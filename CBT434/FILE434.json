{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012022000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 8700328, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 28, "INMDSNAM": "CBT.V500.FILE434.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 8700328, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 8700328, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE434.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x87\\x07'", "DS1TRBAL": "b'\\x89\\x10'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x03 \\x00\\x05\\x03)\\x00\\x05\\x00\\x88'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$$READ": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x000\\x00\\x992/\\x00\\x992/\\x16'\\x00\\n\\x00\\n\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf2\\xf2@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "1999-11-18T16:27:30", "lines": 10, "newlines": 10, "modlines": 0, "user": "CBT422"}, "text": "      D I S C L A I M E R\n      -------------------\n\n    The files contained in this PDS are FREEWARE. Use at your own\n    risk.  Neither Mark Zelden, nor other contributing organizations\n    or individuals accept any liability of any kind howsoever\n    arising out of the use of these files. You are free to use and\n    modify these files as you desire, however, the author does ask\n    that you leave his name in the files and give credit to him as\n    the original programmer.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$$#DATE": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x008\\x01 5\\x0f\\x01 5\\x0f#\\x08\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf5\\xf0\\xf0@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "2020-12-15T00:00:00", "modifydate": "2020-12-15T23:08:38", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-500"}, "text": "REGULAR CBT TAPE - VERSION 500    FILE:  434\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT500.FILE434\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 135 MEMBERS COUNTED; CUMULATIVE SIZE IS 81,656 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   12/15/20    23:08:38    UTC-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$INDEX": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x011?\\x01\\x19\\x11O\\x15\\x00\\x00\\xc6\\x00r\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf9\\xf7@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2001-11-09T00:00:00", "modifydate": "2019-04-24T15:00:00", "lines": 198, "newlines": 114, "modlines": 0, "user": "CBT497"}, "text": "    Sample JOBs / Documentation\n    ---------------------------------------------------------------\n    $$$$READ  - Disclaimer\n    $$$INDEX  - Index of all members\n    $$CHANGE  - CBT File 434 change log\n    $$INSTAL  - General installation documentation for this file\n    $ONEPAK   - Doc for using DFSMSdss instead of FDRCOPY for\n                ONEPAK / TWOPAK jobs.\n    $ROOTSHR  - Doc for setting up a shared UNIX root file\n    $RXINTRO  - Doc to download and use RXINTRO member\n    $SNGLTSO  - Doc for using the same TSO USERID in a shared\n                environment.\n    $WLMMONO  - Doc for setting up WLM in a MONOPLEX\n    CLONERES  - Sample jobstream to clone a two volume sysres set\n                and SMP/E target zones.\n    CLONERSO  - Old version of CLONERES.\n    ISPDFLTS  - ISPF defaults source update needed for single TSO\n                USERID (described in $SNGLTSO).\n    ISPEX16   - ISPXDT and ISPF exit 16 source needed for single\n                TSO USERID (described in $SNGLTSO).\n    ONEPAKZ3  - Sample jobstream to build a one pack \"rescue\"\n                system from a z/OS 1.3 driving system.\n    ONEPAKZ6  - Sample jobstream to build a one pack \"rescue\"\n                system from a z/OS 1.6 driving system.\n    ONEPAKZ8  - Sample jobstream to build a one pack \"rescue\"\n                system from a z/OS 1.7 - z/OS 1.11 driving system.\n    ONEPAKZD  - Sample jobstream to build a one pack \"rescue\"\n                system from a z/OS 1.12 - z/OS 1.13 driving system.\n    ONEPAK21  - Sample jobstream to build a one pack \"rescue\"\n                system from a z/OS 2.1 driving system.\n    ONEPAK22  - Sample jobstream to build a one pack \"rescue\"\n                system from a z/OS 2.1 driving system.\n    ONEPAK22  - Sample jobstream to build a one pack \"rescue\"\n                system from a z/OS 2.2 driving system.\n    ONEPAK43  - Sample jobstream to build a one pack \"rescue\"\n                system (created for ESA 4.3, but is still a good\n                sample of the required steps).\n    RXINTRO   - \"Introduction to TSO/E REXX\" Word document\n    SMPBLD1   - Job to build an SMP/E environment from scratch.\n                All VSAM SMP/E zones are created within the same\n                physical VSAM data set.\n    SMPBLD2   - Job to build an SMP/E environment from scratch.\n                The VSAM SMP/E zones are created as separate\n                physical VSAM data sets.\n    SMPBLD3   - Job to build a new SMP/E target zone, dlib zone,\n                and other required SMP/E data sets into an\n                existing global zone.\n    SMPDELF   - Sample job to delete a FMID from a set of SMP/E\n                zones and libraries.\n    TWOPAKZ3  - Sample jobstream to build a two pack \"rescue\"\n                system from a z/OS 1.3 driving system. Same as\n                ONEPAKZ3 but also includes Unix System Services,\n                TCP/IP, and ISHELL.\n    TWOPAKZ6  - Sample jobstream to build a two pack \"rescue\"\n                system from a z/OS 1.6 driving system. Same as\n                ONEPAKZ6 but also includes Unix System Services,\n                TCP/IP, and ISHELL.\n    TWOPAKZ8  - Sample jobstream to build a two pack \"rescue\"\n                system from a z/OS 1.7 - z/OS 1.11 driving system.\n                Same as ONEPAKZ8 but also includes Unix System\n                Services, TCP/IP, and ISHELL.\n    TWOPAKZD  - Sample jobstream to build a two pack \"rescue\"\n                system from a z/OS 1.12 - z/OS 1.13 driving system.\n                Same as ONEPAKZD but also includes Unix System\n                Services, TCP/IP, and ISHELL.\n    TWOPAK21  - Sample jobstream to build a two pack \"rescue\"\n                system from a z/OS 2.1 driving system.\n                Same as ONEPAK21 but also includes Unix System\n                Services, TCP/IP, and ISHELL.\n    TWOPAK22  - Sample jobstream to build a two pack \"rescue\"\n                system from a z/OS 2.2 driving system.\n                Same as ONEPAK22 but also includes Unix System\n                Services, TCP/IP, and ISHELL.\n    TWOPAK23  - Sample jobstream to build a two pack \"rescue\"\n                system from a z/OS 2.3 driving system.\n    UMJES01   - JES2 source update needed for single TSO USERID\n                (OS/390 R10 & z/OS R1 - described in $SNGLTSO).\n    UMJES012  - JES2 source update needed for single TSO USERID\n                (z/OS R2 and above - described in $SNGLTSO).\n    UMJES01O  - JES2 source update needed for single TSO USERID\n                (prior to OS/390 R10 - described in $SNGLTSO).\n    UMJES06   - JES3 source update needed for single TSO USERID\n                (described in $SNGLTSO).\n\n\n    CLISTS / Edit Macros / REXX execs / Programs\n    ---------------------------------------------------------------\n    ACBCHECK  - ASM PGM to check if a VTAM APPLID is available\n    AMBCLIST  - CLIST to invoke interactive AMBLIST with panel I/P\n    APFVER    - REXX exec to verify APF list\n    ASIDLIST  - ASM PGM to list ASIDs & MAXUSER/RSVSTRT/RSVNONR\n    ASIDLRX   - REXX PGM to list ASIDs & MAXUSER/RSVSTRT/RSVNONR\n    BLKCLIST  - CLIST to invoke BLKDISK command with panel input\n    CAT       - REXX exec to invoke CATSRCH via CATSRCHP panel\n    CATSRCH   - REXX exec to invoke Catalog Search Interface (CSI)\n    CMD34     - REXX exec to process commands against a DSLIST\n    COLADD    - Edit macro to add numbers from a column range\n    COLUTIL   - Edit macro to manipulate columns\n    DB        - Edit macro to delete lines from the cursor line\n                to the bottom line\n    DELDUPS   - Edit macro to delete duplicate lines\n    DELDUPS2  - REXX duplicate record deletion program\n    DELNX     - Edit macro to delete all of a certain string\n    DELX      - Edit macro to delete everything but a certain\n                string\n    DT        - Edit macro to delete lines from the cursor line\n                to the top line\n    EDMACALL  - REXX exec to run an edit macro against every\n                member of a PDS.\n    EXCL      - Edit macro to exclude all of certain string\n    FILL      - Edit macro to fill columns with a character\n    FINDMOD   - REXX exec (command) to find what library(s) a\n                module is in\n    FINDASYS  - Sample search list for FINDMOD CLIST\n    FVE       - REXX exec (command) - Fast View/Edit of DSNs\n    HLISTB    - REXX exec to browse o/p of HLIST DA BCDS (BACKUP)\n    HLISTBL   - REXX exec to browse o/p of HLIST DA LEVEL BCDS\n    HLISTM    - REXX exec to browse o/p of HLIST DA MCDS (MIGRATE)\n    HLISTML   - REXX exec to browse o/p of HLIST DA LEVEL MCDS\n    INCL      - Edit macro to include all of a certain string\n    INDIRECR  - REXX exec to create IDCAMS control cards for\n                indirectly catalogging a list of data set names\n    INSLINE   - Edit macro to insert a string after or before lines\n    IPLHIST   - REXX exec to create a history of IPLs. This exec\n                calls IPLINFO as a function.\n    IPLINFO   - REXX exec to show various system information\n    ISPCMDSA  - CLIST to add temporary cmds to ISPF command table\n    JOBCHECK  - ASM PGM to find if a JOB is active on the system\n    JOBCHKRX  - REXX PGM to find if a JOB is active on the system\n    KEYSWAP   - REXX exec to swap PFKEYS 1-12 with PFKEYS 13-24\n    LASTIPL   - REXX exec to display last (latest) IPLHIST info\n    LINEMAC   - REXX exec - used with Doug Nadel's / IBM's LMAC PGM\n    LINETBL   - Sample ISPF table to use with ISPF line edit macros\n    LMPREXX   - REXX exec to help manage CA LMP KEYS\n    LOGRREXX  - REXX program to build logstream DELETE/DEFINE cards\n                using the output from IXCMIAPU LIST LOGSTREAM.\n    LNKVER    - REXX exec to verify LNKLST syntax and libs\n    LPROG     - REXX exec - displays LNKLST, LPA list, & APF list\n    PREFIX    - Edit macro to add a prefix to the front of a line\n    PREFIX2   - Edit macro to add a prefix to the front of a line\n    RACFUDEL  - REXX program to remove obsolete RACF users\n    RDATE     - REXX date conversion routine\n    RDATEF    - REXX function version of RDATE\n    REXXMEM   - REXX program to browse memory in \"dump\" format\n    REXXSCAN  - REXX program to scan an input file for string(s)\n    REXXSTOR  - REXX exec to show virtual storage usage of invoker\n    REXXSTOJ  - Sample JCL to run REXXSTOR in batch\n    RXSTOR64  - REXX exec to show 64-bit MEMLIMIT and storage use\n    SDSF@DR   - REXX program to that uses the SDSF REXX environment\n                to copy output from the spool into data sets.\n    SUFFIX    - Edit macro to add a suffix to the end of a line\n    SW        - Edit macro to switch from VIEW to EDIT or visa versa\n    TAPESTAK  - REXX tape stacking program (works with CA-1)\n    TSOB      - REXX exec (command) to BROWSE o/p of any TSO cmd\n    TSOE      - REXX exec (command) to EDIT o/p of any TSO cmd\n    TSOR      - REXX exec (command) to REVIEW o/p of any TSO cmd\n    TSOV      - REXX exec (command) to VIEW o/p of any TSO cmd\n    VTOCTOT   - REXX program to summarize VTOC cmd output by HLQ\n    XBROWSE   - REXX (command) to browse any dataset\n    XDSLIST   - REXX (command) to display a data set list (ISPF 3.4)\n    XEDIT     - REXX (command) to edit any dataset\n    XEF       - REXX exec to start eXtended Editor Facility dialog\n    XEFLIBD   - REXX exec to start eXtended Editor Facility dialog\n    XEFCLIST  - eXtended Editor Facility mainline code\n    XLISTC    - REXX (command) to LISTCAT ALL any dataset\n    XMEMLIST  - REXX (command) to bring up member list on any DSN\n    XVIEW     - REXX (command) to view any dataset\n    ZBROWSE   - Edit macro to browse dataset that the cursor is on\n    ZEDIT     - Edit macro to edit dataset that the cursor is on\n    ZVIEW     - Edit macro to view dataset that the cursor is on\n\n\n    ISPF Panels\n    ---------------------------------------------------------------\n    AMBPANEL  - Interactive AMBLIST panel for AMBCLIST\n    BLKPANEL  - Interactive BLKDISK panel for BLKCLIST\n    CATSRCHP  - Optional panel for invoking CATSRCH REXX exec\n    XEFMENU   - eXtended Editor Facility Main Menu\n    XEFMENUB  - eXtended Editor Facility Main Menu (optional)\n    XEFHELP   - eXtended Editor Facility Help Panel #1\n    XEFHELP2  - eXtended Editor Facility Help Panel #2\n    XEFHELP3  - eXtended Editor Facility Help Panel #3\n    XEFHELP4  - eXtended Editor Facility Help Panel #4\n    XEFINF    - eXtended Editor Facility Dataset Info Panel-SEQ\n    XEFINFD   - eXtended Editor Facility Dataset Info Panel-PDS\n    XEFINFE   - eXtended Editor Facility Dataset Info Panel-PDSE\n    XEFINFP   - eXtended Editor Facility Dataset Info Panel-PDS SMS\n    XEFINFS   - eXtended Editor Facility Dataset Info Panel-SEQ SMS\n\n\n    ISPF MESSAGEs\n    ---------------------------------------------------------------\n    XEF00     - eXtended Editor Facility Messages\n\n\n    Miscellaneous\n    ---------------------------------------------------------------\n    XEF62     - XEF V6.2 in TSO XMIT format\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$CHANGE": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x992/\\x01 &\\x8f E\\x03\\xdc\\x00\\xd0\\x00\\x00\\xc3\\xc2\\xe3\\xf5\\xf0\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "2020-09-24T20:45:00", "lines": 988, "newlines": 208, "modlines": 0, "user": "CBT500"}, "text": "          ***************************\n          * CBT File 434 Change Log *\n          ***************************\n\n\n\n\n CBT500   ???????  20yy\n09/24/2020 - IPLINFO Updates:\n             1) Add JES2 node offset and JES3 FMIDs for z/OS 2.4.\n             2) Add IPA updates for z/OS 2.4: RUCSA and BOOST.\n             3) Changed the max symbol length in the Symbol display\n                from 10 (8 max + ampersand and period) to 18 for\n                z/OS 2.2 and above (16 max + ampersand and period).\n\n\n CBT499   May 2020\n05/06/2020 - Added the SDSFPRT program. This program uses the SDSF\n             REXX environment to take all or selected output from\n             the spool and copy it to a PDS via SDSF \"PRINT\"\n             commands.\n\n\n CBT498   December 2019\n08/28/2019 - Updated the SDSF@DR REXX to change the \"ST\" panel\n             invocation from:\n             Address SDSF \"ISFEXEC ST (DELAYED ALTERNATE)\"\n               to\n             Address SDSF \"ISFEXEC ST (DELAYED)\"\n             in case no alternate panel is defined.  By\n             default both primary and alternate fields are\n             merged if an alternate exists anyway.\n07/01/2019 - Added the DSLISTSV and MEMLSTSV CLIST and REXX EXEC.\n06/17/2019 - For z/OS 2.3 and above, added IPA updates for SMFTBUFF,\n             OSPROTECT, ICSF and ICSFPROC.\n             SMFTBUFF was added via APAR OA52828.\n             OSPROTECT was added via APAR OA54807.\n             ICSF / ICSFPROC was added via APAR OA55378.\n06/17/2019 - Updated the \"GET_CPCSI\" code in IPLINFO for a larger\n             offset into IRALCCT to get the CPC SI info for all\n             z/OS 2.3 systems.  The previous change only did it for\n             a z14, but the fix is also needed for z13. The problem\n             is that I don't know what APAR / PTF makes the larger\n             offset required nor if it is processor specific.\n\n\n CBT497   April 2019\n04/24/2019 - Added the TWOPAK23 job. This is an update to the\n             TWOPAK22 job and can be used to create a \"rescue\"\n             system from a z/OS 2.3 driving system.\n04/24/2019   Updated the comments in the TWOPAK22 job. Changes\n             from TWOPAK21 were accidentally left out of the\n             comments section.  I also removed the comments\n             that stated the job could be also be used for\n             for z/OS 2.3 since there is now a separate sample\n             job for z/OS 2.3.\n03/06/2019 - Updated the \"GET_CPCSI\" code in IPLINFO for a larger\n             offset into IRALCCT to get the CPC SI info for z/OS 2.3\n             at RSU1812 and above running on a z14 (the offset is an\n             additional 8 bytes).  I don't know what PTF(s) broke it\n             or if there is a similar change for OS versions lower\n             than z/OS 2.3.\n01/03/2019 - Added a \"REVerse\" mode to CMD34 to process the data\n             set list in reverse order.  \"REVerse\" mode is useful\n             when you are trying to delete GDGs plus the GDG\n             base(s) in the data set list, otherwise the command\n             will fail against the GDG base since there are still\n             GDGs that exist in the base.\n\n\n CBT496   November 2018\n10/12/2018 - Added the ONEPAK22/TWOPAK22 jobs. These are updates to\n             the ONEPAK21/TWOPAK21 jobs and can be used to create a\n             \"rescue\" system from a z/OS 2.2 driving system. They\n             should work for z/OS 2.3 also with no changes.\n\n10/12/2018 - Updated the SDSF@DR REXX to check for\n             \"*BOTTOM OF DATA REACHED*\" so it is not displayed as\n             an error message from XDC. I'm not sure when IBM added\n             this as the code was written in 2009. It may have been\n             in z/OS 2.1.\n\n\n CBT495   January 2018\n12/01/2017 - IPLINFO Updates:\n             1) Add IPA updates for z/OS 2.3: RACF, FXE & IZU.\n             2) Add JES2 node offset and JES3 FMIDs for z/OS 2.3.\n             3) Fix catalog information display in IPL section when\n                LOADxx SYSCAT definition is blank / using defaults\n                for SYS% to SYS1 conversion (col. 16) and/or alias\n                name level (col. 17).\n             4) Change RACF version information to match the z/OS\n                version instead of the FMID for z/OS 2.2 and above.\n                RCVTVRMN always has 7791 starting with z/OS 2.2\n                which is not correct.\n             5) Add \"AUX\" undocumented alias for the \"PAGE\" option.\n04/29/2017 - Added RXSMF30 program.  This is a REXX sample to read\n             SMF 30 records to produce a job accounting report.\n\n\n CBT492   August 2016\n10/11/2016 - IPLINFO Updates:\n             1) Add IPA updates for z/OS 2.2: SMFLIM & IEFOPZ.\n             2) Add JES2 node offset and JES3 FMIDs for z/OS 2.2.\n             3) Add some additional SMS information from the SMS\n                SSI Vector Table.\n             4) Add \"EDIt\" option that can be specified as the\n                3rd parm to edit the output, similar to the\n                Nobrowse option. Also changed the check in the\n                XLATE_NONDISP subroutine from \"> '00'x\" to \">=\n                '00'x\" after seeing a subsystem with x'00' as\n                part of the name in the edited output (and the\n                ISPF warning about invalid / non-display\n                characters).\n             5) Add 2G page information to LFAREA display in the\n                VMAP section.\n             6) Fixed a rounding problem in the \"FORMAT_MEMSIZE\"\n                subroutine for sizes over 1024G that should be\n                displayed using \"M\" instead. The problem was seen\n                in the HVSHARE display in the VMAP section.\n08/27/2016 - Add 2G page information to LFAREA display in RXSTOR64\n             and also added a \"NODETAIL\" option so only system\n             wide totals are displayed for HVSHARE/HVCOMMON/LFAREA.\n08/27/2016 - Fixed a rounding problem in the \"FORMAT_MEMSIZE\"\n             subroutine for sizes over 1024G that should be\n             displayed using \"M\" instead in the following EXECs:\n             IPLINFO, RXSTOR64, REXXSTOR\n08/21/2016 - Added a \"Showdups\" option to the DELDUPS edit macro\n             which will show the duplicate lines instead of deleting\n             them.\n\n\n CBT491   July 2016\n05/15/2016 - Add code to LOGRREXX to remove LS_ALLOCAHEAD(0) if\n             system is not z/OS 2.2. The parm is added to lower\n             level systems after OA44680 for z/OS 2.2 toleration.\n04/04/2016 - IPLINFO Updates:\n             1) Reverted change from 3/12/2015 that changed the\n                method of finding the real storage online at IPL for\n                z/OS 2.1 and above. IBM opened APAR OA48094 to fix\n                the original problem.\n             2) Add an undocumented option alias: SSN for SUBsystems.\n04/04/2016 - Updated the assembler ASIDLIST and JOBCHECK programs\n             to support the ASVT in 31-bit storage which is available\n             via DIAGxx CBLOC in z/OS 2.1 and above.\n\n\n CBT490   November  2015\n05/21/2015 - Change IPLINFO LFAREA display in z/OS 2.1 and above\n             to include PAGEABLE1M allocations.  Before the change\n             these are incorrectly reported as 4K allocations on\n             z/OS 2.1.\n05/21/2015 - Change RXSTOR64 LFAREA total display in z/OS 2.1 and\n             above to include PAGEABLE1M allocations.  Before the\n             change these are incorrectly reported as 4K allocations\n             on z/OS 2.1.\n05/20/2015 - Fix truncation of \"PARESZSL\" in the IPLINFO page data\n             set display to support the number of slots possibly\n             defined on a 3390-54.\n05/14/2015 - Add offset change into IRALCCT for CPC SI info as a\n             comment in IPLINFO for z/OS 1.13 with z13 maintenance\n             applied.\n03/12/2015 - IPLINFO updates:\n             1) Change method of finding online storage at IPL time\n                for z/OS 2.1 and above as CVTRLSTG was not always\n                correct. A field from the RIT is used instead.\n             2) Add code to show SCM (Storage Class Memory) usage\n                to the \"PAGE\" section similar to \"D ASM,SCM\"\n                output for z/OS 2.1 and above.\n01/29/2015 - Updated the REXXMEM memory display utility to work with\n             64-bit addresses.  Using 64-bit addresses requires\n             z/OS 2.1 or above.\n\n\n CBT489   November 2014\n10/27/2014 - Added the ONEPAK21/TWOPAK21 jobs. These are updates to\n             the ONEPAKZD/TWOPAKZD jobs and can be used to create a\n             \"rescue\" system from a z/OS 2.1 driving system.\n\n\n CBT488   June 2014\n05/07/2014 - IPLINFO updates for z/OS 2.1:\n             1) Updated GET_CPCSI code for larger offset into\n                IRALCCT to get the CPC SI info for z/OS 2.1.\n             2) Added JES2 node offset and JES3 FMIDs for z/OS 2.1.\n             3) IPA additions for z/OS 2.1 - 5 IEASYSxx PARMs:\n                  PAGESCM, WARNUND, HZS, GTZ and HZSPROC.\n05/07/2014 - Updated the REXXMEM help panel.\n05/07/2014 - Updated the SMPDELF sample job for deleting\n             an SMP/E function.\n05/07/2014 - Updated $SNGLTSO doc related to JES3 for z/OS 2.1.\n05/01/2014 - Added LFAREA system totals into the VMAP section\n             of IPLINFO similar to the \"D VS,LFAREA\" operator\n             display output.\n11/22/2013 - Added code to IPLINFO to split the \"Supported Subsystem\n             Function Codes\" display for a given subsystem across\n             multiple lines if needed to avoid truncation.\n11/13/2013 - Updated REXXMEM to support indirect storage addressing\n             similar to IPCS.\n11/01/2013 - XEF:  Changed the check in XEFCLIST for a null data set\n             name in the data set list to be after the code to\n             process the \"FIND\" option. Version is now 6.4.3\n\n\n CBT487   October 2013\n10/07/2013 - Added \"Help\" to the following edit macros:\n             COLADD, COLUTIL, DELDUPS, DELNX, DELX, EXCL, FILL,\n             INCL, INSLINE, PREFIX, PREFIX2, SUFFIX.\n             Also added a check into \"FILL\" to make sure the fill\n             data would fit within the columns specified.\n10/07/2013 - Updated the \"FIND_LABELS\" routine in the following\n             edit macros to a better / simpler version:\n             COLADD, COLUTIL, FILL, INSLINE, PREFIX, PREFIX2, SUFFIX\n10/01/2013 - Updated the DELDUPS edit macro to allow labels to be\n             used to limit the range of the operation.\n08/23/2013 - Added code to IPLINFO to display the ACF2 data set\n             names currently in use plus removed equal sign from\n             \"CLPA=\" and \"CVIO=\" in the IPA display.  These parms\n             have no value when specified in IEASYSxx.  Also\n             changed the code that checks for CLPA used at IPL\n             time to look at a specific BIT in ASMFLAG2.\n\n\n CBT486   April 2013\n01/17/2013 - XEF Changes - version is now 6.4.2:\n             1) Blank out the saved \"F\" in the option field if any\n                data sets are found that match the search string.\n             2) Change XEFMENU panel so the command field is now\n                the \"Other DSN\" field instead of the option field\n                so options that conflict with scrolling remain\n                in the option field while scrolling the list of\n                data sets (M, D, & P). Also added code to the panel\n                to allow the full option name to be used instead of\n                a single character.  For example: \"EDIT\" instead of\n                \"E\", \"BROWSE\" instead of \"B\" etc.\n01/17/2013 - Added additional comments in the source code of IPLHIST\n             that describe how to use it.\n\n\n CBT485   December 2012\n\n10/22/2012 - Changed the method IPLINFO uses to get the RACF primary\n             data set name and also display the backup data set and\n             multiple (split) data sets if they exist.\n\n\n CBT484   July 2012\n\n07/05/2012 - Added the ONEPAKZD/TWOPAKZD jobs. These are updates to\n             the ONEPAKZ8/TWOPAKZ8 jobs and can be used to create a\n             \"rescue\" system from a z/OS 1.12 or z/OS 1.13 driving\n             system. ONEPAKZ8/TWOPAKZ8 were also updated with some\n             changes to the comments.\n06/18/2012 - XEF Changes - version is now 6.4.1:\n             1) Force \"DSLIST\" option when a data set\n                is chosen from the menu that contains a pattern.\n             2) Added delete member confirmation for the XEF member\n                list and also honor the CONFIRM setting.\n06/18/2012 - Added delete member confirmation for XMEMLIST and also\n             honor the CONFIRM setting.\n06/18/2012 - Added new \"LINETBL\" table sample for supporting ISPF\n             line macros natively in z/OS 1.13 (ISPF 6.3) and above.\n04/10/2012 - Updated the ISPF Considerations section of the $SNGLTSO\n             doc member related to ISPF profile sharing and z/OSMF.\n03/19/2012 - IPLINFO Updates:\n             1) Added JES2 node offset and JES3 FMIDs for z/OS 1.12\n                and z/OS 1.13.\n             2) Added new parms to the IPA display: AUTOR for\n                z/OS 1.12 and above and CATALOG / IXGCNF for\n                z/OS 1.13 and above.\n             3) Remove RTLS from the IPA display for z/OS 1.13\n                and above.\n02/13/2012 - Changed description of SVCESRMX in IPLINFO SVC display\n             of ESRs from \"Max Entries\" to \"Max ESR Num Supported\".\n01/03/2012 - Added an \"SVC\" option / display to IPLINFO and made the\n             help panel scrollable. Also added the IPL TOD (GMT) from\n             from the IPA to the IPA section.\n\n\n CBT483   December 2011\n\n08/19/2011 - Added LSQA usage to REXXSTOR and changed the way\n             \"Region Available\" is calculated.  The new method is\n             a better estimation and considers LSQA usage.\n08/04/2011 - Fixed 2 errors in IPLINFO identified by the REXX\n             compiler and add a few undocumented option aliases:\n             SSI / SUBsystems for SUB and MEMory for STOrage.\n06/27/2011 - Added a FIND option to XEF.  The XEF version has been\n             changed from 6.3 to 6.4.\n\n\n CBT482  June 2011\n\n06/06/2011 - Enhanced RXSTOR64 to show LFAREA breakout for 1M and 4K\n             page usage in the totals similar to the \"D VS,LFAREA\"\n             command on z/OS 1.12 or z/OS 1.10 and z/OS 1.11 with\n             APAR OA31116 appled.\n04/15/2011 - Fixed display for HMC LPAR ID to support 2 character\n             hex numbers (LPAR ID > x'F') in IPLINFO.\n04/04/2011 - Updated IPLINFO to show the GRS mode (NONE/RING/STAR).\n03/04/2011 - Updated the following execs to reference my new web\n             site URL: APFVER, CATSRCH, FINDMOD, IPLINFO, LPROG,\n             REXXMEM, and RXSTOR64.\n\n\n CBT479  August 2010\n\n07/19/2010 - Added an option to IPLINFO to change the delimiter\n             between returned variables from a blank to \"user\n             defined\" when IPLINFO is called as a REXX function.\n             Also added z/OS 1.11 JES2 node table offset & JES3 FMID.\n04/06/2010 - Added the IPLHIST and LASTIPL REXX execs.\n03/29/2010 - Added the SDSF@DR program. See source code for details.\n03/04/2010 - Added comments to ONEPAKZ8 and TWOPAKZ8 that detail\n             the changes needed to build a z/OS 1.11 system.\n02/01/2010 - Added \"ZZ\" (zAAP on zIIP) display to the IPA section\n             of IPLINFO for z/OS 1.10 and above.\n01/06/2010 - Fixed large memory object usage displays in RXSTOR64\n             for ASID level displays and the total display. The\n             calculations were treating the control block values\n             as 4K pages and converting them to megabytes when\n             they were already in megabytes by definition.\n\n\n CBT478  December 2009\n\n12/22/2009 - Updated LOGRREXX to ignore HLQ(NO_HLQ) when creating\n             define cards. EHLQ(NO_EHLQ) was already being ignored.\n09/02/2009 - Added comments to ONEPAKZ8 and TWOPAKZ8 that detail\n             the changes needed to build a z/OS 1.10 system.\n08/20/2009 - Changes to TAPESTAK. See comments in source code.\n08/14/2009 - Added FVE REXX exec - Fast View/Edit of data sets.\n             This REXX exec is intended to work with ISPF command\n             table entries to create \"shortcuts\" for VIEWing or\n             EDITing data sets or data set concatenations. There are\n             already examples of adding the command table entries\n             dynamically in the ISPCMDSA CLIST. See the source for\n             full details.\n08/14/2009 - Changed the column indicator line in the IPLINFO\n             IPA display from a length of 70 to 72.\n06/08/2009 - Updated RXSTOR64 to display ASID level large memory\n             objects for z/OS 1.9 and above (with supporting\n             hardware) and ASID level 64-bit common storage usage\n             for z/OS 1.10 and above. Also added system wide usage\n             summaries for 64-bit shared virtual (HVSHARE), 64-bit\n             large memory objects (large / 1M page support) and\n             64-bit common storage (HVCOMMON) at the appropriate\n             software levels.\n05/29/2009 - IPLINFO updates:\n             1) Use GDATotalCSAHWM & GDATotalECSAHWM instead of\n                GDACSAHWM & GDAECSAHWM for CSA/ECSA HWM in VMAP\n                section for z/OS 1.10 and above.\n             2) Add 64-bit common storage display (HVCOMMON) to\n                to VMAP section for z/OS 1.10 and above.\n             3) Change numeric digits from 12 to 20 and add 64-bit\n                shared storage display (HVSHARE) to VMAP section\n                for z/OS 1.5 and above.\n             4) Support logical processor add in z/OS 1.10 + z10 in\n                CPU display for \"maximum number of CPUs\".\n             5) Removed equal sign from \"PRESCPU=\" in IPA display.\n                This parm has no values when specified in IEASYSxx.\n03/26/2009 - Added $ONEPAK doc member for creating ONEPAK / TWOPAK\n             systems using DFSMSdss instead of FDRCOPY.\n03/16/2009 - Changed the wording in the SMF logstream \"toleration\"\n             message for IPLINFO and added an undocumented alias\n             of \"ASM\" for the \"PAGE\" option.\n02/20/2009 - Updates to the \"FORMAT_MEMSIZE\" subroutine in RXSTOR64\n             and REXXSTOR to allow for the possibility of a MEMLIMIT\n             value greater than 16 exabytes (64-bit max) being stored\n             in the RAX.  The problem was reported in RXSTOR64 with\n             Health Checker in z/OS 1.10.\n02/09/2009 - Changes to IPLINFO to tolerate SMF LOGSTREAM usage.\n01/21/2009 - IPLINFO updates:\n             1) Added \"CPC SI\" (STSI information) to the CPC display\n                in the CPU section for z/OS 1.2 and above.\n             2) Added new IPA fields for z/OS 1.10.\n             3) Added z/OS 1.10 JES2 node table offset and JES3 FMID.\n\n\n CBT477  January 2009\n\n12/19/2008 - Added new ACBCHECK program.\n10/29/2008 - Added a display for HiperDispatch status to the CPU\n             section of IPLINFO for z/OS 1.8 and above.\n10/29/2008 - Added additional information to REXXSTOR (\"Region Size\"\n             and \"Max Priv Reg Size\") and changed the output display\n             to make it more readable.\n10/03/2008 - Changed \"arg\" to \"parse arg\" in TSOB, TSOE, TSOV and TSOR\n             to prevent case translation of commands being passed to\n             the execs.\n09/12/2008 - IPLINFO updates:\n             1) Fixed check in IPA for values present in z/OS 1.7\n                and above.  Byte 4 of CVTOSLVL was being checked\n                instead of byte 5.\n             2) Added LFAREA to the IPA display for z/OS 1.9 and above.\n             3) Added CADS (MAXCADs) used and HWM displays for z/OS 1.7\n                and above to the STORage section.\n             4) Changed \"NUMERIC DIGITS\" from 10 to 12.\n             5) Added reconfigurable storage size and potential real\n                storage size to the STORage section.\n07/24/2008 - IPLINFO updates:\n             1) Added CSS ID in the IPL section.\n             2) Added microcode level in the CPU section.\n             3) Added real storage increment size and number of\n                increments installed to the storage section.\n07/22/2008 - Added better error checking and messages to FINDMOD and\n             also comments about turning \"FINDMOD\" into \"FINDPROC\".\n06/24/2008 - Updated the ISPF Considerations section of the $SNGLTSO\n             doc member with information about ISPF profile sharing\n             that is available in z/OS 1.9 and above.\n06/06/2008 - IPLINFO updates:\n             1) Added a NOBrowse option so output would not go to\n                an ISPF browse dataset if desired when IPLINFO is\n                invoked from ISPF.\n             2) Removed the \"IPS=\" reference from the IPA display\n                for systems at z/OS 1.3 and higher.\n             3) Indented the output from the \"Supported Subsystem\n                Function Codes\" display to be consistent with\n                other section output displays.\n04/29/2008 - Updated TWOPAKZ8 job to add ZFS support, separate\n             TN3270 from TCPIP and add Unicode.  This allows\n             the TWOPAKZ8 job to be used with z/OS 1.7 through\n             z/OS 1.9. Also added comments about creating userids\n             with non-expiring passwords and turning off RACF\n             inactive auto-revoke.\n04/29/2008 - Updated comments in ONEPAKZ8 to say it could be used\n             for z/OS 1.7 through z/OS 1.9.  Also added comments\n             about creating userids with non-expiring passwords\n             and turning off RACF inactive auto-revoke.\n\n\n CBT476  April 2008\n\n04/16/2008 - Added HLISTB, HLISTBL, HLISTM and HLISTML execs for\n             browsing the output of HLIST BCDS (backup) and HLIST\n             MCDS (migrate) commands for a specific data set or\n             by data set level.\n04/16/2008 - Updated LOGRREXX to handle pending changes to logstreams.\n03/07/2008 - Updated RXSTOR64 to change the \"HIDDEN MEM\" column\n             heading to \"GUARDED MEM\" and added a note about\n             APAR OA02888.\n01/30/2008 - Updated TWOPAKZ8 job to create a null SMS configuration.\n             See comments in the job for the reason.\n\n\n CBT475  December 2007\n\n12/13/2007 - Updated LPROG to add the IEASYSxx LNKAUTH setting\n             (either LNKLST or APFTAB) to the LNKLST display heading.\n12/04/2007 - Fixed REXX NOVALUE condition in IPLINFO RDATE subroutine.\n             Also made the same change to RDATE and RDATEF even though\n             SIGNAL ON NOVALUE is not used in those versions.\n11/28/2007 - Updated CLONERES job and added old version as CLONERSO.\n11/12/2007 - Updated IPLINFO for z/OS 1.9 JES2 node offset and JES3\n             FMID. Also added the IEASYSxx LNKAUTH setting (either\n             LNKLST or APFTAB) to the LNKLST display heading.\n10/09/2007 - Added error traps for SYNTAX and NOVALUE conditions\n             to IPLINFO.\n10/09/2007 - Updated the following execs that use ISPF panels to\n             use ISPF services to create temporary ISPPLIB PDS\n             members instead of REXX EXECIO: APVFER, CATSRCH,\n             FINDMOD, IPLINFO, LPROG, REXXMEM and RXSTOR64.\n08/27/2007 - Fixed an error in RXSTOR64 for displaying shared memory\n             objects. RAXLVSHRNMOMB was coded for a length of 4 when\n             it should have been a length of 8.\n08/23/2007 - Added a check to SW to prevent usage when EDIT/VIEW is\n             using the EDIF/VIIF interface.\n08/23/2007 - Made a cosmetic change to the \"FIND_LABELS\" code in the\n             following edit macros:\n             COLADD COLUTIL INSLINE PREFIX PREFIX2 SUFFIX\n\n\n CBT474  August 2007\n\n05/31/2007 - Added CEC MSU, image MSU and 4 hour MSU average usage\n             to the IPLINFO CPU section and a display to show when\n             the LPAR is being \"soft capped\".  Also re-added the\n             code to create the ISPPLIB as a pemanent data set for\n             systems below OS/390 2.10.\n05/24/2007 - Added the ONEPAKZ8/TWOPAKZ8 jobs. These are updates to\n             the ONEPAKZ6/TWOPAKZ6 jobs and can be used to create a\n             \"rescue\" system from a z/OS 1.7 or z/OS 1.8 driving\n             system.\n05/07/2007 - Updated INSLINE so it works with strings that contain\n             an ampersand.\n05/01/2007 - Changed the following edit macros so they allow the\n             usage of system lables .ZFIRST/.ZF and .ZLAST/.ZL:\n             COLADD COLUTIL FILL INSLINE PREFIX PREFIX2 SUFFIX\n04/27/2007 - Added a display of the LOADPARM device address to the\n             IPA section of IPLINFO.\n04/27/2007 - Added new EXECs TSOV and TSOR (similar to TSOE/TSOB).\n             TSOR uses the REVIEW command from CBT file 134 or 135\n             and can be used under native TSO without ISPF. Also\n             updated the ISPCMDSA sample which adds these commands\n             to the ISPF command table.\n03/23/2007 - IPLINFO updates:\n             1) Added z/OS 1.8 JES2 node offset and added the JES3\n                FMID to the FMID table for z/OS 1.8 JES3.\n             2) Added a display to show the current status of catalog\n                SYS%-SYS1 conversion and current alias level.\n             3) Added a customizable date format option. The default\n                option is to now use ISO 8601 format.\n03/20/2007 - Fixed ISPCMDSA CLIST to work on current ISPF releases.\n             I'm not sure when it broke. Added one line of code.\n03/09/2007 - Updated the following execs that use ISPF panels to\n             create a temporary data set for ISPPLIB instead of a\n             permanent data set: APVFER, CATSRCH, FINDMOD, IPLINFO,\n             LPROG, REXXMEM and RXSTOR64.\n02/16/2007 - Updated INCL, EXCL, DELX, and DELNX so they can work\n             with strings that contain an ampersand.\n01/23/2007 - Added the CMD34 rexx exec.  This exec an be used to\n             issue commands against an ISPF 3.4 type DSLIST.\n\n\n CBT473  January 2007\n\n11/28/2006 - IPLINFO updates:\n             1) Added the ability to abbreviate all options to 3 or\n                more characters. An error message is now displayed\n                if an invalid option is used instead of defaulting\n                to the \"ALL\" option.\n             2) Added a display for the master catalog alias level,\n                the catalog type and SYS% conversion status.\n             3) Added a display for the local time offset from GMT.\n             4) Add displays to the CPU section for maximum number\n                of CPUs and the number of GPs / zAAPs / zIIPs online\n                at IPL time.\n             5) Restructured code to use CVT bits to determine OS\n                levels instead of FMIDNUM or PRODNAME.\n             6) Added SYSNAME/GRSNAME to banner at top of displays.\n             7) Added new LPA, LNKLST and APF display options.\n             8) Increased the number of variables that can be\n                returned from 10 to 20 when IPLINFO is called as\n                a REXX function.\n11/14/2006 - Updated RXSTOR64 and REXXSTOR for new MEMLIMIT source\n             that was added via IBM APAR OA14391.\n10/30/2006 - Added code to RXSTOR64 to bypass ASIDs marked as in-use\n             that don't have a valid RAX.\n\n\n\n CBT472  September 2006\n\n09/06/2006 - Fixed problem with RACF version formatting in IPLINFO on\n             some systems with zIIP support installed.\n08/25/2006 - Updated IPLINFO to include the ACF2 version in the\n             version section for systems running CA-ACF2.\n07/28/2006 - Updated IPLINFO to indicate a zIIP engine in the CPU\n             section and changed the MIPS calculation to exclude\n             zIIP engines.\n07/24/2006 - Updated REXXSTOR to display the MEMLIMIT source.\n06/20/2006 - Added the ability to specify an \"*\" for the member name\n             to process all members with AMBCLIST / AMBPANEL.\n04/03/2006 - IPLINFO updates:\n             1) Added a SMF data set usage display.\n             2) Support for PRESCPU parm in the IPA for z/OS 1.5 and\n                z/OS 1.6 systems with OA09649 applied.\n             3) IPA additions for z/OS 1.7 (CEE, DRMODE, PRESCPU).\n             4) Added code for JES2 node offset for z/OS 1.7 JES2.\n             5) Added the JES3 FMID to the FMID table for z/OS 1.7 JES3.\n             6) Fixed bug in IPA PARMLIB display when there were more\n                than 9 PARMLIBs in the concatenation.\n\n\n CBT471  February 2006\n\n01/20/2006 - Added \"HIDE EXCLUDED\" to the INCL and EXCL edit macros\n             for z/OS 1.6 and above.\n01/05/2006 - Removed ILM parms from IEASYS00 in the ONEPAKZ6 and\n             TWOPAKZ6 jobs.\n\n\n CBT470  December 2005\n\n11/18/2005 - Added the LMPREXX edit macro.  This edit macro helps\n             manage CA LMP keys.\n11/17/2005 - Updated IPLINFO to display the MIF ID in the IPL section.\n11/07/2005 - Updated the SW edit macro to check for changed data\n             prior to switching and added a \"FORCE\" option.\n11/04/2005 - Added RXSTOR64 exec to display 64-bit MEMLIMIT and\n             storage use for all ASIDs running in the system.\n11/03/2005 - Changed IPLINFO to make x'00' a valid display\n             character and changed the check of the architecture\n             level from the IPA to PSA in the common section.\n11/01/2005 - Updated REXXSTOR to display the MEMLIMIT for z/OS 1.2\n             and above.  Also update the REXXSTOJ JCL example.\n10/27/2005 - Updated the ISPF Considerations section of the $SNGLTSO\n             doc member to document caveats related to sharing or not\n             sharing the ISPF profile data set. Also updated the JES2\n             section with notes about NOTIFY=USERID in a JES2 MAS.\n10/05/2005 - Updated CATSRCH to add a period as the last ARG to fix\n             a problem if more than one space is used between the\n             first ARG (filter) and the second ARG (catalog name).\n\n\n CBT469  July 2005\n\n07/08/2005 - Added the CLONERES job. This is a sample jobstream\n             to clone a two volume sysres set and SMP/E target\n             zones.\n06/23/2005 - Added the SMPDELF job.  This is a sample job to remove\n             a FMID from a set of SMP/E zones and libraries.\n06/22/2005 - Updated the REXX function support in IPLINFO to return\n             up to 10 variables instead of only 1 variable.\n06/14/2005 - IPLINFO updates:\n             1) Added an ASID usage display.\n             2) Added REXX function support (see source for details).\n             3) Added \"(WLM)\" to IRD/WLM managed CPUs in CPU display.\n             4) Added check for CVTVERID (user software version) and\n                display it in the version section if present.\n             5) Support for greater than 16 CPs with z/OS 1.6 and\n                above. CPU number is now displayed in hex and also\n                as 2 digits on z/OS 1.6 and above (similar to the\n                D M=CPU operator command).\n06/08/2005 - Updated RDATE to support dates up to 12/31/2172 and\n             added RDATEF which is a REXX function version of RDATE.\n             Also copied updated RDATE version into IPLINFO, RACFUDEL,\n             and TAPESTAK.\n05/09/2005 - Added the ONEPAKZ6/TWOPAKZ6 jobs. These are updates to\n             the ONEPAKZ3/TWOPAKZ3 jobs and can be used to create a\n             \"rescue\" system from a z/OS 1.6 driving system.\n04/28/2005 - IPLINFO updates:\n             1) Added display in CPU section to indicate a zAAP engine\n                and changed the MIPS calculation to not include zAAP\n                engines.\n             2) Changed the system ID display message to indicate that\n             the GRS system id is the SYSNAME and the SMF system ID\n             is the SID.\n04/01/2005 - Fixed bug in DELDUPS2 when trying to work with columns\n             that don't span the entire record.\n02/14/2005 - Added new XDSLIST REXX exec (command).  Also updated\n             the ISPCMDSA sample.\n02/14/2005 - XEF Changes:  Added an additional sample invocation REXX\n             exec for XEF that uses LIBDEFs called XEFLIBD. Removed\n             obsolete code from the )INIT section of XEFMENU.  Also\n             provided an alternate menu panel - XEFMENUB - for XEF 6.3\n             that can be used on any OS/390 system below OS/390 2.10\n             or MVS/ESA V5 (ISPF 4.2 or above is required).  However,\n             no verification is done for valid data set names or\n             patterns when adding the names to the XEF main menu.\n\n\n CBT468  February 2005\n\n02/10/2005 - Added a DSLIST option to XEF with support for data set\n             name patterns. The version has been changed from 6.2 to\n             6.3 and OS/390 2.10 (ISPF V5) or above is now required.\n             XEF 6.2 is still available in TSO XMIT format as member\n             XEFV62.\n\n CBT467  January 2005\n\n12/31/2004 - Added the SW edit macro which allows you to switch an\n             ISPF VIEW session into EDIT and visa versa.\n11/03/2004 - Update to LOGRREXX to prevent possible truncation of some\n             define logstream parameters.  JCL was modified also.\n10/26/2004 - Added new JOBCHKRX and ASIDLRX programs.  These are REXX\n             versions of JOBCHECK and ASIDLIST.\n10/21/2004 - Added USERID and SYSID to XEF Menu title line.\n09/16/2004 - IPLINFO updates:\n             1) Added HVSHARE to IPA display for z/OS 1.5.\n             2) Remove any ILM parms from IPA display for z/OS 1.5.\n             3) Fix HMC LPAR number code in IPL section when CPU(0) is\n                offline (broke when code was changed for z990).\n             4) Change VMAP to show storage from \"the top down\" instead\n                of from \"the bottom up\". An option is given to show\n                it the old way (for now) if desired. See the comments\n                in the source code.\n08/25/2004 - Updated the ISPF Considerations section of the $SNGLTSO\n             doc member to state that ISPF exit 16 is no longer\n             required at z/OS 1.5 and above since the configuration\n             table now supports the use of Static System Symbols.\n08/24/2004 - Added RELADDR=ASNEEDED to SPOOLDEF in ONEPAKZ3/TWOPAKZ3.\n08/24/2004 - Added new LOGRREXX program.\n\n\n CBT466  July 2004\n\n07/14/2004 - IPLINFO updates:\n             1) Added a check for VTAM being active prior to trying to\n             display the VTAM version.\n             2) Added the JES2 node offset for z/OS 1.5 JES2.\n             3) Added the JES3 FMID to the FMID table for z/OS 1.5 JES3.\n\n\n CBT464  February 2004\n\n01/20/2004 - Added the REXXSTOJ sample JCL for running the REXXSTOR\n             REXX exec in batch.\n\n\n CBT462  September 2003\n\n09/02/2003 - Updated IPLINFO to change the method of displaying the\n             LPAR number.  The LPAR number in the CSD control block\n             may not match the HMC defined number on a z990 (T-REX).\n\n09/02/2003 - Updated console definitions in ONEPAKZ3 and TWOPAKZ3\n             jobs. Both consoles had a name of MASTER.\n\n\n CBT461  July 2003\n\n07/11/2003 - Updated the ONEPAKZ3 sample job and added the TWOPAKZ3\n             sample job to create a two pack rescue system. TWOPAKZ3\n             is the same as ONEPAKZ3, but also includes Unix System\n             Services, TCP/IP and ISHELL.\n07/07/2003 - IPLINFO updates:\n             1) Added VTAM NETID and SSCPNAME in the version section.\n             2) Added the RACF primary data set name or Top Secret\n             security file data set name in the version section.\n             3) Added high water marks for SQA,ESQA,CSA, and ECSA to\n             VMAP section (OS/390 R10 and above).\n\n\n CBT460  June 2003\n\n05/15/2003 - Fixed IPLINFO \"sysplex system number\" display when\n             more than 9 systems are in the sysplex.\n05/12/2003 - Changed CATSRCH to show all volsers instead of only\n             three volsers. Also changed panel for ISPF display\n             output to use &ZWIDTH to support a mod 5 terminal.\n\n\n CBT459  April 2003\n\n04/04/2003 - Added \"LINK\" as a valid option for LPROG display of\n             the LNKLST in addition to the \"LNK\" option.\n\n\n CBT458  April 2003\n\n01/16/2003 - Fix JES2 node display for z/OS 1.4 in IPLINFO. Also\n             added JES3 z/OS 1.4 FMID to JES3 FMID/VERSION table for\n             running IPLINFO from Unix System services.\n\n\n CBT456  January 2003\n\n01/08/2003 - Fixed bad comment in REXXSCAN (sample JCL had a \"/*\" in\n             it so a second \"*/\" was needed in the comment).\n01/02/2003 - Added the ONEPAKZ3 job. This is a sample jobstream to\n             build a one pack \"rescue\" system from a z/OS 1.3\n             driving system.\n\n\n CBT454  November 2002\n\n11/07/2002 - IPLINFO Updates:\n             1) Add additional parms to the IPA display that have\n                been added by IBM up to z/OS 1.3.\n             2) Sort the IPA parms. Had to add a sort subroutine\n                and re-write the code that splits up page data\n                set names to multiple lines.\n             3) Removed \"This was system number ?? added to the\n                sysplex\" message for a LOCAL sysplex.\n           - Updated APFVER to show the system name and time of\n             execution in the output header display line.\n10/28/2002 - Fixed bug in member pattern support for XEF PDS option.\n\n\n CBT453  October 2002\n\n10/23/2002 - Added sysplex information to the IPL section of IPLINFO:\n             \"This was system number ?? added to the sysplex\".\n10/15/2002 - Updated ZBROWSE, ZEDIT, and ZVIEW edit macros to work\n             with quoted data set names. Also added some additional\n             documentation on usage within the source code.\n10/04/2002 - Added the ISPF internal version level (ZENVIR) back into\n             the ISPF version display of IPLINFO.\n\n\n CBT451  September 2002\n\n09/04/2002 - IPLINFO Updates:\n             1) Add product (OS/390 or z/OS) to DFSMS level in version\n             display.\n             2) Add product name back into OS version display.\n             3) Strip blanks from ISPF level in version display.\n           - Updated $SNGLTSO doc member and added new JES2 usermod\n             sample (UMJES012) for z/OS 1.2 and above.\n\n\n CBT450  August 2002\n\n08/18/2002 - Fixed some typos in $ROOTSHR (RDRW changed to RDWR).\n08/02/2002 - IPLINFO Updates:\n             1) Fix for JES2 version display for z/OS when running\n             IPLINFO from Unix System Services.\n             2) Added JES3 z/OS 1.2 FMID to JES3 FMID table for\n             running IPLINFO from Unix System services.\n             3) Added support for Unicode in the IEASYSxx display\n             section of the IPA (UNI=).\n             4) Added some blank lines for readability in the various\n             IPA display sections.\n\n\n CBT449  July 2002\n\n06/11/2002 - Updated TAPESTAK to change the format of TMSUPDTE control\n             cards to use YYYY/DDD format. The old YYDDD format is no\n             longer valid.\n           - Updated the $SNGLTSO doc member and added information for\n             using \"RMF ISPF Dialogs\" and \"Other ISPF Applications\"\n             to the ISPF Considerations section.  Also Updated the\n             UMJES01 sample usermod to use a relative branch\n             instruction which is needed for OS/390 R10 JES2 and\n             above.\n           - Cosmetic changes to IPLINFO. No new functions or fixes.\n\n\n CBT447  May 2002\n\n05/22/2002 - IPLINFO Updates:\n             1) Remove the display of potential real storage size and\n             expanded storage size for 64-bit systems.\n             2) Added a display of the system mode (z/Architecture or\n             ESA/390) and ARCHLVL to the \"IPL\" section for systems\n             running OS/390 R10 and above.\n             3) Fixed a bug in subsystem function code display.\n05/15/2002 - Converted XEDIT, XBROWSE, XVIEW, and XMEMLIST from CLIST\n             to REXX. Fully qualified data set names are now optional,\n             regardless of the TSO PROFILE PREFIX setting.\n             PREFIX.DATA.SET.NAME will be tried first, then\n             DATA.SET.NAME for data sets that are not fully qualified.\n             Fixed bug in ZEDIT, XEDIT, XMEMLIST, and XEFCLIST edit\n             recovery code.\n\n CBT445  May 2002\n\n04/19/2002 - Fixed bug in COLADD for total message when the total is\n             not a whole decimal number. Also added an AVG display if\n             extended help is chosen after invocation (normally PF1).\n\n\n CBT444  April 2002\n\n03/19/2002 - Changed IPLINFO to get the master catalog information\n             from the IPA instead of CAXWA in OS/390 R4 and above.\n\n\n CBT442  February 2002\n\n01/30/2002 - Updated the INSLINE edit macro to allow inserting data\n             from the ISPF Default Clipboard via \"PASTE\".\n\n\n CBT441  January 2002\n\n01/18/2002 - Updated the $SNGLTSO doc member and added a GRS / MIM\n             Considerations section.\n01/11/2002 - Updated IPLINFO to correct security software display for\n             some OS/390 R10 systems not running RACF. Also made a\n             cosmetic change to the IPL LOAD PARM display.\n\n\n CBT440  December 2001\n\n11/09/2001 - Added the INDIRECR REXX exec.\n10/31/2001 - Updated IPLINFO to show the used amounts of CSA, SQA,\n             ECSA, ESQA, and the amount of SQA/ESQA conversion to\n             CSA/ECSA in the VMAP section.\n\n\n CBT439  November 2001\n\n10/18/2001 - Updated ZBROWSE, ZEDIT, and ZVIEW edit macros to work\n             with data sets not specified with \"DSN=\" or \"DSNAME=\"\n             as long as the cursor is on the start of the data set.\n09/20/2001 - Updated IPLINFO to prevent garbage display of the IODF\n             token if the token is unavailable, and also prevent the\n             display of the CPC Node Descriptor if it is unavailable.\n09/07/2001 - Added the REXXMEM REXX exec.\n\n\n CBT438  August 2001\n\n08/01/2001 - Updated CATSRCH to prevent a loop if the work area is\n             not large enough and issue an error message.\n07/24/2001 - Updated the $SNGLTSO doc member with SDSF considerations.\n\n\n CBT436  June 2001\n\n06/13/2001 - Changed IPLINFO to get the master catalog information\n             from the IPA instead of CAXWA in OS/390 R10 and above.\n06/04/2001 - Added the VTOCTOT  program.\n05/31/2001 - Added the REXXSCAN program and the EDMACALL REXX exec.\n\n\n CBT434  May 2001\n\n04/25/2001 - IPLINFO fixes/updates:\n             1) Added a Subsystem Information section to IPLINFO.\n             2) Fixed JES version information for systems where\n                JES is not the first subsystem in the SSCVT.\n             3) Changed method of getting JES3 version if running\n                under Unix System Services.\n04/24/2001 - Fixed bug in FINDMOD \"BOTH\" option. Some libraries in\n             the search list member were not searched if comments\n             were used in the member.\n04/13/2001 - Updated the $SNGLTSO doc member.\n\n\n CBT433  March 2001\n\n03/21/2001 - IPLINFO fixes/updates for OS/390 R10:\n             1) Fixed Virtual Storage Map. The start of the system\n             area has moved from x'1000' to x'2000' in R10.\n             2) Changed method of getting IODF information. The old\n             method was not working on some R10 systems.\n             3) Added ARCHLVL value from LOADxx to IPA section for R10.\n             4) Added CPU version number to CPU display.\n             5) Cosmetic changes.\n03/15/2001 - Updated the $SNGLTSO doc member and added UMJES06 JES3\n             USERMOD sample.\n03/02/2001 - Updated FINDMOD to accept a \"BOTH\" parameter so both the\n             search list libraries and the LPA & LNKLST are searched.\n02/28/2001 - Added the REXXSTOR REXX exec.\n02/04/2001 - Added JOB / DOC members: $ROOTSHR, $RXINTRO, $SNGLTSO,\n             $WLMMONO, ISPDFLTS, ISPEX16, UMJES01, ONEPAK43, RXINTRO,\n             SMPBLD1, SMPBLD2, SMPBLD3\n\n\n CBT432  January  2001\n\n01/23/2001 - Added \"ZONE\", \"PACK\", and \"BIN\" options to the COLADD\n             edit macro in addition to \"DEC\" and \"HEX\".\n01/17/2001 - Added the \"STACK\" parameter to LIBDEFs in the following\n             EXECs:  APFVER, CATSRCH, FINDMOD, IPLINFO, and LPROG.\n\n\n CBT431  December 2000\n\n12/22/2000 - Fixed ASIDLIST to handle more than 999 ASIDs.\n12/21/2000 - Fixed possible loop in CATSRCH caused by trying to\n             list an entry that was interrupted during a previous\n             process (message IDC11441I). This only happened when\n             trying to list an entire catalog (HLQ = **).\n12/19/2000 - Changed method of getting JES3 information in IPLINFO.\n12/13/2000 - Updated TAPESTAK to support high capacity cartridges.\n\n\n CBT430  Novemeber 2000\n\n10/23/2000 - Added code to IPLINFO to check which security package\n             is used (RACF, ACF2, or Top Secret).\n09/14/2000 - Added the CATSRCH REXX exec. Also added the optional\n             CATSRCHP panel and CAT invocation exec.\n\n\n CBT429  September 2000\n\n08/28/2000 - Fixed IPLINFO IODF information and JES2 node name\n             for OS/390 2.10. Also fixed IPLINFO JES2 node name\n             for MVS/ESA SP 5 and OS/390 R1.\n\n\n CBT425  June 2000\n\n05/19/2000 - Added the COLADD edit macro.\n04/20/2000 - XEF updates. The version has been changed to 6.2.\n             Added dataset information support for SMS controlled\n             datasets. Added 3 panels - XEFINFE, XEFINFP, & XEFINFS.\n03/16/2000 - Updated LPROG to check the APF flag in the LNKLST\n             display. Also, entry numbers are now displayed for\n             the LPA, LNKLST, and APF list displays.\n03/09/2000 - Updated FINDMOD to allow a member pattern to be\n             specified in the search criteria.\n02/29/2000 - Updated RDATE date conversion routine. It now has\n             the ability to convert NNNNN (the number of days\n             from January 1, 1900) to standard date output.\n02/07/2000 - Changed IPLINFO to check for a NON-VIO local page\n             data set in the page data set display.\n             Changed IPLINFO to get JES2 node name from $HCCT\n             instead of SYSVAR(SYSNODE). This allows the node name\n             to be displayed under Unix System Services.\n01/19/2000 - Added the JOBCHECK program.\n12/17/1999 - Fixed \"LINES KEPT\" total message in DELDUPS.\n12/16/1999 - Fixed Y2K problems with TAPESTAK and RACFUDEL.\n             Changed some comments in IPLINFO and RDATE that\n             referenced the century date.\n\n\n CBT422  November 1999\n\n             Initial CBT release\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$INSTAL": {"ttr": 1028, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x992/\\x01\\x13(\\x0f\\x14\\x15\\x01\\n\\x00\\xd6\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf7@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "2013-10-07T14:15:00", "lines": 266, "newlines": 214, "modlines": 0, "user": "CBT487"}, "text": " Installation Documentation:\n   ****************************************************************\n      Questions: Please email Mark Zelden -  mark@mzelden.com\n\n      Mark's MVS Utilities is also available on the web:\n         http://www.mzelden.com/mvsutil.html\n   ****************************************************************\n\n See member $RXINTRO for instructions on using the RXINTRO member\n\n EDIT Macros:\n   Copy the macro to any library in the SYSPROC concatenation.\n   If the macro is a REXX, it can also be placed in any library\n   in the SYSEXEC concatenation.\n\n   The LINETBL sample is in TSO XMIT format.  You must use the\n   TSO RECEIVE command to obtain a usable file. For example:\n\n        TSO RECEIVE INDA('userid.cbt.file434(LINETBL)')\n           (you will be prompted to enter a data set name:)\n        DA('userid.EDMAC.LINETBL')\n\n REXX EXECs/CLISTs:\n   Copy the EXEC or CLIST to any library in the SYSPROC concatenation.\n   REXX programs can also be placed in any library in the SYSEXEC\n   concatenation.\n\n   Many of the REXX EXECs and CLISTS are best used when set up as ISPF\n   commands. The ISPCMDSA CLIST is an example of how to add these\n   commands on a temporary basis without actually modifying the ISPF\n   Command Table (ISPCMDS). This also allows you to create aliases or\n   command abbbreviations without renaming the CLIST/EXEC.\n\n eXtended Editor Facility (XEF):\n   XEF is an ISPF dialog application that is used for BROWSING,\n   VIEWING, EDITING, or COMPRESSING a dataset. It allows you to\n   choose a dataset from a menu instead of typing in the entire dataset\n   name. XEF can also be used to obtain DATASET INFORMATION or\n   display a DATASET MEMBER LIST of a partitioned dataset. From the\n   member list you can select members to be BROWSEd, VIEWed, EDITed,\n   DELETEd, RENAMEd, or PRINTed.  Using the DSLIST option, a dataset\n   pattern can be entered to display a Data Set List that is like ISPF\n   option 3.4.  If the CBT PDS command is installed, XEF can also\n   interface with it.\n\n   XEF is invoked by selecting the main menu panel - XEFMENU. It can be\n   added to an existing ISPF option panel or is best used when set up as a\n   command in the ISPF Command Table (ISPCMDS). The ISPCMDSA\n   CLIST in this PDS has an example of how to add the XEF command on a\n   temporary basis without actually modifying the ISPF Command Table.\n\n XEF Installation Instructions:\n\n   Add the following CLISTs to a library in the SYSPROC concatenation:\n      XEFCLIST - XEF mainline code\n      XEF      - REXX EXEC to invoke XEF (optional if using ISPF command\n                                          tables or an option menu to\n                                          invoke XEF)\n      XEFLIBD  - Same as XEF CLIST but uses LIBDEFs (optional)\n\n   Add the following panels to a library in the ISPPLIB concatenation:\n      XEFMENU  - XEF Main Menu\n   ** XEFMENUB - Alternate XEF Main Menu (for systems below OS/390 2.10)\n      XEFHELP  - XEF Help Panel #1\n      XEFHELP2 - XEF Help Panel #2\n      XEFHELP3 - XEF Help Panel #3\n      XEFHELP4 - XEF Help Panel #4\n      XEFINF   - XEF Dataset Info Panel (SEQ)\n      XEFINFD  - XEF Dataset Info Panel (PDS)\n      XEFINFE  - XEF Dataset Info Panel (PDSE)\n      XEFINFP  - XEF Dataset Info Panel (PDS SMS)\n      XEFINFS  - XEF Dataset Info Panel (SEQ SMS)\n\n   Add the following messages to a library in the ISPMLIB concatenation:\n      XEF00    - XEF Messages\n\n   ** Note: If you want to run XEF 6.4 on systems below OS/390 2.10\n      use the XEFMENUB panel instead of XEFMENU.  You should rename the\n      panel to XEFMENU during installation.  XEF 6.4 will function as\n      it would on systems running OS/390 2.10 or higher, however, no\n      verification is done for valid data set names or patterns when\n      adding the names to the XEF main menu.  This should work on any\n      OS/390 system below OS/390 2.10 or MVS/ESA V5 systems (ISPF 4.2\n      or above is required).\n\n =======================================================================\n\n Sample ISPF Commands, Command Usage, and Edit Macro Usage\n\n The commands are activated by updating the ISPF Command table.  The\n abbreviations for commands and edit macros are achieved by using the\n command table or by renaming EXECs/CLISTSs.  The ISPCMDSA CLIST is an\n example of how to add these commands on a temporary basis without\n actually modifying the ISPF Command Table (ISPCMDS).\n\n\n                  I S P F     C O M M A N D S\n                  ---------------------------\n COMMAND (ABBR.)   FUNCTION                      EXAMPLE(S):\n ---------------   ---------------------------   -------------------------\n\n AMBCLIST (AMB)    Interactive AMBLIST           AMB\n\n BLKCLIST (BLK)    Interactive BLKDISK           BLK\n\n FINDMOD  (FM)     Find what library(s) a        FINDMOD IEFBR14\n                   module (or modules) is in     FINDMOD ABC*\n                   using the LPA/LNKLST          FM SMPPROC PROCLIST\n                   concatenation or an optional  FM A%C* FINDLIST BOTH\n                   library search list\n\n TSOB              BROWSE the output of any      TSOB LISTA STA\n                   TSO command                   TSOB PROFILE\n\n TSOE              EDIT the output of any        TSOE LISTA STA\n                   TSO command                   TSOE PROFILE\n\n TSOR              REVIEW the output of any      TSOR LISTA STA\n                   TSO command                   TSOR PROFILE\n\n TSOV              VIEW the output of any        TSOV LISTA STA\n                   TSO command                   TSOV PROFILE\n\n XBROWSE  (XB)     BROWSE a dataset              XB 'MY.PDS(ABC*)'\n                                                 XB PDS.NOTCAT USER01\n\n XDSLIST  (XD)     Display DSLIST (ISPF 3.4)     XD  (default is USERID.*)\n                                                 XD SYS2.*.PROCLIB\n                                                 XD SYS2.NOTCAT USER01\n\n XEDIT (XE)        EDIT a dataset                XE 'MY.PDS(ABC*)'\n                                                 XE PDS.NOTCAT USER01\n\n XEF               xXtended Editor Facility      XEF\n\n XLISTC (XL)       IDCAMS LISTCAT ALL - Output   XL 'MY.VSAM.FILE'\n                   goes into a browse dataset       ** Type XL next to DSN\n                                                       on ISPF Opt. 3.4\n\n XMEMLIST (XM)     Show a dataset member list    XM 'MY.PDS(ABC*)'\n                                                 XM PDS.NOTCAT USER01\n\n XVIEW (XV)        VIEW a dataset (ISPF V4)      XV 'MY.PDS(ABC*)'\n                                                 XV PDS.NOTCAT USER01\n\n               I S P F     E D I T     M A C R O S\n               -----------------------------------\n COMMAND (ABBR.)   FUNCTION\n ---------------   -----------------------------------------------------\n COLADD            Total numbers in a specified column range. An optional\n                   parameter of \"HEX\", \"ZONE\", \"PACK\", or \"BIN\" is needed\n                   to add hexadecimal, zoned decimal, packed decimal, or\n                   binary data. \"DEC\" is the default addition type.  The\n                   operation can optionally be limited to specific lines if\n                   labels are used.  Excluded lines are omitted from the\n                   operation.\n                   EXAMPLES: COLADD 10 25     ; COLADD 33 40 HEX .A .B\n                             COLADD 1 4  PACK ; COLADD 10 20 BIN\n\n COLUTIL           1) MOVE, COPY, or SWAP columns to a new location - move\n                   is the default. 2) SHIFT columns right or left. 3) CUT\n                   (copy) data from specific colimns into the ISPF Default\n                   Clipboard. This data can then be used with PASTE later\n                   on.  The operation can optionally be limited to\n                   specific lines if labels are used.  Excluded lines\n                   are omitted from the operation.\n\n                   MOVE EX:  COLUTIL 10 20 5 ; COLUTIL 10 14 35 MOVE .A .B\n                   COPY EX:  COLUTIL 10 20 5 COPY; COLUTIL 10 14 35 C .A .B\n                   SWAP EX:  COLUTIL 10 20 5 SWAP; COLUTIL 10 14 35 S .A .B\n                   SHIFT EX: COLUTIL LEFT 3 ; COLUTIL R 5 .A .B\n                   CUT  EX:  COLUTIL CUT 50 60; COLUTIL CUT 20 25 .A .B\n\n DB                Delete all lines from the line the cursor is on to the\n                   bottom line. This can also be used as a line command with\n                   the help of Doug Nadel's LMAC program.\n                   Doug's site - http://www.sillysot.com/mvs/\n                   For z/OS 1.8 and above, LMAC should be downloaded from\n                   IBM's ISPF web site:\n                   http://www.ibm.com/software/awdtools/ispf/support/\n\n DELDUPS           Sort and delete all duplicate lines. The duplicate search\n                   can optionally be limited to specific columns.\n                   EX: DELDUPS ; DELDUPS 10 15\n\n DELX              Delete everything but a certain string. The search can\n                   optionally be limited to specific columns. EX: DELX VOL=\n\n DELNX             Delete all of a certain string. The search can optionally\n                   be limited to specific colimns. EX: DELNX UNIT=SILO 5 16\n\n DT                Delete all lines from the line the cursor is on to the\n                   top line. This can also be used as a line command with\n                   the help of Doug Nadel's LMAC program.\n                   Doug's site - http://www.sillysot.com/mvs/\n                   For z/OS 1.8 and above, LMAC should be downloaded from\n                   IBM's ISPF web site:\n                   http://www.ibm.com/software/awdtools/ispf/support/\n\n EXCL              Exclude all of a certain string. the search can optionally\n                   be limited to specific columns. EX: EXCL UNIT=SYSDA\n\n FILL              Fill column(s) with characters. The fill can optionally\n                   be limited to specific lines if labels are used.\n                   Excluded lines are omitted from the operation.\n                   EXAMPLE: FILL 1 2 '/' ; FILL 2 7 'DELETE' .A .B\n\n INCL              Include only a certain string. The search can optionally\n                   be limited to specific columns. EX: INCL ' JOB' 10 20\n\n INSLINE (INS)     Insert a character string or previously \"CUT\" data from\n                   the ISPF Default Clipboard either after or before every\n                   line. The insert can optionally be limited to specific\n                   lines if labels are used. Excluded lines are omitted\n                   from the operation.\n                   AFTER EXAMPLES:  INSLINE '//    DISP=SHR' A\n                                    INSLINE PASTE A .FROM .TO\n                   BEFORE EXAMPLES: INSLINE ' DELETE + ' B .FROM .TO\n                                    INSLINE PASTE B\n\n PREFIX  (PRE)     Add a character string prefix to the beginning of a line\n                   before the first non blank character, shifting data to\n                   the right. The prefix can optionally be limited to specific\n                   lines if labels are used. Excluded lines are omitted from\n                   the operation.\n                   EXAMPLE\" PREFIX  \"'\" ; PRE 'DSN=' .A .B\n\n PREFIX2 (PRE2)    Add a character string prefix to the beginning of a line\n                   before the first non blank character. The prefix can\n                   optionally be limited to specific lines if labels are used.\n                   Excluded lines are omitted from the operation.\n                   EXAMPLE: PREFIX2 \"'\" ; PRE2 'DELETE ' .A .B\n\n SUFFIX (SUF)      Add a character string suffix to the end of a line after\n                   the last non blank character. The suffix can optionally\n                   be limited to specific lines if labels are used.\n                   Excluded lines are omitted from the operation.\n                   EXAMPLE: SUFFIX \"'\" ; SUF ',DISP=SHR' .A .B\n\n SW                Switch from VIEW to EDIT and visa versa. For use with\n                   sequential files it requires XVIEW/XEDIT or a similar\n                   EXEC/CLIST.\n\n ZBROWSE (ZB)      BROWSE the dataset on the line that the cursor is at.\n                   This can also be used as a line command with the\n                   help of Doug Nadel's LMAC program.\n                   Doug's site - http://www.sillysot.com/mvs/\n                   For z/OS 1.8 and above, LMAC should be downloaded from\n                   IBM's ISPF web site:\n                   http://www.ibm.com/software/awdtools/ispf/support/\n\n ZEDIT (ZE)        EDIT the dataset on the line that the cursor is at.\n                   This can also be used as a line command with the\n                   help of Doug Nadel's LMAC program.\n                   Doug's site - http://www.sillysot.com/mvs/\n                   For z/OS 1.8 and above, LMAC should be downloaded from\n                   IBM's ISPF web site:\n                   http://www.ibm.com/software/awdtools/ispf/support/\n\n ZVIEW (ZV)        VIEW the dataset on the line that the cursor is at (ISPF V4)\n                   This can also be used as a line command with the\n                   help of Doug Nadel's LMAC program.\n                   Doug's site - http://www.sillysot.com/mvs/\n                   For z/OS 1.8 and above, LMAC should be downloaded from\n                   IBM's ISPF web site:\n                   http://www.ibm.com/software/awdtools/ispf/support/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$ONEPAK": {"ttr": 1033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\t\\x08_\\x01\\t\\x08_\\x10\\x15\\x00(\\x00(\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf8@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2009-03-26T00:00:00", "modifydate": "2009-03-26T10:15:00", "lines": 40, "newlines": 40, "modlines": 0, "user": "CBT478"}, "text": " Creating ONEPAK / TWOPAK Systems Using DFSMSdss Instead of FDRCOPY\n ------------------------------------------------------------------\n\n I often get emails from people about my ONEPAK and TWOPAK jobs\n stating that they don't have FDR and asking if I have a version that\n uses DFSMSdss or some other method.  The answer, is \"NO\" as I do not\n want to maintain multiple versions and virtually 100% of all the\n shops I've ever worked at or consulted for had FDR available.\n\n However, DFSMSdss can easily be used (although adding the SSA prefix\n to the data set names is not as easy to do as it is with FDR).  Below\n is an example of what needs to be done to modify my ONEPAK and TWOPAK\n jobs to use DFSMSdss instead of FDRCOPY.  Obviously this is just a\n sample of a few data sets and all of the required data sets need to\n be added to the \"INCLUDE\" list and \"RENAMEUNCONDITIONAL\" list.\n\n\n //COPY   EXEC  PGM=ADRDSSU,REGION=4M\n //SYSPRINT DD  SYSOUT=*\n //OUT      DD  VOL=SER=SYS1PK,UNIT=SYSALLDA,DISP=OLD\n //SYSIN    DD  *\n  COPY DATASET   -\n           (INCLUDE(      -\n      SYS1.ISF.SISFEXEC   -\n      SYS1.ISF.SISFLINK   -\n      SYS1.ISF.SISFLOAD   -\n           ))             -\n           OUTDDNAME(OUT)  -\n           RENAMEUNCONDITIONAL -\n     ( -\n        (SYS1.ISF.SISFEXEC,       -\n        TARGSYS.SYS1.ISF.SISFEXEC)       -\n        (SYS1.ISF.SISFLINK,      -\n        TARGSYS.SYS1.ISF.SISFLINK)      -\n        (SYS1.ISF.SISFLOAD,      -\n        TARGSYS.SYS1.ISF.SISFLOAD)      -\n        )   -\n    CATALOG -\n    SHARE TOL(ENQF) ALLD(*) REPLACE SPHERE ALLE PROCESS(SYS1) FORCE\n /*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$ROOTSHR": {"ttr": 1035, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x03_\\x01\\x02#\\x0f\\x06\\x16\\x00{\\x00^\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf5\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-02-04T00:00:00", "modifydate": "2002-08-18T06:16:00", "lines": 123, "newlines": 94, "modlines": 0, "user": "CBT450"}, "text": "          Setting Up a Shared UNIX Root File HFS\n\n Recommendations:\n\n Try and make your root file non-SMS managed (DFSMS 1.4 / DFSMS 1.5\n require PTFs).  This is not a requirement, but it necessary for\n using indirect cataloging. If you are using a 3390-9 for your\n sysres, then there is probably plenty of room on the sysres for\n the root file.\n\n Pick a simple name. I suggest calling it something like SYS1.ROOT,\n SYS1.OMVS.ROOT,  SYS1.USS.ROOT, or SYS1.UNIX.ROOT.  Why use SYS1?\n A non-SMS root file can be treated just like any other sysres data\n set, reside on the sysres, and be indirectly cataloged in the\n master catalog so the correct root file is used based on the IPL\n volume.  If your root file will not fit on your primary sysres it\n can still be on a secondary or third sysres and be cataloged using\n extended indirect cataloging.  If your root file is still under\n SMS control, then add the primary sysres name as a suffix to the\n name.   Example:  SYS1.ROOT.RES01A\n\n -------------------------------------------------------------------\n\n Implementation Specifics:\n\n 1. Create/restore a root file from the maintenance root to the\n target volume, this may be your primary sysres if there is room.\n This should be done as part of the cloning process after OS/390\n maintenance is applied.\n\n 2. Update BPXPRMxx with the appropriate root data set name and\n change the mode from RDWR (read/write) to READ (read only):\n\n /********************************************************************/\n /* Define The ROOT HFS                                              */\n /********************************************************************/\n   ROOT     FILESYSTEM('SYS1.ROOT') /* R/O root on sysres            */\n   /* ROOT  FILESYSTEM('SYS1.ROOT.&SYSR1.')  R/O root not on sysres  */\n            TYPE(HFS)               /* Type of File system           */\n            MODE(READ)              /* Can be READ or RDWR           */\n /********************************************************************/\n\n 3. If the /tmp, /dev, and /var directories are currently part of\n the read/write root system, they need to be moved to their own HFS\n files and mounted at IPL time. A TFS (Temporary File System) can\n be used for /dev and /var (there is no residual data needed\n between IPLs from /dev and /var).  A TFS is a \"virtual\" HFS data\n set and only resides in storage, not on DASD. The /tmp directory\n can also be a TFS but is not recommended because of its size\n requirements and the loss of files that may be needed in the /tmp\n directory after an IPL, such as VI recovery files, dumps, etc.\n Note that you need to be at OS/390 2.8 or above to use a TFS for\n the /dev directory, otherwise you will need to copy your current\n /dev from the root to a separate HFS data set. To copy your\n current /dev from the root HFS, mount your maintenance root file\n at the /service mount point and mount a newly allocated (empty)\n HFS at the /service/service mount point (or any unused directory),\n and issue the following command:\n\n            cp -Rp /service/dev/ /service/service/\n\n You must also allocate a empty HFS for the /tmp HFS and mount it at\n IPL time if you are not already doing so. Make sure the permission\n bits are set to 777 (or 1777, which is 777 plus the sticky bit).\n\n The following updates need to be made to BPXPRMxx:\n\n /********************************************************************/\n /* Define Temporary File System (TFS)                               */\n /********************************************************************/\n   FILESYSTYPE TYPE(TFS)            /* Type of file system to start  */\n               ENTRYPOINT(BPXTFS)   /* Entry Point of load module    */\n /********************************************************************/\n /* TMP HFS data set                                                 */\n /********************************************************************/\n   MOUNT FILESYSTEM('OMVS.TMP.&SYSNAME.')     /* Name of file system */\n   TYPE(HFS)                       /* Type of file system - HFS      */\n   MODE(RDWR)                      /* must be read/write for /tmp    */\n   MOUNTPOINT('/tmp')              /* mount point                    */\n /********************************************************************/\n /* DEV HFS data set  (Temporary File System)                        */\n /********************************************************************/\n   MOUNT FILESYSTEM('OMVS.TFS.DEV.&SYSNAME.') /* Name of file system */\n   TYPE(TFS)                       /* Type of file system - TFS      */\n   MODE(RDWR)                      /* must be read/write for /dev    */\n   MOUNTPOINT('/dev')              /* mount point                    */\n   PARM('-s 1')                    /* create a 1M TFS                */\n   /* For /dev TFS, make size = concurrent users * 8K + .5MB.        */\n /********************************************************************/\n /* VAR HFS data set  (Temporary File System)                        */\n /********************************************************************/\n   MOUNT FILESYSTEM('OMVS.TFS.VAR.&SYSNAME.') /* Name of file system */\n   TYPE(TFS)                       /* Type of file system - TFS      */\n   MODE(RDWR)                      /* must be read/write for /dev    */\n   MOUNTPOINT('/var')              /* mount point                    */\n   PARM('-s 2')                    /* create a 2M TFS                */\n /********************************************************************/\n\n 4. The default permission on a TFS is 777, so add a line to /etc/rc\n to change the permission bits to 755 for the /dev directory. The\n /var directory needs to stay at the TFS default of 777.\n\n    # Change TFS /dev permission bits from 777 to 755\n    chmod 755 /dev\n\n 5. Verify the root file is indirectly cataloged in the target\n system's master catalog. If the root is not on the sysres skip\n this step. The root does not have to be on the primary sysres to\n take advantage of indirect cataloging.\n\n    //JS010  EXEC  PGM=IDCAMS\n    //SYSPRINT DD  SYSOUT=*\n    //SYSUDUMP DD  SYSOUT=*\n    //SYSIN    DD  *\n          DEF NVSAM(NAME(SYS1.ROOT) VOL(******) DEVT(0000)) -\n              CAT(MASTER.CATALOG)\n       /* DEF NVSAM(NAME(SYS1.ROOT) VOL(&SYSR2) DEVT(0000)) -  */\n       /*    CAT(MASTER.CATALOG)                               */\n\n 6. IPL\n\n You can now share the root HFS. :-)\n Repeat steps 2 through 6 on any systems that will share the root.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$RXINTRO": {"ttr": 1038, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\"\\x01\\x01\\x03_\\x01\\x01\\x03_\\x14\\x10\\x00\\x13\\x00\\x13\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf3\\xf3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-02-04T00:00:00", "modifydate": "2001-02-04T14:10:22", "lines": 19, "newlines": 19, "modlines": 0, "user": "CBT433"}, "text": " Installation Documentation for \"Introduction To TSO/E REXX\"\n\n The RXINTRO member of this PDS is in TSO XMIT format. You must\n receive the file, download it to your workstation/PC in binary\n format, and un-zip it.\n\n 1) TSO RECEIVE INDA('cbt.file434(RXINTRO)')\n      - you will be prompted to enter a data set name:\n    DA('userid.REXX.INTRO.ZIP')\n\n 2) Transfer the file you received/created in step 1 to your\n    workstation/PC. Make sure the transfer is binary (do not use\n    ASCII/CRLF if using IND$FILE, use the \"BIN\" option if using\n    TCPIP). Name the file something like \"REXXINTRO.ZIP\" on the PC\n    side.\n\n 3) You should now have a usable ZIP file you can UNZIP. The\n    unzipped file is called REXXINTRO.DOC. The file was created\n    using Microsoft Word.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$SNGLTSO": {"ttr": 1281, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x03_\\x01\\x14\\x12\\x7f\\t%\\x00\\xb6\\x00U\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf8@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-02-04T00:00:00", "modifydate": "2014-05-07T09:25:00", "lines": 182, "newlines": 85, "modlines": 0, "user": "CBT488"}, "text": "    How To Use The Same TSO USERID In a Shared Environment\n               (last update 05/06/2014)\n\n GRS / MIM Considerations:\n\n If you are using GRS or MIM (you should be using one of them in a\n shared environment) you must not propagate the SYSIKJUA QNAME or you\n will see message IKJ56425I (which indicates you are already logged\n on) when you try and logon to a second system.  Note that the TSO/E\n General Information manual says that propagation of this QNAME is\n required for TSO Generic Resource support in a parallel sysplex. In\n a shared environment, you should already be propagating the SPFEDIT\n QNAME which is used by ISPF to preserve data set and PDS member\n integrity.\n\n\n JES2 Considerations:\n\n For using a single TSO USERID in a JES2 MAS, a JES2 source update\n to HASPCNVT is required (this takes care of the duplicate logon\n check in JES2).  Alternatively, JES2 exit 44 can be used.  If only\n the DASD is shared and there is no JES2 MAS involved, then the JES2\n source update or exit is not required.  In z/OS 1.4 and above, the\n JES2 HASPCNVT modification is no longer required.\n\n Also note that when using NOTIFY=USERID in a JES2 MAS, the job\n completion message will be sent to the system that has the USERID\n with the lowest job number.  In practice this will be the same as\n the first system you logon to. This issue is resolved in z/OS 1.13\n when all participating MAS members are at that level (or above).\n\n\n SDSF Considerations (sysplex only):\n\n When using a single TSO USERID in a sysplex, no modifications to\n SDSF are required. However, if you use the ULOG command or issue\n MVS and JES2 commands, you will only see the responses on the first\n system that activates the EMCS console. This is because there can't\n be more than one console in a sysplex with the same name, and the\n default EMCS console name is your USERID.  You can change your SDSF\n EMCS console name by using the \"SET CONSOLE <name>\" command or from\n the \"Options\" pull down menu. I normally suffix my USERID with a\n unique single letter or number on each system.\n\n\n JES3 Considerations:\n\n For using a single TSO USERID in a JES3 complex a JES3 source\n update to IATGRJS is required (this takes care of the duplicate\n logon check in JES3). If only the DASD is shared and there is no\n JES3 complex involved, then the JES3 source update is not required.\n However, as of z/OS 2.1, the JES3 source usermod is no longer\n required for any JES3 configuration as there is no longer any\n duplicate logon check within JES3.\n\n\n ISPF Considerations:\n\n 1) Prior to z/OS 1.9, the LOGON clist must allocate a different\n ISPF profile for each system.\n I use:  userid.SYSnnnn.ISPPROF (nnnn=SMFID).\n\n Starting at z/OS 1.9, profile sharing is possible. You must at least\n set PROFILE_SHARING=YES in the ISPF configuration table.  In the\n ISPCCONF dialog, this can be found as \"Multi-logon Profile Sharing\"\n in the \"ISPF Site-wide Defaults\" section. If you are already using\n the setting for ISPF_TEMPORARY_DATA_SET_QUALIFIER, you may remove it\n and let it default to \"ISP&SEQ\" (see below for more on this for pre-\n z/OS 1.9 systems). If you don't remove the qualifier setting or\n specify the default of ISP&SEQ, you will get a warning, but you can\n ignore it as long as the setting will resolve to something that is\n unique for each system in the sysplex, for example SYS&SYSNAME.  See\n the \"Profile Sharing\" section in the ISPF Planning and Customization\n manual for more information on this. ** Note that using the ISPF\n plugin of z/OS Management Facility (z/OSMF) for z/OS 1.13 and\n above requires the use of profile sharing to allow multiple ISPF\n sessions.\n\n The information below applies to ISPPROF sharing without the\n sharing support introduced in z/OS 1.9 enabled:\n\n There are some shops that share ISPPROF by not propagating the\n ENQ for SPFEDIT specifically for the profile data set name.\n Masking must be used with GRS / MIM for the ENQ RNAME in this case.\n I don't recommend this approach because it could lead to corruption\n of your profile data set.  The other caveat with this approach is\n that because the same profile member (APPL) could be updated from\n multiple systems concurrently, the last update wins. For example,\n if you are logged on to SYSA and SYSB and update a PFK setting\n from SYSA and then logoff SYSA before SYSB, you will lose that\n update.  This same issue can destroy edit recovery information\n in your profile. Assuming you are working under the same ISPF\n APPL on both SYSA and SYSB and are forced off of SYSA and logoff\n normally from SYSB, you will not be presented with the edit\n recovery dialog when you logon again to either system.\n\n There is a similar caveat for edit recovery even when not sharing\n the ISPF profile data set.  Because some recovery information is\n stored in the ISPF profile, if you attempt to edit the same\n data set or same PDS member from a system that does not have\n recovery pending, you will be able to update the data set or\n PDS member without warning.  If you then attempt to edit that same\n data set or PDS member from the system pending recovery and don't\n cancel out of the recovery, you will lose the updates done from the\n other system. However, if you are forced off a system and have edit\n recovery pending, then re-logon to the same system, edit recovery\n will work as expected.  I tend to run with recovery off and thus\n avoid the issue altogether.\n\n 2) If your system is not at OS/390 R10 or higher, you need ISPF\n exit 16 to ensure unique names for the LOG,LIST and temporary data\n set names. This also requires updating the ISPXDT exit definition\n table in LMOD ISPEXITS and the ISPDFLTS module to let ISPF know you\n are using exits. If you are at OS/390 2.8 or above, the ISPDFLTS\n table is replaced by the new ISPF Configuration Utility - ISPCCONF.\n You must specify ENABLE_ISPF_EXITS = YES in the configuration table\n that is input to the utility. In the ISPCCONF dialog, this can be\n found in the \"ISPDFLTS, CUA Colors, and Other DM Settings\" section.\n My ISPF Exit 16 uses the convention of:\n    userid.SYSnnnn.SPFLOGn.LIST\n    userid.SYSnnnn.SPFTEMPn.CNTL\n    userid.SYSnnnn.SPFn.LIST\n I link ISPEX16 right in with ISPXDT.\n\n If you are at OS/390 R10 or higher, you can use an option in the\n ISPF Configuration Utility as an alternative to using ISPF exit 16.\n Specify ISPF_TEMPORARY_DATA_SET_QUALIFIER = SYSnnnn (or whatever\n qualifier you desire). In the ISPCCONF dialog, this can be found as\n \"Additional Temporary Data Set Qualifier\" in the \"ISPF Site-wide\n Defaults\" section. The drawback to this method is that you will need\n a different configuration table for each system unless you are at\n the z/OS 1.5 level or above.  In z/OS 1.5 and above, a Static System\n Symbol can be specified as part of the name and ISPF exit 16 is no\n longer required: ISPF_TEMPORARY_DATA_SET_QUALIFIER = SYS&SYSNAME\n For z/OS 1.9 and above, if you implement ISPF profile sharing via\n PROFILE_SHARING=YES, you don't have to specify anything here and may\n let it default to ISPF_TEMPORARY_DATA_SET_QUALIFIER = ISP&SEQ.\n\n 3) As long as you are using GRS or MIM you don't need to worry\n about recovery data set names because an ISPF ENQ (SPFEDIT) will\n be used to create unique names, otherwise there is another ISPF\n exit for that (the data set name change exit).\n\n I have provided the following samples to implement this:\n    ISPDFLTS -  ASM/LNK ISPDFLTS via SMP/E usermod\n    ISPEX16  -  ASM/LNK ISPF EXIT 16 and ISPXDT via SMP/E usermod\n    UMJES01  -  JES2 Source update via SMP/E usermod (OS/390 R10)\n    UMJES012 -  JES2 Source update via SMP/E usermod (z/OS R2 & >)\n    UMJES01O -  JES2 Source update via SMP/E usermod (OS/390 < R10)\n    UMJES06  -  JES3 Source update via SMP/E usermod\n                (supplied by Edward E. Jaffe - Phoenix Software)\n\n ** Please verify the source line numbers in the JES USERMODs to make\n sure they match the line numbers of your JES version!!\n\n If you wish to use JES2 exit 44 instead of the JES2 source usermod\n I am providing, there is a sample available on CBT file 346.\n\n                    RMF ISPF Dialogs (optional)\n\n If you use want to use the RMF ISPF dialogs from multiple systems\n at the same time using the same TSO USERID, you will need to modify\n the SYS1.SERBCLS(ERBRMF3X) CLIST for the ISPTABLE data set name.\n For example, the CLIST as distributed:\n      SET TABLSUF = &STR(ISPTABLE)\n can be changed to:\n      SET TABLSUF = &STR(ISPTABLE).SYS&STR(&SYSSMFID)\n\n                 Other ISPF applications (optional)\n\n Other ISPF applications (IBM, ISV, and local) may also have issues\n with trying to use them concurrently from different systems using\n the same TSO USERID.  For many ISPF applications, concurrent usage\n with the same TSO USERID may not be possible. Each application\n needs to be examined on an individual basis.\n\n Here are a few IBM product CLISTs that may be modified to support\n concurrent usage with the same TSO USERID from different systems:\n\n          HCD  - Modify SYS1.SCBDCLST(CBDCHCD)\n          IPCS - Modify SYS1.SBLSCLI0(BLSCDDIR)\n          RMF  - Modify SYS1.SERBCLS(ERBRMF3X)    (see above)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$WLMMONO": {"ttr": 1285, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x17\\x01\\x01\\x03_\\x01\\x01\\x03_\\x07\\x12\\x006\\x006\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf3\\xf3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-02-04T00:00:00", "modifydate": "2001-02-04T07:12:17", "lines": 54, "newlines": 54, "modlines": 0, "user": "CBT433"}, "text": "               Setting up WLM in a MONOPLEX\n\n Recommendations:\n\n You may want to start from scratch as opposed to trying to \"convert\"\n your IPS/ICS.  A good place for an example of a service policy can\n be found at Cheryl Watson's web site:\n\n         http://www.watsonwalker.com/quickst.html\n\n Here are a few manuals to review for setting up a monplex with WLM:\n\n        MVS Settings up a Sysplex\n        Parallel Sysplex Hardware and Software Migration\n          (pay attention to steps for defining WLM Data Sets\n           and Policys)\n        Planning: Workload Management\n\n -------------------------------------------------------------------\n\n Implementation Specifics:\n\n 1) Define XCF couple datasets with the IXCL1DSU utility\n    - see SYS1.SAMPLIB(IXCSYSPF)\n\n 2) Create COUPLExx member with data set names and sysplex name.\n\n 3) Update IEASYSxx with PLEXCFG=MONOPLEX,COUPLE=xx\n\n 4) IPL\n\n 5) Define WLM couple datasets.\n    - see SYS1.SAMPLIB(IWMFTCDS)\n       The WLM dialogs can also be used:\n       TSO EX 'SYS1.SBLSCLI0(IWMARIN0)'\n       Select UTILITES >> Allocate WLM couple datasets\n\n 6) Use operator command to add the WLM couple datasets:\n     SETXCF COUPLE,TYPE=WLM,PCOUPLE=(data.set.name)\n     SETXCF COUPLE,TYPE=WLM,ACOUPLE=(data.set.name)\n   *** be sure to update your COUPLExx member with the WLM\n       couple data sets.\n\n 7) Now the fun part - create the service definition policy\n    via the WLM dialogs (you need security access to the\n    FACILITY CLASS resource name of MVSADMIN.WLM.POLICY)\n\n 8) Store the policy via WLM Dialogs\n\n 9) V WLM,POLICY=polname\n\n 10) F WLM,MODE=GOAL  (to switch back - F WLM,MODE=COMPAT)\n\n To IPL in goal mode - remove IPS=xx & ICS=xx from IEASYSxx.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE434": {"ttr": 1287, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x003\\x01 5\\x0f\\x01 5\\x0f#\\x08\\x00\\xd7\\x00\\xd7\\x00\\x00\\xc3\\xc2\\xe3`\\xf5\\xf0\\xf0@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "2020-12-15T00:00:00", "modifydate": "2020-12-15T23:08:33", "lines": 215, "newlines": 215, "modlines": 0, "user": "CBT-500"}, "text": "//***FILE 434 is from Mark Zelden and contains his collection       *   FILE 434\n//*           of MVS utilities.                                     *   FILE 434\n//*                                                                 *   FILE 434\n//*   Questions: Please email Mark Zelden -  mark@mzelden.com       *   FILE 434\n//*                                                                 *   FILE 434\n//*   Last Updated:  September 24 2020                              *   FILE 434\n//*                                                                 *   FILE 434\n//*   Mark's MVS Utilities is also available on the web:            *   FILE 434\n//*      http://www.mzelden.com/mvsutil.html                        *   FILE 434\n//*                                                                 *   FILE 434\n//*                                                                 *   FILE 434\n//* Sample JOBs / Documentation                                     *   FILE 434\n//* --------------------------------------------------------------- *   FILE 434\n//* $$$$READ  - Disclaimer                                          *   FILE 434\n//* $$$INDEX  - Index of all members                                *   FILE 434\n//* $$CHANGE  - CBT File 434 change log                             *   FILE 434\n//* $$INSTAL  - General installation documentation for this file    *   FILE 434\n//* $ONEPAK   - Doc for using DFSMSdss instead of FDRCOPY for       *   FILE 434\n//*             ONEPAK / TWOPAK jobs.                               *   FILE 434\n//* $ROOTSHR  - Doc for setting up a shared UNIX root file          *   FILE 434\n//* $RXINTRO  - Doc to download and use RXINTRO member              *   FILE 434\n//* $SNGLTSO  - Doc for using the same TSO USERID in a shared       *   FILE 434\n//*             environment.                                        *   FILE 434\n//* $WLMMONO  - Doc for setting up WLM in a MONOPLEX                *   FILE 434\n//* CLONERES  - Sample jobstream to clone a two volume sysres set   *   FILE 434\n//*             and SMP/E target zones.                             *   FILE 434\n//* CLONERSO  - Old version of CLONERES                             *   FILE 434\n//* ISPDFLTS  - ISPF defaults source update needed for single TSO   *   FILE 434\n//*             USERID (described in $SNGLTSO).                     *   FILE 434\n//* ISPEX16   - ISPXDT and ISPF exit 16 source needed for single    *   FILE 434\n//*             TSO USERID (described in $SNGLTSO).                 *   FILE 434\n//* ONEPAKZ3  - Sample jobstream to build a one pack \"rescue\"       *   FILE 434\n//*             system from a z/OS 1.3 driving system.              *   FILE 434\n//* ONEPAKZ6  - Sample jobstream to build a one pack \"rescue\"       *   FILE 434\n//*             system from a z/OS 1.6 driving system.              *   FILE 434\n//* ONEPAKZ8  - Sample jobstream to build a one pack \"rescue\"       *   FILE 434\n//*             system from a z/OS 1.7 - z/OS 1.11 driving system.  *   FILE 434\n//* ONEPAKZD  - Sample jobstream to build a one pack \"rescue\"       *   FILE 434\n//*             system from a z/OS 1.12 - z/OS 1.13 driving system. *   FILE 434\n//* ONEPAK21  - Sample jobstream to build a one pack \"rescue\"       *   FILE 434\n//*             system from a z/OS 2.1 driving system.              *   FILE 434\n//* ONEPAK22  - Sample jobstream to build a one pack \"rescue\"       *   FILE 434\n//*             system from a z/OS 2.2 or 2.3 driving system.       *   FILE 434\n//* ONEPAK43  - Sample jobstream to build a one pack \"rescue\"       *   FILE 434\n//*             system (created for ESA 4.3, but is still a good    *   FILE 434\n//*             sample of the required steps).                      *   FILE 434\n//* RXINTRO   - \"Introduction to TSO/E REXX\" Word document          *   FILE 434\n//* SMPBLD1   - Job to build an SMP/E environment from scratch.     *   FILE 434\n//*             All VSAM SMP/E zones are created within the same    *   FILE 434\n//*             physical VSAM data set.                             *   FILE 434\n//* SMPBLD2   - Job to build an SMP/E environment from scratch.     *   FILE 434\n//*             The VSAM SMP/E zones are created as separate        *   FILE 434\n//*             physical VSAM data sets.                            *   FILE 434\n//* SMPBLD3   - Job to build a new SMP/E target zone, dlib zone,    *   FILE 434\n//*             and other required SMP/E data sets into an          *   FILE 434\n//*             existing global zone.                               *   FILE 434\n//* SMPDELF   - Sample job to delete a FMID from a set of SMP/E     *   FILE 434\n//*             zones and libraries.                                *   FILE 434\n//* TWOPAKZ3  - Sample jobstream to build a two pack \"rescue\"       *   FILE 434\n//*             system from a z/OS 1.3 driving system. Same as      *   FILE 434\n//*             ONEPAKZ3 but also includes Unix System Services,    *   FILE 434\n//*             TCP/IP, and ISHELL.                                 *   FILE 434\n//* TWOPAKZ6  - Sample jobstream to build a two pack \"rescue\"       *   FILE 434\n//*             system from a z/OS 1.6 driving system. Same as      *   FILE 434\n//*             ONEPAKZ6 but also includes Unix System Services,    *   FILE 434\n//*             TCP/IP, and ISHELL.                                 *   FILE 434\n//* TWOPAKZ8  - Sample jobstream to build a two pack \"rescue\"       *   FILE 434\n//*             system from a z/OS 1.7 - z/OS 1.11 driving system.  *   FILE 434\n//*             Same as ONEPAKZ8 but also includes Unix System      *   FILE 434\n//*             Services, TCP/IP, and ISHELL.                       *   FILE 434\n//* TWOPAKZD  - Sample jobstream to build a two pack \"rescue\"       *   FILE 434\n//*             system from a z/OS 1.12 - z/OS 1.13 driving system. *   FILE 434\n//*             Same as ONEPAKZD but also includes Unix System      *   FILE 434\n//*             Services, TCP/IP, and ISHELL.                       *   FILE 434\n//* TWOPAK21  - Sample jobstream to build a two pack \"rescue\"       *   FILE 434\n//*             system from a z/OS 2.1 driving system.              *   FILE 434\n//*             Same as ONEPAK21 but also includes Unix System      *   FILE 434\n//*             Services, TCP/IP, and ISHELL.                       *   FILE 434\n//* TWOPAK22  - Sample jobstream to build a two pack \"rescue\"       *   FILE 434\n//*             system from a z/OS 2.2 or 2.3 driving system.       *   FILE 434\n//*             Same as ONEPAK22 but also includes Unix System      *   FILE 434\n//*             Services, TCP/IP, and ISHELL.                       *   FILE 434\n//* UMJES01   - JES2 source update needed for single TSO USERID     *   FILE 434\n//*             (OS/390 R10 & z/OS R1 - described in $SNGLTSO).     *   FILE 434\n//* UMJES012  - JES2 source update needed for single TSO USERID     *   FILE 434\n//*             (z/OS R2 and above - described in $SNGLTSO).        *   FILE 434\n//* UMJES01O  - JES2 source update needed for single TSO USERID     *   FILE 434\n//*             (prior to OS/390 R10 - described in $SNGLTSO).      *   FILE 434\n//* UMJES06   - JES3 source update needed for single TSO USERID     *   FILE 434\n//*             (described in $SNGLTSO).                            *   FILE 434\n//*                                                                 *   FILE 434\n//*                                                                 *   FILE 434\n//* CLISTS / Edit Macros / Programs                                 *   FILE 434\n//* --------------------------------------------------------------- *   FILE 434\n//* ACBCHECK  - ASM PGM to check if a VTAM APPLID is available      *   FILE 434\n//* AMBCLIST  - CLIST to invoke interactive AMBLIST with panel I/P  *   FILE 434\n//* APFVER    - REXX exec to verify APF list                        *   FILE 434\n//* ASIDLIST  - ASM PGM to list ASIDs & MAXUSER/RSVSTRT/RSVNONR     *   FILE 434\n//* ASIDLRX   - REXX PGM to list ASIDs & MAXUSER/RSVSTRT/RSVNONR    *   FILE 434\n//* BLKCLIST  - CLIST to invoke BLKDISK command with panel input    *   FILE 434\n//* CAT       - REXX exec to invoke CATSRCH via CATSRCHP panel      *   FILE 434\n//* CATSRCH   - REXX exec to invoke Catalog Search Interface (CSI)  *   FILE 434\n//* CMD34     - REXX exec to process commands against a DSLIST      *   FILE 434\n//* COLADD    - Edit macro to add numbers from a column range       *   FILE 434\n//* COLUTIL   - Edit macro to manipulate columns                    *   FILE 434\n//* DB        - Edit macro to delete lines from the cursor line     *   FILE 434\n//*             to the bottom line                                  *   FILE 434\n//* DELDUPS   - Edit macro to delete duplicate lines                *   FILE 434\n//* DELDUPS2  - REXX duplicate record deletion program              *   FILE 434\n//* DELNX     - Edit macro to delete all of a certain string        *   FILE 434\n//* DELX      - Edit macro to delete everything but a certain       *   FILE 434\n//*             string                                              *   FILE 434\n//* DSLISTSV  - Quick ISPF save of data set names similar to        *   FILE 434\n//*             ISPF 3.4                                            *   FILE 434\n//* DT        - Edit macro to delete lines from the cursor line     *   FILE 434\n//*             to the top line                                     *   FILE 434\n//* EDMACALL  - REXX exec to run an edit macro against every        *   FILE 434\n//*             member of a PDS.                                    *   FILE 434\n//* EXCL      - Edit macro to exclude all of certain string         *   FILE 434\n//* FILL      - Edit macro to fill columns with a character         *   FILE 434\n//* FINDMOD   - REXX exec (command) to find what library(s) a       *   FILE 434\n//*             module is in                                        *   FILE 434\n//* FINDASYS  - Sample search list for FINDMOD CLIST                *   FILE 434\n//* FVE       - REXX exec (command) - Fast View/Edit of DSNs        *   FILE 434\n//* HLISTB    - REXX exec to browse o/p of HLIST DA BCDS (BACKUP)   *   FILE 434\n//* HLISTBL   - REXX exec to browse o/p of HLIST DA LEVEL BCDS      *   FILE 434\n//* HLISTM    - REXX exec to browse o/p of HLIST DA MCDS (MIGRATE)  *   FILE 434\n//* HLISTML   - REXX exec to browse o/p of HLIST DA LEVEL MCDS      *   FILE 434\n//* INCL      - Edit macro to include all of a certain string       *   FILE 434\n//* INDIRECR  - REXX exec to create IDCAMS control cards for        *   FILE 434\n//*             indirectly catalogging a list of data set names     *   FILE 434\n//* INSLINE   - Edit macro to insert a string after or before lines *   FILE 434\n//* IPLHIST   - REXX exec to create a history of IPLs. This exec    *   FILE 434\n//*             calls IPLINFO as a function.                        *   FILE 434\n//* IPLINFO   - REXX exec to show various system information        *   FILE 434\n//* JOBCHECK  - ASM PGM to find if a JOB is active on the system    *   FILE 434\n//* JOBCHKRX  - REXX PGM to find if a JOB is active on the system   *   FILE 434\n//* ISPCMDSA  - CLIST to add temporary cmds to ISPF command table   *   FILE 434\n//* KEYSWAP   - REXX exec to swap PFKEYS 1-12 with PFKEYS 13-24     *   FILE 434\n//* LASTIPL   - REXX exec to display last (latest) IPLHIST info     *   FILE 434\n//* LINEMAC   - REXX exec - used with Doug Nadel's / IBM's LMAC PGM *   FILE 434\n//* LINETBL   - Sample ISPF table to use with ISPF line edit macros *   FILE 434\n//* LMPREXX   - REXX exec to help manage CA LMP KEYS                *   FILE 434\n//* LOGRREXX  - REXX program to build logstream DELETE/DEFINE cards *   FILE 434\n//*             using the output from IXCMIAPU LIST LOGSTREAM.      *   FILE 434\n//* LNKVER    - REXX exec to verify LNKLST syntax and libs          *   FILE 434\n//* LPROG     - REXX exec - displays LNKLST, LPA list, & APF list   *   FILE 434\n//* MEMLSTSV  - Quick ISPF save of member stats. Similar to \"SAVE\"  *   FILE 434\n//*             command from a data set member list.                *   FILE 434\n//* PREFIX    - Edit macro to add a prefix to the front of a line   *   FILE 434\n//* PREFIX2   - Edit macro to add a prefix to the front of a line   *   FILE 434\n//* RACFUDEL  - REXX program to remove obsolete RACF users          *   FILE 434\n//* RDATE     - REXX date conversion routine                        *   FILE 434\n//* RDATEF    - REXX function version of RDATE                      *   FILE 434\n//* REXXMEM   - REXX program to browse memory in \"dump\" format      *   FILE 434\n//* REXXSCAN  - REXX program to scan an input file for string(s)    *   FILE 434\n//* REXXSTOR  - REXX exec to show virtual storage usage of invoker  *   FILE 434\n//* REXXSTOJ  - Sample JCL to run REXXSTOR in batch                 *   FILE 434\n//* RXSMF30   - REXX program to read SMF 30 records and produce     *   FILE 434\n//*             produce a job accounting report.                    *   FILE 434\n//* RXSTOR64  - REXX exec to show 64-bit MEMLIMIT and storage use   *   FILE 434\n//* SDSF@DR   - REXX program to that uses the SDSF REXX environment *   FILE 434\n//*             to copy output from the spool into data sets.       *   FILE 434\n//* SDSFPRT   - REXX program to that uses the SDSF REXX environment *   FILE 434\n//*             to take all or selected output from the spool and   *   FILE 434\n//*             copy it to a PDS via SDSF \"PRINT\" commands.         *   FILE 434\n//* SUFFIX    - Edit macro to add a suffix to the end of a line     *   FILE 434\n//* SW        - Edit macro to switch from VIEW to EDIT or visa versa*   FILE 434\n//* TAPESTAK  - REXX tape stacking program (works with CA-1)        *   FILE 434\n//* TSOB      - REXX exec (command) to BROWSE o/p of any TSO cmd    *   FILE 434\n//* TSOE      - REXX exec (command) to EDIT o/p of any TSO cmd      *   FILE 434\n//* TSOR      - REXX exec (command) to REVIEW o/p of any TSO cmd    *   FILE 434\n//* TSOV      - REXX exec (command) to VIEW o/p of any TSO cmd      *   FILE 434\n//* VTOCTOT   - REXX program to summarize VTOC cmd output by HLQ    *   FILE 434\n//* XBROWSE   - REXX (command) to browse any dataset                *   FILE 434\n//* XDSLIST   - REXX (command) to display a data set list (ISPF 3.4)*   FILE 434\n//* XEDIT     - REXX (command) to edit any dataset                  *   FILE 434\n//* XEF       - REXX exec to start eXtended Editor Facility dialog  *   FILE 434\n//* XEFLIBD   - REXX exec to start eXtended Editor Facility dialog  *   FILE 434\n//* XEFCLIST  - eXtended Editor Facility mainline code              *   FILE 434\n//* XLISTC    - REXX (command) to LISTCAT ALL any dataset           *   FILE 434\n//* XMEMLIST  - CLIST (command) to bring up member list on any DSN  *   FILE 434\n//* XVIEW     - REXX (command) to view any dataset                  *   FILE 434\n//* ZBROWSE   - Edit macro to browse dataset that the cursor is on  *   FILE 434\n//* ZEDIT     - Edit macro to edit dataset that the cursor is on    *   FILE 434\n//* ZVIEW     - Edit macro to view dataset that the cursor is on    *   FILE 434\n//*                                                                 *   FILE 434\n//*                                                                 *   FILE 434\n//* ISPF Panels                                                     *   FILE 434\n//* --------------------------------------------------------------- *   FILE 434\n//* AMBPANEL  - Interactive AMBLIST panel for AMBCLIST              *   FILE 434\n//* BLKPANEL  - Interactive BLKDISK panel for BLKCLIST              *   FILE 434\n//* CATSRCHP  - Optional panel for invoking CATSRCH REXX exec       *   FILE 434\n//* XEFMENU   - eXtended Editor Facility Main Menu                  *   FILE 434\n//* XEFMENUB  - eXtended Editor Facility Main Menu (optional)       *   FILE 434\n//* XEFHELP   - eXtended Editor Facility Help Panel #1              *   FILE 434\n//* XEFHELP2  - eXtended Editor Facility Help Panel #2              *   FILE 434\n//* XEFHELP3  - eXtended Editor Facility Help Panel #3              *   FILE 434\n//* XEFHELP4  - eXtended Editor Facility Help Panel #4              *   FILE 434\n//* XEFINF    - eXtended Editor Facility Dataset Info Panel-SEQ     *   FILE 434\n//* XEFINFD   - eXtended Editor Facility Dataset Info Panel-PDS     *   FILE 434\n//* XEFINFE   - eXtended Editor Facility Dataset Info Panel-PDSE    *   FILE 434\n//* XEFINFP   - eXtended Editor Facility Dataset Info Panel-PDS SMS *   FILE 434\n//* XEFINFS   - eXtended Editor Facility Dataset Info Panel-SEQ SMS *   FILE 434\n//*                                                                 *   FILE 434\n//*                                                                 *   FILE 434\n//* ISPF MESSAGEs                                                   *   FILE 434\n//* --------------------------------------------------------------- *   FILE 434\n//* XEF00     - eXtended Editor Facility Messages                   *   FILE 434\n//*                                                                 *   FILE 434\n//*                                                                 *   FILE 434\n//* Miscellaneous                                                   *   FILE 434\n//* --------------------------------------------------------------- *   FILE 434\n//* XEF62     - XEF V6.2 in TSO XMIT format                         *   FILE 434\n//*                                                                 *   FILE 434\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ACBCHECK": {"ttr": 1292, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x085O\\x01\\x085O\\x140\\x00\\x82\\x00\\x82\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf7@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-12-19T00:00:00", "modifydate": "2008-12-19T14:30:00", "lines": 130, "newlines": 130, "modlines": 0, "user": "CBT477"}, "text": "//USZCZT0A JOB (ADSS),'#07B42 ZELDEN',\n//             NOTIFY=&SYSUID,\n//             CLASS=M,MSGCLASS=H,MSGLEVEL=(1,1)\n//*\n//*\n//ASMACL   PROC\n//C        EXEC PGM=ASMA90\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD  DSN=&&SYSUT1,SPACE=(4096,(120,120),,,ROUND),\n//             UNIT=SYSALLDA,DCB=BUFNO=1\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSN=&&OBJ,SPACE=(3040,(40,40),,,ROUND),\n//             UNIT=SYSALLDA,DISP=(MOD,PASS),\n//             DCB=(BLKSIZE=3040,LRECL=80,RECFM=FB,BUFNO=1)\n//L        EXEC PGM=HEWL,PARM='MAP,LET,LIST,NCAL',COND=(8,LT,C)\n//SYSLIN   DD  DSN=&&OBJ,DISP=(OLD,DELETE)\n//         DD  DDNAME=SYSIN\n//SYSLMOD  DD  DISP=(,PASS),UNIT=SYSALLDA,SPACE=(CYL,(1,1,1)),\n//             DSN=&&GOSET(GO)\n//SYSUT1   DD  DSN=&&SYSUT1,SPACE=(1024,(120,120),,,ROUND),\n//             UNIT=SYSALLDA,DCB=BUFNO=1\n//SYSPRINT DD  SYSOUT=*\n//  PEND\n//ASMACL   EXEC ASMACL,PARM.L='XREF,LIST'\n//C.SYSIN    DD *\n         TITLE 'ACBCHECK - CHECK IF VTAM ACB IS AVAILABLE'\n         PRINT NOGEN\n***************************************************************\n*** THIS PROGRAM WILL CHECK IF A VTAM ACB IS AVAILABLE,     ***\n*** IF IT IS NOT THE PROGRAM WILL WAIT 15 SECONDS AND TRY   ***\n*** AGAIN. IT WILL KEEP TRYING FOR UP TO 15 MINUTES.        ***\n***                                                         ***\n*** IT CAN BE PUT INTO STCS AS A FIRST STEP SO THE STC CAN  ***\n*** BE STARTED VIA COMMNDXX AT IPL BEFORE VTAM IS ACTIVE.   ***\n***                                                         ***\n*** THE PROGRAM MUST BE PASSED A PARM OF THE ACB TO CHECK.  ***\n***************************************************************\n*** SAMPLE JCL:\n***\n*** //ACBCHECK JOB (ACCT),'CHECK VTAM ACB',CLASS=M\n*** //STEP1 EXEC PGM=ACBCHECK,PARM=TSO\n*** //\n***\n*\n*  REGISTER EQUATES AND USAGE\n*\nR01      EQU   1                  INITIAL POINTER TO INPUT PARM\nR02      EQU   2                  WORK REGISTER\nR03      EQU   3                  POINTS TO PARM VALUE\nR04      EQU   4                  COUNT OF RETRIES\nR05      EQU   5                  LOADED WITH CONSTANT  1\nR06      EQU   6                  LOADED WITH CONSTANT  60\nR12      EQU   12                 BASE REGISTER\nR13      EQU   13                 POINTER TO SAVE AREA\nR14      EQU   14                 LINKAGE REGISTER (RETURN ADDRESS)\nR15      EQU   15                 LINKAGE REGISTER (ENTRY POINT)\n*\nACBCHECK CSECT\n         USING *,R12              SET UP REG 12 AS BASE REG\n         B     PASTID             BRANCH PAST MODULE ID\n         DC    C'ACBCHECK &SYSDATE &SYSTIME '\n         DC    C'*** AUTHOR: MARK ZELDEN ***'\nPASTID   SAVE  (14,12)            SAVE REGISTERS\n         LR    R12,R15            SET UP ADDRESSABILITY\n         LR    R02,R13            SAVE ADDR OF PREVIOUS SAVEAREA\n         LA    R13,SAVEAREA       POINT TO CURRENT SAVEAREA\n         ST    R13,8(R02)         SAVE THIS PROGRAM'S SAVEAREA ADDRESS\n         ST    R02,4(R13)         SAVE CALLERS SAVEAREA ADDRESS\n* ====================================================================\n         L     R03,0(R01)          POINT TO PARM VALUE\n         SR    R04,R04             ZERO COUNT REG\n         SR    R02,R02             ZERO EX REG\n         LH    R02,0(R03)          LOAD EX REG FROM PARM LENGTH\n         LTR   R02,R02             CHECK REGISTER FOR LENGTH\n         BZ    NOPARM              BRANCH IF ZERO\n         BCTR  R02,0               DECREMENT FOR MOVE\n         EX    R02,MVACBNM         MOVE PARM INTO ACBNAME\n*\n         LA    R05,1               LOAD COUNT \"AR\" REGISTER WITH 1\n         LA    R06,60              LOAD COUNT \"CR\" REGISTER WITH 60\n*\nCHECKACB DS    0H\n         CR    R04,R06             DOES WAIT COUNT = 60 (15 MINUTES) ?\n         BE    NOTIME              YES, BRANCH\n         SR    R15,R15             ZERO REG 15\n         OPEN  (TESTACB)           TRY TO OPEN VTAM ACB\n         LTR   R15,R15             DID IT OPEN\n         BZ    ACBOPEN             YES- GO ON\n         MVC   WAITWTO+40(8),ACBNAME    PLUG WTO WITH ACB NAME\nWAITWTO  WTO   'ACBCHECK - WAITING FOR VTAM ACB XXXXXXXX TO BECOME AVAIX\n               LABLE',ROUTCDE=(2,8,11),DESC=(6)\n         STIMER WAIT,DINTVL=TIMEVAL SET TO WAIT FOR 15 SECS\n         AR    R04,R05             INCREMENT COUNT REGISTER\n         B     CHECKACB            GO TRY AGAIN\nACBOPEN  DS    0H\n         MVC   OPENWTO+28(8),ACBNAME    PLUG WTO WITH ACB NAME\nOPENWTO  WTO   'ACBCHECK - VTAM ACB XXXXXXXX OPENED SUCCESSFULLY, NOW BX\n               EING CLOSED',ROUTCDE=(2,8,11),DESC=(6)\n         CLOSE (TESTACB)          CLOSE VTAM ACB\n         MVC   CONTWTO+44(8),ACBNAME    PLUG WTO WITH ACB NAME\nCONTWTO  WTO   'ACBCHECK - JOB WAITING FOR VTAM ACB XXXXXXXX WILL NOW CX\n               ONTINUE',ROUTCDE=(2,8,11),DESC=(6)\n         B     RETURN             RETURN\n         SPACE 2\nNOPARM   DS    0H\n         WTO   'ACBCHECK - NO PARM VALUE ENTERED - JOB CANCELLED',     X\n               ROUTCDE=(2,8,11),DESC=(6)\n         ABEND 01                 U0001 ABEND - NO DUMP\n         B     RETURN             RETURN\nNOTIME   DS    0H\n         WTO   'ACBCHECK - RETRY TIME LIMIT EXCEEDED - JOB CANCELLED', X\n               ROUTCDE=(2,8,11),DESC=(6)\n         ABEND 02                 U0002 ABEND - NO DUMP\nRETURN   L     R13,4(R13)         RESTORE CALLERS SAVAREA ADDRESS\n         RETURN (14,12),RC=0      RETURN CONTROL AND SET COND CODE TO 0\n         EJECT\n* ====================================================================\nMVACBNM  MVC   ACBNAME(0),2(3)    EXECUTED MOVE INSTRUCTION\nTIMEVAL  DS    0CL8               TIME TO WAIT (15 SEC.)\n         DC    CL2'00'            HOURS\n         DC    CL2'00'            MINUTES\n         DC    CL2'15'            SECONDS\n         DC    CL2'00'            TENTHS AND HUNDREDTHS\nAPPLIDID DS    0XL9\n         DC    XL1'08'\nACBNAME  DC    CL8' '           VTAM ACB NAME\nSAVEAREA DS    18F              SAVE AREA\nTESTACB  ACB   AM=VTAM,APPLID=APPLIDID,MACRF=NLOGON\n         END   ACBCHECK\n//L.SYSLMOD DD DSN=MPSYS3.USZCZT0.LOADLIB(ACBCHECK),DISP=SHR,UNIT=SYSDA\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AMBCLIST": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x992/\\x01\\x06\\x17\\x1f\\x145\\x00G\\x009\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "2006-06-20T14:35:00", "lines": 71, "newlines": 57, "modlines": 0, "user": "CBT472"}, "text": "PROC 0 UNIT(SYSALLDA)\nCONTROL NOMSG NOLIST NOCONLIST NOFLUSH\n/*                           */\n/* AUTHOR: MARK ZELDEN       */\n/*                           */\n/* LAST UPDATE: 06/20/2006   */\nLOOP: +\nISPEXEC DISPLAY PANEL(AMBPANEL)\n\n  /*  IF \"END\" WAS ENTERED, EXIT */\n\nIF &LASTCC = 8 THEN DO\n  EXIT CODE(0)\nEND\n\n\nFREE FI(SYSLIB SYSIN SYSPRINT)\nFREE ATTRLIST(DCB1 DCB2)\nCONTROL MSG\nIF &O \u00ac= 5 THEN DO\n  IF &STR(&AMBVOL) = &STR() THEN +\n    ALLOC FI(SYSLIB) DA(&AMBDSN) SHR\n  ELSE +\n    ALLOC FI(SYSLIB) DA(&AMBDSN) VOLUME(&AMBVOL) SHR\nEND\nSET &CC = &LASTCC\nCONTROL NOMSG\nIF &CC NE 0 THEN GOTO LOOP\nATTRIB DCB1 RECFM(F) LRECL(80) BLKSIZE(80)\nATTRIB DCB2 RECFM(F B) LRECL(121) BLKSIZE(5687)\nALLOC FILE(SYSIN) UNIT(&UNIT) SP(1,1) TRACK US(DCB1)\nALLOC FILE(SYSPRINT) UNIT(&UNIT) SP(1,10) CYL US(DCB2)\nOPENFILE SYSIN OUTPUT\nIF &O = 1 AND &STR(&AMBMEM) = &STR(*) THEN DO\n  SET &SYSIN=&STR( LISTIDR)\nEND\nELSE IF &O = 1 THEN DO\n  SET &SYSIN=&STR( LISTIDR MEMBER=&AMBMEM)\nEND\nIF &O = 2 AND &STR(&AMBMEM) = &STR(*) THEN DO\n  SET &SYSIN=&STR( LISTLOAD OUTPUT=XREF)\nEND\nELSE IF &O = 2 THEN DO\n  SET &SYSIN=&STR( LISTLOAD OUTPUT=XREF,MEMBER=&AMBMEM)\nEND\nIF &O = 3 AND &STR(&AMBMEM) = &STR(*) THEN DO\n  SET &SYSIN=&STR( LISTLOAD)\nEND\nELSE IF &O = 3 THEN DO\n  SET &SYSIN=&STR( LISTLOAD MEMBER=&AMBMEM)\nEND\nIF &O = 4 AND &STR(&AMBMEM) = &STR(*) THEN DO\n  SET &SYSIN=&STR( LISTOBJ)\nEND\nELSE IF &O = 4 THEN DO\n  SET &SYSIN=&STR( LISTOBJ MEMBER=&AMBMEM)\nEND\nIF &O = 5 THEN DO\n  SET &SYSIN=&STR( LISTLPA)\nEND\nPUTFILE SYSIN\nCLOSFILE SYSIN\nCALL 'SYS1.LINKLIB(AMBLIST)'\nISPEXEC LMINIT DATAID(AMBROWSE) DDNAME(SYSPRINT)\nISPEXEC BROWSE DATAID(&AMBROWSE)\nISPEXEC LMFREE DATAID(&AMBROWSE)\nFREE FI(SYSLIB SYSIN SYSPRINT)\nFREE ATTRLIST(DCB1 DCB2)\nALLOC FI(SYSPRINT) DA(*)\n\nGOTO LOOP\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AMBPANEL": {"ttr": 1540, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x992/\\x01\\x06\\x17\\x1f\\x145\\x00*\\x00)\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "2006-06-20T14:35:00", "lines": 42, "newlines": 41, "modlines": 0, "user": "CBT472"}, "text": ")ATTR\n      + TYPE(TEXT)  INTENS(LOW)\n      % TYPE(TEXT)  INTENS(HIGH)\n      _ TYPE(INPUT) INTENS(HIGH)\n)BODY EXPAND (//)\n%-/-/ Interactive AMBLIST  -/-/\n%COMMAND ===>_ZCMD                                                     +\n+\n+    Valid options:\n+    1=LISTIDR  2=LISTLOAD XREF  3=LISTLOAD  4=LISTOBJ  5=LISTLPA\n+\n+    List option  ===>_O+\n+    Library name ===>_AMBDSN                                      +\n+    Member name  ===>_AMBMEM  +\n+    Volser       ===>_AMBVOL+\n+\n+\n+    Choose an AMBLIST option. You must enter a valid library name and a\n+    member name when using options 1 through 4. An \"*\" can also be used\n+    to process all members when using options 1 through 4.  The library\n+    name and member name are ignored when using option 5 (LISTLPA).\n+\n+\n+    Press%PF3+to EXIT+\n)INIT\n  &ZPRIM = NO\n .CURSOR = O\n &O = &AMBOPT\n IF (&O = &Z )\n    &O = 1\n)PROC\n  VER (&O,NONBLANK)\n  VER (&O,LIST,1,2,3,4,5)\n  IF  (&O NE 5)\n    VER (&AMBDSN,NONBLANK)\n    VER (&AMBDSN,DSNAME)\n    VER (&AMBMEM,NONBLANK)\n    IF  (&AMBMEM NE '*')\n      VER (&AMBMEM,NAME)\n  &AMBOPT = &O\n  VPUT (AMBDSN AMBMEM AMBOPT AMBVOL) PROFILE\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "APFVER": {"ttr": 1542, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x992/\\x01\\x11\\x06?\\x14E\\x00\\xd3\\x00\\xca\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "2011-03-04T14:45:00", "lines": 211, "newlines": 202, "modlines": 0, "user": "CBT482"}, "text": "/* REXX */\n/*                           */\n/* AUTHOR: MARK ZELDEN       */\n/*                           */\n/**************************************************************/\n/* APF Authorized libraries checker REXX exec.                */\n/*                                                            */\n/* This program will report on various errors in the          */\n/* in-storage APF list, such as non-existent data sets or     */\n/* volumes that no longer exist or are not online.            */\n/*                                                            */\n/**************************************************************/\n/* NOTE: The dynamic APF code in this exec uses undocumented  */\n/*       IBM control blocks and may break at any time!        */\n/*    ... tested on MVS ESA 4.3 up to z/OS V1R3               */\n/**************************************************************/\n/* EXECUTION SYNTAX:                                          */\n/*                                                            */\n/* TSO %APFVER                                                */\n/*                                                            */\n/*  Any errors encountered are displayed on the terminal.     */\n/*                                                            */\n/**************************************************************/\nLASTUPD = '10/09/2007'                /* date of last update  */\nIf Sysvar(SYSISPF)='ACTIVE' then address ISREDIT \"MACRO\"\n/**************************************************************/\n /* Trace ?R   */\n /* Trace ?I   */\n /* Trace err  */\nNUMERIC  DIGITS 10\nCVT      = C2d(Storage(10,4))                /* point to cvt */\nGRSNAME  = Storage(D2x(CVT + 340),8)         /* point to system name */\nGRSNAME  = Strip(GRSNAME,'T')                /* del trailing blanks  */\nCVTAUTHL = C2d(Storage(D2x(CVT + 484),4))    /* point to auth lib tbl*/\nIf CVTAUTHL <> C2d('7FFFF001'x) then do      /* static list ?        */\n  NUMAPF   = C2d(Storage(D2x(CVTAUTHL),2))   /* # APF libs in table  */\n  APFOFF   = 2                               /* first ent in APF tbl */\n  Do I = 1 to NUMAPF\n     LEN = C2d(Storage(D2x(CVTAUTHL+APFOFF),1)) /* length of entry   */\n     VOL.I = Storage(D2x(CVTAUTHL+APFOFF+1),6)  /* VOLSER of APF LIB */\n     DSN.I = Storage(D2x(CVTAUTHL+APFOFF+1+6),LEN-6) /*DSN of APF lib*/\n     APFOFF = APFOFF + LEN +1\n  End\nEnd\nElse Do  /* dynamic APF list via PROGxx */\n  ECVT     = C2d(Storage(D2x(CVT + 140),4))  /* point to CVTECVT     */\n  ECVTCSVT = C2d(Storage(D2x(ECVT + 228),4)) /* point to CSV table   */\n  APFA = C2d(Storage(D2x(ECVTCSVT + 12),4))  /* APFA                 */\n  AFIRST = C2d(Storage(D2x(APFA + 8),4))     /* First entry          */\n  ALAST  = C2d(Storage(D2x(APFA + 12),4))    /* Last  entry          */\n  LASTONE = 0   /* flag for end of list      */\n  NUMAPF = 1    /* tot # of entries in list  */\n  Do forever\n     DSN.NUMAPF = Storage(D2x(AFIRST+24),44) /* DSN of APF library   */\n     DSN.NUMAPF = Strip(DSN.NUMAPF,'T')      /* remove blanks        */\n     CKSMS = Storage(D2x(AFIRST+4),1)        /* DSN of APF library   */\n     if  bitand(CKSMS,'80'x)  = '80'x        /*  SMS data set?       */\n       then VOL.NUMAPF = '*SMS* '            /* SMS control dsn      */\n     else VOL.NUMAPF = Storage(D2x(AFIRST+68),6) /* VOLSER of APF lib*/\n     If Substr(DSN.NUMAPF,1,1) <> X2c('00')  /* check for deleted    */\n       then NUMAPF = NUMAPF + 1              /*   APF entry          */\n     AFIRST = C2d(Storage(D2x(AFIRST + 8),4)) /* next  entry          */\n     if LASTONE = 1 then leave\n     If  AFIRST = ALAST then LASTONE = 1\n  End\n  NUMAPF = NUMAPF-1\nEnd\n/**************************************/\n/* We now have all of the APF entries */\n/**************************************/\nSay   'VERIFICATION OF IN-STORAGE APF LIST IN PROGRESS:',\n      'SYSTEM' grsname Translate(Date(N))\nQueue 'VERIFICATION OF IN-STORAGE APF LIST IN PROGRESS:',\n      'SYSTEM' grsname Translate(Date(N))\nSay   '                 '\nQueue '                 '\nERRCNT = 0 /* error count */\nDo I = 1 to NUMAPF\n  If VOL.I = '*SMS*' then ,\n    RETCODE = Listdsi(''''DSN.I''''  norecall)\n  Else ,\n    RETCODE = Listdsi(''''DSN.I'''' 'volume('VOL.I')'  norecall)\n  If RETCODE <> 0 then do\n    Say   'ERROR ENCOUNTERED WHILE VERIFYING THE FOLLOWING DATASET:'\n    Queue 'ERROR ENCOUNTERED WHILE VERIFYING THE FOLLOWING DATASET:'\n    Say    DSN.I\n    Queue  DSN.I\n    If SYSREASON = 24 then do\n      Say   DSN.I 'DOES NOT EXIST ON VOLUME 'VOL.I\n      Queue DSN.I 'DOES NOT EXIST ON VOLUME 'VOL.I\n      Say   '     '\n      Queue '     '\n      ERRCNT = ERRCNT + 1\n    End\n    Else Do\n      Say   SYSMSGLVL2\n      Queue SYSMSGLVL2\n   /* Say 'REASON CODE IN SYSREASON = 'SYSREASON  */\n      Say   '     '\n      Queue '     '\n      ERRCNT = ERRCNT + 1\n    End\n    iterate /* get next record */\n  End /* if retcode */\nEnd  /* do i = 1 to NUMAPF  */\nIf ERRCNT = 0 then do\n  Say   'THE IN-STORAGE APF LIST HAD NO ERRORS'\n  Queue 'THE IN-STORAGE APF LIST HAD NO ERRORS'\nEnd\nElse Do\n  Say   'THE IN-STORAGE APF LIST HAD 'ERRCNT' ERROR(S)'\n  Queue 'THE IN-STORAGE APF LIST HAD 'ERRCNT' ERROR(S)'\nEnd\n/*********************************************************************/\n/* If ISPF is active, browse output - otherwise end                  */\n/*********************************************************************/\nQueue ''  /* null queue to end stack   */\nIf Sysvar(SYSISPF)='ACTIVE' then do\n  /* BROWSE_ISPF:  Browse output if ISPF is active  */\n  Address ISPEXEC \"CONTROL ERRORS RETURN\"\n  Address ISPEXEC \"VGET ZENVIR\"\n  Address TSO\n  prefix = sysvar('SYSPREF')        /* tso profile prefix            */\n  uid    = sysvar('SYSUID')         /* tso userid                    */\n  If prefix = '' then prefix = uid  /* use uid if null prefix        */\n  If prefix <> '' & prefix <> uid then /* different prefix than uid  */\n     prefix = prefix || '.' || uid /* use  prefix.uid                */\n  ddnm1 = 'DDO'||random(1,99999)   /* choose random ddname           */\n  ddnm2 = 'DDP'||random(1,99999)   /* choose random ddname           */\n  junk = msg('off')\n  \"ALLOC FILE(\"||ddnm1||\") UNIT(SYSALLDA) NEW TRACKS SPACE(2,1) DELETE\",\n        \" REUSE LRECL(80) RECFM(F B) BLKSIZE(3120)\"\n  \"ALLOC FILE(\"||ddnm2||\") UNIT(SYSALLDA) NEW TRACKS SPACE(1,1) DELETE\",\n        \" REUSE LRECL(80) RECFM(F B) BLKSIZE(3120) DIR(1)\"\n  junk = msg('on')\n  \"Newstack\"\n  /*************************/\n  /* APFVERP Panel source  */\n  /*************************/\n  If Substr(ZENVIR,6,1) >= 4 then\n    Queue \")PANEL KEYLIST(ISRSPBC,ISR)\"\n  Queue \")ATTR\"\n  Queue \"  _ TYPE(INPUT)   INTENS(HIGH) COLOR(TURQ) CAPS(OFF)\" ,\n        \"FORMAT(&MIXED)\"\n  Queue \"  | AREA(DYNAMIC) EXTEND(ON)   SCROLL(ON)\"\n  Queue \"  + TYPE(TEXT)    INTENS(LOW)  COLOR(BLUE)\"\n  Queue \"  @ TYPE(TEXT)    INTENS(LOW)  COLOR(TURQ)\"\n  Queue \"  % TYPE(TEXT)    INTENS(HIGH) COLOR(GREEN)\"\n  Queue \"  ! TYPE(OUTPUT)  INTENS(HIGH) COLOR(TURQ) PAD(-)\"\n  Queue \" 01 TYPE(DATAOUT) INTENS(LOW)\"\n  Queue \" 02 TYPE(DATAOUT) INTENS(HIGH)\"\n  Queue \" 0B TYPE(DATAOUT) INTENS(HIGH) FORMAT(DBCS)\"\n  Queue \" 0C TYPE(DATAOUT) INTENS(HIGH) FORMAT(EBCDIC)\"\n  Queue \" 0D TYPE(DATAOUT) INTENS(HIGH) FORMAT(&MIXED)\"\n  Queue \" 10 TYPE(DATAOUT) INTENS(LOW)  FORMAT(DBCS)\"\n  Queue \" 11 TYPE(DATAOUT) INTENS(LOW)  FORMAT(EBCDIC)\"\n  Queue \" 12 TYPE(DATAOUT) INTENS(LOW)  FORMAT(&MIXED)\"\n  Queue \")BODY EXPAND(//)\"\n  Queue \"%BROWSE  @&ZTITLE  / /  %Line!ZLINES  %Col!ZCOLUMS+\"\n  Queue \"%Command ===>_ZCMD / /           %Scroll ===>_Z   +\"\n  Queue \"|ZDATA ---------------/ /-------------------------|\"\n  Queue \"|                     / /                         |\"\n  Queue \"| --------------------/-/-------------------------|\"\n  Queue \")INIT\"\n  Queue \"  .HELP = ISR10000\"\n  Queue \"  .ZVARS = 'ZSCBR'\"\n  Queue \"  &ZTITLE = 'Mark''s MVS Utilities - APFVER'\"\n  Queue \"  &MIXED = MIX\"\n  Queue \"  IF (&ZPDMIX = N)\"\n  Queue \"   &MIXED = EBCDIC\"\n  Queue \"  VGET (ZSCBR) PROFILE\"\n  Queue \"  IF (&ZSCBR = ' ')\"\n  Queue \"   &ZSCBR = 'CSR'\"\n  Queue \")REINIT\"\n  Queue \"  REFRESH(ZCMD,ZSCBR,ZDATA,ZLINES,ZCOLUMS)\"\n  Queue \")PROC\"\n  Queue \"  &ZCURSOR = .CURSOR\"\n  Queue \"  &ZCSROFF = .CSRPOS\"\n  Queue \"  &ZLVLINE = LVLINE(ZDATA)\"\n  Queue \"  VPUT (ZSCBR) PROFILE\"\n  Queue \")END\"\n  Queue \"\"\n  /*                                    */\n  Address ISPEXEC \"LMINIT DATAID(PAN) DDNAME(\"ddnm2\")\"\n  Address ISPEXEC \"LMOPEN DATAID(\"pan\") OPTION(OUTPUT)\"\n  Do queued()\n     Parse pull panline\n     Address ISPEXEC \"LMPUT DATAID(\"pan\") MODE(INVAR)\" ,\n             \"DATALOC(PANLINE) DATALEN(80)\"\n  End\n  Address ISPEXEC \"LMMADD DATAID(\"pan\") MEMBER(APFVERP)\"\n  Address ISPEXEC \"LMFREE DATAID(\"pan\")\"\n  \"Delstack\"\n  \"EXECIO * DISKW\" ddnm1 \"(FINIS\"\n  If ERRCNT = 0 then zedsmsg = 'NO ERRORS'\n                else zedsmsg = ERRCNT 'ERROR(S)'\n  zedlmsg = 'APFVER - Last updated  on' ,\n             LASTUPD ||'. Written by' ,\n            'Mark Zelden. Mark''s MVS Utilities -' ,\n            'http://www.mzelden.com/mvsutil.html'\n  address ISPEXEC \"LIBDEF ISPPLIB LIBRARY ID(\"||ddnm2||\") STACK\"\n  address ISPEXEC \"SETMSG MSG(ISRZ000)\"  /* msg - no alarm   */\n  address ISPEXEC \"LMINIT DATAID(TEMP) DDNAME(\"||ddnm1||\")\"\n  address ISPEXEC \"BROWSE DATAID(\"||temp\") PANEL(APFVERP)\"\n  address ISPEXEC \"LMFREE DATAID(\"||temp\")\"\n  address ISPEXEC \"LIBDEF ISPPLIB\"\n  junk = msg('off')\n  \"FREE FI(\"||ddnm1||\")\"\n  \"FREE FI(\"||ddnm2||\")\"\nEnd\nElse \"delstack\" /* empty stack for non-ispf invocation */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ASIDLIST": {"ttr": 1547, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x992/\\x01\\x16\\t_\\x16E\\x01\\xb8\\x01\\xae\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf9\\xf1@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "2016-04-04T16:45:00", "lines": 440, "newlines": 430, "modlines": 0, "user": "CBT491"}, "text": "//TSGMXZ1G JOB (AD00),'#04D42 ZELDEN',\n//             NOTIFY=&SYSUID,\n//             CLASS=M,MSGCLASS=H,MSGLEVEL=(1,1)\n//*\n//ASMHCLG PROC\n//C       EXEC PGM=IEV90,\n//             PARM=(NODECK,OBJECT)\n//SYSLIB   DD  DSN=SYS1.MACLIB,\n//             DISP=SHR\n//SYSUT1   DD  DSN=&SYSUT1,SPACE=(1024,(120,120),,,ROUND),UNIT=VIO,\n//             DCB=BUFNO=1\n//SYSPUNCH DD  SYSOUT=B\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSN=&OBJ,SPACE=(3040,(40,40),,,ROUND),UNIT=VIO,\n//             DISP=(MOD,PASS),\n//             DCB=(BLKSIZE=3040,LRECL=80,RECFM=FBS,BUFNO=1)\n//L       EXEC PGM=IEWL,COND=(5,LT,C),\n//             PARM='LIST,LET,XREF,MAP'\n//SYSLIN   DD  DSN=&OBJ,\n//             DISP=(OLD,DELETE)\n//         DD  DDNAME=SYSIN\n//SYSLMOD  DD  SPACE=(CYL,(1,1,1)),DSN=&LOD(X),\n//             DISP=(,PASS),\n//             UNIT=SYSDA,DCB=BUFNO=1\n//SYSUT1   DD  DSN=&SYSUT1,SPACE=(1024,(120,120),,,ROUND),UNIT=VIO,\n//             DCB=BUFNO=1\n//SYSPRINT DD  SYSOUT=*\n//G       EXEC PGM=*.L.SYSLMOD,COND=((5,LT,L),(5,LT,C))\n//        PEND\n//*\n//ASMHCLG  EXEC ASMHCLG,PARM.L='XREF,LIST',PARM.G=58\n//C.SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//           DD DSN=SYS1.MODGEN,DISP=SHR\n//C.SYSIN    DD *\n         TITLE 'ASIDLIST - LIST ASIDS IN THE SYSTEM'\n         PRINT NOGEN\n***********************************************************************\n* THIS PROGRAM WILL WRITE OUT THE NAMES OF ALL ADDRESS SPACE          *\n* IDS IN THE SYSTEM, THEIR ASCB ADDRESS, THEIR ASID NUMBER IN         *\n* HEX AND IN DECIMAL AS SHOWN IN THE SAMPLE BELOW:                    *\n*                                                                     *\n*   ASCB FOUND AT 00FD4100: *MASTER* - ASID X'0001' (   1 IN DECIMAL) *\n*   ASCB FOUND AT 00F4BE80: PCAUTH   - ASID X'0002' (   2 IN DECIMAL) *\n*   ASCB FOUND AT 00F4D700: RASP     - ASID X'0003' (   3 IN DECIMAL) *\n*   ASCB FOUND AT *NONREUS: *NONREUS - ASID X'000E' (  14 IN DECIMAL) *\n*   ASCB FOUND AT *AVALABL: *AVALABL - ASID X'0037' (  55 IN DECIMAL) *\n*   ASCB FOUND AT *AVALABL: *AVALABL - ASID X'NNNN' (NNNN IN DECIMAL) *\n*                                                                     *\n* THIS PROGRAM ALSO DISPLAYS TOTALS AS SHOWN BELOW:                   *\n*                                                                     *\n*       TOTAL ADDRESS SPACES IN THE SYSTEM:               NNNN        *\n*       TOTAL ACTIVE ADDRESS SPACES IN THE SYSTEM:        NNNN        *\n*       TOTAL AVAILABLE ADDRESS SPACES IN THE SYSTEM:     NNNN        *\n*       TOTAL NON-REUSABLE ADDRESS SPACES IN THE SYSTEM:  NNNN        *\n*                                                                     *\n*                                                                     *\n*               ASID USAGE FROM ASVT                                  *\n*                                                                     *\n*       MAXUSER FROM IEASYSXX:  NNNN                                  *\n*                IN USE ASIDS:  NNNN                                  *\n*             AVAILABLE ASIDS:  NNNN                                  *\n*                                                                     *\n*       RSVSTRT FROM IEASYSXX:  NNNN                                  *\n*              RSVSTRT IN USE:  NNNN                                  *\n*           RSVSTRT AVAILABLE:  NNNN                                  *\n*                                                                     *\n*       RSVNONR FROM IEASYSXX:  NNNN                                  *\n*              RSVNONR IN USE:  NNNN                                  *\n*           RSVNONR AVAILABLE:  NNNN                                  *\n*                                                                     *\n*       NON-REUSABLE ASIDS   :  NNNN                                  *\n*                                                                     *\n*                                                                     *\n* THE DEFAULT OUTPUT IS 55 LINES PER PAGE. AN OPTIONAL 2 DIGIT INPUT  *\n* PARAMETER MAY BE SPECIFIED TO CHANGE THE DEFAULT LINES PER PAGE.    *\n***********************************************************************\n*** SAMPLE JCL:\n***\n*** //ASIDLIST JOB (ACCT),'COUNT JOBS',CLASS=M\n*** //STEP1 EXEC PGM=ASIDLIST,PARM=58\n*** //SYSPRINT  DD  SYSOUT=*\n*** //\n***********************************************************************\n* UPDATES:\n* 04/04/2016 MSZ  ADDED AMODE 31 / RMODE 24 ASSEMBLER DIRECTIVES TO\n*                 TO SUPPORT ASVT IN 31-BIT STORAGE IN Z/OS 2.1\n*                 AND ABOVE VIA DIAGXX CBLOC\n***********************************************************************\n***\n*\n*  REGISTER EQUATES AND USAGE\n*\nR00      EQU   0                  LINKAGE REGISTER\nR01      EQU   1                  INITIAL POINTER TO INPUT PARM\nR02      EQU   2                  WORK REG\nR03      EQU   3                  POINTS TO PARM / MAX # ASVT ENTRIES\nR04      EQU   4                  WORK - POINTS TO CURRENT ADDR IN ASVT\nR05      EQU   5                  WORK REG\nR06      EQU   6                  WORK REG - USED FOR BAL TO PRINT RTNS\nR07      EQU   7                  POINTS TO START OF ASVTENTY\nR08      EQU   8                  ASID COUNTER\nR09      EQU   9                  BASE REG FOR ASVT\nR10      EQU   10                 BASE REG FOR ASCB\nR11      EQU   11                 2ND BASE REG\nR12      EQU   12                 BASE REGISTER\nR14      EQU   14                 LINKAGE REGISTER (RETURN ADDRESS)\nR15      EQU   15                 LINKAGE REGISTER (ENTRY POINT)\n*\nASIDLIST CSECT\nASIDLIST AMODE 31                 ADDED FOR IHAASVT IN 31-BIT MODE\nASIDLIST RMODE 24                 ADDED FOR IHAASVT IN 31-BIT MODE\n         B     START-ASIDLIST(R15)\n         DC    AL1(START-*)\n         DC    C'ASIDLIST &SYSDATE &SYSTIME '\n         DC    C'*** AUTHOR: MARK ZELDEN ***'\nSTART    BAKR  R14,R00            BRANCH AND STACK (LINKAGE STACK)\n         LR    R12,R15            SET UP ADDRESSABILITY\n         LA    R11,2048(R12)      SET UP ADDRESSABILITY TO 2ND\n         LA    R11,2048(R11)        BASE REGISTER\n         USING ASIDLIST,R12,R11   SET UP BASE REGISTERS\n* ====================================================================\n*******************************************************************\n* PROCESS INPUT PARM (IF THERE IS ONE)\n*******************************************************************\n         L     R03,0(R01)         POINT TO INPUT PARM\n         CLC   0(2,R03),=H'0'     IS LENGTH=0 (NO PARM) ?\n         BNE   USEPARM            NO, BRANCH AND USE PARM VALUE\n         MVC   MAXLINES,=PL2'55'  YES, MOVE DEFAULT MAX LINES PER PAGE\n         B     OPEN               BRANCH\nUSEPARM  CLC   0(2,R03),=H'2'     IS LENGTH=2  ?\n         BNE   BADPARM            NO, BRANCH\n         MVC   PARMLINE,2(R03)    MOVE PARM VALUE\n         PACK  MAXLINES,PARMLINE  PACK IT\n*******************************************************************\n* OPEN SYSPRINT AND INITIALIZE COUNTERS\n*******************************************************************\nOPEN     OPEN  (SYSPRINT,(OUTPUT)) OPEN SYSPRINT FILE\n         ZAP   TOTASIDS,=P'0'     ZERO OUT TOTAL ASID COUNTER\n         ZAP   TOTACTIV,=P'0'     ZERO OUT TOTAL ACTIVE ASID COUNTER\n         ZAP   TOTAVAL,=P'0'      ZERO OUT TOTAL AVAILABLE ASID COUNTER\n         ZAP   TOTNONR,=P'0'      ZERO OUT TOTAL NON-REUSABLE COUNTER\n         ZAP   LINCOUNT,=P'0'     ZERO CURRENT LINE # ON PAGE COUNTER\n         ZAP   PAGCOUNT,=P'1'     INITIALIZE PAGE COUNTER\n         LA    R08,1              INITIALIZE ASID COUNTER TO 1\n         BAL   R06,PUTTITLE       BRANCH TO PRINT TITLE SUB-ROUTINE\n*******************************************************************\n* POINT TO ASVT\n*******************************************************************\n         L     R09,CVTPTR         POINT TO CVT  - X'10'\n         USING CVT,R09            MAP CVT\n         L     R09,CVTASVT        POINT TO ASVT\n         DROP  R09                TELL ASMBLR TO STOP USING R09 FOR CVT\n         USING ASVT,R09           MAP ASVT\n         LA    R04,ASVTENTY       POINT TO FIRST ENTRY IN TABLE\n         LR    R07,R04            SAVE ADDRESS IN R7 FOR LATER\n         L     R03,ASVTMAXU       LOAD MAX NUMBER OF ENTRIES\nASVTLOOP DS    0H\n*******************************************************************\n* IS A NEW TOP OF FORM IS NEEDED ?\n*******************************************************************\nTITLECHK DS    0H\n         CP    LINCOUNT,MAXLINES  DO WE NEED A NEW PAGE?\n         BL    SAMEPAGE           NO, BRANCH\n         BAL   R06,PUTTITLE       BRANCH TO PRINT TITLE SUB-ROUTINE\nSAMEPAGE DS    0H\n*******************************************************************\n* THIS ROUTINE CHECKS EACH ASVT ENTRY.\n* IF THE HIGH ORDER BIT IS ON, THE ENTRY IS THE ADDRESS OF THE\n* NEXT AVAILABLE ASID (OR THE LAST ENTRY IF ZEROS).\n* IF THE HIGH ORDER BIT IS NOT ON, THE ENTRY IS THE ADDRESS\n* OF THE ASCB FOR THAT ENTRY. IT THE HIGH ORDER BIT IS ON AND\n* THE ENTRY CONTAINS THE ADDRESS OF MASTER'S ASCB, THEN THE ASID\n* IS NON-REUSABLE.\n*******************************************************************\n         TM    0(R04),ASVTAVAL    IS THIS AN ASSIGNED  ASCB\n         BNO   CHKASCB            YES, BRANCH\n         L     R05,0(R04)         SAVE ADDRESS\n         SL    R05,=X'80000000'    ZERO OUT HIGH ORDER BIT\n         CR    R05,R07            IS THIS A NON-REUSABLE ASID?\n         BNE   AVALAS             MUST BE AVAILABLE, BRANCH\n         MVC   JOBNAME,=C'*NONREUS' MOVE 'NONREUS' INTO JOBNAME\n         AP    TOTNONR,=P'1'      ADD 1 TO TOTAL NON-REUSABLE COUNTER\n         BAL   R06,PUTPRTLN       BRANCH TO PRINT SUB-ROUTINE\n         LA    R04,4(,R04)        NO, POINT TO NEXT ENTRY IN ASVT\n         BCT   R03,ASVTLOOP       GO CHECK NEXT ASVT ENTRY\n         B     TOTALS             NO MORE ENTRIES - BRANCH\nAVALAS   DS    0H\n         MVC   JOBNAME,=C'*AVALABL' MOVE 'AVAILABLE' INTO JOBNAME\n         AP    TOTAVAL,=P'1'      ADD 1 TO TOTAL AVAILABLE COUNTER\n         BAL   R06,PUTPRTLN       BRANCH TO PRINT SUB-ROUTINE\n         LA    R04,4(,R04)        NO, POINT TO NEXT ENTRY IN ASVT\n         BCT   R03,ASVTLOOP       GO CHECK NEXT ASVT ENTRY\n         B     TOTALS             NO MORE ENTRIES - BRANCH\n*******************************************************************\n* CHECK ASCB FOR JOB OR START/LOGON/MOUNT\n*******************************************************************\nCHKASCB  L     R10,0(R04)         POINT TO ASCB\n         USING ASCB,R10           MAP IT\n         L     R05,ASCBJBNI       POINT TO JOBNAME\n         C     R05,=F'0'          WAS THIS A START/MOUNT/LOGON ?\n         BE    NOTAJOB            YES, BRANCH\n         MVC   JOBNAME,0(R05)     MOVE JOBNAME INTO MSG\n         AP    TOTACTIV,=P'1'     ADD 1 TO TOTAL ACTIVE COUNTER\n         BAL   R06,PUTPRTLN       BRANCH TO PRINT SUB-ROUTINE\n         LA    R04,4(,R04)        POINT TO NEXT ENTRY IN ASVT\n         BCT   R03,ASVTLOOP       GO CHECK NEXT ASVT ENTRY\n         B     TOTALS             NO MORE ENTRIES - BRANCH\nNOTAJOB  DS    0H\n         L     R05,ASCBJBNS       POINT TO START/MOUNT/LOGON NAME\n         C     R05,=F'0'          NAME PRESENT ?\n         BNE   MOVESNAM           YES, BRANCH\n         MVC   JOBNAME,=C'*STRTING' MOVE 'STRTING' INTO JOBNAME\n         B     SKIPSNAM\nMOVESNAM MVC   JOBNAME,0(R05)     MOVE JOBNAME INTO MSG\nSKIPSNAM AP    TOTACTIV,=P'1'     ADD 1 TO TOTAL ACTIVE COUNTER\n         BAL   R06,PUTPRTLN       BRANCH TO PRINT SUB-ROUTINE\n         LA    R04,4(,R04)        POINT TO NEXT ENTRY IN ASVT\n         BCT   R03,ASVTLOOP       GO CHECK NEXT ASVT ENTRY\n         B     TOTALS             NO MORE ENTRIES - BRANCH\n*******************************************************************\n* SUB ROUTINE TO PRINT TITLE LINES ON TOP OF PAGE\n*******************************************************************\nPUTTITLE MVC   EDPAGNUM,EDMASK    MOVE EDIT WORD TO OUTPUT\n         ED    EDPAGNUM,PAGCOUNT  MAKE PAGE NUMBER COUNT PRINTABLE\n         MVC   PAGENUM(2),EDPAGNUM+2\n         PUT   SYSPRINT,TITLELN1  WRITE\n         PUT   SYSPRINT,TITLELN2    TITLE\n         PUT   SYSPRINT,BLANKLIN  WRITE BLANK LINE\n         AP    PAGCOUNT,=P'1'     ADD 1 TO PAGE NUMBER COUNTER\n         ZAP   LINCOUNT,=P'2'     INITITALIZE LINE NUMBER COUNTER TO 2\n         BR    R06                RETURN\n*******************************************************************\n* SUB ROUTINE TO WRITE A PRINT LINE\n*******************************************************************\nPUTPRTLN LR    R05,R08            LOAD ASID NUMBER\n         CVD   R05,CVDWORK        CONVERT TO DECIMAL\n         MVC   EDASID,EDMASK2     MOVE EDIT MASK\n         ED    EDASID,CVDWORK+5   UNPACK AND EDIT\n         MVI   ASIDHEX+6,C'('     MOVE \"(\" TO PRINTOUT\n         STCM  R08,B'0011',WORK3  STORE \"HEX\" ASID\n         UNPK  WORK5,WORK3        ADD ZONES\n         TR    WORK5(4),HEXTAB-C'0'   TRANSLATE TO CHARACTERS\n         MVC   ASIDHEX(4),WORK5   MOVE HEX ASID\n*====================================================\n         CLC   JOBNAME,=C'*NONREUS' IS IT A NON-REUSABLE ASID?\n         BNE   CHKAVAL\n         MVC   ASCBADDR,=C'*NONREUS'\n         B     SKIPCVRT\nCHKAVAL  CLC   JOBNAME,=C'*AVALABL' IS IT AN AVAILABLE ASID\n         BNE   CVRTADDR\n         MVC   ASCBADDR,=C'*AVALABL'\n         B     SKIPCVRT\nCVRTADDR ST    R10,WORK4          STORE ASCB ADDR X'ABCDEFAB'\n         MVC   WORK5(4),WORK4     ABCDEFAB00\n         UNPK  WORK9,WORK5        FAFBFCFDFEFFFAFB00\n         TR    WORK9(8),HEXTAB-C'0'   C1C2C3C4C5C6C1C200\n         MVC   ASCBADDR(8),WORK9  C'ABCDEFAB'\nSKIPCVRT PUT   SYSPRINT,ACTMSG    WRITE JOB ACTIVE MSG\n         MVC   JOBNAME,=CL8' '    CLEAR JOBNAME\n         AP    TOTASIDS,=P'1'     ADD 1 TO TOTAL COUNTER\n         AP    LINCOUNT,=P'1'     ADD 1 TO LINE NUMBER COUNTER\n         AH    R08,=X'0001'       ADD 1 TO ASID NUMBER\n         BR    R06                RETURN\n*******************************************************************\n* PUT OUT TOTAL MESSAGES\n*******************************************************************\nTOTALS   DS    0H\n         L     R05,ASVTMAXI       MAXUSERS FROM ASVT\n         CVD   R05,CVDWORK        CONVERT TO DECIMAL\n         MVC   EDTOTMX,EDMASK2    MOVE EDIT MASK\n         ED    EDTOTMX,CVDWORK+5  UNPACK AND EDIT\n         L     R06,ASVTAAV        AVAILABLE FROM ASVT\n         CVD   R06,CVDWORK        CONVERT TO DECIMAL\n         MVC   EDTOTAVA,EDMASK2    MOVE EDIT MASK\n         ED    EDTOTAVA,CVDWORK+5  UNPACK AND EDIT\n         SLR   R05,R06            CALCULATED IN USE ASIDS\n         CVD   R05,CVDWORK        CONVERT TO DECIMAL\n         MVC   EDTOTAVI,EDMASK2    MOVE EDIT MASK\n         ED    EDTOTAVI,CVDWORK+5  UNPACK AND EDIT\n         L     R05,ASVTSTRT       START/SASI FROM ASVT (RSVSTRT)\n         CVD   R05,CVDWORK        CONVERT TO DECIMAL\n         MVC   EDTOTST,EDMASK2    MOVE EDIT MASK\n         ED    EDTOTST,CVDWORK+5  UNPACK AND EDIT\n         L     R06,ASVTAST        AVAILABLE START/SASI FROM ASVT\n         CVD   R06,CVDWORK        CONVERT TO DECIMAL\n         MVC   EDTOTSTA,EDMASK2   MOVE EDIT MASK\n         ED    EDTOTSTA,CVDWORK+5 UNPACK AND EDIT\n         SLR   R05,R06            CALCULATED IN USE SASI\n         CVD   R05,CVDWORK        CONVERT TO DECIMAL\n         MVC   EDTOTSTI,EDMASK2   MOVE EDIT MASK\n         ED    EDTOTSTI,CVDWORK+5 UNPACK AND EDIT\n         L     R05,ASVTNONR       NON-RESUSABLE FROM ASVT (RSVNONR)\n         CVD   R05,CVDWORK        CONVERT TO DECIMAL\n         MVC   EDTOTNR,EDMASK2    MOVE EDIT MASK\n         ED    EDTOTNR,CVDWORK+5  UNPACK AND EDIT\n         L     R06,ASVTANR        AVAILABLE NON-REUSABLE FROM ASVT\n         CVD   R06,CVDWORK        CONVERT TO DECIMAL\n         MVC   EDTOTNRA,EDMASK2   MOVE EDIT MASK\n         ED    EDTOTNRA,CVDWORK+5 UNPACK AND EDIT\n         SLR   R05,R06            CALCULATED IN USE NON-REUSABLE\n         CVD   R05,CVDWORK        CONVERT TO DECIMAL\n         MVC   EDTOTNRI,EDMASK2   MOVE EDIT MASK\n         ED    EDTOTNRI,CVDWORK+5 UNPACK AND EDIT\n*\n         BAL   R06,PUTTITLE       BRANCH TO PRINT TITLE SUB-ROUTINE\n         MVC   EDTOTAS,EDMASK2    MOVE EDIT WORD TO OUTPUT\n         ED    EDTOTAS,TOTASIDS   MAKE TOTAL COUNT PRINTABLE\n         MVC   EDTOTACT,EDMASK2   MOVE EDIT WORD TO OUTPUT\n         ED    EDTOTACT,TOTACTIV  MAKE TOTAL COUNT PRINTABLE\n         MVC   EDTOTAV,EDMASK2    MOVE EDIT WORD TO OUTPUT\n         ED    EDTOTAV,TOTAVAL    MAKE TOTAL COUNT PRINTABLE\n         MVC   EDTOTNOR,EDMASK2   MOVE EDIT WORD TO OUTPUT\n         ED    EDTOTNOR,TOTNONR   MAKE TOTAL COUNT PRINTABLE\n*\n         MVC   TOT2NOR,EDTOTNOR   MOVE EDITED NUMBER OR NON-REUSE\n*\n         PUT   SYSPRINT,TOTALLN1  WRITE TOTAL1 HEADER LINE\n         PUT   SYSPRINT,BLANKLIN  WRITE BLANK LINE\n         PUT   SYSPRINT,TOTASMG   WRITE TOTAL ASID MSG\n         PUT   SYSPRINT,TOTACTMG  WRITE TOTAL ACTIVE ASID MSG\n         PUT   SYSPRINT,TOTAVAMG  WRITE TOTAL AVAILABLE ASID MSG\n         PUT   SYSPRINT,TOTNORMG  WRITE TOTAL NON-REUSABLE ASID MSG\n         PUT   SYSPRINT,BLANKLIN  WRITE BLANK LINE\n         PUT   SYSPRINT,BLANKLIN  WRITE BLANK LINE\n         PUT   SYSPRINT,TOTALLN2  WRITE TOTAL2 HEADER LINE\n         PUT   SYSPRINT,BLANKLIN  WRITE BLANK LINE\n         PUT   SYSPRINT,TOTMAXU   WRITE ASVT MAXUSER LINE\n         PUT   SYSPRINT,TOTAVI    WRITE ASVT TOTAL IN USE LINE\n         PUT   SYSPRINT,TOTAVA    WRITE ASVT TOTAL AVAILABLE LINE\n         PUT   SYSPRINT,BLANKLIN  WRITE BLANK LINE\n         PUT   SYSPRINT,TOTSASI   WRITE ASVT RSVSTRT LINE\n         PUT   SYSPRINT,TOTSASII  WRITE ASVT RSVSTRT IN USE LINE\n         PUT   SYSPRINT,TOTSASIA  WRITE ASVT RSVSTRT AVAILABLE LINE\n         PUT   SYSPRINT,BLANKLIN  WRITE BLANK LINE\n         PUT   SYSPRINT,TOTNR     WRITE ASVT RSVNONR LINE\n         PUT   SYSPRINT,TOTNRI    WRITE ASVT RSVNONR IN USE LINE\n         PUT   SYSPRINT,TOTNRA    WRITE ASVT RSVNONR AVAILABLE LINE\n         PUT   SYSPRINT,BLANKLIN  WRITE BLANK LINE\n         PUT   SYSPRINT,TOTNONRU  WRITE ASVT NON-REUSABLE ASID LINE\n         B     RETURN             GO END\nBADPARM  WTO   'ASIDLIST - NUMBER OF LINES PER PAGE IN PARM MUST BE 2 DX\n               IGITS - JOB CANCELLED',ROUTCDE=11\n         ABEND 01,REASON=0        U0001 ABEND  - NO DUMP\nRETURN   CLOSE (SYSPRINT)         CLOSE FILES\n         LA   R15,0               SET RETURN CODE TO ZERO\n         PR                       PROGRAM RETURN (LINKAGE STACK)\n         EJECT\n* ====================================================================\nSYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,RECFM=FBA,            X\n               LRECL=133,BLKSIZE=3990\nPARMLINE DS    ZL2                PARM VALUE\nMAXLINES DS    PL2                MAXIMUM LINES PER PAGE\nCVDWORK  DS    D                  WORK AREA FOR CVD\nWORK3    DS    CL3                WORK AREA FOR HEX TO CHAR\nWORK4    DS    F                  WORK AREA FOR HEX TO CHAR\nWORK5    DS    CL5                WORK AREA FOR HEX TO CHAR\nWORK9    DS    CL9                WORK AREA FOR HEX TO CHAR\nHEXTAB   DC    C'0123456789ABCDEF' TRANSLATION TABLE FOR HEX TO CHAR\nTOTASIDS DS    PL3                TOTAL # OF ASIDS\nTOTACTIV DS    PL3                TOTAL # OF ACTIVE ASIDS\nTOTAVAL  DS    PL3                TOTAL # OF AVAILABLE ASIDS\nTOTNONR  DS    PL3                TOTAL # OF NON-REUSABLE ASIDS\nLINCOUNT DS    PL2                CURRENT LINE COUNT ON PAGE\nPAGCOUNT DS    PL2                CURRENT PAGE NUMBER COUNT\nEDPAGNUM DS    CL4                EDITED PAGE NUMBER\nBLANKLIN DC    CL133' '\nTITLELN1 DC    CL50'1      A D D R E S S    S P A C E    I D    L I S '\n         DC    CL20'T            PAGE - '\nPAGENUM  DS    CL2                PAGE NUMBER\n         DC    CL61' '            FILLER\nTITLELN2 DC    CL50'+      ___________________________________________'\n         DC    CL50'_                                                 '\n         DC    CL33' '            FILLER\nTOTALLN1 DC    CL50'                 PROGRAM TOTALS                   '\n         DC    CL50'                                                  '\n         DC    CL33' '            FILLER\nACTMSG   DC    CL15' ASCB FOUND AT '\nASCBADDR DS    CL8                EDITED ASCB ADDRESS\n         DC    CL2': '\nJOBNAME  DC    CL8' '\n         DC    CL10' - ASID X'''\nASIDHEX  DS    CL4                ASID IN HEX CHAR\n         DC    CL1''''\nEDASID   DS    CL6                EDITED ASID IN DECIMAL\n         DC    CL12' IN DECIMAL)'\n         DC    CL67'        '     FILLER\nEDMASK   DC    X'40202120'\nEDMASK2  DC    X'402020202120'\nTOTASMG  DC    CL49' TOTAL ADDRESS SPACES IN THE SYSTEM:             '\nEDTOTAS  DS    CL6\n         DC    CL78' '            FILLER\nTOTACTMG DC    CL49' TOTAL ACTIVE ADDRESS SPACES IN THE SYSTEM:      '\nEDTOTACT DS    CL6\n         DC    CL78' '            FILLER\nTOTAVAMG DC    CL49' TOTAL AVAILABLE ADDRESS SPACES IN THE SYSTEM:   '\nEDTOTAV  DS    CL6\n         DC    CL78' '            FILLER\nTOTNORMG DC    CL49' TOTAL NON-REUSABLE ADDRESS SPACES IN THE SYSTEM:'\nEDTOTNOR DS    CL6\n         DC    CL78' '            FILLER\nTOTALLN2 DC    CL49'              ASID USAGE FROM ASVT               '\n         DC    CL49'                                                 '\n         DC    CL35' '            FILLER\nTOTMAXU  DC    CL23' MAXUSER FROM IEASYSXX:'\nEDTOTMX  DS    CL6\n         DC    CL104' '            FILLER\nTOTAVI   DC    CL23'          IN USE ASIDS:'\nEDTOTAVI DS    CL6\n         DC    CL104' '            FILLER\nTOTAVA   DC    CL23'       AVAILABLE ASIDS:'\nEDTOTAVA DS    CL6\n         DC    CL104' '            FILLER\nTOTSASI  DC    CL23' RSVSTRT FROM IEASYSXX:'\nEDTOTST  DS    CL6\n         DC    CL104' '            FILLER\nTOTSASII DC    CL23'        RSVSTRT IN USE:'\nEDTOTSTI DS    CL6\n         DC    CL104' '            FILLER\nTOTSASIA DC    CL23'     RSVSTRT AVAILABLE:'\nEDTOTSTA DS    CL6\n         DC    CL104' '            FILLER\nTOTNR    DC    CL23' RSVNONR FROM IEASYSXX:'\nEDTOTNR  DS    CL6\n         DC    CL104' '            FILLER\nTOTNRI   DC    CL23'        RSVNONR IN USE:'\nEDTOTNRI DS    CL6\n         DC    CL104' '            FILLER\nTOTNRA   DC    CL23'     RSVNONR AVAILABLE:'\nEDTOTNRA DS    CL6\n         DC    CL104' '            FILLER\nTOTNONRU DC    CL23' NON-REUSABLE ASIDS   :'\nTOT2NOR  DS    CL6\n         DC    CL104' '            FILLER\n         LTORG\n         CVT DSECT=YES\n         IHAASVT\n         IHAASCB\n         END\n//G.SYSPRINT DD  SYSOUT=*\n//G.SYSUDUMP DD  SYSOUT=*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ASIDLRX": {"ttr": 1798, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x040\\x0f\\x01\\x040\\x0f\\x14\\x16\\x00\\xb1\\x00\\xb1\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf6\\xf7@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-10-26T00:00:00", "modifydate": "2004-10-26T14:16:00", "lines": 177, "newlines": 177, "modlines": 0, "user": "CBT467"}, "text": "/* REXX */\n/*                                       */\n/* AUTHOR: Mark Zelden                   */\n/*                                       */\n/* Trace ?r */\n/*********************************************************************/\n/* List ASIDs in the system                                          */\n/*********************************************************************/\n/* This program will write out the names of all ASIDs in the         */\n/* system, their ASCB addrses, their ASID number in hex and in       */\n/* decimal as shown in the examples below:                           */\n/*                                                                   */\n/* ASCB FOUND AT 00FD4100: *MASTER* - ASID X'0001' (   1 IN DECIMAL) */\n/* ASCB FOUND AT 00F4BE80: PCAUTH   - ASID X'0002' (   2 IN DECIMAL) */\n/* ASCB FOUND AT 00F4D700: RASP     - ASID X'0003' (   3 IN DECIMAL) */\n/* ASCB FOUND AT *NONREUS: *NONREUS - ASID X'000E' (  14 IN DECIMAL) */\n/* ASCB FOUND AT *AVALABL: *AVALABL - ASID X'0037' (  55 IN DECIMAL) */\n/* ASCB FOUND AT *AVALABL: *AVALABL - ASID X'NNNN' (NNNN IN DECIMAL) */\n/*                                                                   */\n/* This program also displays totals as shown below:                 */\n/*                                                                   */\n/*      Total address spaces in the system:               NNNN       */\n/*      Total active address spaces in the system:        NNNN       */\n/*      Total available address spaces in the system:     NNNN       */\n/*      Total non-reusable address spaces in the system:  NNNN       */\n/*                                                                   */\n/*                                                                   */\n/*              ASID USAGE FROM THE ASVT                             */\n/*                                                                   */\n/*      MAXUSER from IEASYSxx:  NNNN                                 */\n/*               In use ASIDs:  NNNN                                 */\n/*            Available ASIDs:  NNNN                                 */\n/*                                                                   */\n/*      RSVSTRT from IEASYSxx:  NNNN                                 */\n/*             RSVSTRT in use:  NNNN                                 */\n/*          RSVSTRT available:  NNNN                                 */\n/*                                                                   */\n/*      RSVNONR from IEASYSxx:  NNNN                                 */\n/*             RSVNONR in use:  NNNN                                 */\n/*          RSVNONR available:  NNNN                                 */\n/*                                                                   */\n/*********************************************************************/\n/* TSO execution syntax: TSO %ASIDLIST                               */\n/*                       TSO %ASIDLIST NODETAIL                      */\n/*                       TSO %ASIDLIST N                             */\n/*                                                                   */\n/* The \"NODETAIL\" option can be used to list only the totals from    */\n/* the ASVT instead of all ASIDs.  Note that NODETAIL can be         */\n/* abbreviated using one or more of its characters.                  */\n/*********************************************************************/\n/* Sample batch execution JCL:                                       */\n/*                                                                   */\n/*  //MYJOB    JOB (ACCT),CLASS=A,MSGCLASS=H                         */\n/*  //ASIDLIST EXEC PGM=IRXJCL,PARM='ASIDLIST'                       */\n/*  //*ASIDLIST EXEC PGM=IRXJCL,PARM='ASIDLIST NODETAIL'           */*/\n/*  //SYSTSIN  DD DUMMY                                              */\n/*  //SYSTSPRT DD SYSOUT=*                                           */\n/*  //SYSEXEC  DD DSN=your.rexx.sysexec.lib,DISP=SHR                 */\n/*********************************************************************/\nArg OPT\nNumeric digits 10                           /* dflt of 9 not enough  */\n/*********************************************************************/\n/* House keeping                                                     */\n/*********************************************************************/\nTOTASIDS  = 0     /* counter for total ASIDs (should match ASVTMAXU) */\nTOTACTIV  = 0     /* counter for total active ASIDs                  */\nTOTAVAL   = 0     /* counter for total available ASIDs               */\nTOTNONR   = 0     /* counter for total non-reusable ASIDs            */\nCVT      = C2d(Storage(10,4))               /* point to CVT          */\nCVTASVT  = C2d(Storage(D2x(CVT+556),4))     /* point to ASVT         */\n/*********************************************************************/\n/* \"NODETAIL\" option - ASVT totals only, then exit                   */\n/*********************************************************************/\nIf Abbrev('NODETAIL',Translate(OPT),1) <> 0 then do\n  Call ASVT_TOTALS         /* write ASVT total messages              */\n  Exit 0                   /* exit                                   */\nEnd\n/*********************************************************************/\nSay '      A D D R E S S    S P A C E    I D    L I S T' /* title    */\nSay '  '                                                 /* blnk line*/\nASVTMAXU = C2d(Storage(D2x(CVTASVT+516),4)) /* max number of entries */\nMSTRASVT = CVTASVT+528 /* save address of master for non-reuse check */\n/*********************************************************************/\n/* This routine checks each ASVT entry.                              */\n/* If the high order bit is on, the entry is the address of the      */\n/* next available asid (or the last entry if zeros).                 */\n/* If the high order bit is not on, the entry is the address         */\n/* of the ASCB for that entry. If the high order bit is on and       */\n/* the entry contains the address of master's ASCB, then the ASID    */\n/* is non-reusable.                                                  */\n/*********************************************************************/\nDo I = 0 to ASVTMAXU-1 /* start at 0 so I*4 bumps to next entry      */\n  ASVTENTY = Storage(D2x(CVTASVT+528+(I*4)),4)      /* cur ASVT entry*/\n  If Bitand(ASVTENTY,'80000000'x) == '80000000'x then do  /* bit on  */\n    ASVTENTY = Bitand(ASVTENTY,'7FFFFFFF'x)  /* zero high order bit  */\n    ASVTENTY = C2d(ASVTENTY)     /* change to decimal for code below */\n    If ASVTENTY == MSTRASVT then do /* same addr as mstr = non-reuse */\n      TASKNAME = '*NONREUS'\n      ASVTENTY = '*NONREUS'\n      TOTNONR  = TOTNONR+1  /* counter for total non-reusable ASIDs  */\n      Call SAY_FOUND        /* write \"ASCB FOUND\" message            */\n    End\n    Else do        /* different addr than mstr means avaialable asid */\n      TASKNAME = '*AVALABL'\n      ASVTENTY = '*AVALABL'\n      TOTAVAL  = TOTAVAL+1  /* counter for total available ASIDs     */\n      Call SAY_FOUND        /* write \"ASCB FOUND\" message            */\n    End\n    Iterate /* go to next ASVT entry */\n  End /* If Bitand */\n  Else do  /* valid ASCB address */\n    ASVTENTY = C2d(ASVTENTY)     /* change to decimal for code below */\n    ASCBJBN  = C2d(Storage(D2x(ASVTENTY+172),4))  /* ASCBJBNI        */\n    If ASCBJBN = 0 then ,   /* not a job - must be START/LOGON/MOUNT */\n      ASCBJBN = C2d(Storage(D2x(ASVTENTY+176),4)) /* ASCBJBNS        */\n    TASKNAME  = Storage(D2x(ASCBJBN),8)           /* point to name   */\n    ASVTENTY = Right(D2x(ASVTENTY),8,'0')  /* ensure leading zeros   */\n    TOTACTIV = TOTACTIV+1  /* counter for total active ASIDs         */\n    Call SAY_FOUND         /* write \"ASCB FOUND\" message             */\n  End /* else do */\nEnd /* Do I */\nCall PGM_TOTALS            /* write program total messages           */\nCall ASVT_TOTALS           /* write ASVT total messages              */\nExit 0\n/*********************************************************************/\n/*  End of main code                                                 */\n/*********************************************************************/\n/*  Start of sub-routines                                            */\n/*********************************************************************/\nSAY_FOUND:   /* Write \"ASCB FOUND\" message subroutine                */\nSay 'ASCB FOUND AT' ASVTENTY || ':' ,\n  TASKNAME '- ASID X''' || Right(D2x(I+1),4,'0') || ''' (' || ,\n  Right((I+1),4,' ') 'IN DECIMAL)'\nTOTASIDS = TOTASIDS+1      /* counter for total ASIDs                */\nReturn\n\nPGM_TOTALS:  /* Write totals subroutine                              */\n/*                     */\n/* make more readable  */\n/*                     */\nTOTASIDS = Right(TOTASIDS,5,' ')\nTOTACTIV = Right(TOTACTIV,5,' ')\nTOTAVAL  = Right(TOTAVAL,5,' ')\nTOTNONR  = Right(TOTNONR,5,' ')\nSay '  '\nSay '  '\nSay '                PROGRAM TOTALS                  '\nSay '  '\nSay 'Total address spaces in the system:             ' TOTASIDS\nSay 'Total active address spaces in the system:      ' TOTACTIV\nSay 'Total available address spaces in the system:   ' TOTAVAL\nSay 'Total non-reusable address spaces in the system:' TOTNONR\nSay '  '\nSay '  '\nReturn\n\nASVT_TOTALS:  /* Write ASVT totals subroutine                        */\nASVTMAXI = C2d(Storage(D2x(CVTASVT+500),4)) /* MAXUSERS from ASVT    */\nASVTAAVT = C2d(Storage(D2x(CVTASVT+480),4)) /* free slots in ASVT    */\nASVTSTRT = C2d(Storage(D2x(CVTASVT+492),4)) /* RSVTSTRT from ASVT    */\nASVTAST  = C2d(Storage(D2x(CVTASVT+484),4)) /* free START/SASI       */\nASVTNONR = C2d(Storage(D2x(CVTASVT+496),4)) /* RSVNONR  from ASVT    */\nASVTANR  = C2d(Storage(D2x(CVTASVT+488),4)) /* free non-reusable     */\nSay '             ASID USAGE FROM THE ASVT           '\nSay '  '\nSay 'MAXUSER from IEASYSxx:' Right(ASVTMAXI,5,' ')\nSay '         In use ASIDs:' Right(ASVTMAXI-ASVTAAVT,5,' ')\nSay '      Available ASIDs:' Right(ASVTAAVT,5,' ')\nSay '                      '\nSay 'RSVSTRT from IEASYSxx:' Right(ASVTSTRT,5,' ')\nSay '       RSVSTRT in use:' Right(ASVTSTRT-ASVTAST,5,' ')\nSay '    RSVSTRT available:' Right(ASVTAST,5,' ')\nSay '                      '\nSay 'RSVNONR from IEASYSxx:' Right(ASVTNONR,5,' ')\nSay '       RSVNONR in use:' Right(ASVTNONR-ASVTANR,5,' ')\nSay '    RSVNONR available:' Right(ASVTANR,5,' ')\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BLKCLIST": {"ttr": 1802, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x10\\x00\\x992/\\x00\\x992/\\x16'\\x00:\\x00:\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf2\\xf2@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "1999-11-18T16:27:10", "lines": 58, "newlines": 58, "modlines": 0, "user": "CBT422"}, "text": "CONTROL NOMSG NOLIST NOCONLIST\n/*                           */\n/* AUTHOR: MARK ZELDEN       */\n/*                           */\nLOOP: +\nISPEXEC DISPLAY PANEL(BLKPANEL)\n/*  IF \"END\" WAS ENTERED, EXIT */\nIF &LASTCC = 8 THEN DO\n  FREE FI(BLKPRINT)\n  EXIT CODE(0)\nEND\n\n/* ALLOCATE FILE FOR BROWSING COMMAND OUTPUT */\nALLOC FILE(BLKPRINT) UNIT(SYSALLDA) SP(1,1) TRACK REUSE +\n      RECFM(F B) LRECL(132) BLKSIZE(3960)\nOPENFILE BLKPRINT OUTPUT            /* OPEN FILE TO BE BROWSED      */\nSET &SYSOUTTRAP=500                 /* TRAP COMMAND OUTPUT          */\n\n/* ISSUE APPROPRITE BLKDISK COMMAND */\nIF &RECORDS = &STR() AND &KEY = &STR() AND +\n    &BLK = &STR() THEN +\nBLK&DEVT &LRECL\nELSE +\nIF &KEY = &STR() AND &BLK=&STR() THEN  +\nBLK&DEVT &LRECL RECORDS(&RECORDS)\nELSE +\nIF &RECORDS = &STR() AND &BLK=&STR() THEN  +\nBLK&DEVT &LRECL KEY(&KEY)\nELSE +\nIF &RECORDS = &STR() AND &KEY=&STR() THEN  +\nBLK&DEVT &LRECL BLKSIZE(&BLK)\nELSE +\nIF &RECORDS = &STR() THEN +\nBLK&DEVT &LRECL BLKSIZE(&BLK) KEY(&KEY)\nELSE +\nIF &BLK = &STR() THEN +\nBLK&DEVT &LRECL RECORDS(&RECORDS) KEY(&KEY)\nELSE +\nIF &KEY = &STR() THEN +\nBLK&DEVT &LRECL RECORDS(&RECORDS) BLKSIZE(&BLK)\nELSE +\nBLK&DEVT &LRECL RECORDS(&RECORDS) BLKSIZE(&BLK) KEY(&KEY)\n\nSET &SYSOUTTRAP=0                   /* RESET SO WE DON'T TRAP MORE  */\nSET I = 1                           /* INITIALITE COUNTER           */\nDO WHILE &I <= &SYSOUTLINE\n  SET LINE = &STR(&&SYSOUTLINE&I)   /* GET A &SYSOUTLINENN VARIABLE */\n  SET &BLKPRINT = &STR(&LINE)       /* SET PUTFILE VARIABLE         */\n  SET I = &I + 1                    /* INCREASE THE LINE COUNTER    */\n  PUTFILE BLKPRINT                  /* WRITE TO OUTPUT FILE         */\nEND\nCLOSFILE BLKPRINT\n\nISPEXEC LMINIT DATAID(BROWSE) DDNAME(BLKPRINT)\nISPEXEC BROWSE DATAID(&BROWSE)\nISPEXEC LMFREE DATAID(&BROWSE)\n\nGOTO LOOP\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BLKPANEL": {"ttr": 1804, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x005\\x00\\x992/\\x00\\x992/\\x16'\\x00&\\x00&\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf2\\xf2@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "1999-11-18T16:27:35", "lines": 38, "newlines": 38, "modlines": 0, "user": "CBT422"}, "text": ")ATTR\n      + TYPE(TEXT)  INTENS(LOW)\n      % TYPE(TEXT)  INTENS(HIGH)\n      _ TYPE(INPUT) INTENS(HIGH)\n)BODY EXPAND (//)\n%-/-/ Blocksize Calculator -/-/\n+\n+   Enter the LRECL of the dataset being created and%optionally+the number of\n+   records the dataset will contain, the block size,  and the key length.\n+\n+   The optimum blocksize and the space needed for the dataset will be displayed\n+\n+   DEVICE TYPE ==>_DEVT+     (3380 or 3390)\n+\n+   LRECL ========>_LRECL+\n+\n+\n+\n+   RECORDS ======>_RECORDS+\n+\n+   BLOCK SIZE ===>_BLK  +\n+\n+   KEY LENGTH ===>_KEY+\n+\n+Press%PF3+to exit+\n+\n)INIT\n  &ZPRIM = NO\n .CURSOR = LRECL\n  &DEVT = 3390\n)PROC\n  VER (&DEVT,LIST,3380,3390)\n  VER (&LRECL,NONBLANK)\n  VER (&LRECL,NUM)\n  VER (&RECORDS,NUM)\n  VER (&BLK,NUM)\n  VER (&KEY,NUM)\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CALC": {"ttr": 1806, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x992/\\x00\\x992/\\x15 \\x00\\xa4\\x00\\xa4\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf2\\xf2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "1999-11-18T15:20:00", "lines": 164, "newlines": 164, "modlines": 0, "user": "CBT422"}, "text": "/* rexx */\n/*************************************************************/\n/*  Because CALC is an ISPF TSO command supplied by IBM,     */\n/*  this REXX exec must be renamed or invoked using a        */\n/*  a percent sign as follows:                               */\n/*     \"TSO  %CALC\"                                          */\n/*************************************************************/\nnumhexdigits = 8                                /* set default for # of\n                                                   hex digits to use  */\nnumdigits = 10                                  /* set default for # of\n                                                   significant digits to\n                                                   be used in numeric\n                                                   operations         */\nnumeric digits numdigits                        /* set numeric digits */\nsay  'REXX Calculator active!'                  /* display msg        */\nhexmode = 'OFF'                                 /* hex off initially  */\nprompt = ' Enter input, \"END\", or \"?\" for help.'  /* init prompt msg  */\ndo forever                                      /* do till no input   */\n  if hexmode = 'OFF' then                       /* display prompt msg */\n    say 'CALC (Decimal mode) - 'prompt\n  else\n    say 'CALC (Hex mode) - 'prompt\nSignal On Syntax                                /* error condition    */\n  parse upper external input                    /* get calc input     */\n  select                                        /* select on input    */\n    when input = '?'   then call helpme         /* call for help      */\n    when input = 'HEX' then hexmode = 'ON'      /* turn on hex mode   */\n    when input = 'DEC' then hexmode = 'OFF'     /* turn on dec mode   */\n    when input = 'END' then leave               /* exit               */\n    when input = ''    then iterate             /* re-prompt for input*/\n    otherwise do\n      drop decans                               /* reset output value */\n      drop hexans                               /* reset output value */\n      if hexmode = 'OFF' then\n        call calcdec                            /* call decimal rtn   */\n      else                                      /* do hex processing  */\n        call calchex\n    end                                         /* end otherwise      */\n  end                                           /* end of select      */\nend                                             /* get more input     */\nsay 'REXX Calculator ending.'                   /* display exit msg   */\nexit                                            /* exit from program  */\ncalcdec: procedure expose input numdigits numhexdigits\n  if verify(input,'1234567890E+-*/% ().')=0 then /* verify input      */\n    do\n      interpret decans ' = 'input '+ 0'         /* compute output     */\n      decans = decans +0                        /* add 0 in case only a\n                                                   single # is given.\n                                                   This will force it to\n                                                   scientific mode if\n                                                   the result is large*/\n      hexans = dec2hex(decans)                  /* get hex equivalent */\n      if hexans = '' then                       /* check for hex rslt */\n        hexdisp = '(Hex equivalent not available)'     /* no hex msg  */\n      else hexdisp = '('||hexans||' hex)'       /* hex result msg     */\n      input = ''''||input||''''                 /* put quotes around the\n                                                   input so it can be\n                                                   passed as one parm */\n       say  'CALC ' input '=' decans hexdisp\n    end\n  else say 'CALC Invalid input. Enter \"?\" for help.'\nreturn\ncalchex: procedure expose input numdigits numhexdigits\n  numeric digits numdigits*2                    /* need to increment the\n                                                   numeric digits so\n                                                   x2d will work      */\n  if verify(input,'1234567890ABCDEF+-*/% ()')=0 then /* verify input  */\n    do\n      decstr = ''                               /* init decimal equiv */\n      toobig = 'NO'                             /* init toobig flag   */\n      nxtinput = input                          /* init next string   */\n      do until length(nxtinput)=0               /* do till no more    */\n        nonhex = verify(nxtinput,'1234567890ABCDEF')/* find nonhex chr*/\n        if nonhex=0 then nonhex=length(nxtinput)+1 /* set to str end  */\n        if nonhex=1 then                        /* if next symbol is not\n                                                   a number, append it*/\n          decstr = decstr || substr(nxtinput,1,1)\n        else                                    /* otherwise, append the\n                                                   decimal equivalent #,\n                                                   plus the next oper */\n          if nonhex > numhexdigits +1 then      /* check input # size */\n            toobig = 'YES'                      /* set too big flag   */\n          else                                  /* size is ok         */\n            decstr=decstr||x2d(substr(nxtinput,1,nonhex-1))||,\n                   substr(nxtinput,nonhex,1)\n        nxtinput=substr(nxtinput,nonhex+1)      /* reset next string  */\n      end                                       /* end do till no more*/\n      if toobig = 'YES' then                    /* if input too big   */\n         say 'CALC Input number too large for calculations.'\n      else                                      /* input OK, get hex  */\n        do\n          numeric digits numdigits              /* reset numeric digit*/\n          interpret 'decans ='decstr            /* compute dec result */\n          decans = decans +0                    /* add 0 in case only a\n                                                   single # is given.\n                                                   This will force it to\n                                                   scientific mode if\n                                                   the result is large*/\n          hexans = dec2hex(decans)              /* get hex equivalent */\n          if hexans = '' then                   /* display results    */\n            hexans = 'Hex result not available.'\n          input = ''''||input||''''             /* put quotes around the\n                                                   input so it can be\n                                                   passed as one parm */\n           say 'CALC 'input '=' hexans,\n              '('decans' decimal)'\n        end\n    end\n    else say 'CALC Invalid input. Enter \"?\" for help.'\nreturn\ndec2hex: procedure expose numdigits numhexdigits\n  parse arg decans\n  if index(decans,'E') > 0 then return ''       /* exponent is too big*/\n  if index(decans,'.') > 0 then do              /* fractional value?  */\n                                                /* since n.0 = n, strip\n                                                   off the '.0' so that\n                                                   the value can be\n                                                   converted to hex   */\n    decans = strip(decans,'T','0')              /* strip trailing 0's */\n    decans = strip(decans,'T','.')              /* strip trailing '.' */\n  end\n  if index(decans,'.') > 0,                     /* if fraction        */\n   | decans > x2d('FFFFFFFF'),                  /* or too big         */\n   | (decans < 0 & decans < x2d('F0000000',8)), /* or too small       */\n      then return ''                            /* don't convert      */\n  if decans < 0 then                            /* if negative #      */\n    hexans = d2x(decans,numhexdigits)           /* convert neg value  */\n  else\n    hexans = d2x(decans)                        /* convert to hex     */\n  return hexans                                 /* return hex value   */\nSyntax:                                         /* error              */\nSelect\nWhen rc=42 Then Do                              /* return code 42     */\n Say ERRORTEXT(rc)                              /* display message    */\n Say 'Either the number is too big (infinity)',\n   'or division by ''0'' was attempted'         /* display 2nd message*/\nEnd\nOtherwise Do\n Say ERRORTEXT(rc)                              /* other return code  */\nEnd\nEnd\nReturn\nHelpme:\nsay '                                                                 '\nsay ' o When you enter CALC you are in decimal mode. To switch to     '\nsay '   hexadecimal mode enter \"HEX\". To switch back to decimal mode  '\nsay '   enter \"DEC\".                                                  '\nsay '                                                                 '\nsay ' o Enter a valid REXX arithmetic expression. Valid functions are:'\nsay '   + (add), - (subtract), * (multiply, / (divide returning       '\nsay '   decimal quotient), % (divide returning intiger quotient),     '\nsay '   // (divide returning remainder), and ** (exponentiation).     '\nsay '   EXAMPLES: 3+4 ; 543-32; 100*22 ; 250/5 ; 3+(100/20)*3.4       '\nsay '                                                                 '\nsay ' o Results are given in both decimal and hexadecimal. Decimal    '\nsay '   results that are not whole numbers are not converted to       '\nsay '   hexadecimal.                                                  '\nsay '                                                                 '\nsay ' o Decimal results greater than ten billion are displayed in     '\nsay '   scientific notation. Negative hexadecimal results are         '\nsay '   displayed to 8 places.                                        '\nsay '                                                                 '\nsay '                                                                 '\nReturn\n", "mimetype": "text/x-pascal", "datatype": "ebcdic", "extension": ".p"}, "CAT": {"ttr": 2052, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x16\\x01\\x00%\\x8f\\x01\\x00%\\x8f\\x08\\x15\\x00\\x02\\x00\\x02\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf3\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-09-14T00:00:00", "modifydate": "2000-09-14T08:15:16", "lines": 2, "newlines": 2, "modlines": 0, "user": "CBT430"}, "text": "/* REXX */\nADDRESS ISPEXEC \"SELECT PANEL(CATSRCHP)\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CATSRCH": {"ttr": 2054, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00%\\x8f\\x01\\x11\\x06?\\x14E\\x01i\\x01F\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-09-14T00:00:00", "modifydate": "2011-03-04T14:45:00", "lines": 361, "newlines": 326, "modlines": 0, "user": "CBT482"}, "text": "/* REXX */\n/*                                       */\n/* AUTHOR: Mark Zelden                   */\n/*                                       */\n/*********************************************************************/\n/*  MODIFIED FROM SYS1.SAMPLIB(IGGCSIRX)                             */\n/*********************************************************************/\n/*                                                                   */\n/* EXECUTION SYNTAX:                                                 */\n/*   CATSRCH dsn.filter <catalog name>                               */\n/*   (catalog name is optional)                                      */\n/*                                                                   */\n/* FILTER CHARACTERS:                                                */\n/*  %  - one character,   *  - one qualifier,                        */\n/*  **  - one or more qualifiers                                     */\n/*  NOTE: A double asterisk cannot precede or follow any characters; */\n/*   it must be preceded or followed by either a period or a blank   */\n/*    EXAMPLES:  SYS1.A*.**  (correct)                               */\n/*               SYS1.A**    (not correct)                           */\n/*                                                                   */\n/* ** NOTE: Do not use quotes for the data set name filter or        */\n/*          catalog name.                                            */\n/*                                                                   */\n/*  Caution should be exercised in using high-level qualifiers       */\n/*  that contain generic filters because multiple catalogs can be    */\n/*  searched.  A high-level of \"**\" will cause a search of every     */\n/*  user catalog in the system.                                      */\n/*                                                                   */\n/*********************************************************************/\n/*                                                                   */\n/* EXAMPLES:                                                         */\n/*  TSO %CATSRCH USERID.**                                           */\n/*  TSO %CATSRCH SYS1.LINK*                                          */\n/*  TSO %CATSRCH SYS1.*LIB                                           */\n/*  TSO %CATSRCH SYS1.*.PROCLIB                                      */\n/*  TSO %CATSRCH SYS1.**.PROCLIB                                     */\n/*  TSO %CATSRCH SYS1.A%%.*LIB                                       */\n/*  TSO %CATSRCH USER*.**  TSO.USERCAT                               */\n/*  TSO %CATSRCH SYS*.LINKLIB  SYSICF.MASTER                         */\n/*  TSO %CATSRCH SYS*.LINKLIB  (see caution above)                   */\n/*  TSO %CATSRCH SYS1.A*.**    (SYS1.A** won't give everything - see */\n/*                               note on ** above)                   */\n/*                                                                   */\n/*********************************************************************/\nLASTUPD = '10/09/2007'                       /* date of last update  */\n/*********************************************************************/\n /********************************************************************/\n /*                                                                  */\n /*       NAME: IGGCSIRX                                             */\n /*DESCRIPTION: THIS REXX EXEC IS USED TO CALL THE CATALOG           */\n /*             SEARCH INTERFACE.                                    */\n /*      INPUT: FILTER KEY                                           */\n /*     OUTPUT: DATA SETS NAMES AND VOLUMES                          */\n /*                                                                  */\n /********************************************************************/\n /* SAY 'ENTER FILTER KEY' */       /*   ASK FOR FILTER KEY          */\n /* PULL KEY               */       /*   GET FILTER KEY              */\n /********************************************************************/\n /*                                                                  */\n /*  INITIALIZE THE PARM LIST                                        */\n /*                                                                  */\n /********************************************************************/\nPARSE UPPER ARG KEY CAT .           /*                            MSZ*/\nIF KEY = '' THEN DO                 /*                            MSZ*/\n  SAY 'ENTER DATA SET NAME FILTER'  /*                            MSZ*/\n  PULL KEY                          /*                            MSZ*/\nEND                                 /*                            MSZ*/\nCOUNT = 0                           /* TOTAL ENTIRES FOUND        MSZ*/\nMODRSNRC = SUBSTR(' ',1,4)          /*   CLEAR MODULE/RETURN/REASON  */\nCSIFILTK = SUBSTR(KEY,1,44)         /*   MOVE FILTER KEY INTO LIST   */\nIF CAT <> '' THEN                   /*                            MSZ*/\n  CSICATNM = SUBSTR(CAT,1,44)       /*   USE SPECIFIED CATALOG    MSZ*/\nELSE                                /*                            MSZ*/\n  CSICATNM = SUBSTR(' ',1,44)       /*   CLEAR CATALOG NAME       MSZ*/\nCSIRESNM = SUBSTR(' ',1,44)         /*   CLEAR RESUME NAME           */\nCSIDTYPS = SUBSTR(' ',1,16)         /*   CLEAR ENTRY TYPES           */\nCSICLDI  = SUBSTR('Y',1,1)          /*   INDICATE DATA AND INDEX     */\nCSIRESUM = SUBSTR(' ',1,1)          /*   CLEAR RESUME FLAG           */\nIF CAT <> '' THEN                   /*                            MSZ*/\n  CSIS1CAT = SUBSTR('Y',1,1)        /* SEARCH ONLY 1 CAT          MSZ*/\nELSE                                /*                            MSZ*/\n  CSIS1CAT = SUBSTR(' ',1,1)        /* SEARCH > 1 CATALOGS        MSZ*/\nCSIRESRV = SUBSTR(' ',1,1)          /*   CLEAR RESERVE CHARACTER     */\nCSINUMEN = '0001'X                  /*   INIT NUMBER OF FIELDS       */\nCSIFLD1    = SUBSTR('VOLSER',1,8)   /*   INIT FIELD 1 FOR VOLSERS    */\n /********************************************************************/\n /*                                                                  */\n /*  BUILD THE SELECTION CRITERIA FIELDS PART OF PARAMETER LIST      */\n /*                                                                  */\n /********************************************************************/\nCSIOPTS  = CSICLDI || CSIRESUM || CSIS1CAT || CSIRESRV\nCSIFIELD = CSIFILTK || CSICATNM || CSIRESNM || CSIDTYPS || CSIOPTS\nCSIFIELD = CSIFIELD || CSINUMEN || CSIFLD1\n\n /********************************************************************/\n /*                                                                  */\n /*  INITIALIZE AND BUILD WORK ARE OUTPUT PART OF PARAMETER LIST     */\n /*                                                                  */\n /********************************************************************/\n/* WORKLEN = 1024  */\n/* DWORK = '00000400'X || COPIES('00'X,WORKLEN-4) */\nWORKLEN = 131072  /* 128K */      /* APAR OW39593 */\nDWORK = '00020000'X || COPIES('00'X,WORKLEN-4)   /* APAR OW39593 */\n\n /********************************************************************/\n /*                                                                  */\n /*  INITIALIZE WORK VARIABLES                                       */\n /*                                                                  */\n /********************************************************************/\nRESUME = 'Y'\nPREVNAME = ''                     /* NO PREVIOUS NAME            @01A*/\nCATNAMET = SUBSTR(' ',1,44)\nDNAMET = SUBSTR(' ',1,44)\n\n /********************************************************************/\n /*                                                                  */\n /*  SET UP LOOP FOR RESUME (IF A RESUME IS NCESSARY)                */\n /*                                                                  */\n /********************************************************************/\nDO WHILE RESUME = 'Y'\n\n /********************************************************************/\n /*                                                                  */\n /*  ISSUE LINK TO CATALOG GENERIC FILTER INTERFACE                  */\n /*                                                                  */\n /********************************************************************/\n ADDRESS LINKPGM 'IGGCSI00  MODRSNRC  CSIFIELD  DWORK'\n\n RESUME = SUBSTR(CSIFIELD,150,1)    /* GET RESUME FLAG FOR NEXT LOOP */\n USEDLEN = C2D(SUBSTR(DWORK,9,4))   /* GET AMOUNT OF WORK AREA USED  */\n POS1=15                            /* STARTING POSITION             */\n\n /********************************************************************/\n /*                                                                  */\n /*  PROCESS DATA RETURNED IN WORK AREA                              */\n /*                                                                  */\n /********************************************************************/\n DO WHILE POS1 < USEDLEN            /* DO UNTIL ALL DATA IS PROCESSED*/\n   IF SUBSTR(DWORK,POS1+1,1) = '0'  /* IF CATALOG, PRINT CATALOG HEAD*/\n    THEN DO\n         CATNAME=SUBSTR(DWORK,POS1+2,44)\n         POS1 = POS1 + 50\n         END\n\n   DNAME = SUBSTR(DWORK,POS1+2,44)  /* GET ENTRY NAME                */\n\n /********************************************************************/\n /*                                                                  */\n /*  ASSIGN ENTRY TYPE NAME                                          */\n /*                                                                  */\n /********************************************************************/\n   IF SUBSTR(DWORK,POS1+1,1) = 'C' THEN DTYPE = 'CLUSTER '\n    ELSE\n      IF SUBSTR(DWORK,POS1+1,1) = 'D' THEN DTYPE = 'DATA    '\n     ELSE\n      IF SUBSTR(DWORK,POS1+1,1) = 'I' THEN DTYPE = 'INDEX   '\n     ELSE\n      IF SUBSTR(DWORK,POS1+1,1) = 'A' THEN DTYPE = 'NONVSAM '\n     ELSE\n      IF SUBSTR(DWORK,POS1+1,1) = 'H' THEN DTYPE = 'GDS     '\n     ELSE\n      IF SUBSTR(DWORK,POS1+1,1) = 'B' THEN DTYPE = 'GDG     '\n     ELSE\n      IF SUBSTR(DWORK,POS1+1,1) = 'R' THEN DTYPE = 'PATH    '\n     ELSE\n      IF SUBSTR(DWORK,POS1+1,1) = 'G' THEN DTYPE = 'AIX     '\n     ELSE\n      IF SUBSTR(DWORK,POS1+1,1) = 'X' THEN DTYPE = 'ALIAS   '\n     ELSE\n      IF SUBSTR(DWORK,POS1+1,1) = 'U' THEN DTYPE = 'UCAT    '\n     ELSE DO   /* NO ENTRIES IN THE CATALOG OR UNKNOWN TYPE *//* MSZ */\n               /* UNKNOWN TYPE CAN BE CAUSED BY PARTIAL     *//* MSZ */\n               /* CATALOG RECORD SUCH AS AN INTERUPTED      *//* MSZ */\n               /* DELETE OR UPDATE-EXTEND (IDC11441I)       *//* MSZ */\n               /* THIS USED TO CAUSE A LOOP IN THIS CODE    *//* MSZ */\n      IF SUBSTR(DWORK,POS1+1,1) = '0' THEN ITERATE  /* CAT ENTRY MSZ */\n      POS1 = POS1 + 46  /* UNKNOWN DTYPE   */                 /* MSZ */\n      POS1 = POS1 + C2D(SUBSTR(DWORK,POS1,2)) /* NEXT ENTRY*/ /* MSZ */\n      ITERATE                                                 /* MSZ */\n     END   /* ELSE DO */                                      /* MSZ */\n /********************************************************************/\n /* Moved this section of code from above so catalog name would      */\n /* not print during generic hlq search if no entires were found.    */\n /********************************************************************/\n         IF CATNAME <> CATNAMET THEN /* IF RESUME NAME MAY ALREADY BE*/\n          DO                         /*    PRINTED                   */\n     /*    IF FOUND = 'TRUE' THEN  SAY   '     '  */\n           IF FOUND = 'TRUE' THEN  QUEUE '     '\n     /*    SAY 'CATALOG ' CATNAME */ /* IF NOT, PRINT IT             */\n           QUEUE 'CATALOG ' CATNAME  /* IF NOT, PRINT IT             */\n     /*    SAY ' '  */\n           QUEUE '   '\n           CATNAMET = CATNAME\n           FOUND = 'TRUE'                                       /*MSZ*/\n          END\n /*************************************************************//*MSZ*/\n /* CHECK FOR ERROR IN ENTRY RETURNED                         *//*MSZ*/\n /*************************************************************//*MSZ*/\n   CSIEFLAG = SUBSTR(DWORK,POS1+0,1) /* Entry flag information*//*MSZ*/\n   IF BITAND(CSIEFLAG,'40'X) = '40'X THEN DO                    /*MSZ*/\n     POS1 = POS1 + 50           /* HEADER LENGTH */             /*MSZ*/\n     POS1 = POS1 + C2D(SUBSTR(DWORK,POS1,2))                    /*MSZ*/\n /*  SAY   'ERROR PROCESSING THE FOLLOWING ENTRY:' */           /*MSZ*/\n /*  SAY   'DSN  =' DNAME                          */           /*MSZ*/\n /*  SAY   'CAT  =' CATNAME                        */           /*MSZ*/\n /*  SAY   'TYPE =' DTYPE                          */           /*MSZ*/\n     QUEUE 'ERROR PROCESSING THE FOLLOWING ENTRY:'              /*MSZ*/\n     QUEUE 'DSN  =' DNAME                                       /*MSZ*/\n     QUEUE 'CAT  =' CATNAME                                     /*MSZ*/\n     QUEUE 'TYPE =' DTYPE                                       /*MSZ*/\n     ITERATE    /* GO TO NEXT ENTRY */                          /*MSZ*/\n   END                                                          /*MSZ*/\n /********************************************************************/\n /*                                                                  */\n /*  HAVE NAME AND TYPE, GET VOLSER INFO                             */\n /*                                                                  */\n /********************************************************************/\n    COUNT = COUNT + 1  /* total entires found  */               /*MSZ*/\n    POS1 = POS1 + 46\n    NUMVOL = C2D(SUBSTR(DWORK,POS1+4,2))/6 /* HOW MANY VOLSERS ?     */\n                                    /*                               */\n    POS2 = POS1+6                   /* POSITION ON DATA              */\n    Drop VOLSER.\n    ALLVOLS = ''\n    DO I = 1 TO NUMVOL              /* MOVE VOLSERS TO OUTPUT FIELDS */\n      VOLSER.I = SUBSTR(DWORK,POS2,6)\n      POS2 = POS2 + 6\n      ALLVOLS = ALLVOLS VOLSER.I\n    END\n /* IF DNAMET <> DNAME THEN */    /* IF RESUME, NAME MAY ALREADY  MSZ*/\n /*                         */      /*    PRINTED                 MSZ*/\n /* DO                      */      /* IF NOT, PRINT IT           MSZ*/\n  /* SAY COPIES(' ',8) DTYPE DNAME ALLVOLS */\n     QUEUE COPIES(' ',8) DTYPE DNAME ALLVOLS\n\n /*  DNAMET=DNAME           */                                /* MSZ */\n /* END                     */                                /* MSZ */\n /********************************************************************/\n /*                                                                  */\n /*   GET POSITION OF NEXT ENTRY                                     */\n /*                                                                  */\n /********************************************************************/\n    POS1 = POS1 + C2D(SUBSTR(DWORK,POS1,2))\n  END\n IF RESUME = 'Y' &,                 /* IF WE'VE TRIED THIS ENTRY @01A*/\n  PREVNAME = DNAME THEN             /* TWICE, WE'VE GOT TO QUIT  @01A*/\n   DO                                                          /*@01A*/\n  /* SAY STRIP(DNAME) 'CANNOT BE PROCESSED WITH THE WORK AREA SIZE ',*/\n  /*     'PROVIDED - YOU MUST INCREASE THE WORK AREA AND RETRY'      */\n   QUEUE STRIP(DNAME) 'CANNOT BE PROCESSED WITH THE WORK AREA SIZE '\n   QUEUE  'PROVIDED - YOU MUST INCREASE THE WORK AREA AND RETRY'\n   /*RETURN */                                                 /*@01A*/\n     LEAVE                                                     /*@01A*/\n   END                                                         /*@01A*/\n PREVNAME = DNAME                   /* SAVE FOR NEXT ITERATION   @01A*/\nEND\n /********************************************************************/\n\nQUEUE ''  /* NULL TO END STACK */\nIF SYSVAR(SYSISPF)='ACTIVE' THEN CALL BROWSE_ISPF\nELSE DO QUEUED()\n PARSE PULL LINE\n SAY LINE\nEND\nEXIT 0\n\nBROWSE_ISPF: /* BROWSE OUTPUT IF ISPF IS ACTIVE          */\nADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\nADDRESS ISPEXEC \"VGET ZENVIR\"\nADDRESS TSO\nUID   = SYSVAR('SYSUID')        /* TSO USERID            */\nDDNM1 = 'DDO'||RANDOM(1,99999)  /* CHOOSE RANDOM DDNAME  */\nDDNM2 = 'DDP'||RANDOM(1,99999)  /* CHOOSE RANDOM DDNAME  */\nJUNK = MSG('OFF')\n\"ALLOC FILE(\"||DDNM1||\") UNIT(SYSALLDA) NEW CYL SPACE(5,5) DELETE\",\n     \" REUSE LRECL(132) RECFM(F B) BLKSIZE(8976)\"\n\"ALLOC FILE(\"||DDNM2||\") UNIT(SYSALLDA) NEW TRACKS SPACE(1,1) DELETE\",\n      \" REUSE LRECL(80) RECFM(F B) BLKSIZE(3120) DIR(1)\"\nJUNK = MSG('ON')\n\"NEWSTACK\"\n/*************************/\n/* CATPNL PANEL SOURCE */\n/*************************/\nIF SUBSTR(ZENVIR,6,1) >= 4 THEN\n  QUEUE \")PANEL KEYLIST(ISRSPBC,ISR)\"\nQUEUE \")ATTR\"\nQUEUE \"  _ TYPE(INPUT)   INTENS(HIGH) COLOR(TURQ) CAPS(OFF)\"\nQUEUE \"  | AREA(DYNAMIC) EXTEND(ON)   SCROLL(ON)\"\nQUEUE \"  + TYPE(TEXT)    INTENS(LOW)  COLOR(BLUE)\"\nQUEUE \"  @ TYPE(TEXT)    INTENS(LOW)  COLOR(TURQ)\"\nQUEUE \"  % TYPE(TEXT)    INTENS(HIGH) COLOR(GREEN)\"\nQUEUE \"  ! TYPE(OUTPUT)  INTENS(HIGH) COLOR(TURQ) PAD(-)\"\nQUEUE \" 01 TYPE(DATAOUT) INTENS(LOW)\"\nQUEUE \" 02 TYPE(DATAOUT) INTENS(HIGH)\"\nQUEUE \" 0B TYPE(DATAOUT) INTENS(HIGH) FORMAT(DBCS)\"\nQUEUE \" 0C TYPE(DATAOUT) INTENS(HIGH) FORMAT(EBCDIC)\"\nQUEUE \" 0D TYPE(DATAOUT) INTENS(HIGH)\"\nQUEUE \" 10 TYPE(DATAOUT) INTENS(LOW)  FORMAT(DBCS)\"\nQUEUE \" 11 TYPE(DATAOUT) INTENS(LOW)  FORMAT(EBCDIC)\"\nQUEUE \" 12 TYPE(DATAOUT) INTENS(LOW)\"\nQUEUE \")BODY EXPAND(//) WIDTH(&ZWIDTH)\"\nQUEUE \"%BROWSE  @&ZTITLE  / /  %LINE!ZLINES  %COL!ZCOLUMS+\"\nQUEUE \"%COMMAND ===>_ZCMD / /           %SCROLL ===>_Z   +\"\nQUEUE \"|ZDATA ---------------/ /-------------------------|\"\nQUEUE \"|                     / /                         |\"\nQUEUE \"| --------------------/-/-------------------------|\"\nQUEUE \")INIT\"\nQUEUE \"  .HELP = ISR10000\"\nQUEUE \"  .ZVARS = 'ZSCBR'\"\nQUEUE \"  &ZTITLE = 'Mark''s MVS Utilities - CATSRCH'\"\nQUEUE \"  VGET (ZSCBR) PROFILE\"\nQUEUE \"  IF (&ZSCBR = ' ')\"\nQUEUE \"   &ZSCBR = 'CSR'\"\nQUEUE \")REINIT\"\nQUEUE \"  REFRESH(ZCMD,ZSCBR,ZDATA,ZLINES,ZCOLUMS)\"\nQUEUE \")PROC\"\nQUEUE \"  &ZCURSOR = .CURSOR\"\nQUEUE \"  &ZCSROFF = .CSRPOS\"\nQUEUE \"  &ZLVLINE = LVLINE(ZDATA)\"\nQUEUE \"  VPUT (ZSCBR) PROFILE\"\nQUEUE \")END\"\nQUEUE \"\"\n/*                                    */\nAddress ISPEXEC \"LMINIT DATAID(PAN) DDNAME(\"ddnm2\")\"\nAddress ISPEXEC \"LMOPEN DATAID(\"pan\") OPTION(OUTPUT)\"\nDo queued()\n   Parse pull panline\n   Address ISPEXEC \"LMPUT DATAID(\"pan\") MODE(INVAR)\" ,\n           \"DATALOC(PANLINE) DATALEN(80)\"\nEnd\nAddress ISPEXEC \"LMMADD DATAID(\"pan\") MEMBER(CATPNL)\"\nAddress ISPEXEC \"LMFREE DATAID(\"pan\")\"\n\"Delstack\"\n\"EXECIO * DISKW\" DDNM1 \"(FINIS\"\nIF FOUND <> 'TRUE' THEN DO\n  ZEDSMSG = 'No matches found'\n  ZEDLMSG = 'No matches were found for' KEY ||'.' ,\n          '  CATSRCH -' ,\n          'Last updated on' LASTUPD ||'. Written by' ,\n          'Mark Zelden. Mark''s MVS Utilities -' ,\n          'http://www.mzelden.com/mvsutil.html'\n  ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* MSG - WITH ALARM */\nEND\nELSE DO\n  ZEDSMSG = COUNT 'matches found'\n  ZEDLMSG = COUNT 'matches were found for' KEY ||'.' ,\n          '  CATSRCH -' ,\n          'Last updated on' LASTUPD ||'. Written by' ,\n          'Mark Zelden. Mark''s MVS Utilities -' ,\n          'http://www.mzelden.com/mvsutil.html'\n  ADDRESS ISPEXEC \"SETMSG MSG(ISRZ000)\"  /* MSG - NO ALARM */\nEND\nADDRESS ISPEXEC \"LIBDEF ISPPLIB LIBRARY ID(\"||ddnm2||\") STACK\"\nADDRESS ISPEXEC \"LMINIT DATAID(TEMP) DDNAME(\"||ddnm1||\")\"\nADDRESS ISPEXEC \"BROWSE DATAID(\"||temp\") PANEL(CATPNL)\"\nADDRESS ISPEXEC \"LMFREE DATAID(\"||temp\")\"\nADDRESS ISPEXEC \"LIBDEF ISPPLIB\"\nJUNK = MSG('OFF')\n\"FREE FI(\"||ddnm1||\")\"\n\"FREE FI(\"||ddnm2||\")\"\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CATSRCHP": {"ttr": 2061, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01\\x00%\\x8f\\x01\\x00%\\x8f\\x08\\x15\\x00 \\x00 \\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf3\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-09-14T00:00:00", "modifydate": "2000-09-14T08:15:32", "lines": 32, "newlines": 32, "modlines": 0, "user": "CBT430"}, "text": ")ATTR DEFAULT(|+_)\n  | TYPE(TEXT) COLOR(WHITE) INTENS(HIGH)\n  + TYPE(TEXT) COLOR(BLUE) INTENS(LOW)\n)BODY\n|---------------------- Catalog Search Interface (CSI) -------------------------\n|Command ===>_ZCMD\n+\n+   Search  |===>_KEY                                         +\n+   Above:\n+     |%+- one character, |*+- one qualifier, |**+- one or more qualifiers\n+\n+   Catalog |===>_CAT                                         + (optional)\n+\n+   Do not use quotes in your search criteria.\n+\n+   NOTE: A double asterisk cannot precede or follow any characters; it\n+         must be preceded or followed by either a period or a blank.\n+\n+     EXAMPLES:  SYS1.A*.**  (correct)\n+                SYS1.A**    (not correct)\n+\n+   Caution should be exercised in using high-level qualifiers\n+   that contain generic filters because multiple catalogs can be\n+   searched.  A high-level of \"**\" will cause a search of every\n+   user catalog in the system.\n+\n)INIT\n  .CURSOR = ZCMD\n)PROC\n  VER( &KEY NONBLANK  )\n  &ZSEL = 'CMD(CATSRCH &KEY &CAT)'\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CLONERES": {"ttr": 2063, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x05\\x18\\x9f\\x01\\x073/\\x10\\x00\\x00\\xbf\\x00\\xbc\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-07-08T00:00:00", "modifydate": "2007-11-28T10:00:00", "lines": 191, "newlines": 188, "modlines": 0, "user": "CBT475"}, "text": "//USZCZT0C JOB (AD00),'#07B42 ZELDEN',\n//             NOTIFY=&SYSUID,\n//             CLASS=M,MSGCLASS=H,MSGLEVEL=(1,1)\n//*\n//*\n//************************************************************\n//* Sample clone of z/OS 1.8 maintenance sysres set / zones  *\n//************************************************************\n//* GLOBALLY CHANGE  \"RESM81\"  TO VOLID OF CURRENT SYSRES    *\n//* GLOBALLY CHANGE  \"RESM82\"  TO VOLID OF SECONDARY SYSRES  *\n//*    (These should be okay already for normal cloning)     *\n//*                                                          *\n//* GLOBALLY CHANGE  \"NEWRS\"   TO 1ST 5 CHARACTERS OF NEW    *\n//*                            SYSRES SET (Example: RESP3)   *\n//*                                                          *\n//*   WHEN CLONING IS COMPLETE THE NEW SYSRES SET WILL BE:   *\n//*                                                          *\n//*     NEWRS1 - PRIMARY SYSRES   (IBM - LOAD ADDRESS)       *\n//*     NEWRS2 - SECONDARY SYSRES (IBM - ROOT + OTHER HFS)   *\n//*                                                          *\n//************************************************************\n//* NOTE:  If cloning from a prior \"production\" IBM sysres   *\n//*        set instead of the maintenance sysres set, you    *\n//*        must change RESM81/RESM82 to the volsers of the   *\n//*        production sysres set.                            *\n//*                                                          *\n//************************************************************\n//* NOTE:  You must manually mount the following HFS files   *\n//*    to the proper service mount points in order to apply  *\n//*    maintenance.  Examples:                               *\n//*                                                          *\n//*    SYS1.OMVS.RESM82.ROOT                                 *\n//*        mount at: /servz18                                *\n//*    SYS1.OMVS.RESM82.TIVOLI                               *\n//*        mount at: /servz18/usr/lpp/Tivoli                 *\n//*    SYS1.OMVS.RESM82.NETVHFS                              *\n//*        mount at: /servz18/usr/lpp/netview                *\n//*    SYS1.OMVS.RESM82.PLI.SIBMROOT                         *\n//*        mount at: /servz18/usr/lpp/pli                    *\n//*    SYS1.OMVS.RESM82.SIGYROOT                             *\n//*        mount at: /servz18/usr/lpp/cobol                  *\n//*    SYS1.OMVS.RESM82.XML                                  *\n//*        mount at: /servz18/usr/lpp/ixm                    *\n//*                                                          *\n//*    This job also copies all of these HFS files to        *\n//*    NEWRS2.  They should already be (perhaps indirectly)  *\n//*    cataloged on the target system prior to ipling.       *\n//************************************************************\n//* DON'T FORGET TO REPLY \"YES\" TO THE FOLLOWING MESSAGES    *\n//*   \"FDRW01 CONFIRM REQUEST TO RESTORE UNIT=CUU,VOL=NEWRS1 *\n//*       AND                                                *\n//*   \"FDRW01 CONFIRM REQUEST TO RESTORE UNIT=CUU,VOL=NEWRS2 *\n//* THIS IS DONE IN THE 1ST AND 2ND STEPS                    *\n//************************************************************\n//*  ===================                                     *\n//*  ===>  WARNING  <===                                     *\n//*  ===================                                     *\n//*  CANCEL OUT OF THIS JOB AFTER MAKING CHANGES             *\n//*  AND SUBMITTING IT OR IT WILL BE UNUSABLE NEXT TIME.     *\n//*  ===>  WARNING  <===                                     *\n//*  ALL VSAM DATASETS COPIED TO NEWRS1/NEWRS2 WILL BE       *\n//*  REMOVED DURING THIS JOBSTREAM IF THEY EXIST. YOU MUST   *\n//*  MANUALLY MAKE PROVISIONS FOR COPYING/MOVING VSAM        *\n//*  DATA SETS TO NEWRS1/NEWRS2 AFTER THIS JOB COMPLETES.    *\n//************************************************************\n//*\n//***************************************\n//* VOLUME COPY OF RESM81 TO NEWRS1     *\n//***************************************\n//COPYRES  EXEC PGM=FDR,REGION=2M\n//SYSPRINT DD  SYSOUT=*\n//SYSPRIN1 DD  SYSOUT=*\n//SYSUDUMP DD  SYSOUT=*\n//DISK1    DD  UNIT=SYSALLDA,VOL=SER=RESM81,DISP=SHR\n//TAPE1    DD  UNIT=SYSALLDA,VOL=SER=NEWRS1,DISP=SHR\n//SYSIN    DD  *\n COPY TYPE=FDR,VOLRESET=YES\n/*\n//* COPY TYPE=FDR,VOLRESET=YES\n//* COPY TYPE=FDR,VOLRESET=YES,CONFMESS=NO\n//***************************************\n//* COPY OF MAINTENANCE HFS FILES       *\n//* TO NEWRS2                           *\n//***************************************\n//COPYHFS  EXEC PGM=FDRCOPY,REGION=4M\n//SYSPRINT DD  SYSOUT=*\n//SYSPRIN1 DD  SYSOUT=*\n//SYSUDUMP DD  SYSOUT=*\n//SYSIN    DD  *\n COPY     TYPE=DSF,DSNENQ=NONE,ENQERR=NO,NOCAT,HFS=QUIESCE\n SELECT   CATDSN=SYS1.OMVS.RESM82.**,\n            NEWI=..NEWRS2,NVOL=NEWRS2\n/*\n//*\n//**************************************\n//* REMOVE EXISTING VSAM ZONES, DSN'S  *\n//* AND VVDS IF THEY EXIST ON NEWRS1   *\n//* (DUE TO FULL VOLUME DISK TO DISK   *\n//* COPIES)                            *\n//*                                    *\n//* CHANGE SYS1.ICFCAT.MASTER TO THE   *\n//* MCAT OF THE DRIVING SYSTEM BELOW   *\n//**************************************\n//REMOVE   EXEC PGM=IDCAMS,REGION=2M,COND=(0,NE)\n//NEWRS1   DD  UNIT=SYSALLDA,DISP=SHR,VOL=SER=NEWRS1\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  *\n ALTER SYS1.ICFCAT.MASTER FILE(NEWRS1) +\n       REMOVEVOLUMES(NEWRS1)\n/*\n//**************************************\n//* DEL/DEF NEW TARGET ZONE            *\n//**************************************\n//DEFREPRO EXEC PGM=IDCAMS,REGION=2M,COND=(0,NE)\n//VDSBYPAS DD  DUMMY       /* BYPASS VAM */\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  *\n DELETE (SMPE.IBM.ZOS18.NEWRS1.CSI)\n IF LASTCC = 8 THEN SET MAXCC=0\n DEFINE CLUSTER( +\n                NAME(SMPE.IBM.ZOS18.NEWRS1.CSI) +\n                FREESPACE(10,5) +\n                KEYS(24 0) +\n                RECORDSIZE(24 143) +\n                SHR(2) +\n                BUFSP(90000) +\n                VOLUME(SYSMT2) +\n               ) +\n          DATA( +\n               NAME(SMPE.IBM.ZOS18.NEWRS1.CSI.DATA) +\n               CYLINDERS(100 10) +\n               CISZ(8192) +\n              ) +\n          INDEX( +\n               NAME(SMPE.IBM.ZOS18.NEWRS1.CSI.INDEX) +\n               CYLINDERS(1 1) +\n               CISZ(2560) +\n               )\n IF MAXCC = 0 THEN +\n REPRO INDATASET(SMPE.IBM.ZOS18.RESM81.CSI) +\n       OUTDATASET(SMPE.IBM.ZOS18.NEWRS1.CSI)\n/*\n//**************************************\n//* DEFINE ZONES TO SMP/E AND ZONEEDIT *\n//* DDDEFS TO POINT TO NEW VOLUMES.    *\n//**************************************\n//*********************************************************\n//* RC=8 (GIM35701E) IS EXPECTED THE FIRST TIME YOU CLONE *\n//* TO A PREVIOUSLY UNUSED SYSRES SET FOR THIS GZONE DUE  *\n//* TO THE \"DEL GLOBALZONE ZONEINDEX\" COMMAND.            *\n//*********************************************************\n//SMPE   EXEC  PGM=GIMSMP,REGION=0M,\n//             PARM='CSI=SMPE.IBM.ZOS18.GLOBAL.CSI'\n//SMPOUT   DD  SYSOUT=*\n//SMPRPT   DD  SYSOUT=*\n//SMPLIST  DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=*\n//SMPCNTL  DD  *\n SET BOUNDARY(GLOBAL).\n UCLIN.\n DEL GLOBALZONE ZONEINDEX((NEWRS11)).\n ENDUCL.\n RESETRC.\n ZONERENAME(RESM811)\n    TO(NEWRS11)\n    NEWDATASET(SMPE.IBM.ZOS18.NEWRS1.CSI)\n    RELATED(ZNAD100).\n SET BOUNDARY(NEWRS11).\n ZONEEDIT DDDEF.\n    CHANGE VOLUME(RESM81,NEWRS1).\n ENDZONEEDIT.\n/*\n//*\n//**************************************\n//* RESYNCHRONIZE THE GENERATION AND   *\n//* CYCLE NUMBERS IN THE FDR/ABR MODEL *\n//* DSCB TO MATCH THE FDR/ABR CATALOG. *\n//**************************************\n//FDRABRM  EXEC PGM=FDRABRM,\n//             COND=((8,LT,SMPE.SMPE),(0,NE,COPYRES),(0,NE,COPYHFS),\n//             (0,NE,DEFREPRO))\n//SYSPRINT DD  SYSOUT=*\n//ABRMAP   DD  SYSOUT=*\n//SYSUDUMP DD  SYSOUT=*\n//DISK1    DD  UNIT=SYSDA,DISP=SHR,VOL=SER=NEWRS1\n//DISK2    DD  UNIT=SYSDA,DISP=SHR,VOL=SER=NEWRS2\n//SYSIN    DD  *\n  REMODEL VOL=NEWRS1,FORCE\n  REMODEL VOL=NEWRS2,FORCE\n/*\n//*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CLONERSO": {"ttr": 2308, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x05\\x18\\x9f\\x01\\x05\\x18\\x9f\\x14\\x00\\x00\\xbc\\x00\\xbc\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf6\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-07-08T00:00:00", "modifydate": "2005-07-08T14:00:00", "lines": 188, "newlines": 188, "modlines": 0, "user": "CBT469"}, "text": "//USZCZT0C JOB (AD00),'#04D42 ZELDEN',\n//             NOTIFY=&SYSUID,\n//             CLASS=M,MSGCLASS=H,MSGLEVEL=(1,1)\n//*\n//*\n//************************************************************\n//* GLOBALLY CHANGE  \"INPRS1\"  TO VOLID OF INPUT SYSRES #1   *\n//* GLOBALLY CHANGE  \"NEWRS1\"  TO VOLID OF NEW SYSRES #1     *\n//* GLOBALLY CHANGE  \"INPRS2\"  TO VOLID OF INPUT SYSRES #2   *\n//* GLOBALLY CHANGE  \"NEWRS2\"  TO VOLID OF NEW SYSRES #2     *\n//************************************************************\n//*  NOTE: YOU MUST MANUALLY MOUNT OMVS.ROOT.NEWRS1          *\n//*    TO THE SERVICE MOUNT POINT TO APPLY MAINTENANCE.      *\n//************************************************************\n//* DON'T FORGET TO REPLY \"YES\" TO THE FOLLOWING MESSAGE     *\n//* \"FDRW01 CONFIRM REQUEST TO RESTORE UNIT=CUU,VOL=NEWRS1   *\n//************************************************************\n//*  ===================                                     *\n//*  ===>  WARNING  <===                                     *\n//*  ===================                                     *\n//*  CANCEL OUT OF THIS JOB AFTER MAKING CHANGES             *\n//*  AND SUBMITTING IT OR IT WILL BE UNUSABLE NEXT TIME.     *\n//*  ===>  WARNING  <===                                     *\n//*  ALL VSAM DATASETS COPIED TO NEWRS1 WILL BE REMOVED      *\n//*  DURING THIS JOBSTREAM IF THEY EXIST. YOU MUST MANUALLY  *\n//*  MAKE PROVISIONS FOR COPYING/MOVING VSAM DATASETS TO     *\n//*  NEWRS1 AFTER THIS JOB COMPLETES.                        *\n//************************************************************\n//*\n//***************************************\n//* VOLUME COPY OF INPRS1 TO NEWRS1     *\n//***************************************\n//COPY1    EXEC PGM=FDR,REGION=2M\n//SYSPRINT DD  SYSOUT=*\n//SYSPRIN1 DD  SYSOUT=*\n//SYSUDUMP DD  SYSOUT=*\n//DISK1    DD  UNIT=SYSDA,VOL=SER=INPRS1,DISP=SHR\n//TAPE1    DD  UNIT=SYSDA,VOL=SER=NEWRS1,DISP=SHR\n//SYSIN    DD  *\n COPY TYPE=FDR,VOLRESET=YES\n/*\n//* COPY TYPE=FDR,VOLRESET=YES,CONFMESS=NO\n//***************************************\n//* VOLUME COPY OF INPRS2 TO NEWRS2     *\n//***************************************\n//COPY2    EXEC PGM=FDR,REGION=2M\n//SYSPRINT DD  SYSOUT=*\n//SYSPRIN1 DD  SYSOUT=*\n//SYSUDUMP DD  SYSOUT=*\n//DISK1    DD  UNIT=SYSDA,VOL=SER=INPRS2,DISP=SHR\n//TAPE1    DD  UNIT=SYSDA,VOL=SER=NEWRS2,DISP=SHR\n//SYSIN    DD  *\n COPY TYPE=FDR,VOLRESET=YES\n/*\n//* COPY TYPE=FDR,VOLRESET=YES,CONFMESS=NO\n//***************************************\n//* COPY OF ROOT HFS FILE               *\n//***************************************\n//COPYHFS  EXEC PGM=FDRCOPY,REGION=4M\n//SYSPRINT DD  SYSOUT=*\n//SYSPRIN1 DD  SYSOUT=*\n//SYSUDUMP DD  SYSOUT=*\n//SYSIN    DD  *\n COPY     TYPE=DSF,DSNENQ=NONE,ENQERR=NO\n SELECT   CATDSN=OMVS.ROOT.INPRS1,\n            NEWN=OMVS.ROOT.NEWRS1\n/*\n//**************************************\n//* REMOVE EXISTING VSAM ZONES, DSN'S  *\n//* AND VVDS IF THEY EXIST ON NEWRS1   *\n//* OR NEWRS2                          *\n//**************************************\n//REMOVE   EXEC PGM=IDCAMS,REGION=2M,COND=(0,NE)\n//NEWRS1   DD  UNIT=SYSDA,DISP=SHR,VOL=SER=NEWRS1\n//NEWRS2   DD  UNIT=SYSDA,DISP=SHR,VOL=SER=NEWRS2\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  *\n ALTER SYSICF.MASTER.ASYS FILE(NEWRS1) +\n       REMOVEVOLUMES(NEWRS1)\n ALTER SYSICF.MASTER.ASYS FILE(NEWRS2) +\n       REMOVEVOLUMES(NEWRS2)\n/*\n//**************************************\n//* DEL/DEF NEW TARGET ZONE            *\n//**************************************\n//DEFREPRO EXEC PGM=IDCAMS,REGION=2M,COND=(0,NE)\n//VDSBYPAS DD  DUMMY       /* BYPASS VAM */\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  *\n DELETE (MVSSMPE.ZOS14.NEWRS1.CSI)\n IF LASTCC = 8 THEN SET MAXCC=0\n DEFINE CLUSTER( +\n                NAME(MVSSMPE.ZOS14.NEWRS1.CSI) +\n                FREESPACE(10,5) +\n                KEYS(24 0) +\n                RECORDSIZE(24 143) +\n                SHR(2) +\n                BUFSP(90000) +\n                VOLUME(MVS001) +\n               ) +\n          DATA( +\n               NAME(MVSSMPE.ZOS14.NEWRS1.CSI.DATA) +\n               CYLINDERS(90 9) +\n               CISZ(4096) +\n              ) +\n          INDEX( +\n               NAME(MVSSMPE.ZOS14.NEWRS1.CSI.INDEX) +\n               CYLINDERS(2 1) +\n               )\n IF MAXCC = 0 THEN +\n REPRO INDATASET(MVSSMPE.ZOS14.INPRS1.CSI) +\n       OUTDATASET(MVSSMPE.ZOS14.NEWRS1.CSI)\n/*\n//**************************************\n//* DEFINE ZONES TO SMP/E AND ZONEEDIT *\n//* DDDEFS TO POINT TO NEW VOLUMES.    *\n//**************************************\n//SMPE    EXEC SMPE,\n//             COND=(0,NE)\n//SMPCNTL  DD  *\n SET BOUNDARY(GLOBAL).\n UCLIN.\n DEL GLOBALZONE ZONEINDEX((NEWRS11)).\n DEL GLOBALZONE ZONEINDEX((NEWRS12)).\n DEL GLOBALZONE ZONEINDEX((NEWRS13)).\n ENDUCL.\n RESETRC.\n ZONERENAME(INPRS11)\n    TO(NEWRS11)\n    NEWDATASET(MVSSMPE.ZOS14.NEWRS1.CSI)\n    RELATED(MVSD100).\n ZONERENAME(INPRS12)\n    TO(NEWRS12)\n    NEWDATASET(MVSSMPE.ZOS14.NEWRS1.CSI)\n    RELATED(MVSD200).\n ZONERENAME(INPRS13)\n    TO(NEWRS13)\n    NEWDATASET(MVSSMPE.ZOS14.NEWRS1.CSI)\n    RELATED(MVSD300).\n SET BOUNDARY(NEWRS11).\n ZONEEDIT DDDEF.\n    CHANGE VOLUME(INPRS1,NEWRS1).\n    CHANGE VOLUME(INPRS2,NEWRS2).\n ENDZONEEDIT.\n SET BOUNDARY(NEWRS12).\n ZONEEDIT DDDEF.\n    CHANGE VOLUME(INPRS1,NEWRS1).\n    CHANGE VOLUME(INPRS2,NEWRS2).\n ENDZONEEDIT.\n SET BOUNDARY(NEWRS13).\n ZONEEDIT DDDEF.\n    CHANGE VOLUME(INPRS1,NEWRS1).\n    CHANGE VOLUME(INPRS2,NEWRS2).\n ENDZONEEDIT.\n SET BOUNDARY(MVSD100).\n ZONEEDIT DDDEF.\n    CHANGE VOLUME(INPRS1,NEWRS1).\n    CHANGE VOLUME(INPRS2,NEWRS2).\n ENDZONEEDIT.\n SET BOUNDARY(MVSD200).\n ZONEEDIT DDDEF.\n    CHANGE VOLUME(INPRS1,NEWRS1).\n    CHANGE VOLUME(INPRS2,NEWRS2).\n ENDZONEEDIT.\n SET BOUNDARY(MVSD300).\n ZONEEDIT DDDEF.\n    CHANGE VOLUME(INPRS1,NEWRS1).\n    CHANGE VOLUME(INPRS2,NEWRS2).\n ENDZONEEDIT.\n/*\n//*\n//**************************************\n//* RESYNCHRONIZE THE GENERATION AND   *\n//* CYCLE NUMBERS IN THE FDR/ABR MODEL *\n//* DSCB TO MATCH THE FDR/ABR CATALOG. *\n//**************************************\n//FDRABRM  EXEC PGM=FDRABRM,\n//             COND=((8,LT,SMPE.SMPE),(0,NE,COPY1),(0,NE,COPY2),\n//             (0,NE,DEFREPRO))\n//SYSPRINT DD  SYSOUT=*\n//ABRMAP   DD  SYSOUT=*\n//SYSUDUMP DD  SYSOUT=*\n//DISK1    DD  UNIT=SYSDA,DISP=SHR,VOL=SER=NEWRS1\n//DISK2    DD  UNIT=SYSDA,DISP=SHR,VOL=SER=NEWRS2\n//SYSIN    DD  *\n  REMODEL VOL=NEWRS1,FORCE\n  REMODEL VOL=NEWRS2,FORCE\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CMD34": {"ttr": 2312, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x07\\x02?\\x01\\x19\\x00?\\x12@\\x00}\\x00U\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf9\\xf7@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-01-23T00:00:00", "modifydate": "2019-01-03T12:40:00", "lines": 125, "newlines": 85, "modlines": 0, "user": "CBT497"}, "text": "/* REXX                                  */\n/*                                       */\n/* AUTHOR: Mark Zelden                   */\n/* Last Updated 01/03/2019               */\n/************************************************************/\n/* CMD34 - Process commands against an ISPF 3.4 type DSLIST */\n/*                                                          */\n/* SYNTAX:   TSO %CMD34 DSN_LVL COMMAND                     */\n/*                                                          */\n/*  If slashes are found as part of the command the data    */\n/*  set name will be substituted in place of the slashes    */\n/*  similar to what ISPF 3.4 does. The data set names are   */\n/*  always enclosed in single quotes when passed to the     */\n/*  command (just like ISPF 3.4 does).                      */\n/*                                                          */\n/*  Prior to the command(s) being executed you are shown    */\n/*  a sample of what the command will look like and must    */\n/*  respond with \"YES\" or \"REVerse\" to actually issue       */\n/*  the command against the data set list. Note that        */\n/*  \"REVERSE\" can be abbreviated using 3 or more letters    */\n/*  and that case does not matter in the response.          */\n/*                                                          */\n/*  \"REVerse\" mode is useful when you are trying to delete  */\n/*  GDGs plus the GDG base(s) in the data set list,         */\n/*  otherwise the command will fail against the GDG base    */\n/*  since there are still GDGs that exist in the base.      */\n/*                                                          */\n/*                                                          */\n/* Examples: TSO %CMD34 SYS2.OLD.PRODUCT.HLQ HMIG           */\n/*           TSO %CMD34 SOME.HLQ* LISTC ENT(/) VOL          */\n/*           TSO %CMD34 HLQ.OLD.JUNK DEL /                  */\n/*                                                          */\n/************************************************************/\nArg lvl cmd\nIf lvl = '' | cmd = '' then do\n  Say 'Missing DSN_LVL or COMMAND to execute.'\n  Say ' '\n  Say 'SYNTAX:   TSO %CMD34 DSN_LVL COMMAND'\n  Say ' '\n  Say 'Examples: TSO %CMD34 SYS2.OLD.PRODUCT.HLQ HMIG  '\n  Say '          TSO %CMD34 SOME.HLQ* LISTC ENT(/) VOL '\n  Say '          TSO %CMD34 HLQ.OLD.JUNK DEL /         '\n  exit 12\nEnd\n /*                                                         */\n /* Quick ISPF save of data set names. This is much quicker */\n /* than using OPT 3.4, because it does not do an obtain    */\n /* for each data set in the list because of STATS(NO).     */\n /* The dsn created will be userid.CMD34.DATASETS           */\n /*                                                         */\nAddress ISPEXEC \"CONTROL ERRORS RETURN\"\nAddress ISPEXEC \"LMDINIT LISTID(LISTID) LEVEL(\"lvl\")\"\nAddress ISPEXEC ,\n  \"LMDLIST LISTID(\"listid\") OPTION(SAVE) STATS(NO) GROUP(CMD34)\"\nIf rc=4 then do\n  say 'No data sets matched specified search criteria.'\n  Address ISPEXEC \"LMDFREE LISTID(\"listid\")\"\n  exit 12\nEnd\nAddress ISPEXEC \"LMDFREE LISTID(\"listid\")\"\n\nuid = sysvar('SYSUID')\nrevmode = 0  /* do commands against dsn list in reverse */\n\n/* allocate dsn list file and read it */\n\"ALLOC FI(INPUT) DA('\" || uid || \".CMD34.DATASETS') SHR REUSE\"\n\"EXECIO * DISKR INPUT (STEM INREC. FINIS\"\nIf revmode = 0 then do\n  Do I=1 to INREC.0\n    dsn = word(inrec.i,1)\n    If pos('/',cmd) <> 0 then do\n      cmdn = cmd\n      Do until pos('/',cmdn) = 0\n        cmd1 = Substr(cmdn,1,pos('/',cmdn)-1)\n        cmd2 = Substr(cmdn,pos('/',cmdn)+1,Length(cmdn)-Length(cmd1)-1)\n        cmdn = cmd1 || \"'\" || dsn || \"'\" || cmd2\n      End /* do until */\n      If I = 1 then call Show_Sample\n      If revmode = 1 then leave\n      Address TSO cmdn\n    End /* if pos */\n    Else do\n      If I = 1 then call Show_Sample\n      If revmode = 1 then leave\n      Address TSO cmd \"'\" || dsn || \"'\"\n    End\n  End /* do I */\nEnd /* if revmode = 0 */\nIf revmode = 1 then do\n  Do I=INREC.0 to 1 by -1\n    dsn = word(inrec.i,1)\n    If pos('/',cmd) <> 0 then do\n      cmdn = cmd\n      Do until pos('/',cmdn) = 0\n        cmd1 = Substr(cmdn,1,pos('/',cmdn)-1)\n        cmd2 = Substr(cmdn,pos('/',cmdn)+1,Length(cmdn)-Length(cmd1)-1)\n        cmdn = cmd1 || \"'\" || dsn || \"'\" || cmd2\n      End /* do until */\n      Address TSO cmdn\n    End /* if pos */\n    Else do\n      Address TSO cmd \"'\" || dsn || \"'\"\n    End\n  End /* do I */\nEnd /* if revmode = 0 */\n\njunk = msg(off)\n\"DELETE '\" || uid || \".CMD34.DATASETS'\"\njunk = msg(on)\nExit 0\n\nShow_Sample:\nSay 'Sample command(s) to be entered:'\nSay ' '\nIf pos('/',cmd) <> 0 then Say 'TSO 'cmdn\n Else say 'TSO' cmd \"'\" || dsn || \"'\"\nSay ' '\nSay 'Are you sure? Enter \"YES\" or \"REVerse\" to execute.'\nParse upper pull resp\nIf resp = 'YES' then return  /* YES - go issue commands    */\nIf Abbrev('REVERSE',resp,3) = 1 then do\n  revmode = 1\n  Return\nEnd\n Else Exit 0                 /* anything else - forget it! */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COLADD": {"ttr": 2315, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x14\\x0f\\x01\\x13(\\x0f\\x14\\x15\\x01N\\x01\\x1b\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf7@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-05-19T00:00:00", "modifydate": "2013-10-07T14:15:00", "lines": 334, "newlines": 283, "modlines": 0, "user": "CBT487"}, "text": "/* REXX */\n/*                           */\n/* AUTHOR: Mark Zelden       */\n/*                           */\n/* Last Updated 10/07/2013   */\n/*                           */\nhelp_start = HELP_INCL()\n/*********************************************************************/\n/*                                                                   */\n/* This EDIT macro totals numbers in a specified column range.       */\n/* An optional parameter of \"HEX\", \"ZONE\", \"PACK\", or \"BIN\" is       */\n/* needed to add hexadecimal, zoned decimal, packed decimal, or      */\n/* binary data. \"DEC\" is the default addition type.                  */\n/*                                                                   */\n/* Hexadecimal numbers to be added may be represented with or        */\n/* without an \"X\". In other words, x'1E' and 1E can both be          */\n/* processed and are treated the same.                               */\n/*                                                                   */\n/* The result is displayed as an ISPF short message in the top       */\n/* right hand corner in the same format as the addition type         */\n/* (decimal or hexadecimal). If extended help is chosen after        */\n/* the result is displayed (normally PF1), then the result is        */\n/* displayed in both decimal and hexadecimal and the average         */\n/* is also displayed.                                                */\n/*                                                                   */\n/* Line range labels can be used, and excluded lines are always      */\n/* omitted.                                                          */\n/*                                                                   */\n/*********************************************************************/\n/* COMMAND SYNTAX AND USAGE NOTES:                                   */\n/*                                                                   */\n/* COLADD begcol endcol <DEC | HEX | ZONE | PACK | BIN> (.L1) (.L2)  */\n/*                    ** DEC is the default                          */\n/*                                                                   */\n/*  ** NOTE 1: If you execute COLADD with no parms or with a parm    */\n/*             of \"?\", the comment section of this code with syntax  */\n/*             and usage notes will be displayed as \"help\" note      */\n/*             lines. Use the \"RESET\" command to remove them.        */\n/*                                                                   */\n/*  ** NOTE 2: If using line range labels then DEC, HEX, ZONE,       */\n/*             PACK, or BIN must be specified as the 3rd positional  */\n/*             parameter.                                            */\n/*                                                                   */\n/*  ** NOTE 3: Excluded lines are ALWAYS omitted.                    */\n/*                                                                   */\n/*  ** NOTE 4: DEC, HEX, ZONE, PACK, and BIN may be abbreviated by   */\n/*             using one or more of their characters. HEX may also   */\n/*             be abbreviated as \"X\".                                */\n/*                                                                   */\n/*********************************************************************/\n/*  EXAMPLES:                                                        */\n/*                                                                   */\n/*         COLADD 10 25                                              */\n/*         COLADD 33 40 HEX                                          */\n/*         COLADD 25 30 DEC .A .B                                    */\n/*         COLADD 10 29 ZONE                                         */\n/*         COLADD 10 16 PACK                                         */\n/*         COLADD 40 44 BIN                                          */\n/*         COLADD 44 57 X .FROM .TO                                  */\n/*********************************************************************/\nhelp_end = HELP_INCL()\n/* TRACE ?R */\nAddress ISREDIT\n\"MACRO (begcol endcol type label1 label2)\"\n /* Address ISPEXEC \"CONTROL ERRORS RETURN\"  */\n/***********************************************/\n/*   VERIFY INPUT PARAMETERS                   */\n/***********************************************/\nbegcol = Translate(begcol) /* chage to upper case if alpha */\n\"(width) = DATA_WIDTH \"   /* length of line       */\nwidth = Format(width)     /* remove leading zeros */\nIf begcol = '?' then do\n  Call HELP_NOTELINES\n  Exit 1  /* return cursor to command line */\nEnd\nIf begcol = '' then do\n  zedsmsg = 'MISSING PARAMETER'\n  zedlmsg = 'A BEGINNING COLUMN NUMBER',\n            'MUST BE SPECIFIED.'\n  Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n  Call HELP_NOTELINES\n  Exit 4\nEnd\nSelect\n  When Datatype(begcol,Number) = 1 & endcol = '' then do\n    zedsmsg = 'NO ENDING COLUMN'\n    zedlmsg = 'AN ENDING COLUMN NUMBER',\n              'MUST BE SPECIFIED.'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"        /* msg - with alarm */\n    Exit 12\n  End /* when */\n  When Datatype(begcol,Number) <> 1 | ,\n       Datatype(endcol,Number) <> 1 then do\n    zedsmsg = 'COL NUMBER NOT NUMERIC'\n    zedlmsg = 'THE BEGINNING AND ENDING COLUMN NUMBERS',\n              'MUST BE NUMERIC.'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"        /* msg - with alarm */\n    Exit 12\n  End /* when */\n  When Datatype(begcol,Number) =1 & Datatype(endcol,Number) =1 then do\n    If endcol < begcol then do\n      zedsmsg = 'END COL < START COL'\n      zedlmsg = 'THE ENDING COLUMN MUST BE GREATER THAN OR',\n                'EQUAL TO THE STARTING COLUMN.'\n      Address ISPEXEC \"SETMSG MSG(ISRZ001)\"      /* msg - with alarm */\n      Exit 12\n    End\n    If type = '' then type = 'DEC'        /* default add type is DEC */\n    else do\n      type = Translate(type)              /* change to upper case    */\n      If Abbrev('DECIMAL',type,1) = 0 & ,\n         Abbrev('HEXADECIMAL',type,1) = 0 & ,\n         Abbrev('ZONE',type,1) = 0 & ,\n         Abbrev('PACK',type,1) = 0 & ,\n         Abbrev('BIN',type,1) = 0 & ,\n         type <> 'X' then do\n        zedsmsg = 'INVALID ADDITION TYPE'\n        zedlmsg = 'ADDITION TYPE MUST BE \"DEC\", \"HEX\",' ,\n                  '\"ZONE\", \"PACK\", or \"BIN\".'\n        Address ISPEXEC \"SETMSG MSG(ISRZ001)\"    /* msg - with alarm */\n        Exit 12\n      End\n    End /* else do */\n    If begcol < 1 | endcol < 1 then do\n      zedsmsg = 'INVALID COLUMN NUMBER'\n      zedlmsg = 'ALL COLUMN SPECIFICATIONS MUST BE' ,\n                'BETWEEN 1 AND' width\n      Address ISPEXEC \"SETMSG MSG(ISRZ001)\"      /* msg - with alarm */\n      Exit 12\n    End\n    If begcol > width | endcol > width then do\n      zedsmsg = 'INVALID COLUMN NUMBER'\n      zedlmsg = 'ALL COLUMN SPECIFICATIONS MUST BE' ,\n                'BETWEEN 1 AND' width\n      Address ISPEXEC \"SETMSG MSG(ISRZ001)\"      /* msg - with alarm */\n      Exit 12\n    End\n  End /* when */\nEnd /* select */\n/***********************************************/\n/*   FIND OUT IF LABELS ARE BEING USED         */\n/***********************************************/\nCall FIND_LABELS\n/***************************************************/\n/* INITIALIZE VARIABLES NEEDED IN PROCESSING LOOP  */\n/***************************************************/\nNumeric digits 15                    /* default of 9 not enough      */\ncount        = 0                     /* count of added lines         */\nnot_counted  = 0                     /* count of \"not counted\" lines */\ntotal        = 0                     /* total of numbers added       */\ntgtlen       = endcol-begcol+1       /* length of mumbers to add     */\n/*********************************************************************/\n/*   Begin column addition loop                                      */\n/*********************************************************************/\nDo until lastln = firstln-1\n  /* copy the data in the current line to variable 'data1' */\n  \"(data1) = LINE \"firstln\n  \"ISREDIT (chkexcl) = XSTATUS\" firstln\n  If chkexcl = \"NX\" then do       /* only process non-excluded lines */\n    add_data = Substr(data1,begcol,tgtlen) /* find data              */\n    If add_data = '' then do       /* no data within cols specified  */\n      warnmsg = \"'*** WARNING - NEXT LINE WAS NOT COUNTED ***'\"\n      \"ISREDIT LINE_BEFORE\" firstln \"= NOTELINE \" warnmsg\n      not_counted = not_counted + 1 /* bump up \"not counted\" counter */\n      firstln = firstln + 1        /* bump up line counter           */\n      iterate                      /* get next record                */\n    End /* if add_data = '' */\n    count = count + 1             /* add one to line count           */\n    Signal on SYNTAX /* trap errors */\n    /*****************************************************************/\n    /*   Binary data                                                 */\n    /*****************************************************************/\n    If Abbrev('BIN',type,1) <> 0 then ,          /* add bin numbers  */\n      add_data = C2d(add_data)                   /* convert to dec   */\n    /*****************************************************************/\n    /*   Packed decimal data                                         */\n    /*****************************************************************/\n    If Abbrev('PACK',type,1) <> 0 then do /* add packed dec numbers  */\n      add_data = Strip(add_data)                   /* remove blanks  */\n      add_data = C2x(add_data)                     /* convert to hex */\n      len_add_data = Length(add_data)              /* length of data */\n      sign     = Substr(add_data,len_add_data,1)   /* sign portion   */\n      If Verify(sign,'CFD') <> 0 then do           /* valid sign?    */\n        warnmsg = \"'*** ERROR - NEXT LINE HAS BAD SIGN ***'\"\n        \"ISREDIT LINE_BEFORE\" firstln \"= NOTELINE \" warnmsg\n        zedsmsg = 'CAN''T ADD LINE' firstln\n        zedlmsg = 'ERROR - THE DATA TO ADD ON LINE' firstln 'IS NOT',\n                  'VALID PACKED DECIMAL - BAD SIGN.'\n        Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm   */\n        Exit 12\n      End  /* If Verify(sign */\n      add_data = Left(add_data,len_add_data-1)     /* remove sign    */\n      If sign = 'D' then add_data = '-' || add_data /* negative num  */\n    End /* If Abbrev('PACK' */\n    /*****************************************************************/\n    /*   Zoned decimal data                                          */\n    /*****************************************************************/\n    If Abbrev('ZONE',type,1) <> 0 then do /* add zone dec. numbers   */\n      add_data = Strip(add_data)                   /* remove blanks  */\n      len_add_data = Length(add_data)              /* length of data */\n      zone     = Substr(add_data,len_add_data,1)   /* zone portion   */\n      add_data = Substr(add_data,1,len_add_data-1) /* non-zone part  */\n      If Datatype(add_data,N) <> 1 then ,          /* valid number?  */\n        call SYNTAX                        /* no, call error routine */\n      zonedtab = '0123456789ABCDEFGHIJKLMNOPQR{}'\n      If Verify(zone,zonedtab) <> 0 then do      /* valid zone?      */\n        warnmsg = \"'*** ERROR - NEXT LINE HAS BAD ZONE ***'\"\n        \"ISREDIT LINE_BEFORE\" firstln \"= NOTELINE \" warnmsg\n        zedsmsg = 'CAN''T ADD LINE' firstln\n        zedlmsg = 'ERROR - THE DATA TO ADD ON LINE' firstln 'IS NOT',\n                  'VALID ZONED DECIMAL - BAD ZONE.'\n        Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm   */\n        Exit 12\n      End  /* If Verify(zone */\n      outxtab   = '012345678912345678912345678900'\n      add_xzone = Translate(zone,outxtab,zonedtab)\n      If Verify(zone,'JKLMNOPQR}') <> 0 then ,\n        add_data  = add_data ||  add_xzone       /* concat zone      */\n      Else\n        add_data  = '-' || add_data || add_xzone /* concat zone (neg)*/\n    End  /* If Abbrev('ZONE' */\n    /*****************************************************************/\n    /*   Hexadecimal data                                            */\n    /*****************************************************************/\n    If Abbrev('HEXADECIMAL',type,1) <> 0 | ,     /* add              */\n       type = 'X' then do                        /*     hex numbers  */\n      add_data = Translate(add_data,\"\",\"xX'\") /* remove hex notation */\n      add_data = Strip(add_data)              /* remove blanks       */\n      add_data = X2d(add_data)                /* translate to dec.   */\n    End /* If Abbrev('HEXADECIMAL' */\n    /*****************************************************************/\n    /*   Decimal data                                                */\n    /*****************************************************************/\n    total = total + add_data                /* add to prev. total    */\n  End /* of chkexcl */\n  firstln = firstln + 1                     /* bump up line counter  */\nEnd /* do until   */\n/*********************************************************************/\n/*   End column addition loop                                        */\n/*********************************************************************/\nIf not_counted = 0 then do /* all lines counted */\n  endmsg = 'ISRZ000'  /* message - no alarm     */\n  endrc  = 0          /* RC=0                   */\nEnd\nElse do               /* some lines not counted */\n  endmsg = 'ISRZ001'  /* message - with alarm   */\n  endrc  = 4          /* RC=4                   */\nEnd\nIf Abbrev('HEXADECIMAL',type,1) <> 0 | type = 'X' then do\n  zedsmsg = \"Total = x'\"D2x(total)\"'\"\n  zedlmsg = \"Total = x'\"D2x(total)\"' (\"total\" decimal,\" ,\n               \"Avg =\"  Format(total / count,,5) / 1 || \").\" ,\n            count \"lines were counted (\" || ,\n            not_counted \"not counted).\"\n  Address ISPEXEC \"SETMSG MSG(\"|| endmsg ||\")\"\n  Exit endrc\nEnd /* If abbrev */\nElse do\n  total   = total / 1   /* remove trailing zeros  */\n  zedsmsg = \"Total =\" total\n  If total >= 0 & total <  999999999999999 & ,\n     total=Trunc(total,0) then ,\n    zedlmsg = \"Total =\" total \"(x'\"D2x(total)\"' hex),\" ,\n               \"Avg =\" Format(total / count,,5) / 1 || \".\" ,\n               count \"lines were counted (\" || ,\n               not_counted \"not counted).\"\n  Else ,\n    zedlmsg = \"Total =\" total \"(hex not available),\" ,\n               \"Avg =\" Format(total / count,,5) / 1 || \".\" ,\n               count \"lines were counted (\" || ,\n               not_counted \"not counted).\"\n  Address ISPEXEC \"SETMSG MSG(\"|| endmsg ||\")\"\n  Exit endrc\nEnd /* else do */\n/*********************************/\n/*  HELP SUB-ROUTINES            */\n/*********************************/\nHELP_INCL:\nReturn SIGL\nHELP_NOTELINES:\n\"(helpln) = DISPLAY_LINES\"\nDo hlp = help_end-1 to help_start+1 by -1\n  hline = Sourceline(hlp)\n  \"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline)\"\nEnd\nhline2 = '==================='\nhline3 = '===   H E L P   ==='\n\"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline2)\"\n\"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline3)\"\n\"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline2)\"\nReturn\n/*********************************/\n/*  Sub-routine to find labels   */\n/*********************************/\nFIND_LABELS:\nAddress ISPEXEC \"CONTROL ERRORS RETURN\"\nIf label1 = '' then do\n  firstln  = 1\n  \"(lastln) = LINENUM .ZLAST\"\nEnd\nElse do\n  If label2 = '' then label2 = label1\n  \"(firstsv)  = LINENUM\" label1\n  If RC >= 8 then do\n    zedsmsg = 'RANGE LABEL ERROR'\n    zedlmsg = 'THE SPECIFIED RANGE LABEL \"' || label1 '\" WAS',\n              'NOT FOUND'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\n  \"(lastsv)   = LINENUM\" label2\n  If RC >= 8 then do\n    zedsmsg = 'RANGE LABEL ERROR'\n    zedlmsg = 'THE SPECIFIED RANGE LABEL \"' || label2 '\" WAS',\n              'NOT FOUND'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\n  firstln = Min(firstsv,lastsv)\n  lastln  = Max(firstsv,lastsv)\nAddress ISPEXEC \"CONTROL ERRORS\"\nEnd /* else do */\nReturn\n/*********************************/\n/*  error sub-routine            */\n/*********************************/\nSYNTAX:\nwarnmsg = \"'*** ERROR - NEXT LINE HAS BAD DATA ***'\"\n\"ISREDIT LINE_BEFORE\" firstln \"= NOTELINE \" warnmsg\nzedsmsg = 'CAN''T ADD LINE' firstln\nzedlmsg = 'ERROR - THE DATA TO ADD ON LINE' firstln 'IS NOT',\n          'VALID FOR THE ADDITION TYPE.'\nAddress ISPEXEC \"SETMSG MSG(ISRZ001)\"    /* msg - with alarm */\nExit 12\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COLUTIL": {"ttr": 2565, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x992/\\x01\\x13(\\x0f\\x14\\x15\\x01\\xd3\\x01Y\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf7@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "2013-10-07T14:15:00", "lines": 467, "newlines": 345, "modlines": 0, "user": "CBT487"}, "text": "/* REXX */\n/*                           */\n/* AUTHOR: Mark Zelden       */\n/*                           */\n/* Last Updated 10/07/2013   */\n/*                           */\nhelp_start = HELP_INCL()\n/***************************************************************/\n/*                                                             */\n/* THIS EDIT MACRO CAN PERFORM 3 DIFFERENT FUNCTIONS:          */\n/*                                                             */\n/*    A)  MOVE, COPY or SWAP data from one range of            */\n/*        columns to another (default is MOVE).                */\n/*        Excluded lines are always omitted.                   */\n/*                                                             */\n/*    B)  SHIFT data LEFT or RIGHT a specified                 */\n/*        number of columns - same as the \"((\" or \"))\" ISPF    */\n/*        editor line commands.                                */\n/*        Excluded lines are always omitted.                   */\n/*                                                             */\n/*    C)  CUT (copy) data from specific columns into the       */\n/*        ISPF Default Clipboard. This data can then be        */\n/*        used with PASTE later on.                            */\n/*        Excluded lines are always omitted.                   */\n/*                                                             */\n/***************************************************************/\n/* COMMAND SYNTAX:                                             */\n/*                                                             */\n/*   COLUTIL  or  COLUTIL ?   - displays help                  */\n/*                                                             */\n/* MOVE FORMAT:                                                */\n/*                                                             */\n/*   COLUTIL begcol endcol tgtcol (MOVE) (.label1) (.label2)   */\n/*                                                             */\n/* COPY FORMAT:                                                */\n/*                                                             */\n/*   COLUTIL begcol endcol tgtcol COPY  (.label1) (.label2)    */\n/*                                                             */\n/* SWAP FORMAT:                                                */\n/*                                                             */\n/*   COLUTIL begcol endcol tgtcol SWAP  (.label1) (.label2)    */\n/*                                                             */\n/* SHIFT FORMAT:                                               */\n/*                                                             */\n/*   COLUTIL <LEFT | RIGHT> amount (.label1) (.label2)         */\n/*                                                             */\n/* CUT FORMAT:                                                 */\n/*                                                             */\n/*   COLUTIL CUT begcol endcol (.label1) (.label2)             */\n/*                                                             */\n/***************************************************************/\n/* USAGE NOTES:                                                */\n/*                                                             */\n/*  ** NOTE 1: If you execute COLUTIL with no parms or with    */\n/*             a parm of \"?\", the comment section of this      */\n/*             code with syntax and usage notes will be        */\n/*             displayed as \"help\" note lines.  Use the        */\n/*             \"RESET\" command to remove them.                 */\n/*                                                             */\n/*  ** NOTE 2: If using line range labels for a MOVE           */\n/*             operation -  \"MOVE\" must be specified           */\n/*             as the 4th positional parameter.                */\n/*                                                             */\n/*  ** NOTE 3: COPY, MOVE, SWAP, LEFT, RIGHT and CUT can all   */\n/*             be abbreviated by using one or more of their    */\n/*             characters.                                     */\n/*                                                             */\n/*  ** NOTE 4: Excluded lines are ALWAYS omitted.              */\n/*                                                             */\n/*  ** NOTE 5: On a SWAP operation, the length of the          */\n/*             endcol-begcol determines to number of           */\n/*             columns swapped starting with the tgtcol.       */\n/*             For example, \"COLUTIL 10 15 20 SWAP\" will       */\n/*             swap columns 10-15 with 20-25.                  */\n/*                                                             */\n/*  ** NOTE 6: On a SWAP operation, if there are overlapping   */\n/*             columns, for example: \"COLUTIL 10 20 15 SWAP\",  */\n/*             columns 15-25 will replace 10-20, then          */\n/*             the original data from columns 10-20 will       */\n/*             replace columns 15-25.                          */\n/*                                                             */\n/*  ** NOTE 7: On a CUT operation, if you have any existing    */\n/*             data in the ISPF default clipboard, it will     */\n/*             be overlaid.                                    */\n/*                                                             */\n/*  ** NOTE 8: On a CUT operation, ISPF considers the data     */\n/*             changed due to the way the edit macro works.    */\n/*             You must use \"CANCEL\" if you don't want the     */\n/*             data in your edit session saved, although it    */\n/*             is the same data as it was prior to the CUT.    */\n/*                                                             */\n/***************************************************************/\n/*  MOVE EXAMPLES:                                             */\n/*         COLUTIL 10 20 30                                    */\n/*         COLUTIL 45 55 10 M                                  */\n/*         COLUTIL 45 55 10 MOVE                               */\n/*         COLUTIL 45 55 10 MOVE .A .B                         */\n/*                                                             */\n/*  COPY EXAMPLES:                                             */\n/*         COLUTIL 10 15 20 C                                  */\n/*         COLUTIL 10 15 20 COPY                               */\n/*         COLUTIL 45 50 15 COPY .A .B                         */\n/*                                                             */\n/*  SWAP EXAMPLES:                                             */\n/*         COLUTIL 20 25 50 S                                  */\n/*         COLUTIL 40 45 10 SWAP                               */\n/*         COLUTIL 45 50 15 SWAP .A .B                         */\n/*                                                             */\n/*  SHIFT EXAMPLES:                                            */\n/*         COLUTIL R 4                                         */\n/*         COLUTIL L 6                                         */\n/*         COLUTIL RIGHT 10                                    */\n/*         COLUTIL RIGHT 10 .A .B                              */\n/*         COLUTIL LEFT 12                                     */\n/*         COLUTIL LEFT 25  .A .B                              */\n/*                                                             */\n/*  CUT EXAMPLES:                                              */\n/*         COLUTIL C 10 15                                     */\n/*         COLUTIL CUT 68 68                                   */\n/*         COLUTIL CUT 30 40 .A .B                             */\n/*                                                             */\n/***************************************************************/\nhelp_end = HELP_INCL()\n/* TRACE ?R */\nAddress ISREDIT\n\"MACRO (begcol endcol tgtcol type label1 label2)\"\n /* Address ISPEXEC \"CONTROL ERRORS RETURN\"  */\n/***********************************************/\n/*   VERIFY INPUT PARAMETERS                   */\n/***********************************************/\nbegcol = Translate(begcol) /* chage to upper case if alpha */\n\"(width) = DATA_WIDTH \"    /* length of line       */\nwidth    = Format(width)   /* remove leading zeros */\nshiftop  = 'NO'            /* shift operation flag */\ncutop    = 'NO'            /* cut operation flag   */\nIf begcol = '?' then do\n  Call HELP_NOTELINES\n  Exit 1  /* return cursor to command line */\nEnd\nIf begcol = '' then do\n  zedsmsg = 'MISSING PARAMETER'\n  zedlmsg = '\"CUT\" OR A SHIFT TYPE OR A BEGINNING COLUMN NUMBER',\n            'MUST BE SPECIFIED.'\n  Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n  Call HELP_NOTELINES\n  Exit 4\nEnd\nSelect\n  When Datatype(begcol,Number) = 1 & endcol = '' then do\n    zedsmsg = 'NO ENDING COLUMN'\n    zedlmsg = 'AN ENDING COLUMN FOR THE',\n              'OPERATION MUST BE SPECIFIED.'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End /* when */\n  When Datatype(begcol,Number) =1 & Datatype(endcol,Number) <>1 then do\n    zedsmsg = 'END COLUMN NOT NUMERIC'\n    zedlmsg = 'THE ENDING COLUMN FOR THE',\n              'OPERATION MUST BE NUMERIC.'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End /* when */\n  When Datatype(begcol,Number) =1 & Datatype(endcol,Number) =1 then do\n    If endcol < begcol then do\n      zedsmsg = 'END COL < START COL'\n      zedlmsg = 'THE ENDING COLUMN MUST BE GREATER THAN OR',\n                'EQUAL TO THE STARTING COLUMN.'\n      Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n      Exit 12\n    End\n    If tgtcol <> '' then do\n      If Datatype(tgtcol,Number) <> 1 then do\n        zedsmsg = 'TARGET COL NOT NUMERIC'\n        zedlmsg = 'THE TARGET COLUMN FOR THE',\n                  'OPERATION MUST BE NUMERIC.'\n        Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n        Exit 12\n      End\n    End\n    If tgtcol = '' then do\n      zedsmsg = 'NO TARGET COLUMN'\n      zedlmsg = 'YOU MUST SPECIFY A TARGET COLUMN',\n                'FOR THE OPERATION.'\n      Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n      Exit 12\n    End\n    If type = '' then type = 'MOVE'\n    else do\n      type = Translate(type)  /* change to upper case */\n      If Abbrev('MOVE',type,1) = 0 & ,\n         Abbrev('COPY',type,1) = 0 & ,\n         Abbrev('SWAP',type,1) = 0 then do\n        zedsmsg = 'INVALID OPERATION'\n        zedlmsg = 'OPERATION MUST BE \"MOVE\", \"COPY\", OR \"SWAP\".'\n        Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n        Exit 12\n      End\n    End /* else do */\n    If begcol < 1 | endcol < 1 | tgtcol < 1 then do\n      zedsmsg = 'INVALID COLUMN NUMBER'\n      zedlmsg = 'ALL COLUMN SPECIFICATIONS MUST BE' ,\n                'BETWEEN 1 AND' width\n      Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n      Exit 12\n    End\n    If begcol > width | endcol > width | tgtcol > width then do\n      zedsmsg = 'INVALID COLUMN NUMBER'\n      zedlmsg = 'ALL COLUMN SPECIFICATIONS MUST BE' ,\n                'BETWEEN 1 AND' width\n      Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n      Exit 12\n    End\n    If begcol =  tgtcol then do\n      zedsmsg = 'NO ACTION TAKEN'\n      zedlmsg = 'THE STARTING COLUMN AND TARGET COLUMN',\n                'CAN NOT BE THE SAME.'\n      Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n      Exit 12\n    End\n  End /* when */\n  Otherwise    /* shift or cut options being used */\n    If Abbrev('CUT',begcol,1) = 0 & ,\n       Abbrev('LEFT',begcol,1) = 0 & ,\n       Abbrev('RIGHT',begcol,1) = 0 then do\n      zedsmsg = 'INVALID OPTION'\n      zedlmsg = '\"CUT\" OR A SHIFT DIRECTION OF \"LEFT\" OR \"RIGHT\"',\n                'MUST BE SPECIFIED'\n      Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n      Exit 12\n    End\n    If (Abbrev('LEFT',begcol,1) <> 0 | ,\n        Abbrev('RIGHT',begcol,1) <> 0 ) & ,\n        endcol = '' then do\n      zedsmsg = 'NO SHIFT AMOUNT'\n      zedlmsg = 'A SHIFT AMOUNT FOR THE',\n                'OPERATION MUST BE SPECIFIED.'\n      Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n      Exit 12\n    End\n    If  Abbrev('CUT',begcol,1) <> 0 & ,\n        endcol = '' then do\n      zedsmsg = 'NO STARTING COLUMN'\n      zedlmsg = 'A STARTING COLUMN FOR THE CUT',\n                'OPERATION MUST BE SPECIFIED.'\n      Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n      Exit 12\n    End\n    If  Abbrev('CUT',begcol,1) <> 0 & ,\n        tgtcol = '' then do\n      zedsmsg = 'NO ENDING COLUMN'\n      zedlmsg = 'AN ENDING COLUMN FOR THE CUT',\n                'OPERATION MUST BE SPECIFIED.'\n      Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n      Exit 12\n    End\n    Else do\n      If Abbrev('CUT',begcol,1) <> 0 then cutop = 'YES'\n         else shiftop = 'YES'\n      If Datatype(endcol,Number) <> 1 & shiftop = 'YES' then do\n        zedsmsg = 'SHIFT AMOUNT NOT NUMERIC'\n        zedlmsg = 'THE SHIFT AMOUNT SPECIFIED FOR THE',\n                  'OPERATION MUST BE NUMERIC.'\n        Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n        Exit 12\n      End\n      If (endcol > width - 1  | endcol < 1) & shiftop = 'YES' then do\n        zedsmsg = 'INVALID SHIFT AMOUNT'\n        zedlmsg = 'THE SHIFT AMOUNT SPECIFIED MUST',\n                  'BE BETWEEN 1 AND' width - 1 || '.'\n        Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n        Exit 12\n      End\n      If Datatype(endcol,Number) <> 1 & cutop = 'YES' then do\n        zedsmsg = 'START COLUMN NOT NUMERIC'\n        zedlmsg = 'THE STARTING COLUMN SPECIFIED FOR THE',\n                  'CUT OPERATION MUST BE NUMERIC.'\n        Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n        Exit 12\n      End\n      If ((endcol > width  | endcol < 1) | ,\n         (tgtcol > width  | tgtcol < 1)) & ,\n            cutop = 'YES' then do\n        zedsmsg = 'INVALID CUT COLUMNS'\n        zedlmsg = 'THE CUT COLUMNS SPECIFIED MUST',\n                  'BE BETWEEN 1 AND' width || '.'\n        Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n        Exit 12\n      End\n      If tgtcol < endcol & cutop = 'YES' then do\n        zedsmsg = 'END COL < START COL'\n        zedlmsg = 'THE ENDING COLUMN MUST BE GREATER THAN OR',\n                  'EQUAL TO THE STARTING COLUMN.'\n        Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n        Exit 12\n      End\n    End  /* else do */\nEnd /* select */\n/***********************************************/\n/*   SHIFT PROCESSING SETUP                    */\n/***********************************************/\nIf shiftop = 'YES' then do\n  label1   = tgtcol\n  label2   = type\n  shiftamt = endcol\n  type     = 'MOVE'  /* shift is really a MOVE operation    */\n  If Abbrev('LEFT',begcol,1) <> 0 then do /* left shift */\n    shifttyp = 'LEFT'\n    begcol   = shiftamt + 1\n    endcol   = width\n    tgtcol   = 1\n  End\n  Else do /* right shift */\n    shifttyp = 'RIGHT'\n    begcol   = 1\n    endcol   = width\n    tgtcol   = shiftamt + 1\n  End\nEnd  /* if shiftop = 'YES' */\n/***********************************************/\n/*   CUT PROCESSING SETUP                      */\n/***********************************************/\nIf cutop   = 'YES' then do\n  label2   = label1\n  label1   = type\n  begcol   = endcol\n  endcol   = tgtcol\n  crpl1st  = 'YES'   /* \"1st cut\" flag to do \"CUT REPLACE\" */\n \"(saveln) = DISPLAY_LINES\"\nEnd  /* if cutop = 'YES' */\n/***********************************************/\n/*   FIND OUT IF LABELS ARE BEING USED         */\n/***********************************************/\nCall FIND_LABELS\n/***************************************************/\n/* INITIALIZE VARIABLES NEEDED IN PROCESSING LOOP  */\n/***************************************************/\ncount    = 0                 /* count of processed lines  */\ntgtlen   =  endcol-begcol+1  /* length of operation       */\n/***********************************************/\n/*   BEGIN COLUMN PROCESSING LOOP              */\n/***********************************************/\nDo until lastln = firstln-1\n  /* copy the data in the current line to variable 'data1' */\n  \"(data1) = LINE \"firstln\n  \"ISREDIT (chkexcl) = XSTATUS\" firstln\n  If chkexcl = \"NX\" then do\n    count = count + 1\n    If cutop <> 'YES' then do   /* move/copy/swap/shift operation     */\n      tgtdata = Substr(data1,begcol,tgtlen)\n      If shiftop = 'YES' & shifttyp = 'LEFT' then ,  /* clr for left  */\n         data1 = Overlay(' ',data1,width-shiftamt,shiftamt+1) /*shift */\n      If Abbrev('MOVE',type,1) <> 0 then ,          /* clear data for */\n         data1 = Overlay(' ',data1,begcol,tgtlen)   /* column MOVE    */\n      If Abbrev('SWAP',type,1) <> 0 then do         /* SWAP           */\n         data2 = Substr(data1,tgtcol,tgtlen)        /*   the          */\n         data1 = Overlay(data2,data1,begcol,tgtlen) /*     data       */\n      End\n      data1 = Overlay(tgtdata,data1,tgtcol,tgtlen)  /* COPY data      */\n    End  /* if cutop <> 'YES' */\n    Else do /* cut operation */\n      If begcol = 1 then data2 = data1\n        Else data2 = Overlay(' ',data1,1,begcol-1)\n      data3 = Overlay(' ',data2,endcol+1,width-endcol) /* data for cut */\n     \"LINE\" firstln \"= (data3)\"\n      If crpl1st  = 'YES' then do /* first cut -  replace clipboard */\n        \"CURSOR = \" firstln 1\n        \"ISREDIT CUT .ZCSR .ZCSR REPLACE\"\n        crpl1st  = 'NO'      /* reset \"1st cut\" flag */\n      End\n      Else do\n        \"CURSOR = \" firstln 1\n        \"ISREDIT CUT .ZCSR .ZCSR APPEND\"\n      End\n    End /* else do */\n  End\n  /* copy the modified line back into the current line    */\n  \"LINE\" firstln \"= (data1)\"\n  firstln = firstln + 1\nEnd   /* do until   */\n/***********************************************/\n/*   END COLUMN PROCESSING LOOP                */\n/***********************************************/\nIf cutop = 'YES' then do\n  \"(lastln2) = LINENUM .ZLAST\"\n  \"UP MAX\"\n  If saveln <> 1 then \"DOWN \" saveln  /* don't scroll if at top */\n  zedsmsg = count 'LINES CUT'\n  zedlmsg = count 'LINES WERE CUT FROM COLUMNS' begcol || '-' || ,\n           endcol 'TO THE DEFAULT CLIPBOARD'\n  Address ISPEXEC \"SETMSG MSG(ISRZ000)\"  /* msg - no alarm */\n  Exit 1 /* return cursor to command line */\nEnd\nIf shiftop <> 'YES' then do\n   If Abbrev('MOVE',type,1) <> 0 then msgtype = 'MOVED'\n   If Abbrev('SWAP',type,1) <> 0 then msgtype = 'SWAPPED'\n    else msgtype = 'COPIED'\n   If tgtlen+tgtcol-1 <= width then do  /* no truncation    */\n     zedsmsg = count 'LINES CHANGED'\n     zedlmsg = 'COLUMNS' begcol 'THROUGH' endcol 'ON' count ,\n               'LINES WERE' msgtype 'TO COLUMN' tgtcol || '.'\n     Address ISPEXEC \"SETMSG MSG(ISRZ000)\"  /* msg - no alarm */\n     Exit 1  /* return cursor to command line */\n   End\n   Else do\n     zedsmsg = count 'LINES TRUNCATED'\n     zedlmsg = 'COLUMNS' begcol 'THROUGH' endcol 'ON' count ,\n               'LINES WERE' msgtype 'TO COLUMN' tgtcol 'AND TRUNCATED.'\n     Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n     Exit 4\n   End\nEnd\nElse do /* total messages for shift */\n  zedsmsg = count 'LINES SHIFTED'\n  zedlmsg = count 'LINES WERE SHIFTED' shiftamt 'COLUMNS' ,\n           'TO THE' shifttyp || '.'\n  Address ISPEXEC \"SETMSG MSG(ISRZ000)\"  /* msg - no alarm */\n  Exit 1  /* return cursor to command line */\nEnd\n/*********************************/\n/*  HELP SUB-ROUTINES            */\n/*********************************/\nHELP_INCL:\nReturn SIGL\nHELP_NOTELINES:\n\"(helpln) = DISPLAY_LINES\"\nDo hlp = help_end-1 to help_start+1 by -1\n  hline = Sourceline(hlp)\n  \"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline)\"\nEnd\nhline2 = '==================='\nhline3 = '===   H E L P   ==='\n\"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline2)\"\n\"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline3)\"\n\"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline2)\"\nReturn\n/*********************************/\n/*  SUB-ROUTINE TO FIND LABELS   */\n/*********************************/\nFIND_LABELS:\nAddress ISPEXEC \"CONTROL ERRORS RETURN\"\nIf label1 = '' then do\n  firstln  = 1\n  \"(lastln) = LINENUM .ZLAST\"\nEnd\nElse do\n  If label2 = '' then label2 = label1\n  \"(firstsv)  = LINENUM\" label1\n  If RC >= 8 then do\n    zedsmsg = 'RANGE LABEL ERROR'\n    zedlmsg = 'THE SPECIFIED RANGE LABEL \"' || label1 '\" WAS',\n              'NOT FOUND'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\n  \"(lastsv)   = LINENUM\" label2\n  If RC >= 8 then do\n    zedsmsg = 'RANGE LABEL ERROR'\n    zedlmsg = 'THE SPECIFIED RANGE LABEL \"' || label2 '\" WAS',\n              'NOT FOUND'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\n  firstln = Min(firstsv,lastsv)\n  lastln  = Max(firstsv,lastsv)\nAddress ISPEXEC \"CONTROL ERRORS\"\nEnd /* else do */\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DB": {"ttr": 2819, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00F\\x00\\x992/\\x00\\x992/\\x16'\\x00$\\x00$\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf2\\xf2@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "1999-11-18T16:27:46", "lines": 36, "newlines": 36, "modlines": 0, "user": "CBT422"}, "text": "/* REXX */\n/*                                       */\n/* AUTHOR: Mark Zelden                   */\n/*                                       */\n/* TRACE ?R */\nAddress ISREDIT\n\"MACRO\"\n /* Address ISPEXEC \"CONTROL ERRORS RETURN\"  */\n /*                                                    */\n /* This edit macro will delete all lines from the     */\n /* line the cursor is on to the bottom line.          */\n /*                                                    */\n  /***********************************************/\n  /*   BEGIN DB PROCESSING                       */\n  /***********************************************/\n  \"ISREDIT (row,col) = CURSOR\"\n  \"(lastln) = LINENUM .ZLAST\"     /* last data line       */\n  If row  = lastln then do\n    zedsmsg = 'NEED AT LEAST 2 LINES'\n    zedlmsg = 'YOU MUST DELETE AT LEAST 2 LINES IN THE FILE',\n              'TO EXECUTE THE DB EDIT MACRO.'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\n  \"ISREDIT LABEL \" row \"= .FROM\"\n  \"ISREDIT LABEL \" lastln \"= .TO\"\n  \"DELETE ALL .FROM .TO\"  /* delete labeled lines */\n  /***********************************************/\n  /*   END DB PROCESSING                         */\n  /***********************************************/\n  count = lastln - row + 1\n  zedsmsg = count 'LINES DELETED'\n  zedlmsg = count 'LINES WERE DELETED FROM THE CURSOR LINE' ,\n                  'TO THE BOTTOM LINE.'\n  Address ISPEXEC \"SETMSG MSG(ISRZ000)\"  /* msg - no alarm */\n  Exit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DELDUPS": {"ttr": 2821, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x992/\\x01\\x16#O\\x160\\x01F\\x00t\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf9\\xf2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "2016-08-21T16:30:00", "lines": 326, "newlines": 116, "modlines": 0, "user": "CBT492"}, "text": "/* REXX */\n/*                           */\n/* AUTHOR: Mark Zelden       */\n/*                           */\n/*   Label checking code     */\n/*   contribution from:      */\n/*     Sean M. Smith         */\n/*                           */\n/* Last Updated 08/21/2016   */\n/* (added showdups option)   */\n/*                           */\nhelp_start = HELP_INCL()\n/********************************************************************/\n/* This edit macro will sort a file and delete the duplicate lines  */\n/* from it.                                                         */\n/*                                                                  */\n/* The duplicate search can optionally be limited to specific       */\n/* columns and/or lines by using labels.                            */\n/*                                                                  */\n/* An optional parameter of \"Showdups\" may be specified and all     */\n/* the duplicate lines will be shown instead of being deleted. You  */\n/* may wish to use the \"hide excluded\" command after using the      */\n/* Showdups option so you don't see the \"n Line(s) not Displayed\"   */\n/* messages after execution. To see the lines again you would use   */\n/* the \"reset hide\" command. If you would like to see what would    */\n/* be the remaining lines from an actual DELDUPS execution without  */\n/* \"Showdups\" specified, use the \"FLIP\" command after execution     */\n/* with the Showdups option.  The \"Showdups\" option may be          */\n/* appreviated by using one or more of its characters.              */\n/*                                                                  */\n/* The file must be sorted first in order to delete the duplicate   */\n/* lines and is sorted using the \"begcol\" and \"endcol\" for all      */\n/* lines or only the lines that are within the label range used.    */\n/* This sorting is still required when using the \"Showdups\"         */\n/* option even though no lines are actually deleted.                */\n/*                                                                  */\n/* NOTE: The Showdups option requires z/OS 1.6 (ISPF 5.6) or above. */\n/*                                                                  */\n/********************************************************************/\n/* Command syntax:                                                  */\n/*                                                                  */\n/*   DELDUPS (begcol) (endcol) (.label1) .label2) (Showdups)        */\n/*                                                                  */\n/*                   - OR -                                         */\n/*                                                                  */\n/*   DELDUPS (.label1) .label2) (begcol) (endcol) (Showdups)        */\n/*                                                                  */\n/*  ** The Showdups option requires z/OS 1.6 (ISPF 5.6) or above.   */\n/*                                                                  */\n/*                                                                  */\n/*   ** NOTE:   If you execute DELDUPS with a parm of '?' the       */\n/*      the comment secion of this code with syntax and usage       */\n/*      examples will be displayed as \"HELP\" note lines.  Use       */\n/*      the \"RESET\" command to remove them.                         */\n/*                                                                  */\n/*                                                                  */\n/********************************************************************/\n/* Execution examples:                                              */\n/*                                                                  */\n/*   DELDUPS                                                        */\n/*   DELDUPS show                                                   */\n/*   DELDUPS s                                                      */\n/*   DELDUPS 10 15                                                  */\n/*   DELDUPS 10 15 Showdups                                         */\n/*   DELDUPS .from .to                                              */\n/*   DELDUPS .from .to s                                            */\n/*   DELDUPS 43 57 .here .there                                     */\n/*   DELDUPS 43 57 .here .there Show                                */\n/*   DELDUPS .to .from 43 57                                        */\n/*   DELDUPS .to .from 43 57 show                                   */\n/*                                                                  */\n/********************************************************************/\nhelp_end = HELP_INCL()\n/*****************************************************/\n/* To help performance, this macro uses the exclude  */\n/* command and a \"DELETE ALL X\" command, which is    */\n/* much quicker than individual line deletes.        */\n/*****************************************************/\n/* Trace ?R */\nAddress ISREDIT\n\"MACRO (var1 var2 var3 var4 var5)\"\n\nIf var1 = '?' then do\n  Call HELP_NOTELINES\n  Exit 1  /* return cursor to command line */\nEnd\n/******************************************************/\n/* Check for Showdups option - if found set the usage */\n/* flag and remove the parm before processing the     */\n/* column and label options.                          */\n/******************************************************/\nshowopt='no'\nallparms = Translate(var1 var2 var3 var4 var5)\nshowchk  = Pos('S',allparms)\nIf showchk <> 0 then do                /* showdups option ?       */\n  show_word = Substr(allparms,showchk) /* opt actually specified  */\n  show_wpos = Wordpos(show_word,allparms) /* which parm was it?   */\n  If Abbrev('SHOWDUPS',Strip(show_word)) = 0 then do /* bad abbr. */\n    zedsmsg = 'Invalid parameter'\n    zedlmsg = 'Invalid parameter or option specified. Please',\n              'check your execution parameters.'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"     /* msg - with alarm */\n    Call HELP_NOTELINES\n    Exit 12\n  End\n  Else showopt = 'yes'                 /* set usage flag to 'yes' */\n  If show_wpos = 1 then do             /* show was 1st parm       */\n    If var2 <> '' then do              /* any other parms invalid */\n      zedsmsg = 'Invalid parameter'\n      zedlmsg = 'Invalid parameter or option specified. Please',\n                'check your execution parameters.'\n      Address ISPEXEC \"SETMSG MSG(ISRZ001)\"   /* msg - with alarm */\n      Call HELP_NOTELINES\n      Exit 12\n    End\n    Else var1 = ''                     /* remove show parm before */\n  End                                  /*  doing col/lbl checks   */\n  If show_wpos = 3 then do             /* show was 3rd parm       */\n    If var4 <> '' then do              /* any other parms invalid */\n      zedsmsg = 'Invalid parameter'\n      zedlmsg = 'Invalid parameter or option specified. Please',\n                'check your execution parameters.'\n      Address ISPEXEC \"SETMSG MSG(ISRZ001)\"   /* msg - with alarm */\n      Call HELP_NOTELINES\n      Exit 12\n    End\n    Else var3 = ''                     /* remove show parm before */\n  End                                  /*  doing col/lbl checks   */\nEnd\nIf showopt = 'yes' then do             /* show option was used    */\n  Address ISPEXEC \"VGET ZENVIR\"        /* get ispf version        */\n  If Substr(ZENVIR,6,3) < 5.5 then do  /* below 5.5 has no \"FLIP\" */\n    zedsmsg = 'Showdups not allowed'\n    zedlmsg = 'You need z/OS 1.6 (ISPF 5.6)',\n              'or above to use the Showdups option.'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"     /* msg - with alarm */\n    Exit 12\n  End\nEnd\n/*****************************************/\n/* Code below allows either columns      */\n/* and/or labels to be specified in      */\n/* either order.                         */\n/*****************************************/\ncol1 = ''\ncol2 = ''\nlbl1 = ''\nlbl2 = ''\nIf var1 <> '' then do\n  If pos('.',var1) > 0 then lbl1 = var1\n    Else col1 = var1\nEnd\nIf var2 <> '' then do\n  If pos('.',var2) > 0 then lbl2= var2\n    Else col2 = var2\nEnd\nIf var3 <> '' then do\n  If pos('.',var3) > 0 then lbl1= var3\n    Else col1 = var3\nEnd\nIf var4 <> '' then do\n  If pos('.',var4) > 0 then lbl2= var4\n    Else col2 = var4\nEnd\n/*****************************************/\nAddress ISPEXEC \"CONTROL ERRORS RETURN\"\n  /****************************/\n  /* Validate parms           */\n  /****************************/\n  If col1 <> '' then do\n    If Datatype(col1,Number) <> 1 then do\n      zedsmsg = 'Invalid parameter'\n      zedlmsg = 'Invalid parameter or option specified. Please',\n                'check your execution parameters.'\n      Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n      Call HELP_NOTELINES\n      Exit 12\n    End\n    \"(chkwidth) = DATA_WIDTH\"\n    If col1 > chkwidth | col1 < 1 then do\n      zedsmsg = 'Invalid start column'\n      zedlmsg = 'The start column must be between 1 and the',\n                'data width (1-'Format(chkwidth)').'\n      Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n      Exit 12\n    End\n    If col2 = '' then do\n      zedsmsg = 'No ending column'\n      zedlmsg = 'An ending column for the',\n                'duplicate search must be specified.'\n      Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n      Exit 12\n    End\n  End\n  Else col1 = 1  /* default starting column for duplicate search */\n  If col2 <> '' then do\n    If Datatype(col2,Number) <> 1 then do\n      zedsmsg = 'End column not numeric'\n      zedlmsg = 'The ending column for the',\n                'duplicate search must be numeric.'\n      Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n      Exit 12\n    End\n    If col2 < col1 | col2 > chkwidth then do\n      zedsmsg = 'Invalid end column'\n      zedlmsg = 'The end column must be between the start column',\n                'and the data width ('col1'-'Format(chkwidth)').'\n      Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n      Exit 12\n    End\n  End\n  Else \"(col2) = DATA_WIDTH\"   /* default end col for dup search */\n\n  /****************************************************/\n  /* Additional parm validation and some housekeeping */\n  /****************************************************/\n\n  If lbl1 <> '' & lbl2 = '' then do\n    zedsmsg = 'No ending label'\n    zedlmsg = 'An ending label fro the',\n              'duplicate search must be specified.'\n      Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\n\n  If lbl1 = '' then lbl1 = '.ZFIRST'\n  If lbl2 = '' then lbl2 = '.ZLAST'\n\n  \"(status)  = USER_STATE\"     /* save current bounds    */\n  \"(firstln) = LINENUM\" lbl1   /* first data line        */\n  \"(lastln)  = LINENUM\" lbl2   /* last data line         */\n  If firstln = 0 then do\n    zedsmsg = 'Invalid label:' lbl1\n    zedlmsg = 'The starting label must be defined.'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\n  If lastln = 0 then do\n    zedsmsg = 'Invalid label:' lbl2\n    zedlmsg = 'The ending label must be defined.'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\n  If lastln < firstln then do  /* 2nd label specified    */\n    firstln_sv = firstln       /*   before 1st label     */\n    firstln    = lastln        /*   so line numbers      */\n    lastln     = firstln_sv    /*   need to be swapped   */\n  End\n  If lastln - firstln < 1  then do\n    zedsmsg = 'Need at least 2 lines'\n    zedlmsg = 'There must be at least 2 lines in the file',\n              'or label range to use DELDUPS.'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    EXIT 12\n  End\n  delcount = 0                 /* count of deleted lines */\n  currln   = firstln           /* current line number    */\n  \"BOUNDS\"                     /* reset bounds           */\n  \"RESET EXCLUDED\"             /* reset exclude status   */\n  \"SORT \" col1 col2 lbl1 lbl2  /* sort on key columns    */\n\n  /***********************************/\n  /* Begin search for duplicates.    */\n  /***********************************/\n  Do while currln < lastln\n    \"(data1) = LINE \"currln    /* data1 = current line   */\n    data1 =  Substr(data1,col1,col2-col1+1)\n    nextln = currln + 1\n    \"(data2) = LINE \"nextln    /* data2 = next line      */\n    data2 =  Substr(data2,col1,col2-col1+1)\n    If data1 == data2 then do\n      \"ISREDIT XSTATUS \"nextln\" = X\" /* match, excl line */\n      delcount = delcount + 1\n      currln = currln + 1\n    End\n    Else  currln = currln + 1  /* no dup found - loop    */\n  End   /* do while */\n  /***********************************/\n  /* End search for duplicates.      */\n  /***********************************/\n  If showopt = 'no' then ,\n    \"DELETE ALL EXCLUDED\" /* search done - delete all excluded lines */\n  Else \"FLIP\"             /* don't delete, just SHOWdups             */\n    \"(lastln) = LINENUM .ZLAST\"      /* last data line               */\n  /*******************************************************************/\n    \"UP MAX\"                 /* move display to 1st line */\n    \"USER_STATE = (status)\"  /* restore saved bounds     */\n    Address ISPEXEC\n    If delcount = 0 then do\n      zedsmsg = 'No duplicate lines!'\n      zedlmsg = 'No duplicate lines were found in the file!'\n      \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n      Exit 4\n    End\n    Else do\n      lastln = Format(lastln) /* remove leading zeros */\n      If showopt = 'no' then do\n        zedsmsg = delcount 'lines deleted'\n        zedlmsg = delcount 'duplicate line(s) were deleted and',\n                  lastln' line(s) were kept in the file.'\n      End\n      Else do\n        zedsmsg = delcount 'dup line(s) shown'\n        zedlmsg = delcount 'duplicate line(s) shown and',\n                  lastln-delcount' non-dup line(s) were' ,\n                  'excluded in the file.'\n      End\n      \"SETMSG MSG(ISRZ000)\"  /* msg - no alarm */\n      Exit 1  /* return cursor to command line */\n    End\n/*********************************/\n/*  HELP SUB-ROUTINES            */\n/*********************************/\nHELP_INCL:\nReturn SIGL\nHELP_NOTELINES:\nDo hlp = help_end-1 to help_start+1 by -1\n  hline = Sourceline(hlp)\n  \"ISREDIT LINE_AFTER 0 = NOTELINE (hline)\"\nEnd\nhline2 = '==================='\nhline3 = '===   H E L P   ==='\n\"ISREDIT LINE_AFTER 0 = NOTELINE (hline2)\"\n\"ISREDIT LINE_AFTER 0 = NOTELINE (hline3)\"\n\"ISREDIT LINE_AFTER 0 = NOTELINE (hline2)\"\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DELDUPS2": {"ttr": 2827, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x992/\\x01\\x05\\t\\x1f\\x11 \\x00\\xc3\\x00\\xc2\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf6\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "2005-04-01T11:20:00", "lines": 195, "newlines": 194, "modlines": 0, "user": "CBT469"}, "text": "/* REXX                                  */\n/*                                       */\n/* AUTHOR: Mark Zelden                   */\n/* Last Updated 04/01/2005               */\n/*                                       */\n/* TRACE ?R */\nArg SORTIN SORTOUT OUTFILE DUPFILE COL1 COL2 EQUALS\n /*                                                           */\n /* This exec will sort a file and delete records that have   */\n /* duplicate characters between user specified columns.      */\n /* It will also write the duplicate records to another file. */\n /*                                                           */\n /* REQUIRED POSITIONAL PARAMETERS: - (do not use quotes)     */\n /*   SORTIN  - input dataset name                            */\n /*   SORTOUT - sorted output dataset with duplicates         */\n /*   OUTFILE - sorted output dataset without duplicates      */\n /*   DUPFILE - sorted output dataset of only duplicates      */\n /*   COL1    - the beginning sort column                     */\n /*   COL2    - the length of the sort                        */\n /*                                                           */\n /* OPTIONAL POSITIONAL PARAMETER: EQUALS                     */\n /*                                                           */\n /* ** NOTE*** ALL FILES MUST BE PRE-ALLOCATED AND HAVE THE   */\n /*            SAME ATTRIBUTES AS THE SORTIN FILE             */\n /*           (SORTIN & SORTOUT CAN BE THE SAME FILE).        */\n /*                                                           */\n /* SAMPLE EXECUTION FROM ISPF OPT 6:                         */\n /*                                                           */\n /* %DELDUPS2  USERID.SORTIN USERID.SORTOUT USERID.OUTFILE    */\n /*  USERID.DUPFILE 4 20                                      */\n /*                                                           */\n /* SAMPLE EXECUTION FROM BATCH:                              */\n /*                                                           */\n /* //MYJOB    JOB (ACCT),CLASS=E,MSGCLASS=H                  */\n /* //TMP      EXEC PGM=IKJEFT01,REGION=2M,DYNAMNBR=20        */\n /* //SYSPROC  DD   DSN=CLIST.LIBRARY,DISP=SHR                */\n /* //SYSTSPRT DD   SYSOUT=*                                  */\n /* //SYSTSIN  DD   DATA,DLM=##                               */\n /*           %DELDUPS2 +                                     */\n /*           USERID.SORTIN  +                                */\n /*           USERID.SORTOUT +                                */\n /*           USERID.OUTFILE +                                */\n /*           USERID.DUPFILE +                                */\n /*           1 9 EQUALS                                      */\n /* ##                                                        */\n /* //                                                        */\n /*                                                           */\n  /* check for numeric column numbers      */\nIf COL1 <> '' then do\n  If Datatype(COL1,Number) <> 1 then do\n    Say '************************************'\n    Say 'THE STARTING COLUMN MUST BE NUMERIC.'\n    Say '************************************'\n    Exit 12\n  End\nEnd\nIf COL2 <> '' then do\n  If Datatype(COL2,Number) <> 1 then do\n    Say '**********************************'\n    Say 'THE ENDING COLUMN MUST BE NUMERIC.'\n    Say '**********************************'\n    Exit 12\n  End\nEnd\nIf SORTIN  = '' then call MISSING_PARMS\nIf SORTOUT = '' then call MISSING_PARMS\nIf OUTFILE = '' then call MISSING_PARMS\nIf DUPFILE = '' then call MISSING_PARMS\nIf COL1    = '' then call MISSING_PARMS\nIf COL2    = '' then call MISSING_PARMS\nIf EQUALS <> '' then do\n  If EQUALS <> 'EQUALS' then call MISSING_PARMS\nEnd\n/***********************************/\n/* Allocate files                  */\n/***********************************/\n\"ALLOC DA('\"SORTIN\"') F(SORTIN) SHR REUSE\"\nIf RC <> 0 then exit 12\n\"ALLOC DA('\"SORTOUT\"') F(SORTOUT) SHR REUSE\"\nIf RC <> 0 then exit 12\n\"ALLOC DA('\"OUTFILE\"') F(OUTFILE) SHR REUSE\"\nIf RC <> 0 then exit 12\n\"ALLOC DA('\"DUPFILE\"') F(DUPFILE) SHR REUSE\"\nIf RC <> 0 then exit 12\n\"ALLOC FILE(SORTWK01) UNIT(SYSDA) NEW CYL SPACE(50,50) DELETE REUSE\"\n\"ALLOC FILE(SORTWK02) UNIT(SYSDA) NEW CYL SPACE(50,50) DELETE REUSE\"\n\"ALLOC FILE(SYSOUT) DUMMY REUSE\"\n\"ALLOC FILE(SYSIN) UNIT(SYSDA) NEW TRACKS SPACE(1,1) DELETE REUSE\",\n\" LRECL(80) RECFM(F) BLKSIZE(80)\"\nIf EQUALS = 'EQUALS' then\n  Push ' SORT FIELDS=('COL1','COL2',CH,A),EQUALS'\nElse\n  Push ' SORT FIELDS=('COL1','COL2',CH,A)'\n\"EXECIO 1 DISKW SYSIN (FINIS\"\n/* Say '...SORTING'  */\nAddress LINKMVS \"SORT\"\nIf RC <> 0 then do\n  Say '*******************************************'\n  Say '*         SORT FAILURE - ABENDING         *'\n  Say '*******************************************'\n  Call FREE_FILES\n  Exit 12\nEnd\n/* Say '...SEARCHING FOR DUPLICATES'  */\n/***********************************/\n/* Begin search for duplicates.    */\n/***********************************/\nCOUNT  = 0   /* count of deleted records */\nKEPT   = 0   /* count of kept records    */\nRECNUM = 1   /* current record number    */\n\"EXECIO\" 1 \"DISKR SORTOUT\" RECNUM\n/* copy the data in the first record to variable 'DATA1' */\nParse pull DATA1\nRECNUM = RECNUM + 1\nPush DATA1\n\"EXECIO 1 DISKW OUTFILE\"\nKEPT = KEPT + 1\nCHECK1 =  Substr(DATA1,COL1,COL2)\nDo forever\n/* copy the data in the next record to variable 'DATA2' */\n  \"EXECIO\" 1 \"DISKR SORTOUT\" RECNUM\n  If rc <> 0 then leave  /* no more records - exit */\n  Parse pull DATA2\n  RECNUM = RECNUM + 1\n  CHECK2 =  Substr(DATA2,COL1,COL2)\n  If CHECK2 == CHECK1 then do\n    /* dup found - write to dupfile & check next record */\n    Push DATA2\n    \"EXECIO 1 DISKW DUPFILE\"\n    COUNT = COUNT + 1\n  End\n  Else do\n    /* no dup found - write to outfile replace DATA1 & check again */\n    Push DATA2\n    \"EXECIO 1 DISKW OUTFILE\"\n    KEPT   = KEPT + 1\n    DATA1  = DATA2\n    CHECK1 = CHECK2\n  End\nEnd   /* do forever */\n/******************************************/\n/* Done with processing - write totals    */\n/******************************************/\nIf COUNT = 0 then do\n  Say '********************************************'\n  Say 'NO DUPLICATE RECORDS WERE FOUND IN THE FILE.'\n  Say '********************************************'\n  Call FREE_FILES\n  Exit 12\nEnd\nElse do\n  TOTAL = COUNT + KEPT\n  Say '**********************************************************'\n  Say TOTAL' RECORDS WERE SEARCHED FOR DUPLICATES.'\n  Say KEPT' DIFFERENT RECORDS WERE WRITTEN TO THE OUTFILE.'\n  Say COUNT' DUPLICATE RECORDS WERE WRITTEN TO THE DUPFILE.'\n  Say '**********************************************************'\n  Call FREE_FILES\n  Exit 0\nEnd\nMISSING_PARMS:\n  Say '*********************************************************'\n  Say '* ALL PARAMETERS WERE NOT ENTERED PROPERLY.             *'\n  Say '*********************************************************'\n  Say '*                                                       *'\n  Say '* REQUIRED POSITIONAL PARAMETERS: - (DO NOT USE QUOTES) *'\n  Say '*                                                       *'\n  Say '* SORTIN  - INPUT DATASET NAME                          *'\n  Say '* SORTOUT - SORTED OUTPUT DATASET WITH DUPLICATES       *'\n  Say '* OUTFILE - SORTED OUTPUT DATASET WITHOUT DUPLICATES    *'\n  Say '* DUPFILE - SORTED OUTPUT DATASET OF ONLY DUPLICATES    *'\n  Say '* COL1    - THE BEGINNING SORT COLUMN                   *'\n  Say '* COL2    - THE LENGTH OF THE SORT                      *'\n  Say '*                                                       *'\n  Say '* OPTIONAL POSITIONAL PARAMETER: EQUALS                 *'\n  Say '*                                                       *'\n  Say '*                                                       *'\n  Say '* >>> NOTE - ALL FILES MUST BE PRE-ALLOCATED AND HAVE   *'\n  Say '*            THE SAME ATTRIBUTES AS THE SORTIN FILE.    *'\n  Say '*            (SORTIN AND SORTOUT CAN BE THE SAME FILE). *'\n  Say '*********************************************************'\n  Exit 12\nFREE_FILES:\n\"EXECIO 0 DISKR SORTOUT (FINIS\"\n\"EXECIO 0 DISKW OUTFILE (FINIS\"\n\"EXECIO 0 DISKW DUPFILE (FINIS\"\n\"FREE F(SORTIN)\"\n\"FREE F(SORTOUT)\"\n\"FREE F(OUTFILE)\"\n\"FREE F(DUPFILE)\"\n\"FREE F(SORTWK01)\"\n\"FREE F(SORTWK02)\"\n\"FREE F(SYSOUT)\"\n\"FREE F(SYSIN)\"\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DELNX": {"ttr": 3074, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x992/\\x01\\x13(\\x0f\\x14\\x15\\x00\\x8b\\x00M\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf7@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "2013-10-07T14:15:00", "lines": 139, "newlines": 77, "modlines": 0, "user": "CBT487"}, "text": "/* REXX */\n/*                           */\n/* AUTHOR: Mark Zelden       */\n/*                           */\n/* Last Updated 10/07/2013   */\n/*                           */\nhelp_start = HELP_INCL()\n/**********************************************************/\n/* This edit macro will delete all lines that contain     */\n/* a specified search string. The search can optionally   */\n/* be limited to specific columns.                        */\n/*                                                        */\n/* EXAMPLES:                                              */\n/*            DELNX UNIT=CART                             */\n/*            DELNX 'SYSOUT=*' 3 16                       */\n/*                                                        */\n/*                                                        */\n/*  ** NOTE    If you execute DELNX with no parms or with */\n/*             a parm of \"?\", the comment section of this */\n/*             code with examples will be displayed as    */\n/*             \"help\" note lines.  Use the \"RESET\"        */\n/*             command to remove them.                    */\n/*                                                        */\n/**********************************************************/\nhelp_end = HELP_INCL()\n/* Trace ?R */\nAddress ISREDIT\n\"MACRO (parm col1 col2)\"\n /* Address ISPEXEC \"CONTROL ERRORS RETURN\"  */\nIf pos('&',parm) <> 0 then do\n  parmx = Translate(parm) /* upper case                  */\n  parmx = C2X(parmx)      /* change to hex for seek/find */\n  amp = 'Y'\nEnd\nIf parm = '?' then do\n  Call HELP_NOTELINES\n  Exit 1  /* return cursor to command line */\nEnd\nIf parm = '' then do\n  zedsmsg = 'NO SEARCH STRING'\n  zedlmsg = 'YOU MUST PASS A SEARCH STRING PARM',\n            'TO DELNX.'\n  Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n  Call HELP_NOTELINES\n  Exit 4\nEnd\n/* check for numeric column numbers      */\nIf col1 <> '' then do\n  If Datatype(col1,Number) <> 1 then do\n    zedsmsg = 'START COLUMN NOT NUMERIC'\n    zedlmsg = 'THE STARTING COLUMN FOR THE',\n              'SEARCH MUST BE NUMERIC.'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\n  If col2 = '' then col2 = col1\nEnd\nIf col2 <> '' then do\n  If Datatype(col2,Number) <> 1 then do\n    zedsmsg = 'END COLUMN NOT NUMERIC'\n    zedlmsg = 'THE ENDING COLUMN FOR THE',\n              'SEARCH MUST BE NUMERIC.'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\n  If col2 < col1 then do\n    zedsmsg = 'END COL < START COL'\n    zedlmsg = 'THE ENDING COLUMN MUST BE GREATER THAN OR',\n              'EQUAL TO THE STARTING COLUMN.'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\n  If Length(Strip(Translate(parm,'','\"'''''))) ,\n    > COL2-COL1+1 then do\n    zedsmsg = 'PARM TOO LONG'\n    zedlmsg = 'THE STRING WILL NOT FIT BETWEEN THE',\n              'SPECIFIED COLUMNS.'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\n  \"(width) = DATA_WIDTH \"   /* length of line       */\n  width = Format(width)     /* remove leading zeros */\n  If col1 < 1 | col2 < 1 | col1 > width | col2 > width then do\n    zedsmsg = 'INVALID COLUMN NUMBER'\n    zedlmsg = 'ALL COLUMN SPECIFICATIONS MUST BE' ,\n              'BETWEEN 1 AND' width\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\nEnd\nIf AMP = 'Y' then \"SEEK x'\"parmx\"'\" col1 col2\" FIRST\"\n  Else \"SEEK \"parm col1 col2\" FIRST\"\n   IF RC = 0  THEN DO\n      \"EXCLUDE ALL\"\n      If AMP = 'Y' then do\n        \"FIND x'\"parmx\"'\" col1 col2\" ALL\"\n        \"SEEK x'\"parmx\"'\" col1 col2\" ALL\"\n      End\n      Else do\n        \"FIND \"parm col1 col2\" ALL\"\n        \"SEEK \"parm col1 col2\" ALL\"\n      End\n      \"DELETE ALL NX\"\n      \"(count,lines) = SEEK_COUNTS\"\n       count = Format(count)\n       lines = Format(lines)\n       parm = Translate(parm) /* upper case */\n       zedsmsg = lines' LINES DELETED'\n       zedlmsg = count' OCCURRENCES OF \"'parm'\" WERE',\n                'DELETED FROM 'lines' LINES.'\n      \"RESET\"\n       Address ISPEXEC \"SETMSG MSG(ISRZ000)\"  /* msg - no alarm */\n       Exit 1  /* return cursor to command line */\n   End\n   Else do\n       parm = Translate(parm) /* upper case */\n       zedsmsg = 'STRING NOT FOUND'\n       zedlmsg = 'THE STRING \"'parm'\" WAS NOT FOUND IN THE FILE.'\n      \"RESET\"\n       Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n       Exit 12\n   End\n/*********************************/\n/*  HELP SUB-ROUTINES            */\n/*********************************/\nHELP_INCL:\nReturn SIGL\nHELP_NOTELINES:\n\"(helpln) = DISPLAY_LINES\"\nDo hlp = help_end-1 to help_start+1 by -1\n  hline = Sourceline(hlp)\n  \"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline)\"\nEnd\nhline2 = '==================='\nhline3 = '===   H E L P   ==='\n\"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline2)\"\n\"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline3)\"\n\"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline2)\"\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DELX": {"ttr": 3077, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x992/\\x01\\x13(\\x0f\\x14\\x15\\x00\\x8e\\x00P\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf7@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "2013-10-07T14:15:00", "lines": 142, "newlines": 80, "modlines": 0, "user": "CBT487"}, "text": "/* REXX */\n/*                           */\n/* AUTHOR: Mark Zelden       */\n/*                           */\n/* Last Updated 10/07/2013   */\n/*                           */\nhelp_start = HELP_INCL()\n/**********************************************************/\n/* This edit macro will delete all lines but the ones     */\n/* that contain a specified search string.  The search    */\n/* can optionally be limited to specific columns.         */\n/*                                                        */\n/* EXAMPLES:                                              */\n/*            DELX VOL=SER=WORK01                         */\n/*            DELX '//*' 1 3                            */*/\n/*                                                        */\n/*                                                        */\n/*  ** NOTE    If you execute DELX with no parms or with  */\n/*             a parm of \"?\", the comment section of this */\n/*             code with examples will be displayed as    */\n/*             \"help\" note lines.  Use the \"RESET\"        */\n/*             command to remove them.                    */\n/*                                                        */\n/**********************************************************/\nhelp_end = HELP_INCL()\n/* Trace ?R */\nAddress ISREDIT\n\"MACRO (parm col1 col2)\"\n /* Address ISPEXEC \"CONTROL ERRORS RETURN\"  */\nIf pos('&',parm) <> 0 then do\n  parmx = Translate(parm) /* upper case                  */\n  parmx = C2X(parmx)      /* change to hex for seek/find */\n  amp = 'Y'\nEnd\nIf parm = '?' then do\n  Call HELP_NOTELINES\n  Exit 1  /* return cursor to command line */\nEnd\nIf parm = '' then do\n  zedsmsg = 'NO SEARCH STRING'\n  zedlmsg = 'YOU MUST PASS A SEARCH STRING PARM',\n            'TO DELX.'\n  Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n  Call HELP_NOTELINES\n  Exit 4\nEnd\n/* check for numeric column numbers      */\nIf col1 <> '' then do\n  If Datatype(col1,Number) <> 1 then do\n    zedsmsg = 'START COLUMN NOT NUMERIC'\n    zedlmsg = 'THE STARTING COLUMN FOR THE',\n              'SEARCH MUST BE NUMERIC.'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\n  If col2 = '' then col2 = col1\nEnd\nIf col2 <> '' then do\n  If Datatype(col2,Number) <> 1 then do\n    zedsmsg = 'END COLUMN NOT NUMERIC'\n    zedlmsg = 'THE ENDING COLUMN FOR THE',\n              'SEARCH MUST BE NUMERIC.'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\n  If col2 < col1 then do\n    zedsmsg = 'END COL < START COL'\n    zedlmsg = 'THE ENDING COLUMN MUST BE GREATER THAN OR',\n              'EQUAL TO THE STARTING COLUMN.'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\n  If Length(Strip(Translate(parm,'','\"'''''))) ,\n    > COL2-COL1+1 then do\n    zedsmsg = 'PARM TOO LONG'\n    zedlmsg = 'THE STRING WILL NOT FIT BETWEEN THE',\n              'SPECIFIED COLUMNS.'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\n  \"(width) = DATA_WIDTH \"   /* length of line       */\n  width = Format(width)     /* remove leading zeros */\n  If col1 < 1 | col2 < 1 | col1 > width | col2 > width then do\n    zedsmsg = 'INVALID COLUMN NUMBER'\n    zedlmsg = 'ALL COLUMN SPECIFICATIONS MUST BE' ,\n              'BETWEEN 1 AND' width\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\nEnd\n /* \"(FIRSTLN,LASTLN) = DISPLAY_LINES\"          */\n\"(lastln) = LINENUM .ZLAST\"\nIf AMP = 'Y' then \"SEEK x'\"parmx\"'\" col1 col2\" FIRST\"\n  Else \"SEEK \"parm col1 col2\" FIRST\"\n   If rc = 0  then do\n      \"EXCLUDE ALL\"\n      If AMP = 'Y' then do\n        \"FIND x'\"parmx\"'\" col1 col2\" ALL\"\n        \"SEEK x'\"parmx\"'\" col1 col2\" ALL\"\n      End\n      Else do\n        \"FIND \"parm col1 col2\" ALL\"\n        \"SEEK \"parm col1 col2\" ALL\"\n      End\n      \"DELETE ALL X\"\n      \"(count,lines) = SEEK_COUNTS\"\n       count = Format(count)\n       lines = Format(lines)\n       del = lastln-lines\n       parm = Translate(parm) /* upper case */\n       zedsmsg = del' LINES DELETED'\n       zedlmsg = count 'OCCURRENCES OF \"'parm'\" WERE KEPT',\n                  'ON 'lines 'LINES - 'del 'LINES WERE DELETED.'\n      \"RESET\"\n       Address ISPEXEC \"SETMSG MSG(ISRZ000)\"  /* msg - no alarm */\n       Exit 1  /* return cursor to command line */\n   End\n   Else do\n       parm = Translate(parm) /* upper case */\n       zedsmsg = 'STRING NOT FOUND'\n       zedlmsg = 'THE STRING \"'parm'\" WAS NOT FOUND IN THE FILE.'\n      \"RESET\"\n       Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n       Exit 12\n   End\n/*********************************/\n/*  HELP SUB-ROUTINES            */\n/*********************************/\nHELP_INCL:\nReturn SIGL\nHELP_NOTELINES:\n\"(helpln) = DISPLAY_LINES\"\nDo hlp = help_end-1 to help_start+1 by -1\n  hline = Sourceline(hlp)\n  \"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline)\"\nEnd\nhline2 = '==================='\nhline3 = '===   H E L P   ==='\n\"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline2)\"\n\"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline3)\"\n\"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline2)\"\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DSLISTSV": {"ttr": 3081, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x19\\x18/\\x01\\x19\\x18/\\x17 \\x00\\r\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf9\\xf8@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-07-01T00:00:00", "modifydate": "2019-07-01T17:20:00", "lines": 13, "newlines": 12, "modlines": 0, "user": "CBT498"}, "text": "PROC 0 L(&SYSUID)  G(SAVE)\n /*                                                         */\n /* Quick ISPF save of data set names. This is much quicker */\n /* than using OPT 3.4, because it does not do an obtain    */\n /* for each data set in the list because of STATS(NO).     */\n /* The dsn created will be USERID.SAVE.DATASETS            */\n /*                                                         */\n ISPEXEC CONTROL ERRORS RETURN\n ISPEXEC LMDINIT LISTID(LISTID)  LEVEL(&L)\n ISPEXEC LMDLIST LISTID(&LISTID) OPTION(SAVE) STATS(NO) GROUP(&G)\n WRITE COMPLETE!! RETURN CODE WAS &LASTCC\n WRITE OUTPUT IS IN &SYSUID..&G..DATASETS\n ISPEXEC LMDFREE LISTID(&LISTID)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DT": {"ttr": 3083, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00B\\x00\\x992/\\x00\\x992/\\x16'\\x00#\\x00#\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf2\\xf2@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "1999-11-18T16:27:42", "lines": 35, "newlines": 35, "modlines": 0, "user": "CBT422"}, "text": "/* REXX */\n/*                                       */\n/* AUTHOR: Mark Zelden                   */\n/*                                       */\n/* TRACE ?R */\nAddress ISREDIT\n\"MACRO\"\n Address ISPEXEC \"CONTROL ERRORS RETURN\"\n /*                                                    */\n /* This edit macro will delete all lines from the     */\n /* line the cursor is on to the top line.             */\n /*                                                    */\n  /***********************************************/\n  /*   BEGIN DT PROCESSING                       */\n  /***********************************************/\n  \"ISREDIT (row,col) = CURSOR\"\n  If row  <  2 then do\n    zedsmsg = 'NEED AT LEAST 2 LINES'\n    zedlmsg = 'YOU MUST DELETE AT LEAST 2 LINES IN THE FILE',\n              'TO EXECUTE THE DT EDIT MACRO.'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\n  \"ISREDIT LABEL 1 = .FROM\"\n  \"ISREDIT LABEL \" row \"= .TO\"\n  \"DELETE ALL .FROM .TO\"  /* delete labeled lines */\n  /***********************************************/\n  /*   END DT PROCESSING                         */\n  /***********************************************/\n  count = row + 0 /* remove leading zeros */\n  zedsmsg = count 'LINES DELETED'\n  zedlmsg = count 'LINES WERE DELETED FROM THE CURSOR LINE' ,\n                  'TO THE TOP LINE.'\n  Address ISPEXEC \"SETMSG MSG(ISRZ000)\"  /* msg - no alarm */\n  Exit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EDMACALL": {"ttr": 3085, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00X\\x01\\x01\\x15\\x1f\\x01\\x01\\x15\\x1f\\x10!\\x00C\\x00C\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf3\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-05-31T00:00:00", "modifydate": "2001-05-31T10:21:58", "lines": 67, "newlines": 67, "modlines": 0, "user": "CBT436"}, "text": "/* REXX */\n/*                                       */\n/* AUTHOR: Mark Zelden                   */\n/* Last Updated 05/31/2001               */\n/*                                       */\n/***************************************************************/\n/*                                                             */\n/* This REXX exec can be used to process an ISPF EDIT Macro    */\n/* against every member of a PDS.                              */\n/*                                                             */\n/***************************************************************/\n/* Command syntax:                                             */\n/*                                                             */\n/*   TSO %EDMACALL  data_set_name  macro_name                  */\n/*                                                             */\n/* If data_set_name is not enclosed in quotes, then the        */\n/* TSO PREFIX (normally the USERID) will be added to the       */\n/* beginning of the data set name.                             */\n/*                                                             */\n/***************************************************************/\n/* Sample EDIT Macro and EDMACALL execution:                   */\n/*                                                             */\n/*  CHGSYS Edit Macro                                          */\n/*                                                             */\n/*  /* rexx   EDIT Macro to change \"SYSA.\" to \"SYSB.\" */       */\n/*  Address ISREDIT                                            */\n/*  \"MACRO\"                                                    */\n/*  \"CHANGE 'SYSA.' 'SYSB.' ALL\"                               */\n/*  \"SAVE\"                                                     */\n/*  \"END\"                                                      */\n/*                                                             */\n/*  EDMACALL Execution                                         */\n/*                                                             */\n/*  TSO  %EDMACALL 'TEST.PROCLIB' CHGSYS                       */\n/*                                                             */\n/***************************************************************/\nArg DSN MACNAME .\nIf MACNAME = '' then do               /* no macro name parm given    */\n  Say  'ERROR - EDIT MACRO name not specified' /* issue error msg    */\n  Exit 12                             /* exit RC=12                  */\nEnd\nIf Pos(\"'\",DSN) = 0 &  SYSVAR(SYSPREF) <> '' then , /* if no quotes  */\n  DSN = SYSVAR(SYSPREF) || '.' || DSN /* and PREF not null, add it   */\nElse DSN = Strip(Translate(DSN,\"\",\"'\")) /* remove quotes if used     */\nCHKLIB = SYSDSN(\"'\"DSN\"'\")            /* see if data set exists      */\nIf  CHKLIB <> 'OK' then do            /* data set not found          */\n  Say  'ERROR -' dsn 'not found. Check name and quotes.' /* issue msg*/\n  Exit 12                             /* exit RC=12                  */\nEnd\njunk = outtrap('MBR.')                /* capture output to MBR. stem */\n\"LISTD '\" || dsn || \"' MEMBERS\"       /* issue LISTD cmd against PDS */\njunk = outtrap('off')                 /* stop capturing output       */\nDo I = 1 to MBR.0                     /* loop to get past vol info   */\n  If MBR.I = \"--MEMBERS--\" then leave /* if member section, exit loop*/\nEnd\nIf I = MBR.0 then do                  /* no members in PDS           */\n  Say 'ERROR - No MEMBERS found in' dsn'.' /* issue error msg        */\n  Exit 12                             /* exit RC=12                  */\nEnd\nSay 'Processing' MBR.0 - I 'members ...'\nDo J = I+1 to MBR.0                   /* loop to execute edit macro  */\n  Parse var MBR.J MACMEM .            /* get rid of alias info       */\n  Address ISPEXEC \"EDIT DATASET('\" || dsn || \"(\" || macmem || \")')\" ,\n                  \"MACRO(\"macname\")\"\nEnd\nSay 'Processing complete!'\nExit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EXCL": {"ttr": 3087, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x992/\\x01\\x13(\\x0f\\x14\\x15\\x00\\x99\\x00M\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf7@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "2013-10-07T14:15:00", "lines": 153, "newlines": 77, "modlines": 0, "user": "CBT487"}, "text": "/* REXX */\n/*                           */\n/* AUTHOR: Mark Zelden       */\n/*                           */\n/* Last Updated 10/07/2013   */\n/*                           */\nhelp_start = HELP_INCL()\n/**********************************************************/\n/* This edit macro will exclude all lines that contain    */\n/* a specified search string.  The search string can      */\n/* optionally be limited to specific columns.             */\n/*                                                        */\n/* EXAMPLES:                                              */\n/*            EXCL UNIT=SYSDA                             */\n/*            EXCL ' DD ' 3 12                            */\n/*                                                        */\n/*                                                        */\n/*  ** NOTE    If you execute EXCL with no parms or with  */\n/*             a parm of \"?\", the comment section of this */\n/*             code with examples will be displayed as    */\n/*             \"help\" note lines.  Use the \"RESET\"        */\n/*             command to remove them.                    */\n/*                                                        */\n/**********************************************************/\n/*                                                        */\n/*  \"HIDE EXCLUDED\" is used on systems that are running   */\n/*  z/OS 1.6 (ISPF 5.6) and above.                        */\n/*  Remove or comment out the following line of code      */\n/*  around line 105 if you like to see excluded lines     */\n/*  or issue the \"RESET HIDE\" command after you run       */\n/*  the EXCL macro.                                       */\n/*                                                        */\n/*    If Substr(ZENVIR,6,3) >= 5.5 then \"HIDE EXCLUDED\"   */\n/*                                                        */\n/**********************************************************/\nhelp_end = HELP_INCL()\n/* Trace ?R */\nAddress ISREDIT\n\"MACRO (parm col1 col2)\"\n /* Address ISPEXEC \"CONTROL ERRORS RETURN\"  */\nIf pos('&',parm) <> 0 then do\n  parmx = Translate(parm) /* upper case                  */\n  parmx = C2X(parmx)      /* change to hex for seek/find */\n  amp = 'Y'\nEnd\n/* check for numeric column numbers      */\nIf parm = '?' then do\n  Call HELP_NOTELINES\n  Exit 1  /* return cursor to command line */\nEnd\nIf parm = '' then do\n  zedsmsg = 'NO SEARCH STRING'\n  zedlmsg = 'YOU MUST PASS A SEARCH STRING PARM',\n            'TO EXCL.'\n  Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n  Call HELP_NOTELINES\n  Exit 4\nEnd\n\nIf col1 <> '' then do\n  If Datatype(col1,Number) <> 1 then do\n    zedsmsg = 'START COLUMN NOT NUMERIC'\n    zedlmsg = 'THE STARTING COLUMN FOR THE',\n              'SEARCH MUST BE NUMERIC.'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\n  If col2 = '' then col2 = col1\nEnd\nIf col2 <> '' then do\n  If Datatype(col2,Number) <> 1 then do\n    zedsmsg = 'END COLUMN NOT NUMERIC'\n    zedlmsg = 'THE ENDING COLUMN FOR THE',\n              'SEARCH MUST BE NUMERIC.'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\n  If col2 < col1 then do\n    zedsmsg = 'END COL < START COL'\n    zedlmsg = 'THE ENDING COLUMN MUST BE GREATER THAN OR',\n              'EQUAL TO THE STARTING COLUMN.'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\n  If Length(Strip(Translate(parm,'','\"'''''))) ,\n    > COL2-COL1+1 then do\n    zedsmsg = 'PARM TOO LONG'\n    zedlmsg = 'THE STRING WILL NOT FIT BETWEEN THE',\n              'SPECIFIED COLUMNS.'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\n  \"(width) = DATA_WIDTH \"   /* length of line       */\n  width = Format(width)     /* remove leading zeros */\n  If col1 < 1 | col2 < 1 | col1 > width | col2 > width then do\n    zedsmsg = 'INVALID COLUMN NUMBER'\n    zedlmsg = 'ALL COLUMN SPECIFICATIONS MUST BE' ,\n              'BETWEEN 1 AND' width\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\nEnd\nparmck = Translate(parm)\nIf parmck = 'X' | parmck = 'NX' | parmck = '*' ,\n   | parmck = '/*' then parm = \"'\" ||parm|| \"'\"\nIf AMP = 'Y' then \"SEEK x'\"parmx\"'\" col1 col2\" FIRST\"\n  Else \"SEEK \"parm col1 col2\" FIRST\"\n   If rc = 0  then do\n      If AMP = 'Y' then do\n        \"EXCLUDE X'\"parmx\"'\" col1 col2\" ALL\"\n        \"SEEK X'\"parmx\"'\" col1 col2\" ALL\"\n      End\n      Else Do\n        \"EXCLUDE \"parm col1 col2\" ALL\"\n        \"SEEK \"parm col1 col2\" ALL\"\n      End\n      \"(count,lines) = SEEK_COUNTS\"\n       Address ISPEXEC \"VGET ZENVIR\"\n       If Substr(ZENVIR,6,3) >= 5.5 then \"HIDE EXCLUDED\"\n       count = Format(count)\n       lines = Format(lines)\n       parm = Translate(parm) /* upper case */\n       zedsmsg = count' \"'parm'\" EXCLUDED'\n       zedlmsg = 'THE STRING \"'parm'\" WAS EXCLUDED 'count' TIMES',\n                 'FROM 'lines' LINES.'\n       Address ISPEXEC \"SETMSG MSG(ISRZ000)\"  /* msg - no alarm */\n       Exit 1  /* return cursor to command line */\n   End\n   Else do\n       parm = Translate(parm) /* upper case */\n       zedsmsg = 'STRING NOT FOUND'\n       zedlmsg = 'THE STRING \"'parm'\" WAS NOT FOUND IN THE FILE.'\n      \"RESET\"\n       Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n       Exit 12\n   End\n/*********************************/\n/*  HELP SUB-ROUTINES            */\n/*********************************/\nHELP_INCL:\nReturn SIGL\nHELP_NOTELINES:\n\"(helpln) = DISPLAY_LINES\"\nDo hlp = help_end-1 to help_start+1 by -1\n  hline = Sourceline(hlp)\n  \"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline)\"\nEnd\nhline2 = '==================='\nhline3 = '===   H E L P   ==='\n\"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline2)\"\n\"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline3)\"\n\"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline2)\"\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FILL": {"ttr": 3329, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x992/\\x01\\x13(\\x0f\\x14\\x15\\x00\\xc1\\x00\\x98\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf7@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "2013-10-07T14:15:00", "lines": 193, "newlines": 152, "modlines": 0, "user": "CBT487"}, "text": "/* REXX */\n/*                           */\n/* AUTHOR: Mark Zelden       */\n/*                           */\n/* Last Updated 10/07/2013   */\n/*                           */\nhelp_start = HELP_INCL()\n/**********************************************************/\n/* This edit macro will FILL column(s) with characters.   */\n/* The FILL can optionally be limited to specific lines   */\n/* if labels are used. Excluded lines are omitted from    */\n/* the operation.                                         */\n/*                                                        */\n/* EXAMPLES:                                              */\n/*            FILL 1 2 '/'                                */\n/*            FILL 2 7 'DELETE' .A .B                     */\n/*                                                        */\n/*                                                        */\n/*  ** NOTE    If you execute FILL with no parms or with  */\n/*             a parm of \"?\", the comment section of this */\n/*             code with examples will be displayed as    */\n/*             \"help\" note lines.  Use the \"RESET\"        */\n/*             command to remove them.                    */\n/*                                                        */\n/**********************************************************/\nhelp_end = HELP_INCL()\n/* Trace ?R */\nAddress ISREDIT\n\"MACRO (col1 col2 parm label1 label2)\"\n/* Address ISPEXEC \"CONTROL ERRORS RETURN\"  */\nIf col1 = '?' then do\n  Call HELP_NOTELINES\n  Exit 1  /* return cursor to command line */\nEnd\n/* check for numeric column numbers      */\nIf col1 <> '' then do\n  If Datatype(col1,Number) <> 1 then do\n    zedsmsg = 'START COLUMN NOT NUMERIC'\n    zedlmsg = 'THE STARTING COLUMN FOR THE',\n              'FILL MUST BE NUMERIC.'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\n  If col2 = '' then do\n    zedsmsg = 'NO ENDING COLUMN'\n    zedlmsg = 'AN ENDING COLUMN FOR THE',\n              'FILL MUST BE SPECIFIED.'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\nEnd\nIf col2 <> '' then do\n  If Datatype(col2,Number) <> 1 then do\n    zedsmsg = 'END COLUMN NOT NUMERIC'\n    zedlmsg = 'THE ENDING COLUMN FOR THE',\n              'FILL MUST BE NUMERIC.'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\n  If col2 < col1 then do\n    zedsmsg = 'END COL < START COL'\n    zedlmsg = 'THE ENDING COLUMN MUST BE GREATER THAN OR',\n              'EQUAL TO THE STARTING COLUMN.'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\nEnd\nIf col1 = '' then do\n  zedsmsg = 'NO STARTING COLUMN'\n  zedlmsg = 'YOU MUST SPECIFY A STARTING COLUMN',\n            'FOR THE CHARACTER FILL.'\n  Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n  Call HELP_NOTELINES\n  Exit 4\nEnd\nIf parm = '' then do\n  zedsmsg = 'NO FILL CHARACTER'\n  zedlmsg = 'YOU MUST SPECIFY A FILL CHARACTER',\n            'AS THE THIRD PARAMETER.'\n  Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n  Exit 12\nEnd\n\"(width) = DATA_WIDTH \"   /* length of line       */\nwidth = Format(width)     /* remove leading zeros */\nIf col1 < 1 | col2 < 1 | col1 > width | col2 > width then do\n  zedsmsg = 'INVALID COLUMN NUMBER'\n  zedlmsg = 'ALL COLUMN SPECIFICATIONS MUST BE' ,\n            'BETWEEN 1 AND' width\n  Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n  Exit 12\nEnd\n/* make sure data will fit */\nparmckl = parm\nIf Substr(parm,1,1) == \"'\" then\n  parmckl = Strip(Translate(parm,\"\",\"'\"))\nIf Substr(parm,1,1) == '\"' then\n  parmckl = Strip(Translate(parm,'','\"'))\nIf col2-col1+1 < Length(parmckl) then do\n  zedsmsg = 'DATA WON''T FIT'\n  zedlmsg = 'FILL DATA WILL NOT FIT IN THE' ,\n            'SPECIFIED COLUMNS'\n  Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n  Exit 12\nEnd\n/*                             */\n/* Save current BOUNDS setting */\n/*                             */\n\"(status) = USER_STATE\"\n/***********************************************/\n/*   FIND OUT IF LABELS ARE BEING USED         */\n/***********************************************/\nCall FIND_LABELS\n/***********************************************/\nparmck = Translate(parm)\nIf parmck = 'X' | parmck = 'NX' | parmck = '*' ,\n   | parmck = '/*' then parm = \"'\" ||parm|| \"'\"\n/***************************************************/\n/* Begin changing data                             */\n/***************************************************/\n\"BOUNDS \"col1 col2\n\"C P'=' ' '    ALL  NX \"label1 label2 /* all characters   */\n\"C P'=' \" || parm || \" ALL  NX \"label1 label2 /* all characters   */\n/***************************************************/\n/* End of changes                                  */\n/***************************************************/\n/*                                      */\n/* Find the number of changed lines and */\n/* and save them for later use          */\n/*                                      */\n\"SEEK \" || parm || \" ALL NX \"label1 label2\n\"(junk,count) = SEEK_COUNTS\"\n/*                              */\n/* restore saved BOUNDS setting */\n/*                              */\n\"USER_STATE = (status)\"\n\"RESET CHANGE ERROR\"\n/*                              */\n/* display changed lines count  */\n/*                              */\ncount=count+0  /* remove leading zeros */\nzedsmsg = count 'LINES CHANGED'\nzedlmsg = count 'LINES WERE FILLED WITH \"'parm'\".'\nAddress ISPEXEC \"SETMSG MSG(ISRZ000)\"  /* msg - no alarm */\nExit 1  /* return cursor to command line */\n/*********************************/\n/*  HELP SUB-ROUTINES            */\n/*********************************/\nHELP_INCL:\nReturn SIGL\nHELP_NOTELINES:\n\"(helpln) = DISPLAY_LINES\"\nDo hlp = help_end-1 to help_start+1 by -1\n  hline = Sourceline(hlp)\n  \"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline)\"\nEnd\nhline2 = '==================='\nhline3 = '===   H E L P   ==='\n\"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline2)\"\n\"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline3)\"\n\"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline2)\"\nReturn\n/*********************************/\n/*  SUB-ROUTINE TO FIND LABELS   */\n/*********************************/\nFIND_LABELS:\nAddress ISPEXEC \"CONTROL ERRORS RETURN\"\nIf label1 = '' then do\n  firstln  = 1\n  \"(lastln) = LINENUM .ZLAST\"\nEnd\nElse do\n  If label2 = '' then label2 = label1\n  \"(firstsv)  = LINENUM\" label1\n  If RC >= 8 then do\n    zedsmsg = 'RANGE LABEL ERROR'\n    zedlmsg = 'THE SPECIFIED RANGE LABEL \"' || label1 '\" WAS',\n              'NOT FOUND'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\n  \"(lastsv)   = LINENUM\" label2\n  If RC >= 8 then do\n    zedsmsg = 'RANGE LABEL ERROR'\n    zedlmsg = 'THE SPECIFIED RANGE LABEL \"' || label2 '\" WAS',\n              'NOT FOUND'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\n  firstln = Min(firstsv,lastsv)\n  lastln  = Max(firstsv,lastsv)\nAddress ISPEXEC \"CONTROL ERRORS\"\nEnd /* else do */\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FINDASYS": {"ttr": 3333, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00B\\x00\\x992/\\x00\\x992/\\x16'\\x00\\x17\\x00\\x17\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf2\\xf2@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "1999-11-18T16:27:42", "lines": 23, "newlines": 23, "modlines": 0, "user": "CBT422"}, "text": "***************************************************************\n*  LIBRARY SEARCH LIST FOR FINDMOD CLIST - DO NOT DELETE\n***************************************************************\n*\n* PROC LIBS\n*\nASYS.PROCLIB\nSYS1.PROCLIB\nSYS1.IBM.PROCLIB\nASYS.SYSTEMS.PROCLIB\nSYS2.PROCLIB\nPROD.MIC.PROCLIB\nTEST.MIC.PROCLIB\n*\n* CLIST LIBS\n*\nASYS.ISPF.LOGON.ISPCLIB\nGIM.SGIMCLS0\nASYS.USER.ISPCLIB\nTEST.MIC.ISPCLIB\nSYS2.JOBTRAC.TRACCLST\nSYS2.CA90.CAICLIB\nASYS.OPSMVS.FBCLIST\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FINDMOD": {"ttr": 3335, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x992/\\x01\\x11\\x06?\\x14E\\x01\\x84\\x00]\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "2011-03-04T14:45:00", "lines": 388, "newlines": 93, "modlines": 0, "user": "CBT482"}, "text": "/* REXX  */\n/*                           */\n/* AUTHOR: MARK ZELDEN       */\n/*                           */\n/***********************************************************/\n/*  Quickly find the location of a module (or modules).    */\n/*                                                         */\n/*  The specified module name may be fully qualified or    */\n/*  any valid ISPF member pattern. The output will show    */\n/*  the module name(s) found, the library or libraries it  */\n/*  was found in and the \"last updated\" (changed) ISPF     */\n/*  statistic if it exits for the member(s).               */\n/*                                                         */\n/*  By default, the LPA and LNKLST concatenation are       */\n/*  searched. Alternatively, a \"search list member\" may    */\n/*  be specified. In order to use the search list, the     */\n/*  libraries to search must be manually added to a        */\n/*  PDS member (or members).                               */\n/*                                                         */\n/*  The library that the optional search member list must  */\n/*  reside in is defined by the MBRLIB variable below.     */\n/*  A suggested member list name is FINDxxxx where xxxx is */\n/*  the SMFID of the system, or a descriptive name such    */\n/*  as FINDPROC or FINDCICS. The search list should        */\n/*  specify only one library per line. An \"*\" in column    */\n/*  one indicates the line is a comment.                   */\n/*                                                         */\n/*  SAMPLE SEARCH LIST:                                    */\n/*  *---+----1----+----2----+----3----+----4----+----5     */\n/*  ******************************                         */\n/*  * PROC LIBS                                            */\n/*  ******************************                         */\n/*  SYS1.PROCLIB                                           */\n/*  SYS1.IBM.PROCLIB                                       */\n/*  USER.PROCLIB                                           */\n/*  ******************************                         */\n/*  * CLIST LIBS                                           */\n/*  ******************************                         */\n/*  SYS1.CLIST                                             */\n/*  USER.CLIST1                                            */\n/*  USER.CLIST2                                            */\n/*                                                         */\n/***********************************************************/\n/* EXECUTION SYNTAX:                                       */\n/*                                                         */\n/* TSO %FINDMOD <mbr pattern> (search list name) (BOTH)    */\n/*                                                         */\n/* If a search list name is specified, only the libraries  */\n/* in the search list will be searched, unless the \"BOTH\"  */\n/* option is used. The \"BOTH\" option will search the       */\n/* libraries in the search list first, then the LPA and    */\n/* LNKLST.                                                 */\n/*                                                         */\n/* EXAMPLES:                                               */\n/* TSO %FINDMOD         (will prompt for module name)      */\n/* TSO %FINDMOD IEFBR14 (search LPA & LNKLST for IEFBR14)  */\n/* TSO %FINDMOD LLA FINDPROC (find LLA using FINDPROC list)*/\n/* TSO %FINDMOD A%R*  (use mask to search LPA & LNKLST)    */\n/* TSO %FINDMOD MYPROG BOTH (use list, LPA, & LNKLST)      */\n/*                                                         */\n/* NOTE: This exec can be executed as an ISPF EDIT MACRO   */\n/*   from ISPF EDIT or VIEW from the command line without  */\n/*   using the \"TSO\" prefix.  Example: FINDMOD IEFBR14     */\n/***********************************************************/\n/*                                                         */\n/* You can easily turn \"FINDMOD\" into \"FINDPROC\" by        */\n/* uncommenting out one of the \"MEMBER =\" lines below      */\n/* just after \"call CHECK_MODNAME\"   (in other words, hard */\n/* coding a search member name). Then code the PROCLIBs    */\n/* to search in that PDS member and execute as follows:    */\n/*                                                         */\n/* TSO %FINDPROC LLA                                       */\n/*                                                         */\n/***********************************************************/\narg NAME MEMBER OPT DEBUG\n/***********************************************************/\nLASTUPD = '07/22/2008'     /* date of last update          */\n/***********************************************************/\nparse upper arg\nIf Sysvar(SYSISPF) <> 'ACTIVE' then do\n  Say 'FINDMOD must be invoked from ISPF, terminating!'\n  Exit 12\nEnd\naddress ISREDIT \"MACRO (NAME MEMBER OPT DEBUG)\"\nNAME   = translate(NAME)    /* chg to upper case for edit macro */\nMEMBER = translate(MEMBER)  /* chg to upper case for edit macro */\nOPT    = translate(OPT)     /* chg to upper case for edit macro */\nDEBUG  = translate(DEBUG)   /* chg to upper case for edit macro */\nIf OPT <> '' & OPT <> 'BOTH' then do\n  Say '\"BOTH\" is the only valid option'\n  Exit 8\nEnd\nIf debug = 'DEBUG' then trace ?i\n/*********************************************************/\n/* MBRLIB  = 'SYS2.PARMLIB'  */\nMBRLIB  = 'MPSYS3.USZCZT0.CNTL'\n/*********************************************************/\nNUMLIBS = 0  /* total number of libraries to be searched */\ncall CHECK_MODNAME           /* check module name syntax */\n/*********************************************************/\n/* Uncomment one of the following for \"FINDPROC\" or      */\n/* specify your own \"MEMBER =\" member name.              */\n/*********************************************************/\n /* MEMBER = 'FIND' || MVSVAR(SYSSMFID)  */\n /* MEMBER = 'FINDPROC' */\nIf MEMBER = '' then call GET_LPALNK  /* use LPA/LNKLST   */\nElse do\n  Call GET_LIBNAMES          /* use optional search list */\n  If OPT = 'BOTH' then call GET_LPALNK /* use LPA/LNKLST */\nEnd\n/*********************************************************/\n/*   BEGIN MODULE SEARCH                                 */\n/*********************************************************/\nFOUND = 'NO' /* found flag */\nIf member = '' then do\n  Say   '...Searching for 'name' in 'numlibs' libraries'\n  Say   '   (Using LPA & LNKLST' || setname || ')'\n  Queue '...Searching for 'name' in 'numlibs' libraries'\n  Queue '   (Using LPA & LNKLST' || setname || ')'\nEnd\nElse do\n  If OPT = 'BOTH' then do\n    Say   '...Searching for 'name' in 'numlibs' libraries'\n    Say   '   (Using list 'member || ', LPA,' ,\n          '& LNKLST' || setname || ')'\n    Queue '...Searching for 'name' in 'numlibs' libraries'\n    Queue '   (Using list 'member || ', LPA,' ,\n          '& LNKLST' || setname || ')'\n  End\n  Else Do\n    Say   '...Searching for 'name' in 'numlibs' libraries'\n    Say   '   (Using search list 'member || ')'\n    Queue '...Searching for 'name' in 'numlibs' libraries'\n    Queue '   (Using search list 'member || ')'\n  End\nEnd\nSay   '   '\nQueue '   '\nDo SEARCH = 1 to LIB.0\n  LIB.SEARCH = word(LIB.SEARCH,1)\n  /* Say   'Searching' lib.search  */\n  /* Queue 'Searching' lib.search  */\n  Address ISPEXEC \"LMINIT DATAID(FINDMOD1) DATASET('\"lib.search\"')\"\n  If RC <> 0 then do\n    Say   'Error processing' lib.search':'\n    Queue 'Error processing' lib.search':'\n    Say   Strip(ZERRLM)\n    Queue Strip(ZERRLM)\n    Say   '  '\n    Queue '  '\n    Iterate  /* go get next library to search on error */\n  End /* if RC <> 0 */\n  Address ISPEXEC \"LMOPEN DATAID(\"FINDMOD1\") RECFM(RFVAR)\"\n  If RC <> 0 then do\n    Say   'Error processing' lib.search':'\n    Queue 'Error processing' lib.search':'\n    Say   Strip(ZERRLM)\n    Queue Strip(ZERRLM)\n    Say   '  '\n    Queue '  '\n    Address ISPEXEC \"LMFREE DATAID(\"FINDMOD1\")\"\n    Iterate  /* go get next library to search on error */\n  End /* if RC <> 0 */\n  MEMVAR = ' '\n  ZLM4DATE = '' /* reset each new library because of stats yes/no */\n  Do forever\n    If RFVAR = 'FB' then ,\n      Address ISPEXEC \"LMMLIST DATAID(\"FINDMOD1\") OPTION(LIST) \",\n              \"MEMBER(MEMVAR) PATTERN(\"NAME\") STATS(YES)\"\n    Else ,\n      Address ISPEXEC \"LMMLIST DATAID(\"FINDMOD1\") OPTION(LIST) \",\n              \"MEMBER(MEMVAR) PATTERN(\"NAME\") STATS(NO)\"\n    If RC = 0 then do  /* match found */\n      FOUND = 'YES'\n      If ZLM4DATE = 'ZLM4DATE' | ZLM4DATE = '' then do /* no stats */\n        Say   memvar 'found in' lib.search\n        Queue memvar 'found in' lib.search\n      End\n      Else do /* stats */\n        Say   memvar 'found in' lib.search \"(Lastupd \"ZLM4DATE\")\"\n        Queue memvar 'found in' lib.search \"(Lastupd \"ZLM4DATE\")\"\n      End\n    End\n    Else do  /* no match found, or no more in list */\n      Address ISPEXEC \"LMCLOSE DATAID(\"FINDMOD1\")\"\n      Address ISPEXEC \"LMFREE DATAID(\"FINDMOD1\")\"\n      Leave /* leave loop, go search next library if any */\n    End /* else do */\n  End  /* do forever */\nEnd /* do SEARCH */\nIf FOUND = 'NO' then do\n  Say   NAME 'was not found in any library'\n  Queue NAME 'was not found in any library'\nEnd\n/*********************************************************************/\n/* Browse results                                                    */\n/*********************************************************************/\n/* BROWSE_ISPF:  Browse output if ISPF is active  */\nQueue ''  /* null queue to end stack   */\nAddress ISPEXEC \"CONTROL ERRORS RETURN\"\nAddress ISPEXEC \"VGET ZENVIR\"\nAddress TSO\nprefix = sysvar('SYSPREF')        /* tso profile prefix            */\nuid    = sysvar('SYSUID')         /* tso userid                    */\nIf prefix = '' then prefix = uid  /* use uid if null prefix        */\nIf prefix <> '' & prefix <> uid then /* different prefix than uid  */\n   prefix = prefix || '.' || uid /* use  prefix.uid                */\nddnm1 = 'DDO'||random(1,99999)   /* choose random ddname           */\nddnm2 = 'DDP'||random(1,99999)   /* choose random ddname           */\njunk = msg('off')\n\"ALLOC FILE(\"||ddnm1||\") UNIT(SYSALLDA) NEW TRACKS SPACE(2,1) DELETE\",\n      \" REUSE LRECL(80) RECFM(F B) BLKSIZE(3120)\"\n\"ALLOC FILE(\"||ddnm2||\") UNIT(SYSALLDA) NEW TRACKS SPACE(1,1) DELETE\",\n      \" REUSE LRECL(80) RECFM(F B) BLKSIZE(3120) DIR(1)\"\njunk = msg('on')\n\"Newstack\"\n/*************************/\n/* FINDMODP Panel source */\n/*************************/\nIf Substr(ZENVIR,6,1) >= 4 then\n  Queue \")PANEL KEYLIST(ISRSPBC,ISR)\"\nQueue \")ATTR\"\nQueue \"  _ TYPE(INPUT)   INTENS(HIGH) COLOR(TURQ) CAPS(OFF)\" ,\n      \"FORMAT(&MIXED)\"\nQueue \"  | AREA(DYNAMIC) EXTEND(ON)   SCROLL(ON)\"\nQueue \"  + TYPE(TEXT)    INTENS(LOW)  COLOR(BLUE)\"\nQueue \"  @ TYPE(TEXT)    INTENS(LOW)  COLOR(TURQ)\"\nQueue \"  % TYPE(TEXT)    INTENS(HIGH) COLOR(GREEN)\"\nQueue \"  ! TYPE(OUTPUT)  INTENS(HIGH) COLOR(TURQ) PAD(-)\"\nQueue \" 01 TYPE(DATAOUT) INTENS(LOW)\"\nQueue \" 02 TYPE(DATAOUT) INTENS(HIGH)\"\nQueue \" 0B TYPE(DATAOUT) INTENS(HIGH) FORMAT(DBCS)\"\nQueue \" 0C TYPE(DATAOUT) INTENS(HIGH) FORMAT(EBCDIC)\"\nQueue \" 0D TYPE(DATAOUT) INTENS(HIGH) FORMAT(&MIXED)\"\nQueue \" 10 TYPE(DATAOUT) INTENS(LOW)  FORMAT(DBCS)\"\nQueue \" 11 TYPE(DATAOUT) INTENS(LOW)  FORMAT(EBCDIC)\"\nQueue \" 12 TYPE(DATAOUT) INTENS(LOW)  FORMAT(&MIXED)\"\nQueue \")BODY EXPAND(//)\"\nQueue \"%BROWSE  @&ZTITLE  / /  %Line!ZLINES  %Col!ZCOLUMS+\"\nQueue \"%Command ===>_ZCMD / /           %Scroll ===>_Z   +\"\nQueue \"|ZDATA ---------------/ /-------------------------|\"\nQueue \"|                     / /                         |\"\nQueue \"| --------------------/-/-------------------------|\"\nQueue \")INIT\"\nQueue \"  .HELP = ISR10000\"\nQueue \"  .ZVARS = 'ZSCBR'\"\nQueue \"  &ZTITLE = 'Mark''s MVS Utilities - FINDMOD'\"\nQueue \"  &MIXED = MIX\"\nQueue \"  IF (&ZPDMIX = N)\"\nQueue \"   &MIXED = EBCDIC\"\nQueue \"  VGET (ZSCBR) PROFILE\"\nQueue \"  IF (&ZSCBR = ' ')\"\nQueue \"   &ZSCBR = 'CSR'\"\nQueue \")REINIT\"\nQueue \"  REFRESH(ZCMD,ZSCBR,ZDATA,ZLINES,ZCOLUMS)\"\nQueue \")PROC\"\nQueue \"  &ZCURSOR = .CURSOR\"\nQueue \"  &ZCSROFF = .CSRPOS\"\nQueue \"  &ZLVLINE = LVLINE(ZDATA)\"\nQueue \"  VPUT (ZSCBR) PROFILE\"\nQueue \")END\"\nQueue \"\"\n/*                                    */\nAddress ISPEXEC \"LMINIT DATAID(PAN) DDNAME(\"ddnm2\")\"\nAddress ISPEXEC \"LMOPEN DATAID(\"pan\") OPTION(OUTPUT)\"\nDo queued()\n   Parse pull panline\n   Address ISPEXEC \"LMPUT DATAID(\"pan\") MODE(INVAR)\" ,\n           \"DATALOC(PANLINE) DATALEN(80)\"\nEnd\nAddress ISPEXEC \"LMMADD DATAID(\"pan\") MEMBER(FINDMODP)\"\nAddress ISPEXEC \"LMFREE DATAID(\"pan\")\"\n\"Delstack\"\n\"EXECIO * DISKW\" ddnm1 \"(FINIS\"\nIf FOUND = 'NO' then zedsmsg = NAME 'NOT FOUND'\n                else zedsmsg = NAME 'WAS FOUND'\nzedlmsg = 'FINDMOD - Last updated  on' ,\n           LASTUPD ||'. Written by' ,\n          'Mark Zelden. Mark''s MVS Utilities -' ,\n          'http://www.mzelden.com/mvsutil.html'\nAddress ISPEXEC \"LIBDEF ISPPLIB LIBRARY ID(\"ddnm2\") STACK\"\nIf FOUND = 'NO' then ,\n  Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm  */\nElse ,\n  Address ISPEXEC \"SETMSG MSG(ISRZ000)\"  /* msg - no alarm    */\nAddress ISPEXEC \"LMINIT DATAID(TEMP) DDNAME(\"ddnm1\")\"\nAddress ISPEXEC \"BROWSE DATAID(\"temp\") PANEL(FINDMODP)\"\nAddress ISPEXEC \"LMFREE DATAID(\"temp\")\"\nAddress ISPEXEC \"LIBDEF ISPPLIB\"\njunk = msg('off')\n\"FREE FI(\"ddnm1\")\"\n\"FREE FI(\"ddnm2\")\"\nExit\n\n/*******************************************/\n/*  SUB ROUTINES                           */\n/*******************************************/\n\nCHECK_MODNAME:\nIf NAME = '' then do\n  Say 'Please enter module name or pattern to find:'\n  Parse upper pull name\n  Call CHECK_MODNAME\nEnd\nIf length(NAME) >8  then do\n  Say 'Module name' NAME 'invalid - must be less that 8 chars.'\n  Say 'Please re-enter module name or pattern to find:'\n  Parse upper pull name\n  Call CHECK_MODNAME\nEnd\nReturn\n\nGET_LIBNAMES:\nCHKMBR = sysdsn(\"'\"mbrlib\"(\"member\")'\")\nIf  CHKMBR <> 'OK' then do\n  Say ''\n  Say 'Search list member 'member' does not exist in 'mbrlib\n  Say ''\n  Exit 8\nEnd\njunk = msg('off')\n\"ALLOC DA('\"||mbrlib||\"(\"||member||\")') F(LIBLIST) SHR REUSE\"\n\"EXECIO * DISKR LIBLIST (STEM LIST. FINIS\"\n\"FREE F(LIBLIST)\"\njunk = msg('on')\nDo COUNT = 1 to LIST.0\n  LIBNAME = word(LIST.COUNT,1)\n  If substr(LIBNAME,1,1) = '*' then iterate\n  NUMLIBS = NUMLIBS + 1\n  LIB.NUMLIBS = LIBNAME\nEnd /* do count */\nLIB.0 = NUMLIBS   /* tot libs to search*/\nReturn\n\nGET_LPALNK:\nCVT      = C2d(Storage(10,4))                /* point to CVT        */\nFMIDNUM  = Storage(D2x(CVT - 32),7)          /* point to fmid       */\n/*                                                                  */\n/* GET LPA LIST                                                     */\n/*                                                                  */\nCVTSMEXT = C2d(Storage(D2x(CVT + 1196),4))  /* point to stg map ext.*/\nCVTEPLPS = C2d(Storage(D2x(CVTSMEXT+56),4)) /* point to stg map ext.*/\nNUMLPA   = C2d(Storage(D2x(CVTEPLPS+4),4))  /* # LPA libs in table  */\nLPAOFF   = 8                                /* first ent in LPA tbl */\nDo I = 1 to NUMLPA\n  LEN = C2d(Storage(D2x(CVTEPLPS+LPAOFF),1)) /* length of entry     */\n  DSN = Storage(D2x(CVTEPLPS+LPAOFF+1),LEN)  /* DSN of LPA library  */\n  LPAOFF = LPAOFF + 44 + 1                   /* next entry in table */\n  NUMLIBS = NUMLIBS + 1                      /* add 1 to tot libs   */\n  LIB.NUMLIBS = DSN                          /* add dsn to stem     */\nEnd\n/*                                                                  */\n/* GET LNKLST                                                       */\n/*                                                                  */\nIf Substr(FMIDNUM,4,4) < 6602 then do   /* pre os/390 1.2 system?   */\n  CVTLLTA  = C2d(Storage(D2x(CVT + 1244),4))  /* point to lnklst tbl*/\n  NUMLNK   = C2d(Storage(D2x(CVTLLTA+4),4))   /* # LNK libs in table*/\n  LNKOFF   = 8                                /*first ent in LBK tbl*/\n  SETNAME  = ''   /* no LNKLST set for pre OS/390 1.2 systems       */\n  Do I = 1 to NUMLNK\n     LEN = C2d(Storage(D2x(CVTLLTA+LNKOFF),1)) /* length of entry   */\n     DSN = Storage(D2x(CVTLLTA+LNKOFF+1),LEN)  /* DSN of LNK lib    */\n     LNKOFF = LNKOFF + 44 + 1                  /* next entry in tbl */\n     NUMLIBS = NUMLIBS + 1                     /* add 1 to tot libs */\n     LIB.NUMLIBS = DSN                         /* add dsn to stem   */\n  End\nEnd\nElse do  /* OS/390 1.2 and above - PROGxx capable LNKLST            */\n  ASCB     = C2d(Storage(224,4))             /* point to ASCB       */\n  ASSB     = C2d(Storage(D2x(ASCB+336),4))   /* point to ASSB       */\n  DLCB     = C2d(Storage(D2x(ASSB+236),4))   /* point to CSVDLCB    */\n  SETNAME  = Storage(D2x(DLCB + 36),16)      /* LNKLST set name     */\n  SETNAME  = Strip(SETNAME,'T')              /* del trailing blanks */\n  CVTLLTA  = C2d(Storage(D2x(DLCB + 16),4))  /* point to lnklst tbl */\n  LLTX     = C2d(Storage(D2x(DLCB + 20),4))  /* point to LLTX       */\n  NUMLNK   = C2d(Storage(D2x(CVTLLTA+4),4))  /* # LNK libs in table */\n  LNKOFF   = 8                               /*first ent in LLT tbl */\n  Do I = 1 to NUMLNK\n    LEN = C2d(Storage(D2x(CVTLLTA+LNKOFF),1))  /* length of entry   */\n    LKDSN = Storage(D2x(CVTLLTA+LNKOFF+1),LEN) /* DSN of LNK lib    */\n    LNKOFF = LNKOFF + 44 + 1                   /* next entry in LLT */\n    NUMLIBS = NUMLIBS + 1                      /* add 1 to tot libs */\n    LIB.NUMLIBS = LKDSN                        /* add dsn to stem   */\n  End\n  SETNAME  = ' Set 'SETNAME\nEnd\nLIB.0 = NUMLIBS                                /* tot libs to search*/\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FVE": {"ttr": 3585, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\t\"o\\x01\\t\"o\\x130\\x00\\xc5\\x00\\xb5\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf8@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2009-08-14T00:00:00", "modifydate": "2009-08-14T13:30:00", "lines": 197, "newlines": 181, "modlines": 0, "user": "CBT478"}, "text": "/* REXX */\n/*                                       */\n/* AUTHOR: Mark Zelden                   */\n/* Last Updated 08/14/2009               */\n/***********************************************************/\n/*  FVE - Fast View/Edit                                   */\n/*                                                         */\n/*  Command to VIEW or EDIT members from libraries.        */\n/*  It is intended to be used with ISPF command table      */\n/*  entries to create \"shortcuts\" for VIEWing/EDITing      */\n/*  data sets or data set concatenations.                  */\n/***********************************************************/\n/*  Here are example command table entries for short cuts  */\n/*  to VIEWing/EDITing SYS1.PARMLIB and SYS1.PROCLIB:      */\n/*                                                         */\n/*  VERB   = PARM                                          */\n/*  ACTION = SELECT CMD(%FVE PARM &ZPARM) NEWAPPL(ISR)     */\n/*  VERB   = PROC                                          */\n/*  ACTION = SELECT CMD(%FVE PROC &ZPARM) NEWAPPL(ISR)     */\n/*                                                         */\n/*  Assuming the above command table entry, the invocation */\n/*  syntax for VIEWing/EDITing SYS1.PARMLIB would be:      */\n/*                                                         */\n/*  PARM mbrname <mode>                                    */\n/*                                                         */\n/*  MBRNAME = Any valid member name or pattern             */\n/*  MODE    = VIEW , EDIT, or BROWSE                       */\n/*                                                         */\n/*  The default mode is set below for each library in the  */\n/*  REXX code. It can be overriden when specified as the   */\n/*  second parm. If you want to override the default mode, */\n/*  and see all members of the library, then you must      */\n/*  specify '*' as the second parameter.                   */\n/*                                                         */\n/*  EXAMPLES: PARM   (VIEW all members)                    */\n/*            PARM * E (EDIT all members)                  */\n/*            PARM PROG*                                   */\n/*            PARM PROG* BROWSE                            */\n/*            PARM IEA* EDIT                               */\n/*            PARM IEA* E                                  */\n/*            PARM IEA* V                                  */\n/*            PARM IEA* B                                  */\n/*                                                         */\n/*  If you don't want to (or can't) update the ISPF        */\n/*  command table, you can still use this as a \"regular\"   */\n/*  REXX exec.                                             */\n/*                                                         */\n/*  EXAMPLES: TSO %FVE PARM   (VIEW all members)           */\n/*            TSO %FVE PARM * E (EDIT all members)         */\n/*            TSO %FVE PARM PROG*                          */\n/*            TSO %FVE PARM PROG* BROWSE                   */\n/*            TSO %FVE PARM IEA* EDIT                      */\n/*            TSO %FVE PARM IEA* E                         */\n/*            TSO %FVE PARM IEA* V                         */\n/*            TSO %FVE PARM IEA* B                         */\n/*                                                         */\n/***********************************************************/\n/*  *** WARNING *** WARNING *** WARNING *** WARNING ***    */\n/*                                                         */\n/*  When working with library concatenations in EDIT mode, */\n/*  the member will always appear as though it was found   */\n/*  in the first library when selected - regardless of     */\n/*  which library it was actually found in.  This also     */\n/*  means that any SAVE command (either explicit or        */\n/*  AUTOSAVE) will be attempted to the first library in    */\n/*  the concatenation. VIEW and BROWSE will show the       */\n/*  proper library when you select a member by exact name  */\n/*  or from a member list.  This is standard ISPF behavior */\n/*  when working with concatenations and can't be changed. */\n/*                                                         */\n/***********************************************************/\n/* TRACE ?R */\narg VERB MBR MODE\n/***************************************/\n/* Determine system name, smfid and    */\n/* sysclone for later usee             */\n/***************************************/\nSYSNAME  = Mvsvar('SYSNAME')              /* SYSNAME  value */\nSMFNAME  = Mvsvar('SYSSMFID')             /* SMFID    value */\nSYSCLONE = Mvsvar('SYSCLONE')             /* SYSCLONE value */\n/***************************************/\n/* Define libraries and modes below    */\n/***************************************/\nSelect\n  When VERB = 'CNTL' | VERB = 'MYCNTL' then do\n    If MODE = '' then  MODE = 'EDIT'\n    DSN =  \"'userid.lib.CNTL'\"\n  End\n  When VERB = 'MACLIB' then do\n    If MODE = '' then  MODE = 'VIEW'\n    DSN = \"'SYS1.MACLIB','SYS1.MODGEN'\"\n  End\n  When VERB = 'VTAM' then do\n    If MODE = '' then  MODE = 'VIEW'\n      DSN =  \"'SYS1.VTAMLST'\"\n  End\n  When VERB = 'PARM' then do\n    If MODE = '' then  MODE = 'VIEW'\n       DSN = \"'SYS1.PARMLIB','SYS1.IBM.PARMLIB'\"   /* dflt */\n    If SMFNAME = 'SYSA' | ,\n       SMFNAME = 'SYSB' | ,\n       SMFNAME = 'SYSC' then do\n       DSN = \"'SYS1.PRODPLEX.PARMLIB','SYS1.IBM.PARMLIB',\" || ,\n             \"'SYS1.SHASPARM',\" || ,\n             \"'SYS1.PARMLIB'\"\n    End\n    If SMFNAME = 'SYSD' | ,\n       SMFNAME = 'SYSE' then do\n       DSN = \"'SYS1.TESTPLEX.PARMLIB','SYS1.IBM.PARMLIB',\" || ,\n             \"'SYS1.SHASPARM',\" || ,\n             \"'SYS1.PARMLIB'\"\n    End\n  End\n  When VERB = 'IPLPARM' then do\n    If MODE = '' then  MODE = 'VIEW'\n    DSN =  \"'SYS1.IPLPARM'\"\n /* DSN =  \"'SYS1.PARMLIB'\" */ /* use parmlib for IPLPARM */\n  End\n  When VERB = 'PROC' | VERB = 'SYSPROC' then do\n    If MODE = '' then  MODE = 'VIEW'\n       DSN = \"'SYS1.PROCLIB','SYS1.IBM.PROCLIB'\"   /* dflt */\n    If SMFNAME = 'SYSA' | ,\n       SMFNAME = 'SYSB' | ,\n       SMFNAME = 'SYSC' then do\n       DSN = \"'SYS1.\"SMFNAME\".PROCLIB',\" || ,\n             \"'SYS1.PRODPLEX.PROCLIB',\" || ,\n             \"'SYS1.PROCLIB',\" || ,\n             \"'SYS1.IBM.PROCLIB'\"\n    End\n    If SMFNAME = 'SYSD' | ,\n       SMFNAME = 'SYSE' then do\n       DSN = \"'SYS1.\"SMFNAME\".PROCLIB',\" || ,\n             \"'SYS1.TESTPLEX.PROCLIB',\" || ,\n             \"'SYS1.PROCLIB',\" || ,\n             \"'SYS1.IBM.PROCLIB'\"\n    End\n  End\n  When VERB = 'PRODPROC' then do\n    If MODE = '' then  MODE = 'VIEW'\n    DSN = \"'PROD.PROCLIB1',\" || ,\n          \"'PROD.PROCLIB2',\" || ,\n          \"'PROD.PROCLIB3',\" || ,\n          \"'PROD.PROCLIB4'\"\n  End\n  When VERB = 'PRODJCL' then do\n    If MODE = '' then  MODE = 'VIEW'\n    DSN = \"'PROD.JCLLIB1',\" || ,\n          \"'PROD.JCLLIB2',\" || ,\n          \"'PROD.JCLLIB3',\" || ,\n          \"'PROD.JCLLIB4'\"\n  End\n/***************************************/\n  Otherwise\n  Say 'FVE001E - Error in ISPF Command Table or' ,\n      'command/library not coded in FVE EXEC'\n  Exit 12\nEnd  /* select */\n /*                             */\nAddress TSO\njunk = msg(off)\nddnm = 'DD'||random(1,99999)   /* choose random ddname  */\n\"FREE FILE(\"||ddnm||\")\"\n\"ALLOC FILE(\"||ddnm||\") SHR REUSE DA(\"||dsn||\")\"\njunk = msg(on)\n /*                             */\nAddress ISPEXEC\n\"CONTROL ERRORS RETURN\"\n\"LMINIT DATAID(TEMP) DDNAME(\"||ddnm||\")\"\n /*                             */\nMODE = Strip(MODE)  /* remove leading & trailing blanks */\nIf Abbrev('EDIT',MODE,1) <> 0 then ,\n  If mbr = '' | mbr = '*' then \"EDIT DATAID(\"||temp\")\"\n    Else \"EDIT DATAID(\"||temp\") MEMBER(\"||mbr||\")\"\nElse\nIf Abbrev('VIEW',MODE,1) <> 0 then ,\n  If mbr = '' | mbr = '*' then \"VIEW DATAID(\"||temp\")\"\n    Else \"VIEW DATAID(\"||temp\") MEMBER(\"||mbr||\")\"\nElse\nIf Abbrev('BROWSE',MODE,1) <> 0 then ,\n  If mbr = '' | mbr = '*' then \"BROWSE DATAID(\"||temp\")\"\n    Else \"BROWSE DATAID(\"||temp\") MEMBER(\"||mbr||\")\"\nElse do\nzedsmsg = 'Invalid mode-BROWSE used'\nzedlmsg = 'The mode specified was not \"EDIT\"/\"VIEW\"/\"BROWSE\".',\n          '\"BROWSE\" mode was used.'\n\"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n  If mbr = '' | mbr = '*' then \"BROWSE DATAID(\"||temp\")\"\n    Else \"BROWSE DATAID(\"||temp\") MEMBER(\"||mbr||\")\"\n  End\n /*                             */\nRETCD = RC\nIf RETCD = 4 then  RETCD = 0\nIF RETCD <> 0 THEN Address ISPEXEC \"SETMSG MSG(&ZERRMSG)\"\n\"LMFREE DATAID(\"||temp\")\"\nAddress TSO\njunk = msg(off)\n\"FREE FILE(\"||ddnm||\")\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HLISTB": {"ttr": 3589, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x08\\x10\\x7f\\x01\\x08\\x10\\x7f\\x15\\x00\\x00\\x1f\\x00\\x1f\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-04-16T00:00:00", "modifydate": "2008-04-16T15:00:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "CBT476"}, "text": "/* REXX */\n/*                           */\n/* AUTHOR: MARK ZELDEN       */\n/*                           */\n /* ========================================================== */\n /* HLIST BACKUP (BCDS) LINE COMMAND FOR DSN PANEL OPTION 3.4  */\n /* THE OUTPUT IS PUT IN A DATA SET AND BROWSED                */\n /* ========================================================== */\n /* ADDRESS ISPEXEC \"VGET ZDLDSN SHARED\"  */\n/* TRACE ?I */\narg NAME\naddress TSO\nif NAME = '' then do\n  say 'PLEASE ENTER DATASET NAME TO LIST:'\n  parse upper pull NAME\nend\naddress ISPEXEC \"CONTROL ERRORS RETURN\"\nddnm = 'DD'||random(1,99999)    /* choose random ddname  */\nodsn = sysvar(sysuid)||\".HLISTB.\"||ddnm\n/*                                     */\n/*  issue hlist command                */\n/*                                     */\n\"HLIST DA (\"name\") BCDS ODS('\"|| odsn || \"')\"\n/*                                     */\nretcode = rc\naddress ISPEXEC \"BROWSE DATASET('\"|| odsn || \"')\"\nzdlmsg = 'LISTED RC='||retcode\njunk =msg(off)\n\"DELETE '\"|| odsn || \"'\"\njunk =msg(on)\naddress ispexec \"VPUT ZDLMSG SHARED\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HLISTBL": {"ttr": 3591, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x08\\x10\\x7f\\x01\\x08\\x10\\x7f\\x15\\x00\\x00\\x1e\\x00\\x1e\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-04-16T00:00:00", "modifydate": "2008-04-16T15:00:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "CBT476"}, "text": "/* REXX */\n/*                           */\n/* AUTHOR: MARK ZELDEN       */\n/*                           */\n /* ========================================================== */\n /* HLIST DA LEVEL BACKUP COMMAND                              */\n /* THE OUTPUT IS PUT IN A DATA SET AND BROWSED                */\n /* ========================================================== */\n/* TRACE ?I */\narg NAME\naddress TSO\nif NAME = '' then do\n  say 'PLEASE ENTER DATASET NAME LEVEL TO LIST:'\n  parse upper pull NAME\nend\naddress ISPEXEC \"CONTROL ERRORS RETURN\"\nddnm = 'DD'||random(1,99999)    /* choose random ddname  */\nodsn = sysvar(sysuid)||\".HLISTBL.\"||ddnm\n/*                                     */\n/*  issue hlist command                */\n/*                                     */\n\"HLIST DA LEVEL(\"name\") BCDS ODS('\"|| odsn || \"')\"\n/*                                     */\nretcode = rc\naddress ISPEXEC \"BROWSE DATASET('\"|| odsn || \"')\"\nzdlmsg = 'LISTED RC='||retcode\njunk =msg(off)\n\"DELETE '\"|| odsn || \"'\"\njunk =msg(on)\naddress ispexec \"VPUT ZDLMSG SHARED\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HLISTM": {"ttr": 3593, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x08\\x10\\x7f\\x01\\x08\\x10\\x7f\\x15\\x00\\x00\\x1f\\x00\\x1f\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-04-16T00:00:00", "modifydate": "2008-04-16T15:00:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "CBT476"}, "text": "/* REXX */\n/*                           */\n/* AUTHOR: MARK ZELDEN       */\n/*                           */\n /* =========================================================== */\n /* HLIST MIGRATE (MCDS) LINE COMMAND FOR DSN PANEL OPTION 3.4  */\n /* THE OUTPUT IS PUT IN A DATA SET AND BROWSED                 */\n /* =========================================================== */\n /* ADDRESS ISPEXEC \"VGET ZDLDSN SHARED\"  */\n/* TRACE ?I */\narg NAME\naddress TSO\nif NAME = '' then do\n  say 'PLEASE ENTER DATASET NAME TO LIST:'\n  parse upper pull NAME\nend\naddress ISPEXEC \"CONTROL ERRORS RETURN\"\nddnm = 'DD'||random(1,99999)    /* choose random ddname  */\nodsn = sysvar(sysuid)||\".HLISTM.\"||ddnm\n/*                                     */\n/*  issue hlist command                */\n/*                                     */\n\"HLIST DA (\"name\") MCDS ODS('\"|| odsn || \"')\"\n/*                                     */\nretcode = rc\naddress ISPEXEC \"BROWSE DATASET('\"|| odsn || \"')\"\nzdlmsg = 'LISTED RC='||retcode\njunk =msg(off)\n\"DELETE '\"|| odsn || \"'\"\njunk =msg(on)\naddress ispexec \"VPUT ZDLMSG SHARED\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HLISTML": {"ttr": 3595, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x08\\x10\\x7f\\x01\\x08\\x10\\x7f\\x15\\x00\\x00\\x1e\\x00\\x1e\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-04-16T00:00:00", "modifydate": "2008-04-16T15:00:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "CBT476"}, "text": "/* REXX */\n/*                           */\n/* AUTHOR: MARK ZELDEN       */\n/*                           */\n /* ========================================================== */\n /* HLIST DA LEVEL MIGRATE COMMAND                             */\n /* THE OUTPUT IS PUT IN A DATA SET AND BROWSED                */\n /* ========================================================== */\n/* TRACE ?I */\narg NAME\naddress TSO\nif NAME = '' then do\n  say 'PLEASE ENTER DATASET NAME LEVEL TO LIST:'\n  parse upper pull NAME\nend\naddress ISPEXEC \"CONTROL ERRORS RETURN\"\nddnm = 'DD'||random(1,99999)    /* choose random ddname  */\nodsn = sysvar(sysuid)||\".HLISTML.\"||ddnm\n/*                                     */\n/*  issue hlist command                */\n/*                                     */\n\"HLIST DA LEVEL(\"name\") MCDS ODS('\"|| odsn || \"')\"\n/*                                     */\nretcode = rc\naddress ISPEXEC \"BROWSE DATASET('\"|| odsn || \"')\"\nzdlmsg = 'LISTED RC='||retcode\njunk =msg(off)\n\"DELETE '\"|| odsn || \"'\"\njunk =msg(on)\naddress ispexec \"VPUT ZDLMSG SHARED\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INCL": {"ttr": 3597, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x992/\\x01\\x13(\\x0f\\x14\\x15\\x00\\x99\\x00N\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf7@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "2013-10-07T14:15:00", "lines": 153, "newlines": 78, "modlines": 0, "user": "CBT487"}, "text": "/* REXX */\n/*                           */\n/* AUTHOR: Mark Zelden       */\n/*                           */\n/* Last Updated 10/07/2013   */\n/*                           */\nhelp_start = HELP_INCL()\n/**********************************************************/\n/* This edit macro will include only lines that contain   */\n/* a specified search string.  The search string can      */\n/* optionally be limited to specific columns.             */\n/*                                                        */\n/* EXAMPLES:                                              */\n/*            INCL ' JOB'                                 */\n/*            INCL '//' 1 2                               */\n/*                                                        */\n/*                                                        */\n/*  ** NOTE    If you execute INCL with no parms or with  */\n/*             a parm of \"?\", the comment section of this */\n/*             code with examples will be displayed as    */\n/*             \"help\" note lines.  Use the \"RESET\"        */\n/*             command to remove them.                    */\n/*                                                        */\n/**********************************************************/\n/*                                                        */\n/*  \"HIDE EXCLUDED\" is used on systems that are running   */\n/*  z/OS 1.6 (ISPF 5.6) and above.                        */\n/*  Remove or comment out the following line of code      */\n/*  around line 118 if you like to see excluded lines     */\n/*  or issue the \"RESET HIDE\" command after you run       */\n/*  the EXCL macro.                                       */\n/*                                                        */\n/*    If Substr(ZENVIR,6,3) >= 5.5 then \"HIDE EXCLUDED\"   */\n/*                                                        */\n/**********************************************************/\nhelp_end = HELP_INCL()\n/* Trace ?R */\nAddress ISREDIT\n\"MACRO (parm col1 col2)\"\n /* Address ISPEXEC \"CONTROL ERRORS RETURN\"  */\nIf pos('&',parm) <> 0 then do\n  parmx = Translate(parm) /* upper case                  */\n  parmx = C2X(parmx)      /* change to hex for seek/find */\n  amp = 'Y'\nEnd\nIf parm = '?' then do\n  Call HELP_NOTELINES\n  Exit 1  /* return cursor to command line */\nEnd\nIf parm = '' then do\n  zedsmsg = 'NO SEARCH STRING'\n  zedlmsg = 'YOU MUST PASS A SEARCH STRING PARM',\n            'TO INCL.'\n  Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n  Call HELP_NOTELINES\n  Exit 4\nEnd\n/* check for numeric column numbers      */\nIf col1 <> '' then do\n  If Datatype(col1,Number) <> 1 then do\n    zedsmsg = 'START COLUMN NOT NUMERIC'\n    zedlmsg = 'THE STARTING COLUMN FOR THE',\n              'SEARCH MUST BE NUMERIC.'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\n  If col2 = '' then col2 = col1\nEnd\nIf col2 <> '' then do\n  If Datatype(col2,Number) <> 1 then do\n    zedsmsg = 'END COLUMN NOT NUMERIC'\n    zedlmsg = 'THE ENDING COLUMN FOR THE',\n              'SEARCH MUST BE NUMERIC.'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\n  If col2 < col1 then do\n    zedsmsg = 'END COL < START COL'\n    zedlmsg = 'THE ENDING COLUMN MUST BE GREATER THAN OR',\n              'EQUAL TO THE STARTING COLUMN.'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\n  If Length(Strip(Translate(parm,'','\"'''''))) ,\n    > COL2-COL1+1 then do\n    zedsmsg = 'PARM TOO LONG'\n    zedlmsg = 'THE STRING WILL NOT FIT BETWEEN THE',\n              'SPECIFIED COLUMNS.'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\n  \"(width) = DATA_WIDTH \"   /* length of line       */\n  width = Format(width)     /* remove leading zeros */\n  If col1 < 1 | col2 < 1 | col1 > width | col2 > width then do\n    zedsmsg = 'INVALID COLUMN NUMBER'\n    zedlmsg = 'ALL COLUMN SPECIFICATIONS MUST BE' ,\n              'BETWEEN 1 AND' width\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\nEnd\nparmck = Translate(parm)\nIf parmck = 'X' | parmck = 'NX' | parmck = '*' ,\n   | parmck = '/*' then parm = \"'\" ||parm|| \"'\"\nIf AMP = 'Y' then \"SEEK x'\"parmx\"'\" col1 col2\" FIRST\"\n  Else \"SEEK \"parm col1 col2\" FIRST\"\n   If rc = 0  then do\n      \"EXCLUDE ALL\"\n      If AMP = 'Y' then do\n        \"FIND x'\"parmx\"'\" col1 col2\" ALL\"\n        \"SEEK x'\"parmx\"'\" col1 col2\" ALL\"\n      End\n      Else do\n        \"FIND \"parm col1 col2\" ALL\"\n        \"SEEK \"parm col1 col2\" ALL\"\n      End\n      \"(count,lines) = SEEK_COUNTS\"\n       Address ISPEXEC \"VGET ZENVIR\"\n       If Substr(ZENVIR,6,3) >= 5.5 then \"HIDE EXCLUDED\"\n       count = Format(count)\n       lines = Format(lines)\n       parm = Translate(parm) /* upper case */\n       zedsmsg = count' \"'parm'\" FOUND'\n       zedlmsg = 'THE STRING \"'parm'\" WAS FOUND 'count' TIMES',\n                 'ON 'lines' LINES.'\n       Address ISPEXEC \"SETMSG MSG(ISRZ000)\"  /* msg - no alarm */\n       Exit 1  /* return cursor to command line */\n   End\n   Else do\n       parm = Translate(parm) /* upper case */\n       zedsmsg = 'STRING NOT FOUND'\n       zedlmsg = 'THE STRING \"'parm'\" WAS NOT FOUND IN THE FILE.'\n      \"RESET\"\n       Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n       Exit 12\n   End\n/*********************************/\n/*  HELP SUB-ROUTINES            */\n/*********************************/\nHELP_INCL:\nReturn SIGL\nHELP_NOTELINES:\n\"(helpln) = DISPLAY_LINES\"\nDo hlp = help_end-1 to help_start+1 by -1\n  hline = Sourceline(hlp)\n  \"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline)\"\nEnd\nhline2 = '==================='\nhline3 = '===   H E L P   ==='\n\"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline2)\"\n\"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline3)\"\n\"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline2)\"\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INDIRECR": {"ttr": 3601, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x011?\\x01\\x011?\\x100\\x00;\\x00\\x18\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf4\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-11-09T00:00:00", "modifydate": "2001-11-09T10:30:00", "lines": 59, "newlines": 24, "modlines": 0, "user": "CBT440"}, "text": "/* REXX */\nParse upper arg catname catvol\n/*                           */\n/* AUTHOR: MARK ZELDEN       */\n/*                           */\n/* TRACE R */\n/************************************************************/\n/*  This clist will take a list of dataset names allocated  */\n/*  to ddname 'INPUT' and create idcams control cards to    */\n/*  indirectly catalog the datasets in a dataset allocated  */\n/*  to ddname 'OUTPUT'. As coded, this exec allocates       */\n/*  the input/output files as members \"INPUT\" and \"OUTPUT\"  */\n/*  of a PDS defined by the \"workpds\" variable below.       */\n/*  Change the variable to a valid PDS that you can use.    */\n/*                                                          */\n/*  Please modify the CATNAME and CATVOL variables below    */\n/*  or pass them to the exec as needed.                     */\n/*     Example: TSO %INDIRECR MASTER.CAT &SYSR2             */\n/************************************************************/\nworkpds = 'userid.LIB.CNTL'\n/* */\nIf CATNAME = '' then\n   CATNAME = 'CATALOG.MASTER'     /* <===== CATALOG NAME  */\nIf CATVOL  = '' then\n   CATVOL  = '******'             /* <===== volser        */\n  /* other options for CATVOL = &SYSR1, &SYSR2 etc.       */\n/* */\n/******************************************/\n/* allocate input and output files        */\n/******************************************/\n\"ALLOC F(INPUT)  DA('\"|| workpds ||\"(INPUT)')  SHR REUSE\"\n\"ALLOC F(OUTPUT) DA('\"|| workpds ||\"(OUTPUT)') SHR REUSE\"\n/******************************************/\n/* read input file into stem variables    */\n/******************************************/\n\"EXECIO  *  DISKR INPUT (STEM INREC. FINIS\"\n/* */\nDo i = 1 to INREC.0\n/*inrec.i = strip(inrec.i)     remove leading and trailing blanks   */\n  inrec.i = Word(inrec.i,1) /* remove leading and trailing blanks   */\n  inrec.i = Translate(inrec.i) /* convert dsn to upper case if      */\n  outrec1 = ' DEL ('||inrec.i||') -'\n  outrec2 = ' NSCR CAT('||catname||')'\n  outrec3 = ' /*                                                   */ '\n  outrec4 = ' DEF NVSAM(NAME('||inrec.i||') -'\n  outrec5 = ' VOL('||catvol||') DEVT(0000)) -'\n  outrec6 = ' CAT('||catname||')'\n  outrec7 = ' /* * * * * * * * * * * * * * * * * * * * * * * * * * */ '\n  Do j = 1 to 7\n   Interpret queue outrec || j\n  End\nEnd  /* do i */\nQueue ''\n/******************************************/\n/* write output file and exit             */\n/******************************************/\n\"EXECIO * DISKW OUTPUT (FINIS\"\n\"FREE  F(INPUT OUTPUT)\"\nExit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INSLINE": {"ttr": 3841, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x992/\\x01\\x13(\\x0f\\x14\\x15\\x00\\xdf\\x00\\xd2\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf7@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "2013-10-07T14:15:00", "lines": 223, "newlines": 210, "modlines": 0, "user": "CBT487"}, "text": "/* REXX */\n/*                           */\n/* AUTHOR: Mark Zelden       */\n/*                           */\n/* Last Updated 10/07/2013   */\n/*                           */\nhelp_start = HELP_INCL()\n/***************************************************************/\n/*                                                             */\n/* This edit macro will insert a character string either       */\n/* AFTER or BEFORE all or specified lines. Excluded lines      */\n/* are always omitted. If \"PASTE\" is used as the first         */\n/* parm passed to the Macro (in place of a character string),  */\n/* the macro will insert lines that were previously \"CUT\"      */\n/* from the ISPF Default Clipboard. Note that you must be      */\n/* running ISPF 4.8 (OS/390 2.8) or above to use the \"PASTE\"   */\n/* option.                                                     */\n/*                                                             */\n/***************************************************************/\n/* COMMAND SYNTAX:                                             */\n/*                                                             */\n/*   INSLINE 'data to insert' < A | B > (.label1) (.label2)    */\n/*   INSLINE PASTE < A | B > (.label1) (.label2)               */\n/*                                                             */\n/*                                                             */\n/*  ** NOTE    If you execute INSLINE with no parms or with    */\n/*             a parm of \"?\", the comment section of this      */\n/*             code with syntax and usage notes will be        */\n/*             displayed as \"help\" note lines.  Use the        */\n/*             \"RESET\" command to remove them.                 */\n/*                                                             */\n/***************************************************************/\n/* COMMAND EXAMPLES:                                           */\n/*                                                             */\n/*  INSERT \"AFTER\"  EXAMPLES                                   */\n/*      INSLINE 'insert this after every line' A               */\n/*      INSLINE 'insert this after every line' A .FROM .TO     */\n/*      INSLINE PASTE A .FROM .TO                              */\n/*                                                             */\n/*  INSERT \"BEFORE\"  EXAMPLES                                  */\n/*      INSLINE 'insert this before every line' B              */\n/*      INSLINE 'insert this before every line' B .FROM .TO    */\n/*      INSLINE PASTE B .FROM .TO                              */\n/*                                                             */\n/***************************************************************/\nhelp_end = HELP_INCL()\n/* TRACE ?R */\nAddress ISREDIT\n\"MACRO (parm type label1 label2)\"\n /* Address ISPEXEC \"CONTROL ERRORS RETURN\"  */\n/***********************************************/\n/*   VERIFY INPUT PARAMETERS                   */\n/***********************************************/\ntype = Translate(type) /* ensure upper case */\n\nIf parm = '?' then do\n  Call HELP_NOTELINES\n  Exit 1  /* return cursor to command line */\nEnd\nIf parm = '' then do\n  zedsmsg = 'No insert data'\n  zedlmsg = 'You must specify the data to insert',\n            'as the first parameter or \"PASTE\".'\n  Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n  Call HELP_NOTELINES\n  Exit 4\nEnd\nIf type = '' then do\n  zedsmsg = 'No insert type'\n  zedlmsg = 'You must specify an insert type of \"A\"',\n            'or \"B\" as the second parameter.'\n  Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n  Exit 12\nEnd\nIf type <> 'A' & type<> 'B' then do\n  zedsmsg = 'Invalid insert type'\n  zedlmsg = 'You must specify an insert type of \"A\"',\n            'or \"B\" as the second parameter.'\n  Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n  Exit 12\nEnd\n/***********************************************/\n/*   FIND OUT IF LABELS ARE BEING USED         */\n/***********************************************/\nCall FIND_LABELS  /* find out if labels are being used  */\n/***********************************************/\n/* IF THE DATA IS IS DELIMTED BY SINGLE OR     */\n/* DOUBLE QUOTES - THEN REMOVE THE DELIMITERS  */\n/***********************************************/\nIf Substr(parm,1,1) = '''' | Substr(parm,1,1) = '\"' then\nparm = Substr(parm,2,Length(parm)-2)\n/***********************************************/\n/* Verify ISPF release for \"PASTE\" option      */\n/***********************************************/\nIf Translate(parm) = 'PASTE' then do\n  Address ISPEXEC \"VGET ZENVIR\"\n  If Substr(ZENVIR,6,3) < 4.8 then do\n    zedsmsg = '\"PASTE\" not supported'\n    zedlmsg = 'You must be running ISPF Verion 4.8 (OS/390 2.8)',\n              'or above to use the \"PASTE\" option.'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\nEnd\n/***********************************************/\n/* MAKE SURE DATA WILL \"FIT\"                   */\n/***********************************************/\n\"(width) = DATA_WIDTH \" /* length of line  */\nIf Length(parm) > width then do\n  width = width + 0 /* remove leading zeros */\n  zedsmsg = 'Data too long'\n  zedlmsg = 'The insert data is too ling to fit on a line',\n            '(MAXLEN =' width || ').'\n  Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n  Exit 12\nEnd\n/***********************************************/\n/*   BEGIN INSERT PROCESSING                   */\n/***********************************************/\nIf type = 'A' then line_type = 'LINE_AFTER'\n   else line_type = 'LINE_BEFORE'\ncount = lastln - firstln + 1\nDo count\n  \"ISREDIT (chkexcl) = XSTATUS\" firstln\n  If chkexcl = \"X\" then do   /* is line excluded?       */\n    firstln = firstln + 1    /* yes, skip it            */\n    count = count-1          /* correct total count     */\n    iterate                  /* get next record         */\n  End\n  /******************************************************/\n  /* INSERT DATA FROM MACRO INVOCATION PARM             */\n  /******************************************************/\n  If Translate(parm) <> 'PASTE' then do\n    /* line_type firstln \"= DATALINE '\" || parm || \"'\"  */\n    line_type firstln \"= DATALINE (parm)\"\n    firstln = firstln + 2    /* bump up line counter    */\n  End\n  /******************************************************/\n  /* INSERT DATA FROM ISPF DEFAULT CLIPBOARD (PASTE)    */\n  /******************************************************/\n  Else do\n    nextln=firstln+1  /* point to next line                      */\n    \"ISREDIT LABEL (firstln) = .HERE\" /* add label for paste     */\n    If lastln >= nextln then \"ISREDIT LABEL (nextln) =  .NEXT\"\n    Address ISPEXEC \"CONTROL ERRORS RETURN\"\n    If type = 'A' then \"PASTE AFTER .HERE KEEP\" /* paste data    */\n    Else  \"PASTE BEFORE .HERE KEEP\"             /* paste data    */\n    If RC = 12 then do\n      zedsmsg = 'No \"CUT\" data'\n      zedlmsg = 'There is no data to \"PASTE\" from the ISPF' ,\n                'Default Clipboard.'\n      Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n      Exit 12\n    End /* if RC = 12 */\n    Address ISPEXEC \"CONTROL ERRORS CANCEL\"\n    \"(firstln) = LINENUM .NEXT\"       /* bump up line counter    */\n    \"(lastln) = LINENUM .ZLAST\" /* fix last line pointer         */\n  End /* else do */\nEnd\n/***********************************************/\n/*   END INSERT PROCESSING                     */\n/***********************************************/\nIf type = 'A' then mtype = 'after'\n  Else mtype = 'before'\nIf Translate(parm) = 'PASTE' then do\n  zedsmsg = count 'PASTES inserted'\n  zedlmsg = 'Data was inserted via PASTE' mtype count 'lines.'\nEnd\nElse do\n  zedsmsg = count 'lines inserted'\n  zedlmsg = parm 'was inserted' mtype count 'lines.'\nEnd\nAddress ISPEXEC \"SETMSG MSG(ISRZ000)\"  /* msg - no alarm */\nExit 1  /* return cursor to command line */\n/*********************************/\n/*  HELP SUB-ROUTINES            */\n/*********************************/\nHELP_INCL:\nReturn SIGL\nHELP_NOTELINES:\n\"(helpln) = DISPLAY_LINES\"\nDo hlp = help_end-1 to help_start+1 by -1\n  hline = Sourceline(hlp)\n  \"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline)\"\nEnd\nhline2 = '==================='\nhline3 = '===   H E L P   ==='\n\"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline2)\"\n\"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline3)\"\n\"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline2)\"\nReturn\n/*********************************/\n/*  SUB-ROUTINE TO FIND LABELS   */\n/*********************************/\nFIND_LABELS:\nAddress ISPEXEC \"CONTROL ERRORS RETURN\"\nIf label1 = '' then do\n  firstln  = 1\n  \"(lastln) = LINENUM .ZLAST\"\nEnd\nElse do\n  If label2 = '' then label2 = label1\n  \"(firstsv)  = LINENUM\" label1\n  If RC >= 8 then do\n    zedsmsg = 'RANGE LABEL ERROR'\n    zedlmsg = 'THE SPECIFIED RANGE LABEL \"' || label1 '\" WAS',\n              'NOT FOUND'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\n  \"(lastsv)   = LINENUM\" label2\n  If RC >= 8 then do\n    zedsmsg = 'RANGE LABEL ERROR'\n    zedlmsg = 'THE SPECIFIED RANGE LABEL \"' || label2 '\" WAS',\n              'NOT FOUND'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\n  firstln = Min(firstsv,lastsv)\n  lastln  = Max(firstsv,lastsv)\nAddress ISPEXEC \"CONTROL ERRORS\"\nEnd /* else do */\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IPLHIST": {"ttr": 3846, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x10\\to\\x01\\x13\\x01\\x7f\\t\\x06\\x00,\\x00!\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-04-06T00:00:00", "modifydate": "2013-01-17T09:06:04", "lines": 44, "newlines": 33, "modlines": 0, "user": "CBT486"}, "text": "/* REXX */\n/*                                       */\n/* AUTHOR: Mark Zelden                   */\n/*                                       */\n/*********************************************************************/\n/* One line IPL information using the IPLINFO rexx function.         */\n/*                                                                   */\n/* This exec is called by the IPLHIST started task. The most current */\n/* IPL information is written to the top of the HISTOUT file.        */\n/*                                                                   */\n/* IPLHIST should be executed at IPL time and can be started from    */\n/* the COMMNDxx parmlib member.  The history data set should be a    */\n/* PDS allocated with LRECL=80 if using this sample code. PDSE       */\n/* is okay as long as all systems writing to the data set are        */\n/* in the same sysplex and extended PDSE sharing is enabled.         */\n/*                                                                   */\n/* Used in conjuntion with the \"LASTIPL\" exec you can get a          */\n/* summary of the most recent IPL informatiom from all systems       */\n/* sharing the history data set.                                     */\n/*                                                                   */\n/*                                                                   */\n/* Sample IPLHIST PROC:                                              */\n/*                                                                   */\n/*   //IPLHIST  PROC                                                 */\n/*   //IPLHIST EXEC PGM=IKJEFT01,REGION=4M,PARM='%IPLHIST'           */\n/*   //SYSPROC  DD  DSN=lib.with.iplinfo.and.iplhist,DISP=SHR        */\n/*   //SYSOUT   DD  SYSOUT=*                                         */\n/*   //SYSTSPRT DD  SYSOUT=*                                         */\n/*   //SYSTSIN  DD  DUMMY                                            */\n/*   //HISTIN   DD  DSN=SYS1.IPL.HISTORY($&SYSNAME.),DISP=SHR        */\n/*   //HISTOUT  DD  DSN=SYS1.IPL.HISTORY($&SYSNAME.),DISP=SHR        */\n/*                                                                   */\n/*********************************************************************/\nIPL_SUM  = Iplinfo(var,ipldate,ipltime,iplvol,ipladdr,iplparm)\nparse var IPL_SUM ipldate ipltime iplvol ipladdr iplparm\n\nqueue 'Date:'ipldate ' Time:'ipltime ' Vol:'iplvol ,\n    ' Load addr:'ipladdr ' LOADPARM:'iplparm\n\"EXECIO * DISKR HISTIN (STEM INREC. FINIS\"\nDo I = 1 to INREC.0\n  queue inrec.i\nEnd\nqueue ''\n\"EXECIO * DISKW HISTOUT (FINIS\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IPLINFO": {"ttr": 3848, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x992/\\x01 &\\x8f E\\x0e\\x02\\x05\\x9f\\x00\\x00\\xc3\\xc2\\xe3\\xf5\\xf0\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "2020-09-24T20:45:00", "lines": 3586, "newlines": 1439, "modlines": 0, "user": "CBT500"}, "text": "/* REXX */\n/*                                       */\n/* AUTHOR: Mark Zelden                   */\n/*                                       */\n/* Trace ?r */\n/*                                                                   */\n/*********************************************************************/\n/*                                                                   */\n/*   D I S C L A I M E R                                             */\n/*   -------------------                                             */\n/*                                                                   */\n/* This program is FREEWARE. Use at your own risk.  Neither Mark     */\n/* Zelden, nor other contributing organizations or individuals       */\n/* accept any liability of any kind howsoever arising out of the use */\n/* of this program. You are free to use and modify this program as   */\n/* you desire, however, the author does ask that you leave his name  */\n/* in the source and give credit to him as the original programmer.  */\n/*                                                                   */\n/*********************************************************************/\n/* IPLINFO:  DISPLAY SYSTEM INFORMATION ON TERMINAL                  */\n/*********************************************************************/\n/*                                                                   */\n/* IPLINFO can be called as an interactive exec / ISPF edit macro    */\n/* or in batch to display various system information.  The result    */\n/* will be displayed in an ISPF browse data set if ISPF is active.   */\n/*                                                                   */\n/* IPLINFO can also be called as a REXX function to return from 1    */\n/* to 20 variables used in the exec at their final value.  If more   */\n/* than one variable is requested the variables are returned with    */\n/* a blank or user defined delimiter between each variable so they   */\n/* may be parsed if desired.                                         */\n/*                                                                   */\n/* See below for the sytax of each method.                           */\n/*                                                                   */\n/*********************************************************************/\n/*                                                                   */\n/* EXECUTION SYNTAX:                                                 */\n/*                                                                   */\n/* TSO %IPLINFO <option>                                             */\n/*                                                                   */\n/* VALID OPTIONS ARE 'ALL', 'IPL', 'VERsion', 'STOrage', 'CPU',      */\n/*                   'IPA', 'SYMbols', 'VMAp', 'PAGe', 'SMF', 'SUB', */\n/*                   'ASId', 'LPA', 'LNKlst', 'APF' and 'SVC'        */\n/*                                                                   */\n/* ** 'ALL' is the default option                                    */\n/* ** Options may be abbreviated by using 3 or more characters       */\n/*                                                                   */\n/* ** A 2nd parameter option of 'NOBrowse' may also be specified to  */\n/*    eliminate browsing the output even when ISPF is active. This   */\n/*    will allow any IPLINFO output to be trapped and parsed from    */\n/*    another exec or edit macro if desired.  The 'NOBrowse' option  */\n/*    can also be specified as the only option and it will produce   */\n/*    all IPLINFO output without browsing it.                        */\n/*                                                                   */\n/* ** A 2nd parameter option of 'EDIt' may also be specified to      */\n/*    EDIT the output instead of browsing it. The 'EDIt' option      */\n/*    can also be specified as the only option and it will produce   */\n/*    all IPLINFO output without editing it.                         */\n/*                                                                   */\n/* ** The following options are not documented above as standard     */\n/*    options nor in the help panel:                                 */\n/*      \"ASVt\"   - an alias for the \"ASId\" option                    */\n/*      \"ASM\"    - an alias for the \"PAGE\" option                    */\n/*      \"SSI\"    - an alias for the \"SUB\"  option                    */\n/*      \"SSN\"    - an alias for the \"SUB\"  option                    */\n/*      \"STOre\"  - an alias for the \"STORage\"  option                */\n/*      \"MEMory\" - an alias for the \"STORage\"  option                */\n/*      \"SUBsystems\" - an alias for the \"SUB\"  option                */\n/*      \"NOBrowse\"   - the NOBrowse option                           */\n/*      \"EDIt\"       - the EDIt option                               */\n/*                                                                   */\n/* Examples:                                                         */\n/*  TSO %IPLINFO         (Display all information)                   */\n/*  TSO %IPLINFO VMAP    (Display a Virtual Storage Map)             */\n/*  TSO %IPLINFO SYM     (Display Static System Symbols)             */\n/*  TSO %IPLINFO SUB     (Display Subsystem Information)             */\n/*  TSO %IPLINFO APF     (Display APF Library List)                  */\n/*  TSO %IPLINFO ALL NOB (Display all infomation, don't browse O/P)  */\n/*  TSO %IPLINFO SUB NOB (Display subsys info, don't browse O/P)     */\n/*  TSO %IPLINFO NOBROWSE (Display all infomation, don't browse O/P) */\n/*  TSO %IPLINFO ALL EDI (Display all infomation, edit O/P)          */\n/*  TSO %IPLINFO SUB EDI (Display subsys info, edit O/P)             */\n/*  TSO %IPLINFO EDIT    (Display all infomation, edit O/P)          */\n/*                                                                   */\n/* Edit macro invocation:                                            */\n/*  IPLINFO              (Display all information)                   */\n/*  IPLINFO VMAP         (Display a Virtual Storage Map)             */\n/*  IPLINFO SYM          (Display Static System Symbols)             */\n/*  IPLINFO SUB          (Display Subsystem Information)             */\n/*  IPLINFO APF          (Display APF Library List)                  */\n/*  IPLINFO ALL NOB      (Display all infomation, don't browse O/P)  */\n/*  IPLINFO SUB NOB      (Display subsys info, don't browse O/P)     */\n/*  IPLINFO NOBROWSE     (Display all infomation, don't browse O/P)  */\n/*  IPLINFO ALL EDIT     (Display all infomation, edit O/P)          */\n/*  IPLINFO SUB EDIT     (Display subsys info, edit O/P)             */\n/*  IPLINFO EDIT         (Display all infomation, edit O/P)          */\n/*                                                                   */\n/* Sample Unix System Services WEB Server execution via links:       */\n/*  <a href=\"/cgi-bin/iplinfo\">MVS Information</a>                   */\n/*  <a href=\"/cgi-bin/iplinfo?vmap\">Virtual Storage Map</a>          */\n/*  <a href=\"/cgi-bin/iplinfo?symbols\">Static System Symbols</a>     */\n/*  <a href=\"/cgi-bin/iplinfo?sub\">Subsystem Information</a>         */\n/*  <a href=\"/cgi-bin/iplinfo?apf\">APF Library List</a>              */\n/*                                                                   */\n/*********************************************************************/\n/*                                                                   */\n/* FUNCTION SYNTAX:                                                  */\n/*                                                                   */\n/* IPLINFO(VAR,var1_name)                                            */\n/* IPLINFO(VAR,var1_name,var2_name,var3_name, ... var20_name)        */\n/*                                                                   */\n/* Examples:                                                         */\n/*  sysname = IPLINFO(VAR,GRSNAME)                                   */\n/*  pvtsize = IPLINFO(VAR,GDAPVTSZ)                                  */\n/*                                                                   */\n/*                                                                   */\n/*  /* REXX one line IPL information using IPLINFO rexx function */  */\n/*  IPL_SUM  = IPLINFO(VAR,ipldate,ipltime,iplvol,ipladdr,iplparm)   */\n/*  Parse var IPL_SUM ipldate ipltime iplvol ipladdr iplparm         */\n/*  Say 'Date:'ipldate  ' Time:'ipltime ' Vol:'iplvol ,              */\n/*      ' Load addr:'ipladdr ' LOADPARM:'iplparm                     */\n/*                                                                   */\n/*                                                                   */\n/*  NOTE: The default delimeter between returned variables is a      */\n/*        blank. However, this can be problematic when the returned  */\n/*        value contains a blank or is null. You can optionally      */\n/*        change the delimiter from a blank to one of your choice    */\n/*        by using \"VAR2\" instead of \"VAR\" in the function call and  */\n/*        specifying the delimiter character(s) as the next operand  */\n/*        prior to the list of variables you want returned.          */\n/*                                                                   */\n/*                                                                   */\n/* FUNCTION SYNTAX - \"VAR2\" / USER DEFINED DELIMITER:                */\n/*                                                                   */\n/* IPLINFO(VAR2,'dlm',var1_name)                                     */\n/* IPLINFO(VAR2,'dlm',var1_name,var2_name,var3_name, ... var20_name) */\n/*                                                                   */\n/* Example:                                                          */\n/*  /* REXX one line IPL information using IPLINFO rexx function */  */\n/*  IPL_SUM  = IPLINFO(VAR2,'@@',ipldate,ipltime,iplvol, ,           */\n/*                     ipladdr,iplparm)                              */\n/*  Parse var IPL_SUM ipldate '@@' ipltime '@@' iplvol '@@' ,        */\n/*                    ipladdr '@@' iplparm                           */\n/*  Say 'Date:'ipldate  ' Time:'ipltime ' Vol:'iplvol ,              */\n/*      ' Load addr:'ipladdr ' LOADPARM:'iplparm                     */\n/*                                                                   */\n/*********************************************************************/\n/*                                                                   */\n/* NOTE: The dynamic APF and dynamic LNKLST code in this exec        */\n/*       use undocumented IBM control blocks and may break at        */\n/*       any time!                                                   */\n/*     ... tested on MVS ESA V4.3 up through z/OS 2.3.               */\n/*                                                                   */\n/* NOTE: The LNKLST SET displayed is the LNKLST SET of the address   */\n/*       space running this exec, not necessarily the most           */\n/*       current one. For the current LNKLST SET either:             */\n/*       1) Run this exec in batch.                                  */\n/*       2) Log off and on TSO before executing this exec.           */\n/*       3) Issue SETPROG LNKLST,UPDATE,JOB=userid  (B4 execution)   */\n/*                                                                   */\n/* NOTE: The APF flag in the LNKLST display is the status if the     */\n/*       data set is accessed VIA LNKLST. Therefore, if IEASYSxx     */\n/*       specifies LNKAUTH=LNKLST, all entires are marked as APF=Y.  */\n/*                                                                   */\n/*********************************************************************/\nLASTUPD = '09/24/2020'                       /* date of last update  */\n/*********************************************************************/\n/*                                                                   */\n/* B E G I N    C U S T O M I Z A T I O N    S E C T I O N           */\n/*                                                                   */\n/*   You may changes the variables below to your preference.         */\n/*   You may only choose the options that are commented out.         */\n/*                                                                   */\n/*  DATEFMT - Controls date format:   ISO ; USA ; EUR                */\n/*  VMAP    - Controls VMAP order:    HIGHFIRST ; LOWFIRST           */\n/*                                                                   */\n/*********************************************************************/\nDATEFMT = 'ISO'          /* ISO 8601 format YYYY-MM-DD (new default) */\n/* DATEFMT = 'USA' */    /* USA format MM/DD/YYYY (original format)  */\n/* DATEFMT = 'EUR' */    /* EUR format DD/MM/YYYY                    */\n/*********************************************************************/\nVMAP = 'HIGHFIRST'       /* new default - show VMAP from top down    */\n/* VMAP = 'LOWFIRST' */  /* the old way - show from bottom up        */\n/*  Please let me know if you \"need\" the old way (LOWFIRST) as I     */\n/*  will probably remove the duplicate code in the future.           */\n/*********************************************************************/\n/*                                                                   */\n/* E N D    C U S T O M I Z A T I O N    S E C T I O N               */\n/*                                                                   */\n/*********************************************************************/\nSignal On  Syntax  name SIG_ALL     /* trap syntax errors            */\nSignal On  Novalue name SIG_ALL     /* trap uninitialized variables  */\nArg OPTION,VAR.1,VAR.2,VAR.3,VAR.4,VAR.5,VAR.6,VAR.7,VAR.8,VAR.9, ,\n  VAR.10,VAR.11,VAR.12,VAR.13,VAR.14,VAR.15,VAR.16,VAR.17,VAR.18, ,\n  VAR.19,VAR.20,VAR.21\nParse source . EXEC_TYPE . . . . . ENV . .\nMML      = Substr(LASTUPD,1,2)             /* MM from MM/DD/YYYY     */\nDDL      = Substr(LASTUPD,4,2)             /* DD from MM/DD/YYYY     */\nYYYYL    = Substr(LASTUPD,7,4)             /* YYYY from MM/DD/YYYY   */\nIf DATEFMT = 'USA' then ,                  /* USA format date?       */\n  LASTUPD  = LASTUPD                       /* date as MM/DD/YYYY     */\nIf DATEFMT = 'EUR' then ,                  /* EUR format date?       */\n  LASTUPD  = DDL'/'MML'/'YYYYL             /* date as DD/MM/YYYY     */\nIf DATEFMT = 'ISO' then ,                  /* ISO format date?       */\n  LASTUPD  = YYYYL'-'MML'-'DDL             /* date as YYYY-MM-DD     */\nSYSISPF = 'NOT ACTIVE'                     /* set SYSISPF=NOT ACTIVE */\nFUNCDLM = ' '               /* Delimiter default for function call   */\nIf ENV <> 'OMVS' then                      /* are we under unix ?    */\n  If Sysvar('SYSISPF')='ACTIVE' then do    /* no, is ISPF active?    */\n    If Pos('NOB',OPTION) = 0 then ,        /* NOBrowse not used?     */\n      Address ISREDIT \"MACRO (OPTION)\"     /* YES,allow use as macro */\n    OPTION = Translate(OPTION)   /* ensure upper case for edit macro */\n    Address ISPEXEC \"VGET ZENVIR\"          /* ispf version           */\n    SYSISPF = 'ACTIVE'                     /* set SYSISPF = ACTIVE   */\n  End\n/*********************************************************************/\n/* Process options                                                   */\n/*********************************************************************/\nBROWSEOP = 'YES'            /* default is to browse OP under ISPF    */\nEDITOP   = 'NO'             /* output is not in edit mode            */\n/*********************************************************************/\nIf SYSISPF = 'NOT ACTIVE' & Pos('EDI',OPTION) <> 0 then /* EDIT is   */\n  call INVALID_OPTION       /* not valid if ISPF isn't active        */\nIf OPTION = '' then OPTION = 'ALL' /* Default option. Change to IPL  */\n     /* or something else - may want to change help panel if changed */\nIf Abbrev('NOBROWSE',OPTION,3) = 1 then ,   /* NOBROWSE only opt?    */\n  OPTION = 'ALL NOBROWSE'                /* yes, use all option      */\nIf Abbrev('EDIT',OPTION,3) = 1 then ,    /* EDITonly opt?            */\n  OPTION = 'ALL EDIT'                    /* yes, use all option      */\nIf Abbrev('NOBROWSE',Word(OPTION,2),3) = 1 then do /* NOBROWSE USED? */\n  OPTION = Word(OPTION,1)                /* separate out option      */\n  BROWSEOP = 'NO'                        /* set BROWSEOP flag to NO  */\nEnd\nIf Abbrev('EDIT',Word(OPTION,2),3) = 1 then do     /* EDIT USED?     */\n  OPTION = Word(OPTION,1)                /* separate out option      */\n  EDITOP   = 'YES'                       /* set EDITOP flag to YES   */\nEnd\n/*********************************************************************/\nIf OPTION <> 'IPL'                 & ,   /* check for IPL option     */\n   Abbrev('VERSION',OPTION,3) <> 1 & ,   /* check for VERsion option */\n   Abbrev('STORAGE',OPTION,3) <> 1 & ,   /* check for STOrage option */\n   Abbrev('STORE',OPTION,3)   <> 1 & ,   /* check for STOre   option */\n   Abbrev('MEMORY',OPTION,3)  <> 1 & ,   /* check for MEMory  option */\n   OPTION <> 'CPU'                 & ,   /* check for CPU option     */\n   OPTION <> 'IPA'                 & ,   /* check for IPA option     */\n   Abbrev('SYMBOLS',OPTION,3) <> 1 & ,   /* check for SYMbols option */\n   Abbrev('VMAP',OPTION,3) <> 1    & ,   /* check for VMAp option    */\n   Abbrev('PAGE',OPTION,3) <> 1    & ,   /* check for PAGe option    */\n   Abbrev('ASM',OPTION,3) <> 1     & ,   /* check for ASM option     */\n   Abbrev('AUX',OPTION,3) <> 1     & ,   /* check for ASM option     */\n   OPTION <> 'SMF'                 & ,   /* check for SMF option     */\n   OPTION <> 'SSI'                 & ,   /* check for SSI option     */\n   OPTION <> 'SSN'                 & ,   /* check for SSN option     */\n   OPTION <> 'SUB'                 & ,   /* check for SUB option     */\n   Abbrev('SUBSYSTEMS',OPTION,3) <> 1  & ,  /* check for SUB option  */\n   Abbrev('ASID',OPTION,3) <> 1    & ,   /* check for ASId option    */\n   Abbrev('ASVT',OPTION,3) <> 1    & ,   /* check for ASVt option    */\n   OPTION <> 'LPA'                 & ,   /* check for LPA option     */\n   Abbrev('LNKLST',OPTION,3) <> 1  & ,   /* check for LNKlst option  */\n   Abbrev('LINKLIST',OPTION,3) <> 1 & ,  /* check for LINklist option*/\n   OPTION <> 'APF'                 & ,   /* check for APF option     */\n   OPTION <> 'SVC'                 & ,   /* check for SVC option     */\n   OPTION <> 'ALL'                 & ,   /* check for ALL option     */\n   Substr(OPTION,1,3) <> 'VAR'       ,   /* check for VAR option     */\n   then call INVALID_OPTION              /* no valid option...       */\nNumeric digits 20                           /* dflt of 9 not enough  */\n                                            /* 20 can handle 64-bit  */\nCall COMMON            /* control blocks needed by multiple routines */\nCall HEADING                                /* Heading sub-routine   */\nSelect\n  When OPTION = 'ALL' |  Substr(OPTION,1,3) = 'VAR' then do\n    Call IPL                                /* IPL information       */\n    Call VERSION                            /* Version information   */\n    Call STOR                               /* Storage information   */\n    Call CPU                                /* CPU information       */\n    Call IPA                                /* Initialization info.  */\n    Call SYMBOLS                            /* Symbols information   */\n    Call VMAP                               /* Virt. Storage Map     */\n    Call PAGE                               /* Page DSN information  */\n    Call SMF                                /* SMF DSN information   */\n    Call SUB                                /* Subsystem information */\n    Call ASID                               /* ASID usage information*/\n    Call LPA                                /* LPA List information  */\n    Call LNKLST                             /* LNKLST information    */\n    Call APF                                /* APF List information  */\n    Call SVC                                /* SVC information       */\n  End /* when OPTION = 'ALL' */\n  When Abbrev('VERSION',OPTION,3)  = 1 then call VERSION\n  When Abbrev('STORAGE',OPTION,3)  = 1 then call STOR\n  When Abbrev('STORE',OPTION,3)    = 1 then call STOR\n  When Abbrev('MEMORY',OPTION,3)   = 1 then call STOR\n  When Abbrev('SYMBOLS',OPTION,3)  = 1 then call SYMBOLS\n  When Abbrev('VMAP',OPTION,3)     = 1 then call VMAP\n  When Abbrev('ASM',OPTION,3)      = 1 then call PAGE\n  When Abbrev('AUX',OPTION,3)      = 1 then call PAGE\n  When Abbrev('SSI',OPTION,3)      = 1 then call SUB\n  When Abbrev('SSN',OPTION,3)      = 1 then call SUB\n  When Abbrev('SUBSYSTEMS',OPTION,3) = 1 then call SUB\n  When Abbrev('PAGE',OPTION,3)     = 1 then call PAGE\n  When Abbrev('ASID',OPTION,3)     = 1 then call ASID\n  When Abbrev('ASVT',OPTION,3)     = 1 then call ASID\n  When Abbrev('LNKLST',OPTION,3)   = 1 then call LNKLST\n  When Abbrev('LINKLIST',OPTION,3) = 1 then call LNKLST\n  Otherwise interpret \"Call\" OPTION\nEnd /* select */\n/*********************************************************************/\n/* Done looking at all control blocks                                */\n/*********************************************************************/\n/*********************************************************************/\n/* IPLINFO called as a function with an alternate delimiter.         */\n/* Return variable names and exit                                    */\n/*********************************************************************/\nIf Substr(OPTION,1,4) = 'VAR2' & EXEC_TYPE='FUNCTION' then do\n  \"DROPBUF\"                                   /* remove data stack   */\n  FUNCDLM  = VAR.1                            /* function delimiter  */\n  ALL_VARS = Value(VAR.2)                     /* at least one var    */\n  Do V = 3 to 21                              /* check for others    */\n    If VAR.V = '' then leave                  /* done, leave loop    */\n    Else ALL_VARS = ALL_VARS || ,             /* concat additional   */\n                   FUNCDLM || Value(VAR.V)    /*  var + dlm at end   */\n  End  /* end Do V */\n  Return ALL_VARS                             /* return vars         */\nEnd\n/*********************************************************************/\n/* IPLINFO called as a function. Return variable names and exit      */\n/*********************************************************************/\nIf Substr(OPTION,1,3) = 'VAR' & EXEC_TYPE='FUNCTION' then do\n  \"DROPBUF\"                                   /* remove data stack   */\n  ALL_VARS = Value(VAR.1)                     /* at least one var    */\n  Do V = 2 to 20                              /* check for others    */\n    If VAR.V = '' then leave                  /* done, leave loop    */\n    Else ALL_VARS = ALL_VARS || ,             /* concat additional   */\n                   FUNCDLM || Value(VAR.V)    /*  var + dlm at end   */\n  End  /* end Do V */\n  Return ALL_VARS                             /* return vars         */\nEnd\n/*********************************************************************/\n/* If ISPF is active and the BROWSEOP option is set (default) then   */\n/* browse the output - otherwise write to the terminal               */\n/*********************************************************************/\nIf SYSISPF = 'ACTIVE' & BROWSEOP = 'YES' ,   /* ISPF active and      */\n then call BROWSE_ISPF                       /* BROWSEOP option set? */\nElse do queued()                             /* ISPF is not active   */\n  Parse pull line                            /* pull queued lines    */\n  Say line                                   /* say lines            */\nEnd /* else do  */\nExit 0                                       /* End IPLINFO - RC 0   */\n/*********************************************************************/\n/*  End of main IPLINFO code                                         */\n/*********************************************************************/\n/*********************************************************************/\n/*  Start of sub-routines                                            */\n/*********************************************************************/\nINVALID_OPTION:      /* Invalid option sub-routine                   */\nIf SYSISPF = 'ACTIVE' then do\n  Queue ' '\n  Queue '   ******************************************************'\n  If OPTION <> '?' then,\n    Queue '   *            Invalid IPLINFO option.                 *'\n  Queue '   *   Please hit PF1/HELP two times for valid options. *'\n  Queue '   ******************************************************'\n  Queue ' '\n  OPTION = 'Invalid'\n  Call BROWSE_ISPF\n  Exit 16\n  End\nElse do\n  Call CKWEB                               /* call CKWEB sub-routine */\n  Say Copies('*',79)\n  Say \" \"\n  If OPTION <> '?' then,\n    Say \"Invalid IPLINFO option.\"\n  Say \" \"\n  Say \"EXECUTION SYNTAX: %IPLINFO <option>\"\n  Say \" \"\n  Say \"VALID OPTIONS ARE 'ALL', 'IPL', 'VERsion',\" ,\n      \"'STOrage', 'CPU', 'IPA', 'SYMbols',\"\n  Say \" 'VMAp', 'PAGe', 'SMF', 'SUB',\" ,\n      \"'ASId', 'LPA', 'LNKlst' or 'LINklist' and 'APF'\"\n  Say \" \"\n  Say \"** 'ALL' is the default option\"\n  Say \"** OPTIONS may be abbreviated by using 3 or more characters\"\n  Say \" \"\n  Say Copies('*',79)\n  If OPTION = '?' then Exit 0\n    Else exit 16\nEnd\nreturn\n\nHEADING:             /* Heading sub-routine                          */\nCall CKWEB                                 /* call CKWEB sub-routine */\nCall RDATE 'TODAY'                         /* call RDATE sub-routine */\nDAY      = Word(RESULT,3)                  /* weekday from RDATE     */\nMMT      = Substr(RESULT,1,2)              /* MM from MM/DD/YYYY     */\nDDT      = Substr(RESULT,4,2)              /* DD from MM/DD/YYYY     */\nYYYYT    = Substr(RESULT,7,4)              /* YYYY from MM/DD/YYYY   */\nIf DATEFMT = 'USA' then ,                  /* USA format date?       */\n  DATE     = Substr(RESULT,1,10)           /* date as MM/DD/YYYY     */\nIf DATEFMT = 'EUR' then ,                  /* EUR format date?       */\n  DATE     = DDT'/'MMT'/'YYYYT             /* date as DD/MM/YYYY     */\nIf DATEFMT = 'ISO' then ,                  /* ISO format date?       */\n  DATE     = YYYYT'-'MMT'-'DDT             /* date as YYYY-MM-DD     */\nJUL      = Substr(RESULT,7,8)              /* date as YYYY.DDD       */\nCURNNNNN = Substr(RESULT,16,5)             /* date as NNNNN          */\nQueue Copies('*',79)\nQueue Copies('*',15) || ,\n      Center('IPLINFO - SYSTEM INFORMATION FOR' GRSNAME,49) || ,\n      Copies('*',15)\nQueue Copies('*',79)\nQueue ' '\nQueue 'Today is 'DAY DATE '('JUL'). The local time is 'TIME()'.'\nReturn\n\nCKWEB:         /* Create HTML needed for web page output sub-routine */\nIf ENV = 'OMVS' then do                    /* Are we under OMVS?     */\n  Do CKWEB = __ENVIRONMENT.0 to 1 by -1    /* check env. vars        */\n     If pos('HTTP_',__ENVIRONMENT.CKWEB) <> 0 then do  /* web server */\n       Say 'Content-type: text/html'\n       Say ''\n       Say '<title>Mark''s MVS Utilities - IPLINFO</title>'\n       Say '<meta name=\"author\" content=\"Mark Zelden -' ,\n           'mark@mzelden.com\">'\n       Say '<meta name=\"description\" content=\"' || ,\n           'IPLINFO -' OPTION 'option.' ,\n           'Last updated on' LASTUPD ||'. Written by' ,\n           'Mark Zelden. Mark''s MVS Utilities -' ,\n           'http://www.mzelden.com/mvsutil.html\">'\n       Say '<meta http-equiv=\"pragma\" content=\"no-cache\">'\n       Say '<body BGCOLOR=\"#000000\" TEXT=\"#00FFFF\">'\n       Say '<pre>'\n       Leave                               /* exit loop              */\n     End /* if pos */\n  End /* do CKWEB */\nEnd\nReturn\n\nCOMMON:              /* Control blocks needed by multiple routines   */\nCVT      = C2d(Storage(10,4))                /* point to CVT         */\nCVTFLAG2 = Storage(D2x(CVT+377),1)           /* CVT flag byte 2      */\nCVTEXT2  = C2d(Storage(D2x(CVT + 328),4))    /* point to CVTEXT2     */\nPRODNAME = Storage(D2x(CVT - 40),7)          /* point to mvs version */\nIf Substr(PRODNAME,3,1) >= 3 then do         /* HBB3310 ESA V3 & >   */\n  CVTOSLV0   = Storage(D2x(CVT + 1264),1)    /* Byte 0 of CVTOSLVL   */\n  CVTOSLV1   = Storage(D2x(CVT + 1265),1)    /* Byte 1 of CVTOSLVL   */\n  CVTOSLV2   = Storage(D2x(CVT + 1266),1)    /* Byte 2 of CVTOSLVL   */\n  CVTOSLV3   = Storage(D2x(CVT + 1267),1)    /* Byte 3 of CVTOSLVL   */\n  CVTOSLV4   = Storage(D2x(CVT + 1268),1)    /* Byte 4 of CVTOSLVL   */\n  CVTOSLV5   = Storage(D2x(CVT + 1269),1)    /* Byte 5 of CVTOSLVL   */\n  CVTOSLV6   = Storage(D2x(CVT + 1270),1)    /* Byte 6 of CVTOSLVL   */\n  CVTOSLV7   = Storage(D2x(CVT + 1271),1)    /* Byte 7 of CVTOSLVL   */\n  CVTOSLV8   = Storage(D2x(CVT + 1272),1)    /* Byte 8 of CVTOSLVL   */\n  CVTOSLV9   = Storage(D2x(CVT + 1273),1)    /* Byte 9 of CVTOSLVL   */\nEnd\nIf Bitand(CVTOSLV0,'08'x) = '08'x then ,     /* HBB4410 ESA V4 & >   */\n  ECVT     = C2d(Storage(D2x(CVT + 140),4))  /* point to CVTECVT     */\nFMIDNUM  = Storage(D2x(CVT - 32),7)          /* point to fmid        */\nJESCT    = C2d(Storage(D2x(CVT + 296),4))    /* point to JESCT       */\nJESCTEXT = C2d(Storage(D2x(JESCT +100),4))   /* point to JESPEXT     */\nJESPJESN = Storage(D2x(JESCT + 28),4)        /* name of primary JES  */\nCVTSNAME = Storage(D2x(CVT + 340),8)         /* point to system name */\nGRSNAME  = Strip(CVTSNAME,'T')               /* del trailing blanks  */\nCSD      = C2d(Storage(D2x(CVT + 660),4))    /* point to CSD         */\nSMCA     = Storage(D2x(CVT + 196),4)         /* point to SMCA        */\nSMCA     = Bitand(SMCA,'7FFFFFFF'x)          /* zero high order bit  */\nSMCA     = C2d(SMCA)                         /* convert to decimal   */\nASMVT    = C2d(Storage(D2x(CVT + 704),4))    /* point to ASMVT       */\nCVTSCPIN = D2x(CVT+832)                      /* point to SCPINFO     */\nIf Bitand(CVTOSLV5,'08'x) = '08'x then do    /* z/OS 1.10 and above  */\n  ECVTSCPIN = D2x(ECVT+876)                  /* point to cur SCPINFO */\n  SCCB      = C2d(Storage(ECVTSCPIN,4))      /* Service Call Cntl Blk*/\nEnd\nElse SCCB   = C2d(Storage(CVTSCPIN,4))       /* Service Call Cntl Blk*/\nRCE      = C2d(Storage(D2x(CVT + 1168),4))   /* point to RCE         */\nMODEL    = C2d(Storage(D2x(CVT - 6),2))      /* point to cpu model   */\n/*********************************************************************/\n/*  The CPU model is stored in packed decimal format with no sign,   */\n/*  so to make the model printable, it needs to be converted back    */\n/*  to hex.                                                          */\n/*********************************************************************/\nMODEL    = D2x(MODEL)                        /* convert back to hex  */\nPCCAVT    = C2d(Storage(D2x(CVT + 764),4))   /* point to PCCA vect tb*/\nIf Bitand(CVTOSLV1,'01'x) = '01'x then do    /* OS/390 R2 and above  */\n  ECVTIPA  = C2d(Storage(D2x(ECVT + 392),4)) /* point to IPA         */\n  IPASCAT  = Storage(D2x(ECVTIPA + 224),63)  /* SYSCAT  card image   */\nEnd\nzARCH = 1                                    /* default ARCHLVL      */\nIf Bitand(CVTOSLV2,'01'x) = '01'x then do    /* OS/390 R10 and above */\n  FLCARCH  = Storage('A3',1)                 /* FLCARCH in PSA       */\n  If C2d(FLCARCH) <> 0 then zARCH=2          /* non-zero is z/Arch.  */\nEnd\nReturn\n\nIPL:                 /* IPL information sub-routine                  */\nQueue ' '\n/*********************************************************************/\n/*  The IPL date is stored in packed decimal format - so to make     */\n/*  the date printable, it needs to be converted back to hex and     */\n/*  the packed sign needs to be removed.                             */\n/*********************************************************************/\n/*  Converting binary fields to time of day format is described      */\n/*  in the MVS SMF manual.                                           */\n/*********************************************************************/\nIPLTIME  = C2d(Storage(D2x(SMCA + 336),4))   /* IPL Time - binary    */\nIPLDATE  = C2d(Storage(D2x(SMCA + 340),4))   /* IPL Date - 0CYYDDDF  */\nIf IPLDATE  >= 16777231 then do              /*          is C = 1 ?  */\n  IPLDATE  = D2x(IPLDATE)                    /* convert back to hex  */\n  IPLDATE  = Substr(IPLDATE,2,5)             /* keep YYDDD           */\n  IPLDATE  = '20'IPLDATE                     /* use 21st century date*/\nEnd\nElse do\n  IPLDATE  = D2x(IPLDATE)                    /* convert back to hex  */\n  IPLDATE  = Left(IPLDATE,5)                 /* keep YYDDD           */\n  IPLDATE  = '19'IPLDATE                     /* use 20th century date*/\nEnd\nIPLYYYY  = Substr(IPLDATE,1,4)               /* YYYY portion of date */\nIPLDDD   = Substr(IPLDATE,5,3)               /* DDD  portion of date */\nCall RDATE IPLYYYY IPLDDD                    /* call RDATE subroutine*/\nIPLDAY   = Word(RESULT,3)                    /* weekday from RDATE   */\nMMI      = Substr(RESULT,1,2)                /* MM from MM/DD/YYYY   */\nDDI      = Substr(RESULT,4,2)                /* DD from MM/DD/YYYY   */\nYYYYI    = Substr(RESULT,7,4)                /* YYYY from MM/DD/YYYY */\nIf DATEFMT = 'USA' then ,                    /* USA format date?     */\n  IPLDATE  = Substr(RESULT,1,10)             /* date as MM/DD/YYYY   */\nIf DATEFMT = 'EUR' then ,                    /* EUR format date?     */\n  IPLDATE  = DDI'/'MMI'/'YYYYI               /* date as DD/MM/YYYY   */\nIf DATEFMT = 'ISO' then ,                    /* ISO format date?     */\n  IPLDATE  = YYYYI'-'MMI'-'DDI               /* date as YYYY-MM-DD   */\nIPLJUL   = Substr(RESULT,7,8)                /* date as YYYY.DDD     */\nIPLNNNNN = Substr(RESULT,16,5)               /* date as NNNNN        */\nIPLHH    = Right(IPLTIME%100%3600,2,'0')     /* IPL hour             */\nIPLMM    = Right(IPLTIME%100//3600%60,2,'0') /* IPL minute           */\nIPLSS    = Right(IPLTIME%100//60,2,'0')      /* IPL seconds          */\nIPLTIME  = IPLHH':'IPLMM':'IPLSS             /* time in HH:MM:SS     */\n/*                                                                   */\nASMFLAG2 = Storage(D2x(ASMVT + 1),1)         /* point to ASMFLAG2    */\nIf Bitand(ASMFLAG2,'08'x) = '08'x then ,     /* Check ASMQUICK bit   */\n  IPLCLPA    = 'without CLPA'                /* bit on  - no CLPA    */\nElse IPLCLPA = 'with CLPA'                   /* bit off - CLPA       */\nRESUCB   = C2d(Storage(D2x(JESCT + 4),4))    /* point to SYSRES UCB  */\nIPLVOL   = Storage(D2x(RESUCB + 28),6)       /* point to IPL volume  */\nIf Bitand(CVTOSLV1,'20'x) <> '20'x then ,    /* Below HBB5510 ESA V5 */\n  IPLADDR  = Storage(D2x(RESUCB + 13),3)     /* point to IPL address */\nElse do\n  CVTSYSAD = C2d(Storage(D2x(CVT + 48),4))   /* point to UCB address */\n  IPLADDR  = Storage(D2x(CVTSYSAD + 4),2)    /* point to IPL UCB     */\n  IPLADDR  = C2x(IPLADDR)                    /* convert to EBCDIC    */\nEnd\nSMFNAME  = Storage(D2x(SMCA + 16),4)         /* point to SMF name    */\nSMFNAME  = Strip(SMFNAME,'T')                /* del trailing blanks  */\nAMCBS    = C2d(Storage(D2x(CVT + 256),4))    /* point to AMCBS       */\nIf Bitand(CVTOSLV2,'80'x) <> '80'x then do   /*Use CAXWA B4 OS/390 R4*/\n  ACB      = C2d(Storage(D2x(AMCBS + 8),4))  /* point to ACB         */\n  CAXWA    = C2d(Storage(D2x(ACB + 64),4))   /* point to CAXWA       */\n  MCATDSN  = Storage(D2x(CAXWA + 52),44)     /* master catalog dsn   */\n  MCATDSN  = Strip(MCATDSN,'T')              /* remove trailing blnks*/\n  MCATUCB  = C2d(Storage(D2x(CAXWA + 28),4)) /* point to mcat UCB    */\n  MCATVOL  = Storage(D2x(MCATUCB + 28),6)    /* master catalog VOLSER*/\nEnd\nElse do                                      /* OS/390 R4 and above  */\n  MCATDSN  = Strip(Substr(IPASCAT,11,44))    /* master catalog dsn   */\n  MCATVOL  = Substr(IPASCAT,1,6)             /* master catalog VOLSER*/\n  IPASCANL = Storage(d2x(ECVTIPA+231),1)     /* mcat alias level     */\n  IPASCTYP = Storage(d2x(ECVTIPA+230),1)     /* mcat catalog type    */\n  AMCBSFLG = Storage(D2x(AMCBS + 96),1)      /* AMCBS flags          */\n  AMCBSALV = C2d(Storage(D2x(AMCBS + 155),1)) /* AMCBS - alias level */\n  If IPASCANL = ' ' then IPASCANL = 1  /* SYSCAT col 17 blank / dflt */\n  If IPASCTYP = ' ' then IPASCTYP = 1  /* SYSCAT col 16 blank / dflt */\n  CTYP.0   = 'VSAM'\n  CTYP.1   = 'ICF. SYS%-SYS1 conversion was not active at IPL time'\n  CTYP.2   = 'ICF. SYS%-SYS1 conversion was active at IPL time'\nEnd\nQueue 'The last IPL was 'IPLDAY IPLDATE '('IPLJUL')' ,\n      'at 'IPLTIME' ('CURNNNNN - IPLNNNNN' days ago).'\nQueue 'The IPL was done 'IPLCLPA'.'\nQueue 'The system IPL address was 'IPLADDR' ('IPLVOL').'\nIf Bitand(CVTOSLV0,'08'x) = '08'x then do    /* HBB4410 ESA V4 1 & > */\n  ECVTSPLX = Storage(D2x(ECVT+8),8)          /* point to SYSPLEX name*/\n  ECVTLOAD = Storage(D2x(ECVT+160),8)        /* point to LOAD PARM   */\n  IPLPARM  = Strip(ECVTLOAD,'T')             /* del trailing blanks  */\n  SEPPARM  = Substr(IPLPARM,1,4) Substr(IPLPARM,5,2),\n             Substr(IPLPARM,7,1) Substr(IPLPARM,8,1)\n  SEPPARM  = Strip(SEPPARM,'T')              /* del trailing blanks  */\n  Queue 'The IPL LOAD PARM used was 'IPLPARM' ('SEPPARM').'\n  If Bitand(CVTOSLV1,'20'x) = '20'x then do  /* HBB5510 ESA V5 & >   */\n    CVTIXAVL = C2d(Storage(D2x(CVT+124),4))      /* point to IOCM    */\n    IOCIOVTP = C2d(Storage(D2x(CVTIXAVL+208),4)) /* IOS Vector Table */\n    CDA      = C2d(Storage(D2x(IOCIOVTP+24),4))  /* point to CDA     */\n  End\n  CVTTZ      = Storage(D2x(CVT + 304),4)     /* point to cvttz       */\n  CKTZBYTE   = Storage(D2x(CVT + 304),1)     /* need to chk 1st byte */\n  If bitand(CKTZBYTE,'80'x) = '80'x then ,   /* chk for negative     */\n    CVTTZ    = C2d(CVTTZ,4)                  /* negative offset C2d  */\n  Else CVTTZ = C2d(CVTTZ)                    /* postitive offset C2d */\n  CVTTZ      = CVTTZ * 1.048576 / 3600       /* convert to hours     */\n  If Format(CVTTZ,3,1) = Format(CVTTZ,3,0) , /* don't use decimal if */\n   then CVTTZ = Strip(Format(CVTTZ,3,0))     /* not needed           */\n  Else  CVTTZ = Strip(Format(CVTTZ,3,1))     /* display 1 decimal    */\n  Queue 'The local time offset from GMT time is' CVTTZ 'hours.'\n  If Bitand(CVTOSLV1,'10'x) = '10'x then do  /* HBB5520 ESA V5.2 & > */\n    ECVTHDNM = Storage(D2x(ECVT+336),8)      /* point to hardware nam*/\n    ECVTLPNM = Storage(D2x(ECVT+344),8)      /* point to LPAR name   */\n    If Bitand(CVTOSLV2,'01'x) = '01'x then do  /* OS/390 R10 & above */\n      MIFID    = C2d(Storage(D2X(CDA+252),1))  /* MIF ID in decimal  */\n      MIFID    = D2x(MIFID)                    /* MIF ID in hex      */\n      If Bitand(CVTOSLV3,'04'x) = '04'x then do /* z/OS 1.4 and above*/\n        IOCCSSID = C2d(Storage(d2x(CVTIXAVL+275),1))\n        IOCCSSID = D2x(IOCCSSID)                /* CSS ID in hex     */\n      End\n      If zARCH = 2 then ,                    /* z/Architechture      */\n        Queue 'The system is running in z/Architecture mode' ,\n               '(ARCHLVL = 2).'\n      Else ,                                 /* ESA/390 mode         */\n        Queue 'The system is running in ESA/390 mode (ARCHLVL = 1).'\n    End /* If Bitand(CVTOSLV2,'01'x) = '01'x */\n    If ECVTHDNM <> ' ' & ECVTLPNM <> ' ' then do\n      CSDPLPN  = C2d(Storage(D2x(CSD + 252),1))    /* point to LPAR #*/\n   /* CSDPLPN not valid for z990 (T-REX) or z890 for LPAR number     */\n      CPOFF = 0  /* init offset to next PCCA entry                   */\n      PCCA  = 0  /* init PCCA to 0                                   */\n      Do until PCCA <> 0   /* do until we find a valid PCCA          */\n        PCCA = C2d(Storage(D2x(PCCAVT + CPOFF),4)) /* point to PCCA  */\n        If PCCA <> 0 then do\n          LPAR_#  = X2d(Storage(D2x(PCCA + 6),2))  /* LPAR # in hex  */\n          LPAR_#  = D2x(LPAR_#)                    /* display as hex */\n        End /* if PCCA <> 0 */\n        Else CPOFF = CPOFF + 4  /* bump up offset for next PCCA      */\n      End /* do until PCCA <> 0 */\n      If Bitand(CVTOSLV2,'01'x) = '01'x then do    /* OS/390 R10 & > */\n        Queue 'The Processor name is' Strip(ECVTHDNM)'.' ,\n               'The LPAR name is' Strip(ECVTLPNM)'.'\n        If Bitand(CVTOSLV3,'04'x) = '04'x then  /* z/OS 1.4 and above*/\n          Queue ' ' Strip(ECVTLPNM) 'is (HMC defined) LPAR ID =' ,\n                LPAR_#', MIF ID =' mifid 'and CSS ID = 'IOCCSSID'.'\n        Else ,\n          Queue ' ' Strip(ECVTLPNM) 'is (HMC defined) LPAR ID =' ,\n                LPAR_# 'and MIF ID =' mifid'.'\n        Queue ' ' Strip(ECVTLPNM) 'is PR/SM partition number' ,\n                   CSDPLPN' (internal value from the CSD).'\n      End /* If Bitand(CVTOSLV2,'01'x) = '01'x */\n      Else ,\n        Queue 'The Processor name is' Strip(ECVTHDNM)'.' ,\n               'The LPAR name is' Strip(ECVTLPNM)' (LPAR #'CSDPLPN').'\n    End  /* If ECVTHDNM <> ' ' & ECVTLPNM <> ' '   */\n    Else if ECVTHDNM <> ' ' then ,\n      Queue 'The Processor name is' Strip(ECVTHDNM)'.'\n    If Bitand(CVTOSLV1,'20'x) = '20'x ,   /* HBB5510 ESA V5 & above  */\n       & ECVTSPLX <> 'LOCAL' then do      /* and not a local sysplex */\n      JESDSNID = X2d(Storage(D2x(JESCTEXT+120),2)) /*ID for temp dsns*/\n      Queue 'The sysplex name is' Strip(ECVTSPLX)'. This was system' ,\n            'number' Format(JESDSNID) 'added to the sysplex.'\n    End /* If Bitand(CVTOSLV1,'20'x) = '20'x */\n    Else queue 'The sysplex name is' Strip(ECVTSPLX)'.'\n  End  /* If Bitand(CVTOSLV1,'10'x) = '10'x */\nEnd\nQueue 'The GRS system id (SYSNAME) is 'GRSNAME'.'\nIf Bitand(CVTOSLV1,'10'x) = '10'x then do  /* HBB5520 ESA V5.2 & > */\n  ECVTGMOD   = C2d(Storage(D2x(ECVT + 266),1)) /* GRS mode         */\n  GMOD.0     = \"NONE\"  /* Stem for GRS mode: ECVTGNON EQU 0        */\n  GMOD.1     = \"RING\"  /* Stem for GRS mode: ECVTGRNG EQU 1        */\n  GMOD.2     = \"STAR\"  /* Stem for GRS mode: ECVTGSTA EQU 2        */\n  Queue '  The GRS mode is' GMOD.ECVTGMOD' (NONE, RING or STAR).'\nEnd\nQueue 'The SMF system id (SID) is 'SMFNAME'.'\nIf Bitand(CVTOSLV1,'20'x) <> '20'x then do   /* Below HBB5510 ESA V5 */\n  IOCON    = Storage(D2x(CVTEXT2 + 6),2)       /* HCD IODFxx or MVSCP*/\n                                               /* IOCONFIG ID=xx     */\n  Queue 'The currently active IOCONFIG or HCD IODF is 'IOCON'.'\nEnd\nElse do\n  IODF     = Storage(D2X(CDA+32),44)           /* point to IODF name */\n  IODF     = Strip(IODF,'T')                   /* del trailing blanks*/\n  CONFIGID = Storage(D2X(CDA+92),8)            /* point to CONFIG    */\n  EDT      = Storage(D2X(CDA+104),2)           /* point to EDT       */\n  IOPROC   = Storage(D2X(CDA+124),8)           /* point to IODF Proc */\n  IODATE   = Storage(D2X(CDA+156),8)           /* point to IODF date */\n  IOTIME   = Storage(D2X(CDA+164),8)           /* point to IODF time */\n  IODESC   = Storage(D2X(CDA+172),16)          /* point to IODF desc */\n  Queue 'The currently active IODF data set is 'IODF'.'\n  Queue '  Configuration ID =' CONFIGID ' EDT ID =' EDT\n  If Substr(IOPROC,1,1) <> '00'x  & ,\n     Substr(IOPROC,1,1) <> '40'x then do       /* is token there?    */\n    Queue '  TOKEN: Processor  Date      Time      Description'\n    Queue '         'IOPROC'   'IODATE'  'IOTIME'  'IODESC\n  End\nEnd\nQueue 'The Master Catalog is 'MCATDSN' on 'MCATVOL'.'\nIf Bitand(CVTOSLV2,'80'x) = '80'x then do    /* OS/390 R4 and above  */\n Queue '  The catalog alias level was 'IPASCANL' at IPL time.'\n Queue '    The catalog alias level is currently' AMCBSALV'.'\n Queue '  The catalog type is 'CTYP.IPASCTYP'.'\n If Bitand(AMCBSFLG,'40'x) = '40'x then ,\n   Queue '    SYS%-SYS1 conversion is currently active.'\n Else ,\n   Queue '    SYS%-SYS1 conversion is not currently active.'\nEnd\n/*If OPTION = 'IPL' then interpret call 'VERSION' */ /* incl version*/\nReturn\n\nVERSION:             /* Version information sub-routine              */\nQueue ' '\nCall SUB 'FINDJES'   /* call SUB routine with FINDJES option         */\nIf JESPJESN = 'JES3' then do                 /* Is this JES3?        */\n  If ENV = 'OMVS' then do  /* running under Unix System Services     */\n    JES3FMID = Storage(D2x(JESSSVT+644),8)      /* JES3 FMID         */\n    Select  /* determine JES3 version from FMID  */\n      When JES3FMID = 'HJS5521' then JESLEV = 'SP 5.2.1'\n      When JES3FMID = 'HJS6601' then JESLEV = 'OS 1.1.0'\n      When JES3FMID = 'HJS6604' then JESLEV = 'OS 2.4.0'\n      When JES3FMID = 'HJS6606' then JESLEV = 'OS 2.6.0'\n      When JES3FMID = 'HJS6608' then JESLEV = 'OS 2.8.0'\n      When JES3FMID = 'HJS6609' then JESLEV = 'OS 2.9.0'\n      When JES3FMID = 'HJS7703' then JESLEV = 'OS 2.10.0'\n      When JES3FMID = 'HJS7705' then JESLEV = 'z 1.2.0'\n      When JES3FMID = 'HJS7707' then JESLEV = 'z 1.4.0'\n      When JES3FMID = 'HJS7708' then JESLEV = 'z 1.5.0'\n      When JES3FMID = 'HJS7720' then JESLEV = 'z 1.7.0'\n      When JES3FMID = 'HJS7730' then JESLEV = 'z 1.8.0'\n      When JES3FMID = 'HJS7740' then JESLEV = 'z 1.9.0'\n      When JES3FMID = 'HJS7750' then JESLEV = 'z 1.10.0'\n      When JES3FMID = 'HJS7760' then JESLEV = 'z 1.11.0'\n      When JES3FMID = 'HJS7770' then JESLEV = 'z 1.12.0'\n      When JES3FMID = 'HJS7780' then JESLEV = 'z 1.13.0'\n      When JES3FMID = 'HJS7790' then JESLEV = 'z 2.1.0'\n      When JES3FMID = 'HJS77A0' then JESLEV = 'z 2.2.0'\n      When JES3FMID = 'HJS77B0' then JESLEV = 'z 2.3.0'\n      When JES3FMID = 'HJS77C0' then JESLEV = 'z 2.4.0'\n      Otherwise JESLEV = JES3FMID /* if not in tbl, use FMID as ver  */\n    End /* select */\n    JESNODE  = '*not_avail*'                 /* can't do under USS   */\n  End /* if env = 'omvs' */\n  Else do /* if not running under Unix System Services, use TSO VARs */\n    JESLEV   = SYSVAR('SYSJES')              /* TSO/E VAR for JESLVL */\n    JESNODE  = SYSVAR('SYSNODE')             /* TSO/E VAR for JESNODE*/\n  End\nEnd\nElse do  /* JES2 */\n  JESLEV   = Strip(Storage(D2x(JESSUSE),8))  /* JES2 Version         */\n  /* offset in $HCCT - CCTNDENM */\n  Select\n    When Substr(JESLEV,1,8) == 'z/OS 2.4' then, /* z/OS 2.4          */\n      JESNODE  = Strip(Storage(D2x(JESSUS2+696),8)) /* JES2 NODE     */\n    When Substr(JESLEV,1,8) == 'z/OS 2.3' | ,   /* z/OS 2.3          */\n      Substr(JESLEV,1,8) == 'z/OS 2.2'  then,   /* z/OS 2.2          */\n      JESNODE  = Strip(Storage(D2x(JESSUS2+664),8)) /* JES2 NODE     */\n    When Substr(JESLEV,1,8) == 'z/OS 2.1' | ,   /* z/OS 2.1          */\n      Substr(JESLEV,1,8) == 'z/OS1.13'    | ,   /* z/OS 1.13         */\n      Substr(JESLEV,1,8) == 'z/OS1.12'    | ,   /* z/OS 1.12         */\n      Substr(JESLEV,1,8) == 'z/OS1.11'  then,   /* z/OS 1.11         */\n      JESNODE  = Strip(Storage(D2x(JESSUS2+656),8)) /* JES2 NODE     */\n    When Substr(JESLEV,1,8) == 'z/OS1.10' | ,  /* z/OS 1.10          */\n      Substr(JESLEV,1,8) == 'z/OS 1.9' then,    /* z/OS 1.9          */\n      JESNODE  = Strip(Storage(D2x(JESSUS2+708),8)) /* JES2 NODE     */\n    When Substr(JESLEV,1,8) == 'z/OS 1.8' then, /* z/OS 1.8          */\n      JESNODE  = Strip(Storage(D2x(JESSUS2+620),8)) /* JES2 NODE     */\n    When Substr(JESLEV,1,8) == 'z/OS 1.7' then, /* z/OS 1.7          */\n      JESNODE  = Strip(Storage(D2x(JESSUS2+616),8)) /* JES2 NODE     */\n    When Substr(JESLEV,1,8) == 'z/OS 1.5' | , /* z/OS 1.5 & 1.6      */\n      Substr(JESLEV,1,8) == 'z/OS 1.4' then   /* z/OS 1.4            */\n      JESNODE  = Strip(Storage(D2x(JESSUS2+532),8)) /* JES2 NODE     */\n    When Substr(JESLEV,1,7) == 'OS 2.10' | ,  /* OS/390 2.10 and     */\n      Substr(JESLEV,1,8) == 'z/OS 1.2' then,  /* z/OS 1.2            */\n      JESNODE  = Strip(Storage(D2x(JESSUS2+452),8)) /* JES2 NODE     */\n    When Substr(JESLEV,1,6) == 'OS 1.1' | , /* OS/390 1.1  or        */\n      Substr(JESLEV,1,4) == 'SP 5' then ,    /* ESA V5 JES2          */\n      JESNODE  = Strip(Storage(D2x(JESSUS2+336),8)) /*   JES2 NODE   */\n    When Substr(JESLEV,1,5) == 'OS 1.' | ,   /* OS/390 1.2           */\n      Substr(JESLEV,1,5) == 'OS 2.' then,    /*  through OS/390 2.9  */\n      JESNODE  = Strip(Storage(D2x(JESSUS2+372),8)) /* JES2 NODE     */\n    Otherwise ,                              /* Lower than ESA V5    */\n      If ENV = 'OMVS' then JESNODE = '*not_avail*'\n      else JESNODE  = SYSVAR('SYSNODE')      /* TSO/E VAR for JESNODE*/\n  End  /* select */\nEnd /* else do */\n/*                                                                   */\nCVTVERID = Storage(D2x(CVT - 24),16)         /* \"user\" software vers.*/\nCVTRAC   = C2d(Storage(D2x(CVT + 992),4))    /* point to RACF CVT    */\nRCVT     = CVTRAC                            /* use RCVT name        */\nRCVTID   = Storage(D2x(RCVT),4)              /* point to RCVTID      */\n                                             /* RCVT, ACF2, or RTSS  */\nSECNAM = RCVTID                              /* ACF2 SECNAME = RCVTID*/\nIf RCVTID = 'RCVT' then SECNAM = 'RACF'      /* RCVT is RACF         */\nIf RCVTID = 'RTSS' then SECNAM = 'Top Secret'  /* RTSS is Top Secret */\nRACFVRM  = Storage(D2x(RCVT + 616),4)        /* RACF Ver/Rel/Mod     */\nRACFVER  = Substr(RACFVRM,1,1)               /* RACF Version         */\nRACFREL  = Substr(RACFVRM,2,2)               /* RACF Release         */\nIf Bitand(CVTOSLV2,'01'x) <> '01'x then ,    /* below OS/390 R10     */\n  RACFREL  = Format(RACFREL)                 /* Remove leading 0     */\nRACFMOD  = Substr(RACFVRM,4,1)               /* RACF MOD level       */\nRACFLEV  = RACFVER || '.' || RACFREL || '.' || RACFMOD\nIf RCVTID = 'RCVT' | RCVTID = 'RTSS' then ,\n RCVTDSN = Strip(Storage(D2x(RCVT + 56),44))    /* RACF prim dsn or  */\n                                                /* TSS Security File */\nIf SECNAM = 'ACF2' then do\n  SSCVT    = C2d(Storage(D2x(JESCT+24),4))   /* point to SSCVT       */\n  Do while SSCVT <> 0\n    SSCTSNAM = Storage(D2x(SSCVT+8),4)       /* subsystem name       */\n    If SSCTSNAM = 'ACF2' then do\n      ACCVT    = C2d(Storage(D2x(SSCVT + 20),4)) /* ACF2 CVT         */\n      ACCPFXP  = C2d(Storage(D2x(ACCVT - 4),4))  /* ACCVT prefix     */\n      ACCPIDL  = C2d(Storage(D2x(ACCPFXP + 8),2))  /* Len ident area */\n      LEN_ID   = ACCPIDL-4 /* don't count ACCPIDL and ACCPIDO in len */\n      ACCPIDS  = Strip(Storage(D2x(ACCPFXP + 12),LEN_ID)) /*sys ident*/\n      ACF2DSNS = C2d(Storage(D2x(ACCVT + 252) ,4)) /* ACF2 DSNs      */\n      ACF2DNUM = C2d(Storage(D2x(ACF2DSNS + 16),2)) /* # OF DSNs     */\n      Leave\n    End\n  SSCVT    = C2d(Storage(D2x(SSCVT+4),4))    /* next sscvt or zero   */\n  End  /*  Do while SSCVT <> 0 */\nEnd\n/*                                                                   */\nCVTDFA   = C2d(Storage(D2x(CVT + 1216),4))   /* point to DFP ID table*/\nDFAPROD  = C2d(Storage(D2x(CVTDFA +16),1))   /* point to product byte*/\nIf DFAPROD = 0 then do                       /* DFP not DF/SMS       */\n  DFAREL   = C2x(Storage(D2x(CVTDFA+2),2))   /* point to DFP release */\n  DFPVER   = Substr(DFAREL,1,1)              /* DFP Version          */\n  DFPREL   = Substr(DFAREL,2,1)              /* DFP Release          */\n  DFPMOD   = Substr(DFAREL,3,1)              /* DFP Mod Lvl          */\n  DFPRD    = 'DFP'                           /* product is DFP       */\n  DFLEV    = DFPVER || '.' || DFPREL || '.' || DFPMOD\nEnd\nElse do                                      /* DFSMS not DFP        */\n  DFARELS  = C2x(Storage(D2x(CVTDFA+16),4))  /* point to DF/SMS rel  */\n  DFAVER   = X2d(Substr(DFARELS,3,2))        /* DF/SMS Version       */\n  DFAREL   = X2d(Substr(DFARELS,5,2))        /* DF/SMS Release       */\n  DFAMOD   = X2d(Substr(DFARELS,7,2))        /* DF/SMS Mod Lvl       */\n  DFPRD    = 'DFSMS'                         /* product is DF/SMS    */\n  DFLEV    = DFAVER || '.' || DFAREL || '.' || DFAMOD\n  If DFAPROD = 2 then DFLEV = 'OS/390' DFLEV\n  If DFAPROD = 3 then do\n    DFLEV    = 'z/OS' DFLEV\n    /* Next section of code doesn't work because CRT is in key 5 */\n       /*\n    CVTCBSP  = C2d(Storage(D2x(CVT + 256),4))      /* point to AMCBS */\n    CRT      = C2d(Storage(D2x(CVTCBSP + 124),4))  /* point to CRT   */\n    CRTFMID  = Storage(D2x(CRT + 472),7)           /* DFSMS FMID     */\n       */\n  End /* if DFAPROD = 3 */\n  JESSMSIB = C2d(Storage(D2x(JESCTEXT+84),4)) /* point to SMS SSIB   */\n  IGDSSIVT = C2d(Storage(D2x(JESSMSIB+32),4))  /* SMS vector table   */\n  IGDSMS   = Storage(D2x(IGDSSIVT+132),2)      /* IGDSMSxx suffix    */\n  SMSACDS  = Strip(Storage(D2x(IGDSSIVT+44),44))   /* ACDS           */\n  SMSCMDS  = Strip(Storage(D2x(IGDSSIVT+88),44))   /* COMMDS         */\nEnd\n/*                                                                   */\nCVTTVT   = C2d(Storage(D2x(CVT + 156),4))    /* point to TSO vect tbl*/\nTSVTLVER = Storage(D2x(CVTTVT+100),1)        /* point to TSO Version */\nTSVTLREL = Storage(D2x(CVTTVT+101),2)        /* point to TSO Release */\nTSVTLREL = Format(TSVTLREL)                  /* Remove leading 0     */\nTSVTLMOD = Storage(D2x(CVTTVT+103),1)        /* point to TSO Mod Lvl */\nTSOLEV   = TSVTLVER || '.' || TSVTLREL || '.' || TSVTLMOD\n/*                                                                   */\nCHKVTACT = Storage(D2x(CVTEXT2+64),1)        /* VTAM active flag     */\nIf bitand(CHKVTACT,'80'x) = '80'x then do      /* vtam is active     */\n  CVTATCVT = C2d(Storage(D2x(CVTEXT2 + 65),3)) /* point to VTAM AVT  */\n  ISTATCVT = C2d(Storage(D2x(CVTATCVT + 0),4)) /* point to VTAM CVT  */\n  ATCVTLVL = Storage(D2x(ISTATCVT + 0),8)      /* VTAM Rel Lvl VOVRP */\n  VTAMVER  = Substr(ATCVTLVL,3,1)              /* VTAM Version   V   */\n  VTAMREL  = Substr(ATCVTLVL,4,1)              /* VTAM Release    R  */\n  VTAMMOD  = Substr(ATCVTLVL,5,1)              /* VTAM Mod Lvl     P */\n  If VTAMMOD = ' ' then VTAMLEV =  VTAMVER || '.' || VTAMREL\n    else VTAMLEV =  VTAMVER || '.' || VTAMREL || '.' || VTAMMOD\n/*                                                                   */\n  ATCNETID = Strip(Storage(D2x(ISTATCVT + 2080),8))  /* VTAM NETID   */\n  ATCNQNAM = Strip(Storage(D2x(ISTATCVT + 2412),17)) /* VTAM SSCPNAME*/\n  VTAM_ACTIVE = 'YES'\nEnd /* if bitand (vtam is active) */\nElse VTAM_ACTIVE = 'NO'\nIf Bitand(CVTOSLV1,'80'x) = '80'x then do    /* HBB4430 ESA V4.3 & > */\n  ECVTTCP     = D2x(ECVT + 176)              /* TCPIP                */\n  TSAB        = C2d(Storage(ECVTTCP,4))      /* point to TSAB        */\n  TSABLEN     = C2d(Storage(D2x(TSAB+4),2))  /* Length of TSAB       */\n  TSEBNUM     = (TSABLEN - 64) / 128         /* Number of TSEBs      */\n  TCPANUM     = 0                            /* counter of act TSEBs */\n  TCP_ACTIVE  = 'NO'                         /* Init active flag     */\n  Do SCNTSEBS = 1 to TSEBNUM                 /* Scan TSEB loop       */\n    TSEB = TSAB + 64 + (SCNTSEBS-1)*128\n    TCPASID = C2x(Storage(D2x(TSEB + 56),2)) /* asid or zero         */\n    If TCPASID <> 0 then do                  /* active asid          */\n      TCP_ACTIVE = 'YES'\n      TCPANUM = TCPANUM + 1                /* add 1 to active count  */\n      TCPSTATUS           =     Storage(D2x(TSEB +  8),1)\n      TCPNAME.TCPANUM     =     Storage(D2x(TSEB + 16),8)\n      TCPNUM.TCPANUM      = C2x(Storage(D2x(TSEB + 24),1))\n      TCPVER.TCPANUM      = C2x(Storage(D2x(TSEB + 26),2))\n      TCPASID.TCPANUM     = TCPASID '('Right(X2d(TCPASID),4)')'\n      Select\n        When Bitand(TCPSTATUS,'80'x) = '80'x then TCPST = 'Active'\n        When Bitand(TCPSTATUS,'40'x) = '40'x then TCPST = 'Terminating'\n        When Bitand(TCPSTATUS,'20'x) = '20'x then TCPST = 'Down'\n        When Bitand(TCPSTATUS,'10'x) = '10'x then TCPST = 'Stopped'\n        Otherwise say 'Bad TCPSTATUS! Contact Mark Zelden' TCPSTATUS\n      End /*  select  */\n      TCPST.TCPANUM     = TCPST\n    End /* If TCPASID <> 0 */\n  End /* Do SCNTSEBS = 1 to TSEBNUM */\nEnd /* If Bitand(CVTOSLV1,'80'x) = '80'x */\nIf Bitand(CVTOSLV1,'02'x) <> '02'x then ,    /* Below OS/390 R1      */\n  Queue 'The MVS version is 'PRODNAME' - FMID 'FMIDNUM'.'\nElse do\n  PRODNAM2 = Storage(D2x(ECVT+496),16)       /* point to product name*/\n  PRODNAM2 = Strip(PRODNAM2,'T')             /* del trailing blanks  */\n  VER      = Storage(D2x(ECVT+512),2)        /* point to version     */\n  REL      = Storage(D2x(ECVT+514),2)        /* point to release     */\n  MOD      = Storage(D2x(ECVT+516),2)        /* point to mod level   */\n  VRM      = VER'.'REL'.'MOD\n  Queue 'The OS version is 'PRODNAM2 VRM' - FMID' ,\n         FMIDNUM' ('PRODNAME').'\nEnd\nIf CVTVERID <> ' ' then ,\n  Queue 'The \"user\" system software version is' Strip(CVTVERID,'T')'.'\nQueue 'The primary job entry subsystem is 'JESPJESN'.'\nQueue 'The 'JESPJESN 'level is 'JESLEV'.' ,\n      'The 'JESPJESN 'node name is 'JESNODE'.'\nIf SECNAM <> 'RACF' | RACFVRM < '2608' then do\n  Queue 'The security software is 'SECNAM'.'\n  If SECNAM = 'ACF2' then do\n    Queue 'The ACF2 level is' ACCPIDS'.'\n    Queue '  There are 'ACF2DNUM' ACF2 data sets in use:'\n    Do ADSNS = 1 to ACF2DNUM\n      ADSOFF   = ACF2DSNS + 24 + (ADSNS-1)*64\n      ACF2TYPE = Storage(D2x(ADSOFF) , 8)\n      ACF2DSN  = Storage(D2x(ADSOFF + 16),44)\n      Queue '   ' ACF2TYPE '-' ACF2DSN\n    End\n  End /* if secname = 'ACF2' */\n  If Bitand(CVTOSLV6,'40'x) = '40'x then nop /* z/OS 2.2 and above */\n    Else Queue '  The RACF level is 'RACFLEV'.' /*dont show racflev*/\n  If SECNAM = 'Top Secret' then ,\n   Queue '  The TSS Security File data set is' RCVTDSN'.'\n  If SECNAM = 'RACF' then ,\n   Queue '  The RACF primary data set is' RCVTDSN'.'\nEnd\nElse do\n  /* RACF system */\n  RCVTDSDT  = C2d(Storage(D2x(RCVT + 224),4))  /* point to RACFDSDT*/\n  DSDTNUM   = C2d(Storage(D2x(RCVTDSDT+4),4))  /* num RACF dsns    */\n  DSDTPRIM  = Storage(D2x(RCVTDSDT+177),44)    /* point to prim ds */\n  DSDTPRIM  = Strip(DSDTPRIM,'T')              /* del trail blanks */\n  DSDTBACK  = Storage(D2x(RCVTDSDT+353),44)    /* point to back ds */\n  DSDTBACK  = Strip(DSDTBACK,'T')              /* del trail blanks */\n  If Bitand(CVTOSLV6,'40'x) = '40'x then do /* z/OS 2.2 and above  */\n    Queue 'The security software is' Word(PRODNAM2,1) ,\n          'Security Server (RACF).'\n    Queue 'The RACF level is' PRODNAM2 VRM || '.'\n  End\n  Else do\n    Queue 'The security software is' Word(PRODNAM2,1) ,\n          'Security Server (RACF).' ,\n          'The FMID is HRF' || RACFVRM || '.'\n  End\n  If DSDTNUM = 1 then do\n    Queue '  The RACF primary data set is' DSDTPRIM'.'\n    Queue '  The RACF backup  data set is' DSDTBACK'.'\n  End\n  Else do\n    Queue '  RACF is using a split database. There are' DSDTNUM ,\n          'pairs of RACF data sets:'\n    RDTOFF = 0                            /* init cur offset to 0 */\n    DSDTENTY_SIZE = 352                   /* dsdtenty size        */\n    Do RDSNS = 1 to DSDTNUM\n      DSDTPRIM  = Storage(D2x(RCVTDSDT+177+RDTOFF),44) /* prim dsn */\n      DSDTPRIM  = Strip(DSDTPRIM,'T')                  /* del blnks*/\n      DSDTBACK  = Storage(D2x(RCVTDSDT+353+RDTOFF),44) /* bkup dsn */\n      DSDTBACK  = Strip(DSDTBACK,'T')                  /* del blnks*/\n      RDTOFF = RDTOFF + DSDTENTY_SIZE            /* next tbl entry */\n      Queue '    Primary #'RDSNS' - ' DSDTPRIM\n      Queue '    Backup  #'RDSNS' - ' DSDTBACK\n    End  /* do RDSNS = 1 to DSDTNUM */\n  End\nEnd /* else do */\nQueue 'The' DFPRD 'level is' DFLEV'.'\nIf DFPRD = 'DFSMS' then do\n  Queue '  The SMS parmlib member is IGDSMS'igdsms'.'\n  Queue '  The SMS ACDS data set name is' SMSACDS'.'\n  Queue '  The SMS COMMDS data set name is' SMSCMDS'.'\nEnd\nQueue 'The TSO level is 'TSOLEV'.'\nIf SYSISPF = 'ACTIVE' then do                /* is ISPF active?      */\n  Address ISPEXEC \"VGET ZISPFOS\"             /* yes, is it OS?390?   */\n  If RC = 0 then do                          /* yes, get OS/390 var  */\n    ISPFLEV = Strip(Substr(ZISPFOS,10,15))   /* only need version    */\n    Address ISPEXEC \"VGET ZENVIR\"            /* ispf internal rel var*/\n    ISPFLEVI = Substr(ZENVIR,1,8)            /* internal ISPF release*/\n    Queue 'The ISPF level is 'ISPFLEV' ('ISPFLEVI').'\n  End  /* if RC */\n  Else do                          /* not OS/390 - use old variables */\n    Address ISPEXEC \"VGET ZPDFREL\"           /* get pdf release info */\n    ISPFLEV  = Substr(ZENVIR,6,3)            /* ISPF level           */\n    PDFLEV   = Substr(ZPDFREL,5,3)           /* PDF  level           */\n    Queue 'The ISPF level is 'ISPFLEV'. The PDF level is' PDFLEV'.'\n  End /* else do */\nEnd  /* if SYSISPF */\nIf VTAM_ACTIVE = 'YES' then do\n  Queue 'The VTAM level is 'VTAMLEV'.'\n  Queue '  The NETID is' ATCNETID'. The SSCPNAME is' ATCNQNAM'.'\nEnd /* if VTAM_ACTIVE = YES */\nElse Queue 'The VTAM level is not available - VTAM is not active.'\nIf Bitand(CVTOSLV1,'80'x) = '80'x then do    /* HBB4430 ESA V4.3 & > */\n  If TCP_ACTIVE = 'YES' then do\n    Queue 'The TCP/IP stack is active. ',\n          'There are 'TCPANUM' active TSEBs out of 'TSEBNUM'.'\n    Queue '  SI Proc       Vers   ASID ( dec)   Status'\n    Queue '  -- --------   ----   ---- ------   ------'\n    Do LSI = 1 to TCPANUM\n      Queue '  'Right(TCPNUM.LSI,2)' 'TCPNAME.LSI'   'TCPVER.LSI'  ',\n            TCPASID.LSI'   'TCPST.LSI\n    End\n  End /* if TCP_ACTIVE = YES */\n  Else Queue 'The TCP level is not available - TCP is not active.'\nEnd /*  If Bitand(CVTOSLV1,'80'x) = '80'x   */\nReturn\n\nSTOR:                /* Storage information sub-routine              */\nQueue ' '\nCVTRLSTG = C2d(Storage(D2x(CVT + 856),4))    /* point to store at IPL*/\nCVTRLSTG = CVTRLSTG/1024                     /* convert to Megabytes */\nIf zARCH <> 2 then do                        /* not valid in 64-bit  */\n  CVTEORM  = C2d(Storage(D2x(CVT + 312),4))  /* potential real high  */\n  CVTEORM  = (CVTEORM+1)/1024/1024           /* convert to Megabytes */\n  ESTOR    = C2d(Storage(D2x(RCE + 160),4))  /* point to ESTOR frames*/\n  ESTOR    = ESTOR*4/1024                    /* convert to Megabytes */\nEnd\n  /**********************************************************/\n  /* At z/OS 2.1 CVTRLSTG was not always correct. The code  */\n  /* below gets the value from the RSM Internal Table       */\n  /* field 'RITTOTALONLINESTORAGEATIPL'.                    */\n  /* The RIT is documented in the MVS Data Areas manual     */\n  /*  - This was a bug fixed by APAR OA48094                */\n  /**********************************************************/\n /*\nIf Bitand(CVTOSLV6,'80'x) = '80'x then do    /* z/OS 2.1  and above  */\nCVTPVTP  = C2d(Storage(D2x(CVT+356),4))      /* point page vect tbl  */\nPVTRIT   = C2x(Storage(D2x(CVTPVTP+4),4))    /* RSM internal tbl OCO */\nRITOLSTG = X2d(C2x(Storage(D2x(X2d(PVTRIT)+X2d(128)),8)))\nRITOLSTG = RITOLSTG/1024/1024                /* convert to Megabytes */\nCVTRLSTG = RITOLSTG            /* change the name for code below     */\nEnd\n  */\nIf Bitand(CVTOSLV0,'08'x) = '08'x then do    /* HBB4410 ESA V4 & >   */\n  ECVTEORM  = C2d(Storage(d2x(ECVT+600),8))  /* potential real high  */\n  RECONFIG  = (ECVTEORM-CVTRLSTG*1024*1024+1)/(1024*1024) /* amt of  */\n                                             /* reconfigurable stor  */\nEnd\nIf Bitand(CVTOSLV5,'40'x) = '40'x then do    /* z/OS 1.7 and above   */\n  RCECADSUsed = C2d(Storage(D2x(RCE + 572),2)) /* CADS current use   */\n  RCECADSHW   = C2d(Storage(D2x(RCE + 574),2)) /* CADS high water    */\nEnd\nCall STORAGE_GDA_LDA\nIf Bitand(CVTOSLV2,'01'x) = '01'x then do    /* OS/390 R10 and above */\n  SCCBSAI  = C2d(Storage(D2x(SCCB + 10),1))  /* real stor incr. in M */\n  If SCCBSAI =  0 then do                    /* If 0, use SCCBSAIX   */\n    SCCBSAIX = C2d(Storage(D2x(SCCB + 100),4)) /* real stor incr in M*/\n    SCCBSAI  = SCCBSAIX                      /* using SCCBSAI later  */\n  End\n  SCCBSAR  = C2d(Storage(D2x(SCCB + 8),2))   /* # of. incr installed */\nEnd\nIf zARCH <> 2 then do       /* not valid in 64-bit */\n  Queue 'The real storage size at IPL time was 'Format(CVTRLSTG,,0)'M.'\n  Queue 'The potential real storage size is' ,\n         Format(CVTEORM,,0)'M.'\n  If ESTOR > 0 then\n    Queue 'The expanded storage size is 'ESTOR'M.'\n  Else\n    Queue 'The system has no expanded storage.'\nEnd /* If zARCH <> 2 */\nElse Queue 'The real storage online at IPL time' ,\n           'was 'Format(CVTRLSTG,,0)'M.'\nIf Bitand(CVTOSLV2,'01'x) = '01'x then ,     /* OS/390 R10 and above */\n  If SCCBSAI <> 0 then ,\n    Queue 'The real storage increment size is 'SCCBSAI'M with' ,\n           SCCBSAR 'increments installed.'\nIf Bitand(CVTOSLV0,'08'x) = '08'x then do    /* HBB4410 ESA V4 & >   */\n  Queue 'The potential real storage size is' ,\n         (ECVTEORM+1)/(1024*1024)'M.'\n  Queue 'The reconfigurable storage size is 'reconfig'MB.'\nEnd\nQueue 'The private area size <16M is 'GDAPVTSZ'K.'\nQueue 'The private area size >16M is 'GDAEPVTS'M.'\nQueue 'The CSA size <16M is 'GDACSASZ'K.'\nQueue 'The CSA size >16M is 'GDAECSAS'K.'\nQueue 'The SQA size <16M is 'GDASQASZ'K.'\nQueue 'The SQA size >16M is 'GDAESQAS'K.'\nQueue 'The maximum V=R region size is 'GDAVRSZ'K.'\nQueue 'The default V=R region size is 'GDAVREGS'K.'\nQueue 'The maximum V=V region size is 'LDASIZEA'K.'\nIf Bitand(CVTOSLV5,'40'x) = '40'x then do    /* z/OS 1.7 and above   */\n  Queue 'The current number of CADS (MAXCADs)' ,\n        'in use is 'RCECADSUsed'.'\n  Queue 'The maximum number of CADS (MAXCADs)' ,\n        'used since IPL is 'RCECADSHW'.'\nEnd\nReturn\n\nCPU:                 /* CPU information sub-routine                  */\nQueue ' '\nIf Bitand(CVTOSLV3,'01'x) = '01'x then ,  /* z/OS 1.6 & above >16 CPs*/\n  NUMCPU   = C2d(Storage(D2x(CSD + 212),4))  /* point to # of CPUS   */\nElse,\n  NUMCPU   = C2d(Storage(D2x(CSD + 10),2))   /* point to # of CPUS   */\nSCCBNCPS = C2d(Storage(d2x(SCCB + 16),2))    /* Max No. of CPUs      */\n/*                                                                   */\nQueue 'The CPU model number is 'MODEL'.'\nQueue 'The number of online CPUs is 'NUMCPU'.' ,\n      'The maximum number of CPUs is 'SCCBNCPS'.'\nIf Bitand(CVTOSLV3,'20'x) = '20'x & ,        /* z/OS 1.1 and above   */\n   Bitand(CVTOSLV3,'01'x) <> '01'x then do   /* but below z/OS 1.6   */\n  CSDICPUS = C2d(Storage(D2x(CSD+161),1))    /* CPUs online @ IPL    */\n  Queue '  The number of CPUs online at IPL time was 'CSDICPUS'.'\nEnd\nIf Bitand(CVTOSLV3,'01'x) = '01'x then do    /* z/OS 1.6 and above   */\n  CSDICPUS = C2d(Storage(D2x(CSD+161),1))    /* CPUs online @ IPL    */\n  CSDIIFAS = C2d(Storage(D2x(CSD+162),1))    /* zAAPs online @ IPL   */\n  Queue '  The number of GPs online at IPL time was 'CSDICPUS'.'\n  If CSDIIFAS <> 0 then ,\n  Queue '  The number of zAAPs online at IPL time was 'CSDIIFAS'.'\n  If Bitand(CVTOSLV4,'02'x) = '02'x then do /* zIIP (SUP) support    */\n    CSDISUPS = C2d(Storage(D2x(CSD+163),1))  /* zIIPs online @ IPL   */\n    If CSDISUPS <> 0 then ,\n    Queue '  The number of zIIPs online at IPL time was 'CSDISUPS'.'\n  End\nEnd\n/*                                                                   */\nCPNUM     = 0\nFOUNDCPUS = 0\nFOUNDZAPS = 0\nFOUNDZIPS = 0\nDo until FOUNDCPUS = NUMCPU\nPCCA = C2d(Storage(D2x(PCCAVT + CPNUM*4),4)) /* point to PCCA        */\n  If PCCA <> 0 then do\n    CPUVER   = Storage(D2x(PCCA + 4),2)      /* point to VERSION     */\n    CPUID    = Storage(D2x(PCCA + 6),10)     /* point to CPUID       */\n    IDSHORT  = Substr(CPUID,2,5)\n    PCCAATTR = Storage(D2x(PCCA + 376),1)    /* attribute byte       */\n    PCCARCFF = Storage(D2x(PCCA + 379),1)    /* reconfig flag        */\n    CP_TYP   = ''                            /* init to null for now */\n    If Bitand(PCCAATTR,'01'x) = '01'x then do  /* check PCCAIFA      */\n       CP_TYP = '(zAAP)'                       /* zAAP / IFA CP      */\n       FOUNDZAPS = FOUNDZAPS + 1\n    End\n    If Bitand(PCCAATTR,'04'x) = '04'x then do  /* check PCCAzIIP     */\n       CP_TYP = '(zIIP)'                       /* zIIP processor     */\n       FOUNDZIPS = FOUNDZIPS + 1\n    End\n    If Bitand(PCCARCFF,'80'x) = '80'x then ,   /* check PCCACWLM     */\n       CP_TYP = '(WLM)'                        /* WLM controlled CP  */\n    CPNUM_M = D2x(CPNUM)                       /* display in hex     */\n    If Bitand(CVTOSLV3,'01'x) = '01'x then ,   /* z/OS 1.6 & above   */\n      CPNUM_M = Right(CPNUM_M,2,'0')           /* display as 2 digits*/\n    Queue 'The CPU serial number for CPU 'CPNUM_M' is ' || ,\n     CPUID' ('IDSHORT'), version code' CPUVER'.' CP_TYP\n    FOUNDCPUS = FOUNDCPUS + 1\n  End\nCPNUM = CPNUM + 1\nEnd  /* do until  */\n/**************************************************/\n/* SUs/SEC and MIPS calculations                  */\n/* SYS1.NUCLEUS(IEAVNP10) CSECT IRARMCPU          */\n/**************************************************/\nRMCT     = C2d(Storage(D2x(CVT+604),4))      /* point to RMCT        */\nSU       = C2d(Storage(D2x(RMCT+64),4))      /* CPU Rate Adjustment  */\nSUSEC    = Format((16000000/SU),7,2)         /* SUs per second       */\nMIPSCP   = NUMCPU-FOUNDZAPS-FOUNDZIPS        /* Don't include special*/\n                                             /* processors for MIPs  */\nMIPS     = Format((SUSEC/48.5) * MIPSCP,6,2) /* SRM MIPS calculation */\n                                             /* (48.5) borrowed from */\n                                             /* Thierry Falissard    */\nQueue 'The service units per second per online CPU is' Strip(SUSEC)'.'\nQueue 'The approximate total MIPS (SUs/SEC / 48.5 * # general CPUs)' ,\n      'is' Strip(MIPS)'.'\n  /*\nRMCTCCT  = C2d(Storage(D2x(RMCT+4),4))       /* cpu mgmt control tbl */\nCCVUTILP = C2d(Storage(D2x(RMCTCCT+102),2))  /* CPU Utilization      */\nQueue 'The approximate CPU utilization is' CCVUTILP'%.'\n       */\nIf Bitand(CVTOSLV3,'20'x) = '20'x then do    /* z/OS 1.1 and above   */\n                                             /* w/APAR OW55509       */\n  RCT      = C2d(Storage(D2x(RMCT+228),4))   /* Resource Control Tbl */\n  RCTLACS  = C2d(Storage(D2x(RCT+196),4))    /* 4 hr MSU average     */\n  RCTIMGWU = C2d(Storage(D2x(RCT+28),4))     /* Image defined MSUs   */\n  RCTCECWU = C2d(Storage(D2x(RCT+32),4))     /* CEC MSU Capacity     */\n  If RCTCECWU <> 0 then do\n    Queue 'The MSU capacity for this CEC is' RCTCECWU'.'\n    Queue 'The defined MSU capacity for this LPAR is' RCTIMGWU'.'\n  End\n  If RCTLACS <> 0 then do\n    Queue 'The 4 hour MSU average usage is' RCTLACS'.'\n    If RCTLACS >= RCTIMGWU & RCTIMGWU <> RCTCECWU then ,\n      Queue ' ** This LPAR is currently being \"soft capped\". **'\n  End\nEnd\n/*                                                                   */\nIf Bitand(CVTOSLV5,'20'x) = '20'x then do    /* z/OS 1.8 and above   */\n  IEAVESVT = C2d(Storage(D2x(CVT + 868),4))  /* supv. vect tbl IHASVT*/\n  SVTAFFB  = Storage(D2x(IEAVESVT + 12),1)   /* aff-dispatch byte    */\n  If Bitand(SVTAFFB,'80'x) = '80'x then ,\n    Queue 'The HiperDispatch feature is active on this LPAR.'\n  Else Queue 'The HiperDispatch feature is not active on this LPAR.'\n  CPCRPERC = C2d(Storage(D2x(IEAVESVT+1008),4)) /* CPCR Percent      */\n  If CPCRPERC <> 0 then\n    Queue 'The CP Credits feature is active on this CPC/LPAR' ,\n          'at' CPCRPERC'%.'\nEnd\n/**************************************************/\n/* Central Processing Complex Node Descriptor     */\n/**************************************************/\nIf Bitand(CVTOSLV1,'20'x) = '20'x then do      /* HBB5510 ESA V5 & > */\n  CVTHID   = C2d(Storage(D2x(CVT + 1068),4))   /* point to SHID      */\n  CPCND_FLAGS = Storage(D2x(CVTHID+22),1)      /* pnt to CPCND FLAGS */\n  If CPCND_FLAGS <> 0 then do                  /* Is there a CPC?    */\n    CPCND_VALID = Bitand(CPCND_FLAGS,'E0'x)    /* Valid flags        */\n    CPCND_INVALID = Bitand('40'x)              /* Invalid flag       */\n    If CPCND_VALID <> CPCND_INVALID then do    /* Is it valid?       */\n      CPCND_TYPE  = Storage(D2x(CVTHID+26),6)  /* Type               */\n      CPCND_MODEL = Storage(D2x(CVTHID+32),3)  /* Model              */\n      CPCND_MAN   = Storage(D2x(CVTHID+35),3)  /* Manufacturer       */\n      CPCND_PLANT = Storage(D2x(CVTHID+38),2)  /* Plant of manufact. */\n      CPCND_SEQNO = Storage(D2x(CVTHID+40),12) /* Sequence number    */\n      CPC_ID      = C2x(Storage(D2x(CVTHID+55),1))  /* CPC ID        */\n      Queue ' '\n   /* Queue 'Central Processing Complex (CPC) Node Descriptor:' */\n      Queue 'Central Processing Complex (CPC) Information:'\n      Queue '  CPC ND =',\n       CPCND_TYPE'.'CPCND_MODEL'.'CPCND_MAN'.'CPCND_PLANT'.'CPCND_SEQNO\n      If Bitand(CVTOSLV3,'10'x) = '10'x then do    /*z/OS 1.2 & above*/\n        Call GET_CPCSI /* Get CPC SI (STSI) information sub-routine  */\n        Queue '  CPC SI ='  CPCSI_TYPE'.'CPCSI_MODEL'.'  || ,\n               CPCSI_MAN'.'CPCSI_PLANT'.'CPCSI_CPUID\n        Queue '           Model:' CPCSI_MODELID\n      End /* If Bitand(CVTOSLV3,'10'x) = '10'x */\n      Queue '  CPC ID =' CPC_ID\n      Queue '  Type('CPCND_TYPE') Model('CPCND_MODEL')',\n            'Manufacturer('CPCND_MAN') Plant('CPCND_PLANT')',\n            'Seq Num('CPCND_SEQNO')'\n      If Bitand(CVTOSLV3,'20'x) = '20'x then do    /*z/OS 1.1 & above*/\n        RMCTX1M  = Storage(D2x(RMCT+500),4)        /* Microcode addr */\n                                                   /*   in RMCTX1    */\n        If RMCTX1M  <> '7FFFF000'x then do         /* skip VM/FLEX/ES*/\n          RMCTX1M  = C2d(RMCTX1M)                  /* change to dec. */\n          MCL      = Storage(D2x(RMCTX1M + 40),8)  /* Microcode lvl  */\n          MCLDRV   = Substr(MCL,1,4)               /* Driver only..  */\n          If Datatype(MCLDRV,'Number') = 1 then ,  /* if all numeric */\n             MCLDRV = Format(MCLDRV)               /* rmv leading 0s */\n          Queue '  The Microcode level of this CPC is' MCL || ,\n                ' (Driver' MCLDRV').'\n        End /* If RMCTX1M  <> '7FFFF000'x */\n      End /* If Bitand(CVTOSLV3,'20'x) = '20'x */\n    End /* if CPCND_VALID <> CPCND_INVALID */\n    Else do\n      If Bitand(CVTOSLV3,'10'x) = '10'x then do    /*z/OS 1.2 & above*/\n        Call GET_CPCSI /* Get CPC SI (STSI) information sub-routine  */\n        Queue ' '\n        Queue 'Central Processing Complex (CPC) Information:'\n        Queue '  CPC SI ='  CPCSI_TYPE'.'CPCSI_MODEL'.'  || ,\n               CPCSI_MAN'.'CPCSI_PLANT'.'CPCSI_CPUID\n        Queue '           Model:' CPCSI_MODELID\n      End /* if Bitand(CVTOSLV3,'10'x) = '10'x */\n    End /* else do */\n  End  /* if CPCND_FLAGS <>0  */\nEnd\nReturn\n\nIPA:                 /* IPA information sub-routine                  */\nQueue ' '\n/*********************************************************************/\n/* IPL parms from the IPA                                            */\n/*********************************************************************/\nIf Bitand(CVTOSLV1,'01'x) = '01'x then do    /* OS/390 R2 and above  */\n  IPAICTOD = Storage(D2x(ECVTIPA + 8),8)     /* point to IPL TOD     */\n  IPALPARM = Storage(D2x(ECVTIPA + 16),8)    /* point to LOAD PARM   */\n  IPALPDSN = Storage(D2x(ECVTIPA + 48),44)   /* load parm dsn name   */\n  IPALPDDV = Storage(D2x(ECVTIPA + 92),4)    /* load parm dev number */\n  IPAHWNAM = Storage(D2x(ECVTIPA + 24),8)    /* point to HWNAME      */\n  IPAHWNAM = Strip(IPAHWNAM,'T')             /* del trailing blanks  */\n  IPALPNAM = Storage(D2x(ECVTIPA + 32),8)    /* point to LPARNAME    */\n  IPALPNAM = Strip(IPALPNAM,'T')             /* del trailing blanks  */\n  IPAVMNAM = Storage(D2x(ECVTIPA + 40),8)    /* point to VMUSERID    */\n  /**************************/\n  /* PARMS in LOADxx        */\n  /**************************/\n  IPANUCID = Storage(D2x(ECVTIPA + 23),1)    /* NUCLEUS ID           */\n  IPAIODF  = Storage(D2x(ECVTIPA + 96),63)   /* IODF    card image   */\n  IPASPARM = Storage(D2x(ECVTIPA + 160),63)  /* SYSPARM card image   */\n  /*IPASCAT= Storage(D2x(ECVTIPA + 224),63)*//* SYSCAT  card image   */\n  IPASYM   = Storage(D2x(ECVTIPA + 288),63)  /* IEASYM  card image   */\n  IPAPLEX  = Storage(D2x(ECVTIPA + 352),63)  /* SYSPLEX card image   */\n  If Bitand(CVTOSLV2,'01'x) = '01'x then do  /* OS/390 R10 and above */\n    IPAPLNUMX = Storage(D2x(ECVTIPA + 2134),2) /* number of parmlibs */\n    IPAPLNUM  = IPAPLNUMX\n  End\n  Else ,                                     /* OS/390 R10 and above */\n    IPAPLNUM = Storage(D2x(ECVTIPA + 2148),2) /* number of parmlibs  */\n  IPAPLNUM = C2d(IPAPLNUM)                   /* convert to decimal   */\n  POFF = 0\n  Do P = 1 to IPAPLNUM\n    IPAPLIB.P = Storage(D2x(ECVTIPA+416+POFF),63) /* PARMLIB cards   */\n    IPAPLFLG.P = Storage(D2x(ECVTIPA+479+POFF),1)  /* flag bits      */\n    If Bitand(IPAPLFLG.P,'20'x) = '20'x then ,   /* volser from cat? */\n      IPAPLIB.P = Overlay('      ',IPAPLIB.P,46) /* no, clear it     */\n    POFF = POFF + 64\n  End\n  IPANLID  = Storage(D2x(ECVTIPA + 2144),2)  /* NUCLSTxx member used */\n  IPANUCW  = Storage(D2x(ECVTIPA + 2146),1)  /* load wait state char */\n  IPAICTOD = C2x(IPAICTOD)   /* make \"readable\" for REXXTOD call     */\n  Call REXXTOD IPAICTOD      /* convert TOD to YYYY.DDD HH:MM:SS.ttt */\n  TOD_RESY = Substr(RESULT,1,4)      /* year portion from REXXTOD    */\n  TOD_RESD = Substr(RESULT,6,3)      /* day  portion from REXXTOD    */\n  TOD_REST = Substr(RESULT,10,8)     /* time portion from REXXTOD    */\n  Call RDATE TOD_RESY TOD_RESD /* call RDATE- format for ISO/USA/EUR */\n  MMIPA    = Substr(RESULT,1,2)              /* MM from MM/DD/YYYY   */\n  DDIPA    = Substr(RESULT,4,2)              /* DD from MM/DD/YYYY   */\n  YYYYIPA  = Substr(RESULT,7,4)              /* YYYY from MM/DD/YYYY */\n  If DATEFMT = 'USA' then ,                  /* USA format date?     */\n    IPAIDATE = Substr(RESULT,1,10)           /* date as MM/DD/YYYY   */\n  If DATEFMT = 'EUR' then ,                  /* EUR format date?     */\n    IPAIDATE = DDIPA'/'MMIPA'/'YYYYIPA       /* date as DD/MM/YYYY   */\n  If DATEFMT = 'ISO' then ,                  /* ISO format date?     */\n    IPAIDATE = YYYYIPA'-'MMIPA'-'DDIPA       /* date as YYYY-MM-DD   */\n  Queue 'Initialization information from the IPA:'\n  Queue '  IPL TIME (GMT):' IPAIDATE ,\n           '('TOD_RESY'.'TOD_RESD') at' TOD_REST\n  Queue '  IPLPARM =' IPALPARM   '(merged)'\n  Queue '  IPL load parameter data set name: 'IPALPDSN\n  Queue '  IPL load parameter data set device address: 'IPALPDDV\n  Queue '  HWNAME='IPAHWNAM '  LPARNAME='IPALPNAM ,\n        '  VMUSERID='IPAVMNAM\n  Queue '  '                    /* add blank line for readability   */\n  Queue '  LOADxx parameters from the IPA' ,\n        '(LOAD' || Substr(IPALPARM,5,2) || '):'\n  Queue '    *---+----1----+----2----+----3----+----4' || ,\n            '----+----5----+----6----+----7--'\n  If Bitand(CVTOSLV2,'01'x) = '01'x then do    /* OS/390 R10 & above */\n    IPAARCHL = Storage(D2x(ECVTIPA + 2143),1)  /* ARCHLVL (1 or 2)   */\n    Queue '    ARCHLVL  'IPAARCHL\n  End\n  If IPASYM   <> '' then queue '    IEASYM   'IPASYM\n  If IPAIODF  <> '' then queue '    IODF     'IPAIODF\n  If IPANUCID <> '' then queue '    NUCLEUS  'IPANUCID\n  If IPANLID  <> '' then queue '    NUCLST   'IPANLID' 'IPANUCW\n  Do P = 1 to IPAPLNUM\n    Queue '    PARMLIB  'IPAPLIB.P\n  End\n  If IPASCAT  <> '' then queue '    SYSCAT   'IPASCAT\n  If IPASPARM <> '' then queue '    SYSPARM  'IPASPARM\n  If IPAPLEX  <> '' then queue '    SYSPLEX  'IPAPLEX\n  /**************************/\n  /* PARMS in IEASYSxx      */\n  /**************************/\n  Queue '  '                    /* add blank line for readability   */\n  Queue '  IEASYSxx parameters from the IPA:          ',\n        '                     (Source)'\n  Call BUILD_IPAPDETB    /* Build table for init parms               */\n  TOTPRMS = 0            /* tot num of specified or defaulted parms  */\n  Do I = 1 to IPAPDETB.0\n    Call EXTRACT_SYSPARMS IPAPDETB.I   /* extract parms from the IPA */\n  End\n /********************************************************************/\n /* Uncommment a sample below to test IPA PAGE parm \"split\" code:    */\n /*  PRMLINE.32 = 'SWAP SWAP=(SYS1.SWAP.TEST) IEASYSXX'              */\n /*  PRMLINE.32 = 'NONVIO NONVIO=(SYS1.PAGE.TEST) IEASYSXX'          */\n /*  PRMLINE.32 = 'NONVIO NONVIO=(SYS1.PAGE1,SYS1.PAGE2) IEASYSXX'   */\n /*  PRMLINE.32 = 'NONVIO ' || ,                                     */\n /*  'NONVIO=(SYS1.PAGE1,SYS1.PAGE2,SYS1.PAGE3,SYS1.PAGE4) IEASYSXX' */\n /********************************************************************/\n  Call SORT_IPA                       /* sort IPA parms              */\n  Call SPLIT_IPA_PAGE                 /* split page/swap dsn parms   */\n  Do I = 1 to TOT_IPALINES            /* add ipa parms               */\n    If I = TOT_IPALINES then ,        /*   to stack and              */\n      IPALINE.I = Translate(IPALINE.I,' ',',') /* remove comma       */\n    Queue IPALINE.I                   /*           from last parm    */\n  End\nEnd\nReturn\n\nSYMBOLS:             /* System Symbols information sub-routine       */\nQueue ' '\n/*********************************************************************/\n/* Find System Symbols  - ASASYMBP MACRO                             */\n/*  ECVT+X'128' = ECVTSYMT                                           */\n/*  2nd half word = # of symbols , after that each entry is 4 words  */\n/*  1st word = offset to symbol name                                 */\n/*  2nd word = length of symbol name                                 */\n/*  3rd word = offset to symbol value                                */\n/*  4th word = length of symbol value                                */\n/*********************************************************************/\nIf Bitand(CVTOSLV1,'10'x) = '10'x then do    /* HBB5520 ESA V5.2 & > */\n  ECVTSYMT = C2d(Storage(D2x(ECVT + 296),4)) /* point to ECVTSYMT    */\n  NUMSYMBS = C2d(Storage(D2x(ECVTSYMT + 2),2))  /* number of symbols */\n  Queue 'Static System Symbol Values:'\n  Do I = 1 to NUMSYMBS\n    SOFF = I*16-16\n    NAMOFF  = C2d(Storage(D2x(ECVTSYMT+4+SOFF),4))  /*offset to name */\n    NAMLEN  = C2d(Storage(D2x(ECVTSYMT+8+SOFF),4))  /*length of name */\n    VALOFF  = C2d(Storage(D2x(ECVTSYMT+12+SOFF),4)) /*offset to value*/\n    VALLEN  = C2d(Storage(D2x(ECVTSYMT+16+SOFF),4)) /*length of value*/\n    SYMNAME = Storage(D2x(ECVTSYMT+4+NAMOFF),NAMLEN) /*symbol name   */\n    If VALLEN = 0 then VALNAME = ''                 /* null value    */\n    Else ,\n    VALNAME = Storage(D2x(ECVTSYMT+4+VALOFF),VALLEN) /* symbol value */\n      If Bitand(CVTOSLV6,'40'x) = '40'x then ,   /* z/OS 2.2 and >   */\n      Queue ' ' Left(SYMNAME,18,' ') '=' VALNAME /* max 16 + & + .   */\n      Else ,\n      Queue ' ' Left(SYMNAME,10,' ') '=' VALNAME /* max 8 + & + .    */\n  End  /* do NUMSYMBS */\nEnd\nReturn\n\nVMAP:                /* Virtual Storage Map sub-routine              */\nArg VMAPOPT\nIf option <> 'ALL' then,\n  Call STORAGE_GDA_LDA                       /* GDA/LDA stor routine */\nSYSEND  = X2d(LDASTRTS) + (LDASIZS*1024) - 1 /* end of system area   */\nSYSEND  = D2x(SYSEND)                        /* display in hex       */\nIf GDAVRSZ = 0 then do                       /* no v=r               */\n  VRSTRT = 'N/A     '\n  VREND  = 'N/A     '\n  VVSTRT = LDASTRTA                          /* start of v=v         */\n  VVEND  =  X2d(LDASTRTA) + (LDASIZEA*1024) - 1 /* end of v=v        */\n  VVEND  =  D2x(VVEND)                       /* display in hex       */\nEnd\nElse do\n  VRSTRT =  LDASTRTA                         /* start of v=r         */\n  VREND  =  X2d(LDASTRTA) + (GDAVRSZ*1024) - 1 /* end of v=r         */\n  VREND  =  D2X(VREND)                       /* display in hex       */\n  VVSTRT =  LDASTRTA                         /* start of v=v         */\n  VVEND  =  X2d(LDASTRTA) + (LDASIZEA*1024) - 1 /* end of v=v        */\n  VVEND  =  D2x(VVEND)                       /* display in hex       */\nEnd\nGDACSA   = C2d(Storage(D2x(CVTGDA + 108),4)) /* start of CSA addr    */\nGDACSAH  = D2x(GDACSA)                       /* display in hex       */\nCSAEND   = (GDACSASZ*1024) + GDACSA - 1      /* end of CSA           */\nCSAEND   = D2x(CSAEND)                       /* display in hex       */\nCVTSMEXT = C2d(Storage(D2x(CVT +1196),4))    /* point to stg map ext.*/\nCVTMLPAS = C2d(Storage(D2x(CVTSMEXT+ 8),4))  /* start of MLPA addr   */\nCVTMLPAS = D2x(CVTMLPAS)                     /* display in hex       */\nIf CVTMLPAS <> 0 then do\n  CVTMLPAE = C2d(Storage(D2x(CVTSMEXT+12),4))  /* end of MLPA addr   */\n  CVTMLPAE = D2x(CVTMLPAE)                     /* display in hex     */\n  MLPASZ   = X2d(CVTMLPAE) - X2d(CVTMLPAS) + 1 /* size of MLPA       */\n  MLPASZ   = MLPASZ/1024                       /* convert to Kbytes  */\nEnd\nElse do /* no MLPA */\n  CVTMLPAS = 'N/A     '\n  CVTMLPAE = 'N/A     '\n  MLPASZ   = 0\nEnd\nCVTFLPAS = C2d(Storage(D2x(CVTSMEXT+16),4))  /* start of FLPA addr   */\nCVTFLPAS = D2x(CVTFLPAS)                     /* display in hex       */\nIf CVTFLPAS <> 0 then do\n  CVTFLPAE = C2d(Storage(D2x(CVTSMEXT+20),4))  /* end of FLPA addr   */\n  CVTFLPAE = D2x(CVTFLPAE)                     /* display in hex     */\n  FLPASZ   = X2d(CVTFLPAE) - X2d(CVTFLPAS) + 1 /* size of FLPA       */\n  FLPASZ   = FLPASZ/1024                       /* convert to Kbytes  */\nEnd\nElse do /* no FLPA */\n  CVTFLPAS = 'N/A     '\n  CVTFLPAE = 'N/A     '\n  FLPASZ   = 0\nEnd\nCVTPLPAS = C2d(Storage(D2x(CVTSMEXT+24),4))  /* start of PLPA addr   */\nCVTPLPAS = D2x(CVTPLPAS)                     /* display in hex       */\nCVTPLPAE = C2d(Storage(D2x(CVTSMEXT+28),4))  /* end of PLPA addr     */\nCVTPLPAE = D2x(CVTPLPAE)                     /* display in hex       */\nPLPASZ   = X2d(CVTPLPAE) - X2d(CVTPLPAS) + 1 /* size of PLPA         */\nPLPASZ   = PLPASZ/1024                       /* convert to Kbytes    */\nGDASQA   = C2d(Storage(D2x(CVTGDA + 144),4)) /* start of SQA addr    */\nGDASQAH  = D2x(GDASQA)                       /* display in hex       */\nSQAEND   = (GDASQASZ*1024) + GDASQA - 1      /* end of SQA           */\nSQAEND   = D2x(SQAEND)                       /* display in hex       */\nCVTRWNS  = C2d(Storage(D2x(CVTSMEXT+32),4))  /* start of R/W nucleus */\nCVTRWNS  = D2x(CVTRWNS)                      /* display in hex       */\nCVTRWNE  = C2d(Storage(D2x(CVTSMEXT+36),4))  /* end of R/W nucleus   */\nCVTRWNE  = D2x(CVTRWNE)                      /* display in hex       */\nRWNUCSZ  = X2d(CVTRWNE)  - X2d(CVTRWNS)  + 1 /* size of R/W nucleus  */\nRWNUCSZ  = Format(RWNUCSZ/1024,,0)           /* convert to Kbytes    */\nCVTRONS  = C2d(Storage(D2x(CVTSMEXT+40),4))  /* start of R/O nucleus */\nCVTRONS  = D2x(CVTRONS)                      /* display in hex       */\nCVTRONE  = C2d(Storage(D2x(CVTSMEXT+44),4))  /* end of R/O nucleus   */\nCVTRONE  = D2x(CVTRONE)                      /* display in hex       */\nRONUCSZ  = X2d(CVTRONE)  - X2d(CVTRONS)  + 1 /* size of R/O nucleus  */\nRONUCSZ  = Format(RONUCSZ/1024,,0)           /* convert to Kbytes    */\nRONUCSZB = X2d('FFFFFF') - X2d(CVTRONS) + 1  /* size of R/O nuc <16M */\nRONUCSZB = Format(RONUCSZB/1024,,0)          /* convert to Kbytes    */\nRONUCSZA = X2d(CVTRONE) - X2d('1000000') + 1 /* size of R/O nuc >16M */\nRONUCSZA = Format(RONUCSZA/1024,,0)          /* convert to Kbytes    */\nCVTERWNS = C2d(Storage(D2x(CVTSMEXT+48),4))  /* start of E-R/W nuc   */\nCVTERWNS = D2x(CVTERWNS)                     /* display in hex       */\nCVTERWNE = C2d(Storage(D2x(CVTSMEXT+52),4))  /* end of E-R/W nuc     */\nCVTERWNE = D2x(CVTERWNE)                     /* display in hex       */\nERWNUCSZ = X2d(CVTERWNE) - X2d(CVTERWNS) + 1 /* size of E-R/W nuc    */\nERWNUCSZ = ERWNUCSZ/1024                     /* convert to Kbytes    */\nGDAESQA  = C2d(Storage(D2x(CVTGDA + 152),4)) /* start of ESQA addr   */\nGDAESQAH = D2x(GDAESQA)                      /* display in hex       */\nESQAEND  = (GDAESQAS*1024) + GDAESQA - 1     /* end of ESQA          */\nESQAEND  = D2x(ESQAEND)                      /* display in hex       */\nCVTEPLPS = C2d(Storage(D2x(CVTSMEXT+56),4))  /* start of EPLPA addr  */\nCVTEPLPS = D2x(CVTEPLPS)                     /* display in hex       */\nCVTEPLPE = C2d(Storage(D2x(CVTSMEXT+60),4))  /* end of EPLPA addr    */\nCVTEPLPE = D2x(CVTEPLPE)                     /* display in hex       */\nEPLPASZ  = X2d(CVTEPLPE) - X2d(CVTEPLPS) + 1 /* size of EPLPA        */\nEPLPASZ  = EPLPASZ/1024                      /* convert to Kbytes    */\nCVTEFLPS = C2d(Storage(D2x(CVTSMEXT+64),4))  /* start of EFLPA addr  */\nCVTEFLPS = D2x(CVTEFLPS)                     /* display in hex       */\nIf CVTEFLPS <> 0 then do\n  CVTEFLPE = C2d(Storage(D2x(CVTSMEXT+68),4))  /* end of EFLPA addr  */\n  CVTEFLPE = D2x(CVTEFLPE)                     /* display in hex     */\n  EFLPASZ  = X2d(CVTEFLPE) - X2d(CVTEFLPS) + 1 /* size of EFLPA      */\n  EFLPASZ  = EFLPASZ/1024                      /* convert to Kbytes  */\nEnd\nElse do /* no EFLPA */\n  CVTEFLPS = 'N/A     '\n  CVTEFLPE = 'N/A     '\n  EFLPASZ  = 0\nEnd\nCVTEMLPS = C2d(Storage(D2x(CVTSMEXT+72),4))  /* start of EMLPA addr  */\nCVTEMLPS = D2x(CVTEMLPS)                     /* display in hex       */\nIf CVTEMLPS <> 0 then do\n  CVTEMLPE = C2d(Storage(D2x(CVTSMEXT+76),4))  /* end of EMLPA addr  */\n  CVTEMLPE = D2x(CVTEMLPE)                     /* display in hex     */\n  EMLPASZ  = X2d(CVTEMLPE) - X2d(CVTEMLPS) + 1 /* size of EMLPA      */\n  EMLPASZ  = EMLPASZ/1024                      /* convert to Kbytes  */\nEnd\nElse do /* no EMLPA */\n  CVTEMLPS = 'N/A     '\n  CVTEMLPE = 'N/A     '\n  EMLPASZ  = 0\nEnd\nGDAECSA  = C2d(Storage(D2x(CVTGDA + 124),4)) /* start of ECSA addr   */\nGDAECSAH = D2x(GDAECSA)                      /* display in hex       */\nECSAEND  = (GDAECSAS*1024) + GDAECSA - 1     /* end of ECSA          */\nECSAEND  = D2x(ECSAEND)                      /* display in hex       */\nGDAEPVT  = C2d(Storage(D2x(CVTGDA + 168),4)) /* start of EPVT addr   */\nGDAEPVTH = D2x(GDAEPVT)                      /* display in hex       */\nEPVTEND  = (GDAEPVTS*1024*1024) + GDAEPVT - 1 /* end of EPVT         */\nEPVTEND  = D2x(EPVTEND)                      /* display in hex       */\nIf VMAPOPT <> 'NODISP' then do         /* no display of vmap desired */\nQueue ' '\nQueue 'Virtual Storage Map:'\nQueue '          '\nIf VMAP = 'HIGHFIRST' then do\nIf Bitand(CVTOSLV2,'01'x) = '01'x then ,     /* OS/390 R10 and above */\n Queue '     Storage Area     Start      End           Size' ,\n       '     Used     Conv      HWM'\nElse ,\n Queue '     Storage Area     Start      End           Size' ,\n       '     Used     Conv'\nQueue '          '\nQueue '     Ext. Private    '     Right(GDAEPVTH,8,'0') ' ' ,\n   Right(EPVTEND,8,'0')           Right(GDAEPVTS,8,' ')'M'\nIf Bitand(CVTOSLV2,'01'x) = '01'x then ,     /* OS/390 R10 and above */\nQueue '         Ext. CSA    '     Right(GDAECSAH,8,'0') ' ' ,\n   Right(ECSAEND,8,'0')           Right(GDAECSAS,8,' ')'K' ,\n   Right(GDA_ECSA_ALLOC,8,' ')'K         ' ,\n   Right(GDAECSAHWM,7,' ')'K'\nElse ,\nQueue '         Ext. CSA    '     Right(GDAECSAH,8,'0') ' ' ,\n   Right(ECSAEND,8,'0')           Right(GDAECSAS,8,' ')'K' ,\n   Right(GDA_ECSA_ALLOC,8,' ')'K'\nQueue '        Ext. MLPA    '     Right(CVTEMLPS,8,'0') ' ' ,\n   Right(CVTEMLPE,8,'0')          Right(EMLPASZ,8,' ')'K'\nQueue '        Ext. FLPA    '     Right(CVTEFLPS,8,'0') ' ' ,\n   Right(CVTEFLPE,8,'0')          Right(EFLPASZ,8,' ')'K'\nQueue '        Ext. PLPA    '     Right(CVTEPLPS,8,'0') ' ' ,\n   Right(CVTEPLPE,8,'0')          Right(EPLPASZ,8,' ')'K'\nIf Bitand(CVTOSLV2,'01'x) = '01'x then ,     /* OS/390 R10 and above */\nQueue '         Ext. SQA    '     Right(GDAESQAH,8,'0') ' ' ,\n   Right(ESQAEND,8,'0')           Right(GDAESQAS,8,' ')'K' ,\n   Right(GDA_ESQA_ALLOC,8,' ')'K' Right(GDA_ECSA_CONV,7,' ')'K',\n   Right(GDAESQAHWM,7,' ')'K'\nElse ,\nQueue '         Ext. SQA    '     Right(GDAESQAH,8,'0') ' ' ,\n   Right(ESQAEND,8,'0')           Right(GDAESQAS,8,' ')'K' ,\n   Right(GDA_ESQA_ALLOC,8,' ')'K' Right(GDA_ECSA_CONV,7,' ')'K'\nQueue ' Ext. R/W Nucleus    '     Right(CVTERWNS,8,'0') ' ' ,\n   Right(CVTERWNE,8,'0')          Right(ERWNUCSZ,8,' ')'K'\nQueue ' Ext. R/O Nucleus    '     Right('1000000',8,'0') ' ' ,\n   Right(CVTRONE,8,'0')           Right(RONUCSZA,8,' ')'K' ,\n   '(Total' RONUCSZ'K)'\nQueue '             16M line -----------------------------'\nQueue '      R/O Nucleus    '     Right(CVTRONS,8,'0') ' ' ,\n   Right('FFFFFF',8,'0')          Right(RONUCSZB,8,' ')'K',\n   '(Spans 16M line)'\nQueue '      R/W Nucleus    '     Right(CVTRWNS,8,'0') ' ' ,\n   Right(CVTRWNE,8,'0')           Right(RWNUCSZ,8,' ')'K'\nIf Bitand(CVTOSLV2,'01'x) = '01'x then ,     /* OS/390 R10 and above */\nQueue '              SQA    '     Right(GDASQAH,8,'0') ' ' ,\n   Right(SQAEND,8,'0')            Right(GDASQASZ,8,' ')'K' ,\n   Right(GDA_SQA_ALLOC,8,' ')'K'  Right(GDA_CSA_CONV,7,' ')'K' ,\n   Right(GDASQAHWM,7,' ')'K'\nElse ,\nQueue '              SQA    '     Right(GDASQAH,8,'0') ' ' ,\n   Right(SQAEND,8,'0')            Right(GDASQASZ,8,' ')'K' ,\n   Right(GDA_SQA_ALLOC,8,' ')'K'  Right(GDA_CSA_CONV,7,' ')'K'\nQueue '             PLPA    '     Right(CVTPLPAS,8,'0') ' ' ,\n   Right(CVTPLPAE,8,'0')          Right(PLPASZ,8,' ')'K'\nQueue '             FLPA    '     Right(CVTFLPAS,8,'0') ' ' ,\n   Right(CVTFLPAE,8,'0')          Right(FLPASZ,8,' ')'K'\nQueue '             MLPA    '     Right(CVTMLPAS,8,'0') ' ' ,\n   Right(CVTMLPAE,8,'0')          Right(MLPASZ,8,' ')'K'\nIf Bitand(CVTOSLV2,'01'x) = '01'x then ,     /* OS/390 R10 and above */\nQueue '              CSA    '     Right(GDACSAH,8,'0') ' ' ,\n   Right(CSAEND,8,'0')            Right(GDACSASZ,8,' ')'K' ,\n   Right(GDA_CSA_ALLOC,8,' ')'K         ' ,\n   Right(GDACSAHWM,7,' ')'K'\nElse ,\nQueue '              CSA    '     Right(GDACSAH,8,'0') ' ' ,\n   Right(CSAEND,8,'0')            Right(GDACSASZ,8,' ')'K' ,\n   Right(GDA_CSA_ALLOC,8,' ')'K'\nQueue '      Private V=V    '     Right(VVSTRT,8,'0') ' ' ,\n   Right(VVEND,8,'0')             Right(LDASIZEA,8,' ')'K'\nQueue '      Private V=R    '     Right(VRSTRT,8,'0') ' ' ,\n   Right(VREND,8,'0')             Right(GDAVRSZ,8,' ')'K'\nQueue '           System    '     Right(LDASTRTS,8,'0') ' ' ,\n   Right(SYSEND,8,'0')            Right(LDASIZS,8,' ')'K'\nIf zARCH = 2 then ,\n  Queue '              PSA     00000000   00001FFF        8K'\nElse ,\n  Queue '              PSA     00000000   00000FFF        4K'\nEnd  /* if VMAP = 'HIGHFIRST'  */\nElse do  /* VMAP <> 'HIGHFIRST'  */\nIf Bitand(CVTOSLV2,'01'x) = '01'x then ,     /* OS/390 R10 and above */\n Queue '     Storage Area     Start      End           Size' ,\n       '     Used     Conv      HWM'\nElse ,\n Queue '     Storage Area     Start      End           Size' ,\n       '     Used     Conv'\nQueue '          '\nIf zARCH = 2 then ,\n  Queue '              PSA     00000000   00001FFF        8K'\nElse ,\n  Queue '              PSA     00000000   00000FFF        4K'\nQueue '           System    '     Right(LDASTRTS,8,'0') ' ' ,\n   Right(SYSEND,8,'0')            Right(LDASIZS,8,' ')'K'\nQueue '      Private V=R    '     Right(VRSTRT,8,'0') ' ' ,\n   Right(VREND,8,'0')             Right(GDAVRSZ,8,' ')'K'\nQueue '      Private V=V    '     Right(VVSTRT,8,'0') ' ' ,\n   Right(VVEND,8,'0')             Right(LDASIZEA,8,' ')'K'\nIf Bitand(CVTOSLV2,'01'x) = '01'x then ,     /* OS/390 R10 and above */\nQueue '              CSA    '     Right(GDACSAH,8,'0') ' ' ,\n   Right(CSAEND,8,'0')            Right(GDACSASZ,8,' ')'K' ,\n   Right(GDA_CSA_ALLOC,8,' ')'K         ' ,\n   Right(GDACSAHWM,7,' ')'K'\nElse ,\nQueue '              CSA    '     Right(GDACSAH,8,'0') ' ' ,\n   Right(CSAEND,8,'0')            Right(GDACSASZ,8,' ')'K' ,\n   Right(GDA_CSA_ALLOC,8,' ')'K'\nQueue '             MLPA    '     Right(CVTMLPAS,8,'0') ' ' ,\n   Right(CVTMLPAE,8,'0')          Right(MLPASZ,8,' ')'K'\nQueue '             FLPA    '     Right(CVTFLPAS,8,'0') ' ' ,\n   Right(CVTFLPAE,8,'0')          Right(FLPASZ,8,' ')'K'\nQueue '             PLPA    '     Right(CVTPLPAS,8,'0') ' ' ,\n   Right(CVTPLPAE,8,'0')          Right(PLPASZ,8,' ')'K'\nIf Bitand(CVTOSLV2,'01'x) = '01'x then ,     /* OS/390 R10 and above */\nQueue '              SQA    '     Right(GDASQAH,8,'0') ' ' ,\n   Right(SQAEND,8,'0')            Right(GDASQASZ,8,' ')'K' ,\n   Right(GDA_SQA_ALLOC,8,' ')'K'  Right(GDA_CSA_CONV,7,' ')'K' ,\n   Right(GDASQAHWM,7,' ')'K'\nElse ,\nQueue '              SQA    '     Right(GDASQAH,8,'0') ' ' ,\n   Right(SQAEND,8,'0')            Right(GDASQASZ,8,' ')'K' ,\n   Right(GDA_SQA_ALLOC,8,' ')'K'  Right(GDA_CSA_CONV,7,' ')'K'\nQueue '      R/W Nucleus    '     Right(CVTRWNS,8,'0') ' ' ,\n   Right(CVTRWNE,8,'0')           Right(RWNUCSZ,8,' ')'K'\nQueue '      R/O Nucleus    '     Right(CVTRONS,8,'0') ' ' ,\n   Right('FFFFFF',8,'0')          Right(RONUCSZB,8,' ')'K',\n   '(Spans 16M line)'\nQueue '             16M line -----------------------------'\nQueue ' Ext. R/O Nucleus    '     Right('1000000',8,'0') ' ' ,\n   Right(CVTRONE,8,'0')           Right(RONUCSZA,8,' ')'K' ,\n   '(Total' RONUCSZ'K)'\nQueue ' Ext. R/W Nucleus    '     Right(CVTERWNS,8,'0') ' ' ,\n   Right(CVTERWNE,8,'0')          Right(ERWNUCSZ,8,' ')'K'\nIf Bitand(CVTOSLV2,'01'x) = '01'x then ,     /* OS/390 R10 and above */\nQueue '         Ext. SQA    '     Right(GDAESQAH,8,'0') ' ' ,\n   Right(ESQAEND,8,'0')           Right(GDAESQAS,8,' ')'K' ,\n   Right(GDA_ESQA_ALLOC,8,' ')'K' Right(GDA_ECSA_CONV,7,' ')'K',\n   Right(GDAESQAHWM,7,' ')'K'\nElse ,\nQueue '         Ext. SQA    '     Right(GDAESQAH,8,'0') ' ' ,\n   Right(ESQAEND,8,'0')           Right(GDAESQAS,8,' ')'K' ,\n   Right(GDA_ESQA_ALLOC,8,' ')'K' Right(GDA_ECSA_CONV,7,' ')'K'\nQueue '        Ext. PLPA    '     Right(CVTEPLPS,8,'0') ' ' ,\n   Right(CVTEPLPE,8,'0')          Right(EPLPASZ,8,' ')'K'\nQueue '        Ext. FLPA    '     Right(CVTEFLPS,8,'0') ' ' ,\n   Right(CVTEFLPE,8,'0')          Right(EFLPASZ,8,' ')'K'\nQueue '        Ext. MLPA    '     Right(CVTEMLPS,8,'0') ' ' ,\n   Right(CVTEMLPE,8,'0')          Right(EMLPASZ,8,' ')'K'\nIf Bitand(CVTOSLV2,'01'x) = '01'x then ,     /* OS/390 R10 and above */\nQueue '         Ext. CSA    '     Right(GDAECSAH,8,'0') ' ' ,\n   Right(ECSAEND,8,'0')           Right(GDAECSAS,8,' ')'K' ,\n   Right(GDA_ECSA_ALLOC,8,' ')'K         ' ,\n   Right(GDAECSAHWM,7,' ')'K'\nElse ,\nQueue '         Ext. CSA    '     Right(GDAECSAH,8,'0') ' ' ,\n   Right(ECSAEND,8,'0')           Right(GDAECSAS,8,' ')'K' ,\n   Right(GDA_ECSA_ALLOC,8,' ')'K'\nQueue '     Ext. Private    '     Right(GDAEPVTH,8,'0') ' ' ,\n   Right(EPVTEND,8,'0')           Right(GDAEPVTS,8,' ')'M'\nEnd  /* else do (VMAP <> 'HIGHFIRST')  */\n\nIf bitand(CVTOSLV3,'02'x) = '02'x then do   /* z/OS 1.5 and above?   */\n                            /* Yes, get HVSHARE info from the RCE    */\n  RCELVSHRSTRT   = C2d(Storage(D2x(RCE + 544),8))  /* low virt addr  */\n                                                   /* for 64-bit shr */\n  RCELVSHRSTRT_D = C2x(Storage(D2x(RCE + 544),8))  /* make readable  */\n  VSHRSTRT_D     = Substr(RCELVSHRSTRT_D,1,8) ,    /*  address range */\n                   Substr(RCELVSHRSTRT_D,9,8)      /*   display      */\n  RCELVHPRSTRT   = C2d(Storage(D2x(RCE + 552),8))  /* low virt addr  */\n                                                   /* for 64-bit prv */\n  RCELVHPRSTRT_D = C2d(Storage(D2x(RCE + 552),8)) -1 /*make readable */\n  RCELVHPRSTRT_D = Right(D2x(RCELVHPRSTRT_D),16,'0') /* address      */\n  VHPRSTRT_D     = Substr(RCELVHPRSTRT_D,1,8) ,    /*   range        */\n                   Substr(RCELVHPRSTRT_D,9,8)      /*   display      */\n  TOTAL_VHSHR    = RCELVHPRSTRT - RCELVSHRSTRT     /* total shared   */\n  TOTAL_VHSHR    = TOTAL_VHSHR/1024/1024           /* change to MB   */\n  TOTAL_VHSHR    = FORMAT_MEMSIZE(TOTAL_VHSHR)     /* format size    */\n\n  RCELVSHRSTRT   = RCELVSHRSTRT/1024/1024          /* change to MB   */\n  RCELVSHRSTRT   = FORMAT_MEMSIZE(RCELVSHRSTRT)    /* format size    */\n\n  RCELVHPRSTRT   = RCELVHPRSTRT/1024/1024          /* change to MB   */\n  RCELVHPRSTRT   = FORMAT_MEMSIZE(RCELVHPRSTRT)    /* format size    */\n\n  RCELVSHRPAGES  = C2d(Storage(D2x(RCE + 584),8))  /* shr pages      */\n  RCELVSHRPAGES  = (RCELVSHRPAGES*4)/1024          /* change to MB   */\n  RCELVSHRPAGES  = FORMAT_MEMSIZE(RCELVSHRPAGES)   /* format size    */\n\n  RCELVSHRGBYTES = C2d(Storage(D2x(RCE + 592),8))  /* shr bytes HWM  */\n  RCELVSHRGBYTES = RCELVSHRGBYTES/1024/1024        /* change to MB   */\n  RCELVSHRGBYTES = FORMAT_MEMSIZE(RCELVSHRGBYTES)  /* format size    */\n\n  Queue '   '\n  Queue '  64-Bit Shared Virtual Storage (HVSHARE):'\n  Queue '   '\n  Queue '    Shared storage total:' TOTAL_VHSHR\n  Queue '    Shared storage range:' RCELVSHRSTRT'-'RCELVHPRSTRT ,\n        '('VSHRSTRT_D' - 'VHPRSTRT_D')'\n  Queue '    Shared storage allocated:' RCELVSHRPAGES\n  Queue '    Shared storage allocated HWM:' RCELVSHRGBYTES\n\nEnd /* If bitand(CVTOSLV3,'02'x) = '02'x  */\n\nIf bitand(CVTOSLV5,'08'x) = '08'x then do   /* z/OS 1.10 and above   */\n                            /* Yes, get HVCOMMON info from the RCE   */\n  RCEHVCommonStrt = C2d(Storage(D2x(RCE + 872),8)) /*low virt addr */\n                                                   /*for 64-bit cmn*/\n  CommonStrt_D   = C2x(Storage(D2x(RCE + 872),8))  /*make readable */\n  CommonStrt_D   = Substr(CommonStrt_D,1,8) ,      /* address range*/\n                   Substr(CommonStrt_D,9,8)        /*  display     */\n\n  RCEHVCommonEnd = C2d(Storage(D2x(RCE + 880),8))  /*high virt addr*/\n                                                   /*for 64-bit cmn*/\n  RCEHVCommonEnd = RCEHVCommonEnd + 1              /* Add 1 to addr*/\n  CommonEnd_D    = C2x(Storage(D2x(RCE + 880),8))  /*make readable */\n  CommonEnd_D    = Substr(CommonEnd_D,1,8) ,       /* address range*/\n                   Substr(CommonEnd_D,9,8)         /*  display     */\n\n  TOTAL_VHCOMN   = RCEHVCommonEnd-RCEHVCommonStrt  /* total common */\n  TOTAL_VHCOMN   = TOTAL_VHCOMN/1024/1024          /* change to MB */\n  TOTAL_VHCOMN   = FORMAT_MEMSIZE(TOTAL_VHCOMN)    /* format size  */\n\n  RCEHVCommonStrt = RCEHVCommonStrt/1024/1024      /* chg to MB    */\n  RCEHVCommonStrt = FORMAT_MEMSIZE(RCEHVCommonStrt) /* format size */\n\n  RCEHVCommonEnd = RCEHVCommonEnd/1024/1024        /* chg to MB    */\n  RCEHVCommonEnd = FORMAT_MEMSIZE(RCEHVCommonEnd)  /* format  size */\n\n  RCEHVCommonPAGES = C2d(Storage(D2x(RCE + 888),8)) /* comn pages  */\n  RCEHVCommonPAGES = (RCEHVCommonPAGES*4)/1024      /* chg to MB   */\n  RCEHVCommonPAGES = FORMAT_MEMSIZE(RCEHVCommonPAGES) /*format size*/\n\n  RCEHVCommonHWMBytes = C2d(Storage(D2x(RCE + 896),8)) /* comn HWM */\n  RCEHVCommonHWMBytes = RCEHVCommonHWMBytes/1024/1024  /*chg to MB */\n  RCEHVCommonHWMBytes = FORMAT_MEMSIZE(RCEHVCommonHWMBytes) /* fmt */\n\n  Queue '   '\n  Queue '  64-Bit Common Virtual Storage (HVCOMMON):'\n  Queue '   '\n  Queue '    Common storage total:' TOTAL_VHCOMN\n  Queue '    Common storage range:' RCEHVCommonStrt'-'RCEHVCommonEnd ,\n        '('CommonStrt_D' - 'CommonEnd_D')'\n  Queue '    Common storage allocated:' RCEHVCommonPAGES\n  Queue '    Common storage allocated HWM:' RCEHVCommonHWMBytes\nEnd /* If bitand(CVTOSLV5,'08'x) = '08'x  */\nIf Bitand(CVTOSLV5,'10'x) = '10'x &     ,   /* z/OS 1.9 and above &  */\n   Bitand(CVTFLAG2,'01'x) = '01'x then do   /*  CVTEDAT on (z10 >)?  */\n  LARGEMEM = 1                              /* set LARGEMEM avail flg*/\n  RCEReconLFASize  = C2d(Storage(D2x(RCE + 760),8)) /* recon lfarea  */\n  RCENonReconLFASize = C2d(Storage(D2x(RCE + 768),8)) /*  LFAREA     */\n /* Comment out or delete the next 2 lines of code if you want the   */\n /* large memory displays even if you specified or defaulted to      */\n /* LFAREA=0M (z/OS 1.9 & above) and have the hardware support.      */\n  If RCEReconLFASize = 0 & RCENonReconLFASize = 0 then ,  /* both 0? */\n   LARGEMEM = 0\n  If Bitand(CVTOSLV6,'80'x) = '80'x then do /* z/OS 2.1 and above    */\n    PL = 1                                  /* pageable1m + 2.1 & >  */\n    /*****************/\n    /* 2G frame code */\n    /*****************/\n    RCE2GMemoryObjects          = ,\n     C2d(Storage(D2x(RCE + 1256),8))    /* Number of 2G objects      */\n    RCE2GNonReconLFASize        = ,\n     C2d(Storage(D2x(RCE + 1272),8))    /* 2G frame area in 2G units */\n    RCE2GNonReconLFAUsed        = ,\n     C2d(Storage(D2x(RCE + 1280),8))    /* used 2G frames            */\n    RCE2GHWM                    = ,\n     C2d(Storage(D2x(RCE + 1288),4))    /* 2G used frames HWM        */\n    If RCE2GNonReconLFASize <> 0 then LARGEMEM = 1  /* lfarea used   */\n  End\n    Else PL = 0                             /* no pageable1m         */\nEnd /* If Bitand(CVTOSLV5,'10'x) */\n   Else LARGEMEM = 0                        /* < z/OS 1.9/no hw supt */\nIf LARGEMEM = 1 then do                      /* z/OS 1.10 & above  */\n  RCELargeMemoryObjects = ,\n   C2d(Storage(D2x(RCE + 744),8))             /*tot large mem objs */\n  RCELargePagesBackedinReal = ,\n   C2d(Storage(D2x(RCE + 752),8))             /* tot lrg obj pages */\n  RCELFAvailGroups          = ,\n   C2d(Storage(D2x(RCE + 796),4))             /* avial lrg frames  */\n  RCEReconLFAUsed             = ,\n   C2d(Storage(D2x(RCE + 776),8))    /* # recon 1M frames alloc    */\n  RCENonReconLFAUsed          = ,\n   C2d(Storage(D2x(RCE + 784),8))    /* # nonrecon 1M frames alloc */\n\n  LFASize = RCEReconLFASize + RCENonReconLFASize     /* LFAREA size*/\n  LFA_Used    = RCEReconLFAUsed + RCENonReconLFAUsed /* used LFAREA*/\n  LFA_Alloc1M = RCELargePagesBackedinReal            /* 1M alloc   */\n  LFA_Alloc4K = LFA_Used - LFA_Alloc1M               /* 4K alloc   */\n\n  If PL = 1 then do            /* z/OS 2.1 / pageable1m support    */\n    RCELargeUsed4K              = ,\n     C2d(Storage(D2x(RCE + 1032),4))      /* 4K used for 1M req    */\n    LFA_Alloc4K = RCELargeUsed4K     /* chg var name for old code  */\n    RceLargeAllocatedPL         = ,\n     C2d(Storage(D2x(RCE + 1244),4))      /* # used pageable1m     */\n    RceLargeUsedPLHWM           = ,\n     C2d(Storage(D2x(RCE + 1252),4))      /* pageable1m HWM        */\n  End\n\n  LFASize     = FORMAT_MEMSIZE(LFASize)          /* format size    */\n  LFA_Avail   = FORMAT_MEMSIZE(RCELFAvailGroups) /* format size    */\n  LFA_Alloc1M = FORMAT_MEMSIZE(LFA_Alloc1M)      /* format size    */\n  LFA_Alloc4K = FORMAT_MEMSIZE(LFA_Alloc4K)      /* format size    */\n\n  If PL = 1 then do            /* z/OS 2.1 + pageable1m support    */\n    RceLargeAllocatedPL = FORMAT_MEMSIZE(RceLargeAllocatedPL)\n    RceLargeUsedPLHWM   = FORMAT_MEMSIZE(RceLargeUsedPLHWM)\n    /*****************/\n    /* 2G frame code */\n    /*****************/\n    LFA2G_Size  = FORMAT_MEMSIZE(RCE2GNonReconLFASize*2048)\n    LFA2G_Used  = FORMAT_MEMSIZE(RCE2GNonReconLFAUsed*2048)\n    LFA2G_avail = ((RCE2GNonReconLFASize-RCE2GNonReconLFAUsed)*2048)\n    LFA2G_avail = FORMAT_MEMSIZE(LFA2G_avail)\n    LFA2G_Max   = RCE2GHWM*2048\n    LFA2G_Max   = FORMAT_MEMSIZE(LFA2G_Max)\n  End\n\n  If Bitand(CVTOSLV5,'04'x) = '04'x then do /* z/OS 1.12 and above */\n    RceLargeUsed1MHWM           = ,\n     C2d(Storage(D2x(RCE + 804),4)) /*large pg HWM alloc behalf 1M */\n    RceLargeUsed4KHWM           = ,\n     C2d(Storage(D2x(RCE + 808),4)) /*large pg HWM alloc behalf 4K */\n    LFA_Max1M = FORMAT_MEMSIZE(RceLargeUsed1MHWM)  /* format size  */\n    LFA_Max4K = FORMAT_MEMSIZE(RceLargeUsed4KHWM)  /* format size  */\n  End\n\n  Queue '   '\n  Queue '  64-Bit Large Memory Virtual Storage (LFAREA):'\n  Queue '   '\n  If PL = 1 then do            /* z/OS 2.1 / pageable1m support    */\n    Queue '    Large memory area (LFAREA)    :' LFASize ',' LFA2G_Size\n    Queue '    Large memory storage available:' LFA_Avail ',' ,\n               LFA2G_avail\n  End\n  Else do\n    Queue '    Large memory area (LFAREA)    :' LFASize\n    Queue '    Large memory storage available:' LFA_Avail\n  End\n  Queue '    Large memory storage allocated (1M):' LFA_Alloc1M\n  Queue '    Large memory storage allocated (4K):' LFA_Alloc4K\n  If Bitand(CVTOSLV5,'04'x) = '04'x then do /* z/OS 1.12 and above */\n    Queue '    Large memory storage allocated HWM (1M):' LFA_Max1M\n    Queue '    Large memory storage allocated HWM (4K):' LFA_Max4K\n  End\n  If PL = 1 then do            /* z/OS 2.1 / pageable1m support    */\n    Queue '    Large memory storage allocated (PAGEABLE1M):' ,\n     RceLargeAllocatedPL\n    Queue '    Large memory storage allocated HWM (PAGEABLE1M):' ,\n     RceLargeUsedPLHWM\n    Queue '    Large memory storage allocated (2G):' LFA2G_Used ,\n          '/' RCE2GNonReconLFAUsed 'pages'\n    Queue '    Large memory storage allocated HWM (2G):' LFA2G_Max ,\n          '/' RCE2GHWM 'pages'\n  End\n  Queue '    Large memory objects allocated:' RCELargeMemoryObjects\n  If PL = 1 then ,             /* z/OS 2.1 / pageable1m support    */\n    Queue '    Large memory objects allocated (2G):' RCE2GMemoryObjects\nEnd\nEnd  /* If VMAPOPT <> 'NODISP' */\nReturn\n\nPAGE:                /* Page Data Sets information sub-routine       */\nQueue ' '\nQueue 'Page Data Set Usage:'\nQueue '  Type     Full     Slots  Dev   Volser  Data Set Name'\nASMPART  = C2d(Storage(D2x(ASMVT + 8),4))  /* Pnt to Pag Act Ref Tbl */\nPARTSIZE = C2d(Storage(D2x(ASMPART+4),4))  /* Tot number of entries  */\nPARTDSNL = C2d(Storage(D2x(ASMPART+24),4)) /* Point to 1st pg dsn    */\nPARTENTS = ASMPART+80                      /* Point to 1st parte     */\nDo I = 1 to PARTSIZE\n  If I > 1 then do\n    PARTENTS = PARTENTS + 96\n    PARTDSNL = PARTDSNL + 44\n  End\n  CHKINUSE = Storage(D2x(PARTENTS+9),1)    /* in use flag            */\n  If Bitand(CHKINUSE,'80'x) = '80'x then iterate /* not in use       */\n  PGDSN    = Storage(D2x(PARTDSNL),44)     /* page data set name     */\n  PGDSN    = Strip(PGDSN,'T')              /* remove trailing blanks */\n  PARETYPE = Storage(D2x(PARTENTS+8),1)    /* type flag              */\n  Select\n    When Bitand(PARETYPE,'80'x) = '80'x then PGTYPE = ' PLPA    '\n    When Bitand(PARETYPE,'40'x) = '40'x then PGTYPE = ' COMMON  '\n    When Bitand(PARETYPE,'20'x) = '20'x then PGTYPE = ' DUPLEX  '\n    When Bitand(PARETYPE,'10'x) = '10'x then PGTYPE = ' LOCAL   '\n    Otherwise PGTYPE = '??????'\n  End  /* Select */\n  If PGTYPE = ' LOCAL   ' then do\n    PAREFLG1  = Storage(D2x(PARTENTS+9),1)    /* PARTE flags         */\n    If Bitand(PAREFLG1,'10'x) = '10'x then PGTYPE = ' LOCAL NV'\n  End\n  PAREUCBP = C2d(Storage(D2x(PARTENTS+44),4)) /* point to UCB        */\n  PGUCB    = C2x(Storage(D2x(PAREUCBP+4),2))  /* UCB address         */\n  PGVOL    = Storage(D2x(PAREUCBP+28),6)      /* UCB volser          */\n  PARESZSL = C2d(Storage(D2x(PARTENTS+16),4)) /* total slots         */\n  PARESZSL = Right(PARESZSL,9,' ')            /* ensure 9 digits     */\n  PARESLTA = C2d(Storage(D2x(PARTENTS+20),4)) /* avail. slots        */\n  PGFULL   = ((PARESZSL-PARESLTA) / PARESZSL) * 100 /* percent full  */\n  PGFULL   = Format(PGFULL,3,2)               /* force 2 decimals    */\n  PGFULL   = Left(PGFULL,3)                   /* keep intiger only   */\n  Queue  ' 'PGTYPE' 'PGFULL'% 'PARESZSL'  'PGUCB' ' ,\n         PGVOL'  'PGDSN\nEnd  /* do I=1 to partsize */\n/*********************************************************************/\n/* SCM - Storage Class Memory                                        */\n/* ASMVX - SYS1.MODGEN(ILRASMVX) pointed to in SYS1.MODGEN(ILRASMVT) */\n/*********************************************************************/\n /*If Bitand(CVTOSLV5,'01'x) = '01'x then do */ /* z/OS 1.13 and > */\nIf Bitand(CVTOSLV6,'80'x) = '80'x then do    /* z/OS 2.1  and above  */\n  SCMSTATUS = 'NOT-USED'                     /* set dflt to not used */\n  ASMVX = C2d(Storage(D2x(ASMVT + 1236),4))  /* point to ASM tbl ext */\n  SCMBLKSAVAIL = C2d(Storage(D2x(ASMVX + 8),8))   /* SCM blks avail  */\n  SCMNVBC      = C2d(Storage(D2x(ASMVX + 16),8))  /* SCM blks used   */\n  SCMERRS      = C2d(Storage(D2x(ASMVX + 24),8))  /* bad SCM blks    */\n  If (SCMBLKSAVAIL > 0) then do              /* SCM is used          */\n    SCMSTATUS = 'IN-USE  '                   /* status is IN-USE     */\n    SCMPCTUSED = Trunc(SCMNVBC*100/SCMBLKSAVAIL)  /* percent used    */\n    SCMPCTUSED = Format(SCMPCTUSED,3,2)      /* format for display   */\n    SCMPCTUSED = Left(SCMPCTUSED,3)          /* format for display   */\n    Call FORMAT_COMMAS SCMBLKSAVAIL          /* format with commas   */\n    SCMBLKSAVAIL = FORMATTED_WHOLENUM        /* save number          */\n    Call FORMAT_COMMAS SCMNVBC               /* format with commas   */\n    SCMNVBC      = FORMATTED_WHOLENUM        /* save number          */\n    Call FORMAT_COMMAS SCMERRS               /* format with commas   */\n    SCMERRS      = FORMATTED_WHOLENUM        /* save number          */\n    SCMBLKSAVAIL = Right(SCMBLKSAVAIL,16)    /* format for display   */\n    SCMNVBC      = Right(SCMNVBC,16)         /* format for display   */\n    SCMERRS      = Right(SCMERRS,16)         /* format for display   */\n  End\n  Queue ' '\n  Queue 'Storage Class Memory:'\n  Queue '  STATUS      FULL               SIZE             USED' ,\n        '        IN-ERROR'\n  If SCMSTATUS = 'NOT-USED' then Queue ' ' SCMSTATUS\n  Else do\n    Queue ' ' SCMSTATUS '  ' SCMPCTUSED || '%  '  ,\n          SCMBLKSAVAIL SCMNVBC SCMERRS\n  End\nEnd\nReturn\n\nSMF:                 /* SMF Data Set information sub-routine         */\nQueue ' '\nQueue 'SMF Data Set Usage:'\nQueue '  Name                      Volser   Size(Blks)  %Full  Status'\nSMCAMISC = Storage(D2x(SMCA + 1),1)          /* misc. indicators     */\nIf bitand(SMCAMISC,'80'x) <> '80'x then do   /* smf active ??        */\n  Queue '  *** SMF recording not being used ***'\n  Return\nEnd\nSMCAFRDS = C2d(Storage(D2x(SMCA + 244),4))   /* point to first RDS   */\nSMCALRDS = C2d(Storage(D2x(SMCA + 248),4))   /* point to last RDS    */\nSMCASMCX = C2d(Storage(D2x(SMCA + 376),4))   /* point to SMCX        */\nSMCXLSBT = Storage(D2x(SMCASMCX + 88),1)     /* logstream bits       */\nIf Bitand(SMCXLSBT,'80'x) = '80'x then do    /* logstream recording? */\n  If SMCAFRDS = SMCALRDS then do\n    Queue '  ***       SMF LOGSTREAM recording is active       ***'\n    Queue '  *** LOGSTREAM information not available via REXX  ***'\n  Return\n  End\n  Else do\n    Queue '  ***       SMF LOGSTREAM recording is active       ***'\n    Queue '  *** LOGSTREAM information not available via REXX  ***'\n    Queue '  ***     SMF data sets listed below not in use     ***'\n  End\nEnd /* If Bitand(SMCXLSBT,'80'x) */\nIf SMCAFRDS = SMCALRDS then do\n  Queue '  ***    No SMF data sets available     ***'\n  Return\nEnd\nDo until SMCAFRDS = SMCALRDS    /* end loop when next rds ptr = last */\n  RDSNAME  =  Strip(Storage(D2x(SMCAFRDS + 16),44))  /* smf dsn      */\n  RDSVOLID = Storage(D2x(SMCAFRDS + 60),6)           /* smf volser   */\n  RDSCAPTY = C2d(Storage(D2x(SMCAFRDS + 76),4))      /* size in blks */\n  RDSNXTBL = C2d(Storage(D2x(SMCAFRDS + 80),4))      /* next avl blk */\n  /* RDSPCT  = (RDSNXTBL / RDSCAPTY) * 100 */ /* not how mvs does it */\n  RDSPCT   = Trunc((RDSNXTBL / RDSCAPTY) * 100) /* same as mvs disp. */\n  RDSFLG1  = Storage(D2x(SMCAFRDS + 12),1)     /* staus flags        */\n  Select\n    When Bitand(RDSFLG1,'10'x) = '10'x then RDSSTAT = 'FREE REQUIRED'\n    When Bitand(RDSFLG1,'08'x) = '08'x then RDSSTAT = 'DUMP REQUIRED'\n    When Bitand(RDSFLG1,'04'x) = '04'x then RDSSTAT = 'ALTERNATE'\n    When Bitand(RDSFLG1,'02'x) = '02'x then RDSSTAT = 'CLOSE PENDING'\n    When Bitand(RDSFLG1,'01'x) = '01'x then RDSSTAT = 'OPEN REQUIRED'\n    When Bitand(RDSFLG1,'00'x) = '00'x then RDSSTAT = 'ACTIVE'\n    Otherwise RDSSTAT = '??????'\n  End  /* Select */\n  If (RDSSTAT = 'ACTIVE' | RDSSTAT = 'DUMP REQUIRED') , /* display   */\n    & RDSPCT = 0 then RDSPCT = 1    /* %full the same way mvs does   */\n  SMCAFRDS = C2d(Storage(D2x(SMCAFRDS + 4),4)) /* point to next RDS  */\n  If Length(RDSNAME) < 26 then do\n    Queue ' ' Left(RDSNAME,25,' ') RDSVOLID  Right(RDSCAPTY,11,' ') ,\n              ' 'Format(RDSPCT,5,0) ' ' RDSSTAT\n  End\n  Else do\n    Queue ' ' RDSNAME\n    Queue copies(' ',27) RDSVOLID  Right(RDSCAPTY,11,' ') ,\n              ' 'Format(RDSPCT,5,0) ' ' RDSSTAT\n  End\nEnd\nReturn\n\nSUB:                 /* Subsystem information sub-routine            */\nArg SUBOPT\nSSCVT    = C2d(Storage(D2x(JESCT+24),4))     /* point to SSCVT       */\nSSCVT2   = SSCVT           /* save address for second loop           */\nIf SUBOPT <> 'FINDJES' then do\n  Queue ' '\n  Queue 'Subsystem Communications Vector Table:'\n  Queue '  Name   Hex        SSCTADDR   SSCTSSVT' ,\n        '  SSCTSUSE   SSCTSUS2   Status'\nEnd /* if subopt */\nDo until SSCVT = 0\n  SSCTSNAM = Storage(D2x(SSCVT+8),4)         /* subsystem name       */\n  SSCTSSVT = C2d(Storage(D2x(SSCVT+16),4))   /* subsys vect tbl ptr  */\n  SSCTSUSE = C2d(Storage(D2x(SSCVT+20),4))   /* SSCTSUSE pointer     */\n  SSCTSUS2 = C2d(Storage(D2x(SSCVT+28),4))   /* SSCTSUS2 pointer     */\n  If SUBOPT = 'FINDJES' & SSCTSNAM = JESPJESN then do\n     JESSSVT  = SSCTSSVT   /* save SSVTSSVT for \"version\" section    */\n                           /* this points to JES3 Subsystem Vector   */\n                           /* Table, mapped by IATYSVT               */\n     JESSUSE  = SSCTSUSE   /* save SSCTSUSE for \"version\" section    */\n                           /* this points to version for JES2        */\n     JESSUS2  = SSCTSUS2   /* save SSCTSUS2 for \"version\" section    */\n                           /* this points to $HCCT for JES2          */\n     Leave  /* found JES info for version section, exit loop */\n  End /* if subopt */\n  SSCTSNAX = C2x(SSCTSNAM)    /* chg to EBCDIC for non-display chars */\n  Call XLATE_NONDISP SSCTSNAM /* translate non display chars         */\n  SSCTSNAM = RESULT           /* result from XLATE_NONDISP           */\n  If SSCTSSVT = 0 then SSCT_STAT = 'Inactive'\n    Else SSCT_STAT = 'Active'\n  If SUBOPT <> 'FINDJES' then do\n    Queue ' ' SSCTSNAM ' ' SSCTSNAX  ,\n          ' ' Right(D2x(SSCVT),8,0)    ' ' Right(D2x(SSCTSSVT),8,0) ,\n          ' ' Right(D2x(SSCTSUSE),8,0) ' ' Right(D2x(SSCTSUS2),8,0) ,\n          ' ' SSCT_STAT ' '\n  End /* if SUBOPT */\n /*SSCTSSID = C2d(Storage(D2x(SSCVT+13),1)) */ /* subsys identifier  */\n /*If bitand(SSCTSSID,'02'x) = '02'x then JESPJESN = 'JES2' */\n /*If bitand(SSCTSSID,'03'x) = '03'x then JESPJESN = 'JES3'*/\n  SSCVT    = C2d(Storage(D2x(SSCVT+4),4))    /* next sscvt or zero   */\nEnd /* do until sscvt = 0 */\nIf SUBOPT <> 'FINDJES' then do\n  Queue ' '\n  Queue 'Supported Subsystem Function Codes:'\n  Do until SSCVT2 = 0 /* 2nd loop for function codes                 */\n    SSCTSNAM = Storage(D2x(SSCVT2+8),4)        /* subsystem name     */\n    SSCTSSVT = C2d(Storage(D2x(SSCVT2+16),4)) /* subsys vect tbl ptr */\n    SSCTSNAX = C2x(SSCTSNAM)  /* chg to EBCDIC for non-display chars */\n    Call XLATE_NONDISP SSCTSNAM /* translate non display chars       */\n    SSCTSNAM = RESULT           /* result from XLATE_NONDISP         */\n    Queue ' ' SSCTSNAM '(X''' || SSCTSNAX || ''')'\n    If SSCTSSVT <> 0 then do\n      SSVTFCOD = SSCTSSVT + 4                  /* pt to funct. matrix*/\n      SSFUNCTB = Storage(D2X(SSVTFCOD),255)    /* function matrix    */\n      TOTFUNC = 0       /* counter for total functions per subsystem */\n      Drop FUNC.        /* init stem to null for saved functions     */\n      Do SUPFUNC = 1 TO 255\n        If Substr(SSFUNCTB,SUPFUNC,1) <> '00'x then do /* supported? */\n          TOTFUNC = TOTFUNC + 1 /* tot functions for this subsystem  */\n          FUNC.TOTFUNC = SUPFUNC  /* save function in stem           */\n        End\n      End /* do supfunc */\n      /***************************************************************/\n      /* The following code is used to list the supported function   */\n      /* codes by ranges. For example: 1-10,13,18-30,35,70,143-145   */\n      /***************************************************************/\n      If TOTFUNC >= 1 then do   /* begin loop to list function codes */\n        ALLCODES = ''                   /* init var to nulls         */\n        NEWRANGE = 'YES'                /* init newrange flag to YES */\n        FIRSTRNG = 'YES'                /* init firstrng flag to YES */\n        Do FCODES = 1 to TOTFUNC        /* loop though codes         */\n          JUNK = TOTFUNC + 1            /* prevent NOVALUE cond.     */\n          FUNC.JUNK = ''                /*  in func.chknext at end   */\n          CHKNEXT = FCODES + 1          /* stem var to chk next code */\n          If FUNC.FCODES + 1 = FUNC.CHKNEXT then do  /* next matches */\n            If NEWRANGE = 'YES' & FIRSTRNG = 'YES' then do /* first  */\n              ALLCODES =  ALLCODES || FUNC.FCODES || '-'   /* in new */\n              NEWRANGE = 'NO'                    /* range - seperate */\n              FIRSTRNG = 'NO'                    /* with a dash      */\n              Iterate                            /* get next code    */\n            End /* if newrange = 'yes' & firstrng = 'yes'            */\n            If NEWRANGE = 'YES' & FIRSTRNG = 'NO' then do /* next    */\n              ALLCODES =  ALLCODES || FUNC.FCODES  /* matches, but   */\n              NEWRANGE = 'NO'   /* is not the first, don't add dash  */\n              Iterate                            /* get next code    */\n            End /* if newrange = 'yes' & firstrng = 'no'             */\n            Else iterate  /* same range + not first - get next code  */\n          End /* func.fcodes + 1 */\n          If FCODES = TOTFUNC then , /* next doesn't match and this  */\n            ALLCODES =  ALLCODES || FUNC.FCODES  /* is the last code */\n          Else do /* next code doesn't match - seperate with comma   */\n            ALLCODES =  ALLCODES || FUNC.FCODES || ','\n            NEWRANGE = 'YES'         /* re-init newrange flag to YES */\n            FIRSTRNG = 'YES'         /* re-init firstrng flag to YES */\n          End\n        End /* do fcodes = 1 to totfunc */\n        /*************************************************************/\n        /* The code below splits up the ranges to multiple lines if  */\n        /* they won't all fit on a single line due to IPLINFO lrecl. */\n        /*************************************************************/\n        FUN_MAXL = 68      /* max length b4 need to split out codes  */\n        If Length(ALLCODES) <= FUN_MAXL then ,  /* fits on one line  */\n          Queue '    Codes:' ALLCODES\n        Else do                            /* need to split up       */\n          FUNSPLT = Pos(',',ALLCODES,FUN_MAXL-6)   /* split at comma */\n          ALLCODES_1 = Substr(ALLCODES,1,FUNSPLT)  /* 1st part       */\n          ALLCODES_2 = Strip(Substr(ALLCODES,FUNSPLT+1,FUN_MAXL))\n          Queue '    Codes:' ALLCODES_1\n          Queue '          ' ALLCODES_2\n        End /* else do */\n      End /* if totfunc >= 1 */\n    End\n    Else queue '    *Inactive*'\n    SSCVT2   = C2d(Storage(D2x(SSCVT2+4),4))   /* next sscvt or zero */\n  End /* do until sscvt2 = 0 */\nEnd /* if subopt <> 'findjes' */\nReturn\n\nASID:                /* ASVT Usage sub-routine                       */\nQueue ' '\nCVTASVT  = C2d(Storage(D2x(CVT+556),4))     /* point to ASVT         */\nASVTMAXU = C2d(Storage(D2x(CVTASVT+516),4)) /* max number of entries */\nASVTMAXI = C2d(Storage(D2x(CVTASVT+500),4)) /* MAXUSERS from ASVT    */\nASVTAAVT = C2d(Storage(D2x(CVTASVT+480),4)) /* free slots in ASVT    */\nASVTSTRT = C2d(Storage(D2x(CVTASVT+492),4)) /* RSVTSTRT from ASVT    */\nASVTAST  = C2d(Storage(D2x(CVTASVT+484),4)) /* free START/SASI       */\nASVTNONR = C2d(Storage(D2x(CVTASVT+496),4)) /* RSVNONR  from ASVT    */\nASVTANR  = C2d(Storage(D2x(CVTASVT+488),4)) /* free non-reusable     */\nQueue 'ASID Usage Summary from the ASVT:'\nQueue '  Maximum number of ASIDs:' Right(ASVTMAXU,5,' ')\nQueue '                          '\nQueue '    MAXUSER from IEASYSxx:' Right(ASVTMAXI,5,' ')\nQueue '             In use ASIDs:' Right(ASVTMAXI-ASVTAAVT,5,' ')\nQueue '          Available ASIDs:' Right(ASVTAAVT,5,' ')\nQueue '                          '\nQueue '    RSVSTRT from IEASYSxx:' Right(ASVTSTRT,5,' ')\nQueue '           RSVSTRT in use:' Right(ASVTSTRT-ASVTAST,5,' ')\nQueue '        RSVSTRT available:' Right(ASVTAST,5,' ')\nQueue '                          '\nQueue '    RSVNONR from IEASYSxx:' Right(ASVTNONR,5,' ')\nQueue '           RSVNONR in use:' Right(ASVTNONR-ASVTANR,5,' ')\nQueue '        RSVNONR available:' Right(ASVTANR,5,' ')\nReturn\n\nLPA:                 /* LPA List sub-routine                         */\nCVTSMEXT = C2d(Storage(D2x(CVT + 1196),4))   /* point to stg map ext.*/\nCVTEPLPS = C2d(Storage(D2x(CVTSMEXT+56),4))  /* start vaddr of ELPA  */\nNUMLPA   = C2d(Storage(D2x(CVTEPLPS+4),4))   /* # LPA libs in table  */\nLPAOFF   = 8                                 /* first ent in LPA tbl */\nQueue '     '\nQueue 'LPA Library List  ('NUMLPA' libraries):'\nQueue '  POSITION    DSNAME'\nDo I = 1 to NUMLPA\n  LEN   = C2d(Storage(D2x(CVTEPLPS+LPAOFF),1)) /* length of entry    */\n  LPDSN = Storage(D2x(CVTEPLPS+LPAOFF+1),LEN)  /* DSN of LPA library */\n  LPAOFF = LPAOFF + 44 + 1                     /* next entry in table*/\n  LPAPOS = Right(I,3)                        /* position in LPA list */\n  RELLPPOS = Right('(+'I-1')',6)        /* relative position in list */\n  Queue LPAPOS  RELLPPOS '  ' LPDSN\nEnd\nReturn\n\nLNKLST:              /* LNKLST sub-routine                           */\nIf Bitand(CVTOSLV1,'01'x) <> '01'x then do    /* below OS/390 R2     */\n  CVTLLTA  = C2d(Storage(D2x(CVT + 1244),4))  /* point to lnklst tbl */\n  NUMLNK   = C2d(Storage(D2x(CVTLLTA+4),4))   /* # LNK libs in table */\n  LLTAPFTB = CVTLLTA + 8 + (NUMLNK*45)        /* start of LLTAPFTB   */\n  LNKOFF   = 8                                /*first ent in LBK tbl */\n  LKAPFOFF = 0                                /*first ent in LLTAPFTB*/\n  Queue '     '\n  Queue 'LNKLST Library List  ('NUMLNK' Libraries):'\n  Queue '  POSITION    APF    DSNAME'\n  Do I = 1 to NUMLNK\n    LEN = C2d(Storage(D2x(CVTLLTA+LNKOFF),1))     /* length of entry */\n    LKDSN = Storage(D2x(CVTLLTA+LNKOFF+1),LEN)    /* DSN of LNK lib  */\n    CHKAPF = Storage(D2x(LLTAPFTB+LKAPFOFF),1)    /* APF flag        */\n    If  bitand(CHKAPF,'80'x) = '80'x then LKAPF = 'Y'  /* flag on    */\n      else LKAPF = ' '                            /* APF flag off    */\n    LNKOFF = LNKOFF + 44 + 1                      /*next entry in tbl*/\n    LKAPFOFF = LKAPFOFF + 1               /* next entry in LLTAPFTB  */\n    LNKPOS = Right(I,3)                           /*position in list */\n    RELLKPOS = Right('(+'I-1')',6)      /* relative position in list */\n    Queue LNKPOS  RELLKPOS '   ' LKAPF '   ' LKDSN\n  End\nEnd\nElse do  /* OS/390 1.2 and above - PROGxx capable LNKLST             */\n  ASCB     = C2d(Storage(224,4))               /* point to ASCB      */\n  ASSB     = C2d(Storage(D2x(ASCB+336),4))     /* point to ASSB      */\n  DLCB     = C2d(Storage(D2x(ASSB+236),4))     /* point to CSVDLCB   */\n  DLCBFLGS = Storage(d2x(DLCB + 32),1)         /* DLCB flag bits     */\n  SETNAME  = Storage(D2x(DLCB + 36),16)        /* LNKLST set name    */\n  SETNAME  = Strip(SETNAME,'T')                /* del trailing blanks*/\n  CVTLLTA  = C2d(Storage(D2x(DLCB + 16),4))    /* point to lnklst tbl*/\n  LLTX     = C2d(Storage(D2x(DLCB + 20),4))    /* point to LLTX      */\n  NUMLNK   = C2d(Storage(D2x(CVTLLTA+4),4))    /* # LNK libs in table*/\n  LLTAPFTB = CVTLLTA + 8 + (NUMLNK*45)         /* start of LLTAPFTB  */\n  LNKOFF   = 8                                 /*first ent in LLT tbl*/\n  VOLOFF   = 8                                 /*first ent in LLTX   */\n  LKAPFOFF = 0                                /*first ent in LLTAPFTB*/\n  If Bitand(DLCBFLGS,'10'x) = '10'x then ,     /* bit for LNKAUTH    */\n       LAUTH = 'LNKLST'                        /* LNKAUTH=LNKLST     */\n  Else LAUTH = 'APFTAB'                        /* LNKAUTH=APFTAB     */\n  Queue '     '\n  Queue 'LNKLST Library List - Set:' SETNAME ,\n        ' LNKAUTH='LAUTH '('NUMLNK' Libraries):'\n  If LAUTH = 'LNKLST' then ,\n    Queue '     (All LNKLST data sets marked APF=Y due to' ,\n          'LNKAUTH=LNKLST)'\n  Queue '  POSITION    APF   VOLUME    DSNAME'\n  Do I = 1 to NUMLNK\n    LEN = C2d(Storage(D2x(CVTLLTA+LNKOFF),1))     /* length of entry */\n    LKDSN = Storage(D2x(CVTLLTA+LNKOFF+1),LEN)    /* DSN of LNK lib  */\n    LNKVOL = Storage(D2x(LLTX+VOLOFF),6)          /* VOL of LNK lib  */\n    CHKAPF = Storage(D2x(LLTAPFTB+LKAPFOFF),1)    /* APF flag        */\n    If  bitand(CHKAPF,'80'x) = '80'x then LKAPF = 'Y'    /* flag on  */\n      else LKAPF = ' '                            /* APF flag off    */\n    LNKOFF   = LNKOFF + 44 + 1                    /*next entry in LLT*/\n    VOLOFF   = VOLOFF + 8                         /*next vol in LLTX */\n    LKAPFOFF = LKAPFOFF + 1               /* next entry in LLTAPFTB  */\n    LNKPOS   = Right(I,3)                         /*position in list */\n    RELLKPOS = Right('(+'I-1')',6)      /* relative position in list */\n    Queue LNKPOS  RELLKPOS '   ' LKAPF '  ' LNKVOL '  ' LKDSN\n  End\nEnd\nReturn\n\nAPF:                 /* APF List sub-routine                         */\nCVTAUTHL = C2d(Storage(D2x(CVT + 484),4))    /* point to auth lib tbl*/\nIf CVTAUTHL <> C2d('7FFFF001'x) then do      /* dynamic list ?       */\n  NUMAPF   = C2d(Storage(D2x(CVTAUTHL),2))   /* # APF libs in table  */\n  APFOFF   = 2                               /* first ent in APF tbl */\n  Queue '     '\n  Queue 'APF Library List  ('NUMAPF' libraries):'\n  Queue '  ENTRY   VOLUME    DSNAME'\n  Do I = 1 to NUMAPF\n    LEN = C2d(Storage(D2x(CVTAUTHL+APFOFF),1)) /* length of entry    */\n    VOL = Storage(D2x(CVTAUTHL+APFOFF+1),6)    /* VOLSER of APF LIB  */\n    DSN = Storage(D2x(CVTAUTHL+APFOFF+1+6),LEN-6)  /* DSN of apflib  */\n    APFOFF = APFOFF + LEN +1\n    APFPOS   = Right(I,4)                      /*position in APF list*/\n    Queue '  'APFPOS '  ' VOL '  ' DSN\n  End\nEnd\nElse Do\n  ECVT     = C2d(Storage(D2x(CVT + 140),4))    /* point to CVTECVT   */\n  ECVTCSVT = C2d(Storage(D2x(ECVT + 228),4))   /* point to CSV table */\n  APFA = C2d(Storage(D2x(ECVTCSVT + 12),4))    /* APFA               */\n  AFIRST = C2d(Storage(D2x(APFA + 8),4))       /* First entry        */\n  ALAST  = C2d(Storage(D2x(APFA + 12),4))      /* Last  entry        */\n  LASTONE = 0   /* flag for end of list     */\n  NUMAPF = 1    /* tot # of entries in list */\n  Do forever\n    DSN.NUMAPF = Storage(D2x(AFIRST+24),44)    /* DSN of APF library */\n    DSN.NUMAPF = Strip(DSN.NUMAPF,'T')         /* remove blanks      */\n    CKSMS = Storage(D2x(AFIRST+4),1)           /* DSN of APF library */\n    if  bitand(CKSMS,'80'x)  = '80'x           /*  SMS data set?     */\n      then VOL.NUMAPF = '*SMS* '               /* SMS control dsn    */\n    else VOL.NUMAPF = Storage(D2x(AFIRST+68),6)    /* VOL of APF lib */\n    If Substr(DSN.NUMAPF,1,1) <> X2c('00')     /* check for deleted  */\n      then NUMAPF = NUMAPF + 1                 /*   APF entry        */\n    AFIRST = C2d(Storage(D2x(AFIRST + 8),4))   /* next  entry        */\n    if LASTONE = 1 then leave\n    If  AFIRST = ALAST then LASTONE = 1\n  End\n  Queue '     '\n  Queue 'APF Library List  - Dynamic ('NUMAPF - 1' libraries):'\n  Queue '  ENTRY   VOLUME    DSNAME'\n  Do I = 1 to NUMAPF-1\n    APFPOS   = Right(I,4)                      /*position in APF list*/\n    Queue '  'APFPOS '  ' VOL.I '  ' DSN.I\n  End\nEnd\nReturn\n\nSVC:                 /* SVC information sub-routine                  */\n/*********************************************************************/\n/* See SYS1.MODGEN(IHASVC) for descriptions of SVC attributes        */\n/*********************************************************************/\nCVTABEND  = C2d(Storage(D2x(CVT+200),4))     /* point to CVTABEND    */\nSCVT      = CVTABEND        /* this is the SCVT -  mapped by IHASCVT */\nSCVTSVCT  = C2d(Storage(D2x(SCVT+132),4))    /* point to SVCTABLE    */\nSCVTSVCR  = C2d(Storage(D2x(SCVT+136),4))    /* point to SVC UPD TBL */\nCall FIND_NUC 'IGCERROR'     /* Find addr of IGCERROR in NUC MAP     */\nIGCERROR_ADDR = RESULT       /* Save address of IGCERROR             */\nCall FIND_NUC 'IGCRETRN'     /* Find addr of IGCRETRN in NUC MAP     */\nIGCRETRN_ADDR = RESULT       /* Save address of IGCRETRN             */\nCall FIND_NUC 'IGXERROR'     /* Find addr of IGXERROR in NUC MAP     */\nIGXERROR_ADDR = RESULT       /* Save address of IGXERROR             */\nCall VMAP 'NODISP'      /* call virt. stor map routine, \"no display\" */\n/*********************************************************************/\n/* The following code is needed to prevent errors in FIND_SVC_LOC    */\n/* routine \"Select\" because the VMAP sub-routine sets the address    */\n/* variables to \"N/A\" when MLPA/E-MLPA/FLPA/E-FLPA do not exist.     */\n/*********************************************************************/\nIf CVTMLPAS = 'N/A' then CVTMLPAS = 0  /* MLPA   strt does not exist */\nIf CVTMLPAE = 'N/A' then CVTMLPAE = 0  /* MLPA   end  does not exist */\nIf CVTFLPAS = 'N/A' then CVTFLPAS = 0  /* FLPA   strt does not exist */\nIf CVTFLPAE = 'N/A' then CVTFLPAE = 0  /* FLPA   end  does not exist */\nIf CVTEFLPS = 'N/A' then CVTEFLPS = 0  /* E-FLPA strt does not exist */\nIf CVTEFLPE = 'N/A' then CVTEFLPE = 0  /* E-FLPA end  does not exist */\nIf CVTEMLPS = 'N/A' then CVTEMLPS = 0  /* E-MLPA strt does not exist */\nIf CVTEMLPE = 'N/A' then CVTEMLPE = 0  /* E-MLPA end  does not exist */\n/*********************************************************************/\n/* A little house keeping                                            */\n/*********************************************************************/\nSVCACT_TOT    = 0   /* total number of active std SVCs               */\nSVCUNUSED_TOT = 0   /* total number of unused std SVCs               */\nSVCAPF_TOT    = 0   /* total number of std SVCs requiring APF        */\nSVCESR_T1_TOT = 0   /* total number of active Type 1 ESR SVCs        */\nSVCESR_T2_TOT = 0   /* total number of active Type 2 ESR SVCs        */\nSVCESR_T3_TOT = 0   /* total number of active Type 3/4 ESR SVCs      */\nSVCESR_T6_TOT = 0   /* total number of active Type 6 ESR SVCs        */\n/*********************************************************************/\n/* Standard SVC table display loop                                   */\n/*********************************************************************/\nQueue '     '\nQueue 'SVC Table:'\nQueue '  Num Hex  EP-Addr  Location  AM TYP APF ESR ASF AR NP UP' ,\n      'CNT Old-EPA  LOCKS'\nDo SVCLST = 0 to 255\n  SVCTENT  = Storage(D2x(SCVTSVCT+(SVCLST*8)),8)  /* SVC Table Entry */\n  SVCTENTU = Storage(D2x(SCVTSVCR+(SVCLST*24)),24) /* SVC UP TBL ENT */\n  SVCOLDA  = Substr(SVCTENTU,1,4)            /* OLD EP Address       */\n  SVCOLDAR = C2x(SVCOLDA)                    /* OLD addr readable    */\n  SVCOLDAR = Right(SVCOLDAR,8,'0')           /* ensure leading zeros */\n  SVCURCNT = C2d(Substr(SVCTENTU,21,2))      /* SVC update count     */\n  SVCAMODE = Substr(SVCTENT,1,1)             /* AMODE indicator      */\n  SVCEPA   = Substr(SVCTENT,1,4)             /* Entry point addr     */\n  SVCEPAR  = C2x(SVCEPA)                     /* EPA - readable       */\n  SVCEPAR  = Right(SVCEPAR,8,'0')            /* ensure leading zeros */\n  SVCATTR1 = Substr(SVCTENT,5,1)             /* SVC attributes       */\n  SVCATTR3 = Substr(SVCTENT,6,1)             /* SVC attributes       */\n  SVCLOCKS = Substr(SVCTENT,7,1)             /* Lock attributes      */\n  /**************************/\n  /* Save EPAs of ESR SVCs  */\n  /**************************/\n  If SVCLST = 109 then SVC109AD = SVCEPA\n  If SVCLST = 116 then SVC116AD = SVCEPA\n  If SVCLST = 122 then SVC122AD = SVCEPA\n  If SVCLST = 137 then SVC137AD = SVCEPA\n  /**************************/\n  /*  Check amode           */\n  /**************************/\n  If Bitand(SVCAMODE,'80'x) = '80'x then SVC_AMODE = '31'\n    Else SVC_AMODE = '24'\n  /**************************/\n  /*  Check SVC type flag   */\n  /**************************/\n  Select                                     /* determine SVC type   */\n    When Bitand(SVCATTR1,'C0'x) = 'C0'x then SVCTYPE = '3/4'\n    When Bitand(SVCATTR1,'80'x) = '80'x then SVCTYPE = ' 2 '\n    When Bitand(SVCATTR1,'20'x) = '20'x then SVCTYPE = ' 6 '\n    When Bitand(SVCATTR1,'00'x) = '00'x then SVCTYPE = ' 1 '\n    Otherwise SVCTYPE = '???'\n  End /* select */\n  If SVCLST = 109 then SVCTYPE = ' 3 '  /* 109 is type 3 ESR, not 2  */\n  /**************************/\n  /*  Check other SVC flags */\n  /**************************/\n  SVCAPF = '   ' ; SVCESR = '   ' ; SVCNP = '  '  /* init as blanks  */\n  SVCASF = '   ' ; SVCAR  = '  '  ; SVCUP = '  '  /* init as blanks  */\n  If Bitand(SVCATTR1,'08'x) = '08'x then SVCAPF  = 'APF'\n  If Bitand(SVCATTR1,'04'x) = '04'x then SVCESR  = 'ESR'\n  If Bitand(SVCATTR1,'02'x) = '02'x then SVCNP   = 'NP'\n  If Bitand(SVCATTR1,'01'x) = '01'x then SVCASF  = 'ASF'\n  If Bitand(SVCATTR3,'80'x) = '80'x then SVCAR   = 'AR'\n  If SVCURCNT <> 0 then SVCUP = 'UP'   /* this SVC has been updated  */\n  If SVCURCNT = 0 then do              /* svc never updated          */\n    SVCURCNT = '   '\n    SVCOLDAR = '        '\n  End\n  Else do /* most, if not all UP nums are sngl digit- center display */\n   If SVCURCNT < 10 then SVCURCNT = Right(SVCURCNT,2,' ') || ' '\n     Else SVCURCNT = Right(SVCURCNT,3,' ')\n  End /* else do */\n  /**************************/\n  /*  Check lock flags      */\n  /**************************/\n  SVCLL    = ' '  ; SVCCMS  = ' ' ; SVCOPT = ' '  /* init as blanks  */\n  SVCALLOC = ' '  ; SVCDISP = ' '                 /* init as blanks  */\n  If Bitand(SVCLOCKS,'80'x) = '80'x then SVCLL    = 'L'  /* LOCAL    */\n  If Bitand(SVCLOCKS,'40'x) = '40'x then SVCCMS   = 'C'  /* CMS      */\n  If Bitand(SVCLOCKS,'20'x) = '20'x then SVCOPT   = 'O'  /* OPT      */\n  If Bitand(SVCLOCKS,'10'x) = '10'x then SVCALLOC = 'S'  /* SALLOC   */\n  If Bitand(SVCLOCKS,'08'x) = '08'x then SVCDISP  = 'D'  /* DISP     */\n  /*********************************/\n  /*  location, location, location */\n  /*********************************/\n  SVCLOCA = Bitand(SVCEPA,'7FFFFFFF'x)       /* zero high order bit  */\n  SVCLOCA = C2d(SVCLOCA)                     /* need dec. for compare*/\n  Call FIND_SVC_LOC SVCLOCA                  /* determine SVC loc    */\n  SVCLOC = RESULT                            /* Save Result          */\n\n  If SVCLOCA = IGCERROR_ADDR | ,             /* this SVC             */\n     SVCLOCA = IGCRETRN_ADDR then do         /*          is not used */\n    SVC_AMODE = '  '                         /* blank out amode      */\n    SVCAPF = '*** Not Used ***'              /* replace other        */\n    SVCESR = ''                              /*   fields to line     */\n    SVCASF = ''                              /*     up \"locks\" due   */\n    SVCAR  = ''                              /*       to \"not used\"  */\n    SVCNP  = ''                              /*         display      */\n    SVCUP  = ''                              /*                      */\n    SVCURCNT = ''                            /*                      */\n    SVCOLDAR = '          '                  /*                      */\n    SVCUNUSED_TOT = SVCUNUSED_TOT + 1        /* add 1 to unused tot  */\n  End /* If SVCLOCA = IGCERROR_ADDR */\n  Else do /* used SVC */\n    SVCACT_TOT = SVCACT_TOT + 1              /* add 1 to tot active  */\n    If SVCAPF  = 'APF' then ,\n       SVCAPF_TOT = SVCAPF_TOT + 1           /* add 1 to APF total   */\n  End /* Else do */\n\n  Queue ' '  Right(SVCLST,3,' ') '('Right(D2x(SVCLST),2,0)')' ,\n    SVCEPAR SVCLOC SVC_AMODE SVCTYPE SVCAPF SVCESR SVCASF ,\n    SVCAR SVCNP SVCUP SVCURCNT SVCOLDAR ,\n    SVCLL || SVCCMS || SVCOPT || SVCALLOC || SVCDISP\nEnd /* Do SVCLST = 0 to 255 */\n/*********************************************************************/\n/* ESR SVC tables display loop                                       */\n/*********************************************************************/\nDo SVCESRL = 1 to 4  /* ESR display loop  */\n  If SVCESRL = 1 then do\n    SVCEAD = C2d(SVC116AD)                   /* Type 1 ESR tbl       */\n    SVCEHD = 'Type 1 (SVC 116'              /* Type/SVC for heading */\n  End\n  If SVCESRL = 2 then do\n    SVCEAD = C2d(SVC122AD)                   /* Type 2 ESR tbl       */\n    SVCEHD = 'Type 2 (SVC 122'              /* Type/SVC for heading */\n  End\n  If SVCESRL = 3 then do\n    SVCEAD = C2d(SVC109AD)                   /* Type 3 ESR tbl       */\n    SVCEHD = 'Type 3 (SVC 109'              /* Type/SVC for heading */\n  End\n  If SVCESRL = 4 then do\n    SVCEAD = C2d(SVC137AD)                   /* Type 6 ESR tbl       */\n    SVCEHD = 'Type 6 (SVC 137'              /* Type/SVC for heading */\n  End\n  SVCESRMX = C2d(Storage(D2x(SVCEAD+4),4))   /* Max # ESR entries    */\n  Queue '     '\n  Queue 'SVC Table for ESR' SVCEHD '- Maximum ESR Number Supported' ,\n        'is' SVCESRMX'):'\n  Queue '  Num Hex  EP-Addr  Location  AM TYP APF ASF AR NP' ,\n        'LOCKS'\n  SVCEAD = SVCEAD + 8                        /* bump past ESR hdr    */\n  Do SVCELST = 0 to SVCESRMX\n    SVCETENT  = Storage(D2x(SVCEAD+(SVCELST*8)),8) /* SVC Tbl Entry  */\n    SVCEAMODE = Substr(SVCETENT,1,1)         /* AMODE indicator      */\n    SVCEEPA   = Substr(SVCETENT,1,4)         /* Entry point addr     */\n    SVCEEPAR  = C2x(SVCEEPA)                 /* EPA - readable       */\n    SVCEEPAR  = Right(SVCEEPAR,8,'0')        /* ensure leading zeros */\n    SVCEATTR1 = Substr(SVCETENT,5,1)         /* SVC attributes       */\n    SVCEATTR3 = Substr(SVCETENT,6,1)         /* SVC attributes       */\n    SVCELOCKS = Substr(SVCETENT,7,1)         /* Lock attributes      */\n  /**************************/\n  /*  Check amode           */\n  /**************************/\n  If Bitand(SVCEAMODE,'80'x) = '80'x then SVCE_AMODE = '31'\n    Else SVCE_AMODE = '24'\n  /**************************/\n  /*  Check SVC type flag   */\n  /**************************/\n  Select                                     /* determine SVC type   */\n    When Bitand(SVCEATTR1,'C0'x) = 'C0'x then SVCETYPE = '3/4'\n    When Bitand(SVCEATTR1,'80'x) = '80'x then SVCETYPE = ' 2 '\n    When Bitand(SVCEATTR1,'20'x) = '20'x then SVCETYPE = ' 6 '\n    When Bitand(SVCEATTR1,'00'x) = '00'x then SVCETYPE = ' 1 '\n    Otherwise SVCETYPE = '???'\n  End /* select */\n  /**************************/\n  /*  Check other SVC flags */\n  /**************************/\n  SVCEAPF = '   ' ; SVCENP = '  '  /* init as blanks  */\n  SVCEASF = '   ' ; SVCEAR = '  '  /* init as blanks  */\n  SVCEESR = '   '\n  If Bitand(SVCEATTR1,'08'x) = '08'x then SVCEAPF  = 'APF'\n  If Bitand(SVCEATTR1,'04'x) = '04'x then SVCEESR  = 'ESR'\n  If Bitand(SVCEATTR1,'02'x) = '02'x then SVCENP   = 'NP'\n  If Bitand(SVCEATTR1,'01'x) = '01'x then SVCEASF  = 'ASF'\n  If Bitand(SVCEATTR3,'80'x) = '80'x then SVCEAR   = 'AR'\n  /**************************/\n  /*  Check lock flags      */\n  /**************************/\n  SVCELL    = ' '  ; SVCECMS  = ' ' ; SVCEOPT = ' ' /* init as blanks*/\n  SVCEALLOC = ' '  ; SVCEDISP = ' '                 /* init as blanks*/\n  If Bitand(SVCELOCKS,'80'x) = '80'x then SVCELL    = 'L' /* LOCAL   */\n  If Bitand(SVCELOCKS,'40'x) = '40'x then SVCECMS   = 'C' /* CMS     */\n  If Bitand(SVCELOCKS,'20'x) = '20'x then SVCEOPT   = 'O' /* OPT     */\n  If Bitand(SVCELOCKS,'10'x) = '10'x then SVCEALLOC = 'S' /* SALLOC  */\n  If Bitand(SVCELOCKS,'08'x) = '08'x then SVCEDISP  = 'D' /* DISP    */\n  /*********************************/\n  /*  location, location, location */\n  /*********************************/\n  SVCELOCA = Bitand(SVCEEPA,'7FFFFFFF'x)     /* zero high order bit  */\n  SVCELOCA = C2d(SVCELOCA)                   /* need dec. for compare*/\n  Call FIND_SVC_LOC SVCELOCA                 /* determine SVC loc    */\n  SVCELOC = RESULT                           /* Save Result          */\n\n  If SVCELOCA = IGXERROR_ADDR then do        /* this SVC is not used */\n    SVCE_AMODE = '  '                        /* blank out amode      */\n    SVCEAPF = '* Unused *'                   /* replace other fields */\n    SVCEASF = ''                             /*  to line up \"locks\"  */\n    SVCEAR  = ''                             /*   due to \"unused\"    */\n    SVCENP  = ''                             /*    display           */\n  End /* If SVCELOCA = IGXERROR_ADDR */\n  Else do /* used SVC */\n    If SVCESRL = 1 then ,\n       SVCESR_T1_TOT = SVCESR_T1_TOT + 1     /* add 1 to TYPE 1 tot  */\n    If SVCESRL = 2 then ,\n       SVCESR_T2_TOT = SVCESR_T2_TOT + 1     /* add 1 to TYPE 2 tot  */\n    If SVCESRL = 3 then ,\n       SVCESR_T3_TOT = SVCESR_T3_TOT + 1     /* add 1 to TYPE 3/4 tot*/\n    If SVCESRL = 4 then ,\n       SVCESR_T6_TOT = SVCESR_T6_TOT + 1     /* add 1 to TYPE 6 tot  */\n  End /* Else do */\n\n  Queue ' '  Right(SVCELST,3,' ') '('Right(D2x(SVCELST),2,0)')' ,\n    SVCEEPAR SVCELOC SVCE_AMODE SVCETYPE SVCEAPF SVCEASF ,\n    SVCEAR SVCENP ,\n    SVCELL || SVCECMS || SVCEOPT || SVCEALLOC || SVCEDISP\n  End\n\nEnd /* Do SVCESRL = 1 to 4 */\nQueue '    '\nQueue '  SVC Usage Summary:'\nQueue '    Total number of active standard SVCs (including ESR' ,\n      'slots) =' SVCACT_TOT\nQueue '    Total number of unused standard SVCs =' SVCUNUSED_TOT\nQueue '    Total number of active standard SVCs' ,\n      'requiring APF auth =' SVCAPF_TOT\nQueue '    Total number of active Type 1   ESR SVCs =' SVCESR_T1_TOT\nQueue '    Total number of active Type 2   ESR SVCs =' SVCESR_T2_TOT\nQueue '    Total number of active Type 3/4 ESR SVCs =' SVCESR_T3_TOT\nQueue '    Total number of active Type 6   ESR SVCs =' SVCESR_T6_TOT\nReturn\n\nFIND_SVC_LOC:  /* determine virtual storage location of SVC  */\nArg SVC_LOC\nSelect\n  When SVC_LOC >= X2d(VVSTRT)    & SVC_LOC <= X2d(VVEND)     ,\n       then SVCLOC = 'PRIVATE  ' /* never, but coded anyway */\n  When SVC_LOC >= X2d(GDACSAH)   & SVC_LOC <= X2d(CSAEND)    ,\n       then SVCLOC = 'CSA      '\n  When SVC_LOC >= X2d(CVTMLPAS)  & SVC_LOC <= X2d(CVTMLPAE)  ,\n       then SVCLOC = 'MLPA     '\n  When SVC_LOC >= X2d(CVTFLPAS)  & SVC_LOC <= X2d(CVTFLPAE)  ,\n       then SVCLOC = 'FLPA     '\n  When SVC_LOC >= X2d(CVTPLPAS)  & SVC_LOC <= X2d(CVTPLPAE)  ,\n       then SVCLOC = 'PLPA     '\n  When SVC_LOC >= X2d(GDASQAH)   & SVC_LOC <= X2d(SQAEND)    ,\n       then SVCLOC = 'SQA      '\n  When SVC_LOC >= X2d(CVTRWNS)   & SVC_LOC <= X2d(CVTRWNE)   ,\n       then SVCLOC = 'R/W Nuc  '\n  When SVC_LOC >= X2d(RONUCSZB)  & SVC_LOC <= X2d('FFFFFF')  ,\n       then SVCLOC = 'R/O Nuc  '\n  When SVC_LOC >= X2d('1000000') & SVC_LOC <= X2d(CVTRONE)   ,\n       then SVCLOC = 'E-R/O Nuc'\n  When SVC_LOC >= X2d(CVTERWNS)  & SVC_LOC <= X2d(CVTERWNE)  ,\n       then SVCLOC = 'E-R/W Nuc'\n  When SVC_LOC >= X2d(GDAESQAH)  & SVC_LOC <= X2d(ESQAEND)   ,\n       then SVCLOC = 'E-SQA    '\n  When SVC_LOC >= X2d(CVTEPLPS)  & SVC_LOC <= X2d(CVTEPLPE)  ,\n       then SVCLOC = 'E-PLPA   '\n  When SVC_LOC >= X2d(CVTEFLPS)  & SVC_LOC <= X2d(CVTEFLPE)  ,\n       then SVCLOC = 'E-FLPA   '\n  When SVC_LOC >= X2d(CVTEMLPS)  & SVC_LOC <= X2d(CVTEMLPE)  ,\n       then SVCLOC = 'E-MLPA   '\n  When SVC_LOC >= X2d(GDAECSAH)  & SVC_LOC <= X2d(ECSAEND)   ,\n       then SVCLOC = 'E-CSA    '\n  When SVC_LOC >= X2d(GDAEPVTH)  & SVC_LOC <= X2d(EPVTEND)   ,\n       then SVCLOC = 'E-PRIVATE' /* never, but coded anyway */\n  Otherwise SVCLOC = '????     '\nEnd /* select */\nReturn SVCLOC\n\nFIND_NUC: /* Find EP address of \"ARG\" in NUC MAP  */\nArg NUC_NAME\nCVTNUCMP  = C2d(Storage(D2x(CVT+1200),4))    /* NUC map address      */\nNUCMAPEND = C2d(Storage(D2x(CVTNUCMP+8),4))  /* End of nucmap        */\n /* NUCMAPLEN = C2d(Storage(D2x(CVTNUCMP+13),3)) */ /* tbl length    */\nNUC_CURA  = CVTNUCMP+16                      /* Curent tbl entry     */\nDo while  NUC_CURA <  NUCMAPEND              /* go though tbl        */\n  NUC_EP    = Storage(D2x(NUC_CURA),8)       /* Nuc EP name          */\n  If NUC_EP = NUC_NAME then do               /* NUC_NAME found?      */\n    NUC_ADDR = C2d(Storage(D2x(NUC_CURA+8),4)) /* yes, save addr     */\n    Leave                                    /* leave this loop      */\n  End /* If NUC_EP = NUC_NAME */\n  Else NUC_CURA = NUC_CURA + 16              /* bump to next entry   */\nEnd /* do while */\nReturn NUC_ADDR\n\nXLATE_NONDISP:       /* translate non-display characters to a \".\"    */\nArg XLATEPRM\nXLATELEN = Length(XLATEPRM) /* length of parm passed to routine      */\nDo I = 1 to XLATELEN                      /* check each byte for     */\n  If (Substr(XLATEPRM,I,1) >= '00'x & ,   /* non-display characters  */\n    Substr(XLATEPRM,I,1) < '40'x ) | ,    /* and replace each        */\n    Substr(XLATEPRM,I,1) = 'FF'x  then ,  /* character that          */\n    XLATEPRM = OVERLAY('.',XLATEPRM,I)    /* is non-displayable      */\nEnd                                       /* with a period (.)       */\nReturn XLATEPRM\n\nSTORAGE_GDA_LDA:     /* GDA/LDA Storage values sub-routine           */\nASCB     = C2d(Storage(224,4))               /* point to cur ASCB    */\nASCBLDA  = C2d(Storage(D2x(ASCB + 48),4))    /* point to LDA         */\nCVTGDA   = C2d(Storage(D2x(CVT + 560),4))    /* point to GDA         */\nLDASTRTA = Storage(D2x(ASCBLDA + 60),4)      /* point to V=V start   */\nLDASTRTA = C2x(LDASTRTA)                     /* display in hex       */\nLDASIZEA = C2d(Storage(D2x(ASCBLDA + 64),4)) /* point to V=V size    */\nLDASIZEA = LDASIZEA/1024                     /* convert to Kbytes    */\nLDASTRTS = Storage(D2x(ASCBLDA + 92),4)      /* pt. to sysarea start */\nLDASTRTS = C2x(LDASTRTS)                     /* display in hex       */\nLDASIZS  = C2d(Storage(D2x(ASCBLDA + 96),4)) /* pt. to sysarea size  */\nLDASIZS  = LDASIZS/1024                      /* convert to Kbytes    */\nGDAPVTSZ = C2d(Storage(D2x(CVTGDA + 164),4)) /* point to MAX PVT<16M */\nGDAPVTSZ = GDAPVTSZ/1024                     /* convert to Kbytes    */\nGDAEPVTS = C2d(Storage(D2x(CVTGDA + 172),4)) /* point to MAX PVT>16M */\nGDAEPVTS = GDAEPVTS/1024/1024                /* convert to Mbytes    */\nGDACSASZ = C2d(Storage(D2x(CVTGDA + 112),4)) /* point to CSA<16M     */\nGDACSASZ = GDACSASZ/1024                     /* convert to Kbytes    */\nGDAECSAS = C2d(Storage(D2x(CVTGDA + 128),4)) /* point to CSA>16M     */\nGDAECSAS = GDAECSAS/1024                     /* convert to Kbytes    */\nGDASQASZ = C2d(Storage(D2x(CVTGDA + 148),4)) /* point to SQA<16M     */\nGDASQASZ = GDASQASZ/1024                     /* convert to Kbytes    */\nGDAESQAS = C2d(Storage(D2x(CVTGDA + 156),4)) /* point to SQA>16M     */\nGDAESQAS = GDAESQAS/1024                     /* convert to Kbytes    */\nGDAVRSZ  = C2d(Storage(D2x(CVTGDA + 196),4)) /* point to V=R global  */\nGDAVRSZ  = GDAVRSZ/1024                      /* convert to Kbytes    */\nGDAVREGS = C2d(Storage(D2x(CVTGDA + 200),4)) /* point to V=R default */\nGDAVREGS = GDAVREGS/1024                     /* convert to Kbytes    */\nGDA_CSA_ALLOC  = C2d(Storage(D2x(CVTGDA + 432),4)) /* CSA amt alloc  */\nGDA_CSA_ALLOC  = Format(GDA_CSA_ALLOC/1024,,0)     /* conv to Kbytes */\nGDA_ECSA_ALLOC = C2d(Storage(D2x(CVTGDA + 436),4)) /* ECSA amt alloc */\nGDA_ECSA_ALLOC = Format(GDA_ECSA_ALLOC/1024,,0)    /* conv to Kbytes */\nGDA_SQA_ALLOC  = C2d(Storage(D2x(CVTGDA + 440),4)) /* SQA amt alloc  */\nGDA_SQA_ALLOC  = Format(GDA_SQA_ALLOC/1024,,0)     /* conv to Kbytes */\nGDA_ESQA_ALLOC = C2d(Storage(D2x(CVTGDA + 444),4)) /* ESQA amt alloc */\nGDA_ESQA_ALLOC = Format(GDA_ESQA_ALLOC/1024,,0)    /* conv to Kbytes */\nGDA_CSA_CONV   = C2d(Storage(D2x(CVTGDA + 448),4)) /* CSA => SQA amt */\nGDA_CSA_CONV   = Format(GDA_CSA_CONV/1024,,0)      /* conv to Kbytes */\nGDA_ECSA_CONV  = C2d(Storage(D2x(CVTGDA + 452),4)) /* ECSA=>ESQA amt */\nGDA_ECSA_CONV  = Format(GDA_ECSA_CONV/1024,,0)     /* conv to Kbytes */\n/*********************************************************************/\n/* High Water Marks for SQA/ESQA/CSA/ECSA added in OS/390 R10        */\n/*********************************************************************/\nIf Bitand(CVTOSLV2,'01'x) = '01'x then do    /* OS/390 R10 and above */\n  GDASQAHWM  = C2d(Storage(D2x(CVTGDA + 536),4))   /* SQA HWM        */\n  GDASQAHWM  = Format(GDASQAHWM/1024,,0)           /* conv to Kbytes */\n  GDAESQAHWM = C2d(Storage(D2x(CVTGDA + 540),4))   /* ESQA HWM       */\n  GDAESQAHWM = Format(GDAESQAHWM/1024,,0)          /* conv to Kbytes */\n  If Bitand(CVTOSLV5,'08'x) = '08'x then do  /* z/OS 1.10 and above  */\n    GDATotalCSAHWM  = C2d(Storage(D2x(CVTGDA+552),4)) /* CSA HWM     */\n    GDATotalCSAHWM  = Format(GDATotalCSAHWM/1024,,0)  /* conv to Kb  */\n    GDATotalECSAHWM = C2d(Storage(D2x(CVTGDA+556),4)) /* ECSA HWM    */\n    GDATotalECSAHWM = Format(GDATotalECSAHWM/1024,,0) /* conv to Kb  */\n    GDACSAHWM       = GDATotalCSAHWM   /* set var used for VMAP disp */\n    GDAECSAHWM      = GDATotalECSAHWM  /* set var used for VMAP disp */\n  End\n  Else do  /* use pre z/OS 1.10 values for CSA/ECSA HWM              */\n    GDACSAHWM  = C2d(Storage(D2x(CVTGDA + 544),4)) /* CSA HWM        */\n    GDACSAHWM  = Format(GDACSAHWM/1024,,0)         /* conv to Kbytes */\n    GDAECSAHWM = C2d(Storage(D2x(CVTGDA + 548),4)) /* ECSA HWM       */\n    GDAECSAHWM = Format(GDAECSAHWM/1024,,0)        /* conv to Kbytes */\n  End\nEnd\nReturn\n\nEXTRACT_SYSPARMS:    /* Extract IEASYSxx values from the IPA         */\nParse arg IEASPARM\nIEASPARM = Strip(IEASPARM,'T')               /* remove trailing blnks*/\nIf IEASPARM = '<notdef>' then return         /*\"blank\" parm in IHAIPA*/\n/*********************************************************************/\n/* This next section of code removes IEASYSxx parameters from the    */\n/* IPA output display for parms that are obsolete or undocumented    */\n/* but still have to be accounted for when parsing out the parms     */\n/* and values from the IPA control block.                            */\n/*********************************************************************/\nIf Bitand(CVTOSLV3,'08'x) = '08'x then ,     /* z/OS 1.3 and above   */\n  If Substr(IEASPARM,1,3) = 'IPS'then return /* remove IPS parm      */\nIf Bitand(CVTOSLV3,'02'x) = '02'x then ,     /* z/OS 1.5 and above   */\n  If Pos('ILM',IEASPARM) <> 0  then return   /* remove ILM parms     */\nIf Bitand(CVTOSLV5,'04'x) = '04'x then do    /* z/OS 1.11 and above  */\n  If Pos('IQP',IEASPARM)  <> 0 then return   /* remove IQP parm      */\n  If Pos('CPCR',IEASPARM) <> 0 then return   /* remove CPCR parm     */\n  If Pos('DDM',IEASPARM)  <> 0 then return   /* remove DDM parm      */\nEnd\nIf Bitand(CVTOSLV5,'01'x) = '01'x then do    /* z/OS 1.13 and above  */\n  If Pos('RTLS',IEASPARM) <> 0 then return   /* remove RTLS parm     */\nEnd\n/*********************************************************************/\nIPAOFF = ((I-1) * 8)                         /* offset to next entry */\nIPASTOR = D2x(ECVTIPA + 2152 + IPAOFF)       /* point to PDE addr    */\nIPAPDE  = C2x(Storage((IPASTOR),8))          /* point to PDE         */\nIf IPAPDE = 0 then return   /* parm not specified and has no default */\nTOTPRMS = TOTPRMS + 1    /* tot num of specified or defaulted parms  */\nIPAADDR = Substr(IPAPDE,1,8)                 /* PARM address         */\nIPALEN  = X2d(Substr(IPAPDE,9,4))            /* PARM length          */\nIPAPRM  = Storage((IPAADDR),IPALEN)          /* PARM                 */\nIPASRC  = Substr(IPAPDE,13,4)                /* PARM source          */\nIf X2d(IPASRC) = 65535 then PRMSRC = 'Operator'   /* operator parm   */\nElse\n  If X2d(IPASRC) = 0     then PRMSRC = 'Default'  /* default  parm   */\nElse\n  PRMSRC = 'IEASYS' || X2c(IPASRC)           /* IEASYSxx parm        */\nPRMLINE = '    'IEASPARM'='IPAPRM\n  /**************************************************/\n  /* This check just below is for parms that do not */\n  /* have an equal sign in IEASYSxx.                */\n  /**************************************************/\nIf IEASPARM = 'PRESCPU' | ,\n   IEASPARM = 'WARNUND' | ,\n   IEASPARM = 'CVIO'    | ,\n   IEASPARM = 'CLPA' then  PRMLINE = '    'IEASPARM\n  Else PRMLINE = '    'IEASPARM'='IPAPRM\nPRMLINE.TOTPRMS = IEASPARM PRMLINE PRMSRC\nPRMLINE.0 = TOTPRMS\nReturn\n\nBUILD_IPAPDETB:      /* Build table for lookup for IPA values        */\nNUM=1\nIPAPDETB.NUM = 'ALLOC   ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'APF     ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'APG     ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'BLDL    ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'BLDLF   ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'CLOCK   ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'CLPA    ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'CMB     ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'CMD     ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'CON     ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'CONT    ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'COUPLE  ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'CPQE    ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'CSA     ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'CSCBLOC ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'CVIO    ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'DEVSUP  ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'DIAG    ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'DUMP    ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'DUPLEX  ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'EXIT    ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'FIX     ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'GRS     ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'GRSCNF  ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'GRSRNL  ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'ICS     ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'IOS     ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'IPS     ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'LNK     ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'LNKAUTH ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'LOGCLS  ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'LOGLMT  ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'LOGREC  ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'LPA     ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'MAXCAD  ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'MAXUSER ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'MLPA    ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'MSTRJCL ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'NONVIO  ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'NSYSLX  ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'NUCMAP  ' ; NUM = NUM + 1\nIf Bitand(CVTOSLV1,'04'x) = '04'x then do    /* OS/390 R3 and above  */\n   IPAPDETB.NUM = 'OMVS    ' ; NUM = NUM + 1\nEnd\nElse do\n   IPAPDETB.NUM = 'RESERVED' ; NUM = NUM + 1\nEnd\nIPAPDETB.NUM = 'OPI     ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'OPT     ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'PAGE-OPR' ; NUM = NUM + 1\nIPAPDETB.NUM = 'PAGE    ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'PAGNUM  ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'PAGTOTL ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'PAK     ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'PLEXCFG ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'PROD    ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'PROG    ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'PURGE   ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'RDE     ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'REAL    ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'RER     ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'RSU     ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'RSVNONR ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'RSVSTRT ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'SCH     ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'SMF     ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'SMS     ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'SQA     ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'SSN     ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'SVC     ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'SWAP    ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'SYSNAME ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'SYSP    ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'VAL     ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'VIODSN  ' ; NUM = NUM + 1\nIPAPDETB.NUM = 'VRREGN  ' ; NUM = NUM + 1\nIf Bitand(CVTOSLV2,'80'x) = '80'x then do    /* OS/390 R4 and above  */\n   IPAPDETB.NUM = 'RTLS    ' ; NUM = NUM + 1\nEnd\nIf Bitand(CVTOSLV2,'04'x) = '04'x then do    /* OS/390 R8 and above  */\n   IPAPDETB.NUM = 'UNI     ' ; NUM = NUM + 1 /* added by APAR OW44581*/\nEnd\nIf Bitand(CVTOSLV3,'20'x) = '20'x then do    /* z/OS 1.1 and above   */\n   IPAPDETB.NUM = 'ILMLIB  ' ; NUM = NUM + 1\n   IPAPDETB.NUM = 'ILMMODE ' ; NUM = NUM + 1\nEnd\nIf Bitand(CVTOSLV3,'08'x) = '08'x then do    /* z/OS 1.3 and above   */\n   IPAPDETB.NUM = 'IKJTSO  ' ; NUM = NUM + 1\n   IPAPDETB.NUM = 'LICENSE ' ; NUM = NUM + 1\nEnd\nIf Bitand(CVTOSLV3,'02'x) = '02'x then do    /* z/OS 1.5 and above   */\n   IPAPDETB.NUM = '<notdef>' ; NUM = NUM + 1 /*\"blank\" def in IHAIPA */\n   IPAPDETB.NUM = 'HVSHARE ' ; NUM = NUM + 1\n   IPAPDETB.NUM = 'ILM     ' ; NUM = NUM + 1\n /********************************************************************/\n /* If you have a z/OS 1.5 or z/OS 1.6 system without OA09649, you   */\n /* may have to delete the next 3 lines of code.                     */\n /********************************************************************/\n   IPAPDETB.NUM = '<notdef>' ; NUM = NUM + 1 /*\"blank\" def in IHAIPA */\n   IPAPDETB.NUM = '<notdef>' ; NUM = NUM + 1 /*\"blank\" def in IHAIPA */\n   IPAPDETB.NUM = 'PRESCPU ' ; NUM = NUM + 1 /* added by OA09649 */\nEnd\nIf Bitand(CVTOSLV5,'40'x) = '40'x then do    /* z/OS 1.7 and above   */\n   NUM = NUM-3\n   IPAPDETB.NUM = 'DRMODE  ' ; NUM = NUM + 1\n   IPAPDETB.NUM = 'CEE     ' ; NUM = NUM + 1\n   IPAPDETB.NUM = 'PRESCPU ' ; NUM = NUM + 1\nEnd\nIf Bitand(CVTOSLV5,'10'x) = '10'x then do    /* z/OS 1.9 and above   */\n   IPAPDETB.NUM = 'LFAREA  ' ; NUM = NUM + 1\nEnd\nIf Bitand(CVTOSLV5,'08'x) = '08'x then do    /* z/OS 1.10 and above  */\n   IPAPDETB.NUM = 'CEA     ' ; NUM = NUM + 1\n   IPAPDETB.NUM = 'HVCOMMON' ; NUM = NUM + 1\n   IPAPDETB.NUM = 'AXR     ' ; NUM = NUM + 1\nEnd\nIf Bitand(CVTOSLV5,'08'x) = '08'x then do    /* z/OS 1.10 and above  */\n /********************************************************************/\n /* If you have z/OS 1.10 without OA27495, you may have to delete    */\n /* the next line of code. If you have z/OS 1.9 with OA27495 and     */\n /* wish to see the \"ZZ\" value, change the check above from:         */\n /*   If Bitand(CVTOSLV5,'08'x) = '08'x then do                      */\n /* to:                                                              */\n /*   If Bitand(CVTOSLV5,'10'x) = '10'x then do                      */\n /********************************************************************/\n   IPAPDETB.NUM = 'ZZ      ' ; NUM = NUM + 1\nEnd\nIf Bitand(CVTOSLV5,'04'x) = '04'x then do    /* z/OS 1.11 and above  */\n   NUM = NUM - 1\n   IPAPDETB.NUM = 'ZAAPZIIP' ; NUM = NUM + 1\n   IPAPDETB.NUM = 'IQP'      ; NUM = NUM + 1\n   IPAPDETB.NUM = 'CPCR'     ; NUM = NUM + 1\n   IPAPDETB.NUM = 'DDM'      ; NUM = NUM + 1\nEnd\nIf Bitand(CVTOSLV5,'02'x) = '02'x then do    /* z/OS 1.12 and above  */\n   IPAPDETB.NUM = 'AUTOR'    ; NUM = NUM + 1\nEnd\nIf Bitand(CVTOSLV5,'01'x) = '01'x then do    /* z/OS 1.13 and above  */\n   IPAPDETB.NUM = 'CATALOG'  ; NUM = NUM + 1\n   IPAPDETB.NUM = 'IXGCNF'   ; NUM = NUM + 1\nEnd\nIf Bitand(CVTOSLV6,'80'x) = '80'x then do    /* z/OS 2.1  and above  */\n   IPAPDETB.NUM = 'PAGESCM'  ; NUM = NUM + 1\n   IPAPDETB.NUM = 'WARNUND'  ; NUM = NUM + 1\n   IPAPDETB.NUM = 'HZS'      ; NUM = NUM + 1\n   IPAPDETB.NUM = 'GTZ'      ; NUM = NUM + 1\n   IPAPDETB.NUM = 'HZSPROC'  ; NUM = NUM + 1\nEnd\nIf Bitand(CVTOSLV6,'40'x) = '40'x then do    /* z/OS 2.2  and above  */\n   IPAPDETB.NUM = 'SMFLIM'   ; NUM = NUM + 1\n   IPAPDETB.NUM = 'IEFOPZ'   ; NUM = NUM + 1\nEnd\nIf Bitand(CVTOSLV6,'10'x) = '10'x then do    /* z/OS 2.3  and above  */\n   IPAPDETB.NUM = 'RACF'     ; NUM = NUM + 1\n   IPAPDETB.NUM = 'FXE'      ; NUM = NUM + 1\n   IPAPDETB.NUM = 'IZU'      ; NUM = NUM + 1\n   IPAPDETB.NUM = 'SMFTBUFF' ; NUM = NUM + 1  /* APAR OA52828 */\n   IPAPDETB.NUM = 'DIAG1'    ; NUM = NUM + 1  /* IBM use only */\n   IPAPDETB.NUM = 'OSPROTECT'; NUM = NUM + 1  /* APAR OA54807 */\n   IPAPDETB.NUM = 'ICSF'     ; NUM = NUM + 1  /* APAR OA55378 */\n   IPAPDETB.NUM = 'ICSFPROC' ; NUM = NUM + 1  /* APAR OA55378 */\nEnd\n       /* RUCSA and BOOST on z/OS 2.3 with APARs OA56180 and OA57849 */\nIf Bitand(CVTOSLV6,'08'x) = '08'x then do    /* z/OS 2.4  and above  */\n   IPAPDETB.NUM = 'RUCSA'    ; NUM = NUM + 1\n   IPAPDETB.NUM = 'BOOST'    ; NUM = NUM + 1\nEnd\nIPAPDETB.0 = NUM-1\nReturn\n\nSPLIT_IPA_PAGE: /* Split up page data set parms to multiple lines */\nTOT_IPALINES = 0\nDo SPLIT = 1 to PRMLINE.0\n   TOT_IPALINES = TOT_IPALINES+1    /* add one total lines    */\n   IPA_PDE = Word(PRMLINE.SPLIT,1)  /* keyword                */\n   IPA_PRM = Word(PRMLINE.SPLIT,2)  /* value                  */\n   IPA_SRC = Word(PRMLINE.SPLIT,3)  /* IEASYSxx, dlft, or OPR */\n   IPA_LEN = Length(IPA_PRM)\n  If IPA_PDE = 'NONVIO' | IPA_PDE = 'PAGE' | ,\n     IPA_PDE = 'PAGE-OPR' | IPA_PDE = 'SWAP' then do\n    MORE  = 'YES' /* init flag for more subparms */\n    FIRST = 'YES' /* init flag for first subparm */\n    SPLITPOS = 1\n    Do until MORE = 'NO'\n      SPLITPOS = Pos(',',IPA_PRM)\n      If SPLITPOS = 0 then do\n        If FIRST = 'YES' then do\n          IPALINE.TOT_IPALINES = '    'IPA_PRM || ','\n          IPALINE.TOT_IPALINES = ,\n            Overlay(IPA_SRC,IPALINE.TOT_IPALINES,68)\n        End\n        Else do\n          MBLNK = ''\n          If IPA_PDE = 'NONVIO' then MBLNK = '  '     /* align   */\n          If IPA_PDE = 'PAGE-OPR' then MBLNK = '    ' /* align   */\n          IPALINE.TOT_IPALINES = MBLNK'          'IPA_PRM || ','\n          IPALINE.TOT_IPALINES = ,\n            Overlay(IPA_SRC,IPALINE.TOT_IPALINES,68)\n        End\n        MORE = 'NO'  /* no more subparms */\n      End /* if SPLITPOS = 0 */\n      Else do\n        IPAPRM_SPLIT = Substr(IPA_PRM,1,SPLITPOS)\n        If FIRST = 'YES' then IPALINE.TOT_IPALINES = '    'IPAPRM_SPLIT\n          Else do\n            MBLNK = ''\n            If IPA_PDE = 'NONVIO' then MBLNK = '  '     /* align   */\n            If IPA_PDE = 'PAGE-OPR' then MBLNK = '    ' /* align   */\n            IPALINE.TOT_IPALINES = MBLNK'          'IPAPRM_SPLIT\n          End\n        IPA_PRM  = Substr(IPA_PRM,SPLITPOS+1,IPA_LEN-SPLITPOS)\n        IPA_LEN =  Length(IPA_PRM)\n        TOT_IPALINES = TOT_IPALINES+1  /* add one total lines */\n        FIRST = 'NO'\n      End\n    End  /* do until more=no */\n  End\n  Else do\n    IPALINE.TOT_IPALINES = '    'IPA_PRM || ','\n    IPALINE.TOT_IPALINES = Overlay(IPA_SRC,IPALINE.TOT_IPALINES,68)\n  End\nEnd\nReturn\n\nSORT_IPA: Procedure expose PRMLINE.\n/* bubble sort the IPA list */\nSORT_DONE = 0\nSORT_RECS = PRMLINE.0\nDo while SORT_DONE = 0\n  SORT_DONE = 1\n  Do I = 1 to SORT_RECS - 1\n    J = I + 1\n    If PRMLINE.I > PRMLINE.J then do\n      SORT_DONE = 0\n      TEMP_SORT = PRMLINE.J\n      PRMLINE.J = PRMLINE.I\n      PRMLINE.I = TEMP_SORT\n    End /* if */\n  End /* do i=1 to sort_recs */\n  SORT_RECS = SORT_RECS - 1\nEnd /* do while */\nReturn\n\nGET_CPCSI:\nSI_OFF=0\nIRALCCT = C2d(Storage(D2x(RMCT+620),4))         /* point to IRALCCT  */\n                                                /*  (undocumented)   */\nIf Bitand(CVTOSLV5,'08'x) = '08'x then , /* z/OS 1.10 and above      */\n  SI_OFF = 128      /* additional offset to CPC SI info in IRALCCT   */\n /****************************************************************/\n /* If you have z/OS 1.12 or z/OS 1.13 with z13 support          */\n /* maintenance applied you will have to uncomment either the    */\n /* first 2 lines or the 2nd 2 lines to fix the CPCSI display.   */\n /* The 2nd set should work for z/OS 1.12 or z/OS 1.13 systems   */\n /* that do have the maintenance and also for those systems that */\n /* do not have the maintenance.                                 */\n /****************************************************************/\n/*If Bitand(CVTOSLV5,'02'x) = '02'x then , */   /* z/OS 1.12 and >   */\n/*  SI_OFF = 384 */   /* additional offset to CPC SI info in IRALCCT */\n/*If C2x(Storage(D2x(IRALCCT+10),1)) <> '40' then , *//* z13 support */\n/*  SI_OFF = 384 */   /* additional offset to CPC SI info in IRALCCT */\nIf Bitand(CVTOSLV6,'80'x) = '80'x then , /* z/OS 2.1  and above      */\n  SI_OFF = 384      /* additional offset to CPC SI info in IRALCCT   */\n /****************************************************************/\n /* The check below was added for a reported problem on          */\n /* z/OS 2.3 at RSU1812 or RSU1903.  I'm not sure what APAR(s)   */\n /* broke this or if the same APAR could apply to earlier z/OS   */\n /* versions.                                                    */\n /*                                                              */\n /* If the CPU node display doesn't look right, delete the code  */\n /* that changes the offset to 392 or comment it out.            */\n /****************************************************************/\nIf Bitand(CVTOSLV6,'10'x) = '10'x then       /* z/OS 2.3  and above  */\n  /* (MODEL='3906' | MODEL='3907') | */      /* z/OS 2.3 + z14       */\n  /* (MODEL='2964' | MODEL='2965') then */   /* z/OS 2.3 + z13       */\n  SI_OFF = 392      /* additional offset to CPC SI info in IRALCCT   */\nCPCSI_TYPE  = Storage(D2x(IRALCCT+332+SI_OFF),4)    /* Type          */\nCPCSI_MODEL = Storage(D2x(IRALCCT+336+SI_OFF),4)    /* Model         */\nCPCSI_MODEL = Strip(CPCSI_MODEL)                    /* Remove blanks */\nCPCSI_MAN   = Storage(D2x(IRALCCT+384+SI_OFF),16)   /* Manufacturer  */\nCPCSI_MAN   = Strip(CPCSI_MAN)                      /* Remove blanks */\nCPCSI_PLANT = Storage(D2x(IRALCCT+400+SI_OFF),4)    /* Plant         */\nCPCSI_PLANT = Strip(CPCSI_PLANT)                    /* Remove blanks */\nCPCSI_CPUID = Storage(D2x(IRALCCT+352+SI_OFF),16)   /* CPUID         */\nCPCSI_MODELID = Storage(D2x(IRALCCT+592+SI_OFF),4)  /* Model ID      */\nCPCSI_MODELID = Strip(CPCSI_MODELID)                /* Remove blanks */\n /*   CPCSI_MODELID may not be valid on emulated    */\n /*   z/OS systems like FLEX, HERC and z/PDT        */\nReturn\n\nFORMAT_MEMSIZE:\n/****************************************************************/\n/* The following code is used to display the storage size in    */\n/* the largest possible unit.  For example, 1023G and 1025G are */\n/* displayed as 1023G and 1025G, but 1024G is displayed as 1T.  */\n/* The size passed to the routine must be in MB.                */\n/****************************************************************/\nArg SIZE_IN_MB\nSelect\n   When SIZE_IN_MB < 1024 then do\n     MUNITS = 'M'\n   End\n   When SIZE_IN_MB >= 1024 & SIZE_IN_MB < 1048576 then do\n     If SIZE_IN_MB/1024 == TRUNC(SIZE_IN_MB/1024) then do\n       SIZE_IN_MB = SIZE_IN_MB/1024\n       MUNITS = 'G'\n     End\n     Else MUNITS = 'M'\n   End\n   When SIZE_IN_MB >= 1048576 & SIZE_IN_MB < 1073741824 then do\n     If SIZE_IN_MB/1048576 == TRUNC(SIZE_IN_MB/1048576) then do\n       SIZE_IN_MB = SIZE_IN_MB/1048576\n       MUNITS = 'T'\n     End\n     Else do\n       If SIZE_IN_MB/1024 == TRUNC(SIZE_IN_MB/1024) then do\n         SIZE_IN_MB = SIZE_IN_MB/1024\n         MUNITS = 'G'\n       End\n       Else MUNITS = 'M'\n     End\n   End\n   When SIZE_IN_MB >= 1073741824 & ,\n        SIZE_IN_MB <= 17591112302592 then do\n     If SIZE_IN_MB/1073741824 == TRUNC(SIZE_IN_MB/1073741824) ,\n        then do\n       SIZE_IN_MB = SIZE_IN_MB/1073741824\n       MUNITS = 'P'\n     End\n     Else do\n       SIZE_IN_MB = SIZE_IN_MB/1048576\n       MUNITS = 'T'\n     End\n   End\n   When SIZE_IN_MB = 17592186040320 then do\n       SIZE_IN_MB = 'NOLIMIT'   /* 16384P */\n       MUNITS = ''\n   End\n   When SIZE_IN_MB > 17592186040320 then do\n       SIZE_IN_MB = '*NOLIMT'   /* >16384P  (16EB) ?? */\n       MUNITS = ''\n   End\n   Otherwise do\n     Queue ' '\n     Queue 'Error in FORMAT_MEMSIZE code. Contact Mark Zelden.'\n     Queue 'SIZE_IN_MB=' SIZE_IN_MB\n     Queue ' '\n     SIZE_IN_MB = '*ERROR*'\n     MUNITS = ''\n   End\nEnd /* select */\nSTOR_SIZE =  SIZE_IN_MB || MUNITS\nReturn STOR_SIZE\n\nBROWSE_ISPF:         /* Browse output if ISPF is active              */\nAddress ISPEXEC \"CONTROL ERRORS RETURN\"\nAddress TSO\nprefix = sysvar('SYSPREF')        /* tso profile prefix              */\nuid    = sysvar('SYSUID')         /* tso userid                      */\nIf prefix = '' then prefix = uid  /* use uid if null prefix          */\nIf prefix <> '' & prefix <> uid then /* different prefix than uid    */\n   prefix = prefix || '.' || uid  /* use  prefix.uid                 */\nddnm1 = 'DDO'||random(1,99999)    /* choose random ddname            */\nddnm2 = 'DDP'||random(1,99999)    /* choose random ddname            */\njunk = MSG('OFF')\n\"ALLOC FILE(\"||ddnm1||\") UNIT(SYSALLDA) NEW TRACKS SPACE(2,1) DELETE\",\n      \" REUSE LRECL(80) RECFM(F B) BLKSIZE(3120)\"\n\"ALLOC FILE(\"||ddnm2||\") UNIT(SYSALLDA) NEW TRACKS SPACE(1,1) DELETE\",\n      \" REUSE LRECL(80) RECFM(F B) BLKSIZE(3120) DIR(1)\"\njunk = MSG('ON')\n\"Newstack\"\n/*************************/\n/* IPLINFOP Panel source */\n/*************************/\nIf Substr(ZENVIR,6,1) >= 4 then\n  If EDITOP = 'YES' then ,\n    Queue \")PANEL KEYLIST(ISRSPEC,ISR)\"\n  Else ,\n    Queue \")PANEL KEYLIST(ISRSPBC,ISR)\"\nQueue \")ATTR\"\nQueue \"  _ TYPE(INPUT)   INTENS(HIGH) COLOR(TURQ) CAPS(OFF)\" ,\n      \"FORMAT(&MIXED)\"\nIf EDITOP = 'YES' then ,\n  Queue \"  | AREA(DYNAMIC) EXTEND(ON)   SCROLL(ON) USERMOD('20')\"\nElse ,\n  Queue \"  | AREA(DYNAMIC) EXTEND(ON)   SCROLL(ON)\"\nQueue \"  + TYPE(TEXT)    INTENS(LOW)  COLOR(BLUE)\"\nQueue \"  @ TYPE(TEXT)    INTENS(LOW)  COLOR(TURQ)\"\nQueue \"  % TYPE(TEXT)    INTENS(HIGH) COLOR(GREEN)\"\nQueue \"  ! TYPE(OUTPUT)  INTENS(HIGH) COLOR(TURQ) PAD(-)\"\nQueue \" 01 TYPE(DATAOUT) INTENS(LOW)\"\nQueue \" 02 TYPE(DATAOUT) INTENS(HIGH)\"\nIf EDITOP = 'YES' then do\n  Queue \" 03 TYPE(DATAOUT) SKIP(ON) /* FOR TEXT ENTER CMD. FIELD */\"\n  Queue \" 04 TYPE(DATAIN)  INTENS(LOW)  CAPS(OFF) FORMAT(&MIXED)\"\n  Queue \" 05 TYPE(DATAIN)  INTENS(HIGH) CAPS(OFF) FORMAT(&MIXED)\"\n  Queue \" 06 TYPE(DATAIN)  INTENS(LOW)  CAPS(IN)  FORMAT(&MIXED)\"\n  Queue \" 07 TYPE(DATAIN)  INTENS(HIGH) CAPS(IN)  FORMAT(&MIXED)\"\n  Queue \" 08 TYPE(DATAIN)  INTENS(LOW)  FORMAT(DBCS) OUTLINE(L)\"\n  Queue \" 09 TYPE(DATAIN)  INTENS(LOW)  FORMAT(EBCDIC) OUTLINE(L)\"\n  Queue \" 0A TYPE(DATAIN)  INTENS(LOW)  FORMAT(&MIXED) OUTLINE(L)\"\n  Queue \" 0D TYPE(DATAIN)  INTENS(LOW)  CAPS(IN)  FORMAT(&MIXED)\" || ,\n        \" COLOR(BLUE)\"\n  Queue \" 20 TYPE(DATAIN)  INTENS(LOW) CAPS(IN) FORMAT(&MIXED)\"\nEnd\nElse do\n  Queue \" 0B TYPE(DATAOUT) INTENS(HIGH) FORMAT(DBCS)\"\n  Queue \" 0C TYPE(DATAOUT) INTENS(HIGH) FORMAT(EBCDIC)\"\n  Queue \" 0D TYPE(DATAOUT) INTENS(HIGH) FORMAT(&MIXED)\"\n  Queue \" 10 TYPE(DATAOUT) INTENS(LOW)  FORMAT(DBCS)\"\n  Queue \" 11 TYPE(DATAOUT) INTENS(LOW)  FORMAT(EBCDIC)\"\n  Queue \" 12 TYPE(DATAOUT) INTENS(LOW)  FORMAT(&MIXED)\"\nEnd\nIf EDITOP = 'YES' then do\n  Queue \")BODY WIDTH(&ZWIDTH) EXPAND(//)\"\n  Queue \"@EDIT @&ZTITLE  / /  %Columns!ZCL  !ZCR  +\"\nEnd\nElse do\n  Queue \")BODY EXPAND(//)\"\n  Queue \"%BROWSE  @&ZTITLE  / /  %Line!ZLINES  %Col!ZCOLUMS+\"\nEnd\nQueue \"%Command ===>_ZCMD / /           %Scroll ===>_Z   +\"\nQueue \"|ZDATA ---------------/ /-------------------------|\"\nQueue \"|                     / /                         |\"\nQueue \"| --------------------/-/-------------------------|\"\nQueue \")INIT\"\nQueue \"  .HELP = IPLINFOH\"\nIf EDITOP = 'YES' then ,\n  Queue \"  .ZVARS = 'ZSCED'\"\nElse ,\n  Queue \"  .ZVARS = 'ZSCBR'\"\nQueue \"  &ZTITLE = 'Mark''s MVS Utilities - IPLINFO'\"\nQueue \"  &MIXED = MIX\"\nQueue \"  IF (&ZPDMIX = N)\"\nQueue \"   &MIXED = EBCDIC\"\nIf EDITOP = 'YES' then do\n  Queue \"  VGET (ZSCED) PROFILE\"\n  Queue \"  IF (&ZSCED = ' ')\"\n  Queue \"   &ZSCED = 'CSR'\"\nEnd\nElse do\n  Queue \"  VGET (ZSCBR) PROFILE\"\n  Queue \"  IF (&ZSCBR = ' ')\"\n  Queue \"   &ZSCBR = 'CSR'\"\nEnd\nQueue \")REINIT\"\nQueue \"  .HELP = IPLINFOH\"\nIf EDITOP = 'YES' then ,\n  Queue \"  REFRESH(ZCMD,ZSCED,ZDATA,ZCL,ZCR)\"\nElse ,\n  Queue \"  REFRESH(ZCMD,ZSCBR,ZDATA,ZLINES,ZCOLUMS)\"\nQueue \")PROC\"\nQueue \"  &ZCURSOR = .CURSOR\"\nQueue \"  &ZCSROFF = .CSRPOS\"\nQueue \"  &ZLVLINE = LVLINE(ZDATA)\"\nIf EDITOP = 'YES' then ,\n  Queue \"  VPUT (ZSCED) PROFILE\"\nElse ,\n  Queue \"  VPUT (ZSCBR) PROFILE\"\nQueue \")END\"\n/*                                    */\nAddress ISPEXEC \"LMINIT DATAID(PAN) DDNAME(\"ddnm2\")\"\nAddress ISPEXEC \"LMOPEN DATAID(\"pan\") OPTION(OUTPUT)\"\nDo queued()\n   Parse pull panline\n   Address ISPEXEC \"LMPUT DATAID(\"pan\") MODE(INVAR)\" ,\n           \"DATALOC(PANLINE) DATALEN(80)\"\nEnd\nAddress ISPEXEC \"LMMADD DATAID(\"pan\") MEMBER(IPLINFOP)\"\n/* Address ISPEXEC \"LMFREE DATAID(\"pan\")\" */\n\"Delstack\"\n\"Newstack\"\n/*************************/\n/* IPLINFOH Panel source */\n/*************************/\nIf Substr(ZENVIR,6,1) >= 4 then\n  Queue \")PANEL KEYLIST(ISRSPBC,ISR)\"\nQueue \")ATTR DEFAULT(!+_)\"\nQueue \"  _ TYPE(INPUT)   INTENS(HIGH) COLOR(TURQ) CAPS(OFF)\" ,\n      \"FORMAT(&MIXED)\"\nQueue \"  + TYPE(TEXT)    INTENS(LOW)  COLOR(BLUE)\"\nQueue \"  @ TYPE(TEXT)    INTENS(LOW)  COLOR(TURQ)\"\nQueue \"  ! TYPE(TEXT)    INTENS(HIGH) COLOR(GREEN)\"\nQueue \"  # AREA(SCRL)    EXTEND(ON)\"\nQueue \")BODY EXPAND(//)\"\nQueue \"!HELP    @&ZTITLE  / / \"\nQueue \"!Command ===>_ZCMD / / \"\nQueue \"#IPLHSCR                                          \"  || ,\n      \"                            #\"\nQueue \")AREA IPLHSCR\"\nQueue \"@EXECUTION SYNTAX:!TSO %IPLINFO <option>                       \"\nQueue \"+VALID OPTIONS ARE 'ALL', 'IPL', 'VERsion',\" ||,\n      \" 'STOrage', 'CPU', 'IPA', 'SYMbols',\"\nQueue \"+ 'VMAp', 'PAGe', 'SMF', \" ||,\n      \"'SUB', 'ASId', 'LPA', 'LNKlst', 'APF' and 'SVC'\"\nQueue \"@**+OPTIONS may be abbreviated by using 3 or more characters   \"\nQueue \"+Examples:                                                     \"\nQueue \"! TSO %IPLINFO        +(Display all Information)               \"\nQueue \"! TSO %IPLINFO IPL    +(Display IPL Information)               \"\nQueue \"! TSO %IPLINFO VER    +(Display Version Information)           \"\nQueue \"! TSO %IPLINFO STOR   +(Display Storage Information)           \"\nQueue \"! TSO %IPLINFO CPU    +(Display CPU Information)               \"\nQueue \"! TSO %IPLINFO IPA    +(Display Initialization Information)    \"\nQueue \"! TSO %IPLINFO SYM    +(Display Static System Symbols)         \"\nQueue \"! TSO %IPLINFO VMAP   +(Display a Virtual Storage Map)         \"\nQueue \"! TSO %IPLINFO PAGE   +(Display Page Data Set Usage\",\n                              \"Information)\"\nQueue \"! TSO %IPLINFO SMF    +(Display SMF Data Set Usage Information)\"\nQueue \"! TSO %IPLINFO SUB    +(Display Subsystem Information)         \"\nQueue \"! TSO %IPLINFO ASID   +(Display ASID Usage Information)        \"\nQueue \"! TSO %IPLINFO LPA    +(Display LPA List Information)          \"\nQueue \"! TSO %IPLINFO LNK    +(Display LNKLST Information)            \"\nQueue \"! TSO %IPLINFO APF    +(Display APF List Information)          \"\nQueue \"! TSO %IPLINFO SVC    +(Display SVC Information)               \"\nQueue \"@&ADLINE\"\nQueue \")INIT\"\nQueue \"  .HELP = ISR10000\"\nQueue \"  &ZTITLE = 'Mark''s MVS Utilities - IPLINFO'\"\nQueue \"  &L1 = 'Mark''s MVS Utilities -'\"\nQueue \"  &L2 = 'http://www.mzelden.com/mvsutil.html'\"\nQueue \"  &ADLINE  = '&L1 &L2'\"\nQueue \"  &MIXED = MIX\"\nQueue \"  IF (&ZPDMIX = N)\"\nQueue \"   &MIXED = EBCDIC\"\nQueue \")END\"\n/*                                    */\nDo queued()\n   Parse pull panline\n   Address ISPEXEC \"LMPUT DATAID(\"pan\") MODE(INVAR)\" ,\n           \"DATALOC(PANLINE) DATALEN(80)\"\nEnd\nAddress ISPEXEC \"LMMADD DATAID(\"pan\") MEMBER(IPLINFOH)\"\nAddress ISPEXEC \"LMFREE DATAID(\"pan\")\"\n\"Delstack\"\n\"EXECIO\" Queued() \"DISKW\" ddnm1 \"(FINIS\"\nzerrsm  = 'IPLINFO' LASTUPD\nzerrlm  = 'IPLINFO -' OPTION 'option.' ,\n          'Last updated on' LASTUPD ||'. Written by' ,\n          'Mark Zelden. Mark''s MVS Utilities -' ,\n          'http://www.mzelden.com/mvsutil.html'\nzerralrm = 'NO'        /* msg - no alarm */\nzerrhm   = 'IPLINFOH'  /* help panel */\naddress ISPEXEC \"LIBDEF ISPPLIB LIBRARY ID(\"||ddnm2||\") STACK\"\naddress ISPEXEC \"SETMSG MSG(ISRZ002)\"\naddress ISPEXEC \"LMINIT DATAID(TEMP) DDNAME(\"||ddnm1||\")\"\nIf EDITOP = 'YES' then ,\n  address ISPEXEC \"EDIT DATAID(\"||temp\") PANEL(IPLINFOP)\"\nElse ,\n  address ISPEXEC \"BROWSE DATAID(\"||temp\") PANEL(IPLINFOP)\"\naddress ISPEXEC \"LMFREE DATAID(\"||temp\")\"\naddress ISPEXEC \"LIBDEF ISPPLIB\"\njunk = MSG('OFF')\n\"FREE FI(\"||ddnm1||\")\"\n\"FREE FI(\"||ddnm2||\")\"\nReturn\n\nREXXTOD:\n/* REXX */\n/*                                       */\n/* AUTHOR: Mark Zelden                   */\n/*                                       */\n/***********************************************************/\n/* Convert TOD string which is units since January 1, 1990 */\n/* Result is in format of YYYY.DDD HH:MM:SS.ttt            */\n/*                                                         */\n/* Examples:                                               */\n/*   REXXTOD B92E37543F000000  -->  2003.086 05:06:06.435  */\n/*   REXXTOD C653258535522000  -->  2010.205 13:23:45.154  */\n/*   REXXTOD C8B8D8A516A77000  -->  2011.328 16:09:07.768  */\n/***********************************************************/\nArg TODIN\n /* Numeric Digits 16 */    /* commented out, IPLINFO already higher */\nTODIN  = Left(TODIN,13,0)   /* rtn can only handle 1000s of a second */\nTODIN  = X2d(TODIN)         /* convert to decimal for arithmetic     */\nTODIN  = TODIN %  1000\n  TTT  = TODIN // 1000      /* 1000s of a second  - \".ttt\"           */\nTODIN  = TODIN %  1000\n  SS   = TODIN // 60;       /* Seconds - \"SS\"                        */\nTODIN  = TODIN %  60\n  MM   = TODIN // 60;       /* Minutes - \"MM\"                        */\nTODIN  = TODIN %  60\n  HH   = TODIN // 24;       /* Hours   - \"HH\"                        */\nTODIN  = TODIN %  24\n\nTODIN = TODIN + 1           /* add 1 to remainder, needed for next   */\n                            /* section of code taken from \"RDATE\"    */\n\n/* Determine YYYY and DDD */\nif TODIN>365 then TODIN=TODIN+1\nYEARS_X4=(TODIN-1)%1461\nDDD=TODIN-YEARS_X4*1461\nif TODIN > 73415 then DDD = DDD +1\nEXTRA_YEARS=(DDD*3-3)%1096\nDDD=DDD-(EXTRA_YEARS*1096+2)%3\nYYYY=YEARS_X4*4+EXTRA_YEARS+1900\n\n/* Format prior to result */\nDDD     = Right(DDD,3,'0')\nHH      = Right(HH,2,'0')\nMM      = Right(MM,2,'0')\nSS      = Right(SS,2,'0')\nTTT     = Right(TTT,3,'0')\n\nTOD_VAL = YYYY'.'DDD  HH':'MM':'SS'.'TTT\n /* Say TOD_VAL; Exit 0 */\nReturn TOD_VAL\n\n\nFORMAT_COMMAS:\n/* REXX  - Format whole number with commas */\n/*                                         */\n/* AUTHOR: Mark Zelden                     */\n/*                                         */\nArg WHOLENUM\n\nWHOLENUM  = Strip(WHOLENUM)\nCOMMAVAR3 = ''\nParse var WHOLENUM COMMAVAR1\nCOMMAVAR1 = Reverse(COMMAVAR1)\nDo while COMMAVAR1 <> ''\n  Parse var COMMAVAR1 COMMAVAR2 4 COMMAVAR1\n  If COMMAVAR3 = '' then COMMAVAR3 = COMMAVAR2\n  Else COMMAVAR3 = COMMAVAR3','COMMAVAR2\nEnd\nFORMATTED_WHOLENUM = Reverse(COMMAVAR3)\nReturn FORMATTED_WHOLENUM\n\n\n/* rexx */\nRDATE:\n/*                                       */\n/* AUTHOR: Mark Zelden                   */\n/*                                       */\n/************************************************/\n/* Convert MM DD YYYY , YYYY DDD, or NNNNN to   */\n/* standard date output that includes the day   */\n/* of the week and the number of days (NNNNN)   */\n/* from January 1, 1900. This is not the same   */\n/* as the Century date! Valid input dates range */\n/* from 01/01/1900 through 12/31/2172.          */\n/*                                              */\n/* A parm of \"TODAY\" can also be passed to      */\n/* the date conversion routine.                 */\n/* MM DD YYYY can also be specifed as           */\n/* MM/DD/YYYY or MM-DD-YYYY.                    */\n/*                                              */\n/* The output format is always as follows:      */\n/*      MM/DD/YYYY.JJJ NNNNN WEEKDAY            */\n/*                                              */\n/* The above value will be put in the special   */\n/* REXX variable \"RESULT\"                       */\n/* example: CALL RDATE TODAY                    */\n/* example: CALL RDATE 1996 300                 */\n/* example: CALL RDATE 10 26 1996               */\n/* example: CALL RDATE 10/26/1996               */\n/* example: CALL RDATE 10-26-1996               */\n/* example: CALL RDATE 35363                    */\n/* result:  10/26/1996.300 35363 Saturday       */\n/************************************************/\narg P1 P2 P3\n\nIf Pos('/',P1) <> 0 | Pos('-',P1) <> 0 then do\n  PX =  Translate(P1,'  ','/-')\n  Parse var PX P1 P2 P3\nEnd\n\nJULTBL = '000031059090120151181212243273304334'\nDAY.0 = 'Sunday'\nDAY.1 = 'Monday'\nDAY.2 = 'Tuesday'\nDAY.3 = 'Wednesday'\nDAY.4 = 'Thursday'\nDAY.5 = 'Friday'\nDAY.6 = 'Saturday'\n\nSelect\n  When P1 = 'TODAY' then do\n    P1 = Substr(date('s'),5,2)\n    P2 = Substr(date('s'),7,2)\n    P3 = Substr(date('s'),1,4)\n    call CONVERT_MDY\n    call THE_END\n  end\n  When P2 = '' & P3 = '' then do\n    call CONVERT_NNNNN\n    call THE_END\n  end\n  When P3 = '' then do\n    call CONVERT_JDATE\n    call DOUBLE_CHECK\n    call THE_END\n  end\n  otherwise do\n    call CONVERT_MDY\n    call DOUBLE_CHECK\n    call THE_END\n  end\nend /* end select */\n/* say RDATE_VAL; exit 0 */\nreturn RDATE_VAL\n/**********************************************/\n/*  E N D    O F   M A I N L I N E   C O D E  */\n/**********************************************/\n\nCONVERT_MDY:\nif P1<1 | P1>12 then do\n  say 'Invalid month passed to date routine'\n  exit 12\nend\nif P2<1 | P2>31 then do\n  say 'Invalid day passed to date routine'\n  exit 12\nend\nif (P1=4 | P1=6 | P1=9 | P1=11) & P2>30 then do\n  say 'Invalid day passed to date routine'\n  exit 12\nend\nif P3<1900 | P3>2172 then do\n  say 'Invalid year passed to date routine. Must be be 1900-2172'\n  exit 12\nend\nBASE   = Substr(JULTBL,((P1-1)*3)+1,3)\nif (P3//4=0 & P3<>1900 & P3<>2100) then LEAP= 1\n  else LEAP = 0\nif P1 > 2 then BASE = BASE+LEAP\nJJJ = BASE + P2\n\nMM   = P1\nDD   = P2\nYYYY = P3\nreturn\n\nCONVERT_NNNNN:\nif P1<1 | P1>99712 then do\n  say 'Invalid date passed to date routine. NNNNN must be 1-99712'\n  exit 12\nend\n/* Determine YYYY and JJJ */\nif P1>365 then P1=P1+1\nYEARS_X4=(P1-1)%1461\nJJJ=P1-YEARS_X4*1461\nif P1 > 73415 then JJJ = JJJ +1\nEXTRA_YEARS=(JJJ*3-3)%1096\nJJJ=JJJ-(EXTRA_YEARS*1096+2)%3\nYYYY=YEARS_X4*4+EXTRA_YEARS+1900\nP1 = YYYY ; P2 = JJJ ;  call CONVERT_JDATE\n\nCONVERT_JDATE:\nMATCH = 'N'\nif P1<1900 | P1>2172 then do\n  say 'Invalid year passed to date routine. Must be be 1900-2172'\n  exit 12\nend\nif P2<1 | P2>366 then do\n  say 'Invalid Julian date passed to date routine'\n  exit 12\nend\nif (P1//4=0 & P1<>1900 & P1<>2100) then LEAP= 1\n  else LEAP = 0\nADJ1 = 0\nADJ2 = 0\nDo MM = 1 to 11\n   VAL1 = Substr(JULTBL,((MM-1)*3)+1,3)\n   VAL2 = Substr(JULTBL,((MM-1)*3)+4,3)\n   if MM >=2 then ADJ2 = LEAP\n   if MM >=3 then ADJ1 = LEAP\n   if P2 > VAL1+ADJ1 & P2 <= VAL2+ADJ2 then do\n        DD = P2-VAL1-ADJ1\n        MATCH = 'Y'\n        leave\n   end\nend\nif MATCH <> 'Y' then do\n    MM = 12\n    DD = P2-334-LEAP\nend\n\nYYYY = P1\nJJJ  = P2\nreturn\n\nDOUBLE_CHECK:\nif MM = 2 then do\n   if DD > 28 & LEAP = 0 then do\n     say 'Invalid day passed to date routine'\n     exit 12\n   end\n   if DD > 29 & LEAP = 1 then do\n     say 'Invalid day passed to date routine'\n     exit 12\n   end\nend\nif LEAP = 0 & JJJ > 365 then do\n  say 'Invalid Julian date passed to date routine'\n  exit 12\nend\nreturn\n\nTHE_END:\nYR_1900 = YYYY-1900\nNNNNN = (YR_1900*365) +(YR_1900+3)%4 + JJJ\nif YYYY > 1900 then NNNNN = NNNNN-1\nif YYYY > 2100 then NNNNN = NNNNN-1\nINDEX   = NNNNN//7  /* index to DAY stem */\nWEEKDAY =  DAY.INDEX\n\nDD      = Right(DD,2,'0')\nMM      = Right(MM,2,'0')\nYYYY    = Strip(YYYY)\nNNNNN   = Right(NNNNN,5,'0')\nJJJ     = Right(JJJ,3,'0')\n\nRDATE_VAL = MM||'/'||DD||'/'||YYYY||'.'||JJJ||' '||NNNNN||' '||WEEKDAY\nreturn\n\nSIG_ALL:\nSIGTYPE = Condition('C')                   /* condition name         */\nIf SIGTYPE   = 'SYNTAX' then ,             /* SYNTAX error ?         */\n  SIGINFO    = Errortext(RC)               /* rexx error message     */\nElse SIGINFO = Condition('D')              /* condition description  */\nSIGLINE      = Strip(Sourceline(SIGL))     /* error source code      */\nSay 'SIGNAL -' SIGTYPE 'ERROR:' SIGINFO ,  /* display the error info */\n    'on source line number' SIGL':'        /*   and line number      */\nSay '\"'SIGLINE'\"'                          /* error source code      */\n\"Delstack\"                                 /* delete data stack      */\nExit 16                                    /* exit RC=16             */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISPCMDSA": {"ttr": 5380, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x13\\x0f\\x01\\x07\\x11\\x7f\\x11\\x00\\x01/\\x00\\x1d\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-05-10T00:00:00", "modifydate": "2007-04-27T11:00:00", "lines": 303, "newlines": 29, "modlines": 0, "user": "CBT474"}, "text": "PROC 0 TABLE(ISPCMDS)\n/*                                       */\n/* AUTHOR: MARK ZELDEN                   */\n/*                                       */\n/*****************************************/\n/* UPDATED ON 03/20/2007                 */\n/*  TO ADD \"SET &SEL = &Z\"               */\n/*  JUST BEFORE THE TBDISPL AT THE END   */\n/*  I'M NOT SURE WHEN IT BROKE.          */\n/*****************************************/\n/* LAST UPDATED ON 04/27/2007            */\n/*****************************************/\n/*                                                                  */\n/*  ADD TEMPORARY COMMANDS TO THE ISPF COMMAND TABLE                */\n/*                                                                  */\nCONTROL MAIN NOCAPS\nISPEXEC CONTROL ERRORS RETURN\nISPEXEC TBBOTTOM &TABLE\n/********************************************************************/\n/*   MY COMMANDS AND EDIT MACROS                                    */\n/********************************************************************/\n/*                                                                  */\n/*   ADD AMBLIST (AMB) COMMAND                                      */\n/*                                                                  */\nSET &ZCTVERB = AMBLIST                                   /* COMMAND */\nSET &ZCTTRUNC = 3                                        /* MIN LEN */\nSET &ZCTACT = &STR(SELECT CMD(%AMBCLIST))                /* ACTION  */\nSET &ZCTDESC = &STR(INVOKE INTERACTIVE AMBLIST)          /* DESC.   */\nISPEXEC TBADD &TABLE\n/*                                                                  */\n/*   ADD XEFMENU (XEF) COMMAND                                      */\n/*                                                                  */\nSET &ZCTVERB = XEFMENU                                   /* COMMAND */\nSET &ZCTTRUNC = 3                                        /* MIN LEN */\nSET &ZCTACT = &STR(SELECT PANEL(XEFMENU) NEWAPPL(ISR))   /* ACTION  */\nSET &ZCTDESC = &STR(INVOKE XEF)                          /* DESC.   */\nISPEXEC TBADD &TABLE\n/*                                                                  */\n/*   ADD XEDIT (XE) COMMAND                                         */\n/*                                                                  */\nSET &ZCTVERB = XEDIT                                     /* COMMAND */\nSET &ZCTTRUNC = 2                                        /* MIN LEN */\nSET &ZCTACT= &STR(SELECT CMD(%XEDIT &&ZPARM) NEWAPPL(ISR)) /* ACTION */\nSET &ZCTDESC = &STR(EDIT ANY DATASET FROM ANY PANEL)     /* DESC.   */\nISPEXEC TBADD &TABLE\n/*                                                                  */\n/*   ADD XVIEW (XV) COMMAND                                         */\n/*                                                                  */\nSET &ZCTVERB = XVIEW                                     /* COMMAND */\nSET &ZCTTRUNC = 2                                        /* MIN LEN */\nSET &ZCTACT= &STR(SELECT CMD(%XVIEW &&ZPARM) NEWAPPL(ISR)) /* ACTION */\nSET &ZCTDESC = &STR(VIEW ANY DATASET FROM ANY PANEL)     /* DESC.   */\nISPEXEC TBADD &TABLE\n/*                                                                  */\n/*   ADD XBROWSE (XB) COMMAND                                       */\n/*                                                                  */\nSET &ZCTVERB = XBROWSE                                   /* COMMAND */\nSET &ZCTTRUNC = 2                                        /* MIN LEN */\nSET &ZCTACT= &STR(SELECT CMD(%XBROWSE &&ZPARM) NEWAPPL(ISR)) /*ACTION*/\nSET &ZCTDESC = &STR(BROWSE ANY DATASET FROM ANY PANEL)   /* DESC.   */\nISPEXEC TBADD &TABLE\n/*                                                                  */\n/*   ADD XDSLIST (XD) COMMAND                                       */\n/*                                                                  */\nSET &ZCTVERB = XDSLIST                                   /* COMMAND */\nSET &ZCTTRUNC = 2                                        /* MIN LEN */\nSET &ZCTACT= &STR(SELECT CMD(%XDSLIST &&ZPARM) NEWAPPL(ISR)) /*ACTION*/\nSET &ZCTDESC = &STR(DSLIST FROM ANY PANEL)               /* DESC.   */\nISPEXEC TBADD &TABLE\n/*                                                                  */\n/*   ADD XMEMLIST (XM) COMMAND                                      */\n/*                                                                  */\nSET &ZCTVERB = XMEMLIST                                  /* COMMAND */\nSET &ZCTTRUNC = 2                                        /* MIN LEN */\nSET &ZCTACT=&STR(SELECT CMD(%XMEMLIST &&ZPARM) NEWAPPL(ISR)) /*ACTION*/\nSET &ZCTDESC = &STR(GET A DSN MEMBER LIST FROM ANY PANEL) /* DESC.   */\nISPEXEC TBADD &TABLE\n/*                                                                  */\n/*   ADD XLISTC (XL) COMMAND                                        */\n/*                                                                  */\nSET &ZCTVERB = XLISTC                                    /* COMMAND */\nSET &ZCTTRUNC = 2                                        /* MIN LEN */\nSET &ZCTACT=&STR(SELECT CMD(%XLISTC &&ZPARM) NEWAPPL(ISR)) /*ACTION  */\nSET &ZCTDESC = &STR(IDCAMS LISTCAT ALL FROM ANY PANEL)   /* DESC.   */\nISPEXEC TBADD &TABLE\n/*                                                                  */\n/*   ADD ZEDIT (ZE) COMMAND                                         */\n/*                                                                  */\nSET &ZCTVERB = ZEDIT                                     /* COMMAND */\nSET &ZCTTRUNC = 2                                        /* MIN LEN */\nSET &ZCTACT = &STR(ALIAS ZEDIT)                          /* ACTION  */\nSET &ZCTDESC = &STR(EDIT DSN SPECIFIED OR AT CURSOR)     /* DESC.   */\nISPEXEC TBADD &TABLE\n/*                                                                  */\n/*   ADD ZVIEW (ZV) COMMAND                                         */\n/*                                                                  */\nSET &ZCTVERB = ZVIEW                                     /* COMMAND */\nSET &ZCTTRUNC = 2                                        /* MIN LEN */\nSET &ZCTACT = &STR(ALIAS ZVIEW)                          /* ACTION  */\nSET &ZCTDESC = &STR(VIEW DSN SPECIFIED OR AT CURSOR)     /* DESC.   */\nISPEXEC TBADD &TABLE\n/*                                                                  */\n/*   ADD ZBROWSE (ZB) COMMAND                                       */\n/*                                                                  */\nSET &ZCTVERB = ZBROWSE                                   /* COMMAND */\nSET &ZCTTRUNC = 2                                        /* MIN LEN */\nSET &ZCTACT = &STR(ALIAS ZBROWSE)                        /* ACTION  */\nSET &ZCTDESC = &STR(BROWSE DSN SPECIFIED OR AT CURSOR)   /* DESC.   */\nISPEXEC TBADD &TABLE\n/*                                                                  */\n/*   ADD CNTL COMMAND                                               */\n/*                                                                  */\nSET &ZCTVERB = CNTL                                      /* COMMAND */\nSET &ZCTTRUNC = 0                                        /* MIN LEN */\nSET &ZCTACT = &STR(SELECT CMD(%FVE CNTL &&ZPARM) NEWAPPL(ISR))\nSET &ZCTDESC = &STR(INVOKE CNTL CLIST TO EDIT MY CNTL DSN) /* DESC. */\nISPEXEC TBADD &TABLE\n/*                                                                  */\n/*   ADD PARM COMMAND                                               */\n/*                                                                  */\nSET &ZCTVERB = PARM                                      /* COMMAND */\nSET &ZCTTRUNC = 0                                        /* MIN LEN */\nSET &ZCTACT = &STR(SELECT CMD(%FVE PARM &&ZPARM) NEWAPPL(ISR))\nSET &ZCTDESC = &STR(INVOKE PARM CLIST TO EDIT SYS1.PARMLIB) /*DESC. */\nISPEXEC TBADD &TABLE\n/*                                                                  */\n/*   ADD PROC COMMAND                                               */\n/*                                                                  */\nSET &ZCTVERB = PROC                                      /* COMMAND */\nSET &ZCTTRUNC = 0                                        /* MIN LEN */\nSET &ZCTACT = &STR(SELECT CMD(%FVE PROC &&ZPARM) NEWAPPL(ISR))\nSET &ZCTDESC = &STR(INVOKE PARM CLIST TO EDIT SYS1.PARMLIB) /*DESC. */\nISPEXEC TBADD &TABLE\n/*                                                                  */\n/*   ADD PREFIX (PRE) COMMAND                                       */\n/*                                                                  */\nSET &ZCTVERB = PREFIX                                    /* COMMAND */\nSET &ZCTTRUNC = 3                                        /* MIN LEN */\nSET &ZCTACT = &STR(ALIAS PREFIX)                         /* ACTION  */\nSET &ZCTDESC = &STR(ABBREV FOR PREFIX EDIT MACRO)        /* DESC.   */\nISPEXEC TBADD &TABLE\n/*                                                                  */\n/*   ADD SUFFIX (SUF) COMMAND                                       */\n/*                                                                  */\nSET &ZCTVERB = SUFFIX                                    /* COMMAND */\nSET &ZCTTRUNC = 3                                        /* MIN LEN */\nSET &ZCTACT = &STR(ALIAS SUFFIX)                         /* ACTION  */\nSET &ZCTDESC = &STR(ABBREV FOR SUFFIX EDIT MACRO)        /* DESC.   */\nISPEXEC TBADD &TABLE\n/*                                                                  */\n/*   ADD TSOB COMMAND                                               */\n/*                                                                  */\nSET &ZCTVERB = TSOB                                      /* COMMAND */\nSET &ZCTTRUNC = 0                                        /* MIN LEN */\nSET &ZCTACT = &STR(SELECT CMD(%TSOB &&ZPARM) NEWAPPL(ISR))  /*ACTION*/\nSET &ZCTDESC = &STR(BROWSE OUTPUT FROM TSO COMMAND)      /* DESC.   */\nISPEXEC TBADD &TABLE\n/*                                                                  */\n/*   ADD TSOE COMMAND                                               */\n/*                                                                  */\nSET &ZCTVERB = TSOE                                      /* COMMAND */\nSET &ZCTTRUNC = 0                                        /* MIN LEN */\nSET &ZCTACT = &STR(SELECT CMD(%TSOE &&ZPARM) NEWAPPL(ISR))  /*ACTION*/\nSET &ZCTDESC = &STR(EDIT OUTPUT FROM TSO COMMAND)        /* DESC.   */\nISPEXEC TBADD &TABLE\n/*                                                                  */\n/*   ADD TSOR COMMAND                                               */\n/*                                                                  */\nSET &ZCTVERB = TSOR                                      /* COMMAND */\nSET &ZCTTRUNC = 0                                        /* MIN LEN */\nSET &ZCTACT = &STR(SELECT CMD(%TSOR &&ZPARM) NEWAPPL(ISR))  /*ACTION*/\nSET &ZCTDESC = &STR(REVIEW OUTPUT FROM TSO COMMAND)      /* DESC.   */\nISPEXEC TBADD &TABLE\n/*                                                                  */\n/*   ADD TSOV COMMAND                                               */\n/*                                                                  */\nSET &ZCTVERB = TSOV                                      /* COMMAND */\nSET &ZCTTRUNC = 0                                        /* MIN LEN */\nSET &ZCTACT = &STR(SELECT CMD(%TSOV &&ZPARM) NEWAPPL(ISR))  /*ACTION*/\nSET &ZCTDESC = &STR(VIEW OUTPUT FROM TSO COMMAND)        /* DESC.   */\nISPEXEC TBADD &TABLE\n/*                                                                  */\n/*   ADD FINDMOD COMMAND                                            */\n/*                                                                  */\nSET &ZCTVERB = FINDMOD                                   /* COMMAND */\nSET &ZCTTRUNC = 0                                        /* MIN LEN */\nSET &ZCTACT = &STR(SELECT CMD(%FINDMOD &&ZPARM))         /*ACTION   */\nSET &ZCTDESC = &STR(FIND A MODULE FROM ANY PANEL)        /* DESC.   */\nISPEXEC TBADD &TABLE\n/*                                                                  */\n/*   ADD FINDMOD (FM) COMMAND                                       */\n/*                                                                  */\nSET &ZCTVERB = FM                                        /* COMMAND */\nSET &ZCTTRUNC = 0                                        /* MIN LEN */\nSET &ZCTACT = &STR(SELECT CMD(%FINDMOD &&ZPARM))         /*ACTION   */\nSET &ZCTDESC = &STR(FIND A MODULE FROM ANY PANEL)        /* DESC.   */\nISPEXEC TBADD &TABLE\n/*                                                                  */\n/*   ADD ISPF COMMAND                                               */\n/*                                                                  */\nSET &ZCTVERB = ISPF                                      /* COMMAND */\nSET &ZCTTRUNC = 0                                        /* MIN LEN */\nSET &ZCTACT = &STR(SELECT PANEL(ISR@PRIM) NEWAPPL(ISR) OPT(&&ZPARM))\nSET &ZCTDESC = &STR(INVOKE RECURSIVE ISPF PRIMARY PANEL) /* DESC.   */\nISPEXEC TBADD &TABLE\n/********************************************************************/\n/*   OTHER PRODUCTS                                                 */\n/********************************************************************/\n/*                                                                  */\n/*   ADD BLKDISK                                                    */\n/*                                                                  */\nSET &ZCTVERB = BLKDISK                                   /* COMMAND */\nSET &ZCTTRUNC = 3                                        /* MIN LEN */\nSET &ZCTACT=&STR(SELECT CMD(%BLKCLIST))                  /* ACTION  */\nSET &ZCTDESC = &STR(INVOKE BLKDISK BLOCKSIZE CALCULATOR) /* DESC.   */\nISPEXEC TBADD &TABLE\n/*                                                                  */\n/*   ADD PHONE                                                      */\n/*                                                                  */\nSET &ZCTVERB = PHONE                                     /* COMMAND */\nSET &ZCTTRUNC = 0                                        /* MIN LEN */\nSET &ZCTACT=&STR(SELECT CMD(%PHONE &&ZPARM))             /* ACTION  */\nSET &ZCTDESC = &STR(FIND NAME IN WHO PHONE LIST)         /* DESC.   */\nISPEXEC TBADD &TABLE\n/*                                                                  */\n/*   ADD PDS COMMAND                                                */\n/*                                                                  */\nSET &ZCTVERB = PDS                                       /* COMMAND */\nSET &ZCTTRUNC = 0                                        /* MIN LEN */\nSET &ZCTACT = &STR(SELECT PANEL(PDS@PRIM) NEWAPPL(ISR))  /* ACTION  */\nSET &ZCTDESC = &STR(INVOKE PDS)                          /* DESC.   */\nISPEXEC TBADD &TABLE\n/*                                                                  */\n/*   ADD SDSF COMMAND                                               */\n/*                                                                  */\nSET &ZCTVERB = SDSF                                      /* COMMAND */\nSET &ZCTTRUNC = 2                                        /* MIN LEN */\nSET &ZCTACT=&STR(SELECT PGM(ISFISP) NOCHECK NEWAPPL(ISF) PARM(&&ZPARM))\nSET &ZCTDESC = &STR(INVOKE SDSF)                         /* DESC.   */\nISPEXEC TBADD &TABLE\n/*                                                                  */\n/*   ADD SMPE COMMAND                                               */\n/*                                                                  */\nSET &ZCTVERB = SMPE                                      /* COMMAND */\nSET &ZCTTRUNC = 0                                        /* MIN LEN */\nSET &ZCTACT=&STR(SELECT PGM(GIMSTART) NOCHECK PARM(&&ZPARM))\nSET &ZCTDESC = &STR(INVOKE SMPE)                         /* DESC.   */\nISPEXEC TBADD &TABLE\n/*                                                                  */\n/*   ADD TMS COMMAND                                                */\n/*                                                                  */\nSET &ZCTVERB = TMS                                       /* COMMAND */\nSET &ZCTTRUNC = 0                                        /* MIN LEN */\nSET &ZCTACT = &STR(SELECT PGM(TMSIOPRI) NEWAPPL(TMS) NOCHECK)\nSET &ZCTDESC = &STR(INVOKE CA-1 (TMS))                   /* DESC.   */\nISPEXEC TBADD &TABLE\n/*                                                                  */\n/*   ADD CA1 COMMAND                                                */\n/*                                                                  */\nSET &ZCTVERB = CA1                                       /* COMMAND */\nSET &ZCTTRUNC = 0                                        /* MIN LEN */\nSET &ZCTACT = &STR(SELECT PGM(TMSIOPRI) NEWAPPL(TMS) NOCHECK)\nSET &ZCTDESC = &STR(INVOKE CA-1 (TMS))                   /* DESC.   */\nISPEXEC TBADD &TABLE\n/*                                                                  */\n/*   ADD WLM COMMAND                                                */\n/*                                                                  */\nSET &ZCTVERB = WLM                                       /* COMMAND */\nSET &ZCTTRUNC = 0                                        /* MIN LEN */\nSET &ZCTACT = &STR(SELECT CMD(%IWMARIN0))\nSET &ZCTDESC = &STR(INVOKE WLM)                          /* DESC.   */\nISPEXEC TBADD &TABLE\n/*                                                                  */\n/*   ADD DDLIST COMMAND                                             */\n/*                                                                  */\nSET &ZCTVERB = DDLIST                                    /* COMMAND */\nSET &ZCTTRUNC = 2                                        /* MIN LEN */\nSET &ZCTACT = &STR(SELECT PGM(ISRDDN) NEWAPPL(ISP) SUSPEND)\nSET &ZCTDESC = &STR(INVOKE ISRDDN)                       /* DESC.   */\nISPEXEC TBADD &TABLE\n/*                                                                  */\n/*   ADD LPROG COMMAND                                              */\n/*                                                                  */\nSET &ZCTVERB = LPROG                                     /* COMMAND */\nSET &ZCTTRUNC = 0                                        /* MIN LEN */\nSET &ZCTACT = &STR(SELECT CMD(%LPROG &&ZPARM) NEWAPPL(ISP))\nSET &ZCTDESC = &STR(INVOKE LPROG)                        /* DESC.   */\nISPEXEC TBADD &TABLE\n/*                                                                  */\n/*   ADD IPLINFO COMMAND                                            */\n/*                                                                  */\nSET &ZCTVERB = IPLINFO                                   /* COMMAND */\nSET &ZCTTRUNC = 3                                        /* MIN LEN */\nSET &ZCTACT = &STR(SELECT CMD(%IPLINFO &&ZPARM) NEWAPPL(ISP))\nSET &ZCTDESC = &STR(INVOKE IPLINFO)                      /* DESC.   */\nISPEXEC TBADD &TABLE\n/*                                                                  */\n/*  STORE TABLE NAME IN PANEL DISPLAY AND DISPLAY IT                */\n/*                                                                  */\nSET &TABLE = &STR(&TABLE)\nISPEXEC VPUT (TABLE)\nSET &SEL = &Z\nISPEXEC TBDISPL &TABLE PANEL(ISPUCMC)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISPDFLTS": {"ttr": 5386, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00G\\x01\\x01\\x03?\\x01\\x01\\x03?\\x14\\x10\\x000\\x000\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf3\\xf3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-02-02T00:00:00", "modifydate": "2001-02-02T14:10:47", "lines": 48, "newlines": 48, "modlines": 0, "user": "CBT433"}, "text": "//TSGMXZ1I JOB (AD00),'#04D42 ZELDEN',\n//             NOTIFY=&SYSUID,\n//             CLASS=M,MSGCLASS=H,MSGLEVEL=(1,1)\n//************************************************************\n//* NOTE: THE SMP/E GLOBAL ZONE AND ++VER MAY NEED TO BE\n//*       ADJUSTED FOR THE CORRECT OS/390 & ISPF VERSION\n//*       BEFORE RUNNING THIS JOB\n//************************************************************\n//C       EXEC PGM=ASMA90,\n//             PARM='RENT,OBJECT,NODECK'\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//         DD  DSN=SYS1.MODGEN,DISP=SHR\n//         DD  DSN=SYS1.ISP.SISPMACS,DISP=SHR\n//SYSUT1   DD  DSN=&&SYSUT1,SPACE=(CYL,(1,1),,,ROUND),\n//             UNIT=SYSALLDA,DCB=BUFNO=1\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSN=&&OBJ,SPACE=(CYL,(1,1)),\n//             UNIT=SYSALLDA,DISP=(MOD,PASS),\n//             DCB=(BLKSIZE=3040,LRECL=80,RECFM=FBS,BUFNO=1)\n//************************************************************\n//SYSIN   DD DATA,DLM=##\n         ISPMTAIL   TROWDEF=1,CMDSTKSZ=512,EXITS=YES,TCP=TCPIP\n##\n//************************************************************\n//SMPE        EXEC  PGM=GIMSMP,REGION=6M,\n//             COND=(0,NE),\n//             PARM='CSI=MPSYS1.OS39028.GLOBAL.CSI'\n//SMPOUT    DD  SYSOUT=*\n//SMPRPT    DD  SYSOUT=*\n//SYSPRINT  DD  SYSOUT=*\n//SMPCNTL   DD  *\n SET BDY(GLOBAL) .\n REJECT  S(UMISP01) BYPASS(APPLYCHECK).\n RESETRC.\n RECEIVE S(UMISP01) SYSMOD SOURCEID(USERMOD) .\n SET BDY(SM0R1A1).\n APPLY SELECT(UMISP01) REDO.\n//SMPPTFIN  DD  *\n++ USERMOD (UMISP01)   /*\n    THIS USERMOD LETS ISPF KNOW THAT EXITS WILL BE\n    USED BY CHANGING THE ISPDFLTS MODULE ISPDFLTS.\n    ISPDFLTS IS LINKED INTO ISPMAIN WHICH IS IN\n    THE SISPLPA LIBRARY.\n               */ .\n++ VER (Z038) FMID (HIF4802).\n++ MOD (ISPDFLTS) DISTLIB(AISPMOD1).\n/*\n//          DD DSN=&&OBJ,DISP=(OLD,DELETE)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ISPEX16": {"ttr": 5388, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00)\\x01\\x01\\x03?\\x01\\x01\\x03?\\x14\\x10\\x00\\x8d\\x00\\x8d\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf3\\xf3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-02-02T00:00:00", "modifydate": "2001-02-02T14:10:29", "lines": 141, "newlines": 141, "modlines": 0, "user": "CBT433"}, "text": "//TSGMXZ1I JOB (AD00),'#04D42 ZELDEN',\n//             NOTIFY=&SYSUID,\n//             CLASS=M,MSGCLASS=H,MSGLEVEL=(1,1)\n//************************************************************\n//* NOTE: THE SMP/E GLOBAL ZONE AND ++VER MAY NEED TO BE\n//*       ADJUSTED FOR THE CORRECT OS/390 & ISPF VERSION\n//*       BEFORE RUNNING THIS JOB\n//************************************************************\n//C       EXEC PGM=ASMA90,\n//             PARM='RENT,OBJECT,NODECK'\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//         DD  DSN=SYS1.MODGEN,DISP=SHR\n//         DD  DSN=SYS1.ISP.SISPMACS,DISP=SHR\n//SYSUT1   DD  DSN=&&SYSUT1,SPACE=(CYL,(1,1),,,ROUND),\n//             UNIT=SYSALLDA,DCB=BUFNO=1\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSN=&&OBJ,SPACE=(CYL,(1,1)),\n//             UNIT=SYSALLDA,DISP=(MOD,PASS),\n//             DCB=(BLKSIZE=3040,LRECL=80,RECFM=FBS,BUFNO=1)\n//************************************************************\n//SYSIN   DD DATA,DLM=##\n    TITLE 'ISPF EXIT 16 FOR LOG, LIST, AND TEMPORARY DATA SET NAMES'\n*   THIS SAMPLE CODE PUTS THE SMFID INTO THE LOG,LIST AND\n*   TEMPORARY DATA SET NAMES GENERATED BY ISPF.\n*   EXAMPLES:\n*      userid.SYSnnnn.SPFLOGn.LIST      (LOG)\n*      userid.SYSnnnn.SPFn.LIST         (LIST)\n*      userid.SYSnnnn.SPFTEMPn.CNTL     (generated by SUBMIT command)\n*\n         ISPMXED START\n         ISPMXLST (16)\n         ISPMXDEF 16\n         ISPMEPT ISPEX16\n         ISPMXEND\n*\n         ISPMXED END\n*\n         ISPMXDD START\n*\n         ISPMXDD END\nISPEX16  RSECT\nISPEX16  AMODE 31\nISPEX16  RMODE ANY\n         SAVE  (14,12),,'ISPEX16 &SYSDATC &SYSTIME'\n         LR    R12,R15\n         USING ISPEX16,R12\n         LR    R10,R1              SAVE INPUT PARAMETER LIST\n         USING PARMLIST,R10        MAP PARAMETERS\n*\n         L     R1,EXITID\n         CLC   =F'16',0(R1)        MAKE SURE CALL IS FOR EXIT 16\n         BNE   RETURN              WHAT????  (SHOULDN'T HAPPEN)\n         L     R3,PRELEN           ADDRESS OF PREFIX LENGTH IN R3\n         L     R4,PREFIX           PREFIX DATA IN R4\n         L     R6,0(,R3)           GET PREFIX LENGTH\n         C     R6,=F'16'           CHECK LENGTH\n         BH    RETURN              ALREADY TOO LONG!\n         L     R5,CVTPTR           GET POINTER TO CVT\n         USING CVT,R5              MAP IT\n         ICM   R5,B'1111',CVTSMCA  GET POINTER TO SMCA & CHK FOR ZEROS\n         BZ    RETURN              NO SMCA (SMF NOT ACTIVE)??\n         DROP  R5\n         USING SMCABASE,R5         MAP SMCA\n         ALR   R4,R6               POINT TO LAST POSITION OF PREFIX\n         MVC   0(4,R4),=C'.SYS'    PREFIX IS\n         MVC   4(4,R4),SMCASID           '.SYSNNNN' NNNN=SMFID\n         LA    R4,7(,R4)\nF_BLANK  DS    0H\n         CLI   0(R4),C' '\n         BNE   E_BLANK\n         BCT   R4,F_BLANK\nE_BLANK  DS    0H\n         S     R4,PREFIX           GET LENGTH\n         LA    R4,1(,R4)           ACTUALLY 1 LONGER\n         L     R3,PRELEN\n         ST    R4,0(,R3)           STORE NEW LENGTH IN R3\nRETURN   DS    0H\n         RETURN (14,12),RC=0\n         PRINT   OFF\n         IHAPSA  DSECT=YES,LIST=NO\n         CVT     DSECT=YES,LIST=NO\n         IEESMCA\n         IHAASCB DSECT=YES,LIST=NO\n*\n*  REGISTER EQUATES\n*\nR0       EQU   0\nR1       EQU   1                  POINTER TO INPUT PARMAMTER LIST\nR2       EQU   2\nR3       EQU   3                  WORK - ADDRESS OF PREFIX LENGTH\nR4       EQU   4                  WORK - LENGTH OF PREFIX\nR5       EQU   5                  BASE USED FOR CVT AND SMCA\nR6       EQU   6                  WORK REGISTER\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10                 SAVED INPUT PARAMETER LIST\nR11      EQU   11\nR12      EQU   12                 BASE REGISTER\nR13      EQU   13\nR14      EQU   14                 LINKAGE REGISTER (RETURN ADDRESS)\nR15      EQU   15                 LINKAGE REGISTER (ENTRY POINT)\nPARMLIST DSECT\nEXITID   DS    A       *EXITID      F\nUSERID   DS    A       *USERID      CL8\nSCREENID DS    A       *SCREENID    CL8\nZENVIR   DS    A       *ZENVIR      CL32\nDATALEN  DS    A       *DATALEN     F\nDATAPTR  DS    A       *DATAPTR     A\nPRELEN   DS    A       *PRELEN      F\nPREFIX   DS    A       *PREFIX      CL26\nSUFTYPE  DS    A       *SUFTYPE     F\nSUFLEN   DS    A       *SUFLEN      F\nSUFFIX   DS    A       *SUFFIX      CL18\n         END\n##\n//************************************************************\n//SMPE        EXEC  PGM=GIMSMP,REGION=6M,\n//             COND=(0,NE),\n//             PARM='CSI=MPSYS1.OS39028.GLOBAL.CSI'\n//SMPOUT    DD  SYSOUT=*\n//SMPRPT    DD  SYSOUT=*\n//SYSPRINT  DD  SYSOUT=*\n//SMPCNTL   DD  *\n SET BDY(GLOBAL) .\n REJECT  S(UMISP02) BYPASS(APPLYCHECK).\n RESETRC.\n RECEIVE S(UMISP02) SYSMOD SOURCEID(USERMOD) .\n SET BDY(SM0R1A1).\n APPLY SELECT(UMISP02) REDO.\n//SMPPTFIN  DD  *\n++ USERMOD (UMISP02)   /*\n    THIS USERMOD UPDATES ISPXDT - THE ISPF EXIT DEFINITION\n    TABLE CSECT IN LMOD ISPEXITS TO LET ISPF KNOW WHAT\n    EXITS ARE BEING USED. ISPF EXIT16 IS LINKED TOGETHER\n    WITH THIS LMOD. ISPEXITS IS IN THE SISPLOAD LIBRARY.\n               */ .\n++ VER (Z038) FMID (HIF4802).\n++ MOD (ISPXDT) DISTLIB(AISPMOD1).\n/*\n//          DD DSN=&&OBJ,DISP=(OLD,DELETE)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "JOBCHECK": {"ttr": 5633, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x01\\x9f\\x01\\x16\\t_\\x16E\\x00\\xb3\\x00\\xab\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf9\\xf1@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-19T00:00:00", "modifydate": "2016-04-04T16:45:00", "lines": 179, "newlines": 171, "modlines": 0, "user": "CBT491"}, "text": "//TSGMXZ1A JOB (AD00),'#04D42 ZELDEN',\n//             NOTIFY=&SYSUID,\n//             CLASS=M,MSGCLASS=H,MSGLEVEL=(1,1)\n//*\n//C       EXEC PGM=ASMA90,\n//             PARM=(NODECK,OBJECT)\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//         DD  DSN=SYS1.MODGEN,DISP=SHR\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(1024,(120,120),,,ROUND)\n//SYSPUNCH DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSN=&OBJ,SPACE=(3040,(40,40),,,ROUND),UNIT=SYSALLDA,\n//             DISP=(MOD,PASS),\n//             DCB=(BLKSIZE=3040,LRECL=80,RECFM=FBS,BUFNO=1)\n//SYSIN    DD  *\n         TITLE 'JOBCHECK - CHECK IF JOB IS ACTIVE IN THE SYSTEM'\n         PRINT NOGEN\n***********************************************************************\n* THIS PROGRAM WILL CHECK IF A JOB (STC,TSU, OR JOB)                  *\n* IS ACTIVE IN THE SYSTEM.                                            *\n*                                                                     *\n* THE PROGRAM MUST BE PASSED A PARM OF THE JOB TO CHECK.              *\n*                                                                     *\n* IF THE JOB IS FOUND THE CONDITION CODE IS SET TO 0.                 *\n* IF THE JOB IS NOT FOUND THE CONDITION CODE IS SET TO 4.             *\n*                                                                     *\n* NORMAL COMPLETION MESSAGES:                                         *\n*  JOBCHECK - JOB XXXXXXXX WAS ACTIVE IN THE SYSTEM - CONDITION CODE  *\n*             SET TO 00                                               *\n*  JOBCHECK - STC XXXXXXXX WAS ACTIVE IN THE SYSTEM - CONDITION CODE  *\n*             SET TO 00                                               *\n*  JOBCHECK - XXXXXXXX WAS NOT ACTIVE IN THE SYSTEM - CONDITION CODE  *\n*             SET TO 04                                               *\n*                                                                     *\n* ABEND MESSAGES:                                                     *\n*  JOBCHECK - NO PARM VALUE ENTERED                                   *\n*                 U0001 ABEND                                         *\n*  JOBCHECK - BAD PARM - MAXIMUM JOBNAME LENGTH IS 8 CHARACTERS       *\n*                 U0002 ABEND                                         *\n***********************************************************************\n*** SAMPLE JCL:\n***\n*** //JOBCHECK JOB (ACCT),'CHK FOR ACTIVE JOB',CLASS=M\n*** //STEP1 EXEC PGM=JOBCHECK,PARM=MYJOB\n*** //\n***********************************************************************\n* UPDATES:\n* 04/04/2016 MSZ  ADDED AMODE 31 / RMODE 24 ASSEMBLER DIRECTIVES TO\n*                 TO SUPPORT ASVT IN 31-BIT STORAGE IN Z/OS 2.1\n*                 AND ABOVE VIA DIAGXX CBLOC\n***********************************************************************\n***\n*\n*  REGISTER EQUATES AND USAGE\n*\nR01      EQU   1                  INITIAL POINTER TO INPUT PARM\nR02      EQU   2                  WORK REG\nR03      EQU   3                  POINTS TO PARM / MAX # ASVT ENTRIES\nR04      EQU   4                  WORK - POINTS TO CURRENT ADDR IN ASVT\nR05      EQU   5                  WORK REG\nR10      EQU   10                 BASE REG FOR ASCB\nR11      EQU   11                 BASE REG FOR ASVT\nR12      EQU   12                 BASE REGISTER\nR13      EQU   13                 POINTER TO SAVE AREA\nR14      EQU   14                 LINKAGE REGISTER (RETURN ADDRESS)\nR15      EQU   15                 LINKAGE REGISTER (ENTRY POINT)\n*\nJOBCHECK CSECT\nJOBCHECK AMODE 31                 ADDED FOR IHAASVT IN 31-BIT MODE\nJOBCHECK RMODE 24                 ADDED FOR IHAASVT IN 31-BIT MODE\n         B     START-JOBCHECK(R15)\n         DC    AL1(START-*)\n         DC    C'JOBCHECK &SYSDATE &SYSTIME '\n         DC    C'*** AUTHOR: MARK ZELDEN ***'\nSTART    SAVE  (14,12)            SAVE REGISTERS\n         LR    R12,R15            SET UP ADDRESSABILITY\n         USING JOBCHECK,R12       SET UP BASE REGISTER\n         LR    R02,R13            SAVE ADDR OF PREVIOUS SAVEAREA\n         LA    R13,SAVEAREA       POINT TO CURRENT SAVEAREA\n         ST    R13,8(R02)         SAVE THIS PROGRAM'S SAVEAREA ADDRESS\n         ST    R02,4(R13)         SAVE CALLERS SAVEAREA ADDRESS\n* ====================================================================\n         L     R03,0(R01)         POINT TO PARM VALUE\n         SR    R02,R02            ZERO EX REG\n         LH    R02,0(R03)         LOAD EX REG FROM PARM LENGTH\n         CL    R02,=F'8'          PARM LENGTH GREATER THAN 8 ?\n         BH    BADPARM            YES, BRANCH\n         LTR   R02,R02            PARM LENGTH = 0 ?\n         BZ    NOPARM             YES, BRANCH\n         BCTR  R02,0              DECREMENT FOR EXECUTE MOVE\n         EX    R02,MVJOBNM        MOVE JOBNAME\n*******************************************************************\n* POINT TO ASVT\n*******************************************************************\n         L     R11,CVTPTR         POINT TO CVT  - X'10'\n         USING CVT,R11            MAP CVT\n         L     R11,CVTASVT        POINT TO ASVT\n         DROP  R11                TELL ASMBLR TO STOP USING R11 FOR CVT\n         USING ASVT,R11           MAP ASVT\n         LA    R04,ASVTENTY       POINT TO FIRST ENTRY IN TABLE\n         L     R03,ASVTMAXU       LOAD MAX NUMBER OF ENTRIES\n*******************************************************************\n* THIS ROUTINE CHECKS EACH ASVT ENTRY.\n* IF THE HIGH ORDER BIT IS ON, THE ENTRY IS THE ADDRESS OF THE\n* NEXT AVAILABLE ASID (OR THE LAST ENTRY IF ZEROS).\n* IF THE HIGH ORDER BIT IS NOT ON, THE ENTRY IS THE ADDRESS\n* OF THE ASCB FOR THAT ENTRY.\n*******************************************************************\nASVTLOOP TM    0(R04),ASVTAVAL    IS THIS AN ASCB ADDRESS ?\n         BNO   CHKASCB            YES, BRANCH\n         LA    R04,4(,R04)        NO, POINT TO NEXT ENTRY IN ASVT\n         BCT   R03,ASVTLOOP       GO CHECK NEXT ASVT ENTRY\n         B     NOTFOUND           NO MORE ENTRIES - BRANCH\n*******************************************************************\n* WE HAVE A VALID ASCB ADDRESS - CHECK IT\n*******************************************************************\nCHKASCB  L     R10,0(R04)         POINT TO ASCB\n         USING ASCB,R10           MAP IT\n         L     R05,ASCBJBNI       POINT TO JOBNAME\n         CL    R05,=F'0'          WAS THIS A START/MOUNT/LOGON ?\n         BE    NOTAJOB            YES, BRANCH\n         CLC   JOBNAME,0(R05)     IS IT THE ASCB OF JOB ON THE PARM?\n         BE    FOUND              YES, BRANCH\n         LA    R04,4(,R04)        NO, POINT TO NEXT ENTRY IN ASVT\n         BCT   R03,ASVTLOOP       GO CHECK NEXT ASVT ENTRY\nNOTAJOB  L     R05,ASCBJBNS       POINT TO START/MOUNT/LOGON NAME\n         CLC   JOBNAME,0(R05)     IS IT THE ASCB OF JOB ON THE PARM?\n         BE    CHGWTO             YES, BRANCH\n         LA    R04,4(,R04)        NO, POINT TO NEXT ENTRY IN ASVT\n         BCT   R03,ASVTLOOP       GO CHECK NEXT ASVT ENTRY\nCHGWTO   MVC   FNDWTO+19(3),=C'STC'    PLUG WTO WITH \"STC\"\n         B     FOUND              BRANCH\n*******************************************************************\n* JOB NOT FOUND - WRITE MSG AND END RC=4\n*******************************************************************\nNOTFOUND MVC   NFNDWTO+19(8),JOBNAME    PLUG WTO WITH JOB NAME\nNFNDWTO  WTO   'JOBCHECK - XXXXXXXX WAS NOT ACTIVE IN THE SYSTEM - CONDX\n               ITION CODE SET TO 04',ROUTCDE=11\n         L     R13,4(R13)         RESTORE CALLERS SAVAREA ADDRESS\n         RETURN (14,12),RC=4      RETURN CONTROL AND SET COND CODE TO 4\n*******************************************************************\n* JOB FOUND - WRITE MSG AND END RC=0\n*******************************************************************\nFOUND    MVC   FNDWTO+23(8),JOBNAME    PLUG WTO WITH JOB NAME\nFNDWTO   WTO   'JOBCHECK - JOB XXXXXXXX WAS ACTIVE IN THE SYSTEM - CONDX\n               ITION CODE SET TO 00',ROUTCDE=11\n         B     RETURN0            GET OUT - RETURN CODE 0\n*******************************************************************\nNOPARM   WTO   'JOBCHECK - NO PARM VALUE ENTERED',ROUTCDE=11\n         ABEND 01,REASON=0        U0001 ABEND  - NO DUMP\n         B     RETURN0            GET OUT - RETURN CODE 0\n*******************************************************************\nBADPARM  WTO   'JOBCHECK - BAD PARM - MAXIMUM JOBNAME LENGTH IS 8 CHARAX\n               CTERS',ROUTCDE=11\n         ABEND 02,REASON=8        U0002 ABEND  - NO DUMP\n*******************************************************************\nRETURN0  L     R13,4(R13)         RESTORE CALLERS SAVAREA ADDRESS\n         RETURN (14,12),RC=0      RETURN CONTROL AND SET COND CODE TO 0\n         EJECT\n* ====================================================================\nMVJOBNM  MVC   JOBNAME(0),2(3)    EXECUTED MOVE INSTRUCTION\nJOBNAME  DC    CL8' '             JOB NAME TO CHECK\nSAVEAREA DS    18F                SAVE AREA\n         LTORG\n         CVT DSECT=YES\n         IHAASVT\n         IHAASCB\n         END\n/*\n//L       EXEC PGM=IEWL,COND=(5,LT,C),\n//             PARM='LIST,LET,XREF,MAP'\n//SYSLIN   DD  DSN=&OBJ,\n//             DISP=(OLD,DELETE)\n//         DD  DDNAME=SYSIN\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(1024,(120,120),,,ROUND)\n//SYSPRINT DD  SYSOUT=*\n//*************************************************************\n//SYSLMOD  DD  DISP=SHR,DSN=????????.LOAD(JOBCHECK)\n//*************************************************************\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JOBCHKRX": {"ttr": 5637, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00U\\x01\\x040\\x0f\\x01\\x040\\x0f\\x14\\x15\\x00^\\x00^\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf6\\xf7@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-10-26T00:00:00", "modifydate": "2004-10-26T14:15:55", "lines": 94, "newlines": 94, "modlines": 0, "user": "CBT467"}, "text": "/* REXX */\n/*                                       */\n/* AUTHOR: Mark Zelden                   */\n/*                                       */\n/* Trace ?r */\n/*********************************************************************/\n/* JOBCHECK                                                          */\n/*                                                                   */\n/* This program will check if a task (STC,TSU, OR JOB)               */\n/* is active in the system.                                          */\n/*                                                                   */\n/* The program must be passed a parm of the task name to check.      */\n/*                                                                   */\n/* If the task is found the condition code is set to 0.              */\n/* If the task is not found the condition code is set to 4.          */\n/*                                                                   */\n/* Normal completion messages:                                       */\n/* JOBCHECK - XXXXXXXX WAS ACTIVE IN THE SYSTEM - CONDITION          */\n/*            CODE SET TO 00                                         */\n/* JOBCHECK - XXXXXXXX WAS NOT ACTIVE IN THE SYSTEM - CONDITION      */\n/*            CODE SET TO 04                                         */\n/*                                                                   */\n/* Abnormal completion messages:                                     */\n/* JOBCHECK - NO PARM VALUE ENTERED - CONDITION CODE SET TO 16       */\n/* JOBCHECK - BAD PARM - MAXIMUM TASKNAME LENGTH IS 8 CHARACTERS -   */\n/*            CONDITION CODE SET TO 16                               */\n/*                                                                   */\n/*********************************************************************/\n/* Sample batch execution JCL:                                       */\n/*                                                                   */\n/*  //MYJOB    JOB (ACCT),CLASS=A,MSGCLASS=H                         */\n/*  //JOBCHECK EXEC PGM=IRXJCL,PARM='JOBCHECK MYJOB'                 */\n/*  //SYSTSIN  DD DUMMY                                              */\n/*  //SYSTSPRT DD SYSOUT=*                                           */\n/*  //SYSEXEC  DD DSN=your.rexx.sysexec.lib,DISP=SHR                 */\n/*                                                                   */\n/*********************************************************************/\nArg TASKPRM\nIf TASKPRM = '' then do\n  Say 'NO PARM VALUE ENTERED - CONDITION CODE SET TO 16'\n  Exit 16\nEnd\nIf Length(TASKPRM) > 8 then do\n  Say 'BAD PARM - MAXIMUM TASKNAME LENGTH IS 8 CHARACTERS -' ,\n      'CONDITION CODE SET TO 16'\n  Exit 16\nEnd\n/*********************************************************************/\nNumeric digits 10                           /* dflt of 9 not enough  */\n/*********************************************************************/\n/* Point to ASVT                                                     */\n/*********************************************************************/\nCVT      = C2d(Storage(10,4))               /* point to CVT          */\nCVTASVT  = C2d(Storage(D2x(CVT+556),4))     /* point to ASVT         */\nASVTMAXU = C2d(Storage(D2x(CVTASVT+516),4)) /* max number of entries */\n/*********************************************************************/\n/* This routine checks each ASVT entry.                              */\n/* If the high order bit is on, the entry is the address of the      */\n/* next available asid (or the last entry if zeros).                 */\n/* If the high order bit is not on, the entry is the address         */\n/* of the ascb for that entry.                                       */\n/*********************************************************************/\nFOUND = 'N'                            /* init \"FOUND\" flag to \"N\"   */\nDo I = 0 to ASVTMAXU-1     /* start at 0 so I*4 bumps to next entry  */\n  ASVTENTY = Storage(D2x(CVTASVT+528+(I*4)),4)      /* cur ASVT entry*/\n  If Bitand(ASVTENTY,'80000000'x) == '80000000'x then iterate\n/*********************************************************************/\n/* We have a valid ASCB address - check it                           */\n/*********************************************************************/\n  Else do\n    ASVTENTY = C2d(ASVTENTY)     /* change to decimal for code below */\n    ASCBJBN  = C2d(Storage(D2x(ASVTENTY+172),4))  /* ASCBJBNI        */\n    If ASCBJBN = 0 then ,   /* not a job - must be START/LOGON/MOUNT */\n      ASCBJBN = C2d(Storage(D2x(ASVTENTY+176),4)) /* ASCBJBNS        */\n    TASKNAME  = Strip(Storage(D2x(ASCBJBN),8))    /* point to name   */\n    If TASKNAME == TASKPRM then do\n      FOUND = 'Y'                 /* set found flag                  */\n      Leave I                     /* leave loop, no need to continue */\n    End\n  End /* Else do */\nEnd /* Do I */\n/*********************************************************************/\n/* Done processing - write end messages and set return code          */\n/*********************************************************************/\nIf FOUND = 'Y' then do\n  Say 'JOBCHECK -' TASKPRM 'WAS ACTIVE IN THE SYSTEM -' ,\n      'CONDITION CODE SET TO 00'\n  Exit 0\nEnd\nElse do\n  Say 'JOBCHECK -' TASKPRM 'WAS NOT ACTIVE IN THE SYSTEM -' ,\n      'CONDITION CODE SET TO 04'\n  Exit 4\nEnd\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "KEYSWAP": {"ttr": 5640, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x006\\x00\\x992/\\x00\\x992/\\x16'\\x00P\\x00P\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf2\\xf2@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "1999-11-18T16:27:36", "lines": 80, "newlines": 80, "modlines": 0, "user": "CBT422"}, "text": "/* rexx */\n/*                           */\n/* AUTHOR: MARK ZELDEN       */\n/*                           */\n/*****************************/\n/* swap pfkeys 1  thru 12    */\n/* with pfkeys 13 thru 24    */\n/*****************************/\n say 'SWAPPING PFKEYS 1-12 WITH PFKEYS 13-24'\n call read_keys\n call swap_keys\n call write_keys\n say '    '\n say 'SWAPPING COMPLETE!'\n\nread_keys:\ndo i= 1 to 24\n  i = right(i,2,'0')\n  \"ISPEXEC VGET ZPF\"||i||\" PROFILE\"\nend\nreturn\n\nswap_keys:\nTPF.1  = ZPF13\nTPF.2  = ZPF14\nTPF.3  = ZPF15\nTPF.4  = ZPF16\nTPF.5  = ZPF17\nTPF.6  = ZPF18\nTPF.7  = ZPF19\nTPF.8  = ZPF20\nTPF.9  = ZPF21\nTPF.10 = ZPF22\nTPF.11 = ZPF23\nTPF.12 = ZPF24\nTPF.13 = ZPF01\nTPF.14 = ZPF02\nTPF.15 = ZPF03\nTPF.16 = ZPF04\nTPF.17 = ZPF05\nTPF.18 = ZPF06\nTPF.19 = ZPF07\nTPF.20 = ZPF08\nTPF.21 = ZPF09\nTPF.22 = ZPF10\nTPF.23 = ZPF11\nTPF.24 = ZPF12\n\nZPF01  = TPF.1\nZPF02  = TPF.2\nZPF03  = TPF.3\nZPF04  = TPF.4\nZPF05  = TPF.5\nZPF06  = TPF.6\nZPF07  = TPF.7\nZPF08  = TPF.8\nZPF09  = TPF.9\nZPF10  = TPF.10\nZPF11  = TPF.11\nZPF12  = TPF.12\nZPF13  = TPF.13\nZPF14  = TPF.14\nZPF15  = TPF.15\nZPF16  = TPF.16\nZPF17  = TPF.17\nZPF18  = TPF.18\nZPF19  = TPF.19\nZPF20  = TPF.20\nZPF21  = TPF.21\nZPF22  = TPF.22\nZPF23  = TPF.23\nZPF24  = TPF.24\nreturn\n\nwrite_keys:\ndo i= 1 to 24\n  i = right(i,2,'0')\n  \"ISPEXEC VPUT ZPF\"||i||\" PROFILE\"\nend\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LASTIPL": {"ttr": 5643, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x10\\to\\x01\\x10\\to\\t\\x00\\x00t\\x00r\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-04-06T00:00:00", "modifydate": "2010-04-06T09:00:00", "lines": 116, "newlines": 114, "modlines": 0, "user": "CBT479"}, "text": "/* REXX */\n/*                                       */\n/* AUTHOR: Mark Zelden                   */\n/*                                       */\n/***************************************************************/\n/*                                                             */\n/* DISPLAY THE LAST (LATEST) IPL INFORMATION FOR ALL LPARS     */\n/*                                                             */\n/* This exec is meant to run against the PDS that contains     */\n/* the output history created by the IPLHIST exec.             */\n/*                                                             */\n/* From the TSO READY prompt or ISPF option 6:                 */\n/*  EX 'SYS1.IPL.HISTORY(LASTIPL)'                             */\n/*     or                                                      */\n/*  Type \"EX\" next to this member from an enhanced member list */\n/*     or                                                      */\n/*  Put this exec in a SYSPROC/SYSEXEC library and type        */\n/*    TSO %LASTIPL                                             */\n/***************************************************************/\nArg dsn\nIf dsn = '' then DSN = 'SYS1.IPL.HISTORY'\njunk = outtrap('MBR.')                /* capture output to MBR. stem */\n\"LISTD '\" || dsn || \"' MEMBERS\"       /* issue LISTD cmd against PDS */\njunk = outtrap('off')                 /* stop capturing output       */\nDo I = 1 to MBR.0                     /* loop to get past vol info   */\n  If MBR.I = \"--MEMBERS--\" then leave /* if member section, exit loop*/\nEnd\nIf I = MBR.0 then do                  /* no members in PDS           */\n  Say 'ERROR - No MEMBERS found in' dsn'.' /* issue error msg        */\n  Exit 12                             /* exit RC=12                  */\nEnd\n/*********************************************************************/\n/* Create a new member list without blanks and remove $$$DOC and any */\n/* other names that don't start with \"$\" from the list (in case      */\n/* IPLINFO and IPLHIST are stored in the same library as the         */\n/* history.                                                          */\n/*********************************************************************/\nTOT = 0   /* total members in new stem */\nDo newl = I+1 to mbr.0\n  ckmem  = Strip(mbr.newl)\n  If ckmem = '$$$DOC' then iterate           /* ignore $$$DOC member */\n  If Substr(ckmem,1,1) <> '$' then iterate  /* ignore non-hist mbrs  */\n  TOT = TOT+1                         /* add 1 to total stem members */\n  newm.TOT = ckmem                    /* new stem with member name   */\nEnd\nIf TOT = 0 then do                    /* no valid members in PDS     */\n  Say 'ERROR - No valid MEMBERS found in' dsn'.' /* issue error msg  */\n  Exit 12                             /* exit RC=12                  */\nEnd\n/******************************************/\n/* allocate input files                   */\n/******************************************/\nDo alloc = 1 to tot\n  \"ALLOC FI(\"newm.alloc\") DA('\"dsn\"(\"newm.alloc\")') SHR REUSE\"\nEnd\n/******************************************/\n/* read input file into stem variables    */\n/******************************************/\nDo rd = 1 to tot\n  \"EXECIO 1 DISKR\" newm.rd \"(STEM\" Substr(newm.rd,2,4) \"FINIS\"\nEnd\n/******************************************/\n/* queue records to the stack             */\n/******************************************/\nDo q1  = 1 to tot\n  Interpret Queue ' 'Substr(newm.q1,2,4) || 1\nEnd\n/******************************************/\n/* need to remove some blanks so the      */\n/* output will fit in 80 columns.         */\n/******************************************/\nDo J = 1 to tot\n  pull lpar\n  parse var LPAR ipldate ipltime iplvol . ipladdr iplparm\n  LastIPL.J = ipldate ipltime iplvol 'LOAD' || ipladdr || iplparm\nEnd\n/******************************************/\n/* Queue output                           */\n/******************************************/\nQueue '      L A S T    I P L    I N F O R M A T I O N' ,\n      '  -   A L L    L P A R S'\nQueue Copies('-',78)\n\nDo q2 = 1 to tot\n  Queue Substr(newm.q2,2,4)':' LastIPL.q2\nEnd\n/******************************************/\n/* Display output                         */\n/******************************************/\nIf Sysvar('SYSISPF')='ACTIVE' then do\n  ddnm = 'DD'||random(1,99999)    /* choose random ddname  */\n  junk = msg(off)\n  \"ALLOC FILE(\"||ddnm||\") UNIT(SYSALLDA) NEW TRACKS SPACE(1,1)\",\n  \" DELETE REUSE LRECL(80) RECFM(F B) BLKSIZE(3120)\"\n  junk = msg(on)\n\n  \"EXECIO\"  Queued()  \"DISKW\" ddnm \"(FINIS\"\n\n  address ISPEXEC \"LMINIT DATAID(TEMP) DDNAME(\"||ddnm||\")\"\n  address ISPEXEC \"BROWSE DATAID(\"||temp\")\"\n  address ISPEXEC \"LMFREE DATAID(\"||temp\")\"\n  junk = msg(off)\n  \"FREE FI(\"||ddnm||\")\"\nEnd\nElse do queued()\n Parse pull line\n Say line\nEnd\n/******************************************/\n/* Free files                             */\n/******************************************/\njunk = msg(off)\nDo free = 1 to tot\n  \"FREE FI(\"newm.free\")\"\nEnd\nExit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LINEMAC": {"ttr": 5646, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x009\\x00\\x992/\\x00\\x992/\\x16'\\x00\\x17\\x00\\x17\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf2\\xf2@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "1999-11-18T16:27:39", "lines": 23, "newlines": 23, "modlines": 0, "user": "CBT422"}, "text": "/* REXX */\n/*                                                    */\n/* AUTHOR: Mark Zelden                                */\n/* Implement DB, DT, ZB, ZE, & ZV line commands.      */\n/*                                                    */\nAddress ISREDIT\n\"MACRO (parm) NOPROCESS\"\nAddress ISPEXEC \"CONTROL ERRORS RETURN\"\nIf parm <> 'DB' & parm <> 'DT' & parm <> 'ZB' & ,\n   parm <> 'ZE' & parm <> 'ZV' then do\n  zedtpcmd=parm\n  Address ISPEXEC \"SETMSG MSG(ISRE041)\"\n  Exit  8             /* let ISPF handle the error */\nEnd\nSelect\n  When parm = 'ZB' then parm2 = 'ZBROWSE'\n  When parm = 'ZV' then parm2 = 'ZVIEW'\n  When parm = 'ZE' then parm2 = 'ZEDIT'\n  Otherwise parm2 = parm\nEnd\n\"PROCESS RANGE\" parm\nInterpret call parm2\nExit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LINETBL": {"ttr": 5648, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x12\\x17\\x0f\\x01\\x12\\x17\\x0f\\x100\\x00\\x06\\x00\\x06\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-06-18T00:00:00", "modifydate": "2012-06-18T10:30:00", "lines": 6, "newlines": 6, "modlines": 0, "user": "CBT484"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "LMPREXX": {"ttr": 5889, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x052/\\x01\\x052/\\t\\x00\\x01\\x9a\\x01\\x9a\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-11-18T00:00:00", "modifydate": "2005-11-18T09:00:00", "lines": 410, "newlines": 410, "modlines": 0, "user": "CBT470"}, "text": "/* REXX */\n/*                                       */\n/* AUTHOR: Mark Zelden                   */\n/*                                       */\n/*********************************************************************/\n/* LMPREXX:                                                          */\n/*                                                                   */\n/* This edit macro will do the following:                            */\n/*                                                                   */\n/* 1) Create a KEYSOLD member from the member being edited.          */\n/* 2) Append keys from the KEYSNEW member into member being edited.  */\n/* 3) Check for duplicates and only keep the more current one.       */\n/* 4) Write the duplicates to the KEYSDUP member.                    */\n/* 5) Write expired keys to the KEYSDUP member. Expired keys are     */\n/*    also removed from the original file, but can optionally be     */\n/*    kept if the \"KEEPEXP\" parameter is used at invocation.         */\n/*                                                                   */\n/*  Duplicate keys are defined as keys that have the same PROD(nn)   */\n/*  code and the same last 4 characters of the CPU serial number.    */\n/*                                                                   */\n/* NOTE:  This macro will not automatically save the data being      */\n/*        edited.  However, since the data will most likely          */\n/*        be changed the data will be saved if you type END or       */\n/*        use the END PFK. This also depends on your profile         */\n/*        settings for AUTOSAVE.                                     */\n/*********************************************************************/\n/* The KEYS for the member being edited and the keys in the KEYSNEW  */\n/* member must start in column 1 and look similar to this:           */\n/*                                                                   */\n/* *---+----1----+----2----+----3----+----4----+----5----+----6----+ */\n/* Prod(nn) Date(ddmthyy) CPU(nnnn-nnn /ssssss) LMPCODE(...          */\n/*                                                                   */\n/*********************************************************************/\n/* Execution Syntax:                                                 */\n/*                                                                   */\n/*  LMPREXX            (delete dups and expired keys)                */\n/*  LMPREXX KEEPEXP    (delete dups but keep expired keys)           */\n/*********************************************************************/\nADDRESS ISREDIT\n\"MACRO (opt)\"\nopt = Translate(opt) /* force upper case */\nIf opt <> '' & opt <> 'KEEPEXP' then do\n  zedsmsg = 'Invalid Option -' opt\n  zedlmsg = 'Invalid option specified. The only valid option is',\n            '\"KEEPEXP\".'\n  Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n  Exit 12\nEnd\n/*********************************************************************/\n/* House Keeping                                                     */\n/*********************************************************************/\n\"(status) = USER_STATE\"         /* save current settings  */\n\"(lastln) = LINENUM .ZLAST\"     /* last data line         */\n\"(lmpdsn) = DATASET\"            /* cur data set name      */\n\"BOUNDS\"                        /* reset bounds           */\n\"RESET EXCLUDED\"                /* reset exclude status   */\nCall RDATE TODAY                /* get today's  \"NDATE\"   */\nNTODAY = Substr(RESULT,16,5)    /* num days since 1900    */\n/*********************************************************************/\n/* Create KEYSOLD backup member                                      */\n/*********************************************************************/\n\"REPLACE KEYSOLD 1\" lastln\n/*********************************************************************/\n/* Append additions from KEYSNEW into member being edited            */\n/*********************************************************************/\n\"COPY KEYSNEW AFTER\" lastln\n/*********************************************************************/\n/* SORT RECORDS  - By CPU serial number and by KEY                   */\n/*********************************************************************/\n\"SORT 40 44 5 9\"\n/*********************************************************************/\n/* Duplicate check                                                   */\n/*********************************************************************/\nCURRLN   = 1       /* current line number      */\nDUPCOUNT = 0       /* count of duplicate lines */\nKEYCOL1  = 5       /* start col for key check  */\nKEYCOL2  = 9       /* end col for key check    */\nCPUCOL1  = 40      /* start col for cpu check  */\nCPUCOL2  = 44      /* end col for cpu check    */\n/*  */\nDo while currln < lastln\n  \"(data1) = LINE \"currln              /* data1 = current line       */\n  key1  =  Substr(data1,keycol1,keycol2-keycol1+1)  /* extract key   */\n  cpu1  =  Substr(data1,cpucol1,cpucol2-cpucol1+1)  /* extract CPU   */\n  nextln = currln + 1                  /* bump up line counter       */\n  \"(data2) = LINE \"nextln              /* data2 = next line          */\n  key2  =  Substr(data2,keycol1,keycol2-keycol1+1)   /* extract key  */\n  cpu2  =  Substr(data2,cpucol1,cpucol2-cpucol1+1)   /* extract CPU  */\n  If KEY1 == KEY2 & CPU1 == CPU2 then do   /* duplicate              */\n    dupcount = dupcount + 1                /* add 1 to dupcount      */\n    dateYY1  = '20' || Substr(data1,20,2)  /* extract year           */\n    dateDD1  = Substr(data1,15,2)          /* extract day            */\n    dateMTH1 = Substr(data1,17,3)          /* extract month          */\n    dateYY2  = '20' || Substr(data2,20,2)  /* extract year           */\n    dateDD2  = Substr(data2,15,2)          /* extract day            */\n    dateMTH2 = Substr(data2,17,3)          /* extract month          */\n    Call MTH_to_MM dateMTH1    /* convert MTH to numeric month       */\n    dateMM1 = RESULT            /* answer from MTH_to_MM             */\n    Call MTH_to_MM dateMTH2    /* convert MTH to numeric month       */\n    dateMM2 = RESULT            /* answer from MTH_to_MM             */\n    Call RDATE dateMM1 dateDD1 dateYY1 /* call RDATE to get \"NDATE\"  */\n    keydate1 = Substr(RESULT,16,5) /* num days since 1900            */\n    Call RDATE dateMM2 dateDD2 dateYY2 /* call RDATE to get \"NDATE\"  */\n    keydate2 = Substr(RESULT,16,5) /* num days since 1900            */\n    If keydate1 <= keydate2 then do   /* nextln is a newer key       */\n      dup.dupcount = data1            /* save the data for later     */\n      \"ISREDIT XSTATUS \"currln\" = X\"  /* exclude this line           */\n    End /* if keydate1 */\n    Else do                           /* currln is a newer key       */\n      dup.dupcount = data2            /* save the data for later     */\n      \"ISREDIT XSTATUS \"nextln\" = X\"  /* exclude this line           */\n    End /* else do */\n    currln = currln + 1               /* bump up currln counter      */\n  End /* If KEY1 == KEY2 */\n  Else  currln = currln + 1 /* no dup found - loop */\nEnd   /* do while currln < lastln */\n/*********************************************************************/\n/* End duplicate check                                               */\n/*********************************************************************/\n\"DELETE ALL EXCLUDED\"  /* end dup search - delete all excl. lines    */\n\"(lastln) = LINENUM .ZLAST\"     /* last data line                    */\n/*********************************************************************/\n/* Expired check                                                     */\n/*********************************************************************/\nCURRLN   = 1       /* current line number      */\nEXPCOUNT = 0       /* count of duplicate lines */\nDo while currln < lastln\n  \"(data3) = LINE \"currln                  /* data3 = current line   */\n  dateYY3  = '20' || Substr(data3,20,2)    /* extract year           */\n  dateDD3  = Substr(data3,15,2)            /* extract day            */\n  dateMTH3 = Substr(data3,17,3)            /* extract month          */\n  Call MTH_to_MM dateMTH3      /* convert MTH to numeric month       */\n  dateMM3 = RESULT              /* answer from MTH_to_MM             */\n  Call RDATE dateMM3 dateDD3 dateYY3  /* call RDATE to get \"NDATE\"   */\n  keydate3 = Substr(RESULT,16,5)      /* num days since 1900         */\n  If keydate3 <= ntoday then do       /* key is expired              */\n    \"ISREDIT XSTATUS \"currln\" = X\"    /* exclude this line           */\n    expcount = expcount + 1           /* add 1 to expcount           */\n    exp.expcount = data3              /* save the data for later     */\n  End\n  currln = currln + 1                 /* bump up currln counter      */\nEnd   /* do while currln < lastln */\n/*********************************************************************/\n/* End expired check                                                 */\n/*********************************************************************/\nIf opt <> 'KEEPEXP' then ,   /* \"KEEPEXP\" not specified,             */\n  \"DELETE ALL EXCLUDED\"      /*  delete all excluded lines           */\n\"(lastln) = LINENUM .ZLAST\"     /* last data line                    */\n/*********************************************************************/\n\"RESET\"                  /* issue RESET command                      */\n\"USER_STATE = (status)\"  /* restore saved settings including bounds  */\n\"UP MAX\"                 /* move display to first line               */\n/*********************************************************************/\nAddress ISPEXEC\nIf dupcount = 0 & expcount = 0 then do\n  zedsmsg = 'No duplicate/expired keys'\n  zedlmsg = 'No duplicate or expired keys were found in the file.'\n  \"SETMSG MSG(ISRZ000)\"  /* msg - no alarm */\n  Exit 0\nEnd\nElse do\n  Call Write_Dups  /* create KEYSDUP member with duplicates   */\n  lastln = Format(lastln) /* remove leading zeros */\n  zedsmsg = dupcount 'key(s) deleted.'\n  If opt = 'KEEPEXP' then ,   /* \"KEEPEXP\" specified          */\n    zedlmsg = dupcount 'duplicate key(s) were deleted and',\n              'written to the KEYSDUP member.' expcount 'expired' ,\n              'key(s) were also written and not deleted.' ,\n              lastln' keys were kept in the file.'\n  Else ,\n    zedlmsg = dupcount 'duplicate key(s) were deleted and',\n              'written to the KEYSDUP member.' expcount 'expired' ,\n              'key(s) were also written and deleted.' ,\n              lastln' keys were kept in the file.'\n  \"SETMSG MSG(ISRZ000)\"  /* msg - no alarm */\n  Exit 0\nEnd\n/*********************************************************************/\n/*  End of main code                                                 */\n/*********************************************************************/\n/*  Start of sub-routines                                            */\n/*********************************************************************/\nMTH_to_MM:   /* convert MTH to numeric MM value                      */\nParse upper arg MTH\nSelect\n  When MTH = 'JAN' then MM = '01'\n  When MTH = 'FEB' then MM = '02'\n  When MTH = 'MAR' then MM = '03'\n  When MTH = 'APR' then MM = '04'\n  When MTH = 'MAY' then MM = '05'\n  When MTH = 'JUN' then MM = '06'\n  When MTH = 'JUL' then MM = '07'\n  When MTH = 'AUG' then MM = '08'\n  When MTH = 'SEP' then MM = '09'\n  When MTH = 'OCT' then MM = '10'\n  When MTH = 'NOV' then MM = '11'\n  When MTH = 'DEC' then MM = '12'\n  Otherwise MM = '??'         /* Error - should not happen       */\nEnd /* select */\nReturn MM\n\nWrite_Dups:   /* write duplicates to KEYSDUP member              */\nAddress TSO\n\"ALLOC FI(DUPS) DA('\" || lmpdsn || \"(KEYSDUP)') SHR REUSE\"\nQueue '/********************************************************/'\nQueue '/* The following duplicate keys were found and deleted. */'\nQueue '/********************************************************/'\nDo I = 1 to dupcount\n  Queue dup.i\nEnd\nIf opt = 'KEEPEXP' then do /* \"KEEPEXP\" specified          */\n  Queue '/********************************************************/'\n  Queue '/* The following expired keys were found (but kept).    */'\n  Queue '/********************************************************/'\nEnd\nElse Do\n  Queue '/********************************************************/'\n  Queue '/* The following expired keys were found and deleted.   */'\n  Queue '/********************************************************/'\nEnd\nDo I = 1 to expcount\n  Queue exp.i\nEnd\nQueue ''  /* null queue to end stack   */\n\"EXECIO * DISKW DUPS (FINIS\"\n\"FREE  FI(DUPS)\"\nReturn\n\nRDATE:\n/*                                       */\n/* AUTHOR: Mark Zelden                   */\n/*                                       */\n/************************************************/\n/* Convert MM DD YYYY , YYYY DDD, or NNNNN to   */\n/* standard date output that includes the day   */\n/* of the week and the number of days (NNNNN)   */\n/* from January 1, 1900. This is not the same   */\n/* as the Century date!                         */\n/*                                              */\n/* A parm of \"TODAY\" can also be passed to      */\n/* the date conversion routine.                 */\n/* MM DD YYYY can also be specifed as           */\n/* MM/DD/YYYY or MM-DD-YYYY.                    */\n/*                                              */\n/* The output format is always as follows:      */\n/*      MM/DD/YYYY.JJJ NNNNN WEEKDAY            */\n/*                                              */\n/* The above value will be put in the special   */\n/* REXX variable \"RESULT\"                       */\n/* example: CALL RDATE TODAY                    */\n/* example: CALL RDATE 1996 300                 */\n/* example: CALL RDATE 10 26 1996               */\n/* example: CALL RDATE 10/26/1996               */\n/* example: CALL RDATE 10-26-1996               */\n/* example: CALL RDATE 35363                    */\n/* result:  10/26/1996.300 35363 Saturday       */\n/************************************************/\narg P1 P2 P3\n\nIf Pos('/',P1) <> 0 | Pos('-',P1) <> 0 then do\n  PX =  Translate(P1,'  ','/-')\n  Parse var PX P1 P2 P3\nEnd\n\nJULTBL = '000031059090120151181212243273304334'\nDAY.0 = 'Sunday'\nDAY.1 = 'Monday'\nDAY.2 = 'Tuesday'\nDAY.3 = 'Wednesday'\nDAY.4 = 'Thursday'\nDAY.5 = 'Friday'\nDAY.6 = 'Saturday'\n\nSelect\n  When P1 = 'TODAY' then do\n    CURDATE = date('s')\n    P1 = Substr(CURDATE,5,2)\n    P2 = Substr(CURDATE,7,2)\n    P3 = Substr(CURDATE,1,4)\n    call CONVERT_MDY\n    call THE_END\n  end\n  When P2 = '' & P3 = '' then do\n    call CONVERT_NNNNN\n    call THE_END\n  end\n  When P3 = '' then do\n    call CONVERT_JDATE\n    call DOUBLE_CHECK\n    call THE_END\n  end\n  otherwise do\n    call CONVERT_MDY\n    call DOUBLE_CHECK\n    call THE_END\n  end\nend /* end select */\n/* say RDATE_VAL; exit 0  */\nreturn RDATE_VAL\n/**********************************************/\n/*  E N D    O F   M A I N L I N E   C O D E  */\n/**********************************************/\n\nCONVERT_MDY:\nif P1<1 | P1>12 then do\n  say 'Invalid month passed to date routine'\n  exit 12\nend\nif P2<1 | P2>31 then do\n  say 'Invalid day passed to date routine'\n  exit 12\nend\nif (P1=4 | P1=6 | P1=9 | P1=11) & P2>30 then do\n  say 'Invalid day passed to date routine'\n  exit 12\nend\nif P3<1900 | P3>2099 then do\n  say 'Invalid year passed to date routine'\n  exit 12\nend\nBASE   = Substr(JULTBL,((P1-1)*3)+1,3)\nif (P3//4=0 & P3<>1900) then LEAP= 1\n  else LEAP = 0\nif P1 > 2 then BASE = BASE+LEAP\nJJJ = BASE + P2\n\nMM   = P1\nDD   = P2\nYYYY = P3\nreturn\n\nCONVERT_NNNNN:\nif P1<1 | P1>73049 then do\n  say 'Invalid date passed to date routine. NNNNN must be 1-73049'\n  exit 12\nend\n/* Determine YYYY and JJJ */\nif P1>365 then P1=P1+1\nYEARS_X4=(P1-1)%1461\nJJJ=P1-YEARS_X4*1461\nEXTRA_YEARS=(JJJ*3-3)%1096\nJJJ=JJJ-(EXTRA_YEARS*1096+2)%3\nYYYY=YEARS_X4*4+EXTRA_YEARS+1900\nP1 = YYYY ; P2 = JJJ ;  call CONVERT_JDATE\n\nCONVERT_JDATE:\nif P1<1900 | P1>2099 then do\n  say 'Invalid year passed to date routine'\n  exit 12\nend\nif P2<1 | P2>366 then do\n  say 'Invalid Julian date passed to date routine'\n  exit 12\nend\nif (P1//4=0 & P1<>1900) then LEAP= 1\n  else LEAP = 0\nADJ1 = 0\nADJ2 = 0\nDo MM = 1 to 11\n   VAL1 = Substr(JULTBL,((MM-1)*3)+1,3)\n   VAL2 = Substr(JULTBL,((MM-1)*3)+4,3)\n   if MM >=2 then ADJ2 = LEAP\n   if MM >=3 then ADJ1 = LEAP\n   if P2 > VAL1+ADJ1 & P2 <= VAL2+ADJ2 then do\n        DD = P2-VAL1-ADJ1\n        MATCH = 'Y'\n        leave\n   end\nend\nif MATCH <> 'Y' then do\n    MM = 12\n    DD = P2-334-LEAP\nend\n\nYYYY = P1\nJJJ  = P2\nreturn\n\nDOUBLE_CHECK:\nif MM = 2 then do\n   if DD > 28 & LEAP = 0 then do\n     say 'Invalid day passed to date routine'\n     exit 12\n   end\n   if DD > 29 & LEAP = 1 then do\n     say 'Invalid day passed to date routine'\n     exit 12\n   end\nend\nif LEAP = 0 & JJJ > 365 then do\n  say 'Invalid Julian date passed to date routine'\n  exit 12\nend\nreturn\n\nTHE_END:\nYR_1900 = YYYY-1900\nNNNNN = (YR_1900*365) +(YR_1900+3)%4 + JJJ\nif YYYY > 1900 then NNNNN = NNNNN-1\nINDEX   = NNNNN//7  /* index to DAY stem */\nWEEKDAY =  DAY.INDEX\n\nDD      = Right(DD,2,'0')\nMM      = Right(MM,2,'0')\nYYYY    = Strip(YYYY)\nNNNNN   = Right(NNNNN,5,'0')\nJJJ     = Right(JJJ,3,'0')\n\nRDATE_VAL = MM||'/'||DD||'/'||YYYY||'.'||JJJ||' '||NNNNN||' '||WEEKDAY\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LNKVER": {"ttr": 5896, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00G\\x00\\x992/\\x00\\x992/\\x16'\\x01\\xf1\\x01\\xf1\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf2\\xf2@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "1999-11-18T16:27:47", "lines": 497, "newlines": 497, "modlines": 0, "user": "CBT422"}, "text": "/* REXX */\n/*                           */\n/* AUTHOR: MARK ZELDEN       */\n/*                           */\n/**************************************************************/\n/* LINK LIST LIBRARIES Checker REXX Exec                      */\n/**************************************************************/\n/* This REXX exec checks for invalid syntax (missing / extra  */\n/* commas), for data sets not cataloged in the master         */\n/* catalog, invalid link list datasets (not a PDS or RECFM=U) */\n/* and the concatenation algorithm:                           */\n/*    (32) + (16n) + (k-1)                                    */\n/*      n = the number of DASD extents (PDS/E counts as 1)    */\n/*      k = the number of data set in the link list           */\n/* The result of the algorithm cannot exceed 2040             */\n/*                                                            */\n/* If running DFSMS/MVS 1.3 or later, then the only           */\n/* restriction is that the total number of extents must not   */\n/* not exceed 255.                                            */\n/**************************************************************/\n/* EXECUTION SYNTAX:                                          */\n/*                                                            */\n/* TSO %LNKVER < IEASYSxx | LNKLSTxx > (option)               */\n/*                                                            */\n/* - The first parm is the IEASYSxx name that                 */\n/*   will be used to build the link list in SYS1.PARMLIB,     */\n/*   or a LNKLSTxx member name in SYS1.PARMLIB.               */\n/*   The default is IEASYS00                                  */\n/*                                                            */\n/*   Valid options are: NODETAIL and DETAIL                   */\n/*   The default is NODETAIL                                  */\n/*                                                            */\n/* EXAMPLES:                                                  */\n/* TSO %LNKVER                                                */\n/* TSO %LNKVER LNKLST00                                       */\n/* TSO %LNKVER IEASYS01 DETAIL                                */\n/*                                                            */\n/*  Any errors encountered are displayed on the terminal      */\n/*  along with a short summary at the end. If the \"DETAIL\"    */\n/*  option is used, an extent summary by data set is also     */\n/*  displayed.                                                */\n/*                                                            */\n/**************************************************************/\n /* Trace ?R   */\n /* Trace ?I   */\n /* Trace err  */\nArg MEMNAME OPTION\n/*                                                 */\n/*  Verify input parameters                        */\n/*                                                 */\nIf MEMNAME = '' then MEMNAME = 'IEASYS00'\nIf Index(MEMNAME,'LNKLST') = 0 & Index(MEMNAME,'IEASYS') = 0 then do\n  Say 'INVALID SYS1.PARMLIB MEMBER SPECIFIED'\n  Say 'IF SPECIFIED, THE MEMBER NAME MUST BE EITHER IEASYSxx' ,\n      'OR LNKLSTxx'\n  Say 'EXAMPLE:  TSO %LNKVER'\n  Say 'EXAMPLE:  TSO %LNKVER LNKLST00'\n  Say 'EXAMPLE:  TSO %LNKVER IEASYS00 DETAIL'\n  Exit 12\nEnd\nIf OPTION <> 'DETAIL' & OPTION <>'NODETAIL' & OPTION <> '' then do\n  Say 'INVALID OPTION SPECIFIED'\n  Say 'OPTION MUST BE \"NODETAIL\" (DEFAULT) OR \"DETAIL\"'\n  Say 'EXAMPLE:  TSO %LNKVER'\n  Say 'EXAMPLE:  TSO %LNKVER LNKLST00'\n  Say 'EXAMPLE:  TSO %LNKVER IEASYS00 DETAIL'\n  Exit 12\nEnd\nIf OPTION = '' then OPTION = 'NODETAIL'\n/*                                                 */\n/*  Build Library List to verify                   */\n/*                                                 */\nCall MEMBER_CHECK MEMNAME\nCall READ_FILE MEMNAME\nIf Index(MEMNAME,'LNKLST') <> 0 then do  /* LNKLSTxx specified */\n  Call FIND_COMMENTS\n  Call CHECK_COMMAS\n  LIBREC.0 = INREC.0\n  Do I = 1 to LIBREC.0\n    LIBREC.I = INREC.I\n  End\n  Say 'LINK LIST VERIFICATION WILL USE THE FOLLOWING MEMBER:' MEMNAME\n  Call VERIFY_LIST\nEnd\n/*                                                 */\n/*  IEASYSxx is specified, check members and       */\n/*  build library list                             */\n/*                                                 */\nElse do\n  Do I = 1 to INREC.0  /* look for LNK= in IEASYSxx */\n    If Index(INREC.I,'LNK=') = 0 then iterate\n    Else do\n      SRCH  = INREC.I\n      Leave\n    End\n  End\n  STRTLIST = Index(SRCH,'LNK=')\n  If Substr(SRCH,STRTLIST+4,1) = '(' then do\n    /*                                                 */\n    /* Multi LNK=(xx,xx,xx) specified in IEASYSxx      */\n    /*                                                 */\n    ENDLIST = Index(SRCH,')',STRTLIST+4)\n    If ENDLIST = 0 then do   /* LNK = spans more than one line  */\n      ENDLIST = Index(SRCH,', ',STRTLIST+4)\n      LIST    = Substr(SRCH,STRTLIST+5,ENDLIST-STRTLIST-5)\n      Do Forever  /* loop to find end of LNK= specifications */\n        I = I+1   /* increment record count */\n        SRCH2 = INREC.I\n        STRTLST2 = Wordindex(SRCH2,1)\n        ENDLIST2 = Index(SRCH2,')',STRTLST2)\n        If ENDLIST2 = 0 then do /* end of list not found */\n          ENDLIST2 = Index(SRCH2,', ',STRTLST2)\n          LIST2 = Substr(SRCH2,STRTLST2,ENDLIST2-STRTLST2)\n          LIST = LIST LIST2\n          Iterate  /* get another record */\n        End\n        Else do  /* end of list found */\n          LIST2 = Substr(SRCH2,STRTLST2,ENDLIST2-STRTLST2)\n          LIST = LIST LIST2\n          Leave  /* exit do forever loop */\n        End\n      End  /* do forever */\n    End  /* if ENDLIST = 0 */\n    Else /* LNK = is on one line only */\n      LIST = Substr(SRCH,STRTLIST+5,ENDLIST-STRTLIST-5)\n    LIST = Translate(LIST,' ',',')    /* remove commas              */\n    NUMONLST = Words(LIST)            /* number of LNKLSTxx members */\n    If word(list,numonlst) = 'L' then do\n      numonlst = numonlst-1\n      LIST = Translate(LIST,' ','L ') /* remove last \"L \"           */\n    End\n    LIBREC.0 = 0                      /* initialize variable        */\n    Do J = 1 to NUMONLST\n      MEM.J   = 'LNKLST' || WORD(LIST,J) /* LNKLSTxx mbr name       */\n      Call MEMBER_CHECK MEM.J\n      Call READ_FILE MEM.J\n      Call FIND_COMMENTS\n      Call CHECK_COMMAS\n      Do I = 1 to INREC.0\n        LIBNUM        = LIBREC.0 + I\n        LIBREC.LIBNUM = INREC.I\n      End\n      LIBREC.0 = LIBREC.0 + INREC.0\n    End\n    Say 'LINK LIST VERIFICATION WILL USE THE FOLLOWING',\n         MEMNAME 'SUFFIXES:'\n    Say  LIST\n    Call VERIFY_LIST\n  End\n  /*                                                 */\n  /* Single LNK=xx specified in IEASYSxx             */\n  /*                                                 */\n  Else do\n    SUF     =  Substr(SRCH,STRTLIST+4,2)\n    CURMBR  = 'LNKLST' || SUF\n    Call MEMBER_CHECK CURMBR\n    Call READ_FILE CURMBR\n    Call FIND_COMMENTS\n    Call CHECK_COMMAS\n    LIBREC.0 = INREC.0\n    Do I = 1 to LIBREC.0\n      LIBREC.I = INREC.I\n    End\n    Say 'LINK LIST VERIFICATION WILL USE THE FOLLOWING',\n         MEMNAME 'SUFFIX:' SUF\n    Call VERIFY_LIST\n  End\nEnd\n/*                                                 */\n/*  Done processing libraries - check              */\n/*  concatentation algorithm, write totals,        */\n/*  and exit.                                      */\n/*                                                 */\nIf Substr(FMIDNUM,4,4) < 6602 &  ALG > 2040 then do\n  Say 'ERROR - THE LNKLST CONCATENATION ALGORITHM EXCEEDED 2040'\n  Say '           '\n  ALGERR = 'TRUE'\nEnd\nElse if EXTENTS > 255 then do\n  Say 'ERROR - THE NUMBER OF EXTENTS EXCEEDED 255'\n  Say '           '\n  ALGERR = 'TRUE'\nEnd\nSay '                   S U M M A R Y                    '\nSay '----------------------------------------------------'\nIf ALGERR = 'TRUE' then\n  Say '   TOTAL ERRORS     =' ERRCNT + 1\nElse\n  Say '   TOTAL ERRORS     =' ERRCNT\nSay '   TOTAL LIBRARIES  =' TOTLIBS - ERRCNT\nIf Substr(FMIDNUM,4,4) < 6602 then do\n  Say '   TOTAL EXTENTS    =' EXTENTS\n  Say '   ALGORITHM RESULT =' ALG ' (CAN''T BE > 2040)    '\nEnd\nElse do\n  Say '   TOTAL EXTENTS    =' EXTENTS ' (CAN''T BE > 255)'\n  Say '   ALGORITHM RESULT =' ALG\nEnd\nSay '           '\nIf OPTION = 'DETAIL' then do\n    Say ' NUM  EXT   ALG   VOLUME  LNKLST LIBRARY'\n    Say ' EXT  TOTL  TOTL  SERIAL  DATA SET NAME'\n    Say ' ---  ----  ----  ------  ----------------------' || ,\n        '--------------------'\n  Do I = 1 to TOTLIBS\n    Say '' Right(EXT.I,3) '' Right(EXTT.I,4) '' Right(TOT.I,4)  ,\n            '' Right(VOL.I,6)  '' LIB.I\n  End\nEnd\nIf ERRCNT = 0 then Exit 0\n  else Exit 12\n/********************************************************************/\n/*              S  U  B  R  O  U  T  I  N  E  S                     */\n/********************************************************************/\n/*                                                 */\n/*  Subroutine to verify LINK LIST libraries       */\n/*                                                 */\nVERIFY_LIST:\nSay 'BEGINNING VERIFICATION OF LINK LIST - PLEASE WAIT...'\nSay '                 '\n/*                                            */\n/*  Initilize variables                       */\n/*                                            */\nNUMRECS = LIBREC.0 /* total recs in LINKLST   */\nTEMPTOT = 0        /* specified libs to check */\nTOTLIBS = 0        /* total libs to check     */\nERRCNT  = 0        /* total libs with errors  */\nEXTENTS = 0        /* total number of extents */\nALG     = 32 - 1   /* part of concat algorithm*/\n/*                                            */\n/*  Determine Master Catalog data set name    */\n/*  and operating system FMID                 */\n/*                                            */\nCVT      = C2d(Storage(10,4))\nAMCBS    = C2d(Storage(D2x(CVT + 256),4))\nACB      = C2d(Storage(D2x(AMCBS + 8),4))\nCAXWA    = C2d(Storage(D2x(ACB + 64),4))\nMCATDSN  = Storage(D2x(CAXWA + 52),44)\nMCATDSN  = Strip(MCATDSN,T)\nFMIDNUM  = Storage(D2x(CVT - 32),7)\nIf Substr(FMIDNUM,4,1) < 6 then VOLSOK = 'N'\n Else VOLSOK = 'Y'   /* OK to use VOLSERs if OS/390 */\n/*                                                 */\n/*  Put a list of all library names to check in    */\n/*  the \"LIB.\" stem variable.                      */\n/*                                                 */\nDo I = 1 to NUMRECS\n  REC = Substr(LIBREC.I,1,71)\n  REC = Translate(REC,' ',',')\n  Call CHECK_COMMENTS\n  NUMONREC = Words(REC)\n  Do J = 1 to NUMONREC\n     TEMPTOT = TEMPTOT + 1\n     TEMPLIB.TEMPTOT = Word(REC,J)\n  End\nEnd\n/*                                                 */\n/*  Automatically include default libraries        */\n/*                                                 */\nLIB.1 = 'SYS1.LINKLIB'\nLIB.2 = 'SYS1.MIGLIB'\nLIB.3 = 'SYS1.CSSLIB'\nTOTLIBS = 3\n/*                                                 */\n/*  Remove default libraries if they were          */\n/*  already specified in input parm member.        */\n/*                                                 */\nDo I = 1 to TEMPTOT\n  If TEMPLIB.I == 'SYS1.LINKLIB' | ,\n     TEMPLIB.I == 'SYS1.MIGLIB'  | ,\n     TEMPLIB.I == 'SYS1.CSSLIB'    ,\n     then iterate\n  Else Do\n     TOTLIBS     = TOTLIBS + 1\n     LIB.TOTLIBS = TEMPLIB.I\n  End\nEnd\nDo I = 1 to TOTLIBS\n  /*                                                    */\n  /* If OS/390, then VOLSERs ARE allowed in LNKLST      */\n  /*                                                    */\n  FIND1 = Index(LIB.I,'(')\n  Select\n    When  FIND1 <> 0 & VOLSOK = 'Y' then do\n      VOL.I  = Substr(LIB.I,FIND1+1,6)\n      LIB.I  = Substr(LIB.I,1,FIND1-1)\n      RETCODE = Listdsi(''''LIB.I'''' 'volume('VOL.I')'  NORECALL)\n      If RETCODE <> 0 then do\n        Say 'ERROR ENCOUNTERED WHILE VERIFYING THE FOLLOWING DATASET:'\n        Say LIB.I\n        If SYSREASON = 24 then do\n          Say LIB.I 'DOES NOT EXIST ON VOLUME 'VOL.I\n          LIB.I   = LIB.I  || ' ** IGNORED - NOT ON SPECIFIED VOL **'\n        End\n        Else do\n          Say SYSMSGLVL2\n          LIB.I   = LIB.I  || ' ** IGNORED' SYSMSGLVL2 '**'\n        End\n        Say '        '\n        ERRCNT = ERRCNT + 1\n        EXT.I   = 'ERR'\n        EXTT.I  = 'ERR'\n        TOT.I   = 'ERR'\n        VOL.I   = '*ERR*'\n        Iterate\n      End   /* if RETCODE <>0  */\n    End  /* when  FIND1 <>0  & VOLSOK ='Y' */\n    /*                                                    */\n    /* Not OS/390, VOLSERs ARE not allowed in LNKLST      */\n    /*                                                    */\n    When  FIND1 <> 0 & VOLSOK = 'N' then do\n      VOL.I  = Substr(LIB.I,FIND1+1,6)\n      LIB.I  = Substr(LIB.I,1,FIND1-1)\n      Say 'ERROR ENCOUNTERED WHILE VERIFYING THE FOLLOWING DATASET:'\n      Say LIB.I\n      Say 'VOLSERS ARE NOT ALLOWED IN THIS VERSION OF MVS'\n      Say '        '\n      ERRCNT = ERRCNT + 1\n      EXT.I   = 'ERR'\n      EXTT.I  = 'ERR'\n      TOT.I   = 'ERR'\n      LIB.I   = LIB.I  || ' ** IGNORED - VOLSER NOT ALLOWED **'\n      Iterate\n    End  /* when  FIND1 <>0  & VOLSOK ='N' */\n    /*                                                    */\n    /* VOLSERs are not coded                              */\n    /*                                                    */\n    When  FIND1 = 0 then do\n      /*                                                    */\n      /* See if Library is Cataloged                        */\n      /*                                                    */\n      RETCODE = Listdsi(''''LIB.I''''   NORECALL)\n      If RETCODE <> 0 then do\n        Say 'ERROR ENCOUNTERED WHILE VERIFYING THE FOLLOWING DATASET:'\n        Say LIB.I\n        If SYSREASON = 5 then do\n          Say 'DATA SET IS NOT CATALOGED'\n          LIB.I   = LIB.I  || ' ** IGNORED - NOT CATALOGED **'\n        End\n        Else do\n          Say SYSMSGLVL2\n          LIB.I   = LIB.I  || ' ** IGNORED' SYSMSGLVL2 '**'\n        End\n        Say '        '\n        ERRCNT = ERRCNT + 1\n        EXT.I   = 'ERR'\n        EXTT.I  = 'ERR'\n        TOT.I   = 'ERR'\n        VOL.I   = '*ERR*'\n        Iterate\n      End  /* if RETCODE <>0  */\n      VOL.I   = SYSVOLUME\n    /*                                                    */\n    /* Check to see if library is in the Master Catalog   */\n    /*                                                    */\n      junk=outtrap(LINE.)                    /* trap output */\n      Address TSO \"LISTCAT ENT('\"LIB.I\"')  CAT('\"MCATDSN\"')\"\n      junk=outtrap('off')                    /* trap off    */\n      If RC <> 0 then do\n        Say 'ERROR ENCOUNTERED WHILE VERIFYING THE FOLLOWING DATASET:'\n        Say LIB.I\n        Say 'DATA SET IS NOT CATALOGED IN THE MASTER CATALOG'\n        Say '        '\n        ERRCNT = ERRCNT + 1\n        EXT.I   = 'ERR'\n        EXTT.I  = 'ERR'\n        TOT.I   = 'ERR'\n        LIB.I   = LIB.I  || ' ** IGNORED - NOT IN MCAT **'\n      Iterate\n      End\n      If  SYSDSORG <> 'PO' | SYSRECFM <> 'U' then do\n        Say 'ERROR ENCOUNTERED WHILE VERIFYING THE FOLLOWING DATASET:'\n        Say LIB.I\n        Say 'DATA SET IS NOT A PDS OR IS NOT A LOADLIB'\n        Say '        '\n        ERRCNT = ERRCNT + 1\n        EXT.I   = 'ERR'\n        EXTT.I  = 'ERR'\n        TOT.I   = 'ERR'\n        LIB.I   = LIB.I  || ' ** IGNORED - NOT A PDS/LOADLIB  **'\n      Iterate\n      End\n    End  /* when  FIND1 = 0  */\n  End  /* select */\n  If  SYSUSED = 'N/A' then SYSEXTENTS = 1 /* PDS/E */\n    EXTENTS = EXTENTS + SYSEXTENTS\n    EXT.I   = SYSEXTENTS\n /* VOL.I   = SYSVOLUME  */\n    ALG     = ALG + (16 * EXT.I) + 1\n    TOT.I   = ALG\n    EXTT.I  = EXTENTS\n    If Substr(FMIDNUM,4,4) < 6602 & ,\n      ALG > 2040 then  LIB.I = LIB.I || ' ** IGNORED - ALG > 2040 **'\n    Else if,\n      EXTENTS > 255 then  LIB.I = LIB.I || ' ** IGNORED - # EXT > 255 **'\nEnd  /* do I = 1 to totlibs */\nReturn\n/*                                                 */\n/*  Subroutine to verify parmlib members           */\n/*                                                 */\nMEMBER_CHECK:\nArg CURMBR\nCHKMBR = Sysdsn('''SYS1.PARMLIB(' || CURMBR || ')''')\nIf  CHKMBR <> 'OK' then do\n  Say 'UNABLE TO LOCATE SYS1.PARMLIB(' || CURMBR || ')'\n  Exit 12\nEnd\nReturn\n/*                                                 */\n/*  Subroutine to read library members             */\n/*                                                 */\nREAD_FILE:\nArg CURMBR\n\"ALLOC DA('SYS1.PARMLIB(\"CURMBR\")') F(LNKMEM) SHR REUSE\"\nIf RC <> 0 then exit 12\n\"EXECIO * DISKR LNKMEM (STEM INREC. FINIS\"\n/* check for open error */\nIf RC <> 0 then do\n  Say 'ERROR OPENING DATASET SYS1.PARMLIB('CURMBR').'\n  Exit 12\nEnd\nReturn\n/*                                                 */\n/*  Subroutine to find comments at end of members  */\n/*                                                 */\nFIND_COMMENTS:\nDo  I = INREC.0 to 1 by -1\n  TEST = Word(INREC.I,1)\n  If Index(TEST,'/*') = 0 then leave\n  Else INREC.0 = INREC.0 - 1\nEnd\nReturn\n/*                                                 */\n/*  Subroutine to make sure last record in a       */\n/*  member does not end in a comma and that all    */\n/*  other records in a member does end in a comma. */\n/*                                                 */\nCHECK_COMMAS:\nNUMRECS = INREC.0\nLASTREC = Substr(INREC.NUMRECS,1,71)\nLEN     = Length(Strip(LASTREC,T))\nTEST    = Index(LASTREC,',',LEN)\nIf TEST <> 0 then do\n    Say 'LNKLST ERROR - THE LAST LIBRARY NAME (LINE' NUMRECS') DOES',\n        'NOT END IN A BLANK'\n    Say '(MEMBER' CURMBR')'\n    Say  LASTREC\n    Say 'VERIFICATION TERMINATED'\n    Exit 12\nEnd\nDo CHECK = 1 to NUMRECS - 1\n  REC     = Substr(INREC.CHECK,1,71)\n  Call CHECK_COMMENTS\n  LEN     = Length(Strip(REC,T))\n  TEST    = Index(REC,',',LEN)\n  If TEST = 0 then do\n    Say 'LNKLST ERROR - MISSING CONTINUATION ON LINE' CHECK ,\n        '(MEMBER' CURMBR')'\n    Say  REC\n    Say 'VERIFICATION TERMINATED'\n    Exit 12\n  End\nEnd\nReturn\nCHECK_COMMENTS:\n/****************************************/\n/* Look for comments. If they are on    */\n/* the same line as other data, remove  */\n/* them. If the entire line is comments,*/\n/* skip it. If there are not matching   */\n/* delimiters, flag it as an error.     */\n/****************************************/\nIf Pos('/*',REC) <> 0 then do\n  If Pos('*/',REC) = 0 then do\n    Say 'LNKLST ERROR - INVALID COMMENTS EXIST ON LINE' CHECK ,\n        '(MEMBER' CURMBR')'\n    Say  REC\n    Say 'VERIFICATION TERMINATED'\n    Exit 12\n  End\n  /* remove comments from record */\n  SCOM = Pos('/*',REC)  /* start col of comments */\n  ECOM = Pos('*/',REC)  /* end col of cumments */\n  REC = Overlay(' ',REC,SCOM,ECOM)\nEnd\nIf Pos('*/',REC) <> 0 then do\n  If Pos('/*',REC) =       0 then do\n    Say 'LNKLST ERROR - INVALID COMMENTS EXIST ON LINE' CHECK ,\n        '(MEMBER' CURMBR')'\n    Say  REC\n    Say 'VERIFICATION TERMINATED'\n    Exit 12\n  End\nEnd\nIf Pos('*/',REC) <> 0 | , /* check for mult comments */\n   Pos('/*',REC) <> 0 then call CHECK_COMMENTS\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOGRREXX": {"ttr": 6151, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04#\\x7f\\x01\\x16\\x13o\\t\\x15\\x00\\xef\\x00\\xad\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf9\\xf1@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-08-24T00:00:00", "modifydate": "2016-05-15T09:15:00", "lines": 239, "newlines": 173, "modlines": 0, "user": "CBT491"}, "text": "//USZCZT0R JOB (AD00),'#07B42 ZELDEN',\n//             NOTIFY=&SYSUID,\n//             CLASS=M,MSGCLASS=H,MSGLEVEL=(1,1)\n//**********************************************************\n//* This jobstream can be used to list all logstreams\n//* from the LOGGER Couple Data Set and generate\n//* delete/define cards from the list.\n//**********************************************************\n//*  List LOGSTREAMS from the LOGGER Couple Data Set\n//**********************************************************\n//LIST     EXEC PGM=IXCMIAPU\n//SYSABEND DD  SYSOUT=*\n//SYSPRINT DD  DSN=userid.LOGR.LIST,\n//             DISP=(NEW,CATLG,DELETE),\n//             UNIT=SYSALLDA,\n//             SPACE=(CYL,(5,5),RLSE),\n//             DCB=(LRECL=133,RECFM=FBA,BLKSIZE=0)\n//SYSIN    DD  *\n  DATA TYPE(LOGR) REPORT(NO)\n       LIST LOGSTREAM NAME(*) DETAIL(NO)\n/*\n//**********************************************************\n//*  COPY REXX PROGRAM TO A TEMPORARY PDS\n//**********************************************************\n//GENER     EXEC PGM=IEBGENER\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DUMMY\n//SYSUT2   DD  DSN=&&PDS(LOGRREXX),UNIT=SYSALLDA,\n//             DISP=(NEW,PASS,DELETE),\n//             SPACE=(TRK,(1,1,1)),\n//             DCB=(LRECL=80,BLKSIZE=3120,RECFM=FB,DSORG=PO)\n//SYSUT1    DD DATA,DLM=##\n/* REXX */\n/*                                       */\n/* AUTHOR: Mark Zelden                   */\n/*                                       */\n/* Last update:  05/15/2016              */\n/*                                       */\n/*********************************************************************/\n/*  05/15/2016 - add code to remove LS_ALLOCAHEAD(0) if system is    */\n/*               not z/OS 2.2. The parm is added to lower level      */\n/*               systems after OA44680 for z/OS 2.2 toleration.      */\n/*********************************************************************/\n/* This exec takes the output of a LIST LOGSTREAM command from the   */\n/* IXCMIAPU utility and creates DELETE/DEFINE cards for the listed   */\n/* logstreams.                                                       */\n/*                                                                   */\n/* If the program ends with RC=4, this means that there were pending */\n/* updates to one or more logstreams that are not reflected in the   */\n/* DEFINE cards generated from this program.  Those updates must be  */\n/* made manually if needed. Review the listing that was used as input*/\n/* and look for \"PENDING CHANGES\" to find the changes.               */\n/*********************************************************************/\nkept = 1 /* counter for kept define cards */\nCVT      = C2d(Storage(10,4))                /* point to CVT         */\nCVTOSLV6   = Storage(D2x(CVT + 1270),1)      /* Byte 6 of CVTOSLVL   */\nblanks = '                             '\n\"EXECIO  *  DISKR INDD (STEM INREC. FINIS\"  /* read input file       */\n/********************************************/\n/* Strip out everything but DEFINE cards    */\n/********************************************/\nDo i = 10 to inrec.0       /* start at record 10 to skip some output */\n   If Substr(inrec.i,1,1) = '1' then iterate    /* skip page header  */\n   If Substr(inrec.i,1,1) = '+' then iterate    /* skip page header  */\n   If Substr(inrec.i,2,7) = 'IXG005I' then iterate  /* skip header   */\n   If Substr(inrec.i,2,32) = blanks    then iterate  /* skip blanks  */\n   def.kept = Substr(inrec.i,5,115)   /* keep this card image        */\n   kept = kept+1                      /* add one to total kept       */\nEnd  /* do i */\nDrop inrec.           /* free storage, inrec. no longer needed       */\n/***************************************************/\n/* Add in DELETE/DEFINE cards for each logstream   */\n/***************************************************/\nDo add = 1 to kept-1\n  If Substr(def.add,1,9) = 'LOGSTREAM' then do\n    dsnend.add = Pos('STRUCTNAME',def.add) - 2   /* find end of dsn  */\n    Queue 'DELETE' Substr(def.add,1,dsnend.add)  /* delete card      */\n    Queue 'DEFINE' def.add                       /* define card      */\n    Iterate                                      /* get next card    */\n  End /* if substr */\n  Queue substr(def.add,9,110)  /* not 1st card, add \"as is\" to stack */\nEnd /* do add */\nDrop def.             /* free storage, def.  no longer needed        */\n/*********************************************************************/\n/* Assign new variable to all lines in the stack                     */\n/*********************************************************************/\ntotcards = queued()   /* find how many cards in current stack        */\nDo assign = 1 to totcards\n  Parse pull linenw1.assign                   /* get line from stack */\nEnd\n/*********************************************************************/\n/* Remove any keywords with null values, HLQ(NO_HLQ) / EHLQ(NO_EHLQ) */\n/* and check for DASDONLY(YES) logstreams and remove keywords        */\n/* that are not valid for DASDONLY(YES).                             */\n/*********************************************************************/\ntotdonly = 1 /* initialize counter of kept lines   */\nDo donly = 1 to totcards\n  If Substr(linenw1.donly,1,6) = 'DELETE' then do   /* don't need    */\n     linenw2.totdonly = linenw1.donly            /* to worry about   */\n     totdonly = totdonly + 1                     /* delete cards     */\n     Iterate  /* get next card */\n  End\n  Else do   /* until next DELETE card */\n    totdk = 1 /* init total keywords in define to 1 */\n    Do until donly >= totcards  /* loop until no more lines          */\n      If substr(linenw1.donly,1,6) = 'DELETE' then leave\n      defkwords.donly = words(linenw1.donly)  /* find out # keywords */\n      Do k = 1 to defkwords.donly\n        dkword.totdk = word(linenw1.donly,k)  /* current keyword     */\n        totdk = totdk + 1                     /* add 1 to total      */\n      End /* do k */\n      donly = donly + 1   /* bump up line counter */\n    End /* do until   */\n    /**************************************************************/\n    /* We now have all the define keywords parsed out. Check for  */\n    /* DASDONLY(YES) and remove keywords that are not valid for   */\n    /* DASDONLY logstreams.  Also remove any keywords with null   */\n    /* values and HLQ(NO_HLQ) / EHLQ(NO_EHLQ) keywords if they    */\n    /* exist.                                                     */\n    /**************************************************************/\n    dflag = 0   /* flag for a DASDONLY(YES) logstream  */\n    Do chk1 = 1 to totdk-1     /* loop to check for DASDONLY(YES) */\n      If dkword.chk1 = 'DASDONLY(YES)' then do     /* found       */\n         dflag = 1                                 /* set flag    */\n         Leave chk1  /* no need to continue to look, exit loop    */\n      End /* if dkword.chk1 */\n    End /* do chk1 */\n    If dflag = 0 then do    /* not a DASDONLY(YES) logstream      */\n      Do rloop1 = 1 to totdk-1     /* create define card loop     */\n        If Pos('()',dkword.rloop1) <> 0 then iterate /*null kword */\n        If Pos('LS_ALLOCAHEAD',dkword.rloop1) <> 0 then do\n          If Bitand(CVTOSLV6,'40'x) = '40'x then nop   /* z/OS 2.2*/\n          Else iterate\n        End\n        If Pos('NO_HLQ',dkword.rloop1) <> 0 then iterate\n        If Pos('NO_EHLQ',dkword.rloop1) <> 0 then iterate\n        If Substr(dkword.rloop1,1,6) = 'DEFINE' then,\n          linenw2.totdonly = dkword.rloop1 /* indent except for   */\n        else linenw2.totdonly = '  ' dkword.rloop1     /* define  */\n        totdonly = totdonly + 1  /* add one to total cards        */\n      End /* do rloop1 */\n    End  /* if dflag = 0 */\n    Else do\n      /* remove invalid keywords for DASDONLY logstreams */\n      Do rloop2 = 1 to totdk-1 /* dasdonly define card loop       */\n        If Pos('()',dkword.rloop2) <> 0 then iterate /*null kword */\n        If Pos('NO_HLQ',dkword.rloop2) <> 0 then iterate\n        If Pos('NO_EHLQ',dkword.rloop2) <> 0 then iterate\n        If Pos('LS_ALLOCAHEAD',dkword.rloop2)  ,\n              <> 0 then iterate\n        If Substr(dkword.rloop2,1,10) = 'STG_DUPLEX' then iterate\n        If Substr(dkword.rloop2,1,10) = 'DUPLEXMODE' then iterate\n        If Substr(dkword.rloop2,1,12) = 'LOGGERDUPLEX' then iterate\n        If Substr(dkword.rloop2,1,6) = 'DEFINE' then,\n          linenw2.totdonly = dkword.rloop2 /* indent except for  */\n        else linenw2.totdonly = '  ' dkword.rloop2    /* define  */\n        totdonly = totdonly + 1 /* add one to total cards        */\n      End /* do rloop2 */\n    End /* else do */\n    donly = donly-1\n    iterate /* get next define */\n  End  /* else do */\nEnd /* do donly */\n/*********************************************************************/\n/* One final loop through the cards we have so far to search         */\n/* for pending changes and get rid of them. These pending changes    */\n/* will be lost but the defines should work without error.           */\n/* Also get rid of blank lines if they exist.                        */\n/*********************************************************************/\nTOTF  = 0        /* new final total                  */\nPSKIP = 0        /* skip pending flag                */\nSKIPED_USED = 0  /* skip was used at least once flag */\nDo p = 1 to totdonly-1\n  If PSKIP = 1 & substr(linenw2.p,1,6) <> 'DELETE' ,\n    then iterate         /* skip until another DELETE is found       */\n    Else PSKIP = 0       /* DELETE found, reset PSKIP flag           */\n  If substr(linenw2.p,4,5) = 'NDING' then do   /* pending changes    */\n    PSKIP = 1                        /* set skip flag                */\n    SKIPED_USED = 1                  /* set skiped was used flag     */\n    iterate                          /* skip this card               */\n  End\n  If substr(linenw2.p,1,30) = blanks then iterate /* skip blank lines*/\n  Else do                          /* all other checks failed..      */\n     totf = totf + 1               /* add 1 to final total           */\n     linenw3.totf = linenw2.p      /* we want this one -  use it     */\n  End\nEnd\n/*********************************************************************/\n/* Queue JCL and DELETE/DEFINE cards to data stack                   */\n/*********************************************************************/\nQueue '//DELDEF   EXEC PGM=IXCMIAPU'\nQueue '//SYSPRINT DD   SYSOUT=*'\nQueue '//SYSABEND DD   SYSOUT=*'\nQueue '//SYSIN    DD   *'\nQueue 'DATA TYPE(LOGR) REPORT(NO)'\nDo z=1 to totf\n  Queue linenw3.z\nEnd\nQueue ''  /* null queue to end stack */\n/******************************************/\n/* write output file                      */\n/******************************************/\n\"EXECIO 0 DISKR INDD   (FINIS\"\n\"EXECIO * DISKW OUTDD  (FINIS\"\n/******************************************/\n/* Warn user if pending changes were      */\n/* skipped and exit either RC=4 or RC=0   */\n/* if no pending changes were found       */\n/******************************************/\nIf SKIPED_USED = 1 then do\n  Say '****************************************************'\n  Say '*  WARNING: One or more logstreams had pending     *'\n  Say '*           changes that were not included in the  *'\n  Say '*           genrated DEFINE for the logstream.     *'\n  Say '*                                                  *'\n  Say '*           Please review the logstream listing    *'\n  Say '*           that was used as input to this program *'\n  Say '*           and manually update the logstream      *'\n  Say '*           DEFINE cards that were generated and   *'\n  Say '*           update if desired or needed. Look for  *'\n  Say '*           \"PENDING CHANGES\" in the listing.      *'\n  Say '****************************************************'\n  Exit 4\nEnd\nElse exit 0\n##\n//************************************************************\n//*  EXEC \"LOGRREXX\" REXX CLIST IN BATCH\n//************************************************************\n//LOGRREXX EXEC PGM=IRXJCL,PARM='LOGRREXX'\n//INDD     DD  DSN=userid.LOGR.LIST,DISP=SHR\n//OUTDD    DD  DSN=userid.LOGR.DELDEF,\n//             DISP=(NEW,CATLG,DELETE),\n//             UNIT=SYSALLDA,\n//             SPACE=(CYL,(5,5),RLSE),\n//             DCB=(LRECL=80,BLKSIZE=0,RECFM=FB)\n//SYSTSIN  DD DUMMY\n//SYSTSPRT DD SYSOUT=*\n//SYSEXEC  DD  DSN=&&PDS,DISP=(OLD,DELETE,DELETE)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LPROG": {"ttr": 6156, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x992/\\x01\\x11\\x06?\\x14E\\x01\\x8d\\x01|\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "2011-03-04T14:45:00", "lines": 397, "newlines": 380, "modlines": 0, "user": "CBT482"}, "text": "/* REXX */\n/*                                       */\n/* AUTHOR: Mark Zelden                   */\n/*                                       */\n/* Trace ?r */\n/*********************************************************************/\n/* DISPLAY LPA, LNKLST, AND APF LIBRARY LISTS ON TERMINAL            */\n/*********************************************************************/\n/*                                                                   */\n/* NOTE: The dynamic APF and dynamic LNKLST code in this exec        */\n/*       use undocumented IBM control blocks and may break at        */\n/*       any time!                                                   */\n/*    ... tested on MVS ESA 4.3, OS/390, and up to z/OS 1.9.         */\n/*                                                                   */\n/* NOTE: The LNKLST SET displayed is the LNKLST SET of the address   */\n/*       space running this program, not necessarily the most        */\n/*       current one. For the current LNKLST SET either:             */\n/*       1) Run this exec in batch.                                  */\n/*       2) Log off and on TSO before executing this exec.           */\n/*       3) Issue SETPROG LNKLST,UPDATE,JOB=userid  (B4 execution)   */\n/*                                                                   */\n/* NOTE: The APF flag in the LNKLST display is the status if the     */\n/*       data set is accessed VIA LNKLST. Therefore, if IEASYSxx     */\n/*       specifies LNKAUTH=LNKLST, all entires are marked as APF=Y.  */\n/*********************************************************************/\n/* EXECUTION SYNTAX:                                                 */\n/*                                                                   */\n/* TSO %LPROG <option>                                               */\n/*                                                                   */\n/* VALID OPTIONS ARE 'ALL' (default), 'LNK' or 'LINK', 'APF', & 'LPA'*/\n/*                                                                   */\n/* Examples:                                                         */\n/*  TSO %LPROG       (display LPA list, LNKLST, and APF list)        */\n/*  TSO %LPROG LPA   (display LPA list)                              */\n/*  TSO %LPROG LNK   (display LNKLST)                                */\n/*  TSO %LPROG LINK  (display LNKLST)                                */\n/*  TSO %LPROG APF   (display APF list)                              */\n/*                                                                   */\n/*********************************************************************/\n/*  CVTLLTA LAYOUT (OFFSET 1244 IN CVT): (STATIC LNKLST)             */\n/*         DESC                       LEN                            */\n/*         ------------------------   ---                            */\n/*         CONSTANT 'LLT '             4                             */\n/*         NUMBER OF ENTRIES           4                             */\n/*         LENGTH OF DSN               1                             */\n/*         DSN (PADDED WITH BLANKS)    44                            */\n/*********************************************************************/\n/*  LPAT LAYOUT  (OFFSET 0 IN CVTEPLPS / START OF EXT. LPA):         */\n/*         DESC                       LEN                            */\n/*         ------------------------   ---                            */\n/*         CONSTANT 'LPAT'             4                             */\n/*         NUMBER OF ENTRIES           4                             */\n/*         LENGTH OF DSN               1                             */\n/*         DSN (PADDED WITH BLANKS)    44                            */\n/*********************************************************************/\n/*  CVTAUTHL LAYOUT (OFFSET 484 IN CVT):      (STATIC APF LIST)      */\n/*         DESC                       LEN                            */\n/*         ------------------------   ---                            */\n/*         NUMBER OF ENTRIES           2                             */\n/*         LENGTH OF ENTRY             1                             */\n/*         VOLUME                      6                             */\n/*         DSN                       VARIABLE                        */\n/*********************************************************************/\nLASTUPD = '12/13/2007'                       /* date of last update  */\n/*********************************************************************/\nArg OPTION\nParse source . . . . . . . ENV . .\nIf ENV <> 'OMVS' then                        /* are we under unix ?  */\n  If Sysvar('SYSISPF')='ACTIVE' then do      /* no, is ISPF active?  */\n    Address ISREDIT \"MACRO (OPTION)\"    /* YES - allow use as macro  */\n    OPTION = Translate(OPTION)   /* ensure upper case for edit macro */\n    Address ISPEXEC \"VGET ZENVIR\"            /* ispf version         */\n    SYSISPF = 'ACTIVE'                       /* set SYSISPF = ACTIVE */\n  End\nIf ENV = 'OMVS' then do                    /* Are we under OMVS?     */\n  Do CKWEB = __ENVIRONMENT.0 to 1 by -1    /* check env. vars        */\n     If pos('HTTP_',__ENVIRONMENT.CKWEB) <> 0 then do  /* web server */\n       Say 'Content-type: text/html'\n       Say ''\n       Say '<title>Mark''s MVS Utilities - LPROG</title>'\n       Say '<meta name=\"author\" content=\"Mark Zelden -' ,\n           'mark@mzelden.com\">'\n       Say '<meta name=\"description\" content=\"' || ,\n           'LPROG -' OPTION 'option.' ,\n           'Last updated on' LASTUPD ||'. Written by' ,\n           'Mark Zelden. Mark''s MVS Utilities -' ,\n           'http://www.mzelden.com/mvsutil.html\">'\n       Say '<meta http-equiv=\"pragma\" content=\"no-cache\">'\n       Say '<body BGCOLOR=\"#000000\" TEXT=\"#00FFFF\">'\n       Say '<pre>'\n       Leave                               /* exit loop              */\n     End /* if pos */\n  End /* do CKWEB */\nEnd\nOPTION = Translate(OPTION)  /* chg to UC for edit macro invocation   */\nIf OPTION = ' ' then OPTION = 'ALL'\nIf OPTION <> 'APF' & OPTION <> 'LNK' & OPTION <> 'LINK' & ,\n   OPTION <> 'LPA' & OPTION <> 'ALL' then do\n  Say 'INVALID OPTION. THE OPTION MUST BE \"APF\", \"LNK\" or \"LINK\",' ,\n      '\"LPA\", OR \"ALL\".'\n  Exit 12\nEnd\n/*                                                                   */\nCVT      = C2d(Storage(10,4))                /* point to CVT         */\nFMIDNUM  = Storage(D2x(CVT - 32),7)          /* point to fmid        */\n/*                                                                   */\nIf OPTION = 'LPA' | OPTION = 'ALL' then do\n  CVTSMEXT = C2d(Storage(D2x(CVT + 1196),4)) /* point to stg map ext.*/\n  CVTEPLPS = C2d(Storage(D2x(CVTSMEXT+56),4)) /* point to stg map ext*/\n  NUMLPA   = C2d(Storage(D2x(CVTEPLPS+4),4)) /* # LPA libs in table  */\n  LPAOFF   = 8                               /* first ent in LPA tbl */\n  Queue 'LPA LIBRARY LIST  ('NUMLPA' LIBRARIES)'\n  Queue '     '\n  Queue '  POSITION    DSNAME'\n  Do I = 1 to NUMLPA\n     LEN   = C2d(Storage(D2x(CVTEPLPS+LPAOFF),1)) /* length of entry */\n     LPDSN = Storage(D2x(CVTEPLPS+LPAOFF+1),LEN) /*DSN of LPA library*/\n     LPAOFF = LPAOFF + 44 + 1                  /* next entry in table*/\n     LPAPOS = Right(I,3)                       /*position in LPA list*/\n     RELLPPOS = Right('(+'I-1')',6)      /* relative position in list*/\n     Queue LPAPOS  RELLPPOS '  ' LPDSN\n  End\nEnd\nIf OPTION = 'ALL'  then do\n  Queue '     '\n  Queue '----------------------------------------------------'\n  Queue '     '\nEnd\nIf OPTION = 'LNK' | OPTION = 'LINK' |  OPTION = 'ALL' then do\n  If Substr(FMIDNUM,4,4) < 6602 then do\n    CVTLLTA  = C2d(Storage(D2x(CVT + 1244),4)) /* point to lnklst tbl*/\n    NUMLNK   = C2d(Storage(D2x(CVTLLTA+4),4))  /* # LNK libs in table*/\n    LLTAPFTB = CVTLLTA + 8 + (NUMLNK*45)       /* start of LLTAPFTB  */\n    LNKOFF   = 8                               /*first ent in LBK tbl*/\n    LKAPFOFF = 0                              /*first ent in LLTAPFTB*/\n    Queue 'LNKLST LIBRARY LIST  ('NUMLNK' LIBRARIES)'\n    Queue '     '\n    Queue '  POSITION    APF    DSNAME'\n    Do I = 1 to NUMLNK\n       LEN = C2d(Storage(D2x(CVTLLTA+LNKOFF),1))  /* length of entry */\n       LKDSN = Storage(D2x(CVTLLTA+LNKOFF+1),LEN) /* DSN of LNK lib  */\n       CHKAPF = Storage(D2x(LLTAPFTB+LKAPFOFF),1) /* APF flag        */\n       If  bitand(CHKAPF,'80'x) = '80'x then LKAPF = 'Y' /* flag on  */\n         else LKAPF = ' '                         /* APF flag off    */\n       LNKOFF = LNKOFF + 44 + 1                   /*next entry in tbl*/\n       LKAPFOFF = LKAPFOFF + 1            /* next entry in LLTAPFTB  */\n       LNKPOS = Right(I,3)                        /*position in list */\n       RELLKPOS = Right('(+'I-1')',6)   /* relative position in list */\n       Queue LNKPOS  RELLKPOS '   ' LKAPF '   ' LKDSN\n    End\n  End\n  Else do  /* OS/390 1.2 and above - PROGxx capable LNKLST           */\n    ASCB     = C2d(Storage(224,4))             /* point to ASCB      */\n    ASSB     = C2d(Storage(D2x(ASCB+336),4))   /* point to ASSB      */\n    DLCB     = C2d(Storage(D2x(ASSB+236),4))   /* point to CSVDLCB   */\n    DLCBFLGS = Storage(d2x(DLCB + 32),1)       /* DLCB flag bits     */\n    SETNAME  = Storage(D2x(DLCB + 36),16)      /* LNKLST set name    */\n    SETNAME  = Strip(SETNAME,'T')              /* del trailing blanks*/\n    CVTLLTA  = C2d(Storage(D2x(DLCB + 16),4))  /* point to lnklst tbl*/\n    LLTX     = C2d(Storage(D2x(DLCB + 20),4))  /* point to LLTX      */\n    NUMLNK   = C2d(Storage(D2x(CVTLLTA+4),4))  /* # LNK libs in table*/\n    LLTAPFTB = CVTLLTA + 8 + (NUMLNK*45)       /* start of LLTAPFTB  */\n    LNKOFF   = 8                               /*first ent in LLT tbl*/\n    VOLOFF   = 8                               /*first ent in LLTX   */\n    LKAPFOFF = 0                              /*first ent in LLTAPFTB*/\n    If Bitand(DLCBFLGS,'10'x) = '10'x then ,   /* bit for LNKAUTH    */\n         LAUTH = 'LNKLST'                      /* LNKAUTH=LNKLST     */\n    Else LAUTH = 'APFTAB'                      /* LNKAUTH=APFTAB     */\n    Queue 'LNKLST LIBRARY LIST - SET:' SETNAME ,\n          ' LNKAUTH='LAUTH '('NUMLNK' LIBRARIES):'\n    If LAUTH = 'LNKLST' then ,\n      Queue '     (ALL LNKLST DATA SETS MARKED APF=Y DUE TO' ,\n            'LNKAUTH=LNKLST)'\n    Queue '     '\n    Queue '  POSITION    APF   VOLUME    DSNAME'\n    Do I = 1 to NUMLNK\n       LEN = C2d(Storage(D2x(CVTLLTA+LNKOFF),1))  /* length of entry */\n       LKDSN = Storage(D2x(CVTLLTA+LNKOFF+1),LEN) /* DSN of LNK lib  */\n       LNKVOL = Storage(D2x(LLTX+VOLOFF),6)       /* VOL of LNK lib  */\n       CHKAPF = Storage(D2x(LLTAPFTB+LKAPFOFF),1) /* APF flag        */\n       If  bitand(CHKAPF,'80'x) = '80'x then LKAPF = 'Y' /* flag on  */\n         else LKAPF = ' '                         /* APF flag off    */\n       LNKOFF   = LNKOFF + 44 + 1                 /*next entry in LLT*/\n       VOLOFF   = VOLOFF + 8                      /*next vol in LLTX */\n       LKAPFOFF = LKAPFOFF + 1            /* next entry in LLTAPFTB  */\n       LNKPOS   = Right(I,3)                      /*position in list */\n       RELLKPOS = Right('(+'I-1')',6)   /* relative position in list */\n       Queue LNKPOS  RELLKPOS '   ' LKAPF '  ' LNKVOL '  ' LKDSN\n    End\n  End\nEnd\nIf OPTION = 'ALL'  then do\n  Queue '     '\n  Queue '----------------------------------------------------'\n  Queue '     '\nEnd\nIf OPTION = 'APF' | OPTION = 'ALL' then do\n  NUMERIC  DIGITS 10\n  CVTAUTHL = C2d(Storage(D2x(CVT + 484),4))  /* point to auth lib tbl*/\n  If CVTAUTHL <> C2d('7FFFF001'x) then do    /* dynamic list ?       */\n    NUMAPF   = C2d(Storage(D2x(CVTAUTHL),2)) /* # APF libs in table  */\n    APFOFF   = 2                             /* first ent in APF tbl */\n    Queue 'APF LIBRARY LIST  ('NUMAPF' LIBRARIES)'\n    Queue '     '\n    Queue 'ENTRY   VOLUME    DSNAME'\n    Do I = 1 to NUMAPF\n       LEN = C2d(Storage(D2x(CVTAUTHL+APFOFF),1)) /* length of entry */\n       VOL = Storage(D2x(CVTAUTHL+APFOFF+1),6)  /* VOLSER of APF LIB */\n       DSN = Storage(D2x(CVTAUTHL+APFOFF+1+6),LEN-6) /* DSN of apflib*/\n       APFOFF = APFOFF + LEN +1\n       APFPOS   = Right(I,4)                   /*position in APF list*/\n       Queue APFPOS '  ' VOL '  ' DSN\n    End\n  End\n  Else Do\n    ECVT     = C2d(Storage(D2x(CVT + 140),4))  /* point to CVTECVT   */\n    ECVTCSVT = C2d(Storage(D2x(ECVT + 228),4)) /* point to CSV table */\n    APFA = C2d(Storage(D2x(ECVTCSVT + 12),4))  /* APFA               */\n    AFIRST = C2d(Storage(D2x(APFA + 8),4))     /* First entry        */\n    ALAST  = C2d(Storage(D2x(APFA + 12),4))    /* Last  entry        */\n    LASTONE = 0   /* flag for end of list      */\n    NUMAPF = 1    /* tot # of entries in list  */\n    Do forever\n       DSN.NUMAPF = Storage(D2x(AFIRST+24),44) /* DSN of APF library */\n       DSN.NUMAPF = Strip(DSN.NUMAPF,'T')      /* remove blanks      */\n       CKSMS = Storage(D2x(AFIRST+4),1)        /* DSN of APF library */\n       if  bitand(CKSMS,'80'x)  = '80'x        /*  SMS data set?     */\n         then VOL.NUMAPF = '*SMS* '            /* SMS control dsn    */\n       else VOL.NUMAPF = Storage(D2x(AFIRST+68),6) /* VOL of APF lib */\n       If Substr(DSN.NUMAPF,1,1) <> X2c('00')  /* check for deleted  */\n         then NUMAPF = NUMAPF + 1              /*   APF entry        */\n       AFIRST = C2d(Storage(D2x(AFIRST + 8),4)) /* next  entry       */\n       if LASTONE = 1 then leave\n       If  AFIRST = ALAST then LASTONE = 1\n    End\n    Queue 'APF LIBRARY LIST  - DYNAMIC ('NUMAPF - 1' LIBRARIES)'\n    Queue '     '\n    Queue 'ENTRY   VOLUME    DSNAME'\n    Do I = 1 to NUMAPF-1\n       APFPOS   = Right(I,4)                   /*position in APF list*/\n       Queue APFPOS '  ' VOL.I '  ' DSN.I\n    End\n  End\nEnd\n/*                                                                   */\nQueue ''  /* null queue to end stack   */\nIf SYSISPF = 'ACTIVE' then call BROWSE_ISPF\nElse do queued()\n Parse pull line\n Say line\nEnd\nExit 0\n\nBROWSE_ISPF: /* Browse output if ISPF is active          */\nAddress ISPEXEC \"CONTROL ERRORS RETURN\"\nAddress TSO\nprefix = sysvar('SYSPREF')        /* tso profile prefix            */\nuid    = sysvar('SYSUID')         /* tso userid                    */\nIf prefix = '' then prefix = uid  /* use uid if null prefix        */\nIf prefix <> '' & prefix <> uid then /* different prefix than uid  */\n   prefix = prefix || '.' || uid /* use  prefix.uid                */\nddnm1 = 'DDO'||random(1,99999)   /* choose random ddname           */\nddnm2 = 'DDP'||random(1,99999)   /* choose random ddname           */\njunk = msg('off')\n\"ALLOC FILE(\"||ddnm1||\") UNIT(SYSALLDA) NEW TRACKS SPACE(2,1) DELETE\",\n      \" REUSE LRECL(80) RECFM(F B) BLKSIZE(3120)\"\n\"ALLOC FILE(\"||ddnm2||\") UNIT(SYSALLDA) NEW TRACKS SPACE(1,1) DELETE\",\n      \" REUSE LRECL(80) RECFM(F B) BLKSIZE(3120) DIR(1)\"\njunk = msg('on')\n\"Newstack\"\n/*************************/\n/* LPROGP Panel source   */\n/*************************/\nIf Substr(ZENVIR,6,1) >= 4 then\n  Queue \")PANEL KEYLIST(ISRSPBC,ISR)\"\nQueue \")ATTR\"\nQueue \"  _ TYPE(INPUT)   INTENS(HIGH) COLOR(TURQ) CAPS(OFF)\" ,\n      \"FORMAT(&MIXED)\"\nQueue \"  | AREA(DYNAMIC) EXTEND(ON)   SCROLL(ON)\"\nQueue \"  + TYPE(TEXT)    INTENS(LOW)  COLOR(BLUE)\"\nQueue \"  @ TYPE(TEXT)    INTENS(LOW)  COLOR(TURQ)\"\nQueue \"  % TYPE(TEXT)    INTENS(HIGH) COLOR(GREEN)\"\nQueue \"  ! TYPE(OUTPUT)  INTENS(HIGH) COLOR(TURQ) PAD(-)\"\nQueue \" 01 TYPE(DATAOUT) INTENS(LOW)\"\nQueue \" 02 TYPE(DATAOUT) INTENS(HIGH)\"\nQueue \" 0B TYPE(DATAOUT) INTENS(HIGH) FORMAT(DBCS)\"\nQueue \" 0C TYPE(DATAOUT) INTENS(HIGH) FORMAT(EBCDIC)\"\nQueue \" 0D TYPE(DATAOUT) INTENS(HIGH) FORMAT(&MIXED)\"\nQueue \" 10 TYPE(DATAOUT) INTENS(LOW)  FORMAT(DBCS)\"\nQueue \" 11 TYPE(DATAOUT) INTENS(LOW)  FORMAT(EBCDIC)\"\nQueue \" 12 TYPE(DATAOUT) INTENS(LOW)  FORMAT(&MIXED)\"\nQueue \")BODY EXPAND(//)\"\nQueue \"%BROWSE  @&ZTITLE  / /  %Line!ZLINES  %Col!ZCOLUMS+\"\nQueue \"%Command ===>_ZCMD / /           %Scroll ===>_Z   +\"\nQueue \"|ZDATA ---------------/ /-------------------------|\"\nQueue \"|                     / /                         |\"\nQueue \"| --------------------/-/-------------------------|\"\nQueue \")INIT\"\nQueue \"  .HELP = LPROGH\"\nQueue \"  .ZVARS = 'ZSCBR'\"\nQueue \"  &ZTITLE = 'Mark''s MVS Utilities - LPROG'\"\nQueue \"  &MIXED = MIX\"\nQueue \"  IF (&ZPDMIX = N)\"\nQueue \"   &MIXED = EBCDIC\"\nQueue \"  VGET (ZSCBR) PROFILE\"\nQueue \"  IF (&ZSCBR = ' ')\"\nQueue \"   &ZSCBR = 'CSR'\"\nQueue \")REINIT\"\nQueue \"  REFRESH(ZCMD,ZSCBR,ZDATA,ZLINES,ZCOLUMS)\"\nQueue \")PROC\"\nQueue \"  &ZCURSOR = .CURSOR\"\nQueue \"  &ZCSROFF = .CSRPOS\"\nQueue \"  &ZLVLINE = LVLINE(ZDATA)\"\nQueue \"  VPUT (ZSCBR) PROFILE\"\nQueue \")END\"\nQueue \"\"\n/*                                    */\nAddress ISPEXEC \"LMINIT DATAID(PAN) DDNAME(\"ddnm2\")\"\nAddress ISPEXEC \"LMOPEN DATAID(\"pan\") OPTION(OUTPUT)\"\nDo queued()\n   Parse pull panline\n   Address ISPEXEC \"LMPUT DATAID(\"pan\") MODE(INVAR)\" ,\n           \"DATALOC(PANLINE) DATALEN(80)\"\nEnd\nAddress ISPEXEC \"LMMADD DATAID(\"pan\") MEMBER(LPROGP)\"\n/* Address ISPEXEC \"LMFREE DATAID(\"pan\")\" */\n\"Delstack\"\n\"Newstack\"\n/*************************/\n/* LPROGH Panel source   */\n/*************************/\nIf Substr(ZENVIR,6,1) >= 4 then\n  Queue \")PANEL KEYLIST(ISRSPBC,ISR)\"\nQueue \")ATTR DEFAULT(!+_)\"\nQueue \"  _ TYPE(INPUT)   INTENS(HIGH) COLOR(TURQ) CAPS(OFF)\" ,\n      \"FORMAT(&MIXED)\"\nQueue \"  + TYPE(TEXT)    INTENS(LOW)  COLOR(BLUE)\"\nQueue \"  @ TYPE(TEXT)    INTENS(LOW)  COLOR(TURQ)\"\nQueue \"  ! TYPE(TEXT)    INTENS(HIGH) COLOR(GREEN)\"\nQueue \")BODY EXPAND(//)\"\nQueue \"!HELP    @&ZTITLE  / / \"\nQueue \"!Command ===>_ZCMD / / \"\nQueue \"+                                                              \"\nQueue \"+EXECUTION SYNTAX:                                             \"\nQueue \"+                                                              \"\nQueue \"!TSO %LPROG <option>                                           \"\nQueue \"+                                                              \"\nQueue \"+VALID OPTIONS ARE 'ALL' (default), 'LNK'\",\n      \"or 'LINK', 'APF', & 'LPA' \"\nQueue \"+                                                              \"\nQueue \"+Examples:                                                     \"\nQueue \"! TSO %LPROG       (display LPA list, LNKLST, and APF list)    \"\nQueue \"! TSO %LPROG LPA   (display LPA list)                          \"\nQueue \"! TSO %LPROG LNK   (display LNKLST)                            \"\nQueue \"! TSO %LPROG LINK  (display LNKLST)                            \"\nQueue \"! TSO %LPROG APF   (display APF list)                          \"\nQueue \"+                                                              \"\nQueue \"+                                                              \"\nQueue \"+                                                              \"\nQueue \"@&ADLINE\"\nQueue \")INIT\"\nQueue \"  .HELP = ISR10000\"\nQueue \"  &ZTITLE = 'Mark''s MVS Utilities - LPROG'\"\nQueue \" &ADLINE = 'Mark''s MVS Utilities -\",\n      \"http://www.mzelden.com/mvsutil.html'\"\nQueue \"  &MIXED = MIX\"\nQueue \"  IF (&ZPDMIX = N)\"\nQueue \"   &MIXED = EBCDIC\"\nQueue \")END\"\nQueue \"\"\n/*                                    */\nDo queued()\n   Parse pull panline\n   Address ISPEXEC \"LMPUT DATAID(\"pan\") MODE(INVAR)\" ,\n           \"DATALOC(PANLINE) DATALEN(80)\"\nEnd\nAddress ISPEXEC \"LMMADD DATAID(\"pan\") MEMBER(LPROGH)\"\nAddress ISPEXEC \"LMFREE DATAID(\"pan\")\"\n\"Delstack\"\n\"EXECIO * DISKW\" ddnm1 \"(FINIS\"\nzerrsm  = 'LPROG' OPTION\nzerrlm  = 'LPROG -' OPTION ||' option. Last updated on' ,\n           LASTUPD ||'. Written by' ,\n          'Mark Zelden. Mark''s MVS Utilities -' ,\n          'http://www.mzelden.com/mvsutil.html'\nzerralrm = 'NO'      /* msg - no alarm */\nzerrhm   = 'LPROGH'  /* help panel */\naddress ISPEXEC \"LIBDEF ISPPLIB LIBRARY ID(\"||ddnm2||\") STACK\"\naddress ISPEXEC \"SETMSG MSG(ISRZ002)\"\naddress ISPEXEC \"LMINIT DATAID(TEMP) DDNAME(\"||ddnm1||\")\"\naddress ISPEXEC \"BROWSE DATAID(\"||temp\") PANEL(LPROGP)\"\naddress ISPEXEC \"LMFREE DATAID(\"||temp\")\"\naddress ISPEXEC \"LIBDEF ISPPLIB\"\njunk = msg('off')\n\"FREE FI(\"||ddnm1||\")\"\n\"FREE FI(\"||ddnm2||\")\"\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MEMLSTSV": {"ttr": 6407, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x19\\x18/\\x01\\x19\\x18/\\x17 \\x00\\x19\\x00\\x19\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf9\\xf8@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-07-01T00:00:00", "modifydate": "2019-07-01T17:20:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "CBT498"}, "text": "/* rexx */\n/* Quick ISPF save of member stats.                 */\nARG DS G\n/* DS is the data set name to get the stats from.   */\n/* G is the middle qualifer of the saved data set   */\n/* The saved data set name will be userid.g.MEMBERS */\nIf G = '' then G = 'STATS'\nIf DS = '' then do\n  Say 'You must supply at least a data set name to MEMLSTSV.'\n      'Do not use quotes as the REXX EXEC supplies those.'\n  Say 'For example, TSO %MEMLSTSV USERID.LIB.CNTL'\n  Exit 12\nEnd\nAddress ISPEXEC\n \"CONTROL ERRORS RETURN\"\n \"LMINIT DATAID(STATID)  DATASET('\"DS\"')\"\n If RC = 0 then do\n   \"LMOPEN DATAID(\"STATID\")\"\n   \"LMMLIST DATAID(\"STATID\") OPTION(SAVE) STATS(YES) GROUP(\"G\")\"\n    If RC = 0 then,\n      Say 'Stats written to userid.' || G || '.MEMBERS'\n    Else say 'Error - RC=' || RC\n End\n Else say 'Error - RC=' || RC\n \"LMFREE DATAID(\"STATID\")\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ONEPAKZD": {"ttr": 6409, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x12\\x18\\x7f\\x01\\x12\\x18\\x7f\\t\\x10\\x0b\\\\\\x0b\\\\\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-07-05T00:00:00", "modifydate": "2012-07-05T09:10:00", "lines": 2908, "newlines": 2908, "modlines": 0, "user": "CBT484"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "ONEPAKZ3": {"ttr": 7685, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00A\\x01\\x03\\x00/\\x01\\x04#\\x7f\\x15S\\x0b\\x15\\n\\xd9\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf6\\xf7@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-01-02T00:00:00", "modifydate": "2004-08-24T15:53:41", "lines": 2837, "newlines": 2777, "modlines": 0, "user": "CBT467"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "ONEPAKZ6": {"ttr": 8714, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x05\\x12\\x9f\\x01\\x06\\x00_\\tP\\x0b(\\x0b)\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf1@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-05-09T00:00:00", "modifydate": "2006-01-05T09:50:00", "lines": 2856, "newlines": 2857, "modlines": 0, "user": "CBT471"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "ONEPAKZ8": {"ttr": 9990, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x07\\x14O\\x01\\x12\\x18\\x7f\\t\\x10\\x0bn\\x0b-\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-05-24T00:00:00", "modifydate": "2012-07-05T09:10:00", "lines": 2926, "newlines": 2861, "modlines": 0, "user": "CBT484"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "ONEPAK21": {"ttr": 11267, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x140\\x0f\\x01\\x140\\x0f\\x11U\\x0b\\x10\\x0b\\\\\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-10-27T00:00:00", "modifydate": "2014-10-27T11:55:00", "lines": 2832, "newlines": 2908, "modlines": 0, "user": "CBT489"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "ONEPAK22": {"ttr": 12296, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x18(_\\x01\\x18(_\\x11E\\x0b;\\x0b:\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf9\\xf6@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-10-12T00:00:00", "modifydate": "2018-10-12T11:45:00", "lines": 2875, "newlines": 2874, "modlines": 0, "user": "CBT496"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "ONEPAK43": {"ttr": 13573, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00)\\x01\\x01\\x03?\\x01\\x01\\x03?\\x14\\x10\\x01f\\x01f\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf3\\xf3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-02-02T00:00:00", "modifydate": "2001-02-02T14:10:29", "lines": 358, "newlines": 358, "modlines": 0, "user": "CBT433"}, "text": "//TSGMXZ1O  JOB (AD00),'#04D42 ZELDEN',\n//             NOTIFY=&SYSUID,\n//             CLASS=M,MSGCLASS=H,MSGLEVEL=(1,1)\n//*\n//*****************************************************************\n//*  GLOBALLY CHANGE CURRES TO THE CURRENT SYSRES VOLUME\n//*****************************************************************\n//*\n//* THE ONEPAK SYSTEM INCLUDES THE FOLLOWING PRODUCTS (IN ADDITION TO\n//* MVS/ESA STUFF): DFP, DSF, VTAM, RACF, ISPF, ISPF/PDF, SDSF,\n//*                TSO/E, COBOL LIBRARY, FDR, IAM, AND SYNCSORT\n//*\n//*\n//*   THE FOLLOWING STEPS COPY CURRES TO SYS1PK AND ......\n//*\n//*  1.  DEFINE MASTER CATALOG\n//*  2.  FDRCOPY RACF DSNS (MUST BE DONE FIRST - DSORG=PSU)\n//*  3.  DEFINE PAGE DATA SETS, SMF DATASETS AND STGINDEX\n//*  4.  FORMAT SMF DATASETS\n//*  5.  FDRCOPY THE CURRENT MVS SYSTEM TO SYS1PK AND CATLG DSNS\n//*  6.  PUT IPL TEXT ON VOLUME USING ICKDSF\n//*  7.  ALLOCATE NEW LOGREC, BRODCAST, SPOOL AND DUMP DSN\n//*  8.  RENAME NEW LOGREC, BRODCAST, SPOOL AND DUMP DSN\n//*  9.  CATALOG NEW LOGREC, BRODCAST, SPOOL AND DUMP DSN\n//* 10.  INITIALIZE LOGREC\n//* 11.  UPDATE SYSCATLG MEMBER IN SYS1.NUCLEUS\n//* 12.  COMPRESS SYS1.PARMLIB ON SYS1PK\n//* 13.  UPDATE PROCLIBS, PARMLIB, AND VTAMLST MEMBERS ON SYS1PK\n//* 14.  LIST THE SYS1PK MASTER CATALOG\n//*\n//* AFTER THE FIRST IPL:\n//*  A) ISSUE  DD CLEAR,DSN=ALL  COMMAND FROM A SYSTEM CONSOLE.\n//*  B) LOGON TO TSO AND ISSUE THE SYNC COMMAND TO FORMAT THE\n//*     BRODCAST DATASET (BE SURE TO ALLOC FILE(SYSUADS) ).\n//*\n//*****************************************************************\n//*----------------------------------------------------------------\n//MCAT1     EXEC  PGM=IDCAMS,REGION=4096K\n//SYSPRINT  DD    SYSOUT=*\n//DISK      DD    DISP=SHR,UNIT=SYSDA,VOL=SER=SYS1PK\n//SYSIN     DD    *\n EXP SYS1.MCAT.VSYS1PK DISCONNECT\n IF LASTCC=12 THEN SET MAXCC=0\n DEF MCAT(NAME(SYS1.MCAT.VSYS1PK) VOLUME(SYS1PK) -\n     FILE(DISK) TRK(15 2) ICFCAT IMBED REPL -\n     SHR(3 4) STRNO(2) BUFSP(6144)) -\n     DATA(BUFND(3) FSPC(10 2) CISZ(1024)) -\n     INDEX(BUFNI(3) CISZ(1024)) -\n     CAT(CURRENT.MASTER.CATALOG)  /* CHANGE */\n//*----------------------------------------------------------------\n//COPY2    EXEC PGM=FDRCOPY,REGION=4096K\n//STEPCAT   DD    DISP=SHR,DSN=SYS1.MCAT.VSYS1PK\n//SYSPRINT DD  SYSOUT=*\n//SYSPRIN1 DD  SYSOUT=*\n//SYSPRIN2 DD  SYSOUT=*\n//SYSUDUMP DD  SYSOUT=*\n//DISK1    DD  UNIT=SYSDA,VOL=SER=SYSMCT,DISP=SHR\n//TAPE1    DD  UNIT=SYSDA,VOL=SER=SYS1PK,DISP=SHR\n//DISK2    DD  UNIT=SYSDA,VOL=SER=SYS021,DISP=SHR\n//TAPE2    DD  UNIT=SYSDA,VOL=SER=SYS1PK,DISP=SHR\n//SYSIN    DD  *\n COPY     TYPE=DSF,DSNENQ=NONE,ENQERR=NO\n SELECT   DSN=SYS1.RACF,VOL=SYSMCT\n SELECT   DSN=SYS1.RACF.BKUP1,VOL=SYS021\n//*----------------------------------------------------------------\n//*\n//PAGE3     EXEC  PGM=IDCAMS,REGION=4096K\n//STEPCAT   DD    DISP=SHR,DSN=SYS1.MCAT.VSYS1PK\n//SYSPRINT  DD    SYSOUT=*\n//DISK      DD    DISP=OLD,VOL=SER=SYS1PK,UNIT=SYSDA\n//SYSIN     DD    *\n DEF PGSPC(NAME(PAGE.VSYS1PK.PLPA) VOL(SYS1PK) -\n     FILE(DISK) CYLINDERS(50)) -\n     CATALOG(SYS1.MCAT.VSYS1PK)\n DEF PGSPC(NAME(PAGE.VSYS1PK.COMMON) VOL(SYS1PK) -\n     FILE(DISK) CYLINDERS(10)) -\n     CATALOG(SYS1.MCAT.VSYS1PK)\n DEF PGSPC(NAME(PAGE.VSYS1PK.LOCAL) VOL(SYS1PK) -\n     FILE(DISK) CYLINDERS(200)) -\n     CATALOG(SYS1.MCAT.VSYS1PK)\n DEF CLUSTER (BUFFERSPACE(20480) CYL(2) FILE(DISK) -\n     KEYS(12,8) NAME(SYS1.STGINDEX) -\n     RECORDSIZE(2041,2041) REUSE VOLUME(SYS1PK)) -\n     DATA(CONTROLINTERVALSIZE(2048)) -\n     INDEX(CONTROLINTERVALSIZE(4096)) -\n     CATALOG(SYS1.MCAT.VSYS1PK)\n DEF CLUSTER (CONTROLINTERVALSIZE(4096) CYLINDERS(5) -\n     NAME(SYS1.MAN1) NONINDEXED RECORDSIZE(4086,32767)-\n     REUSE SHAREOPTIONS(2) SPANNED SPEED VOLUME(SYS1PK)) -\n     DATA (NAME(SYS1.MAN1.DATA)) -\n     CATALOG(SYS1.MCAT.VSYS1PK)\n DEF CLUSTER (CONTROLINTERVALSIZE(4096) CYLINDERS(1) -\n     NAME(SYS1.MAN2) NONINDEXED RECORDSIZE(4086,32767)-\n     REUSE SHAREOPTIONS(2) SPANNED SPEED VOLUME(SYS1PK)) -\n     DATA (NAME(SYS1.MAN2.DATA)) -\n     CATALOG(SYS1.MCAT.VSYS1PK)\n//*----------------------------------------------------------------\n//SMFFMT4 EXEC  PGM=IFASMFDP\n//STEPCAT   DD    DISP=SHR,DSN=SYS1.MCAT.VSYS1PK\n//SYSPRINT DD  SYSOUT=*\n//MAN1     DD  DSN=SYS1.MAN1,DISP=SHR\n//MAN2     DD  DSN=SYS1.MAN2,DISP=SHR\n//SYSIN    DD  *\n   INDD(MAN1,OPTIONS(CLEAR))\n   INDD(MAN2,OPTIONS(CLEAR))\n/*\n//*----------------------------------------------------------------\n//*\n//COPY5    EXEC PGM=FDRCOPY,REGION=4096K\n//STEPCAT   DD    DISP=SHR,DSN=SYS1.MCAT.VSYS1PK\n//SYSPRINT DD  SYSOUT=*\n//SYSPRIN1 DD  SYSOUT=*\n//SYSPRIN2 DD  SYSOUT=*\n//SYSPRIN3 DD  SYSOUT=*\n//SYSPRIN4 DD  SYSOUT=*\n//SYSPRIN5 DD  SYSOUT=*\n//SYSUDUMP DD  SYSOUT=*\n//DISK1    DD  UNIT=SYSDA,VOL=SER=CURRES,DISP=SHR\n//TAPE1    DD  UNIT=SYSDA,VOL=SER=SYS1PK,DISP=SHR\n//DISK2    DD  UNIT=SYSDA,VOL=SER=SMPE01,DISP=SHR\n//TAPE2    DD  UNIT=SYSDA,VOL=SER=SYS1PK,DISP=SHR\n//DISK3    DD  UNIT=SYSDA,VOL=SER=SYSMCT,DISP=SHR\n//TAPE3    DD  UNIT=SYSDA,VOL=SER=SYS1PK,DISP=SHR\n//DISK4    DD  UNIT=SYSDA,VOL=SER=IMS13A,DISP=SHR\n//TAPE4    DD  UNIT=SYSDA,VOL=SER=SYS1PK,DISP=SHR\n//DISK5    DD  UNIT=SYSDA,VOL=SER=SYS011,DISP=SHR\n//TAPE5    DD  UNIT=SYSDA,VOL=SER=SYS1PK,DISP=SHR\n//SYSIN    DD  *\n COPY     TYPE=DSF,DSNENQ=NONE,ENQERR=NO\n SELECT   DSN=SYS1.CMDLIB,VOL=CURRES\n SELECT   DSN=SYS1.DAE,VOL=CURRES\n SELECT   DSN=SYS1.HELP,VOL=CURRES\n SELECT   DSN=SYS1.IMAGELIB,VOL=CURRES\n SELECT   DSN=SYS1.LINKLIB,VOL=CURRES\n SELECT   DSN=SYS1.MIGLIB,VOL=CURRES\n SELECT   DSN=SYS1.CSSLIB,VOL=CURRES\n SELECT   DSN=SYS1.LPALIB,VOL=CURRES\n SELECT   DSN=SYS1.MACLIB,VOL=CURRES\n SELECT   DSN=SYS1.MODGEN,VOL=CURRES\n SELECT   DSN=SYS1.NUCLEUS,VOL=CURRES\n SELECT   DSN=SYS1.PARMLIB,VOL=CURRES\n SELECT   DSN=SYS1.PROCLIB,VOL=CURRES\n SELECT   DSN=SYS1.SAMPLIB,VOL=CURRES\n SELECT   DSN=SYS1.SISTMAC1,VOL=CURRES\n SELECT   DSN=SYS1.SVCLIB,VOL=CURRES\n SELECT   DSN=SYS1.VSCLLIB,VOL=CURRES\n SELECT   DSN=SYS1.COB2LIB,VOL=CURRES\n SELECT   DSN=SYS1.PLILINK,VOL=CURRES\n SELECT   DSN=SYS1.SIBMLINK,VOL=CURRES\n SELECT   DSN=SYS1.VTAMLIB,VOL=CURRES\n SELECT   DSN=ISF.**,VOL=CURRES\n SELECT   DSN=ISP.**,VOL=CURRES\n SELECT   DSN=ISR.**,VOL=CURRES\n SELECT   DSN=ISF.HASPINDX,VOL=IMS13A\n SELECT   DSN=SYS2.LINKLIB,VOL=SMPE01\n SELECT   DSN=SYS1.IAM.LINKLIB,VOL=SYS011\n SELECT   DSN=SYS2.FDR.LINKLIB,VOL=SMPE01\n SELECT   DSN=SYS2.SYNC.LINKLIB,VOL=SMPE01\n SELECT   DSN=SYS2.SYNC.LPALIB,VOL=SMPE01\n SELECT   DSN=SYS3.PARMLIB,VOL=SMPE01,NEWN=SYS2.PARMLIB\n SELECT   DSN=SYS1.UADS,VOL=SYSMCT\n SELECT   DSN=SYS1.VTAMLST,VOL=SYSMCT\n SELECT   DSN=SYS2.PROCLIB,VOL=SYSMCT\n SELECT   DSN=SYS3.VTAMLIB,VOL=SYSMCT,NEWN=SYS2.VTAMLIB\n/*\n//*----------------------------------------------------------------\n//IPLTEXT6 EXEC PGM=ICKDSF,REGION=4096K\n//SYSPRINT DD  SYSOUT=*\n//IPLTEXT  DD  DISP=SHR,VOL=SER=SYS1PK,UNIT=SYSDA,\n//             DSN=SYS1.SAMPLIB(IPLRECS)\n//         DD  DISP=SHR,VOL=SER=SYS1PK,UNIT=SYSDA,\n//             DSN=SYS1.SAMPLIB(IEAIPL00)\n//SYSIN    DD  *\n   REFORMAT  DDNAME(IPLTEXT)                                     -\n             IPLDD(IPLTEXT)                                      -\n             NOVERIFY                                            -\n             BOOTSTRAP   /* IPLRECS OF IPLTEXT DD WILL SUPPLY IT */\n/*\n//*----------------------------------------------------------------\n//ALLOC7   EXEC  PGM=IEFBR14\n//LOGREC   DD  DISP=(NEW,KEEP),DSN=SYS3.LOGREC,\n//             VOL=SER=SYS1PK,UNIT=SYSDA,\n//             SPACE=(CYL,1)\n//BRODCAST DD  DISP=(NEW,KEEP),DSN=SYS3.BRODCAST,\n//             VOL=SER=SYS1PK,UNIT=SYSDA,\n//             SPACE=(CYL,2)\n//HASPCKPT DD  DISP=(NEW,KEEP),DSN=SYS3.HASPCKPT,\n//             VOL=SER=SYS1PK,UNIT=SYSDA,\n//             SPACE=(CYL,5)\n//HASPACE  DD  DISP=(NEW,KEEP),DSN=SYS3.HASPACE,\n//             VOL=SER=SYS1PK,UNIT=SYSDA,\n//             SPACE=(CYL,75)\n//DUMP00   DD  DISP=(NEW,KEEP),DSN=SYS3.DUMP00,\n//             VOL=SER=SYS1PK,UNIT=SYSDA,\n//             SPACE=(CYL,1),\n//*            DCB=(RECFM=F,LRECL=4104,BLKSIZE=4104)\n//             DCB=(RECFM=F,LRECL=4160,BLKSIZE=4160)\n//*---------------------------------------------------------------\n//RENAME8  EXEC  PGM=IEHPROGM\n//SYSPRINT DD  SYSOUT=*\n//SYS1PK   DD  DISP=OLD,VOL=SER=SYS1PK,UNIT=SYSDA\n//SYSIN    DD  *\n RENAME VOL=SYSDA=SYS1PK,DSNAME=SYS3.LOGREC,                           X\n               NEWNAME=SYS1.LOGREC\n RENAME VOL=SYSDA=SYS1PK,DSNAME=SYS3.BRODCAST,                         X\n               NEWNAME=SYS1.BRODCAST\n RENAME VOL=SYSDA=SYS1PK,DSNAME=SYS3.HASPCKPT,                         X\n               NEWNAME=SYS1.HASPCKPT\n RENAME VOL=SYSDA=SYS1PK,DSNAME=SYS3.HASPACE,                          X\n               NEWNAME=SYS1.HASPACE\n RENAME VOL=SYSDA=SYS1PK,DSNAME=SYS3.DUMP00,                           X\n               NEWNAME=SYS1.DUMP00\n//*-----------------------------------------------------------------\n//CATLG9    EXEC  PGM=IDCAMS,REGION=4096K\n//STEPCAT   DD    DISP=SHR,DSN=SYS1.MCAT.VSYS1PK\n//SYSPRINT  DD    SYSOUT=*\n//SYSIN     DD    *\n DEF NVSAM(NAME(SYS1.LOGREC)   VOL(SYS1PK) DEVT(3380))\n DEF NVSAM(NAME(SYS1.BRODCAST) VOL(SYS1PK) DEVT(3380))\n DEF NVSAM(NAME(SYS1.HASPACE)  VOL(SYS1PK) DEVT(3380))\n DEF NVSAM(NAME(SYS1.HASPCKPT) VOL(SYS1PK) DEVT(3380))\n DEF NVSAM(NAME(SYS1.DUMP00)   VOL(SYS1PK) DEVT(3380))\n//*----------------------------------------------------------------\n//LOGREC10  EXEC  PGM=IFCDIP00\n//SERERDS   DD DISP=SHR,DSN=SYS1.LOGREC,\n//             VOL=SER=SYS1PK,UNIT=SYSDA\n//*-----------------------------------------------------------------\n//CATPTR11 EXEC PGM=IEBDG,REGION=4096K\n//*\n//* DOC: THE PURPOSE OF THIS STEP IS TO REPLACE MEMBER 'SYSCATLG'\n//*      IN DATA SET 'SYS1.NUCLEUS' TO FACILITATE THE USE OF AN\n//*      EXISTING ICF MASTER CATALOG WITH A NEWLY CREATED\n//*      IPL VOLUME.\n//*\n//*  *****  (YOU CAN SKIP THIS STEP IF USING LOADXX)\n//*\n//* NOTE: THE FORMAT OF SYSCATLG IN SYS1.NUCLEUS HAS CHANGED FOR\n//*       MVS/DFP VERSION 3. THE NEW FORMAT OF SYSCATLG IS:\n//*       VVVVVVTALLNNNNNN.....\n//*       VVVVVV    = VOLSER\n//*       T         = CATALOG TYPE\n//*                   1 = ICF CATALOG\n//*                   2 = ICF CATALOG WITH SYS% TO SYS1 CONVERSION\n//*                       ACTIVE\n//*       A         = NUMBER OF MLA ALIAS LEVELS (1-4)\n//*                   DEFAULT IS 1\n//*       LL        = CAS SERVICE TASK LOWER LIMIT\n//*                   DEFAULT=X'3C', MINIMUM=X'18', MAXIMUM=X'C8'\n//*       NNNNNN... = CATALOG NAME (UP TO 44 CHARACTERS)\n//*\n//*\n//SYSPRINT DD  SYSOUT=*\n//NUCLEUS  DD  DSN=SYS1.NUCLEUS(SYSCATLG),\n//             UNIT=SYSDA,VOL=SER=SYS1PK,    <----VERIFY/CHANGE\n//             DISP=OLD                    UNIT AND VOLSER OF IPL PACK\n//SYSIN    DD  *\n  DSD OUTPUT=(NUCLEUS)\n  FD NAME=VOL,\n     LENGTH=06,\n     STARTLOC=01,\n     FILL=X'40',\n     PICTURE=6,'SYS1PK' <----- VERIFY/CHANGE VOLSER OF CATALOG\n  FD NAME=CATTYPE,\n     LENGTH=01,\n     STARTLOC=07,\n     FILL=X'F1'    <----- ICF CATALOG\n  FD NAME=ALIAS,\n     LENGTH=01,\n     STARTLOC=08,\n     FILL=X'F1'    <-----NUMBER OF MLA ALIAS LEVELS (DEFAULT=1)\n  FD NAME=CASLL,\n     LENGTH=02,\n     STARTLOC=09,\n     FILL=X'40',\n     PICTURE=2,'3C' <----CAS SERVICE TASK LOWER LIMIT (DEFAULT=60)\n  FD NAME=CAT,\n     LENGTH=44,\n     STARTLOC=11,\n     FILL=X'40',\n     PICTURE=44,'SYS1.MCAT.VSYS1PK                            '\n  FD NAME=FIL,\n     LENGTH=26,\n     STARTLOC=55,\n     FILL=X'40'\n  CREATE QUANTITY=1,FILL=X'00',NAME=(VOL,CATTYPE,ALIAS,CASLL,CAT,FIL)\n/*\n//*\n//* COMPRESS SYS1.PARMLIB ON SYS1PK\n//*\n//COMP12     EXEC PGM=IEBCOPY\n//SYSPRINT DD  SYSOUT=*\n//IN1      DD  DISP=SHR,DSN=SYS1.PARMLIB,\n//             UNIT=SYSDA,VOL=SER=SYS1PK\n//SYSUT3   DD  UNIT=SYSDA,SPACE=(CYL,(10,5))\n//SYSUT4   DD  UNIT=SYSDA,SPACE=(CYL,(10,5))\n//SYSIN    DD  *\n  COPY INDD=IN1,OUTDD=IN1,LIST=NO\n/*\n//*\n//* UPDATE PROCLIB, PARMLIB, AND VTAMLST MEMBERS\n//*\n//UPDATE13 EXEC PGM=IEBCOPY\n//SYSPRINT DD  SYSOUT=*\n//SYSUT3   DD  SPACE=(CYL,1),UNIT=SYSDA\n//SYSUT4   DD  SPACE=(CYL,1),UNIT=SYSDA\n//IN1      DD  DSN=SYS3.ONEPAK.CNTL,DISP=SHR\n//OUT1     DD  DSN=SYS2.PROCLIB,DISP=SHR,\n//             UNIT=SYSDA,VOL=SER=SYS1PK\n//IN2      DD  DSN=SYS3.ONEPAK.CNTL,DISP=SHR\n//OUT2     DD  DSN=SYS1.PROCLIB,DISP=SHR,\n//             UNIT=SYSDA,VOL=SER=SYS1PK\n//IN3      DD  DSN=SYS3.ONEPAK.CNTL,DISP=SHR\n//OUT3     DD  DSN=SYS1.PARMLIB,DISP=SHR,\n//             UNIT=SYSDA,VOL=SER=SYS1PK\n//IN4      DD  DSN=SYS3.ONEPAK.CNTL,DISP=SHR\n//OUT4     DD  DSN=SYS1.VTAMLST,DISP=SHR,\n//             UNIT=SYSDA,VOL=SER=SYS1PK\n//SYSIN    DD  *\n  COPY   I=((IN1,R)),O=OUT1\n  SELECT MEMBER=IKJACCNT\n  SELECT MEMBER=TSOPROC\n  SELECT MEMBER=SOFTPROC\n  COPY   I=((IN2,R)),O=OUT2\n  SELECT MEMBER=JES2\n  SELECT MEMBER=NET\n  SELECT MEMBER=TSO\n  COPY   I=((IN3,R)),O=OUT3\n  SELECT MEMBER=COMMND00\n  SELECT MEMBER=CONSOL00\n  SELECT MEMBER=IEAAPF00\n  SELECT MEMBER=IEAFIX00\n  SELECT MEMBER=IEALPA00\n  SELECT MEMBER=IEASVC00\n  SELECT MEMBER=IEASYS00\n  SELECT MEMBER=IECIOS00\n  SELECT MEMBER=IEFSSN00\n  SELECT MEMBER=JES2PARM\n  SELECT MEMBER=LNKLST00\n  SELECT MEMBER=LOAD00\n  SELECT MEMBER=LPALST00\n  SELECT MEMBER=SMFPRM00\n  SELECT MEMBER=MPFLST00\n  SELECT MEMBER=TSOKEY00\n  SELECT MEMBER=VATLST00\n  COPY   I=((IN4,R)),O=OUT4\n  SELECT MEMBER=APTSO\n  SELECT MEMBER=ATCCON00\n  SELECT MEMBER=ATCSTR00\n  SELECT MEMBER=LCL3270A\n/*\n//*\n//LIST14 EXEC  PGM=IDCAMS\n//STEPCAT  DD  DSN=SYS1.MCAT.VSYS1PK,DISP=SHR\n//SYSPRINT DD  SYSOUT=*\n//SYSUDUMP DD  SYSOUT=*\n//SYSIN    DD  *\n     LISTC CATALOG(SYS1.MCAT.VSYS1PK) ALL\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PREFIX": {"ttr": 13580, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x992/\\x01\\x13(\\x0f\\x14\\x15\\x00\\x9b\\x00\\x80\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf7@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "2013-10-07T14:15:00", "lines": 155, "newlines": 128, "modlines": 0, "user": "CBT487"}, "text": "/* REXX */\n/*                           */\n/* AUTHOR: Mark Zelden       */\n/*                           */\n/* Last Updated 10/07/2013   */\n/*                           */\nhelp_start = HELP_INCL()\n/**********************************************************/\n/* This edit macro will add a character string prefix     */\n/* to the beginning of a line before the first non-blank  */\n/* character, shifting data to the right. The prefix can  */\n/* optionally be limited to specific lines if labels      */\n/* are used. Excluded lines are omitted from the          */\n/* operation.                                             */\n/*                                                        */\n/* EXAMPLES:                                              */\n/*            PREFIX \"'\"                                  */\n/*            PREFIX 'DELETE ' .A .B                      */\n/*                                                        */\n/*                                                        */\n/*  ** NOTE  If you execute PREFIX with no parms or with  */\n/*           a parm of \"?\", the comment section of this   */\n/*           code with examples will be displayed as      */\n/*           \"help\" note lines.  Use the \"RESET\"          */\n/*           command to remove them.                      */\n/*                                                        */\n/**********************************************************/\nhelp_end = HELP_INCL()\n/* TRACE ?R */\nAddress ISREDIT\n\"MACRO (parm label1 label2)\"\n/* Address ISPEXEC \"CONTROL ERRORS RETURN\"  */\n/*                                                    */\nIf parm = '?' then do\n  Call HELP_NOTELINES\n  Exit 1  /* return cursor to command line */\nEnd\nIf parm = '' then do\n  zedsmsg = 'NO PREFIX SPECIFIED'\n  zedlmsg = 'YOU MUST PASS A PARM STRING',\n            'FOR PREFIX TO ADD.'\n  Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n  Call HELP_NOTELINES\n  Exit 4\nEnd\n/*                                                    */\nCall FIND_LABELS  /* find out if labels are being used  */\n/*                                             */\n/*   HOUSE KEEPING                             */\n/*                                             */\n\"(width) = DATA_WIDTH \" /* length of line  */\ncount    = 0     /* count of changed lines */\ntruncat  = 0     /* lines truncated count  */\ntruncmsg = \"'*** THE NEXT LINE WAS TRUNCATED AT THE END ***'\"\n/*                                             */\n/* If the prefix is is delimted by single or   */\n/* double quotes - then remove the delimiters  */\n/*                                             */\nIf Substr(parm,1,1) = '''' | Substr(parm,1,1) = '\"' then\nparm = Substr(parm,2,Length(parm)-2)\n/***********************************************/\n/*   BEGIN PREFIX PROCESSING                   */\n/***********************************************/\nDo until lastln = firstln-1\n  /* copy the data in the current line to variable 'data1' */\n  \"(data1) = LINE \"firstln\n  \"ISREDIT (chkexcl) = XSTATUS\" firstln\n  If chkexcl = \"NX\" then do\n\n    len1  = Length(Strip(data1,L))\n    len2  = width-len1+1\n    len3  = Length(Strip(data1,T))\n    len4  = Length(parm)\n\n    /* check if adding the prefix will cause truncation     */\n    If len3 + len4 > width then do\n      truncat = truncat + 1\n      \"ISREDIT LINE_BEFORE\" firstln \"= NOTELINE \" truncmsg\n    End\n\n    blnks = Substr(data1,1,len2-1)\n    data2 = substr(data1,len2,len1)\n    data1 = blnks || parm || data2\n\n    count = count + 1\n  End\n  /* copy the prefixed 'data1' back into the current line */\n  \"LINE\" firstln \"= (data1)\"\n  firstln = firstln + 1\nEnd   /* do until   */\n/***********************************************/\n/*   END PREFIX PROCESSING                     */\n/***********************************************/\nIf truncat = 0 then do\n  zedsmsg = count 'LINES CHANGED'\n  zedlmsg = 'PREFIX \"'parm'\" WAS ADDED ON' count 'LINES.'\n  Address ISPEXEC \"SETMSG MSG(ISRZ000)\"  /* msg - no alarm */\n  Exit 1  /* return cursor to command line */\nEnd\nElse do\n  zedsmsg = 'TRUNCATED ON' truncat 'LINES'\n  zedlmsg = 'PREFIX \"'parm'\" WAS ADDED ON' count 'LINES',\n            '('truncat 'LINES WERE TRUNCATED).'\n  Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n  Exit 4\nEnd\n/*********************************/\n/*  HELP SUB-ROUTINES            */\n/*********************************/\nHELP_INCL:\nReturn SIGL\nHELP_NOTELINES:\n\"(helpln) = DISPLAY_LINES\"\nDo hlp = help_end-1 to help_start+1 by -1\n  hline = Sourceline(hlp)\n  \"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline)\"\nEnd\nhline2 = '==================='\nhline3 = '===   H E L P   ==='\n\"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline2)\"\n\"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline3)\"\n\"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline2)\"\nReturn\n/*********************************/\n/*  SUB-ROUTINE TO FIND LABELS   */\n/*********************************/\nFIND_LABELS:\nAddress ISPEXEC \"CONTROL ERRORS RETURN\"\nIf label1 = '' then do\n  firstln  = 1\n  \"(lastln) = LINENUM .ZLAST\"\nEnd\nElse do\n  If label2 = '' then label2 = label1\n  \"(firstsv)  = LINENUM\" label1\n  If RC >= 8 then do\n    zedsmsg = 'RANGE LABEL ERROR'\n    zedlmsg = 'THE SPECIFIED RANGE LABEL \"' || label1 '\" WAS',\n              'NOT FOUND'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\n  \"(lastsv)   = LINENUM\" label2\n  If RC >= 8 then do\n    zedsmsg = 'RANGE LABEL ERROR'\n    zedlmsg = 'THE SPECIFIED RANGE LABEL \"' || label2 '\" WAS',\n              'NOT FOUND'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\n  firstln = Min(firstsv,lastsv)\n  lastln  = Max(firstsv,lastsv)\nAddress ISPEXEC \"CONTROL ERRORS\"\nEnd /* else do */\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PREFIX2": {"ttr": 13828, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x992/\\x01\\x13(\\x0f\\x14\\x15\\x00\\x95\\x00z\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf7@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "2013-10-07T14:15:00", "lines": 149, "newlines": 122, "modlines": 0, "user": "CBT487"}, "text": "/* REXX */\n/*                           */\n/* AUTHOR: Mark Zelden       */\n/*                           */\n/* Last Updated 10/07/2013   */\n/*                           */\nhelp_start = HELP_INCL()\n/**********************************************************/\n/* This edit macro will add a character string prefix     */\n/* to the beginning of a line before the first non-blank  */\n/* character. The prefix can optionally be limited to     */\n/* specific lines if labels are used. Excluded lines      */\n/* are omitted from the operation.                        */\n/*                                                        */\n/* EXAMPLES:                                              */\n/*            PREFIX2 \"'\"                                 */\n/*            PREFIX2 'DSN=' .A .B                        */\n/*                                                        */\n/*                                                        */\n/*  ** NOTE  If you execute PREFIX2 with no parms or with */\n/*           a parm of \"?\", the comment section of this   */\n/*           code with examples will be displayed as      */\n/*           \"help\" note lines.  Use the \"RESET\"          */\n/*           command to remove them.                      */\n/*                                                        */\n/**********************************************************/\nhelp_end = HELP_INCL()\n/* TRACE ?R */\nAddress ISREDIT\n\"MACRO (parm label1 label2)\"\n/* Address ISPEXEC \"CONTROL ERRORS RETURN\"  */\n/*                                                    */\nIf parm = '?' then do\n  Call HELP_NOTELINES\n  Exit 1  /* return cursor to command line */\nEnd\nIf parm = '' then do\n  zedsmsg = 'NO PREFIX SPECIFIED'\n  zedlmsg = 'YOU MUST PASS A PARM STRING',\n            'FOR PREFIX2 TO ADD.'\n  Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n  Call HELP_NOTELINES\n  Exit 4\nEnd\n/*                                                    */\nCall FIND_LABELS  /* find out if labels are being used  */\n/*                                             */\n/*   HOUSE KEEPING                             */\n/*                                             */\n\"(width) = DATA_WIDTH \" /* length of line  */\ncount    = 0     /* count of changed lines */\ntruncat  = 0     /* lines truncated count  */\ntruncmsg = \"'*** THE PREFIX WAS TRUNCATED ON THE NEXT LINE ***'\"\n/*                                             */\n/* If the prefix is is delimted by single or   */\n/* double quotes - then remove the delimiters  */\n/*                                             */\nIf Substr(parm,1,1) = '''' | Substr(parm,1,1) = '\"' then\nparm = Substr(parm,2,Length(parm)-2)\n/***********************************************/\n/*   BEGIN PREFIX PROCESSING                   */\n/***********************************************/\nDo until lastln = firstln-1\n  /* copy the data in the current line to variable 'data1' */\n  \"(data1) = LINE \"firstln\n  \"ISREDIT (chkexcl) = XSTATUS\" firstln\n  If chkexcl = \"NX\" then do\n    len1  = Length(Strip(data1,L))\n    len2  = width-len1-Length(parm)+1\n    If len2 < 1 then do\n      len2 = 1\n      parmt = Substr(parm,1,width-len1)\n      data1 = Overlay(parmt,data1,len2)\n      truncat = truncat + 1\n      \"ISREDIT LINE_BEFORE\" firstln \"= NOTELINE \" truncmsg\n    End\n    Else\n      data1 = Overlay(parm,data1,len2)\n   count = count + 1\n   End\n  /* copy the prefixed 'data1' back into the current line */\n  \"LINE\" firstln \"= (data1)\"\n  firstln = firstln + 1\nEnd   /* do until   */\n/***********************************************/\n/*   END PREFIX PROCESSING                     */\n/***********************************************/\nIf truncat = 0 then do\n  zedsmsg = count 'LINES CHANGED'\n  zedlmsg = 'PREFIX \"'parm'\" WAS ADDED ON' count 'LINES.'\n  Address ISPEXEC \"SETMSG MSG(ISRZ000)\"  /* msg - no alarm */\n  Exit 1  /* return cursor to command line */\nEnd\nElse do\n  zedsmsg = 'TRUNCATED ON' truncat 'LINES'\n  zedlmsg = 'PREFIX \"'parm'\" WAS ADDED ON' count 'LINES',\n            '('truncat 'LINES WERE TRUNCATED).'\n  Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n  Exit 4\nEnd\n/*********************************/\n/*  HELP SUB-ROUTINES            */\n/*********************************/\nHELP_INCL:\nReturn SIGL\nHELP_NOTELINES:\n\"(helpln) = DISPLAY_LINES\"\nDo hlp = help_end-1 to help_start+1 by -1\n  hline = Sourceline(hlp)\n  \"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline)\"\nEnd\nhline2 = '==================='\nhline3 = '===   H E L P   ==='\n\"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline2)\"\n\"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline3)\"\n\"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline2)\"\nReturn\n/*********************************/\n/*  SUB-ROUTINE TO FIND LABELS   */\n/*********************************/\nFIND_LABELS:\nAddress ISPEXEC \"CONTROL ERRORS RETURN\"\nIf label1 = '' then do\n  firstln  = 1\n  \"(lastln) = LINENUM .ZLAST\"\nEnd\nElse do\n  If label2 = '' then label2 = label1\n  \"(firstsv)  = LINENUM\" label1\n  If RC >= 8 then do\n    zedsmsg = 'RANGE LABEL ERROR'\n    zedlmsg = 'THE SPECIFIED RANGE LABEL \"' || label1 '\" WAS',\n              'NOT FOUND'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\n  \"(lastsv)   = LINENUM\" label2\n  If RC >= 8 then do\n    zedsmsg = 'RANGE LABEL ERROR'\n    zedlmsg = 'THE SPECIFIED RANGE LABEL \"' || label2 '\" WAS',\n              'NOT FOUND'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\n  firstln = Min(firstsv,lastsv)\n  lastln  = Max(firstsv,lastsv)\nAddress ISPEXEC \"CONTROL ERRORS\"\nEnd /* else do */\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACFUDEL": {"ttr": 13832, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x992/\\x01\\x05\\x15\\x9f\\x15\\x00\\x01\\xc2\\x01\\xbf\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf6\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "2005-06-08T15:00:00", "lines": 450, "newlines": 447, "modlines": 0, "user": "CBT469"}, "text": "//TSGMXZ1R JOB (AD00),'#04D42 ZELDEN',\n//             NOTIFY=&SYSUID,\n//             CLASS=M,MSGCLASS=H,MSGLEVEL=(1,1)\n//*\n//**********************************************************\n//*  COPY REXX PROGRAM TO A TEMPORARY PDS\n//**********************************************************\n//GENER     EXEC PGM=IEBGENER\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DUMMY\n//SYSUT1    DD DATA,DLM=@#\n/* rexx */\n/*                                       */\n/* AUTHOR: Mark Zelden                   */\n/*                                       */\n/********************************************************************/\n/* This program reads the output from the RACF database unload      */\n/* utility IRRDBU00. It creates two output files and a report. The  */\n/* report lists all of the USERIDs that are have not been accessed  */\n/* a specified number of days taken from an input parm to this      */\n/* program (the default is 180 days).   The first output file       */\n/* contains RACF \"DELUSER\" commands.   The second output file       */\n/* contains \"DELETE\" commands for user datasets (if the dataset is  */\n/* migrated the command is changed to \"HDELETE\") and aliases, and   */\n/* also contains \"DELDSD\" commands for any dataset profiles for     */\n/* the user.                                                        */\n/*                                                                  */\n/* The record layout for the utility can be found in SYS1.SAMPLIB   */\n/* member RACDBULD. This program has been tested successfully with  */\n/* RACF V1.9.2 and RACF V2.1.                                       */\n/********************************************************************/\n/* SAMPLE EXECUTION JCL:                                            */\n/* (This program must be run under the TMP because of TSO commands  */\n/* that are issued from within the program).                        */\n/*                                                                  */\n/* //MYJOB   JOB (ACCT),CLASS=M,MSGCLASS=H                          */\n/* //TMP      EXEC PGM=IKJEFT01,REGION=2M                           */\n/* //SYSEXEC  DD DSN=REXX.EXEC.LIBRARY,DISP=SHR                     */\n/* //RACFIN   DD DSN=RACF.UNLOADED.DATABASE,DISP=SHR                */\n/* //DELUSER DD   DSN=USERID.RACF.DELUSER,DISP=(NEW,CATLG,DELETE),  */\n/* //             UNIT=SYSALLDA,SPACE=(TRK,(15,5),RLSE),            */\n/* //             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)              */\n/* //DELTSO   DD  DSN=USERID.RACF.DELTSO,DISP=(NEW,CATLG,DELETE),   */\n/* //             UNIT=SYSALLDA,SPACE=(TRK,(15,5),RLSE),            */\n/* //             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)              */\n/* //DELRPT   DD SYSOUT=*,DCB=(LRECL=133,RECFM=FBA,BLKSIZE=3990)    */\n/* //SYSTSPRT DD SYSOUT=*                                           */\n/* //SYSTSIN  DD *                                                  */\n/*   %RACFUDEL 180                                                  */\n/* /*                                                             */*/\n/* //  180 = THE NUMBER OF DAYS SINCE THE USERID WAS LAST ACCESSED  */\n/********************************************************************/\narg NUMDAYS\nif NUMDAYS = '' then\n  NUMDAYS = 180 /* number of days since accessed */\n\nCAT1 ='MCAT.ICF.VACAT43'\nCAT2 ='MCAT.ICF.VBCAT43'\n\nCURDATE  = Translate(Date('N'))  /* DD MMM YYYY  */\nCALL RDATE(TODAY)                  /* Get number of days             */\nCURNDATE = Substr(RESULT,16,5)     /* NNNNN   date from RDATE        */\nRECNUM   = 1 /* current record NUMBER */\nTOTAL    = 0 /* total number of records */\nPAGEC    = 1 /* page counter */\nLINEC    = 0 /* line couter  */\n\ncall NEWPAGE\n\ndo forever\n  \"EXECIO 1 DISKR RACFIN \"RECNUM\n  if rc<>0 then leave  /* no more records - exit loop */\n  RECNUM = RECNUM+1\n  parse pull INREC\n  TYPE = Substr(inrec,1,4) /* record type */\n  if TYPE <> '0200' then iterate  /* not user record */\n\n  TEMPY = Substr(inrec,114,4)\n  TEMPM = Substr(inrec,119,2)\n  TEMPD = Substr(inrec,122,2)\n  if TEMPY <> '' then do\n    Call RDATE TEMPM TEMPD TEMPY\n    DATEACC = Substr(RESULT,16,5) /* century date from RDATE */\n    NEVERUSED = 'N'\n  end\n  else do\n    DATEACC   = 00000\n    NEVERUSED = 'Y'\n  end\n  if CURNDATE - NUMDAYS \u00ac> DATEACC then iterate /* not enough time */\n  /******************************/\n  /* USERID met age criteria    */\n  /******************************/\n\n  If LINEC > 55 then call NEWPAGE  /* do we need a new page? */\n\n  LASTDATE = Substr(inrec,114,10)\n  USERID   = substr(inrec,6,8)\n  USERIDX  = Strip(USERID)\n  NAME     = substr(inrec,75,20)\n  if Substr(inrec,50,1) = 'Y' then REVOKMSG = ' REVOKED=Y '\n    else  REVOKMSG = ' REVOKED=N '\n\n  if NEVERUSED = 'Y' then\n    ACCMSG = 'LAST ACCESS UNKNOWN (ID NEVER USED)'\n  else\n    ACCMSG = 'LAST ACCESSED ON' LASTDATE\n  queue ' ' USERID NAME REVOKMSG ACCMSG\n  \"EXECIO 1 DISKW DELRPT\"\n\n  /******************************************************************/\n  /* Check to see if user has a TSO segment                         */\n  /******************************************************************/\n  /* \"EXECIO 1 DISKR RACFIN \"RECNUM                                 */\n  /* if rc<>0 then leave  /* no more records - exit loop */         */\n  /* RECNUM = RECNUM+1                                              */\n  /* parse pull INREC2                                              */\n  /* TYPE2 = Substr(inrec2,1,4) /* record type */                   */\n  /* if TYPE2 = '0220' then call DELTSO_USER /* tso segment ? */    */\n  /******************************************************************/\n  Call DELTSO_USER /* check for dsns, aliases and dsn profiles */\n\n  queue ' DELUSER ' USERID ' /*' NAME '*/'\n  \"EXECIO 1 DISKW DELUSER\"\n\n  TOTAL = TOTAL+1\n  LINEC  = LINEC+1\n\nEnd  /* do forever */\n/******************************************/\n/* write totals                           */\n/******************************************/\n\nIf LINEC > 52 then call NEWPAGE  /* do we need a new page? */\n\nqueue '                               '\nqueue '                               '\nqueue ' THE TOTAL NUMBER OF REVOKED USERIDS THAT HAVE',\n     'NOT BEEN USED IN' numdays 'DAYS WAS' total\n\"EXECIO 3 DISKW DELRPT\"\n/******************************************/\n/* close files and exit                   */\n/******************************************/\n\"EXECIO 0 DISKR RACFIN   (FINIS\"\n\"EXECIO 0 DISKW DELUSER (FINIS\"\n\"EXECIO 0 DISKW DELTSO   (FINIS\"\n\"EXECIO 0 DISKW DELRPT   (FINIS\"\nExit 0\n\n\n/******************************************/\n/* SUB ROUTINES                           */\n/******************************************/\nDELTSO_USER:\n/*********************************************************************/\n/* check if user has any datasets cataloged                          */\n/*********************************************************************/\njunk=outtrap(LISTC.)\n\"LISTCAT LEVEL('\" || USERIDX || \"') ALL\"\nRETCODE = RC\njunk=outtrap('off')\nIf RETCODE = 0 then do /* user has datasets */\n  do SCAN1 = 1 to LISTC.0\n    if Pos('--- ' || USERIDX,LISTC.SCAN1) = 0 then iterate\n    DSN = Strip(Substr(LISTC.SCAN1,17,44))\n    line# = SCAN1\n    do SCAN2 = line# to LISTC.0\n      if Pos('VOLSER---',LISTC.SCAN2) = 0 then iterate\n      VOL = Substr(LISTC.SCAN2,26,6)\n      leave\n    end /* do SCAN2 */\n    if Datatype(VOL,number) = 1 then iterate /* tape vol - skip */\n    if VOL = 'MIGRAT' then CMD = 'HDELETE'\n      else CMD = 'DELETE'\n    queue ' ' || CMD || ' ''' || DSN || ''''\n    \"EXECIO 1 DISKW DELTSO\"\n  end /* do SCAN1 */\nend\n/*********************************************************************/\n/* check for aliases                                                 */\n/*********************************************************************/\njunk=outtrap(dummy.)\n\"LISTCAT ENT('\" || USERIDX || \"')   CAT('\" || CAT1 || \"')\"\nif rc = 0 then do\n  queue ' DELETE  ''' || USERIDX || ''' CATALOG(''' || CAT1 || ''')'\n  \"EXECIO 1 DISKW DELTSO\"\nend\n\"LISTCAT ENT('\" || USERIDX || \"')   CAT('\" || CAT2 || \"')\"\nif rc = 0 then do\n  queue ' DELETE  ''' || USERIDX || ''' CATALOG(''' || CAT2 || ''')'\n  \"EXECIO 1 DISKW DELTSO\"\nend\njunk=outtrap('off')\n/*********************************************************************/\n/* Check for RACF dataset profiles                                   */\n/*********************************************************************/\njunk=outtrap(SEARCH.)\n\"SEARCH MASK(\" || USERIDX || \".)\"\nRETCODE = RC\njunk=outtrap('off')\nIf RETCODE = 0 then do /* user has datasets */\n  do PROF = 1 to SEARCH.0\n    queue ' DELDSD  ''' || Word(SEARCH.PROF,1) || ''''\n    \"EXECIO 1 DISKW DELUSER\"\n  end\nend\nreturn\n\n\nNEWPAGE:\nqueue '1      USERIDS THAT HAVE NOT BEEN',\n     'USED IN' numdays 'DAYS    ' curdate '    PAGE' pagec\nqueue '                                           '\nqueue '                                           '\n\"EXECIO 3 DISKW DELRPT\"\nLINEC = 3\nPAGEC  = PAGEC+1\nreturn\n\n/* rexx */\nRDATE:\n/*                                       */\n/* AUTHOR: Mark Zelden                   */\n/*                                       */\n/************************************************/\n/* Convert MM DD YYYY , YYYY DDD, or NNNNN to   */\n/* standard date output that includes the day   */\n/* of the week and the number of days (NNNNN)   */\n/* from January 1, 1900. This is not the same   */\n/* as the Century date! Valid input dates range */\n/* from 01/01/1900 through 12/31/2172.          */\n/*                                              */\n/* A parm of \"TODAY\" can also be passed to      */\n/* the date conversion routine.                 */\n/* MM DD YYYY can also be specifed as           */\n/* MM/DD/YYYY or MM-DD-YYYY.                    */\n/*                                              */\n/* The output format is always as follows:      */\n/*      MM/DD/YYYY.JJJ NNNNN WEEKDAY            */\n/*                                              */\n/* The above value will be put in the special   */\n/* REXX variable \"RESULT\"                       */\n/* example: CALL RDATE TODAY                    */\n/* example: CALL RDATE 1996 300                 */\n/* example: CALL RDATE 10 26 1996               */\n/* example: CALL RDATE 10/26/1996               */\n/* example: CALL RDATE 10-26-1996               */\n/* example: CALL RDATE 35363                    */\n/* result:  10/26/1996.300 35363 Saturday       */\n/************************************************/\narg P1 P2 P3\n\nIf Pos('/',P1) <> 0 | Pos('-',P1) <> 0 then do\n  PX =  Translate(P1,'  ','/-')\n  Parse var PX P1 P2 P3\nEnd\n\nJULTBL = '000031059090120151181212243273304334'\nDAY.0 = 'Sunday'\nDAY.1 = 'Monday'\nDAY.2 = 'Tuesday'\nDAY.3 = 'Wednesday'\nDAY.4 = 'Thursday'\nDAY.5 = 'Friday'\nDAY.6 = 'Saturday'\n\nSelect\n  When P1 = 'TODAY' then do\n    P1 = Substr(date('s'),5,2)\n    P2 = Substr(date('s'),7,2)\n    P3 = Substr(date('s'),1,4)\n    call CONVERT_MDY\n    call THE_END\n  end\n  When P2 = '' & P3 = '' then do\n    call CONVERT_NNNNN\n    call THE_END\n  end\n  When P3 = '' then do\n    call CONVERT_JDATE\n    call DOUBLE_CHECK\n    call THE_END\n  end\n  otherwise do\n    call CONVERT_MDY\n    call DOUBLE_CHECK\n    call THE_END\n  end\nend /* end select */\n/* say RDATE_VAL; exit 0 */\nreturn RDATE_VAL\n/**********************************************/\n/*  E N D    O F   M A I N L I N E   C O D E  */\n/**********************************************/\n\nCONVERT_MDY:\nif P1<1 | P1>12 then do\n  say 'Invalid month passed to date routine'\n  exit 12\nend\nif P2<1 | P2>31 then do\n  say 'Invalid day passed to date routine'\n  exit 12\nend\nif (P1=4 | P1=6 | P1=9 | P1=11) & P2>30 then do\n  say 'Invalid day passed to date routine'\n  exit 12\nend\nif P3<1900 | P3>2172 then do\n  say 'Invalid year passed to date routine. Must be be 1900-2172'\n  exit 12\nend\nBASE   = Substr(JULTBL,((P1-1)*3)+1,3)\nif (P3//4=0 & P3<>1900 & P3<>2100) then LEAP= 1\n  else LEAP = 0\nif P1 > 2 then BASE = BASE+LEAP\nJJJ = BASE + P2\n\nMM   = P1\nDD   = P2\nYYYY = P3\nreturn\n\nCONVERT_NNNNN:\nif P1<1 | P1>99712 then do\n  say 'Invalid date passed to date routine. NNNNN must be 1-99712'\n  exit 12\nend\n/* Determine YYYY and JJJ */\nif P1>365 then P1=P1+1\nYEARS_X4=(P1-1)%1461\nJJJ=P1-YEARS_X4*1461\nif P1 > 73415 then JJJ = JJJ +1\nEXTRA_YEARS=(JJJ*3-3)%1096\nJJJ=JJJ-(EXTRA_YEARS*1096+2)%3\nYYYY=YEARS_X4*4+EXTRA_YEARS+1900\nP1 = YYYY ; P2 = JJJ ;  call CONVERT_JDATE\n\nCONVERT_JDATE:\nif P1<1900 | P1>2172 then do\n  say 'Invalid year passed to date routine. Must be be 1900-2172'\n  exit 12\nend\nif P2<1 | P2>366 then do\n  say 'Invalid Julian date passed to date routine'\n  exit 12\nend\nif (P1//4=0 & P1<>1900 & P1<>2100) then LEAP= 1\n  else LEAP = 0\nADJ1 = 0\nADJ2 = 0\nDo MM = 1 to 11\n   VAL1 = Substr(JULTBL,((MM-1)*3)+1,3)\n   VAL2 = Substr(JULTBL,((MM-1)*3)+4,3)\n   if MM >=2 then ADJ2 = LEAP\n   if MM >=3 then ADJ1 = LEAP\n   if P2 > VAL1+ADJ1 & P2 <= VAL2+ADJ2 then do\n        DD = P2-VAL1-ADJ1\n        MATCH = 'Y'\n        leave\n   end\nend\nif MATCH <> 'Y' then do\n    MM = 12\n    DD = P2-334-LEAP\nend\n\nYYYY = P1\nJJJ  = P2\nreturn\n\nDOUBLE_CHECK:\nif MM = 2 then do\n   if DD > 28 & LEAP = 0 then do\n     say 'Invalid day passed to date routine'\n     exit 12\n   end\n   if DD > 29 & LEAP = 1 then do\n     say 'Invalid day passed to date routine'\n     exit 12\n   end\nend\nif LEAP = 0 & JJJ > 365 then do\n  say 'Invalid Julian date passed to date routine'\n  exit 12\nend\nreturn\n\nTHE_END:\nYR_1900 = YYYY-1900\nNNNNN = (YR_1900*365) +(YR_1900+3)%4 + JJJ\nif YYYY > 1900 then NNNNN = NNNNN-1\nif YYYY > 2100 then NNNNN = NNNNN-1\nINDEX   = NNNNN//7  /* index to DAY stem */\nWEEKDAY =  DAY.INDEX\n\nDD      = Right(DD,2,'0')\nMM      = Right(MM,2,'0')\nYYYY    = Strip(YYYY)\nNNNNN   = Right(NNNNN,5,'0')\nJJJ     = Right(JJJ,3,'0')\n\nRDATE_VAL = MM||'/'||DD||'/'||YYYY||'.'||JJJ||' '||NNNNN||' '||WEEKDAY\nreturn\n@#\n//SYSUT2   DD  DSN=&&PDS(RACFUDEL),UNIT=SYSDA,\n//             DISP=(NEW,PASS,DELETE),\n//             SPACE=(TRK,(1,1,1)),\n//             DCB=(LRECL=80,BLKSIZE=3120,RECFM=FB,DSORG=PO)\n//**********************************************************\n//*  UNLOAD RACF DATABASE TO A FLAT FILE\n//**********************************************************\n//UNLOAD  EXEC PGM=IRRDBU00,\n//             PARM='NOLOCKINPUT'\n//SYSPRINT  DD SYSOUT=*\n//SYSUDUMP  DD SYSOUT=*\n//INDD1     DD DSN=SYS1.RACF,DISP=SHR\n//OUTDD     DD DSN=&&FLAT,DISP=(,PASS,DELETE),\n//             SPACE=(CYL,(10,10),RLSE),\n//             UNIT=SYSDA,\n//*            DCB=(LRECL=2048,BLKSIZE=27998,RECFM=VB) /* RACF 1.9 */\n//             DCB=(LRECL=4098,BLKSIZE=27998,RECFM=VB) /* RACF 2.1 */\n//**********************************************************\n//* DELETE \"DELUSER\" AND \"DELTSO\" FILES IF THEY EXIST\n//**********************************************************\n//BR14   EXEC PGM=IEFBR14\n//DELUSER DD   DSN=TSGMXZ1.RACF.DELUSER,DISP=(MOD,DELETE),\n//             UNIT=SYSALLDA,SPACE=(TRK,1)\n//DELTSO   DD  DSN=TSGMXZ1.RACF.DELTSO,DISP=(MOD,DELETE),\n//             UNIT=SYSALLDA,SPACE=(TRK,1)\n//**********************************************************\n//*  EXEC \"RACFUDEL\" REXX CLIST IN BATCH\n//*  PARM OF 180 = NUMBER OF DAYS SINCE LAST USED\n//*********************************************************\n//TMP      EXEC PGM=IKJEFT01,REGION=2M\n//**********************************************************\n//SYSEXEC  DD  DSN=&&PDS,DISP=(OLD,DELETE,DELETE)\n//RACFIN   DD  DSN=&&FLAT,DISP=(OLD,DELETE,DELETE)\n//DELUSER  DD  DSN=TSGMXZ1.RACF.DELUSER,DISP=(NEW,CATLG,DELETE),\n//             UNIT=SYSALLDA,SPACE=(TRK,(15,5),RLSE),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)\n//DELTSO   DD  DSN=TSGMXZ1.RACF.DELTSO,DISP=(NEW,CATLG,DELETE),\n//             UNIT=SYSALLDA,SPACE=(TRK,(15,5),RLSE),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)\n//DELRPT   DD SYSOUT=*,DCB=(LRECL=133,RECFM=FBA,BLKSIZE=3990)\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\n  %RACFUDEL 180\n/*\n//* 180 = THE NUMBER OF DAYS SINCE THE USERID WAS LAST ACCESSED\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RDATE": {"ttr": 14084, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x992/\\x01\\x073\\x8f\\x14%\\x00\\xba\\x00\\xb6\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "2007-12-04T14:25:00", "lines": 186, "newlines": 182, "modlines": 0, "user": "CBT475"}, "text": "/* rexx */\nRDATE:\n/*                                       */\n/* AUTHOR: Mark Zelden                   */\n/*                                       */\n/************************************************/\n/* Convert MM DD YYYY , YYYY DDD, or NNNNN to   */\n/* standard date output that includes the day   */\n/* of the week and the number of days (NNNNN)   */\n/* from January 1, 1900. This is not the same   */\n/* as the Century date! Valid input dates range */\n/* from 01/01/1900 through 12/31/2172.          */\n/*                                              */\n/* A parm of \"TODAY\" can also be passed to      */\n/* the date conversion routine.                 */\n/* MM DD YYYY can also be specifed as           */\n/* MM/DD/YYYY or MM-DD-YYYY.                    */\n/*                                              */\n/* The output format is always as follows:      */\n/*      MM/DD/YYYY.JJJ NNNNN WEEKDAY            */\n/*                                              */\n/* The above value will be put in the special   */\n/* REXX variable \"RESULT\"                       */\n/* example: CALL RDATE TODAY                    */\n/* example: CALL RDATE 1996 300                 */\n/* example: CALL RDATE 10 26 1996               */\n/* example: CALL RDATE 10/26/1996               */\n/* example: CALL RDATE 10-26-1996               */\n/* example: CALL RDATE 35363                    */\n/* result:  10/26/1996.300 35363 Saturday       */\n/************************************************/\narg P1 P2 P3\n\nIf Pos('/',P1) <> 0 | Pos('-',P1) <> 0 then do\n  PX =  Translate(P1,'  ','/-')\n  Parse var PX P1 P2 P3\nEnd\n\nJULTBL = '000031059090120151181212243273304334'\nDAY.0 = 'Sunday'\nDAY.1 = 'Monday'\nDAY.2 = 'Tuesday'\nDAY.3 = 'Wednesday'\nDAY.4 = 'Thursday'\nDAY.5 = 'Friday'\nDAY.6 = 'Saturday'\n\nSelect\n  When P1 = 'TODAY' then do\n    P1 = Substr(date('s'),5,2)\n    P2 = Substr(date('s'),7,2)\n    P3 = Substr(date('s'),1,4)\n    call CONVERT_MDY\n    call THE_END\n  end\n  When P2 = '' & P3 = '' then do\n    call CONVERT_NNNNN\n    call THE_END\n  end\n  When P3 = '' then do\n    call CONVERT_JDATE\n    call DOUBLE_CHECK\n    call THE_END\n  end\n  otherwise do\n    call CONVERT_MDY\n    call DOUBLE_CHECK\n    call THE_END\n  end\nend /* end select */\nsay RDATE_VAL; exit 0\n/* return RDATE_VAL  */\n/**********************************************/\n/*  E N D    O F   M A I N L I N E   C O D E  */\n/**********************************************/\n\nCONVERT_MDY:\nif P1<1 | P1>12 then do\n  say 'Invalid month passed to date routine'\n  exit 12\nend\nif P2<1 | P2>31 then do\n  say 'Invalid day passed to date routine'\n  exit 12\nend\nif (P1=4 | P1=6 | P1=9 | P1=11) & P2>30 then do\n  say 'Invalid day passed to date routine'\n  exit 12\nend\nif P3<1900 | P3>2172 then do\n  say 'Invalid year passed to date routine. Must be be 1900-2172'\n  exit 12\nend\nBASE   = Substr(JULTBL,((P1-1)*3)+1,3)\nif (P3//4=0 & P3<>1900 & P3<>2100) then LEAP= 1\n  else LEAP = 0\nif P1 > 2 then BASE = BASE+LEAP\nJJJ = BASE + P2\n\nMM   = P1\nDD   = P2\nYYYY = P3\nreturn\n\nCONVERT_NNNNN:\nif P1<1 | P1>99712 then do\n  say 'Invalid date passed to date routine. NNNNN must be 1-99712'\n  exit 12\nend\n/* Determine YYYY and JJJ */\nif P1>365 then P1=P1+1\nYEARS_X4=(P1-1)%1461\nJJJ=P1-YEARS_X4*1461\nif P1 > 73415 then JJJ = JJJ +1\nEXTRA_YEARS=(JJJ*3-3)%1096\nJJJ=JJJ-(EXTRA_YEARS*1096+2)%3\nYYYY=YEARS_X4*4+EXTRA_YEARS+1900\nP1 = YYYY ; P2 = JJJ ;  call CONVERT_JDATE\n\nCONVERT_JDATE:\nMATCH = 'N'\nif P1<1900 | P1>2172 then do\n  say 'Invalid year passed to date routine. Must be be 1900-2172'\n  exit 12\nend\nif P2<1 | P2>366 then do\n  say 'Invalid Julian date passed to date routine'\n  exit 12\nend\nif (P1//4=0 & P1<>1900 & P1<>2100) then LEAP= 1\n  else LEAP = 0\nADJ1 = 0\nADJ2 = 0\nDo MM = 1 to 11\n   VAL1 = Substr(JULTBL,((MM-1)*3)+1,3)\n   VAL2 = Substr(JULTBL,((MM-1)*3)+4,3)\n   if MM >=2 then ADJ2 = LEAP\n   if MM >=3 then ADJ1 = LEAP\n   if P2 > VAL1+ADJ1 & P2 <= VAL2+ADJ2 then do\n        DD = P2-VAL1-ADJ1\n        MATCH = 'Y'\n        leave\n   end\nend\nif MATCH <> 'Y' then do\n    MM = 12\n    DD = P2-334-LEAP\nend\n\nYYYY = P1\nJJJ  = P2\nreturn\n\nDOUBLE_CHECK:\nif MM = 2 then do\n   if DD > 28 & LEAP = 0 then do\n     say 'Invalid day passed to date routine'\n     exit 12\n   end\n   if DD > 29 & LEAP = 1 then do\n     say 'Invalid day passed to date routine'\n     exit 12\n   end\nend\nif LEAP = 0 & JJJ > 365 then do\n  say 'Invalid Julian date passed to date routine'\n  exit 12\nend\nreturn\n\nTHE_END:\nYR_1900 = YYYY-1900\nNNNNN = (YR_1900*365) +(YR_1900+3)%4 + JJJ\nif YYYY > 1900 then NNNNN = NNNNN-1\nif YYYY > 2100 then NNNNN = NNNNN-1\nINDEX   = NNNNN//7  /* index to DAY stem */\nWEEKDAY =  DAY.INDEX\n\nDD      = Right(DD,2,'0')\nMM      = Right(MM,2,'0')\nYYYY    = Strip(YYYY)\nNNNNN   = Right(NNNNN,5,'0')\nJJJ     = Right(JJJ,3,'0')\n\nRDATE_VAL = MM||'/'||DD||'/'||YYYY||'.'||JJJ||' '||NNNNN||' '||WEEKDAY\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RDATEF": {"ttr": 14088, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x05\\x15\\x9f\\x01\\x073\\x8f\\x14%\\x00\\xb1\\x00\\xb0\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-06-08T00:00:00", "modifydate": "2007-12-04T14:25:00", "lines": 177, "newlines": 176, "modlines": 0, "user": "CBT475"}, "text": "/* rexx */\nRDATE:\n/*                                       */\n/* AUTHOR: Mark Zelden                   */\n/*                                       */\n/************************************************/\n/*  Function version of RDATE                   */\n/************************************************/\n/* Convert MM DD YYYY , YYYY DDD, or NNNNN to   */\n/* standard date output that includes the day   */\n/* of the week and the number of days (NNNNN)   */\n/* from January 1, 1900. This is not the same   */\n/* as the Century date! Valid input dates range */\n/* from 01/01/1900 through 12/31/2172.          */\n/*                                              */\n/* A parm of \"TODAY\" can also be passed to      */\n/* the date conversion routine.                 */\n/*                                              */\n/* The result format is always as follows:      */\n/*      MM/DD/YYYY.JJJ NNNNN WEEKDAY            */\n/*                                              */\n/* example: X = RDATEF(TODAY)                   */\n/* example: X = RDATEF(1996,300)                */\n/* example: X = RDATEF(10,26,1996)              */\n/* example: X = RDATEF(35363)                   */\n/* result:  X = 10/26/1996.300 35363 Saturday   */\n/************************************************/\narg P1,P2,P3\n\nJULTBL = '000031059090120151181212243273304334'\nDAY.0 = 'Sunday'\nDAY.1 = 'Monday'\nDAY.2 = 'Tuesday'\nDAY.3 = 'Wednesday'\nDAY.4 = 'Thursday'\nDAY.5 = 'Friday'\nDAY.6 = 'Saturday'\n\nSelect\n  When P1 = 'TODAY' then do\n    P1 = Substr(date('s'),5,2)\n    P2 = Substr(date('s'),7,2)\n    P3 = Substr(date('s'),1,4)\n    call CONVERT_MDY\n    call THE_END\n  end\n  When P2 = '' & P3 = '' then do\n    call CONVERT_NNNNN\n    call THE_END\n  end\n  When P3 = '' then do\n    call CONVERT_JDATE\n    call DOUBLE_CHECK\n    call THE_END\n  end\n  otherwise do\n    call CONVERT_MDY\n    call DOUBLE_CHECK\n    call THE_END\n  end\nend /* end select */\n/* say RDATE_VAL; exit 0 */\nreturn RDATE_VAL\n/**********************************************/\n/*  E N D    O F   M A I N L I N E   C O D E  */\n/**********************************************/\n\nCONVERT_MDY:\nif P1<1 | P1>12 then do\n  say 'Invalid month passed to date routine'\n  exit 12\nend\nif P2<1 | P2>31 then do\n  say 'Invalid day passed to date routine'\n  exit 12\nend\nif (P1=4 | P1=6 | P1=9 | P1=11) & P2>30 then do\n  say 'Invalid day passed to date routine'\n  exit 12\nend\nif P3<1900 | P3>2172 then do\n  say 'Invalid year passed to date routine. Must be be 1900-2172'\n  exit 12\nend\nBASE   = Substr(JULTBL,((P1-1)*3)+1,3)\nif (P3//4=0 & P3<>1900 & P3<>2100) then LEAP= 1\n  else LEAP = 0\nif P1 > 2 then BASE = BASE+LEAP\nJJJ = BASE + P2\n\nMM   = P1\nDD   = P2\nYYYY = P3\nreturn\n\nCONVERT_NNNNN:\nif P1<1 | P1>99712 then do\n  say 'Invalid date passed to date routine. NNNNN must be 1-99712'\n  exit 12\nend\n/* Determine YYYY and JJJ */\nif P1>365 then P1=P1+1\nYEARS_X4=(P1-1)%1461\nJJJ=P1-YEARS_X4*1461\nif P1 > 73415 then JJJ = JJJ +1\nEXTRA_YEARS=(JJJ*3-3)%1096\nJJJ=JJJ-(EXTRA_YEARS*1096+2)%3\nYYYY=YEARS_X4*4+EXTRA_YEARS+1900\nP1 = YYYY ; P2 = JJJ ;  call CONVERT_JDATE\n\nCONVERT_JDATE:\nMATCH = 'N'\nif P1<1900 | P1>2172 then do\n  say 'Invalid year passed to date routine. Must be be 1900-2172'\n  exit 12\nend\nif P2<1 | P2>366 then do\n  say 'Invalid Julian date passed to date routine'\n  exit 12\nend\nif (P1//4=0 & P1<>1900 & P1<>2100) then LEAP= 1\n  else LEAP = 0\nADJ1 = 0\nADJ2 = 0\nDo MM = 1 to 11\n   VAL1 = Substr(JULTBL,((MM-1)*3)+1,3)\n   VAL2 = Substr(JULTBL,((MM-1)*3)+4,3)\n   if MM >=2 then ADJ2 = LEAP\n   if MM >=3 then ADJ1 = LEAP\n   if P2 > VAL1+ADJ1 & P2 <= VAL2+ADJ2 then do\n        DD = P2-VAL1-ADJ1\n        MATCH = 'Y'\n        leave\n   end\nend\nif MATCH <> 'Y' then do\n    MM = 12\n    DD = P2-334-LEAP\nend\n\nYYYY = P1\nJJJ  = P2\nreturn\n\nDOUBLE_CHECK:\nif MM = 2 then do\n   if DD > 28 & LEAP = 0 then do\n     say 'Invalid day passed to date routine'\n     exit 12\n   end\n   if DD > 29 & LEAP = 1 then do\n     say 'Invalid day passed to date routine'\n     exit 12\n   end\nend\nif LEAP = 0 & JJJ > 365 then do\n  say 'Invalid Julian date passed to date routine'\n  exit 12\nend\nreturn\n\nTHE_END:\nYR_1900 = YYYY-1900\nNNNNN = (YR_1900*365) +(YR_1900+3)%4 + JJJ\nif YYYY > 1900 then NNNNN = NNNNN-1\nif YYYY > 2100 then NNNNN = NNNNN-1\nINDEX   = NNNNN//7  /* index to DAY stem */\nWEEKDAY =  DAY.INDEX\n\nDD      = Right(DD,2,'0')\nMM      = Right(MM,2,'0')\nYYYY    = Strip(YYYY)\nNNNNN   = Right(NNNNN,5,'0')\nJJJ     = Right(JJJ,3,'0')\n\nRDATE_VAL = MM||'/'||DD||'/'||YYYY||'.'||JJJ||' '||NNNNN||' '||WEEKDAY\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXXMEM": {"ttr": 14092, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01%\\x0f\\x01\\x15\\x02\\x9f\\x10\\x15\\x01}\\x00\\xca\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf9\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-09-07T00:00:00", "modifydate": "2015-01-29T10:15:00", "lines": 381, "newlines": 202, "modlines": 0, "user": "CBT490"}, "text": "/* REXX -                                */\n/*                                       */\n/* AUTHOR: Mark Zelden                   */\n/*                                       */\n/*   Indirect storage addressing code    */\n/*   contribution from: Mau Tran         */\n/*                                       */\n/*                                       */\nhelp_start = HELP_INCL()\n/*********************************************************************/\n/* DISPLAY MEMORY IN \"DUMP\" FORMAT                                   */\n/*********************************************************************/\n/* EXECUTION SYNTAX:                                                 */\n/*                                                                   */\n/* TSO %REXXMEM <strt_addr> <length>                                 */\n/*                                                                   */\n/* The strt_addr and length values are expected to be hexidecimal.   */\n/* The hexadecimal values supplied may be represented with or        */\n/* without an \"X\". In other words, x'100' and 100 can both be        */\n/* processed and are treated the same.                               */\n/*                                                                   */\n/* strt_addr can also make use of indirect storage addressing        */\n/* similar to IPCS.  \"?\", \"%\", \"+\", \"-\" and \".\" are supported.       */\n/* See the examples below.                                           */\n/*                                                                   */\n/* NOTE #1: If no length is specified, then the default is 100 (hex).*/\n/*                                                                   */\n/* NOTE #2: While \".\" is supported like IPCS, it is not required     */\n/*          when the initial digit is the letter A through F like    */\n/*          it is in IPCS and is essentially ignored.                */\n/*                                                                   */\n/* NOTE #3: If any storage in the range is protected, then none of   */\n/*          it can be displayed. This is how the REXX STORAGE        */\n/*          function works.                                          */\n/*                                                                   */\n/* NOTE #4: If you execute REXXMEM without a parm or a parm of \"?\"   */\n/*          the comment section of this code with syntax and usage   */\n/*          notes plus examples will be displayed as \"help\".         */\n/*                                                                   */\n/* NOTE #5: In z/OS 2.1 and above strt_addr can be a 64-bit          */\n/*          address. The address specifcation rules are the          */\n/*          same as those documented in the TSO/E REXX reference     */\n/*          manual for the STORAGE TSO/E External Function.          */\n/*                                                                   */\n/*********************************************************************/\n/*                                                                   */\n/* Examples:                                                         */\n/*  TSO %REXXMEM                (display syntax, notes & examples)   */\n/*  TSO %REXXMEM 0              (start at x'00000000' for x'100')    */\n/*  TSO %REXXMEM 10 100         (start at x'00000010' for x'100')    */\n/*  TSO %REXXMEM x'10' x'100'   (start at x'00000010' for x'100')    */\n/*  TSO %REXXMEM FD0740         (start at x'00FD0740' for x'100')    */\n/*  TSO %REXXMEM FD0746 64      (start at x'00FD0746' for x'64')     */\n/*  TSO %REXXMEM 4C%            (24-bit ptr to stor at x'4C')        */\n/*  TSO %REXXMEM 10.%%          (24-bit ptr x'10' + 2nd 24-bit ptr)  */\n/*  TSO %REXXMEM 10?            (31-bit ptr to stor at x'10' - CVT)  */\n/*  TSO %REXXMEM 10?+8C? 200    (point to ECVT stor for x'200')      */\n/*  TSO %REXXMEM 10?+22C? 1E00  (point to ASVT stor for x'1E00')     */\n/*  TSO %REXXMEM 10?+8C?+188? 1000    (point to IPA for x'1000')     */\n/*  TSO %REXXMEM 1FFFFF00000          (64-bit address display)       */\n/*  TSO %REXXMEM 1FF_FFF00000 200     (64-bit display for x'200')    */\n/*                                                                   */\n/*********************************************************************/\nhelp_end = HELP_INCL()\n/*********************************************************************/\nLASTUPD = '01/29/2015'                    /* date of last update     */\n/*********************************************************************/\nArg R_ADDR R_LEN\nHELPDSP = 0                               /* default panel display   */\nNumeric digits 20                         /* dflt of 9 not enough    */\nIf R_ADDR = '' | R_ADDR = '?' then do     /* call help routine       */\n  R_ADDR  = 0\n  R_LEN   = 0\n  HELPDSP = 1                             /* help panel display      */\n  Call HELP_DISPLAY\n  Call FINISHED\nEnd                                       /* tokenize strt_addr parm */\n/*********************************************************************/\nSignal On Syntax                          /* error condition         */\nIf R_ADDR = '' then R_ADDR = 0            /* dflt strt_addr 00000000 */\nIf R_LEN  = '' then R_LEN = 100           /* dflt length x'100'      */\nR_ADDR = Translate(R_ADDR,\"\",\"xX'\")       /* remove hex notation     */\nR_ADDR = Space(R_ADDR,0)                  /* rmv blnks in addr string*/\nR_LEN  = Translate(R_LEN ,\"\",\"xX'\")       /* remove hex notation     */\nR_LEN  = Strip(R_LEN)                     /* remove blanks           */\nIf Length(R_ADDR) > 8 then do             /* 64-bit address?         */\n  R_ADDR = Translate(R_ADDR,\"\",\"_\")       /*   remove underscore     */\n  R_ADDR = Space(R_ADDR,0)                /* rmv blnks in addr string*/\nEnd\n/*********************************************************************/\n/* Tokenize the input address string for indirect addressing         */\n/*********************************************************************/\nCall TOKENIZE R_ADDR\nR_ADDR = TOKEN.1\n/*********************************************************************/\nR_ADDR = X2d(R_ADDR)                      /* change to dec for rexx  */\nR_LEN  = X2d(R_LEN)                       /* change to dec for rexx  */\nR_ADDR = RESOLVE_ADDR(R_ADDR)\n/*********************************************************************/\n/* Try and get the storage requested                                 */\n/*********************************************************************/\nD_STOR = Storage(D2x(R_ADDR),R_LEN)             /* get the storage   */\nIf D_STOR = '' then do                          /* none returned?    */\n  Say  'Some storage in specified range is protected - none' ,\n       'can be displayed.'\n  \"Delstack\"                                    /* delete data stack */\n  Exit 12\nEnd\nD_STORX = C2x(D_STOR)\nD_STORL = Length(D_STORX)\n/*********************************************************************/\n/* Routine to format address fro the output display and for the      */\n/* ISPF long help message                                            */\n/*********************************************************************/\nM_ADDR      = D2x(R_ADDR)\nR_ADDR_L    = Length(M_ADDR)\nIf R_ADDR_L > 8 then do\n  M_ADDR1   = Substr(M_ADDR,1,R_ADDR_L-8)\n  M_ADDR1   = Right(M_ADDR1,8,'0')\n  M_ADDR2   = Right(M_ADDR,8)\n  M_ADDR  = M_ADDR1 || '_' || M_ADDR2\nEnd\nElse ,\n  M_ADDR   = Right(M_ADDR,8,'0')\nQueue 'STORAGE(' || M_ADDR || ',' || D2x(R_LEN) || ')'\nQueue ' '\n/*********************************************************************/\n/* Routine to make sure we start the storage display at an address   */\n/* that is on a quadruple word boundry.                              */\n/*********************************************************************/\nIf (R_ADDR/16) <> 0 then do\n  T1    = Trunc(R_ADDR/16)\n  T2    = T1 * 16\n  DIFF_S = R_ADDR - T2\n  D_ADDR = R_ADDR - DIFF_S\n  D_STORX = Copies('40',DIFF_S) || D_STORX       /* add blanks       */\n  D_STORL = Length(D_STORX)\nEnd\nElse D_ADDR = R_ADDR\n/*********************************************************************/\n/* Routine to format storage address and length from above           */\n/*********************************************************************/\nD_OFF    = 0                                     /* relative offset  */\n  Queue 'Address   Offset  0-1-2-3-  4-5-6-7-  8-9-A-B-  C-D-E-F-' ,\n        '   0123456789ABCDEF'\n\nDo I = 1 to D_STORL by 32\n  D_ADDR   = Right(D2x(D_ADDR),8,0)              /* format stg addr  */\n  D_OFF2   = Right('+'|| D2x(D_OFF),6,' ')       /* format offset    */\n  D_STOR_A = Strip(Substr(D_STORX,I,32))         /* remove blanks    */\n  If I > D_STORL - 32 then do                    /* last time only   */\n    DIFF_L   = (31-(D_STORL-I)) / 2  /* figure out how many blanks   */\n    ENDBLNKS = Copies(' ',DIFF_L)    /* to add at end of ebcdic      */\n    D_STOR_E = X2c(D_STOR_A) || ENDBLNKS         /* make EBCDIC      */\n  End\n  Else D_STOR_E = X2c(D_STOR_A)                  /* make EBCDIC      */\n  If I = 1 & R_ADDR <> 0 then                    /* fix hex display  */\n    D_STORX = Overlay(' ',D_STORX,1,DIFF_S*2, ' ') /* for start addr */\n  D_STORX1 = Substr(D_STORX,I,8)                 /* first  word      */\n  D_STORX2 = Substr(D_STORX,I+8,8)               /* second word      */\n  D_STORX3 = Substr(D_STORX,I+16,8)              /* third  word      */\n  D_STORX4 = Substr(D_STORX,I+24,8)              /* forth  word      */\n  If R_ADDR <= 2147483648  then ,                /* 31-bit address   */\n    Queue  D_ADDR '' D_OFF2 '' D_STORX1 '' D_STORX2 '' D_STORX3 ,\n           ''  D_STORX4  ' |' D_STOR_E '|'\n  Else do\n    D_ADDR2 = Overlay('_',D_ADDR,1)              /* 64-bit address   */\n    Queue  D_ADDR2 '' D_OFF2 '' D_STORX1 '' D_STORX2 '' D_STORX3 ,\n           ''  D_STORX4  ' |' D_STOR_E '|'\n  End\n  D_ADDR = X2d(D_ADDR) + 16                      /* bump up addr     */\n  If I = 1 & R_ADDR <> 0 then D_OFF = 16-DIFF_S  /* bump up offset   */\n    Else D_OFF = D_OFF + 16                      /* bump up offset   */\nEnd\nQueue ''  /* NULL Queue TO END STACK   */\n/***************************************************************/\nFINISHED:\nIf Sysvar(SYSISPF) = 'ACTIVE' then call BROWSE_ISPF\nElse do Queued()\n Parse pull line\n Say line\nEnd\nExit 0\n/***************************************************************/\nBROWSE_ISPF:\nQueue ''  /* null queue to end stack   */\nAddress ISPEXEC \"CONTROL ERRORS RETURN\"\nAddress ISPEXEC \"VGET ZENVIR\"\nAddress TSO\nprefix = sysvar('SYSPREF')        /* tso profile prefix            */\nuid    = sysvar('SYSUID')         /* tso userid                    */\nIf prefix = '' then prefix = uid  /* use uid if null prefix        */\nIf prefix <> '' & prefix <> uid then /* different prefix than uid  */\n   prefix = prefix || '.' || uid /* use  prefix.uid                */\nddnm1 = 'DD'||random(1,99999)   /* choose random ddname            */\nddnm2 = 'DD'||random(1,99999)   /* choose random ddname            */\njunk = msg(off)\n\"ALLOC FILE(\"||ddnm1||\") UNIT(SYSALLDA) NEW TRACKS SPACE(9,9) DELETE\",\n      \" REUSE LRECL(80) RECFM(F B) BLKSIZE(3120)\"\n\"ALLOC FILE(\"||ddnm2||\") UNIT(SYSALLDA) NEW TRACKS SPACE(1,1) DELETE\",\n      \" REUSE LRECL(80) RECFM(F B) BLKSIZE(3120) DIR(1)\",\n      \" DA('\"||prefix||\".REXXMEM.\" ||ddnm2|| \".ISPPLIB')\"\njunk = msg(on)\nNewstack\n/*************************/\n/* REXXMEMP Panel source */\n/*************************/\nIf Substr(ZENVIR,6,1) >= 4 then\n  Queue \")PANEL KEYLIST(ISRSPBC,ISR)\"\nQueue \")ATTR\"\nQueue \"  _ TYPE(INPUT)   INTENS(HIGH) COLOR(TURQ) CAPS(OFF)\" ,\n      \"FORMAT(&MIXED)\"\nQueue \"  | AREA(DYNAMIC) EXTEND(ON)   SCROLL(ON)\"\nQueue \"  + TYPE(TEXT)    INTENS(LOW)  COLOR(BLUE)\"\nQueue \"  @ TYPE(TEXT)    INTENS(LOW)  COLOR(TURQ)\"\nQueue \"  % TYPE(TEXT)    INTENS(HIGH) COLOR(GREEN)\"\nQueue \"  ! TYPE(OUTPUT)  INTENS(HIGH) COLOR(TURQ) PAD(-)\"\nQueue \" 01 TYPE(DATAOUT) INTENS(LOW)\"\nQueue \" 02 TYPE(DATAOUT) INTENS(HIGH)\"\nQueue \" 0B TYPE(DATAOUT) INTENS(HIGH) FORMAT(DBCS)\"\nQueue \" 0C TYPE(DATAOUT) INTENS(HIGH) FORMAT(EBCDIC)\"\nQueue \" 0D TYPE(DATAOUT) INTENS(HIGH) FORMAT(&MIXED)\"\nQueue \" 10 TYPE(DATAOUT) INTENS(LOW)  FORMAT(DBCS)\"\nQueue \" 11 TYPE(DATAOUT) INTENS(LOW)  FORMAT(EBCDIC)\"\nQueue \" 12 TYPE(DATAOUT) INTENS(LOW)  FORMAT(&MIXED)\"\nQueue \")BODY EXPAND(//)\"\nQueue \"%BROWSE  @&ZTITLE  / /  %Line!ZLINES  %Col!ZCOLUMS+\"\nQueue \"%Command ===>_ZCMD / /           %Scroll ===>_Z   +\"\nQueue \"|ZDATA ---------------/ /-------------------------|\"\nQueue \"|                     / /                         |\"\nQueue \"| --------------------/-/-------------------------|\"\nQueue \")INIT\"\nQueue \"  .HELP = ISR10000\"\nQueue \"  .ZVARS = 'ZSCBR'\"\nIf HELPDSP = 1 then ,\n  Queue \"  &ZTITLE = 'Mark''s MVS Utilities - REXXMEM  -- HELP --'\"\nElse ,\n  Queue \"  &ZTITLE = 'Mark''s MVS Utilities - REXXMEM'\"\nQueue \"  &MIXED = MIX\"\nQueue \"  IF (&ZPDMIX = N)\"\nQueue \"   &MIXED = EBCDIC\"\nQueue \"  VGET (ZSCBR) PROFILE\"\nQueue \"  IF (&ZSCBR = ' ')\"\nQueue \"   &ZSCBR = 'CSR'\"\nQueue \")REINIT\"\nQueue \"  REFRESH(ZCMD,ZSCBR,ZDATA,ZLINES,ZCOLUMS)\"\nQueue \")PROC\"\nQueue \"  &ZCURSOR = .CURSOR\"\nQueue \"  &ZCSROFF = .CSRPOS\"\nQueue \"  &ZLVLINE = LVLINE(ZDATA)\"\nQueue \"  VPUT (ZSCBR) PROFILE\"\nQueue \")END\"\nQueue \"\"\n/*                                    */\n\"ALLOC FILE(REXXMEMP) SHR REUSE\",\n      \" DA('\"||prefix||\".REXXMEM.\" ||ddnm2|| \".ISPPLIB(REXXMEMP)')\"\n\"EXECIO * DISKW REXXMEMP (FINIS\"\n\"FREE FI(REXXMEMP)\"\nDelstack\n\"EXECIO * DISKW\" ddnm1 \"(FINIS\"\nIf HELPDSP = 1 then zedsmsg = 'Help displayed'\n   Else zedsmsg = 'Storage displayed'\nzedlmsg = 'REXXMEM - Last updated on' ,\n           LASTUPD ||'. Written by' ,\n          'Mark Zelden. Mark''s MVS Utilities -' ,\n          'http://www.mzelden.com/mvsutil.html'\nAddress ISPEXEC \"LIBDEF ISPPLIB LIBRARY ID(\"ddnm2\") STACK\"\nAddress ISPEXEC \"SETMSG MSG(ISRZ000)\"  /* msg - no alarm    */\nAddress ISPEXEC \"LMINIT DATAID(TEMP) DDNAME(\"ddnm1\")\"\nAddress ISPEXEC \"BROWSE DATAID(\"temp\") PANEL(REXXMEMP)\"\nAddress ISPEXEC \"LMFREE DATAID(\"temp\")\"\nAddress ISPEXEC \"LIBDEF ISPPLIB\"\njunk = msg(off)\n\"FREE FI(\"ddnm1\")\"\n\"FREE FI(\"ddnm2\")\"\nExit\n\n\nTOKENIZE: Procedure expose DELIM. TOKEN. R_ADDR\n/*********************************************************************/\n/*   Routine to tokenize the input address                           */\n/*********************************************************************/\nParse upper arg ADDR_STR\nDELIM.1 = '?'\nDELIM.2 = '+'\nDELIM.3 = '-'\nDELIM.4 = '%'\nDELIM.5 = '.'\nDELIM.0 = 5\nREFCNT = 1\nDo while length(ADDR_STR) > 0\n  REF_FND = verify(ADDR_STR,'?+-%.','M')\n  If REF_FND > 0 then do\n    If REF_FND > 1 then do\n      TOKEN.REFCNT = Substr(ADDR_STR,1,REF_FND-1)\n      REFCNT = REFCNT + 1\n    End  /* if REF_FND > 1 ... */\n    TOKEN.REFCNT = Substr(ADDR_STR,REF_FND,1)\n    ADDR_STR = Substr(ADDR_STR,REF_FND+1)\n    REFCNT = REFCNT + 1\n  End          /* if REF_FND > 0 ... */\n  Else do\n    TOKEN.REFCNT = ADDR_STR\n    ADDR_STR = ''\n    REFCNT = REFCNT + 1\n  End\nEnd     /* do while ...*/\nTOKEN.0 = REFCNT - 1\nReturn\n\n\nRESOLVE_ADDR: Procedure expose DELIM TOKEN.\n/*********************************************************************/\n/*   Routine to resolve indirect addressing                          */\n/*********************************************************************/\nADDR = Arg(1)\n/* LINE = ADDR */\nLINE = \"x'\" || D2x(ADDR) || \"'\"\nDo RSLV=2 to TOKEN.0\n  If TOKEN.RSLV = '?' then do\n    RESULT = C2x(Storage(D2x(ADDR),4))\n    ADDR   = X2d(RESULT)\n    LINE = LINE||TOKEN.RSLV\n    Queue LINE \"=\" D2x(ADDR)\n  End\n  If TOKEN.RSLV = '%' then do\n    RESULT = C2x(Storage(D2x(ADDR),4))\n    RESULT = Substr(RESULT,3,6)  /* 24-bit pointer */\n    ADDR   = X2d(RESULT)\n    LINE = LINE||TOKEN.RSLV\n    Queue LINE \"=\" D2x(ADDR)\n  End\n  If TOKEN.RSLV = '+' then do\n    RSLV = RSLV + 1\n    ADDR = ADDR + X2d(TOKEN.RSLV)\n    LINE = LINE||\"+x'\"TOKEN.RSLV\"'\"\n    Queue LINE \"=\" D2x(ADDR)\n  End\n  If TOKEN.RSLV = '-' then do\n    RSLV = RSLV + 1\n    ADDR = ADDR - X2d(TOKEN.RSLV)\n    LINE = LINE||\"-x'\"TOKEN.RSLV\"'\"\n    Queue LINE \"=\" D2x(ADDR)\n  End\n  If TOKEN.RSLV = '.' then do\n /* LINE = LINE||\"\"TOKEN.RSLV           */\n /* Queue LINE \"=\" D2x(ADDR)            */\n  End\nEnd\nIf TOKEN.0 > 1 then do\n  /* Improve readability - add lines before storage display if       */\n  /* indirect storage references are used.                           */\n  Queue '---------------------------------------------------' || ,\n        '---------------------------'\n  Queue ' '\nEnd\nReturn ADDR\n\n\n/*********************************/\n/*  HELP SUB-ROUTINES            */\n/*********************************/\nHELP_INCL:\nReturn SIGL\nHELP_DISPLAY:\nQueue '==================='\nQueue '===   H E L P   ==='\nQueue '==================='\nDo hlp = help_start+1 to help_end-1 by 1\n  hline = Sourceline(hlp)\n  Queue hline\nEnd\nReturn\n\n\nSYNTAX:\nSay ERRORTEXT(rc)                              /* return code        */\nSay 'Please verify input parameters for valid hex characters' ,\n    'and proper indirect storage addressing.'\n\"Delstack\"                                     /* delete data stack  */\nExit 12\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXXSCAN": {"ttr": 14342, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Q\\x01\\x01\\x15\\x1f\\x01\\x03\\x00\\x8f\\x13W\\x00j\\x00j\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf5\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-05-31T00:00:00", "modifydate": "2003-01-08T13:57:51", "lines": 106, "newlines": 106, "modlines": 0, "user": "CBT456"}, "text": "/* REXX */\n/*                                       */\n/* AUTHOR: Mark Zelden                   */\n/* Last Updated 01/08/2003               */\n/*                                       */\n/*********************************************************************/\n/*                                                                   */\n/* SCAN INPUT FILE FOR PARM STRING(S)                                */\n/*                                                                   */\n/*  EXEC  ARGS:                                                      */\n/*  SEARCH1 = FIRST SCAN ARG                                         */\n/*  SEARCH2 = SECOND SCAN ARG (OPTIONAL)                             */\n/*  TYPE    = \"AND\"  OR  \"OR\" (OPTIONAL)                             */\n/*                                                                   */\n/*  IF A SECOND SCAN ARG IS USED THEN \"TYPE\" IS USED TO              */\n/*  DETERMINE IF \"BOTH\" ARGS MUST BE FOUND OR \"EITHER\" ARG           */\n/*  MUST BE FOUND. ** THE DEFAULT IS \"OR\" **                         */\n/*                                                                   */\n/* INPUT DDNAME  - SCANIN                                            */\n/* OUTPUT DDNAME - SCANOUT                                           */\n/*                                                                   */\n/*********************************************************************/\n/* Sample batch execution JCL:                                       */\n/*                                                                   */\n/*  //MYJOB    JOB (ACCT),CLASS=A,MSGCLASS=H                         */\n/*  //SCAN  EXEC PGM=IRXJCL,PARM='REXXSCAN IOS000I'                  */\n/*  //*SCAN  EXEC PGM=IRXJCL,PARM='REXXSCAN IOS000I 560 AND'       */*/\n/*  //SYSTSIN  DD DUMMY                                              */\n/*  //SYSTSPRT DD SYSOUT=*                                           */\n/*  //SYSEXEC  DD DSN=your.rexxscan.sysexec.lib,DISP=SHR             */\n/*  //SCANOUT  DD SYSOUT=*                                           */\n/*  //SCANIN   DD DISP=SHR,DSN=dataset.to.scan                       */\n/*                                                                   */\n/*********************************************************************/\nparse arg search1 search2 type     /* do not translate to upper case */\nif search1 = '' then do\n  say '                               '\n  say ' ******************************'\n  say ' *  NO SCAN PARM(S) SUPPLIED  *'\n  say ' ******************************'\n  say '                               '\n  exit 12\nend\nif type <> '' then do\n  upper type\n  if type <> 'AND' & type <> 'OR' then do\n    say '                               '\n    say ' ******************************'\n    say ' *    COMPARE TYPE MUST BE    *'\n    say ' *      \"AND\"  OR  \"OR\"       *'\n    say ' ******************************'\n    say '                               '\n    exit 12\n  end\nend\nfound   = 0\ntotrecs = 0\ndo forever\n  \"EXECIO 10000 DISKR SCANIN (STEM INREC.\"\n  if RC > 2 | inrec.0 == 0 then leave  /* rc = 2 for partial read */\n  do I = 1 to inrec.0\n    if search2 = '' then do\n      if pos(search1,inrec.i) <> 0 then do\n        queue inrec.i\n      end\n    end\n    else do\n      if type = 'AND' then do\n        if pos(search1,inrec.i) <> 0  &,\n           pos(search2,inrec.i) <> 0  then do\n          queue inrec.i\n        end\n      end\n      else do\n        if pos(search1,inrec.i) <> 0  |,\n           pos(search2,inrec.i) <> 0  then do\n          queue inrec.i\n        end\n      end  /* else do */\n    end /* else do */\n  end  /* do I = 1 to inrec.0 */\n  new = queued()  /* how many new records found */\n  \"EXECIO\" new \"DISKW SCANOUT\"\n  found   = found + new\n  totrecs = totrecs + inrec.0\nend  /* do forever */\n/*                                     */\n/* close files, write totals and exit  */\n/*                                     */\n\"EXECIO 0 DISKR SCANIN  (FINIS\"\n\"EXECIO 0 DISKW SCANOUT (FINIS\"\n/*                                     */\ntotrecs = Right(totrecs,7,'0')\nfound   = Right(found,7,'0')\nsay  totrecs' RECORDS WERE READ FROM THE INPUT FILE.'\nif search2 = '' then\n  say  found' RECORDS WERE FOUND WITH \"'||search1||'\".'\nelse\n  if type <> 'AND' then\n    say  found' RECORDS WERE FOUND WITH \"'||search1||'\" OR',\n                                       '\"'||search2||'\".'\n  else\n    say  found' RECORDS WERE FOUND WITH \"'||search1||'\" AND',\n                                       '\"'||search2||'\".'\nif found = 0 then exit 4\n  else exit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXXSTOJ": {"ttr": 14345, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x04\\x02\\x0f\\x01\\x050_\\x130\\x00,\\x00\\x19\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-01-20T00:00:00", "modifydate": "2005-11-01T13:30:00", "lines": 44, "newlines": 25, "modlines": 0, "user": "CBT470"}, "text": "//USZCZT0T JOB (AD00),'#04B42 ZELDEN',\n//             NOTIFY=&SYSUID,\n//             CLASS=M,MSGCLASS=H,MSGLEVEL=(1,1)\n//*\n//TEST PROC\n//S1  EXEC PGM=IRXJCL,PARM='REXXSTOR'\n//SYSTSIN  DD DUMMY\n//SYSTSPRT DD SYSOUT=*\n//SYSEXEC  DD DSN=MPSYS3.USZCZT0.CNTL,DISP=SHR\n// PEND\n//J1 EXEC TEST   /* DEFAULT REGION SIZE ABOVE & BELOW -       */\n//*              /* JES2 DEFAULT REGION SIZE FROM JOBCLASS(N) */\n//*              /* IS USED FOR REGION SIZE IF NOT OVERRIDEN  */\n//*              /* BY INSTALLATION EXIT                      */\n//J2  EXEC TEST,REGION.S1=4M    /* REQ BELOW / ABOVE TEST #1  */\n//J3  EXEC TEST,REGION.S1=8M    /* REQ BELOW / ABOVE TEST #2  */\n//J4  EXEC TEST,REGION.S1=20M   /* MAX BELOW / ABOVE TEST #1  */\n//J5  EXEC TEST,REGION.S1=40M   /* MAX BELOW / ABOVE TEST #2  */\n//J6  EXEC TEST,REGION.S1=80M   /* MAX BELOW / ABOVE TEST #3  */\n//J7  EXEC TEST,REGION.S1=100M  /* MAX BELOW / ABOVE TEST #4  */\n//J8  EXEC TEST,REGION.S1=200M  /* MAX BELOW / ABOVE TEST #5  */\n//J9  EXEC TEST,REGION.S1=500M  /* MAX BELOW / ABOVE TEST #6  */\n//J10 EXEC TEST,REGION.S1=900M  /* MAX BELOW / ABOVE TEST #7  */\n//J11 EXEC TEST,REGION.S1=1024M /* MAX BELOW / ABOVE TEST #8  */\n//J12 EXEC TEST,REGION.S1=1200M /* MAX BELOW / ABOVE TEST #9  */\n//J13 EXEC TEST,REGION.S1=1400M /* MAX BELOW / ABOVE TEST #10 */\n//J14 EXEC TEST,REGION.S1=0M    /* REGION = 0M TEST           */\n//J15 EXEC TEST,MEMLIMIT.S1=0M          /* MEMLIMIT TEST #1   */\n//J16 EXEC TEST,MEMLIMIT.S1=2047M       /* MEMLIMIT TEST #2   */\n//J17 EXEC TEST,MEMLIMIT.S1=2049M       /* MEMLIMIT TEST #3   */\n//J18 EXEC TEST,MEMLIMIT.S1=2048M       /* MEMLIMIT TEST #4   */\n//J19 EXEC TEST,MEMLIMIT.S1=2G          /* MEMLIMIT TEST #5   */\n//J20 EXEC TEST,MEMLIMIT.S1=4096G       /* MEMLIMIT TEST #6   */\n//J21 EXEC TEST,MEMLIMIT.S1=4T          /* MEMLIMIT TEST #7   */\n//J22 EXEC TEST,MEMLIMIT.S1=100T        /* MEMLIMIT TEST #8   */\n//J23 EXEC TEST,MEMLIMIT.S1=100P        /* MEMLIMIT TEST #9   */\n//J24 EXEC TEST,MEMLIMIT.S1=16383P      /* MEMLIMIT TEST #10  */\n//J25 EXEC TEST,MEMLIMIT.S1=16384P      /* MEMLIMIT TEST #11  */\n//J26 EXEC TEST,MEMLIMIT.S1=NOLIMIT     /* MEMLIMIT TEST #12  */\n//J27 EXEC TEST,REGION.S1=2000M /* IMPOSSIBLE RGN ABOVE TEST  */\n//J28 EXEC TEST,REGION.S1=15M   /* IMPOSSIBLE RGN BELOW TEST  */\n//*                             /* THIS SHOULD GET AN 822     */\n//*                             /* ABEND IF IEFUSI DOESN'T    */\n//*                             /* CHANGE THE VALUE.          */\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REXXSTOR": {"ttr": 14347, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x05\\x9f\\x01\\x16$\\x0f\\x14U\\x00\\xa4\\x00\\x1d\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf9\\xf2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-02-28T00:00:00", "modifydate": "2016-08-27T14:55:00", "lines": 164, "newlines": 29, "modlines": 0, "user": "CBT492"}, "text": "/* REXX                                  */\n/*                                       */\n/* AUTHOR: Mark Zelden                   */\n/* Last Updated 08/27/2016               */\n/*********************************************************************/\n/* This exec will show the virtual storage usage of the task that    */\n/* invokes the REXX exec.  This could be an interactive TSO user, a  */\n/* batch TSO step, or even a Unix System Services user / Web server. */\n/* For z/OS 1.2 and above running in z/Architecture mode, it will    */\n/* also display the MEMLIMIT and the MEMLIMIT source.                */\n/*********************************************************************/\n/* SEE OA14391 for an explanation of MEMSRC.10                       */\n/*********************************************************************/\nNumeric digits 14                            /* dflt of 9 not enough!*/\nASCB     = C2d(Storage(224,4))               /* current ASCB         */\nLDA      = C2d(Storage(D2x(ASCB + 48),4))    /* local data area      */\nLDASIZA  = C2d(storage(D2x(LDA + 64),4))     /* <16m max priv size   */\nLDASIZA  = Right(LDASIZA/1024,9)             /* convert to kbytes    */\nLDAESIZA = C2d(storage(D2x(LDA + 80),4))     /* >16m max priv size   */\nLDAESIZA = Right(LDAESIZA/1024,9)            /* convert to kbytes    */\nLDAREGRQ = C2d(storage(D2x(LDA + 204),4))    /* region requested     */\nLDAREGRQ = LDAREGRQ/1024                     /* convert to kbytes    */\nLDALIMIT = C2d(storage(D2x(LDA + 208),4))    /* <16m reg limit       */\nLDALIMIT = Right(LDALIMIT/1024,9)            /* convert to kbytes    */\nLDAVVRG  = C2d(storage(D2x(LDA + 212),4))    /* <16m reg size        */\nLDAVVRG  = Right(LDAVVRG/1024,9)             /* convert to kbytes    */\nLDAELIM  = C2d(storage(D2x(LDA + 216),4))    /* >16m reg limit       */\nLDAELIM  = Right(LDAELIM/1024,9)             /* convert to kbytes    */\nLDAEVVRG = C2d(storage(D2x(LDA + 220),4))    /* >16m reg size        */\nLDAEVVRG = Right(LDAEVVRG/1024,9)            /* convert to kbytes    */\nLDALOAL  = C2d(storage(D2x(LDA + 232),4))    /* <16m reg alloc       */\nLDALOAL  = Right(LDALOAL/1024,9)             /* convert to kbytes    */\nLDAHIAL  = C2d(storage(D2x(LDA + 236),4))    /* <16m lsqa alloc      */\nLDAHIAL  = Right(LDAHIAL/1024,9)             /* convert to kbytes    */\nLDAELOAL = C2d(storage(D2x(LDA + 240),4))    /* >16m reg alloc       */\nLDAELOAL = Right(LDAELOAL/1024,9)            /* convert to kbytes    */\nLDAEHIAL = C2d(storage(D2x(LDA + 244),4))    /* >16m lsqa alloc      */\nLDAEHIAL = Right(LDAEHIAL/1024,9)            /* convert to kbytes    */\n /* AVAIL    = Right(LDALIMIT-LDALOAL,9) */  /* available <16M       */\n /* EAVAIL   = Right(LDAELIM-LDAELOAL,9) */  /* available >16M       */\nAVAIL    = Min(LDAVVRG,LDASIZA-LDAHIAL) - LDALOAL      /* avail <16M */\nAVAIL    = Right(AVAIL,9)                              /* format     */\nEAVAIL   = Min(LDAEVVRG,LDAESIZA-LDAEHIAL) - LDAELOAL  /* avail >16M */\nEAVAIL   = Right(EAVAIL,9)                             /* format     */\n/*********************************************************************/\n/* MEMLIMIT code                                                     */\n/*********************************************************************/\nShow_MEMLIMIT_Display = 0    /* Init flag to \"false\" - used later    */\nCVT      = C2d(Storage(10,4))                /* point to CVT         */\nCVTOSLV3 = Storage(D2x(CVT+1267),1)          /* byte 3 of CVTOSLVL   */\nFLCARCH  = Storage(A3,1)                     /* FLCARCH in PSA       */\nIf bitand(CVTOSLV3,'10'x) = '10'x & ,        /* z/OS 1.2 64-bit srvs */\n   C2d(FLCARCH) <> 0 then do                 /* non-zero is z/Arch.  */\n  Show_MEMLIMIT_Display = 1                  /* Set FLAG to \"true\"   */\n  RAX      = C2d(Storage(D2X(ASCB+364),4))   /* point to RAX         */\n  RAXLVMEMLIM = C2d(Storage(D2x(RAX+152),8)) /* MEMLIMIT in MB       */\n  MEMLIM=FORMAT_MEMSIZE(RAXLVMEMLIM)         /* Format MEMLIMIT size */\n  RAXLVMEMLIMS= C2d(Storage(D2x(RAX+184),1)) /* MEMLIMIT Source      */\nEnd /* If bitand(CVTOSLV3,'10'x) */\n/* Memlimit Source Table */\nMEMSRC.0  = ' '\nMEMSRC.1  = 'SMF'\nMEMSRC.2  = 'JCL'\nMEMSRC.3  = 'REGION=0'\nMEMSRC.4  = 'IEFUSI'\nMEMSRC.5  = 'OMVS SEGMENT'\nMEMSRC.6  = 'UNIX SETRLIMIT'\nMEMSRC.7  = 'UNIX SPAWN'\nMEMSRC.8  = 'SETOMVS CMD'\nMEMSRC.9  = 'AUTH PROGRAM'\nMEMSRC.10 = 'IEFUSI + REGION=0'\n/*********************************************************************/\n/* Display results                                                   */\n/*********************************************************************/\nSay ''\nSay '                       V I R T U A L    S T O R A G E' || ,\n    '    U S A G E'\nSay '                       ------------------------------' || ,\n    '-------------'\nSay ' '\nSay ' '\nSay '                             Region requested:' LDAREGRQ'K'\nSay ' '\nSay '             Max Priv     Region     Region     Region' || ,\n    '       LSQA     Region'\nSay '             Reg Size      Limit       Size     In-Use' || ,\n    '     In-Use      Avail'\nSay '             --------   --------   --------   --------' || ,\n    '   --------   --------'\nSay 'Below 16M:' LDASIZA'K'  LDALIMIT'K'  LDAVVRG'K' ,\n       LDALOAL'K' LDAHIAL'K' AVAIL'K'\nSay 'Above 16M:' LDAESIZA'K' LDAELIM'K'   LDAEVVRG'K' ,\n       LDAELOAL'K' LDAEHIAL'K' EAVAIL'K'\nIf Show_MEMLIMIT_Display = 1 then do         /* FLAG set to \"true\"?  */\n  Say ' '\n  Say 'Above 2G :' Right(MEMLIM,10) ,\n      '    (64-bit MEMLIMIT)'\n  Say 'MEMLIMIT Source: ' MEMSRC.RAXLVMEMLIMS\nEnd\nExit 0\n\nFORMAT_MEMSIZE:\n/****************************************************************/\n/* The following code is used to display the storage size in    */\n/* the largest possible unit.  For example, 1023G and 1025G are */\n/* displayed as 1023G and 1025G, but 1024G is displayed as 1T.  */\n/* The size passed to the routine must be in MB.                */\n/****************************************************************/\nArg SIZE_IN_MB\nSelect\n   When SIZE_IN_MB < 1024 then do\n     MUNITS = 'M'\n   End\n   When SIZE_IN_MB >= 1024 & SIZE_IN_MB < 1048576 then do\n     If SIZE_IN_MB/1024 == TRUNC(SIZE_IN_MB/1024) then do\n       SIZE_IN_MB = SIZE_IN_MB/1024\n       MUNITS = 'G'\n     End\n     Else MUNITS = 'M'\n   End\n   When SIZE_IN_MB >= 1048576 & SIZE_IN_MB < 1073741824 then do\n     If SIZE_IN_MB/1048576 == TRUNC(SIZE_IN_MB/1048576) then do\n       SIZE_IN_MB = SIZE_IN_MB/1048576\n       MUNITS = 'T'\n     End\n     Else do\n       If SIZE_IN_MB/1024 == TRUNC(SIZE_IN_MB/1024) then do\n         SIZE_IN_MB = SIZE_IN_MB/1024\n         MUNITS = 'G'\n       End\n       Else MUNITS = 'M'\n     End\n   End\n   When SIZE_IN_MB >= 1073741824 & ,\n        SIZE_IN_MB <= 17591112302592 then do\n     If SIZE_IN_MB/1073741824 == TRUNC(SIZE_IN_MB/1073741824) ,\n        then do\n       SIZE_IN_MB = SIZE_IN_MB/1073741824\n       MUNITS = 'P'\n     End\n     Else do\n       SIZE_IN_MB = SIZE_IN_MB/1048576\n       MUNITS = 'T'\n     End\n   End\n   When SIZE_IN_MB = 17592186040320 then do\n       SIZE_IN_MB = 'NOLIMIT'   /* 16384P */\n       MUNITS = ''\n   End\n   When SIZE_IN_MB > 17592186040320 then do\n       SIZE_IN_MB = '*NOLIMT'   /* >16384P  (16EB) ?? */\n       MUNITS = ''\n   End\n   Otherwise do\n     Say ' '\n     Say 'Error in FORMAT_MEMSIZE code. Contact Mark Zelden.'\n     Say 'SIZE_IN_MB=' SIZE_IN_MB\n     Say ' '\n     SIZE_IN_MB = '*ERROR*'\n     MUNITS = ''\n   End\nEnd /* select */\nSTOR_SIZE =  SIZE_IN_MB || MUNITS\nReturn STOR_SIZE\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXINTRO": {"ttr": 14593, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00!\\x01\\x01\\x03?\\x01\\x01\\x03?\\x14\\x10\\x02I\\x02I\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf3\\xf3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-02-02T00:00:00", "modifydate": "2001-02-02T14:10:21", "lines": 585, "newlines": 585, "modlines": 0, "user": "CBT433"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "RXSMF30": {"ttr": 14849, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x17\\x11\\x9f\\x01\\x17\\x11\\x9f\\x11\\x10\\x00\\xfd\\x00\\xfd\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf9\\xf5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-04-29T00:00:00", "modifydate": "2017-04-29T11:10:00", "lines": 253, "newlines": 253, "modlines": 0, "user": "CBT495"}, "text": "/* REXX */\n/*                                       */\n/* AUTHOR: Mark Zelden    November 1995  */\n/*                                       */\n/* Trace ?r */\n/*************************************************************/\n/* Since REXX can not read spanned records, the SMF file     */\n/* needs to be re-formatted from RECFM=VBS to RECFM=VB       */\n/* using the following sample JCL. The extract step is       */\n/* optional but can be used to limit the amount of data      */\n/* passed to the REXX program.                               */\n/*                                                           */\n/*                                                           */\n/*   //MYJOB  JOB (ACCT),CLASS=M,MSGCLASS=H                  */\n/*   //EXT30   EXEC PGM=IFASMFDP                             */\n/*   //SYSPRINT DD  SYSOUT=*                                 */\n/*   //DUMPIN   DD  DISP=SHR,DSN=TECH.SYSA.SMFDAILY(-0)      */\n/*   //*DUMPIN   DD  DISP=SHR,DSN=SYS1.MAN1                */*/\n/*   //DUMPOUT  DD  UNIT=SYSDA,                              */\n/*   //             SPACE=(CYL,(30,30),RLSE),                */\n/*   //             DISP=(,PASS,DELETE),                     */\n/*   //             DSN=&&SMF30                              */\n/*   //SYSIN    DD  *                                        */\n/*   INDD(DUMPIN,OPTIONS(DUMP))                              */\n/*   OUTDD(DUMPOUT,TYPE(30))                                 */\n/*   /*                                                    */*/\n/*   //REBLK  EXEC  PGM=IDCAMS                               */\n/*   //SYSPRINT DD  SYSOUT=*                                 */\n/*   //SYSUDUMP DD  SYSOUT=*                                 */\n/*   //IN       DD  DSN=&&SMF30,DISP=(OLD,DELETE)            */\n/*   //OUT      DD  DSN=hlq.RXSMF30.INPUT,DISP=(,CATLG),     */\n/*   //             UNIT=SYSALLDA,SPACE=(CYL,(15,15),RLSE),  */\n/*   //             DCB=(RECFM=VB,BLKSIZE=32760)             */\n/*   //SYSIN    DD  *                                        */\n/*     REPRO INFILE(IN) OUTFILE(OUT)                         */\n/*   /*                                                    */*/\n/*   //                                                      */\n/*************************************************************/\n/* SAMPLE EXECUTION JCL:                                     */\n/*                                                           */\n/*   //MYJOB  JOB (ACCT),CLASS=M,MSGCLASS=H                  */\n/*   //JS010  EXEC  PGM=IRXJCL,PARM='RXSMF30'                */\n/*   //SYSTSIN  DD  DUMMY                                    */\n/*   //SYSTSPRT DD  SYSOUT=*                                 */\n/*   //SYSEXEC  DD  DSN=REXX.EXEC.LIBRARY,DISP=SHR           */\n/*   //SMF      DD  DSN=hlq.RXSMF30.INPUT,DISP=SHR           */\n/*   //RPT      DD  SYSOUT=*,                                */\n/*   //             DCB=(LRECL=133,BLKSIZE=3990,RECFM=FBA)   */\n/*************************************************************/\n/*  Initialize counters and run date.                        */\n/*************************************************************/\nRECNUM = 1            /* current record number    */\nPAGENUM = '  1'       /* page number count        */\nMAXLINES= 55          /* max lines per page       */\nTOTAL   = 0           /* count of o/p records     */\nTOTSCRM = 0           /* tot scr tape mnts        */\nTOTIPM  = 0           /* tot input tape mnts      */\nTOTMNTS = 0           /* total tape mounts        */\nDATEA   = Date('W')               /* day of week  */\nDATEB   = Date('M')               /* month        */\nDATEC   = Substr(Date('N'),1,2)   /* day of month */\nDATED   = Substr(Date('N'),8,4)   /* year         */\nDATERUN = DATEA', 'DATEB' 'DATEC', 'DATED\nUpper DATERUN\n/*************************************************************/\n/* Begin reading smf file                                    */\n/*************************************************************/\ndo forever\n  \"EXECIO 1 DISKR SMF\" RECNUM\n  if RECNUM = 1 then\n    if rc <> 0 then exit 12   /* SMF not allocated or i/o error */\n  if rc <> 0 then leave  /* no more records - exit */\n  RECNUM = RECNUM + 1\n  parse pull INREC\n/*********************************************************************/\n  RECTYPE = Substr(INREC,2,1)        /* smf record type              */\n  if C2d(RECTYPE) <> 30 then iterate /* chk for type(30)             */\n  SUBTYPE = Substr(INREC,19,2)       /* smf record subtype           */\n  if C2d(SUBTYPE) <> 4  then iterate /* chk for subtype(4)           */\n  IDENTOFF = Substr(INREC,29,4)      /* offset to identification sect*/\n  IDENTOFF = C2d(IDENTOFF) - 3       /* cvrt to dec & adj for rdw    */\n  COMPOFF  = Substr(INREC,45,4)      /* offset to completion section */\n  COMPOFF  = C2d(COMPOFF) - 3        /* cvrt to dec & adj for rdw    */\n  ETIME    = Substr(INREC,3,4)           /* run time in hex          */\n  ETIME    = C2d(ETIME)                  /* convert to decimal       */\n  ETIME    = Left(ETIME,5)               /* seconds since midnight   */\n  HOURS    = Trunc(ETIME/3600)           /* hours since midnight     */\n  HOURS    = Right(HOURS,2,'0')          /* ensure 2 digit hour      */\n  SECTOT   = Trunc(ETIME-(HOURS*3600))  /* seconds since midnight   */\n  MINS     = Trunc(SECTOT/60)            /* minutes past the hour    */\n  MINS     = Right(MINS,2,'0')           /* ensure 2 digit minutes   */\n  SECS     = SECTOT-(MINS*60)            /* seconds past the minute  */\n  SECS     = Right(SECS,2,'0')           /* ensure 2 digit seconds   */\n  TIME     = HOURS||':'||MINS||':'||SECS /* time in HH:MM:SS format  */\n  EDATE    = Substr(INREC,7,4)           /* run date in packed dec   */\n  EDATE    = C2x(EDATE)                  /* convert to character     */\n  EDATE    = Left(EDATE,7)               /* chop off packed sign \"F\" */\n  EDATE    = Right(EDATE,5)              /* chop off leading zeros   */\n  JOBNAME  = Substr(INREC,IDENTOFF,8)    /* jobname                  */\n  PROGNAME = Substr(INREC,IDENTOFF+8,8)  /* program name             */\n  STEPNAME = Substr(INREC,IDENTOFF+16,8) /* step name                */\n  JESID    = Substr(INREC,IDENTOFF+32,8) /* JES job identifier       */\n/*IF JESIDSV = JESID then JOBNAME = ''*/ /* same as last job?        */\n/*   Else JESIDSV = JESID             */ /* no, don't clear jobname  */\n  CLS      = Substr(INREC,IDENTOFF+42,1) /* job class (jobs only)    */\n  STEPIND  = Substr(INREC,COMPOFF+2,1)   /* step term indicator      */\n  CHKIND7  = C2d(Bitand(STEPIND,'01'x))  /* chk for x '01' (bit 7)   */\n  if CHKIND7 >= 1 then RTCD = 'FLUSH'    /* bit on - step flushed    */\n  else do                                /* bit off -step not flushed*/\n    CHKIND6  = C2d(Bitand(STEPIND,'02'x)) /* check for x'02' (bit 6) */\n    if CHKIND6 >= 2 then do             /* bit on - step abended     */\n      CODEIND  = Substr(INREC,COMPOFF,1) /* code indicator           */\n      CHKCODE1 = C2d(Bitand(CODEIND,'80'x)) /* check high order bit  */\n      if CHKCODE1 >= 128 then do            /* bit on - user abend   */\n        RTCD = Substr(INREC,COMPOFF,2)      /* user abend code       */\n        RTCD = C2d(RTCD) -32768             /* convert to decimal    */\n        RTCD = Right(RTCD,4,'0')            /* pad with zeros        */\n        RTCD = 'U'||RTCD                    /* abend is UNNNN        */\n      end\n      else do\n        RTCD = Substr(INREC,COMPOFF,2)      /* system abend code     */\n        RTCD = C2x(RTCD)                    /* convert to character  */\n        RTCD = Right(RTCD,3,'0')            /* pad with zeros        */\n        RTCD = 'S'||RTCD                    /* abend is SNNN         */\n      end\n    end\n    else do                        /* bit off - normal end of step   */\n      RTCD   = Substr(INREC,COMPOFF,2) /* step completion code       */\n      RTCD   = C2d(RTCD)             /* convert to decimal           */\n      if RTCD >9999 then nop\n      else\n        RTCD   = Right(RTCD,4,'0')   /* pad with zeros - RC = NNNN   */\n    end\n  end\n/*******************************************************************/\n/* Start of filter records section                                 */\n/*******************************************************************/\n /*                                                                */\n /* Add code here to select or exclude records based on SID,       */\n /* JESID, JOBNAME, STEPNAME, PROGNAME, CLS or RTCD.               */\n /*                                                                */\n /* EXAMPLES:                                                      */\n /*                                                                */\n /* if PROGNAME <> 'SORT' then iterate                             */\n /* if RTCD = '0000' | RTCD = 'FLUSH' then iterate                 */\n /* if RTCD <> 'S0C1' & RTCD <> 'U0020' then iterate               */\n /* if JOBNAME <> 'OPSMFDMP' | PROGNAME <>'SMFDUMP' then iterate   */\n /*                                                                */\n/*******************************************************************/\n/* End of filter records section                                   */\n/*******************************************************************/\n  NUMOPR   = Substr(INREC,91,2)      /* number of operator sections  */\n  NUMOPR   = C2d(NUMOPR)             /* cvrt to dec                  */\n  If NUMOPR <> 0 then do\n    OPROFF   = Substr(INREC,85,4)    /* offset to operator section   */\n    OPROFF   = C2d(OPROFF)  - 3      /* cvrt to dec & adj for rdw    */\n    NTAPMNTS = Substr(INREC,OPROFF+8,4)  /* non-specific tape mnts   */\n    NTAPMNTS = C2d(NTAPMNTS)         /* make printable               */\n    TOTSCRM  = TOTSCRM + NTAPMNTS    /* add number to total          */\n    STAPMNTS = Substr(INREC,OPROFF+12,4) /* specific tape mnts       */\n    STAPMNTS = C2d(STAPMNTS)         /* make printable               */\n    TOTIPM   = TOTIPM + STAPMNTS     /* add number to total          */\n  End\n  if TOTAL = 0 then call PUT_HEADING /* write page heading */\n  if LINECNT = MAXLINES then call PUT_HEADING\n  call PUT_REC                       /* write output record */\nend  /* Do forever */\n/******************************************/\n/* Done with processing - write totals    */\n/******************************************/\nRECNUM  = Right(RECNUM-1,7,'0')\nTOTAL   = Right(TOTAL,7,'0')\nTOTSCRM = Right(TOTSCRM,7,'0')\nTOTIPM  = Right(TOTIPM,7,'0')\nTOTMNTS = Right(TOTSCRM+TOTIPM,7,'0')\nHEAD1   = '1'DATERUN||'             '||COMPANY||'                 ',\n          '   PAGE 'PAGENUM\nHEAD2   = '0                                      ',\n          '           SMF JOB ACCOUNTING REPORT - TOTALS'\nTOT1  = '      '\nTOT2  = ' 'RECNUM' RECORDS WERE READ'\nTOT3  = ' 'TOTAL' RECORDS WERE SELECTED FOR OUTPUT'\nTOT4  = ' '\nTOT5  = ' 'TOTSCRM' SCRATCH TAPE MOUNTS'\nTOT6  = ' 'TOTIPM' INPUT TAPE MOUNTS'\nTOT7  = ' 'TOTMNTS' TOTAL TAPE MOUNTS'\nqueue HEAD1\nqueue HEAD2\nqueue TOT1\nqueue TOT1\nqueue TOT1\nqueue TOT2\nqueue TOT3\nqueue TOT4\nqueue TOT5\nqueue TOT6\nqueue TOT7\n\"EXECIO * DISKW RPT\"\n/******************************************/\n/* close files and exit                   */\n/******************************************/\nqueue ''\n\"EXECIO * DISKW RPT (FINIS\"\n\"EXECIO 0 DISKR SMF (FINIS\"\nExit 0\n/******************************************/\n/* page heading sub-routine               */\n/******************************************/\nPUT_HEADING:\nCOMPANY = 'M A R K    Z E L D E N    A B C    C O M P A N Y,   I N C.'\nHEAD1   = '1'DATERUN||'             '||COMPANY||'                 ',\n          '   PAGE 'PAGENUM\nHEAD2   = '0                                      ',\n          '              SMF JOB ACCOUNTING REPORT'\nHEAD3   = '0             ',\n          '   JOB        STEP     PROGRAM      JES      JOB',\n          '  COMP    SYS    END       END     SCR  I/P'\nHEAD4   = '              ',\n          '   NAME       NAME      NAME       IDENT     CLS',\n          '  CODE    ID     DATE      TIME    MNT  MNT'\nHEAD5   = '                               '\nqueue HEAD1\nqueue HEAD2\nqueue HEAD3\nqueue HEAD4\nqueue HEAD5\n\"EXECIO * DISKW RPT\"\nLINECNT = 7  /* The \"0\" ANSI chars above - skip a line, counts as 2 */\nPAGENUM = PAGENUM + 1\nPAGENUM = Right(PAGENUM,3,' ')\nreturn\n/******************************************/\n/* write output record sub-routine        */\n/******************************************/\nPUT_REC:\nSID    = Substr(INREC,11,4)\nOUTREC  = ''\nOUTREC  = Overlay(JOBNAME,OUTREC,17)\nOUTREC  = Overlay(STEPNAME,OUTREC,28)\nOUTREC  = Overlay(PROGNAME,OUTREC,39)\nOUTREC  = Overlay(JESID,OUTREC,50)\nOUTREC  = Overlay(CLS,OUTREC,62)\nOUTREC  = Overlay(RTCD,OUTREC,67)\nOUTREC  = Overlay(SID,OUTREC,75)\nOUTREC  = Overlay(EDATE,OUTREC,82)\nOUTREC  = Overlay(TIME,OUTREC,90)\nOUTREC  = Overlay(NTAPMNTS,OUTREC,101)\nOUTREC  = Overlay(STAPMNTS,OUTREC,106)\nqueue OUTREC\n\"EXECIO * DISKW RPT\"\nTOTAL   = TOTAL + 1\nLINECNT = LINECNT + 1\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXSTOR64": {"ttr": 14854, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x050_\\x01\\x16$\\x0f\\x14U\\x03A\\x00m\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf9\\xf2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-11-01T00:00:00", "modifydate": "2016-08-27T14:55:00", "lines": 833, "newlines": 109, "modlines": 0, "user": "CBT492"}, "text": "/* REXX */\n/*                        */\n/* AUTHOR: Mark Zelden    */\n/*                        */\n/* Trace ?r */\n/*********************************************************************/\n/* This exec will show the MEMLIMIT and 64-bit storage allocation    */\n/* for all tasks running in the system.  The allocation numbers      */\n/* come from the RSM Address Space Block Extension (RAX).            */\n/*                                                                   */\n/* For z/OS 1.5 and above, 64-bit shared memory allocations are      */\n/* included as well as system wide 64-bit shared memory usage.       */\n/*                                                                   */\n/* For z/OS 1.9 and above, 64-bit large memory allocations are       */\n/* included as well as system wide 64-bit large memory usage.        */\n/*                                                                   */\n/* For z/OS 1.10 and above, 64-bit common memory allocations are     */\n/* included as well as system wide 64-bit common memory usage.       */\n/*                                                                   */\n/* For z/OS 1.12 and above, 64-bit large memory usage High Water     */\n/* Mark (HWM) is displayed in the summary.  You can get this         */\n/* display on z/OS 1.10 and z/OS 1.11 if you have APAR OA31116       */\n/* installed.  See comments in source code for what you need         */\n/* to change if you have this APAR installed and want the HWM.       */\n/*                                                                   */\n/* The system wide 64-bit shared memory and 64-bit common usage      */\n/* numbers come from the RSM Control and Enumeration Area (RCE).     */\n/*                                                                   */\n/* See MVS Data Areas manual and SYS1.MODGEN(IARRAX)                 */\n/*                           and SYS1.MODGEN(IARRCE)                 */\n/*********************************************************************/\n/* Be sure OA02888 is applied (z/OS 1.2, 1.3 and 1.4) or RAXLVGBYTES */\n/* will not be cleared between job steps that run in an initiator.   */\n/*********************************************************************/\n/* SEE OA14391 for an explanation of MEMSRC.10 (IEFUSI + REGION=0)   */\n/* After this APAR you won't see REG=0 as a reason if IEFUSI         */\n/* changes your REGION without touching MEMLIMIT.                    */\n/*********************************************************************/\n/* TSO execution syntax: TSO %RXSTOR64                               */\n/*                       TSO %RXSTOR64 ALL                           */\n/*                       TSO %RXSTOR64 NODETAIL                      */\n/*                                                                   */\n/* By default, only tasks that have memory objects allocated will    */\n/* be displayed unless the \"ALL\" option is used.  A system wide      */\n/* summary of usage for HVSHARE/HVCOMMON/LFAREA is displayed at      */\n/* the end. You can use the \"NODETAIL\" option if you only want       */\n/* to see the summary informaion. Note that NODETAIL can be          */\n/* abbreviated using one or more of its characters.                  */\n/*********************************************************************/\nArg OPT\n/*********************************************************************/\nLASTUPD = '08/27/2016'              /* date of last update           */\n/*********************************************************************/\nSignal On  Syntax  name SIG_ALL     /* trap syntax errors            */\nSignal On  Novalue name SIG_ALL     /* trap uninitialized variables  */\n/*********************************************************************/\n/* \"NODETAIL\" option - system wide totals only ??                    */\n/*********************************************************************/\nDETAIL = 'YES'\nIf Abbrev('NODETAIL',Translate(OPT),1) <> 0 then DETAIL = 'NO'\n\nNumeric digits 20                           /* dflt of 9 not enough  */\n\nCVT      = C2d(Storage(10,4))               /* point to CVT          */\nCVTFLAG2 = Storage(D2x(CVT+377),1)          /* CVT flag byte 2       */\nCVTOSLV3 = Storage(D2x(CVT+1267),1)         /* byte 3 of CVTOSLVL    */\nCVTOSLV5 = Storage(D2x(CVT+1269),1)         /* byte 5 of CVTOSLVL    */\nCVTOSLV6 = Storage(D2x(CVT + 1270),1)       /* Byte 6 of CVTOSLVL    */\nRCE      = C2d(Storage(D2x(CVT + 1168),4))  /* point to RCE          */\nFLCARCH  = Storage('A3',1)                  /* FLCARCH in PSA        */\nIf bitand(CVTOSLV3,'10'x) <> '10'x | ,      /* z/OS 1.2 or above ?   */\n   C2d(FLCARCH) = 0 then do                 /* 0 means not z/Arch.   */\n  Say 'System must be at least z/OS 1.2 and running in'\n  Say 'z/Architecture mode to use this exec.'\n  Exit 12\nEnd\nIf bitand(CVTOSLV3,'02'x) = '02'x then ,    /* z/OS 1.5 and above?   */\n   HVSHARE = 1                              /* set HVSHARE avail flag*/\n  Else HVSHARE = 0                          /* below z/OS 1.5        */\nIf Bitand(CVTOSLV5,'10'x) = '10'x &     ,   /* z/OS 1.9 and above &  */\n   Bitand(CVTFLAG2,'01'x) = '01'x then ,    /*  CVTEDAT on (z10 >)?  */\n   LARGEMEM = 1                             /* set LARGEMEM avail flg*/\n  Else LARGEMEM = 0                         /* < z/OS 1.9/no hw supt */\nIf bitand(CVTOSLV5,'08'x) = '08'x then ,    /* z/OS 1.10 and above   */\n   HVCOMMON = 1                             /* set HVCOMMON avail flg*/\n  Else HVCOMMON = 0                         /* below z/OS 1.10       */\nIf Bitand(CVTOSLV6,'80'x) = '80'x then ,    /* z/OS 2.1 and above    */\n   PL = 1                                   /* pageable1m            */\n  Else PL = 0                               /* no pageable1m         */\n /* HVSHARE = 0  */ /* force 0 for testing  - must set others to 0   */\n /* LARGEMEM = 0 */ /* force 0 for testing */\n /* HVCOMMON = 0 */ /* force 0 for testing */\n\nCVTASVT  = C2d(Storage(D2x(CVT+556),4))     /* point to ASVT         */\nASVTMAXU = C2d(Storage(D2x(CVTASVT+516),4)) /* max number of entries */\n\n\nIf LARGEMEM = 1 then do                        /* z/OS 1.9 and above */\n  RCEReconLFASize  = C2d(Storage(D2x(RCE + 760),8)) /* recon lfarea  */\n  RCENonReconLFASize = C2d(Storage(D2x(RCE + 768),8)) /*  LFAREA     */\n /* Comment out or delete the next 2 lines of code if you want the   */\n /* large memory displays even if you specified or defaulted to      */\n /* LFAREA=0M (z/OS 1.9 & above) and have the hardware support.      */\n  If RCEReconLFASize = 0 & RCENonReconLFASize = 0 then ,  /* both 0? */\n   LARGEMEM = 0                         /* set LARGEMEM not avail flg*/\n  If Bitand(CVTOSLV6,'80'x) = '80'x then do /* z/OS 2.1 and above    */\n    /*****************/\n    /* 2G frame code */\n    /*****************/\n    RCE2GMemoryObjects          = ,\n     C2d(Storage(D2x(RCE + 1256),8))    /* Number of 2G objects      */\n    RCE2GNonReconLFASize        = ,\n     C2d(Storage(D2x(RCE + 1272),8))    /* 2G frame area in 2G units */\n    RCE2GNonReconLFAUsed        = ,\n     C2d(Storage(D2x(RCE + 1280),8))    /* used 2G frames            */\n    RCE2GHWM                    = ,\n     C2d(Storage(D2x(RCE + 1288),4))    /* 2G used frames HWM        */\n    If RCE2GNonReconLFASize <> 0 then LARGEMEM = 1  /* lfarea used   */\n  End\nEnd /* If LARGEMEM = 1 */\n\nIf HVSHARE = 1 then do                         /* z/OS 1.5 and above */\n   /* Memlimit Source Table */\n  MEMSRC.0  = '       '\n  MEMSRC.1  = '  SMF  '\n  MEMSRC.2  = '  JCL  '\n  MEMSRC.3  = ' REG=0 '\n  MEMSRC.4  = ' IEFUSI'\n  MEMSRC.5  = 'OMVSSEG'\n  MEMSRC.6  = 'SETRLIM'\n  MEMSRC.7  = ' SPAWN '\n  MEMSRC.8  = 'SETOMVS'\n  MEMSRC.9  = 'AUTHPGM'\n  MEMSRC.10 = 'USIREG0'\nIf DETAIL = 'YES' then do\n  If HVCOMMON = 1 & LARGEMEM = 1 then do       /* z/OS 1.10 & above  */\n                                               /* + largemem support */\n    Queue '                                6 4 - B I T  ' ,\n          '  S T O R A G E     A L L O C A T I O N'\n    Queue '  '\n    Queue '  TASK     MEMORY   MEMLIM   NUM    ALLOC' ,\n        ' GUARDED   HWM   SHARE   SHARE   SHARE  LARGE   LARGE' ,\n        ' COMMN   COMMN   COMMN'\n    Queue '  NAME     LIMIT    SOURCE   OBJ     MEM ' ,\n        '   MEM     MEM   # OBJ   ALLOC    HWM   # OBJ   ALLOC' ,\n        ' # OBJ   ALLOC    HWM '\n    Queue '--------  -------  -------  -----  ------' ,\n        ' ------  ------  -----  ------  ------  -----  ------' ,\n        ' -----  ------  ------'\n  End /* If HVCOMMON = 1 & LARGEMEM = 1 */\n  Else if HVCOMMON = 1 & LARGEMEM = 0 then do  /* z/OS 1.10 & above  */\n                                               /* no largemem support*/\n    Queue '                         6 4 - B I T  ' ,\n          '  S T O R A G E     A L L O C A T I O N'\n    Queue '  '\n    Queue '  TASK     MEMORY   MEMLIM   NUM    ALLOC' ,\n        ' GUARDED   HWM   SHARE   SHARE   SHARE  COMMN   COMMN' ,\n        '  COMMN'\n    Queue '  NAME     LIMIT    SOURCE   OBJ     MEM ' ,\n        '   MEM     MEM   # OBJ   ALLOC    HWM   # OBJ   ALLOC' ,\n        '   HWM '\n    Queue '--------  -------  -------  -----  ------' ,\n        ' ------  ------  -----  ------  ------  -----  ------' ,\n        ' ------'\n  End /* If HVCOMMON = 1 & LARGEMEM = 0 */\n  Else if LARGEMEM = 1 then do                 /* z/OS 1.9 & above   */\n    Queue '                     6 4 - B I T     S T O R A G E  ' ,\n          '  A L L O C A T I O N'\n    Queue '  '\n    Queue '  TASK     MEMORY   MEMLIM   NUM    ALLOC' ,\n        ' GUARDED   HWM   SHARE   SHARE   SHARE  LARGE   LARGE'\n    Queue '  NAME     LIMIT    SOURCE   OBJ     MEM ' ,\n        '   MEM     MEM   # OBJ   ALLOC    HWM   # OBJ   ALLOC'\n    Queue '--------  -------  -------  -----  ------' ,\n        ' ------  ------  -----  ------  ------  -----  ------'\n  End /* if LARGEMEM = 1 */\n  Else Do\n    Queue '             6 4 - B I T     S T O R A G E  ' ,\n          '  A L L O C A T I O N'\n    Queue '  '\n    Queue '  TASK     MEMORY   MEMLIM   NUM    ALLOC' ,\n        ' GUARDED   HWM   SHARE   SHARE   SHARE'\n    Queue '  NAME     LIMIT    SOURCE   OBJ     MEM ' ,\n        '   MEM     MEM   # OBJ   ALLOC    HWM '\n    Queue '--------  -------  -------  -----  ------' ,\n        ' ------  ------  -----  ------  ------'\n  End /* else do */\nEnd /* If DETAIL = 'YES' then do */\nElse do\n    Queue '6 4 - B I T    S T O R A G E ' ,\n          '  A L L O C A T I O N    S U M M A R Y'\nEnd\nEnd /* if HVSHARE = 1 */\nElse Do                                         /* below z/os 1.5    */\n   /* Memlimit Source Table */\n  MEMSRC.0  = '              '\n  MEMSRC.1  = '     SMF      '\n  MEMSRC.2  = '     JCL      '\n  MEMSRC.3  = '   REGION=0   '\n  MEMSRC.4  = '    IEFUSI    '\n  MEMSRC.5  = ' OMVS SEGMENT '\n  MEMSRC.6  = 'UNIX SETRLIMIT'\n  MEMSRC.7  = '  UNIX SPAWN  '\n  MEMSRC.8  = ' SETOMVS CMD  '\n  MEMSRC.9  = ' AUTH PROGRAM '\n  MEMSRC.10 = 'IEFUSI + REG=0'\n  If DETAIL = 'YES' then do\n  Queue '        6 4 - B I T     S T O R A G E     A L L O C A T I O N'\n  Queue '  '\n  Queue '  TASK      MEMORY      MEMLIMIT       NUM     ALLOC' ,\n      '  GUARDED    HWM '\n  Queue '  NAME      LIMIT        SOURCE        OBJ      MEM ' ,\n      '    MEM      MEM '\n  Queue '--------   -------   --------------   -----   ------' ,\n      '  ------   ------'\n  End /* If DETAIL = 'YES' then do */\nEnd /* else do */\n\nNUMOBJ  = 0     /* total number of tasks with private memory objects */\nNUMSHR  = 0     /* total number of tasks with shared memory objects  */\nNUMLRG  = 0     /* total number of tasks with large memory objects   */\nNUMCOMN = 0     /* total number of tasks with common memory objects  */\nDo I = 0 to ASVTMAXU-1 /* start at 0 so I*4 bumps to next entry      */\n  ASVTENTY = Storage(D2x(CVTASVT+528+(I*4)),4)  /* cur ASVT entry    */\n  ASVT_USED = Storage(D2x(CVTASVT+528+(I*4)),1) /* in use byte       */\n  If Bitand(ASVT_USED,'80'x) == '80'x then iterate  /* avail, skip   */\n  ASCB     = C2d(ASVTENTY)     /* change to decimal for code below   */\n  ASCBRSME = C2d(Storage(D2X(ASCB+364),4))      /* point to RAX      */\n  RAX      = ASCBRSME                           /* more readable     */\n  If RAX   = 0 then iterate                /* Skip broken / NF asid? */\n  ASCBJBN  = C2d(Storage(D2x(ASCB+172),4))      /* ASCBJBNI          */\n  If ASCBJBN  = 0 then ,    /* not a job - must be START/LOGON/MOUNT */\n     ASCBJBN  = C2d(Storage(D2x(ASCB+176),4))   /* ASCBJBNS          */\n\n  TASKNAME    = Storage(D2x(ASCBJBN),8)         /* task name         */\n\n  RAXLVNMOMB = C2d(Storage(D2x(RAX + 188),4))   /* number of objects */\n  /* RAXLVNMOMB = 0 */   /* force 0 for testing */\n  If RAXLVNMOMB <> 0 then ,\n     NUMOBJ = NUMOBJ+1                      /* # tasks with objects  */\n\n  If HVSHARE = 1 then do                       /* z/OS 1.5 & above   */\n    RAXLVSHRNMOMB = C2d(Storage(D2x(RAX + 216),8)) /* # shr objects  */\n  /* RAXLVSHRNMOMB = 1 */  /* force 1 for testing */\n    If RAXLVSHRNMOMB <> 0 then ,\n       NUMSHR = NUMSHR+1                    /* # tasks with shr objs */\n  End /* if HVSHARE = 1 */\n  Else RAXLVSHRNMOMB = 0  /* never any shared objects below z/OS 1.5 */\n\n  If LARGEMEM = 1 then do                      /* z/OS 1.9 & above   */\n    RAXLargeMemoryObjects =C2d(Storage(D2x(RAX+248),8)) /*# lrg objs */\n  /* RAXLargeMemoryObjects = 1 */  /* force 1 for testing */\n    If RAXLargeMemoryObjects <> 0 then ,\n       NUMLRG = NUMLRG+1                    /* # tasks with shr objs */\n  End /* if LARGEMEM = 1 */\n  Else RAXLargeMemoryObjects=0    /* no large memory below z/OS 1.9  */\n\n  If HVCOMMON = 1 then do                      /* z/OS 1.10 & above  */\n    RAXHVCommonNMOMB = C2d(Storage(D2x(RAX + 280),8)) /* # comn objs */\n  /* RAXHVCommonNMOMB = 1 */  /* force 1 for testing */\n    If RAXHVCommonNMOMB <> 0 then ,\n       NUMCOMN = NUMCOMN+1                  /* # tasks with comn objs*/\n  End /* if HVCOMMON = 1 */\n  Else RAXHVCommonNMOMB = 0       /* no shared common below z/OS 1.10*/\n\n  If OPT <> 'ALL' & ,\n    (RAXLVNMOMB=0 & RAXLVSHRNMOMB=0 & ,\n     RAXLargeMemoryObjects=0 & RAXHVCommonNMOMB=0) then iterate\n\n  RAXLVMEMLIM = C2d(Storage(D2x(RAX+152),8))    /* MEMLIMIT in MB    */\n  RAXLVMEMLIM = FORMAT_MEMSIZE(RAXLVMEMLIM)     /* format size       */\n\n  RAXLVMEMLIMS = C2d(Storage(D2x(RAX + 184),1)) /* MEMLIMIT source   */\n\n  RAXLVABYTES = C2d(Storage(D2x(RAX + 160),8))  /* bytes allocated   */\n  RAXLVABYTES = RAXLVABYTES/1024/1024           /* change to MB      */\n  RAXLVABYTES = FORMAT_MEMSIZE(RAXLVABYTES)     /* format size       */\n\n  RAXLVHBYTES = C2d(Storage(D2x(RAX + 168),8))  /* bytes guarded     */\n  RAXLVHBYTES = RAXLVHBYTES/1024/1024           /* change to MB      */\n  RAXLVHBYTES = FORMAT_MEMSIZE(RAXLVHBYTES)     /* format size       */\n\n  RAXLVGBYTES = C2d(Storage(D2x(RAX + 176),8))  /* high water mark   */\n  RAXLVGBYTES = RAXLVGBYTES/1024/1024           /* change to MB      */\n  RAXLVGBYTES = FORMAT_MEMSIZE(RAXLVGBYTES)     /* format size       */\n\n  If HVSHARE = 1 then do                       /* z/OS 1.5 & above   */\n    RAXLVSHRBYTES = C2d(Storage(D2x(RAX + 200),8)) /* shr bytes alloc*/\n    RAXLVSHRBYTES = RAXLVSHRBYTES/1024/1024        /* change to MB   */\n    RAXLVSHRBYTES = FORMAT_MEMSIZE(RAXLVSHRBYTES)  /* format size    */\n\n    RAXLVSHRGBYTES = C2d(Storage(D2x(RAX + 208),8)) /* shr bytes HWM */\n    RAXLVSHRGBYTES = RAXLVSHRGBYTES/1024/1024       /* change to MB  */\n    RAXLVSHRGBYTES = FORMAT_MEMSIZE(RAXLVSHRGBYTES) /* format size   */\n  End /* if HVSHARE = 1 */\n\n  If LARGEMEM = 1 then do                       /* z/OS 1.9 & above  */\n    RAXLargePagesBackedinReal = ,\n     C2d(Storage(D2x(RAX + 256),8))             /* large obj pages   */\n    RAXLargePagesBackedinReal = ,\n     FORMAT_MEMSIZE(RAXLargePagesBackedinReal)  /* format size       */\n  End /* if LARGEMEM = 1 */\n\n  If HVCOMMON = 1 then do                      /* z/OS 1.10 & above  */\n    RAXHVCommonBytes = C2d(Storage(D2x(RAX + 264),8)) /*cmn bytes alc*/\n    RAXHVCommonBytes = RAXHVCommonBytes/1024/1024     /* chg to MB   */\n    RAXHVCommonBytes = FORMAT_MEMSIZE(RAXHVCommonBytes) /*format size*/\n\n    RAXHVCommonHWMBytes = C2d(Storage(D2x(RAX + 272),8)) /*common HWM*/\n    RAXHVCommonHWMBytes = RAXHVCommonHWMBytes/1024/1024  /* chg to MB*/\n    RAXHVCommonHWMBytes = FORMAT_MEMSIZE(RAXHVCommonHWMBytes) /* fmt */\n\n  End /* if HVCOMMON = 1 */\n\n  If DETAIL = 'YES' then do\n\n  If HVCOMMON = 1 & LARGEMEM = 1 then do       /* z/OS 1.10 & above  */\n                                               /* + largemem support */\n\n  Queue TASKNAME ' 'Right(RAXLVMEMLIM,7) ,\n           ' 'MEMSRC.RAXLVMEMLIMS ,\n           ' 'Right(RAXLVNMOMB,5)      Right(RAXLVABYTES,7) ,\n              Right(RAXLVHBYTES,7)     Right(RAXLVGBYTES,7) ,\n           ' 'Right(RAXLVSHRNMOMB,5)   Right(RAXLVSHRBYTES,7) ,\n              Right(RAXLVSHRGBYTES,7) ,\n           ' 'Right(RAXLargeMemoryObjects,5) ,\n              Right(RAXLargePagesBackedinReal,7) ,\n           ' 'Right(RAXHVCommonNMOMB,5) Right(RAXHVCommonBytes,7) ,\n              Right(RAXHVCommonHWMBytes,7)\n  End /* If HVCOMMON = 1 & LARGEMEM = 1 */\n  Else If HVCOMMON = 1 & LARGEMEM = 0 then do  /* z/OS 1.10 & above  */\n                                               /* no largemem support*/\n  Queue TASKNAME ' 'Right(RAXLVMEMLIM,7) ,\n           ' 'MEMSRC.RAXLVMEMLIMS ,\n           ' 'Right(RAXLVNMOMB,5)      Right(RAXLVABYTES,7) ,\n              Right(RAXLVHBYTES,7)     Right(RAXLVGBYTES,7) ,\n           ' 'Right(RAXLVSHRNMOMB,5)   Right(RAXLVSHRBYTES,7) ,\n              Right(RAXLVSHRGBYTES,7) ,\n           ' 'Right(RAXHVCommonNMOMB,5) Right(RAXHVCommonBytes,7) ,\n              Right(RAXHVCommonHWMBytes,7)\n  End /* If HVCOMMON = 1 & LARGEMEM = 0 */\n  Else if LARGEMEM = 1 then do                 /* z/OS 1.9 & above   */\n  Queue TASKNAME ' 'Right(RAXLVMEMLIM,7) ,\n           ' 'MEMSRC.RAXLVMEMLIMS ,\n           ' 'Right(RAXLVNMOMB,5)      Right(RAXLVABYTES,7) ,\n              Right(RAXLVHBYTES,7)     Right(RAXLVGBYTES,7) ,\n           ' 'Right(RAXLVSHRNMOMB,5)   Right(RAXLVSHRBYTES,7) ,\n              Right(RAXLVSHRGBYTES,7) ,\n           ' 'Right(RAXLargeMemoryObjects,5) ,\n              Right(RAXLargePagesBackedinReal,7)\n  End /* if HVSHARE = 1 */\n  Else if HVSHARE = 1 then do                  /* z/OS 1.5 & above   */\n  Queue TASKNAME ' 'Right(RAXLVMEMLIM,7) ,\n           ' 'MEMSRC.RAXLVMEMLIMS ,\n           ' 'Right(RAXLVNMOMB,5)      Right(RAXLVABYTES,7) ,\n              Right(RAXLVHBYTES,7)     Right(RAXLVGBYTES,7) ,\n           ' 'Right(RAXLVSHRNMOMB,5)   Right(RAXLVSHRBYTES,7) ,\n              Right(RAXLVSHRGBYTES,7)\n  End /* if HVSHARE = 1 */\n  Else Do                                      /* below z/os 1.5     */\n  Queue TASKNAME '  'Right(RAXLVMEMLIM,7) ,\n           '  'MEMSRC.RAXLVMEMLIMS ,\n          '  'Right(RAXLVNMOMB,5)   ' 'Right(RAXLVABYTES,7) ,\n           ' 'Right(RAXLVHBYTES,7)  ' 'Right(RAXLVGBYTES,7)\n  End /* else do */\n\n  End /* If DETAIL = 'YES' then do  */\n\nEnd  /* Do I = 0 to ASVTMAXU-1 */\n\n\nIf (NUMOBJ = 0 & NUMSHR = 0 & ,\n    NUMLRG = 0 & NUMCOMN = 0) & OPT <> 'ALL' then do\n  Queue ' '\n  Queue '** No tasks have memory objects allocated **'\n  Queue '**    Use the \"ALL\" option for details    **'\n  Queue ' '\nEnd\nElse do\n  If HVSHARE = 1 then do                       /* z/OS 1.5 & above   */\n    /**********************************/\n    /* System wide totals for HVSHARE */\n    /**********************************/\n    RCELVSHRSTRT   = C2d(Storage(D2x(RCE + 544),8)) /* low virt addr */\n                                                    /* for 64-bit shr*/\n    RCELVSHRSTRT_D = C2x(Storage(D2x(RCE + 544),8)) /* make readable */\n    VSHRSTRT_D     = Substr(RCELVSHRSTRT_D,1,8) ,   /*  address range*/\n                     Substr(RCELVSHRSTRT_D,9,8)     /*   display     */\n\n    RCELVHPRSTRT   = C2d(Storage(D2x(RCE + 552),8)) /* low virt addr */\n                                                    /* for 64-bit prv*/\n    RCELVHPRSTRT_D = C2d(Storage(D2x(RCE + 552),8))-1 /*make readable*/\n    RCELVHPRSTRT_D = Right(D2x(RCELVHPRSTRT_D),16,'0') /* address    */\n    VHPRSTRT_D     = Substr(RCELVHPRSTRT_D,1,8) ,    /*    range     */\n                     Substr(RCELVHPRSTRT_D,9,8)      /*     display  */\n\n    TOTAL_VHSHR    = RCELVHPRSTRT - RCELVSHRSTRT     /* total shared */\n    TOTAL_VHSHR    = TOTAL_VHSHR/1024/1024           /* change to MB */\n    TOTAL_VHSHR    = FORMAT_MEMSIZE(TOTAL_VHSHR)     /* format size  */\n\n    RCELVSHRSTRT   = RCELVSHRSTRT/1024/1024          /* change to MB */\n    RCELVSHRSTRT   = FORMAT_MEMSIZE(RCELVSHRSTRT)    /* format size  */\n\n    RCELVHPRSTRT   = RCELVHPRSTRT/1024/1024          /* change to MB */\n    RCELVHPRSTRT   = FORMAT_MEMSIZE(RCELVHPRSTRT)    /* format size  */\n\n    RCELVSHRPAGES  = C2d(Storage(D2x(RCE + 584),8))  /* shr pages    */\n    RCELVSHRPAGES  = (RCELVSHRPAGES*4)/1024          /* change to MB */\n    RCELVSHRPAGES  = FORMAT_MEMSIZE(RCELVSHRPAGES)   /* format size  */\n\n    RCELVSHRGBYTES = C2d(Storage(D2x(RCE + 592),8))  /* shr bytes HWM*/\n    RCELVSHRGBYTES = RCELVSHRGBYTES/1024/1024        /* change to MB */\n    RCELVSHRGBYTES = FORMAT_MEMSIZE(RCELVSHRGBYTES)  /* format size  */\n\n    RCELVSHRNMOMB  = C2d(Storage(D2x(RCE + 600),4))  /* tot shr objs */\n\n    Queue '   '\n    Queue '   '\n    Queue '   '\n    Queue '64-BIT SHARED VIRTUAL STORAGE (HVSHARE) - SYSTEM WIDE USAGE'\n    Queue '-----------------------------------------------------------'\n    Queue '   '\n    Queue 'SHARED STORAGE TOTAL:' TOTAL_VHSHR\n    Queue 'SHARED STORAGE RANGE:' RCELVSHRSTRT'-'RCELVHPRSTRT ,\n          '('VSHRSTRT_D' - 'VHPRSTRT_D')'\n    Queue 'SHARED STORAGE ALLOCATED:' RCELVSHRPAGES\n    Queue 'SHARED STORAGE ALLOCATED HWM:' RCELVSHRGBYTES\n    Queue 'SHARED OBJECTS ALLOCATED:' RCELVSHRNMOMB\n  End /* if HVSHARE = 1 */\n  End /* if LARGEMEM = 1 */\n  If HVCOMMON = 1 then do                      /* z/OS 1.10 & above  */\n    /***********************************/\n    /* System wide totals for HVCOMMON */\n    /***********************************/\n    RCEHVCommonStrt = C2d(Storage(D2x(RCE + 872),8)) /*low virt addr */\n                                                     /*for 64-bit cmn*/\n    CommonStrt_D   = C2x(Storage(D2x(RCE + 872),8))  /*make readable */\n    CommonStrt_D   = Substr(CommonStrt_D,1,8) ,      /* address range*/\n                     Substr(CommonStrt_D,9,8)        /*  display     */\n\n    RCEHVCommonEnd = C2d(Storage(D2x(RCE + 880),8))  /*high virt addr*/\n                                                     /*for 64-bit cmn*/\n    RCEHVCommonEnd = RCEHVCommonEnd + 1              /* Add 1 to addr*/\n    CommonEnd_D    = C2x(Storage(D2x(RCE + 880),8))  /*make readable */\n    CommonEnd_D    = Substr(CommonEnd_D,1,8) ,       /* address range*/\n                     Substr(CommonEnd_D,9,8)         /*  display     */\n\n    TOTAL_VHCOMN   = RCEHVCommonEnd-RCEHVCommonStrt  /* total common */\n    TOTAL_VHCOMN   = TOTAL_VHCOMN/1024/1024          /* change to MB */\n    TOTAL_VHCOMN   = FORMAT_MEMSIZE(TOTAL_VHCOMN)    /* format size  */\n\n    RCEHVCommonStrt = RCEHVCommonStrt/1024/1024      /* chg to MB    */\n    RCEHVCommonStrt = FORMAT_MEMSIZE(RCEHVCommonStrt) /* format size */\n\n    RCEHVCommonEnd = RCEHVCommonEnd/1024/1024        /* chg to MB    */\n    RCEHVCommonEnd = FORMAT_MEMSIZE(RCEHVCommonEnd)  /* format  size */\n\n    RCEHVCommonPAGES = C2d(Storage(D2x(RCE + 888),8)) /* comn pages  */\n    RCEHVCommonPAGES = (RCEHVCommonPAGES*4)/1024      /* chg to MB   */\n    RCEHVCommonPAGES = FORMAT_MEMSIZE(RCEHVCommonPAGES) /*format size*/\n\n    RCEHVCommonHWMBytes = C2d(Storage(D2x(RCE + 896),8)) /* comn HWM */\n    RCEHVCommonHWMBytes = RCEHVCommonHWMBytes/1024/1024  /*chg to MB */\n    RCEHVCommonHWMBytes = FORMAT_MEMSIZE(RCEHVCommonHWMBytes) /* fmt */\n\n    RCEHVCommonNMOMB = C2d(Storage(D2x(RCE + 904),8)) /*tot comn objs*/\n\n    Queue '   '\n    Queue '   '\n    Queue '   '\n    Queue '64-BIT COMMON VIRTUAL STORAGE (HVCOMMON) - SYSTEM' || ,\n          ' WIDE USAGE'\n    Queue '-------------------------------------------------' || ,\n          '-----------'\n    Queue '   '\n    Queue 'COMMON STORAGE TOTAL:' TOTAL_VHCOMN\n    Queue 'COMMON STORAGE RANGE:' RCEHVCommonStrt'-'RCEHVCommonEnd ,\n          '('CommonStrt_D' - 'CommonEnd_D')'\n    Queue 'COMMON STORAGE ALLOCATED:' RCEHVCommonPAGES\n    Queue 'COMMON STORAGE ALLOCATED HWM:' RCEHVCommonHWMBytes\n    Queue 'COMMON OBJECTS ALLOCATED:' RCEHVCommonNMOMB\n  End /* if HVCOMMON = 1 */\n  If LARGEMEM = 1 then do                      /* z/OS 1.10 & above  */\n    /***********************************/\n    /* System wide totals for LARGEMEM */\n    /***********************************/\n    RCELargeMemoryObjects = ,\n     C2d(Storage(D2x(RCE + 744),8))             /*tot large mem objs */\n    RCELargePagesBackedinReal = ,\n     C2d(Storage(D2x(RCE + 752),8))             /* tot lrg obj pages */\n    RCELFAvailGroups          = ,\n     C2d(Storage(D2x(RCE + 796),4))             /* avial lrg frames  */\n /* RCEReconLFAUsed             = ,\n     C2d(Storage(D2x(RCE + 776),8)) */ /* # recon 1M frames alloc    */\n    RCENonReconLFAUsed          = ,\n     C2d(Storage(D2x(RCE + 784),8))    /* # nonrecon 1M frames alloc */\n\n /* LFASize = RCEReconLFASize + RCENonReconLFASize */  /* LFAREA size*/\n    LFASize = RCENonReconLFASize                       /* LFAREA size*/\n /* LFA_Used = RCEReconLFAUsed + RCENonReconLFAUsed */\n    LFA_Used    = RCENonReconLFAUsed                   /* used LFAREA*/\n    LFA_Alloc1M = RCELargePagesBackedinReal            /* 1M alloc   */\n    LFA_Alloc4K = LFA_Used - LFA_Alloc1M               /* 4K alloc   */\n\n    If PL = 1 then do                       /* pageable1m support    */\n      RCELargeUsed4K              = ,\n       C2d(Storage(D2x(RCE + 1032),4))      /* 4K used for 1M req    */\n      LFA_Alloc4K = RCELargeUsed4K     /* chg var name for old code  */\n      RceLargeAllocatedPL         = ,\n       C2d(Storage(D2x(RCE + 1244),4))      /* # used pageable1m     */\n      RceLargeUsedPLHWM           = ,\n       C2d(Storage(D2x(RCE + 1252),4))      /* pageable1m HWM        */\n    End\n\n    LFASize     = FORMAT_MEMSIZE(LFASize)          /* format size    */\n    LFA_Avail   = FORMAT_MEMSIZE(RCELFAvailGroups) /* format size    */\n    LFA_Alloc1M = FORMAT_MEMSIZE(LFA_Alloc1M)      /* format size    */\n    LFA_Alloc4K = FORMAT_MEMSIZE(LFA_Alloc4K)      /* format size    */\n\n    If PL = 1 then do            /* z/OS 2.1 + pageable1m support    */\n      RceLargeAllocatedPL = FORMAT_MEMSIZE(RceLargeAllocatedPL)\n      RceLargeUsedPLHWM   = FORMAT_MEMSIZE(RceLargeUsedPLHWM)\n      /*****************/\n      /* 2G frame code */\n      /*****************/\n      LFA2G_Size  = FORMAT_MEMSIZE(RCE2GNonReconLFASize*2048)\n      LFA2G_Used  = FORMAT_MEMSIZE(RCE2GNonReconLFAUsed*2048)\n      LFA2G_avail = ((RCE2GNonReconLFASize-RCE2GNonReconLFAUsed)*2048)\n      LFA2G_avail = FORMAT_MEMSIZE(LFA2G_avail)\n      LFA2G_Max   = RCE2GHWM*2048\n      LFA2G_Max   = FORMAT_MEMSIZE(LFA2G_Max)\n    End\n    /**************************************************************/\n    /* If APAR OA31116 has been applied to your z/OS 1.10 or 1.11 */\n    /* system you can change the check below to x'04' for 1.11    */\n    /* or x'08' for 1.10.  Chg display about 25 lines below also. */\n    /**************************************************************/\n\n /* If Bitand(CVTOSLV5,'08'x) = '08'x then do */ /* z/OS 1.10+OA31116*/\n /* If Bitand(CVTOSLV5,'04'x) = '04'x then do */ /* z/OS 1.11+OA31116*/\n /* If Bitand(CVTOSLV5,'02'x) = '02'x then do */ /* z/OS 1.12        */\n    If Bitand(CVTOSLV5,'02'x) = '02'x then do /* z/OS 1.12 and above */\n      RceLargeUsed1MHWM           = ,\n       C2d(Storage(D2x(RCE + 804),4)) /*large pg HWM alloc behalf 1M */\n      RceLargeUsed4KHWM           = ,\n       C2d(Storage(D2x(RCE + 808),4)) /*large pg HWM alloc behalf 4K */\n      LFA_Max1M = FORMAT_MEMSIZE(RceLargeUsed1MHWM)  /* format size  */\n      LFA_Max4K = FORMAT_MEMSIZE(RceLargeUsed4KHWM)  /* format size  */\n    End\n\n    Queue '   '\n    Queue '   '\n    Queue '   '\n    Queue '64-BIT LARGE MEMORY VIRTUAL STORAGE (LFAREA) - SYSTEM' || ,\n          ' WIDE USAGE'\n    Queue '-----------------------------------------------------' || ,\n          '-----------'\n    Queue '   '\n    If PL = 1 then do            /* z/OS 2.1 / pageable1m support    */\n      Queue 'LARGE MEMORY AREA (LFAREA):' LFASize ',' LFA2G_Size\n      Queue 'LARGE MEMORY STORAGE AVAILABLE:' LFA_Avail ',' ,\n                 LFA2G_avail\n    End\n    Else do\n      Queue 'LARGE MEMORY AREA (LFAREA):' LFASize\n      Queue 'LARGE MEMORY STORAGE AVAILABLE:' LFA_Avail\n    End\n    Queue 'LARGE MEMORY STORAGE ALLOCATED (1M):' LFA_Alloc1M\n    Queue 'LARGE MEMORY STORAGE ALLOCATED (4K):' LFA_Alloc4K\n /* If Bitand(CVTOSLV5,'08'x) = '08'x then do */ /* z/OS 1.10+OA31116*/\n /* If Bitand(CVTOSLV5,'04'x) = '04'x then do */ /* z/OS 1.11+OA31116*/\n /* If Bitand(CVTOSLV5,'02'x) = '02'x then do */ /* z/OS 1.12        */\n    If Bitand(CVTOSLV5,'02'x) = '02'x then do /* z/OS 1.12 and above */\n      Queue 'LARGE MEMORY STORAGE ALLOCATED HWM (1M):' LFA_Max1M\n      Queue 'LARGE MEMORY STORAGE ALLOCATED HWM (4K):' LFA_Max4K\n      If PL = 1 then do                     /* pageable1m support    */\n        Queue 'LARGE MEMORY STORAGE ALLOCATED (PAGEABLE1M):' ,\n         RceLargeAllocatedPL\n        Queue 'LARGE MEMORY STORAGE ALLOCATED HWM (PAGEABLE1M):' ,\n         RceLargeUsedPLHWM\n        Queue 'LARGE MEMORY STORAGE ALLOCATED (2G):' LFA2G_Used ,\n              '/' RCE2GNonReconLFAUsed 'pages'\n        Queue 'LARGE MEMORY STORAGE ALLOCATED HWM (2G):' LFA2G_Max ,\n              '/' RCE2GHWM 'PAGES'\n      End\n\n    End\n    Queue 'LARGE MEMORY OBJECTS ALLOCATED:' RCELargeMemoryObjects\n    If PL = 1 then ,             /* z/OS 2.1 / pageable1m support    */\n      Queue 'LARGE MEMORY OBJECTS ALLOCATED (2G):' RCE2GMemoryObjects\nEnd\n\n/*****************************************************************/\n/* Done processing. If ISPF is active, browse output.  Otherwise */\n/* write to the terminal via \"SAY\".                              */\n/*****************************************************************/\nQueue ''  /* null queue to end stack   */\nIf Sysvar('SYSISPF')='ACTIVE' then call BROWSE_ISPF\nElse do queued()\n Parse pull line\n Say line\nEnd\nExit 0\n\nFORMAT_MEMSIZE:\n/****************************************************************/\n/* The following code is used to display the storage size in    */\n/* the largest possible unit.  For example, 1023G and 1025G are */\n/* displayed as 1023G and 1025G, but 1024G is displayed as 1T.  */\n/* The size passed to the routine must be in MB.                */\n/****************************************************************/\nArg SIZE_IN_MB\nSelect\n   When SIZE_IN_MB < 1024 then do\n     MUNITS = 'M'\n   End\n   When SIZE_IN_MB >= 1024 & SIZE_IN_MB < 1048576 then do\n     If SIZE_IN_MB/1024 == TRUNC(SIZE_IN_MB/1024) then do\n       SIZE_IN_MB = SIZE_IN_MB/1024\n       MUNITS = 'G'\n     End\n     Else MUNITS = 'M'\n   End\n   When SIZE_IN_MB >= 1048576 & SIZE_IN_MB < 1073741824 then do\n     If SIZE_IN_MB/1048576 == TRUNC(SIZE_IN_MB/1048576) then do\n       SIZE_IN_MB = SIZE_IN_MB/1048576\n       MUNITS = 'T'\n     End\n     Else do\n       If SIZE_IN_MB/1024 == TRUNC(SIZE_IN_MB/1024) then do\n         SIZE_IN_MB = SIZE_IN_MB/1024\n         MUNITS = 'G'\n       End\n       Else MUNITS = 'M'\n     End\n   End\n   When SIZE_IN_MB >= 1073741824 & ,\n        SIZE_IN_MB <= 17591112302592 then do\n     If SIZE_IN_MB/1073741824 == TRUNC(SIZE_IN_MB/1073741824) ,\n        then do\n       SIZE_IN_MB = SIZE_IN_MB/1073741824\n       MUNITS = 'P'\n     End\n     Else do\n       SIZE_IN_MB = SIZE_IN_MB/1048576\n       MUNITS = 'T'\n     End\n   End\n   When SIZE_IN_MB = 17592186040320 then do\n       SIZE_IN_MB = 'NOLIMIT'   /* 16384P */\n       MUNITS = ''\n   End\n   When SIZE_IN_MB > 17592186040320 then do\n       SIZE_IN_MB = '*NOLIMT'   /* >16384P  (16EB) ?? */\n       MUNITS = ''\n   End\n   Otherwise do\n     Queue ' '\n     Queue 'Error in FORMAT_MEMSIZE code. Contact Mark Zelden.'\n     Queue 'SIZE_IN_MB=' SIZE_IN_MB\n     Queue ' '\n     SIZE_IN_MB = '*ERROR*'\n     MUNITS = ''\n   End\nEnd /* select */\nSTOR_SIZE =  SIZE_IN_MB || MUNITS\nReturn STOR_SIZE\n\nBROWSE_ISPF: /* Browse output if ISPF is active          */\n/*********************************************************************/\n/* Browse results                                                    */\n/*********************************************************************/\nQueue ''  /* null queue to end stack   */\nAddress ISPEXEC \"CONTROL ERRORS RETURN\"\nAddress ISPEXEC \"VGET ZENVIR\"\nAddress TSO\nprefix = sysvar('SYSPREF')        /* tso profile prefix            */\nuid    = sysvar('SYSUID')         /* tso userid                    */\nIf prefix = '' then prefix = uid  /* use uid if null prefix        */\nIf prefix <> '' & prefix <> uid then /* different prefix than uid  */\n   prefix = prefix || '.' || uid /* use  prefix.uid                */\nddnm1 = 'DDO'||random(1,99999)   /* choose random ddname           */\nddnm2 = 'DDP'||random(1,99999)   /* choose random ddname           */\njunk = msg('off')\nIf HVCOMMON = 1 & LARGEMEM = 1 then ,          /* z/OS 1.10 & above  */\n                                               /* + largemem support */\n  \"ALLOC FILE(\"||ddnm1||\") UNIT(SYSALLDA) NEW TRACKS SPACE(2,1)\",\n      \" DELETE REUSE LRECL(118) RECFM(F B) BLKSIZE(3068)\"\nElse if HVCOMMON = 1 & LARGEMEM = 0 then ,     /* z/OS 1.10 & above  */\n  \"ALLOC FILE(\"||ddnm1||\") UNIT(SYSALLDA) NEW TRACKS SPACE(2,1)\",\n      \" DELETE REUSE LRECL(103) RECFM(F B) BLKSIZE(3090)\"\n                                               /* no largemem support*/\nElse if LARGEMEM = 1 then,\n  \"ALLOC FILE(\"||ddnm1||\") UNIT(SYSALLDA) NEW TRACKS SPACE(2,1)\",\n      \" DELETE REUSE LRECL(95) RECFM(F B) BLKSIZE(3135)\"\nElse ,\n  \"ALLOC FILE(\"||ddnm1||\") UNIT(SYSALLDA) NEW TRACKS SPACE(2,1)\",\n      \" DELETE REUSE LRECL(80) RECFM(F B) BLKSIZE(3120)\"\n\"ALLOC FILE(\"||ddnm2||\") UNIT(SYSALLDA) NEW TRACKS SPACE(1,1) DELETE\",\n      \" REUSE LRECL(80) RECFM(F B) BLKSIZE(3120) DIR(1)\"\njunk = msg('on')\n\"Newstack\"\n/*************************/\n/* REXX64P Panel source */\n/*************************/\nIf Substr(ZENVIR,6,1) >= 4 then\n  Queue \")PANEL KEYLIST(ISRSPBC,ISR)\"\nQueue \")ATTR\"\nQueue \"  _ TYPE(INPUT)   INTENS(HIGH) COLOR(TURQ) CAPS(OFF)\" ,\n      \"FORMAT(&MIXED)\"\nQueue \"  | AREA(DYNAMIC) EXTEND(ON)   SCROLL(ON)\"\nQueue \"  + TYPE(TEXT)    INTENS(LOW)  COLOR(BLUE)\"\nQueue \"  @ TYPE(TEXT)    INTENS(LOW)  COLOR(TURQ)\"\nQueue \"  % TYPE(TEXT)    INTENS(HIGH) COLOR(GREEN)\"\nQueue \"  ! TYPE(OUTPUT)  INTENS(HIGH) COLOR(TURQ) PAD(-)\"\nQueue \" 01 TYPE(DATAOUT) INTENS(LOW)\"\nQueue \" 02 TYPE(DATAOUT) INTENS(HIGH)\"\nQueue \" 0B TYPE(DATAOUT) INTENS(HIGH) FORMAT(DBCS)\"\nQueue \" 0C TYPE(DATAOUT) INTENS(HIGH) FORMAT(EBCDIC)\"\nQueue \" 0D TYPE(DATAOUT) INTENS(HIGH) FORMAT(&MIXED)\"\nQueue \" 10 TYPE(DATAOUT) INTENS(LOW)  FORMAT(DBCS)\"\nQueue \" 11 TYPE(DATAOUT) INTENS(LOW)  FORMAT(EBCDIC)\"\nQueue \" 12 TYPE(DATAOUT) INTENS(LOW)  FORMAT(&MIXED)\"\nQueue \")BODY  EXPAND(//) WIDTH(&ZWIDTH)\"\nQueue \"%BROWSE  @&ZTITLE  / /  %Line!ZLINES  %Col!ZCOLUMS+\"\nQueue \"%Command ===>_ZCMD / /           %Scroll ===>_Z   +\"\nQueue \"|ZDATA ---------------/ /-------------------------|\"\nQueue \"|                     / /                         |\"\nQueue \"| --------------------/-/-------------------------|\"\nQueue \")INIT\"\nQueue \"  .HELP = ISR10000\"\nQueue \"  .ZVARS = 'ZSCBR'\"\nQueue \"  &ZTITLE = 'Mark''s MVS Utilities - RXSTOR64'\"\nQueue \"  &MIXED = MIX\"\nQueue \"  IF (&ZPDMIX = N)\"\nQueue \"   &MIXED = EBCDIC\"\nQueue \"  VGET (ZSCBR) PROFILE\"\nQueue \"  IF (&ZSCBR = ' ')\"\nQueue \"   &ZSCBR = 'CSR'\"\nQueue \")REINIT\"\nQueue \"  REFRESH(ZCMD,ZSCBR,ZDATA,ZLINES,ZCOLUMS)\"\nQueue \")PROC\"\nQueue \"  &ZCURSOR = .CURSOR\"\nQueue \"  &ZCSROFF = .CSRPOS\"\nQueue \"  &ZLVLINE = LVLINE(ZDATA)\"\nQueue \"  VPUT (ZSCBR) PROFILE\"\nQueue \")END\"\nQueue \"\"\n/*                                    */\nAddress ISPEXEC \"LMINIT DATAID(PAN) DDNAME(\"ddnm2\")\"\nAddress ISPEXEC \"LMOPEN DATAID(\"pan\") OPTION(OUTPUT)\"\nDo queued()\n   Parse pull panline\n   Address ISPEXEC \"LMPUT DATAID(\"pan\") MODE(INVAR)\" ,\n           \"DATALOC(PANLINE) DATALEN(80)\"\nEnd\nAddress ISPEXEC \"LMMADD DATAID(\"pan\") MEMBER(REXX64P)\"\nAddress ISPEXEC \"LMFREE DATAID(\"pan\")\"\n\"Delstack\"\n\"EXECIO * DISKW\" ddnm1 \"(FINIS\"\nIf (NUMOBJ = 0 & NUMSHR = 0 & ,\n    NUMLRG = 0 & NUMCOMN = 0) then zedsmsg = 'No memory objects'\n                else zedsmsg = 'Tasks found with objects'\nIf HVCOMMON = 1 & LARGEMEM = 1 then do         /* z/OS 1.10 & above  */\n                                               /* + largemem support */\n  zedlmsg = NUMOBJ 'tasks with private,' NUMSHR 'tasks' ,\n            'with shared,' NUMLRG 'tasks' ,\n            'with large and' NUMCOMN 'tasks' ,\n            'with common memory objects found.' ,\n            'RXSTOR64 - Last updated on' ,\n             LASTUPD ||'. Written by' ,\n            'Mark Zelden. Mark''s MVS Utilities -' ,\n            'http://www.mzelden.com/mvsutil.html'\nEnd /* If HVCOMMON = 1 */\nElse if HVCOMMON = 1 & LARGEMEM = 0 then do    /* z/OS 1.10 & above  */\n                                               /* no largemem support*/\n  zedlmsg = NUMOBJ 'tasks with private,' NUMSHR 'tasks' ,\n            'with shared and' NUMCOMN 'tasks' ,\n            'with common memory objects found.' ,\n            'RXSTOR64 - Last updated on' ,\n             LASTUPD ||'. Written by' ,\n            'Mark Zelden. Mark''s MVS Utilities -' ,\n            'http://www.mzelden.com/mvsutil.html'\nEnd /* If HVCOMMON = 1 */\nElse if LARGEMEM = 1 then do                   /* z/OS 1.9 and above */\n  zedlmsg = NUMOBJ 'tasks with private,' NUMSHR 'tasks' ,\n            'with shared and' NUMLRG 'tasks' ,\n            'with large memory objects found.' ,\n            'RXSTOR64 - Last updated on' ,\n             LASTUPD ||'. Written by' ,\n            'Mark Zelden. Mark''s MVS Utilities -' ,\n            'http://www.mzelden.com/mvsutil.html'\nEnd /* If LARGEMEM = 1 */\nElse if HVSHARE = 1 then do                    /* z/OS 1.5 and above */\n  zedlmsg = NUMOBJ 'tasks with private and' NUMSHR 'tasks' ,\n            'with shared memory objects found.' ,\n            'RXSTOR64 - Last updated on' ,\n             LASTUPD ||'. Written by' ,\n            'Mark Zelden. Mark''s MVS Utilities -' ,\n            'http://www.mzelden.com/mvsutil.html'\nEnd   /* If HVSHARE = 1*/\nElse do\n  zedlmsg = NUMOBJ 'tasks with memory objects found.' ,\n            'RXSTOR64 - Last updated on' ,\n             LASTUPD ||'. Written by' ,\n            'Mark Zelden. Mark''s MVS Utilities -' ,\n            'http://www.mzelden.com/mvsutil.html'\nEnd\nAddress ISPEXEC \"LIBDEF ISPPLIB LIBRARY ID(\"ddnm2\") STACK\"\nIf OPT <> 'ALL' & (NUMOBJ = 0 & NUMSHR = 0) then ,\n  Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm  */\nElse ,\n  Address ISPEXEC \"SETMSG MSG(ISRZ000)\"  /* msg - no alarm    */\nAddress ISPEXEC \"LMINIT DATAID(TEMP) DDNAME(\"ddnm1\")\"\nAddress ISPEXEC \"BROWSE DATAID(\"temp\") PANEL(REXX64P)\"\nAddress ISPEXEC \"LMFREE DATAID(\"temp\")\"\nAddress ISPEXEC \"LIBDEF ISPPLIB\"\njunk = msg('off')\n\"FREE FI(\"ddnm1\")\"\n\"FREE FI(\"ddnm2\")\"\nReturn\n\nSIG_ALL:\nSIGTYPE = Condition('C')                   /* condition name         */\nIf SIGTYPE   = 'SYNTAX' then ,             /* SYNTAX error ?         */\n  SIGINFO    = Errortext(RC)               /* rexx error message     */\nElse SIGINFO = Condition('D')              /* condition description  */\nSIGLINE      = Strip(Sourceline(SIGL))     /* error source code      */\nSay 'SIGNAL -' SIGTYPE 'ERROR:' SIGINFO ,  /* display the error info */\n    'on source line number' SIGL':'        /*   and line number      */\nSay '\"'SIGLINE'\"'                          /* error source code      */\n\"Delstack\"                                 /* delete data stack      */\nExit 16                                    /* exit RC=16             */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SDSF@DR": {"ttr": 15113, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x10\\x08\\x8f\\x01\\x19$\\x0f\\x16\\x15\\x00\\xe1\\x00\\xd0\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf9\\xf8@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-03-29T00:00:00", "modifydate": "2019-08-28T16:15:00", "lines": 225, "newlines": 208, "modlines": 0, "user": "CBT498"}, "text": "/* REXX */\n/*                                       */\n/* AUTHOR: Mark Zelden                   */\n/*                                       */\n/* Trace ?r */\n/*********************************************************************/\n/* EXEC:  SDSF@DR                                                    */\n/*                                                                   */\n/* FUNCTION: To take all the output in the spool at DR and copy it   */\n/*           to data sets via SDSF \"PRINT\" command.                  */\n/*                                                                   */\n/*********************************************************************/\n/* EXECUTION SYNTAX:                                                 */\n/*   SDSF@DR volser jobname_mask hlq storclas                        */\n/*                                                                   */\n/*   No parms are required but in order to use the 2nd parm,         */\n/*   the first one must be specified.  In order to use the 3rd       */\n/*   parm, the first and second ones must be specified, and so on.   */\n/*                                                                   */\n/* DEFAULTS:                                                         */\n/*   SDSF@DR DRWRK1 * TECH    (no storclas used)                     */\n/*                                                                   */\n/* EXAMPLES:                                                         */\n/*                                                                   */\n/*  SDSF@DR                                                          */\n/*   (O/P to DRWRK1, select all jobs, HLQ of TECH no STORCLAS)       */\n/*                                                                   */\n/*  SDSF@DR DRWRK2                                                   */\n/*   (O/P to DRWRK2)                                                 */\n/*                                                                   */\n/*  SDSF@DR DRWRK1 MYJOBS*                                           */\n/*   (O/P to DRWRK2, only select \"MYJOBS*\")                          */\n/*                                                                   */\n/*  SDSF@DR DRWRK1 MYJOBS* SYSDR                                     */\n/*   (O/P to DRWRK2, select \"MYJOBS*\", HLQ of SYSDR)                 */\n/*                                                                   */\n/*  SDSF@DR DRWRK1 MYJOBS* SYSDR NONSMS                              */\n/*   (O/P to DRWRK1, select \"MYJOB*\", HLQ of SYSDR, STORCLAS=NONSMS) */\n/*                                                                   */\n/*                                                                   */\n/* Sample JCL to execute in batch:                                   */\n/*                                                                   */\n/* //MYJOB JOB (ACCT),CLASS=A,...                                    */\n/* //S1 EXEC PGM=IRXJCL,PARM='SDSF@DR'                               */\n/* //*S1 EXEC PGM=IRXJCL,PARM='SDSF@DR DRWRK2'                     */*/\n/* //*S1 EXEC PGM=IRXJCL,PARM='SDSF@DR DRWRK1 MYJOBS*'             */*/\n/* //*S1 EXEC PGM=IRXJCL,PARM='SDSF@DR DRWRK1 MYJOBS* SYSDR'       */*/\n/* //*S1 EXEC PGM=IRXJCL,PARM='SDSF@DR DRWRK1 MYJOBS* SYSDR NONSMS'*/*/\n/* //SYSTSIN  DD DUMMY                                               */\n/* //SYSTSPRT DD SYSOUT=*                                            */\n/* //SYSEXEC  DD DSN=pds.with.this.exec,DISP=SHR                     */\n/*                                                                   */\n/*                                                                   */\n/* Output data set names will be in the format of:                   */\n/*   hlq.DR.smfid.jobname.JOBnnnnn.Yyyyy.Dnnn                        */\n/*   hlq.DR.smfid.jobname.STCnnnnn.Yyyyy.Dnnn                        */\n/*                                                                   */\n/* Example:                                                          */\n/*   TECH.DR.SYSA.SYSLOG.STC00002.Y2019.D240                         */\n/*                                                                   */\n/*********************************************************************/\n/* Updates:                                                          */\n/*                                                                   */\n/* 10/12/2018: Check for \"*BOTTOM OF DATA REACHED*\" as a normal      */\n/*             message from XDC and not display it as an error.      */\n/*                                                                   */\n/* 08/28/2019: Change the \"ST\" panel invocation from                 */\n/*             Address SDSF \"ISFEXEC ST (DELAYED ALTERNATE)\"         */\n/*               to                                                  */\n/*             Address SDSF \"ISFEXEC ST (DELAYED)\"                   */\n/*             in case no alternate panel is defined.  By            */\n/*             default both primary and alternate fields are         */\n/*             merged if an alternate exists anyway.                 */\n/*                                                                   */\n/*********************************************************************/\n\n\nArg outvol isfprefix hlq storclas .\n/**********************************************/\n/* House keeping                              */\n/**********************************************/\nIf outvol    = '' then isfprtvolser = 'DRWRK1' /* dflt output volume */\nIf isfprefix = '' then isfprefix = '*'         /* jobs to process    */\nIf hlq       = '' then hlq = 'TECH'            /* o/p dsns HLQ       */\nIf storclas  = '' then nop                     /* o/p dsns STORCLAS  */\nsmfid        = MVSVAR('SYSSMFID')              /* SMFID              */\ntot_failed   = 0 /* total # of jobs that failed and can't be printed */\n\n\n/**********************************************/\n/* Start of main code                         */\n/**********************************************/\nSay 'SDSF@DR processing parameters used for this run:'\nSay '    Output volume =' outvol\nIf isfprefix = '*' then ,\n  Say '    Jobs to process =  (all jobs will be processed)'\nElse ,\n  Say '    Jobs to process =' isfprefix\nSay '    HLQ of output data sets =' hlq\nIf storclas = '' then ,\n  Say '    SMS STORCLAS = (none specified)'\nElse ,\n  Say '    SMS STORCLAS =' storclas\nSay '               '      /* blank line to make more readable */\n\nrc=isfcalls('ON')\n  /*************************/\n  /* Access the ST display */\n  /*************************/\n  isfsort   = 'JNAME A JOBID A'    /* sort / process in jobname order */\n  Address SDSF \"ISFEXEC ST (DELAYED)\"             /* ST command       */\n  Drop jname.      /* get rid of results from first time              */\n  Address SDSF \"ISFEXEC ST (DELAYED)\"            /* may not catch the */\n                   /* batch job running this if not issued a 2nd time */\n  lrc=rc\n  call msgrtn\n  if lrc<>0 then exit 20\n  /**********************************************************/\n  /* 1st loop to display all jobs returned via \"ST\" command */\n  /**********************************************************/\n  Say 'The following' jname.0 'jobs were returned from the \"ST\"' ,\n      'command and will be processed:'\n  do dis_jobs=1 to jname.0\n      Say '   ' Left(jname.dis_jobs,8) ' ' jobid.dis_jobs\n  end\n  Say ' '\n  Say ' '\n  Say ' '\n  /**********************************************************/\n  /* 2nd loop to print all jobs returned via \"ST\" command   */\n  /**********************************************************/\n  Say 'Processing jobs ...'\n  Say ' '\n  do ix=1 to jname.0\n      call Setup_print_vars\n\n      Say 'Attempting to print output to DSN=' || ,\n        Strip(Translate(isfprtdsname,\"\",\"'\"))  /* remove quotes */\n\n        /******************************************/\n        /* Issue the XDC action against the job   */\n        /******************************************/\n        Address SDSF \"ISFACT ST TOKEN('\"TOKEN.ix\"') PARM(NP XDC)\"\n        lrc=rc\n        call msgrtn\n    /*  if lrc<>0 then exit 20 */\n\n  end  /* end do ix=1 */\n\nrc=isfcalls('OFF')\n\nSay ' '\nSay ' '\nSay ' '\nSay '***********************************'\nSay ' Program totals'\nSay ' '\nSay ' Total JOBs processed =' jname.0\nSay ' Total JOBs printed   =' jname.0 - tot_failed\nSay ' Total JOBs failed    =' tot_failed\nSay '***********************************'\n\nexit 0\n/**********************************************/\n/* End of main code                           */\n/**********************************************/\n\n\n/*============================================*/\n/* S U B R O U T I N E S                      */\n/*============================================*/\n/*************************************/\n/* Subroutine to list error messages */\n/*************************************/\nmsgrtn: procedure expose isfmsg isfmsg2. tot_failed jname. jobid. ix\n\n  /************************************************/\n  /* The isfmsg variable contains a short message */\n  /************************************************/\n  if isfmsg = '' |  Strip(isfmsg) = 'PRINT CLOSED' ,\n          | Strip(isfmsg) = '*BOTTOM OF DATA REACHED*' ,\n    then nop  /* normal messages from print */\n  else do\n    Say '  ** Error processing' jname.ix jobid.ix\n    Say '  **' isfmsg\n\n    tot_failed = tot_failed + 1 /* add 1 to failed total */\n       /****************************************************/\n       /* The isfmsg2 stem contains additional descriptive */\n       /* error messages                                   */\n       /****************************************************/\n   /* do ix=1 to isfmsg2.0\n        Say \"isfmsg2.\"ix \"is:\" isfmsg2.ix\n      end */\n\n  end\nreturn\n\n/**********************************************************************/\n/* Setup required vars for printing                                   */\n/**********************************************************************/\nSetup_print_vars:\nisfprtblksize = '0'           /* default 3120 */\nisfprtdisp = 'NEW'\n /***********************************************************/\n /* Output data set names will be in the format of:         */\n /*  hlq.DR.smfid.jobname.JOBnnnnn.Yyyyy.Dnnn               */\n /*  hlq.DR.smfid.jobname.STCnnnnn.Yyyyy.Dnnn               */\n /* Example:                                                */\n /*  TECH.DR.SYSA.SYSLOG.STC00002.Y2010.D088                */\n /***********************************************************/\nisfprtdsname = \"'\"hlq\".DR.\"smfid\".\"jname.ix\".\"jobid.ix\".\" || ,\n    \"Y\"substr(dater.ix,1,4)\".D\"substr(dater.ix,6,3)\"'\"\nisfprtlrecl       = '255'          /* default 240  */\nisfprtprimary     = '4500'         /* default 500  */\nisfprtrecfm       = 'VBA'          /* default VBA  */\nisfprtsecondary   = '4500'         /* default 500  */\nisfprtspacetype   = 'TRKS'         /* default BLKS  */\nisfprtmember = ''\n/* isfprtdirblks  = ''  */\n/* isfprtdataclas = ''  */\nisfprtunit = 'SYSALLDA'\nisfprtvolser = outvol      /* passed via ARG or dflt set at top */\nisfprtstorclas = storclas  /* passed via ARG or dflt set at top */\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SDSFPRT": {"ttr": 15364, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01 \\x12\\x7f\\x01 \\x12\\x7f\"\\x00\\x01~\\x01~\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf9\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-05-06T00:00:00", "modifydate": "2020-05-06T22:00:00", "lines": 382, "newlines": 382, "modlines": 0, "user": "CBT499"}, "text": "/* REXX */\n/*                                       */\n/* AUTHOR: Mark Zelden                   */\n/*                                       */\n/* Trace ?r */\n/*********************************************************************/\n/* EXEC:  SDSFPRT                                                    */\n/*                                                                   */\n/* FUNCTION: To take all or selected output from the spool and       */\n/*           copy it to a PDS via SDSF \"PRINT\" commands.             */\n/*                                                                   */\n/*           Each job is created in the PDS as a member name with    */\n/*           the JOBID - JOBnnnnn, TSUnnnnn or STCnnnnn.             */\n/*           In addition, an member named \"$$$INDEX\" is created      */\n/*           in the output PDS that has a list of the JOBNAMEs,      */\n/*           JOBIDs, MAXRCs, OWNERIDs, Programmer Names, Start       */\n/*           Times, Start Dates, End Times and End Dates.            */\n/*                                                                   */\n/*           JOBID / member names could also be Jnnnnnnn, Tnnnnnnn   */\n/*           or Snnnnnnn if you are using Job numbers over 5 digits. */\n/*                                                                   */\n/*           The default output PDS data set name is userid.PRINT.   */\n/*           If it doesn't exist it will be created with LRECL(255)  */\n/*           RECFM(VBA) DIR(500) BLKSIZE(0) SPACE CYL(100,100)       */\n/*                                                                   */\n/*           By default all jobs in the spool with an owner that     */\n/*           is the same as your userid are processed.               */\n/*                                                                   */\n/*           If using an existing output PDS and there is already    */\n/*           a $$$INDEX member, any new JOBIDs will be merged into   */\n/*           the existing $$$INDEX member. If existing JOBIDs        */\n/*           are printed again, the duplicate information is         */\n/*           discarded.                                              */\n/*                                                                   */\n/*           If you want to edit the $$$INDEX member for any         */\n/*           reason, you must ensure the job information starts      */\n/*           on line 5 or it will break the index merge code.        */\n/*                                                                   */\n/*********************************************************************/\n/* EXECUTION SYNTAX:                                                 */\n/*                                                                   */\n/*   SDSFPRT owner_mask jobname_mask output_pds numcyl               */\n/*                                                                   */\n/*   owern_mask   = Jobname ownwer mask (default is your userid)     */\n/*   jobname_mask = Jobname prefix mask (default is \"*\" - all jobs)  */\n/*   output_pds   = output PDS data set name                         */\n/*   numcyl       = mumber of primary and secondary cylinders        */\n/*                  to allocate if the PDS doesn't exist             */\n/*                                                                   */\n/*   No parms are required but in order to use the 2nd parm,         */\n/*   the first one must be specified.  In order to use the 3rd       */\n/*   parm, the first and second ones must be specified, in           */\n/*   order to use the 4th parm, the first, second and 3rd            */\n/*   parms must all be specified.                                    */\n/*                                                                   */\n/*                                                                   */\n/* DEFAULTS (no parms but the exec name)                             */\n/*   SDSFPRT userid * userid.print 100                               */\n/*                                                                   */\n/* EXAMPLES:                                                         */\n/*                                                                   */\n/*  %SDSFPRT                                                         */\n/*   (O/P to \"USERID.PRINT\", select all jobs with owner=userid       */\n/*                                                                   */\n/*  %SDSFPRT USERA*                                                  */\n/*   (O/P to \"USERID.PRINT\", select all jobs with owner=USERA*       */\n/*                                                                   */\n/*  %SDSFPRT * JOBNM*                                                */\n/*   (O/P to \"USERID.PRINT\", select \"JOBNM*\" jobs,  all owners       */\n/*                                                                   */\n/*  %SDSFPRT USERB INST*                                             */\n/*   (O/P to \"USERID.PRINT\", select INST* jobs with owner=USERB      */\n/*                                                                   */\n/*  %SDSFPRT * JOBNM*  USERID.PRINT.PDS                              */\n/*   (O/P to \"USERID.PRINT.PDS\", select \"JOBNM*\", all owners         */\n/*                                                                   */\n/*  %SDSFPRT * MYJOBS* USERID.PRINT.PDS 300                          */\n/*   (O/P to \"USERID.PRINT.PDS\", select \"MYJOBS*\", CYL(300,300) )    */\n/*                                                                   */\n/*                                                                   */\n/* Sample JCL to execute in batch:                                   */\n/*                                                                   */\n/* //MYJOB JOB (ACCT),CLASS=A,...                                    */\n/* //S1 EXEC PGM=IKJEFT01                                            */\n/* //SYSEXEC  DD DSN=pds.with.this.exec,DISP=SHR                     */\n/* //SYSTSPRT DD SYSOUT=*                                            */\n/* //SYSTSIN  DD *                                                   */\n/*  %SDSFPRT OWNER* JOBNM* USERID.PRINT.PDS 300                      */\n/* /*                                                              */*/\n/*                                                                   */\n/*********************************************************************/\n/*  Sample output found in the $$$INDEX MEMBER:                      */\n/*    (start/end times and dates columns not shown in the sample)    */\n/*                                                                   */\n/*  The following jobs were successfully processed:                  */\n/*                                                                   */\n/*    JOBNAME    MEMBER     MAXRC     OWNER     PROGRAMMER NAME      */\n/*    --------  --------  ----------  --------  -------------------- */\n/*    MZELDENT  JOB05067  CC 0012     MZELDEN   MARK ZELDEN          */\n/*    MZELDENR  JOB05226  CC 0000     MZELDEN   MARK ZELDEN          */\n/*    MZELDENT  JOB05229  CANCELED    MZELDEN   MARK ZELDEN          */\n/*    MZELDENB  JOB05434  CC 0004     MZELDEN   MARK ZELDEN          */\n/*    REORG     JOB05521  CC 0000     MZELDEN   MARK ZELDEN          */\n/*    COPYFILE  JOB05607  CC 0000     MZELDEN   MARK ZELDEN          */\n/*    MZELDENQ  JOB05634  CC 0000     MZELDEN   MARK ZELDEN          */\n/*                                                                   */\n/*********************************************************************/\n/* Updates:                                                          */\n/*                                                                   */\n/* 05/06/2020: Created exec, modified from \"SDSF@DR\"                 */\n/*                                                                   */\n/*********************************************************************/\n\nArg isfowner isfprefix outdsn numcyl .\n/**********************************************/\n/* House keeping                              */\n/**********************************************/\nuid          = sysvar('SYSUID')                /* tso userid         */\nIf isfowner  = '' then isfowner  = uid         /* onwer jobs to sel  */\nIf isfprefix = '' then isfprefix = '*'         /* job names to sel   */\nIf outdsn    = '' then outdsn = uid ||.PRINT   /* output dsn         */\nIf numcyl    = '' then numcyl = '100'          /* dflt space in cyl  */\nexisting_idx = 0 /* flag for existing $$$INDEX member (0=false)      */\ntot_failed   = 0 /* total # of jobs that failed and can't be printed */\n\n/*********************************************************************/\n/* Make sure output dsn exists and is a PDS                          */\n/*********************************************************************/\njunk = outtrap('on')\n\"LISTD '\" || outdsn || \"'\"\njunk = outtrap('off')\nIf rc <> 0 then do\n  Say 'Output dataset ''' || outdsn || '''  not found. Allocating...'\n  Say '   '\n  \"ALLOC FI($$$OUTFL) DA('\" || outdsn || \"') NEW REUSE\"  ,\n  \"UNIT(SYSALLDA) CYL SPACE(\"NUMCYL\",\"NUMCYL\") DIR(500)\" ,\n  \"LRECL(255) RECFM(V B A) BLKSIZE(0)\"\n  \"FREE FI($$$OUTFL)\"\nEnd\nElse do\n Say 'Existing output dataset ''' || outdsn || '''  will be used.'\n junk = outtrap('MBR.')                /* capture output to MBR. stem */\n \"LISTD '\" || outdsn || \"' MEMBERS\"    /* issue LISTD cmd against PDS */\n junk = outtrap('off')                 /* stop capturing output       */\n/*********************************************************************/\n/* Ensure output dataset is partiioned.                              */\n/*********************************************************************/\n If MBR.0 = 5 then do                  /* no members in PDS           */\n   Say 'ERROR -' outdsn 'is not a PDS!' /* issue error msg            */\n   Exit 12                             /* exit RC=12                  */\n End\n/*********************************************************************/\n/* Check for existing $$$INDEX member and if it exists read          */\n/* member information into stem variables.                           */\n/*********************************************************************/\n Do I = 1 to MBR.0                     /* loop to get past vol info   */\n   If MBR.I = \"--MEMBERS--\" then leave /* if member section, exit loop*/\n End\n Do J = I+1 to MBR.0                   /* loop to execute edit macro  */\n   Parse var MBR.J IDXMEM .            /* get rid of alias info       */\n   If Substr(idxmem,1,8) == '$$$INDEX' then do  /* check IDX numbers  */\n     /*****************************************/\n     /* $$$INDEX exists, save existing info   */\n     /*****************************************/\n     existing_idx = 1 /* flag for existing $$$INDEX member (1=true)   */\n     \"ALLOC FI($$$INDEX) DA('\" || outdsn || \"($$$INDEX)') SHR REUSE\"\n     \"EXECIO * DISKR $$$INDEX (STEM CURIDX. FINIS\"\n   End\n End /* end do J */\n Say ' '\nEnd\n/**********************************************/\n/* Start of main code                         */\n/**********************************************/\nSay 'SDSFPRT processing parameters used for this run:'\nSay '    Output dataset =' outdsn\nIf isfowner  = '*' then ,\n  Say '    Owner to process = ''*'' (all owners will be processed)'\nElse ,\n  Say '    Owner to process =' isfowner\nIf isfprefix = '*' then ,\n  Say '    Jobs to process = ''*'' (all jobs will be processed)'\nElse ,\n  Say '    Jobs to process =' isfprefix\nIf existing_idx = 1 then ,\n  Say '    Index member $$$INDEX already exists and new data' ,\n      'will be merged.'\nSay '               '      /* blank line to make more readable */\n\nrc=isfcalls('ON')\n/*************************/\n/* Access the ST display */\n/*************************/\n /* isfsort = 'JNAME A JOBID A' */ /* sort/process in jobname order */\nisfsort   = 'JOBID A'              /* sort/process in jobid   order */\nAddress SDSF \"ISFEXEC ST (DELAYED)\"             /* ST command       */\nDrop jname.      /* get rid of results from first time              */\nAddress SDSF \"ISFEXEC ST (DELAYED)\"            /* may not catch the */\n                 /* batch job running this if not issued a 2nd time */\nlrc=rc\ncall msgrtn\nif lrc<>0 then exit 20\n/**********************************************************/\n/* 1st loop to display all jobs returned via \"ST\" command */\n/**********************************************************/\nSay 'The following' jname.0 'jobs were returned from the \"ST\"' ,\n    'command and will be processed:'\ndo dis_jobs=1 to jname.0\n    Say '   ' Left(jname.dis_jobs,8) ' ' jobid.dis_jobs\nend\nSay ' '\nSay ' '\nSay ' '\n/**********************************************************/\n/* 2nd loop to print all jobs returned via \"ST\" command   */\n/**********************************************************/\n\"ALLOC FI($$$INDEX) DA('\" || outdsn || \"($$$INDEX)') SHR REUSE\"\nqueue ' The following jobs from the ST command were' ,\n      'successfully processed:'\nqueue ' '\nqueue '  JOBNAME    MEMBER     MAXRC ' ,\n      '   OWNER     PROGRAMMER NAME     ' ,\n      ' STRTTIME  STRTDATE  END TIME  END DATE'\nqueue '  --------  --------  ----------' ,\n      ' --------  --------------------' ,\n      ' --------  --------  --------  --------'\nSay 'Processing jobs ...'\nSay ' '\ngoodct = 0 /* initialize counter for index records to write */\ndo ix=1 to jname.0\n    call Setup_print_vars\n\n    Say 'Attempting to print output to DSN=' || ,\n      Strip(Translate(isfprtdsname,\"\",\"'\"))  || , /* remove quotes */\n       \"(\"jobid.ix\") - JOBNAME\" jname.ix\n\n      /******************************************/\n      /* Issue the XDC action against the job   */\n      /******************************************/\n      Address SDSF \"ISFACT ST TOKEN('\"TOKEN.ix\"') PARM(NP XDC)\"\n      lrc=rc\n      call msgrtn\n      if lrc = 0 then do\n        goodct = goodct+1\n        if Substr(timee.ix,2,1) = ':' then ,\n          timee.ix = ' ' || timee.ix\n        if Substr(timen.ix,2,1) = ':' then ,\n          timen.ix = ' ' || timen.ix\n        timen.ix = Substr(timen.ix,1,8)\n        /******************************************/\n        /* queue the index line to the data stack */\n        /******************************************/\n        thisidx.goodct = ' ' Left(jname.ix,8) '' Left(jobid.ix,8) ,\n         '' Left(retcode.ix,10) '' Left(ownerid.ix,8) ,\n         '' Left(pname.ix,20) ,\n         '' Left(timee.ix,8) '' datee.ix ,\n         '' Left(timen.ix,8) '' daten.ix\n      end\n  /*  if lrc<>0 then exit 20 */\n\nend  /* end do ix=1 */\n\n/**********************************************************/\n/* No $$$INDEX exists, queue index info before writing it */\n/**********************************************************/\nIf existing_idx = 0 then do\n  Do ix2=1 to goodct      /* index records from this run */\n    queue thisidx.ix2     /* index stem var              */\n  End\nEnd\n/**********************************************************/\n/* IF $$$INDEX exists, merge new info into new stem,      */\n/*   bubble sort by JOBID and delete any duplicates.      */\n/**********************************************************/\nElse do  /* $$$INDEX already exists */\n  mrgct  = 0           /* initialize counter of total records merged */\n  Do ix2=1 to goodct                  /* index records from this run */\n    mrgct = mrgct + 1                 /* bump up counter             */\n    mrgidx.mrgct = thisidx.ix2        /* merged index stem var       */\n  End\n  Do ix3 = 5 to curidx.0   /* start at record 5 of existing $$$INDEX */\n    mrgct = mrgct + 1                 /* bump up counter             */\n    mrgidx.mrgct = curidx.ix3         /* merged index stem var       */\n  End\n  /**********************************************************/\n  /* bubble sort by the JOBID                               */\n  /**********************************************************/\n  sort_done = 0\n  sort_recs = mrgct\n  Do while sort_done = 0\n    sort_done = 1\n    Do bbl1 = 1 to sort_recs - 1\n      bbl2 = bbl1 + 1\n      /* JOBID is at column 13 for 8 characters */\n      If Substr(mrgidx.bbl1,13,8) > Substr(mrgidx.bbl2,13,8) then do\n        sort_done = 0\n        temp_sort = mrgidx.bbl2\n        mrgidx.bbl2 = mrgidx.bbl1\n        mrgidx.bbl1 = temp_sort\n      End /* if */\n    End /* do i=1 to sort_recs */\n    sort_recs = sort_recs - 1\n  End /* do while sort_done */\n  /**********************************************************/\n  /* Delete duplicate index information                     */\n  /**********************************************************/\n  currln = 1       /* initialize counter */\n  Do while currln < mrgct + 1\n    data1   = Substr(mrgidx.currln,13,8)\n    nextln  = currln + 1\n    data2 = Substr(mrgidx.nextln,13,8)\n    If data1 == data2 then currln = currln + 1\n    Else do\n      queue mrgidx.currln\n      currln = currln + 1\n    End\n  End   /* do while */\nEnd /* else do - $$$INDEX exists */\n/**********************************************************/\n/* Write $$$INDEX member and free $$$INDEX DD             */\n/**********************************************************/\nqueue ''  /* end data stack with a null */\n\"EXECIO * DISKW $$$INDEX (FINIS\"\n\"FREE FI($$$INDEX)\"\n\nrc=isfcalls('OFF')\n\nSay ' '\nSay ' '\nSay ' '\nSay '***********************************'\nSay ' Program totals'\nSay ' '\nSay ' Total JOBs processed =' jname.0\nSay ' Total JOBs printed   =' jname.0 - tot_failed\nSay ' Total JOBs failed    =' tot_failed\nSay '***********************************'\n\nexit 0\n/**********************************************/\n/* End of main code                           */\n/**********************************************/\n\n\n/*============================================*/\n/* S U B R O U T I N E S                      */\n/*============================================*/\n/*************************************/\n/* Subroutine to list error messages */\n/*************************************/\nmsgrtn: procedure expose isfmsg isfmsg2. tot_failed jname. jobid. ix\n\n  /************************************************/\n  /* The isfmsg variable contains a short message */\n  /************************************************/\n  if isfmsg = '' |  Strip(isfmsg) = 'PRINT CLOSED' ,\n          | Strip(isfmsg) = '*BOTTOM OF DATA REACHED*' ,\n    then nop  /* normal messages from print */\n  else do\n    Say '  ** Error processing' jname.ix jobid.ix\n    Say '  **' isfmsg\n\n    tot_failed = tot_failed + 1 /* add 1 to failed total */\n       /****************************************************/\n       /* The isfmsg2 stem contains additional descriptive */\n       /* error messages                                   */\n       /****************************************************/\n   /* do ix=1 to isfmsg2.0\n        Say \"isfmsg2.\"ix \"is:\" isfmsg2.ix\n      end */\n\n  end\nreturn\n\n/**********************************************************************/\n/* Setup required vars for printing                                   */\n/**********************************************************************/\nSetup_print_vars:\nisfprtdisp     = 'SHR'\nisfprtdsname   = \"'\" || outdsn || \"'\"\nisfprtmember   = jobid.ix\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SMPBLD1": {"ttr": 15371, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x06\\x01\\x01\\x03?\\x01\\x01\\x03?\\x14\\x10\\x01U\\x01U\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf3\\xf3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-02-02T00:00:00", "modifydate": "2001-02-02T14:10:06", "lines": 341, "newlines": 341, "modlines": 0, "user": "CBT433"}, "text": "//TSGMXZ1S JOB (AD00),'#04D42 ZELDEN',\n//             NOTIFY=&SYSUID,\n//             CLASS=M,MSGCLASS=H,MSGLEVEL=(1,1)\n//*\n//********************************************************************\n//* THIS JOB WILL ALLOCATE SMP/E DATASETS, DEFINE AND INITIALIZE\n//* THE CSI, AND THEN DEFINE GLOBAL, TARGET, AND DLIB\n//* ZONES WITHIN THE SAME PHYSICAL VSAM DATA SET.\n//********************************************************************\n//*  GLOBAL CHANGE XXXXXXXX TO BE THE HIGH LEVEL INDEX OF SMP DATASETS\n//*  GLOBAL CHANGE SMPVOL  TO BE THE SMP DATASET DASD VOLUME\n//*  GLOBAL CHANGE Z038    TO BE THE SMP SREL YOU WANT IN THE OPTIONS\n//*  GLOBAL CHANGE TARGET1 TO BE THE TARGET ZONE NAME YOU DESIRE\n//*  GLOBAL CHANGE DLIB1   TO BE THE DLIB   ZONE NAME YOU DESIRE\n//*  GLOBAL CHANGE OPTMVS  TO BE THE OPTIONS NAME YOU DESIRE\n//*\n//* NOTE: AFTER CHANGES BE SURE TO CHECK \"DSPREFIX\" IN GLOBAL\n//*       ZONE OPTIONS - IT CAN ONLY BE MAX OF 26 CHAR.\n//********************************************************************\n//ALLOC   EXEC PGM=IEFBR14\n//SMPSCDS   DD DSN=XXXXXXXX.SMPSCDS,\n//             DISP=(,CATLG,DELETE),\n//             SPACE=(TRK,(10,5,50)),UNIT=SYSALLDA,\n//             VOL=SER=SMPVOL,\n//             DCB=(LRECL=80,BLKSIZE=6080,RECFM=FB)\n//*SMPLTS    DD DSN=XXXXXXXX.SMPLTS,\n//*             DISP=(,CATLG,DELETE),\n//*             SPACE=(TRK,(5,5,10)),UNIT=SYSALLDA,\n//*             VOL=SER=SMPVOL,\n//*             DCB=(BLKSIZE=6233,RECFM=U)\n//SMPMTS    DD DSN=XXXXXXXX.SMPMTS,\n//             DISP=(,CATLG,DELETE),\n//             SPACE=(TRK,(5,5,10)),UNIT=SYSALLDA,\n//             VOL=SER=SMPVOL,\n//             DCB=(LRECL=80,BLKSIZE=6080,RECFM=FB)\n//SMPSTS    DD DSN=XXXXXXXX.SMPSTS,\n//             DISP=(,CATLG,DELETE),\n//             SPACE=(TRK,(5,5,10)),UNIT=SYSALLDA,\n//             VOL=SER=SMPVOL,\n//             DCB=(LRECL=80,BLKSIZE=6080,RECFM=FB)\n//SMPPTS    DD DSN=XXXXXXXX.SMPPTS,\n//             DISP=(,CATLG,DELETE),\n//             SPACE=(TRK,(30,5,50)),UNIT=SYSALLDA,\n//             VOL=SER=SMPVOL,\n//             DCB=(LRECL=80,BLKSIZE=6080,RECFM=FB)\n//SMPLOG    DD DSN=XXXXXXXX.SMPLOG,\n//             DISP=(,CATLG,DELETE),\n//             SPACE=(TRK,(30,5)),UNIT=SYSALLDA,\n//             VOL=SER=SMPVOL,\n//             DCB=(BLKSIZE=3200,LRECL=260,RECFM=VB)\n//SMPLOGA   DD DSN=XXXXXXXX.SMPLOGA,\n//             DISP=(,CATLG,DELETE),\n//             SPACE=(TRK,(1,5)),UNIT=SYSALLDA,\n//             VOL=SER=SMPVOL,\n//             DCB=(BLKSIZE=3200,LRECL=260,RECFM=VB)\n//DEFCSI  EXEC PGM=IDCAMS,REGION=1024K\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  *\n  DEFINE CLUSTER(+\n                  NAME(XXXXXXXX.SMPCSI.CSI) +\n                  FREESPACE(10,5) +\n                  KEYS(24 0) +\n                  RECORDSIZE(24 143) +\n                  BUFSP(20480) +\n                  SHR(2) +\n                  VOLUME(SMPVOL) +\n                ) +\n           DATA(   +\n                  NAME(XXXXXXXX.SMPCSI.CSI.DATA) +\n                  CYLINDERS(5 1) +\n                  CISZ(4096) +\n               ) +\n           INDEX(  +\n                  NAME(XXXXXXXX.SMPCSI.CSI.INDEX) +\n                  TRACKS(2 1)  +\n                )\n/*\n//INITCSI EXEC PGM=IDCAMS,REGION=1024K\n//ZPOOL    DD  DISP=SHR,\n//             DSN=SYS1.MACLIB(GIMZPOOL)\n//SMPCSI   DD  UNIT=SYSALLDA,\n//             DSN=XXXXXXXX.SMPCSI.CSI,DISP=SHR\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  *\n    REPRO INFILE(ZPOOL) +\n          OUTFILE(SMPCSI)\n/*\n//BLDCSI  EXEC PGM=GIMSMP,REGION=4096K,PARM='DATE=U'\n//SMPOUT   DD SYSOUT=*\n//SMPRPT   DD SYSOUT=*\n//SMPLIST  DD SYSOUT=*\n//SMPSNAP  DD SYSOUT=*\n//SMPPUNCH DD DUMMY\n//SYSPRINT DD SYSOUT=*\n//*-------------------------------------------------------------------\n//*   SMP DATASETS\n//*-------------------------------------------------------------------\n//SMPPTS   DD DISP=OLD,DSN=XXXXXXXX.SMPPTS\n//SMPMTS   DD DISP=OLD,DSN=XXXXXXXX.SMPMTS\n//SMPSTS   DD DISP=OLD,DSN=XXXXXXXX.SMPSTS\n//SMPSCDS  DD DISP=OLD,DSN=XXXXXXXX.SMPSCDS\n//*SMPLOG   DD DISP=MOD,DSN=XXXXXXXX.SMPLOG\n//SMPLOG   DD SYSOUT=*\n//SMPCSI   DD DISP=SHR,DSN=XXXXXXXX.SMPCSI.CSI\n//TARGET1  DD DISP=SHR,DSN=XXXXXXXX.SMPCSI.CSI\n//DLIB1    DD DISP=SHR,DSN=XXXXXXXX.SMPCSI.CSI\n//SMPWRK1  DD UNIT=SYSALLDA,SPACE=(CYL,(2,1,5)),\n//            DCB=BLKSIZE=3120,DISP=(,DELETE)\n//SMPWRK2  DD UNIT=SYSALLDA,SPACE=(CYL,(2,1,5)),\n//            DCB=BLKSIZE=3120,DISP=(,DELETE)\n//SMPWRK3  DD UNIT=SYSALLDA,SPACE=(CYL,(2,1,5)),\n//            DCB=BLKSIZE=3120,DISP=(,DELETE)\n//SMPWRK4  DD UNIT=SYSALLDA,SPACE=(CYL,(2,1,5)),\n//            DCB=BLKSIZE=3120,DISP=(,DELETE)\n//*SMPWRK5  DD UNIT=SYSALLDA,SPACE=(CYL,(2,1,5)),\n//*            DCB=BLKSIZE=7294,DISP=(,DELETE)\n//SMPWRK6  DD UNIT=SYSALLDA,SPACE=(CYL,(2,1,5)),\n//            DCB=BLKSIZE=3120,DISP=(,DELETE)\n//SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(2,1)),DISP=(,DELETE)\n//SYSUT2   DD UNIT=SYSALLDA,SPACE=(CYL,(2,1)),DISP=(,DELETE)\n//SYSUT3   DD UNIT=SYSALLDA,SPACE=(CYL,(2,1)),DISP=(,DELETE)\n//SYSUT4   DD UNIT=SYSALLDA,SPACE=(TRK,(2,1)),DISP=(,DELETE)\n//SMPTLIB  DD UNIT=SYSALLDA,VOL=SER=SMPVOL,DISP=OLD\n//SYSLIB   DD DISP=SHR,DCB=(BLKSIZE=19040),\n//            DSN=XXXXXXXX.SMPMTS\n//         DD DISP=SHR,DSN=SYS1.MACLIB\n//SMPCNTL  DD *\n SET BDY(GLOBAL).\n UCLIN.\n   ADD GLOBALZONE\n        SREL(Z038)\n        OPTIONS(OPTMVS)\n        ZONEINDEX(\n            (TARGET1,XXXXXXXX.SMPCSI.CSI,TARGET),\n            (DLIB1,XXXXXXXX.SMPCSI.CSI,DLIB)\n                 ).\n   ADD OPTIONS(OPTMVS)\n        DSSPACE(150,60,150)\n        DSPREFIX(XXXXXXXX.RELFILE)\n        RETRYDDN(ALL)\n        LKED(IEWL)\n        NUCID(1)\n        PEMAX(9999).\n  ADD UTILITY(IEWL)\n         NAME(IEWL)\n         PARM(LET,LIST,XREF,NCAL).\n  ADD DDDEF(SMPPTS) SHR\n      DA(XXXXXXXX.SMPPTS) .\n  ADD DDDEF(SMPTLIB)\n      UNIT(SYSALLDA) VOLUME(SMPVOL) .\n /* ADD     DDDEF(SMPLOG)\n            SYSOUT(*) .\n    ADD     DDDEF(SMPLOGA)\n            SYSOUT(*) .  */\n ADD DDDEF(SMPLOG) MOD\n         UNIT(SYSALLDA) VOLUME(SMPVOL)\n         DA(XXXXXXXX.SMPLOG).\n ADD DDDEF(SMPLOGA) MOD\n         UNIT(SYSALLDA) VOLUME(SMPVOL)\n         DA(XXXXXXXX.SMPLOGA).\n ADD     DDDEF(SMPOUT)\n         SYSOUT(*) .\n ADD     DDDEF(SMPLIST)\n         SYSOUT(*) .\n ADD     DDDEF(SMPRPT)\n         SYSOUT(*) .\n ADD     DDDEF(SMPSNAP)\n         SYSOUT(*) .\n ADD     DDDEF(SMPDEBUG)\n         SYSOUT(*) .\n ADD     DDDEF(SMPPUNCH)\n         SYSOUT(B) .\n ADD     DDDEF(SYSPRINT)\n         SYSOUT(*) .\n ADD     DDDEF(SYSUDUMP)\n         SYSOUT(*) .\n ADD     DDDEF(SYSUT1) BLK(3120) SPACE(384,760)\n         UNIT(SYSALLDA).\n ADD     DDDEF(SYSUT2) BLK(3120) SPACE(384,760)\n         UNIT(SYSALLDA).\n ADD     DDDEF(SYSUT3) BLK(3120) SPACE(384,760)\n         UNIT(SYSALLDA).\n ADD     DDDEF(SYSUT4) BLK(3120) SPACE(384,760)\n         UNIT(SYSALLDA).\n ADD     DDDEF(SYSPUNCH) BLK(3120) SPACE(380,380) DIR(64)\n         UNIT(SYSALLDA) .\n ENDUCL.\n SET BDY(TARGET1).\n UCLIN.\n    ADD TARGETZONE(TARGET1)\n         SREL(Z038)\n         OPTIONS(OPTMVS)\n         RELATED(DLIB1).\n  ADD DDDEF(SMPPTS) SHR\n      DA(XXXXXXXX.SMPPTS) .\n /*  ADD DDDEF(SMPLTS)\n      SHR UNIT(SYSALLDA) VOLUME(SMPVOL)\n      DA(XXXXXXXX.SMPLTS) . */\n  ADD DDDEF(SMPMTS)\n      SHR UNIT(SYSALLDA) VOLUME(SMPVOL)\n      DA(XXXXXXXX.SMPMTS) .\n  ADD DDDEF(SMPSTS)\n      SHR UNIT(SYSALLDA) VOLUME(SMPVOL)\n      DA(XXXXXXXX.SMPSTS) .\n  ADD DDDEF(SMPSCDS)\n      SHR UNIT(SYSALLDA) VOLUME(SMPVOL)\n      DA(XXXXXXXX.SMPSCDS) .\n  ADD DDDEF(SMPTLIB)\n      UNIT(SYSALLDA) VOLUME(SMPVOL) .\n  ADD DDDEF(SYSLIB)\n      CONCAT(\n             SMPMTS\n                ) .\n /* ADD     DDDEF(SMPLOG)\n            SYSOUT(*) .\n    ADD     DDDEF(SMPLOGA)\n            SYSOUT(*) .  */\n ADD DDDEF(SMPLOG) MOD\n         UNIT(SYSALLDA) VOLUME(SMPVOL)\n         DA(XXXXXXXX.SMPLOG).\n ADD DDDEF(SMPLOGA) MOD\n         UNIT(SYSALLDA) VOLUME(SMPVOL)\n         DA(XXXXXXXX.SMPLOGA).\n ADD     DDDEF(SMPOUT)\n         SYSOUT(*) .\n ADD     DDDEF(SMPLIST)\n         SYSOUT(*) .\n ADD     DDDEF(SMPRPT)\n         SYSOUT(*) .\n ADD     DDDEF(SMPSNAP)\n         SYSOUT(*) .\n ADD     DDDEF(SMPDEBUG)\n         SYSOUT(*) .\n ADD     DDDEF(SMPPUNCH)\n         SYSOUT(B) .\n ADD     DDDEF(SYSPRINT)\n         SYSOUT(*) .\n ADD     DDDEF(SYSUDUMP)\n         SYSOUT(*) .\n ADD     DDDEF(SMPWRK1) BLK(3120) SPACE(384,380) DIR(111) NEW DELETE\n         UNIT(SYSALLDA).\n ADD     DDDEF(SMPWRK2) BLK(3120) SPACE(384,380) DIR(111) NEW DELETE\n         UNIT(SYSALLDA).\n ADD     DDDEF(SMPWRK3) BLK(3120) SPACE(384,380) DIR(111) NEW DELETE\n         UNIT(SYSALLDA).\n ADD     DDDEF(SMPWRK4) BLK(3120) SPACE(384,380) DIR(111) NEW DELETE\n         UNIT(SYSALLDA).\n /*ADD   DDDEF(SMPWRK5) BLK(7294) SPACE(384,380) DIR(111) NEW DELETE\n         UNIT(SYSALLDA).  */\n ADD     DDDEF(SMPWRK6) BLK(3120) SPACE(384,380) DIR(111) NEW DELETE\n         UNIT(SYSALLDA).\n ADD     DDDEF(SYSUT1) BLK(3120) SPACE(384,760)\n         UNIT(SYSALLDA).\n ADD     DDDEF(SYSUT2) BLK(3120) SPACE(384,760)\n         UNIT(SYSALLDA).\n ADD     DDDEF(SYSUT3) BLK(3120) SPACE(384,760)\n         UNIT(SYSALLDA).\n ADD     DDDEF(SYSUT4) BLK(3120) SPACE(384,760)\n         UNIT(SYSALLDA).\n ADD     DDDEF(SYSPUNCH) BLK(3120) SPACE(380,380) DIR(64)\n         UNIT(SYSALLDA) .\n ENDUCL.\n SET BDY(DLIB1).\n UCLIN.\n    ADD DLIBZONE(DLIB1)\n         ACCJCLIN\n         SREL(Z038)\n         OPTIONS(OPTMVS)\n         RELATED(TARGET1).\n  ADD DDDEF(SMPPTS) SHR\n      DA(XXXXXXXX.SMPPTS) .\n /*  ADD DDDEF(SMPLTS)\n      SHR UNIT(SYSALLDA) VOLUME(SMPVOL)\n      DA(XXXXXXXX.SMPLTS) . */\n  ADD DDDEF(SMPMTS)\n      SHR UNIT(SYSALLDA) VOLUME(SMPVOL)\n      DA(XXXXXXXX.SMPMTS) .\n  ADD DDDEF(SMPSTS)\n      SHR UNIT(SYSALLDA) VOLUME(SMPVOL)\n      DA(XXXXXXXX.SMPSTS) .\n  ADD DDDEF(SMPSCDS)\n      SHR UNIT(SYSALLDA) VOLUME(SMPVOL)\n      DA(XXXXXXXX.SMPSCDS) .\n  ADD DDDEF(SMPTLIB)\n      UNIT(SYSALLDA) VOLUME(SMPVOL) .\n  ADD DDDEF(SYSLIB)\n      CONCAT(\n             SMPMTS\n                ) .\n /* ADD     DDDEF(SMPLOG)\n            SYSOUT(*) .\n    ADD     DDDEF(SMPLOGA)\n            SYSOUT(*) .  */\n ADD DDDEF(SMPLOG) MOD\n         UNIT(SYSALLDA) VOLUME(SMPVOL)\n         DA(XXXXXXXX.SMPLOG).\n ADD DDDEF(SMPLOGA) MOD\n         UNIT(SYSALLDA) VOLUME(SMPVOL)\n         DA(XXXXXXXX.SMPLOGA).\n ADD     DDDEF(SMPOUT)\n         SYSOUT(*) .\n ADD     DDDEF(SMPLIST)\n         SYSOUT(*) .\n ADD     DDDEF(SMPRPT)\n         SYSOUT(*) .\n ADD     DDDEF(SMPSNAP)\n         SYSOUT(*) .\n ADD     DDDEF(SMPDEBUG)\n         SYSOUT(*) .\n ADD     DDDEF(SMPPUNCH)\n         SYSOUT(B) .\n ADD     DDDEF(SYSPRINT)\n         SYSOUT(*) .\n ADD     DDDEF(SYSUDUMP)\n         SYSOUT(*) .\n ADD     DDDEF(SMPWRK1) BLK(3120) SPACE(384,380) DIR(111) NEW DELETE\n         UNIT(SYSALLDA).\n ADD     DDDEF(SMPWRK2) BLK(3120) SPACE(384,380) DIR(111) NEW DELETE\n         UNIT(SYSALLDA).\n ADD     DDDEF(SMPWRK3) BLK(3120) SPACE(384,380) DIR(111) NEW DELETE\n         UNIT(SYSALLDA).\n ADD     DDDEF(SMPWRK4) BLK(3120) SPACE(384,380) DIR(111) NEW DELETE\n         UNIT(SYSALLDA).\n /*ADD   DDDEF(SMPWRK5) BLK(7294) SPACE(384,380) DIR(111) NEW DELETE\n         UNIT(SYSALLDA).  */\n ADD     DDDEF(SMPWRK6) BLK(3120) SPACE(384,380) DIR(111) NEW DELETE\n         UNIT(SYSALLDA).\n ADD     DDDEF(SYSUT1) BLK(3120) SPACE(384,760)\n         UNIT(SYSALLDA).\n ADD     DDDEF(SYSUT2) BLK(3120) SPACE(384,760)\n         UNIT(SYSALLDA).\n ADD     DDDEF(SYSUT3) BLK(3120) SPACE(384,760)\n         UNIT(SYSALLDA).\n ADD     DDDEF(SYSUT4) BLK(3120) SPACE(384,760)\n         UNIT(SYSALLDA).\n ADD     DDDEF(SYSPUNCH) BLK(3120) SPACE(380,380) DIR(64)\n         UNIT(SYSALLDA) .\n ENDUCL.\n SET BDY(GLOBAL).\n LIST ALLZONES.\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SMPBLD2": {"ttr": 15621, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x01\\x03?\\x01\\x01\\x03?\\x14\\x10\\x01\\x98\\x01\\x98\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf3\\xf3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-02-02T00:00:00", "modifydate": "2001-02-02T14:10:20", "lines": 408, "newlines": 408, "modlines": 0, "user": "CBT433"}, "text": "//TSGMXZ1S JOB (AD00),'#04D42 ZELDEN',\n//             NOTIFY=&SYSUID,\n//             CLASS=M,MSGCLASS=H,MSGLEVEL=(1,1)\n//*\n//********************************************************************\n//* THIS JOB WILL ALLOCATE SMP/E DATASETS, DEFINE AND INITIALIZE\n//* THE CSI'S, AND THEN DEFINE GLOBAL, TARGET, AND DLIB\n//* ZONES AS SEPERATE VSAM DATA SETS.\n//********************************************************************\n//*  GLOBAL CHANGE XXXXXXXX TO BE THE HIGH LEVEL INDEX OF SMP DATASETS\n//*  GLOBAL CHANGE SMPVOL  TO BE THE SMP DATASET DASD VOLUME\n//*  GLOBAL CHANGE Z038    TO BE THE SMP SREL YOU WANT IN THE OPTIONS\n//*  GLOBAL CHANGE TARGET1 TO BE THE TARGET ZONE NAME YOU DESIRE\n//*  GLOBAL CHANGE DLIB1   TO BE THE DLIB   ZONE NAME YOU DESIRE\n//*  GLOBAL CHANGE OPTMVS  TO BE THE OPTIONS NAME YOU DESIRE\n//*\n//* NOTE: AFTER CHANGES BE SURE TO CHECK \"DSPREFIX\" IN GLOBAL\n//*       ZONE OPTIONS - IT CAN ONLY BE MAX OF 26 CHAR.\n//********************************************************************\n//ALLOC   EXEC PGM=IEFBR14\n//SMPSCDS   DD DSN=XXXXXXXX.SMPSCDS,\n//             DISP=(,CATLG,DELETE),\n//             SPACE=(TRK,(10,5,50)),UNIT=SYSALLDA,\n//             VOL=SER=SMPVOL,\n//             DCB=(LRECL=80,BLKSIZE=6080,RECFM=FB)\n//*SMPLTS    DD DSN=XXXXXXXX.SMPLTS,\n//*             DISP=(,CATLG,DELETE),\n//*             SPACE=(TRK,(5,5,10)),UNIT=SYSALLDA,\n//*             VOL=SER=SMPVOL,\n//*             DCB=(BLKSIZE=6233,RECFM=U)\n//SMPMTS    DD DSN=XXXXXXXX.SMPMTS,\n//             DISP=(,CATLG,DELETE),\n//             SPACE=(TRK,(5,5,10)),UNIT=SYSALLDA,\n//             VOL=SER=SMPVOL,\n//             DCB=(LRECL=80,BLKSIZE=6080,RECFM=FB)\n//SMPSTS    DD DSN=XXXXXXXX.SMPSTS,\n//             DISP=(,CATLG,DELETE),\n//             SPACE=(TRK,(5,5,10)),UNIT=SYSALLDA,\n//             VOL=SER=SMPVOL,\n//             DCB=(LRECL=80,BLKSIZE=6080,RECFM=FB)\n//SMPPTS    DD DSN=XXXXXXXX.SMPPTS,\n//             DISP=(,CATLG,DELETE),\n//             SPACE=(TRK,(30,5,50)),UNIT=SYSALLDA,\n//             VOL=SER=SMPVOL,\n//             DCB=(LRECL=80,BLKSIZE=6080,RECFM=FB)\n//SMPGLOG   DD DSN=XXXXXXXX.SMPGLOG,\n//             DISP=(,CATLG,DELETE),\n//             SPACE=(TRK,(5,5)),UNIT=SYSALLDA,\n//             VOL=SER=SMPVOL,\n//             DCB=(BLKSIZE=3200,LRECL=260,RECFM=VB)\n//SMPGLOGA  DD DSN=XXXXXXXX.SMPGLOGA,\n//             DISP=(,CATLG,DELETE),\n//             SPACE=(TRK,(1,5)),UNIT=SYSALLDA,\n//             VOL=SER=SMPVOL,\n//             DCB=(BLKSIZE=3200,LRECL=260,RECFM=VB)\n//SMPTLOG   DD DSN=XXXXXXXX.SMPTLOG,\n//             DISP=(,CATLG,DELETE),\n//             SPACE=(TRK,(30,5)),UNIT=SYSALLDA,\n//             VOL=SER=SMPVOL,\n//             DCB=(BLKSIZE=3200,LRECL=260,RECFM=VB)\n//SMPTLOGA  DD DSN=XXXXXXXX.SMPTLOGA,\n//             DISP=(,CATLG,DELETE),\n//             SPACE=(TRK,(1,5)),UNIT=SYSALLDA,\n//             VOL=SER=SMPVOL,\n//             DCB=(BLKSIZE=3200,LRECL=260,RECFM=VB)\n//SMPDLOG   DD DSN=XXXXXXXX.SMPDLOG,\n//             DISP=(,CATLG,DELETE),\n//             SPACE=(TRK,(30,5)),UNIT=SYSALLDA,\n//             VOL=SER=SMPVOL,\n//             DCB=(BLKSIZE=3200,LRECL=260,RECFM=VB)\n//SMPDLOGA  DD DSN=XXXXXXXX.SMPDLOGA,\n//             DISP=(,CATLG,DELETE),\n//             SPACE=(TRK,(1,5)),UNIT=SYSALLDA,\n//             VOL=SER=SMPVOL,\n//             DCB=(BLKSIZE=3200,LRECL=260,RECFM=VB)\n//DEFCSI  EXEC PGM=IDCAMS,REGION=1024K\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  *\n  DEFINE CLUSTER(+\n                  NAME(XXXXXXXX.GLOBAL.CSI) +\n                  FREESPACE(10,5) +\n                  KEYS(24 0) +\n                  RECORDSIZE(24 143) +\n                  BUFSP(20480) +\n                  SHR(2) +\n                  VOLUME(SMPVOL) +\n                ) +\n           DATA(   +\n                  NAME(XXXXXXXX.GLOBAL.CSI.DATA) +\n                  CYLINDERS(1 1) +\n                  CISZ(4096) +\n               ) +\n           INDEX(  +\n                  NAME(XXXXXXXX.GLOBAL.CSI.INDEX) +\n                  TRACKS(1 1)  +\n                  IMBED +\n                )\n  DEFINE CLUSTER(+\n                  NAME(XXXXXXXX.TARGET1.CSI) +\n                  FREESPACE(10,5) +\n                  KEYS(24 0) +\n                  RECORDSIZE(24 143) +\n                  BUFSP(20480) +\n                  SHR(2) +\n                  VOLUME(SMPVOL) +\n                ) +\n           DATA(   +\n                  NAME(XXXXXXXX.TARGET1.CSI.DATA) +\n                  CYLINDERS(4 1) +\n                  CISZ(4096) +\n               ) +\n           INDEX(  +\n                  NAME(XXXXXXXX.TARGET1.CSI.INDEX) +\n                  TRACKS(1 1)  +\n                  IMBED +\n                )\n  DEFINE CLUSTER(+\n                  NAME(XXXXXXXX.DLIB1.CSI) +\n                  FREESPACE(10,5) +\n                  KEYS(24 0) +\n                  RECORDSIZE(24 143) +\n                  BUFSP(20480) +\n                  SHR(2) +\n                  VOLUME(SMPVOL) +\n                ) +\n           DATA(   +\n                  NAME(XXXXXXXX.DLIB1.CSI.DATA) +\n                  CYLINDERS(3 1) +\n                  CISZ(4096) +\n               ) +\n           INDEX(  +\n                  NAME(XXXXXXXX.DLIB1.CSI.INDEX) +\n                  TRACKS(1 1)  +\n                  IMBED +\n                )\n/*\n//INITCSI EXEC PGM=IDCAMS,REGION=1024K\n//ZPOOL    DD  DISP=SHR,\n//             DSN=SYS1.MACLIB(GIMZPOOL)\n//SMPCSI   DD  UNIT=SYSALLDA,\n//             DSN=XXXXXXXX.GLOBAL.CSI,DISP=SHR\n//TARGET1  DD  UNIT=SYSALLDA,\n//             DSN=XXXXXXXX.TARGET1.CSI,DISP=SHR\n//DLIB1    DD  UNIT=SYSALLDA,\n//             DSN=XXXXXXXX.DLIB1.CSI,DISP=SHR\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  *\n    REPRO INFILE(ZPOOL) +\n          OUTFILE(SMPCSI)\n    REPRO INFILE(ZPOOL) +\n          OUTFILE(TARGET1)\n    REPRO INFILE(ZPOOL) +\n          OUTFILE(DLIB1)\n/*\n//BLDCSI  EXEC PGM=GIMSMP,REGION=4096K,PARM='DATE=U'\n//SMPOUT   DD SYSOUT=*\n//SMPRPT   DD SYSOUT=*\n//SMPLIST  DD SYSOUT=*\n//SMPSNAP  DD SYSOUT=*\n//SMPPUNCH DD DUMMY\n//SYSPRINT DD SYSOUT=*\n//*-------------------------------------------------------------------\n//*   SMP DATASETS\n//*-------------------------------------------------------------------\n//SMPPTS   DD DISP=OLD,DSN=XXXXXXXX.SMPPTS\n//SMPMTS   DD DISP=OLD,DSN=XXXXXXXX.SMPMTS\n//SMPSTS   DD DISP=OLD,DSN=XXXXXXXX.SMPSTS\n//SMPSCDS  DD DISP=OLD,DSN=XXXXXXXX.SMPSCDS\n//*SMPLOG   DD DISP=MOD,DSN=XXXXXXXX.SMPGLOG\n//SMPLOG   DD SYSOUT=*\n//SMPCSI   DD DISP=SHR,DSN=XXXXXXXX.GLOBAL.CSI\n//TARGET1  DD DISP=SHR,DSN=XXXXXXXX.TARGET1.CSI\n//DLIB1    DD DISP=SHR,DSN=XXXXXXXX.DLIB1.CSI\n//SMPWRK1  DD UNIT=SYSALLDA,SPACE=(CYL,(2,1,5)),\n//            DCB=BLKSIZE=3120,DISP=(,DELETE)\n//SMPWRK2  DD UNIT=SYSALLDA,SPACE=(CYL,(2,1,5)),\n//            DCB=BLKSIZE=3120,DISP=(,DELETE)\n//SMPWRK3  DD UNIT=SYSALLDA,SPACE=(CYL,(2,1,5)),\n//            DCB=BLKSIZE=3120,DISP=(,DELETE)\n//SMPWRK4  DD UNIT=SYSALLDA,SPACE=(CYL,(2,1,5)),\n//            DCB=BLKSIZE=3120,DISP=(,DELETE)\n//*SMPWRK5  DD UNIT=SYSALLDA,SPACE=(CYL,(2,1,5)),\n//*            DCB=BLKSIZE=7294,DISP=(,DELETE)\n//SMPWRK6  DD UNIT=SYSALLDA,SPACE=(CYL,(2,1,5)),\n//            DCB=BLKSIZE=3120,DISP=(,DELETE)\n//SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(2,1)),DISP=(,DELETE)\n//SYSUT2   DD UNIT=SYSALLDA,SPACE=(CYL,(2,1)),DISP=(,DELETE)\n//SYSUT3   DD UNIT=SYSALLDA,SPACE=(CYL,(2,1)),DISP=(,DELETE)\n//SYSUT4   DD UNIT=SYSALLDA,SPACE=(TRK,(2,1)),DISP=(,DELETE)\n//SMPTLIB  DD UNIT=SYSALLDA,VOL=SER=SMPVOL,DISP=OLD\n//SYSLIB   DD DISP=SHR,DCB=(BLKSIZE=19040),\n//            DSN=XXXXXXXX.SMPMTS\n//         DD DISP=SHR,DSN=SYS1.MACLIB\n//SMPCNTL  DD *\n SET BDY(GLOBAL).\n UCLIN.\n   ADD GLOBALZONE\n        SREL(Z038)\n        OPTIONS(OPTMVS)\n        ZONEINDEX(\n            (TARGET1,XXXXXXXX.TARGET1.CSI,TARGET),\n            (DLIB1,XXXXXXXX.DLIB1.CSI,DLIB)\n                 ).\n   ADD OPTIONS(OPTMVS)\n        DSSPACE(150,60,150)\n        DSPREFIX(XXXXXXXX.RELFILE)\n        RETRYDDN(ALL)\n        LKED(IEWL)\n        NUCID(1)\n        PEMAX(9999).\n  ADD UTILITY(IEWL)\n         NAME(IEWL)\n         PARM(LET,LIST,XREF,NCAL).\n  ADD DDDEF(SMPPTS) SHR\n      DA(XXXXXXXX.SMPPTS) .\n  ADD DDDEF(SMPTLIB)\n      UNIT(SYSALLDA) VOLUME(SMPVOL) .\n /* ADD     DDDEF(SMPLOG)\n            SYSOUT(*) .\n    ADD     DDDEF(SMPLOGA)\n            SYSOUT(*) .     */\n ADD DDDEF(SMPLOG) MOD\n      UNIT(SYSALLDA) VOLUME(SMPVOL)\n      DA(XXXXXXXX.SMPGLOG).\n ADD DDDEF(SMPLOGA) MOD\n      UNIT(SYSALLDA) VOLUME(SMPVOL)\n      DA(XXXXXXXX.SMPGLOGA).\n ADD     DDDEF(SMPOUT)\n         SYSOUT(*) .\n ADD     DDDEF(SMPLIST)\n         SYSOUT(*) .\n ADD     DDDEF(SMPRPT)\n         SYSOUT(*) .\n ADD     DDDEF(SMPSNAP)\n         SYSOUT(*) .\n ADD     DDDEF(SMPDEBUG)\n         SYSOUT(*) .\n ADD     DDDEF(SMPPUNCH)\n         SYSOUT(B) .\n ADD     DDDEF(SYSPRINT)\n         SYSOUT(*) .\n ADD     DDDEF(SYSUDUMP)\n         SYSOUT(*) .\n ADD     DDDEF(SYSUT1) BLK(3120) SPACE(384,760)\n         UNIT(SYSALLDA).\n ADD     DDDEF(SYSUT2) BLK(3120) SPACE(384,760)\n         UNIT(SYSALLDA).\n ADD     DDDEF(SYSUT3) BLK(3120) SPACE(384,760)\n         UNIT(SYSALLDA).\n ADD     DDDEF(SYSUT4) BLK(3120) SPACE(384,760)\n         UNIT(SYSALLDA).\n ADD     DDDEF(SYSPUNCH) BLK(3120) SPACE(380,380) DIR(64)\n         UNIT(SYSALLDA) .\n ENDUCL.\n SET BDY(TARGET1).\n UCLIN.\n    ADD TARGETZONE(TARGET1)\n         SREL(Z038)\n         OPTIONS(OPTMVS)\n         RELATED(DLIB1).\n  ADD DDDEF(SMPPTS) SHR\n      DA(XXXXXXXX.SMPPTS) .\n /*  ADD DDDEF(SMPLTS)\n      SHR UNIT(SYSALLDA) VOLUME(SMPVOL)\n      DA(XXXXXXXX.SMPLTS) . */\n  ADD DDDEF(SMPMTS)\n      SHR UNIT(SYSALLDA) VOLUME(SMPVOL)\n      DA(XXXXXXXX.SMPMTS) .\n  ADD DDDEF(SMPSTS)\n      SHR UNIT(SYSALLDA) VOLUME(SMPVOL)\n      DA(XXXXXXXX.SMPSTS) .\n  ADD DDDEF(SMPSCDS)\n      SHR UNIT(SYSALLDA) VOLUME(SMPVOL)\n      DA(XXXXXXXX.SMPSCDS) .\n  ADD DDDEF(SMPTLIB)\n      UNIT(SYSALLDA) VOLUME(SMPVOL) .\n  ADD DDDEF(SYSLIB)\n      CONCAT(\n             SMPMTS\n                ) .\n /* ADD     DDDEF(SMPLOG)\n            SYSOUT(*) .\n    ADD     DDDEF(SMPLOGA)\n            SYSOUT(*) . */\n ADD DDDEF(SMPLOG) MOD\n      UNIT(SYSALLDA) VOLUME(SMPVOL)\n      DA(XXXXXXXX.SMPTLOG).\n ADD DDDEF(SMPLOGA) MOD\n      UNIT(SYSALLDA) VOLUME(SMPVOL)\n      DA(XXXXXXXX.SMPTLOGA).\n ADD     DDDEF(SMPOUT)\n         SYSOUT(*) .\n ADD     DDDEF(SMPLIST)\n         SYSOUT(*) .\n ADD     DDDEF(SMPRPT)\n         SYSOUT(*) .\n ADD     DDDEF(SMPSNAP)\n         SYSOUT(*) .\n ADD     DDDEF(SMPDEBUG)\n         SYSOUT(*) .\n ADD     DDDEF(SMPPUNCH)\n         SYSOUT(B) .\n ADD     DDDEF(SYSPRINT)\n         SYSOUT(*) .\n ADD     DDDEF(SYSUDUMP)\n         SYSOUT(*) .\n ADD     DDDEF(SMPWRK1) BLK(3120) SPACE(384,380) DIR(111) NEW DELETE\n         UNIT(SYSALLDA).\n ADD     DDDEF(SMPWRK2) BLK(3120) SPACE(384,380) DIR(111) NEW DELETE\n         UNIT(SYSALLDA).\n ADD     DDDEF(SMPWRK3) BLK(3120) SPACE(384,380) DIR(111) NEW DELETE\n         UNIT(SYSALLDA).\n ADD     DDDEF(SMPWRK4) BLK(3120) SPACE(384,380) DIR(111) NEW DELETE\n         UNIT(SYSALLDA).\n /*ADD   DDDEF(SMPWRK5) BLK(7294) SPACE(384,380) DIR(111) NEW DELETE\n         UNIT(SYSALLDA).  */\n ADD     DDDEF(SMPWRK6) BLK(3120) SPACE(384,380) DIR(111) NEW DELETE\n         UNIT(SYSALLDA).\n ADD     DDDEF(SYSUT1) BLK(3120) SPACE(384,760)\n         UNIT(SYSALLDA).\n ADD     DDDEF(SYSUT2) BLK(3120) SPACE(384,760)\n         UNIT(SYSALLDA).\n ADD     DDDEF(SYSUT3) BLK(3120) SPACE(384,760)\n         UNIT(SYSALLDA).\n ADD     DDDEF(SYSUT4) BLK(3120) SPACE(384,760)\n         UNIT(SYSALLDA).\n ADD     DDDEF(SYSPUNCH) BLK(3120) SPACE(380,380) DIR(64)\n         UNIT(SYSALLDA) .\n ENDUCL.\n SET BDY(DLIB1).\n UCLIN.\n    ADD DLIBZONE(DLIB1)\n         ACCJCLIN\n         SREL(Z038)\n         OPTIONS(OPTMVS)\n         RELATED(TARGET1).\n  ADD DDDEF(SMPPTS) SHR\n      DA(XXXXXXXX.SMPPTS) .\n /*  ADD DDDEF(SMPLTS)\n      SHR UNIT(SYSALLDA) VOLUME(SMPVOL)\n      DA(XXXXXXXX.SMPLTS) . */\n  ADD DDDEF(SMPMTS)\n      SHR UNIT(SYSALLDA) VOLUME(SMPVOL)\n      DA(XXXXXXXX.SMPMTS) .\n  ADD DDDEF(SMPSTS)\n      SHR UNIT(SYSALLDA) VOLUME(SMPVOL)\n      DA(XXXXXXXX.SMPSTS) .\n  ADD DDDEF(SMPSCDS)\n      SHR UNIT(SYSALLDA) VOLUME(SMPVOL)\n      DA(XXXXXXXX.SMPSCDS) .\n  ADD DDDEF(SMPTLIB)\n      UNIT(SYSALLDA) VOLUME(SMPVOL) .\n  ADD DDDEF(SYSLIB)\n      CONCAT(\n             SMPMTS\n                ) .\n  /* ADD     DDDEF(SMPLOG)\n             SYSOUT(*) .\n     ADD     DDDEF(SMPLOGA)\n             SYSOUT(*) .     */\n ADD DDDEF(SMPLOG) MOD\n      UNIT(SYSALLDA) VOLUME(SMPVOL)\n      DA(XXXXXXXX.SMPDLOG).\n ADD DDDEF(SMPLOGA) MOD\n      UNIT(SYSALLDA) VOLUME(SMPVOL)\n      DA(XXXXXXXX.SMPDLOGA).\n ADD     DDDEF(SMPOUT)\n         SYSOUT(*) .\n ADD     DDDEF(SMPLIST)\n         SYSOUT(*) .\n ADD     DDDEF(SMPRPT)\n         SYSOUT(*) .\n ADD     DDDEF(SMPSNAP)\n         SYSOUT(*) .\n ADD     DDDEF(SMPDEBUG)\n         SYSOUT(*) .\n ADD     DDDEF(SMPPUNCH)\n         SYSOUT(B) .\n ADD     DDDEF(SYSPRINT)\n         SYSOUT(*) .\n ADD     DDDEF(SYSUDUMP)\n         SYSOUT(*) .\n ADD     DDDEF(SMPWRK1) BLK(3120) SPACE(384,380) DIR(111) NEW DELETE\n         UNIT(SYSALLDA).\n ADD     DDDEF(SMPWRK2) BLK(3120) SPACE(384,380) DIR(111) NEW DELETE\n         UNIT(SYSALLDA).\n ADD     DDDEF(SMPWRK3) BLK(3120) SPACE(384,380) DIR(111) NEW DELETE\n         UNIT(SYSALLDA).\n ADD     DDDEF(SMPWRK4) BLK(3120) SPACE(384,380) DIR(111) NEW DELETE\n         UNIT(SYSALLDA).\n /*ADD   DDDEF(SMPWRK5) BLK(7294) SPACE(384,380) DIR(111) NEW DELETE\n         UNIT(SYSALLDA).  */\n ADD     DDDEF(SMPWRK6) BLK(3120) SPACE(384,380) DIR(111) NEW DELETE\n         UNIT(SYSALLDA).\n ADD     DDDEF(SYSUT1) BLK(3120) SPACE(384,760)\n         UNIT(SYSALLDA).\n ADD     DDDEF(SYSUT2) BLK(3120) SPACE(384,760)\n         UNIT(SYSALLDA).\n ADD     DDDEF(SYSUT3) BLK(3120) SPACE(384,760)\n         UNIT(SYSALLDA).\n ADD     DDDEF(SYSUT4) BLK(3120) SPACE(384,760)\n         UNIT(SYSALLDA).\n ADD     DDDEF(SYSPUNCH) BLK(3120) SPACE(380,380) DIR(64)\n         UNIT(SYSALLDA) .\n ENDUCL.\n SET BDY(GLOBAL).\n LIST ALLZONES.\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SMPBLD3": {"ttr": 15873, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00F\\x01\\x01\\x03?\\x01\\x01\\x03?\\x14\\x10\\x017\\x017\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf3\\xf3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-02-02T00:00:00", "modifydate": "2001-02-02T14:10:46", "lines": 311, "newlines": 311, "modlines": 0, "user": "CBT433"}, "text": "//TSGMXZ1S JOB (AD00),'#04D42 ZELDEN',\n//             NOTIFY=&SYSUID,\n//             CLASS=M,MSGCLASS=H,MSGLEVEL=(1,1)\n//*\n//********************************************************************\n//* THIS JOB WILL ADD A NEW TARGET AND DLIB ZONE PLUS SMP DATASETS\n//* TO AN EXISTING GLOBAL ZONE.\n//********************************************************************\n//********************************************************************\n//*  GLOBAL CHANGE ZZZZZZZZ.GLOBAL.CSI  TO BE THE EXISTING GLOBAL ZONE\n//*  GLOBAL CHANGE ZZZZZZZZ.SMPPTS      TO BE THE EXISTING SMPPTS DSN\n//********************************************************************\n//*  GLOBAL CHANGE XXXXXXXX TO BE THE HIGH LEVEL INDEX OF SMP DATASETS\n//*  GLOBAL CHANGE SMPVOL  TO BE THE SMP DATASET DASD VOLUME\n//*  GLOBAL CHANGE P004    TO BE THE SMP SREL YOU WANT IN THE OPTIONS\n//*  GLOBAL CHANGE TARGET1 TO BE THE TARGET ZONE NAME YOU DESIRE\n//*  GLOBAL CHANGE DLIB1   TO BE THE DLIB   ZONE NAME YOU DESIRE\n//*  GLOBAL CHANGE OPTNCP  TO BE THE OPTIONS NAME YOU DESIRE\n//********************************************************************\n//ALLOC   EXEC PGM=IEFBR14\n//SMPSCDS   DD DSN=XXXXXXXX.SMPSCDS,\n//             DISP=(,CATLG,DELETE),\n//             SPACE=(TRK,(10,5,50)),UNIT=SYSALLDA,\n//             VOL=SER=SMPVOL,\n//             DCB=(LRECL=80,BLKSIZE=6080,RECFM=FB)\n//*SMPLTS    DD DSN=XXXXXXXX.SMPLTS,\n//*             DISP=(,CATLG,DELETE),\n//*             SPACE=(TRK,(5,5,10)),UNIT=SYSALLDA,\n//*             VOL=SER=SMPVOL,\n//*             DCB=(BLKSIZE=6233,RECFM=U)\n//SMPMTS    DD DSN=XXXXXXXX.SMPMTS,\n//             DISP=(,CATLG,DELETE),\n//             SPACE=(TRK,(5,5,10)),UNIT=SYSALLDA,\n//             VOL=SER=SMPVOL,\n//             DCB=(LRECL=80,BLKSIZE=6080,RECFM=FB)\n//SMPSTS    DD DSN=XXXXXXXX.SMPSTS,\n//             DISP=(,CATLG,DELETE),\n//             SPACE=(TRK,(5,5,10)),UNIT=SYSALLDA,\n//             VOL=SER=SMPVOL,\n//             DCB=(LRECL=80,BLKSIZE=6080,RECFM=FB)\n//SMPTLOG   DD DSN=XXXXXXXX.SMPTLOG,\n//             DISP=(,CATLG,DELETE),\n//             SPACE=(TRK,(30,5)),UNIT=SYSALLDA,\n//             VOL=SER=SMPVOL,\n//             DCB=(BLKSIZE=3200,LRECL=260,RECFM=VB)\n//SMPTLOGA  DD DSN=XXXXXXXX.SMPTLOGA,\n//             DISP=(,CATLG,DELETE),\n//             SPACE=(TRK,(1,5)),UNIT=SYSALLDA,\n//             VOL=SER=SMPVOL,\n//             DCB=(BLKSIZE=3200,LRECL=260,RECFM=VB)\n//SMPDLOG   DD DSN=XXXXXXXX.SMPDLOG,\n//             DISP=(,CATLG,DELETE),\n//             SPACE=(TRK,(30,5)),UNIT=SYSALLDA,\n//             VOL=SER=SMPVOL,\n//             DCB=(BLKSIZE=3200,LRECL=260,RECFM=VB)\n//SMPDLOGA  DD DSN=XXXXXXXX.SMPDLOGA,\n//             DISP=(,CATLG,DELETE),\n//             SPACE=(TRK,(1,5)),UNIT=SYSALLDA,\n//             VOL=SER=SMPVOL,\n//             DCB=(BLKSIZE=3200,LRECL=260,RECFM=VB)\n//DEFCSI  EXEC PGM=IDCAMS,REGION=1024K\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  *\n  DEFINE CLUSTER(+\n                  NAME(XXXXXXXX.TARGET1.CSI) +\n                  FREESPACE(10,5) +\n                  KEYS(24 0) +\n                  RECORDSIZE(24 143) +\n                  BUFSP(20480) +\n                  SHR(2) +\n                  VOLUME(SMPVOL) +\n                ) +\n           DATA(   +\n                  NAME(XXXXXXXX.TARGET1.CSI.DATA) +\n                  CYLINDERS(4  1) +\n                  CISZ(4096) +\n               ) +\n           INDEX(  +\n                  NAME(XXXXXXXX.TARGET1.CSI.INDEX) +\n                  TRACKS(1 1)  +\n                  IMBED +\n                )\n  DEFINE CLUSTER(+\n                  NAME(XXXXXXXX.DLIB1.CSI) +\n                  FREESPACE(10,5) +\n                  KEYS(24 0) +\n                  RECORDSIZE(24 143) +\n                  BUFSP(20480) +\n                  SHR(2) +\n                  VOLUME(SMPVOL) +\n                ) +\n           DATA(   +\n                  NAME(XXXXXXXX.DLIB1.CSI.DATA) +\n                  CYLINDERS(3 1) +\n                  CISZ(4096) +\n               ) +\n           INDEX(  +\n                  NAME(XXXXXXXX.DLIB1.CSI.INDEX) +\n                  TRACKS(1 1)  +\n                  IMBED +\n                )\n/*\n//INITCSI EXEC PGM=IDCAMS,REGION=1024K\n//ZPOOL    DD  DISP=SHR,\n//             DSN=SYS1.MACLIB(GIMZPOOL)\n//TARGET1  DD  UNIT=SYSALLDA,\n//             DSN=XXXXXXXX.TARGET1.CSI,DISP=SHR\n//DLIB1    DD  UNIT=SYSALLDA,\n//             DSN=XXXXXXXX.DLIB1.CSI,DISP=SHR\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  *\n    REPRO INFILE(ZPOOL) +\n          OUTFILE(TARGET1)\n    REPRO INFILE(ZPOOL) +\n          OUTFILE(DLIB1)\n/*\n//BLDCSI  EXEC PGM=GIMSMP,REGION=4096K,PARM='DATE=U'\n//SMPOUT   DD SYSOUT=*\n//SMPRPT   DD SYSOUT=*\n//SMPLIST  DD SYSOUT=*\n//SMPSNAP  DD SYSOUT=*\n//SMPPUNCH DD DUMMY\n//SYSPRINT DD SYSOUT=*\n//*-------------------------------------------------------------------\n//*   SMP DATASETS\n//*-------------------------------------------------------------------\n//SMPPTS   DD DISP=OLD,DSN=ZZZZZZZZ.SMPPTS\n//SMPMTS   DD DISP=OLD,DSN=XXXXXXXX.SMPMTS\n//SMPSTS   DD DISP=OLD,DSN=XXXXXXXX.SMPSTS\n//SMPSCDS  DD DISP=OLD,DSN=XXXXXXXX.SMPSCDS\n//SMPLOG   DD SYSOUT=*\n//SMPCSI   DD DISP=SHR,DSN=ZZZZZZZZ.GLOBAL.CSI\n//TARGET1  DD DISP=SHR,DSN=XXXXXXXX.TARGET1.CSI\n//DLIB1    DD DISP=SHR,DSN=XXXXXXXX.DLIB1.CSI\n//SMPWRK1  DD UNIT=SYSALLDA,SPACE=(CYL,(2,1,5)),\n//            DCB=BLKSIZE=3120,DISP=(,DELETE)\n//SMPWRK2  DD UNIT=SYSALLDA,SPACE=(CYL,(2,1,5)),\n//            DCB=BLKSIZE=3120,DISP=(,DELETE)\n//SMPWRK3  DD UNIT=SYSALLDA,SPACE=(CYL,(2,1,5)),\n//            DCB=BLKSIZE=3120,DISP=(,DELETE)\n//SMPWRK4  DD UNIT=SYSALLDA,SPACE=(CYL,(2,1,5)),\n//            DCB=BLKSIZE=3120,DISP=(,DELETE)\n//*SMPWRK5  DD UNIT=SYSALLDA,SPACE=(CYL,(2,1,5)),\n//*            DCB=BLKSIZE=7294,DISP=(,DELETE)\n//SMPWRK6  DD UNIT=SYSALLDA,SPACE=(CYL,(2,1,5)),\n//            DCB=BLKSIZE=3120,DISP=(,DELETE)\n//SYSUT1   DD UNIT=SYSALLDA,SPACE=(CYL,(2,1)),DISP=(,DELETE)\n//SYSUT2   DD UNIT=SYSALLDA,SPACE=(CYL,(2,1)),DISP=(,DELETE)\n//SYSUT3   DD UNIT=SYSALLDA,SPACE=(CYL,(2,1)),DISP=(,DELETE)\n//SYSUT4   DD UNIT=SYSALLDA,SPACE=(TRK,(2,1)),DISP=(,DELETE)\n//SMPTLIB  DD UNIT=SYSALLDA,VOL=SER=SMPVOL,DISP=OLD\n//SYSLIB   DD DISP=SHR,DCB=(BLKSIZE=19040),\n//            DSN=XXXXXXXX.SMPMTS\n//         DD DISP=SHR,DSN=SYS1.MACLIB\n//SMPCNTL  DD *\n SET BDY(GLOBAL).\n UCLIN.\n   ADD GLOBALZONE\n        ZONEINDEX(\n            (TARGET1,XXXXXXXX.TARGET1.CSI,TARGET),\n            (DLIB1,XXXXXXXX.DLIB1.CSI,DLIB)\n                 ).\n ENDUCL.\n SET BDY(TARGET1).\n UCLIN.\n    ADD TARGETZONE(TARGET1)\n         SREL(P004)\n         OPTIONS(OPTNCP)\n         RELATED(DLIB1).\n  ADD DDDEF(SMPPTS) SHR\n      DA(ZZZZZZZZ.SMPPTS) .\n /*  ADD DDDEF(SMPLTS)\n      SHR UNIT(SYSALLDA) VOLUME(SMPVOL)\n      DA(XXXXXXXX.SMPLTS) . */\n  ADD DDDEF(SMPMTS)\n      SHR\n      DA(XXXXXXXX.SMPMTS) .\n  ADD DDDEF(SMPSTS)\n      SHR\n      DA(XXXXXXXX.SMPSTS) .\n  ADD DDDEF(SMPSCDS)\n      SHR\n      DA(XXXXXXXX.SMPSCDS) .\n  ADD DDDEF(SMPTLIB)\n      UNIT(SYSALLDA) VOLUME(SMPVOL) .\n  ADD DDDEF(SYSLIB)\n      CONCAT(\n             SMPMTS\n                ) .\n /* ADD     DDDEF(SMPLOG)\n            SYSOUT(*) .\n    ADD     DDDEF(SMPLOGA)\n            SYSOUT(*) .     */\n ADD DDDEF(SMPLOG) MOD\n         DA(XXXXXXXX.SMPTLOG).\n ADD DDDEF(SMPLOGA) MOD\n         DA(XXXXXXXX.SMPTLOGA).\n ADD     DDDEF(SMPOUT)\n         SYSOUT(*) .\n ADD     DDDEF(SMPLIST)\n         SYSOUT(*) .\n ADD     DDDEF(SMPRPT)\n         SYSOUT(*) .\n ADD     DDDEF(SMPSNAP)\n         SYSOUT(*) .\n ADD     DDDEF(SMPDEBUG)\n         SYSOUT(*) .\n ADD     DDDEF(SMPPUNCH)\n         SYSOUT(B) .\n ADD     DDDEF(SYSPRINT)\n         SYSOUT(*) .\n ADD     DDDEF(SYSUDUMP)\n         SYSOUT(*) .\n ADD     DDDEF(SMPWRK1) BLK(3120) SPACE(384,380) DIR(111) NEW DELETE\n         UNIT(SYSALLDA).\n ADD     DDDEF(SMPWRK2) BLK(3120) SPACE(384,380) DIR(111) NEW DELETE\n         UNIT(SYSALLDA).\n ADD     DDDEF(SMPWRK3) BLK(3120) SPACE(384,380) DIR(111) NEW DELETE\n         UNIT(SYSALLDA).\n ADD     DDDEF(SMPWRK4) BLK(3120) SPACE(384,380) DIR(111) NEW DELETE\n         UNIT(SYSALLDA).\n /*ADD   DDDEF(SMPWRK5) BLK(7294) SPACE(384,380) DIR(111) NEW DELETE\n         UNIT(SYSALLDA).  */\n ADD     DDDEF(SMPWRK6) BLK(3120) SPACE(384,380) DIR(111) NEW DELETE\n         UNIT(SYSALLDA).\n ADD     DDDEF(SYSUT1) BLK(3120) SPACE(384,760)\n         UNIT(SYSALLDA).\n ADD     DDDEF(SYSUT2) BLK(3120) SPACE(384,760)\n         UNIT(SYSALLDA).\n ADD     DDDEF(SYSUT3) BLK(3120) SPACE(384,760)\n         UNIT(SYSALLDA).\n ADD     DDDEF(SYSUT4) BLK(3120) SPACE(384,760)\n         UNIT(SYSALLDA).\n ADD     DDDEF(SYSPUNCH) BLK(3120) SPACE(380,380) DIR(64)\n         UNIT(SYSALLDA) .\n ENDUCL.\n SET BDY(DLIB1).\n UCLIN.\n    ADD DLIBZONE(DLIB1)\n         ACCJCLIN\n         SREL(P004)\n         OPTIONS(OPTNCP)\n         RELATED(TARGET1).\n  ADD DDDEF(SMPPTS) SHR\n      DA(ZZZZZZZZ.SMPPTS) .\n /*  ADD DDDEF(SMPLTS)\n      SHR UNIT(SYSALLDA) VOLUME(SMPVOL)\n      DA(XXXXXXXX.SMPLTS) . */\n  ADD DDDEF(SMPMTS)\n      SHR\n      DA(XXXXXXXX.SMPMTS) .\n  ADD DDDEF(SMPSTS)\n      SHR\n      DA(XXXXXXXX.SMPSTS) .\n  ADD DDDEF(SMPSCDS)\n      SHR\n      DA(XXXXXXXX.SMPSCDS) .\n  ADD DDDEF(SMPTLIB)\n      UNIT(SYSALLDA) VOLUME(SMPVOL) .\n  ADD DDDEF(SYSLIB)\n      CONCAT(\n             SMPMTS\n                ) .\n /* ADD     DDDEF(SMPLOG)\n            SYSOUT(*) .\n    ADD     DDDEF(SMPLOGA)\n            SYSOUT(*) .     */\n ADD DDDEF(SMPLOG) MOD\n         DA(XXXXXXXX.SMPDLOG).\n ADD DDDEF(SMPLOGA) MOD\n         DA(XXXXXXXX.SMPDLOGA).\n ADD     DDDEF(SMPOUT)\n         SYSOUT(*) .\n ADD     DDDEF(SMPLIST)\n         SYSOUT(*) .\n ADD     DDDEF(SMPRPT)\n         SYSOUT(*) .\n ADD     DDDEF(SMPSNAP)\n         SYSOUT(*) .\n ADD     DDDEF(SMPDEBUG)\n         SYSOUT(*) .\n ADD     DDDEF(SMPPUNCH)\n         SYSOUT(B) .\n ADD     DDDEF(SYSPRINT)\n         SYSOUT(*) .\n ADD     DDDEF(SYSUDUMP)\n         SYSOUT(*) .\n ADD     DDDEF(SMPWRK1) BLK(3120) SPACE(384,380) DIR(111) NEW DELETE\n         UNIT(SYSALLDA).\n ADD     DDDEF(SMPWRK2) BLK(3120) SPACE(384,380) DIR(111) NEW DELETE\n         UNIT(SYSALLDA).\n ADD     DDDEF(SMPWRK3) BLK(3120) SPACE(384,380) DIR(111) NEW DELETE\n         UNIT(SYSALLDA).\n ADD     DDDEF(SMPWRK4) BLK(3120) SPACE(384,380) DIR(111) NEW DELETE\n         UNIT(SYSALLDA).\n /*ADD   DDDEF(SMPWRK5) BLK(7294) SPACE(384,380) DIR(111) NEW DELETE\n         UNIT(SYSALLDA).  */\n ADD     DDDEF(SMPWRK6) BLK(3120) SPACE(384,380) DIR(111) NEW DELETE\n         UNIT(SYSALLDA).\n ADD     DDDEF(SYSUT1) BLK(3120) SPACE(384,760)\n         UNIT(SYSALLDA).\n ADD     DDDEF(SYSUT2) BLK(3120) SPACE(384,760)\n         UNIT(SYSALLDA).\n ADD     DDDEF(SYSUT3) BLK(3120) SPACE(384,760)\n         UNIT(SYSALLDA).\n ADD     DDDEF(SYSUT4) BLK(3120) SPACE(384,760)\n         UNIT(SYSALLDA).\n ADD     DDDEF(SYSPUNCH) BLK(3120) SPACE(380,380) DIR(64)\n         UNIT(SYSALLDA) .\n ENDUCL.\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SMPDELF": {"ttr": 15879, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x05\\x17O\\x01\\x14\\x12\\x7f\\t%\\x00E\\x00=\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf8@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-06-23T00:00:00", "modifydate": "2014-05-07T09:25:00", "lines": 69, "newlines": 61, "modlines": 0, "user": "CBT488"}, "text": "//TSGMXZ1D JOB (AD00),'ZELDEN',\n//             NOTIFY=&SYSUID,\n//             CLASS=M,MSGCLASS=H,MSGLEVEL=(1,1)\n//*\n//*\n//S1       EXEC PGM=GIMSMP,\n//         PARM='PROCESS=WAIT',\n//         DYNAMNBR=120\n//********************************************************************\n//*\n//*   USE THIS JOBSTREAM TO DELETE A FMID / PRODUCT FROM\n//*   A SET OF SMP ZONES AND LIBRARIES. IT WILL ALSO DELETE ANY\n//*   SYSMODS FOR THE FMID YOU ARE DELETING FROM THE GLOBAL ZONE AND\n//*   SMPPTS DATASET. IT WILL ALSO DELETE THE FMID FROM THE GLOBAL\n//*   ZONE INDEX. THIS WILL PREVENT SERVICE FOR THAT FMID FROM BEING\n//*   RECEIVED FROM PUT TAPES OR FROM CBPDO TAPES.\n//*\n//*   NOTE: IF THE PRODUCT LIBRARIES ARE NOT IN DDDEF'S YOU\n//*         MUST ADD THEM TO THIS JCL.\n//*\n//********************************************************************\n//*  GLOBALLY CHANGE \"TGTZONE\" TO BE THE CORRECT TARGET ZONE NAME\n//*  GLOBALLY CHANGE \"DLBZONE\" TO BE THE CORRECT DLIB   ZONE NAME\n//********************************************************************\n//*\n//SMPCSI   DD DISP=SHR,DSN='SMPE.GLOBAL.CSI'\n//SMPHOLD  DD DUMMY\n//SMPLOG   DD  SYSOUT=*\n//SMPOUT   DD  SYSOUT=*\n//SMPRPT   DD  SYSOUT=*\n//SMPLIST  DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=*\n//SMPPTFIN DD *\n++FUNCTION  (MSZ0001) REWORK(2014038)\n /***********************************************************/\n /* DELETE XXXXXXX FROM ALL ZONES                           */\n /***********************************************************/\n .\n++VER   (Z038)\n        DELETE(XXXXXXX) .\n/*\n//SMPCNTL  DD *\n  SET    BOUNDARY (GLOBAL).\n  RECEIVE SELECT (MSZ0001) SYSMOD.\n  SET    BOUNDARY (TGTZONE) .\n  APPLY   SELECT (MSZ0001) .\n  SET    BOUNDARY (DLBZONE) .\n  ACCEPT  SELECT (MSZ0001) .\n  SET  BOUNDARY(TGTZONE) .\n  UCLIN.\n  DEL SYSMOD(MSZ0001).\n  DEL SYSMOD(XXXXXXX).\n  ENDUCL.\n  SET  BOUNDARY(DLBZONE) .\n  UCLIN.\n  DEL SYSMOD(MSZ0001).\n  DEL SYSMOD(XXXXXXX).\n  ENDUCL.\n  SET    BOUNDARY (GLOBAL).\n  REJECT  APARS FUNCTIONS PTFS USERMODS FORFMID(XXXXXXX).\n  RESETRC.\n  UCLIN.\n  DEL  GLOBALZONE FMID(MSZ0001).\n  DEL  GLOBALZONE FMID(XXXXXXX).\n  ENDUCL.\n  REJECT  SELECT(MSZ0001). /* MAY BE NEEDED - DEPENDS ON CLEANUP OPTS */\n  RESETRC.\n/*\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SUFFIX": {"ttr": 15881, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x992/\\x01\\x13(\\x0f\\x14\\x15\\x00\\x90\\x00u\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf7@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "2013-10-07T14:15:00", "lines": 144, "newlines": 117, "modlines": 0, "user": "CBT487"}, "text": "/* REXX */\n/*                           */\n/* AUTHOR: Mark Zelden       */\n/*                           */\n/* Last Updated 10/07/2013   */\n/*                           */\nhelp_start = HELP_INCL()\n/**********************************************************/\n/* This edit macro will add a character string suffix     */\n/* to the end of a line after the last non-blank          */\n/* character. The suffix can optionally be limited to     */\n/* specific lines if labels are used. Excluded lines      */\n/* are omitted from the operation.                        */\n/*                                                        */\n/* EXAMPLES:                                              */\n/*            SUFFIX \"'\"                                  */\n/*            SUFFIX ',DISP=SHR' .A .B                    */\n/*                                                        */\n/*                                                        */\n/*  ** NOTE  If you execute SUFFIX with no parms or with  */\n/*           a parm of \"?\", the comment section of this   */\n/*           code with examples will be displayed as      */\n/*           \"help\" note lines.  Use the \"RESET\"          */\n/*           command to remove them.                      */\n/*                                                        */\n/**********************************************************/\nhelp_end = HELP_INCL()\n/* TRACE ?R */\nAddress ISREDIT\n\"MACRO (parm label1 label2)\"\n/* Address ISPEXEC \"CONTROL ERRORS RETURN\"  */\n/*                                                    */\nIf parm = '?' then do\n  Call HELP_NOTELINES\n  Exit 1  /* return cursor to command line */\nEnd\nIf parm = '' then do\n  zedsmsg = 'NO SUFFIX SPECIFIED'\n  zedlmsg = 'YOU MUST PASS A PARM STRING',\n            'FOR SUFFIX TO ADD.'\n  Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n  Call HELP_NOTELINES\n  Exit 4\nEnd\n/*                                                    */\nCall FIND_LABELS  /* find out if labels are being used  */\n/*                                             */\n/*   HOUSE KEEPING                             */\n/*                                             */\n\"(width) = DATA_WIDTH\" /* length of line  */\ncount   = 0   /* count of changed lines   */\ntruncat = 0   /* lines truncated count    */\ntruncmsg = \"'*** THE SUFFIX WAS TRUNCATED ON THE NEXT LINE ***'\"\n/*                                             */\n/* If the suffix is is delimted by single or   */\n/* double quotes - then remove the delimiters  */\n/*                                             */\nIf Substr(parm,1,1) = '''' | Substr(parm,1,1) = '\"' then\nparm = Substr(parm,2,Length(parm)-2)\n/***********************************************/\n/*   BEGIN SUFFIX PROCESSING                   */\n/***********************************************/\nDo until lastln = firstln-1\n  /* copy the data in the current line to variable 'data1' */\n  \"(data1) = LINE \"firstln\n  \"ISREDIT (chkexcl) = XSTATUS\" firstln\n  If chkexcl = \"NX\" then do\n    data1 = Strip(data1,T)\n    data1 = data1||parm\n    count = count + 1\n    If Length(data1) > width then do\n      truncat = truncat+1\n      \"ISREDIT LINE_BEFORE\" firstln \"= NOTELINE \" truncmsg\n    End\n  End\n  /* copy the suffixed 'data1' back into the current line */\n  \"LINE\" firstln \"= (data1)\"\n  firstln = firstln + 1\nEnd   /* do until   */\n/***********************************************/\n/*   END SUFFIX PROCESSING                     */\n/***********************************************/\nIf truncat = 0 then do\n  zedsmsg = count 'LINES CHANGED'\n  zedlmsg = 'SUFFIX \"'parm'\" WAS ADDED ON' count 'LINES.'\n  Address ISPEXEC \"SETMSG MSG(ISRZ000)\"  /* msg - no alarm */\n  Exit 1  /* return cursor to command line */\nEnd\nElse do\n  zedsmsg = 'TRUNCATED ON' truncat 'LINES'\n  zedlmsg = 'SUFFIX \"'parm'\" WAS ADDED ON' count 'LINES',\n            '('truncat 'LINES WERE TRUNCATED).'\n  Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n  Exit 4\nEnd\n/*********************************/\n/*  HELP SUB-ROUTINES            */\n/*********************************/\nHELP_INCL:\nReturn SIGL\nHELP_NOTELINES:\n\"(helpln) = DISPLAY_LINES\"\nDo hlp = help_end-1 to help_start+1 by -1\n  hline = Sourceline(hlp)\n  \"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline)\"\nEnd\nhline2 = '==================='\nhline3 = '===   H E L P   ==='\n\"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline2)\"\n\"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline3)\"\n\"ISREDIT LINE_AFTER \" helpln \" = NOTELINE (hline2)\"\nReturn\n/*********************************/\n/*  SUB-ROUTINE TO FIND LABELS   */\n/*********************************/\nFIND_LABELS:\nAddress ISPEXEC \"CONTROL ERRORS RETURN\"\nIf label1 = '' then do\n  firstln  = 1\n  \"(lastln) = LINENUM .ZLAST\"\nEnd\nElse do\n  If label2 = '' then label2 = label1\n  \"(firstsv)  = LINENUM\" label1\n  If RC >= 8 then do\n    zedsmsg = 'RANGE LABEL ERROR'\n    zedlmsg = 'THE SPECIFIED RANGE LABEL \"' || label1 '\" WAS',\n              'NOT FOUND'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\n  \"(lastsv)   = LINENUM\" label2\n  If RC >= 8 then do\n    zedsmsg = 'RANGE LABEL ERROR'\n    zedlmsg = 'THE SPECIFIED RANGE LABEL \"' || label2 '\" WAS',\n              'NOT FOUND'\n    Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n    Exit 12\n  End\n  firstln = Min(firstsv,lastsv)\n  lastln  = Max(firstsv,lastsv)\nAddress ISPEXEC \"CONTROL ERRORS\"\nEnd /* else do */\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SW": {"ttr": 15885, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x046o\\x01\\x07#_\\t0\\x00G\\x00\\x16\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf5@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-12-31T00:00:00", "modifydate": "2007-08-23T09:30:00", "lines": 71, "newlines": 22, "modlines": 0, "user": "CBT475"}, "text": "/* REXX */\n/*                                        */\n/* AUTHOR: Mark Zelden                    */\n/*                                        */\n/* Last Updated 08/23/2007                */\n/***************************************************************/\n/* SW Edit Macro - Switch from VIEW to EDIT or visa versa      */\n/***************************************************************/\n/* Execution syntax:                                           */\n/*                                                             */\n/* SW  or  SW FORCE   (FORCE may be abbreviated, e.g. SW F)    */\n/*                                                             */\n/* Note:                                                       */\n/*  If data has been changed you must either SAVE the data     */\n/*  first or use the FORCE option. Any changes made will be    */\n/*  lost when using FORCE. FORCE me be abbeviated using one    */\n/*  or more of its characters, for example:  SW F.             */\n/*                                                             */\n/*  Also note that using this macro on a sequential data set   */\n/*  requires the use of XVIEW and XEDIT also available from    */\n/*  CBT file 434 and my web site.                              */\n/*                                                             */\n/***************************************************************/\nAddress ISREDIT\n\"MACRO (opt)\"\n\"(DSN) = DATASET\"\n\"(MBR) = MEMBER\"\n\"(SES) = SESSION\"\n\"(DCHG) = DATA_CHANGED\"\nOPT = Translate(OPT)                /* ensure upper case */\nIf ses = 'EDIF' | ses = 'VIIF' then do\n  zedsmsg = 'Can''t switch from' ses\n  zedlmsg = 'This macro can''t be used when the session is' ,\n            'using the ISPF' ses 'interface.'\n  Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n  Exit 12\nEnd\nIf OPT <> '' & Abbrev('FORCE',OPT,1) <> 1 then do\n  zedsmsg = 'Invalid option'\n  zedlmsg = 'The only valid option is \"FORCE\". FORCE may be' ,\n            'abbreviated using one or more of its characters.'\n  Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n  Exit 12\nEnd\nIf DCHG = 'NO' | ,\n   (DCHG = 'YES' & Abbrev('FORCE',OPT,1) = 1) then do\n  If MBR <> '' then do\n    If ses = 'VIEW' then \"EDIT\" mbr\n      else \"VIEW\" mbr\n    If RC = 4 then RC = 0\n    If RC <> 0 then do\n      Address ISPEXEC \"SETMSG MSG(\"ZERRMSG\")\"\n      Exit 8\n    End\n  End /* if MBR */\n  Else do\n    \"(VOL) = VOLUME\"\n    If ses = 'VIEW' then Address TSO \"%XEDIT '\"dsn\"'\" vol\n      else Address TSO \"%XVIEW '\"dsn\"'\" vol\n  End\n  \"CANCEL\"  /* cancel out of mbr originally edited/viewed */\nEnd /* if DCHG = 'YES' & Abbrev('FORCE',OPT,1) = 1 */\nElse do\n  zedsmsg = 'Data changed: SAVE/FORCE'\n  zedlmsg = 'If data has been changed you must either SAVE the data' ,\n            'first or use the FORCE option. Any changes made will be',\n            'lost when using FORCE. FORCE may be abbreviated using' ,\n            'one or more of its characters, for example:  SW F.'\n  Address ISPEXEC \"SETMSG MSG(ISRZ001)\"  /* msg - with alarm */\n  Exit 12\nEnd\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TAPESTAK": {"ttr": 16130, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x992/\\x01\\t#/\\x12\\x00\\x04\\x1d\\x03\\xc0\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf8@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "2009-08-20T12:00:00", "lines": 1053, "newlines": 960, "modlines": 0, "user": "CBT478"}, "text": "/* REXX */\n/*                           */\n/* AUTHOR: MARK ZELDEN       */\n/*                           */\n/*********************************************************************/\n/*   TAPESTAK - REXX TAPE STACKING PROGRAM                           */\n/*   LAST UPDATE - 08/20/2009                                        */\n/*     -  Changed check for (non) vault from hexzeros to <= ' ' to   */\n/*        allow for hexzeros or blanks (changed in CA-1 R5.?)        */\n/*     -  Added in TMDEN check for 3592 & WORM                       */\n/*     -  Only add in Inter Block Gaps (IBG) for 38K / 38KC          */\n/*********************************************************************/\n/*  NOTE: This program was written to work with CA-1 release 5.0     */\n/*        CA-1 release 5.1, and CA-1 release 5.2.                    */\n/*                                                                   */\n/* INPUT FILES NEEDED                                                */\n/*  CA-1 TMC FILE - DD NAME OF TMC                                   */\n/*                                                                   */\n/* OUTPUT FILES NEEDED                                               */\n/*  REPORT FILE   - DD NAME OF REPORT  (report on stacked tapes)     */\n/*  SYSPRINT FILE - DD NAME OF SYSPRINT (work file needed for IDCAMS)*/\n/*  SYSIN FILE    - DD NAME OF SYSIN   (work file needed for IDCAMS) */\n/*                                                                   */\n/*  COPYCAT FILE  - DD NAME OF COPYCAT (copycat stacking jobs)       */\n/*  GENER FILE    - DD NAME OF GENER   (iebgener stacking jobs)      */\n/*********************************************************************/\n/* OPTIONAL PARMS:                                                   */\n/*  JOBTYPE - Type of jobs to generate - IEBGENER or COPYCAT         */\n/*            The default is COPYCAT                                 */\n/*  MAXJOBS - Maximum number of jobs to generate (1-99)              */\n/*            The default is 5                                       */\n/*  RUNMODE - either \"TEST\" or \"PROD\"                                */\n/*            The default is PROD                                    */\n/*            In TEST mode:                                          */\n/*              1) Input files are not uncataloged                   */\n/*              2) Input files do not get expired                    */\n/*              3) Output files are not cataloged                    */\n/*              4) Output files are given LABEL=RETPD=1              */\n/*              5) The control statements for the COPYCAT option     */\n/*                 are changed to perform the above actions.         */\n/*              6) The TMSUPDTE steps are not generated to expire    */\n/*                 input tapes for the IEBGENER option.              */\n/*              7) The output report indicates *** TEST MODE ***     */\n/*                                                                   */\n/*  *** If you specify MAXJOBS you must also specify JOBTYPE first.  */\n/*  *** If you specify RUNMODE you must also specify JOBTYPE and     */\n/*      MAXJOBS first. ***                                           */\n/*********************************************************************/\n/* SAMPLE EXECUTION JCL:                                             */\n/*                                                                   */\n/*  //TAPESTAK JOB (ACCT,INFO),'REXX BATCH',CLASS=M,MSGCLASS=H       */\n/*  //*                                                          */  */\n/*  //STEP1 EXEC PGM=IRXJCL,PARM='TAPESTAK'                          */\n/*  //*STEP1 EXEC PGM=IRXJCL,PARM='TAPESTAK IEBGENER'            */  */\n/*  //*STEP1 EXEC PGM=IRXJCL,PARM='TAPESTAK COPYCAT 10'          */  */\n/*  //*STEP1 EXEC PGM=IRXJCL,PARM='TAPESTAK IEBGENER 5 TEST'     */  */\n/*  //*STEP1 EXEC PGM=IRXJCL,PARM='TAPESTAK COPYCAT 5 PROD' DEFLT */ */\n/*  //*                                                          */  */\n/*  //SYSTSIN  DD  DUMMY                 /* STD IRXJCL DD */         */\n/*  //SYSTSPRT DD  SYSOUT=*              /* STD IRXJCL DD */         */\n/*  //SYSEXEC  DD  DSN=REXX.EXEC.PDSLIB, /* STD IRXJCL DD */         */\n/*  //             DISP=SHR                                          */\n/*  //*                                                          */  */\n/*  //TMC      DD  DSN=CA1.TMC,DISP=SHR                              */\n/*  //REPORT   DD  SYSOUT=*,DCB=(LRECL=133,BLKSIZE=3990,RECFM=FBA)   */\n/*  //SYSIN    DD  UNIT=SYSDA,SPACE=(TRK,(1,1)) /*NEEDED FOR IDCAMS*/*/\n/*  //SYSPRINT DD  UNIT=SYSDA,SPACE=(TRK,(1,1)) /*NEEDED FOR IDCAMS*/*/\n/*  //*COPYCAT DD  DSN=JCL.PDSLIB(COPYCAT),DISP=SHR              */  */\n/*  //COPYCAT  DD  SYSOUT=(A,INTRDR),DCB=BLKSIZE=80                  */\n/*  //*GENER   DD  DSN=JCL.PDSLIB(GENER),DISP=SHR                */  */\n/*  //GENER    DD  SYSOUT=(A,INTRDR),DCB=BLKSIZE=80                  */\n/*********************************************************************/\n/* ERROR MESSAGES:                                                   */\n/*                                                                   */\n/*  STAK001E INVALID JOB TYPE SPECIFIED                              */\n/*  STAK002E JOB TYPE MUST BE EITHER \"IEBGENER\" OR \"COPYCAT\"         */\n/*                                                                   */\n/*  STAK003E MAXJOBS PARAMETER IS NOT NUMBERIC                       */\n/*  STAK004E MAXJOBS PARAMETER MUST BE BETWEEN 1 AND 99              */\n/*                                                                   */\n/*  STAK005E INVALID RUN MODE SPECIFIED                              */\n/*  STAK006E RUN MODE MUST BE EITHER \"PROD\" OR \"TEST\"                */\n/*                                                                   */\n/*  STAK007E JOB NAME PREFIX (JOBPRE) MUST BE 6 CHARACTERS OR LESS   */\n/*                                                                   */\n/*  STAK008E UNKNOWN TAPE DENSITY FOUND - TERMINATING                */\n/*  STAK009E RECORD = NN VOLSER = NNNNNN                             */\n/*                                                                   */\n/*  STAK010I THE NUMBER OF JOBS GENERATED WAS LESS THAN MAXJOBS      */\n/*********************************************************************/\n/*                                                                   */\n/* A RETURN CODE OF 4 MEANS THAT THE NUMBER OF JOBS GENERATED        */\n/* WAS LESS THAN THE MAXJOBS PARAMETER THAT WAS SPECIFIED OR         */\n/* DEFAULTED. THIS IS BECAUSE NO TAPES WERE FOUND THAT COULD BE      */\n/* STACKED WITH THE TAPE THAT WAS CHOSEN TO BE USED AS THE FIRST     */\n/* FILE IN A STACKING JOB OR THERE WERE NO MORE TMC RECORDS TO READ. */\n/*                                                                   */\n/* IF THIS HAPPENS, THE GENERATED JOBS SHOULD BE RUN BEFORE RUNNING  */\n/* THIS PROGRAM AGAIN OR THE CUSTOMIZATION PARAMETERS BELOW SHOULD   */\n/* BE ADJUSTED - WHICH SHOULD PRODUCE DIFFERENT RESULTS.             */\n/*                                                                   */\n/*********************************************************************/\n/*                                                                   */\n/* ALL GENERATED JOBS SHOULD BE RUN BEFORE THIS PROGRAM IS USED      */\n/* TO GENERATE MORE STACKING JOBS. IF ALL JOBS ARE NOT RUN THE       */\n/* SAME TAPES CAN BE DUPLICATED IN NEW JOBS.                         */\n/*                                                                   */\n/*********************************************************************/\n/*                                                                   */\n/* IF STACKING SPECIFIC EXPIRATION TAPES IS YOUR MAIN OBJECTIVE,     */\n/* IT MIGHT BE HELPFUL TO SORT THE TMC BY EXPIRATION DATE AND USE    */\n/* THE SORTED FILE AS INPUT. YOU MIGHT ALSO WANT TO CHANGE THE       */\n/* \"RANGE\" VALUE BELOW TO A LARGE NUMBER SUCH AS 9999 TO NULLIFY     */\n/* IT'S EFFECTS.                                                     */\n/*                                                                   */\n/* THE FOLLOWING SORT CONTROL CARDS CAN BE USED TO SORT THE TMC      */\n/* BY EXPIRATION DATE AND VOLSER AND WILL OMIT ALL DSNB RECORDS:     */\n/*       *** YOU MUST USE THE OMIT CONTROL CARD ***                  */\n/*                                                                   */\n/*   SORT FIELDS=(51,4,BI,A,1,6,CH,A)                                */\n/*   OMIT COND=(1,1,BI,EQ,X'FF')                                     */\n/*                                                                   */\n/*********************************************************************/\n/*                                                                   */\n/* NOTE: THE ONLY TAPES THAT CAN BE STACKED ARE TAPES THAT HAVE      */\n/* SPECIFIC EXPIRATION DATES AND CATALOG CONTROL TAPES.              */\n/*                                                                   */\n/* TAPES UNDER CYCLE, LDATE OR PERMANENT CONTROL CAN NOT BE STACKED  */\n/* BECAUSE IF THE FIRST FILE REACHES IT'S EXPIRATION, THEN ALL FILES */\n/* THAT ARE STACKED WILL ALSO BE EXPIRED.                            */\n/*                                                                   */\n/*********************************************************************/\nArg JOBTYPE MAXJOBS RUNMODE\nIf JOBTYPE = '' then JOBTYPE = COPYCAT\nElse do\n  If JOBTYPE <> IEBGENER & JOBTYPE<> COPYCAT then do\n    Say 'STAK001E INVALID JOB TYPE SPECIFIED'\n    Say 'STAK002E JOB TYPE MUST BE EITHER \"IEBGENER\" OR \"COPYCAT\"'\n    Exit 12\n  End /* if */\nEnd  /* else  */\nIf MAXJOBS <> '' then do\n  If Datatype(MAXJOBS,Number) <> 1 then do\n    Say 'STAK003E MAXJOBS PARAMETER IS NOT NUMBERIC'\n    Exit 12\n  End\n  If MAXJOBS <1 | MAXJOBS > 99 then do\n    Say 'STAK004E MAXJOBS PARAMETER MUST BE BETWEEN 1 AND 99'\n    Exit 12\n  End\nEnd\nElse\n  MAXJOBS  = 5              /* default of 5 jobs generated           */\nIf RUNMODE = '' then RUNMODE = PROD\nElse do\n  If RUNMODE <> PROD & RUNMODE <> TEST then do\n    Say 'STAK005E INVALID RUN MODE SPECIFIED'\n    Say 'STAK006E RUN MODE MUST BE EITHER \"PROD\" OR \"TEST\"'\n    Exit 12\n  End /* if */\nEnd  /* else  */\n/*********************************************************************/\nNUMERIC DIGITS 12\n/*********************************************************************/\n/* B E G I N    C U S T O M I Z A T I O N    S E C T I O N           */\n/*********************************************************************/\n/* The values in the box below can be customized for your            */\n/* environment.                                                      */\n/*********************************************************************/\nSTARTNUM = 000001           /* ignore tapes with volser < 000001     */\nENDNUM   = 999999           /* ignore tapes with volser > 999999     */\nEXDAYS   = 30               /* ignore tapes that will exp in 30 days */\nRANGE    = 90               /* retpd cntl expdt range o.k. to stack  */\nCATCDATE = 60               /* ctlg cntl cdate must be 60 days old   */\nJOBPRE   = 'TPSTAK'         /* job name prefix - 6 chars. or less    */\nACCT     = 'SYS,9999'       /* acct info for generated jcl jobcards  */\nEXCLASS  = 'A'              /* execution class for generated jobs    */\nMSGCL    = 'X'              /* message class for generated jobs      */\nTPUNITI  = 'CART'           /* tape unit name for jcl - input tapes  */\nTPUNITO  = 'CART'           /* tape unit name for jcl - output tapes */\nIDRC     = 'YES'            /* output tapes will use IDRC (yes or no)*/\n /********************************************************************/\n /*  Sample values for 3480/3490 18-track                            */\n /********************************************************************/\n /* MAXHOLD  = 200000000 */ /* 18 track tape will hold 200M          */\n /* TAPEFULL = 185000000 */ /* start new tape if at least 185M       */\n /* SKIPAMT  =  75000000 */ /* if tape has  75M or more, skip it     */\n /* COMPRESS = 50        */ /* assume 50% compression for IDRC tapes */\n /********************************************************************/\n /*  Sample values for 3490E 36-track                                */\n /********************************************************************/\n /* MAXHOLD  = 400000000 */ /* 36 track tape will hold 400M          */\n /* TAPEFULL = 375000000 */ /* start new tape if at least 375M       */\n /* SKIPAMT  = 150000000 */ /* if tape has 150M or more, skip it     */\n /* COMPRESS = 50        */ /* assume 50% compression for IDRC tapes */\n /********************************************************************/\n /*  Sample values for 3490E 36-track extended capacity              */\n /********************************************************************/\n /* MAXHOLD  = 800000000 */ /* 3490E 36 track tape will hold 800M    */\n /* TAPEFULL = 750000000 */ /* start new tape if at least 750M       */\n /* SKIPAMT  = 150000000 */ /* if tape has 150M or more, skip it     */\n /* COMPRESS = 50        */ /* assume 50% compression for IDRC tapes */\n /********************************************************************/\n /*  Sample values for 3590 128-track                                */\n /********************************************************************/\n /* MAXHOLD  = 10000000000 */ /* 3590 tape will hold 10,000M (10G)   */\n /* TAPEFULL = 8000000000  */ /* start new tape if at least 8G       */\n /* SKIPAMT  = 1000000000  */ /* if tape has 1G or more, skip it     */\n /* COMPRESS = 66        */ /* assume 66% compression for LZ-1 tapes */\n /********************************************************************/\n /*  Sample values for 3590 128-track extended capacity              */\n /********************************************************************/\n /* MAXHOLD  = 20000000000 */ /* 3590 tape will hold 20,000M (20G)   */\n /* TAPEFULL = 15000000000 */ /* start new tape if at least 15G      */\n /* SKIPAMT  = 2000000000  */ /* if tape has 2G or more, skip it     */\n /* COMPRESS = 66        */ /* assume 66% compression for LZ-1 tapes */\n /********************************************************************/\n /*  Sample values for 3590E 256-track                               */\n /********************************************************************/\n /* MAXHOLD  = 20000000000 */ /* 3590E tape will hold 20,000M (20G)  */\n /* TAPEFULL = 15000000000 */ /* start new tape if at least 15G      */\n /* SKIPAMT  = 2000000000  */ /* if tape has 2G or more, skip it     */\n /* COMPRESS = 66        */ /* assume 66% compression for LZ-1 tapes */\n /********************************************************************/\n /*  Sample values for 3590E 256-track extended capacity             */\n /********************************************************************/\n /* MAXHOLD  = 40000000000 */ /* 3590E tape will hold 40,000M (40G)  */\n /* TAPEFULL = 30000000000 */ /* start new tape if at least 30G      */\n /* SKIPAMT  = 5000000000  */ /* if tape has 5G or more, skip it     */\n /* COMPRESS = 66        */ /* assume 66% compression for LZ-1 tapes */\n /********************************************************************/\n /*  Sample values for STK 9840A / 9840B                             */\n /********************************************************************/\n /* MAXHOLD  = 20000000000 */ /* tape will hold 20,000M (20G)        */\n /* TAPEFULL = 15000000000 */ /* start new tape if at least 15G      */\n /* SKIPAMT  = 2000000000  */ /* if tape has 2G or more, skip it     */\n /* COMPRESS = 66        */ /* assume 66% compression for LZ-1 tapes */\n /********************************************************************/\n /*  Sample values for STK 9840C                                     */\n /********************************************************************/\n /* MAXHOLD  = 40000000000 */ /* tape will hold 40,000M (40G)        */\n /* TAPEFULL = 30000000000 */ /* start new tape if at least 30G      */\n /* SKIPAMT  = 5000000000  */ /* if tape has 5G or more, skip it     */\n /* COMPRESS = 66        */ /* assume 66% compression for LZ-1 tapes */\n /********************************************************************/\n /*  Sample values for STK Timberline                                */\n /********************************************************************/\n /* MAXHOLD  = 1600000000 */ /* tape will hold 1,600M                */\n /* TAPEFULL = 1000000000 */ /* start new tape if at least 1,000M    */\n /* SKIPAMT  = 100000000 */  /* if tape has 100M or more, skip it    */\n /* COMPRESS = 50        */ /* assume 50% compression for IDRC tapes */\n /********************************************************************/\n /*  Sample values for STK Redwood 10G Cartridge                     */\n /********************************************************************/\n /* MAXHOLD  = 10000000000 */ /* tape will hold 10,000M (10G)        */\n /* TAPEFULL = 8000000000  */ /* start new tape if at least 8G       */\n /* SKIPAMT  = 1000000000  */ /* if tape has 1G or more, skip it     */\n /* COMPRESS = 50        */ /* assume 50% compression for IDRC tapes */\n /********************************************************************/\n /*  Sample values for STK Redwood 25G Cartridge                     */\n /********************************************************************/\n /* MAXHOLD  = 25000000000 */ /* tape will hold 25,000M (25G)        */\n /* TAPEFULL = 15000000000 */ /* start new tape if at least 15G      */\n /* SKIPAMT  = 2000000000  */ /* if tape has 2G or more, skip it     */\n /* COMPRESS = 50        */ /* assume 50% compression for IDRC tapes */\n /********************************************************************/\n /*  Sample values for STK Redwood 50G Cartridge                     */\n /********************************************************************/\n /* MAXHOLD  = 50000000000 */ /* tape will hold 50,000M (50G)        */\n /* TAPEFULL = 40000000000 */ /* start new tape if at least 40G      */\n /* SKIPAMT  = 5000000000  */ /* if tape has 5G or more, skip it     */\n /* COMPRESS = 50        */ /* assume 50% compression for IDRC tapes */\n /********************************************************************/\nMAXHOLD  = 400000000        /* 36 track tape will hold 400M          */\nTAPEFULL = 375000000        /* start new tape if at least 375M       */\nSKIPAMT  = 150000000        /* if tape has 150M or more, skip it     */\nCOMPRESS = 50               /* assume 50% compression for IDRC tapes */\nMAXVB    = 90               /* assume 90% of vb records are max      */\nMAXLINES = 55               /* max lines per page on report output   */\nCOMPANY = 'Y O U R       C O M P A N Y       N A M E'   /*rpt heading*/\n/*********************************************************************/\n/* E N D    C U S T O M I Z A T I O N    S E C T I O N               */\n/*********************************************************************/\nIf Length(JOBPRE) > 6 then do\n  Say 'STAK007E JOB NAME PREFIX (JOBPRE) MUST BE 6 CHARACTERS OR LESS'\n  Exit 12\nEnd\n/*********************************************************************/\n/*  Make sure jcl variables are in upper case to prevent jcl errors  */\n/*********************************************************************/\nJOBPRE   = Translate(JOBPRE)\nACCT     = Translate(ACCT)\nEXCLASS  = Translate(EXCLASS)\nMSGCL    = Translate(MSGCL)\nTPUNITI  = Translate(TPUNITI)\nTPUNITO  = Translate(TPUNITO)\n/*********************************************************************/\n/*  Initialize counters, flags, and run date.                        */\n/*********************************************************************/\nCOMPANY = Center(COMPANY,70)   /* center company name on report      */\nRECNUM   = 1           /* current input record number                */\nNEWTAPE  = 'YES'       /* initialize new stacked tape flag to 'YES'  */\nPAGENUM  = '  1'       /* report page number count                   */\nTOTAL    = 0           /* count of stacked tapes in all jobs         */\nGENJOBS  = 0           /* count of generated jobs                    */\nCALL RDATE(TODAY)                  /* Get number of days             */\nDATEN = Substr(RESULT,16,5)        /* NNNNN   date from RDATE        */\nDATEW    = Date('W')               /* day of week                    */\nDATEM    = Date('M')               /* month                          */\nDATEND   = Substr(Date('N'),1,2)   /* day of month                   */\nDATEND   = Strip(DATEND)           /* remove blanks for days 1-9     */\nDATESY   = Substr(Date('S'),1,4)   /* year                           */\nDATERUN  = DATEW', 'DATEM' 'DATEND', 'DATESY   /* rpt date heading   */\nDATERUN = Translate(DATERUN)   /* convert date heading to upper case */\nDATERUN = Left(DATERUN,30,' ')  /* ensure length is always 30        */\nDATEJ    = Date('J')               /* Julian YYDDD                   */\nDATEJ    = DATESY || '/' || Substr(DATEJ,3,3)  /* Julian YYYY/DDD    */\n/*********************************************************************/\n/* Begin search for tapes to stack                                   */\n/*********************************************************************/\nDo I = 1 to MAXJOBS\nDo forever\n  \"EXECIO 1 DISKR TMC\" RECNUM     /* put input record on data stack  */\n  If rc <> 0 then leave  /* no more records - exit                   */\n  RECNUM = RECNUM + 1 /* add 1 to record count                       */\n  Parse pull INREC    /* read input record from data stack           */\n  /*                                                                 */\n  /*  If the record is a DSNB we are done with the TMC               */\n  /*                                                                 */\n  If Substr(INREC,1,1) = X2c('FF') then leave  /* DSNBs - done w/TMC */\n  /*                                                                 */\n  /* Check for TMC control records:                                  */\n  /*                                                                 */\n  VOLSER  = Substr(INREC,1,6)\n  If VOLSER = 'TMSCTL' then iterate      /* TMS control records      */\n  /*                                                                 */\n  /* Check flag1 bits :                                              */\n  /*  x'02' = volume in delete status                                */\n  /*  x'04' = volume in scratch status                               */\n  /*  x'10' = volume closed by abend                                 */\n  /*                                                                 */\n  /* If any of the above bits are on - then get another record       */\n  /*                                                                 */\n  FLAG1  = Substr(INREC,85,1)\n  CHKDEL = C2d(Bitand(FLAG1,'02'x))   /* check for B'0000 0010'      */\n  CHKSCR = C2d(Bitand(FLAG1,'04'x))   /* check for B'0000 0100'      */\n  CHKABN = C2d(Bitand(FLAG1,'10'x))   /* check for B'0001 0000'      */\n  If CHKDEL \u00ac< 2 | CHKSCR \u00ac< 4 | CHKABN \u00ac< 16 then iterate\n  /*                                                                 */\n  /*  If any of the following conditions are true - get              */\n  /*  another record.                                                */\n  /*                                                                 */\n  /*   1) The tape volser < STARTNUM or > ENDNUM                     */\n  /*   2) The tape is a 9 track (3420) tape                          */\n  /*   3) The tape is a FDRABR tape                                  */\n  /*   4) The tape is a DFHSM  tape                                  */\n  /*   5) The tape is vaulted                                        */\n  /*   6) The tape is part of a multi-volume set                     */\n  /*   7) The tape is a multi- file tape (tape has DSNBs)            */\n  /*                                                                 */\n  If VOLSER < STARTNUM | VOLSER > ENDNUM then iterate\n  If Substr(INREC,89,1) = X2c('80') then iterate /* 9 track (3420)   */\n  If Substr(INREC,7,6) = 'FDRABR' then iterate /* FDR/ABR tapes      */\n  If Substr(INREC,7,5) = 'DFHSM'  then iterate /* DFHSM tapes        */\n /*If Substr(INREC,109,4) <> X2c('00000000') then iterate *//*vaulted*/\n  If Substr(INREC,109,1) <=' '              then iterate /* vaulted  */\n  If Substr(INREC,57,6) <> X2c('000000000000') then iterate /*mlt-vol*/\n  If Substr(INREC,75,2) <> X2c('0000') then iterate /* multi file    */\n  /*                                                                 */\n  /* Check for standard label tape bit                               */\n  /*  x'02' = standard label                                         */\n  /*                                                                 */\n  TMLTYPE = Substr(INREC,91,1)\n  CHKLABL = C2d(Bitand(TMLTYPE,'02'x))   /* check for B'0000 0010'   */\n  If CHKLABL < 2 then iterate    /* sl bit off - get another tape    */\n  /*                                                                 */\n  /* The following code checks expiration dates                      */\n  /*   If the first byte is x'00' it is in 20th century (19XX)       */\n  /*   If the first byte is x'01' it is in 21th century (20XX)       */\n  /*   If the first byte is x'99' it is CA-1 special keyword         */\n  /*                                                                 */\n  EXDATE  = Substr(INREC,51,4)\n  EXDATEA = Substr(INREC,51,1)\n  Select\n    When EXDATEA = X2c('00') then do /* RETPD control year 19XX      */\n      EXDATE  = C2d(EXDATE)\n      EXDATE  = D2x(EXDATE)\n      EXDATE  = Left(EXDATE,5)\n      EXDATE = '19'||Substr(EXDATE,1,2)||'/'||Substr(EXDATE,3,3)' '\n      /*                                                             */\n      /* If the tape is due to expire in the                         */\n      /* next EXDAYS days - get another record.                      */\n      /*                                                             */\n      DATEPARM = Substr(EXDATE,1,4)||' '||Substr(EXDATE,6,3)\n      Call RDATE DATEPARM\n      EXPCENT = Substr(RESULT,16,5) /* century date from RDATE */\n      If DATEN > EXPCENT - EXDAYS then iterate\n      /*                                                             */\n      JCLEXP = Strip(EXDATE)\n      CONTROL = 'RETENTION'\n    End /* when */\n    When EXDATEA = X2c('01') then do /* RETPD control year 20XX      */\n      EXDATE  = Substr(INREC,52,3)\n      EXDATE  = C2d(EXDATE)\n      EXDATE  = D2x(EXDATE,6)\n      EXDATE  = Left(EXDATE,5)\n      EXDATE = '20'||Substr(EXDATE,1,2)||'/'||Substr(EXDATE,3,3)' '\n      /*                                                             */\n      /* If the tape is due to expire in the                         */\n      /* next EXDAYS days - get another record.                      */\n      /*                                                             */\n      DATEPARM = Substr(EXDATE,1,4)||' '||Substr(EXDATE,6,3)\n      Call RDATE DATEPARM\n      EXPCENT = Substr(RESULT,16,5) /* century date from RDATE */\n      If DATEN > EXPCENT - EXDAYS then iterate\n      /*                                                             */\n      JCLEXP = Strip(EXDATE)\n      CONTROL = 'RETENTION'\n    End /* when */\n    Otherwise\n      EXDATEB = Substr(INREC,51,2)\n      If EXDATEB = X2c('9990') then do /* CATALOG control        */\n        EXDATE  = 'CATALOG  '\n        JCLEXP = '99000'\n        CONTROL = 'CATALOG'\n      End\n      Else iterate /* PERMANENT,CYCLE,LDATE, or STATS retention */\n  End  /* select */\n  /*                                                                 */\n  CDATE     = Substr(INREC,117,4)\n  CDATEA    = Substr(INREC,117,1)\n  If CDATEA = X2c(00) then do\n    CDATE     = C2d(CDATE)\n    CDATE     = D2x(CDATE)\n    CDATE     = Left(CDATE,5)\n    CDATE     = '19'||Substr(CDATE,1,2)||'/'||Substr(CDATE,3,3)\n  End /* if */\n  Else do\n    CDATE     = Substr(INREC,118,3)\n    CDATE     = C2d(CDATE)\n    CDATE     = D2x(CDATE,6)\n    CDATE     = Left(CDATE,5)\n    CDATE     = '20'||Substr(CDATE,1,2)||'/'||Substr(CDATE,3,3)\n  End /* else */\n  /*                                                               */\n  /* If stacking tapes under catalog control - make sure the       */\n  /* tape is at least CATCDATE days old                            */\n  /*                                                               */\n  If CONTROL = 'CATALOG' then do\n    DATEPARM = Substr(CDATE,1,4)||' '||Substr(CDATE,6,3)\n    Call RDATE DATEPARM\n    CDATCENT = Substr(RESULT,16,5) /* century date from RDATE */\n    If CDATCENT > DATEN - CATCDATE then iterate\n  End /* if control */\n  /*                                                                 */\n  /* If we are not on a new tape, and the expiration date doesn't    */\n  /* match the previously stacked files and was under catalog        */\n  /* control - get another tape. If the tape was under retention     */\n  /* period control - check if it falls into the default date range  */\n  /* to be stacked.                                                  */\n  /*                                                                 */\n  If NEWTAPE <> 'YES' then\n    If EXDATE <> SAVEDATE then\n      If SAVEDATE <> 'CATALOG  ' then\n        If CONTROL <> 'CATALOG' then do\n          /*                                                         */\n          DATEPARM = Substr(SAVEDATE,1,4)||' '||Substr(SAVEDATE,6,3)\n          Call RDATE DATEPARM\n          SAVECENT = Substr(RESULT,16,5) /* century date from RDATE  */\n          /*                                                         */\n          If EXPCENT < SAVECENT then\n            If SAVECENT - EXPCENT \u00ac< RANGE then iterate\n            Else nop\n          Else\n          If EXPCENT - SAVECENT \u00ac< RANGE then iterate\n        End  /* if control */\n        Else iterate /* if control  */\n      Else iterate /* if savedate */\n    Else nop     /* if exdate   */\n  Else nop     /* if newtape  */\n  /*                                                                 */\n  /* We now have an eligable tape.                                   */\n  /* Calculate how much data is on the tape.                         */\n  /* A 3480 tape holds about 200MB when it is not compacted.         */\n  /*                                                                 */\n  BLKSIZE    = C2d(Substr(INREC,97,4))\n  If BLKSIZE = 0 then iterate   /* can't copy tape with no blksize   */\n  BLKCOUNT   = C2d(Substr(INREC,101,4))\n  RECFM      = Substr(INREC,92,1)\n  /*                                                                 */\n  /* Check for variable length record file                           */\n  /*                                                                 */\n  CHKVAR     = C2d(Bitand(RECFM,'40'x))   /* check for B'0100 0000'  */\n  If CHKVAR  < 64  then VARBIT = 'OFF' /* bit off */\n    Else VARBIT  = 'ON'\n  /*                                                                 */\n  /* The following code is to check for 3480 tapes that are          */\n  /* utilizing compaction (IDRC).                                    */\n  /*                                                                 */\n  TMDEN      = Substr(INREC,90,1)\n  /*                                                                 */\n  /* The only density that should ever be found should               */\n  /* be X'E3', x'E7', x'E8', x'E9' pr x'EA' because                  */\n  /* we are already bypassing 9 track tapes in the                   */\n  /* beginning of the program.                                       */\n  Select\n /* When TMDEN = X2c('03') then  */\n /*      TMDEN = '200 '          */\n /* When TMDEN = X2c('43') then  */\n /*      TMDEN = '556 '          */\n /* When TMDEN = X2c('83') then  */\n /*      TMDEN = '800 '          */\n /* When TMDEN = X2c('C3') then  */\n /*      TMDEN = '1600'          */\n /* When TMDEN = X2c('D3') then  */\n /*      TMDEN = '6250'          */\n    When TMDEN = X2c('E3') then  /* 3480 no idrc  */\n         TMDEN = '38K '\n    When TMDEN = X2c('E7') then  /* 3480 with idrc */\n         TMDEN = '38KC'\n    When TMDEN = X2c('E8') then  /* 3590           */\n         TMDEN = '3590'\n    When TMDEN = X2c('E9') then  /* 3592           */\n         TMDEN = '3592'\n    When TMDEN = X2c('EA') then  /* 3592 WORM      */\n         TMDEN = 'WORM'\n  Otherwise\n    TMDEN = '????'\n    Say 'STAK008E UNKNOWN TAPE DENSITY FOUND - TERMINATING'\n    Say 'STAK009E RECORD = 'RECNUM' VOLSER =  'VOLSER\n    Exit 12\n  End  /* select */\n  /*                                                                 */\n  /* Calculate approximate amount of tape used.                      */\n  /*                                                                 */\n  TAPEUSED = BLKSIZE * BLKCOUNT\n  /*                                                                 */\n  /*                                                                 */\n  /* If variable records - assume MAXVB% are the max lrecl           */\n  /*                                                                 */\n  If VARBIT = 'ON' then TAPEUSED = TAPEUSED * (MAXVB /100)\n  /*                                                                 */\n  /* If compacted tape (IDRC) - assume COMPRESS% compaction - or     */\n  /* if uncompacted tape and the output will be compacted            */\n  /* assume COMPRESS% compaction                                     */\n  /*                                                                 */\n  If TMDEN = '38KC' | IDRC = 'YES' then ,\n     TAPEUSED = TAPEUSED * (1-(COMPRESS/100))\n  /*                                                                 */\n  /* Add in the Inter Block Gaps (IBG)                               */\n  /*                                                                 */\n  /* The density of a 3480 cartrige is:                              */\n  /* 1491 characters per millimeter American National Standard       */\n  /*                                                                 */\n  /*   1 inch  =  2.54  centimeters or 25.4 millimeters              */\n  /*   1 character   = 1 byte                                        */\n  /*   1491 * 25.4 = 37871 bytes per inch  (38K BPI)                 */\n  /*                                                                 */\n  /* The IBG is .08 inches                                           */\n  /*   37871 * .08 = 3030 bytes                                      */\n  /*                                                                 */\n  If TMDEN = '38K' | TMDEN = '38KC' then , /* add in                 */\n  TAPEUSED = TAPEUSED + (BLKCOUNT * 3030)  /*        3480 IBGs       */\n  /*                                                                 */\n  /* If the tape is more then SKIPAMT full - get another tape        */\n  /*                                                                 */\n  If TAPEUSED > SKIPAMT  then iterate   /* tape too full - skip it   */\n  /*                                                                 */\n  If NEWTAPE = 'YES' then do\n    SAVEDATE = EXDATE\n    STAKUSED = TAPEUSED\n    NEWTAPE  = 'NO'\n    F =  1   /* file number */\n    Call SAVE_VARS    /* save tape tmc info */\n  End\n  Else do /* not a new tape */\n  /*                                                                 */\n  /* The following code is to make sure the selected tape to be      */\n  /* stacked will fit on the existing tape. If it won't fit - get    */\n  /* another tape.                                                   */\n  /*                                                                 */\n    STAKTEMP = STAKUSED + TAPEUSED\n    If STAKTEMP > MAXHOLD   then iterate /* won't fit on this tape */\n  /*                                                                 */\n    Else do   /* tape will fit */\n      STAKUSED = STAKTEMP\n      F = F + 1 /* file number */\n      Call SAVE_VARS    /* save tape tmc info */\n      If STAKUSED > TAPEFULL then do   /* tape is full enough */\n        NEWTAPE = 'YES'\n        Call CREATE_JOB    /* tape is full - create stack job        */\n        Leave /* leave do forever loop */\n      End /* if stakused */\n    End  /* else do - tape will fit*/\n  End /* else do - not a new tape*/\nEnd /* Do forever */\nEnd I /* Do  */\nIf GENJOBS < MAXJOBS then\n  If F > 1 then Call CREATE_JOB    /*  create final stack job        */\n/******************************************/\n/* DONE WITH PROCESSING - WRITE TOTALS    */\n/******************************************/\nRECNUM  = Right(RECNUM-1,7,'0')\nTOTAL   = Right(TOTAL,7,'0')\nGENJOBS = Right(GENJOBS,7,'0')\nIf RUNMODE = 'PROD' then\n  Queue     '1'DATERUN||COMPANY||'                      PAGE 'PAGENUM\nElse\n  Queue     '1'DATERUN||COMPANY||' *** TEST MODE ***    PAGE 'PAGENUM\nQueue   '0                                          ' ,\n        '        TAPES TO BE STACKED - TOTALS'\nQueue   '      '\nQueue   '      '\nQueue   '      '\nQueue   ' 'RECNUM' TMC RECORDS WERE READ'\nQueue   ' 'TOTAL' TAPES WERE SELECTED TO BE STACKED'\nQueue   ' 'GENJOBS JOBTYPE' JOBS WERE GENERATED'\n\"EXECIO 8 DISKW REPORT\"\nIf GENJOBS < MAXJOBS then do\n  Say 'STAK010I THE NUMBER OF JOBS GENERATED WAS LESS THAN 'MAXJOBS\n  Queue '     '\n  Queue  ' ** THE NUMBER OF JOBS GENERATED WAS LESS THAN 'MAXJOBS\n  \"EXECIO 2 DISKW REPORT\"\n  If F = 1 then do\n    Queue  ' ** BECAUSE NO TAPES WERE FOUND THAT COULD BE STACKED'\n    Queue  ' ** WITH VOLSER 'STKVOL.F' - EXPIRATION 'STKEXP.F\n    \"EXECIO 2 DISKW REPORT\"\n  End\n  Else do\n    Queue  ' ** BECAUSE THERE WERE NO MORE TMC RECORDS TO READ'\n    \"EXECIO 1 DISKW REPORT\"\n  End\n  RETCODE = 4\nEnd\nElse RETCODE = 0\nIf JOBTYPE = 'COPYCAT' then do\n  Queue  ' '\n  Queue  ' *********************************************************'\n  Queue  ' *** NOTE: COPYCAT MAY NOT USE THE SAME FILE STACKING  ***'\n  Queue  ' ***       SEQUENCE THAT IS SHOWN IN THIS REPORT.      ***'\n  Queue  ' ***                                                   ***'\n  Queue  ' ***       SEE THE COPYCAT DETAIL REPORT FOR THE       ***'\n  Queue  ' ***       ACTUAL ORDER THAT WAS USED.                 ***'\n  Queue  ' *********************************************************'\n  \"EXECIO 8 DISKW REPORT\"\nEnd /* if */\n/******************************************/\n/* CLOSE FILES AND EXIT                   */\n/******************************************/\n\"EXECIO 0 DISKR TMC (FINIS\"\n\"EXECIO 0 DISKW REPORT (FINIS\"\nIf JOBTYPE = 'IEBGENER' then\n  \"EXECIO 0 DISKW GENER (FINIS\"\nElse\n  \"EXECIO 0 DISKW COPYCAT (FINIS\"\nExit RETCODE\n/*********************************************************************/\n/* SUBROUTINE TO WRITE REPORT PAGE HEADING                           */\n/*********************************************************************/\nPUT_HEADING:\nIf RUNMODE = 'PROD' then\n  Queue '1'DATERUN||COMPANY||'                      PAGE 'PAGENUM\nElse\n  Queue '1'DATERUN||COMPANY||' *** TEST MODE ***    PAGE 'PAGENUM\nQueue   '0                                          ' ,\n        '     TAPES TO BE STACKED - JOB NUMBER 'GENJOBS\nCOLHDA1 = '0  VOLUME   DATASET'\nCOLHDA2 = 'CREATE      CREATE   EXPIRE      CREATING    '\nCOLHDA3 = 'TAPE    NEW    NEW'\nQueue     Insert(COLHDA2||COLHDA3,COLHDA1,60)\nCOLHDB1 = '   SERIAL   NAME   '\nCOLHDB2 = 'DATE        TIME     DATE        JOB         '\nCOLHDB3 = 'DEN     SEQ    DISP'\nQueue     Insert(COLHDB2||COLHDB3,COLHDB1,60)\nQueue   '     '\n\"EXECIO 5 DISKW REPORT\"\nLINECNT = 7\nPAGENUM = PAGENUM + 1\nPAGENUM = Right(PAGENUM,3,' ')\nReturn\n/*********************************************************************/\n/* SUBROUTINE TO SAVE VARIABLES                                      */\n/*********************************************************************/\nSAVE_VARS:\n/*                                                                   */\n/* Copy previously determined variables                              */\n/*                                                                   */\nSTKVOL.F  = VOLSER\nSTKEXP.F  = EXDATE\nSTKJEXP.F = JCLEXP\nSTKDEN.F  = TMDEN\nSTKCRE.F  = CDATE\n/*                                                                   */\n/* Extract other variables from input record                         */\n/*                                                                   */\nDSN.F     = Substr(INREC,7,44)\nCTIME.F = C2d(Substr(INREC,122,3))\nCTIME.F = D2x(CTIME.F,5)\nCTIME.F = Left(CTIME.F,4)\nCTIME.F = Substr(CTIME.F,1,2)||':'||Substr(CTIME.F,3,2)\nCJOB.F    = Substr(INREC,125,8)\nCall CHECK_CAT   /* check if tape is cataloged */\nReturn\n/*********************************************************************/\n/* SUBROUTINE TO CALL IDCAMS TO SEE IF TAPE IS CATALOGED             */\n/*********************************************************************/\nCHECK_CAT:\nQueue  ' LISTC ENT('DSN.F') VOL'\n\"EXECIO 1 DISKW SYSIN (FINIS\"\nAddress LINK \"IDCAMS\"\n/*********************************************************************/\n/* If the dataset is cataloged - we need to make sure the volser     */\n/* that is in the catalog is the same one we are checking.           */\n/*********************************************************************/\nIf RC = 0 then do /* dataset is cataloged                            */\n  \"EXECIO 1 DISKR SYSPRINT 10 (FINIS\" /* put 10th rec on data stack  */\n  Parse pull PRTREC    /* read record from data stack                */\n  If Substr(PRTREC,27,6) = STKVOL.F then do /* volser matches catalog*/\n    INDISP.F  = UNCATLG\n    OUTDISP.F = CATLG\n  End\n  Else do     /* volser is not the same one that is cataloged        */\n    INDISP.F  = KEEP\n    OUTDISP.F = KEEP\n  End\nEnd /* if rc = 0 */\nElse do /* dataset is not cataloged */\n   INDISP.F  = KEEP\n   OUTDISP.F = KEEP\nEnd\nReturn\n/*********************************************************************/\n/* SUBROUTINE TO CREATE STACKING JOB                                 */\n/*********************************************************************/\nCREATE_JOB:\nGENJOBS = GENJOBS + 1\nJOBNUM  = Right(GENJOBS,2,'0')\nCall PUT_HEADING  /* rpt page heading subroutine */\nIf JOBTYPE = 'IEBGENER' then\n  Call NEW_GENER    /* build iebgener jobcard jcl subroutine */\nElse\n  Call NEW_CPYCAT   /* build copycat jcl subroutine */\nDo J = 1 to F\n  Call PUT_REC     /* write report record */\n  If JOBTYPE = 'IEBGENER' then do\n    Call PUT_JCL      /* build iebgener jcl copy step subroutine */\n    Call TMS_UPDATE   /* build tms update step subroutine */\n  End\n  Else\n    Call PUT_VOLSER  /* create copycat volser control stmts */\nEnd /* do */\nReturn\n/*********************************************************************/\n/* SUBROUTINE TO WRITE AN OUTPUT REPORT RECORD                       */\n/*********************************************************************/\nPUT_REC:\nSEQ.J = Right(J,3,'0')\nIf LINECNT = MAXLINES then CALL PUT_HEADING\nOUT1    = '   'STKVOL.J'   'DSN.J\nOUT2    = STKCRE.J'    'CTIME.J'    'STKEXP.J'   'CJOB.J'    '\nOUT3    = STKDEN.J'    'SEQ.J'    'OUTDISP.J\nQueue   Insert(OUT2||OUT3,OUT1,60)\n\"EXECIO 1 DISKW REPORT\"\nTOTAL   = TOTAL + 1\nLINECNT = LINECNT + 1\nReturn\n/*********************************************************************/\n/* SUBROUTINE TO CREATE JOBCARD JCL FOR A NEW IEBGENER JOB           */\n/*********************************************************************/\nNEW_GENER:\nQueue   '//'||JOBPRE||JOBNUM'  JOB ('||ACCT||'),''STACK TAPES'','\nQueue   '//             CLASS='||EXCLASS||',MSGCLASS='||MSGCL||','\nQueue   '//             MSGLEVEL=(1,1),TYPRUN=HOLD'\n\"EXECIO 3 DISKW GENER\"\nReturn\n/*********************************************************************/\n/* SUBROUTINE TO CREATE JCL STATEMENTS FOR A NEW CA-1 COPYCAT JOB    */\n/*********************************************************************/\nNEW_CPYCAT:\nQueue   '//'||JOBPRE||JOBNUM'  JOB ('||ACCT||'),''STACK TAPES'','\nQueue   '//             CLASS='||EXCLASS||',MSGCLASS='||MSGCL||','\nQueue   '//             MSGLEVEL=(1,1),TYPRUN=HOLD'\nQueue   '//COPYCAT      EXEC PGM=COPYCAT'\nQueue   '//T3480IN  DD  UNIT=('||TPUNITI||',,DEFER)'\nQueue   '//TAPEOUT  DD  UNIT=('||TPUNITO||',,DEFER),'\nIf IDRC = 'YES' then\n  Queue '//             DCB=TRTCH=COMP'\nElse\n  Queue '//             DCB=TRTCH=NOCOMP'\nQueue   '//SYSPRINT DD  SYSOUT=*'\nQueue   '//SYSOUT   DD  SYSOUT=*'\nQueue   '//TMSRPT   DD  SYSOUT=*'\nQueue   '//CCRPT    DD  SYSOUT=*'\nQueue   '//SORTWK01 DD  UNIT=SYSDA,SPACE=(CYL,(1,1))'\nQueue   '//SORTWK02 DD  UNIT=SYSDA,SPACE=(CYL,(1,1))'\nQueue   '//SORTWK03 DD  UNIT=SYSDA,SPACE=(CYL,(1,1))'\nQueue   '//SYSIN    DD  *'\nQueue   'FILECOPY'\nIf RUNMODE = 'PROD' then\n  Queue 'FILES=ALL,SAVEINFO=YES,RECATALOG=PREV,INDISP=RETPD=0'\nElse\n  Queue 'FILES=ALL,SAVEINFO=YES,RECATALOG=NONE,OUTDISP=RETPD=1'\nQueue   'INPUT=*'\n\"EXECIO 18 DISKW COPYCAT\"\nReturn\n/*********************************************************************/\n/* SUBROUTINE TO CREATE JCL FOR IEBGENER COPY STEP                   */\n/*********************************************************************/\nPUT_JCL:\nDSN.J = Strip(DSN.J)  /* remove trailing blanks from dsn */\nQueue    '//************************************************'\nQueue    '//* 'JOBPRE||JOBNUM' IEBGENER STACK STEP NUMBER '||J\nQueue    '//************************************************'\nIf J = 1 then\n  Queue  '//STEP'||J'   EXEC PGM=IEBGENER'\nElse\n  Queue  '//STEP'||J'   EXEC PGM=IEBGENER,COND=(0,NE)'\nQueue    '//SYSPRINT DD  SYSOUT=*'\nQueue    '//SYSIN    DD  DUMMY'\nQueue    '//SYSUT1   DD  DSN='||DSN.J||','\nQueue    '//             UNIT='||TPUNITI||',VOL=SER='||STKVOL.J||','\nIf RUNMODE = 'PROD' then\n  Queue  '//             DISP=(SHR,'||INDISP.J||',KEEP)'\nElse\n  Queue  '//             DISP=(SHR,KEEP,KEEP)'\nQueue    '//SYSUT2   DD  DSN='||DSN.J||','\nQueue    '//             UNIT='||TPUNITO||','\nIf RUNMODE = 'PROD' then\n  Queue  '//             LABEL=('||J||',SL,EXPDT='||STKJEXP.J'),'\nElse\n  Queue  '//             LABEL=('||J||',SL,RETPD=1),'\nIf RUNMODE = 'PROD' then\n  Queue  '//             DISP=(NEW,'||OUTDISP.J||',DELETE),'\nElse\n  Queue  '//             DISP=(NEW,KEEP,DELETE),'\nIf J = 1 then\n  Queue  '//             VOL=(,RETAIN),'\nElse\n  Queue  '//             VOL=(,RETAIN,REF=*.STEP'||J-1||'.SYSUT2),'\nIf IDRC = 'YES' then\n  Queue  '//             DCB=TRTCH=COMP'\nElse\n  Queue  '//             DCB=TRTCH=NOCOMP'\n\"EXECIO 15 DISKW GENER\"\nReturn\n/*********************************************************************/\n/* SUBROUTINE TO CREATE VOLSER CONTROL STATEMENTS FOR COPYCAT JOB    */\n/*********************************************************************/\nPUT_VOLSER:\nQueue STKVOL.J\n\"EXECIO 1 DISKW COPYCAT\"\nReturn\n/*********************************************************************/\n/* SUBROUTINE TO CREATE TMSUPDTE STEP TO EXPIRE COPIED TAPES         */\n/*********************************************************************/\nTMS_UPDATE:\nIf RUNMODE <> 'PROD' then return\nQueue  '//************************************************'\nQueue  '//* 'JOBPRE||JOBNUM' TMSUPDTE STEP TO EXPIRE 'STKVOL.J\nQueue  '//************************************************'\nQueue  '//EXPIRE'||J 'EXEC PGM=TMSUPDTE,PARM='AUDIT',COND=(0,NE)'\nQueue  '//TMSRPT   DD  SYSOUT=*'\nQueue  '//SYSIN    DD  *'\nQueue  'VOL '||STKVOL.J||',NODSN'\nQueue  'REP EXPDT='||DATEJ\n\"EXECIO 8 DISKW GENER\"\nReturn\n\n/* rexx */\nRDATE:\n/*                                       */\n/* AUTHOR: Mark Zelden                   */\n/*                                       */\n/************************************************/\n/* Convert MM DD YYYY , YYYY DDD, or NNNNN to   */\n/* standard date output that includes the day   */\n/* of the week and the number of days (NNNNN)   */\n/* from January 1, 1900. This is not the same   */\n/* as the Century date! Valid input dates range */\n/* from 01/01/1900 through 12/31/2172.          */\n/*                                              */\n/* A parm of \"TODAY\" can also be passed to      */\n/* the date conversion routine.                 */\n/* MM DD YYYY can also be specifed as           */\n/* MM/DD/YYYY or MM-DD-YYYY.                    */\n/*                                              */\n/* The output format is always as follows:      */\n/*      MM/DD/YYYY.JJJ NNNNN WEEKDAY            */\n/*                                              */\n/* The above value will be put in the special   */\n/* REXX variable \"RESULT\"                       */\n/* example: CALL RDATE TODAY                    */\n/* example: CALL RDATE 1996 300                 */\n/* example: CALL RDATE 10 26 1996               */\n/* example: CALL RDATE 10/26/1996               */\n/* example: CALL RDATE 10-26-1996               */\n/* example: CALL RDATE 35363                    */\n/* result:  10/26/1996.300 35363 Saturday       */\n/************************************************/\narg P1 P2 P3\n\nIf Pos('/',P1) <> 0 | Pos('-',P1) <> 0 then do\n  PX =  Translate(P1,'  ','/-')\n  Parse var PX P1 P2 P3\nEnd\n\nJULTBL = '000031059090120151181212243273304334'\nDAY.0 = 'Sunday'\nDAY.1 = 'Monday'\nDAY.2 = 'Tuesday'\nDAY.3 = 'Wednesday'\nDAY.4 = 'Thursday'\nDAY.5 = 'Friday'\nDAY.6 = 'Saturday'\n\nSelect\n  When P1 = 'TODAY' then do\n    P1 = Substr(date('s'),5,2)\n    P2 = Substr(date('s'),7,2)\n    P3 = Substr(date('s'),1,4)\n    call CONVERT_MDY\n    call THE_END\n  end\n  When P2 = '' & P3 = '' then do\n    call CONVERT_NNNNN\n    call THE_END\n  end\n  When P3 = '' then do\n    call CONVERT_JDATE\n    call DOUBLE_CHECK\n    call THE_END\n  end\n  otherwise do\n    call CONVERT_MDY\n    call DOUBLE_CHECK\n    call THE_END\n  end\nend /* end select */\n/* say RDATE_VAL; exit 0 */\nreturn RDATE_VAL\n/**********************************************/\n/*  E N D    O F   M A I N L I N E   C O D E  */\n/**********************************************/\n\nCONVERT_MDY:\nif P1<1 | P1>12 then do\n  say 'Invalid month passed to date routine'\n  exit 12\nend\nif P2<1 | P2>31 then do\n  say 'Invalid day passed to date routine'\n  exit 12\nend\nif (P1=4 | P1=6 | P1=9 | P1=11) & P2>30 then do\n  say 'Invalid day passed to date routine'\n  exit 12\nend\nif P3<1900 | P3>2172 then do\n  say 'Invalid year passed to date routine. Must be be 1900-2172'\n  exit 12\nend\nBASE   = Substr(JULTBL,((P1-1)*3)+1,3)\nif (P3//4=0 & P3<>1900 & P3<>2100) then LEAP= 1\n  else LEAP = 0\nif P1 > 2 then BASE = BASE+LEAP\nJJJ = BASE + P2\n\nMM   = P1\nDD   = P2\nYYYY = P3\nreturn\n\nCONVERT_NNNNN:\nif P1<1 | P1>99712 then do\n  say 'Invalid date passed to date routine. NNNNN must be 1-99712'\n  exit 12\nend\n/* Determine YYYY and JJJ */\nif P1>365 then P1=P1+1\nYEARS_X4=(P1-1)%1461\nJJJ=P1-YEARS_X4*1461\nif P1 > 73415 then JJJ = JJJ +1\nEXTRA_YEARS=(JJJ*3-3)%1096\nJJJ=JJJ-(EXTRA_YEARS*1096+2)%3\nYYYY=YEARS_X4*4+EXTRA_YEARS+1900\nP1 = YYYY ; P2 = JJJ ;  call CONVERT_JDATE\n\nCONVERT_JDATE:\nif P1<1900 | P1>2172 then do\n  say 'Invalid year passed to date routine. Must be be 1900-2172'\n  exit 12\nend\nif P2<1 | P2>366 then do\n  say 'Invalid Julian date passed to date routine'\n  exit 12\nend\nif (P1//4=0 & P1<>1900 & P1<>2100) then LEAP= 1\n  else LEAP = 0\nADJ1 = 0\nADJ2 = 0\nDo MM = 1 to 11\n   VAL1 = Substr(JULTBL,((MM-1)*3)+1,3)\n   VAL2 = Substr(JULTBL,((MM-1)*3)+4,3)\n   if MM >=2 then ADJ2 = LEAP\n   if MM >=3 then ADJ1 = LEAP\n   if P2 > VAL1+ADJ1 & P2 <= VAL2+ADJ2 then do\n        DD = P2-VAL1-ADJ1\n        MATCH = 'Y'\n        leave\n   end\nend\nif MATCH <> 'Y' then do\n    MM = 12\n    DD = P2-334-LEAP\nend\n\nYYYY = P1\nJJJ  = P2\nreturn\n\nDOUBLE_CHECK:\nif MM = 2 then do\n   if DD > 28 & LEAP = 0 then do\n     say 'Invalid day passed to date routine'\n     exit 12\n   end\n   if DD > 29 & LEAP = 1 then do\n     say 'Invalid day passed to date routine'\n     exit 12\n   end\nend\nif LEAP = 0 & JJJ > 365 then do\n  say 'Invalid Julian date passed to date routine'\n  exit 12\nend\nreturn\n\nTHE_END:\nYR_1900 = YYYY-1900\nNNNNN = (YR_1900*365) +(YR_1900+3)%4 + JJJ\nif YYYY > 1900 then NNNNN = NNNNN-1\nif YYYY > 2100 then NNNNN = NNNNN-1\nINDEX   = NNNNN//7  /* index to DAY stem */\nWEEKDAY =  DAY.INDEX\n\nDD      = Right(DD,2,'0')\nMM      = Right(MM,2,'0')\nYYYY    = Strip(YYYY)\nNNNNN   = Right(NNNNN,5,'0')\nJJJ     = Right(JJJ,3,'0')\n\nRDATE_VAL = MM||'/'||DD||'/'||YYYY||'.'||JJJ||' '||NNNNN||' '||WEEKDAY\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSOB": {"ttr": 16393, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x992/\\x01\\x08'\\x7f\\x13\\x10\\x00\\x1a\\x00\\x1a\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf7@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "2008-10-03T13:10:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "CBT477"}, "text": "/* REXX */\n/*                           */\n/* AUTHOR: MARK ZELDEN       */\n/*                           */\n/* TRACE ?I */\nparse arg TSOCMD\naddress ISPEXEC \"CONTROL ERRORS RETURN\"\naddress TSO\nddnm = 'DD'||random(1,99999)    /* choose random ddname  */\njunk = msg(off)\n\"ALLOC FILE(\"||ddnm||\") UNIT(VIO) NEW TRACKS SPACE(90,90) DELETE\",\n\" REUSE LRECL(172) RECFM(F B) BLKSIZE(8944)\"\njunk = msg(on)\n/*                                    */\n/*  issue tso commnd and trap output  */\n/*                                    */\njunk=outtrap(LINE.)\nTSOCMD\njunk=outtrap('off')\n/*                                    */\n\"EXECIO\" line.0  \"DISKW\" ddnm \"(STEM LINE. FINIS\"\naddress ISPEXEC \"LMINIT DATAID(TEMP) DDNAME(\"||ddnm||\")\"\naddress ISPEXEC \"BROWSE DATAID(\"||temp\")\"\naddress ISPEXEC \"LMFREE DATAID(\"||temp\")\"\njunk = msg(off)\n\"FREE FI(\"||ddnm||\")\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSOE": {"ttr": 16395, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x992/\\x01\\x08'\\x7f\\x13\\x10\\x00\\x1a\\x00\\x1a\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf7@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "2008-10-03T13:10:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "CBT477"}, "text": "/* REXX */\n/*                           */\n/* AUTHOR: MARK ZELDEN       */\n/*                           */\n/* TRACE ?I */\nparse arg TSOCMD\naddress ISPEXEC \"CONTROL ERRORS RETURN\"\naddress TSO\nddnm = 'DD'||random(1,99999)    /* choose random ddname  */\njunk = msg(off)\n\"ALLOC FILE(\"||ddnm||\") UNIT(VIO) NEW TRACKS SPACE(90,90) DELETE\",\n\" REUSE LRECL(172) RECFM(F B) BLKSIZE(8944)\"\njunk = msg(on)\n/*                                    */\n/*  issue tso commnd and trap output  */\n/*                                    */\njunk=outtrap(LINE.)\nTSOCMD\njunk=outtrap('off')\n/*                                    */\n\"EXECIO\" line.0  \"DISKW\" ddnm \"(STEM LINE. FINIS\"\naddress ISPEXEC \"LMINIT DATAID(TEMP) DDNAME(\"||ddnm||\")\"\naddress ISPEXEC \"EDIT   DATAID(\"||temp\")\"\naddress ISPEXEC \"LMFREE DATAID(\"||temp\")\"\njunk = msg(off)\n\"FREE FI(\"||ddnm||\")\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSOR": {"ttr": 16397, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x01\\x07\\x11\\x7f\\x01\\x08'\\x7f\\x13\\x10\\x00\\x1f\\x00\\x1f\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf7@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-04-27T00:00:00", "modifydate": "2008-10-03T13:10:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "CBT477"}, "text": "/* REXX */\n/*                           */\n/* AUTHOR: MARK ZELDEN       */\n/*                           */\n/**************************************************/\n/* NOTE:  Use of this EXEC requires the REVIEW    */\n/*        command from CBT file 134 or 135.       */\n/**************************************************/\n/* REVIEW command output.  This has an advantage  */\n/* over TSOE/TSOB/TSOV in that it works under     */\n/* native TSO (TSO READY) without ISPF.           */\n/**************************************************/\n/* TRACE ?I */\nparse arg TSOCMD\naddress TSO\nddnm = 'DD'||random(1,99999)    /* choose random ddname  */\njunk = msg(off)\n\"ALLOC FILE(\"||ddnm||\") UNIT(SYSALLDA) NEW TRACKS SPACE(9,9) DELETE\",\n\" REUSE LRECL(172) RECFM(F B) BLKSIZE(8944)\"\njunk = msg(on)\n/*                                    */\n/*  issue tso commnd and trap output  */\n/*                                    */\njunk=outtrap(LINE.)\nTSOCMD\njunk=outtrap('off')\n/*                                    */\n\"EXECIO\" line.0  \"DISKW\" ddnm \"(STEM LINE. FINIS\"\naddress TSO     \"REVIEW       \"||ddnm||\"    FILE\"\njunk = msg(off)\n\"FREE FI(\"||ddnm||\")\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSOV": {"ttr": 16399, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x01\\x07\\x11\\x7f\\x01\\x08'\\x7f\\x13\\x10\\x00\\x1f\\x00\\x1f\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf7@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-04-27T00:00:00", "modifydate": "2008-10-03T13:10:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "CBT477"}, "text": "/* REXX */\n/*                           */\n/* AUTHOR: MARK ZELDEN       */\n/*                           */\n/****************************************************/\n/* There is really no advantage to using TSOV over  */\n/* TSOE since a temporary data set is used, but     */\n/* to complete the TSO* set of EXECs - here it is.  */\n/****************************************************/\n/* TRACE ?I */\nparse arg TSOCMD\naddress ISPEXEC \"CONTROL ERRORS RETURN\"\naddress TSO\nddnm = 'DD'||random(1,99999)    /* choose random ddname  */\njunk = msg(off)\n\"ALLOC FILE(\"||ddnm||\") UNIT(VIO) NEW TRACKS SPACE(90,90) DELETE\",\n\" REUSE LRECL(172) RECFM(F B) BLKSIZE(8944)\"\njunk = msg(on)\n/*                                    */\n/*  issue tso commnd and trap output  */\n/*                                    */\njunk=outtrap(LINE.)\nTSOCMD\njunk=outtrap('off')\n/*                                    */\n\"EXECIO\" line.0  \"DISKW\" ddnm \"(STEM LINE. FINIS\"\naddress ISPEXEC \"LMINIT DATAID(TEMP) DDNAME(\"||ddnm||\")\"\naddress ISPEXEC \"VIEW   DATAID(\"||temp\")\"\naddress ISPEXEC \"LMFREE DATAID(\"||temp\")\"\njunk = msg(off)\n\"FREE FI(\"||ddnm||\")\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TWOPAKZD": {"ttr": 16641, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x12\\x18\\x7f\\x01\\x12\\x18\\x7f\\t\\x10\\x15\\xc3\\x15\\xc3\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2012-07-05T00:00:00", "modifydate": "2012-07-05T09:10:00", "lines": 5571, "newlines": 5571, "modlines": 0, "user": "CBT484"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "TWOPAKZ3": {"ttr": 18698, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x13\\x01\\x03\\x19/\\x01\\x04#\\x7f\\x15T\\x13\\xc2\\x13\\xc1\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf6\\xf7@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-07-11T00:00:00", "modifydate": "2004-08-24T15:54:13", "lines": 5058, "newlines": 5057, "modlines": 0, "user": "CBT467"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "TWOPAKZ6": {"ttr": 20993, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x05\\x12\\x9f\\x01\\x06\\x00_\\tP\\x13\\xd4\\x13\\xc7\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf1@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-05-09T00:00:00", "modifydate": "2006-01-05T09:50:00", "lines": 5076, "newlines": 5063, "modlines": 0, "user": "CBT471"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "TWOPAKZ8": {"ttr": 23043, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x07\\x14O\\x01\\x12\\x18\\x7f\\t\\x10\\x15\\xd8\\x13\\xed\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-05-24T00:00:00", "modifydate": "2012-07-05T09:10:00", "lines": 5592, "newlines": 5101, "modlines": 0, "user": "CBT484"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "TWOPAK21": {"ttr": 25345, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x140\\x0f\\x01\\x140\\x0f\\x11U\\x15\\x9a\\x15\\xc3\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-10-27T00:00:00", "modifydate": "2014-10-27T11:55:00", "lines": 5530, "newlines": 5571, "modlines": 0, "user": "CBT489"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "TWOPAK22": {"ttr": 27401, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x18(_\\x01\\x19\\x11O\\x15\\x00\\x15\\xc5\\x15\\xbd\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf9\\xf7@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-10-12T00:00:00", "modifydate": "2019-04-24T15:00:00", "lines": 5573, "newlines": 5565, "modlines": 0, "user": "CBT497"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "TWOPAK23": {"ttr": 29704, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x19\\x11O\\x01\\x19\\x11O\\x15\\x00\\x15\\xed\\x15\\xed\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf9\\xf7@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-04-24T00:00:00", "modifydate": "2019-04-24T15:00:00", "lines": 5613, "newlines": 5613, "modlines": 0, "user": "CBT497"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "UMJES01": {"ttr": 32008, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x03?\\x01\\x02\\x15\\x7f\\x11P\\x00\\r\\x00\\x0e\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-02-02T00:00:00", "modifydate": "2002-06-06T11:50:00", "lines": 13, "newlines": 14, "modlines": 0, "user": "CBT449"}, "text": "++USERMOD(UMJES01) REWORK(2002152)\n /*\n  MODIFY JES2-SOURCE TO ALLOW CONCURRENT TSO LOGONS ON DIFFERENT\n  MVS-IMAGES IN A MAS.\n  SOURCE UPDATE ORIGINALLY DOCUMENTED IN RTA000089663\n */ .\n++VER(Z038) FMID(HJE7703)\n   PRE(UW74954).\n++SRCUPD (HASPCNVT) .\n./ CHANGE NAME=HASPCNVT\n*        JZ    XTDUPEND     ** DUP CHECK COMMENTED OUT BY UMJES01 **\n         J     XTDUPEND  ** ALLOW DUP TSO LOGON - MODIFIED BY UMJES01\n./ ENDUP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UMJES01O": {"ttr": 32010, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x15o\\x01\\x02\\x15\\x7f\\x11P\\x00\\x0e\\x00\\x0e\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-06-05T00:00:00", "modifydate": "2002-06-06T11:50:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "CBT449"}, "text": "++USERMOD(UMJES01) REWORK(1998351)\n /*\n  MODIFY JES2-SOURCE TO ALLOW CONCURRENT TSO LOGONS ON DIFFERENT\n  MVS-IMAGES IN A MAS.\n  SOURCE UPDATE ORIGINALLY DOCUMENTED IN RTA000089663\n */ .\n++VER(Z038) FMID(HJE6605)\n   PRE(UW42791 UW44373 UW44783 UW45057 UW46250\n       UW47776 UW50043 UW51147 UW53420).\n++SRCUPD (HASPCNVT) .\n./ CHANGE NAME=HASPCNVT\n*        BZ    XTDUPEND     ** DUP CHECK COMMENTED OUT BY UMJES01 **\n         B     XTDUPEND  ** ALLOW DUP TSO LOGON - MODIFIED BY UMJES01\n./ ENDUP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UMJES012": {"ttr": 32012, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02$\\x7f\\x01\\x02$\\x7f\\x11\\x12\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf5\\xf1@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-09-04T00:00:00", "modifydate": "2002-09-04T11:12:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT451"}, "text": "++USERMOD(UMJES01) REWORK(2002247)\n /*\n  MODIFY JES2-SOURCE TO ALLOW CONCURRENT TSO LOGONS ON DIFFERENT\n  MVS-IMAGES IN A MAS.\n  SOURCE UPDATE ORIGINALLY DOCUMENTED IN RTA000089663\n */ .\n++VER(Z038) FMID(HJE7705).\n++SRCUPD (HASPCNVT) .\n./ CHANGE NAME=HASPCNVT\n*        JZ    XTDUPEND     ** DUP CHECK COMMENTED OUT BY UMJES01 **\n         J     XTDUPEND  ** ALLOW DUP TSO LOGON - MODIFIED BY UMJES01\n./ ENDUP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UMJES06": {"ttr": 32014, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x01\\x06O\\x01\\x01\\x06O\\x10\\x19\\x00\\x0b\\x00\\r\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf3\\xf3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-03-05T00:00:00", "modifydate": "2001-03-05T10:19:20", "lines": 11, "newlines": 13, "modlines": 0, "user": "CBT433"}, "text": "++USERMOD(UMJES06) /*\n  ************************************************************\n  * Allow Multiple TSO Logon within a JES3 Complex           *\n  * (USERMOD supplied by Edward E. Jaffe - Phoenix Software) *\n  ************************************************************\n */ .\n++VER(Z038) FMID(HJS7703)\n            PRE(UW73175,UW75087) .\n++SRCUPD(IATGRJS) .\n./ CHANGE NAME=IATGRJS\n         B     MSSCH030            ACCEPT MULTIPLE LOGON       UMJES06\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VTOCLIST": {"ttr": 32016, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x004\\x01\\x02\\t\\x1f\\x01\\x10\\x02\\x7f\\x08)\\x03&\\x03\\x17\\x00\\x00\\xe3\\xd9\\xc9\\xc4\\xd1\\xd2@@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2002-04-01T00:00:00", "modifydate": "2010-01-27T08:29:34", "lines": 806, "newlines": 791, "modlines": 0, "user": "TRIDJK"}, "text": "         TITLE 'VTOCLIST - LIST VTOC OF SYSUT1'\n***********************************************************************\n**@@NAME=U10001AS      EUROPEAN GUIDE MODS SEE ABSTR.FLE. 3-75 GUIDE  *\n*                                                                     *\n* AUTHOR -     P.E.HAVERCAN - C.A.V. LIMITED                          *\n*                                                                     *\n* TITLE -      VTOCLIST                                               *\n*                                                                     *\n* FUNCTION -   LIST THE VTOC ON A DASD VOLUME                         *\n*                                                                     *\n* JCL -        //VTOCLIST   EXEC  PGM=VTOCLIST                        *\n*              //SYSPRINT   DD  SYSOUT=*                              *\n*              //SYSUT1     DD  UNIT=SYS20DA,DISP=SHR,VOL=SER=VVVVVV  *\n*                                                                     *\n*              PARM='PDS' WILL PRINT DIRECTORY BLOCKS ALLOCATED/USED  *\n*              INSTEAD OF THE CREATION/LAST REFERENCE DATES.  THIS    *\n*              REQUIRES READALL IN ACF2 IN ORDER TO OPEN EACH         *\n*              PDS DIRECTORY ON THE VOLUME WITHOUT GETTING SECURITY   *\n*              VIOLATIONS.                                            *\n*                                                                     *\n* ATTRIBUTES - NONREUSABLE                                            *\n*                                                                     *\n* MODIFIED   - JOHN KALINICH, COMPUTER SCIENCES CORPORATION,          *\n*              ST. LOUIS, MO                                          *\n*              JKALINIC@CSC.COM                                       *\n*                                                                     *\n* 09/20/78 -   FIX MISCELLANEOUS BUGS AND 0C4 ABENDS                  *\n*                                                                     *\n*              PDS DIRECTORY BLOCKS ALLOCATED/USED OPTION             *\n*                                                                     *\n* 09/18/85 -   PRINT THE LAST REFERENCE DATE INSTEAD OF THE           *\n*              EXPIRATION DATE                                        *\n*                                                                     *\n*              3380/3390 SUPPORT                                      *\n*                                                                     *\n*              PRINT DATES IN AMERICAN (MM/DD/YY) FORMAT              *\n*              INSTEAD OF EUROPEAN (DD/MM/YY) FORMAT                  *\n*                                                                     *\n* 06/10/88 -   PRINT UP TO 123 EXTENTS FOR ICF VSAM DATA SETS         *\n*                                                                     *\n* 01/09/98 -   PROCESS YEAR 2000 VTOC DATES CORRECTLY                 *\n*                                                                     *\n* 08/12/99 -   DISPLAY NEW DSORG TYPES:  PDSE, HFS, AND VSAM EF       *\n*                                                                     *\n* 03/22/02 -   3390-9 AND 3390-27/32 SUPPORT                          *\n*              PRINT UP TO 255 EXTENTS                                *\n*                                                                     *\n* 06/20/03 -   IF PARM=PDS, BYPASS HFS FILES                          *\n*                                                                     *\n* 01/20/10 -   FREEMAIN FORMAT1 STORAGE AREA                          *\n*                                                                     *\n* 01/26/10 -   FREEPOOL QSAM BUFFERS                                  *\n*                                                                     *\n***********************************************************************\n         MACRO\n&NAME    #SORT &FIELDS=(1,1,CH,A),&FIRST=,&LAST=,&A=,&FORMAT=,         *\n               &LENGTH=\n.*       AUTHOR - PETER HAVERCAN\n         GBLC  &##EQU\n         LCLA  &X,&Y,&Z,&LEN\n         LCLC  &HI,&LO,&R0,&R1,&R14,&R15\n&X       SETA  N'&FIELDS\n         AIF   (&X NE 3 AND &X NE 4).ERR1\n         AIF   (&X EQ 4 AND '&FIELDS(3)' NE 'CH').ERR2\n&HI      SETC  'H'\n&LO      SETC  'L'\n         AIF   ('&FIELDS(&X)' NE 'D').TESTA\n&HI      SETC  'L'\n&LO      SETC  'H'\n         AGO   .SETREGS\n.TESTA   AIF   ('&FIELDS(&X)' EQ 'A').SETREGS\n         MNOTE *,'*** SORT TYPE NOT A OR D - A ASSUMED'\n.SETREGS ANOP\n&R0      SETC  '&##EQU.0'\n&R1      SETC  '&##EQU.1'\n&R14     SETC  '&##EQU.14'\n&R15     SETC  '&##EQU.15'\n         AIF   ('&LENGTH' EQ '').NOLNGTH\n&LEN     SETA  &LENGTH\n         AGO   .LENSET\n.NOLNGTH ANOP\n&LEN     SETA  L'&FIRST\n.LENSET  ANOP\n&X       SETA  &FIELDS(1)-1            OFFSET WITHIN RECORD\n&Y       SETA  &FIELDS(2)              LENGTH OF SORT-KEY\n&Z       SETA  &X+&LEN                 OFFSET WITHIN NEXT RECORD\n         AIF   ('&FIRST&LAST' EQ '').ATYPE\n&NAME    LA    &R15,&FIRST             ADDRESS FIRST ENTRY\n         LA    &R0,&LENGTH             LOAD WIDTH OF TABLE\n         LA    &R1,&LAST               ADDRESS LAST ENTRY\n         AGO   .STEPBCK\n.ATYPE   AIF   ('&A' EQ '').ERR3\n&NAME    LM    &R15,&R1,&A             FIRST ENTRY,WIDTH,LAST ENTRY\n.STEPBCK ANOP\n         SR    &R1,&R0                 R1 POINTS AT PENULTIMATE\n         CLC   &X.(&Y,&R15),&Z.(&R1)   COMPARE FIRST & LAST ENTRIES\n         B&LO  *+22                    RECDS IN SEQUENCE\n         XC    0(&LEN,&R15),&LEN.(&R1) SWITCH FIRST AND\n         XC    &LEN.(&LEN,&R1),0(&R15) LAST ENTRIES INTO\n         XC    0(&LEN,&R15),&LEN.(&R1) CORRECT SEQUENCE\n         LA    &R14,&LEN.(&R15)        ADDRESS NEXT RECORD\n         CLC   &X.(&Y,&R14),&X.(&R15)  COMPARE SORT KEYS\n         BN&LO *+26                    IN SEQUENCE FROM FRONT\n         XC    0(&LEN,&R14),0(&R15)    SWITCH FIELDS\n         XC    0(&LEN,&R15),0(&R14)    WHICH ARE OUT\n         XC    0(&LEN,&R14),0(&R15)    OF SEQUENCE\n         B     *+32                    GO TO LOOP CONTROL\n         CLC   &X.(&Y,&R14),&Z.(&R1)   COMPARE WITH FINAL RECORD\n         BN&HI *+22                    IN SEQUENCE FROM REAR\n         XC    0(&LEN,&R14),&LEN.(&R1) SWITCH FIELDS\n         XC    &LEN.(&LEN,&R1),0(&R14) WHICH ARE OUT\n         XC    0(&LEN,&R14),&LEN.(&R1) OF SEQUENCE\n         BXLE  &R14,&R0,*-60           INCREMENT & LOOP BACK\n         SR    &R1,&R0                 DECREMENT END POINTER\n         BXLE  &R15,&R0,*-98           ADVANCE FRONT POINTER\n         MEXIT\n.ERR1    MNOTE 8,'INVALID NO. OF ENTRIES IN FIELDS PARAMETER'\n         MEXIT\n.ERR2    MNOTE 4,'FORMAT TYPE IS NOT SUPPORTED'\n         MEXIT\n.ERR3    MNOTE 8,'NEITHER A NOR FIRST AND LAST ARE SPECIFIED'\n         MEND\n*\n         MACRO\n&NAME    ERROR &A\n&NAME    ABEND &A\n         MEND\n*\n         EJECT\nVTOCLIST CSECT\n*        AUTHOR - P.E.HAVERCAN - C.A.V. LIMITED\n*        REGEQU                        * SYMBOLIC REGISTERS\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         USING VTOCLIST,R15            * ADDRESS SAVEAREA\n         STM   R14,R12,12(R13)         * SAVE REGISTERS\n         ST    R13,SAVEAREA+4          * BACKWARD TO CALLER\n         LR    R5,R13                  * KEEP FOR A WHILE\n         CNOP  0,4                     * ALIGN TO FULLWORD FOR R13\n         BAS   R13,SAVEAREA+72         * PRIME 1ST BASE\n         DROP  R15\n         USING *,R13,R12               * DECLARE BASE REGISTERS\nSAVEAREA DC    18F'0'                  * 72-BYTE SAVEAREA\n         ST    R13,8(R5)               * FORWARD FROM CALLER\n         LA    R12,2048(R13)           * +2K PAST 1ST BASE\n         LA    R12,2048(R12)           * +4K PAST 1ST BASE\n         LM    R10,R11,0(R1)           * PICK UP PARM ADDR & DCB ADDR\n         CLC   0(2,R10),=XL2'0000'     * PARM ENTERED?\n         BE    NOPARM                  * NO\n         MVC   PARM(3),2(R10)          * YES, KEEP\nNOPARM   EQU   *\n         LTR   R10,R10                 * ONLY PARM SUPPLIED?\n         BNM   SKIPOPEN                * NO, OMIT INITIALIZATION OF DCB\n         RDJFCB MF=(E,OPENVTOC)        * READ VTOC JFCB\n         MVI   JFCBDSNM,X'04'          * SET UP\n         MVC   JFCBDSNM+1(43),JFCBDSNM * VTOC DSNAME\n         OI    JFCBAREA+52,X'08'       * INDICATE NO JFCB WRITE-BACK\n         OPEN  MF=(E,OPENVTOC),TYPE=J  * OPEN VTOC\n         LA    R11,VTOC                * ADDRESS THE OPENED DCB\nSKIPOPEN ST    R11,VTOCDECB+8          * AND SAVE IN DECB\n         TM    48(R11),X'10'           * CHECK DCB IS OPEN\n         BO    GOODOPEN                * LOOKS OK\nERR1     EQU   *\n         ERROR 1\nGOODOPEN TM    48(R11),X'02'           * DO I HAVE THE DCB TO MYSELF?\n         BO    NOUSER                  * I THINK SO\n         ERROR 2                       * MAYBE NOT\nNOUSER   EQU   *\n         OPEN  (PRINTER,OUTPUT)        * OPEN PRINT FILE\n         TM    PRINTER+48,X'10'        * TEST THAT OPEN WORKED\n         BZ    ERR1                    * ERROR OPENING PRINTER\n* SET UP HDR1 LINE FOR HEAD OF PAGE\n         MVC   HDR1VOL,JFCBVOLS        * VOLUME SERIAL NO\n         TIME  DEC                     * GET TIME OF JOB\n         ST    R0,DWORK+4              * SAVE TIME IN WORKAREA\n         ED    HDR1TIME,DWORK+4        * MOVE TO OUTPUT\n         SR    R0,R0                   * CLEAR OUT R0\n         STM   R0,R1,DWORK             * SAVE DECIMAL DATE\n         CVB   R1,DWORK                * CONVERT DEC DATE TO BIN\n         D     R0,=F'1000'             * SPLIT INTO YEAR & DAY\n         ST    R0,DWORK+4              * STORE BINARY DAYS\n         STH   R1,DWORK+4              * STORE BINARY YEAR\n         BAS   R9,DATECONV             * GO CONVERT DATE\n         ED    HDR1DATE,DWORK+4        * THEN USE CNVRTED RESULT\n         EJECT\n* SETUP TO READ FORMAT 4 DSCB\n         L     R3,44(R11)              * PICK UP DEB ADDR FROM DCB\n         MVC   VTOCFDAD+1(6),36(R3)    * MOVE BBCCHH OF EXTENT START\n         MVI   VTOCFDAD+7,1            * POINT TO 1ST RECD = FMT4\n         BAS   R9,READDSCB+6           * READ THE FORMAT 4\n         CLI   DS1FMTID,C'4'           * IS IT REALLY A FORMAT 4 ?\n         BE    MOVEFMT4                * FORTUNATELY, YES\n         ERROR 3                       * HOW DID WE GET HERE?\nMOVEFMT4 MVC   DS4DATA(71),DS1FMTID    * MOVE FORMAT4 DATA TO SPEC AREA\n         BAS   R9,POINTF5              * GO DO THE CALCULATION PROPERLY\n         LH    R4,46(R3)               * PICK # TRKS IN VTOC FROM DEB\n         SR    R5,R5                   * CLEAR R5\n         IC    R5,DS4DEVDT             * INSERT NO OF DSCB'S PER TRK\n         MR    R4,R4                   * WHENCE FIND # OF DSCBS IN VTOC\n         M     R4,TBLWIDTH             * MULT BY AMT OF CORE PER ENTRY\n         ST    R5,SAVER5               * SAVE TABLE SIZE      DRK JAN10\nGETMAIN  GETMAIN EC,LV=(5),A=TABLADDR  * ESTIMATE CORE REQ FOR FORMAT1S\n         B     *+4(R15)                * SEE IF CORE WAS AVAILABLE\n         B     GOTCORE                 * YES, GO BUILD TABLE\n* INSUFFICIENT CORE TO SORT FORMAT1 DSCBS - POINT ROUTINE TO PICK UP\n* THE SORTED ENTRIES TO THE ROUTINE WHICH READS THEM THE FIRST TIME\n         LA    R2,READFMT1             * GET ROUTINE ADDR\n         ST    R2,RTNADDR              * SAVE IT\n         LA    R2,ENDUP                * GET END-OF-FILE ROUTINE\n         ST    R2,EODADDR              * SAVE IT\n         B     PRNTDSCB                * AND GO IMMEDIATELY TO PRINT\n         EJECT\nGOTCORE  EQU   *\n         L     R4,TABLADDR             * R4 -> TABLE OF DSCBS\nBLDLOOP  BAS   R9,READFMT1             * READ A FORMAT1 DSCB\n         MVC   0(1,R4),DS1DSORG        * DSORG IS HI-ORDER SORT-KEY\n         NI    0(R4),B'10000000'       * TO DISTINGUISH ISAM FILES\n         MVC   1(44,R4),DS1DSNAM       * MOVE DSNAME INTO TABLE\n         MVC   45(5,R4),VTOCFDAD+3     * SET RECORD ADDR OF THIS DSCB\n         LA    R4,50(R4)               * BUMP TABLE POINTER\n         B     BLDLOOP                 * AND GO READ NEXT FORMAT 1\nVTOCEOD  EQU   *                       * COME HERE WHEN DSCBS EXHAUSTED\n         S     R4,TBLWIDTH             * POINT TO LAST TABLE ENTRY\n         ST    R4,TABLEND              * SAVE IN #SORT LIST\n         CP    FMT1CNT,=P'1'           * HOW MANY DATA SETS ON VOLUME\n         BE    VTOCEOD1                * ONLY 1, BYPASS THE SORT\n         BL    PRNTDSCB                * NO FORMAT 1 DSCBS READ\n         #SORT FIELDS=(1,45,CH,A),A=TABLADDR,LENGTH=50 SORT TABLE\nVTOCEOD1 EQU   *\n         L     R4,TABLADDR             * RESET R4 -> TABLE OF DSCBS\n         S     R4,TBLWIDTH             * THEN POINT TO PREVIOUS AREA\n         EJECT\nPRNTDSCB PUT   PRINTER                 * GET A PRINT BUFFER\n         USING HDRLINE,R1              * MAP OUTPUT LINE\n         MVI   0(R1),C' '              * SINGLE SPACE NORMALLY\n         SP    LINECNTR,=P'1'          * DECREMENT LINE-COUNTER\n         BP    PRINTBR                 * NOT HEAD OF PAGE\n         MVC   0(133,R1),HDR1          * MOVE IN A PAGE HEADER\n         AP    PAGECNTR,=P'1'          * ADD 1 TO PAGE-COUNTER\n         ED    HDPAGCNT,PAGECNTR       * AND MOVE TO HEADER LINE\n         PUT   PRINTER                 * GET A PRINT BUFFER\n         CLC   PARM(3),=CL3'PDS'       * DIR BLKS ALLOC/USED REQUEST\n         BNE   NOTPO1                  * NO, LEAVE HEADERS ALONE\n         MVC   HDR2(133),HDR2P         * DIRECTORY BLOCKS\n         MVC   HDR3(133),HDR3P         * ALLOC     USED\nNOTPO1   EQU   *\n         MVC   0(133,R1),HDR2          * MOVE SECOND LINE\n         PUT   PRINTER                 * GET A PRINT BUFFER\n         MVC   0(133,R1),HDR3          * MOVE THIRD LINE\n         PUT   PRINTER                 * GET A PRINT BUFFER\n         ZAP   LINECNTR,MAXLINES       * RESET LINE-COUNTER\n         CP    FMT1CNT,=P'1'           * HOW MANY DATA SETS ON VOLUME\n         BNL   FIRSTDTL                * AT LEAST ONE\n         LR    R10,R1                  * NO FORMAT 1 DSCBS READ\n         B     ENDUP                   * PRINT LAST TWO LINES\nFIRSTDTL EQU   *\n         MVI   0(R1),C'0'              * FIRST DETAIL LINE DOUBLE SPACE\nPRINTBR  NOP   XDPRLPND                * BR IF MULTIPLE EXTENT\n         EJECT\nGETDSCB  LR    R10,R1                  * SAVE POINTER TO BUFFER\n         USING DSNLINE,R10             * AND SET DSECT\n         L     R15,RTNADDR             * ADDR OF ROUTINE TO READ DSCB\n         BASR  R9,R15                  * GO AND DO IT\n         MVC   LNDSN,DS1DSNAM          * MOVE DSNAME\n         MVC   LNCREDT(88),LNEDMSK     * MOVE EDIT MASKS FOR OTHER FLDS\n         MVC   DWORK+5(3),DS1CREDT     * CREATION DATE\n         BAS   R9,DATECONV             * CONVERT DATE\n         ED    LNCREDT,DWORK+4         * MM/DD/YY FORMAT\n         OC    DS1REFD,DS1REFD         * CHECK FOR ZERO REFERENCE DATE\n         BNZ   CNVREFDT                * NON-ZERO, GO CONVERT IT\n         MVC   LNREFDT+1(8),LNREFDT    * ELSE CLEAR TO SPACES\n         B     PARMTEST                * AND CONTINUE\nCNVREFDT MVC   DWORK+5(3),DS1REFD      * REFERENCE DATE\n         BAS   R9,DATECONV             * CONVERT DATE\n         ED    LNREFDT,DWORK+4         * MM/DD/YY FORMAT\nPARMTEST EQU   *\n         CLC   PARM(3),=CL3'PDS'       * DIR BLKS ALLOC/USED REQUEST\n         BNE   NOTPO2                  * NO, SKIP READ OF PDS DIRECTORY\n         MVI   LNCREDT,C' '            * MOVE\n         MVC   LNCREDT+1(8),LNCREDT    * SPACES\n         MVI   LNREFDT,C' '            * MOVE\n         MVC   LNREFDT+1(8),LNREFDT    * SPACES\n         ZAP   DIRTOTAL(3),=PL3'0'     * ZERO COUNTER\n         ZAP   DIRUSED(3),=PL3'0'      * ZERO COUNTER\n         TM    DS1DSORG,B'00000010'    * PARTITIONED ORGANIZATION?\n         BNO   NOTPO2                  * NO\n         TM    DS1SMSFG,DS1PDSEX       * HFS?\n         BO    NOTPO2                  * YES, SKIP\n         MVC   JFCBDSNM,DS1DSNAM       * YES, MOVE DSNAME\n         OI    JFCBAREA+52,X'08'       * INDICATE NO JFCB WRITE BACK\n         OPEN  (PDS,INPUT),TYPE=J      * OPEN PDS\n         XC    DIRSTAT,DIRSTAT         * CLEAR DIRECTORY STATUS BYTE\nGETDIR   EQU   *\n         GET   PDS                     * READ PDS DIRECTORY BLOCKS\n         AP    DIRTOTAL(3),=PL3'1'     * ADD TO TOTAL\n         TM    DIRSTAT,X'80'           * END OF MEMBERS REACHED?\n         BO    GETDIR                  * YES\n         AP    DIRUSED(3),=PL3'1'      * NO, ADD TO USED\n         LR    R5,R1                   * PT AT DIRECTORY BLOCK\n         LH    R6,0(R5)                * # OF BYTES USED IN DIR BLOCK\n         AR    R6,R5                   * A(END OF DIR BLOCK)\n         LA    R5,2(R5)                * GO PAST BYTES USED FIELD\nNAMETTR  EQU   *\n         CR    R5,R6                   * END OF DIRECTORY BLOCK?\n         BNL   GETDIR                  * YES\n         CLC   0(8,R5),=8XL1'FF'       * END OF DIRECTORY MEMBERS?\n         BE    MBREOF                  * YES\n         SR    R1,R1                   * CLEAR A REGISTER\n         NI    11(R5),X'1F'            * TURN OFF BITS 0,1,2\n         IC    R1,11(R5)               * INDICATOR BYTE\n         SLL   R1,1                    * HALFWORDS OF USER DATA\n         AR    R5,R1                   * GO PAST USER DATA\n         LA    R5,12(R5)               * GO PAST NAME/TTR\n         B     NAMETTR                 * CHECK NEXT MEMBER\nMBREOF   EQU   *\n         OI    DIRSTAT,X'80'           * SET END OF MEMBERS FLAG\n         B     GETDIR                  * AND CONTINUE\nPDSEOF   EQU   *\n         CLOSE PDS                     * DISCONNECT\n         FREEPOOL PDS                  * FREE BUFFERS         DRK JAN10\n         MVC   LNCREDT(6),DIRPATT      * EDIT MASK\n         MVC   LNREFDT+2(6),DIRPATT    * EDIT MASK\n         ED    LNCREDT(6),DIRTOTAL     * MOVE TO OUTPUT LINE\n         ED    LNREFDT+2(6),DIRUSED    * MOVE TO OUTPUT LINE\nNOTPO2   EQU   *\n         TM    DS1DSORG,B'00000001'    * UNMOVABLE DATA?\n         BNO   *+8                     * NO, SKIP NEXT INSTR\n         MVI   LNDSORGU,C'U'           * INDICATE UNMOVABLE\n         LH    R0,DS1DSORG             * LOAD DSORG INTO R0\n         SLL   R0,16                   * AND SHIFT TO LHS OF REG\n         LA    R1,7                    * LOAD # OF BITS TO TEST\nDSORGLP  LTR   R0,R0                   * IS HI-ORDER BIT ON?\n         BM    DSORGFND                * YES, ASSUME ONLY BIT SET\n         SLL   R0,1                    * NO, SLIDE NEXT BIT TO SIGN\n         BCT   R1,DSORGLP              * AND TEST THAT\nDSORGFND SLL   R1,1                    * MULTIPLY R1 BY 2\n         LA    R2,ORGTYPES(R1)         * USE IT TO ADDRESS TABLE\n         MVC   LNDSORG,0(R2)           * MOVE CORRESPONDING DSORG\n         TM    DS1DSORG+1,DS1ORGAM     * VSAM?\n         BNO   *+4+6                   * NO\n         MVC   LNDSORG,=CL2'VS'        * YES\n         TM    DS1SMSFG,DS1PDSE        * PDSE?\n         BNO   *+4+6                   * NO\n         MVC   LNDSORG,=CL2'PE'        * YES\n         TM    DS1SMSFG,DS1PDSEX       * HFS?\n         BNO   *+4+6                   * NO\n         MVC   LNDSORG,=CL2'HF'        * YES\n         TM    DS1SMSFG,DS1STRP        * EXTENDED FORMAT DATASET?\n         BNO   *+4+4                   * NO\n         MVI   LNDSORGU,C'X'           * YES\n         EJECT\n         LA    R2,LNRECFM              * ADDRESS OUTPUT RECFM\n         L     R0,DS1RECFM             * LOAD INPUT RECFM\n         LA    R1,FMTYPES              * ADDRESS TABLE OF RECFM TYPES\n         LA    R3,7                    * NO OF BITS TO TEST\n         TM    DS1RECFM,B'11000000'    * FIRST CHECK FOR 'U'\n         BNO   FMLOOP                  * NOT UNDEFINED\n         MVI   0(R2),C'U'              * MOVE IN 'U'\n         N     R0,=X'3FFFFFFF'         * OFF 'F' & 'V' BITS\n         B     FMJUMP                  * AND JOIN LOOP\nFMLOOP   LTR   R0,R0                   * TEST SIGN BIT\n         BNM   FMEND                   * BIT IS OFF\n         MVC   0(1,R2),0(R1)           * MOVE CORRESP CHAR\nFMJUMP   LA    R2,1(R2)                * POINT TO NEXT OUTPUT SPOT\nFMEND    EQU   *\n         LA    R1,1(R1)                * POINT TO NEXT TYPE IN LIST\n         SLL   R0,1                    * SHIFT OVER NEXT BIT\n         BCT   R3,FMLOOP               * AND GO TEST IT\n         LH    R0,DS1BLKL              * PICK UP BLKSIZE\n         CVD   R0,DWORK                * CONVERT TO DECIMAL\n         ED    LNBLKSI,DWORK+5         * MOVE TO OUTPUT\n         LH    R0,DS1LRECL             * PICK UP LRECL\n         CH    R0,=X'8000'             * IF LRECL = X'8000'\n         BNE   NOT32K                  * THIS INDICATES  SPANNED RECDS\n         MVC   LNLRECL+1(5),=C' >32K'      WITH RECD LENGTH > 32756\n         B     CNVKEYLE                * AND THAT'S ALL\nNOT32K   CVD   R0,DWORK                * OTHERWISE WE JUST\n         ED    LNLRECL,DWORK+5         * MOVE VALUE TO OUTPUT\nCNVKEYLE EQU   *\n         SR    R0,R0                   * CLEAR REGISTER\n         IC    R0,DS1KEYL              * INSERT KEYLEN\n         CVD   R0,DWORK                * DECIMALISE\n*        ED    LNKEYLE,DWORK+6         * AND OUTPUT\n         EJECT\n* PICK UP SECONDARY ALLOCATION TYPE AND QUANTITY\n         MVC   DWORK(4),DS1SCALO       * ALIGNMENT\n         L     R2,DWORK                * LOAD SECONDARY ALLOC\n         LA    R1,0(R2)                * SAVE IN R1 WITH HI-ORDER OFF\n         SRL   R2,30                   * SHIFT OVER 2 BIT INDICATOR\n         LA    R0,0(R2,R2)             * DOUBLE IT\n         ALR   R2,R0                   * MAKE IT TRIPLE\n         BNZ   NOTABSTR                * NOT ABSOLUTE TRACK\n         MVC   LNSCALO(10),=C'     ABSTR' INDICATE ABSTR\n         B     SECALEND                * FINISHED\nNOTABSTR LA    R2,SECTYPES-3(R2)       * ADDRESS BLK, TRK OR CYL\n         MVC   LNSCTYPE,0(R2)          * AND MOVE IT TO OUTPUT\n         CVD   R1,DWORK                * CNVRT SEC ALLOC QTY\n*        ED    LNSCALO,DWORK+5         * MOVE TO OUTPUT\n         MVC   TRKSWORK(8),MASKTRKS    * EDIT MASK FOR SEC ALLOC\n         ED    TRKSWORK(8),DWORK+4     * EDIT 7 DIGIT SEC ALLOC\n         MVC   LNSCALO,TRKSWORK+2      * AND MOVE 6 TO OUTPUT\nSECALEND EQU   *                       * THROUGH WITH SEC ALLOC\n         SR    R0,R0                   * CLEAR A REG\n         IC    R0,DS1NOEPV             * INSERT NO. OF EXTENTS\n         CVD   R0,DWORK                * CONVERT TO DECIMAL\n         ED    LNNOEXT,DWORK+6         * MOVE TO OUT-PUT LINE\n         EJECT\n         MVC   LASTBLK,DS1LSTAR        * FIRST SAVE LAST-BLK POINTER\n* ROOM FOR 263 EXTENTS (1 FORMAT 1 PLUS 20 FORMAT 3 DSCB'S) IN TABLE\n* MAX OF 255 EXTENTS IS POSSIBLE\n         LA    R14,XTNTAREA            * AREA TO BE ZEROED\n         LA    R15,2630                * LENGTH\n         SR    R0,R0                   * NULL SOURCE\n         SR    R1,R1                   * NULL SOURCE\n         MVCL  R14,R0                  * FILL WITH PAD 0 FROM R1\n         MVC   XTNTAREA(30),DS1EXT1    * MOVE 1ST 3 EXTENT DESCRIPTS\n         LA    R5,10                   * LOAD MAX # OF F3'S TO READ\n         LA    R6,XTNTAREA+30          * START OF F3'S IN AREA\nCHKCHAIN OC    DS1PTRDS,DS1PTRDS       * IS THERE A FORMAT2 OR 3?\n         BZ    NOCHAIN                 * NO, CHAINING NOT NECC\n         MVC   VTOCFDAD+3(5),DS1PTRDS  * YES, SET ADDRESS\n         BAS   R9,READDSCB+6           * AND READ FORMAT3\n         CLI   DS1FMTID,C'3'           * IS IT A FORMAT 3?\n         BNE   CHKCHAIN                * NO SO CHAIN AGAIN\n         MVC   0(40,R6),DS1DSNAM+4     * MOVE NEXT 4 EXTENT DESCRIPTS\n         MVC   40(90,R6),DS1DSSN       * MOVE NEXT 9 EXTENT DESCRIPTS\n         LA    R6,130(R6)              * POINT TO NEXT SLOT IN AREA\n         BCT   R5,CHKCHAIN             * GO SEE IF MORE\n*\n* NOW FOR SOMETHING TRICKY AFTER ALL THOSE STRAIGHTFORWARD EDITS -\n* FIND THE NUMBER OF TRACKS ALLOCATED\n*\nNOCHAIN  EQU   *\n         LA    R5,XTNTAREA             * SET UP BEGINNING,\n         LA    R6,10                       INCREMENT,\n         LA    R7,XTNTAREA+2620              AND END POINTER FOR LOOP\n         SR    R0,R0                   * ZERO REGISTER TO STORE RESULT\nXTNTLOOP CLI   0(R5),X'00'             * IS THIS A VALID EXTENT?\n         BE    XTNTEXIT                * NO\n         LH    R1,6(R5)                * PICK UP CC FOR EXTENT END\n         SH    R1,2(R5)                * SUBTRACT CC FOR EXTENT START\n         MH    R1,DS4DEVSZ+2           * MULTIPLY BY # TRKS/CYL\n         AH    R1,8(R5)                * ADD HH FOR EXTENT END\n         SH    R1,4(R5)                * SUBTRACT HH FOR EXTENT START\n         LA    R1,1(R1)                * ALLOW FOR LAST TRK OF EXTENT\n         STH   R1,6(R5)                * SAVE # OF TRKS IN TABLE\n         AR    R0,R1                   * ADD IN TO TOTAL TRKS\n         BXLE  R5,R6,XTNTLOOP          * CHECK NEXT EXTENT\nXTNTEXIT SR    R5,R6                   * POINT R5 BACK TO LAST EXTENT\n         LR    R7,R5                   * RESET BXLE LIMIT\n         CVD   R0,DWORK                * CNVERT NO. OF TRKS\n*        ED    LNNOTRKS,DWORK+5        * AND MOVE TO OUTPUT\n         MVC   TRKSWORK(8),MASKTRKS    * EDIT MASK FOR TRKS ALLOC\n         ED    TRKSWORK(8),DWORK+4     * EDIT 7 DIGIT TRKS ALLOC\n         MVC   LNNOTRKS,TRKSWORK+2     * AND MOVE 6 TO OUTPUT\n         BNZ   CNVUSAGE                * OFF TO CONVERT % USAGE\n         MVC   LNUSAGE+1(3),LNUSAGE      EXCEPT WHEN INDETERMINATE\n         B     XDPRNT                  * BECAUSE ZERO ALLOC\n         EJECT\nCNVUSAGE LH    R3,LASTBLK              * PICK UP TT OF LAST BLOCK\n         LA    R3,1(R3)                * ALLOW FOR LAST (PART-USED) TRK\n         SR    R8,R8                   * ZERO REGISTER\n         ICM   R8,3,DS4DEVTK           * LOAD HALFWORD (UP TO 64K)\n         MR    R2,R8                   * CONVERT TO #BYTES USED\n         LR    R1,R0                   * LOAD ODD-REGISTER OF PAIR\n         MR    R0,R8                   * CONVERT TOTAL ALLOC\n         LR    R0,R1                   * COPY TOTAL BYTES ALLOC\n         SRL   R1,1                    * HALVE IT\n         XC    DWORK(8),DWORK          * CLEAR AREA FOR SUBTRACT\n         MVC   DWORK+6(2),LASTBLK+3    * MOVE FOR ALIGNMENT\n         S     R3,DWORK+4              * SUBTRACT TRACK BALANCE\n         M     R2,=F'100'              * MULT BY 100 FOR PERCENT\n         AR    R3,R1                   * ROUND UP BY HALF TOTAL ALLOC\n         DR    R2,R0                   * AND DIVIDE BY TOTAL ALLOCATION\n         CVD   R3,DWORK                * CNVERT RESULT TO DECIMAL\n         ED    LNUSAGE,DWORK+6         * THEN MOVE TO OUTPUT LINE\nXDPRNT   LA    R5,XTNTAREA             * RESET PNTR TO WORKAREA\nXDPRLOOP SR    R0,R0                   * CLEAR WORK REG\n         IC    R0,1(R5)                * OBTAIN EXTENT NUMBER (M)\n         CVD   R0,DWORK                * CONVERT TO DECIMAL\n         ED    LNXDM,DWORK+6           * MOVE TO LINE\n         LH    R15,2(R5)               * PICK UP CYL ADDRESS IN HEX\n         CVD   R15,DWORK               * GET IN PACKED DECIMAL\n         MVC   CCCCWORK(6),MASKCCCC    * USE EDIT MASK FOR 3380 E/K\n         ED    CCCCWORK(6),DWORK+5     * EDIT 5 DIGIT CYLINDER ADDRESS\n         MVC   LNXDCCHH(5),CCCCWORK+1  * SET CYL ADDRESS IN PRINT LINE\n         LH    R15,4(R5)               * PICK UP TRK ADDRESS IN HEX\n         CVD   R15,DWORK               * GET IN PACKED DECIMAL\n*        ED    LNXDCCHH+4(4),DWORK+6   * SET TRK ADDRESS IN PRINT LINE\n         MVC   CCCCWORK(4),=X'40202120' * HH EDIT MASK\n         ED    CCCCWORK(4),DWORK+6     * EDIT TRK ADDRESS\n         MVI   LNXDCCHH+5,C' '         * SPACE\n         MVC   LNXDCCHH+6(2),CCCCWORK+2 * SET TRK ADDRESS IN PRINT LINE\n         SR    R0,R0                   * ZERO REGISTER\n         ICM   R0,3,6(R5)              * PICK UP # TRKS\n         CVD   R0,DWORK                * CONVERT\n*        ED    LNXD#TRK,DWORK+5        * AND EDIT TO LINE\n         MVC   TRKSWORK(8),MASKTRKS    * EDIT MASK FOR # TRKS\n         ED    TRKSWORK(8),DWORK+4     * EDIT 7 DIGIT # TRKS\n         MVC   LNXD#TRK,TRKSWORK+2     * AND MOVE 6 TO OUTPUT\n         BXH   R5,R6,PRNTDSCB          * FINISH IF ALL EXTENTS DONE\n         MVI   PRINTBR+1,X'F0'         * MAKE A BRANCH\n         B     PRNTDSCB                * GO PRINT A LINE\nXDPRLPND MVI   PRINTBR+1,X'00'         * RESET TO NOP\n         LR    R10,R1                  * SET BUFFER POINTER\n         MVI   LNCC+1,C' '             * INITIALISE\n         MVC   LNCC+2(112),LNCC+1      * TO SPACES\n         MVC   LNXDM(21),LNEXTDSC      * MOVE IN NEW EDIT MSK\n         B     XDPRLOOP                * CONTINUE WITH NEXT EXTENT\n         EJECT\nREADDSCB MVC   VTOCFDAD,VTOCNEXT       * MOVE ADDRESS OF NEXT DSCB\n         READ  VTOCDECB,DIR,VTOC,DS1FMTID,'S',DS1DSNAM,                *\n               VTOCFDAD,VTOCNEXT\n         CHECK VTOCDECB                * WAIT FOR IT TO ARRIVE\n         TM    VTOCDECB+1,B'10000100'  * NO RECD FND / EOF\n         L     R15,EODADDR             * PICK UP EODAD\n         BCR   7,R15                   * GO THERE IF NRF OR EOF\nPOINTF5  EQU   *\n         MVC   VTOCNEXT,VTOCFDAD       * MOVE OLD DISC ADDRESS\n         SR    R15,R15                 * CLEAR R15\n         SR    R1,R1                   * AND R1\n         LA    R0,1                    * SET R0 TO 1\n         IC    R15,VTOCNEXT+7          * PICK UP RECD NO. ON TRK\n         IC    R1,DS4DEVDT             * PICK UP MAX RECDS PER TRK\n         BXH   R15,R0,NEXTTRK          * BRANCH IF HIGH\n         STC   R15,VTOCNEXT+7          * ELSE SAVE BUMPED VALUE\n         BR    R9                      * THEN RETURN\nNEXTTRK  MVI   VTOCNEXT+7,1            * RESET R TO 1\n         LH    R15,VTOCNEXT+5          * PICK UP CC\n         LH    R1,DS4DEVSZ+2           * AND NO. TRKS/CYL\n         BCTR  R1,0                    * MINUS ONE\n         BXH   R15,R0,NEXTCYL          * BUMP AND TEST\n         STH   R15,VTOCNEXT+5          * SAVE INCREMENTED VALUE\n         BR    R9                      * AND EXIT\nNEXTCYL  AH    R0,VTOCNEXT+3           * ADD 1 TO CC\n         SLL   R0,16                   * INSERT ZEROS ON RIGHT\n         ST    R0,VTOCNEXT+3           * SAVE NEW CCHH\n         BR    R9                      * THEN RETURN\n         EJECT\nREADFMT1 EQU   *                       * READ A FORMAT 1\n         LR    R3,R9                   * SAVE LINK REG\nTSTHPCHR CLC   VTOCNEXT+3(5),DS4HPCHR  * IS ADDR HIGHER THAN\n*                                          HIGHEST FORMAT 1 ?\n         L     R15,EODADDR             * PICK UP EODAD\n         BCR   2,R15                   * GO THERE IF FINISHED\n         BAS   R9,READDSCB             * READ A DSCB\n         CLI   DS1FMTID,C'1'           * IS IT A FORMAT1?\n         BNE   TSTHPCHR                * IF NO, TRY AGAIN\n         AP    FMT1CNT,=P'1'           * INCLUDE THIS DSCB IN COUNT\n         LR    R9,R3                   * RESTORE LINK\n         BR    R9                      * AND RETURN\n         EJECT\nREADTABL EQU   *\n         LA    R4,50(R4)               * BUMP POINTER\n         C     R4,TABLEND              * FINISHED?\n         BH    ENDUP                   * YES\n         MVC   VTOCFDAD+3(5),45(R4)    * MOVE CCHHR FROM TABLE\n         B     READDSCB+6              * GO READ NEXT DSCB\n         EJECT\nENDUP    ED    FLINE1CT,FMT1CNT+1      * SET NO OF DATA SETS IN PRT LNE\n         MVC   0(133,R10),FLINE1       * SET PRINT LINE PROPER\n         L     R11,VTOCDECB+8          * PT @ DCB\n         L     R3,44(R11)              * PICK UP DEB ADDR FROM DCB\n         L     R0,32(R3)               * PICK UP UCB ADDR FROM DEB\n         LA    R1,MESSAGE              * LSPACE MESSAGE AREA\n         SVC   78                      * LSPACE SVC\n         PACK  DBLWD1+5(3),TOTCYLS     * CONVERT TO PACKED DECIMAL\n         PACK  DBLWD2+5(3),TOTTRKS     * CONVERT TO PACKED DECIMAL\n         ED    FLINE2C,DBLWD1+5        * SET NO OF CYLS IN PRT LINE\n         ED    FLINE2T,DBLWD2+5        * SET NO OF TRKS IN PRT LINE\n         PUT   PRINTER                 * GET BUFFER POSITION\n         MVC   0(133,R1),FLINE2        * MOVE INTO BUFFER\n         CLOSE (VTOC,,PRINTER)         * CLOSE FILES\n         FREEPOOL PRINTER              * FREE BUFFERS         DRK JAN10\n         L     R1,TABLADDR             * LOAD TABLE ADDRESS   DRK JAN10\n         LTR   R1,R1                   * GETMAIN SUCCESSFUL?  DRK JAN10\n         BZ    RETURN                  * NO, SKIP FREEMAIN    DRK JAN10\n         L     R5,SAVER5               * RESTORE TABLE SIZE   DRK JAN10\nFREEMAIN FREEMAIN EC,LV=(5),A=TABLADDR * FREE FORMAT1 AREA    DRK JAN10\nRETURN   DS    0H\n         L     R13,4(R13)              * RESTORE R13\n         RETURN (14,12),RC=0           * RETURN TO CALLER\n         EJECT\n* DATE CONVERSION - DATE IN FORMAT YDD IS ASSUMED TO BE IN LAST\n* THREE BYTES OF DWORK\nDATECONV EQU   *                       * CONVERT DATE TO DECIMAL\n         LA    R0,28                   * LOAD 28 DAYS FOR FEBRUARY\n         TM    DWORK+5,3               * TEST FOR LEAP YEAR\n         BNZ   *+8                     * NO, SKIP NEXT INSTR\n         LA    R0,29                   * YES, 29 DAYS IN FEB\n         STH   R0,DATETABL+2           * STORE FEB DAYS\n         LA    R15,DATETABL            * POINT TO TABLE START\n         LA    R1,DATETABL+22          * AND TABLE END\n         LA    R0,2                    * LOAD BXLE INCREMENT\n         LH    R14,DWORK+6             * PICK UP # DAYS IN YEAR\nDATELOOP SH    R14,0(R15)              * SUBTRACT TABLE ENTRY\n         BNP   MNTHFND                 * IF -VE, HAVE HIT REQD MONTH\n         BXLE  R15,R0,DATELOOP         * ELSE LOOP AGAIN\n         XC    DWORK,DWORK             * IF NO MATCH, THEN ERROR\n         BR    R9                      * SO RETURN\nMNTHFND  AH    R14,0(R15)              * ALLOW FOR LAST SUBTRACT\n         S     R15,=A(DATETABL-2)      * FIND TABLE DISPLACEMENT\n         MH    R15,=H'5000'            * OBTAIN MONTH*10000\n         MH    R14,=H'100'             * AND DAY*100\n         SR    R0,R0                   * CLEAR R0\n         IC    R0,DWORK+5              * GET YEAR NO. 000000YY\n         C     R0,=F'100'              * Y2K DATE?\n         BL    *+8                     * NO\n         S     R0,=F'100'              * YES, AVOID OVERFLOW INTO DD\n         AR    R0,R14                  * ADD DAY      0000DDYY\n         AR    R0,R15                  * AND MONTH    00MMDDYY\n         CVD   R0,DWORK                * CONVERT      0MMDDYYC\n         MVO   DWORK,DWORK             * AND SHIFT    MMDDYYCC\n         BR    R9                      * RETURN FOR EDIT\nDATETABL DC    H'31,28,31,30,31,30'    * TABLE USED TO FIND\n         DC    H'31,31,30,31,30,31'    * THE NUMBER OF THE MONTH\n         PUSH  USING                   * SAVE USING STATUS\n         DROP  ,                       * DROP ALL BASE REGS\n         EJECT\nIOERR    EQU   *                       * SYNAD ROUTINE\n         USING *,R15                   * R13 IS CLOBBERED\n         SYNADAF ACSMETH=BDAM          * PERFORM SYSTEM ERROR ANALYSIS\n         MVC   SYNERMSG(60),68(R1)     * MOVE USEFUL PART OF SYSMSG\n         MVC   SYNADVOL,JFCBVOLS       * SET VOL SER NO IN MESSAGE\n         WTO   MF=(E,SYNADMSG)         * ISSUE ERROR MESSAGE\n         BASR  R15,0                   * R15 DESTROYED BY WTO\n         USING *,R15                   * SO BASE MUST BE RESET\n         MVI   DS1FMTID,X'00'          * ENSURE BAD DSCB IGNORED\n         SYNADRLS ,                    * RESTORE R13\n         DROP  R15                     * RELEASE R15\n         BR    R14                     * RETURN TO CHECK ROUTINE\n         POP   USING                   * RESTORE USING STATUS\n         EJECT\nDBLWD1   DC    D'0'                    * WORK AREA FOR FREE CYL COUNT\nDBLWD2   DC    D'0'                    * WORK AREA FOR FREE TRK COUNT\nDWORK    DC    D'0'                    * WORKAREA\nVTOCFDAD DC    D'0'                    * FULL DISC ADDR - MBBCCHHR\nSAVER5   DC    F'0'                    * SAVEAREA FOR R5      DRK JAN10\nTABLADDR DC    A(0)                    * ADDRESS OF TABLE OF DSCB'S\nTBLWIDTH DC    A(50)                   * SIZE OF TABLE ENTRY\nTABLEND  DC    A(0)                    * END OF TABLE\nRTNADDR  DC    A(READTABL)             * DEFAULT ROUTINE\nEODADDR  DC    A(VTOCEOD)              * END-OF-FILE ROUTINE\nFMT1CNT  DC    PL4'0'                  * NO OF FORMAT 1 DSCBS READ\nLASTBLK  DC    XL5'00'                 * SAVEAREA FOR LAST BLOCK PNTR\nVTOCNEXT DC    XL8'00'                 * MUST ALIGN AT FULLWD+1\nLINECNTR DC    P'000'                  * LINE COUNTER\nMAXLINES DC    P'54'                   * LINES PER PAGE\nPAGECNTR DC    P'000'                  * PAGE COUNTER\nPARM     DC    CL3' '                  * JCL PARM HOLD AREA\nHALFWD   DC    H'0'                    * WORK AREA FOR ALIGNMENT\nDIRSTAT  DC    XL1'00'                 * PDS DIR STATUS\nDIRTOTAL DC    PL3'0'                  * PDS DIR BLKS ALLOC\nDIRUSED  DC    PL3'0'                  * PDS DIR BLKS USED\nDIRPATT  DC    X'402020202120'         * EDIT MASK FOR DIR BLKS\nMASKCCCC DC    X'402020202120'         * EDIT MASK FOR CYLINDERS\nMASKTRKS DC    X'4020202020202120'     * EDIT MASK FOR TRKS ALLOC\nCCCCWORK DC    CL6' '                  * WORK AREA FOR CYLINDER EDIT\nTRKSWORK DC    CL8' '                  * WORK AREA FOR TRKS ALLOC EDIT\nFMTYPES  DC    CL8'FVTBSAM'            * PERMISSIBLE RECFM'S\nORGTYPES DC    C'  POMQCQCXDAPSIS'     * DSORG TYPES\nSECTYPES DC    C'BLKTRKCYL'            * TYPES OF ALLOCATION\nLNEDMSK  DS    0CL88                   * EDIT MASK FOR DSN OUTPUT LINE\n         DC    2X'402120612020612020'  * CREATION/LAST REF DATE\n         DC    C' '\n         DC    CL3' '                  * DSORG(U)\n         DC    C' '\n         DC    CL5' '                  * RECFM\n         DC    X'402020202020'         * BLKSIZE\n         DC    X'402020202020'         * LRECL\n         DC    C' '\n         DC    X'402020202120'         * TRKS ALLOC\n         DC    X'40202120'             * PERCENT USE\n         DC    X'40202120'             * NUMBER OF EXTENTS\n         DC    C' '\n         DC    X'402020202120'         * SECONDARY EXTENT QUANTITY\n         DC    C' '\n         DC    CL3' '                  * SECONDARY EXTENT TYPE\n         DC    C' '                    *\nLNEXTDSC DS    0CL21                   * EXTENT DESCRIPTION\n         DC    X'40202120'             * EXTENT NUMBER\n         DC    C' '\n         DC    X'4020212040202120'     * CCHH OF EXTENT\n         DC    CL2' '\n         DC    X'402020202120'         * NO OF TRKS IN EXTENT\n         PRINT NOGEN\nPRINTER  DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PL,LRECL=133,            *\n               RECFM=FBA\nVTOC     DCB   DDNAME=SYSUT1,DSORG=DA,MACRF=RIC,OPTCD=A,               *\n               SYNAD=IOERR,RECFM=FS,BLKSIZE=96,KEYLEN=44,EXLST=VTOCXLST\nPDS      DCB   DDNAME=SYSUT1,                                          *\n               RECFM=U,                                                *\n               BLKSIZE=256,                                            *\n               EODAD=PDSEOF,                                           *\n               DSORG=PS,                                               *\n               MACRF=GL,                                               *\n               EXLST=VTOCXLST\nOPENVTOC OPEN  (VTOC,INPUT),MF=L       * LIST FOR E-TYPE OPEN, RDJFCB\nVTOCXLST DC    X'87',AL3(JFCBAREA)     * JFCB ENTRY IN EXIT LIST\nSYNADMSG DC    AL2(JFCBDSNM+44-*,0)    * WTO RECD DESCRIPTOR WORD\n         DC    C'VTOCLIST - I/O ERROR READING VTOC ON '\nSYNADVOL DC    C'******'\n         DC    C', SYNADAF INFO ='\nSYNERMSG DC    CL16' '                 * INITIALISE TO SPACES\n         ORG   *-4                     * BACKSPACE\n         DS    0F                      * ALIGN TO FULLWORD\nJFCBAREA DS    0CL176                  * SPACE FOR VTOC JFCB\nJFCBDSNM DS    CL44                    * VTOC DSN - ALSO SYNAD WRKAREA\n         DS    CL132                   * SPACE FOR REST OF JFCB\nJFCBVOLS EQU   JFCBAREA+118            * VOLUME SERIAL NO.\n         EJECT\n         PRINT GEN\n         IECSDSL1 (1)                  * FORMAT 1 DSCB\nDS4DATA  DS    0CL71\n         IECSDSL1 (4)                  * FORMAT 4 DSCB\n         EJECT\nMESSAGE  DC    30C'0'                  * OUTPUT AREA FOR LSPACE SVC\n         ORG   MESSAGE\n         DS    CL6\nTOTCYLS  DS    CL4                     * FREE CYLINDERS\n         DS    CL1\nTOTTRKS  DS    CL4                     * FREE TRACKS\n         ORG   ,\nHDR1     DC    133C'*'\n         ORG   HDR1\n         DC    C'1*** CONTENTS OF '\nHDR1FILE DC    C'THE VOLUME TABLE OF CONTENTS'\n         DC    C' ON VOLUME '\nHDR1VOL  DC    C'******'\n         DC    C' *** DATE ='\nHDR1DATE DC    X'402120612020612020'\n         DC    C' *** TIME ='\nHDR1TIME DC    X'4021204B20204B202040'\n         ORG   HDR1+120\n         DC    C' PAGE'\n         DC    X'4020202040'\n         ORG   HDR1+133\nHDR2     DC    CL33'-                                              '\n         DC    C'               DATE     DATE   DS-        BLK-    '\n         DC    C'    TRKS   %  NO.    SEC-ALLOC  EXTENT-DESCRIPTION'\nHDR3     DC    CL33'    DATASET NAME                               '\n         DC    C'              CREATED  LASTREF ORG RECFM  SIZE LRE'\n         DC    C'CL  ALLOC USE EXTS   QTY TYPE   M    CC HH   #TRKS'\nHDR2P    DC    CL33'-                                              '\n         DC    C'             DIRECTORY  BLOCKS DS-        BLK-    '\n         DC    C'    TRKS   %  NO.    SEC-ALLOC  EXTENT-DESCRIPTION'\nHDR3P    DC    CL33'    DATASET NAME                               '\n         DC    C'             ALLOCATED  USED   ORG RECFM  SIZE LRE'\n         DC    C'CL  ALLOC USE EXTS   QTY TYPE   M    CC HH   #TRKS'\nFLINE1   DC    CL15'0 *** THERE ARE'\nFLINE1CT DC    X'402020202120'\n         DC    CL112' DATA SETS ON THIS VOLUME.'\nFLINE2   DC    CL15'  *** THERE ARE'\nFLINE2C  DC    XL6'402020202120'\n         DC    CL21' EMPTY CYLINDERS PLUS'\nFLINE2T  DC    XL6'402020202120'\n         DC    CL85' EMPTY TRACKS ON THIS VOLUME.'\n         LTORG\n         DC    0F'0'                   * ENSURE XTNTAREA ALIGNED\nXTNTAREA DC    30X'00'                 * EXTENTS 1-3   (F1)\n         DC    2600X'00'               * EXTENTS 4-263 (F3, 20 MAX)\n         EJECT\nHDRLINE  DSECT\n         DS    CL125\nHDPAGCNT DS    XL4\nDSNLINE  DSECT\nLNCC     DS    C                       * CARRIAGE CONTROL BYTE\nLNDSN    DS    CL44                    * DATASET NAME\nLNCREDT  DS    CL9                     * CREATION DATE\nLNREFDT  DS    CL9                     * LAST REFERENCE DATE\n         DS    C\nLNDSORG  DS    CL2                     * DSORG\nLNDSORGU DS    C                       * UNMOVABLE FLAG\n         DS    C\nLNRECFM  DS    5C                      * RECFM\nLNBLKSI  DS    CL6                     * BLKSIZE\nLNLRECL  DS    CL6                     * LRECL\n         DS    C\nLNNOTRKS DS    CL6                     * TOTAL NO. OF TRKS ALLOCATED\nLNUSAGE  DS    CL4                     * PERCENTAGE USE OF ALLOC SPACE\nLNNOEXT  DS    CL4                     * NUMBER OF EXTENTS\n         DS    C\nLNSCALO  DS    CL6                     * SECONDARY ALLOCATION QTY\n         DS    C\nLNSCTYPE DS    CL3                     * TYPE OF ALLOC - TRK/CYL/BLK\n         DS    C\nLNXDM    DS    CL4                     * EXTENT-DESCRIPTION - M\n         DS    C\nLNXDCCHH DS    CL8                     * EXTENT DESCRIPTION - CCHH\n         DS    CL2\nLNXD#TRK DS    CL6                     * EXTENT DESCRIPTION - NO OF TRK\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VTOCTOT": {"ttr": 32515, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x13\\x01\\x01\\x15_\\x01\\x01\\x15_\\x14\\x15\\x00_\\x00_\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf3\\xf6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-06-04T00:00:00", "modifydate": "2001-06-04T14:15:13", "lines": 95, "newlines": 95, "modlines": 0, "user": "CBT436"}, "text": "//#TSMSZ1T JOB (SYS,9999),'MARK ZELDEN',\n//             NOTIFY=&SYSUID,\n//             CLASS=J,MSGCLASS=T,MSGLEVEL=(1,1)\n//*\n//VTOC     EXEC PGM=IKJEFT01,REGION=2M\n//STEPLIB DD    DISP=SHR,DSN=#TSMSZ1.LOADLIB /* VTOC COMMAND */\n//SYSTSPRT DD   DSN=&&TEMP,DISP=(NEW,PASS,DELETE),\n//  UNIT=SYSALLDA,SPACE=(CYL,(5,5),RLSE),\n//  DCB=(LRECL=133,BLKSIZE=0,RECFM=FB)\n//*\n//*  VTOC IS FROM CBT FILE 112 - http://www.cbttape.org\n//*  VTOC COMMAND SYNTAX TO USE:\n//*  VTOC volmask SORT   (use volmask of \"ALL\" for all volumes)\n//*\n//SYSTSIN  DD   *\n    VTOC ALL SORT\n/*\n//*\n//GENEXEC  EXEC PGM=IEBGENER\n//SYSPRINT DD  SYSOUT=*\n//SYSUT2   DD  DSN=&&PDS(VTOCTOT),DISP=(NEW,PASS,DELETE),\n//  UNIT=SYSALLDA,SPACE=(TRK,(1,1,1)),\n//  DCB=(LRECL=80,BLKSIZE=3120,RECFM=FB)\n//SYSIN    DD  DUMMY\n//SYSUT1   DD  DATA,DLM=##\n/* REXX */\n/*                                       */\n/* AUTHOR: Mark Zelden                   */\n/*                                       */\n/* Process VTOC command output and       */\n/* total allocations by HLQ.             */\n/*                                       */\n/*****************************************/\n/* VTOC COMMAND SYNTAX EXPECTED:         */\n/*    VTOC ALL SORT                      */\n/*      or                               */\n/*    VTOC volmask SORT                  */\n/*****************************************/\n/* allocate input file                   */\n/*****************************************/\n   /* \"ALLOC FI(INPUT) DA('userid.VTOC.OUTPUT')   SHR REUSE\" */\n/*****************************************/\n/* read input file into stem variables   */\n/*****************************************/\n\"EXECIO  *  DISKR INPUT (STEM INREC. FINIS\"\n   /* \"FREE  FI(INPUT)\"  */\n/******************************************/\nj        = 0      /* total # of dsns      */\ntothlq   = 0      /* total alloc by hlq   */\ntothdsn  = 0      /* total # of hlq dsns  */\ntotalloc = 0      /* total alloc all dsns */\nnumhlq   = 0      /* total # unique hlqs  */\noldhlq   = '????????' /* init oldhlq      */\n/******************************************/\nDo i = 1 to inrec.0\n  chkalc = Substr(inrec.i,3,5)\n  If Datatype(chkalc,Number) <> 1 then iterate  /* record not needed */\n  j = j + 1                               /* add 1 to tot # of dsns  */\n  dsn.j     = Substr(inrec.i,63,44)       /* extract dsn from ip rec */\n  /* vol.j  = Substr(inrec.i,56,44) */    /* extract vol from ip rec */\n  alloc.j   = chkalc          /* total tracks allocated for this dsn */\n  dotpos    = Pos('.',dsn.j)  /* find where the hlq ends             */\n  If dotpos = 0 then curhlq = Strip(dsn.j)   /* sinqle node data set */\n    Else curhlq  = Substr(dsn.j,1,dotpos-1)  /* extract hlq from dsn */\n  If curhlq  <> oldhlq & j <> 1 then call TOTAL_HLQ /*total this hlq */\n  oldhlq    = curhlq                /* reset oldhlq to current hlq   */\n  tothlq    = tothlq + alloc.j      /* add to current total by hlq   */\n  tothdsn   = tothdsn + 1           /* add 1 to tot # of dsns by hlq */\nEnd  /* do */\n/******************************************/\n/* write total and exit                   */\n/******************************************/\ncall TOTAL_HLQ  /* total current/last hlq */\nSay  ' '\nSay  totalloc  'Total tracks allocated  ' ,\n     Format((totalloc/15),,0) 'Total cylinders allocated  ',\n     j  'Total data sets  ' numhlq 'Total HLQs'\nExit 0\n\nTOTAL_HLQ: /* totals for current hlq */\nSay  Right(oldhlq,8,' ') '-',\n     Right(tothlq,8,' ')  'Tracks allocated  ' ,\n     Right(Format((tothlq/15),,0),7,' ') 'Cylinders allocated  ' ,\n     Right(tothdsn,7,' ') 'Data sets'\ntotalloc = totalloc + tothlq    /* add to total for all data sets    */\nnumhlq   = numhlq + 1           /* add 1 to total # of hlqs          */\ntothlq  = 0                     /* reset tot alloc by hlq            */\ntothdsn = 0                     /* reset tot # dsns by hlq           */\nReturn\n##\n//PROCESS  EXEC PGM=IRXJCL,PARM='VTOCTOT'\n//SYSTSIN  DD DUMMY\n//SYSTSPRT DD SYSOUT=*\n//SYSEXEC  DD DSN=&&PDS,DISP=(OLD,DELETE)\n//INPUT    DD DSN=&&TEMP,DISP=(OLD,DELETE)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XBROWSE": {"ttr": 32518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x992/\\x01\\x02\\x13_\\x08\\x15\\x00,\\x00\\t\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf4\\xf7@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "2002-05-15T08:15:00", "lines": 44, "newlines": 9, "modlines": 0, "user": "CBT447"}, "text": "/* REXX */\n/*                                       */\n/* AUTHOR: Mark Zelden                   */\n/*                                       */\n/* Last update:  05/15/2002              */\n/*****************************************************************/\n/*  XBROWSE - BROWSE a data set from anywhere.                   */\n/*                                                               */\n/*  Best used when set up in the ISPF command table with an      */\n/*  abbreviation of \"XB\".                                        */\n/*    VERB      T   ACTION                                       */\n/*    XBROWSE   2   SELECT CMD(%XBROWSE &ZPARM) NEWAPPL(ISR)     */\n/*                                                               */\n/*  Fully qualified data set names are now optional, regardless  */\n/*  of the TSO PROFILE PREFIX setting. PREFIX.DATA.SET.NAME will */\n/*  be tried first, then DATA.SET.NAME for data sets that are    */\n/*  not fully qualified.                                         */\n/*                                                               */\n/*****************************************************************/\n/* COMMAND SYNTAX:                                               */\n/*                                                               */\n/*  XB DATA.SET.NAME  <volser>    (VOLSER is optional)           */\n/*                                                               */\n/*  XB 'MY.PDS(ABC*)'                                            */\n/*  XB PDS.NOTCAT USER01                                         */\n/*                                                               */\n/*  If not set up as an ISPF command, then you can still         */\n/*  invoke the exec by typing:   TSO %XBROWSE DATA.SET.NAME      */\n/*****************************************************************/\nParse UPPER ARG DSN VOL\n\nIf DSN= '' then do                          /* no DSN specified      */\n  say 'Please enter positional parameter dsn -' /* prompt for dsn    */\n  parse upper pull DSN                      /* get dsn response      */\nEnd\n\nAddress ISPEXEC\n\"CONTROL ERRORS RETURN\"\n\"BROWSE DATASET(\"DSN\") VOLUME(\"VOL\")\"       /* try userid.DSN first  */\nIf RC <> 0 then do                          /* not found - try again */\n   DSN =  Strip(Translate(DSN,\"\",\"'\"))      /* remove quotes if used */\n  \"BROWSE DATASET('\"DSN\"') VOLUME(\"VOL\")\"   /* try DSN specified     */\nEnd\nIf RC <> 0 then \"SETMSG MSG(\"ZERRMSG\")\"     /* not found - issue msg */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XDSLIST": {"ttr": 32520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x05\\x04_\\x01\\x05\\x04_\\x08\\x00\\x00*\\x00)\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf6\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-02-14T00:00:00", "modifydate": "2005-02-14T08:00:00", "lines": 42, "newlines": 41, "modlines": 0, "user": "CBT469"}, "text": "/* REXX */\n/*                                       */\n/* AUTHOR: Mark Zelden                   */\n/*                                       */\n/* Last update:  02/14/2005              */\n/*****************************************************************/\n/*  XDSLIST - DSLIST (ISPF 3.4) from anywhere.                   */\n/*                                                               */\n/*  Best used when set up in the ISPF command table with an      */\n/*  abbreviation of \"XD\".                                        */\n/*    VERB      T   ACTION                                       */\n/*    XDSLIST   2   SELECT CMD(%XDSLIST &ZPARM) NEWAPPL(ISR)     */\n/*                                                               */\n/*****************************************************************/\n/* COMMAND SYNTAX:                                               */\n/*                                                               */\n/*  XD dsname.level   <volser>    (VOLSER is optional)           */\n/*                                                               */\n/*  XD           (USERID.* is used as dsname level by default)   */\n/*  XD SYS1.ISF                                                  */\n/*  XD SYS2.*.PROCLIB                                            */\n/*  XD SYS2.NOTCAT USER01                                        */\n/*                                                               */\n/*  Note: If single quotes are used around the DSNLEV then       */\n/*  they will be automatically removed.                          */\n/*                                                               */\n/*  If not set up as an ISPF command, then you can still         */\n/*  invoke the exec by typing:   TSO %XDSLIST dsname.level       */\n/*****************************************************************/\nParse UPPER ARG DSNLEV VOL\n\nIf DSNLEV= '' then do               /* no DSNLEV specified           */\n  UID    = Sysvar('SYSUID')         /* tso userid                    */\n  DSNLEV = UID || '.*'              /* use USERID.* as default       */\nEnd\nElse DSNLEV = Strip(Translate(DSNLEV,\"\",\"'\"))  /* remove any quotes  */\n\nAddress ISPEXEC\n\"LMDINIT LISTID(XDSLIST) LEVEL(\"DSNLEV\") VOLUME(\"VOL\")\"\n\"LMDDISP LISTID(\"XDSLIST\")\"\nIf RC <> 0 then \"SETMSG MSG(\"ZERRMSG\")\"\nExit RC\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XEDIT": {"ttr": 32522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x992/\\x01\\x02\\x13_\\x08\\x15\\x00K\\x00,\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf4\\xf7@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "2002-05-15T08:15:00", "lines": 75, "newlines": 44, "modlines": 0, "user": "CBT447"}, "text": "/* REXX */\n/*                                       */\n/* AUTHOR: Mark Zelden                   */\n/*                                       */\n/* Last update:  05/15/2002              */\n/*****************************************************************/\n/*  XEDIT - EDIT a data set from anywhere.                       */\n/*                                                               */\n/*  Best used when set up in the ISPF command table with an      */\n/*  abbreviation of \"XE\".                                        */\n/*    VERB      T   ACTION                                       */\n/*    XEDIT     2   SELECT CMD(%XEDIT &ZPARM) NEWAPPL(ISR)       */\n/*                                                               */\n/*  Fully qualified data set names are now optional, regardless  */\n/*  of the TSO PROFILE PREFIX setting. PREFIX.DATA.SET.NAME will */\n/*  be tried first, then DATA.SET.NAME for data sets that are    */\n/*  not fully qualified.                                         */\n/*                                                               */\n/*****************************************************************/\n/* COMMAND SYNTAX:                                               */\n/*                                                               */\n/*  XE DATA.SET.NAME  <volser>    (VOLSER is optional)           */\n/*                                                               */\n/*  XE 'MY.PDS(ABC*)'                                            */\n/*  XE PDS.NOTCAT USER01                                         */\n/*                                                               */\n/*  If not set up as an ISPF command, then you can still         */\n/*  invoke the exec by typing:   TSO %XEDIT DATA.SET.NAME        */\n/*****************************************************************/\nParse UPPER ARG DSN VOL\n\nIf DSN= '' then do                          /* no DSN specified      */\n  say 'Please enter positional parameter dsn -' /* prompt for dsn    */\n  parse upper pull DSN                      /* get dsn response      */\nEnd\n\nAddress ISPEXEC\n\"CONTROL ERRORS RETURN\"\n\"VGET ZPCFMCN PROFILE\"\nIf ZPCFMCN = '/' then CONF = 'YES'\n else CONF = 'NO'\n/************************************/\n/* check if EDIT RECOVERY is needed */\n/************************************/\nEDITOK = 'NOTOK'\nDo while EDITOK = 'NOTOK'\n  \"EDREC QUERY\"\n  If RC = 4 then do\n    \"DISPLAY PANEL(ISREDM02)\"\n    DISPRC = RC\n    \"VGET ZVERB\"\n     If DISPRC = 0 then do\n       If ZEDCMD = '' then \"EDREC PROCESS PASSWORD(\" || PSWD || \")\"\n       If ZEDCMD = 'C' then \"EDREC CANCEL\"\n       If ZEDCMD = 'D' then \"EDREC DEFER\"\n     End\n     Else if DISPRC = 8 & ZVERB = 'CANCEL' then \"EDREC CANCEL\"\n     Else EXIT 0\n  End\n  Else EDITOK = 'OK'\nEnd\nRC = 0\n/************************************/\n/* end of RECOVERY CHECK            */\n/************************************/\n\"EDIT DATASET(\"DSN\") VOLUME(\"VOL\")\" ,       /* try userid.DSN first  */\n\"CONFIRM(\"CONF\")\"\nIf RC = 4 then RC = 0\nIf RC <> 0 then do                          /* not found - try again */\n   DSN =  Strip(Translate(DSN,\"\",\"'\"))      /* remove quotes if used */\n  \"EDIT DATASET('\"DSN\"') VOLUME(\"VOL\")\" ,   /* try DSN specified     */\n  \"CONFIRM(\"CONF\")\"\nEnd\nIf RC = 4 then RC = 0\nIf RC <> 0 then \"SETMSG MSG(\"ZERRMSG\")\"     /* not found - issue msg */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XEF": {"ttr": 32525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06+\\x00\\x00\\x01\\x00\\x11\\x1f\\x01\\x11\\x17\\x8f\\x14\\x15\\x00\\x07\\x00\\x06\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf3@@@@'", "ispf": {"version": "06.43", "flags": 0, "createdate": "2000-04-20T00:00:00", "modifydate": "2011-06-27T14:15:00", "lines": 7, "newlines": 6, "modlines": 0, "user": "CBT483"}, "text": "/* REXX */\n/* Invoke XEF .. if APPLID is not ISR, reinvoke it */\nAddress ISPEXEC\n\"VGET ZAPPLID PROFILE SHARED\"\nIf zapplid <> 'ISR' then \"SELECT CMD(%XEF) NEWAPPL(ISR)\"\nElse\n\"SELECT PANEL(XEFMENU)\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XEFCLIST": {"ttr": 32527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06+\\x00\\x00\\x01\\x00\\x11\\x1f\\x01\\x130_\\tP\\x02_\\x01}\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf8@@@@'", "ispf": {"version": "06.43", "flags": 0, "createdate": "2000-04-20T00:00:00", "modifydate": "2013-11-01T09:50:00", "lines": 607, "newlines": 381, "modlines": 0, "user": "CBT488"}, "text": "    PROC 2 XOPT XDN XMEM()\n  /*****************************************************************/\n  /* XEF - VERSION 6.4.3   WRITTEN BY MARK ZELDEN                  */\n  /*                       LASTUPD   11/01/2013                    */\n  /*                                                               */\n  /* V1.0 - EDIT,BROWSE,ATTRIBUTES LIST, ADD DSN, AND REMOVE       */\n  /*        DSN OPTIONS.                                           */\n  /* V2.0 - ADDED MEMBER LIST OPTION.                              */\n  /* V3.0 - ADDED COMPRESS OPTION AND REMOVED THE ADD & REMOVE     */\n  /*        OPTIONS. DATASETS ARE NOW ADDED BY TYPING THEM IN      */\n  /*        DIRECTLY ON THE MAIN MENU.                             */\n  /* V4.0 - INCREASED NUMBER OF DATASETS FROM 24 TO 34 AND         */\n  /*        ADDED EDIT RECOVERY CODE.                              */\n  /* V5.0 - ADDED DATASET INFORMATION OPTION, REMOVED LIST OPTION. */\n  /* V5.1 - ADDED MEMBER PATTERN SUPPORT FOR MEMBER LIST OPTION    */\n  /* V5.2 - ADDED ENHANCED MEMBER PATTERN SUPPORT FOR ISPF V3.     */\n  /* V6.0 - INCREASED NUMBER OF DATASETS FROM 34 TO 99 AND MADE    */\n  /*        THE DATASET LIST SCROLLABLE. ADDED VIEW OPTION ON MAIN */\n  /*        PANEL AND MEMBER LIST TO SUPPORT ISPF V4. ADDED        */\n  /*        \"USED EXTENTS\" CODE TO CLIST AND TO DSN INFO PANELS.   */\n  /*        ADDED CURSOR SELECTION OF DATASETS.                    */\n  /* V6.0.1 ADDED CODE TO HONOR \"CONFIRM\" SETTING FOR EDIT/VIEW    */\n  /* V6.1 - ADDED PDS OPTION - TO REMOVE PDS SUPPORT, CHANGE       */\n  /*        &PDS = Y TO &PDS = N IN THE PROC SECTION OF XEFMENU.   */\n  /*        IF THE PDS COMMAND HAS A DIFFERENT NAME THAN PDS, SUCH */\n  /*        AS PDS85, YOU MUST CHANGE THE COMMAND IN THE CODE BELOW*/\n  /*        IN THE \"PDS MEMBER\" SECTION AND THE \"PDS ALL\" SECTION. */\n  /* V6.2 - ADDED DATASET INFORMATION SUPPORT FOR SMS CONTROLLED   */\n  /*        DSNS. ADDED 3 PANELS - XEFINFE, XEFINFP, & XEFINFS.    */\n  /* V6.3 - ADDED DSLIST OPTION (ISPF 3.4) SO DSN PATTERNS CAN     */\n  /*        BE SAVED IN THE XEF MENU. OS/390 2.10 (ISPF V5) OR     */\n  /*        ABOVE IS NOW REQUIRED.                                 */\n  /* V6.4 - ADDED FIND OPTION TO FIND DATASETS IN THE LIST THAT    */\n  /*        MATCH A SEARCH STRING.                                 */\n  /* V6.4.1 ADDED DELETE MEMBER CONFIRMATION FOR MEMBER LIST AND   */\n  /*        HONOR \"CONFIRM\" SETTING.                               */\n  /*        FORCE DSLIST OPTION IF NAME IS A PATTERN.              */\n  /* V6.4.2 BLANK OUT THE SAVED \"F\" IN THE OPTION FIELD IF ANY     */\n  /*        DATA SETS ARE FOUND THAT MATCH THE SEARCH STRING.      */\n  /*        CHANGE XEFMENU PANEL SO THE COMMAND FIELD IS NOW       */\n  /*        THE \"OTHER DSN\" FIELD INSTEAD OF THE OPTION FIELD      */\n  /*        SO OPTIONS THAT CONFLICT WITH SCROLLING REMAIN         */\n  /*        IN THE OPTION FIELD WHILE SCROLLING THE LIST OF        */\n  /*        DATA SETS (M, D, & P). ALSO ADDED CODE TO THE PANEL    */\n  /*        TO ALLOW THE FULL OPTION NAME TO BE USED INSTEAD OF    */\n  /*        A SINGLE CHARACTER.  FOR EXAMPLE: \"EDIT\" INSTEAD OF    */\n  /*        \"E\", \"BROWSE\" INSTEAD OF \"B\" ETC.                      */\n  /* V6.4.3 MOVED CHECK FOR NULL DATA SET NAME AFTER THE \"FIND\"    */\n  /*        OPTION CODE.                                           */\n  /*****************************************************************/\n  /* CONTROL LIST SYMLIST CONLIST  */\n    ISPEXEC CONTROL ERRORS RETURN\n /* DETERMINE ISPF LEVEL */\n    ISPEXEC VGET ZENVIR\n    SET XIVER3 = &SUBSTR(6:8,&ZENVIR)\n    SET XIVER1 = &SUBSTR(1:1,&XIVER3)\n    IF &XIVER1 >= 4 THEN DO\n      ISPEXEC VGET ZPCFMCN PROFILE\n      IF &STR(&ZPCFMCN) = &STR(/) THEN +\n        SET &CONF = &STR(YES)\n      ELSE +\n        SET &CONF = &STR(NO)\n    END\n /*                      */\n    ISPEXEC VGET XDSN&XDN PROFILE\n    SET &NAME = &STR(&&XDSN&XDN)\n    SET &NAME = &STR(&NAME)\n  /*********************************/\n  /* CHECK FOR \"OTHER DATASET\"     */\n  /*********************************/\n    ISPEXEC VGET XODSN PROFILE\n    IF &STR(&XODSN) \u00ac= &STR() THEN DO\n       SET &NAME = &STR(&XODSN)\n       SET &NAME = &STR(&NAME)\n    END\n  /*********************************/\n  /* FIND OPTION                   */\n  /*********************************/\n /* IF &XOPT = &STR(F) OR &XOPT = &STR(FIND) THEN DO\n    IF &XOPT = &STR(F) THEN DO\n      CONTROL ASIS\n      WRITE Please type the search string and hit enter:\n      CONTROL CAPS\n      READ FNAME\n      SET &FOUND = NOTFOUND\n      SET &NUMFD = 0\n  /*  DO &XCOUNT = 01 TO 99 WHILE &FOUND = NOTFOUND /*1ST MATCH ONLY*/\n      DO &XCOUNT = 01 TO 99\n        ISPEXEC VGET XDSN&XCOUNT PROFILE\n        SET &NAME = &STR(&&XDSN&XCOUNT)\n        SET &NAME = &STR(&NAME)\n        IF &SYSINDEX(&FNAME,&NAME) \u00ac= 0 THEN DO\n          IF &XCOUNT LT 10 THEN SET &XCOUNT = &STR( &XCOUNT)\n          WRITE &XCOUNT &NAME\n          SET &FOUND = FOUNDIT\n          SET &NUMFD = &NUMFD+1\n          SET &SAVFD = &XCOUNT\n          SET &XOPT  = &STR()   /* IF ANY MATCH, BLANK OUT FIND OPT */\n          ISPEXEC VPUT XOPT\n        END\n      END\n      IF &NUMFD = 1 THEN DO /* IF ONLY 1 MATCH, UPDATE NUM IN MENU */\n        SET &XN = &SAVFD\n        ISPEXEC VPUT XN\n      END\n      IF &FOUND = NOTFOUND THEN DO\n        SET &ZERRMSG = &STR(XEF008A)\n        ISPEXEC SETMSG MSG(&ZERRMSG)\n        GOTO ENDIT\n      END\n    END\n  /*********************************/\n  /* CHECK FOR NULL DATASET NAME   */\n  /*********************************/\n    IF &STR(&NAME) = &STR() THEN DO\n       SET &ZERRMSG = &STR(XEF004A)\n       ISPEXEC SETMSG MSG(&ZERRMSG)\n       GOTO ENDIT\n    END\n  /***********************************/\n  /* FORCE DSLIST IF PATTERN IN NAME */\n  /***********************************/\n  IF &SYSINDEX(*,&NAME) \u00ac= 0 OR &SYSINDEX(%,&NAME) \u00ac= 0 THEN DO\n    SET &XOPT = &STR(D)\n    ISPEXEC VPUT XOPT PROFILE\n  END\n  /*********************************/\n  /* DATASET INFORMATION OPTION    */\n  /*********************************/\n    IF &XOPT = &STR(I) THEN DO\n       LISTDSI '&NAME' NORECALL DIRECTORY SMSINFO\n       SET &RC = &LASTCC\n          IF &RC = 16 THEN DO\n          SET &XERRMSG = &SUBSTR(11:&LENGTH(&STR(&SYSMSGLVL2)),+\n                         &SYSMSGLVL2)\n          SET &ZERRMSG = &STR(XEF007A)\n          ISPEXEC SETMSG MSG(&ZERRMSG)\n          GOTO ENDIT\n          END\n       SET &DSNAME   = &STR(&SYSDSNAME)\n       SET &VOLUME   = &STR(&SYSVOLUME)\n       SET &UNIT     = &STR(&SYSUNIT)\n       SET &DSORG    = &STR(&SYSDSORG)\n       SET &RECFM    = &STR(&SYSRECFM)\n       SET &LRECL    = &STR(&SYSLRECL)\n       SET &BLKSIZE  = &STR(&SYSBLKSIZE)\n       SET &ALLOC    = &STR(&SYSALLOC)\n       SET &USED     = &STR(&SYSUSED)\n       SET &PRIMARY  = &STR(&SYSPRIMARY)\n       SET &SECONDS  = &STR(&SYSSECONDS)\n       SET &UNITS    = &STR(&SYSUNITS)\n       SET &EXTENTS  = &STR(&SYSEXTENTS)\n       SET &CREATE   = &STR(&SYSCREATE)\n       SET &REFDATE  = &STR(&SYSREFDATE)\n       SET &EXDATE   = &STR(&SYSEXDATE)\n       SET &UPDATED  = &STR(&SYSUPDATED)\n       SET &ADIRBLK  = &STR(&SYSADIRBLK)\n       SET &UDIRBLK  = &STR(&SYSUDIRBLK)\n       SET &MEMBERS  = &STR(&SYSMEMBERS)\n       /* PDSE VARS */\n    /* SET &DSSMS       = &STR(&SYSDSSMS)      */\n    /* IF &STR(&DSSMS)  \u00ac= &STR(PDS) && +      */\n    /*    &STR(&DSSMS)  \u00ac= &STR(SEQ) THEN +    */\n    /*     SET &DSSMS   = &STR(LIBRARY)        */\n       SET &USEDPAGE    = &STR(&SYSUSEDPAGES)\n       SET &DATACLAS    = &STR(&SYSDATACLASS)\n       SET &STORCLAS    = &STR(&SYSSTORCLASS)\n       SET &MGMTCLAS    = &STR(&SYSMGMTCLASS)\n       /*****************************************/\n       /*  DETERMINE HOW MANY EXTENTS ARE USED  */\n       /*****************************************/\n       IF &STR(&ADIRBLK) = &STR(NO_LIM) THEN DO\n           SET &ADIRBLK  = &STR(NOLIMIT)\n           GOTO SKIPEXT\n       END\n       IF &USED <= &PRIMARY THEN DO\n         SET &USEDEXT=1\n       END\n       ELSE DO\n         SET &TEMPUA = 2\n         SET &TEMPUB = &EVAL(&PRIMARY+&SECONDS)\n       EXTLOOP: +\n         SET &TEMPUC = &EVAL(&TEMPUB/&USED)\n         IF  &TEMPUC = 0 THEN DO\n           SET &USEDEXT = &EXTENTS\n           GOTO SKIPEXT\n         END\n         IF  &TEMPUC >= 1 THEN SET &USEDEXT = &TEMPUA\n         ELSE DO\n           SET &TEMPUB = &EVAL(&TEMPUB+&SECONDS)\n           SET &TEMPUA = &EVAL(&TEMPUA+1)\n           GOTO EXTLOOP\n         END\n       END\n       IF &USEDEXT > &EXTENTS THEN SET &USEDEXT = &EXTENTS\n       /*****************************************/\n       /*  DISPLAY CORRECT INFORMATION PANEL    */\n       /*****************************************/\n       SKIPEXT: +\n       SELECT\n         WHEN (&RC <= 4  AND  &ADIRBLK \u00ac= &STR()) DO   /* PDS */\n            IF &ADIRBLK = &STR(NOLIMIT) THEN +\n             ISPEXEC DISPLAY PANEL(XEFINFE)  /* PDSE */\n            ELSE +\n            IF &STR(&STORCLAS) \u00ac= &STR() THEN +\n             ISPEXEC DISPLAY PANEL(XEFINFP)  /* PDS SMS */\n            ELSE +\n            ISPEXEC DISPLAY PANEL(XEFINFD)   /* PDS NONSMS */\n         END\n         OTHERWISE DO   /* SEQ */\n            IF &STR(&STORCLAS) \u00ac= &STR() THEN +\n             ISPEXEC DISPLAY PANEL(XEFINFS)  /* SEQ SMS */\n            ELSE +\n            ISPEXEC DISPLAY PANEL(XEFINF)    /* SEQ NONSMS */\n         END\n       END\n       EXIT CODE(0)\n    END\n  /*********************************/\n  /* EDIT MEMBER OPTION            */\n  /*********************************/\n    IF &XOPT = &STR(E) THEN +\n       IF &STR(&XMEM) NE &STR() THEN DO\n       SET &EDITOK = NOTOK\n       DO WHILE &EDITOK = NOTOK\n         ISPEXEC EDREC QUERY\n         IF &LASTCC = 4 THEN DO\n           ISPEXEC DISPLAY PANEL(ISREDM02)\n           SET &DISPRC = &LASTCC\n           ISPEXEC VGET ZVERB\n           IF &DISPRC = 0 THEN DO\n             IF &ZEDCMD =   THEN ISPEXEC EDREC PROCESS PASSWORD(&PSWD)\n             IF &ZEDCMD = C THEN ISPEXEC EDREC CANCEL\n             IF &ZEDCMD = D THEN ISPEXEC EDREC DEFER\n           END\n           ELSE IF &DISPRC = 8 && &STR(&ZVERB) = &STR(CANCEL) THEN +\n                ISPEXEC EDREC CANCEL\n           ELSE DO\n             EXIT CODE(0)\n           END\n         END\n         ELSE SET &EDITOK = OK\n       END\n       SET &RC = 0\n       IF &EDITOK = OK && &XIVER1 >= 4 THEN DO\n         ISPEXEC EDIT DATASET ('&NAME(&XMEM)') CONFIRM(&CONF)\n         SET &RC = &LASTCC\n         IF &RC = 4 THEN SET &RC = 0\n       END\n       IF &EDITOK = OK && &XIVER1 < 4 THEN DO\n         ISPEXEC EDIT DATASET ('&NAME(&XMEM)')\n         SET &RC = &LASTCC\n         IF &RC = 4 THEN SET &RC = 0\n       END\n       GOTO ENDIT\n    END\n  /*********************************/\n  /* EDIT ALL OPTION               */\n  /*********************************/\n    IF &XOPT = &STR(E) THEN DO\n       SET &EDITOK = NOTOK\n       DO WHILE &EDITOK = NOTOK\n         ISPEXEC EDREC QUERY\n         IF &LASTCC = 4 THEN DO\n           ISPEXEC DISPLAY PANEL(ISREDM02)\n           SET &DISPRC = &LASTCC\n           ISPEXEC VGET ZVERB\n           IF &DISPRC = 0 THEN DO\n             IF &ZEDCMD =   THEN ISPEXEC EDREC PROCESS PASSWORD(&PSWD)\n             IF &ZEDCMD = C THEN ISPEXEC EDREC CANCEL\n             IF &ZEDCMD = D THEN ISPEXEC EDREC DEFER\n           END\n           ELSE IF &DISPRC = 8 && &STR(&ZVERB) = &STR(CANCEL) THEN +\n                ISPEXEC EDREC CANCEL\n           ELSE DO\n             EXIT CODE(0)\n           END\n         END\n         ELSE SET &EDITOK = OK\n       END\n       SET &RC = 0\n       IF &EDITOK = OK && &XIVER1 >= 4 THEN DO\n         ISPEXEC EDIT DATASET ('&NAME') CONFIRM(&CONF)\n         SET &RC = &LASTCC\n         IF &RC = 4 THEN SET &RC = 0\n       END\n       IF &EDITOK = OK && &XIVER1 < 4 THEN DO\n         ISPEXEC EDIT DATASET ('&NAME')\n         SET &RC = &LASTCC\n         IF &RC = 4 THEN SET &RC = 0\n       END\n       GOTO ENDIT\n    END\n  /*********************************/\n  /* PDS MEMBER OPTION             */\n  /*********************************/\n    IF &XOPT = &STR(P) THEN +\n       IF &STR(&XMEM) NE &STR() THEN DO\n       PDS   '&NAME' SHR ML &XMEM\n       SET &RC = &LASTCC\n       GOTO ENDIT\n    END\n  /*********************************/\n  /* PDS ALL OPTION                */\n  /*********************************/\n    IF &XOPT = &STR(P) THEN DO\n       PDS   '&NAME'\n       SET &RC = &LASTCC\n       GOTO ENDIT\n    END\n  /*********************************/\n  /* BROWSE MEMBER OPTION          */\n  /*********************************/\n    IF &XOPT = &STR(B) THEN +\n       IF &STR(&XMEM) NE &STR() THEN DO\n       ISPEXEC BROWSE DATASET ('&NAME(&XMEM)')\n       SET &RC = &LASTCC\n       GOTO ENDIT\n    END\n  /*********************************/\n  /* BROWSE ALL OPTION             */\n  /*********************************/\n    IF &XOPT = &STR(B) THEN DO\n       ISPEXEC BROWSE DATASET ('&NAME')\n       SET &RC = &LASTCC\n       GOTO ENDIT\n    END\n  /*********************************/\n  /* VIEW MEMBER OPTION            */\n  /*********************************/\n    IF &XOPT = &STR(V) && &XIVER1 >= 4 THEN +\n       IF &STR(&XMEM) NE &STR() THEN DO\n       ISPEXEC VIEW DATASET ('&NAME(&XMEM)') CONFIRM(&CONF)\n       SET &RC = &LASTCC\n       GOTO ENDIT\n    END\n    IF &XOPT = &STR(V) && &XIVER1 < 4 THEN +\n       IF &STR(&XMEM) NE &STR() THEN DO\n       ISPEXEC VIEW DATASET ('&NAME(&XMEM)')\n       SET &RC = &LASTCC\n       GOTO ENDIT\n    END\n  /*********************************/\n  /* VIEW ALL OPTION               */\n  /*********************************/\n    IF &XOPT = &STR(V) && &XIVER1 >= 4 THEN DO\n       ISPEXEC VIEW DATASET ('&NAME') CONFIRM(&CONF)\n       SET &RC = &LASTCC\n       GOTO ENDIT\n    END\n    IF &XOPT = &STR(V) && &XIVER1 < 4 THEN DO\n       ISPEXEC VIEW DATASET ('&NAME')\n       SET &RC = &LASTCC\n       GOTO ENDIT\n    END\n  /*********************************/\n  /* DSLIST OPTION                 */\n  /*********************************/\n    IF &XOPT = &STR(D) THEN DO\n       ISPEXEC LMDINIT LISTID(XEFD1) LEVEL(&NAME)\n       ISPEXEC LMDDISP LISTID(&XEFD1)\n       SET &RC = &LASTCC\n       GOTO ENDIT\n    END\n  /*********************************/\n  /* COMPRESS DATASET OPTION       */\n  /*********************************/\n    IF &XOPT = &STR(Z) THEN DO\n    ISPEXEC LMINIT DATAID(XEFD1) DATASET('&NAME') ENQ(EXCLU)\n    SET &RC = &LASTCC\n     IF &RC = 0 THEN DO\n      ISPEXEC LMCOMP DATAID(&XEFD1)\n      SET &RC = &LASTCC\n      ISPEXEC LMFREE DATAID(&XEFD1)\n     END\n       IF &RC = 0 THEN DO\n       /************************************************/\n       /* THE FOLLOWING CODE IS FOR FINDING OUT THE    */\n       /* DATASET NAME FOR THE COMPRESS LISTING SO IT  */\n       /* CAN BE DISPLAYED WITH THE HELP TEXT          */\n       /************************************************/\n       ISPEXEC VGET ZTEMPF PROFILE SHARED\n           /************************************************/\n           /* CHECK IF ISPCTL DATASET IS A TEMPORARY       */\n           /* DATASET. IF IT IS , DO NOT DISPLAY WHERE     */\n           /* THE COMPRESS LISTING IS BECAUSE IT IS NOT    */\n           /* CATALOGED OR IT COULD BE IN VIO.             */\n           /************************************************/\n           SET XCOMP1 = &LENGTH(&ZTEMPF)\n           IF &XCOMP1 > 22 THEN DO   /* CHECK IF TEMP DSN */\n           SET &ZERRMSG = &STR(XEF005A)\n           ISPEXEC SETMSG MSG(&ZERRMSG)\n           GOTO ENDIT\n           END\n       SET XCOMP2 = &SYSINDEX(SPFTEMP,&ZTEMPF)\n       SET XCOMP3 = &XCOMP2+7\n       SET XCOMP4 = &SUBSTR(&XCOMP2:&XCOMP3,&ZTEMPF)\n       SET XLISTDSN = &SYSUID..&XCOMP4..LIST\n       SET &ZERRMSG = &STR(XEF005B)\n       ISPEXEC SETMSG MSG(&ZERRMSG)\n       END\n     GOTO ENDIT\n    END\n  /*********************************/\n  /* MEMBER LIST OPTION            */\n  /*********************************/\n    IF &XOPT = &STR(M) THEN DO\n       ISPEXEC LMINIT DATAID(XEFD1) DATASET('&NAME')\n       SET &RC = &LASTCC\n       IF &RC = 0 THEN DO\n         ISPEXEC LMOPEN DATAID(&XEFD1)\n         SET &RC = &LASTCC\n         IF &RC = 0 THEN DO\n           SET &ZLLCMD =\n           SET &ZLMEMBER =\n           SET &ZLUDATA =\n           ISPEXEC LMMDISP DATAID(&XEFD1) COMMANDS(ANY) MEMBER(&XMEM)\n           SET &RC = &LASTCC\n           DO WHILE &RC = 0\n             IF &STR(&ZLLCMD) = &STR(B) THEN DO\n               ISPEXEC BROWSE DATAID(&XEFD1) MEMBER(&ZLMEMBER)\n               SET &CC = &LASTCC\n               SET &UD = &STR(*BROWSED)\n               IF &CC \u00ac= 0 THEN ISPEXEC SETMSG MSG(&ZERRMSG)\n               END\n             ELSE IF &STR(&ZLLCMD) = &STR(/) && &XIVER1 \u00ac<4 THEN DO\n               ISPEXEC BROWSE DATAID(&XEFD1) MEMBER(&ZLMEMBER)\n               SET &CC = &LASTCC\n               SET &UD = &STR(*BROWSED)\n               IF &CC \u00ac= 0 THEN ISPEXEC SETMSG MSG(&ZERRMSG)\n               END\n             ELSE IF &STR(&ZLLCMD) = &STR(V) && &XIVER1 \u00ac<4 THEN DO\n               ISPEXEC VIEW DATAID(&XEFD1) MEMBER(&ZLMEMBER) +\n                       CONFIRM(&CONF)\n               SET &CC = &LASTCC\n               SET &UD = &STR(*VIEWED)\n               IF &CC \u00ac= 0 THEN ISPEXEC SETMSG MSG(&ZERRMSG)\n               END\n             ELSE IF &STR(&ZLLCMD) = &STR(E) && &XIVER1 \u00ac<4 THEN DO\n               SET &EDITOK = NOTOK\n               DO WHILE &EDITOK = NOTOK\n                 ISPEXEC EDREC QUERY\n                 IF &LASTCC = 4 THEN DO\n                   ISPEXEC DISPLAY PANEL(ISREDM02)\n                   SET &DISPRC = &LASTCC\n                   ISPEXEC VGET ZVERB\n                   IF &DISPRC = 0 THEN DO\n                     IF &ZEDCMD =   THEN ISPEXEC EDREC PROCESS +\n                        PASSWORD(&PSWD)\n                     IF &ZEDCMD = C THEN ISPEXEC EDREC CANCEL\n                     IF &ZEDCMD = D THEN ISPEXEC EDREC DEFER\n                   END\n                   ELSE IF &DISPRC = 8 && &STR(&ZVERB) = &STR(CANCEL) +\n                        THEN ISPEXEC EDREC CANCEL\n                   ELSE DO\n                     EXIT CODE(0)\n                   END\n                 END\n                 ELSE SET &EDITOK = OK\n               END\n               SET &RC = 0\n               ISPEXEC EDIT DATAID(&XEFD1) MEMBER(&ZLMEMBER) +\n                       CONFIRM(&CONF)\n               SET &CC = &LASTCC\n               IF &CC = 4 THEN SET &CC = 0\n               SET &UD = &STR(*EDITED)\n               END\n             ELSE IF &STR(&ZLLCMD) = &STR(E) && &XIVER1 <4 THEN DO\n               SET &EDITOK = NOTOK\n               DO WHILE &EDITOK = NOTOK\n                 ISPEXEC EDREC QUERY\n                 IF &LASTCC = 4 THEN DO\n                   ISPEXEC DISPLAY PANEL(ISREDM02)\n                   SET &DISPRC = &LASTCC\n                   ISPEXEC VGET ZVERB\n                   IF &DISPRC = 0 THEN DO\n                     IF &ZEDCMD =   THEN ISPEXEC EDREC PROCESS +\n                        PASSWORD(&PSWD)\n                     IF &ZEDCMD = C THEN ISPEXEC EDREC CANCEL\n                     IF &ZEDCMD = D THEN ISPEXEC EDREC DEFER\n                   END\n                   ELSE IF &DISPRC = 8 && &STR(&ZVERB) = &STR(CANCEL) +\n                        THEN ISPEXEC EDREC CANCEL\n                   ELSE DO\n                     EXIT CODE(0)\n                   END\n                 END\n                 ELSE SET &EDITOK = OK\n               END\n               SET &RC = 0\n               ISPEXEC EDIT DATAID(&XEFD1) MEMBER(&ZLMEMBER)\n               SET &CC = &LASTCC\n               IF &CC = 4 THEN SET &CC = 0\n               SET &UD = &STR(*EDITED)\n               END\n             ELSE IF &STR(&ZLLCMD) = &STR(P) THEN DO\n               ISPEXEC LMPRINT DATAID(&XEFD1) MEMBER(&ZLMEMBER)\n               SET &CC = &LASTCC\n               SET &UD = &STR(*PRINTED)\n               IF &CC \u00ac= 0 THEN ISPEXEC SETMSG MSG(&ZERRMSG)\n               END\n             ELSE IF &STR(&ZLLCMD) = &STR(R) THEN DO\n               ISPEXEC LMINIT DATAID(XEFD2) DATASET('&NAME') +\n                 ENQ(SHRW)\n               SET &RC = &LASTCC\n               IF &RC = 0 THEN DO\n                 ISPEXEC LMOPEN DATAID(&XEFD2) OPTION(OUTPUT)\n                 SET &CC = &LASTCC\n                 IF &CC = 0 THEN DO\n                   ISPEXEC LMMREN DATAID(&XEFD2) MEMBER(&ZLMEMBER) +\n                      NEWNAME(&ZLUDATA)\n                   SET &CC = &LASTCC\n                   IF &STR(&ZLUDATA) = THEN DO\n                     SET &ZERRMSG = &STR(ISRU003)\n                     SET &CURLOC  = &STR(ZLUDATA)\n                   END\n                   SET &UD = &STR(*RENAMED)\n                   ISPEXEC LMCLOSE DATAID(&XEFD2)\n                   END\n                 ISPEXEC LMFREE DATAID(&XEFD2)\n                 END\n               END\n             ELSE IF &STR(&ZLLCMD) = &STR(D) THEN DO\n               ISPEXEC LMINIT DATAID(XEFD2) DATASET('&NAME') +\n                 ENQ(SHRW)\n               SET &RC = &LASTCC\n               IF &RC = 0 THEN DO\n                 ISPEXEC LMOPEN DATAID(&XEFD2) OPTION(OUTPUT)\n                 SET &CC = &LASTCC\n                 IF &CC = 0 THEN DO\n                   ISPEXEC VGET ZMEMCONF\n                   IF &ZMEMCONF \u00ac= OFF THEN DO\n                     SET ZCFDSN = &NAME\n                     SET ZCFMEM = &ZLMEMBER\n                     SET &UD = &STR(&Z)\n                     ISPEXEC ADDPOP\n                     ISPEXEC DISPLAY PANEL(ISRUDELC)\n                     SET &DISPRC = &LASTCC\n                     IF &DISPRC EQ 0 THEN DO\n                       ISPEXEC LMMDEL DATAID(&XEFD2) MEMBER(&ZLMEMBER)\n                       SET &CC = &LASTCC\n                       SET &UD = &STR(*DELETED)\n                     END\n                     ISPEXEC REMPOP\n                   END\n                   ELSE DO\n                     ISPEXEC LMMDEL DATAID(&XEFD2) MEMBER(&ZLMEMBER)\n                     SET &CC = &LASTCC\n                     SET &UD = &STR(*DELETED)\n                   END\n                   ISPEXEC LMCLOSE DATAID(&XEFD2)\n                 END\n                 ISPEXEC LMFREE DATAID(&XEFD2)\n               END\n             END\n             ELSE DO\n                 IF &STR(&ZCMD) NE &STR(&Z) THEN DO\n                 SET &ZERRMSG = &STR(XEF006A)\n                 SET &CURLOC  = &STR(ZCMD)\n                 END\n                 ELSE DO\n                 IF &XIVER1 < 4 THEN +\n                   SET &ZERRMSG = &STR(XEF006C)\n                   ELSE +\n                   SET &ZERRMSG = &STR(XEF006B)\n                 SET &CURLOC  = &STR(ZLLCMD)\n                 END\n               SET &CC = 4\n               END\n             IF &CC = 0 THEN DO\n               ISPEXEC LMMDISP DATAID(&XEFD1) OPTION(PUT) +\n                 MEMBER(&ZLMEMBER) ZLUDATA(&UD)\n               ISPEXEC LMMDISP DATAID(&XEFD1) OPTION(GET)\n               SET &RC = &LASTCC\n               IF &RC = 8 THEN DO\n                 ISPEXEC LMMDISP DATAID(&XEFD1) COMMANDS(ANY)\n                 SET &RC = &LASTCC\n                 END\n             END\n             ELSE DO\n               ISPEXEC SETMSG MSG(&ZERRMSG)\n               ISPEXEC LMMDISP DATAID(&XEFD1) OPTION(PUT) +\n                 MEMBER(&ZLMEMBER) ZLLCMD(&ZLLCMD) ZLUDATA(&ZLUDATA)\n               ISPEXEC LMMDISP DATAID(&XEFD1) COMMANDS(ANY) +\n                 CURSOR(&CURLOC) TOP(&ZLMEMBER)\n               SET &RC = &LASTCC\n             END\n             END\n           IF &RC = 8 THEN SET &RC = 0\n           ISPEXEC LMMDISP DATAID(&XEFD1) OPTION(FREE)\n           IF &ZERRSM = &STR(NO MEMBER LIST) THEN DO\n             SET PTRNSTRT = &SYSINDEX(&STR(*),&XMEM)\n             IF &PTRNSTRT > 0 THEN SET &ZERRMSG = &STR(XEF003A)\n             ELSE +\n             SET &ZERRMSG = &STR(XEF003B)\n           END\n           IF &ZERRSM = &STR(DATA SET NOT PARTITIONED) THEN DO\n             SET &ZERRMSG = &STR(XEF003C)\n           END\n           ISPEXEC LMCLOSE DATAID(&XEFD1)\n           END\n         ISPEXEC LMFREE DATAID(&XEFD1)\n    END\nENDIT: +\n    IF &RC \u00ac= 0 THEN ISPEXEC SETMSG MSG(&ZERRMSG)\n    END\n    EXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XEFHELP": {"ttr": 32776, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06+\\x00\\x00\\x01\\x00\\x11\\x1f\\x01\\x11\\x17\\x8f\\x14\\x15\\x00\\x1f\\x00\\x1f\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf3@@@@'", "ispf": {"version": "06.43", "flags": 0, "createdate": "2000-04-20T00:00:00", "modifydate": "2011-06-27T14:15:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "CBT483"}, "text": ")ATTR\n           + TYPE(TEXT)   INTENS(LOW)  COLOR(BLUE)\n           % TYPE(TEXT)   INTENS(HIGH) COLOR(PINK)\n           _ TYPE(INPUT)  INTENS(HIGH) COLOR(RED)\n)BODY EXPAND(//)\n%XEF - eXtended Editor Facility (&ZAPPLID) - HELP  -/-/ V6.4 ---\n%COMMAND ===>_ZCMD\n+\n+ This screen is used for%BROWSING, VIEWING, EDITING+or%COMPRESSING+a dataset.\n+ It allows you to choose a dataset from a menu instead of typing in the entire\n+ dataset name. If a dataset is not listed on the menu, you may still select it\n+ by using the%\"OTHER DATASET NAME\"+field.\n+\n+ XEF can also be used to obtain%DATASET INFORMATION+or display a%DATASET\n+%MEMBER LIST+of a partitioned dataset. From the member list you can select\n+ members to be BROWSEd, VIEWed, EDITed, DELETEd, RENAMEd, or PRINTed.\n+ Using the%DSLIST+option, a dataset pattern can be entered to display\n+ a Data Set List that is like ISPF option 3.4.  If the CBT%PDS+command\n+ is installed, XEF can also interface with it.\n+ ------------------------------------------------------------------------------\n+ To start you must add datasets to the menu. To do this, simply tab to one of\n+ the dataset name fields (1 thru 99) and type in the dataset name that you wish\n+ to have in that field (do not use quotes). The dataset must be cataloged, but\n+ the system will not check to see that it is until you try and access it.\n+ You can scroll through the dataset list using the UP and DOWN scroll commands.\n+\n+                               (continued)\n+\n)PROC\n &ZCONT = 'XEFHELP2'\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XEFHELP2": {"ttr": 32778, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06+\\x00\\x00\\x01\\x00\\x11\\x1f\\x01\\x11\\x17\\x8f\\x14\\x15\\x00\\x1f\\x00\\x1f\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf3@@@@'", "ispf": {"version": "06.43", "flags": 0, "createdate": "2000-04-20T00:00:00", "modifydate": "2011-06-27T14:15:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "CBT483"}, "text": ")ATTR\n           + TYPE(TEXT)   INTENS(LOW)  COLOR(BLUE)\n           % TYPE(TEXT)   INTENS(HIGH) COLOR(PINK)\n           _ TYPE(INPUT)  INTENS(HIGH) COLOR(RED)\n)BODY EXPAND(//)\n%XEF - eXtended Editor Facility (&ZAPPLID) - HELP  (continued)  -/-/ V6.4 ---\n%COMMAND ===>_ZCMD\n+\n+ To%BROWSE+dataset%1,+type in%B+in the command area and%1+in the number area.\n+ If you want a browse member list, leave the member field name blank. You can\n+ also specify a specific member or a member name pattern in the member field.\n+\n+ To%VIEW+dataset%1,+type in%V+in the command area and%1+in the number area.\n+ If you want a view member list, leave the member field name blank. You can\n+ also specify a specific member or a member name pattern in the member field.\n+\n+ To%EDIT+dataset%1,+type in%E+in the command area and%1+in the number area.\n+ If you want an edit member list, leave the member field name blank. You can\n+ also specify a specific member or a member name pattern in the member field.\n+\n+ To use the%PDS+interface with dataset%1,+type in%P+in the command area and\n+%1+in the number area.\n+\n+ To%FIND+dataset names in your list that match a search string,+type in%F+in\n+ the command area and hit enter. You will be prompted for the search string.\n+\n+                               (continued)\n+\n)PROC\n &ZCONT = 'XEFHELP3'\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XEFHELP3": {"ttr": 32780, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06+\\x00\\x00\\x01\\x00\\x11\\x1f\\x01\\x11\\x17\\x8f\\x14\\x15\\x00\\x1f\\x00\\x1f\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf3@@@@'", "ispf": {"version": "06.43", "flags": 0, "createdate": "2000-04-20T00:00:00", "modifydate": "2011-06-27T14:15:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "CBT483"}, "text": ")ATTR\n           + TYPE(TEXT)   INTENS(LOW)  COLOR(BLUE)\n           % TYPE(TEXT)   INTENS(HIGH) COLOR(PINK)\n           _ TYPE(INPUT)  INTENS(HIGH) COLOR(RED)\n)BODY EXPAND(//)\n%XEF - eXtended Editor Facility (&ZAPPLID) - HELP  (continued)  -/-/ V6.4 ---\n%COMMAND ===>_ZCMD\n+\n+ To display a%DATASET MEMBER LIST,+type in%M+in the command area and the number\n+ of the dataset you wish to have the member list for in the number area.\n+ Member list commands are%B+(Browse), %V+(View), %E+(Edit), %R+(Rename),\n+%D+(Delete), and %P+(Print). You can also specify a specific member or a\n+ member name pattern in the member field.\n+\n+ To use the%DSLIST+option, type a %D+in the command area and the number of\n+ the dataset or dataset pattern that you wish to use in the number area.\n+\n+ To%COMPRESS+a dataset,+type in%Z+in the command area and the number of the\n+ dataset you wish to have compressed in the number area.\n+\n+ To obtain%DATASET INFORMATION,+type in%I+in the command area and the number\n+ of the dataset you wish to have information for in the number area.\n+\n+ Instead of using the dataset number area you may also select the dataset\n+ you wish to work with by placing the cursor on it. Cursor selection of a\n+ dataset will override the number area selection.\n+                               (continued)\n+\n)PROC\n &ZCONT = 'XEFHELP4'\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XEFHELP4": {"ttr": 32782, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06+\\x00\\x00\\x01\\x00\\x11\\x1f\\x01\\x11\\x17\\x8f\\x14\\x15\\x00\\x1e\\x00\\x1d\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf3@@@@'", "ispf": {"version": "06.43", "flags": 0, "createdate": "2000-04-20T00:00:00", "modifydate": "2011-06-27T14:15:00", "lines": 30, "newlines": 29, "modlines": 0, "user": "CBT483"}, "text": ")ATTR\n           + TYPE(TEXT)   INTENS(LOW)  COLOR(BLUE)\n           % TYPE(TEXT)   INTENS(HIGH) COLOR(PINK)\n           _ TYPE(INPUT)  INTENS(HIGH) COLOR(RED)\n)BODY EXPAND(//)\n%XEF - eXtended Editor Facility (&ZAPPLID) - HELP  (continued)  -/-/ V6.4 ---\n%COMMAND ===>_ZCMD\n+\n+                         %XEF SUMMARY OF CHANGES\n+\n+ %V6.4+- Added a find option.\n+ %V6.3+- Added the DSLIST option. OS390 2.10 (ISPF V5) or above now required.\n+ %V6.2+- Added dataset information support for SMS controlled datasets.\n+ %V6.1+- Added support for the PDS command.\n+ %V6.0+- Increased the number of datasets from 34 to 99 and made the dataset\n+         list scrollable. Added support for VIEW under ISPF V4 to the main\n+         menu and to the member list options. Added \"Used extents\" field to\n+         the DATASET INFORMATION display. Added cursor selection of datasets.\n+ %V5.2+- Enhanced member pattern support for ISPF V3.\n+ %V5.1+- Member pattern support for the member list option.\n+ %V5.0+- Added a dataset information option and removed the list option.\n+ %V4.0+- Increased the number of datasets from 24 to 34 and added support\n+         for edit recovery.\n+ %V3.0+- Added a compress option and removed the ADD & REMOVE options.\n+         Datasets are now added by typing them in directly on the main menu.\n+ %V2.0+- Added a member list option.\n+ %V1.0+- Initial release. Available options: ADD dataset, REMOVE dataset,\n+         BROWSE dataset, EDIT dataset, LIST dataset attributes.\n+\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XEFINF": {"ttr": 32784, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06+\\x00\\x00\\x01\\x00\\x11\\x1f\\x01\\x11\\x17\\x8f\\x14\\x15\\x00%\\x00%\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf3@@@@'", "ispf": {"version": "06.43", "flags": 0, "createdate": "2000-04-20T00:00:00", "modifydate": "2011-06-27T14:15:00", "lines": 37, "newlines": 37, "modlines": 0, "user": "CBT483"}, "text": ")ATTR\n           + TYPE(TEXT)   INTENS(LOW)  COLOR(BLUE)\n           % TYPE(TEXT)   INTENS(HIGH) COLOR(PINK)\n           # TYPE(TEXT)   INTENS(HIGH) COLOR(TURQ)\n           $ TYPE(TEXT)   INTENS(LOW)  COLOR(TURQ)\n           @ TYPE(OUTPUT) INTENS(LOW)  COLOR(TURQ)   JUST(RIGHT)\n           _ TYPE(INPUT)  INTENS(HIGH) COLOR(RED)\n)BODY EXPAND(//)\n%XEF - eXtended Editor Facility (&ZAPPLID) - DATA SET INFORMATION  -/-/ V6.4 ---\n%COMMAND ===>_ZCMD\n+\n+DATA SET NAME:#&DSNAME\n%\n+GENERAL INFORMATION:                      +CURRENT ALLOCATION:\n   +Volume serial:         $&VOLUME           +Allocated &UNITS:    @ALLOC   +\n   +Device type:           $&UNIT             +Allocated extents:    @EXTENTS+\n   +Organization:          $&DSORG\n   +Record format:         $&RECFM\n   +Record length:         $&LRECL\n   +Block size:            $&BLKSIZE       +CURRENT UTILIZATION:\n   +1st extent &UNITS:     $&PRIMARY          +Used &UNITS:          @USED   +\n   +Secondary &UNITS:      $&SECONDS          +Used extents:         @USEDEXT+\n\n   +Creation date:         $&CREATE           +Last reference date: @REFDATE +\n   +Expiration date:       $&EXDATE           +Update indicator      @UPDATED+\n                     %&EXPERM\n)INIT\n.HELP = XEFHELP\n  &UNITS = TRANS (&UNITS CYLINDER,cylinders TRACK,tracks BLOCK,blocks)\n  IF (&EXDATE = '0')\n    &EXDATE = '**NONE**'\n  IF (&EXDATE = '1999/365')\n    &EXPERM = '(Permanent Retention)'\n  IF (&EXDATE = '1999/366')\n    &EXPERM = '(Permanent Retention)'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XEFINFD": {"ttr": 33025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06+\\x00\\x00\\x01\\x00\\x11\\x1f\\x01\\x11\\x17\\x8f\\x14\\x15\\x00&\\x00&\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf3@@@@'", "ispf": {"version": "06.43", "flags": 0, "createdate": "2000-04-20T00:00:00", "modifydate": "2011-06-27T14:15:00", "lines": 38, "newlines": 38, "modlines": 0, "user": "CBT483"}, "text": ")ATTR\n           + TYPE(TEXT)   INTENS(LOW)  COLOR(BLUE)\n           % TYPE(TEXT)   INTENS(HIGH) COLOR(PINK)\n           # TYPE(TEXT)   INTENS(HIGH) COLOR(TURQ)\n           $ TYPE(TEXT)   INTENS(LOW)  COLOR(TURQ)\n           @ TYPE(OUTPUT) INTENS(LOW)  COLOR(TURQ)   JUST(RIGHT)\n           _ TYPE(INPUT)  INTENS(HIGH) COLOR(RED)\n)BODY EXPAND(//)\n%XEF - eXtended Editor Facility (&ZAPPLID) - DATA SET INFORMATION  -/-/ V6.4 ---\n%COMMAND ===>_ZCMD\n+\n+DATA SET NAME:#&DSNAME\n%\n+GENERAL INFORMATION:                      +CURRENT ALLOCATION:\n   +Volume serial:         $&VOLUME           +Allocated &UNITS:    @ALLOC   +\n   +Device type:           $&UNIT             +Allocated extents:    @EXTENTS+\n   +Organization:          $&DSORG            +Maximum dir. blocks:  @ADIRBLK+\n   +Record format:         $&RECFM\n   +Record length:         $&LRECL         +CURRENT UTILIZATION:\n   +Block size:            $&BLKSIZE          +Used &UNITS:          @USED   +\n   +1st extent &UNITS:     $&PRIMARY          +Used extents:         @USEDEXT+\n   +Secondary &UNITS:      $&SECONDS          +Used dir. blocks:     @UDIRBLK+\n                                              +Number of members:    @MEMBERS+\n\n   +Creation date:         $&CREATE           +Last reference date: @REFDATE +\n   +Expiration date:       $&EXDATE           +Update indicator      @UPDATED+\n                     %&EXPERM\n)INIT\n.HELP = XEFHELP\n  &UNITS = TRANS (&UNITS CYLINDER,cylinders TRACK,tracks BLOCK,blocks)\n  IF (&EXDATE = '0')\n    &EXDATE = '**NONE**'\n  IF (&EXDATE = '1999/365')\n    &EXPERM = '(Permanent Retention)'\n  IF (&EXDATE = '1999/366')\n    &EXPERM = '(Permanent Retention)'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XEFINFE": {"ttr": 33027, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06+\\x00\\x00\\x01\\x00\\x11\\x1f\\x01\\x11\\x17\\x8f\\x14\\x15\\x00)\\x00)\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf3@@@@'", "ispf": {"version": "06.43", "flags": 0, "createdate": "2000-04-20T00:00:00", "modifydate": "2011-06-27T14:15:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "CBT483"}, "text": ")ATTR\n           + TYPE(TEXT)   INTENS(LOW)  COLOR(BLUE)\n           % TYPE(TEXT)   INTENS(HIGH) COLOR(PINK)\n           # TYPE(TEXT)   INTENS(HIGH) COLOR(TURQ)\n           $ TYPE(TEXT)   INTENS(LOW)  COLOR(TURQ)\n           @ TYPE(OUTPUT) INTENS(LOW)  COLOR(TURQ)   JUST(RIGHT)\n           _ TYPE(INPUT)  INTENS(HIGH) COLOR(RED)\n)BODY EXPAND(//)\n%XEF - eXtended Editor Facility (&ZAPPLID) - DATA SET INFORMATION  -/-/ V6.4 ---\n%COMMAND ===>_ZCMD\n+\n+DATA SET NAME:#&DSNAME\n%\n+GENERAL INFORMATION:                      +CURRENT ALLOCATION:\n  +Management class:       $&MGMTCLAS         +Allocated &UNITS:    @ALLOC   +\n  +Storage class:          $&STORCLAS         +Allocated extents:    @EXTENTS+\n   +Volume serial:         $&VOLUME           +Maximum dir. blocks:  @ADIRBLK+\n   +Device type:           $&UNIT\n  +Data class:             $&DATACLAS\n   +Organization:          $&DSORG         +CURRENT UTILIZATION:\n   +Record format:         $&RECFM            +Used pages:          @USEDPAGE+\n   +Record length:         $&LRECL            +Number of members:    @MEMBERS+\n   +Block size:            $&BLKSIZE\n   +1st extent &UNITS:     $&PRIMARY\n   +Secondary &UNITS:      $&SECONDS\n   +Data set name type:    $LIBRARY\n\n   +Creation date:         $&CREATE           +Last reference date: @REFDATE +\n   +Expiration date:       $&EXDATE           +Update indicator      @UPDATED+\n                     %&EXPERM\n)INIT\n.HELP = XEFHELP\n  &UNITS = TRANS (&UNITS CYLINDER,cylinders TRACK,tracks BLOCK,blocks)\n  IF (&EXDATE = '0')\n    &EXDATE = '**NONE**'\n  IF (&EXDATE = '1999/365')\n    &EXPERM = '(Permanent Retention)'\n  IF (&EXDATE = '1999/366')\n    &EXPERM = '(Permanent Retention)'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XEFINFP": {"ttr": 33029, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06+\\x00\\x00\\x01\\x00\\x11\\x1f\\x01\\x11\\x17\\x8f\\x14\\x15\\x00)\\x00)\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf3@@@@'", "ispf": {"version": "06.43", "flags": 0, "createdate": "2000-04-20T00:00:00", "modifydate": "2011-06-27T14:15:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "CBT483"}, "text": ")ATTR\n           + TYPE(TEXT)   INTENS(LOW)  COLOR(BLUE)\n           % TYPE(TEXT)   INTENS(HIGH) COLOR(PINK)\n           # TYPE(TEXT)   INTENS(HIGH) COLOR(TURQ)\n           $ TYPE(TEXT)   INTENS(LOW)  COLOR(TURQ)\n           @ TYPE(OUTPUT) INTENS(LOW)  COLOR(TURQ)   JUST(RIGHT)\n           _ TYPE(INPUT)  INTENS(HIGH) COLOR(RED)\n)BODY EXPAND(//)\n%XEF - eXtended Editor Facility (&ZAPPLID) - DATA SET INFORMATION  -/-/ V6.4 ---\n%COMMAND ===>_ZCMD\n+\n+DATA SET NAME:#&DSNAME\n%\n+GENERAL INFORMATION:                      +CURRENT ALLOCATION:\n  +Management class:       $&MGMTCLAS         +Allocated &UNITS:    @ALLOC   +\n  +Storage class:          $&STORCLAS         +Allocated extents:    @EXTENTS+\n   +Volume serial:         $&VOLUME           +Maximum dir. blocks:  @ADIRBLK+\n   +Device type:           $&UNIT\n  +Data class:             $&DATACLAS\n   +Organization:          $&DSORG         +CURRENT UTILIZATION:\n   +Record format:         $&RECFM            +Used &UNITS:          @USED   +\n   +Record length:         $&LRECL            +Used extents:         @USEDEXT+\n   +Block size:            $&BLKSIZE          +Used dir. blocks:     @UDIRBLK+\n   +1st extent &UNITS:     $&PRIMARY          +Number of members:    @MEMBERS+\n   +Secondary &UNITS:      $&SECONDS\n   +Data set name type:    $PDS\n\n   +Creation date:         $&CREATE           +Last reference date: @REFDATE +\n   +Expiration date:       $&EXDATE           +Update indicator      @UPDATED+\n                     %&EXPERM\n)INIT\n.HELP = XEFHELP\n  &UNITS = TRANS (&UNITS CYLINDER,cylinders TRACK,tracks BLOCK,blocks)\n  IF (&EXDATE = '0')\n    &EXDATE = '**NONE**'\n  IF (&EXDATE = '1999/365')\n    &EXPERM = '(Permanent Retention)'\n  IF (&EXDATE = '1999/366')\n    &EXPERM = '(Permanent Retention)'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XEFINFS": {"ttr": 33031, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06+\\x00\\x00\\x01\\x00\\x11\\x1f\\x01\\x11\\x17\\x8f\\x14\\x15\\x00)\\x00)\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf3@@@@'", "ispf": {"version": "06.43", "flags": 0, "createdate": "2000-04-20T00:00:00", "modifydate": "2011-06-27T14:15:00", "lines": 41, "newlines": 41, "modlines": 0, "user": "CBT483"}, "text": ")ATTR\n           + TYPE(TEXT)   INTENS(LOW)  COLOR(BLUE)\n           % TYPE(TEXT)   INTENS(HIGH) COLOR(PINK)\n           # TYPE(TEXT)   INTENS(HIGH) COLOR(TURQ)\n           $ TYPE(TEXT)   INTENS(LOW)  COLOR(TURQ)\n           @ TYPE(OUTPUT) INTENS(LOW)  COLOR(TURQ)   JUST(RIGHT)\n           _ TYPE(INPUT)  INTENS(HIGH) COLOR(RED)\n)BODY EXPAND(//)\n%XEF - eXtended Editor Facility (&ZAPPLID) - DATA SET INFORMATION  -/-/ V6.4 ---\n%COMMAND ===>_ZCMD\n+\n+DATA SET NAME:#&DSNAME\n%\n+GENERAL INFORMATION:                      +CURRENT ALLOCATION:\n  +Management class:       $&MGMTCLAS         +Allocated &UNITS:    @ALLOC   +\n  +Storage class:          $&STORCLAS         +Allocated extents:    @EXTENTS+\n   +Volume serial:         $&VOLUME\n   +Device type:           $&UNIT\n  +Data class:             $&DATACLAS\n   +Organization:          $&DSORG         +CURRENT UTILIZATION:\n   +Record format:         $&RECFM            +Used &UNITS:          @USED   +\n   +Record length:         $&LRECL            +Used extents:         @USEDEXT+\n   +Block size:            $&BLKSIZE\n   +1st extent &UNITS:     $&PRIMARY\n   +Secondary &UNITS:      $&SECONDS\n   +Data set name type:    $SEQ\n\n   +Creation date:         $&CREATE           +Last reference date: @REFDATE +\n   +Expiration date:       $&EXDATE           +Update indicator      @UPDATED+\n                     %&EXPERM\n)INIT\n.HELP = XEFHELP\n  &UNITS = TRANS (&UNITS CYLINDER,cylinders TRACK,tracks BLOCK,blocks)\n  IF (&EXDATE = '0')\n    &EXDATE = '**NONE**'\n  IF (&EXDATE = '1999/365')\n    &EXPERM = '(Permanent Retention)'\n  IF (&EXDATE = '1999/366')\n    &EXPERM = '(Permanent Retention)'\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XEFLIBD": {"ttr": 33033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06+\\x00\\x00\\x01\\x05\\x04\\x1f\\x01\\x11\\x17\\x8f\\x14\\x15\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf3@@@@'", "ispf": {"version": "06.43", "flags": 0, "createdate": "2005-02-10T00:00:00", "modifydate": "2011-06-27T14:15:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "CBT483"}, "text": "/* REXX */\nuid    = sysvar('SYSUID')\ndsn = \"'\" || uid || \".CBT.FILE434'\"\naddress TSO \"ALTLIB ACTIVATE APPLICATION(CLIST) DA(\"dsn\")\"\naddress ISPEXEC \"LIBDEF ISPPLIB DATASET ID(\"dsn\") STACK\"\naddress ISPEXEC \"LIBDEF ISPMLIB DATASET ID(\"dsn\") STACK\"\naddress ISPEXEC \"SELECT PANEL(XEFMENU) NEWAPPL(ISR) PASSLIB\"\naddress ISPEXEC \"LIBDEF ISPMLIB\"\naddress ISPEXEC \"LIBDEF ISPPLIB\"\naddress TSO \"ALTLIB DEACTIVATE APPLICATION(CLIST) \"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XEFMENU": {"ttr": 33035, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06+\\x00\\x00\\x01\\x00\\x11\\x1f\\x01\\x13\\x01\\x7f\\x08X\\x01(\\x01\\r\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf6@@@@'", "ispf": {"version": "06.43", "flags": 0, "createdate": "2000-04-20T00:00:00", "modifydate": "2013-01-17T08:58:00", "lines": 296, "newlines": 269, "modlines": 0, "user": "CBT486"}, "text": ")ATTR\n    # TYPE(DATAOUT) INTENS(HIGH) COLOR(TURQ)\n    \u00ac AREA(DYNAMIC)\n    | AREA(SCRL)    EXTEND(ON)\n    % TYPE(TEXT)    INTENS(HIGH) COLOR(PINK) SKIP(ON)\n    _ TYPE(INPUT)   INTENS(HIGH) COLOR(RED)\n    @ TYPE(INPUT)   INTENS(LOW)  COLOR(BLUE)\n)BODY CMD(XODSN) EXPAND(//)\n%XEF - eXtended Editor Facility (&ZAPPLID) - USER:&ZUSER SYS:&ZSYSID /-/ V6.4 -\n%OPTION  ===>_XOPT / / %NUMBER ==>_XN% MEMBER ==>_XMEM    %\n\u00acMENU                                                                          \u00ac\n\u00acMEN2   \u00ac%OTHER DSN OR COMMAND%==>_XODSN                                       %\n%-/-/\n|XEFSCRL                                                                       |\n)AREA XEFSCRL\n% 1@XDSN1                               %51@XDSN51\n% 2@XDSN2                               %52@XDSN52\n% 3@XDSN3                               %53@XDSN53\n% 4@XDSN4                               %54@XDSN54\n% 5@XDSN5                               %55@XDSN55\n% 6@XDSN6                               %56@XDSN56\n% 7@XDSN7                               %57@XDSN57\n% 8@XDSN8                               %58@XDSN58\n% 9@XDSN9                               %59@XDSN59\n%10@XDSN10                              %60@XDSN60\n%11@XDSN11                              %61@XDSN61\n%12@XDSN12                              %62@XDSN62\n%13@XDSN13                              %63@XDSN63\n%14@XDSN14                              %64@XDSN64\n%15@XDSN15                              %65@XDSN65\n%16@XDSN16                              %66@XDSN66\n%17@XDSN17                              %67@XDSN67\n%18@XDSN18                              %68@XDSN68\n%19@XDSN19                              %69@XDSN69\n%20@XDSN20                              %70@XDSN70\n%21@XDSN21                              %71@XDSN71\n%22@XDSN22                              %72@XDSN72\n%23@XDSN23                              %73@XDSN73\n%24@XDSN24                              %74@XDSN74\n%25@XDSN25                              %75@XDSN75\n%26@XDSN26                              %76@XDSN76\n%27@XDSN27                              %77@XDSN77\n%28@XDSN28                              %78@XDSN78\n%29@XDSN29                              %79@XDSN79\n%30@XDSN30                              %80@XDSN80\n%31@XDSN31                              %81@XDSN81\n%32@XDSN32                              %82@XDSN82\n%33@XDSN33                              %83@XDSN83\n%34@XDSN34                              %84@XDSN84\n%35@XDSN35                              %85@XDSN85\n%36@XDSN36                              %86@XDSN86\n%37@XDSN37                              %87@XDSN87\n%38@XDSN38                              %88@XDSN88\n%39@XDSN39                              %89@XDSN89\n%40@XDSN40                              %90@XDSN90\n%41@XDSN41                              %91@XDSN91\n%42@XDSN42                              %92@XDSN92\n%43@XDSN43                              %93@XDSN93\n%44@XDSN44                              %94@XDSN94\n%45@XDSN45                              %95@XDSN95\n%46@XDSN46                              %96@XDSN96\n%47@XDSN47                              %97@XDSN97\n%48@XDSN48                              %98@XDSN98\n%49@XDSN49                              %99@XDSN99\n%50@XDSN50                                      %\n)INIT\n &PDS = Y   /* Y or N for PDS command support   */\n .HELP = XEFHELP\n .CURSOR = XOPT\n &MENU= ' #B-Browse# V-View# E-Edit# M-MemList# +\n           D-Dslist# Z-Compress# I-Info# F-Find#'\n &MEN2= ' #X-Exit#'\n IF (&PDS = Y)\n   &MENU= '#B-Browse# V-View# E-Edit# M-Memlist# +\n           D-Dslist# Z-Compress# I-Info# P-PDS#F-Find#'\n   &MEN2= '#X-Exit#'\n VGET (XOPT XN XMEM XODSN) PROFILE\n VGET (XDSN1 XDSN2 XDSN3 XDSN4 XDSN5) PROFILE\n VGET (XDSN6 XDSN7 XDSN8 XDSN9 XDSN10) PROFILE\n VGET (XDSN11 XDSN12 XDSN13 XDSN14 XDSN15) PROFILE\n VGET (XDSN16 XDSN17 XDSN18 XDSN19 XDSN20) PROFILE\n VGET (XDSN21 XDSN22 XDSN23 XDSN24 XDSN25) PROFILE\n VGET (XDSN26 XDSN27 XDSN28 XDSN29 XDSN30) PROFILE\n VGET (XDSN31 XDSN32 XDSN33 XDSN34 XDSN35) PROFILE\n VGET (XDSN36 XDSN37 XDSN38 XDSN39 XDSN40) PROFILE\n VGET (XDSN41 XDSN42 XDSN43 XDSN44 XDSN45) PROFILE\n VGET (XDSN46 XDSN47 XDSN48 XDSN49 XDSN50) PROFILE\n VGET (XDSN51 XDSN52 XDSN53 XDSN54 XDSN55) PROFILE\n VGET (XDSN56 XDSN57 XDSN58 XDSN59 XDSN60) PROFILE\n VGET (XDSN61 XDSN62 XDSN63 XDSN64 XDSN65) PROFILE\n VGET (XDSN66 XDSN67 XDSN68 XDSN69 XDSN70) PROFILE\n VGET (XDSN71 XDSN72 XDSN73 XDSN74 XDSN75) PROFILE\n VGET (XDSN76 XDSN77 XDSN78 XDSN79 XDSN80) PROFILE\n VGET (XDSN81 XDSN82 XDSN83 XDSN84 XDSN85) PROFILE\n VGET (XDSN86 XDSN87 XDSN88 XDSN89 XDSN90) PROFILE\n VGET (XDSN91 XDSN92 XDSN93 XDSN94 XDSN95) PROFILE\n VGET (XDSN96 XDSN97 XDSN98 XDSN99) PROFILE\n IF (&PDS = N)\n   IF (&XOPT NE B,V,E,M,D,Z,I,F,FIND)\n       &XOPT = &Z\n IF (&PDS = Y)\n   IF (&XOPT NE B,V,E,M,D,Z,I,P,F,FIND)\n       &XOPT = &Z\n)PROC\n IF (&XN NE &Z)\n   &XN = TRANS(&XN 01,1 02,2 03,3 04,4 05,5 06,6 07,7 08,8 09,9 *,*)\n IF (.CURSOR GE XDSN1 AND .CURSOR LE XDSN99)\n    &XN = TRUNC(.CURSOR,4)\n    &XN = .TRAIL\n\n /* *REXX(XOPT,(XEFPANX))   */\n\n IF (&XOPT EQ BROWSE)\n    &XOPT = 'B'\n IF (&XOPT EQ VIEW)\n    &XOPT = 'V'\n IF (&XOPT EQ EDIT)\n    &XOPT = 'E'\n IF (&XOPT EQ MEMLIST)\n    &XOPT = 'M'\n IF (&XOPT EQ DSLIST)\n    &XOPT = 'D'\n IF (&XOPT EQ COMPRESS)\n    &XOPT = 'Z'\n IF (&XOPT EQ INFO)\n    &XOPT = 'I'\n IF (&XOPT EQ PDS)\n    &XOPT = 'P'\n IF (&XOPT EQ FIND)\n    &XOPT = 'F'\n IF (&XOPT EQ EXIT)\n    &XOPT = 'X'\n\n &ZSEL = TRANS( TRUNC(&XOPT,)\n                 B,'CMD(%XEFCLIST &XOPT &XN XMEM(''&XMEM''))'\n                 V,'CMD(%XEFCLIST &XOPT &XN XMEM(''&XMEM''))'\n                 E,'CMD(%XEFCLIST &XOPT &XN XMEM(''&XMEM''))'\n                 M,'CMD(%XEFCLIST &XOPT &XN XMEM(''&XMEM''))'\n                 D,'CMD(%XEFCLIST &XOPT &XN)'\n                 Z,'CMD(%XEFCLIST &XOPT &XN)'\n                 I,'CMD(%XEFCLIST &XOPT &XN)'\n                 P,'CMD(%XEFCLIST &XOPT &XN XMEM(''&XMEM''))'\n                 F,'CMD(%XEFCLIST &XOPT &XN)'\n              FIND,'CMD(%XEFCLIST &XOPT &XN)'\n                 X,'EXIT')\n IF (&XOPT NE X)\n    VER(&XDSN1,DSNAMEF)\n    VER(&XDSN2,DSNAMEF)\n    VER(&XDSN3,DSNAMEF)\n    VER(&XDSN4,DSNAMEF)\n    VER(&XDSN5,DSNAMEF)\n    VER(&XDSN6,DSNAMEF)\n    VER(&XDSN7,DSNAMEF)\n    VER(&XDSN8,DSNAMEF)\n    VER(&XDSN9,DSNAMEF)\n    VER(&XDSN10,DSNAMEF)\n    VER(&XDSN11,DSNAMEF)\n    VER(&XDSN12,DSNAMEF)\n    VER(&XDSN13,DSNAMEF)\n    VER(&XDSN14,DSNAMEF)\n    VER(&XDSN15,DSNAMEF)\n    VER(&XDSN16,DSNAMEF)\n    VER(&XDSN17,DSNAMEF)\n    VER(&XDSN18,DSNAMEF)\n    VER(&XDSN19,DSNAMEF)\n    VER(&XDSN20,DSNAMEF)\n    VER(&XDSN21,DSNAMEF)\n    VER(&XDSN22,DSNAMEF)\n    VER(&XDSN23,DSNAMEF)\n    VER(&XDSN24,DSNAMEF)\n    VER(&XDSN25,DSNAMEF)\n    VER(&XDSN26,DSNAMEF)\n    VER(&XDSN27,DSNAMEF)\n    VER(&XDSN28,DSNAMEF)\n    VER(&XDSN29,DSNAMEF)\n    VER(&XDSN30,DSNAMEF)\n    VER(&XDSN31,DSNAMEF)\n    VER(&XDSN32,DSNAMEF)\n    VER(&XDSN33,DSNAMEF)\n    VER(&XDSN34,DSNAMEF)\n    VER(&XDSN35,DSNAMEF)\n    VER(&XDSN36,DSNAMEF)\n    VER(&XDSN37,DSNAMEF)\n    VER(&XDSN38,DSNAMEF)\n    VER(&XDSN39,DSNAMEF)\n    VER(&XDSN40,DSNAMEF)\n    VER(&XDSN41,DSNAMEF)\n    VER(&XDSN42,DSNAMEF)\n    VER(&XDSN43,DSNAMEF)\n    VER(&XDSN44,DSNAMEF)\n    VER(&XDSN45,DSNAMEF)\n    VER(&XDSN46,DSNAMEF)\n    VER(&XDSN47,DSNAMEF)\n    VER(&XDSN48,DSNAMEF)\n    VER(&XDSN49,DSNAMEF)\n    VER(&XDSN50,DSNAMEF)\n    VER(&XDSN51,DSNAMEF)\n    VER(&XDSN52,DSNAMEF)\n    VER(&XDSN53,DSNAMEF)\n    VER(&XDSN54,DSNAMEF)\n    VER(&XDSN55,DSNAMEF)\n    VER(&XDSN56,DSNAMEF)\n    VER(&XDSN57,DSNAMEF)\n    VER(&XDSN58,DSNAMEF)\n    VER(&XDSN59,DSNAMEF)\n    VER(&XDSN60,DSNAMEF)\n    VER(&XDSN61,DSNAMEF)\n    VER(&XDSN62,DSNAMEF)\n    VER(&XDSN63,DSNAMEF)\n    VER(&XDSN64,DSNAMEF)\n    VER(&XDSN65,DSNAMEF)\n    VER(&XDSN66,DSNAMEF)\n    VER(&XDSN67,DSNAMEF)\n    VER(&XDSN68,DSNAMEF)\n    VER(&XDSN69,DSNAMEF)\n    VER(&XDSN70,DSNAMEF)\n    VER(&XDSN71,DSNAMEF)\n    VER(&XDSN72,DSNAMEF)\n    VER(&XDSN73,DSNAMEF)\n    VER(&XDSN74,DSNAMEF)\n    VER(&XDSN75,DSNAMEF)\n    VER(&XDSN76,DSNAMEF)\n    VER(&XDSN77,DSNAMEF)\n    VER(&XDSN78,DSNAMEF)\n    VER(&XDSN79,DSNAMEF)\n    VER(&XDSN80,DSNAMEF)\n    VER(&XDSN81,DSNAMEF)\n    VER(&XDSN82,DSNAMEF)\n    VER(&XDSN83,DSNAMEF)\n    VER(&XDSN84,DSNAMEF)\n    VER(&XDSN85,DSNAMEF)\n    VER(&XDSN86,DSNAMEF)\n    VER(&XDSN87,DSNAMEF)\n    VER(&XDSN88,DSNAMEF)\n    VER(&XDSN89,DSNAMEF)\n    VER(&XDSN90,DSNAMEF)\n    VER(&XDSN91,DSNAMEF)\n    VER(&XDSN92,DSNAMEF)\n    VER(&XDSN93,DSNAMEF)\n    VER(&XDSN94,DSNAMEF)\n    VER(&XDSN95,DSNAMEF)\n    VER(&XDSN96,DSNAMEF)\n    VER(&XDSN97,DSNAMEF)\n    VER(&XDSN98,DSNAMEF)\n    VER(&XDSN99,DSNAMEF)\n    IF (&XMEM NE &Z)\n      VER(&XMEM,NAMEF)\n    IF (&PDS = N)\n      VER(&XOPT,NONBLANK,MSG=XEF001A)\n      VER(&XOPT,LIST,B,V,E,M,D,Z,I,F,FIND,MSG=XEF001B)\n    IF (&PDS = Y)\n      VER(&XOPT,NONBLANK,MSG=XEF001C)\n      VER(&XOPT,LIST,B,V,E,M,D,Z,I,P,F,FIND,MSG=XEF001D)\n    IF (&XODSN EQ &Z)\n       VER(&XN,NONBLANK,MSG=XEF002A)\n       VER(&XN,NUM,MSG=XEF002B)\n       VER(&XN,RANGE,1,99,MSG=XEF002B)\n    IF (&XODSN NE &Z)\n       IF (.CURSOR GE XDSN1 AND .CURSOR LE XDSN99)\n          .CURSOR = .CURSOR\n          .MSG=XEF002D\n       VER(&XN,LIST,' ',MSG=XEF002C)\n       VER(&XODSN,DSNAMEF)\n       &ZSEL = TRANS( TRUNC(&XOPT,)\n                 B,'CMD(%XEFCLIST &XOPT DUMMYDN XMEM(''&XMEM''))'\n                 V,'CMD(%XEFCLIST &XOPT DUMMYDN XMEM(''&XMEM''))'\n                 E,'CMD(%XEFCLIST &XOPT DUMMYDN XMEM(''&XMEM''))'\n                 M,'CMD(%XEFCLIST &XOPT DUMMYDN XMEM(''&XMEM''))'\n                 D,'CMD(%XEFCLIST &XOPT DUMMYDN)'\n                 Z,'CMD(%XEFCLIST &XOPT DUMMYDN)'\n                 I,'CMD(%XEFCLIST &XOPT DUMMYDN)'\n                 F,'CMD(%XEFCLIST &XOPT DUMMYDN)'\n              FIND,'CMD(%XEFCLIST &XOPT DUMMYDN)'\n                 P,'CMD(%XEFCLIST &XOPT DUMMYDN)')\n    VPUT (XOPT XN XMEM XODSN) PROFILE\n    VPUT (XDSN1 XDSN2 XDSN3 XDSN4 XDSN5) PROFILE\n    VPUT (XDSN6 XDSN7 XDSN8 XDSN9 XDSN10) PROFILE\n    VPUT (XDSN11 XDSN12 XDSN13 XDSN14 XDSN15) PROFILE\n    VPUT (XDSN16 XDSN17 XDSN18 XDSN19 XDSN20) PROFILE\n    VPUT (XDSN21 XDSN22 XDSN23 XDSN24 XDSN25) PROFILE\n    VPUT (XDSN26 XDSN27 XDSN28 XDSN29 XDSN30) PROFILE\n    VPUT (XDSN31 XDSN32 XDSN33 XDSN34 XDSN35) PROFILE\n    VPUT (XDSN36 XDSN37 XDSN38 XDSN39 XDSN40) PROFILE\n    VPUT (XDSN41 XDSN42 XDSN43 XDSN44 XDSN45) PROFILE\n    VPUT (XDSN46 XDSN47 XDSN48 XDSN49 XDSN50) PROFILE\n    VPUT (XDSN51 XDSN52 XDSN53 XDSN54 XDSN55) PROFILE\n    VPUT (XDSN56 XDSN57 XDSN58 XDSN59 XDSN60) PROFILE\n    VPUT (XDSN61 XDSN62 XDSN63 XDSN64 XDSN65) PROFILE\n    VPUT (XDSN66 XDSN67 XDSN68 XDSN69 XDSN70) PROFILE\n    VPUT (XDSN71 XDSN72 XDSN73 XDSN74 XDSN75) PROFILE\n    VPUT (XDSN76 XDSN77 XDSN78 XDSN79 XDSN80) PROFILE\n    VPUT (XDSN81 XDSN82 XDSN83 XDSN84 XDSN85) PROFILE\n    VPUT (XDSN86 XDSN87 XDSN88 XDSN89 XDSN90) PROFILE\n    VPUT (XDSN91 XDSN92 XDSN93 XDSN94 XDSN95) PROFILE\n    VPUT (XDSN96 XDSN97 XDSN98 XDSN99) PROFILE\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XEFMENUB": {"ttr": 33041, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06+\\x00\\x00\\x01\\x05\\x04?\\x01\\x13\\x01\\x7f\\x08X\\x00\\xc0\\x00\\xab\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf6@@@@'", "ispf": {"version": "06.43", "flags": 0, "createdate": "2005-02-12T00:00:00", "modifydate": "2013-01-17T08:58:00", "lines": 192, "newlines": 171, "modlines": 0, "user": "CBT486"}, "text": ")ATTR\n    ! TYPE(DATAOUT) INTENS(LOW)  COLOR(TURQ) HILITE(USCORE) CAPS(OFF)\n    # TYPE(DATAOUT) INTENS(HIGH) COLOR(TURQ)\n    \u00ac AREA(DYNAMIC)\n    | AREA(SCRL)    EXTEND(ON)\n    % TYPE(TEXT)    INTENS(HIGH) COLOR(PINK) SKIP(ON)\n    _ TYPE(INPUT)   INTENS(HIGH) COLOR(RED)\n    @ TYPE(INPUT)   INTENS(LOW)  COLOR(BLUE)\n)BODY CMD(XODSN) EXPAND(//)\n%XEF - eXtended Editor Facility (&ZAPPLID) - USER:&ZUSER SYS:&ZSYSID /-/ V6.4 -\n%OPTION  ===>_XOPT / / %NUMBER ==>_XN% MEMBER ==>_XMEM    %\n\u00acMENU                                                                          \u00ac\n\u00acMEN2   \u00ac%OTHER DSN OR COMMAND%==>_XODSN                                       %\n%-/-/\n|XEFSCRL                                                                       |\n)AREA XEFSCRL\n% 1@XDSN1                               %51@XDSN51\n% 2@XDSN2                               %52@XDSN52\n% 3@XDSN3                               %53@XDSN53\n% 4@XDSN4                               %54@XDSN54\n% 5@XDSN5                               %55@XDSN55\n% 6@XDSN6                               %56@XDSN56\n% 7@XDSN7                               %57@XDSN57\n% 8@XDSN8                               %58@XDSN58\n% 9@XDSN9                               %59@XDSN59\n%10@XDSN10                              %60@XDSN60\n%11@XDSN11                              %61@XDSN61\n%12@XDSN12                              %62@XDSN62\n%13@XDSN13                              %63@XDSN63\n%14@XDSN14                              %64@XDSN64\n%15@XDSN15                              %65@XDSN65\n%16@XDSN16                              %66@XDSN66\n%17@XDSN17                              %67@XDSN67\n%18@XDSN18                              %68@XDSN68\n%19@XDSN19                              %69@XDSN69\n%20@XDSN20                              %70@XDSN70\n%21@XDSN21                              %71@XDSN71\n%22@XDSN22                              %72@XDSN72\n%23@XDSN23                              %73@XDSN73\n%24@XDSN24                              %74@XDSN74\n%25@XDSN25                              %75@XDSN75\n%26@XDSN26                              %76@XDSN76\n%27@XDSN27                              %77@XDSN77\n%28@XDSN28                              %78@XDSN78\n%29@XDSN29                              %79@XDSN79\n%30@XDSN30                              %80@XDSN80\n%31@XDSN31                              %81@XDSN81\n%32@XDSN32                              %82@XDSN82\n%33@XDSN33                              %83@XDSN83\n%34@XDSN34                              %84@XDSN84\n%35@XDSN35                              %85@XDSN85\n%36@XDSN36                              %86@XDSN86\n%37@XDSN37                              %87@XDSN87\n%38@XDSN38                              %88@XDSN88\n%39@XDSN39                              %89@XDSN89\n%40@XDSN40                              %90@XDSN90\n%41@XDSN41                              %91@XDSN91\n%42@XDSN42                              %92@XDSN92\n%43@XDSN43                              %93@XDSN93\n%44@XDSN44                              %94@XDSN94\n%45@XDSN45                              %95@XDSN95\n%46@XDSN46                              %96@XDSN96\n%47@XDSN47                              %97@XDSN97\n%48@XDSN48                              %98@XDSN98\n%49@XDSN49                              %99@XDSN99\n%50@XDSN50                                      %\n)INIT\n &PDS = Y   /* Y or N for PDS command support   */\n .HELP = XEFHELP\n .CURSOR = XOPT\n &MENU= ' #B-Browse# V-View# E-Edit# M-MemList# +\n           D-Dslist# Z-Compress# I-Info# F-Find#'\n &MEN2= ' #X-!Exit#'\n IF (&PDS = Y)\n   &MENU= '#B-Browse# V-View# E-Edit# M-Memlist# +\n           D-Dslist# Z-Compress# I-Info# P-PDS#F-Find#'\n   &MEN2= '#X-Exit#'\n VGET (XOPT XN XMEM XODSN) PROFILE\n VGET (XDSN1 XDSN2 XDSN3 XDSN4 XDSN5) PROFILE\n VGET (XDSN6 XDSN7 XDSN8 XDSN9 XDSN10) PROFILE\n VGET (XDSN11 XDSN12 XDSN13 XDSN14 XDSN15) PROFILE\n VGET (XDSN16 XDSN17 XDSN18 XDSN19 XDSN20) PROFILE\n VGET (XDSN21 XDSN22 XDSN23 XDSN24 XDSN25) PROFILE\n VGET (XDSN26 XDSN27 XDSN28 XDSN29 XDSN30) PROFILE\n VGET (XDSN31 XDSN32 XDSN33 XDSN34 XDSN35) PROFILE\n VGET (XDSN36 XDSN37 XDSN38 XDSN39 XDSN40) PROFILE\n VGET (XDSN41 XDSN42 XDSN43 XDSN44 XDSN45) PROFILE\n VGET (XDSN46 XDSN47 XDSN48 XDSN49 XDSN50) PROFILE\n VGET (XDSN51 XDSN52 XDSN53 XDSN54 XDSN55) PROFILE\n VGET (XDSN56 XDSN57 XDSN58 XDSN59 XDSN60) PROFILE\n VGET (XDSN61 XDSN62 XDSN63 XDSN64 XDSN65) PROFILE\n VGET (XDSN66 XDSN67 XDSN68 XDSN69 XDSN70) PROFILE\n VGET (XDSN71 XDSN72 XDSN73 XDSN74 XDSN75) PROFILE\n VGET (XDSN76 XDSN77 XDSN78 XDSN79 XDSN80) PROFILE\n VGET (XDSN81 XDSN82 XDSN83 XDSN84 XDSN85) PROFILE\n VGET (XDSN86 XDSN87 XDSN88 XDSN89 XDSN90) PROFILE\n VGET (XDSN91 XDSN92 XDSN93 XDSN94 XDSN95) PROFILE\n VGET (XDSN96 XDSN97 XDSN98 XDSN99) PROFILE\n IF (&PDS = N)\n   IF (&XOPT NE B,V,E,M,D,Z,I,F,FIND)\n       &XOPT = &Z\n IF (&PDS = Y)\n   IF (&XOPT NE B,V,E,M,D,Z,I,P,F,FIND)\n       &XOPT = &Z\n)PROC\n IF (&XN NE &Z)\n   &XN = TRANS(&XN 01,1 02,2 03,3 04,4 05,5 06,6 07,7 08,8 09,9 *,*)\n IF (.CURSOR GE XDSN1 AND .CURSOR LE XDSN99)\n    &XN = TRUNC(.CURSOR,4)\n    &XN = .TRAIL\n\n IF (&XOPT EQ BROWSE)\n    &XOPT = 'B'\n IF (&XOPT EQ VIEW)\n    &XOPT = 'V'\n IF (&XOPT EQ EDIT)\n    &XOPT = 'E'\n IF (&XOPT EQ MEMLIST)\n    &XOPT = 'M'\n IF (&XOPT EQ DSLIST)\n    &XOPT = 'D'\n IF (&XOPT EQ COMPRESS)\n    &XOPT = 'Z'\n IF (&XOPT EQ INFO)\n    &XOPT = 'I'\n IF (&XOPT EQ PDS)\n    &XOPT = 'P'\n IF (&XOPT EQ FIND)\n    &XOPT = 'F'\n IF (&XOPT EQ EXIT)\n    &XOPT = 'X'\n\n &ZSEL = TRANS( TRUNC(&XOPT,)\n                 B,'CMD(%XEFCLIST &XOPT &XN XMEM(''&XMEM''))'\n                 V,'CMD(%XEFCLIST &XOPT &XN XMEM(''&XMEM''))'\n                 E,'CMD(%XEFCLIST &XOPT &XN XMEM(''&XMEM''))'\n                 M,'CMD(%XEFCLIST &XOPT &XN XMEM(''&XMEM''))'\n                 D,'CMD(%XEFCLIST &XOPT &XN)'\n                 Z,'CMD(%XEFCLIST &XOPT &XN)'\n                 I,'CMD(%XEFCLIST &XOPT &XN)'\n                 P,'CMD(%XEFCLIST &XOPT &XN XMEM(''&XMEM''))'\n                 F,'CMD(%XEFCLIST &XOPT &XN)'\n              FIND,'CMD(%XEFCLIST &XOPT &XN)'\n                 X,'EXIT')\n    IF (&PDS = N)\n      VER(&XOPT,NONBLANK,MSG=XEF001A)\n      VER(&XOPT,LIST,B,V,E,M,D,Z,I,F,FIND,MSG=XEF001B)\n    IF (&PDS = Y)\n      VER(&XOPT,NONBLANK,MSG=XEF001C)\n      VER(&XOPT,LIST,B,V,E,M,D,Z,I,P,F,FIND,MSG=XEF001D)\n    IF (&XODSN EQ &Z)\n       VER(&XN,NONBLANK,MSG=XEF002A)\n       VER(&XN,NUM,MSG=XEF002B)\n       VER(&XN,RANGE,1,99,MSG=XEF002B)\n    IF (&XODSN NE &Z)\n       IF (.CURSOR GE XDSN1 AND .CURSOR LE XDSN99)\n          .CURSOR = .CURSOR\n          .MSG=XEF002D\n       VER(&XN,LIST,' ',MSG=XEF002C)\n       &ZSEL = TRANS( TRUNC(&XOPT,)\n                 B,'CMD(%XEFCLIST &XOPT DUMMYDN XMEM(''&XMEM''))'\n                 V,'CMD(%XEFCLIST &XOPT DUMMYDN XMEM(''&XMEM''))'\n                 E,'CMD(%XEFCLIST &XOPT DUMMYDN XMEM(''&XMEM''))'\n                 M,'CMD(%XEFCLIST &XOPT DUMMYDN XMEM(''&XMEM''))'\n                 D,'CMD(%XEFCLIST &XOPT DUMMYDN)'\n                 Z,'CMD(%XEFCLIST &XOPT DUMMYDN)'\n                 I,'CMD(%XEFCLIST &XOPT DUMMYDN)'\n                 F,'CMD(%XEFCLIST &XOPT DUMMYDN)'\n              FIND,'CMD(%XEFCLIST &XOPT DUMMYDN)'\n                 P,'CMD(%XEFCLIST &XOPT DUMMYDN)')\n    VPUT (XOPT XN XMEM XODSN) PROFILE\n    VPUT (XDSN1 XDSN2 XDSN3 XDSN4 XDSN5) PROFILE\n    VPUT (XDSN6 XDSN7 XDSN8 XDSN9 XDSN10) PROFILE\n    VPUT (XDSN11 XDSN12 XDSN13 XDSN14 XDSN15) PROFILE\n    VPUT (XDSN16 XDSN17 XDSN18 XDSN19 XDSN20) PROFILE\n    VPUT (XDSN21 XDSN22 XDSN23 XDSN24 XDSN25) PROFILE\n    VPUT (XDSN26 XDSN27 XDSN28 XDSN29 XDSN30) PROFILE\n    VPUT (XDSN31 XDSN32 XDSN33 XDSN34 XDSN35) PROFILE\n    VPUT (XDSN36 XDSN37 XDSN38 XDSN39 XDSN40) PROFILE\n    VPUT (XDSN41 XDSN42 XDSN43 XDSN44 XDSN45) PROFILE\n    VPUT (XDSN46 XDSN47 XDSN48 XDSN49 XDSN50) PROFILE\n    VPUT (XDSN51 XDSN52 XDSN53 XDSN54 XDSN55) PROFILE\n    VPUT (XDSN56 XDSN57 XDSN58 XDSN59 XDSN60) PROFILE\n    VPUT (XDSN61 XDSN62 XDSN63 XDSN64 XDSN65) PROFILE\n    VPUT (XDSN66 XDSN67 XDSN68 XDSN69 XDSN70) PROFILE\n    VPUT (XDSN71 XDSN72 XDSN73 XDSN74 XDSN75) PROFILE\n    VPUT (XDSN76 XDSN77 XDSN78 XDSN79 XDSN80) PROFILE\n    VPUT (XDSN81 XDSN82 XDSN83 XDSN84 XDSN85) PROFILE\n    VPUT (XDSN86 XDSN87 XDSN88 XDSN89 XDSN90) PROFILE\n    VPUT (XDSN91 XDSN92 XDSN93 XDSN94 XDSN95) PROFILE\n    VPUT (XDSN96 XDSN97 XDSN98 XDSN99) PROFILE\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "XEFV62": {"ttr": 33284, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06\\x02\\x00\\x00\\x01\\x05\\x04\\x1f\\x01\\x05\\x04\\x1f\\x13E\\x04\\xd5\\x04\\xd5\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf6\\xf8@@@@'", "ispf": {"version": "06.02", "flags": 0, "createdate": "2005-02-10T00:00:00", "modifydate": "2005-02-10T13:45:00", "lines": 1237, "newlines": 1237, "modlines": 0, "user": "CBT468"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "XEF00": {"ttr": 33796, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06+\\x00\\x00\\x01\\x00\\x11\\x1f\\x01\\x11\\x17\\x8f\\x14\\x15\\x00&\\x00*\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf3@@@@'", "ispf": {"version": "06.43", "flags": 0, "createdate": "2000-04-20T00:00:00", "modifydate": "2011-06-27T14:15:00", "lines": 38, "newlines": 42, "modlines": 0, "user": "CBT483"}, "text": "XEF001A 'Enter option' .HELP=XEFHELP  .ALARM=NO\n'You must choose an option. Valid options are: B, V, E, M, D, Z, I, F and X.'\nXEF001B 'Invalid option' .HELP=XEFHELP  .ALARM=YES\n'Valid options are: B, V, E, M, D, Z, I, F and X.'\nXEF001C 'Enter option' .HELP=XEFHELP  .ALARM=NO\n'You must choose an option. Valid options are: B, V, E, M, D, Z, I, P, F and X.'\nXEF001D 'Invalid option' .HELP=XEFHELP  .ALARM=YES\n'Valid options are: B, V, E, M, D, Z, I, P, F and X.'\nXEF002A 'Number is required' .HELP=XEFHELP  .ALARM=YES\n'A dataset number between 1 and 99 must be chosen.'\nXEF002B 'Invalid number' .HELP=XEFHELP  .ALARM=YES\n'A dataset number between 1 and 99 must be chosen.'\nXEF002C 'Number not allowed' .HELP=XEFHELP  .ALARM=YES\n'A dataset number is not allowed when using the \"OTHER DATASET NAME\" field.'\nXEF002D 'Cursor select invalid' .HELP=XEFHELP  .ALARM=YES\n'Cursor selection is not allowed when using the \"OTHER DATASET NAME\" field.'\nXEF003A 'No matches' .HELP=XEFHELP .ALARM=YES\n'Member name pattern &XMEM produced no matching members.'\nXEF003B 'Member not found' .HELP=XEFHELP .ALARM=YES\n'Member &XMEM was not found in the pds directory.'\nXEF003C 'Invalid DSORG' .HELP=XEFHELP .ALARM=YES\n'''&NAME'' organization must be partitioned.'\nXEF004A 'Null dataset name' .HELP=XEFHELP  .ALARM=YES\n'No dataset name exists for dataset number &XDN in your dataset list.'\nXEF005A 'Compress successful' .HELP=XEFHELP\n'''&NAME'' was successfully compressed.'\nXEF005B 'Compress successful' .HELP=XEFHELP\n'Compress listing is in ''&XLISTDSN''.'\nXEF006A 'Invalid command'  .ALARM=YES\n'Valid member list commands are \"SELECT\", \"SORT\", \"LOCATE\", \"RESET\" and \"SAVE\".'\nXEF006B 'Invalid selection code' .HELP=XEFHELP  .ALARM=YES\n'Codes are:  E (edit), B (browse), V (view), R (rename), D (delete), P (print).'\nXEF006C 'Invalid selection code' .HELP=XEFHELP  .ALARM=YES\n'Codes are:  E (edit), B (browse), R (rename), D (delete), P (print).'\nXEF007A 'Dataset info failed'  .HELP=XEFHELP .ALARM=YES\n'&XERRMSG..'\nXEF008A 'String not found'  .HELP=XEFHELP .ALARM=YES\n'No dataset names were found that matched your FIND request.'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XEF62": {"ttr": 33798, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x06\\x02\\x00\\x00\\x01\\x05\\x04\\x1f\\x01\\x05\\x04\\x1f\\x13E\\x04\\xd5\\x04\\xd5\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf6\\xf8@@@@'", "ispf": {"version": "06.02", "flags": 0, "createdate": "2005-02-10T00:00:00", "modifydate": "2005-02-10T13:45:00", "lines": 1237, "newlines": 1237, "modlines": 0, "user": "CBT468"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "XLISTC": {"ttr": 34309, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x04\\x00\\x992/\\x00\\x992/\\x16'\\x00'\\x00'\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf2\\xf2@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "1999-11-18T16:27:04", "lines": 39, "newlines": 39, "modlines": 0, "user": "CBT422"}, "text": "/* REXX */\n/*                           */\n/* AUTHOR: MARK ZELDEN       */\n/*                           */\n /* =================================================== */\n /* LISTCAT LINE COMMAND FOR DSN PANEL OPTION 3.4       */\n /* ALSO AN ISPF COMMAND IN THE ISPF COMMAND TABLE      */\n /* =================================================== */\n /* ADDRESS ISPEXEC \"VGET ZDLDSN SHARED\"  */\n /* \"LISTC ALL ENT(\"ZDLDSN\")\"             */\n/* TRACE ?I */\narg NAME\naddress TSO\nif NAME = '' then do\n  say 'PLEASE ENTER DATASET NAME TO LIST:'\n  parse upper pull NAME\nend\naddress ISPEXEC \"CONTROL ERRORS RETURN\"\nddnm = 'DD'||random(1,99999)    /* choose random ddname  */\njunk = msg(off)\n\"ALLOC FILE(\"||ddnm||\") UNIT(VIO) NEW TRACKS SPACE(5,5) DELETE\",\n\" REUSE LRECL(132) RECFM(F B) BLKSIZE(8976)\"\njunk = msg(on)\n/*                                     */\n/*  issue listcat cmd and trap output  */\n/*                                     */\njunk=outtrap(LINE.)\n\"LISTC ALL ENT(\"||name||\")\"\nretcode = rc\njunk=outtrap('off')\n/*                                     */\n\"EXECIO\" line.0  \"DISKW\" ddnm \"(STEM LINE. FINIS\"\naddress ISPEXEC \"LMINIT DATAID(LIST) DDNAME(\"||ddnm||\")\"\naddress ISPEXEC \"BROWSE DATAID(\"||list\")\"\naddress ISPEXEC \"LMFREE DATAID(\"||list\")\"\njunk = msg(off)\n\"FREE FI(\"||ddnm||\")\"\nzdlmsg = 'LISTED RC='||retcode\naddress ispexec \"VPUT ZDLMSG SHARED\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XMEMLIST": {"ttr": 34311, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x992/\\x01\\x12\\x17\\x0f\\x100\\x01\\x1b\\x00\\xbd\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf8\\xf4@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "2012-06-18T10:30:00", "lines": 283, "newlines": 189, "modlines": 0, "user": "CBT484"}, "text": "/* REXX */\n/*                                       */\n/* AUTHOR: Mark Zelden                   */\n/*                                       */\n/* Last update:  06/18/2012              */\n/*****************************************************************/\n/*  XMEMLIST - MEMLIST a data set from anywhere.                 */\n/*                                                               */\n/*  Best used when set up in the ISPF command table with an      */\n/*  abbreviation of \"XM\".                                        */\n/*    VERB      T   ACTION                                       */\n/*    XMEMLIST  2   SELECT CMD(%XMEMLIST &ZPARM) NEWAPPL(ISR)    */\n/*                                                               */\n/*  Fully qualified data set names are now optional, regardless  */\n/*  of the TSO PROFILE PREFIX setting. PREFIX.DATA.SET.NAME will */\n/*  be tried first, then DATA.SET.NAME for data sets that are    */\n/*  not fully qualified.                                         */\n/*                                                               */\n/*****************************************************************/\n/* COMMAND SYNTAX:                                               */\n/*                                                               */\n/*  XM DATA.SET.NAME  <volser>    (VOLSER is optional)           */\n/*                                                               */\n/*  XM 'MY.PDS(ABC*)'                                            */\n/*  XM PDS.NOTCAT USER01                                         */\n/*                                                               */\n/*  If not set up as an ISPF command, then you can still         */\n/*  invoke the exec by typing:   TSO %XMEMLIST DATA.SET.NAME     */\n/*****************************************************************/\nParse UPPER ARG DSN VOL\n\nIf DSN= '' then do                          /* no DSN specified      */\n  say 'Please enter positional parameter dsn -' /* prompt for dsn    */\n  parse upper pull DSN                      /* get dsn response      */\nEnd\n\nAddress ISPEXEC\n\"CONTROL ERRORS RETURN\"\njunk = MSG(off)\n\nMEMSTART = Pos('(',DSN)\nIf MEMSTART <> 0 then do\n  MEMEND = Pos(')',DSN)\n  XMEM   = Substr(DSN,MEMSTART+1,MEMEND-MEMSTART-1)\n  DSN    = Substr(DSN,1,MEMSTART-1)\n  If Pos(\"'\",DSN) <> 0 then DSN = DSN || \"'\"\nEnd\n Else XMEM = ''\n\n\n\"VGET ZENVIR\"                              /* get ISPF version      */\nXIVER1 = Substr(ZENVIR,6,1)                /* only need 1 char      */\n\"VGET ZPCFMCN PROFILE\"\nIf ZPCFMCN = '/' then CONF = 'YES'\n Else CONF = 'NO'\n\n\"LMINIT DATAID(\"XMEMD1\") DATASET(\"DSN\") VOLUME(\"VOL\")\"\nRCSV = RC\nIf RCSV <> 0 then do\n   If Pos(\"'\",DSN) <> 0 then QUOTES = 'Y'   /* need to know for later*/\n   DSN =  Strip(Translate(DSN,\"\",\"'\"))      /* remove quotes if used */\n   \"LMINIT DATAID(\"XMEMD1\") DATASET('\"DSN\"') VOLUME(\"VOL\")\"\n   RCSV = RC\n   If RCSV <> 0 then do\n     \"SETMSG MSG(\"ZERRMSG\")\"                /* not found - issue msg */\n     Exit RCSV\n   End\n   Else if QUOTES <> 'Y' then DSN = \"'\" || DSN || \"'\"  /* add quotes */\nEnd\nIf RCSV = 0 then do\n  \"LMOPEN DATAID(\"XMEMD1\")\"\n  RCSV = RC\n  If RCSV = 0 then do\n    ZLLCMD   = ''\n    ZLMEMBER = ''\n    ZLUDATA  = ''\n    CURLOC   = 'ZLLCMD'\n    \"LMMDISP DATAID(\"XMEMD1\") COMMANDS(ANY) MEMBER(\"XMEM\")\"\n    RCSV = RC\n    Do while RCSV = 0\n      If ZLLCMD = 'B' then do\n        \"BROWSE DATAID(\"XMEMD1\") MEMBER(\"ZLMEMBER\")\"\n        CC = RC\n        UD = '*BROWSED'\n        If CC <> 0 then \"SETMSG MSG(\"ZERRMSG\")\"\n      End\n      Else if ZLLCMD = '/' & XIVER1 >= 4 then do\n        \"BROWSE DATAID(\"XMEMD1\") MEMBER(\"ZLMEMBER\")\"\n        CC = RC\n        UD = '*BROWSED'\n        If CC <> 0 then \"SETMSG MSG(\"ZERRMSG\")\"\n      End\n      Else if ZLLCMD = 'V' & XIVER1 >=4 then do\n        \"VIEW DATAID(\"XMEMD1\") MEMBER(\"ZLMEMBER\")\" ,\n               \"CONFIRM(\"CONF\")\"\n        CC = RC\n        UD = '*VIEWED'\n        If CC <> 0 then \"SETMSG MSG(\"ZERRMSG\")\"\n      End\n      Else if ZLLCMD = 'E' & XIVER1 >=4 then do\n        EDITOK = 'NOTOK'\n        Do while EDITOK = 'NOTOK'\n          \"EDREC QUERY\"\n          If RC = 4 then do\n            \"DISPLAY PANEL(ISREDM02)\"\n            DISPRC = RC\n            \"VGET ZVERB\"\n             If DISPRC = 0 then do\n               If ZEDCMD = '' then \"EDREC PROCESS PASSWORD(\" || PSWD || \")\"\n               If ZEDCMD = 'C' then \"EDREC CANCEL\"\n               If ZEDCMD = 'D' then \"EDREC DEFER\"\n             End\n             Else if DISPRC = 8 & ZVERB = 'CANCEL' then \"EDREC CANCEL\"\n             Else EXIT 0\n          End\n          Else EDITOK = 'OK'\n        End\n        RC = 0\n        \"EDIT DATAID(\"XMEMD1\") MEMBER(\"ZLMEMBER\")\" ,\n               \"CONFIRM(\"CONF\")\"\n        CC = RC\n        UD = '*EDITED'\n        If CC = 4 then CC = 0\n        If CC <> 0 then \"SETMSG MSG(\"ZERRMSG\")\"\n      End /* Else if ZLLCMD = 'E' & XIVER1 >=4 */\n      Else if ZLLCMD = 'E' & XIVER1 < 4 then do\n        EDITOK = 'NOTOK'\n        Do while EDITOK = 'NOTOK'\n          \"EDREC QUERY\"\n          If RC = 4 then do\n            \"DISPLAY PANEL(ISREDM02)\"\n            DISPRC = RC\n            \"VGET ZVERB\"\n             If DISPRC = 0 then do\n               If ZEDCMD = '' then \"EDREC PROCESS PASSWORD(\" || PSWD || \")\"\n               If ZEDCMD = 'C' then \"EDREC CANCEL\"\n               If ZEDCMD = 'D' then \"EDREC DEFER\"\n             End\n             Else if DISPRC = 8 & ZVERB = 'CANCEL' then \"EDREC CANCEL\"\n             Else EXIT 0\n          End\n          Else EDITOK = 'OK'\n        End\n        RC = 0\n        \"EDIT DATAID(\"XMEMD1\") MEMBER(\"ZLMEMBER\")\"\n        CC = RC\n        UD = '*EDITED'\n        If CC = 4 then CC = 0\n        If CC <> 0 then \"SETMSG MSG(\"ZERRMSG\")\"\n      End /* Else if ZLLCMD = 'E' & XIVER1 < 4 */\n      Else if ZLLCMD = 'P' then do\n        \"LMPRINT DATAID(\"XMEMD1\") MEMBER(\"ZLMEMBER\")\"\n        CC = RC\n        UD = '*PRINTED'\n        If CC <> 0 then \"SETMSG MSG(\"ZERRMSG\")\"\n      End\n      Else if ZLLCMD = 'R' then do\n        \"LMINIT DATAID(XMEMD2) DATASET(\"DSN\")\" ,\n            \"ENQ(SHRW) VOLUME(\"VOL\")\"\n        RCSV = RC\n        If RCSV = 0 then do\n          \"LMOPEN DATAID(\"XMEMD2\") OPTION(OUTPUT)\"\n          CC = RC\n          If CC = 0 then do\n            \"LMMREN DATAID(\"XMEMD2\") MEMBER(\"ZLMEMBER\")\" ,\n                \"NEWNAME(\"ZLUDATA\")\"\n             CC = RC\n             If ZLUDATA = '' then do\n               ZERRMSG = 'ISRU003'\n               CURLOC  = 'ZLUDATA'\n             End\n            UD = '*RENAMED'\n            \"LMCLOSE DATAID(\"XMEMD2\")\"\n          End\n          \"LMFREE DATAID(\"XMEMD2\")\"\n        End\n      End  /* if ZLLCMD = 'R' */\n      Else if ZLLCMD = 'D' then do\n        \"LMINIT DATAID(XMEMD2) DATASET(\"DSN\")\" ,\n          \"ENQ(SHRW) VOLUME(\"VOL\")\"\n        RCSV = RC\n        If RCSV = 0 then do\n          \"LMOPEN DATAID(\"XMEMD2\") OPTION(OUTPUT)\"\n          CC = RC\n          If CC = 0 then do\n            \"VGET ZMEMCONF\"\n            If ZMEMCONF <> 'OFF' then do\n              ZCFDSN = Strip(Translate(DSN,\"\",\"'\"))\n              ZCFMEM = ZLMEMBER\n              UD = ''\n              \"ADDPOP\"\n              \"DISPLAY PANEL(ISRUDELC)\"\n              DISPRC = RC\n              If DISPRC = 0 then do\n                \"LMMDEL DATAID(\"XMEMD2\") MEMBER(\"ZLMEMBER\")\"\n                CC = RC\n                UD = '*DELETED'\n              End\n              \"REMPOP\"\n            End /* if ZMEMCONF = */\n            Else Do\n              \"LMMDEL DATAID(\"XMEMD2\") MEMBER(\"ZLMEMBER\")\"\n              CC = RC\n              UD = '*DELETED'\n            End\n            \"LMCLOSE DATAID(\"XMEMD2\")\"\n          End\n          \"LMFREE DATAID(\"XMEMD2\")\"\n        End  /* if RCSV = 0 */\n      End  /* if ZLLCMD = 'D' */\n      Else do\n        If ZCMD <> '' then do\n          ZEDSMSG = 'Invalid command'\n          ZEDLMSG = 'Valid member list commands are',\n                    '\"SELECT\", \"SORT\", \"LOCATE\", \"RESET\"' ,\n                        'and \"SAVE\".'\n          ZERRMSG = 'ISRZ001' /* MSG - WITH ALARM */\n          CURLOC  = 'ZCMD'\n        End\n        Else do\n          ZEDSMSG = 'Invalid selection code'\n          If XIVER1 < 4 then ,\n            ZEDLMSG = 'Codes are: E (Edit),' ,\n                          'B (Browse),' ,\n                          'R (Rename), D (Delete),' ,\n                          'P (Print).'\n          Else ,\n            ZEDLMSG = 'Valid codes: E (Edit),',\n                          'B (Browse), V (View),' ,\n                          'R (Rename), D (Delete),' ,\n                          'P (Print).'\n          ZERRMSG = 'ISRZ001' /* MSG - WITH ALARM */\n          CURLOC  = 'ZLLCMD'\n        End\n      CC = 4   /* init non zero CC for next selection */\n      End\n      If CC = 0 then do\n        \"LMMDISP DATAID(\"XMEMD1\") OPTION(PUT)\" ,\n          \"MEMBER(\"ZLMEMBER\") ZLUDATA(\"UD\")\"\n        \"LMMDISP DATAID(\"XMEMD1\") OPTION(GET)\"\n        RCSV = RC\n        If RCSV = 8 then do\n          \"LMMDISP DATAID(\"XMEMD1\") COMMANDS(ANY)\"\n          RCSV = RC\n        End\n      End\n      Else do\n        \"SETMSG MSG(\"ZERRMSG\")\"\n        \"LMMDISP DATAID(\"XMEMD1\") OPTION(PUT)\" ,\n          \"MEMBER(\"ZLMEMBER\") ZLLCMD(\"ZLLCMD\") ZLUDATA(\"ZLUDATA\")\"\n        \"LMMDISP DATAID(\"XMEMD1\") COMMANDS(ANY)\" ,\n          \"CURSOR(\"CURLOC\") TOP(\"ZLMEMBER\")\"\n        RCSV = RC\n      End\n    End /* do while RC=0 */\n    If RCSV = 8 then RCSV = 0\n    \"LMMDISP DATAID(\"XMEMD1\") OPTION(FREE)\"\n    If Translate(ZERRSM) = 'NO MEMBER LIST' then do\n      If Pos('*',XMEM) > 0 | Pos('%',XMEM) > 0 then do\n        ZEDSMSG = 'No matches'\n        ZEDLMSG = 'Member name pattern' XMEM 'produced' ,\n                      'no matching members.'\n        ZERRMSG = 'ISRZ001' /* MSG - WITH ALARM */\n      End\n      Else do\n        ZEDSMSG = 'Member not found'\n        ZEDLMSG = 'Member' XMEM 'was not found in the' ,\n                     'PDS directory.'\n        ZERRMSG = 'ISRZ001' /* MSG - WITH ALARM */\n      End\n    End\n    If Translate(ZERRSM) = 'DATA SET NOT PARTITIONED' then do\n      ZEDSMSG = 'Invalid DSORG'\n      ZEDLMSG = DSN 'organization must be' ,\n                    'partitioned.'\n      ZERRMSG = 'ISRZ001' /* MSG - WITH ALARM */\n    End\n    \"LMCLOSE DATAID(\"XMEMD1\")\"\n  End\n  \"LMFREE DATAID(\"XMEMD1\")\"\nEnd\nIf RCSV <> 0 then \"SETMSG MSG(\"ZERRMSG\")\"\nExit RCSV\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XVIEW": {"ttr": 34317, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x992/\\x01\\x02\\x13_\\x08\\x15\\x001\\x00\\x0e\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf4\\xf7@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "2002-05-15T08:15:00", "lines": 49, "newlines": 14, "modlines": 0, "user": "CBT447"}, "text": "/* REXX */\n/*                                       */\n/* AUTHOR: Mark Zelden                   */\n/*                                       */\n/* Last update:  05/15/2002              */\n/*****************************************************************/\n/*  XVIEW - VIEW a data set from anywhere.                       */\n/*                                                               */\n/*  Best used when set up in the ISPF command table with an      */\n/*  abbreviation of \"XV\".                                        */\n/*    VERB      T   ACTION                                       */\n/*    XVIEW     2   SELECT CMD(%XVIEW &ZPARM) NEWAPPL(ISR)       */\n/*                                                               */\n/*  Fully qualified data set names are now optional, regardless  */\n/*  of the TSO PROFILE PREFIX setting. PREFIX.DATA.SET.NAME will */\n/*  be tried first, then DATA.SET.NAME for data sets that are    */\n/*  not fully qualified.                                         */\n/*                                                               */\n/*****************************************************************/\n/* COMMAND SYNTAX:                                               */\n/*                                                               */\n/*  XV DATA.SET.NAME  <volser>    (VOLSER is optional)           */\n/*                                                               */\n/*  XV 'MY.PDS(ABC*)'                                            */\n/*  XV PDS.NOTCAT USER01                                         */\n/*                                                               */\n/*  If not set up as an ISPF command, then you can still         */\n/*  invoke the exec by typing:   TSO %XVIEW DATA.SET.NAME        */\n/*****************************************************************/\nParse UPPER ARG DSN VOL\n\nIf DSN= '' then do                          /* no DSN specified      */\n  say 'Please enter positional parameter dsn -' /* prompt for dsn    */\n  parse upper pull DSN                      /* get dsn response      */\nEnd\n\nAddress ISPEXEC\n\"CONTROL ERRORS RETURN\"\n\"VGET ZPCFMCN PROFILE\"\nIf ZPCFMCN = '/' then CONF = 'YES'\n else CONF = 'NO'\n\"VIEW DATASET(\"DSN\") VOLUME(\"VOL\")\" ,       /* try userid.DSN first  */\n\"CONFIRM(\"CONF\")\"\nIf RC <> 0 then do                          /* not found - try again */\n   DSN =  Strip(Translate(DSN,\"\",\"'\"))      /* remove quotes if used */\n  \"VIEW DATASET('\"DSN\"') VOLUME(\"VOL\")\" ,   /* try DSN specified     */\n  \"CONFIRM(\"CONF\")\"\nEnd\nIf RC <> 0 then \"SETMSG MSG(\"ZERRMSG\")\"     /* not found - issue msg */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZBROWSE": {"ttr": 34561, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00I\\x00\\x992/\\x01\\x02(\\x8f\\x13\\x11\\x00@\\x00=\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf5\\xf3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "2002-10-15T13:11:49", "lines": 64, "newlines": 61, "modlines": 0, "user": "CBT453"}, "text": "/* REXX */\n/*                                             */\n/*                                             */\n/* AUTHOR: Mark Zelden                         */\n/*                                             */\n/* This edit macro allows the user to BROWSE   */\n/* the data set located on the line that the   */\n/* cursor is on.                               */\n/*                                             */\n/* The cursor can be anywhere on a line that   */\n/* has DSN= or DSNAME= but must be at the      */\n/* start of the data set name if there is      */\n/* no DSN= or DSNAME=.                         */\n/*                                             */\n/* Last updated on 10/15/2002                  */\n/* TRACE ?R */\nAddress ISREDIT\n\"MACRO\"\nAddress ISPEXEC \"CONTROL ERRORS RETURN\"\n  /***********************************************/\n  /*   BEGIN PROCESSING                          */\n  /***********************************************/\n  \"(row,col) = CURSOR\"\n  \"(data1) = LINE \" row              /* data1 = cursor line          */\n  /**********************************/\n  /* Find start of data set name    */\n  /**********************************/\n  dsnstart = Pos('DSN=',data1)       /* look for DSN=                */\n  If dsnstart = 0 then do            /* no DSN =                     */\n    dsnstart = Pos('DSNAME=',data1)  /* look for DSNAME=             */\n    If dsnstart = 0 then do          /* no DSN= or DSNAME=           */\n      \"CURSOR = \" row col            /* cursor pos                   */\n      If col < 1 then dsnstart = 1   /* needed for ZB line cmd       */\n      Else dsnstart = col            /* assume cursor on DSN         */\n    End\n    Else dsnstart = dsnstart + 7     /* DSNAME= specified in JCL     */\n  End /* if dsnstart = 0 */\n  Else dsnstart = dsnstart + 4       /* DSN = specified in JCL       */\n  /**********************************/\n  /* Find end of data set name      */\n  /**********************************/\n  dsnend = Pos(',',data1,dsnstart)   /* look for comma at end of dsn */\n  If dsnend = 0 then do              /* no comma found               */\n    dsnend = Pos(' ',data1,dsnstart) /* look for blank to end DSN    */\n    If dsnend = 0 then do            /* no blank or comma at end     */\n      zedsmsg = 'No end of DSN'\n      zedlmsg = 'The data set name is not terminated with a' ,\n                'space or comma.'\n      Address ISPEXEC \"SETMSG MSG(ISRZ001)\"      /* msg - with alarm */\n      \"CURSOR = \" row col /* put cursor back to last position        */\n      Exit 8\n    End  /* if dsnend = 0 */\n    Else dsnend = dsnend - 1         /* DSN ends with blank          */\n  End /* if dsnend = 0 */\n  Else dsnend = dsnend - 1           /* DSN ends with comma          */\n  /**********************************/\n  /* BROWSE the data set            */\n  /**********************************/\n  dsn = Substr(data1,dsnstart,dsnend-dsnstart+1) /* extract dsn     */\n  dsn = Strip(Translate(dsn,\"\",\"'\"))       /* remove quotes if used */\n  Address ISPEXEC \"BROWSE DATASET('\"dsn\"')\"\n  If RC <> 0 then Address ISPEXEC \"SETMSG MSG(\"ZERRMSG\")\"\n  \"CURSOR = \" row col /* put cursor back to last position        */\n  Exit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZEDIT": {"ttr": 34563, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x992/\\x01\\x02(\\x8f\\x13\\x12\\x00d\\x00]\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf5\\xf3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "2002-10-15T13:12:00", "lines": 100, "newlines": 93, "modlines": 0, "user": "CBT453"}, "text": "/* REXX */\n/*                                             */\n/* AUTHOR: Mark Zelden                         */\n/*                                             */\n/* This edit macro allows the user to EDIT     */\n/* the data set located on the line that the   */\n/* cursor is on.                               */\n/*                                             */\n/* The cursor can be anywhere on a line that   */\n/* has DSN= or DSNAME= but must be at the      */\n/* start of the data set name if there is      */\n/* no DSN= or DSNAME=.                         */\n/*                                             */\n/* Last updated on 10/15/2002                  */\n/* TRACE ?R */\nAddress ISREDIT\n\"MACRO\"\nAddress ISPEXEC \"CONTROL ERRORS RETURN\"\nAddress ISPEXEC \"VGET ZENVIR\"\nZIVER  = Substr(ZENVIR,6,1)                   /* get ISPF version    */\nIf ZIVER >= 4 then do                         /* check ISPF version  */\n  Address ISPEXEC \"VGET ZPCFMCN PROFILE\"      /* get confirm setting */\n  If ZPCFMCN == '/' then CONF = 'YES'\n    Else CONF = 'NO'\nEnd  /* if ZIVER */\n  /***********************************************/\n  /*   BEGIN PROCESSING                          */\n  /***********************************************/\n  \"(row,col) = CURSOR\"\n  \"(data1) = LINE \" row              /* data1 = cursor line          */\n  /**********************************/\n  /* Find start of data set name    */\n  /**********************************/\n  dsnstart = Pos('DSN=',data1)       /* look for DSN=                */\n  If dsnstart = 0 then do            /* no DSN =                     */\n    dsnstart = Pos('DSNAME=',data1)  /* look for DSNAME=             */\n    If dsnstart = 0 then do          /* no DSN= or DSNAME=           */\n      \"CURSOR = \" row col            /* cursor pos                   */\n      If col < 1 then dsnstart = 1   /* needed for ZE line cmd       */\n      Else dsnstart = col            /* assume cursor on DSN         */\n    End\n    Else dsnstart = dsnstart + 7     /* DSNAME= specified in JCL     */\n  End /* if dsnstart = 0 */\n  Else dsnstart = dsnstart + 4       /* DSN = specified in JCL       */\n  /**********************************/\n  /* Find end of data set name      */\n  /**********************************/\n  dsnend = Pos(',',data1,dsnstart)   /* look for comma at end of dsn */\n  If dsnend = 0 then do              /* no comma found               */\n    dsnend = Pos(' ',data1,dsnstart) /* look for blank to end DSN    */\n    If dsnend = 0 then do            /* no blank or comma at end     */\n      zedsmsg = 'No end of DSN'\n      zedlmsg = 'The data set name is not terminated with a' ,\n                'space or comma.'\n      Address ISPEXEC \"SETMSG MSG(ISRZ001)\"      /* msg - with alarm */\n      \"CURSOR = \" row col /* put cursor back to last position        */\n      Exit 8\n    End  /* if dsnend = 0 */\n    Else dsnend = dsnend - 1         /* DSN ends with blank          */\n  End /* if dsnend = 0 */\n  Else dsnend = dsnend - 1           /* DSN ends with comma          */\n  /**********************************/\n  /* EDIT the data set              */\n  /**********************************/\n  dsn = Substr(data1,dsnstart,dsnend-dsnstart+1) /* extract dsn     */\n  dsn = Strip(Translate(dsn,\"\",\"'\"))       /* remove quotes if used */\n  editok = 'NOTOK'\n  Do while editok = 'NOTOK'\n    Address ISPEXEC \"EDREC QUERY\"\n    If RC = 4 then do\n      Address ISPEXEC \"DISPLAY PANEL(ISREDM02)\"\n      DISPRC = RC\n      Address ISPEXEC \"VGET ZVERB\"\n        If DISPRC = 0 then do\n          If ZEDCMD = '' then ,\n            Address ISPEXEC \"EDREC PROCESS PASSWORD(\"PSWD\")\"\n          If ZEDCMD = 'C' then address ISPEXEC \"EDREC CANCEL\"\n          If ZEDCMD = 'D' then address ISPEXEC \"EDREC DEFER\"\n        End /* if RC = 0 */\n        Else if DISPRC = 8 & ZVERB = 'CANCEL' then ,\n            Address ISPEXEC \"EDREC CANCEL\"\n        Else do\n         \"CURSOR = \" row col /* put cursor back to last position     */\n          Exit 0\n        End\n    End /* if RC = 4 */\n    Else editok = 'OK'\n  End  /* do while editok */\n  RC = 0\n  If editok = 'OK' & ZIVER >= 4 then do\n    Address ISPEXEC \"EDIT DATASET('\"dsn\"') CONFIRM(\"conf\")\"\n    If RC = 4 then RC = 0\n  End\n  If editok = 'OK' & ZIVER < 4 then do\n    Address ISPEXEC \"EDIT DATASET('\"dsn\"')\"\n    If RC = 4 then RC = 0\n  End\n  If RC <> 0 then Address ISPEXEC \"SETMSG MSG(\"ZERRMSG\")\"\n  \"CURSOR = \" row col /* put cursor back to last position        */\n  Exit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZVIEW": {"ttr": 34566, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x14\\x00\\x992/\\x01\\x02(\\x8f\\x13\\x12\\x00C\\x00@\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf5\\xf3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-11-18T00:00:00", "modifydate": "2002-10-15T13:12:14", "lines": 67, "newlines": 64, "modlines": 0, "user": "CBT453"}, "text": "/* REXX */\n/*                                             */\n/*                                             */\n/* AUTHOR: Mark Zelden                         */\n/*                                             */\n/* This edit macro allows the user to VIEW     */\n/* the data set located on the line that the   */\n/* cursor is on.                               */\n/*                                             */\n/* The cursor can be anywhere on a line that   */\n/* has DSN= or DSNAME= but must be at the      */\n/* start of the data set name if there is      */\n/* no DSN= or DSNAME=.                         */\n/*                                             */\n/* Last updated on 10/15/2002                  */\n/* TRACE ?R */\nAddress ISREDIT\n\"MACRO\"\nAddress ISPEXEC \"CONTROL ERRORS RETURN\"\nAddress ISPEXEC \"VGET ZPCFMCN PROFILE\"         /* get confirm setting */\nIf ZPCFMCN == '/' then CONF = 'YES'\n  Else CONF = 'NO'\n  /***********************************************/\n  /*   BEGIN PROCESSING                          */\n  /***********************************************/\n  \"(row,col) = CURSOR\"\n  \"(data1) = LINE \" row              /* data1 = cursor line          */\n  /**********************************/\n  /* Find start of data set name    */\n  /**********************************/\n  dsnstart = Pos('DSN=',data1)       /* look for DSN=                */\n  If dsnstart = 0 then do            /* no DSN =                     */\n    dsnstart = Pos('DSNAME=',data1)  /* look for DSNAME=             */\n    If dsnstart = 0 then do          /* no DSN= or DSNAME=           */\n      \"CURSOR = \" row col            /* cursor pos                   */\n      If col < 1 then dsnstart = 1   /* needed for ZV line cmd       */\n      Else dsnstart = col            /* assume cursor on DSN         */\n    End\n    Else dsnstart = dsnstart + 7     /* DSNAME= specified in JCL     */\n  End /* if dsnstart = 0 */\n  Else dsnstart = dsnstart + 4       /* DSN = specified in JCL       */\n  /**********************************/\n  /* Find end of data set name      */\n  /**********************************/\n  dsnend = Pos(',',data1,dsnstart)   /* look for comma at end of dsn */\n  If dsnend = 0 then do              /* no comma found               */\n    dsnend = Pos(' ',data1,dsnstart) /* look for blank to end DSN    */\n    If dsnend = 0 then do            /* no blank or comma at end     */\n      zedsmsg = 'No end of DSN'\n      zedlmsg = 'The data set name is not terminated with a' ,\n                'space or comma.'\n      Address ISPEXEC \"SETMSG MSG(ISRZ001)\"      /* msg - with alarm */\n      \"CURSOR = \" row col /* put cursor back to last position        */\n      Exit 8\n    End  /* if dsnend = 0 */\n    Else dsnend = dsnend - 1         /* DSN ends with blank          */\n  End /* if dsnend = 0 */\n  Else dsnend = dsnend - 1           /* DSN ends with comma          */\n  /**********************************/\n  /* VIEW the data set              */\n  /**********************************/\n  dsn = Substr(data1,dsnstart,dsnend-dsnstart+1) /* extract dsn     */\n  dsn = Strip(Translate(dsn,\"\",\"'\"))       /* remove quotes if used */\n  Address ISPEXEC \"VIEW DATASET('\"dsn\"') CONFIRM(\"conf\")\"\n  If RC <> 0 then Address ISPEXEC \"SETMSG MSG(\"ZERRMSG\")\"\n  \"CURSOR = \" row col /* put cursor back to last position        */\n  Exit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT434/FILE434.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT434", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}