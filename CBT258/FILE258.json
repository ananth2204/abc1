{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011610000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 4115020, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 12, "INMDSNAM": "CBT.V500.FILE258.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 4115020, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 4115020, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE258.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00@\\n'", "DS1TRBAL": "b'\\x0f\\x8a'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x01\\xca\\x00\\x04\\x01\\xce\\x00\\x08\\x00A'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$$COPY": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x96\\x03?\\x00\\x96\\x03?\\x109\\x00\\x06\\x00\\x06\\x00\\x00\\xe2\\xc1\\xe2\\xc4\\xc4\\xc6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-02-02T00:00:00", "modifydate": "1996-02-02T10:39:00", "lines": 6, "newlines": 6, "modlines": 0, "user": "SASDDF"}, "text": "Copyright (c) 1996, SAS Institute Inc., Cary, NC, USA.\n\nTHE WIN3270 CODED AND RELATED FILES CONTAINED HEREIN ARE PROVIDED \"AS\nIS\" WITHOUT WARRANTY OF ANY KIND.  Recipient agrees that the Institute\nshall not be liable for any damage whatsoever arising out of the use of\nsuch code.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$$$READ": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x955?\\x00\\x96\\x03?\\x10E\\x00e\\x00\\x03\\x00\\x00\\xe2\\xc1\\xe2\\xc4\\xc4\\xc6@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1995-12-19T00:00:00", "modifydate": "1996-02-02T10:45:00", "lines": 101, "newlines": 3, "modlines": 0, "user": "SASDDF"}, "text": " 3270 Tools PDS release 1 - December 1995\n==========================================\n\nDisclaimer\n----------\n\n\nCopyright (c) 1996, SAS Institute Inc., Cary, NC, USA.\nAll Rights Reserved.\n\nTHE WIN3270 CODE AND ASSOCIATED FILES WITHIN THE SAME PDS, AND THE\nLOAD MODULES BUILT FROM THAT CODE ARE PROVIDED BY THE INSTITUTE \"AS\nIS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING\nBUT NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS FOR A PARTICULAR PURPOSE.  RECIPIENTS ACKNOWLEDGE AND AGREE\nTHAT THE INSTITUTE SHALL NOT BE LIABLE WHATSOEVER FOR ANY DAMAGES\nARISING OUT OF THEIR USE OF THIS MATERIAL OR CODE. IN ADDITION, SAS\nINSTITUTE WILL PROVIDE NO SUPPORT FOR THE CODE OR OTHER MATERIALS\nCONTAINED HEREIN.\n\n                      RESTRICTED RIGHTS LEGEND\n\nUse, duplication, or disclosure by the U.S. Government is subject to\nrestrictions as set forth in subparagraph (c)(1)(ii) of the Rights in\nTechnical Data and Computer Software clause at DFARS 252.227-7013.\n\nSAS INSTITUTE INC., SAS CAMPUS DRIVE, CARY, NORTH CAROLINA USA 27513\n\n\nContact\n-------\n\nHowever, the author (David Fahey) may be contacted with\nquestions related to these programs. I may be contacted\nat the following address:\n\n   David Fahey\n   MVS Host R&D\n   SAS Institute\n   1 Campus Drive\n   Cary NC 27513\n\n   (919) 677-8000 ext 6833\n\n   sasddf@kiwi.unx.sas.com\n   75764.2543@compuserve.com\n\nFuture modifications and bug fixes may be provided in subsequent\nreleases of this file. I hope to add some vector graphic support\nto the WIN3270 program in the future if time permits.\n\nPlease send me any modifications that you make, or suggestions\nif you find this material usefull. I am always willing to hear\nfrom the die hard 3270 users of the world.\n\nInstall\n-------\n\nThere is no special requirements to install these programs.\nAll of the load modules can be executed by the TSO call\ncommand. The clists will require the dataset names to be\nchanged to names that you have used.\n\nCompilation of the source requires the SAS/C compiler. The\nversion 5.50 of the compiler is required to support the\nWIN3270 program with the REXX language. The CCOMP clist\nwas used to compile these programs. Notice that it\nspecifies a DDname for the included font H files, which\nyou would need to add to any batch compilation that you\nmay prefer to use.\n\nAssembly of the BAL code can be done with JCL that is like\nthe following:\n\n//ASM     EXEC PGM=IEV90,REGION=1024K,\n//             PARM='TERM,NODECK,OBJECT,NORENT,XREF(SHORT)'\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//         DD  DISP=SHR,DSN=SDC.C550C.MACLIBA        <=== VERIFY\n//SYSUT1   DD  SPACE=(CYL,(5,1)),UNIT=SYSDA\n//SYSTERM  DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=*\n//SYSPUNCH DD  DUMMY\n//SYSLIN   DD  DSN=&&OBJSET,UNIT=SYSDA,SPACE=(80,(200,50)),\n//             DISP=(MOD,PASS)\n//SYSIN    DD  DISP=SHR,DSN=SASDDF.A.SOURCE(TGETN)       <=== VERIFY\n//LKED     EXEC PGM=HEWLF064,PARM='XREF,LET,LIST,NCAL',\n//             COND=(6,LT,ASM),REGION=1024K\n//SYSLIN   DD   DSN=&&OBJSET,DISP=(OLD,DELETE)\n//         DD   DDNAME=SYSIN\n//SYSLIB   DD   DSN=SYS1.LINKLIB,DISP=SHR\n//SYSLMOD  DD   DISP=SHR,DSN=SASDDF.A.LOADLIB       <=== VERIFY\n//SYSUT1   DD   DSN=&&SYSUT1,UNIT=SYSDA,SPACE=(1024,(50,20))\n//SYSPRINT DD   SYSOUT=*\n//SYSIN    DD   *\n     MODE AMODE(ANY),RMODE(24)\n     NAME TGETN(R)\n/*\n\nIf you change the fonts you will have to firstly use\nthe font clist then recompile the C programs to include the\nH file with the new symbol set definition.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$$INDEX": {"ttr": 521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x955?\\x00\\x96\\x06\\x7f\\x17X\\x00\\xbb\\x00^\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1995-12-19T00:00:00", "modifydate": "1996-03-07T17:58:00", "lines": 187, "newlines": 94, "modlines": 0, "user": "SBGCSC"}, "text": "//***FILE 258 IS FROM DAVID FAHEY OF THE SAS INSTITUTE AND CONTAINS *   FILE 258\n//*           CLISTS, TEXT DOCUMENTATION, C AND ASM SOURCE. THESE   *   FILE 258\n//*           ARE ALL 3270 DEVICE TOOLS AND EXAMPLES. THEY EXPLOIT  *   FILE 258\n//*           MOST OF THE FUNCTIONALITY OF THE 3270 AND INCLUDE     *   FILE 258\n//*           CODE FOR LOADING PROGRAMMED SYMBOL SETS, AND A TSO    *   FILE 258\n//*           SUB-COMMAND ENVIRONMENT THAT ALLOWS YOU TO DO FULL    *   FILE 258\n//*           SCREEN WIDGET ORIENTED CLIST OR REXX PROGRAMMING.     *   FILE 258\n//*                                                                 *   FILE 258\n//*           THE FOLLOWING MEMBERS ARE IN THIS PDS, ALL DOC        *   FILE 258\n//*           MEMBERS ARE PRECEDED BY $, ALL CLISTS ARE PRECEDED    *   FILE 258\n//*           BY @, AND OTHER MEMBER NAMES ARE EITHER C OR ASM      *   FILE 258\n//*           SOURCE CODE.                                          *   FILE 258\n//*                                                                 *   FILE 258\n//*           $$$$NOTE  -  A DISCLAIMER REGARDING THE               *   FILE 258\n//*                        SUPPORT FOR THIS MATERIAL.               *   FILE 258\n//*                                                                 *   FILE 258\n//*           $$$INDEX  -  THIS MEMBER.                             *   FILE 258\n//*                                                                 *   FILE 258\n//*           $$DOC     -  DOCUMENTATION FOR WIN3270, A TSO FULL    *   FILE 258\n//*                        SCREEN DIALOG CONSTRUCTION TOOL. THIS    *   FILE 258\n//*                        TOOL ALLOWS CREATION OF FULL SCREEN      *   FILE 258\n//*                        INTERACTIVE DIALOGS, THAT USE WIDGETS    *   FILE 258\n//*                        AND SUPPORT TSO AND REXX LANGUAGE        *   FILE 258\n//*                        VARIABLES.                               *   FILE 258\n//*                                                                 *   FILE 258\n//*           @CCOMP    -  A CLIST USED TO COMPILE THE C LANGUAGE   *   FILE 258\n//*                        PROGRAMS. THE COMPILER USED IS THE SAS   *   FILE 258\n//*                        C COMPILER.                              *   FILE 258\n//*                                                                 *   FILE 258\n//*           @DD3270   -  A CLIST TO START THE DD3270 MODULE       *   FILE 258\n//*                        WHICH DISPLAYS A TEST WINDOW ON A 3270   *   FILE 258\n//*                                                                 *   FILE 258\n//*           @FONTGEN  -  A CLIST USED TO READ A FONT              *   FILE 258\n//*                        SPECIFICATION FILE AND CREATE AN H FILE  *   FILE 258\n//*                        DEFINITION OF A 3270 SYMBOL SET.         *   FILE 258\n//*                                                                 *   FILE 258\n//*           @INFO32P  -  A CLIST USED TO PRINT 3270 DEVICE        *   FILE 258\n//*                        ATTRIBUTE INFORMATION.                   *   FILE 258\n//*                                                                 *   FILE 258\n//*           @INFO327  -  A CLIST USED TO DISPLAY 3270 DEVICE      *   FILE 258\n//*                        ATTRIBUTE INFORMATION ON THE TERMINAL.   *   FILE 258\n//*                                                                 *   FILE 258\n//*           @LISTCAT  -  A CLIST THAT DISPLAYS THE USERS CATALOG. *   FILE 258\n//*                        THIS IS AN EXAMPLE OF THE WIN3270        *   FILE 258\n//*                        TSO SUB-COMMAND ENVIRONMENT TOOL.        *   FILE 258\n//*                                                                 *   FILE 258\n//*           @LOGON    -  A CLIST THAT DISPLAYS A FULL SCREEN      *   FILE 258\n//*                        WINDOW IN A LOGON CLIST AS A GREETING.   *   FILE 258\n//*                        THIS IS AN EXAMPLE OF THE WIN3270        *   FILE 258\n//*                        TSO SUB-COMMAND ENVIRONMENT TOOL.        *   FILE 258\n//*                                                                 *   FILE 258\n//*           @TERMST   -  A CLIST THAT DISPLAYS TERMINAL STATUS    *   FILE 258\n//*                        INFORMATION ON THE TERMINAL. LESS        *   FILE 258\n//*                        INFO IS PROVIDED THAN INFO327.           *   FILE 258\n//*                        THIS IS AN EXAMPLE OF THE WIN3270        *   FILE 258\n//*                        TSO SUB-COMMAND ENVIRONMENT TOOL.        *   FILE 258\n//*                                                                 *   FILE 258\n//*           @TEST327  -  A CLIST THAT DISPLAYS THE TERMINALS      *   FILE 258\n//*                        CHARACTER SETS, AND ALLOWS SELECTION     *   FILE 258\n//*                        OF STANDARD, APL, OR THE LOADED PS       *   FILE 258\n//*                        CHARACTER SET.                           *   FILE 258\n//*                        THIS IS AN EXAMPLE OF THE WIN3270        *   FILE 258\n//*                        TSO SUB-COMMAND ENVIRONMENT TOOL.        *   FILE 258\n//*                                                                 *   FILE 258\n//*           @TREXX    -  A REXX THAT STARTS THE WIN3270 ENVIRON.  *   FILE 258\n//*                                                                 *   FILE 258\n//*           @TREXX2   -  A REXX THAT USES THE WIN3270 ENVIRON.    *   FILE 258\n//*                                                                 *   FILE 258\n//*           @T32A     -  A TEST CLIST THAT ALLOWS A PS FONT TO    *   FILE 258\n//*                        BE TYPED INTO A FIELD.                   *   FILE 258\n//*                        THIS IS AN EXAMPLE OF THE WIN3270        *   FILE 258\n//*                        TSO SUB-COMMAND ENVIRONMENT TOOL.        *   FILE 258\n//*                                                                 *   FILE 258\n//*           @WIDGET   -  A CLIST THAT CALLS THE WIDGET32 PROGRAM  *   FILE 258\n//*                        TO DISPLAY A WINDOW CONTAINING WIDGETS   *   FILE 258\n//*                        ON THE 3270. THE PROGRAM IS SIMPLY AN    *   FILE 258\n//*                        ILLUSTRATION OF THE LOOK OF CERTAIN      *   FILE 258\n//*                        WIDGETS.                                 *   FILE 258\n//*                                                                 *   FILE 258\n//*           @WIN327A  -  A CLIST THAT ILLUSTRATES SOME FEEDBACK   *   FILE 258\n//*                        VARIABLES PROVIDED BY THE WIN3270        *   FILE 258\n//*                        TSO SUB-COMMAND ENVIRONMENT.             *   FILE 258\n//*                                                                 *   FILE 258\n//*           @WIN327D  -  A EXAMPLE (DUMB) CLIST APPLICATION THAT  *   FILE 258\n//*                        SHOWS HOW TO BUILD A WIN3270 TSO         *   FILE 258\n//*                        SUB-COMMAND ENVIRONMENT APPLICATION.     *   FILE 258\n//*                        THIS CLIST HAS LOYS OF COMMENTS.         *   FILE 258\n//*                                                                 *   FILE 258\n//*           @WIN327T  -  ANOTHER EXAMPLE SIMILAR TO WIN3270D      *   FILE 258\n//*                                                                 *   FILE 258\n//*           @XHELP    -  A CLIST THAT TURNS THE STANDARD SYSTEM   *   FILE 258\n//*                        HELP INTO A FULL SCREEN CONTEXT          *   FILE 258\n//*                        SENSITIVE HELP.                          *   FILE 258\n//*                        THIS IS AN EXAMPLE OF THE WIN3270        *   FILE 258\n//*                        TSO SUB-COMMAND ENVIRONMENT TOOL.        *   FILE 258\n//*                                                                 *   FILE 258\n//*           COMBO32   -  C PROGRAM THAT DISPLAYS A DEMO OF A      *   FILE 258\n//*                        COMBO BOX ON A 3270 DEVICE               *   FILE 258\n//*                                                                 *   FILE 258\n//*           DD3270    -  C PROGRAM THAT DISPLAYS A DEMO OF A      *   FILE 258\n//*                        WINDOW ON A 3270 DEVICE. THIS PROGRAM    *   FILE 258\n//*                        COULD EASILY BE EXTENDED TO DO OTHER     *   FILE 258\n//*                        THINGS THAT COULD USE THE FULL SCREEN    *   FILE 258\n//*                        ROUTINES.                                *   FILE 258\n//*                                                                 *   FILE 258\n//*           FONT      -  C PROGRAM THAT CONVERTS A FONT           *   FILE 258\n//*                        SPECIFICATION FILE (SYM..... SEE BELOW)  *   FILE 258\n//*                        INTO AN H FILE (INCLUDED WHEN COMPILING  *   FILE 258\n//*                        MANY OF THE OTHER PROGRAMS HERE).        *   FILE 258\n//*                                                                 *   FILE 258\n//*           INFO3270  -  C PROGRAM THAT DISPLAYS A 3270 DEVICES   *   FILE 258\n//*                        ATTRIBUTES ON THE STANDARD OUT FILE.     *   FILE 258\n//*                                                                 *   FILE 258\n//*           LSTBOX32  -  C PROGRAM THAT DISPLAYS A DEMO OF A      *   FILE 258\n//*                        LIST BOX ON A 3270 DEVICE.               *   FILE 258\n//*                                                                 *   FILE 258\n//*           PS9X12U   -  H FILE CONTAINING PROGRAM SYMBOL SET FOR *   FILE 258\n//*                        A 9 BY 12 BIT CHARACTER THAT HAS         *   FILE 258\n//*                        UNDERLINE AND OVERLINE, PLUS SOME        *   FILE 258\n//*                        SPECIAL DRAWING CHARACTERS.              *   FILE 258\n//*                        THIS MEMBER IS MACHINE GENERATED BY THE  *   FILE 258\n//*                        FONT PROGRAM ABOVE.                      *   FILE 258\n//*                                                                 *   FILE 258\n//*           PS9X15U   -  H FILE CONTAINING PROGRAM SYMBOL SET FOR *   FILE 258\n//*                        A 9 BY 15 BIT CHARACTER THAT HAS         *   FILE 258\n//*                        UNDERLINE AND OVERLINE, PLUS SOME        *   FILE 258\n//*                        SPECIAL DRAWING CHARACTERS.              *   FILE 258\n//*                        THIS MEMBER IS MACHINE GENERATED BY THE  *   FILE 258\n//*                        FONT PROGRAM ABOVE.                      *   FILE 258\n//*                                                                 *   FILE 258\n//*           PS9X16U   -  H FILE CONTAINING PROGRAM SYMBOL SET FOR *   FILE 258\n//*                        A 9 BY 16 BIT CHARACTER THAT HAS         *   FILE 258\n//*                        UNDERLINE AND OVERLINE, PLUS SOME        *   FILE 258\n//*                        SPECIAL DRAWING CHARACTERS.              *   FILE 258\n//*                        THIS MEMBER IS MACHINE GENERATED BY THE  *   FILE 258\n//*                        FONT PROGRAM ABOVE.                      *   FILE 258\n//*                                                                 *   FILE 258\n//*           SYM9X12U  -  FONT SPECIFICATION FILE FOR              *   FILE 258\n//*                        A 9 BY 12 BIT CHARACTER THAT HAS         *   FILE 258\n//*                        UNDERLINE AND OVERLINE, PLUS SOME        *   FILE 258\n//*                        SPECIAL DRAWING CHARACTERS.              *   FILE 258\n//*                        THIS MEMBER IS READ BY THE FONT PROGRAM  *   FILE 258\n//*                        (SEE ABOVE).                             *   FILE 258\n//*                                                                 *   FILE 258\n//*           SYM9X15U  -  FONT SPECIFICATION FILE FOR              *   FILE 258\n//*                        A 9 BY 15 BIT CHARACTER THAT HAS         *   FILE 258\n//*                        UNDERLINE AND OVERLINE, PLUS SOME        *   FILE 258\n//*                        SPECIAL DRAWING CHARACTERS.              *   FILE 258\n//*                        THIS MEMBER IS READ BY THE FONT PROGRAM  *   FILE 258\n//*                        (SEE ABOVE).                             *   FILE 258\n//*                                                                 *   FILE 258\n//*           SYM9X16U  -  FONT SPECIFICATION FILE FOR              *   FILE 258\n//*                        A 9 BY 16 BIT CHARACTER THAT HAS         *   FILE 258\n//*                        UNDERLINE AND OVERLINE, PLUS SOME        *   FILE 258\n//*                        SPECIAL DRAWING CHARACTERS.              *   FILE 258\n//*                        THIS MEMBER IS READ BY THE FONT PROGRAM  *   FILE 258\n//*                        (SEE ABOVE).                             *   FILE 258\n//*                                                                 *   FILE 258\n//*           TG        -  ASM TEST PROGRAM THAT DISPLAYS SEVERAL   *   FILE 258\n//*                        GRAPHIC ITEMS ON A VECTOR GRAPHIC        *   FILE 258\n//*                        DEVICE. DO NOT USE ON OTHER DEVICE TYPES *   FILE 258\n//*                        IT WILL CAUSE ERRORS.                    *   FILE 258\n//*                                                                 *   FILE 258\n//*           TGETN     -  ASM TGET ROUTINE CALLED BY OTHER         *   FILE 258\n//*                        C LANGUAGE PROGRAMS.                     *   FILE 258\n//*                                                                 *   FILE 258\n//*           TGT327D   -  ASM GTTERM ROUTINE CALLED BY OTHER       *   FILE 258\n//*                        C LANGUAGE PROGRAMS.                     *   FILE 258\n//*                                                                 *   FILE 258\n//*           TPGN      -  ASM TPG ROUTINE CALLED BY OTHER          *   FILE 258\n//*                        C LANGUAGE PROGRAMS.                     *   FILE 258\n//*                                                                 *   FILE 258\n//*           TPUTN     -  ASM TPUT ROUTINE CALLED BY OTHER         *   FILE 258\n//*                        C LANGUAGE PROGRAMS.                     *   FILE 258\n//*                                                                 *   FILE 258\n//*           TXTPAD32  -  C PROGRAM THAT DISPLAYS A DEMO OF A      *   FILE 258\n//*                        TEXT PAD ON A 3270 DEVICE.               *   FILE 258\n//*                                                                 *   FILE 258\n//*           WIDGET32  -  C PROGRAM THAT DISPLAYS A DEMO OF        *   FILE 258\n//*                        SEVERAL DIFFERENT WIDGETS ON A           *   FILE 258\n//*                        3270 DEVICE.                             *   FILE 258\n//*                                                                 *   FILE 258\n//*           WIN3270   -  C PROGRAM THAT ESTABLISHES A TSO SUB-    *   FILE 258\n//*                        COMMAND ENVIRONMENT AND PROCESSES        *   FILE 258\n//*                        WINDOW DEFINITION AND DISPLAY            *   FILE 258\n//*                        SUB-COMMANDS.                            *   FILE 258\n//*                                                                 *   FILE 258\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$IXF02": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x955?\\x00\\x96\\x04O F\\x00D\\x00\\xba\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1995-12-19T00:00:00", "modifydate": "1996-02-13T20:46:00", "lines": 68, "newlines": 186, "modlines": 0, "user": "SBGCSC"}, "text": "//***FILE 258 IS FROM DAVID FAHEY OF THE SAS INSTITUTE AND CONTAINS *   FILE 258\n//*           SOURCE CODE FOR THE LOAD MODULES WHICH ARE IN FILE    *   FILE 258\n//*           259.  THIS SOURCE CODE IS WRITTEN IN SAS/C, AND       *   FILE 258\n//*           VERSION 5.50 OR LATER OF THE SAS/C COMPILER IS        *   FILE 258\n//*           NEEDED IF YOU WANT TO COMPILE OR MAKE MODIFICATIONS.  *   FILE 258\n//*           MY IMPRESSION IS THAT YOU DON'T NEED THE SAS/C        *   FILE 258\n//*           RUNTIME LIBRARY TO RUN THE LOAD MODULES.              *   FILE 258\n//*                                                                 *   FILE 258\n//*           THIS IS A COLLECTION OF 3270 DEVICE TOOLS THAT YOU    *   FILE 258\n//*           CAN USE FOR CREATING 3270 APPLICATIONS.  THEY ARE     *   FILE 258\n//*           A GOOD MODEL SO YOU CAN SEE WHAT CAN BE DONE IN       *   FILE 258\n//*           THIS AREA.                                            *   FILE 258\n//*                                                                 *   FILE 258\n//***FILE 259 IS FROM DAVID FAHEY OF THE SAS INSTITUTE AND CONTAINS *   FILE 259\n//*           LOAD MODULES WHICH ARE ALL 3270 DEVICE TOOLS AND      *   FILE 259\n//*           EXAMPLES.                                             *   FILE 259\n//*                                                                 *   FILE 259\n//*           THE FOLLOWING LOAD MODULES ARE IN THIS PDS:           *   FILE 259\n//*                                                                 *   FILE 259\n//*           COMBO32   -  PROGRAM THAT DISPLAYS A DEMO OF A        *   FILE 259\n//*                        COMBO BOX ON A 3270 DEVICE               *   FILE 259\n//*                                                                 *   FILE 259\n//*           DD3270    -  PROGRAM THAT DISPLAYS A DEMO OF A        *   FILE 259\n//*                        WINDOW ON A 3270 DEVICE. THIS PROGRAM    *   FILE 259\n//*                        COULD EASILY BE EXTENDED TO DO OTHER     *   FILE 259\n//*                        THINGS THAT COULD USE THE FULL SCREEN    *   FILE 259\n//*                        ROUTINES.                                *   FILE 259\n//*                                                                 *   FILE 259\n//*           FONT      -  PROGRAM THAT CONVERTS A FONT             *   FILE 259\n//*                        SPECIFICATION FILE (SYM..... SEE BELOW)  *   FILE 259\n//*                        INTO AN H FILE (INCLUDED WHEN COMPILING  *   FILE 259\n//*                        MANY OF THE OTHER PROGRAMS HERE).        *   FILE 259\n//*                                                                 *   FILE 259\n//*           INFO3270  -  PROGRAM THAT DISPLAYS A 3270 DEVICES     *   FILE 259\n//*                        ATTRIBUTES ON THE STANDARD OUT FILE.     *   FILE 259\n//*                                                                 *   FILE 259\n//*           LSTBOX32  -  PROGRAM THAT DISPLAYS A DEMO OF A        *   FILE 259\n//*                        LIST BOX ON A 3270 DEVICE.               *   FILE 259\n//*                                                                 *   FILE 259\n//*           TG        -  TEST PROGRAM THAT DISPLAYS SEVERAL       *   FILE 259\n//*                        GRAPHIC ITEMS ON A VECTOR GRAPHIC        *   FILE 259\n//*                        DEVICE. DO NOT USE ON OTHER DEVICE TYPES *   FILE 259\n//*                        IT WILL CAUSE ERRORS.                    *   FILE 259\n//*                                                                 *   FILE 259\n//*           TGETN     -  TGET ROUTINE CALLED BY OTHER             *   FILE 259\n//*                        C LANGUAGE PROGRAMS.                     *   FILE 259\n//*                                                                 *   FILE 259\n//*           TGT327D   -  GTTERM ROUTINE CALLED BY OTHER           *   FILE 259\n//*                        C LANGUAGE PROGRAMS.                     *   FILE 259\n//*                                                                 *   FILE 259\n//*           TPGN      -  TPG ROUTINE CALLED BY OTHER              *   FILE 259\n//*                        C LANGUAGE PROGRAMS.                     *   FILE 259\n//*                                                                 *   FILE 259\n//*           TPUTN     -  TPUT ROUTINE CALLED BY OTHER             *   FILE 259\n//*                        C LANGUAGE PROGRAMS.                     *   FILE 259\n//*                                                                 *   FILE 259\n//*           TXTPAD32  -  PROGRAM THAT DISPLAYS A DEMO OF A        *   FILE 259\n//*                        TEXT PAD ON A 3270 DEVICE.               *   FILE 259\n//*                                                                 *   FILE 259\n//*           WIDGET32  -  PROGRAM THAT DISPLAYS A DEMO OF          *   FILE 259\n//*                        SEVERAL DIFFERENT WIDGETS ON A           *   FILE 259\n//*                        3270 DEVICE.                             *   FILE 259\n//*                                                                 *   FILE 259\n//*           WIN3270   -  PROGRAM THAT ESTABLISHES A TSO SUB-      *   FILE 259\n//*                        COMMAND ENVIRONMENT AND PROCESSES        *   FILE 259\n//*                        WINDOW DEFINITION AND DISPLAY            *   FILE 259\n//*                        SUB-COMMANDS.                            *   FILE 259\n//*                                                                 *   FILE 259\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$DOC": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x955?\\x00\\x955?\\x13@\\x01\\xd4\\x01\\xbe\\x00\\x00\\xe2\\xc1\\xe2\\xc4\\xc4\\xc6@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1995-12-19T00:00:00", "modifydate": "1995-12-19T13:40:00", "lines": 468, "newlines": 446, "modlines": 0, "user": "SASDDF"}, "text": "WIN3270 - TSO 3270 full screen dialog construction tool\n=======================================================\n\n\nOverview of WIN3270\n-------------------\n\nThe WIN3270 environment is allows users of the TSO Clist language\nor TSO REXX language facilities to create full screen\napplications on the 3270 display station.  Six types of widgets\nare supported, and any displayed text can be treated s HOT or\nselectable allowing context sensitive text dialogs to be created.\nThe widgets supported are LABEL, INPUT, OUTPUT, BUTTON, RADIO,\nand CECKBOX. The following window shows the style of widgets that\ncan be created:\n\n                (picture not shown)\n\n\nThis simple tool set for the 3270 should allow powerfull\napplications to be created with the CLIST language or REXX\nlanguage on TSO.\n\nIt is not the intention that this code should remove the need for\nsimilar ISPF code. ISPF is much more powerfull and feature rich\ncompared to the WIN3270 subcommand environment. Though these\nfunctions can be used with those of ISPF, or before ISPF is\nstarted. The WIN3270 tools may a simpler way to create a dialog\nin some instances.\n\nThe WIN3270 environmant has benn created as a training exercise\nto allow the author to become more familiar with 3270 data stream\nprogramming and C language programming. And so its future is\nundetermined. The code is being enhanced as time permits,\ntherefore it would be wise to copy the load module if you want to\nuse it and ensure repeatability of opperation.\n\n\n\nRunning the WIN3270 subcommand environment.\n-------------------------------------------\n\nRunning WIN3270 from a clist\n----------------------------\n\nFrom a clist program use the following command to start the\nenvironment. Once this has executed WIN3270 subcommands will be\ninterpreted.\n\nCALL 'SASDDF.A.LOADLIB(WIN3270)'\n\nThis program can not be called directly from the TSO READY\nprompt. However, if the clist program fails during execution and\nthe subcommand environment is stil active a line command prompt\nwill be displayed like \"WIN3270:\". If this appears simply type\nthe WX subcommand to terminate the WIN3270 environment.\n\nIf there are problems with starting WIN3270 or with subsequent\nsubcommands then the following parameter will provide a lot of\ninformation that may help solve the problem.  For more\ninformation see the ML subcommand below. If an error\n\nCALL 'SASDDF.A.LOADLIB(WIN3270)' '-ML 9'\n\nFor example the TSO clist:\n\nPROC 0\nCONTROL NOCAPS\nCALL 'SASDDF.A.LOADLIB(WIN3270)'    /* start environment */\n/* create attributes */\nWA value=\\ type=label color=cyan hilite=none\nWA value=# type=label color=red hilite=none\nWA value=! type=label color=blue hilite=reverse\nWA value=_ type=output color=yellow hilite=none\n/* name the window */\nWC name=main\n/* define the window layout */\nWS 08 !                                                          \\\nWS 09 ! \\                                                      ! \\\nWS 10 ! \\  This is a very simple test box.   User:_SYSUID      ! \\\nWS 11 ! \\                                                      ! \\\nWS 12 ! \\  Second and last line of the test. #Use PF3 to end   ! \\\nWS 13 ! \\                                                      ! \\\nWS 14 !                                                          \\\nDO WHILE(&STR(&WINSYSK)\u00ac=&STR(PF3))\n  /* display the window until PF3 is pressed */\n  WD name=main row=1 col=1\nEND\n/* tidy up, stop win3270, and exit */\nWE name=main\nWX\nEXIT\n\nThe clist above shows how simple it is to display this message box.\n\n            (picture not shown)\n\n\nRunning WIN3270 from a REXX exec\n--------------------------------\n\nTo do a similar thing using the TSO REXX language requires a\nslightly different approach. You must have two REXX execs in your\nSYSPROC library. The first one establishes the WIN3270\nenvironment and specifies the name of the second exec.  For\nexample:\n\n/* REXX */\n\"CALL 'SASDDF.A.LOADLIB(WIN3270)' '-REXX TREXX2'\"\nexit\n\nThe second REXX exec (called TREXX2) can then issue WIN3270\nsubcommands after first addressing the WIN3270 environment using\nthe ADDRESS statement. For example:\n\n\n/* REXX */\naddress WIN3270\n/* define attributes */\n\"WA value=\\ type=label color=cyan hilite=none\"\n\"WA value=# type=label color=red hilite=none\"\n\"WA value=! type=label color=blue hilite=reverse\"\n\"WA value=_ type=output color=yellow hilite=none\"\nusr = sysvar(SYSUID)\n/* define window */\n\"WC name=main\"\n\"WS 08 !                                            \\\"\n\"WS 09 ! \\                                        ! \\\"\n\"WS 10 ! \\ This is a very simple test box.        ! \\\"\n\"WS 11 ! \\ User:_USR                              ! \\\"\n\"WS 12 ! \\ Second and last line of the test.      ! \\\"\n\"WS 13 ! # Use PF3 to end                         ! \\\"\n\"WS 14 ! \\                                        ! \\\"\n\"WS 15 !                                            \\\"\n/* display window */\ndo until(winsysk = 'PF3')\n  \"WD name=main\"\nend\n/* clean up */\n\"WE name=main\"\n\"WX\"\n\n\n\nWIN3270 environment feedback variables.\n---------------------------------------\n\nThe following TSO variables are set after the WIN3270 subcommand\nenvironment has been established. These variables provide\nfeedback about the 3270 device that the clist application may\nneed before it uses the WIN3270 subcommands:\n\n   WINSYSDC = Display colors list.\n   WINSYSNR = Number of display lines (rows).\n   WINSYSNC = Number of display columns.\n   WINSYSAP = APL support either Y or N.\n   WINSYSGR = Vector graphic support either Y or N.\n   WINSYSPS = Programmed symbols either Y or N.\n   WINSYSDH = Display hilights list.\n\nFor example win3270a command displays a screen that shows the\nbuilt in WIN3270 feedback variables.\n\n\nWIN3270 sub-commands.\n---------------------\n\nThe following is a list of WIN3270 subcommands and their operands:\n\n   WA subcommand - set field attributes used by all windows.\n\n      value= Single character used to define field\n      start. Value is required.\n\n      type= Type of the widget. Default type is LABEL. Type can\n      be one of:  LABEL, INPUT, OUTPUT, BUTTON, RADIO or\n      CHECKBOX.\n\n         type=label is used for a protected text label field. The\n         value= character is replaced by an attribute character.\n         The text for the field will follow the value= char.\n\n         type=output is used for a protected text field. The\n         value= character is replaced by an attribute character.\n         The name of the CLIST variable will follow the value=\n         character. The variable contents will be displayed in\n         the field after the window has been displayed.\n\n         type=input is used for an unprotected input field. The\n         value= character is replaced by an attribute character.\n         The name of the CLIST variable will follow the value=\n         character. The variable contents will be displayed in\n         the field as the window is displayed, and the variable\n         will receive the contents of the field after the window\n         has been displayed.\n\n         type=button is used for an unprotected input field, that\n         has a button border to it. The name of the CLIST\n         variable will follow the value= character. The variable\n         will be set to X if the cursor is on the field when the\n         window has been displayed.  Otherwise the variable will\n         be set to blank.\n\n         type=radio is used for an unprotected input field, that\n         has small button indicator on the left of it.  The name\n         of the CLIST variable will follow the value= character\n         of the first radio button field. The variable name is\n         the first word of the text and is not displayed. (see\n         below) The variable will contain the second word if this\n         station is the selected radio box station.  Otherwise\n         the variable will be set to blank. The x and o in the\n         following diagram will be replaced with PS symbols on\n         devices that support these, otherwise the O and star(*)\n         characters will be used.\n\n                This:\n                WS 02   @A1 Red apples\n                WS 03   @A1 Green apples\n                WS 04   @A1 Yellow apples\n                WS 05\n                WS 06   @A2 Orange oranges\n                WS 07   @A2 Blue oranges - yuck\n\n                Will generate:\n                        .O.Red apples\n                        .*.Green apples\n                        .O.Yellow apples\n\n                        .O.Orange oranges\n                        .*.Blue oranges - yuck\n\n\n         Here variable names are A1 and A2.  The variable A1 will\n         contain \"Green\" and the variable A2 will contain \"Blue\".\n         You will note that the first 3 and the last two fields\n         are respectively linked to their own variables, whose\n         name is the first word in the field definition. Only one\n         of the linked fields can be on (displaying a *), if the\n         variable is set to an invalid value then the value will\n         be replaced by the name of the first field.\n\n         type=checkbox is used for an unprotected input field,\n         that has a small box indicator on the left of it. The\n         name of the CLIST variable will follow the value=\n         character.\n\n         The variable name and displayed text are the same until\n         the first blank character. (see below) The variable will\n         be set to contain \"X\" if the cursor is on the field when\n         the window has been displayed.  Otherwise the variable\n         will be set to blank. The X and _ in the following\n         diagram will be replaced with PS symbols on devices that\n         support these, otherwise the X and underscore(_)\n         characters will be used.\n\n                This:\n                WS 02   #Bird feathers\n                WS 03   #Dog hair\n                WS 04   #Cat fur\n                WS 05   #Fish scales\n\n                Will generate:\n                        .X.Bird feathers\n                        ._.Dog hair\n                        .X.Cat fur\n                        ._.Fish scales\n\n\n         Here variable names are BIRD, DOG, CAT and FISH.\n         Variable BIRD will contain \"X\", variable DOG will\n         contain blank, variable CAT will contain \"X\", and\n         variable FISH will contain blank.\n\n      color= The color name used for the widget. Color can be one\n      of: RED, BLUE, GREEN, WHITE, PINK, YELLOW, CYAN, NONE, or\n      BLACK. The default is GREEN.\n\n      hilite= The hilight to use for some widgets. Hilite can be\n      one of: NONE, REVERSE, ULINE, BLINK. The default is NONE.\n      Not all widget types support hilites.\n\n      symbol= Symbol set to use. Can be one of: NONE, APL, PS.\n      The default is NONE. Not all widget types support APL or\n      PS, and not all devices will display these symbol sets.\n\n      The PS symbol set is comprised of the standard english\n      alphabet and some special drawing characters. All of the\n      alpha numeric and some symbols characters have a fixed\n      underline and overline. Not all device cell sizes are\n      supported for PS. An example of the PS font definition is\n      in sym9x16u.sym This results in a symbol set that looks\n      like:\n\n            (picture not shown)\n\n\n      just= The justification to use. Can be either of: NONE,\n      LEFT, CENTER, RIGHT. The default is NONE. Not all widget\n      types support justification.\n\n      NOTE: Just is not implemented yet.\n\n   WE subcommand - erase named window.\n\n      name= The name of the window to erase.  This is required.\n      If name= is not specified LASTCC will be set to 4 and a\n      window will not be deleted. If name already exists and is\n      deleted LASTCC will be 0 and if the window was the\n      currently active window there will no longer be a currently\n      active window.\n\n   WC subcommand - create named window.\n\n      name= The name of the window to create. This is required.\n      If name= is not specified LASTCC will be set to 4 and a\n      window will not be created. If name already exists LASTCC\n      will be set to 8, and the currently active window will not\n      be changed, and no new window will be defined.\n\n      WC must be followed by at least one WS sub command.\n\n   WS subcommand - define row on currently named window.\n      nn NN defines the row to define.  Characters following the\n      single blank following NN are assumed to be part of the\n      window for row NN of the window named by the last WC sub\n      command. This parameter is required.  If nn is larger than\n      the screen will allow the LASTCC will be set to 4 and the\n      row will not be defined. If nn is not a valid integer\n      greater than 0 LASTCC will be set to 8 and the row will not\n      be defined. If nn has already been defined then LASTCC will\n      be set to 12 and the row will not be defined. WS must be\n      preceeded by one WC sub command.\n\n      Warning Do not use characters that the CLIST language\n      processor likes to eat, as attribute characters. Such\n      errors are hard to find. In particular avoid plus,minus,\n      ampersand, and colon.\n\n   WD subcommand - display the named window.\n\n      name= Name of an existing window to display. If the window\n      named by name= does not exist the LASTCC will be set to 4\n      and the window will not be displayed. This parameter is\n      required.\n\n      row=nn Row position of top left window corner. The default\n      for nn is 1. If row= is not a valid number LASTCC is set to\n      8. If the number is too large for the window to the LASTCC\n      is set to 12 and the window is not displayed.\n\n      col=nn Column position of top left window corner. The\n      default for nn is 1.  If col= is not a valid number LASTCC\n      is set to 8. If the number is too large for the window to\n      the LASTCC is set to 12 and the window is not displayed.\n\n      input=Y Flag indicating if input will be accepted from the\n      window. The default is \"Y\", meaning input will be accepted.\n      Alternatively \"N\" can be specified, meaning that the user\n      will only see the window for the delay time (see below). If\n      \"N\" is specified delay= should be set greater than 0, else\n      the display may not be perceptable.\n\n      delay=0 The time that the window is displayed for before\n      the user can enter input if input=Y is specified.  Or, the\n      time the window is displayed for before control is returned\n      to the clist if input=N is specified. The time is specified\n      as an integer number of seconds. The default os 0 seconds.\n\n   The following feedback variables are set after the WD sub\n   command has executed with a LASTCC of 0. If the LASTCC is not\n   0 these variables will remain unchanged.\n\n      WINSYSR = The current cursor row.\n\n      WINSYSC = The current cursor column.\n\n      WINSYSK = The name of the last key pressed.\n\n         May be one of:\n         ENTER, PF1, ... PF24, PA2, PA3 OPID, MAGRDR, SELPEN.\n\n         The following keys will not be returned:  ATTN, PA1 -\n         TSO causes an attention interupt that the clist can\n         handle itself.  CLEAR, SYSREQ, TESTREQ - Not supported\n         by read modified request to the device.\n\n      WINSYSV = The name of the selected variable or blank if no\n      variable is selected.\n\n      WINSYST = The word of text that is selected or blank if no\n      test is selected.\n\n   For example win3270a command displays a screen that shows the\n   built in WIN3270 feedback variables.\n\n   WX subcommand - exit the WIN3270 subcommand environment. WX\n   has no parameters. This subcommand will free any resources,\n   clear the screen, and exit from the WIN3270 sub command\n   environment.\n\n   WXDEB subcommand - The debug level setting sub command..\n\n      nn The debug level number is an integer value that\n      determines how much debug info to display. 0 indicates\n      debug is off. 1 through 9 indicate a level, 1 being terse 9\n      being verbose. Numbers above 9 mean display specific info.\n\n\n\nExamples of the WIN3270 subcommand environment.\n-----------------------------------------------\n\nThe following examples can be found in the PDS 'SASDDF.A.CLIST'.\n\n   t32 command - Displays a test window that has a reverse video\n   box surrounding it. It requires PF3 to end the display.  This\n   is a very simple clist that illustrates the order that WIN3270\n   subcommands should be executed in.\n\n   win3270a command - Displays a screen that shows the built in\n   WIN3270 feedback variables.  This is a simple clist that\n   illustrates how to get the WIN3270 feedback variables.\n\n   win3270t command - Displays a crazy little application that\n   does nothing, except demonstrate use of some widgets. In\n   particular push buttons, check boxes and radio buttons. It\n   also demonstrates the ability to define more than 1 window,\n   and swap between them. win3270alc\n\n   lc command - Lists a tso users catalog, displaying the\n   contents on a full screen.  Illustrates the use of input and\n   output fields and function keys for scrolling.\n\n   xhelp command - Displays help for the keyword entered, and\n   allows the user to drill down within the displayed help in\n   order to display further help.  Illustrates the use of input\n   and output fields, function keys for scrolling, and the\n   WINSYST variable to access the selected text. Also uses the\n   screen size variable WINSYSNR to set the number of lines to\n   display.\n\n\n\nReferences Used.\n----------------\n\nThe following publications have been used in the developement of\nthis program:\n\n   SC28-1875 TSO/E v2 programming Services\n   GA23-0059 3270 Info. Display Sys. Data Stream Programmers Reference.\n   GA27-3831 3174 Establishment Controller Character Set Reference.\n   GA27-2837 3270 Character Set Reference.\n   HUR 9058 IBM3270 Personal Computer\n     Graphics Control Program Data Stream\n     Reference.\n   GA18-2589 IBM 3179-G/3192-G Color\n     Graphics Display Station Description.\n   GG27-6999 Introduction to Programming the IBM 3270.\n   SC28-1882 MVS/REXX Users Guide.\n   SC28-1883 Procedure Language MVS/REXX Reference.\n   56117 SAS/C Library Reference - Volume 1\n   56118 SAS/C Library Reference - Volume 2\n   56123 SAS/C Compiler and Library Users Guide\n   59014 SAS Technical report C-109 Changes\n     and Enhancements to the C Library\n     Reference Release 5.00\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@CCOMP": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x00\\x00\\x95\\x17\\x9f\\x00\\x95$O\\x15\"\\x00\\x0e\\x00\\n\\x00\\x00\\xe2\\xc1\\xe2\\xc4\\xc4\\xc6@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1995-06-28T00:00:00", "modifydate": "1995-09-01T15:22:00", "lines": 14, "newlines": 10, "modlines": 0, "user": "SASDDF"}, "text": "PROC 1 PGM OMD\n  CONTROL ASIS NOMSG NOLIST NOSYMLIST\n  FREE FI(INC)\n  ALLOC FI(INC) DA('SASDDF.A.SOURCE') SHR\n  DELETE TEMP.LIST\n  LC370 'SASDDF.A.SOURCE(&PGM)' +\n    OBJECT('''SASDDF.A.OBJ(&PGM)''') +\n    DBGLIB('''SASDDF.A.DBGLIB(&PGM)''') PRINT(TEMP) &OMD\n  IF &LASTCC <= 4 THEN +\n    CLK370 'SASDDF.A.OBJ(&PGM)' +\n      LOAD('''SASDDF.A.LOADLIB(&PGM)''')\n  FREE FI(INC)\n  ISPEXEC BROWSE DATASET(TEMP.LIST)\nEXIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@DD3270": {"ttr": 777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95#\\x7f\\x00\\x95#\\x7f\\x198\\x00\\x04\\x00\\x04\\x00\\x00\\xe2\\xc1\\xe2\\xc4\\xc4\\xc6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-08-25T00:00:00", "modifydate": "1995-08-25T19:38:00", "lines": 4, "newlines": 4, "modlines": 0, "user": "SASDDF"}, "text": "PROC 0\n/* DISPLAYS A TEST NOTEPAD WINDOW */\nCALL 'SASDDF.A.LOADLIB(DD3270)'\nEXIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FONTGEN": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x95$?\\x00\\x95%_\\x13Q\\x00\\x0c\\x00\\x06\\x00\\x00\\xe2\\xc1\\xe2\\xc4\\xc4\\xc6@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1995-08-31T00:00:00", "modifydate": "1995-09-12T13:51:00", "lines": 12, "newlines": 6, "modlines": 0, "user": "SASDDF"}, "text": "PROC 2 INSYM OUTARRAY\nIF &INSYM \u00ac= &OUTARRAY THEN DO\n  /* PROCESSES A FONT DEFINITION TO A C-LANGUAGE STRUCTURE */\n  ALLOC F(IN) DA('SASDDF.A.SOURCE(&INSYM)') SHR\n  ALLOC F(OUT) DA('SASDDF.A.SOURCE(&OUTARRAY)') SHR\n  CALL 'SASDDF.A.LOADLIB(FONT)' '&OUTARRAY'\n  FREE F(IN)\n  FREE F(OUT)\n  END\nELSE +\n  WRITE ERROR: PARAMETERS CAN NOT BE THE SAME.\nEXIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@INFO32P": {"ttr": 781, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x95\"?\\x00\\x954\\x1f\\x13!\\x00\\x0c\\x00\\x07\\x00\\x00\\xe2\\xc1\\xe2\\xc4\\xc4\\xc6\\xf2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1995-08-11T00:00:00", "modifydate": "1995-12-07T13:21:00", "lines": 12, "newlines": 7, "modlines": 0, "user": "SASDDF2"}, "text": "PROC 0 NAME() DEST(CHPLJR46) TERSE DUMP FORCE\n/* PRINTS INFO ABOUT THE TERMINAL */\nSET OPT = &STR()\nIF &TERSE=TERSE THEN SET OPT = &STR(&OPT -T)\nIF &DUMP=DUMP THEN SET OPT = &STR(&OPT -D)\nIF &FORCE=FORCE THEN SET OPT = &STR(&OPT -F)\nIF &NAME\u00ac=&STR() THEN SET OPT = &STR(&OPT -N &NAME)\nALLOC F(SYSPRINT) DA(INFO3270.TEXT) SHR\nCALL 'SASDDF.A.LOADLIB(INFO3270)' '&OPT'\nFREE F(SYSPRINT)\nPRINTOFF INFO3270.TEXT DEST(&DEST)\nEXIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@INFO327": {"ttr": 783, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x95\"?\\x00\\x95\"?\\x15F\\x00\\t\\x00\\x03\\x00\\x00\\xe2\\xc1\\xe2\\xc4\\xc4\\xc6@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1995-08-11T00:00:00", "modifydate": "1995-08-11T15:46:00", "lines": 9, "newlines": 3, "modlines": 0, "user": "SASDDF"}, "text": "PROC 0 NAME() TERSE DUMP FORCE\n/* DISPLAYS INFORMATION ABOUT THE TERMINAL */\nSET OPT = &STR()\nIF &TERSE=TERSE THEN SET OPT = &STR(&OPT -T)\nIF &DUMP=DUMP THEN SET OPT = &STR(&OPT -D)\nIF &FORCE=FORCE THEN SET OPT = &STR(&OPT -F)\nIF &NAME\u00ac=&STR() THEN SET OPT = &STR(&OPT -N &NAME)\nCALL 'SASDDF.A.LOADLIB(INFO3270)' '&OPT'\nEXIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@LISTCAT": {"ttr": 785, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95)/\\x00\\x95)/\\x14T\\x00\\x89\\x00\\x89\\x00\\x00\\xe2\\xc1\\xe2\\xc4\\xc4\\xc6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-10-19T00:00:00", "modifydate": "1995-10-19T14:54:00", "lines": 137, "newlines": 137, "modlines": 0, "user": "SASDDF"}, "text": "PROC 0 U()\n/*==================================================================*/\n/* Program:   WIN3270A                                              */\n/* Support:   DAF                                                   */\n/* Language:  CLIST                                                 */\n/*                                                                  */\n/* Purpose:   A test clist for the WIN3270 sub command environment. */\n/*            Displays a full screen scrollable catalog list.       */\n/*            See WIN3270T clist for large amounts of comments.     */\n/*                                                                  */\n/* History:   18Oct95  Initial coding                           DAF */\n/* End.                                                             */\n/*==================================================================*/\n\nCONTROL NOCAPS\nIF &U = THEN SET U = &SYSUID\n\n/* capture output from some tso command */\nSET &SYSOUTTRAP = 999     /* TURN ON AND CAPTURE 999 LINES OF OUTPUT */\nLISTC L(&U)\nSET &LINES = &SYSOUTLINE   /* GET NUMBER OF LINES CREATED BY COMMAND */\nSET &COUNT = 1\nSET DSC = 1\nDO WHILE(&COUNT <= &LINES)\n  SET QQ = &&SYSOUTLINE&COUNT\n  IF &SUBSTR(6:7,&QQ) \u00ac= IN THEN +\n    DO\n      SET PQ = &SUBSTR(17:&SYSINDEX(!,&QQ!)-1,&QQ    )\n      SET TABLE&DSC = &PQ\n      LISTDSI '&PQ' NORECALL\n      IF &LASTCC = 0 THEN +\n        SET TABDSA&DSC = &STR(&SYSVOLUME &SYSDSORG &SYSALLOC)\n      ELSE +\n        SET TABDSA&DSC = &STR(?)\n      SET DSC = &DSC + 1\n    END\n  SET COUNT = &COUNT + 1\nEND\nSET &SYSOUTTRAP = 0   /* turn off output line capture */\n\nCALL 'SASDDF.A.LOADLIB(WIN3270)'\nWA value=\\ type=label color=white hilite=none\nWA value=@ type=label color=blue hilite=uline\nWA value={ type=label color=yellow hilite=none\nWA value=% type=output color=red hilite=none\nWA value=! type=output color=blue hilite=none\nWA value=_ type=output color=cyan hilite=none\nWA value=$ type=input color=green hilite=none\nWC name=main\n\nWS 01 \\List catatalog of: !U                                        +\n{User:!SYSUID\nWS 02 \\Command ===>$zcmd                                            +\n{Time:!XTIME\nWS 03 %msg\nWS 04 @Data set name                             Volume Org. Alloc.\nWS 05 _A1                                       !DSI1\nWS 06 _A2                                       !DSI2\nWS 07 _A3                                       !DSI3\nWS 08 _A4                                       !DSI4\nWS 09 _A5                                       !DSI5\nWS 10 _A6                                       !DSI6\nWS 11 _A7                                       !DSI7\nWS 12 _A8                                       !DSI8\nWS 13 _A9                                       !DSI9\nWS 14 _A10                                      !DSI10\nWS 15 _A11                                      !DSI11\nWS 16 _A12                                      !DSI12\nWS 17 _A13                                      !DSI13\nWS 18 _A14                                      !DSI14\nWS 19 _A15                                      !DSI15\nWS 20 _A16                                      !DSI16\nWS 21 _A17                                      !DSI17\nWS 22 _A18                                      !DSI18\nWS 23 _A19                                      !DSI19\nWS 24 _A20                                      !DSI20\n\nSET &TOPROW = 1\nSET ZCMD = &STR()\nSET MSG = &STR(&dsc datasets displayed.)\nDO WHILE(&SYSCAPS(&STR(&ZCMD))\u00ac=&STR(END))\n  /* subcommand to display the defined screen */\n  SET XTIME = &SYSTIME\n  SET ZCMD = &STR( )\n  /* display the captured output */\n\n  SET I = 1\n  DO WHILE(&I <= 20)\n    SET TABP = &EVAL(&TOPROW+&I-1)\n    IF &TABP <= &DSC THEN +\n      DO\n        SET QQ = &&TABLE&TABP\n        SET A&I = &STR(&QQ)\n        SET QQ = &&TABDSA&TABP\n        SET DSI&I = &STR(&QQ)\n      END\n    ELSE +\n      DO\n        SET A&I = &STR( )\n        SET DSI&I = &STR( )\n      END\n    SET I = &I + 1\n  END\n\n  WD name=main row=1 col=1\n  IF &WINSYSK = PF3 THEN +\n    SET ZCMD = &STR(END)                   /* end */\n  IF &WINSYSK = PF15 THEN +\n    SET ZCMD = &STR(END)\n  IF &WINSYSK = PF19 THEN +\n    DO\n      SET TOPROW = &EVAL(&TOPROW - 10)      /* up */\n      IF &TOPROW < 1 THEN +\n        DO\n          SET TOPROW = 1\n          SET MSG = &STR(At top.)\n        END\n    END\n  IF &WINSYSK = PF20 THEN +\n    DO\n      SET LSTTOP = &TOPROW                  /* down */\n      SET TOPROW = &EVAL(&TOPROW + 10)\n      IF &TOPROW > &DSC THEN +\n        DO\n          SET TOPROW = &LSTTOP\n          SET MSG = &STR(At bottom.)\n        END\n    END\nEND\n\n  /* subcommand to erase the screen */\nFIN:  +\n  WE name=main\n  /* subcommand end WIN3270 */\n  WX\n\nEXIT\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@LOGON": {"ttr": 788, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x13\\x00\\x00\\x00\\x890?\\x00\\x95)?\\x145\\x00!\\x00\\x02\\x00\\x00\\xe2\\xc1\\xe2\\xc4\\xc4\\xc6@@@@'", "ispf": {"version": "01.19", "flags": 0, "createdate": "1989-10-30T00:00:00", "modifydate": "1995-10-20T14:35:00", "lines": 33, "newlines": 2, "modlines": 0, "user": "SASDDF"}, "text": "PROC 0\nCONTROL NOCAPS\nCALL 'SASDDF.A.LOADLIB(WIN3270)'\nWA value=$ type=label color=cyan hilite=blink\nWA value=\u00ac type=label color=yellow hilite=none\nWA value=# type=label color=blue hilite=none\nWA value=\\ type=label color=white hilite=none\nWC name=main\nWS 02 \\ Hello again Dave ...\nWD name=main row=1 col=1 delay=2\nWS 04 #        \u00acDDDDDDD#        \u00acOOOOO#    \u00acNNNN#    \u00acNNN# \u00acTTTTTTTTTTT#\nWS 05 #        \u00acDDDDDDDDD#     \u00acOOOOOOO#   \u00acNNNNN#   \u00acNNN# \u00acTTTTTTTTTTT#\nWS 06 #       \u00acDDD# \u00acDDDD#   \u00acOOO# \u00acOOO#  \u00acNNNNNN#  \u00acNNN#     \u00acTTT#\nWS 07 #      \u00acDDD#  \u00acDDDD# \u00acOOO#   \u00acOOO# \u00acNNN\u00acNNN# \u00acNNN#     \u00acTTT#\nWS 08 #     \u00acDDD#  \u00acDDDD# \u00acOOO#   \u00acOOO# \u00acNNN#\u00acNNN#\u00acNNN#     \u00acTTT#\nWS 09 #    \u00acDDD#  \u00acDDDD# \u00acOOO#   \u00acOOO# \u00acNNN# \u00acNNN\u00acNNN#     \u00acTTT#\nWS 10 #   \u00acDDD# \u00acDDDD#   \u00acOOO# \u00acOOO#  \u00acNNN#  \u00acNNNNNN#     \u00acTTT#\nWS 11 #  \u00acDDDDDDDDD#     \u00acOOOOOOO#   \u00acNNN#   \u00acNNNNN#     \u00acTTT#\nWS 12 # \u00acDDDDDDD#        \u00acOOOOO#    \u00acNNN#    \u00acNNNN#     \u00acTTT#\nWD name=main row=1 col=1 delay=1\nWS 15 #      $PPPPPP#       $A#        $NNNN#    $NNN#$IIIIIII#   $CCCC#\nWS 16 #     $PPPPPPPP#    $AAA#       $NNNNN#   $NNN#$IIIIIII#  $CCCCCC#\nWS 17 #    $PPP#$PPPP#  $AAAAA#      $NNNNNN#  $NNN#  $III#   $CCC#$CCC#\nWS 18 #   $PPPPPPPP#  $AAA$AAA#     $NNN$NNN# $NNN#  $III#  $CCC#\nWS 19 #  $PPPPPP#   $AAA# $AAA#    $NNN#$NNN#$NNN#  $III#  $CCC#\nWS 20 # $PPP#     $AAAAAAAAAAA#   $NNN# $NNN$NNN#  $III#  $CCC#\nWS 21 #$PPP#    $AAAAAAAAAAAAA#  $NNN#  $NNNNNN#  $III#   $CCC#$CCC#\nWS 22 $PPP#   $AAA#       $AAA# $NNN#   $NNNNN#$IIIIIII#  $CCCCCC#\nWS 23 $PPP#  $AAA#         $AAA#$NNN#    $NNNN#$IIIIIII#   $CCCC#\nWD name=main row=1 col=1 delay=3\nWE name=main\nWX\nEXIT\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@TERMST": {"ttr": 1026, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x950?\\x00\\x950?\\x13\\x00\\x00\\x06\\x00\\x06\\x00\\x00\\xe2\\xc1\\xe2\\xc4\\xc4\\xc6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-10-30T00:00:00", "modifydate": "1995-10-30T13:00:00", "lines": 6, "newlines": 6, "modlines": 0, "user": "SASDDF"}, "text": "PROC 0\nCONTROL NOCAPS\nCALL 'SASDDF.A.LOADLIB(WIN3270)'\nWM 10\nWX\nEXIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@TEST327": {"ttr": 1028, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x950O\\x00\\x950O\\x16\\x12\\x00x\\x00&\\x00\\x00\\xe2\\xc1\\xe2\\xc4\\xc4\\xc6@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1995-10-31T00:00:00", "modifydate": "1995-10-31T16:12:00", "lines": 120, "newlines": 38, "modlines": 0, "user": "SASDDF"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "@TREXX": {"ttr": 1031, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x950_\\x00\\x950o\\x15F\\x00\\x03\\x00\\x18\\x00\\x00\\xe2\\xc1\\xe2\\xc4\\xc4\\xc6@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1995-11-01T00:00:00", "modifydate": "1995-11-02T15:46:00", "lines": 3, "newlines": 24, "modlines": 0, "user": "SASDDF"}, "text": "/* REXX */\n\"CALL 'SASDDF.A.LOADLIB(WIN3270)' '-ML 9 -REXX TREXX2'\"\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@TREXX2": {"ttr": 1033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x950o\\x00\\x950o\\x16\\x06\\x00\\x19\\x00\\x0f\\x00\\x00\\xe2\\xc1\\xe2\\xc4\\xc4\\xc6@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1995-11-02T00:00:00", "modifydate": "1995-11-02T16:06:00", "lines": 25, "newlines": 15, "modlines": 0, "user": "SASDDF"}, "text": "/* REXX */\naddress WIN3270\n/* define attributes */\n\"WA value=\\ type=label color=cyan hilite=none\"\n\"WA value=# type=label color=red hilite=none\"\n\"WA value=! type=label color=blue hilite=reverse\"\n\"WA value=_ type=output color=yellow hilite=none\"\nusr = sysvar(SYSUID)\n/* define window */\n\"WC name=main\"\n\"WS 08 !                                            \\\"\n\"WS 09 ! \\                                        ! \\\"\n\"WS 10 ! \\ This is a very simple test box.        ! \\\"\n\"WS 11 ! \\ User:_USR                              ! \\\"\n\"WS 12 ! \\ Second and last line of the test.      ! \\\"\n\"WS 13 ! # Use PF3 to end                         ! \\\"\n\"WS 14 ! \\                                        ! \\\"\n\"WS 15 !                                            \\\"\n/* display window */\ndo until(winsysk = 'PF3')\n  \"WD name=main\"\nend\n/* clean up */\n\"WE name=main\"\n\"WX\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@T32": {"ttr": 1035, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x95)?\\x00\\x950\\x0f\\x12\\x12\\x00\\x15\\x00\\x0f\\x00\\x00\\xe2\\xc1\\xe2\\xc4\\xc4\\xc6@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1995-10-20T00:00:00", "modifydate": "1995-10-27T12:12:00", "lines": 21, "newlines": 15, "modlines": 0, "user": "SASDDF"}, "text": "PROC 0\nCONTROL NOCAPS\nCALL 'SASDDF.A.LOADLIB(WIN3270)'\nWA value=\\ type=label color=cyan hilite=none\nWA value=# type=label color=red hilite=none\nWA value=! type=label color=blue hilite=reverse\nWA value=_ type=output color=yellow hilite=none\nWC name=main\nWS 08 !                                                               \\\nWS 09 ! \\                                                           ! \\\nWS 10 ! \\     This is a very simple test box.   User:_SYSUID        ! \\\nWS 11 ! \\                                                           ! \\\nWS 12 ! \\     Second and last line of the test. #Use PF3 to end     ! \\\nWS 13 ! \\                                                           ! \\\nWS 14 !                                                               \\\nDO WHILE(&STR(&WINSYSK)\u00ac=&STR(PF3))\n  WD name=main row=1 col=1\nEND\nWE name=main\nWX\nEXIT\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@T32A": {"ttr": 1037, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x950\\x0f\\x00\\x950\\x0f\\x14$\\x00\\x16\\x00\\x16\\x00\\x00\\xe2\\xc1\\xe2\\xc4\\xc4\\xc6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-10-27T00:00:00", "modifydate": "1995-10-27T14:24:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "SASDDF"}, "text": "PROC 0\nCONTROL NOCAPS\nCALL 'SASDDF.A.LOADLIB(WIN3270)'\nWA value=\\ type=label color=cyan hilite=none\nWA value=# type=label color=red hilite=none\nWA value=! type=label color=blue hilite=reverse\nWA value=_ type=output color=yellow hilite=none\nWA value=@ type=input color=green hilite=none symbol=ps\nWC name=main\nWS 08 !                                                               \\\nWS 09 ! \\                                                           ! \\\nWS 10 ! \\     This is a very simple test box.   User:_SYSUID        ! \\\nWS 11 ! \\                                                           ! \\\nWS 12 ! \\     Second and last line of the test. #Use PF3 to end     ! \\\nWS 13 ! \\     Input ===>@test                                       ! \\\nWS 14 !                                                               \\\nDO WHILE(&STR(&WINSYSK)\u00ac=&STR(PF3))\n  WD name=main row=1 col=1\nEND\nWE name=main\nWX\nEXIT\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@WIDGET": {"ttr": 1039, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95%o\\x00\\x95%o\\x187\\x00\\x04\\x00\\x04\\x00\\x00\\xe2\\xc1\\xe2\\xc4\\xc4\\xc6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-09-13T00:00:00", "modifydate": "1995-09-13T18:37:00", "lines": 4, "newlines": 4, "modlines": 0, "user": "SASDDF"}, "text": "PROC 0\n/* DISPLAYS A 3270 TEST WIDGET WINDOW */\nCALL 'SASDDF.A.LOADLIB(WIDGET32)'\nEXIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@WIN327A": {"ttr": 1041, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x95)\\x1f\\x00\\x950\\x7f\\x11\\x18\\x00D\\x00C\\x00\\x00\\xe2\\xc1\\xe2\\xc4\\xc4\\xc6@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1995-10-18T00:00:00", "modifydate": "1995-11-03T11:18:00", "lines": 68, "newlines": 67, "modlines": 0, "user": "SASDDF"}, "text": "PROC 0\n/*==================================================================*/\n/* Program:   WIN3270A                                              */\n/* Support:   DAF                                                   */\n/* Language:  CLIST                                                 */\n/*                                                                  */\n/* Purpose:   A test clist for the WIN3270 sub command environment. */\n/*            See WIN3270T clist for large amounts of comments.     */\n/*                                                                  */\n/* History:   18Oct95  Initial coding                           DAF */\n/* End.                                                             */\n/*==================================================================*/\n\nCONTROL NOCAPS\n  CALL 'SASDDF.A.LOADLIB(WIN3270)'\n  WA value=\\ type=label color=white hilite=none\n  WA value={ type=label color=yellow hilite=none\n  WA value=% type=output color=red hilite=none\n  WA value=! type=output color=blue hilite=none\n  WA value=$ type=input color=green hilite=none\n  WA value=_ type=button color=cyan just=center\n  WA value=@ type=radio color=cyan just=left\n  WA value=# type=checkbox color=cyan just=left\n  WE name=main\n  WC name=main\n  SET ZCMD = &STR()\n  SET MSG = &STR(Initial message)\n\n  WS 01 \\WIN3270: TSO 3270 display program test        {User:!SYSUID\n  WS 02 \\Command ===>$zcmd                             {Time:!XTIME\n  WS 03 %msg\n  WS 04 \\\n  WS 05 \\Display of the built in feedback variables provided by the\n  WS 06 \\win3270 sub-command environment.\n  WS 07 \\\n  WS 08 \\Variables set at initialization of the environment.\n  WS 09 \\  WINSYSDC = Display colors list.....:!WINSYSDC\n  WS 10 \\  WINSYSNR = Number of display lines :!WINSYSNR\n  WS 11 \\  WINSYSNC = Number of display cols..:!WINSYSNC\n  WS 12 \\  WINSYSAP = APL support.............:!WINSYSAP\n  WS 13 \\  WINSYSGR = Vector graphic support..:!WINSYSGR\n  WS 14 \\  WINSYSPS = Programmed symbols......:!WINSYSPS\n  WS 15 \\  WINSYSDH = Display hilights list...:!WINSYSDH\n  WS 16 \\\n  WS 17 \\Built in variables (value for last display).\n  WS 18 \\  WINSYSR = Current cursor row.......:!WINSYSR\n  WS 19 \\  WINSYSC = Current cursor column....:!WINSYSC\n  WS 20 \\  WINSYSK = Name of last key pressed.:!WINSYSK\n  WS 21 \\  WINSYST = Last selected word.......:!WINSYST\n  WS 22 \\  WINSYSV = Last selected variable...:!WINSYSV\n\n  DO WHILE(&STR(&ZCMD)\u00ac=&STR(end))\n    /* subcommand to display the defined screen */\n    SET XTIME = &SYSTIME\n    SET ZCMD = &STR( )\n    WD name=main row=1 col=1\n    SET MSG = &STR(ZCMD was: &ZCMD)\n    IF &WINSYSK = PF3 THEN GOTO FIN\n    ELSE IF &WINSYSK = PF15 THEN GOTO FIN\n  END\n\n  /* subcommand to erase the screen */\nFIN:  +\n  WE name=main\n  /* subcommand end WIN3270 */\n  WX\n\nEXIT\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@WIN327D": {"ttr": 1043, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x950\\x0f\\x00\\x950\\x0f\\x12E\\x01\\xa4\\x01\\xa4\\x00\\x00\\xe2\\xc1\\xe2\\xc4\\xc4\\xc6@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1995-10-27T00:00:00", "modifydate": "1995-10-27T12:45:00", "lines": 420, "newlines": 420, "modlines": 0, "user": "SASDDF"}, "text": "PROC 0 DEB\n/*==================================================================*/\n/* Program:   WIN3270D                                              */\n/* Support:   DAF                                                   */\n/* Language:  CLIST                                                 */\n/*                                                                  */\n/* Purpose:   A test clist for the WIN3270 sub command environment. */\n/*            This clist also contains large amounts of comments    */\n/*            that explain what each subcommand and their           */\n/*            attributes do. Also explained are the feeback         */\n/*            variables and their contents.                         */\n/*                                                                  */\n/*            The WIN3270 environment allows users of the           */\n/*            TSO Clist language and the REXX language on TSO       */\n/*            facilities to create full screen applications on the  */\n/*            3270 display station. Six types of widgets are        */\n/*            supported, and any displayed text can be treated      */\n/*            as HOT or selectable allowing context sensitive       */\n/*            text dialogs to be created. The widgets supported     */\n/*            are LABEL, INPUT, OUTPUT, BUTTON, RADIO, and          */\n/*            CHECKBOX. This simple tool set for the 3270 should    */\n/*            allow powerfull applications to be created with       */\n/*            CLIST and REXX for TSO.                               */\n/*                                                                  */\n/*            It is NOT the intention that this code should         */\n/*            remove the need for similar ISPF code. ISPF is        */\n/*            greatly more powerfull and feature rich than          */\n/*            the WIN3270 subcommand environment. Though            */\n/*            these functions can be used with those of ISPF,       */\n/*            or before ISPF is started.                            */\n/*                                                                  */\n/*            This code has been created as a training exercise     */\n/*            to allow the author to become more familiar with      */\n/*            3270 data stream programming and C language           */\n/*            programming. And so its future is undetermined.       */\n/*                                                                  */\n/* History:   25Aug95  Initial coding                           DAF */\n/*            25Aug95  Added message level parm                 DAF */\n/* End.                                                             */\n/*==================================================================*/\n\nCONTROL NOCAPS\n\n/* initialize the WIN3270 environment */\nIF &STR(&DEB) = DEB THEN +\n  DO\n    ALLOC FI(DBGLIB) DA(A.DBGLIB) SHR\n    CALL 'SASDDF.A.LOADLIB(WIN3270)' '-ML 9 =DEBUG'\n  END\nELSE +\n  CALL 'SASDDF.A.LOADLIB(WIN3270)'\n/* WH */         /* information only - prints the help text */\n/* WM 10 */      /* debug subcommand - prints term stat information */\n\n/* The following WIN3270 feedback variables are set after the */\n/* WIN3270 sub command environment has been established:      */\n/*   WINSYSDC = Display colors list.                          */\n/*   WINSYSNR = Number of display lines (rows).               */\n/*   WINSYSNC = Number of display columns.                    */\n/*   WINSYSAP = APL support either Y or N.                    */\n/*   WINSYSGR = Vector graphic support either Y or N.         */\n/*   WINSYSPS = Programmed symbols either Y or N.             */\n/*   WINSYSDH = Display hilights list.                        */\n/* These variables should not be altered as their content is  */\n/* not refreshed after the sub command environment has been   */\n/* started.                                                   */\n/*                                                            */\n/* WIN3270 subcommands and operands:                          */\n/*   WA - set field attributes used by all windows.           */\n/*     value=   Single character used to define field start.  */\n/*              Value is required.                            */\n/*     type=    Type of the widget. Default type is LABEL.    */\n/*              Type can be one of:                           */\n/*                LABEL, INPUT, OUTPUT, BUTTON, RADIO or      */\n/*                CHECKBOX.                                   */\n/*     color=   The color name used for the widget.           */\n/*              Color can be one of:                          */\n/*                RED, BLUE, GREEN, WHITE, PINK, YELLOW,      */\n/*                CYAN, NONE, or BLACK.                       */\n/*              The default is GREEN.                         */\n/*     hilite=  The hilight to use for some widgets.          */\n/*              Hilite can be one of:                         */\n/*                NONE, REVERSE, ULINE, BLINK.                */\n/*              The default is NONE.                          */\n/*              Not all widget types support hilites.         */\n/*     symbol=  Symbol set to use. Can be one of:             */\n/*                NONE, APL.                                  */\n/*              The default is NONE.                          */\n/*              Not all widget types support APL.             */\n/*     just=    The justification to use. Can be either of:   */\n/*                NONE, LEFT, CENTER, RIGHT.                  */\n/*              The default is NONE.                          */\n/*              Not all widget types support justification.   */\n/*                                                            */\n/*   WE - erase named window.                                 */\n/*     name=    The name of the window to erase. This is      */\n/*              required. If name= is not specified LASTCC    */\n/*              will be set to 4 and a window will not be     */\n/*              deleted. If name already exists and is        */\n/*              deleted LASTCC will be 0 and if the window    */\n/*              was the currently active window there will    */\n/*              no longer be a currently active window.       */\n/*                                                            */\n/*   WC - create named window.                                */\n/*     name=    The name of the window to create. This is     */\n/*              required. If name= is not specified LASTCC    */\n/*              will be set to 4 and a window will not be     */\n/*              created. If name already exists LASTCC will   */\n/*              be set to 8, and the currently active window  */\n/*              will not be changed, and no new window will   */\n/*              be defined.                                   */\n/*              WC must be followed by at least one WS        */\n/*              sub command.                                  */\n/*                                                            */\n/*   WS - define row on currently named window.               */\n/*     nn       NN defines the row to define. Characters      */\n/*              following the single blank following NN are   */\n/*              assumed to be part of the window for row NN   */\n/*              of the window named by the last WC sub        */\n/*              command.                                      */\n/*              This parameter is required.                   */\n/*              If nn is larger than the screen will allow    */\n/*              the LASTCC will be set to 4 and the row       */\n/*              will not be defined.                          */\n/*              If nn is not a valid integer greater          */\n/*              than 0 LASTCC will be set to 8 and            */\n/*              the row will not be defined.                  */\n/*              If nn has already been defined then LASTCC    */\n/*              will be set to 12 and the row will not be     */\n/*              defined.                                      */\n/*              WS must be preceeded by one WC sub command.   */\n/*                                                            */\n/*   WD - display the named window.                           */\n/*     name=    Name of an existing window to display.        */\n/*              If the window named by name= does not exist   */\n/*              the LASTCC will be set to 4 and the window    */\n/*              will not be displayed. This parameter is      */\n/*              required.                                     */\n/*     row=nn   Row position of top left window corner.       */\n/*              The default for nn is 1. If row= is not a     */\n/*              valid number LASTCC is set to 8.              */\n/*              If the number is too large for the window     */\n/*              to the LASTCC is set to 12 and the window     */\n/*              is not displayed.                             */\n/*     col=nn   Column position of top left window corner.    */\n/*              The default for nn is 1. If col= is not a     */\n/*              valid number LASTCC is set to 8.              */\n/*              If the number is too large for the window     */\n/*              to the LASTCC is set to 12 and the window     */\n/*              is not displayed.                             */\n/*     input=Y  Flag indicating if input will be accepted     */\n/*              from the window. The default is \"Y\", meaning  */\n/*              input will be accepted. Alternatively \"N\"     */\n/*              can be specified, meaning that the user will  */\n/*              only see the window for the delay time (see   */\n/*              below). If \"N\" is specified delay= should be  */\n/*              set greater than 0, else the display may not  */\n/*              be perceptable.                               */\n/*     delay=0  The time that the window is displayed for     */\n/*              before the user can enter input if input=Y    */\n/*              is specified. Or, the time the window is      */\n/*              displayed for before control is returned to   */\n/*              the clist if input=N is specified.            */\n/*              The time is specified as an integer number    */\n/*              of seconds. The default os 0 seconds.         */\n/*                                                            */\n/*     The following feedback variables are set after the WD  */\n/*     sub command has executed with a LASTCC of 0. If the    */\n/*     LASTCC is not 0 these variables will remain unchanged. */\n/*       WINSYSR = The current cursor row.                    */\n/*       WINSYSC = The current cursor column.                 */\n/*       WINSYSK = The name of the last key pressed.          */\n/*         May be one of:                                     */\n/*           ENTER, PF1, ... PF24, PA2, PA3                   */\n/*           OPID, MAGRDR, SELPEN.                            */\n/*         The following keys will not be returned:           */\n/*           ATTN, PA1 - TSO causes an attention interupt     */\n/*                       that the clist can handle itself.    */\n/*           CLEAR, SYSREQ, TESTREQ - Not supported by read   */\n/*                       modified request to the device.      */\n/*       WINSYSV = The name of the selected variable          */\n/*         or blank if no variable is selected.               */\n/*       WINSYST = The word of text that is selected          */\n/*         or blank if no test is selected.                   */\n/*                                                            */\n/*   WX - exit the WIN3270 subcommand environment.            */\n/*              WX has no parameters.                         */\n/*              This subcommand will free any resources,      */\n/*              clear the screen, and exit from the WIN3270   */\n/*              sub command environment.                      */\n/*                                                            */\n/*   WXDEB - The debug level setting sub command..            */\n/*     nn       The debug level number is an integer value    */\n/*              that determines how much debug info to        */\n/*              display. 0 indicates debug is off.            */\n/*              1 through 9 indicate a level, 1 being terse   */\n/*              9 being verbose.                              */\n/*              numbers above 9 mean display specific info.   */\n\n/* subcommands to set up the attribute values to use */\n\nWA value=\\ type=label color=white hilite=none\nWA value={ type=label color=yellow hilite=none\n  /* type=label is used for a protected text label field. The */\n  /* value= character is replaced by an attribute character.  */\n  /* The text for the field will follow the value= char.      */\n\nWA value=% type=output color=red hilite=none\nWA value=! type=output color=blue hilite=none\n  /* type=output is used for a protected text field. The      */\n  /* value= character is replaced by an attribute character.  */\n  /* The name of the CLIST variable will follow the value=    */\n  /* character. The variable contents will be displayed in the*/\n  /* field after the window has been displayed.               */\n\nWA value=$ type=input color=green hilite=uline\n  /* type=input is used for an unprotected input field. The   */\n  /* value= character is replaced by an attribute character.  */\n  /* The name of the CLIST variable will follow the value=    */\n  /* character. The variable contents will be displayed in the*/\n  /* field as the window is displayed, and the variable will  */\n  /* receive the contents of the field after the window has   */\n  /* been displayed.                                          */\n\nWA value=_ type=button color=cyan just=center\n  /* type=button is used for an unprotected input field, that */\n  /* has a button border to it.                               */\n  /* The name of the CLIST variable will follow the value=    */\n  /* character. The variable will be set to X if the cursor   */\n  /* is on the field when the window has been displayed.      */\n  /* Otherwise the variable will be set to blank.             */\n\nWA value=@ type=radio color=cyan just=left\n  /* type=radio is used for an unprotected input field, that  */\n  /* has small button indicator on the left of it.            */\n  /* The name of the CLIST variable will follow the value=    */\n  /* character of the first radio button field.               */\n  /* The variable name is the first word of the text and      */\n  /* is not displayed. (see below)                            */\n  /* The variable will contain the second word if this station*/\n  /* is the selected radio box station.                       */\n  /* Otherwise the variable will be set to blank.             */\n  /* The x and o in the following diagram will be replaced    */\n  /* with PS symbols on devices that support these, otherwise */\n  /* the O and star(*) characters will be used.               */\n  /*                                                          */\n  /*   This:                                                  */\n  /*   WS 02   @A1 Red apples                                 */\n  /*   WS 03   @A1 Green apples                               */\n  /*   WS 04   @A1 Yellow apples                              */\n  /*   WS 05                                                  */\n  /*   WS 06   @A2 Orange oranges                             */\n  /*   WS 07   @A2 Blue oranges - yuck                        */\n  /*                                                          */\n  /*   Will generate:                                         */\n  /*           .O.Red apples                                  */\n  /*           .*.Green apples                                */\n  /*           .O.Yellow apples                               */\n  /*                                                          */\n  /*           .O.Orange oranges                              */\n  /*           .*.Blue oranges - yuck                         */\n  /*                                                          */\n  /* Here variable names are A1 and A2. The variable          */\n  /* A1 will contain \"Green\" and the variable A2              */\n  /* will contain \"Blue\". You will note that the first 3      */\n  /* and the last two fields are respectively linked to       */\n  /* their own variables, whose name is the                   */\n  /* first word in the field definition. Only one of the      */\n  /* linked fields can be on (displaying a *), if the         */\n  /* variable is set to an invalid value then the value will  */\n  /* be replaced by the name of the first field.              */\n\nWA value=# type=checkbox color=cyan just=left\n  /* type=checkbox is used for an unprotected input field,    */\n  /* that has a small box indicator on the left of it.        */\n  /* The name of the CLIST variable will follow the value=    */\n  /* character.                                               */\n  /* The variable name and displayed text are the             */\n  /* same until the first blank character. (see below)        */\n  /* The variable will be set to contain \"X\" if the cursor    */\n  /* is on the field when the window has been displayed.      */\n  /* Otherwise the variable will be set to blank.             */\n  /* The X and _ in the following diagram will be replaced    */\n  /* with PS symbols on devices that support these, otherwise */\n  /* the X and underscore(_) characters will be used.         */\n  /*                                                          */\n  /*   This:                                                  */\n  /*   WS 02   #Bird feathers                                 */\n  /*   WS 03   #Dog hair                                      */\n  /*   WS 04   #Cat fur                                       */\n  /*   WS 05   #Fish scales                                   */\n  /*                                                          */\n  /*   Will generate:                                         */\n  /*           .X.Bird feathers                               */\n  /*           ._.Dog hair                                    */\n  /*           .X.Cat fur                                     */\n  /*           ._.Fish scales                                 */\n  /*                                                          */\n  /* Here variable names are BIRD, DOG, CAT and FISH. Variable*/\n  /* BIRD will contain \"X\", variable DOG will contain blank,  */\n  /* variable CAT will contain \"X\", and variable FISH will    */\n  /* contain blank.                                           */\n\n/* subcommand to erase the screen */\nWE name=main\n/* subcommand to create the screen, defines the current window */\nWC name=main\n\n/* define all the variables in the window(s) */\nSET ZCMD = &STR()\nSET MSG = &STR(Initial message)\nSET OT = &STR(Red)\nSET BLUE = &STR()\nSET GREEN = &STR()\nSET FRIED = &STR()\nSET POACHED = &STR()\nSET OVER = &STR()\nSET GRILLED = &STR()\nSET OK = &STR()\nSET CANCEL = &STR()\nSET HELP = &STR()\n\n/* subcommands define the format of the screen */\n/*=============================================*/\n/* Warning  Do not use characters that the     */\n/*          CLIST language processor likes to  */\n/*          eat, to build windows, or use as   */\n/*          attributes, etc. Such errors are   */\n/*          hard to find.                      */\n/*          Avoid plus,minus,ampersand,colon   */\n/*=============================================*/\nWS 01 \\Miliways Menu                                             +\n{User:!SYSUID\nWS 02 \\Command ===>$zcmd                                         +\n{Time:!XTIME\nWS 03 %msg\nWS 04 \\Todays menu is from Mars a small red planet in the Teran system.\nWS 05 \\\nWS 06 \\\nWS 07 \\   Pick one of these\nWS 08 \\        @OT Blue rats with a red dog sauce.\nWS 09 \\        @OT Red fish in a white wino sauce.\nWS 10 \\        @OT White cats stuffed with marsh mellow.\nWS 11 \\\nWS 12 \\   Pick many of these strange things\nWS 13 \\        #Blue birds.                   #Green eggs and ham.\nWS 14 \\        #Fried green potatoes.         #Poached turkey.\nWS 15 \\        #Over fried beans.             #Grilled pumpkin.\nWS 16 \\\nWS 17 \\             _OK  \\      _Cancel  \\     _Help  \\.\n\n/* WM 11       dump field list */\n\n/* subcommand to erase the screen */\nWE name=help\n/* subcommand to create the screen */\nWC name=help\n/* subcommands define the format of the screen */\nWS 01 \\Miliways Help\nWS 02 \\Command ===>$zcmd\nWS 03 %msg\nWS 04 \\\nWS 05 \\            Sorry mate there is no help for the menu. You\nWS 06 \\            just have to take pot luck with this stuff.\nWS 07 \\            There is no free lunch to be found here.\nWS 08 \\\nWS 09 \\\nWS 10 \\                               _OK  \\.\nWS 11 \\\n\n  DO WHILE(&SYSCAPS(&STR(&ZCMD))\u00ac=&STR(END))\n    /* subcommand to display the defined screen */\n    SET XTIME = &SYSTIME\n    SET ZCMD = &STR( )\n    WD name=main row=1 col=1\n\n    /* process the selection */\n    IF &CANCEL = X THEN GOTO FIN\n    ELSE IF &HELP = X THEN +\n      DO\n        SET ZCMD = &STR()\n        WD name=help row=1 col=1\n        SET WINSYSK = &STR()\n        SET OK = &STR()\n        SET ZCMD = &STR()\n      END\n    ELSE IF &OK = X THEN +\n      DO\n        IF &OT = Red THEN +\n          SET MSG = &STR(You ordered: Red fish in a white wino sauce.)\n        ELSE IF &OT = Blue THEN +\n          SET MSG = &STR(You ordered: Blue rats with a red dog sauce.)\n        ELSE IF &OT = White THEN +\n          SET MSG = &STR(You ordered: White cats stuffed with marsh ...)\n      /* ... and other truely strange tastes ! */\n      END\n\n    IF &STR(&ZCMD) = HELP THEN +\n      DO\n        SET ZCMD = &STR()\n        WD name=help row=1 col=1 delay=8\n        SET WINSYSK = &STR()\n        SET ZCMD = &STR()\n        SET OK = &STR() /* turn button off to indicate it is processed*/\n      END\n\n    IF &STR(&WINSYSK) = PF3 THEN +\n      SET ZCMD = &STR(END)\n    IF &STR(&WINSYSK) = PF15 THEN +\n      SET ZCMD = &STR(END)\n  END\n\n  /* subcommand to erase the screen */\nFIN:  +\n  WE name=help\n  WE name=main\n  /* subcommand end WIN3270 */\n  WX\n\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@WIN327T": {"ttr": 1285, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01,\\x00\\x00\\x00\\x95#\\x7f\\x00\\x950o\\x13\\x01\\x00\\x85\\x00\\t\\x00\\x00\\xe2\\xc1\\xe2\\xc4\\xc4\\xc6@@@@'", "ispf": {"version": "01.44", "flags": 0, "createdate": "1995-08-25T00:00:00", "modifydate": "1995-11-02T13:01:00", "lines": 133, "newlines": 9, "modlines": 0, "user": "SASDDF"}, "text": "PROC 0\n/*==================================================================*/\n/* Program:   WIN3270T                                              */\n/* Support:   DAF                                                   */\n/* Language:  CLIST                                                 */\n/* Purpose:   A test clist for the WIN3270 sub command environment. */\n/* History:   25Aug95  Initial coding                           DAF */\n/*            25Aug95  Added message level parm                 DAF */\n/*            27Oct95  Added box to display                     DAF */\n/* End.                                                             */\n/*==================================================================*/\n\nCONTROL NOCAPS\nCALL 'SASDDF.A.LOADLIB(WIN3270)'\nWA value=~ type=label color=blue hilite=reverse\nWA value=\\ type=label color=white hilite=none\nWA value={ type=label color=yellow hilite=none\nWA value=% type=output color=red hilite=none\nWA value=! type=output color=blue hilite=none\nWA value=$ type=input color=green hilite=none\nWA value=_ type=button color=cyan just=center\nWA value=@ type=radio color=cyan just=left\nWA value=# type=checkbox color=cyan just=left\n/* subcommand to create the screen, defines the current window */\nWC name=main\n/* define all the variables in the window(s) */\nSET ZCMD = &STR()\nSET MSG = &STR(Initial message)\nSET OT = &STR(Red)\nSET BLUE = &STR()\nSET GREEN = &STR()\nSET FRIED = &STR()\nSET POACHED = &STR()\nSET OVER = &STR()\nSET GRILLED = &STR()\nSET OK = &STR()\nSET CANCEL = &STR()\nSET HELP = &STR()\n/* subcommands define the format of the screen */\n\nWS 01 ~123456789012345678901234567890123456789012345678901234567890123\\\nWS 02 ~ \\Miliways Menu                               {User:!SYSUID  ~ \\\nWS 03 ~ \\Command ===>$zcmd                           {Time:!XTIME   ~ \\\nWS 04 ~ %msg                                                        ~ \\\nWS 05 ~ \\Todays menu is from Mars a small red planet that circles   ~ \\\nWS 06 ~ \\the dull yellow sun called Sol.                            ~ \\\nWS 07 ~ \\                                                           ~ \\\nWS 08 ~ \\   Pick one of these                                       ~ \\\nWS 09 ~ \\        @OT Blue rats with a red dog sauce.                ~ \\\nWS 10 ~ \\        @OT Red fish in a white wino sauce.                ~ \\\nWS 11 ~ \\        @OT White cats stuffed with marsh mellow.          ~ \\\nWS 12 ~ \\                                                           ~ \\\nWS 13 ~ \\   Pick many of these strange things                       ~ \\\nWS 14 ~ \\        #Blue birds.              #Green eggs and ham.12345~ \\\nWS 15 ~ \\        #Fried green potatoes.    #Poached turkey.         ~ \\\nWS 16 ~ \\        #Over fried beans.        #Grilled pumpkin.        ~ \\\nWS 17 ~ \\                                                           ~ \\\nWS 18 ~ \\             _Order  \\      _Exit  \\     _Help  \\          ~ \\\nWS 19 ~ \\                                                           ~ \\\nWS 20 ~---------1---------2---------3---------4---------5---------6---\\\n/* subcommand to erase the screen */\nWE name=help\n/* subcommand to create the screen */\nWC name=help\n/* subcommands define the format of the screen */\nWS 01 ~                                                               \\\nWS 02 ~ \\Miliways Help                                              ~ \\\nWS 03 ~ \\Command ===>$zcmd                                          ~ \\\nWS 04 ~ %msg                                                        ~ \\\nWS 05 ~ \\                                                           ~ \\\nWS 06 ~ \\      Sorry mate there is no help for the menu. You        ~ \\\nWS 07 ~ \\      just have to take pot luck with this stuff.          ~ \\\nWS 08 ~ \\      There is no free lunch to be found here.             ~ \\\nWS 09 ~ \\                                                           ~ \\\nWS 10 ~ \\                                                           ~ \\\nWS 11 ~ \\                       _Goback  \\                          ~ \\\nWS 12 ~ \\                                                           ~ \\\nWS 13 ~                                                               \\\n\n  DO WHILE(&SYSCAPS(&STR(&ZCMD))\u00ac=&STR(END))\n    /* subcommand to display the defined screen */\n    SET XTIME = &SYSTIME\n    SET ZCMD = &STR( )\n    WD name=main row=1 col=1\n\n    /* process the selection */\n    IF &exit = X THEN GOTO FIN\n    ELSE IF &HELP = X THEN +\n      DO\n        SET ZCMD = &STR()\n        WD name=help row=1 col=1\n        SET WINSYSK = &STR()\n        SET OK = &STR()\n        SET ZCMD = &STR()\n      END\n    ELSE IF &ORDER = X THEN +\n      DO\n        IF &OT = Red THEN +\n          SET MSG = &STR(You ordered: Red fish in a white wino sauce.)\n        ELSE IF &OT = Blue THEN +\n          SET MSG = &STR(You ordered: Blue rats with a red dog sauce.)\n        ELSE IF &OT = White THEN +\n          SET MSG = &STR(You ordered: White cats stuffed with marsh ...)\n      /* ... and other truely strange tastes ! */\n      END\n\n    IF &STR(&ZCMD) = HELP THEN +\n      DO\n        SET ZCMD = &STR()\n        WD name=help row=1 col=1 delay=8\n        SET WINSYSK = &STR()\n        SET ZCMD = &STR()\n        SET OK = &STR() /* turn button off to indicate it is processed*/\n      END\n    ELSE IF &STR(&ZCMD) \u00ac= &STR( ) THEN +\n      DO\n        &ZCMD\n      END\n\n    IF &STR(&WINSYSK) = PF3 THEN +\n      SET ZCMD = &STR(END)\n    IF &STR(&WINSYSK) = PF15 THEN +\n      SET ZCMD = &STR(END)\n  END\n\n  /* subcommand to erase the screen */\nFIN:  +\n  WE name=help\n  WE name=main\n  /* subcommand end WIN3270 */\n  WX\n\nEXIT\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@XHELP": {"ttr": 1288, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x95)/\\x00\\x95)\\x9f\\x164\\x00\\xea\\x00\\xad\\x00\\x00\\xe2\\xc1\\xe2\\xc4\\xc4\\xc6@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1995-10-19T00:00:00", "modifydate": "1995-10-26T16:34:00", "lines": 234, "newlines": 173, "modlines": 0, "user": "SASDDF"}, "text": "PROC 1 TOPIC\n/*==================================================================*/\n/* Program:   WIN3270A                                              */\n/* Support:   DAF                                                   */\n/* Language:  CLIST                                                 */\n/*                                                                  */\n/* Purpose:   A test clist for the WIN3270 sub command environment. */\n/*            Displays a full screen scrollable help.               */\n/*            See WIN3270T clist for large amounts of comments.     */\n/*                                                                  */\n/* History:   18Oct95  Initial coding                           DAF */\n/* End.                                                             */\n/*==================================================================*/\n\nCONTROL NOCAPS   /* CONLIST SYMLIST */\n\n/* capture output from some tso command */\nIF &STR(&TOPIC) = ALL THEN +\n  DO\n    SET TOPIC = &STR()\n    SET LEVEL = 1\n    SET DEPTH&LEVEL = &STR(&TOPIC)\n  END\nELSE +\n  DO\n    IF &SYSDSN('SYS1.HELP(&TOPIC)') = &STR(OK) |        +\n       &SYSDSN('TSO.MVS.HELP(&TOPIC)') = &STR(OK) THEN +\n      DO\n        SET LEVEL = 1\n        SET DEPTH&LEVEL = &STR(&TOPIC)\n      END\n    ELSE +\n      DO\n        WRITE No help exists for &TOPIC\n        EXIT CODE(99)\n      END\n  END\n\nAGAIN: +\nSET &SYSOUTTRAP = 999     /* TURN ON AND CAPTURE 999 LINES OF OUTPUT */\nHELP &TOPIC\nSET &LINES = &SYSOUTLINE   /* GET NUMBER OF LINES CREATED BY COMMAND */\nSET &COUNT = 1\nSET DSC = 1\nDO WHILE(&DSC <= &LINES)\n  SET QQ = &&SYSOUTLINE&DSC\n  SET TABLE&DSC = &STR(&QQ)\n  SET DSC = &DSC + 1\nEND\nSET &SYSOUTTRAP = 0   /* turn off output line capture */\n\nCALL 'SASDDF.A.LOADLIB(WIN3270)'\nWA value=\\ type=label color=white hilite=none\nWA value=@ type=label color=blue hilite=uline\nWA value={ type=label color=yellow hilite=none\nWA value=% type=output color=red hilite=none\nWA value=! type=output color=blue hilite=none\nWA value=_ type=output color=cyan hilite=none\nWA value=$ type=input color=green hilite=none\nWC name=main\n\nWS 01 \\Help information for!DESCR                                   +\n{User:!SYSUID\nWS 02 \\Command ===>$zcmd                                            +\n{Time:!XTIME\nWS 03 %msg\nWS 04 @\nWS 05 _A1\nWS 06 _A2\nWS 07 _A3\nWS 08 _A4\nWS 09 _A5\nWS 10 _A6\nWS 11 _A7\nWS 12 _A8\nWS 13 _A9\nWS 14 _A10\nWS 15 _A11\nWS 16 _A12\nWS 17 _A13\nWS 18 _A14\nWS 19 _A15\nWS 20 _A16\nWS 21 _A17\nWS 22 _A18\nWS 23 _A19\nWS 24 _A20\nSET ROWMAX = 20\nSET SCRAMT = 10\nIF &WINSYSNR > 24 THEN +\n  DO\n    WS 25 _A21\n    WS 26 _A22\n    WS 27 _A23\n    SET ROWMAX = 23\n    SET SCRAMT = 12\n    IF &WINSYSNR > 27 THEN +\n      DO\n        WS 28 _A24\n        WS 29 _A25\n        WS 30 _A26\n        WS 31 _A27\n        WS 32 _A28\n        SET ROWMAX = 28\n        SET SCRAMT = 14\n        IF &WINSYSNR > 32 THEN +\n          DO\n            WS 33 _A29\n            WS 34 _A30\n            WS 35 _A31\n            WS 36 _A32\n            WS 37 _A33\n            WS 38 _A34\n            WS 39 _A35\n            WS 40 _A36\n            WS 41 _A37\n            WS 42 _A38\n            WS 43 _A39\n            SET ROWMAX = 39\n            SET SCRAMT = 18\n          END\n      END\n  END\n\nSET &TOPROW = 1\nSET ZCMD = &STR( )\nSET MSG = &STR(Help entry contains &DSC lines.)\nIF &TOPIC = THEN +\n  SET DESCR = &STR(all TSO commands)\nELSE SET DESCR = &STR(&TOPIC)\n\nDO WHILE(&SYSCAPS(&STR(&ZCMD))\u00ac=&STR(END))\n  /* subcommand to display the defined screen */\n  SET XTIME = &SYSTIME\n  SET ZCMD = &STR( )\n\n  /* fill display variables and display the captured output */\n  SET I = 1\n  DO WHILE(&I <= &ROWMAX)\n    SET TABP = &EVAL(&TOPROW+&I-1)\n    IF &TABP <= &DSC THEN +\n      DO\n        SET QQ = &&TABLE&TABP\n        SET A&I = &STR(&QQ)\n      END\n    ELSE +\n        SET A&I = &STR( )\n    SET I = &I + 1\n  END\n  WD name=main row=1 col=1\n\n  /* process commands and function keys */\n  IF &WINSYSK = PF1 THEN                   /* drill down help */ +\n    DO\n      IF &STR(&WINSYST) \u00ac=  THEN +\n        DO\n          IF &SYSDSN('SYS1.HELP(&SYSCAPS(&WINSYST))') = &STR(OK) |  +\n             &SYSDSN('TSO.MVS.HELP(&TOPIC)') = &STR(OK) THEN        +\n            DO\n              SET DEPTH&LEVEL = &STR(&TOPIC)\n              SET LEVEL = &EVAL(&LEVEL+1)\n              SET TOPIC = &WINSYST\n              WE name=main\n              WX\n              GOTO AGAIN\n            END\n          ELSE +\n            SET MSG = &STR(No help for &WINSYST exists.)\n        END\n    END\n\n  IF &WINSYSK = PF3 THEN                   /* go back or exit */ +\n    DO\n      IF &LEVEL > 1 THEN +\n        DO\n          SET LEVEL = &EVAL(&LEVEL-1)\n          SET TOPIC = &&DEPTH&LEVEL\n          WE name=main\n          WX\n          GOTO AGAIN\n        END\n      ELSE +\n        SET ZCMD = &STR(END)               /* exit */\n    END\n  IF &WINSYSK = PF15 THEN                  /* go back or exit */  +\n    DO\n      IF &LEVEL > 1 THEN +\n        DO\n          SET LEVEL = &EVAL(&LEVEL-1)\n          SET TOPIC = &&DEPTH&LEVEL\n          WE name=main\n          WX\n          GOTO AGAIN\n        END\n      ELSE +\n        SET ZCMD = &STR(END)               /* exit */\n    END\n\n  IF &WINSYSK = PF4 THEN +\n    SET ZCMD = &STR(END)                   /* return = exit */\n  IF &WINSYSK = PF16 THEN +\n    SET ZCMD = &STR(END)\n\n  IF &WINSYSK = PF19 THEN +\n    DO\n      SET MSG = &STR( )\n      SET TOPROW = &EVAL(&TOPROW - &SCRAMT)      /* up */\n      IF &TOPROW < 1 THEN +\n        DO\n          SET TOPROW = 1\n          SET MSG = &STR(At top.)\n        END\n    END\n\n  IF &WINSYSK = PF20 THEN +\n    DO\n      SET MSG = &STR( )\n      SET LSTTOP = &TOPROW                  /* down */\n      SET TOPROW = &EVAL(&TOPROW + &SCRAMT)\n      IF &TOPROW > &DSC THEN +\n        DO\n          SET TOPROW = &LSTTOP\n          SET MSG = &STR(At bottom.)\n        END\n    END\nEND\n\n  /* subcommand to erase the screen */\nFIN:  +\n  WE name=main\n  /* subcommand end WIN3270 */\n  WX\n\nEXIT\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "COMBO32": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x95(\\x9f\\x00\\x95(\\x9f\\x16I\\x0bJ\\x0bJ\\x00\\x00\\xe2\\xc1\\xe2\\xc4\\xc4\\xc6@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1995-10-16T00:00:00", "modifydate": "1995-10-16T16:49:00", "lines": 2890, "newlines": 2890, "modlines": 0, "user": "SASDDF"}, "text": "#pragma eject\n#pragma title combo32.c - display a combo box on a 3270 device\n\n/*+-----------------------------------------------------------------+\n  | Program:   combo32.c                                            |\n  | Language:  c                                                    |\n  | Support:   DAF                                                  |\n  | Purpose:   To learn some full screen 3270 coding techniques to  |\n  |            use on the IBM 3270 display station.                 |\n  |                                                                 |\n  |            The following publications have been used in the     |\n  |            developement of this program:                        |\n  |              SC28-1875 TSO/E v2 programming Services            |\n  |              GA23-0059 3270 Info. Display Sys. Data Stream      |\n  |                        Programmers Reference.                   |\n  |              GA27-3831 3174 Establishment Controller Character  |\n  |                        Set Reference.                           |\n  |              GA27-2837 3270 Character Set Reference.            |\n  |              HUR 9058  IBM3270 Personal Computer Graphics       |\n  |                        Control Program Data Stream Reference.   |\n  |              GA18-2589 IBM 3179-G/3192-G Color Graphics Display |\n  |                        Station Description.                     |\n  |              GG27-6999 Introduction to Programming the IBM 3270.|\n  |                                                                 |\n  |            This programs main routine creates a simple notepad  |\n  |            window on the 3270. It uses routines to build the    |\n  |            notepad that support the creation, modification,     |\n  |            removal, and display of fields on the 3270 screen.   |\n  |            A screen is represented as linked list of fields.    |\n  |            These field routines can be viewed as an API that    |\n  |            the main program (application) uses to create windows|\n  |            on the 3270. The application is freed from managing  |\n  |            things like buffer address translation, and data     |\n  |            stream creation, and inbound data stream parsing.    |\n  |            Varying length strings are represented by the data   |\n  |            type LSTR. These strings can contain amy amount of   |\n  |            data including the null character.                   |\n  |                                                                 |\n  |            The following techniques have not been implemented   |\n  |            in this program but will be added later:             |\n  |            - Data stream compression using RBA.                 |\n  |            - Graphics support.                                  |\n  |                                                                 |\n  | Notes:     1. Numeric fields do not work the same on all        |\n  |               devices. The 3192-G allows lowercase character    |\n  |               input. Many devices also upper case character     |\n  |               input.                                            |\n  |            2. Most devices do not support field attributes:     |\n  |               Field Outlining, Background color, and Field      |\n  |               Validation.                                       |\n  |            3. The character set for APL does not appear to be   |\n  |               allowed on the SFE order, only on the SA order.   |\n  | End.                                                            |\n  +-----------------------------------------------------------------+*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <svc.h>\n#include <tput.h>\n#include <ostask.h>\n\n#define _AMODE31\n\n#include \"ps9x16u.inc\"\n#include \"ps9x15u.inc\"\n#include \"ps9x12u.inc\"\n\n/* escape character and device commands */\n#define ESC     0x27\n#define EW      0xf5\n#define EWA     0x7e\n#define WRT     0xf1\n#define WSF     0xf3\n#define RB      0xf2\n\n/* write control characters, or'd together as required */\n#define WCCMDT  0x01\n#define WCCKBD  0x02\n#define WCCRES  0xc0\n#define WCCBEL  0x04\n\n/* 3270 data stream orders */\n#define GE      0x08\n#define FF      0x0c\n#define CRR     0x0d\n#define SBA     0x11\n#define EUA     0x12\n#define ICUR    0x13\n#define NL      0x15\n#define EM      0x19\n#define DUP     0x1c\n#define SF      0x1d\n#define FM      0x1e\n#define SA      0x28\n#define SFE     0x29\n#define MF      0x2c\n#define RA      0x3c\n#define SUB     0x3f\n\n#define PROT    0x20\n#define NUM     0x10\n\n/* Type byte of the SA, SFE and MF orders */\n#define ALL     0x00\n#define NONE    0x00\n#define DFLT    0x00\n\n#define ATTR    0xc0\n#define FVALID  0xc1\n#define OUTLIN  0xc2\n#define HILITE  0x41\n#define COLOR   0x42\n#define SYMSET  0x43\n#define BAKCOL  0x45\n#define TRANSP  0x46\n\n#define APL     0xF1\n\n/* Out lines for the value byte of the SA, SFE, or MF order */\n#define UNDR    0x01\n#define OVR     0x04\n#define OVRUND  0x05\n#define NOOVR   0x0b\n#define NOUNDR  0x0e\n#define RECT    0x0f\n\n/* Hilites for the value byte of the SA, SFE, or MF order */\n#define BLINK   0xf1\n#define RVIDEO  0xf2\n#define USCORE  0xf4\n\n/* Colors for the value byte of the SA, SFE, or MF order */\n#define BLUE    0xf1\n#define RED     0xf2\n#define PINK    0xf3\n#define GREEN   0xf4\n#define TURQ    0xf5\n#define CYAN    0xf5\n#define YELLOW  0xf6\n#define WHITE   0xf7\n\n/* Attribute for the value byte of the SF, SFE and MF order */\n#define UNPRT   0x40\n#define UNNUM   0x50\n#define UNNUMHI 0xd8\n#define UNNON   0x4c\n#define UNHI    0xc8\n#define PRT     0x60\n#define PRTHI   0xe4\n#define PRTAS   0xf0\n#define PRTHIAS 0xf8\n\n/* Attention Identification (AID) Values */\n#define NOAID   0x60\n#define NOAIDP  0xe8\n#define STRFLD  0x88\n#define ENTER   0x7d\n#define PF1     0xf1\n#define PF2     0xf2\n#define PF3     0xf3\n#define PF4     0xf4\n#define PF5     0xf5\n#define PF6     0xf6\n#define PF7     0xf7\n#define PF8     0xf8\n#define PF9     0xf9\n#define PF10    0x7a\n#define PF11    0x7b\n#define PF12    0x7c\n#define PF13    0xc1\n#define PF14    0xc2\n#define PF15    0xc3\n#define PF16    0xc4\n#define PF17    0xc5\n#define PF18    0xc6\n#define PF19    0xc7\n#define PF20    0xc8\n#define PF21    0xc9\n#define PF22    0x4a\n#define PF23    0x4b\n#define PF24    0x4c\n#define OID     0xe6\n#define MAG     0xe7\n#define PEN     0x7e\n#define PA1     0x6c\n#define PA2     0x6e\n#define PA3     0x6b\n#define CLEAR   0x6d\n#define SYSREQ  0xf0\n\ntypedef\n  struct LSTR     /* string with length */\n  {\n    int len ;             /* current length of data */\n    char *data ;          /* pointer to data */\n  } TLSTR ;\n\ntypedef\n  struct SFLD     /* 3270 screen field information list entry */\n  {\n    int fid ;             /* unique field identifier */\n    TLSTR fdata ;         /* field data (input or output) */\n    int fxpos ;           /* X column position */\n    int fypos ;           /* Y row position */\n    char fattr ;          /* 3270 field attribute */\n    char fcolor ;         /* 3270 color attribute */\n    char fhilite ;        /* 3270 hilite attribute */\n    char symbol ;         /* 0x00=normal 0xf1=APL else 0x40-0xef=PS */\n    struct SFLD *next ;   /* next list entry */\n  } TSFLD ;\n\n#define BUFFMAX 5000\nchar *buffer ;    /* buffer area for tput/tget */\n\nTSFLD *screen ;   /* root of 3270 screen field list */\n\n#define SFIDMAX 256\nTSFLD *sfidtab\u00ddSFIDMAX\u00a8 ; /* field id address table */\nint fidnext = 0 ;         /* next field id number to assign */\nint curcol = 1 ;          /* current cursor column */\nint currow = 1 ;          /* current cursor row */\nint bellflg = 0 ;         /* ring bell on next display */\nint iotrace = 0 ;         /* trace terminal I/O flag */\n\n\nstruct DCB        /* Device control block */\n  {\n    int model ;         /* model number ie: 3279, 3278, 3277 */\n    int type ;          /* model type ie: 2, 3, 4, 5 */\n    int rows ;          /* number of rows (height) on device */\n    int cols ;          /* number of columns (width) on device */\n    int celheigh ;      /* cell height on device */\n    int celwidth ;      /* cell width on device */\n    int colors ;        /* number of colors on device */\n    int colora ;        /* number of actual colors on device */\n    int hilites ;       /* number of colors on device */\n    int adrmode ;       /* device addressing mode: 12 or 14 or 16 bit*/\n    char unit ;         /* 0 = inch 1 = mm */\n    char edsflg ;       /* extended data stream flag */\n    char psflg ;        /* program symbols on device flag */\n    char altflg ;       /* use alternate flag */\n    char aplflg ;       /* 0 or apl's lcid=supports APL on device */\n    char graflg ;       /* graphics device flag */\n    char loadflg ;      /* loadable symbol sets supported flag */\n    char triflg ;       /* triple plane symbol sets supported flag */\n    char dbcsflg ;      /* double byte characters supported flag */\n    char colorlst\u00dd17\u00a8 ; /* list of color attributes on device */\n    char hilitlst\u00dd5\u00a8 ;  /* list of hilite attributes on device */\n    char modname\u00dd11\u00a8 ;  /* name of device ie: IBM32793B IBM3179G ..*/\n  } sdcb ;\n\n\n\n/*-------------------------------------------------------------------*/\n/* Function Prototypes                                               */\n/*-------------------------------------------------------------------*/\n\n/* field handling */\nint initscr() ;\nvoid termscr() ;\nchar dspflds() ;\nint insfld(TLSTR *, int, int, char, char, char) ;\nint getdev() ;\nint remflds() ;\nint delfld(int) ;\nint erasefld(int) ;\nint getfld(int, TLSTR *) ;\nint modfld(int, TLSTR *) ;\nint setfld(int, int, char) ;\nvoid dumpfld() ;\n/* 3270 support */\nint tputn(char *, int) ;\nint tgetn(char *, int) ;\nint tpgn(char *, int) ;\nvoid rc2sba(int, int, char *) ;\nvoid sba2rc(char *, int *, int *, int) ;\nint modsym(char *, char) ;\nint modcolor(char *, char) ;\nint modhilit(char *, char) ;\nint modattr(char *, char) ;\nint getterm(int *, int *, int *, int *, int *) ;\nint querydev() ;\nint dsummary(char *, short) ;\nint darea(char *, short) ;\nint dcharset(char *, short) ;\nint dcolor(char *, short) ;\nint dhilite(char *, short) ;\nint dmodes(char *, short) ;\nint dimpart(char *, short) ;\nint loadps1() ;\nvoid termstat() ;\nvoid clear() ;\n/* varying length string */\nvoid lstran(TLSTR *, char, char) ;\nint lstrlen(TLSTR *) ;\nvoid lstrload(TLSTR *, char *, int) ;\nint lstrunld(char *, TLSTR *) ;\nvoid lstrcopy(TLSTR *, TLSTR *) ;\nvoid lstrnew(TLSTR *, char *) ;\nvoid lstrsub(TLSTR *, TLSTR *, int, int) ;\nint lstrindx(TLSTR *, TLSTR *) ;\nvoid lstrfill(TLSTR *, char *) ;\nint lstrcmpc(TLSTR *, char *) ;\nvoid lstrdel(TLSTR *) ;\nvoid lstrrep(TLSTR *, char *, int) ;\nvoid lstrcat(TLSTR *, TLSTR *, TLSTR *) ;\n/* utility */\nvoid fill(char *, char, int) ;\nvoid dumpchar(char *, int) ;\nvoid overlay(char *, int, char *, int, int) ;\nvoid serror(int, char *) ;\n\n\n/* application routines */\nvoid buildwin() ;\nvoid dispwin() ;\nvoid winmsg(char *) ;\n\n/* variables for application */\nint cmdfid ;       /* field identifier for command line */\nint msgfid ;       /* field identifier for message line */\nint bt ;           /* top border */\nint bb ;           /* bottom border */\nint bl ;           /* left border */\nint br ;           /* right border */\nint cmdflg = 0 ;   /* command flag = true if command done */\n\n /*-----------------------------------------------------------------*\n  | Main Program                                                    |\n  *-----------------------------------------------------------------*/\nvoid main(int argc, char **argv, char **envp)\n  {\n    int rc ;        /* return code */\n\n    rc = initscr() ;  /* initialise environment */\n    if (rc==0)         /* if env OK */\n      {\n        /* initial border positions */\n        bt = 1 ;            /* top border */\n        bb = sdcb.rows ;    /* bottom border */\n        bl = 1 ;            /* left border */\n        br = sdcb.cols ;    /* right border */\n\n        /* indicate cursor on command field and set field to blank */\n        cmdflg = 1 ;\n\n        buildwin() ;  /* build the initial display window */\n        dispwin() ;   /* display the window and run appl. */\n\n        termscr() ;   /* terminate environment */\n      }\n  }\n\n\n/*-------------------------------------------------------------------*/\n/* Build a window with a title, command line and an edit space.      */\n/*-------------------------------------------------------------------*/\nvoid buildwin()\n  {\n    int t, tl ;                /* temp */\n    int i ;                    /* counter */\n    int fid ;                  /* field identifier handle */\n    TLSTR data, data1, data2, data3, data4 ; /* temp varying strings */\n    TLSTR title ;              /* title string */\n\n    /* create title line */\n    lstrnew(&title,\" COMBO32: 3270 Combo box test\");\n\n    /* create command line (prompt, input area, and help) */\n    lstrnew(&data,\"Command ===>\") ;   /* create VLstring */\n    fid = insfld(&data,bt+1,bl+2,PRT,WHITE,NONE);\n    if (fid<0) serror(81,\"Field insert failed\") ;\n    lstrnew(&data,\" \") ;   /* create VLstring */\n    cmdfid = insfld(&data,bt+1,bl+15,UNPRT,GREEN,NONE);\n    if (cmdfid<0) serror(81,\"Field insert failed\") ;\n    if ((br-bl)>18)\n      {\n        lstrnew(&data,\"PF1=Help PF3=End\") ;   /* create VLstring */\n        fid = insfld(&data,bt+1,br-18,PRT,WHITE,NONE);\n        if (fid<0) serror(81,\"Field insert failed\") ;\n      }\n\n    /* create message line */\n    lstrnew(&data,\" \") ;   /* create VLstring */\n    msgfid = insfld(&data,bt+2,bl+2,PRTHI,RED,NONE);\n    if (msgfid<0) serror(81,\"Field insert failed\") ;\n\n    /*----------------------------------------------------------------*/\n    /* Create top window border                                       */\n    /*   The border outline is drawn with different characters        */\n    /*     based on the devices abilities.                            */\n    /*   Window border locations are based on four global variables:  */\n    /*     bt - top border row                                        */\n    /*     bb - bottom border row                                     */\n    /*     br - right border column                                   */\n    /*     bl - left border column                                    */\n    /*----------------------------------------------------------------*/\n    if (sdcb.loadflg)\n      {\n        lstrnew(&data1,\"\\x42\\x47\") ;     /* top left corner */\n        lstrnew(&data2,\"\\x48\\x46\\x45\\x44\") ; /* top right corner */\n        lstrnew(&data3,\" \") ;\n        lstran(&title,0x40,0x48) ;      /* translate in PS blank char */\n        tl = lstrlen(&title) ; /* actual title length */\n        t = br-bl-5 ;           /* available space */\n        if (tl>t)\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrsub(&data3,&title,1,t-1) ; /* shorten title */\n            lstrcat(&data,&data,&data3) ;  /* add title */\n            lstrcat(&data,&data,&data2) ;  /* add right border */\n          }\n        else\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrcat(&data,&data,&title) ;  /* add title */\n            lstrrep(&data3,\"\\x48\",t-tl-1) ;/* repeat char to string */\n            lstrcat(&data,&data,&data3) ;  /* add top border chars */\n            lstrcat(&data,&data,&data2) ;  /* concat strings */\n          }\n        fid = insfld(&data,bt,bl,PRTAS,BLUE,NONE);\n        if (fid<0) serror(81,\"Field insert failed\") ;\n        setfld(fid,SYMSET,0x40) ;   /* make it id of PS symbols */\n      }\n    else if (sdcb.aplflg)\n      {\n        lstrnew(&data1,\"\\xc5\\xee\") ;     /* top left corner */\n        lstrnew(&data2,\"\\xa2\\xba\\xbb\\xd5\") ;   /* top right corner */\n        tl = lstrlen(&title) ; /* actual title length */\n        t = br-bl-5 ;           /* available space */\n        if (tl>t)\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrsub(&data4,&title,1,t-1) ; /* shorten title */\n            lstrnew(&data3,\"\\x28\\x43\\x01\") ;  /* stop APL chars */\n            lstran(&data3,0x01,0x00) ; /* translate 0x01 to ox00 */\n            lstrcat(&data,&data,&data3) ;  /* add stop APL */\n            lstrcat(&data,&data,&data4) ;  /* add title */\n            lstrnew(&data3,\"\\x28\\x43\\xf1\") ;  /* start APL */\n            lstrcat(&data,&data,&data3) ;  /* add start APL */\n            lstrcat(&data,&data,&data2) ;  /* add right border */\n          }\n        else\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrnew(&data3,\"\\x28\\x43\\x01\") ;  /* stop APL chars */\n            lstran(&data3,0x01,0x00) ; /* translate 0x01 to ox00 */\n            lstrcat(&data,&data,&data3) ;  /* add stop APL */\n            lstrcat(&data,&data,&title) ;  /* add title */\n            lstrnew(&data3,\"\\x28\\x43\\xf1\") ;  /* start APL */\n            lstrcat(&data,&data,&data3) ;  /* add start APL */\n            lstrrep(&data3,\"s\",t-tl-1) ;   /* repeat char to string */\n            lstrcat(&data,&data,&data3) ;  /* add top border chars */\n            lstrcat(&data,&data,&data2) ;  /* concat strings */\n          }\n        fid = insfld(&data,bt,bl,PRTAS,BLUE,NONE);\n        if (fid<0) serror(81,\"Field insert failed\") ;\n        setfld(fid,SYMSET,APL) ; /* make it APL */\n      }\n    else\n      {\n        lstrnew(&data1,\"+#\") ;     /* create VLstring */\n        lstrnew(&data2,\"-VA+\") ;   /* create VLstring */\n        lstrnew(&data3,\" \") ;\n        tl = lstrlen(&title) ;     /* actual title length */\n        t = br-bl-5 ;              /* available space */\n        if (tl>t)\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrsub(&data4,&title,1,t-1) ; /* shorten title */\n            lstrcat(&data,&data,&data4) ;  /* add title */\n            lstrcat(&data,&data,&data2) ;  /* add right border */\n          }\n        else\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrcat(&data,&data,&title) ;  /* add title */\n            lstrrep(&data3,\"-\",t-tl-1) ;   /* repeat char to string */\n            lstrcat(&data,&data,&data3) ;  /* add top border chars */\n            lstrcat(&data,&data,&data2) ;  /* concat strings */\n          }\n        fid = insfld(&data,bt,bl,PRTAS,BLUE,NONE);\n        if (fid<0) serror(81,\"Field insert failed\") ;\n      }\n\n    /* create edit area lines and left and right borders */\n    for (i=bt+1; i<=bb-1; i++)    /* edit area fields */\n      {\n        /* add left border */\n        if (sdcb.loadflg)\n          {\n            lstrnew(&data,\"\\x71\") ;\n            fid = insfld(&data,i,bl,PRTAS,BLUE,NONE) ;\n            if (fid<0) serror(81,\"Field insert failed\") ;\n            setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n          }\n        else if (sdcb.aplflg)\n          {\n            lstrnew(&data,\"e\") ;\n            fid = insfld(&data,i,bl,PRTAS,BLUE,NONE) ;\n            if (fid<0) serror(81,\"Field insert failed\") ;\n            setfld(fid,SYMSET,APL) ; /* make it APL */\n          }\n        else\n          {\n            lstrnew(&data,\"|\") ;\n            fid = insfld(&data,i,bl,PRTAS,BLUE,NONE) ;\n            if (fid<0) serror(81,\"Field insert failed\") ;\n          }\n\n        /* add right border */\n        if (sdcb.loadflg)\n          {\n            lstrnew(&data,\"\\x71\") ;\n            fid = insfld(&data,i,br-1,PRTAS,BLUE,NONE) ;\n            if (fid<0) serror(81,\"Field insert failed\") ;\n            setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n          }\n        else if (sdcb.aplflg)\n          {\n            lstrnew(&data,\"e\") ;\n            fid = insfld(&data,i,br-1,PRTAS,BLUE,NONE) ;\n            if (fid<0) serror(81,\"Field insert failed\") ;\n            setfld(fid,SYMSET,APL) ; /* make it APL */\n          }\n        else\n          {\n            lstrnew(&data,\"|\") ;\n            fid = insfld(&data,i,br-1,PRTAS,BLUE,NONE) ;\n            if (fid<0) serror(81,\"Field insert failed\") ;\n          }\n      }  /* of for edit area lines */\n\n    /* create bottom border */\n    if (sdcb.loadflg)\n      {\n        lstrnew(&data1,\"\\x67\") ;       /* lower left corner */\n        lstrnew(&data2,\"\\x69\") ;       /* lower right corner */\n        lstrrep(&data,\"\\x70\",br-bl-2) ;/* lower border chars */\n        lstrcat(&data,&data1,&data) ;  /* concat strings */\n        lstrcat(&data,&data,&data2) ;  /* concat strings */\n        fid = insfld(&data,bb,bl,PRTAS,BLUE,NONE) ;\n        if (fid<0) serror(81,\"Field insert failed\") ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n      }\n    else if (sdcb.aplflg)\n      {\n        lstrnew(&data1,\"D\") ;          /* lower left corner */\n        lstrnew(&data2,\"M\") ;          /* lower right corner */\n        lstrrep(&data,\"s\",br-bl-2) ;   /* lower border chars */\n        lstrcat(&data,&data1,&data) ;  /* concat strings */\n        lstrcat(&data,&data,&data2) ;  /* concat strings */\n        fid = insfld(&data,bb,bl,PRTAS,BLUE,NONE) ;\n        if (fid<0) serror(81,\"Field insert failed\") ;\n        setfld(fid,SYMSET,APL) ; /* make it APL */\n      }\n    else\n      {\n        lstrnew(&data1,\"+\") ;          /* lower left corner */\n        lstrnew(&data2,\"+\") ;          /* lower right corner */\n        lstrrep(&data,\"-\",br-bl-2) ;   /* lower border chars */\n        lstrcat(&data,&data1,&data) ;  /* concat strings */\n        lstrcat(&data,&data,&data2) ;  /* concat strings */\n        fid = insfld(&data,bb,bl,PRTAS,BLUE,NONE) ;\n        if (fid<0) serror(81,\"Field insert failed\") ;\n      }\n\n    /* create some widgets in the window */\n    if (sdcb.loadflg)\n      {\n        /* title static label */\n        lstrnew(&data1,\"Program Symbol Device Style\") ;\n        fid = insfld(&data1,bt+3,bl+15,PRTAS,PINK,USCORE) ;\n        lstrnew(&data1,\" \") ;\n        fid = insfld(&data1,bt+3,bl+43,PRTAS,PINK,NONE) ;\n\n\n        /* *** list box *** */\n        /* top */\n        lstrnew(&data1,\" \") ;   /* create VLstring */\n        fid = insfld(&data1,bt+5,bl+5,UNPRT,GREEN,USCORE);\n        lstrnew(&data1,\"\\xde\");\n        fid = insfld(&data1,bt+5,bl+21,UNPRT,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n        lstrnew(&data1,\n          \"\\xef\\xef\\xef\\xef\\xef\\xef\\xef\\xef\\xef\\xef\\xef\"\n          \"\\xef\\xef\\xef\\xef\\xef\\xef\");\n        fid = insfld(&data1,bt+6,bl+5,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n\n        lstrnew(&data1,\"\\x43\") ;\n        fid = insfld(&data1,bt+7,bl+5,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n        lstrnew(&data1,\"Selection 1  \") ;\n        fid = insfld(&data1,bt+7,bl+7,UNPRT,CYAN,NONE) ;\n        lstrnew(&data1,\"\\xdc\") ;\n        fid = insfld(&data1,bt+7,bl+21,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n\n        lstrnew(&data1,\"\\x43\") ;\n        fid = insfld(&data1,bt+8,bl+5,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n        lstrnew(&data1,\"Selection 2  \") ;\n        fid = insfld(&data1,bt+8,bl+7,UNPRT,CYAN,NONE) ;\n        lstrnew(&data1,\"\\xed\") ;\n        fid = insfld(&data1,bt+8,bl+21,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n\n        lstrnew(&data1,\"\\x43\") ;\n        fid = insfld(&data1,bt+9,bl+5,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n        lstrnew(&data1,\"Selection 3  \") ;\n        fid = insfld(&data1,bt+9,bl+7,UNPRT,CYAN,NONE) ;\n        lstrnew(&data1,\"\\xdb\") ;\n        fid = insfld(&data1,bt+9,bl+21,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n\n        lstrnew(&data1,\"\\x43\") ;\n        fid = insfld(&data1,bt+10,bl+5,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n        lstrnew(&data1,\"Selection 4  \") ;\n        fid = insfld(&data1,bt+10,bl+7,UNPRT,CYAN,RVIDEO) ;\n        lstrnew(&data1,\"\\xda\") ;\n        fid = insfld(&data1,bt+10,bl+21,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n\n        lstrnew(&data1,\"\\x43\") ;\n        fid = insfld(&data1,bt+11,bl+5,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n        lstrnew(&data1,\"Selection 5  \") ;\n        fid = insfld(&data1,bt+11,bl+7,UNPRT,CYAN,NONE) ;\n        lstrnew(&data1,\"\\xda\") ;\n        fid = insfld(&data1,bt+11,bl+21,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n\n        lstrnew(&data1,\"\\x43\") ;\n        fid = insfld(&data1,bt+12,bl+5,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n        lstrnew(&data1,\"Selection 6  \") ;\n        fid = insfld(&data1,bt+12,bl+7,UNPRT,CYAN,NONE) ;\n        lstrnew(&data1,\"\\xda\") ;\n        fid = insfld(&data1,bt+12,bl+21,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n\n        lstrnew(&data1,\"\\x43\") ;\n        fid = insfld(&data1,bt+13,bl+5,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n        lstrnew(&data1,\"Selection 7  \") ;\n        fid = insfld(&data1,bt+13,bl+7,UNPRT,CYAN,NONE) ;\n        lstrnew(&data1,\"\\xee\") ;\n        fid = insfld(&data1,bt+13,bl+21,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n\n        lstrnew(&data1,\"\\x43\") ;\n        fid = insfld(&data1,bt+14,bl+5,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n        lstrnew(&data1,\"Selection 8  \") ;\n        fid = insfld(&data1,bt+14,bl+7,UNPRT,CYAN,NONE) ;\n        lstrnew(&data1,\"\\xdd\") ;\n        fid = insfld(&data1,bt+14,bl+21,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n\n        /* bottom */\n        lstrnew(&data1,\n          \"\\xcd\\xeb\\x58\\x65\\x65\\x65\\x65\\x65\\x65\\x65\\x65\"\n          \"\\x65\\x65\\x65\\xec\\xcf\\xea\");\n        fid = insfld(&data1,bt+15,bl+5,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n\n      }\n    else if (sdcb.aplflg)\n      {\n        /* title static label */\n        lstrnew(&data1,\"APL Symbol Device Style\") ;\n        fid = insfld(&data1,bt+3,bl+15,PRTAS,PINK,USCORE) ;\n        lstrnew(&data1,\" \") ;\n        fid = insfld(&data1,bt+3,bl+39,PRTAS,PINK,NONE) ;\n\n\n\n      }\n    else\n      {\n        /* title static label */\n        lstrnew(&data1,\"Primitive Device Style\") ;\n        fid = insfld(&data1,bt+3,bl+15,PRTHIAS,PINK,USCORE) ;\n        lstrnew(&data1,\" \") ;\n        fid = insfld(&data1,bt+3,bl+38,PRTAS,PINK,NONE) ;\n\n\n      }\n  }\n\n\n/*-------------------------------------------------------------------*/\n/* Display the window and process the keys/commands entered.         */\n/*-------------------------------------------------------------------*/\nvoid dispwin()\n  {\n    TLSTR temp  ;        /* temp varying length string */\n    TLSTR command ;      /* command name varying length string */\n    char key ;           /* AID for the key just pressed */\n\n    lstrnew(&command,\" \") ;\n    while(lstrcmpc(&command,\"end\") != 0)\n      {\n        if (cmdflg)\n          {\n            /* set initial cursor row and col to the command field */\n            currow = bt + 1 ;\n            curcol = bl + 16 ;\n            /* blank out the command line */\n            lstrnew(&command,\" \") ;\n            modfld(cmdfid,&command) ;\n            cmdflg = 0 ;\n          }\n        key = dspflds() ;     /* display the screen and get aid=key */\n        lstrnew(&temp,\" \") ;\n        modfld(msgfid,&temp) ;    /* blank message line */\n        getfld(cmdfid,&command) ;  /* get the command line */\n\n        /* Process function keys PFKs */\n        switch (key)\n          {\n            case ENTER:\n              if (currow == bt) /* window border accelerators */\n                {\n                  if (curcol == (bl+2))  /* close window */\n                    {\n                      lstrnew(&command,\"end\") ;\n                    }\n                  else if (curcol == (br-2))  /* minimise window */\n                    {\n                      bt = 1 ;\n                      bl = 1 ;\n                      br = 48 ;\n                      bb = 20 ;\n                      remflds() ;\n                      buildwin() ;  /* re-build the display window */\n                      winmsg(\"Window minimised.\") ;\n                    }\n                  else if (curcol == (br-1))  /* maximise window */\n                    {\n                      bt = 1 ;\n                      bl = 1 ;\n                      br = sdcb.cols ;\n                      bb = sdcb.rows ;\n                      remflds() ;\n                      buildwin() ;  /* re-build the display window */\n                      winmsg(\"Window maximised.\") ;\n                    }\n                }\n              break ;\n            case PF1:    /* No help message */\n              winmsg(\n                \"Move border: PF23=Top PF11=Bottom PF10=Left PF12=Right\"\n                ) ;\n              break ;\n            case PF3:    /* Generate end command */\n            case PF15:   /* Alternate generate end command */\n              lstrnew(&command,\"end\") ;\n              break ;\n\n            case PF10:   /* move left border */\n              if ((curcol<(br-48)) &&\n                  (curcol>=1) )\n                {\n                  bl = curcol-1 ; /* adjust for attr byte */\n                  remflds() ;\n                  buildwin() ;  /* re-build the display window */\n                }\n              else\n                winmsg(\"Left border move position too far.\") ;\n              break ;\n\n            case PF11:   /* move bottom border */\n              if ((currow>(bt+20)) &&\n                  (currow<=sdcb.rows) )\n                {\n                  bb = currow ;\n                  remflds() ;\n                  buildwin() ;  /* re-build the display window */\n                }\n              else\n                winmsg(\"Bottom border move position too far.\") ;\n              break ;\n\n            case PF12:   /* move right border */\n              if ((curcol>(bl+48)) &&\n                 (curcol<=sdcb.cols) )\n                {\n                  br = curcol-1 ;  /* adjust for attr byte */\n                  remflds() ;\n                  buildwin() ;  /* re-build the display window */\n                }\n              else\n                winmsg(\"Right border move position too far.\") ;\n              break ;\n\n            case PF23:   /* move top border */\n              if ((currow<(bb-20)) &&\n                  (currow>=1) )\n                {\n                  bt = currow ;\n                  remflds() ;\n                  buildwin() ;  /* re-build the display window */\n                }\n              else\n                winmsg(\"Top border move position too far.\") ;\n              break ;\n\n            case PF24:   /* zoom to max window size */\n              bt = 1 ;\n              bl = 1 ;\n              br = sdcb.cols ;\n              bb = sdcb.rows ;\n              remflds() ;\n              buildwin() ;  /* re-build the display window */\n              break ;\n\n            case PA2:    /* reshow key does nothing - yet */\n              break ;\n\n            default:     /* any other key is not valid */\n              bellflg = 1 ;  /* sound alarm */\n              winmsg(\"Invalid function key.\") ;\n              break ;\n          }\n\n        /* Process command from the command line */\n        if (lstrcmpc(&command,\"test\") == 0)   /* test command */\n          {\n            winmsg(\"The test command was entered.\") ;\n            cmdflg = 1 ;  /* reset command line */\n          }\n        else if (lstrcmpc(&command,\"dump\") == 0)  /* dump command */\n          {\n            dumpfld() ;\n            winmsg(\"Dump command executed.\") ;\n            cmdflg = 1 ;  /* reset command line */\n          }\n        else if (lstrcmpc(&command,\"load\") == 0)  /* force load PS */\n          {\n            loadps1() ;\n            winmsg(\"Load PS type 1 command executed.\") ;\n            cmdflg = 1 ;  /* reset command line */\n          }\n        else if (lstrcmpc(&command,\"termstat\") == 0) /*dump term data*/\n          {\n            termstat() ;\n            winmsg(\"Terminal status printed.\") ;\n            cmdflg = 1 ;  /* reset command line */\n          }\n        else if (lstrcmpc(&command,\"traceon\") == 0) /* trace on */\n          {\n            iotrace = 1 ;\n            winmsg(\"Trace is on.\") ;\n            cmdflg = 1 ;  /* reset command line */\n          }\n        else if (lstrcmpc(&command,\"traceoff\") == 0) /* trace off */\n          {\n            iotrace = 0 ;\n            winmsg(\"Trace is off.\") ;\n            cmdflg = 1 ;  /* reset command line */\n          }\n\n      }   /* of while command not end */\n    clear() ;   /* clear the 3270 screen */\n  }\n\n\n/*-------------------------------------------------------------------*/\n/* Display the window and process the keys/commands entered.         */\n/*-------------------------------------------------------------------*/\nvoid winmsg(char *msg)\n  {\n    TLSTR msgstr  ;     /* message varying length string */\n\n    lstrnew(&msgstr,msg) ;\n    modfld(msgfid,&msgstr) ;\n  }\n\n/*********************************************************************/\n/* 3270 field handling routines                                      */\n/*   rc = initscr()                                                  */\n/*   termscr()                                                       */\n/*   fid = insfld(data,row,col,attr,color,hilite)                    */\n/*   rc = remflds()                                                  */\n/*   rc = delfld(fid)                                                */\n/*   rc = erasefld(fid)                                              */\n/*   rc = getfld(fid,returndata)                                     */\n/*   rc = modfld(fid,newdata)                                        */\n/*   rc = setfld(fid,attrtype,attrvalue)                             */\n/*   dumpflds()                                                      */\n/*                                                                   */\n/*********************************************************************/\n\n\n/*-------------------------------------------------------------------*/\n/* Set up the screen environment.                                    */\n/*-------------------------------------------------------------------*/\nint initscr()\n{\n    int rc = 0 ;\n\n    buffer = (char *)malloc(BUFFMAX) ;  /* alloc tput/get buffer */\n    if (buffer)\n      {\n        rc = getdev() ;  /* get3270 device information */\n        if (rc==0 && sdcb.loadflg==1)\n          loadps1() ;\n      }\n    else\n      rc = 1 ;   /* could not get buffer */\n\n    return rc ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Terminate screen environment.                                     */\n/*-------------------------------------------------------------------*/\nvoid termscr()\n{\n    if (screen)\n      remflds() ;       /* remove any remaining fields */\n\n    free((char *)buffer) ;  /* remove tput/get buffer */\n}\n\n/*-------------------------------------------------------------------*/\n/* Display current contents of the 3270 field list.                  */\n/*-------------------------------------------------------------------*/\nchar dspflds()\n{\n  TSFLD *curr ;\n  int rc, bufpos, trow = 0, tcol = 0, fstart, fend, ilen ;\n  char sba\u00dd2\u00a8 ;\n  char aid ;\n\n  /* assemble buffer, it will contain: (EW WCC) followed by all  */\n  /* the display fields. Each field will contain:                */\n  /*   (SFE 0x03 0xC0 fattr HILITE fhilite COLOR fcolor data)    */\n  if (sdcb.altflg)\n    buffer\u00dd0\u00a8 = EWA ;     /* erase write alternate */\n  else\n    buffer\u00dd0\u00a8 = EW ;      /* erase write */\n\n  /* determine if the bell should be rung */\n  if (bellflg)\n    {\n      buffer\u00dd1\u00a8 = WCCRES | WCCKBD | WCCMDT | WCCBEL ;\n      bellflg = 0 ;  /* turn bell flag off, one ring only */\n    }\n  else\n    buffer\u00dd1\u00a8 = WCCRES | WCCKBD | WCCMDT ;\n\n  bufpos = 2 ;\n  curr = screen ;     /* first node in field list */\n  while (curr)\n    {\n      buffer\u00ddbufpos++\u00a8 = SBA ;  /* set buffer address */\n      rc2sba(curr->fypos,curr->fxpos,sba) ;\n      buffer\u00ddbufpos++\u00a8 = sba\u00dd0\u00a8 ;\n      buffer\u00ddbufpos++\u00a8 = sba\u00dd1\u00a8 ;\n      if (sdcb.edsflg)\n        {\n          buffer\u00ddbufpos++\u00a8 = SFE ;  /* start field extended */\n          buffer\u00ddbufpos++\u00a8 = 0x03 ;\n          buffer\u00ddbufpos++\u00a8 = 0xc0 ;\n          buffer\u00ddbufpos++\u00a8 = curr->fattr ;\n          buffer\u00ddbufpos++\u00a8 = HILITE ;\n          buffer\u00ddbufpos++\u00a8 = curr->fhilite ;\n          buffer\u00ddbufpos++\u00a8 = COLOR ;\n          buffer\u00ddbufpos++\u00a8 = curr->fcolor ;\n\n          /* insert set character attribute before data if APL/PS syms*/\n          /* are required and the field has protection turned on.     */\n          if (((curr->symbol==APL) || (curr->symbol==0x40)) /*APL/PS*/\n            && (curr->fattr & 0x40)) /* and protected field */\n            {\n              buffer\u00ddbufpos++\u00a8 = SA ;           /* set attribute */\n              buffer\u00ddbufpos++\u00a8 = SYMSET ;       /* symbol */\n              if (curr->symbol==APL) /* APL ? */\n                buffer\u00ddbufpos++\u00a8 = sdcb.aplflg ; /* use APL's lcid */\n              else\n                buffer\u00ddbufpos++\u00a8 = curr->symbol ; /* use symbol value */\n            }\n        }\n      else    /* dont used extended data stream */\n        {\n          buffer\u00ddbufpos++\u00a8 = SF ;  /* start field */\n          buffer\u00ddbufpos++\u00a8 = curr->fattr ;\n        }\n\n      /* insert field data */\n      ilen = lstrunld(&buffer\u00ddbufpos\u00a8,&curr->fdata) ;\n      bufpos = bufpos + ilen ;\n\n      /* revert to standard symbols after APL/PS data symbols  */\n      if (((curr->symbol==APL) || (curr->symbol==0x40)) /*APL/PS*/\n        && (curr->fattr & 0x40)) /* and protected field */\n        {\n          buffer\u00ddbufpos++\u00a8 = SA ;       /* set attribute */\n          buffer\u00ddbufpos++\u00a8 = SYMSET ;   /* symbol */\n          buffer\u00ddbufpos++\u00a8 = DFLT ;     /* revert to default symbols */\n        }\n\n      curr = curr->next ;  /* go to next field */\n    }\n\n  /* insert the cursor in the same location the user left it */\n  buffer\u00ddbufpos++\u00a8 = SBA ;     /* add set buffer address order */\n  rc2sba(currow,curcol,sba) ;  /* determine SBA for current row/col */\n  buffer\u00ddbufpos++\u00a8 = sba\u00dd0\u00a8 ;  /* add buffer addr part 1 */\n  buffer\u00ddbufpos++\u00a8 = sba\u00dd1\u00a8 ;  /* add buffer addr part 2 */\n  buffer\u00ddbufpos++\u00a8 = ICUR ;    /* add insert cursor order */\n\n  /* dumpchar(buffer,bufpos) ; */\n\n  /* write buffer to the 3270 */\n  rc = tputn(buffer, bufpos) ;\n\n  fill(buffer,0x00,bufpos) ;\n  /* receive the response from the user */\n  rc = tgetn(buffer, BUFFMAX ) ;\n\n  /* decode input, should be an AID, a cursor pos bufferaddr */\n  /* and a list of fields (SBA addr1 addr2 data)             */\n\n  aid = buffer\u00dd0\u00a8 ;      /* get code of key that was pressed */\n  sba\u00dd0\u00a8 = buffer\u00dd1\u00a8 ;\n  sba\u00dd1\u00a8 = buffer\u00dd2\u00a8 ;\n  sba2rc(sba,&currow,&curcol,0) ;  /* convert and store cursor pos */\n                                   /* adjust = 0 used for cursor pos */\n\n  curr = screen ;\n  fstart = 0 ;\n  bufpos = 3 ;\n  while(bufpos<=BUFFMAX)\n    {\n      if (buffer\u00ddbufpos\u00a8==SBA)\n        {\n          /* get new buffer address */\n          bufpos++ ;\n          sba\u00dd0\u00a8 = buffer\u00ddbufpos++\u00a8 ;\n          sba\u00dd1\u00a8 = buffer\u00ddbufpos++\u00a8 ;\n          sba2rc(sba,&trow,&tcol,1) ; /* convert buf.addr to row/col */\n                              /* adjust = 1 used for retn. buf. addr */\n          fstart = bufpos ;\n\n          /* locate field by r/c then write data to field list entry */\n          while( !((curr->fxpos==tcol) && (curr->fypos==trow)) )\n            {                          /* locate */\n              curr = curr->next ;\n              if (!curr) break ; /* could not locate - real bad */\n            }\n\n          if (curr)    /* found field - copy the data into it */\n            {\n              /* first locate end of data */\n              fend = fstart ;\n              while ((buffer\u00ddfend\u00a8 != SBA) &&\n                     (buffer\u00ddfend\u00a8 != 0x00))\n                fend++ ;  /* leaves fend pointing at next char. */\n\n              /* copy data from buffer into field list */\n              ilen = fend - fstart ;\n              lstrload(&curr->fdata,&buffer\u00ddfstart\u00a8,ilen) ;\n\n              /* adjust bufpos to last char of this returned SBA */\n              bufpos = fend -1 ;\n            }\n          else\n            {\n              /* SEVERE ERROR: This should never happen */\n              printf(\"No locate field: row %d col %d SBA %.2X %.2X\\n\",\n                trow,tcol,sba\u00dd0\u00a8,sba\u00dd1\u00a8) ;\n              curr = screen ;  /* further searches from top */\n            }\n        }\n      else\n        bufpos++ ;   /* advance to next char */\n    }\n\n  return aid ;    /* data returned OK */\n}\n\n\n/*-------------------------------------------------------------------*/\n/* Dump field list to stdout.                                        */\n/*-------------------------------------------------------------------*/\nvoid dumpfld()\n{\n  TSFLD *curr ;\n  int i = 0, size = 0 ;\n  char sba\u00dd2\u00a8 ;\n\n  printf(\"Field list follows:\\n\") ;\n  curr = screen ;     /* first node in field list */\n  while (curr)\n    {\n      printf(\"  Field at row %d col %d\\n\",curr->fypos,curr->fxpos) ;\n      rc2sba(curr->fypos,curr->fxpos,sba) ;\n      printf(\"    BufAddr: %.2X %.2X \",sba\u00dd0\u00a8,sba\u00dd1\u00a8) ;\n      printf(\"Attrib: %.2X \",curr->fattr) ;\n      printf(\"Hilite: %.2X \",curr->fhilite) ;\n      printf(\"Color: %.2X \",curr->fcolor) ;\n      printf(\"Symbol: %.2X \",curr->symbol) ;\n      printf(\"DataLen: %d\\n\",curr->fdata.len) ;\n      printf(\"    Data dump: \\n\") ;\n      dumpchar(curr->fdata.data,curr->fdata.len) ;\n      size = size + curr->fdata.len  + 11 ;\n      i++ ;\n      curr = curr->next ;\n    }\n  printf(\"Total fields %d, buffer size required %d\\n\",i,size) ;\n}\n\n\n/*-------------------------------------------------------------------*/\n/* Print terminal status.                                            */\n/*-------------------------------------------------------------------*/\nvoid termstat()\n{\n  printf(\"Terminal status follows:\\n\") ;\n  printf(\"  Device name.........: %s\\n\",sdcb.modname) ;\n  printf(\"  Device model........: %d\\n\",sdcb.model) ;\n  printf(\"  Device type.........: %d\\n\",sdcb.type) ;\n  printf(\"  Addressing mode.....: %d\\n\",sdcb.adrmode) ;\n  printf(\"  Maximum rows........: %d\\n\",sdcb.rows) ;\n  printf(\"  Maximum columns.....: %d\\n\",sdcb.cols) ;\n  printf(\"  Cell height.........: %d\\n\",sdcb.celheigh) ;\n  printf(\"  Cell width..........: %d\\n\",sdcb.celwidth) ;\n  printf(\"  Supported colors....: %d\\n\",sdcb.colors) ;\n  printf(\"  Actual colors.......: %d\\n\",sdcb.colora) ;\n  printf(\"  Color attr list.....: %.32X\\n\",sdcb.colorlst) ;\n  printf(\"  Number of Highlights: %d\\n\",sdcb.hilites) ;\n  printf(\"  Highlight attr list.: %.8X\\n\",sdcb.hilitlst) ;\n  if (sdcb.unit)\n    printf(\"  Unit................: mm\\n\") ;\n  else\n    printf(\"  Unit................: inch\\n\") ;\n  printf(\"  Alternate device....: %d\\n\",sdcb.altflg) ;\n  printf(\"  APL symbol set......: %.2X\\n\",sdcb.aplflg) ;\n  printf(\"  Extended data stream: %d\\n\",sdcb.edsflg) ;\n  printf(\"  Loadable symbols....: %d\\n\",sdcb.loadflg) ;\n  printf(\"  Load PS extended....: %d\\n\",sdcb.psflg) ;\n  printf(\"  Triple plane symbols: %d\\n\",sdcb.triflg) ;\n  printf(\"  Double byte symbols.: %d\\n\",sdcb.dbcsflg) ;\n  printf(\"  Vector graphic......: %d\\n\",sdcb.graflg) ;\n}\n\n\n/*-------------------------------------------------------------------*/\n/* Add a field to the 3270 field list.                               */\n/*-------------------------------------------------------------------*/\nint insfld(TLSTR *flddata,       /* the data */\n            int ypos,            /* display at row */\n            int xpos,            /* display at column */\n            char attr,           /* field attribute PRT, UNPRT ...*/\n            char color,          /* field color RED, BLUE, ...*/\n            char hilite )        /* field hilite BLINK, RVIDEO,...*/\n{\n  int rc ;\n  TSFLD *newfld, *last, *top ;\n\n  /* get storage for new nodes */\n  newfld = (TSFLD *)malloc(sizeof(TSFLD)) ;\n  if (!newfld) serror(20,\"Not enough memory\") ;\n  memset(newfld,0x00,sizeof(TSFLD)) ;\n\n  /* verify contents of all parameters */\n  if ((flddata->len > 0) &&\n    (flddata->len <= (sdcb.rows * sdcb.cols)))\n    lstrcopy(&newfld->fdata,flddata) ;\n  else\n    return -1 ;\n\n  if ((xpos > 0) &&\n    (xpos < sdcb.cols))\n    newfld->fxpos = xpos ;\n  else\n    return -2 ;\n\n  if ((ypos > 0) &&\n    (ypos <= sdcb.rows))\n    newfld->fypos = ypos ;\n  else\n    return -3 ;\n\n  rc = modattr(&newfld->fattr,attr) ;\n  if (rc) return -4 ;\n\n  rc = modcolor(&newfld->fcolor,color) ;\n  if (rc) return -5 ;\n\n  rc = modhilite(&newfld->fhilite,hilite) ;\n  if (rc) return -6 ;\n\n  /* insert the field into the field list in order of buffer offset */\n  top = screen ;\n  if (!top)   /* first entry in the list (screen->00) */\n    {\n      newfld->next = NULL ;\n      screen = newfld ;\n    }\n  else\n    {\n      last = NULL ;  /* last node examined */\n      while(top)    /* loop through fields for insert place */\n        {\n          if ((top->fxpos+top->fypos*sdcb.cols) <\n            (newfld->fxpos+newfld->fypos*sdcb.cols)) /* rel.buff.pos */\n            {    /* chain to next node */\n              last = top ;\n              top = top->next ;\n            }\n          else\n            {\n              if (last)  /* insert the new node, in middle of list */\n                {\n                  last->next = newfld ;\n                  newfld->next = top ;\n                }\n              else   /* insert new first node in list */\n                {\n                  newfld->next = top ;\n                  screen = newfld ;\n                }\n              break ;   /* exit loop */\n            }\n        }\n      if (!newfld->next)  /* stil not inserted? - add to end */\n        last->next = newfld ;\n    }\n\n  /* update field id table and field id in field struct */\n  newfld->fid = fidnext ;\n  sfidtab\u00ddfidnext\u00a8 = newfld ;\n  rc = fidnext++ ;\n  return rc ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Remove all fields defined from the 3270 field list.               */\n/*-------------------------------------------------------------------*/\nint remflds()\n{\n  int i ;\n  TSFLD *curr, *top ;\n\n  for (i=0; i<SFIDMAX; i++)  /* empty fid table */\n    sfidtab\u00ddi\u00a8 = NULL ;\n  fidnext = 0 ;              /* reset next fid */\n\n  top = screen ;             /* free field list */\n  while(top)\n    {\n      curr = top ;\n      top = top->next ;\n      free((char *)curr->fdata.data) ;\n      free((TSFLD *)curr) ;\n    }\n  screen = NULL ;\n  return 0 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Delete a field from the 3270 field list.                          */\n/*-------------------------------------------------------------------*/\nint delfld(int id)\n{\n    TSFLD *curr, *top, *last ;\n\n    if ((id < SFIDMAX) && (id >= 0))\n      {\n        curr = sfidtab\u00ddid\u00a8 ;\n        if (curr)\n          {\n            top = screen ;\n            last = NULL ;\n            while (top)\n              {\n                if (top == curr)\n                  {\n                    if (!last)   /* ? found node at top */\n                      screen = top->next ;\n                    else if (!top->next)  /* ? last node */\n                      last->next = NULL ;\n                    else           /* in middle of list */\n                      last->next = top->next ;\n                    /* delete the node */\n                    free((char *)top->fdata.data) ;\n                    free((TSFLD *)top) ;\n                    sfidtab\u00ddid\u00a8 = NULL ; /* invalidate id */\n                    return 0 ;  /* field id removed OK */\n                  }\n                last = top ;  /* remember last node */\n                top = top->next ;   /* chain to next node */\n              }    /* of while top */\n          }\n        else return 1 ;     /* invalid id */\n      }\n    else return 2 ;    /* out of range id */\n    return 3 ;     /* idtab list mismatch */\n}\n\n/*-------------------------------------------------------------------*/\n/* Erase the contents of a field in the 3270 field list.             */\n/*-------------------------------------------------------------------*/\nint erasefld(int id)\n{\n  TSFLD *curr ;\n\n  if ((id < SFIDMAX) && (id >= 0))\n    {\n      curr = sfidtab\u00ddid\u00a8 ;\n      if (curr)\n        lstrfill(&curr->fdata,\"\\0\") ; /* fill with zeros */\n      else\n        return 1 ;     /* invalid id */\n    }\n  else\n    return 2 ;    /* out of range id */\n\n  return 0 ;    /* id erased OK */\n}\n\n/*-------------------------------------------------------------------*/\n/* Get the current contents of a field in the 3270 field list.       */\n/*-------------------------------------------------------------------*/\nint getfld(int id,\n           TLSTR *retdata)\n{\n  TSFLD *curr ;\n\n  if ((id < SFIDMAX) && (id >= 0))\n    {\n      curr = sfidtab\u00ddid\u00a8 ;\n      if (curr)\n        lstrcopy(retdata,&curr->fdata) ; /* copy data */\n      else\n        return 1 ;     /* invalid id */\n    }\n  else\n    return 2 ;    /* out of range id */\n\n  return 0 ;    /* data returned OK */\n}\n\n/*-------------------------------------------------------------------*/\n/* Modify the contents of a field in the 3270 field list.            */\n/*-------------------------------------------------------------------*/\nint modfld(int id,\n           TLSTR *newdata)\n{\n  TSFLD *curr ;\n\n  if ((id < SFIDMAX) && (id >= 0))\n    {\n      curr = sfidtab\u00ddid\u00a8 ;\n      if (curr)\n        {\n          if ((newdata->len > 0) &&\n            (newdata->len <= (sdcb.rows * sdcb.cols)))\n            lstrcopy(&curr->fdata,newdata) ; /* alter field data*/\n          else\n            return 1 ;  /* data too large or 0 */\n        }\n      else\n        return 2 ;     /* invalid id */\n    }\n  else\n    return 3 ;    /* out of range id */\n\n  return 0 ;    /* data returned OK */\n}\n\n/*-------------------------------------------------------------------*/\n/* Change the attributes of a field in the 3270 field list.          */\n/*-------------------------------------------------------------------*/\nint setfld(int id,\n           int type,\n           char value)\n{\n  TSFLD *curr ;\n  int rc = 0 ;\n\n  if ((id < SFIDMAX) && (id >= 0))\n    {\n      curr = sfidtab\u00ddid\u00a8 ;\n      if (curr)\n        {\n          switch (type)\n            {\n            case ALL:\n              rc = modcolor(&curr->fcolor,DFLT) ;\n              rc = modhilite(&curr->fhilite,DFLT) ;\n              rc = modattr(&curr->fattr,DFLT) ;\n              break ;\n            case HILITE:\n              rc = modhilite(&curr->fhilite,value) ;\n              break ;\n            case COLOR:\n              rc = modcolor(&curr->fcolor,value) ;\n              break ;\n            case ATTR:\n              rc = modattr(&curr->fattr,value) ;\n              break ;\n            case SYMSET:\n              rc = modsym(&curr->symbol,value) ;\n              break ;\n            default:\n              return 1 ;    /* invalid type */\n            }\n        }\n      else\n        return 1 ;     /* invalid id */\n    }\n  else\n    return 2 ;    /* out of range id */\n\n  return rc ;   /* return */\n}\n\n\n\n/*********************************************************************/\n/* 3270 support routines                                             */\n/*   rc2sba(row,col,sba)                                             */\n/*   sba2rc(sba,row,col,adjust)                                      */\n/*   rc = modcolor(out,in)                                           */\n/*   rc = modhilit(out,in)                                           */\n/*   rc = modattr(out,in)                                            */\n/*   rc = tputn(buf,buflen)                                          */\n/*   rc = tgetn(buf,buflen)                                          */\n/*   rc = tpgn(buf,buflen)                                           */\n/*   rc = getdev()                                                   */\n/*   rc = getterm(primrow,primcol,altrow,altcol,attrs)               */\n/*   rc = querydev()                                                 */\n/*   rc = dsummary(buf,buflen)                                       */\n/*   rc = darea(buf,buflen)                                          */\n/*   rc = dcharset(buf,buflen)                                       */\n/*   rc = dcolor(buf,buflen)                                         */\n/*   rc = dhilite(buf,buflen)                                        */\n/*   rc = dmodes(buf,buflen)                                         */\n/*   rc = dimpart(buf,buflen)                                        */\n/*                                                                   */\n/*********************************************************************/\n\n/*-------------------------------------------------------------------*/\n/* The TPUTN routine is loaded below the 16M line                    */\n/* It issues the TPUT macro with the NOEDIT option                   */\n/*-------------------------------------------------------------------*/\nint tputn(char *buf, int buflen)\n  {\n    int rc = 0 ;\n    int (*tputn)(char *,int) ;\n\n    loadm(\"TPUTN\",&tputn) ;\n    if (iotrace)      /* trace terminal I/O ? */\n      {\n        printf(\"Outbound data stream:\\n\") ;\n        dumpchar(buf,buflen) ;\n      }\n    rc = (*tputn)(buf,buflen) ;\n    unloadm(tputn) ;\n    return rc ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* The TGETN routine is loaded below the 16M line                    */\n/* It issues the TGET macro with the FULLSCR option.                 */\n/*-------------------------------------------------------------------*/\nint tgetn(char *buf, int buflen)\n  {\n    int rc = 0 ;\n    int (*tgetn)(char *,int) ;\n\n    loadm(\"TGETN\",&tgetn) ;\n    rc = (*tgetn)(buf,buflen) ;\n    if (iotrace)      /* trace terminal I/O ? */\n      {\n        printf(\"Inbound data stream:\\n\") ;\n        dumpchar(buf,buflen) ;\n      }\n    unloadm(tgetn) ;\n    return rc ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* The TPGN routine is loaded below the 16M line                     */\n/* It issues the TPG macro with the NOEDIT option.                   */\n/*-------------------------------------------------------------------*/\nint tpgn(char *buf, int buflen)\n  {\n    int rc = 0 ;\n    int (*tpgn)(char *,int) ;\n\n    loadm(\"TPGN\",&tpgn) ;\n    if (iotrace)      /* trace terminal I/O ? */\n      {\n        printf(\"Outbound data stream:\\n\") ;\n        dumpchar(buf,buflen) ;\n      }\n    rc = (*tpgn)(buf,buflen) ;\n    unloadm(tpgn) ;\n    return rc ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* Convert row/column to 3270 12/16 bit buffer address.              */\n/*-------------------------------------------------------------------*/\nvoid rc2sba(int row,\n            int col,\n            char *sba)\n{\n  int offset, byte1, byte2 ;\n\n  offset = ((row-1)*sdcb.cols)+(col-1) ;\n  if (sdcb.adrmode == 12)  /* addressing mode = 12 */\n    {\n      byte1 = offset >> 6 ;           /* extract high order bits */\n      byte1 = byte1 | 0x000000c0 ;    /* turn on 12 bit ind */\n\n      byte2 = offset & 0x0000003f ;   /* extract low order 6 bits */\n      byte2 = byte2 | 0x000000c0 ;    /* turn on 12 bit ind */\n\n      sba\u00dd0\u00a8 = *((char *)&byte1+3) ;  /* assemble 2 byte sba */\n      sba\u00dd1\u00a8 = *((char *)&byte2+3) ;\n    }\n  else /* adrmode = 16 or 14 */\n    {\n      byte1 = offset >> 8 ;           /* extract high order byte */\n      byte2 = offset & 0x00ff ;       /* extract low order byte */\n      sba\u00dd0\u00a8 = *((char *)&byte1+3) ;  /* assemble 2 byte sba */\n      sba\u00dd1\u00a8 = *((char *)&byte2+3) ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Convert 12/14/16-bit address to an offset and row/column.         */\n/*-------------------------------------------------------------------*/\nvoid sba2rc(char *inaddr,  /* input buffer addr */\n            int *row,      /* returned row */\n            int *col,      /* returned column */\n            int adjust)    /* amount to subtract - usuallu 0 for the */\n                           /*   returned cursor position, but is set */\n                           /*   to one to get correct returned buffer*/\n                           /*   addresses.                           */\n{\n  int taddr,     /* Temporary address holder */\n      offset ;\n  short addr ;\n  memcpy((char *)&addr,inaddr,sizeof(short)) ;\n\n  /* If 12-bit address, then we need to massage it a little */\n  if (addr & 0xc000)    /* 12-bit address ? */\n    {\n       addr &= 0x3f3f ;      /* turn off 2 hi bits in each byte */\n       taddr = addr >> 8 ;   /* taddr is first 6 bits */\n       addr &= 0x00ff ;      /* addr is second 6 bits */\n       taddr = taddr << 6 ;  /* shift taddr left and .. */\n       taddr |= addr ;       /*   merge taddr with addr into taddr */\n       offset = taddr ;      /* taddr is the offset into the buffer */\n    }\n  else\n    offset = addr ;          /* addr is the offset into the buffer */\n\n  offset = offset - adjust ; /* adjust is either 0 or 1 */\n\n  /* turn offset into row and column based on device num of columns */\n  *col = (offset % sdcb.cols) + 1 ;\n  *row = (offset / sdcb.cols) + 1 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Check color attribute and copy if valid.                          */\n/*-------------------------------------------------------------------*/\nint modsym(char *out,\n           char in )\n{\n  switch (in)\n    {\n    case DFLT:\n      *out = in ;\n      return 0 ;\n    case APL:\n      if (sdcb.aplflg)\n        {\n          *out = in ;\n          return 0 ;\n        }\n      else\n        return 1 ;\n    default:\n      if (sdcb.loadflg)\n        {\n          if ((in>=0x40) && (in<=0xef))\n            {\n              *out = in ;\n              return 0 ;\n            }\n          else\n            return 1 ;\n        }\n      else\n        return 1 ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Check color attribute and copy if valid.                          */\n/*-------------------------------------------------------------------*/\nint modcolor(char *out,\n             char in )\n{\n  switch (in)\n    {\n    case DFLT:\n    case BLUE:\n    case RED:\n    case PINK:\n    case GREEN:\n    case TURQ:\n    case YELLOW:\n    case WHITE:\n      *out = in ;\n      return 0 ;\n    default:\n      return 1 ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Check hilite attribute and copy if valid.                         */\n/*-------------------------------------------------------------------*/\nint modhilit(char *out,\n             char in )\n{\n  switch (in)\n    {\n    case NONE:\n    case BLINK:\n    case RVIDEO:\n    case USCORE:\n      *out = in ;\n      return 0 ;\n    default:\n      return 1 ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Check field attribute and copy if valid.                          */\n/*-------------------------------------------------------------------*/\nint modattr(char *out,\n            char in )\n{\n  switch (in)\n    {\n    case PRT:       /* protected normal intensity */\n    case PRTHI:     /* protected high intensity */\n    case PRTAS:     /* protected normal intensity auto skip */\n    case PRTHIAS:   /* protected high intensity auto skip */\n    case UNPRT:     /* unprotected normal intensity */\n    case UNNUM:     /* unprotected numeric normal intensity */\n    case UNNUMHI:   /* unprotected numeric high intensity */\n    case UNNON:     /* unprotected non display */\n    case UNHI:      /* unprotected high intensity */\n      *out = in ;\n      return 0 ;\n    default:\n      return 1 ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Load programmed symbols - type 1 load                             */\n/*   loads programmed symbols without compression                    */\n/*-------------------------------------------------------------------*/\nint loadps1()\n  {\n    int rc ;         /* return code */\n    int bufpos ;     /* next buffer position */\n    int i, j ;       /* counters */\n    short s ;        /* temp */\n\n    memset(buffer,0x00,BUFFMAX) ;  /* clear buffer */\n\n    bufpos = 0 ;\n    buffer\u00ddbufpos++\u00a8 = WSF ;   /* write structured field */\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;  /* structured field length */\n    buffer\u00ddbufpos++\u00a8 = 0x07 ;  /* structured field length contd. */\n    buffer\u00ddbufpos++\u00a8 = 0x06 ;  /* load PS structured field */\n    buffer\u00ddbufpos++\u00a8 = 0x41 ;  /* flags: clear sym.set and use type 1 */\n    buffer\u00ddbufpos++\u00a8 = 0xff ;  /* make associated RWS = not assigned */\n    buffer\u00ddbufpos++\u00a8 = 0x41 ;  /* starting code point */\n    buffer\u00ddbufpos++\u00a8 = 0x02 ;  /* RWS of PSA symbol set */\n\n    /* write buffer to the 3270 */\n    rc = tputn(buffer, bufpos) ;\n\n    memset(buffer,0x00, bufpos) ;  /* clear buffer */\n\n    bufpos = 0 ;\n    buffer\u00ddbufpos++\u00a8 = WSF ;   /* write structured field */\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;  /* structured field length */\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;  /* structured field length contd. */\n    buffer\u00ddbufpos++\u00a8 = 0x06 ;  /* load PS structured field */\n    buffer\u00ddbufpos++\u00a8 = 0x01 ;  /* flags: use type 1 */\n    buffer\u00ddbufpos++\u00a8 = 0x40 ;  /* make associated RWS = 0x40 */\n    buffer\u00ddbufpos++\u00a8 = 0x41 ;  /* starting code point (symbol=65) */\n    buffer\u00ddbufpos++\u00a8 = 0x02 ;  /* RWS of PSA symbol set */\n\n /* This extra stuff needs the flags bit 1 on to indicate extended\n    I dont think I need to use it yet.\n\n    buffer\u00ddbufpos++\u00a8 = 0x08 ;     P length - length of extra parms\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     flags: operator selectable ...\n    buffer\u00ddbufpos++\u00a8 = 0x09 ;     LW - width of character\n    buffer\u00ddbufpos++\u00a8 = 0x10 ;     LH - width of character\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     SUBSN - only one byte codes\n    buffer\u00ddbufpos++\u00a8 = 0xf1 ;     COLOR - F1 - first attr ???\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     ST.SUBSN - default\n    buffer\u00ddbufpos++\u00a8 = 0xf9 ;     ECHAR - last symbol=249\n\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     NW - number width pairs\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     NH - number height pairs\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     RES - reserved\n */\n\n    /* load specific font based on the cell height */\n    if (sdcb.celheigh >= 16)\n      {\n        for (i=65;i<=249;i++)   /* for each symbol, 0x41 to 0xF9 */\n          {\n            for (j=0;j<=17;j++)      /* for each slice  */\n              {\n                buffer\u00ddbufpos++\u00a8 = ps9x16u\u00ddi\u00a8\u00ddj\u00a8 ;\n              }\n          }\n      }\n    else if (sdcb.celheigh == 15)\n      {\n        for (i=65;i<=249;i++)   /* for each symbol, 0x41 to 0xF9 */\n          {\n            for (j=0;j<=17;j++)      /* for each slice  */\n              {\n                buffer\u00ddbufpos++\u00a8 = ps9x15u\u00ddi\u00a8\u00ddj\u00a8 ;\n              }\n          }\n      }\n    else\n      {\n        for (i=65;i<=249;i++)   /* for each symbol, 0x41 to 0xF9 */\n          {\n            for (j=0;j<=17;j++)      /* for each slice  */\n              {\n                buffer\u00ddbufpos++\u00a8 = ps9x12u\u00ddi\u00a8\u00ddj\u00a8 ;\n              }\n          }\n      }\n\n    s = bufpos - 1 ;\n    memcpy(buffer+1,&s,sizeof(short)) ;\n\n    /* write buffer to the 3270 to load the programmed symbols */\n    rc = tputn(buffer, bufpos) ;\n\n    memset(buffer,0x00,BUFFMAX) ;  /* clear buffer */\n    return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* Get the display device attributes.                                */\n/*-------------------------------------------------------------------*/\nint getdev()\n  {\n    int rc, pr = 0, pc = 0, ar = 0, ac = 0, att = 0 ;\n    int i ;\n\n    /* set the default values, may get over ridden later */\n    sdcb.adrmode = 12 ;  /* addressing mode */\n    sdcb.altflg = 0 ;    /* use primary device */\n    sdcb.edsflg = 0 ;    /* no extended data stream */\n    sdcb.graflg = 0 ;    /* not a graphics device */\n    sdcb.aplflg = 0 ;    /* no apl symbols on device */\n    sdcb.psflg = 0 ;     /* no program symbols on device */\n    sdcb.loadflg = 0 ;   /* no loadable symbols sets on device */\n    sdcb.triflg = 0 ;    /* no triple plane symbols sets on device */\n    sdcb.dbcsflg = 0 ;   /* no double byte symbols on device */\n    sdcb.celheigh = 0 ;  /* zero cell height on device */\n    sdcb.celwidth = 0 ;  /* zero cell width on device */\n    sdcb.unit = 0 ;      /* units are inches */\n    sdcb.colora = 1 ;    /* actual colors default to monochrome */\n    sdcb.colors = 1 ;    /* supported colors default to monochrome */\n    sdcb.hilites = 0 ;   /* supported hilites default to none */\n    for (i=0;i<17;i++)\n      sdcb.colorlst\u00ddi\u00a8 = 0x00 ; /* list of color attributes on device*/\n    for (i=0;i<5;i++)\n      sdcb.hilitlst\u00ddi\u00a8 = 0x00 ; /* list of hilite attributes on device*/\n\n\n    /* get info from TSO about this device */\n    rc = getterm(&pr,&pc,&ar,&ac,&att) ;\n    if (rc==0)                 /* get terminal info worked ? */\n      {\n        if (att==0x00000001)   /* device has query structured fields */\n          {\n            /* set row and col may be later reset by query dev */\n            if ((ar>0) && (ar!=pr) &&\n                (ac>0) && (ac!=pc))\n              {\n                sdcb.altflg = 1 ;    /* use alternate device */\n                sdcb.rows = ar ;     /* use alternate rows */\n                sdcb.cols = ac ;     /* use alternate cols */\n              }\n            else\n              {\n                sdcb.rows = pr ;     /* use primary rows */\n                sdcb.cols = pc ;     /* use primary cols */\n              }\n\n            rc = querydev() ;\n            /* try to determine actual device */\n            if (sdcb.rows == 32)\n              {\n                strcpy(sdcb.modname,\"IBM3279-3\") ;\n                sdcb.model = 3279 ;\n                sdcb.type = 3 ;\n              }\n            else if (sdcb.rows == 43)\n              {\n                strcpy(sdcb.modname,\"IBM3278-4\") ;\n                sdcb.model = 3278 ;\n                sdcb.type = 4 ;\n              }\n            else if (sdcb.rows == 27)\n              {\n                strcpy(sdcb.modname,\"IBM3290\") ;\n                sdcb.model = 3290 ;\n                sdcb.type = 5 ;\n              }\n            else  /* cant tell - use most primitive */\n              {\n                strcpy(sdcb.modname,\"IBM3278-2\") ;\n                sdcb.model = 3278 ;\n                sdcb.type = 2 ;\n              }\n          }\n        else  /* dont know a lot about the device - make some guesses */\n          {\n            if ((ar>0) && (ar!=pr) &&\n                (ac>0) && (ac!=pc))\n              {\n                sdcb.altflg = 1 ;    /* use alternate device */\n                sdcb.rows = ar ;     /* use alternate rows */\n                sdcb.cols = ac ;     /* use alternate cols */\n              }\n            else\n              {\n                sdcb.rows = pr ;     /* use primary rows */\n                sdcb.cols = pc ;     /* use primary cols */\n              }\n\n            /* try to determine actual device */\n            if (sdcb.rows == 32)\n              {\n                strcpy(sdcb.modname,\"IBM3279-3\") ;\n                sdcb.model = 3279 ;\n                sdcb.type = 3 ;\n              }\n            else if (sdcb.rows == 43)\n              {\n                strcpy(sdcb.modname,\"IBM3278-4\") ;\n                sdcb.model = 3278 ;\n                sdcb.type = 4 ;\n              }\n            else if (sdcb.rows == 27)\n              {\n                strcpy(sdcb.modname,\"IBM3290\") ;\n                sdcb.model = 3290 ;\n                sdcb.type = 5 ;\n              }\n            else  /* cant tell - use most primitive */\n              {\n                strcpy(sdcb.modname,\"IBM3278-2\") ;\n                sdcb.model = 3278 ;\n                sdcb.type = 2 ;\n              }\n          }\n        return 0 ;\n      }\n    else  /* get term failed - return its code */\n      return rc ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* This routine loads an assebbler module below the 16 MB line       */\n/* that issues the GTTERM macro instruction to obtain the            */\n/* dimensions of the screen and also some bit fields that            */\n/* tell if the device can be queried. The module copies the          */\n/* results from storage below the line to this routines              */\n/* automatic storage.                                                */\n/* Upon completion the module is unloaded.                           */\n/*-------------------------------------------------------------------*/\nint getterm(int *primrow, int *primcol,\n             int *altrow, int *altcol,\n             int *attrs)\n  {\n    struct {\n      union {\n        short sh ;\n        char c\u00dd2\u00a8 ;\n      } prim ;\n      union {\n        short sh ;\n        char c\u00dd2\u00a8 ;\n      } alt ;\n      int attr ;\n    } pm ;\n    int rc = 0 ;\n    int (*tgt327d)(void *) ;\n\n    loadm(\"TGT327D\",&tgt327d) ;   /* load ASM routine below 16M */\n    rc = (*tgt327d)(&pm) ;        /* execute GTTERM macro */\n    if (rc==0)      /* data returned OK ? */\n      {             /* yes - convert single byte numbers to int */\n        *primrow = pm.prim.c\u00dd0\u00a8 ;\n        *primcol = pm.prim.c\u00dd1\u00a8 ;\n        *altrow = pm.alt.c\u00dd0\u00a8 ;\n        *altcol = pm.alt.c\u00dd1\u00a8 ;\n        *attrs = pm.attr ;\n      }\n    unloadm(tgt327d) ;            /* unload ASM routine */\n    return rc ;                   /* return code from GTTERM */\n  }\n\n/*-------------------------------------------------------------------*/\n/* Clear 3270 screen.                                                */\n/*-------------------------------------------------------------------*/\nvoid clear()\n  {\n    int rc ;\n    char sba\u00dd2\u00a8 ;\n    char out1\u00dd\u00a8 = {      /* set up for erase */\n      WRT, 0x40,\n      SBA, 0x5d, 0x7f,   /* end addr - overlayed later */\n      SBA, 0x40, 0x40,   /* start addr row=1 col=1 */\n      SBA, 0xe7, 0x7f,   /* insert cursor location, row/col max */\n      ICUR               /* insert cursor */\n      } ;\n    char out2\u00dd\u00a8 = {      /* erase write alternate */\n      EWA, 0xc2\n      } ;\n    char out3\u00dd\u00a8 = {      /* erase primary */\n      WRT, 0xc2\n      } ;\n\n    /* set max screen size known so far sba */\n    rc2sba(sdcb.rows,sdcb.cols,sba) ;\n    out1\u00dd9\u00a8 = sba\u00dd0\u00a8 ;\n    out1\u00dd10\u00a8 = sba\u00dd1\u00a8 ;\n\n    rc = tputn(out1,sizeof(out1) ) ;   /* define the buffer */\n    rc = tputn(out2,sizeof(out2) ) ;   /* erase write alternate */\n    rc = tputn(out3,sizeof(out3) ) ;   /* erase write primary */\n  }\n\n/*-------------------------------------------------------------------*/\n/* Select the entire screen buffer using SBA based on the            */\n/* scrsize returned from GTTERM and EW/EWA to select the             */\n/* primary or alternate buffer.                                      */\n/* Then assemble a structured field query, and send it to the        */\n/* device using TPG which will cause the device to imediately        */\n/* send back the response without any user intervention.             */\n/* Then decode the read partition, query operations, query and       */\n/* put the interesting data in the sdcb structure.                   */\n/*-------------------------------------------------------------------*/\nint querydev()\n  {\n    short sflen ;      /* structured field length */\n    char  sfid ;       /* structured field ID */\n    char  qcode ;      /* query reply - query code */\n    char input\u00dd256\u00a8 ;  /* query buffer */\n    char *ibuf ;       /* current query buffer pointer */\n    int rc ;\n    char sba\u00dd2\u00a8 ;\n\n    char out1\u00dd\u00a8 = {      /* set up for erase */\n      WRT, 0x40,\n      SBA, 0x5d, 0x7f,   /* end addr - overlayed later, rc= 24,80 */\n      SBA, 0x40, 0x40,   /* start addr row=1 col=1 */\n      SBA, 0xe7, 0x7f,   /* insert cursor loc, rc= 32,80 *OVERLAYED**/\n      ICUR               /* insert cursor */\n      } ;\n\n    char out2\u00dd\u00a8 = {      /* erase write alternate */\n      EWA, 0xc2\n      } ;\n\n    char out3\u00dd\u00a8 = {      /* erase primary */\n      WRT, 0xc2\n      } ;\n\n    char out4\u00dd\u00a8 = {\n      WSF,               /* write structured field */\n      0x00, 0x05,        /* structured field length */\n      0x01,              /* read partition */\n      0xFF,              /* query operations */\n      0x02               /* query */\n      } ;\n\n    /* set max screen size known so far sba */\n    rc2sba(sdcb.rows,sdcb.cols,sba) ;\n    out1\u00dd9\u00a8 = sba\u00dd0\u00a8 ;\n    out1\u00dd10\u00a8 = sba\u00dd1\u00a8 ;\n\n    fill(input,0x00,sizeof(input)) ;   /* zero input buffer */\n\n    rc = tputn(out1,sizeof(out1) ) ;   /* define the buffer */\n    rc = tputn(out2,sizeof(out2) ) ;   /* erase write alternate */\n    rc = tputn(out3,sizeof(out3) ) ;   /* erase write primary */\n    rc = tpgn(out4,sizeof(out4) ) ;    /* query the device */\n    rc = tgetn(input,sizeof(input)) ;  /* receive device resp.*/\n\n    ibuf = input ;       /* point at input */\n\n    if (*input==0x88)    /* check for 88 AID byte */\n      {\n        ibuf = ibuf+1 ;         /* advance to 1st structured field */\n        sfid = *(ibuf+2) ;      /* sfid should be 0x81 */\n\n        while (sfid==0x81)  /* while structured fields remain */\n          {\n            sflen = *((short *)ibuf) ;  /* get structured field len */\n            if (sflen==0)           /* bad error - should not happen */\n              {\n                printf(\"Error: Structured field length zero at %p\\n\",\n                  ibuf) ;\n                dumpchar(input,sizeof(input)) ;\n                return 1 ;\n              }\n            qcode = *(ibuf+3) ;     /* get query code */\n            switch (qcode)\n              {\n                case 0x80:           /* Q-code summary */\n                  rc = dsummary(ibuf,sflen) ;\n                  break ;\n                case 0x81:           /* Usable area */\n                  rc = darea(ibuf,sflen) ;\n                  break ;\n                case 0x85:           /* Character sets */\n                  rc = dcharset(ibuf,sflen) ;\n                  break ;\n                case 0x86:           /* Color */\n                  rc = dcolor(ibuf,sflen) ;\n                  break ;\n                case 0x87:           /* Highlighting */\n                  rc = dhilite(ibuf,sflen) ;\n                  break ;\n                case 0x88:           /* Modes */\n                  rc = dmodes(ibuf,sflen) ;\n                  break ;\n                case 0xa6:           /* Implicit partition */\n                  rc = dimpart(ibuf,sflen) ;\n                  break ;\n                default:\n                  break ;\n              }  /* of switch */\n            ibuf = ibuf+sflen ; /* advance to next structured field */\n            sfid = *(ibuf+2) ;  /* sfid should be 0x81 - else stop */\n\n          } /* of while sfid=81 */\n\n      } /* of AID=88 */\n    return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x80: Qcode summary                                               */\n/*-------------------------------------------------------------------*/\nint dsummary(char *buf, short buflen)\n  {\n     int i ;\n     char qcode ;\n\n     for (i=4;i<buflen;i++)\n       {\n          qcode = *(buf+i) ;     /* get query code */\n          if (qcode == 0xb4)\n            sdcb.graflg = 1 ;    /* indicate graphic support */\n       }  /* of for i=4 */\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x81: Usable area                                                 */\n/*-------------------------------------------------------------------*/\nint darea(char *buf, short buflen)\n  {\n     char celunits\u00dd6\u00a8 ;   /* screen size unit PEL or CELL */\n     short w, h ;         /* screen size w=width h=height */\n     char aw, ah ;        /* units per cell aw=width ah=height */\n     float xr, xrd, yr, yrd ;  /* pel spacing ratio */\n     float fw, fh ;       /* ratio - pels per unit */\n\n     if ((*(buf+4) & 0x03)==0x03)\n       sdcb.adrmode = 16 ;\n     else if ((*(buf+4) & 0x01)==0x01)\n       sdcb.adrmode = 12 ;\n\n     w = *((short *)(buf+6)) ;   /* width of usable area */\n     h = *((short *)(buf+8)) ;   /* height of usable area */\n\n     if (*(buf+10) == 0x01)    /* pels/in or pels/mm */\n       sdcb.unit = 1 ;  /* units are mm */\n     else\n       sdcb.unit = 0 ;  /* units are inch */\n\n     xr = *((short *)(buf+11)) ;    /* x dim pel ratio numerator */\n     xrd = *((short *)(buf+13)) ;   /* x dim pel ratio denominator */\n     yr = *((short *)(buf+15)) ;    /* y dim pel ratio numerator */\n     yrd = *((short *)(buf+17)) ;   /* y dim pel ratio denominator */\n\n     fw = (float)(xr) / (float)(xrd) ; /* horiz. ratio pels per unit */\n     fh = (float)(yr) / (float)(yrd) ; /* vert. ratio pels per unit */\n\n     aw = *(buf+19) ;    /* number of X units in default cell */\n     ah = *(buf+20) ;    /* number of Y units in default cell */\n\n     if (*(buf+5) & 0x20)       /* byte 5 bit 3 on unit=pels */\n       strcpy(celunits,\"pels\") ;\n     else                       /* other wise unit=cells */\n       strcpy(celunits,\"cells\") ;\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x85: Character sets                                              */\n/*-------------------------------------------------------------------*/\nint dcharset(char *buf, short buflen)\n  {\n     int i, j ;         /* counters */\n     int cgcsgid ;      /* Coded graphic character set identifier */\n     short ccsid ;      /* Coded character set identifier */\n     char gf = 0 ;      /* CGCSGID not present flag */\n     char ch2 = 0 ;     /* Two byte char. set flag */\n     char ms = 0 ;      /* Multiple slot sizes flag */\n     char cf = 0 ;      /* CCSID not present flag */\n     char sdw ;         /* Default character slot width */\n     char sdh ;         /* Default character slot height */\n     char dl ;          /* character set descriptor (CSD) length */\n     char *csd ;        /* character set descriptor (CSD) ptr */\n     char set ;         /* character set ID (PS store no.) */\n     char lcid ;        /* character set Local ID (alias) */\n     char sw ;          /* character set slot width */\n     char sh ;          /* character set slot height */\n     char ssubsn ;      /* character set starting subsection */\n     char esubsn ;      /* character set ending subsection */\n\n     if (*(buf+4) & 0x10)\n       sdcb.psflg = 1 ;   /* load PS Extended supported */\n     else\n       sdcb.psflg = 0 ;   /* load PS Extended not supported */\n\n     if (*(buf+4) & 0x08)\n       ms = 1 ;   /* More than one size character slot supported */\n\n     if (*(buf+4) & 0x04)\n       ch2 = 1 ;  /* Two byte code character sets are supported */\n\n     if (*(buf+4) & 0x02)\n       gf = 1 ;   /* CGCSGID present */\n\n     if (*(buf+5) & 0x20)\n       cf = 1 ;   /* CCSID present */\n\n     sdw = *(buf+6) ;\n     sdh = *(buf+7) ;\n\n     dl = *(buf+12) ;   /* get CSD length */\n     i = 13 ;\n     while (i<buflen)\n       {\n         csd = buf + i ;  /* point at CSD to process */\n         set = *csd ;     /* get character set ID (PS store no.) */\n         if (*(csd+1) & 0x80)\n           sdcb.loadflg = 1 ;  /* loadable symbol sets exist */\n\n         if (*(csd+1) & 0x40)\n           sdcb.triflg = 1 ;   /* Triple-plane character sets exist */\n\n         if (*(csd+1) & 0x20)\n           sdcb.dbcsflg = 1 ;  /* Double-byte coded character sets */\n\n         lcid = *(csd+2) ;   /* get character set ID (PS store no.) */\n\n         j = 0 ;\n         if (ms)\n           {\n             sw = *(csd+3) ;  /* slot width */\n             sh = *(csd+4) ;  /* slot height */\n             j = j + 2 ;\n           }\n\n         if (ch2)\n           {\n             ssubsn = *(csd+j+3) ;  /* starting sub-section */\n             esubsn = *(csd+j+4) ; /* ending sub-section */\n             j = j + 2 ;\n           }\n\n         if (gf)\n           {\n             cgcsgid = *((int *)(csd+j+3)) ;  /* Graf char set ID */\n             if (cgcsgid==0x03c30136)\n               sdcb.aplflg = lcid ;   /* APL supported store lcid */\n             j = j + 4 ;\n           }\n\n         if (cf)\n           {\n             ccsid = *((short *)(csd+j+3)) ;  /* char set ID */\n           }\n\n         i = i + dl ;  /* get pos of next CSD */\n       }  /* of while i<buflen */\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x86: Colors                                                      */\n/*-------------------------------------------------------------------*/\nint dcolor(char *buf, short buflen)\n  {\n     int colora = 0 ; /* number of actual colors on device */\n     int icolor ;     /* color index */\n     int i, j = 0 ;   /* counter */\n     char attr ;      /* color attribute accepted by device */\n     char dcolor ;    /* color displayed for this attribute */\n\n     sdcb.colors = (int)*(buf+5) ; /* number of colors accepted */\n     for (i=6;i<buflen;i=i+2)\n       {\n         attr = *(buf+i) ;        /* attribute used by appl. */\n         sdcb.colorlst\u00ddj++\u00a8 = attr ;\n         dcolor = *(buf+i+1) ;    /* attr/color used by device */\n         icolor = (int)(dcolor - 0xf0) ;\n         if ((icolor >= 0) && (icolor <= 15))\n           colora++ ;\n       }\n     sdcb.colora = colora ;  /* number of actual colors on device */\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x87: Highlighting                                                */\n/*-------------------------------------------------------------------*/\nint dhilite(char *buf, short buflen)\n  {\n     int i, j = 0 ;    /* counter */\n     char attr ;       /* color attribute accepted by device */\n     char dhilite ;    /* color displayed for this attribute */\n\n     sdcb.hilites = (int)*(buf+4) ;\n     for (i=5;i<buflen;i=i+2)\n       {\n         attr = *(buf+i) ;        /* attribute used by appl. */\n         dhilite = *(buf+i+1) ;   /* attr/highlight used by device */\n         sdcb.hilitlst\u00ddj++\u00a8 = attr ;\n       }\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x88: Modes                                                       */\n/*-------------------------------------------------------------------*/\nint dmodes(char *buf, short buflen)\n  {\n     int i ;           /* counter */\n     char mode ;       /* device opperation mode */\n\n     for (i=4;i<buflen;i++)\n       {\n         mode = *(buf+i) ;        /* attribute used by appl. */\n         if ((mode==0x01) ||\n             (mode==0x02))\n           sdcb.edsflg = 1 ;  /* queryable device can use extended DS*/\n       }   /* of for i */\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0xa6: Implicit partition                                          */\n/*-------------------------------------------------------------------*/\nint dimpart(char *buf, short buflen)\n  {\n     char *sdp ;                /* self defining parameter (SDP) ptr */\n     short wd, wa, hd, ha ;     /* screen dimensions */\n     short wcd, wca, hcd, hca ; /* cell sizes */\n     int i ;                    /* counter */\n\n     i = 6 ;        /* length of header */\n     while(i < buflen)   /* loop over all SDPs */\n       {\n         sdp = buf + i ;\n         if (*sdp==0x0b)    /* is it a SDP ? */\n           {\n             if (*(sdp+1)==0x01)\n               {\n                 wd = *((short *)(sdp+3)) ;  /* default width */\n                 hd = *((short *)(sdp+5)) ;  /* default height */\n                 wa = *((short *)(sdp+7)) ;  /* alternate width */\n                 ha = *((short *)(sdp+9)) ;  /* alternate height */\n                 if ((ha>hd) || (wa>wd))\n                   {\n                     sdcb.altflg = 1 ;    /* use alternate device */\n                     sdcb.rows = ha ;     /* use alternate rows */\n                     sdcb.cols = wa ;     /* use alternate cols */\n                   }\n                 else\n                   {\n                     sdcb.rows = hd ;     /* use primary rows */\n                     sdcb.cols = wd ;     /* use primary cols */\n                   }\n                 i = i + 11 ;     /* add length of this SDP */\n               }\n             else if (*(sdp+1)==0x03)\n               {\n                 i = i + 11 ;     /* add length of this SDP */\n               }\n             else if (*(sdp+1)==0x02)\n               {\n                 wcd = *((short *)(sdp+3)) ;  /* default cell width */\n                 hcd = *((short *)(sdp+5)) ;  /* default cell height */\n                 wca = *((short *)(sdp+7)) ;  /* alternate cell width */\n                 hca = *((short *)(sdp+9)) ;  /* alternate cell height*/\n                 if (sdcb.altflg)         /* using alternate device */\n                   {\n                     sdcb.celheigh = hca ; /* use alt. cell height */\n                     sdcb.celwidth = wca ; /* use alt. cell width */\n                   }\n                 else\n                   {\n                     sdcb.celheigh = hcd ; /* use primary cell height */\n                     sdcb.celwidth = wcd ; /* use primary cols width */\n                   }\n                 i = i + 11 ;     /* add length of this SDP */\n               }\n           }\n       }  /* of while */\n\n     return 0 ;\n  }\n\n\n\n\n/*********************************************************************/\n/* General string handling routines for varying length strings.      */\n/*   lstran(mod_lstr,fromchar,tochar)                                */\n/*   lstrload(to_lstr,fromchar,len)                                  */\n/*   lstrunld(tochar,from_lstr)                                      */\n/*   lstrcopy(to_lstr,from_lstr)                                     */\n/*   lstrnew(to,fromchars)                                           */\n/*   lstrsub(to_lstr,from_lstr,start,length)                         */\n/*   len = lstrlen(haystack_lstr)                                    */\n/*   pos = lstrindex(haystack_lstr,needle_lstr)                      */\n/*   lstrfill(to_lstr,fillchars)                                     */\n/*   rc = lstrcmpc(cmp_lstr,cmpchars)                                */\n/*   lstrdel(del-lstr)                                               */\n/*   lstrrep(to_lstr,repchars,copies)                                */\n/*   lstrcat(to_lstr,left_lstr,right_lstr)                           */\n/*********************************************************************/\n\n/*-------------------------------------------------------------------*/\n/* Translate a character in an lstr to another character.            */\n/*-------------------------------------------------------------------*/\nvoid lstran(TLSTR *in, char from, char to)\n{\n  int i ;      /* temp counter */\n\n  if (in)      /* from string exists ? */\n    {\n      for (i=0;i<=in->len;i++)\n        {\n          if (*(in->data+i) == from)\n            *(in->data+i) = to ;\n        }\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Get the length of an lstr.                                        */\n/*-------------------------------------------------------------------*/\nint lstrlen(TLSTR *in)\n{\n  if (in)      /* from string exists ? */\n    {\n      return in->len ;\n    }\n  else\n    return 0 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Unload varying length string contents into character buffer.      */\n/*-------------------------------------------------------------------*/\nint lstrunld(char *to,\n             TLSTR *from)\n{\n  if (from)      /* from string exists ? */\n    {\n      memcpy(to,from->data,from->len) ;\n      return from->len ;\n    }\n  else\n    return 0 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Load varying length string with contents of character buffer.     */\n/*-------------------------------------------------------------------*/\nvoid lstrload(TLSTR *to,\n              char *from,\n              int len)\n{\n  if (to)      /* to string exists ? */\n    {\n      if (len!=to->len)\n        {\n          free((char *)to->data) ;\n          to->data = (char *)malloc(len) ;\n          if (!to->data) serror(4,\"Not enough memory\") ;\n          to->len = len ;\n        }\n      memcpy(to->data,from,len) ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Copy varying length string.                                       */\n/*-------------------------------------------------------------------*/\nvoid lstrcopy(TLSTR *to,\n              TLSTR *from)\n{\n  if (from)      /* from string exists ? */\n    {\n      if (!to)    /* to string does not exist */\n        serror(2,\"String does not exist\") ;\n      else     /* to string exists */\n        {\n          if (from->len > 0)\n            {\n              if (to->data == NULL)     /* does not exist yet ? */\n                {\n                  to->data = (char *)malloc(from->len) ;\n                  if (!to->data) serror(14,\"Not enough memory\") ;\n                }\n              else if (from->len != to->len)   /* increase length ? */\n                {\n                  free((char *)to->data) ;\n                  to->data = (char *)malloc(from->len) ;\n                  if (!to->data) serror(4,\"Not enough memory\") ;\n                }\n              to->len = from->len ;\n              memcpy(to->data,from->data,from->len) ;\n            }\n          else\n            {\n              if (to->len > 0)   /* empty data */\n                free((char *)to->data) ;\n              to->len = 0 ;\n              to->data = NULL ;\n            }\n        }\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Initialize a varying length string with a string.                 */\n/*-------------------------------------------------------------------*/\nvoid lstrnew(TLSTR *newstr,\n             char *from)\n{\n  int i ;\n\n  if (!newstr)\n    serror(5,\"String does not exist\") ;\n  else\n    {\n      i = strlen(from) ;\n      if (i > 0)\n        {\n          newstr->data = (char *)malloc(i) ;\n          if (!newstr->data) serror(17,\"Not enough memory\") ;\n          newstr->len = i ;\n          memcpy(newstr->data,from,i) ;\n        }\n      else\n        {\n          newstr->len = 0 ;\n          newstr->data = NULL ;\n        }\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Create substring of a varying length string to a varying length   */\n/* string.                                                           */\n/*-------------------------------------------------------------------*/\nvoid lstrsub(TLSTR *to,\n             TLSTR *from,\n             int start,\n             int len)\n{\n  int i ;\n\n  if (start <= from->len)\n    {\n      i = from->len - start ;\n      if (len < i)\n        i = len ;       /* i is the length of the sub string */\n\n      if (!to)\n        serror(8,\"String does not exist\") ;\n      else\n        {\n          if (i > 0)\n            {\n              if (to->data == NULL)     /* does not exist yet ? */\n                {\n                  to->data = (char *)malloc(i) ;\n                  if (!to->data) serror(20,\n                    \"Not enough memory\") ;\n                }\n              else if (to->len != i)          /* wrong size ? */\n                {\n                  free((char *)to->data) ;\n                  to->data = (char *)malloc(i) ;\n                  if (!to->data) serror(10,\n                    \"Not enough memory\") ;\n                }\n              to->len = i ;\n              memcpy(to->data,from->data+start,i) ;\n            }\n          else\n            {\n              if (to->len > 0)   /* empty data */\n                free((char *)to->data) ;\n              to->len = 0 ;\n              to->data = NULL ;\n            }\n        }\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Find the position in a varying length string of a varying length  */\n/* sub-string.                                                       */\n/*-------------------------------------------------------------------*/\nint lstrindx(TLSTR *haystack, /* string to search */\n             TLSTR *needle)   /* sub-string to search for */\n{\n  int i, j, k, endpos ;\n\n  endpos = haystack->len - needle->len ;\n  for (i=0; i<endpos; i++)\n    {\n      k = 0 ;\n      for (j=0; j<needle->len; j++)\n        {\n          if (haystack->data\u00ddi+j\u00a8 == needle->data\u00ddj\u00a8)\n            k ++ ;\n          else break ;\n        }\n      if (k==needle->len)\n        return(i+1) ;\n    }\n  return 0 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Compare a varying length string with a string.                    */\n/*   rc = 0  == strings same                                         */\n/*   rc = 1  == lstr has larger value than charstr                   */\n/*   rc = -1 == lstr has smaller value than charstr                  */\n/*-------------------------------------------------------------------*/\nint lstrcmpc(TLSTR *lstr,   /* string to compare */\n             char *cstr)    /* characters to compare with */\n{\n  int i ;               /* counter */\n  int t=0 ;             /* compare flag */\n  int l ;               /* compare length */\n  int ld=0 ;            /* length differ flag */\n  char *lstrptr ;\n  char *cstrptr ;\n\n  l = strlen(cstr) ;    /* determine shortest string */\n  if (l != lstr->len)   /* same lengths ? */\n    {                   /*   no .. */\n      ld = 1 ;          /*   flag lengths differ */\n      if (l > lstr->len)\n        l = lstr->len ; /*   use shortest length */\n    }\n\n  /* compare to shortest length */\n  lstrptr = lstr->data ;\n  cstrptr = cstr ;\n  for (i=0; i<l; i++)\n    {\n      if (*lstrptr > *cstrptr)\n        {\n          t = 1 ;    /* indicate left larger than right */\n          break ;    /* end scan now  */\n        }\n      if (*lstrptr < *cstrptr)\n        {\n          t = -1 ;   /* indicate left smaller than right */\n          break ;    /* end scan now  */\n        }\n      lstrptr++ ;\n      cstrptr++ ;\n    }\n\n  if ((t==0) && (ld==1)) /* same after shortest length compared ? */\n    {\n      if (strlen(cstr) > lstr->len)\n        t = -1 ;     /* lstr smaller */\n      else\n        t = 1 ;      /* lstr larger */\n    }\n  return t ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Fill a varying length string with a string.                       */\n/*-------------------------------------------------------------------*/\nvoid lstrfill(TLSTR *string,   /* string to fill */\n              char *fillstr)  /* filler characters to use */\n{\n  int i ;\n  char *strptr ;\n\n  strptr = fillstr ;\n  for (i=0; i<=string->len; i++)\n    {\n      string->data\u00ddi\u00a8 = *(strptr++) ;\n      if (*strptr=='\\0')\n        strptr = fillstr ;    /* start over on fill string */\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Delete a varying length string (free associated memory).          */\n/*-------------------------------------------------------------------*/\nvoid lstrdel(TLSTR *string)   /* string to delete */\n{\n  free((char *)string->data) ;\n  string->data = NULL ;\n  string->len = 0 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Create a varying length string with multiple copies of a string.  */\n/*-------------------------------------------------------------------*/\nvoid lstrrep(TLSTR *string,\n             char *repstr,\n             int copies)\n{\n  int repstrlen ;\n  char *strptr ;\n  int newlen ;\n  int i ;\n\n  /* The input string that replications are made from is assumed */\n  /* to have a length of one or longer.                          */\n\n  repstrlen = strlen(repstr) ;\n  if (repstrlen==0)  /* assume repitition of 0x00 */\n    repstrlen = 1 ;\n  newlen = repstrlen * copies ;\n  if (string->data==NULL)          /* alloc storage ? */\n    {\n      string->data = (char *)malloc(newlen) ;\n      if (!string->data) serror(21,\"Not enough memory\") ;\n    }\n  else if (string->len!=newlen)    /* alloc more/less storage ? */\n    {\n      free((char *)string->data) ;\n      string->data = (char *)malloc(newlen) ;\n      if (!string->data) serror(11,\"Not enough memory\") ;\n    }\n  string->len = newlen ;     /* alter string length */\n  strptr = repstr ;\n  for (i=0; i<newlen; i++)        /* replicate the repstr data */\n    {\n      string->data\u00ddi\u00a8 = *strptr++ ;\n      if (*strptr == '\\0')\n        strptr = repstr ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Concatenate two varying length strings together placing the       */\n/* in a varying length string.                                       */\n/*-------------------------------------------------------------------*/\nvoid lstrcat(TLSTR *result,   /* result of concatenation */\n             TLSTR *left,     /* left string to concatenate */\n             TLSTR *right)    /* right string to concatenate */\n{\n  char *rstr ;\n  int newlen ;\n\n  newlen = left->len + right->len ;    /* extend LSTR */\n  rstr = (char *)malloc(newlen) ;\n  if (!rstr) serror(12,\"Not enough memory\") ;\n\n  memcpy(rstr,left->data,left->len) ;   /* make new string */\n  memcpy(rstr+left->len,right->data,right->len) ;\n\n  free((char *)result->data) ;   /* assemble new LSTR */\n  result->data = rstr ;\n  result->len = newlen ;\n}\n\n\n/*********************************************************************/\n/* General sub routines.                                             */\n/*   fill(haystack,fillchar,number)                                  */\n/*   dumpchar(buffer,length)                                         */\n/*   overlay(buffer,bufferlen,overlay,overlaylen,overlaypos)         */\n/*********************************************************************/\n\n/*-------------------------------------------------------------------*/\n/* Fill a character string with a number of filler characters.       */\n/*-------------------------------------------------------------------*/\nvoid fill(char *haystack,   /* area to fill */\n          char filler,      /* fill characters */\n          int num)          /* number of repetitions */\n{\n  int i = 0 ;\n  for(i=0;i<=num;i++)\n    *haystack++ = filler ;\n  *haystack = '\\0' ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Dump the contents of a buffer, formatted in a way that makes a    */\n/* 3270 data stream easier to interpret.                             */\n/*-------------------------------------------------------------------*/\nvoid dumpchar(char *dat,    /* data to dump */\n              int len)      /* length to dump */\n{\n  char *cptr ;\n  char c ;\n  char cc\u00dd3\u00a8 ;\n  int i ;\n  int n, m ;\n\n  n = 0 ;\n  m = 0 ;\n  cptr = dat ;\n  do\n    {\n      printf(\"      %.8X \",dat) ;\n      for(i=1;i<=16;i++)\n        {                   /* 0 indicates all */\n          if (*dat=='\\0' && len==0)\n            break ;\n          if (n==len && len>0)\n            break ;\n          c = *dat++ ;\n          n++ ;\n          printf(\"%.2X\",c) ;\n          if ((i%4)==0)\n            printf(\" \") ;\n        }\n      printf(\"\\n               \") ;\n\n      for(i=1;i<=16;i++)\n        {\n          if (*cptr=='\\0' && len==0)\n            break ;\n          if (m==len && len>0)\n            break ;\n          c = *cptr++ ;\n          m++ ;\n          if (c <= 0x3f || c==0xff)\n            {\n              switch (c)\n                {\n                  case GE:   strcpy(cc,\"GE\") ;\n                    break ;\n                  case FF:   strcpy(cc,\"FF\") ;\n                    break ;\n                  case CRR:  strcpy(cc,\"CR\") ;\n                    break ;\n                  case SBA:  strcpy(cc,\"SB\") ;\n                    break ;\n                  case EUA:  strcpy(cc,\"EU\") ;\n                    break ;\n                  case ICUR: strcpy(cc,\"IC\") ;\n                    break ;\n                  case NL:   strcpy(cc,\"NL\") ;\n                    break ;\n                  case EM:   strcpy(cc,\"EM\") ;\n                    break ;\n                  case DUP:  strcpy(cc,\"DU\") ;\n                    break ;\n                  case SF:   strcpy(cc,\"SF\") ;\n                    break ;\n                  case FM:   strcpy(cc,\"FM\") ;\n                    break ;\n                  case SA:   strcpy(cc,\"SA\") ;\n                    break ;\n                  case SFE:  strcpy(cc,\"SX\") ;\n                    break ;\n                  case MF:   strcpy(cc,\"MF\") ;\n                    break ;\n                  case RA:   strcpy(cc,\"RA\") ;\n                    break ;\n                  case SUB:  strcpy(cc,\"SU\") ;\n                    break ;\n                  default:   strcpy(cc,\". \") ;\n                    break ;\n                }\n              printf(\"%s\",cc) ;\n            }\n          else\n            printf(\"%c \",c) ;\n          if ((i%4)==0)\n            printf(\" \") ;\n        }\n      printf(\"\\n\") ;\n    }\n  while( ((*dat!='\\0') && (len==0)) ||\n         ((m!=len) && (len>20))\n       ) ;\n  printf(\"\\n\") ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Overlay characterc in a buffer.                                   */\n/*-------------------------------------------------------------------*/\nvoid overlay(char *haystack,    /* area to overlay */\n             int haylen,        /* length to overlay */\n             char *needle,      /* overlay characters */\n             int len,           /* length of overlay */\n             int pos)           /* start postition of overlay */\n{\n  int hlen, nlen ;   /* length of haystack and needle */\n  int i = 0 ;        /* itterator */\n\n  if (haylen==0)\n    hlen = strlen(haystack) ;\n  else\n    hlen = haylen ;\n\n  if (len==0)\n    nlen = strlen(needle) ;\n  else\n    nlen = len ;\n\n  if (hlen>(nlen+pos))\n    {\n      haystack = haystack+pos ;    /* move to overlay pos */\n      for(i=0;i<nlen;i++)          /* copy the data */\n        *haystack++ = *needle++ ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* General error message routine.                                    */\n/*-------------------------------------------------------------------*/\nvoid serror(int errno,\n            char *msg)\n{\n  printf(\"Error: %d - %s\\n\",errno,msg) ;\n  abort() ;\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "DD3270": {"ttr": 2568, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01(\\x00\\x00\\x00\\x95\"\\x8f\\x00\\x95%_\\x189\\n\\xd3\\x04C\\x00\\x00\\xe2\\xc1\\xe2\\xc4\\xc4\\xc6@@@@'", "ispf": {"version": "01.40", "flags": 0, "createdate": "1995-08-16T00:00:00", "modifydate": "1995-09-12T18:39:00", "lines": 2771, "newlines": 1091, "modlines": 0, "user": "SASDDF"}, "text": "#pragma eject\n#pragma title dd3270.C - display fields on a 3270 device\n\n/*+-----------------------------------------------------------------+\n  | Program:   dd3270.c                                             |\n  | Language:  c                                                    |\n  | Support:   DAF                                                  |\n  | Purpose:   To learn some full screen 3270 coding techniques to  |\n  |            use on the IBM 3270 display station.                 |\n  |                                                                 |\n  |            The following publications have been used in the     |\n  |            developement of this program:                        |\n  |              SC28-1875 TSO/E v2 programming Services            |\n  |              GA23-0059 3270 Info. Display Sys. Data Stream      |\n  |                        Programmers Reference.                   |\n  |              GA27-3831 3174 Establishment Controller Character  |\n  |                        Set Reference.                           |\n  |              GA27-2837 3270 Character Set Reference.            |\n  |              HUR 9058  IBM3270 Personal Computer Graphics       |\n  |                        Control Program Data Stream Reference.   |\n  |              GA18-2589 IBM 3179-G/3192-G Color Graphics Display |\n  |                        Station Description.                     |\n  |              GG27-6999 Introduction to Programming the IBM 3270.|\n  |                                                                 |\n  |            This programs main routine creates a simple notepad  |\n  |            window on the 3270. It uses routines to build the    |\n  |            notepad that support the creation, modification,     |\n  |            removal, and display of fields on the 3270 screen.   |\n  |            A screen is represented as linked list of fields.    |\n  |            These field routines can be viewed as an API that    |\n  |            the main program (application) uses to create windows|\n  |            on the 3270. The application is freed from managing  |\n  |            things like buffer address translation, and data     |\n  |            stream creation, and inbound data stream parsing.    |\n  |            Varying length strings are represented by the data   |\n  |            type LSTR. These strings can contain amy amount of   |\n  |            data including the null character.                   |\n  |                                                                 |\n  |            The following techniques have not been implemented   |\n  |            in this program but will be added later:             |\n  |            - Data stream compression using RBA.                 |\n  |            - Program symbol sets support.                       |\n  |            - Graphics support.                                  |\n  |                                                                 |\n  | Notes:     1. Numeric fields do not work the same on all        |\n  |               devices. The 3192-G allows lowercase character    |\n  |               input. Many devices also upper case character     |\n  |               input.                                            |\n  |            2. Most devices do not support field attributes:     |\n  |               Field Outlining, Background color, and Field      |\n  |               Validation.                                       |\n  |            3. The character set for APL does not appear to be   |\n  |               allowed on the SFE order, only on the SA order.   |\n  | End.                                                            |\n  +-----------------------------------------------------------------+*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <svc.h>\n#include <tput.h>\n#include <ostask.h>\n\n#define _AMODE31\n\n#include \"ps9x16u.inc\"\n#include \"ps9x15u.inc\"\n#include \"ps9x12u.inc\"\n\n/* escape character and device commands */\n#define ESC     0x27\n#define EW      0xf5\n#define EWA     0x7e\n#define WRT     0xf1\n#define WSF     0xf3\n#define RB      0xf2\n\n/* write control characters, or'd together as required */\n#define WCCMDT  0x01\n#define WCCKBD  0x02\n#define WCCRES  0xc0\n#define WCCBEL  0x04\n\n/* 3270 data stream orders */\n#define GE      0x08\n#define FF      0x0c\n#define CRR     0x0d\n#define SBA     0x11\n#define EUA     0x12\n#define ICUR    0x13\n#define NL      0x15\n#define EM      0x19\n#define DUP     0x1c\n#define SF      0x1d\n#define FM      0x1e\n#define SA      0x28\n#define SFE     0x29\n#define MF      0x2c\n#define RA      0x3c\n#define SUB     0x3f\n\n#define PROT    0x20\n#define NUM     0x10\n\n/* Type byte of the SA, SFE and MF orders */\n#define ALL     0x00\n#define NONE    0x00\n#define DFLT    0x00\n\n#define ATTR    0xc0\n#define FVALID  0xc1\n#define OUTLIN  0xc2\n#define HILITE  0x41\n#define COLOR   0x42\n#define SYMSET  0x43\n#define BAKCOL  0x45\n#define TRANSP  0x46\n\n#define APL     0xF1\n\n/* Out lines for the value byte of the SA, SFE, or MF order */\n#define UNDR    0x01\n#define OVR     0x04\n#define OVRUND  0x05\n#define NOOVR   0x0b\n#define NOUNDR  0x0e\n#define RECT    0x0f\n\n/* Hilites for the value byte of the SA, SFE, or MF order */\n#define BLINK   0xf1\n#define RVIDEO  0xf2\n#define USCORE  0xf4\n\n/* Colors for the value byte of the SA, SFE, or MF order */\n#define BLUE    0xf1\n#define RED     0xf2\n#define PINK    0xf3\n#define GREEN   0xf4\n#define TURQ    0xf5\n#define YELLOW  0xf6\n#define WHITE   0xf7\n\n/* Attribute for the value byte of the SF, SFE and MF order */\n#define UNPRT   0x40\n#define UNNUM   0x50\n#define UNNUMHI 0xd8\n#define UNNON   0x4c\n#define UNHI    0xc8\n#define PRT     0x60\n#define PRTHI   0xe4\n#define PRTAS   0xf0\n#define PRTHIAS 0xf8\n\n/* Attention Identification (AID) Values */\n#define NOAID   0x60\n#define NOAIDP  0xe8\n#define STRFLD  0x88\n#define ENTER   0x7d\n#define PF1     0xf1\n#define PF2     0xf2\n#define PF3     0xf3\n#define PF4     0xf4\n#define PF5     0xf5\n#define PF6     0xf6\n#define PF7     0xf7\n#define PF8     0xf8\n#define PF9     0xf9\n#define PF10    0x7a\n#define PF11    0x7b\n#define PF12    0x7c\n#define PF13    0xc1\n#define PF14    0xc2\n#define PF15    0xc3\n#define PF16    0xc4\n#define PF17    0xc5\n#define PF18    0xc6\n#define PF19    0xc7\n#define PF20    0xc8\n#define PF21    0xc9\n#define PF22    0x4a\n#define PF23    0x4b\n#define PF24    0x4c\n#define OID     0xe6\n#define MAG     0xe7\n#define PEN     0x7e\n#define PA1     0x6c\n#define PA2     0x6e\n#define PA3     0x6b\n#define CLEAR   0x6d\n#define SYSREQ  0xf0\n\ntypedef\n  struct LSTR     /* string with length */\n  {\n    int len ;             /* current length of data */\n    char *data ;          /* pointer to data */\n  } TLSTR ;\n\ntypedef\n  struct SFLD     /* 3270 screen field information list entry */\n  {\n    int fid ;             /* unique field identifier */\n    TLSTR fdata ;         /* field data (input or output) */\n    int fxpos ;           /* X column position */\n    int fypos ;           /* Y row position */\n    char fattr ;          /* 3270 field attribute */\n    char fcolor ;         /* 3270 color attribute */\n    char fhilite ;        /* 3270 hilite attribute */\n    char symbol ;         /* 0x00=normal 0xf1=APL else 0x40-0xef=PS */\n    struct SFLD *next ;   /* next list entry */\n  } TSFLD ;\n\n#define BUFFMAX 5000\nchar *buffer ;    /* buffer area for tput/tget */\n\nTSFLD *screen ;   /* root of 3270 screen field list */\n\n#define SFIDMAX 256\nTSFLD *sfidtab\u00ddSFIDMAX\u00a8 ; /* field id address table */\nint fidnext = 0 ;         /* next field id number to assign */\nint curcol = 1 ;          /* current cursor column */\nint currow = 1 ;          /* current cursor row */\nint bellflg = 0 ;         /* ring bell on next display */\nint iotrace = 0 ;         /* trace terminal I/O flag */\n\n\nstruct DCB        /* Device control block */\n  {\n    int model ;         /* model number ie: 3279, 3278, 3277 */\n    int type ;          /* model type ie: 2, 3, 4, 5 */\n    int rows ;          /* number of rows (height) on device */\n    int cols ;          /* number of columns (width) on device */\n    int celheigh ;      /* cell height on device */\n    int celwidth ;      /* cell width on device */\n    int colors ;        /* number of colors on device */\n    int colora ;        /* number of actual colors on device */\n    int hilites ;       /* number of colors on device */\n    int adrmode ;       /* device addressing mode: 12 or 14 or 16 bit*/\n    char unit ;         /* 0 = inch 1 = mm */\n    char edsflg ;       /* extended data stream flag */\n    char psflg ;        /* program symbols on device flag */\n    char altflg ;       /* use alternate flag */\n    char aplflg ;       /* 0 or apl's lcid=supports APL on device */\n    char graflg ;       /* graphics device flag */\n    char loadflg ;      /* loadable symbol sets supported flag */\n    char triflg ;       /* triple plane symbol sets supported flag */\n    char dbcsflg ;      /* double byte characters supported flag */\n    char colorlst\u00dd17\u00a8 ; /* list of color attributes on device */\n    char hilitlst\u00dd5\u00a8 ;  /* list of hilite attributes on device */\n    char modname\u00dd11\u00a8 ;  /* name of device ie: IBM32793B IBM3179G ..*/\n  } sdcb ;\n\n\n\n/*-------------------------------------------------------------------*/\n/* Function Prototypes                                               */\n/*-------------------------------------------------------------------*/\n\n/* field handling */\nint initscr() ;\nvoid termscr() ;\nchar dspflds() ;\nint insfld(TLSTR *, int, int, char, char, char) ;\nint getdev() ;\nint remflds() ;\nint delfld(int) ;\nint erasefld(int) ;\nint getfld(int, TLSTR *) ;\nint modfld(int, TLSTR *) ;\nint setfld(int, int, char) ;\nvoid dumpfld() ;\n/* 3270 support */\nint tputn(char *, int) ;\nint tgetn(char *, int) ;\nint tpgn(char *, int) ;\nvoid rc2sba(int, int, char *) ;\nvoid sba2rc(char *, int *, int *, int) ;\nint modsym(char *, char) ;\nint modcolor(char *, char) ;\nint modhilit(char *, char) ;\nint modattr(char *, char) ;\nint getterm(int *, int *, int *, int *, int *) ;\nint querydev() ;\nint dsummary(char *, short) ;\nint darea(char *, short) ;\nint dcharset(char *, short) ;\nint dcolor(char *, short) ;\nint dhilite(char *, short) ;\nint dmodes(char *, short) ;\nint dimpart(char *, short) ;\nint loadps1() ;\nvoid termstat() ;\nvoid clear() ;\n/* varying length string */\nvoid lstran(TLSTR *, char, char) ;\nint lstrlen(TLSTR *) ;\nvoid lstrload(TLSTR *, char *, int) ;\nint lstrunld(char *, TLSTR *) ;\nvoid lstrcopy(TLSTR *, TLSTR *) ;\nvoid lstrnew(TLSTR *, char *) ;\nvoid lstrsub(TLSTR *, TLSTR *, int, int) ;\nint lstrindx(TLSTR *, TLSTR *) ;\nvoid lstrfill(TLSTR *, char *) ;\nint lstrcmpc(TLSTR *, char *) ;\nvoid lstrdel(TLSTR *) ;\nvoid lstrrep(TLSTR *, char *, int) ;\nvoid lstrcat(TLSTR *, TLSTR *, TLSTR *) ;\n/* utility */\nvoid fill(char *, char, int) ;\nvoid dumpchar(char *, int) ;\nvoid overlay(char *, int, char *, int, int) ;\nvoid serror(int, char *) ;\n\n\n/* application routines */\nvoid buildwin() ;\nvoid dispwin() ;\nvoid winmsg(char *) ;\n\n/* variables for application */\nint cmdfid ;       /* field identifier for command line */\nint msgfid ;       /* field identifier for message line */\nint bt ;           /* top border */\nint bb ;           /* bottom border */\nint bl ;           /* left border */\nint br ;           /* right border */\nint cmdflg = 0 ;   /* command flag = true if command done */\n\n /*-----------------------------------------------------------------*\n  | Main Program                                                    |\n  *-----------------------------------------------------------------*/\nvoid main(int argc, char **argv, char **envp)\n  {\n    int rc ;        /* return code */\n\n    rc = initscr() ;  /* initialise environment */\n    if (rc==0)         /* if env OK */\n      {\n        /* initial border positions */\n        bt = 1 ;            /* top border */\n        bb = sdcb.rows ;    /* bottom border */\n        bl = 1 ;            /* left border */\n        br = sdcb.cols ;    /* right border */\n\n        /* indicate cursor on command field and set field to blank */\n        cmdflg = 1 ;\n\n        buildwin() ;  /* build the initial display window */\n        dispwin() ;   /* display the window and run appl. */\n\n        termscr() ;   /* terminate environment */\n      }\n  }\n\n\n/*-------------------------------------------------------------------*/\n/* Build a window with a title, command line and an edit space.      */\n/*-------------------------------------------------------------------*/\nvoid buildwin()\n  {\n    int t, tl ;                /* temp */\n    int i ;                    /* counter */\n    int fid ;                  /* field identifier handle */\n    TLSTR data, data1, data2, data3, data4 ; /* temp varying strings */\n    TLSTR title ;              /* title string */\n\n    /* create title line */\n    lstrnew(&title,\" DD3270: Note pad\");\n\n    /* create command line (prompt, input area, and help) */\n    lstrnew(&data,\"Command ===>\") ;   /* create VLstring */\n    fid = insfld(&data,bt+1,bl+2,PRT,WHITE,NONE);\n    if (fid<0) serror(81,\"Field insert failed\") ;\n    lstrnew(&data,\" \") ;   /* create VLstring */\n    cmdfid = insfld(&data,bt+1,bl+15,UNPRT,GREEN,NONE);\n    if (cmdfid<0) serror(81,\"Field insert failed\") ;\n    if ((br-bl)>18)\n      {\n        lstrnew(&data,\"PF1=Help PF3=End\") ;   /* create VLstring */\n        fid = insfld(&data,bt+1,br-18,PRT,WHITE,NONE);\n        if (fid<0) serror(81,\"Field insert failed\") ;\n      }\n\n    /* create message line */\n    lstrnew(&data,\" \") ;   /* create VLstring */\n    msgfid = insfld(&data,bt+2,bl+2,PRTHI,RED,NONE);\n    if (msgfid<0) serror(81,\"Field insert failed\") ;\n\n    /*----------------------------------------------------------------*/\n    /* Create top window border                                       */\n    /*   The border outline is drawn with different characters        */\n    /*     based on the devices abilities.                            */\n    /*   Window border locations are based on four global variables:  */\n    /*     bt - top border row                                        */\n    /*     bb - bottom border row                                     */\n    /*     br - right border column                                   */\n    /*     bl - left border column                                    */\n    /*----------------------------------------------------------------*/\n    if (sdcb.loadflg)\n      {\n        lstrnew(&data1,\"\\x42\\x47\") ;     /* top left corner */\n        lstrnew(&data2,\"\\x48\\x46\\x45\\x44\") ; /* top right corner */\n        lstrnew(&data3,\" \") ;\n        lstran(&title,0x40,0x48) ;      /* translate in PS blank char */\n        tl = lstrlen(&title) ; /* actual title length */\n        t = br-bl-5 ;           /* available space */\n        if (tl>t)\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrsub(&data3,&title,1,t-1) ; /* shorten title */\n            lstrcat(&data,&data,&data3) ;  /* add title */\n            lstrcat(&data,&data,&data2) ;  /* add right border */\n          }\n        else\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrcat(&data,&data,&title) ;  /* add title */\n            lstrrep(&data3,\"\\x48\",t-tl-1) ;/* repeat char to string */\n            lstrcat(&data,&data,&data3) ;  /* add top border chars */\n            lstrcat(&data,&data,&data2) ;  /* concat strings */\n          }\n        fid = insfld(&data,bt,bl,PRTAS,BLUE,NONE);\n        if (fid<0) serror(81,\"Field insert failed\") ;\n        setfld(fid,SYMSET,0x40) ;   /* make it id of PS symbols */\n      }\n    else if (sdcb.aplflg)\n      {\n        lstrnew(&data1,\"\\xc5\\xee\") ;     /* top left corner */\n        lstrnew(&data2,\"\\xa2\\xba\\xbb\\xd5\") ;   /* top right corner */\n        tl = lstrlen(&title) ; /* actual title length */\n        t = br-bl-5 ;           /* available space */\n        if (tl>t)\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrsub(&data4,&title,1,t-1) ; /* shorten title */\n            lstrnew(&data3,\"\\x28\\x43\\x01\") ;  /* stop APL chars */\n            lstran(&data3,0x01,0x00) ; /* translate 0x01 to ox00 */\n            lstrcat(&data,&data,&data3) ;  /* add stop APL */\n            lstrcat(&data,&data,&data4) ;  /* add title */\n            lstrnew(&data3,\"\\x28\\x43\\xf1\") ;  /* start APL */\n            lstrcat(&data,&data,&data3) ;  /* add start APL */\n            lstrcat(&data,&data,&data2) ;  /* add right border */\n          }\n        else\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrnew(&data3,\"\\x28\\x43\\x01\") ;  /* stop APL chars */\n            lstran(&data3,0x01,0x00) ; /* translate 0x01 to ox00 */\n            lstrcat(&data,&data,&data3) ;  /* add stop APL */\n            lstrcat(&data,&data,&title) ;  /* add title */\n            lstrnew(&data3,\"\\x28\\x43\\xf1\") ;  /* start APL */\n            lstrcat(&data,&data,&data3) ;  /* add start APL */\n            lstrrep(&data3,\"s\",t-tl-1) ;   /* repeat char to string */\n            lstrcat(&data,&data,&data3) ;  /* add top border chars */\n            lstrcat(&data,&data,&data2) ;  /* concat strings */\n          }\n        fid = insfld(&data,bt,bl,PRTAS,BLUE,NONE);\n        if (fid<0) serror(81,\"Field insert failed\") ;\n        setfld(fid,SYMSET,APL) ; /* make it APL */\n      }\n    else\n      {\n        lstrnew(&data1,\"+#\") ;     /* create VLstring */\n        lstrnew(&data2,\"-VA+\") ;   /* create VLstring */\n        lstrnew(&data3,\" \") ;\n        tl = lstrlen(&title) ;     /* actual title length */\n        t = br-bl-5 ;              /* available space */\n        if (tl>t)\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrsub(&data4,&title,1,t-1) ; /* shorten title */\n            lstrcat(&data,&data,&data4) ;  /* add title */\n            lstrcat(&data,&data,&data2) ;  /* add right border */\n          }\n        else\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrcat(&data,&data,&title) ;  /* add title */\n            lstrrep(&data3,\"-\",t-tl-1) ;   /* repeat char to string */\n            lstrcat(&data,&data,&data3) ;  /* add top border chars */\n            lstrcat(&data,&data,&data2) ;  /* concat strings */\n          }\n        fid = insfld(&data,bt,bl,PRTAS,BLUE,NONE);\n        if (fid<0) serror(81,\"Field insert failed\") ;\n      }\n\n    /* create edit area lines and left and right borders */\n    for (i=bt+1; i<=bb-1; i++)    /* edit area fields */\n      {\n        /* add left border */\n        if (sdcb.loadflg)\n          {\n            lstrnew(&data,\"\\x71\") ;\n            fid = insfld(&data,i,bl,PRTAS,BLUE,NONE) ;\n            if (fid<0) serror(81,\"Field insert failed\") ;\n            setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n          }\n        else if (sdcb.aplflg)\n          {\n            lstrnew(&data,\"e\") ;\n            fid = insfld(&data,i,bl,PRTAS,BLUE,NONE) ;\n            if (fid<0) serror(81,\"Field insert failed\") ;\n            setfld(fid,SYMSET,APL) ; /* make it APL */\n          }\n        else\n          {\n            lstrnew(&data,\"|\") ;\n            fid = insfld(&data,i,bl,PRTAS,BLUE,NONE) ;\n            if (fid<0) serror(81,\"Field insert failed\") ;\n          }\n\n        if (i> (bt+2))   /* if beyond title/command/msg area */\n          {\n            /* add text input area */\n            lstrnew(&data,\" \") ;\n            fid = insfld(&data,i,bl+2,UNHI,GREEN,NONE) ;\n            if (fid<0) serror(81,\"Field insert failed\") ;\n          }\n\n        /* add right border */\n        if (sdcb.loadflg)\n          {\n            lstrnew(&data,\"\\x71\") ;\n            fid = insfld(&data,i,br-1,PRTAS,BLUE,NONE) ;\n            if (fid<0) serror(81,\"Field insert failed\") ;\n            setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n          }\n        else if (sdcb.aplflg)\n          {\n            lstrnew(&data,\"e\") ;\n            fid = insfld(&data,i,br-1,PRTAS,BLUE,NONE) ;\n            if (fid<0) serror(81,\"Field insert failed\") ;\n            setfld(fid,SYMSET,APL) ; /* make it APL */\n          }\n        else\n          {\n            lstrnew(&data,\"|\") ;\n            fid = insfld(&data,i,br-1,PRTAS,BLUE,NONE) ;\n            if (fid<0) serror(81,\"Field insert failed\") ;\n          }\n      }  /* of for edit area lines */\n\n    /* create bottom border */\n    if (sdcb.loadflg)\n      {\n        lstrnew(&data1,\"\\x67\") ;       /* lower left corner */\n        lstrnew(&data2,\"\\x69\") ;       /* lower right corner */\n        lstrrep(&data,\"\\x70\",br-bl-2) ;/* lower border chars */\n        lstrcat(&data,&data1,&data) ;  /* concat strings */\n        lstrcat(&data,&data,&data2) ;  /* concat strings */\n        fid = insfld(&data,bb,bl,PRTAS,BLUE,NONE) ;\n        if (fid<0) serror(81,\"Field insert failed\") ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n      }\n    else if (sdcb.aplflg)\n      {\n        lstrnew(&data1,\"D\") ;          /* lower left corner */\n        lstrnew(&data2,\"M\") ;          /* lower right corner */\n        lstrrep(&data,\"s\",br-bl-2) ;   /* lower border chars */\n        lstrcat(&data,&data1,&data) ;  /* concat strings */\n        lstrcat(&data,&data,&data2) ;  /* concat strings */\n        fid = insfld(&data,bb,bl,PRTAS,BLUE,NONE) ;\n        if (fid<0) serror(81,\"Field insert failed\") ;\n        setfld(fid,SYMSET,APL) ; /* make it APL */\n      }\n    else\n      {\n        lstrnew(&data1,\"+\") ;          /* lower left corner */\n        lstrnew(&data2,\"+\") ;          /* lower right corner */\n        lstrrep(&data,\"-\",br-bl-2) ;   /* lower border chars */\n        lstrcat(&data,&data1,&data) ;  /* concat strings */\n        lstrcat(&data,&data,&data2) ;  /* concat strings */\n        fid = insfld(&data,bb,bl,PRTAS,BLUE,NONE) ;\n        if (fid<0) serror(81,\"Field insert failed\") ;\n      }\n  }\n\n\n/*-------------------------------------------------------------------*/\n/* Display the window and process the keys/commands entered.         */\n/*-------------------------------------------------------------------*/\nvoid dispwin()\n  {\n    TLSTR temp  ;        /* temp varying length string */\n    TLSTR command ;      /* command name varying length string */\n    char key ;           /* AID for the key just pressed */\n\n    lstrnew(&command,\" \") ;\n    while(lstrcmpc(&command,\"end\") != 0)\n      {\n        if (cmdflg)\n          {\n            /* set initial cursor row and col to the command field */\n            currow = bt + 1 ;\n            curcol = bl + 16 ;\n            /* blank out the command line */\n            lstrnew(&command,\" \") ;\n            modfld(cmdfid,&command) ;\n            cmdflg = 0 ;\n          }\n        key = dspflds() ;     /* display the screen and get aid=key */\n        lstrnew(&temp,\" \") ;\n        modfld(msgfid,&temp) ;    /* blank message line */\n        getfld(cmdfid,&command) ;  /* get the command line */\n\n        /* Process function keys PFKs */\n        switch (key)\n          {\n            case ENTER:\n              if (currow == bt) /* window border accelerators */\n                {\n                  if (curcol == (bl+2))  /* close window */\n                    {\n                      lstrnew(&command,\"end\") ;\n                    }\n                  else if (curcol == (br-2))  /* minimise window */\n                    {\n                      bt = 1 ;\n                      bl = 1 ;\n                      br = 40 ;\n                      bb = 6 ;\n                      remflds() ;\n                      buildwin() ;  /* re-build the display window */\n                    }\n                  else if (curcol == (br-1))  /* maximise window */\n                    {\n                      bt = 1 ;\n                      bl = 1 ;\n                      br = sdcb.cols ;\n                      bb = sdcb.rows ;\n                      remflds() ;\n                      buildwin() ;  /* re-build the display window */\n                    }\n                }\n              break ;\n            case PF1:    /* No help message */\n              winmsg(\n                \"Move border: PF23=Top PF11=Bottom PF10=Left PF12=Right\"\n                ) ;\n              break ;\n            case PF3:    /* Generate end command */\n            case PF15:   /* Alternate generate end command */\n              lstrnew(&command,\"end\") ;\n              break ;\n\n            case PF10:   /* move left border */\n              if ((curcol<(br-25)) &&\n                  (curcol>=1) )\n                {\n                  bl = curcol-1 ; /* adjust for attr byte */\n                  remflds() ;\n                  buildwin() ;  /* re-build the display window */\n                }\n              else\n                winmsg(\"Left border move position too far.\") ;\n              break ;\n\n            case PF11:   /* move bottom border */\n              if ((currow>(bt+8)) &&\n                  (currow<=sdcb.rows) )\n                {\n                  bb = currow ;\n                  remflds() ;\n                  buildwin() ;  /* re-build the display window */\n                }\n              else\n                winmsg(\"Bottom border move position too far.\") ;\n              break ;\n\n            case PF12:   /* move right border */\n              if ((curcol>(bl+25)) &&\n                 (curcol<=sdcb.cols) )\n                {\n                  br = curcol-1 ;  /* adjust for attr byte */\n                  remflds() ;\n                  buildwin() ;  /* re-build the display window */\n                }\n              else\n                winmsg(\"Right border move position too far.\") ;\n              break ;\n\n            case PF23:   /* move top border */\n              if ((currow<(bb-8)) &&\n                  (currow>=1) )\n                {\n                  bt = currow ;\n                  remflds() ;\n                  buildwin() ;  /* re-build the display window */\n                }\n              else\n                winmsg(\"Top border move position too far.\") ;\n              break ;\n\n            case PF24:   /* zoom to max window size */\n              bt = 1 ;\n              bl = 1 ;\n              br = sdcb.cols ;\n              bb = sdcb.rows ;\n              remflds() ;\n              buildwin() ;  /* re-build the display window */\n              break ;\n\n            case PA2:    /* reshow key does nothing - yet */\n              break ;\n\n            default:     /* any other key is not valid */\n              bellflg = 1 ;  /* sound alarm */\n              winmsg(\"Invalid function key.\") ;\n              break ;\n          }\n\n        /* Process command from the command line */\n        if (lstrcmpc(&command,\"test\") == 0)   /* test command */\n          {\n            winmsg(\"The test command was entered.\") ;\n            cmdflg = 1 ;  /* reset command line */\n          }\n        else if (lstrcmpc(&command,\"dump\") == 0)  /* dump command */\n          {\n            dumpfld() ;\n            winmsg(\"Dump command executed.\") ;\n            cmdflg = 1 ;  /* reset command line */\n          }\n        else if (lstrcmpc(&command,\"load\") == 0)  /* force load PS */\n          {\n            loadps1() ;\n            winmsg(\"Load PS type 1 command executed.\") ;\n            cmdflg = 1 ;  /* reset command line */\n          }\n        else if (lstrcmpc(&command,\"termstat\") == 0) /*dump term data*/\n          {\n            termstat() ;\n            winmsg(\"Terminal status printed.\") ;\n            cmdflg = 1 ;  /* reset command line */\n          }\n        else if (lstrcmpc(&command,\"traceon\") == 0) /* trace on */\n          {\n            iotrace = 1 ;\n            winmsg(\"Trace is on.\") ;\n            cmdflg = 1 ;  /* reset command line */\n          }\n        else if (lstrcmpc(&command,\"traceoff\") == 0) /* trace off */\n          {\n            iotrace = 0 ;\n            winmsg(\"Trace is off.\") ;\n            cmdflg = 1 ;  /* reset command line */\n          }\n\n      }   /* of while command not end */\n    clear() ;   /* clear the 3270 screen */\n  }\n\n\n/*-------------------------------------------------------------------*/\n/* Display the window and process the keys/commands entered.         */\n/*-------------------------------------------------------------------*/\nvoid winmsg(char *msg)\n  {\n    TLSTR msgstr  ;     /* message varying length string */\n\n    lstrnew(&msgstr,msg) ;\n    modfld(msgfid,&msgstr) ;\n  }\n\n/*********************************************************************/\n/* 3270 field handling routines                                      */\n/*   rc = initscr()                                                  */\n/*   termscr()                                                       */\n/*   fid = insfld(data,row,col,attr,color,hilite)                    */\n/*   rc = remflds()                                                  */\n/*   rc = delfld(fid)                                                */\n/*   rc = erasefld(fid)                                              */\n/*   rc = getfld(fid,returndata)                                     */\n/*   rc = modfld(fid,newdata)                                        */\n/*   rc = setfld(fid,attrtype,attrvalue)                             */\n/*   dumpflds()                                                      */\n/*                                                                   */\n/*********************************************************************/\n\n\n/*-------------------------------------------------------------------*/\n/* Set up the screen environment.                                    */\n/*-------------------------------------------------------------------*/\nint initscr()\n{\n    int rc = 0 ;\n\n    buffer = (char *)malloc(BUFFMAX) ;  /* alloc tput/get buffer */\n    if (buffer)\n      {\n        rc = getdev() ;  /* get3270 device information */\n        if (rc==0 && sdcb.loadflg==1)\n          loadps1() ;\n      }\n    else\n      rc = 1 ;   /* could not get buffer */\n\n    return rc ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Terminate screen environment.                                     */\n/*-------------------------------------------------------------------*/\nvoid termscr()\n{\n    if (screen)\n      remflds() ;       /* remove any remaining fields */\n\n    free((char *)buffer) ;  /* remove tput/get buffer */\n}\n\n/*-------------------------------------------------------------------*/\n/* Display current contents of the 3270 field list.                  */\n/*-------------------------------------------------------------------*/\nchar dspflds()\n{\n  TSFLD *curr ;\n  int rc, bufpos, trow = 0, tcol = 0, fstart, fend, ilen ;\n  char sba\u00dd2\u00a8 ;\n  char aid ;\n\n  /* assemble buffer, it will contain: (EW WCC) followed by all  */\n  /* the display fields. Each field will contain:                */\n  /*   (SFE 0x03 0xC0 fattr HILITE fhilite COLOR fcolor data)    */\n  if (sdcb.altflg)\n    buffer\u00dd0\u00a8 = EWA ;     /* erase write alternate */\n  else\n    buffer\u00dd0\u00a8 = EW ;      /* erase write */\n\n  /* determine if the bell should be rung */\n  if (bellflg)\n    {\n      buffer\u00dd1\u00a8 = WCCRES | WCCKBD | WCCMDT | WCCBEL ;\n      bellflg = 0 ;  /* turn bell flag off, one ring only */\n    }\n  else\n    buffer\u00dd1\u00a8 = WCCRES | WCCKBD | WCCMDT ;\n\n  bufpos = 2 ;\n  curr = screen ;     /* first node in field list */\n  while (curr)\n    {\n      buffer\u00ddbufpos++\u00a8 = SBA ;  /* set buffer address */\n      rc2sba(curr->fypos,curr->fxpos,sba) ;\n      buffer\u00ddbufpos++\u00a8 = sba\u00dd0\u00a8 ;\n      buffer\u00ddbufpos++\u00a8 = sba\u00dd1\u00a8 ;\n      if (sdcb.edsflg)\n        {\n          buffer\u00ddbufpos++\u00a8 = SFE ;  /* start field extended */\n          buffer\u00ddbufpos++\u00a8 = 0x03 ;\n          buffer\u00ddbufpos++\u00a8 = 0xc0 ;\n          buffer\u00ddbufpos++\u00a8 = curr->fattr ;\n          buffer\u00ddbufpos++\u00a8 = HILITE ;\n          buffer\u00ddbufpos++\u00a8 = curr->fhilite ;\n          buffer\u00ddbufpos++\u00a8 = COLOR ;\n          buffer\u00ddbufpos++\u00a8 = curr->fcolor ;\n\n          /* insert set character attribute before data if APL/PS syms*/\n          /* are required and the field has protection turned on.     */\n          if (((curr->symbol==APL) || (curr->symbol==0x40)) /*APL/PS*/\n            && (curr->fattr & 0x40)) /* and protected field */\n            {\n              buffer\u00ddbufpos++\u00a8 = SA ;           /* set attribute */\n              buffer\u00ddbufpos++\u00a8 = SYMSET ;       /* symbol */\n              if (curr->symbol==APL) /* APL ? */\n                buffer\u00ddbufpos++\u00a8 = sdcb.aplflg ; /* use APL's lcid */\n              else\n                buffer\u00ddbufpos++\u00a8 = curr->symbol ; /* use symbol value */\n            }\n        }\n      else    /* dont used extended data stream */\n        {\n          buffer\u00ddbufpos++\u00a8 = SF ;  /* start field */\n          buffer\u00ddbufpos++\u00a8 = curr->fattr ;\n        }\n\n      /* insert field data */\n      ilen = lstrunld(&buffer\u00ddbufpos\u00a8,&curr->fdata) ;\n      bufpos = bufpos + ilen ;\n\n      /* revert to standard symbols after APL/PS data symbols  */\n      if (((curr->symbol==APL) || (curr->symbol==0x40)) /*APL/PS*/\n        && (curr->fattr & 0x40)) /* and protected field */\n        {\n          buffer\u00ddbufpos++\u00a8 = SA ;       /* set attribute */\n          buffer\u00ddbufpos++\u00a8 = SYMSET ;   /* symbol */\n          buffer\u00ddbufpos++\u00a8 = DFLT ;     /* revert to default symbols */\n        }\n\n      curr = curr->next ;  /* go to next field */\n    }\n\n  /* insert the cursor in the same location the user left it */\n  buffer\u00ddbufpos++\u00a8 = SBA ;     /* add set buffer address order */\n  rc2sba(currow,curcol,sba) ;  /* determine SBA for current row/col */\n  buffer\u00ddbufpos++\u00a8 = sba\u00dd0\u00a8 ;  /* add buffer addr part 1 */\n  buffer\u00ddbufpos++\u00a8 = sba\u00dd1\u00a8 ;  /* add buffer addr part 2 */\n  buffer\u00ddbufpos++\u00a8 = ICUR ;    /* add insert cursor order */\n\n  /* dumpchar(buffer,bufpos) ; */\n\n  /* write buffer to the 3270 */\n  rc = tputn(buffer, bufpos) ;\n\n  fill(buffer,0x00,bufpos) ;\n  /* receive the response from the user */\n  rc = tgetn(buffer, BUFFMAX ) ;\n\n  /* decode input, should be an AID, a cursor pos bufferaddr */\n  /* and a list of fields (SBA addr1 addr2 data)             */\n\n  aid = buffer\u00dd0\u00a8 ;      /* get code of key that was pressed */\n  sba\u00dd0\u00a8 = buffer\u00dd1\u00a8 ;\n  sba\u00dd1\u00a8 = buffer\u00dd2\u00a8 ;\n  sba2rc(sba,&currow,&curcol,0) ;  /* convert and store cursor pos */\n                                   /* adjust = 0 used for cursor pos */\n\n  curr = screen ;\n  fstart = 0 ;\n  bufpos = 3 ;\n  while(bufpos<=BUFFMAX)\n    {\n      if (buffer\u00ddbufpos\u00a8==SBA)\n        {\n          /* get new buffer address */\n          bufpos++ ;\n          sba\u00dd0\u00a8 = buffer\u00ddbufpos++\u00a8 ;\n          sba\u00dd1\u00a8 = buffer\u00ddbufpos++\u00a8 ;\n          sba2rc(sba,&trow,&tcol,1) ; /* convert buf.addr to row/col */\n                              /* adjust = 1 used for retn. buf. addr */\n          fstart = bufpos ;\n\n          /* locate field by r/c then write data to field list entry */\n          while( !((curr->fxpos==tcol) && (curr->fypos==trow)) )\n            {                          /* locate */\n              curr = curr->next ;\n              if (!curr) break ; /* could not locate - real bad */\n            }\n\n          if (curr)    /* found field - copy the data into it */\n            {\n              /* first locate end of data */\n              fend = fstart ;\n              while ((buffer\u00ddfend\u00a8 != SBA) &&\n                     (buffer\u00ddfend\u00a8 != 0x00))\n                fend++ ;  /* leaves fend pointing at next char. */\n\n              /* copy data from buffer into field list */\n              ilen = fend - fstart ;\n              lstrload(&curr->fdata,&buffer\u00ddfstart\u00a8,ilen) ;\n\n              /* adjust bufpos to last char of this returned SBA */\n              bufpos = fend -1 ;\n            }\n          else\n            {\n              /* SEVERE ERROR: This should never happen */\n              printf(\"No locate field: row %d col %d SBA %.2X %.2X\\n\",\n                trow,tcol,sba\u00dd0\u00a8,sba\u00dd1\u00a8) ;\n              curr = screen ;  /* further searches from top */\n            }\n        }\n      else\n        bufpos++ ;   /* advance to next char */\n    }\n\n  return aid ;    /* data returned OK */\n}\n\n\n/*-------------------------------------------------------------------*/\n/* Dump field list to stdout.                                        */\n/*-------------------------------------------------------------------*/\nvoid dumpfld()\n{\n  TSFLD *curr ;\n  int i = 0, size = 0 ;\n  char sba\u00dd2\u00a8 ;\n\n  printf(\"Field list follows:\\n\") ;\n  curr = screen ;     /* first node in field list */\n  while (curr)\n    {\n      printf(\"  Field at row %d col %d\\n\",curr->fypos,curr->fxpos) ;\n      rc2sba(curr->fypos,curr->fxpos,sba) ;\n      printf(\"    BufAddr: %.2X %.2X \",sba\u00dd0\u00a8,sba\u00dd1\u00a8) ;\n      printf(\"Attrib: %.2X \",curr->fattr) ;\n      printf(\"Hilite: %.2X \",curr->fhilite) ;\n      printf(\"Color: %.2X \",curr->fcolor) ;\n      printf(\"Symbol: %.2X \",curr->symbol) ;\n      printf(\"DataLen: %d\\n\",curr->fdata.len) ;\n      printf(\"    Data dump: \\n\") ;\n      dumpchar(curr->fdata.data,curr->fdata.len) ;\n      size = size + curr->fdata.len  + 11 ;\n      i++ ;\n      curr = curr->next ;\n    }\n  printf(\"Total fields %d, buffer size required %d\\n\",i,size) ;\n}\n\n\n/*-------------------------------------------------------------------*/\n/* Print terminal status.                                            */\n/*-------------------------------------------------------------------*/\nvoid termstat()\n{\n  printf(\"Terminal status follows:\\n\") ;\n  printf(\"  Device name.........: %s\\n\",sdcb.modname) ;\n  printf(\"  Device model........: %d\\n\",sdcb.model) ;\n  printf(\"  Device type.........: %d\\n\",sdcb.type) ;\n  printf(\"  Addressing mode.....: %d\\n\",sdcb.adrmode) ;\n  printf(\"  Maximum rows........: %d\\n\",sdcb.rows) ;\n  printf(\"  Maximum columns.....: %d\\n\",sdcb.cols) ;\n  printf(\"  Cell height.........: %d\\n\",sdcb.celheigh) ;\n  printf(\"  Cell width..........: %d\\n\",sdcb.celwidth) ;\n  printf(\"  Supported colors....: %d\\n\",sdcb.colors) ;\n  printf(\"  Actual colors.......: %d\\n\",sdcb.colora) ;\n  printf(\"  Color attr list.....: %.32X\\n\",sdcb.colorlst) ;\n  printf(\"  Number of Highlights: %d\\n\",sdcb.hilites) ;\n  printf(\"  Highlight attr list.: %.8X\\n\",sdcb.hilitlst) ;\n  if (sdcb.unit)\n    printf(\"  Unit................: mm\\n\") ;\n  else\n    printf(\"  Unit................: inch\\n\") ;\n  printf(\"  Alternate device....: %d\\n\",sdcb.altflg) ;\n  printf(\"  APL symbol set......: %.2X\\n\",sdcb.aplflg) ;\n  printf(\"  Extended data stream: %d\\n\",sdcb.edsflg) ;\n  printf(\"  Loadable symbols....: %d\\n\",sdcb.loadflg) ;\n  printf(\"  Load PS extended....: %d\\n\",sdcb.psflg) ;\n  printf(\"  Triple plane symbols: %d\\n\",sdcb.triflg) ;\n  printf(\"  Double byte symbols.: %d\\n\",sdcb.dbcsflg) ;\n  printf(\"  Vector graphic......: %d\\n\",sdcb.graflg) ;\n}\n\n\n/*-------------------------------------------------------------------*/\n/* Add a field to the 3270 field list.                               */\n/*-------------------------------------------------------------------*/\nint insfld(TLSTR *flddata,       /* the data */\n            int ypos,            /* display at row */\n            int xpos,            /* display at column */\n            char attr,           /* field attribute PRT, UNPRT ...*/\n            char color,          /* field color RED, BLUE, ...*/\n            char hilite )        /* field hilite BLINK, RVIDEO,...*/\n{\n  int rc ;\n  TSFLD *newfld, *last, *top ;\n\n  /* get storage for new nodes */\n  newfld = (TSFLD *)malloc(sizeof(TSFLD)) ;\n  if (!newfld) serror(20,\"Not enough memory\") ;\n  memset(newfld,0x00,sizeof(TSFLD)) ;\n\n  /* verify contents of all parameters */\n  if ((flddata->len > 0) &&\n    (flddata->len <= (sdcb.rows * sdcb.cols)))\n    lstrcopy(&newfld->fdata,flddata) ;\n  else\n    return -1 ;\n\n  if ((xpos > 0) &&\n    (xpos < sdcb.cols))\n    newfld->fxpos = xpos ;\n  else\n    return -2 ;\n\n  if ((ypos > 0) &&\n    (ypos <= sdcb.rows))\n    newfld->fypos = ypos ;\n  else\n    return -3 ;\n\n  rc = modattr(&newfld->fattr,attr) ;\n  if (rc) return -4 ;\n\n  rc = modcolor(&newfld->fcolor,color) ;\n  if (rc) return -5 ;\n\n  rc = modhilite(&newfld->fhilite,hilite) ;\n  if (rc) return -6 ;\n\n  /* insert the field into the field list in order of buffer offset */\n  top = screen ;\n  if (!top)   /* first entry in the list (screen->00) */\n    {\n      newfld->next = NULL ;\n      screen = newfld ;\n    }\n  else\n    {\n      last = NULL ;  /* last node examined */\n      while(top)    /* loop through fields for insert place */\n        {\n          if ((top->fxpos+top->fypos*sdcb.cols) <\n            (newfld->fxpos+newfld->fypos*sdcb.cols)) /* rel.buff.pos */\n            {    /* chain to next node */\n              last = top ;\n              top = top->next ;\n            }\n          else\n            {\n              if (last)  /* insert the new node, in middle of list */\n                {\n                  last->next = newfld ;\n                  newfld->next = top ;\n                }\n              else   /* insert new first node in list */\n                {\n                  newfld->next = top ;\n                  screen = newfld ;\n                }\n              break ;   /* exit loop */\n            }\n        }\n      if (!newfld->next)  /* stil not inserted? - add to end */\n        last->next = newfld ;\n    }\n\n  /* update field id table and field id in field struct */\n  newfld->fid = fidnext ;\n  sfidtab\u00ddfidnext\u00a8 = newfld ;\n  rc = fidnext++ ;\n  return rc ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Remove all fields defined from the 3270 field list.               */\n/*-------------------------------------------------------------------*/\nint remflds()\n{\n  int i ;\n  TSFLD *curr, *top ;\n\n  for (i=0; i<SFIDMAX; i++)  /* empty fid table */\n    sfidtab\u00ddi\u00a8 = NULL ;\n  fidnext = 0 ;              /* reset next fid */\n\n  top = screen ;             /* free field list */\n  while(top)\n    {\n      curr = top ;\n      top = top->next ;\n      free((char *)curr->fdata.data) ;\n      free((TSFLD *)curr) ;\n    }\n  screen = NULL ;\n  return 0 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Delete a field from the 3270 field list.                          */\n/*-------------------------------------------------------------------*/\nint delfld(int id)\n{\n    TSFLD *curr, *top, *last ;\n\n    if ((id < SFIDMAX) && (id >= 0))\n      {\n        curr = sfidtab\u00ddid\u00a8 ;\n        if (curr)\n          {\n            top = screen ;\n            last = NULL ;\n            while (top)\n              {\n                if (top == curr)\n                  {\n                    if (!last)   /* ? found node at top */\n                      screen = top->next ;\n                    else if (!top->next)  /* ? last node */\n                      last->next = NULL ;\n                    else           /* in middle of list */\n                      last->next = top->next ;\n                    /* delete the node */\n                    free((char *)top->fdata.data) ;\n                    free((TSFLD *)top) ;\n                    sfidtab\u00ddid\u00a8 = NULL ; /* invalidate id */\n                    return 0 ;  /* field id removed OK */\n                  }\n                last = top ;  /* remember last node */\n                top = top->next ;   /* chain to next node */\n              }    /* of while top */\n          }\n        else return 1 ;     /* invalid id */\n      }\n    else return 2 ;    /* out of range id */\n    return 3 ;     /* idtab list mismatch */\n}\n\n/*-------------------------------------------------------------------*/\n/* Erase the contents of a field in the 3270 field list.             */\n/*-------------------------------------------------------------------*/\nint erasefld(int id)\n{\n  TSFLD *curr ;\n\n  if ((id < SFIDMAX) && (id >= 0))\n    {\n      curr = sfidtab\u00ddid\u00a8 ;\n      if (curr)\n        lstrfill(&curr->fdata,\"\\0\") ; /* fill with zeros */\n      else\n        return 1 ;     /* invalid id */\n    }\n  else\n    return 2 ;    /* out of range id */\n\n  return 0 ;    /* id erased OK */\n}\n\n/*-------------------------------------------------------------------*/\n/* Get the current contents of a field in the 3270 field list.       */\n/*-------------------------------------------------------------------*/\nint getfld(int id,\n           TLSTR *retdata)\n{\n  TSFLD *curr ;\n\n  if ((id < SFIDMAX) && (id >= 0))\n    {\n      curr = sfidtab\u00ddid\u00a8 ;\n      if (curr)\n        lstrcopy(retdata,&curr->fdata) ; /* copy data */\n      else\n        return 1 ;     /* invalid id */\n    }\n  else\n    return 2 ;    /* out of range id */\n\n  return 0 ;    /* data returned OK */\n}\n\n/*-------------------------------------------------------------------*/\n/* Modify the contents of a field in the 3270 field list.            */\n/*-------------------------------------------------------------------*/\nint modfld(int id,\n           TLSTR *newdata)\n{\n  TSFLD *curr ;\n\n  if ((id < SFIDMAX) && (id >= 0))\n    {\n      curr = sfidtab\u00ddid\u00a8 ;\n      if (curr)\n        {\n          if ((newdata->len > 0) &&\n            (newdata->len <= (sdcb.rows * sdcb.cols)))\n            lstrcopy(&curr->fdata,newdata) ; /* alter field data*/\n          else\n            return 1 ;  /* data too large or 0 */\n        }\n      else\n        return 2 ;     /* invalid id */\n    }\n  else\n    return 3 ;    /* out of range id */\n\n  return 0 ;    /* data returned OK */\n}\n\n/*-------------------------------------------------------------------*/\n/* Change the attributes of a field in the 3270 field list.          */\n/*-------------------------------------------------------------------*/\nint setfld(int id,\n           int type,\n           char value)\n{\n  TSFLD *curr ;\n  int rc = 0 ;\n\n  if ((id < SFIDMAX) && (id >= 0))\n    {\n      curr = sfidtab\u00ddid\u00a8 ;\n      if (curr)\n        {\n          switch (type)\n            {\n            case ALL:\n              rc = modcolor(&curr->fcolor,DFLT) ;\n              rc = modhilite(&curr->fhilite,DFLT) ;\n              rc = modattr(&curr->fattr,DFLT) ;\n              break ;\n            case HILITE:\n              rc = modhilite(&curr->fhilite,value) ;\n              break ;\n            case COLOR:\n              rc = modcolor(&curr->fcolor,value) ;\n              break ;\n            case ATTR:\n              rc = modattr(&curr->fattr,value) ;\n              break ;\n            case SYMSET:\n              rc = modsym(&curr->symbol,value) ;\n              break ;\n            default:\n              return 1 ;    /* invalid type */\n            }\n        }\n      else\n        return 1 ;     /* invalid id */\n    }\n  else\n    return 2 ;    /* out of range id */\n\n  return rc ;   /* return */\n}\n\n\n\n/*********************************************************************/\n/* 3270 support routines                                             */\n/*   rc2sba(row,col,sba)                                             */\n/*   sba2rc(sba,row,col,adjust)                                      */\n/*   rc = modcolor(out,in)                                           */\n/*   rc = modhilit(out,in)                                           */\n/*   rc = modattr(out,in)                                            */\n/*   rc = tputn(buf,buflen)                                          */\n/*   rc = tgetn(buf,buflen)                                          */\n/*   rc = tpgn(buf,buflen)                                           */\n/*   rc = getdev()                                                   */\n/*   rc = getterm(primrow,primcol,altrow,altcol,attrs)               */\n/*   rc = querydev()                                                 */\n/*   rc = dsummary(buf,buflen)                                       */\n/*   rc = darea(buf,buflen)                                          */\n/*   rc = dcharset(buf,buflen)                                       */\n/*   rc = dcolor(buf,buflen)                                         */\n/*   rc = dhilite(buf,buflen)                                        */\n/*   rc = dmodes(buf,buflen)                                         */\n/*   rc = dimpart(buf,buflen)                                        */\n/*                                                                   */\n/*********************************************************************/\n\n/*-------------------------------------------------------------------*/\n/* The TPUTN routine is loaded below the 16M line                    */\n/* It issues the TPUT macro with the NOEDIT option                   */\n/*-------------------------------------------------------------------*/\nint tputn(char *buf, int buflen)\n  {\n    int rc = 0 ;\n    int (*tputn)(char *,int) ;\n\n    loadm(\"TPUTN\",&tputn) ;\n    if (iotrace)      /* trace terminal I/O ? */\n      {\n        printf(\"Outbound data stream:\\n\") ;\n        dumpchar(buf,buflen) ;\n      }\n    rc = (*tputn)(buf,buflen) ;\n    unloadm(tputn) ;\n    return rc ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* The TGETN routine is loaded below the 16M line                    */\n/* It issues the TGET macro with the FULLSCR option.                 */\n/*-------------------------------------------------------------------*/\nint tgetn(char *buf, int buflen)\n  {\n    int rc = 0 ;\n    int (*tgetn)(char *,int) ;\n\n    loadm(\"TGETN\",&tgetn) ;\n    rc = (*tgetn)(buf,buflen) ;\n    if (iotrace)      /* trace terminal I/O ? */\n      {\n        printf(\"Inbound data stream:\\n\") ;\n        dumpchar(buf,buflen) ;\n      }\n    unloadm(tgetn) ;\n    return rc ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* The TPGN routine is loaded below the 16M line                     */\n/* It issues the TPG macro with the NOEDIT option.                   */\n/*-------------------------------------------------------------------*/\nint tpgn(char *buf, int buflen)\n  {\n    int rc = 0 ;\n    int (*tpgn)(char *,int) ;\n\n    loadm(\"TPGN\",&tpgn) ;\n    if (iotrace)      /* trace terminal I/O ? */\n      {\n        printf(\"Outbound data stream:\\n\") ;\n        dumpchar(buf,buflen) ;\n      }\n    rc = (*tpgn)(buf,buflen) ;\n    unloadm(tpgn) ;\n    return rc ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* Convert row/column to 3270 12/16 bit buffer address.              */\n/*-------------------------------------------------------------------*/\nvoid rc2sba(int row,\n            int col,\n            char *sba)\n{\n  int offset, byte1, byte2 ;\n\n  offset = ((row-1)*sdcb.cols)+(col-1) ;\n  if (sdcb.adrmode == 12)  /* addressing mode = 12 */\n    {\n      byte1 = offset >> 6 ;           /* extract high order bits */\n      byte1 = byte1 | 0x000000c0 ;    /* turn on 12 bit ind */\n\n      byte2 = offset & 0x0000003f ;   /* extract low order 6 bits */\n      byte2 = byte2 | 0x000000c0 ;    /* turn on 12 bit ind */\n\n      sba\u00dd0\u00a8 = *((char *)&byte1+3) ;  /* assemble 2 byte sba */\n      sba\u00dd1\u00a8 = *((char *)&byte2+3) ;\n    }\n  else /* adrmode = 16 or 14 */\n    {\n      byte1 = offset >> 8 ;           /* extract high order byte */\n      byte2 = offset & 0x00ff ;       /* extract low order byte */\n      sba\u00dd0\u00a8 = *((char *)&byte1+3) ;  /* assemble 2 byte sba */\n      sba\u00dd1\u00a8 = *((char *)&byte2+3) ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Convert 12/14/16-bit address to an offset and row/column.         */\n/*-------------------------------------------------------------------*/\nvoid sba2rc(char *inaddr,  /* input buffer addr */\n            int *row,      /* returned row */\n            int *col,      /* returned column */\n            int adjust)    /* amount to subtract - usuallu 0 for the */\n                           /*   returned cursor position, but is set */\n                           /*   to one to get correct returned buffer*/\n                           /*   addresses.                           */\n{\n  int taddr,     /* Temporary address holder */\n      offset ;\n  short addr ;\n  memcpy((char *)&addr,inaddr,sizeof(short)) ;\n\n  /* If 12-bit address, then we need to massage it a little */\n  if (addr & 0xc000)    /* 12-bit address ? */\n    {\n       addr &= 0x3f3f ;      /* turn off 2 hi bits in each byte */\n       taddr = addr >> 8 ;   /* taddr is first 6 bits */\n       addr &= 0x00ff ;      /* addr is second 6 bits */\n       taddr = taddr << 6 ;  /* shift taddr left and .. */\n       taddr |= addr ;       /*   merge taddr with addr into taddr */\n       offset = taddr ;      /* taddr is the offset into the buffer */\n    }\n  else\n    offset = addr ;          /* addr is the offset into the buffer */\n\n  offset = offset - adjust ; /* adjust is either 0 or 1 */\n\n  /* turn offset into row and column based on device num of columns */\n  *col = (offset % sdcb.cols) + 1 ;\n  *row = (offset / sdcb.cols) + 1 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Check color attribute and copy if valid.                          */\n/*-------------------------------------------------------------------*/\nint modsym(char *out,\n           char in )\n{\n  switch (in)\n    {\n    case DFLT:\n      *out = in ;\n      return 0 ;\n    case APL:\n      if (sdcb.aplflg)\n        {\n          *out = in ;\n          return 0 ;\n        }\n      else\n        return 1 ;\n    default:\n      if (sdcb.loadflg)\n        {\n          if ((in>=0x40) && (in<=0xef))\n            {\n              *out = in ;\n              return 0 ;\n            }\n          else\n            return 1 ;\n        }\n      else\n        return 1 ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Check color attribute and copy if valid.                          */\n/*-------------------------------------------------------------------*/\nint modcolor(char *out,\n             char in )\n{\n  switch (in)\n    {\n    case DFLT:\n    case BLUE:\n    case RED:\n    case PINK:\n    case GREEN:\n    case TURQ:\n    case YELLOW:\n    case WHITE:\n      *out = in ;\n      return 0 ;\n    default:\n      return 1 ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Check hilite attribute and copy if valid.                         */\n/*-------------------------------------------------------------------*/\nint modhilit(char *out,\n             char in )\n{\n  switch (in)\n    {\n    case NONE:\n    case BLINK:\n    case RVIDEO:\n    case USCORE:\n      *out = in ;\n      return 0 ;\n    default:\n      return 1 ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Check field attribute and copy if valid.                          */\n/*-------------------------------------------------------------------*/\nint modattr(char *out,\n            char in )\n{\n  switch (in)\n    {\n    case PRT:       /* protected normal intensity */\n    case PRTHI:     /* protected high intensity */\n    case PRTAS:     /* protected normal intensity auto skip */\n    case PRTHIAS:   /* protected high intensity auto skip */\n    case UNPRT:     /* unprotected normal intensity */\n    case UNNUM:     /* unprotected numeric normal intensity */\n    case UNNUMHI:   /* unprotected numeric high intensity */\n    case UNNON:     /* unprotected non display */\n    case UNHI:      /* unprotected high intensity */\n      *out = in ;\n      return 0 ;\n    default:\n      return 1 ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Load programmed symbols - type 1 load                             */\n/*   loads programmed symbols without compression                    */\n/*-------------------------------------------------------------------*/\nint loadps1()\n  {\n    int rc ;         /* return code */\n    int bufpos ;     /* next buffer position */\n    int i, j ;       /* counters */\n    short s ;        /* temp */\n\n    memset(buffer,0x00,BUFFMAX) ;  /* clear buffer */\n\n    bufpos = 0 ;\n    buffer\u00ddbufpos++\u00a8 = WSF ;   /* write structured field */\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;  /* structured field length */\n    buffer\u00ddbufpos++\u00a8 = 0x07 ;  /* structured field length contd. */\n    buffer\u00ddbufpos++\u00a8 = 0x06 ;  /* load PS structured field */\n    buffer\u00ddbufpos++\u00a8 = 0x41 ;  /* flags: clear sym.set and use type 1 */\n    buffer\u00ddbufpos++\u00a8 = 0xff ;  /* make associated RWS = not assigned */\n    buffer\u00ddbufpos++\u00a8 = 0x41 ;  /* starting code point */\n    buffer\u00ddbufpos++\u00a8 = 0x02 ;  /* RWS of PSA symbol set */\n\n    /* write buffer to the 3270 */\n    rc = tputn(buffer, bufpos) ;\n\n    memset(buffer,0x00, bufpos) ;  /* clear buffer */\n\n    bufpos = 0 ;\n    buffer\u00ddbufpos++\u00a8 = WSF ;   /* write structured field */\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;  /* structured field length */\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;  /* structured field length contd. */\n    buffer\u00ddbufpos++\u00a8 = 0x06 ;  /* load PS structured field */\n    buffer\u00ddbufpos++\u00a8 = 0x01 ;  /* flags: use type 1 */\n    buffer\u00ddbufpos++\u00a8 = 0x40 ;  /* make associated RWS = 0x40 */\n    buffer\u00ddbufpos++\u00a8 = 0x41 ;  /* starting code point (symbol=65) */\n    buffer\u00ddbufpos++\u00a8 = 0x02 ;  /* RWS of PSA symbol set */\n\n /* This extra stuff needs the flags bit 1 on to indicate extended\n    I dont think I need to use it yet.\n\n    buffer\u00ddbufpos++\u00a8 = 0x08 ;     P length - length of extra parms\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     flags: operator selectable ...\n    buffer\u00ddbufpos++\u00a8 = 0x09 ;     LW - width of character\n    buffer\u00ddbufpos++\u00a8 = 0x10 ;     LH - width of character\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     SUBSN - only one byte codes\n    buffer\u00ddbufpos++\u00a8 = 0xf1 ;     COLOR - F1 - first attr ???\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     ST.SUBSN - default\n    buffer\u00ddbufpos++\u00a8 = 0xf9 ;     ECHAR - last symbol=249\n\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     NW - number width pairs\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     NH - number height pairs\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     RES - reserved\n */\n\n    /* load specific font based on the cell height */\n    if (sdcb.celheigh >= 16)\n      {\n        for (i=65;i<=249;i++)   /* for each symbol, 0x41 to 0xF9 */\n          {\n            for (j=0;j<=17;j++)      /* for each slice  */\n              {\n                buffer\u00ddbufpos++\u00a8 = ps9x16u\u00ddi\u00a8\u00ddj\u00a8 ;\n              }\n          }\n      }\n    else if (sdcb.celheigh == 15)\n      {\n        for (i=65;i<=249;i++)   /* for each symbol, 0x41 to 0xF9 */\n          {\n            for (j=0;j<=17;j++)      /* for each slice  */\n              {\n                buffer\u00ddbufpos++\u00a8 = ps9x15u\u00ddi\u00a8\u00ddj\u00a8 ;\n              }\n          }\n      }\n    else\n      {\n        for (i=65;i<=249;i++)   /* for each symbol, 0x41 to 0xF9 */\n          {\n            for (j=0;j<=17;j++)      /* for each slice  */\n              {\n                buffer\u00ddbufpos++\u00a8 = ps9x12u\u00ddi\u00a8\u00ddj\u00a8 ;\n              }\n          }\n      }\n\n    s = bufpos - 1 ;\n    memcpy(buffer+1,&s,sizeof(short)) ;\n\n    /* write buffer to the 3270 to load the programmed symbols */\n    rc = tputn(buffer, bufpos) ;\n\n    memset(buffer,0x00,BUFFMAX) ;  /* clear buffer */\n    return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* Get the display device attributes.                                */\n/*-------------------------------------------------------------------*/\nint getdev()\n  {\n    int rc, pr = 0, pc = 0, ar = 0, ac = 0, att = 0 ;\n    int i ;\n\n    /* set the default values, may get over ridden later */\n    sdcb.adrmode = 12 ;  /* addressing mode */\n    sdcb.altflg = 0 ;    /* use primary device */\n    sdcb.edsflg = 0 ;    /* no extended data stream */\n    sdcb.graflg = 0 ;    /* not a graphics device */\n    sdcb.aplflg = 0 ;    /* no apl symbols on device */\n    sdcb.psflg = 0 ;     /* no program symbols on device */\n    sdcb.loadflg = 0 ;   /* no loadable symbols sets on device */\n    sdcb.triflg = 0 ;    /* no triple plane symbols sets on device */\n    sdcb.dbcsflg = 0 ;   /* no double byte symbols on device */\n    sdcb.celheigh = 0 ;  /* zero cell height on device */\n    sdcb.celwidth = 0 ;  /* zero cell width on device */\n    sdcb.unit = 0 ;      /* units are inches */\n    sdcb.colora = 1 ;    /* actual colors default to monochrome */\n    sdcb.colors = 1 ;    /* supported colors default to monochrome */\n    sdcb.hilites = 0 ;   /* supported hilites default to none */\n    for (i=0;i<17;i++)\n      sdcb.colorlst\u00ddi\u00a8 = 0x00 ; /* list of color attributes on device*/\n    for (i=0;i<5;i++)\n      sdcb.hilitlst\u00ddi\u00a8 = 0x00 ; /* list of hilite attributes on device*/\n\n\n    /* get info from TSO about this device */\n    rc = getterm(&pr,&pc,&ar,&ac,&att) ;\n    if (rc==0)                 /* get terminal info worked ? */\n      {\n        if (att==0x00000001)   /* device has query structured fields */\n          {\n            /* set row and col may be later reset by query dev */\n            if ((ar>0) && (ar!=pr) &&\n                (ac>0) && (ac!=pc))\n              {\n                sdcb.altflg = 1 ;    /* use alternate device */\n                sdcb.rows = ar ;     /* use alternate rows */\n                sdcb.cols = ac ;     /* use alternate cols */\n              }\n            else\n              {\n                sdcb.rows = pr ;     /* use primary rows */\n                sdcb.cols = pc ;     /* use primary cols */\n              }\n\n            rc = querydev() ;\n            /* try to determine actual device */\n            if (sdcb.rows == 32)\n              {\n                strcpy(sdcb.modname,\"IBM3279-3\") ;\n                sdcb.model = 3279 ;\n                sdcb.type = 3 ;\n              }\n            else if (sdcb.rows == 43)\n              {\n                strcpy(sdcb.modname,\"IBM3278-4\") ;\n                sdcb.model = 3278 ;\n                sdcb.type = 4 ;\n              }\n            else if (sdcb.rows == 27)\n              {\n                strcpy(sdcb.modname,\"IBM3290\") ;\n                sdcb.model = 3290 ;\n                sdcb.type = 5 ;\n              }\n            else  /* cant tell - use most primitive */\n              {\n                strcpy(sdcb.modname,\"IBM3278-2\") ;\n                sdcb.model = 3278 ;\n                sdcb.type = 2 ;\n              }\n          }\n        else  /* dont know a lot about the device - make some guesses */\n          {\n            if ((ar>0) && (ar!=pr) &&\n                (ac>0) && (ac!=pc))\n              {\n                sdcb.altflg = 1 ;    /* use alternate device */\n                sdcb.rows = ar ;     /* use alternate rows */\n                sdcb.cols = ac ;     /* use alternate cols */\n              }\n            else\n              {\n                sdcb.rows = pr ;     /* use primary rows */\n                sdcb.cols = pc ;     /* use primary cols */\n              }\n\n            /* try to determine actual device */\n            if (sdcb.rows == 32)\n              {\n                strcpy(sdcb.modname,\"IBM3279-3\") ;\n                sdcb.model = 3279 ;\n                sdcb.type = 3 ;\n              }\n            else if (sdcb.rows == 43)\n              {\n                strcpy(sdcb.modname,\"IBM3278-4\") ;\n                sdcb.model = 3278 ;\n                sdcb.type = 4 ;\n              }\n            else if (sdcb.rows == 27)\n              {\n                strcpy(sdcb.modname,\"IBM3290\") ;\n                sdcb.model = 3290 ;\n                sdcb.type = 5 ;\n              }\n            else  /* cant tell - use most primitive */\n              {\n                strcpy(sdcb.modname,\"IBM3278-2\") ;\n                sdcb.model = 3278 ;\n                sdcb.type = 2 ;\n              }\n          }\n        return 0 ;\n      }\n    else  /* get term failed - return its code */\n      return rc ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* This routine loads an assebbler module below the 16 MB line       */\n/* that issues the GTTERM macro instruction to obtain the            */\n/* dimensions of the screen and also some bit fields that            */\n/* tell if the device can be queried. The module copies the          */\n/* results from storage below the line to this routines              */\n/* automatic storage.                                                */\n/* Upon completion the module is unloaded.                           */\n/*-------------------------------------------------------------------*/\nint getterm(int *primrow, int *primcol,\n             int *altrow, int *altcol,\n             int *attrs)\n  {\n    struct {\n      union {\n        short sh ;\n        char c\u00dd2\u00a8 ;\n      } prim ;\n      union {\n        short sh ;\n        char c\u00dd2\u00a8 ;\n      } alt ;\n      int attr ;\n    } pm ;\n    int rc = 0 ;\n    int (*tgt327d)(void *) ;\n\n    loadm(\"TGT327D\",&tgt327d) ;   /* load ASM routine below 16M */\n    rc = (*tgt327d)(&pm) ;        /* execute GTTERM macro */\n    if (rc==0)      /* data returned OK ? */\n      {             /* yes - convert single byte numbers to int */\n        *primrow = pm.prim.c\u00dd0\u00a8 ;\n        *primcol = pm.prim.c\u00dd1\u00a8 ;\n        *altrow = pm.alt.c\u00dd0\u00a8 ;\n        *altcol = pm.alt.c\u00dd1\u00a8 ;\n        *attrs = pm.attr ;\n      }\n    unloadm(tgt327d) ;            /* unload ASM routine */\n    return rc ;                   /* return code from GTTERM */\n  }\n\n/*-------------------------------------------------------------------*/\n/* Clear 3270 screen.                                                */\n/*-------------------------------------------------------------------*/\nvoid clear()\n  {\n    int rc ;\n    char sba\u00dd2\u00a8 ;\n    char out1\u00dd\u00a8 = {      /* set up for erase */\n      WRT, 0x40,\n      SBA, 0x5d, 0x7f,   /* end addr - overlayed later */\n      SBA, 0x40, 0x40,   /* start addr row=1 col=1 */\n      SBA, 0xe7, 0x7f,   /* insert cursor location, row/col max */\n      ICUR               /* insert cursor */\n      } ;\n    char out2\u00dd\u00a8 = {      /* erase write alternate */\n      EWA, 0xc2\n      } ;\n    char out3\u00dd\u00a8 = {      /* erase primary */\n      WRT, 0xc2\n      } ;\n\n    /* set max screen size known so far sba */\n    rc2sba(sdcb.rows,sdcb.cols,sba) ;\n    out1\u00dd9\u00a8 = sba\u00dd0\u00a8 ;\n    out1\u00dd10\u00a8 = sba\u00dd1\u00a8 ;\n\n    rc = tputn(out1,sizeof(out1) ) ;   /* define the buffer */\n    rc = tputn(out2,sizeof(out2) ) ;   /* erase write alternate */\n    rc = tputn(out3,sizeof(out3) ) ;   /* erase write primary */\n  }\n\n/*-------------------------------------------------------------------*/\n/* Select the entire screen buffer using SBA based on the            */\n/* scrsize returned from GTTERM and EW/EWA to select the             */\n/* primary or alternate buffer.                                      */\n/* Then assemble a structured field query, and send it to the        */\n/* device using TPG which will cause the device to imediately        */\n/* send back the response without any user intervention.             */\n/* Then decode the read partition, query operations, query and       */\n/* put the interesting data in the sdcb structure.                   */\n/*-------------------------------------------------------------------*/\nint querydev()\n  {\n    short sflen ;      /* structured field length */\n    char  sfid ;       /* structured field ID */\n    char  qcode ;      /* query reply - query code */\n    char input\u00dd256\u00a8 ;  /* query buffer */\n    char *ibuf ;       /* current query buffer pointer */\n    int rc ;\n    char sba\u00dd2\u00a8 ;\n\n    char out1\u00dd\u00a8 = {      /* set up for erase */\n      WRT, 0x40,\n      SBA, 0x5d, 0x7f,   /* end addr - overlayed later, rc= 24,80 */\n      SBA, 0x40, 0x40,   /* start addr row=1 col=1 */\n      SBA, 0xe7, 0x7f,   /* insert cursor loc, rc= 32,80 *OVERLAYED**/\n      ICUR               /* insert cursor */\n      } ;\n\n    char out2\u00dd\u00a8 = {      /* erase write alternate */\n      EWA, 0xc2\n      } ;\n\n    char out3\u00dd\u00a8 = {      /* erase primary */\n      WRT, 0xc2\n      } ;\n\n    char out4\u00dd\u00a8 = {\n      WSF,               /* write structured field */\n      0x00, 0x05,        /* structured field length */\n      0x01,              /* read partition */\n      0xFF,              /* query operations */\n      0x02               /* query */\n      } ;\n\n    /* set max screen size known so far sba */\n    rc2sba(sdcb.rows,sdcb.cols,sba) ;\n    out1\u00dd9\u00a8 = sba\u00dd0\u00a8 ;\n    out1\u00dd10\u00a8 = sba\u00dd1\u00a8 ;\n\n    fill(input,0x00,sizeof(input)) ;   /* zero input buffer */\n\n    rc = tputn(out1,sizeof(out1) ) ;   /* define the buffer */\n    rc = tputn(out2,sizeof(out2) ) ;   /* erase write alternate */\n    rc = tputn(out3,sizeof(out3) ) ;   /* erase write primary */\n    rc = tpgn(out4,sizeof(out4) ) ;    /* query the device */\n    rc = tgetn(input,sizeof(input)) ;  /* receive device resp.*/\n\n    ibuf = input ;       /* point at input */\n\n    if (*input==0x88)    /* check for 88 AID byte */\n      {\n        ibuf = ibuf+1 ;         /* advance to 1st structured field */\n        sfid = *(ibuf+2) ;      /* sfid should be 0x81 */\n\n        while (sfid==0x81)  /* while structured fields remain */\n          {\n            sflen = *((short *)ibuf) ;  /* get structured field len */\n            if (sflen==0)           /* bad error - should not happen */\n              {\n                printf(\"Error: Structured field length zero at %p\\n\",\n                  ibuf) ;\n                dumpchar(input,sizeof(input)) ;\n                return 1 ;\n              }\n            qcode = *(ibuf+3) ;     /* get query code */\n            switch (qcode)\n              {\n                case 0x80:           /* Q-code summary */\n                  rc = dsummary(ibuf,sflen) ;\n                  break ;\n                case 0x81:           /* Usable area */\n                  rc = darea(ibuf,sflen) ;\n                  break ;\n                case 0x85:           /* Character sets */\n                  rc = dcharset(ibuf,sflen) ;\n                  break ;\n                case 0x86:           /* Color */\n                  rc = dcolor(ibuf,sflen) ;\n                  break ;\n                case 0x87:           /* Highlighting */\n                  rc = dhilite(ibuf,sflen) ;\n                  break ;\n                case 0x88:           /* Modes */\n                  rc = dmodes(ibuf,sflen) ;\n                  break ;\n                case 0xa6:           /* Implicit partition */\n                  rc = dimpart(ibuf,sflen) ;\n                  break ;\n                default:\n                  break ;\n              }  /* of switch */\n            ibuf = ibuf+sflen ; /* advance to next structured field */\n            sfid = *(ibuf+2) ;  /* sfid should be 0x81 - else stop */\n\n          } /* of while sfid=81 */\n\n      } /* of AID=88 */\n    return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x80: Qcode summary                                               */\n/*-------------------------------------------------------------------*/\nint dsummary(char *buf, short buflen)\n  {\n     int i ;\n     char qcode ;\n\n     for (i=4;i<buflen;i++)\n       {\n          qcode = *(buf+i) ;     /* get query code */\n          if (qcode == 0xb4)\n            sdcb.graflg = 1 ;    /* indicate graphic support */\n       }  /* of for i=4 */\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x81: Usable area                                                 */\n/*-------------------------------------------------------------------*/\nint darea(char *buf, short buflen)\n  {\n     char celunits\u00dd6\u00a8 ;   /* screen size unit PEL or CELL */\n     short w, h ;         /* screen size w=width h=height */\n     char aw, ah ;        /* units per cell aw=width ah=height */\n     float xr, xrd, yr, yrd ;  /* pel spacing ratio */\n     float fw, fh ;       /* ratio - pels per unit */\n\n     if ((*(buf+4) & 0x03)==0x03)\n       sdcb.adrmode = 16 ;\n     else if ((*(buf+4) & 0x01)==0x01)\n       sdcb.adrmode = 12 ;\n\n     w = *((short *)(buf+6)) ;   /* width of usable area */\n     h = *((short *)(buf+8)) ;   /* height of usable area */\n\n     if (*(buf+10) == 0x01)    /* pels/in or pels/mm */\n       sdcb.unit = 1 ;  /* units are mm */\n     else\n       sdcb.unit = 0 ;  /* units are inch */\n\n     xr = *((short *)(buf+11)) ;    /* x dim pel ratio numerator */\n     xrd = *((short *)(buf+13)) ;   /* x dim pel ratio denominator */\n     yr = *((short *)(buf+15)) ;    /* y dim pel ratio numerator */\n     yrd = *((short *)(buf+17)) ;   /* y dim pel ratio denominator */\n\n     fw = (float)(xr) / (float)(xrd) ; /* horiz. ratio pels per unit */\n     fh = (float)(yr) / (float)(yrd) ; /* vert. ratio pels per unit */\n\n     aw = *(buf+19) ;    /* number of X units in default cell */\n     ah = *(buf+20) ;    /* number of Y units in default cell */\n\n     if (*(buf+5) & 0x20)       /* byte 5 bit 3 on unit=pels */\n       strcpy(celunits,\"pels\") ;\n     else                       /* other wise unit=cells */\n       strcpy(celunits,\"cells\") ;\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x85: Character sets                                              */\n/*-------------------------------------------------------------------*/\nint dcharset(char *buf, short buflen)\n  {\n     int i, j ;         /* counters */\n     int cgcsgid ;      /* Coded graphic character set identifier */\n     short ccsid ;      /* Coded character set identifier */\n     char gf = 0 ;      /* CGCSGID not present flag */\n     char ch2 = 0 ;     /* Two byte char. set flag */\n     char ms = 0 ;      /* Multiple slot sizes flag */\n     char cf = 0 ;      /* CCSID not present flag */\n     char sdw ;         /* Default character slot width */\n     char sdh ;         /* Default character slot height */\n     char dl ;          /* character set descriptor (CSD) length */\n     char *csd ;        /* character set descriptor (CSD) ptr */\n     char set ;         /* character set ID (PS store no.) */\n     char lcid ;        /* character set Local ID (alias) */\n     char sw ;          /* character set slot width */\n     char sh ;          /* character set slot height */\n     char ssubsn ;      /* character set starting subsection */\n     char esubsn ;      /* character set ending subsection */\n\n     if (*(buf+4) & 0x10)\n       sdcb.psflg = 1 ;   /* load PS Extended supported */\n     else\n       sdcb.psflg = 0 ;   /* load PS Extended not supported */\n\n     if (*(buf+4) & 0x08)\n       ms = 1 ;   /* More than one size character slot supported */\n\n     if (*(buf+4) & 0x04)\n       ch2 = 1 ;  /* Two byte code character sets are supported */\n\n     if (*(buf+4) & 0x02)\n       gf = 1 ;   /* CGCSGID present */\n\n     if (*(buf+5) & 0x20)\n       cf = 1 ;   /* CCSID present */\n\n     sdw = *(buf+6) ;\n     sdh = *(buf+7) ;\n\n     dl = *(buf+12) ;   /* get CSD length */\n     i = 13 ;\n     while (i<buflen)\n       {\n         csd = buf + i ;  /* point at CSD to process */\n         set = *csd ;     /* get character set ID (PS store no.) */\n         if (*(csd+1) & 0x80)\n           sdcb.loadflg = 1 ;  /* loadable symbol sets exist */\n\n         if (*(csd+1) & 0x40)\n           sdcb.triflg = 1 ;   /* Triple-plane character sets exist */\n\n         if (*(csd+1) & 0x20)\n           sdcb.dbcsflg = 1 ;  /* Double-byte coded character sets */\n\n         lcid = *(csd+2) ;   /* get character set ID (PS store no.) */\n\n         j = 0 ;\n         if (ms)\n           {\n             sw = *(csd+3) ;  /* slot width */\n             sh = *(csd+4) ;  /* slot height */\n             j = j + 2 ;\n           }\n\n         if (ch2)\n           {\n             ssubsn = *(csd+j+3) ;  /* starting sub-section */\n             esubsn = *(csd+j+4) ; /* ending sub-section */\n             j = j + 2 ;\n           }\n\n         if (gf)\n           {\n             cgcsgid = *((int *)(csd+j+3)) ;  /* Graf char set ID */\n             if (cgcsgid==0x03c30136)\n               sdcb.aplflg = lcid ;   /* APL supported store lcid */\n             j = j + 4 ;\n           }\n\n         if (cf)\n           {\n             ccsid = *((short *)(csd+j+3)) ;  /* char set ID */\n           }\n\n         i = i + dl ;  /* get pos of next CSD */\n       }  /* of while i<buflen */\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x86: Colors                                                      */\n/*-------------------------------------------------------------------*/\nint dcolor(char *buf, short buflen)\n  {\n     int colora = 0 ; /* number of actual colors on device */\n     int icolor ;     /* color index */\n     int i, j = 0 ;   /* counter */\n     char attr ;      /* color attribute accepted by device */\n     char dcolor ;    /* color displayed for this attribute */\n\n     sdcb.colors = (int)*(buf+5) ; /* number of colors accepted */\n     for (i=6;i<buflen;i=i+2)\n       {\n         attr = *(buf+i) ;        /* attribute used by appl. */\n         sdcb.colorlst\u00ddj++\u00a8 = attr ;\n         dcolor = *(buf+i+1) ;    /* attr/color used by device */\n         icolor = (int)(dcolor - 0xf0) ;\n         if ((icolor >= 0) && (icolor <= 15))\n           colora++ ;\n       }\n     sdcb.colora = colora ;  /* number of actual colors on device */\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x87: Highlighting                                                */\n/*-------------------------------------------------------------------*/\nint dhilite(char *buf, short buflen)\n  {\n     int i, j = 0 ;    /* counter */\n     char attr ;       /* color attribute accepted by device */\n     char dhilite ;    /* color displayed for this attribute */\n\n     sdcb.hilites = (int)*(buf+4) ;\n     for (i=5;i<buflen;i=i+2)\n       {\n         attr = *(buf+i) ;        /* attribute used by appl. */\n         dhilite = *(buf+i+1) ;   /* attr/highlight used by device */\n         sdcb.hilitlst\u00ddj++\u00a8 = attr ;\n       }\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x88: Modes                                                       */\n/*-------------------------------------------------------------------*/\nint dmodes(char *buf, short buflen)\n  {\n     int i ;           /* counter */\n     char mode ;       /* device opperation mode */\n\n     for (i=4;i<buflen;i++)\n       {\n         mode = *(buf+i) ;        /* attribute used by appl. */\n         if ((mode==0x01) ||\n             (mode==0x02))\n           sdcb.edsflg = 1 ;  /* queryable device can use extended DS*/\n       }   /* of for i */\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0xa6: Implicit partition                                          */\n/*-------------------------------------------------------------------*/\nint dimpart(char *buf, short buflen)\n  {\n     char *sdp ;                /* self defining parameter (SDP) ptr */\n     short wd, wa, hd, ha ;     /* screen dimensions */\n     short wcd, wca, hcd, hca ; /* cell sizes */\n     int i ;                    /* counter */\n\n     i = 6 ;        /* length of header */\n     while(i < buflen)   /* loop over all SDPs */\n       {\n         sdp = buf + i ;\n         if (*sdp==0x0b)    /* is it a SDP ? */\n           {\n             if (*(sdp+1)==0x01)\n               {\n                 wd = *((short *)(sdp+3)) ;  /* default width */\n                 hd = *((short *)(sdp+5)) ;  /* default height */\n                 wa = *((short *)(sdp+7)) ;  /* alternate width */\n                 ha = *((short *)(sdp+9)) ;  /* alternate height */\n                 if ((ha>hd) || (wa>wd))\n                   {\n                     sdcb.altflg = 1 ;    /* use alternate device */\n                     sdcb.rows = ha ;     /* use alternate rows */\n                     sdcb.cols = wa ;     /* use alternate cols */\n                   }\n                 else\n                   {\n                     sdcb.rows = hd ;     /* use primary rows */\n                     sdcb.cols = wd ;     /* use primary cols */\n                   }\n                 i = i + 11 ;     /* add length of this SDP */\n               }\n             else if (*(sdp+1)==0x03)\n               {\n                 i = i + 11 ;     /* add length of this SDP */\n               }\n             else if (*(sdp+1)==0x02)\n               {\n                 wcd = *((short *)(sdp+3)) ;  /* default cell width */\n                 hcd = *((short *)(sdp+5)) ;  /* default cell height */\n                 wca = *((short *)(sdp+7)) ;  /* alternate cell width */\n                 hca = *((short *)(sdp+9)) ;  /* alternate cell height*/\n                 if (sdcb.altflg)         /* using alternate device */\n                   {\n                     sdcb.celheigh = hca ; /* use alt. cell height */\n                     sdcb.celwidth = wca ; /* use alt. cell width */\n                   }\n                 else\n                   {\n                     sdcb.celheigh = hcd ; /* use primary cell height */\n                     sdcb.celwidth = wcd ; /* use primary cols width */\n                   }\n                 i = i + 11 ;     /* add length of this SDP */\n               }\n           }\n       }  /* of while */\n\n     return 0 ;\n  }\n\n\n\n\n/*********************************************************************/\n/* General string handling routines for varying length strings.      */\n/*   lstran(mod_lstr,fromchar,tochar)                                */\n/*   lstrload(to_lstr,fromchar,len)                                  */\n/*   lstrunld(tochar,from_lstr)                                      */\n/*   lstrcopy(to_lstr,from_lstr)                                     */\n/*   lstrnew(to,fromchars)                                           */\n/*   lstrsub(to_lstr,from_lstr,start,length)                         */\n/*   len = lstrlen(haystack_lstr)                                    */\n/*   pos = lstrindex(haystack_lstr,needle_lstr)                      */\n/*   lstrfill(to_lstr,fillchars)                                     */\n/*   rc = lstrcmpc(cmp_lstr,cmpchars)                                */\n/*   lstrdel(del-lstr)                                               */\n/*   lstrrep(to_lstr,repchars,copies)                                */\n/*   lstrcat(to_lstr,left_lstr,right_lstr)                           */\n/*********************************************************************/\n\n/*-------------------------------------------------------------------*/\n/* Translate a character in an lstr to another character.            */\n/*-------------------------------------------------------------------*/\nvoid lstran(TLSTR *in, char from, char to)\n{\n  int i ;      /* temp counter */\n\n  if (in)      /* from string exists ? */\n    {\n      for (i=0;i<=in->len;i++)\n        {\n          if (*(in->data+i) == from)\n            *(in->data+i) = to ;\n        }\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Get the length of an lstr.                                        */\n/*-------------------------------------------------------------------*/\nint lstrlen(TLSTR *in)\n{\n  if (in)      /* from string exists ? */\n    {\n      return in->len ;\n    }\n  else\n    return 0 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Unload varying length string contents into character buffer.      */\n/*-------------------------------------------------------------------*/\nint lstrunld(char *to,\n             TLSTR *from)\n{\n  if (from)      /* from string exists ? */\n    {\n      memcpy(to,from->data,from->len) ;\n      return from->len ;\n    }\n  else\n    return 0 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Load varying length string with contents of character buffer.     */\n/*-------------------------------------------------------------------*/\nvoid lstrload(TLSTR *to,\n              char *from,\n              int len)\n{\n  if (to)      /* to string exists ? */\n    {\n      if (len!=to->len)\n        {\n          free((char *)to->data) ;\n          to->data = (char *)malloc(len) ;\n          if (!to->data) serror(4,\"Not enough memory\") ;\n          to->len = len ;\n        }\n      memcpy(to->data,from,len) ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Copy varying length string.                                       */\n/*-------------------------------------------------------------------*/\nvoid lstrcopy(TLSTR *to,\n              TLSTR *from)\n{\n  if (from)      /* from string exists ? */\n    {\n      if (!to)    /* to string does not exist */\n        serror(2,\"String does not exist\") ;\n      else     /* to string exists */\n        {\n          if (from->len > 0)\n            {\n              if (to->data == NULL)     /* does not exist yet ? */\n                {\n                  to->data = (char *)malloc(from->len) ;\n                  if (!to->data) serror(14,\"Not enough memory\") ;\n                }\n              else if (from->len != to->len)   /* increase length ? */\n                {\n                  free((char *)to->data) ;\n                  to->data = (char *)malloc(from->len) ;\n                  if (!to->data) serror(4,\"Not enough memory\") ;\n                }\n              to->len = from->len ;\n              memcpy(to->data,from->data,from->len) ;\n            }\n          else\n            {\n              if (to->len > 0)   /* empty data */\n                free((char *)to->data) ;\n              to->len = 0 ;\n              to->data = NULL ;\n            }\n        }\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Initialize a varying length string with a string.                 */\n/*-------------------------------------------------------------------*/\nvoid lstrnew(TLSTR *newstr,\n             char *from)\n{\n  int i ;\n\n  if (!newstr)\n    serror(5,\"String does not exist\") ;\n  else\n    {\n      i = strlen(from) ;\n      if (i > 0)\n        {\n          newstr->data = (char *)malloc(i) ;\n          if (!newstr->data) serror(17,\"Not enough memory\") ;\n          newstr->len = i ;\n          memcpy(newstr->data,from,i) ;\n        }\n      else\n        {\n          newstr->len = 0 ;\n          newstr->data = NULL ;\n        }\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Create substring of a varying length string to a varying length   */\n/* string.                                                           */\n/*-------------------------------------------------------------------*/\nvoid lstrsub(TLSTR *to,\n             TLSTR *from,\n             int start,\n             int len)\n{\n  int i ;\n\n  if (start <= from->len)\n    {\n      i = from->len - start ;\n      if (len < i)\n        i = len ;       /* i is the length of the sub string */\n\n      if (!to)\n        serror(8,\"String does not exist\") ;\n      else\n        {\n          if (i > 0)\n            {\n              if (to->data == NULL)     /* does not exist yet ? */\n                {\n                  to->data = (char *)malloc(i) ;\n                  if (!to->data) serror(20,\n                    \"Not enough memory\") ;\n                }\n              else if (to->len != i)          /* wrong size ? */\n                {\n                  free((char *)to->data) ;\n                  to->data = (char *)malloc(i) ;\n                  if (!to->data) serror(10,\n                    \"Not enough memory\") ;\n                }\n              to->len = i ;\n              memcpy(to->data,from->data+start,i) ;\n            }\n          else\n            {\n              if (to->len > 0)   /* empty data */\n                free((char *)to->data) ;\n              to->len = 0 ;\n              to->data = NULL ;\n            }\n        }\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Find the position in a varying length string of a varying length  */\n/* sub-string.                                                       */\n/*-------------------------------------------------------------------*/\nint lstrindx(TLSTR *haystack, /* string to search */\n             TLSTR *needle)   /* sub-string to search for */\n{\n  int i, j, k, endpos ;\n\n  endpos = haystack->len - needle->len ;\n  for (i=0; i<endpos; i++)\n    {\n      k = 0 ;\n      for (j=0; j<needle->len; j++)\n        {\n          if (haystack->data\u00ddi+j\u00a8 == needle->data\u00ddj\u00a8)\n            k ++ ;\n          else break ;\n        }\n      if (k==needle->len)\n        return(i+1) ;\n    }\n  return 0 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Compare a varying length string with a string.                    */\n/*   rc = 0  == strings same                                         */\n/*   rc = 1  == lstr has larger value than charstr                   */\n/*   rc = -1 == lstr has smaller value than charstr                  */\n/*-------------------------------------------------------------------*/\nint lstrcmpc(TLSTR *lstr,   /* string to compare */\n             char *cstr)    /* characters to compare with */\n{\n  int i ;               /* counter */\n  int t=0 ;             /* compare flag */\n  int l ;               /* compare length */\n  int ld=0 ;            /* length differ flag */\n  char *lstrptr ;\n  char *cstrptr ;\n\n  l = strlen(cstr) ;    /* determine shortest string */\n  if (l != lstr->len)   /* same lengths ? */\n    {                   /*   no .. */\n      ld = 1 ;          /*   flag lengths differ */\n      if (l > lstr->len)\n        l = lstr->len ; /*   use shortest length */\n    }\n\n  /* compare to shortest length */\n  lstrptr = lstr->data ;\n  cstrptr = cstr ;\n  for (i=0; i<l; i++)\n    {\n      if (*lstrptr > *cstrptr)\n        {\n          t = 1 ;    /* indicate left larger than right */\n          break ;    /* end scan now  */\n        }\n      if (*lstrptr < *cstrptr)\n        {\n          t = -1 ;   /* indicate left smaller than right */\n          break ;    /* end scan now  */\n        }\n      lstrptr++ ;\n      cstrptr++ ;\n    }\n\n  if ((t==0) && (ld==1)) /* same after shortest length compared ? */\n    {\n      if (strlen(cstr) > lstr->len)\n        t = -1 ;     /* lstr smaller */\n      else\n        t = 1 ;      /* lstr larger */\n    }\n  return t ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Fill a varying length string with a string.                       */\n/*-------------------------------------------------------------------*/\nvoid lstrfill(TLSTR *string,   /* string to fill */\n              char *fillstr)  /* filler characters to use */\n{\n  int i ;\n  char *strptr ;\n\n  strptr = fillstr ;\n  for (i=0; i<=string->len; i++)\n    {\n      string->data\u00ddi\u00a8 = *(strptr++) ;\n      if (*strptr=='\\0')\n        strptr = fillstr ;    /* start over on fill string */\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Delete a varying length string (free associated memory).          */\n/*-------------------------------------------------------------------*/\nvoid lstrdel(TLSTR *string)   /* string to delete */\n{\n  free((char *)string->data) ;\n  string->data = NULL ;\n  string->len = 0 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Create a varying length string with multiple copies of a string.  */\n/*-------------------------------------------------------------------*/\nvoid lstrrep(TLSTR *string,\n             char *repstr,\n             int copies)\n{\n  int repstrlen ;\n  char *strptr ;\n  int newlen ;\n  int i ;\n\n  /* The input string that replications are made from is assumed */\n  /* to have a length of one or longer.                          */\n\n  repstrlen = strlen(repstr) ;\n  if (repstrlen==0)  /* assume repitition of 0x00 */\n    repstrlen = 1 ;\n  newlen = repstrlen * copies ;\n  if (string->data==NULL)          /* alloc storage ? */\n    {\n      string->data = (char *)malloc(newlen) ;\n      if (!string->data) serror(21,\"Not enough memory\") ;\n    }\n  else if (string->len!=newlen)    /* alloc more/less storage ? */\n    {\n      free((char *)string->data) ;\n      string->data = (char *)malloc(newlen) ;\n      if (!string->data) serror(11,\"Not enough memory\") ;\n    }\n  string->len = newlen ;     /* alter string length */\n  strptr = repstr ;\n  for (i=0; i<newlen; i++)        /* replicate the repstr data */\n    {\n      string->data\u00ddi\u00a8 = *strptr++ ;\n      if (*strptr == '\\0')\n        strptr = repstr ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Concatenate two varying length strings together placing the       */\n/* in a varying length string.                                       */\n/*-------------------------------------------------------------------*/\nvoid lstrcat(TLSTR *result,   /* result of concatenation */\n             TLSTR *left,     /* left string to concatenate */\n             TLSTR *right)    /* right string to concatenate */\n{\n  char *rstr ;\n  int newlen ;\n\n  newlen = left->len + right->len ;    /* extend LSTR */\n  rstr = (char *)malloc(newlen) ;\n  if (!rstr) serror(12,\"Not enough memory\") ;\n\n  memcpy(rstr,left->data,left->len) ;   /* make new string */\n  memcpy(rstr+left->len,right->data,right->len) ;\n\n  free((char *)result->data) ;   /* assemble new LSTR */\n  result->data = rstr ;\n  result->len = newlen ;\n}\n\n\n/*********************************************************************/\n/* General sub routines.                                             */\n/*   fill(haystack,fillchar,number)                                  */\n/*   dumpchar(buffer,length)                                         */\n/*   overlay(buffer,bufferlen,overlay,overlaylen,overlaypos)         */\n/*********************************************************************/\n\n/*-------------------------------------------------------------------*/\n/* Fill a character string with a number of filler characters.       */\n/*-------------------------------------------------------------------*/\nvoid fill(char *haystack,   /* area to fill */\n          char filler,      /* fill characters */\n          int num)          /* number of repetitions */\n{\n  int i = 0 ;\n  for(i=0;i<=num;i++)\n    *haystack++ = filler ;\n  *haystack = '\\0' ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Dump the contents of a buffer, formatted in a way that makes a    */\n/* 3270 data stream easier to interpret.                             */\n/*-------------------------------------------------------------------*/\nvoid dumpchar(char *dat,    /* data to dump */\n              int len)      /* length to dump */\n{\n  char *cptr ;\n  char c ;\n  char cc\u00dd3\u00a8 ;\n  int i ;\n  int n, m ;\n\n  n = 0 ;\n  m = 0 ;\n  cptr = dat ;\n  do\n    {\n      printf(\"      %.8X \",dat) ;\n      for(i=1;i<=16;i++)\n        {                   /* 0 indicates all */\n          if (*dat=='\\0' && len==0)\n            break ;\n          if (n==len && len>0)\n            break ;\n          c = *dat++ ;\n          n++ ;\n          printf(\"%.2X\",c) ;\n          if ((i%4)==0)\n            printf(\" \") ;\n        }\n      printf(\"\\n               \") ;\n\n      for(i=1;i<=16;i++)\n        {\n          if (*cptr=='\\0' && len==0)\n            break ;\n          if (m==len && len>0)\n            break ;\n          c = *cptr++ ;\n          m++ ;\n          if (c <= 0x3f || c==0xff)\n            {\n              switch (c)\n                {\n                  case GE:   strcpy(cc,\"GE\") ;\n                    break ;\n                  case FF:   strcpy(cc,\"FF\") ;\n                    break ;\n                  case CRR:  strcpy(cc,\"CR\") ;\n                    break ;\n                  case SBA:  strcpy(cc,\"SB\") ;\n                    break ;\n                  case EUA:  strcpy(cc,\"EU\") ;\n                    break ;\n                  case ICUR: strcpy(cc,\"IC\") ;\n                    break ;\n                  case NL:   strcpy(cc,\"NL\") ;\n                    break ;\n                  case EM:   strcpy(cc,\"EM\") ;\n                    break ;\n                  case DUP:  strcpy(cc,\"DU\") ;\n                    break ;\n                  case SF:   strcpy(cc,\"SF\") ;\n                    break ;\n                  case FM:   strcpy(cc,\"FM\") ;\n                    break ;\n                  case SA:   strcpy(cc,\"SA\") ;\n                    break ;\n                  case SFE:  strcpy(cc,\"SX\") ;\n                    break ;\n                  case MF:   strcpy(cc,\"MF\") ;\n                    break ;\n                  case RA:   strcpy(cc,\"RA\") ;\n                    break ;\n                  case SUB:  strcpy(cc,\"SU\") ;\n                    break ;\n                  default:   strcpy(cc,\". \") ;\n                    break ;\n                }\n              printf(\"%s\",cc) ;\n            }\n          else\n            printf(\"%c \",c) ;\n          if ((i%4)==0)\n            printf(\" \") ;\n        }\n      printf(\"\\n\") ;\n    }\n  while( ((*dat!='\\0') && (len==0)) ||\n         ((m!=len) && (len>20))\n       ) ;\n  printf(\"\\n\") ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Overlay characterc in a buffer.                                   */\n/*-------------------------------------------------------------------*/\nvoid overlay(char *haystack,    /* area to overlay */\n             int haylen,        /* length to overlay */\n             char *needle,      /* overlay characters */\n             int len,           /* length of overlay */\n             int pos)           /* start postition of overlay */\n{\n  int hlen, nlen ;   /* length of haystack and needle */\n  int i = 0 ;        /* itterator */\n\n  if (haylen==0)\n    hlen = strlen(haystack) ;\n  else\n    hlen = haylen ;\n\n  if (len==0)\n    nlen = strlen(needle) ;\n  else\n    nlen = len ;\n\n  if (hlen>(nlen+pos))\n    {\n      haystack = haystack+pos ;    /* move to overlay pos */\n      for(i=0;i<nlen;i++)          /* copy the data */\n        *haystack++ = *needle++ ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* General error message routine.                                    */\n/*-------------------------------------------------------------------*/\nvoid serror(int errno,\n            char *msg)\n{\n  printf(\"Error: %d - %s\\n\",errno,msg) ;\n  abort() ;\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "FONT": {"ttr": 3843, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x95$?\\x00\\x95%\\x8f\\t\\x10\\x01J\\x00,\\x00\\x00\\xe2\\xc1\\xe2\\xc4\\xc4\\xc6@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1995-08-31T00:00:00", "modifydate": "1995-09-15T09:10:00", "lines": 330, "newlines": 44, "modlines": 0, "user": "SASDDF"}, "text": "#pragma eject\n#pragma title font.c - program to create a 3270 program symbol set\n\n/*+-----------------------------------------------------------------+\n  | Program:   font.c                                               |\n  | Language:  c                                                    |\n  | Support:   DAF                                                  |\n  | Purpose:   Convert a fontlayout file into a C language structure|\n  |            that is the bit image format for the type 1 3270     |\n  |            program symbol set.                                  |\n  | Files:     DDNAME=IN  Input font definition.                    |\n  |              Font layout file format:                           |\n  |                Column one is a record identifier where dot(.)   |\n  |                indicates a comment at plus(+) indicates the hex |\n  |                character code for the following bit map, and a  |\n  |                colon(:) indicates a character cell pattern.     |\n  |                Character cells are all 9 by 16, so 16 colon     |\n  |                lines are required for each character. The       |\n  |                format of colon and plus lines is fixed.         |\n  |                                                                 |\n  |                1. A comment line can only appear any where.     |\n  |                                                                 |\n  |                2. A plus line must be followed with 2           |\n  |                   characters that are the hex representation of |\n  |                   a character that the symbol defined after it  |\n  |                   wil use. The range allowed is 0x41 to 0xFE    |\n  |                   inclusive.                                    |\n  |                                                                 |\n  |                3. A colon line has the following format:        |\n  |                     : . . . . . . . . .                         |\n  |                   This indicates 9 pel positions accross the    |\n  |                   character, here all are turned off. An X is   |\n  |                   used to indicate that the pel is turned on.   |\n  |                   for example:                                  |\n  |                     : x x x x . . . . .                         |\n  |                                                                 |\n  |                   Here the first four pels atr turned on, and   |\n  |                   the last five are off. there must be one, and |\n  |                   only one blank character between each pel     |\n  |                   indicator, and also one blank following the   |\n  |                   colon.                                        |\n  |                                                                 |\n  |                4. Characters that are not specified             |\n  |                   are stored as if all pels were off.           |\n  |                                                                 |\n  |                The letter \"A\" would be sent to                  |\n  |                the PS device as a type 1 symbol                 |\n  |                with the bit string:                             |\n  |                  x'00000000102844828282fe82828282000000'        |\n  |                                                                 |\n  |                The following shows how the letter \"A\" would be  |\n  |                defined:                                         |\n  |                  +C1                                            |\n  |                  : . . . . . . . . .                            |\n  |                  : . . . . . . . . .                            |\n  |                  : . . . . X . . . .                            |\n  |                  : . . . X . X . . .                            |\n  |                  : . . X . . . X . .                            |\n  |                  : . X . . . . . X .                            |\n  |                  : . X . . . . . X .                            |\n  |                  : . X . . . . . X .                            |\n  |                  : . X X X X X X X .                            |\n  |                  : . X . . . . . X .                            |\n  |                  : . X . . . . . X .                            |\n  |                  : . X . . . . . X .                            |\n  |                  : . X . . . . . X .                            |\n  |                  : . . . . . . . . .                            |\n  |                  : . . . . . . . . .                            |\n  |                  : . . . . . . . . .                            |\n  |                                                                 |\n  |                                                                 |\n  |            DDNAME=OUT Output C language program symbol          |\n  |                   definition as a two dimensional character     |\n  |                   array.                                        |\n  | Notes:     None.                                                |\n  | End.                                                            |\n  +-----------------------------------------------------------------+*/\n\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n\nvoid main(int argc, char **argv, char **envp)\n  {\n    long s ;\n    int reclen = 82 ;       /* record length of input plus 2 */\n    int i, j ;              /* counters */\n    int exists ;            /* test flag for testing if char defined */\n    int cno = 0 ;           /* current character(symbol) number */\n    int row = 0 ;           /* current colon(:) row after plus(+) */\n    int rec = 0 ;           /* current record number being processed */\n    int error = 0 ;         /* error flag for colon record */\n    char *a ;               /* string pointer */\n    char aname\u00dd9\u00a8 ;         /* input file buffer */\n    char str\u00dd82\u00a8 ;          /* input file buffer */\n    char symset\u00dd256\u00a8\u00dd18\u00a8 ;  /* symbol set definition array */\n    char *stopchar ;        /* hex string to long stop character */\n    FILE *in, *out ;        /* files */\n\n    printf(\"Font to 3270 Program Symbol conversion program, Ver 2\\n\") ;\n\n    /* decode parameter = name of the output array */\n    if (argc!=2)\n      {\n        printf(\"Invalid number of parameters.\\n\") ;\n        exit(1) ;\n      }\n\n    i = strlen(argv\u00dd1\u00a8) ;\n    if ((i > 0) && (i <= 8))\n      {\n        strcpy(aname,argv\u00dd1\u00a8) ;\n        a = aname ;\n        while(*a)\n          {\n            *a = tolower(*a) ;\n            a++ ;\n          }\n      }\n    else\n      strcpy(aname,\"symset\") ;\n    printf(\"Output array name is: %s\\n\",aname) ;\n\n    /* process the input file into the symset array */\n    in = fopen(\"IN\",\"r\") ;\n    if (in)\n      {\n        fgets(str,reclen,in) ;\n        rec++ ;\n        while (!feof(in))\n          {\n            if (str\u00dd0\u00a8=='+' || str\u00dd0\u00a8==':')  /* valid + or : line */\n              {\n                if (str\u00dd0\u00a8=='+')    /* valid + line */\n                  {\n                    if (! ((row==16) || (row==0)))\n                      {\n                        printf(\"Error before line %d \\n\",rec) ;\n                        printf(\"Symbol 0x%.2X has invalid size.\\n\",\n                          cno);\n                      }\n                    s = strtol(str+1,&stopchar,16) ;\n                    if ((s>=65) && (s<=254))\n                      {\n                        cno = s ;\n                        exists = 0 ;\n                        for (i=0;i<18;i++)\n                          if (symset\u00ddcno\u00a8\u00ddi\u00a8 != 0x00) exists = 1 ;\n                        if (exists)\n                          {\n                            printf(\"Warning at line %d \\n\",rec) ;\n                            printf(\"Symbol 0x%.2X being re-defined.\\n\",\n                              cno);\n                          }\n                      }\n                    else cno = 0 ;\n                    row = 0 ;\n                  }\n                else if ((str\u00dd0\u00a8==':') && (cno!=0))  /* valid : line */\n                  {\n                    row++ ;\n                    if (row<=16)\n                      {\n                        error = 0 ;\n                        if (str\u00dd2\u00a8=='X')\n                          {\n                            if (row==1)\n                              symset\u00ddcno\u00a8\u00dd0\u00a8 = symset\u00ddcno\u00a8\u00dd0\u00a8 | 0x80 ;\n                            else if (row==2)\n                              symset\u00ddcno\u00a8\u00dd0\u00a8 = symset\u00ddcno\u00a8\u00dd0\u00a8 | 0x40 ;\n                            else if (row==3)\n                              symset\u00ddcno\u00a8\u00dd0\u00a8 = symset\u00ddcno\u00a8\u00dd0\u00a8 | 0x20 ;\n                            else if (row==4)\n                              symset\u00ddcno\u00a8\u00dd0\u00a8 = symset\u00ddcno\u00a8\u00dd0\u00a8 | 0x10 ;\n                            else if (row==5)\n                              symset\u00ddcno\u00a8\u00dd0\u00a8 = symset\u00ddcno\u00a8\u00dd0\u00a8 | 0x08 ;\n                            else if (row==6)\n                              symset\u00ddcno\u00a8\u00dd0\u00a8 = symset\u00ddcno\u00a8\u00dd0\u00a8 | 0x04 ;\n                            else if (row==7)\n                              symset\u00ddcno\u00a8\u00dd0\u00a8 = symset\u00ddcno\u00a8\u00dd0\u00a8 | 0x02 ;\n                            else if (row==8)\n                              symset\u00ddcno\u00a8\u00dd0\u00a8 = symset\u00ddcno\u00a8\u00dd0\u00a8 | 0x01 ;\n                            else if (row==9)\n                              symset\u00ddcno\u00a8\u00dd1\u00a8 = symset\u00ddcno\u00a8\u00dd1\u00a8 | 0x80 ;\n                            else if (row==10)\n                              symset\u00ddcno\u00a8\u00dd1\u00a8 = symset\u00ddcno\u00a8\u00dd1\u00a8 | 0x40 ;\n                            else if (row==11)\n                              symset\u00ddcno\u00a8\u00dd1\u00a8 = symset\u00ddcno\u00a8\u00dd1\u00a8 | 0x20 ;\n                            else if (row==12)\n                              symset\u00ddcno\u00a8\u00dd1\u00a8 = symset\u00ddcno\u00a8\u00dd1\u00a8 | 0x10 ;\n                            else if (row==13)\n                              symset\u00ddcno\u00a8\u00dd1\u00a8 = symset\u00ddcno\u00a8\u00dd1\u00a8 | 0x08 ;\n                            else if (row==14)\n                              symset\u00ddcno\u00a8\u00dd1\u00a8 = symset\u00ddcno\u00a8\u00dd1\u00a8 | 0x04 ;\n                            else if (row==15)\n                              symset\u00ddcno\u00a8\u00dd1\u00a8 = symset\u00ddcno\u00a8\u00dd1\u00a8 | 0x02 ;\n                            else if (row==16)\n                              symset\u00ddcno\u00a8\u00dd1\u00a8 = symset\u00ddcno\u00a8\u00dd1\u00a8 | 0x01 ;\n                          }\n                        else if (str\u00dd2\u00a8=='.') ;\n                        else error = 1 ;\n\n                        if (str\u00dd4\u00a8=='X')\n                          symset\u00ddcno\u00a8\u00ddrow+1\u00a8 = symset\u00ddcno\u00a8\u00ddrow+1\u00a8 |0x80;\n                        else if (str\u00dd4\u00a8=='.') ;\n                        else error = 1 ;\n\n                        if (str\u00dd6\u00a8=='X')\n                          symset\u00ddcno\u00a8\u00ddrow+1\u00a8 = symset\u00ddcno\u00a8\u00ddrow+1\u00a8 |0x40;\n                        else if (str\u00dd6\u00a8=='.') ;\n                        else error = 1 ;\n\n                        if (str\u00dd8\u00a8=='X')\n                          symset\u00ddcno\u00a8\u00ddrow+1\u00a8 = symset\u00ddcno\u00a8\u00ddrow+1\u00a8 |0x20;\n                        else if (str\u00dd8\u00a8=='.') ;\n                        else error = 1 ;\n\n                        if (str\u00dd10\u00a8=='X')\n                          symset\u00ddcno\u00a8\u00ddrow+1\u00a8 = symset\u00ddcno\u00a8\u00ddrow+1\u00a8 |0x10;\n                        else if (str\u00dd10\u00a8=='.') ;\n                        else error = 1 ;\n\n                        if (str\u00dd12\u00a8=='X')\n                          symset\u00ddcno\u00a8\u00ddrow+1\u00a8 = symset\u00ddcno\u00a8\u00ddrow+1\u00a8 |0x08;\n                        else if (str\u00dd12\u00a8=='.') ;\n                        else error = 1 ;\n\n                        if (str\u00dd14\u00a8=='X')\n                          symset\u00ddcno\u00a8\u00ddrow+1\u00a8 = symset\u00ddcno\u00a8\u00ddrow+1\u00a8 |0x04;\n                        else if (str\u00dd14\u00a8=='.') ;\n                        else error = 1 ;\n\n                        if (str\u00dd16\u00a8=='X')\n                          symset\u00ddcno\u00a8\u00ddrow+1\u00a8 = symset\u00ddcno\u00a8\u00ddrow+1\u00a8 |0x02;\n                        else if (str\u00dd16\u00a8=='.') ;\n                        else error = 1 ;\n\n                        if (str\u00dd18\u00a8=='X')\n                          symset\u00ddcno\u00a8\u00ddrow+1\u00a8 = symset\u00ddcno\u00a8\u00ddrow+1\u00a8 |0x01;\n                        else if (str\u00dd18\u00a8=='.') ;\n                        else error = 1 ;\n\n                        if (error)\n                          printf(\"Format error in line %d, %s\",rec,str);\n                     }\n                  }  /* of valid : line */\n                else\n                  printf(\"No valid char# for line %d, %s\",rec,str) ;\n              }  /* of valid + or : line */\n            fgets(str,reclen,in) ;\n            rec++ ;\n          }  /* of while */\n        fclose(in) ;\n\n        /* spit out the C language structure */\n        out = fopen(\"OUT\",\"w\") ;\n        if (out)\n          {\n            sprintf(str,\"#pragma eject \\n\") ;\n            fputs(str,out) ;\n            sprintf(str,\"/* 3270 Program Symbol Definition array */\\n\");\n            fputs(str,out) ;\n            sprintf(str,\"char %s\u00dd256\u00a8\u00dd18\u00a8 = { \\n\",aname) ;\n            fputs(str,out) ;\n            for (i=0;i<256;i++)\n              {\n                exists = 0 ;\n                for (j=0;j<18;j++)\n                  {\n                    if (symset\u00ddi\u00a8\u00ddj\u00a8 != 0x00)\n                      exists = 1 ;\n                  }\n                if ((i==64) ||\n                    ((i>=74) && (i<=80)) ||\n                    ((i>=90) && (i<=97)) ||\n                    ((i>=106) && (i<=111)) ||\n                    ((i>=122) && (i<=127)) ||\n                    ((i>=129) && (i<=137)) ||\n                    ((i>=145) && (i<=153)) ||\n                    ((i>=161) && (i<=169)) ||\n                    ((i>=193) && (i<=201)) ||\n                    ((i>=209) && (i<=217)) ||\n                    ((i>=226) && (i<=233)) ||\n                    ((i>=240) && (i<=249))\n                   )\n                  {\n                    if (exists)\n                      sprintf(str,\"  /* Symbol %c='%.2X'x defined */\",\n                        (char)i,(char)i) ;\n                    else\n                      sprintf(str,\"  /* No symbol '%.2X'x defined */\",\n                         (char)i) ;\n                  }\n                else\n                  {\n                    if (exists)\n                      sprintf(str,\"  /* Symbol '%.2X'x defined */\",\n                        (char)i) ;\n                    else\n                      sprintf(str,\"  /* No symbol '%.2X'x defined */\",\n                        (char)i) ;\n                  }\n                fputs(str,out) ;\n                for (j=0;j<18;j++)\n                  {\n                    if ((j%10) == 0)  /* insert new line after 10 */\n                      {\n                        sprintf(str,\"\\n    \") ;\n                        fputs(str,out) ;\n                      }\n                    if ((i==255) && (j==17))  /* last one - no comma */\n                      sprintf(str,\"0x%.2x\",symset\u00ddi\u00a8\u00ddj\u00a8) ;\n                    else\n                      sprintf(str,\"0x%.2x,\",symset\u00ddi\u00a8\u00ddj\u00a8) ;\n                    fputs(str,out) ;\n                  }\n                sprintf(str,\"\\n\") ;\n                fputs(str,out) ;\n              }\n            sprintf(str,\"  } ; \\n\") ;\n            fputs(str,out) ;\n            fclose(out) ;\n          }\n        else\n          printf(\"Error: Failed to open output file.\\n\") ;\n      }\n    else\n      printf(\"Error: Failed to open input file.\\n\") ;\n    printf(\"Font program ended.\\n\") ;\n  }\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "INFO3270": {"ttr": 3849, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x00\\x00\\x95\"\\x0f\\x00\\x95%o\\tB\\x06\\xc2\\x00E\\x00\\x00\\xe2\\xc1\\xe2\\xc4\\xc4\\xc6@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1995-08-08T00:00:00", "modifydate": "1995-09-13T09:42:00", "lines": 1730, "newlines": 69, "modlines": 0, "user": "SASDDF"}, "text": "#pragma eject\n#pragma title INFO3270.C - Program lists info. for this device\n\n/*+-----------------------------------------------------------------+\n  | Program:   info3270.c                                           |\n  | Language:  c                                                    |\n  | Support:   DAF                                                  |\n  | Purpose:   This program queries the device that is being used   |\n  |            for the active TSO session and displays as much      |\n  |            information as it can about the device being used.   |\n  | Method:    The GTTERM macro gets information from TSO/VTAM,     |\n  |            and TPG is used to send a Read partition, Query      |\n  |            operations, query, to get information from the       |\n  |            3270 device.                                         |\n  +-----------------------------------------------------------------+*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <dynam.h>\n#include <tput.h>\n\n#define _AMODE31\n/* --------------------- 3270 commands ----------------------------- */\n#define ESC    0x27\n#define EW     0xf5\n#define EWA    0x7e\n#define WRT    0xf1\n#define WSF    0xf3\n#define RB     0xf2\n\n/* ------ write control characters, or'd together as required ------ */\n#define WCCMDT 0x01\n#define WCCKBD 0x02\n#define WCCRES 0xc0\n\n/* ------------- 3270 data stream orders --------------------------- */\n#define GE     0x08\n#define FF     0x0c\n#define CRR    0x0d\n#define SBA    0x11\n#define EUA    0x12\n#define ICUR   0x13\n#define NL     0x15\n#define EM     0x19\n#define DUP    0x1c\n#define SF     0x1d\n#define FM     0x1e\n#define SA     0x28\n#define SFE    0x29\n#define MF     0x2c\n#define RA     0x3c\n#define SUB    0x3f\n\n#define PROT   0x20\n#define NUM    0x10\n\n/* ------ these are the sub commands of the set attribute SA ------- */\n#define ALL    0x00\n#define DFLT   0x00\n#define OUTLIN 0xc2\n#define HILITE 0x41\n#define COLOR  0x42\n#define SYMSET 0x43\n#define BCOLOR 0x45\n#define TRANSP 0x46\n\n#define APL    0xf1\n\n/* these are the hilites for the second byte of the set attribute SA */\n#define NONE   0x00\n#define BLINK  0xf1\n#define RVIDEO 0xf2\n#define USCORE 0xf4\n\n/* these are the colors for the second byte of the set attribute SA  */\n#define BLUE   0xf1\n#define RED    0xf2\n#define PINK   0xf3\n#define GREEN  0xf4\n#define TURQ   0xf5\n#define YELLOW 0xf6\n#define WHITE  0xf7\n\n/* --------- the attribute byte for the SF command ----------------- */\n#define UNPRT  0x40\n#define UNPRTH 0xc8\n#define PRT    0x60\n#define PRTH   0xe8\n\n#define ADDR1(row,col)  ((((row-1)*80)+(col-1) & 0xff00) >> 8)\n#define ADDR2(row,col)  (((row-1)*80)+(col-1) & 0x00ff)\n\n\n/* ------------------------- Prototypes ---------------------------- */\nint getterm(int *, int *, int *, int *, int *) ;\nint tputn(char *buf, int buflen) ;\nint tpgn(char *buf, int buflen) ;\nvoid rc2sba(int, int, char *) ;\nvoid fill(char *, char, int) ;\nvoid dumpchar(char *, int) ;\nvoid querydev() ;\nvoid help() ;\n\nint dsummary(char *buf, short buflen) ;\nint darea(char *buf, short buflen) ;\nint dimage(char *buf, short buflen) ;\nint dtextp(char *buf, short buflen) ;\nint dalphap(char *buf, short buflen) ;\nint dcharset(char *buf, short buflen) ;\nint dcolor(char *buf, short buflen) ;\nint dhilite(char *buf, short buflen) ;\nint dmodes(char *buf, short buflen) ;\nint dfieldv(char *buf, short buflen) ;\nint dmsrcntl(char *buf, short buflen) ;\nint dfieldol(char *buf, short buflen) ;\nint dpartchr(char *buf, short buflen) ;\nint doemaux(char *buf, short buflen) ;\nint dformat(char *buf, short buflen) ;\nint ddbcs(char *buf, short buflen) ;\nint dsave(char *buf, short buflen) ;\nint dfmtaux(char *buf, short buflen) ;\nint ddist(char *buf, short buflen) ;\nint dstrpool(char *buf, short buflen) ;\nint ddocint(char *buf, short buflen) ;\nint datchain(char *buf, short buflen) ;\nint dauxdev(char *buf, short buflen) ;\nint d3270ip(char *buf, short buflen) ;\nint dpdds(char *buf, short buflen) ;\nint danom(char *buf, short buflen) ;\nint dibmaux(char *buf, short buflen) ;\nint dbeof(char *buf, short buflen) ;\nint ddevchar(char *buf, short buflen) ;\nint drpqname(char *buf, short buflen) ;\nint ddatastr(char *buf, short buflen) ;\nint dimpart(char *buf, short buflen) ;\nint dpaperf(char *buf, short buflen) ;\nint dtrans(char *buf, short buflen) ;\nint dsprnch(char *buf, short buflen) ;\nint diocaaux(char *buf, short buflen) ;\nint dcooproc(char *buf, short buflen) ;\nint dsegment(char *buf, short buflen) ;\nint dproc(char *buf, short buflen) ;\nint dlinetyp(char *buf, short buflen) ;\nint dport(char *buf, short buflen) ;\nint dgrapcol(char *buf, short buflen) ;\nint dextdraw(char *buf, short buflen) ;\nint dgrapsym(char *buf, short buflen) ;\n\n/* --------------------- Global Variables -------------------------- */\nchar force = 0 ;   /* -F Flag, if 1: force a query of the device */\nchar terse = 0 ;   /* -T Flag, if 1: do not do dump of buffers */\nchar dump  = 0 ;   /* -D Flag, if 1: only dump buffer contents */\nint rows = 0 ;     /* Number of rows on the device */\nint cols = 0 ;     /* Number of columns on the device */\nint adrmode = 12 ; /* Device addressing mode 12 or 14 or 16 bit */\n\n/* ------------------------- Main program -------------------------- */\nvoid main(int argc, char **argv, char **envp)\n  /*\n     This program firstly extracts the screen size and some\n     attributes from TSO/VTAM using the GTTERM macro, then\n     uses the TPUT, TPG and TGET macro instructions to send\n     a query operations to the device and read the response\n     from the device. The response is decoded acording to the\n     specifications in the IBM book 'Data Stream Programmers Ref'\n     # GA23-0059. The decoded output is written to the STDOUT\n     file.\n  */\n  {\n    int rc, pr = 0, pc = 0, ar = 0, ac = 0, att = 0 ;\n    int i ;               /* counter */\n    char name\u00dd20\u00a8 ;       /* documentory device name */\n\n    printf(\"\\nINFO3270  - 3270 Information Query Program.\\n\") ;\n\n    /* extract program parameters */\n    if (argc>0)\n      {\n        i = 1 ;           /* skip first arg(0)=(pgm name) */\n        while(i<argc)\n          {\n            if (strcmp(argv\u00ddi\u00a8,\"-F\")==0)\n              force = 1 ;     /* always query the device */\n            else if (strcmp(argv\u00ddi\u00a8,\"-T\")==0)\n              terse = 1 ;     /* dont print dump of buffer */\n            else if (strcmp(argv\u00ddi\u00a8,\"-D\")==0)\n              dump = 1 ;      /* only print dump of buffer */\n            else if (strcmp(argv\u00ddi\u00a8,\"-H\")==0)\n              help() ;        /* print some help info and end */\n            else if (strcmp(argv\u00ddi\u00a8,\"-N\")==0)\n              {               /* documentory name */\n                i++ ;\n                if (i<argc)\n                  strcpy(name,argv\u00ddi\u00a8) ;\n              }\n            else\n              {\n                printf(\"Ingoring invalid parameter: %s \\n\",argv\u00ddi\u00a8) ;\n                printf(\"Use -H parm. for more info.\\n\") ;\n              }\n            i++ ;\n          }  /* of while more args */\n        if (dump)\n          terse = 0 ;\n      }  /* of if args */\n    printf(\"Options: Terse=%d Dump=%d Force=%d Name=%s\\n\",\n      terse,dump,force,name) ;\n\n    /* gripe about invalid environment options */\n    i = 0 ;\n    while (*envp)\n      printf(\"Environment option %s ignored.\\n\",i++,*envp++) ;\n\n    /* get info from TSO about this device */\n    rc = getterm(&pr,&pc,&ar,&ac,&att) ;\n    if (rc==0)                 /* get terminal info worked ? */\n      {\n        /* set row and col may used later by query dev */\n        if ((ar>0) && (ar!=pr) &&\n            (ac>0) && (ac!=pc))\n          {\n            rows = ar ;     /* use alternate rows */\n            cols = ac ;     /* use alternate cols */\n          }\n        else\n          {\n            rows = pr ;     /* use primary rows */\n            cols = pc ;     /* use primary cols */\n          }\n\n        printf(\"Getterm device info.: %s \\n\",name) ;\n        printf(\"  Primary partition sereen size:\\n\") ;\n        printf(\"    Rows...: %d \\n\",pr) ;\n        printf(\"    Columns: %d \\n\",pc) ;\n        printf(\"  Alternate partition screen size:\\n\") ;\n        printf(\"    Rows...: %d \\n\",ar) ;\n        printf(\"    Columns: %d \\n\",ac) ;\n        printf(\"  Gtterm attributes '%.8X'x \\n\",att) ;\n        if (att==0x00000001)     /* query structured fields */\n          {\n            printf(\"  Device supports query structured fields.\\n\") ;\n            querydev() ;\n          }\n        else\n          {\n            printf(\"  Structured field query not supported.\\n\");\n            if (force)\n              {\n                printf(\"  Warning: Query structured field forced.\\n\");\n                querydev() ;\n              }\n          }\n      }\n    else\n      printf(\"Error: GETTERM macro RC=%d \\n\",rc) ;\n    printf(\"INFO3270 ended.\\n\") ;\n  }\n\n\n/* ------------------------- Sub routines -------------------------- */\n\nvoid help()\n  /*\n     This routine displays a small amount of help\n  */\n  {\n     printf(\"Parameters are:\\n\") ;\n     printf(\"  -N name .. Supply a documentory name to display.\\n\") ;\n     printf(\"  -F .. Force a query of the device.\\n\") ;\n     printf(\"  -T .. Do not dump buffer contents.\\n\") ;\n     printf(\"  -D .. Only dump buffer contents.\\n\") ;\n     printf(\"  -H .. This help.\\n\") ;\n  }\n\nint getterm(int *primrow, int *primcol,\n             int *altrow, int *altcol,\n             int *attrs)\n  /*\n     This routine loads an assebbler module below the 16 MB line\n     that issues the GTTERM macro instruction to obtain the\n     dimensions of the screen and also some bit fields that\n     tell if the device can be queried. The module copies the\n     results from storage below the line to this routines\n     automatic storage.\n     Upon completion the module is unloaded.\n  */\n  {\n    struct {\n      union {\n        short sh ;\n        char c\u00dd2\u00a8 ;\n      } prim ;\n      union {\n        short sh ;\n        char c\u00dd2\u00a8 ;\n      } alt ;\n      int attr ;\n    } pm ;\n    int rc = 0 ;\n    int (*tgt327d)(void *) ;\n\n    loadm(\"TGT327D\",&tgt327d) ;   /* load ASM routine below 16M */\n    rc = (*tgt327d)(&pm) ;        /* execute GTTERM macro */\n    if (rc==0)      /* data returned OK ? */\n      {             /* yes - convert single byte numbers to int */\n        *primrow = pm.prim.c\u00dd0\u00a8 ;\n        *primcol = pm.prim.c\u00dd1\u00a8 ;\n        *altrow = pm.alt.c\u00dd0\u00a8 ;\n        *altcol = pm.alt.c\u00dd1\u00a8 ;\n        *attrs = pm.attr ;\n      }\n    unloadm(tgt327d) ;            /* unload ASM routine */\n    return rc ;                   /* return code from GTTERM */\n  }\n\nvoid rc2sba(int row,\n            int col,\n            char *sba)\n/*\n   Convert row/column to 3270 12/16 bit buffer address.\n*/\n{\n  int offset, byte1, byte2 ;\n\n  offset = ((row-1)*cols)+(col-1) ;\n  if (adrmode == 12)  /* addressing mode = 12 */\n    {\n      byte1 = offset >> 6 ;           /* extract high order bits */\n      byte1 = byte1 | 0x000000c0 ;    /* turn on 12 bit ind */\n\n      byte2 = offset & 0x0000003f ;   /* extract low order 6 bits */\n      byte2 = byte2 | 0x000000c0 ;    /* turn on 12 bit ind */\n\n      sba\u00dd0\u00a8 = *((char *)&byte1+3) ;  /* assemble 2 byte sba */\n      sba\u00dd1\u00a8 = *((char *)&byte2+3) ;\n    }\n  else /* adrmode = 16 or 14 */\n    {\n      byte1 = offset >> 8 ;           /* extract high order byte */\n      byte2 = offset & 0x00ff ;       /* extract low order byte */\n      sba\u00dd0\u00a8 = *((char *)&byte1+3) ;  /* assemble 2 byte sba */\n      sba\u00dd1\u00a8 = *((char *)&byte2+3) ;\n    }\n}\n\nvoid querydev()\n  /*\n     Select the entire screen buffer using SBA based on the\n     scrsize returned from GTTERM and EW/EWA to select the\n     primary or alternate buffer.\n     Then assemble a structured field query, and send it to the\n     device using TPG which will cause the device to imediately\n     send back the response without any user intervention.\n     Then decode the read partition, query operations, query and\n     print the results to STDOUT.\n  */\n  {\n    short sflen ;    /* structured field length */\n    char  sfid ;     /* structured field ID */\n    char  qcode ;    /* query reply - query code */\n    char input\u00dd256\u00a8 ;/* query buffer */\n    char *ibuf ;     /* current query buffer pointer */\n    int rc ;         /* return code */\n    char sba\u00dd2\u00a8 ;    /* buffer address of max row/col */\n\n    char out1\u00dd\u00a8 = {      /* set up for erase */\n      WRT, 0x40,\n      SBA, 0x5d, 0x7f,   /* end addr - row=24 col=80 */\n      SBA, 0x40, 0x40,   /* start addr row=1 col=1 */\n      SBA, 0xe7, 0x7f,   /* insert cursor location - row=max col=max */\n      ICUR               /* insert cursor */\n      } ;\n\n    char out2\u00dd\u00a8 = {      /* erase write alternate */\n      EWA, 0xc2\n      } ;\n\n    char out3\u00dd\u00a8 = {      /* erase primary */\n      WRT, 0xc2\n      } ;\n\n    char out4\u00dd\u00a8 = {\n      WSF,               /* write structured field */\n      0x00, 0x05,        /* structured field length */\n      0x01,              /* read partition */\n      0xFF,              /* query operations */\n      0x02               /* query */\n      } ;\n\n    /* set max screen size known so far sba */\n    rc2sba(rows,cols,sba) ;\n    out1\u00dd9\u00a8 = sba\u00dd0\u00a8 ;\n    out1\u00dd10\u00a8 = sba\u00dd1\u00a8 ;\n\n    fill(input,0x00,sizeof(input)) ;   /* zero input buffer */\n\n    rc = tputn(out1,sizeof(out1) ) ;   /* define the buffer */\n    rc = tputn(out2,sizeof(out2) ) ;   /* erase write alternate */\n    rc = tputn(out3,sizeof(out3) ) ;   /* erase write primary */\n    rc = tpgn(out4,sizeof(out4) ) ;    /* query the device */\n    rc = TGET(input,sizeof(input),_FULLSCR) ; /* receive device resp.*/\n\n    ibuf = input ;       /* point at input */\n\n    if (*input==0x88)    /* check for 88 AID byte */\n      {\n        printf(\"\\nRead device, Query operations info.: \\n\") ;\n        ibuf = ibuf+1 ;         /* advance to 1st structured field */\n        sfid = *(ibuf+2) ;      /* sfid should be 0x81 */\n\n        while (sfid==0x81)  /* while structured fields remain */\n          {\n            sflen = *((short *)ibuf) ;  /* get structured field len */\n            if (sflen==0)           /* bad error - should not happen */\n              {\n                printf(\"Error: Structured field length zero at %p\\n\",\n                  ibuf) ;\n                dumpchar(input,sizeof(input)) ;\n                break ;\n              }\n            qcode = *(ibuf+3) ;     /* get query code */\n            switch (qcode)\n              {\n                case 0x80:           /* Qcode summary */\n                  rc = dsummary(ibuf,sflen) ;\n                  break ;\n                case 0x81:           /* Usable area */\n                  rc = darea(ibuf,sflen) ;\n                  break ;\n                case 0x82:           /* Image */\n                  rc = dimage(ibuf,sflen) ;\n                  break ;\n                case 0x83:           /* Text partitions */\n                  rc = dtextp(ibuf,sflen) ;\n                  break ;\n                case 0x84:           /* Alphanumeric partitions */\n                  rc = dalphap(ibuf,sflen) ;\n                  break ;\n                case 0x85:           /* Character sets */\n                  rc = dcharset(ibuf,sflen) ;\n                  break ;\n                case 0x86:           /* Color */\n                  rc = dcolor(ibuf,sflen) ;\n                  break ;\n                case 0x87:           /* Highlighting */\n                  rc = dhilite(ibuf,sflen) ;\n                  break ;\n                case 0x88:           /* Modes */\n                  rc = dmodes(ibuf,sflen) ;\n                  break ;\n                case 0x8a:           /* Field validation */\n                  rc = dfieldv(ibuf,sflen) ;\n                  break ;\n                case 0x8b:           /* MSR Control */\n                  rc = dmsrcntl(ibuf,sflen) ;\n                  break ;\n                case 0x8c:           /* Field Outlining */\n                  rc = dfieldol(ibuf,sflen) ;\n                  break ;\n                case 0x8e:           /* Partition Characteristics */\n                  rc = dpartchr(ibuf,sflen) ;\n                  break ;\n                case 0x8f:           /* OEM Auxillary Device */\n                  rc = doemaux(ibuf,sflen) ;\n                  break ;\n                case 0x90:           /* Format presentation */\n                  rc = dformat(ibuf,sflen) ;\n                  break ;\n                case 0x91:           /* DBCS - Asia */\n                  rc = ddbcs(ibuf,sflen) ;\n                  break ;\n                case 0x92:           /* Save restore format */\n                  rc = dsave(ibuf,sflen) ;\n                  break ;\n                case 0x94:           /* Format auxillary storage devic*/\n                  rc = dfmtaux(ibuf,sflen) ;\n                  break ;\n                case 0x95:           /* Distributed data management */\n                  rc = ddist(ibuf,sflen) ;\n                  break ;\n                case 0x96:           /* Storage pools */\n                  rc = dstrpool(ibuf,sflen) ;\n                  break ;\n                case 0x97:           /* Document interchange arch. */\n                  rc = ddocint(ibuf,sflen) ;\n                  break ;\n                case 0x98:           /* Data chaining */\n                  rc = datchain(ibuf,sflen) ;\n                  break ;\n                case 0x99:           /* Auxilliary device */\n                  rc = dauxdev(ibuf,sflen) ;\n                  break ;\n                case 0x9a:           /* 3270 IPDS */\n                  rc = d3270ip(ibuf,sflen) ;\n                  break ;\n                case 0x9c:           /* Product defined data stream */\n                  rc = dpdds(ibuf,sflen) ;\n                  break ;\n                case 0x9d:           /* Anomaly implementation */\n                  rc = danom(ibuf,sflen) ;\n                  break ;\n                case 0x9e:           /* IBM auxilliary device */\n                  rc = dibmaux(ibuf,sflen) ;\n                  break ;\n                case 0x9f:           /* Begin / end of file */\n                  rc = dbeof(ibuf,sflen) ;\n                  break ;\n                case 0xa0:           /* Device characteristics */\n                  rc = ddevchar(ibuf,sflen) ;\n                  break ;\n                case 0xa1:           /* RPQ names */\n                  rc = drpqname(ibuf,sflen) ;\n                  break ;\n                case 0xa2:           /* Data streams */\n                  rc = ddatastr(ibuf,sflen) ;\n                  break ;\n                case 0xa6:           /* Implicit partition */\n                  rc = dimpart(ibuf,sflen) ;\n                  break ;\n                case 0xa7:           /* Paper feed techniques */\n                  rc = dpaperf(ibuf,sflen) ;\n                  break ;\n                case 0xa8:           /* Transparency */\n                  rc = dtrans(ibuf,sflen) ;\n                  break ;\n                case 0xa9:           /* Settable printer chars. */\n                  rc = dsprnch(ibuf,sflen) ;\n                  break ;\n                case 0xaa:           /* IOCA Auxillary Device */\n                  rc = diocaaux(ibuf,sflen) ;\n                  break ;\n                case 0xab:           /* Cooperative proc requestor */\n                  rc = dcooproc(ibuf,sflen) ;\n                  break ;\n                case 0xb0:           /* Segment */\n                  rc = dsegment(ibuf,sflen) ;\n                  break ;\n                case 0xb1:           /* Procedure */\n                  rc = dproc(ibuf,sflen) ;\n                  break ;\n                case 0xb2:           /* Line type */\n                  rc = dlinetyp(ibuf,sflen) ;\n                  break ;\n                case 0xb3:           /* Port */\n                  rc = dport(ibuf,sflen) ;\n                  break ;\n                case 0xb4:           /* Graphic color */\n                  rc = dgrapcol(ibuf,sflen) ;\n                  break ;\n                case 0xb5:           /* Extended drawing routine */\n                  rc = dextdraw(ibuf,sflen) ;\n                  break ;\n                case 0xb6:           /* Graphic symbol sets */\n                  rc = dgrapsym(ibuf,sflen) ;\n                  break ;\n                default:\n                  printf(\"Error: Invalid q-code at %p in buffer:\\n\",\n                    ibuf+3) ;\n                  dumpchar(input,sizeof(input)) ;\n                  printf(\"INFO3270 ending early due to errors.\\n\") ;\n                  abort() ;\n              }  /* of switch */\n            ibuf = ibuf+sflen ; /* advance to next structured field */\n            sfid = *(ibuf+2) ;  /* sfid should be 0x81 - else stop */\n\n          } /* of while sfid=81 */\n\n      } /* of AID=88 */\n  }\n\nint dsummary(char *buf, short buflen)\n  /*\n    0x80: Qcode summary\n  */\n  {\n     int i ;\n     char qcode ;\n\n     printf(\"  Q-code summary:\\n\") ;\n     printf(\"    Following Q-codes supported:\\n\") ;\n     for (i=4;i<buflen;i++)\n       {\n          printf(\"      \") ;\n          qcode = *(buf+i) ;     /* get query code */\n          switch (qcode)\n            {\n              case 0x80:\n                printf(\"(%.2X) Qcode summary.\\n\",qcode) ;\n                break ;\n              case 0x81:\n                printf(\"(%.2X) Usable area.\\n\",qcode) ;\n                break ;\n              case 0x82:\n                printf(\"(%.2X) Image.\\n\",qcode) ;\n                break ;\n              case 0x83:\n                printf(\"(%.2X) Text partitions.\\n\",qcode) ;\n                break ;\n              case 0x84:\n                printf(\"(%.2X) Alphanumeric partitions.\\n\",qcode) ;\n                break ;\n              case 0x85:\n                printf(\"(%.2X) Character sets.\\n\",qcode) ;\n                break ;\n              case 0x86:\n                printf(\"(%.2X) Color.\\n\",qcode) ;\n                break ;\n              case 0x87:\n                printf(\"(%.2X) Highlighting.\\n\",qcode) ;\n                break ;\n              case 0x88:\n                printf(\"(%.2X) Modes.\\n\",qcode) ;\n                break ;\n              case 0x8a:\n                printf(\"(%.2X) Field validation.\\n\",qcode) ;\n                break ;\n              case 0x8b:\n                printf(\"(%.2X) MSR Control.\\n\",qcode) ;\n                break ;\n              case 0x8c:\n                printf(\"(%.2X) Field Outlining.\\n\",qcode) ;\n                break ;\n              case 0x8e:\n                printf(\"(%.2X) Partition Characteristics.\\n\",qcode) ;\n                break ;\n              case 0x8f:\n                printf(\"(%.2X) OEM Auxillary Device.\\n\",qcode) ;\n                break ;\n              case 0x90:\n                printf(\"(%.2X) Format presentation.\\n\",qcode) ;\n                break ;\n              case 0x91:\n                printf(\"(%.2X) DBCS - Asia.\\n\",qcode) ;\n                break ;\n              case 0x92:\n                printf(\"(%.2X) Save restore format.\\n\",qcode) ;\n                break ;\n              case 0x94:\n                printf(\"(%.2X) Format auxillary storage device.\\n\",\n                  qcode) ;\n                break ;\n              case 0x95:\n                printf(\"(%.2X) Distributed data management.\\n\",qcode) ;\n                break ;\n              case 0x96:\n                printf(\"(%.2X) Storage pools.\\n\",qcode) ;\n                break ;\n              case 0x97:\n                printf(\"(%.2X) Document interchange arch..\\n\",qcode) ;\n                break ;\n              case 0x98:\n                printf(\"(%.2X) Data chaining.\\n\",qcode) ;\n                break ;\n              case 0x99:\n                printf(\"(%.2X) Auxilliary device.\\n\",qcode) ;\n                break ;\n              case 0x9a:\n                printf(\"(%.2X) 3270 IPDS.\\n\",qcode) ;\n                break ;\n              case 0x9c:\n                printf(\"(%.2X) Product defined data stream.\\n\",qcode) ;\n                break ;\n              case 0x9d:\n                printf(\"(%.2X) Anomaly implementation.\\n\",qcode) ;\n                break ;\n              case 0x9e:\n                printf(\"(%.2X) IBM auxilliary device.\\n\",qcode) ;\n                break ;\n              case 0x9f:\n                printf(\"(%.2X) Begin / end of file.\\n\",qcode) ;\n                break ;\n              case 0xa0:\n                printf(\"(%.2X) Device characteristics.\\n\",qcode) ;\n                break ;\n              case 0xa1:\n                printf(\"(%.2X) RPQ names.\\n\",qcode) ;\n                break ;\n              case 0xa2:\n                printf(\"(%.2X) Data streams.\\n\",qcode) ;\n                break ;\n              case 0xa6:\n                printf(\"(%.2X) Implicit partition.\\n\",qcode) ;\n                break ;\n              case 0xa7:\n                printf(\"(%.2X) Paper feed techniques.\\n\",qcode) ;\n                break ;\n              case 0xa8:\n                printf(\"(%.2X) Transparency.\\n\",qcode) ;\n                break ;\n              case 0xa9:\n                printf(\"(%.2X) Settable printer chars..\\n\",qcode) ;\n                break ;\n              case 0xaa:\n                printf(\"(%.2X) IOCA Auxillary Device.\\n\",qcode) ;\n                break ;\n              case 0xab:\n                printf(\"(%.2X) Cooperative proc requestor.\\n\",qcode) ;\n                break ;\n              case 0xb0:\n                printf(\"(%.2X) Segment.\\n\",qcode) ;\n                break ;\n              case 0xb1:\n                printf(\"(%.2X) Procedure.\\n\",qcode) ;\n                break ;\n              case 0xb2:\n                printf(\"(%.2X) Line type.\\n\",qcode) ;\n                break ;\n              case 0xb3:\n                printf(\"(%.2X) Port.\\n\",qcode) ;\n                break ;\n              case 0xb4:\n                printf(\"(%.2X) Graphic color.\\n\",qcode) ;\n                break ;\n              case 0xb5:\n                printf(\"(%.2X) Extended drawing routine.\\n\",qcode) ;\n                break ;\n              case 0xb6:\n                printf(\"(%.2X) Graphic symbol sets.\\n\",qcode) ;\n                break ;\n              default:\n                printf(\"Warning: Q-code %.2X unknown.\\n\",qcode) ;\n                break ;\n            }  /* of switch qcode */\n       }  /* of for i=4 */\n\n     printf(\"\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint darea(char *buf, short buflen)\n  /*\n    0x81: Usable area\n  */\n  {\n     char celunits\u00dd6\u00a8 ;   /* screen size unit PEL or CELL */\n     char units\u00dd3\u00a8 ;      /* pel spacing inits IN or MM */\n     short w, h ;         /* screen size w=width h=height */\n     char aw, ah ;        /* units per cell aw=width ah=height */\n     float xr, xrd, yr, yrd ;  /* pel spacing ratio */\n     char vcpflg = 0 ;    /* VCP - variable cell size per partition */\n     float fw, fh ;       /* ratio - pels per unit */\n\n     printf(\"  Usable area:\\n\") ;\n     if (*(buf+4) & 0x10)\n       printf(\"    Device is hardcopy.\\n\") ;\n     else\n       printf(\"    Device is interactive.\\n\") ;\n\n     if ((*(buf+4) & 0x0f)==0x0f)\n       printf(\"    Addressing unmapped.\\n\") ;\n     else if ((*(buf+4) & 0x03)==0x03)\n       printf(\"    12/14/16 bit addressing allowed.\\n\") ;\n     else if ((*(buf+4) & 0x01)==0x01)\n       printf(\"    12/14 bit addressing allowed.\\n\") ;\n\n     if (*(buf+5) & 0x80)\n       {\n         printf(\"    Variable cells supported.\\n\") ;\n         vcpflg = 1 ;\n       }\n     else\n       printf(\"    Variable cells not supported.\\n\") ;\n\n     if (*(buf+5) & 0x40)\n       printf(\"    Non-matrix character.\\n\") ;\n     else\n       printf(\"    Matrix character.\\n\") ;\n\n     w = *((short *)(buf+6)) ;   /* width of usable area */\n     h = *((short *)(buf+8)) ;   /* height of usable area */\n\n     if (*(buf+10) == 0x01)    /* pels/in or pels/mm */\n       strcpy(units,\"mm\") ;\n     else\n       strcpy(units,\"in\") ;\n\n     xr = *((short *)(buf+11)) ;    /* x dim pel ratio numerator */\n     xrd = *((short *)(buf+13)) ;   /* x dim pel ratio denominator */\n     yr = *((short *)(buf+15)) ;    /* y dim pel ratio numerator */\n     yrd = *((short *)(buf+17)) ;   /* y dim pel ratio denominator */\n\n     fw = (float)(xr) / (float)(xrd) ; /* horiz. ratio pels per unit */\n     fh = (float)(yr) / (float)(yrd) ; /* vert. ratio pels per unit */\n     printf(\"    Horizontal pels per %s is: %f \\n\",units,fw) ;\n     printf(\"    Vertical pels per %s is: %f \\n\",units,fh) ;\n\n     aw = *(buf+19) ;    /* number of X units in default cell */\n     ah = *(buf+20) ;    /* number of Y units in default cell */\n     printf(\"    Character cell size is: %d by %d pels.\\n\",aw,ah) ;\n\n     if (*(buf+5) & 0x20)       /* byte 5 bit 3 on unit=pels */\n       strcpy(celunits,\"pels\") ;\n     else                       /* other wise unit=cells */\n       strcpy(celunits,\"cells\") ;\n\n     printf(\"    Screen width is: %d %s.\\n\",w,celunits) ;\n     printf(\"    Screen height is: %d %s.\\n\",h,celunits) ;\n\n     printf(\"\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint dimage(char *buf, short buflen)\n  /*\n    0x82: Image\n  */\n  {\n     printf(\"  Image:\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\n\nint dtextp(char *buf, short buflen)\n  /*\n    0x83: Text partitions\n  */\n  {\n     printf(\"  Text partitions:\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint dalphap(char *buf, short buflen)\n  /*\n    0x84: Alphanumeric partitions\n  */\n  {\n     short m ;        /* total available partition storage */\n\n     printf(\"  Alphanumeric partitions:\\n\") ;\n\n     m = *((short *)(buf+5)) ;\n     printf(\"    Total partition storage: %d \\n\",m) ;\n\n     if (*(buf+7) & 0x80)\n       printf(\"    Vertical scrolling supported.\\n\") ;\n     else\n       printf(\"    Vertical scrolling not supported.\\n\") ;\n\n     if (*(buf+7) & 0x40)\n       printf(\"    Horizontal scrolling supported.\\n\") ;\n     else\n       printf(\"    Horizontal scrolling not supported.\\n\") ;\n\n     if (*(buf+7) & 0x10)\n       printf(\"    All ports addressability supported.\\n\") ;\n     else\n       printf(\"    All ports addressability not supported.\\n\") ;\n\n     if (*(buf+7) & 0x08)\n       printf(\"    Partition protection supported.\\n\") ;\n     else\n       printf(\"    Partition protection not supported.\\n\") ;\n\n     if (*(buf+7) & 0x04)\n       printf(\"    Presentation space local copy supported.\\n\") ;\n     else\n       printf(\"    Presentation space local copy not supported.\\n\") ;\n\n     if (*(buf+7) & 0x02)\n       printf(\"    Modify partition supported.\\n\") ;\n     else\n       printf(\"    Modify partition not supported.\\n\") ;\n\n     printf(\"\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint dcharset(char *buf, short buflen)\n  /*\n    0x85: Character sets\n  */\n  {\n     int i, j ;         /* counters */\n     int cgcsgid ;      /* Coded graphic character set identifier */\n     int form ;         /* Supported loaded PS format types */\n     short ccsid ;      /* Coded character set identifier */\n     char gf = 0 ;      /* CGCSGID not present flag */\n     char ch2 = 0 ;     /* Two byte char. set flag */\n     char ms = 0 ;      /* Multiple slot sizes flag */\n     char cf = 0 ;      /* CCSID not present flag */\n     char sdw ;         /* Default character slot width */\n     char sdh ;         /* Default character slot height */\n     char dl ;          /* character set descriptor (CSD) length */\n     char *csd ;        /* character set descriptor (CSD) ptr */\n     char set ;         /* character set ID (PS store no.) */\n     char lcid ;        /* character set Local ID (alias) */\n     char sw ;          /* character set slot width */\n     char sh ;          /* character set slot height */\n     char ssubsn ;      /* character set starting subsection */\n     char esubsn ;      /* character set ending subsection */\n     char name\u00dd16\u00a8 ;    /* character set name */\n\n     printf(\"  Character sets:\\n\") ;\n\n     if (*(buf+4) & 0x80)\n       printf(\"    Graphic Escape (GE) supported.\\n\") ;\n     else\n       printf(\"    Graphic Escape not supported.\\n\") ;\n\n     if (*(buf+4) & 0x40)\n       printf(\"    Multiple LCIDs supported.\\n\") ;\n     else\n       printf(\"    Multiple LCIDs not supported.\\n\") ;\n\n     if (*(buf+4) & 0x20)\n       printf(\"    Load PSSF supported.\\n\") ;\n     else\n       printf(\"    Load PSSF not supported.\\n\") ;\n\n     if (*(buf+4) & 0x10)\n       printf(\"    Load PS Extended supported.\\n\") ;\n     else\n       printf(\"    Load PS Extended not supported.\\n\") ;\n\n     if (*(buf+4) & 0x08)\n       {\n         ms = 1 ;\n         printf(\"    More than one size character slot supported.\\n\") ;\n       }\n     else\n       printf(\"    Only one size character slot is supported.\\n\") ;\n\n     if (*(buf+4) & 0x04)\n       {\n         ch2 = 1 ;\n         printf(\"    Two byte code character sets are supported.\\n\") ;\n       }\n     else\n       printf(\"    Two byte code character sets are not supported.\\n\") ;\n\n     if (*(buf+4) & 0x02)\n       {\n         gf = 1 ;\n         printf(\"    CGCSGID present.\\n\") ;\n       }\n     else\n       printf(\"    CGCSGID not present.\\n\") ;\n\n     if (*(buf+5) & 0x40)\n       printf(\"    Load PS match slot size not required.\\n\") ;\n     else\n       printf(\"    Load PS match slot size required.\\n\") ;\n\n     if (*(buf+5) & 0x20)\n       {\n         cf = 1 ;\n         printf(\"    CCSID present.\\n\") ;\n       }\n     else\n       printf(\"    CCSID not present.\\n\") ;\n\n     sdw = *(buf+6) ;\n     sdh = *(buf+7) ;\n     printf(\"    Default character slot width: %d\\n\",sdw) ;\n     printf(\"    Default character slot height: %d\\n\",sdh) ;\n\n     form = *((int *)(buf+8)) ;\n     for (i=0;i<=31;i++)\n       {\n         if (form & 0x80000000)\n           printf(\"    Load PS format type %d supported.\\n\",i) ;\n         form = form << 1 ;\n       }\n     dl = *(buf+12) ;   /* get CSD length */\n     i = 13 ;\n     while (i<buflen)\n       {\n         csd = buf + i ;  /* point at CSD to process */\n         set = *csd ;     /* get character set ID (PS store no.) */\n         printf(\"    Character set: %d\\n\",set) ;\n         if (*(csd+1) & 0x80)\n           printf(\"      Loadable character set.\\n\") ;\n         else\n           printf(\"      Non-Loadable character set.\\n\") ;\n\n         if (*(csd+1) & 0x40)\n           printf(\"      Triple-plane character set.\\n\") ;\n         else\n           printf(\"      Single-plane character set.\\n\") ;\n\n         if (*(csd+1) & 0x20)\n           printf(\"      Double-byte coded character set.\\n\") ;\n         else\n           printf(\"      Single-byte coded character set.\\n\") ;\n\n         if (*(csd+1) & 0x10)\n           printf(\"      No LCID compare.\\n\") ;\n         else\n           printf(\"      LCID compare.\\n\") ;\n\n         lcid = *(csd+2) ;   /* get character set ID (PS store no.) */\n         printf(\"      Local character set ID (alias): %d\\n\",lcid) ;\n\n         j = 0 ;\n         if (ms)\n           {\n             sw = *(csd+3) ;  /* slot width */\n             sh = *(csd+4) ;  /* slot height */\n             printf(\"      Slot width: %d \\n\",sw) ;\n             printf(\"      Slot height: %d \\n\",sh) ;\n             j = j + 2 ;\n           }\n\n         if (ch2)\n           {\n             ssubsn = *(csd+j+3) ;  /* starting sub-section */\n             esubsn = *(csd+j+4) ; /* ending sub-section */\n             printf(\"      Starting sub-section: %d \\n\",ssubsn) ;\n             printf(\"      Ending sub-section: %d \\n\",esubsn) ;\n             j = j + 2 ;\n           }\n\n         if (gf)\n           {\n             cgcsgid = *((int *)(csd+j+3)) ;  /* Graf char set ID */\n             if (cgcsgid==0x00000000)\n               strcpy(name,\"Loadable\") ;\n             else if (cgcsgid==0x03c30136)\n               strcpy(name,\"APL\") ;\n             else if (cgcsgid==0x02b90025)\n               strcpy(name,\"U.S. English\") ;\n             else if (cgcsgid==0x02b9011d)\n               strcpy(name,\"U.K. English\") ;\n             else if (cgcsgid==0x02b90129)\n               strcpy(name,\"French\") ;\n             else if (cgcsgid==0x02b90111)\n               strcpy(name,\"Austrian/German\") ;\n             else if (cgcsgid==0x02b90118)\n               strcpy(name,\"Italian\") ;\n             else if (cgcsgid==0x02b9011c)\n               strcpy(name,\"Spanish\") ;\n             else\n               strcpy(name,\"Unknown\") ;\n             printf(\"      Coded graphic char. set ID: '%.8X'x \",\n               cgcsgid) ;\n             printf(\"- %s symbol set.\\n\",name) ;\n             j = j + 4 ;\n           }\n\n         if (cf)\n           {\n             ccsid = *((short *)(csd+j+3)) ;  /* char set ID */\n             printf(\"      Coded character set ID: '%.4X'x\\n\",ccsid) ;\n           }\n\n         i = i + dl ;  /* get pos of next CSD */\n       }  /* of while i<buflen */\n\n     printf(\"\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint dcolor(char *buf, short buflen)\n  /*\n    0x86: Colors\n  */\n  {\n     char acolors\u00dd16\u00a8\u00dd15\u00a8 = {\n       {\"Black         \"},    /* 'f0'x   00 */\n       {\"Blue          \"},    /* 'f1'x   01 */\n       {\"Red           \"},    /* 'f2'x   02 */\n       {\"Pink          \"},    /* 'f3'x   03 */\n       {\"Green         \"},    /* 'f4'x   04 */\n       {\"Turquoise     \"},    /* 'f5'x   05 */\n       {\"Yellow        \"},    /* 'f6'x   06 */\n       {\"White         \"},    /* 'f7'x   07 */\n       {\"Black         \"},    /* 'f8'x   08 */\n       {\"Deep Blue     \"},    /* 'f9'x   09 */\n       {\"Orange        \"},    /* 'fa'x   10 */\n       {\"Purple        \"},    /* 'fb'x   11 */\n       {\"Pale Green    \"},    /* 'fc'x   12 */\n       {\"Pale Turquoise\"},    /* 'fd'x   13 */\n       {\"Gray          \"},    /* 'fe'x   14 */\n       {\"White         \"}     /* 'ff'x   15 */\n     } ;\n     int colors ;     /* number of colors */\n     int icolor ;     /* color index */\n     int i ;          /* counter */\n     char attr ;      /* color attribute accepted by device */\n     char dcolor ;    /* color displayed for this attribute */\n\n     printf(\"  Colors:\\n\") ;\n     colors = (int)*(buf+5) ;\n     printf(\"    Number of colors supported: %d\\n\",colors) ;\n     printf(\"    Color attribute map follows:\\n\") ;\n     for (i=6;i<buflen;i=i+2)\n       {\n         attr = *(buf+i) ;        /* attribute used by appl. */\n         dcolor = *(buf+i+1) ;    /* attr/color used ny device */\n         icolor = (int)(dcolor - 0xf0) ;\n         if ((icolor >= 0) && (icolor <= 15))\n           printf(\"      Attr: %.2X Uses color: %s \\n\",\n             attr,acolors\u00ddicolor\u00a8) ;\n         else\n           printf(\"      Attr: %.2X Uses color is invalid.\\n\",attr) ;\n       }\n\n     printf(\"\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint dhilite(char *buf, short buflen)\n  /*\n    0x87: Highlighting\n  */\n  {\n     char ahilite\u00dd9\u00a8\u00dd11\u00a8 = {\n       {\"Normal    \"},    /* 'f0'x   00 */\n       {\"Blink     \"},    /* 'f1'x   01 */\n       {\"Reverse   \"},    /* 'f2'x   02 */\n       {\"          \"},    /* 'f3'x   03 */\n       {\"Underscore\"},    /* 'f4'x   04 */\n       {\"          \"},    /* 'f5'x   05 */\n       {\"          \"},    /* 'f6'x   06 */\n       {\"          \"},    /* 'f7'x   07 */\n       {\"Intensify \"}     /* 'f8'x   08 */\n     } ;\n     int hilites ;     /* number of hilites */\n     int ihilite ;     /* color index */\n     int i ;           /* counter */\n     char attr ;       /* color attribute accepted by device */\n     char dhilite ;    /* color displayed for this attribute */\n\n     printf(\"  Highlighting:\\n\") ;\n     hilites = (int)*(buf+4) ;\n     printf(\"    Number of highlights supported: %d\\n\",hilites) ;\n     printf(\"    Highlight attribute map follows:\\n\") ;\n     for (i=5;i<buflen;i=i+2)\n       {\n         attr = *(buf+i) ;        /* attribute used by appl. */\n         dhilite = *(buf+i+1) ;   /* attr/highlight used by device */\n         ihilite = (int)(dhilite - 0xf0) ;\n         if (attr == 0x00)\n           printf(\"      Attr: %.2X (default) Uses highlight: %s\\n\",\n             attr,ahilite\u00dd0\u00a8) ;\n         else if ((ihilite >= 0) && (ihilite <= 9))\n           printf(\"      Attr: %.2X Uses highlight: %s \\n\",\n             attr,ahilite\u00ddihilite\u00a8) ;\n         else\n           printf(\"      Attr: %.2X Used highlight is invalid.\\n\",\n             attr) ;\n       }\n\n     printf(\"\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint dmodes(char *buf, short buflen)\n  /*\n    0x88: Modes\n  */\n  {\n     int i ;           /* counter */\n     char mode ;       /* device opperation mode */\n\n     printf(\"  Modes:\\n\") ;\n     printf(\"    Supported modes follow:\\n\") ;\n     for (i=4;i<buflen;i++)\n       {\n         printf(\"      \") ;\n         mode = *(buf+i) ;        /* attribute used by appl. */\n         if (mode==0x00)\n           printf(\"Field mode (SF order).\\n\") ;\n         else if (mode==0x01)\n           printf(\"Extended field mode (SFE + MF orders).\\n\") ;\n         else if (mode==0x02)\n           printf(\"Character mode (SA order).\\n\") ;\n         else\n           printf(\"Warning: Mode %.2X not unknown.\\n\") ;\n       }   /* of for i */\n\n     printf(\"\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint dfieldv(char *buf, short buflen)\n  /*\n    0x8a: Field validation\n  */\n  {\n     printf(\"  Field validation:\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint dmsrcntl(char *buf, short buflen)\n  /*\n    0x8b: MSR Control\n  */\n  {\n     printf(\"  MSR Control:\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint dfieldol(char *buf, short buflen)\n  /*\n    0x8c: Field Outlining\n  */\n  {\n     printf(\"  Field Outlining:\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint dpartchr(char *buf, short buflen)\n  /*\n    0x8e: Partition Characteristics\n  */\n  {\n     printf(\"  Partition Characteristics:\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint doemaux(char *buf, short buflen)\n  /*\n    0x8f: OEM Auxillary Device\n  */\n  {\n     printf(\"  OEM Auxillary Device Info.:\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint dformat(char *buf, short buflen)\n  /*\n    0x90: Format presentation\n  */\n  {\n     printf(\"  Format Presentation:\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint ddbcs(char *buf, short buflen)\n  /*\n    0x91: DBCS - Asia\n  */\n  {\n     printf(\"  DBCS - Asia:\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint dsave(char *buf, short buflen)\n  /*\n    0x92: Save restore format\n  */\n  {\n     printf(\"  Save Restore Format:\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint dfmtaux(char *buf, short buflen)\n  /*\n    0x94: Format auxillary storage device\n  */\n  {\n     printf(\"  Format Auxillary Storage Device:\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint ddist(char *buf, short buflen)\n  /*\n    0x95: Distributed data management\n  */\n  {\n     printf(\"  Distributed Data Management:\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint dstrpool(char *buf, short buflen)\n  /*\n    0x96: Storage pools\n  */\n  {\n     printf(\"  Storage Pools:\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint ddocint(char *buf, short buflen)\n  /*\n    0x97: Document interchange arch.\n  */\n  {\n     printf(\"  Document Interchange Architecture:\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint datchain(char *buf, short buflen)\n  /*\n    0x98: Data chaining\n  */\n  {\n     printf(\"  Data Chaining:\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint dauxdev(char *buf, short buflen)\n  /*\n    0x99: Auxilliary device\n  */\n  {\n     printf(\"  Auxillary Device:\\n\") ;\n     printf(\"    Auxillary devices are supported.\\n\") ;\n\n     printf(\"\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint d3270ip(char *buf, short buflen)\n  /*\n    0x9a: 3270 IPDS\n  */\n  {\n     printf(\"  3270 IPDS:\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint dpdds(char *buf, short buflen)\n  /*\n    0x9c: Product defined data stream\n  */\n  {\n     printf(\"  Product Defined Data Stream:\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint danom(char *buf, short buflen)\n  /*\n    0x9d: Anomaly implementation\n  */\n  {\n     printf(\"  Anomaly Implementation:\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint dibmaux(char *buf, short buflen)\n  /*\n    0x9e: IBM auxilliary device\n  */\n  {\n     printf(\"  IBM Auxillary Device:\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint dbeof(char *buf, short buflen)\n  /*\n    0x9f: Begin / end of file\n  */\n  {\n     printf(\"  Begin/End of File:\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint ddevchar(char *buf, short buflen)\n  /*\n    0xa0: Device characteristics\n  */\n  {\n     printf(\"  Device Characteristics:\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint drpqname(char *buf, short buflen)\n  /*\n    0xa1: RPQ names\n  */\n  {\n     printf(\"  RPQ Names:\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint ddatastr(char *buf, short buflen)\n  /*\n    0xa2: Data streams\n  */\n  {\n     printf(\"  Data Streams:\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint dimpart(char *buf, short buflen)\n  /*\n    0xa6: Implicit partition\n  */\n  {\n     char *sdp ;                /* self defining parameter (SDP) ptr */\n     short wd, wa, hd, ha ;     /* screen dimensions */\n     short wcd, wca, hcd, hca ; /* cell sizes */\n     int i ;                    /* counter */\n\n     printf(\"  Implicit Partition:\\n\") ;\n     i = 6 ;        /* length of header */\n     while(i < buflen)   /* loop over all SDPs */\n       {\n         sdp = buf + i ;\n         if (*sdp==0x0b)    /* is it a SDP ? */\n           {\n             if (*(sdp+1)==0x01)\n               {\n                 wd = *((short *)(sdp+3)) ;  /* default width */\n                 hd = *((short *)(sdp+5)) ;  /* default height */\n                 wa = *((short *)(sdp+7)) ;  /* alternate width */\n                 ha = *((short *)(sdp+9)) ;  /* alternate height */\n                 printf(\"    Default width: %d \\n\",wd) ;\n                 printf(\"    Default height: %d \\n\",hd) ;\n                 printf(\"    Alternate width: %d \\n\",wa) ;\n                 printf(\"    Alternate height: %d \\n\",ha) ;\n                 i = i + 11 ;     /* add length of this SDP */\n               }\n             else if (*(sdp+1)==0x03)\n               {\n                 printf(\"    Device is a printer.\\n\") ;\n                 i = i + 11 ;     /* add length of this SDP */\n               }\n             else if (*(sdp+1)==0x02)\n               {\n                 wcd = *((short *)(sdp+3)) ;  /* default cell width */\n                 hcd = *((short *)(sdp+5)) ;  /* default cell height */\n                 wca = *((short *)(sdp+7)) ;  /* alternate cell width */\n                 hca = *((short *)(sdp+9)) ;  /* alternate cell height*/\n                 printf(\"    Default cell width: %d \\n\",wcd) ;\n                 printf(\"    Default cell height: %d \\n\",hcd) ;\n                 printf(\"    Alternate cell width: %d \\n\",wca) ;\n                 printf(\"    Alternate cell height: %d \\n\",hca) ;\n                 i = i + 11 ;     /* add length of this SDP */\n               }\n           }\n         else\n           printf(\"  Warning: SDP invalid.\\n\") ;\n       }  /* of while */\n\n     printf(\"\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint dpaperf(char *buf, short buflen)\n  /*\n    0xa7: Paper feed techniques\n  */\n  {\n     printf(\"  Paper Feed Techniques:\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint dtrans(char *buf, short buflen)\n  /*\n    0xa8: Transparency\n  */\n  {\n     printf(\"  Transparency:\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint dsprnch(char *buf, short buflen)\n  /*\n    0xa9: Settable printer chars.\n  */\n  {\n     printf(\"  Settable Printer chars.:\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint diocaaux(char *buf, short buflen)\n  /*\n    0xaa: IOCA Auxillary Device\n  */\n  {\n     printf(\"  IOCA Auxillary Device:\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint dcooproc(char *buf, short buflen)\n  /*\n    0xab: Cooperative proc requestor\n  */\n  {\n     printf(\"  Cooperative Proc Requestor:\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint dsegment(char *buf, short buflen)\n  /*\n    0xb0 Segment\n  */\n  {\n     printf(\"  Segment:\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint dproc(char *buf, short buflen)\n  /*\n    0xb1: Procedure\n  */\n  {\n     printf(\"  Procedure:\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint dlinetyp(char *buf, short buflen)\n  /*\n    0xb2: Line type\n  */\n  {\n     printf(\"  Line Type:\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint dport(char *buf, short buflen)\n  /*\n    0xb3: Port\n  */\n  {\n     printf(\"  Port:\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint dgrapcol(char *buf, short buflen)\n  /*\n    0xb4: Graphic color\n  */\n  {\n     printf(\"  Graphic Color:\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint dextdraw(char *buf, short buflen)\n  /*\n    0xb5: Extended drawing routine\n  */\n  {\n     printf(\"  Extended Drawing Routine:\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint dgrapsym(char *buf, short buflen)\n  /*\n    0xb6: Graphic symbol sets\n  */\n  {\n     printf(\"  Graphic Symbol Sets:\\n\") ;\n     dumpchar(buf,(int)buflen) ;\n     return 0 ;\n  }\n\nint tputn(char *buf, int buflen)\n  /*\n     The TPUTN routine is loaded below the 16M line\n     It issues the TPUT macro with the NOEDIT option\n  */\n  {\n    int rc = 0 ;\n    int (*tputn)(char *,int) ;\n\n    loadm(\"TPUTN\",&tputn) ;\n    rc = (*tputn)(buf,buflen) ;\n    unloadm(tputn) ;\n    return rc ;\n  }\n\nint tpgn(char *buf, int buflen)\n  /*\n    The TPGN routine is loaded below the 16M line\n    It issues the TPG macro with the NOEDIT option\n  */\n  {\n    int rc = 0 ;\n    int (*tpgn)(char *,int) ;\n\n    loadm(\"TPGN\",&tpgn) ;\n    rc = (*tpgn)(buf,buflen) ;\n    unloadm(tpgn) ;\n    return rc ;\n  }\n\nvoid fill(char *haystack, char filler, int num)\n  /*\n    Fills an area of memory with a specific fill\n    character.\n  */\n  {\n    int i = 0 ;\n    for(i=0;i<=num;i++)\n      *haystack++ = filler ;\n    *haystack = '\\0' ;\n  }\n\nvoid dumpchar(char *dat, int len)\n  /*\n    Dumps an area of memory using a HEX and character dump\n    format that positions the hex charactes above the EBCIDC\n    character representation. Also tries to interpret some\n    of the special characters as 3270 data stream commands\n    or orders.\n  */\n  {\n    char *cptr ;\n    char c ;\n    char cc\u00dd3\u00a8 ;\n    int i ;\n    int n, m ;\n\n    if (terse)     /* dont dump buffer if terse parameter specified */\n      return ;\n\n    n = 0 ;\n    m = 0 ;\n    cptr = dat ;\n    if (len==0)\n      printf(\"    Buffer at: %.8X follows: \\n\",dat) ;\n    else\n      printf(\"    Buffer at: %.8X length: %d follows: \\n\",dat,len) ;\n\n    do\n      {\n        printf(\"      %.8X  \",dat) ;\n        for(i=1;i<=16;i++)\n          {\n            if (*dat=='\\0' && len==0)\n              break ;\n            if (n==len && len>0)\n              break ;\n            c = *dat++ ;\n            n++ ;\n            printf(\"%.2X\",c) ;\n            if ((i%4)==0)\n              printf(\" \") ;\n          }\n        printf(\"\\n                \") ;\n\n        for(i=1;i<=16;i++)\n          {\n            if (*cptr=='\\0' && len==0)\n              break ;\n            if (m==len && len>0)\n              break ;\n            c = *cptr++ ;\n            m++ ;\n            if (c <= 0x3f || c==0xff)\n              {\n                switch (c)\n                  {\n                    case GE:   strcpy(cc,\"GE\") ;\n                      break ;\n                    case FF:   strcpy(cc,\"FF\") ;\n                      break ;\n                    case CRR:  strcpy(cc,\"CR\") ;\n                      break ;\n                    case SBA:  strcpy(cc,\"SB\") ;\n                      break ;\n                    case EUA:  strcpy(cc,\"EU\") ;\n                      break ;\n                    case ICUR: strcpy(cc,\"IC\") ;\n                      break ;\n                    case NL:   strcpy(cc,\"NL\") ;\n                      break ;\n                    case EM:   strcpy(cc,\"EM\") ;\n                      break ;\n                    case DUP:  strcpy(cc,\"DU\") ;\n                      break ;\n                    case SF:   strcpy(cc,\"SF\") ;\n                      break ;\n                    case FM:   strcpy(cc,\"FM\") ;\n                      break ;\n                    case SA:   strcpy(cc,\"SA\") ;\n                      break ;\n                    case SFE:  strcpy(cc,\"SX\") ;\n                      break ;\n                    case MF:   strcpy(cc,\"MF\") ;\n                      break ;\n                    case RA:   strcpy(cc,\"RA\") ;\n                      break ;\n                    case SUB:  strcpy(cc,\"SU\") ;\n                      break ;\n                    default:   strcpy(cc,\". \") ;\n                      break ;\n                  }\n                printf(\"%s\",cc) ;\n              }\n            else\n              printf(\"%c \",c) ;\n            if ((i%4)==0)\n              printf(\" \") ;\n          }\n        printf(\"\\n\") ;\n      }\n    while( ((*dat!='\\0') && (len==0)) ||\n           ((m!=len) && (len>20))\n         ) ;\n    printf(\"\\n\") ;\n  }\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "LSTBOX32": {"ttr": 4614, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x95(o\\x00\\x95(\\x9f\\x17\\x02\\x0bD\\x0b1\\x00\\x00\\xe2\\xc1\\xe2\\xc4\\xc4\\xc6@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1995-10-13T00:00:00", "modifydate": "1995-10-16T17:02:00", "lines": 2884, "newlines": 2865, "modlines": 0, "user": "SASDDF"}, "text": "#pragma eject\n#pragma title lstbox32.c - display a list box on a 3270 device\n\n/*+-----------------------------------------------------------------+\n  | Program:   lstbox32.c                                           |\n  | Language:  c                                                    |\n  | Support:   DAF                                                  |\n  | Purpose:   To learn some full screen 3270 coding techniques to  |\n  |            use on the IBM 3270 display station.                 |\n  |                                                                 |\n  |            The following publications have been used in the     |\n  |            developement of this program:                        |\n  |              SC28-1875 TSO/E v2 programming Services            |\n  |              GA23-0059 3270 Info. Display Sys. Data Stream      |\n  |                        Programmers Reference.                   |\n  |              GA27-3831 3174 Establishment Controller Character  |\n  |                        Set Reference.                           |\n  |              GA27-2837 3270 Character Set Reference.            |\n  |              HUR 9058  IBM3270 Personal Computer Graphics       |\n  |                        Control Program Data Stream Reference.   |\n  |              GA18-2589 IBM 3179-G/3192-G Color Graphics Display |\n  |                        Station Description.                     |\n  |              GG27-6999 Introduction to Programming the IBM 3270.|\n  |                                                                 |\n  |            This programs main routine creates a simple notepad  |\n  |            window on the 3270. It uses routines to build the    |\n  |            notepad that support the creation, modification,     |\n  |            removal, and display of fields on the 3270 screen.   |\n  |            A screen is represented as linked list of fields.    |\n  |            These field routines can be viewed as an API that    |\n  |            the main program (application) uses to create windows|\n  |            on the 3270. The application is freed from managing  |\n  |            things like buffer address translation, and data     |\n  |            stream creation, and inbound data stream parsing.    |\n  |            Varying length strings are represented by the data   |\n  |            type LSTR. These strings can contain amy amount of   |\n  |            data including the null character.                   |\n  |                                                                 |\n  |            The following techniques have not been implemented   |\n  |            in this program but will be added later:             |\n  |            - Data stream compression using RBA.                 |\n  |            - Graphics support.                                  |\n  |                                                                 |\n  | Notes:     1. Numeric fields do not work the same on all        |\n  |               devices. The 3192-G allows lowercase character    |\n  |               input. Many devices also upper case character     |\n  |               input.                                            |\n  |            2. Most devices do not support field attributes:     |\n  |               Field Outlining, Background color, and Field      |\n  |               Validation.                                       |\n  |            3. The character set for APL does not appear to be   |\n  |               allowed on the SFE order, only on the SA order.   |\n  | End.                                                            |\n  +-----------------------------------------------------------------+*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <svc.h>\n#include <tput.h>\n#include <ostask.h>\n\n#define _AMODE31\n\n#include \"ps9x16u.inc\"\n#include \"ps9x15u.inc\"\n#include \"ps9x12u.inc\"\n\n/* escape character and device commands */\n#define ESC     0x27\n#define EW      0xf5\n#define EWA     0x7e\n#define WRT     0xf1\n#define WSF     0xf3\n#define RB      0xf2\n\n/* write control characters, or'd together as required */\n#define WCCMDT  0x01\n#define WCCKBD  0x02\n#define WCCRES  0xc0\n#define WCCBEL  0x04\n\n/* 3270 data stream orders */\n#define GE      0x08\n#define FF      0x0c\n#define CRR     0x0d\n#define SBA     0x11\n#define EUA     0x12\n#define ICUR    0x13\n#define NL      0x15\n#define EM      0x19\n#define DUP     0x1c\n#define SF      0x1d\n#define FM      0x1e\n#define SA      0x28\n#define SFE     0x29\n#define MF      0x2c\n#define RA      0x3c\n#define SUB     0x3f\n\n#define PROT    0x20\n#define NUM     0x10\n\n/* Type byte of the SA, SFE and MF orders */\n#define ALL     0x00\n#define NONE    0x00\n#define DFLT    0x00\n\n#define ATTR    0xc0\n#define FVALID  0xc1\n#define OUTLIN  0xc2\n#define HILITE  0x41\n#define COLOR   0x42\n#define SYMSET  0x43\n#define BAKCOL  0x45\n#define TRANSP  0x46\n\n#define APL     0xF1\n\n/* Out lines for the value byte of the SA, SFE, or MF order */\n#define UNDR    0x01\n#define OVR     0x04\n#define OVRUND  0x05\n#define NOOVR   0x0b\n#define NOUNDR  0x0e\n#define RECT    0x0f\n\n/* Hilites for the value byte of the SA, SFE, or MF order */\n#define BLINK   0xf1\n#define RVIDEO  0xf2\n#define USCORE  0xf4\n\n/* Colors for the value byte of the SA, SFE, or MF order */\n#define BLUE    0xf1\n#define RED     0xf2\n#define PINK    0xf3\n#define GREEN   0xf4\n#define TURQ    0xf5\n#define CYAN    0xf5\n#define YELLOW  0xf6\n#define WHITE   0xf7\n\n/* Attribute for the value byte of the SF, SFE and MF order */\n#define UNPRT   0x40\n#define UNNUM   0x50\n#define UNNUMHI 0xd8\n#define UNNON   0x4c\n#define UNHI    0xc8\n#define PRT     0x60\n#define PRTHI   0xe4\n#define PRTAS   0xf0\n#define PRTHIAS 0xf8\n\n/* Attention Identification (AID) Values */\n#define NOAID   0x60\n#define NOAIDP  0xe8\n#define STRFLD  0x88\n#define ENTER   0x7d\n#define PF1     0xf1\n#define PF2     0xf2\n#define PF3     0xf3\n#define PF4     0xf4\n#define PF5     0xf5\n#define PF6     0xf6\n#define PF7     0xf7\n#define PF8     0xf8\n#define PF9     0xf9\n#define PF10    0x7a\n#define PF11    0x7b\n#define PF12    0x7c\n#define PF13    0xc1\n#define PF14    0xc2\n#define PF15    0xc3\n#define PF16    0xc4\n#define PF17    0xc5\n#define PF18    0xc6\n#define PF19    0xc7\n#define PF20    0xc8\n#define PF21    0xc9\n#define PF22    0x4a\n#define PF23    0x4b\n#define PF24    0x4c\n#define OID     0xe6\n#define MAG     0xe7\n#define PEN     0x7e\n#define PA1     0x6c\n#define PA2     0x6e\n#define PA3     0x6b\n#define CLEAR   0x6d\n#define SYSREQ  0xf0\n\ntypedef\n  struct LSTR     /* string with length */\n  {\n    int len ;             /* current length of data */\n    char *data ;          /* pointer to data */\n  } TLSTR ;\n\ntypedef\n  struct SFLD     /* 3270 screen field information list entry */\n  {\n    int fid ;             /* unique field identifier */\n    TLSTR fdata ;         /* field data (input or output) */\n    int fxpos ;           /* X column position */\n    int fypos ;           /* Y row position */\n    char fattr ;          /* 3270 field attribute */\n    char fcolor ;         /* 3270 color attribute */\n    char fhilite ;        /* 3270 hilite attribute */\n    char symbol ;         /* 0x00=normal 0xf1=APL else 0x40-0xef=PS */\n    struct SFLD *next ;   /* next list entry */\n  } TSFLD ;\n\n#define BUFFMAX 5000\nchar *buffer ;    /* buffer area for tput/tget */\n\nTSFLD *screen ;   /* root of 3270 screen field list */\n\n#define SFIDMAX 256\nTSFLD *sfidtab\u00ddSFIDMAX\u00a8 ; /* field id address table */\nint fidnext = 0 ;         /* next field id number to assign */\nint curcol = 1 ;          /* current cursor column */\nint currow = 1 ;          /* current cursor row */\nint bellflg = 0 ;         /* ring bell on next display */\nint iotrace = 0 ;         /* trace terminal I/O flag */\n\n\nstruct DCB        /* Device control block */\n  {\n    int model ;         /* model number ie: 3279, 3278, 3277 */\n    int type ;          /* model type ie: 2, 3, 4, 5 */\n    int rows ;          /* number of rows (height) on device */\n    int cols ;          /* number of columns (width) on device */\n    int celheigh ;      /* cell height on device */\n    int celwidth ;      /* cell width on device */\n    int colors ;        /* number of colors on device */\n    int colora ;        /* number of actual colors on device */\n    int hilites ;       /* number of colors on device */\n    int adrmode ;       /* device addressing mode: 12 or 14 or 16 bit*/\n    char unit ;         /* 0 = inch 1 = mm */\n    char edsflg ;       /* extended data stream flag */\n    char psflg ;        /* program symbols on device flag */\n    char altflg ;       /* use alternate flag */\n    char aplflg ;       /* 0 or apl's lcid=supports APL on device */\n    char graflg ;       /* graphics device flag */\n    char loadflg ;      /* loadable symbol sets supported flag */\n    char triflg ;       /* triple plane symbol sets supported flag */\n    char dbcsflg ;      /* double byte characters supported flag */\n    char colorlst\u00dd17\u00a8 ; /* list of color attributes on device */\n    char hilitlst\u00dd5\u00a8 ;  /* list of hilite attributes on device */\n    char modname\u00dd11\u00a8 ;  /* name of device ie: IBM32793B IBM3179G ..*/\n  } sdcb ;\n\n\n\n/*-------------------------------------------------------------------*/\n/* Function Prototypes                                               */\n/*-------------------------------------------------------------------*/\n\n/* field handling */\nint initscr() ;\nvoid termscr() ;\nchar dspflds() ;\nint insfld(TLSTR *, int, int, char, char, char) ;\nint getdev() ;\nint remflds() ;\nint delfld(int) ;\nint erasefld(int) ;\nint getfld(int, TLSTR *) ;\nint modfld(int, TLSTR *) ;\nint setfld(int, int, char) ;\nvoid dumpfld() ;\n/* 3270 support */\nint tputn(char *, int) ;\nint tgetn(char *, int) ;\nint tpgn(char *, int) ;\nvoid rc2sba(int, int, char *) ;\nvoid sba2rc(char *, int *, int *, int) ;\nint modsym(char *, char) ;\nint modcolor(char *, char) ;\nint modhilit(char *, char) ;\nint modattr(char *, char) ;\nint getterm(int *, int *, int *, int *, int *) ;\nint querydev() ;\nint dsummary(char *, short) ;\nint darea(char *, short) ;\nint dcharset(char *, short) ;\nint dcolor(char *, short) ;\nint dhilite(char *, short) ;\nint dmodes(char *, short) ;\nint dimpart(char *, short) ;\nint loadps1() ;\nvoid termstat() ;\nvoid clear() ;\n/* varying length string */\nvoid lstran(TLSTR *, char, char) ;\nint lstrlen(TLSTR *) ;\nvoid lstrload(TLSTR *, char *, int) ;\nint lstrunld(char *, TLSTR *) ;\nvoid lstrcopy(TLSTR *, TLSTR *) ;\nvoid lstrnew(TLSTR *, char *) ;\nvoid lstrsub(TLSTR *, TLSTR *, int, int) ;\nint lstrindx(TLSTR *, TLSTR *) ;\nvoid lstrfill(TLSTR *, char *) ;\nint lstrcmpc(TLSTR *, char *) ;\nvoid lstrdel(TLSTR *) ;\nvoid lstrrep(TLSTR *, char *, int) ;\nvoid lstrcat(TLSTR *, TLSTR *, TLSTR *) ;\n/* utility */\nvoid fill(char *, char, int) ;\nvoid dumpchar(char *, int) ;\nvoid overlay(char *, int, char *, int, int) ;\nvoid serror(int, char *) ;\n\n\n/* application routines */\nvoid buildwin() ;\nvoid dispwin() ;\nvoid winmsg(char *) ;\n\n/* variables for application */\nint cmdfid ;       /* field identifier for command line */\nint msgfid ;       /* field identifier for message line */\nint bt ;           /* top border */\nint bb ;           /* bottom border */\nint bl ;           /* left border */\nint br ;           /* right border */\nint cmdflg = 0 ;   /* command flag = true if command done */\n\n /*-----------------------------------------------------------------*\n  | Main Program                                                    |\n  *-----------------------------------------------------------------*/\nvoid main(int argc, char **argv, char **envp)\n  {\n    int rc ;        /* return code */\n\n    rc = initscr() ;  /* initialise environment */\n    if (rc==0)         /* if env OK */\n      {\n        /* initial border positions */\n        bt = 1 ;            /* top border */\n        bb = sdcb.rows ;    /* bottom border */\n        bl = 1 ;            /* left border */\n        br = sdcb.cols ;    /* right border */\n\n        /* indicate cursor on command field and set field to blank */\n        cmdflg = 1 ;\n\n        buildwin() ;  /* build the initial display window */\n        dispwin() ;   /* display the window and run appl. */\n\n        termscr() ;   /* terminate environment */\n      }\n  }\n\n\n/*-------------------------------------------------------------------*/\n/* Build a window with a title, command line and an edit space.      */\n/*-------------------------------------------------------------------*/\nvoid buildwin()\n  {\n    int t, tl ;                /* temp */\n    int i ;                    /* counter */\n    int fid ;                  /* field identifier handle */\n    TLSTR data, data1, data2, data3, data4 ; /* temp varying strings */\n    TLSTR title ;              /* title string */\n\n    /* create title line */\n    lstrnew(&title,\" LSTBOX32: 3270 List box test\");\n\n    /* create command line (prompt, input area, and help) */\n    lstrnew(&data,\"Command ===>\") ;   /* create VLstring */\n    fid = insfld(&data,bt+1,bl+2,PRT,WHITE,NONE);\n    if (fid<0) serror(81,\"Field insert failed\") ;\n    lstrnew(&data,\" \") ;   /* create VLstring */\n    cmdfid = insfld(&data,bt+1,bl+15,UNPRT,GREEN,NONE);\n    if (cmdfid<0) serror(81,\"Field insert failed\") ;\n    if ((br-bl)>18)\n      {\n        lstrnew(&data,\"PF1=Help PF3=End\") ;   /* create VLstring */\n        fid = insfld(&data,bt+1,br-18,PRT,WHITE,NONE);\n        if (fid<0) serror(81,\"Field insert failed\") ;\n      }\n\n    /* create message line */\n    lstrnew(&data,\" \") ;   /* create VLstring */\n    msgfid = insfld(&data,bt+2,bl+2,PRTHI,RED,NONE);\n    if (msgfid<0) serror(81,\"Field insert failed\") ;\n\n    /*----------------------------------------------------------------*/\n    /* Create top window border                                       */\n    /*   The border outline is drawn with different characters        */\n    /*     based on the devices abilities.                            */\n    /*   Window border locations are based on four global variables:  */\n    /*     bt - top border row                                        */\n    /*     bb - bottom border row                                     */\n    /*     br - right border column                                   */\n    /*     bl - left border column                                    */\n    /*----------------------------------------------------------------*/\n    if (sdcb.loadflg)\n      {\n        lstrnew(&data1,\"\\x42\\x47\") ;     /* top left corner */\n        lstrnew(&data2,\"\\x48\\x46\\x45\\x44\") ; /* top right corner */\n        lstrnew(&data3,\" \") ;\n        lstran(&title,0x40,0x48) ;      /* translate in PS blank char */\n        tl = lstrlen(&title) ; /* actual title length */\n        t = br-bl-5 ;           /* available space */\n        if (tl>t)\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrsub(&data3,&title,1,t-1) ; /* shorten title */\n            lstrcat(&data,&data,&data3) ;  /* add title */\n            lstrcat(&data,&data,&data2) ;  /* add right border */\n          }\n        else\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrcat(&data,&data,&title) ;  /* add title */\n            lstrrep(&data3,\"\\x48\",t-tl-1) ;/* repeat char to string */\n            lstrcat(&data,&data,&data3) ;  /* add top border chars */\n            lstrcat(&data,&data,&data2) ;  /* concat strings */\n          }\n        fid = insfld(&data,bt,bl,PRTAS,BLUE,NONE);\n        if (fid<0) serror(81,\"Field insert failed\") ;\n        setfld(fid,SYMSET,0x40) ;   /* make it id of PS symbols */\n      }\n    else if (sdcb.aplflg)\n      {\n        lstrnew(&data1,\"\\xc5\\xee\") ;     /* top left corner */\n        lstrnew(&data2,\"\\xa2\\xba\\xbb\\xd5\") ;   /* top right corner */\n        tl = lstrlen(&title) ; /* actual title length */\n        t = br-bl-5 ;           /* available space */\n        if (tl>t)\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrsub(&data4,&title,1,t-1) ; /* shorten title */\n            lstrnew(&data3,\"\\x28\\x43\\x01\") ;  /* stop APL chars */\n            lstran(&data3,0x01,0x00) ; /* translate 0x01 to ox00 */\n            lstrcat(&data,&data,&data3) ;  /* add stop APL */\n            lstrcat(&data,&data,&data4) ;  /* add title */\n            lstrnew(&data3,\"\\x28\\x43\\xf1\") ;  /* start APL */\n            lstrcat(&data,&data,&data3) ;  /* add start APL */\n            lstrcat(&data,&data,&data2) ;  /* add right border */\n          }\n        else\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrnew(&data3,\"\\x28\\x43\\x01\") ;  /* stop APL chars */\n            lstran(&data3,0x01,0x00) ; /* translate 0x01 to ox00 */\n            lstrcat(&data,&data,&data3) ;  /* add stop APL */\n            lstrcat(&data,&data,&title) ;  /* add title */\n            lstrnew(&data3,\"\\x28\\x43\\xf1\") ;  /* start APL */\n            lstrcat(&data,&data,&data3) ;  /* add start APL */\n            lstrrep(&data3,\"s\",t-tl-1) ;   /* repeat char to string */\n            lstrcat(&data,&data,&data3) ;  /* add top border chars */\n            lstrcat(&data,&data,&data2) ;  /* concat strings */\n          }\n        fid = insfld(&data,bt,bl,PRTAS,BLUE,NONE);\n        if (fid<0) serror(81,\"Field insert failed\") ;\n        setfld(fid,SYMSET,APL) ; /* make it APL */\n      }\n    else\n      {\n        lstrnew(&data1,\"+#\") ;     /* create VLstring */\n        lstrnew(&data2,\"-VA+\") ;   /* create VLstring */\n        lstrnew(&data3,\" \") ;\n        tl = lstrlen(&title) ;     /* actual title length */\n        t = br-bl-5 ;              /* available space */\n        if (tl>t)\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrsub(&data4,&title,1,t-1) ; /* shorten title */\n            lstrcat(&data,&data,&data4) ;  /* add title */\n            lstrcat(&data,&data,&data2) ;  /* add right border */\n          }\n        else\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrcat(&data,&data,&title) ;  /* add title */\n            lstrrep(&data3,\"-\",t-tl-1) ;   /* repeat char to string */\n            lstrcat(&data,&data,&data3) ;  /* add top border chars */\n            lstrcat(&data,&data,&data2) ;  /* concat strings */\n          }\n        fid = insfld(&data,bt,bl,PRTAS,BLUE,NONE);\n        if (fid<0) serror(81,\"Field insert failed\") ;\n      }\n\n    /* create edit area lines and left and right borders */\n    for (i=bt+1; i<=bb-1; i++)    /* edit area fields */\n      {\n        /* add left border */\n        if (sdcb.loadflg)\n          {\n            lstrnew(&data,\"\\x71\") ;\n            fid = insfld(&data,i,bl,PRTAS,BLUE,NONE) ;\n            if (fid<0) serror(81,\"Field insert failed\") ;\n            setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n          }\n        else if (sdcb.aplflg)\n          {\n            lstrnew(&data,\"e\") ;\n            fid = insfld(&data,i,bl,PRTAS,BLUE,NONE) ;\n            if (fid<0) serror(81,\"Field insert failed\") ;\n            setfld(fid,SYMSET,APL) ; /* make it APL */\n          }\n        else\n          {\n            lstrnew(&data,\"|\") ;\n            fid = insfld(&data,i,bl,PRTAS,BLUE,NONE) ;\n            if (fid<0) serror(81,\"Field insert failed\") ;\n          }\n\n        /* add right border */\n        if (sdcb.loadflg)\n          {\n            lstrnew(&data,\"\\x71\") ;\n            fid = insfld(&data,i,br-1,PRTAS,BLUE,NONE) ;\n            if (fid<0) serror(81,\"Field insert failed\") ;\n            setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n          }\n        else if (sdcb.aplflg)\n          {\n            lstrnew(&data,\"e\") ;\n            fid = insfld(&data,i,br-1,PRTAS,BLUE,NONE) ;\n            if (fid<0) serror(81,\"Field insert failed\") ;\n            setfld(fid,SYMSET,APL) ; /* make it APL */\n          }\n        else\n          {\n            lstrnew(&data,\"|\") ;\n            fid = insfld(&data,i,br-1,PRTAS,BLUE,NONE) ;\n            if (fid<0) serror(81,\"Field insert failed\") ;\n          }\n      }  /* of for edit area lines */\n\n    /* create bottom border */\n    if (sdcb.loadflg)\n      {\n        lstrnew(&data1,\"\\x67\") ;       /* lower left corner */\n        lstrnew(&data2,\"\\x69\") ;       /* lower right corner */\n        lstrrep(&data,\"\\x70\",br-bl-2) ;/* lower border chars */\n        lstrcat(&data,&data1,&data) ;  /* concat strings */\n        lstrcat(&data,&data,&data2) ;  /* concat strings */\n        fid = insfld(&data,bb,bl,PRTAS,BLUE,NONE) ;\n        if (fid<0) serror(81,\"Field insert failed\") ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n      }\n    else if (sdcb.aplflg)\n      {\n        lstrnew(&data1,\"D\") ;          /* lower left corner */\n        lstrnew(&data2,\"M\") ;          /* lower right corner */\n        lstrrep(&data,\"s\",br-bl-2) ;   /* lower border chars */\n        lstrcat(&data,&data1,&data) ;  /* concat strings */\n        lstrcat(&data,&data,&data2) ;  /* concat strings */\n        fid = insfld(&data,bb,bl,PRTAS,BLUE,NONE) ;\n        if (fid<0) serror(81,\"Field insert failed\") ;\n        setfld(fid,SYMSET,APL) ; /* make it APL */\n      }\n    else\n      {\n        lstrnew(&data1,\"+\") ;          /* lower left corner */\n        lstrnew(&data2,\"+\") ;          /* lower right corner */\n        lstrrep(&data,\"-\",br-bl-2) ;   /* lower border chars */\n        lstrcat(&data,&data1,&data) ;  /* concat strings */\n        lstrcat(&data,&data,&data2) ;  /* concat strings */\n        fid = insfld(&data,bb,bl,PRTAS,BLUE,NONE) ;\n        if (fid<0) serror(81,\"Field insert failed\") ;\n      }\n\n    /* create some widgets in the window */\n    if (sdcb.loadflg)\n      {\n        /* title static label */\n        lstrnew(&data1,\"Program Symbol Device Style\") ;\n        fid = insfld(&data1,bt+3,bl+15,PRTAS,PINK,USCORE) ;\n        lstrnew(&data1,\" \") ;\n        fid = insfld(&data1,bt+3,bl+43,PRTAS,PINK,NONE) ;\n\n\n        /* *** list box *** */\n        /* top */\n        lstrnew(&data1,\n          \"\\x64\\x48\"\"List\"\"\\x48\"\"Box\"\"\\x48\\x48\\x48\\x48\\x48\\x48\\x63\");\n        fid = insfld(&data1,bt+5,bl+5,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n\n        lstrnew(&data1,\"\\x43\") ;\n        fid = insfld(&data1,bt+6,bl+5,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n        lstrnew(&data1,\"Selection 1  \") ;\n        fid = insfld(&data1,bt+6,bl+7,UNPRT,CYAN,NONE) ;\n        lstrnew(&data1,\"\\xdc\") ;\n        fid = insfld(&data1,bt+6,bl+21,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n\n        lstrnew(&data1,\"\\x43\") ;\n        fid = insfld(&data1,bt+7,bl+5,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n        lstrnew(&data1,\"Selection 2  \") ;\n        fid = insfld(&data1,bt+7,bl+7,UNPRT,CYAN,NONE) ;\n        lstrnew(&data1,\"\\xed\") ;\n        fid = insfld(&data1,bt+7,bl+21,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n\n        lstrnew(&data1,\"\\x43\") ;\n        fid = insfld(&data1,bt+8,bl+5,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n        lstrnew(&data1,\"Selection 3  \") ;\n        fid = insfld(&data1,bt+8,bl+7,UNPRT,CYAN,NONE) ;\n        lstrnew(&data1,\"\\xdb\") ;\n        fid = insfld(&data1,bt+8,bl+21,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n\n        lstrnew(&data1,\"\\x43\") ;\n        fid = insfld(&data1,bt+9,bl+5,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n        lstrnew(&data1,\"Selection 4  \") ;\n        fid = insfld(&data1,bt+9,bl+7,UNPRT,CYAN,RVIDEO) ;\n        lstrnew(&data1,\"\\xda\") ;\n        fid = insfld(&data1,bt+9,bl+21,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n\n        lstrnew(&data1,\"\\x43\") ;\n        fid = insfld(&data1,bt+10,bl+5,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n        lstrnew(&data1,\"Selection 5  \") ;\n        fid = insfld(&data1,bt+10,bl+7,UNPRT,CYAN,NONE) ;\n        lstrnew(&data1,\"\\xda\") ;\n        fid = insfld(&data1,bt+10,bl+21,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n\n        lstrnew(&data1,\"\\x43\") ;\n        fid = insfld(&data1,bt+11,bl+5,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n        lstrnew(&data1,\"Selection 6  \") ;\n        fid = insfld(&data1,bt+11,bl+7,UNPRT,CYAN,NONE) ;\n        lstrnew(&data1,\"\\xda\") ;\n        fid = insfld(&data1,bt+11,bl+21,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n\n        lstrnew(&data1,\"\\x43\") ;\n        fid = insfld(&data1,bt+12,bl+5,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n        lstrnew(&data1,\"Selection 7  \") ;\n        fid = insfld(&data1,bt+12,bl+7,UNPRT,CYAN,NONE) ;\n        lstrnew(&data1,\"\\xee\") ;\n        fid = insfld(&data1,bt+12,bl+21,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n\n        lstrnew(&data1,\"\\x43\") ;\n        fid = insfld(&data1,bt+13,bl+5,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n        lstrnew(&data1,\"Selection 8  \") ;\n        fid = insfld(&data1,bt+13,bl+7,UNPRT,CYAN,NONE) ;\n        lstrnew(&data1,\"\\xdd\") ;\n        fid = insfld(&data1,bt+13,bl+21,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n\n        /* bottom */\n        lstrnew(&data1,\n          \"\\xcd\\xeb\\x58\\x65\\x65\\x65\\x65\\x65\\x65\\x65\\x65\"\n          \"\\x65\\x65\\x65\\xec\\xcf\\xea\");\n        fid = insfld(&data1,bt+14,bl+5,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n\n      }\n    else if (sdcb.aplflg)\n      {\n        /* title static label */\n        lstrnew(&data1,\"APL Symbol Device Style\") ;\n        fid = insfld(&data1,bt+3,bl+15,PRTAS,PINK,USCORE) ;\n        lstrnew(&data1,\" \") ;\n        fid = insfld(&data1,bt+3,bl+39,PRTAS,PINK,NONE) ;\n\n\n\n      }\n    else\n      {\n        /* title static label */\n        lstrnew(&data1,\"Primitive Device Style\") ;\n        fid = insfld(&data1,bt+3,bl+15,PRTHIAS,PINK,USCORE) ;\n        lstrnew(&data1,\" \") ;\n        fid = insfld(&data1,bt+3,bl+38,PRTAS,PINK,NONE) ;\n\n\n      }\n  }\n\n\n/*-------------------------------------------------------------------*/\n/* Display the window and process the keys/commands entered.         */\n/*-------------------------------------------------------------------*/\nvoid dispwin()\n  {\n    TLSTR temp  ;        /* temp varying length string */\n    TLSTR command ;      /* command name varying length string */\n    char key ;           /* AID for the key just pressed */\n\n    lstrnew(&command,\" \") ;\n    while(lstrcmpc(&command,\"end\") != 0)\n      {\n        if (cmdflg)\n          {\n            /* set initial cursor row and col to the command field */\n            currow = bt + 1 ;\n            curcol = bl + 16 ;\n            /* blank out the command line */\n            lstrnew(&command,\" \") ;\n            modfld(cmdfid,&command) ;\n            cmdflg = 0 ;\n          }\n        key = dspflds() ;     /* display the screen and get aid=key */\n        lstrnew(&temp,\" \") ;\n        modfld(msgfid,&temp) ;    /* blank message line */\n        getfld(cmdfid,&command) ;  /* get the command line */\n\n        /* Process function keys PFKs */\n        switch (key)\n          {\n            case ENTER:\n              if (currow == bt) /* window border accelerators */\n                {\n                  if (curcol == (bl+2))  /* close window */\n                    {\n                      lstrnew(&command,\"end\") ;\n                    }\n                  else if (curcol == (br-2))  /* minimise window */\n                    {\n                      bt = 1 ;\n                      bl = 1 ;\n                      br = 48 ;\n                      bb = 20 ;\n                      remflds() ;\n                      buildwin() ;  /* re-build the display window */\n                      winmsg(\"Window minimised.\") ;\n                    }\n                  else if (curcol == (br-1))  /* maximise window */\n                    {\n                      bt = 1 ;\n                      bl = 1 ;\n                      br = sdcb.cols ;\n                      bb = sdcb.rows ;\n                      remflds() ;\n                      buildwin() ;  /* re-build the display window */\n                      winmsg(\"Window maximised.\") ;\n                    }\n                }\n              break ;\n            case PF1:    /* No help message */\n              winmsg(\n                \"Move border: PF23=Top PF11=Bottom PF10=Left PF12=Right\"\n                ) ;\n              break ;\n            case PF3:    /* Generate end command */\n            case PF15:   /* Alternate generate end command */\n              lstrnew(&command,\"end\") ;\n              break ;\n\n            case PF10:   /* move left border */\n              if ((curcol<(br-48)) &&\n                  (curcol>=1) )\n                {\n                  bl = curcol-1 ; /* adjust for attr byte */\n                  remflds() ;\n                  buildwin() ;  /* re-build the display window */\n                }\n              else\n                winmsg(\"Left border move position too far.\") ;\n              break ;\n\n            case PF11:   /* move bottom border */\n              if ((currow>(bt+20)) &&\n                  (currow<=sdcb.rows) )\n                {\n                  bb = currow ;\n                  remflds() ;\n                  buildwin() ;  /* re-build the display window */\n                }\n              else\n                winmsg(\"Bottom border move position too far.\") ;\n              break ;\n\n            case PF12:   /* move right border */\n              if ((curcol>(bl+48)) &&\n                 (curcol<=sdcb.cols) )\n                {\n                  br = curcol-1 ;  /* adjust for attr byte */\n                  remflds() ;\n                  buildwin() ;  /* re-build the display window */\n                }\n              else\n                winmsg(\"Right border move position too far.\") ;\n              break ;\n\n            case PF23:   /* move top border */\n              if ((currow<(bb-20)) &&\n                  (currow>=1) )\n                {\n                  bt = currow ;\n                  remflds() ;\n                  buildwin() ;  /* re-build the display window */\n                }\n              else\n                winmsg(\"Top border move position too far.\") ;\n              break ;\n\n            case PF24:   /* zoom to max window size */\n              bt = 1 ;\n              bl = 1 ;\n              br = sdcb.cols ;\n              bb = sdcb.rows ;\n              remflds() ;\n              buildwin() ;  /* re-build the display window */\n              break ;\n\n            case PA2:    /* reshow key does nothing - yet */\n              break ;\n\n            default:     /* any other key is not valid */\n              bellflg = 1 ;  /* sound alarm */\n              winmsg(\"Invalid function key.\") ;\n              break ;\n          }\n\n        /* Process command from the command line */\n        if (lstrcmpc(&command,\"test\") == 0)   /* test command */\n          {\n            winmsg(\"The test command was entered.\") ;\n            cmdflg = 1 ;  /* reset command line */\n          }\n        else if (lstrcmpc(&command,\"dump\") == 0)  /* dump command */\n          {\n            dumpfld() ;\n            winmsg(\"Dump command executed.\") ;\n            cmdflg = 1 ;  /* reset command line */\n          }\n        else if (lstrcmpc(&command,\"load\") == 0)  /* force load PS */\n          {\n            loadps1() ;\n            winmsg(\"Load PS type 1 command executed.\") ;\n            cmdflg = 1 ;  /* reset command line */\n          }\n        else if (lstrcmpc(&command,\"termstat\") == 0) /*dump term data*/\n          {\n            termstat() ;\n            winmsg(\"Terminal status printed.\") ;\n            cmdflg = 1 ;  /* reset command line */\n          }\n        else if (lstrcmpc(&command,\"traceon\") == 0) /* trace on */\n          {\n            iotrace = 1 ;\n            winmsg(\"Trace is on.\") ;\n            cmdflg = 1 ;  /* reset command line */\n          }\n        else if (lstrcmpc(&command,\"traceoff\") == 0) /* trace off */\n          {\n            iotrace = 0 ;\n            winmsg(\"Trace is off.\") ;\n            cmdflg = 1 ;  /* reset command line */\n          }\n\n      }   /* of while command not end */\n    clear() ;   /* clear the 3270 screen */\n  }\n\n\n/*-------------------------------------------------------------------*/\n/* Display the window and process the keys/commands entered.         */\n/*-------------------------------------------------------------------*/\nvoid winmsg(char *msg)\n  {\n    TLSTR msgstr  ;     /* message varying length string */\n\n    lstrnew(&msgstr,msg) ;\n    modfld(msgfid,&msgstr) ;\n  }\n\n/*********************************************************************/\n/* 3270 field handling routines                                      */\n/*   rc = initscr()                                                  */\n/*   termscr()                                                       */\n/*   fid = insfld(data,row,col,attr,color,hilite)                    */\n/*   rc = remflds()                                                  */\n/*   rc = delfld(fid)                                                */\n/*   rc = erasefld(fid)                                              */\n/*   rc = getfld(fid,returndata)                                     */\n/*   rc = modfld(fid,newdata)                                        */\n/*   rc = setfld(fid,attrtype,attrvalue)                             */\n/*   dumpflds()                                                      */\n/*                                                                   */\n/*********************************************************************/\n\n\n/*-------------------------------------------------------------------*/\n/* Set up the screen environment.                                    */\n/*-------------------------------------------------------------------*/\nint initscr()\n{\n    int rc = 0 ;\n\n    buffer = (char *)malloc(BUFFMAX) ;  /* alloc tput/get buffer */\n    if (buffer)\n      {\n        rc = getdev() ;  /* get3270 device information */\n        if (rc==0 && sdcb.loadflg==1)\n          loadps1() ;\n      }\n    else\n      rc = 1 ;   /* could not get buffer */\n\n    return rc ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Terminate screen environment.                                     */\n/*-------------------------------------------------------------------*/\nvoid termscr()\n{\n    if (screen)\n      remflds() ;       /* remove any remaining fields */\n\n    free((char *)buffer) ;  /* remove tput/get buffer */\n}\n\n/*-------------------------------------------------------------------*/\n/* Display current contents of the 3270 field list.                  */\n/*-------------------------------------------------------------------*/\nchar dspflds()\n{\n  TSFLD *curr ;\n  int rc, bufpos, trow = 0, tcol = 0, fstart, fend, ilen ;\n  char sba\u00dd2\u00a8 ;\n  char aid ;\n\n  /* assemble buffer, it will contain: (EW WCC) followed by all  */\n  /* the display fields. Each field will contain:                */\n  /*   (SFE 0x03 0xC0 fattr HILITE fhilite COLOR fcolor data)    */\n  if (sdcb.altflg)\n    buffer\u00dd0\u00a8 = EWA ;     /* erase write alternate */\n  else\n    buffer\u00dd0\u00a8 = EW ;      /* erase write */\n\n  /* determine if the bell should be rung */\n  if (bellflg)\n    {\n      buffer\u00dd1\u00a8 = WCCRES | WCCKBD | WCCMDT | WCCBEL ;\n      bellflg = 0 ;  /* turn bell flag off, one ring only */\n    }\n  else\n    buffer\u00dd1\u00a8 = WCCRES | WCCKBD | WCCMDT ;\n\n  bufpos = 2 ;\n  curr = screen ;     /* first node in field list */\n  while (curr)\n    {\n      buffer\u00ddbufpos++\u00a8 = SBA ;  /* set buffer address */\n      rc2sba(curr->fypos,curr->fxpos,sba) ;\n      buffer\u00ddbufpos++\u00a8 = sba\u00dd0\u00a8 ;\n      buffer\u00ddbufpos++\u00a8 = sba\u00dd1\u00a8 ;\n      if (sdcb.edsflg)\n        {\n          buffer\u00ddbufpos++\u00a8 = SFE ;  /* start field extended */\n          buffer\u00ddbufpos++\u00a8 = 0x03 ;\n          buffer\u00ddbufpos++\u00a8 = 0xc0 ;\n          buffer\u00ddbufpos++\u00a8 = curr->fattr ;\n          buffer\u00ddbufpos++\u00a8 = HILITE ;\n          buffer\u00ddbufpos++\u00a8 = curr->fhilite ;\n          buffer\u00ddbufpos++\u00a8 = COLOR ;\n          buffer\u00ddbufpos++\u00a8 = curr->fcolor ;\n\n          /* insert set character attribute before data if APL/PS syms*/\n          /* are required and the field has protection turned on.     */\n          if (((curr->symbol==APL) || (curr->symbol==0x40)) /*APL/PS*/\n            && (curr->fattr & 0x40)) /* and protected field */\n            {\n              buffer\u00ddbufpos++\u00a8 = SA ;           /* set attribute */\n              buffer\u00ddbufpos++\u00a8 = SYMSET ;       /* symbol */\n              if (curr->symbol==APL) /* APL ? */\n                buffer\u00ddbufpos++\u00a8 = sdcb.aplflg ; /* use APL's lcid */\n              else\n                buffer\u00ddbufpos++\u00a8 = curr->symbol ; /* use symbol value */\n            }\n        }\n      else    /* dont used extended data stream */\n        {\n          buffer\u00ddbufpos++\u00a8 = SF ;  /* start field */\n          buffer\u00ddbufpos++\u00a8 = curr->fattr ;\n        }\n\n      /* insert field data */\n      ilen = lstrunld(&buffer\u00ddbufpos\u00a8,&curr->fdata) ;\n      bufpos = bufpos + ilen ;\n\n      /* revert to standard symbols after APL/PS data symbols  */\n      if (((curr->symbol==APL) || (curr->symbol==0x40)) /*APL/PS*/\n        && (curr->fattr & 0x40)) /* and protected field */\n        {\n          buffer\u00ddbufpos++\u00a8 = SA ;       /* set attribute */\n          buffer\u00ddbufpos++\u00a8 = SYMSET ;   /* symbol */\n          buffer\u00ddbufpos++\u00a8 = DFLT ;     /* revert to default symbols */\n        }\n\n      curr = curr->next ;  /* go to next field */\n    }\n\n  /* insert the cursor in the same location the user left it */\n  buffer\u00ddbufpos++\u00a8 = SBA ;     /* add set buffer address order */\n  rc2sba(currow,curcol,sba) ;  /* determine SBA for current row/col */\n  buffer\u00ddbufpos++\u00a8 = sba\u00dd0\u00a8 ;  /* add buffer addr part 1 */\n  buffer\u00ddbufpos++\u00a8 = sba\u00dd1\u00a8 ;  /* add buffer addr part 2 */\n  buffer\u00ddbufpos++\u00a8 = ICUR ;    /* add insert cursor order */\n\n  /* dumpchar(buffer,bufpos) ; */\n\n  /* write buffer to the 3270 */\n  rc = tputn(buffer, bufpos) ;\n\n  fill(buffer,0x00,bufpos) ;\n  /* receive the response from the user */\n  rc = tgetn(buffer, BUFFMAX ) ;\n\n  /* decode input, should be an AID, a cursor pos bufferaddr */\n  /* and a list of fields (SBA addr1 addr2 data)             */\n\n  aid = buffer\u00dd0\u00a8 ;      /* get code of key that was pressed */\n  sba\u00dd0\u00a8 = buffer\u00dd1\u00a8 ;\n  sba\u00dd1\u00a8 = buffer\u00dd2\u00a8 ;\n  sba2rc(sba,&currow,&curcol,0) ;  /* convert and store cursor pos */\n                                   /* adjust = 0 used for cursor pos */\n\n  curr = screen ;\n  fstart = 0 ;\n  bufpos = 3 ;\n  while(bufpos<=BUFFMAX)\n    {\n      if (buffer\u00ddbufpos\u00a8==SBA)\n        {\n          /* get new buffer address */\n          bufpos++ ;\n          sba\u00dd0\u00a8 = buffer\u00ddbufpos++\u00a8 ;\n          sba\u00dd1\u00a8 = buffer\u00ddbufpos++\u00a8 ;\n          sba2rc(sba,&trow,&tcol,1) ; /* convert buf.addr to row/col */\n                              /* adjust = 1 used for retn. buf. addr */\n          fstart = bufpos ;\n\n          /* locate field by r/c then write data to field list entry */\n          while( !((curr->fxpos==tcol) && (curr->fypos==trow)) )\n            {                          /* locate */\n              curr = curr->next ;\n              if (!curr) break ; /* could not locate - real bad */\n            }\n\n          if (curr)    /* found field - copy the data into it */\n            {\n              /* first locate end of data */\n              fend = fstart ;\n              while ((buffer\u00ddfend\u00a8 != SBA) &&\n                     (buffer\u00ddfend\u00a8 != 0x00))\n                fend++ ;  /* leaves fend pointing at next char. */\n\n              /* copy data from buffer into field list */\n              ilen = fend - fstart ;\n              lstrload(&curr->fdata,&buffer\u00ddfstart\u00a8,ilen) ;\n\n              /* adjust bufpos to last char of this returned SBA */\n              bufpos = fend -1 ;\n            }\n          else\n            {\n              /* SEVERE ERROR: This should never happen */\n              printf(\"No locate field: row %d col %d SBA %.2X %.2X\\n\",\n                trow,tcol,sba\u00dd0\u00a8,sba\u00dd1\u00a8) ;\n              curr = screen ;  /* further searches from top */\n            }\n        }\n      else\n        bufpos++ ;   /* advance to next char */\n    }\n\n  return aid ;    /* data returned OK */\n}\n\n\n/*-------------------------------------------------------------------*/\n/* Dump field list to stdout.                                        */\n/*-------------------------------------------------------------------*/\nvoid dumpfld()\n{\n  TSFLD *curr ;\n  int i = 0, size = 0 ;\n  char sba\u00dd2\u00a8 ;\n\n  printf(\"Field list follows:\\n\") ;\n  curr = screen ;     /* first node in field list */\n  while (curr)\n    {\n      printf(\"  Field at row %d col %d\\n\",curr->fypos,curr->fxpos) ;\n      rc2sba(curr->fypos,curr->fxpos,sba) ;\n      printf(\"    BufAddr: %.2X %.2X \",sba\u00dd0\u00a8,sba\u00dd1\u00a8) ;\n      printf(\"Attrib: %.2X \",curr->fattr) ;\n      printf(\"Hilite: %.2X \",curr->fhilite) ;\n      printf(\"Color: %.2X \",curr->fcolor) ;\n      printf(\"Symbol: %.2X \",curr->symbol) ;\n      printf(\"DataLen: %d\\n\",curr->fdata.len) ;\n      printf(\"    Data dump: \\n\") ;\n      dumpchar(curr->fdata.data,curr->fdata.len) ;\n      size = size + curr->fdata.len  + 11 ;\n      i++ ;\n      curr = curr->next ;\n    }\n  printf(\"Total fields %d, buffer size required %d\\n\",i,size) ;\n}\n\n\n/*-------------------------------------------------------------------*/\n/* Print terminal status.                                            */\n/*-------------------------------------------------------------------*/\nvoid termstat()\n{\n  printf(\"Terminal status follows:\\n\") ;\n  printf(\"  Device name.........: %s\\n\",sdcb.modname) ;\n  printf(\"  Device model........: %d\\n\",sdcb.model) ;\n  printf(\"  Device type.........: %d\\n\",sdcb.type) ;\n  printf(\"  Addressing mode.....: %d\\n\",sdcb.adrmode) ;\n  printf(\"  Maximum rows........: %d\\n\",sdcb.rows) ;\n  printf(\"  Maximum columns.....: %d\\n\",sdcb.cols) ;\n  printf(\"  Cell height.........: %d\\n\",sdcb.celheigh) ;\n  printf(\"  Cell width..........: %d\\n\",sdcb.celwidth) ;\n  printf(\"  Supported colors....: %d\\n\",sdcb.colors) ;\n  printf(\"  Actual colors.......: %d\\n\",sdcb.colora) ;\n  printf(\"  Color attr list.....: %.32X\\n\",sdcb.colorlst) ;\n  printf(\"  Number of Highlights: %d\\n\",sdcb.hilites) ;\n  printf(\"  Highlight attr list.: %.8X\\n\",sdcb.hilitlst) ;\n  if (sdcb.unit)\n    printf(\"  Unit................: mm\\n\") ;\n  else\n    printf(\"  Unit................: inch\\n\") ;\n  printf(\"  Alternate device....: %d\\n\",sdcb.altflg) ;\n  printf(\"  APL symbol set......: %.2X\\n\",sdcb.aplflg) ;\n  printf(\"  Extended data stream: %d\\n\",sdcb.edsflg) ;\n  printf(\"  Loadable symbols....: %d\\n\",sdcb.loadflg) ;\n  printf(\"  Load PS extended....: %d\\n\",sdcb.psflg) ;\n  printf(\"  Triple plane symbols: %d\\n\",sdcb.triflg) ;\n  printf(\"  Double byte symbols.: %d\\n\",sdcb.dbcsflg) ;\n  printf(\"  Vector graphic......: %d\\n\",sdcb.graflg) ;\n}\n\n\n/*-------------------------------------------------------------------*/\n/* Add a field to the 3270 field list.                               */\n/*-------------------------------------------------------------------*/\nint insfld(TLSTR *flddata,       /* the data */\n            int ypos,            /* display at row */\n            int xpos,            /* display at column */\n            char attr,           /* field attribute PRT, UNPRT ...*/\n            char color,          /* field color RED, BLUE, ...*/\n            char hilite )        /* field hilite BLINK, RVIDEO,...*/\n{\n  int rc ;\n  TSFLD *newfld, *last, *top ;\n\n  /* get storage for new nodes */\n  newfld = (TSFLD *)malloc(sizeof(TSFLD)) ;\n  if (!newfld) serror(20,\"Not enough memory\") ;\n  memset(newfld,0x00,sizeof(TSFLD)) ;\n\n  /* verify contents of all parameters */\n  if ((flddata->len > 0) &&\n    (flddata->len <= (sdcb.rows * sdcb.cols)))\n    lstrcopy(&newfld->fdata,flddata) ;\n  else\n    return -1 ;\n\n  if ((xpos > 0) &&\n    (xpos < sdcb.cols))\n    newfld->fxpos = xpos ;\n  else\n    return -2 ;\n\n  if ((ypos > 0) &&\n    (ypos <= sdcb.rows))\n    newfld->fypos = ypos ;\n  else\n    return -3 ;\n\n  rc = modattr(&newfld->fattr,attr) ;\n  if (rc) return -4 ;\n\n  rc = modcolor(&newfld->fcolor,color) ;\n  if (rc) return -5 ;\n\n  rc = modhilite(&newfld->fhilite,hilite) ;\n  if (rc) return -6 ;\n\n  /* insert the field into the field list in order of buffer offset */\n  top = screen ;\n  if (!top)   /* first entry in the list (screen->00) */\n    {\n      newfld->next = NULL ;\n      screen = newfld ;\n    }\n  else\n    {\n      last = NULL ;  /* last node examined */\n      while(top)    /* loop through fields for insert place */\n        {\n          if ((top->fxpos+top->fypos*sdcb.cols) <\n            (newfld->fxpos+newfld->fypos*sdcb.cols)) /* rel.buff.pos */\n            {    /* chain to next node */\n              last = top ;\n              top = top->next ;\n            }\n          else\n            {\n              if (last)  /* insert the new node, in middle of list */\n                {\n                  last->next = newfld ;\n                  newfld->next = top ;\n                }\n              else   /* insert new first node in list */\n                {\n                  newfld->next = top ;\n                  screen = newfld ;\n                }\n              break ;   /* exit loop */\n            }\n        }\n      if (!newfld->next)  /* stil not inserted? - add to end */\n        last->next = newfld ;\n    }\n\n  /* update field id table and field id in field struct */\n  newfld->fid = fidnext ;\n  sfidtab\u00ddfidnext\u00a8 = newfld ;\n  rc = fidnext++ ;\n  return rc ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Remove all fields defined from the 3270 field list.               */\n/*-------------------------------------------------------------------*/\nint remflds()\n{\n  int i ;\n  TSFLD *curr, *top ;\n\n  for (i=0; i<SFIDMAX; i++)  /* empty fid table */\n    sfidtab\u00ddi\u00a8 = NULL ;\n  fidnext = 0 ;              /* reset next fid */\n\n  top = screen ;             /* free field list */\n  while(top)\n    {\n      curr = top ;\n      top = top->next ;\n      free((char *)curr->fdata.data) ;\n      free((TSFLD *)curr) ;\n    }\n  screen = NULL ;\n  return 0 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Delete a field from the 3270 field list.                          */\n/*-------------------------------------------------------------------*/\nint delfld(int id)\n{\n    TSFLD *curr, *top, *last ;\n\n    if ((id < SFIDMAX) && (id >= 0))\n      {\n        curr = sfidtab\u00ddid\u00a8 ;\n        if (curr)\n          {\n            top = screen ;\n            last = NULL ;\n            while (top)\n              {\n                if (top == curr)\n                  {\n                    if (!last)   /* ? found node at top */\n                      screen = top->next ;\n                    else if (!top->next)  /* ? last node */\n                      last->next = NULL ;\n                    else           /* in middle of list */\n                      last->next = top->next ;\n                    /* delete the node */\n                    free((char *)top->fdata.data) ;\n                    free((TSFLD *)top) ;\n                    sfidtab\u00ddid\u00a8 = NULL ; /* invalidate id */\n                    return 0 ;  /* field id removed OK */\n                  }\n                last = top ;  /* remember last node */\n                top = top->next ;   /* chain to next node */\n              }    /* of while top */\n          }\n        else return 1 ;     /* invalid id */\n      }\n    else return 2 ;    /* out of range id */\n    return 3 ;     /* idtab list mismatch */\n}\n\n/*-------------------------------------------------------------------*/\n/* Erase the contents of a field in the 3270 field list.             */\n/*-------------------------------------------------------------------*/\nint erasefld(int id)\n{\n  TSFLD *curr ;\n\n  if ((id < SFIDMAX) && (id >= 0))\n    {\n      curr = sfidtab\u00ddid\u00a8 ;\n      if (curr)\n        lstrfill(&curr->fdata,\"\\0\") ; /* fill with zeros */\n      else\n        return 1 ;     /* invalid id */\n    }\n  else\n    return 2 ;    /* out of range id */\n\n  return 0 ;    /* id erased OK */\n}\n\n/*-------------------------------------------------------------------*/\n/* Get the current contents of a field in the 3270 field list.       */\n/*-------------------------------------------------------------------*/\nint getfld(int id,\n           TLSTR *retdata)\n{\n  TSFLD *curr ;\n\n  if ((id < SFIDMAX) && (id >= 0))\n    {\n      curr = sfidtab\u00ddid\u00a8 ;\n      if (curr)\n        lstrcopy(retdata,&curr->fdata) ; /* copy data */\n      else\n        return 1 ;     /* invalid id */\n    }\n  else\n    return 2 ;    /* out of range id */\n\n  return 0 ;    /* data returned OK */\n}\n\n/*-------------------------------------------------------------------*/\n/* Modify the contents of a field in the 3270 field list.            */\n/*-------------------------------------------------------------------*/\nint modfld(int id,\n           TLSTR *newdata)\n{\n  TSFLD *curr ;\n\n  if ((id < SFIDMAX) && (id >= 0))\n    {\n      curr = sfidtab\u00ddid\u00a8 ;\n      if (curr)\n        {\n          if ((newdata->len > 0) &&\n            (newdata->len <= (sdcb.rows * sdcb.cols)))\n            lstrcopy(&curr->fdata,newdata) ; /* alter field data*/\n          else\n            return 1 ;  /* data too large or 0 */\n        }\n      else\n        return 2 ;     /* invalid id */\n    }\n  else\n    return 3 ;    /* out of range id */\n\n  return 0 ;    /* data returned OK */\n}\n\n/*-------------------------------------------------------------------*/\n/* Change the attributes of a field in the 3270 field list.          */\n/*-------------------------------------------------------------------*/\nint setfld(int id,\n           int type,\n           char value)\n{\n  TSFLD *curr ;\n  int rc = 0 ;\n\n  if ((id < SFIDMAX) && (id >= 0))\n    {\n      curr = sfidtab\u00ddid\u00a8 ;\n      if (curr)\n        {\n          switch (type)\n            {\n            case ALL:\n              rc = modcolor(&curr->fcolor,DFLT) ;\n              rc = modhilite(&curr->fhilite,DFLT) ;\n              rc = modattr(&curr->fattr,DFLT) ;\n              break ;\n            case HILITE:\n              rc = modhilite(&curr->fhilite,value) ;\n              break ;\n            case COLOR:\n              rc = modcolor(&curr->fcolor,value) ;\n              break ;\n            case ATTR:\n              rc = modattr(&curr->fattr,value) ;\n              break ;\n            case SYMSET:\n              rc = modsym(&curr->symbol,value) ;\n              break ;\n            default:\n              return 1 ;    /* invalid type */\n            }\n        }\n      else\n        return 1 ;     /* invalid id */\n    }\n  else\n    return 2 ;    /* out of range id */\n\n  return rc ;   /* return */\n}\n\n\n\n/*********************************************************************/\n/* 3270 support routines                                             */\n/*   rc2sba(row,col,sba)                                             */\n/*   sba2rc(sba,row,col,adjust)                                      */\n/*   rc = modcolor(out,in)                                           */\n/*   rc = modhilit(out,in)                                           */\n/*   rc = modattr(out,in)                                            */\n/*   rc = tputn(buf,buflen)                                          */\n/*   rc = tgetn(buf,buflen)                                          */\n/*   rc = tpgn(buf,buflen)                                           */\n/*   rc = getdev()                                                   */\n/*   rc = getterm(primrow,primcol,altrow,altcol,attrs)               */\n/*   rc = querydev()                                                 */\n/*   rc = dsummary(buf,buflen)                                       */\n/*   rc = darea(buf,buflen)                                          */\n/*   rc = dcharset(buf,buflen)                                       */\n/*   rc = dcolor(buf,buflen)                                         */\n/*   rc = dhilite(buf,buflen)                                        */\n/*   rc = dmodes(buf,buflen)                                         */\n/*   rc = dimpart(buf,buflen)                                        */\n/*                                                                   */\n/*********************************************************************/\n\n/*-------------------------------------------------------------------*/\n/* The TPUTN routine is loaded below the 16M line                    */\n/* It issues the TPUT macro with the NOEDIT option                   */\n/*-------------------------------------------------------------------*/\nint tputn(char *buf, int buflen)\n  {\n    int rc = 0 ;\n    int (*tputn)(char *,int) ;\n\n    loadm(\"TPUTN\",&tputn) ;\n    if (iotrace)      /* trace terminal I/O ? */\n      {\n        printf(\"Outbound data stream:\\n\") ;\n        dumpchar(buf,buflen) ;\n      }\n    rc = (*tputn)(buf,buflen) ;\n    unloadm(tputn) ;\n    return rc ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* The TGETN routine is loaded below the 16M line                    */\n/* It issues the TGET macro with the FULLSCR option.                 */\n/*-------------------------------------------------------------------*/\nint tgetn(char *buf, int buflen)\n  {\n    int rc = 0 ;\n    int (*tgetn)(char *,int) ;\n\n    loadm(\"TGETN\",&tgetn) ;\n    rc = (*tgetn)(buf,buflen) ;\n    if (iotrace)      /* trace terminal I/O ? */\n      {\n        printf(\"Inbound data stream:\\n\") ;\n        dumpchar(buf,buflen) ;\n      }\n    unloadm(tgetn) ;\n    return rc ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* The TPGN routine is loaded below the 16M line                     */\n/* It issues the TPG macro with the NOEDIT option.                   */\n/*-------------------------------------------------------------------*/\nint tpgn(char *buf, int buflen)\n  {\n    int rc = 0 ;\n    int (*tpgn)(char *,int) ;\n\n    loadm(\"TPGN\",&tpgn) ;\n    if (iotrace)      /* trace terminal I/O ? */\n      {\n        printf(\"Outbound data stream:\\n\") ;\n        dumpchar(buf,buflen) ;\n      }\n    rc = (*tpgn)(buf,buflen) ;\n    unloadm(tpgn) ;\n    return rc ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* Convert row/column to 3270 12/16 bit buffer address.              */\n/*-------------------------------------------------------------------*/\nvoid rc2sba(int row,\n            int col,\n            char *sba)\n{\n  int offset, byte1, byte2 ;\n\n  offset = ((row-1)*sdcb.cols)+(col-1) ;\n  if (sdcb.adrmode == 12)  /* addressing mode = 12 */\n    {\n      byte1 = offset >> 6 ;           /* extract high order bits */\n      byte1 = byte1 | 0x000000c0 ;    /* turn on 12 bit ind */\n\n      byte2 = offset & 0x0000003f ;   /* extract low order 6 bits */\n      byte2 = byte2 | 0x000000c0 ;    /* turn on 12 bit ind */\n\n      sba\u00dd0\u00a8 = *((char *)&byte1+3) ;  /* assemble 2 byte sba */\n      sba\u00dd1\u00a8 = *((char *)&byte2+3) ;\n    }\n  else /* adrmode = 16 or 14 */\n    {\n      byte1 = offset >> 8 ;           /* extract high order byte */\n      byte2 = offset & 0x00ff ;       /* extract low order byte */\n      sba\u00dd0\u00a8 = *((char *)&byte1+3) ;  /* assemble 2 byte sba */\n      sba\u00dd1\u00a8 = *((char *)&byte2+3) ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Convert 12/14/16-bit address to an offset and row/column.         */\n/*-------------------------------------------------------------------*/\nvoid sba2rc(char *inaddr,  /* input buffer addr */\n            int *row,      /* returned row */\n            int *col,      /* returned column */\n            int adjust)    /* amount to subtract - usuallu 0 for the */\n                           /*   returned cursor position, but is set */\n                           /*   to one to get correct returned buffer*/\n                           /*   addresses.                           */\n{\n  int taddr,     /* Temporary address holder */\n      offset ;\n  short addr ;\n  memcpy((char *)&addr,inaddr,sizeof(short)) ;\n\n  /* If 12-bit address, then we need to massage it a little */\n  if (addr & 0xc000)    /* 12-bit address ? */\n    {\n       addr &= 0x3f3f ;      /* turn off 2 hi bits in each byte */\n       taddr = addr >> 8 ;   /* taddr is first 6 bits */\n       addr &= 0x00ff ;      /* addr is second 6 bits */\n       taddr = taddr << 6 ;  /* shift taddr left and .. */\n       taddr |= addr ;       /*   merge taddr with addr into taddr */\n       offset = taddr ;      /* taddr is the offset into the buffer */\n    }\n  else\n    offset = addr ;          /* addr is the offset into the buffer */\n\n  offset = offset - adjust ; /* adjust is either 0 or 1 */\n\n  /* turn offset into row and column based on device num of columns */\n  *col = (offset % sdcb.cols) + 1 ;\n  *row = (offset / sdcb.cols) + 1 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Check color attribute and copy if valid.                          */\n/*-------------------------------------------------------------------*/\nint modsym(char *out,\n           char in )\n{\n  switch (in)\n    {\n    case DFLT:\n      *out = in ;\n      return 0 ;\n    case APL:\n      if (sdcb.aplflg)\n        {\n          *out = in ;\n          return 0 ;\n        }\n      else\n        return 1 ;\n    default:\n      if (sdcb.loadflg)\n        {\n          if ((in>=0x40) && (in<=0xef))\n            {\n              *out = in ;\n              return 0 ;\n            }\n          else\n            return 1 ;\n        }\n      else\n        return 1 ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Check color attribute and copy if valid.                          */\n/*-------------------------------------------------------------------*/\nint modcolor(char *out,\n             char in )\n{\n  switch (in)\n    {\n    case DFLT:\n    case BLUE:\n    case RED:\n    case PINK:\n    case GREEN:\n    case TURQ:\n    case YELLOW:\n    case WHITE:\n      *out = in ;\n      return 0 ;\n    default:\n      return 1 ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Check hilite attribute and copy if valid.                         */\n/*-------------------------------------------------------------------*/\nint modhilit(char *out,\n             char in )\n{\n  switch (in)\n    {\n    case NONE:\n    case BLINK:\n    case RVIDEO:\n    case USCORE:\n      *out = in ;\n      return 0 ;\n    default:\n      return 1 ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Check field attribute and copy if valid.                          */\n/*-------------------------------------------------------------------*/\nint modattr(char *out,\n            char in )\n{\n  switch (in)\n    {\n    case PRT:       /* protected normal intensity */\n    case PRTHI:     /* protected high intensity */\n    case PRTAS:     /* protected normal intensity auto skip */\n    case PRTHIAS:   /* protected high intensity auto skip */\n    case UNPRT:     /* unprotected normal intensity */\n    case UNNUM:     /* unprotected numeric normal intensity */\n    case UNNUMHI:   /* unprotected numeric high intensity */\n    case UNNON:     /* unprotected non display */\n    case UNHI:      /* unprotected high intensity */\n      *out = in ;\n      return 0 ;\n    default:\n      return 1 ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Load programmed symbols - type 1 load                             */\n/*   loads programmed symbols without compression                    */\n/*-------------------------------------------------------------------*/\nint loadps1()\n  {\n    int rc ;         /* return code */\n    int bufpos ;     /* next buffer position */\n    int i, j ;       /* counters */\n    short s ;        /* temp */\n\n    memset(buffer,0x00,BUFFMAX) ;  /* clear buffer */\n\n    bufpos = 0 ;\n    buffer\u00ddbufpos++\u00a8 = WSF ;   /* write structured field */\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;  /* structured field length */\n    buffer\u00ddbufpos++\u00a8 = 0x07 ;  /* structured field length contd. */\n    buffer\u00ddbufpos++\u00a8 = 0x06 ;  /* load PS structured field */\n    buffer\u00ddbufpos++\u00a8 = 0x41 ;  /* flags: clear sym.set and use type 1 */\n    buffer\u00ddbufpos++\u00a8 = 0xff ;  /* make associated RWS = not assigned */\n    buffer\u00ddbufpos++\u00a8 = 0x41 ;  /* starting code point */\n    buffer\u00ddbufpos++\u00a8 = 0x02 ;  /* RWS of PSA symbol set */\n\n    /* write buffer to the 3270 */\n    rc = tputn(buffer, bufpos) ;\n\n    memset(buffer,0x00, bufpos) ;  /* clear buffer */\n\n    bufpos = 0 ;\n    buffer\u00ddbufpos++\u00a8 = WSF ;   /* write structured field */\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;  /* structured field length */\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;  /* structured field length contd. */\n    buffer\u00ddbufpos++\u00a8 = 0x06 ;  /* load PS structured field */\n    buffer\u00ddbufpos++\u00a8 = 0x01 ;  /* flags: use type 1 */\n    buffer\u00ddbufpos++\u00a8 = 0x40 ;  /* make associated RWS = 0x40 */\n    buffer\u00ddbufpos++\u00a8 = 0x41 ;  /* starting code point (symbol=65) */\n    buffer\u00ddbufpos++\u00a8 = 0x02 ;  /* RWS of PSA symbol set */\n\n /* This extra stuff needs the flags bit 1 on to indicate extended\n    I dont think I need to use it yet.\n\n    buffer\u00ddbufpos++\u00a8 = 0x08 ;     P length - length of extra parms\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     flags: operator selectable ...\n    buffer\u00ddbufpos++\u00a8 = 0x09 ;     LW - width of character\n    buffer\u00ddbufpos++\u00a8 = 0x10 ;     LH - width of character\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     SUBSN - only one byte codes\n    buffer\u00ddbufpos++\u00a8 = 0xf1 ;     COLOR - F1 - first attr ???\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     ST.SUBSN - default\n    buffer\u00ddbufpos++\u00a8 = 0xf9 ;     ECHAR - last symbol=249\n\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     NW - number width pairs\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     NH - number height pairs\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     RES - reserved\n */\n\n    /* load specific font based on the cell height */\n    if (sdcb.celheigh >= 16)\n      {\n        for (i=65;i<=249;i++)   /* for each symbol, 0x41 to 0xF9 */\n          {\n            for (j=0;j<=17;j++)      /* for each slice  */\n              {\n                buffer\u00ddbufpos++\u00a8 = ps9x16u\u00ddi\u00a8\u00ddj\u00a8 ;\n              }\n          }\n      }\n    else if (sdcb.celheigh == 15)\n      {\n        for (i=65;i<=249;i++)   /* for each symbol, 0x41 to 0xF9 */\n          {\n            for (j=0;j<=17;j++)      /* for each slice  */\n              {\n                buffer\u00ddbufpos++\u00a8 = ps9x15u\u00ddi\u00a8\u00ddj\u00a8 ;\n              }\n          }\n      }\n    else\n      {\n        for (i=65;i<=249;i++)   /* for each symbol, 0x41 to 0xF9 */\n          {\n            for (j=0;j<=17;j++)      /* for each slice  */\n              {\n                buffer\u00ddbufpos++\u00a8 = ps9x12u\u00ddi\u00a8\u00ddj\u00a8 ;\n              }\n          }\n      }\n\n    s = bufpos - 1 ;\n    memcpy(buffer+1,&s,sizeof(short)) ;\n\n    /* write buffer to the 3270 to load the programmed symbols */\n    rc = tputn(buffer, bufpos) ;\n\n    memset(buffer,0x00,BUFFMAX) ;  /* clear buffer */\n    return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* Get the display device attributes.                                */\n/*-------------------------------------------------------------------*/\nint getdev()\n  {\n    int rc, pr = 0, pc = 0, ar = 0, ac = 0, att = 0 ;\n    int i ;\n\n    /* set the default values, may get over ridden later */\n    sdcb.adrmode = 12 ;  /* addressing mode */\n    sdcb.altflg = 0 ;    /* use primary device */\n    sdcb.edsflg = 0 ;    /* no extended data stream */\n    sdcb.graflg = 0 ;    /* not a graphics device */\n    sdcb.aplflg = 0 ;    /* no apl symbols on device */\n    sdcb.psflg = 0 ;     /* no program symbols on device */\n    sdcb.loadflg = 0 ;   /* no loadable symbols sets on device */\n    sdcb.triflg = 0 ;    /* no triple plane symbols sets on device */\n    sdcb.dbcsflg = 0 ;   /* no double byte symbols on device */\n    sdcb.celheigh = 0 ;  /* zero cell height on device */\n    sdcb.celwidth = 0 ;  /* zero cell width on device */\n    sdcb.unit = 0 ;      /* units are inches */\n    sdcb.colora = 1 ;    /* actual colors default to monochrome */\n    sdcb.colors = 1 ;    /* supported colors default to monochrome */\n    sdcb.hilites = 0 ;   /* supported hilites default to none */\n    for (i=0;i<17;i++)\n      sdcb.colorlst\u00ddi\u00a8 = 0x00 ; /* list of color attributes on device*/\n    for (i=0;i<5;i++)\n      sdcb.hilitlst\u00ddi\u00a8 = 0x00 ; /* list of hilite attributes on device*/\n\n\n    /* get info from TSO about this device */\n    rc = getterm(&pr,&pc,&ar,&ac,&att) ;\n    if (rc==0)                 /* get terminal info worked ? */\n      {\n        if (att==0x00000001)   /* device has query structured fields */\n          {\n            /* set row and col may be later reset by query dev */\n            if ((ar>0) && (ar!=pr) &&\n                (ac>0) && (ac!=pc))\n              {\n                sdcb.altflg = 1 ;    /* use alternate device */\n                sdcb.rows = ar ;     /* use alternate rows */\n                sdcb.cols = ac ;     /* use alternate cols */\n              }\n            else\n              {\n                sdcb.rows = pr ;     /* use primary rows */\n                sdcb.cols = pc ;     /* use primary cols */\n              }\n\n            rc = querydev() ;\n            /* try to determine actual device */\n            if (sdcb.rows == 32)\n              {\n                strcpy(sdcb.modname,\"IBM3279-3\") ;\n                sdcb.model = 3279 ;\n                sdcb.type = 3 ;\n              }\n            else if (sdcb.rows == 43)\n              {\n                strcpy(sdcb.modname,\"IBM3278-4\") ;\n                sdcb.model = 3278 ;\n                sdcb.type = 4 ;\n              }\n            else if (sdcb.rows == 27)\n              {\n                strcpy(sdcb.modname,\"IBM3290\") ;\n                sdcb.model = 3290 ;\n                sdcb.type = 5 ;\n              }\n            else  /* cant tell - use most primitive */\n              {\n                strcpy(sdcb.modname,\"IBM3278-2\") ;\n                sdcb.model = 3278 ;\n                sdcb.type = 2 ;\n              }\n          }\n        else  /* dont know a lot about the device - make some guesses */\n          {\n            if ((ar>0) && (ar!=pr) &&\n                (ac>0) && (ac!=pc))\n              {\n                sdcb.altflg = 1 ;    /* use alternate device */\n                sdcb.rows = ar ;     /* use alternate rows */\n                sdcb.cols = ac ;     /* use alternate cols */\n              }\n            else\n              {\n                sdcb.rows = pr ;     /* use primary rows */\n                sdcb.cols = pc ;     /* use primary cols */\n              }\n\n            /* try to determine actual device */\n            if (sdcb.rows == 32)\n              {\n                strcpy(sdcb.modname,\"IBM3279-3\") ;\n                sdcb.model = 3279 ;\n                sdcb.type = 3 ;\n              }\n            else if (sdcb.rows == 43)\n              {\n                strcpy(sdcb.modname,\"IBM3278-4\") ;\n                sdcb.model = 3278 ;\n                sdcb.type = 4 ;\n              }\n            else if (sdcb.rows == 27)\n              {\n                strcpy(sdcb.modname,\"IBM3290\") ;\n                sdcb.model = 3290 ;\n                sdcb.type = 5 ;\n              }\n            else  /* cant tell - use most primitive */\n              {\n                strcpy(sdcb.modname,\"IBM3278-2\") ;\n                sdcb.model = 3278 ;\n                sdcb.type = 2 ;\n              }\n          }\n        return 0 ;\n      }\n    else  /* get term failed - return its code */\n      return rc ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* This routine loads an assebbler module below the 16 MB line       */\n/* that issues the GTTERM macro instruction to obtain the            */\n/* dimensions of the screen and also some bit fields that            */\n/* tell if the device can be queried. The module copies the          */\n/* results from storage below the line to this routines              */\n/* automatic storage.                                                */\n/* Upon completion the module is unloaded.                           */\n/*-------------------------------------------------------------------*/\nint getterm(int *primrow, int *primcol,\n             int *altrow, int *altcol,\n             int *attrs)\n  {\n    struct {\n      union {\n        short sh ;\n        char c\u00dd2\u00a8 ;\n      } prim ;\n      union {\n        short sh ;\n        char c\u00dd2\u00a8 ;\n      } alt ;\n      int attr ;\n    } pm ;\n    int rc = 0 ;\n    int (*tgt327d)(void *) ;\n\n    loadm(\"TGT327D\",&tgt327d) ;   /* load ASM routine below 16M */\n    rc = (*tgt327d)(&pm) ;        /* execute GTTERM macro */\n    if (rc==0)      /* data returned OK ? */\n      {             /* yes - convert single byte numbers to int */\n        *primrow = pm.prim.c\u00dd0\u00a8 ;\n        *primcol = pm.prim.c\u00dd1\u00a8 ;\n        *altrow = pm.alt.c\u00dd0\u00a8 ;\n        *altcol = pm.alt.c\u00dd1\u00a8 ;\n        *attrs = pm.attr ;\n      }\n    unloadm(tgt327d) ;            /* unload ASM routine */\n    return rc ;                   /* return code from GTTERM */\n  }\n\n/*-------------------------------------------------------------------*/\n/* Clear 3270 screen.                                                */\n/*-------------------------------------------------------------------*/\nvoid clear()\n  {\n    int rc ;\n    char sba\u00dd2\u00a8 ;\n    char out1\u00dd\u00a8 = {      /* set up for erase */\n      WRT, 0x40,\n      SBA, 0x5d, 0x7f,   /* end addr - overlayed later */\n      SBA, 0x40, 0x40,   /* start addr row=1 col=1 */\n      SBA, 0xe7, 0x7f,   /* insert cursor location, row/col max */\n      ICUR               /* insert cursor */\n      } ;\n    char out2\u00dd\u00a8 = {      /* erase write alternate */\n      EWA, 0xc2\n      } ;\n    char out3\u00dd\u00a8 = {      /* erase primary */\n      WRT, 0xc2\n      } ;\n\n    /* set max screen size known so far sba */\n    rc2sba(sdcb.rows,sdcb.cols,sba) ;\n    out1\u00dd9\u00a8 = sba\u00dd0\u00a8 ;\n    out1\u00dd10\u00a8 = sba\u00dd1\u00a8 ;\n\n    rc = tputn(out1,sizeof(out1) ) ;   /* define the buffer */\n    rc = tputn(out2,sizeof(out2) ) ;   /* erase write alternate */\n    rc = tputn(out3,sizeof(out3) ) ;   /* erase write primary */\n  }\n\n/*-------------------------------------------------------------------*/\n/* Select the entire screen buffer using SBA based on the            */\n/* scrsize returned from GTTERM and EW/EWA to select the             */\n/* primary or alternate buffer.                                      */\n/* Then assemble a structured field query, and send it to the        */\n/* device using TPG which will cause the device to imediately        */\n/* send back the response without any user intervention.             */\n/* Then decode the read partition, query operations, query and       */\n/* put the interesting data in the sdcb structure.                   */\n/*-------------------------------------------------------------------*/\nint querydev()\n  {\n    short sflen ;      /* structured field length */\n    char  sfid ;       /* structured field ID */\n    char  qcode ;      /* query reply - query code */\n    char input\u00dd256\u00a8 ;  /* query buffer */\n    char *ibuf ;       /* current query buffer pointer */\n    int rc ;\n    char sba\u00dd2\u00a8 ;\n\n    char out1\u00dd\u00a8 = {      /* set up for erase */\n      WRT, 0x40,\n      SBA, 0x5d, 0x7f,   /* end addr - overlayed later, rc= 24,80 */\n      SBA, 0x40, 0x40,   /* start addr row=1 col=1 */\n      SBA, 0xe7, 0x7f,   /* insert cursor loc, rc= 32,80 *OVERLAYED**/\n      ICUR               /* insert cursor */\n      } ;\n\n    char out2\u00dd\u00a8 = {      /* erase write alternate */\n      EWA, 0xc2\n      } ;\n\n    char out3\u00dd\u00a8 = {      /* erase primary */\n      WRT, 0xc2\n      } ;\n\n    char out4\u00dd\u00a8 = {\n      WSF,               /* write structured field */\n      0x00, 0x05,        /* structured field length */\n      0x01,              /* read partition */\n      0xFF,              /* query operations */\n      0x02               /* query */\n      } ;\n\n    /* set max screen size known so far sba */\n    rc2sba(sdcb.rows,sdcb.cols,sba) ;\n    out1\u00dd9\u00a8 = sba\u00dd0\u00a8 ;\n    out1\u00dd10\u00a8 = sba\u00dd1\u00a8 ;\n\n    fill(input,0x00,sizeof(input)) ;   /* zero input buffer */\n\n    rc = tputn(out1,sizeof(out1) ) ;   /* define the buffer */\n    rc = tputn(out2,sizeof(out2) ) ;   /* erase write alternate */\n    rc = tputn(out3,sizeof(out3) ) ;   /* erase write primary */\n    rc = tpgn(out4,sizeof(out4) ) ;    /* query the device */\n    rc = tgetn(input,sizeof(input)) ;  /* receive device resp.*/\n\n    ibuf = input ;       /* point at input */\n\n    if (*input==0x88)    /* check for 88 AID byte */\n      {\n        ibuf = ibuf+1 ;         /* advance to 1st structured field */\n        sfid = *(ibuf+2) ;      /* sfid should be 0x81 */\n\n        while (sfid==0x81)  /* while structured fields remain */\n          {\n            sflen = *((short *)ibuf) ;  /* get structured field len */\n            if (sflen==0)           /* bad error - should not happen */\n              {\n                printf(\"Error: Structured field length zero at %p\\n\",\n                  ibuf) ;\n                dumpchar(input,sizeof(input)) ;\n                return 1 ;\n              }\n            qcode = *(ibuf+3) ;     /* get query code */\n            switch (qcode)\n              {\n                case 0x80:           /* Q-code summary */\n                  rc = dsummary(ibuf,sflen) ;\n                  break ;\n                case 0x81:           /* Usable area */\n                  rc = darea(ibuf,sflen) ;\n                  break ;\n                case 0x85:           /* Character sets */\n                  rc = dcharset(ibuf,sflen) ;\n                  break ;\n                case 0x86:           /* Color */\n                  rc = dcolor(ibuf,sflen) ;\n                  break ;\n                case 0x87:           /* Highlighting */\n                  rc = dhilite(ibuf,sflen) ;\n                  break ;\n                case 0x88:           /* Modes */\n                  rc = dmodes(ibuf,sflen) ;\n                  break ;\n                case 0xa6:           /* Implicit partition */\n                  rc = dimpart(ibuf,sflen) ;\n                  break ;\n                default:\n                  break ;\n              }  /* of switch */\n            ibuf = ibuf+sflen ; /* advance to next structured field */\n            sfid = *(ibuf+2) ;  /* sfid should be 0x81 - else stop */\n\n          } /* of while sfid=81 */\n\n      } /* of AID=88 */\n    return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x80: Qcode summary                                               */\n/*-------------------------------------------------------------------*/\nint dsummary(char *buf, short buflen)\n  {\n     int i ;\n     char qcode ;\n\n     for (i=4;i<buflen;i++)\n       {\n          qcode = *(buf+i) ;     /* get query code */\n          if (qcode == 0xb4)\n            sdcb.graflg = 1 ;    /* indicate graphic support */\n       }  /* of for i=4 */\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x81: Usable area                                                 */\n/*-------------------------------------------------------------------*/\nint darea(char *buf, short buflen)\n  {\n     char celunits\u00dd6\u00a8 ;   /* screen size unit PEL or CELL */\n     short w, h ;         /* screen size w=width h=height */\n     char aw, ah ;        /* units per cell aw=width ah=height */\n     float xr, xrd, yr, yrd ;  /* pel spacing ratio */\n     float fw, fh ;       /* ratio - pels per unit */\n\n     if ((*(buf+4) & 0x03)==0x03)\n       sdcb.adrmode = 16 ;\n     else if ((*(buf+4) & 0x01)==0x01)\n       sdcb.adrmode = 12 ;\n\n     w = *((short *)(buf+6)) ;   /* width of usable area */\n     h = *((short *)(buf+8)) ;   /* height of usable area */\n\n     if (*(buf+10) == 0x01)    /* pels/in or pels/mm */\n       sdcb.unit = 1 ;  /* units are mm */\n     else\n       sdcb.unit = 0 ;  /* units are inch */\n\n     xr = *((short *)(buf+11)) ;    /* x dim pel ratio numerator */\n     xrd = *((short *)(buf+13)) ;   /* x dim pel ratio denominator */\n     yr = *((short *)(buf+15)) ;    /* y dim pel ratio numerator */\n     yrd = *((short *)(buf+17)) ;   /* y dim pel ratio denominator */\n\n     fw = (float)(xr) / (float)(xrd) ; /* horiz. ratio pels per unit */\n     fh = (float)(yr) / (float)(yrd) ; /* vert. ratio pels per unit */\n\n     aw = *(buf+19) ;    /* number of X units in default cell */\n     ah = *(buf+20) ;    /* number of Y units in default cell */\n\n     if (*(buf+5) & 0x20)       /* byte 5 bit 3 on unit=pels */\n       strcpy(celunits,\"pels\") ;\n     else                       /* other wise unit=cells */\n       strcpy(celunits,\"cells\") ;\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x85: Character sets                                              */\n/*-------------------------------------------------------------------*/\nint dcharset(char *buf, short buflen)\n  {\n     int i, j ;         /* counters */\n     int cgcsgid ;      /* Coded graphic character set identifier */\n     short ccsid ;      /* Coded character set identifier */\n     char gf = 0 ;      /* CGCSGID not present flag */\n     char ch2 = 0 ;     /* Two byte char. set flag */\n     char ms = 0 ;      /* Multiple slot sizes flag */\n     char cf = 0 ;      /* CCSID not present flag */\n     char sdw ;         /* Default character slot width */\n     char sdh ;         /* Default character slot height */\n     char dl ;          /* character set descriptor (CSD) length */\n     char *csd ;        /* character set descriptor (CSD) ptr */\n     char set ;         /* character set ID (PS store no.) */\n     char lcid ;        /* character set Local ID (alias) */\n     char sw ;          /* character set slot width */\n     char sh ;          /* character set slot height */\n     char ssubsn ;      /* character set starting subsection */\n     char esubsn ;      /* character set ending subsection */\n\n     if (*(buf+4) & 0x10)\n       sdcb.psflg = 1 ;   /* load PS Extended supported */\n     else\n       sdcb.psflg = 0 ;   /* load PS Extended not supported */\n\n     if (*(buf+4) & 0x08)\n       ms = 1 ;   /* More than one size character slot supported */\n\n     if (*(buf+4) & 0x04)\n       ch2 = 1 ;  /* Two byte code character sets are supported */\n\n     if (*(buf+4) & 0x02)\n       gf = 1 ;   /* CGCSGID present */\n\n     if (*(buf+5) & 0x20)\n       cf = 1 ;   /* CCSID present */\n\n     sdw = *(buf+6) ;\n     sdh = *(buf+7) ;\n\n     dl = *(buf+12) ;   /* get CSD length */\n     i = 13 ;\n     while (i<buflen)\n       {\n         csd = buf + i ;  /* point at CSD to process */\n         set = *csd ;     /* get character set ID (PS store no.) */\n         if (*(csd+1) & 0x80)\n           sdcb.loadflg = 1 ;  /* loadable symbol sets exist */\n\n         if (*(csd+1) & 0x40)\n           sdcb.triflg = 1 ;   /* Triple-plane character sets exist */\n\n         if (*(csd+1) & 0x20)\n           sdcb.dbcsflg = 1 ;  /* Double-byte coded character sets */\n\n         lcid = *(csd+2) ;   /* get character set ID (PS store no.) */\n\n         j = 0 ;\n         if (ms)\n           {\n             sw = *(csd+3) ;  /* slot width */\n             sh = *(csd+4) ;  /* slot height */\n             j = j + 2 ;\n           }\n\n         if (ch2)\n           {\n             ssubsn = *(csd+j+3) ;  /* starting sub-section */\n             esubsn = *(csd+j+4) ; /* ending sub-section */\n             j = j + 2 ;\n           }\n\n         if (gf)\n           {\n             cgcsgid = *((int *)(csd+j+3)) ;  /* Graf char set ID */\n             if (cgcsgid==0x03c30136)\n               sdcb.aplflg = lcid ;   /* APL supported store lcid */\n             j = j + 4 ;\n           }\n\n         if (cf)\n           {\n             ccsid = *((short *)(csd+j+3)) ;  /* char set ID */\n           }\n\n         i = i + dl ;  /* get pos of next CSD */\n       }  /* of while i<buflen */\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x86: Colors                                                      */\n/*-------------------------------------------------------------------*/\nint dcolor(char *buf, short buflen)\n  {\n     int colora = 0 ; /* number of actual colors on device */\n     int icolor ;     /* color index */\n     int i, j = 0 ;   /* counter */\n     char attr ;      /* color attribute accepted by device */\n     char dcolor ;    /* color displayed for this attribute */\n\n     sdcb.colors = (int)*(buf+5) ; /* number of colors accepted */\n     for (i=6;i<buflen;i=i+2)\n       {\n         attr = *(buf+i) ;        /* attribute used by appl. */\n         sdcb.colorlst\u00ddj++\u00a8 = attr ;\n         dcolor = *(buf+i+1) ;    /* attr/color used by device */\n         icolor = (int)(dcolor - 0xf0) ;\n         if ((icolor >= 0) && (icolor <= 15))\n           colora++ ;\n       }\n     sdcb.colora = colora ;  /* number of actual colors on device */\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x87: Highlighting                                                */\n/*-------------------------------------------------------------------*/\nint dhilite(char *buf, short buflen)\n  {\n     int i, j = 0 ;    /* counter */\n     char attr ;       /* color attribute accepted by device */\n     char dhilite ;    /* color displayed for this attribute */\n\n     sdcb.hilites = (int)*(buf+4) ;\n     for (i=5;i<buflen;i=i+2)\n       {\n         attr = *(buf+i) ;        /* attribute used by appl. */\n         dhilite = *(buf+i+1) ;   /* attr/highlight used by device */\n         sdcb.hilitlst\u00ddj++\u00a8 = attr ;\n       }\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x88: Modes                                                       */\n/*-------------------------------------------------------------------*/\nint dmodes(char *buf, short buflen)\n  {\n     int i ;           /* counter */\n     char mode ;       /* device opperation mode */\n\n     for (i=4;i<buflen;i++)\n       {\n         mode = *(buf+i) ;        /* attribute used by appl. */\n         if ((mode==0x01) ||\n             (mode==0x02))\n           sdcb.edsflg = 1 ;  /* queryable device can use extended DS*/\n       }   /* of for i */\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0xa6: Implicit partition                                          */\n/*-------------------------------------------------------------------*/\nint dimpart(char *buf, short buflen)\n  {\n     char *sdp ;                /* self defining parameter (SDP) ptr */\n     short wd, wa, hd, ha ;     /* screen dimensions */\n     short wcd, wca, hcd, hca ; /* cell sizes */\n     int i ;                    /* counter */\n\n     i = 6 ;        /* length of header */\n     while(i < buflen)   /* loop over all SDPs */\n       {\n         sdp = buf + i ;\n         if (*sdp==0x0b)    /* is it a SDP ? */\n           {\n             if (*(sdp+1)==0x01)\n               {\n                 wd = *((short *)(sdp+3)) ;  /* default width */\n                 hd = *((short *)(sdp+5)) ;  /* default height */\n                 wa = *((short *)(sdp+7)) ;  /* alternate width */\n                 ha = *((short *)(sdp+9)) ;  /* alternate height */\n                 if ((ha>hd) || (wa>wd))\n                   {\n                     sdcb.altflg = 1 ;    /* use alternate device */\n                     sdcb.rows = ha ;     /* use alternate rows */\n                     sdcb.cols = wa ;     /* use alternate cols */\n                   }\n                 else\n                   {\n                     sdcb.rows = hd ;     /* use primary rows */\n                     sdcb.cols = wd ;     /* use primary cols */\n                   }\n                 i = i + 11 ;     /* add length of this SDP */\n               }\n             else if (*(sdp+1)==0x03)\n               {\n                 i = i + 11 ;     /* add length of this SDP */\n               }\n             else if (*(sdp+1)==0x02)\n               {\n                 wcd = *((short *)(sdp+3)) ;  /* default cell width */\n                 hcd = *((short *)(sdp+5)) ;  /* default cell height */\n                 wca = *((short *)(sdp+7)) ;  /* alternate cell width */\n                 hca = *((short *)(sdp+9)) ;  /* alternate cell height*/\n                 if (sdcb.altflg)         /* using alternate device */\n                   {\n                     sdcb.celheigh = hca ; /* use alt. cell height */\n                     sdcb.celwidth = wca ; /* use alt. cell width */\n                   }\n                 else\n                   {\n                     sdcb.celheigh = hcd ; /* use primary cell height */\n                     sdcb.celwidth = wcd ; /* use primary cols width */\n                   }\n                 i = i + 11 ;     /* add length of this SDP */\n               }\n           }\n       }  /* of while */\n\n     return 0 ;\n  }\n\n\n\n\n/*********************************************************************/\n/* General string handling routines for varying length strings.      */\n/*   lstran(mod_lstr,fromchar,tochar)                                */\n/*   lstrload(to_lstr,fromchar,len)                                  */\n/*   lstrunld(tochar,from_lstr)                                      */\n/*   lstrcopy(to_lstr,from_lstr)                                     */\n/*   lstrnew(to,fromchars)                                           */\n/*   lstrsub(to_lstr,from_lstr,start,length)                         */\n/*   len = lstrlen(haystack_lstr)                                    */\n/*   pos = lstrindex(haystack_lstr,needle_lstr)                      */\n/*   lstrfill(to_lstr,fillchars)                                     */\n/*   rc = lstrcmpc(cmp_lstr,cmpchars)                                */\n/*   lstrdel(del-lstr)                                               */\n/*   lstrrep(to_lstr,repchars,copies)                                */\n/*   lstrcat(to_lstr,left_lstr,right_lstr)                           */\n/*********************************************************************/\n\n/*-------------------------------------------------------------------*/\n/* Translate a character in an lstr to another character.            */\n/*-------------------------------------------------------------------*/\nvoid lstran(TLSTR *in, char from, char to)\n{\n  int i ;      /* temp counter */\n\n  if (in)      /* from string exists ? */\n    {\n      for (i=0;i<=in->len;i++)\n        {\n          if (*(in->data+i) == from)\n            *(in->data+i) = to ;\n        }\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Get the length of an lstr.                                        */\n/*-------------------------------------------------------------------*/\nint lstrlen(TLSTR *in)\n{\n  if (in)      /* from string exists ? */\n    {\n      return in->len ;\n    }\n  else\n    return 0 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Unload varying length string contents into character buffer.      */\n/*-------------------------------------------------------------------*/\nint lstrunld(char *to,\n             TLSTR *from)\n{\n  if (from)      /* from string exists ? */\n    {\n      memcpy(to,from->data,from->len) ;\n      return from->len ;\n    }\n  else\n    return 0 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Load varying length string with contents of character buffer.     */\n/*-------------------------------------------------------------------*/\nvoid lstrload(TLSTR *to,\n              char *from,\n              int len)\n{\n  if (to)      /* to string exists ? */\n    {\n      if (len!=to->len)\n        {\n          free((char *)to->data) ;\n          to->data = (char *)malloc(len) ;\n          if (!to->data) serror(4,\"Not enough memory\") ;\n          to->len = len ;\n        }\n      memcpy(to->data,from,len) ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Copy varying length string.                                       */\n/*-------------------------------------------------------------------*/\nvoid lstrcopy(TLSTR *to,\n              TLSTR *from)\n{\n  if (from)      /* from string exists ? */\n    {\n      if (!to)    /* to string does not exist */\n        serror(2,\"String does not exist\") ;\n      else     /* to string exists */\n        {\n          if (from->len > 0)\n            {\n              if (to->data == NULL)     /* does not exist yet ? */\n                {\n                  to->data = (char *)malloc(from->len) ;\n                  if (!to->data) serror(14,\"Not enough memory\") ;\n                }\n              else if (from->len != to->len)   /* increase length ? */\n                {\n                  free((char *)to->data) ;\n                  to->data = (char *)malloc(from->len) ;\n                  if (!to->data) serror(4,\"Not enough memory\") ;\n                }\n              to->len = from->len ;\n              memcpy(to->data,from->data,from->len) ;\n            }\n          else\n            {\n              if (to->len > 0)   /* empty data */\n                free((char *)to->data) ;\n              to->len = 0 ;\n              to->data = NULL ;\n            }\n        }\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Initialize a varying length string with a string.                 */\n/*-------------------------------------------------------------------*/\nvoid lstrnew(TLSTR *newstr,\n             char *from)\n{\n  int i ;\n\n  if (!newstr)\n    serror(5,\"String does not exist\") ;\n  else\n    {\n      i = strlen(from) ;\n      if (i > 0)\n        {\n          newstr->data = (char *)malloc(i) ;\n          if (!newstr->data) serror(17,\"Not enough memory\") ;\n          newstr->len = i ;\n          memcpy(newstr->data,from,i) ;\n        }\n      else\n        {\n          newstr->len = 0 ;\n          newstr->data = NULL ;\n        }\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Create substring of a varying length string to a varying length   */\n/* string.                                                           */\n/*-------------------------------------------------------------------*/\nvoid lstrsub(TLSTR *to,\n             TLSTR *from,\n             int start,\n             int len)\n{\n  int i ;\n\n  if (start <= from->len)\n    {\n      i = from->len - start ;\n      if (len < i)\n        i = len ;       /* i is the length of the sub string */\n\n      if (!to)\n        serror(8,\"String does not exist\") ;\n      else\n        {\n          if (i > 0)\n            {\n              if (to->data == NULL)     /* does not exist yet ? */\n                {\n                  to->data = (char *)malloc(i) ;\n                  if (!to->data) serror(20,\n                    \"Not enough memory\") ;\n                }\n              else if (to->len != i)          /* wrong size ? */\n                {\n                  free((char *)to->data) ;\n                  to->data = (char *)malloc(i) ;\n                  if (!to->data) serror(10,\n                    \"Not enough memory\") ;\n                }\n              to->len = i ;\n              memcpy(to->data,from->data+start,i) ;\n            }\n          else\n            {\n              if (to->len > 0)   /* empty data */\n                free((char *)to->data) ;\n              to->len = 0 ;\n              to->data = NULL ;\n            }\n        }\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Find the position in a varying length string of a varying length  */\n/* sub-string.                                                       */\n/*-------------------------------------------------------------------*/\nint lstrindx(TLSTR *haystack, /* string to search */\n             TLSTR *needle)   /* sub-string to search for */\n{\n  int i, j, k, endpos ;\n\n  endpos = haystack->len - needle->len ;\n  for (i=0; i<endpos; i++)\n    {\n      k = 0 ;\n      for (j=0; j<needle->len; j++)\n        {\n          if (haystack->data\u00ddi+j\u00a8 == needle->data\u00ddj\u00a8)\n            k ++ ;\n          else break ;\n        }\n      if (k==needle->len)\n        return(i+1) ;\n    }\n  return 0 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Compare a varying length string with a string.                    */\n/*   rc = 0  == strings same                                         */\n/*   rc = 1  == lstr has larger value than charstr                   */\n/*   rc = -1 == lstr has smaller value than charstr                  */\n/*-------------------------------------------------------------------*/\nint lstrcmpc(TLSTR *lstr,   /* string to compare */\n             char *cstr)    /* characters to compare with */\n{\n  int i ;               /* counter */\n  int t=0 ;             /* compare flag */\n  int l ;               /* compare length */\n  int ld=0 ;            /* length differ flag */\n  char *lstrptr ;\n  char *cstrptr ;\n\n  l = strlen(cstr) ;    /* determine shortest string */\n  if (l != lstr->len)   /* same lengths ? */\n    {                   /*   no .. */\n      ld = 1 ;          /*   flag lengths differ */\n      if (l > lstr->len)\n        l = lstr->len ; /*   use shortest length */\n    }\n\n  /* compare to shortest length */\n  lstrptr = lstr->data ;\n  cstrptr = cstr ;\n  for (i=0; i<l; i++)\n    {\n      if (*lstrptr > *cstrptr)\n        {\n          t = 1 ;    /* indicate left larger than right */\n          break ;    /* end scan now  */\n        }\n      if (*lstrptr < *cstrptr)\n        {\n          t = -1 ;   /* indicate left smaller than right */\n          break ;    /* end scan now  */\n        }\n      lstrptr++ ;\n      cstrptr++ ;\n    }\n\n  if ((t==0) && (ld==1)) /* same after shortest length compared ? */\n    {\n      if (strlen(cstr) > lstr->len)\n        t = -1 ;     /* lstr smaller */\n      else\n        t = 1 ;      /* lstr larger */\n    }\n  return t ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Fill a varying length string with a string.                       */\n/*-------------------------------------------------------------------*/\nvoid lstrfill(TLSTR *string,   /* string to fill */\n              char *fillstr)  /* filler characters to use */\n{\n  int i ;\n  char *strptr ;\n\n  strptr = fillstr ;\n  for (i=0; i<=string->len; i++)\n    {\n      string->data\u00ddi\u00a8 = *(strptr++) ;\n      if (*strptr=='\\0')\n        strptr = fillstr ;    /* start over on fill string */\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Delete a varying length string (free associated memory).          */\n/*-------------------------------------------------------------------*/\nvoid lstrdel(TLSTR *string)   /* string to delete */\n{\n  free((char *)string->data) ;\n  string->data = NULL ;\n  string->len = 0 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Create a varying length string with multiple copies of a string.  */\n/*-------------------------------------------------------------------*/\nvoid lstrrep(TLSTR *string,\n             char *repstr,\n             int copies)\n{\n  int repstrlen ;\n  char *strptr ;\n  int newlen ;\n  int i ;\n\n  /* The input string that replications are made from is assumed */\n  /* to have a length of one or longer.                          */\n\n  repstrlen = strlen(repstr) ;\n  if (repstrlen==0)  /* assume repitition of 0x00 */\n    repstrlen = 1 ;\n  newlen = repstrlen * copies ;\n  if (string->data==NULL)          /* alloc storage ? */\n    {\n      string->data = (char *)malloc(newlen) ;\n      if (!string->data) serror(21,\"Not enough memory\") ;\n    }\n  else if (string->len!=newlen)    /* alloc more/less storage ? */\n    {\n      free((char *)string->data) ;\n      string->data = (char *)malloc(newlen) ;\n      if (!string->data) serror(11,\"Not enough memory\") ;\n    }\n  string->len = newlen ;     /* alter string length */\n  strptr = repstr ;\n  for (i=0; i<newlen; i++)        /* replicate the repstr data */\n    {\n      string->data\u00ddi\u00a8 = *strptr++ ;\n      if (*strptr == '\\0')\n        strptr = repstr ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Concatenate two varying length strings together placing the       */\n/* in a varying length string.                                       */\n/*-------------------------------------------------------------------*/\nvoid lstrcat(TLSTR *result,   /* result of concatenation */\n             TLSTR *left,     /* left string to concatenate */\n             TLSTR *right)    /* right string to concatenate */\n{\n  char *rstr ;\n  int newlen ;\n\n  newlen = left->len + right->len ;    /* extend LSTR */\n  rstr = (char *)malloc(newlen) ;\n  if (!rstr) serror(12,\"Not enough memory\") ;\n\n  memcpy(rstr,left->data,left->len) ;   /* make new string */\n  memcpy(rstr+left->len,right->data,right->len) ;\n\n  free((char *)result->data) ;   /* assemble new LSTR */\n  result->data = rstr ;\n  result->len = newlen ;\n}\n\n\n/*********************************************************************/\n/* General sub routines.                                             */\n/*   fill(haystack,fillchar,number)                                  */\n/*   dumpchar(buffer,length)                                         */\n/*   overlay(buffer,bufferlen,overlay,overlaylen,overlaypos)         */\n/*********************************************************************/\n\n/*-------------------------------------------------------------------*/\n/* Fill a character string with a number of filler characters.       */\n/*-------------------------------------------------------------------*/\nvoid fill(char *haystack,   /* area to fill */\n          char filler,      /* fill characters */\n          int num)          /* number of repetitions */\n{\n  int i = 0 ;\n  for(i=0;i<=num;i++)\n    *haystack++ = filler ;\n  *haystack = '\\0' ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Dump the contents of a buffer, formatted in a way that makes a    */\n/* 3270 data stream easier to interpret.                             */\n/*-------------------------------------------------------------------*/\nvoid dumpchar(char *dat,    /* data to dump */\n              int len)      /* length to dump */\n{\n  char *cptr ;\n  char c ;\n  char cc\u00dd3\u00a8 ;\n  int i ;\n  int n, m ;\n\n  n = 0 ;\n  m = 0 ;\n  cptr = dat ;\n  do\n    {\n      printf(\"      %.8X \",dat) ;\n      for(i=1;i<=16;i++)\n        {                   /* 0 indicates all */\n          if (*dat=='\\0' && len==0)\n            break ;\n          if (n==len && len>0)\n            break ;\n          c = *dat++ ;\n          n++ ;\n          printf(\"%.2X\",c) ;\n          if ((i%4)==0)\n            printf(\" \") ;\n        }\n      printf(\"\\n               \") ;\n\n      for(i=1;i<=16;i++)\n        {\n          if (*cptr=='\\0' && len==0)\n            break ;\n          if (m==len && len>0)\n            break ;\n          c = *cptr++ ;\n          m++ ;\n          if (c <= 0x3f || c==0xff)\n            {\n              switch (c)\n                {\n                  case GE:   strcpy(cc,\"GE\") ;\n                    break ;\n                  case FF:   strcpy(cc,\"FF\") ;\n                    break ;\n                  case CRR:  strcpy(cc,\"CR\") ;\n                    break ;\n                  case SBA:  strcpy(cc,\"SB\") ;\n                    break ;\n                  case EUA:  strcpy(cc,\"EU\") ;\n                    break ;\n                  case ICUR: strcpy(cc,\"IC\") ;\n                    break ;\n                  case NL:   strcpy(cc,\"NL\") ;\n                    break ;\n                  case EM:   strcpy(cc,\"EM\") ;\n                    break ;\n                  case DUP:  strcpy(cc,\"DU\") ;\n                    break ;\n                  case SF:   strcpy(cc,\"SF\") ;\n                    break ;\n                  case FM:   strcpy(cc,\"FM\") ;\n                    break ;\n                  case SA:   strcpy(cc,\"SA\") ;\n                    break ;\n                  case SFE:  strcpy(cc,\"SX\") ;\n                    break ;\n                  case MF:   strcpy(cc,\"MF\") ;\n                    break ;\n                  case RA:   strcpy(cc,\"RA\") ;\n                    break ;\n                  case SUB:  strcpy(cc,\"SU\") ;\n                    break ;\n                  default:   strcpy(cc,\". \") ;\n                    break ;\n                }\n              printf(\"%s\",cc) ;\n            }\n          else\n            printf(\"%c \",c) ;\n          if ((i%4)==0)\n            printf(\" \") ;\n        }\n      printf(\"\\n\") ;\n    }\n  while( ((*dat!='\\0') && (len==0)) ||\n         ((m!=len) && (len>20))\n       ) ;\n  printf(\"\\n\") ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Overlay characterc in a buffer.                                   */\n/*-------------------------------------------------------------------*/\nvoid overlay(char *haystack,    /* area to overlay */\n             int haylen,        /* length to overlay */\n             char *needle,      /* overlay characters */\n             int len,           /* length of overlay */\n             int pos)           /* start postition of overlay */\n{\n  int hlen, nlen ;   /* length of haystack and needle */\n  int i = 0 ;        /* itterator */\n\n  if (haylen==0)\n    hlen = strlen(haystack) ;\n  else\n    hlen = haylen ;\n\n  if (len==0)\n    nlen = strlen(needle) ;\n  else\n    nlen = len ;\n\n  if (hlen>(nlen+pos))\n    {\n      haystack = haystack+pos ;    /* move to overlay pos */\n      for(i=0;i<nlen;i++)          /* copy the data */\n        *haystack++ = *needle++ ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* General error message routine.                                    */\n/*-------------------------------------------------------------------*/\nvoid serror(int errno,\n            char *msg)\n{\n  printf(\"Error: %d - %s\\n\",errno,msg) ;\n  abort() ;\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "PS9X12U": {"ttr": 5891, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "#pragma eject\n/* 3270 Program Symbol Definition array */\nchar ps9x12u\u00dd256\u00a8\u00dd18\u00a8 = {\n  /* No symbol '00'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '01'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '02'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '03'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '04'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '05'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '06'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '07'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '08'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '09'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '0A'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '0B'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '0C'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '0D'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '0E'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '0F'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '10'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '11'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '12'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '13'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '14'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '15'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '16'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '17'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '18'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '19'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '1A'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '1B'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '1C'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '1D'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '1E'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '1F'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '20'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '21'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '22'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '23'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '24'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '25'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '26'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '27'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '28'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '29'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '2A'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '2B'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '2C'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '2D'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '2E'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '2F'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '30'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '31'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '32'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '33'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '34'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '35'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '36'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '37'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '38'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '39'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '3A'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '3B'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '3C'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '3D'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '3E'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '3F'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '40'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol '41'x defined */\n    0x48,0x10,0xdf,0x00,0x80,0x50,0xa8,0x38,0x2b,0x04,\n    0x02,0x01,0x06,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol '42'x defined */\n    0x00,0x00,0x1f,0x10,0x10,0x10,0x10,0x10,0x10,0x10,\n    0x10,0x10,0x10,0x1f,0x00,0x00,0x00,0x00,\n  /* Symbol '43'x defined */\n    0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol '44'x defined */\n    0x80,0x10,0xf0,0x10,0x10,0x10,0x10,0x10,0x10,0x10,\n    0x10,0x10,0x10,0xf0,0x00,0x00,0x00,0x00,\n  /* Symbol '45'x defined */\n    0xbf,0xd0,0xff,0x00,0xff,0x11,0x11,0x11,0xf1,0x01,\n    0x01,0xff,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol '46'x defined */\n    0xbe,0x10,0xff,0x00,0xf0,0x10,0x10,0x10,0xf0,0x07,\n    0x07,0x07,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol '47'x defined */\n    0x80,0x10,0xff,0x00,0xdb,0xdb,0x00,0x66,0x66,0x00,\n    0x18,0x18,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol '48'x defined */\n    0x80,0x10,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol '49'x defined */\n    0x00,0x00,0x1f,0x15,0x1a,0x14,0x18,0x10,0x10,0x10,\n    0x10,0x10,0x10,0x1f,0x00,0x00,0x00,0x00,\n  /* Symbol \u00a2='4A'x defined */\n    0x80,0x10,0xff,0x00,0x10,0x7c,0x92,0x90,0x90,0x92,\n    0x7c,0x10,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol .='4B'x defined */\n    0x80,0x10,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x60,0x60,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol <='4C'x defined */\n    0x80,0x10,0xff,0x00,0x08,0x10,0x20,0x40,0x40,0x20,\n    0x10,0x08,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol (='4D'x defined */\n    0x80,0x10,0xff,0x00,0x10,0x20,0x40,0x40,0x40,0x40,\n    0x20,0x10,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol +='4E'x defined */\n    0x80,0x10,0xff,0x00,0x00,0x10,0x10,0x10,0xfe,0x10,\n    0x10,0x10,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol |='4F'x defined */\n    0x80,0x10,0xff,0x00,0x10,0x10,0x10,0x10,0x10,0x10,\n    0x10,0x10,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol &='50'x defined */\n    0x80,0x10,0xff,0x00,0x70,0x88,0x50,0x70,0x8a,0x84,\n    0x8a,0x70,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol '51'x defined */\n    0x80,0x30,0xf0,0x10,0x10,0x10,0x10,0x10,0x10,0x30,\n    0x50,0xb0,0x50,0xf0,0x00,0x00,0x00,0x00,\n  /* Symbol '52'x defined */\n    0x80,0x10,0xff,0x00,0x82,0xc6,0xee,0x7c,0x7c,0xee,\n    0xc6,0x82,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol '53'x defined */\n    0x0f,0x00,0x00,0x38,0x44,0x82,0x39,0x7d,0x7d,0x39,\n    0x82,0x44,0x38,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol '54'x defined */\n    0x0f,0x00,0x00,0x38,0x44,0x82,0x01,0x01,0x01,0x01,\n    0x82,0x44,0x38,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol '55'x defined */\n    0x7f,0xc0,0x00,0xff,0x83,0x45,0x29,0x11,0x29,0x45,\n    0x83,0xff,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol '56'x defined */\n    0x7f,0xc0,0x00,0xff,0x01,0x01,0x01,0x01,0x01,0x01,\n    0x01,0xff,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol '57'x defined */\n    0x55,0x40,0x00,0x55,0x00,0x01,0x00,0x01,0x00,0x01,\n    0x00,0x55,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol '58'x defined */\n    0xbf,0xd0,0xff,0x00,0xff,0xff,0xff,0xff,0xff,0xff,\n    0xff,0xff,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol '59'x defined */\n    0xff,0xf0,0xff,0x00,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,\n    0x7f,0x7f,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol !='5A'x defined */\n    0x80,0x10,0xff,0x00,0x10,0x10,0x10,0x10,0x10,0x10,\n    0x00,0x10,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol $='5B'x defined */\n    0x80,0x10,0xff,0x00,0x10,0x3c,0x50,0x38,0x14,0x54,\n    0x38,0x10,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol *='5C'x defined */\n    0x80,0x10,0xff,0x00,0x10,0x54,0x38,0xfe,0x38,0x54,\n    0x10,0x00,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol )='5D'x defined */\n    0x80,0x10,0xff,0x00,0x10,0x08,0x04,0x04,0x04,0x04,\n    0x08,0x10,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol ;='5E'x defined */\n    0x80,0x10,0xff,0x00,0x00,0x00,0x00,0x60,0x00,0x00,\n    0x60,0x60,0x40,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol \u00ac='5F'x defined */\n    0x80,0x10,0xff,0x00,0x00,0xf8,0x08,0x00,0x00,0x00,\n    0x00,0x00,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol -='60'x defined */\n    0x80,0x10,0xff,0x00,0x00,0x00,0x00,0xfe,0x00,0x00,\n    0x00,0x00,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol /='61'x defined */\n    0x80,0x50,0xff,0x00,0x02,0x04,0x08,0x10,0x20,0x40,\n    0x80,0x00,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol '62'x defined */\n    0xbf,0xd0,0xff,0x01,0xfd,0xfd,0xfd,0xfd,0xfd,0xfd,\n    0xfd,0xfd,0x01,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol '63'x defined */\n    0x80,0x10,0xff,0x01,0x01,0x01,0x01,0x01,0x01,0x01,\n    0x01,0x01,0x01,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol '64'x defined */\n    0xff,0xf0,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol '65'x defined */\n    0x80,0x10,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol '66'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1f,0x10,\n    0x10,0x10,0x10,0x10,0x00,0x00,0x00,0x00,\n  /* Symbol '67'x defined */\n    0x00,0x00,0x10,0x10,0x10,0x10,0x10,0x1f,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol '68'x defined */\n    0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x10,\n    0x10,0x10,0x10,0x10,0x00,0x00,0x00,0x00,\n  /* Symbol '69'x defined */\n    0x04,0x00,0x10,0x10,0x10,0x10,0x10,0xf0,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '6A'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol ,='6B'x defined */\n    0x80,0x10,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x60,0x60,0x40,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol %='6C'x defined */\n    0x80,0x10,0xff,0x00,0x62,0x94,0x68,0x10,0x20,0x2c,\n    0x52,0x8c,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol _='6D'x defined */\n    0x80,0x50,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0xff,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol >='6E'x defined */\n    0x80,0x10,0xff,0x00,0x40,0x20,0x10,0x08,0x08,0x10,\n    0x20,0x40,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol ?='6F'x defined */\n    0x80,0x10,0xff,0x00,0x38,0x44,0x04,0x08,0x10,0x10,\n    0x00,0x10,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol '70'x defined */\n    0x04,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol '71'x defined */\n    0x00,0x00,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,\n    0x10,0x10,0x10,0x10,0x00,0x00,0x00,0x00,\n  /* Symbol '72'x defined */\n    0x80,0x10,0xff,0x10,0x10,0x10,0x10,0x10,0x10,0x10,\n    0x10,0x10,0x10,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol '73'x defined */\n    0x0a,0x00,0x00,0x10,0x44,0x00,0x01,0x00,0x01,0x00,\n    0x82,0x00,0x28,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol '74'x defined */\n    0x55,0x40,0x00,0x55,0x82,0x45,0x28,0x11,0x28,0x45,\n    0x82,0x55,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol '75'x defined */\n    0x7f,0xc0,0x00,0xff,0x01,0x45,0x01,0x11,0x01,0x45,\n    0x01,0xff,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol '76'x defined */\n    0x55,0x40,0x00,0x55,0x00,0x45,0x00,0x11,0x00,0x45,\n    0x00,0x55,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol '77'x defined */\n    0x0a,0x00,0x00,0x10,0x44,0x00,0x39,0x7c,0x7d,0x38,\n    0x82,0x00,0x28,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol '78'x defined */\n    0x0f,0x00,0x00,0x38,0x44,0x82,0x29,0x55,0x29,0x11,\n    0x82,0x44,0x38,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '79'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol :='7A'x defined */\n    0x80,0x10,0xff,0x00,0x00,0x00,0x00,0x60,0x60,0x00,\n    0x60,0x60,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol #='7B'x defined */\n    0x80,0x10,0xff,0x00,0x28,0x28,0xfe,0x28,0x28,0xfe,\n    0x28,0x28,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol @='7C'x defined */\n    0x80,0x10,0xff,0x00,0x7c,0x82,0x9e,0xa2,0xa2,0x9c,\n    0x80,0x7e,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol '='7D'x defined */\n    0x80,0x10,0xff,0x00,0x10,0x10,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol =='7E'x defined */\n    0x80,0x10,0xff,0x00,0x00,0x00,0xfe,0x00,0xfe,0x00,\n    0x00,0x00,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol \"='7F'x defined */\n    0x80,0x10,0xff,0x00,0x28,0x28,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol '80'x defined */\n    0x0a,0x00,0x00,0x10,0x44,0x00,0x29,0x54,0x29,0x10,\n    0x82,0x00,0x28,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol a='81'x defined */\n    0x80,0x10,0xff,0x00,0x00,0x00,0x00,0x7c,0x02,0x7e,\n    0x82,0x7e,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol b='82'x defined */\n    0x80,0x10,0xff,0x00,0x80,0x80,0x80,0xf8,0x84,0x84,\n    0x84,0xf8,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol c='83'x defined */\n    0x80,0x10,0xff,0x00,0x00,0x00,0x00,0x7c,0x80,0x80,\n    0x80,0x7c,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol d='84'x defined */\n    0x80,0x10,0xff,0x00,0x02,0x02,0x02,0x7e,0x82,0x82,\n    0x82,0x7e,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol e='85'x defined */\n    0x80,0x10,0xff,0x00,0x00,0x00,0x00,0x7c,0x82,0xfe,\n    0x80,0x7e,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol f='86'x defined */\n    0x80,0x10,0xff,0x00,0x1c,0x20,0x20,0xf8,0x20,0x20,\n    0x20,0x20,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol g='87'x defined */\n    0x80,0x10,0xff,0x00,0x00,0x00,0x00,0x78,0x84,0x84,\n    0x7c,0x04,0x38,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol h='88'x defined */\n    0x80,0x10,0xff,0x00,0x80,0x80,0x80,0xf8,0x84,0x84,\n    0x84,0x84,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol i='89'x defined */\n    0x80,0x10,0xff,0x00,0x00,0x10,0x00,0x10,0x10,0x10,\n    0x10,0x10,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol '8A'x defined */\n    0x00,0x40,0x00,0x00,0x7c,0x44,0x44,0x44,0x44,0x44,\n    0x44,0xff,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '8B'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '8C'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '8D'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '8E'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '8F'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol '90'x defined */\n    0x00,0x40,0x00,0x00,0x7c,0x44,0x44,0x44,0x44,0x7c,\n    0x7c,0xff,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol j='91'x defined */\n    0x80,0x10,0xff,0x00,0x00,0x10,0x00,0x10,0x10,0x10,\n    0x10,0x10,0x60,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol k='92'x defined */\n    0x80,0x10,0xff,0x00,0x80,0x80,0x88,0x90,0xa0,0xd0,\n    0x88,0x84,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol l='93'x defined */\n    0x80,0x10,0xff,0x00,0x10,0x10,0x10,0x10,0x10,0x10,\n    0x10,0x18,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol m='94'x defined */\n    0x80,0x10,0xff,0x00,0x00,0x00,0x00,0x6c,0x92,0x92,\n    0x92,0x92,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol n='95'x defined */\n    0x80,0x10,0xff,0x00,0x00,0x00,0x00,0xbc,0xc2,0x82,\n    0x82,0x82,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol o='96'x defined */\n    0x80,0x10,0xff,0x00,0x00,0x00,0x00,0x7c,0x82,0x82,\n    0x82,0x7c,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol p='97'x defined */\n    0x80,0x10,0xff,0x00,0x00,0x00,0x00,0xf8,0x84,0x82,\n    0x84,0xf8,0x80,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol q='98'x defined */\n    0x80,0x10,0xff,0x00,0x00,0x00,0x00,0x7c,0x84,0x84,\n    0x8c,0x74,0x06,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol r='99'x defined */\n    0x80,0x10,0xff,0x00,0x00,0x00,0x00,0xb8,0xc0,0x80,\n    0x80,0x80,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol '9A'x defined */\n    0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7c,\n    0x7c,0xff,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '9B'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol '9C'x defined */\n    0x00,0x00,0x1f,0x10,0x10,0x10,0x10,0x10,0x10,0x18,\n    0x14,0x1a,0x15,0x1f,0x00,0x00,0x00,0x00,\n  /* No symbol '9D'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol '9E'x defined */\n    0xc0,0x10,0xf0,0x50,0xb0,0x50,0x30,0x10,0x10,0x10,\n    0x10,0x10,0x10,0xf0,0x00,0x00,0x00,0x00,\n  /* Symbol '9F'x defined */\n    0x9f,0x90,0xff,0x00,0x00,0xb6,0xb6,0xb6,0xb6,0xb6,\n    0xb6,0x00,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* No symbol 'A0'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'A1'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol s='A2'x defined */\n    0x80,0x10,0xff,0x00,0x00,0x00,0x00,0x7c,0x80,0x78,\n    0x04,0xf8,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol t='A3'x defined */\n    0x80,0x10,0xff,0x00,0x20,0x20,0x20,0xf8,0x20,0x20,\n    0x20,0x38,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol u='A4'x defined */\n    0x80,0x10,0xff,0x00,0x00,0x00,0x00,0x84,0x84,0x84,\n    0x84,0x78,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol v='A5'x defined */\n    0x80,0x10,0xff,0x00,0x00,0x00,0x00,0x82,0x44,0x44,\n    0x28,0x10,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol w='A6'x defined */\n    0x80,0x10,0xff,0x00,0x00,0x00,0x00,0x82,0x82,0x92,\n    0xaa,0x44,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol x='A7'x defined */\n    0x80,0x10,0xff,0x00,0x00,0x00,0x00,0x44,0x28,0x10,\n    0x28,0x44,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol y='A8'x defined */\n    0x80,0x10,0xff,0x00,0x00,0x00,0x00,0x42,0x22,0x14,\n    0x08,0x10,0x20,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol z='A9'x defined */\n    0x80,0x10,0xff,0x00,0x00,0x00,0x00,0x7c,0x08,0x10,\n    0x20,0x7c,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* No symbol 'AA'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'AB'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'AC'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'AD'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'AE'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'AF'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'B0'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'B1'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'B2'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'B3'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'B4'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'B5'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'B6'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'B7'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'B8'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'B9'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol 'BA'x defined */\n    0x00,0x40,0x00,0x00,0x54,0x44,0x00,0x44,0x00,0x44,\n    0x00,0x55,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'BB'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'BC'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'BD'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'BE'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'BF'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'C0'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol A='C1'x defined */\n    0x80,0x10,0xff,0x00,0x10,0x28,0x44,0x82,0xfe,0x82,\n    0x82,0x82,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol B='C2'x defined */\n    0x80,0x10,0xff,0x00,0xfc,0x42,0x42,0x7c,0x42,0x42,\n    0x42,0xfc,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol C='C3'x defined */\n    0x80,0x10,0xff,0x00,0x3c,0x42,0x80,0x80,0x80,0x80,\n    0x42,0x3c,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol D='C4'x defined */\n    0x80,0x10,0xff,0x00,0xf8,0x44,0x42,0x42,0x42,0x42,\n    0x44,0xf8,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol E='C5'x defined */\n    0x80,0x10,0xff,0x00,0xfe,0x80,0x80,0xf8,0x80,0x80,\n    0x80,0xfe,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol F='C6'x defined */\n    0x80,0x10,0xff,0x00,0xfe,0x80,0x80,0xf8,0x80,0x80,\n    0x80,0x80,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol G='C7'x defined */\n    0x80,0x10,0xff,0x00,0x38,0x44,0x80,0x80,0x8e,0x84,\n    0x44,0x3c,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol H='C8'x defined */\n    0x80,0x10,0xff,0x00,0x82,0x82,0x82,0xfe,0x82,0x82,\n    0x82,0x82,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol I='C9'x defined */\n    0x80,0x10,0xff,0x00,0x7c,0x10,0x10,0x10,0x10,0x10,\n    0x10,0x7c,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol 'CA'x defined */\n    0x00,0x40,0x00,0x00,0x54,0x44,0x00,0x44,0x00,0x54,\n    0x28,0x55,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol 'CB'x defined */\n    0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x54,\n    0x28,0x55,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'CC'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol 'CD'x defined */\n    0xff,0xf0,0xff,0x00,0x04,0x0c,0x1c,0x3c,0x3c,0x1c,\n    0x0c,0x04,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* No symbol 'CE'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol 'CF'x defined */\n    0x80,0x10,0xff,0x01,0x41,0x61,0x71,0x79,0x79,0x71,\n    0x61,0x41,0x01,0xff,0x00,0x00,0x00,0x00,\n  /* No symbol 'D0'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol J='D1'x defined */\n    0x80,0x10,0xff,0x00,0x1c,0x08,0x08,0x08,0x08,0x88,\n    0x48,0x30,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol K='D2'x defined */\n    0x80,0x10,0xff,0x00,0x84,0x88,0x90,0xa0,0xe0,0x90,\n    0x88,0x84,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol L='D3'x defined */\n    0x80,0x10,0xff,0x00,0x80,0x80,0x80,0x80,0x80,0x80,\n    0x80,0xfe,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol M='D4'x defined */\n    0x80,0x10,0xff,0x00,0x82,0xc6,0xaa,0xaa,0x92,0x82,\n    0x82,0x82,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol N='D5'x defined */\n    0x80,0x10,0xff,0x00,0x82,0xc2,0xa2,0x92,0x92,0x8a,\n    0x86,0x82,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol O='D6'x defined */\n    0x80,0x10,0xff,0x00,0x7c,0x82,0x82,0x82,0x82,0x82,\n    0x82,0x7c,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol P='D7'x defined */\n    0x80,0x10,0xff,0x00,0xf8,0x84,0x84,0xf8,0x80,0x80,\n    0x80,0x80,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol Q='D8'x defined */\n    0x80,0x10,0xff,0x00,0x38,0x44,0x82,0x82,0x82,0x92,\n    0x54,0x38,0x04,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol R='D9'x defined */\n    0x80,0x10,0xff,0x00,0xf8,0x84,0x84,0xf8,0xa0,0x90,\n    0x88,0x84,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol 'DA'x defined */\n    0xff,0xf0,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,\n    0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,\n  /* Symbol 'DB'x defined */\n    0xff,0xf0,0x7d,0x7d,0x7d,0x7d,0x7d,0x7d,0x7d,0x7d,\n    0x7d,0x7d,0x7d,0x7d,0x00,0x00,0x00,0x00,\n  /* Symbol 'DC'x defined */\n    0xff,0xf0,0xff,0x01,0x11,0x11,0x11,0x39,0x39,0x39,\n    0x7d,0x7d,0x7d,0x01,0x00,0x00,0x00,0x00,\n  /* Symbol 'DD'x defined */\n    0xff,0xf0,0x01,0x7d,0x7d,0x7d,0x39,0x39,0x39,0x11,\n    0x11,0x11,0x01,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol 'DE'x defined */\n    0xff,0xf0,0xff,0x01,0x39,0x39,0x39,0x39,0x39,0x7d,\n    0x39,0x11,0x01,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol 'DF'x defined */\n    0xff,0xf0,0xff,0x01,0x01,0x01,0x01,0x01,0x01,0x55,\n    0x55,0x01,0x01,0xff,0x00,0x00,0x00,0x00,\n  /* No symbol 'E0'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'E1'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol S='E2'x defined */\n    0x80,0x10,0xff,0x00,0x38,0x44,0x40,0x38,0x04,0x04,\n    0x44,0x38,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol T='E3'x defined */\n    0x80,0x10,0xff,0x00,0xfe,0x10,0x10,0x10,0x10,0x10,\n    0x10,0x10,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol U='E4'x defined */\n    0x80,0x10,0xff,0x00,0x82,0x82,0x82,0x82,0x82,0x82,\n    0x82,0x7c,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol V='E5'x defined */\n    0x80,0x10,0xff,0x00,0x82,0x82,0x44,0x44,0x28,0x28,\n    0x10,0x10,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol W='E6'x defined */\n    0x80,0x10,0xff,0x00,0x82,0x82,0x82,0x92,0x92,0x92,\n    0x92,0x6c,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol X='E7'x defined */\n    0x80,0x10,0xff,0x00,0x82,0x44,0x28,0x10,0x28,0x44,\n    0x44,0x82,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol Y='E8'x defined */\n    0x80,0x10,0xff,0x00,0x82,0x44,0x28,0x10,0x10,0x10,\n    0x10,0x10,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol Z='E9'x defined */\n    0x80,0x10,0xff,0x00,0xfe,0x02,0x04,0x08,0x10,0x20,\n    0x40,0xfe,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol 'EA'x defined */\n    0xff,0xf0,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,\n    0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol 'EB'x defined */\n    0x80,0x10,0xff,0x00,0x22,0x22,0x66,0xee,0x66,0x22,\n    0x22,0x00,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol 'EC'x defined */\n    0x80,0x10,0xff,0x00,0x88,0x88,0xcc,0xee,0xcc,0x88,\n    0x88,0x00,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol 'ED'x defined */\n    0xff,0xf0,0x01,0x11,0x11,0x39,0x7d,0x01,0x11,0x11,\n    0x39,0x7d,0x01,0x01,0x00,0x00,0x00,0x00,\n  /* Symbol 'EE'x defined */\n    0xff,0xf0,0x01,0x01,0x7d,0x39,0x11,0x11,0x01,0x7d,\n    0x39,0x11,0x11,0x01,0x00,0x00,0x00,0x00,\n  /* Symbol 'EF'x defined */\n    0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol 0='F0'x defined */\n    0x80,0x10,0xff,0x00,0x7c,0x82,0x82,0x92,0x92,0x82,\n    0x82,0x7c,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol 1='F1'x defined */\n    0x80,0x10,0xff,0x00,0x10,0x30,0x10,0x10,0x10,0x10,\n    0x10,0x38,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol 2='F2'x defined */\n    0x80,0x10,0xff,0x00,0x7c,0x82,0x04,0x08,0x10,0x20,\n    0x40,0xfe,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol 3='F3'x defined */\n    0x80,0x10,0xff,0x00,0xfe,0x02,0x04,0x38,0x04,0x02,\n    0x82,0x7c,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol 4='F4'x defined */\n    0x80,0x10,0xff,0x00,0x08,0x18,0x28,0x48,0x88,0xfe,\n    0x08,0x08,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol 5='F5'x defined */\n    0x80,0x10,0xff,0x00,0xfe,0x80,0x80,0xfc,0x02,0x02,\n    0x44,0x38,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol 6='F6'x defined */\n    0x80,0x10,0xff,0x00,0x7c,0x82,0x80,0x80,0xfc,0x82,\n    0x82,0x7c,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol 7='F7'x defined */\n    0x80,0x10,0xff,0x00,0xfe,0x02,0x04,0x08,0x10,0x10,\n    0x10,0x10,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol 8='F8'x defined */\n    0x80,0x10,0xff,0x00,0x7c,0x82,0x44,0x38,0x44,0x82,\n    0x82,0x7c,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol 9='F9'x defined */\n    0x80,0x10,0xff,0x00,0x7c,0x82,0x82,0x7e,0x02,0x02,\n    0x44,0x38,0x00,0xff,0x00,0x00,0x00,0x00,\n  /* No symbol 'FA'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'FB'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'FC'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'FD'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'FE'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'FF'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00\n  } ;\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "PS9X15U": {"ttr": 6150, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "#pragma eject\n/* 3270 Program Symbol Definition array */\nchar ps9x15u\u00dd256\u00a8\u00dd18\u00a8 = {\n  /* No symbol '00'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '01'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '02'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '03'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '04'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '05'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '06'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '07'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '08'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '09'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '0A'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '0B'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '0C'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '0D'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '0E'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '0F'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '10'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '11'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '12'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '13'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '14'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '15'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '16'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '17'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '18'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '19'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '1A'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '1B'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '1C'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '1D'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '1E'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '1F'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '20'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '21'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '22'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '23'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '24'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '25'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '26'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '27'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '28'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '29'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '2A'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '2B'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '2C'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '2D'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '2E'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '2F'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '30'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '31'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '32'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '33'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '34'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '35'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '36'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '37'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '38'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '39'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '3A'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '3B'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '3C'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '3D'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '3E'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '3F'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '40'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol '41'x defined */\n    0x00,0x02,0x77,0x80,0x60,0x10,0xe0,0x10,0x28,0x38,\n    0x28,0x0e,0x10,0x0c,0x02,0x1c,0xff,0x00,\n  /* Symbol '42'x defined */\n    0x00,0x00,0x1f,0x10,0x10,0x10,0x10,0x10,0x10,0x10,\n    0x10,0x10,0x10,0x10,0x10,0x10,0x1f,0x00,\n  /* Symbol '43'x defined */\n    0xff,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol '44'x defined */\n    0x80,0x02,0xf0,0x10,0x10,0x10,0x10,0x10,0x10,0x10,\n    0x10,0x10,0x10,0x10,0x10,0x10,0xf0,0x00,\n  /* Symbol '45'x defined */\n    0xbf,0xfa,0xff,0x00,0xff,0x11,0x11,0x11,0x11,0x11,\n    0xf1,0x01,0x01,0x01,0xff,0x00,0xff,0x00,\n  /* Symbol '46'x defined */\n    0xbf,0x82,0xff,0x00,0xf0,0x10,0x10,0x10,0x10,0x10,\n    0xf0,0x08,0x07,0x07,0x07,0x00,0xff,0x00,\n  /* Symbol '47'x defined */\n    0x80,0x02,0xff,0x00,0xdb,0xdb,0x00,0x00,0x66,0x66,\n    0x00,0x00,0x18,0x18,0x00,0x00,0xff,0x00,\n  /* Symbol '48'x defined */\n    0x80,0x02,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x00,\n  /* Symbol '49'x defined */\n    0x00,0x00,0x1f,0x15,0x1a,0x14,0x18,0x10,0x10,0x10,\n    0x10,0x10,0x10,0x10,0x10,0x10,0x1f,0x00,\n  /* Symbol \u00a2='4A'x defined */\n    0x80,0x02,0xff,0x00,0x10,0x10,0x7c,0x92,0x90,0x90,\n    0x90,0x92,0x7c,0x10,0x10,0x00,0xff,0x00,\n  /* Symbol .='4B'x defined */\n    0x80,0x02,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x60,0x60,0x00,0xff,0x00,\n  /* Symbol <='4C'x defined */\n    0x80,0x02,0xff,0x00,0x04,0x08,0x10,0x20,0x40,0x80,\n    0x40,0x20,0x10,0x08,0x04,0x00,0xff,0x00,\n  /* Symbol (='4D'x defined */\n    0x80,0x02,0xff,0x00,0x10,0x20,0x20,0x40,0x40,0x40,\n    0x40,0x40,0x20,0x20,0x10,0x00,0xff,0x00,\n  /* Symbol +='4E'x defined */\n    0x80,0x02,0xff,0x00,0x00,0x10,0x10,0x10,0x10,0xfe,\n    0x10,0x10,0x10,0x10,0x00,0x00,0xff,0x00,\n  /* Symbol |='4F'x defined */\n    0x80,0x02,0xff,0x00,0x10,0x10,0x10,0x10,0x10,0x10,\n    0x10,0x10,0x10,0x10,0x10,0x00,0xff,0x00,\n  /* Symbol &='50'x defined */\n    0x80,0x02,0xff,0x00,0x70,0x88,0x88,0x50,0x70,0x8a,\n    0x84,0x84,0x8a,0x88,0x70,0x00,0xff,0x00,\n  /* Symbol '51'x defined */\n    0x80,0x06,0xf0,0x10,0x10,0x10,0x10,0x10,0x10,0x10,\n    0x10,0x10,0x30,0x50,0xb0,0x50,0xf0,0x00,\n  /* Symbol '52'x defined */\n    0x80,0x02,0xff,0x00,0x00,0x82,0xc6,0xee,0x7c,0x38,\n    0x7c,0xee,0xc6,0x82,0x00,0x00,0xff,0x00,\n  /* Symbol '53'x defined */\n    0x07,0x80,0x00,0x00,0x38,0x44,0x82,0x39,0x7d,0x7d,\n    0x39,0x82,0x44,0x38,0x00,0x00,0x00,0x00,\n  /* Symbol '54'x defined */\n    0x07,0x80,0x00,0x00,0x38,0x44,0x82,0x01,0x01,0x01,\n    0x01,0x82,0x44,0x38,0x00,0x00,0x00,0x00,\n  /* Symbol '55'x defined */\n    0x3f,0xe0,0x00,0x00,0xff,0x83,0x45,0x29,0x11,0x29,\n    0x45,0x83,0xff,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol '56'x defined */\n    0x3f,0xe0,0x00,0x00,0xff,0x01,0x01,0x01,0x01,0x01,\n    0x01,0x01,0xff,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol '57'x defined */\n    0x2a,0xa0,0x00,0x00,0x55,0x00,0x01,0x00,0x01,0x00,\n    0x01,0x00,0x55,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol '58'x defined */\n    0x9f,0xf2,0xff,0x00,0x00,0xff,0xff,0xff,0xff,0xff,\n    0xff,0xff,0xff,0xff,0x00,0x00,0xff,0x00,\n  /* Symbol '59'x defined */\n    0xff,0xfe,0xff,0x00,0x00,0x7f,0x7f,0x7f,0x7f,0x7f,\n    0x7f,0x7f,0x7f,0x7f,0x00,0x00,0xff,0x00,\n  /* Symbol !='5A'x defined */\n    0x80,0x02,0xff,0x00,0x10,0x10,0x10,0x10,0x10,0x10,\n    0x10,0x10,0x00,0x10,0x10,0x00,0xff,0x00,\n  /* Symbol $='5B'x defined */\n    0x80,0x02,0xff,0x00,0x10,0x38,0x54,0x90,0x50,0x38,\n    0x14,0x12,0x54,0x38,0x10,0x00,0xff,0x00,\n  /* Symbol *='5C'x defined */\n    0x80,0x02,0xff,0x00,0x00,0x10,0x10,0x54,0x38,0xfe,\n    0x38,0x54,0x10,0x10,0x00,0x00,0xff,0x00,\n  /* Symbol )='5D'x defined */\n    0x80,0x02,0xff,0x00,0x10,0x08,0x08,0x04,0x04,0x04,\n    0x04,0x04,0x08,0x08,0x10,0x00,0xff,0x00,\n  /* Symbol ;='5E'x defined */\n    0x80,0x02,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x60,\n    0x60,0x00,0x00,0x60,0x60,0x40,0xff,0x00,\n  /* Symbol \u00ac='5F'x defined */\n    0x80,0x02,0xff,0x00,0x00,0xf8,0x08,0x08,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x00,\n  /* Symbol -='60'x defined */\n    0x80,0x02,0xff,0x00,0x00,0x00,0x00,0x00,0xfe,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x00,\n  /* Symbol /='61'x defined */\n    0x80,0x02,0xff,0x00,0x02,0x04,0x04,0x08,0x08,0x10,\n    0x10,0x20,0x20,0x40,0x80,0x00,0xff,0x00,\n  /* Symbol '62'x defined */\n    0x9f,0xf2,0xff,0x01,0x01,0xfd,0xfd,0xfd,0xfd,0xfd,\n    0xfd,0xfd,0xfd,0xfd,0x01,0x01,0xff,0x00,\n  /* Symbol '63'x defined */\n    0x80,0x02,0xff,0x01,0x01,0x01,0x01,0x01,0x01,0x01,\n    0x01,0x01,0x01,0x01,0x01,0x01,0xff,0x00,\n  /* Symbol '64'x defined */\n    0xff,0xfe,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x00,\n  /* Symbol '65'x defined */\n    0x80,0x02,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x00,\n  /* Symbol '66'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1f,\n    0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x00,\n  /* Symbol '67'x defined */\n    0x00,0x00,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x1f,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol '68'x defined */\n    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,\n    0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x00,\n  /* Symbol '69'x defined */\n    0x01,0x00,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0xf0,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '6A'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol ,='6B'x defined */\n    0x80,0x02,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x60,0x60,0x40,0xff,0x00,\n  /* Symbol %='6C'x defined */\n    0x80,0x02,0xff,0x00,0x62,0x94,0x94,0x68,0x08,0x10,\n    0x20,0x2c,0x52,0x52,0x8c,0x00,0xff,0x00,\n  /* Symbol _='6D'x defined */\n    0x80,0x0a,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0xff,0x00,0xff,0x00,\n  /* Symbol >='6E'x defined */\n    0x80,0x02,0xff,0x00,0x80,0x40,0x20,0x10,0x08,0x04,\n    0x08,0x10,0x20,0x40,0x80,0x00,0xff,0x00,\n  /* Symbol ?='6F'x defined */\n    0x80,0x02,0xff,0x00,0x38,0x44,0x04,0x04,0x08,0x10,\n    0x10,0x00,0x10,0x38,0x10,0x00,0xff,0x00,\n  /* Symbol '70'x defined */\n    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol '71'x defined */\n    0x00,0x00,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,\n    0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x00,\n  /* Symbol '72'x defined */\n    0x80,0x02,0xff,0x10,0x10,0x10,0x10,0x10,0x10,0x10,\n    0x10,0x10,0x10,0x10,0x10,0x10,0xff,0x00,\n  /* Symbol '73'x defined */\n    0x05,0x00,0x00,0x00,0x10,0x44,0x00,0x01,0x00,0x01,\n    0x00,0x82,0x00,0x28,0x00,0x00,0x00,0x00,\n  /* Symbol '74'x defined */\n    0x2a,0xa0,0x00,0x00,0x55,0x82,0x45,0x28,0x11,0x28,\n    0x45,0x82,0x55,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol '75'x defined */\n    0x3f,0xe0,0x00,0x00,0xff,0x01,0x45,0x01,0x11,0x01,\n    0x45,0x01,0xff,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol '76'x defined */\n    0x2a,0xa0,0x00,0x00,0x55,0x00,0x45,0x00,0x11,0x00,\n    0x45,0x00,0x55,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol '77'x defined */\n    0x05,0x00,0x00,0x00,0x10,0x44,0x00,0x39,0x7c,0x7d,\n    0x38,0x82,0x00,0x28,0x00,0x00,0x00,0x00,\n  /* Symbol '78'x defined */\n    0x07,0x80,0x00,0x00,0x38,0x44,0x82,0x29,0x55,0x29,\n    0x11,0x82,0x44,0x38,0x00,0x00,0x00,0x00,\n  /* No symbol '79'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol :='7A'x defined */\n    0x80,0x02,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x60,\n    0x60,0x00,0x00,0x60,0x60,0x00,0xff,0x00,\n  /* Symbol #='7B'x defined */\n    0x80,0x02,0xff,0x00,0x28,0x28,0x28,0xfe,0x28,0x28,\n    0x28,0xfe,0x28,0x28,0x28,0x00,0xff,0x00,\n  /* Symbol @='7C'x defined */\n    0x80,0x02,0xff,0x00,0x7c,0x82,0x82,0x9e,0xa2,0xa2,\n    0xa2,0xa2,0x9c,0x80,0x7e,0x00,0xff,0x00,\n  /* Symbol '='7D'x defined */\n    0x80,0x02,0xff,0x00,0x10,0x10,0x10,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x00,\n  /* Symbol =='7E'x defined */\n    0x80,0x02,0xff,0x00,0x00,0x00,0x00,0xfe,0x00,0x00,\n    0xfe,0x00,0x00,0x00,0x00,0x00,0xff,0x00,\n  /* Symbol \"='7F'x defined */\n    0x80,0x02,0xff,0x00,0x28,0x28,0x28,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x00,\n  /* Symbol '80'x defined */\n    0x05,0x00,0x00,0x00,0x10,0x44,0x00,0x29,0x54,0x29,\n    0x10,0x82,0x00,0x28,0x00,0x00,0x00,0x00,\n  /* Symbol a='81'x defined */\n    0x80,0x02,0xff,0x00,0x00,0x00,0x00,0x00,0x7c,0x02,\n    0x7e,0x82,0x82,0x82,0x7e,0x00,0xff,0x00,\n  /* Symbol b='82'x defined */\n    0x80,0x02,0xff,0x00,0x80,0x80,0x80,0x80,0xf8,0x84,\n    0x82,0x82,0x82,0x84,0xf8,0x00,0xff,0x00,\n  /* Symbol c='83'x defined */\n    0x80,0x02,0xff,0x00,0x00,0x00,0x00,0x00,0x3c,0x42,\n    0x80,0x80,0x80,0x42,0x3c,0x00,0xff,0x00,\n  /* Symbol d='84'x defined */\n    0x80,0x02,0xff,0x00,0x02,0x02,0x02,0x02,0x7e,0x82,\n    0x82,0x82,0x82,0x82,0x7e,0x00,0xff,0x00,\n  /* Symbol e='85'x defined */\n    0x80,0x02,0xff,0x00,0x00,0x00,0x00,0x00,0x7c,0x82,\n    0x82,0xfe,0x80,0x80,0x7e,0x00,0xff,0x00,\n  /* Symbol f='86'x defined */\n    0x80,0x02,0xff,0x00,0x1c,0x20,0x20,0x20,0xf8,0x20,\n    0x20,0x20,0x20,0x20,0x20,0x00,0xff,0x00,\n  /* Symbol g='87'x defined */\n    0x80,0x02,0xff,0x00,0x00,0x00,0x00,0x00,0x78,0x84,\n    0x84,0x84,0x84,0x7c,0x04,0x38,0xff,0x00,\n  /* Symbol h='88'x defined */\n    0x80,0x02,0xff,0x00,0x80,0x80,0x80,0x80,0xf8,0x84,\n    0x84,0x84,0x84,0x84,0x84,0x00,0xff,0x00,\n  /* Symbol i='89'x defined */\n    0x80,0x02,0xff,0x00,0x00,0x10,0x10,0x00,0x10,0x10,\n    0x10,0x10,0x10,0x10,0x10,0x00,0xff,0x00,\n  /* Symbol '8A'x defined */\n    0x00,0x10,0x00,0x00,0x7c,0x44,0x44,0x44,0x44,0x44,\n    0x44,0x44,0x44,0xff,0x00,0x00,0x00,0x00,\n  /* No symbol '8B'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '8C'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '8D'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '8E'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '8F'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol '90'x defined */\n    0x00,0x10,0x00,0x00,0x7c,0x44,0x44,0x44,0x44,0x44,\n    0x7c,0x7c,0x7c,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol j='91'x defined */\n    0x80,0x02,0xff,0x00,0x00,0x10,0x10,0x00,0x10,0x10,\n    0x10,0x10,0x10,0x10,0x10,0x60,0xff,0x00,\n  /* Symbol k='92'x defined */\n    0x80,0x02,0xff,0x00,0x80,0x80,0x82,0x84,0x88,0x90,\n    0xa0,0xd0,0x88,0x84,0x82,0x00,0xff,0x00,\n  /* Symbol l='93'x defined */\n    0x80,0x02,0xff,0x00,0x10,0x10,0x10,0x10,0x10,0x10,\n    0x10,0x10,0x10,0x10,0x18,0x00,0xff,0x00,\n  /* Symbol m='94'x defined */\n    0x80,0x02,0xff,0x00,0x00,0x00,0x00,0x00,0x6c,0x92,\n    0x92,0x92,0x92,0x92,0x92,0x00,0xff,0x00,\n  /* Symbol n='95'x defined */\n    0x80,0x02,0xff,0x00,0x00,0x00,0x00,0x00,0xbc,0xc2,\n    0x82,0x82,0x82,0x82,0x82,0x00,0xff,0x00,\n  /* Symbol o='96'x defined */\n    0x80,0x02,0xff,0x00,0x00,0x00,0x00,0x00,0x7c,0x82,\n    0x82,0x82,0x82,0x82,0x7c,0x00,0xff,0x00,\n  /* Symbol p='97'x defined */\n    0x80,0x02,0xff,0x00,0x00,0x00,0x00,0x00,0xf8,0x84,\n    0x82,0x82,0x82,0x84,0xf8,0x80,0xff,0x00,\n  /* Symbol q='98'x defined */\n    0x80,0x02,0xff,0x00,0x00,0x00,0x00,0x00,0x7c,0x84,\n    0x84,0x84,0x84,0x8c,0x74,0x06,0xff,0x00,\n  /* Symbol r='99'x defined */\n    0x80,0x02,0xff,0x00,0x00,0x00,0x00,0x00,0xb8,0xc0,\n    0x80,0x80,0x80,0x80,0x80,0x00,0xff,0x00,\n  /* Symbol '9A'x defined */\n    0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x7c,0x7c,0x7c,0xff,0x00,0x00,0x00,0x00,\n  /* No symbol '9B'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol '9C'x defined */\n    0x00,0x00,0x1f,0x10,0x10,0x10,0x10,0x10,0x10,0x10,\n    0x10,0x10,0x18,0x14,0x1a,0x15,0x1f,0x00,\n  /* No symbol '9D'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol '9E'x defined */\n    0xc0,0x02,0xf0,0x50,0xb0,0x50,0x30,0x10,0x10,0x10,\n    0x10,0x10,0x10,0x10,0x10,0x10,0xf0,0x00,\n  /* Symbol '9F'x defined */\n    0x9f,0xf2,0xff,0x00,0x00,0xb6,0xb6,0xb6,0xb6,0xb6,\n    0xb6,0xb6,0xb6,0xb6,0x00,0x00,0xff,0x00,\n  /* No symbol 'A0'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'A1'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol s='A2'x defined */\n    0x80,0x02,0xff,0x00,0x00,0x00,0x00,0x00,0x7c,0x80,\n    0x80,0x78,0x04,0x04,0xf8,0x00,0xff,0x00,\n  /* Symbol t='A3'x defined */\n    0x80,0x02,0xff,0x00,0x20,0x20,0x20,0x20,0xf8,0x20,\n    0x20,0x20,0x20,0x20,0x38,0x00,0xff,0x00,\n  /* Symbol u='A4'x defined */\n    0x80,0x02,0xff,0x00,0x00,0x00,0x00,0x00,0x84,0x84,\n    0x84,0x84,0x84,0x84,0x78,0x00,0xff,0x00,\n  /* Symbol v='A5'x defined */\n    0x80,0x02,0xff,0x00,0x00,0x00,0x00,0x00,0x82,0x82,\n    0x44,0x44,0x28,0x28,0x10,0x00,0xff,0x00,\n  /* Symbol w='A6'x defined */\n    0x80,0x02,0xff,0x00,0x00,0x00,0x00,0x00,0x82,0x82,\n    0x92,0x92,0x92,0xaa,0x44,0x00,0xff,0x00,\n  /* Symbol x='A7'x defined */\n    0x80,0x02,0xff,0x00,0x00,0x00,0x00,0x00,0x82,0x44,\n    0x28,0x10,0x28,0x44,0x82,0x00,0xff,0x00,\n  /* Symbol y='A8'x defined */\n    0x80,0x02,0xff,0x00,0x00,0x00,0x00,0x00,0x82,0x42,\n    0x24,0x14,0x08,0x08,0x10,0x10,0xff,0x00,\n  /* Symbol z='A9'x defined */\n    0x80,0x02,0xff,0x00,0x00,0x00,0x00,0x00,0xfe,0x04,\n    0x08,0x10,0x20,0x40,0xfe,0x00,0xff,0x00,\n  /* No symbol 'AA'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'AB'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'AC'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'AD'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'AE'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'AF'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'B0'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'B1'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'B2'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'B3'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'B4'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'B5'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'B6'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'B7'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'B8'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'B9'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol 'BA'x defined */\n    0x00,0x10,0x00,0x00,0x54,0x44,0x00,0x44,0x00,0x44,\n    0x00,0x44,0x00,0x55,0x00,0x00,0x00,0x00,\n  /* No symbol 'BB'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'BC'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'BD'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'BE'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'BF'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'C0'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol A='C1'x defined */\n    0x80,0x02,0xff,0x00,0x10,0x28,0x44,0x82,0x82,0xfe,\n    0x82,0x82,0x82,0x82,0x82,0x00,0xff,0x00,\n  /* Symbol B='C2'x defined */\n    0x80,0x02,0xff,0x00,0xfc,0x42,0x42,0x42,0x42,0x7c,\n    0x42,0x42,0x42,0x42,0xfc,0x00,0xff,0x00,\n  /* Symbol C='C3'x defined */\n    0x80,0x02,0xff,0x00,0x3c,0x42,0x80,0x80,0x80,0x80,\n    0x80,0x80,0x80,0x42,0x3c,0x00,0xff,0x00,\n  /* Symbol D='C4'x defined */\n    0x80,0x02,0xff,0x00,0xf8,0x44,0x42,0x42,0x42,0x42,\n    0x42,0x42,0x42,0x44,0xf8,0x00,0xff,0x00,\n  /* Symbol E='C5'x defined */\n    0x80,0x02,0xff,0x00,0xfe,0x80,0x80,0x80,0x80,0xf8,\n    0x80,0x80,0x80,0x80,0xfe,0x00,0xff,0x00,\n  /* Symbol F='C6'x defined */\n    0x80,0x02,0xff,0x00,0xfe,0x80,0x80,0x80,0x80,0xf8,\n    0x80,0x80,0x80,0x80,0x80,0x00,0xff,0x00,\n  /* Symbol G='C7'x defined */\n    0x80,0x02,0xff,0x00,0x38,0x44,0x80,0x80,0x80,0x80,\n    0x8e,0x84,0x84,0x44,0x3c,0x00,0xff,0x00,\n  /* Symbol H='C8'x defined */\n    0x80,0x02,0xff,0x00,0x82,0x82,0x82,0x82,0x82,0xfe,\n    0x82,0x82,0x82,0x82,0x82,0x00,0xff,0x00,\n  /* Symbol I='C9'x defined */\n    0x80,0x02,0xff,0x00,0x7c,0x10,0x10,0x10,0x10,0x10,\n    0x10,0x10,0x10,0x10,0x7c,0x00,0xff,0x00,\n  /* Symbol 'CA'x defined */\n    0x00,0x10,0x00,0x00,0x54,0x44,0x00,0x44,0x00,0x44,\n    0x28,0x54,0x28,0x55,0x00,0x00,0x00,0x00,\n  /* Symbol 'CB'x defined */\n    0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x54,\n    0x28,0x54,0x28,0x55,0x00,0x00,0x00,0x00,\n  /* No symbol 'CC'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol 'CD'x defined */\n    0xff,0xfe,0xff,0x00,0x02,0x06,0x0e,0x1e,0x3e,0x7e,\n    0x3e,0x1e,0x0e,0x06,0x02,0x00,0xff,0x00,\n  /* No symbol 'CE'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol 'CF'x defined */\n    0x80,0x02,0xff,0x01,0x81,0xc1,0xe1,0xf1,0xf9,0xfd,\n    0xf9,0xf1,0xe1,0xc1,0x81,0x01,0xff,0x00,\n  /* No symbol 'D0'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol J='D1'x defined */\n    0x80,0x02,0xff,0x00,0x1c,0x08,0x08,0x08,0x08,0x08,\n    0x08,0x08,0x88,0x48,0x30,0x00,0xff,0x00,\n  /* Symbol K='D2'x defined */\n    0x80,0x02,0xff,0x00,0x82,0x84,0x88,0x90,0xa0,0xc0,\n    0xa0,0x90,0x88,0x84,0x82,0x00,0xff,0x00,\n  /* Symbol L='D3'x defined */\n    0x80,0x02,0xff,0x00,0x80,0x80,0x80,0x80,0x80,0x80,\n    0x80,0x80,0x80,0x80,0xfe,0x00,0xff,0x00,\n  /* Symbol M='D4'x defined */\n    0x80,0x02,0xff,0x00,0x82,0xc6,0xaa,0xaa,0x92,0x92,\n    0x82,0x82,0x82,0x82,0x82,0x00,0xff,0x00,\n  /* Symbol N='D5'x defined */\n    0x80,0x02,0xff,0x00,0x82,0xc2,0xa2,0xa2,0x92,0x92,\n    0x92,0x8a,0x8a,0x86,0x82,0x00,0xff,0x00,\n  /* Symbol O='D6'x defined */\n    0x80,0x02,0xff,0x00,0x7c,0x82,0x82,0x82,0x82,0x82,\n    0x82,0x82,0x82,0x82,0x7c,0x00,0xff,0x00,\n  /* Symbol P='D7'x defined */\n    0x80,0x02,0xff,0x00,0xf8,0x84,0x82,0x82,0x84,0xf8,\n    0x80,0x80,0x80,0x80,0x80,0x00,0xff,0x00,\n  /* Symbol Q='D8'x defined */\n    0x80,0x02,0xff,0x00,0x38,0x44,0x82,0x82,0x82,0x82,\n    0x82,0x82,0x92,0x54,0x38,0x04,0xff,0x00,\n  /* Symbol R='D9'x defined */\n    0x80,0x02,0xff,0x00,0xf8,0x84,0x82,0x82,0x84,0xf8,\n    0xa0,0x90,0x88,0x84,0x82,0x00,0xff,0x00,\n  /* Symbol 'DA'x defined */\n    0xff,0xfe,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,\n    0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x00,\n  /* Symbol 'DB'x defined */\n    0xff,0xfe,0x7d,0x7d,0x7d,0x7d,0x7d,0x7d,0x7d,0x7d,\n    0x7d,0x7d,0x7d,0x7d,0x7d,0x7d,0x7d,0x00,\n  /* Symbol 'DC'x defined */\n    0xff,0xfe,0xff,0x01,0x01,0x11,0x11,0x11,0x39,0x39,\n    0x39,0x7d,0x7d,0x7d,0x01,0x01,0x01,0x00,\n  /* Symbol 'DD'x defined */\n    0xff,0xfe,0x01,0x01,0x01,0x7d,0x7d,0x7d,0x39,0x39,\n    0x39,0x11,0x11,0x11,0x01,0x01,0xff,0x00,\n  /* Symbol 'DE'x defined */\n    0xff,0xfe,0xff,0x01,0x39,0x39,0x39,0x39,0x39,0x39,\n    0x7d,0x39,0x39,0x11,0x11,0x01,0xff,0x00,\n  /* Symbol 'DF'x defined */\n    0xff,0xfe,0xff,0x01,0x01,0x01,0x01,0x01,0x01,0x01,\n    0x01,0x01,0x55,0x55,0x01,0x01,0xff,0x00,\n  /* No symbol 'E0'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'E1'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol S='E2'x defined */\n    0x80,0x02,0xff,0x00,0x38,0x44,0x82,0x80,0x40,0x38,\n    0x04,0x02,0x82,0x44,0x38,0x00,0xff,0x00,\n  /* Symbol T='E3'x defined */\n    0x80,0x02,0xff,0x00,0xfe,0x10,0x10,0x10,0x10,0x10,\n    0x10,0x10,0x10,0x10,0x10,0x00,0xff,0x00,\n  /* Symbol U='E4'x defined */\n    0x80,0x02,0xff,0x00,0x82,0x82,0x82,0x82,0x82,0x82,\n    0x82,0x82,0x82,0x82,0x7c,0x00,0xff,0x00,\n  /* Symbol V='E5'x defined */\n    0x80,0x02,0xff,0x00,0x82,0x82,0x82,0x44,0x44,0x44,\n    0x28,0x28,0x28,0x10,0x10,0x00,0xff,0x00,\n  /* Symbol W='E6'x defined */\n    0x80,0x02,0xff,0x00,0x82,0x82,0x82,0x82,0x82,0x92,\n    0x92,0x92,0x92,0x92,0x6c,0x00,0xff,0x00,\n  /* Symbol X='E7'x defined */\n    0x80,0x02,0xff,0x00,0x82,0x82,0x44,0x44,0x28,0x10,\n    0x28,0x44,0x44,0x82,0x82,0x00,0xff,0x00,\n  /* Symbol Y='E8'x defined */\n    0x80,0x02,0xff,0x00,0x82,0x82,0x44,0x44,0x28,0x10,\n    0x10,0x10,0x10,0x10,0x10,0x00,0xff,0x00,\n  /* Symbol Z='E9'x defined */\n    0x80,0x02,0xff,0x00,0xfe,0x02,0x04,0x04,0x08,0x10,\n    0x20,0x40,0x40,0x80,0xfe,0x00,0xff,0x00,\n  /* Symbol 'EA'x defined */\n    0xff,0xfe,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,\n    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,\n  /* Symbol 'EB'x defined */\n    0x80,0x02,0xff,0x00,0x00,0x22,0x22,0x66,0x66,0xee,\n    0x66,0x66,0x22,0x22,0x00,0x00,0xff,0x00,\n  /* Symbol 'EC'x defined */\n    0x80,0x02,0xff,0x00,0x00,0x88,0x88,0xcc,0xcc,0xee,\n    0xcc,0xcc,0x88,0x88,0x00,0x00,0xff,0x00,\n  /* Symbol 'ED'x defined */\n    0xff,0xfe,0x01,0x11,0x11,0x39,0x39,0x7d,0x7d,0x01,\n    0x11,0x11,0x39,0x39,0x7d,0x7d,0x01,0x00,\n  /* Symbol 'EE'x defined */\n    0xff,0xfe,0x01,0x7d,0x7d,0x39,0x39,0x11,0x11,0x01,\n    0x7d,0x7d,0x39,0x39,0x11,0x11,0x01,0x00,\n  /* Symbol 'EF'x defined */\n    0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x00,\n  /* Symbol 0='F0'x defined */\n    0x80,0x02,0xff,0x00,0x7c,0x82,0x82,0x82,0x92,0x92,\n    0x92,0x82,0x82,0x82,0x7c,0x00,0xff,0x00,\n  /* Symbol 1='F1'x defined */\n    0x80,0x02,0xff,0x00,0x10,0x30,0x10,0x10,0x10,0x10,\n    0x10,0x10,0x10,0x10,0x38,0x00,0xff,0x00,\n  /* Symbol 2='F2'x defined */\n    0x80,0x02,0xff,0x00,0x7c,0x82,0x02,0x02,0x04,0x08,\n    0x10,0x20,0x40,0x80,0xfe,0x00,0xff,0x00,\n  /* Symbol 3='F3'x defined */\n    0x80,0x02,0xff,0x00,0x7c,0x82,0x02,0x02,0x04,0x38,\n    0x04,0x02,0x02,0x82,0x7c,0x00,0xff,0x00,\n  /* Symbol 4='F4'x defined */\n    0x80,0x02,0xff,0x00,0x08,0x18,0x28,0x48,0x88,0xfe,\n    0x08,0x08,0x08,0x08,0x08,0x00,0xff,0x00,\n  /* Symbol 5='F5'x defined */\n    0x80,0x02,0xff,0x00,0xfe,0x80,0x80,0x80,0xfc,0x02,\n    0x02,0x02,0x82,0x44,0x38,0x00,0xff,0x00,\n  /* Symbol 6='F6'x defined */\n    0x80,0x02,0xff,0x00,0x1c,0x22,0x40,0x80,0x80,0xbc,\n    0xc2,0x82,0x82,0x82,0x7c,0x00,0xff,0x00,\n  /* Symbol 7='F7'x defined */\n    0x80,0x02,0xff,0x00,0xfe,0x02,0x04,0x04,0x08,0x08,\n    0x10,0x10,0x10,0x20,0x20,0x00,0xff,0x00,\n  /* Symbol 8='F8'x defined */\n    0x80,0x02,0xff,0x00,0x7c,0x82,0x82,0x82,0x44,0x38,\n    0x44,0x82,0x82,0x82,0x7c,0x00,0xff,0x00,\n  /* Symbol 9='F9'x defined */\n    0x80,0x02,0xff,0x00,0x7c,0x82,0x82,0x82,0x7e,0x02,\n    0x02,0x02,0x02,0x44,0x38,0x00,0xff,0x00,\n  /* No symbol 'FA'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'FB'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'FC'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'FD'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'FE'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'FF'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00\n  } ;\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "PS9X16U": {"ttr": 6409, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "#pragma eject\n/* 3270 Program Symbol Definition array */\nchar ps9x16u\u00dd256\u00a8\u00dd18\u00a8 = {\n  /* No symbol '00'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '01'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '02'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '03'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '04'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '05'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '06'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '07'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '08'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '09'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '0A'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '0B'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '0C'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '0D'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '0E'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '0F'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '10'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '11'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '12'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '13'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '14'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '15'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '16'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '17'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '18'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '19'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '1A'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '1B'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '1C'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '1D'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '1E'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '1F'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '20'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '21'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '22'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '23'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '24'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '25'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '26'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '27'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '28'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '29'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '2A'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '2B'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '2C'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '2D'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '2E'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '2F'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '30'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '31'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '32'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '33'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '34'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '35'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '36'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '37'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '38'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '39'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '3A'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '3B'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '3C'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '3D'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '3E'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '3F'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '40'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol '41'x defined */\n    0x00,0x01,0x77,0x80,0x60,0x10,0xe0,0x00,0x10,0x28,\n    0x38,0x28,0x00,0x0e,0x10,0x0c,0x02,0x9c,\n  /* Symbol '42'x defined */\n    0x00,0x00,0x1f,0x10,0x10,0x10,0x10,0x10,0x10,0x10,\n    0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x1f,\n  /* Symbol '43'x defined */\n    0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol '44'x defined */\n    0x80,0x01,0xf0,0x10,0x10,0x10,0x10,0x10,0x10,0x10,\n    0x10,0x10,0x10,0x10,0x10,0x10,0x10,0xf0,\n  /* Symbol '45'x defined */\n    0xbf,0xfd,0xff,0x00,0xff,0x09,0x09,0x09,0x09,0x09,\n    0xf9,0x01,0x01,0x01,0x01,0xff,0x00,0xff,\n  /* Symbol '46'x defined */\n    0xbf,0x81,0xff,0x00,0xf8,0x08,0x08,0x08,0x08,0x08,\n    0xf8,0x00,0x08,0x07,0x07,0x07,0x00,0xff,\n  /* Symbol '47'x defined */\n    0x80,0x01,0xff,0x00,0x00,0xdb,0xdb,0x00,0x00,0x66,\n    0x66,0x00,0x00,0x18,0x18,0x00,0x00,0xff,\n  /* Symbol '48'x defined */\n    0x80,0x01,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,\n  /* Symbol '49'x defined */\n    0x00,0x00,0x1f,0x15,0x1a,0x14,0x18,0x10,0x10,0x10,\n    0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x1f,\n  /* Symbol \u00a2='4A'x defined */\n    0x80,0x01,0xff,0x00,0x00,0x10,0x10,0x7c,0x92,0x90,\n    0x90,0x90,0x92,0x7c,0x10,0x10,0x00,0xff,\n  /* Symbol .='4B'x defined */\n    0x80,0x01,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x60,0x60,0x00,0x00,0xff,\n  /* Symbol <='4C'x defined */\n    0x80,0x01,0xff,0x00,0x04,0x08,0x10,0x20,0x40,0x80,\n    0x40,0x20,0x10,0x08,0x04,0x00,0x00,0xff,\n  /* Symbol (='4D'x defined */\n    0x80,0x01,0xff,0x00,0x10,0x20,0x20,0x40,0x40,0x40,\n    0x40,0x40,0x20,0x20,0x10,0x00,0x00,0xff,\n  /* Symbol +='4E'x defined */\n    0x80,0x01,0xff,0x00,0x00,0x10,0x10,0x10,0x10,0xfe,\n    0x10,0x10,0x10,0x10,0x00,0x00,0x00,0xff,\n  /* Symbol |='4F'x defined */\n    0x80,0x01,0xff,0x00,0x10,0x10,0x10,0x10,0x10,0x10,\n    0x10,0x10,0x10,0x10,0x10,0x10,0x00,0xff,\n  /* Symbol &='50'x defined */\n    0x80,0x01,0xff,0x00,0x70,0x88,0x88,0x50,0x70,0x8a,\n    0x84,0x84,0x8a,0x88,0x70,0x00,0x00,0xff,\n  /* Symbol '51'x defined */\n    0x80,0x03,0xf0,0x10,0x10,0x10,0x10,0x10,0x10,0x10,\n    0x10,0x10,0x10,0x30,0x50,0xb0,0x50,0xf0,\n  /* Symbol '52'x defined */\n    0x80,0x01,0xff,0x00,0x00,0x82,0xc6,0xee,0x7c,0x38,\n    0x7c,0xee,0xc6,0x82,0x00,0x00,0x00,0xff,\n  /* Symbol '53'x defined */\n    0x03,0xc0,0x00,0x00,0x00,0x38,0x44,0x82,0x39,0x7d,\n    0x7d,0x39,0x82,0x44,0x38,0x00,0x00,0x00,\n  /* Symbol '54'x defined */\n    0x03,0xc0,0x00,0x00,0x00,0x38,0x44,0x82,0x01,0x01,\n    0x01,0x01,0x82,0x44,0x38,0x00,0x00,0x00,\n  /* Symbol '55'x defined */\n    0x1f,0xf0,0x00,0x00,0x00,0xff,0x83,0x45,0x29,0x11,\n    0x29,0x45,0x83,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol '56'x defined */\n    0x1f,0xf0,0x00,0x00,0x00,0xff,0x01,0x01,0x01,0x01,\n    0x01,0x01,0x01,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol '57'x defined */\n    0x15,0x50,0x00,0x00,0x00,0x55,0x00,0x01,0x00,0x01,\n    0x00,0x01,0x00,0x55,0x00,0x00,0x00,0x00,\n  /* Symbol '58'x defined */\n    0x9f,0xf9,0xff,0x00,0x00,0xff,0xff,0xff,0xff,0xff,\n    0xff,0xff,0xff,0xff,0xff,0x00,0x00,0xff,\n  /* Symbol '59'x defined */\n    0xff,0xff,0xff,0x00,0x00,0x7f,0x7f,0x7f,0x7f,0x7f,\n    0x7f,0x7f,0x7f,0x7f,0x7f,0x00,0x00,0xff,\n  /* Symbol !='5A'x defined */\n    0x80,0x01,0xff,0x00,0x10,0x10,0x10,0x10,0x10,0x10,\n    0x10,0x10,0x00,0x10,0x38,0x10,0x00,0xff,\n  /* Symbol $='5B'x defined */\n    0x80,0x01,0xff,0x00,0x10,0x38,0x54,0x90,0x50,0x38,\n    0x14,0x12,0x54,0x38,0x10,0x00,0x00,0xff,\n  /* Symbol *='5C'x defined */\n    0x80,0x01,0xff,0x00,0x00,0x10,0x10,0x54,0x38,0xfe,\n    0x38,0x54,0x10,0x10,0x00,0x00,0x00,0xff,\n  /* Symbol )='5D'x defined */\n    0x80,0x01,0xff,0x00,0x10,0x08,0x08,0x04,0x04,0x04,\n    0x04,0x04,0x08,0x08,0x10,0x00,0x00,0xff,\n  /* Symbol ;='5E'x defined */\n    0x80,0x01,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x60,\n    0x60,0x00,0x00,0x60,0x60,0x20,0x40,0xff,\n  /* Symbol \u00ac='5F'x defined */\n    0x80,0x01,0xff,0x00,0x00,0xf8,0x08,0x08,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,\n  /* Symbol -='60'x defined */\n    0x80,0x01,0xff,0x00,0x00,0x00,0x00,0x00,0xfe,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,\n  /* Symbol /='61'x defined */\n    0x80,0x01,0xff,0x00,0x02,0x04,0x04,0x08,0x08,0x10,\n    0x10,0x20,0x20,0x40,0x40,0x80,0x00,0xff,\n  /* Symbol '62'x defined */\n    0x9f,0xf9,0xff,0x01,0x01,0xfd,0xfd,0xfd,0xfd,0xfd,\n    0xfd,0xfd,0xfd,0xfd,0xfd,0x01,0x01,0xff,\n  /* Symbol '63'x defined */\n    0x80,0x01,0xff,0x01,0x01,0x01,0x01,0x01,0x01,0x01,\n    0x01,0x01,0x01,0x01,0x01,0x01,0x01,0xff,\n  /* Symbol '64'x defined */\n    0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,\n  /* Symbol '65'x defined */\n    0x80,0x01,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,\n  /* Symbol '66'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1f,\n    0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,\n  /* Symbol '67'x defined */\n    0x00,0x00,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x1f,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol '68'x defined */\n    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,\n    0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,\n  /* Symbol '69'x defined */\n    0x01,0x00,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0xf0,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '6A'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol ,='6B'x defined */\n    0x80,0x01,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x60,0x60,0x20,0x40,0xff,\n  /* Symbol %='6C'x defined */\n    0x80,0x01,0xff,0x00,0x62,0x94,0x94,0x68,0x08,0x10,\n    0x10,0x20,0x2c,0x52,0x52,0x8c,0x00,0xff,\n  /* Symbol _='6D'x defined */\n    0x80,0x05,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0xff,0x00,0xff,\n  /* Symbol >='6E'x defined */\n    0x80,0x01,0xff,0x00,0x80,0x40,0x20,0x10,0x08,0x04,\n    0x08,0x10,0x20,0x40,0x80,0x00,0x00,0xff,\n  /* Symbol ?='6F'x defined */\n    0x80,0x01,0xff,0x00,0x38,0x44,0x04,0x04,0x08,0x10,\n    0x10,0x00,0x10,0x38,0x10,0x00,0x00,0xff,\n  /* Symbol '70'x defined */\n    0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol '71'x defined */\n    0x00,0x00,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,\n    0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,\n  /* Symbol '72'x defined */\n    0x80,0x01,0xff,0x10,0x10,0x10,0x10,0x10,0x10,0x10,\n    0x10,0x10,0x10,0x10,0x10,0x10,0x10,0xff,\n  /* Symbol '73'x defined */\n    0x02,0x80,0x00,0x00,0x00,0x10,0x44,0x00,0x01,0x00,\n    0x01,0x00,0x82,0x00,0x28,0x00,0x00,0x00,\n  /* Symbol '74'x defined */\n    0x15,0x50,0x00,0x00,0x00,0x55,0x82,0x45,0x28,0x11,\n    0x28,0x45,0x82,0x55,0x00,0x00,0x00,0x00,\n  /* Symbol '75'x defined */\n    0x1f,0xf0,0x00,0x00,0x00,0xff,0x01,0x45,0x01,0x11,\n    0x01,0x45,0x01,0xff,0x00,0x00,0x00,0x00,\n  /* Symbol '76'x defined */\n    0x15,0x50,0x00,0x00,0x00,0x55,0x00,0x45,0x00,0x11,\n    0x00,0x45,0x00,0x55,0x00,0x00,0x00,0x00,\n  /* Symbol '77'x defined */\n    0x02,0x80,0x00,0x00,0x00,0x10,0x44,0x00,0x39,0x7c,\n    0x7d,0x38,0x82,0x00,0x28,0x00,0x00,0x00,\n  /* Symbol '78'x defined */\n    0x03,0xc0,0x00,0x00,0x00,0x38,0x44,0x82,0x29,0x55,\n    0x29,0x11,0x82,0x44,0x38,0x00,0x00,0x00,\n  /* No symbol '79'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol :='7A'x defined */\n    0x80,0x01,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x60,\n    0x60,0x00,0x00,0x60,0x60,0x00,0x00,0xff,\n  /* Symbol #='7B'x defined */\n    0x80,0x01,0xff,0x00,0x28,0x28,0x28,0xfe,0x28,0x28,\n    0x28,0xfe,0x28,0x28,0x28,0x00,0x00,0xff,\n  /* Symbol @='7C'x defined */\n    0x80,0x01,0xff,0x00,0x7c,0x82,0x82,0x9e,0xa2,0xa2,\n    0xa2,0xa2,0x9c,0x80,0x7e,0x00,0x00,0xff,\n  /* Symbol '='7D'x defined */\n    0x80,0x01,0xff,0x00,0x10,0x10,0x10,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,\n  /* Symbol =='7E'x defined */\n    0x80,0x01,0xff,0x00,0x00,0x00,0x00,0xfe,0x00,0x00,\n    0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0xff,\n  /* Symbol \"='7F'x defined */\n    0x80,0x01,0xff,0x00,0x28,0x28,0x28,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,\n  /* Symbol '80'x defined */\n    0x02,0x80,0x00,0x00,0x00,0x10,0x44,0x00,0x29,0x54,\n    0x29,0x10,0x82,0x00,0x28,0x00,0x00,0x00,\n  /* Symbol a='81'x defined */\n    0x80,0x01,0xff,0x00,0x00,0x00,0x00,0x00,0x7c,0x02,\n    0x7e,0x82,0x82,0x82,0x7e,0x00,0x00,0xff,\n  /* Symbol b='82'x defined */\n    0x80,0x01,0xff,0x00,0x80,0x80,0x80,0x80,0xf8,0x84,\n    0x82,0x82,0x82,0x84,0xf8,0x00,0x00,0xff,\n  /* Symbol c='83'x defined */\n    0x80,0x01,0xff,0x00,0x00,0x00,0x00,0x00,0x3c,0x42,\n    0x80,0x80,0x80,0x42,0x3c,0x00,0x00,0xff,\n  /* Symbol d='84'x defined */\n    0x80,0x01,0xff,0x00,0x02,0x02,0x02,0x02,0x7e,0x82,\n    0x82,0x82,0x82,0x82,0x7e,0x00,0x00,0xff,\n  /* Symbol e='85'x defined */\n    0x80,0x01,0xff,0x00,0x00,0x00,0x00,0x00,0x7c,0x82,\n    0x82,0xfe,0x80,0x80,0x7e,0x00,0x00,0xff,\n  /* Symbol f='86'x defined */\n    0x80,0x01,0xff,0x00,0x1c,0x20,0x20,0x20,0xf8,0x20,\n    0x20,0x20,0x20,0x20,0x20,0x00,0x00,0xff,\n  /* Symbol g='87'x defined */\n    0x80,0x01,0xff,0x00,0x00,0x00,0x00,0x00,0x78,0x84,\n    0x84,0x84,0x84,0x7c,0x04,0x04,0x38,0xff,\n  /* Symbol h='88'x defined */\n    0x80,0x01,0xff,0x00,0x80,0x80,0x80,0x80,0xf8,0x84,\n    0x84,0x84,0x84,0x84,0x84,0x00,0x00,0xff,\n  /* Symbol i='89'x defined */\n    0x80,0x01,0xff,0x00,0x00,0x10,0x10,0x00,0x10,0x10,\n    0x10,0x10,0x10,0x10,0x10,0x00,0x00,0xff,\n  /* Symbol '8A'x defined */\n    0x00,0x08,0x00,0x00,0x7c,0x44,0x44,0x44,0x44,0x44,\n    0x44,0x44,0x44,0x44,0xff,0x00,0x00,0x00,\n  /* No symbol '8B'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '8C'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '8D'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '8E'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol '8F'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol '90'x defined */\n    0x00,0x08,0x00,0x00,0x7c,0x44,0x44,0x44,0x44,0x44,\n    0x7c,0x7c,0x7c,0x7c,0xff,0x00,0x00,0x00,\n  /* Symbol j='91'x defined */\n    0x80,0x01,0xff,0x00,0x00,0x10,0x10,0x00,0x10,0x10,\n    0x10,0x10,0x10,0x10,0x10,0x10,0x60,0xff,\n  /* Symbol k='92'x defined */\n    0x80,0x01,0xff,0x00,0x80,0x80,0x82,0x84,0x88,0x90,\n    0xa0,0xd0,0x88,0x84,0x82,0x00,0x00,0xff,\n  /* Symbol l='93'x defined */\n    0x80,0x01,0xff,0x00,0x10,0x10,0x10,0x10,0x10,0x10,\n    0x10,0x10,0x10,0x10,0x18,0x00,0x00,0xff,\n  /* Symbol m='94'x defined */\n    0x80,0x01,0xff,0x00,0x00,0x00,0x00,0x00,0x6c,0x92,\n    0x92,0x92,0x92,0x92,0x92,0x00,0x00,0xff,\n  /* Symbol n='95'x defined */\n    0x80,0x01,0xff,0x00,0x00,0x00,0x00,0x00,0xbc,0xc2,\n    0x82,0x82,0x82,0x82,0x82,0x00,0x00,0xff,\n  /* Symbol o='96'x defined */\n    0x80,0x01,0xff,0x00,0x00,0x00,0x00,0x00,0x7c,0x82,\n    0x82,0x82,0x82,0x82,0x7c,0x00,0x00,0xff,\n  /* Symbol p='97'x defined */\n    0x80,0x01,0xff,0x00,0x00,0x00,0x00,0x00,0xf8,0x84,\n    0x82,0x82,0x82,0x84,0xf8,0x80,0x80,0xff,\n  /* Symbol q='98'x defined */\n    0x80,0x01,0xff,0x00,0x00,0x00,0x00,0x00,0x7c,0x84,\n    0x84,0x84,0x84,0x8c,0x74,0x06,0x04,0xff,\n  /* Symbol r='99'x defined */\n    0x80,0x01,0xff,0x00,0x00,0x00,0x00,0x00,0xb8,0xc0,\n    0x80,0x80,0x80,0x80,0x80,0x00,0x00,0xff,\n  /* Symbol '9A'x defined */\n    0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x7c,0x7c,0x7c,0x7c,0xff,0x00,0x00,0x00,\n  /* No symbol '9B'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol '9C'x defined */\n    0x00,0x00,0x1f,0x10,0x10,0x10,0x10,0x10,0x10,0x10,\n    0x10,0x10,0x10,0x18,0x14,0x1a,0x15,0x1f,\n  /* No symbol '9D'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol '9E'x defined */\n    0xc0,0x01,0xf0,0x50,0xb0,0x50,0x30,0x10,0x10,0x10,\n    0x10,0x10,0x10,0x10,0x10,0x10,0x10,0xf0,\n  /* Symbol '9F'x defined */\n    0x9f,0xf9,0xff,0x00,0x00,0xb6,0xb6,0xb6,0xb6,0xb6,\n    0xb6,0xb6,0xb6,0xb6,0xb6,0x00,0x00,0xff,\n  /* No symbol 'A0'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'A1'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol s='A2'x defined */\n    0x80,0x01,0xff,0x00,0x00,0x00,0x00,0x00,0x7c,0x80,\n    0x80,0x78,0x04,0x04,0xf8,0x00,0x00,0xff,\n  /* Symbol t='A3'x defined */\n    0x80,0x01,0xff,0x00,0x20,0x20,0x20,0x20,0xf8,0x20,\n    0x20,0x20,0x20,0x20,0x38,0x00,0x00,0xff,\n  /* Symbol u='A4'x defined */\n    0x80,0x01,0xff,0x00,0x00,0x00,0x00,0x00,0x84,0x84,\n    0x84,0x84,0x84,0x84,0x78,0x00,0x00,0xff,\n  /* Symbol v='A5'x defined */\n    0x80,0x01,0xff,0x00,0x00,0x00,0x00,0x00,0x82,0x82,\n    0x44,0x44,0x28,0x28,0x10,0x00,0x00,0xff,\n  /* Symbol w='A6'x defined */\n    0x80,0x01,0xff,0x00,0x00,0x00,0x00,0x00,0x82,0x82,\n    0x92,0x92,0x92,0xaa,0x44,0x00,0x00,0xff,\n  /* Symbol x='A7'x defined */\n    0x80,0x01,0xff,0x00,0x00,0x00,0x00,0x00,0x82,0x44,\n    0x28,0x10,0x28,0x44,0x82,0x00,0x00,0xff,\n  /* Symbol y='A8'x defined */\n    0x80,0x01,0xff,0x00,0x00,0x00,0x00,0x00,0x82,0x42,\n    0x24,0x14,0x08,0x08,0x10,0x10,0x20,0xff,\n  /* Symbol z='A9'x defined */\n    0x80,0x01,0xff,0x00,0x00,0x00,0x00,0x00,0xfe,0x04,\n    0x08,0x10,0x20,0x40,0xfe,0x00,0x00,0xff,\n  /* No symbol 'AA'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'AB'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'AC'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'AD'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'AE'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'AF'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'B0'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'B1'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'B2'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'B3'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'B4'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'B5'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'B6'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'B7'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'B8'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'B9'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol 'BA'x defined */\n    0x00,0x08,0x00,0x00,0x54,0x00,0x44,0x00,0x44,0x00,\n    0x44,0x00,0x44,0x00,0x55,0x00,0x00,0x00,\n  /* No symbol 'BB'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'BC'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'BD'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'BE'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'BF'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'C0'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol A='C1'x defined */\n    0x80,0x01,0xff,0x00,0x10,0x28,0x44,0x82,0x82,0xfe,\n    0x82,0x82,0x82,0x82,0x82,0x00,0x00,0xff,\n  /* Symbol B='C2'x defined */\n    0x80,0x01,0xff,0x00,0xfc,0x42,0x42,0x42,0x42,0x7c,\n    0x42,0x42,0x42,0x42,0xfc,0x00,0x00,0xff,\n  /* Symbol C='C3'x defined */\n    0x80,0x01,0xff,0x00,0x3c,0x42,0x80,0x80,0x80,0x80,\n    0x80,0x80,0x80,0x42,0x3c,0x00,0x00,0xff,\n  /* Symbol D='C4'x defined */\n    0x80,0x01,0xff,0x00,0xf8,0x44,0x42,0x42,0x42,0x42,\n    0x42,0x42,0x42,0x44,0xf8,0x00,0x00,0xff,\n  /* Symbol E='C5'x defined */\n    0x80,0x01,0xff,0x00,0xfe,0x80,0x80,0x80,0x80,0xf8,\n    0x80,0x80,0x80,0x80,0xfe,0x00,0x00,0xff,\n  /* Symbol F='C6'x defined */\n    0x80,0x01,0xff,0x00,0xfe,0x80,0x80,0x80,0x80,0xf8,\n    0x80,0x80,0x80,0x80,0x80,0x00,0x00,0xff,\n  /* Symbol G='C7'x defined */\n    0x80,0x01,0xff,0x00,0x38,0x44,0x80,0x80,0x80,0x80,\n    0x8e,0x84,0x84,0x44,0x3c,0x00,0x00,0xff,\n  /* Symbol H='C8'x defined */\n    0x80,0x01,0xff,0x00,0x82,0x82,0x82,0x82,0x82,0xfe,\n    0x82,0x82,0x82,0x82,0x82,0x00,0x00,0xff,\n  /* Symbol I='C9'x defined */\n    0x80,0x01,0xff,0x00,0x7c,0x10,0x10,0x10,0x10,0x10,\n    0x10,0x10,0x10,0x10,0x7c,0x00,0x00,0xff,\n  /* Symbol 'CA'x defined */\n    0x00,0x08,0x00,0x00,0x54,0x00,0x44,0x00,0x44,0x00,\n    0x54,0x28,0x54,0x28,0x55,0x00,0x00,0x00,\n  /* Symbol 'CB'x defined */\n    0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x54,0x28,0x54,0x28,0x55,0x00,0x00,0x00,\n  /* No symbol 'CC'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol 'CD'x defined */\n    0xff,0xff,0xff,0x00,0x02,0x06,0x0e,0x1e,0x3e,0x7e,\n    0x3e,0x1e,0x0e,0x06,0x02,0x00,0x00,0xff,\n  /* No symbol 'CE'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol 'CF'x defined */\n    0x80,0x01,0xff,0x01,0x81,0xc1,0xe1,0xf1,0xf9,0xfd,\n    0xf9,0xf1,0xe1,0xc1,0x81,0x01,0x01,0xff,\n  /* No symbol 'D0'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol J='D1'x defined */\n    0x80,0x01,0xff,0x00,0x1c,0x08,0x08,0x08,0x08,0x08,\n    0x08,0x08,0x88,0x48,0x30,0x00,0x00,0xff,\n  /* Symbol K='D2'x defined */\n    0x80,0x01,0xff,0x00,0x82,0x84,0x88,0x90,0xa0,0xc0,\n    0xa0,0x90,0x88,0x84,0x82,0x00,0x00,0xff,\n  /* Symbol L='D3'x defined */\n    0x80,0x01,0xff,0x00,0x80,0x80,0x80,0x80,0x80,0x80,\n    0x80,0x80,0x80,0x80,0xfe,0x00,0x00,0xff,\n  /* Symbol M='D4'x defined */\n    0x80,0x01,0xff,0x00,0x82,0xc6,0xaa,0xaa,0x92,0x92,\n    0x82,0x82,0x82,0x82,0x82,0x00,0x00,0xff,\n  /* Symbol N='D5'x defined */\n    0x80,0x01,0xff,0x00,0x82,0xc2,0xa2,0xa2,0x92,0x92,\n    0x92,0x8a,0x8a,0x86,0x82,0x00,0x00,0xff,\n  /* Symbol O='D6'x defined */\n    0x80,0x01,0xff,0x00,0x7c,0x82,0x82,0x82,0x82,0x82,\n    0x82,0x82,0x82,0x82,0x7c,0x00,0x00,0xff,\n  /* Symbol P='D7'x defined */\n    0x80,0x01,0xff,0x00,0xf8,0x84,0x82,0x82,0x84,0xf8,\n    0x80,0x80,0x80,0x80,0x80,0x00,0x00,0xff,\n  /* Symbol Q='D8'x defined */\n    0x80,0x01,0xff,0x00,0x38,0x44,0x82,0x82,0x82,0x82,\n    0x82,0x82,0x92,0x54,0x38,0x04,0x00,0xff,\n  /* Symbol R='D9'x defined */\n    0x80,0x01,0xff,0x00,0xf8,0x84,0x82,0x82,0x84,0xf8,\n    0xa0,0x90,0x88,0x84,0x82,0x00,0x00,0xff,\n  /* Symbol 'DA'x defined */\n    0xff,0xff,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,\n    0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,\n  /* Symbol 'DB'x defined */\n    0xff,0xff,0x7d,0x7d,0x7d,0x7d,0x7d,0x7d,0x7d,0x7d,\n    0x7d,0x7d,0x7d,0x7d,0x7d,0x7d,0x7d,0x7d,\n  /* Symbol 'DC'x defined */\n    0xff,0xff,0xff,0x01,0x01,0x11,0x11,0x11,0x39,0x39,\n    0x39,0x7d,0x7d,0x7d,0x01,0x01,0x01,0x01,\n  /* Symbol 'DD'x defined */\n    0xff,0xff,0x01,0x01,0x01,0x01,0x7d,0x7d,0x7d,0x39,\n    0x39,0x39,0x11,0x11,0x11,0x01,0x01,0xff,\n  /* Symbol 'DE'x defined */\n    0xff,0xff,0xff,0x01,0x01,0x39,0x39,0x39,0x39,0x39,\n    0x39,0x7d,0x39,0x39,0x11,0x11,0x01,0xff,\n  /* Symbol 'DF'x defined */\n    0xff,0xff,0xff,0x01,0x01,0x01,0x01,0x01,0x01,0x01,\n    0x01,0x01,0x55,0x55,0x01,0x01,0x01,0xff,\n  /* No symbol 'E0'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'E1'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* Symbol S='E2'x defined */\n    0x80,0x01,0xff,0x00,0x38,0x44,0x82,0x80,0x40,0x38,\n    0x04,0x02,0x82,0x44,0x38,0x00,0x00,0xff,\n  /* Symbol T='E3'x defined */\n    0x80,0x01,0xff,0x00,0xfe,0x10,0x10,0x10,0x10,0x10,\n    0x10,0x10,0x10,0x10,0x10,0x00,0x00,0xff,\n  /* Symbol U='E4'x defined */\n    0x80,0x01,0xff,0x00,0x82,0x82,0x82,0x82,0x82,0x82,\n    0x82,0x82,0x82,0x82,0x7c,0x00,0x00,0xff,\n  /* Symbol V='E5'x defined */\n    0x80,0x01,0xff,0x00,0x82,0x82,0x82,0x44,0x44,0x44,\n    0x28,0x28,0x28,0x10,0x10,0x00,0x00,0xff,\n  /* Symbol W='E6'x defined */\n    0x80,0x01,0xff,0x00,0x82,0x82,0x82,0x82,0x82,0x92,\n    0x92,0x92,0x92,0x92,0x6c,0x00,0x00,0xff,\n  /* Symbol X='E7'x defined */\n    0x80,0x01,0xff,0x00,0x82,0x82,0x44,0x44,0x28,0x10,\n    0x28,0x44,0x44,0x82,0x82,0x00,0x00,0xff,\n  /* Symbol Y='E8'x defined */\n    0x80,0x01,0xff,0x00,0x82,0x82,0x44,0x44,0x28,0x10,\n    0x10,0x10,0x10,0x10,0x10,0x00,0x00,0xff,\n  /* Symbol Z='E9'x defined */\n    0x80,0x01,0xff,0x00,0xfe,0x02,0x04,0x04,0x08,0x10,\n    0x20,0x40,0x40,0x80,0xfe,0x00,0x00,0xff,\n  /* Symbol 'EA'x defined */\n    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,\n    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,\n  /* Symbol 'EB'x defined */\n    0x80,0x01,0xff,0x00,0x00,0x22,0x22,0x66,0x66,0xee,\n    0x66,0x66,0x22,0x22,0x00,0x00,0x00,0xff,\n  /* Symbol 'EC'x defined */\n    0x80,0x01,0xff,0x00,0x00,0x88,0x88,0xcc,0xcc,0xee,\n    0xcc,0xcc,0x88,0x88,0x00,0x00,0x00,0xff,\n  /* Symbol 'ED'x defined */\n    0xff,0xff,0x01,0x11,0x11,0x39,0x39,0x7d,0x7d,0x01,\n    0x11,0x11,0x39,0x39,0x7d,0x7d,0x01,0x01,\n  /* Symbol 'EE'x defined */\n    0xff,0xff,0x01,0x01,0x7d,0x7d,0x39,0x39,0x11,0x11,\n    0x01,0x7d,0x7d,0x39,0x39,0x11,0x11,0x01,\n  /* Symbol 'EF'x defined */\n    0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,\n  /* Symbol 0='F0'x defined */\n    0x80,0x01,0xff,0x00,0x7c,0x82,0x82,0x82,0x92,0x92,\n    0x92,0x82,0x82,0x82,0x7c,0x00,0x00,0xff,\n  /* Symbol 1='F1'x defined */\n    0x80,0x01,0xff,0x00,0x10,0x30,0x10,0x10,0x10,0x10,\n    0x10,0x10,0x10,0x10,0x38,0x00,0x00,0xff,\n  /* Symbol 2='F2'x defined */\n    0x80,0x01,0xff,0x00,0x7c,0x82,0x02,0x02,0x04,0x08,\n    0x10,0x20,0x40,0x80,0xfe,0x00,0x00,0xff,\n  /* Symbol 3='F3'x defined */\n    0x80,0x01,0xff,0x00,0x7c,0x82,0x02,0x02,0x04,0x38,\n    0x04,0x02,0x02,0x82,0x7c,0x00,0x00,0xff,\n  /* Symbol 4='F4'x defined */\n    0x80,0x01,0xff,0x00,0x08,0x18,0x28,0x48,0x88,0xfe,\n    0x08,0x08,0x08,0x08,0x08,0x00,0x00,0xff,\n  /* Symbol 5='F5'x defined */\n    0x80,0x01,0xff,0x00,0xfe,0x80,0x80,0x80,0xfc,0x02,\n    0x02,0x02,0x82,0x44,0x38,0x00,0x00,0xff,\n  /* Symbol 6='F6'x defined */\n    0x80,0x01,0xff,0x00,0x1c,0x22,0x40,0x80,0x80,0xbc,\n    0xc2,0x82,0x82,0x82,0x7c,0x00,0x00,0xff,\n  /* Symbol 7='F7'x defined */\n    0x80,0x01,0xff,0x00,0xfe,0x02,0x04,0x04,0x08,0x08,\n    0x10,0x10,0x10,0x20,0x20,0x00,0x00,0xff,\n  /* Symbol 8='F8'x defined */\n    0x80,0x01,0xff,0x00,0x7c,0x82,0x82,0x82,0x44,0x38,\n    0x44,0x82,0x82,0x82,0x7c,0x00,0x00,0xff,\n  /* Symbol 9='F9'x defined */\n    0x80,0x01,0xff,0x00,0x7c,0x82,0x82,0x82,0x7e,0x02,\n    0x02,0x02,0x02,0x44,0x38,0x00,0x00,0xff,\n  /* No symbol 'FA'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'FB'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'FC'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'FD'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'FE'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n  /* No symbol 'FF'x defined */\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00\n  } ;\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "SYM9X12U": {"ttr": 6914, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00\\x00\\x00\\x95%_\\x00\\x95(\\x9f\\x19(\\x0b\\x10\\x08\\xbd\\x00\\x00\\xe2\\xc1\\xe2\\xc4\\xc4\\xc6@@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "1995-09-12T00:00:00", "modifydate": "1995-10-16T19:28:00", "lines": 2832, "newlines": 2237, "modlines": 0, "user": "SASDDF"}, "text": ".....................................................................\n. Program:   SYM9X12U\n. Support:   David Fahey\n. Language:  SYMDEF\n. Date:      3Sep95\n. Purpose:   This file contains a 3270 character map for 9 by 12 under\n.            and over lined font.\n. Notes:\n.\n. The format of this file is as follows:\n.   Column one is a record identifier where dot(.) indicates a comment\n.   at plus(+) indicates the hex character code for the following bit\n.   map, and a colon(:) indicates a character cell pattern. Character\n.   cells are all 9 by 16, so 16 colon lines are required for each\n.   character. The format of colon and plus lines is fixed.\n.   1. A comment line can only appear any where.\n.   2. A plus line must be followed with 2 characters that are the\n.      hex representation of a character that the symbol defined after\n.      it will use. the range allowed is 41 to fe inclusive.\n.   3. A colon line has the following format:\n.        : . . . . . . . . .\n.      This indicates 9 pel positions accross the character, here all\n.      are turned off. an x is used to indicate that the pel is\n.      turned on. for example:\n.        : X X X X . . . . .\n.      Here the first four pels atr turned on, and the last five are\n.      off. there must be one, and only one blank character between each\n.      pel indicator, and also one blank following the colon.\n.      Note: The bit positions must only be  in dicated using\n.            The upper case X and the dot.\n.   4. Characters that are not specified are stored as if all\n.      pels were off.\n.   5. Symbol order is not important.\n.\n.\n. The letter a would be sent to the ps device as a type 1 symbol\n. with thw bit string: X'00000000102844828282FE82828282000000'\n.\n.....................................................................\n+C1 --- A\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . X . . . .\n: . . . X . X . . .\n: . . X . . . X . .\n: . X . . . . . X .\n: . X X X X X X X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+C2   --- B\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X X X X X X . .\n: . . X . . . . X .\n: . . X . . . . X .\n: . . X X X X X . .\n: . . X . . . . X .\n: . . X . . . . X .\n: . . X . . . . X .\n: . X X X X X X . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+C3   --- C\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . X X X X . .\n: . . X . . . . X .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . . X . . . . X .\n: . . . X X X X . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+C4   --- D\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X X X X X . . .\n: . . X . . . X . .\n: . . X . . . . X .\n: . . X . . . . X .\n: . . X . . . . X .\n: . . X . . . . X .\n: . . X . . . X . .\n: . X X X X X . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+C5   --- E\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X X X X X X X .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X X X X X . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X X X X X X X .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+C6   --- F\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X X X X X X X .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X X X X X . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+C7   --- G\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . X X X . . .\n: . . X . . . X . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . X X X .\n: . X . . . . X . .\n: . . X . . . X . .\n: . . . X X X X . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+C8   --- H\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X X X X X X X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+C9   --- I\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . X X X X X . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . X X X X X . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+D1   --- J\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . X X X . .\n: . . . . . X . . .\n: . . . . . X . . .\n: . . . . . X . . .\n: . . . . . X . . .\n: . X . . . X . . .\n: . . X . . X . . .\n: . . . X X . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+D2   --- K\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X . . . . X . .\n: . X . . . X . . .\n: . X . . X . . . .\n: . X . X . . . . .\n: . X X X . . . . .\n: . X . . X . . . .\n: . X . . . X . . .\n: . X . . . . X . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+D3   --- L\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X X X X X X X .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+D4   --- M\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X . . . . . X .\n: . X X . . . X X .\n: . X . X . X . X .\n: . X . X . X . X .\n: . X . . X . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+D5   --- N\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X . . . . . X .\n: . X X . . . . X .\n: . X . X . . . X .\n: . X . . X . . X .\n: . X . . X . . X .\n: . X . . . X . X .\n: . X . . . . X X .\n: . X . . . . . X .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+D6   --- O\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . X X X X X . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . X X X X X . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+D7   --- P\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X X X X X . . .\n: . X . . . . X . .\n: . X . . . . X . .\n: . X X X X X . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+D8   --- Q\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . X X X . . .\n: . . X . . . X . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . X . . X .\n: . . X . X . X . .\n: . . . X X X . . .\n: . . . . . . X . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+D9   --- R\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X X X X X . . .\n: . X . . . . X . .\n: . X . . . . X . .\n: . X X X X X . . .\n: . X . X . . . . .\n: . X . . X . . . .\n: . X . . . X . . .\n: . X . . . . X . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+E2   --- S\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . X X X . . .\n: . . X . . . X . .\n: . . X . . . . . .\n: . . . X X X . . .\n: . . . . . . X . .\n: . . . . . . X . .\n: . . X . . . X . .\n: . . . X X X . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+E3   --- T\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X X X X X X X .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+E4   --- U\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . X X X X X . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+E5   --- V\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . X . . . X . .\n: . . X . . . X . .\n: . . . X . X . . .\n: . . . X . X . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+E6   --- W\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . X . . X .\n: . X . . X . . X .\n: . X . . X . . X .\n: . X . . X . . X .\n: . . X X . X X . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+E7   --- X\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X . . . . . X .\n: . . X . . . X . .\n: . . . X . X . . .\n: . . . . X . . . .\n: . . . X . X . . .\n: . . X . . . X . .\n: . . X . . . X . .\n: . X . . . . . X .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+E8   --- Y\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X . . . . . X .\n: . . X . . . X . .\n: . . . X . X . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+E9   --- Z\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X X X X X X X .\n: . . . . . . . X .\n: . . . . . . X . .\n: . . . . . X . . .\n: . . . . X . . . .\n: . . . X . . . . .\n: . . X . . . . . .\n: . X X X X X X X .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+4E\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . X X X X X X X .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+41\n. 1 2 3 4 5 6 7 8 9\n: . X X . X X X X X\n: X . . . . . . . .\n: . X . . . . . . .\n: . . X . X . . . .\n: X X . X . X . . .\n: . . . X X X . . .\n: . . . X . X . X X\n: . . . . . . X . .\n: . . . . . . . X .\n: . . . . . . . . X\n: . . . . . . X X .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+81   --- a\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X X X X X . .\n: . . . . . . . X .\n: . . X X X X X X .\n: . X . . . . . X .\n: . . X X X X X X .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+82   --- b\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X X X X X . . .\n: . X . . . . X . .\n: . X . . . . X . .\n: . X . . . . X . .\n: . X X X X X . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+83   --- c\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X X X X X . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . . X X X X X . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+84   --- d\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . X .\n: . . . . . . . X .\n: . . . . . . . X .\n: . . X X X X X X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . X X X X X X .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+85   --- e\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X X X X X . .\n: . X . . . . . X .\n: . X X X X X X X .\n: . X . . . . . . .\n: . . X X X X X X .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+86   --- f\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . X X X . .\n: . . . X . . . . .\n: . . . X . . . . .\n: . X X X X X . . .\n: . . . X . . . . .\n: . . . X . . . . .\n: . . . X . . . . .\n: . . . X . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+87   --- g\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X X X X . . .\n: . X . . . . X . .\n: . X . . . . X . .\n: . . X X X X X . .\n: . . . . . . X . .\n: . . . X X X . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+88   --- h\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X X X X X . . .\n: . X . . . . X . .\n: . X . . . . X . .\n: . X . . . . X . .\n: . X . . . . X . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+89   --- i\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+91   --- j\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . X X . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+92   --- k\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . X . . .\n: . X . . X . . . .\n: . X . X . . . . .\n: . X X . X . . . .\n: . X . . . X . . .\n: . X . . . . X . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+93   --- l\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X X . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+94   --- m\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X X . X X . .\n: . X . . X . . X .\n: . X . . X . . X .\n: . X . . X . . X .\n: . X . . X . . X .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+95   --- n\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . X . X X X X . .\n: . X X . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+96   --- o\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X X X X X . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . X X X X X . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+97   --- p\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . X X X X X . . .\n: . X . . . . X . .\n: . X . . . . . X .\n: . X . . . . X . .\n: . X X X X X . . .\n: . X . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+98   --- q\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X X X X X . .\n: . X . . . . X . .\n: . X . . . . X . .\n: . X . . . X X . .\n: . . X X X . X . .\n: . . . . . . X X .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+99   --- r\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . X . X X X . . .\n: . X X . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+A2   --- s\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X X X X X . .\n: . X . . . . . . .\n: . . X X X X . . .\n: . . . . . . X . .\n: . X X X X X . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+A3   --- t\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . X . . . . .\n: . . . X . . . . .\n: . . . X . . . . .\n: . X X X X X . . .\n: . . . X . . . . .\n: . . . X . . . . .\n: . . . X . . . . .\n: . . . X X X . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+A4   --- u\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . X . . . . X . .\n: . X . . . . X . .\n: . X . . . . X . .\n: . X . . . . X . .\n: . . X X X X . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+A5   --- v\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . X . . . . . X .\n: . . X . . . X . .\n: . . X . . . X . .\n: . . . X . X . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+A6   --- w\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . X . . X .\n: . X . X . X . X .\n: . . X . . . X . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+A7   --- x\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X . . . X . .\n: . . . X . X . . .\n: . . . . X . . . .\n: . . . X . X . . .\n: . . X . . . X . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+A8   --- y\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X . . . . X .\n: . . . X . . . X .\n: . . . . X . X . .\n: . . . . . X . . .\n: . . . . X . . . .\n: . . . X . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+A9   --- z\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X X X X X . .\n: . . . . . X . . .\n: . . . . X . . . .\n: . . . X . . . . .\n: . . X X X X X . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+F0\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . X X X X X . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . X . . X .\n: . X . . X . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . X X X X X . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+F1   --- 1\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . X . . . .\n: . . . X X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . X X X . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+F2   --- 2\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . X X X X X . .\n: . X . . . . . X .\n: . . . . . . X . .\n: . . . . . X . . .\n: . . . . X . . . .\n: . . . X . . . . .\n: . . X . . . . . .\n: . X X X X X X X .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+F3   --- 3\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X X X X X X X .\n: . . . . . . . X .\n: . . . . . . X . .\n: . . . X X X . . .\n: . . . . . . X . .\n: . . . . . . . X .\n: . X . . . . . X .\n: . . X X X X X . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+F4   --- 4\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . X . . .\n: . . . . X X . . .\n: . . . X . X . . .\n: . . X . . X . . .\n: . X . . . X . . .\n: . X X X X X X X .\n: . . . . . X . . .\n: . . . . . X . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+F5   --- 5\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X X X X X X X .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X X X X X X . .\n: . . . . . . . X .\n: . . . . . . . X .\n: . . X . . . X . .\n: . . . X X X . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+F6   --- 6\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . X X X X X . .\n: . X . . . . . X .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X X X X X X . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . X X X X X . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+F7   --- 7\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X X X X X X X .\n: . . . . . . . X .\n: . . . . . . X . .\n: . . . . . X . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+F8   --- 8\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . X X X X X . .\n: . X . . . . . X .\n: . . X . . . X . .\n: . . . X X X . . .\n: . . X . . . X . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . X X X X X . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+F9\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . X X X X X . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . X X X X X X .\n: . . . . . . . X .\n: . . . . . . . X .\n: . . X . . . X . .\n: . . . X X X . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+4A   --- CENT\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . X . . . .\n: . . X X X X X . .\n: . X . . X . . X .\n: . X . . X . . . .\n: . X . . X . . . .\n: . X . . X . . X .\n: . . X X X X X . .\n: . . . . X . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+4B   --- .\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X X . . . . .\n: . . X X . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+4C   --- <\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . X . . .\n: . . . . X . . . .\n: . . . X . . . . .\n: . . X . . . . . .\n: . . X . . . . . .\n: . . . X . . . . .\n: . . . . X . . . .\n: . . . . . X . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+4D   --- (\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . X . . . .\n: . . . X . . . . .\n: . . X . . . . . .\n: . . X . . . . . .\n: . . X . . . . . .\n: . . X . . . . . .\n: . . . X . . . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+4F   --- |\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+50   --- &\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . X X X . . . .\n: . X . . . X . . .\n: . . X . X . . . .\n: . . X X X . . . .\n: . X . . . X . X .\n: . X . . . . X . .\n: . X . . . X . X .\n: . . X X X . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+5A   --- !\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+5B   --- $\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . X . . . .\n: . . . X X X X . .\n: . . X . X . . . .\n: . . . X X X . . .\n: . . . . X . X . .\n: . . X . X . X . .\n: . . . X X X . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+7F   --- \"\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . X . X . . .\n: . . . X . X . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+5D   --- )\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . X . . . .\n: . . . . . X . . .\n: . . . . . . X . .\n: . . . . . . X . .\n: . . . . . . X . .\n: . . . . . . X . .\n: . . . . . X . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+5E   --- ;\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X X . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X X . . . . .\n: . . X X . . . . .\n: . . X . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+7A   --- :\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X X . . . . .\n: . . X X . . . . .\n: . . . . . . . . .\n: . . X X . . . . .\n: . . X X . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+5F   --- \u00ac\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . X X X X X . . .\n: . . . . . X . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+60   --- -\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . X X X X X X X .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+61   --- /\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . X .\n: . . . . . . X . .\n: . . . . . X . . .\n: . . . . X . . . .\n: . . . X . . . . .\n: . . X . . . . . .\n: . X . . . . . . .\n: X . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+6B   --- ,\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X X . . . . .\n: . . X X . . . . .\n: . . X . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+6C   --- %\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . X X . . . X .\n: . X . . X . X . .\n: . . X X . X . . .\n: . . . . X . . . .\n: . . . X . . . . .\n: . . . X . X X . .\n: . . X . X . . X .\n: . X . . . X X . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+6D   --- _\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+6E   --- >\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . X . . . . . .\n: . . . X . . . . .\n: . . . . X . . . .\n: . . . . . X . . .\n: . . . . . X . . .\n: . . . . X . . . .\n: . . . X . . . . .\n: . . X . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+6F   --- ?\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . X X X . . .\n: . . X . . . X . .\n: . . . . . . X . .\n: . . . . . X . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+7B   --- #\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . X . X . . .\n: . . . X . X . . .\n: . X X X X X X X .\n: . . . X . X . . .\n: . . . X . X . . .\n: . X X X X X X X .\n: . . . X . X . . .\n: . . . X . X . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+7C   --- @\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . X X X X X . .\n: . X . . . . . X .\n: . X . . X X X X .\n: . X . X . . . X .\n: . X . X . . . X .\n: . X . . X X X . .\n: . X . . . . . . .\n: . . X X X X X X .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+7D   --- '\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+7E   --- =\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . X X X X X X X .\n: . . . . . . . . .\n: . X X X X X X X .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+5C   --- *\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . X . . . .\n: . . X . X . X . .\n: . . . X X X . . .\n: . X X X X X X X .\n: . . . X X X . . .\n: . . X . X . X . .\n: . . . . X . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+42   --- LEFT END\n. 1 2 3 4 5 6 7 8 9\n: . . . . X X X X X\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+43   --- RIGHT END\n. 1 2 3 4 5 6 7 8 9\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+44   --- OTHER RIGHT END\n. 1 2 3 4 5 6 7 8 9\n: X X X X X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: X X X X X . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+45   --- UP ARROW\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: X X X X X X X X X\n: X . . . X . . . X\n: X . . . X . . . X\n: X . . . X . . . X\n: X X X X X . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X X X X X X X X X\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+46   --- DOWN ARROW\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: X X X X X . . . .\n: X . . . X . . . .\n: X . . . X . . . .\n: X . . . X . . . .\n: X X X X X . . . .\n: . . . . . . X X X\n: . . . . . . X X X\n: . . . . . . X X X\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+47   --- 3D MINUS SIGN\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X X . X X . X X\n: . X X . X X . X X\n: . . . . . . . . .\n: . . X X . . X X .\n: . . X X . . X X .\n: . . . . . . . . .\n: . . . . X X . . .\n: . . . . X X . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+48   --- BLANK REPLACEMENT\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+49   --- TOP LEFT WINDOW BORDER\n. 1 2 3 4 5 6 7 8 9\n: . . . . X X X X X\n: . . . . X . X . X\n: . . . . X X . X .\n: . . . . X . X . .\n: . . . . X X . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+51   --- BOTTOM RIGHT WINDOW BORDER\n. 1 2 3 4 5 6 7 8 9\n: X X X X X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . X X . . . .\n: . . X . X . . . .\n: . X . X X . . . .\n: X . X . X . . . .\n: X X X X X . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+52   --- WINDOW CONTROL FOR TERNINATE WINDOW\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X . . . . . X .\n: . X X . . . X X .\n: . X X X . X X X .\n: . . X X X X X . .\n: . . X X X X X . .\n: . X X X . X X X .\n: . X X . . . X X .\n: . X . . . . . X .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+53   --- RADIO BUTTON - ON\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . X X X . . .\n: . . X . . . X . .\n: . X . . . . . X .\n: X . . X X X . . X\n: X . X X X X X . X\n: X . X X X X X . X\n: X . . X X X . . X\n: . X . . . . . X .\n: . . X . . . X . .\n: . . . X X X . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+54   --- RADIO BUTTON - OFF\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . X X X . . .\n: . . X . . . X . .\n: . X . . . . . X .\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: . X . . . . . X .\n: . . X . . . X . .\n: . . . X X X . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+55   --- CHECK BOX - ON\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: X X X X X X X X X\n: X X . . . . . X X\n: X . X . . . X . X\n: X . . X . X . . X\n: X . . . X . . . X\n: X . . X . X . . X\n: X . X . . . X . X\n: X X . . . . . X X\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+56   --- CHECK BOX - OFF\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: X X X X X X X X X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+57   --- CHECK BOX - UNDEFINED STATE\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: X . X . X . X . X\n: . . . . . . . . .\n: X . . . . . . . X\n: . . . . . . . . .\n: X . . . . . . . X\n: . . . . . . . . .\n: X . . . . . . . X\n: . . . . . . . . .\n: X . X . X . X . X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+58   --- BAR GRAPH - MIDDLE FULL\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: X X X X X X X X X\n: X X X X X X X X X\n: X X X X X X X X X\n: X X X X X X X X X\n: X X X X X X X X X\n: X X X X X X X X X\n: X X X X X X X X X\n: X X X X X X X X X\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+59   --- BAR GRAPH - START FULL\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: X . . . . . . . .\n: X . X X X X X X X\n: X . X X X X X X X\n: X . X X X X X X X\n: X . X X X X X X X\n: X . X X X X X X X\n: X . X X X X X X X\n: X . X X X X X X X\n: X . X X X X X X X\n: X . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+62   --- BAR GRAPH - END FULL\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . X\n: X X X X X X X . X\n: X X X X X X X . X\n: X X X X X X X . X\n: X X X X X X X . X\n: X X X X X X X . X\n: X X X X X X X . X\n: X X X X X X X . X\n: X X X X X X X . X\n: . . . . . . . . X\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+63   --- BAR GRAPH - END EMPTY\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . X\n: . . . . . . . . X\n: . . . . . . . . X\n: . . . . . . . . X\n: . . . . . . . . X\n: . . . . . . . . X\n: . . . . . . . . X\n: . . . . . . . . X\n: . . . . . . . . X\n: . . . . . . . . X\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+64   --- BAR GRAPH - START EMPTY\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+65   --- BAR GRAPH - MIDDLE EMPTY\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+66   --- LEFT TOP CORNER\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . X X X X X\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+67   --- LEFT BOTTOM CORNER\n. 1 2 3 4 5 6 7 8 9\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+68   --- RIGHT TOP CORNER\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+69   --- RIGHT BOTTOM CORNER\n. 1 2 3 4 5 6 7 8 9\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: X X X X X . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+70   --- FLAT LINE - HORIZONTAL\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+71   --- FLAT LINE - VERTICAL\n. 1 2 3 4 5 6 7 8 9\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+72   --- VERTICAL LINE\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+73   --- RADIO BUTTON - NOT DEFINED\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . X . . . .\n: . . X . . . X . .\n: . . . . . . . . .\n: X . . . . . . . X\n: . . . . . . . . .\n: X . . . . . . . X\n: . . . . . . . . .\n: . X . . . . . X .\n: . . . . . . . . .\n: . . . X . X . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+74   --- CHECK BOX - ON - GRAYED\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: X . X . X . X . X\n: . X . . . . . X .\n: X . X . . . X . X\n: . . . X . X . . .\n: X . . . X . . . X\n: . . . X . X . . .\n: X . X . . . X . X\n: . X . . . . . X .\n: X . X . X . X . X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+75   --- CHECK BOX - UNDEFINED\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: X X X X X X X X X\n: X . . . . . . . X\n: X . X . . . X . X\n: X . . . . . . . X\n: X . . . X . . . X\n: X . . . . . . . X\n: X . X . . . X . X\n: X . . . . . . . X\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+76   --- CHECK BOX - GRAYED - UNDEFINED STATE\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: X . X . X . X . X\n: . . . . . . . . .\n: X . X . . . X . X\n: . . . . . . . . .\n: X . . . X . . . X\n: . . . . . . . . .\n: X . X . . . X . X\n: . . . . . . . . .\n: X . X . X . X . X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+77   --- RADIO BUTTON - ON - GRAYED\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . X . . . .\n: . . X . . . X . .\n: . . . . . . . . .\n: X . . X X X . . X\n: . . X X X X X . .\n: X . X X X X X . X\n: . . . X X X . . .\n: . X . . . . . X .\n: . . . . . . . . .\n: . . . X . X . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+78   --- RADIO BUTTON - UNDEFINED\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . X X X . . .\n: . . X . . . X . .\n: . X . . . . . X .\n: X . . X . X . . X\n: X . X . X . X . X\n: X . . X . X . . X\n: X . . . X . . . X\n: . X . . . . . X .\n: . . X . . . X . .\n: . . . X X X . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+80   --- RADIO BUTTON - UNDEFINED - GRAYED\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . X . . . .\n: . . X . . . X . .\n: . . . . . . . . .\n: X . . X . X . . X\n: . . X . X . X . .\n: X . . X . X . . X\n: . . . . X . . . .\n: . X . . . . . X .\n: . . . . . . . . .\n: . . . X . X . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+8A   --- BUTTON NOT PRESSED\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X X X X X . .\n: . . X . . . X . .\n: . . X . . . X . .\n: . . X . . . X . .\n: . . X . . . X . .\n: . . X . . . X . .\n: . . X . . . X . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+90   --- BUTTON INDETERMINATE\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X X X X X . .\n: . . X . . . X . .\n: . . X . . . X . .\n: . . X . . . X . .\n: . . X . . . X . .\n: . . X X X X X . .\n: . . X X X X X . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+9A   --- BUTTON PRESSED\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X X X X X . .\n: . . X X X X X . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+BA   --- BUTTON NOT PRESSED - GRAY\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X . X . X . .\n: . . X . . . X . .\n: . . . . . . . . .\n: . . X . . . X . .\n: . . . . . . . . .\n: . . X . . . X . .\n: . . . . . . . . .\n: X . X . X . X . X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+CA   --- BUTTON INDETERMINATE - GRAY\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X . X . X . .\n: . . X . . . X . .\n: . . . . . . . . .\n: . . X . . . X . .\n: . . . . . . . . .\n: . . X . X . X . .\n: . . . X . X . . .\n: X . X . X . X . X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+CB   --- BUTTON PRESSED - GRAY\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X . X . X . .\n: . . . X . X . . .\n: X . X . X . X . X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+CD   --- LEFT HORIZONTAL SCROLL ARROW\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: X . . . . . . . .\n: X . . . . . X . .\n: X . . . . X X . .\n: X . . . X X X . .\n: X . . X X X X . .\n: X . . X X X X . .\n: X . . . X X X . .\n: X . . . . X X . .\n: X . . . . . X . .\n: X . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+CF   --- RIGHT HORIZONTAL SCROLL ARROW\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . X\n: . . X . . . . . X\n: . . X X . . . . X\n: . . X X X . . . X\n: . . X X X X . . X\n: . . X X X X . . X\n: . . X X X . . . X\n: . . X X . . . . X\n: . . X . . . . . X\n: . . . . . . . . X\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+DA   --- VERTICAL SCROLL BAR CHAR\n. 1 2 3 4 5 6 7 8 9\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+DB   --- VERTICAL SCROLL BAR THUMB\n. 1 2 3 4 5 6 7 8 9\n: X . X X X X X . X\n: X . X X X X X . X\n: X . X X X X X . X\n: X . X X X X X . X\n: X . X X X X X . X\n: X . X X X X X . X\n: X . X X X X X . X\n: X . X X X X X . X\n: X . X X X X X . X\n: X . X X X X X . X\n: X . X X X X X . X\n: X . X X X X X . X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+DC   --- VERTICAL SCROLL BAR TOP ARROW\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: X . . . . . . . X\n: X . . . X . . . X\n: X . . . X . . . X\n: X . . . X . . . X\n: X . . X X X . . X\n: X . . X X X . . X\n: X . . X X X . . X\n: X . X X X X X . X\n: X . X X X X X . X\n: X . X X X X X . X\n: X . . . . . . . X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+DD   --- VERTICAL SCROLL BAR BOTTOM ARROW\n. 1 2 3 4 5 6 7 8 9\n: X . . . . . . . X\n: X . X X X X X . X\n: X . X X X X X . X\n: X . X X X X X . X\n: X . . X X X . . X\n: X . . X X X . . X\n: X . . X X X . . X\n: X . . . X . . . X\n: X . . . X . . . X\n: X . . . X . . . X\n: X . . . . . . . X\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+DE   --- COMBO BOX DROP DOWN CONTROL\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: X . . . . . . . X\n: X . . X X X . . X\n: X . . X X X . . X\n: X . . X X X . . X\n: X . . X X X . . X\n: X . . X X X . . X\n: X . X X X X X . X\n: X . . X X X . . X\n: X . . . X . . . X\n: X . . . . . . . X\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+DF   --- ELIPSIS CONTROL\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . X . X . X . X\n: X . X . X . X . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+EA   --- FILLED CELL\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: X X X X X X X X X\n: X X X X X X X X X\n: X X X X X X X X X\n: X X X X X X X X X\n: X X X X X X X X X\n: X X X X X X X X X\n: X X X X X X X X X\n: X X X X X X X X X\n: X X X X X X X X X\n: X X X X X X X X X\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+EB   --- HORIZONTAL SCROLL LEFT PAGE ARROW\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . X . . . X .\n: . . . X . . . X .\n: . . X X . . X X .\n: . X X X . X X X .\n: . . X X . . X X .\n: . . . X . . . X .\n: . . . X . . . X .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+EC   --- HORIZONTAL SCROLL RIGHT PAGE ARROW\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X . . . X . . .\n: . X . . . X . . .\n: . X X . . X X . .\n: . X X X . X X X .\n: . X X . . X X . .\n: . X . . . X . . .\n: . X . . . X . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+ED   --- VERTICAL SCROLL BAR SCROLL UP PAGE ARROW\n. 1 2 3 4 5 6 7 8 9\n: X . . . . . . . X\n: X . . . X . . . X\n: X . . . X . . . X\n: X . . X X X . . X\n: X . X X X X X . X\n: X . . . . . . . X\n: X . . . X . . . X\n: X . . . X . . . X\n: X . . X X X . . X\n: X . X X X X X . X\n: X . . . . . . . X\n: X . . . . . . . X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+EE   --- VERTICAL SCROLL BAR SCROLL DOWN PAGE ARROW\n. 1 2 3 4 5 6 7 8 9\n: X . . . . . . . X\n: X . . . . . . . X\n: X . X X X X X . X\n: X . . X X X . . X\n: X . . . X . . . X\n: X . . . X . . . X\n: X . . . . . . . X\n: X . X X X X X . X\n: X . . X X X . . X\n: X . . . X . . . X\n: X . . . X . . . X\n: X . . . . . . . X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+EF   --- BOTTOM HORIZONTAL LINE\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+9C   --- BOTTOM LEFT WINDOW BORDER\n. 1 2 3 4 5 6 7 8 9\n: . . . . X X X X X\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X X . . .\n: . . . . X . X . .\n: . . . . X X . X .\n: . . . . X . X . X\n: . . . . X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+9E   --- TOP RIGHT WINDOW BORDER\n. 1 2 3 4 5 6 7 8 9\n: X X X X X . . . .\n: X . X . X . . . .\n: . X . X X . . . .\n: . . X . X . . . .\n: . . . X X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: X X X X X . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+9F   --- SELECTED WINDOW HIGHLIGHT\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: X X . X X . X X .\n: X X . X X . X X .\n: X X . X X . X X .\n: X X . X X . X X .\n: X X . X X . X X .\n: X X . X X . X X .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SYM9X15U": {"ttr": 7943, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00\\x00\\x00\\x95%_\\x00\\x95(\\x9f\\x19)\\x0b\\x10\\x08\\xbd\\x00\\x00\\xe2\\xc1\\xe2\\xc4\\xc4\\xc6@@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "1995-09-12T00:00:00", "modifydate": "1995-10-16T19:29:00", "lines": 2832, "newlines": 2237, "modlines": 0, "user": "SASDDF"}, "text": ".....................................................................\n. Program:   SYM9X15U\n. Support:   David Fahey\n. Language:  SYMDEF\n. Date:      3Sep95\n. Purpose:   This file contains a 3270 character map for 9 by 15 under\n.            and over lined font.\n. Notes:\n.\n. The format of this file is as follows:\n.   Column one is a record identifier where dot(.) indicates a comment\n.   at plus(+) indicates the hex character code for the following bit\n.   map, and a colon(:) indicates a character cell pattern. Character\n.   cells are all 9 by 16, so 16 colon lines are required for each\n.   character. The format of colon and plus lines is fixed.\n.   1. A comment line can only appear any where.\n.   2. A plus line must be followed with 2 characters that are the\n.      hex representation of a character that the symbol defined after\n.      it will use. the range allowed is 41 to fe inclusive.\n.   3. A colon line has the following format:\n.        : . . . . . . . . .\n.      This indicates 9 pel positions accross the character, here all\n.      are turned off. an x is used to indicate that the pel is\n.      turned on. for example:\n.        : X X X X . . . . .\n.      Here the first four pels atr turned on, and the last five are\n.      off. there must be one, and only one blank character between each\n.      pel indicator, and also one blank following the colon.\n.      Note: The bit positions must only be  in dicated using\n.            The upper case X and the dot.\n.   4. Characters that are not specified are stored as if all\n.      pels were off.\n.   5. Symbol order is not important.\n.\n.\n. The letter a would be sent to the ps device as a type 1 symbol\n. with thw bit string: X'00000000102844828282FE82828282000000'\n.\n.....................................................................\n+C1 --- A\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . X . . . .\n: . . . X . X . . .\n: . . X . . . X . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X X X X X X X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+C2   --- B\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X X X X X X . .\n: . . X . . . . X .\n: . . X . . . . X .\n: . . X . . . . X .\n: . . X . . . . X .\n: . . X X X X X . .\n: . . X . . . . X .\n: . . X . . . . X .\n: . . X . . . . X .\n: . . X . . . . X .\n: . X X X X X X . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+C3   --- C\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . X X X X . .\n: . . X . . . . X .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . . X . . . . X .\n: . . . X X X X . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+C4   --- D\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X X X X X . . .\n: . . X . . . X . .\n: . . X . . . . X .\n: . . X . . . . X .\n: . . X . . . . X .\n: . . X . . . . X .\n: . . X . . . . X .\n: . . X . . . . X .\n: . . X . . . . X .\n: . . X . . . X . .\n: . X X X X X . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+C5   --- E\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X X X X X X X .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X X X X X . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X X X X X X X .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+C6   --- F\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X X X X X X X .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X X X X X . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+C7   --- G\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . X X X . . .\n: . . X . . . X . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . X X X .\n: . X . . . . X . .\n: . X . . . . X . .\n: . . X . . . X . .\n: . . . X X X X . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+C8   --- H\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X X X X X X X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+C9   --- I\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . X X X X X . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . X X X X X . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+D1   --- J\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . X X X . .\n: . . . . . X . . .\n: . . . . . X . . .\n: . . . . . X . . .\n: . . . . . X . . .\n: . . . . . X . . .\n: . . . . . X . . .\n: . . . . . X . . .\n: . X . . . X . . .\n: . . X . . X . . .\n: . . . X X . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+D2   --- K\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X . . . . . X .\n: . X . . . . X . .\n: . X . . . X . . .\n: . X . . X . . . .\n: . X . X . . . . .\n: . X X . . . . . .\n: . X . X . . . . .\n: . X . . X . . . .\n: . X . . . X . . .\n: . X . . . . X . .\n: . X . . . . . X .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+D3   --- L\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X X X X X X X .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+D4   --- M\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X . . . . . X .\n: . X X . . . X X .\n: . X . X . X . X .\n: . X . X . X . X .\n: . X . . X . . X .\n: . X . . X . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+D5   --- N\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X . . . . . X .\n: . X X . . . . X .\n: . X . X . . . X .\n: . X . X . . . X .\n: . X . . X . . X .\n: . X . . X . . X .\n: . X . . X . . X .\n: . X . . . X . X .\n: . X . . . X . X .\n: . X . . . . X X .\n: . X . . . . . X .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+D6   --- O\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . X X X X X . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . X X X X X . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+D7   --- P\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X X X X X . . .\n: . X . . . . X . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . X . .\n: . X X X X X . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+D8   --- Q\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . X X X . . .\n: . . X . . . X . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . X . . X .\n: . . X . X . X . .\n: . . . X X X . . .\n: . . . . . . X . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+D9   --- R\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X X X X X . . .\n: . X . . . . X . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . X . .\n: . X X X X X . . .\n: . X . X . . . . .\n: . X . . X . . . .\n: . X . . . X . . .\n: . X . . . . X . .\n: . X . . . . . X .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+E2   --- S\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . X X X . . .\n: . . X . . . X . .\n: . X . . . . . X .\n: . X . . . . . . .\n: . . X . . . . . .\n: . . . X X X . . .\n: . . . . . . X . .\n: . . . . . . . X .\n: . X . . . . . X .\n: . . X . . . X . .\n: . . . X X X . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+E3   --- T\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X X X X X X X .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+E4   --- U\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . X X X X X . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+E5   --- V\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . X . . . X . .\n: . . X . . . X . .\n: . . X . . . X . .\n: . . . X . X . . .\n: . . . X . X . . .\n: . . . X . X . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+E6   --- W\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . X . . X .\n: . X . . X . . X .\n: . X . . X . . X .\n: . X . . X . . X .\n: . X . . X . . X .\n: . . X X . X X . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+E7   --- X\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . X . . . X . .\n: . . X . . . X . .\n: . . . X . X . . .\n: . . . . X . . . .\n: . . . X . X . . .\n: . . X . . . X . .\n: . . X . . . X . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+E8   --- Y\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . X . . . X . .\n: . . X . . . X . .\n: . . . X . X . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+E9   --- Z\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X X X X X X X .\n: . . . . . . . X .\n: . . . . . . X . .\n: . . . . . . X . .\n: . . . . . X . . .\n: . . . . X . . . .\n: . . . X . . . . .\n: . . X . . . . . .\n: . . X . . . . . .\n: . X . . . . . . .\n: . X X X X X X X .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+4E\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . X X X X X X X .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+41\n. 1 2 3 4 5 6 7 8 9\n: . . X X X . X X X\n: . X . . . . . . .\n: . . X X . . . . .\n: . . . . X . . . .\n: . X X X . . . . .\n: . . . . X . . . .\n: . . . X . X . . .\n: . . . X X X . . .\n: . . . X . X . . .\n: . . . . . X X X .\n: . . . . X . . . .\n: . . . . . X X . .\n: . . . . . . . X .\n: . . . . X X X . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+81   --- a\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X X X X X . .\n: . . . . . . . X .\n: . . X X X X X X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . X X X X X X .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+82   --- b\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X X X X X . . .\n: . X . . . . X . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . X . .\n: . X X X X X . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+83   --- c\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . X X X X . .\n: . . X . . . . X .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . . X . . . . X .\n: . . . X X X X . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+84   --- d\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . X .\n: . . . . . . . X .\n: . . . . . . . X .\n: . . . . . . . X .\n: . . X X X X X X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . X X X X X X .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+85   --- e\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X X X X X . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X X X X X X X .\n: . X . . . . . . .\n: . X . . . . . . .\n: . . X X X X X X .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+86   --- f\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . X X X . .\n: . . . X . . . . .\n: . . . X . . . . .\n: . . . X . . . . .\n: . X X X X X . . .\n: . . . X . . . . .\n: . . . X . . . . .\n: . . . X . . . . .\n: . . . X . . . . .\n: . . . X . . . . .\n: . . . X . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+87   --- g\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X X X X . . .\n: . X . . . . X . .\n: . X . . . . X . .\n: . X . . . . X . .\n: . X . . . . X . .\n: . . X X X X X . .\n: . . . . . . X . .\n: . . . X X X . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+88   --- h\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X X X X X . . .\n: . X . . . . X . .\n: . X . . . . X . .\n: . X . . . . X . .\n: . X . . . . X . .\n: . X . . . . X . .\n: . X . . . . X . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+89   --- i\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+91   --- j\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . X X . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+92   --- k\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . X .\n: . X . . . . X . .\n: . X . . . X . . .\n: . X . . X . . . .\n: . X . X . . . . .\n: . X X . X . . . .\n: . X . . . X . . .\n: . X . . . . X . .\n: . X . . . . . X .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+93   --- l\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X X . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+94   --- m\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X X . X X . .\n: . X . . X . . X .\n: . X . . X . . X .\n: . X . . X . . X .\n: . X . . X . . X .\n: . X . . X . . X .\n: . X . . X . . X .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+95   --- n\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . X . X X X X . .\n: . X X . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+96   --- o\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X X X X X . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . X X X X X . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+97   --- p\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . X X X X X . . .\n: . X . . . . X . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . X . .\n: . X X X X X . . .\n: . X . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+98   --- q\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X X X X X . .\n: . X . . . . X . .\n: . X . . . . X . .\n: . X . . . . X . .\n: . X . . . . X . .\n: . X . . . X X . .\n: . . X X X . X . .\n: . . . . . . X X .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+99   --- r\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . X . X X X . . .\n: . X X . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+A2   --- s\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X X X X X . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . . X X X X . . .\n: . . . . . . X . .\n: . . . . . . X . .\n: . X X X X X . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+A3   --- t\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . X . . . . .\n: . . . X . . . . .\n: . . . X . . . . .\n: . . . X . . . . .\n: . X X X X X . . .\n: . . . X . . . . .\n: . . . X . . . . .\n: . . . X . . . . .\n: . . . X . . . . .\n: . . . X . . . . .\n: . . . X X X . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+A4   --- u\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . X . . . . X . .\n: . X . . . . X . .\n: . X . . . . X . .\n: . X . . . . X . .\n: . X . . . . X . .\n: . X . . . . X . .\n: . . X X X X . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+A5   --- v\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . X . . . X . .\n: . . X . . . X . .\n: . . . X . X . . .\n: . . . X . X . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+A6   --- w\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . X . . X .\n: . X . . X . . X .\n: . X . . X . . X .\n: . X . X . X . X .\n: . . X . . . X . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+A7   --- x\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . X . . . . . X .\n: . . X . . . X . .\n: . . . X . X . . .\n: . . . . X . . . .\n: . . . X . X . . .\n: . . X . . . X . .\n: . X . . . . . X .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+A8   --- y\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . X . . . . . X .\n: . . X . . . . X .\n: . . . X . . X . .\n: . . . . X . X . .\n: . . . . . X . . .\n: . . . . . X . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+A9   --- z\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . X X X X X X X .\n: . . . . . . X . .\n: . . . . . X . . .\n: . . . . X . . . .\n: . . . X . . . . .\n: . . X . . . . . .\n: . X X X X X X X .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+F0\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . X X X X X . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . X . . X .\n: . X . . X . . X .\n: . X . . X . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . X X X X X . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+F1   --- 1\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . X . . . .\n: . . . X X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . X X X . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+F2   --- 2\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . X X X X X . .\n: . X . . . . . X .\n: . . . . . . . X .\n: . . . . . . . X .\n: . . . . . . X . .\n: . . . . . X . . .\n: . . . . X . . . .\n: . . . X . . . . .\n: . . X . . . . . .\n: . X . . . . . . .\n: . X X X X X X X .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+F3   --- 3\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . X X X X X . .\n: . X . . . . . X .\n: . . . . . . . X .\n: . . . . . . . X .\n: . . . . . . X . .\n: . . . X X X . . .\n: . . . . . . X . .\n: . . . . . . . X .\n: . . . . . . . X .\n: . X . . . . . X .\n: . . X X X X X . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+F4   --- 4\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . X . . .\n: . . . . X X . . .\n: . . . X . X . . .\n: . . X . . X . . .\n: . X . . . X . . .\n: . X X X X X X X .\n: . . . . . X . . .\n: . . . . . X . . .\n: . . . . . X . . .\n: . . . . . X . . .\n: . . . . . X . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+F5   --- 5\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X X X X X X X .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X X X X X X . .\n: . . . . . . . X .\n: . . . . . . . X .\n: . . . . . . . X .\n: . X . . . . . X .\n: . . X . . . X . .\n: . . . X X X . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+F6   --- 6\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . X X X . .\n: . . . X . . . X .\n: . . X . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . X X X X . .\n: . X X . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . X X X X X . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+F7   --- 7\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X X X X X X X .\n: . . . . . . . X .\n: . . . . . . X . .\n: . . . . . . X . .\n: . . . . . X . . .\n: . . . . . X . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . X . . . . .\n: . . . X . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+F8   --- 8\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . X X X X X . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . X . . . X . .\n: . . . X X X . . .\n: . . X . . . X . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . X X X X X . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+F9\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . X X X X X . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . X X X X X X .\n: . . . . . . . X .\n: . . . . . . . X .\n: . . . . . . . X .\n: . . . . . . . X .\n: . . X . . . X . .\n: . . . X X X . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+4A   --- CENT\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . X X X X X . .\n: . X . . X . . X .\n: . X . . X . . . .\n: . X . . X . . . .\n: . X . . X . . . .\n: . X . . X . . X .\n: . . X X X X X . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+4B   --- .\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X X . . . . .\n: . . X X . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+4C   --- <\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . X . .\n: . . . . . X . . .\n: . . . . X . . . .\n: . . . X . . . . .\n: . . X . . . . . .\n: . X . . . . . . .\n: . . X . . . . . .\n: . . . X . . . . .\n: . . . . X . . . .\n: . . . . . X . . .\n: . . . . . . X . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+4D   --- (\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . X . . . .\n: . . . X . . . . .\n: . . . X . . . . .\n: . . X . . . . . .\n: . . X . . . . . .\n: . . X . . . . . .\n: . . X . . . . . .\n: . . X . . . . . .\n: . . . X . . . . .\n: . . . X . . . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+4F   --- |\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+50   --- &\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . X X X . . . .\n: . X . . . X . . .\n: . X . . . X . . .\n: . . X . X . . . .\n: . . X X X . . . .\n: . X . . . X . X .\n: . X . . . . X . .\n: . X . . . . X . .\n: . X . . . X . X .\n: . X . . . X . . .\n: . . X X X . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+5A   --- !\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+5B   --- $\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . X . . . .\n: . . . X X X . . .\n: . . X . X . X . .\n: . X . . X . . . .\n: . . X . X . . . .\n: . . . X X X . . .\n: . . . . X . X . .\n: . . . . X . . X .\n: . . X . X . X . .\n: . . . X X X . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+7F   --- \"\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . X . X . . .\n: . . . X . X . . .\n: . . . X . X . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+5D   --- )\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . X . . . .\n: . . . . . X . . .\n: . . . . . X . . .\n: . . . . . . X . .\n: . . . . . . X . .\n: . . . . . . X . .\n: . . . . . . X . .\n: . . . . . . X . .\n: . . . . . X . . .\n: . . . . . X . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+5E   --- ;\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X X . . . . .\n: . . X X . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X X . . . . .\n: . . X X . . . . .\n: . . X . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+7A   --- :\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X X . . . . .\n: . . X X . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X X . . . . .\n: . . X X . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+5F   --- \u00ac\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . X X X X X . . .\n: . . . . . X . . .\n: . . . . . X . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+60   --- -\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . X X X X X X X .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+61   --- /\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . X .\n: . . . . . . X . .\n: . . . . . . X . .\n: . . . . . X . . .\n: . . . . . X . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . X . . . . .\n: . . . X . . . . .\n: . . X . . . . . .\n: . X . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+6B   --- ,\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X X . . . . .\n: . . X X . . . . .\n: . . X . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+6C   --- %\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . X X . . . X .\n: . X . . X . X . .\n: . X . . X . X . .\n: . . X X . X . . .\n: . . . . . X . . .\n: . . . . X . . . .\n: . . . X . . . . .\n: . . . X . X X . .\n: . . X . X . . X .\n: . . X . X . . X .\n: . X . . . X X . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+6D   --- _\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+6E   --- >\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X . . . . . . .\n: . . X . . . . . .\n: . . . X . . . . .\n: . . . . X . . . .\n: . . . . . X . . .\n: . . . . . . X . .\n: . . . . . X . . .\n: . . . . X . . . .\n: . . . X . . . . .\n: . . X . . . . . .\n: . X . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+6F   --- ?\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . X X X . . .\n: . . X . . . X . .\n: . . . . . . X . .\n: . . . . . . X . .\n: . . . . . X . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: . . . . X . . . .\n: . . . X X X . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+7B   --- #\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . X . X . . .\n: . . . X . X . . .\n: . . . X . X . . .\n: . X X X X X X X .\n: . . . X . X . . .\n: . . . X . X . . .\n: . . . X . X . . .\n: . X X X X X X X .\n: . . . X . X . . .\n: . . . X . X . . .\n: . . . X . X . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+7C   --- @\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . X X X X X . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . X X X X .\n: . X . X . . . X .\n: . X . X . . . X .\n: . X . X . . . X .\n: . X . X . . . X .\n: . X . . X X X . .\n: . X . . . . . . .\n: . . X X X X X X .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+7D   --- '\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+7E   --- =\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . X X X X X X X .\n: . . . . . . . . .\n: . . . . . . . . .\n: . X X X X X X X .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+5C   --- *\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . X . X . X . .\n: . . . X X X . . .\n: . X X X X X X X .\n: . . . X X X . . .\n: . . X . X . X . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+42   --- LEFT END\n. 1 2 3 4 5 6 7 8 9\n: . . . . X X X X X\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X X X X X\n: . . . . . . . . .\n.\n+43   --- RIGHT END\n. 1 2 3 4 5 6 7 8 9\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: . . . . . . . . .\n.\n+44   --- OTHER RIGHT END\n. 1 2 3 4 5 6 7 8 9\n: X X X X X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: X X X X X . . . .\n: . . . . . . . . .\n.\n+45   --- UP ARROW\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: X X X X X X X X X\n: X . . . X . . . X\n: X . . . X . . . X\n: X . . . X . . . X\n: X . . . X . . . X\n: X . . . X . . . X\n: X X X X X . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X X X X X X X X X\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+46   --- DOWN ARROW\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: X X X X X . . . .\n: X . . . X . . . .\n: X . . . X . . . .\n: X . . . X . . . .\n: X . . . X . . . .\n: X . . . X . . . .\n: X X X X X . . . .\n: . . . . . X . . .\n: . . . . . . X X X\n: . . . . . . X X X\n: . . . . . . X X X\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+47   --- 3D MINUS SIGN\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X X . X X . X X\n: . X X . X X . X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X X . . X X .\n: . . X X . . X X .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . X X . . .\n: . . . . X X . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+48   --- BLANK REPLACEMENT\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+49   --- TOP LEFT WINDOW BORDER\n. 1 2 3 4 5 6 7 8 9\n: . . . . X X X X X\n: . . . . X . X . X\n: . . . . X X . X .\n: . . . . X . X . .\n: . . . . X X . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X X X X X\n: . . . . . . . . .\n.\n+51   --- BOTTOM RIGHT WINDOW BORDER\n. 1 2 3 4 5 6 7 8 9\n: X X X X X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . X X . . . .\n: . . X . X . . . .\n: . X . X X . . . .\n: X . X . X . . . .\n: X X X X X . . . .\n: . . . . . . . . .\n.\n+52   --- WINDOW CONTROL FOR TERNINATE WINDOW\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . X . . . . . X .\n: . X X . . . X X .\n: . X X X . X X X .\n: . . X X X X X . .\n: . . . X X X . . .\n: . . X X X X X . .\n: . X X X . X X X .\n: . X X . . . X X .\n: . X . . . . . X .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+53   --- RADIO BUTTON - ON\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . X X X . . .\n: . . X . . . X . .\n: . X . . . . . X .\n: X . . X X X . . X\n: X . X X X X X . X\n: X . X X X X X . X\n: X . . X X X . . X\n: . X . . . . . X .\n: . . X . . . X . .\n: . . . X X X . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+54   --- RADIO BUTTON - OFF\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . X X X . . .\n: . . X . . . X . .\n: . X . . . . . X .\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: . X . . . . . X .\n: . . X . . . X . .\n: . . . X X X . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+55   --- CHECK BOX - ON\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: X X . . . . . X X\n: X . X . . . X . X\n: X . . X . X . . X\n: X . . . X . . . X\n: X . . X . X . . X\n: X . X . . . X . X\n: X X . . . . . X X\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+56   --- CHECK BOX - OFF\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+57   --- CHECK BOX - UNDEFINED STATE\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . . . . . .\n: X . X . X . X . X\n: . . . . . . . . .\n: X . . . . . . . X\n: . . . . . . . . .\n: X . . . . . . . X\n: . . . . . . . . .\n: X . . . . . . . X\n: . . . . . . . . .\n: X . X . X . X . X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+58   --- BAR GRAPH - MIDDLE FULL\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: X X X X X X X X X\n: X X X X X X X X X\n: X X X X X X X X X\n: X X X X X X X X X\n: X X X X X X X X X\n: X X X X X X X X X\n: X X X X X X X X X\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+59   --- BAR GRAPH - START FULL\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: X . . . . . . . .\n: X . . . . . . . .\n: X . X X X X X X X\n: X . X X X X X X X\n: X . X X X X X X X\n: X . X X X X X X X\n: X . X X X X X X X\n: X . X X X X X X X\n: X . X X X X X X X\n: X . X X X X X X X\n: X . X X X X X X X\n: X . . . . . . . .\n: X . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+62   --- BAR GRAPH - END FULL\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . X\n: . . . . . . . . X\n: X X X X X X X . X\n: X X X X X X X . X\n: X X X X X X X . X\n: X X X X X X X . X\n: X X X X X X X . X\n: X X X X X X X . X\n: X X X X X X X . X\n: X X X X X X X . X\n: X X X X X X X . X\n: . . . . . . . . X\n: . . . . . . . . X\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+63   --- BAR GRAPH - END EMPTY\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . X\n: . . . . . . . . X\n: . . . . . . . . X\n: . . . . . . . . X\n: . . . . . . . . X\n: . . . . . . . . X\n: . . . . . . . . X\n: . . . . . . . . X\n: . . . . . . . . X\n: . . . . . . . . X\n: . . . . . . . . X\n: . . . . . . . . X\n: . . . . . . . . X\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+64   --- BAR GRAPH - START EMPTY\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: X . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+65   --- BAR GRAPH - MIDDLE EMPTY\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+66   --- LEFT TOP CORNER\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . X X X X X\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . . . . . .\n.\n+67   --- LEFT BOTTOM CORNER\n. 1 2 3 4 5 6 7 8 9\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+68   --- RIGHT TOP CORNER\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . . . . . .\n.\n+69   --- RIGHT BOTTOM CORNER\n. 1 2 3 4 5 6 7 8 9\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: X X X X X . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+70   --- FLAT LINE - HORIZONTAL\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+71   --- FLAT LINE - VERTICAL\n. 1 2 3 4 5 6 7 8 9\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . . . . . .\n.\n+72   --- VERTICAL LINE\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+73   --- RADIO BUTTON - UNDEFINED\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . X . . . .\n: . . X . . . X . .\n: . . . . . . . . .\n: X . . . . . . . X\n: . . . . . . . . .\n: X . . . . . . . X\n: . . . . . . . . .\n: . X . . . . . X .\n: . . . . . . . . .\n: . . . X . X . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+74   --- CHECK BOX - ON - GRAYED\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . . . . . .\n: X . X . X . X . X\n: . X . . . . . X .\n: X . X . . . X . X\n: . . . X . X . . .\n: X . . . X . . . X\n: . . . X . X . . .\n: X . X . . . X . X\n: . X . . . . . X .\n: X . X . X . X . X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+75   --- CHECK BOX - UNDEFINED\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: X . . . . . . . X\n: X . X . . . X . X\n: X . . . . . . . X\n: X . . . X . . . X\n: X . . . . . . . X\n: X . X . . . X . X\n: X . . . . . . . X\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+76   --- CHECK BOX - GRAYED - UNDEFINED STATE\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . . . . . .\n: X . X . X . X . X\n: . . . . . . . . .\n: X . X . . . X . X\n: . . . . . . . . .\n: X . . . X . . . X\n: . . . . . . . . .\n: X . X . . . X . X\n: . . . . . . . . .\n: X . X . X . X . X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+77   --- RADIO BUTTON - ON - GRAYED\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . X . . . .\n: . . X . . . X . .\n: . . . . . . . . .\n: X . . X X X . . X\n: . . X X X X X . .\n: X . X X X X X . X\n: . . . X X X . . .\n: . X . . . . . X .\n: . . . . . . . . .\n: . . . X . X . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+78   --- RADIO BUTTON - UNDEFINED\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . X X X . . .\n: . . X . . . X . .\n: . X . . . . . X .\n: X . . X . X . . X\n: X . X . X . X . X\n: X . . X . X . . X\n: X . . . X . . . X\n: . X . . . . . X .\n: . . X . . . X . .\n: . . . X X X . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+80   --- RADIO BUTTON - UNDEFINED - GRAYED\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . X . . . .\n: . . X . . . X . .\n: . . . . . . . . .\n: X . . X . X . . X\n: . . X . X . X . .\n: X . . X . X . . X\n: . . . . X . . . .\n: . X . . . . . X .\n: . . . . . . . . .\n: . . . X . X . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+8A   --- BUTTON NOT PRESSED\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X X X X X . .\n: . . X . . . X . .\n: . . X . . . X . .\n: . . X . . . X . .\n: . . X . . . X . .\n: . . X . . . X . .\n: . . X . . . X . .\n: . . X . . . X . .\n: . . X . . . X . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+90   --- BUTTON INDETERMINATE\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X X X X X . .\n: . . X . . . X . .\n: . . X . . . X . .\n: . . X . . . X . .\n: . . X . . . X . .\n: . . X . . . X . .\n: . . X X X X X . .\n: . . X X X X X . .\n: . . X X X X X . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+9A   --- BUTTON PRESSED\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X X X X X . .\n: . . X X X X X . .\n: . . X X X X X . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+BA   --- BUTTON NOT PRESSED - GRAY\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X . X . X . .\n: . . X . . . X . .\n: . . . . . . . . .\n: . . X . . . X . .\n: . . . . . . . . .\n: . . X . . . X . .\n: . . . . . . . . .\n: . . X . . . X . .\n: . . . . . . . . .\n: X . X . X . X . X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+CA   --- BUTTON INDETERMINATE - GRAY\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X . X . X . .\n: . . X . . . X . .\n: . . . . . . . . .\n: . . X . . . X . .\n: . . . . . . . . .\n: . . X . . . X . .\n: . . . X . X . . .\n: . . X . X . X . .\n: . . . X . X . . .\n: X . X . X . X . X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+CB   --- BUTTON PRESSED - GRAY\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X . X . X . .\n: . . . X . X . . .\n: . . X . X . X . .\n: . . . X . X . . .\n: X . X . X . X . X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+CD   --- LEFT HORIZONTAL SCROLL ARROW\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: X . . . . . . . .\n: X . . . . . . X .\n: X . . . . . X X .\n: X . . . . X X X .\n: X . . . X X X X .\n: X . . X X X X X .\n: X . X X X X X X .\n: X . . X X X X X .\n: X . . . X X X X .\n: X . . . . X X X .\n: X . . . . . X X .\n: X . . . . . . X .\n: X . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+CF   --- RIGHT HORIZONTAL SCROLL ARROW\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . X\n: . X . . . . . . X\n: . X X . . . . . X\n: . X X X . . . . X\n: . X X X X . . . X\n: . X X X X X . . X\n: . X X X X X X . X\n: . X X X X X . . X\n: . X X X X . . . X\n: . X X X . . . . X\n: . X X . . . . . X\n: . X . . . . . . X\n: . . . . . . . . X\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+DA   --- VERTICAL SCROLL BAR CHAR\n. 1 2 3 4 5 6 7 8 9\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: . . . . . . . . .\n.\n+DB   --- VERTICAL SCROLL BAR THUMB\n. 1 2 3 4 5 6 7 8 9\n: X . X X X X X . X\n: X . X X X X X . X\n: X . X X X X X . X\n: X . X X X X X . X\n: X . X X X X X . X\n: X . X X X X X . X\n: X . X X X X X . X\n: X . X X X X X . X\n: X . X X X X X . X\n: X . X X X X X . X\n: X . X X X X X . X\n: X . X X X X X . X\n: X . X X X X X . X\n: X . X X X X X . X\n: X . X X X X X . X\n: . . . . . . . . .\n.\n+DC   --- VERTICAL SCROLL BAR TOP ARROW\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . X . . . X\n: X . . . X . . . X\n: X . . . X . . . X\n: X . . X X X . . X\n: X . . X X X . . X\n: X . . X X X . . X\n: X . X X X X X . X\n: X . X X X X X . X\n: X . X X X X X . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: . . . . . . . . .\n.\n+DD   --- VERTICAL SCROLL BAR BOTTOM ARROW\n. 1 2 3 4 5 6 7 8 9\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . X X X X X . X\n: X . X X X X X . X\n: X . X X X X X . X\n: X . . X X X . . X\n: X . . X X X . . X\n: X . . X X X . . X\n: X . . . X . . . X\n: X . . . X . . . X\n: X . . . X . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+DE   --- COMBO BOX DROP DOWN CONTROL\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: X . . . . . . . X\n: X . . X X X . . X\n: X . . X X X . . X\n: X . . X X X . . X\n: X . . X X X . . X\n: X . . X X X . . X\n: X . . X X X . . X\n: X . X X X X X . X\n: X . . X X X . . X\n: X . . X X X . . X\n: X . . . X . . . X\n: X . . . X . . . X\n: X . . . . . . . X\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+DF   --- ELIPSIS CONTROL\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X . X . X . X . X\n: X . X . X . X . X\n: X . . . . . . . X\n: X . . . . . . . X\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+EA   --- FILLED CELL\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: X X X X X X X X X\n: X X X X X X X X X\n: X X X X X X X X X\n: X X X X X X X X X\n: X X X X X X X X X\n: X X X X X X X X X\n: X X X X X X X X X\n: X X X X X X X X X\n: X X X X X X X X X\n: X X X X X X X X X\n: X X X X X X X X X\n: X X X X X X X X X\n: X X X X X X X X X\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+EB   --- HORIZONTAL SCROLL LEFT PAGE ARROW\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . X . . . X .\n: . . . X . . . X .\n: . . X X . . X X .\n: . . X X . . X X .\n: . X X X . X X X .\n: . . X X . . X X .\n: . . X X . . X X .\n: . . . X . . . X .\n: . . . X . . . X .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+EC   --- HORIZONTAL SCROLL RIGHT PAGE ARROW\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . X . . . X . . .\n: . X . . . X . . .\n: . X X . . X X . .\n: . X X . . X X . .\n: . X X X . X X X .\n: . X X . . X X . .\n: . X X . . X X . .\n: . X . . . X . . .\n: . X . . . X . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+ED   --- VERTICAL SCROLL BAR SCROLL UP PAGE ARROW\n. 1 2 3 4 5 6 7 8 9\n: X . . . . . . . X\n: X . . . X . . . X\n: X . . . X . . . X\n: X . . X X X . . X\n: X . . X X X . . X\n: X . X X X X X . X\n: X . X X X X X . X\n: X . . . . . . . X\n: X . . . X . . . X\n: X . . . X . . . X\n: X . . X X X . . X\n: X . . X X X . . X\n: X . X X X X X . X\n: X . X X X X X . X\n: X . . . . . . . X\n: . . . . . . . . .\n.\n+EE   --- VERTICAL SCROLL BAR SCROLL DOWN PAGE ARROW\n. 1 2 3 4 5 6 7 8 9\n: X . . . . . . . X\n: X . X X X X X . X\n: X . X X X X X . X\n: X . . X X X . . X\n: X . . X X X . . X\n: X . . . X . . . X\n: X . . . X . . . X\n: X . . . . . . . X\n: X . X X X X X . X\n: X . X X X X X . X\n: X . . X X X . . X\n: X . . X X X . . X\n: X . . . X . . . X\n: X . . . X . . . X\n: X . . . . . . . X\n: . . . . . . . . .\n.\n+EF   --- BOTTOM HORIZONTAL LINE\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n+9C   --- BOTTOM LEFT WINDOW BORDER\n. 1 2 3 4 5 6 7 8 9\n: . . . . X X X X X\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X X . . .\n: . . . . X . X . .\n: . . . . X X . X .\n: . . . . X . X . X\n: . . . . X X X X X\n: . . . . . . . . .\n.\n+9E   --- TOP RIGHT WINDOW BORDER\n. 1 2 3 4 5 6 7 8 9\n: X X X X X . . . .\n: X . X . X . . . .\n: . X . X X . . . .\n: . . X . X . . . .\n: . . . X X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: X X X X X . . . .\n: . . . . . . . . .\n.\n+9F   --- SELECTED WINDOW HIGHLIGHT\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: X X . X X . X X .\n: X X . X X . X X .\n: X X . X X . X X .\n: X X . X X . X X .\n: X X . X X . X X .\n: X X . X X . X X .\n: X X . X X . X X .\n: X X . X X . X X .\n: X X . X X . X X .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n: . . . . . . . . .\n.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SYM9X16U": {"ttr": 9219, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x16\\x00\\x00\\x00\\x95$O\\x00\\x95(\\x9f\\x190\\x0b\\x10\\x07-\\x00\\x00\\xe2\\xc1\\xe2\\xc4\\xc4\\xc6@@@@'", "ispf": {"version": "01.22", "flags": 0, "createdate": "1995-09-01T00:00:00", "modifydate": "1995-10-16T19:30:00", "lines": 2832, "newlines": 1837, "modlines": 0, "user": "SASDDF"}, "text": ".....................................................................\n. Program:   SYM9X16U\n. Support:   David Fahey\n. Language:  SYMDEF\n. Date:      3Sep95\n. Purpose:   This file contains a 3270 character map for 9 by 16 under\n.            and over lined font.\n. Notes:\n.\n. The format of this file is as follows:\n.   Column one is a record identifier where dot(.) indicates a comment\n.   at plus(+) indicates the hex character code for the following bit\n.   map, and a colon(:) indicates a character cell pattern. Character\n.   cells are all 9 by 16, so 16 colon lines are required for each\n.   character. The format of colon and plus lines is fixed.\n.   1. A comment line can only appear any where.\n.   2. A plus line must be followed with 2 characters that are the\n.      hex representation of a character that the symbol defined after\n.      it will use. the range allowed is 41 to fe inclusive.\n.   3. A colon line has the following format:\n.        : . . . . . . . . .\n.      This indicates 9 pel positions accross the character, here all\n.      are turned off. an x is used to indicate that the pel is\n.      turned on. for example:\n.        : X X X X . . . . .\n.      Here the first four pels atr turned on, and the last five are\n.      off. there must be one, and only one blank character between each\n.      pel indicator, and also one blank following the colon.\n.      Note: The bit positions must only be  in dicated using\n.            The upper case X and the dot.\n.   4. Characters that are not specified are stored as if all\n.      pels were off.\n.   5. Symbol order is not important.\n.\n.\n. The letter a would be sent to the ps device as a type 1 symbol\n. with thw bit string: X'00000000102844828282FE82828282000000'\n.\n.....................................................................\n+C1 --- A\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . X . . . .\n: . . . X . X . . .\n: . . X . . . X . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X X X X X X X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n.\n+C2   --- B\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X X X X X X . .\n: . . X . . . . X .\n: . . X . . . . X .\n: . . X . . . . X .\n: . . X . . . . X .\n: . . X X X X X . .\n: . . X . . . . X .\n: . . X . . . . X .\n: . . X . . . . X .\n: . . X . . . . X .\n: . X X X X X X . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n.\n+C3   --- C\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . X X X X . .\n: . . X . . . . X .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . . X . . . . X .\n: . . . X X X X . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n.\n+C4   --- D\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X X X X X . . .\n: . . X . . . X . .\n: . . X . . . . X .\n: . . X . . . . X .\n: . . X . . . . X .\n: . . X . . . . X .\n: . . X . . . . X .\n: . . X . . . . X .\n: . . X . . . . X .\n: . . X . . . X . .\n: . X X X X X . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n.\n+C5   --- E\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X X X X X X X .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X X X X X . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X X X X X X X .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n.\n+C6   --- F\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X X X X X X X .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X X X X X . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n.\n+C7   --- G\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . X X X . . .\n: . . X . . . X . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . X X X .\n: . X . . . . X . .\n: . X . . . . X . .\n: . . X . . . X . .\n: . . . X X X X . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n.\n+C8   --- H\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X X X X X X X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n.\n+C9   --- I\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . X X X X X . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . X X X X X . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n.\n+D1   --- J\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . X X X . .\n: . . . . . X . . .\n: . . . . . X . . .\n: . . . . . X . . .\n: . . . . . X . . .\n: . . . . . X . . .\n: . . . . . X . . .\n: . . . . . X . . .\n: . X . . . X . . .\n: . . X . . X . . .\n: . . . X X . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n.\n+D2   --- K\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X . . . . . X .\n: . X . . . . X . .\n: . X . . . X . . .\n: . X . . X . . . .\n: . X . X . . . . .\n: . X X . . . . . .\n: . X . X . . . . .\n: . X . . X . . . .\n: . X . . . X . . .\n: . X . . . . X . .\n: . X . . . . . X .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n.\n+D3   --- L\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X X X X X X X .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n.\n+D4   --- M\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X . . . . . X .\n: . X X . . . X X .\n: . X . X . X . X .\n: . X . X . X . X .\n: . X . . X . . X .\n: . X . . X . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n.\n+D5   --- N\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X . . . . . X .\n: . X X . . . . X .\n: . X . X . . . X .\n: . X . X . . . X .\n: . X . . X . . X .\n: . X . . X . . X .\n: . X . . X . . X .\n: . X . . . X . X .\n: . X . . . X . X .\n: . X . . . . X X .\n: . X . . . . . X .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n.\n+D6   --- O\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . X X X X X . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . X X X X X . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n.\n+D7   --- P\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X X X X X . . .\n: . X . . . . X . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . X . .\n: . X X X X X . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . X . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n.\n+D8   --- Q\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . X X X . . .\n: . . X . . . X . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . X . . X .\n: . . X . X . X . .\n: . . . X X X . . .\n: . . . . . . X . .\n: . . . . . . . . .\n: X X X X X X X X X\n.\n+D9   --- R\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X X X X X . . .\n: . X . . . . X . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . X . .\n: . X X X X X . . .\n: . X . X . . . . .\n: . X . . X . . . .\n: . X . . . X . . .\n: . X . . . . X . .\n: . X . . . . . X .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n.\n+E2   --- S\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . X X X . . .\n: . . X . . . X . .\n: . X . . . . . X .\n: . X . . . . . . .\n: . . X . . . . . .\n: . . . X X X . . .\n: . . . . . . X . .\n: . . . . . . . X .\n: . X . . . . . X .\n: . . X . . . X . .\n: . . . X X X . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n.\n+E3   --- T\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X X X X X X X .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n.\n+E4   --- U\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . X X X X X . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n.\n+E5   --- V\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . X . . . X . .\n: . . X . . . X . .\n: . . X . . . X . .\n: . . . X . X . . .\n: . . . X . X . . .\n: . . . X . X . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n.\n+E6   --- W\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . . . . X .\n: . X . . X . . X .\n: . X . . X . . X .\n: . X . . X . . X .\n: . X . . X . . X .\n: . X . . X . . X .\n: . . X X . X X . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n.\n+E7   --- X\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . X . . . X . .\n: . . X . . . X . .\n: . . . X . X . . .\n: . . . . X . . . .\n: . . . X . X . . .\n: . . X . . . X . .\n: . . X . . . X . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n.\n+E8   --- Y\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X . . . . . X .\n: . X . . . . . X .\n: . . X . . . X . .\n: . . X . . . X . .\n: . . . X . X . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n.\n+E9   --- Z\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . X X X X X X X .\n: . . . . . . . X .\n: . . . . . . X . .\n: . . . . . . X . .\n: . . . . . X . . .\n: . . . . X . . . .\n: . . . X . . . . .\n: . . X . . . . . .\n: . . X . . . . . .\n: . X . . . . . . .\n: . X X X X X X X .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n.\n+4E\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . X X X X X X X .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: X X X X X X X X X\n.\n+41\n. 1 2 3 4 5 6 7 8 9\n: . . X X X . X X X\n: . X . . . . . . .\n: . . X X . . . . .\n: . . . . X . . . .\n: . X X X . . . . .\n: . . . . . . . . .\n: . . . . X . . . .\n: . . . X . X . . .\n: . . . X X X . . .\n: . . . X . X . . .\n: . . . . . . . . .\n: . . . . . X X X .\n: . . . . X . . . .\n: . . . . . X X . .\n: . . . . . . . X .\n: X X . . X X X . .\n.\n+81   --- a\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . . . . . . .  4\n: . . . . . . . . .  5\n: . . . . . . . . .  6\n: . . X X X X X . .  7\n: . . . . . . . X .  8\n: . . X X X X X X .  9\n: . X . . . . . X .  10\n: . X . . . . . X .  11\n: . X . . . . . X .  12\n: . . X X X X X X .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+82   --- b\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . X . . . . . . .  3\n: . X . . . . . . .  4\n: . X . . . . . . .  5\n: . X . . . . . . .  6\n: . X X X X X . . .  7\n: . X . . . . X . .  8\n: . X . . . . . X .  9\n: . X . . . . . X .  10\n: . X . . . . . X .  11\n: . X . . . . X . .  12\n: . X X X X X . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+83   --- c\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . . . . . . .  4\n: . . . . . . . . .  5\n: . . . . . . . . .  6\n: . . . X X X X . .  7\n: . . X . . . . X .  8\n: . X . . . . . . .  9\n: . X . . . . . . .  10\n: . X . . . . . . .  11\n: . . X . . . . X .  12\n: . . . X X X X . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+84   --- d\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . . . X .  3\n: . . . . . . . X .  4\n: . . . . . . . X .  5\n: . . . . . . . X .  6\n: . . X X X X X X .  7\n: . X . . . . . X .  8\n: . X . . . . . X .  9\n: . X . . . . . X .  10\n: . X . . . . . X .  11\n: . X . . . . . X .  12\n: . . X X X X X X .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+85   --- e\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . . . . . . .  4\n: . . . . . . . . .  5\n: . . . . . . . . .  6\n: . . X X X X X . .  7\n: . X . . . . . X .  8\n: . X . . . . . X .  9\n: . X X X X X X X .  10\n: . X . . . . . . .  11\n: . X . . . . . . .  12\n: . . X X X X X X .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+86   --- f\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . X X X . .  3\n: . . . X . . . . .  4\n: . . . X . . . . .  5\n: . . . X . . . . .  6\n: . X X X X X . . .  7\n: . . . X . . . . .  8\n: . . . X . . . . .  9\n: . . . X . . . . .  10\n: . . . X . . . . .  11\n: . . . X . . . . .  12\n: . . . X . . . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+87   --- g\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . . . . . . .  4\n: . . . . . . . . .  5\n: . . . . . . . . .  6\n: . . X X X X . . .  7\n: . X . . . . X . .  8\n: . X . . . . X . .  9\n: . X . . . . X . .  10\n: . X . . . . X . .  11\n: . . X X X X X . .  12\n: . . . . . . X . .  13\n: . . . . . . X . .  14\n: . . . X X X . . .  15\n: X X X X X X X X X  16\n.\n+88   --- h\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . X . . . . . . .  3\n: . X . . . . . . .  4\n: . X . . . . . . .  5\n: . X . . . . . . .  6\n: . X X X X X . . .  7\n: . X . . . . X . .  8\n: . X . . . . X . .  9\n: . X . . . . X . .  10\n: . X . . . . X . .  11\n: . X . . . . X . .  12\n: . X . . . . X . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+89   --- i\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . . X . . . .  4\n: . . . . X . . . .  5\n: . . . . . . . . .  6\n: . . . . X . . . .  7\n: . . . . X . . . .  8\n: . . . . X . . . .  9\n: . . . . X . . . .  10\n: . . . . X . . . .  11\n: . . . . X . . . .  12\n: . . . . X . . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+91   --- j\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . . X . . . .  4\n: . . . . X . . . .  5\n: . . . . . . . . .  6\n: . . . . X . . . .  7\n: . . . . X . . . .  8\n: . . . . X . . . .  9\n: . . . . X . . . .  10\n: . . . . X . . . .  11\n: . . . . X . . . .  12\n: . . . . X . . . .  13\n: . . . . X . . . .  14\n: . . X X . . . . .  15\n: X X X X X X X X X  16\n.\n+92   --- k\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . X . . . . . . .  3\n: . X . . . . . . .  4\n: . X . . . . . X .  5\n: . X . . . . X . .  6\n: . X . . . X . . .  7\n: . X . . X . . . .  8\n: . X . X . . . . .  9\n: . X X . X . . . .  10\n: . X . . . X . . .  11\n: . X . . . . X . .  12\n: . X . . . . . X .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+93   --- l\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . X . . . .  3\n: . . . . X . . . .  4\n: . . . . X . . . .  5\n: . . . . X . . . .  6\n: . . . . X . . . .  7\n: . . . . X . . . .  8\n: . . . . X . . . .  9\n: . . . . X . . . .  10\n: . . . . X . . . .  11\n: . . . . X . . . .  12\n: . . . . X X . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+94   --- m\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . . . . . . .  4\n: . . . . . . . . .  5\n: . . . . . . . . .  6\n: . . X X . X X . .  7\n: . X . . X . . X .  8\n: . X . . X . . X .  9\n: . X . . X . . X .  10\n: . X . . X . . X .  11\n: . X . . X . . X .  12\n: . X . . X . . X .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+95   --- n\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . . . . . . .  4\n: . . . . . . . . .  5\n: . . . . . . . . .  6\n: . X . X X X X . .  7\n: . X X . . . . X .  8\n: . X . . . . . X .  9\n: . X . . . . . X .  10\n: . X . . . . . X .  11\n: . X . . . . . X .  12\n: . X . . . . . X .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+96   --- o\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . . . . . . .  4\n: . . . . . . . . .  5\n: . . . . . . . . .  6\n: . . X X X X X . .  7\n: . X . . . . . X .  8\n: . X . . . . . X .  9\n: . X . . . . . X .  10\n: . X . . . . . X .  11\n: . X . . . . . X .  12\n: . . X X X X X . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+97   --- p\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . . . . . . .  4\n: . . . . . . . . .  5\n: . . . . . . . . .  6\n: . X X X X X . . .  7\n: . X . . . . X . .  8\n: . X . . . . . X .  9\n: . X . . . . . X .  10\n: . X . . . . . X .  11\n: . X . . . . X . .  12\n: . X X X X X . . .  13\n: . X . . . . . . .  14\n: . X . . . . . . .  15\n: X X X X X X X X X  16\n.\n+98   --- q\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . . . . . . .  4\n: . . . . . . . . .  5\n: . . . . . . . . .  6\n: . . X X X X X . .  7\n: . X . . . . X . .  8\n: . X . . . . X . .  9\n: . X . . . . X . .  10\n: . X . . . . X . .  11\n: . X . . . X X . .  12\n: . . X X X . X . .  13\n: . . . . . . X X .  14\n: . . . . . . X . .  15\n: X X X X X X X X X  16\n.\n+99   --- r\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . . . . . . .  4\n: . . . . . . . . .  5\n: . . . . . . . . .  6\n: . X . X X X . . .  7\n: . X X . . . . . .  8\n: . X . . . . . . .  9\n: . X . . . . . . .  10\n: . X . . . . . . .  11\n: . X . . . . . . .  12\n: . X . . . . . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+A2   --- s\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . . . . . . .  4\n: . . . . . . . . .  5\n: . . . . . . . . .  6\n: . . X X X X X . .  7\n: . X . . . . . . .  8\n: . X . . . . . . .  9\n: . . X X X X . . .  10\n: . . . . . . X . .  11\n: . . . . . . X . .  12\n: . X X X X X . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+A3   --- t\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . X . . . . .  3\n: . . . X . . . . .  4\n: . . . X . . . . .  5\n: . . . X . . . . .  7\n: . X X X X X . . .  6\n: . . . X . . . . .  8\n: . . . X . . . . .  9\n: . . . X . . . . .  10\n: . . . X . . . . .  11\n: . . . X . . . . .  12\n: . . . X X X . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+A4   --- u\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . . . . . . .  4\n: . . . . . . . . .  5\n: . . . . . . . . .  6\n: . X . . . . X . .  7\n: . X . . . . X . .  8\n: . X . . . . X . .  9\n: . X . . . . X . .  10\n: . X . . . . X . .  11\n: . X . . . . X . .  12\n: . . X X X X . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+A5   --- v\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . . . . . . .  4\n: . . . . . . . . .  5\n: . . . . . . . . .  6\n: . X . . . . . X .  7\n: . X . . . . . X .  8\n: . . X . . . X . .  9\n: . . X . . . X . .  10\n: . . . X . X . . .  11\n: . . . X . X . . .  12\n: . . . . X . . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+A6   --- w\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . . . . . . .  4\n: . . . . . . . . .  5\n: . . . . . . . . .  6\n: . X . . . . . X .  7\n: . X . . . . . X .  8\n: . X . . X . . X .  9\n: . X . . X . . X .  10\n: . X . . X . . X .  11\n: . X . X . X . X .  12\n: . . X . . . X . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+A7   --- x\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . . . . . . .  4\n: . . . . . . . . .  5\n: . . . . . . . . .  6\n: . X . . . . . X .  7\n: . . X . . . X . .  8\n: . . . X . X . . .  9\n: . . . . X . . . .  10\n: . . . X . X . . .  11\n: . . X . . . X . .  12\n: . X . . . . . X .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+A8   --- y\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . . . . . . .  4\n: . . . . . . . . .  5\n: . . . . . . . . .  6\n: . X . . . . . X .  7\n: . . X . . . . X .  8\n: . . . X . . X . .  9\n: . . . . X . X . .  10\n: . . . . . X . . .  11\n: . . . . . X . . .  12\n: . . . . X . . . .  13\n: . . . . X . . . .  14\n: . . . X . . . . .  15\n: X X X X X X X X X  16\n.\n+A9   --- z\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . . . . . . .  4\n: . . . . . . . . .  5\n: . . . . . . . . .  6\n: . X X X X X X X .  7\n: . . . . . . X . .  8\n: . . . . . X . . .  9\n: . . . . X . . . .  10\n: . . . X . . . . .  11\n: . . X . . . . . .  12\n: . X X X X X X X .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+F0\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . X X X X X . .  3\n: . X . . . . . X .  4\n: . X . . . . . X .  5\n: . X . . . . . X .  6\n: . X . . X . . X .  7\n: . X . . X . . X .  8\n: . X . . X . . X .  9\n: . X . . . . . X .  10\n: . X . . . . . X .  11\n: . X . . . . . X .  12\n: . . X X X X X . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+F1   --- 1\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . X . . . .  3\n: . . . X X . . . .  4\n: . . . . X . . . .  5\n: . . . . X . . . .  6\n: . . . . X . . . .  7\n: . . . . X . . . .  8\n: . . . . X . . . .  9\n: . . . . X . . . .  10\n: . . . . X . . . .  11\n: . . . . X . . . .  12\n: . . . X X X . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+F2   --- 2\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . X X X X X . .  3\n: . X . . . . . X .  4\n: . . . . . . . X .  5\n: . . . . . . . X .  6\n: . . . . . . X . .  7\n: . . . . . X . . .  8\n: . . . . X . . . .  9\n: . . . X . . . . .  10\n: . . X . . . . . .  11\n: . X . . . . . . .  12\n: . X X X X X X X .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+F3   --- 3\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . X X X X X . .  3\n: . X . . . . . X .  4\n: . . . . . . . X .  5\n: . . . . . . . X .  6\n: . . . . . . X . .  7\n: . . . X X X . . .  8\n: . . . . . . X . .  9\n: . . . . . . . X .  10\n: . . . . . . . X .  11\n: . X . . . . . X .  12\n: . . X X X X X . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+F4   --- 4\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . X . . .  3\n: . . . . X X . . .  4\n: . . . X . X . . .  5\n: . . X . . X . . .  6\n: . X . . . X . . .  7\n: . X X X X X X X .  8\n: . . . . . X . . .  9\n: . . . . . X . . .  10\n: . . . . . X . . .  11\n: . . . . . X . . .  12\n: . . . . . X . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+F5   --- 5\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . X X X X X X X .  3\n: . X . . . . . . .  4\n: . X . . . . . . .  5\n: . X . . . . . . .  6\n: . X X X X X X . .  7\n: . . . . . . . X .  8\n: . . . . . . . X .  9\n: . . . . . . . X .  10\n: . X . . . . . X .  11\n: . . X . . . X . .  12\n: . . . X X X . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+F6   --- 6\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . X X X . .  3\n: . . . X . . . X .  4\n: . . X . . . . . .  5\n: . X . . . . . . .  6\n: . X . . . . . . .  7\n: . X . X X X X . .  8\n: . X X . . . . X .  9\n: . X . . . . . X .  10\n: . X . . . . . X .  11\n: . X . . . . . X .  12\n: . . X X X X X . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+F7   --- 7\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . X X X X X X X .  3\n: . . . . . . . X .  4\n: . . . . . . X . .  5\n: . . . . . . X . .  6\n: . . . . . X . . .  7\n: . . . . . X . . .  8\n: . . . . X . . . .  9\n: . . . . X . . . .  10\n: . . . . X . . . .  11\n: . . . X . . . . .  12\n: . . . X . . . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+F8   --- 8\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . X X X X X . .  3\n: . X . . . . . X .  4\n: . X . . . . . X .  5\n: . X . . . . . X .  6\n: . . X . . . X . .  7\n: . . . X X X . . .  8\n: . . X . . . X . .  9\n: . X . . . . . X .  10\n: . X . . . . . X .  11\n: . X . . . . . X .  12\n: . . X X X X X . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+F9\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . X X X X X . .  3\n: . X . . . . . X .  4\n: . X . . . . . X .  5\n: . X . . . . . X .  6\n: . . X X X X X X .  7\n: . . . . . . . X .  8\n: . . . . . . . X .  9\n: . . . . . . . X .  10\n: . . . . . . . X .  11\n: . . X . . . X . .  12\n: . . . X X X . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+4A   --- CENT\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . . X . . . .  4\n: . . . . X . . . .  5\n: . . X X X X X . .  6\n: . X . . X . . X .  7\n: . X . . X . . . .  8\n: . X . . X . . . .  9\n: . X . . X . . . .  10\n: . X . . X . . X .  11\n: . . X X X X X . .  12\n: . . . . X . . . .  13\n: . . . . X . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+4B   --- .\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . . . . . . .  4\n: . . . . . . . . .  5\n: . . . . . . . . .  6\n: . . . . . . . . .  7\n: . . . . . . . . .  8\n: . . . . . . . . .  9\n: . . . . . . . . .  10\n: . . . . . . . . .  11\n: . . X X . . . . .  12\n: . . X X . . . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+4C   --- <\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . . X . .  3\n: . . . . . X . . .  4\n: . . . . X . . . .  5\n: . . . X . . . . .  6\n: . . X . . . . . .  7\n: . X . . . . . . .  8\n: . . X . . . . . .  9\n: . . . X . . . . .  10\n: . . . . X . . . .  11\n: . . . . . X . . .  12\n: . . . . . . X . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+4D   --- (\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . X . . . .  3\n: . . . X . . . . .  4\n: . . . X . . . . .  5\n: . . X . . . . . .  6\n: . . X . . . . . .  7\n: . . X . . . . . .  8\n: . . X . . . . . .  9\n: . . X . . . . . .  10\n: . . . X . . . . .  11\n: . . . X . . . . .  12\n: . . . . X . . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+4F   --- |\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . X . . . .  3\n: . . . . X . . . .  4\n: . . . . X . . . .  5\n: . . . . X . . . .  6\n: . . . . X . . . .  7\n: . . . . X . . . .  8\n: . . . . X . . . .  9\n: . . . . X . . . .  10\n: . . . . X . . . .  11\n: . . . . X . . . .  12\n: . . . . X . . . .  13\n: . . . . X . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+50   --- &\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . X X X . . . .  3\n: . X . . . X . . .  4\n: . X . . . X . . .  5\n: . . X . X . . . .  6\n: . . X X X . . . .  7\n: . X . . . X . X .  8\n: . X . . . . X . .  9\n: . X . . . . X . .  10\n: . X . . . X . X .  11\n: . X . . . X . . .  12\n: . . X X X . . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+5A   --- !\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . X . . . .  3\n: . . . . X . . . .  4\n: . . . . X . . . .  5\n: . . . . X . . . .  6\n: . . . . X . . . .  7\n: . . . . X . . . .  8\n: . . . . X . . . .  9\n: . . . . X . . . .  10\n: . . . . . . . . .  11\n: . . . . X . . . .  12\n: . . . X X X . . .  13\n: . . . . X . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+5B   --- $\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . X . . . .  3\n: . . . X X X . . .  4\n: . . X . X . X . .  5\n: . X . . X . . . .  6\n: . . X . X . . . .  7\n: . . . X X X . . .  8\n: . . . . X . X . .  9\n: . . . . X . . X .  10\n: . . X . X . X . .  11\n: . . . X X X . . .  12\n: . . . . X . . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+7F   --- \"\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . X . X . . .  3\n: . . . X . X . . .  4\n: . . . X . X . . .  5\n: . . . . . . . . .  6\n: . . . . . . . . .  7\n: . . . . . . . . .  8\n: . . . . . . . . .  9\n: . . . . . . . . .  10\n: . . . . . . . . .  11\n: . . . . . . . . .  12\n: . . . . . . . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+5D   --- )\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . X . . . .  3\n: . . . . . X . . .  4\n: . . . . . X . . .  5\n: . . . . . . X . .  6\n: . . . . . . X . .  7\n: . . . . . . X . .  8\n: . . . . . . X . .  9\n: . . . . . . X . .  10\n: . . . . . X . . .  11\n: . . . . . X . . .  12\n: . . . . X . . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+5E   --- ;\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . . . . . . .  4\n: . . . . . . . . .  5\n: . . . . . . . . .  6\n: . . . . . . . . .  7\n: . . X X . . . . .  8\n: . . X X . . . . .  9\n: . . . . . . . . .  10\n: . . . . . . . . .  11\n: . . X X . . . . .  12\n: . . X X . . . . .  13\n: . . . X . . . . .  14\n: . . X . . . . . .  15\n: X X X X X X X X X  16\n.\n+7A   --- :\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . . . . . . .  4\n: . . . . . . . . .  5\n: . . . . . . . . .  6\n: . . . . . . . . .  7\n: . . X X . . . . .  8\n: . . X X . . . . .  9\n: . . . . . . . . .  10\n: . . . . . . . . .  11\n: . . X X . . . . .  12\n: . . X X . . . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+5F   --- \u00ac\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . X X X X X . . .  4\n: . . . . . X . . .  5\n: . . . . . X . . .  6\n: . . . . . . . . .  7\n: . . . . . . . . .  8\n: . . . . . . . . .  9\n: . . . . . . . . .  10\n: . . . . . . . . .  11\n: . . . . . . . . .  12\n: . . . . . . . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+60   --- -\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . . . . . . .  4\n: . . . . . . . . .  5\n: . . . . . . . . .  6\n: . X X X X X X X .  7\n: . . . . . . . . .  8\n: . . . . . . . . .  9\n: . . . . . . . . .  10\n: . . . . . . . . .  11\n: . . . . . . . . .  12\n: . . . . . . . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+61   --- /\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . . . X .  3\n: . . . . . . X . .  4\n: . . . . . . X . .  5\n: . . . . . X . . .  6\n: . . . . . X . . .  7\n: . . . . X . . . .  8\n: . . . . X . . . .  9\n: . . . X . . . . .  10\n: . . . X . . . . .  11\n: . . X . . . . . .  12\n: . . X . . . . . .  13\n: . X . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+6B   --- ,\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . . . . . . .  4\n: . . . . . . . . .  5\n: . . . . . . . . .  6\n: . . . . . . . . .  7\n: . . . . . . . . .  8\n: . . . . . . . . .  9\n: . . . . . . . . .  10\n: . . . . . . . . .  11\n: . . X X . . . . .  12\n: . . X X . . . . .  13\n: . . . X . . . . .  14\n: . . X . . . . . .  15\n: X X X X X X X X X  16\n.\n+6C   --- %\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . X X . . . X .  3\n: . X . . X . X . .  4\n: . X . . X . X . .  5\n: . . X X . X . . .  6\n: . . . . . X . . .  7\n: . . . . X . . . .  8\n: . . . . X . . . .  9\n: . . . X . . . . .  10\n: . . . X . X X . .  11\n: . . X . X . . X .  12\n: . . X . X . . X .  13\n: . X . . . X X . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+6D   --- _\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . . . . . . .  4\n: . . . . . . . . .  5\n: . . . . . . . . .  6\n: . . . . . . . . .  7\n: . . . . . . . . .  8\n: . . . . . . . . .  9\n: . . . . . . . . .  10\n: . . . . . . . . .  11\n: . . . . . . . . .  12\n: . . . . . . . . .  13\n: X X X X X X X X X  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+6E   --- >\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . X . . . . . . .  3\n: . . X . . . . . .  4\n: . . . X . . . . .  5\n: . . . . X . . . .  6\n: . . . . . X . . .  7\n: . . . . . . X . .  8\n: . . . . . X . . .  9\n: . . . . X . . . .  10\n: . . . X . . . . .  11\n: . . X . . . . . .  12\n: . X . . . . . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+6F   --- ?\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . X X X . . .  3\n: . . X . . . X . .  4\n: . . . . . . X . .  5\n: . . . . . . X . .  6\n: . . . . . X . . .  7\n: . . . . X . . . .  8\n: . . . . X . . . .  9\n: . . . . . . . . .  10\n: . . . . X . . . .  11\n: . . . X X X . . .  12\n: . . . . X . . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+7B   --- #\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . X . X . . .  3\n: . . . X . X . . .  4\n: . . . X . X . . .  5\n: . X X X X X X X .  6\n: . . . X . X . . .  7\n: . . . X . X . . .  8\n: . . . X . X . . .  9\n: . X X X X X X X .  10\n: . . . X . X . . .  11\n: . . . X . X . . .  12\n: . . . X . X . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+7C   --- @\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . X X X X X . .  3\n: . X . . . . . X .  4\n: . X . . . . . X .  5\n: . X . . X X X X .  6\n: . X . X . . . X .  7\n: . X . X . . . X .  8\n: . X . X . . . X .  9\n: . X . X . . . X .  10\n: . X . . X X X . .  11\n: . X . . . . . . .  12\n: . . X X X X X X .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+7D   --- '\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . X . . . .  3\n: . . . . X . . . .  4\n: . . . . X . . . .  5\n: . . . . . . . . .  6\n: . . . . . . . . .  7\n: . . . . . . . . .  8\n: . . . . . . . . .  9\n: . . . . . . . . .  10\n: . . . . . . . . .  11\n: . . . . . . . . .  12\n: . . . . . . . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+7E   --- =\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . . . . . . .  4\n: . . . . . . . . .  5\n: . X X X X X X X .  6\n: . . . . . . . . .  7\n: . . . . . . . . .  8\n: . X X X X X X X .  9\n: . . . . . . . . .  10\n: . . . . . . . . .  11\n: . . . . . . . . .  12\n: . . . . . . . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+5C   --- *\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . . X . . . .  4\n: . . . . X . . . .  5\n: . . X . X . X . .  6\n: . . . X X X . . .  7\n: . X X X X X X X .  8\n: . . . X X X . . .  9\n: . . X . X . X . .  10\n: . . . . X . . . .  11\n: . . . . X . . . .  12\n: . . . . . . . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+42   --- LEFT END\n. 1 2 3 4 5 6 7 8 9\n: . . . . X X X X X  1\n: . . . . X . . . .  2\n: . . . . X . . . .  3\n: . . . . X . . . .  4\n: . . . . X . . . .  5\n: . . . . X . . . .  6\n: . . . . X . . . .  7\n: . . . . X . . . .  8\n: . . . . X . . . .  9\n: . . . . X . . . .  10\n: . . . . X . . . .  11\n: . . . . X . . . .  12\n: . . . . X . . . .  13\n: . . . . X . . . .  14\n: . . . . X . . . .  15\n: . . . . X X X X X  16\n.\n+43   --- RIGHT END\n. 1 2 3 4 5 6 7 8 9\n: X . . . . . . . .  1\n: X . . . . . . . .  2\n: X . . . . . . . .  3\n: X . . . . . . . .  4\n: X . . . . . . . .  5\n: X . . . . . . . .  6\n: X . . . . . . . .  7\n: X . . . . . . . .  8\n: X . . . . . . . .  9\n: X . . . . . . . .  10\n: X . . . . . . . .  11\n: X . . . . . . . .  12\n: X . . . . . . . .  13\n: X . . . . . . . .  14\n: X . . . . . . . .  15\n: X . . . . . . . .  16\n.\n+44   --- OTHER RIGHT END\n. 1 2 3 4 5 6 7 8 9\n: X X X X X . . . .  1\n: . . . . X . . . .  2\n: . . . . X . . . .  3\n: . . . . X . . . .  4\n: . . . . X . . . .  5\n: . . . . X . . . .  6\n: . . . . X . . . .  7\n: . . . . X . . . .  8\n: . . . . X . . . .  9\n: . . . . X . . . .  10\n: . . . . X . . . .  11\n: . . . . X . . . .  12\n: . . . . X . . . .  13\n: . . . . X . . . .  14\n: . . . . X . . . .  15\n: X X X X X . . . .  16\n.\n+49   --- TOP LEFT WINDOW BORDER\n. 1 2 3 4 5 6 7 8 9\n: . . . . X X X X X\n: . . . . X . X . X\n: . . . . X X . X .\n: . . . . X . X . .\n: . . . . X X . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X X X X X\n.\n+51   --- BOTTOM RIGHT WINDOW BORDER\n. 1 2 3 4 5 6 7 8 9\n: X X X X X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . X X . . . .\n: . . X . X . . . .\n: . X . X X . . . .\n: X . X . X . . . .\n: X X X X X . . . .\n.\n+47   --- 3D MINUS SIGN\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . X X . X X . X X  4\n: . X X . X X . X X  5\n: . . . . . . . . .  6\n: . . . . . . . . .  7\n: . . X X . . X X .  8\n: . . X X . . X X .  9\n: . . . . . . . . .  10\n: . . . . . . . . .  11\n: . . . . X X . . .  12\n: . . . . X X . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+48   --- BLANK REPLACEMENT\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . . . . . . .  4\n: . . . . . . . . .  5\n: . . . . . . . . .  6\n: . . . . . . . . .  7\n: . . . . . . . . .  8\n: . . . . . . . . .  9\n: . . . . . . . . .  10\n: . . . . . . . . .  11\n: . . . . . . . . .  12\n: . . . . . . . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+45   --- WINDOW CONTROL FOR MAXIMISE\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: X X X X X X X X X  3\n: X . . . . X . . X  4\n: X . . . . X . . X  5\n: X . . . . X . . X  6\n: X . . . . X . . X  7\n: X . . . . X . . X  8\n: X X X X X X . . X  9\n: X . . . . . . . X  10\n: X . . . . . . . X  11\n: X . . . . . . . X  12\n: X . . . . . . . X  13\n: X X X X X X X X X  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+46   --- WINDOW CONTROL FOR MINIMISE\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: X X X X X X . . .  3\n: X . . . . X . . .  4\n: X . . . . X . . .  5\n: X . . . . X . . .  6\n: X . . . . X . . .  7\n: X . . . . X . . .  8\n: X X X X X X . . .  9\n: . . . . . . . . .  10\n: . . . . . X . . .  11\n: . . . . . . X X X  12\n: . . . . . . X X X  13\n: . . . . . . X X X  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+52   --- WINDOW CONTROL FOR TERNINATE WINDOW\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . X . . . . . X .  4\n: . X X . . . X X .  5\n: . X X X . X X X .  6\n: . . X X X X X . .  7\n: . . . X X X . . .  8\n: . . X X X X X . .  9\n: . X X X . X X X .  10\n: . X X . . . X X .  11\n: . X . . . . . X .  12\n: . . . . . . . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+53   --- RADIO BUTTON - ON\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . X X X . . .  4\n: . . X . . . X . .  5\n: . X . . . . . X .  6\n: X . . X X X . . X  7\n: X . X X X X X . X  8\n: X . X X X X X . X  9\n: X . . X X X . . X  10\n: . X . . . . . X .  11\n: . . X . . . X . .  12\n: . . . X X X . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: . . . . . . . . .  16\n.\n+54   --- RADIO BUTTON - OFF\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . X X X . . .  4\n: . . X . . . X . .  5\n: . X . . . . . X .  6\n: X . . . . . . . X  7\n: X . . . . . . . X  8\n: X . . . . . . . X  9\n: X . . . . . . . X  10\n: . X . . . . . X .  11\n: . . X . . . X . .  12\n: . . . X X X . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: . . . . . . . . .  16\n.\n+55   --- CHECK BOX - ON\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: X X X X X X X X X  4\n: X X . . . . . X X  5\n: X . X . . . X . X  6\n: X . . X . X . . X  7\n: X . . . X . . . X  8\n: X . . X . X . . X  9\n: X . X . . . X . X  10\n: X X . . . . . X X  11\n: X X X X X X X X X  12\n: . . . . . . . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: . . . . . . . . .  16\n.\n+56   --- CHECK BOX - OFF\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: X X X X X X X X X  4\n: X . . . . . . . X  5\n: X . . . . . . . X  6\n: X . . . . . . . X  7\n: X . . . . . . . X  8\n: X . . . . . . . X  9\n: X . . . . . . . X  10\n: X . . . . . . . X  11\n: X X X X X X X X X  12\n: . . . . . . . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: . . . . . . . . .  16\n.\n+57   --- CHECK BOX - OFF - GRAYED\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: X . X . X . X . X  4\n: . . . . . . . . .  5\n: X . . . . . . . X  6\n: . . . . . . . . .  7\n: X . . . . . . . X  8\n: . . . . . . . . .  9\n: X . . . . . . . X  10\n: . . . . . . . . .  11\n: X . X . X . X . X  12\n: . . . . . . . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: . . . . . . . . .  16\n.\n+58   --- BAR GRAPH - MIDDLE FULL\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: X X X X X X X X X  4\n: X X X X X X X X X  5\n: X X X X X X X X X  6\n: X X X X X X X X X  7\n: X X X X X X X X X  8\n: X X X X X X X X X  9\n: X X X X X X X X X  10\n: X X X X X X X X X  11\n: X X X X X X X X X  12\n: X X X X X X X X X  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+59   --- BAR GRAPH - START FULL\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: X . . . . . . . .  2\n: X . . . . . . . .  3\n: X . X X X X X X X  4\n: X . X X X X X X X  5\n: X . X X X X X X X  6\n: X . X X X X X X X  7\n: X . X X X X X X X  8\n: X . X X X X X X X  9\n: X . X X X X X X X  10\n: X . X X X X X X X  11\n: X . X X X X X X X  12\n: X . X X X X X X X  13\n: X . . . . . . . .  14\n: X . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+62   --- BAR GRAPH - END FULL\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . X  2\n: . . . . . . . . X  3\n: X X X X X X X . X  4\n: X X X X X X X . X  5\n: X X X X X X X . X  6\n: X X X X X X X . X  7\n: X X X X X X X . X  8\n: X X X X X X X . X  9\n: X X X X X X X . X  10\n: X X X X X X X . X  11\n: X X X X X X X . X  12\n: X X X X X X X . X  13\n: . . . . . . . . X  14\n: . . . . . . . . X  15\n: X X X X X X X X X  16\n.\n+63   --- BAR GRAPH - END EMPTY\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . X  2\n: . . . . . . . . X  3\n: . . . . . . . . X  4\n: . . . . . . . . X  5\n: . . . . . . . . X  6\n: . . . . . . . . X  7\n: . . . . . . . . X  8\n: . . . . . . . . X  9\n: . . . . . . . . X  10\n: . . . . . . . . X  11\n: . . . . . . . . X  12\n: . . . . . . . . X  13\n: . . . . . . . . X  14\n: . . . . . . . . X  15\n: X X X X X X X X X  16\n.\n+64   --- BAR GRAPH - START EMPTY\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: X . . . . . . . .  2\n: X . . . . . . . .  3\n: X . . . . . . . .  4\n: X . . . . . . . .  5\n: X . . . . . . . .  6\n: X . . . . . . . .  7\n: X . . . . . . . .  8\n: X . . . . . . . .  9\n: X . . . . . . . .  10\n: X . . . . . . . .  11\n: X . . . . . . . .  12\n: X . . . . . . . .  13\n: X . . . . . . . .  14\n: X . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+65   --- BAR GRAPH - MIDDLE EMPTY\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . . . . . . .  4\n: . . . . . . . . .  5\n: . . . . . . . . .  6\n: . . . . . . . . .  7\n: . . . . . . . . .  8\n: . . . . . . . . .  9\n: . . . . . . . . .  10\n: . . . . . . . . .  11\n: . . . . . . . . .  12\n: . . . . . . . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+66   --- LEFT TOP CORNER\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . . . . . . .  4\n: . . . . . . . . .  5\n: . . . . . . . . .  6\n: . . . . . . . . .  7\n: . . . . X X X X X  8\n: . . . . X . . . .  9\n: . . . . X . . . .  10\n: . . . . X . . . .  11\n: . . . . X . . . .  12\n: . . . . X . . . .  13\n: . . . . X . . . .  14\n: . . . . X . . . .  15\n: . . . . X . . . .  16\n.\n+67   --- LEFT BOTTOM CORNER\n. 1 2 3 4 5 6 7 8 9\n: . . . . X . . . .  1\n: . . . . X . . . .  2\n: . . . . X . . . .  3\n: . . . . X . . . .  4\n: . . . . X . . . .  5\n: . . . . X . . . .  6\n: . . . . X . . . .  7\n: . . . . X X X X X  8\n: . . . . . . . . .  9\n: . . . . . . . . .  10\n: . . . . . . . . .  11\n: . . . . . . . . .  12\n: . . . . . . . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: . . . . . . . . .  16\n.\n+68   --- RIGHT TOP CORNER\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . . . . . . .  4\n: . . . . . . . . .  5\n: . . . . . . . . .  6\n: . . . . . . . . .  7\n: X X X X X . . . .  8\n: . . . . X . . . .  9\n: . . . . X . . . .  10\n: . . . . X . . . .  11\n: . . . . X . . . .  12\n: . . . . X . . . .  13\n: . . . . X . . . .  14\n: . . . . X . . . .  15\n: . . . . X . . . .  16\n.\n+69   --- RIGHT BOTTOM CORNER\n. 1 2 3 4 5 6 7 8 9\n: . . . . X . . . .  1\n: . . . . X . . . .  2\n: . . . . X . . . .  3\n: . . . . X . . . .  4\n: . . . . X . . . .  5\n: . . . . X . . . .  6\n: . . . . X . . . .  7\n: X X X X X . . . .  8\n: . . . . . . . . .  9\n: . . . . . . . . .  10\n: . . . . . . . . .  11\n: . . . . . . . . .  12\n: . . . . . . . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: . . . . . . . . .  16\n.\n+70   --- FLAT LINE - HORIZONTAL\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . . . . . . .  4\n: . . . . . . . . .  5\n: . . . . . . . . .  6\n: . . . . . . . . .  7\n: X X X X X X X X X  8\n: . . . . . . . . .  9\n: . . . . . . . . .  10\n: . . . . . . . . .  11\n: . . . . . . . . .  12\n: . . . . . . . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: . . . . . . . . .  16\n.\n+71   --- FLAT LINE - VERTICAL\n. 1 2 3 4 5 6 7 8 9\n: . . . . X . . . .  1\n: . . . . X . . . .  2\n: . . . . X . . . .  3\n: . . . . X . . . .  4\n: . . . . X . . . .  5\n: . . . . X . . . .  6\n: . . . . X . . . .  7\n: . . . . X . . . .  8\n: . . . . X . . . .  9\n: . . . . X . . . .  10\n: . . . . X . . . .  11\n: . . . . X . . . .  12\n: . . . . X . . . .  13\n: . . . . X . . . .  14\n: . . . . X . . . .  15\n: . . . . X . . . .  16\n.\n+72   --- VERTICAL LINE\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . X . . . .  2\n: . . . . X . . . .  3\n: . . . . X . . . .  4\n: . . . . X . . . .  5\n: . . . . X . . . .  6\n: . . . . X . . . .  7\n: . . . . X . . . .  8\n: . . . . X . . . .  9\n: . . . . X . . . .  10\n: . . . . X . . . .  11\n: . . . . X . . . .  12\n: . . . . X . . . .  13\n: . . . . X . . . .  14\n: . . . . X . . . .  15\n: X X X X X X X X X  16\n.\n+73   --- RADIO BUTTON - UNDEFINED\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . . X . . . .  4\n: . . X . . . X . .  5\n: . . . . . . . . .  6\n: X . . . . . . . X  7\n: . . . . . . . . .  8\n: X . . . . . . . X  9\n: . . . . . . . . .  10\n: . X . . . . . X .  11\n: . . . . . . . . .  12\n: . . . X . X . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: . . . . . . . . .  16\n.\n+74   --- CHECK BOX - ON - GRAYED\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: X . X . X . X . X  4\n: . X . . . . . X .  5\n: X . X . . . X . X  6\n: . . . X . X . . .  7\n: X . . . X . . . X  8\n: . . . X . X . . .  9\n: X . X . . . X . X  10\n: . X . . . . . X .  11\n: X . X . X . X . X  12\n: . . . . . . . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: . . . . . . . . .  16\n.\n+75   --- CHECK BOX - UNDEFINED\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: X X X X X X X X X  4\n: X . . . . . . . X  5\n: X . X . . . X . X  6\n: X . . . . . . . X  7\n: X . . . X . . . X  8\n: X . . . . . . . X  9\n: X . X . . . X . X  10\n: X . . . . . . . X  11\n: X X X X X X X X X  12\n: . . . . . . . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: . . . . . . . . .  16\n.\n+76   --- CHECK BOX - GRAYED - UNDEFINED STATE\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: X . X . X . X . X  4\n: . . . . . . . . .  5\n: X . X . . . X . X  6\n: . . . . . . . . .  7\n: X . . . X . . . X  8\n: . . . . . . . . .  9\n: X . X . . . X . X  10\n: . . . . . . . . .  11\n: X . X . X . X . X  12\n: . . . . . . . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: . . . . . . . . .  16\n.\n+77   --- RADIO BUTTON - ON - GRAYED\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . . X . . . .  4\n: . . X . . . X . .  5\n: . . . . . . . . .  6\n: X . . X X X . . X  7\n: . . X X X X X . .  8\n: X . X X X X X . X  9\n: . . . X X X . . .  10\n: . X . . . . . X .  11\n: . . . . . . . . .  12\n: . . . X . X . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: . . . . . . . . .  16\n.\n+78   --- RADIO BUTTON - UNDEFINED\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . X X X . . .  4\n: . . X . . . X . .  5\n: . X . . . . . X .  6\n: X . . X . X . . X  7\n: X . X . X . X . X  8\n: X . . X . X . . X  9\n: X . . . X . . . X  10\n: . X . . . . . X .  11\n: . . X . . . X . .  12\n: . . . X X X . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: . . . . . . . . .  16\n.\n+80   --- RADIO BUTTON - UNDEFINED - GRAYED\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . . X . . . .  4\n: . . X . . . X . .  5\n: . . . . . . . . .  6\n: X . . X . X . . X  7\n: . . X . X . X . .  8\n: X . . X . X . . X  9\n: . . . . X . . . .  10\n: . X . . . . . X .  11\n: . . . . . . . . .  12\n: . . . X . X . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: . . . . . . . . .  16\n.\n+8A   --- BUTTON NOT PRESSED\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X X X X X . .\n: . . X . . . X . .\n: . . X . . . X . .\n: . . X . . . X . .\n: . . X . . . X . .\n: . . X . . . X . .\n: . . X . . . X . .\n: . . X . . . X . .\n: . . X . . . X . .\n: . . X . . . X . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+90   --- BUTTON INDETERMINATE\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X X X X X . .\n: . . X . . . X . .\n: . . X . . . X . .\n: . . X . . . X . .\n: . . X . . . X . .\n: . . X . . . X . .\n: . . X X X X X . .\n: . . X X X X X . .\n: . . X X X X X . .\n: . . X X X X X . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+9A   --- BUTTON PRESSED\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X X X X X . .\n: . . X X X X X . .\n: . . X X X X X . .\n: . . X X X X X . .\n: X X X X X X X X X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+BA   --- BUTTON NOT PRESSED - GRAY\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X . X . X . .\n: . . . . . . . . .\n: . . X . . . X . .\n: . . . . . . . . .\n: . . X . . . X . .\n: . . . . . . . . .\n: . . X . . . X . .\n: . . . . . . . . .\n: . . X . . . X . .\n: . . . . . . . . .\n: X . X . X . X . X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+CA   --- BUTTON INDETERMINATE - GRAY\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X . X . X . .\n: . . . . . . . . .\n: . . X . . . X . .\n: . . . . . . . . .\n: . . X . . . X . .\n: . . . . . . . . .\n: . . X . X . X . .\n: . . . X . X . . .\n: . . X . X . X . .\n: . . . X . X . . .\n: X . X . X . X . X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+CB   --- BUTTON PRESSED - GRAY\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n: . . X . X . X . .\n: . . . X . X . . .\n: . . X . X . X . .\n: . . . X . X . . .\n: X . X . X . X . X\n: . . . . . . . . .\n: . . . . . . . . .\n: . . . . . . . . .\n.\n+CD   --- LEFT HORIZONTAL SCROLL ARROW\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: X . . . . . . . .  2\n: X . . . . . . X .  3\n: X . . . . . X X .  4\n: X . . . . X X X .  5\n: X . . . X X X X .  6\n: X . . X X X X X .  7\n: X . X X X X X X .  8\n: X . . X X X X X .  9\n: X . . . X X X X .  10\n: X . . . . X X X .  11\n: X . . . . . X X .  12\n: X . . . . . . X .  13\n: X . . . . . . . .  14\n: X . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+CF   --- RIGHT HORIZONTAL SCROLL ARROW\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . X  2\n: . X . . . . . . X  3\n: . X X . . . . . X  4\n: . X X X . . . . X  5\n: . X X X X . . . X  6\n: . X X X X X . . X  7\n: . X X X X X X . X  8\n: . X X X X X . . X  9\n: . X X X X . . . X  10\n: . X X X . . . . X  11\n: . X X . . . . . X  12\n: . X . . . . . . X  13\n: . . . . . . . . X  14\n: . . . . . . . . X  15\n: X X X X X X X X X  16\n.\n+DA   --- VERTICAL SCROLL BAR CHAR\n. 1 2 3 4 5 6 7 8 9\n: X . . . . . . . X  1\n: X . . . . . . . X  2\n: X . . . . . . . X  3\n: X . . . . . . . X  4\n: X . . . . . . . X  5\n: X . . . . . . . X  6\n: X . . . . . . . X  7\n: X . . . . . . . X  8\n: X . . . . . . . X  9\n: X . . . . . . . X  10\n: X . . . . . . . X  11\n: X . . . . . . . X  12\n: X . . . . . . . X  13\n: X . . . . . . . X  14\n: X . . . . . . . X  15\n: X . . . . . . . X  16\n.\n+DB   --- VERTICAL SCROLL BAR THUMB\n. 1 2 3 4 5 6 7 8 9\n: X . X X X X X . X  1\n: X . X X X X X . X  2\n: X . X X X X X . X  3\n: X . X X X X X . X  4\n: X . X X X X X . X  5\n: X . X X X X X . X  6\n: X . X X X X X . X  7\n: X . X X X X X . X  8\n: X . X X X X X . X  9\n: X . X X X X X . X  10\n: X . X X X X X . X  11\n: X . X X X X X . X  12\n: X . X X X X X . X  13\n: X . X X X X X . X  14\n: X . X X X X X . X  15\n: X . X X X X X . X  16\n.\n+DC   --- VERTICAL SCROLL BAR TOP ARROW\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: X . . . . . . . X  2\n: X . . . . . . . X  3\n: X . . . X . . . X  4\n: X . . . X . . . X  5\n: X . . . X . . . X  6\n: X . . X X X . . X  7\n: X . . X X X . . X  8\n: X . . X X X . . X  9\n: X . X X X X X . X  10\n: X . X X X X X . X  11\n: X . X X X X X . X  12\n: X . . . . . . . X  13\n: X . . . . . . . X  14\n: X . . . . . . . X  15\n: X . . . . . . . X  16\n.\n+DD   --- VERTICAL SCROLL BAR BOTTOM ARROW\n. 1 2 3 4 5 6 7 8 9\n: X . . . . . . . X  1\n: X . . . . . . . X  2\n: X . . . . . . . X  3\n: X . . . . . . . X  4\n: X . X X X X X . X  5\n: X . X X X X X . X  6\n: X . X X X X X . X  7\n: X . . X X X . . X  8\n: X . . X X X . . X  9\n: X . . X X X . . X  10\n: X . . . X . . . X  11\n: X . . . X . . . X  12\n: X . . . X . . . X  13\n: X . . . . . . . X  14\n: X . . . . . . . X  15\n: X X X X X X X X X  16\n.\n+DE   --- COMBO BOX DROP DOWN CONTROL\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: X . . . . . . . X  2\n: X . . . . . . . X  3\n: X . . X X X . . X  4\n: X . . X X X . . X  5\n: X . . X X X . . X  6\n: X . . X X X . . X  7\n: X . . X X X . . X  8\n: X . . X X X . . X  9\n: X . X X X X X . X  10\n: X . . X X X . . X  11\n: X . . X X X . . X  12\n: X . . . X . . . X  13\n: X . . . X . . . X  14\n: X . . . . . . . X  15\n: X X X X X X X X X  16\n.\n+DF   --- ELIPSIS CONTROL\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: X . . . . . . . X  2\n: X . . . . . . . X  3\n: X . . . . . . . X  4\n: X . . . . . . . X  5\n: X . . . . . . . X  6\n: X . . . . . . . X  7\n: X . . . . . . . X  8\n: X . . . . . . . X  9\n: X . . . . . . . X  10\n: X . X . X . X . X  11\n: X . X . X . X . X  12\n: X . . . . . . . X  13\n: X . . . . . . . X  14\n: X . . . . . . . X  15\n: X X X X X X X X X  16\n.\n+EA   --- FILLED CELL\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: X X X X X X X X X  2\n: X X X X X X X X X  3\n: X X X X X X X X X  4\n: X X X X X X X X X  5\n: X X X X X X X X X  6\n: X X X X X X X X X  7\n: X X X X X X X X X  8\n: X X X X X X X X X  9\n: X X X X X X X X X  10\n: X X X X X X X X X  11\n: X X X X X X X X X  12\n: X X X X X X X X X  13\n: X X X X X X X X X  14\n: X X X X X X X X X  15\n: X X X X X X X X X  16\n.\n+EB   --- HORIZONTAL SCROLL LEFT PAGE ARROW\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . X . . . X .  4\n: . . . X . . . X .  5\n: . . X X . . X X .  6\n: . . X X . . X X .  7\n: . X X X . X X X .  8\n: . . X X . . X X .  9\n: . . X X . . X X .  10\n: . . . X . . . X .  11\n: . . . X . . . X .  12\n: . . . . . . . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+EC   --- HORIZONTAL SCROLL RIGHT PAGE ARROW\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . X . . . X . . .  4\n: . X . . . X . . .  5\n: . X X . . X X . .  6\n: . X X . . X X . .  7\n: . X X X . X X X .  8\n: . X X . . X X . .  9\n: . X X . . X X . .  10\n: . X . . . X . . .  11\n: . X . . . X . . .  12\n: . . . . . . . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+ED   --- VERTICAL SCROLL BAR SCROLL UP PAGE ARROW\n. 1 2 3 4 5 6 7 8 9\n: X . . . . . . . X  1\n: X . . . X . . . X  2\n: X . . . X . . . X  3\n: X . . X X X . . X  4\n: X . . X X X . . X  5\n: X . X X X X X . X  6\n: X . X X X X X . X  7\n: X . . . . . . . X  8\n: X . . . X . . . X  9\n: X . . . X . . . X  10\n: X . . X X X . . X  11\n: X . . X X X . . X  12\n: X . X X X X X . X  13\n: X . X X X X X . X  14\n: X . . . . . . . X  15\n: X . . . . . . . X  16\n.\n+EE   --- VERTICAL SCROLL BAR SCROLL DOWN PAGE ARROW\n. 1 2 3 4 5 6 7 8 9\n: X . . . . . . . X  1\n: X . . . . . . . X  2\n: X . X X X X X . X  3\n: X . X X X X X . X  4\n: X . . X X X . . X  5\n: X . . X X X . . X  6\n: X . . . X . . . X  7\n: X . . . X . . . X  8\n: X . . . . . . . X  9\n: X . X X X X X . X  10\n: X . X X X X X . X  11\n: X . . X X X . . X  12\n: X . . X X X . . X  13\n: X . . . X . . . X  14\n: X . . . X . . . X  15\n: X . . . . . . . X  16\n.\n+EF   --- BOTTON HORIZONTAL LINE\n. 1 2 3 4 5 6 7 8 9\n: . . . . . . . . .  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: . . . . . . . . .  4\n: . . . . . . . . .  5\n: . . . . . . . . .  6\n: . . . . . . . . .  7\n: . . . . . . . . .  8\n: . . . . . . . . .  9\n: . . . . . . . . .  10\n: . . . . . . . . .  11\n: . . . . . . . . .  12\n: . . . . . . . . .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n+9C   --- LEFT TOP CORNER DRAG\n. 1 2 3 4 5 6 7 8 9\n: . . . . X X X X X\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X X . . .\n: . . . . X . X . .\n: . . . . X X . X .\n: . . . . X . X . X\n: . . . . X X X X X\n.\n+9E   --- TOP RIGHT WINDOW BORDER\n. 1 2 3 4 5 6 7 8 9\n: X X X X X . . . .\n: X . X . X . . . .\n: . X . X X . . . .\n: . . X . X . . . .\n: . . . X X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: . . . . X . . . .\n: X X X X X . . . .\n.\n+9F   --- WINDOW SELECTED INDICATOR\n. 1 2 3 4 5 6 7 8 9\n: X X X X X X X X X  1\n: . . . . . . . . .  2\n: . . . . . . . . .  3\n: X X . X X . X X .  4\n: X X . X X . X X .  5\n: X X . X X . X X .  6\n: X X . X X . X X .  7\n: X X . X X . X X .  8\n: X X . X X . X X .  9\n: X X . X X . X X .  10\n: X X . X X . X X .  11\n: X X . X X . X X .  12\n: X X . X X . X X .  13\n: . . . . . . . . .  14\n: . . . . . . . . .  15\n: X X X X X X X X X  16\n.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TG": {"ttr": 10248, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x00\\x00\\x950\\x7f\\x00\\x951O\\x16\\x08\\x01\\x98\\x00R\\x00\\x00\\xe2\\xc1\\xe2\\xc4\\xc4\\xc6@@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "1995-11-03T00:00:00", "modifydate": "1995-11-10T16:08:00", "lines": 408, "newlines": 82, "modlines": 0, "user": "SASDDF"}, "text": "//TG  JOB (0,J358),'DAVID FAHEY',TIME=(0,5),\n//  NOTIFY=,REGION=4096K,MSGLEVEL=(1,1)\n/*JOBPARM FETCH\n//  EXEC ASMHCL\n//SYSIN DD *\n***********************************************************************\n* Draw a square box on the 3270                                       *\n***********************************************************************\n         PUSH  PRINT\n         PRINT NOGEN\n         POP   PRINT\n*\nTG       CSECT\n         STM   14,12,12(13)\n         LR    12,15\n         USING TG,12\n         ST    13,SAVEAREA+4\n         LA    13,SAVEAREA\n* tell TSO full screen mode\n         STTMPMD ON\n         STFSMODE ON,INITIAL=YES\n* clear screen\n         LA    1,CLRSCRN\n         L     2,=A(CLRSCRNL)\n         TPUT  (1),(2),FULLSCR\n* write graphic\n         LA    1,DS1\n         L     2,=A(DS1L)\n         TPUT  (1),(2),NOEDIT\n* wait for key press\n         LA    1,BUFFER\n         L     2,=A(BUFFERL)\n         TGET  (1),(2)\n* write graphic\n         LA    1,DS2\n         L     2,=A(DS2L)\n         TPUT  (1),(2),NOEDIT\n* wait for key press\n         LA    1,BUFFER\n         L     2,=A(BUFFERL)\n         TGET  (1),(2)\n* tell TSO no more full screen\n         STFSMODE OFF\n         STTMPMD OFF\n         SLR   15,15                    ZERO RETURN CODE\n         L     13,SAVEAREA+4            RESTORE 13\n         L     14,12(13)                RESTORE 14\n         LM    0,12,20(13)              AND 0 THRU 12\n         BR    14\n*\n*\nSAVEAREA DS    18F\nBUFFER   DC    CL256' '\nBUFFERL  EQU   *-BUFFER\nCLRSCRN  DC    X'F1C3'\nCLRSCRNL EQU   *-CLRSCRN\n*\n***********************************************************************\n*        Draw a square box                                            *\n***********************************************************************\n*\nDS1      DC    X'F3'                   WSF\n         DC    X'00040380'             SF: ERASE/RESET\nDS1D     DC    AL2(DS1DL)\n         DC    X'0F10'                 SF: OBJECT PICTURE\n         DC    X'00C000700C000000010000' OBJECT PICTURE\n         DC    AL2(DS1EL)\n         DC    X'00000000'\n*-FILLED RECTANGLE 1---------------------------------------------------\nDS1E     DC    X'3902'                 CHARACTER PRECISION - 2\n         DC    X'33080009001000000000' CELL SIZE - 9 X 16\n         DC    X'0C02'                 MIX - OVERPAINT\n         DC    X'0A05'                 COLOR - yellow\n         DC    X'1808'                 Line style - invisible\n         DC    X'2104FFE70019'         SET POSITION (-25, 25)\n         DC    X'2810'                 SET PATTERN\n         DC    X'68C0'                 BEGIN AREA\n         DC    X'A108320000CECE000032' SQUARE (50 PIXELS)\n         DC    X'6000'                 END AREA\n         DC    X'0A01'                 COLOR - blue\n         DC    X'1800'                 Line style - default\n         DC    X'A108320000CECE000032' SQUARE (50 PIXELS)\n*-FILLED RECTANGLE 2---------------------------------------------------\n         DC    X'0A04'                 COLOR - green\n         DC    X'1808'                 Line style - invisible\n         DC    X'210400000000'         SET POSITION (0, 0)\n         DC    X'280C'                 SET PATTERN right diag 2\n         DC    X'68C0'                 BEGIN AREA\n         DC    X'A108320000CECE000032' SQUARE (50 PIXELS)\n         DC    X'6000'                 END AREA\n         DC    X'0A02'                 COLOR - red\n         DC    X'1800'                 Line style - default\n         DC    X'A108320000CECE000032' SQUARE (50 PIXELS)\n*-FILLED RECTANGLE 3---------------------------------------------------\n         DC    X'0C01'                 MIX - OR\n         DC    X'0A05'                 COLOR - yellow\n         DC    X'1808'                 Line style - invisible\n         DC    X'2104FFE70074'         SET POSITION\n         DC    X'2810'                 SET PATTERN\n         DC    X'68C0'                 BEGIN AREA\n         DC    X'A108320000CECE000032' SQUARE (50 PIXELS)\n         DC    X'6000'                 END AREA\n         DC    X'0A01'                 COLOR - blue\n         DC    X'1800'                 Line style - default\n         DC    X'A108320000CECE000032' SQUARE (50 PIXELS)\n*-FILLED RECTANGLE 4---------------------------------------------------\n         DC    X'0A04'                 COLOR - green\n         DC    X'1808'                 Line style - invisible\n         DC    X'21040000005B'         SET POSITION\n         DC    X'280C'                 SET PATTERN right diag 2\n         DC    X'68C0'                 BEGIN AREA\n         DC    X'A108320000CECE000032' SQUARE (50 PIXELS)\n         DC    X'6000'                 END AREA\n         DC    X'0A02'                 COLOR - red\n         DC    X'1800'                 Line style - default\n         DC    X'A108320000CECE000032' SQUARE (50 PIXELS)\n*-FILLED RECTANGLE 5---------------------------------------------------\n         DC    X'0C03'                 MIX - Underpaint\n         DC    X'0A05'                 COLOR - yellow\n         DC    X'1808'                 Line style - invisible\n         DC    X'2104FFE700E8'         SET POSITION\n         DC    X'2810'                 SET PATTERN\n         DC    X'68C0'                 BEGIN AREA\n         DC    X'A108320000CECE000032' SQUARE (50 PIXELS)\n         DC    X'6000'                 END AREA\n         DC    X'0A01'                 COLOR - blue\n         DC    X'1800'                 Line style - default\n         DC    X'A108320000CECE000032' SQUARE (50 PIXELS)\n*-FILLED RECTANGLE 6---------------------------------------------------\n         DC    X'0A04'                 COLOR - green\n         DC    X'1808'                 Line style - invisible\n         DC    X'2104000000CF'         SET POSITION\n         DC    X'280C'                 SET PATTERN right diag 2\n         DC    X'68C0'                 BEGIN AREA\n         DC    X'A108320000CECE000032' SQUARE (50 PIXELS)\n         DC    X'6000'                 END AREA\n         DC    X'0A02'                 COLOR - red\n         DC    X'1800'                 Line style - default\n         DC    X'A108320000CECE000032' SQUARE (50 PIXELS)\n*-FILLED RECTANGLE 7---------------------------------------------------\n         DC    X'0C04'                 MIX - Exclusive OR\n         DC    X'0A05'                 COLOR - yellow\n         DC    X'1808'                 Line style - invisible\n         DC    X'2104009600E8'         SET POSITION\n         DC    X'2810'                 SET PATTERN\n         DC    X'68C0'                 BEGIN AREA\n         DC    X'A108320000CECE000032' SQUARE (50 PIXELS)\n         DC    X'6000'                 END AREA\n         DC    X'0A01'                 COLOR - blue\n         DC    X'1800'                 Line style - default\n         DC    X'A108320000CECE000032' SQUARE (50 PIXELS)\n*-FILLED RECTANGLE 8---------------------------------------------------\n         DC    X'0A04'                 COLOR - green\n         DC    X'1808'                 Line style - invisible\n         DC    X'210400AF00CF'         SET POSITION\n         DC    X'280C'                 SET PATTERN right diag 2\n         DC    X'68C0'                 BEGIN AREA\n         DC    X'A108320000CECE000032' SQUARE (50 PIXELS)\n         DC    X'6000'                 END AREA\n         DC    X'0A02'                 COLOR - red\n         DC    X'1800'                 Line style - default\n         DC    X'A108320000CECE000032' SQUARE (50 PIXELS)\n*-FILLED RECTANGLE 9---------------------------------------------------\n         DC    X'0C00'                 MIX - Default\n         DC    X'0A05'                 COLOR - yellow\n         DC    X'1808'                 Line style - invisible\n         DC    X'210400960074'         SET POSITION\n         DC    X'2810'                 SET PATTERN\n         DC    X'68C0'                 BEGIN AREA\n         DC    X'A108320000CECE000032' SQUARE (50 PIXELS)\n         DC    X'6000'                 END AREA\n         DC    X'0A01'                 COLOR - blue\n         DC    X'1800'                 Line style - default\n         DC    X'A108320000CECE000032' SQUARE (50 PIXELS)\n*-FILLED RECTANGLE 10--------------------------------------------------\n         DC    X'0A04'                 COLOR - green\n         DC    X'1808'                 Line style - invisible\n         DC    X'210400AF005B'         SET POSITION\n         DC    X'280C'                 SET PATTERN right diag 2\n         DC    X'68C0'                 BEGIN AREA\n         DC    X'A108320000CECE000032' SQUARE (50 PIXELS)\n         DC    X'6000'                 END AREA\n         DC    X'0A02'                 COLOR - red\n         DC    X'1800'                 Line style - default\n         DC    X'A108320000CECE000032' SQUARE (50 PIXELS)\n*-CHARACTER STRINGS----------------------------------------------------\n         DC    X'0A07'                 COLOR - white\n         DC    X'3A01'                 Character direction: left->right\n         DC    X'3902'                 Character precision: string\n         DC    X'38F0'                 Character set: Base\n         DC    X'33080009001000000000' Character cell size: 9x16\n         DC    X'340400010000'         Angle x y\n         DC    X'350400000001'         Shear x y\n         DC    X'C31CFE9B00C8'         Character string\n*                    xxxxyyyy\n         DC    C'Press ENTER to continue.'\n         DC    X'0A03'                 COLOR - pink\n         DC    X'C30D00390000'         Character string\n*                    xxxxyyyy\n         DC    C'Overpaint'\n         DC    X'C30600390064'         Character string\n*                    xxxxyyyy\n         DC    C'OR'\n         DC    X'C30E003900D8'         Character string\n*                    xxxxyyyy\n         DC    C'Underpaint'\n         DC    X'C31000E100D8'         Character string\n*                    xxxxyyyy\n         DC    C'Exclusive OR'\n         DC    X'C30B00E10064'         Character string\n*                    xxxxyyyy\n         DC    C'Default'\nDS1DL    EQU   *-DS1D\nDS1EL    EQU   *-DS1E\nDS1F     DC    AL1(0),AL1(DS1FL)\n         DC    X'4000F1F31109FF1D6011000013' 3270 DS TO PROTECT, IC\nDS1FL    EQU   *-DS1F\nDS1L     EQU   *-DS1\n*******************************************************************\nDS2      DC    X'F3'                   WSF\n         DC    X'00040380'             SF: ERASE/RESET\nDS2D     DC    AL2(DS2DL)\n         DC    X'0F10'                 SF: OBJECT PICTURE\n         DC    X'00C000700C000000010000'\n         DC    AL2(DS2EL)\n         DC    X'00000000'\n*-SQUARE---------------------------------------------------------------\nDS2E     DC    X'0A06'                 COLOR - yellow\n         DC    X'1807'                 Line style - solid\n*        DC    X'1801'                 Line style - dots\n         DC    X'C1140019003200320032003200190019001900190032' SQUARE\n*                    xxxxyyyyxxxxyyyyxxxxyyyyxxxxyyyyxxxxyyyy\n         DC    X'1807'                 Line style - solid\n*        DC    X'1801'                 Line style - dots\n         DC    X'0A05'                 COLOR - cyan\n         DC    X'C114FE9B00C8016300C80163FF36FE9BFF36FE9B00C8' SQUARE\n*                    xxxxyyyyxxxxyyyyxxxxyyyyxxxxyyyyxxxxyyyy\n*                    -355 200 355 200 355-200-355-200-355 200\n*-LINE-----------------------------------------------------------------\n         DC    X'1807'                 Line style - solid\n         DC    X'0A02'                 COLOR - red\n         DC    X'C1080019003200320019' LINE\n*                    xxxxyyyyxxxxyyyy\n*-ARC------------------------------------------------------------------\n         DC    X'1807'                 Line style - solid\n*        DC    X'1802'                 Line style - short dash\n         DC    X'0A04'                 COLOR - green\n         DC    X'C50C016300C8000000000163FF36' ARC\n*                    xxxxyyyyxxxxyyyyxxxxyyyy\n*-CIRCLE---------------------------------------------------------------\n         DC    X'1807'                 Line style - solid\n*        DC    X'1804'                 Line style - double dotted\n         DC    X'0A03'                 COLOR - pink\n         DC    X'220800520052FFAC0052' SET ARC PARMS\n*                    ppppqqqqrrrrssss\n*                     82  82  -82 82\n         DC    X'C706000000000100'     FULL ARC\n*                    xxxxyyyymmmm\n*-ELLIPSE--------------------------------------------------------------\n         DC    X'1807'                 Line style - solid\n*        DC    X'1803'                 Line style - dash dot\n         DC    X'0A01'                 COLOR - blue\n         DC    X'220800620042FFD40062' SET ARC PARMS\n*                    ppppqqqqrrrrssss\n*                     98  66  -66 98\n         DC    X'C706000000000100'     FULL ARC\n*                    xxxxyyyymmmm\n*-ELLIPSE--------------------------------------------------------------\n         DC    X'1807'                 Line style - solid\n*        DC    X'1803'                 Line style - dash dot\n         DC    X'0A02'                 COLOR - red\n         DC    X'220800620042FFD40062' SET ARC PARMS\n*                    ppppqqqqrrrrssss\n*                     98  66  -66 98\n         DC    X'C706000000000200'     FULL ARC\n*                    xxxxyyyymmmm\n*-MARKER---------------------------------------------------------------\n         DC    X'2903'                 Marker shape - diamond\n         DC    X'0A02'                 COLOR - red\n         DC    X'C20400000082'         MARKER\n*                    xxxxyyyy\n*                      0  130\n         DC    X'2901'                 Marker shape - cross\n         DC    X'0A04'                 COLOR - green\n         DC    X'C20400100082'         MARKER\n*                    xxxxyyyy\n*                      16 130\n         DC    X'2902'                 Marker shape - plus\n         DC    X'0A03'                 COLOR - pink\n         DC    X'C20400200082'         MARKER\n*                    xxxxyyyy\n*                      32 130\n         DC    X'2904'                 Marker shape - square\n         DC    X'0A06'                 COLOR - yellow\n         DC    X'C20400300082'         MARKER\n*                    xxxxyyyy\n*                      48 130\n         DC    X'2905'                 Marker shape - star 6 pt\n         DC    X'0A07'                 COLOR - white\n         DC    X'C20400400082'         MARKER\n*                    xxxxyyyy\n*                      64 130\n         DC    X'2906'                 Marker shape - star 8 pt\n         DC    X'0A01'                 COLOR - blue\n         DC    X'C20400500082'         MARKER\n*                    xxxxyyyy\n*                      80 130\n         DC    X'2907'                 Marker shape - shaded diamond\n         DC    X'0A05'                 COLOR - cyan\n         DC    X'C20400600082'         MARKER\n*                    xxxxyyyy\n*                      96 130\n         DC    X'2908'                 Marker shape - shaded square\n         DC    X'0A02'                 COLOR - red\n         DC    X'C20400700082'         MARKER\n*                    xxxxyyyy\n*                     112 130\n*-CHARACTER STRING-----------------------------------------------------\n         DC    X'0A07'                 COLOR - white\n         DC    X'3A01'                 Character direction: left->right\n         DC    X'3902'                 Character precision: character\n         DC    X'38F0'                 Character set: Base\n         DC    X'33080009001000000000' Character cell size: 9x16\n         DC    X'340400010000'         Angle x y - (1,0) = 0 degrees\n         DC    X'350400000001'         Shear x y\n         DC    X'C31400550022'         Character string\n*                    xxxxyyyy\n         DC    C'String STD--9x16'\n*----------------------------------------------------------------------\n         DC    X'0A04'                 COLOR - green\n         DC    X'340400010001'         Angle x y - (1,1) = 45 degrees\n         DC    X'350400000000'         Shear x y\n         DC    X'C31400770055'         Character string\n*                    xxxxyyyy\n         DC    C'0123456789--9x16'\n*----------------------------------------------------------------------\n         DC    X'0A06'                 COLOR - yellow\n         DC    X'3A03'                 Character direction: right->left\n         DC    X'3404000000FF'         Angle x y - (0,1) = 90 degrees\n         DC    X'350400000001'         Shear x y\n         DC    X'C31301430066'         Character string\n*                    xxxxyyyy\n         DC    C'V E R T I C A L'\n*----------------------------------------------------------------------\n         DC    X'0A01'                 COLOR - blue\n         DC    X'3A01'                 Character direction: left->right\n         DC    X'3903'                 Character precision: stroke\n         DC    X'38F0'                 Character set: Base\n         DC    X'33080009001000000000' Character cell size: 9x16\n         DC    X'340400010000'         Angle x y\n         DC    X'350400180010'         Shear x y\n         DC    X'C31400550011'         Character string\n*                    xxxxyyyy\n         DC    C'Shearstring 9x16'\n*----------------------------------------------------------------------\n         DC    X'0A03'                 COLOR - pink\n         DC    X'3A01'                 Character direction: left->right\n         DC    X'3903'                 Character precision: stroke\n         DC    X'38F0'                 Character set: Base\n         DC    X'33080006000B00000000' Character cell size: 6x11\n         DC    X'340400010000'         Angle x y\n         DC    X'350400000001'         Shear x y\n         DC    X'C31400550000'         Character string\n*                    xxxxyyyy\n         DC    C'Smaller.....6x11'\n*----------------------------------------------------------------------\n         DC    X'0A04'                 COLOR - green\n         DC    X'3A01'                 Character direction: left->right\n         DC    X'3903'                 Character precision: stroke\n         DC    X'38F0'                 Character set: Base\n         DC    X'33080009001000000000' Character cell size: 9x16\n         DC    X'340400010000'         Angle x y\n         DC    X'350400000001'         Shear x y\n         DC    X'C3140055FFEB'         Character string\n*                    xxxxyyyy\n         DC    C'ABCDEFGH abcdefg'\n*----------------------------------------------------------------------\n         DC    X'0A01'                 COLOR - blue\n         DC    X'3A01'                 Character direction: left->right\n         DC    X'3903'                 Character precision: stroke\n         DC    X'38F0'                 Character set: Base\n         DC    X'33080020003200000000' Character cell size: 32x50\n         DC    X'340400010000'         Angle x y\n         DC    X'350400000001'         Shear x y\n         DC    X'C30D000000C8'         Character string\n*                    xxxxyyyy\n         DC    C'BIG 32x50'\n*----------------------------------------------------------------------\n         DC    X'0A07'                 COLOR - white\n         DC    X'3A01'                 Character direction: left->right\n         DC    X'3902'                 Character precision: character\n         DC    X'38F0'                 Character set: Base\n         DC    X'33080009001000000000' Character cell size: 9x16\n         DC    X'340400010000'         Angle x y\n         DC    X'350400000001'         Shear x y\n         DC    X'C31DFE9B00C8'         Character string\n*                    xxxxyyyy\n         DC    C'Press ENTER to terminate.'\n*----------------------------------------------------------------------\nDS2DL    EQU   *-DS2D\nDS2EL    EQU   *-DS2E\nDS2F     DC    AL1(0),AL1(DS2FL)\n         DC    X'4000F1F31109FF1D6011000013' 3270 DS TO PROTECT, IC\nDS2FL    EQU   *-DS2F\nDS2L     EQU   *-DS2\n         LTORG\n         END\n//LKED.SYSLMOD DD DSN=SASDDF.A.LOADLIB(TG),DISP=SHR\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TGETN": {"ttr": 10501, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95#_\\x00\\x95#_\\x16T\\x00S\\x00S\\x00\\x00\\xe2\\xc1\\xe2\\xc4\\xc4\\xc6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-08-23T00:00:00", "modifydate": "1995-08-23T16:54:00", "lines": 83, "newlines": 83, "modlines": 0, "user": "SASDDF"}, "text": "TGETN    TITLE '--- PROGRAM TO ISSUE TGET MACRO ---'\n*******************************************************************\n*                     TGETN     PROGRAM                  PAGE: 1  *\n*                    ===================                          *\n*                                                                 *\n* PROGRAM......: TGETN                                            *\n*                                                                 *\n* LANGUAGE.....: ASSEMBLER                                        *\n*                                                                 *\n* DATE.........: 23AUG95                                          *\n*                                                                 *\n* VERSION......: 1.0                                              *\n*                                                                 *\n* AUTHOR.......: DAVID FAHEY     (WHOM GOD PRESERVE)              *\n*                                                                 *\n* DESCRIPTION..: THIS PROGRAM IS LOADED BELOW THE LINE AND        *\n*                CALLED BY A C LANGUAGE CALLER.                   *\n*                                                                 *\n*******************************************************************\n         EJECT\n*******************************************************************\n*                     TGETN     PROGRAM                  PAGE: 2  *\n*                    ===================                          *\n*                                                                 *\n* SYSTEM MACROS: CREGS    --- REGISTER SETTINGS                   *\n*                CENTRY   --- C LANGUAGE ENTRY CONVENTIONS        *\n*                TGET     --- ISSUE TGET (SVC 93)                 *\n*                CEXIT    --- C LANGUAGE EXIT CONVENTIONS         *\n*                                                                 *\n*******************************************************************\n         EJECT\nTGETN@   CSECT\n         CREGS USING\nTGETN    CENTRY DSA=DSALEN\n*******************************************************************\n*        MAIN PROGRAM LOGIC                                       *\n*******************************************************************\n         SPACE\n* --- GET PARAMETER LIST\n         L       R2,0(,R1)              CALLERS BUFFER ADDR\n         L       R3,4(,R1)              CALLERS DATE LENGTH\n         SPACE\n* --- GET STORAGE BELOW LINE\n         GETMAIN R,LV=(R3)              GET STG BELOW 16M LINE\n         LR      R6,R1                  HOLD INPUT ADDR IN R6\n         LR      R7,R3                  HOLD INPUT LEN IN R7\n         SPACE\n* --- ISSUE TGET MACRO\n         LR      R0,R3                  R0 = LENGTH OF BUFFER\n         LR      R1,R6                  R1 = BUFFER ADDRESS\n         LA      R4,TGFLG               FLGS FOR TGET FULLSCR\n         SLL     R4,24                  SHIFT LEFT FLGS TO HIGH BYTE\n         OR      R1,R4                  MERGE FLAGS WITH BUF. ADDR\n         TGET    (1),(0),R\n         LR      R8,R15                 SAVE RETURN CODE\n         SPACE\n* --- COPY DATA TO CALLERS STG (MAYBE ABOVE 16M LINE)\n*                                       OUTPUT DATA ADDR IN R2\n*                                       OUTPUT LEN IN R3\n         LR      R4,R6                  INPUT ADDR IN R4\n         LR      R5,R7                  INPUT LEN IN R5\n         MVCL    R2,R4                  COPY DATA TO CALLERS STG\n*                                         R2(R3) <== R4(R5)\n         SPACE\n* --- FREE STORAGE\n         FREEMAIN R,LV=(R7),A=(R6)      FREE STG BELOW 16M LINE\n         SPACE\n* --- RETURN TO C CALLER\nFIN      CEXIT   RC=(8),DSA=DSALEN      FAILED - NOT DISPLAY MSG\n         SPACE\n         SPACE\n         LTORG\n*******************************************************************\n*        CONTROL BLOCKS AND WORK AREAS                            *\n*******************************************************************\n         SPACE\n         COPY    DSA\nDSALEN   EQU     *-DSA\n         SPACE\n         COPY    CRAB\n         SPACE\nTGFLG    EQU     B'10000011'            FLAGS FOR TGET FULLSCR\n         END     TGETN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TGT327D": {"ttr": 10504, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x95!O\\x00\\x95!O\\x12\\x04\\x00S\\x00\\xb8\\x003\\xe2\\xc1\\xe2\\xc4\\xc4\\xc6@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1995-08-02T00:00:00", "modifydate": "1995-08-02T12:04:00", "lines": 83, "newlines": 184, "modlines": 51, "user": "SASDDF"}, "text": "TGT327D   TITLE '--- PROGRAM TO GET TERMINAL ATTRS FOR C CALLER ---'\n*******************************************************************\n*                     TGT327D   PROGRAM                  PAGE: 1  *\n*                    ===================                          *\n*                                                                 *\n* PROGRAM......: TGT327D                                          *\n*                                                                 *\n* LANGUAGE.....: ASSEMBLER                                        *\n*                                                                 *\n* DATE.........: 02AUG95                                          *\n*                                                                 *\n* VERSION......: 1.0                                              *\n*                                                                 *\n* AUTHOR.......: DAVID FAHEY     (WHOM GOD PRESERVE)              *\n*                                                                 *\n* DESCRIPTION..: THIS PROGRAM IS LOADED BELOW THE LINE AND        *\n*                CALLED BY A C LANGUAGE CALLER.                   *\n*                                                                 *\n*******************************************************************\n         EJECT\n*******************************************************************\n*                     TGT327D   PROGRAM                  PAGE: 2  *\n*                    ===================                          *\n*                                                                 *\n* SYSTEM MACROS: CREGS    --- REGISTER SETTINGS                   *\n*                CENTRY   --- C LANGUAGE ENTRY CONVENTIONS        *\n*                GTTERM   --- GET TERMINAL INFO (SVC 94 CODE 11X) *\n*                CEXIT    --- C LANGUAGE EXIT CONVENTIONS         *\n*                                                                 *\n*******************************************************************\n         EJECT\nTGT327D@ CSECT\n         CREGS USING\nTGT327D  CENTRY DSA=DSALEN\n*******************************************************************\n*        MAIN PROGRAM LOGIC                                       *\n*******************************************************************\n         SPACE\n         L       R5,0(,R1)              ADDRESS CALLERS DATA AREA\n         USING   PARMRET,R5\n         SPACE\n         LA      R2,TGPRM               -> PRIMARY\n         LA      R3,TGALT               -> ALTERNATE\n         LA      R4,TGATTR              -> ATTRIBUTES\n         GTTERM  PRMSZE=(R2),ALTSZE=(R3),ATTRIB=(R4)\n         LTR     R15,R15                IS IT A 3270 ?\n         BNZ     FIN                    NO - GO BACK NOW\n*                                       YES - COPY DATA TO CALLER\n         LH      R3,TGPRM               COPY PRIMARY TO CALLERS STG\n         STH     R3,RXPRM\n         LH      R3,TGALT               COPY ALTERNATE TO CALLERS STG\n         STH     R3,RXALT\n         L       R3,TGATTR              COPY ATTRIBUTES TO CALLERS STG\n         ST      R3,RXATTR\n         SPACE\nFIN      CEXIT   RC=(15),DSA=DSALEN     FAILED - NOT DISPLAY MSG\n         B       FIN\n         SPACE\n         LTORG\n*******************************************************************\n*        CONTROL BLOCKS AND WORK AREAS                            *\n*******************************************************************\n         SPACE\n         COPY  DSA\nTGPRM    DS    0H                       PRIMARY SCREEN SIZE\nTGPRMR   DS    CL1\nTGPRMC   DS    CL1\n*\nTGALT    DS    0H                       ALTERNATE SCREEN SIZE\nTGALTR   DS    CL1\nTGALTC   DS    CL1\n*\nTGATTR   DS    F                        OTHER DEVICE ATTRIBUTES\nDSALEN   EQU   *-DSA\n         SPACE\n         COPY  CRAB\n         SPACE\nPARMRET  DSECT ,\nRXPRM    DS    H                        PRIMARY SCREEN SIZE\nRXALT    DS    H                        ALTERNATE SCREEN SIZE\nRXATTR   DS    F                        OTHER DEVICE ATTRIBUTES\n         SPACE\n         END     TGT327D\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TPGN": {"ttr": 10507, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x95!_\\x00\\x95!o\\x18\"\\x00P\\x00?\\x00\\x1f\\xe2\\xc1\\xe2\\xc4\\xc4\\xc6@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1995-08-03T00:00:00", "modifydate": "1995-08-04T18:22:00", "lines": 80, "newlines": 63, "modlines": 31, "user": "SASDDF"}, "text": "TPGN      TITLE '--- PROGRAM TO ISSUE TPG MACRO WITH NOEDIT ---'\n*******************************************************************\n*                     TPGN      PROGRAM                  PAGE: 1  *\n*                    ===================                          *\n*                                                                 *\n* PROGRAM......: TPGN                                             *\n*                                                                 *\n* LANGUAGE.....: ASSEMBLER                                        *\n*                                                                 *\n* DATE.........: 03AUG95                                          *\n*                                                                 *\n* VERSION......: 1.0                                              *\n*                                                                 *\n* AUTHOR.......: DAVID FAHEY     (WHOM GOD PRESERVE)              *\n*                                                                 *\n* DESCRIPTION..: THIS PROGRAM IS LOADED BELOW THE LINE AND        *\n*                CALLED BY A C LANGUAGE CALLER.                   *\n*                                                                 *\n*******************************************************************\n         EJECT\n*******************************************************************\n*                     TPGN      PROGRAM                  PAGE: 2  *\n*                    ===================                          *\n*                                                                 *\n* SYSTEM MACROS: CREGS    --- REGISTER SETTINGS                   *\n*                CENTRY   --- C LANGUAGE ENTRY CONVENTIONS        *\n*                GETMAIN  --- ALLOC STORAGE                       *\n*                FREEMAIN --- FREE STORAGE                        *\n*                TPGN     --- ISSUE TPUT/GET (SVC 93)             *\n*                CEXIT    --- C LANGUAGE EXIT CONVENTIONS         *\n*                                                                 *\n*******************************************************************\n         EJECT\nTPGN@    CSECT\n         CREGS USING\nTPGN     CENTRY DSA=DSALEN\n*******************************************************************\n*        MAIN PROGRAM LOGIC                                       *\n*******************************************************************\n         SPACE\n* --- GET PARAMETER LIST\n         L       R2,0(,R1)              ADDR BUFFER\n         L       R3,4(,R1)              LENGTH DATA\n         SPACE\n* --- GET STORAGE BELOW LINE\n         GETMAIN R,LV=(R3)              GET STG BELOW 16M LINE\n         LR      R6,R1                  HOLD OUTPUT ADDR IN R6\n         LR      R7,R3                  HOLD OUTPUT LEN IN R7\n         SPACE\n* --- COPY DATA BELOW 16M LINE\n*                                       INPUT ADDR IN R2\n*                                       INPUT LEN IN R3\n         LR      R4,R1                  OUTPUT ADDR IN R4\n         LR      R5,R3                  OUTPUT LEN IN R5\n         MVCL    R4,R2                  COPY DATA BELOW LINE\n         SPACE\n* --- ISSUE TPG MACRO\n         MVC     WTPG(TPGL),XTPG        COPY R/O TO R/W PARM\n         LA      R8,WTPG                WORKING COPY OF TPG PARM\n         TPG     (R6),(R7),MF=(E,(R8))\n         LR      R2,R15                 SAVE RET CODE\n         SPACE\n* --- FREE STORAGE\n         FREEMAIN R,LV=(R7),A=(R6)      FREE STG BELOW 16M LINE\nFIN      CEXIT   RC=(2),DSA=DSALEN      FAILED - NOT DISPLAY MSG\n         B       FIN\n         SPACE\n         LTORG\nXTPG     TPG     0,0,NOEDIT,WAIT,NOHOLD,MF=L     LITERAL TPG PARM\nTPGL     EQU     *-XTPG\n*******************************************************************\n*        CONTROL BLOCKS AND WORK AREAS                            *\n*******************************************************************\n         SPACE\n         COPY    DSA\nWTPG     TPG     0,0,NOEDIT,WAIT,NOHOLD,MF=L     WORK COPY OF TPG PARM\nDSALEN   EQU     *-DSA\n         SPACE\n         COPY    CRAB\n         END     TPGN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TPUTN": {"ttr": 10510, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00\\x00\\x00\\x95!_\\x00\\x95#_\\x16'\\x00N\\x00I\\x00\\x07\\xe2\\xc1\\xe2\\xc4\\xc4\\xc6@@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "1995-08-03T00:00:00", "modifydate": "1995-08-23T16:27:00", "lines": 78, "newlines": 73, "modlines": 7, "user": "SASDDF"}, "text": "TPUTN    TITLE '--- PROGRAM TO ISSUE TPUT MACRO WITH NOEDIT ---'\n*******************************************************************\n*                     TPUTN     PROGRAM                  PAGE: 1  *\n*                    ===================                          *\n*                                                                 *\n* PROGRAM......: TPUTN                                            *\n*                                                                 *\n* LANGUAGE.....: ASSEMBLER                                        *\n*                                                                 *\n* DATE.........: 03AUG95                                          *\n*                                                                 *\n* VERSION......: 1.0                                              *\n*                                                                 *\n* AUTHOR.......: DAVID FAHEY     (WHOM GOD PRESERVE)              *\n*                                                                 *\n* DESCRIPTION..: THIS PROGRAM IS LOADED BELOW THE LINE AND        *\n*                CALLED BY A C LANGUAGE CALLER.                   *\n*                                                                 *\n*******************************************************************\n         EJECT\n*******************************************************************\n*                     TPUTN     PROGRAM                  PAGE: 2  *\n*                    ===================                          *\n*                                                                 *\n* SYSTEM MACROS: CREGS    --- REGISTER SETTINGS                   *\n*                CENTRY   --- C LANGUAGE ENTRY CONVENTIONS        *\n*                TPUT     --- ISSUE TPUT (SVC 93)                 *\n*                CEXIT    --- C LANGUAGE EXIT CONVENTIONS         *\n*                                                                 *\n*******************************************************************\n         EJECT\nTPUTN@   CSECT\n         CREGS USING\nTPUTN    CENTRY DSA=DSALEN\n*******************************************************************\n*        MAIN PROGRAM LOGIC                                       *\n*******************************************************************\n         SPACE\n* --- GET PARAMETER LIST\n         L       R2,0(,R1)              ADDR BUFFER\n         L       R3,4(,R1)              LENGTH DATA\n         SPACE\n* --- GET STORAGE BELOW LINE\n         GETMAIN R,LV=(R3)              GET STG BELOW 16M LINE\n         LR      R6,R1                  HOLD OUTPUT ADDR IN R6\n         LR      R7,R3                  HOLD OUTPUT LEN IN R7\n         SPACE\n* --- COPY DATA BELOW 16M LINE\n*                                       INPUT ADDR IN R2\n*                                       INPUT LEN IN R3\n         LR      R4,R1                  OUTPUT ADDR IN R4\n         LR      R5,R3                  OUTPUT LEN IN R5\n         MVCL    R4,R2                  COPY DATA BELOW LINE\n         SPACE\n* --- ISSUE TPG MACRO\n         MVC     TPLW(TPLL),TPL         COPY PARM LIST TO WSTG\n         LA      R4,TPLW\n         TPUT    (R6),(R7),MF=(E,(R4))\n         LR      R2,R15                 SAVE RET CODE\n         SPACE\n* --- FREE STORAGE\n         FREEMAIN R,LV=(R7),A=(R6)      FREE STG BELOW 16M LINE\nFIN      CEXIT   RC=(2),DSA=DSALEN      FAILED - NOT DISPLAY MSG\n         SPACE\nTPL      TPUT    0,0,NOEDIT,MF=L\nTPLL     EQU     *-TPL\n         SPACE\n         LTORG\n*******************************************************************\n*        CONTROL BLOCKS AND WORK AREAS                            *\n*******************************************************************\n         SPACE\n         COPY    DSA\nTPLW     TPUT    0,0,NOEDIT,MF=L\nDSALEN   EQU     *-DSA\n         SPACE\n         COPY    CRAB\n         END     TPUTN\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TXTPAD32": {"ttr": 10753, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x95(\\x9f\\x00\\x95(\\x9f\\x17\\x10\\x0bo\\x0bo\\x00\\x00\\xe2\\xc1\\xe2\\xc4\\xc4\\xc6@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1995-10-16T00:00:00", "modifydate": "1995-10-16T17:10:00", "lines": 2927, "newlines": 2927, "modlines": 0, "user": "SASDDF"}, "text": "#pragma eject\n#pragma title txtpad32.c - display a text pad on a 3270 device\n\n/*+-----------------------------------------------------------------+\n  | Program:   txtpad32.c                                           |\n  | Language:  c                                                    |\n  | Support:   DAF                                                  |\n  | Purpose:   To learn some full screen 3270 coding techniques to  |\n  |            use on the IBM 3270 display station.                 |\n  |                                                                 |\n  |            The following publications have been used in the     |\n  |            developement of this program:                        |\n  |              SC28-1875 TSO/E v2 programming Services            |\n  |              GA23-0059 3270 Info. Display Sys. Data Stream      |\n  |                        Programmers Reference.                   |\n  |              GA27-3831 3174 Establishment Controller Character  |\n  |                        Set Reference.                           |\n  |              GA27-2837 3270 Character Set Reference.            |\n  |              HUR 9058  IBM3270 Personal Computer Graphics       |\n  |                        Control Program Data Stream Reference.   |\n  |              GA18-2589 IBM 3179-G/3192-G Color Graphics Display |\n  |                        Station Description.                     |\n  |              GG27-6999 Introduction to Programming the IBM 3270.|\n  |                                                                 |\n  |            This programs main routine creates a simple notepad  |\n  |            window on the 3270. It uses routines to build the    |\n  |            notepad that support the creation, modification,     |\n  |            removal, and display of fields on the 3270 screen.   |\n  |            A screen is represented as linked list of fields.    |\n  |            These field routines can be viewed as an API that    |\n  |            the main program (application) uses to create windows|\n  |            on the 3270. The application is freed from managing  |\n  |            things like buffer address translation, and data     |\n  |            stream creation, and inbound data stream parsing.    |\n  |            Varying length strings are represented by the data   |\n  |            type LSTR. These strings can contain amy amount of   |\n  |            data including the null character.                   |\n  |                                                                 |\n  |            The following techniques have not been implemented   |\n  |            in this program but will be added later:             |\n  |            - Data stream compression using RBA.                 |\n  |            - Graphics support.                                  |\n  |                                                                 |\n  | Notes:     1. Numeric fields do not work the same on all        |\n  |               devices. The 3192-G allows lowercase character    |\n  |               input. Many devices also upper case character     |\n  |               input.                                            |\n  |            2. Most devices do not support field attributes:     |\n  |               Field Outlining, Background color, and Field      |\n  |               Validation.                                       |\n  |            3. The character set for APL does not appear to be   |\n  |               allowed on the SFE order, only on the SA order.   |\n  | End.                                                            |\n  +-----------------------------------------------------------------+*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <svc.h>\n#include <tput.h>\n#include <ostask.h>\n\n#define _AMODE31\n\n#include \"ps9x16u.inc\"\n#include \"ps9x15u.inc\"\n#include \"ps9x12u.inc\"\n\n/* escape character and device commands */\n#define ESC     0x27\n#define EW      0xf5\n#define EWA     0x7e\n#define WRT     0xf1\n#define WSF     0xf3\n#define RB      0xf2\n\n/* write control characters, or'd together as required */\n#define WCCMDT  0x01\n#define WCCKBD  0x02\n#define WCCRES  0xc0\n#define WCCBEL  0x04\n\n/* 3270 data stream orders */\n#define GE      0x08\n#define FF      0x0c\n#define CRR     0x0d\n#define SBA     0x11\n#define EUA     0x12\n#define ICUR    0x13\n#define NL      0x15\n#define EM      0x19\n#define DUP     0x1c\n#define SF      0x1d\n#define FM      0x1e\n#define SA      0x28\n#define SFE     0x29\n#define MF      0x2c\n#define RA      0x3c\n#define SUB     0x3f\n\n#define PROT    0x20\n#define NUM     0x10\n\n/* Type byte of the SA, SFE and MF orders */\n#define ALL     0x00\n#define NONE    0x00\n#define DFLT    0x00\n\n#define ATTR    0xc0\n#define FVALID  0xc1\n#define OUTLIN  0xc2\n#define HILITE  0x41\n#define COLOR   0x42\n#define SYMSET  0x43\n#define BAKCOL  0x45\n#define TRANSP  0x46\n\n#define APL     0xF1\n\n/* Out lines for the value byte of the SA, SFE, or MF order */\n#define UNDR    0x01\n#define OVR     0x04\n#define OVRUND  0x05\n#define NOOVR   0x0b\n#define NOUNDR  0x0e\n#define RECT    0x0f\n\n/* Hilites for the value byte of the SA, SFE, or MF order */\n#define BLINK   0xf1\n#define RVIDEO  0xf2\n#define USCORE  0xf4\n\n/* Colors for the value byte of the SA, SFE, or MF order */\n#define BLUE    0xf1\n#define RED     0xf2\n#define PINK    0xf3\n#define GREEN   0xf4\n#define TURQ    0xf5\n#define CYAN    0xf5\n#define YELLOW  0xf6\n#define WHITE   0xf7\n\n/* Attribute for the value byte of the SF, SFE and MF order */\n#define UNPRT   0x40\n#define UNNUM   0x50\n#define UNNUMHI 0xd8\n#define UNNON   0x4c\n#define UNHI    0xc8\n#define PRT     0x60\n#define PRTHI   0xe4\n#define PRTAS   0xf0\n#define PRTHIAS 0xf8\n\n/* Attention Identification (AID) Values */\n#define NOAID   0x60\n#define NOAIDP  0xe8\n#define STRFLD  0x88\n#define ENTER   0x7d\n#define PF1     0xf1\n#define PF2     0xf2\n#define PF3     0xf3\n#define PF4     0xf4\n#define PF5     0xf5\n#define PF6     0xf6\n#define PF7     0xf7\n#define PF8     0xf8\n#define PF9     0xf9\n#define PF10    0x7a\n#define PF11    0x7b\n#define PF12    0x7c\n#define PF13    0xc1\n#define PF14    0xc2\n#define PF15    0xc3\n#define PF16    0xc4\n#define PF17    0xc5\n#define PF18    0xc6\n#define PF19    0xc7\n#define PF20    0xc8\n#define PF21    0xc9\n#define PF22    0x4a\n#define PF23    0x4b\n#define PF24    0x4c\n#define OID     0xe6\n#define MAG     0xe7\n#define PEN     0x7e\n#define PA1     0x6c\n#define PA2     0x6e\n#define PA3     0x6b\n#define CLEAR   0x6d\n#define SYSREQ  0xf0\n\ntypedef\n  struct LSTR     /* string with length */\n  {\n    int len ;             /* current length of data */\n    char *data ;          /* pointer to data */\n  } TLSTR ;\n\ntypedef\n  struct SFLD     /* 3270 screen field information list entry */\n  {\n    int fid ;             /* unique field identifier */\n    TLSTR fdata ;         /* field data (input or output) */\n    int fxpos ;           /* X column position */\n    int fypos ;           /* Y row position */\n    char fattr ;          /* 3270 field attribute */\n    char fcolor ;         /* 3270 color attribute */\n    char fhilite ;        /* 3270 hilite attribute */\n    char symbol ;         /* 0x00=normal 0xf1=APL else 0x40-0xef=PS */\n    struct SFLD *next ;   /* next list entry */\n  } TSFLD ;\n\n#define BUFFMAX 5000\nchar *buffer ;    /* buffer area for tput/tget */\n\nTSFLD *screen ;   /* root of 3270 screen field list */\n\n#define SFIDMAX 256\nTSFLD *sfidtab\u00ddSFIDMAX\u00a8 ; /* field id address table */\nint fidnext = 0 ;         /* next field id number to assign */\nint curcol = 1 ;          /* current cursor column */\nint currow = 1 ;          /* current cursor row */\nint bellflg = 0 ;         /* ring bell on next display */\nint iotrace = 0 ;         /* trace terminal I/O flag */\n\n\nstruct DCB        /* Device control block */\n  {\n    int model ;         /* model number ie: 3279, 3278, 3277 */\n    int type ;          /* model type ie: 2, 3, 4, 5 */\n    int rows ;          /* number of rows (height) on device */\n    int cols ;          /* number of columns (width) on device */\n    int celheigh ;      /* cell height on device */\n    int celwidth ;      /* cell width on device */\n    int colors ;        /* number of colors on device */\n    int colora ;        /* number of actual colors on device */\n    int hilites ;       /* number of colors on device */\n    int adrmode ;       /* device addressing mode: 12 or 14 or 16 bit*/\n    char unit ;         /* 0 = inch 1 = mm */\n    char edsflg ;       /* extended data stream flag */\n    char psflg ;        /* program symbols on device flag */\n    char altflg ;       /* use alternate flag */\n    char aplflg ;       /* 0 or apl's lcid=supports APL on device */\n    char graflg ;       /* graphics device flag */\n    char loadflg ;      /* loadable symbol sets supported flag */\n    char triflg ;       /* triple plane symbol sets supported flag */\n    char dbcsflg ;      /* double byte characters supported flag */\n    char colorlst\u00dd17\u00a8 ; /* list of color attributes on device */\n    char hilitlst\u00dd5\u00a8 ;  /* list of hilite attributes on device */\n    char modname\u00dd11\u00a8 ;  /* name of device ie: IBM32793B IBM3179G ..*/\n  } sdcb ;\n\n\n\n/*-------------------------------------------------------------------*/\n/* Function Prototypes                                               */\n/*-------------------------------------------------------------------*/\n\n/* field handling */\nint initscr() ;\nvoid termscr() ;\nchar dspflds() ;\nint insfld(TLSTR *, int, int, char, char, char) ;\nint getdev() ;\nint remflds() ;\nint delfld(int) ;\nint erasefld(int) ;\nint getfld(int, TLSTR *) ;\nint modfld(int, TLSTR *) ;\nint setfld(int, int, char) ;\nvoid dumpfld() ;\n/* 3270 support */\nint tputn(char *, int) ;\nint tgetn(char *, int) ;\nint tpgn(char *, int) ;\nvoid rc2sba(int, int, char *) ;\nvoid sba2rc(char *, int *, int *, int) ;\nint modsym(char *, char) ;\nint modcolor(char *, char) ;\nint modhilit(char *, char) ;\nint modattr(char *, char) ;\nint getterm(int *, int *, int *, int *, int *) ;\nint querydev() ;\nint dsummary(char *, short) ;\nint darea(char *, short) ;\nint dcharset(char *, short) ;\nint dcolor(char *, short) ;\nint dhilite(char *, short) ;\nint dmodes(char *, short) ;\nint dimpart(char *, short) ;\nint loadps1() ;\nvoid termstat() ;\nvoid clear() ;\n/* varying length string */\nvoid lstran(TLSTR *, char, char) ;\nint lstrlen(TLSTR *) ;\nvoid lstrload(TLSTR *, char *, int) ;\nint lstrunld(char *, TLSTR *) ;\nvoid lstrcopy(TLSTR *, TLSTR *) ;\nvoid lstrnew(TLSTR *, char *) ;\nvoid lstrsub(TLSTR *, TLSTR *, int, int) ;\nint lstrindx(TLSTR *, TLSTR *) ;\nvoid lstrfill(TLSTR *, char *) ;\nint lstrcmpc(TLSTR *, char *) ;\nvoid lstrdel(TLSTR *) ;\nvoid lstrrep(TLSTR *, char *, int) ;\nvoid lstrcat(TLSTR *, TLSTR *, TLSTR *) ;\n/* utility */\nvoid fill(char *, char, int) ;\nvoid dumpchar(char *, int) ;\nvoid overlay(char *, int, char *, int, int) ;\nvoid serror(int, char *) ;\n\n\n/* application routines */\nvoid buildwin() ;\nvoid dispwin() ;\nvoid winmsg(char *) ;\n\n/* variables for application */\nint cmdfid ;       /* field identifier for command line */\nint msgfid ;       /* field identifier for message line */\nint bt ;           /* top border */\nint bb ;           /* bottom border */\nint bl ;           /* left border */\nint br ;           /* right border */\nint cmdflg = 0 ;   /* command flag = true if command done */\n\n /*-----------------------------------------------------------------*\n  | Main Program                                                    |\n  *-----------------------------------------------------------------*/\nvoid main(int argc, char **argv, char **envp)\n  {\n    int rc ;        /* return code */\n\n    rc = initscr() ;  /* initialise environment */\n    if (rc==0)         /* if env OK */\n      {\n        /* initial border positions */\n        bt = 1 ;            /* top border */\n        bb = sdcb.rows ;    /* bottom border */\n        bl = 1 ;            /* left border */\n        br = sdcb.cols ;    /* right border */\n\n        /* indicate cursor on command field and set field to blank */\n        cmdflg = 1 ;\n\n        buildwin() ;  /* build the initial display window */\n        dispwin() ;   /* display the window and run appl. */\n\n        termscr() ;   /* terminate environment */\n      }\n  }\n\n\n/*-------------------------------------------------------------------*/\n/* Build a window with a title, command line and an edit space.      */\n/*-------------------------------------------------------------------*/\nvoid buildwin()\n  {\n    int t, tl ;                /* temp */\n    int i ;                    /* counter */\n    int fid ;                  /* field identifier handle */\n    TLSTR data, data1, data2, data3, data4 ; /* temp varying strings */\n    TLSTR title ;              /* title string */\n\n    /* create title line */\n    lstrnew(&title,\" TXTPAD32: 3270 Text pad test\");\n\n    /* create command line (prompt, input area, and help) */\n    lstrnew(&data,\"Command ===>\") ;   /* create VLstring */\n    fid = insfld(&data,bt+1,bl+2,PRT,WHITE,NONE);\n    if (fid<0) serror(81,\"Field insert failed\") ;\n    lstrnew(&data,\" \") ;   /* create VLstring */\n    cmdfid = insfld(&data,bt+1,bl+15,UNPRT,GREEN,NONE);\n    if (cmdfid<0) serror(81,\"Field insert failed\") ;\n    if ((br-bl)>18)\n      {\n        lstrnew(&data,\"PF1=Help PF3=End\") ;   /* create VLstring */\n        fid = insfld(&data,bt+1,br-18,PRT,WHITE,NONE);\n        if (fid<0) serror(81,\"Field insert failed\") ;\n      }\n\n    /* create message line */\n    lstrnew(&data,\" \") ;   /* create VLstring */\n    msgfid = insfld(&data,bt+2,bl+2,PRTHI,RED,NONE);\n    if (msgfid<0) serror(81,\"Field insert failed\") ;\n\n    /*----------------------------------------------------------------*/\n    /* Create top window border                                       */\n    /*   The border outline is drawn with different characters        */\n    /*     based on the devices abilities.                            */\n    /*   Window border locations are based on four global variables:  */\n    /*     bt - top border row                                        */\n    /*     bb - bottom border row                                     */\n    /*     br - right border column                                   */\n    /*     bl - left border column                                    */\n    /*----------------------------------------------------------------*/\n    if (sdcb.loadflg)\n      {\n        lstrnew(&data1,\"\\x42\\x47\") ;     /* top left corner */\n        lstrnew(&data2,\"\\x48\\x46\\x45\\x44\") ; /* top right corner */\n        lstrnew(&data3,\" \") ;\n        lstran(&title,0x40,0x48) ;      /* translate in PS blank char */\n        tl = lstrlen(&title) ; /* actual title length */\n        t = br-bl-5 ;           /* available space */\n        if (tl>t)\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrsub(&data3,&title,1,t-1) ; /* shorten title */\n            lstrcat(&data,&data,&data3) ;  /* add title */\n            lstrcat(&data,&data,&data2) ;  /* add right border */\n          }\n        else\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrcat(&data,&data,&title) ;  /* add title */\n            lstrrep(&data3,\"\\x48\",t-tl-1) ;/* repeat char to string */\n            lstrcat(&data,&data,&data3) ;  /* add top border chars */\n            lstrcat(&data,&data,&data2) ;  /* concat strings */\n          }\n        fid = insfld(&data,bt,bl,PRTAS,BLUE,NONE);\n        if (fid<0) serror(81,\"Field insert failed\") ;\n        setfld(fid,SYMSET,0x40) ;   /* make it id of PS symbols */\n      }\n    else if (sdcb.aplflg)\n      {\n        lstrnew(&data1,\"\\xc5\\xee\") ;     /* top left corner */\n        lstrnew(&data2,\"\\xa2\\xba\\xbb\\xd5\") ;   /* top right corner */\n        tl = lstrlen(&title) ; /* actual title length */\n        t = br-bl-5 ;           /* available space */\n        if (tl>t)\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrsub(&data4,&title,1,t-1) ; /* shorten title */\n            lstrnew(&data3,\"\\x28\\x43\\x01\") ;  /* stop APL chars */\n            lstran(&data3,0x01,0x00) ; /* translate 0x01 to ox00 */\n            lstrcat(&data,&data,&data3) ;  /* add stop APL */\n            lstrcat(&data,&data,&data4) ;  /* add title */\n            lstrnew(&data3,\"\\x28\\x43\\xf1\") ;  /* start APL */\n            lstrcat(&data,&data,&data3) ;  /* add start APL */\n            lstrcat(&data,&data,&data2) ;  /* add right border */\n          }\n        else\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrnew(&data3,\"\\x28\\x43\\x01\") ;  /* stop APL chars */\n            lstran(&data3,0x01,0x00) ; /* translate 0x01 to ox00 */\n            lstrcat(&data,&data,&data3) ;  /* add stop APL */\n            lstrcat(&data,&data,&title) ;  /* add title */\n            lstrnew(&data3,\"\\x28\\x43\\xf1\") ;  /* start APL */\n            lstrcat(&data,&data,&data3) ;  /* add start APL */\n            lstrrep(&data3,\"s\",t-tl-1) ;   /* repeat char to string */\n            lstrcat(&data,&data,&data3) ;  /* add top border chars */\n            lstrcat(&data,&data,&data2) ;  /* concat strings */\n          }\n        fid = insfld(&data,bt,bl,PRTAS,BLUE,NONE);\n        if (fid<0) serror(81,\"Field insert failed\") ;\n        setfld(fid,SYMSET,APL) ; /* make it APL */\n      }\n    else\n      {\n        lstrnew(&data1,\"+#\") ;     /* create VLstring */\n        lstrnew(&data2,\"-VA+\") ;   /* create VLstring */\n        lstrnew(&data3,\" \") ;\n        tl = lstrlen(&title) ;     /* actual title length */\n        t = br-bl-5 ;              /* available space */\n        if (tl>t)\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrsub(&data4,&title,1,t-1) ; /* shorten title */\n            lstrcat(&data,&data,&data4) ;  /* add title */\n            lstrcat(&data,&data,&data2) ;  /* add right border */\n          }\n        else\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrcat(&data,&data,&title) ;  /* add title */\n            lstrrep(&data3,\"-\",t-tl-1) ;   /* repeat char to string */\n            lstrcat(&data,&data,&data3) ;  /* add top border chars */\n            lstrcat(&data,&data,&data2) ;  /* concat strings */\n          }\n        fid = insfld(&data,bt,bl,PRTAS,BLUE,NONE);\n        if (fid<0) serror(81,\"Field insert failed\") ;\n      }\n\n    /* create edit area lines and left and right borders */\n    for (i=bt+1; i<=bb-1; i++)    /* edit area fields */\n      {\n        /* add left border */\n        if (sdcb.loadflg)\n          {\n            lstrnew(&data,\"\\x71\") ;\n            fid = insfld(&data,i,bl,PRTAS,BLUE,NONE) ;\n            if (fid<0) serror(81,\"Field insert failed\") ;\n            setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n          }\n        else if (sdcb.aplflg)\n          {\n            lstrnew(&data,\"e\") ;\n            fid = insfld(&data,i,bl,PRTAS,BLUE,NONE) ;\n            if (fid<0) serror(81,\"Field insert failed\") ;\n            setfld(fid,SYMSET,APL) ; /* make it APL */\n          }\n        else\n          {\n            lstrnew(&data,\"|\") ;\n            fid = insfld(&data,i,bl,PRTAS,BLUE,NONE) ;\n            if (fid<0) serror(81,\"Field insert failed\") ;\n          }\n\n        /* add right border */\n        if (sdcb.loadflg)\n          {\n            lstrnew(&data,\"\\x71\") ;\n            fid = insfld(&data,i,br-1,PRTAS,BLUE,NONE) ;\n            if (fid<0) serror(81,\"Field insert failed\") ;\n            setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n          }\n        else if (sdcb.aplflg)\n          {\n            lstrnew(&data,\"e\") ;\n            fid = insfld(&data,i,br-1,PRTAS,BLUE,NONE) ;\n            if (fid<0) serror(81,\"Field insert failed\") ;\n            setfld(fid,SYMSET,APL) ; /* make it APL */\n          }\n        else\n          {\n            lstrnew(&data,\"|\") ;\n            fid = insfld(&data,i,br-1,PRTAS,BLUE,NONE) ;\n            if (fid<0) serror(81,\"Field insert failed\") ;\n          }\n      }  /* of for edit area lines */\n\n    /* create bottom border */\n    if (sdcb.loadflg)\n      {\n        lstrnew(&data1,\"\\x67\") ;       /* lower left corner */\n        lstrnew(&data2,\"\\x69\") ;       /* lower right corner */\n        lstrrep(&data,\"\\x70\",br-bl-2) ;/* lower border chars */\n        lstrcat(&data,&data1,&data) ;  /* concat strings */\n        lstrcat(&data,&data,&data2) ;  /* concat strings */\n        fid = insfld(&data,bb,bl,PRTAS,BLUE,NONE) ;\n        if (fid<0) serror(81,\"Field insert failed\") ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n      }\n    else if (sdcb.aplflg)\n      {\n        lstrnew(&data1,\"D\") ;          /* lower left corner */\n        lstrnew(&data2,\"M\") ;          /* lower right corner */\n        lstrrep(&data,\"s\",br-bl-2) ;   /* lower border chars */\n        lstrcat(&data,&data1,&data) ;  /* concat strings */\n        lstrcat(&data,&data,&data2) ;  /* concat strings */\n        fid = insfld(&data,bb,bl,PRTAS,BLUE,NONE) ;\n        if (fid<0) serror(81,\"Field insert failed\") ;\n        setfld(fid,SYMSET,APL) ; /* make it APL */\n      }\n    else\n      {\n        lstrnew(&data1,\"+\") ;          /* lower left corner */\n        lstrnew(&data2,\"+\") ;          /* lower right corner */\n        lstrrep(&data,\"-\",br-bl-2) ;   /* lower border chars */\n        lstrcat(&data,&data1,&data) ;  /* concat strings */\n        lstrcat(&data,&data,&data2) ;  /* concat strings */\n        fid = insfld(&data,bb,bl,PRTAS,BLUE,NONE) ;\n        if (fid<0) serror(81,\"Field insert failed\") ;\n      }\n\n    /* create some widgets in the window */\n    if (sdcb.loadflg)\n      {\n        /* title static label */\n        lstrnew(&data1,\"Program Symbol Device Style\") ;\n        fid = insfld(&data1,bt+3,bl+15,PRTAS,PINK,USCORE) ;\n        lstrnew(&data1,\" \") ;\n        fid = insfld(&data1,bt+3,bl+43,PRTAS,PINK,NONE) ;\n\n\n        /* *** list box *** */\n        /* top */\n        lstrnew(&data1,\n          \"\\xef\\xef\\xef\\xef\\xef\\xef\\xef\\xef\\xef\\xef\\xef\"\n          \"\\xef\\xef\\xef\\xef\\xef\\xef\\xef\\xef\\xef\\xef\\xef\\xef\"\n          \"\\xef\\xef\\xef\\xef\\xef\\xef\\xef\\xef\\xef\\xef\\xef\\xef\"\n          \"\\xef\\xef\\xef\\xef\\xef\\xef\");\n        fid = insfld(&data1,bt+6,bl+5,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n\n        lstrnew(&data1,\"\\x43\") ;\n        fid = insfld(&data1,bt+7,bl+5,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n        lstrnew(&data1,\"00001\") ;\n        fid = insfld(&data1,bt+7,bl+7,UNPRT,GREEN,NONE) ;\n        lstrnew(&data1,\" \") ;\n        fid = insfld(&data1,bt+7,bl+13,UNPRT,YELLOW,NONE) ;\n        lstrnew(&data1,\"\\xdc\") ;\n        fid = insfld(&data1,bt+7,bl+45,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n\n        lstrnew(&data1,\"\\x43\") ;\n        fid = insfld(&data1,bt+8,bl+5,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n        lstrnew(&data1,\"00002\") ;\n        fid = insfld(&data1,bt+8,bl+7,UNPRT,GREEN,NONE) ;\n        lstrnew(&data1,\" \") ;\n        fid = insfld(&data1,bt+8,bl+13,UNPRT,YELLOW,NONE) ;\n        lstrnew(&data1,\"\\xed\") ;\n        fid = insfld(&data1,bt+8,bl+45,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n\n        lstrnew(&data1,\"\\x43\") ;\n        fid = insfld(&data1,bt+9,bl+5,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n        lstrnew(&data1,\"00003\") ;\n        fid = insfld(&data1,bt+9,bl+7,UNPRT,GREEN,NONE) ;\n        lstrnew(&data1,\" \") ;\n        fid = insfld(&data1,bt+9,bl+13,UNPRT,YELLOW,NONE) ;\n        lstrnew(&data1,\"\\xdb\") ;\n        fid = insfld(&data1,bt+9,bl+45,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n\n        lstrnew(&data1,\"\\x43\") ;\n        fid = insfld(&data1,bt+10,bl+5,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n        lstrnew(&data1,\"00004\") ;\n        fid = insfld(&data1,bt+10,bl+7,UNPRT,GREEN,NONE) ;\n        lstrnew(&data1,\" \") ;\n        fid = insfld(&data1,bt+10,bl+13,UNPRT,YELLOW,NONE) ;\n        lstrnew(&data1,\"\\xda\") ;\n        fid = insfld(&data1,bt+10,bl+45,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n\n        lstrnew(&data1,\"\\x43\") ;\n        fid = insfld(&data1,bt+11,bl+5,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n        lstrnew(&data1,\"00005\") ;\n        fid = insfld(&data1,bt+11,bl+7,UNPRT,GREEN,NONE) ;\n        lstrnew(&data1,\" \") ;\n        fid = insfld(&data1,bt+11,bl+13,UNPRT,YELLOW,NONE) ;\n        lstrnew(&data1,\"\\xda\") ;\n        fid = insfld(&data1,bt+11,bl+45,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n\n        lstrnew(&data1,\"\\x43\") ;\n        fid = insfld(&data1,bt+12,bl+5,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n        lstrnew(&data1,\"00006\") ;\n        fid = insfld(&data1,bt+12,bl+7,UNPRT,GREEN,NONE) ;\n        lstrnew(&data1,\" \") ;\n        fid = insfld(&data1,bt+12,bl+13,UNPRT,YELLOW,NONE) ;\n        lstrnew(&data1,\"\\xda\") ;\n        fid = insfld(&data1,bt+12,bl+45,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n\n        lstrnew(&data1,\"\\x43\") ;\n        fid = insfld(&data1,bt+13,bl+5,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n        lstrnew(&data1,\"00007\") ;\n        fid = insfld(&data1,bt+13,bl+7,UNPRT,GREEN,NONE) ;\n        lstrnew(&data1,\" \") ;\n        fid = insfld(&data1,bt+13,bl+13,UNPRT,YELLOW,NONE) ;\n        lstrnew(&data1,\"\\xda\") ;\n        fid = insfld(&data1,bt+13,bl+45,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n\n        lstrnew(&data1,\"\\x43\") ;\n        fid = insfld(&data1,bt+14,bl+5,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n        lstrnew(&data1,\"00008\") ;\n        fid = insfld(&data1,bt+14,bl+7,UNPRT,GREEN,NONE) ;\n        lstrnew(&data1,\" \") ;\n        fid = insfld(&data1,bt+14,bl+13,UNPRT,YELLOW,NONE) ;\n        lstrnew(&data1,\"\\xda\") ;\n        fid = insfld(&data1,bt+14,bl+45,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n\n        lstrnew(&data1,\"\\x43\") ;\n        fid = insfld(&data1,bt+15,bl+5,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n        lstrnew(&data1,\"00009\") ;\n        fid = insfld(&data1,bt+15,bl+7,UNPRT,GREEN,NONE) ;\n        lstrnew(&data1,\" \") ;\n        fid = insfld(&data1,bt+15,bl+13,UNPRT,YELLOW,NONE) ;\n        lstrnew(&data1,\"\\xee\") ;\n        fid = insfld(&data1,bt+15,bl+45,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n\n        lstrnew(&data1,\"\\x43\") ;\n        fid = insfld(&data1,bt+16,bl+5,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n        lstrnew(&data1,\"00010\") ;\n        fid = insfld(&data1,bt+16,bl+7,UNPRT,GREEN,NONE) ;\n        lstrnew(&data1,\" \") ;\n        fid = insfld(&data1,bt+16,bl+13,UNPRT,YELLOW,NONE) ;\n        lstrnew(&data1,\"\\xdd\") ;\n        fid = insfld(&data1,bt+16,bl+45,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n\n        /* bottom */\n        lstrnew(&data1,\n          \"\\xea\\xea\\xea\\xea\\xea\\xea\\xea\\xcd\\xeb\\x58\\x65\"\n          \"\\x65\\x65\\x65\\x65\\x65\\x65\\x65\\x65\\x65\\x65\\x65\\x65\"\n          \"\\x65\\x65\\x65\\x65\\x65\\x65\\x65\\x65\\x65\\x65\\x65\\x65\"\n          \"\\x65\\x65\\x65\\xec\\xcf\\xea\");\n        fid = insfld(&data1,bt+17,bl+5,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n\n      }\n    else if (sdcb.aplflg)\n      {\n        /* title static label */\n        lstrnew(&data1,\"APL Symbol Device Style\") ;\n        fid = insfld(&data1,bt+3,bl+15,PRTAS,PINK,USCORE) ;\n        lstrnew(&data1,\" \") ;\n        fid = insfld(&data1,bt+3,bl+39,PRTAS,PINK,NONE) ;\n\n\n\n      }\n    else\n      {\n        /* title static label */\n        lstrnew(&data1,\"Primitive Device Style\") ;\n        fid = insfld(&data1,bt+3,bl+15,PRTHIAS,PINK,USCORE) ;\n        lstrnew(&data1,\" \") ;\n        fid = insfld(&data1,bt+3,bl+38,PRTAS,PINK,NONE) ;\n\n\n      }\n  }\n\n\n/*-------------------------------------------------------------------*/\n/* Display the window and process the keys/commands entered.         */\n/*-------------------------------------------------------------------*/\nvoid dispwin()\n  {\n    TLSTR temp  ;        /* temp varying length string */\n    TLSTR command ;      /* command name varying length string */\n    char key ;           /* AID for the key just pressed */\n\n    lstrnew(&command,\" \") ;\n    while(lstrcmpc(&command,\"end\") != 0)\n      {\n        if (cmdflg)\n          {\n            /* set initial cursor row and col to the command field */\n            currow = bt + 1 ;\n            curcol = bl + 16 ;\n            /* blank out the command line */\n            lstrnew(&command,\" \") ;\n            modfld(cmdfid,&command) ;\n            cmdflg = 0 ;\n          }\n        key = dspflds() ;     /* display the screen and get aid=key */\n        lstrnew(&temp,\" \") ;\n        modfld(msgfid,&temp) ;    /* blank message line */\n        getfld(cmdfid,&command) ;  /* get the command line */\n\n        /* Process function keys PFKs */\n        switch (key)\n          {\n            case ENTER:\n              if (currow == bt) /* window border accelerators */\n                {\n                  if (curcol == (bl+2))  /* close window */\n                    {\n                      lstrnew(&command,\"end\") ;\n                    }\n                  else if (curcol == (br-2))  /* minimise window */\n                    {\n                      bt = 1 ;\n                      bl = 1 ;\n                      br = 48 ;\n                      bb = 20 ;\n                      remflds() ;\n                      buildwin() ;  /* re-build the display window */\n                      winmsg(\"Window minimised.\") ;\n                    }\n                  else if (curcol == (br-1))  /* maximise window */\n                    {\n                      bt = 1 ;\n                      bl = 1 ;\n                      br = sdcb.cols ;\n                      bb = sdcb.rows ;\n                      remflds() ;\n                      buildwin() ;  /* re-build the display window */\n                      winmsg(\"Window maximised.\") ;\n                    }\n                }\n              break ;\n            case PF1:    /* No help message */\n              winmsg(\n                \"Move border: PF23=Top PF11=Bottom PF10=Left PF12=Right\"\n                ) ;\n              break ;\n            case PF3:    /* Generate end command */\n            case PF15:   /* Alternate generate end command */\n              lstrnew(&command,\"end\") ;\n              break ;\n\n            case PF10:   /* move left border */\n              if ((curcol<(br-48)) &&\n                  (curcol>=1) )\n                {\n                  bl = curcol-1 ; /* adjust for attr byte */\n                  remflds() ;\n                  buildwin() ;  /* re-build the display window */\n                }\n              else\n                winmsg(\"Left border move position too far.\") ;\n              break ;\n\n            case PF11:   /* move bottom border */\n              if ((currow>(bt+20)) &&\n                  (currow<=sdcb.rows) )\n                {\n                  bb = currow ;\n                  remflds() ;\n                  buildwin() ;  /* re-build the display window */\n                }\n              else\n                winmsg(\"Bottom border move position too far.\") ;\n              break ;\n\n            case PF12:   /* move right border */\n              if ((curcol>(bl+48)) &&\n                 (curcol<=sdcb.cols) )\n                {\n                  br = curcol-1 ;  /* adjust for attr byte */\n                  remflds() ;\n                  buildwin() ;  /* re-build the display window */\n                }\n              else\n                winmsg(\"Right border move position too far.\") ;\n              break ;\n\n            case PF23:   /* move top border */\n              if ((currow<(bb-20)) &&\n                  (currow>=1) )\n                {\n                  bt = currow ;\n                  remflds() ;\n                  buildwin() ;  /* re-build the display window */\n                }\n              else\n                winmsg(\"Top border move position too far.\") ;\n              break ;\n\n            case PF24:   /* zoom to max window size */\n              bt = 1 ;\n              bl = 1 ;\n              br = sdcb.cols ;\n              bb = sdcb.rows ;\n              remflds() ;\n              buildwin() ;  /* re-build the display window */\n              break ;\n\n            case PA2:    /* reshow key does nothing - yet */\n              break ;\n\n            default:     /* any other key is not valid */\n              bellflg = 1 ;  /* sound alarm */\n              winmsg(\"Invalid function key.\") ;\n              break ;\n          }\n\n        /* Process command from the command line */\n        if (lstrcmpc(&command,\"test\") == 0)   /* test command */\n          {\n            winmsg(\"The test command was entered.\") ;\n            cmdflg = 1 ;  /* reset command line */\n          }\n        else if (lstrcmpc(&command,\"dump\") == 0)  /* dump command */\n          {\n            dumpfld() ;\n            winmsg(\"Dump command executed.\") ;\n            cmdflg = 1 ;  /* reset command line */\n          }\n        else if (lstrcmpc(&command,\"load\") == 0)  /* force load PS */\n          {\n            loadps1() ;\n            winmsg(\"Load PS type 1 command executed.\") ;\n            cmdflg = 1 ;  /* reset command line */\n          }\n        else if (lstrcmpc(&command,\"termstat\") == 0) /*dump term data*/\n          {\n            termstat() ;\n            winmsg(\"Terminal status printed.\") ;\n            cmdflg = 1 ;  /* reset command line */\n          }\n        else if (lstrcmpc(&command,\"traceon\") == 0) /* trace on */\n          {\n            iotrace = 1 ;\n            winmsg(\"Trace is on.\") ;\n            cmdflg = 1 ;  /* reset command line */\n          }\n        else if (lstrcmpc(&command,\"traceoff\") == 0) /* trace off */\n          {\n            iotrace = 0 ;\n            winmsg(\"Trace is off.\") ;\n            cmdflg = 1 ;  /* reset command line */\n          }\n\n      }   /* of while command not end */\n    clear() ;   /* clear the 3270 screen */\n  }\n\n\n/*-------------------------------------------------------------------*/\n/* Display the window and process the keys/commands entered.         */\n/*-------------------------------------------------------------------*/\nvoid winmsg(char *msg)\n  {\n    TLSTR msgstr  ;     /* message varying length string */\n\n    lstrnew(&msgstr,msg) ;\n    modfld(msgfid,&msgstr) ;\n  }\n\n/*********************************************************************/\n/* 3270 field handling routines                                      */\n/*   rc = initscr()                                                  */\n/*   termscr()                                                       */\n/*   fid = insfld(data,row,col,attr,color,hilite)                    */\n/*   rc = remflds()                                                  */\n/*   rc = delfld(fid)                                                */\n/*   rc = erasefld(fid)                                              */\n/*   rc = getfld(fid,returndata)                                     */\n/*   rc = modfld(fid,newdata)                                        */\n/*   rc = setfld(fid,attrtype,attrvalue)                             */\n/*   dumpflds()                                                      */\n/*                                                                   */\n/*********************************************************************/\n\n\n/*-------------------------------------------------------------------*/\n/* Set up the screen environment.                                    */\n/*-------------------------------------------------------------------*/\nint initscr()\n{\n    int rc = 0 ;\n\n    buffer = (char *)malloc(BUFFMAX) ;  /* alloc tput/get buffer */\n    if (buffer)\n      {\n        rc = getdev() ;  /* get3270 device information */\n        if (rc==0 && sdcb.loadflg==1)\n          loadps1() ;\n      }\n    else\n      rc = 1 ;   /* could not get buffer */\n\n    return rc ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Terminate screen environment.                                     */\n/*-------------------------------------------------------------------*/\nvoid termscr()\n{\n    if (screen)\n      remflds() ;       /* remove any remaining fields */\n\n    free((char *)buffer) ;  /* remove tput/get buffer */\n}\n\n/*-------------------------------------------------------------------*/\n/* Display current contents of the 3270 field list.                  */\n/*-------------------------------------------------------------------*/\nchar dspflds()\n{\n  TSFLD *curr ;\n  int rc, bufpos, trow = 0, tcol = 0, fstart, fend, ilen ;\n  char sba\u00dd2\u00a8 ;\n  char aid ;\n\n  /* assemble buffer, it will contain: (EW WCC) followed by all  */\n  /* the display fields. Each field will contain:                */\n  /*   (SFE 0x03 0xC0 fattr HILITE fhilite COLOR fcolor data)    */\n  if (sdcb.altflg)\n    buffer\u00dd0\u00a8 = EWA ;     /* erase write alternate */\n  else\n    buffer\u00dd0\u00a8 = EW ;      /* erase write */\n\n  /* determine if the bell should be rung */\n  if (bellflg)\n    {\n      buffer\u00dd1\u00a8 = WCCRES | WCCKBD | WCCMDT | WCCBEL ;\n      bellflg = 0 ;  /* turn bell flag off, one ring only */\n    }\n  else\n    buffer\u00dd1\u00a8 = WCCRES | WCCKBD | WCCMDT ;\n\n  bufpos = 2 ;\n  curr = screen ;     /* first node in field list */\n  while (curr)\n    {\n      buffer\u00ddbufpos++\u00a8 = SBA ;  /* set buffer address */\n      rc2sba(curr->fypos,curr->fxpos,sba) ;\n      buffer\u00ddbufpos++\u00a8 = sba\u00dd0\u00a8 ;\n      buffer\u00ddbufpos++\u00a8 = sba\u00dd1\u00a8 ;\n      if (sdcb.edsflg)\n        {\n          buffer\u00ddbufpos++\u00a8 = SFE ;  /* start field extended */\n          buffer\u00ddbufpos++\u00a8 = 0x03 ;\n          buffer\u00ddbufpos++\u00a8 = 0xc0 ;\n          buffer\u00ddbufpos++\u00a8 = curr->fattr ;\n          buffer\u00ddbufpos++\u00a8 = HILITE ;\n          buffer\u00ddbufpos++\u00a8 = curr->fhilite ;\n          buffer\u00ddbufpos++\u00a8 = COLOR ;\n          buffer\u00ddbufpos++\u00a8 = curr->fcolor ;\n\n          /* insert set character attribute before data if APL/PS syms*/\n          /* are required and the field has protection turned on.     */\n          if (((curr->symbol==APL) || (curr->symbol==0x40)) /*APL/PS*/\n            && (curr->fattr & 0x40)) /* and protected field */\n            {\n              buffer\u00ddbufpos++\u00a8 = SA ;           /* set attribute */\n              buffer\u00ddbufpos++\u00a8 = SYMSET ;       /* symbol */\n              if (curr->symbol==APL) /* APL ? */\n                buffer\u00ddbufpos++\u00a8 = sdcb.aplflg ; /* use APL's lcid */\n              else\n                buffer\u00ddbufpos++\u00a8 = curr->symbol ; /* use symbol value */\n            }\n        }\n      else    /* dont used extended data stream */\n        {\n          buffer\u00ddbufpos++\u00a8 = SF ;  /* start field */\n          buffer\u00ddbufpos++\u00a8 = curr->fattr ;\n        }\n\n      /* insert field data */\n      ilen = lstrunld(&buffer\u00ddbufpos\u00a8,&curr->fdata) ;\n      bufpos = bufpos + ilen ;\n\n      /* revert to standard symbols after APL/PS data symbols  */\n      if (((curr->symbol==APL) || (curr->symbol==0x40)) /*APL/PS*/\n        && (curr->fattr & 0x40)) /* and protected field */\n        {\n          buffer\u00ddbufpos++\u00a8 = SA ;       /* set attribute */\n          buffer\u00ddbufpos++\u00a8 = SYMSET ;   /* symbol */\n          buffer\u00ddbufpos++\u00a8 = DFLT ;     /* revert to default symbols */\n        }\n\n      curr = curr->next ;  /* go to next field */\n    }\n\n  /* insert the cursor in the same location the user left it */\n  buffer\u00ddbufpos++\u00a8 = SBA ;     /* add set buffer address order */\n  rc2sba(currow,curcol,sba) ;  /* determine SBA for current row/col */\n  buffer\u00ddbufpos++\u00a8 = sba\u00dd0\u00a8 ;  /* add buffer addr part 1 */\n  buffer\u00ddbufpos++\u00a8 = sba\u00dd1\u00a8 ;  /* add buffer addr part 2 */\n  buffer\u00ddbufpos++\u00a8 = ICUR ;    /* add insert cursor order */\n\n  /* dumpchar(buffer,bufpos) ; */\n\n  /* write buffer to the 3270 */\n  rc = tputn(buffer, bufpos) ;\n\n  fill(buffer,0x00,bufpos) ;\n  /* receive the response from the user */\n  rc = tgetn(buffer, BUFFMAX ) ;\n\n  /* decode input, should be an AID, a cursor pos bufferaddr */\n  /* and a list of fields (SBA addr1 addr2 data)             */\n\n  aid = buffer\u00dd0\u00a8 ;      /* get code of key that was pressed */\n  sba\u00dd0\u00a8 = buffer\u00dd1\u00a8 ;\n  sba\u00dd1\u00a8 = buffer\u00dd2\u00a8 ;\n  sba2rc(sba,&currow,&curcol,0) ;  /* convert and store cursor pos */\n                                   /* adjust = 0 used for cursor pos */\n\n  curr = screen ;\n  fstart = 0 ;\n  bufpos = 3 ;\n  while(bufpos<=BUFFMAX)\n    {\n      if (buffer\u00ddbufpos\u00a8==SBA)\n        {\n          /* get new buffer address */\n          bufpos++ ;\n          sba\u00dd0\u00a8 = buffer\u00ddbufpos++\u00a8 ;\n          sba\u00dd1\u00a8 = buffer\u00ddbufpos++\u00a8 ;\n          sba2rc(sba,&trow,&tcol,1) ; /* convert buf.addr to row/col */\n                              /* adjust = 1 used for retn. buf. addr */\n          fstart = bufpos ;\n\n          /* locate field by r/c then write data to field list entry */\n          while( !((curr->fxpos==tcol) && (curr->fypos==trow)) )\n            {                          /* locate */\n              curr = curr->next ;\n              if (!curr) break ; /* could not locate - real bad */\n            }\n\n          if (curr)    /* found field - copy the data into it */\n            {\n              /* first locate end of data */\n              fend = fstart ;\n              while ((buffer\u00ddfend\u00a8 != SBA) &&\n                     (buffer\u00ddfend\u00a8 != 0x00))\n                fend++ ;  /* leaves fend pointing at next char. */\n\n              /* copy data from buffer into field list */\n              ilen = fend - fstart ;\n              lstrload(&curr->fdata,&buffer\u00ddfstart\u00a8,ilen) ;\n\n              /* adjust bufpos to last char of this returned SBA */\n              bufpos = fend -1 ;\n            }\n          else\n            {\n              /* SEVERE ERROR: This should never happen */\n              printf(\"No locate field: row %d col %d SBA %.2X %.2X\\n\",\n                trow,tcol,sba\u00dd0\u00a8,sba\u00dd1\u00a8) ;\n              curr = screen ;  /* further searches from top */\n            }\n        }\n      else\n        bufpos++ ;   /* advance to next char */\n    }\n\n  return aid ;    /* data returned OK */\n}\n\n\n/*-------------------------------------------------------------------*/\n/* Dump field list to stdout.                                        */\n/*-------------------------------------------------------------------*/\nvoid dumpfld()\n{\n  TSFLD *curr ;\n  int i = 0, size = 0 ;\n  char sba\u00dd2\u00a8 ;\n\n  printf(\"Field list follows:\\n\") ;\n  curr = screen ;     /* first node in field list */\n  while (curr)\n    {\n      printf(\"  Field at row %d col %d\\n\",curr->fypos,curr->fxpos) ;\n      rc2sba(curr->fypos,curr->fxpos,sba) ;\n      printf(\"    BufAddr: %.2X %.2X \",sba\u00dd0\u00a8,sba\u00dd1\u00a8) ;\n      printf(\"Attrib: %.2X \",curr->fattr) ;\n      printf(\"Hilite: %.2X \",curr->fhilite) ;\n      printf(\"Color: %.2X \",curr->fcolor) ;\n      printf(\"Symbol: %.2X \",curr->symbol) ;\n      printf(\"DataLen: %d\\n\",curr->fdata.len) ;\n      printf(\"    Data dump: \\n\") ;\n      dumpchar(curr->fdata.data,curr->fdata.len) ;\n      size = size + curr->fdata.len  + 11 ;\n      i++ ;\n      curr = curr->next ;\n    }\n  printf(\"Total fields %d, buffer size required %d\\n\",i,size) ;\n}\n\n\n/*-------------------------------------------------------------------*/\n/* Print terminal status.                                            */\n/*-------------------------------------------------------------------*/\nvoid termstat()\n{\n  printf(\"Terminal status follows:\\n\") ;\n  printf(\"  Device name.........: %s\\n\",sdcb.modname) ;\n  printf(\"  Device model........: %d\\n\",sdcb.model) ;\n  printf(\"  Device type.........: %d\\n\",sdcb.type) ;\n  printf(\"  Addressing mode.....: %d\\n\",sdcb.adrmode) ;\n  printf(\"  Maximum rows........: %d\\n\",sdcb.rows) ;\n  printf(\"  Maximum columns.....: %d\\n\",sdcb.cols) ;\n  printf(\"  Cell height.........: %d\\n\",sdcb.celheigh) ;\n  printf(\"  Cell width..........: %d\\n\",sdcb.celwidth) ;\n  printf(\"  Supported colors....: %d\\n\",sdcb.colors) ;\n  printf(\"  Actual colors.......: %d\\n\",sdcb.colora) ;\n  printf(\"  Color attr list.....: %.32X\\n\",sdcb.colorlst) ;\n  printf(\"  Number of Highlights: %d\\n\",sdcb.hilites) ;\n  printf(\"  Highlight attr list.: %.8X\\n\",sdcb.hilitlst) ;\n  if (sdcb.unit)\n    printf(\"  Unit................: mm\\n\") ;\n  else\n    printf(\"  Unit................: inch\\n\") ;\n  printf(\"  Alternate device....: %d\\n\",sdcb.altflg) ;\n  printf(\"  APL symbol set......: %.2X\\n\",sdcb.aplflg) ;\n  printf(\"  Extended data stream: %d\\n\",sdcb.edsflg) ;\n  printf(\"  Loadable symbols....: %d\\n\",sdcb.loadflg) ;\n  printf(\"  Load PS extended....: %d\\n\",sdcb.psflg) ;\n  printf(\"  Triple plane symbols: %d\\n\",sdcb.triflg) ;\n  printf(\"  Double byte symbols.: %d\\n\",sdcb.dbcsflg) ;\n  printf(\"  Vector graphic......: %d\\n\",sdcb.graflg) ;\n}\n\n\n/*-------------------------------------------------------------------*/\n/* Add a field to the 3270 field list.                               */\n/*-------------------------------------------------------------------*/\nint insfld(TLSTR *flddata,       /* the data */\n            int ypos,            /* display at row */\n            int xpos,            /* display at column */\n            char attr,           /* field attribute PRT, UNPRT ...*/\n            char color,          /* field color RED, BLUE, ...*/\n            char hilite )        /* field hilite BLINK, RVIDEO,...*/\n{\n  int rc ;\n  TSFLD *newfld, *last, *top ;\n\n  /* get storage for new nodes */\n  newfld = (TSFLD *)malloc(sizeof(TSFLD)) ;\n  if (!newfld) serror(20,\"Not enough memory\") ;\n  memset(newfld,0x00,sizeof(TSFLD)) ;\n\n  /* verify contents of all parameters */\n  if ((flddata->len > 0) &&\n    (flddata->len <= (sdcb.rows * sdcb.cols)))\n    lstrcopy(&newfld->fdata,flddata) ;\n  else\n    return -1 ;\n\n  if ((xpos > 0) &&\n    (xpos < sdcb.cols))\n    newfld->fxpos = xpos ;\n  else\n    return -2 ;\n\n  if ((ypos > 0) &&\n    (ypos <= sdcb.rows))\n    newfld->fypos = ypos ;\n  else\n    return -3 ;\n\n  rc = modattr(&newfld->fattr,attr) ;\n  if (rc) return -4 ;\n\n  rc = modcolor(&newfld->fcolor,color) ;\n  if (rc) return -5 ;\n\n  rc = modhilite(&newfld->fhilite,hilite) ;\n  if (rc) return -6 ;\n\n  /* insert the field into the field list in order of buffer offset */\n  top = screen ;\n  if (!top)   /* first entry in the list (screen->00) */\n    {\n      newfld->next = NULL ;\n      screen = newfld ;\n    }\n  else\n    {\n      last = NULL ;  /* last node examined */\n      while(top)    /* loop through fields for insert place */\n        {\n          if ((top->fxpos+top->fypos*sdcb.cols) <\n            (newfld->fxpos+newfld->fypos*sdcb.cols)) /* rel.buff.pos */\n            {    /* chain to next node */\n              last = top ;\n              top = top->next ;\n            }\n          else\n            {\n              if (last)  /* insert the new node, in middle of list */\n                {\n                  last->next = newfld ;\n                  newfld->next = top ;\n                }\n              else   /* insert new first node in list */\n                {\n                  newfld->next = top ;\n                  screen = newfld ;\n                }\n              break ;   /* exit loop */\n            }\n        }\n      if (!newfld->next)  /* stil not inserted? - add to end */\n        last->next = newfld ;\n    }\n\n  /* update field id table and field id in field struct */\n  newfld->fid = fidnext ;\n  sfidtab\u00ddfidnext\u00a8 = newfld ;\n  rc = fidnext++ ;\n  return rc ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Remove all fields defined from the 3270 field list.               */\n/*-------------------------------------------------------------------*/\nint remflds()\n{\n  int i ;\n  TSFLD *curr, *top ;\n\n  for (i=0; i<SFIDMAX; i++)  /* empty fid table */\n    sfidtab\u00ddi\u00a8 = NULL ;\n  fidnext = 0 ;              /* reset next fid */\n\n  top = screen ;             /* free field list */\n  while(top)\n    {\n      curr = top ;\n      top = top->next ;\n      free((char *)curr->fdata.data) ;\n      free((TSFLD *)curr) ;\n    }\n  screen = NULL ;\n  return 0 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Delete a field from the 3270 field list.                          */\n/*-------------------------------------------------------------------*/\nint delfld(int id)\n{\n    TSFLD *curr, *top, *last ;\n\n    if ((id < SFIDMAX) && (id >= 0))\n      {\n        curr = sfidtab\u00ddid\u00a8 ;\n        if (curr)\n          {\n            top = screen ;\n            last = NULL ;\n            while (top)\n              {\n                if (top == curr)\n                  {\n                    if (!last)   /* ? found node at top */\n                      screen = top->next ;\n                    else if (!top->next)  /* ? last node */\n                      last->next = NULL ;\n                    else           /* in middle of list */\n                      last->next = top->next ;\n                    /* delete the node */\n                    free((char *)top->fdata.data) ;\n                    free((TSFLD *)top) ;\n                    sfidtab\u00ddid\u00a8 = NULL ; /* invalidate id */\n                    return 0 ;  /* field id removed OK */\n                  }\n                last = top ;  /* remember last node */\n                top = top->next ;   /* chain to next node */\n              }    /* of while top */\n          }\n        else return 1 ;     /* invalid id */\n      }\n    else return 2 ;    /* out of range id */\n    return 3 ;     /* idtab list mismatch */\n}\n\n/*-------------------------------------------------------------------*/\n/* Erase the contents of a field in the 3270 field list.             */\n/*-------------------------------------------------------------------*/\nint erasefld(int id)\n{\n  TSFLD *curr ;\n\n  if ((id < SFIDMAX) && (id >= 0))\n    {\n      curr = sfidtab\u00ddid\u00a8 ;\n      if (curr)\n        lstrfill(&curr->fdata,\"\\0\") ; /* fill with zeros */\n      else\n        return 1 ;     /* invalid id */\n    }\n  else\n    return 2 ;    /* out of range id */\n\n  return 0 ;    /* id erased OK */\n}\n\n/*-------------------------------------------------------------------*/\n/* Get the current contents of a field in the 3270 field list.       */\n/*-------------------------------------------------------------------*/\nint getfld(int id,\n           TLSTR *retdata)\n{\n  TSFLD *curr ;\n\n  if ((id < SFIDMAX) && (id >= 0))\n    {\n      curr = sfidtab\u00ddid\u00a8 ;\n      if (curr)\n        lstrcopy(retdata,&curr->fdata) ; /* copy data */\n      else\n        return 1 ;     /* invalid id */\n    }\n  else\n    return 2 ;    /* out of range id */\n\n  return 0 ;    /* data returned OK */\n}\n\n/*-------------------------------------------------------------------*/\n/* Modify the contents of a field in the 3270 field list.            */\n/*-------------------------------------------------------------------*/\nint modfld(int id,\n           TLSTR *newdata)\n{\n  TSFLD *curr ;\n\n  if ((id < SFIDMAX) && (id >= 0))\n    {\n      curr = sfidtab\u00ddid\u00a8 ;\n      if (curr)\n        {\n          if ((newdata->len > 0) &&\n            (newdata->len <= (sdcb.rows * sdcb.cols)))\n            lstrcopy(&curr->fdata,newdata) ; /* alter field data*/\n          else\n            return 1 ;  /* data too large or 0 */\n        }\n      else\n        return 2 ;     /* invalid id */\n    }\n  else\n    return 3 ;    /* out of range id */\n\n  return 0 ;    /* data returned OK */\n}\n\n/*-------------------------------------------------------------------*/\n/* Change the attributes of a field in the 3270 field list.          */\n/*-------------------------------------------------------------------*/\nint setfld(int id,\n           int type,\n           char value)\n{\n  TSFLD *curr ;\n  int rc = 0 ;\n\n  if ((id < SFIDMAX) && (id >= 0))\n    {\n      curr = sfidtab\u00ddid\u00a8 ;\n      if (curr)\n        {\n          switch (type)\n            {\n            case ALL:\n              rc = modcolor(&curr->fcolor,DFLT) ;\n              rc = modhilite(&curr->fhilite,DFLT) ;\n              rc = modattr(&curr->fattr,DFLT) ;\n              break ;\n            case HILITE:\n              rc = modhilite(&curr->fhilite,value) ;\n              break ;\n            case COLOR:\n              rc = modcolor(&curr->fcolor,value) ;\n              break ;\n            case ATTR:\n              rc = modattr(&curr->fattr,value) ;\n              break ;\n            case SYMSET:\n              rc = modsym(&curr->symbol,value) ;\n              break ;\n            default:\n              return 1 ;    /* invalid type */\n            }\n        }\n      else\n        return 1 ;     /* invalid id */\n    }\n  else\n    return 2 ;    /* out of range id */\n\n  return rc ;   /* return */\n}\n\n\n\n/*********************************************************************/\n/* 3270 support routines                                             */\n/*   rc2sba(row,col,sba)                                             */\n/*   sba2rc(sba,row,col,adjust)                                      */\n/*   rc = modcolor(out,in)                                           */\n/*   rc = modhilit(out,in)                                           */\n/*   rc = modattr(out,in)                                            */\n/*   rc = tputn(buf,buflen)                                          */\n/*   rc = tgetn(buf,buflen)                                          */\n/*   rc = tpgn(buf,buflen)                                           */\n/*   rc = getdev()                                                   */\n/*   rc = getterm(primrow,primcol,altrow,altcol,attrs)               */\n/*   rc = querydev()                                                 */\n/*   rc = dsummary(buf,buflen)                                       */\n/*   rc = darea(buf,buflen)                                          */\n/*   rc = dcharset(buf,buflen)                                       */\n/*   rc = dcolor(buf,buflen)                                         */\n/*   rc = dhilite(buf,buflen)                                        */\n/*   rc = dmodes(buf,buflen)                                         */\n/*   rc = dimpart(buf,buflen)                                        */\n/*                                                                   */\n/*********************************************************************/\n\n/*-------------------------------------------------------------------*/\n/* The TPUTN routine is loaded below the 16M line                    */\n/* It issues the TPUT macro with the NOEDIT option                   */\n/*-------------------------------------------------------------------*/\nint tputn(char *buf, int buflen)\n  {\n    int rc = 0 ;\n    int (*tputn)(char *,int) ;\n\n    loadm(\"TPUTN\",&tputn) ;\n    if (iotrace)      /* trace terminal I/O ? */\n      {\n        printf(\"Outbound data stream:\\n\") ;\n        dumpchar(buf,buflen) ;\n      }\n    rc = (*tputn)(buf,buflen) ;\n    unloadm(tputn) ;\n    return rc ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* The TGETN routine is loaded below the 16M line                    */\n/* It issues the TGET macro with the FULLSCR option.                 */\n/*-------------------------------------------------------------------*/\nint tgetn(char *buf, int buflen)\n  {\n    int rc = 0 ;\n    int (*tgetn)(char *,int) ;\n\n    loadm(\"TGETN\",&tgetn) ;\n    rc = (*tgetn)(buf,buflen) ;\n    if (iotrace)      /* trace terminal I/O ? */\n      {\n        printf(\"Inbound data stream:\\n\") ;\n        dumpchar(buf,buflen) ;\n      }\n    unloadm(tgetn) ;\n    return rc ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* The TPGN routine is loaded below the 16M line                     */\n/* It issues the TPG macro with the NOEDIT option.                   */\n/*-------------------------------------------------------------------*/\nint tpgn(char *buf, int buflen)\n  {\n    int rc = 0 ;\n    int (*tpgn)(char *,int) ;\n\n    loadm(\"TPGN\",&tpgn) ;\n    if (iotrace)      /* trace terminal I/O ? */\n      {\n        printf(\"Outbound data stream:\\n\") ;\n        dumpchar(buf,buflen) ;\n      }\n    rc = (*tpgn)(buf,buflen) ;\n    unloadm(tpgn) ;\n    return rc ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* Convert row/column to 3270 12/16 bit buffer address.              */\n/*-------------------------------------------------------------------*/\nvoid rc2sba(int row,\n            int col,\n            char *sba)\n{\n  int offset, byte1, byte2 ;\n\n  offset = ((row-1)*sdcb.cols)+(col-1) ;\n  if (sdcb.adrmode == 12)  /* addressing mode = 12 */\n    {\n      byte1 = offset >> 6 ;           /* extract high order bits */\n      byte1 = byte1 | 0x000000c0 ;    /* turn on 12 bit ind */\n\n      byte2 = offset & 0x0000003f ;   /* extract low order 6 bits */\n      byte2 = byte2 | 0x000000c0 ;    /* turn on 12 bit ind */\n\n      sba\u00dd0\u00a8 = *((char *)&byte1+3) ;  /* assemble 2 byte sba */\n      sba\u00dd1\u00a8 = *((char *)&byte2+3) ;\n    }\n  else /* adrmode = 16 or 14 */\n    {\n      byte1 = offset >> 8 ;           /* extract high order byte */\n      byte2 = offset & 0x00ff ;       /* extract low order byte */\n      sba\u00dd0\u00a8 = *((char *)&byte1+3) ;  /* assemble 2 byte sba */\n      sba\u00dd1\u00a8 = *((char *)&byte2+3) ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Convert 12/14/16-bit address to an offset and row/column.         */\n/*-------------------------------------------------------------------*/\nvoid sba2rc(char *inaddr,  /* input buffer addr */\n            int *row,      /* returned row */\n            int *col,      /* returned column */\n            int adjust)    /* amount to subtract - usuallu 0 for the */\n                           /*   returned cursor position, but is set */\n                           /*   to one to get correct returned buffer*/\n                           /*   addresses.                           */\n{\n  int taddr,     /* Temporary address holder */\n      offset ;\n  short addr ;\n  memcpy((char *)&addr,inaddr,sizeof(short)) ;\n\n  /* If 12-bit address, then we need to massage it a little */\n  if (addr & 0xc000)    /* 12-bit address ? */\n    {\n       addr &= 0x3f3f ;      /* turn off 2 hi bits in each byte */\n       taddr = addr >> 8 ;   /* taddr is first 6 bits */\n       addr &= 0x00ff ;      /* addr is second 6 bits */\n       taddr = taddr << 6 ;  /* shift taddr left and .. */\n       taddr |= addr ;       /*   merge taddr with addr into taddr */\n       offset = taddr ;      /* taddr is the offset into the buffer */\n    }\n  else\n    offset = addr ;          /* addr is the offset into the buffer */\n\n  offset = offset - adjust ; /* adjust is either 0 or 1 */\n\n  /* turn offset into row and column based on device num of columns */\n  *col = (offset % sdcb.cols) + 1 ;\n  *row = (offset / sdcb.cols) + 1 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Check color attribute and copy if valid.                          */\n/*-------------------------------------------------------------------*/\nint modsym(char *out,\n           char in )\n{\n  switch (in)\n    {\n    case DFLT:\n      *out = in ;\n      return 0 ;\n    case APL:\n      if (sdcb.aplflg)\n        {\n          *out = in ;\n          return 0 ;\n        }\n      else\n        return 1 ;\n    default:\n      if (sdcb.loadflg)\n        {\n          if ((in>=0x40) && (in<=0xef))\n            {\n              *out = in ;\n              return 0 ;\n            }\n          else\n            return 1 ;\n        }\n      else\n        return 1 ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Check color attribute and copy if valid.                          */\n/*-------------------------------------------------------------------*/\nint modcolor(char *out,\n             char in )\n{\n  switch (in)\n    {\n    case DFLT:\n    case BLUE:\n    case RED:\n    case PINK:\n    case GREEN:\n    case TURQ:\n    case YELLOW:\n    case WHITE:\n      *out = in ;\n      return 0 ;\n    default:\n      return 1 ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Check hilite attribute and copy if valid.                         */\n/*-------------------------------------------------------------------*/\nint modhilit(char *out,\n             char in )\n{\n  switch (in)\n    {\n    case NONE:\n    case BLINK:\n    case RVIDEO:\n    case USCORE:\n      *out = in ;\n      return 0 ;\n    default:\n      return 1 ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Check field attribute and copy if valid.                          */\n/*-------------------------------------------------------------------*/\nint modattr(char *out,\n            char in )\n{\n  switch (in)\n    {\n    case PRT:       /* protected normal intensity */\n    case PRTHI:     /* protected high intensity */\n    case PRTAS:     /* protected normal intensity auto skip */\n    case PRTHIAS:   /* protected high intensity auto skip */\n    case UNPRT:     /* unprotected normal intensity */\n    case UNNUM:     /* unprotected numeric normal intensity */\n    case UNNUMHI:   /* unprotected numeric high intensity */\n    case UNNON:     /* unprotected non display */\n    case UNHI:      /* unprotected high intensity */\n      *out = in ;\n      return 0 ;\n    default:\n      return 1 ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Load programmed symbols - type 1 load                             */\n/*   loads programmed symbols without compression                    */\n/*-------------------------------------------------------------------*/\nint loadps1()\n  {\n    int rc ;         /* return code */\n    int bufpos ;     /* next buffer position */\n    int i, j ;       /* counters */\n    short s ;        /* temp */\n\n    memset(buffer,0x00,BUFFMAX) ;  /* clear buffer */\n\n    bufpos = 0 ;\n    buffer\u00ddbufpos++\u00a8 = WSF ;   /* write structured field */\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;  /* structured field length */\n    buffer\u00ddbufpos++\u00a8 = 0x07 ;  /* structured field length contd. */\n    buffer\u00ddbufpos++\u00a8 = 0x06 ;  /* load PS structured field */\n    buffer\u00ddbufpos++\u00a8 = 0x41 ;  /* flags: clear sym.set and use type 1 */\n    buffer\u00ddbufpos++\u00a8 = 0xff ;  /* make associated RWS = not assigned */\n    buffer\u00ddbufpos++\u00a8 = 0x41 ;  /* starting code point */\n    buffer\u00ddbufpos++\u00a8 = 0x02 ;  /* RWS of PSA symbol set */\n\n    /* write buffer to the 3270 */\n    rc = tputn(buffer, bufpos) ;\n\n    memset(buffer,0x00, bufpos) ;  /* clear buffer */\n\n    bufpos = 0 ;\n    buffer\u00ddbufpos++\u00a8 = WSF ;   /* write structured field */\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;  /* structured field length */\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;  /* structured field length contd. */\n    buffer\u00ddbufpos++\u00a8 = 0x06 ;  /* load PS structured field */\n    buffer\u00ddbufpos++\u00a8 = 0x01 ;  /* flags: use type 1 */\n    buffer\u00ddbufpos++\u00a8 = 0x40 ;  /* make associated RWS = 0x40 */\n    buffer\u00ddbufpos++\u00a8 = 0x41 ;  /* starting code point (symbol=65) */\n    buffer\u00ddbufpos++\u00a8 = 0x02 ;  /* RWS of PSA symbol set */\n\n /* This extra stuff needs the flags bit 1 on to indicate extended\n    I dont think I need to use it yet.\n\n    buffer\u00ddbufpos++\u00a8 = 0x08 ;     P length - length of extra parms\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     flags: operator selectable ...\n    buffer\u00ddbufpos++\u00a8 = 0x09 ;     LW - width of character\n    buffer\u00ddbufpos++\u00a8 = 0x10 ;     LH - width of character\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     SUBSN - only one byte codes\n    buffer\u00ddbufpos++\u00a8 = 0xf1 ;     COLOR - F1 - first attr ???\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     ST.SUBSN - default\n    buffer\u00ddbufpos++\u00a8 = 0xf9 ;     ECHAR - last symbol=249\n\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     NW - number width pairs\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     NH - number height pairs\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     RES - reserved\n */\n\n    /* load specific font based on the cell height */\n    if (sdcb.celheigh >= 16)\n      {\n        for (i=65;i<=249;i++)   /* for each symbol, 0x41 to 0xF9 */\n          {\n            for (j=0;j<=17;j++)      /* for each slice  */\n              {\n                buffer\u00ddbufpos++\u00a8 = ps9x16u\u00ddi\u00a8\u00ddj\u00a8 ;\n              }\n          }\n      }\n    else if (sdcb.celheigh == 15)\n      {\n        for (i=65;i<=249;i++)   /* for each symbol, 0x41 to 0xF9 */\n          {\n            for (j=0;j<=17;j++)      /* for each slice  */\n              {\n                buffer\u00ddbufpos++\u00a8 = ps9x15u\u00ddi\u00a8\u00ddj\u00a8 ;\n              }\n          }\n      }\n    else\n      {\n        for (i=65;i<=249;i++)   /* for each symbol, 0x41 to 0xF9 */\n          {\n            for (j=0;j<=17;j++)      /* for each slice  */\n              {\n                buffer\u00ddbufpos++\u00a8 = ps9x12u\u00ddi\u00a8\u00ddj\u00a8 ;\n              }\n          }\n      }\n\n    s = bufpos - 1 ;\n    memcpy(buffer+1,&s,sizeof(short)) ;\n\n    /* write buffer to the 3270 to load the programmed symbols */\n    rc = tputn(buffer, bufpos) ;\n\n    memset(buffer,0x00,BUFFMAX) ;  /* clear buffer */\n    return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* Get the display device attributes.                                */\n/*-------------------------------------------------------------------*/\nint getdev()\n  {\n    int rc, pr = 0, pc = 0, ar = 0, ac = 0, att = 0 ;\n    int i ;\n\n    /* set the default values, may get over ridden later */\n    sdcb.adrmode = 12 ;  /* addressing mode */\n    sdcb.altflg = 0 ;    /* use primary device */\n    sdcb.edsflg = 0 ;    /* no extended data stream */\n    sdcb.graflg = 0 ;    /* not a graphics device */\n    sdcb.aplflg = 0 ;    /* no apl symbols on device */\n    sdcb.psflg = 0 ;     /* no program symbols on device */\n    sdcb.loadflg = 0 ;   /* no loadable symbols sets on device */\n    sdcb.triflg = 0 ;    /* no triple plane symbols sets on device */\n    sdcb.dbcsflg = 0 ;   /* no double byte symbols on device */\n    sdcb.celheigh = 0 ;  /* zero cell height on device */\n    sdcb.celwidth = 0 ;  /* zero cell width on device */\n    sdcb.unit = 0 ;      /* units are inches */\n    sdcb.colora = 1 ;    /* actual colors default to monochrome */\n    sdcb.colors = 1 ;    /* supported colors default to monochrome */\n    sdcb.hilites = 0 ;   /* supported hilites default to none */\n    for (i=0;i<17;i++)\n      sdcb.colorlst\u00ddi\u00a8 = 0x00 ; /* list of color attributes on device*/\n    for (i=0;i<5;i++)\n      sdcb.hilitlst\u00ddi\u00a8 = 0x00 ; /* list of hilite attributes on device*/\n\n\n    /* get info from TSO about this device */\n    rc = getterm(&pr,&pc,&ar,&ac,&att) ;\n    if (rc==0)                 /* get terminal info worked ? */\n      {\n        if (att==0x00000001)   /* device has query structured fields */\n          {\n            /* set row and col may be later reset by query dev */\n            if ((ar>0) && (ar!=pr) &&\n                (ac>0) && (ac!=pc))\n              {\n                sdcb.altflg = 1 ;    /* use alternate device */\n                sdcb.rows = ar ;     /* use alternate rows */\n                sdcb.cols = ac ;     /* use alternate cols */\n              }\n            else\n              {\n                sdcb.rows = pr ;     /* use primary rows */\n                sdcb.cols = pc ;     /* use primary cols */\n              }\n\n            rc = querydev() ;\n            /* try to determine actual device */\n            if (sdcb.rows == 32)\n              {\n                strcpy(sdcb.modname,\"IBM3279-3\") ;\n                sdcb.model = 3279 ;\n                sdcb.type = 3 ;\n              }\n            else if (sdcb.rows == 43)\n              {\n                strcpy(sdcb.modname,\"IBM3278-4\") ;\n                sdcb.model = 3278 ;\n                sdcb.type = 4 ;\n              }\n            else if (sdcb.rows == 27)\n              {\n                strcpy(sdcb.modname,\"IBM3290\") ;\n                sdcb.model = 3290 ;\n                sdcb.type = 5 ;\n              }\n            else  /* cant tell - use most primitive */\n              {\n                strcpy(sdcb.modname,\"IBM3278-2\") ;\n                sdcb.model = 3278 ;\n                sdcb.type = 2 ;\n              }\n          }\n        else  /* dont know a lot about the device - make some guesses */\n          {\n            if ((ar>0) && (ar!=pr) &&\n                (ac>0) && (ac!=pc))\n              {\n                sdcb.altflg = 1 ;    /* use alternate device */\n                sdcb.rows = ar ;     /* use alternate rows */\n                sdcb.cols = ac ;     /* use alternate cols */\n              }\n            else\n              {\n                sdcb.rows = pr ;     /* use primary rows */\n                sdcb.cols = pc ;     /* use primary cols */\n              }\n\n            /* try to determine actual device */\n            if (sdcb.rows == 32)\n              {\n                strcpy(sdcb.modname,\"IBM3279-3\") ;\n                sdcb.model = 3279 ;\n                sdcb.type = 3 ;\n              }\n            else if (sdcb.rows == 43)\n              {\n                strcpy(sdcb.modname,\"IBM3278-4\") ;\n                sdcb.model = 3278 ;\n                sdcb.type = 4 ;\n              }\n            else if (sdcb.rows == 27)\n              {\n                strcpy(sdcb.modname,\"IBM3290\") ;\n                sdcb.model = 3290 ;\n                sdcb.type = 5 ;\n              }\n            else  /* cant tell - use most primitive */\n              {\n                strcpy(sdcb.modname,\"IBM3278-2\") ;\n                sdcb.model = 3278 ;\n                sdcb.type = 2 ;\n              }\n          }\n        return 0 ;\n      }\n    else  /* get term failed - return its code */\n      return rc ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* This routine loads an assebbler module below the 16 MB line       */\n/* that issues the GTTERM macro instruction to obtain the            */\n/* dimensions of the screen and also some bit fields that            */\n/* tell if the device can be queried. The module copies the          */\n/* results from storage below the line to this routines              */\n/* automatic storage.                                                */\n/* Upon completion the module is unloaded.                           */\n/*-------------------------------------------------------------------*/\nint getterm(int *primrow, int *primcol,\n             int *altrow, int *altcol,\n             int *attrs)\n  {\n    struct {\n      union {\n        short sh ;\n        char c\u00dd2\u00a8 ;\n      } prim ;\n      union {\n        short sh ;\n        char c\u00dd2\u00a8 ;\n      } alt ;\n      int attr ;\n    } pm ;\n    int rc = 0 ;\n    int (*tgt327d)(void *) ;\n\n    loadm(\"TGT327D\",&tgt327d) ;   /* load ASM routine below 16M */\n    rc = (*tgt327d)(&pm) ;        /* execute GTTERM macro */\n    if (rc==0)      /* data returned OK ? */\n      {             /* yes - convert single byte numbers to int */\n        *primrow = pm.prim.c\u00dd0\u00a8 ;\n        *primcol = pm.prim.c\u00dd1\u00a8 ;\n        *altrow = pm.alt.c\u00dd0\u00a8 ;\n        *altcol = pm.alt.c\u00dd1\u00a8 ;\n        *attrs = pm.attr ;\n      }\n    unloadm(tgt327d) ;            /* unload ASM routine */\n    return rc ;                   /* return code from GTTERM */\n  }\n\n/*-------------------------------------------------------------------*/\n/* Clear 3270 screen.                                                */\n/*-------------------------------------------------------------------*/\nvoid clear()\n  {\n    int rc ;\n    char sba\u00dd2\u00a8 ;\n    char out1\u00dd\u00a8 = {      /* set up for erase */\n      WRT, 0x40,\n      SBA, 0x5d, 0x7f,   /* end addr - overlayed later */\n      SBA, 0x40, 0x40,   /* start addr row=1 col=1 */\n      SBA, 0xe7, 0x7f,   /* insert cursor location, row/col max */\n      ICUR               /* insert cursor */\n      } ;\n    char out2\u00dd\u00a8 = {      /* erase write alternate */\n      EWA, 0xc2\n      } ;\n    char out3\u00dd\u00a8 = {      /* erase primary */\n      WRT, 0xc2\n      } ;\n\n    /* set max screen size known so far sba */\n    rc2sba(sdcb.rows,sdcb.cols,sba) ;\n    out1\u00dd9\u00a8 = sba\u00dd0\u00a8 ;\n    out1\u00dd10\u00a8 = sba\u00dd1\u00a8 ;\n\n    rc = tputn(out1,sizeof(out1) ) ;   /* define the buffer */\n    rc = tputn(out2,sizeof(out2) ) ;   /* erase write alternate */\n    rc = tputn(out3,sizeof(out3) ) ;   /* erase write primary */\n  }\n\n/*-------------------------------------------------------------------*/\n/* Select the entire screen buffer using SBA based on the            */\n/* scrsize returned from GTTERM and EW/EWA to select the             */\n/* primary or alternate buffer.                                      */\n/* Then assemble a structured field query, and send it to the        */\n/* device using TPG which will cause the device to imediately        */\n/* send back the response without any user intervention.             */\n/* Then decode the read partition, query operations, query and       */\n/* put the interesting data in the sdcb structure.                   */\n/*-------------------------------------------------------------------*/\nint querydev()\n  {\n    short sflen ;      /* structured field length */\n    char  sfid ;       /* structured field ID */\n    char  qcode ;      /* query reply - query code */\n    char input\u00dd256\u00a8 ;  /* query buffer */\n    char *ibuf ;       /* current query buffer pointer */\n    int rc ;\n    char sba\u00dd2\u00a8 ;\n\n    char out1\u00dd\u00a8 = {      /* set up for erase */\n      WRT, 0x40,\n      SBA, 0x5d, 0x7f,   /* end addr - overlayed later, rc= 24,80 */\n      SBA, 0x40, 0x40,   /* start addr row=1 col=1 */\n      SBA, 0xe7, 0x7f,   /* insert cursor loc, rc= 32,80 *OVERLAYED**/\n      ICUR               /* insert cursor */\n      } ;\n\n    char out2\u00dd\u00a8 = {      /* erase write alternate */\n      EWA, 0xc2\n      } ;\n\n    char out3\u00dd\u00a8 = {      /* erase primary */\n      WRT, 0xc2\n      } ;\n\n    char out4\u00dd\u00a8 = {\n      WSF,               /* write structured field */\n      0x00, 0x05,        /* structured field length */\n      0x01,              /* read partition */\n      0xFF,              /* query operations */\n      0x02               /* query */\n      } ;\n\n    /* set max screen size known so far sba */\n    rc2sba(sdcb.rows,sdcb.cols,sba) ;\n    out1\u00dd9\u00a8 = sba\u00dd0\u00a8 ;\n    out1\u00dd10\u00a8 = sba\u00dd1\u00a8 ;\n\n    fill(input,0x00,sizeof(input)) ;   /* zero input buffer */\n\n    rc = tputn(out1,sizeof(out1) ) ;   /* define the buffer */\n    rc = tputn(out2,sizeof(out2) ) ;   /* erase write alternate */\n    rc = tputn(out3,sizeof(out3) ) ;   /* erase write primary */\n    rc = tpgn(out4,sizeof(out4) ) ;    /* query the device */\n    rc = tgetn(input,sizeof(input)) ;  /* receive device resp.*/\n\n    ibuf = input ;       /* point at input */\n\n    if (*input==0x88)    /* check for 88 AID byte */\n      {\n        ibuf = ibuf+1 ;         /* advance to 1st structured field */\n        sfid = *(ibuf+2) ;      /* sfid should be 0x81 */\n\n        while (sfid==0x81)  /* while structured fields remain */\n          {\n            sflen = *((short *)ibuf) ;  /* get structured field len */\n            if (sflen==0)           /* bad error - should not happen */\n              {\n                printf(\"Error: Structured field length zero at %p\\n\",\n                  ibuf) ;\n                dumpchar(input,sizeof(input)) ;\n                return 1 ;\n              }\n            qcode = *(ibuf+3) ;     /* get query code */\n            switch (qcode)\n              {\n                case 0x80:           /* Q-code summary */\n                  rc = dsummary(ibuf,sflen) ;\n                  break ;\n                case 0x81:           /* Usable area */\n                  rc = darea(ibuf,sflen) ;\n                  break ;\n                case 0x85:           /* Character sets */\n                  rc = dcharset(ibuf,sflen) ;\n                  break ;\n                case 0x86:           /* Color */\n                  rc = dcolor(ibuf,sflen) ;\n                  break ;\n                case 0x87:           /* Highlighting */\n                  rc = dhilite(ibuf,sflen) ;\n                  break ;\n                case 0x88:           /* Modes */\n                  rc = dmodes(ibuf,sflen) ;\n                  break ;\n                case 0xa6:           /* Implicit partition */\n                  rc = dimpart(ibuf,sflen) ;\n                  break ;\n                default:\n                  break ;\n              }  /* of switch */\n            ibuf = ibuf+sflen ; /* advance to next structured field */\n            sfid = *(ibuf+2) ;  /* sfid should be 0x81 - else stop */\n\n          } /* of while sfid=81 */\n\n      } /* of AID=88 */\n    return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x80: Qcode summary                                               */\n/*-------------------------------------------------------------------*/\nint dsummary(char *buf, short buflen)\n  {\n     int i ;\n     char qcode ;\n\n     for (i=4;i<buflen;i++)\n       {\n          qcode = *(buf+i) ;     /* get query code */\n          if (qcode == 0xb4)\n            sdcb.graflg = 1 ;    /* indicate graphic support */\n       }  /* of for i=4 */\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x81: Usable area                                                 */\n/*-------------------------------------------------------------------*/\nint darea(char *buf, short buflen)\n  {\n     char celunits\u00dd6\u00a8 ;   /* screen size unit PEL or CELL */\n     short w, h ;         /* screen size w=width h=height */\n     char aw, ah ;        /* units per cell aw=width ah=height */\n     float xr, xrd, yr, yrd ;  /* pel spacing ratio */\n     float fw, fh ;       /* ratio - pels per unit */\n\n     if ((*(buf+4) & 0x03)==0x03)\n       sdcb.adrmode = 16 ;\n     else if ((*(buf+4) & 0x01)==0x01)\n       sdcb.adrmode = 12 ;\n\n     w = *((short *)(buf+6)) ;   /* width of usable area */\n     h = *((short *)(buf+8)) ;   /* height of usable area */\n\n     if (*(buf+10) == 0x01)    /* pels/in or pels/mm */\n       sdcb.unit = 1 ;  /* units are mm */\n     else\n       sdcb.unit = 0 ;  /* units are inch */\n\n     xr = *((short *)(buf+11)) ;    /* x dim pel ratio numerator */\n     xrd = *((short *)(buf+13)) ;   /* x dim pel ratio denominator */\n     yr = *((short *)(buf+15)) ;    /* y dim pel ratio numerator */\n     yrd = *((short *)(buf+17)) ;   /* y dim pel ratio denominator */\n\n     fw = (float)(xr) / (float)(xrd) ; /* horiz. ratio pels per unit */\n     fh = (float)(yr) / (float)(yrd) ; /* vert. ratio pels per unit */\n\n     aw = *(buf+19) ;    /* number of X units in default cell */\n     ah = *(buf+20) ;    /* number of Y units in default cell */\n\n     if (*(buf+5) & 0x20)       /* byte 5 bit 3 on unit=pels */\n       strcpy(celunits,\"pels\") ;\n     else                       /* other wise unit=cells */\n       strcpy(celunits,\"cells\") ;\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x85: Character sets                                              */\n/*-------------------------------------------------------------------*/\nint dcharset(char *buf, short buflen)\n  {\n     int i, j ;         /* counters */\n     int cgcsgid ;      /* Coded graphic character set identifier */\n     short ccsid ;      /* Coded character set identifier */\n     char gf = 0 ;      /* CGCSGID not present flag */\n     char ch2 = 0 ;     /* Two byte char. set flag */\n     char ms = 0 ;      /* Multiple slot sizes flag */\n     char cf = 0 ;      /* CCSID not present flag */\n     char sdw ;         /* Default character slot width */\n     char sdh ;         /* Default character slot height */\n     char dl ;          /* character set descriptor (CSD) length */\n     char *csd ;        /* character set descriptor (CSD) ptr */\n     char set ;         /* character set ID (PS store no.) */\n     char lcid ;        /* character set Local ID (alias) */\n     char sw ;          /* character set slot width */\n     char sh ;          /* character set slot height */\n     char ssubsn ;      /* character set starting subsection */\n     char esubsn ;      /* character set ending subsection */\n\n     if (*(buf+4) & 0x10)\n       sdcb.psflg = 1 ;   /* load PS Extended supported */\n     else\n       sdcb.psflg = 0 ;   /* load PS Extended not supported */\n\n     if (*(buf+4) & 0x08)\n       ms = 1 ;   /* More than one size character slot supported */\n\n     if (*(buf+4) & 0x04)\n       ch2 = 1 ;  /* Two byte code character sets are supported */\n\n     if (*(buf+4) & 0x02)\n       gf = 1 ;   /* CGCSGID present */\n\n     if (*(buf+5) & 0x20)\n       cf = 1 ;   /* CCSID present */\n\n     sdw = *(buf+6) ;\n     sdh = *(buf+7) ;\n\n     dl = *(buf+12) ;   /* get CSD length */\n     i = 13 ;\n     while (i<buflen)\n       {\n         csd = buf + i ;  /* point at CSD to process */\n         set = *csd ;     /* get character set ID (PS store no.) */\n         if (*(csd+1) & 0x80)\n           sdcb.loadflg = 1 ;  /* loadable symbol sets exist */\n\n         if (*(csd+1) & 0x40)\n           sdcb.triflg = 1 ;   /* Triple-plane character sets exist */\n\n         if (*(csd+1) & 0x20)\n           sdcb.dbcsflg = 1 ;  /* Double-byte coded character sets */\n\n         lcid = *(csd+2) ;   /* get character set ID (PS store no.) */\n\n         j = 0 ;\n         if (ms)\n           {\n             sw = *(csd+3) ;  /* slot width */\n             sh = *(csd+4) ;  /* slot height */\n             j = j + 2 ;\n           }\n\n         if (ch2)\n           {\n             ssubsn = *(csd+j+3) ;  /* starting sub-section */\n             esubsn = *(csd+j+4) ; /* ending sub-section */\n             j = j + 2 ;\n           }\n\n         if (gf)\n           {\n             cgcsgid = *((int *)(csd+j+3)) ;  /* Graf char set ID */\n             if (cgcsgid==0x03c30136)\n               sdcb.aplflg = lcid ;   /* APL supported store lcid */\n             j = j + 4 ;\n           }\n\n         if (cf)\n           {\n             ccsid = *((short *)(csd+j+3)) ;  /* char set ID */\n           }\n\n         i = i + dl ;  /* get pos of next CSD */\n       }  /* of while i<buflen */\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x86: Colors                                                      */\n/*-------------------------------------------------------------------*/\nint dcolor(char *buf, short buflen)\n  {\n     int colora = 0 ; /* number of actual colors on device */\n     int icolor ;     /* color index */\n     int i, j = 0 ;   /* counter */\n     char attr ;      /* color attribute accepted by device */\n     char dcolor ;    /* color displayed for this attribute */\n\n     sdcb.colors = (int)*(buf+5) ; /* number of colors accepted */\n     for (i=6;i<buflen;i=i+2)\n       {\n         attr = *(buf+i) ;        /* attribute used by appl. */\n         sdcb.colorlst\u00ddj++\u00a8 = attr ;\n         dcolor = *(buf+i+1) ;    /* attr/color used by device */\n         icolor = (int)(dcolor - 0xf0) ;\n         if ((icolor >= 0) && (icolor <= 15))\n           colora++ ;\n       }\n     sdcb.colora = colora ;  /* number of actual colors on device */\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x87: Highlighting                                                */\n/*-------------------------------------------------------------------*/\nint dhilite(char *buf, short buflen)\n  {\n     int i, j = 0 ;    /* counter */\n     char attr ;       /* color attribute accepted by device */\n     char dhilite ;    /* color displayed for this attribute */\n\n     sdcb.hilites = (int)*(buf+4) ;\n     for (i=5;i<buflen;i=i+2)\n       {\n         attr = *(buf+i) ;        /* attribute used by appl. */\n         dhilite = *(buf+i+1) ;   /* attr/highlight used by device */\n         sdcb.hilitlst\u00ddj++\u00a8 = attr ;\n       }\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x88: Modes                                                       */\n/*-------------------------------------------------------------------*/\nint dmodes(char *buf, short buflen)\n  {\n     int i ;           /* counter */\n     char mode ;       /* device opperation mode */\n\n     for (i=4;i<buflen;i++)\n       {\n         mode = *(buf+i) ;        /* attribute used by appl. */\n         if ((mode==0x01) ||\n             (mode==0x02))\n           sdcb.edsflg = 1 ;  /* queryable device can use extended DS*/\n       }   /* of for i */\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0xa6: Implicit partition                                          */\n/*-------------------------------------------------------------------*/\nint dimpart(char *buf, short buflen)\n  {\n     char *sdp ;                /* self defining parameter (SDP) ptr */\n     short wd, wa, hd, ha ;     /* screen dimensions */\n     short wcd, wca, hcd, hca ; /* cell sizes */\n     int i ;                    /* counter */\n\n     i = 6 ;        /* length of header */\n     while(i < buflen)   /* loop over all SDPs */\n       {\n         sdp = buf + i ;\n         if (*sdp==0x0b)    /* is it a SDP ? */\n           {\n             if (*(sdp+1)==0x01)\n               {\n                 wd = *((short *)(sdp+3)) ;  /* default width */\n                 hd = *((short *)(sdp+5)) ;  /* default height */\n                 wa = *((short *)(sdp+7)) ;  /* alternate width */\n                 ha = *((short *)(sdp+9)) ;  /* alternate height */\n                 if ((ha>hd) || (wa>wd))\n                   {\n                     sdcb.altflg = 1 ;    /* use alternate device */\n                     sdcb.rows = ha ;     /* use alternate rows */\n                     sdcb.cols = wa ;     /* use alternate cols */\n                   }\n                 else\n                   {\n                     sdcb.rows = hd ;     /* use primary rows */\n                     sdcb.cols = wd ;     /* use primary cols */\n                   }\n                 i = i + 11 ;     /* add length of this SDP */\n               }\n             else if (*(sdp+1)==0x03)\n               {\n                 i = i + 11 ;     /* add length of this SDP */\n               }\n             else if (*(sdp+1)==0x02)\n               {\n                 wcd = *((short *)(sdp+3)) ;  /* default cell width */\n                 hcd = *((short *)(sdp+5)) ;  /* default cell height */\n                 wca = *((short *)(sdp+7)) ;  /* alternate cell width */\n                 hca = *((short *)(sdp+9)) ;  /* alternate cell height*/\n                 if (sdcb.altflg)         /* using alternate device */\n                   {\n                     sdcb.celheigh = hca ; /* use alt. cell height */\n                     sdcb.celwidth = wca ; /* use alt. cell width */\n                   }\n                 else\n                   {\n                     sdcb.celheigh = hcd ; /* use primary cell height */\n                     sdcb.celwidth = wcd ; /* use primary cols width */\n                   }\n                 i = i + 11 ;     /* add length of this SDP */\n               }\n           }\n       }  /* of while */\n\n     return 0 ;\n  }\n\n\n\n\n/*********************************************************************/\n/* General string handling routines for varying length strings.      */\n/*   lstran(mod_lstr,fromchar,tochar)                                */\n/*   lstrload(to_lstr,fromchar,len)                                  */\n/*   lstrunld(tochar,from_lstr)                                      */\n/*   lstrcopy(to_lstr,from_lstr)                                     */\n/*   lstrnew(to,fromchars)                                           */\n/*   lstrsub(to_lstr,from_lstr,start,length)                         */\n/*   len = lstrlen(haystack_lstr)                                    */\n/*   pos = lstrindex(haystack_lstr,needle_lstr)                      */\n/*   lstrfill(to_lstr,fillchars)                                     */\n/*   rc = lstrcmpc(cmp_lstr,cmpchars)                                */\n/*   lstrdel(del-lstr)                                               */\n/*   lstrrep(to_lstr,repchars,copies)                                */\n/*   lstrcat(to_lstr,left_lstr,right_lstr)                           */\n/*********************************************************************/\n\n/*-------------------------------------------------------------------*/\n/* Translate a character in an lstr to another character.            */\n/*-------------------------------------------------------------------*/\nvoid lstran(TLSTR *in, char from, char to)\n{\n  int i ;      /* temp counter */\n\n  if (in)      /* from string exists ? */\n    {\n      for (i=0;i<=in->len;i++)\n        {\n          if (*(in->data+i) == from)\n            *(in->data+i) = to ;\n        }\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Get the length of an lstr.                                        */\n/*-------------------------------------------------------------------*/\nint lstrlen(TLSTR *in)\n{\n  if (in)      /* from string exists ? */\n    {\n      return in->len ;\n    }\n  else\n    return 0 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Unload varying length string contents into character buffer.      */\n/*-------------------------------------------------------------------*/\nint lstrunld(char *to,\n             TLSTR *from)\n{\n  if (from)      /* from string exists ? */\n    {\n      memcpy(to,from->data,from->len) ;\n      return from->len ;\n    }\n  else\n    return 0 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Load varying length string with contents of character buffer.     */\n/*-------------------------------------------------------------------*/\nvoid lstrload(TLSTR *to,\n              char *from,\n              int len)\n{\n  if (to)      /* to string exists ? */\n    {\n      if (len!=to->len)\n        {\n          free((char *)to->data) ;\n          to->data = (char *)malloc(len) ;\n          if (!to->data) serror(4,\"Not enough memory\") ;\n          to->len = len ;\n        }\n      memcpy(to->data,from,len) ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Copy varying length string.                                       */\n/*-------------------------------------------------------------------*/\nvoid lstrcopy(TLSTR *to,\n              TLSTR *from)\n{\n  if (from)      /* from string exists ? */\n    {\n      if (!to)    /* to string does not exist */\n        serror(2,\"String does not exist\") ;\n      else     /* to string exists */\n        {\n          if (from->len > 0)\n            {\n              if (to->data == NULL)     /* does not exist yet ? */\n                {\n                  to->data = (char *)malloc(from->len) ;\n                  if (!to->data) serror(14,\"Not enough memory\") ;\n                }\n              else if (from->len != to->len)   /* increase length ? */\n                {\n                  free((char *)to->data) ;\n                  to->data = (char *)malloc(from->len) ;\n                  if (!to->data) serror(4,\"Not enough memory\") ;\n                }\n              to->len = from->len ;\n              memcpy(to->data,from->data,from->len) ;\n            }\n          else\n            {\n              if (to->len > 0)   /* empty data */\n                free((char *)to->data) ;\n              to->len = 0 ;\n              to->data = NULL ;\n            }\n        }\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Initialize a varying length string with a string.                 */\n/*-------------------------------------------------------------------*/\nvoid lstrnew(TLSTR *newstr,\n             char *from)\n{\n  int i ;\n\n  if (!newstr)\n    serror(5,\"String does not exist\") ;\n  else\n    {\n      i = strlen(from) ;\n      if (i > 0)\n        {\n          newstr->data = (char *)malloc(i) ;\n          if (!newstr->data) serror(17,\"Not enough memory\") ;\n          newstr->len = i ;\n          memcpy(newstr->data,from,i) ;\n        }\n      else\n        {\n          newstr->len = 0 ;\n          newstr->data = NULL ;\n        }\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Create substring of a varying length string to a varying length   */\n/* string.                                                           */\n/*-------------------------------------------------------------------*/\nvoid lstrsub(TLSTR *to,\n             TLSTR *from,\n             int start,\n             int len)\n{\n  int i ;\n\n  if (start <= from->len)\n    {\n      i = from->len - start ;\n      if (len < i)\n        i = len ;       /* i is the length of the sub string */\n\n      if (!to)\n        serror(8,\"String does not exist\") ;\n      else\n        {\n          if (i > 0)\n            {\n              if (to->data == NULL)     /* does not exist yet ? */\n                {\n                  to->data = (char *)malloc(i) ;\n                  if (!to->data) serror(20,\n                    \"Not enough memory\") ;\n                }\n              else if (to->len != i)          /* wrong size ? */\n                {\n                  free((char *)to->data) ;\n                  to->data = (char *)malloc(i) ;\n                  if (!to->data) serror(10,\n                    \"Not enough memory\") ;\n                }\n              to->len = i ;\n              memcpy(to->data,from->data+start,i) ;\n            }\n          else\n            {\n              if (to->len > 0)   /* empty data */\n                free((char *)to->data) ;\n              to->len = 0 ;\n              to->data = NULL ;\n            }\n        }\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Find the position in a varying length string of a varying length  */\n/* sub-string.                                                       */\n/*-------------------------------------------------------------------*/\nint lstrindx(TLSTR *haystack, /* string to search */\n             TLSTR *needle)   /* sub-string to search for */\n{\n  int i, j, k, endpos ;\n\n  endpos = haystack->len - needle->len ;\n  for (i=0; i<endpos; i++)\n    {\n      k = 0 ;\n      for (j=0; j<needle->len; j++)\n        {\n          if (haystack->data\u00ddi+j\u00a8 == needle->data\u00ddj\u00a8)\n            k ++ ;\n          else break ;\n        }\n      if (k==needle->len)\n        return(i+1) ;\n    }\n  return 0 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Compare a varying length string with a string.                    */\n/*   rc = 0  == strings same                                         */\n/*   rc = 1  == lstr has larger value than charstr                   */\n/*   rc = -1 == lstr has smaller value than charstr                  */\n/*-------------------------------------------------------------------*/\nint lstrcmpc(TLSTR *lstr,   /* string to compare */\n             char *cstr)    /* characters to compare with */\n{\n  int i ;               /* counter */\n  int t=0 ;             /* compare flag */\n  int l ;               /* compare length */\n  int ld=0 ;            /* length differ flag */\n  char *lstrptr ;\n  char *cstrptr ;\n\n  l = strlen(cstr) ;    /* determine shortest string */\n  if (l != lstr->len)   /* same lengths ? */\n    {                   /*   no .. */\n      ld = 1 ;          /*   flag lengths differ */\n      if (l > lstr->len)\n        l = lstr->len ; /*   use shortest length */\n    }\n\n  /* compare to shortest length */\n  lstrptr = lstr->data ;\n  cstrptr = cstr ;\n  for (i=0; i<l; i++)\n    {\n      if (*lstrptr > *cstrptr)\n        {\n          t = 1 ;    /* indicate left larger than right */\n          break ;    /* end scan now  */\n        }\n      if (*lstrptr < *cstrptr)\n        {\n          t = -1 ;   /* indicate left smaller than right */\n          break ;    /* end scan now  */\n        }\n      lstrptr++ ;\n      cstrptr++ ;\n    }\n\n  if ((t==0) && (ld==1)) /* same after shortest length compared ? */\n    {\n      if (strlen(cstr) > lstr->len)\n        t = -1 ;     /* lstr smaller */\n      else\n        t = 1 ;      /* lstr larger */\n    }\n  return t ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Fill a varying length string with a string.                       */\n/*-------------------------------------------------------------------*/\nvoid lstrfill(TLSTR *string,   /* string to fill */\n              char *fillstr)  /* filler characters to use */\n{\n  int i ;\n  char *strptr ;\n\n  strptr = fillstr ;\n  for (i=0; i<=string->len; i++)\n    {\n      string->data\u00ddi\u00a8 = *(strptr++) ;\n      if (*strptr=='\\0')\n        strptr = fillstr ;    /* start over on fill string */\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Delete a varying length string (free associated memory).          */\n/*-------------------------------------------------------------------*/\nvoid lstrdel(TLSTR *string)   /* string to delete */\n{\n  free((char *)string->data) ;\n  string->data = NULL ;\n  string->len = 0 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Create a varying length string with multiple copies of a string.  */\n/*-------------------------------------------------------------------*/\nvoid lstrrep(TLSTR *string,\n             char *repstr,\n             int copies)\n{\n  int repstrlen ;\n  char *strptr ;\n  int newlen ;\n  int i ;\n\n  /* The input string that replications are made from is assumed */\n  /* to have a length of one or longer.                          */\n\n  repstrlen = strlen(repstr) ;\n  if (repstrlen==0)  /* assume repitition of 0x00 */\n    repstrlen = 1 ;\n  newlen = repstrlen * copies ;\n  if (string->data==NULL)          /* alloc storage ? */\n    {\n      string->data = (char *)malloc(newlen) ;\n      if (!string->data) serror(21,\"Not enough memory\") ;\n    }\n  else if (string->len!=newlen)    /* alloc more/less storage ? */\n    {\n      free((char *)string->data) ;\n      string->data = (char *)malloc(newlen) ;\n      if (!string->data) serror(11,\"Not enough memory\") ;\n    }\n  string->len = newlen ;     /* alter string length */\n  strptr = repstr ;\n  for (i=0; i<newlen; i++)        /* replicate the repstr data */\n    {\n      string->data\u00ddi\u00a8 = *strptr++ ;\n      if (*strptr == '\\0')\n        strptr = repstr ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Concatenate two varying length strings together placing the       */\n/* in a varying length string.                                       */\n/*-------------------------------------------------------------------*/\nvoid lstrcat(TLSTR *result,   /* result of concatenation */\n             TLSTR *left,     /* left string to concatenate */\n             TLSTR *right)    /* right string to concatenate */\n{\n  char *rstr ;\n  int newlen ;\n\n  newlen = left->len + right->len ;    /* extend LSTR */\n  rstr = (char *)malloc(newlen) ;\n  if (!rstr) serror(12,\"Not enough memory\") ;\n\n  memcpy(rstr,left->data,left->len) ;   /* make new string */\n  memcpy(rstr+left->len,right->data,right->len) ;\n\n  free((char *)result->data) ;   /* assemble new LSTR */\n  result->data = rstr ;\n  result->len = newlen ;\n}\n\n\n/*********************************************************************/\n/* General sub routines.                                             */\n/*   fill(haystack,fillchar,number)                                  */\n/*   dumpchar(buffer,length)                                         */\n/*   overlay(buffer,bufferlen,overlay,overlaylen,overlaypos)         */\n/*********************************************************************/\n\n/*-------------------------------------------------------------------*/\n/* Fill a character string with a number of filler characters.       */\n/*-------------------------------------------------------------------*/\nvoid fill(char *haystack,   /* area to fill */\n          char filler,      /* fill characters */\n          int num)          /* number of repetitions */\n{\n  int i = 0 ;\n  for(i=0;i<=num;i++)\n    *haystack++ = filler ;\n  *haystack = '\\0' ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Dump the contents of a buffer, formatted in a way that makes a    */\n/* 3270 data stream easier to interpret.                             */\n/*-------------------------------------------------------------------*/\nvoid dumpchar(char *dat,    /* data to dump */\n              int len)      /* length to dump */\n{\n  char *cptr ;\n  char c ;\n  char cc\u00dd3\u00a8 ;\n  int i ;\n  int n, m ;\n\n  n = 0 ;\n  m = 0 ;\n  cptr = dat ;\n  do\n    {\n      printf(\"      %.8X \",dat) ;\n      for(i=1;i<=16;i++)\n        {                   /* 0 indicates all */\n          if (*dat=='\\0' && len==0)\n            break ;\n          if (n==len && len>0)\n            break ;\n          c = *dat++ ;\n          n++ ;\n          printf(\"%.2X\",c) ;\n          if ((i%4)==0)\n            printf(\" \") ;\n        }\n      printf(\"\\n               \") ;\n\n      for(i=1;i<=16;i++)\n        {\n          if (*cptr=='\\0' && len==0)\n            break ;\n          if (m==len && len>0)\n            break ;\n          c = *cptr++ ;\n          m++ ;\n          if (c <= 0x3f || c==0xff)\n            {\n              switch (c)\n                {\n                  case GE:   strcpy(cc,\"GE\") ;\n                    break ;\n                  case FF:   strcpy(cc,\"FF\") ;\n                    break ;\n                  case CRR:  strcpy(cc,\"CR\") ;\n                    break ;\n                  case SBA:  strcpy(cc,\"SB\") ;\n                    break ;\n                  case EUA:  strcpy(cc,\"EU\") ;\n                    break ;\n                  case ICUR: strcpy(cc,\"IC\") ;\n                    break ;\n                  case NL:   strcpy(cc,\"NL\") ;\n                    break ;\n                  case EM:   strcpy(cc,\"EM\") ;\n                    break ;\n                  case DUP:  strcpy(cc,\"DU\") ;\n                    break ;\n                  case SF:   strcpy(cc,\"SF\") ;\n                    break ;\n                  case FM:   strcpy(cc,\"FM\") ;\n                    break ;\n                  case SA:   strcpy(cc,\"SA\") ;\n                    break ;\n                  case SFE:  strcpy(cc,\"SX\") ;\n                    break ;\n                  case MF:   strcpy(cc,\"MF\") ;\n                    break ;\n                  case RA:   strcpy(cc,\"RA\") ;\n                    break ;\n                  case SUB:  strcpy(cc,\"SU\") ;\n                    break ;\n                  default:   strcpy(cc,\". \") ;\n                    break ;\n                }\n              printf(\"%s\",cc) ;\n            }\n          else\n            printf(\"%c \",c) ;\n          if ((i%4)==0)\n            printf(\" \") ;\n        }\n      printf(\"\\n\") ;\n    }\n  while( ((*dat!='\\0') && (len==0)) ||\n         ((m!=len) && (len>20))\n       ) ;\n  printf(\"\\n\") ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Overlay characterc in a buffer.                                   */\n/*-------------------------------------------------------------------*/\nvoid overlay(char *haystack,    /* area to overlay */\n             int haylen,        /* length to overlay */\n             char *needle,      /* overlay characters */\n             int len,           /* length of overlay */\n             int pos)           /* start postition of overlay */\n{\n  int hlen, nlen ;   /* length of haystack and needle */\n  int i = 0 ;        /* itterator */\n\n  if (haylen==0)\n    hlen = strlen(haystack) ;\n  else\n    hlen = haylen ;\n\n  if (len==0)\n    nlen = strlen(needle) ;\n  else\n    nlen = len ;\n\n  if (hlen>(nlen+pos))\n    {\n      haystack = haystack+pos ;    /* move to overlay pos */\n      for(i=0;i<nlen;i++)          /* copy the data */\n        *haystack++ = *needle++ ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* General error message routine.                                    */\n/*-------------------------------------------------------------------*/\nvoid serror(int errno,\n            char *msg)\n{\n  printf(\"Error: %d - %s\\n\",errno,msg) ;\n  abort() ;\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "WIDGET32": {"ttr": 11784, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x011\\x00\\x00\\x00\\x95%o\\x00\\x95(o\\x17\\x04\\x0b\\xfb\\n\\xd3\\x00\\x00\\xe2\\xc1\\xe2\\xc4\\xc4\\xc6@@@@'", "ispf": {"version": "01.49", "flags": 0, "createdate": "1995-09-13T00:00:00", "modifydate": "1995-10-13T17:04:00", "lines": 3067, "newlines": 2771, "modlines": 0, "user": "SASDDF"}, "text": "#pragma eject\n#pragma title widget32.c - display widgets on a 3270 device\n\n/*+-----------------------------------------------------------------+\n  | Program:   widget32.c                                           |\n  | Language:  c                                                    |\n  | Support:   DAF                                                  |\n  | Purpose:   To learn some full screen 3270 coding techniques to  |\n  |            use on the IBM 3270 display station.                 |\n  |                                                                 |\n  |            The following publications have been used in the     |\n  |            developement of this program:                        |\n  |              SC28-1875 TSO/E v2 programming Services            |\n  |              GA23-0059 3270 Info. Display Sys. Data Stream      |\n  |                        Programmers Reference.                   |\n  |              GA27-3831 3174 Establishment Controller Character  |\n  |                        Set Reference.                           |\n  |              GA27-2837 3270 Character Set Reference.            |\n  |              HUR 9058  IBM3270 Personal Computer Graphics       |\n  |                        Control Program Data Stream Reference.   |\n  |              GA18-2589 IBM 3179-G/3192-G Color Graphics Display |\n  |                        Station Description.                     |\n  |              GG27-6999 Introduction to Programming the IBM 3270.|\n  |                                                                 |\n  |            This programs main routine creates a simple notepad  |\n  |            window on the 3270. It uses routines to build the    |\n  |            notepad that support the creation, modification,     |\n  |            removal, and display of fields on the 3270 screen.   |\n  |            A screen is represented as linked list of fields.    |\n  |            These field routines can be viewed as an API that    |\n  |            the main program (application) uses to create windows|\n  |            on the 3270. The application is freed from managing  |\n  |            things like buffer address translation, and data     |\n  |            stream creation, and inbound data stream parsing.    |\n  |            Varying length strings are represented by the data   |\n  |            type LSTR. These strings can contain amy amount of   |\n  |            data including the null character.                   |\n  |                                                                 |\n  |            The following techniques have not been implemented   |\n  |            in this program but will be added later:             |\n  |            - Data stream compression using RBA.                 |\n  |            - Graphics support.                                  |\n  |                                                                 |\n  | Notes:     1. Numeric fields do not work the same on all        |\n  |               devices. The 3192-G allows lowercase character    |\n  |               input. Many devices also upper case character     |\n  |               input.                                            |\n  |            2. Most devices do not support field attributes:     |\n  |               Field Outlining, Background color, and Field      |\n  |               Validation.                                       |\n  |            3. The character set for APL does not appear to be   |\n  |               allowed on the SFE order, only on the SA order.   |\n  | End.                                                            |\n  +-----------------------------------------------------------------+*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <svc.h>\n#include <tput.h>\n#include <ostask.h>\n\n#define _AMODE31\n\n#include \"ps9x16u.inc\"\n#include \"ps9x15u.inc\"\n#include \"ps9x12u.inc\"\n\n/* escape character and device commands */\n#define ESC     0x27\n#define EW      0xf5\n#define EWA     0x7e\n#define WRT     0xf1\n#define WSF     0xf3\n#define RB      0xf2\n\n/* write control characters, or'd together as required */\n#define WCCMDT  0x01\n#define WCCKBD  0x02\n#define WCCRES  0xc0\n#define WCCBEL  0x04\n\n/* 3270 data stream orders */\n#define GE      0x08\n#define FF      0x0c\n#define CRR     0x0d\n#define SBA     0x11\n#define EUA     0x12\n#define ICUR    0x13\n#define NL      0x15\n#define EM      0x19\n#define DUP     0x1c\n#define SF      0x1d\n#define FM      0x1e\n#define SA      0x28\n#define SFE     0x29\n#define MF      0x2c\n#define RA      0x3c\n#define SUB     0x3f\n\n#define PROT    0x20\n#define NUM     0x10\n\n/* Type byte of the SA, SFE and MF orders */\n#define ALL     0x00\n#define NONE    0x00\n#define DFLT    0x00\n\n#define ATTR    0xc0\n#define FVALID  0xc1\n#define OUTLIN  0xc2\n#define HILITE  0x41\n#define COLOR   0x42\n#define SYMSET  0x43\n#define BAKCOL  0x45\n#define TRANSP  0x46\n\n#define APL     0xF1\n\n/* Out lines for the value byte of the SA, SFE, or MF order */\n#define UNDR    0x01\n#define OVR     0x04\n#define OVRUND  0x05\n#define NOOVR   0x0b\n#define NOUNDR  0x0e\n#define RECT    0x0f\n\n/* Hilites for the value byte of the SA, SFE, or MF order */\n#define BLINK   0xf1\n#define RVIDEO  0xf2\n#define USCORE  0xf4\n\n/* Colors for the value byte of the SA, SFE, or MF order */\n#define BLUE    0xf1\n#define RED     0xf2\n#define PINK    0xf3\n#define GREEN   0xf4\n#define TURQ    0xf5\n#define CYAN    0xf5\n#define YELLOW  0xf6\n#define WHITE   0xf7\n\n/* Attribute for the value byte of the SF, SFE and MF order */\n#define UNPRT   0x40\n#define UNNUM   0x50\n#define UNNUMHI 0xd8\n#define UNNON   0x4c\n#define UNHI    0xc8\n#define PRT     0x60\n#define PRTHI   0xe4\n#define PRTAS   0xf0\n#define PRTHIAS 0xf8\n\n/* Attention Identification (AID) Values */\n#define NOAID   0x60\n#define NOAIDP  0xe8\n#define STRFLD  0x88\n#define ENTER   0x7d\n#define PF1     0xf1\n#define PF2     0xf2\n#define PF3     0xf3\n#define PF4     0xf4\n#define PF5     0xf5\n#define PF6     0xf6\n#define PF7     0xf7\n#define PF8     0xf8\n#define PF9     0xf9\n#define PF10    0x7a\n#define PF11    0x7b\n#define PF12    0x7c\n#define PF13    0xc1\n#define PF14    0xc2\n#define PF15    0xc3\n#define PF16    0xc4\n#define PF17    0xc5\n#define PF18    0xc6\n#define PF19    0xc7\n#define PF20    0xc8\n#define PF21    0xc9\n#define PF22    0x4a\n#define PF23    0x4b\n#define PF24    0x4c\n#define OID     0xe6\n#define MAG     0xe7\n#define PEN     0x7e\n#define PA1     0x6c\n#define PA2     0x6e\n#define PA3     0x6b\n#define CLEAR   0x6d\n#define SYSREQ  0xf0\n\ntypedef\n  struct LSTR     /* string with length */\n  {\n    int len ;             /* current length of data */\n    char *data ;          /* pointer to data */\n  } TLSTR ;\n\ntypedef\n  struct SFLD     /* 3270 screen field information list entry */\n  {\n    int fid ;             /* unique field identifier */\n    TLSTR fdata ;         /* field data (input or output) */\n    int fxpos ;           /* X column position */\n    int fypos ;           /* Y row position */\n    char fattr ;          /* 3270 field attribute */\n    char fcolor ;         /* 3270 color attribute */\n    char fhilite ;        /* 3270 hilite attribute */\n    char symbol ;         /* 0x00=normal 0xf1=APL else 0x40-0xef=PS */\n    struct SFLD *next ;   /* next list entry */\n  } TSFLD ;\n\n#define BUFFMAX 5000\nchar *buffer ;    /* buffer area for tput/tget */\n\nTSFLD *screen ;   /* root of 3270 screen field list */\n\n#define SFIDMAX 256\nTSFLD *sfidtab\u00ddSFIDMAX\u00a8 ; /* field id address table */\nint fidnext = 0 ;         /* next field id number to assign */\nint curcol = 1 ;          /* current cursor column */\nint currow = 1 ;          /* current cursor row */\nint bellflg = 0 ;         /* ring bell on next display */\nint iotrace = 0 ;         /* trace terminal I/O flag */\n\n\nstruct DCB        /* Device control block */\n  {\n    int model ;         /* model number ie: 3279, 3278, 3277 */\n    int type ;          /* model type ie: 2, 3, 4, 5 */\n    int rows ;          /* number of rows (height) on device */\n    int cols ;          /* number of columns (width) on device */\n    int celheigh ;      /* cell height on device */\n    int celwidth ;      /* cell width on device */\n    int colors ;        /* number of colors on device */\n    int colora ;        /* number of actual colors on device */\n    int hilites ;       /* number of colors on device */\n    int adrmode ;       /* device addressing mode: 12 or 14 or 16 bit*/\n    char unit ;         /* 0 = inch 1 = mm */\n    char edsflg ;       /* extended data stream flag */\n    char psflg ;        /* program symbols on device flag */\n    char altflg ;       /* use alternate flag */\n    char aplflg ;       /* 0 or apl's lcid=supports APL on device */\n    char graflg ;       /* graphics device flag */\n    char loadflg ;      /* loadable symbol sets supported flag */\n    char triflg ;       /* triple plane symbol sets supported flag */\n    char dbcsflg ;      /* double byte characters supported flag */\n    char colorlst\u00dd17\u00a8 ; /* list of color attributes on device */\n    char hilitlst\u00dd5\u00a8 ;  /* list of hilite attributes on device */\n    char modname\u00dd11\u00a8 ;  /* name of device ie: IBM32793B IBM3179G ..*/\n  } sdcb ;\n\n\n\n/*-------------------------------------------------------------------*/\n/* Function Prototypes                                               */\n/*-------------------------------------------------------------------*/\n\n/* field handling */\nint initscr() ;\nvoid termscr() ;\nchar dspflds() ;\nint insfld(TLSTR *, int, int, char, char, char) ;\nint getdev() ;\nint remflds() ;\nint delfld(int) ;\nint erasefld(int) ;\nint getfld(int, TLSTR *) ;\nint modfld(int, TLSTR *) ;\nint setfld(int, int, char) ;\nvoid dumpfld() ;\n/* 3270 support */\nint tputn(char *, int) ;\nint tgetn(char *, int) ;\nint tpgn(char *, int) ;\nvoid rc2sba(int, int, char *) ;\nvoid sba2rc(char *, int *, int *, int) ;\nint modsym(char *, char) ;\nint modcolor(char *, char) ;\nint modhilit(char *, char) ;\nint modattr(char *, char) ;\nint getterm(int *, int *, int *, int *, int *) ;\nint querydev() ;\nint dsummary(char *, short) ;\nint darea(char *, short) ;\nint dcharset(char *, short) ;\nint dcolor(char *, short) ;\nint dhilite(char *, short) ;\nint dmodes(char *, short) ;\nint dimpart(char *, short) ;\nint loadps1() ;\nvoid termstat() ;\nvoid clear() ;\n/* varying length string */\nvoid lstran(TLSTR *, char, char) ;\nint lstrlen(TLSTR *) ;\nvoid lstrload(TLSTR *, char *, int) ;\nint lstrunld(char *, TLSTR *) ;\nvoid lstrcopy(TLSTR *, TLSTR *) ;\nvoid lstrnew(TLSTR *, char *) ;\nvoid lstrsub(TLSTR *, TLSTR *, int, int) ;\nint lstrindx(TLSTR *, TLSTR *) ;\nvoid lstrfill(TLSTR *, char *) ;\nint lstrcmpc(TLSTR *, char *) ;\nvoid lstrdel(TLSTR *) ;\nvoid lstrrep(TLSTR *, char *, int) ;\nvoid lstrcat(TLSTR *, TLSTR *, TLSTR *) ;\n/* utility */\nvoid fill(char *, char, int) ;\nvoid dumpchar(char *, int) ;\nvoid overlay(char *, int, char *, int, int) ;\nvoid serror(int, char *) ;\n\n\n/* application routines */\nvoid buildwin() ;\nvoid dispwin() ;\nvoid winmsg(char *) ;\n\n/* variables for application */\nint cmdfid ;       /* field identifier for command line */\nint msgfid ;       /* field identifier for message line */\nint bt ;           /* top border */\nint bb ;           /* bottom border */\nint bl ;           /* left border */\nint br ;           /* right border */\nint cmdflg = 0 ;   /* command flag = true if command done */\n\n /*-----------------------------------------------------------------*\n  | Main Program                                                    |\n  *-----------------------------------------------------------------*/\nvoid main(int argc, char **argv, char **envp)\n  {\n    int rc ;        /* return code */\n\n    rc = initscr() ;  /* initialise environment */\n    if (rc==0)         /* if env OK */\n      {\n        /* initial border positions */\n        bt = 1 ;            /* top border */\n        bb = sdcb.rows ;    /* bottom border */\n        bl = 1 ;            /* left border */\n        br = sdcb.cols ;    /* right border */\n\n        /* indicate cursor on command field and set field to blank */\n        cmdflg = 1 ;\n\n        buildwin() ;  /* build the initial display window */\n        dispwin() ;   /* display the window and run appl. */\n\n        termscr() ;   /* terminate environment */\n      }\n  }\n\n\n/*-------------------------------------------------------------------*/\n/* Build a window with a title, command line and an edit space.      */\n/*-------------------------------------------------------------------*/\nvoid buildwin()\n  {\n    int t, tl ;                /* temp */\n    int i ;                    /* counter */\n    int fid ;                  /* field identifier handle */\n    TLSTR data, data1, data2, data3, data4 ; /* temp varying strings */\n    TLSTR title ;              /* title string */\n\n    /* create title line */\n    lstrnew(&title,\" WIDGET32: 3270 Widget test\");\n\n    /* create command line (prompt, input area, and help) */\n    lstrnew(&data,\"Command ===>\") ;   /* create VLstring */\n    fid = insfld(&data,bt+1,bl+2,PRT,WHITE,NONE);\n    if (fid<0) serror(81,\"Field insert failed\") ;\n    lstrnew(&data,\" \") ;   /* create VLstring */\n    cmdfid = insfld(&data,bt+1,bl+15,UNPRT,GREEN,NONE);\n    if (cmdfid<0) serror(81,\"Field insert failed\") ;\n    if ((br-bl)>18)\n      {\n        lstrnew(&data,\"PF1=Help PF3=End\") ;   /* create VLstring */\n        fid = insfld(&data,bt+1,br-18,PRT,WHITE,NONE);\n        if (fid<0) serror(81,\"Field insert failed\") ;\n      }\n\n    /* create message line */\n    lstrnew(&data,\" \") ;   /* create VLstring */\n    msgfid = insfld(&data,bt+2,bl+2,PRTHI,RED,NONE);\n    if (msgfid<0) serror(81,\"Field insert failed\") ;\n\n    /*----------------------------------------------------------------*/\n    /* Create top window border                                       */\n    /*   The border outline is drawn with different characters        */\n    /*     based on the devices abilities.                            */\n    /*   Window border locations are based on four global variables:  */\n    /*     bt - top border row                                        */\n    /*     bb - bottom border row                                     */\n    /*     br - right border column                                   */\n    /*     bl - left border column                                    */\n    /*----------------------------------------------------------------*/\n    if (sdcb.loadflg)\n      {\n        lstrnew(&data1,\"\\x42\\x47\") ;     /* top left corner */\n        lstrnew(&data2,\"\\x48\\x46\\x45\\x44\") ; /* top right corner */\n        lstrnew(&data3,\" \") ;\n        lstran(&title,0x40,0x48) ;      /* translate in PS blank char */\n        tl = lstrlen(&title) ; /* actual title length */\n        t = br-bl-5 ;           /* available space */\n        if (tl>t)\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrsub(&data3,&title,1,t-1) ; /* shorten title */\n            lstrcat(&data,&data,&data3) ;  /* add title */\n            lstrcat(&data,&data,&data2) ;  /* add right border */\n          }\n        else\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrcat(&data,&data,&title) ;  /* add title */\n            lstrrep(&data3,\"\\x48\",t-tl-1) ;/* repeat char to string */\n            lstrcat(&data,&data,&data3) ;  /* add top border chars */\n            lstrcat(&data,&data,&data2) ;  /* concat strings */\n          }\n        fid = insfld(&data,bt,bl,PRTAS,BLUE,NONE);\n        if (fid<0) serror(81,\"Field insert failed\") ;\n        setfld(fid,SYMSET,0x40) ;   /* make it id of PS symbols */\n      }\n    else if (sdcb.aplflg)\n      {\n        lstrnew(&data1,\"\\xc5\\xee\") ;     /* top left corner */\n        lstrnew(&data2,\"\\xa2\\xba\\xbb\\xd5\") ;   /* top right corner */\n        tl = lstrlen(&title) ; /* actual title length */\n        t = br-bl-5 ;           /* available space */\n        if (tl>t)\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrsub(&data4,&title,1,t-1) ; /* shorten title */\n            lstrnew(&data3,\"\\x28\\x43\\x01\") ;  /* stop APL chars */\n            lstran(&data3,0x01,0x00) ; /* translate 0x01 to ox00 */\n            lstrcat(&data,&data,&data3) ;  /* add stop APL */\n            lstrcat(&data,&data,&data4) ;  /* add title */\n            lstrnew(&data3,\"\\x28\\x43\\xf1\") ;  /* start APL */\n            lstrcat(&data,&data,&data3) ;  /* add start APL */\n            lstrcat(&data,&data,&data2) ;  /* add right border */\n          }\n        else\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrnew(&data3,\"\\x28\\x43\\x01\") ;  /* stop APL chars */\n            lstran(&data3,0x01,0x00) ; /* translate 0x01 to ox00 */\n            lstrcat(&data,&data,&data3) ;  /* add stop APL */\n            lstrcat(&data,&data,&title) ;  /* add title */\n            lstrnew(&data3,\"\\x28\\x43\\xf1\") ;  /* start APL */\n            lstrcat(&data,&data,&data3) ;  /* add start APL */\n            lstrrep(&data3,\"s\",t-tl-1) ;   /* repeat char to string */\n            lstrcat(&data,&data,&data3) ;  /* add top border chars */\n            lstrcat(&data,&data,&data2) ;  /* concat strings */\n          }\n        fid = insfld(&data,bt,bl,PRTAS,BLUE,NONE);\n        if (fid<0) serror(81,\"Field insert failed\") ;\n        setfld(fid,SYMSET,APL) ; /* make it APL */\n      }\n    else\n      {\n        lstrnew(&data1,\"+#\") ;     /* create VLstring */\n        lstrnew(&data2,\"-VA+\") ;   /* create VLstring */\n        lstrnew(&data3,\" \") ;\n        tl = lstrlen(&title) ;     /* actual title length */\n        t = br-bl-5 ;              /* available space */\n        if (tl>t)\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrsub(&data4,&title,1,t-1) ; /* shorten title */\n            lstrcat(&data,&data,&data4) ;  /* add title */\n            lstrcat(&data,&data,&data2) ;  /* add right border */\n          }\n        else\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrcat(&data,&data,&title) ;  /* add title */\n            lstrrep(&data3,\"-\",t-tl-1) ;   /* repeat char to string */\n            lstrcat(&data,&data,&data3) ;  /* add top border chars */\n            lstrcat(&data,&data,&data2) ;  /* concat strings */\n          }\n        fid = insfld(&data,bt,bl,PRTAS,BLUE,NONE);\n        if (fid<0) serror(81,\"Field insert failed\") ;\n      }\n\n    /* create edit area lines and left and right borders */\n    for (i=bt+1; i<=bb-1; i++)    /* edit area fields */\n      {\n        /* add left border */\n        if (sdcb.loadflg)\n          {\n            lstrnew(&data,\"\\x71\") ;\n            fid = insfld(&data,i,bl,PRTAS,BLUE,NONE) ;\n            if (fid<0) serror(81,\"Field insert failed\") ;\n            setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n          }\n        else if (sdcb.aplflg)\n          {\n            lstrnew(&data,\"e\") ;\n            fid = insfld(&data,i,bl,PRTAS,BLUE,NONE) ;\n            if (fid<0) serror(81,\"Field insert failed\") ;\n            setfld(fid,SYMSET,APL) ; /* make it APL */\n          }\n        else\n          {\n            lstrnew(&data,\"|\") ;\n            fid = insfld(&data,i,bl,PRTAS,BLUE,NONE) ;\n            if (fid<0) serror(81,\"Field insert failed\") ;\n          }\n\n        /* add right border */\n        if (sdcb.loadflg)\n          {\n            lstrnew(&data,\"\\x71\") ;\n            fid = insfld(&data,i,br-1,PRTAS,BLUE,NONE) ;\n            if (fid<0) serror(81,\"Field insert failed\") ;\n            setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n          }\n        else if (sdcb.aplflg)\n          {\n            lstrnew(&data,\"e\") ;\n            fid = insfld(&data,i,br-1,PRTAS,BLUE,NONE) ;\n            if (fid<0) serror(81,\"Field insert failed\") ;\n            setfld(fid,SYMSET,APL) ; /* make it APL */\n          }\n        else\n          {\n            lstrnew(&data,\"|\") ;\n            fid = insfld(&data,i,br-1,PRTAS,BLUE,NONE) ;\n            if (fid<0) serror(81,\"Field insert failed\") ;\n          }\n      }  /* of for edit area lines */\n\n    /* create bottom border */\n    if (sdcb.loadflg)\n      {\n        lstrnew(&data1,\"\\x67\") ;       /* lower left corner */\n        lstrnew(&data2,\"\\x69\") ;       /* lower right corner */\n        lstrrep(&data,\"\\x70\",br-bl-2) ;/* lower border chars */\n        lstrcat(&data,&data1,&data) ;  /* concat strings */\n        lstrcat(&data,&data,&data2) ;  /* concat strings */\n        fid = insfld(&data,bb,bl,PRTAS,BLUE,NONE) ;\n        if (fid<0) serror(81,\"Field insert failed\") ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n      }\n    else if (sdcb.aplflg)\n      {\n        lstrnew(&data1,\"D\") ;          /* lower left corner */\n        lstrnew(&data2,\"M\") ;          /* lower right corner */\n        lstrrep(&data,\"s\",br-bl-2) ;   /* lower border chars */\n        lstrcat(&data,&data1,&data) ;  /* concat strings */\n        lstrcat(&data,&data,&data2) ;  /* concat strings */\n        fid = insfld(&data,bb,bl,PRTAS,BLUE,NONE) ;\n        if (fid<0) serror(81,\"Field insert failed\") ;\n        setfld(fid,SYMSET,APL) ; /* make it APL */\n      }\n    else\n      {\n        lstrnew(&data1,\"+\") ;          /* lower left corner */\n        lstrnew(&data2,\"+\") ;          /* lower right corner */\n        lstrrep(&data,\"-\",br-bl-2) ;   /* lower border chars */\n        lstrcat(&data,&data1,&data) ;  /* concat strings */\n        lstrcat(&data,&data,&data2) ;  /* concat strings */\n        fid = insfld(&data,bb,bl,PRTAS,BLUE,NONE) ;\n        if (fid<0) serror(81,\"Field insert failed\") ;\n      }\n\n    /* create some widgets in the window */\n    if (sdcb.loadflg)\n      {\n        /* title static label */\n        lstrnew(&data1,\"Program Symbol Device Style\") ;\n        fid = insfld(&data1,bt+3,bl+15,PRTAS,PINK,USCORE) ;\n        lstrnew(&data1,\" \") ;\n        fid = insfld(&data1,bt+3,bl+43,PRTAS,PINK,NONE) ;\n\n\n        /* un checked check box */\n        lstrnew(&data1,\"\\x56\") ;       /* symbol */\n        fid = insfld(&data1,bt+5,bl+5,UNPRT,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n        lstrnew(&data1,\"Un-checked check box\") ;\n        fid = insfld(&data1,bt+5,bl+7,UNPRT,CYAN,NONE) ;\n\n        /* un checked check box - grayed */\n        lstrnew(&data1,\"\\x57\") ;       /* symbol */\n        fid = insfld(&data1,bt+5,bl+40,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n        lstrnew(&data1,\"Un-checked check box grayed\") ;\n        fid = insfld(&data1,bt+5,bl+42,PRTAS,CYAN,NONE) ;\n\n\n        /* checked check box */\n        lstrnew(&data1,\"\\x55\") ;       /* symbol */\n        fid = insfld(&data1,bt+6,bl+5,UNPRT,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n        lstrnew(&data1,\"Checked check box\") ;\n        fid = insfld(&data1,bt+6,bl+7,UNPRT,CYAN,NONE) ;\n\n        /* checked check box - grayed */\n        lstrnew(&data1,\"\\x74\") ;       /* symbol */\n        fid = insfld(&data1,bt+6,bl+40,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n        lstrnew(&data1,\"Checked check box grayed\") ;\n        fid = insfld(&data1,bt+6,bl+42,PRTAS,CYAN,NONE) ;\n\n\n        /* indeterminate check box */\n        lstrnew(&data1,\"\\x75\") ;       /* symbol */\n        fid = insfld(&data1,bt+7,bl+5,UNPRT,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n        lstrnew(&data1,\"Indeterminate check box\") ;\n        fid = insfld(&data1,bt+7,bl+7,UNPRT,CYAN,NONE) ;\n\n        /* indeterminate check box - grayed */\n        lstrnew(&data1,\"\\x76\") ;       /* symbol */\n        fid = insfld(&data1,bt+7,bl+40,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n        lstrnew(&data1,\"Indeterminate check box grayed\") ;\n        fid = insfld(&data1,bt+7,bl+42,PRTAS,CYAN,NONE) ;\n\n\n        /* Radio button pressed */\n        lstrnew(&data1,\"\\x53\") ;       /* symbol */\n        fid = insfld(&data1,bt+9,bl+5,UNPRT,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n        lstrnew(&data1,\"Radio button pressed\") ;\n        fid = insfld(&data1,bt+9,bl+7,UNPRT,CYAN,NONE) ;\n\n        /* Radio button pressed - grayed */\n        lstrnew(&data1,\"\\x77\") ;       /* symbol */\n        fid = insfld(&data1,bt+9,bl+40,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n        lstrnew(&data1,\"Radio button pressed grayed\") ;\n        fid = insfld(&data1,bt+9,bl+42,PRTAS,CYAN,NONE) ;\n\n        /* Radio button not pressed */\n        lstrnew(&data1,\"\\x54\") ;       /* symbol */\n        fid = insfld(&data1,bt+10,bl+5,UNPRT,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n        lstrnew(&data1,\"Radio button not pressed\") ;\n        fid = insfld(&data1,bt+10,bl+7,UNPRT,CYAN,NONE) ;\n\n        /* Radio button not pressed - grayed */\n        lstrnew(&data1,\"\\x73\") ;       /* symbol */\n        fid = insfld(&data1,bt+10,bl+40,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n        lstrnew(&data1,\"Radio button not pressed grayed\") ;\n        fid = insfld(&data1,bt+10,bl+42,PRTAS,CYAN,NONE) ;\n\n        /* Radio button indeterminate */\n        lstrnew(&data1,\"\\x78\") ;       /* symbol */\n        fid = insfld(&data1,bt+11,bl+5,UNPRT,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n        lstrnew(&data1,\"Radio button indeterminate\") ;\n        fid = insfld(&data1,bt+11,bl+7,UNPRT,CYAN,NONE) ;\n\n        /* Radio button indeterminate - grayed */\n        lstrnew(&data1,\"\\x80\") ;       /* symbol */\n        fid = insfld(&data1,bt+11,bl+40,PRTAS,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n        lstrnew(&data1,\"Radio button indeterminate grayed\") ;\n        fid = insfld(&data1,bt+11,bl+42,PRTAS,CYAN,NONE) ;\n\n\n        /* Single bar graph */\n        lstrnew(&data1,\"Percent complete:\") ;\n        fid = insfld(&data1,bt+13,bl+5,PRTAS,BLUE,NONE) ;\n        lstrnew(&data1,\"\\x59\\x58\\x58\\x58\\x58\\x58\\x65\\x65\\x65\\x63\") ;\n        fid = insfld(&data1,bt+13,bl+25,PRTAS,BLUE,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n\n\n        /* Slide bar */\n        lstrnew(&data1,\"Slide bar.......:\") ;\n        fid = insfld(&data1,bt+15,bl+5,PRTAS,BLUE,NONE) ;\n        lstrnew(&data1,\"\\x64\\x65\\x65\\x65\\x65\\x58\\x65\\x65\\x65\\x63\") ;\n        fid = insfld(&data1,bt+15,bl+25,UNPRT,YELLOW,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n\n\n        /* Push buttons - not gray */\n        lstrnew(&data1,\"Buttons not grayed:\") ;\n        fid = insfld(&data1,bt+17,bl+5,PRTAS,BLUE,NONE) ;\n\n        lstrnew(&data1,\"\\x9a\\x28\\x43\\x01\"\n          \" Pressed \") ;\n        lstran(&data1,0x01,0x00) ; /* translate 0x01 to ox00 */\n        fid = insfld(&data1,bt+18,bl+8,UNPRT,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n\n        lstrnew(&data1,\"\\x8a\\x28\\x43\\x01\"\n          \" NotPressed \") ;\n        lstran(&data1,0x01,0x00) ; /* translate 0x01 to ox00 */\n        fid = insfld(&data1,bt+18,bl+24,UNPRT,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n\n        lstrnew(&data1,\"\\x90\\x28\\x43\\x01\"\n          \" Indeterminent \") ;\n        lstran(&data1,0x01,0x00) ; /* translate 0x01 to ox00 */\n        fid = insfld(&data1,bt+18,bl+41,UNPRT,CYAN,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n\n        /* Push buttons - gray */\n        lstrnew(&data1,\"Buttons grayed:\") ;\n        fid = insfld(&data1,bt+19,bl+5,PRTAS,BLUE,NONE) ;\n\n        lstrnew(&data1,\"\\xcb\\x28\\x43\\x01\"\n          \" Pressed \") ;\n        lstran(&data1,0x01,0x00) ; /* translate 0x01 to ox00 */\n        fid = insfld(&data1,bt+20,bl+8,PRTAS,WHITE,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n\n        lstrnew(&data1,\"\\xba\\x28\\x43\\x01\"\n          \" NotPressed \") ;\n        lstran(&data1,0x01,0x00) ; /* translate 0x01 to ox00 */\n        fid = insfld(&data1,bt+20,bl+24,PRTAS,WHITE,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n\n        lstrnew(&data1,\"\\xca\\x28\\x43\\x01\"\n          \" Indeterminent \") ;\n        lstran(&data1,0x01,0x00) ; /* translate 0x01 to ox00 */\n        fid = insfld(&data1,bt+20,bl+41,PRTAS,WHITE,NONE) ;\n        setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n\n      }\n    else if (sdcb.aplflg)\n      {\n        /* title static label */\n        lstrnew(&data1,\"APL Symbol Device Style\") ;\n        fid = insfld(&data1,bt+3,bl+15,PRTAS,PINK,USCORE) ;\n        lstrnew(&data1,\" \") ;\n        fid = insfld(&data1,bt+3,bl+39,PRTAS,PINK,NONE) ;\n\n\n        /* un checked check box */\n        lstrnew(&data1,\"\\x90\") ;       /* symbol */\n        fid = insfld(&data1,bt+4,bl+5,UNPRT,CYAN,NONE) ;\n        setfld(fid,SYMSET,APL) ; /* make it APL symbols */\n        lstrnew(&data1,\"Un-checked check box\") ;\n        fid = insfld(&data1,bt+4,bl+7,UNPRT,CYAN,NONE) ;\n\n        /* checked check box */\n        lstrnew(&data1,\"\\xee\") ;       /* symbol */\n        fid = insfld(&data1,bt+5,bl+5,UNPRT,CYAN,NONE) ;\n        setfld(fid,SYMSET,APL) ; /* make it APL symbols */\n        lstrnew(&data1,\"Checked check box\") ;\n        fid = insfld(&data1,bt+5,bl+7,UNPRT,CYAN,NONE) ;\n\n        /* undefined check box */\n        lstrnew(&data1,\"\\x9c\") ;       /* symbol */\n        fid = insfld(&data1,bt+6,bl+5,UNPRT,CYAN,NONE) ;\n        setfld(fid,SYMSET,APL) ; /* make it APL symbols */\n        lstrnew(&data1,\"Undefined check box\") ;\n        fid = insfld(&data1,bt+6,bl+7,UNPRT,CYAN,NONE) ;\n\n        /* Radio button pressed */\n        lstrnew(&data1,\"\\xed\") ;       /* symbol */\n        fid = insfld(&data1,bt+8,bl+5,UNPRT,CYAN,NONE) ;\n        setfld(fid,SYMSET,APL) ; /* make it APL symbols */\n        lstrnew(&data1,\"Radio button pressed\") ;\n        fid = insfld(&data1,bt+8,bl+7,UNPRT,CYAN,NONE) ;\n\n        /* Radio button not pressed */\n        lstrnew(&data1,\"\\x9d\") ;       /* symbol */\n        fid = insfld(&data1,bt+9,bl+5,UNPRT,CYAN,NONE) ;\n        setfld(fid,SYMSET,APL) ; /* make it APL symbols */\n        lstrnew(&data1,\"Radio button not pressed\") ;\n        fid = insfld(&data1,bt+9,bl+7,UNPRT,CYAN,NONE) ;\n\n        /* Single bar graph */\n        lstrnew(&data1,\"Percent complete:\") ;\n        fid = insfld(&data1,bt+11,bl+5,PRTAS,BLUE,NONE) ;\n        lstrnew(&data1,\"\\x95\\x95\\x95\\x95\\x95\\x95\\x82\\x82\\x82\\x91\") ;\n        fid = insfld(&data1,bt+12,bl+8,PRTAS,BLUE,NONE) ;\n        setfld(fid,SYMSET,APL) ; /* make it APL symbols */\n\n        /* Slide bar */\n        lstrnew(&data1,\"Slide bar\") ;\n        fid = insfld(&data1,bt+14,bl+5,PRTAS,WHITE,NONE) ;\n        lstrnew(&data1,\"\\x92\\x82\\x82\\x82\\x82\\x95\\x82\\x82\\x82\\x91\") ;\n        fid = insfld(&data1,bt+15,bl+8,UNPRT,YELLOW,NONE) ;\n        setfld(fid,SYMSET,APL) ; /* make it APL symbols */\n\n        /* Push button */\n        lstrnew(&data1,\"( Button1 )\") ;\n        fid = insfld(&data1,bt+17,bl+8,UNPRT,CYAN,RVIDEO) ;\n        lstrnew(&data1,\" \") ;\n        fid = insfld(&data1,bt+17,bl+20,PRTAS,BLUE,NONE) ;\n\n        lstrnew(&data1,\"( Button2 )\") ;\n        fid = insfld(&data1,bt+17,bl+22,UNPRT,CYAN,RVIDEO) ;\n        lstrnew(&data1,\" \") ;\n        fid = insfld(&data1,bt+17,bl+34,PRTAS,BLUE,NONE) ;\n\n        lstrnew(&data1,\"( Button3 )\") ;\n        fid = insfld(&data1,bt+18,bl+22,UNPRT,CYAN,RVIDEO) ;\n        lstrnew(&data1,\" \") ;\n        fid = insfld(&data1,bt+18,bl+34,PRTAS,BLUE,NONE) ;\n\n      }\n    else\n      {\n        /* title static label */\n        lstrnew(&data1,\"Primitive Device Style\") ;\n        fid = insfld(&data1,bt+3,bl+15,PRTHIAS,PINK,USCORE) ;\n        lstrnew(&data1,\" \") ;\n        fid = insfld(&data1,bt+3,bl+38,PRTAS,PINK,NONE) ;\n\n        /* un checked check box */\n        lstrnew(&data1,\"_\") ;       /* symbol */\n        fid = insfld(&data1,bt+4,bl+5,UNPRT,CYAN,NONE) ;\n        lstrnew(&data1,\"Un-checked check box\") ;\n        fid = insfld(&data1,bt+4,bl+7,UNPRT,CYAN,NONE) ;\n\n        /* checked check box */\n        lstrnew(&data1,\"X\") ;       /* symbol */\n        fid = insfld(&data1,bt+5,bl+5,UNPRT,CYAN,NONE) ;\n        lstrnew(&data1,\"Checked check box\") ;\n        fid = insfld(&data1,bt+5,bl+7,UNPRT,CYAN,NONE) ;\n\n        /* undefined check box */\n        lstrnew(&data1,\".\") ;       /* symbol */\n        fid = insfld(&data1,bt+6,bl+5,UNPRT,CYAN,NONE) ;\n        lstrnew(&data1,\"Undefined check box\") ;\n        fid = insfld(&data1,bt+6,bl+7,UNPRT,CYAN,NONE) ;\n\n        /* Radio button pressed */\n        lstrnew(&data1,\"*\") ;       /* symbol */\n        fid = insfld(&data1,bt+8,bl+5,UNPRT,CYAN,NONE) ;\n        lstrnew(&data1,\"Radio button pressed\") ;\n        fid = insfld(&data1,bt+8,bl+7,UNPRT,CYAN,NONE) ;\n\n        /* Radio button not pressed */\n        lstrnew(&data1,\"o\") ;       /* symbol */\n        fid = insfld(&data1,bt+9,bl+5,UNPRT,CYAN,NONE) ;\n        lstrnew(&data1,\"Radio button not pressed\") ;\n        fid = insfld(&data1,bt+9,bl+7,UNPRT,CYAN,NONE) ;\n\n        /* Single bar graph */\n        lstrnew(&data1,\"Percent complete:\") ;\n        fid = insfld(&data1,bt+11,bl+5,PRTAS,BLUE,NONE) ;\n        lstrnew(&data1,\"######....\") ;\n        fid = insfld(&data1,bt+12,bl+8,PRTAS,BLUE,NONE) ;\n\n        /* Slide bar */\n        lstrnew(&data1,\"Slide bar\") ;\n        fid = insfld(&data1,bt+14,bl+5,PRTAS,WHITE,NONE) ;\n        lstrnew(&data1,\"<....X...>\") ;\n        fid = insfld(&data1,bt+15,bl+8,UNPRT,YELLOW,NONE) ;\n\n        /* Push button */\n        lstrnew(&data1,\"( Button1 )\") ;\n        fid = insfld(&data1,bt+17,bl+8,UNPRT,CYAN,RVIDEO) ;\n        lstrnew(&data1,\" \") ;\n        fid = insfld(&data1,bt+17,bl+20,PRTAS,BLUE,NONE) ;\n\n        lstrnew(&data1,\"( Button2 )\") ;\n        fid = insfld(&data1,bt+17,bl+22,UNPRT,CYAN,RVIDEO) ;\n        lstrnew(&data1,\" \") ;\n        fid = insfld(&data1,bt+17,bl+34,PRTAS,BLUE,NONE) ;\n\n        lstrnew(&data1,\"( Button3 )\") ;\n        fid = insfld(&data1,bt+18,bl+22,UNPRT,CYAN,RVIDEO) ;\n        lstrnew(&data1,\" \") ;\n        fid = insfld(&data1,bt+18,bl+34,PRTAS,BLUE,NONE) ;\n\n      }\n  }\n\n\n/*-------------------------------------------------------------------*/\n/* Display the window and process the keys/commands entered.         */\n/*-------------------------------------------------------------------*/\nvoid dispwin()\n  {\n    TLSTR temp  ;        /* temp varying length string */\n    TLSTR command ;      /* command name varying length string */\n    char key ;           /* AID for the key just pressed */\n\n    lstrnew(&command,\" \") ;\n    while(lstrcmpc(&command,\"end\") != 0)\n      {\n        if (cmdflg)\n          {\n            /* set initial cursor row and col to the command field */\n            currow = bt + 1 ;\n            curcol = bl + 16 ;\n            /* blank out the command line */\n            lstrnew(&command,\" \") ;\n            modfld(cmdfid,&command) ;\n            cmdflg = 0 ;\n          }\n        key = dspflds() ;     /* display the screen and get aid=key */\n        lstrnew(&temp,\" \") ;\n        modfld(msgfid,&temp) ;    /* blank message line */\n        getfld(cmdfid,&command) ;  /* get the command line */\n\n        /* Process function keys PFKs */\n        switch (key)\n          {\n            case ENTER:\n              if (currow == bt) /* window border accelerators */\n                {\n                  if (curcol == (bl+2))  /* close window */\n                    {\n                      lstrnew(&command,\"end\") ;\n                    }\n                  else if (curcol == (br-2))  /* minimise window */\n                    {\n                      bt = 1 ;\n                      bl = 1 ;\n                      br = 48 ;\n                      bb = 20 ;\n                      remflds() ;\n                      buildwin() ;  /* re-build the display window */\n                      winmsg(\"Window minimised.\") ;\n                    }\n                  else if (curcol == (br-1))  /* maximise window */\n                    {\n                      bt = 1 ;\n                      bl = 1 ;\n                      br = sdcb.cols ;\n                      bb = sdcb.rows ;\n                      remflds() ;\n                      buildwin() ;  /* re-build the display window */\n                      winmsg(\"Window maximised.\") ;\n                    }\n                }\n              break ;\n            case PF1:    /* No help message */\n              winmsg(\n                \"Move border: PF23=Top PF11=Bottom PF10=Left PF12=Right\"\n                ) ;\n              break ;\n            case PF3:    /* Generate end command */\n            case PF15:   /* Alternate generate end command */\n              lstrnew(&command,\"end\") ;\n              break ;\n\n            case PF10:   /* move left border */\n              if ((curcol<(br-48)) &&\n                  (curcol>=1) )\n                {\n                  bl = curcol-1 ; /* adjust for attr byte */\n                  remflds() ;\n                  buildwin() ;  /* re-build the display window */\n                }\n              else\n                winmsg(\"Left border move position too far.\") ;\n              break ;\n\n            case PF11:   /* move bottom border */\n              if ((currow>(bt+20)) &&\n                  (currow<=sdcb.rows) )\n                {\n                  bb = currow ;\n                  remflds() ;\n                  buildwin() ;  /* re-build the display window */\n                }\n              else\n                winmsg(\"Bottom border move position too far.\") ;\n              break ;\n\n            case PF12:   /* move right border */\n              if ((curcol>(bl+48)) &&\n                 (curcol<=sdcb.cols) )\n                {\n                  br = curcol-1 ;  /* adjust for attr byte */\n                  remflds() ;\n                  buildwin() ;  /* re-build the display window */\n                }\n              else\n                winmsg(\"Right border move position too far.\") ;\n              break ;\n\n            case PF23:   /* move top border */\n              if ((currow<(bb-20)) &&\n                  (currow>=1) )\n                {\n                  bt = currow ;\n                  remflds() ;\n                  buildwin() ;  /* re-build the display window */\n                }\n              else\n                winmsg(\"Top border move position too far.\") ;\n              break ;\n\n            case PF24:   /* zoom to max window size */\n              bt = 1 ;\n              bl = 1 ;\n              br = sdcb.cols ;\n              bb = sdcb.rows ;\n              remflds() ;\n              buildwin() ;  /* re-build the display window */\n              break ;\n\n            case PA2:    /* reshow key does nothing - yet */\n              break ;\n\n            default:     /* any other key is not valid */\n              bellflg = 1 ;  /* sound alarm */\n              winmsg(\"Invalid function key.\") ;\n              break ;\n          }\n\n        /* Process command from the command line */\n        if (lstrcmpc(&command,\"test\") == 0)   /* test command */\n          {\n            winmsg(\"The test command was entered.\") ;\n            cmdflg = 1 ;  /* reset command line */\n          }\n        else if (lstrcmpc(&command,\"dump\") == 0)  /* dump command */\n          {\n            dumpfld() ;\n            winmsg(\"Dump command executed.\") ;\n            cmdflg = 1 ;  /* reset command line */\n          }\n        else if (lstrcmpc(&command,\"load\") == 0)  /* force load PS */\n          {\n            loadps1() ;\n            winmsg(\"Load PS type 1 command executed.\") ;\n            cmdflg = 1 ;  /* reset command line */\n          }\n        else if (lstrcmpc(&command,\"termstat\") == 0) /*dump term data*/\n          {\n            termstat() ;\n            winmsg(\"Terminal status printed.\") ;\n            cmdflg = 1 ;  /* reset command line */\n          }\n        else if (lstrcmpc(&command,\"traceon\") == 0) /* trace on */\n          {\n            iotrace = 1 ;\n            winmsg(\"Trace is on.\") ;\n            cmdflg = 1 ;  /* reset command line */\n          }\n        else if (lstrcmpc(&command,\"traceoff\") == 0) /* trace off */\n          {\n            iotrace = 0 ;\n            winmsg(\"Trace is off.\") ;\n            cmdflg = 1 ;  /* reset command line */\n          }\n\n      }   /* of while command not end */\n    clear() ;   /* clear the 3270 screen */\n  }\n\n\n/*-------------------------------------------------------------------*/\n/* Display the window and process the keys/commands entered.         */\n/*-------------------------------------------------------------------*/\nvoid winmsg(char *msg)\n  {\n    TLSTR msgstr  ;     /* message varying length string */\n\n    lstrnew(&msgstr,msg) ;\n    modfld(msgfid,&msgstr) ;\n  }\n\n/*********************************************************************/\n/* 3270 field handling routines                                      */\n/*   rc = initscr()                                                  */\n/*   termscr()                                                       */\n/*   fid = insfld(data,row,col,attr,color,hilite)                    */\n/*   rc = remflds()                                                  */\n/*   rc = delfld(fid)                                                */\n/*   rc = erasefld(fid)                                              */\n/*   rc = getfld(fid,returndata)                                     */\n/*   rc = modfld(fid,newdata)                                        */\n/*   rc = setfld(fid,attrtype,attrvalue)                             */\n/*   dumpflds()                                                      */\n/*                                                                   */\n/*********************************************************************/\n\n\n/*-------------------------------------------------------------------*/\n/* Set up the screen environment.                                    */\n/*-------------------------------------------------------------------*/\nint initscr()\n{\n    int rc = 0 ;\n\n    buffer = (char *)malloc(BUFFMAX) ;  /* alloc tput/get buffer */\n    if (buffer)\n      {\n        rc = getdev() ;  /* get3270 device information */\n        if (rc==0 && sdcb.loadflg==1)\n          loadps1() ;\n      }\n    else\n      rc = 1 ;   /* could not get buffer */\n\n    return rc ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Terminate screen environment.                                     */\n/*-------------------------------------------------------------------*/\nvoid termscr()\n{\n    if (screen)\n      remflds() ;       /* remove any remaining fields */\n\n    free((char *)buffer) ;  /* remove tput/get buffer */\n}\n\n/*-------------------------------------------------------------------*/\n/* Display current contents of the 3270 field list.                  */\n/*-------------------------------------------------------------------*/\nchar dspflds()\n{\n  TSFLD *curr ;\n  int rc, bufpos, trow = 0, tcol = 0, fstart, fend, ilen ;\n  char sba\u00dd2\u00a8 ;\n  char aid ;\n\n  /* assemble buffer, it will contain: (EW WCC) followed by all  */\n  /* the display fields. Each field will contain:                */\n  /*   (SFE 0x03 0xC0 fattr HILITE fhilite COLOR fcolor data)    */\n  if (sdcb.altflg)\n    buffer\u00dd0\u00a8 = EWA ;     /* erase write alternate */\n  else\n    buffer\u00dd0\u00a8 = EW ;      /* erase write */\n\n  /* determine if the bell should be rung */\n  if (bellflg)\n    {\n      buffer\u00dd1\u00a8 = WCCRES | WCCKBD | WCCMDT | WCCBEL ;\n      bellflg = 0 ;  /* turn bell flag off, one ring only */\n    }\n  else\n    buffer\u00dd1\u00a8 = WCCRES | WCCKBD | WCCMDT ;\n\n  bufpos = 2 ;\n  curr = screen ;     /* first node in field list */\n  while (curr)\n    {\n      buffer\u00ddbufpos++\u00a8 = SBA ;  /* set buffer address */\n      rc2sba(curr->fypos,curr->fxpos,sba) ;\n      buffer\u00ddbufpos++\u00a8 = sba\u00dd0\u00a8 ;\n      buffer\u00ddbufpos++\u00a8 = sba\u00dd1\u00a8 ;\n      if (sdcb.edsflg)\n        {\n          buffer\u00ddbufpos++\u00a8 = SFE ;  /* start field extended */\n          buffer\u00ddbufpos++\u00a8 = 0x03 ;\n          buffer\u00ddbufpos++\u00a8 = 0xc0 ;\n          buffer\u00ddbufpos++\u00a8 = curr->fattr ;\n          buffer\u00ddbufpos++\u00a8 = HILITE ;\n          buffer\u00ddbufpos++\u00a8 = curr->fhilite ;\n          buffer\u00ddbufpos++\u00a8 = COLOR ;\n          buffer\u00ddbufpos++\u00a8 = curr->fcolor ;\n\n          /* insert set character attribute before data if APL/PS syms*/\n          /* are required and the field has protection turned on.     */\n          if (((curr->symbol==APL) || (curr->symbol==0x40)) /*APL/PS*/\n            && (curr->fattr & 0x40)) /* and protected field */\n            {\n              buffer\u00ddbufpos++\u00a8 = SA ;           /* set attribute */\n              buffer\u00ddbufpos++\u00a8 = SYMSET ;       /* symbol */\n              if (curr->symbol==APL) /* APL ? */\n                buffer\u00ddbufpos++\u00a8 = sdcb.aplflg ; /* use APL's lcid */\n              else\n                buffer\u00ddbufpos++\u00a8 = curr->symbol ; /* use symbol value */\n            }\n        }\n      else    /* dont used extended data stream */\n        {\n          buffer\u00ddbufpos++\u00a8 = SF ;  /* start field */\n          buffer\u00ddbufpos++\u00a8 = curr->fattr ;\n        }\n\n      /* insert field data */\n      ilen = lstrunld(&buffer\u00ddbufpos\u00a8,&curr->fdata) ;\n      bufpos = bufpos + ilen ;\n\n      /* revert to standard symbols after APL/PS data symbols  */\n      if (((curr->symbol==APL) || (curr->symbol==0x40)) /*APL/PS*/\n        && (curr->fattr & 0x40)) /* and protected field */\n        {\n          buffer\u00ddbufpos++\u00a8 = SA ;       /* set attribute */\n          buffer\u00ddbufpos++\u00a8 = SYMSET ;   /* symbol */\n          buffer\u00ddbufpos++\u00a8 = DFLT ;     /* revert to default symbols */\n        }\n\n      curr = curr->next ;  /* go to next field */\n    }\n\n  /* insert the cursor in the same location the user left it */\n  buffer\u00ddbufpos++\u00a8 = SBA ;     /* add set buffer address order */\n  rc2sba(currow,curcol,sba) ;  /* determine SBA for current row/col */\n  buffer\u00ddbufpos++\u00a8 = sba\u00dd0\u00a8 ;  /* add buffer addr part 1 */\n  buffer\u00ddbufpos++\u00a8 = sba\u00dd1\u00a8 ;  /* add buffer addr part 2 */\n  buffer\u00ddbufpos++\u00a8 = ICUR ;    /* add insert cursor order */\n\n  /* dumpchar(buffer,bufpos) ; */\n\n  /* write buffer to the 3270 */\n  rc = tputn(buffer, bufpos) ;\n\n  fill(buffer,0x00,bufpos) ;\n  /* receive the response from the user */\n  rc = tgetn(buffer, BUFFMAX ) ;\n\n  /* decode input, should be an AID, a cursor pos bufferaddr */\n  /* and a list of fields (SBA addr1 addr2 data)             */\n\n  aid = buffer\u00dd0\u00a8 ;      /* get code of key that was pressed */\n  sba\u00dd0\u00a8 = buffer\u00dd1\u00a8 ;\n  sba\u00dd1\u00a8 = buffer\u00dd2\u00a8 ;\n  sba2rc(sba,&currow,&curcol,0) ;  /* convert and store cursor pos */\n                                   /* adjust = 0 used for cursor pos */\n\n  curr = screen ;\n  fstart = 0 ;\n  bufpos = 3 ;\n  while(bufpos<=BUFFMAX)\n    {\n      if (buffer\u00ddbufpos\u00a8==SBA)\n        {\n          /* get new buffer address */\n          bufpos++ ;\n          sba\u00dd0\u00a8 = buffer\u00ddbufpos++\u00a8 ;\n          sba\u00dd1\u00a8 = buffer\u00ddbufpos++\u00a8 ;\n          sba2rc(sba,&trow,&tcol,1) ; /* convert buf.addr to row/col */\n                              /* adjust = 1 used for retn. buf. addr */\n          fstart = bufpos ;\n\n          /* locate field by r/c then write data to field list entry */\n          while( !((curr->fxpos==tcol) && (curr->fypos==trow)) )\n            {                          /* locate */\n              curr = curr->next ;\n              if (!curr) break ; /* could not locate - real bad */\n            }\n\n          if (curr)    /* found field - copy the data into it */\n            {\n              /* first locate end of data */\n              fend = fstart ;\n              while ((buffer\u00ddfend\u00a8 != SBA) &&\n                     (buffer\u00ddfend\u00a8 != 0x00))\n                fend++ ;  /* leaves fend pointing at next char. */\n\n              /* copy data from buffer into field list */\n              ilen = fend - fstart ;\n              lstrload(&curr->fdata,&buffer\u00ddfstart\u00a8,ilen) ;\n\n              /* adjust bufpos to last char of this returned SBA */\n              bufpos = fend -1 ;\n            }\n          else\n            {\n              /* SEVERE ERROR: This should never happen */\n              printf(\"No locate field: row %d col %d SBA %.2X %.2X\\n\",\n                trow,tcol,sba\u00dd0\u00a8,sba\u00dd1\u00a8) ;\n              curr = screen ;  /* further searches from top */\n            }\n        }\n      else\n        bufpos++ ;   /* advance to next char */\n    }\n\n  return aid ;    /* data returned OK */\n}\n\n\n/*-------------------------------------------------------------------*/\n/* Dump field list to stdout.                                        */\n/*-------------------------------------------------------------------*/\nvoid dumpfld()\n{\n  TSFLD *curr ;\n  int i = 0, size = 0 ;\n  char sba\u00dd2\u00a8 ;\n\n  printf(\"Field list follows:\\n\") ;\n  curr = screen ;     /* first node in field list */\n  while (curr)\n    {\n      printf(\"  Field at row %d col %d\\n\",curr->fypos,curr->fxpos) ;\n      rc2sba(curr->fypos,curr->fxpos,sba) ;\n      printf(\"    BufAddr: %.2X %.2X \",sba\u00dd0\u00a8,sba\u00dd1\u00a8) ;\n      printf(\"Attrib: %.2X \",curr->fattr) ;\n      printf(\"Hilite: %.2X \",curr->fhilite) ;\n      printf(\"Color: %.2X \",curr->fcolor) ;\n      printf(\"Symbol: %.2X \",curr->symbol) ;\n      printf(\"DataLen: %d\\n\",curr->fdata.len) ;\n      printf(\"    Data dump: \\n\") ;\n      dumpchar(curr->fdata.data,curr->fdata.len) ;\n      size = size + curr->fdata.len  + 11 ;\n      i++ ;\n      curr = curr->next ;\n    }\n  printf(\"Total fields %d, buffer size required %d\\n\",i,size) ;\n}\n\n\n/*-------------------------------------------------------------------*/\n/* Print terminal status.                                            */\n/*-------------------------------------------------------------------*/\nvoid termstat()\n{\n  printf(\"Terminal status follows:\\n\") ;\n  printf(\"  Device name.........: %s\\n\",sdcb.modname) ;\n  printf(\"  Device model........: %d\\n\",sdcb.model) ;\n  printf(\"  Device type.........: %d\\n\",sdcb.type) ;\n  printf(\"  Addressing mode.....: %d\\n\",sdcb.adrmode) ;\n  printf(\"  Maximum rows........: %d\\n\",sdcb.rows) ;\n  printf(\"  Maximum columns.....: %d\\n\",sdcb.cols) ;\n  printf(\"  Cell height.........: %d\\n\",sdcb.celheigh) ;\n  printf(\"  Cell width..........: %d\\n\",sdcb.celwidth) ;\n  printf(\"  Supported colors....: %d\\n\",sdcb.colors) ;\n  printf(\"  Actual colors.......: %d\\n\",sdcb.colora) ;\n  printf(\"  Color attr list.....: %.32X\\n\",sdcb.colorlst) ;\n  printf(\"  Number of Highlights: %d\\n\",sdcb.hilites) ;\n  printf(\"  Highlight attr list.: %.8X\\n\",sdcb.hilitlst) ;\n  if (sdcb.unit)\n    printf(\"  Unit................: mm\\n\") ;\n  else\n    printf(\"  Unit................: inch\\n\") ;\n  printf(\"  Alternate device....: %d\\n\",sdcb.altflg) ;\n  printf(\"  APL symbol set......: %.2X\\n\",sdcb.aplflg) ;\n  printf(\"  Extended data stream: %d\\n\",sdcb.edsflg) ;\n  printf(\"  Loadable symbols....: %d\\n\",sdcb.loadflg) ;\n  printf(\"  Load PS extended....: %d\\n\",sdcb.psflg) ;\n  printf(\"  Triple plane symbols: %d\\n\",sdcb.triflg) ;\n  printf(\"  Double byte symbols.: %d\\n\",sdcb.dbcsflg) ;\n  printf(\"  Vector graphic......: %d\\n\",sdcb.graflg) ;\n}\n\n\n/*-------------------------------------------------------------------*/\n/* Add a field to the 3270 field list.                               */\n/*-------------------------------------------------------------------*/\nint insfld(TLSTR *flddata,       /* the data */\n            int ypos,            /* display at row */\n            int xpos,            /* display at column */\n            char attr,           /* field attribute PRT, UNPRT ...*/\n            char color,          /* field color RED, BLUE, ...*/\n            char hilite )        /* field hilite BLINK, RVIDEO,...*/\n{\n  int rc ;\n  TSFLD *newfld, *last, *top ;\n\n  /* get storage for new nodes */\n  newfld = (TSFLD *)malloc(sizeof(TSFLD)) ;\n  if (!newfld) serror(20,\"Not enough memory\") ;\n  memset(newfld,0x00,sizeof(TSFLD)) ;\n\n  /* verify contents of all parameters */\n  if ((flddata->len > 0) &&\n    (flddata->len <= (sdcb.rows * sdcb.cols)))\n    lstrcopy(&newfld->fdata,flddata) ;\n  else\n    return -1 ;\n\n  if ((xpos > 0) &&\n    (xpos < sdcb.cols))\n    newfld->fxpos = xpos ;\n  else\n    return -2 ;\n\n  if ((ypos > 0) &&\n    (ypos <= sdcb.rows))\n    newfld->fypos = ypos ;\n  else\n    return -3 ;\n\n  rc = modattr(&newfld->fattr,attr) ;\n  if (rc) return -4 ;\n\n  rc = modcolor(&newfld->fcolor,color) ;\n  if (rc) return -5 ;\n\n  rc = modhilite(&newfld->fhilite,hilite) ;\n  if (rc) return -6 ;\n\n  /* insert the field into the field list in order of buffer offset */\n  top = screen ;\n  if (!top)   /* first entry in the list (screen->00) */\n    {\n      newfld->next = NULL ;\n      screen = newfld ;\n    }\n  else\n    {\n      last = NULL ;  /* last node examined */\n      while(top)    /* loop through fields for insert place */\n        {\n          if ((top->fxpos+top->fypos*sdcb.cols) <\n            (newfld->fxpos+newfld->fypos*sdcb.cols)) /* rel.buff.pos */\n            {    /* chain to next node */\n              last = top ;\n              top = top->next ;\n            }\n          else\n            {\n              if (last)  /* insert the new node, in middle of list */\n                {\n                  last->next = newfld ;\n                  newfld->next = top ;\n                }\n              else   /* insert new first node in list */\n                {\n                  newfld->next = top ;\n                  screen = newfld ;\n                }\n              break ;   /* exit loop */\n            }\n        }\n      if (!newfld->next)  /* stil not inserted? - add to end */\n        last->next = newfld ;\n    }\n\n  /* update field id table and field id in field struct */\n  newfld->fid = fidnext ;\n  sfidtab\u00ddfidnext\u00a8 = newfld ;\n  rc = fidnext++ ;\n  return rc ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Remove all fields defined from the 3270 field list.               */\n/*-------------------------------------------------------------------*/\nint remflds()\n{\n  int i ;\n  TSFLD *curr, *top ;\n\n  for (i=0; i<SFIDMAX; i++)  /* empty fid table */\n    sfidtab\u00ddi\u00a8 = NULL ;\n  fidnext = 0 ;              /* reset next fid */\n\n  top = screen ;             /* free field list */\n  while(top)\n    {\n      curr = top ;\n      top = top->next ;\n      free((char *)curr->fdata.data) ;\n      free((TSFLD *)curr) ;\n    }\n  screen = NULL ;\n  return 0 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Delete a field from the 3270 field list.                          */\n/*-------------------------------------------------------------------*/\nint delfld(int id)\n{\n    TSFLD *curr, *top, *last ;\n\n    if ((id < SFIDMAX) && (id >= 0))\n      {\n        curr = sfidtab\u00ddid\u00a8 ;\n        if (curr)\n          {\n            top = screen ;\n            last = NULL ;\n            while (top)\n              {\n                if (top == curr)\n                  {\n                    if (!last)   /* ? found node at top */\n                      screen = top->next ;\n                    else if (!top->next)  /* ? last node */\n                      last->next = NULL ;\n                    else           /* in middle of list */\n                      last->next = top->next ;\n                    /* delete the node */\n                    free((char *)top->fdata.data) ;\n                    free((TSFLD *)top) ;\n                    sfidtab\u00ddid\u00a8 = NULL ; /* invalidate id */\n                    return 0 ;  /* field id removed OK */\n                  }\n                last = top ;  /* remember last node */\n                top = top->next ;   /* chain to next node */\n              }    /* of while top */\n          }\n        else return 1 ;     /* invalid id */\n      }\n    else return 2 ;    /* out of range id */\n    return 3 ;     /* idtab list mismatch */\n}\n\n/*-------------------------------------------------------------------*/\n/* Erase the contents of a field in the 3270 field list.             */\n/*-------------------------------------------------------------------*/\nint erasefld(int id)\n{\n  TSFLD *curr ;\n\n  if ((id < SFIDMAX) && (id >= 0))\n    {\n      curr = sfidtab\u00ddid\u00a8 ;\n      if (curr)\n        lstrfill(&curr->fdata,\"\\0\") ; /* fill with zeros */\n      else\n        return 1 ;     /* invalid id */\n    }\n  else\n    return 2 ;    /* out of range id */\n\n  return 0 ;    /* id erased OK */\n}\n\n/*-------------------------------------------------------------------*/\n/* Get the current contents of a field in the 3270 field list.       */\n/*-------------------------------------------------------------------*/\nint getfld(int id,\n           TLSTR *retdata)\n{\n  TSFLD *curr ;\n\n  if ((id < SFIDMAX) && (id >= 0))\n    {\n      curr = sfidtab\u00ddid\u00a8 ;\n      if (curr)\n        lstrcopy(retdata,&curr->fdata) ; /* copy data */\n      else\n        return 1 ;     /* invalid id */\n    }\n  else\n    return 2 ;    /* out of range id */\n\n  return 0 ;    /* data returned OK */\n}\n\n/*-------------------------------------------------------------------*/\n/* Modify the contents of a field in the 3270 field list.            */\n/*-------------------------------------------------------------------*/\nint modfld(int id,\n           TLSTR *newdata)\n{\n  TSFLD *curr ;\n\n  if ((id < SFIDMAX) && (id >= 0))\n    {\n      curr = sfidtab\u00ddid\u00a8 ;\n      if (curr)\n        {\n          if ((newdata->len > 0) &&\n            (newdata->len <= (sdcb.rows * sdcb.cols)))\n            lstrcopy(&curr->fdata,newdata) ; /* alter field data*/\n          else\n            return 1 ;  /* data too large or 0 */\n        }\n      else\n        return 2 ;     /* invalid id */\n    }\n  else\n    return 3 ;    /* out of range id */\n\n  return 0 ;    /* data returned OK */\n}\n\n/*-------------------------------------------------------------------*/\n/* Change the attributes of a field in the 3270 field list.          */\n/*-------------------------------------------------------------------*/\nint setfld(int id,\n           int type,\n           char value)\n{\n  TSFLD *curr ;\n  int rc = 0 ;\n\n  if ((id < SFIDMAX) && (id >= 0))\n    {\n      curr = sfidtab\u00ddid\u00a8 ;\n      if (curr)\n        {\n          switch (type)\n            {\n            case ALL:\n              rc = modcolor(&curr->fcolor,DFLT) ;\n              rc = modhilite(&curr->fhilite,DFLT) ;\n              rc = modattr(&curr->fattr,DFLT) ;\n              break ;\n            case HILITE:\n              rc = modhilite(&curr->fhilite,value) ;\n              break ;\n            case COLOR:\n              rc = modcolor(&curr->fcolor,value) ;\n              break ;\n            case ATTR:\n              rc = modattr(&curr->fattr,value) ;\n              break ;\n            case SYMSET:\n              rc = modsym(&curr->symbol,value) ;\n              break ;\n            default:\n              return 1 ;    /* invalid type */\n            }\n        }\n      else\n        return 1 ;     /* invalid id */\n    }\n  else\n    return 2 ;    /* out of range id */\n\n  return rc ;   /* return */\n}\n\n\n\n/*********************************************************************/\n/* 3270 support routines                                             */\n/*   rc2sba(row,col,sba)                                             */\n/*   sba2rc(sba,row,col,adjust)                                      */\n/*   rc = modcolor(out,in)                                           */\n/*   rc = modhilit(out,in)                                           */\n/*   rc = modattr(out,in)                                            */\n/*   rc = tputn(buf,buflen)                                          */\n/*   rc = tgetn(buf,buflen)                                          */\n/*   rc = tpgn(buf,buflen)                                           */\n/*   rc = getdev()                                                   */\n/*   rc = getterm(primrow,primcol,altrow,altcol,attrs)               */\n/*   rc = querydev()                                                 */\n/*   rc = dsummary(buf,buflen)                                       */\n/*   rc = darea(buf,buflen)                                          */\n/*   rc = dcharset(buf,buflen)                                       */\n/*   rc = dcolor(buf,buflen)                                         */\n/*   rc = dhilite(buf,buflen)                                        */\n/*   rc = dmodes(buf,buflen)                                         */\n/*   rc = dimpart(buf,buflen)                                        */\n/*                                                                   */\n/*********************************************************************/\n\n/*-------------------------------------------------------------------*/\n/* The TPUTN routine is loaded below the 16M line                    */\n/* It issues the TPUT macro with the NOEDIT option                   */\n/*-------------------------------------------------------------------*/\nint tputn(char *buf, int buflen)\n  {\n    int rc = 0 ;\n    int (*tputn)(char *,int) ;\n\n    loadm(\"TPUTN\",&tputn) ;\n    if (iotrace)      /* trace terminal I/O ? */\n      {\n        printf(\"Outbound data stream:\\n\") ;\n        dumpchar(buf,buflen) ;\n      }\n    rc = (*tputn)(buf,buflen) ;\n    unloadm(tputn) ;\n    return rc ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* The TGETN routine is loaded below the 16M line                    */\n/* It issues the TGET macro with the FULLSCR option.                 */\n/*-------------------------------------------------------------------*/\nint tgetn(char *buf, int buflen)\n  {\n    int rc = 0 ;\n    int (*tgetn)(char *,int) ;\n\n    loadm(\"TGETN\",&tgetn) ;\n    rc = (*tgetn)(buf,buflen) ;\n    if (iotrace)      /* trace terminal I/O ? */\n      {\n        printf(\"Inbound data stream:\\n\") ;\n        dumpchar(buf,buflen) ;\n      }\n    unloadm(tgetn) ;\n    return rc ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* The TPGN routine is loaded below the 16M line                     */\n/* It issues the TPG macro with the NOEDIT option.                   */\n/*-------------------------------------------------------------------*/\nint tpgn(char *buf, int buflen)\n  {\n    int rc = 0 ;\n    int (*tpgn)(char *,int) ;\n\n    loadm(\"TPGN\",&tpgn) ;\n    if (iotrace)      /* trace terminal I/O ? */\n      {\n        printf(\"Outbound data stream:\\n\") ;\n        dumpchar(buf,buflen) ;\n      }\n    rc = (*tpgn)(buf,buflen) ;\n    unloadm(tpgn) ;\n    return rc ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* Convert row/column to 3270 12/16 bit buffer address.              */\n/*-------------------------------------------------------------------*/\nvoid rc2sba(int row,\n            int col,\n            char *sba)\n{\n  int offset, byte1, byte2 ;\n\n  offset = ((row-1)*sdcb.cols)+(col-1) ;\n  if (sdcb.adrmode == 12)  /* addressing mode = 12 */\n    {\n      byte1 = offset >> 6 ;           /* extract high order bits */\n      byte1 = byte1 | 0x000000c0 ;    /* turn on 12 bit ind */\n\n      byte2 = offset & 0x0000003f ;   /* extract low order 6 bits */\n      byte2 = byte2 | 0x000000c0 ;    /* turn on 12 bit ind */\n\n      sba\u00dd0\u00a8 = *((char *)&byte1+3) ;  /* assemble 2 byte sba */\n      sba\u00dd1\u00a8 = *((char *)&byte2+3) ;\n    }\n  else /* adrmode = 16 or 14 */\n    {\n      byte1 = offset >> 8 ;           /* extract high order byte */\n      byte2 = offset & 0x00ff ;       /* extract low order byte */\n      sba\u00dd0\u00a8 = *((char *)&byte1+3) ;  /* assemble 2 byte sba */\n      sba\u00dd1\u00a8 = *((char *)&byte2+3) ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Convert 12/14/16-bit address to an offset and row/column.         */\n/*-------------------------------------------------------------------*/\nvoid sba2rc(char *inaddr,  /* input buffer addr */\n            int *row,      /* returned row */\n            int *col,      /* returned column */\n            int adjust)    /* amount to subtract - usuallu 0 for the */\n                           /*   returned cursor position, but is set */\n                           /*   to one to get correct returned buffer*/\n                           /*   addresses.                           */\n{\n  int taddr,     /* Temporary address holder */\n      offset ;\n  short addr ;\n  memcpy((char *)&addr,inaddr,sizeof(short)) ;\n\n  /* If 12-bit address, then we need to massage it a little */\n  if (addr & 0xc000)    /* 12-bit address ? */\n    {\n       addr &= 0x3f3f ;      /* turn off 2 hi bits in each byte */\n       taddr = addr >> 8 ;   /* taddr is first 6 bits */\n       addr &= 0x00ff ;      /* addr is second 6 bits */\n       taddr = taddr << 6 ;  /* shift taddr left and .. */\n       taddr |= addr ;       /*   merge taddr with addr into taddr */\n       offset = taddr ;      /* taddr is the offset into the buffer */\n    }\n  else\n    offset = addr ;          /* addr is the offset into the buffer */\n\n  offset = offset - adjust ; /* adjust is either 0 or 1 */\n\n  /* turn offset into row and column based on device num of columns */\n  *col = (offset % sdcb.cols) + 1 ;\n  *row = (offset / sdcb.cols) + 1 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Check color attribute and copy if valid.                          */\n/*-------------------------------------------------------------------*/\nint modsym(char *out,\n           char in )\n{\n  switch (in)\n    {\n    case DFLT:\n      *out = in ;\n      return 0 ;\n    case APL:\n      if (sdcb.aplflg)\n        {\n          *out = in ;\n          return 0 ;\n        }\n      else\n        return 1 ;\n    default:\n      if (sdcb.loadflg)\n        {\n          if ((in>=0x40) && (in<=0xef))\n            {\n              *out = in ;\n              return 0 ;\n            }\n          else\n            return 1 ;\n        }\n      else\n        return 1 ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Check color attribute and copy if valid.                          */\n/*-------------------------------------------------------------------*/\nint modcolor(char *out,\n             char in )\n{\n  switch (in)\n    {\n    case DFLT:\n    case BLUE:\n    case RED:\n    case PINK:\n    case GREEN:\n    case TURQ:\n    case YELLOW:\n    case WHITE:\n      *out = in ;\n      return 0 ;\n    default:\n      return 1 ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Check hilite attribute and copy if valid.                         */\n/*-------------------------------------------------------------------*/\nint modhilit(char *out,\n             char in )\n{\n  switch (in)\n    {\n    case NONE:\n    case BLINK:\n    case RVIDEO:\n    case USCORE:\n      *out = in ;\n      return 0 ;\n    default:\n      return 1 ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Check field attribute and copy if valid.                          */\n/*-------------------------------------------------------------------*/\nint modattr(char *out,\n            char in )\n{\n  switch (in)\n    {\n    case PRT:       /* protected normal intensity */\n    case PRTHI:     /* protected high intensity */\n    case PRTAS:     /* protected normal intensity auto skip */\n    case PRTHIAS:   /* protected high intensity auto skip */\n    case UNPRT:     /* unprotected normal intensity */\n    case UNNUM:     /* unprotected numeric normal intensity */\n    case UNNUMHI:   /* unprotected numeric high intensity */\n    case UNNON:     /* unprotected non display */\n    case UNHI:      /* unprotected high intensity */\n      *out = in ;\n      return 0 ;\n    default:\n      return 1 ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Load programmed symbols - type 1 load                             */\n/*   loads programmed symbols without compression                    */\n/*-------------------------------------------------------------------*/\nint loadps1()\n  {\n    int rc ;         /* return code */\n    int bufpos ;     /* next buffer position */\n    int i, j ;       /* counters */\n    short s ;        /* temp */\n\n    memset(buffer,0x00,BUFFMAX) ;  /* clear buffer */\n\n    bufpos = 0 ;\n    buffer\u00ddbufpos++\u00a8 = WSF ;   /* write structured field */\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;  /* structured field length */\n    buffer\u00ddbufpos++\u00a8 = 0x07 ;  /* structured field length contd. */\n    buffer\u00ddbufpos++\u00a8 = 0x06 ;  /* load PS structured field */\n    buffer\u00ddbufpos++\u00a8 = 0x41 ;  /* flags: clear sym.set and use type 1 */\n    buffer\u00ddbufpos++\u00a8 = 0xff ;  /* make associated RWS = not assigned */\n    buffer\u00ddbufpos++\u00a8 = 0x41 ;  /* starting code point */\n    buffer\u00ddbufpos++\u00a8 = 0x02 ;  /* RWS of PSA symbol set */\n\n    /* write buffer to the 3270 */\n    rc = tputn(buffer, bufpos) ;\n\n    memset(buffer,0x00, bufpos) ;  /* clear buffer */\n\n    bufpos = 0 ;\n    buffer\u00ddbufpos++\u00a8 = WSF ;   /* write structured field */\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;  /* structured field length */\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;  /* structured field length contd. */\n    buffer\u00ddbufpos++\u00a8 = 0x06 ;  /* load PS structured field */\n    buffer\u00ddbufpos++\u00a8 = 0x01 ;  /* flags: use type 1 */\n    buffer\u00ddbufpos++\u00a8 = 0x40 ;  /* make associated RWS = 0x40 */\n    buffer\u00ddbufpos++\u00a8 = 0x41 ;  /* starting code point (symbol=65) */\n    buffer\u00ddbufpos++\u00a8 = 0x02 ;  /* RWS of PSA symbol set */\n\n /* This extra stuff needs the flags bit 1 on to indicate extended\n    I dont think I need to use it yet.\n\n    buffer\u00ddbufpos++\u00a8 = 0x08 ;     P length - length of extra parms\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     flags: operator selectable ...\n    buffer\u00ddbufpos++\u00a8 = 0x09 ;     LW - width of character\n    buffer\u00ddbufpos++\u00a8 = 0x10 ;     LH - width of character\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     SUBSN - only one byte codes\n    buffer\u00ddbufpos++\u00a8 = 0xf1 ;     COLOR - F1 - first attr ???\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     ST.SUBSN - default\n    buffer\u00ddbufpos++\u00a8 = 0xf9 ;     ECHAR - last symbol=249\n\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     NW - number width pairs\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     NH - number height pairs\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     RES - reserved\n */\n\n    /* load specific font based on the cell height */\n    if (sdcb.celheigh >= 16)\n      {\n        for (i=65;i<=249;i++)   /* for each symbol, 0x41 to 0xF9 */\n          {\n            for (j=0;j<=17;j++)      /* for each slice  */\n              {\n                buffer\u00ddbufpos++\u00a8 = ps9x16u\u00ddi\u00a8\u00ddj\u00a8 ;\n              }\n          }\n      }\n    else if (sdcb.celheigh == 15)\n      {\n        for (i=65;i<=249;i++)   /* for each symbol, 0x41 to 0xF9 */\n          {\n            for (j=0;j<=17;j++)      /* for each slice  */\n              {\n                buffer\u00ddbufpos++\u00a8 = ps9x15u\u00ddi\u00a8\u00ddj\u00a8 ;\n              }\n          }\n      }\n    else\n      {\n        for (i=65;i<=249;i++)   /* for each symbol, 0x41 to 0xF9 */\n          {\n            for (j=0;j<=17;j++)      /* for each slice  */\n              {\n                buffer\u00ddbufpos++\u00a8 = ps9x12u\u00ddi\u00a8\u00ddj\u00a8 ;\n              }\n          }\n      }\n\n    s = bufpos - 1 ;\n    memcpy(buffer+1,&s,sizeof(short)) ;\n\n    /* write buffer to the 3270 to load the programmed symbols */\n    rc = tputn(buffer, bufpos) ;\n\n    memset(buffer,0x00,BUFFMAX) ;  /* clear buffer */\n    return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* Get the display device attributes.                                */\n/*-------------------------------------------------------------------*/\nint getdev()\n  {\n    int rc, pr = 0, pc = 0, ar = 0, ac = 0, att = 0 ;\n    int i ;\n\n    /* set the default values, may get over ridden later */\n    sdcb.adrmode = 12 ;  /* addressing mode */\n    sdcb.altflg = 0 ;    /* use primary device */\n    sdcb.edsflg = 0 ;    /* no extended data stream */\n    sdcb.graflg = 0 ;    /* not a graphics device */\n    sdcb.aplflg = 0 ;    /* no apl symbols on device */\n    sdcb.psflg = 0 ;     /* no program symbols on device */\n    sdcb.loadflg = 0 ;   /* no loadable symbols sets on device */\n    sdcb.triflg = 0 ;    /* no triple plane symbols sets on device */\n    sdcb.dbcsflg = 0 ;   /* no double byte symbols on device */\n    sdcb.celheigh = 0 ;  /* zero cell height on device */\n    sdcb.celwidth = 0 ;  /* zero cell width on device */\n    sdcb.unit = 0 ;      /* units are inches */\n    sdcb.colora = 1 ;    /* actual colors default to monochrome */\n    sdcb.colors = 1 ;    /* supported colors default to monochrome */\n    sdcb.hilites = 0 ;   /* supported hilites default to none */\n    for (i=0;i<17;i++)\n      sdcb.colorlst\u00ddi\u00a8 = 0x00 ; /* list of color attributes on device*/\n    for (i=0;i<5;i++)\n      sdcb.hilitlst\u00ddi\u00a8 = 0x00 ; /* list of hilite attributes on device*/\n\n\n    /* get info from TSO about this device */\n    rc = getterm(&pr,&pc,&ar,&ac,&att) ;\n    if (rc==0)                 /* get terminal info worked ? */\n      {\n        if (att==0x00000001)   /* device has query structured fields */\n          {\n            /* set row and col may be later reset by query dev */\n            if ((ar>0) && (ar!=pr) &&\n                (ac>0) && (ac!=pc))\n              {\n                sdcb.altflg = 1 ;    /* use alternate device */\n                sdcb.rows = ar ;     /* use alternate rows */\n                sdcb.cols = ac ;     /* use alternate cols */\n              }\n            else\n              {\n                sdcb.rows = pr ;     /* use primary rows */\n                sdcb.cols = pc ;     /* use primary cols */\n              }\n\n            rc = querydev() ;\n            /* try to determine actual device */\n            if (sdcb.rows == 32)\n              {\n                strcpy(sdcb.modname,\"IBM3279-3\") ;\n                sdcb.model = 3279 ;\n                sdcb.type = 3 ;\n              }\n            else if (sdcb.rows == 43)\n              {\n                strcpy(sdcb.modname,\"IBM3278-4\") ;\n                sdcb.model = 3278 ;\n                sdcb.type = 4 ;\n              }\n            else if (sdcb.rows == 27)\n              {\n                strcpy(sdcb.modname,\"IBM3290\") ;\n                sdcb.model = 3290 ;\n                sdcb.type = 5 ;\n              }\n            else  /* cant tell - use most primitive */\n              {\n                strcpy(sdcb.modname,\"IBM3278-2\") ;\n                sdcb.model = 3278 ;\n                sdcb.type = 2 ;\n              }\n          }\n        else  /* dont know a lot about the device - make some guesses */\n          {\n            if ((ar>0) && (ar!=pr) &&\n                (ac>0) && (ac!=pc))\n              {\n                sdcb.altflg = 1 ;    /* use alternate device */\n                sdcb.rows = ar ;     /* use alternate rows */\n                sdcb.cols = ac ;     /* use alternate cols */\n              }\n            else\n              {\n                sdcb.rows = pr ;     /* use primary rows */\n                sdcb.cols = pc ;     /* use primary cols */\n              }\n\n            /* try to determine actual device */\n            if (sdcb.rows == 32)\n              {\n                strcpy(sdcb.modname,\"IBM3279-3\") ;\n                sdcb.model = 3279 ;\n                sdcb.type = 3 ;\n              }\n            else if (sdcb.rows == 43)\n              {\n                strcpy(sdcb.modname,\"IBM3278-4\") ;\n                sdcb.model = 3278 ;\n                sdcb.type = 4 ;\n              }\n            else if (sdcb.rows == 27)\n              {\n                strcpy(sdcb.modname,\"IBM3290\") ;\n                sdcb.model = 3290 ;\n                sdcb.type = 5 ;\n              }\n            else  /* cant tell - use most primitive */\n              {\n                strcpy(sdcb.modname,\"IBM3278-2\") ;\n                sdcb.model = 3278 ;\n                sdcb.type = 2 ;\n              }\n          }\n        return 0 ;\n      }\n    else  /* get term failed - return its code */\n      return rc ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* This routine loads an assebbler module below the 16 MB line       */\n/* that issues the GTTERM macro instruction to obtain the            */\n/* dimensions of the screen and also some bit fields that            */\n/* tell if the device can be queried. The module copies the          */\n/* results from storage below the line to this routines              */\n/* automatic storage.                                                */\n/* Upon completion the module is unloaded.                           */\n/*-------------------------------------------------------------------*/\nint getterm(int *primrow, int *primcol,\n             int *altrow, int *altcol,\n             int *attrs)\n  {\n    struct {\n      union {\n        short sh ;\n        char c\u00dd2\u00a8 ;\n      } prim ;\n      union {\n        short sh ;\n        char c\u00dd2\u00a8 ;\n      } alt ;\n      int attr ;\n    } pm ;\n    int rc = 0 ;\n    int (*tgt327d)(void *) ;\n\n    loadm(\"TGT327D\",&tgt327d) ;   /* load ASM routine below 16M */\n    rc = (*tgt327d)(&pm) ;        /* execute GTTERM macro */\n    if (rc==0)      /* data returned OK ? */\n      {             /* yes - convert single byte numbers to int */\n        *primrow = pm.prim.c\u00dd0\u00a8 ;\n        *primcol = pm.prim.c\u00dd1\u00a8 ;\n        *altrow = pm.alt.c\u00dd0\u00a8 ;\n        *altcol = pm.alt.c\u00dd1\u00a8 ;\n        *attrs = pm.attr ;\n      }\n    unloadm(tgt327d) ;            /* unload ASM routine */\n    return rc ;                   /* return code from GTTERM */\n  }\n\n/*-------------------------------------------------------------------*/\n/* Clear 3270 screen.                                                */\n/*-------------------------------------------------------------------*/\nvoid clear()\n  {\n    int rc ;\n    char sba\u00dd2\u00a8 ;\n    char out1\u00dd\u00a8 = {      /* set up for erase */\n      WRT, 0x40,\n      SBA, 0x5d, 0x7f,   /* end addr - overlayed later */\n      SBA, 0x40, 0x40,   /* start addr row=1 col=1 */\n      SBA, 0xe7, 0x7f,   /* insert cursor location, row/col max */\n      ICUR               /* insert cursor */\n      } ;\n    char out2\u00dd\u00a8 = {      /* erase write alternate */\n      EWA, 0xc2\n      } ;\n    char out3\u00dd\u00a8 = {      /* erase primary */\n      WRT, 0xc2\n      } ;\n\n    /* set max screen size known so far sba */\n    rc2sba(sdcb.rows,sdcb.cols,sba) ;\n    out1\u00dd9\u00a8 = sba\u00dd0\u00a8 ;\n    out1\u00dd10\u00a8 = sba\u00dd1\u00a8 ;\n\n    rc = tputn(out1,sizeof(out1) ) ;   /* define the buffer */\n    rc = tputn(out2,sizeof(out2) ) ;   /* erase write alternate */\n    rc = tputn(out3,sizeof(out3) ) ;   /* erase write primary */\n  }\n\n/*-------------------------------------------------------------------*/\n/* Select the entire screen buffer using SBA based on the            */\n/* scrsize returned from GTTERM and EW/EWA to select the             */\n/* primary or alternate buffer.                                      */\n/* Then assemble a structured field query, and send it to the        */\n/* device using TPG which will cause the device to imediately        */\n/* send back the response without any user intervention.             */\n/* Then decode the read partition, query operations, query and       */\n/* put the interesting data in the sdcb structure.                   */\n/*-------------------------------------------------------------------*/\nint querydev()\n  {\n    short sflen ;      /* structured field length */\n    char  sfid ;       /* structured field ID */\n    char  qcode ;      /* query reply - query code */\n    char input\u00dd256\u00a8 ;  /* query buffer */\n    char *ibuf ;       /* current query buffer pointer */\n    int rc ;\n    char sba\u00dd2\u00a8 ;\n\n    char out1\u00dd\u00a8 = {      /* set up for erase */\n      WRT, 0x40,\n      SBA, 0x5d, 0x7f,   /* end addr - overlayed later, rc= 24,80 */\n      SBA, 0x40, 0x40,   /* start addr row=1 col=1 */\n      SBA, 0xe7, 0x7f,   /* insert cursor loc, rc= 32,80 *OVERLAYED**/\n      ICUR               /* insert cursor */\n      } ;\n\n    char out2\u00dd\u00a8 = {      /* erase write alternate */\n      EWA, 0xc2\n      } ;\n\n    char out3\u00dd\u00a8 = {      /* erase primary */\n      WRT, 0xc2\n      } ;\n\n    char out4\u00dd\u00a8 = {\n      WSF,               /* write structured field */\n      0x00, 0x05,        /* structured field length */\n      0x01,              /* read partition */\n      0xFF,              /* query operations */\n      0x02               /* query */\n      } ;\n\n    /* set max screen size known so far sba */\n    rc2sba(sdcb.rows,sdcb.cols,sba) ;\n    out1\u00dd9\u00a8 = sba\u00dd0\u00a8 ;\n    out1\u00dd10\u00a8 = sba\u00dd1\u00a8 ;\n\n    fill(input,0x00,sizeof(input)) ;   /* zero input buffer */\n\n    rc = tputn(out1,sizeof(out1) ) ;   /* define the buffer */\n    rc = tputn(out2,sizeof(out2) ) ;   /* erase write alternate */\n    rc = tputn(out3,sizeof(out3) ) ;   /* erase write primary */\n    rc = tpgn(out4,sizeof(out4) ) ;    /* query the device */\n    rc = tgetn(input,sizeof(input)) ;  /* receive device resp.*/\n\n    ibuf = input ;       /* point at input */\n\n    if (*input==0x88)    /* check for 88 AID byte */\n      {\n        ibuf = ibuf+1 ;         /* advance to 1st structured field */\n        sfid = *(ibuf+2) ;      /* sfid should be 0x81 */\n\n        while (sfid==0x81)  /* while structured fields remain */\n          {\n            sflen = *((short *)ibuf) ;  /* get structured field len */\n            if (sflen==0)           /* bad error - should not happen */\n              {\n                printf(\"Error: Structured field length zero at %p\\n\",\n                  ibuf) ;\n                dumpchar(input,sizeof(input)) ;\n                return 1 ;\n              }\n            qcode = *(ibuf+3) ;     /* get query code */\n            switch (qcode)\n              {\n                case 0x80:           /* Q-code summary */\n                  rc = dsummary(ibuf,sflen) ;\n                  break ;\n                case 0x81:           /* Usable area */\n                  rc = darea(ibuf,sflen) ;\n                  break ;\n                case 0x85:           /* Character sets */\n                  rc = dcharset(ibuf,sflen) ;\n                  break ;\n                case 0x86:           /* Color */\n                  rc = dcolor(ibuf,sflen) ;\n                  break ;\n                case 0x87:           /* Highlighting */\n                  rc = dhilite(ibuf,sflen) ;\n                  break ;\n                case 0x88:           /* Modes */\n                  rc = dmodes(ibuf,sflen) ;\n                  break ;\n                case 0xa6:           /* Implicit partition */\n                  rc = dimpart(ibuf,sflen) ;\n                  break ;\n                default:\n                  break ;\n              }  /* of switch */\n            ibuf = ibuf+sflen ; /* advance to next structured field */\n            sfid = *(ibuf+2) ;  /* sfid should be 0x81 - else stop */\n\n          } /* of while sfid=81 */\n\n      } /* of AID=88 */\n    return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x80: Qcode summary                                               */\n/*-------------------------------------------------------------------*/\nint dsummary(char *buf, short buflen)\n  {\n     int i ;\n     char qcode ;\n\n     for (i=4;i<buflen;i++)\n       {\n          qcode = *(buf+i) ;     /* get query code */\n          if (qcode == 0xb4)\n            sdcb.graflg = 1 ;    /* indicate graphic support */\n       }  /* of for i=4 */\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x81: Usable area                                                 */\n/*-------------------------------------------------------------------*/\nint darea(char *buf, short buflen)\n  {\n     char celunits\u00dd6\u00a8 ;   /* screen size unit PEL or CELL */\n     short w, h ;         /* screen size w=width h=height */\n     char aw, ah ;        /* units per cell aw=width ah=height */\n     float xr, xrd, yr, yrd ;  /* pel spacing ratio */\n     float fw, fh ;       /* ratio - pels per unit */\n\n     if ((*(buf+4) & 0x03)==0x03)\n       sdcb.adrmode = 16 ;\n     else if ((*(buf+4) & 0x01)==0x01)\n       sdcb.adrmode = 12 ;\n\n     w = *((short *)(buf+6)) ;   /* width of usable area */\n     h = *((short *)(buf+8)) ;   /* height of usable area */\n\n     if (*(buf+10) == 0x01)    /* pels/in or pels/mm */\n       sdcb.unit = 1 ;  /* units are mm */\n     else\n       sdcb.unit = 0 ;  /* units are inch */\n\n     xr = *((short *)(buf+11)) ;    /* x dim pel ratio numerator */\n     xrd = *((short *)(buf+13)) ;   /* x dim pel ratio denominator */\n     yr = *((short *)(buf+15)) ;    /* y dim pel ratio numerator */\n     yrd = *((short *)(buf+17)) ;   /* y dim pel ratio denominator */\n\n     fw = (float)(xr) / (float)(xrd) ; /* horiz. ratio pels per unit */\n     fh = (float)(yr) / (float)(yrd) ; /* vert. ratio pels per unit */\n\n     aw = *(buf+19) ;    /* number of X units in default cell */\n     ah = *(buf+20) ;    /* number of Y units in default cell */\n\n     if (*(buf+5) & 0x20)       /* byte 5 bit 3 on unit=pels */\n       strcpy(celunits,\"pels\") ;\n     else                       /* other wise unit=cells */\n       strcpy(celunits,\"cells\") ;\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x85: Character sets                                              */\n/*-------------------------------------------------------------------*/\nint dcharset(char *buf, short buflen)\n  {\n     int i, j ;         /* counters */\n     int cgcsgid ;      /* Coded graphic character set identifier */\n     short ccsid ;      /* Coded character set identifier */\n     char gf = 0 ;      /* CGCSGID not present flag */\n     char ch2 = 0 ;     /* Two byte char. set flag */\n     char ms = 0 ;      /* Multiple slot sizes flag */\n     char cf = 0 ;      /* CCSID not present flag */\n     char sdw ;         /* Default character slot width */\n     char sdh ;         /* Default character slot height */\n     char dl ;          /* character set descriptor (CSD) length */\n     char *csd ;        /* character set descriptor (CSD) ptr */\n     char set ;         /* character set ID (PS store no.) */\n     char lcid ;        /* character set Local ID (alias) */\n     char sw ;          /* character set slot width */\n     char sh ;          /* character set slot height */\n     char ssubsn ;      /* character set starting subsection */\n     char esubsn ;      /* character set ending subsection */\n\n     if (*(buf+4) & 0x10)\n       sdcb.psflg = 1 ;   /* load PS Extended supported */\n     else\n       sdcb.psflg = 0 ;   /* load PS Extended not supported */\n\n     if (*(buf+4) & 0x08)\n       ms = 1 ;   /* More than one size character slot supported */\n\n     if (*(buf+4) & 0x04)\n       ch2 = 1 ;  /* Two byte code character sets are supported */\n\n     if (*(buf+4) & 0x02)\n       gf = 1 ;   /* CGCSGID present */\n\n     if (*(buf+5) & 0x20)\n       cf = 1 ;   /* CCSID present */\n\n     sdw = *(buf+6) ;\n     sdh = *(buf+7) ;\n\n     dl = *(buf+12) ;   /* get CSD length */\n     i = 13 ;\n     while (i<buflen)\n       {\n         csd = buf + i ;  /* point at CSD to process */\n         set = *csd ;     /* get character set ID (PS store no.) */\n         if (*(csd+1) & 0x80)\n           sdcb.loadflg = 1 ;  /* loadable symbol sets exist */\n\n         if (*(csd+1) & 0x40)\n           sdcb.triflg = 1 ;   /* Triple-plane character sets exist */\n\n         if (*(csd+1) & 0x20)\n           sdcb.dbcsflg = 1 ;  /* Double-byte coded character sets */\n\n         lcid = *(csd+2) ;   /* get character set ID (PS store no.) */\n\n         j = 0 ;\n         if (ms)\n           {\n             sw = *(csd+3) ;  /* slot width */\n             sh = *(csd+4) ;  /* slot height */\n             j = j + 2 ;\n           }\n\n         if (ch2)\n           {\n             ssubsn = *(csd+j+3) ;  /* starting sub-section */\n             esubsn = *(csd+j+4) ; /* ending sub-section */\n             j = j + 2 ;\n           }\n\n         if (gf)\n           {\n             cgcsgid = *((int *)(csd+j+3)) ;  /* Graf char set ID */\n             if (cgcsgid==0x03c30136)\n               sdcb.aplflg = lcid ;   /* APL supported store lcid */\n             j = j + 4 ;\n           }\n\n         if (cf)\n           {\n             ccsid = *((short *)(csd+j+3)) ;  /* char set ID */\n           }\n\n         i = i + dl ;  /* get pos of next CSD */\n       }  /* of while i<buflen */\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x86: Colors                                                      */\n/*-------------------------------------------------------------------*/\nint dcolor(char *buf, short buflen)\n  {\n     int colora = 0 ; /* number of actual colors on device */\n     int icolor ;     /* color index */\n     int i, j = 0 ;   /* counter */\n     char attr ;      /* color attribute accepted by device */\n     char dcolor ;    /* color displayed for this attribute */\n\n     sdcb.colors = (int)*(buf+5) ; /* number of colors accepted */\n     for (i=6;i<buflen;i=i+2)\n       {\n         attr = *(buf+i) ;        /* attribute used by appl. */\n         sdcb.colorlst\u00ddj++\u00a8 = attr ;\n         dcolor = *(buf+i+1) ;    /* attr/color used by device */\n         icolor = (int)(dcolor - 0xf0) ;\n         if ((icolor >= 0) && (icolor <= 15))\n           colora++ ;\n       }\n     sdcb.colora = colora ;  /* number of actual colors on device */\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x87: Highlighting                                                */\n/*-------------------------------------------------------------------*/\nint dhilite(char *buf, short buflen)\n  {\n     int i, j = 0 ;    /* counter */\n     char attr ;       /* color attribute accepted by device */\n     char dhilite ;    /* color displayed for this attribute */\n\n     sdcb.hilites = (int)*(buf+4) ;\n     for (i=5;i<buflen;i=i+2)\n       {\n         attr = *(buf+i) ;        /* attribute used by appl. */\n         dhilite = *(buf+i+1) ;   /* attr/highlight used by device */\n         sdcb.hilitlst\u00ddj++\u00a8 = attr ;\n       }\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x88: Modes                                                       */\n/*-------------------------------------------------------------------*/\nint dmodes(char *buf, short buflen)\n  {\n     int i ;           /* counter */\n     char mode ;       /* device opperation mode */\n\n     for (i=4;i<buflen;i++)\n       {\n         mode = *(buf+i) ;        /* attribute used by appl. */\n         if ((mode==0x01) ||\n             (mode==0x02))\n           sdcb.edsflg = 1 ;  /* queryable device can use extended DS*/\n       }   /* of for i */\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0xa6: Implicit partition                                          */\n/*-------------------------------------------------------------------*/\nint dimpart(char *buf, short buflen)\n  {\n     char *sdp ;                /* self defining parameter (SDP) ptr */\n     short wd, wa, hd, ha ;     /* screen dimensions */\n     short wcd, wca, hcd, hca ; /* cell sizes */\n     int i ;                    /* counter */\n\n     i = 6 ;        /* length of header */\n     while(i < buflen)   /* loop over all SDPs */\n       {\n         sdp = buf + i ;\n         if (*sdp==0x0b)    /* is it a SDP ? */\n           {\n             if (*(sdp+1)==0x01)\n               {\n                 wd = *((short *)(sdp+3)) ;  /* default width */\n                 hd = *((short *)(sdp+5)) ;  /* default height */\n                 wa = *((short *)(sdp+7)) ;  /* alternate width */\n                 ha = *((short *)(sdp+9)) ;  /* alternate height */\n                 if ((ha>hd) || (wa>wd))\n                   {\n                     sdcb.altflg = 1 ;    /* use alternate device */\n                     sdcb.rows = ha ;     /* use alternate rows */\n                     sdcb.cols = wa ;     /* use alternate cols */\n                   }\n                 else\n                   {\n                     sdcb.rows = hd ;     /* use primary rows */\n                     sdcb.cols = wd ;     /* use primary cols */\n                   }\n                 i = i + 11 ;     /* add length of this SDP */\n               }\n             else if (*(sdp+1)==0x03)\n               {\n                 i = i + 11 ;     /* add length of this SDP */\n               }\n             else if (*(sdp+1)==0x02)\n               {\n                 wcd = *((short *)(sdp+3)) ;  /* default cell width */\n                 hcd = *((short *)(sdp+5)) ;  /* default cell height */\n                 wca = *((short *)(sdp+7)) ;  /* alternate cell width */\n                 hca = *((short *)(sdp+9)) ;  /* alternate cell height*/\n                 if (sdcb.altflg)         /* using alternate device */\n                   {\n                     sdcb.celheigh = hca ; /* use alt. cell height */\n                     sdcb.celwidth = wca ; /* use alt. cell width */\n                   }\n                 else\n                   {\n                     sdcb.celheigh = hcd ; /* use primary cell height */\n                     sdcb.celwidth = wcd ; /* use primary cols width */\n                   }\n                 i = i + 11 ;     /* add length of this SDP */\n               }\n           }\n       }  /* of while */\n\n     return 0 ;\n  }\n\n\n\n\n/*********************************************************************/\n/* General string handling routines for varying length strings.      */\n/*   lstran(mod_lstr,fromchar,tochar)                                */\n/*   lstrload(to_lstr,fromchar,len)                                  */\n/*   lstrunld(tochar,from_lstr)                                      */\n/*   lstrcopy(to_lstr,from_lstr)                                     */\n/*   lstrnew(to,fromchars)                                           */\n/*   lstrsub(to_lstr,from_lstr,start,length)                         */\n/*   len = lstrlen(haystack_lstr)                                    */\n/*   pos = lstrindex(haystack_lstr,needle_lstr)                      */\n/*   lstrfill(to_lstr,fillchars)                                     */\n/*   rc = lstrcmpc(cmp_lstr,cmpchars)                                */\n/*   lstrdel(del-lstr)                                               */\n/*   lstrrep(to_lstr,repchars,copies)                                */\n/*   lstrcat(to_lstr,left_lstr,right_lstr)                           */\n/*********************************************************************/\n\n/*-------------------------------------------------------------------*/\n/* Translate a character in an lstr to another character.            */\n/*-------------------------------------------------------------------*/\nvoid lstran(TLSTR *in, char from, char to)\n{\n  int i ;      /* temp counter */\n\n  if (in)      /* from string exists ? */\n    {\n      for (i=0;i<=in->len;i++)\n        {\n          if (*(in->data+i) == from)\n            *(in->data+i) = to ;\n        }\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Get the length of an lstr.                                        */\n/*-------------------------------------------------------------------*/\nint lstrlen(TLSTR *in)\n{\n  if (in)      /* from string exists ? */\n    {\n      return in->len ;\n    }\n  else\n    return 0 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Unload varying length string contents into character buffer.      */\n/*-------------------------------------------------------------------*/\nint lstrunld(char *to,\n             TLSTR *from)\n{\n  if (from)      /* from string exists ? */\n    {\n      memcpy(to,from->data,from->len) ;\n      return from->len ;\n    }\n  else\n    return 0 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Load varying length string with contents of character buffer.     */\n/*-------------------------------------------------------------------*/\nvoid lstrload(TLSTR *to,\n              char *from,\n              int len)\n{\n  if (to)      /* to string exists ? */\n    {\n      if (len!=to->len)\n        {\n          free((char *)to->data) ;\n          to->data = (char *)malloc(len) ;\n          if (!to->data) serror(4,\"Not enough memory\") ;\n          to->len = len ;\n        }\n      memcpy(to->data,from,len) ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Copy varying length string.                                       */\n/*-------------------------------------------------------------------*/\nvoid lstrcopy(TLSTR *to,\n              TLSTR *from)\n{\n  if (from)      /* from string exists ? */\n    {\n      if (!to)    /* to string does not exist */\n        serror(2,\"String does not exist\") ;\n      else     /* to string exists */\n        {\n          if (from->len > 0)\n            {\n              if (to->data == NULL)     /* does not exist yet ? */\n                {\n                  to->data = (char *)malloc(from->len) ;\n                  if (!to->data) serror(14,\"Not enough memory\") ;\n                }\n              else if (from->len != to->len)   /* increase length ? */\n                {\n                  free((char *)to->data) ;\n                  to->data = (char *)malloc(from->len) ;\n                  if (!to->data) serror(4,\"Not enough memory\") ;\n                }\n              to->len = from->len ;\n              memcpy(to->data,from->data,from->len) ;\n            }\n          else\n            {\n              if (to->len > 0)   /* empty data */\n                free((char *)to->data) ;\n              to->len = 0 ;\n              to->data = NULL ;\n            }\n        }\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Initialize a varying length string with a string.                 */\n/*-------------------------------------------------------------------*/\nvoid lstrnew(TLSTR *newstr,\n             char *from)\n{\n  int i ;\n\n  if (!newstr)\n    serror(5,\"String does not exist\") ;\n  else\n    {\n      i = strlen(from) ;\n      if (i > 0)\n        {\n          newstr->data = (char *)malloc(i) ;\n          if (!newstr->data) serror(17,\"Not enough memory\") ;\n          newstr->len = i ;\n          memcpy(newstr->data,from,i) ;\n        }\n      else\n        {\n          newstr->len = 0 ;\n          newstr->data = NULL ;\n        }\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Create substring of a varying length string to a varying length   */\n/* string.                                                           */\n/*-------------------------------------------------------------------*/\nvoid lstrsub(TLSTR *to,\n             TLSTR *from,\n             int start,\n             int len)\n{\n  int i ;\n\n  if (start <= from->len)\n    {\n      i = from->len - start ;\n      if (len < i)\n        i = len ;       /* i is the length of the sub string */\n\n      if (!to)\n        serror(8,\"String does not exist\") ;\n      else\n        {\n          if (i > 0)\n            {\n              if (to->data == NULL)     /* does not exist yet ? */\n                {\n                  to->data = (char *)malloc(i) ;\n                  if (!to->data) serror(20,\n                    \"Not enough memory\") ;\n                }\n              else if (to->len != i)          /* wrong size ? */\n                {\n                  free((char *)to->data) ;\n                  to->data = (char *)malloc(i) ;\n                  if (!to->data) serror(10,\n                    \"Not enough memory\") ;\n                }\n              to->len = i ;\n              memcpy(to->data,from->data+start,i) ;\n            }\n          else\n            {\n              if (to->len > 0)   /* empty data */\n                free((char *)to->data) ;\n              to->len = 0 ;\n              to->data = NULL ;\n            }\n        }\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Find the position in a varying length string of a varying length  */\n/* sub-string.                                                       */\n/*-------------------------------------------------------------------*/\nint lstrindx(TLSTR *haystack, /* string to search */\n             TLSTR *needle)   /* sub-string to search for */\n{\n  int i, j, k, endpos ;\n\n  endpos = haystack->len - needle->len ;\n  for (i=0; i<endpos; i++)\n    {\n      k = 0 ;\n      for (j=0; j<needle->len; j++)\n        {\n          if (haystack->data\u00ddi+j\u00a8 == needle->data\u00ddj\u00a8)\n            k ++ ;\n          else break ;\n        }\n      if (k==needle->len)\n        return(i+1) ;\n    }\n  return 0 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Compare a varying length string with a string.                    */\n/*   rc = 0  == strings same                                         */\n/*   rc = 1  == lstr has larger value than charstr                   */\n/*   rc = -1 == lstr has smaller value than charstr                  */\n/*-------------------------------------------------------------------*/\nint lstrcmpc(TLSTR *lstr,   /* string to compare */\n             char *cstr)    /* characters to compare with */\n{\n  int i ;               /* counter */\n  int t=0 ;             /* compare flag */\n  int l ;               /* compare length */\n  int ld=0 ;            /* length differ flag */\n  char *lstrptr ;\n  char *cstrptr ;\n\n  l = strlen(cstr) ;    /* determine shortest string */\n  if (l != lstr->len)   /* same lengths ? */\n    {                   /*   no .. */\n      ld = 1 ;          /*   flag lengths differ */\n      if (l > lstr->len)\n        l = lstr->len ; /*   use shortest length */\n    }\n\n  /* compare to shortest length */\n  lstrptr = lstr->data ;\n  cstrptr = cstr ;\n  for (i=0; i<l; i++)\n    {\n      if (*lstrptr > *cstrptr)\n        {\n          t = 1 ;    /* indicate left larger than right */\n          break ;    /* end scan now  */\n        }\n      if (*lstrptr < *cstrptr)\n        {\n          t = -1 ;   /* indicate left smaller than right */\n          break ;    /* end scan now  */\n        }\n      lstrptr++ ;\n      cstrptr++ ;\n    }\n\n  if ((t==0) && (ld==1)) /* same after shortest length compared ? */\n    {\n      if (strlen(cstr) > lstr->len)\n        t = -1 ;     /* lstr smaller */\n      else\n        t = 1 ;      /* lstr larger */\n    }\n  return t ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Fill a varying length string with a string.                       */\n/*-------------------------------------------------------------------*/\nvoid lstrfill(TLSTR *string,   /* string to fill */\n              char *fillstr)  /* filler characters to use */\n{\n  int i ;\n  char *strptr ;\n\n  strptr = fillstr ;\n  for (i=0; i<=string->len; i++)\n    {\n      string->data\u00ddi\u00a8 = *(strptr++) ;\n      if (*strptr=='\\0')\n        strptr = fillstr ;    /* start over on fill string */\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Delete a varying length string (free associated memory).          */\n/*-------------------------------------------------------------------*/\nvoid lstrdel(TLSTR *string)   /* string to delete */\n{\n  free((char *)string->data) ;\n  string->data = NULL ;\n  string->len = 0 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Create a varying length string with multiple copies of a string.  */\n/*-------------------------------------------------------------------*/\nvoid lstrrep(TLSTR *string,\n             char *repstr,\n             int copies)\n{\n  int repstrlen ;\n  char *strptr ;\n  int newlen ;\n  int i ;\n\n  /* The input string that replications are made from is assumed */\n  /* to have a length of one or longer.                          */\n\n  repstrlen = strlen(repstr) ;\n  if (repstrlen==0)  /* assume repitition of 0x00 */\n    repstrlen = 1 ;\n  newlen = repstrlen * copies ;\n  if (string->data==NULL)          /* alloc storage ? */\n    {\n      string->data = (char *)malloc(newlen) ;\n      if (!string->data) serror(21,\"Not enough memory\") ;\n    }\n  else if (string->len!=newlen)    /* alloc more/less storage ? */\n    {\n      free((char *)string->data) ;\n      string->data = (char *)malloc(newlen) ;\n      if (!string->data) serror(11,\"Not enough memory\") ;\n    }\n  string->len = newlen ;     /* alter string length */\n  strptr = repstr ;\n  for (i=0; i<newlen; i++)        /* replicate the repstr data */\n    {\n      string->data\u00ddi\u00a8 = *strptr++ ;\n      if (*strptr == '\\0')\n        strptr = repstr ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Concatenate two varying length strings together placing the       */\n/* in a varying length string.                                       */\n/*-------------------------------------------------------------------*/\nvoid lstrcat(TLSTR *result,   /* result of concatenation */\n             TLSTR *left,     /* left string to concatenate */\n             TLSTR *right)    /* right string to concatenate */\n{\n  char *rstr ;\n  int newlen ;\n\n  newlen = left->len + right->len ;    /* extend LSTR */\n  rstr = (char *)malloc(newlen) ;\n  if (!rstr) serror(12,\"Not enough memory\") ;\n\n  memcpy(rstr,left->data,left->len) ;   /* make new string */\n  memcpy(rstr+left->len,right->data,right->len) ;\n\n  free((char *)result->data) ;   /* assemble new LSTR */\n  result->data = rstr ;\n  result->len = newlen ;\n}\n\n\n/*********************************************************************/\n/* General sub routines.                                             */\n/*   fill(haystack,fillchar,number)                                  */\n/*   dumpchar(buffer,length)                                         */\n/*   overlay(buffer,bufferlen,overlay,overlaylen,overlaypos)         */\n/*********************************************************************/\n\n/*-------------------------------------------------------------------*/\n/* Fill a character string with a number of filler characters.       */\n/*-------------------------------------------------------------------*/\nvoid fill(char *haystack,   /* area to fill */\n          char filler,      /* fill characters */\n          int num)          /* number of repetitions */\n{\n  int i = 0 ;\n  for(i=0;i<=num;i++)\n    *haystack++ = filler ;\n  *haystack = '\\0' ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Dump the contents of a buffer, formatted in a way that makes a    */\n/* 3270 data stream easier to interpret.                             */\n/*-------------------------------------------------------------------*/\nvoid dumpchar(char *dat,    /* data to dump */\n              int len)      /* length to dump */\n{\n  char *cptr ;\n  char c ;\n  char cc\u00dd3\u00a8 ;\n  int i ;\n  int n, m ;\n\n  n = 0 ;\n  m = 0 ;\n  cptr = dat ;\n  do\n    {\n      printf(\"      %.8X \",dat) ;\n      for(i=1;i<=16;i++)\n        {                   /* 0 indicates all */\n          if (*dat=='\\0' && len==0)\n            break ;\n          if (n==len && len>0)\n            break ;\n          c = *dat++ ;\n          n++ ;\n          printf(\"%.2X\",c) ;\n          if ((i%4)==0)\n            printf(\" \") ;\n        }\n      printf(\"\\n               \") ;\n\n      for(i=1;i<=16;i++)\n        {\n          if (*cptr=='\\0' && len==0)\n            break ;\n          if (m==len && len>0)\n            break ;\n          c = *cptr++ ;\n          m++ ;\n          if (c <= 0x3f || c==0xff)\n            {\n              switch (c)\n                {\n                  case GE:   strcpy(cc,\"GE\") ;\n                    break ;\n                  case FF:   strcpy(cc,\"FF\") ;\n                    break ;\n                  case CRR:  strcpy(cc,\"CR\") ;\n                    break ;\n                  case SBA:  strcpy(cc,\"SB\") ;\n                    break ;\n                  case EUA:  strcpy(cc,\"EU\") ;\n                    break ;\n                  case ICUR: strcpy(cc,\"IC\") ;\n                    break ;\n                  case NL:   strcpy(cc,\"NL\") ;\n                    break ;\n                  case EM:   strcpy(cc,\"EM\") ;\n                    break ;\n                  case DUP:  strcpy(cc,\"DU\") ;\n                    break ;\n                  case SF:   strcpy(cc,\"SF\") ;\n                    break ;\n                  case FM:   strcpy(cc,\"FM\") ;\n                    break ;\n                  case SA:   strcpy(cc,\"SA\") ;\n                    break ;\n                  case SFE:  strcpy(cc,\"SX\") ;\n                    break ;\n                  case MF:   strcpy(cc,\"MF\") ;\n                    break ;\n                  case RA:   strcpy(cc,\"RA\") ;\n                    break ;\n                  case SUB:  strcpy(cc,\"SU\") ;\n                    break ;\n                  default:   strcpy(cc,\". \") ;\n                    break ;\n                }\n              printf(\"%s\",cc) ;\n            }\n          else\n            printf(\"%c \",c) ;\n          if ((i%4)==0)\n            printf(\" \") ;\n        }\n      printf(\"\\n\") ;\n    }\n  while( ((*dat!='\\0') && (len==0)) ||\n         ((m!=len) && (len>20))\n       ) ;\n  printf(\"\\n\") ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Overlay characterc in a buffer.                                   */\n/*-------------------------------------------------------------------*/\nvoid overlay(char *haystack,    /* area to overlay */\n             int haylen,        /* length to overlay */\n             char *needle,      /* overlay characters */\n             int len,           /* length of overlay */\n             int pos)           /* start postition of overlay */\n{\n  int hlen, nlen ;   /* length of haystack and needle */\n  int i = 0 ;        /* itterator */\n\n  if (haylen==0)\n    hlen = strlen(haystack) ;\n  else\n    hlen = haylen ;\n\n  if (len==0)\n    nlen = strlen(needle) ;\n  else\n    nlen = len ;\n\n  if (hlen>(nlen+pos))\n    {\n      haystack = haystack+pos ;    /* move to overlay pos */\n      for(i=0;i<nlen;i++)          /* copy the data */\n        *haystack++ = *needle++ ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* General error message routine.                                    */\n/*-------------------------------------------------------------------*/\nvoid serror(int errno,\n            char *msg)\n{\n  printf(\"Error: %d - %s\\n\",errno,msg) ;\n  abort() ;\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "WINDOW32": {"ttr": 13063, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x95(\\x9f\\x00\\x95)\\x0f\\x11\"\\x0b\\x87\\n\\xd3\\x00\\x00\\xe2\\xc1\\xe2\\xc4\\xc4\\xc6@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1995-10-16T00:00:00", "modifydate": "1995-10-17T11:22:00", "lines": 2951, "newlines": 2771, "modlines": 0, "user": "SASDDF"}, "text": "#pragma eject\n#pragma title window32.C - display prototype for SAS 3270 windows\n\n/*+-----------------------------------------------------------------+\n  | Program:   window32.c                                           |\n  | Language:  c                                                    |\n  | Support:   DAF                                                  |\n  | Purpose:   To learn some full screen 3270 coding techniques to  |\n  |            use on the IBM 3270 display station.                 |\n  |                                                                 |\n  |            The following publications have been used in the     |\n  |            developement of this program:                        |\n  |              SC28-1875 TSO/E v2 programming Services            |\n  |              GA23-0059 3270 Info. Display Sys. Data Stream      |\n  |                        Programmers Reference.                   |\n  |              GA27-3831 3174 Establishment Controller Character  |\n  |                        Set Reference.                           |\n  |              GA27-2837 3270 Character Set Reference.            |\n  |              HUR 9058  IBM3270 Personal Computer Graphics       |\n  |                        Control Program Data Stream Reference.   |\n  |              GA18-2589 IBM 3179-G/3192-G Color Graphics Display |\n  |                        Station Description.                     |\n  |              GG27-6999 Introduction to Programming the IBM 3270.|\n  |                                                                 |\n  |            This programs main routine creates a simple notepad  |\n  |            window on the 3270. It uses routines to build the    |\n  |            notepad that support the creation, modification,     |\n  |            removal, and display of fields on the 3270 screen.   |\n  |            A screen is represented as linked list of fields.    |\n  |            These field routines can be viewed as an API that    |\n  |            the main program (application) uses to create windows|\n  |            on the 3270. The application is freed from managing  |\n  |            things like buffer address translation, and data     |\n  |            stream creation, and inbound data stream parsing.    |\n  |            Varying length strings are represented by the data   |\n  |            type LSTR. These strings can contain amy amount of   |\n  |            data including the null character.                   |\n  |                                                                 |\n  |            The following techniques have not been implemented   |\n  |            in this program but will be added later:             |\n  |            - Data stream compression using RBA.                 |\n  |            - Program symbol sets support.                       |\n  |            - Graphics support.                                  |\n  |                                                                 |\n  | Notes:     1. Numeric fields do not work the same on all        |\n  |               devices. The 3192-G allows lowercase character    |\n  |               input. Many devices also upper case character     |\n  |               input.                                            |\n  |            2. Most devices do not support field attributes:     |\n  |               Field Outlining, Background color, and Field      |\n  |               Validation.                                       |\n  |            3. The character set for APL does not appear to be   |\n  |               allowed on the SFE order, only on the SA order.   |\n  | End.                                                            |\n  +-----------------------------------------------------------------+*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <svc.h>\n#include <tput.h>\n#include <ostask.h>\n\n#define _AMODE31\n\n#include \"ps9x16u.inc\"\n#include \"ps9x15u.inc\"\n#include \"ps9x12u.inc\"\n\n/* escape character and device commands */\n#define ESC     0x27\n#define EW      0xf5\n#define EWA     0x7e\n#define WRT     0xf1\n#define WSF     0xf3\n#define RB      0xf2\n\n/* write control characters, or'd together as required */\n#define WCCMDT  0x01\n#define WCCKBD  0x02\n#define WCCRES  0xc0\n#define WCCBEL  0x04\n\n/* 3270 data stream orders */\n#define GE      0x08\n#define FF      0x0c\n#define CRR     0x0d\n#define SBA     0x11\n#define EUA     0x12\n#define ICUR    0x13\n#define NL      0x15\n#define EM      0x19\n#define DUP     0x1c\n#define SF      0x1d\n#define FM      0x1e\n#define SA      0x28\n#define SFE     0x29\n#define MF      0x2c\n#define RA      0x3c\n#define SUB     0x3f\n\n#define PROT    0x20\n#define NUM     0x10\n\n/* Type byte of the SA, SFE and MF orders */\n#define ALL     0x00\n#define NONE    0x00\n#define DFLT    0x00\n\n#define ATTR    0xc0\n#define FVALID  0xc1\n#define OUTLIN  0xc2\n#define HILITE  0x41\n#define COLOR   0x42\n#define SYMSET  0x43\n#define BAKCOL  0x45\n#define TRANSP  0x46\n\n#define APL     0xF1\n\n/* Out lines for the value byte of the SA, SFE, or MF order */\n#define UNDR    0x01\n#define OVR     0x04\n#define OVRUND  0x05\n#define NOOVR   0x0b\n#define NOUNDR  0x0e\n#define RECT    0x0f\n\n/* Hilites for the value byte of the SA, SFE, or MF order */\n#define BLINK   0xf1\n#define RVIDEO  0xf2\n#define USCORE  0xf4\n\n/* Colors for the value byte of the SA, SFE, or MF order */\n#define BLUE    0xf1\n#define RED     0xf2\n#define PINK    0xf3\n#define GREEN   0xf4\n#define TURQ    0xf5\n#define YELLOW  0xf6\n#define WHITE   0xf7\n\n/* Attribute for the value byte of the SF, SFE and MF order */\n#define UNPRT   0x40\n#define UNNUM   0x50\n#define UNNUMHI 0xd8\n#define UNNON   0x4c\n#define UNHI    0xc8\n#define PRT     0x60\n#define PRTHI   0xe4\n#define PRTAS   0xf0\n#define PRTHIAS 0xf8\n\n/* Attention Identification (AID) Values */\n#define NOAID   0x60\n#define NOAIDP  0xe8\n#define STRFLD  0x88\n#define ENTER   0x7d\n#define PF1     0xf1\n#define PF2     0xf2\n#define PF3     0xf3\n#define PF4     0xf4\n#define PF5     0xf5\n#define PF6     0xf6\n#define PF7     0xf7\n#define PF8     0xf8\n#define PF9     0xf9\n#define PF10    0x7a\n#define PF11    0x7b\n#define PF12    0x7c\n#define PF13    0xc1\n#define PF14    0xc2\n#define PF15    0xc3\n#define PF16    0xc4\n#define PF17    0xc5\n#define PF18    0xc6\n#define PF19    0xc7\n#define PF20    0xc8\n#define PF21    0xc9\n#define PF22    0x4a\n#define PF23    0x4b\n#define PF24    0x4c\n#define OID     0xe6\n#define MAG     0xe7\n#define PEN     0x7e\n#define PA1     0x6c\n#define PA2     0x6e\n#define PA3     0x6b\n#define CLEAR   0x6d\n#define SYSREQ  0xf0\n\ntypedef\n  struct LSTR     /* string with length */\n  {\n    int len ;             /* current length of data */\n    char *data ;          /* pointer to data */\n  } TLSTR ;\n\ntypedef\n  struct SFLD     /* 3270 screen field information list entry */\n  {\n    int fid ;             /* unique field identifier */\n    TLSTR fdata ;         /* field data (input or output) */\n    int fxpos ;           /* X column position */\n    int fypos ;           /* Y row position */\n    char fattr ;          /* 3270 field attribute */\n    char fcolor ;         /* 3270 color attribute */\n    char fhilite ;        /* 3270 hilite attribute */\n    char symbol ;         /* 0x00=normal 0xf1=APL else 0x40-0xef=PS */\n    struct SFLD *next ;   /* next list entry */\n  } TSFLD ;\n\n#define BUFFMAX 5000\nchar *buffer ;    /* buffer area for tput/tget */\n\nTSFLD *screen ;   /* root of 3270 screen field list */\n\n#define SFIDMAX 256\nTSFLD *sfidtab\u00ddSFIDMAX\u00a8 ; /* field id address table */\nint fidnext = 0 ;         /* next field id number to assign */\nint curcol = 1 ;          /* current cursor column */\nint currow = 1 ;          /* current cursor row */\nint bellflg = 0 ;         /* ring bell on next display */\nint iotrace = 0 ;         /* trace terminal I/O flag */\n\n\nstruct DCB        /* Device control block */\n  {\n    int model ;         /* model number ie: 3279, 3278, 3277 */\n    int type ;          /* model type ie: 2, 3, 4, 5 */\n    int rows ;          /* number of rows (height) on device */\n    int cols ;          /* number of columns (width) on device */\n    int celheigh ;      /* cell height on device */\n    int celwidth ;      /* cell width on device */\n    int colors ;        /* number of colors on device */\n    int colora ;        /* number of actual colors on device */\n    int hilites ;       /* number of colors on device */\n    int adrmode ;       /* device addressing mode: 12 or 14 or 16 bit*/\n    char unit ;         /* 0 = inch 1 = mm */\n    char edsflg ;       /* extended data stream flag */\n    char psflg ;        /* program symbols on device flag */\n    char altflg ;       /* use alternate flag */\n    char aplflg ;       /* 0 or apl's lcid=supports APL on device */\n    char graflg ;       /* graphics device flag */\n    char loadflg ;      /* loadable symbol sets supported flag */\n    char triflg ;       /* triple plane symbol sets supported flag */\n    char dbcsflg ;      /* double byte characters supported flag */\n    char colorlst\u00dd17\u00a8 ; /* list of color attributes on device */\n    char hilitlst\u00dd5\u00a8 ;  /* list of hilite attributes on device */\n    char modname\u00dd11\u00a8 ;  /* name of device ie: IBM32793B IBM3179G ..*/\n  } sdcb ;\n\n\n\n/*-------------------------------------------------------------------*/\n/* Function Prototypes                                               */\n/*-------------------------------------------------------------------*/\n\n/* field handling */\nint initscr() ;\nvoid termscr() ;\nchar dspflds() ;\nint insfld(TLSTR *, int, int, char, char, char) ;\nint getdev() ;\nint remflds() ;\nint delfld(int) ;\nint erasefld(int) ;\nint getfld(int, TLSTR *) ;\nint modfld(int, TLSTR *) ;\nint setfld(int, int, char) ;\nvoid dumpfld() ;\n/* 3270 support */\nint tputn(char *, int) ;\nint tgetn(char *, int) ;\nint tpgn(char *, int) ;\nvoid rc2sba(int, int, char *) ;\nvoid sba2rc(char *, int *, int *, int) ;\nint modsym(char *, char) ;\nint modcolor(char *, char) ;\nint modhilit(char *, char) ;\nint modattr(char *, char) ;\nint getterm(int *, int *, int *, int *, int *) ;\nint querydev() ;\nint dsummary(char *, short) ;\nint darea(char *, short) ;\nint dcharset(char *, short) ;\nint dcolor(char *, short) ;\nint dhilite(char *, short) ;\nint dmodes(char *, short) ;\nint dimpart(char *, short) ;\nint loadps1() ;\nvoid termstat() ;\nvoid clear() ;\n/* varying length string */\nvoid lstran(TLSTR *, char, char) ;\nint lstrlen(TLSTR *) ;\nvoid lstrload(TLSTR *, char *, int) ;\nint lstrunld(char *, TLSTR *) ;\nvoid lstrcopy(TLSTR *, TLSTR *) ;\nvoid lstrnew(TLSTR *, char *) ;\nvoid lstrsub(TLSTR *, TLSTR *, int, int) ;\nint lstrindx(TLSTR *, TLSTR *) ;\nvoid lstrfill(TLSTR *, char *) ;\nint lstrcmpc(TLSTR *, char *) ;\nvoid lstrdel(TLSTR *) ;\nvoid lstrrep(TLSTR *, char *, int) ;\nvoid lstrcat(TLSTR *, TLSTR *, TLSTR *) ;\n/* utility */\nvoid fill(char *, char, int) ;\nvoid dumpchar(char *, int) ;\nvoid overlay(char *, int, char *, int, int) ;\nvoid serror(int, char *) ;\n\n\n/* application routines */\nvoid buildwin() ;\nvoid dispwin() ;\nvoid winmsg(char *) ;\n\n/* variables for application */\nTLSTR msgstr  ;    /* current message varying length string */\nint msgfid ;       /* field identifier for message line */\nint bt ;           /* top border */\nint bb ;           /* bottom border */\nint bl ;           /* left border */\nint br ;           /* right border */\nint cmdflg = 0 ;   /* command flag = true if command done */\n\n /*-----------------------------------------------------------------*\n  | Main Program                                                    |\n  *-----------------------------------------------------------------*/\nvoid main(int argc, char **argv, char **envp)\n  {\n    int rc ;        /* return code */\n\n    rc = initscr() ;  /* initialise environment */\n    if (rc==0)         /* if env OK */\n      {\n        /* initial border positions */\n        bt = 1 ;            /* top border */\n        bb = sdcb.rows ;    /* bottom border */\n        bl = 1 ;            /* left border */\n        br = sdcb.cols ;    /* right border */\n\n        /* indicate cursor on command field and set field to blank */\n        cmdflg = 1 ;\n\n        winmsg(\"Note: PF3=End, PF1=Help.\") ;  /* set initial message */\n        buildwin() ;  /* build the initial display window */\n        dispwin() ;   /* display the window and run appl. */\n\n        termscr() ;   /* terminate environment */\n      }\n  }\n\n\n/*-------------------------------------------------------------------*/\n/* Build a window with a title, command line and an edit space.      */\n/*-------------------------------------------------------------------*/\nvoid buildwin()\n  {\n    int t, tl ;                /* temp */\n    int i ;                    /* counter */\n    int fid ;                  /* field identifier handle */\n    TLSTR data, data1, data2, data3, data4 ; /* temp varying strings */\n    TLSTR title ;              /* title string */\n\n    /* create title line */\n    lstrnew(&title,\" WINDOW32: SAS window prototype \");\n\n    /* create command line (prompt, input area, and help) */\n    lstrnew(&data,\"FIle\") ;   /* create VLstring */\n    fid = insfld(&data,bt+1,bl+2,UNPRT,WHITE,NONE);\n    lstrnew(&data,\"Edit\") ;   /* create VLstring */\n    fid = insfld(&data,bt+1,bl+7,UNPRT,WHITE,NONE);\n    lstrnew(&data,\"Focus\") ;   /* create VLstring */\n    fid = insfld(&data,bt+1,bl+12,UNPRT,WHITE,NONE);\n    if ((br-bl)>18)\n      {\n        lstrnew(&data,\"NoFocus\") ;   /* create VLstring */\n        fid = insfld(&data,bt+1,bl+18,UNPRT,WHITE,NONE);\n        lstrnew(&data,\"Globals\") ;   /* create VLstring */\n        fid = insfld(&data,bt+1,bl+26,UNPRT,WHITE,NONE);\n        lstrnew(&data,\"Help\") ;   /* create VLstring */\n        fid = insfld(&data,bt+1,bl+34,UNPRT,WHITE,NONE);\n      }\n    else\n      {\n        lstrnew(&data,\"NoFocus\") ;   /* create VLstring */\n        fid = insfld(&data,bt+1,bl+18,UNPRT,WHITE,NONE);\n        lstrnew(&data,\"Globals\") ;   /* create VLstring */\n        fid = insfld(&data,bt+1,bl+26,UNPRT,WHITE,NONE);\n        lstrnew(&data,\"Help\") ;   /* create VLstring */\n        fid = insfld(&data,bt+1,bl+34,UNPRT,WHITE,NONE);\n      }\n\n    /*----------------------------------------------------------------*/\n    /* Create top window border                                       */\n    /*   The border outline is drawn with different characters        */\n    /*     based on the devices abilities.                            */\n    /*   Window border locations are based on four global variables:  */\n    /*     bt - top border row                                        */\n    /*     bb - bottom border row                                     */\n    /*     br - right border column                                   */\n    /*     bl - left border column                                    */\n    /*----------------------------------------------------------------*/\n    if (sdcb.loadflg)\n      {\n        /* top left cnr */\n        lstrnew(&data1,\"\\x49\\x47\\x72\") ;\n        /* top right cnr */\n        lstrnew(&data2,\"\\x48\\x72\\x46\\x72\\x45\\x72\\x52\\x9e\") ;\n        lstrnew(&data3,\" \") ;\n        lstran(&title,0x40,0x48) ;      /* translate in PS blank char */\n        tl = lstrlen(&title) ; /* actual title length */\n        t = br-bl-10;           /* available space */\n        if (tl>t)\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrsub(&data3,&title,1,t-1) ; /* shorten title */\n            lstrcat(&data,&data,&data3) ;  /* add title */\n            lstrcat(&data,&data,&data2) ;  /* add right border */\n          }\n        else\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrcat(&data,&data,&title) ;  /* add title */\n            lstrrep(&data3,\"\\x9f\",t-tl-1) ;/* repeat char to string */\n            lstrcat(&data,&data,&data3) ;  /* add top border chars */\n            lstrcat(&data,&data,&data2) ;  /* concat strings */\n          }\n        fid = insfld(&data,bt,bl,PRTAS,BLUE,NONE);\n        if (fid<0) serror(81,\"Field insert failed\") ;\n        setfld(fid,SYMSET,0x40) ;   /* make it id of PS symbols */\n      }\n    else if (sdcb.aplflg)\n      {\n        /* top left corner */\n        lstrnew(&data1,\"\\xc5\\xba\\xa2\") ;\n        /* top left corner */\n        lstrnew(&data2,\"\\xa2\\xa2\\xca\\xa2\\xcb\\xa2\\x90\\xd5\") ;\n        tl = lstrlen(&title) ; /* actual title length */\n        t = br-bl-10 ;           /* available space */\n        if (tl>t)\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrsub(&data4,&title,1,t-1) ; /* shorten title */\n            lstrnew(&data3,\"\\x28\\x43\\x01\") ;  /* stop APL chars */\n            lstran(&data3,0x01,0x00) ; /* translate 0x01 to ox00 */\n            lstrcat(&data,&data,&data3) ;  /* add stop APL */\n            lstrcat(&data,&data,&data4) ;  /* add title */\n            lstrnew(&data3,\"\\x28\\x43\\xf1\") ;  /* start APL */\n            lstrcat(&data,&data,&data3) ;  /* add start APL */\n            lstrcat(&data,&data,&data2) ;  /* add right border */\n          }\n        else\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrnew(&data3,\"\\x28\\x43\\x01\") ;  /* stop APL chars */\n            lstran(&data3,0x01,0x00) ; /* translate 0x01 to ox00 */\n            lstrcat(&data,&data,&data3) ;  /* add stop APL */\n            lstrcat(&data,&data,&title) ;  /* add title */\n            lstrnew(&data3,\"\\x28\\x43\\xf1\") ;  /* start APL */\n            lstrcat(&data,&data,&data3) ;  /* add start APL */\n            lstrrep(&data3,\"s\",t-tl-1) ;   /* repeat char to string */\n            lstrcat(&data,&data,&data3) ;  /* add top border chars */\n            lstrcat(&data,&data,&data2) ;  /* concat strings */\n          }\n        fid = insfld(&data,bt,bl,PRTAS,BLUE,NONE);\n        if (fid<0) serror(81,\"Field insert failed\") ;\n        setfld(fid,SYMSET,APL) ; /* make it APL */\n      }\n    else\n      {\n        lstrnew(&data1,\"+#-\") ;     /* create VLstring */\n        lstrnew(&data2,\"--V-A-X+\") ;   /* create VLstring */\n        lstrnew(&data3,\" \") ;\n        tl = lstrlen(&title) ;     /* actual title length */\n        t = br-bl-10 ;              /* available space */\n        if (tl>t)\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrsub(&data4,&title,1,t-1) ; /* shorten title */\n            lstrcat(&data,&data,&data4) ;  /* add title */\n            lstrcat(&data,&data,&data2) ;  /* add right border */\n          }\n        else\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrcat(&data,&data,&title) ;  /* add title */\n            lstrrep(&data3,\"-\",t-tl-1) ;   /* repeat char to string */\n            lstrcat(&data,&data,&data3) ;  /* add top border chars */\n            lstrcat(&data,&data,&data2) ;  /* concat strings */\n          }\n        fid = insfld(&data,bt,bl,PRTAS,BLUE,NONE);\n        if (fid<0) serror(81,\"Field insert failed\") ;\n      }\n\n    /* create edit area lines and left and right borders */\n    for (i=bt+1; i<=bb-1; i++)    /* edit area fields */\n      {\n        /* add left border */\n        if (sdcb.loadflg)\n          {\n            lstrnew(&data,\"\\x71\") ;\n            fid = insfld(&data,i,bl,PRTAS,BLUE,NONE) ;\n            if (fid<0) serror(81,\"Field insert failed\") ;\n            setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n          }\n        else if (sdcb.aplflg)\n          {\n            lstrnew(&data,\"e\") ;\n            fid = insfld(&data,i,bl,PRTAS,BLUE,NONE) ;\n            if (fid<0) serror(81,\"Field insert failed\") ;\n            setfld(fid,SYMSET,APL) ; /* make it APL */\n          }\n        else\n          {\n            lstrnew(&data,\"|\") ;\n            fid = insfld(&data,i,bl,PRTAS,BLUE,NONE) ;\n            if (fid<0) serror(81,\"Field insert failed\") ;\n          }\n\n        if (i> (bt+2))   /* if beyond title/command/msg area */\n          {\n            /* add text input area */\n            lstrnew(&data,\" \") ;\n            fid = insfld(&data,i,bl+2,UNHI,GREEN,NONE) ;\n            if (fid<0) serror(81,\"Field insert failed\") ;\n          }\n\n        /* add right border */\n        if (sdcb.loadflg)\n          {\n            lstrnew(&data,\"\\x71\") ;\n            fid = insfld(&data,i,br-1,PRTAS,BLUE,NONE) ;\n            if (fid<0) serror(81,\"Field insert failed\") ;\n            setfld(fid,SYMSET,0x40) ; /* make it loaded PS symbols */\n          }\n        else if (sdcb.aplflg)\n          {\n            lstrnew(&data,\"e\") ;\n            fid = insfld(&data,i,br-1,PRTAS,BLUE,NONE) ;\n            if (fid<0) serror(81,\"Field insert failed\") ;\n            setfld(fid,SYMSET,APL) ; /* make it APL */\n          }\n        else\n          {\n            lstrnew(&data,\"|\") ;\n            fid = insfld(&data,i,br-1,PRTAS,BLUE,NONE) ;\n            if (fid<0) serror(81,\"Field insert failed\") ;\n          }\n      }  /* of for edit area lines */\n\n    /* create bottom border - following code is in winmsg() as well */\n    if (sdcb.loadflg)\n      {\n        lstrnew(&data1,\"\\x9c\\x72\") ;   /* lower left corner */\n        lstrnew(&data2,\"\\x72\\x51\") ;   /* lower right corner */\n        lstrnew(&data3,\" \") ;\n        lstran(&msgstr,0x40,0x48) ;  /* translate in PS blank char */\n        tl = lstrlen(&msgstr) ; /* actual msg length */\n        t = br-bl-3 ;           /* available space */\n        if (tl>t)\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrsub(&data3,&msgstr,1,t-1) ; /* shorten title */\n            lstrcat(&data,&data,&data3) ;  /* add title */\n            lstrcat(&data,&data,&data2) ;  /* add right border */\n          }\n        else\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrcat(&data,&data,&msgstr) ;  /* add title */\n            lstrrep(&data3,\"\\x48\",t-tl-1) ;/* repeat char to string */\n            lstrcat(&data,&data,&data3) ;  /* add top border chars */\n            lstrcat(&data,&data,&data2) ;  /* concat strings */\n          }\n        msgfid = insfld(&data,bb,bl,PRTAS,BLUE,NONE) ;\n        if (fid<0) serror(81,\"Field insert failed\") ;\n        setfld(msgfid,SYMSET,0x40) ; /* make it loaded PS symbols */\n      }\n    else if (sdcb.aplflg)\n      {\n        lstrnew(&data1,\"D\") ;          /* lower left corner */\n        lstrnew(&data2,\"M\") ;          /* lower right corner */\n        tl = lstrlen(&msgstr) ; /* actual title length */\n        t = br-bl-5 ;           /* available space */\n        if (tl>t)\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrsub(&data4,&msgstr,1,t-1) ; /* shorten title */\n            lstrnew(&data3,\"\\x28\\x43\\x01\") ;  /* stop APL chars */\n            lstran(&data3,0x01,0x00) ; /* translate 0x01 to ox00 */\n            lstrcat(&data,&data,&data3) ;  /* add stop APL */\n            lstrcat(&data,&data,&data4) ;  /* add title */\n            lstrnew(&data3,\"\\x28\\x43\\xf1\") ;  /* start APL */\n            lstrcat(&data,&data,&data3) ;  /* add start APL */\n            lstrcat(&data,&data,&data2) ;  /* add right border */\n          }\n        else\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrnew(&data3,\"\\x28\\x43\\x01\") ;  /* stop APL chars */\n            lstran(&data3,0x01,0x00) ; /* translate 0x01 to ox00 */\n            lstrcat(&data,&data,&data3) ;  /* add stop APL */\n            lstrcat(&data,&data,&msgstr) ;  /* add title */\n            lstrnew(&data3,\"\\x28\\x43\\xf1\") ;  /* start APL */\n            lstrcat(&data,&data,&data3) ;  /* add start APL */\n            lstrrep(&data3,\"s\",t-tl-1) ;   /* repeat char to string */\n            lstrcat(&data,&data,&data3) ;  /* add top border chars */\n            lstrcat(&data,&data,&data2) ;  /* concat strings */\n          }\n        msgfid = insfld(&data,bb,bl,PRTAS,BLUE,NONE) ;\n        if (fid<0) serror(81,\"Field insert failed\") ;\n        setfld(msgfid,SYMSET,APL) ; /* make it APL */\n      }\n    else\n      {\n        lstrnew(&data1,\"+\") ;          /* lower left corner */\n        lstrnew(&data2,\"+\") ;          /* lower right corner */\n        lstrnew(&data3,\" \") ;\n        tl = lstrlen(&msgstr) ;     /* actual title length */\n        t = br-bl-5 ;              /* available space */\n        if (tl>t)\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrsub(&data4,&msgstr,1,t-1) ; /* shorten title */\n            lstrcat(&data,&data,&data4) ;  /* add title */\n            lstrcat(&data,&data,&data2) ;  /* add right border */\n          }\n        else\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrcat(&data,&data,&msgstr) ;  /* add title */\n            lstrrep(&data3,\"-\",t-tl-1) ;   /* repeat char to string */\n            lstrcat(&data,&data,&data3) ;  /* add top border chars */\n            lstrcat(&data,&data,&data2) ;  /* concat strings */\n          }\n        msgfid = insfld(&data,bb,bl,PRTAS,BLUE,NONE) ;\n        if (fid<0) serror(81,\"Field insert failed\") ;\n      }\n\n  }\n\n/*-------------------------------------------------------------------*/\n/* Display the window and process the keys/commands entered.         */\n/*-------------------------------------------------------------------*/\nvoid winmsg(char *msg)\n  {\n    int t, tl ;                /* temp */\n    TLSTR data, data1, data2, data3, data4 ; /* temp varying strings */\n\n    lstrnew(&msgstr,msg) ;\n    if (sdcb.loadflg)\n      {\n        lstrnew(&data1,\"\\x9c\\x72\") ;   /* lower left corner */\n        lstrnew(&data2,\"\\x72\\x51\") ;   /* lower right corner */\n        lstrnew(&data3,\" \") ;\n        lstran(&msgstr,0x40,0x48) ;  /* translate in PS blank char */\n        tl = lstrlen(&msgstr) ; /* actual msg length */\n        t = br-bl-3 ;           /* available space */\n        if (tl>t)\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrsub(&data3,&msgstr,1,t-1) ; /* shorten title */\n            lstrcat(&data,&data,&data3) ;  /* add title */\n            lstrcat(&data,&data,&data2) ;  /* add right border */\n          }\n        else\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrcat(&data,&data,&msgstr) ;  /* add title */\n            lstrrep(&data3,\"\\x48\",t-tl-1) ;/* repeat char to string */\n            lstrcat(&data,&data,&data3) ;  /* add top border chars */\n            lstrcat(&data,&data,&data2) ;  /* concat strings */\n          }\n      }\n    else if (sdcb.aplflg)\n      {\n        lstrnew(&data1,\"D\") ;          /* lower left corner */\n        lstrnew(&data2,\"M\") ;          /* lower right corner */\n        tl = lstrlen(&msgstr) ; /* actual title length */\n        t = br-bl-5 ;           /* available space */\n        if (tl>t)\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrsub(&data4,&msgstr,1,t-1) ; /* shorten title */\n            lstrnew(&data3,\"\\x28\\x43\\x01\") ;  /* stop APL chars */\n            lstran(&data3,0x01,0x00) ; /* translate 0x01 to ox00 */\n            lstrcat(&data,&data,&data3) ;  /* add stop APL */\n            lstrcat(&data,&data,&data4) ;  /* add title */\n            lstrnew(&data3,\"\\x28\\x43\\xf1\") ;  /* start APL */\n            lstrcat(&data,&data,&data3) ;  /* add start APL */\n            lstrcat(&data,&data,&data2) ;  /* add right border */\n          }\n        else\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrnew(&data3,\"\\x28\\x43\\x01\") ;  /* stop APL chars */\n            lstran(&data3,0x01,0x00) ; /* translate 0x01 to ox00 */\n            lstrcat(&data,&data,&data3) ;  /* add stop APL */\n            lstrcat(&data,&data,&msgstr) ;  /* add title */\n            lstrnew(&data3,\"\\x28\\x43\\xf1\") ;  /* start APL */\n            lstrcat(&data,&data,&data3) ;  /* add start APL */\n            lstrrep(&data3,\"s\",t-tl-1) ;   /* repeat char to string */\n            lstrcat(&data,&data,&data3) ;  /* add top border chars */\n            lstrcat(&data,&data,&data2) ;  /* concat strings */\n          }\n      }\n    else\n      {\n        lstrnew(&data1,\"+\") ;          /* lower left corner */\n        lstrnew(&data2,\"+\") ;          /* lower right corner */\n        lstrnew(&data3,\" \") ;\n        tl = lstrlen(&msgstr) ;     /* actual title length */\n        t = br-bl-5 ;              /* available space */\n        if (tl>t)\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrsub(&data4,&msgstr,1,t-1) ; /* shorten title */\n            lstrcat(&data,&data,&data4) ;  /* add title */\n            lstrcat(&data,&data,&data2) ;  /* add right border */\n          }\n        else\n          {\n            lstrcopy(&data,&data1) ;       /* add left border */\n            lstrcat(&data,&data,&msgstr) ;  /* add title */\n            lstrrep(&data3,\"-\",t-tl-1) ;   /* repeat char to string */\n            lstrcat(&data,&data,&data3) ;  /* add top border chars */\n            lstrcat(&data,&data,&data2) ;  /* concat strings */\n          }\n      }\n    modfld(msgfid,&data) ;\n  }\n\n\n/*-------------------------------------------------------------------*/\n/* Display the window and process the keys/commands entered.         */\n/*-------------------------------------------------------------------*/\nvoid dispwin()\n  {\n    TLSTR command ;      /* command name varying length string */\n    char key ;           /* AID for the key just pressed */\n\n    lstrnew(&command,\" \") ;\n    while(lstrcmpc(&command,\"end\") != 0)\n      {\n        if (cmdflg)\n          {\n            /* set initial cursor row and col to the command field */\n            currow = bt + 1 ;\n            curcol = bl + 16 ;\n            /* blank out the command line */\n            lstrnew(&command,\" \") ;\n            cmdflg = 0 ;\n          }\n        key = dspflds() ;     /* display the screen and get aid=key */\n\n        /* Process function keys PFKs */\n        switch (key)\n          {\n            case ENTER:\n              if (currow == bt) /* window border accelerators */\n                {\n                  if (curcol == (bl+2))  /* close window */\n                    {\n                      winmsg(\"Not implememented of course.\") ;\n                    }\n                  else if (curcol == (br-5))  /* minimise window */\n                    {\n                      bt = 1 ;\n                      bl = 1 ;\n                      br = 40 ;\n                      bb = 6 ;\n                      remflds() ;\n                      buildwin() ;  /* re-build the display window */\n                    }\n                  else if (curcol == (br-3))  /* maximise window */\n                    {\n                      bt = 1 ;\n                      bl = 1 ;\n                      br = sdcb.cols ;\n                      bb = sdcb.rows ;\n                      remflds() ;\n                      buildwin() ;  /* re-build the display window */\n                    }\n                  else if (curcol == (br-1))  /* maximise window */\n                    {\n                      lstrnew(&command,\"end\") ;\n                    }\n                }\n              else if (currow == bt+1) /* menu words */\n                {\n                  if ((curcol >= (bl+2)) &&   /* FILE = close window */\n                      (curcol <= (bl+5)) )\n                    {\n                      lstrnew(&command,\"end\") ;\n                    }\n                  else if ((curcol >= (bl+7)) &&   /* EDIT = nothong */\n                          (curcol <= (bl+10)) )\n                    {\n                      lstrnew(&command,\"termstat\") ;\n                    }\n                  else if ((curcol >= (bl+12)) && /* FOCUS */\n                          (curcol <= (bl+16)) )\n                    {\n                      winmsg(\"Focus set on.\") ;\n                    }\n                  else if ((curcol >= (bl+18)) && /* NOFOCUS */\n                          (curcol <= (bl+24)) )\n                    {\n                      winmsg(\"Focus set off.\") ;\n                    }\n                  else if ((curcol >= (bl+26)) && /* GLOBALS */\n                          (curcol <= (bl+32)) )\n                    {\n                      winmsg(\"Not implememented of course.\") ;\n                    }\n                  else if ((curcol >= (bl+34)) && /* HELP */\n                          (curcol <= (bl+37)) )\n                    {\n                      winmsg(\"Press PF1 for more help.\") ;\n                    }\n                }\n              break ;\n            case PF1:    /* No help message */\n              winmsg(\n                \"Move border: PF23=Top PF11=Bottom PF10=Left PF12=Right\"\n                ) ;\n              break ;\n            case PF3:    /* Generate end command */\n            case PF15:   /* Alternate generate end command */\n              lstrnew(&command,\"end\") ;\n              break ;\n\n            case PF10:   /* move left border */\n              if ((curcol<(br-25)) &&\n                  (curcol>=1) )\n                {\n                  bl = curcol-1 ; /* adjust for attr byte */\n                  remflds() ;\n                  buildwin() ;  /* re-build the display window */\n                }\n              else\n                winmsg(\"Left border move position too far.\") ;\n              break ;\n\n            case PF11:   /* move bottom border */\n              if ((currow>(bt+8)) &&\n                  (currow<=sdcb.rows) )\n                {\n                  bb = currow ;\n                  remflds() ;\n                  buildwin() ;  /* re-build the display window */\n                }\n              else\n                winmsg(\"Bottom border move position too far.\") ;\n              break ;\n\n            case PF12:   /* move right border */\n              if ((curcol>(bl+25)) &&\n                 (curcol<=sdcb.cols) )\n                {\n                  br = curcol-1 ;  /* adjust for attr byte */\n                  remflds() ;\n                  buildwin() ;  /* re-build the display window */\n                }\n              else\n                winmsg(\"Right border move position too far.\") ;\n              break ;\n\n            case PF23:   /* move top border */\n              if ((currow<(bb-8)) &&\n                  (currow>=1) )\n                {\n                  bt = currow ;\n                  remflds() ;\n                  buildwin() ;  /* re-build the display window */\n                }\n              else\n                winmsg(\"Top border move position too far.\") ;\n              break ;\n\n            case PF24:   /* zoom to max window size */\n              bt = 1 ;\n              bl = 1 ;\n              br = sdcb.cols ;\n              bb = sdcb.rows ;\n              remflds() ;\n              buildwin() ;  /* re-build the display window */\n              break ;\n\n            case PA2:    /* reshow key does nothing - yet */\n              break ;\n\n            default:     /* any other key is not valid */\n              bellflg = 1 ;  /* sound alarm */\n              winmsg(\"Invalid function key.\") ;\n              break ;\n          }\n\n        /* Process command from the command line */\n        if (lstrcmpc(&command,\"test\") == 0)   /* test command */\n          {\n            winmsg(\"The test command was entered.\") ;\n            cmdflg = 1 ;  /* reset command line */\n          }\n        else if (lstrcmpc(&command,\"dump\") == 0)  /* dump command */\n          {\n            dumpfld() ;\n            winmsg(\"Dump command executed.\") ;\n            cmdflg = 1 ;  /* reset command line */\n          }\n        else if (lstrcmpc(&command,\"load\") == 0)  /* force load PS */\n          {\n            loadps1() ;\n            winmsg(\"Load PS type 1 command executed.\") ;\n            cmdflg = 1 ;  /* reset command line */\n          }\n        else if (lstrcmpc(&command,\"termstat\") == 0) /*dump term data*/\n          {\n            termstat() ;\n            winmsg(\"Terminal status printed.\") ;\n            cmdflg = 1 ;  /* reset command line */\n          }\n        else if (lstrcmpc(&command,\"traceon\") == 0) /* trace on */\n          {\n            iotrace = 1 ;\n            winmsg(\"Trace is on.\") ;\n            cmdflg = 1 ;  /* reset command line */\n          }\n        else if (lstrcmpc(&command,\"traceoff\") == 0) /* trace off */\n          {\n            iotrace = 0 ;\n            winmsg(\"Trace is off.\") ;\n            cmdflg = 1 ;  /* reset command line */\n          }\n\n      }   /* of while command not end */\n    clear() ;   /* clear the 3270 screen */\n  }\n\n\n/*********************************************************************/\n/* 3270 field handling routines                                      */\n/*   rc = initscr()                                                  */\n/*   termscr()                                                       */\n/*   fid = insfld(data,row,col,attr,color,hilite)                    */\n/*   rc = remflds()                                                  */\n/*   rc = delfld(fid)                                                */\n/*   rc = erasefld(fid)                                              */\n/*   rc = getfld(fid,returndata)                                     */\n/*   rc = modfld(fid,newdata)                                        */\n/*   rc = setfld(fid,attrtype,attrvalue)                             */\n/*   dumpflds()                                                      */\n/*                                                                   */\n/*********************************************************************/\n\n\n/*-------------------------------------------------------------------*/\n/* Set up the screen environment.                                    */\n/*-------------------------------------------------------------------*/\nint initscr()\n{\n    int rc = 0 ;\n\n    buffer = (char *)malloc(BUFFMAX) ;  /* alloc tput/get buffer */\n    if (buffer)\n      {\n        rc = getdev() ;  /* get3270 device information */\n        if (rc==0 && sdcb.loadflg==1)\n          loadps1() ;\n      }\n    else\n      rc = 1 ;   /* could not get buffer */\n\n    return rc ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Terminate screen environment.                                     */\n/*-------------------------------------------------------------------*/\nvoid termscr()\n{\n    if (screen)\n      remflds() ;       /* remove any remaining fields */\n\n    free((char *)buffer) ;  /* remove tput/get buffer */\n}\n\n/*-------------------------------------------------------------------*/\n/* Display current contents of the 3270 field list.                  */\n/*-------------------------------------------------------------------*/\nchar dspflds()\n{\n  TSFLD *curr ;\n  int rc, bufpos, trow = 0, tcol = 0, fstart, fend, ilen ;\n  char sba\u00dd2\u00a8 ;\n  char aid ;\n\n  /* assemble buffer, it will contain: (EW WCC) followed by all  */\n  /* the display fields. Each field will contain:                */\n  /*   (SFE 0x03 0xC0 fattr HILITE fhilite COLOR fcolor data)    */\n  if (sdcb.altflg)\n    buffer\u00dd0\u00a8 = EWA ;     /* erase write alternate */\n  else\n    buffer\u00dd0\u00a8 = EW ;      /* erase write */\n\n  /* determine if the bell should be rung */\n  if (bellflg)\n    {\n      buffer\u00dd1\u00a8 = WCCRES | WCCKBD | WCCMDT | WCCBEL ;\n      bellflg = 0 ;  /* turn bell flag off, one ring only */\n    }\n  else\n    buffer\u00dd1\u00a8 = WCCRES | WCCKBD | WCCMDT ;\n\n  bufpos = 2 ;\n  curr = screen ;     /* first node in field list */\n  while (curr)\n    {\n      buffer\u00ddbufpos++\u00a8 = SBA ;  /* set buffer address */\n      rc2sba(curr->fypos,curr->fxpos,sba) ;\n      buffer\u00ddbufpos++\u00a8 = sba\u00dd0\u00a8 ;\n      buffer\u00ddbufpos++\u00a8 = sba\u00dd1\u00a8 ;\n      if (sdcb.edsflg)\n        {\n          buffer\u00ddbufpos++\u00a8 = SFE ;  /* start field extended */\n          buffer\u00ddbufpos++\u00a8 = 0x03 ;\n          buffer\u00ddbufpos++\u00a8 = 0xc0 ;\n          buffer\u00ddbufpos++\u00a8 = curr->fattr ;\n          buffer\u00ddbufpos++\u00a8 = HILITE ;\n          buffer\u00ddbufpos++\u00a8 = curr->fhilite ;\n          buffer\u00ddbufpos++\u00a8 = COLOR ;\n          buffer\u00ddbufpos++\u00a8 = curr->fcolor ;\n\n          /* insert set character attribute before data if APL/PS syms*/\n          /* are required and the field has protection turned on.     */\n          if (((curr->symbol==APL) || (curr->symbol==0x40)) /*APL/PS*/\n            && (curr->fattr & 0x40)) /* and protected field */\n            {\n              buffer\u00ddbufpos++\u00a8 = SA ;           /* set attribute */\n              buffer\u00ddbufpos++\u00a8 = SYMSET ;       /* symbol */\n              if (curr->symbol==APL) /* APL ? */\n                buffer\u00ddbufpos++\u00a8 = sdcb.aplflg ; /* use APL's lcid */\n              else\n                buffer\u00ddbufpos++\u00a8 = curr->symbol ; /* use symbol value */\n            }\n        }\n      else    /* dont used extended data stream */\n        {\n          buffer\u00ddbufpos++\u00a8 = SF ;  /* start field */\n          buffer\u00ddbufpos++\u00a8 = curr->fattr ;\n        }\n\n      /* insert field data */\n      ilen = lstrunld(&buffer\u00ddbufpos\u00a8,&curr->fdata) ;\n      bufpos = bufpos + ilen ;\n\n      /* revert to standard symbols after APL/PS data symbols  */\n      if (((curr->symbol==APL) || (curr->symbol==0x40)) /*APL/PS*/\n        && (curr->fattr & 0x40)) /* and protected field */\n        {\n          buffer\u00ddbufpos++\u00a8 = SA ;       /* set attribute */\n          buffer\u00ddbufpos++\u00a8 = SYMSET ;   /* symbol */\n          buffer\u00ddbufpos++\u00a8 = DFLT ;     /* revert to default symbols */\n        }\n\n      curr = curr->next ;  /* go to next field */\n    }\n\n  /* insert the cursor in the same location the user left it */\n  buffer\u00ddbufpos++\u00a8 = SBA ;     /* add set buffer address order */\n  rc2sba(currow,curcol,sba) ;  /* determine SBA for current row/col */\n  buffer\u00ddbufpos++\u00a8 = sba\u00dd0\u00a8 ;  /* add buffer addr part 1 */\n  buffer\u00ddbufpos++\u00a8 = sba\u00dd1\u00a8 ;  /* add buffer addr part 2 */\n  buffer\u00ddbufpos++\u00a8 = ICUR ;    /* add insert cursor order */\n\n  /* dumpchar(buffer,bufpos) ; */\n\n  /* write buffer to the 3270 */\n  rc = tputn(buffer, bufpos) ;\n\n  fill(buffer,0x00,bufpos) ;\n  /* receive the response from the user */\n  rc = tgetn(buffer, BUFFMAX ) ;\n\n  /* decode input, should be an AID, a cursor pos bufferaddr */\n  /* and a list of fields (SBA addr1 addr2 data)             */\n\n  aid = buffer\u00dd0\u00a8 ;      /* get code of key that was pressed */\n  sba\u00dd0\u00a8 = buffer\u00dd1\u00a8 ;\n  sba\u00dd1\u00a8 = buffer\u00dd2\u00a8 ;\n  sba2rc(sba,&currow,&curcol,0) ;  /* convert and store cursor pos */\n                                   /* adjust = 0 used for cursor pos */\n\n  curr = screen ;\n  fstart = 0 ;\n  bufpos = 3 ;\n  while(bufpos<=BUFFMAX)\n    {\n      if (buffer\u00ddbufpos\u00a8==SBA)\n        {\n          /* get new buffer address */\n          bufpos++ ;\n          sba\u00dd0\u00a8 = buffer\u00ddbufpos++\u00a8 ;\n          sba\u00dd1\u00a8 = buffer\u00ddbufpos++\u00a8 ;\n          sba2rc(sba,&trow,&tcol,1) ; /* convert buf.addr to row/col */\n                              /* adjust = 1 used for retn. buf. addr */\n          fstart = bufpos ;\n\n          /* locate field by r/c then write data to field list entry */\n          while( !((curr->fxpos==tcol) && (curr->fypos==trow)) )\n            {                          /* locate */\n              curr = curr->next ;\n              if (!curr) break ; /* could not locate - real bad */\n            }\n\n          if (curr)    /* found field - copy the data into it */\n            {\n              /* first locate end of data */\n              fend = fstart ;\n              while ((buffer\u00ddfend\u00a8 != SBA) &&\n                     (buffer\u00ddfend\u00a8 != 0x00))\n                fend++ ;  /* leaves fend pointing at next char. */\n\n              /* copy data from buffer into field list */\n              ilen = fend - fstart ;\n              lstrload(&curr->fdata,&buffer\u00ddfstart\u00a8,ilen) ;\n\n              /* adjust bufpos to last char of this returned SBA */\n              bufpos = fend -1 ;\n            }\n          else\n            {\n              /* SEVERE ERROR: This should never happen */\n              printf(\"No locate field: row %d col %d SBA %.2X %.2X\\n\",\n                trow,tcol,sba\u00dd0\u00a8,sba\u00dd1\u00a8) ;\n              curr = screen ;  /* further searches from top */\n            }\n        }\n      else\n        bufpos++ ;   /* advance to next char */\n    }\n\n  return aid ;    /* data returned OK */\n}\n\n\n/*-------------------------------------------------------------------*/\n/* Dump field list to stdout.                                        */\n/*-------------------------------------------------------------------*/\nvoid dumpfld()\n{\n  TSFLD *curr ;\n  int i = 0, size = 0 ;\n  char sba\u00dd2\u00a8 ;\n\n  printf(\"Field list follows:\\n\") ;\n  curr = screen ;     /* first node in field list */\n  while (curr)\n    {\n      printf(\"  Field at row %d col %d\\n\",curr->fypos,curr->fxpos) ;\n      rc2sba(curr->fypos,curr->fxpos,sba) ;\n      printf(\"    BufAddr: %.2X %.2X \",sba\u00dd0\u00a8,sba\u00dd1\u00a8) ;\n      printf(\"Attrib: %.2X \",curr->fattr) ;\n      printf(\"Hilite: %.2X \",curr->fhilite) ;\n      printf(\"Color: %.2X \",curr->fcolor) ;\n      printf(\"Symbol: %.2X \",curr->symbol) ;\n      printf(\"DataLen: %d\\n\",curr->fdata.len) ;\n      printf(\"    Data dump: \\n\") ;\n      dumpchar(curr->fdata.data,curr->fdata.len) ;\n      size = size + curr->fdata.len  + 11 ;\n      i++ ;\n      curr = curr->next ;\n    }\n  printf(\"Total fields %d, buffer size required %d\\n\",i,size) ;\n}\n\n\n/*-------------------------------------------------------------------*/\n/* Print terminal status.                                            */\n/*-------------------------------------------------------------------*/\nvoid termstat()\n{\n  printf(\"Terminal status follows:\\n\") ;\n  printf(\"  Device name.........: %s\\n\",sdcb.modname) ;\n  printf(\"  Device model........: %d\\n\",sdcb.model) ;\n  printf(\"  Device type.........: %d\\n\",sdcb.type) ;\n  printf(\"  Addressing mode.....: %d\\n\",sdcb.adrmode) ;\n  printf(\"  Maximum rows........: %d\\n\",sdcb.rows) ;\n  printf(\"  Maximum columns.....: %d\\n\",sdcb.cols) ;\n  printf(\"  Cell height.........: %d\\n\",sdcb.celheigh) ;\n  printf(\"  Cell width..........: %d\\n\",sdcb.celwidth) ;\n  printf(\"  Supported colors....: %d\\n\",sdcb.colors) ;\n  printf(\"  Actual colors.......: %d\\n\",sdcb.colora) ;\n  printf(\"  Color attr list.....: %.32X\\n\",sdcb.colorlst) ;\n  printf(\"  Number of Highlights: %d\\n\",sdcb.hilites) ;\n  printf(\"  Highlight attr list.: %.8X\\n\",sdcb.hilitlst) ;\n  if (sdcb.unit)\n    printf(\"  Unit................: mm\\n\") ;\n  else\n    printf(\"  Unit................: inch\\n\") ;\n  printf(\"  Alternate device....: %d\\n\",sdcb.altflg) ;\n  printf(\"  APL symbol set......: %.2X\\n\",sdcb.aplflg) ;\n  printf(\"  Extended data stream: %d\\n\",sdcb.edsflg) ;\n  printf(\"  Loadable symbols....: %d\\n\",sdcb.loadflg) ;\n  printf(\"  Load PS extended....: %d\\n\",sdcb.psflg) ;\n  printf(\"  Triple plane symbols: %d\\n\",sdcb.triflg) ;\n  printf(\"  Double byte symbols.: %d\\n\",sdcb.dbcsflg) ;\n  printf(\"  Vector graphic......: %d\\n\",sdcb.graflg) ;\n}\n\n\n/*-------------------------------------------------------------------*/\n/* Add a field to the 3270 field list.                               */\n/*-------------------------------------------------------------------*/\nint insfld(TLSTR *flddata,       /* the data */\n            int ypos,            /* display at row */\n            int xpos,            /* display at column */\n            char attr,           /* field attribute PRT, UNPRT ...*/\n            char color,          /* field color RED, BLUE, ...*/\n            char hilite )        /* field hilite BLINK, RVIDEO,...*/\n{\n  int rc ;\n  TSFLD *newfld, *last, *top ;\n\n  /* get storage for new nodes */\n  newfld = (TSFLD *)malloc(sizeof(TSFLD)) ;\n  if (!newfld) serror(20,\"Not enough memory\") ;\n  memset(newfld,0x00,sizeof(TSFLD)) ;\n\n  /* verify contents of all parameters */\n  if ((flddata->len > 0) &&\n    (flddata->len <= (sdcb.rows * sdcb.cols)))\n    lstrcopy(&newfld->fdata,flddata) ;\n  else\n    return -1 ;\n\n  if ((xpos > 0) &&\n    (xpos < sdcb.cols))\n    newfld->fxpos = xpos ;\n  else\n    return -2 ;\n\n  if ((ypos > 0) &&\n    (ypos <= sdcb.rows))\n    newfld->fypos = ypos ;\n  else\n    return -3 ;\n\n  rc = modattr(&newfld->fattr,attr) ;\n  if (rc) return -4 ;\n\n  rc = modcolor(&newfld->fcolor,color) ;\n  if (rc) return -5 ;\n\n  rc = modhilite(&newfld->fhilite,hilite) ;\n  if (rc) return -6 ;\n\n  /* insert the field into the field list in order of buffer offset */\n  top = screen ;\n  if (!top)   /* first entry in the list (screen->00) */\n    {\n      newfld->next = NULL ;\n      screen = newfld ;\n    }\n  else\n    {\n      last = NULL ;  /* last node examined */\n      while(top)    /* loop through fields for insert place */\n        {\n          if ((top->fxpos+top->fypos*sdcb.cols) <\n            (newfld->fxpos+newfld->fypos*sdcb.cols)) /* rel.buff.pos */\n            {    /* chain to next node */\n              last = top ;\n              top = top->next ;\n            }\n          else\n            {\n              if (last)  /* insert the new node, in middle of list */\n                {\n                  last->next = newfld ;\n                  newfld->next = top ;\n                }\n              else   /* insert new first node in list */\n                {\n                  newfld->next = top ;\n                  screen = newfld ;\n                }\n              break ;   /* exit loop */\n            }\n        }\n      if (!newfld->next)  /* stil not inserted? - add to end */\n        last->next = newfld ;\n    }\n\n  /* update field id table and field id in field struct */\n  newfld->fid = fidnext ;\n  sfidtab\u00ddfidnext\u00a8 = newfld ;\n  rc = fidnext++ ;\n  return rc ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Remove all fields defined from the 3270 field list.               */\n/*-------------------------------------------------------------------*/\nint remflds()\n{\n  int i ;\n  TSFLD *curr, *top ;\n\n  for (i=0; i<SFIDMAX; i++)  /* empty fid table */\n    sfidtab\u00ddi\u00a8 = NULL ;\n  fidnext = 0 ;              /* reset next fid */\n\n  top = screen ;             /* free field list */\n  while(top)\n    {\n      curr = top ;\n      top = top->next ;\n      free((char *)curr->fdata.data) ;\n      free((TSFLD *)curr) ;\n    }\n  screen = NULL ;\n  return 0 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Delete a field from the 3270 field list.                          */\n/*-------------------------------------------------------------------*/\nint delfld(int id)\n{\n    TSFLD *curr, *top, *last ;\n\n    if ((id < SFIDMAX) && (id >= 0))\n      {\n        curr = sfidtab\u00ddid\u00a8 ;\n        if (curr)\n          {\n            top = screen ;\n            last = NULL ;\n            while (top)\n              {\n                if (top == curr)\n                  {\n                    if (!last)   /* ? found node at top */\n                      screen = top->next ;\n                    else if (!top->next)  /* ? last node */\n                      last->next = NULL ;\n                    else           /* in middle of list */\n                      last->next = top->next ;\n                    /* delete the node */\n                    free((char *)top->fdata.data) ;\n                    free((TSFLD *)top) ;\n                    sfidtab\u00ddid\u00a8 = NULL ; /* invalidate id */\n                    return 0 ;  /* field id removed OK */\n                  }\n                last = top ;  /* remember last node */\n                top = top->next ;   /* chain to next node */\n              }    /* of while top */\n          }\n        else return 1 ;     /* invalid id */\n      }\n    else return 2 ;    /* out of range id */\n    return 3 ;     /* idtab list mismatch */\n}\n\n/*-------------------------------------------------------------------*/\n/* Erase the contents of a field in the 3270 field list.             */\n/*-------------------------------------------------------------------*/\nint erasefld(int id)\n{\n  TSFLD *curr ;\n\n  if ((id < SFIDMAX) && (id >= 0))\n    {\n      curr = sfidtab\u00ddid\u00a8 ;\n      if (curr)\n        lstrfill(&curr->fdata,\"\\0\") ; /* fill with zeros */\n      else\n        return 1 ;     /* invalid id */\n    }\n  else\n    return 2 ;    /* out of range id */\n\n  return 0 ;    /* id erased OK */\n}\n\n/*-------------------------------------------------------------------*/\n/* Get the current contents of a field in the 3270 field list.       */\n/*-------------------------------------------------------------------*/\nint getfld(int id,\n           TLSTR *retdata)\n{\n  TSFLD *curr ;\n\n  if ((id < SFIDMAX) && (id >= 0))\n    {\n      curr = sfidtab\u00ddid\u00a8 ;\n      if (curr)\n        lstrcopy(retdata,&curr->fdata) ; /* copy data */\n      else\n        return 1 ;     /* invalid id */\n    }\n  else\n    return 2 ;    /* out of range id */\n\n  return 0 ;    /* data returned OK */\n}\n\n/*-------------------------------------------------------------------*/\n/* Modify the contents of a field in the 3270 field list.            */\n/*-------------------------------------------------------------------*/\nint modfld(int id,\n           TLSTR *newdata)\n{\n  TSFLD *curr ;\n\n  if ((id < SFIDMAX) && (id >= 0))\n    {\n      curr = sfidtab\u00ddid\u00a8 ;\n      if (curr)\n        {\n          if ((newdata->len > 0) &&\n            (newdata->len <= (sdcb.rows * sdcb.cols)))\n            lstrcopy(&curr->fdata,newdata) ; /* alter field data*/\n          else\n            return 1 ;  /* data too large or 0 */\n        }\n      else\n        return 2 ;     /* invalid id */\n    }\n  else\n    return 3 ;    /* out of range id */\n\n  return 0 ;    /* data returned OK */\n}\n\n/*-------------------------------------------------------------------*/\n/* Change the attributes of a field in the 3270 field list.          */\n/*-------------------------------------------------------------------*/\nint setfld(int id,\n           int type,\n           char value)\n{\n  TSFLD *curr ;\n  int rc = 0 ;\n\n  if ((id < SFIDMAX) && (id >= 0))\n    {\n      curr = sfidtab\u00ddid\u00a8 ;\n      if (curr)\n        {\n          switch (type)\n            {\n            case ALL:\n              rc = modcolor(&curr->fcolor,DFLT) ;\n              rc = modhilite(&curr->fhilite,DFLT) ;\n              rc = modattr(&curr->fattr,DFLT) ;\n              break ;\n            case HILITE:\n              rc = modhilite(&curr->fhilite,value) ;\n              break ;\n            case COLOR:\n              rc = modcolor(&curr->fcolor,value) ;\n              break ;\n            case ATTR:\n              rc = modattr(&curr->fattr,value) ;\n              break ;\n            case SYMSET:\n              rc = modsym(&curr->symbol,value) ;\n              break ;\n            default:\n              return 1 ;    /* invalid type */\n            }\n        }\n      else\n        return 1 ;     /* invalid id */\n    }\n  else\n    return 2 ;    /* out of range id */\n\n  return rc ;   /* return */\n}\n\n\n\n/*********************************************************************/\n/* 3270 support routines                                             */\n/*   rc2sba(row,col,sba)                                             */\n/*   sba2rc(sba,row,col,adjust)                                      */\n/*   rc = modcolor(out,in)                                           */\n/*   rc = modhilit(out,in)                                           */\n/*   rc = modattr(out,in)                                            */\n/*   rc = tputn(buf,buflen)                                          */\n/*   rc = tgetn(buf,buflen)                                          */\n/*   rc = tpgn(buf,buflen)                                           */\n/*   rc = getdev()                                                   */\n/*   rc = getterm(primrow,primcol,altrow,altcol,attrs)               */\n/*   rc = querydev()                                                 */\n/*   rc = dsummary(buf,buflen)                                       */\n/*   rc = darea(buf,buflen)                                          */\n/*   rc = dcharset(buf,buflen)                                       */\n/*   rc = dcolor(buf,buflen)                                         */\n/*   rc = dhilite(buf,buflen)                                        */\n/*   rc = dmodes(buf,buflen)                                         */\n/*   rc = dimpart(buf,buflen)                                        */\n/*                                                                   */\n/*********************************************************************/\n\n/*-------------------------------------------------------------------*/\n/* The TPUTN routine is loaded below the 16M line                    */\n/* It issues the TPUT macro with the NOEDIT option                   */\n/*-------------------------------------------------------------------*/\nint tputn(char *buf, int buflen)\n  {\n    int rc = 0 ;\n    int (*tputn)(char *,int) ;\n\n    loadm(\"TPUTN\",&tputn) ;\n    if (iotrace)      /* trace terminal I/O ? */\n      {\n        printf(\"Outbound data stream:\\n\") ;\n        dumpchar(buf,buflen) ;\n      }\n    rc = (*tputn)(buf,buflen) ;\n    unloadm(tputn) ;\n    return rc ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* The TGETN routine is loaded below the 16M line                    */\n/* It issues the TGET macro with the FULLSCR option.                 */\n/*-------------------------------------------------------------------*/\nint tgetn(char *buf, int buflen)\n  {\n    int rc = 0 ;\n    int (*tgetn)(char *,int) ;\n\n    loadm(\"TGETN\",&tgetn) ;\n    rc = (*tgetn)(buf,buflen) ;\n    if (iotrace)      /* trace terminal I/O ? */\n      {\n        printf(\"Inbound data stream:\\n\") ;\n        dumpchar(buf,buflen) ;\n      }\n    unloadm(tgetn) ;\n    return rc ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* The TPGN routine is loaded below the 16M line                     */\n/* It issues the TPG macro with the NOEDIT option.                   */\n/*-------------------------------------------------------------------*/\nint tpgn(char *buf, int buflen)\n  {\n    int rc = 0 ;\n    int (*tpgn)(char *,int) ;\n\n    loadm(\"TPGN\",&tpgn) ;\n    if (iotrace)      /* trace terminal I/O ? */\n      {\n        printf(\"Outbound data stream:\\n\") ;\n        dumpchar(buf,buflen) ;\n      }\n    rc = (*tpgn)(buf,buflen) ;\n    unloadm(tpgn) ;\n    return rc ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* Convert row/column to 3270 12/16 bit buffer address.              */\n/*-------------------------------------------------------------------*/\nvoid rc2sba(int row,\n            int col,\n            char *sba)\n{\n  int offset, byte1, byte2 ;\n\n  offset = ((row-1)*sdcb.cols)+(col-1) ;\n  if (sdcb.adrmode == 12)  /* addressing mode = 12 */\n    {\n      byte1 = offset >> 6 ;           /* extract high order bits */\n      byte1 = byte1 | 0x000000c0 ;    /* turn on 12 bit ind */\n\n      byte2 = offset & 0x0000003f ;   /* extract low order 6 bits */\n      byte2 = byte2 | 0x000000c0 ;    /* turn on 12 bit ind */\n\n      sba\u00dd0\u00a8 = *((char *)&byte1+3) ;  /* assemble 2 byte sba */\n      sba\u00dd1\u00a8 = *((char *)&byte2+3) ;\n    }\n  else /* adrmode = 16 or 14 */\n    {\n      byte1 = offset >> 8 ;           /* extract high order byte */\n      byte2 = offset & 0x00ff ;       /* extract low order byte */\n      sba\u00dd0\u00a8 = *((char *)&byte1+3) ;  /* assemble 2 byte sba */\n      sba\u00dd1\u00a8 = *((char *)&byte2+3) ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Convert 12/14/16-bit address to an offset and row/column.         */\n/*-------------------------------------------------------------------*/\nvoid sba2rc(char *inaddr,  /* input buffer addr */\n            int *row,      /* returned row */\n            int *col,      /* returned column */\n            int adjust)    /* amount to subtract - usuallu 0 for the */\n                           /*   returned cursor position, but is set */\n                           /*   to one to get correct returned buffer*/\n                           /*   addresses.                           */\n{\n  int taddr,     /* Temporary address holder */\n      offset ;\n  short addr ;\n  memcpy((char *)&addr,inaddr,sizeof(short)) ;\n\n  /* If 12-bit address, then we need to massage it a little */\n  if (addr & 0xc000)    /* 12-bit address ? */\n    {\n       addr &= 0x3f3f ;      /* turn off 2 hi bits in each byte */\n       taddr = addr >> 8 ;   /* taddr is first 6 bits */\n       addr &= 0x00ff ;      /* addr is second 6 bits */\n       taddr = taddr << 6 ;  /* shift taddr left and .. */\n       taddr |= addr ;       /*   merge taddr with addr into taddr */\n       offset = taddr ;      /* taddr is the offset into the buffer */\n    }\n  else\n    offset = addr ;          /* addr is the offset into the buffer */\n\n  offset = offset - adjust ; /* adjust is either 0 or 1 */\n\n  /* turn offset into row and column based on device num of columns */\n  *col = (offset % sdcb.cols) + 1 ;\n  *row = (offset / sdcb.cols) + 1 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Check color attribute and copy if valid.                          */\n/*-------------------------------------------------------------------*/\nint modsym(char *out,\n           char in )\n{\n  switch (in)\n    {\n    case DFLT:\n      *out = in ;\n      return 0 ;\n    case APL:\n      if (sdcb.aplflg)\n        {\n          *out = in ;\n          return 0 ;\n        }\n      else\n        return 1 ;\n    default:\n      if (sdcb.loadflg)\n        {\n          if ((in>=0x40) && (in<=0xef))\n            {\n              *out = in ;\n              return 0 ;\n            }\n          else\n            return 1 ;\n        }\n      else\n        return 1 ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Check color attribute and copy if valid.                          */\n/*-------------------------------------------------------------------*/\nint modcolor(char *out,\n             char in )\n{\n  switch (in)\n    {\n    case DFLT:\n    case BLUE:\n    case RED:\n    case PINK:\n    case GREEN:\n    case TURQ:\n    case YELLOW:\n    case WHITE:\n      *out = in ;\n      return 0 ;\n    default:\n      return 1 ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Check hilite attribute and copy if valid.                         */\n/*-------------------------------------------------------------------*/\nint modhilit(char *out,\n             char in )\n{\n  switch (in)\n    {\n    case NONE:\n    case BLINK:\n    case RVIDEO:\n    case USCORE:\n      *out = in ;\n      return 0 ;\n    default:\n      return 1 ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Check field attribute and copy if valid.                          */\n/*-------------------------------------------------------------------*/\nint modattr(char *out,\n            char in )\n{\n  switch (in)\n    {\n    case PRT:       /* protected normal intensity */\n    case PRTHI:     /* protected high intensity */\n    case PRTAS:     /* protected normal intensity auto skip */\n    case PRTHIAS:   /* protected high intensity auto skip */\n    case UNPRT:     /* unprotected normal intensity */\n    case UNNUM:     /* unprotected numeric normal intensity */\n    case UNNUMHI:   /* unprotected numeric high intensity */\n    case UNNON:     /* unprotected non display */\n    case UNHI:      /* unprotected high intensity */\n      *out = in ;\n      return 0 ;\n    default:\n      return 1 ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Load programmed symbols - type 1 load                             */\n/*   loads programmed symbols without compression                    */\n/*-------------------------------------------------------------------*/\nint loadps1()\n  {\n    int rc ;         /* return code */\n    int bufpos ;     /* next buffer position */\n    int i, j ;       /* counters */\n    short s ;        /* temp */\n\n    memset(buffer,0x00,BUFFMAX) ;  /* clear buffer */\n\n    bufpos = 0 ;\n    buffer\u00ddbufpos++\u00a8 = WSF ;   /* write structured field */\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;  /* structured field length */\n    buffer\u00ddbufpos++\u00a8 = 0x07 ;  /* structured field length contd. */\n    buffer\u00ddbufpos++\u00a8 = 0x06 ;  /* load PS structured field */\n    buffer\u00ddbufpos++\u00a8 = 0x41 ;  /* flags: clear sym.set and use type 1 */\n    buffer\u00ddbufpos++\u00a8 = 0xff ;  /* make associated RWS = not assigned */\n    buffer\u00ddbufpos++\u00a8 = 0x41 ;  /* starting code point */\n    buffer\u00ddbufpos++\u00a8 = 0x02 ;  /* RWS of PSA symbol set */\n\n    /* write buffer to the 3270 */\n    rc = tputn(buffer, bufpos) ;\n\n    memset(buffer,0x00, bufpos) ;  /* clear buffer */\n\n    bufpos = 0 ;\n    buffer\u00ddbufpos++\u00a8 = WSF ;   /* write structured field */\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;  /* structured field length */\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;  /* structured field length contd. */\n    buffer\u00ddbufpos++\u00a8 = 0x06 ;  /* load PS structured field */\n    buffer\u00ddbufpos++\u00a8 = 0x01 ;  /* flags: use type 1 */\n    buffer\u00ddbufpos++\u00a8 = 0x40 ;  /* make associated RWS = 0x40 */\n    buffer\u00ddbufpos++\u00a8 = 0x41 ;  /* starting code point (symbol=65) */\n    buffer\u00ddbufpos++\u00a8 = 0x02 ;  /* RWS of PSA symbol set */\n\n /* This extra stuff needs the flags bit 1 on to indicate extended\n    I dont think I need to use it yet.\n\n    buffer\u00ddbufpos++\u00a8 = 0x08 ;     P length - length of extra parms\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     flags: operator selectable ...\n    buffer\u00ddbufpos++\u00a8 = 0x09 ;     LW - width of character\n    buffer\u00ddbufpos++\u00a8 = 0x10 ;     LH - width of character\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     SUBSN - only one byte codes\n    buffer\u00ddbufpos++\u00a8 = 0xf1 ;     COLOR - F1 - first attr ???\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     ST.SUBSN - default\n    buffer\u00ddbufpos++\u00a8 = 0xf9 ;     ECHAR - last symbol=249\n\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     NW - number width pairs\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     NH - number height pairs\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     RES - reserved\n */\n\n    /* load specific font based on the cell height */\n    if (sdcb.celheigh >= 16)\n      {\n        for (i=65;i<=249;i++)   /* for each symbol, 0x41 to 0xF9 */\n          {\n            for (j=0;j<=17;j++)      /* for each slice  */\n              {\n                buffer\u00ddbufpos++\u00a8 = ps9x16u\u00ddi\u00a8\u00ddj\u00a8 ;\n              }\n          }\n      }\n    else if (sdcb.celheigh == 15)\n      {\n        for (i=65;i<=249;i++)   /* for each symbol, 0x41 to 0xF9 */\n          {\n            for (j=0;j<=17;j++)      /* for each slice  */\n              {\n                buffer\u00ddbufpos++\u00a8 = ps9x15u\u00ddi\u00a8\u00ddj\u00a8 ;\n              }\n          }\n      }\n    else\n      {\n        for (i=65;i<=249;i++)   /* for each symbol, 0x41 to 0xF9 */\n          {\n            for (j=0;j<=17;j++)      /* for each slice  */\n              {\n                buffer\u00ddbufpos++\u00a8 = ps9x12u\u00ddi\u00a8\u00ddj\u00a8 ;\n              }\n          }\n      }\n\n    s = bufpos - 1 ;\n    memcpy(buffer+1,&s,sizeof(short)) ;\n\n    /* write buffer to the 3270 to load the programmed symbols */\n    rc = tputn(buffer, bufpos) ;\n\n    memset(buffer,0x00,BUFFMAX) ;  /* clear buffer */\n    return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* Get the display device attributes.                                */\n/*-------------------------------------------------------------------*/\nint getdev()\n  {\n    int rc, pr = 0, pc = 0, ar = 0, ac = 0, att = 0 ;\n    int i ;\n\n    /* set the default values, may get over ridden later */\n    sdcb.adrmode = 12 ;  /* addressing mode */\n    sdcb.altflg = 0 ;    /* use primary device */\n    sdcb.edsflg = 0 ;    /* no extended data stream */\n    sdcb.graflg = 0 ;    /* not a graphics device */\n    sdcb.aplflg = 0 ;    /* no apl symbols on device */\n    sdcb.psflg = 0 ;     /* no program symbols on device */\n    sdcb.loadflg = 0 ;   /* no loadable symbols sets on device */\n    sdcb.triflg = 0 ;    /* no triple plane symbols sets on device */\n    sdcb.dbcsflg = 0 ;   /* no double byte symbols on device */\n    sdcb.celheigh = 0 ;  /* zero cell height on device */\n    sdcb.celwidth = 0 ;  /* zero cell width on device */\n    sdcb.unit = 0 ;      /* units are inches */\n    sdcb.colora = 1 ;    /* actual colors default to monochrome */\n    sdcb.colors = 1 ;    /* supported colors default to monochrome */\n    sdcb.hilites = 0 ;   /* supported hilites default to none */\n    for (i=0;i<17;i++)\n      sdcb.colorlst\u00ddi\u00a8 = 0x00 ; /* list of color attributes on device*/\n    for (i=0;i<5;i++)\n      sdcb.hilitlst\u00ddi\u00a8 = 0x00 ; /* list of hilite attributes on device*/\n\n\n    /* get info from TSO about this device */\n    rc = getterm(&pr,&pc,&ar,&ac,&att) ;\n    if (rc==0)                 /* get terminal info worked ? */\n      {\n        if (att==0x00000001)   /* device has query structured fields */\n          {\n            /* set row and col may be later reset by query dev */\n            if ((ar>0) && (ar!=pr) &&\n                (ac>0) && (ac!=pc))\n              {\n                sdcb.altflg = 1 ;    /* use alternate device */\n                sdcb.rows = ar ;     /* use alternate rows */\n                sdcb.cols = ac ;     /* use alternate cols */\n              }\n            else\n              {\n                sdcb.rows = pr ;     /* use primary rows */\n                sdcb.cols = pc ;     /* use primary cols */\n              }\n\n            rc = querydev() ;\n            /* try to determine actual device */\n            if (sdcb.rows == 32)\n              {\n                strcpy(sdcb.modname,\"IBM3279-3\") ;\n                sdcb.model = 3279 ;\n                sdcb.type = 3 ;\n              }\n            else if (sdcb.rows == 43)\n              {\n                strcpy(sdcb.modname,\"IBM3278-4\") ;\n                sdcb.model = 3278 ;\n                sdcb.type = 4 ;\n              }\n            else if (sdcb.rows == 27)\n              {\n                strcpy(sdcb.modname,\"IBM3290\") ;\n                sdcb.model = 3290 ;\n                sdcb.type = 5 ;\n              }\n            else  /* cant tell - use most primitive */\n              {\n                strcpy(sdcb.modname,\"IBM3278-2\") ;\n                sdcb.model = 3278 ;\n                sdcb.type = 2 ;\n              }\n          }\n        else  /* dont know a lot about the device - make some guesses */\n          {\n            if ((ar>0) && (ar!=pr) &&\n                (ac>0) && (ac!=pc))\n              {\n                sdcb.altflg = 1 ;    /* use alternate device */\n                sdcb.rows = ar ;     /* use alternate rows */\n                sdcb.cols = ac ;     /* use alternate cols */\n              }\n            else\n              {\n                sdcb.rows = pr ;     /* use primary rows */\n                sdcb.cols = pc ;     /* use primary cols */\n              }\n\n            /* try to determine actual device */\n            if (sdcb.rows == 32)\n              {\n                strcpy(sdcb.modname,\"IBM3279-3\") ;\n                sdcb.model = 3279 ;\n                sdcb.type = 3 ;\n              }\n            else if (sdcb.rows == 43)\n              {\n                strcpy(sdcb.modname,\"IBM3278-4\") ;\n                sdcb.model = 3278 ;\n                sdcb.type = 4 ;\n              }\n            else if (sdcb.rows == 27)\n              {\n                strcpy(sdcb.modname,\"IBM3290\") ;\n                sdcb.model = 3290 ;\n                sdcb.type = 5 ;\n              }\n            else  /* cant tell - use most primitive */\n              {\n                strcpy(sdcb.modname,\"IBM3278-2\") ;\n                sdcb.model = 3278 ;\n                sdcb.type = 2 ;\n              }\n          }\n        return 0 ;\n      }\n    else  /* get term failed - return its code */\n      return rc ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* This routine loads an assebbler module below the 16 MB line       */\n/* that issues the GTTERM macro instruction to obtain the            */\n/* dimensions of the screen and also some bit fields that            */\n/* tell if the device can be queried. The module copies the          */\n/* results from storage below the line to this routines              */\n/* automatic storage.                                                */\n/* Upon completion the module is unloaded.                           */\n/*-------------------------------------------------------------------*/\nint getterm(int *primrow, int *primcol,\n             int *altrow, int *altcol,\n             int *attrs)\n  {\n    struct {\n      union {\n        short sh ;\n        char c\u00dd2\u00a8 ;\n      } prim ;\n      union {\n        short sh ;\n        char c\u00dd2\u00a8 ;\n      } alt ;\n      int attr ;\n    } pm ;\n    int rc = 0 ;\n    int (*tgt327d)(void *) ;\n\n    loadm(\"TGT327D\",&tgt327d) ;   /* load ASM routine below 16M */\n    rc = (*tgt327d)(&pm) ;        /* execute GTTERM macro */\n    if (rc==0)      /* data returned OK ? */\n      {             /* yes - convert single byte numbers to int */\n        *primrow = pm.prim.c\u00dd0\u00a8 ;\n        *primcol = pm.prim.c\u00dd1\u00a8 ;\n        *altrow = pm.alt.c\u00dd0\u00a8 ;\n        *altcol = pm.alt.c\u00dd1\u00a8 ;\n        *attrs = pm.attr ;\n      }\n    unloadm(tgt327d) ;            /* unload ASM routine */\n    return rc ;                   /* return code from GTTERM */\n  }\n\n/*-------------------------------------------------------------------*/\n/* Clear 3270 screen.                                                */\n/*-------------------------------------------------------------------*/\nvoid clear()\n  {\n    int rc ;\n    char sba\u00dd2\u00a8 ;\n    char out1\u00dd\u00a8 = {      /* set up for erase */\n      WRT, 0x40,\n      SBA, 0x5d, 0x7f,   /* end addr - overlayed later */\n      SBA, 0x40, 0x40,   /* start addr row=1 col=1 */\n      SBA, 0xe7, 0x7f,   /* insert cursor location, row/col max */\n      ICUR               /* insert cursor */\n      } ;\n    char out2\u00dd\u00a8 = {      /* erase write alternate */\n      EWA, 0xc2\n      } ;\n    char out3\u00dd\u00a8 = {      /* erase primary */\n      WRT, 0xc2\n      } ;\n\n    /* set max screen size known so far sba */\n    rc2sba(sdcb.rows,sdcb.cols,sba) ;\n    out1\u00dd9\u00a8 = sba\u00dd0\u00a8 ;\n    out1\u00dd10\u00a8 = sba\u00dd1\u00a8 ;\n\n    rc = tputn(out1,sizeof(out1) ) ;   /* define the buffer */\n    rc = tputn(out2,sizeof(out2) ) ;   /* erase write alternate */\n    rc = tputn(out3,sizeof(out3) ) ;   /* erase write primary */\n  }\n\n/*-------------------------------------------------------------------*/\n/* Select the entire screen buffer using SBA based on the            */\n/* scrsize returned from GTTERM and EW/EWA to select the             */\n/* primary or alternate buffer.                                      */\n/* Then assemble a structured field query, and send it to the        */\n/* device using TPG which will cause the device to imediately        */\n/* send back the response without any user intervention.             */\n/* Then decode the read partition, query operations, query and       */\n/* put the interesting data in the sdcb structure.                   */\n/*-------------------------------------------------------------------*/\nint querydev()\n  {\n    short sflen ;      /* structured field length */\n    char  sfid ;       /* structured field ID */\n    char  qcode ;      /* query reply - query code */\n    char input\u00dd256\u00a8 ;  /* query buffer */\n    char *ibuf ;       /* current query buffer pointer */\n    int rc ;\n    char sba\u00dd2\u00a8 ;\n\n    char out1\u00dd\u00a8 = {      /* set up for erase */\n      WRT, 0x40,\n      SBA, 0x5d, 0x7f,   /* end addr - overlayed later, rc= 24,80 */\n      SBA, 0x40, 0x40,   /* start addr row=1 col=1 */\n      SBA, 0xe7, 0x7f,   /* insert cursor loc, rc= 32,80 *OVERLAYED**/\n      ICUR               /* insert cursor */\n      } ;\n\n    char out2\u00dd\u00a8 = {      /* erase write alternate */\n      EWA, 0xc2\n      } ;\n\n    char out3\u00dd\u00a8 = {      /* erase primary */\n      WRT, 0xc2\n      } ;\n\n    char out4\u00dd\u00a8 = {\n      WSF,               /* write structured field */\n      0x00, 0x05,        /* structured field length */\n      0x01,              /* read partition */\n      0xFF,              /* query operations */\n      0x02               /* query */\n      } ;\n\n    /* set max screen size known so far sba */\n    rc2sba(sdcb.rows,sdcb.cols,sba) ;\n    out1\u00dd9\u00a8 = sba\u00dd0\u00a8 ;\n    out1\u00dd10\u00a8 = sba\u00dd1\u00a8 ;\n\n    fill(input,0x00,sizeof(input)) ;   /* zero input buffer */\n\n    rc = tputn(out1,sizeof(out1) ) ;   /* define the buffer */\n    rc = tputn(out2,sizeof(out2) ) ;   /* erase write alternate */\n    rc = tputn(out3,sizeof(out3) ) ;   /* erase write primary */\n    rc = tpgn(out4,sizeof(out4) ) ;    /* query the device */\n    rc = tgetn(input,sizeof(input)) ;  /* receive device resp.*/\n\n    ibuf = input ;       /* point at input */\n\n    if (*input==0x88)    /* check for 88 AID byte */\n      {\n        ibuf = ibuf+1 ;         /* advance to 1st structured field */\n        sfid = *(ibuf+2) ;      /* sfid should be 0x81 */\n\n        while (sfid==0x81)  /* while structured fields remain */\n          {\n            sflen = *((short *)ibuf) ;  /* get structured field len */\n            if (sflen==0)           /* bad error - should not happen */\n              {\n                printf(\"Error: Structured field length zero at %p\\n\",\n                  ibuf) ;\n                dumpchar(input,sizeof(input)) ;\n                return 1 ;\n              }\n            qcode = *(ibuf+3) ;     /* get query code */\n            switch (qcode)\n              {\n                case 0x80:           /* Q-code summary */\n                  rc = dsummary(ibuf,sflen) ;\n                  break ;\n                case 0x81:           /* Usable area */\n                  rc = darea(ibuf,sflen) ;\n                  break ;\n                case 0x85:           /* Character sets */\n                  rc = dcharset(ibuf,sflen) ;\n                  break ;\n                case 0x86:           /* Color */\n                  rc = dcolor(ibuf,sflen) ;\n                  break ;\n                case 0x87:           /* Highlighting */\n                  rc = dhilite(ibuf,sflen) ;\n                  break ;\n                case 0x88:           /* Modes */\n                  rc = dmodes(ibuf,sflen) ;\n                  break ;\n                case 0xa6:           /* Implicit partition */\n                  rc = dimpart(ibuf,sflen) ;\n                  break ;\n                default:\n                  break ;\n              }  /* of switch */\n            ibuf = ibuf+sflen ; /* advance to next structured field */\n            sfid = *(ibuf+2) ;  /* sfid should be 0x81 - else stop */\n\n          } /* of while sfid=81 */\n\n      } /* of AID=88 */\n    return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x80: Qcode summary                                               */\n/*-------------------------------------------------------------------*/\nint dsummary(char *buf, short buflen)\n  {\n     int i ;\n     char qcode ;\n\n     for (i=4;i<buflen;i++)\n       {\n          qcode = *(buf+i) ;     /* get query code */\n          if (qcode == 0xb4)\n            sdcb.graflg = 1 ;    /* indicate graphic support */\n       }  /* of for i=4 */\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x81: Usable area                                                 */\n/*-------------------------------------------------------------------*/\nint darea(char *buf, short buflen)\n  {\n     char celunits\u00dd6\u00a8 ;   /* screen size unit PEL or CELL */\n     short w, h ;         /* screen size w=width h=height */\n     char aw, ah ;        /* units per cell aw=width ah=height */\n     float xr, xrd, yr, yrd ;  /* pel spacing ratio */\n     float fw, fh ;       /* ratio - pels per unit */\n\n     if ((*(buf+4) & 0x03)==0x03)\n       sdcb.adrmode = 16 ;\n     else if ((*(buf+4) & 0x01)==0x01)\n       sdcb.adrmode = 12 ;\n\n     w = *((short *)(buf+6)) ;   /* width of usable area */\n     h = *((short *)(buf+8)) ;   /* height of usable area */\n\n     if (*(buf+10) == 0x01)    /* pels/in or pels/mm */\n       sdcb.unit = 1 ;  /* units are mm */\n     else\n       sdcb.unit = 0 ;  /* units are inch */\n\n     xr = *((short *)(buf+11)) ;    /* x dim pel ratio numerator */\n     xrd = *((short *)(buf+13)) ;   /* x dim pel ratio denominator */\n     yr = *((short *)(buf+15)) ;    /* y dim pel ratio numerator */\n     yrd = *((short *)(buf+17)) ;   /* y dim pel ratio denominator */\n\n     fw = (float)(xr) / (float)(xrd) ; /* horiz. ratio pels per unit */\n     fh = (float)(yr) / (float)(yrd) ; /* vert. ratio pels per unit */\n\n     aw = *(buf+19) ;    /* number of X units in default cell */\n     ah = *(buf+20) ;    /* number of Y units in default cell */\n\n     if (*(buf+5) & 0x20)       /* byte 5 bit 3 on unit=pels */\n       strcpy(celunits,\"pels\") ;\n     else                       /* other wise unit=cells */\n       strcpy(celunits,\"cells\") ;\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x85: Character sets                                              */\n/*-------------------------------------------------------------------*/\nint dcharset(char *buf, short buflen)\n  {\n     int i, j ;         /* counters */\n     int cgcsgid ;      /* Coded graphic character set identifier */\n     short ccsid ;      /* Coded character set identifier */\n     char gf = 0 ;      /* CGCSGID not present flag */\n     char ch2 = 0 ;     /* Two byte char. set flag */\n     char ms = 0 ;      /* Multiple slot sizes flag */\n     char cf = 0 ;      /* CCSID not present flag */\n     char sdw ;         /* Default character slot width */\n     char sdh ;         /* Default character slot height */\n     char dl ;          /* character set descriptor (CSD) length */\n     char *csd ;        /* character set descriptor (CSD) ptr */\n     char set ;         /* character set ID (PS store no.) */\n     char lcid ;        /* character set Local ID (alias) */\n     char sw ;          /* character set slot width */\n     char sh ;          /* character set slot height */\n     char ssubsn ;      /* character set starting subsection */\n     char esubsn ;      /* character set ending subsection */\n\n     if (*(buf+4) & 0x10)\n       sdcb.psflg = 1 ;   /* load PS Extended supported */\n     else\n       sdcb.psflg = 0 ;   /* load PS Extended not supported */\n\n     if (*(buf+4) & 0x08)\n       ms = 1 ;   /* More than one size character slot supported */\n\n     if (*(buf+4) & 0x04)\n       ch2 = 1 ;  /* Two byte code character sets are supported */\n\n     if (*(buf+4) & 0x02)\n       gf = 1 ;   /* CGCSGID present */\n\n     if (*(buf+5) & 0x20)\n       cf = 1 ;   /* CCSID present */\n\n     sdw = *(buf+6) ;\n     sdh = *(buf+7) ;\n\n     dl = *(buf+12) ;   /* get CSD length */\n     i = 13 ;\n     while (i<buflen)\n       {\n         csd = buf + i ;  /* point at CSD to process */\n         set = *csd ;     /* get character set ID (PS store no.) */\n         if (*(csd+1) & 0x80)\n           sdcb.loadflg = 1 ;  /* loadable symbol sets exist */\n\n         if (*(csd+1) & 0x40)\n           sdcb.triflg = 1 ;   /* Triple-plane character sets exist */\n\n         if (*(csd+1) & 0x20)\n           sdcb.dbcsflg = 1 ;  /* Double-byte coded character sets */\n\n         lcid = *(csd+2) ;   /* get character set ID (PS store no.) */\n\n         j = 0 ;\n         if (ms)\n           {\n             sw = *(csd+3) ;  /* slot width */\n             sh = *(csd+4) ;  /* slot height */\n             j = j + 2 ;\n           }\n\n         if (ch2)\n           {\n             ssubsn = *(csd+j+3) ;  /* starting sub-section */\n             esubsn = *(csd+j+4) ; /* ending sub-section */\n             j = j + 2 ;\n           }\n\n         if (gf)\n           {\n             cgcsgid = *((int *)(csd+j+3)) ;  /* Graf char set ID */\n             if (cgcsgid==0x03c30136)\n               sdcb.aplflg = lcid ;   /* APL supported store lcid */\n             j = j + 4 ;\n           }\n\n         if (cf)\n           {\n             ccsid = *((short *)(csd+j+3)) ;  /* char set ID */\n           }\n\n         i = i + dl ;  /* get pos of next CSD */\n       }  /* of while i<buflen */\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x86: Colors                                                      */\n/*-------------------------------------------------------------------*/\nint dcolor(char *buf, short buflen)\n  {\n     int colora = 0 ; /* number of actual colors on device */\n     int icolor ;     /* color index */\n     int i, j = 0 ;   /* counter */\n     char attr ;      /* color attribute accepted by device */\n     char dcolor ;    /* color displayed for this attribute */\n\n     sdcb.colors = (int)*(buf+5) ; /* number of colors accepted */\n     for (i=6;i<buflen;i=i+2)\n       {\n         attr = *(buf+i) ;        /* attribute used by appl. */\n         sdcb.colorlst\u00ddj++\u00a8 = attr ;\n         dcolor = *(buf+i+1) ;    /* attr/color used by device */\n         icolor = (int)(dcolor - 0xf0) ;\n         if ((icolor >= 0) && (icolor <= 15))\n           colora++ ;\n       }\n     sdcb.colora = colora ;  /* number of actual colors on device */\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x87: Highlighting                                                */\n/*-------------------------------------------------------------------*/\nint dhilite(char *buf, short buflen)\n  {\n     int i, j = 0 ;    /* counter */\n     char attr ;       /* color attribute accepted by device */\n     char dhilite ;    /* color displayed for this attribute */\n\n     sdcb.hilites = (int)*(buf+4) ;\n     for (i=5;i<buflen;i=i+2)\n       {\n         attr = *(buf+i) ;        /* attribute used by appl. */\n         dhilite = *(buf+i+1) ;   /* attr/highlight used by device */\n         sdcb.hilitlst\u00ddj++\u00a8 = attr ;\n       }\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x88: Modes                                                       */\n/*-------------------------------------------------------------------*/\nint dmodes(char *buf, short buflen)\n  {\n     int i ;           /* counter */\n     char mode ;       /* device opperation mode */\n\n     for (i=4;i<buflen;i++)\n       {\n         mode = *(buf+i) ;        /* attribute used by appl. */\n         if ((mode==0x01) ||\n             (mode==0x02))\n           sdcb.edsflg = 1 ;  /* queryable device can use extended DS*/\n       }   /* of for i */\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0xa6: Implicit partition                                          */\n/*-------------------------------------------------------------------*/\nint dimpart(char *buf, short buflen)\n  {\n     char *sdp ;                /* self defining parameter (SDP) ptr */\n     short wd, wa, hd, ha ;     /* screen dimensions */\n     short wcd, wca, hcd, hca ; /* cell sizes */\n     int i ;                    /* counter */\n\n     i = 6 ;        /* length of header */\n     while(i < buflen)   /* loop over all SDPs */\n       {\n         sdp = buf + i ;\n         if (*sdp==0x0b)    /* is it a SDP ? */\n           {\n             if (*(sdp+1)==0x01)\n               {\n                 wd = *((short *)(sdp+3)) ;  /* default width */\n                 hd = *((short *)(sdp+5)) ;  /* default height */\n                 wa = *((short *)(sdp+7)) ;  /* alternate width */\n                 ha = *((short *)(sdp+9)) ;  /* alternate height */\n                 if ((ha>hd) || (wa>wd))\n                   {\n                     sdcb.altflg = 1 ;    /* use alternate device */\n                     sdcb.rows = ha ;     /* use alternate rows */\n                     sdcb.cols = wa ;     /* use alternate cols */\n                   }\n                 else\n                   {\n                     sdcb.rows = hd ;     /* use primary rows */\n                     sdcb.cols = wd ;     /* use primary cols */\n                   }\n                 i = i + 11 ;     /* add length of this SDP */\n               }\n             else if (*(sdp+1)==0x03)\n               {\n                 i = i + 11 ;     /* add length of this SDP */\n               }\n             else if (*(sdp+1)==0x02)\n               {\n                 wcd = *((short *)(sdp+3)) ;  /* default cell width */\n                 hcd = *((short *)(sdp+5)) ;  /* default cell height */\n                 wca = *((short *)(sdp+7)) ;  /* alternate cell width */\n                 hca = *((short *)(sdp+9)) ;  /* alternate cell height*/\n                 if (sdcb.altflg)         /* using alternate device */\n                   {\n                     sdcb.celheigh = hca ; /* use alt. cell height */\n                     sdcb.celwidth = wca ; /* use alt. cell width */\n                   }\n                 else\n                   {\n                     sdcb.celheigh = hcd ; /* use primary cell height */\n                     sdcb.celwidth = wcd ; /* use primary cols width */\n                   }\n                 i = i + 11 ;     /* add length of this SDP */\n               }\n           }\n       }  /* of while */\n\n     return 0 ;\n  }\n\n\n\n\n/*********************************************************************/\n/* General string handling routines for varying length strings.      */\n/*   lstran(mod_lstr,fromchar,tochar)                                */\n/*   lstrload(to_lstr,fromchar,len)                                  */\n/*   lstrunld(tochar,from_lstr)                                      */\n/*   lstrcopy(to_lstr,from_lstr)                                     */\n/*   lstrnew(to,fromchars)                                           */\n/*   lstrsub(to_lstr,from_lstr,start,length)                         */\n/*   len = lstrlen(haystack_lstr)                                    */\n/*   pos = lstrindex(haystack_lstr,needle_lstr)                      */\n/*   lstrfill(to_lstr,fillchars)                                     */\n/*   rc = lstrcmpc(cmp_lstr,cmpchars)                                */\n/*   lstrdel(del-lstr)                                               */\n/*   lstrrep(to_lstr,repchars,copies)                                */\n/*   lstrcat(to_lstr,left_lstr,right_lstr)                           */\n/*********************************************************************/\n\n/*-------------------------------------------------------------------*/\n/* Translate a character in an lstr to another character.            */\n/*-------------------------------------------------------------------*/\nvoid lstran(TLSTR *in, char from, char to)\n{\n  int i ;      /* temp counter */\n\n  if (in)      /* from string exists ? */\n    {\n      for (i=0;i<=in->len;i++)\n        {\n          if (*(in->data+i) == from)\n            *(in->data+i) = to ;\n        }\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Get the length of an lstr.                                        */\n/*-------------------------------------------------------------------*/\nint lstrlen(TLSTR *in)\n{\n  if (in)      /* from string exists ? */\n    {\n      return in->len ;\n    }\n  else\n    return 0 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Unload varying length string contents into character buffer.      */\n/*-------------------------------------------------------------------*/\nint lstrunld(char *to,\n             TLSTR *from)\n{\n  if (from)      /* from string exists ? */\n    {\n      memcpy(to,from->data,from->len) ;\n      return from->len ;\n    }\n  else\n    return 0 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Load varying length string with contents of character buffer.     */\n/*-------------------------------------------------------------------*/\nvoid lstrload(TLSTR *to,\n              char *from,\n              int len)\n{\n  if (to)      /* to string exists ? */\n    {\n      if (len!=to->len)\n        {\n          free((char *)to->data) ;\n          to->data = (char *)malloc(len) ;\n          if (!to->data) serror(4,\"Not enough memory\") ;\n          to->len = len ;\n        }\n      memcpy(to->data,from,len) ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Copy varying length string.                                       */\n/*-------------------------------------------------------------------*/\nvoid lstrcopy(TLSTR *to,\n              TLSTR *from)\n{\n  if (from)      /* from string exists ? */\n    {\n      if (!to)    /* to string does not exist */\n        serror(2,\"String does not exist\") ;\n      else     /* to string exists */\n        {\n          if (from->len > 0)\n            {\n              if (to->data == NULL)     /* does not exist yet ? */\n                {\n                  to->data = (char *)malloc(from->len) ;\n                  if (!to->data) serror(14,\"Not enough memory\") ;\n                }\n              else if (from->len != to->len)   /* increase length ? */\n                {\n                  free((char *)to->data) ;\n                  to->data = (char *)malloc(from->len) ;\n                  if (!to->data) serror(4,\"Not enough memory\") ;\n                }\n              to->len = from->len ;\n              memcpy(to->data,from->data,from->len) ;\n            }\n          else\n            {\n              if (to->len > 0)   /* empty data */\n                free((char *)to->data) ;\n              to->len = 0 ;\n              to->data = NULL ;\n            }\n        }\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Initialize a varying length string with a string.                 */\n/*-------------------------------------------------------------------*/\nvoid lstrnew(TLSTR *newstr,\n             char *from)\n{\n  int i ;\n\n  if (!newstr)\n    serror(5,\"String does not exist\") ;\n  else\n    {\n      i = strlen(from) ;\n      if (i > 0)\n        {\n          newstr->data = (char *)malloc(i) ;\n          if (!newstr->data) serror(17,\"Not enough memory\") ;\n          newstr->len = i ;\n          memcpy(newstr->data,from,i) ;\n        }\n      else\n        {\n          newstr->len = 0 ;\n          newstr->data = NULL ;\n        }\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Create substring of a varying length string to a varying length   */\n/* string.                                                           */\n/*-------------------------------------------------------------------*/\nvoid lstrsub(TLSTR *to,\n             TLSTR *from,\n             int start,\n             int len)\n{\n  int i ;\n\n  if (start <= from->len)\n    {\n      i = from->len - start ;\n      if (len < i)\n        i = len ;       /* i is the length of the sub string */\n\n      if (!to)\n        serror(8,\"String does not exist\") ;\n      else\n        {\n          if (i > 0)\n            {\n              if (to->data == NULL)     /* does not exist yet ? */\n                {\n                  to->data = (char *)malloc(i) ;\n                  if (!to->data) serror(20,\n                    \"Not enough memory\") ;\n                }\n              else if (to->len != i)          /* wrong size ? */\n                {\n                  free((char *)to->data) ;\n                  to->data = (char *)malloc(i) ;\n                  if (!to->data) serror(10,\n                    \"Not enough memory\") ;\n                }\n              to->len = i ;\n              memcpy(to->data,from->data+start,i) ;\n            }\n          else\n            {\n              if (to->len > 0)   /* empty data */\n                free((char *)to->data) ;\n              to->len = 0 ;\n              to->data = NULL ;\n            }\n        }\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Find the position in a varying length string of a varying length  */\n/* sub-string.                                                       */\n/*-------------------------------------------------------------------*/\nint lstrindx(TLSTR *haystack, /* string to search */\n             TLSTR *needle)   /* sub-string to search for */\n{\n  int i, j, k, endpos ;\n\n  endpos = haystack->len - needle->len ;\n  for (i=0; i<endpos; i++)\n    {\n      k = 0 ;\n      for (j=0; j<needle->len; j++)\n        {\n          if (haystack->data\u00ddi+j\u00a8 == needle->data\u00ddj\u00a8)\n            k ++ ;\n          else break ;\n        }\n      if (k==needle->len)\n        return(i+1) ;\n    }\n  return 0 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Compare a varying length string with a string.                    */\n/*   rc = 0  == strings same                                         */\n/*   rc = 1  == lstr has larger value than charstr                   */\n/*   rc = -1 == lstr has smaller value than charstr                  */\n/*-------------------------------------------------------------------*/\nint lstrcmpc(TLSTR *lstr,   /* string to compare */\n             char *cstr)    /* characters to compare with */\n{\n  int i ;               /* counter */\n  int t=0 ;             /* compare flag */\n  int l ;               /* compare length */\n  int ld=0 ;            /* length differ flag */\n  char *lstrptr ;\n  char *cstrptr ;\n\n  l = strlen(cstr) ;    /* determine shortest string */\n  if (l != lstr->len)   /* same lengths ? */\n    {                   /*   no .. */\n      ld = 1 ;          /*   flag lengths differ */\n      if (l > lstr->len)\n        l = lstr->len ; /*   use shortest length */\n    }\n\n  /* compare to shortest length */\n  lstrptr = lstr->data ;\n  cstrptr = cstr ;\n  for (i=0; i<l; i++)\n    {\n      if (*lstrptr > *cstrptr)\n        {\n          t = 1 ;    /* indicate left larger than right */\n          break ;    /* end scan now  */\n        }\n      if (*lstrptr < *cstrptr)\n        {\n          t = -1 ;   /* indicate left smaller than right */\n          break ;    /* end scan now  */\n        }\n      lstrptr++ ;\n      cstrptr++ ;\n    }\n\n  if ((t==0) && (ld==1)) /* same after shortest length compared ? */\n    {\n      if (strlen(cstr) > lstr->len)\n        t = -1 ;     /* lstr smaller */\n      else\n        t = 1 ;      /* lstr larger */\n    }\n  return t ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Fill a varying length string with a string.                       */\n/*-------------------------------------------------------------------*/\nvoid lstrfill(TLSTR *string,   /* string to fill */\n              char *fillstr)  /* filler characters to use */\n{\n  int i ;\n  char *strptr ;\n\n  strptr = fillstr ;\n  for (i=0; i<=string->len; i++)\n    {\n      string->data\u00ddi\u00a8 = *(strptr++) ;\n      if (*strptr=='\\0')\n        strptr = fillstr ;    /* start over on fill string */\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Delete a varying length string (free associated memory).          */\n/*-------------------------------------------------------------------*/\nvoid lstrdel(TLSTR *string)   /* string to delete */\n{\n  free((char *)string->data) ;\n  string->data = NULL ;\n  string->len = 0 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Create a varying length string with multiple copies of a string.  */\n/*-------------------------------------------------------------------*/\nvoid lstrrep(TLSTR *string,\n             char *repstr,\n             int copies)\n{\n  int repstrlen ;\n  char *strptr ;\n  int newlen ;\n  int i ;\n\n  /* The input string that replications are made from is assumed */\n  /* to have a length of one or longer.                          */\n\n  repstrlen = strlen(repstr) ;\n  if (repstrlen==0)  /* assume repitition of 0x00 */\n    repstrlen = 1 ;\n  newlen = repstrlen * copies ;\n  if (string->data==NULL)          /* alloc storage ? */\n    {\n      string->data = (char *)malloc(newlen) ;\n      if (!string->data) serror(21,\"Not enough memory\") ;\n    }\n  else if (string->len!=newlen)    /* alloc more/less storage ? */\n    {\n      free((char *)string->data) ;\n      string->data = (char *)malloc(newlen) ;\n      if (!string->data) serror(11,\"Not enough memory\") ;\n    }\n  string->len = newlen ;     /* alter string length */\n  strptr = repstr ;\n  for (i=0; i<newlen; i++)        /* replicate the repstr data */\n    {\n      string->data\u00ddi\u00a8 = *strptr++ ;\n      if (*strptr == '\\0')\n        strptr = repstr ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Concatenate two varying length strings together placing the       */\n/* in a varying length string.                                       */\n/*-------------------------------------------------------------------*/\nvoid lstrcat(TLSTR *result,   /* result of concatenation */\n             TLSTR *left,     /* left string to concatenate */\n             TLSTR *right)    /* right string to concatenate */\n{\n  char *rstr ;\n  int newlen ;\n\n  newlen = left->len + right->len ;    /* extend LSTR */\n  rstr = (char *)malloc(newlen) ;\n  if (!rstr) serror(12,\"Not enough memory\") ;\n\n  memcpy(rstr,left->data,left->len) ;   /* make new string */\n  memcpy(rstr+left->len,right->data,right->len) ;\n\n  free((char *)result->data) ;   /* assemble new LSTR */\n  result->data = rstr ;\n  result->len = newlen ;\n}\n\n\n/*********************************************************************/\n/* General sub routines.                                             */\n/*   fill(haystack,fillchar,number)                                  */\n/*   dumpchar(buffer,length)                                         */\n/*   overlay(buffer,bufferlen,overlay,overlaylen,overlaypos)         */\n/*********************************************************************/\n\n/*-------------------------------------------------------------------*/\n/* Fill a character string with a number of filler characters.       */\n/*-------------------------------------------------------------------*/\nvoid fill(char *haystack,   /* area to fill */\n          char filler,      /* fill characters */\n          int num)          /* number of repetitions */\n{\n  int i = 0 ;\n  for(i=0;i<=num;i++)\n    *haystack++ = filler ;\n  *haystack = '\\0' ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Dump the contents of a buffer, formatted in a way that makes a    */\n/* 3270 data stream easier to interpret.                             */\n/*-------------------------------------------------------------------*/\nvoid dumpchar(char *dat,    /* data to dump */\n              int len)      /* length to dump */\n{\n  char *cptr ;\n  char c ;\n  char cc\u00dd3\u00a8 ;\n  int i ;\n  int n, m ;\n\n  n = 0 ;\n  m = 0 ;\n  cptr = dat ;\n  do\n    {\n      printf(\"      %.8X \",dat) ;\n      for(i=1;i<=16;i++)\n        {                   /* 0 indicates all */\n          if (*dat=='\\0' && len==0)\n            break ;\n          if (n==len && len>0)\n            break ;\n          c = *dat++ ;\n          n++ ;\n          printf(\"%.2X\",c) ;\n          if ((i%4)==0)\n            printf(\" \") ;\n        }\n      printf(\"\\n               \") ;\n\n      for(i=1;i<=16;i++)\n        {\n          if (*cptr=='\\0' && len==0)\n            break ;\n          if (m==len && len>0)\n            break ;\n          c = *cptr++ ;\n          m++ ;\n          if (c <= 0x3f || c==0xff)\n            {\n              switch (c)\n                {\n                  case GE:   strcpy(cc,\"GE\") ;\n                    break ;\n                  case FF:   strcpy(cc,\"FF\") ;\n                    break ;\n                  case CRR:  strcpy(cc,\"CR\") ;\n                    break ;\n                  case SBA:  strcpy(cc,\"SB\") ;\n                    break ;\n                  case EUA:  strcpy(cc,\"EU\") ;\n                    break ;\n                  case ICUR: strcpy(cc,\"IC\") ;\n                    break ;\n                  case NL:   strcpy(cc,\"NL\") ;\n                    break ;\n                  case EM:   strcpy(cc,\"EM\") ;\n                    break ;\n                  case DUP:  strcpy(cc,\"DU\") ;\n                    break ;\n                  case SF:   strcpy(cc,\"SF\") ;\n                    break ;\n                  case FM:   strcpy(cc,\"FM\") ;\n                    break ;\n                  case SA:   strcpy(cc,\"SA\") ;\n                    break ;\n                  case SFE:  strcpy(cc,\"SX\") ;\n                    break ;\n                  case MF:   strcpy(cc,\"MF\") ;\n                    break ;\n                  case RA:   strcpy(cc,\"RA\") ;\n                    break ;\n                  case SUB:  strcpy(cc,\"SU\") ;\n                    break ;\n                  default:   strcpy(cc,\". \") ;\n                    break ;\n                }\n              printf(\"%s\",cc) ;\n            }\n          else\n            printf(\"%c \",c) ;\n          if ((i%4)==0)\n            printf(\" \") ;\n        }\n      printf(\"\\n\") ;\n    }\n  while( ((*dat!='\\0') && (len==0)) ||\n         ((m!=len) && (len>20))\n       ) ;\n  printf(\"\\n\") ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Overlay characterc in a buffer.                                   */\n/*-------------------------------------------------------------------*/\nvoid overlay(char *haystack,    /* area to overlay */\n             int haylen,        /* length to overlay */\n             char *needle,      /* overlay characters */\n             int len,           /* length of overlay */\n             int pos)           /* start postition of overlay */\n{\n  int hlen, nlen ;   /* length of haystack and needle */\n  int i = 0 ;        /* itterator */\n\n  if (haylen==0)\n    hlen = strlen(haystack) ;\n  else\n    hlen = haylen ;\n\n  if (len==0)\n    nlen = strlen(needle) ;\n  else\n    nlen = len ;\n\n  if (hlen>(nlen+pos))\n    {\n      haystack = haystack+pos ;    /* move to overlay pos */\n      for(i=0;i<nlen;i++)          /* copy the data */\n        *haystack++ = *needle++ ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* General error message routine.                                    */\n/*-------------------------------------------------------------------*/\nvoid serror(int errno,\n            char *msg)\n{\n  printf(\"Error: %d - %s\\n\",errno,msg) ;\n  abort() ;\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "WIN3270": {"ttr": 14341, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x19\\x00\\x00\\x00\\x95#\\x7f\\x00\\x950o\\x18\\x05\\x15'\\x00\\x89\\x00\\x00\\xe2\\xc1\\xe2\\xc4\\xc4\\xc6@@@@\"", "ispf": {"version": "01.25", "flags": 0, "createdate": "1995-08-25T00:00:00", "modifydate": "1995-11-02T18:05:00", "lines": 5415, "newlines": 137, "modlines": 0, "user": "SASDDF"}, "text": "#pragma eject\n#pragma title win3270.c - display fields on a 3270 device\n\n/*+-----------------------------------------------------------------+\n  | Program:   win3270.c                                            |\n  | Language:  C - Some specific SAS/C v5.50C routines required.    |\n  | Support:   DAF                                                  |\n  | Purpose:   To allow a full screen dialog application to be      |\n  |            created using the CLIST or REXX language in the      |\n  |            TSO environment.                                     |\n  | History:   24Aug95 Inital coding, frame work only.          DAF |\n  |            15Sep95 Added some more code.                    DAF |\n  |                                                                 |\n  |            The following publications have been used in the     |\n  |            developement of this program:                        |\n  |              SC28-1875 TSO/E v2 programming Services            |\n  |              GA23-0059 3270 Info. Display Sys. Data Stream      |\n  |                        Programmers Reference.                   |\n  |              GA27-3831 3174 Establishment Controller Character  |\n  |                        Set Reference.                           |\n  |              GA27-2837 3270 Character Set Reference.            |\n  |              HUR 9058  IBM3270 Personal Computer Graphics       |\n  |                        Control Program Data Stream Reference.   |\n  |              GA18-2589 IBM 3179-G/3192-G Color Graphics Display |\n  |                        Station Description.                     |\n  |              GG27-6999 Introduction to Programming the IBM 3270.|\n  |              SC28-1882 MVS/REXX Users Guide.                    |\n  |              SC28-1883 Procedure Language MVS/REXX Reference.   |\n  |                                                                 |\n  |              56117     SAS/C Library Reference - Volume 1       |\n  |              56118     SAS/C Library Reference - Volume 2       |\n  |              56123     SAS/C Compiler and Library Users Guide   |\n  |              59014     SAS Technical report C-109 Changes and   |\n  |                        Enhancements to the C Library Reference  |\n  |                        Release 5.00                             |\n  |                                                                 |\n  | Notes:     1. Numeric fields do not work the same on all        |\n  |               devices. The 3192-G allows lowercase character    |\n  |               input. Many devices also upper case character     |\n  |               input.                                            |\n  |            2. Most devices do not support field attributes:     |\n  |               Field Outlining, Background color, and Field      |\n  |               Validation.                                       |\n  |            3. The character set for APL does not appear to be   |\n  |               allowed on the SFE order, only on the SA order.   |\n  | End.                                                            |\n  +-----------------------------------------------------------------+*/\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <exec.h>\n#include <ctype.h>\n#include <svc.h>\n#include <tput.h>\n#include <ostask.h>\n\n#define _AMODE31\n\n#include \"ps9x16u.inc\"\n#include \"ps9x15u.inc\"\n#include \"ps9x12u.inc\"\n\n/* Token delimiters */\n#define DELIMS \" =\"\n#define DELIMQ \"'=\"\n\n/* Attribute value array indexes */\n#define AVALUE  0\n#define ATYPE   1\n#define ACOLOR  2\n#define AHILITE 3\n#define ASYMBOL 4\n#define AJUST   5\n\n/* escape character and device commands */\n#define ESC     0x27\n#define EW      0xf5\n#define EWA     0x7e\n#define WRT     0xf1\n#define WSF     0xf3\n#define RB      0xf2\n\n/* write control characters, or'd together as required */\n#define WCCMDT  0x01\n#define WCCKBD  0x02\n#define WCCRES  0xc0\n#define WCCBEL  0x04\n\n/* 3270 data stream orders */\n#define GE      0x08\n#define FF      0x0c\n#define CRR     0x0d\n#define SBA     0x11\n#define EUA     0x12\n#define ICUR    0x13\n#define NL      0x15\n#define EM      0x19\n#define DUP     0x1c\n#define SF      0x1d\n#define FM      0x1e\n#define SA      0x28\n#define SFE     0x29\n#define MF      0x2c\n#define RA      0x3c\n#define SUB     0x3f\n\n#define PROT    0x20\n#define NUM     0x10\n\n/* Type byte of the SA, SFE and MF orders */\n#define ALL     0x00\n#define NONE    0x00\n#define DFLT    0x00\n\n#define ATTR    0xc0\n#define FVALID  0xc1\n#define OUTLIN  0xc2\n#define HILITE  0x41\n#define COLOR   0x42\n#define SYMSET  0x43\n#define BAKCOL  0x45\n#define TRANSP  0x46\n\n#define APL     0xF1\n\n/* Out lines for the value byte of the SA, SFE, or MF order */\n#define UNDR    0x01\n#define OVR     0x04\n#define OVRUND  0x05\n#define NOOVR   0x0b\n#define NOUNDR  0x0e\n#define RECT    0x0f\n\n/* Hilites for the value byte of the SA, SFE, or MF order */\n#define BLINK   0xf1\n#define RVIDEO  0xf2\n#define REVERSE 0xf2\n#define USCORE  0xf4\n#define ULINE   0xf4\n\n/* Colors for the value byte of the SA, SFE, or MF order */\n#define BLUE    0xf1\n#define RED     0xf2\n#define PINK    0xf3\n#define GREEN   0xf4\n#define TURQ    0xf5\n#define CYAN    0xf5\n#define YELLOW  0xf6\n#define WHITE   0xf7\n\n/* Attribute for the value byte of the SF, SFE and MF order */\n#define UNPRT   0x40\n#define UNNUM   0x50\n#define UNNUMHI 0xd8\n#define UNNON   0x4c\n#define UNHI    0xc8\n#define PRT     0x60\n#define PRTHI   0xe4\n#define PRTAS   0xf0\n#define PRTHIAS 0xf8\n\n/* Field input attribute settings */\n#define INPUT   0x01\n#define NOINPUT 0x00\n\n/* Field subtype identifiers */\n#define TEXT    'T'\n#define CONTROL 'C'\n\n/* Attention Identification (AID) Values */\n#define NOAID   0x60\n#define NOAIDP  0xe8\n#define STRFLD  0x88\n#define ENTER   0x7d\n#define PF1     0xf1\n#define PF2     0xf2\n#define PF3     0xf3\n#define PF4     0xf4\n#define PF5     0xf5\n#define PF6     0xf6\n#define PF7     0xf7\n#define PF8     0xf8\n#define PF9     0xf9\n#define PF10    0x7a\n#define PF11    0x7b\n#define PF12    0x7c\n#define PF13    0xc1\n#define PF14    0xc2\n#define PF15    0xc3\n#define PF16    0xc4\n#define PF17    0xc5\n#define PF18    0xc6\n#define PF19    0xc7\n#define PF20    0xc8\n#define PF21    0xc9\n#define PF22    0x4a\n#define PF23    0x4b\n#define PF24    0x4c\n#define OID     0xe6\n#define MAG     0xe7\n#define PEN     0x7e\n#define PA1     0x6c\n#define PA2     0x6e\n#define PA3     0x6b\n#define CLEAR   0x6d\n#define SYSREQ  0xf0\n\n/* size constants */\n#define BUFFMAX  5000\n#define SFIDMAX  256\n#define ATTRMAX  50\n#define TSOVSIZE 32\n\n\n\n/*--------------------------------------------------------------------*/\n/* Special types                                                      */\n/*--------------------------------------------------------------------*/\ntypedef\n  struct LSTR     /* string with length */\n  {\n    int len ;             /* current length of data */\n    char *data ;          /* pointer to data */\n  } TLSTR ;\n\ntypedef\n  struct SFLD     /* 3270 screen field information list entry */\n  {\n    int fid ;             /* unique field identifier */\n    TLSTR fdata ;         /* field data (input or output) */\n    int fxpos ;           /* X column position */\n    int fypos ;           /* Y row position */\n    char fattr ;          /* 3270 field attribute */\n    char fcolor ;         /* 3270 color attribute */\n    char fhilite ;        /* 3270 hilite attribute */\n    char symbol ;         /* 0x00=normal 0xf1=APL else 0x40-0xef=PS */\n    char just ;           /* justify, L=Left R=Right C=Center N=None */\n    char modflg ;         /* field modified 01=yes 00=no */\n    char inputflg ;       /* input allowed for field 01=yes 00=no */\n    char type ;           /* widget type */\n                          /* L = LABEL .....> tsovar = NULL */\n                          /* I = INPUT */\n                          /* O = OUTPUT */\n                          /* B = BUTTON */\n                          /* R = RADIO */\n                          /* C = CHECKBOX */\n    char subtype ;        /* widget sub type for radio and checkbox */\n                          /* T = display text field */\n                          /* C = control symbol field */\n                          /* 00 = not used */\n    char *tsovar ;        /* pointer to TSO variable name string */\n    struct SFLD *next ;   /* next list entry */\n  } TSFLD ;\n\ntypedef\n  struct WINDOW   /* List of defined windows and their info. */\n  {\n    int srow ;            /* start row of window */\n    int scol ;            /* start column of window */\n    int delay ;           /* time to wait after display (secs.) */\n    int lastcol ;         /* last cursor coloumn - on screen */\n    int lastrow ;         /* last cursor row - on screen */\n    int fidnext ;         /* next field id number to assign */\n    TSFLD *fields ;       /* field list for window */\n    TSFLD *sfidtab\u00ddSFIDMAX\u00a8 ; /* field id address table */\n    char name\u00dd9\u00a8 ;        /* name of window */\n    char lastvar\u00dd32\u00a8 ;    /* last variable selected or empty */\n    char lastword\u00dd32\u00a8 ;   /* last word selected or empty */\n    char lastkey ;        /* last key pressed */\n    char eraseflg ;       /* erase screen required 01=yes 00=no */\n    char inputflg ;       /* input flag 0=no input, 1=input allowed */\n    char bdselflg ;       /* border selected flag, selected=1 */\n    int bellflg ;         /* ring bell on next display */\n    struct WINDOW *next ; /* next list entry */\n  } TWINDOW ;\n\n\n\n/*--------------------------------------------------------------------*/\n/* Global Variables                                                   */\n/*--------------------------------------------------------------------*/\nint (*xtputn)(char *,int) ; /* tput noedit routine */\nint (*xtgetn)(char *,int) ; /* tget routine */\nint (*xtpgn)(char *,int) ;  /* tpg routine */\n\nchar attrtab\u00ddATTRMAX\u00a8\u00dd6\u00a8 ; /* value character attribute mapping */\nchar msg\u00dd120\u00a8 ;          /* output message buffer */\nint attrnext ;           /* next attrtab entry to use */\nint mlev ;               /* msg level,0=off, 1..9=level, 9++ =special */\n\nchar *buffer ;    /* buffer area for tput/tget */\n\nTWINDOW *windows ;/* root of all windows */\nTWINDOW *curwin ; /* currently active window */\n\nint iotrace = 0 ;         /* trace terminal I/O flag */\n\n\nstruct DCB        /* Device control block */\n  {\n    int model ;         /* model number ie: 3279, 3278, 3277 */\n    int type ;          /* model type ie: 2, 3, 4, 5 */\n    int rows ;          /* number of rows (height) on device */\n    int cols ;          /* number of columns (width) on device */\n    int celheigh ;      /* cell height on device */\n    int celwidth ;      /* cell width on device */\n    int uacelh ;        /* usable area cell height on device */\n    int uacelw ;        /* usable area cell width on device */\n    int colors ;        /* number of colors on device */\n    int colora ;        /* number of actual colors on device */\n    int hilites ;       /* number of colors on device */\n    int adrmode ;       /* device addressing mode: 12 or 14 or 16 bit*/\n    char unit ;         /* 0 = inch 1 = mm */\n    char edsflg ;       /* extended data stream flag */\n    char psflg ;        /* program symbols on device flag */\n    char altflg ;       /* use alternate flag */\n    char aplflg ;       /* 0 or apl's lcid=supports APL on device */\n    char graflg ;       /* graphics device flag */\n    char loadflg ;      /* loadable symbol sets supported flag */\n    char triflg ;       /* triple plane symbol sets supported flag */\n    char dbcsflg ;      /* double byte characters supported flag */\n    char colorlst\u00dd17\u00a8 ; /* list of color attributes on device */\n    char hilitlst\u00dd5\u00a8 ;  /* list of hilite attributes on device */\n    char modname\u00dd11\u00a8 ;  /* name of device ie: IBM32793B IBM3179G ..*/\n  } sdcb ;\n\n\n\n/*-------------------------------------------------------------------*/\n/* Function Prototypes                                               */\n/*-------------------------------------------------------------------*/\n\n/* win3270 */\nvoid help() ;\nint wacmd(char *) ;\nint wecmd(char *) ;\nint wccmd(char *) ;\nint wscmd(char *) ;\nint wdcmd(char *) ;\n/* field handling */\nint initscr() ;\nvoid termscr() ;\nchar dspflds() ;\nint insfld(TLSTR *, int, int, char, char, char, char, char, char) ;\nint getvfid(char *) ;\nint getdev() ;\nint remflds() ;\nint delfld(int) ;\nint erasefld(int) ;\nint setfvar(int, char *) ;\nint getfld(int, TLSTR *) ;\nint modfld(int, TLSTR *) ;\nint setfld(int, int, char) ;\nvoid dumpfld() ;\nvoid var2fld() ;\nvoid fld2var() ;\nvoid cursorp(char *, char *) ;\n/* 3270 support */\nint tputn(char *, int) ;\nint tgetn(char *, int) ;\nint tpgn(char *, int) ;\nvoid rc2sba(int, int, char *) ;\nvoid sba2rc(char *, int *, int *, int) ;\nvoid getkeynm(char *, char) ;\nint modsym(char *, char) ;\nint modcolor(char *, char) ;\nint modhilit(char *, char) ;\nint modattr(char *, char) ;\nint getterm(int *, int *, int *, int *, int *) ;\nint querydev() ;\nint dsummary(char *, short) ;\nint darea(char *, short) ;\nint dcharset(char *, short) ;\nint dcolor(char *, short) ;\nint dhilite(char *, short) ;\nint dmodes(char *, short) ;\nint dimpart(char *, short) ;\nint loadps1() ;\nvoid termstat() ;\nvoid clear() ;\n/* varying length string */\nvoid lstran(TLSTR *, char, char) ;\nint lstrlen(TLSTR *) ;\nvoid lstrload(TLSTR *, char *, int) ;\nint lstrunld(char *, TLSTR *) ;\nvoid lstrcopy(TLSTR *, TLSTR *) ;\nvoid lstrnewx(TLSTR *, char *, int) ;\nvoid lstrnew(TLSTR *, char *) ;\nvoid lstrsub(TLSTR *, TLSTR *, int, int) ;\nint lstrindx(TLSTR *, TLSTR *) ;\nvoid lstrfill(TLSTR *, char *) ;\nint lstrcmpc(TLSTR *, char *) ;\nvoid lstrdel(TLSTR *) ;\nvoid lstrover(TLSTR *, char, int) ;\nvoid lstrrep(TLSTR *, char *, int) ;\nvoid lstrcat(TLSTR *, TLSTR *, TLSTR *) ;\n/* utility */\nvoid fill(char *, char, int) ;\nvoid dumpchar(char *, int) ;\nvoid overlay(char *, int, char *, int, int) ;\nvoid serror(int, char *) ;\nvoid strtoupr(char *) ;\n\n\n\n/*--------------------------------------------------------------------*/\n/* Main program                                                       */\n/*--------------------------------------------------------------------*/\nmain(int argc, char **argv, char **envp)\n  {\n    char *input, *cmdname, *operands ;\n    char *number_end ;\n    char *color ;\n    char rexxnm\u00dd9\u00a8 ;      /* if rexxflg, names a REXX to start */\n    int interact ;\n    int rexxflg = 0 ;     /* processing with REXX option */\n    int cmdcnt = 0 ;\n    int rcode ;\n    int maxrc = 0 ;\n    int i ;               /* counter */\n    int t ;               /* temp */\n\n    mlev = 0 ;\n    attrnext = 0 ;\n    windows = NULL ;  /* root of all windows */\n    curwin = NULL ;   /* root of current 3270 window field list */\n\n    /* extract program parameters */\n    if (argc>0)\n      {\n        i = 1 ;           /* skip first arg(0)=(pgm name) */\n        while(i<argc)\n          {\n            if (strcmp(argv\u00ddi\u00a8,\"-D\")==0)\n              mlev = 9 ;     /* debug on */\n            else if (strcmp(argv\u00ddi\u00a8,\"-M\")==0)\n              mlev = 1 ;     /* debug on */\n            else if (strcmp(argv\u00ddi\u00a8,\"-H\")==0)\n              {\n                help() ;        /* print some help info and end */\n                return 0 ; /* and exit */\n              }\n            else if (strcmp(argv\u00ddi\u00a8,\"-REXX\")==0)\n              {\n                i++ ;\n                if (i<argc)\n                  {\n                    rexxflg = 1 ;\n                    strcpy(rexxnm,argv\u00ddi\u00a8) ;\n                  }\n              }\n            else if (strcmp(argv\u00ddi\u00a8,\"-ML\")==0)\n              {               /* documentory name */\n                i++ ;\n                if (i<argc)\n                  {\n                    mlev = strtol(argv\u00ddi\u00a8, &number_end,10) ;\n                    if (!number_end)\n                      {\n                        sprintf(msg,\"Invalid message level %s\",argv\u00ddi\u00a8);\n                        execmsg(\"WIN002E\",msg) ;\n                        rcode = 4 ;\n                      }\n                    else\n                      {\n                        if (mlev <= 9)\n                          {\n                            sprintf(msg,\"Message level now %d\",mlev) ;\n                            execmsg(\"WIN003I\",msg) ;\n                          }\n                        else\n                          {\n                            sprintf(msg,\"Message too large, 0 used.\") ;\n                            execmsg(\"WIN003I\",msg) ;\n                            mlev = 0 ;\n                          }\n                      }\n                  }\n              }\n            else\n              {\n                sprintf(msg,\"Ingoring invalid parameter: %s \\n\",\n                  argv\u00ddi\u00a8) ;\n                execmsg(\"WIN006I\",msg) ;\n                sprintf(msg,\"Use -H parm. for more info.\\n\") ;\n                execmsg(\"WIN007I\",msg) ;\n                sprintf(msg,\"Use WX sub-command to end.\\n\") ;\n                execmsg(\"WIN009I\",msg) ;\n              }\n            i++ ;\n          }  /* of while more args */\n      }  /* of if args */\n\n    rcode = initscr() ;\n    if (rcode != 0)\n      {\n        sprintf(msg,\"WIN3270 create environment failed, rc=%d\",rcode) ;\n        execmsg(\"WIN020E\",msg) ;\n        return 8 ;\n      }\n\n    interact = 0 ;\n    execinit(\"WIN3270\",interact) ;    /* init - noninteractive mode */\n\n    *msg = '\\0' ;\n    for (i=0;i<sdcb.hilites;i++)\n      {\n        switch (sdcb.hilitlst\u00ddi\u00a8)\n          {\n          case BLINK:\n            color = \"BLINK\" ;\n            break ;\n          case REVERSE:\n            color = \"REVERSE\" ;\n            break ;\n          case ULINE:\n            color = \"ULINE\" ;\n            break ;\n          case DFLT:\n            color = \"NONE\" ;\n            break ;\n          default:\n            color = \"NONE\" ;\n            break ;\n          }\n        if (i==0)\n          sprintf(msg,\"%s\",msg,color) ;  /* first hilite in list */\n        else\n          sprintf(msg,\"%s %s\",msg,color) ;  /* append hilite to list */\n      }\n    rcode = shvset(\"WINSYSDH\",msg) ;\n    if (rcode!=SHV_SUCCESS)\n      {\n        if (mlev>0)\n          {\n            sprintf(msg,\n              \"Failed to set variable WINSYSDH\") ;\n            execmsg(\"WIN063E\",msg) ;\n          }\n        execend() ;\n        return 4 ;\n      }\n\n    *msg = '\\0' ;\n    for (i=0;i<sdcb.colora;i++)\n      {\n        switch (sdcb.colorlst\u00ddi\u00a8)\n          {\n          case BLUE:\n            color = \"BLUE\" ;\n            break ;\n          case RED:\n            color = \"RED\" ;\n            break ;\n          case PINK:\n            color = \"PINK\" ;\n            break ;\n          case GREEN:\n            color = \"GREEN\" ;\n            break ;\n          case CYAN:\n            color = \"CYAN\" ;\n            break ;\n          case YELLOW:\n            color = \"YELLOW\" ;\n            break ;\n          case WHITE:\n            color = \"WHITE\" ;\n            break ;\n          case DFLT:\n            color = \"BLACK\" ;\n            break ;\n          default:\n            color = \"BLACK\" ;\n            break ;\n          }\n        if (i==0)\n          sprintf(msg,\"%s\",msg,color) ;  /* first color in list */\n        else\n          sprintf(msg,\"%s %s\",msg,color) ;  /* append color to list */\n      }\n    rcode = shvset(\"WINSYSDC\",msg) ;\n    if (rcode!=SHV_SUCCESS)\n      {\n        if (mlev>0)\n          {\n            sprintf(msg,\n              \"Failed to set variable WINSYSDC\") ;\n            execmsg(\"WIN057E\",msg) ;\n          }\n        execend() ;\n        return 4 ;\n      }\n\n    sprintf(msg,\"%d\",sdcb.rows) ;\n    rcode = shvset(\"WINSYSNR\",msg) ;\n    if (rcode!=SHV_SUCCESS)\n      {\n        if (mlev>0)\n          {\n            sprintf(msg,\n              \"Failed to set variable WINSYSNR\") ;\n            execmsg(\"WIN058E\",msg) ;\n          }\n        execend() ;\n        return 4 ;\n      }\n\n    sprintf(msg,\"%d\",sdcb.cols) ;\n    rcode = shvset(\"WINSYSNC\",msg) ;\n    if (rcode!=SHV_SUCCESS)\n      {\n        if (mlev>0)\n          {\n            sprintf(msg,\n              \"Failed to set variable WINSYSNC\") ;\n            execmsg(\"WIN059E\",msg) ;\n          }\n        execend() ;\n        return 4 ;\n      }\n\n    if (sdcb.aplflg)\n      rcode = shvset(\"WINSYSAP\",\"Y\") ;\n    else\n      rcode = shvset(\"WINSYSAP\",\"N\") ;\n    if (rcode!=SHV_SUCCESS)\n      {\n        if (mlev>0)\n          {\n            sprintf(msg,\n              \"Failed to set variable WINSYSAP\") ;\n            execmsg(\"WIN060E\",msg) ;\n          }\n        execend() ;\n        return 4 ;\n      }\n\n    if (sdcb.loadflg)\n      rcode = shvset(\"WINSYSPS\",\"Y\") ;\n    else\n      rcode = shvset(\"WINSYSPS\",\"N\") ;\n    if (rcode!=SHV_SUCCESS)\n      {\n        if (mlev>0)\n          {\n            sprintf(msg,\n              \"Failed to set variable WINSYSPS\") ;\n            execmsg(\"WIN061E\",msg) ;\n          }\n        execend() ;\n        return 4 ;\n      }\n\n    if (sdcb.graflg)\n      rcode = shvset(\"WINSYSGR\",\"Y\") ;\n    else\n      rcode = shvset(\"WINSYSGR\",\"N\") ;\n    if (rcode!=SHV_SUCCESS)\n      {\n        if (mlev>0)\n          {\n            sprintf(msg,\n              \"Failed to set variable WINSYSGR\") ;\n            execmsg(\"WIN062E\",msg) ;\n          }\n        execend() ;\n        return 4 ;\n      }\n\n    if (rexxflg)       /* is there an initial REXX to start */\n      rcode = execcall(rexxnm) ;           /* yes, start it */\n\n    for (;;)\n      {\n        operands = input = execget() ;\n        if (mlev>4)\n          {\n            sprintf(msg,\"<> %s\",input) ;\n            execmsg(0,msg) ;\n          }\n\n        /* get next input line */\n        if (!input)\n          break ;\n\n        cmdname = execid(&operands) ;\n\n        /* obtain command name, if error in execid expect */\n        /* CLIST/EXEC input next */\n        if (!cmdname)\n          {\n            interact = 1 ;\n            continue ;\n          }\n\n        if (!*cmdname)    /* check for null input */\n          {\n            continue ;\n          }\n\n        /* if execid did an EXEC for us, note and continue */\n        else if (strcmp(cmdname,\"*EXEC\") == 0)\n          {\n            interact = 0 ;\n            continue ;\n          }\n\n        /* if just switched from EXEC to the terminal, note this */\n        else if (strcmp(cmdname,\"*ENDEXEC\") == 0 )\n          {\n            interact = 1 ;\n            rcode = atoi(operands) ;\n            /* extract the exec return code - it might be missing */\n            if (operands)\n              sprintf(msg,\"Exec return code %d\",rcode) ;\n            else\n               strcpy(msg,\"Exec return code not available.\") ;\n            execmsg(\"WIN001I\",msg) ;\n          }\n\n        /* WX sub command */\n        else if (strcmp(cmdname,\"WX\") == 0)\n          {\n            if (mlev>3)\n              {\n                sprintf(msg,\"Subcommand: %s (%s)\",cmdname,operands) ;\n                execmsg(\"WIN068I\",msg) ;\n              }\n            rcode = wxcmd(operands) ;\n            if (mlev>2)\n              {\n                sprintf(msg,\"Subcommand %s lastcc: %d\",cmdname,rcode) ;\n                execmsg(\"WIN069I\",msg) ;\n              }\n            break ;\n          }\n\n        /* Call exec for EXEC SUBCOMmand and expect input from it */\n        else if (strcmp(cmdname,\"EXEC\") == 0)\n          {\n            /* call EXEC for EXEC sub-command */\n            rcode = execcall(input) ;\n            interact = 0 ;\n            if (rcode != 0)\n              {\n                sprintf(msg,\"Exec failed with return code %d\",\n                  rcode) ;\n                execmsg(\"WIN005E\",msg) ;\n              }\n          }\n\n        /* WA sub command - set Window Attributes */\n        else if (strcmp(cmdname,\"WA\") == 0)\n          {\n            if (mlev>3)\n              {\n                sprintf(msg,\"Subcommand: %s (%s)\",cmdname,operands) ;\n                execmsg(\"WIN068I\",msg) ;\n              }\n            rcode = wacmd(operands) ;\n            if (mlev>2)\n              {\n                sprintf(msg,\"Subcommand %s lastcc: %d\",cmdname,rcode) ;\n                execmsg(\"WIN069I\",msg) ;\n              }\n          }\n\n        /* WE sub command - set Window Erase  */\n        else if (strcmp(cmdname,\"WE\") == 0)\n          {\n            if (mlev>3)\n              {\n                sprintf(msg,\"Subcommand: %s (%s)\",cmdname,operands) ;\n                execmsg(\"WIN068I\",msg) ;\n              }\n            rcode = wecmd(operands) ;\n            if (mlev>2)\n              {\n                sprintf(msg,\"Subcommand %s lastcc: %d\",cmdname,rcode) ;\n                execmsg(\"WIN069I\",msg) ;\n              }\n          }\n\n        /* WC sub command - set Window Create */\n        else if (strcmp(cmdname,\"WC\") == 0)\n          {\n            if (mlev>3)\n              {\n                sprintf(msg,\"Subcommand: %s (%s)\",cmdname,operands) ;\n                execmsg(\"WIN068I\",msg) ;\n              }\n            rcode = wccmd(operands) ;\n            if (mlev>2)\n              {\n                sprintf(msg,\"Subcommand %s lastcc: %d\",cmdname,rcode) ;\n                execmsg(\"WIN069I\",msg) ;\n              }\n          }\n\n        /* WS sub command - set Window define row */\n        else if (strcmp(cmdname,\"WS\") == 0)\n          {\n            if (mlev>3)\n              {\n                sprintf(msg,\"Subcommand: %s (%s)\",cmdname,operands) ;\n                execmsg(\"WIN068I\",msg) ;\n              }\n            rcode = wscmd(operands) ;\n            if (mlev>2)\n              {\n                sprintf(msg,\"Subcommand %s lastcc: %d\",cmdname,rcode) ;\n                execmsg(\"WIN069I\",msg) ;\n              }\n          }\n\n        /* WD sub command - set Window Display */\n        else if (strcmp(cmdname,\"WD\") == 0)\n          {\n            if (mlev>3)\n              {\n                sprintf(msg,\"Subcommand: %s (%s)\",cmdname,operands) ;\n                execmsg(\"WIN068I\",msg) ;\n              }\n            rcode = wdcmd(operands) ;\n            if (mlev>2)\n              {\n                sprintf(msg,\"Subcommand %s lastcc: %d\",cmdname,rcode) ;\n                execmsg(\"WIN069I\",msg) ;\n              }\n          }\n\n        /* HELP sub command - Help */\n        else if (strcmp(cmdname,\"HELP\") == 0)\n          {\n            if (mlev>3)\n              {\n                sprintf(msg,\"Subcommand: %s (%s)\",cmdname,operands) ;\n                execmsg(\"WIN068I\",msg) ;\n              }\n            help() ;\n            if (mlev>2)\n              {\n                sprintf(msg,\"Subcommand %s lastcc: %d\",cmdname,rcode) ;\n                execmsg(\"WIN069I\",msg) ;\n              }\n          }\n\n        /* WH sub command - Help */\n        else if (strcmp(cmdname,\"WH\") == 0)\n          {\n            if (mlev>3)\n              {\n                sprintf(msg,\"Subcommand: %s (%s)\",cmdname,operands) ;\n                execmsg(\"WIN068I\",msg) ;\n              }\n            help() ;\n            if (mlev>2)\n              {\n                sprintf(msg,\"Subcommand %s lastcc: %d\",cmdname,rcode) ;\n                execmsg(\"WIN069I\",msg) ;\n              }\n          }\n\n        /* WM sub command, set message level, 0 is off */\n        else if (strcmp(cmdname,\"WM\") == 0)\n          {\n            if (mlev>3)\n              {\n                sprintf(msg,\"Subcommand: %s (%s)\",cmdname,operands) ;\n                execmsg(\"WIN068I\",msg) ;\n              }\n            t = strtol(operands, &number_end,10) ;\n            if (!number_end)\n              {\n                sprintf(msg,\"Invalid message level %s\",operands) ;\n                execmsg(\"WIN002E\",msg) ;\n                rcode = 4 ;\n              }\n            else\n              {\n                if (t <= 9)  /* valid message level */\n                  {\n                    sprintf(msg,\"Message level now %d\",t) ;\n                    execmsg(\"WIN003I\",msg) ;\n                    mlev = t ;\n                  }\n                else  /* specific debugging function */\n                  {\n                    if (t == 10)\n                      termstat() ;\n                    else if (t == 11)\n                      dumpfld() ;\n                    else if (t == 12)\n                      iotrace = 1 ;\n                    else if (t == 13)\n                      iotrace = 0 ;\n                    else\n                      {\n                        sprintf(msg,\"Invalid message level, 0 used.\") ;\n                        execmsg(\"WIN003I\",msg) ;\n                        mlev = 0 ;\n                      }\n                  }\n              }\n          }\n\n        /* Uknown command, try to execute it. */\n        else\n          {\n            rcode = execcall(input) ;\n            interact = 0 ;\n          }\n\n        cmdcnt++ ;\n        maxrc = execrc(rcode) ;    /* inform exec of return code */\n      }  /* of for ever (until WX command) */\n\n\n    if (mlev>1)\n      {\n        sprintf(msg,\"%d commands executed, max. return code %d\",\n          cmdcnt,maxrc) ;\n        execmsg(\"WIN004I\",msg) ;\n      }\n\n    execend() ;\n    return maxrc ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* Show a limited amount of help info.                               */\n/*-------------------------------------------------------------------*/\nvoid help()\n  {\n    int i ;\n    char helpinfo\u00dd\u00a8\u00dd60\u00a8 = {\n      {\"Sub commands available are:\"},\n      {\" WA - Set field attributes\"},\n      {\" WE - Erase a window\"},\n      {\" WC - Create a window\"},\n      {\" WS - Define line in window\"},\n      {\" WD - Display a window\"},\n      {\" WX - Terminate WIN3270\"},\n      {\" WM - Set debug level\"},\n      {\".\"}\n    } ;\n    sprintf(msg,\"WIN3270 Help information follows:\\n\") ;\n    execmsg(\"WIN008I\",msg) ;\n    i = 0 ;\n    while(strcmp(helpinfo\u00ddi\u00a8,\".\") != 0)\n      {\n        sprintf(msg,\"%s\\n\",helpinfo\u00ddi\u00a8) ;\n        execmsg(0,msg) ;\n        i++ ;\n      }\n  }\n\n/*-------------------------------------------------------------------*/\n/* Window sub command environment termination processing             */\n/*-------------------------------------------------------------------*/\nint wxcmd(char *parm)\n  {\n    clear() ;\n    termscr() ;\n    return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* Window Attribute command processing                               */\n/*-------------------------------------------------------------------*/\nint wacmd(char *parm)\n  {\n    char *word ;         /* current token */\n    char temp\u00dd10\u00a8 ;      /* temp area for token */\n    int i ;              /* counter */\n    int n = 1 ;          /* current token number */\n    int valueflg = 0 ;   /* flag - seen VALUE= parm */\n    int found ;          /* flag - found value attr char */\n    int attrix ;         /* index pos of this attr in table attrtab */\n    char value ;         /* value (name) of attribute */\n    char type ;          /* type of attribute */\n    char color ;         /* color of attribute */\n    char hilite ;        /* hilite of attribute */\n    char symbol ;        /* symbol of attribute */\n    char just ;          /* just of attribute */\n\n    type = 'L' ;         /* default type of attribute */\n    color = GREEN ;      /* default color of attribute */\n    hilite = NONE ;      /* default hilite of attribute */\n    symbol = NONE ;      /* default symbol of attribute */\n    just = 'N' ;         /* default just of attribute */\n\n    word = strtok(parm,DELIMS) ;\n    while(word != NULL)\n      {\n        if (mlev>3)\n          {\n            sprintf(msg,\"  Parm %d: %s\",n,word) ;\n            execmsg(0,msg) ;\n          }\n        if (strlen(word) >10)\n          {\n            if (mlev>0)\n              {\n                sprintf(msg,\"Invalid parameter length for: %s\",word) ;\n                execmsg(\"WIN018E\",msg) ;\n              }\n            return 36 ;\n          }\n        strcpy(temp,word) ;\n        strtoupr(temp) ;\n\n        if (strcmp(temp,\"VALUE\") == 0)\n          {\n            valueflg = 1 ;   /* indicate seen required parm */\n            word = strtok(NULL,DELIMS) ;  /* get next word */\n            found = 0 ;\n            value = *word ;  /* value name is first char */\n                             /* ignore extra characters in token */\n            for(i=0;i<attrnext;i++)\n              {\n                if (attrtab\u00ddi\u00a8\u00ddAVALUE\u00a8 == value)\n                  {        /* replace old value */\n                    attrtab\u00ddi\u00a8\u00ddAVALUE\u00a8 = value ;\n                    attrix = i ;\n                    found = 1 ;\n                  }\n              }\n            if (!found) /* add new value */\n              {\n                attrtab\u00ddattrnext\u00a8\u00ddAVALUE\u00a8 = value ;\n                attrix = attrnext ;\n                attrnext++ ;\n              }\n          }\n\n        else if (strcmp(temp,\"TYPE\") == 0)\n          {\n            word = strtok(NULL,DELIMS) ;  /* get next word */\n            if (strlen(word) >10)\n              {\n                if (mlev>0)\n                  {\n                    sprintf(msg,\"Invalid value length for: %s\",word) ;\n                    execmsg(\"WIN019E\",msg) ;\n                  }\n                return 40 ;\n              }\n            strcpy(temp,word) ;\n            strtoupr(temp) ;\n            if (strcmp(temp,\"LABEL\") == 0)\n              type = 'L' ;\n            else if (strcmp(temp,\"INPUT\") == 0)\n              type = 'I' ;\n            else if (strcmp(temp,\"OUTPUT\") == 0)\n              type = 'O' ;\n            else if (strcmp(temp,\"BUTTON\") == 0)\n              type = 'B' ;\n            else if (strcmp(temp,\"RADIO\") == 0)\n              type = 'R' ;\n            else if (strcmp(temp,\"CHECKBOX\") == 0)\n              type = 'C' ;\n            else  /* invalid parm */\n              {\n                if (mlev>0)\n                  {\n                    sprintf(msg,\"Invalid TYPE= value %s\",temp) ;\n                    execmsg(\"WIN012E\",msg) ;\n                  }\n                return 8 ;\n              }\n          }\n\n        else if (strcmp(temp,\"COLOR\") == 0)\n          {\n            word = strtok(NULL,DELIMS) ;  /* get next word */\n            if (strlen(word) >10)\n              {\n                if (mlev>0)\n                  {\n                    sprintf(msg,\"Invalid value length for: %s\",word) ;\n                    execmsg(\"WIN019E\",msg) ;\n                  }\n                return 40 ;\n              }\n            strcpy(temp,word) ;\n            strtoupr(temp) ;\n            if (strcmp(temp,\"RED\") == 0)\n              color = RED ;\n            else if (strcmp(temp,\"BLUE\") == 0)\n              color = BLUE ;\n            else if (strcmp(temp,\"GREEN\") == 0)\n              color = GREEN ;\n            else if (strcmp(temp,\"WHITE\") == 0)\n              color = WHITE ;\n            else if (strcmp(temp,\"PINK\") == 0)\n              color = PINK ;\n            else if (strcmp(temp,\"YELLOW\") == 0)\n              color = YELLOW ;\n            else if (strcmp(temp,\"CYAN\") == 0)\n              color = CYAN ;\n            else if (strcmp(temp,\"NONE\") == 0)\n              color = NONE ;\n            else if (strcmp(temp,\"BLACK\") == 0)\n              color = NONE ;\n            else  /* invalid parm */\n              {\n                if (mlev>0)\n                  {\n                    sprintf(msg,\"Invalid COLOR= value %s\",temp) ;\n                    execmsg(\"WIN013E\",msg) ;\n                  }\n                return 12 ;\n              }\n          }\n\n        else if (strcmp(temp,\"HILITE\") == 0)\n          {\n            word = strtok(NULL,DELIMS) ;  /* get next word */\n            if (strlen(word) >10)\n              {\n                if (mlev>0)\n                  {\n                    sprintf(msg,\"Invalid value length for: %s\",word) ;\n                    execmsg(\"WIN019E\",msg) ;\n                  }\n                return 40 ;\n              }\n            strcpy(temp,word) ;\n            strtoupr(temp) ;\n            if (strcmp(temp,\"BLINK\") == 0)\n              hilite = BLINK ;\n            else if (strcmp(temp,\"REVERSE\") == 0)\n              hilite = REVERSE ;\n            else if (strcmp(temp,\"ULINE\") == 0)\n              hilite = ULINE ;\n            else if (strcmp(temp,\"NONE\") == 0)\n              hilite = NONE ;\n            else  /* invalid parm */\n              {\n                if (mlev>0)\n                  {\n                    sprintf(msg,\"Invalid HILITE= value %s\",temp) ;\n                    execmsg(\"WIN014E\",msg) ;\n                  }\n                return 16 ;\n              }\n          }\n\n        else if (strcmp(temp,\"SYMBOL\") == 0)\n          {\n            word = strtok(NULL,DELIMS) ;  /* get next word */\n            if (strlen(word) >10)\n              {\n                if (mlev>0)\n                  {\n                    sprintf(msg,\"Invalid value length for: %s\",word) ;\n                    execmsg(\"WIN019E\",msg) ;\n                  }\n                return 40 ;\n              }\n            strcpy(temp,word) ;\n            strtoupr(temp) ;\n            if (strcmp(temp,\"APL\") == 0)\n              symbol = APL ;\n            else if (strcmp(temp,\"PS\") == 0)\n              symbol = 0x40 ;\n            else if (strcmp(temp,\"NONE\") == 0)\n              symbol = NONE ;\n            else  /* invalid parm */\n              {\n                if (mlev>0)\n                  {\n                    sprintf(msg,\"Invalid SYMBOL= value %s\",temp) ;\n                    execmsg(\"WIN015E\",msg) ;\n                  }\n                return 20 ;\n              }\n          }\n\n        else if (strcmp(temp,\"JUST\") == 0)\n          {\n            word = strtok(NULL,DELIMS) ;  /* get next word */\n            if (strlen(word) >10)\n              {\n                if (mlev>0)\n                  {\n                    sprintf(msg,\"Invalid value length for: %s\",word) ;\n                    execmsg(\"WIN019E\",msg) ;\n                  }\n                return 40 ;\n              }\n            strcpy(temp,word) ;\n            strtoupr(temp) ;\n            if (strcmp(temp,\"LEFT\") == 0)\n              just = 'L' ;\n            else if (strcmp(temp,\"CENTER\") == 0)\n              just = 'C' ;\n            else if (strcmp(temp,\"RIGHT\") == 0)\n              just = 'R' ;\n            else if (strcmp(temp,\"NONE\") == 0)\n              just = 'N' ;\n            else  /* invalid parm */\n              {\n                if (mlev>0)\n                  {\n                    sprintf(msg,\"Invalid JUST= value %s\",temp) ;\n                    execmsg(\"WIN016E\",msg) ;\n                  }\n                return 24 ;\n              }\n          }\n\n        else  /* invalid parm */\n          {\n            if (mlev>0)\n              {\n                sprintf(msg,\"Invalid WA parameter %s\",temp) ;\n                execmsg(\"WIN010E\",msg) ;\n              }\n            return 32 ;\n          }\n\n        word = strtok(NULL,DELIMS) ;  /* get next word */\n        n++ ;\n      }    /* of while tokens */\n\n    if (valueflg)  /* value= parameter was specified - update entry */\n      {\n        if (mlev>3)\n          {\n            sprintf(msg,\n            \"  Value:%c Type:%c Color:%2X Hilite:%2X Symbol:%2X Just:%c\"\n              ,value,type,color,hilite,symbol,just) ;\n            execmsg(0,msg) ;\n          }\n        attrtab\u00ddattrix\u00a8\u00ddATYPE\u00a8 = type ;\n        attrtab\u00ddattrix\u00a8\u00ddACOLOR\u00a8 = color ;\n        attrtab\u00ddattrix\u00a8\u00ddAHILITE\u00a8 = hilite ;\n        attrtab\u00ddattrix\u00a8\u00ddASYMBOL\u00a8 = symbol ;\n        attrtab\u00ddattrix\u00a8\u00ddAJUST\u00a8 = just ;\n      }\n    else\n      {\n        if (mlev>0)\n          {\n            sprintf(msg,\"Invalid WA sub-command, no VALUE= parameter\") ;\n            execmsg(\"WIN017E\",msg) ;\n          }\n        return 28 ;\n      }\n    return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* Window Erase command processing                                   */\n/*-------------------------------------------------------------------*/\nint wecmd(char *parm)\n  {\n    int found = 0 ;      /* window found flag */\n    int n = 1 ;          /* token counter */\n    char *word ;         /* current token */\n    char temp\u00dd10\u00a8 ;      /* temp area for token */\n    char name\u00dd9\u00a8 ;       /* name of window to erase */\n    char nameflg = 0 ;   /* flag - seen NAME= parm */\n    TWINDOW *last, *top ;\n\n    if (windows)\n      {\n        word = strtok(parm,DELIMS) ;\n        while(word != NULL)\n          {\n            if (mlev>3)\n              {\n                sprintf(msg,\"  Parm %d: %s\",n,word) ;\n                execmsg(0,msg) ;\n              }\n            if (strlen(word) >10)\n              {\n                if (mlev>0)\n                  {\n                    sprintf(msg,\"Invalid parameter length for: %s\",\n                      word) ;\n                    execmsg(\"WIN018E\",msg) ;\n                  }\n                return 8 ;\n              }\n            strcpy(temp,word) ;\n            strtoupr(temp) ;\n\n            if (strcmp(temp,\"NAME\") == 0)\n              {\n                word = strtok(NULL,DELIMS) ;  /* get next word */\n                if (*word)\n                  {\n                    nameflg = 1 ;   /* indicate seen required parm */\n                    if (strlen(word) >8)\n                      {\n                        if (mlev>0)\n                          {\n                             sprintf(msg,\n                               \"Length too long (>8) for name: %s\",\n                               word) ;\n                             execmsg(\"WIN028E\",msg) ;\n                           }\n                         return 12 ;\n                      }\n                    strcpy(name,word) ;\n                    strtoupr(name) ;\n\n                    /* locate window by name on window list */\n                    /*   if not found do error lastcc 12 */\n                    found = 0 ;\n                    last = NULL ;\n                    top = windows ;\n                    while (top)\n                      {\n                        if (strcmp(top->name,name) == 0)\n                          {\n                            found = 1 ;\n                            break ;\n                          }\n                        last = top ;\n                        top = top->next ;\n                      }\n                    if (!found)\n                      {\n                        if (mlev>0)\n                          {\n                            sprintf(msg,\"Window %s not found.\",name) ;\n                            execmsg(\"WIN043E\",msg) ;\n                          }\n                        return 12 ;\n                      }\n\n                    /* set found window as the current window */\n                    curwin = top ;\n\n                    /* do remflds() to this windows fields */\n                    remflds() ;\n\n                    /* remove the window from the list */\n                    if (last)\n                      last->next = top->next ;\n                    else\n                      windows = top->next ;\n                    free((TWINDOW *)curwin) ;\n\n                    /* set current window to first window */\n                    /*   remaining on the window list */\n                    curwin = windows ;\n                    if (!curwin)\n                      {\n                        if (mlev>0)\n                          {\n                            sprintf(msg,\"No windows currently defined\");\n                            execmsg(\"WIN044I\",msg) ;\n                          }\n                      }\n                  }\n              }\n\n            else  /* invalid parm */\n              {\n                if (mlev>0)\n                  {\n                    sprintf(msg,\"Invalid WE parameter %s\",temp) ;\n                    execmsg(\"WIN021E\",msg) ;\n                  }\n                return 8 ;\n              }\n\n            word = strtok(NULL,DELIMS) ;  /* get next word */\n            n++ ;\n          }    /* of while tokens */\n\n        if (! nameflg)  /* name= parameter not specified */\n          {\n            if (mlev>0)\n              {\n                sprintf(msg,\n                  \"Invalid WE sub-command, no NAME= parameter\") ;\n                execmsg(\"WIN022E\",msg) ;\n              }\n            return 4 ;\n          }\n\n      }   /* of if windows */\n    return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* Window Create command processing                                  */\n/*-------------------------------------------------------------------*/\nint wccmd(char *parm)\n  {\n    int n = 1 ;          /* token counter */\n    char *word ;         /* current token */\n    char temp\u00dd10\u00a8 ;      /* temp area for token */\n    char name\u00dd9\u00a8 ;       /* name of window to erase */\n    char nameflg = 0 ;   /* flag - seen NAME= parm */\n    TWINDOW *newwin, *last, *top ;\n\n    word = strtok(parm,DELIMS) ;\n    while(word != NULL)\n      {\n        if (mlev>3)\n          {\n            sprintf(msg,\"  Parm %d: %s\",n,word) ;\n            execmsg(0,msg) ;\n          }\n        if (strlen(word) >10)\n          {\n            if (mlev>0)\n              {\n                sprintf(msg,\"Invalid parameter length for: %s\",\n                  word) ;\n                execmsg(\"WIN018E\",msg) ;\n              }\n            return 16 ;\n          }\n        strcpy(temp,word) ;\n        strtoupr(temp) ;\n\n        if (strcmp(temp,\"NAME\") == 0)\n          {\n            word = strtok(NULL,DELIMS) ;  /* get next word */\n            if (*word)\n              {\n                nameflg = 1 ;   /* indicate seen required parm */\n                if (strlen(word) >8)\n                  {\n                    if (mlev>0)\n                      {\n                         sprintf(msg,\n                           \"Length too long (>8) for name: %s\",\n                           word) ;\n                         execmsg(\"WIN028E\",msg) ;\n                       }\n                     return 16 ;\n                  }\n                strcpy(name,word) ;\n                strtoupr(name) ;\n\n                /* locate window on window list */\n                /* if it exists do error lastcc 8 */\n                top = windows ;\n                while (top)\n                  {\n                    if (strcmp(top->name,name) == 0)\n                      {\n                        sprintf(msg,\"Window %s already exists.\",name) ;\n                        execmsg(\"WIN023E\",msg) ;\n                        return 8 ;\n                      }\n                    top = top->next ;\n                  }\n\n                /* get storage for new window node */\n                newwin = (TWINDOW *)malloc(sizeof(TWINDOW)) ;\n                if (!newwin) serror(50,\"Not enough memory\") ;\n                memset(newwin,0x00,sizeof(TWINDOW)) ;\n\n                /* initialise window information */\n                newwin->fields = NULL ; /* next field id number */\n                newwin->fidnext = 0 ;   /* next field id number */\n                strcpy(newwin->name,name) ;  /* name of window */\n                newwin->inputflg = 1;   /* input flag 0=none,1=allowed*/\n                newwin->delay = 0 ;     /* do not delay */\n                newwin->srow = 1 ;      /* start row */\n                newwin->scol = 1 ;      /* start col */\n                newwin->lastrow = 1 ;   /* initial cursor row */\n                newwin->lastcol = 1 ;   /* initial cursor col */\n                newwin->eraseflg = 1 ;  /* ensure screen erase write */\n\n                /* create a new window entry in list */\n                newwin->next = NULL ;\n                if (!windows) /* first entry in list (windows->00) */\n                  windows = newwin ;\n                else  /* insert new window at top of window list */\n                  {\n                    last = windows ;\n                    windows = newwin ;\n                    windows->next = last ;\n                  }\n\n                /* set this new window as the current window */\n                curwin = newwin ;\n              }\n          }\n\n        else  /* invalid parm */\n          {\n            if (mlev>0)\n              {\n                sprintf(msg,\"Invalid WC parameter %s\",temp) ;\n                execmsg(\"WIN023E\",msg) ;\n              }\n            return 12 ;\n          }\n\n        word = strtok(NULL,DELIMS) ;  /* get next word */\n        n++ ;\n      }    /* of while tokens */\n\n    if (! nameflg)  /* name= parameter not specified */\n      {\n        if (mlev>0)\n          {\n            sprintf(msg,\n              \"Invalid WC sub-command, no NAME= parameter\") ;\n            execmsg(\"WIN024E\",msg) ;\n          }\n        return 4 ;\n      }\n\n    return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* Window define row command processing                              */\n/*-------------------------------------------------------------------*/\nint wscmd(char *parm)\n  {\n    int len ;            /* length of current field */\n    int fid ;            /* temp field id */\n    int found ;          /* attribute character found flag */\n    int infield = 0 ;    /* field start located yet flag */\n    int row ;            /* row number being processed */\n    int col ;            /* start col of current field being processed*/\n    int i ;              /* counter */\n    char crow\u00dd3\u00a8 ;       /* char line number */\n    char vname\u00ddTSOVSIZE\u00a8;/* tso variable name */\n    char *start ;        /* start of field definition area */\n    char *c ;            /* current character */\n    char *d ;            /* end field character */\n    char *e ;            /* temp char pointer */\n    char *f ;            /* temp char pointer */\n    char *number_end;    /* end str marker */\n    char type ;          /* type of attribute */\n    char color ;         /* color of attribute */\n    char hilite ;        /* hilite of attribute */\n    char symbol ;        /* symbol of attribute */\n    char just ;          /* just of attribute */\n    TLSTR data ;         /* field data */\n    TLSTR data1 ;        /* field data */\n    TLSTR data2 ;        /* field data */\n    TLSTR data3 ;        /* field data */\n\n    if (curwin)\n      {\n        /*------------------------------------------------------*/\n        /* Parm should contain the following format on entry    */\n        /* nn %text    %  %text  % text   text                  */\n        /* Where - nn is numeric with a length of 2 followed by */\n        /*         one blank.                                   */\n        /*       - % is an attribute character                  */\n        /*         Column 4 is the first column of the field    */\n        /*         definition area, and must contain an         */\n        /*         attribute character.                         */\n        /*       - text is any characters other than attribute  */\n        /*         characters, including the blank character.   */\n        /*------------------------------------------------------*/\n\n        /* get row number and make sure it is a valid row number */\n        memcpy(crow,parm,3) ;\n        crow\u00dd2\u00a8 = 0x00 ;\n        row = strtol(crow, &number_end,10) ;\n        if (!number_end)\n          {\n            if (mlev>0)\n              {\n                sprintf(msg,\"Invalid row %s\",crow) ;\n                execmsg(\"WIN045E\",msg) ;\n              }\n            return 8 ;\n          }\n        else\n          {\n            if ((row > sdcb.rows) || (row < 1))\n              {\n                if (mlev>0)\n                  {\n                    sprintf(msg,\"Row number %d out of range.\",row) ;\n                    execmsg(\"WIN046E\",msg) ;\n                  }\n                return 4 ;\n              }\n          }\n\n        /* examine each character and test if it is an attr char */\n        c = parm+3 ;\n        start = c ;\n        while(*c)    /* for all characters in the row */\n          {\n            found = 0 ;\n            /* look up the char in the attribute table and leave */\n            /* the index in i if the char is found */\n            for(i=0;i<attrnext;i++)\n              {\n                if (attrtab\u00ddi\u00a8\u00ddAVALUE\u00a8 == *c)\n                  {\n                    found = 1 ;\n                    infield = 1 ;\n                    break ;\n                  }\n              }\n            if (!(found && infield)) /* error - first char not attrib */\n              {\n                if (mlev>0)\n                  {\n                    sprintf(msg,\n                      \"Row %d first char (%c) not attibute char.\",\n                      row,*c) ;\n                    execmsg(\"WIN047E\",msg) ;\n                  }\n                return 20 ;\n              }\n\n            /* if attr char look for next attr char to find field len*/\n            if (found)\n              {\n                /* get widget attribs based on index for attrib char */\n                col = (c-start)+1 ;\n                type = attrtab\u00ddi\u00a8\u00ddATYPE\u00a8 ;\n                color = attrtab\u00ddi\u00a8\u00ddACOLOR\u00a8 ;\n                hilite = attrtab\u00ddi\u00a8\u00ddAHILITE\u00a8 ;\n                symbol = attrtab\u00ddi\u00a8\u00ddASYMBOL\u00a8 ;\n                just = attrtab\u00ddi\u00a8\u00ddAJUST\u00a8 ;\n\n                /* look for end of field */\n                found = 0 ;\n                d = c+1 ;\n                while(*d && !found)\n                  {\n                    found = 0 ;\n                    for(i=0;i<attrnext;i++)\n                      {\n                        if (attrtab\u00ddi\u00a8\u00ddAVALUE\u00a8 == *d)\n                          {\n                            found = 1 ;\n                            break ;\n                          }\n                      }\n                    d++ ;\n                  }\n                /* if not at end of string, decrement end string ptr */\n                if ((*d) || ((*d == '\\0') && (found == 1)) )\n                  d-- ;\n\n                /* set field length inclusive of field attribute byte */\n                /* c points at attr byte, and d points at next        */\n                /* attr byte or the end of the field definition area. */\n                len = d-c-1 ;\n                if ((len <= 1) && (type!='L'))\n                  {\n                    if (mlev>0)\n                      {\n                        sprintf(msg,\"Attribute (%c) at \"\n                          \"row %d col %d, field length too small.\",\n                          *c,row,col) ;\n                        execmsg(\"WIN091E\",msg) ;\n                      }\n                    return 20 ;\n                  }\n\n                /* define new field according to type */\n                if (type == 'L')          /* label */\n                  {\n                    if (len < 1)\n                      lstrnew(&data,\" \") ;\n                    else\n                      lstrnewx(&data,c+1,len) ;\n                    fid = insfld(&data,row,col,PRTAS,color,hilite,\n                      type,NONE,NOINPUT) ;\n                    if (fid<0) serror(81,\"Field insert failed\") ;\n\n                    if (sdcb.loadflg && (symbol==0x40))\n                      setfld(fid,SYMSET,0x40) ; /* loaded PS symbols */\n                    else if (sdcb.aplflg && (symbol==APL))\n                      setfld(fid,SYMSET,APL) ; /* APL symbols */\n                  }\n\n                else if (type == 'I')     /* input */\n                  {\n                    /* copy and validate variable name */\n                    e = vname ;\n                    f = c+1 ;\n                    i = 0 ;\n                    while (isalnum(*f))\n                      {\n                        if (i==TSOVSIZE)\n                          break ;\n                        *e++ = *f++ ;\n                        i++ ;\n                      }\n                    *e = '\\0' ;\n                    if ((i<=0) || (i>TSOVSIZE))\n                      {\n                        if (mlev>0)\n                          {\n                            sprintf(msg,\n                              \"Invalid var name length for %s\",c) ;\n                            execmsg(\"WIN049E\",msg) ;\n                          }\n                        return 24 ;\n                      }\n\n                    /* create new field on current window */\n                    lstrnew(&data,\" \") ;\n                    fid = insfld(&data,row,col,UNPRT,color,hilite,\n                      type,NONE,INPUT) ;\n                    if (fid<0) serror(81,\"Field insert failed\") ;\n\n                    if (sdcb.loadflg && (symbol==0x40))\n                      setfld(fid,SYMSET,0x40) ; /* loaded PS symbols */\n                    else if (sdcb.aplflg && (symbol==APL))\n                      setfld(fid,SYMSET,APL) ; /* APL symbols */\n\n                    /* add variable name to field definition */\n                    setfvar(fid,vname) ;\n                  }\n\n                else if (type == 'O')     /* output */\n                  {\n                    /* copy and validate variable name */\n                    e = vname ;\n                    f = c+1 ;\n                    i = 0 ;\n                    while (isalnum(*f))\n                      {\n                        if (i==TSOVSIZE)\n                          break ;\n                        *e++ = *f++ ;\n                        i++ ;\n                      }\n                    *e = '\\0' ;\n                    if ((i<=0) || (i>TSOVSIZE))\n                      {\n                        if (mlev>0)\n                          {\n                            sprintf(msg,\n                              \"Invalid var name length for %s\",c) ;\n                            execmsg(\"WIN050E\",msg) ;\n                          }\n                        return 28 ;\n                      }\n\n                    /* create new field on current window */\n                    lstrnew(&data,\" \") ;\n                    fid = insfld(&data,row,col,PRTAS,color,hilite,\n                      type,NONE,NOINPUT) ;\n                    if (fid<0) serror(81,\"Field insert failed\") ;\n\n                    if (sdcb.loadflg && (symbol==0x40))\n                      setfld(fid,SYMSET,0x40) ; /* loaded PS symbols */\n                    else if (sdcb.aplflg && (symbol==APL))\n                      setfld(fid,SYMSET,APL) ; /* APL symbols */\n\n                    /* add variable name to field definition */\n                    setfvar(fid,vname) ;  /* save variable name */\n                  }\n\n                else if (type == 'B')     /* button */\n                  {\n                    /* copy and validate variable name */\n                    e = vname ;\n                    f = c+1 ;\n                    i = 0 ;\n                    while (isalnum(*f))\n                      {\n                        if (i==TSOVSIZE)\n                          break ;\n                        *e++ = *f++ ;\n                        i++ ;\n                      }\n                    *e = '\\0' ;\n                    if ((i<=0) || (i>TSOVSIZE))\n                      {\n                        if (mlev>0)\n                          {\n                            sprintf(msg,\n                              \"Invalid var name length for %s\",c) ;\n                            execmsg(\"WIN051E\",msg) ;\n                          }\n                        return 32 ;\n                      }\n\n                    /* create new field on current window */\n                    lstrnewx(&data3,c+1,len-2) ;\n                    if (sdcb.loadflg)\n                      {\n                        lstrnew(&data1,\"\\x64\") ; /* left button end */\n                        lstrnew(&data2,\"\\x63\") ; /* right button end */\n                        lstrcat(&data,&data1,&data3) ;\n                        lstrcat(&data3,&data,&data2) ;\n\n                        fid = insfld(&data3,row,col,UNPRT,color,NONE,\n                          type,NONE,NOINPUT) ;\n                        setfld(fid,SYMSET,0x40) ; /*loaded PS symbols*/\n                      }\n                    else\n                      {\n                        lstrnew(&data1,\"(\") ; /* left button end */\n                        lstrnew(&data2,\")\") ; /* right button end */\n                        lstrcat(&data,&data1,&data3) ;\n                        lstrcat(&data3,&data,&data2) ;\n\n                        fid = insfld(&data3,row,col,UNPRT,color,RVIDEO,\n                          type,NONE,NOINPUT) ;\n                      }\n                    /* add variable name to field definition */\n                    setfvar(fid,vname) ;  /* save variable name */\n                  }\n\n                else if (type == 'R')     /* radio */\n                  {\n                    /* copy and validate variable name */\n                    e = vname ;\n                    f = c+1 ;\n                    i = 0 ;\n                    while (isalnum(*f))\n                      {\n                        if (i==TSOVSIZE)\n                          break ;\n                        *e++ = *f++ ;\n                        i++ ;\n                      }\n                    *e = '\\0' ;\n                    if ((i<=0) || (i>TSOVSIZE))\n                      {\n                        if (mlev>0)\n                          {\n                            sprintf(msg,\n                              \"Invalid var name length for %s\",c) ;\n                            execmsg(\"WIN052E\",msg) ;\n                          }\n                        return 36 ;\n                      }\n\n                    /* create new field on current window */\n                    /* subtract length of variable name and one  */\n                    /* blank character, this should allow for    */\n                    /* the control at the front of the text.     */\n                    lstrnewx(&data,f+1,len-i-1) ;\n                    fid = insfld(&data,row,col+2,UNPRT,color,hilite,\n                      type,TEXT,NOINPUT) ;\n                    /* add variable name to field definition */\n                    setfvar(fid,vname) ;  /* save variable name */\n                    if (sdcb.loadflg)\n                      {\n                        lstrnew(&data,\"\\x54\") ;   /* un pressed sym */\n                        fid = insfld(&data,row,col,UNPRT,color,hilite,\n                          type,CONTROL,NOINPUT) ;\n                        setfld(fid,SYMSET,0x40) ; /*loaded PS symbols*/\n                      }\n                    else if (sdcb.aplflg)\n                      {\n                        lstrnew(&data,\"\\x9d\") ; /* un pressed sym */\n                        fid = insfld(&data,row,col,UNPRT,color,hilite,\n                          type,CONTROL,NOINPUT) ;\n                        setfld(fid,SYMSET,APL) ; /* APL symbols */\n                      }\n                    else\n                      {\n                        lstrnew(&data,\"o\") ;  /* un pressed symbol */\n                        fid = insfld(&data,row,col,UNPRT,color,hilite,\n                          type,CONTROL,NOINPUT) ;\n                      }\n                    /* add variable name to field definition */\n                    setfvar(fid,vname) ;  /* save variable name */\n                  }\n\n                else if (type == 'C')     /* checkbox */\n                  {\n                    /* copy and validate variable name */\n                    e = vname ;\n                    f = c+1 ;\n                    i = 0 ;\n                    while (isalnum(*f))\n                      {\n                        if (i==TSOVSIZE)\n                          break ;\n                        *e++ = *f++ ;\n                        i++ ;\n                      }\n                    *e = '\\0' ;\n                    if ((i<=0) || (i>TSOVSIZE))\n                      {\n                        if (mlev>0)\n                          {\n                            sprintf(msg,\n                              \"Invalid var name length for %s\",c) ;\n                            execmsg(\"WIN052E\",msg) ;\n                          }\n                        return 36 ;\n                      }\n\n                    /* subtract 2 from length to account for the */\n                    /* control at the front of the text          */\n                    lstrnewx(&data,c+1,len-2) ;\n                    fid = insfld(&data,row,col+2,UNPRT,color,hilite,\n                      type,TEXT,NOINPUT) ;\n                    /* add variable name to field definition */\n                    setfvar(fid,vname) ;  /* save variable name */\n                    if (sdcb.loadflg)\n                      {\n                        lstrnew(&data,\"\\x56\") ;   /* un cheched sym */\n                        fid = insfld(&data,row,col,UNPRT,color,hilite,\n                          type,CONTROL,NOINPUT) ;\n                        setfld(fid,SYMSET,0x40) ; /*loaded PS symbols*/\n                      }\n                    else if (sdcb.aplflg)\n                      {\n                        lstrnew(&data,\"\\x90\") ; /* un checked sym */\n                        fid = insfld(&data,row,col,UNPRT,color,hilite,\n                          type,CONTROL,NOINPUT) ;\n                        setfld(fid,SYMSET,APL) ; /* APL symbols */\n                      }\n                    else\n                      {\n                        lstrnew(&data,\"_\") ;  /* un checked symbol */\n                        fid = insfld(&data,row,col,UNPRT,color,hilite,\n                          type,CONTROL,NOINPUT) ;\n                      }\n                    /* add variable name to field definition */\n                    setfvar(fid,vname) ;  /* save variable name */\n                  }\n\n                else  /* nasty error */\n                  {\n                    if (mlev>0)\n                      {\n                        sprintf(msg,\n                          \"Logic error in WS, invalid type: %c\",type) ;\n                        execmsg(\"WIN048S\",msg) ;\n                      }\n                    return 24 ;\n                  }\n\n                /* reposition c past this field */\n                c = d ;\n\n              }  /* of if found */\n            else\n              c++ ;\n\n          }  /* of while characters in the row */\n\n      }\n    else /* error - no current window */\n      {\n        if (mlev>0)\n          {\n            sprintf(msg,\n              \"No current window exists, can not define rows\") ;\n            execmsg(\"WIN036E\",msg) ;\n          }\n        return 16 ;\n      }\n    return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* Window Display command processing                                 */\n/*-------------------------------------------------------------------*/\nint wdcmd(char *parm)\n  {\n    char *number_end ;   /* end of number token */\n    char *word ;         /* current token */\n    char curvar\u00ddTSOVSIZE\u00a8 ; /* current field variable name */\n    char curword\u00dd80\u00a8 ;   /* current word under cursor */\n    char temp\u00dd10\u00a8 ;      /* temp area for token */\n    char keyname\u00dd8\u00a8 ;    /* name of key pressed */\n    char name\u00dd9\u00a8 ;       /* name of window to display */\n    char nameflg = 0 ;   /* flag - seen NAME= parm */\n    char input = 1 ;     /* input flag, either Y=yes or N=no */\n    int found ;          /* window found flag */\n    int delay = 0 ;      /* window display delay */\n    int prow = 1 ;       /* start row */\n    int pcol = 1 ;       /* start col */\n    int n = 1 ;          /* token counter */\n    int svrc ;           /* set variable return code */\n    TWINDOW *last, *top ;\n\n    if (windows)\n      {\n        word = strtok(parm,DELIMS) ;\n        while(word != NULL)\n          {\n            if (mlev>3)\n              {\n                sprintf(msg,\"  Parm %d: %s\",n,word) ;\n                execmsg(0,msg) ;\n              }\n            if (strlen(word) >10)\n              {\n                if (mlev>0)\n                  {\n                    sprintf(msg,\"Invalid parameter length for: %s\",\n                      word) ;\n                    execmsg(\"WIN018E\",msg) ;\n                  }\n                return 12 ;\n              }\n            strcpy(temp,word) ;\n            strtoupr(temp) ;\n\n            if (strcmp(temp,\"NAME\") == 0)\n              {\n                word = strtok(NULL,DELIMS) ;  /* get next word */\n                if (*word)\n                  {\n                    nameflg = 1 ;   /* indicate seen required parm */\n                    if (strlen(word) >8)\n                      {\n                        if (mlev>0)\n                          {\n                             sprintf(msg,\n                               \"Length too long (>8) for name: %s\",\n                               word) ;\n                             execmsg(\"WIN028E\",msg) ;\n                           }\n                         return 20 ;\n                      }\n                    strcpy(name,word) ;\n                    strtoupr(name) ;\n                  }\n              }\n\n            else if (strcmp(temp,\"ROW\") == 0)\n              {\n                word = strtok(NULL,DELIMS) ;  /* get next word */\n                prow = strtol(word, &number_end,10) ;\n                if (!number_end)\n                  {\n                    if (mlev>0)\n                      {\n                        sprintf(msg,\"Invalid start row %s\",word) ;\n                        execmsg(\"WIN036E\",msg) ;\n                      }\n                    return 8 ;\n                  }\n                else\n                  {\n                    if ((prow > sdcb.rows) || (prow < 1))\n                      {\n                        if (mlev>0)\n                          {\n                            sprintf(msg,\"Bad start row size %d\",prow) ;\n                            execmsg(\"WIN037E\",msg) ;\n                          }\n                        return 12 ;\n                      }\n                  }\n              }\n\n            else if (strcmp(temp,\"COL\") == 0)\n              {\n                word = strtok(NULL,DELIMS) ;  /* get next word */\n                pcol = strtol(word, &number_end,10) ;\n                if (!number_end)\n                  {\n                    if (mlev>0)\n                      {\n                        sprintf(msg,\"Invalid start column %s\",word) ;\n                        execmsg(\"WIN038E\",msg) ;\n                      }\n                    return 8 ;\n                  }\n                else\n                  {\n                    if ((pcol > sdcb.cols) || (pcol < 1))\n                      {\n                        if (mlev>0)\n                          {\n                            sprintf(msg,\"Bad start col size %d\",pcol) ;\n                            execmsg(\"WIN039E\",msg) ;\n                          }\n                        return 12 ;\n                      }\n                  }\n              }\n\n            else if (strcmp(temp,\"INPUT\") == 0)\n              {\n                word = strtok(NULL,DELIMS) ;  /* get next word */\n                if (toupper(*word)=='Y')\n                  input = 1 ;\n                else if (toupper(*word)=='N')\n                  input = 0 ;\n                else\n                  {\n                    if (mlev>0)\n                      {\n                        sprintf(msg,\"Invalid input flag.\") ;\n                        execmsg(\"WIN042E\",msg) ;\n                      }\n                    return 12 ;\n                  }\n                curwin->inputflg = input ; /* input flag 0=no, 1=yes */\n              }\n\n            else if (strcmp(temp,\"DELAY\") == 0)\n              {\n                word = strtok(NULL,DELIMS) ;  /* get next word */\n                delay = strtol(word, &number_end,10) ;\n                if (!number_end)\n                  {\n                    if (mlev>0)\n                      {\n                        sprintf(msg,\"Invalid delay time %s\",word) ;\n                        execmsg(\"WIN040E\",msg) ;\n                      }\n                    return 8 ;\n                  }\n                else\n                  {\n                    if ((delay > 60) || (delay < 0))\n                      {\n                        if (mlev>0)\n                          {\n                            sprintf(msg,\"Delay %d out of range\",delay);\n                            execmsg(\"WIN041E\",msg) ;\n                          }\n                        return 12 ;\n                      }\n                  }\n                curwin->delay = delay ; /* wait after disp (secs.) */\n              }\n\n            else  /* invalid parm */\n              {\n                if (mlev>0)\n                  {\n                    sprintf(msg,\"Invalid WD parameter %s\",temp) ;\n                    execmsg(\"WIN025E\",msg) ;\n                  }\n                return 8 ;\n              }\n\n            word = strtok(NULL,DELIMS) ;  /* get next word */\n            n++ ;\n          }    /* of while tokens */\n\n        if (nameflg)  /* name= parameter specified */\n          {\n            /* locate window by name on window list */\n            /*   if not found do error lastcc 4 */\n            found = 0 ;\n            last = NULL ;\n            top = windows ;\n            while (top)\n              {\n                if (strcmp(top->name,name) == 0)\n                  {\n                    found = 1 ;\n                    break ;\n                  }\n                last = top ;\n                top = top->next ;\n              }\n            if (!found)\n              {\n                if (mlev>0)\n                  {\n                    sprintf(msg,\"Window %s not found.\",name) ;\n                    execmsg(\"WIN051E\",msg) ;\n                  }\n                return 4 ;\n              }\n\n            /* if window changed, indicate erase write */\n            if (curwin != top)\n              top->eraseflg = 1 ;\n\n            /* set found window as the current window */\n            curwin = top ;\n\n            /* set Twindow data for current window */\n            curwin->srow = prow ;      /* start row of window */\n            curwin->scol = pcol ;      /* start column of window */\n            curwin->inputflg = input ; /* input flag 0=no, 1=yes */\n            curwin->delay = delay ;    /* wait after disp (secs.) */\n\n            /* look at all the TSO variables associated */\n            /*   with fields and copy the variable data */\n            /*   to the field depending on widget type */\n            var2fld() ;\n\n            /* dspflds() to display the window */\n            if (delay > 0)\n              /* if delay is set then sleep(nn) */\n              curwin->lastkey = dspflds(delay) ; /* display */\n            else\n              {\n                curwin->lastkey = dspflds(0) ; /* display */\n\n                /* get the cursor field variable name and the */\n                /* word the cursor is positioned on, also set */\n                /* button, checkbox, or radio buttons if the  */\n                /* cursor is on them.                         */\n                cursorp(curword,curvar) ;\n\n                /* get the modied field data from the fields */\n                /*   into the TSO variables */\n                fld2var() ;\n              }\n\n            /* if no input then return */\n            if (input == 0)\n              return 0 ;\n\n            /* set TSO post display builtin variables */\n            sprintf(msg,\"%d\",curwin->lastrow) ;  /* last cursor row */\n            svrc = shvset(\"WINSYSR\",msg) ;\n            if (svrc!=SHV_SUCCESS)\n              {\n                if (mlev>0)\n                  {\n                    sprintf(msg,\n                      \"Failed to set variable WINSYSR\") ;\n                    execmsg(\"WIN052E\",msg) ;\n                  }\n                return 28 ;\n              }\n\n            sprintf(msg,\"%d\",curwin->lastcol) ;  /* last cursor col */\n            svrc = shvset(\"WINSYSC\",msg) ;\n            if (svrc!=SHV_SUCCESS)\n              {\n                if (mlev>0)\n                  {\n                    sprintf(msg,\n                      \"Failed to set variable WINSYSC\") ;\n                    execmsg(\"WIN053E\",msg) ;\n                  }\n                return 28 ;\n              }\n\n            getkeynm(keyname,curwin->lastkey) ;\n            sprintf(msg,\"%s\",keyname) ;  /* last key pressed */\n            svrc = shvset(\"WINSYSK\",msg) ;\n            if (svrc!=SHV_SUCCESS)\n              {\n                if (mlev>0)\n                  {\n                    sprintf(msg,\n                      \"Failed to set variable WINSYSK\") ;\n                    execmsg(\"WIN054E\",msg) ;\n                  }\n                return 28 ;\n              }\n\n            svrc = shvset(\"WINSYSV\",curvar) ; /* var cursor is on */\n            if (svrc!=SHV_SUCCESS)\n              {\n                if (mlev>0)\n                  {\n                    sprintf(msg,\n                      \"Failed to set variable WINSYSV\") ;\n                    execmsg(\"WIN055E\",msg) ;\n                  }\n                return 28 ;\n              }\n\n            svrc = shvset(\"WINSYST\",curword) ; /* word cursor is on */\n            if (svrc!=SHV_SUCCESS)\n              {\n                if (mlev>0)\n                  {\n                    sprintf(msg,\n                      \"Failed to set variable WINSYST\") ;\n                    execmsg(\"WIN056E\",msg) ;\n                  }\n                return 28 ;\n              }\n\n          }\n        else  /* name= parameter not specified */\n          {\n            if (mlev>0)\n              {\n                sprintf(msg,\n                  \"Invalid WD sub-command, no NAME= parameter\") ;\n                execmsg(\"WIN026E\",msg) ;\n              }\n            return 24 ;\n          }\n\n      }   /* of if windows */\n    else /* no windows exist cant display */\n      {\n        if (mlev>0)\n          {\n            sprintf(msg,\n              \"Not windows exist, WD cant display\") ;\n            execmsg(\"WIN027E\",msg) ;\n          }\n        return 16 ;\n      }\n\n    return 0 ;\n  }\n\n\n\n/*********************************************************************/\n/* 3270 field handling routines                                      */\n/*   rc = initscr()                                                  */\n/*   termscr()                                                       */\n/*   fid = insfld(data,row,col,attr,color,hilite,type,subtype,input) */\n/*   fid = getvfid(vname)                                            */\n/*   rc = remflds()                                                  */\n/*   rc = delfld(fid)                                                */\n/*   rc = erasefld(fid)                                              */\n/*   rc = setfvar(fid,vname)                                         */\n/*   rc = getfld(fid,returndata)                                     */\n/*   rc = modfld(fid,newdata)                                        */\n/*   rc = setfld(fid,attrtype,attrvalue)                             */\n/*   key = dspflds(delay)                                            */\n/*   dumpfld()                                                       */\n/*   var2fld()                                                       */\n/*   fld2var()                                                       */\n/*                                                                   */\n/*********************************************************************/\n\n\n/*-------------------------------------------------------------------*/\n/* Set up the screen environment.                                    */\n/*-------------------------------------------------------------------*/\nint initscr()\n{\n    int rc = 0 ;\n\n    /* load i/o functions */\n    loadm(\"TPUTN\",&xtputn) ;\n    loadm(\"TGETN\",&xtgetn) ;\n    loadm(\"TPGN\",&xtpgn) ;\n\n    /* get memory */\n    buffer = (char *)malloc(BUFFMAX) ;  /* alloc tput/get buffer */\n    if (buffer)\n      {\n        rc = getdev() ;  /* get3270 device information */\n        if (rc==0 && sdcb.loadflg==1)\n          loadps1() ;\n      }\n    else\n      rc = 1 ;   /* could not get buffer */\n\n    return rc ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Terminate screen environment.                                     */\n/*-------------------------------------------------------------------*/\nvoid termscr()\n{\n    TWINDOW *top, *curr ;\n\n    /* free memory */\n    top = windows ;\n    while (top)\n      {\n        curr = top ;\n        top = top->next ;\n        if (curr->fields)\n          {\n            curwin = curr ;\n            remflds() ;       /* remove fields in this window */\n          }\n        free((TWINDOW *)curr) ;  /* remove this window cntl block */\n      }\n\n    free((char *)buffer) ;  /* remove tput/get buffer */\n\n    /* unload i/o functions */\n    unloadm(xtputn) ;\n    unloadm(xtgetn) ;\n    unloadm(xtpgn) ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Display current contents of the 3270 field list.                  */\n/*-------------------------------------------------------------------*/\nchar dspflds(int delay)\n{\n  TSFLD *curr ;         /* pointer to current display field */\n  TSFLD *other ;        /* another pointer to display field list */\n  TSFLD *last ;         /* pointer to last display field */\n  int rc ;              /* return code */\n  int bufpos ;          /* current buffer position */\n  int trow = 0 ;        /* input data, field row */\n  int tcol = 0 ;        /* input data, field column */\n  int fstart ;          /* input data, field start pointer */\n  int fend ;            /* input data, field end pointer */\n  int ilen ;            /* inserted field data length */\n  char sba\u00dd2\u00a8 ;         /* 3270 buffer address */\n  char aid ;            /* id of key pressed */\n\n  /*-------------------------------------------------------------*/\n  /* assemble buffer, it will contain: (EW WCC) followed by all  */\n  /* the display fields. Each field will contain:                */\n  /*   (SFE 0x03 0xC0 fattr HILITE fhilite COLOR fcolor data)    */\n  /*-------------------------------------------------------------*/\nredisply:\n  if (curwin->eraseflg)  /* need to erase screen ? */\n    {\n      if (sdcb.altflg)\n        buffer\u00dd0\u00a8 = EWA ;     /* erase write alternate */\n      else\n        buffer\u00dd0\u00a8 = EW ;      /* erase write */\n    }\n  else\n    buffer\u00dd0\u00a8 = WRT ;         /* write */\n\n  /* determine if the bell should be rung */\n  if (curwin->bellflg)\n    {\n      buffer\u00dd1\u00a8 = WCCRES | WCCKBD | WCCMDT | WCCBEL ;\n      curwin->bellflg = 0 ;  /* turn bell flag off, one ring only */\n    }\n  else\n    buffer\u00dd1\u00a8 = WCCRES | WCCKBD | WCCMDT ;\n\n  bufpos = 2 ;\n  curr = curwin->fields ;     /* first node in field list */\n  while (curr)\n    {\n      if (curr->modflg || curwin->eraseflg)  /* need to write field?*/\n        {\n          curr->modflg = 0 ;        /* turn mod flag off */\n          buffer\u00ddbufpos++\u00a8 = SBA ;  /* set buffer address */\n          rc2sba(curr->fypos,curr->fxpos,sba) ;\n          buffer\u00ddbufpos++\u00a8 = sba\u00dd0\u00a8 ;\n          buffer\u00ddbufpos++\u00a8 = sba\u00dd1\u00a8 ;\n          if (sdcb.edsflg)\n            {\n              buffer\u00ddbufpos++\u00a8 = SFE ;  /* start field extended */\n              buffer\u00ddbufpos++\u00a8 = 0x03 ;\n              buffer\u00ddbufpos++\u00a8 = 0xc0 ;\n              buffer\u00ddbufpos++\u00a8 = curr->fattr ;\n              buffer\u00ddbufpos++\u00a8 = HILITE ;\n              buffer\u00ddbufpos++\u00a8 = curr->fhilite ;\n              buffer\u00ddbufpos++\u00a8 = COLOR ;\n              buffer\u00ddbufpos++\u00a8 = curr->fcolor ;\n\n              /* insert set character attribute before data if APL/PS */\n              /* symbols are required and the field has protection    */\n              /* turned on.                                           */\n              if (((curr->symbol==APL) || (curr->symbol==0x40))\n                && (curr->fattr & 0x40)) /* and protected field */\n                {\n                  buffer\u00ddbufpos++\u00a8 = SA ;           /* set attribute */\n                  buffer\u00ddbufpos++\u00a8 = SYMSET ;       /* symbol */\n                  if (curr->symbol==APL) /* APL ? */\n                    buffer\u00ddbufpos++\u00a8 = sdcb.aplflg ; /* use APL's lcid*/\n                  else\n                    buffer\u00ddbufpos++\u00a8 = curr->symbol ; /*use symbol val*/\n                }\n            }\n          else    /* dont used extended data stream */\n            {\n              buffer\u00ddbufpos++\u00a8 = SF ;  /* start field */\n              buffer\u00ddbufpos++\u00a8 = curr->fattr ;\n            }\n\n          /* insert field data */\n          ilen = lstrunld(&buffer\u00ddbufpos\u00a8,&curr->fdata) ;\n          bufpos = bufpos + ilen ;\n\n          /* revert to standard symbols after APL/PS data symbols  */\n          if (((curr->symbol==APL) || (curr->symbol==0x40)) /*APL/PS*/\n            && (curr->fattr & 0x40)) /* and protected field */\n            {\n              buffer\u00ddbufpos++\u00a8 = SA ;    /* set attribute */\n              buffer\u00ddbufpos++\u00a8 = SYMSET ;/* symbol */\n              buffer\u00ddbufpos++\u00a8 = DFLT ;  /* revert to default symbols */\n            }\n\n        }  /* of need  to write */\n\n      curr = curr->next ;  /* go to next field */\n    }\n  curwin->eraseflg = 0 ;   /* reset erase flag */\n\n  /* insert the cursor in the same location the user left it */\n  buffer\u00ddbufpos++\u00a8 = SBA ;     /* add set buffer address order */\n  /* determine SBA for current row/col */\n  rc2sba(curwin->lastrow,curwin->lastcol,sba) ;\n  buffer\u00ddbufpos++\u00a8 = sba\u00dd0\u00a8 ;  /* add buffer addr part 1 */\n  buffer\u00ddbufpos++\u00a8 = sba\u00dd1\u00a8 ;  /* add buffer addr part 2 */\n  buffer\u00ddbufpos++\u00a8 = ICUR ;    /* add insert cursor order */\n\n  /* dumpchar(buffer,bufpos) ; */\n\n  /* write buffer to the 3270 */\n  rc = tputn(buffer, bufpos) ;\n\n  fill(buffer,0x00,bufpos) ;\n\n  if (delay > 0)      /* if delay specified only display the fields */\n    {                 /* for the delay time and dont read any input */\n      sleep(delay) ;\n      return 0x00 ;\n    }\n\n  /* receive the response from the user */\n  rc = tgetn(buffer, BUFFMAX ) ;\n\n  /*---------------------------------------------------------*/\n  /* Decode input, should be an AID, a cursor pos bufferaddr */\n  /* and a list of fields (SBA addr1 addr2 data)             */\n  /*---------------------------------------------------------*/\n\n  aid = buffer\u00dd0\u00a8 ;      /* get code of key that was pressed */\n  if (aid == PA2)\n    {\n      curwin->eraseflg = 1 ;   /* set erase flag */\n      goto redisply ;\n    }\n  sba\u00dd0\u00a8 = buffer\u00dd1\u00a8 ;\n  sba\u00dd1\u00a8 = buffer\u00dd2\u00a8 ;\n\n  /* convert and store cursor pos and adjust = 0 used for cursor pos */\n  sba2rc(sba,&curwin->lastrow,&curwin->lastcol,0) ;\n\n  curr = curwin->fields ;\n  fstart = 0 ;\n  bufpos = 3 ;\n  while(bufpos<=BUFFMAX)\n    {\n      if (buffer\u00ddbufpos\u00a8==SBA)\n        {\n          /* get new buffer address */\n          bufpos++ ;\n          sba\u00dd0\u00a8 = buffer\u00ddbufpos++\u00a8 ;\n          sba\u00dd1\u00a8 = buffer\u00ddbufpos++\u00a8 ;\n          sba2rc(sba,&trow,&tcol,1) ; /* convert buf.addr to row/col */\n                              /* adjust = 1 used for retn. buf. addr */\n          fstart = bufpos ;\n\n          /* locate field by r/c then write data to field list entry */\n          last = NULL ;\n          while( !((curr->fxpos==tcol) && (curr->fypos==trow)) )\n            {                          /* locate */\n              last = curr ;\n              curr = curr->next ;\n              if (!curr) break ; /* could not locate - real bad */\n            }\n\n          if (curr)    /* found field - copy the data into it */\n            {\n              curr->modflg = 1 ;  /* indicate field was modified */\n\n              /* first locate end of data */\n              fend = fstart ;\n              while ((buffer\u00ddfend\u00a8 != SBA) &&\n                     (buffer\u00ddfend\u00a8 != 0x00))\n                fend++ ;  /* leaves fend pointing at next char. */\n\n              if (curr->inputflg)\n                {\n                  /* copy data from buffer into field list */\n                  ilen = fend - fstart ;\n                  lstrload(&curr->fdata,&buffer\u00ddfstart\u00a8,ilen) ;\n                }\n\n              if (curr->type == 'B')   /* push button */\n                {\n                  curr->fhilite = NONE ;  /* signal push */\n                }\n\n              else if (curr->type == 'C')   /* check box */\n                {\n                  if (curr->subtype == 'C')   /* control part */\n                    {\n                      if (sdcb.loadflg)   /* set new state */\n                        {\n                          if (*curr->fdata.data == 0x55)\n                            *curr->fdata.data = 0x56 ; /* not checked */\n                          else\n                            *curr->fdata.data = 0x55 ; /* checked */\n                        }\n                      else if (sdcb.aplflg)\n                        {\n                          if (*curr->fdata.data == 0xee)\n                            *curr->fdata.data = 0x90 ; /* not checked */\n                          else\n                            *curr->fdata.data = 0xee ; /* checked */\n                        }\n                      else\n                        {\n                          if (*curr->fdata.data == 'X')\n                            *curr->fdata.data = '_' ; /* not checked */\n                          else\n                            *curr->fdata.data = 'X' ; /* checked */\n                        }\n                    }\n                  else                        /* text part */\n                    {\n                      if (last->subtype == 'C')  /* control part */\n                        {\n                          last->modflg = 1 ; /* indicate modified */\n                          if (sdcb.loadflg)   /* set new state */\n                            {\n                              if (*last->fdata.data == 0x55)\n                                *last->fdata.data = 0x56 ; /* notcheck*/\n                              else\n                                *last->fdata.data = 0x55 ; /* checked */\n                            }\n                          else if (sdcb.aplflg)\n                            {\n                              if (*last->fdata.data == 0xee)\n                                *last->fdata.data = 0x90 ; /* notcheck*/\n                              else\n                                *last->fdata.data = 0xee ; /* checked */\n                            }\n                          else\n                            {\n                              if (*last->fdata.data == 'X')\n                                *last->fdata.data = '_' ; /* notcheck*/\n                              else\n                                *last->fdata.data = 'X' ; /* checked */\n                            }\n                        }\n                      else\n                        {\n                          /* BAD ERROR: This should never happen */\n                          sprintf(msg,\n                            \"Cant locate control part of checkbox %s\",\n                            curr->tsovar) ;\n                          execmsg(\"WIN068S\",msg) ;\n                        }\n                    }\n                }\n\n              else if (curr->type == 'R')   /* radio button */\n                {\n                  /* turn off all other radio buttons for this var */\n                  other = curwin->fields ;\n                  while(other)\n                    {\n                      if ((other->type == 'R') &&   /* radio button */\n                          (other->subtype == 'C'))  /* control */\n                        {\n                          if (strcmp(other->tsovar,curr->tsovar) == 0)\n                            {\n                              other->modflg = 1 ; /*indicate modified*/\n                              if (sdcb.loadflg)  /* radio off */\n                                *other->fdata.data = 0x54 ;\n                              else if (sdcb.aplflg)\n                                *other->fdata.data = 0x9d ;\n                              else\n                                *other->fdata.data = 'o' ;\n                            }\n                        }\n                      other = other->next ;\n                    }\n\n                  /* turn this radio button station on */\n                  if (curr->subtype == 'C')   /* control part */\n                    {\n                      if (sdcb.loadflg)       /* indicate radio on */\n                        *curr->fdata.data = 0x53 ;\n                      else if (sdcb.aplflg)\n                        *curr->fdata.data = 0xed ;\n                      else\n                        *curr->fdata.data = '*' ;\n                    }\n                  else                        /* text part */\n                    {\n                      if (last->subtype == 'C')  /* control part */\n                        {\n                          if (sdcb.loadflg)     /* indicate radio on */\n                            *last->fdata.data = 0x53 ;\n                          else if (sdcb.aplflg)\n                            *last->fdata.data = 0xed ;\n                          else\n                            *last->fdata.data = '*' ;\n                        }\n                      else\n                        {\n                          /* BAD ERROR: This should never happen */\n                          sprintf(msg,\n                           \"Cant locate control part of radio button %s\"\n                           ,curr->tsovar) ;\n                          execmsg(\"WIN070S\",msg) ;\n                        }\n                    }\n                }\n\n              /* adjust bufpos to last char of this returned SBA */\n              bufpos = fend -1 ;\n            }\n          else\n            {\n              /* SEVERE ERROR: This should never happen */\n              sprintf(msg,\n                \"Locate field failed: row %d col %d SBA %.2X %.2X\\n\",\n                trow,tcol,sba\u00dd0\u00a8,sba\u00dd1\u00a8) ;\n              execmsg(\"WIN029S\",msg) ;\n              curr = curwin->fields ;  /* further searches from top */\n            }\n        }\n      else\n        bufpos++ ;   /* advance to next char */\n    }\n\n  return aid ;    /* data returned OK */\n}\n\n\n/*-------------------------------------------------------------------*/\n/* Copy the contents of modifiable fields into their TSO variables.  */\n/*-------------------------------------------------------------------*/\nvoid fld2var()\n{\n  TSFLD *curr ;         /* pointer to current field */\n  TSFLD *next ;         /* pointer to next field */\n  int svrc ;            /* tso variable set return code */\n  char temp\u00dd80\u00a8 ;       /* temp buffer */\n  char *pv ;            /* pointer to variable data */\n  char *pn ;            /* pointer to next field fdata.data */\n\n  curr = curwin->fields ;     /* first node in field list */\n  while (curr)\n    {\n      if (curr->type=='I')   /* input field */\n        {\n          if (curr->tsovar)\n            {\n              lstrunld(temp,&curr->fdata) ;\n              svrc = shvset(curr->tsovar,temp) ;\n              if (svrc!=SHV_SUCCESS)\n                {\n                  if (mlev>0)\n                    {\n                      sprintf(msg,\n                        \"Failed to set field input variable %s\"\n                        ,curr->tsovar) ;\n                      execmsg(\"WIN101E\",msg) ;\n                    }\n                }\n            }\n          else\n            {\n              if (mlev>0)\n                {\n                  sprintf(msg,\n                    \"No variable for input field at row %d col %d\",\n                    curr->fypos,curr->fxpos) ;\n                  execmsg(\"WIN102E\",msg) ;\n                }\n            }\n        }\n\n      else if (curr->type=='B')  /* push button */\n        {\n          if (curr->tsovar)\n            {\n              if (curr->fhilite==NONE)\n                svrc = shvset(curr->tsovar,\"X\") ;\n              else\n                svrc = shvset(curr->tsovar,\" \") ;\n              if (svrc!=SHV_SUCCESS)\n                {\n                  if (mlev>0)\n                    {\n                      sprintf(msg,\n                        \"Failed to set button variable %s\"\n                        ,curr->tsovar) ;\n                      execmsg(\"WIN103E\",msg) ;\n                    }\n                }\n            }\n          else\n            {\n              if (mlev>0)\n                {\n                  sprintf(msg,\n                    \"No variable for button at row %d col %d\",\n                    curr->fypos,curr->fxpos) ;\n                  execmsg(\"WIN104E\",msg) ;\n                }\n            }\n        }\n\n      else if (curr->type=='C')  /* check box */\n        {\n          if (curr->subtype == 'C')  /* control part */\n            {\n              if (curr->tsovar)\n                {\n                  if (sdcb.loadflg)\n                    {\n                      if (*curr->fdata.data == 0x55)\n                        svrc = shvset(curr->tsovar,\"X\") ;\n                      else\n                        svrc = shvset(curr->tsovar,\" \") ;\n                    }\n                  else if (sdcb.aplflg)\n                    {\n                      if (*curr->fdata.data == 0xee)\n                        svrc = shvset(curr->tsovar,\"X\") ;\n                      else\n                        svrc = shvset(curr->tsovar,\" \") ;\n                    }\n                  else\n                    {\n                      if (*curr->fdata.data == 'X')\n                        svrc = shvset(curr->tsovar,\"X\") ;\n                      else\n                        svrc = shvset(curr->tsovar,\" \") ;\n                    }\n                  if (svrc!=SHV_SUCCESS)\n                    {\n                      if (mlev>0)\n                        {\n                          sprintf(msg,\n                            \"Failed to set check box variable %s\"\n                            ,curr->tsovar) ;\n                          execmsg(\"WIN105E\",msg) ;\n                        }\n                    }\n                }\n              else\n                {\n                  if (mlev>0)\n                    {\n                      sprintf(msg,\n                        \"No variable for check box at row %d col %d\",\n                        curr->fypos,curr->fxpos) ;\n                      execmsg(\"WIN106E\",msg) ;\n                    }\n                }\n            }\n        }\n\n      else if (curr->type=='R')  /* radio button */\n        {\n          if (curr->subtype == 'C')  /* control part */\n            {\n              if (curr->tsovar)\n                {\n                  svrc = SHV_SUCCESS ;\n                  if (sdcb.loadflg)\n                    {\n                      if (*curr->fdata.data == 0x53) /* currently on */\n                        {\n                          /* extract first word of text for var */\n                          next = curr->next ;\n                          pn = next->fdata.data ;\n                          pv = temp ;\n                          while ((*pn!='\\0') && (*pn!=' '))\n                            *pv++ = *pn++ ;\n                          *pv = '\\0' ;\n                          svrc = shvset(curr->tsovar,temp) ;\n                        }\n                    }\n                  else if (sdcb.aplflg)\n                    {\n                      if (*curr->fdata.data == 0xed) /* currently on */\n                        {\n                          /* extract first word of text for var */\n                          next = curr->next ;\n                          pn = next->fdata.data ;\n                          pv = temp ;\n                          while ((*pn!='\\0') && (*pn!=' '))\n                            *pv++ = *pn++ ;\n                          *pv = '\\0' ;\n                          svrc = shvset(curr->tsovar,temp) ;\n                        }\n                    }\n                  else\n                    {\n                      if (*curr->fdata.data == '*') /* currently on */\n                        {\n                          /* extract first word of text for var */\n                          next = curr->next ;\n                          pn = next->fdata.data ;\n                          pv = temp ;\n                          while ((*pn!='\\0') && (*pn!=' '))\n                            *pv++ = *pn++ ;\n                          *pv = '\\0' ;\n                          svrc = shvset(curr->tsovar,temp) ;\n                        }\n                    }\n                  if (svrc!=SHV_SUCCESS)\n                    {\n                      if (mlev>0)\n                        {\n                          sprintf(msg,\n                            \"Failed to set radio button variable %s\"\n                          ,curr->tsovar) ;\n                          execmsg(\"WIN064E\",msg) ;\n                        }\n                    }\n                }\n              else\n                {\n                  if (mlev>0)\n                    {\n                      sprintf(msg,\n                        \"No variable for radio button at row %d col %d\",\n                        curr->fypos,curr->fxpos) ;\n                      execmsg(\"WIN107E\",msg) ;\n                    }\n                }\n            }\n        }\n      curr = curr->next ;\n    }\n}\n\n\n/*-------------------------------------------------------------------*/\n/* Copy the contents of TSO variables into their fields.             */\n/*-------------------------------------------------------------------*/\nvoid var2fld()\n{\n  TSFLD *curr ;        /* pointer to current field */\n  TSFLD *next ;        /* pointer to next field */\n  char temp\u00dd81\u00a8 ;      /* temp buffer */\n  char word1\u00dd81\u00a8 ;     /* first word of radio button text */\n  int svrc ;           /* tso variable fetch return code */\n  int len ;            /* length of tso variable data */\n  int flen ;           /* length of field */\n  int i ;              /* counter */\n  char *pv ;           /* pointer to variable data */\n  char *pn ;           /* pointer to next field fdata.data */\n\n  curr = curwin->fields ;     /* first node in field list */\n  next = curr->next ;\n  while (curr)\n    {\n      if ((curr->type=='I') ||   /* input field */\n          (curr->type=='O'))     /* output field */\n        {\n          if (curr->tsovar)\n            {\n              svrc = shvfetch(curr->tsovar,temp,sizeof(temp)) ;\n              len = strlen(temp) ;\n              if (svrc==SHV_TRUNC_VAL)\n                {\n                  if (mlev>0)\n                    {\n                      sprintf(msg,\n                        \"I/O field variable %s data truncated.\"\n                        ,curr->tsovar) ;\n                      execmsg(\"WIN066I\",msg) ;\n                    }\n                  len = sizeof(temp) -1 ;\n                }\n              else if (svrc!=SHV_SUCCESS)\n                {\n                  if (mlev>0)\n                    {\n                      sprintf(msg,\n                        \"Failed to get I/O field variable %s\"\n                        ,curr->tsovar) ;\n                      execmsg(\"WIN067E\",msg) ;\n                    }\n                  len = 0 ;\n                }\n\n              if (len > 0)    /* got data to copy */\n                {\n                  /* figure out actual field length */\n                  if (next)\n                    {\n                      if (next->fypos == curr->fypos) /* on same line */\n                        flen = (next->fxpos - curr->fxpos) - 1 ;\n                      else\n                        flen = sdcb.cols - curr->fxpos;/*no field wrap*/\n                    }\n                  else\n                    flen = sdcb.cols - curr->fxpos; /* no field wrap */\n\n                  /* ensure data fits in field */\n                  if (len < flen)\n                    {   /* data less than field length - blank pad */\n                      for (i=len;i<flen;i++)\n                        temp\u00ddi\u00a8 = ' ' ;\n                      temp\u00ddi\u00a8 = '\\0' ;\n                    }\n                  lstrload(&curr->fdata,temp,flen) ;\n                  curr->modflg = 1 ; /*indicate modified*/\n                }\n            }\n          else\n            {\n              if (mlev>0)\n                {\n                  sprintf(msg,\n                    \"No variable for I/O field at row %d col %d\",\n                    curr->fypos,curr->fxpos) ;\n                  execmsg(\"WIN065E\",msg) ;\n                }\n            }\n        }\n\n      else if (curr->type=='B')  /* button */\n        {\n          if (curr->tsovar)\n            {\n              curr->fhilite = REVERSE ;\n              curr->modflg = 1 ; /*indicate modified*/\n            }\n          else\n            {\n              if (mlev>0)\n                {\n                  sprintf(msg,\n                    \"No variable for button at row %d col %d\",\n                    curr->fypos,curr->fxpos) ;\n                  execmsg(\"WIN093E\",msg) ;\n                }\n            }\n        }\n\n      else if (curr->type=='C')  /* check box */\n        {\n          if (curr->tsovar)\n            {\n              if (curr->subtype=='C')  /* control part */\n                {\n                  svrc = shvfetch(curr->tsovar,temp,sizeof(temp)) ;\n                  if (svrc!=SHV_SUCCESS)\n                    {\n                      if (mlev>0)\n                        {\n                          sprintf(msg,\n                            \"Failed to get check box variable %s\"\n                            ,curr->tsovar) ;\n                          execmsg(\"WIN094E\",msg) ;\n                        }\n                    }\n                  else\n                    {\n                      curr->modflg = 1 ; /*indicate modified*/\n                      if (*temp == 'X')\n                        {\n                          if (sdcb.loadflg)\n                            *curr->fdata.data = 0x55 ;\n                          else if (sdcb.aplflg)\n                            *curr->fdata.data = 0xee ;\n                          else\n                            *curr->fdata.data = 'X' ;\n                        }\n                      else\n                        {\n                          if (sdcb.loadflg)\n                            *curr->fdata.data = 0x56 ;\n                          else if (sdcb.aplflg)\n                            *curr->fdata.data = 0x90 ;\n                          else\n                            *curr->fdata.data = '_' ;\n                        }\n                    }\n                }\n            }\n          else\n            {\n              if (mlev>0)\n                {\n                  sprintf(msg,\n                    \"No variable for check box at row %d col %d\",\n                    curr->fypos,curr->fxpos) ;\n                  execmsg(\"WIN095E\",msg) ;\n                }\n            }\n        }\n\n      else if (curr->type=='R')  /* radio button */\n        {\n          if (curr->tsovar)\n            {\n              if (curr->subtype=='C')  /* control part */\n                {\n                  svrc = shvfetch(curr->tsovar,temp,sizeof(temp)) ;\n                  if (svrc!=SHV_SUCCESS)\n                    {\n                      if (mlev>0)\n                        {\n                          sprintf(msg,\n                            \"Failed to get radio button variable %s\"\n                            ,curr->tsovar) ;\n                          execmsg(\"WIN096E\",msg) ;\n                        }\n                    }\n                  else\n                    {\n                      /* extract first word of this stations text */\n                      pn = next->fdata.data ;\n                      pv = word1 ;\n                      while ((*pn!='\\0') && (*pn!=' '))\n                        *pv++ = *pn++ ;\n                      *pv = '\\0' ;\n\n                      curr->modflg = 1 ; /*indicate modified*/\n                      if (strcmp(temp,word1) == 0) /* var = text wrd1*/\n                        {\n                          if (sdcb.loadflg)\n                            *curr->fdata.data = 0x53 ; /* indicate on */\n                          else if (sdcb.aplflg)\n                            *curr->fdata.data = 0xed ;\n                          else\n                            *curr->fdata.data = '*' ;\n                        }\n                      else\n                        {\n                          if (sdcb.loadflg)\n                            *curr->fdata.data = 0x54 ; /* indicate off*/\n                          else if (sdcb.aplflg)\n                            *curr->fdata.data = 0x9d ;\n                          else\n                            *curr->fdata.data = 'o' ;\n                        }\n                    }\n                }\n            }\n          else\n            {\n              if (mlev>0)\n                {\n                  sprintf(msg,\n                    \"No variable for radio button at row %d col %d\",\n                    curr->fypos,curr->fxpos) ;\n                  execmsg(\"WIN097E\",msg) ;\n                }\n            }\n        }\n      curr = curr->next ;\n      next = curr->next ;\n    }   /* of while more fields */\n}\n\n\n/*-------------------------------------------------------------------*/\n/* Get variable and word at the cursor position.                     */\n/*-------------------------------------------------------------------*/\nvoid cursorp(char *word, char *var)\n{\n  TSFLD  *other, *last, *next, *curr ;\n  int offset ;\n  int nx ;\n  int len ;\n  char *f, *g ;\n\n  strcpy(var,\" \") ;  /* initialise returned values */\n  strcpy(word,\" \") ;\n\n  curr = curwin->fields ;     /* first node in field list */\n  last = NULL ;\n  while (curr)  /* scan field list */\n    {\n      next = curr->next ;\n      if (curwin->lastrow == curr->fypos)  /* on correct row */\n        {\n          /* determine end of this field */\n          if (next)\n            {\n              if (next->fypos != curr->fypos)\n                nx = sdcb.cols ;\n              else\n                nx = next->fxpos ;\n            }\n          else\n            nx = sdcb.cols ;\n\n          /* determine if this field is the field the cursor is in */\n          if ((curwin->lastcol >= curr->fxpos) &&\n              (curwin->lastcol < nx))  /* on correct field ? */\n            {\n              /* is cursor field - indicate field was modified */\n              curr->modflg = 1 ;\n\n              /* set TSO variable name if there is one */\n              if (curr->tsovar)\n                strcpy(var,curr->tsovar) ;\n              else\n                strcpy(var,\" \") ;\n\n              /* set the word the cursor is on if one exists */\n              offset = curwin->lastcol - curr->fxpos ;\n              f = curr->fdata.data + offset ;\n              if (isalnum(*f))\n                {\n                  g = curr->fdata.data ;\n                  while (isalnum(*f) && (f>=g)) /* find word start */\n                    f-- ;\n                  f++ ;   /* start of word */\n                  g = f ;\n                  len = 0 ;\n                  while (isalnum(*g++)) /* find word length */\n                    len++ ;\n                  memcpy(word,f,len) ;\n                  g = word + len ;\n                  *g = '\\0' ;\n                }\n              else\n                strcpy(word,\" \") ;\n\n              /* make widget cursor is on be modified */\n              if (curr->type == 'B')   /* push button */\n                {\n                  curr->fhilite = NONE ;  /* signal push */\n                }\n\n              else if (curr->type == 'C')   /* check box */\n                {\n                  if (curr->subtype == 'C')   /* control part */\n                    {\n                      if (sdcb.loadflg)   /* set new state */\n                        {\n                          if (*curr->fdata.data == 0x55)\n                            *curr->fdata.data = 0x56 ; /* not checked */\n                          else\n                            *curr->fdata.data = 0x55 ; /* checked */\n                        }\n                      else if (sdcb.aplflg)\n                        {\n                          if (*curr->fdata.data == 0xee)\n                            *curr->fdata.data = 0x90 ; /* not checked */\n                          else\n                            *curr->fdata.data = 0xee ; /* checked */\n                        }\n                      else\n                        {\n                          if (*curr->fdata.data == 'X')\n                            *curr->fdata.data = '_' ; /* not checked */\n                          else\n                            *curr->fdata.data = 'X' ; /* checked */\n                        }\n                    }\n                  else                        /* text part */\n                    {\n                      if (last->subtype == 'C')  /* control part */\n                        {\n                          if (sdcb.loadflg)   /* set new state */\n                            {\n                              if (*last->fdata.data == 0x55)\n                                *last->fdata.data = 0x56 ; /* notcheck*/\n                              else\n                                *last->fdata.data = 0x55 ; /* checked */\n                            }\n                          else if (sdcb.aplflg)\n                            {\n                              if (*last->fdata.data == 0xee)\n                                *last->fdata.data = 0x90 ; /* notcheck*/\n                              else\n                                *last->fdata.data = 0xee ; /* checked */\n                            }\n                          else\n                            {\n                              if (*last->fdata.data == 'X')\n                                *last->fdata.data = '_' ; /* notcheck*/\n                              else\n                                *last->fdata.data = 'X' ; /* checked */\n                            }\n                        }\n                      else\n                        {\n                          /* BAD ERROR: This should never happen */\n                          sprintf(msg,\n                            \"Cant locate control part of checkbox %s\",\n                            curr->tsovar) ;\n                          execmsg(\"WIN068S\",msg) ;\n                        }\n                    }\n                }\n\n              else if (curr->type == 'R')   /* radio button */\n                {\n                  /* turn off all other radio buttons for this var */\n                  other = curwin->fields ;\n                  while(other)\n                    {\n                      if ((other->type == 'R') &&   /* radio button */\n                          (other->subtype == 'C'))  /* control */\n                        {\n                          if (strcmp(other->tsovar,curr->tsovar) == 0)\n                            {\n                              if (sdcb.loadflg)  /* radio off */\n                                *other->fdata.data = 0x54 ;\n                              else if (sdcb.aplflg)\n                                *other->fdata.data = 0x9d ;\n                              else\n                                *other->fdata.data = 'o' ;\n                            }\n                        }\n                      other = other->next ;\n                    }\n\n                  /* turn this radio button station on */\n                  if (curr->subtype == 'C')   /* control part */\n                    {\n                      if (sdcb.loadflg)       /* indicate radio on */\n                        *curr->fdata.data = 0x53 ;\n                      else if (sdcb.aplflg)\n                        *curr->fdata.data = 0xed ;\n                      else\n                        *curr->fdata.data = '*' ;\n                    }\n                  else                        /* text part */\n                    {\n                      if (last->subtype == 'C')  /* control part */\n                        {\n                          if (sdcb.loadflg)     /* indicate radio on */\n                            *last->fdata.data = 0x53 ;\n                          else if (sdcb.aplflg)\n                            *last->fdata.data = 0xed ;\n                          else\n                            *last->fdata.data = '*' ;\n                        }\n                      else\n                        {\n                          /* BAD ERROR: This should never happen */\n                          sprintf(msg,\n                            \"Cant locate control part of checkbox %s\",\n                            curr->tsovar) ;\n                          execmsg(\"WIN068S\",msg) ;\n                        }\n                    }\n                }\n\n              /* field found - look no further through list */\n              break ;\n\n            }  /* of correct field */\n\n        }  /* of correct row */\n\n      last = curr ;\n      curr = curr->next ;\n    }  /* of scan field list */\n}\n\n\n/*-------------------------------------------------------------------*/\n/* Dump field list.                                                  */\n/*-------------------------------------------------------------------*/\nvoid dumpfld()\n{\n  TSFLD *curr ;\n  int i = 0, size = 0 ;\n  char sba\u00dd2\u00a8 ;\n\n  sprintf(msg,\"Field list follows:\\n\") ;\n  execmsg(\"WIN030I\",msg) ;\n  curr = curwin->fields ;     /* first node in field list */\n  while (curr)\n    {\n      sprintf(msg,\"  Field at row %d col %d\\n\",curr->fypos,curr->fxpos);\n      execmsg(0,msg) ;\n      rc2sba(curr->fypos,curr->fxpos,sba) ;\n      sprintf(msg,\"    BufAddr: %.2X %.2X Attrib: %.2X Hilite: %.2X \"\n        \"Color: %.2X Symbol: %.2X DataLen: %d\\n\",\n        sba\u00dd0\u00a8,sba\u00dd1\u00a8,curr->fattr,curr->fhilite,curr->fcolor\n        ,curr->symbol,curr->fdata.len) ;\n      execmsg(0,msg) ;\n      sprintf(msg,\"    Type: %c Subtype: %c InputFlg: %.2X \",\n        curr->type,curr->subtype,curr->inputflg ) ;\n      execmsg(0,msg) ;\n      if (curr->tsovar)\n        {\n          sprintf(msg,\"    TSO variable: %s \",curr->tsovar ) ;\n          execmsg(0,msg) ;\n        }\n      sprintf(msg,\"    Data: %s\",curr->fdata.data) ;\n      execmsg(0,msg) ;\n      size = size + curr->fdata.len  + 11 ;\n      i++ ;\n      curr = curr->next ;\n    }\n  sprintf(msg,\"Total fields %d, buffer size required %d\\n\",i,size) ;\n  execmsg(0,msg) ;\n}\n\n\n/*-------------------------------------------------------------------*/\n/* Print terminal status.                                            */\n/*-------------------------------------------------------------------*/\nvoid termstat()\n{\n  int i ;     /* counter */\n\n  sprintf(msg,\"Terminal status follows:\\n\") ;\n  execmsg(\"WIN031I\",msg) ;\n  sprintf(msg,\"  Device name.........: %s\\n\",sdcb.modname) ;\n  execmsg(0,msg) ;\n  sprintf(msg,\"  Device model........: %d\\n\",sdcb.model) ;\n  execmsg(0,msg) ;\n  sprintf(msg,\"  Device type.........: %d\\n\",sdcb.type) ;\n  execmsg(0,msg) ;\n  sprintf(msg,\"  Addressing mode.....: %d\\n\",sdcb.adrmode) ;\n  execmsg(0,msg) ;\n  sprintf(msg,\"  Maximum rows........: %d\\n\",sdcb.rows) ;\n  execmsg(0,msg) ;\n  sprintf(msg,\"  Maximum columns.....: %d\\n\",sdcb.cols) ;\n  execmsg(0,msg) ;\n  sprintf(msg,\"  Cell height(ImpPart): %d\\n\",sdcb.celheigh) ;\n  execmsg(0,msg) ;\n  sprintf(msg,\"  Cell width(ImpPart).: %d\\n\",sdcb.celwidth) ;\n  execmsg(0,msg) ;\n  sprintf(msg,\"  Cell height(UseArea): %d\\n\",sdcb.uacelh) ;\n  execmsg(0,msg) ;\n  sprintf(msg,\"  Cell width(UseArea).: %d\\n\",sdcb.uacelw) ;\n  execmsg(0,msg) ;\n  sprintf(msg,\"  Supported colors....: %d\\n\",sdcb.colors) ;\n  execmsg(0,msg) ;\n  sprintf(msg,\"  Actual colors.......: %d\\n\",sdcb.colora) ;\n  execmsg(0,msg) ;\n\n  sprintf(msg,\"  Color list: \\n\") ;\n  execmsg(0,msg) ;\n  for (i=0;i<sdcb.colors;i++)\n    {\n      sprintf(msg,\"     %.2X\\n\",sdcb.colorlst\u00ddi\u00a8) ;\n      execmsg(0,msg) ;\n    }\n\n  sprintf(msg,\"  Number of Highlights: %d\\n\",sdcb.hilites) ;\n  execmsg(0,msg) ;\n\n  sprintf(msg,\"  Highlight list: \\n\") ;\n  execmsg(0,msg) ;\n  for (i=0;i<sdcb.hilites;i++)\n    {\n      sprintf(msg,\"     %.2X\\n\",sdcb.hilitlst\u00ddi\u00a8) ;\n      execmsg(0,msg) ;\n    }\n\n  if (sdcb.unit)\n    sprintf(msg,\"  Unit................: mm\\n\") ;\n  else\n    sprintf(msg,\"  Unit................: inch\\n\") ;\n  execmsg(0,msg) ;\n  sprintf(msg,\"  Alternate device....: %d\\n\",sdcb.altflg) ;\n  execmsg(0,msg) ;\n  sprintf(msg,\"  APL symbol set......: %.2X\\n\",sdcb.aplflg) ;\n  execmsg(0,msg) ;\n  sprintf(msg,\"  Extended data stream: %d\\n\",sdcb.edsflg) ;\n  execmsg(0,msg) ;\n  sprintf(msg,\"  Loadable symbols....: %d\\n\",sdcb.loadflg) ;\n  execmsg(0,msg) ;\n  sprintf(msg,\"  Load PS extended....: %d\\n\",sdcb.psflg) ;\n  execmsg(0,msg) ;\n  sprintf(msg,\"  Triple plane symbols: %d\\n\",sdcb.triflg) ;\n  execmsg(0,msg) ;\n  sprintf(msg,\"  Double byte symbols.: %d\\n\",sdcb.dbcsflg) ;\n  execmsg(0,msg) ;\n  sprintf(msg,\"  Vector graphic......: %d\\n\",sdcb.graflg) ;\n  execmsg(0,msg) ;\n}\n\n\n/*-------------------------------------------------------------------*/\n/* Add a field to the 3270 field list.                               */\n/*-------------------------------------------------------------------*/\nint insfld(TLSTR *flddata,       /* the data */\n            int ypos,            /* display at row */\n            int xpos,            /* display at column */\n            char attr,           /* field attribute PRT, UNPRT ...*/\n            char color,          /* field color RED, BLUE, ...*/\n            char hilite,         /* field hilite BLINK, RVIDEO,...*/\n            char type,           /* type of field, RADIO,CHECKBOX,.. */\n            char subtype,        /* sub type of field, TEXT, CONTROL */\n            char inputflg )      /* input flag, INPUT or NOINPUT */\n{\n  int rc ;\n  TSFLD *newfld, *last, *top ;\n\n  /* get storage for new nodes */\n  newfld = (TSFLD *)malloc(sizeof(TSFLD)) ;\n  if (!newfld) serror(20,\"Not enough memory\") ;\n  memset(newfld,0x00,sizeof(TSFLD)) ;\n\n  /* verify contents of all parameters */\n  if ((flddata->len > 0) &&\n    (flddata->len <= (sdcb.rows * sdcb.cols)))\n    lstrcopy(&newfld->fdata,flddata) ;\n  else\n    return -1 ;\n\n  if ((xpos > 0) &&\n    (xpos < sdcb.cols))\n    newfld->fxpos = xpos ;\n  else\n    return -2 ;\n\n  if ((ypos > 0) &&\n    (ypos <= sdcb.rows))\n    newfld->fypos = ypos ;\n  else\n    return -3 ;\n\n  rc = modattr(&newfld->fattr,attr) ;\n  if (rc) return -4 ;\n\n  rc = modcolor(&newfld->fcolor,color) ;\n  if (rc) return -5 ;\n\n  rc = modhilite(&newfld->fhilite,hilite) ;\n  if (rc) return -6 ;\n\n  newfld->modflg = 1 ;   /* ensure new field is written to device */\n  newfld->type = type ;\n  newfld->subtype = subtype ;\n  newfld->inputflg = inputflg ;\n\n  /* insert the field into the field list in order of buffer offset */\n  top = curwin->fields ;\n  if (!top)   /* first entry in the list (screen->00) */\n    {\n      newfld->next = NULL ;\n      curwin->fields = newfld ;\n    }\n  else\n    {\n      last = NULL ;  /* last node examined */\n      while(top)    /* loop through fields for insert place */\n        {\n          if ((top->fxpos+top->fypos*sdcb.cols) <\n            (newfld->fxpos+newfld->fypos*sdcb.cols)) /* rel.buff.pos */\n            {    /* chain to next node */\n              last = top ;\n              top = top->next ;\n            }\n          else\n            {\n              if (last)  /* insert the new node, in middle of list */\n                {\n                  last->next = newfld ;\n                  newfld->next = top ;\n                }\n              else   /* insert new first node in list */\n                {\n                  newfld->next = top ;\n                  curwin->fields = newfld ;\n                }\n              break ;   /* exit loop */\n            }\n        }\n      if (!newfld->next)  /* stil not inserted? - add to end */\n        last->next = newfld ;\n    }\n\n  /* update field id table and field id in field struct */\n  newfld->fid = curwin->fidnext ;\n  curwin->sfidtab\u00ddcurwin->fidnext\u00a8 = newfld ;\n  rc = curwin->fidnext++ ;\n  return rc ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Remove all fields defined from the 3270 field list.               */\n/*-------------------------------------------------------------------*/\nint remflds()\n{\n  int i ;\n  TSFLD *curr, *top ;\n\n  for (i=0; i<SFIDMAX; i++)  /* empty fid table */\n  curwin->sfidtab\u00ddi\u00a8 = NULL ;\n  curwin->fidnext = 0 ;              /* reset next fid */\n\n  top = curwin->fields ;             /* free field list */\n  while(top)\n    {\n      curr = top ;\n      top = top->next ;\n      if (curr->tsovar)\n        free((char *)curr->tsovar) ;\n      free((char *)curr->fdata.data) ;\n      free((TSFLD *)curr) ;\n    }\n  curwin->fields = NULL ;\n  curwin->eraseflg = 1 ;  /* ensure erase write on next display */\n  return 0 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Delete a field from the 3270 field list.                          */\n/*-------------------------------------------------------------------*/\nint delfld(int id)\n{\n    TSFLD *curr, *top, *last ;\n\n    if ((id < SFIDMAX) && (id >= 0))\n      {\n        curr = curwin->sfidtab\u00ddid\u00a8 ;\n        if (curr)\n          {\n            top = curwin->fields ;\n            last = NULL ;\n            while (top)\n              {\n                if (top == curr)\n                  {\n                    if (!last)   /* ? found node at top */\n                      curwin->fields = top->next ;\n                    else if (!top->next)  /* ? last node */\n                      last->next = NULL ;\n                    else           /* in middle of list */\n                      last->next = top->next ;\n                    /* delete the node */\n                    if (top->tsovar)\n                      free((char *)top->tsovar) ;\n                    free((char *)top->fdata.data) ;\n                    free((TSFLD *)top) ;\n                    curwin->sfidtab\u00ddid\u00a8 = NULL ; /* invalidate id */\n\n                    /* ensure erase write on next display */\n                    curwin->eraseflg = 1 ;\n                    return 0 ;  /* field id removed OK */\n                  }\n                last = top ;  /* remember last node */\n                top = top->next ;   /* chain to next node */\n              }    /* of while top */\n          }\n        else return 1 ;     /* invalid id */\n      }\n    else return 2 ;    /* out of range id */\n    return 3 ;     /* idtab list mismatch */\n}\n\n/*-------------------------------------------------------------------*/\n/* Erase the contents of a field in the 3270 field list.             */\n/*-------------------------------------------------------------------*/\nint erasefld(int id)\n{\n  TSFLD *curr ;\n\n  if ((id < SFIDMAX) && (id >= 0))\n    {\n      curr = curwin->sfidtab\u00ddid\u00a8 ;\n      if (curr)\n        {\n          lstrfill(&curr->fdata,\"\\0\") ; /* fill with zeros */\n          curr->modflg = 1 ; /* ensure field re-written to device */\n        }\n      else\n        return 1 ;     /* invalid id */\n    }\n  else\n    return 2 ;    /* out of range id */\n\n  return 0 ;    /* id erased OK */\n}\n\n/*-------------------------------------------------------------------*/\n/* Set the variable name of a field in the 3270 field list.          */\n/*-------------------------------------------------------------------*/\nint setfvar(int id,\n            char *vname)\n{\n  TSFLD *curr ;\n\n  if ((id < SFIDMAX) && (id >= 0))\n    {\n      curr = curwin->sfidtab\u00ddid\u00a8 ;\n      if (curr)\n        {\n          if (curr->tsovar)\n            strcpy(curr->tsovar,vname) ;\n          else\n            {\n              curr->tsovar = (char *)malloc(TSOVSIZE) ;\n              if (!curr->tsovar) serror(56,\"Not enough memory\") ;\n              strcpy(curr->tsovar,vname) ;\n            }\n        }\n      else\n        return 1 ;     /* invalid id */\n    }\n  else\n    return 2 ;    /* out of range id */\n\n  return 0 ;    /* data returned OK */\n}\n\n/*-------------------------------------------------------------------*/\n/* Return the field id for a given TSO variable name.                */\n/*-------------------------------------------------------------------*/\nint getvfid(char *vname)\n{\n  TSFLD *curr ;       /* current field pointer */\n\n  curr = curwin->fields ;            /* free field list */\n  while(curr)\n    {\n      if (curr->tsovar)\n        {\n          if (strcmp(curr->tsovar,vname) == 0)\n            return curr->fid ;\n        }\n      curr = curr->next ;\n    }\n  return -1 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Get the current contents of a field in the 3270 field list.       */\n/*-------------------------------------------------------------------*/\nint getfld(int id,\n           TLSTR *retdata)\n{\n  TSFLD *curr ;\n\n  if ((id < SFIDMAX) && (id >= 0))\n    {\n      curr = curwin->sfidtab\u00ddid\u00a8 ;\n      if (curr)\n        lstrcopy(retdata,&curr->fdata) ; /* copy data */\n      else\n        return 1 ;     /* invalid id */\n    }\n  else\n    return 2 ;    /* out of range id */\n\n  return 0 ;    /* data returned OK */\n}\n\n/*-------------------------------------------------------------------*/\n/* Modify the contents of a field in the 3270 field list.            */\n/*-------------------------------------------------------------------*/\nint modfld(int id,\n           TLSTR *newdata)\n{\n  TSFLD *curr ;\n\n  if ((id < SFIDMAX) && (id >= 0))\n    {\n      curr = curwin->sfidtab\u00ddid\u00a8 ;\n      if (curr)\n        {\n          if ((newdata->len > 0) &&\n            (newdata->len <= (sdcb.rows * sdcb.cols)))\n            {\n              lstrcopy(&curr->fdata,newdata) ; /* alter field data */\n              curr->modflg = 1 ; /* ensure field re-written to device */\n            }\n          else\n            return 1 ;  /* data too large or 0 */\n        }\n      else\n        return 2 ;     /* invalid id */\n    }\n  else\n    return 3 ;    /* out of range id */\n\n  return 0 ;    /* data returned OK */\n}\n\n/*-------------------------------------------------------------------*/\n/* Change the attributes of a field in the 3270 field list.          */\n/*-------------------------------------------------------------------*/\nint setfld(int id,\n           int type,\n           char value)\n{\n  TSFLD *curr ;\n  int rc = 0 ;\n\n  if ((id < SFIDMAX) && (id >= 0))\n    {\n      curr = curwin->sfidtab\u00ddid\u00a8 ;\n      if (curr)\n        {\n          switch (type)\n            {\n            case ALL:\n              rc = modcolor(&curr->fcolor,DFLT) ;\n              rc = modhilite(&curr->fhilite,DFLT) ;\n              rc = modattr(&curr->fattr,DFLT) ;\n              break ;\n            case HILITE:\n              rc = modhilite(&curr->fhilite,value) ;\n              break ;\n            case COLOR:\n              rc = modcolor(&curr->fcolor,value) ;\n              break ;\n            case ATTR:\n              rc = modattr(&curr->fattr,value) ;\n              break ;\n            case SYMSET:\n              rc = modsym(&curr->symbol,value) ;\n              break ;\n            default:\n              return 1 ;    /* invalid type */\n            }\n          curr->modflg = 1 ; /* ensure field re-written to device */\n        }\n      else\n        return 1 ;     /* invalid id */\n    }\n  else\n    return 2 ;    /* out of range id */\n\n  return rc ;   /* return */\n}\n\n\n\n/*********************************************************************/\n/* 3270 support routines                                             */\n/*   rc2sba(row,col,sba)                                             */\n/*   sba2rc(sba,row,col,adjust)                                      */\n/*   getkeynm(keyname,key)                                           */\n/*   rc = modcolor(out,in)                                           */\n/*   rc = modhilit(out,in)                                           */\n/*   rc = modattr(out,in)                                            */\n/*   rc = tputn(buf,buflen)                                          */\n/*   rc = tgetn(buf,buflen)                                          */\n/*   rc = tpgn(buf,buflen)                                           */\n/*   rc = getdev()                                                   */\n/*   rc = getterm(primrow,primcol,altrow,altcol,attrs)               */\n/*   rc = querydev()                                                 */\n/*   rc = dsummary(buf,buflen)                                       */\n/*   rc = darea(buf,buflen)                                          */\n/*   rc = dcharset(buf,buflen)                                       */\n/*   rc = dcolor(buf,buflen)                                         */\n/*   rc = dhilite(buf,buflen)                                        */\n/*   rc = dmodes(buf,buflen)                                         */\n/*   rc = dimpart(buf,buflen)                                        */\n/*                                                                   */\n/*********************************************************************/\n\n/*-------------------------------------------------------------------*/\n/* The TPUTN routine is loaded below the 16M line                    */\n/* It issues the TPUT macro with the NOEDIT option                   */\n/*-------------------------------------------------------------------*/\nint tputn(char *buf, int buflen)\n  {\n    int rc = 0 ;\n\n    if (iotrace)      /* trace terminal I/O ? */\n      {\n        sprintf(msg,\"Outbound data stream:\\n\") ;\n        execmsg(\"WIN032I\",msg) ;\n        dumpchar(buf,buflen) ;\n      }\n    rc = (*xtputn)(buf,buflen) ;\n    return rc ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* The TGETN routine is loaded below the 16M line                    */\n/* It issues the TGET macro with the FULLSCR option.                 */\n/*-------------------------------------------------------------------*/\nint tgetn(char *buf, int buflen)\n  {\n    int rc = 0 ;\n\n    rc = (*xtgetn)(buf,buflen) ;\n    if (iotrace)      /* trace terminal I/O ? */\n      {\n        sprintf(msg,\"Inbound data stream:\\n\") ;\n        execmsg(\"WIN033I\",msg) ;\n        dumpchar(buf,buflen) ;\n      }\n    return rc ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* The TPGN routine is loaded below the 16M line                     */\n/* It issues the TPG macro with the NOEDIT option.                   */\n/*-------------------------------------------------------------------*/\nint tpgn(char *buf, int buflen)\n  {\n    int rc = 0 ;\n\n    if (iotrace)      /* trace terminal I/O ? */\n      {\n        sprintf(msg,\"Outbound data stream:\\n\") ;\n        execmsg(\"WIN032I\",msg) ;\n        dumpchar(buf,buflen) ;\n      }\n    rc = (*xtpgn)(buf,buflen) ;\n    return rc ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* Convert row/column to 3270 12/16 bit buffer address.              */\n/*-------------------------------------------------------------------*/\nvoid rc2sba(int row,\n            int col,\n            char *sba)\n{\n  int offset, byte1, byte2 ;\n\n  offset = ((row-1)*sdcb.cols)+(col-1) ;\n  if (sdcb.adrmode == 12)  /* addressing mode = 12 */\n    {\n      byte1 = offset >> 6 ;           /* extract high order bits */\n      byte1 = byte1 | 0x000000c0 ;    /* turn on 12 bit ind */\n\n      byte2 = offset & 0x0000003f ;   /* extract low order 6 bits */\n      byte2 = byte2 | 0x000000c0 ;    /* turn on 12 bit ind */\n\n      sba\u00dd0\u00a8 = *((char *)&byte1+3) ;  /* assemble 2 byte sba */\n      sba\u00dd1\u00a8 = *((char *)&byte2+3) ;\n    }\n  else /* adrmode = 16 or 14 */\n    {\n      byte1 = offset >> 8 ;           /* extract high order byte */\n      byte2 = offset & 0x00ff ;       /* extract low order byte */\n      sba\u00dd0\u00a8 = *((char *)&byte1+3) ;  /* assemble 2 byte sba */\n      sba\u00dd1\u00a8 = *((char *)&byte2+3) ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Convert 12/14/16-bit address to an offset and row/column.         */\n/*-------------------------------------------------------------------*/\nvoid sba2rc(char *inaddr,  /* input buffer addr */\n            int *row,      /* returned row */\n            int *col,      /* returned column */\n            int adjust)    /* amount to subtract - usuallu 0 for the */\n                           /*   returned cursor position, but is set */\n                           /*   to one to get correct returned buffer*/\n                           /*   addresses.                           */\n{\n  int taddr,     /* Temporary address holder */\n      offset ;\n  short addr ;\n  memcpy((char *)&addr,inaddr,sizeof(short)) ;\n\n  /* If 12-bit address, then we need to massage it a little */\n  if (addr & 0xc000)    /* 12-bit address ? */\n    {\n       addr &= 0x3f3f ;      /* turn off 2 hi bits in each byte */\n       taddr = addr >> 8 ;   /* taddr is first 6 bits */\n       addr &= 0x00ff ;      /* addr is second 6 bits */\n       taddr = taddr << 6 ;  /* shift taddr left and .. */\n       taddr |= addr ;       /*   merge taddr with addr into taddr */\n       offset = taddr ;      /* taddr is the offset into the buffer */\n    }\n  else\n    offset = addr ;          /* addr is the offset into the buffer */\n\n  offset = offset - adjust ; /* adjust is either 0 or 1 */\n\n  /* turn offset into row and column based on device num of columns */\n  *col = (offset % sdcb.cols) + 1 ;\n  *row = (offset / sdcb.cols) + 1 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Return the name of a 3270 action key given the AID value.         */\n/*-------------------------------------------------------------------*/\nvoid getkeynm(char *keyname,\n              char key)\n{\n  if (key == ENTER)\n    strcpy(keyname,\"ENTER\") ;\n  else if (key == PF1)\n    strcpy(keyname,\"PF1\") ;\n  else if (key == PF2)\n    strcpy(keyname,\"PF2\") ;\n  else if (key == PF3)\n    strcpy(keyname,\"PF3\") ;\n  else if (key == PF4)\n    strcpy(keyname,\"PF4\") ;\n  else if (key == PF5)\n    strcpy(keyname,\"PF5\") ;\n  else if (key == PF6)\n    strcpy(keyname,\"PF6\") ;\n  else if (key == PF7)\n    strcpy(keyname,\"PF7\") ;\n  else if (key == PF8)\n    strcpy(keyname,\"PF8\") ;\n  else if (key == PF9)\n    strcpy(keyname,\"PF9\") ;\n  else if (key == PF10)\n    strcpy(keyname,\"PF10\") ;\n  else if (key == PF11)\n    strcpy(keyname,\"PF11\") ;\n  else if (key == PF12)\n    strcpy(keyname,\"PF12\") ;\n  else if (key == PF13)\n    strcpy(keyname,\"PF13\") ;\n  else if (key == PF14)\n    strcpy(keyname,\"PF14\") ;\n  else if (key == PF15)\n    strcpy(keyname,\"PF15\") ;\n  else if (key == PF16)\n    strcpy(keyname,\"PF16\") ;\n  else if (key == PF17)\n    strcpy(keyname,\"PF17\") ;\n  else if (key == PF18)\n    strcpy(keyname,\"PF18\") ;\n  else if (key == PF19)\n    strcpy(keyname,\"PF19\") ;\n  else if (key == PF20)\n    strcpy(keyname,\"PF20\") ;\n  else if (key == PF21)\n    strcpy(keyname,\"PF21\") ;\n  else if (key == PF22)\n    strcpy(keyname,\"PF22\") ;\n  else if (key == PF23)\n    strcpy(keyname,\"PF23\") ;\n  else if (key == PF24)\n    strcpy(keyname,\"PF24\") ;\n  else if (key == PA1)\n    strcpy(keyname,\"PA1\") ;\n  else if (key == PA2)\n    strcpy(keyname,\"PA2\") ;\n  else if (key == PA3)\n    strcpy(keyname,\"PA3\") ;\n  else if (key == CLEAR)\n    strcpy(keyname,\"CLEAR\") ;\n  else if (key == SYSREQ)\n    strcpy(keyname,\") SYSREQ\") ;\n  else if (key == OID)\n    strcpy(keyname,\"OID\") ;\n  else if (key == MAG)\n    strcpy(keyname,\"MAG\") ;\n  else if (key == PEN)\n    strcpy(keyname,\"PEN\") ;\n  else\n    strcpy(keyname,\"UNKNOWN\") ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Check color attribute and copy if valid.                          */\n/*-------------------------------------------------------------------*/\nint modsym(char *out,\n           char in )\n{\n  switch (in)\n    {\n    case DFLT:\n      *out = in ;\n      return 0 ;\n    case APL:\n      if (sdcb.aplflg)\n        {\n          *out = in ;\n          return 0 ;\n        }\n      else\n        return 1 ;\n    default:\n      if (sdcb.loadflg)\n        {\n          if ((in>=0x40) && (in<=0xef))\n            {\n              *out = in ;\n              return 0 ;\n            }\n          else\n            return 1 ;\n        }\n      else\n        return 1 ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Check color attribute and copy if valid.                          */\n/*-------------------------------------------------------------------*/\nint modcolor(char *out,\n             char in )\n{\n  switch (in)\n    {\n    case DFLT:\n    case BLUE:\n    case RED:\n    case PINK:\n    case GREEN:\n    case TURQ:\n    case YELLOW:\n    case WHITE:\n      *out = in ;\n      return 0 ;\n    default:\n      return 1 ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Check hilite attribute and copy if valid.                         */\n/*-------------------------------------------------------------------*/\nint modhilit(char *out,\n             char in )\n{\n  switch (in)\n    {\n    case NONE:\n    case BLINK:\n    case RVIDEO:\n    case USCORE:\n      *out = in ;\n      return 0 ;\n    default:\n      return 1 ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Check field attribute and copy if valid.                          */\n/*-------------------------------------------------------------------*/\nint modattr(char *out,\n            char in )\n{\n  switch (in)\n    {\n    case PRT:       /* protected normal intensity */\n    case PRTHI:     /* protected high intensity */\n    case PRTAS:     /* protected normal intensity auto skip */\n    case PRTHIAS:   /* protected high intensity auto skip */\n    case UNPRT:     /* unprotected normal intensity */\n    case UNNUM:     /* unprotected numeric normal intensity */\n    case UNNUMHI:   /* unprotected numeric high intensity */\n    case UNNON:     /* unprotected non display */\n    case UNHI:      /* unprotected high intensity */\n      *out = in ;\n      return 0 ;\n    default:\n      return 1 ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Load programmed symbols - type 1 load                             */\n/*   loads programmed symbols without compression                    */\n/*-------------------------------------------------------------------*/\nint loadps1()\n  {\n    int rc ;         /* return code */\n    int hi ;         /* cell height */\n    int bufpos ;     /* next buffer position */\n    int i, j ;       /* counters */\n    short s ;        /* temp */\n\n    if (sdcb.celheigh == 0)\n      hi = sdcb.uacelh ;     /* use usable area height */\n    else\n      hi = sdcb.celheigh ;   /* default to Implicit partition height */\n\n    memset(buffer,0x00,BUFFMAX) ;  /* clear buffer */\n\n    bufpos = 0 ;\n    buffer\u00ddbufpos++\u00a8 = WSF ;   /* write structured field */\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;  /* structured field length */\n    buffer\u00ddbufpos++\u00a8 = 0x07 ;  /* structured field length contd. */\n    buffer\u00ddbufpos++\u00a8 = 0x06 ;  /* load PS structured field */\n    buffer\u00ddbufpos++\u00a8 = 0x41 ;  /* flags: clear sym.set and use type 1 */\n    buffer\u00ddbufpos++\u00a8 = 0xff ;  /* make associated RWS = not assigned */\n    buffer\u00ddbufpos++\u00a8 = 0x41 ;  /* starting code point */\n    buffer\u00ddbufpos++\u00a8 = 0x02 ;  /* RWS of PSA symbol set */\n\n    /* write buffer to the 3270 */\n    rc = tputn(buffer, bufpos) ;\n\n    memset(buffer,0x00, bufpos) ;  /* clear buffer */\n\n    bufpos = 0 ;\n    buffer\u00ddbufpos++\u00a8 = WSF ;   /* write structured field */\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;  /* structured field length */\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;  /* structured field length contd. */\n    buffer\u00ddbufpos++\u00a8 = 0x06 ;  /* load PS structured field */\n    buffer\u00ddbufpos++\u00a8 = 0x01 ;  /* flags: use type 1 */\n    buffer\u00ddbufpos++\u00a8 = 0x40 ;  /* make associated RWS = 0x40 */\n    buffer\u00ddbufpos++\u00a8 = 0x41 ;  /* starting code point (symbol=65) */\n    buffer\u00ddbufpos++\u00a8 = 0x02 ;  /* RWS of PSA symbol set */\n\n /* This extra stuff needs the flags bit 1 on to indicate extended\n    I dont think I need to use it yet.\n\n    buffer\u00ddbufpos++\u00a8 = 0x08 ;     P length - length of extra parms\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     flags: operator selectable ...\n    buffer\u00ddbufpos++\u00a8 = 0x09 ;     LW - width of character\n    buffer\u00ddbufpos++\u00a8 = 0x10 ;     LH - width of character\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     SUBSN - only one byte codes\n    buffer\u00ddbufpos++\u00a8 = 0xf1 ;     COLOR - F1 - first attr ???\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     ST.SUBSN - default\n    buffer\u00ddbufpos++\u00a8 = 0xf9 ;     ECHAR - last symbol=249\n\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     NW - number width pairs\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     NH - number height pairs\n    buffer\u00ddbufpos++\u00a8 = 0x00 ;     RES - reserved\n */\n\n    /* load specific font based on the cell height */\n    if (hi >= 16)\n      {\n        for (i=65;i<=249;i++)   /* for each symbol, 0x41 to 0xF9 */\n          {\n            for (j=0;j<=17;j++)      /* for each slice  */\n              {\n                buffer\u00ddbufpos++\u00a8 = ps9x16u\u00ddi\u00a8\u00ddj\u00a8 ;\n              }\n          }\n      }\n    else if (hi == 15)\n      {\n        for (i=65;i<=249;i++)   /* for each symbol, 0x41 to 0xF9 */\n          {\n            for (j=0;j<=17;j++)      /* for each slice  */\n              {\n                buffer\u00ddbufpos++\u00a8 = ps9x15u\u00ddi\u00a8\u00ddj\u00a8 ;\n              }\n          }\n      }\n    else\n      {\n        for (i=65;i<=249;i++)   /* for each symbol, 0x41 to 0xF9 */\n          {\n            for (j=0;j<=17;j++)      /* for each slice  */\n              {\n                buffer\u00ddbufpos++\u00a8 = ps9x12u\u00ddi\u00a8\u00ddj\u00a8 ;\n              }\n          }\n      }\n\n    s = bufpos - 1 ;\n    memcpy(buffer+1,&s,sizeof(short)) ;\n\n    /* write buffer to the 3270 to load the programmed symbols */\n    rc = tputn(buffer, bufpos) ;\n\n    memset(buffer,0x00,BUFFMAX) ;  /* clear buffer */\n    return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* Get the display device attributes.                                */\n/*-------------------------------------------------------------------*/\nint getdev()\n  {\n    int rc, pr = 0, pc = 0, ar = 0, ac = 0, att = 0 ;\n    int i ;\n\n    /* set the default values, may get over ridden later */\n    sdcb.adrmode = 12 ;  /* addressing mode */\n    sdcb.altflg = 0 ;    /* use primary device */\n    sdcb.edsflg = 0 ;    /* no extended data stream */\n    sdcb.graflg = 0 ;    /* not a graphics device */\n    sdcb.aplflg = 0 ;    /* no apl symbols on device */\n    sdcb.psflg = 0 ;     /* no program symbols on device */\n    sdcb.loadflg = 0 ;   /* no loadable symbols sets on device */\n    sdcb.triflg = 0 ;    /* no triple plane symbols sets on device */\n    sdcb.dbcsflg = 0 ;   /* no double byte symbols on device */\n    sdcb.celheigh = 0 ;  /* zero cell height on device */\n    sdcb.celwidth = 0 ;  /* zero cell width on device */\n    sdcb.uacelh = 0 ;    /* zero usable area cell height on device */\n    sdcb.uacelw = 0 ;    /* zero usable area cell width on device */\n    sdcb.unit = 0 ;      /* units are inches */\n    sdcb.colora = 1 ;    /* actual colors default to monochrome */\n    sdcb.colors = 1 ;    /* supported colors default to monochrome */\n    sdcb.hilites = 0 ;   /* supported hilites default to none */\n    for (i=0;i<17;i++)\n      sdcb.colorlst\u00ddi\u00a8 = 0x00 ; /* list of color attributes on device*/\n    for (i=0;i<5;i++)\n      sdcb.hilitlst\u00ddi\u00a8 = 0x00 ; /* list of hilite attributes on device*/\n\n\n    /* get info from TSO about this device */\n    rc = getterm(&pr,&pc,&ar,&ac,&att) ;\n    if (rc==0)                 /* get terminal info worked ? */\n      {\n        if (att==0x00000001)   /* device has query structured fields */\n          {\n            /* set row and col may be later reset by query dev */\n            if ((ar>0) && (ar!=pr) &&\n                (ac>0) && (ac!=pc))\n              {\n                sdcb.altflg = 1 ;    /* use alternate device */\n                sdcb.rows = ar ;     /* use alternate rows */\n                sdcb.cols = ac ;     /* use alternate cols */\n              }\n            else\n              {\n                sdcb.rows = pr ;     /* use primary rows */\n                sdcb.cols = pc ;     /* use primary cols */\n              }\n\n            rc = querydev() ;\n            /* try to determine actual device */\n            if (sdcb.rows == 32)\n              {\n                strcpy(sdcb.modname,\"IBM3279-3\") ;\n                sdcb.model = 3279 ;\n                sdcb.type = 3 ;\n              }\n            else if (sdcb.rows == 43)\n              {\n                strcpy(sdcb.modname,\"IBM3278-4\") ;\n                sdcb.model = 3278 ;\n                sdcb.type = 4 ;\n              }\n            else if (sdcb.rows == 27)\n              {\n                strcpy(sdcb.modname,\"IBM3290\") ;\n                sdcb.model = 3290 ;\n                sdcb.type = 5 ;\n              }\n            else  /* cant tell - use most primitive */\n              {\n                strcpy(sdcb.modname,\"IBM3278-2\") ;\n                sdcb.model = 3278 ;\n                sdcb.type = 2 ;\n              }\n          }\n        else  /* dont know a lot about the device - make some guesses */\n          {\n            if ((ar>0) && (ar!=pr) &&\n                (ac>0) && (ac!=pc))\n              {\n                sdcb.altflg = 1 ;    /* use alternate device */\n                sdcb.rows = ar ;     /* use alternate rows */\n                sdcb.cols = ac ;     /* use alternate cols */\n              }\n            else\n              {\n                sdcb.rows = pr ;     /* use primary rows */\n                sdcb.cols = pc ;     /* use primary cols */\n              }\n\n            /* try to determine actual device */\n            if (sdcb.rows == 32)\n              {\n                strcpy(sdcb.modname,\"IBM3279-3\") ;\n                sdcb.model = 3279 ;\n                sdcb.type = 3 ;\n              }\n            else if (sdcb.rows == 43)\n              {\n                strcpy(sdcb.modname,\"IBM3278-4\") ;\n                sdcb.model = 3278 ;\n                sdcb.type = 4 ;\n              }\n            else if (sdcb.rows == 27)\n              {\n                strcpy(sdcb.modname,\"IBM3290\") ;\n                sdcb.model = 3290 ;\n                sdcb.type = 5 ;\n              }\n            else  /* cant tell - use most primitive */\n              {\n                strcpy(sdcb.modname,\"IBM3278-2\") ;\n                sdcb.model = 3278 ;\n                sdcb.type = 2 ;\n              }\n          }\n        return 0 ;\n      }\n    else  /* get term failed - return its code */\n      return rc ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* This routine loads an assebbler module below the 16 MB line       */\n/* that issues the GTTERM macro instruction to obtain the            */\n/* dimensions of the screen and also some bit fields that            */\n/* tell if the device can be queried. The module copies the          */\n/* results from storage below the line to this routines              */\n/* automatic storage.                                                */\n/* Upon completion the module is unloaded.                           */\n/*-------------------------------------------------------------------*/\nint getterm(int *primrow, int *primcol,\n             int *altrow, int *altcol,\n             int *attrs)\n  {\n    struct {\n      union {\n        short sh ;\n        char c\u00dd2\u00a8 ;\n      } prim ;\n      union {\n        short sh ;\n        char c\u00dd2\u00a8 ;\n      } alt ;\n      int attr ;\n    } pm ;\n    int rc = 0 ;\n    int (*tgt327d)(void *) ;\n\n    loadm(\"TGT327D\",&tgt327d) ;   /* load ASM routine below 16M */\n    rc = (*tgt327d)(&pm) ;        /* execute GTTERM macro */\n    if (rc==0)      /* data returned OK ? */\n      {             /* yes - convert single byte numbers to int */\n        *primrow = pm.prim.c\u00dd0\u00a8 ;\n        *primcol = pm.prim.c\u00dd1\u00a8 ;\n        *altrow = pm.alt.c\u00dd0\u00a8 ;\n        *altcol = pm.alt.c\u00dd1\u00a8 ;\n        *attrs = pm.attr ;\n      }\n    unloadm(tgt327d) ;            /* unload ASM routine */\n    return rc ;                   /* return code from GTTERM */\n  }\n\n/*-------------------------------------------------------------------*/\n/* Clear 3270 screen.                                                */\n/*-------------------------------------------------------------------*/\nvoid clear()\n  {\n    int rc ;\n    char sba\u00dd2\u00a8 ;\n    char out1\u00dd\u00a8 = {      /* set up for erase */\n      WRT, 0x40,\n      SBA, 0x5d, 0x7f,   /* end addr - overlayed later */\n      SBA, 0x40, 0x40,   /* start addr row=1 col=1 */\n      SBA, 0xe7, 0x7f,   /* insert cursor location, row/col max */\n      ICUR               /* insert cursor */\n      } ;\n    char out2\u00dd\u00a8 = {      /* erase write alternate */\n      EWA, 0xc2\n      } ;\n    char out3\u00dd\u00a8 = {      /* erase primary */\n      WRT, 0xc2\n      } ;\n\n    /* set max screen size known so far sba */\n    rc2sba(sdcb.rows,sdcb.cols,sba) ;\n    out1\u00dd9\u00a8 = sba\u00dd0\u00a8 ;\n    out1\u00dd10\u00a8 = sba\u00dd1\u00a8 ;\n\n    rc = tputn(out1,sizeof(out1) ) ;   /* define the buffer */\n    rc = tputn(out2,sizeof(out2) ) ;   /* erase write alternate */\n    rc = tputn(out3,sizeof(out3) ) ;   /* erase write primary */\n  }\n\n/*-------------------------------------------------------------------*/\n/* Select the entire screen buffer using SBA based on the            */\n/* scrsize returned from GTTERM and EW/EWA to select the             */\n/* primary or alternate buffer.                                      */\n/* Then assemble a structured field query, and send it to the        */\n/* device using TPG which will cause the device to imediately        */\n/* send back the response without any user intervention.             */\n/* Then decode the read partition, query operations, query and       */\n/* put the interesting data in the sdcb structure.                   */\n/*-------------------------------------------------------------------*/\nint querydev()\n  {\n    short sflen ;      /* structured field length */\n    char  sfid ;       /* structured field ID */\n    char  qcode ;      /* query reply - query code */\n    char input\u00dd256\u00a8 ;  /* query buffer */\n    char *ibuf ;       /* current query buffer pointer */\n    int rc ;\n    char sba\u00dd2\u00a8 ;\n\n    char out1\u00dd\u00a8 = {      /* set up for erase */\n      WRT, 0x40,\n      SBA, 0x5d, 0x7f,   /* end addr - overlayed later, rc= 24,80 */\n      SBA, 0x40, 0x40,   /* start addr row=1 col=1 */\n      SBA, 0xe7, 0x7f,   /* insert cursor loc, rc= 32,80 *OVERLAYED**/\n      ICUR               /* insert cursor */\n      } ;\n\n    char out2\u00dd\u00a8 = {      /* erase write alternate */\n      EWA, 0xc2\n      } ;\n\n    char out3\u00dd\u00a8 = {      /* erase primary */\n      WRT, 0xc2\n      } ;\n\n    char out4\u00dd\u00a8 = {\n      WSF,               /* write structured field */\n      0x00, 0x05,        /* structured field length */\n      0x01,              /* read partition */\n      0xFF,              /* query operations */\n      0x02               /* query */\n      } ;\n\n    /* set max screen size known so far sba */\n    rc2sba(sdcb.rows,sdcb.cols,sba) ;\n    out1\u00dd9\u00a8 = sba\u00dd0\u00a8 ;\n    out1\u00dd10\u00a8 = sba\u00dd1\u00a8 ;\n\n    fill(input,0x00,sizeof(input)) ;   /* zero input buffer */\n\n    rc = tputn(out1,sizeof(out1) ) ;   /* define the buffer */\n    rc = tputn(out2,sizeof(out2) ) ;   /* erase write alternate */\n    rc = tputn(out3,sizeof(out3) ) ;   /* erase write primary */\n    rc = tpgn(out4,sizeof(out4) ) ;    /* query the device */\n    rc = tgetn(input,sizeof(input)) ;  /* receive device resp.*/\n\n    ibuf = input ;       /* point at input */\n\n    if (*input==0x88)    /* check for 88 AID byte */\n      {\n        ibuf = ibuf+1 ;         /* advance to 1st structured field */\n        sfid = *(ibuf+2) ;      /* sfid should be 0x81 */\n\n        while (sfid==0x81)  /* while structured fields remain */\n          {\n            sflen = *((short *)ibuf) ;  /* get structured field len */\n            if (sflen==0)           /* bad error - should not happen */\n              {\n                sprintf(msg,\"Error structured field len. zero at %p\\n\",\n                  ibuf) ;\n                execmsg(\"WIN034S\",msg) ;\n                dumpchar(input,sizeof(input)) ;\n                return 1 ;\n              }\n            qcode = *(ibuf+3) ;     /* get query code */\n            switch (qcode)\n              {\n                case 0x80:           /* Q-code summary */\n                  rc = dsummary(ibuf,sflen) ;\n                  break ;\n                case 0x81:           /* Usable area */\n                  rc = darea(ibuf,sflen) ;\n                  break ;\n                case 0x85:           /* Character sets */\n                  rc = dcharset(ibuf,sflen) ;\n                  break ;\n                case 0x86:           /* Color */\n                  rc = dcolor(ibuf,sflen) ;\n                  break ;\n                case 0x87:           /* Highlighting */\n                  rc = dhilite(ibuf,sflen) ;\n                  break ;\n                case 0x88:           /* Modes */\n                  rc = dmodes(ibuf,sflen) ;\n                  break ;\n                case 0xa6:           /* Implicit partition */\n                  rc = dimpart(ibuf,sflen) ;\n                  break ;\n                default:\n                  break ;\n              }  /* of switch */\n            ibuf = ibuf+sflen ; /* advance to next structured field */\n            sfid = *(ibuf+2) ;  /* sfid should be 0x81 - else stop */\n\n          } /* of while sfid=81 */\n\n      } /* of AID=88 */\n    return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x80: Qcode summary                                               */\n/*-------------------------------------------------------------------*/\nint dsummary(char *buf, short buflen)\n  {\n     int i ;\n     char qcode ;\n\n     for (i=4;i<buflen;i++)\n       {\n          qcode = *(buf+i) ;     /* get query code */\n          if (qcode == 0xb4)\n            sdcb.graflg = 1 ;    /* indicate graphic support */\n       }  /* of for i=4 */\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x81: Usable area                                                 */\n/*-------------------------------------------------------------------*/\nint darea(char *buf, short buflen)\n  {\n     char celunits\u00dd6\u00a8 ;   /* screen size unit PEL or CELL */\n     short w, h ;         /* screen size w=width h=height */\n     char aw, ah ;        /* units per cell aw=width ah=height */\n     float xr, xrd, yr, yrd ;  /* pel spacing ratio */\n     float fw, fh ;       /* ratio - pels per unit */\n\n     if ((*(buf+4) & 0x03)==0x03)\n       sdcb.adrmode = 16 ;\n     else if ((*(buf+4) & 0x01)==0x01)\n       sdcb.adrmode = 12 ;\n\n     w = *((short *)(buf+6)) ;   /* width of usable area */\n     h = *((short *)(buf+8)) ;   /* height of usable area */\n\n     if (*(buf+10) == 0x01)    /* pels/in or pels/mm */\n       sdcb.unit = 1 ;  /* units are mm */\n     else\n       sdcb.unit = 0 ;  /* units are inch */\n\n     xr = *((short *)(buf+11)) ;    /* x dim pel ratio numerator */\n     xrd = *((short *)(buf+13)) ;   /* x dim pel ratio denominator */\n     yr = *((short *)(buf+15)) ;    /* y dim pel ratio numerator */\n     yrd = *((short *)(buf+17)) ;   /* y dim pel ratio denominator */\n\n     fw = (float)(xr) / (float)(xrd) ; /* horiz. ratio pels per unit */\n     fh = (float)(yr) / (float)(yrd) ; /* vert. ratio pels per unit */\n\n     aw = *(buf+19) ;    /* number of X units in default cell */\n     ah = *(buf+20) ;    /* number of Y units in default cell */\n     sdcb.uacelh = ah ;  /* use alt. cell height */\n     sdcb.uacelw = aw ;  /* use alt. cell width */\n\n     if (*(buf+5) & 0x20)       /* byte 5 bit 3 on unit=pels */\n       strcpy(celunits,\"pels\") ;\n     else                       /* other wise unit=cells */\n       strcpy(celunits,\"cells\") ;\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x85: Character sets                                              */\n/*-------------------------------------------------------------------*/\nint dcharset(char *buf, short buflen)\n  {\n     int i, j ;         /* counters */\n     int cgcsgid ;      /* Coded graphic character set identifier */\n     short ccsid ;      /* Coded character set identifier */\n     char gf = 0 ;      /* CGCSGID not present flag */\n     char ch2 = 0 ;     /* Two byte char. set flag */\n     char ms = 0 ;      /* Multiple slot sizes flag */\n     char cf = 0 ;      /* CCSID not present flag */\n     char sdw ;         /* Default character slot width */\n     char sdh ;         /* Default character slot height */\n     char dl ;          /* character set descriptor (CSD) length */\n     char *csd ;        /* character set descriptor (CSD) ptr */\n     char set ;         /* character set ID (PS store no.) */\n     char lcid ;        /* character set Local ID (alias) */\n     char sw ;          /* character set slot width */\n     char sh ;          /* character set slot height */\n     char ssubsn ;      /* character set starting subsection */\n     char esubsn ;      /* character set ending subsection */\n\n     if (*(buf+4) & 0x10)\n       sdcb.psflg = 1 ;   /* load PS Extended supported */\n     else\n       sdcb.psflg = 0 ;   /* load PS Extended not supported */\n\n     if (*(buf+4) & 0x08)\n       ms = 1 ;   /* More than one size character slot supported */\n\n     if (*(buf+4) & 0x04)\n       ch2 = 1 ;  /* Two byte code character sets are supported */\n\n     if (*(buf+4) & 0x02)\n       gf = 1 ;   /* CGCSGID present */\n\n     if (*(buf+5) & 0x20)\n       cf = 1 ;   /* CCSID present */\n\n     sdw = *(buf+6) ;\n     sdh = *(buf+7) ;\n\n     dl = *(buf+12) ;   /* get CSD length */\n     i = 13 ;\n     while (i<buflen)\n       {\n         csd = buf + i ;  /* point at CSD to process */\n         set = *csd ;     /* get character set ID (PS store no.) */\n         if (*(csd+1) & 0x80)\n           sdcb.loadflg = 1 ;  /* loadable symbol sets exist */\n\n         if (*(csd+1) & 0x40)\n           sdcb.triflg = 1 ;   /* Triple-plane character sets exist */\n\n         if (*(csd+1) & 0x20)\n           sdcb.dbcsflg = 1 ;  /* Double-byte coded character sets */\n\n         lcid = *(csd+2) ;   /* get character set ID (PS store no.) */\n\n         j = 0 ;\n         if (ms)\n           {\n             sw = *(csd+3) ;  /* slot width */\n             sh = *(csd+4) ;  /* slot height */\n             j = j + 2 ;\n           }\n\n         if (ch2)\n           {\n             ssubsn = *(csd+j+3) ;  /* starting sub-section */\n             esubsn = *(csd+j+4) ; /* ending sub-section */\n             j = j + 2 ;\n           }\n\n         if (gf)\n           {\n             cgcsgid = *((int *)(csd+j+3)) ;  /* Graf char set ID */\n             if (cgcsgid==0x03c30136)\n               sdcb.aplflg = lcid ;   /* APL supported store lcid */\n             j = j + 4 ;\n           }\n\n         if (cf)\n           {\n             ccsid = *((short *)(csd+j+3)) ;  /* char set ID */\n           }\n\n         i = i + dl ;  /* get pos of next CSD */\n       }  /* of while i<buflen */\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x86: Colors                                                      */\n/*-------------------------------------------------------------------*/\nint dcolor(char *buf, short buflen)\n  {\n     int colora = 0 ; /* number of actual colors on device */\n     int icolor ;     /* color index */\n     int i, j = 0 ;   /* counter */\n     char attr ;      /* color attribute accepted by device */\n     char dcolor ;    /* color displayed for this attribute */\n\n     sdcb.colors = (int)*(buf+5) ; /* number of colors accepted */\n     for (i=6;i<buflen;i=i+2)\n       {\n         attr = *(buf+i) ;        /* attribute used by appl. */\n         sdcb.colorlst\u00ddj++\u00a8 = attr ;\n         dcolor = *(buf+i+1) ;    /* attr/color used by device */\n         icolor = (int)(dcolor - 0xf0) ;\n         if ((icolor >= 0) && (icolor <= 15))\n           colora++ ;\n       }\n     sdcb.colora = colora ;  /* number of actual colors on device */\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x87: Highlighting                                                */\n/*-------------------------------------------------------------------*/\nint dhilite(char *buf, short buflen)\n  {\n     int i, j = 0 ;    /* counter */\n     char attr ;       /* color attribute accepted by device */\n     char dhilite ;    /* color displayed for this attribute */\n\n     sdcb.hilites = (int)*(buf+4) ;\n     for (i=5;i<buflen;i=i+2)\n       {\n         attr = *(buf+i) ;        /* attribute used by appl. */\n         dhilite = *(buf+i+1) ;   /* attr/highlight used by device */\n         sdcb.hilitlst\u00ddj++\u00a8 = attr ;\n       }\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0x88: Modes                                                       */\n/*-------------------------------------------------------------------*/\nint dmodes(char *buf, short buflen)\n  {\n     int i ;           /* counter */\n     char mode ;       /* device opperation mode */\n\n     for (i=4;i<buflen;i++)\n       {\n         mode = *(buf+i) ;        /* attribute used by appl. */\n         if ((mode==0x01) ||\n             (mode==0x02))\n           sdcb.edsflg = 1 ;  /* queryable device can use extended DS*/\n       }   /* of for i */\n\n     return 0 ;\n  }\n\n/*-------------------------------------------------------------------*/\n/* 0xa6: Implicit partition                                          */\n/*-------------------------------------------------------------------*/\nint dimpart(char *buf, short buflen)\n  {\n     char *sdp ;                /* self defining parameter (SDP) ptr */\n     short wd, wa, hd, ha ;     /* screen dimensions */\n     short wcd, wca, hcd, hca ; /* cell sizes */\n     int i ;                    /* counter */\n\n     i = 6 ;        /* length of header */\n     while(i < buflen)   /* loop over all SDPs */\n       {\n         sdp = buf + i ;\n         if (*sdp==0x0b)    /* is it a SDP ? */\n           {\n             if (*(sdp+1)==0x01)\n               {\n                 wd = *((short *)(sdp+3)) ;  /* default width */\n                 hd = *((short *)(sdp+5)) ;  /* default height */\n                 wa = *((short *)(sdp+7)) ;  /* alternate width */\n                 ha = *((short *)(sdp+9)) ;  /* alternate height */\n                 if ((ha>hd) || (wa>wd))\n                   {\n                     sdcb.altflg = 1 ;    /* use alternate device */\n                     sdcb.rows = ha ;     /* use alternate rows */\n                     sdcb.cols = wa ;     /* use alternate cols */\n                   }\n                 else\n                   {\n                     sdcb.rows = hd ;     /* use primary rows */\n                     sdcb.cols = wd ;     /* use primary cols */\n                   }\n                 i = i + 11 ;     /* add length of this SDP */\n               }\n             else if (*(sdp+1)==0x03)\n               {\n                 i = i + 11 ;     /* add length of this SDP */\n               }\n             else if (*(sdp+1)==0x02)\n               {\n                 wcd = *((short *)(sdp+3)) ;  /* default cell width */\n                 hcd = *((short *)(sdp+5)) ;  /* default cell height */\n                 wca = *((short *)(sdp+7)) ;  /* alternate cell width */\n                 hca = *((short *)(sdp+9)) ;  /* alternate cell height*/\n                 if (sdcb.altflg)\n                   {\n                     sdcb.celheigh = hca ;\n                     sdcb.celwidth = wca ;\n                   }\n                 else\n                   {\n                     sdcb.celheigh = hcd ;\n                     sdcb.celwidth = wcd ;\n                   }\n                 i = i + 11 ;     /* add length of this SDP */\n               }\n           }\n       }  /* of while */\n\n     return 0 ;\n  }\n\n\n\n\n/*********************************************************************/\n/* General string handling routines for varying length strings.      */\n/*   lstran(mod_lstr,fromchar,tochar)                                */\n/*   lstrload(to_lstr,fromchar,len)                                  */\n/*   lstrunld(tochar,from_lstr)                                      */\n/*   lstrcopy(to_lstr,from_lstr)                                     */\n/*   lstrnew(to,fromchars)                                           */\n/*   lstrsub(to_lstr,from_lstr,start,length)                         */\n/*   len = lstrlen(haystack_lstr)                                    */\n/*   pos = lstrindex(haystack_lstr,needle_lstr)                      */\n/*   lstrfill(to_lstr,fillchars)                                     */\n/*   rc = lstrcmpc(cmp_lstr,cmpchars)                                */\n/*   lstrdel(del-lstr)                                               */\n/*   lstrover(to_lstr,char,position)                                 */\n/*   lstrrep(to_lstr,repchars,copies)                                */\n/*   lstrcat(to_lstr,left_lstr,right_lstr)                           */\n/*********************************************************************/\n\n/*-------------------------------------------------------------------*/\n/* Translate a character in an lstr to another character.            */\n/*-------------------------------------------------------------------*/\nvoid lstran(TLSTR *in, char from, char to)\n{\n  int i ;      /* temp counter */\n\n  if (in)      /* from string exists ? */\n    {\n      for (i=0;i<=in->len;i++)\n        {\n          if (*(in->data+i) == from)\n            *(in->data+i) = to ;\n        }\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Get the length of an lstr.                                        */\n/*-------------------------------------------------------------------*/\nint lstrlen(TLSTR *in)\n{\n  if (in)      /* from string exists ? */\n    {\n      return in->len ;\n    }\n  else\n    return 0 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Unload varying length string contents into character buffer.      */\n/*-------------------------------------------------------------------*/\nint lstrunld(char *to,\n             TLSTR *from)\n{\n  if (from)      /* from string exists ? */\n    {\n      memcpy(to,from->data,from->len) ;\n      return from->len ;\n    }\n  else\n    return 0 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Load varying length string with contents of character buffer.     */\n/*-------------------------------------------------------------------*/\nvoid lstrload(TLSTR *to,\n              char *from,\n              int len)\n{\n  if (to)      /* to string exists ? */\n    {\n      if (len!=to->len)\n        {\n          free((char *)to->data) ;\n          to->data = (char *)malloc(len) ;\n          if (!to->data) serror(4,\"Not enough memory\") ;\n          to->len = len ;\n        }\n      memcpy(to->data,from,len) ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Copy varying length string.                                       */\n/*-------------------------------------------------------------------*/\nvoid lstrcopy(TLSTR *to,\n              TLSTR *from)\n{\n  if (from)      /* from string exists ? */\n    {\n      if (!to)    /* to string does not exist */\n        serror(2,\"String does not exist\") ;\n      else     /* to string exists */\n        {\n          if (from->len > 0)\n            {\n              if (to->data == NULL)     /* does not exist yet ? */\n                {\n                  to->data = (char *)malloc(from->len) ;\n                  if (!to->data) serror(14,\"Not enough memory\") ;\n                }\n              else if (from->len != to->len)   /* increase length ? */\n                {\n                  free((char *)to->data) ;\n                  to->data = (char *)malloc(from->len) ;\n                  if (!to->data) serror(4,\"Not enough memory\") ;\n                }\n              to->len = from->len ;\n              memcpy(to->data,from->data,from->len) ;\n            }\n          else\n            {\n              if (to->len > 0)   /* empty data */\n                free((char *)to->data) ;\n              to->len = 0 ;\n              to->data = NULL ;\n            }\n        }\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Initialize a varying length string with a string supplied length. */\n/*-------------------------------------------------------------------*/\nvoid lstrnewx(TLSTR *newstr,\n             char *from,\n             int len)\n{\n  if (!newstr)\n    serror(5,\"String does not exist\") ;\n  else\n    {\n      if (len > 0)\n        {\n          newstr->data = (char *)malloc(len) ;\n          if (!newstr->data) serror(17,\"Not enough memory\") ;\n          newstr->len = len ;\n          memcpy(newstr->data,from,len) ;\n        }\n      else\n        {\n          newstr->len = 0 ;\n          newstr->data = NULL ;\n        }\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Initialize a varying length string with a string.                 */\n/*-------------------------------------------------------------------*/\nvoid lstrnew(TLSTR *newstr,\n             char *from)\n{\n  int i ;\n\n  if (!newstr)\n    serror(5,\"String does not exist\") ;\n  else\n    {\n      i = strlen(from) ;\n      if (i > 0)\n        {\n          newstr->data = (char *)malloc(i) ;\n          if (!newstr->data) serror(17,\"Not enough memory\") ;\n          newstr->len = i ;\n          memcpy(newstr->data,from,i) ;\n        }\n      else\n        {\n          newstr->len = 0 ;\n          newstr->data = NULL ;\n        }\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Create substring of a varying length string to a varying length   */\n/* string.                                                           */\n/*-------------------------------------------------------------------*/\nvoid lstrsub(TLSTR *to,\n             TLSTR *from,\n             int start,\n             int len)\n{\n  int i ;\n\n  if (start <= from->len)\n    {\n      i = from->len - start ;\n      if (len < i)\n        i = len ;       /* i is the length of the sub string */\n\n      if (!to)\n        serror(8,\"String does not exist\") ;\n      else\n        {\n          if (i > 0)\n            {\n              if (to->data == NULL)     /* does not exist yet ? */\n                {\n                  to->data = (char *)malloc(i) ;\n                  if (!to->data) serror(20,\n                    \"Not enough memory\") ;\n                }\n              else if (to->len != i)          /* wrong size ? */\n                {\n                  free((char *)to->data) ;\n                  to->data = (char *)malloc(i) ;\n                  if (!to->data) serror(10,\n                    \"Not enough memory\") ;\n                }\n              to->len = i ;\n              memcpy(to->data,from->data+start,i) ;\n            }\n          else\n            {\n              if (to->len > 0)   /* empty data */\n                free((char *)to->data) ;\n              to->len = 0 ;\n              to->data = NULL ;\n            }\n        }\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Find the position in a varying length string of a varying length  */\n/* sub-string.                                                       */\n/*-------------------------------------------------------------------*/\nint lstrindx(TLSTR *haystack, /* string to search */\n             TLSTR *needle)   /* sub-string to search for */\n{\n  int i, j, k, endpos ;\n\n  endpos = haystack->len - needle->len ;\n  for (i=0; i<endpos; i++)\n    {\n      k = 0 ;\n      for (j=0; j<needle->len; j++)\n        {\n          if (haystack->data\u00ddi+j\u00a8 == needle->data\u00ddj\u00a8)\n            k ++ ;\n          else break ;\n        }\n      if (k==needle->len)\n        return(i+1) ;\n    }\n  return 0 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Compare a varying length string with a string.                    */\n/*   rc = 0  == strings same                                         */\n/*   rc = 1  == lstr has larger value than charstr                   */\n/*   rc = -1 == lstr has smaller value than charstr                  */\n/*-------------------------------------------------------------------*/\nint lstrcmpc(TLSTR *lstr,   /* string to compare */\n             char *cstr)    /* characters to compare with */\n{\n  int i ;               /* counter */\n  int t=0 ;             /* compare flag */\n  int l ;               /* compare length */\n  int ld=0 ;            /* length differ flag */\n  char *lstrptr ;\n  char *cstrptr ;\n\n  l = strlen(cstr) ;    /* determine shortest string */\n  if (l != lstr->len)   /* same lengths ? */\n    {                   /*   no .. */\n      ld = 1 ;          /*   flag lengths differ */\n      if (l > lstr->len)\n        l = lstr->len ; /*   use shortest length */\n    }\n\n  /* compare to shortest length */\n  lstrptr = lstr->data ;\n  cstrptr = cstr ;\n  for (i=0; i<l; i++)\n    {\n      if (*lstrptr > *cstrptr)\n        {\n          t = 1 ;    /* indicate left larger than right */\n          break ;    /* end scan now  */\n        }\n      if (*lstrptr < *cstrptr)\n        {\n          t = -1 ;   /* indicate left smaller than right */\n          break ;    /* end scan now  */\n        }\n      lstrptr++ ;\n      cstrptr++ ;\n    }\n\n  if ((t==0) && (ld==1)) /* same after shortest length compared ? */\n    {\n      if (strlen(cstr) > lstr->len)\n        t = -1 ;     /* lstr smaller */\n      else\n        t = 1 ;      /* lstr larger */\n    }\n  return t ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Fill a varying length string with a string.                       */\n/*-------------------------------------------------------------------*/\nvoid lstrfill(TLSTR *string,   /* string to fill */\n              char *fillstr)  /* filler characters to use */\n{\n  int i ;\n  char *strptr ;\n\n  strptr = fillstr ;\n  for (i=0; i<=string->len; i++)\n    {\n      string->data\u00ddi\u00a8 = *(strptr++) ;\n      if (*strptr=='\\0')\n        strptr = fillstr ;    /* start over on fill string */\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Delete a varying length string (free associated memory).          */\n/*-------------------------------------------------------------------*/\nvoid lstrdel(TLSTR *string)   /* string to delete */\n{\n  free((char *)string->data) ;\n  string->data = NULL ;\n  string->len = 0 ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Overlay a character in a varying length string.                   */\n/*-------------------------------------------------------------------*/\nvoid lstrover(TLSTR *string,\n             char oc,\n             int pos)\n{\n  char *cp ;\n\n  if ((pos >= 1) && (pos <= string->len))    /* position ok ? */\n    {\n      cp = string->data + pos + 1 ;\n      *cp = oc ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Create a varying length string with multiple copies of a string.  */\n/*-------------------------------------------------------------------*/\nvoid lstrrep(TLSTR *string,\n             char *repstr,\n             int copies)\n{\n  int repstrlen ;\n  char *strptr ;\n  int newlen ;\n  int i ;\n\n  /* The input string that replications are made from is assumed */\n  /* to have a length of one or longer.                          */\n\n  repstrlen = strlen(repstr) ;\n  if (repstrlen==0)  /* assume repitition of 0x00 */\n    repstrlen = 1 ;\n  newlen = repstrlen * copies ;\n  if (string->data==NULL)          /* alloc storage ? */\n    {\n      string->data = (char *)malloc(newlen) ;\n      if (!string->data) serror(21,\"Not enough memory\") ;\n    }\n  else if (string->len!=newlen)    /* alloc more/less storage ? */\n    {\n      if (string->data)\n        free((char *)string->data) ;\n      string->data = (char *)malloc(newlen) ;\n      if (!string->data) serror(11,\"Not enough memory\") ;\n    }\n  string->len = newlen ;     /* alter string length */\n  strptr = repstr ;\n  for (i=0; i<newlen; i++)        /* replicate the repstr data */\n    {\n      string->data\u00ddi\u00a8 = *strptr++ ;\n      if (*strptr == '\\0')\n        strptr = repstr ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* Concatenate two varying length strings together placing the       */\n/* in a varying length string.                                       */\n/*-------------------------------------------------------------------*/\nvoid lstrcat(TLSTR *result,   /* result of concatenation */\n             TLSTR *left,     /* left string to concatenate */\n             TLSTR *right)    /* right string to concatenate */\n{\n  char *rstr ;\n  int newlen ;\n\n  newlen = left->len + right->len ;    /* extend LSTR */\n  rstr = (char *)malloc(newlen) ;\n  if (!rstr) serror(12,\"Not enough memory\") ;\n\n  memcpy(rstr,left->data,left->len) ;   /* make new string */\n  memcpy(rstr+left->len,right->data,right->len) ;\n\n  free((char *)result->data) ;   /* assemble new LSTR */\n  result->data = rstr ;\n  result->len = newlen ;\n}\n\n\n/*********************************************************************/\n/* General sub routines.                                             */\n/*   fill(haystack,fillchar,number)                                  */\n/*   dumpchar(buffer,length)                                         */\n/*   overlay(buffer,bufferlen,overlay,overlaylen,overlaypos)         */\n/*********************************************************************/\n\n/*-------------------------------------------------------------------*/\n/* Fill a character string with a number of filler characters.       */\n/*-------------------------------------------------------------------*/\nvoid fill(char *haystack,   /* area to fill */\n          char filler,      /* fill characters */\n          int num)          /* number of repetitions */\n{\n  int i = 0 ;\n  for(i=0;i<=num;i++)\n    *haystack++ = filler ;\n  *haystack = '\\0' ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Dump the contents of a buffer, formatted in a way that makes a    */\n/* 3270 data stream easier to interpret.                             */\n/*-------------------------------------------------------------------*/\nvoid dumpchar(char *dat,    /* data to dump */\n              int len)      /* length to dump */\n{\n  char *cptr ;\n  char c ;\n  char cc\u00dd3\u00a8 ;\n  int i ;\n  int n, m ;\n\n  n = 0 ;\n  m = 0 ;\n  cptr = dat ;\n  do\n    {\n      printf(\"      %.8X \",dat) ;\n      for(i=1;i<=16;i++)\n        {                   /* 0 indicates all */\n          if (*dat=='\\0' && len==0)\n            break ;\n          if (n==len && len>0)\n            break ;\n          c = *dat++ ;\n          n++ ;\n          printf(\"%.2X\",c) ;\n          if ((i%4)==0)\n            printf(\" \") ;\n        }\n      printf(\"\\n               \") ;\n\n      for(i=1;i<=16;i++)\n        {\n          if (*cptr=='\\0' && len==0)\n            break ;\n          if (m==len && len>0)\n            break ;\n          c = *cptr++ ;\n          m++ ;\n          if (c <= 0x3f || c==0xff)\n            {\n              switch (c)\n                {\n                  case GE:   strcpy(cc,\"GE\") ;\n                    break ;\n                  case FF:   strcpy(cc,\"FF\") ;\n                    break ;\n                  case CRR:  strcpy(cc,\"CR\") ;\n                    break ;\n                  case SBA:  strcpy(cc,\"SB\") ;\n                    break ;\n                  case EUA:  strcpy(cc,\"EU\") ;\n                    break ;\n                  case ICUR: strcpy(cc,\"IC\") ;\n                    break ;\n                  case NL:   strcpy(cc,\"NL\") ;\n                    break ;\n                  case EM:   strcpy(cc,\"EM\") ;\n                    break ;\n                  case DUP:  strcpy(cc,\"DU\") ;\n                    break ;\n                  case SF:   strcpy(cc,\"SF\") ;\n                    break ;\n                  case FM:   strcpy(cc,\"FM\") ;\n                    break ;\n                  case SA:   strcpy(cc,\"SA\") ;\n                    break ;\n                  case SFE:  strcpy(cc,\"SX\") ;\n                    break ;\n                  case MF:   strcpy(cc,\"MF\") ;\n                    break ;\n                  case RA:   strcpy(cc,\"RA\") ;\n                    break ;\n                  case SUB:  strcpy(cc,\"SU\") ;\n                    break ;\n                  default:   strcpy(cc,\". \") ;\n                    break ;\n                }\n              printf(\"%s\",cc) ;\n            }\n          else\n            printf(\"%c \",c) ;\n          if ((i%4)==0)\n            printf(\" \") ;\n        }\n      printf(\"\\n\") ;\n    }\n  while( ((*dat!='\\0') && (len==0)) ||\n         ((m!=len) && (len>20))\n       ) ;\n  printf(\"\\n\") ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Overlay characterc in a buffer.                                   */\n/*-------------------------------------------------------------------*/\nvoid overlay(char *haystack,    /* area to overlay */\n             int haylen,        /* length to overlay */\n             char *needle,      /* overlay characters */\n             int len,           /* length of overlay */\n             int pos)           /* start postition of overlay */\n{\n  int hlen, nlen ;   /* length of haystack and needle */\n  int i = 0 ;        /* itterator */\n\n  if (haylen==0)\n    hlen = strlen(haystack) ;\n  else\n    hlen = haylen ;\n\n  if (len==0)\n    nlen = strlen(needle) ;\n  else\n    nlen = len ;\n\n  if (hlen>(nlen+pos))\n    {\n      haystack = haystack+pos ;    /* move to overlay pos */\n      for(i=0;i<nlen;i++)          /* copy the data */\n        *haystack++ = *needle++ ;\n    }\n}\n\n/*-------------------------------------------------------------------*/\n/* General error message routine.                                    */\n/*-------------------------------------------------------------------*/\nvoid serror(int errno,\n            char *msg)\n{\n  sprintf(msg,\"Error: %d - %s\\n\",errno,msg) ;\n  execmsg(\"WIN035S\",msg) ;\n  abort() ;\n}\n\n/*-------------------------------------------------------------------*/\n/* Translate a string to upper case.                                 */\n/*-------------------------------------------------------------------*/\nvoid strtoupr(char *str)\n  {\n    char *strp ;\n\n    strp = str ;\n    while(*strp)\n      {\n        *strp = toupper(*strp) ;\n        strp++ ;\n      }\n  }\n\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT258/FILE258.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT258", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}