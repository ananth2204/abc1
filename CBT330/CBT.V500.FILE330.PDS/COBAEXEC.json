{"INMR01": {"INMLRECL": 80, "INMFNODE": "NODENAME", "INMFUID": "EX31022", "INMTNODE": "SY1", "INMTUID": "EX31022", "INMFTIME": "20021210080916000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 999362, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 27920, "INMRECFM": "FB", "INMDIR": 9, "INMDSNAM": "EX31022.COBA.SISPEXEC", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 999362, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 999362, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"EX31022.COBA.SISPEXEC": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 27920, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 128, "file_tape_blocksize": 3120, "DVAOPTS": 12304, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "020344", "DS1SCEXT": "b'\\x80m\\x10'", "DS1SCALO": "b'P\\x00\\x003'", "DS1LSTAR": "b'\\x00\\x0f\\x03'", "DS1TRBAL": "b'\\x06\\xe8'"}, "COPYR2": {"deb": "b'\\x02\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f1\\xe0\\x00\\x04\\x93\\xd00'", "extents": ["b'\\x02\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f1\\xe0\\x00\\x04\\x93\\xd00'", "b'X\\xf4H\\xf8\\x00\\x00\\x00\\x0e\\x00\\x02\\x00\\x0f\\x00\\x01\\x00\\x0f'", "b'X\\xf4H\\xf8\\x00\\x00\\x00-\\x00\\x01\\x00.\\x00\\x0b\\x00\\x1a'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$README": {"ttr": 515, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00@\\x00\\x99\\x15\\x9f\\x00\\x99\\x15\\x9f\\x07\\x12\\x00,\\x00,\\x00\\x00\\xc4\\xc5\\xe2\\xe3\\xe2\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-06-08T00:00:00", "modifydate": "1999-06-08T07:12:40", "lines": 44, "newlines": 44, "modlines": 0, "user": "DESTS03"}, "text": "     ----------------------- ISPF application --------------------------\n\n     supplement to CBT File 419\n\n     COBA      This Application analyse the output from the\n               Cobol analyse program developed by Roland Schiradin\n               Roland(at)Schiradin.de\n               To simlify the procedure, the program COBANAL is\n               included in this library\n               This application requires ISPF Version 4\n               The application consist of 4 datasets.\n               Rexx library\n               Panel Library\n               Message and Skeleton Library\n               Table Libary\n\n               You have to change member $COBA in the Rexx library\n               See section/label Coba_Parms thru End_Coba_Parms.\n               Please change the following variables to your standards\n\n               ACCOUNT\n               CLASS\n               MSGCLASS\n               STEPLIB\n               ISPFHLQ\n               COBAAPPL\n               COBAHLQ\n               LLQCLIB\n               LLQPLIB\n               LLQMLIB\n               LLQSLIB\n               LLQTLIB\n               LLQTABL\n\n               After these changes you can execute procedure $COBA\n               First you'll see a selection panel to display\n               or create analyse tables.\n\n               If you have any problems, comments or improvements\n               please contact\n               Alber(at)alber-edv.de\n               If case of a problem please send the output from\n               the COBANAL program and the edited output file.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$WHATSN": {"ttr": 519, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x17\\x00\\x994\\x8f\\x00\\x994\\x8f\\x16I\\x00\\x03\\x00\\x02\\x00\\x00\\xc4\\xc5\\xe2\\xe3\\xe2\\xf0\\xf3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-12-14T00:00:00", "modifydate": "1999-12-14T16:49:17", "lines": 3, "newlines": 2, "modlines": 0, "user": "DESTS03"}, "text": "COBANAL  A new version\nSISP*    The ISPF interface changed rexx's and panels\n         for new output from COBANAL program\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$COBA": {"ttr": 521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x14\\x00\\x99&_\\x00\\x995\\x0f\\x078\\x00H\\x00H\\x00\\x00\\xc5\\xe7\\xf3\\xf1\\xf0\\xf2\\xf2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-09-22T00:00:00", "modifydate": "1999-12-16T07:38:14", "lines": 72, "newlines": 72, "modlines": 0, "user": "EX31022"}, "text": "/*---- REXX -- COPYRIGHT - 1999 -- COBA ---- ISPF-DIALOG -----*/\n/*                                                            */\n/*     COBOL ANALYSE ISPF DIALOG                              */\n/*     supplement to cbt file 419 program cobanal             */\n/*     developed by roland schiradin                          */\n/*                                                            */\n/*     Fritz Alber                                            */\n/*     Albstr. 19                                             */\n/*     D 72649 Wolfschlugen                                   */\n/*     TEL. 0049-7022/959234                                  */\n/*     FAX. 0049-7022/959236                                  */\n/*                                                            */\n/*     E-MAIL  : Alber\u00a7alber-edv.de                           */\n/*     INTERNET: www.alber-edv.de                             */\n/*                                                            */\n/*     Please customize section Coba_parms to your values     */\n/*                                                            */\n/*------------------------------------------------------------*/\n\nCoba_Parms:              /*  -------- Start COBA Parms ------ */\n                         /*  --------- JCL Parameters ------- */\nACCOUNT = '#ACCNT'       /*  Account Info for JOB card        */\nCLASS   = 'S'            /*  Job class                        */\nMSGCLASS= 'T'            /*  Job message class                */\nISPFHLQ = 'ISP'          /*  ISPFHLQ = HLQ for ISP system dsn */\n                         /*  Steplib for COBANAL program      */\nSTEPLIB = 'EX31022.COBA.SISPLOAD'\n                         /*  ------- End JCL Parameters ----- */\n                         /*  ----------- ISPF Parms --------- */\nCOBAHLQ = 'EX31022.COBA' /*  COBAHLQ = HLQ for COBA ISPF appl */\n                         /*                                   */\nCOBAAPPL = COBA          /*  ISPF Application name for COBA   */\n                         /*  application                      */\nLLQCLIB  = SISPEXEC      /*  LOW LEVEL QUALIFIER for EXEC and */\n                         /*  CLISTS. Change to your value     */\nLLQMLIB  = SISPMENU      /*  LOW LEVEL QUALIFIER for  MESSAGES*/\n                         /*  Change to your value             */\nLLQPLIB  = SISPPENU      /*  LOW LEVEL QUALIFIER for  PANELS  */\n                         /*  Change to your value             */\nLLQSLIB  = SISPMENU      /*  LOW LEVEL QUALIFIER for  SKELS   */\n                         /*  Change to your value             */\nLLQTLIB  = SISPTENU      /*  LOW LEVEL QUALIFIER for  TABLE   */\n                         /*  INPUT. Change to your value      */\nLLQTABL  = SISPTENU      /*  LOW LEVEL QUALIFIER for  TABLE   */\n                         /*  OUTPUT. Change to your value     */\n                         /*  ------- End of ISPF Parms ------ */\nEnd_Coba_Parms:          /*  ------  End of Coba Parms ------ */\n\nADDRESS TSO\n\"ALTLIB ACTIVATE APPL(CLIST) DATASET('\"COBAHLQ\".\"LLQCLIB\"')\"\n\nADDRESS ISPEXEC\n\"LIBDEF ISPMLIB DATASET ID('\"COBAHLQ\".\"LLQMLIB\"') STACK\"\n\"LIBDEF ISPPLIB DATASET ID('\"COBAHLQ\".\"LLQPLIB\"') STACK\"\n\"LIBDEF ISPSLIB DATASET ID('\"COBAHLQ\".\"LLQSLIB\"') STACK\"\n\"LIBDEF ISPTLIB DATASET ID('\"COBAHLQ\".\"LLQTLIB\"') STACK\"\n\"LIBDEF ISPTABL DATASET ID('\"COBAHLQ\".\"LLQTABL\"') STACK\"\n\n\"SELECT CMD(COBANL \" STEPLIB COBAAPPL COBAHLQ ,\n            LLQCLIB LLQMLIB LLQPLIB LLQSLIB LLQTLIB LLQTABL ,\n            ACCOUNT CLASS MSGCLASS ISPFHLQ\") ,\n            PASSLIB NEWAPPL(\"COBAAPPL\")\"\n\n\"LIBDEF ISPMLIB\"\n\"LIBDEF ISPPLIB\"\n\"LIBDEF ISPSLIB\"\n\"LIBDEF ISPTLIB\"\n\"LIBDEF ISPTABL\"\n\nADDRESS TSO \"ALTLIB DEACTIVATE APPL(CLIST)\"\n\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COBA#MAC": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x16\\x01\\x00\\x01\\x0f\\x01\\x004o\\tS\\x00\\xef\\x00\\xef\\x00\\x01\\xc4\\xc5\\xe2\\xe3\\xe2\\xf0\\xf3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-01-10T00:00:00", "modifydate": "2000-12-11T09:53:16", "lines": 239, "newlines": 239, "modlines": 1, "user": "DESTS03"}, "text": "/* REXX */\nTRACE\nADDRESS ISPEXEC\n\"ISREDIT MACRO\"\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'was loaded' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'Sorry no'   ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'You better' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'Can not estab' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND '=== End  ====' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'No call'    ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'No program' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'Call Liter' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'Call iden'  ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'Call address'  ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'Copy-'      ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'Program has' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'Program use' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND ' DATA DIVISION' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND ' ENVIROMENT DIVISION' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'Additional' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'User supplied' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'Following' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'Installation def' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'hexadecimal' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'Exponent' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'Floating' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'Basis-St' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'Shift-In' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'Compilation' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT CHANGE 'no Default' 'no-Default'                          ALL\"\n\"ISREDIT RESET\"\n\"ISREDIT CHANGE 'SIZE(value)SOURCE' 'SIZE(value) SOURCE'           ALL\"\n\"ISREDIT RESET\"\n\"ISREDIT CHANGE 'SIZE(value)NOSOURCE' 'SIZE(value) NOSOURCE'       ALL\"\n\"ISREDIT RESET\"\n\"ISREDIT CHANGE 'Go to' 'Go-to'                                    ALL\"\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT BOUNDS 1 50\"\n\"ISREDIT FIND '                                                  ' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT CHANGE 'NO TRACE ' 'NO-TRACE '                            ALL\"\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT BOUNDS 1 50\"\n\"ISREDIT FIND '==================================================' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT BOUNDS 1 20\"\n\"ISREDIT FIND 'Open Exten' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'Error during load' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT FIND 'DBCS-Name in' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT EXCLUDE ALL\"\n\"ISREDIT BOUNDS 1 3\"\n\"ISREDIT FIND 'No ' ALL\"\nif rc = 0\nthen do\n  \"ISREDIT DELETE ALL NX\"\nend\n\"ISREDIT RESET\"\n\"ISREDIT BOUNDS\"\n\"ISREDIT END \"\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COBAI34": {"ttr": 259, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*-------- REXX -------------------------------------------*/\n/* Function   : display information ISPF 3.4 panel         */\n/* callers    : COBA application                           */\n/*---------------------------------------------------------*/\n/*\n   TRACE ?R\n*/\n\narg type arg1 arg2\n\nif type = 'VOL'\nthen do\n  zdldsnlv = \" \"\n  zdlpvl   = arg1\nend\nelse do\n  if type = 'BOTH'\n  then do\n    zdldsnlv = arg1\n    zdlpvl   = arg2\n  end\n  else do\n    zdldsnlv = arg1\n    zdlpvl   = \"\"\n  end\nend\n\n\"ispexec vput (zdldsnlv zdlpvl) profile\"\n\"ISPEXEC SELECT PGM(ISRUDL) PARM(ISRUDLP)\"\n\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COBANAL": {"ttr": 2307, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00&\\x01\\x02\\x01_\\x01\\x02\\x01_\\x149\\x08\\x1b\\x08\\x1b\\x00\\x00\\xc5\\xe7\\xf3\\xf1\\xf0\\xf2\\xf2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-01-15T00:00:00", "modifydate": "2002-01-15T14:39:26", "lines": 2075, "newlines": 2075, "modlines": 0, "user": "EX31022"}, "text": "***********************************************************************\n*                                                                     *\n* Name:         COBANAL                                               *\n*                                                                     *\n* Author:       Roland Schiradin                                      *\n*               roland(at)Schiradin.de                                *\n*                                                                     *\n* Date:         Februar 1996                                          *\n*                                                                     *\n* Description:  Show compile-settings and some other information      *\n*                                                                     *\n* Changes:      16.12.1996 (european)                                 *\n*               Support for VS/COBOL1 (just a few)                    *\n*               String macro no longer inside this source             *\n*               (request FILE183 from Naspa or drop me an email)      *\n*               28.04.1997 (european)                                 *\n*               Support for COBOL for MVS and VM Release 2 (formally  *\n*               called AD/Cycle COBOL/370)                            *\n*               04.03.1998 (european)                                 *\n*               MODID-marco dropped                                   *\n*               Direct Load-Library support                           *\n*               Some parts of Dave Alcocks code (DA$COBR)             *\n*               (You can contact him at dalcock(at)csw.com)           *\n*               24.03.1998 (european)                                 *\n*               Prevent S15D abend you invoke COBANAL from TSO-CALL   *\n*               (reported by Dave Alcock)                             *\n*               Support for newer STRING macro STRING GENERATE instead*\n*               of STRING FINAL_CALL                                  *\n*               (reported by Dave Alcock)                             *\n*               Fixed a bug in statement list. Y now means Yes and not*\n*               vice versa. Sorry                                     *\n*               15.02.1999 (european)                                 *\n*               Support for COBOL OS/390 and VM V2R1                  *\n*               Some new Compile-options                              *\n*               Compile-Date is European style, added long name       *\n*               Some minor fixes I cant remember in detail            *\n*               Support for MVS 4.3 (AMODE switching)                 *\n*               10.06.1999 (european)                                 *\n*               Fixed bugs reported by Mr. Smets (Thank you)          *\n*               Show ?? as the century for COBOL2                     *\n*               Support for Entrypoints (e.g. ENTRY 'DLITCBL')        *\n*               Note: There is no need to do this for IMS             *\n*               25.10.1999 (european)                                 *\n*               Check ParmLength for Parameter \"ALL\".                 *\n*               Close all datasets                                    *\n*               Make CobAnal reentrant (LinkList!!!)                  *\n*               Release storage                                       *\n*               Load modules from DD COBANAL if exist                 *\n*               29.12.1999 (european)                                 *\n*               Abend 0C4 fixed                                       *\n*               Add PPA2 support                                      *\n*               Detect C/C++ and LE-enabled Assembler Programs        *\n*               The product name for COBOL1 is OS/VS Cobol (MVS) and  *\n*               DOS/VS COBOL (VSE)                                    *\n*               13.04.2000 (european)                                 *\n*               Support for some infos I missed (INVOKE, GLOBAL and   *\n*               so on) Thank you Mr. Gross                            *\n*               Add a third base register                             *\n*               23.04.2000 (european)                                 *\n*               Tested with STRING V507 from FILE183                  *\n*               19.07.2000 (european)                                 *\n*               Support for COBOL1 OEM products (e.g. CA-Optimzer)    *\n*               Thank you Mr. Pfeifer                                 *\n*               02.10.2000 (european)                                 *\n*               Support for COBOL for OS/390 & VM V2R2                *\n*               New TEST(SEPARATE)/NO TEST(SEPARATE)                  *\n*               New ARITH(EXTEND)/ARITH(COMPAT)                       *\n*               New line-sequential file                              *\n*               Thank you IBM for HFS-Support and Display under CICS  *\n*               Save some literal pool                                *\n*               I know I need to re-design the program but the        *\n*               time (you may know) is limited. At the start it       *\n*               was intend to run once and then throw it away         *\n*               Thanks for all ideas to do it better, if I'm retired  *\n*               I would spent some time on it. Don't expect that      *\n*               within the next 25 years !!!                          *\n*               09.10.1999 (european)                                 *\n*               End-Substract changed to End-Subtract                 *\n*               Corect a length for moving literal Subtract           *\n*               08.01.2001 (european)                                 *\n*               Loop bug fixed                                        *\n*               04.12.2001 (european)                                 *\n*               Fixed buf reporting CLOSE Y/N                         *\n*               Support for Cobol Enterprise V3R1 (BETA)              *\n*               Support for generic member names                      *\n*                 You can use ? or * in the member name to minimize   *\n*                 output instead of ALL or a single load member       *\n*                 '?' stand for any single character                  *\n*                 '*' stand for any character                         *\n*                 Be aware this feature require SYS1.MODGEN(ASAXWC)   *\n*                 introduced with MVS 5.2                             *\n*               ** Attention ****                                     *\n*                  CobAnal require MVS 5.2                            *\n*               ** Attention ****                                     *\n*               ASAXWC is not GUPI but I raised a requirement         *\n*               If you think ASAXWC might be useful for you too,      *\n*               please open a requirement                             *\n***********************************************************************\n         TITLE 'Show Compile-Option and some more nice info'\nCOBANAL  CSECT\nCOBANAL  AMODE 31\nCOBANAL  RMODE 24\n         BAKR  R14,R0             Save register\n         LA    R10,1\n         LR    R6,R15             set base register\n         LA    R7,4095(R10,R6)    second base register\n         LA    R12,4095(R10,R7)   third base register\n         USING COBANAL,R6,R7,R12     Addressebility\n         L     R9,0(R1)           Save Parmlist\n         USING COBANAL_PARM,R9    addressebility\n         LA    R0,COBANAL_WORK_LENGTH\n         STORAGE OBTAIN,LENGTH=(R0),ADDR=(R1),COND=NO,LOC=BELOW\n         LR    R11,R1             COBANAL_WORK register\n         USING COBANAL_WORK,R11   addressebility\n         MVC   EYECATCHER,=CL8'COBANAL'\n         MVI   DOALL,C'N'         Default\n         MVI   DD_COBANAL,C'N'    Default\n         XC    SAVEAREA,SAVEAREA  clear saveare\n         LA    R15,SAVEAREA       get address of savearea\n         ST    R13,4(,R15)        chain the savearea back pointer\n         ST    R15,8(,R13)        chain saveare forward\n         LR    R13,R15            set new savearea\n         ST    R11,ADR_COBANAL_WORK  save address\n         ST    R9,ADR_COBANAL_PARM   save address\n*------------------------------------------------------------*\n*        Check JCL-Parm                                      *\n*------------------------------------------------------------*\n         MVC   PARM_LENGTH,COBANAL_PARM_LENGTH\n         LH    R10,PARM_LENGTH\n         LA    R9,2(R9)            jump length field\n         MVC   PGMNAME,BLANKS      clear PGMNANE\n         MVC   PGMNAME_GET,BLANKS  clear PGMNANE GETMEM\n         LA    R8,PGMNAME          first parm\nCOBANAL_010 DS  0H                 do until first ',' or end\n         CLI   0(R9),C','          parm separator\n         BE    COBANAL_020         next parm\n         MVC   0(1,R8),0(R9)\n         LA    R8,1(R8)            next digit\n         LA    R9,1(R9)            next digit\n         BCT   R10,COBANAL_010     loop\nCOBANAL_020 DS  0H\n         MVC   SYSPRINT(SYSPRINT_FIX_LENGTH),SYSPRINT_FIX\n         MVC   PARMLIST(C_LSTOL),C_LSTO\n         LA    R9,SYSPRINT\n         USING IHADCB,R9\n         MVC   DCBDDNAM,=C'SYSPRINT'\n         OPEN  ((R9),OUTPUT),MF=(E,PARMLIST)\n         DROP  R9\n         DEVTYPE =CL8'COBANAL',DOUBLE     Get COBANAL information\n         LTR   R15,R15                    Is it allocated?\n         BNZ   COBANAL_021                No, continue\n         MVI   DD_COBANAL,C'Y'    Default\n         MVC   INPUT(INPUT_FIX_LENGTH),INPUT_FIX\n         MVC   PARMLIST(C_LSTIL),C_LSTI\n         LA    R9,INPUT\n         USING IHADCB,R9\n         MVC   DCBDDNAM,=C'COBANAL '\n         OPEN  ((R9),INPUT),MF=(E,PARMLIST)\n         DROP  R9\nCOBANAL_021 DS  0H\n         STRING 'COBOL module analysis is starting',INTO=RECORD\n         BAL   R14,SPACE1                 Print starting message\n         CLC   PGMNAME,BLANKS      check PGMNAME\n         BE    COBANAL_PARM_ERROR  if clear ==> Error\n         CLC   PGMNAME(3),=C'ALL'  PGMNAME = ALL indicate analyzing\n         BNE   COBANAL_025         a complete Load, but check for\n         CLC   PARM_LENGTH,=H'3'   length; maybe it is a prog called\n         BNE   COBANAL_025         ALLWAYS :-))\n         CLI   DD_COBANAL,C'Y'        Did you read the docs?\n         BE    COBANAL_022           yes, thats fine\n         STRING 'Parameter=ALL specified but DD-Name COBANAL missing', *\n               INTO=RECORD\n         BAL   R14,SPACE1                 Print starting message\n         MVC   RETCODE,=F'12'\n         B     COBANAL_EXIT         no, leave\n** Loop\nCOBANAL_022 DS  0H\n         MVI   DOALL,C'Y'          remember that\n         BAL   R14,GETMEM          get the member name\n         CLC   PGMNAME_GET,XFF         more entries?\n         BE    COBANAL_EXIT          leave\n*------------------------------------------------------------*\n*        Load the progamm from DD COBANAL                    *\n*------------------------------------------------------------*\n         LOAD  EPLOC=PGMNAME_GET,DCB=INPUT,ERRET=COBANAL_LOAD_ERROR\n         B     COBANAL_027\nCOBANAL_025 DS  0H\n         LA    R5,PGMNAME         start search at address\n         LA    R4,L'PGMNAME       length of string to be searched\n         AR    R4,R5              + start of address\n         LA    R0,C'?'            search for ?\n         SRST  R4,R5              issue search\n         BC    4,COBANAL_028      wildcard ? found\n         LA    R5,PGMNAME         start search at address\n         LA    R4,L'PGMNAME       length of string to be searched\n         AR    R4,R5              + start of address\n         LA    R0,C'*'            search for *\n         SRST  R4,R5              issue search\n         BC    4,COBANAL_028      wildcard * found\n         MVC   PGMNAME_GET,PGMNAME\n         CLI   DD_COBANAL,C'Y'    load from DD Cobanal ?\n         BE    COBANAL_026           yes\n*------------------------------------------------------------*\n*        Load the progamm                                    *\n*------------------------------------------------------------*\n         LOAD  EPLOC=PGMNAME_GET   Load the pgm\n         B     COBANAL_027\nCOBANAL_026 DS  0H\n*------------------------------------------------------------*\n*        Load the progamm from DD COBANAL                    *\n*------------------------------------------------------------*\n         LOAD  EPLOC=PGMNAME,DCB=INPUT,ERRET=COBANAL_LOAD_ERROR\nCOBANAL_027 DS  0H\n         LTR   R15,R15             check response\n         BNZ   COBANAL_LOAD_ERROR if greater zero ==> Error\n         ST    R0,ADR_PGMNAME      save the address\n*------------------------------------------------------------*\n*        Check length                                        *\n*------------------------------------------------------------*\n         CSVQUERY SEARCH=JPALPA,       SEARCH JPAQ                     +\n               INADDR=ADR_PGMNAME,     ADDRESS                         +\n               OUTLENGTH=CSV_LENGTH,                                   +\n               MF=(E,CSVQRYWK)         WORK AREA\n         LTR   R2,R15                  pass return code\n         BNZ   COBANAL_CSV_ERROR if greater zero ==> Error\n         B     COBANAL_03\nCOBANAL_028 DS  0H\n         MVI   DOALL,C'X'          remember that (eXclude)\n         BAL   R14,GETMEM          get the member name\n         CLC   PGMNAME_GET,XFF         more entries?\n         BE    COBANAL_EXIT          leave\n         ASAXWC    PATTERNSTR=PGMNAME,                                 X\n               PATTERNSTRLEN==A(L'PGMNAME),                            X\n               STRING=PGMNAME_GET,                                     X\n               STRINGLEN==A(L'PGMNAME_GET),                            X\n               ZEROORMORE==CL1'*',                                     X\n               ONECHAR==CL1'?',                                        X\n               DELIMITER==CL1' ',                                      X\n               RETCODE=RETCODE,                                        X\n               MF=(E,MYLIST)\n*        STRING 'Program Name= ',PGMNAME_GET,                          @\n               ' Pattern= ',PGMNAME,'RC= ',(RETCODE,,X),               @\n               INTO=RECORD                    debug\n*        BAL   R14,SPACE1\n         CLC   RETCODE,=F'0'\n         BNE   COBANAL_028\n*------------------------------------------------------------*\n*        Load the progamm from DD COBANAL                    *\n*------------------------------------------------------------*\n         LOAD  EPLOC=PGMNAME_GET,DCB=INPUT,ERRET=COBANAL_LOAD_ERROR\n         B     COBANAL_027\n*------------------------------------------------------------*\n*        Write info to sysprint                              *\n*------------------------------------------------------------*\nCOBANAL_03 DS  0H\n         STRING 'Program Name= ',PGMNAME_GET,                          @\n               ' was loaded into storage at EPA= ',(ADR_PGMNAME,,X),   @\n               INTO=RECORD\n         BAL   R14,SPACE1\n*\n*        Dump the first 256 Bytes for Identification.\n*        Should be activate only in case of problems\n*\n*        L     R4,ADR_PGMNAME\n*        LA    R3,256/16               LOOP COUNTER\n*LOOP\nCOBANAL_04 DS  0H\n*        STRING 4X,((R4),4,X),1X,(4(R4),4,X),1X,(8(R4),4,X),1X,        X\n               (12(R4),4,X),3X,((R4),16),                              $\n               INTO=RECORD\n*        BAL   R14,SPACE1          <== next line\n*        LA    R4,016(,R4)             BUMP POINTER\n*        BCT   R3,COBANAL_04\n*ENDLOOP\n         L     R4,ADR_PGMNAME       Load-Entry-Point\n         USING COBOL_370_DSECT,R4\n         CLC   CSV_LENGTH,=F'24'    At least 24 bytes!!!\n         BNH   COBANAL_06            prevent S0C4\n         CLC   CEE_EYECATCHER,C_COBOL370   COBOL/370 ?  X'00C3C5C5'\n         BE    COBOL_370\n         CLC   CEE_EYECATCHER,C_OPLINK     C         ?  X'01C3C5C5'\n         BE    C_370\n         USING COBOL_2_DSECT,R4\n         CLC   C2_EYECATCHER,=CL4' C2 '     COBOL/2 ?  X'40C3F240'\n         BE    COBOL_2\n         USING COBOL_1_DSECT,R4\n* ???    CLC   C1_EYECATCHER,=CL2'AN'       ANS4 COBOL ?\n* ???    BE    COBOL_1\n         CLC   C1_EYECATCHER(4),=CL4'VSR1'       OS/VS COBOL/1 ?\n         BE    COBOL_1\n         CLC   C1_EYECATCHER(4),=CL4'VSR2'       OS/VS COBOL/1 ?\n         BE    COBOL_1\nCOBANAL_06 DS  0H\n         STRING 'Can not established the program_language',INTO=RECORD\n         BAL   R14,SPACE1\n         MVC   RETCODE,=F'8'\n         B     COBANAL_EXIT         no, leave\nCOBANAL_08 DS  0H\n         STRING 'Program=',PGMNAME_GET,' seems to be LE but',          X\n               ' PPA1 looks invalid',INTO=RECORD\n         BAL   R14,SPACE1\n         MVC   RETCODE,=F'8'\n         B     COBANAL_EXIT         no, leave\nCOBANAL_09 DS  0H\n         CLI   0(R2),X'03'          ID = C       (03) ?\n         BNE   COBANAL_10             no check Assembler\n         STRING 'Program=',PGMNAME_GET,' is a C-Program ',INTO=RECORD\n         BAL   R14,SPACE1\n         MVC   RETCODE,=F'8'\n         B     COBANAL_EXIT         no, leave\nCOBANAL_10 DS  0H\n         CLI   0(R2),X'0F'          ID = Assembler (15) ?\n         BNE   COBANAL_06             no, unknown language\n         STRING 'Program=',PGMNAME_GET,' is a LE-enabled ',            X\n               'Assembler',INTO=RECORD\n         BAL   R14,SPACE1\n         MVC   RETCODE,=F'8'\n         B     COBANAL_EXIT         no, leave\nCOBANAL_PARM_ERROR DS  0H\n         STRING 'Error parm statement, check it',INTO=RECORD\n         BAL   R14,SPACE1\n         MVC   RETCODE,=F'12'\n         B     COBANAL_EXIT         no, leave\nCOBANAL_LOAD_ERROR DS  0H\n         STRING 'Error during load of program=',PGMNAME_GET,           X\n               INTO=RECORD\n         BAL   R14,SPACE1\n         MVC   RETCODE,=F'12'\n         B     COBANAL_EXIT         no, leave\nCOBANAL_CSV_ERROR DS  0H\n         STRING 'CSVQUERY failed, RC=',((R2),,L),INTO=RECORD\n         BAL   R14,SPACE1\n         MVC   RETCODE,=F'12'\n         B     COBANAL_EXIT         no, leave\nCOBANAL_EXIT       DS 0H\n         DELETE EPLOC=PGMNAME_GET   Delete the pgm\n         CLI   DOALL,C'N'           Default\n         BE    COBANAL_FIN\n         CLI   DOALL,C'X'           Exclude with wildcards?\n         BE    COBANAL_EXIT_1         No leave\n         CLC   PGMNAME_GET,XFF      Last Program?\n         BNE   COBANAL_022            no loop\n         B     COBANAL_FIN          finish\nCOBANAL_EXIT_1     DS 0H\n         CLC   PGMNAME_GET,XFF      Last Program?\n         BNE   COBANAL_028           no loop\nCOBANAL_FIN        DS 0H\n         LA    R9,SYSPRINT\n         USING IHADCB,R9\n         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN Is it OPEN?\n         BNO   COBANAL_FIN_1              No, ignore it\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE\n         CLOSE ((R9)),MF=(E,PARMLIST)      Close it\n         DROP  R9\nCOBANAL_FIN_1      DS 0H\n         LA    R9,INPUT\n         USING IHADCB,R9\n         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN Is it OPEN?\n         BNO   COBANAL_FIN_2              No, ignore it\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE\n         CLOSE ((R9)),MF=(E,PARMLIST)      Close it\n         DROP  R9\nCOBANAL_FIN_2      DS 0H\n         LA    R0,COBANAL_WORK_LENGTH\n         STORAGE RELEASE,              free Storage                    *\n               LENGTH=(R0),            Length                          *\n               ADDR=((R11))\n         L     R15,RETCODE\n         PR\n*============================================================*\n*    C/370 Program OPLINK Bit on !!!!!                       *\n*    Offset instead of relative pointer!!!                   *\n*============================================================*\nC_370    DS 0H\n         LR    R2,R4\n         A     R2,12(,R4)          PPA1\n         CLI   1(R2),X'CE'         Check PPA1\n         BNE   COBANAL_08            seems invalid PPA1\n         A     R4,4(,R2)           PPA2 pointer\n         LR    R2,R4\n         B     COBANAL_09          check languages\n*============================================================*\n*    COBOL/370 Program                                       *\n*============================================================*\nCOBOL_370 DS 0H\n         USING COBOL_370_DSECT,R4\n         LR    R2,R4\n         A     R2,12(,R4)          PPA1\n         CLI   1(R2),X'CE'         Check PPA1\n         BNE   COBANAL_08            seems invalid PPA1\n         ICM   R2,B'1111',4(R2)    PPA2 pointer\n         BZ    COBANAL_08            seems invalid PPA2\n         CLI   0(R2),X'05'         ID = Cobol!! (15)\n         BNE   COBANAL_09            no, error\n         MVI   LE_SWITCH,C'1'\n         L     R4,CEE_PRI_EP_ADDRESS\n         MVC   LE_VERS,CEE_VERS\n         MVC   LE_REL,CEE_REL\n         MVC   LE_MOD,CEE_MOD\n         MVC   LE_CCSID,CEE_CCSID\n         MVC   LE_PGM_NAME,CEE_PGM_NAME\n         MVC   LE_COMP_DAY,CEE_COMP_DAY\n         MVC   LE_COMP_MONTH,CEE_COMP_MONTH\n         MVC   LE_COMP_YEAR,CEE_COMP_YEAR\n         MVC   LE_COMP_HOURS,CEE_COMP_HOURS\n         MVC   LE_COMP_MIN,CEE_COMP_MIN\n         MVC   LE_COMP_SEC,CEE_COMP_SEC\n         MVC   LE_DATA_STATEMENTS,CEE_DATA_STATEMENTS\n         MVC   LE_PROC_LINES,CEE_PROC_LINES\n         MVC   LE_YEAR_WINDOW,CEE_YEAR_WINDOW\n         MVC   LE_STATUS_BYTE_01,CEE_STATUS_BYTE_01\n         MVC   LE_STATUS_BYTE_02,CEE_STATUS_BYTE_02\n         MVC   LE_STATUS_BYTE_03,CEE_STATUS_BYTE_03\n         MVC   LE_STATUS_BYTE_04,CEE_STATUS_BYTE_04\n         MVC   LE_STATUS_BYTE_05,CEE_STATUS_BYTE_05\n         MVC   LE_STATUS_BYTE_06,CEE_STATUS_BYTE_06\n         MVC   LE_STATUS_BYTE_07,CEE_STATUS_BYTE_07\n         MVC   LE_STATUS_BYTE_08,CEE_STATUS_BYTE_08\n         MVC   LE_STATUS_BYTE_09,CEE_STATUS_BYTE_09\n         MVC   LE_STATUS_BYTE_10,CEE_STATUS_BYTE_10\n         MVC   LE_STATUS_BYTE_11,CEE_STATUS_BYTE_11\n         MVC   LE_STATUS_BYTE_12,CEE_STATUS_BYTE_12\n         MVC   LE_STATUS_BYTE_13,CEE_STATUS_BYTE_13\n         MVC   LE_STATUS_BYTE_14,CEE_STATUS_BYTE_14\n         MVC   LE_STATUS_BYTE_15,CEE_STATUS_BYTE_15\n         MVC   LE_STATUS_BYTE_16,CEE_STATUS_BYTE_16\n         MVC   LE_STATUS_BYTE_17,CEE_STATUS_BYTE_17\n         MVC   LE_STATUS_BYTE_18,CEE_STATUS_BYTE_18\n         MVC   LE_STATUS_BYTE_19,CEE_STATUS_BYTE_19\n         MVC   LE_STATUS_BYTE_20,CEE_STATUS_BYTE_20\n         MVC   LE_STATUS_BYTE_21,CEE_STATUS_BYTE_21\n         MVC   LE_STATUS_BYTE_22,CEE_STATUS_BYTE_22\n         MVC   LE_STATUS_BYTE_23,CEE_STATUS_BYTE_23\n         MVC   LE_STATUS_BYTE_24,CEE_STATUS_BYTE_24\n         MVC   LE_STATUS_BYTE_25,CEE_STATUS_BYTE_25\n         MVC   LE_STATUS_BYTE_26,CEE_STATUS_BYTE_26\n         MVC   LE_STATUS_BYTE_27,CEE_STATUS_BYTE_27\n         MVC   LE_STATUS_BYTE_28,CEE_STATUS_BYTE_28\n         MVC   LE_STATUS_BYTE_29,CEE_STATUS_BYTE_29\n         B     LE370_INFO\n*============================================================*\n*    COBOL/2 Program                                         *\n*============================================================*\nCOBOL_2 DS 0H\n         USING COBOL_2_DSECT,R4\n         MVI   LE_SWITCH,C'2'\n         L     R4,C2_GET_ENTRY\n         L     R4,0(R4)\n         MVC   LE_VERS,C2_VERS\n         MVC   LE_REL,C2_REL\n         MVC   LE_MOD,C2_MOD\n         MVC   LE_PGM_NAME,C2_PGM_NAME\n         MVC   LE_COMP_DAY,C2_COMP_DAY\n         MVC   LE_COMP_MONTH,C2_COMP_MONTH\n         MVC   LE_COMP_YEAR(2),=C'??'    COBOL2 not Y2K ready\n         MVC   LE_COMP_YEAR+2(2),C2_COMP_YEAR\n         MVC   LE_COMP_HOURS,C2_COMP_HOURS\n         MVC   LE_COMP_MIN,C2_COMP_MIN\n         MVC   LE_COMP_SEC,C2_COMP_SEC\n         MVC   LE_DATA_STATEMENTS,C2_DATA_STATEMENTS\n         MVC   LE_PROC_LINES,C2_PROC_LINES\n         MVC   LE_STATUS_BYTE_01,C2_STATUS_BYTE_01\n         MVC   LE_STATUS_BYTE_02,C2_STATUS_BYTE_02\n         MVC   LE_STATUS_BYTE_03,C2_STATUS_BYTE_03\n         MVC   LE_STATUS_BYTE_04,C2_STATUS_BYTE_04\n         MVC   LE_STATUS_BYTE_05,C2_STATUS_BYTE_05\n         MVC   LE_STATUS_BYTE_06,C2_STATUS_BYTE_06\n         MVC   LE_STATUS_BYTE_07,C2_STATUS_BYTE_07\n         MVC   LE_STATUS_BYTE_08,C2_STATUS_BYTE_08\n         MVC   LE_STATUS_BYTE_09,C2_STATUS_BYTE_09\n         MVC   LE_STATUS_BYTE_10,C2_STATUS_BYTE_10\n         MVC   LE_STATUS_BYTE_11,C2_STATUS_BYTE_11\n         MVC   LE_STATUS_BYTE_12,C2_STATUS_BYTE_12\n         MVC   LE_STATUS_BYTE_13,C2_STATUS_BYTE_13\n         MVC   LE_STATUS_BYTE_14,C2_STATUS_BYTE_14\n         MVC   LE_STATUS_BYTE_15,C2_STATUS_BYTE_15\n         MVC   LE_STATUS_BYTE_16,C2_STATUS_BYTE_16\n         MVC   LE_STATUS_BYTE_17,C2_STATUS_BYTE_17\n         MVC   LE_STATUS_BYTE_18,C2_STATUS_BYTE_18\n         MVC   LE_STATUS_BYTE_19,C2_STATUS_BYTE_19\n         MVC   LE_STATUS_BYTE_20,C2_STATUS_BYTE_20\n         MVC   LE_STATUS_BYTE_21,C2_STATUS_BYTE_21\n         MVC   LE_STATUS_BYTE_22,C2_STATUS_BYTE_22\n         MVC   LE_STATUS_BYTE_23,C2_STATUS_BYTE_23\n         MVC   LE_STATUS_BYTE_24,C2_STATUS_BYTE_24\n         MVC   LE_STATUS_BYTE_25,C2_STATUS_BYTE_25\n         B     LE370_INFO\n*============================================================*\n* OS/VS COBOL   Program                                      *\n*============================================================*\nCOBOL_1 DS 0H\n         USING COBOL_1_DSECT,R4\n         MVI   LE_SWITCH,C'3'\n         MVC   LE_VERS,BLANKS\n         MVC   LE_REL,C1_REL\n         MVC   LE_MOD,BLANKS\n         MVC   LE_PGM_NAME,C1_PGM_NAME\n         MVC   LE_COMP_DAY,C1_COMP_DAY\n         MVC   LE_COMP_MONTH,C1_COMP_MONTH\n         MVC   LE_COMP_YEAR,C1_COMP_YEAR\n         MVC   LE_COMP_HOURS,C1_COMP_HOURS\n         MVC   LE_COMP_MIN,C1_COMP_MIN\n         MVC   LE_COMP_SEC,C1_COMP_SEC\n         L     R5,C1_TGT_PTR\n         USING COBOL_1_TGT,R5\n         CLC   C1_CHECK,=CL8'SYSOUT'     check\n         BE    LE370_INFO\n*\n*        UNABLE TO FIND THE TASK GLOBAL TABLE  -\n*\nNOTTGT   DS    0H\n         STRING 'Program ',PGMNAME_GET,' failed the TGT (Task Global', @\n               'Table) test',INTO=RECORD\n         BAL   R14,SPACE2\n         LA    R15,8\n         B     COBANAL_EXIT\nLE370_INFO DS  0H\n         STRING '============ Info ==================================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         CLI   LE_SWITCH,C'1'\n         BNE   JUMP_AROUND_1\n         STRING 'Program: ',PGMNAME_GET,' is COBOL/370 Version ',      X, *\n               LE_VERS,                                                X\n               ' Release ',LE_REL,' Mod-Level ',LE_MOD,INTO=RECORD\n         CLC   LE_VERS(4),=C'0301'  Vers+Rel < 0301 COBOL V3R1\n         BL    JUMP_AROUND_2         yes\n         STRING 'Program: ',PGMNAME_GET,' is COBOL Enterprise',        X, *\n               ' Version ',LE_VERS,                                    X\n               ' Release ',LE_REL,' Mod-Level ',LE_MOD,INTO=RECORD\n         B     JUMP_AROUND_2\nJUMP_AROUND_1 DS 0H\n         STRING 'Program: ',PGMNAME_GET,' is COBOL/2 Version ',LE_VERS,X*\n               ' Release ',LE_REL,' Mod-Level ',LE_MOD,INTO=RECORD\n         CLI   LE_SWITCH,C'2'\n         BE    JUMP_AROUND_2\n         STRING 'Program: ',PGMNAME_GET,' is OS/VS COBOL Release ',    XL, *\n               LE_REL,                                                 X\n               INTO=RECORD\nJUMP_AROUND_2 DS 0H\n         BAL   R14,SPACE2\n         STRING '============ Timestamps ============================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         STRING 'Compiled program name ',LE_PGM_NAME,INTO=RECORD\n         BAL   R14,SPACE1\n         BAL   R9,LE_370_12\n         DC    CL2'01',CL3'Jan'      Long name\n         DC    CL2'02',CL3'Feb'      for our non-european user\n         DC    CL2'03',CL3'Mar'\n         DC    CL2'04',CL3'Apr'\n         DC    CL2'05',CL3'May'\n         DC    CL2'06',CL3'Jun'\n         DC    CL2'07',CL3'Jul'\n         DC    CL2'08',CL3'Aug'\n         DC    CL2'09',CL3'Sep'\n         DC    CL2'10',CL3'Okt'\n         DC    CL2'11',CL3'Nov'\n         DC    CL2'12',CL3'Dec'\n         DC    X'0000',CL3'n/a'             end of table\nLE_370_12 DS   0H\n         CLC   LE_COMP_MONTH(2),0(R9)         check properties\n         BE    LE_370_14               jump if on\n         LA    R9,5(,R9)              Skip entry\n         CLI   0(R9),0                 end of table?\n         BNE   LE_370_12               not yet, loop\nLE_370_14 DS   0H\n         STRING 'Date: ',LE_COMP_DAY,'.',(LE_COMP_MONTH,2),'.',        *\n               LE_COMP_YEAR,' (european) ',LE_COMP_DAY,'.',            *\n               (2(R9),3,T),'.',LE_COMP_YEAR,' (long) ',                *\n               ' Time: ',LE_COMP_HOURS,':',LE_COMP_MIN,                *\n               ':',LE_COMP_SEC,INTO=RECORD\n         CLI   LE_SWITCH,C'3'    OS/VS COBOL ?\n         BNE   JUMP_AROUND_3       no, go ahead\n         STRING 'Date: ',LE_COMP_DAY,'.',LE_COMP_MONTH,'.',            *\n               LE_COMP_YEAR,' Time: ',LE_COMP_HOURS,':',LE_COMP_MIN,   *\n               ':',LE_COMP_SEC,INTO=RECORD\n         BAL   R14,SPACE2\n         B     INFO_COBOL            sorry no more information\nJUMP_AROUND_3 DS 0H\n         BAL   R14,SPACE2\n         STRING '============ Statistics ============================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         STRING 'Number of data items  : ',(LE_DATA_STATEMENTS,F,R7B), *\n               INTO=RECORD\n         BAL   R14,SPACE1\n         STRING 'Number of instructions: ',(LE_PROC_LINES,F,R7B),      *\n               INTO=RECORD\n         BAL   R14,SPACE2\n         STRING '============ Options in effect =====================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         MVC   RECORD,BLANKS\n         LA    R15,RECORD\n         MVC   1(3,R15),=C'ADV'\n         TM    LE_STATUS_BYTE_01,BIT0\n         BO    *+10\n         MVC   1(5,R15),=C'NOADV'\n         LA    R15,8(R15)\n         MVC   0(5,R15),=C'APOST'\n         TM    LE_STATUS_BYTE_01,BIT1\n         BO    *+10\n         MVC   0(5,R15),=C'QUOTE'\n         LA    R15,8(R15)\n         MVC   RECORD+16(9),=CL9'DATA(31)'\n         TM    LE_STATUS_BYTE_01,BIT2\n         BO    *+10\n         MVC   RECORD+16(9),=CL9'DATA(24)'\n         MVC   RECORD+25(6),=CL6'DECK'\n         TM    LE_STATUS_BYTE_01,BIT3\n         BO    *+10\n         MVC   RECORD+25(6),=CL6'NODECK'\n         MVC   RECORD+33(6),=CL6'DUMP'\n         TM    LE_STATUS_BYTE_01,BIT4\n         BO    *+10\n         MVC   RECORD+33(6),=CL6'NODUMP'\n         MVC   RECORD+40(8),=CL8'DYNAM'\n         TM    LE_STATUS_BYTE_01,BIT5\n         BO    *+10\n         MVC   RECORD+40(8),=CL8'NODYNAM'\n         MVC   RECORD+51(10),=CL10'FASTSRT'\n         TM    LE_STATUS_BYTE_01,BIT6\n         BO    *+10\n         MVC   RECORD+51(10),=CL10'NOFASTSRT'\n         MVC   RECORD+62(8),=CL8'FDUMP'\n         TM    LE_STATUS_BYTE_01,BIT7\n         BO    *+10\n         MVC   RECORD+62(8),=CL8'NOFDUMP'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(6),=CL6'LIB'\n         TM    LE_STATUS_BYTE_02,BIT0\n         BO    *+10\n         MVC   RECORD+1(6),=CL6'NOLIB'\n         MVC   RECORD+8(7),=CL7'LIST'\n         TM    LE_STATUS_BYTE_02,BIT1\n         BO    *+10\n         MVC   RECORD+8(7),=CL7'NOLIST'\n         MVC   RECORD+16(9),=CL9'MAP'\n         TM    LE_STATUS_BYTE_02,BIT2\n         BO    *+10\n         MVC   RECORD+16(9),=CL9'NOMAP'\n         MVC   RECORD+25(6),=CL6'NUM'\n         TM    LE_STATUS_BYTE_02,BIT3\n         BO    *+10\n         MVC   RECORD+25(6),=CL6'NONUM'\n         MVC   RECORD+33(6),=CL6'OBJ'\n         TM    LE_STATUS_BYTE_02,BIT4\n         BO    *+10\n         MVC   RECORD+33(6),=CL6'NOOBJ'\n         MVC   RECORD+40(8),=CL8'OFFSET'\n         TM    LE_STATUS_BYTE_02,BIT5\n         BO    *+10\n         MVC   RECORD+40(8),=CL8'NOOFFSET'\n         MVC   RECORD+51(10),=CL10'OPTIMIZE'\n         TM    LE_STATUS_BYTE_02,BIT6\n         BO    *+10\n         MVC   RECORD+51(10),=CL10'NOOPTIMIZE'\n         CLI   LE_SWITCH,C'1'   COBOL/370\n         BNE   LE_370_18\n         CLC   LE_VERS(4),=C'0301'  Vers+Rel < 0301 COBOL V3R1\n         BL    LE_370_18             yes\n         MVC   RECORD+62(18),=CL18'OUTDD(SYSOUT)'\n         TM    LE_STATUS_BYTE_02,BIT7\n         BO    *+10\n         MVC   RECORD+62(18),=CL18'OUTDD(Supplied)'\n         BAL   R14,SPACE1\n         B     LE_370_19\nLE_370_18 DS 0H\n         MVC   RECORD+62(17),=CL17'OUTDD(Default)'\n         TM    LE_STATUS_BYTE_02,BIT7\n         BO    *+10\n         MVC   RECORD+62(17),=CL17'OUTDD(Supplied)'\n         BAL   R14,SPACE1\nLE_370_19 DS 0H\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(15),=CL15'NUMPROC(MIG)'\n         TM    LE_STATUS_BYTE_05,BIT0\n         BO    LE_370_21\n         MVC   RECORD+1(15),=CL15'NUMPROC(PFD)'\n         TM    LE_STATUS_BYTE_03,BIT0\n         BO    *+10\n         MVC   RECORD+1(15),=CL15'NUMPROC(NOPFD)'\nLE_370_21 DS 0H\n         MVC   RECORD+16(7),=CL7'RENT'\n         TM    LE_STATUS_BYTE_03,BIT1\n         BO    *+10\n         MVC   RECORD+16(7),=CL7'NORENT'\n         MVC   RECORD+25(6),=CL6'RES'\n         TM    LE_STATUS_BYTE_03,BIT2\n         BO    *+10\n         MVC   RECORD+25(6),=CL6'NORES'\n         MVC   RECORD+33(6),=CL6'SEQ'\n         TM    LE_STATUS_BYTE_03,BIT3\n         BO    *+10\n         MVC   RECORD+33(6),=CL6'NOSEQ'\n         MVC   RECORD+40(12),=CL12'SIZE(MAX)'\n         TM    LE_STATUS_BYTE_03,BIT4\n         BO    *+10\n         MVC   RECORD+40(12),=CL12'SIZE(value)'\n         MVC   RECORD+51(9),=CL9'SOURCE'\n         TM    LE_STATUS_BYTE_03,BIT5\n         BO    *+10\n         MVC   RECORD+51(9),=CL9'NOSOURCE'\n         MVC   RECORD+62(10),=CL10'SSRANGE'\n         TM    LE_STATUS_BYTE_03,BIT6\n         BO    *+10\n         MVC   RECORD+62(10),=CL10'NOSSRANGE'\n         MVC   RECORD+72(8),=CL8'TERM'\n         TM    LE_STATUS_BYTE_03,BIT7\n         BO    *+10\n         MVC   RECORD+72(8),=CL8'NOTERM'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(8),=CL8'TEST'\n         TM    LE_STATUS_BYTE_04,BIT0\n         BO    *+10\n         MVC   RECORD+1(8),=CL8'NOTEST'\n         MVC   RECORD+8(10),=CL11'TRUNC(BIN)'\n         TM    LE_STATUS_BYTE_05,BIT4\n         BO    LE_370_33\n         MVC   RECORD+8(10),=CL11'TRUNC(STD)'\n         TM    LE_STATUS_BYTE_04,BIT1\n         BO    *+10\n         MVC   RECORD+8(10),=CL11'TRUNC(OPT)'\nLE_370_33 DS 0H\n         MVC   RECORD+25(9),=CL9'WORD(xx)'\n         TM    LE_STATUS_BYTE_04,BIT2\n         BO    *+10\n         MVC   RECORD+25(9),=CL9'NOWORD'                                t'\n         MVC   RECORD+33(8),=CL8'VBREF'\n         TM    LE_STATUS_BYTE_04,BIT3\n         BO    *+10\n         MVC   RECORD+33(8),=CL8'NOVBREF'\n         MVC   RECORD+40(6),=CL6'XREF'\n         TM    LE_STATUS_BYTE_04,BIT4\n         BO    *+10\n         MVC   RECORD+40(6),=CL6'NOXREF'\n         MVC   RECORD+51(6),=CL6'ZWB'\n         TM    LE_STATUS_BYTE_04,BIT5\n         BO    *+10\n         MVC   RECORD+51(6),=CL6'NOZWB'\n         MVC   RECORD+62(7),=CL7'NAME'\n         TM    LE_STATUS_BYTE_04,BIT6\n         BO    *+10\n         MVC   RECORD+62(7),=CL7'NONAME'\n         MVC   RECORD+72(8),=CL8'CMPR2'\n         TM    LE_STATUS_BYTE_04,BIT7\n         BO    *+10\n         MVC   RECORD+72(8),=CL8'NOCMPR2'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(12),=CL12'NUMCLS'  other Cobol\n         TM    LE_STATUS_BYTE_05,BIT1\n         BO    *+10\n         MVC   RECORD+1(12),=CL12'NONUMCLS'\n         CLI   LE_SWITCH,C'1'   COBOL/370\n         BNE   LE_370_42\n         CLC   LE_VERS(4),=C'0102'  Vers+Rel < 0102 COBOL MVS and VM\n         BL    LE_370_42             yes\n         MVC   RECORD+1(12),=CL12'NUMCLS(ALT)'\n         TM    LE_STATUS_BYTE_05,BIT1\n         BO    *+10\n         MVC   RECORD+1(12),=CL12'NUMCLS(PRIM)'\nLE_370_42 DS 0H\n         MVC   RECORD+16(7),=CL7'DBCS'\n         TM    LE_STATUS_BYTE_05,BIT2\n         BO    *+10\n         MVC   RECORD+16(7),=CL7'NODBCS'\n         MVC   RECORD+25(6),=CL6'AWO'\n         TM    LE_STATUS_BYTE_05,BIT3\n         BO    *+10\n         MVC   RECORD+25(6),=CL6'NOAWO'\n         CLI   LE_SWITCH,C'1'                  Cobol/370\n         BNE   LE_370_48                       no, jump around\n         MVC   RECORD+33(9),=CL9'EVENTS'       n/a COBOL/2\n         TM    LE_STATUS_BYTE_05,BIT5\n         BO    *+10\n         MVC   RECORD+33(9),=CL9'NOEVENTS'\n         MVC   RECORD+51(11),=CL11'CURRENCY'   n/a COBOL/2\n         TM    LE_STATUS_BYTE_05,BIT6\n         BO    *+10\n         MVC   RECORD+51(11),=CL11'NOCURRENCY'\nLE_370_48 DS 0H\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(40),=CL40'Compilation unit = Class'\n         TM    LE_STATUS_BYTE_05,BIT7\n         BO    *+10\n         MVC   RECORD+1(40),=CL40'Compilation unit = Program'\n         CLI   LE_SWITCH,C'1'   COBOL/370 ?\n         BNE   LE_370_50Z         no\n         CLC   LE_VERS(4),=C'0102'  Vers+Rel < 0102 COBOL MVS and VM\n         BL    LE_370_50Z         no\n*                         Supported only for COBOL MVS and VM R2\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(11),=CL11'RMODE(ANY)'\n         TM    LE_STATUS_BYTE_26,BIT0\n         BO    *+10\n         MVC   RECORD+1(11),=CL11'RMODE(24)'\n         MVC   RECORD+16(13),=CL13'TEST(STMT)'\n         TM    LE_STATUS_BYTE_26,BIT1\n         BO    *+10\n         MVC   RECORD+16(13),=CL13'NO TEST(STMT)'\n         MVC   RECORD+33(13),=CL13'TEST(PATH)'\n         TM    LE_STATUS_BYTE_26,BIT2\n         BO    *+10\n         MVC   RECORD+33(13),=CL13'NO TEST(PATH)'\n         MVC   RECORD+51(14),=CL14'TEST(BLOCK)'\n         TM    LE_STATUS_BYTE_26,BIT3\n         BO    *+10\n         MVC   RECORD+51(14),=CL14'NO TEST(BLOCK)'\n         MVC   RECORD+72(17),=CL17'OPT(FULL)'\n         TM    LE_STATUS_BYTE_26,BIT4\n         BO    *+10\n         MVC   RECORD+72(17),=CL17'NOOPT OR OPT(STD)'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(13),=CL13'INTDATE(LIL)'\n         TM    LE_STATUS_BYTE_26,BIT5\n         BO    *+10\n         MVC   RECORD+1(13),=CL13'INTDATE(ANSI)'\n         MVC   RECORD+16(3),=CL3'N/A'                            RS1000\n         CLC   LE_VERS(4),=C'0202'  Vers+Rel < 0202 COBOL MVS and VM\n         BL    LE_370_50Y           no lower                     RS1000\n         MVC   RECORD+16(14),=CL14'TEST(SEPARATE)'               RS1000\n         TM    LE_STATUS_BYTE_26,BIT6                            RS1000\n         BO    *+10                                              RS1000\n         MVC   RECORD+16(17),=CL17'NO TEST(SEPARATE)'            RS1000\nLE_370_50Y DS  0H\n         MVC   RECORD+35(22),=CL22'PGMNAME(LONGUPPER)'\n         TM    LE_STATUS_BYTE_27,BIT0\n         BO    *+10\n         MVC   RECORD+35(22),=CL22'NOT PGMNAME(LONGUPPER)'\n         MVC   RECORD+60(22),=CL22'PGMNAME(LONGMIXED)'\n         TM    LE_STATUS_BYTE_27,BIT1\n         BO    *+10\n         MVC   RECORD+60(22),=CL22'NOT PGMNAME(LONGMIXED)'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(5),=CL5'DLL'\n         TM    LE_STATUS_BYTE_27,BIT2\n         BO    *+10\n         MVC   RECORD+1(5),=CL5'NODLL'\n         MVC   RECORD+16(11),=CL11'EXPORTALL'\n         TM    LE_STATUS_BYTE_27,BIT3\n         BO    *+10\n         MVC   RECORD+16(11),=CL11'NOEXPORTALL'\n         MVC   RECORD+33(10),=CL10'DATEPROC'\n         TM    LE_STATUS_BYTE_27,BIT4\n         BO    *+10\n         MVC   RECORD+33(10),=CL10'NODATEPROC'\n         STRING (RECORD,,L),1X,'YEARWINDOW(',(LE_YEAR_WINDOW,H,R4B),   *\n               ')',INTO=RECORD\n         CLC   LE_VERS(4),=C'0202'  Vers+Rel < 0202 COBOL MVS and VM\n         BL    LE_370_50Z           no lower                     RS1000\n         MVC   RECORD+62(13),=CL13'ARITH(EXTEND)'                RS1000\n         TM    LE_STATUS_BYTE_27,BIT5                            RS1000\n         BO    *+10                                              RS1000\n         MVC   RECORD+62(13),=CL13'ARITH(COMPAT)'                RS1000\n         CLI   LE_SWITCH,C'1'   COBOL/370\n         BNE   LE_370_50Z\n         CLC   LE_VERS(4),=C'0301'  Vers+Rel < 0301 COBOL V3R1\n         BL    LE_370_50Z            yes\n         MVC   RECORD+76(11),=CL11'THREAD(YES)'\n         TM    LE_STATUS_BYTE_27,BIT6\n         BO    *+10\n         MVC   RECORD+76(11),=CL11'THREAD(NO)'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         STRING (RECORD,,L),1X,'CODEPAGE(',(LE_CCSID,H,R4B),')',       X\n               INTO=RECORD\nLE_370_50Z DS 0H\n         BAL   R14,SPACE2\n         STRING '============ Additional information ================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE1\n         STRING '============ about DATA DIVISION    ================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         STRING 'Program use',' no',' QSAM or SAM access method',      *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT0\n         BNO   LE_370_51\n         STRING 'Program use',' QSAM or SAM access method',INTO=RECORD\nLE_370_51 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program use',' no',' VSAM sequential files',          *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT1\n         BNO   LE_370_52\n         STRING 'Program use',' VSAM sequential files',INTO=RECORD\nLE_370_52 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program use',' no',' VSAM indexed files',INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT2\n         BNO   LE_370_53\n         STRING 'Program use',' VSAM indexed files',INTO=RECORD\nLE_370_53 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program use',' no',' VSAM RBA files',INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT3\n         BNO   LE_370_54\n         STRING 'Program use',' VSAM RBA files',INTO=RECORD\nLE_370_54 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program use',' no',' CODE-SET (ASCII files)',         *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT4\n         BNO   LE_370_55\n         STRING 'Program use',' CODE-SET (ASCII files)',INTO=RECORD\nLE_370_55 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program use',' no',' spanned records',INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT5\n         BNO   LE_370_56\n         STRING 'Program use',' spanned records',INTO=RECORD\nLE_370_56 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' picture G (DBCS) items',         *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT6\n         BNO   LE_370_57\n         STRING 'Program has',' picture G (DBCS) items',INTO=RECORD\nLE_370_57 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' OCCURS DEPENDING ON items',      *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT7\n         BNO   LE_370_58\n         STRING 'Program has',' OCCURS DEPENDING ON items',INTO=RECORD\nLE_370_58 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' SYNCHRONIZED clause',INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT0\n         BNO   LE_370_59\n         STRING 'Program has',' SYNCHRONIZED clause',INTO=RECORD\nLE_370_59 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' JUSTIFIED clause',INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT1\n         BNO   LE_370_60\n         STRING 'Program has',' JUSTIFIED clause',INTO=RECORD\nLE_370_60 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' POINTER items',INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT2\n         BNO   LE_370_61\n         STRING 'Program has',' POINTER items',INTO=RECORD\nLE_370_61 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' complex ODO clause',INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT3\n         BNO   LE_370_62\n         STRING 'Program has',' complex ODO clause',INTO=RECORD\nLE_370_62 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' external',                       *\n               ' floating-point items',                                *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT4\n         BNO   LE_370_63\n         STRING 'Program has',' external',' floating-point items',     *\n               INTO=RECORD\nLE_370_63 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' internal',                       *RD\n               ' floating-point items',                                *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT5\n         BNO   LE_370_63_1\n         STRING 'Program has',' internal',' floating-point items',     *\n               INTO=RECORD\nLE_370_63_1 DS 0H\n         CLI   LE_SWITCH,C'1'                  Cobol/370\n         BNE   LE_370_64                       no, jump around\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' Proc-Pointer or Func-Pointer ',  X\n               'items',INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT7\n         BNO   LE_370_63_2\n         STRING 'Program has',' Proc or Func-Pointer items',INTO=RECORD\nLE_370_63_2 DS 0H\n         CLC   LE_VERS(4),=C'0202'  Vers+Rel < 0202 COBOL MVS and VM\n         BL    LE_370_64            no lower                     RS1000\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' Line-sequential file',           *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT6\n         BNO   LE_370_64\n         STRING 'Program has',' Line-sequential file',                 *\n               INTO=RECORD\nLE_370_64 DS 0H\n         BAL   R14,SPACE2\n         STRING '============ Additional information    =============',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE1\n         STRING '============ about ENVIROMENT DIVISION =============',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         STRING 'Program use',' no',' FILE-STATUS clause',INTO=RECORD\n         TM    LE_STATUS_BYTE_08,BIT0\n         BNO   LE_370_66\n         STRING 'Program use',' FILE-STATUS clause',INTO=RECORD\nLE_370_66 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program use',' no',' RERUN clause in I/O-control',    *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_08,BIT1\n         BNO   LE_370_67\n         STRING 'Program has',' RERUN clause in I/O-control',          *\n               INTO=RECORD\nLE_370_67 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program use',' no',' UPSI switches',INTO=RECORD\n         TM    LE_STATUS_BYTE_08,BIT2\n         BNO   LE_370_68\n         STRING 'Program use',' UPSI switches',INTO=RECORD\nLE_370_68 DS 0H\n         BAL   R14,SPACE2\n         STRING '============ Additional information    =============',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE1\n         STRING '============ about PROCEDURE DIVISION  =============',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         STRING 'Following statements in control (check Y/N):',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(6),=CL6'Accept'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_09,BIT0\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(3),=CL3'Add'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_09,BIT1\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(5),=CL5'Alter'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_09,BIT2\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(4),=CL4'Call'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_09,BIT3\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(6),=CL6'Cancel'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_09,BIT4\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(5),=CL5'Close'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_09,BIT6\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(7),=CL7'Compute'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_10,BIT0\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(6),=CL6'Delete'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_10,BIT2\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(7),=CL7'Display'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_10,BIT4\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(6),=CL6'Divide'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_10,BIT5\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(11),=CL11'End-Perform'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_11,BIT1\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(5),=CL5'Enter'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_11,BIT2\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(5),=CL5'Entry'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_11,BIT3\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(4),=CL4'Exit'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_11,BIT4\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(5),=CL5'Go to'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_11,BIT6\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(2),=CL2'If'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_11,BIT7\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(10),=CL10'Initialize'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_12,BIT0\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         CLI   LE_SWITCH,C'1'   COBOL/370 ?\n         BNE   LE_370_70          no, jump around\n         MVC   RECORD+86(6),=CL6'Invoke'   comes with COBOL/370\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_12,BIT1\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\nLE_370_70 DS 0H\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(7),=CL7'Inspect'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_12,BIT2\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(5),=CL5'Merge'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_12,BIT3\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(4),=CL4'Move'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_12,BIT4\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(8),=CL8'Multiply'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_12,BIT5\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(4),=CL4'Open'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_12,BIT6\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(7),=CL7'Perform'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_12,BIT7\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(4),=CL4'Read'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_13,BIT0\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(7),=CL7'Release'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_13,BIT2\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(6),=CL6'Return'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_13,BIT3\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(7),=CL7'Rewrite'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_13,BIT4\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(6),=CL6'Search'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_13,BIT5\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(3),=CL3'Set'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_13,BIT7\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(4),=CL4'Sort'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_14,BIT0\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(5),=CL5'Start'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_14,BIT1\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(4),=CL4'Stop'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_14,BIT2\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(6),=CL6'String'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_14,BIT3\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(8),=CL8'Subtract'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_14,BIT4\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(8),=CL8'Unstring'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_14,BIT7\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(3),=CL3'Use'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_15,BIT0\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(5),=CL5'Write'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_15,BIT1\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(8),=CL8'Continue'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_15,BIT2\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(7),=CL7'End-Add'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_15,BIT3\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(8),=CL8'End-Call'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_15,BIT4\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(11),=CL11'End-Compute'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_15,BIT5\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(10),=CL10'End-Delete'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_15,BIT6\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(10),=CL10'End-Divide'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_15,BIT7\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(12),=CL12'End-Evaluate'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_16,BIT0\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(6),=CL6'End-If'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_16,BIT1\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(11),=CL11'End-Muliply'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_16,BIT2\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(8),=CL8'End-Read'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_16,BIT3\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(10),=CL10'End-Return'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_16,BIT4\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(11),=CL11'End-Rewrite'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_16,BIT5\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(10),=CL10'End-Search'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_16,BIT6\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(9),=CL9'End-Start'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_16,BIT7\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(10),=CL10'End-String'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_17,BIT0\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(12),=CL12'End-Subtract'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_17,BIT1\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(12),=CL12'End-Unstring'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_17,BIT2\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(9),=CL9'End-Write'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_17,BIT3\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(6),=CL6'Goback'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_17,BIT4\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(9),=CL9'Evaluate'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_17,BIT5\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(7),=CL7'Service'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_17,BIT7\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(10),=CL10'End-Invoke'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_18,BIT0\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         CLI   LE_SWITCH,C'1'   COBOL/370\n         BNE   LE_370_125\n         CLC   LE_VERS(4),=C'0301'  Vers+Rel < 0301 COBOL V3R1\n         BL    LE_370_125            yes\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(10),=CL10'Exec'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_11,BIT5\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(9),=CL9'End-Exec'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_18,BIT2\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(9),=CL9'End-Exec'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_18,BIT2\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(3),=CL3'XML'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_18,BIT3\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(3),=CL3'END-XML'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_18,BIT3\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         BAL   R14,SPACE1\nLE_370_125 DS 0H\n         STRING '====================================================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         STRING 'No hexadecimal literals',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT0\n         BNO   LE_370_128\n         STRING 'Procedure include hexadecimal literals',INTO=RECORD\nLE_370_128 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No altered GO TO',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT1\n         BNO   LE_370_129\n         STRING 'Program contains altered GO TO',INTO=RECORD\nLE_370_129 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','I/O error declarative',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT2\n         BNO   LE_370_130\n         STRING 'I/O error declarative',INTO=RECORD\nLE_370_130 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Label declarative',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT3\n         BNO   LE_370_131\n         STRING 'Label declarative',INTO=RECORD\nLE_370_131 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Debugging declarative',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT4\n         BNO   LE_370_132\n         STRING 'Debugging declarative',INTO=RECORD\nLE_370_132 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Program segmentation',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT5\n         BNO   LE_370_133\n         STRING 'Program segmentation',INTO=RECORD\nLE_370_133 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Open Extend',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT6\n         BNO   LE_370_134\n         STRING 'Open Extend',INTO=RECORD\nLE_370_134 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Exit Program',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT7\n         BNO   LE_370_135\n         STRING 'Exit Program',INTO=RECORD\nLE_370_135 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No call literal',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT0\n         BNO   LE_370_136\n         STRING 'Call literal (static?), see options',INTO=RECORD\nLE_370_136 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Call identifier',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT1\n         BNO   LE_370_137\n         STRING 'Call identifier',INTO=RECORD\nLE_370_137 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Call on overflow',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT2\n         BNO   LE_370_138\n         STRING 'Call on overflow',INTO=RECORD\nLE_370_138 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Call length of',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT3\n         BNO   LE_370_139\n         STRING 'Call length of',INTO=RECORD\nLE_370_139 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Call address of',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT4\n         BNO   LE_370_140\n         STRING 'Call address of',INTO=RECORD\nLE_370_140 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Close reel/unit',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT5\n         BNO   LE_370_141\n         STRING 'Close reel/unit',INTO=RECORD\nLE_370_141 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Exponentiation used',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT6\n         BNO   LE_370_142\n         STRING 'Exponentiation used',INTO=RECORD\nLE_370_142 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Floating point items used',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT7\n         BNO   LE_370_143\n         STRING 'Floating point items used',INTO=RECORD\nLE_370_143 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Copy-Statements',INTO=RECORD\n         TM    LE_STATUS_BYTE_23,BIT0\n         BNO   LE_370_144\n         STRING 'Copy-Statements',INTO=RECORD\nLE_370_144 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Basis-Statements',INTO=RECORD\n         TM    LE_STATUS_BYTE_23,BIT1\n         BNO   LE_370_145\n         STRING 'Basis-Statements',INTO=RECORD\nLE_370_145 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','DBCS-Name in Program',INTO=RECORD\n         TM    LE_STATUS_BYTE_23,BIT2\n         BNO   LE_370_146\n         STRING 'DBCS-Name in Program',INTO=RECORD\nLE_370_146 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Shift-In/Shift-Out',INTO=RECORD\n         TM    LE_STATUS_BYTE_23,BIT3\n         BNO   LE_370_147\n         STRING 'Shift-In/Shift-Out',INTO=RECORD\nLE_370_147 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','DBCS literal',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT0\n         BNO   LE_370_148\n         STRING 'DBCS literal',INTO=RECORD\nLE_370_148 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Replace-Statements',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT1\n         BNO   LE_370_149\n         STRING 'Replace-Statements',INTO=RECORD\nLE_370_149 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Reference modification was used',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT2\n         BNO   LE_370_150\n         STRING 'Reference modification was used',INTO=RECORD\nLE_370_150 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Nested Program',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT3\n         BNO   LE_370_151\n         STRING 'Nested Program',INTO=RECORD\nLE_370_151 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','INITIAL Program',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT4\n         BNO   LE_370_152\n         STRING 'INITIAL Program',INTO=RECORD\nLE_370_152 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','COMMON Program',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT5\n         BNO   LE_370_153\n         STRING 'COMMON Program',INTO=RECORD\nLE_370_153 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Select Optional Files',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT6\n         BNO   LE_370_154\n         STRING 'Select Optional Files',INTO=RECORD\nLE_370_154 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','External Files',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT7\n         BNO   LE_370_155\n         STRING 'External Files',INTO=RECORD\nLE_370_155 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Global Files',INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT0\n         BNO   LE_370_156\n         STRING 'Global Files',INTO=RECORD\nLE_370_156 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Record is varying clause',INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT1\n         BNO   LE_370_157\n         STRING 'Record is varying clause',INTO=RECORD\nLE_370_157 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Accept from SYSIPT used in Label Declarative',  *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT2\n         BNO   LE_370_158\n         STRING 'Accept from SYSIPT used in Label Declarative',        *\n               INTO=RECORD\nLE_370_158 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Display upon SYSLST used in Label Declarative', *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT3\n         BNO   LE_370_159\n         STRING 'Display upon SYSLST used in Label Declarative',       *\n               INTO=RECORD\nLE_370_159 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Display upon SYSPCH used in Label Declarative', *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT4\n         BNO   LE_370_160\n         STRING 'Display upon SYSPCH used in Label Declarative',       *\n               INTO=RECORD\nLE_370_160 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Intrinsic function was used',INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT5\n         BNO   LE_370_161\n         STRING 'Intrinsic function was used',INTO=RECORD\nLE_370_161 DS 0H\n         CLI   LE_SWITCH,C'1'   COBOL/370\n         BNE   LE_370_177\n         CLC   LE_VERS(4),=C'0301'  Vers+Rel < 0301 COBOL V3R1\n         BL    LE_370_177            yes\n         BAL   R14,SPACE1\n         STRING 'No ','Function Random was used',INTO=RECORD\n         TM    LE_STATUS_BYTE_29,BIT1\n         BNO   LE_370_162\n         STRING 'Function Random was used',INTO=RECORD\nLE_370_162 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Java-based OO syntax was used',INTO=RECORD\n         TM    LE_STATUS_BYTE_29,BIT0\n         BNO   LE_370_163\n         STRING 'Java-based OO syntax was used',INTO=RECORD\nLE_370_163 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','National data was used',INTO=RECORD\n         TM    LE_STATUS_BYTE_29,BIT0\n         BNO   LE_370_177\n         STRING 'National data was used',INTO=RECORD\nLE_370_177 DS 0H\n         BAL   R14,SPACE1\n         STRING '============ End  ==================================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         LA    R15,0\n         B     COBANAL_EXIT\nINFO_COBOL DS 0H\n         CLI   C1_OEM_MOD_AREA,X'00' low-value ?                 RS0700\n         BE    INFO_COBOL_OEM                                    RS0700\n         STRING '============ OEM Modified Area =====================',*\n               '=============================================',        *RD\n               INTO=RECORD                                       RS0700\n         BAL   R14,SPACE2                                        RS0700\n         STRING ' ',C1_OEM_MOD_AREA,INTO=RECORD                  RS0700\n         BAL   R14,SPACE2                                        RS0700\nINFO_COBOL_OEM DS 0H                                             RS0700\n         STRING '============ Options in effect =====================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(8),=CL8'SYMDMP'\n         TM    C1_STATUS_BYTE_01,X'08'\n         BO    *+10\n         MVC   RECORD+1(8),=CL8'NOSYMDMP'\n         MVC   RECORD+10(6),=CL6'FLOW'\n         TM    C1_STATUS_BYTE_01,X'04'\n         BO    *+10\n         MVC   RECORD+10(6),=CL6'NOFLOW'\n         MVC   RECORD+17(7),=CL7'STATE'\n         TM    C1_STATUS_BYTE_01,X'02'\n         BO    *+10\n         MVC   RECORD+17(7),=CL7'NOSTATE'\n         MVC   RECORD+25(6),=CL6'OPT'\n         TM    C1_STATUS_BYTE_01,X'01'\n         BO    *+10\n         MVC   RECORD+25(6),=CL6'NOOPT'\n         MVC   RECORD+32(6),=CL6'TEST'\n         TM    C1_STATUS_BYTE_02,X'10'\n         BO    *+10\n         MVC   RECORD+32(6),=CL6'NOTEST'\n         MVC   RECORD+39(6),=CL6'RES'\n         TM    C1_STATUS_BYTE_03,X'80'\n         BO    *+10\n         MVC   RECORD+39(6),=CL6'NORES'\n         MVC   RECORD+46(8),=CL8'ENDJOB'\n         TM    C1_STATUS_BYTE_03,X'40'\n         BO    *+10\n         MVC   RECORD+46(8),=CL8'NOENDJOB'\n         MVC   RECORD+55(8),=CL8'OBJ370'\n         TM    C1_STATUS_BYTE_03,X'20'\n         BO    *+10\n         MVC   RECORD+55(8),=CL8'NOOBJ370'\n         MVC   RECORD+64(8),=CL8'COUNT'\n         TM    C1_STATUS_BYTE_03,X'08'\n         BO    *+10\n         MVC   RECORD+64(8),=CL8'NOCOUNT'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(11),=CL11'READY TRACE'\n         TM    C1_STATUS_BYTE_03,X'04'\n         BO    *+10\n         MVC   RECORD+1(11),=CL11'NO TRACE'\n         BAL   R14,SPACE1\n         STRING 'Sorry no more infomation for OS/VS COBOL',INTO=RECORD\n         BAL   R14,SPACE1\n         STRING 'You better upgrade to COBOL for OS/390 (MVS) and VM', *\n               INTO=RECORD\n         BAL   R14,SPACE1\n         STRING '============ End  ==================================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         LA    R15,0\n         B     COBANAL_EXIT\n*============================================================*\n* Print                                                      *\n*============================================================*\nSPACE2   DS 0H\n         ST    R14,SAVER14\n         LA    R1,SYSPRINT         GET OUTPUT DCB ADDRESS\n         LA    R0,RECORD           GET OBJECT NAME ADDRESS\n         PUT   (1),(0)             WRITE NAME TO NOTIFY DATA SET\n         LA    R1,SYSPRINT         GET OUTPUT DCB ADDRESS\n         LA    R0,BLANKS           GET OBJECT NAME ADDRESS\n         BAS   R14,AMODE24             AMode24\n         PUT   (1),(0)             WRITE NAME TO NOTIFY DATA SET\n         BAS   R14,AMODE31             AMode31\n         L     R14,SAVER14\n         BR    R14            return\nSPACE1   DS 0H\n         ST    R14,SAVER14\n         LA    R1,SYSPRINT         GET OUTPUT DCB ADDRESS\n         LA    R0,RECORD           GET OBJECT NAME ADDRESS\n         BAS   R14,AMODE24             AMode24\n         PUT   (1),(0)             WRITE NAME TO NOTIFY DATA SET\n         BAS   R14,AMODE31             AMode31\n         L     R14,SAVER14\n         BR    R14            return\n***************************************************************\n*\n*                  get Member Name from PDS-Directory\n*\n***************************************************************\nGETMEM   EQU   *\n         ST    R14,GETMSAVE            save return address\n         L     R4,ADBLKPTR             restore pointer\n         CLC   DIRAREA(2),=XL2'0000'   Directory present?\n         BNE   NEWNAME                   yes, get next\nNEWBLOCK EQU   *\n         BAS   R14,AMODE24             Amode24\n         GET   INPUT,DIRAREA           get a new directory\n         BAS   R14,AMODE31             Amode24\n         LA    R4,DIRAREA              get work area address\n         AH    R4,DIRAREA              + length\n         ST    R4,ADBLKEND             save ending address\n         LA    R4,DIRAREA+2            Skip LL bytes\n         ST    R4,ADBLKPTR             save pointer\nNEWNAME  EQU   *\n         C     R4,ADBLKEND             end of current dir block\n         BNL   NEWBLOCK                  yes, get new block\n         MVC   PGMNAME_GET,0(R4)       Save member-name\n         IC    R5,11(R4)               LOOK FOR ANY USER TTRN'S\n         SLL   R5,27                   SHIFT OFF UNWANTED BITS\n         SRL   R5,26                   SHIFT BACK THE USABLE BI\n         LA    R4,12(R4,R5)            ADD DISPL TO GET OVER TT\n         ST    R4,ADBLKPTR             save Pointer next mem\n         L     R14,GETMSAVE            restore return address\n         BR    R14                     goback\nAMODE24  LA    R14,0(,R14)             remove XA bit\n         BSM   R0,R14                  return\n         SPACE 2\nAMODE31  O     R14,HIBIT               add XA bit\n         BSM   R0,R14                  return\n*\n*============================================================*\n* SONSTIGE DEFINITIONS                                       *\n*============================================================*\n****************************** CONSTANTS *****************************\nC_COBOL370 DC X'00',C'CEE'                   COBOL/370 ?  X'00C3C5C5'\nC_OPLINK   DC X'01',C'CEE'                   COBOL/370 ?  X'01C3C5C5'\nHIBIT    DC    A(X'80000000')         XA BIT CONSTANS\nBLANKS   DC    CL255' '           just blanks\nC_LSTO   OPEN  (*-*,(OUTPUT)),MF=L\nC_LSTOL  EQU   *-C_LSTO\nC_LSTI   OPEN  (*-*,(INPUT)),MF=L\nC_LSTIL  EQU   *-C_LSTI\nC_CLOSE  CLOSE (*-*),MF=L\nC_CLOSEL EQU   *-C_CLOSE\nXFF      DC    XL8'FFFFFFFFFFFFFFFF' just High-value\nSYSPRINT_FIX DCB   DSORG=PS,DDNAME=SYSPRINT,MACRF=PM,                  *\n               RECFM=FB,LRECL=121\nSYSPRINT_FIX_LENGTH EQU *-SYSPRINT_FIX   Length workarea\nINPUT_FIX DCB   DSORG=PS,DDNAME=COBANAL,MACRF=(GM),                    *\n               RECFM=U,BLKSIZE=256\n*INPUT_FIX DCB   DSORG=PO,DDNAME=COBANAL,MACRF=(R),                    *\n               RECFM=U,BLKSIZE=256\nINPUT_FIX_LENGTH EQU *-INPUT_FIX     Length workarea\n*\n*============================================================*\n* Workarea below the line                                    *\n*============================================================*\nCOBANAL_WORK        DSECT\nEYECATCHER          DS    CL8   'COBANAL'\nPGMNAME             DS    CL8   Pgmname from the parmlist\nPGMNAME_GET         DS    CL8   Pgmname from GETMEM\nSAVEAREA            DS    18F\nSAVER14             DS    F\nRETCODE             DS    F\nADR_COBANAL_WORK    DS    F     Save Workarea pointer\nADR_COBANAL_PARM    DS    F     Save Parmlist pointer\nADR_PGMNAME         DS    F     Save entry-point Application PGM\nRC_PGMNAME          DS    F     Save application RC\nPARM_LENGTH         DS    H     Parm length wihout header\nGETMSAVE            DS    F     Parm length wihout header\nADBLKPTR            DS    F     Parm length wihout header\nADBLKEND            DS    F     Parm length wihout header\nDOALL               DS    CL1   Analyze a complete loadlib\nDD_COBANAL          DS    CL1   Switch for DD CobAnal\nDOUBLE              DS    D\nCSV_LENGTH          DS    F     Length returned by CSVQuery\n         CSVQUERY MF=(L,CSVQRYWK)\n         ASAXWC    MF=(L,MYLIST)\n****************************** VARIABLES *****************************\nLE_SWITCH           DS    CL1   Switch for COBOL/370 or COBOL/2\nLE_PGM_NAME         DS CL8  name of program\nLE_COMP_YEAR        DS CL4  year of compilation\n*  3 bytes because of OS/VS COBOL\nLE_COMP_MONTH       DS CL3  month of compilation\nLE_COMP_DAY         DS CL2  day of compilation\nLE_COMP_HOURS       DS CL2  hours of compilation\nLE_COMP_MIN         DS CL2  minutes of compilation\nLE_COMP_SEC         DS CL2  seconds of compilation\nLE_VERS             DS CL2  version\nLE_REL              DS CL2  release\nLE_MOD              DS CL2  modification level\nLE_CCSID            DS XL2  Codepage\nLE_STATUS_BYTE      DS    0C   signature bytes\nLE_STATUS_BYTE_01   DS X    status byte\nLE_STATUS_BYTE_02   DS X    status byte\nLE_STATUS_BYTE_03   DS X    status byte\nLE_STATUS_BYTE_04   DS X    status byte\nLE_STATUS_BYTE_05   DS X    status byte\nLE_STATUS_BYTE_06   DS X    status byte\nLE_STATUS_BYTE_07   DS X    status byte\nLE_STATUS_BYTE_08   DS X    status byte\nLE_STATUS_BYTE_09   DS X    status byte\nLE_STATUS_BYTE_10   DS X    status byte\nLE_STATUS_BYTE_11   DS X    status byte\nLE_STATUS_BYTE_12   DS X    status byte\nLE_STATUS_BYTE_13   DS X    status byte\nLE_STATUS_BYTE_14   DS X    status byte\nLE_STATUS_BYTE_15   DS X    status byte\nLE_STATUS_BYTE_16   DS X    status byte\nLE_STATUS_BYTE_17   DS X    status byte\nLE_STATUS_BYTE_18   DS X    status byte\nLE_STATUS_BYTE_19   DS X    status byte\nLE_STATUS_BYTE_20   DS X    status byte\nLE_STATUS_BYTE_21   DS X    status byte\nLE_STATUS_BYTE_22   DS X    status byte\nLE_STATUS_BYTE_23   DS X    status byte\nLE_STATUS_BYTE_24   DS X    status byte\nLE_STATUS_BYTE_25   DS X    status byte\nLE_STATUS_BYTE_26   DS X    status byte Cobol for MVS and VM\nLE_STATUS_BYTE_27   DS X    status byte Cobol for MVS and VM\nLE_STATUS_BYTE_28   DS X    status byte Cobol V3R1\nLE_STATUS_BYTE_29   DS X    status byte Cobol V3R1\nLE_COBOL_SIGNAT     DS X    cobol signature level\nLE_DATA_STATEMENTS  DS XL4  number of data items\nLE_PROC_LINES       DS XL4  number of proc statements\nLE_YEAR_WINDOW      DS H    YearWindow\nSYSPRINT DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,                      *\n               RECFM=FB,LRECL=121\nINPUT    DCB   DSORG=PS,DDNAME=COBANAL,MACRF=(GM),                     *\n               RECFM=U,BLKSIZE=256\nDIRAREA             DS    XL256 PDS-Directory input area\nPARMLIST            DS XL40\nRECORD              DS CL132\nCOBANAL_WORK_LENGTH EQU *-COBANAL_WORK  Length workarea\n*\n*============================================================*\n* Parameter (JCL)                                            *\n*============================================================*\nCOBANAL_PARM        DSECT\nCOBANAL_PARM_LENGTH DS H\n*\n*\n*============================================================*\n* COBOL/370 DCL\n*============================================================*\nCOBOL_370_DSECT     DSECT\n                    DS CL4  bypass\nCEE_EYECATCHER      DS CL4  excatcher\nCEE_STACK_FRAME     DS F    stack frame size\nCEE_PPA1_OFFSET     DS F    offset to first ppa1\n                    DS CL4  reserved\nCEE_PPA1_START      DS 0C\nCEE_OFFSET          DS X    offset to length of name from ppa1\nCEE_SIGNATURE       DS X    CEL-Signature\nCEE_FLAG1           DS X    CEL-FLAGS Bitmask\nCEE_FLAG2           DS X    Member Flags for Cobol\nCEE_ADDRESS_OF_PPA2 DS F    Address of PPA2\nCEE_OFFSET_DBI      DS F    Offset BDI (None)\nCEE_EP_DESCRIPTOR   DS F    Entry Point Descriptor\nCEE_STACK_OVERFLOW  DS F    Offset for Stack overflow\n                    DS F    available word\n                    DS F    available word\n                    DS F    available word\n                    DS F    available word\nCEE_PRIMARY_EP      DS 0C\nCEE_PRI_EP_ADDRESS  DS A    primary entry-point address\nCEE_PGT_ADDRESS     DS A    PGT-Address\nCEE_TGT_ADDRESS     DS A    PGT-Address\nCEE_EP_NAME         DS A    Offset to entry_point_name\nCEE_CURRENT_EP      DS A    current EP-Address\nCEE_START           DS A    procedure code Address\nCEE_INIT_PROG       DS A    Initialize Routine\nCEE_PARM_LIST       DS A    Address of parm list for CEEINT\n                    DS F    available word\n                    DS H    available half-word\nCEE_LENGTH_NAME     DS XL2  length of program_name\nCEE_NAME_PART       DS 0C\nCEE_PGM_NAME        DS CL8  name of program\nCEE_COMP_YEAR       DS CL4  year of compilation\nCEE_COMP_MONTH      DS CL2  month of compilation\nCEE_COMP_DAY        DS CL2  day of compilation\nCEE_COMP_HOURS      DS CL2  hours of compilation\nCEE_COMP_MIN        DS CL2  minutes of compilation\nCEE_COMP_SEC        DS CL2  seconds of compilation\nCEE_VERS            DS CL2  version\nCEE_REL             DS CL2  release\nCEE_MOD             DS CL2  modification level\nCEE_CCSID           DS XL2  Codepage (COBOL V3R1 only)\n                    DS H    available halfword\nCEE_STATUS_BYTE_28  DS X    status byte\nCEE_STATUS_BYTE_29  DS X    status byte\nCEE_YEAR_WINDOW     DS H    YearWindow\nCEE_STATUS_BYTE_01  DS X    status byte\nCEE_STATUS_BYTE_02  DS X    status byte\nCEE_STATUS_BYTE_03  DS X    status byte\nCEE_STATUS_BYTE_04  DS X    status byte\nCEE_STATUS_BYTE_05  DS X    status byte\nCEE_STATUS_BYTE_06  DS X    status byte\nCEE_STATUS_BYTE_07  DS X    status byte\nCEE_STATUS_BYTE_08  DS X    status byte\nCEE_STATUS_BYTE_09  DS X    status byte\nCEE_STATUS_BYTE_10  DS X    status byte\nCEE_STATUS_BYTE_11  DS X    status byte\nCEE_STATUS_BYTE_12  DS X    status byte\nCEE_STATUS_BYTE_13  DS X    status byte\nCEE_STATUS_BYTE_14  DS X    status byte\nCEE_STATUS_BYTE_15  DS X    status byte\nCEE_STATUS_BYTE_16  DS X    status byte\nCEE_STATUS_BYTE_17  DS X    status byte\nCEE_STATUS_BYTE_18  DS X    status byte\nCEE_STATUS_BYTE_19  DS X    status byte\nCEE_STATUS_BYTE_20  DS X    status byte\nCEE_STATUS_BYTE_21  DS X    status byte\nCEE_STATUS_BYTE_22  DS X    status byte\nCEE_STATUS_BYTE_23  DS X    status byte\nCEE_COBOL_SIGNAT    DS X    cobol signature level\nCEE_DATA_STATEMENTS DS XL4  number of data items\nCEE_PROC_LINES      DS XL4  number of proc statements\nCEE_STATUS_BYTE_24  DS X    status byte\nCEE_STATUS_BYTE_25  DS X    status byte\nCEE_STATUS_BYTE_26  DS X    status byte\nCEE_STATUS_BYTE_27  DS X    status byte\n*============================================================*\n* COBOL2 DCL\n*============================================================*\nCOBOL_2_DSECT      DSECT\n                   DS CL4  bypass\n                   DS X\nC2_PGM_NAME        DS CL8  name of program\nC2_EYECATCHER      DS CL4  eyecatcher\nC2_VERS            DS CL2  version\nC2_REL             DS CL2  release\nC2_MOD             DS CL2  modification level\nC2_COMP_MONTH      DS CL2  month of compilation\n                   DS CL1\nC2_COMP_DAY        DS CL2  day of compilation\n                   DS CL1\nC2_COMP_YEAR       DS CL2  year of compilation\n                   DS CL1\nC2_COMP_HOURS      DS CL2  hours of compilation\n                   DS CL1\nC2_COMP_MIN        DS CL2  minutes of compilation\n                   DS CL1\nC2_COMP_SEC        DS CL2  seconds of compilation\nC2_GET_ENTRY       DS A    Address of address\nC2_STATUS_BYTE_01  DS X    status byte\nC2_STATUS_BYTE_02  DS X    status byte\nC2_STATUS_BYTE_03  DS X    status byte\nC2_STATUS_BYTE_04  DS X    status byte\nC2_STATUS_BYTE_05  DS X    status byte\nC2_STATUS_BYTE_06  DS X    status byte\nC2_STATUS_BYTE_07  DS X    status byte\nC2_STATUS_BYTE_08  DS X    status byte\nC2_STATUS_BYTE_09  DS X    status byte\nC2_STATUS_BYTE_10  DS X    status byte\nC2_STATUS_BYTE_11  DS X    status byte\nC2_STATUS_BYTE_12  DS X    status byte\nC2_STATUS_BYTE_13  DS X    status byte\nC2_STATUS_BYTE_14  DS X    status byte\nC2_STATUS_BYTE_15  DS X    status byte\nC2_STATUS_BYTE_16  DS X    status byte\nC2_STATUS_BYTE_17  DS X    status byte\nC2_STATUS_BYTE_18  DS X    status byte\nC2_STATUS_BYTE_19  DS X    status byte\nC2_STATUS_BYTE_20  DS X    status byte\nC2_STATUS_BYTE_21  DS X    status byte\nC2_STATUS_BYTE_22  DS X    status byte\nC2_STATUS_BYTE_23  DS X    status byte\n                   DS X    cobol signature level\nC2_DATA_STATEMENTS DS XL4  number of data items\nC2_PROC_LINES      DS XL4  number of proc statements\nC2_STATUS_BYTE_24  DS X    status byte\nC2_STATUS_BYTE_25  DS X    status byte\n                   DS XL2  status byte\n                   DS CL4  status byte\nC2_PRI_EP_ADDRESS  DS A    primary entry-point address\n*\n*============================================================*\n* OS/VS COBOL\n*============================================================*\nCOBOL_1_DSECT      DSECT\n                   DS CL12 bypass\nC1_PGM_NAME        DS CL8  name of program\nC1_EYECATCHER      DS CL2  eyecatcher\nC1_REL             DS CL2  release\n                   DS CL36\nC1_TGT_PTR         DS F    pointer to tgt\n                   DS CL8  unknown                               RS0700\nC1_OEM_MOD_AREA    DS CL60 Optimizer Info orgin COBOL low-values RS0700\n                   DS CL4  unknown                               RS0700\nC1_COMP_HOURS      DS CL2  hours of compilation\n                   DS CL1\nC1_COMP_MIN        DS CL2  minutes of compilation\n                   DS CL1\nC1_COMP_SEC        DS CL2  seconds of compilation\nC1_COMP_MONTH      DS CL3  month of compilation\n                   DS CL1\nC1_COMP_DAY        DS CL2  day of compilation\n                   DS CL2\nC1_COMP_YEAR       DS CL4  year of compilation\nCOBOL_1_TGT        DSECT\n                   DS CL72 ?\nC1_STATUS_BYTE_01  DS X    status byte\nC1_STATUS_BYTE_02  DS X    status byte\nC1_STATUS_BYTE_03  DS X    status byte\n                   DS CL369\nC1_CHECK           DS CL8  check TGT for SYSOUT\n*\n         DCBD    DSORG=QS\n         STRING GENERATE\nBIT0     EQU   B'10000000'\nBIT1     EQU   B'01000000'\nBIT2     EQU   B'00100000'\nBIT3     EQU   B'00010000'\nBIT4     EQU   B'00001000'\nBIT5     EQU   B'00000100'\nBIT6     EQU   B'00000010'\nBIT7     EQU   B'00000001'\n*------------------------------------------------------------*\n* Program equates                                            *\n*------------------------------------------------------------*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COBANAL1": {"ttr": 1029, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01M\\x00\\x00\\x00\\x99\\x16\\x1f\\x01\\x01\\x01\\x1f\\x07X\\x07|\\x06c\\x00\\x00\\xe7\\xe2\\xe2\\xc7\\xe2\\xc3\\xc8@@@'", "ispf": {"version": "01.77", "flags": 0, "createdate": "1999-06-10T00:00:00", "modifydate": "2001-01-11T07:58:00", "lines": 1916, "newlines": 1635, "modlines": 0, "user": "XSSGSCH"}, "text": "***********************************************************************\n*                                                                     *\n* Name:         COBANAL                                               *\n*                                                                     *\n* Author:       Roland Schiradin                                      *\n*               roland(at)Schiradin.de                                *\n*                                                                     *\n* Date:         Februar 1996                                          *\n*                                                                     *\n* Description:  Show compile-settings and some other information      *\n*                                                                     *\n* Changes:      16.12.1996 (european)                                 *\n*               Support for VS/COBOL1 (just a few)                    *\n*               String macro no longer inside this source             *\n*               (request FILE183 from Naspa or drop me an email)      *\n*               28.04.1997 (european)                                 *\n*               Support for COBOL for MVS and VM Release 2 (formally  *\n*               called AD/Cycle COBOL/370)                            *\n*               04.03.1998 (european)                                 *\n*               MODID-marco dropped                                   *\n*               Direct Load-Library support                           *\n*               Some parts of Dave Alcocks code (DA$COBR)             *\n*               (You can contact him at dalcock(at)csw.com)           *\n*               24.03.1998 (european)                                 *\n*               Prevent S15D abend you invoke COBANAL from TSO-CALL   *\n*               (reported by Dave Alcock)                             *\n*               Support for newer STRING macro STRING GENERATE instaed*\n*               of STRING FINAL_CALL                                  *\n*               (reported by Dave Alcock)                             *\n*               Fixed a bug in statement list. Y now means Yes and not*\n*               vice versa. Sorry                                     *\n*               15.02.1999 (european)                                 *\n*               Support for COBOL OS/390 and VM V2R1                  *\n*               Some new Compile-options                              *\n*               Compile-Date is European style, added long name       *\n*               Some minor fixes I cant remember in detail            *\n*               Support for MVS 4.3 (AMODE switching)                 *\n*               10.06.1999 (european)                                 *\n*               Fixed bugs reported by Mr. Smets (Thank you)          *\n*               Show ?? as the century for COBOL2                     *\n*               Support for Entrypoints (e.g. ENTRY 'DLITCBL')        *\n*               Note: There is no need to do this for IMS             *\n*               25.10.1999 (european)                                 *\n*               Check ParmLength for Parameter \"ALL\".                 *\n*               Close all datasets                                    *\n*               Make CobAnal reentrant (LinkList!!!)                  *\n*               Release storage                                       *\n*               Load modules from DD COBANAL if exist                 *\n*               29.12.1999 (european)                                 *\n*               Abend 0C4 fixed                                       *\n*               Add PPA2 support                                      *\n*               Detect C/C++ and LE-enabled Assembler Programs        *\n*               The product name for COBOL1 is OS/VS Cobol (MVS) and  *\n*               DOS/VS COBOL (VSE)                                    *\n*               13.04.2000 (european)                                 *\n*               Support for some infos I missed (INVOKE, GLOBAL and   *\n*               so on) Thank you Mr. Gross                            *\n*               Add a third base register                             *\n*               23.04.2000 (european)                                 *\n*               Tested with STRING V507 from FILE183                  *\n*               19.07.2000 (european)                                 *\n*               Support for COBOL1 OEM products (e.g. CA-Optimzer)    *\n*               Thank you Mr. Pfeifer                                 *\n*               02.10.2000 (european)                                 *\n*               Support for COBOL for OS/390 & VM V2R2                *\n*               New TEST(SEPARATE)/NO TEST(SEPARATE)                  *\n*               New ARITH(EXTEND)/ARITH(COMPAT)                       *\n*               New line-sequential file                              *\n*               Thank you IBM for HFS-Support and Display under CICS  *\n*               Save some literal pool                                *\n*               I know I need to re-design the program but the        *\n*               time (you may know) is limited. At the start it       *\n*               was intend to run once and then throw it away         *\n*               Thanks for all ideas to do it better, if I'm retired  *\n*               I would spent some time on it. Don't expect that      *\n*               within the next 25 years !!!                          *\n*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 09.10.1999 (european)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 *\n*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 End-Substract changed to End-Subtract\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 *\n*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Corect a length for moving literal Subtract\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 *\n*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 08.01.2001 (european)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 *\n*\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Loop bug fixed\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 *\n***********************************************************************\n         TITLE 'Show Compile-Option and some more nice info'\nCOBANAL  CSECT\nCOBANAL  AMODE 31\nCOBANAL  RMODE 24\n         BAKR  R14,R0             Save register\n         LA    R10,1\n         LR    R6,R15             set base register\n         LA    R7,4095(R10,R6)    second base register\n         LA    R12,4095(R10,R7)   third base register\n         USING COBANAL,R6,R7,R12     Addressebility\n         L     R9,0(R1)           Save Parmlist\n         USING COBANAL_PARM,R9    addressebility\n         LA    R0,COBANAL_WORK_LENGTH\n         STORAGE OBTAIN,LENGTH=(R0),ADDR=(R1),COND=NO,LOC=BELOW\n         LR    R11,R1             COBANAL_WORK register\n         USING COBANAL_WORK,R11   addressebility\n         MVC   EYECATCHER,=CL8'COBANAL'\n         MVI   DOALL,C'N'         Default\n         MVI   DD_COBANAL,C'N'    Default\n         XC    SAVEAREA,SAVEAREA  clear saveare\n         LA    R15,SAVEAREA       get address of savearea\n         ST    R13,4(,R15)        chain the savearea back pointer\n         ST    R15,8(,R13)        chain saveare forward\n         LR    R13,R15            set new savearea\n         ST    R11,ADR_COBANAL_WORK  save address\n         ST    R9,ADR_COBANAL_PARM   save address\n*------------------------------------------------------------*\n*        Check JCL-Parm                                      *\n*------------------------------------------------------------*\n         MVC   PARM_LENGTH,COBANAL_PARM_LENGTH\n         LH    R10,PARM_LENGTH\n         LA    R9,2(R9)            jump length field\n         MVC   PGMNAME,BLANKS      clear PGMNANE\n         LA    R8,PGMNAME          first parm\nCOBANAL_010 DS  0H                 do until first ',' or end\n         CLI   0(R9),C','          parm separator\n         BE    COBANAL_020         next parm\n         MVC   0(1,R8),0(R9)\n         LA    R8,1(R8)            next digit\n         LA    R9,1(R9)            next digit\n         BCT   R10,COBANAL_010     loop\nCOBANAL_020 DS  0H\n         MVC   SYSPRINT(SYSPRINT_FIX_LENGTH),SYSPRINT_FIX\n         MVC   PARMLIST(C_LSTOL),C_LSTO\n         LA    R9,SYSPRINT\n         USING IHADCB,R9\n         MVC   DCBDDNAM,=C'SYSPRINT'\n         OPEN  ((R9),OUTPUT),MF=(E,PARMLIST)\n         DROP  R9\n         DEVTYPE =CL8'COBANAL',DOUBLE     Get COBANAL information\n         LTR   R15,R15                    Is it allocated?\n         BNZ   COBANAL_021                No, continue\n         MVI   DD_COBANAL,C'Y'    Default\n         MVC   INPUT(INPUT_FIX_LENGTH),INPUT_FIX\n         MVC   PARMLIST(C_LSTIL),C_LSTI\n         LA    R9,INPUT\n         USING IHADCB,R9\n         MVC   DCBDDNAM,=C'COBANAL '\n         OPEN  ((R9),INPUT),MF=(E,PARMLIST)\n         DROP  R9\nCOBANAL_021 DS  0H\n         STRING 'COBOL module analysis is starting',INTO=RECORD\n         BAL   R14,SPACE1                 Print starting message\n         CLC   PGMNAME,BLANKS      check PGMNAME\n         BE    COBANAL_PARM_ERROR  if clear ==> Error\n         CLC   PGMNAME(3),=C'ALL'  PGMNAME = ALL indicate analyzing\n         BNE   COBANAL_025         a complete Load, but check for\n         CLC   PARM_LENGTH,=H'3'   length; maybe it is a prog called\n         BNE   COBANAL_025         ALLWAYS :-))\n         CLI   DD_COBANAL,C'Y'        Did you read the docs?\n         BE    COBANAL_022           yes, thats fine\n         STRING 'Parameter=ALL specified but DD-Name COBANAL missing', *\n               INTO=RECORD\n         BAL   R14,SPACE1                 Print starting message\n         MVC   RETCODE,=F'12'\n         B     COBANAL_EXIT         no, leave\n** Loop\nCOBANAL_022 DS  0H\n         MVI   DOALL,C'Y'          remember that\n         BAL   R14,GETMEM          get the member name\n         CLC   PGMNAME,XFF         more entries?\n         BE    COBANAL_EXIT          leave\n*------------------------------------------------------------*\n*        Load the progamm from DD COBANAL                    *\n*------------------------------------------------------------*\n         LOAD  EPLOC=PGMNAME,DCB=INPUT,ERRET=COBANAL_LOAD_ERROR\n         B     COBANAL_027\nCOBANAL_025 DS  0H\n         CLI   DD_COBANAL,C'Y'    load from DD Cobanal ?\n         BE    COBANAL_026           yes\n*------------------------------------------------------------*\n*        Load the progamm                                    *\n*------------------------------------------------------------*\n         LOAD  EPLOC=PGMNAME       Load the pgm\n         B     COBANAL_027\nCOBANAL_026 DS  0H\n*------------------------------------------------------------*\n*        Load the progamm from DD COBANAL                    *\n*------------------------------------------------------------*\n         LOAD  EPLOC=PGMNAME,DCB=INPUT,ERRET=COBANAL_LOAD_ERROR\nCOBANAL_027 DS  0H\n         LTR   R15,R15             check response\n         BNZ   COBANAL_LOAD_ERROR if greater zero ==> Error\n         ST    R0,ADR_PGMNAME      save the address\n*------------------------------------------------------------*\n*        Check length                                        *\n*------------------------------------------------------------*\n         CSVQUERY SEARCH=JPALPA,       SEARCH JPAQ                     +\n               INADDR=ADR_PGMNAME,     ADDRESS                         +\n               OUTLENGTH=CSV_LENGTH,                                   +\n               MF=(E,CSVQRYWK)         WORK AREA\n         LTR   R2,R15                  pass return code\n         BNZ   COBANAL_CSV_ERROR if greater zero ==> Error\n*------------------------------------------------------------*\n*        Write info to sysprint                              *\n*------------------------------------------------------------*\nCOBANAL_03 DS  0H\n         STRING 'Program Name= ',PGMNAME,                              @\n               ' was loaded into storage at EPA= ',(ADR_PGMNAME,,X),   @\n               INTO=RECORD\n         BAL   R14,SPACE1\n*\n*        Dump the first 256 Bytes for Identification.\n*        Should be activate only in case of problems\n*\n*        L     R4,ADR_PGMNAME\n*        LA    R3,256/16               LOOP COUNTER\n*LOOP\nCOBANAL_04 DS  0H\n*        STRING 4X,((R4),4,X),1X,(4(R4),4,X),1X,(8(R4),4,X),1X,        X\n               (12(R4),4,X),3X,((R4),16),                              $\n               INTO=RECORD\n*        BAL   R14,SPACE1          <== next line\n*        LA    R4,016(,R4)             BUMP POINTER\n*        BCT   R3,COBANAL_04\n*ENDLOOP\n         L     R4,ADR_PGMNAME       Load-Entry-Point\n         USING COBOL_370_DSECT,R4\n         CLC   CSV_LENGTH,=F'24'    At least 24 bytes!!!\n         BNH   COBANAL_06            prevent S0C4\n         CLC   CEE_EYECATCHER,C_COBOL370   COBOL/370 ?  X'00C3C5C5'\n         BE    COBOL_370\n         CLC   CEE_EYECATCHER,C_OPLINK     C         ?  X'01C3C5C5'\n         BE    C_370\n         USING COBOL_2_DSECT,R4\n         CLC   C2_EYECATCHER,=CL4' C2 '     COBOL/2 ?  X'40C3F240'\n         BE    COBOL_2\n         USING COBOL_1_DSECT,R4\n* ???    CLC   C1_EYECATCHER,=CL2'AN'       ANS4 COBOL ?\n* ???    BE    COBOL_1\n         CLC   C1_EYECATCHER(4),=CL4'VSR1'       OS/VS COBOL/1 ?\n         BE    COBOL_1\n         CLC   C1_EYECATCHER(4),=CL4'VSR2'       OS/VS COBOL/1 ?\n         BE    COBOL_1\nCOBANAL_06 DS  0H\n         STRING 'Can not established the program_language',INTO=RECORD\n         BAL   R14,SPACE1\n         MVC   RETCODE,=F'8'\n         B     COBANAL_EXIT         no, leave\nCOBANAL_08 DS  0H\n         STRING 'Program=',PGMNAME,' seems to be LE but',              X\n               ' PPA1 looks invalid',INTO=RECORD\n         BAL   R14,SPACE1\n         MVC   RETCODE,=F'8'\n         B     COBANAL_EXIT         no, leave\nCOBANAL_09 DS  0H\n         CLI   0(R2),X'03'          ID = C       (03) ?\n         BNE   COBANAL_10             no check Assembler\n         STRING 'Program=',PGMNAME,' is a C-Program ',INTO=RECORD\n         BAL   R14,SPACE1\n         MVC   RETCODE,=F'8'\n         B     COBANAL_EXIT         no, leave\nCOBANAL_10 DS  0H\n         CLI   0(R2),X'0F'          ID = Assembler (15) ?\n         BNE   COBANAL_06             no, unknown language\n         STRING 'Program=',PGMNAME,' is a LE-enabled ',                X\n               'Assembler',INTO=RECORD\n         BAL   R14,SPACE1\n         MVC   RETCODE,=F'8'\n         B     COBANAL_EXIT         no, leave\nCOBANAL_PARM_ERROR DS  0H\n         STRING 'Error parm statement, check it',INTO=RECORD\n         BAL   R14,SPACE1\n         MVC   RETCODE,=F'12'\n         B     COBANAL_EXIT         no, leave\nCOBANAL_LOAD_ERROR DS  0H\n         STRING 'Error during load of program=',PGMNAME,INTO=RECORD\n         BAL   R14,SPACE1\n         MVC   RETCODE,=F'12'\n         B     COBANAL_EXIT         no, leave\nCOBANAL_CSV_ERROR DS  0H\n         STRING 'CSVQUERY failed, RC5=',((R2),,L),INTO=RECORD\n         BAL   R14,SPACE1\n         MVC   RETCODE,=F'12'\n         B     COBANAL_EXIT         no, leave\nCOBANAL_EXIT       DS 0H\n         DELETE EPLOC=PGMNAME       Delete the pgm\n         CLI   DOALL,C'N'           Default\n         BE    COBANAL_FIN\n         CLC   PGMNAME,XFF          Last Program?\n         BNE   COBANAL_022           no loop\nCOBANAL_FIN        DS 0H\n         LA    R9,SYSPRINT\n         USING IHADCB,R9\n         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN Is it OPEN?\n         BNO   COBANAL_FIN_1              No, ignore it\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE\n         CLOSE ((R9)),MF=(E,PARMLIST)      Close it\n         DROP  R9\nCOBANAL_FIN_1      DS 0H\n         LA    R9,INPUT\n         USING IHADCB,R9\n         TM    DCBOFLGS-IHADCB(R3),DCBOFOPN Is it OPEN?\n         BNO   COBANAL_FIN_2              No, ignore it\n         MVC   PARMLIST(C_CLOSEL),C_CLOSE\n         CLOSE ((R9)),MF=(E,PARMLIST)      Close it\n         DROP  R9\nCOBANAL_FIN_2      DS 0H\n         LA    R0,COBANAL_WORK_LENGTH\n         STORAGE RELEASE,              free Storage                    *\n               LENGTH=(R0),            Length                          *\n               ADDR=((R11))\n         L     R15,RETCODE\n         PR\n*============================================================*\n*    C/370 Program OPLINK Bit on !!!!!                       *\n*    Offset instead of relative pointer!!!                   *\n*============================================================*\nC_370    DS 0H\n         LR    R2,R4\n         A     R2,12(,R4)          PPA1\n         CLI   1(R2),X'CE'         Check PPA1\n         BNE   COBANAL_08            seems invalid PPA1\n         A     R4,4(,R2)           PPA2 pointer\n         LR    R2,R4\n         B     COBANAL_09          check languages\n*============================================================*\n*    COBOL/370 Program                                       *\n*============================================================*\nCOBOL_370 DS 0H\n         USING COBOL_370_DSECT,R4\n         LR    R2,R4\n         A     R2,12(,R4)          PPA1\n         CLI   1(R2),X'CE'         Check PPA1\n         BNE   COBANAL_08            seems invalid PPA1\n         ICM   R2,B'1111',4(R2)    PPA2 pointer\n         BZ    COBANAL_08            seems invalid PPA1\n         CLI   0(R2),X'05'         ID = Cobol!! (15)\n         BNE   COBANAL_09            no, error\n         MVI   LE_SWITCH,C'1'\n         L     R4,CEE_PRI_EP_ADDRESS\n         MVC   LE_VERS,CEE_VERS\n         MVC   LE_REL,CEE_REL\n         MVC   LE_MOD,CEE_MOD\n         MVC   LE_PGM_NAME,CEE_PGM_NAME\n         MVC   LE_COMP_DAY,CEE_COMP_DAY\n         MVC   LE_COMP_MONTH,CEE_COMP_MONTH\n         MVC   LE_COMP_YEAR,CEE_COMP_YEAR\n         MVC   LE_COMP_HOURS,CEE_COMP_HOURS\n         MVC   LE_COMP_MIN,CEE_COMP_MIN\n         MVC   LE_COMP_SEC,CEE_COMP_SEC\n         MVC   LE_DATA_STATEMENTS,CEE_DATA_STATEMENTS\n         MVC   LE_PROC_LINES,CEE_PROC_LINES\n         MVC   LE_YEAR_WINDOW,CEE_YEAR_WINDOW\n         MVC   LE_STATUS_BYTE_01,CEE_STATUS_BYTE_01\n         MVC   LE_STATUS_BYTE_02,CEE_STATUS_BYTE_02\n         MVC   LE_STATUS_BYTE_03,CEE_STATUS_BYTE_03\n         MVC   LE_STATUS_BYTE_04,CEE_STATUS_BYTE_04\n         MVC   LE_STATUS_BYTE_05,CEE_STATUS_BYTE_05\n         MVC   LE_STATUS_BYTE_06,CEE_STATUS_BYTE_06\n         MVC   LE_STATUS_BYTE_07,CEE_STATUS_BYTE_07\n         MVC   LE_STATUS_BYTE_08,CEE_STATUS_BYTE_08\n         MVC   LE_STATUS_BYTE_09,CEE_STATUS_BYTE_09\n         MVC   LE_STATUS_BYTE_10,CEE_STATUS_BYTE_10\n         MVC   LE_STATUS_BYTE_11,CEE_STATUS_BYTE_11\n         MVC   LE_STATUS_BYTE_12,CEE_STATUS_BYTE_12\n         MVC   LE_STATUS_BYTE_13,CEE_STATUS_BYTE_13\n         MVC   LE_STATUS_BYTE_14,CEE_STATUS_BYTE_14\n         MVC   LE_STATUS_BYTE_15,CEE_STATUS_BYTE_15\n         MVC   LE_STATUS_BYTE_16,CEE_STATUS_BYTE_16\n         MVC   LE_STATUS_BYTE_17,CEE_STATUS_BYTE_17\n         MVC   LE_STATUS_BYTE_18,CEE_STATUS_BYTE_18\n         MVC   LE_STATUS_BYTE_19,CEE_STATUS_BYTE_19\n         MVC   LE_STATUS_BYTE_20,CEE_STATUS_BYTE_20\n         MVC   LE_STATUS_BYTE_21,CEE_STATUS_BYTE_21\n         MVC   LE_STATUS_BYTE_22,CEE_STATUS_BYTE_22\n         MVC   LE_STATUS_BYTE_23,CEE_STATUS_BYTE_23\n         MVC   LE_STATUS_BYTE_24,CEE_STATUS_BYTE_24\n         MVC   LE_STATUS_BYTE_25,CEE_STATUS_BYTE_25\n         MVC   LE_STATUS_BYTE_26,CEE_STATUS_BYTE_26\n         MVC   LE_STATUS_BYTE_27,CEE_STATUS_BYTE_27\n         B     LE370_INFO\n*============================================================*\n*    COBOL/2 Program                                         *\n*============================================================*\nCOBOL_2 DS 0H\n         USING COBOL_2_DSECT,R4\n         MVI   LE_SWITCH,C'2'\n         L     R4,C2_GET_ENTRY\n         L     R4,0(R4)\n         MVC   LE_VERS,C2_VERS\n         MVC   LE_REL,C2_REL\n         MVC   LE_MOD,C2_MOD\n         MVC   LE_PGM_NAME,C2_PGM_NAME\n         MVC   LE_COMP_DAY,C2_COMP_DAY\n         MVC   LE_COMP_MONTH,C2_COMP_MONTH\n         MVC   LE_COMP_YEAR(2),=C'??'    COBOL2 not Y2K ready\n         MVC   LE_COMP_YEAR+2(2),C2_COMP_YEAR\n         MVC   LE_COMP_HOURS,C2_COMP_HOURS\n         MVC   LE_COMP_MIN,C2_COMP_MIN\n         MVC   LE_COMP_SEC,C2_COMP_SEC\n         MVC   LE_DATA_STATEMENTS,C2_DATA_STATEMENTS\n         MVC   LE_PROC_LINES,C2_PROC_LINES\n         MVC   LE_STATUS_BYTE_01,C2_STATUS_BYTE_01\n         MVC   LE_STATUS_BYTE_02,C2_STATUS_BYTE_02\n         MVC   LE_STATUS_BYTE_03,C2_STATUS_BYTE_03\n         MVC   LE_STATUS_BYTE_04,C2_STATUS_BYTE_04\n         MVC   LE_STATUS_BYTE_05,C2_STATUS_BYTE_05\n         MVC   LE_STATUS_BYTE_06,C2_STATUS_BYTE_06\n         MVC   LE_STATUS_BYTE_07,C2_STATUS_BYTE_07\n         MVC   LE_STATUS_BYTE_08,C2_STATUS_BYTE_08\n         MVC   LE_STATUS_BYTE_09,C2_STATUS_BYTE_09\n         MVC   LE_STATUS_BYTE_10,C2_STATUS_BYTE_10\n         MVC   LE_STATUS_BYTE_11,C2_STATUS_BYTE_11\n         MVC   LE_STATUS_BYTE_12,C2_STATUS_BYTE_12\n         MVC   LE_STATUS_BYTE_13,C2_STATUS_BYTE_13\n         MVC   LE_STATUS_BYTE_14,C2_STATUS_BYTE_14\n         MVC   LE_STATUS_BYTE_15,C2_STATUS_BYTE_15\n         MVC   LE_STATUS_BYTE_16,C2_STATUS_BYTE_16\n         MVC   LE_STATUS_BYTE_17,C2_STATUS_BYTE_17\n         MVC   LE_STATUS_BYTE_18,C2_STATUS_BYTE_18\n         MVC   LE_STATUS_BYTE_19,C2_STATUS_BYTE_19\n         MVC   LE_STATUS_BYTE_20,C2_STATUS_BYTE_20\n         MVC   LE_STATUS_BYTE_21,C2_STATUS_BYTE_21\n         MVC   LE_STATUS_BYTE_22,C2_STATUS_BYTE_22\n         MVC   LE_STATUS_BYTE_23,C2_STATUS_BYTE_23\n         MVC   LE_STATUS_BYTE_24,C2_STATUS_BYTE_24\n         MVC   LE_STATUS_BYTE_25,C2_STATUS_BYTE_25\n         B     LE370_INFO\n*============================================================*\n* OS/VS COBOL   Program                                      *\n*============================================================*\nCOBOL_1 DS 0H\n         USING COBOL_1_DSECT,R4\n         MVI   LE_SWITCH,C'3'\n         MVC   LE_VERS,BLANKS\n         MVC   LE_REL,C1_REL\n         MVC   LE_MOD,BLANKS\n         MVC   LE_PGM_NAME,C1_PGM_NAME\n         MVC   LE_COMP_DAY,C1_COMP_DAY\n         MVC   LE_COMP_MONTH,C1_COMP_MONTH\n         MVC   LE_COMP_YEAR,C1_COMP_YEAR\n         MVC   LE_COMP_HOURS,C1_COMP_HOURS\n         MVC   LE_COMP_MIN,C1_COMP_MIN\n         MVC   LE_COMP_SEC,C1_COMP_SEC\n         L     R5,C1_TGT_PTR\n         USING COBOL_1_TGT,R5\n         CLC   C1_CHECK,=CL8'SYSOUT'     check\n         BE    LE370_INFO\n*\n*        UNABLE TO FIND THE TASK GLOBAL TABLE  -\n*\nNOTTGT   DS    0H\n         STRING 'Program ',PGMNAME,' failed the TGT (Task Global',     @\n               'Table) test',INTO=RECORD\n         BAL   R14,SPACE2\n         LA    R15,8\n         B     COBANAL_EXIT\nLE370_INFO DS  0H\n         STRING '============ Info ==================================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         STRING 'Program: ',PGMNAME,' is COBOL/370 Version ',LE_VERS,  *\n               ' Release ',LE_REL,' Mod-Level ',LE_MOD,INTO=RECORD\n         CLI   LE_SWITCH,C'1'\n         BE    JUMP_AROUND\n         STRING 'Program: ',PGMNAME,' is COBOL/2 Version ',LE_VERS,    *\n               ' Release ',LE_REL,' Mod-Level ',LE_MOD,INTO=RECORD\n         CLI   LE_SWITCH,C'2'\n         BE    JUMP_AROUND\n         STRING 'Program: ',PGMNAME,' is OS/VS COBOL Release ',LE_REL, *\n               INTO=RECORD\nJUMP_AROUND DS 0H\n         BAL   R14,SPACE2\n         STRING '============ Timestamps ============================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         STRING 'Compiled program name ',LE_PGM_NAME,INTO=RECORD\n         BAL   R14,SPACE1\n         BAL   R9,LE_370_12\n         DC    CL2'01',CL3'Jan'      Long name\n         DC    CL2'02',CL3'Feb'      for our non-european user\n         DC    CL2'03',CL3'Mar'\n         DC    CL2'04',CL3'Apr'\n         DC    CL2'05',CL3'May'\n         DC    CL2'06',CL3'Jun'\n         DC    CL2'07',CL3'Jul'\n         DC    CL2'08',CL3'Aug'\n         DC    CL2'09',CL3'Sep'\n         DC    CL2'10',CL3'Okt'\n         DC    CL2'11',CL3'Nov'\n         DC    CL2'12',CL3'Dec'\n         DC    X'0000',CL3'n/a'             end of table\nLE_370_12 DS   0H\n         CLC   LE_COMP_MONTH(2),0(R9)         check properties\n         BE    LE_370_14               jump if on\n         LA    R9,5(,R9)              Skip entry\n         CLI   0(R9),0                 end of table?\n         BNE   LE_370_12               not yet, loop\nLE_370_14 DS   0H\n         STRING 'Date: ',LE_COMP_DAY,'.',(LE_COMP_MONTH,2),'.',        *\n               LE_COMP_YEAR,' (european) ',LE_COMP_DAY,'.',            *\n               (2(R9),3,T),'.',LE_COMP_YEAR,' (long) ',                *\n               ' Time: ',LE_COMP_HOURS,':',LE_COMP_MIN,                *\n               ':',LE_COMP_SEC,INTO=RECORD\n         CLI   LE_SWITCH,C'3'    OS/VS COBOL ?\n         BNE   JUMP_AROUND_2       no, go ahead\n         STRING 'Date: ',LE_COMP_DAY,'.',LE_COMP_MONTH,'.',            *\n               LE_COMP_YEAR,' Time: ',LE_COMP_HOURS,':',LE_COMP_MIN,   *\n               ':',LE_COMP_SEC,INTO=RECORD\n         BAL   R14,SPACE2\n         B     INFO_COBOL            sorry no more information\nJUMP_AROUND_2 DS 0H\n         BAL   R14,SPACE2\n         STRING '============ Statistics ============================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         STRING 'Number of data items  : ',(LE_DATA_STATEMENTS,F,R7B), *\n               INTO=RECORD\n         BAL   R14,SPACE1\n         STRING 'Number of instructions: ',(LE_PROC_LINES,F,R7B),      *\n               INTO=RECORD\n         BAL   R14,SPACE2\n         STRING '============ Options in effect =====================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         MVC   RECORD,BLANKS\n         LA    R15,RECORD\n         MVC   1(3,R15),=C'ADV'\n         TM    LE_STATUS_BYTE_01,BIT0\n         BO    *+10\n         MVC   1(5,R15),=C'NOADV'\n         LA    R15,8(R15)\n         MVC   0(5,R15),=C'APOST'\n         TM    LE_STATUS_BYTE_01,BIT1\n         BO    *+10\n         MVC   0(5,R15),=C'QUOTE'\n         LA    R15,8(R15)\n         MVC   RECORD+16(9),=CL9'DATA(31)'\n         TM    LE_STATUS_BYTE_01,BIT2\n         BO    *+10\n         MVC   RECORD+16(9),=CL9'DATA(24)'\n         MVC   RECORD+25(6),=CL6'DECK'\n         TM    LE_STATUS_BYTE_01,BIT3\n         BO    *+10\n         MVC   RECORD+25(6),=CL6'NODECK'\n         MVC   RECORD+33(6),=CL6'DUMP'\n         TM    LE_STATUS_BYTE_01,BIT4\n         BO    *+10\n         MVC   RECORD+33(6),=CL6'NODUMP'\n         MVC   RECORD+40(8),=CL8'DYNAM'\n         TM    LE_STATUS_BYTE_01,BIT5\n         BO    *+10\n         MVC   RECORD+40(8),=CL8'NODYNAM'\n         MVC   RECORD+51(10),=CL10'FASTSRT'\n         TM    LE_STATUS_BYTE_01,BIT6\n         BO    *+10\n         MVC   RECORD+51(10),=CL10'NOFASTSRT'\n         MVC   RECORD+62(8),=CL8'FDUMP'\n         TM    LE_STATUS_BYTE_01,BIT7\n         BO    *+10\n         MVC   RECORD+62(8),=CL8'NOFDUMP'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(6),=CL6'LIB'\n         TM    LE_STATUS_BYTE_02,BIT0\n         BO    *+10\n         MVC   RECORD+1(6),=CL6'NOLIB'\n         MVC   RECORD+8(7),=CL7'LIST'\n         TM    LE_STATUS_BYTE_02,BIT1\n         BO    *+10\n         MVC   RECORD+8(7),=CL7'NOLIST'\n         MVC   RECORD+16(9),=CL9'MAP'\n         TM    LE_STATUS_BYTE_02,BIT2\n         BO    *+10\n         MVC   RECORD+16(9),=CL9'NOMAP'\n         MVC   RECORD+25(6),=CL6'NUM'\n         TM    LE_STATUS_BYTE_02,BIT3\n         BO    *+10\n         MVC   RECORD+25(6),=CL6'NONUM'\n         MVC   RECORD+33(6),=CL6'OBJ'\n         TM    LE_STATUS_BYTE_02,BIT4\n         BO    *+10\n         MVC   RECORD+33(6),=CL6'NOOBJ'\n         MVC   RECORD+40(8),=CL8'OFFSET'\n         TM    LE_STATUS_BYTE_02,BIT5\n         BO    *+10\n         MVC   RECORD+40(8),=CL8'NOOFFSET'\n         MVC   RECORD+51(10),=CL10'OPTIMIZE'\n         TM    LE_STATUS_BYTE_02,BIT6\n         BO    *+10\n         MVC   RECORD+51(10),=CL10'NOOPTIMIZE'\n         MVC   RECORD+62(17),=CL17'DDNAME(no Default)'\n         TM    LE_STATUS_BYTE_02,BIT7\n         BO    *+10\n         MVC   RECORD+62(17),=CL17'DDNAME(Default)'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(15),=CL15'NUMPROC(MIG)'\n         TM    LE_STATUS_BYTE_05,BIT0\n         BO    LE_370_21\n         MVC   RECORD+1(15),=CL15'NUMPROC(PFD)'\n         TM    LE_STATUS_BYTE_03,BIT0\n         BO    *+10\n         MVC   RECORD+1(15),=CL15'NUMPROC(NOPFD)'\nLE_370_21 DS 0H\n         MVC   RECORD+16(7),=CL7'RENT'\n         TM    LE_STATUS_BYTE_03,BIT1\n         BO    *+10\n         MVC   RECORD+16(7),=CL7'NORENT'\n         MVC   RECORD+25(6),=CL6'RES'\n         TM    LE_STATUS_BYTE_03,BIT2\n         BO    *+10\n         MVC   RECORD+25(6),=CL6'NORES'\n         MVC   RECORD+33(6),=CL6'SEQ'\n         TM    LE_STATUS_BYTE_03,BIT3\n         BO    *+10\n         MVC   RECORD+33(6),=CL6'NOSEQ'\n         MVC   RECORD+40(12),=CL12'SIZE(MAX)'\n         TM    LE_STATUS_BYTE_03,BIT4\n         BO    *+10\n         MVC   RECORD+40(12),=CL12'SIZE(value)'\n         MVC   RECORD+51(9),=CL9'SOURCE'\n         TM    LE_STATUS_BYTE_03,BIT5\n         BO    *+10\n         MVC   RECORD+51(9),=CL9'NOSOURCE'\n         MVC   RECORD+62(10),=CL10'SSRANGE'\n         TM    LE_STATUS_BYTE_03,BIT6\n         BO    *+10\n         MVC   RECORD+62(10),=CL10'NOSSRANGE'\n         MVC   RECORD+72(8),=CL8'TERM'\n         TM    LE_STATUS_BYTE_03,BIT7\n         BO    *+10\n         MVC   RECORD+72(8),=CL8'NOTERM'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(8),=CL8'TEST'\n         TM    LE_STATUS_BYTE_04,BIT0\n         BO    *+10\n         MVC   RECORD+1(8),=CL8'NOTEST'\n         MVC   RECORD+8(10),=CL11'TRUNC(BIN)'\n         TM    LE_STATUS_BYTE_05,BIT4\n         BO    LE_370_33\n         MVC   RECORD+8(10),=CL11'TRUNC(STD)'\n         TM    LE_STATUS_BYTE_04,BIT1\n         BO    *+10\n         MVC   RECORD+8(10),=CL11'TRUNC(OPT)'\nLE_370_33 DS 0H\n         MVC   RECORD+25(8),=CL8'VBREF'\n         TM    LE_STATUS_BYTE_04,BIT3\n         BO    *+10\n         MVC   RECORD+25(8),=CL8'NOVBREF'\n         MVC   RECORD+33(6),=CL6'XREF'\n         TM    LE_STATUS_BYTE_04,BIT4\n         BO    *+10\n         MVC   RECORD+33(6),=CL6'NOXREF'\n         MVC   RECORD+40(6),=CL6'ZWB'\n         TM    LE_STATUS_BYTE_04,BIT5\n         BO    *+10\n         MVC   RECORD+40(6),=CL6'NOZWB'\n         MVC   RECORD+51(7),=CL7'NAME'\n         TM    LE_STATUS_BYTE_04,BIT6\n         BO    *+10\n         MVC   RECORD+51(7),=CL7'NONAME'\n         MVC   RECORD+62(8),=CL8'CMPR2'\n         TM    LE_STATUS_BYTE_04,BIT7\n         BO    *+10\n         MVC   RECORD+62(8),=CL8'NOCMPR2'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(12),=CL12'NUMCLS'  other Cobol\n         TM    LE_STATUS_BYTE_05,BIT1\n         BO    *+10\n         MVC   RECORD+1(12),=CL12'NONUMCLS'\n         CLI   LE_SWITCH,C'1'   COBOL/370\n         BNE   LE_370_42\n         CLC   LE_VERS(4),=C'0102'  Vers+Rel < 0102 COBOL MVS and VM\n         BL    LE_370_42             yes\n         MVC   RECORD+1(12),=CL12'NUMCLS(ALT)'\n         TM    LE_STATUS_BYTE_05,BIT1\n         BO    *+10\n         MVC   RECORD+1(12),=CL12'NUMCLS(PRIM)'\nLE_370_42 DS 0H\n         MVC   RECORD+16(7),=CL7'DBCS'\n         TM    LE_STATUS_BYTE_05,BIT2\n         BO    *+10\n         MVC   RECORD+16(7),=CL7'NODBCS'\n         MVC   RECORD+25(6),=CL6'AWO'\n         TM    LE_STATUS_BYTE_05,BIT3\n         BO    *+10\n         MVC   RECORD+25(6),=CL6'NOAWO'\n         CLI   LE_SWITCH,C'1'                  Cobol/370\n         BNE   LE_370_48                       no, jump around\n         MVC   RECORD+33(9),=CL9'EVENTS'       n/a COBOL/2\n         TM    LE_STATUS_BYTE_05,BIT5\n         BO    *+10\n         MVC   RECORD+33(9),=CL9'NOEVENTS'\n         MVC   RECORD+51(11),=CL11'CURRENCY'   n/a COBOL/2\n         TM    LE_STATUS_BYTE_05,BIT6\n         BO    *+10\n         MVC   RECORD+51(11),=CL11'NOCURRENCY'\nLE_370_48 DS 0H\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(40),=CL40'Compilation unit = Class'\n         TM    LE_STATUS_BYTE_05,BIT7\n         BO    *+10\n         MVC   RECORD+1(40),=CL40'Compilation unit = Program'\n         BAL   R14,SPACE1\n         MVC   RECORD+1(40),=CL40'User supplied reserved word list'\n         TM    LE_STATUS_BYTE_04,BIT2\n         BO    *+10\n         MVC   RECORD+1(40),=CL40'Installation default res. word list'  t'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         CLI   LE_SWITCH,C'1'   COBOL/370 ?\n         BNE   LE_370_50Z         no\n         CLC   LE_VERS(4),=C'0102'  Vers+Rel < 0102 COBOL MVS and VM\n         BL    LE_370_50Z         no\n*                         Supportet only for COBOL MVS and VM R2\n         MVC   RECORD+1(11),=CL11'RMODE(ANY)'\n         TM    LE_STATUS_BYTE_26,BIT0\n         BO    *+10\n         MVC   RECORD+1(11),=CL11'RMODE(24)'\n         MVC   RECORD+16(13),=CL13'TEST(STMT)'\n         TM    LE_STATUS_BYTE_26,BIT1\n         BO    *+10\n         MVC   RECORD+16(13),=CL13'NO TEST(STMT)'\n         MVC   RECORD+33(13),=CL13'TEST(PATH)'\n         TM    LE_STATUS_BYTE_26,BIT2\n         BO    *+10\n         MVC   RECORD+33(13),=CL13'NO TEST(PATH)'\n         MVC   RECORD+51(14),=CL14'TEST(BLOCK)'\n         TM    LE_STATUS_BYTE_26,BIT3\n         BO    *+10\n         MVC   RECORD+51(14),=CL14'NO TEST(BLOCK)'\n         MVC   RECORD+72(17),=CL17'OPT(FULL)'\n         TM    LE_STATUS_BYTE_26,BIT4\n         BO    *+10\n         MVC   RECORD+72(17),=CL17'NOOPT OR OPT(STD)'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(13),=CL13'INTDATE(LIL)'\n         TM    LE_STATUS_BYTE_26,BIT5\n         BO    *+10\n         MVC   RECORD+1(13),=CL13'INTDATE(ANSI)'\n         MVC   RECORD+16(3),=CL3'N/A'                            RS1000\n         CLC   LE_VERS(4),=C'0202'  Vers+Rel < 0202 COBOL MVS and VM\n         BL    LE_370_50Y           no lower                     RS1000\n         MVC   RECORD+16(14),=CL14'TEST(SEPARATE)'               RS1000\n         TM    LE_STATUS_BYTE_26,BIT6                            RS1000\n         BO    *+10                                              RS1000\n         MVC   RECORD+16(17),=CL17'NO TEST(SEPARATE)'            RS1000\nLE_370_50Y DS  0H\n         MVC   RECORD+35(22),=CL22'PGMNAME(LONGUPPER)'\n         TM    LE_STATUS_BYTE_27,BIT0\n         BO    *+10\n         MVC   RECORD+35(22),=CL22'NOT PGMNAME(LONGUPPER)'\n         MVC   RECORD+60(22),=CL22'PGMNAME(LONGMIXED)'\n         TM    LE_STATUS_BYTE_27,BIT1\n         BO    *+10\n         MVC   RECORD+60(22),=CL22'NOT PGMNAME(LONGMIXED)'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(5),=CL5'DLL'\n         TM    LE_STATUS_BYTE_27,BIT2\n         BO    *+10\n         MVC   RECORD+1(5),=CL5'NODLL'\n         MVC   RECORD+16(11),=CL11'EXPORTALL'\n         TM    LE_STATUS_BYTE_27,BIT3\n         BO    *+10\n         MVC   RECORD+16(11),=CL11'NOEXPORTALL'\n         MVC   RECORD+33(10),=CL10'DATEPROC'\n         TM    LE_STATUS_BYTE_27,BIT4\n         BO    *+10\n         MVC   RECORD+33(10),=CL10'NODATEPROC'\n         STRING (RECORD,,L),1X,'YEARWINDOW(',(LE_YEAR_WINDOW,H,R4B),   *\n               ')',INTO=RECORD\n         CLC   LE_VERS(4),=C'0202'  Vers+Rel < 0202 COBOL MVS and VM\n         BL    LE_370_50Z           no lower                     RS1000\n         MVC   RECORD+62(13),=CL13'ARITH(EXTEND)'                RS1000\n         TM    LE_STATUS_BYTE_27,BIT5                            RS1000\n         BO    *+10                                              RS1000\n         MVC   RECORD+62(13),=CL13'ARITH(COMPAT)'                RS1000\nLE_370_50Z DS 0H\n         BAL   R14,SPACE2\n         STRING '============ Additional information ================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE1\n         STRING '============ about DATA DIVISION    ================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         STRING 'Program use',' no',' QSAM or SAM access method',      *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT0\n         BNO   LE_370_51\n         STRING 'Program use',' QSAM or SAM access method',INTO=RECORD\nLE_370_51 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program use',' no',' VSAM sequential files',          *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT1\n         BNO   LE_370_52\n         STRING 'Program use',' VSAM sequential files',INTO=RECORD\nLE_370_52 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program use',' no',' VSAM indexed files',INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT2\n         BNO   LE_370_53\n         STRING 'Program use',' VSAM indexed files',INTO=RECORD\nLE_370_53 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program use',' no',' VSAM RBA files',INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT3\n         BNO   LE_370_54\n         STRING 'Program use',' VSAM RBA files',INTO=RECORD\nLE_370_54 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program use',' no',' CODE-SET (ASCII files)',         *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT4\n         BNO   LE_370_55\n         STRING 'Program use',' CODE-SET (ASCII files)',INTO=RECORD\nLE_370_55 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program use',' no',' spanned records',INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT5\n         BNO   LE_370_56\n         STRING 'Program use',' spanned records',INTO=RECORD\nLE_370_56 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' picture G (DBCS) items',         *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT6\n         BNO   LE_370_57\n         STRING 'Program has',' picture G (DBCS) items',INTO=RECORD\nLE_370_57 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' OCCURS DEPENDING ON items',      *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_06,BIT7\n         BNO   LE_370_58\n         STRING 'Program has',' OCCURS DEPENDING ON items',INTO=RECORD\nLE_370_58 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' SYNCHRONIZED clause',INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT0\n         BNO   LE_370_59\n         STRING 'Program has',' SYNCHRONIZED clause',INTO=RECORD\nLE_370_59 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' JUSTIFIED clause',INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT1\n         BNO   LE_370_60\n         STRING 'Program has',' JUSTIFIED clause',INTO=RECORD\nLE_370_60 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' POINTER items',INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT2\n         BNO   LE_370_61\n         STRING 'Program has',' POINTER items',INTO=RECORD\nLE_370_61 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' complex ODO clause',INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT3\n         BNO   LE_370_62\n         STRING 'Program has',' complex ODO clause',INTO=RECORD\nLE_370_62 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' external',                       *\n               ' floating-point items',                                *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT4\n         BNO   LE_370_63\n         STRING 'Program has',' external',' floating-point items',     *\n               INTO=RECORD\nLE_370_63 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' internal',                       *RD\n               ' floating-point items',                                *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT5\n         BNO   LE_370_63_1\n         STRING 'Program has',' internal',' floating-point items',     *\n               INTO=RECORD\nLE_370_63_1 DS 0H\n         CLI   LE_SWITCH,C'1'                  Cobol/370\n         BNE   LE_370_64                       no, jump around\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' procedure-pointer items',        *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT7       n/a cobol/2 or OS/VS COBOL\n         BNO   LE_370_64\n         STRING 'Program has',' procedure-pointer items',              *\n               INTO=RECORD\n         CLC   LE_VERS(4),=C'0202'  Vers+Rel < 0202 COBOL MVS and VM\n         BL    LE_370_64            no lower                     RS1000\n         BAL   R14,SPACE1\n         STRING 'Program has',' no',' Line-sequential file',           *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_07,BIT6\n         BNO   LE_370_64\n         STRING 'Program has',' Line-sequential file',                 *\n               INTO=RECORD\nLE_370_64 DS 0H\n         BAL   R14,SPACE2\n         STRING '============ Additional information    =============',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE1\n         STRING '============ about ENVIROMENT DIVISION =============',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         STRING 'Program use',' no',' FILE-STATUS clause',INTO=RECORD\n         TM    LE_STATUS_BYTE_08,BIT0\n         BNO   LE_370_66\n         STRING 'Program use',' FILE-STATUS clause',INTO=RECORD\nLE_370_66 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program use',' no',' RERUN clause in I/O-control',    *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_08,BIT1\n         BNO   LE_370_67\n         STRING 'Program has',' RERUN clause in I/O-control',          *\n               INTO=RECORD\nLE_370_67 DS 0H\n         BAL   R14,SPACE1\n         STRING 'Program use',' no',' UPSI switches',INTO=RECORD\n         TM    LE_STATUS_BYTE_08,BIT2\n         BNO   LE_370_68\n         STRING 'Program use',' UPSI switches',INTO=RECORD\nLE_370_68 DS 0H\n         BAL   R14,SPACE2\n         STRING '============ Additional information    =============',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE1\n         STRING '============ about PROCEDURE DIVISION  =============',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         STRING 'Following statements in control (check Y/N):',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(6),=CL6'Accept'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_09,BIT0\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(3),=CL3'Add'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_09,BIT1\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(5),=CL5'Alter'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_09,BIT2\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(4),=CL4'Call'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_09,BIT3\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(6),=CL6'Cancel'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_09,BIT4\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(5),=CL5'Close'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_09,BIT7\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(7),=CL7'Compute'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_10,BIT0\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(6),=CL6'Delete'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_10,BIT2\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(7),=CL7'Display'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_10,BIT4\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(6),=CL6'Divide'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_10,BIT5\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(11),=CL11'End-Perform'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_11,BIT1\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(5),=CL5'Enter'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_11,BIT2\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(5),=CL5'Entry'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_11,BIT3\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(4),=CL4'Exit'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_11,BIT4\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(5),=CL5'Go to'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_11,BIT6\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(2),=CL2'If'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_11,BIT7\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(10),=CL10'Initialize'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_12,BIT0\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         CLI   LE_SWITCH,C'1'   COBOL/370 ?\n         BNE   LE_370_70          no, jump around\n         MVC   RECORD+86(6),=CL6'Invoke'   comes with COBOL/370\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_12,BIT1\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\nLE_370_70 DS 0H\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(7),=CL7'Inspect'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_12,BIT2\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(5),=CL5'Merge'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_12,BIT3\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(4),=CL4'Move'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_12,BIT4\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(8),=CL8'Multiply'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_12,BIT5\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(4),=CL4'Open'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_12,BIT6\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(7),=CL7'Perform'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_12,BIT7\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(4),=CL4'Read'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_13,BIT0\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(7),=CL7'Release'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_13,BIT2\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(6),=CL6'Return'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_13,BIT3\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(7),=CL7'Rewrite'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_13,BIT4\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(6),=CL6'Search'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_13,BIT5\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(3),=CL3'Set'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_13,BIT7\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(4),=CL4'Sort'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_14,BIT0\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(5),=CL5'Start'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_14,BIT1\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(4),=CL4'Stop'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_14,BIT2\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(6),=CL6'String'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_14,BIT3\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(8),=CL8'Subtract'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_14,BIT4\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(8),=CL8'Unstring'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_14,BIT7\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(3),=CL3'Use'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_15,BIT0\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(5),=CL5'Write'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_15,BIT1\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(8),=CL8'Continue'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_15,BIT2\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(7),=CL7'End-Add'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_15,BIT3\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(8),=CL8'End-Call'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_15,BIT4\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(11),=CL11'End-Compute'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_15,BIT5\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(10),=CL10'End-Delete'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_15,BIT6\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(10),=CL10'End-Divide'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_15,BIT7\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(12),=CL12'End-Evaluate'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_16,BIT0\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(6),=CL6'End-If'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_16,BIT1\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(11),=CL11'End-Muliply'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_16,BIT2\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(8),=CL8'End-Read'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_16,BIT3\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(10),=CL10'End-Return'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_16,BIT4\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(11),=CL11'End-Rewrite'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_16,BIT5\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(10),=CL10'End-Search'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_16,BIT6\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(9),=CL9'End-Start'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_16,BIT7\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(10),=CL10'End-String'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_17,BIT0\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(12),=CL12'End-Subtract'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_17,BIT1\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(12),=CL12'End-Unstring'\n         MVI   RECORD+15,C'N'\n         TM    LE_STATUS_BYTE_17,BIT2\n         BNO   *+8\n         MVI   RECORD+15,C'Y'\n         MVC   RECORD+18(9),=CL9'End-Write'\n         MVI   RECORD+32,C'N'\n         TM    LE_STATUS_BYTE_17,BIT3\n         BNO   *+8\n         MVI   RECORD+32,C'Y'\n         MVC   RECORD+35(6),=CL6'Goback'\n         MVI   RECORD+49,C'N'\n         TM    LE_STATUS_BYTE_17,BIT4\n         BNO   *+8\n         MVI   RECORD+49,C'Y'\n         MVC   RECORD+52(9),=CL9'Evaluate'\n         MVI   RECORD+66,C'N'\n         TM    LE_STATUS_BYTE_17,BIT5\n         BNO   *+8\n         MVI   RECORD+66,C'Y'\n         MVC   RECORD+69(7),=CL7'Service'\n         MVI   RECORD+83,C'N'\n         TM    LE_STATUS_BYTE_17,BIT7\n         BNO   *+8\n         MVI   RECORD+83,C'Y'\n         MVC   RECORD+86(10),=CL10'End-Invoke'\n         MVI   RECORD+100,C'N'\n         TM    LE_STATUS_BYTE_18,BIT0\n         BNO   *+8\n         MVI   RECORD+100,C'Y'\n         BAL   R14,SPACE1\n         STRING '====================================================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         STRING 'No hexadecimal literals',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT0\n         BNO   LE_370_128\n         STRING 'Procedure include hexadecimal literals',INTO=RECORD\nLE_370_128 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No altered GO TO',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT1\n         BNO   LE_370_129\n         STRING 'Program contains altered GO TO',INTO=RECORD\nLE_370_129 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','I/O error declarative',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT2\n         BNO   LE_370_130\n         STRING 'I/O error declarative',INTO=RECORD\nLE_370_130 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Label declarative',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT3\n         BNO   LE_370_131\n         STRING 'Label declarative',INTO=RECORD\nLE_370_131 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Debugging declarative',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT4\n         BNO   LE_370_132\n         STRING 'Debugging declarative',INTO=RECORD\nLE_370_132 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Program segmentation',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT5\n         BNO   LE_370_133\n         STRING 'Program segmentation',INTO=RECORD\nLE_370_133 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Open Extend',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT6\n         BNO   LE_370_134\n         STRING 'Open Extend',INTO=RECORD\nLE_370_134 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Exit Program',INTO=RECORD\n         TM    LE_STATUS_BYTE_21,BIT7\n         BNO   LE_370_135\n         STRING 'Exit Program',INTO=RECORD\nLE_370_135 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No call literal',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT0\n         BNO   LE_370_136\n         STRING 'Call literal (static?), see options',INTO=RECORD\nLE_370_136 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Call identifier',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT1\n         BNO   LE_370_137\n         STRING 'Call identifier',INTO=RECORD\nLE_370_137 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Call on overflow',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT2\n         BNO   LE_370_138\n         STRING 'Call on overflow',INTO=RECORD\nLE_370_138 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Call length of',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT3\n         BNO   LE_370_139\n         STRING 'Call length of',INTO=RECORD\nLE_370_139 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Call address of',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT4\n         BNO   LE_370_140\n         STRING 'Call address of',INTO=RECORD\nLE_370_140 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Close reel/unit',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT5\n         BNO   LE_370_141\n         STRING 'Close reel/unit',INTO=RECORD\nLE_370_141 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Exponentiation used',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT6\n         BNO   LE_370_142\n         STRING 'Exponentiation used',INTO=RECORD\nLE_370_142 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Floating point items used',INTO=RECORD\n         TM    LE_STATUS_BYTE_22,BIT7\n         BNO   LE_370_143\n         STRING 'Floating point items used',INTO=RECORD\nLE_370_143 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Copy-Statements',INTO=RECORD\n         TM    LE_STATUS_BYTE_23,BIT0\n         BNO   LE_370_144\n         STRING 'Copy-Statements',INTO=RECORD\nLE_370_144 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Basis-Statements',INTO=RECORD\n         TM    LE_STATUS_BYTE_23,BIT1\n         BNO   LE_370_145\n         STRING 'Basis-Statements',INTO=RECORD\nLE_370_145 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','DBCS-Name in Program',INTO=RECORD\n         TM    LE_STATUS_BYTE_23,BIT2\n         BNO   LE_370_146\n         STRING 'DBCS-Name in Program',INTO=RECORD\nLE_370_146 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Shift-In/Shift-Out',INTO=RECORD\n         TM    LE_STATUS_BYTE_23,BIT3\n         BNO   LE_370_147\n         STRING 'Shift-In/Shift-Out',INTO=RECORD\nLE_370_147 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','DBCS literal',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT0\n         BNO   LE_370_148\n         STRING 'DBCS literal',INTO=RECORD\nLE_370_148 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Replace-Statements',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT1\n         BNO   LE_370_149\n         STRING 'Replace-Statements',INTO=RECORD\nLE_370_149 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Reference modification was used',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT2\n         BNO   LE_370_150\n         STRING 'Reference modification was used',INTO=RECORD\nLE_370_150 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Nested Program',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT3\n         BNO   LE_370_151\n         STRING 'Nested Program',INTO=RECORD\nLE_370_151 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','INITIAL Program',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT4\n         BNO   LE_370_152\n         STRING 'INITIAL Program',INTO=RECORD\nLE_370_152 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','COMMON Program',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT5\n         BNO   LE_370_153\n         STRING 'COMMON Program',INTO=RECORD\nLE_370_153 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Select Optional Files',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT6\n         BNO   LE_370_154\n         STRING 'Select Optional Files',INTO=RECORD\nLE_370_154 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','External Files',INTO=RECORD\n         TM    LE_STATUS_BYTE_24,BIT7\n         BNO   LE_370_155\n         STRING 'External Files',INTO=RECORD\nLE_370_155 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Global Files',INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT0\n         BNO   LE_370_156\n         STRING 'Global Files',INTO=RECORD\nLE_370_156 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Record is varying clause',INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT1\n         BNO   LE_370_157\n         STRING 'Record is varying clause',INTO=RECORD\nLE_370_157 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Accept from SYSIPT used in Label Declarative',  *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT2\n         BNO   LE_370_158\n         STRING 'Accept from SYSIPT used in Label Declarative',        *\n               INTO=RECORD\nLE_370_158 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Display upon SYSLST used in Label Declarative', *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT3\n         BNO   LE_370_159\n         STRING 'Display upon SYSLST used in Label Declarative',       *\n               INTO=RECORD\nLE_370_159 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Display upon SYSPCH used in Label Declarative', *\n               INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT4\n         BNO   LE_370_160\n         STRING 'Display upon SYSPCH used in Label Declarative',       *\n               INTO=RECORD\nLE_370_160 DS 0H\n         BAL   R14,SPACE1\n         STRING 'No ','Intrinsic function was used',INTO=RECORD\n         TM    LE_STATUS_BYTE_25,BIT5\n         BNO   LE_370_161\n         STRING 'Intrinsic function was used',INTO=RECORD\nLE_370_161 DS 0H\n         BAL   R14,SPACE1\n         STRING '============ End  ==================================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         LA    R15,0\n         B     COBANAL_EXIT\nINFO_COBOL DS 0H\n         CLI   C1_OEM_MOD_AREA,X'00' low-value ?                 RS0700\n         BE    INFO_COBOL_OEM                                    RS0700\n         STRING '============ OEM Modified Area =====================',*\n               '=============================================',        *RD\n               INTO=RECORD                                       RS0700\n         BAL   R14,SPACE2                                        RS0700\n         STRING ' ',C1_OEM_MOD_AREA,INTO=RECORD                  RS0700\n         BAL   R14,SPACE2                                        RS0700\nINFO_COBOL_OEM DS 0H                                             RS0700\n         STRING '============ Options in effect =====================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(8),=CL8'SYMDMP'\n         TM    C1_STATUS_BYTE_01,X'08'\n         BO    *+10\n         MVC   RECORD+1(8),=CL8'NOSYMDMP'\n         MVC   RECORD+10(6),=CL6'FLOW'\n         TM    C1_STATUS_BYTE_01,X'04'\n         BO    *+10\n         MVC   RECORD+10(6),=CL6'NOFLOW'\n         MVC   RECORD+17(7),=CL7'STATE'\n         TM    C1_STATUS_BYTE_01,X'02'\n         BO    *+10\n         MVC   RECORD+17(7),=CL7'NOSTATE'\n         MVC   RECORD+25(6),=CL6'OPT'\n         TM    C1_STATUS_BYTE_01,X'01'\n         BO    *+10\n         MVC   RECORD+25(6),=CL6'NOOPT'\n         MVC   RECORD+32(6),=CL6'TEST'\n         TM    C1_STATUS_BYTE_02,X'10'\n         BO    *+10\n         MVC   RECORD+32(6),=CL6'NOTEST'\n         MVC   RECORD+39(6),=CL6'RES'\n         TM    C1_STATUS_BYTE_03,X'80'\n         BO    *+10\n         MVC   RECORD+39(6),=CL6'NORES'\n         MVC   RECORD+46(8),=CL8'ENDJOB'\n         TM    C1_STATUS_BYTE_03,X'40'\n         BO    *+10\n         MVC   RECORD+46(8),=CL8'NOENDJOB'\n         MVC   RECORD+55(8),=CL8'OBJ370'\n         TM    C1_STATUS_BYTE_03,X'20'\n         BO    *+10\n         MVC   RECORD+55(8),=CL8'NOOBJ370'\n         MVC   RECORD+64(8),=CL8'COUNT'\n         TM    C1_STATUS_BYTE_03,X'08'\n         BO    *+10\n         MVC   RECORD+64(8),=CL8'NOCOUNT'\n         BAL   R14,SPACE1\n         MVC   RECORD,BLANKS\n         MVC   RECORD+1(11),=CL11'READY TRACE'\n         TM    C1_STATUS_BYTE_03,X'04'\n         BO    *+10\n         MVC   RECORD+1(11),=CL11'NO TRACE'\n         BAL   R14,SPACE1\n         STRING 'Sorry no more infomation for OS/VS COBOL',INTO=RECORD\n         BAL   R14,SPACE1\n         STRING 'You better upgrade to COBOL for OS/390 (MVS) and VM', *\n               INTO=RECORD\n         BAL   R14,SPACE1\n         STRING '============ End  ==================================',*\n               '=============================================',        *RD\n               INTO=RECORD\n         BAL   R14,SPACE2\n         LA    R15,0\n         B     COBANAL_EXIT\n*============================================================*\n* Print                                                      *\n*============================================================*\nSPACE2   DS 0H\n         ST    R14,SAVER14\n         LA    R1,SYSPRINT         GET OUTPUT DCB ADDRESS\n         LA    R0,RECORD           GET OBJECT NAME ADDRESS\n         PUT   (1),(0)             WRITE NAME TO NOTIFY DATA SET\n         LA    R1,SYSPRINT         GET OUTPUT DCB ADDRESS\n         LA    R0,BLANKS           GET OBJECT NAME ADDRESS\n         BAS   R14,AMODE24             AMode24\n         PUT   (1),(0)             WRITE NAME TO NOTIFY DATA SET\n         BAS   R14,AMODE31             AMode31\n         L     R14,SAVER14\n         BR    R14            return\nSPACE1   DS 0H\n         ST    R14,SAVER14\n         LA    R1,SYSPRINT         GET OUTPUT DCB ADDRESS\n         LA    R0,RECORD           GET OBJECT NAME ADDRESS\n         BAS   R14,AMODE24             AMode24\n         PUT   (1),(0)             WRITE NAME TO NOTIFY DATA SET\n         BAS   R14,AMODE31             AMode31\n         L     R14,SAVER14\n         BR    R14            return\n***************************************************************\n*\n*                  get Member Name from PDS-Directory\n*\n***************************************************************\nGETMEM   EQU   *\n         ST    R14,GETMSAVE            save return address\n         L     R4,ADBLKPTR             restore pointer\n         CLC   DIRAREA(2),=XL2'0000'   Directory present?\n         BNE   NEWNAME                   yes, get next\nNEWBLOCK EQU   *\n         BAS   R14,AMODE24             Amode24\n         GET   INPUT,DIRAREA           get a new directory\n         BAS   R14,AMODE31             Amode24\n         LA    R4,DIRAREA              get work area address\n         AH    R4,DIRAREA              + length\n         ST    R4,ADBLKEND             save ending address\n         LA    R4,DIRAREA+2            Skip LL bytes\n         ST    R4,ADBLKPTR             save pointer\nNEWNAME  EQU   *\n         C     R4,ADBLKEND             end of current dir block\n         BNL   NEWBLOCK                  yes, get new block\n         MVC   PGMNAME,0(R4)           Save member-name\n         IC    R5,11(R4)               LOOK FOR ANY USER TTRN'S\n         SLL   R5,27                   SHIFT OFF UNWANTED BITS\n         SRL   R5,26                   SHIFT BACK THE USABLE BI\n         LA    R4,12(R4,R5)            ADD DISPL TO GET OVER TT\n         ST    R4,ADBLKPTR             save Pointer next mem\n         L     R14,GETMSAVE            restore return address\n         BR    R14                     goback\nAMODE24  LA    R14,0(,R14)             remove XA bit\n         BSM   R0,R14                  return\n         SPACE 2\nAMODE31  O     R14,HIBIT               add XA bit\n         BSM   R0,R14                  return\n*\n*============================================================*\n* SONSTIGE DEFINITIONS                                       *\n*============================================================*\n****************************** CONSTANTS *****************************\nC_COBOL370 DC X'00',C'CEE'                   COBOL/370 ?  X'00C3C5C5'\nC_OPLINK   DC X'01',C'CEE'                   COBOL/370 ?  X'01C3C5C5'\nHIBIT    DC    A(X'80000000')         XA BIT CONSTANS\nBLANKS   DC    CL255' '           just blanks\nC_LSTO   OPEN  (*-*,(OUTPUT)),MF=L\nC_LSTOL  EQU   *-C_LSTO\nC_LSTI   OPEN  (*-*,(INPUT)),MF=L\nC_LSTIL  EQU   *-C_LSTI\nC_CLOSE  CLOSE (*-*),MF=L\nC_CLOSEL EQU   *-C_CLOSE\nXFF      DC    XL8'FFFFFFFFFFFFFFFF' just High-value\nSYSPRINT_FIX DCB   DSORG=PS,DDNAME=SYSPRINT,MACRF=PM,                  *\n               RECFM=FB,LRECL=121\nSYSPRINT_FIX_LENGTH EQU *-SYSPRINT_FIX   Length workarea\nINPUT_FIX DCB   DSORG=PS,DDNAME=COBANAL,MACRF=(GM),                    *\n               RECFM=U,BLKSIZE=256\n*INPUT_FIX DCB   DSORG=PO,DDNAME=COBANAL,MACRF=(R),                    *\n               RECFM=U,BLKSIZE=256\nINPUT_FIX_LENGTH EQU *-INPUT_FIX     Length workarea\n*\n*============================================================*\n* Workarea below the line                                    *\n*============================================================*\nCOBANAL_WORK        DSECT\nEYECATCHER          DS    CL8   'COBANAL'\nPGMNAME             DS    CL8   Pgmname from the parmlist\nSAVEAREA            DS    18F\nSAVER14             DS    F\nRETCODE             DS    F\nADR_COBANAL_WORK    DS    F     Save Workarea pointer\nADR_COBANAL_PARM    DS    F     Save Parmlist pointer\nADR_PGMNAME         DS    F     Save entry-point Application PGM\nRC_PGMNAME          DS    F     Save application RC\nPARM_LENGTH         DS    H     Parm length wihout header\nGETMSAVE            DS    F     Parm length wihout header\nADBLKPTR            DS    F     Parm length wihout header\nADBLKEND            DS    F     Parm length wihout header\nDOALL               DS    CL1   Analyze a complete loadlib\nDD_COBANAL          DS    CL1   Switch for DD CobAnal\nDOUBLE              DS    D\nCSV_LENGTH          DS    F     Length returned by CSVQuery\n         CSVQUERY MF=(L,CSVQRYWK)\n****************************** VARIABLES *****************************\nLE_SWITCH           DS    CL1   Switch for COBOL/370 or COBOL/2\nLE_PGM_NAME         DS CL8  name of program\nLE_COMP_YEAR        DS CL4  year of compilation\n*  3 bytes because of OS/VS COBOL\nLE_COMP_MONTH       DS CL3  month of compilation\nLE_COMP_DAY         DS CL2  day of compilation\nLE_COMP_HOURS       DS CL2  hours of compilation\nLE_COMP_MIN         DS CL2  minutes of compilation\nLE_COMP_SEC         DS CL2  seconds of compilation\nLE_VERS             DS CL2  version\nLE_REL              DS CL2  release\nLE_MOD              DS CL2  modification level\nLE_STATUS_BYTE      DS    0C   signature bytes\nLE_STATUS_BYTE_01   DS X    status byte\nLE_STATUS_BYTE_02   DS X    status byte\nLE_STATUS_BYTE_03   DS X    status byte\nLE_STATUS_BYTE_04   DS X    status byte\nLE_STATUS_BYTE_05   DS X    status byte\nLE_STATUS_BYTE_06   DS X    status byte\nLE_STATUS_BYTE_07   DS X    status byte\nLE_STATUS_BYTE_08   DS X    status byte\nLE_STATUS_BYTE_09   DS X    status byte\nLE_STATUS_BYTE_10   DS X    status byte\nLE_STATUS_BYTE_11   DS X    status byte\nLE_STATUS_BYTE_12   DS X    status byte\nLE_STATUS_BYTE_13   DS X    status byte\nLE_STATUS_BYTE_14   DS X    status byte\nLE_STATUS_BYTE_15   DS X    status byte\nLE_STATUS_BYTE_16   DS X    status byte\nLE_STATUS_BYTE_17   DS X    status byte\nLE_STATUS_BYTE_18   DS X    status byte\nLE_STATUS_BYTE_19   DS X    status byte\nLE_STATUS_BYTE_20   DS X    status byte\nLE_STATUS_BYTE_21   DS X    status byte\nLE_STATUS_BYTE_22   DS X    status byte\nLE_STATUS_BYTE_23   DS X    status byte\nLE_STATUS_BYTE_24   DS X    status byte\nLE_STATUS_BYTE_25   DS X    status byte\nLE_STATUS_BYTE_26   DS X    status byte Cobol for MVS and VM\nLE_STATUS_BYTE_27   DS X    status byte Cobol for MVS and VM\nLE_COBOL_SIGNAT     DS X    cobol signature level\nLE_DATA_STATEMENTS  DS XL4  number of data items\nLE_PROC_LINES       DS XL4  number of proc statements\nLE_YEAR_WINDOW      DS H    YearWindow\nSYSPRINT DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,                      *\n               RECFM=FB,LRECL=121\nINPUT    DCB   DSORG=PS,DDNAME=COBANAL,MACRF=(GM),                     *\n               RECFM=U,BLKSIZE=256\nDIRAREA             DS    XL256 PDS-Directory input area\nPARMLIST            DS XL40\nRECORD              DS CL132\nCOBANAL_WORK_LENGTH EQU *-COBANAL_WORK  Length workarea\n*\n*============================================================*\n* Parameter (JCL)                                            *\n*============================================================*\nCOBANAL_PARM        DSECT\nCOBANAL_PARM_LENGTH DS H\n*\n*\n*============================================================*\n* COBOL/370 DCL\n*============================================================*\nCOBOL_370_DSECT     DSECT\n                    DS CL4  bypass\nCEE_EYECATCHER      DS CL4  excatcher\nCEE_STACK_FRAME     DS F    stack frame size\nCEE_PPA1_OFFSET     DS F    offset to first ppa1\n                    DS CL4  reserved\nCEE_PPA1_START      DS 0C\nCEE_OFFSET          DS X    offset to length of name from ppa1\nCEE_SIGNATURE       DS X    CEL-Signature\nCEE_FLAG1           DS X    CEL-FLAGS Bitmask\nCEE_FLAG2           DS X    Member Flags for Cobol\nCEE_ADDRESS_OF_PPA2 DS F    Address of PPA2\nCEE_OFFSET_DBI      DS F    Offset BDI (None)\nCEE_EP_DESCRIPTOR   DS F    Entry Point Descriptor\nCEE_STACK_OVERFLOW  DS F    Offset for Stack overflow\n                    DS F    available word\n                    DS F    available word\n                    DS F    available word\n                    DS F    available word\nCEE_PRIMARY_EP      DS 0C\nCEE_PRI_EP_ADDRESS  DS A    primary entry-point address\nCEE_PGT_ADDRESS     DS A    PGT-Address\nCEE_TGT_ADDRESS     DS A    PGT-Address\nCEE_EP_NAME         DS A    Offset to entry_point_name\nCEE_CURRENT_EP      DS A    current EP-Address\nCEE_START           DS A    procedure code Address\nCEE_INIT_PROG       DS A    Initialize Routine\nCEE_PARM_LIST       DS A    Address of parm list for CEEINT\n                    DS F    available word\n                    DS H    available half-word\nCEE_LENGTH_NAME     DS XL2  length of program_name\nCEE_NAME_PART       DS 0C\nCEE_PGM_NAME        DS CL8  name of program\nCEE_COMP_YEAR       DS CL4  year of compilation\nCEE_COMP_MONTH      DS CL2  month of compilation\nCEE_COMP_DAY        DS CL2  day of compilation\nCEE_COMP_HOURS      DS CL2  hours of compilation\nCEE_COMP_MIN        DS CL2  minutes of compilation\nCEE_COMP_SEC        DS CL2  seconds of compilation\nCEE_VERS            DS CL2  version\nCEE_REL             DS CL2  release\nCEE_MOD             DS CL2  modification level\n                    DS F    available word\n                    DS H\nCEE_YEAR_WINDOW     DS H    YearWindow\nCEE_STATUS_BYTE_01  DS X    status byte\nCEE_STATUS_BYTE_02  DS X    status byte\nCEE_STATUS_BYTE_03  DS X    status byte\nCEE_STATUS_BYTE_04  DS X    status byte\nCEE_STATUS_BYTE_05  DS X    status byte\nCEE_STATUS_BYTE_06  DS X    status byte\nCEE_STATUS_BYTE_07  DS X    status byte\nCEE_STATUS_BYTE_08  DS X    status byte\nCEE_STATUS_BYTE_09  DS X    status byte\nCEE_STATUS_BYTE_10  DS X    status byte\nCEE_STATUS_BYTE_11  DS X    status byte\nCEE_STATUS_BYTE_12  DS X    status byte\nCEE_STATUS_BYTE_13  DS X    status byte\nCEE_STATUS_BYTE_14  DS X    status byte\nCEE_STATUS_BYTE_15  DS X    status byte\nCEE_STATUS_BYTE_16  DS X    status byte\nCEE_STATUS_BYTE_17  DS X    status byte\nCEE_STATUS_BYTE_18  DS X    status byte\nCEE_STATUS_BYTE_19  DS X    status byte\nCEE_STATUS_BYTE_20  DS X    status byte\nCEE_STATUS_BYTE_21  DS X    status byte\nCEE_STATUS_BYTE_22  DS X    status byte\nCEE_STATUS_BYTE_23  DS X    status byte\nCEE_COBOL_SIGNAT    DS X    cobol signature level\nCEE_DATA_STATEMENTS DS XL4  number of data items\nCEE_PROC_LINES      DS XL4  number of proc statements\nCEE_STATUS_BYTE_24  DS X    status byte\nCEE_STATUS_BYTE_25  DS X    status byte\nCEE_STATUS_BYTE_26  DS X    status byte\nCEE_STATUS_BYTE_27  DS X    status byte\n*============================================================*\n* COBOL2 DCL\n*============================================================*\nCOBOL_2_DSECT      DSECT\n                   DS CL4  bypass\n                   DS X\nC2_PGM_NAME        DS CL8  name of program\nC2_EYECATCHER      DS CL4  eyecatcher\nC2_VERS            DS CL2  version\nC2_REL             DS CL2  release\nC2_MOD             DS CL2  modification level\nC2_COMP_MONTH      DS CL2  month of compilation\n                   DS CL1\nC2_COMP_DAY        DS CL2  day of compilation\n                   DS CL1\nC2_COMP_YEAR       DS CL2  year of compilation\n                   DS CL1\nC2_COMP_HOURS      DS CL2  hours of compilation\n                   DS CL1\nC2_COMP_MIN        DS CL2  minutes of compilation\n                   DS CL1\nC2_COMP_SEC        DS CL2  seconds of compilation\nC2_GET_ENTRY       DS A    Address of address\nC2_STATUS_BYTE_01  DS X    status byte\nC2_STATUS_BYTE_02  DS X    status byte\nC2_STATUS_BYTE_03  DS X    status byte\nC2_STATUS_BYTE_04  DS X    status byte\nC2_STATUS_BYTE_05  DS X    status byte\nC2_STATUS_BYTE_06  DS X    status byte\nC2_STATUS_BYTE_07  DS X    status byte\nC2_STATUS_BYTE_08  DS X    status byte\nC2_STATUS_BYTE_09  DS X    status byte\nC2_STATUS_BYTE_10  DS X    status byte\nC2_STATUS_BYTE_11  DS X    status byte\nC2_STATUS_BYTE_12  DS X    status byte\nC2_STATUS_BYTE_13  DS X    status byte\nC2_STATUS_BYTE_14  DS X    status byte\nC2_STATUS_BYTE_15  DS X    status byte\nC2_STATUS_BYTE_16  DS X    status byte\nC2_STATUS_BYTE_17  DS X    status byte\nC2_STATUS_BYTE_18  DS X    status byte\nC2_STATUS_BYTE_19  DS X    status byte\nC2_STATUS_BYTE_20  DS X    status byte\nC2_STATUS_BYTE_21  DS X    status byte\nC2_STATUS_BYTE_22  DS X    status byte\nC2_STATUS_BYTE_23  DS X    status byte\n                   DS X    cobol signature level\nC2_DATA_STATEMENTS DS XL4  number of data items\nC2_PROC_LINES      DS XL4  number of proc statements\nC2_STATUS_BYTE_24  DS X    status byte\nC2_STATUS_BYTE_25  DS X    status byte\n                   DS XL2  status byte\n                   DS CL4  status byte\nC2_PRI_EP_ADDRESS  DS A    primary entry-point address\n*\n*============================================================*\n* OS/VS COBOL\n*============================================================*\nCOBOL_1_DSECT      DSECT\n                   DS CL12 bypass\nC1_PGM_NAME        DS CL8  name of program\nC1_EYECATCHER      DS CL2  eyecatcher\nC1_REL             DS CL2  release\n                   DS CL36\nC1_TGT_PTR         DS F    pointer to tgt\n                   DS CL8  unknown                               RS0700\nC1_OEM_MOD_AREA    DS CL60 Optimizer Info orgin COBOL low-values RS0700\n                   DS CL4  unknown                               RS0700\nC1_COMP_HOURS      DS CL2  hours of compilation\n                   DS CL1\nC1_COMP_MIN        DS CL2  minutes of compilation\n                   DS CL1\nC1_COMP_SEC        DS CL2  seconds of compilation\nC1_COMP_MONTH      DS CL3  month of compilation\n                   DS CL1\nC1_COMP_DAY        DS CL2  day of compilation\n                   DS CL2\nC1_COMP_YEAR       DS CL4  year of compilation\nCOBOL_1_TGT        DSECT\n                   DS CL72 ?\nC1_STATUS_BYTE_01  DS X    status byte\nC1_STATUS_BYTE_02  DS X    status byte\nC1_STATUS_BYTE_03  DS X    status byte\n                   DS CL369\nC1_CHECK           DS CL8  check TGT for SYSOUT\n*\n         DCBD    DSORG=QS\n         STRING GENERATE\nBIT0     EQU   B'10000000'\nBIT1     EQU   B'01000000'\nBIT2     EQU   B'00100000'\nBIT3     EQU   B'00010000'\nBIT4     EQU   B'00001000'\nBIT5     EQU   B'00000100'\nBIT6     EQU   B'00000010'\nBIT7     EQU   B'00000001'\n*------------------------------------------------------------*\n* Program equates                                            *\n*------------------------------------------------------------*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COBANL": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00!\\x01\\x014_\\x01\\x014_\\x11C\\x01\\x03\\x01\\x03\\x00\\x00\\xc5\\xe7\\xf3\\xf1\\xf0\\xf2\\xf2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-12-11T00:00:00", "modifydate": "2001-12-11T11:43:21", "lines": 259, "newlines": 259, "modlines": 0, "user": "EX31022"}, "text": "/*-------- REXX -------------------------------------------*/\n/* Function   : display Cobanl selection menu              */\n/*---------------------------------------------------------*/\n/*\n    trace ?r\n*/\n\n\"ispexec control errors return\"\nparse source xx yy procname rest\nsignal on syntax  name failures\nsignal on failure name failures\n\narg steplib  ,              /* steplib for cobanal pgm       */\n    cobaappl ,              /* applname for coba application */\n    cobahlq  ,              /* hlq for coba datasets         */\n    llqclib  ,              /* llq for exec und clist        */\n    llqmlib  ,              /* llq for mlib                  */\n    llqplib  ,              /* llq for plib                  */\n    llqslib  ,              /* llq for slib                  */\n    llqtlib  ,              /* llq for tlib                  */\n    llqtabl  ,              /* llq tabl                      */\n    account  ,\n    class    ,\n    msgclass ,\n    ispfhlq\n\nuserhlq = userid()\n\n\"ISPEXEC VPUT (STEPLIB COBAAPPL COBAHLQ USERHLQ)\"\n\"ISPEXEC VPUT (LLQCLIB LLQMLIB LLQPLIB LLQSLIB LLQTLIB LLQTABL)\"\n\"ISPEXEC VPUT (ACCOUNT CLASS MSGCLASS ISPFHLQ)\"\n\nSTART:\n\"ISPEXEC DISPLAY PANEL(COBANL)\"\n\nIF RC = 12 | RC = 20\nTHEN do\n  CALL COBA000 cobanl cobanl rc\n  EXIT\nend\n\nIF ZCMD = TRACE\nTHEN DO\n  zcmd = ' '\n  trace ?r\nend\n\nIF RC = 8\nTHEN do\n  \"ISPEXEC TBEND COBANL00\"\n  \"ISPEXEC TBEND COBANL01\"\n  \"ISPEXEC TBEND COBANL02\"\n  \"ISPEXEC TBEND COBANL03\"\n  \"ISPEXEC TBEND COBANL04\"\n  EXIT\nend\n\n\nselect\n  when zcmd = 1\n  then do\n    mess1   = 'Please edit the follwoing JCL to your '\n    mess2   = 'namings and submit the job'\n    mess3   = 'For permant change edit member COBANAL'\n    mess4   = 'in ISPSLIB dataset'\n    \"ISPEXEC ADDPOP ROW(03) COLUMN(10)\"\n    \"ISPEXEC DISPLAY PANEL(COBA000)\"\n    IF ZCMD = TRACE\n    THEN DO\n      zcmd = ' '\n      trace ?r\n    end\n    IF RC = 8\n    THEN do\n      \"ISPEXEC TBEND COBANL00\"\n      \"ISPEXEC TBEND COBANL01\"\n      \"ISPEXEC TBEND COBANL02\"\n      \"ISPEXEC TBEND COBANL03\"\n      \"ISPEXEC TBEND COBANL04\"\n      \"ISPEXEC REMPOP\"\n      signal start\n    end\n    mess    = 'please enter dsn of loadlib to analyse'\n    \"ISPEXEC REMPOP\"\n    \"ISPEXEC ADDPOP ROW(03) COLUMN(10)\"\n    \"ISPEXEC DISPLAY PANEL(COBANLLO)\"\n    IF ZCMD = TRACE\n    THEN DO\n      zcmd = ' '\n      trace ?r\n    end\n    IF RC = 8\n    THEN do\n      \"ISPEXEC TBEND COBANL00\"\n      \"ISPEXEC TBEND COBANL01\"\n      \"ISPEXEC TBEND COBANL02\"\n      \"ISPEXEC TBEND COBANL03\"\n      \"ISPEXEC TBEND COBANL04\"\n      \"ISPEXEC REMPOP\"\n      signal start\n    end\n    \"ISPEXEC REMPOP\"\n    \"ISPEXEC ADDPOP ROW(03) COLUMN(10)\"\n    \"ISPEXEC DISPLAY PANEL(COBANL04)\"\n    IF ZCMD = TRACE\n    THEN DO\n      zcmd = ' '\n      trace ?r\n    end\n    IF RC = 8\n    THEN do\n      \"ISPEXEC TBEND COBANL00\"\n      \"ISPEXEC TBEND COBANL01\"\n      \"ISPEXEC TBEND COBANL02\"\n      \"ISPEXEC TBEND COBANL03\"\n      \"ISPEXEC TBEND COBANL04\"\n      \"ISPEXEC REMPOP\"\n      signal start\n    end\n    \"ISPEXEC REMPOP\"\n    call cobasubp dsn t\n  end\n  when zcmd = 2 THEN CALL COBANLDS\n  when zcmd = 3\n  then do\n    call open_tables\n    sel = 'all cobol programs '\n    tkey1   = 'PGMKEY'\n    \"ispexec vput tkey1\"\n    call cobanldt ALL ,\n                  COBANL00 ,\n                  COBANL01 ,\n                  COBANL02 ,\n                  COBANL00 ,\n                  COBANLF0 ,\n                  COBANLL0 ,\n                  COBANLS0 ,\n                  COBANL  ,\n                  sel\n  end\n  when zcmd = 4\n  then do\n    call open_tables\n    sel = 'all cobol compile options'\n    tkey1   = 'OPTION'\n    \"ispexec vput tkey1\"\n    call cobanldt ALL ,\n                  COBANL01 ,\n                  COBANL00 ,\n                  COBANL02 ,\n                  COBANL01 ,\n                  COBANLF1 ,\n                  COBANLLI ,\n                  COBANLS1 ,\n                  COBANL  ,\n                  sel\n  end\n  when zcmd = 5\n  then do\n    call open_tables\n    sel = 'all cobol compiler versions'\n    tkey1   = 'COBVERS'\n    \"ispexec vput tkey1\"\n    call cobanldt ALL ,\n                  COBANL02 ,\n                  COBANL00 ,\n                  COBANL01 ,\n                  COBANL02 ,\n                  COBANLF2 ,\n                  COBANLLI ,\n                  COBANLS2 ,\n                  COBANL  ,\n                  sel\n  end\n  when zcmd = 6\n  then do\n    call open_tables\n    sel = 'all procedure division statements'\n    tkey1   = 'STMT'\n    \"ispexec vput tkey1\"\n    call cobanldt ALL ,\n                  COBANL03 ,\n                  COBANL00 ,\n                  COBANL01 ,\n                  COBANL07 ,\n                  COBANLF3 ,\n                  COBANLLI ,\n                  COBANLS3 ,\n                  COBANL  ,\n                  sel\n  end\n  when zcmd = 7\n  then do\n    call open_tables\n    sel = 'all analyzed loadlibs'\n    tkey1   = 'LOADLIB'\n    \"ispexec vput tkey1\"\n    call cobanldt ALL ,\n                  COBANL04 ,\n                  COBANL00 ,\n                  COBANL01 ,\n                  COBANL09 ,\n                  COBANLF2 ,\n                  COBANLL9 ,\n                  COBANLS2 ,\n                  COBANL  ,\n                  sel\n  end\n  when zcmd = 8\n  then do\n    call cobanlpg\n  end\n  when zcmd = 9\n  then do\n    call open_tables\n    tkey1   = 'OPTION'\n    \"ispexec vput tkey1\"\n    call cobanl03\n  end\n  when zcmd = 10\n  then do\n    zcmd = isplibd\n    \"ispexec display panel(ispllsa) command(zcmd)\"\n  end\n  when zcmd = 11\n  then do\n    call isrddn\n  end\n  when zcmd = 12\n  then do\n    zcmd = sarea\n    \"ispexec display panel(ispsammn) command(zcmd)\"\n  end\n  when zcmd = 13\n  then do\n    call cobasysi\n  end\n  otherwise  signal start\nend\n\nSIGNAL START\n\nEXIT\n\nopen_tables:\n\n\"ISPEXEC TBOPEN COBANL00 NOWRITE\"\n\"ISPEXEC TBOPEN COBANL01 NOWRITE\"\n\"ISPEXEC TBOPEN COBANL02 NOWRITE\"\n\"ISPEXEC TBOPEN COBANL03 NOWRITE\"\n\"ISPEXEC TBOPEN COBANL04 NOWRITE\"\n\nreturn\n\nfailures:\nsay  \"line = \" strip(sourceline(sigl))\nsay  \"Cond = \" condition('C') condition('D')\nsay  \"Error= \" errortext(rc)\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COBANLBL": {"ttr": 3841, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1b\\x00D\\x00\\x994\\x8f\\x01\\x023\\x0f\\x11P\\x02\\x9e\\x02A\\x00\\x00\\xc5\\xe7\\xf3\\xf1\\xf0\\xf2\\xf2@@@'", "ispf": {"version": "01.27", "flags": 0, "createdate": "1999-12-14T00:00:00", "modifydate": "2002-11-26T11:50:44", "lines": 670, "newlines": 577, "modlines": 0, "user": "EX31022"}, "text": "/*-------- REXX -------------------------------------------*/\n/* Function   : build cobanal tables                       */\n/*---------------------------------------------------------*/\n/*\n    trace ?r\n*/\n\narg ptyp loadlib\n\nsay 'create analyse report started'\nsay 'parameter ptyp    = ' ptyp\nsay 'parameter loadlib = ' loadlib\n\n\"ispexec control errors return\"\nparse source xx yy procname rest\nsignal on syntax  name failures\nsignal on failure name failures\n\nDSNAME   = LISTDSI(COBANAL FILE)\ndsname   = sysdsname\n\nif SYSDSN(\"'\"DSNAME\"'\") \u00ac= 'OK'\nthen do\n  say \"DSN = \" dsname \" notfound\"\n  exit\nend\n\n\"ISPEXEC EDIT DATASET('\"dsname\"') MACRO(COBA#MAC)\"\n\nif rc > 4\nthen do\n  say  \"/*----------------------------------------------------------*/\"\n  say  \"Error during editing listing dataset \"\n  say  \"Dataset = \" dsname\n  say  \"Returncode = \" rc\n  say  \"Possible reasons\"\n  say  \"1. Regionsize to low  ---> increase region size\"\n  say  \"2. Edit region size limited by installation modification\"\n  say  \"   via ISRCONFG parameter EDITSTOR\"\n  say  \"   ---> set parameter EDITSTOR to zero, increase region size\"\n  say  \"            if not possible, pray and asked your  \"\n  say  \"            systemprogrammer\"\n  say  \"3. Wrong input dataset\"\n  say  \"/*----------------------------------------------------------*/\"\n  zispfrc = 17\n  \"ispexec vput zispfrc shared\"\n  exit zispfrc\nend\n\n/*----- Cobal tables -----------------------------*/\n/*                                                */\n/*    COBANL00 Table Programm information         */\n/*    COBANL01 Table Option   information         */\n/*    COBANL02 Table Compiler information         */\n/*    COBANL03 Table procedur information         */\n/*    COBANL04 Table loadlib  information         */\n/*                                                */\n/*------------------------------------------------*/\n\n\"ISPEXEC TBEND    COBANL00\"\n\"ISPEXEC TBEND    COBANL01\"\n\"ISPEXEC TBEND    COBANL02\"\n\"ISPEXEC TBEND    COBANL03\"\n\"ISPEXEC TBEND    COBANL04\"\n\nloadlib  = strip(loadlib,L,' ')\n\nif ptyp  \u00ac= 'E'\nthen do\n  \"ISPEXEC TBERASE  COBANL00\"\n  names = \"COBREL COBVERS COMPREL COMPNAME COMPDATE COMPTIME ANZITEM ANZINSTR \"\n  names = names || \"O1 O2 O3 O4 O5 O6 O7 O8 O9 O10 O11 O12 O13 O14 O15 O16 O17 \"\n  names = names || \"O18 O19 O20 O21 O22 O23 O24 O25 O26 O27 O28 O29 O30 O31 \"\n  names = names || \"O32 O33 O34 O35 O36 O37 O38 O39 O40 O41 O42 O43 O44 O45 \"\n  names = names || \"P1 P2 P3 P4 P5 P6 P7 P8 P9 \"\n  names = names || \"P10 P11 P12 P13 P14 P15 P16 P17 P18 P19 \"\n  names = names || \"P20 P21 P22 P23 P24 P25 P26 P27 P28 P29 \"\n  names = names || \"P30 P31 P32 P33 P34 P35 P36 P37 P38 P39 \"\n  names = names || \"P40 P41 P42 P43 P44 P45 P46 P47 P48 P49 \"\n  names = names || \"P50 P51 P52 P53 P54 P55 P56 P57 P58 P59 \"\n  names = names || \"P60 P61 P62 P63 P64 P65 P66 P67 P68 P69 \"\n  names = names || \"PGMNAME LOADLIB\"\n  \"ISPEXEC TBCREATE COBANL00 KEYS(PGMKEY) NAMES(\"names\")\"\n\n \"ISPEXEC TBERASE  COBANL01\"\n \"ISPEXEC TBCREATE COBANL01 KEYS(OPTION) NAMES(FN ANZPGM)\"\n\n \"ISPEXEC TBERASE  COBANL02\"\n \"ISPEXEC TBCREATE COBANL02 KEYS(COBVERS) NAMES(COBREL ANZPGM)\"\n\n \"ISPEXEC TBERASE  COBANL03\"\n \"ISPEXEC TBCREATE COBANL03 KEYS(STMT) NAMES(FN ANZPGM)\"\n\n \"ISPEXEC TBERASE  COBANL04\"\n \"ISPEXEC TBCREATE COBANL04 KEYS(LOADLIB)\n          NAMES (ANZPGMCO ANZCOBVS ANZCOBII ANZCOB37 REPDAY REPDATE)\"\nend\nelse do\n  \"ISPEXEC TBOPEN   COBANL04\"\n  \"ispexec tbget cobanl04\"\n  if rc = 0\n  then do\n    say  \"loadlib = \" loadlib \" already analyzed\"\n    \"ISPEXEC TBCLOSE  COBANL04\"\n    exit\n  end\n  \"ISPEXEC TBOPEN   COBANL00\"\n  \"ISPEXEC TBOPEN   COBANL01\"\n  \"ISPEXEC TBOPEN   COBANL02\"\n  \"ISPEXEC TBOPEN   COBANL03\"\nend\n\nrepday   = '---n/a---'\nanzpgmco = 0\nanzcobvs = 0\nanzcobii = 0\nanzcob37 = 0\n\nrepdate  = date('E')\n\nif sysvar(systsoe) >= 2060 then repday = date('W',repdate,'E')\n\n\"EXECIO 1 DISKR COBANAL\"\nparse PULL RECORD\n\"EXECIO 1 DISKR COBANAL\"\n\nIF RC = 2\nTHEN\n  EOF = J\nELSE\n  EOF = N\n\nDO WHILE EOF = N\n  parse PULL RECORD\n  select\n    when pos('was loaded',record) > 0\n    then do\n      do i     = 1 to 70\n        fn1    = 'o'||i\n        ini    = ' '\n        call     value fn1,ini\n        fn1    = 'p'||i\n        call     value fn1,ini\n      end\n      cobrel   = 'NO Cobol'\n      cobvers  = 'n/a'\n      comprel  = 'n/a'\n      compname = 'n/a'\n      compdate = 'n/a'\n      comptime = 'n/a'\n      anzitem  = 'n/a'\n      anzinstr = 'n/a'\n      pgmname  = word(record,3)\n      pgmkey   = pgmname||loadlib\n      \"ispexec tbadd cobanl00\"\n    end\n    when pos('= Info =',record) > 0\n    then do\n      \"EXECIO 1 DISKR COBANAL\"\n      parse PULL RECORD\n      call pgm_record\n    end\n    when pos('= Timestamps =',record) > 0\n    then do\n      \"EXECIO 1 DISKR COBANAL\"\n      parse PULL RECORD\n      call timestamp_record\n    end\n    when pos('= Statistics =',record) > 0\n    then do\n      \"EXECIO 1 DISKR COBANAL\"\n      parse PULL RECORD\n      call statistic_record\n    end\n    when pos('= Options in effect =',record) > 0\n    then do\n      \"EXECIO 1 DISKR COBANAL\"\n      parse PULL RECORD\n      call option_record\n      if cobrel     = 'OS/VS'\n      then\n        \"ispexec tbmod cobanl00\"\n    end\n    when pos('PROCEDURE DIVISION',record) > 0\n    then do\n      \"EXECIO 1 DISKR COBANAL\"\n      parse PULL RECORD\n      call procedure_record\n      \"ispexec tbmod cobanl00\"\n    end\n    otherwise\n  end\n  \"EXECIO 1 DISKR COBANAL\"\n  IF RC = 2\n  THEN DO\n    EOF = J\n  END\nEND\n\n\"EXECIO 0 DISKR COBANAL (FINIS\"\n\"FREE F(COBANAL)\"\n\n\"ISPEXEC TBMOD   COBANL04\"\n\n\"ISPEXEC TBSORT  COBANL00 FIELDS(PGMNAME)\"\n\"ISPEXEC TBSORT  COBANL01 FIELDS(OPTION)\"\n\"ISPEXEC TBSORT  COBANL02 FIELDS(COBREL,C,A,COBVERS,C,A)\"\n\"ISPEXEC TBSORT  COBANL03 FIELDS(STMT)\"\n\"ISPEXEC TBSORT  COBANL04 FIELDS(LOADLIB)\"\n\n\"ISPEXEC TBCLOSE COBANL00\"\n\"ISPEXEC TBCLOSE COBANL01\"\n\"ISPEXEC TBCLOSE COBANL02\"\n\"ISPEXEC TBCLOSE COBANL03\"\n\"ISPEXEC TBCLOSE COBANL04\"\n\nsay 'create analyse report ended'\n\nexit\n\npgm_record:\n\npgmname       = word(record,2)\npgmkey        = pgmname||loadlib\ncobrel        = word(record,4)\ncobvers       = word(record,6)\n\nif cobrel     = \"COBOL\"\nthen do\n  cobvers     = word(record,5)\nend\n\nif cobrel     = \"OS/VS\"\nthen do\n  cobvers     = word(record,7)\nend\n\nselect\n  when cobvers  = \"Enterprise\"\n  then do\n    cobrel      = cobrel || '/' || cobvers\n    cobvers     = 'V' || word(record,7)\n    cobvers     = strip(cobvers,T,'.')\n    cobvers     = cobvers || 'R' || word(record,9)\n    cobvers     = strip(cobvers,T,'.')\n    cobvers     = cobvers || 'M' || word(record,11)\n    cobvers     = strip(cobvers,T,'.')\n  end\n  when cobvers   \u00ac= \"R1\"\n  then do\n    cobvers     = 'V' || word(record,6)\n    cobvers     = strip(cobvers,T,'.')\n    cobvers     = cobvers || 'R' || word(record,8)\n    cobvers     = strip(cobvers,T,'.')\n    cobvers     = cobvers || 'M' || word(record,10)\n    cobvers     = strip(cobvers,T,'.')\n  end\n  otherwise\nend\n\n\"ispexec        tbget cobanl02\"\nif rc         > 0\nthen do\n  anzpgm      = 1\n  \"ispexec      tbadd cobanl02\"\nend\nelse do\n  anzpgm      = anzpgm + 1\n  \"ispexec      tbmod cobanl02\"\nend\n\npcomprel      = pos('Version',record)\nif pcomprel   = 0\nthen do\n  pcomprel    = pos('Release',record)\nend\ncomprel       = substr(record,pcomprel)\n\nreturn\n\ntimestamp_record:\n\ncompname      = word(record,4)\n\n\"EXECIO 1 DISKR COBANAL\"\nparse PULL RECORD\n\ncompdate      = word(record,2)\n\nif cobrel     = 'OS/VS'\nthen do\n  comptime    = word(record,4)\n  anzcobvs    = anzcobvs + 1\nend\nelse do\n  if cobrel     = 'COBOL/2'\n  then do\n    if cobvers  = 'V1R1M0' | cobvers = 'V1R2M0'\n    then do\n      comptime  = word(record,7)\n      compdate  = word(record,4)\n    end\n    else do\n      wordindd  = wordpos(\"(european)\",record)\n      compdate  = word(record,wordindd+1)\n      wordindt  = wordpos('Time:',record)\n      comptime  = word(record,wordindt+1)\n    end\n    if pos('??',compdate) > 0\n    then do\n      p1        = pos('??',compdate)\n      if substr(compdate,p1+2,2)  > 70 then oj = 19\n                                       else oj = 20\n      compdate  = overlay(oj,compdate,p1)\n    end\n    anzcobii    = anzcobii + 1\n  end\n  else do\n    comptime    = word(record,7)\n    compdate    = word(record,4)\n    anzcob37    = anzcob37 + 1\n  end\nend\n\nif pos('??',compdate) > 0\nthen do\n  jp   = pos('??',compdate)\n  compyear  = substr(compdate,jp+2,2)\n  if compyear > '70'\n  then compdate = overlay('19',compdate,jp)\n  else compdate = overlay('20',compdate,jp)\nend\n\nanzpgmco      = anzpgmco + 1\n\nanzitem       = 'n/a'\nanzinstr      = 'n/a'\n\nreturn\n\nstatistic_record:\n\nanzitem       = word(record,6)\n\n\"EXECIO 1 DISKR COBANAL\"\nparse PULL RECORD\nanzinstr      = word(record,4)\n\nreturn\n\noption_record:\n\ndo i   = 1 to 70\n  fn1  = 'o'||i\n  ini  = ' '\n  call   value fn1,ini\n  fn1  = 'p'||i\n  call   value fn1,ini\nend\n\ni      = 0\n\nnword  = words(record)\n\ndo j   = 1 to nword\n  i    = i + 1\n  fn   = 'o'||i\n  call   value fn,word(record,j)\n  option='OPTION'\n  call   value option,word(record,j)\n  call   update_options\nend\n\n\"EXECIO 1 DISKR COBANAL\"\nparse PULL RECORD\n\nnword  = words(record)\n\ndo j   = 1 to nword\n  i    = i + 1\n  fn   = 'o'||i\n  call   value fn,word(record,j)\n  option='OPTION'\n  call   value option,word(record,j)\n  call   update_options\nend\n\nif cobrel     = 'OS/VS' then return\n\n\"EXECIO 1 DISKR COBANAL\"\nparse PULL RECORD\n\nnword  = words(record)\n\ndo j   = 1 to nword\n  i    = i + 1\n  fn   = 'o'||i\n  call   value fn,word(record,j)\n  option='OPTION'\n  call   value option,word(record,j)\n  call   update_options\nend\n\n\"EXECIO 1 DISKR COBANAL\"\nparse PULL RECORD\n\nnword  = words(record)\n\ndo j   = 1 to nword\n  i    = i + 1\n  fn   = 'o'||i\n  call   value fn,word(record,j)\n  option='OPTION'\n  call   value option,word(record,j)\n  call   update_options\nend\n\n\"EXECIO 1 DISKR COBANAL\"\nparse PULL RECORD\n\nnword  = words(record)\n\ndo j   = 1 to nword\n  i    = i + 1\n  fn   = 'o'||i\n  call   value fn,word(record,j)\n  option='OPTION'\n  call   value option,word(record,j)\n  call   update_options\nend\n\nreturn\n\nupdate_options:\n\n\"ispexec        tbget cobanl01\"\nif rc         > 0\nthen do\n  anzpgm      = 1\n  \"ispexec      tbadd cobanl01\"\nend\nelse do\n  anzpgm      = anzpgm + 1\n  \"ispexec      tbmod cobanl01\"\nend\n\nreturn\n\nprocedure_record:\n\ni      = 0\n\nnword  = words(record)\n\ndo j   = 1 to nword\n  i    = i + 1\n  fn   = 'p'||i\n  if word(record,j+1) = 'Y'\n  then do\n    call   value fn,word(record,j)\n    option='STMT'\n    call   value option,word(record,j)\n    call   update_stmt\n  end\n  j = j + 1\nend\n\n\"EXECIO 1 DISKR COBANAL\"\nparse PULL RECORD\n\nnword  = words(record)\n\ndo j   = 1 to nword\n  i    = i + 1\n  fn   = 'p'||i\n  if word(record,j+1) = 'Y'\n  then do\n    call   value fn,word(record,j)\n    option='STMT'\n    call   value option,word(record,j)\n    call   update_stmt\n  end\n  j = j + 1\nend\n\n\"EXECIO 1 DISKR COBANAL\"\nparse PULL RECORD\n\nnword  = words(record)\n\ndo j   = 1 to nword\n  i    = i + 1\n  fn   = 'p'||i\n  if word(record,j+1) = 'Y'\n  then do\n    call   value fn,word(record,j)\n    option='STMT'\n    call   value option,word(record,j)\n    call   update_stmt\n  end\n  j = j + 1\nend\n\n\"EXECIO 1 DISKR COBANAL\"\nparse PULL RECORD\n\nnword  = words(record)\n\ndo j   = 1 to nword\n  i    = i + 1\n  fn   = 'p'||i\n  if word(record,j+1) = 'Y'\n  then do\n    call   value fn,word(record,j)\n    option='STMT'\n    call   value option,word(record,j)\n    call   update_stmt\n  end\n  j = j + 1\nend\n\n\"EXECIO 1 DISKR COBANAL\"\nparse PULL RECORD\n\nnword  = words(record)\n\ndo j   = 1 to nword\n  i    = i + 1\n  fn   = 'p'||i\n  if word(record,j+1) = 'Y'\n  then do\n    call   value fn,word(record,j)\n    option='STMT'\n    call   value option,word(record,j)\n    call   update_stmt\n  end\n  j = j + 1\nend\n\n\"EXECIO 1 DISKR COBANAL\"\nparse PULL RECORD\n\nnword  = words(record)\n\ndo j   = 1 to nword\n  i    = i + 1\n  fn   = 'p'||i\n  if word(record,j+1) = 'Y'\n  then do\n    call   value fn,word(record,j)\n    option='STMT'\n    call   value option,word(record,j)\n    call   update_stmt\n  end\n  j = j + 1\nend\n\n\"EXECIO 1 DISKR COBANAL\"\nparse PULL RECORD\n\nnword  = words(record)\n\ndo j   = 1 to nword\n  i    = i + 1\n  fn   = 'p'||i\n  if word(record,j+1) = 'Y'\n  then do\n    call   value fn,word(record,j)\n    option='STMT'\n    call   value option,word(record,j)\n    call   update_stmt\n  end\n  j = j + 1\nend\n\n\"EXECIO 1 DISKR COBANAL\"\nparse PULL RECORD\n\nnword  = words(record)\n\ndo j   = 1 to nword\n  i    = i + 1\n  fn   = 'p'||i\n  if word(record,j+1) = 'Y'\n  then do\n    call   value fn,word(record,j)\n    option='STMT'\n    call   value option,word(record,j)\n    call   update_stmt\n  end\n  j = j + 1\nend\n\n\"EXECIO 1 DISKR COBANAL\"\nparse PULL RECORD\n\nnword  = words(record)\n\ndo j   = 1 to nword\n  i    = i + 1\n  fn   = 'p'||i\n  if word(record,j+1) = 'Y'\n  then do\n    call   value fn,word(record,j)\n    option='STMT'\n    call   value option,word(record,j)\n    call   update_stmt\n  end\n  j = j + 1\nend\n\n\"EXECIO 1 DISKR COBANAL\"\nparse PULL RECORD\n\nnword  = words(record)\n\ndo j   = 1 to nword\n  i    = i + 1\n  fn   = 'p'||i\n  if word(record,j+1) = 'Y'\n  then do\n    call   value fn,word(record,j)\n    option='STMT'\n    call   value option,word(record,j)\n    call   update_stmt\n  end\n  j = j + 1\nend\n\nif cobrel    \u00ac= 'COBOL/Enterprise' then return\n\n\"EXECIO 1 DISKR COBANAL\"\nparse PULL RECORD\n\ndo j   = 1 to nword\n  i    = i + 1\n  fn   = 'p'||i\n  if word(record,j+1) = 'Y'\n  then do\n    call   value fn,word(record,j)\n    option='STMT'\n    call   value option,word(record,j)\n    call   update_stmt\n  end\n  j = j + 1\nend\n\nreturn\n\nupdate_stmt:\n\n\"ispexec        tbget cobanl03\"\nif rc         > 0\nthen do\n  anzpgm      = 1\n  \"ispexec      tbadd cobanl03\"\nend\nelse do\n  anzpgm      = anzpgm + 1\n  \"ispexec      tbmod cobanl03\"\nend\n\nreturn\n\nfailures:\nsay  record\nsay  \"line = \" strip(sourceline(sigl))\nsay  \"Cond = \" condition('C') condition('D')\nsay  \"Error= \" errortext(rc)\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COBANLDS": {"ttr": 513, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*-------- REXX -------------------------------------------*/\n/* Function   : display cobanal output                     */\n/*---------------------------------------------------------*/\n/*\n    trace ?r\n*/\n\ndsnlist = userid()||\".COBANAL.LISTING\"\ndsnedit = userid()||\".COBANAL.LISTEDIT\"\n\n\"ispexec control errors return\"\nparse source xx yy procname rest\nsignal on syntax  name failures\nsignal on failure name failures\n\nstart:\n\"ISPEXEC ADDPOP ROW(03) COLUMN(10)\"\n\"ISPEXEC DISPLAY PANEL(COBANLDS)\"\n\nIF RC = 12 | RC = 20\nTHEN do\n  \"ISPEXEC REMPOP\"\n  EXIT\nend\n\nIF ZCMD = TRACE\nTHEN DO\n  zcmd = ' '\n  trace ?r\nend\n\nIF RC = 8\nTHEN do\n  \"ISPEXEC REMPOP\"\n  EXIT\nend\n\n\"ISPEXEC REMPOP\"\n\nif zcmd  = 1 then dsn = dsnlist\n             else dsn = dsnedit\n\nif SYSDSN(\"'\"DSN\"'\") \u00ac= 'OK'\nthen do\n  mess = 'dataset ' dsn sysdsn(\"'\"dsn\"'\")\n  signal start\nend\n\n\"ISPEXEC VIEW DATASET('\"dsn\"')\"\n\nsignal start\n\nfailures:\nsay  \"line = \" strip(sourceline(sigl))\nsay  \"Cond = \" condition('C') condition('D')\nsay  \"Error= \" errortext(rc)\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COBANLDT": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x01\\x01\\x01%O\\x01\\x01%O\\x10\\x12\\x00\\xae\\x00\\xaf\\x00\\x00\\xc5\\xe7\\xf3\\xf1\\xf0\\xf2\\xf2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2001-09-11T00:00:00", "modifydate": "2001-09-11T10:12:01", "lines": 174, "newlines": 175, "modlines": 0, "user": "EX31022"}, "text": "/*-------- REXX -------------------------------------------*/\n/* Function   : display information from table             */\n/* callers    : cob application                            */\n/* parameter  : kz        selection type                   */\n/*            : table     table to display                 */\n/*            : table2    table to process                 */\n/*            : table3    table to process                 */\n/*            : panel     panel to display                 */\n/*            : filtproc  name of filter procedure         */\n/*            : lineproc  name of line selection procedure */\n/*            : sortproc  name of sort selection procedure */\n/*            : fromproc  name of calling procedure        */\n/*            : sel       selection comment                */\n/*---------------------------------------------------------*/\n/*\n   trace ?r\n*/\n\n\"ispexec   control errors return\"\nparse      source xx yy procname rest\nsignal     on syntax  name failures\nsignal     on failure name failures\n\n\"ispexec   vget (tkey1 debug)\"\n\narg        kz  ,                   /*    reference /mark       */\n           table    ,              /*    tablename             */\n           table2   ,              /*    tablename             */\n           table3   ,              /*    tablename             */\n           panel    ,              /*    panel to display      */\n           filtproc ,              /*    procedure for filter  */\n           lineproc ,              /*    procedure line select */\n           fromproc ,              /*    calling procname      */\n           sel\n\ncursor   = 'zcmd'\nzcmd     = ' '\nanzscan  = 0\n\nif kz    = 'ALL' then rowsv = kz\nelse do\n  rowsv  = SCAN\n  signal display\n  rc     = 0\n  do while rc = 0\n    \"ISPEXEC TBSCAN \" table\n    if rc     > 0 then leave\n    anzscan   = anzscan + 1\n  end\nend\n\n/*------------------------------------------------------------*/\n/*   Display table information                                */\n/*------------------------------------------------------------*/\n\ndisplay:\na        = \"\"\n\"ispexec   tbdispl \" table \" panel(\"panel\") cursor(\"cursor\")\"\n\nif rc    = 12 | rc = 20\nthen do\n  call     coba000 procname panel rc\n  exit\nend\n\nif substr(zcmd,1,6) = filter\nthen do\n  if sel = 'FILTERLINE'\n  then do\n    fi   = length(zcmd)\n    if fi > 6\n    then do\n      zparm    =  substr(zcmd,8,fi-6)\n      if zparm = 'CLEAR'\n      then do\n        \"ispexec setmsg msg(coba006) msgloc(zcmd)\"\n        \"ispexec vput zparm\"\n      end\n    end\n    zcmd     =  substr(zcmd,1,6)\n    \"ispexec vput zcmd\"\n    exit\n  end\n  fi     = length(zcmd)\n  if fi  > 6\n  then do\n    zparm    =  substr(zcmd,8,fi-6)\n    if zparm = 'CLEAR'\n    then do\n      \"ispexec setmsg msg(coba006) msgloc(zcmd)\"\n      signal display\n    end\n  end\n  zcmd   = \" \"                /*  zcmd clear wegen Abfrage in   */\n  \"ispexec vput zcmd\"         /*  in Filtproc                   */\n  filtproc 'FI'     ,\n           table    ,\n           table2   ,\n           table3   ,\n           panel    ,\n           filtproc ,\n           lineproc ,\n           fromproc ,\n           'filterline'\n  zcmd   = ' '\n  csel   = ' '\n  f1     = \"\"\n  f2     = \"\"\n  f3     = \"\"\n  f4     = \"\"\n  f5     = \"\"\n  f6     = \"\"\n  f7     = \"\"\n  f8     = \"\"\n  f9     = \"\"\n  signal     display\nend\n\nif zcmd = 'TRACE' | csel = 'TR'\nthen do\n  zcmd  = ' '\n  csel  = ' '\n  trace ?r\nend\n\nif rc = 8\nthen do\n  zcmd   = \" \"                /*  zcmd clear wegen Abfrage in   */\n  \"ispexec vput zcmd\"         /*  in Filtproc                   */\n  exit\nend\n\nif rc = 0\nthen do\n  if substr(zcmd,1,1) = 'F' | substr(zcmd,1,1) = 'L'\n  then do\n    fi = length(zcmd)\n    if fi < 3\n    then do\n      \"ispexec setmsg msg(coba001)\"\n      signal display\n    end\n    else do\n      call value tkey1,substr(zcmd,3,fi-2)\n      \"ispexec tbtop \" table\n      \"ispexec tbscan \" table \" arglist(\"tkey1\") condlist(ge)\"\n      signal display\n    end\n  end\nend\n\ndo while ztdsels > 0\n  if a = 'S' | a = '/'\n  then do\n    lineproc value(tkey1) table table2 fromproc a\n  end\n  if a = 'X'\n  then do\n    cobanllx value(tkey1) table table2 fromproc a\n  end\n  if ztdsels = 1 then signal display\n  \"ispexec tbdispl \" table\nend\n\nsignal display\n\nexit\n\nfailures:\nline = strip(sourceline(sigl))\ncond = condition('c') condition('d')\n\"ispexec vput (cond line)\"\ncall cobasynt procname sigl errortext(rc) /* show what went wrong */\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COBANLF0": {"ttr": 261, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*-------- REXX -------------------------------------------*/\n/* Function   : cobol information select program info      */\n/*---------------------------------------------------------*/\n/*\n   TRACE ?R\n*/\n\n\"ispexec control errors return\"\nparse source xx yy procname rest\nsignal on syntax  name failures\nsignal on failure name failures\n\narg           kz       ,\n              table    ,\n              table2   ,\n              table3   ,\n              panel    ,\n              filtproc ,\n              lineproc ,\n              fromproc ,\n              sel\n\n\"ispexec vget (csel f1 f2 f3)\"\n\nIF f1 = \"\" & f2 = \"\" & f3 = \"\"\nthen nop\nelse do\n  v1   = EQ\n  v2   = EQ\n  v3   = EQ\n  kz   = FS\n  signal filter_done\nend\n\nSTART:\ncall fill_names\n\"ISPEXEC ADDPOP ROW(03) COLUMN(10)\"\n\"ISPEXEC DISPLAY PANEL(COBAFI10)\"\n\nIF RC = 12 | RC = 20\nTHEN do\n  CALL coba000 procname cobafi10 RC\n  \"ISPEXEC REMPOP\"\n  EXIT\nend\n\nIF ZCMD = TRACE\nTHEN DO\n  zcmd = ' '\n  trace ?r\nend\n\nIF RC = 8\nTHEN do\n  \"ISPEXEC REMPOP\"\n  EXIT\nend\n\n\"ISPEXEC REMPOP\"\n\nif substr(zcmd,1,6) = filter\nthen do\n  fi = length(zcmd)\n  if fi > 6\n  then do\n    zparm =  substr(zcmd,8,fi-6)\n    if zparm = 'CLEAR'\n    then do\n      \"ispexec setmsg msg(coba006) msgloc(zcmd)\"\n      f1 = \"\"\n      f2 = \"\"\n      f3 = \"\"\n      zparm  = \"\"\n      \"ispexec vput zparm\"\n      signal start\n    end\n  end\n  signal start\nend\n\nIF f1 = \"\" & f2 = \"\" & f3 = \"\"\nTHEN do\n  MESS1 = \"no filter criteria specified\"\n  \"ISPEXEC ADDPOP\"\n  \"ISPEXEC DISPLAY PANEL(coba000)\"\n  \"ISPEXEC REMPOP\"\n  signal start\nend\n\n\"ispexec vput (f1 f2 f3)\"\n\nfilter_done:\n\n\"ISPEXEC TBVCLEAR \" table\n\nfieldn = \"\"\n\nif f1 > \"\"\nthen do\n  field  = 'PGMNAME,'\n  field  = field||v1\n  fieldn = field\n  pkomma = pos(',',field)\n  name   = substr(field,1,pkomma-1)\n  f1n    = name\n  if pos('*',f1) = 0 then f1 = f1||'*'\n  fieldv = f1\n  call value name,fieldv\nend\n\nif f2 > \"\"\nthen do\n  field  = 'COBREL,'\n  field  = field||v2\n  if fieldn \u00ac= \"\" then fieldn = fieldn||','\n  fieldn = fieldn || field\n  pkomma = pos(',',field)\n  name   = substr(field,1,pkomma-1)\n  f2n    = name\n  if pos('*',f2) = 0 then f2 = f2||'*'\n  fieldv = f2\n  call value name,fieldv\nend\n\nif f3 > \"\"\nthen do\n  field  = 'COBVERS,'\n  field  = field||v3\n  if fieldn \u00ac= \"\" then fieldn = fieldn||','\n  fieldn = fieldn || field\n  pkomma = pos(',',field)\n  name   = substr(field,1,pkomma-1)\n  f3n    = name\n  if pos('*',f3) = 0 then f3 = f3||'*'\n  fieldv = f3\n  call value name,fieldv\nend\n\ntabname = 'R'||time('S')\n\n\"ISPEXEC TBQUERY\" table \" KEYS(TKEYS) KEYNUM(TKEYNUM) NAMES(TNAMES)\"\n\"ISPEXEC TBSARG \" table \" NEXT NAMECOND(\"fieldn\")\"\n\n\"ISPEXEC TBERASE  \" tabname\n\"ISPEXEC TBCREATE \" TABNAME \" KEYS\"TKEYS \"NOWRITE NAMES\"TNAMES\n\nrc = 0\nrecfound = n\n\ndo while rc = 0\n  \"ISPEXEC TBSCAN \" table\n  if rc > 0 then leave\n  \"ISPEXEC TBADD \" tabname \" MULT(1000)\"\n  recfound = y\nend\n\nIF recfound = n\nTHEN do\n  MESS1 = \"no rows with searchargument found\"\n  MESS2 = \"searchargument \"\n  MESS3 = f1n \" = \" f1\n  MESS4 = f2n \" = \" f2\n  MESS5 = f3n \" = \" f3\n  \"ISPEXEC ADDPOP\"\n  \"ISPEXEC DISPLAY PANEL(coba000)\"\n  \"ISPEXEC REMPOP\"\n  \"ISPEXEC TBEND\" tabname\n  signal start\nend\n\n\"ISPEXEC TBTOP \" tabname\n\ncall cobanldt ALL      ,\n              tabname  ,\n              table2   ,\n              table3   ,\n              panel    ,\n              filtproc ,\n              lineproc ,\n              COBANLF0 ,\n              sel\n\n\"ISPEXEC TBEND \" tabname\n\n\"ispexec vget (zparm zcmd)\"\n\nif zcmd     = FILTER\nthen do\n  if zparm  = 'CLEAR'\n  then do\n    f1      = \"\"\n    f2      = \"\"\n    f3      = \"\"\n    zparm   = \"\"\n    \"ispexec  vput zparm\"\n  end\n  signal      start\nend\n\nif kz       = FI then signal start\n\nf1          = \"\"\nf2          = \"\"\nf3          = \"\"\n\n\"ispexec      vput (f1 f2 f3)\"\n\nexit\n\nfill_names:\n\nf1n    = 'Program'\nf1K    = 'Name of program(s) to select'\nf2n    = 'Cobol'\nf2K    = 'Cobol version (COBOL/VS,COBOL/2)'\nf3n    = 'Compiler'\nf3K    = 'Compiler Version'\n\nreturn\n\nfailures:\nline = strip(sourceline(sigl))\nCond = condition('C') condition('D')\n\"ispexec vput (cond line)\"\ncall cobasynt procname sigl errortext(rc) /* show what went wrong */\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COBANLF1": {"ttr": 11, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*-------- REXX -------------------------------------------*/\n/* Function   : cobol information select program info      */\n/*---------------------------------------------------------*/\n/*\n   TRACE ?R\n*/\n\n\"ispexec control errors return\"\nparse source xx yy procname rest\nsignal on syntax  name failures\nsignal on failure name failures\n\narg           kz       ,\n              table    ,\n              table2   ,\n              table3   ,\n              panel    ,\n              filtproc ,\n              lineproc ,\n              fromproc ,\n              sel\n\n\"ispexec vget (csel f1)\"\n\nIF f1 = \"\"\nthen nop\nelse do\n  v1    = EQ\n  v2    = EQ\n  v3    = EQ\n  kz    = FS\n  signal filter_done\nend\n\nSTART:\ncall fill_names\n\"ISPEXEC ADDPOP ROW(03) COLUMN(10)\"\n\"ISPEXEC DISPLAY PANEL(COBAFI10)\"\n\nIF RC = 12 | RC = 20\nTHEN do\n  CALL coba000 procname cobafi10 RC\n  \"ISPEXEC REMPOP\"\n  EXIT\nend\n\nIF ZCMD = TRACE\nTHEN DO\n  zcmd = ' '\n  trace ?r\nend\n\nIF RC = 8\nTHEN do\n  \"ISPEXEC REMPOP\"\n  EXIT\nend\n\n\"ISPEXEC REMPOP\"\n\nif substr(zcmd,1,6) = filter\nthen do\n  fi = length(zcmd)\n  if fi > 6\n  then do\n    zparm =  substr(zcmd,8,fi-6)\n    if zparm = 'CLEAR'\n    then do\n      \"ispexec setmsg msg(coba006) msgloc(zcmd)\"\n      f1 = \"\"\n      zparm  = \"\"\n      \"ispexec vput zparm\"\n      signal start\n    end\n  end\n  signal start\nend\n\nIF f1 = \"\"\nTHEN do\n  MESS1 = \"no filter criteria specified\"\n  \"ISPEXEC ADDPOP\"\n  \"ISPEXEC DISPLAY PANEL(coba000)\"\n  \"ISPEXEC REMPOP\"\n  signal start\nend\n\n\"ispexec vput (f1)\"\n\nfilter_done:\n\n\"ISPEXEC TBVCLEAR \" table\n\nfieldn = \"\"\n\nif f1 > \"\"\nthen do\n  field  = 'OPTION,'\n  field  = field||v1\n  fieldn = field\n  pkomma = pos(',',field)\n  name   = substr(field,1,pkomma-1)\n  f1n    = name\n  if pos('*',f1) = 0 then f1 = f1||'*'\n  fieldv = f1\n  call value name,fieldv\nend\n\ntabname = 'R'||time('S')\n\n\"ISPEXEC TBQUERY\" table \" KEYS(TKEYS) KEYNUM(TKEYNUM) NAMES(TNAMES)\"\n\"ISPEXEC TBSARG \" table \" NEXT NAMECOND(\"fieldn\")\"\n\n\"ISPEXEC TBERASE  \" tabname\n\"ISPEXEC TBCREATE \" TABNAME \" KEYS\"TKEYS \"NOWRITE NAMES\"TNAMES\n\nrc = 0\nrecfound = n\n\ndo while rc = 0\n  \"ISPEXEC TBSCAN \" table\n  if rc > 0 then leave\n  \"ISPEXEC TBADD \" tabname \" MULT(1000)\"\n  recfound = y\nend\n\nIF recfound = n\nTHEN do\n  MESS1 = \"no rows with searchargument found\"\n  MESS2 = \"searchargument \"\n  MESS3 = f1n \" = \" f1\n  \"ISPEXEC ADDPOP\"\n  \"ISPEXEC DISPLAY PANEL(coba000)\"\n  \"ISPEXEC REMPOP\"\n  \"ISPEXEC TBEND\" tabname\n  signal start\nend\n\n\"ISPEXEC TBTOP \" tabname\n\ncall cobanldt kz       ,\n              tabname  ,\n              table2   ,\n              table3   ,\n              panel    ,\n              filtproc ,\n              lineproc ,\n              COBANLF1 ,\n              sel\n\n\"ISPEXEC TBEND \" tabname\n\n\"ispexec vget (zparm zcmd)\"\n\nif zcmd     = FILTER\nthen do\n  if zparm  = 'CLEAR'\n  then do\n    f1      = \"\"\n    zparm   = \"\"\n    \"ispexec  vput zparm\"\n  end\n  signal      start\nend\n\nif kz       = FI then signal start\n\nf1          = \"\"\n\n\"ispexec      vput (f1)\"\n\nexit\n\nfill_names:\n\nf1n    = 'Option '\nf1K    = 'select cobol option'\nf2n    = ' '\nf2K    = ' '\nf3n    = ' '\nf3K    = ' '\n\nreturn\n\nfailures:\nline = strip(sourceline(sigl))\nCond = condition('C') condition('D')\n\"ispexec vput (cond line)\"\ncall cobasynt procname sigl errortext(rc) /* show what went wrong */\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COBANLF3": {"ttr": 13, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*-------- REXX -------------------------------------------*/\n/* Function   : cobol information select statement info    */\n/*---------------------------------------------------------*/\n/*\n   TRACE ?R\n*/\n\n\"ispexec control errors return\"\nparse source xx yy procname rest\nsignal on syntax  name failures\nsignal on failure name failures\n\narg           kz       ,\n              table    ,\n              table2   ,\n              table3   ,\n              panel    ,\n              filtproc ,\n              lineproc ,\n              fromproc ,\n              sel\n\n\"ispexec vget (csel f1)\"\n\nIF f1 = \"\"\nthen nop\nelse do\n  v1    = EQ\n  v2    = EQ\n  v3    = EQ\n  kz    = FS\n  signal filter_done\nend\n\nSTART:\ncall fill_names\n\"ISPEXEC ADDPOP ROW(03) COLUMN(10)\"\n\"ISPEXEC DISPLAY PANEL(COBAFI10)\"\n\nIF RC = 12 | RC = 20\nTHEN do\n  CALL coba000 procname cobafi10 RC\n  \"ISPEXEC REMPOP\"\n  EXIT\nend\n\nIF ZCMD = TRACE\nTHEN DO\n  zcmd = ' '\n  trace ?r\nend\n\nIF RC = 8\nTHEN do\n  \"ISPEXEC REMPOP\"\n  EXIT\nend\n\n\"ISPEXEC REMPOP\"\n\nif substr(zcmd,1,6) = filter\nthen do\n  fi = length(zcmd)\n  if fi > 6\n  then do\n    zparm =  substr(zcmd,8,fi-6)\n    if zparm = 'CLEAR'\n    then do\n      \"ispexec setmsg msg(coba006) msgloc(zcmd)\"\n      f1 = \"\"\n      zparm  = \"\"\n      \"ispexec vput zparm\"\n      signal start\n    end\n  end\n  signal start\nend\n\nIF f1 = \"\"\nTHEN do\n  MESS1 = \"no filter criteria specified\"\n  \"ISPEXEC ADDPOP\"\n  \"ISPEXEC DISPLAY PANEL(coba000)\"\n  \"ISPEXEC REMPOP\"\n  signal start\nend\n\n\"ispexec vput (f1)\"\n\nfilter_done:\n\n\"ISPEXEC TBVCLEAR \" table\n\nfieldn = \"\"\n\nif f1 > \"\"\nthen do\n  field  = 'STMT,'\n  field  = field||v1\n  fieldn = field\n  pkomma = pos(',',field)\n  name   = substr(field,1,pkomma-1)\n  f1n    = name\n  if pos('*',f1) = 0 then f1 = f1||'*'\n  fieldv = f1\n  call value name,fieldv\nend\n\ntabname = 'R'||time('S')\n\n\"ISPEXEC TBQUERY\" table \" KEYS(TKEYS) KEYNUM(TKEYNUM) NAMES(TNAMES)\"\n\"ISPEXEC TBSARG \" table \" NEXT NAMECOND(\"fieldn\")\"\n\n\"ISPEXEC TBERASE  \" tabname\n\"ISPEXEC TBCREATE \" TABNAME \" KEYS\"TKEYS \"NOWRITE NAMES\"TNAMES\n\nrc = 0\nrecfound = n\n\ndo while rc = 0\n  \"ISPEXEC TBSCAN \" table\n  if rc > 0 then leave\n  \"ISPEXEC TBADD \" tabname \" MULT(1000)\"\n  recfound = y\nend\n\nIF recfound = n\nTHEN do\n  MESS1 = \"no rows with searchargument found\"\n  MESS2 = \"searchargument \"\n  MESS3 = f1n \" = \" f1\n  \"ISPEXEC ADDPOP\"\n  \"ISPEXEC DISPLAY PANEL(coba000)\"\n  \"ISPEXEC REMPOP\"\n  \"ISPEXEC TBEND\" tabname\n  signal start\nend\n\n\"ISPEXEC TBTOP \" tabname\n\ncall cobanldt kz       ,\n              tabname  ,\n              table2   ,\n              table3   ,\n              panel    ,\n              filtproc ,\n              lineproc ,\n              COBANLF3 ,\n              sel\n\n\"ISPEXEC TBEND \" tabname\n\n\"ispexec vget (zparm zcmd)\"\n\nif zcmd     = FILTER\nthen do\n  if zparm  = 'CLEAR'\n  then do\n    f1      = \"\"\n    zparm   = \"\"\n    \"ispexec  vput zparm\"\n  end\n  signal      start\nend\n\nif kz       = FI then signal start\n\nf1          = \"\"\n\n\"ispexec      vput (f1)\"\n\nexit\n\nfill_names:\n\nf1n    = 'Statement'\nf1K    = 'select cobol procedure division statement'\nf2n    = ' '\nf2K    = ' '\nf3n    = ' '\nf3K    = ' '\n\nreturn\n\nfailures:\nline = strip(sourceline(sigl))\nCond = condition('C') condition('D')\n\"ispexec vput (cond line)\"\ncall cobasynt procname sigl errortext(rc) /* show what went wrong */\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COBANLLI": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00T\\x01\\x01%O\\x01\\x01%O\\x10\\x12\\x00e\\x00`\\x00\\x00\\xc5\\xe7\\xf3\\xf1\\xf0\\xf2\\xf2@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2001-09-11T00:00:00", "modifydate": "2001-09-11T10:12:54", "lines": 101, "newlines": 96, "modlines": 0, "user": "EX31022"}, "text": "/*-------- REXX -------------------------------------------*/\n/* Function   : select cobanal programs                    */\n/* caller     : general table display procedure            */\n/*---------------------------------------------------------*/\n/*\n    trace ?r\n*/\n\n\"ispexec control errors return\"\nparse source xx yy procname rest\nsignal on syntax  name failures\nsignal on failure name failures\n\nparse arg selection table table2 fromproc a sel\n\n\n\"ispexec vget tkey1\"\nztkey1   = tkey1\ntkey1    = 'PGMKEY'\n\"ispexec vput tkey1\"\n\nselect\n  when ztkey1 = 'OPTION'\n  then do\n    option    = selection\n  end\n  when ztkey1 = 'LOADLIB'\n  then do\n    fn        = 'LOADLIB'\n    loadlib   = selection\n    sel      = 'all programs from library ' selection\n  end\n  when ztkey1 = 'COBVERS'\n  then do\n    fn        = 'COBVERS'\n    cobvers   = selection\n    sel      = 'all programs compiler ' selection\n  end\n  when ztkey1 = 'STMT'\n  then do\n    fn        = 'STMT'\n    stmt      = selection\n    sel      = 'all programs with statement ' selection\n  end\n  otherwise do\n    MESS1 = \"invalid option specified\"\n    MESS2 = \"searchargument follows\"\n    MESS3 = 'TKEY1 = ' ztkey1\n    MESS4 = 'Selection = ' selection\n    \"ISPEXEC ADDPOP\"\n    \"ISPEXEC DISPLAY PANEL(COBA000)\"\n    \"ISPEXEC REMPOP\"\n    signal finish\n  end\nend\n\n\"ispexec tbget \" table\n\ncall value fn,selection\n\n\"ISPEXEC TBSARG \" table2 \" NEXT NAMECOND(\"fn\",EQ)\"\n\nIF rc > 0\nTHEN do\n  MESS1 = \"no rows with searchargument found\"\n  MESS2 = \"searchargument follows\"\n  MESS3 = 'TKEY1 = ' ztkey1\n  MESS4 = 'Selection = ' selection\n  \"ISPEXEC ADDPOP\"\n  \"ISPEXEC DISPLAY PANEL(COBA000)\"\n  \"ISPEXEC REMPOP\"\n  signal finish\nend\n\nif sel  = \"\"\nthen\n  Sel = 'programs with compile option ' option                            000038\n\ncall cobanldt 'OP'     ,\n              table2   ,\n              table2   ,\n              table3   ,\n              COBANL00 ,\n              COBANLF0 ,\n              COBANLL0 ,\n              COBANLLI ,\n              sel\n\nfinish:\ntkey1    = ztkey1\n\"ispexec vput tkey1\"\n\nexit\n\nfailures:\nline = strip(sourceline(sigl))\nCond = condition('C') condition('D')\n\"ispexec vput (cond line)\"\nparse source x y procname z\ncall cobasynt procname sigl errortext(rc) /* show what went wrong */\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COBANLLX": {"ttr": 265, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*-------- REXX -------------------------------------------*/\n/* Function   : select cobanal programs                    */\n/* caller     : general table display procedure            */\n/*---------------------------------------------------------*/\n/*\n    trace ?r\n*/\n\n\"ispexec control errors return\"\nparse source xx yy procname rest\nsignal on syntax  name failures\nsignal on failure name failures\n\narg selection table table2 fromproc a\n\n\"ispexec vget tkey1\"\nztkey1   = tkey1\ntkey1    = 'PGMKEY'\n\"ispexec vput tkey1\"\n\nselect\n  when ztkey1 = 'OPTION'\n  then do\n    option    = selection\n  end\n  when ztkey1 = 'COBVERS'\n  then do\n    fn        = 'COBVERS'\n    cobvers   = selection\n  end\n  when ztkey1 = 'STMT'\n  then do\n    fn        = 'STMT'\n    stmt      = selection\n  end\n  when ztkey1 = 'LOADLIB'\n  then do\n    fn        = 'LOADLIB'\n    loadlib   = selection\n  end\n  otherwise do\n    MESS1 = \"invalid option specified\"\n    MESS2 = \"searchargument follows\"\n    MESS3 = 'TKEY1 = ' ztkey1\n    MESS4 = 'Selection = ' selection\n    \"ISPEXEC ADDPOP\"\n    \"ISPEXEC DISPLAY PANEL(COBA000)\"\n    \"ISPEXEC REMPOP\"\n    signal finish\n  end\nend\n\n\"ispexec tbget \" table\n\ncall value fn,selection\n\n\"ISPEXEC TBQUERY\" table2 \" KEYS(TKEY) KEYNUM(TKEYNUM) NAMES(TNAMES)\"\n\ntabname     = 'R'||time('S')\n\n\"ISPEXEC TBERASE \" tabname\n\n\"ISPEXEC TBCREATE \" TABNAME \" KEYS\"TKEY \"NOWRITE NAMES\"TNAMES\n\nrc          = 0\nrecfound    = n\n\n\"ISPEXEC TBSARG \" table2 \" NEXT NAMECOND(\"fn\")\"\n\ndo while rc = 0\n  \"ISPEXEC TBSCAN \" table2\n  if rc     > 0 then leave\n  \"ISPEXEC TBADD \" tabname \" MULT(1000)\"\n  recfound  = y\nend\n\nIF recfound = n\nTHEN do\n  MESS1 = \"no rows with searchargument found\"\n  MESS2 = \"searchargument follows\"\n  \"ISPEXEC ADDPOP\"\n  \"ISPEXEC DISPLAY PANEL(COBA000)\"\n  \"ISPEXEC REMPOP\"\n  \"ISPEXEC TBEND\" tabname\n  signal finish\nend\n\n\"ISPEXEC TBTOP \" tabname\n\nSel = 'programs with ' ztkey1 '=' selection\n\ncall cobanldt 'ALL'    ,\n              tabname  ,\n              table2   ,\n              table3   ,\n              COBANL00 ,\n              COBANLF0 ,\n              COBANLL0 ,\n              COBANLLI ,\n              sel\n\nfinish:\ntkey1    = ztkey1\n\"ispexec vput tkey1\"\n\nexit\n\nfailures:\nline = strip(sourceline(sigl))\nCond = condition('C') condition('D')\n\"ispexec vput (cond line)\"\nparse source x y procname z\ncall cobasynt procname sigl errortext(rc) /* show what went wrong */\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COBANLL0": {"ttr": 263, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*-------- REXX -------------------------------------------*/\n/* Function   : display cobanal programm compiler options  */\n/*---------------------------------------------------------*/\n/*\n    trace ?r\n*/\n\narg pgmkey rest\n\n\"ispexec tbget cobanl00\"\n\n\"ispexec control errors return\"\nparse source xx yy procname rest\nsignal on syntax  name failures\nsignal on failure name failures\n\nstart:\n\"ISPEXEC ADDPOP ROW(03) COLUMN(10)\"\n\"ISPEXEC DISPLAY PANEL(COBANLL0)\"\n\nIF RC = 12 | RC = 20\nTHEN do\n  CALL COBA000 procname  procname rc\n  \"ISPEXEC REMPOP\"\n  EXIT\nend\n\nIF ZCMD = TRACE\nTHEN DO\n  zcmd = ' '\n  trace ?r\nend\n\nIF RC = 8\nTHEN do\n  \"ISPEXEC REMPOP\"\n  EXIT\nend\n\n\"ISPEXEC REMPOP\"\n\nif COBREL = 'VS/COBOL'\nthen do\n  mess1   = 'no more information for VS/COBOL program'\n  \"ISPEXEC ADDPOP ROW(03) COLUMN(10)\"\n  \"ISPEXEC DISPLAY PANEL(COBA000)\"\n  \"ISPEXEC REMPOP\"\n  signal start\nend\n\ndo i   = 1 to 59\n  fn1  = 's'||i\n  ini  = ' '\n  call   value fn1,ini\nend\n\nj      = 0\n\ndo i   = 1 to 59\n  fn1  = 'f'||i\n  fn2  = 'p'||i\n  if value(fn2) > \"\"\n  then do\n    j  = j + 1\n    fn3= 's'||j\n    call   value fn3,value(fn2)\n  end\nend\n\n\"ISPEXEC ADDPOP ROW(03) COLUMN(10)\"\n\"ISPEXEC DISPLAY PANEL(COBANL08)\"\n\nIF RC = 12 | RC = 20\nTHEN do\n  CALL COBA000 procname cobanl08 rc\n  \"ISPEXEC REMPOP\"\n  EXIT\nend\n\nIF ZCMD = TRACE\nTHEN DO\n  zcmd = ' '\n  trace ?r\nend\n\nIF RC = 8\nTHEN do\n  \"ISPEXEC REMPOP\"\n  EXIT\nend\n\n\"ISPEXEC REMPOP\"\n\nsignal start\n\nexit\n\nfailures:\nsay  \"line = \" strip(sourceline(sigl))\nsay  \"Cond = \" condition('C') condition('D')\nsay  \"Error= \" errortext(rc)\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COBANLL9": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00Y\\x01\\x01%O\\x01\\x01%O\\x10\\x01\\x00s\\x00s\\x00\\x00\\xc5\\xe7\\xf3\\xf1\\xf0\\xf2\\xf2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2001-09-11T00:00:00", "modifydate": "2001-09-11T10:01:59", "lines": 115, "newlines": 115, "modlines": 0, "user": "EX31022"}, "text": "/*-------- REXX -------------------------------------------*/\n/* Function   : display information for loadlibs           */\n/* callers    : coba application                           */\n/*---------------------------------------------------------*/\n/*\n    trace ?r\n*/\n\n\"ispexec control errors return\"\nparse source xx yy procname rest\nsignal on syntax  name failures\nsignal on failure name failures\n\narg loadlib table table2 fromproc a\n\n\"ispexec tbget \" table\n\n\"ispexec vget tkey1\"\nztkey1   = tkey1\n\nSTART:\n\"ISPEXEC ADDPOP ROW(05) COLUMN(04)\"\n\"ISPEXEC DISPLAY PANEL(COBANLL9)\"\n\nIF RC = 12 | RC = 20\nTHEN do\n  CALL COBA000 procname procname RC\n  \"ISPEXEC REMPOP\"\n  EXIT\nend\n\nIF ZCMD = TRACE\nTHEN DO\n  zcmd = ' '\n  trace ?r\nend\n\nIF RC = 8\nTHEN do\n  tkey1    = ztkey1                                                       000050\n  \"ispexec vput tkey1\"                                                    000051\n  \"ISPEXEC REMPOP\"\n  EXIT\nend\n\n\"ISPEXEC REMPOP\"\n\nselect\n  when zcmd   = 1\n  then do\n    tkey1    = ztkey1                                                       0000\n    \"ispexec vput tkey1\"                                                    0000\n    call cobanlli loadlib table table2 COBANLL9 zcmd\n    signal start\n  end\n  when zcmd   = 2\n  then do\n    cobrel    = 'OS/VS'\n    ausw      = 'Cobol/VS '\n  end\n  when zcmd   = 3\n  then do\n    cobrel    = 'COBOL/2'\n    ausw      = 'Cobol/II '\n  end\n  when zcmd   = 4\n  then do\n    cobrel    = 'COBOL/370'\n    ausw      = 'Cobol/370 '\n  end\n  when zcmd   = 5\n  then do\n    call cobai34 'DSN' loadlib\n    signal start\n  end\n  otherwise signal start\nEND\n\nfn        = 'COBREL,EQ,LOADLIB,EQ'\nausw      = ausw 'programs from library' loadlib\ntkey1     = 'PGMKEY'\n\"ispexec vput tkey1\"\n\n\"ISPEXEC TBSARG COBANL00 NEXT NAMECOND(\"fn\")\"\n\nIF rc > 0\nTHEN do\n  MESS1 = \"no rows with searchargument found\"\n  MESS2 = \"searchargument follows\"\n  MESS3 = 'COBREL = ' cobrel\n  MESS4 = 'LOADLIB= ' loadlib\n  \"ISPEXEC ADDPOP\"\n  \"ISPEXEC DISPLAY PANEL(COBA000)\"\n  \"ISPEXEC REMPOP\"\n  signal start\nend\n\ncall cobanldt 'LO'     ,\n              COBANL00 ,\n              table2   ,\n              table3   ,\n              COBANL00 ,\n              COBANLF0 ,\n              COBANLL0 ,\n              COBANLLI ,\n              ausw\n\nsignal start\n\nfailures:\nline = strip(sourceline(sigl))\nCond = condition('C') condition('D')\n\"ispexec vput (cond line)\"\ncall cobasynt procname sigl errortext(rc) /* show what went wrong */\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COBANLPG": {"ttr": 517, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x008\\x00\\x994\\x8f\\x00\\x994\\x8f\\x10\\x05\\x00^\\x00^\\x00\\x00\\xc4\\xc5\\xe2\\xe3\\xe2\\xf0\\xf3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-12-14T00:00:00", "modifydate": "1999-12-14T10:05:38", "lines": 94, "newlines": 94, "modlines": 0, "user": "DESTS03"}, "text": "/*-------- REXX -------------------------------------------*/\n/* Function   : display Cobanl program selection panel     */\n/*---------------------------------------------------------*/\n/*\n    trace ?r\n*/\n\n\"ispexec control errors return\"\nparse source xx yy procname rest\nsignal on syntax  name failures\n\nstart:\nmess    = 'please enter program name and loadlib'\n\"ISPEXEC ADDPOP ROW(03) COLUMN(10)\"\n\"ISPEXEC DISPLAY PANEL(COBANLPG)\"\nIF ZCMD = TRACE\nTHEN DO\n  zcmd = ' '\n  trace ?r\nend\nIF RC = 8\nTHEN do\n  \"ISPEXEC REMPOP\"\n  exit\nend\n\n\"ISPEXEC REMPOP\"\n\nM = MSG(OFF)\nX = SYSDSN(\"'\"dsn\"'\")\n\nIF X \u00ac= 'OK'\nTHEN DO\n  mess1   = 'load library = ' dsn\n  mess2   = 'not cataloged'\n  \"ISPEXEC ADDPOP ROW(03) COLUMN(10)\"\n  \"ISPEXEC DISPLAY PANEL(COBA000)\"\n  \"ISPEXEC REMPOP\"\n  signal start\nEND\n\n\"ispexec vget steplib\"\n\n\"FREE F(SYSPRINT)\"\n\"FREE F(COBANAL)\"\n\nodataset = userid()\".COBANAL.PGMLIST\"\n\nADDRESS TSO \"DELETE '\"odataset\"'\"\n\nADDRESS TSO \"ALLOC F(SYSPRINT) \",\n            \"DA('\"odataset\"') \",\n            \"NEW REU \",\n            \"LRECL(121)\",\n            \"RECFM(F B)\",\n            \"BLKSIZE(0)\",\n            \"TRACKS\",\n            \"SPACE(1 1)\"\n\nADDRESS TSO \"ALLOC F(COBANAL) \",\n            \"DA('\"dsn\"') \",\n            \"SHR\"\n\n\"CALL '\"STEPLIB\"(COBANAL)' '\"pgm\"'\"\nmess1 = 'CALL 'STEPLIB'(COBANAL)' pgm\n\nif rc     > 4\nthen do\n  mess2   = 'Returncode = ' rc\n  mess3   = 'Possible reason could be S806'\n  mess4   = 'module COBANAL not found'\n  \"ISPEXEC ADDPOP ROW(03) COLUMN(10)\"\n  \"ISPEXEC DISPLAY PANEL(COBA000)\"\n  \"ISPEXEC REMPOP\"\nend\nelse do\n  \"ISPEXEC VIEW DATASET('\"ODATASET\"')\"\nend\n\n\"FREE F(SYSPRINT)\"\n\"FREE F(COBANAL)\"\n\nADDRESS TSO \"DELETE '\"odataset\"'\"\nM = MSG(ON)\n\nSIGNAL START\n\nfailures:\nline = strip(sourceline(sigl))\nCond = condition('C') condition('D')\n\"ispexec vput (cond line)\"\nparse source x y procname z\ncall cobasynt procname sigl errortext(rc) /* show what went wrong */\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COBANL03": {"ttr": 3329, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00V\\x01\\x023\\x0f\\x01\\x023\\x0f\\x10T\\x01\\x84\\x01\\x7f\\x00\\x05\\xc5\\xe7\\xf3\\xf1\\xf0\\xf2\\xf2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-11-26T00:00:00", "modifydate": "2002-11-26T10:54:56", "lines": 388, "newlines": 383, "modlines": 5, "user": "EX31022"}, "text": "/*-------- REXX -------------------------------------------*/\n/* Function   : select  cobanal options                    */\n/*---------------------------------------------------------*/\n/*\n    trace ?r\n*/\n\n\"ispexec control errors return\"\nparse source xx yy procname rest\nsignal on syntax  name failures\nsignal on failure name failures\n\ninit:\n\"ISPEXEC ADDPOP\"\n\"ISPEXEC DISPLAY PANEL(COBANL05)\"\n\nIF RC = 12 | RC = 20\nTHEN do\n  \"ISPEXEC REMPOP\"\n  CALL COBA000 procname cobanl05 rc\n  EXIT\nend\n\nIF ZCMD = TRACE\nTHEN DO\n  zcmd = ' '\n  trace ?r\nend\n\nIF RC = 8\nTHEN do\n  \"ISPEXEC REMPOP\"\n  EXIT\nend\n\n\"ISPEXEC REMPOP\"\n\nselect\n  when zcmd = 1\n  then do\n    call      cobanl06\n    signal    init\n  end\n  when zcmd = 2 then nop\n  when zcmd = 3\n  then do\n    call      cobanl10\n    signal    init\n  end\n  otherwise   signal init\nend\n\nstart:\n\"ISPEXEC ADDPOP\"\n\"ISPEXEC DISPLAY PANEL(COBANL03)\"\n\nIF RC = 12 | RC = 20\nTHEN do\n  \"ISPEXEC REMPOP\"\n  CALL COBA000 procname procname rc\n  EXIT\nend\n\nIF ZCMD = TRACE\nTHEN DO\n  zcmd = ' '\n  trace ?r\nend\n\nIF RC = 8\nTHEN do\n  \"ISPEXEC REMPOP\"\n  signal init\nend\n\n\"ISPEXEC REMPOP\"\n\nselect\n  when zcmd = 1\n  then do\n    fieldv  = ADV\n  end\n  when zcmd = 2\n  then do\n    fieldv  = NOADV\n  end\n  when zcmd = 3\n  then do\n    fieldv  = QUOTE\n  end\n  when zcmd = 4\n  then do\n    fieldv  = NOQUOTE\n  end\n  when zcmd = 5\n  then do\n    fieldv  = 'DATA(24)'\n  end\n  when zcmd = 6\n  then do\n    fieldv  = 'DATA(31)'\n  end\n  when zcmd = 7\n  then do\n    fieldv  = DECK\n  end\n  when zcmd = 8\n  then do\n    fieldv  = NODECK\n  end\n  when zcmd = 9\n  then do\n    fieldv  = DUMP\n  end\n  when zcmd = 10\n  then do\n    fieldv  = NODUMP\n  end\n  when zcmd = 11\n  then do\n    fieldv  = DYNAM\n  end\n  when zcmd = 12\n  then do\n    fieldv  = NODYNAM\n  end\n  when zcmd = 13\n  then do\n    fieldv  = FASTSRT\n  end\n  when zcmd = 14\n  then do\n    fieldv  = NOFASTSRT\n  end\n  when zcmd = 15\n  then do\n    fieldv  = FDUMP\n  end\n  when zcmd = 16\n  then do\n    fieldv  = NOFDUMP\n  end\n  when zcmd = 17\n  then do\n    fieldv  = LIB\n  end\n  when zcmd = 18\n  then do\n    fieldv  = NOLIB\n  end\n  when zcmd = 19\n  then do\n    fieldv  = LIST\n  end\n  when zcmd = 20\n  then do\n    fieldv  = NOLIST\n  end\n  when zcmd = 21\n  then do\n    fieldv  = MAP\n  end\n  when zcmd = 22\n  then do\n    fieldv  = NOMAP\n  end\n  when zcmd = 23\n  then do\n    fieldv  = NUM\n  end\n  when zcmd = 24\n  then do\n    fieldv  = NONUM\n  end\n  when zcmd = 25\n  then do\n    fieldv  = OBJ\n  end\n  when zcmd = 26\n  then do\n    fieldv  = NOOBJ\n  end\n  when zcmd = 27\n  then do\n    fieldv  = OFFSET\n  end\n  when zcmd = 28\n  then do\n    fieldv  = NOOFFSET\n  end\n  when zcmd = 29\n  then do\n    fieldv  = OPTIMIZE\n  end\n  when zcmd = 30\n  then do\n    fieldv  = NOOPTIMIZE\n  end\n  when zcmd = 31\n  then do\n    fieldv  = 'DDNAME(Default)'\n  end\n  when zcmd = 32\n  then do\n    fieldv  = 'DDNAME(no-Default)'\n  end\n  when zcmd = 33\n  then do\n    fieldv  = 'NUMPROC(PFD)'\n  end\n  when zcmd = 34\n  then do\n    fieldv  = 'NUMPROC(NOPFD)'\n  end\n  when zcmd = 35\n  then do\n    fieldv  = RENT\n  end\n  when zcmd = 36\n  then do\n    fieldv  = NORENT\n  end\n  when zcmd = 37\n  then do\n    fieldv  = RES\n  end\n  when zcmd = 38\n  then do\n    fieldv  = NORES\n  end\n  when zcmd = 39\n  then do\n    fieldv  = SEQ\n  end\n  when zcmd = 40\n  then do\n    fieldv  = NOSEQ\n  end\n  when zcmd = 41\n  then do\n    fieldv  = 'SIZE(MAX)'\n  end\n  when zcmd = 42\n  then do\n    fieldv  = 'SIZE(NOMAX)'\n  end\n  when zcmd = 43\n  then do\n    fieldv  = SOURCE\n  end\n  when zcmd = 44\n  then do\n    fieldv  = NOSOURCE\n  end\n  when zcmd = 45\n  then do\n    fieldv  = SSRANGE\n  end\n  when zcmd = 46\n  then do\n    fieldv  = NOSSRANGE\n  end\n  when zcmd = 47\n  then do\n    fieldv  = TERM\n  end\n  when zcmd = 48\n  then do\n    fieldv  = NOTERM\n  end\n  when zcmd = 49\n  then do\n    fieldv  = TEST\n  end\n  when zcmd = 50\n  then do\n    fieldv  = NOTEST\n  end\n  when zcmd = 51\n  then do\n    fieldv  = 'TRUNC(BIN)'\n  end\n  when zcmd = 52\n  then do\n    fieldv  = 'TRUNC(OPT)'\n  end\n  when zcmd = 53\n  then do\n    fieldv  = VBREF\n  end\n  when zcmd = 54\n  then do\n    fieldv  = NOVBREF\n  end\n  when zcmd = 55\n  then do\n    fieldv  = XREF\n  end\n  when zcmd = 56\n  then do\n    fieldv  = NOXREF\n  end\n  when zcmd = 57\n  then do\n    fieldv  = ZWB\n  end\n  when zcmd = 58\n  then do\n    fieldv  = NOZWB\n  end\n  when zcmd = 59\n  then do\n    fieldv  = NAME\n  end\n  when zcmd = 60\n  then do\n    fieldv  = NONAME\n  end\n  when zcmd = 61\n  then do\n    fieldv  = CMPR2\n  end\n  when zcmd = 62\n  then do\n    fieldv  = NOCMPR2\n  end\n  when zcmd = 63\n  then do\n    fieldv  = NUMCLS\n  end\n  when zcmd = 64\n  then do\n    fieldv  = NONUMCLS\n  end\n  when zcmd = 65\n  then do\n    fieldv  = DBCS\n  end\n  when zcmd = 66\n  then do\n    fieldv  = NODBCS\n  end\n  when zcmd = 67\n  then do\n    fieldv  = AWO\n  end\n  when zcmd = 68\n  then do\n    fieldv  = NOAWO\n  end\n  when zcmd = 69\n  then do\n    fieldv  = EVENTS\n  end\n  when zcmd = 70\n  then do\n    fieldv  = NOEVENTS\n  end\n  when zcmd = 71\n  then do\n    fieldv  = CURRENCY\n  end\n  when zcmd = 72\n  then do\n    fieldv  = NOCURRENCY\n  end\n  when zcmd = 73\n  then do\n    fieldv  = WORD\n  end\n  when zcmd = 74\n  then do\n    fieldv  = NOWORD\n  end\n  otherwise   signal start\nend\n\ncall cobanlli fieldv cobanl01 cobanl00 cobanl03 s\n\nsignal start\n\nexit\n\nfailures:\nsay  \"line = \" strip(sourceline(sigl))\nsay  \"Cond = \" condition('C') condition('D')\nsay  \"Error= \" errortext(rc)\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COBANL06": {"ttr": 257, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*-------- REXX -------------------------------------------*/\n/* Function   : select  cobanal options                    */\n/*---------------------------------------------------------*/\n/*\n    trace ?r\n*/\n\n\"ispexec control errors return\"\nparse source xx yy procname rest\nsignal on syntax  name failures\nsignal on failure name failures\n\nstart:\n\"ISPEXEC ADDPOP\"\n\"ISPEXEC DISPLAY PANEL(COBANL06)\"\n\nIF RC = 12 | RC = 20\nTHEN do\n  \"ISPEXEC REMPOP\"\n  CALL COBA000 procname cobanl06 rc\n  EXIT\nend\n\nIF ZCMD = TRACE\nTHEN DO\n  zcmd = ' '\n  trace ?r\nend\n\nIF RC = 8\nTHEN do\n  \"ISPEXEC REMPOP\"\n  EXIT\nend\n\n\"ISPEXEC REMPOP\"\n\nselect\n  when zcmd = 1\n  then do\n    fieldv  = SYMDMP\n  end\n  when zcmd = 2\n  then do\n    fieldv  = NOSYMDMP\n  end\n  when zcmd = 3\n  then do\n    fieldv  = FLOW\n  end\n  when zcmd = 4\n  then do\n    fieldv  = NOFLOW\n  end\n  when zcmd = 5\n  then do\n    fieldv  = STATE\n  end\n  when zcmd = 6\n  then do\n    fieldv  = NOSTATE\n  end\n  when zcmd = 7\n  then do\n    fieldv  = OPT\n  end\n  when zcmd = 8\n  then do\n    fieldv  = NOOPT\n  end\n  when zcmd = 9\n  then do\n    fieldv  = TEST\n  end\n  when zcmd = 10\n  then do\n    fieldv  = NOTEST\n  end\n  when zcmd = 11\n  then do\n    fieldv  = RES\n  end\n  when zcmd = 12\n  then do\n    fieldv  = NORES\n  end\n  when zcmd = 13\n  then do\n    fieldv  = ENDJOB\n  end\n  when zcmd = 14\n  then do\n    fieldv  = NOENDJOB\n  end\n  when zcmd = 15\n  then do\n    fieldv  = OBJ370\n  end\n  when zcmd = 16\n  then do\n    fieldv  = NOOBJ370\n  end\n  when zcmd = 17\n  then do\n    fieldv  = COUNT\n  end\n  when zcmd = 18\n  then do\n    fieldv  = NOCOUNT\n  end\n  when zcmd = 19\n  then do\n    fieldv  = LIST\n  end\n  when zcmd = 20\n  then do\n    fieldv  = TRACE\n  end\n  when zcmd = 21\n  then do\n    fieldv  = 'NO-TRACE'\n  end\n  otherwise   signal start\nend\n\ncall cobanlli fieldv cobanl01 cobanl00 cobanl03 s\n\nsignal start\n\nexit\n\nfailures:\nsay  \"line = \" strip(sourceline(sigl))\nsay  \"Cond = \" condition('C') condition('D')\nsay  \"Error= \" errortext(rc)\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COBANL10": {"ttr": 3585, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00S\\x01\\x023\\x0f\\x01\\x023\\x0f\\x11\\t\\x01\\\\\\x01\\\\\\x00\\x01\\xc5\\xe7\\xf3\\xf1\\xf0\\xf2\\xf2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-11-26T00:00:00", "modifydate": "2002-11-26T11:09:53", "lines": 348, "newlines": 348, "modlines": 1, "user": "EX31022"}, "text": "/*-------- REXX -------------------------------------------*/\n/* Function   : select  cobanal options                    */\n/*---------------------------------------------------------*/\n/*\n    trace ?r\n*/\n\n\"ispexec control errors return\"\nparse source xx yy procname rest\nsignal on syntax  name failures\nsignal on failure name failures\n\nstart:\n\"ISPEXEC ADDPOP\"\n\"ISPEXEC DISPLAY PANEL(COBANL10)\"\n\nIF RC = 12 | RC = 20\nTHEN do\n  \"ISPEXEC REMPOP\"\n  CALL COBA000 procname procname rc\n  EXIT\nend\n\nIF ZCMD = TRACE\nTHEN DO\n  zcmd = ' '\n  trace ?r\nend\n\nIF RC = 8\nTHEN do\n  \"ISPEXEC REMPOP\"\n  exit\nend\n\n\"ISPEXEC REMPOP\"\n\nselect\n  when zcmd = 1\n  then do\n    fieldv  = ADV\n  end\n  when zcmd = 2\n  then do\n    fieldv  = NOADV\n  end\n  when zcmd = 3\n  then do\n    fieldv  = QUOTE\n  end\n  when zcmd = 4\n  then do\n    fieldv  = NOQUOTE\n  end\n  when zcmd = 5\n  then do\n    fieldv  = 'DATA(24)'\n  end\n  when zcmd = 6\n  then do\n    fieldv  = 'DATA(31)'\n  end\n  when zcmd = 7\n  then do\n    fieldv  = DECK\n  end\n  when zcmd = 8\n  then do\n    fieldv  = NODECK\n  end\n  when zcmd = 9\n  then do\n    fieldv  = DUMP\n  end\n  when zcmd = 10\n  then do\n    fieldv  = NODUMP\n  end\n  when zcmd = 11\n  then do\n    fieldv  = DYNAM\n  end\n  when zcmd = 12\n  then do\n    fieldv  = NODYNAM\n  end\n  when zcmd = 13\n  then do\n    fieldv  = FASTSRT\n  end\n  when zcmd = 14\n  then do\n    fieldv  = NOFASTSRT\n  end\n  when zcmd = 15\n  then do\n    fieldv  = FDUMP\n  end\n  when zcmd = 16\n  then do\n    fieldv  = NOFDUMP\n  end\n  when zcmd = 17\n  then do\n    fieldv  = LIB\n  end\n  when zcmd = 18\n  then do\n    fieldv  = NOLIB\n  end\n  when zcmd = 19\n  then do\n    fieldv  = LIST\n  end\n  when zcmd = 20\n  then do\n    fieldv  = NOLIST\n  end\n  when zcmd = 21\n  then do\n    fieldv  = MAP\n  end\n  when zcmd = 22\n  then do\n    fieldv  = NOMAP\n  end\n  when zcmd = 23\n  then do\n    fieldv  = NUM\n  end\n  when zcmd = 24\n  then do\n    fieldv  = NONUM\n  end\n  when zcmd = 25\n  then do\n    fieldv  = OBJ\n  end\n  when zcmd = 26\n  then do\n    fieldv  = NOOBJ\n  end\n  when zcmd = 27\n  then do\n    fieldv  = OFFSET\n  end\n  when zcmd = 28\n  then do\n    fieldv  = NOOFFSET\n  end\n  when zcmd = 29\n  then do\n    fieldv  = OPTIMIZE\n  end\n  when zcmd = 30\n  then do\n    fieldv  = NOOPTIMIZE\n  end\n  when zcmd = 31\n  then do\n    fieldv  = 'DDNAME(Default)'\n  end\n  when zcmd = 32\n  then do\n    fieldv  = 'DDNAME(no-Default)'\n  end\n  when zcmd = 33\n  then do\n    fieldv  = 'NUMPROC(PFD)'\n  end\n  when zcmd = 34\n  then do\n    fieldv  = 'NUMPROC(NOPFD)'\n  end\n  when zcmd = 35\n  then do\n    fieldv  = RENT\n  end\n  when zcmd = 36\n  then do\n    fieldv  = NORENT\n  end\n  when zcmd = 37\n  then do\n    fieldv  = RES\n  end\n  when zcmd = 38\n  then do\n    fieldv  = NORES\n  end\n  when zcmd = 39\n  then do\n    fieldv  = SEQ\n  end\n  when zcmd = 40\n  then do\n    fieldv  = NOSEQ\n  end\n  when zcmd = 41\n  then do\n    fieldv  = 'SIZE(MAX)'\n  end\n  when zcmd = 42\n  then do\n    fieldv  = 'SIZE(NOMAX)'\n  end\n  when zcmd = 43\n  then do\n    fieldv  = SOURCE\n  end\n  when zcmd = 44\n  then do\n    fieldv  = NOSOURCE\n  end\n  when zcmd = 45\n  then do\n    fieldv  = SSRANGE\n  end\n  when zcmd = 46\n  then do\n    fieldv  = NOSSRANGE\n  end\n  when zcmd = 47\n  then do\n    fieldv  = TERM\n  end\n  when zcmd = 48\n  then do\n    fieldv  = NOTERM\n  end\n  when zcmd = 49\n  then do\n    fieldv  = TEST\n  end\n  when zcmd = 50\n  then do\n    fieldv  = NOTEST\n  end\n  when zcmd = 51\n  then do\n    fieldv  = 'TRUNC(BIN)'\n  end\n  when zcmd = 52\n  then do\n    fieldv  = 'TRUNC(OPT)'\n  end\n  when zcmd = 53\n  then do\n    fieldv  = VBREF\n  end\n  when zcmd = 54\n  then do\n    fieldv  = NOVBREF\n  end\n  when zcmd = 55\n  then do\n    fieldv  = XREF\n  end\n  when zcmd = 56\n  then do\n    fieldv  = NOXREF\n  end\n  when zcmd = 57\n  then do\n    fieldv  = ZWB\n  end\n  when zcmd = 58\n  then do\n    fieldv  = NOZWB\n  end\n  when zcmd = 59\n  then do\n    fieldv  = NAME\n  end\n  when zcmd = 60\n  then do\n    fieldv  = NONAME\n  end\n  when zcmd = 61\n  then do\n    fieldv  = CMPR2\n  end\n  when zcmd = 62\n  then do\n    fieldv  = NOCMPR2\n  end\n  when zcmd = 63\n  then do\n    fieldv  = NUMCLS\n  end\n  when zcmd = 64\n  then do\n    fieldv  = NONUMCLS\n  end\n  when zcmd = 65\n  then do\n    fieldv  = DBCS\n  end\n  when zcmd = 66\n  then do\n    fieldv  = NODBCS\n  end\n  when zcmd = 67\n  then do\n    fieldv  = AWO\n  end\n  when zcmd = 68\n  then do\n    fieldv  = NOAWO\n  end\n  when zcmd = 69\n  then do\n    fieldv  = EVENTS\n  end\n  when zcmd = 70\n  then do\n    fieldv  = NOEVENTS\n  end\n  when zcmd = 71\n  then do\n    fieldv  = CURRENCY\n  end\n  when zcmd = 72\n  then do\n    fieldv  = NOCURRENCY\n  end\n  when zcmd = 73\n  then do\n    fieldv  = WORD\n  end\n  when zcmd = 74\n  then do\n    fieldv  = NOWORD\n  end\n  otherwise   signal start\nend\n\ncall cobanlli fieldv cobanl01 cobanl00 cobanl03 s\n\nsignal start\n\nexit\n\nfailures:\nsay  \"line = \" strip(sourceline(sigl))\nsay  \"Cond = \" condition('C') condition('D')\nsay  \"Error= \" errortext(rc)\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COBASUBP": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x10\\x01\\x01\\x03\\x8f\\x01\\x01\\x03\\x8f\\x06W\\x00g\\x00g\\x00\\x00\\xc5\\xe7\\xf3\\xf1\\xf0\\xf2\\xf2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-02-07T00:00:00", "modifydate": "2001-02-07T06:57:10", "lines": 103, "newlines": 103, "modlines": 0, "user": "EX31022"}, "text": "/*--- REXX -------------------------------------------*/\n/*\n   trace ?r\n*/\n\nARG loadlib ptype\n\n\"ISPEXEC CONTROL ERRORS RETURN\"\n\ndsname   = listdsi(ISPPROF FILE)\n\nif dsname = 16\nthen do\n  JCLLIB  = USERID()||.ISPF.ISPPROF\nend\nelse do\n  jcllib   = sysdsname\nend\n\n\"ALLOC DD(ISPFILE) DSN('\"JCLLIB\"') SHR REUSE\"\n\n\"ISPEXEC VGET (STEPLIB COBAAPPL)\"\n\"ISPEXEC VGET (COBAHLQ LLQCLIB LLQMLIB LLQPLIB LLQSLIB LLQTLIB LLQTABL)\"\n\"ISPEXEC VGET (ACCOUNT CLASS MSGCLASS ISPFHLQ)\"\n\n\"ISPEXEC FTCLOSE NAME(COBAJOB0)\"\n\n\"ISPEXEC FTOPEN\"\n\nif rc > 0\nthen do\n  select\n    when rc = 8\n    then do\n      MESS2 = \"file tailoring already in progress\"\n    end\n    when rc = 12\n    then do\n      MESS2 = \"output file in use. ENQ failed\"\n    end\n    when rc = 16\n    then do\n      MESS2 = \"ISPFILE not allocated\"\n    end\n    when rc = 20\n    then do\n      MESS2 = \"severe error\"\n    end\n    otherwise\n  end\n  MESS1 = \"error FTOPEN\"\n  MESS3 = \"returncode = \" || rc\n  MESS4 = \"Procedur = COBASUBP\"\n  \"ISPEXEC ADDPOP\"\n  \"ISPEXEC DISPLAY PANEL(COBA000)\"\n  \"ISPEXEC REMPOP\"\n  \"ISPEXEC FTCLOSE\"\n  signal free_file\nend\n\n\"ISPEXEC FTINCL COBANAL\"\n\nif rc > 0\nthen do\n  select\n    when rc = 8\n    then do\n      MESS1 = \"output skeleton not defined\"\n    end\n    when rc = 12\n    then do\n      MESS1 = \"output skeleton in use. ENQ failed\"\n    end\n    when rc = 16\n    then do\n      MESS1 = \"data truncation occured\"\n    end\n    when rc = 20\n    then do\n      MESS1 = \"severe error\"\n    end\n    otherwise\n  end\n  MESS2 = \"please contact system support\"\n  MESS3 = \"skeleton = \" || COBANAL\n  \"ISPEXEC ADDPOP\"\n  \"ISPEXEC DISPLAY PANEL(COBA000)\"\n  \"ISPEXEC FTCLOSE\"\n  \"ISPEXEC REMPOP\"\n  signal ende\nend\n\n\"ISPEXEC FTCLOSE NAME(COBAJOB0)\"\n\n\"ISPEXEC EDIT DATASET('\"JCLLIB\"(COBAJOB0)')\"\n\nende:\n\"ISPEXEC FTERASE COBAJOB0\"\n\nfree_file:\n\"FREE DD(ISPFILE)\"\n\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COBASYNT": {"ttr": 7, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*--- REXX -------------------------------------------*/\n/*\n   TRACE ?R\n*/\n\narg proc sline err\n\n\"ISPEXEC CONTROL ERRORS RETURN \"\n\n\"ispexec vget (line cond)\"\n\n\"ISPEXEC ADDPOP ROW(04) COLUMN(08)\"\n\nSTART:\n\"ISPEXEC DISPLAY PANEL(COBASYNT)\"\n\nIF RC = 12 | RC = 20\nTHEN do\n  CALL COBA000 COBASYNT COBASYNT RC\n  \"ISPEXEC REMPOP\"\n  EXIT\nend\n\nIF RC = 8\nTHEN do\n  \"ISPEXEC REMPOP\"\n  EXIT\nend\n\nsignal start\n\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COBASYSI": {"ttr": 15, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*-------- REXX -------------------------------------------*/\n/* Function   : display information for system             */\n/* callers    : coba information application               */\n/*---------------------------------------------------------*/\n/*\n    trace ?r\n*/\n\n\"ispexec control errors return\"\nparse source xx yy procname rest\nsignal on syntax  name failures\nsignal on failure name failures\n\ncpu     = storage(208,4)\ncpu     = storage(d2x(c2d(cpu)+12),4)\ncvt     = storage(10,4)\ncvtprod = d2x(c2d(cvt) - c2d('28'x))\nmvslvl  = storage(cvtprod,16)\n\nx = syscpus(cpu.)\ncpun    = cpu.0\ncpu1    = cpu.1\nif cpun > 1 then cpu2    = cpu.2\nif cpun > 2 then cpu3    = cpu.3\nif cpun > 3 then cpu4    = cpu.4\nif cpun > 4 then cpu5    = cpu.5\nif cpun > 5 then cpu6    = cpu.6\n\nmvslvl  = mvsvar(sysopsys)\nsyslvl  = mvsvar(sysname)\nsmfid   = mvsvar(syssmfid)\ncput    = sysvar(syscpu)\n\njeslvl  = sysvar(sysjes)\ntsolvl  = sysvar(systsoe)\nracflvl = sysvar(syslracf)\nparse version rexxlvl\n\n\"ISPEXEC ADDPOP ROW(08) COLUMN(10)\"\n\n\"ISPEXEC DISPLAY PANEL(COBASYSI)\"\n\nIF RC = 12 | RC = 20\nTHEN do\n  CALL COBA000 procname cobasysi RC\n  \"ISPEXEC REMPOP\"\n  EXIT\nend\n\n\"ISPEXEC REMPOP\"\n\nIF ZCMD = TRACE\nTHEN DO\n  zcmd = ' '\n  trace ?r\nend\n\nEXIT\n\nsyntax:\nparse source x y procname z\ncall cobasynt procname sigl errortext(rc)\nexit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COBAUMWA": {"ttr": 1027, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00R\\x01\\x02\\x00\\x8f\\x01\\x02\\x00\\x8f\\x10\\x11\\x00!\\x00!\\x00\\x01\\xc5\\xe7\\xf3\\xf1\\xf0\\xf2\\xf2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-01-08T00:00:00", "modifydate": "2002-01-08T10:11:52", "lines": 33, "newlines": 33, "modlines": 1, "user": "EX31022"}, "text": "//COBAUMWA PROC NAME=,\n//             COBAHLQ='EX31022.COBA',\n//             LLQSRCE=SISPEXEC,\n//             LLQLOAD=SISPLOAD,\n//             OUTC='*',\n//             REG=1024K,\n//             WORK=SYSALLDA\n//*\n//ASM     EXEC PGM=ASMA90,\n//             REGION=&REG,\n//             PARM='DECK,NOOBJECT,LIST'\n//SYSLIB    DD DSN=&COBAHLQ..&LLQSRCE,DISP=SHR\n//          DD DSN=SYS1.MACLIB,DISP=SHR\n//          DD DSN=SYS1.AMODGEN,DISP=SHR\n//SYSIN     DD DSN=&COBAHLQ..&LLQSRCE(&NAME),DISP=SHR\n//SYSUT1    DD UNIT=&WORK,SPACE=(1700,(400,400))\n//SYSUT2    DD UNIT=&WORK,SPACE=(1700,(400,400))\n//SYSUT3    DD UNIT=&WORK,SPACE=(1700,(400,400))\n//SYSPUNCH  DD DSN=&&LOADSET,\n//             UNIT=&WORK,DISP=(,PASS),\n//             SPACE=(400,(100,100)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=400)\n//SYSPRINT  DD SYSOUT=&OUTC\n//LKED    EXEC PGM=IEWL,REGION=&REG,\n//             PARM=XREF,COND=(5,LT,ASM)\n//SYSLIB    DD DSN=ISP.SISPLOAD,DISP=SHR\n//SYSUT1    DD UNIT=&WORK,DCB=BLKSIZE=1024,\n//             SPACE=(1024,(200,20))\n//SYSPRINT  DD SYSOUT=&OUTC\n//SYSPUNCH  DD DSN=&&LOADSET,DISP=(OLD,PASS)\n//SYSLIN    DD DSN=&&LOADSET,\n//             DISP=(OLD,PASS),VOL=REF=*.SYSPUNCH\n//SYSLMOD   DD DSN=&COBAHLQ..&LLQLOAD(&NAME),DISP=SHR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "COBA000": {"ttr": 9, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/*-------- REXX -------------------------------------------*/\n/* Function   : display information for panel error        */\n/* callers    : cob analysys  application                  */\n/*---------------------------------------------------------*/\n/*\n   TRACE ?R\n*/\n\narg procname panel disrc\n\n/* Rexx get panelid of last displayed panel                          */\n/* Not a general use programming interface                           */\n/* This method is subject to breakage by maintanence or new releases */\n/* die folgende zuweisung zeigt letztes gezeigtes Panel an           */\n\npnl   = storage(d2x(ptr(ptr(ptr(ptr(ptr(540)+132)+112)+24))+352),8)\n\nMESS1 = 'panel display/query error in procedur '\nMESS2 = 'Procname   = '||procname\nMESS3 = 'Panel name = '||panel\nMESS4 = 'returncode = '||disrc\n\nif disrc = 20 then mess6 = \"severe error\"\nelse do\n  mess6 = \"no table rows to display\"\n  mess7 = \"or panel does not exist\"\nend\n\n\"ISPEXEC ADDPOP\"\n\"ISPEXEC DISPLAY PANEL(COBA000)\"\n\"ISPEXEC REMPOP\"\n\nexit\n\n/* Rexx get panelid of last displayed panel                          */\n/* Not a general use programming interface                           */\n/* This method is subject to breakage by maintanence or new releases */\n\nptr: Return c2d(bitand(storage(d2x(Arg(1)),4),'7FFFFFFF'x))\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JUMWCOBA": {"ttr": 3075, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00!\\x01\\x02\\x00\\x8f\\x01\\x02\\x01_\\x14@\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc5\\xe7\\xf3\\xf1\\xf0\\xf2\\xf2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-01-08T00:00:00", "modifydate": "2002-01-15T14:40:21", "lines": 11, "newlines": 11, "modlines": 0, "user": "EX31022"}, "text": "//EX31022A JOB (#ACCNT),'NAME',\n//             CLASS=S,MSGCLASS=T,MSGLEVEL=(1,1)\n//*\n//MYLIB JCLLIB ORDER=(EX31022.COBA.SISPEXEC)\n//*\n//*        UMWANDLUNG/LINK      ASSEMBLER BATCH\n//*\n//STEP1   EXEC COBAUMWA,NAME=COBANAL\n//ASM.SYSIN DD DSN=EX31022.COBA.SISPEXEC(&NAME)\n//LKED.SYSLMOD DD DSN=EX31022.COBA.SISPLOAD(&NAME),DISP=SHR\n//*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "STRING": {"ttr": 1795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x05\\x00\\x00\\x00x#\\x9f\\x01\\x00\\x11O\\x17G\\x05S\\x00\\x19\\x05S\\xd9\\xd6\\xd3\\xc1\\xd5\\xc4\\xe2@@@'", "ispf": {"version": "05.05", "flags": 0, "createdate": "1978-08-27T00:00:00", "modifydate": "2000-04-23T17:47:00", "lines": 1363, "newlines": 25, "modlines": 1363, "user": "ROLANDS"}, "text": "*//IBMUSERM JOB (ACCT#),STRING,\n*// NOTIFY=&SYSUID,\n*// CLASS=A,MSGCLASS=X,COND=(0,NE)\n*//ASMH EXEC PGM=IEV90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF,NOBATCH)\n***********************************************************************\n*                                                                     *\n* MACRO NAME = STRING                                                 *\n*                                                                     *\n* DESCRIPTIVE NAME = STRING Macro Instruction.                        *\n*                                                                     *\n* FUNCTION = Provide capabilities similar to PUT EDIT (of PL/I)       *\n*            or STRING (of COBOL) to assembler programs.              *\n*                                                                     *\n* STATUS = R507                                                       *\n*                                                                     *\n* AUTHOR = Gilbert Saint-flour <gsf@pobox.com>                        *\n*                                                                     *\n* ENVIRONMENT = SEE BELOW                                             *\n*                                                                     *\n*     AMODE = ANY                                                     *\n*     SCP   = MVS/XA, MVS/ESA or OS/390                               *\n*     KEY   = ANY                                                     *\n*     MODE  = ANY                                                     *\n*     APF   = OFF                                                     *\n*                                                                     *\n* OPERATION = SEE DOCUMENTATION AT THE END OF THIS FILE               *\n*                                                                     *\n* INVOCATION = SEE DOCUMENTATION AT THE END OF THIS FILE              *\n*                                                                     *\n* NOTES = SEE DOCUMENTATION AT THE END OF THIS FILE                   *\n*                                                                     *\n* CHANGE ACTIVITY                                                     *\n*                                                                     *\n*  $301  FIX BUGS WITH (XYZ,,L8) AND INTO=((R1),(R2))                 *\n*  $302  GENERATE $DEBUG BOOT-STRAP IN FINAL_CALL INVOCATION          *\n*  $303  REPLACE @STRPAD WITH @STRBLANKS                              *\n*  $304  USE @00-@15 INSTEAD OF R0-R15 FOR REGISTER EQUATES           *\n*  $306  TAILOR @STRING CSECT TO PROGRAM'S REQUIREMENTS               *\n*        LITERALS CAN BE CODED AS 'ABC' OR C'ABC' OR X'C1C2C3'        *\n*        USE L'PSATOLD AS IMPLICIT LENGTH FOR (PSATOLD-PSA,,X)        *\n*  $307  FINAL_CALL OPTION CHANGED TO GENERATE                        *\n*        ADD NOCSECT AND LOCTR OPTIONS TO GENERATE CALL               *\n*  $308  USE L'RBCDE AS IMPLICIT LENGTH FOR (PRB.RBCDE,,X)            *\n*        PREVENT S0C4 WHEN ADDR IS BAD AND LENGTH IS ZERO             *\n*  $400  REORG THE CODE TO SIMPLIFY FEATURE SELECTION                 *\n*        BLANKS NO LONGER USED OR GENERATED                           *\n*  $401  GENERATE @STRHEXT WHEN ((REG),,X) ONLY HEX FIELD             *\n*  $502  @STRING ROUTINE REWRITTEN FOR MVS/ESA:                       *\n*        -  USE LINKAGE STACK TO STORE CALLER'S REGISTERS             *\n*        -  ADD SUPPORT FOR AR MODE                                   *\n*  $503  DATE CONVERSION TO YYYY-MM-DD FORMAT (ISO STANDARD)          *\n*        IMPROVE SUPPORT FOR AR MODE                                  *\n*  $504  SET &STRBLANKS TO 10 WHEN PROCESSING DATES                   *\n*  $505  Allow for 128K-offset                                        *\n*  $506  Remove literal from BAL instruction for HLASM R3             *\n*  $507  Merge STRINGXA code, add AR_MODE option                      *\n*        Change syntax of GENERATE call                               *\n***********************************************************************\n         MACRO\n&NAME    STRING &INTO=,&PRINT=NOGEN\n         GBLC  &STRING_MACRO_VERSION\n&STRING_MACRO_VERSION SETC '507'       current version\n         AIF   ('&PRINT' EQ 'NOGEN').NOGEN\n         PUSH  PRINT\n         PRINT GEN\n.NOGEN   GBLA  &$_LIT\n         GBLB  &$_FEAT(16)             FEATURES\n.*                                       1 LITERALS\n.*                                       2 REGISTER (BIN)\n.*                                       3 REGISTER (HEX)\n.*                                       4 PACKED\n.*                                       5 JDATE\n.*                                       6 BINARY\n.*                                       7 HEX\n.*                                       8 NUMERIC\n.*                                       9 LEFT JUST (NUMERIC)\n.*                                       10 LEADING ZEROES\n.*                                       11 TRUNCATE (CHAR STRING)\n.*                                       12 %TIME\n         GBLC  &$_LITS(9999)           LITERALS\n         LCLA  &I,&J,&N\n         AIF   (T'&INTO EQ 'O' AND N'&SYSLIST EQ 1                     X\n               AND '&SYSLIST(1,1)' EQ 'GENERATE').GENL\n&LABEL   SETC  'IHB&SYSNDX'            STEM FOR LOCAL LABELS\n&LQ      SETC  'L'''                   LENGTH ATTRIBUTE\n&STR     SETC  '  R&STRING_MACRO_VERSION'\n&NAME    BAS   R14,$STRING&STR         CALL @STRING SUB-ROUTINE\n         AIF   (N'&SYSLIST EQ 0).ERR1  NO POSITIONAL OPERANDS, ERROR\n         AIF   (T'&INTO EQ 'O').ERR2   NO RECEIVING FIELD, ERROR\n         AIF   (N'&INTO GT 2).ERR2     INTO=(A,32,BLURB)\n         DC    AL2((&LABEL.P-*)/2)     OFFSET TO FIELD DESCRIPTORS\n         AIF   (D'$LITERAL).LOCTR2     NOT FIRST TIME, JUMP\n$LTORG   LOCTR                         ADDRESSABLE CONSTANTS\n$FARRTNE LOCTR                         FAR ROUTINES\n.LOCTR2  ANOP\n$LITERAL LOCTR                         NON-ADDRESSABLE CONSTANTS\n&TO1     SETC  '&INTO(1)'\n&TO2     SETC  '&LQ&INTO'\n         AIF   (N'&INTO EQ 1).PUNTO8            JUMP IF INTO=XXX\n         AIF   ('&INTO(1)'(1,1) NE '(').PUNTO3  JUMP IF INTO=(XXX,44)\n&TO1     SETC  '0&INTO(1)'                              INTO=((R3),44)\n.PUNTO3  ANOP\n&TO2     SETC  '&INTO(2)'                               INTO=(XXX,LL)\n         AIF   ('&INTO(2)'(1,1) NE '(').PUNTO8  JUMP IF INTO=(XXX,44)\n&TO2     SETC  '0&INTO(2)'                              INTO=(XXX,(R1))\n.PUNTO8  ANOP\n&LABEL.P DC    S(&TO1,&TO2)\n.*--------------------------------------------------------------------*\n.*-------      FIELDS       ------------------------------------------*\n.*--------------------------------------------------------------------*\n         LCLB  &LAST,&BIN,&HEX,&REG,&PACKED,&LEFT,&ZERO,&TRUNC\n&I       SETA  1\n.*LOOP\n.LOOP1   ANOP\n         AIF   (N'&SYSLIST(&I) GT 3).FLD990   TOO MANY SUB-OPERANDS\n&LAST    SETB  (&I EQ N'&SYSLIST)                LOOP\n         AIF   ('&SYSLIST(&I)'(1,1) EQ '''').LIT00\n         AIF   ('&SYSLIST(&I)'(K'&SYSLIST(&I),1) EQ '''').LIT01\n.*--------------------------------------------------------------------*\n.*       PROCESS FIRST SUBPARAMETER (ADDRESS)                         *\n.*--------------------------------------------------------------------*\n&P1S     SETC  '&SYSLIST(&I,1)'\n&P2L     SETC  '0'                     INPUT LENGTH\n&P3L     SETC  '0'                     OUTPUT LENGTH\n         AIF   ('&SYSLIST(&I)'(1,1) GE '0').FLD180 SPACES\n         AIF   ('&SYSLIST(&I)' EQ '%TIME').FLD190 %TIME\n         AIF   ('&SYSLIST(&I,1)'(1,1) NE '(').FLD115 (R2)\n         AIF   (T'&SYSLIST(&I,2) EQ 'O').FLD250\n&P1S     SETC  '0&SYSLIST(&I,1)'       CHANGE (R1) TO 0(R1)\n.FLD115  ANOP\n.*\n.*       EXTRACT RBCDE FROM PRB.RBCDE (HLASM)\n.*\n&L       SETA  1\n.*--LOOP\n.FLD131  AIF   ('&P1S'(&L,1) EQ '.').FLD133\n&L       SETA  &L+1\n         AIF   (&L LT K'&P1S).FLD131\n.*--ENDLOOP\n&P2L     SETC  '&P1S'                    ABCDEF FROM ABCDEF\n         AGO   .FLD134\n.FLD133  ANOP\n&P2L     SETC  '&P1S'(&L+1,K'&P1S-&L)    RBCDE FROM PRB.RBCDE\n.FLD134  ANOP\n.*\n         AIF   (T'&SYSLIST(&I,2) NE 'O').FLD200\n.*\n         AIF   (NOT D'&P2L).FLD140\n&P2C     SETC  T'&P2L\n.*MNOTE *,'&P1 &P2C'\n         AIF   ('&P2C' EQ 'F' OR '&P2C' EQ 'H' OR '&P2C' EQ 'P').FLD220\n         AIF   ('&P2C' EQ 'G').FLD210  FL2\n.FLD140  ANOP\n.*\n.*       EXTRACT PSATOLD FROM PSATOLD-PSA\n.*\n&L       SETA  1\n.*--LOOP\n.FLD141  AIF   ('&P2L'(&L,1) EQ '-').FLD143\n         AIF   ('&P2L'(&L,1) EQ '+').FLD143\n&L       SETA  &L+1\n         AIF   (&L LT K'&P2L).FLD141\n.*--ENDLOOP\n&P2L     SETC  '&LQ&P2L'               L'ABCDEF\n         AGO   .FLD300\n.FLD143  ANOP\n&P2L     SETC  '&LQ'.'&P2L'(1,&L-1)    L'PSATOLD FROM PSATOLD-PSA\n         AGO   .FLD300\n.*\n.FLD180  AIF   ('&SYSLIST(&I)'(K'&SYSLIST(&I),1) NE 'X').FLD800\n&P2L     SETC  '&SYSLIST(&I)'(1,K'&SYSLIST(&I)-1) 12\n&J       SETA  X'4000'+&LAST*X'8000'\n         DC    AL2(0,&P2L,&J)          BLANKS\n&$_FEAT(1) SETB 1                      LITERAL\n         AGO   .LIT99\n.*\n.FLD190  ANOP                          %TIME\n&P1S     SETC  '1(14)'                 %TIME\n&$_FEAT(12) SETB 1                     %TIME\n         AGO   .FLD800\n.*--------------------------------------------------------------------*\n.*       PROCESS SECOND SUBPARAMETER (LENGTH/TYPE)                    *\n.*--------------------------------------------------------------------*\n.FLD200  AIF   (T'&SYSLIST(&I,2) EQ 'O').FLD300 NO LENGTH SPECIFIED\n&P2C     SETC  '&SYSLIST(&I,2)'\n         AGO   .FLD220\n.*T'&P1=G\n.FLD210  ANOP\n&L       SETA  L'&SYSLIST(&I)          T'&P1 = 'G'\n&P2C     SETC  'FL&L'                  T'&P1 = 'G'\n.*\n.FLD220  ANOP\n&P2L     SETC  '0&P2C'                 (R2) LENGTH\n         AIF   ('&P2C'(1,1) EQ '(').FLD300\n&P2L     SETC  '&P2C'                  3(R2) LENGTH\n         AIF   ('&P2C'(K'&P2C,1) EQ ')').FLD300\n&P2L     SETC  '0'\n&PACKED  SETB  ('&P2C' EQ 'P')\n         AIF   (&PACKED).FLD300\n&P2L     SETC  '1'\n         AIF   ('&P2C' EQ 'FL1').FLD240\n&P2L     SETC  '3'\n         AIF   ('&P2C' EQ 'FL2' OR '&P2C' EQ 'H').FLD240\n&P2L     SETC  '7'\n         AIF   ('&P2C' EQ 'FL3').FLD240\n&P2L     SETC  '15'\n         AIF   ('&P2C' EQ 'F').FLD240\n&P2L     SETC  '&P2C'                  IMMEDIATE LENGTH, FIELD\n         AGO   .FLD300\n.*\n.FLD240  ANOP                          BINARY VARIABLE\n&BIN     SETB  1\n         AGO   .FLD300\n.*\n.FLD250  ANOP                          REGISTER CONTENT\n&REG     SETB  1\n.*--------------------------------------------------------------------*\n.*       PROCESS THIRD SUBPARAMETER (OUTPUT FORMAT)                   *\n.*--------------------------------------------------------------------*\n.FLD300  AIF   (T'&SYSLIST(&I,3) EQ 'O').FLD800\n&HEX     SETB  ('&SYSLIST(&I,3)' EQ 'X') HEXADECIMAL\n&TRUNC   SETB  ('&SYSLIST(&I,3)' EQ 'T') TRUNCATE\n         AIF   (&HEX OR &TRUNC).FLD800\n.*\n&P3C     SETC  '&SYSLIST(&I,3)'\n&P3L     SETC  '248'\n         AIF   ('&P3C' EQ 'YYYY-MM-DD' AND &PACKED).FLD308\n&P3L     SETC  '249'\n         AIF   ('&P3C' EQ 'YYYYMMDD' AND &PACKED).FLD308\n&P3L     SETC  '250'\n         AIF   ('&P3C' EQ 'YY/MM/DD' AND &PACKED).FLD308\n&P3L     SETC  '251'\n         AIF   ('&P3C' EQ 'DD/MM/YY' AND &PACKED).FLD308\n&P3L     SETC  '252'\n         AIF   ('&P3C' EQ 'MM/DD/YY' AND &PACKED).FLD308\n&P3L     SETC  '253'\n         AIF   ('&P3C' EQ 'YYMMDD'   AND &PACKED).FLD308\n&P3L     SETC  '0'\n         AIF   (T'&SYSLIST(&I,2) NE 'N').FLD310\n         MNOTE 8,'EDIT PATTERN NOT ALLOWED WITH CHARACTER STRING'\n         AGO   .FLD310\n.FLD308  ANOP\n&$_FEAT(5) SETB 1                      JDATE\n         AGO   .FLD800\n.*--LOOP\n.FLD310  AIF   ('&P3C'(1,1) EQ 'R').FLD318       DEFAULT\n         AIF   ('&P3C'(1,1) EQ 'B').FLD318       DEFAULT\n         AIF   ('&P3C'(1,1) NE 'L').FLD311\n&LEFT    SETB  1\n         AGO   .FLD318\n.FLD311  AIF   ('&P3C'(1,1) NE 'Z').FLD312\n&ZERO    SETB  1\n         AGO   .FLD318\n.FLD312  AIF   ('&P3C'(1,1) LT '0').FLD993\n&P3L     SETC  '&P3L'.'&P3C'(1,1)\n.FLD318  ANOP\n.*MNOTE *,'&SYSLIST(&I) P3C=/&P3C/ P3L=/&P3L/'\n&P3C     SETC  '&P3C'(2,K'&P3C-1)     STRIP OFF FIRST CHARACTER\n         AIF   (K'&P3C GT 0).FLD310\n.*--ENDLOOP\n.*--------------------------------------------------------------------*\n.FLD800  ANOP\n&NUMERIC SETB  (&BIN OR &PACKED OR (&REG AND NOT &HEX))\n&TRUNC   SETB  (&TRUNC OR (&LEFT AND NOT &NUMERIC))\n&LEFT    SETB  (&LEFT AND &NUMERIC)\n         AIF   (NOT &NUMERIC).FLD810\n         AIF   (&LEFT OR '&P3L' NE '0').FLD810\n&P3L     SETC  '7'                     DEFAULT OUTPUT LENGTH ((R3))\n         AIF   (&REG).FLD810\n&P3L     SETC  '3'                     DEFAULT OUTPUT LENGTH\n         AIF   ('&P2C' EQ 'FL1').FLD810\n&P3L     SETC  '5'                     DEFAULT OUTPUT LENGTH\n         AIF   ('&P2C' EQ 'H' OR '&P2C' EQ 'FL2').FLD810\n&P3L     SETC  '7'                     DEFAULT OUTPUT LENGTH\n.FLD810  ANOP\n&FLAG    SETA  &LAST*128+&HEX*8+&BIN*4+&PACKED*2+&REG*1\n&LEN2    SETA  &TRUNC*128+&LEFT*128+&ZERO*64+&P3L\n         DC    S(&P1S,&P2L),AL1(&FLAG,&LEN2)\n&$_FEAT(2) SETB (&$_FEAT(2) OR (&REG AND NOT &HEX))   REGISTER (BIN)\n&$_FEAT(3) SETB (&$_FEAT(3) OR (&REG AND &HEX))       REGISTER (HEX)\n&$_FEAT(4) SETB (&$_FEAT(4) OR &PACKED)               PACKED\n&$_FEAT(6) SETB (&$_FEAT(6) OR &BIN)                  BINARY\n&$_FEAT(7) SETB (&$_FEAT(7) OR (&HEX AND NOT &REG))   HEX\n&$_FEAT(8) SETB (&$_FEAT(8) OR &NUMERIC)              BIN,PACKED\n&$_FEAT(9) SETB (&$_FEAT(9) OR (&LEFT AND &NUMERIC))\n&$_FEAT(10) SETB (&$_FEAT(10) OR &ZERO)\n&$_FEAT(11) SETB (&$_FEAT(11) OR &TRUNC)\n&BIN     SETB  0                    RESET FLAGS\n&HEX     SETB  0                    RESET FLAGS\n&REG     SETB  0                    RESET FLAGS\n&PACKED  SETB  0                    RESET FLAGS\n&LEFT    SETB  0                    RESET FLAGS\n&ZERO    SETB  0                    RESET FLAGS\n&TRUNC   SETB  0                    RESET FLAGS\n         AGO   .LIT99\n.FLD990  MNOTE 12,'OPERAND &I HAS TOO MANY SUB-OPERANDS'\n         AGO   .LIT99\n.FLD993  MNOTE 8,'THIRD SUBPARAMETER IS INVALID: ''&SYSLIST(&I,3)'''\n         AGO   .LIT99\n.*--------------------------------------------------------------------*\n.*------------ LITERALS ----------------------------------------------*\n.*--------------------------------------------------------------------*\n.LIT00   ANOP\n&LIT     SETC  'C&SYSLIST(&I)'\n         AGO   .LIT09\n.LIT01   ANOP\n&LIT     SETC  '&SYSLIST(&I)'\n.LIT09   AIF   (&$_LIT EQ 0).LIT50\n&N       SETA  1\n         ACTR  &$_LIT*3+200\n.LIT10   AIF   (&N GT &$_LIT).LIT50                  LOOP\n&L       SETA  &N+1000                               LOOP\n         AIF   ('&LIT' EQ '&$_LITS(&N)').LIT80 LOOP\n&N       SETA  &N+1                                  LOOP\n         AGO   .LIT10                                LOOP\n.LIT50   ANOP\n&$_LIT   SETA  &$_LIT+1\n&$_LITS(&$_LIT) SETC '&LIT'\n&L       SETA  &$_LIT+1000\n.LIT80   ANOP\n&J       SETA  X'4000'+&LAST*X'8000'\n         DC    AL2($LIT&L-*,&LQ.$LIT&L,&J)\n&$_FEAT(1) SETB 1                      LITERAL\n.LIT99   ANOP\n.*--------------------------------------------------------------------*\n&I       SETA  1+&I                              LOOP\n         AIF   (&I LE N'&SYSLIST).LOOP1          LOOP\n.*ENDLOOP\n&SYSLOC  LOCTR\n         AGO   .MEND\n.ERR1    MNOTE 12,'AT LEAST ONE INPUT FIELD MUST BE SPECIFIED'\n         AGO   .MEND\n.ERR2    MNOTE 12,'INVALID OUTPUT AREA SPECIFICATION'\n         AGO   .MEND\n.**********************************************************************\n.*       GENERATE: GENERATE LITERALS AND PROCESSING ROUTINE           *\n.**********************************************************************\n.GENL    ANOP\n         AIF   (N'&SYSLIST(1) GT 3).GENL1R\n&OPT2    SETC  '&SYSLIST(1,2)'\n         AIF   ('&OPT2' NE '' AND '&OPT2' NE 'AR_MODE'                 X\n               AND '&OPT2' NE 'NO_CSECT').GENL1R\n&OPT3    SETC  '&SYSLIST(1,3)'\n         AIF   ('&OPT3' NE '' AND '&OPT3' NE 'LOCTR').GENL1R\n         AIF   ('&OPT2' EQ 'NO_CSECT' AND '&OPT3' EQ 'LOCTR').GENL1R\n         AGO   .GENL1D\n.GENL1R  MNOTE 12,'Invalid GENERATE options, default used'\n&OPT2    SETC  ''\n&OPT3    SETC  ''\n.GENL1D  ANOP\n&STRBLANKS SETA 2\n         AIF   (D'$LTORG).GENL1F             CSECT-ONLY\n&$_FEAT(1) SETB 1,1,1,1,1,1,1,1,1,1,1,1\n.GENL1F  ANOP\n&ALLFEAT SETC  '&$_FEAT(1)&$_FEAT(2)&$_FEAT(3)&$_FEAT(4)'\n&ALLFEAT SETC  '&ALLFEAT&$_FEAT(5)&$_FEAT(7)&$_FEAT(6)&$_FEAT(8)'\n&ALLFEAT SETC  '&ALLFEAT&$_FEAT(9)&$_FEAT(10)&$_FEAT(11)&$_FEAT(12)'\n&STR     SETC  '&STRING_MACRO_VERSION'\n         MNOTE *,'STRING R&STR - FEATURES GENERATED: &ALLFEAT'\n         AIF   (&$_LIT EQ 0).GENL3\n$LITERAL LOCTR\n.GENL2   ANOP                                LOOP\n&N       SETA  &N+1                          LOOP\n&I       SETA  &N+1000                       LOOP\n$LIT&I   DC    &$_LITS(&N)\n         AIF   (&N LT &$_LIT).GENL2          LOOP\n.GENL3   ANOP\n         AIF   ('&OPT2' EQ 'NO_CSECT').GENL8\n&ARMODE  SETB  ('&OPT2' EQ 'AR_MODE')\n.**********************************************************************\n.*                                                                    *\n.*       STRING SUB-ROUTINE                                           *\n.*                                                                    *\n.*             CAUTION: BYTES 49-72 OF THE CALLER'S SAVE AREA         *\n.*                      (R7-R12 SLOTS) ARE USED AS WORK SPACE         *\n.*                                                                    *\n.**********************************************************************\n         AIF   ('&OPT3' EQ 'LOCTR').GENL4L\n@STRING  CSECT\n@STRING  RMODE ANY\n         AGO   .GENL4X\n.GENL4L  PUSH  USING                   GENERATE,LOCTR\n         DROP\n@STRING@ LOCTR\n@STRING  DS    0H                      ALIGNMENT\n.GENL4X  ANOP\n@00      EQU   0                       WORK REGISTER\n@01      EQU   1                       WORK REGISTER\n@02      EQU   2                       WORK REGISTER\n@03      EQU   3                       WORK REGISTER\n@04      EQU   4                       WORK REGISTER\n@05      EQU   5                       WORK REGISTER\n@06      EQU   6                       WORK REGISTER\n         AIF   (NOT &ARMODE).ARMODE1N\n@07      EQU   7                       WORK REGISTER\n@08      EQU   8                       WORK REGISTER\n@09      EQU   9                       WORK REGISTER\n@10      EQU   10                      WORK REGISTER\n@11      EQU   11                      WORK REGISTER\n@12      EQU   12                      WORK REGISTER\n@13      EQU   13                      CALLER'S SAVE AREA\n@14      EQU   14                      WORK REGISTER\n@15      EQU   15                      BASE REG\n         USING @STRING,@15\n         USING @STRSAVE,@13\n         B     @STR003                 BRANCH AROUND EYE-CATCHER\n         DC    C'@STRING/390 R&STRING_MACRO_VERSION &ALLFEAT',0H'0'\n@STR002  DC    H'2'\n@STR003  STM   @14,@12,12(@13)         SAVE REGS (DEBUGGING ONLY)\n         AH    @14,@STR002-@STRING(@15) POINT PARM PARM-LIST OFFSET\n         BAKR  @14,0                   SAVE REGS AND RETURN ADDRESS\n         BCTR  @14,0                   ADJUST ADDR OF PARM LIST OFFSET\n         BCTR  @14,0                   ADJUST ADDR OF PARM LIST OFFSET\n         LAE   @06,0                   R6=0 AR6=0\n         CPYA  @14,@06                 AR14=0\n         CPYA  @15,@06                 AR15=0\n&LAE     SETC  'LAE'\n         AGO   .ARMODE1X\n.ARMODE1N ANOP\n@13      EQU   13                      CALLER'S SAVE AREA\n@14      EQU   14                      WORK REGISTER\n@15      EQU   15                      BASE REG\n&LAE     SETC  'LA'\n         SAVE  (14,6),,'@STRING/370 R&STRING_MACRO_VERSION &ALLFEAT'\n         USING @STRING,@15\n         USING @STRSAVE,@13\n         SLR   @06,@06                 R6=0\n.ARMODE1X ANOP\n         ICM   @06,B'0011',0(@14)      PICK UP PARM-LIST 1/2 OFFSET\n         ALR   @06,@06                 PICK UP PARM-LIST OFFSET\n         ALR   @06,@14                 R6 NOW POINTS TO PARM LIST\n         USING @STRPARM,@06\n         &LAE  @02,@STRSCON            RESOLVE FIRST SCON (ADDR)\n         BAL   @14,@STRS2A             GET ADDRESS IN R2\n         &LAE  @04,0(,@02)             KEEP ADDRESS OF \"INTO\" FIELD\n         L     @14,12(,@13)            RESTORE ADDR OF STRING MACRO\n         OI    0(@04),0                GET CLEAN S0C4 IF ADDRESS IS BAD\n         &LAE  @02,@STRFLEN            RESOLVE SECOND S-CON (LEN)\n         BAL   @14,@STRS2A             GET LENGTH IN R2\n         LR    @05,@02                 KEEP LENGTH OF \"INTO\" FIELD\n         CR    @05,@04                 END ADDRESS?\n         BL    @STR282                 NO, JUMP\n         SR    @05,@04                 CALCULATE LENGTH\n         AIF   (NOT &ARMODE).ARMODE5N\n@STR282  MSTA  @04                     SAVE R4,R5 ON LINKAGE STACK\n.*SLAC   DC    X'B247,0040'            SLAC assembler error\n         AGO   .ARMODE5X\n.ARMODE5N ANOP\n@STR282  ST    @04,8(,@13)             SAVE ADDRESS FOR LATER\n.ARMODE5X ANOP\n.**********************************************************************\n.*       MOVE FIELDS TO OUTPUT AREA                                   *\n.**********************************************************************\n         &LAE  @06,@STRFLAG            POINT TO 1ST FIELD DESC\n.*LOOP\n@STR310  EQU   *\n         AIF   (NOT &$_FEAT(1)).FEAT1A\n         TM    @STRFLAG,@STRLIT        IS THIS A LITERAL?\n         BO    @STR372                 YES, JUMP\n.FEAT1A  ANOP\n         AIF   (NOT &$_FEAT(2) AND NOT &$_FEAT(3)).FEAT23A\n         TM    @STRFLAG,@STRREG        REGISTER?\n         BO    @STR323                 YES, JUMP\n.FEAT23A ANOP\n         AIF   (NOT &$_FEAT(12)).FEAT12A\n         CLI   @STRSCON,X'E0'          IS IT %TIME ?\n         BE    @STR378                 YES, JUMP\n.FEAT12A ANOP\n.*\n.*       IT'S A FIELD (SCON)\n.*\n         &LAE  @02,@STRFLEN            RESOLVE SECOND S-CON (LEN)\n         BAL   @14,@STRS2A             GET LENGTH IN R2\n         AIF   (&$_FEAT(9)).FEAT9E1    (LEFT JUSTIFICATION, NUMERIC)\n         LTR   @03,@02                 KEEP/TEST LENGTH\n         BZ    @STR398                 ZERO LENGTH, DO NOT EDIT\n         AGO   .FEAT9E2\n.FEAT9E1 LTR   @03,@02                 KEEP/TEST LENGTH\n         BP    @STR313                 LENGTH POSITIVE, JUMP\n         TM    @STRLEN2,@STRLEFT       LEFT JUSTIFICATION?\n         BNO   @STR398                 NO, ZERO LENGTH IS NOT OK\n@STR313  EQU   *\n.FEAT9E2 ANOP\n         &LAE  @02,@STRSCON            RESOLVE FIRST SCON (ADDR)\n         BAL   @14,@STRS2A             GET ADDRESS IN R2\n         L     @14,12(,@13)            RESTORE ADDR OF STRING MACRO\n         CLI   0(@02),0                GET CLEAN S0C4 IF ADDRESS IS BAD\n         CR    @03,@02                 END ADDRESS?\n         BL    @STR314                 NO, JUMP\n         LA    @00,X'0080'             PSA ADDRESS\n         CLR   @02,@00                 PSA REFERENCE?\n         BL    @STR314                 YES, JUMP\n         SR    @03,@02                 CALCULATE LENGTH\n@STR314  EQU   *\n         AIF   (NOT &$_FEAT(6)).FEAT6A\n         TM    @STRFLAG,@STRBIN        BINARY FIELD?\n         BO    @STR328                 YES, JUMP\n.FEAT6A  ANOP\n         AIF   (NOT &$_FEAT(4)).FEAT4A\n         TM    @STRFLAG,@STRPACK       PACKED FIELD?\n         BO    @STR351                 YES, JUMP\n.FEAT4A  ANOP\n         AIF   (NOT &$_FEAT(7)).FEAT7A\n         TM    @STRFLAG,@STRHEX        EDIT IN HEX?\n         BO    @STR376                 YES, JUMP\n.FEAT7A  ANOP\n.*\n.*       TRUNCATE CHARACTER STRING\n.*\n         AIF   (NOT &$_FEAT(11)).FEAT11A\n         CLI   @STRLEN2,@STRLEFT       CHECK JUSTIFICATION, OUTPUT LEN\n         BNE   @STR390                 NO STRING TRUNCATION, JUMP\n         &LAE  @01,0(@03,@02)          FIRST BYTE AFTER FIELD\n@STR318  BCTR  @01,0                   DOWN 1 BYTE                 LOOP\n         CLI   0(@01),C' '             IS IT A SPACE ?             LOOP\n         BNE   @STR390                 LAST NON-BLANK BYTE         LOOP\n         BCT   @03,@STR318             LOOP UNTIL 1ST NON-BLANK    LOOP\n         B     @STR398                 BLANK FIELD, DO NOT EDIT\n         AGO   .FEAT11B\n.FEAT11A ANOP\n         AIF (&$_FEAT(2)+&$_FEAT(3)+&$_FEAT(4)+&$_FEAT(6) EQ 0).FEAT11B\n         B     @STR390                 EDIT\n.FEAT11B ANOP\n.*\n.*       REGISTER (R0-R13)\n.*\n         AIF   (NOT &$_FEAT(2) AND NOT &$_FEAT(3)).FEAT23B\n         AIF   (NOT &ARMODE).ARMODE7N\n@STR323  LH    @01,@STRSCON            REG NUMBER IN BITS 28-31\n         CLI   @STRSCON+1,@06          IS THIS R7-R13?\n         BH    @STR323R                YES, JUMP\n         LR    @07,@01                 SAVE R1 (R)\n         LAE   @10,0(,@04)             SAVE R4\n         LR    @11,@05                 SAVE R5\n         LAE   @12,0(,@06)             SAVE R6\n         EREG  @00,@06                 RELOAD CALLER'S R0-R6\n         EX    @07,@STR323L            COPY R0-R6 VALUE\n         LAE   @04,0(,@10)             RESTORE R4\n         LR    @05,@11                 RESTORE R5\n         LAE   @06,0(,@12)             RESTORE R6\n         B     @STR323T\n@STR323L LR    @00,*-*                 COPY VALUE FOR EDIT\n@STR323R EQU   *\n         EREG  @07,@12                 RESTORE CALLER'S R7-R12\n         EX    @01,@STR323L            COPY R7-R13 INTO R0\n         AGO   .ARMODE7X\n.ARMODE7N ANOP\n@STR323L LR    @00,*-*                 COPY VALUE FOR EDIT\n@STR323  LH    @01,@STRSCON            REG NUMBER IN BITS 28-31\n         EX    @01,@STR323L            COPY R7-R13 INTO R0\n         CLI   @STRSCON+1,@06+1        IS THIS R7-R13?\n         BNL   @STR323T                YES, JUMP\n         SLL   @01,2                   R1= 000000BB BASE * 4\n         L     @00,20(@01,@13)         PICK UP VALUE FOR R0-R6\n.ARMODE7X ANOP\n@STR323T EQU   *\n         AIF   (NOT &$_FEAT(3)).FEAT3R REG,HEX\n         AIF   (NOT &$_FEAT(2)).FEAT2H REG,BIN\n         TM    @STRFLAG,@STRHEX        EDIT IN HEX?\n         BNO   @STR330                 NO, EDIT FWD\n.FEAT2H  ANOP\n         STCM  @00,B'1111',@STRDWD-1   STORE IT FOR CVD/UNPK\n         LA    @03,8                   OUTPUT LENGTH\n         B     @STR376X                EDIT IN HEX\n.FEAT3R  ANOP\n         AIF   (NOT &$_FEAT(6)).FEAT23B\n         B     @STR330                 EDIT R0\n.FEAT23B ANOP\n.*\n.*       BINARY VARIABLE: @03 CONTAINS THE ICM MASK (1 3 7 F)\n.*\n         AIF   (NOT &$_FEAT(6)).FEAT6B\n@STR328M ICM   @00,*-*,0(@02)          **EXECUTED INSTRUCTION**\n@STR328  SLR   @00,@00\n         EX    @03,@STR328M            LOAD THE BINARY VARIABLE\n.FEAT6B  ANOP\n.*\n         AIF   (NOT &$_FEAT(2) AND NOT &$_FEAT(6)).FEAT6C\n@STR330  CVD   @00,@STRDWD             CONVERT VALUE TO DECIMAL\n         AIF   (NOT &$_FEAT(4)).FEAT6C\n         B     @STR361                 EDIT DWD\n.FEAT6C  ANOP\n.*\n.*       PACKED FIELD\n.*\n         AIF   (NOT &$_FEAT(4)).FEAT4B\n@STRZAP  ZAP   @STRDWD,0(*-*,@02)      MOVE TO @STRDWD\n@STR351  &LAE  @03,0(,@02)             FIRST BYTE OF PACKED FIELD\n         BALR  @14,0\n         TM    0(@03),X'0C'            IS THIS THE SIGN BYTE?\n         LA    @03,1(,@03)              (NEXT BYTE)\n         BNOR  @14                     NO, LOOP MORE\n         SLR   @03,@02                 GET LENGTH OF PACKED FIELD\n         BCTR  @03,0\n         EX    @03,@STRZAP             EXECUTE ZAP\n         AIF   (NOT &$_FEAT(5)).FEAT4B\n         CLI   @STRLEN2,248            JULIAN-TO-YYMMDD CONV?\n         BNL   @STR375                 YES, JUMP\n.FEAT4B  ANOP                          PACKED\n.*\n.*       EDIT @STRDWD (BIN, REG, PACKED)\n.*\n         AIF   (NOT &$_FEAT(8)).FEAT8B\n@STR361  IC    @00,@STRLEN2            OUTPUT LENGTH\n         LA    @03,X'003F'             MASK FOR \"AND\"\n         NR    @03,@00                 OUTPUT LENGTH\n         MVC   @STRWK16(16),@STRMASK   EDIT MASK\n.*\n.*       LEFT-JUSTIFICATION (NUMERIC)\n.*\n         AIF   (NOT &$_FEAT(9)).FEAT9B\n         TM    @STRLEN2,@STRLEFT       LEFT JUSTIFICATION?\n         BNO   @STR367                 NO, JUMP\n         &LAE  @01,@STRWK16+15         PREVENT BAD R1\n         EDMK  @STRWK16(16),@STRDWD    ZONED DECIMAL\n         &LAE  @02,0(,@01)             FIRST STRING POSITION\n         LTR   @03,@03                 CHECK OUTPUT LENGTH\n         BNZ   @STR363                 JUMP IF NOT ZERO\n.*       L0    (LEFT JUSTIFIED, NO PADDING)\n         &LAE  @03,@STRWK16+16         FIRST POSITION AFTER STRING\n         SR    @03,@02                 COMPUTE STRING LENGTH\n         B     @STR390                 MOVE FIELD TO OUTPUT LINE\n.*       L1-L63 (LEFT JUSTIFIED, PADDING)\n@STR363  CR    @03,@05                 COMPARE LENGTH TO REMAINING LEN\n         BNH   @STR364                 LARGE ENOUGH, JUMP\n         LR    @03,@05                 TOO BIG, TRUNCATE TO REM. LEN.\n@STR364  SR    @05,@03                 COMPUTE REMAINING LENGTH\n         AIF   (NOT &ARMODE).ARMODE8N\n         LAE   @08,0(,@04)             POINTER IN OUTPUT LINE\n         LR    @09,@03                 LENGTH WITH PADDING\n         AGO   .ARMODE8X\n.ARMODE8N ANOP\n         LR    @00,@04                 POINTER IN OUTPUT LINE\n         LR    @01,@03                 LENGTH WITH PADDING\n.ARMODE8X ANOP\n         LA    @03,@STRWK16+16         FIRST POSITION AFTER STRING\n         SR    @03,@02                 COMPUTE STRING LENGTH\n         B     @STR392                 MOVE FIELD TO OUTPUT LINE\n@STR367  EQU   *\n.FEAT9B  ANOP\n         AIF   (NOT &$_FEAT(10)).FEAT10B\n         TM    @STRLEN2,@STRZERO       LEADING ZEROES REQ'D?\n         BNO   @STR368                 NO, JUMP\n         MVI   @STRWK16,C'0'           YES, CHANGE X'40' TO C'0'\n@STR368  EQU   *\n.FEAT10B ANOP\n         ED    @STRWK16(16),@STRDWD    ZONED DECIMAL\n         &LAE  @02,@STRWK16+16         FIRST POSITION AFTER STRING\n         SR    @02,@03                 FIRST STRING POSITION\n.FEAT8B  ANOP\n.*\n.*       LITERAL (@STRSCON IS A 16-BIT OFFSET)\n.*       BLANKS  (@STRSCON=ZERO)\n.*\n         AIF   (NOT &$_FEAT(1)).FEAT1B\n         B     @STR390                 MOVE STRING TO OUTPUT LINE\n@STR372  &LAE  @02,0                   R2=0,AR2=0\n         ICM   @02,B'0011',@STRSCON    LOAD LITERAL OFFSET\n         BZ    @STR372L                BLANKS, JUMP\n         LA    @02,@STRSCON(@02)       CONVERT OFFSET TO FULL ADDRESS\n@STR372L LH    @03,@STRFLEN            GET LITERAL LENGTH\n.FEAT1B  ANOP\n.*\n.*       CONVERT JULIAN DATE TO YYMMDD\n.*\n         AIF   (NOT &$_FEAT(5)).FEAT5F\n         B     @STR390                 MOVE STRING TO OUTPUT LINE\n@STR375  LA    @00,248                 MASK FOR 'SLR'\n         SLR   @01,@01\n         IC    @01,@STRLEN2            248-255\n         SLR   @01,@00                 000-007\n         LA    @00,12                  L'@STR375W\n         MR    @00,@00                 COMPUTE OFFSET\n         &LAE  @01,@STR375W(@01)       ENTRY IN \"TR\" MASK TABLE\n         SLR   @03,@03\n         IC    @03,0(,@01)             LENGTH OF DATE (6, 8 OR 10)\n         ZAP   @STRDWD,@STRDWD         DATE=0000000?               @JDT\n         BNZ   @STR375B                NO, JUMP                    @JDT\n@STR375Z &LAE  @02,@STRBLANKS          WORK AREA\n&STRBLANKS SETA 10                     WE NEED AT LEAST 10 BLANKS\n         B     @STR390                 MOVE FIELD TO OUTPUT LINE\n@STR375W DC    AL1(10,C'-',0,1,2,3,8,4,5,8,6,7) YYYY-MM-DD   248\n         DC    AL1(8,C' ',0,1,2,3,4,5,6,7,8,8)  YYYYMMDD//   249\n         DC    AL1(8,C'/',2,3,8,4,5,8,6,7,8,8)  YY/MM/DD//   250\n         DC    AL1(8,C'/',6,7,8,4,5,8,2,3,8,8)  DD/MM/YY//   251\n         DC    AL1(8,C'/',4,5,8,6,7,8,2,3,8,8)  MM/DD/YY//   252\n         DC    AL1(6,C' ',2,3,4,5,6,7,8,8,8,8)  YYMMDD       253\n.*       DC    AL1(6,C' ',6,7,4,5,2,3,8,8,8,8)  DDMMYY       254\n.*       DC    AL1(6,C' ',4,5,6,7,2,3,8,8,8,8)  MMDDYY       255\n@STR375T DC    P'59,31,29,31,30,31,30,31,31,30,31,30,31'\n@STR375B CLI   @STRDWD+4,X'01'         YEAR 2000 OR ABOVE?\n         BH    @STR375C                CC>01, JUMP (MUST BE 19 OR 20)\n         MVI   @STRDWD+4,X'20'         CC=01, CHANGE TO CC=20\n         BE    @STR375C                CC=01, USE CC=20\n         CLI   @STRDWD+4+1,X'50'       YY<50?\n         BL    @STR375C                YES, USE CC=20\n         MVI   @STRDWD+4,X'19'         NO, FORCE CC=19\n@STR375C UNPK  @STRWK16(5),@STRDWD+4(3) CCYY?\n         ZAP   @STRDWD+1(2),@STR375T+9(1) INIT MONTH COUNTER\n         &LAE  @02,@STR375T            TABLE OF MONTHS (NUMBER OF DAYS)\n         TM    @STRDWD+4+1,X'01'       ODD YEARS\n         BO    @STR375N                  AREN'T LEAP YEARS\n         TM    @STRDWD+4+1,X'12'       ZEROES IN 1980, ALL ONES IN 1992\n         BNM   @STR375L                MIXED IN 1982/1990\n.*       IF IT'S NOT A LEAP YEAR AND DDD>59, THEN ADD 1 TO DDD\n@STR375N CP    @STRDWD+4+2(2),@STR375T ARE WE PAST FEB 28 (DDD>59) ?\n         BNH   @STR375L                NO, JUMP\n         AP    @STRDWD+4+2(2),@STR375T+3(1) ADD 1 (FROM 31) TO DDD\n.*--LOOP WHILE DDD > 0\n@STR375L AP    @STRDWD+1(2),@STR375T+3(1)   ADD 1 (FROM 31) TO MONTH\n         LA    @02,2(,@02)             NEXT ENTRY IN \"MONTHS\" TABLE\n         SP    @STRDWD+4+2(2),0(2,@02) SUB DAYS-IN-MONTH FROM DDD\n         BP    @STR375L\n.*--ENDLOOP\n         AP    @STRDWD+4+2(2),0(2,@02) UNDO LAST \"SP\" INSTRUCTION\n         UNPK  @STRWK16+4(2),@STRDWD+1(2) FYFYFYFY,FMCM??\n         UNPK  @STRWK16+6(2),@STRDWD+6(2) FYFYFYFY,FMCMFDCD\n         MVZ   @STRWK16+1(7),@STRWK16     FYFYFYFY,FMCMFDCD\n         MVC   @STRWK16+8(1),1(@01)    SEPARATOR\n         &LAE  @02,@STRWK16+9          WORK AREA\n         MVC   0(10,@02),2(@01)        MOVE CORRESPONDING MASK\n         TR    0(10,@02),@STRWK16      CONVERT DATE TO THE RIGHT FORMAT\n.FEAT5F  ANOP                          JDATE\n.*\n.*       HEX STRING\n.*\n         AIF   (NOT &$_FEAT(7)).FEAT7B\n         B     @STR390                 MOVE STRING TO OUTPUT LINE\n@STR376M MVC   @STRDWD-1(*-*),0(@02)   PREVENT S0C4 IN UNPK\n@STR376  LA    @00,8                   MAX LENGTH\n         CLR   @03,@00                 CHECK LENGTH\n         BNH   @STR376B                JUMP IF LE 8\n         LR    @03,@00                 TRUNCATE TO MAXIMUM LENGTH\n@STR376B LR    @01,@03                 INPUT LENGTH\n         BCTR  @01,0\n         EX    @01,@STR376M            MOVE DATA TO SAFE STORAGE\n         ALR   @03,@03                 OUTPUT LENGTH\n         AGO   .FEAT37B\n.FEAT7B  ANOP\n         AIF   (NOT &$_FEAT(3)).FEAT37C\n         B     @STR390                 MOVE STRING TO OUTPUT LINE\n.FEAT37B ANOP\n@STR376X &LAE  @02,@STRWK16            WORK AREA\n         UNPK  0(9,@02),@STRDWD-1(5)   EXPAND SOURCE BYTES FOR \"TR\"\n         UNPK  8(9,@02),@STRDWD+3(5)   EXPAND SOURCE BYTES FOR \"TR\"\n         TR    0(16,@02),@STRHEXT-240  =C'0123456789ABCDEF'\n.FEAT37C ANOP\n.*\n.*       %TIME\n.*\n         AIF   (NOT &$_FEAT(12)).FEAT12B\n         B     @STR390                 MOVE STRING TO OUTPUT LINE\n@STRTIME DC    X'4021207A20207A20207A20204000'    0X.XX.XX.XX\n@STR378  LR    @02,@15                 SAVE BASE REG\n         TIME  DEC                     GET HHMMSSHH\n         LR    @15,@02                 RESTORE BASE REG\n         ST    @00,@STRDWD             STORE HHMMSSHH\n         MVC   @STRWK16(13),@STRTIME   MOVE EDIT MASK\n         ED    @STRWK16(13),@STRDWD    EDIT HH:MM:SS:HH\n         &LAE  @02,@STRWK16+1          WORK AREA\n         LA    @03,12                  HH:MM:SS:HH+ SPACE\n.FEAT12B ANOP\n.*MOVE\n@STR390  CR    @03,@05                 COMPARE LENGTH TO REMAINING LEN\n         BNH   @STR391                 LARGE ENOUGH, JUMP\n         LR    @03,@05                 TOO BIG, TRUNCATE TO REM. LEN.\n@STR391  SR    @05,@03                 COMPUTE REMAINING LENGTH\n         AIF   (NOT &ARMODE).ARMODE39N\n         LAE   @08,0(,@04)             POINTER IN OUTPUT LINE\n         LR    @09,@03                 PASS REMAINING LENGTH\n         AGO   .ARMODE39X\n.ARMODE39N ANOP\n         LR    @00,@04                 POINTER IN OUTPUT LINE\n         LR    @01,@03                 PASS REMAINING LENGTH\n.ARMODE39X ANOP\n         LTR   @02,@02                 BLANKS?\n         BNZ   @STR392                 NO, JUMP\n         SLR   @03,@03                 YES, ZERO LENGTH\n@STR392  ICM   @03,B'1000',@STRBLANKS  PAD WITH BLANKS\n         AIF   (NOT &ARMODE).ARMODE44N\n         MVCL  @08,@02                 MOVE FIELD TO OUTPUT LINE\n         LR    @04,@08                 NEW POINTER IN OUTPUT LINE\n         AGO   .ARMODE44X\n.ARMODE44N ANOP\n         MVCL  @00,@02                 MOVE FIELD TO OUTPUT LINE\n         LR    @04,@00                 NEW POINTER IN OUTPUT LINE\n.ARMODE44X ANOP\n@STR398  TM    @STRFLAG,@STRLAST       TEST LAST-ENTRY INDICATOR\n         LA    @06,@STRNEXT            BUMP UP TO NEXT ENTRY\n         BNO   @STR310                 PROCESS NEXT ENTRY\n.*ENDLOOP\n.*\n.*       END-OF-LINE PROCESSING - PAD WITH BLANKS\n.*\n         SLR   @01,@01                 SET UP R1 FOR PADDING\n         ICM   @01,B'1000',@STRBLANKS  SET UP R1 FOR PADDING\n         AIF   (NOT &ARMODE).ARMODE52N\n.***     DROP  @06,@13,@15\n         LA    @15,3                   MODIFIABLE AREA\n         ESTA  @14,@15                 R14 = START OF OUTPUT AREA\n         LR    @15,@04                 END OF OUTPUT AREA\n         SR    @15,@14                 R15 = LENGTH USED IN OUTPUT AREA\n         MVCL  @04,@00                 PAD WITH BLANKS\n         EREG  @00,@14                 RESTORE WORK REGISTERS\n         STM   @14,@12,12(@13)         MAKE SAVE AREA LOOK NORMAL\n         OI    15(@13),1               SIMULATE \"T\" OPTION OF RETURN\n         PR                            RETURN TO CALLER\n         AGO   .ARMODE52X\n.ARMODE52N ANOP\n         LA    @14,2                   INCREMENT\n         AL    @14,12(,@13)            RETURN ADDRESS\n         SLR   @01,@01                 SET UP R1 FOR PADDING\n         ICM   @01,B'1000',@STRBLANKS  SET UP R1 FOR PADDING\n         LR    @15,@04                 CURRENT POINTER IN OUTPUT FIELD\n         SL    @15,8(,@13)             CALCULATE LENGTH USED\n         MVCL  @04,@00                 PAD WITH BLANKS\n         LM    @00,@06,20(@13)         RESTORE WORK REGISTERS\n         STM   @06+1,@13-1,48(@13)     MAKE SAVE AREA LOOK NORMAL\n         OI    15(@13),1               SIMULATE \"T\" OPTION OF RETURN\n         BR    @14                     RETURN TO CALLER\n.ARMODE52X ANOP\n.*\n         AIF   (NOT (&$_FEAT(3) OR &$_FEAT(7))).FEAT37T\n@STRHEXT DC    C'0123456789ABCDEF'     HEX-TO-EBCDIC CONVERSION\n.FEAT37T ANOP\n         AIF   (NOT &$_FEAT(8)).FEAT8T\n@STRMASK DC    X'4020202020202020,2020202020202120'\n.FEAT8T  ANOP\n.**********************************************************************\n.*       CONVERT S-CON TO 31-BIT ADDRESS (RESULT RETURNED IN R2)      *\n.**********************************************************************\n@STRS2A  SLR   @00,@00\n         ICM   @00,B'0011',0(@02)      R0 = 0000BDDD\n         SRDL  @00,12                  R0 = 0000000B, R1= DDD.....\n         SRL   @01,20                  R1 = 00000DDD (DISPLACEMENT)\n         AIF   (NOT &ARMODE).ARMODE88N\n         SLL   @00,2                   MULT BY 4\n         CLI   0(@02),@07*16           R7-R13?\n         BNL   @STRS2A7                YES, JUMP\n.*BASE REG IS R0-R6\n@STRS2A4 LTR   @02,@00                 IS R0 THE BASE REG?\n         BNZ   @STRS2A5                NO, JUMP\n         LTR   @02,@01                 IS THIS A PSA ADDRESS?\n         BNZR  @14                     YES, GOBACK\n         EREG  @00,@00                 POP R0\n         LAE   @02,0                   R2=0 AR2=0\n         LR    @02,@00                 PASS R0 VALUE\n         LA    @02,0(,@02)             CLEAN UP\n         BR    @14                     GOBACK\n@STRS2A5 LR    @07,@00                 SAVE R0 (B*4)\n         LR    @08,@01                 SAVE R1 (DDD)\n         LR    @09,@03                 SAVE R3\n         LAE   @10,0(,@04)             SAVE R4\n         LR    @11,@05                 SAVE R5\n         LAE   @12,0(,@06)             SAVE R6\n         EREG  @01,@06                 RELOAD CALLER'S R1-R6\n         EX    0,@STRS2A9-4(@07)       ADD BASE REG VALUE TO DISPL\n         LR    @03,@09                 RESTORE R3\n         LAE   @04,0(,@10)             RESTORE R4\n         LR    @05,@11                 RESTORE R5\n         LAE   @06,0(,@12)             RESTORE R6\n         BR    @14                     GOBACK\n.*BASE REG IS R7-R13\n@STRS2A7 LR    @02,@00                 R2= 0000000B (BASE REG NUMBER)\n         EREG  @07,@12                 RESTORE CALLER'S R7-R12\n         EX    0,@STRS2A9-4(@02)       ADD BASE REG VALUE TO DISPL\n         BR    @14                     GOBACK\n@STRS2A9 LAE   @02,0(@08,@01)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@08,@02)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@08,@03)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@08,@04)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@08,@05)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@08,@06)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@07)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@08)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@09)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@10)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@11)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@12)          ADD BASE REG VALUE TO DISPL\n         LAE   @02,0(@01,@13)          ADD BASE REG VALUE TO DISPL\n         AGO   .ARMODE88X\n.ARMODE88N ANOP\n         CLI   0(@02),(@06+1)*16       R7-R13?\n         BL    @STRS2A5                NO, JUMP\n.*BASE REG IS R7-R13\n         LR    @02,@00                 R2= 0000000B (BASE REG NUMBER)\n         EX    @02,@STRS2A4            ADD BASE REG VALUE TO DISPL\n         B     @STRS2A7                CLEAN UP ADDRESS\n@STRS2A4 LA    @02,0(*-*,@01)          ADD BASE REG VALUE TO DISPL\n.*BASE REG IS R0-R6\n@STRS2A5 LTR   @02,@00                 IS R0 THE BASE REG?\n         BNZ   @STRS2A6                NO, JUMP\n         LTR   @02,@01                 IS THIS A PSA ADDRESS?\n         BNZR  @14                     YES, GOBACK\n@STRS2A6 SLL   @02,2                   R2= 000000BB BASE * 4\n         L     @02,20(@02,@13)         PICK UP BASE REG VALUE\n         LA    @02,0(@02,@01)          ADD BASE REG VALUE TO DISPL\n.*CLEAN UP R2 BASED ON CALLER'S AMODE\n@STRS2A7 TM    12(@13),X'80'           CALLER'S IN AMODE31?\n         BOR   @14                     YES, GOBACK\n         ICM   @02,B'1000',16          NO, ZERO HI-ORDER BYTE\n         BR    @14\n.ARMODE88X ANOP\n         AIF   ('&OPT3' EQ 'LOCTR').GENL7L\n@STRBLANKS DC  CL((((*+&STRBLANKS+7-@STRING)/8)*8)-(*-@STRING))' '\n         AGO   .GENL7X\n.GENL7L  ANOP\n@STRBLANKS DC  CL&STRBLANKS.' '\n.GENL7X  ANOP\n@STRING_SIZE EQU *-@STRING             SIZE OF GENERATED CSECT\n.**********************************************************************\n.*       WORK AREA (CALLER'S SAVE AREA)                               *\n.**********************************************************************\n@STRSAVE DSECT                         24-BYTE WORK AREA\n         DS    A(0,@STRSAVE,@STRSAVE,14,15,0,1,2,3,4,5,6)\n@STRWK16 DS    F'7,8,9,10'             WORK AREA\n@STRDWD  DS    D'1112'                 WORK AREA\n@STRPARM DSECT\n@STRSCON DS    S                   +0  FIELD ADDRESS\n@STRFLEN DS    S                   +2  FIELD LENGTH\n@STRFLAG DS    B                   +4  FORMAT, FLAGS\n@STRLAST EQU   X'80'                     LAST ENTRY\n@STRLIT  EQU   X'40'                     LITERAL, @STRSCON IS AN OFFSET\n@STRJDT  EQU   X'20'                     JULIAN DATE\n.*             X'3F'                   CONVERSION REQUIRED\n@STRHEX  EQU   X'08'                     HEXADECIMAL\n@STRBIN  EQU   X'04'                     BINARY\n@STRPACK EQU   X'02'                     PACKED\n@STRREG  EQU   X'01'                     REGISTER\n@STRLEN2 DS    B                   +5  FORMAT, OUTPUT LENGTH\n@STRLEFT EQU   X'80'                     LEFT JUSTIFICATION\n@STRZERO EQU   X'40'                     LEADING ZEROES\n.*             X'3F'                     OUTPUT LENGTH, 0 MEANS TRUNC.\n@STRNEXT EQU   *                   +6\n         AIF   (NOT D'$LTORG).MEND99   CSECT-ONLY\n         AIF   (D'$STRING).MEND99      CSECT-ONLY\n$LTORG   LOCTR\n         AIF   ('&OPT3' EQ 'LOCTR').GENL9L\n         CNOP  0,4\n$STRING  BALR  @15,0                   LOCAL BASE\n         L     @15,6(@15,0)            ROUTINE ADDRESS           00\n         BR    @15                     GO TO @STRING             04\n         AGO   .GENL9\n.GENL8   ANOP                          GENERATE,NOCSECT\n&$_LIT   SETA  0                       DO NOT GENERATE LITERALS TWICE\n&$_FEAT(1) SETB 1,1,1,1,1,1,1,1,1,1,1,1   GENERATE=FULL\n$LTORG   LOCTR\n         CNOP  0,4\n$STRING  BALR  R15,0                   LOCAL BASE\n         L     R15,6(R15,0)            ROUTINE ADDRESS           00\n         BR    R15                     GO TO @STRING             04\n.GENL9   ANOP\n         DC    V(@STRING)              ROUTINE ADDRESS           06\n         AGO   .MEND\n.GENL9L  POP   USING                   GENERATE,LOCTR\n$STRING  BAS   R15,$STRING2\n         DC    Y(@STRING-*)            OFFSET TO @STRING ROUTINE\n$STRING2 AH    R15,0(R15)\n         BR    R15\n.MEND    AIF   ('&PRINT' EQ 'NOGEN').MEND99\n         POP   PRINT\n.MEND99  MEND\n         EJECT\n**********************************************************************\n**********************************************************************\n********* TEST PROGRAM FOR THE 'STRING' MACRO ************************\n**********************************************************************\n**********************************************************************\n**       STRING (GENERATE,AR_MODE)\n**       END\n         LCLA  &ASMH_HLASM\n         AIF   (T'&ASMH_HLASM EQ 'N').ASMH1X\n&SYSVER  SETC  'ASMH'\n&SYSDATC SETC  '20'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)\n.ASMH1X  ANOP\nTESTPGM  START X'027000'\n         BALR  R12,0\n         USING *,R12\n LOAD EP=SYSDEBUG\n LR R15,R0\n BASSM R14,R15\n*STRING 1X,INTO=XXX\n         OPEN  (SYSPRINT,OUTPUT)\n         STRING 'Assembler is &SYSVER, DATE is &SYSDATC',INTO=XXX\n         PUT   SYSPRINT,XXX\nRBPREFIX EQU   *\nRBINTCOD EQU   *+6,2,C'H'\nASCBASID EQU   *+8,2,C'X'\n         L     R1,PSATOLD-PSA\n         L     R1,0(,R1)               TCBRBP\n         STRING 'SVC',(RBINTCOD-RBPREFIX(R1),H,R3Z),                   X\n               1X,(WWWW,,T),' - ',     VV.MM OF SVC RTNE               X\n               ((R8),,X),1X,           COM-REG ADDR                    X\n               (ASCBASID,,X),1X,       ASID                            X\n               PARM1,1X,               MAIN PGM NAME                   X\n               INTO=XXX\n         PUT   SYSPRINT,XXX\n*\n         LA    R2,XXX\n         STRING 1X,INTO=((R2),8)\n         MACRO                                       JDATE MACRO\n        @JDATE &DATE                                 JDATE MACRO\n         LA    R1,=P'&DATE'                          JDATE MACRO\n*** STRING ((R1),P),2X,((R1),P),INTO=XXX\n         STRING ((R1),P),2X,((R1),P,YYMMDD),INTO=XXX,                  X\n               3X,((R1),P,YY/MM/DD),                                   X\n               3X,((R1),P,DD/MM/YY),                                   X\n               3X,((R1),P,MM/DD/YY),                                   X\n               3X,((R1),P,YYYYMMDD),                                   X\n               3X,((R1),P,YYYY-MM-DD)\n         PUT   SYSPRINT,XXX                          JDATE MACRO\n         MEND                                        JDATE MACRO\n        @JDATE 90058\n        @JDATE 91059\n        @JDATE 93060\n        @JDATE 94365\n        @JDATE 80058\n        @JDATE 84059\n        @JDATE 88060\n        @JDATE 92061\n        @JDATE 00366\n         LA    R2,1234\n         STRING 'CVTPTR=X''',(CVTPTR,4,X),'''',INTO=XXX,               X\n               ' 1234=',((R2),,R4Z)\n         PUT   SYSPRINT,XXX\n         L     R1,CVTPTR\n         STRING 'CVTDATE=',(56(R1),P,YYMMDD),INTO=XXX\n         PUT   SYSPRINT,XXX\n         LA    R0,1000\n         LA    R3,0033\n         STRING 'D1=/',D1,'/,WWWW=/',WWWW,'/',                         X\n               ((R3),,L),'/',((R3),,X),'/',((R0),,L),'/',              X\n               ((R3),,R9B),'/',INTO=XXX\n         LR    R4,R15                   LENGTH USED\n         PUT   SYSPRINT,XXX\n         STRING WWWW,                                                  X\n               (4(R13),4,X),'''',(4(R13),F),'''',                      X\n               (4(R13),F,L),'''',                                      X\n               (4(R13),F,L11),'''',                                    X\n               (4(R13),F,Z9),'''',                                     X\n               8X,'R4=',((R4),,L),      LENGTH USED                    X\n               INTO=XXX\n         PUT   SYSPRINT,XXX\n         STRING %TIME,D1,'B12345678B',5X,(CTR1,P),1X,PARM1,1X,PARM2,   X\n               INTO=XXX\n         PUT   SYSPRINT,XXX\n         LA    R3,22\n         STRING INTO=XXX,'CCC1234A',(D1,(R3)),'.',(CTR1,P,R7Z)\n         PUT   SYSPRINT,XXX\n         STRING C'DDN2(',(D1,,T),')',X'40C1C2C3C4',                    +\n               ' PSATOLD=',(PSATOLD-PSA,,X),                           +\n               INTO=XXX\n         PUT   SYSPRINT,XXX\n         AIF   ('&SYSVER' EQ 'ASMH').HLASM99\nPSABASE  USING PSA,R0\n         STRING 'PSATOLD=',(PSABASE.PSATOLD,,X),                       +\n               ' PSATOLD=',(PSATOLD-PSA,,X),                           +\n               INTO=XXX\n         PUT   SYSPRINT,XXX\n.HLASM99 ANOP\n         BALR  R0,0\n         STRING 'R0=',((R0),,X),'   16(R0)=',(16(R0),4,X),INTO=XXX\n         PUT   SYSPRINT,XXX\n*\nAMODE31  LA    R12,0(,R12)             BALR->BASR\n         L     R15,=A(*+X'80000006')   AMODE=31\n         BSM   0,R15                   AMODE=31\n         L     R1,=A(@STRING)          point at CSECT\n         CLC   =C'/390',11(R1)         (GENERATE,AR_MODE) ?\n         BNE   EXIT                    no, prevent S0E0\n         DSPSERV CREATE,                                               X\n               NAME==CL8'STRING00',    C'STRING00'                     X\n               BLOCKS=HDRBLKS,         SIZE IN PAGES                   X\n               STOKEN=DSPCSTKN,                                        X\n               ORIGIN=DSPCORG\n         ALESERV ADD,STOKEN=DSPCSTKN,ALET=DSPCALET\n         LAM   R8,R8,DSPCALET          POINT TO THE DATA SPACE\n         L     R8,DSPCORG              SPACE ORIGIN (0 OR 4096)\n         SAC   512                     MODE=AR\n LAM R14,R6,TESTPGM+40                 S0E0-28\n         STRING WWWW,'AR_MODE WORKED OK',INTO=(2048(R8),100)\n         LAM   R2,R2,DSPCALET          POINT TO THE DATA SPACE\n         LR    R2,R8                   SPACE ORIGIN (0 OR 4096)\n         STRING (2048+L'WWWW(R2),30,T),INTO=XXX\n         SAC   0                       MODE=AR OFF\n         PUT   SYSPRINT,XXX            AR_MODE WORKS OK\n*\nEXIT     SLR   R15,R15\n         SVC   3                       GOBACK\nD1       DC    C'D1-----D1    '\nWWWW     DC    C'WWWW'\nCTR1     DC    P'1'\nPARM1    DC    C'<-PARM1->'\nPARM2    DC    C'<-PARM2->'\nXXX      DS    CL132\nDSPCSTKN DS    XL8                  0  AS TOKEN\nDSPCALET DS    F                    8  ALET\nDSPCORG  DS    F                   12  ORIGIN\nHDRBLKS  DC    F'100'\nCVTPTR   EQU   0016,4,C'A'\nSYSPRINT DCB   DSORG=PS,DDNAME=SYSPRINT,MACRF=PM,RECFM=FB,LRECL=121\nXYZ      DSECT\n         STRING GENERATE\n**       STRING (GENERATE,NO_CSECT) -\\\n**       STRING (GENERATE,AR_MODE)  -/\n**       STRING (GENERATE,,LOCTR)\n**       STRING (GENERATE,AR_MODE,LOCTR)\n**       STRING (GENERATE,NO_CSECT,LOCTR)    invalid combination\n         YREGS\nPSA      DSECT\nPSATOLD  EQU   *+X'21C',4,C'A'\n         END\n*/SYSPRINT DD SYSOUT=*\n*/SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n*/SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n*/SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n*/*\n*/GO      EXEC PGM=LOADER,PARM=PRINT,TIME=(,1)\n*/SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,DELETE)\n*/SYSLOUT  DD SYSOUT=*\n*/SYSPRINT DD SYSOUT=*\n*/ABNLTERM DD SYSOUT=*\n*/ABNLIGNR DD DUMMY\n*/SYSDEBUG DD SYSOUT=*\n*/SYSUDUMP DD SYSOUT=*\n*/\n*/        +----------------------------------------+\n*/        +                                        +\n*/        +   Documentation for the STRING macro   +\n*/        +                                        +\n*/        +       Last update: 13 Dec 1999         +\n*/        +----------------------------------------+\n*/\n*/The STRING macro is functionally similar to the COBOL DISPLAY\n*/or PL/I PUT EDIT instructions.\n*/\n*/Using STRING, you can concatenate any number of fields, edit\n*/each of them if necessary, and get the result in the work area\n*/you specify.\n*/\n*/Formats:\n*/\n*/  (1) label  STRING {field_specification1}\n*/                    {,field_specification2}...\n*/                    ,INTO=workarea|(workarea,length)\n*/                    {,PRINT=GEN|NOGEN}\n*/\n*/  (2) label  STRING GENERATE\n*/                    {,PRINT=GEN|NOGEN}\n*/\n*/\n*/field_specification\n*/\n*/  Each field to be printed is described as a positional\n*/  operand.  Each operand specifies the field address, its\n*/  length, and its formatting requirements.\n*/\n*/  Four field description formats are supported:\n*/\n*/    1.   symbol\n*/    2.   (symbol,length,format)\n*/    3.   (d(r)|(r),length,format)\n*/    4.   ((r),,format)\n*/    5.   'character string'\n*/\n*/Symbol specifies the field address.  It must be an\n*/  S-type (relocatable) address.\n*/\n*/d(r) may be used to specify the field address in S/370\n*/  base-displacement format.  If d is zero, it may be omitted.\n*/  If d(r) or (r) is used, length must also be specified.  R14\n*/  and R15 may not be used.  If d(0) is used, it is handled the\n*/  way the assembler does, i.e. R0 as a base register is assumed\n*/  to contain zero: 16(0) is equivalent to 16, CVTPTR or, X'10'.\n*/\n*/((r),,format) specifies that (r) contains the value\n*/  itself, not an address.  R14 and R15 may not be used.\n*/\n*/'character string' specifies a literal enclosed in single quotes\n*/  as specified in a DC instruction.  Hex strings or character\n*/  strings are supported.  The following expressions are equivalent:\n*/  'ABC' C'ABC' X'C1C2C3'\n*/\n*/Length specifies the length and/or the type of the input field.\n*/  It may be specified as an integer, a symbol, a register, or a\n*/  constant.  When used with symbol, it overrides the assembled\n*/  length and/or type.  Length is required if field is specified\n*/  as d(r) or (r).  If a zero length is specified, the field is\n*/  ignored.\n*/\n*/      nn   field length in bytes\n*/      H    half-word\n*/      F    full-word\n*/      FL1  1-byte binary integer\n*/      FL3  3-byte binary integer\n*/      P    packed field\n*/      (r)  length of character string (R0 thru R12)\n*/      d(r) length of character string (R1 thru R12)\n*/\n*/Notes:  If the field address is specified as a symbol that\n*/        has been defined previously in the program, the symbol\n*/        type is known and there is no need to specify it.\n*/\n*/        If the length is specified as (r) or d(r) and the value\n*/        is greater than the address itself, (r) or d(r) is\n*/        considered to be the end address +1 instead of the length.\n*/\n*/        The length is not specified for packed fields.  The\n*/        @STRING subroutine scans the field left-to-right until it\n*/        finds a byte with a valid sign in the low-order 4 bits.\n*/\n*/        If symbol is an arithmetic expression and no length is coded,\n*/        the implicit length will be that of the first symbol in the\n*/        expression;  for example, if symbol is coded as PSATOLD-PSA,\n*/        then the implicit length will be L'PSATOLD.\n*/\n*/        All numeric items are assumed positive.\n*/\n*/format  optionally indicates editing options that must\n*/        be applied to a field.\n*/\n*/    L        left justified\n*/    R        right justified\n*/    nn       output length\n*/    0        adjust length\n*/    Z        leading zeroes\n*/    B        leading/trailing blanks\n*/    T        truncate character string after last non-blank\n*/    X        display in hexadecimal\n*/    YYMMDD   convert julian date to YYMMDD\n*/    YY/MM/DD convert julian date to YY/MM/DD\n*/    DD/MM/YY convert julian date to DD/MM/YY\n*/    MM/DD/YY convert julian date to MM/DD/YY\n*/    YYYYMMDD convert julian date to YYYYMMDD\n*/    YYYY-MM-DD convert julian date to YYYY-MM-DD\n*/\n*/  The default format depends on the field type:\n*/\n*/      Type                   Default Format\n*/\n*/      character string             L\n*/      FL1                          R3B\n*/      H or FL2                     R5B\n*/      other numeric fields         R7B\n*/\n*/  Note: L0 and T are equivalent for character strings.\n*/\n*/'character string' is any character string enclosed in\n*/single quotes.  Blank spaces may be specified as nnX,\n*/where nn is the number of X'40' bytes you want to be\n*/inserted in the output line.  %TIME may be specified to\n*/obtain the current time in hh.mm.ss.hh format.\n*/\n*INTO=workarea|(workarea,length)\n*/\n*/INTO indicates the address and length of the output work area\n*/into which the result of the concatenation should be placed\n*/(left justified).  If the work area is too small, truncation\n*/will occur.  If it is too large, it is padded with blanks.\n*/\n*/The address may be a symbol, d(r) (S-type address) or (r).\n*/\n*/The length may be specified as an integer, a symbol, a register,\n*/or a constant; it is required if the address is coded as d(r) or\n*/(r).  If length is not specified for a symbol-type address, the\n*/assembled length of the symbol is used.\n*/\n*/Upon return from STRING, R15 contains the length actually used\n*/in the output work area (before padding).\n*/\n*PRINT=GEN|NOGEN\n*/\n*/This operand allows you to temporarily override the PRINT\n*/specification (GEN or NOGEN).\n*/\n*GENERATE (format 2)\n*/\n*/The GENERATE format must be specified once at the end of the\n*/program.  It generates the @STRING sub-routine as well as all\n*/the literals specified in previous invocations of the macro.\n*/\n*/The GENERATE format allows the specifications of the\n*/AR_MODE, NO_CSECT and LOCTR options.\n*/\n*/       STRING GENERATE<,AR_MODE<,LOCTR>>>\n*/                        NO_CSECT\n*/\n*/The following combinations are valid:\n*/\n*/       STRING GENERATE\n*/       STRING (GENERATE,NO_CSECT)\n*/       STRING (GENERATE,AR_MODE)\n*/       STRING (GENERATE,,LOCTR)\n*/       STRING (GENERATE,AR_MODE,LOCTR)\n*/\n*/The AR_MODE option can be specified to generate a\n*/@STRING module that supportd AR mode.  Example:\n*/\n*/       STRING (GENERATE,AR_MODE)\n*/\n*/The NO_CSECT option can be specified to indicate that the\n*/@STRING module should not be generated; only the literals\n*/are generated in this case.  Example:\n*/\n*/       STRING (GENERATE,NO_CSECT)\n*/\n*/The @STRING CSECT contains optional functions (such as %TIME or\n*/julian date conversion) that are only generated if they have\n*/been specified in the previous invocations of the STRING macro.\n*/\n*/To generate of a @STRING CSECT that supports all of the optional\n*/functions, two STRING GENERATE macros must be specified:\n*/\n*/       STRING (GENERATE,NO_CSECT)        Generate Literals\n*/       STRING GENERATE                   Generate CSECT\n*/\n*Examples:\n*/\n*/   STRING 'ERROR===>',LINE1,'<=== POS ',((R6),,L0),INTO=WORKAREA\n*/\n*/   STRING 8X,C'ERRORS FOUND: ',(ERRORS,,L0),INTO=((R7),44)\n*/\n*/   STRING 'CVT ADDR IS ',(CVTPTR,4,X),X'40C1C2C3C4',INTO=LINE\n*/\n*/   LA    R5,WORK+16              end addr +1\n*/   STRING 'R4=',((R4),,X),INTO=(WORK,(R5)),PRINT=GEN\n*/\n*/   STRING '//JOBLIB DD DSN=',(DSN1,,T),',DISP=SHR',INTO=((R2),72)\n*/\n*/   PUT31 SYSLIN\n*/   LH    R0,SYSLIN+82            LRECL\n*/   STRING '   NAME  ',(4(R3),8,T),'(R)',INTO=((R1),(R0))\n*/\n*/   STRING GENERATE         Generate literals and sub-routine\n*/\n*/\n*Programming Notes:\n*/\n*/A STRING macro generates only 6 bytes that need to be covered by\n*/base registers.  More code is generated at the end of the\n*/current CSECT (using LOCTR pseudo instruction), but this code\n*/does not require addressability.  This is particularly useful\n*/when STRING calls specify a large number of literals.\n*/\n*/Additionally, STRING does not use A-type constants (ACON), but\n*/S-type constants (SCON) which require symbols to be addressable\n*/at the point in the program where STRING is issued.\n*/\n*/While this reduces the number of base registers required to\n*/cover the program's code and makes it easier to write reentrant\n*/programs, it will produce assembly errors in the following\n*/situations:\n*/\n*/a.  STRING is used in more than one CSECT in the same assembly\n*/\n*/b.  the CSECT in which STRING is used is longer than 64K\n*/\n*/c.  symbols are not addressable at the point in the program\n*/    where STRING is issued\n*/\n*/d.  the $STRING symbol (generated in the $LTORG LOCTR during the\n*/    GENERATE invocation of the STRING macro) is not addressable\n*/    in some of the STRING calls.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT330/CBT.V500.FILE330.PDS/COBAEXEC.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT330/CBT.V500.FILE330.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}