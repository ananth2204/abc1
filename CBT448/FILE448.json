{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012045000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 117572, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE448.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE448.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x03\\n'", "DS1TRBAL": "b'\\x8bt'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x035\\x00\\n\\x035\\x00\\r\\x00\\x04'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$NOTES": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x18\\x1f\\x01\\x00\\x18\\x1f\\x17\\x19\\x009\\x009\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-06-29T00:00:00", "modifydate": "2000-06-29T17:19:00", "lines": 57, "newlines": 57, "modlines": 0, "user": "WSBG"}, "text": "From:   Sam Knutson <dragon@his.com>\nSent:   Tuesday, June 27, 2000 1:00 PM\nTo:     sbgolob@aol.com; sbgolob@attglobal.net\n\nDate:   Mon, 5 Jun 2000 23:14:14 PDT\nFrom:   'Mark C. Lawrence' <M.Lawrence@FORSYTHE.STANFORD.EDU>\nSubject:        symbolic parameters for date in dsnames\n\n\nREPLY TO 06/05/00 20:59 FROM IBM-MAIN@BAMA.UA.EDU\n'IBM Mainframe Discussion List': IBM-MAIN Digest -\n4 Jun 2000 to 5 Jun 2000 (#2000-157)\n\n'Nasser, David' <David_Nasser@UMSL.EDU> writes,\nI had asked about getting a current date\nautomagically embedded in a DSN in a\nbatch job. Someone asked about a summary.\n\na.) It can be done with a CA-7 module.\nb.) It can be done with CLIST/REXX/Skeleton stuff.\nc.) It can be done with an Assembler routine.\nd.) It can be done with a IEFUJV exit.\n\nI'm not particularly well qualified to elaborate\non a.) - d.), but if anyone needs to pursue this\nI might be able to connect you with someone more\nknowledgable.\n\nI have a variant of (c.) that I implemented on our test LPAR.  A\nsimple assembler program (could be almost any language, actually)\nis run automatically at midnight.  It rewrites a proclib member\nthat contains SET commands to define the desired symbolic date\nparameters.  This member can then be copied in by any batch job,\nand the values used to generate names.\n\n? started task called MIDNIGHT is run at midnight by JES2.  It\n  does several housekeeping things, one is to run proc SYSDATEP.\n? proc SYSDATEP does EXEC PGM=SYSDATE, which has OUTPUT DD\n  pointing to a proclib member called SYSDATE.\n? program SYSDATE gets date, formats it several ways, writes\n  several SET statements, e.g. // SET SYSYEAR 00 into PROCLIB\n  member.\n? batch job does // INCLUDE MEMBER=SYSDATE\n? batch job can then have a DD statement with parameter like\n  DSN=userid.Y&SYSYEAR..D&SYSMONTH&SYSDAY\n\nWe never put it in production, but it's been running on our test\nLPAR for a year without any problems.  One might to change these\nsymbol names to avoid any conflict with IBM system variables.  I\ncan furnish the program to anyone who's interested-email me\ndirectly as I don't read this list every day.\n\nMark C. Lawrence\nSystems Programmer               M.Lawrence@Forsythe.Stanford.edu\nStanford Data Center             (650) 723-4976\nStanford, CA 94305-4136\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE448": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x99\\x08?\\x01\\x00\\x18\\x1f\\x17#\\x00\\r\\x00\\x02\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1999-03-24T00:00:00", "modifydate": "2000-06-29T17:23:00", "lines": 13, "newlines": 2, "modlines": 0, "user": "WSBG"}, "text": "//***FILE 448 is a utility to put the current system date into      *   FILE 448\n//*           system symbolic parameters that can be used in JCL.   *   FILE 448\n//*           This file is from Mark Lawrence of Stanford           *   FILE 448\n//*           University in California.                             *   FILE 448\n//*                                                                 *   FILE 448\n//*           Mark C. Lawrence                                      *   FILE 448\n//*           Systems Programmer                                    *   FILE 448\n//*           Stanford Data Center                                  *   FILE 448\n//*           Stanford, CA 94305-4136                               *   FILE 448\n//*                                                                 *   FILE 448\n//*  email:   M.Lawrence@Forsythe.Stanford.edu                      *   FILE 448\n//*  phone:   (650) 723-4976                                        *   FILE 448\n//*                                                                 *   FILE 448\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DOC": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x17\\x9f\\x01\\x00\\x17\\x9f (\\x00?\\x00?\\x00\\x00\\xd3\\xc1\\xe6\\xd9\\xc5\\xd5\\xc3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-06-27T00:00:00", "modifydate": "2000-06-27T20:28:00", "lines": 63, "newlines": 63, "modlines": 0, "user": "LAWRENC"}, "text": "Notes on the SETDATE program                               2000/06/26\nMark C. Lawrence     email m.lawrence@forsythe.stanford.edu\n\nCopy the SETDATE.ASM dataset, assemble and linkedit in the usual way.\nTypical JCL would be:\n\n//  JOB etc.\n// EXEC ASMSCL\n//ASM.SYSLIB DD DSN=SETDATE.ASM,DISP=SHR\n//ASM.SYSIN DD DSN=SETDATE.ASM(SETDATE),DISP=SHR\n//LKED.SYSLMOD DD DSN=your.linklib(SYSDATE), ...\n\nModify SYSLIB, SYSIN, and SYSLMOD to meet your installation requirements.\n\nDefine a PROCLIB or JCLLIB member name to use for the SET statements (I just\ncalled it SYSDATE).  Make sure this proclib has sufficient free space, since\nyou'll be updating a member nightly.\n\nCreate a proc to run this program, such as:\n\n  //SYSDATEP PROC\n  //*******************************************************************\n  //*                                                                 *\n  //* Run SYSDATE pgm to set system symbolic parameters for date      *\n  //* Invoked by MIDNIGHT started task just after midnight            *\n  //*                                                                 *\n  //*******************************************************************\n  //*\n  //SYS EXEC PGM=SYSDATE\n  //STEPLIB DD DISP=SHR,DSN=your.link.library\n  //OUTPUT DD DSN=your.PROCLIB(SYSDATE),DISP=SHR\n\nCreate a MIDNIGHT job (or modify an existing one) to execute the above proc.\nFor example,\n\n  //MIDNIGHT PROC\n  //*\n  //*  STARTED AT MIDNIGHT BY JES2\n  //*\n  //SETDATE EXEC SYSDATEP\n  //*\n\nYou need some kind of automatic job submission process to do this -- we use\na local JES2 mod but any automation system could be used.  Make sure it runs\nthis job before any that depend on the date symbols.\n\nSo, this program is run just after midnight each night, and it updates the\nproclib/jcllib member.  Jobs that want to use these \"symbols\" must include\nit:\n\n  // INCLUDE MEMBER=SYSDATE\n\nBatch job can then have a DD statement with parameter like\n\n  DSN=userid.Y&SYSYEAR..D&SYSMONTH&SYSDAY\n\n\n\n\nMark C. Lawrence\nSystems Programmer               M.Lawrence@Forsythe.Stanford.edu\nStanford Data Center             (650) 723-4976\nStanford, CA 94305-4136\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DOCMACRO": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x17\\x9f\\x01\\x00\\x17\\x9f (\\x00\\x19\\x00\\x19\\x00\\x00\\xd3\\xc1\\xe6\\xd9\\xc5\\xd5\\xc3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-06-27T00:00:00", "modifydate": "2000-06-27T20:28:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "LAWRENC"}, "text": "Some useful macros --\n\nThe following are the macros used in the SETDATE program; all are generally\nuseful for other programs as well.  I've also included one additional macro,\nEDIT, that is not used by SETDATE.\n\nEDIT     Construct a pattern, convert to decimal, issue ED instruction to\n         format an integer value into a message.\n\nENTER    Save registers, chain save areas, establish addressability for\n         non-reentrant programs.  Provides common addressability across\n         multiple entry points, supports multiple entry points.\n\nEXIT     Restore registers, unchain save areas, set return code, return to\n         caller.\n\nFILL     Pad a message field to a specified length.\n\nREGISTER Equates to define symbolic register names (R1, etc.)\n\n\nMark C. Lawrence\nSystems Programmer               M.Lawrence@Forsythe.Stanford.edu\nStanford Data Center             (650) 723-4976\nStanford, CA 94305-4136\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EDIT": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x17\\x9f\\x01\\x00\\x17\\x9f (\\x00\\x9e\\x00\\x9e\\x00\\x00\\xd3\\xc1\\xe6\\xd9\\xc5\\xd5\\xc3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-06-27T00:00:00", "modifydate": "2000-06-27T20:28:00", "lines": 158, "newlines": 158, "modlines": 0, "user": "LAWRENC"}, "text": "         MACRO\n.*  Last revision 03/06/89\n&N       EDIT  &TO,&FROM,&P,&DECIMAL=0,&ZEROS=1,&COMMAS=NO,&STYLE=USA,&*\n               FILL=40\n         GBLC  &EDWORK             Global work area\n         LCLA  &LEN,&K,&D,&NDS,&KMIN,&NDD,&NDL,&NDT,&NC,&XS\n         LCLA  &NDP,&NPAD\n         LCLB  &W,&CMA,&LC\n         LCLC  &R,&PACK,&P0,&CC,&DC\n.* Initialize codes...North American standards\n&CC      SETC  '6B'                Comma (,)...to group thousands\n&DC      SETC  '4B'                Period (.) ... decimal point\n         AIF   ('&STYLE' EQ 'USA').USA\n&CC      SETC  '4B'                European Style:  nnn.nnn.nnn,n\n&DC      SETC  '6B'                So \"decimal point\" is a comma\n.USA     ANOP\n.* -------------  Load Value  ------------------------------------\n         AIF   ('&FROM'(1,1) EQ '(').REG\n.*  Load value from storage.  Is binary value in 1, 2, 3, or 4-byte\n&R       SETC  '0'                 Use R0 for work reg\n         AIF   (T'&FROM EQ 'U').LF If undefined, assume fullword\n&LEN     SETA  L'&FROM             Length\n         AIF   (&LEN GT  4).BADLEN\n         AIF   (&LEN EQ 4).LF      Fullword\n         AIF   (&LEN EQ 2).LH      Halfword\n&N       SR    &R,&R\n         AIF   (&LEN EQ 3).L3      3 bytes\n.*  One byte...\n         IC    &R,&FROM            Load value\n         AGO   .LOADED\n.L3      ANOP\n         ICM   &R,7,&FROM          Load value\n         AGO   .LOADED\n.LF      ANOP\n&N       L     &R,&FROM            Load value\n         AGO   .LOADED\n.LH      ANOP\n&N       LH    &R,&FROM            Load value\n         AGO   .LOADED\n.REG     ANOP\n&R       SETC  '&FROM(1)'          Value in reg\n         AIF   ('&N' EQ '').LOADED\n&N       EQU   *\n.LOADED  ANOP\n.* -------------------- Work Area ---------------------------------\n&PACK    SETC  '&EDWORK'           Global value if any\n         AIF   ('&PACK' NE '').GSET\n&PACK    SETC  'IHB&SYSNDX'\n         AGO   .WT\n.GSET    ANOP\n&W       SETB  1                   Show we have work area\n.WT      AIF   (T'&P EQ 'O').NOW   If no work area supplied\n&W       SETB  1\n&PACK    SETC  '&P'\n.NOW     ANOP\n.* ------------ Calculate values for pattern -----------------------\n         AIF   ('&COMMAS'(1,1) NE 'Y').NCA\n&CMA     SETB  1                   Flag for commas\n.NCA     ANOP\n&NPAD    SETA  1                   Minimum number of pad chars.\n&K       SETA  L'&TO               Field length\n&NDD     SETA  &DECIMAL\n.*  NDP = 0 if no decimal point, 1 otherwise\n.*  NDD = no. decimal digits\n.*  NDT = total number of digits\n.*  NDL = no. digits left of decimal point\n&NDT     SETA  &K-1                1 for fill (see even/odd below)\n&KMIN    SETA  4                   If no decimal\n         AIF   (&NDD EQ 0).ND1\n&KMIN    SETA  4+&NDD              Min. length\n&NDT     SETA  &NDT-1              1 less digit select\n&NDP     SETA  1                   1 byte for the decimal point\n.ND1     ANOP\n         AIF   (&K LT &KMIN).BAD   Too small\n&NDL     SETA  &NDT-&NDD           No. digits left of decimal\n.*                                 (will be reduced if it ends up odd)\n         AIF   (NOT &CMA).NC1\n&NC      SETA  (&NDL-1)/4          No. commas\n         AIF   (&NDL/4*4 NE &NDL).NOTMOD4\n&NDL     SETA  &NDL-1              length is 0 mod 4, would\n&NPAD    SETA  &NPAD+1                result in leading comma\n.NOTMOD4 ANOP\n&NDL     SETA  &NDL-&NC            Digits remaining\n         AIF   (&NDL-&NDL/3*3 NE 1).N31\n&LC      SETB  1                   digits=1 mod 3\n.N31     ANOP\n.NC1     ANOP\n&NDT     SETA  &NDL+&NDD           recompute total digits\n         AIF   (&NDT LE 15).OK     All right\n.* Field too large, calculate padding\n&NDL     SETA  15-&NDD             left digits\n&NC      SETA  0\n         AIF   (NOT &CMA).CPD\n&NC      SETA  (&NDL+1)/3          No. commas\n.CPD     ANOP\n&NDT     SETA  15\n&NPAD    SETA  &K-(&NDL+&NC+&NDD+&NDP)   pad on left\n&XS      SETA  &NPAD-1\n         AIF   (&XS LE 0).PBLD\n         MNOTE 4,'Field too large, &XS bytes ignored'\n         AGO   .PBLD\n.OK      ANOP\n         AIF   (&NDT/2*2 NE &NDT).ODD  See if even or odd\n&NPAD    SETA  &NPAD+1             Pad with extra blank\n&NDL     SETA  &NDL-1              ...means 1 less digit\n         AIF   (NOT &LC).ODD\n&NPAD    SETA  &NPAD+1             replace leading comma with blank\n&NC      SETA  &NC-1\n.ODD     ANOP\n&NDT     SETA  &NDL+&NDD           recalc. total\n.* ------------- build the pattern -----------------------------\n.PBLD    ANOP\n&P0      SETC  '=X''&FILL'         Pattern start\n         AGO   .P0\n.PLOOP   ANOP\n&P0      SETC  '&P0.&FILL'         Another blank (or whatever)\n.P0      ANOP\n&NPAD    SETA  &NPAD-1\n         AIF   (&NPAD GT 0).PLOOP\n&D       SETA  8-(&NDT+1)/2        Displacement in packed area\n         AIF   (&NDL LE 2).NODS    No digit selects (we'll add 2)\n         AGO   .NOT3               Don't begin with a comma\n.DSLOOP  ANOP\n         AIF   (NOT &CMA).NOT3     No commas...\n         AIF   (&NDL/3*3 NE &NDL).NOT3\n&P0      SETC  '&P0.&CC'            Put in a comma\n.NOT3    ANOP\n&P0      SETC  '&P0.20'            Add a digit select\n&NDL     SETA  &NDL-1              Decrement count\n         AIF   (&NDL GE 3).DSLOOP  Do another\n.NODS    ANOP\n         AIF   ('&ZEROS' EQ 'N').NZ    Don't print zero if N=0\n&P0      SETC  '&P0.2120'          Sig. starter and last dig. sel.\n         AGO   .SSD\n.NZ      ANOP\n&P0      SETC  '&P0.2021'          Last digit sel, sig. start\n.*  In this mode, field (before decimal, if any) will be blank if N=0\n.SSD     ANOP\n         AIF   (&NDD LE 0).NODD    No decimal digits\n&P0      SETC  '&P0.&DC'            Decimal point\n.DDLOOP  ANOP\n&P0      SETC  '&P0.20'            Add a digit select\n&NDD     SETA  &NDD-1              Counter\n         AIF   (&NDD GE 1).DDLOOP  Do another\n.NODD    ANOP\n&P0      SETC  '&P0.'''            Trailing quote\n.* ------------------- machine instructions -----------------------\n         CVD   &R,&PACK\n         MVC   &TO,&P0\n         ED    &TO,&PACK+&D\n         AIF   (&W).OUT\n         B     &PACK+8             Branch around work area\n&PACK    DS    D                   For CVD\n.OUT     MEXIT\n.BAD     MNOTE 8,'   Invalid field Length'\n         MEXIT\n.BADLEN  MNOTE 8,'   &LEN:  Invalid source length'\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ENTER": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x17\\x9f\\x01\\x00\\x17\\x9f (\\x00\\xc1\\x00\\xc1\\x00\\x00\\xd3\\xc1\\xe6\\xd9\\xc5\\xd5\\xc3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-06-27T00:00:00", "modifydate": "2000-06-27T20:28:00", "lines": 193, "newlines": 193, "modlines": 0, "user": "LAWRENC"}, "text": "         MACRO\n&N       ENTER    &BASE=,&SAVE=,&ID=\n.* General purpose entry point macro\n.*  Mark C. Lawrence        ITS -- Stanford University\n.*  Last revision  1996/10/03\n.*  This macro saves registers, establishes base register(s), and\n.*  provides standard save area linkage.\n.*\n.*\n.*  This macro will save all registers according to the standard\n.*  convention, chain save areas together in the standard way, load\n.*  base register(s), issue any necessary USING instructions to the\n.*  Assembler, and name the entry point.  The  entry point name\n.*  will be the symbol naming the ENTER statement, if any, else the\n.*  CSECT name.\n.*\n.*  The following keyword arguments are allowed:\n.*\n.*    BASE     is the  desired  base  register  (expressed  as  a\n.*             decimal number).  It may be a list of numbers enclosed\n.*             in parenthesis.  If omitted, the previously defined\n.*             base register(s) will be used, and if none have been\n.*             specified in a previous ENTER macro in this CSECT,\n.*             then the default will be used.  The default is 12 if a\n.*             save area is specified, else 13.\n.*\n.*    AREA     is the save area to be used.  It may be any type of\n.*             symbol which may appear as the argument of a LA\n.*             instruction.  If omitted, the save area defined in the\n.*             first ENTER macro in this CSECT will be used, or, if\n.*             this is the first invocation of the ENTER macro in\n.*             this CSECT, then a save area will be generated.  If\n.*             SAVE=0 is specified, no save area will be used.\n.*\n.*    ID       is an optional identifier string, which will be\n.*             assembled at the entry point, in addition to the\n.*             default identifier, which is the entry name, date and\n.*             time of assembly.\n.*\n         GBLC  &SNAME,&CSECT\n         GBLA  &B(16),&NBASE\n         LCLB  &SAVEGEN\n         LCLA  &IDL,&NB,&M,&BDISP,&SDISP,&JDISP\n         LCLC  &BP,&STR,&U\n         CNOP  0,4                 ALIGN\n         AIF   ('&SYSECT' EQ '&CSECT').OLD   If not first entry\n.*  Here if first entry this CSECT\n&CSECT   SETC  '&SYSECT'           Remember CSECT name\n.*  Define the default base register.\n&NBASE   SETA  1                   Number of base registers\n         AIF   ('&SAVE' NE '').DB1    If savearea specified\n&B(1)    SETA  13                  Default base\n         AGO   .SET\n.DB1     ANOP\n&B(1)    SETA  12                  Default base\n.SET     ANOP\n&SNAME   SETC  ''                  Save area name--none\n         AIF   ('&N' NE '').ENTRY  If entry name\n         AGO   .BC\n.OLD     AIF   ('&N' EQ '').NN\n.ENTRY   ENTRY &N\n.*  Base registers\n.BC      AIF   (N'&BASE EQ 0).BOK  None specified, use default\n&NBASE   SETA  N'&BASE\n.*  Copy list of base registers.\n.BLOOP   ANOP\n&NB      SETA  &NB+1\n&B(&NB)  SETA  &BASE(&NB)\n         AIF   (&NB LT &NBASE).BLOOP\n.BOK     ANOP\n.*  Save area\n         AIF   ('&SAVE' EQ '').NOSAV    If none specified\n.*  User specified a name; he can't also use R13 as base.\n         AIF   (&B(1) EQ 13).BAD2  Can't use 13 here...\n&SNAME   SETC  '&SAVE'             Save area name\n         AGO   .SAVDONE\n.NOSAV   ANOP\n         AIF   ('&SNAME' NE '').SAVDONE  If name already set\n&SNAME   SETC  'SAV&SYSNDX'        Generate save area name\n&SAVEGEN  SETB  1                  Show save area generated\n.SAVDONE ANOP\n.*  Build an identifying string.\n.*  First, the entry or CSECT name.\n&STR     SETC  '&CSECT'\n&M       SETA  K'&CSECT            Default -- CSECT name\n         AIF   ('&N' EQ '').ID1    If no name on ENTER macro\n&STR     SETC  '&N'                Use name on macro\n&M       SETA  K'&N                and its length\n.ID1     ANOP\n.*  Next, the date and time assembled.\n&STR     SETC  '&STR.-&SYSDATC.-&SYSTIME'\n&M       SETA  &M+K'&SYSDATC+K'&SYSTIME+2\n.*  If user coded ID, add it to the string.\n         AIF   ('&ID' EQ '').NOID\n.*  Strip off quotes if supplied.\n         AIF   ('&ID'(1,1) NE '''').IDOK  If no quotes\n&U       SETC  '&ID'(2,K'&ID-2)    Strip quotes\n&IDL     SETA  K'&ID-2             Length\n         AGO   .IDDONE\n.IDOK    ANOP\n&U       SETC  '&ID'\n&IDL     SETA  K'&ID\n.IDDONE  ANOP\n&STR     SETC  '&STR.:&U'\n&M       SETA  &M+&IDL+1\n.NOID    ANOP\n.*\n.*  M is the length of the identifying string.  Now compute the\n.*  displacements for various machine-instructions.\n.*  &BDISP points to adcon for base address, which will follow ID\n.*  The adcon will be omitted if BASE=13\n&BDISP   SETA  ((&M+8)/4)*4        Length of ID+1 for length byte,\n.*                                   +4 for instruction length,\n.*                                   +3 for round to fullword\n&SDISP   SETA  &BDISP              For save area or its adcon (init.)\n         AIF   (&B(1) EQ 13).B13   If BASE=13, no adcon for base\n&SDISP   SETA  &SDISP+4            Skip base adcon\n.B13     ANOP\n.*  &JDISP will be the displacement in the branch instruction.\n&JDISP   SETA  &SDISP              Tentative\n         AIF   ('&SNAME' EQ '0').SAVSPEC  Skip this stuff if no save\n&JDISP   SETA  &JDISP+4            Allow for save area adcon\n         AIF   (NOT &SAVEGEN).SAVSPEC  If save area not included here\n&JDISP   SETA  &JDISP+68           Allow for save area (less the 4 we\n.*                                 already allowed)\n.SAVSPEC ANOP\n.*\n.*  Start generating instructions.\n.*\n&N       B     &JDISP.(0,15)       Branch around constants\n         DC    AL1(&M)             ID length\n         DC    CL&M'&STR'  ID\n         AIF   (&B(1) EQ 13).B13A  If base 13, no adcon for base\n         DC    A(&SYSECT)          Base address\n&BP      SETC  '&SYSECT'           For using\n         AGO   .SAVTST\n.B13A    ANOP\n&BP      SETC  '&SNAME'            For using\n.SAVTST  AIF   (&SAVEGEN).SAVGEN   If save area to be generated\n         AIF   ('&SNAME' EQ '0').STM   If no save\n         DC    A(&SNAME)           Save area address\n         AGO   .STM\n.SAVGEN  ANOP\n&SNAME   DS    18F                 Save area\n.STM     STM   14,12,12(13)        Save registers\n.*  Chain save areas\n         AIF   (&SAVEGEN).SGB\n         AIF   ('&SNAME' EQ '0').SAVE0    If no save\n.*  Save area not in-line here.\n         L     2,&SDISP.(15)       Save area address\n         AGO   .CHAIN\n.SAVE0   ANOP\n         SR    2,2                 Show no\n         ST    2,8(13)                low savearea\n         AGO   .LOADB\n.SGB     LA    2,&SDISP.(15)       Save area address\n.CHAIN   ST    2,8(13)             Low savearea ptr in caller's area\n         ST    13,4(2)             High savearea ptr in our save area\n         LR    13,2                Save area address\n         SR    2,2                 Zero\n         ST    2,8(13)                our LSA pointer\n.*\n.*  Load base register(s)\n.*\n.LOADB   AIF   (&B(1) EQ 13).R13   Already loaded if 13\n         L     &B(1),&BDISP.(15)   Base address\n.R13     AIF   (&NBASE LT 2).USING If only one base reg\n&NB      SETA  0\n.LOOP    ANOP\n&NB      SETA  &NB+1               Loop counter\n         AIF   (&B(&NB+1) EQ 13).BAD5\n         LA    &B(&NB+1),2048(&B(&NB))\n         LA    &B(&NB+1),2048(&B(&NB+1))\n         AIF   (&NBASE GT &NB+1).LOOP   If more regs to set up\n.*  Generate the USING command.\n.USING   ANOP\n&NB      SETA  1                   Loop counter\n&U       SETC  '&B(1)'             First base reg.\n         AIF   (&NBASE EQ 1).UU    If only one\n.ULOOP   ANOP\n&NB      SETA  &NB+1               Bump counter\n&U       SETC  '&U.,&B(&NB)'       Add next reg to string\n         AIF   (&NB LT &NBASE).ULOOP   Do next one\n.UU      USING &BP,&U\n.DONE    MEXIT\n.*\n.*\n.NN      MNOTE 4,'  WARNING:  No entry point name specified'\n         AGO   .BC\n.BAD2    MNOTE 4,'Can''t specify save area if BASE=13; SAVE ignored'\n         AGO   .NOSAV              Continue...\n.BAD5    MNOTE 8,'  Can''t use R13 as 2nd or subsequent base register'\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EXIT": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x17\\x9f\\x01\\x00\\x17\\x9f (\\x00V\\x00V\\x00\\x00\\xd3\\xc1\\xe6\\xd9\\xc5\\xd5\\xc3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-06-27T00:00:00", "modifydate": "2000-06-27T20:28:00", "lines": 86, "newlines": 86, "modlines": 0, "user": "LAWRENC"}, "text": "         MACRO\n&N       EXIT  &RC=0\n.*  General purpose exit macro\n.*  Mark Lawrence  12 Sept 73\n.*  Last Revision 31 Jan 86\n.*\n.*  This macro will restore regs 2-14, load a return code in R15, and\n.*  return.  The contents of registers 0 and 1 are unchanged.\n.*  Return code:  If \"RC\" is not specified, the return code is zero.\n.*                If RC is an absolute expression, it is used as\n.*                the return code.\n.*                If RC=(reg) is specified, the return code will be\n.*                loaded from the specified register (whch must not\n.*                be register 13).\n.*                If RC=(15) or RC=(R15) is specified, the contents\n.*                of register 15 will not be changed.\n.*                If \"RC\" is a fullword, halfword, or byte-length\n.*                symbol, RC will be loaded from the specified\n.*                location.\n.*\n.*  Save area:  The save area name established by the last ENTER\n.*  macro will be used.  If SAVE=0 was specified, then no save\n.*  area exists; in this case, registers 2-12 are restored but\n.*  the contents of R13 are unchanged.\n.*\n         GBLC  &SNAME              Save area name, or \"0\"\n         LCLA  &RNO\n         AIF   ('&RC'(1,1) NE '(').NRCR\n.*\n.*  Here if RC=(reg)\n.*\n         AIF   (T'&RC(1) EQ 'N').NRR    If numeric, check value\n         AIF   ('&RC(1)' EQ 'R15').R15  Assuming \"R15\"=15\n.*  Don't know what kind of operand.  Just use it and hope\n&N       LR    15,&RC(1)           Return code\n         AGO   .LOADED\n.*  Register operand is numeric.  Check the value\n.NRR     ANOP\n&RNO     SETA  &RC(1)              Copy reg. no\n         AIF   (&RNO EQ 13 OR &RNO GT 15).BAD1  If illegal reg\n         AIF   (&RNO EQ 15).R15    RC is already in R15\n&N       LR    15,&RNO             Return code\n         AGO   .LOADED\n.R15     AIF   ('&SNAME' EQ '0').NOSAV1   If no save area\n&N       L     13,4(13)            Restore R13 from our save area\n         AGO   .LR15\n.NOSAV1  ANOP\n&N       L     14,12(13)           Restore R14\n         AGO   .LM\n.*\n.*  Here if RC=value  or RC=symbol\n.*\n.NRCR    AIF   (T'&RC EQ 'N').ABSEXP\n.*  RC is in core.  Load it\n.CORE    AIF   (L'&RC EQ 4).FW\n         AIF   (L'&RC EQ 2).HW\n         AIF   (L'&RC EQ 1).BYTE\n         AGO   .BAD2               Other length illegal\n.FW      ANOP\n&N       L     15,&RC              Return code\n         AGO   .LOADED\n.HW      ANOP\n&N       LH    15,&RC              Return code\n         AGO   .LOADED\n.BYTE    ANOP\n&N       SR    15,15\n         IC    15,&RC              Return code\n         AGO   .LOADED\n.*  Here if RC=absexp\n.ABSEXP  ANOP\n         AIF   (&RC EQ 0).ZERO\n&N       LA    15,&RC              Return code\n         AGO   .LOADED\n.ZERO    ANOP\n&N       SR    15,15               Return code\n.LOADED  AIF   ('&SNAME' EQ '0').LR15    If no save area\n         L     13,4(13)            Restore R13 from our save area\n.LR15    L     14,12(13)           Restore R14\n.LM      LM    2,12,28(13)         Restore R2-R12\n         MVI   12(13),X'FF'        Indicate return\n         BR    14                  Return\n         MEXIT\n.BAD1    MNOTE 8,'  &RC.:  Invalid return code register'\n         MEXIT\n.BAD2    MNOTE 8,'  &RC.:  Invalid length or type'\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FILL": {"ttr": 772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x17\\x9f\\x01\\x00\\x17\\x9f (\\x00\\x0c\\x00\\x0c\\x00\\x00\\xd3\\xc1\\xe6\\xd9\\xc5\\xd5\\xc3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-06-27T00:00:00", "modifydate": "2000-06-27T20:28:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "LAWRENC"}, "text": "         MACRO\n&A       FILL  &X,&LEN\n         LCLC  &LFILL\n         LCLC  &FL\n&LFILL   SETC  '133'\n         AIF   ('&LEN' EQ '').NOL\n&LFILL   SETC  '&LEN'\n.NOL     ANOP\n&FL      SETC  'IHB&SYSNDX'\n&FL      EQU   (&LFILL-*+&X)\n&A       DC    CL(&FL)' '         PAD WITH BLANKS\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REGISTER": {"ttr": 774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x17\\x9f\\x01\\x00\\x17\\x9f (\\x00\\x1a\\x00\\x1a\\x00\\x00\\xd3\\xc1\\xe6\\xd9\\xc5\\xd5\\xc3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-06-27T00:00:00", "modifydate": "2000-06-27T20:28:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "LAWRENC"}, "text": "         MACRO\n         REGISTER\n         GBLB  &REGEQU\n         AIF   (&REGEQU).OUT\n&REGEQU  SETB  1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nF0       EQU   0\nF2       EQU   2\nF4       EQU   4\nF6       EQU   6\n.OUT     MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SETDATE": {"ttr": 776, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x17\\x9f\\x01\\x00\\x17\\x9f (\\x00K\\x00K\\x00\\x00\\xd3\\xc1\\xe6\\xd9\\xc5\\xd5\\xc3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-06-27T00:00:00", "modifydate": "2000-06-27T20:28:00", "lines": 75, "newlines": 75, "modlines": 0, "user": "LAWRENC"}, "text": "SETDATE  CSECT\n         REGISTER\n         ENTER BASE=12,SAVE=SAVEAREA\n         EJECT\n*********************************************************************\n*                                                                   *\n*  Create SET JCL statements that define month, day, year.          *\n*  These statements would normally be written into a proclib member *\n*  each day just after midnight.                                    *\n*                                                                   *\n*  OUTPUT DD statement should point to a proclib or jcllib member.  *\n*                                                                   *\n*  Mark C. Lawrence 1999/07/22                                      *\n*                                                                   *\n*********************************************************************\n\n         OPEN (OUTDCB,(OUTPUT))\n         TIME  DEC,DATE1,ZONE=LT,DATETYPE=YYYYMMDD,LINKAGE=SYSTEM\n*        TIME  DEC,DATE2,ZONE=LT,DATETYPE=YYYYDDD,LINKAGE=SYSTEM\n\n*  Convert to zoned\n\n         MVI   SN1,X'0F'           valid digit and sign\n         UNPK  DATEWORK,YMDP       get YYYYMMDD0\n         MVC   SDT,DATEWORK        YYYYMMDD\n         MVC   SYR,DATEWORK        YYYY\n         MVC   SMO,DATEWORK+4      MM\n         MVC   SDA,DATEWORK+6      DD\n         PUT   OUTDCB,REC1\n         PUT   OUTDCB,REC2\n         PUT   OUTDCB,REC3\n         PUT   OUTDCB,REC4\n         PUT   OUTDCB,REC5\n         CLOSE OUTDCB\n         EXIT\n         TITLE 'DATA AREA'\n         DC    0D'0'\nSAVEAREA DC    18F'0'\nDATE1    DC    2D'0'\nYMDP     EQU   DATE1+8,5           YYYYMMDD unsigned plus SN1\nSN1      EQU   DATE1+12,1          to append sign\n\nDATEWORK DC    CL9' '\n\nREC1     DC    CL80'//*  System date parameters, set by SETDATE'\n\n*********************************************************************\n*                                                                   *\n*  The following four records define \"year\", \"month\", \"day\", and    *\n*  \"date\" variables.  Assign whatever names to these fit your       *\n*  installation requirements -- you may wish to avoid \"SYS\" names   *\n*  so you don't conflict with MVS symbols.                          *\n*                                                                   *\n*********************************************************************\n\nREC2     DC    C'//  SET  SYSYEAR='\nSYR      DC    C'0000'\n         FILL  REC2,80\n\nREC3     DC    C'//  SET  SYSMONTH='\nSMO      DC    C'00'\n         FILL  REC3,80\n\nREC4     DC    C'//  SET  SYSDAY='\nSDA      DC    C'00'\n         FILL  REC4,80\n\nREC5     DC    C'//  SET  SYSDATE='\nSDT      DC    C'00000000'\n         FILL  REC5,80\n\n         PRINT NOGEN\nOUTDCB   DCB   DDNAME=OUTPUT,DSORG=PS,MACRF=PM,RECFM=FB,LRECL=80\n         PRINT GEN\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT448/FILE448.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT448", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}