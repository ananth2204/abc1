{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012818000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 235144, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE796.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 235144, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 235144, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE796.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x04\\x0e'", "DS1TRBAL": "b'\\x05\\xd8'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x05b\\x00\\x06\\x05b\\x00\\n\\x00\\x05'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04M\\x00\\x00\\x01\\x085?\\x01\\x085?\\x13S\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf7@@@'", "ispf": {"version": "04.77", "flags": 0, "createdate": "2008-12-18T00:00:00", "modifydate": "2008-12-18T13:53:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-477"}, "text": "REGULAR CBT TAPE - VERSION 477    FILE:  796\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT477.FILE796\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 9 MEMBERS COUNTED; CUMULATIVE SIZE IS 1,694 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   12/18/08    13:53:08    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$COPYWR": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x001\\x01\\x081O\\x01\\x081O\\x14\\x05\\x00\\t\\x00\\x04\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2008-11-09T00:00:00", "modifydate": "2008-11-09T14:05:31", "lines": 9, "newlines": 4, "modlines": 0, "user": "IBMUSER"}, "text": "Anything here is as is, no warantee no guarantee no nothing.\nNeither the author nor CBT nor anyone connected with this assume\nany responsibility for this code.\n\nNever run any freeware on your system without checking to see what it\ndoes first.\n\nAside from that, do whatever you want with it.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$NOTE1": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00F\\x01\\x085?\\x01\\x085?\\t\\x18\\x00\\x15\\x00\\x15\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-12-18T00:00:00", "modifydate": "2008-12-18T09:18:46", "lines": 21, "newlines": 21, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:    Addition to CBT: File 796\nFrom:       Lindy Mayfield <lindy.mayfield@ssf.sas.com>\nDate:       Sun, 9 Nov 2008 17:45:17 +0100\nTo:         Sam Golob <sbgolob@cbttape.org>\n\nHere is the xmit file package.\n\nIt s a start, but I think I have a number of utilities that I can\nadd to it as time goes by.\n\nSo far there are two utilities:\n\n1) A Rexx/ISPF exec that shows control blocks and information\n   regarding 522 timeouts.\n\n2) A Rexx assembler function to write SMF records.  Uses BPX1SMF.\n\nAll the best to you and your family as well.\n\nLindy\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$CONTNTS": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00'\\x01\\x081O\\x01\\x081O\\x14\\x08\\x00\\x06\\x00\\x07\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "2008-11-09T00:00:00", "modifydate": "2008-11-09T14:08:27", "lines": 6, "newlines": 7, "modlines": 0, "user": "IBMUSER"}, "text": "$$COPYWR  - Copywrite and disclamer\n$CONTNTS  - This member\nD522      - Rexx utility that displays control blocks related to 522s\nRXSMFASM  - Rexx assembler function to write SMS records\nRXSMFEX   - Rexx example that calls REXXSMF\nRXSMFTST  - JCL to run a test of REXXSMF\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE796": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04M\\x00\\x00\\x01\\x085?\\x01\\x085?\\x13R\\x00\\r\\x00\\r\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf7@@@'", "ispf": {"version": "04.77", "flags": 0, "createdate": "2008-12-18T00:00:00", "modifydate": "2008-12-18T13:52:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "CBT-477"}, "text": "//***FILE 796 is from Lindy Mayfield, and contains a collection     *   FILE 796\n//*           of his utilities.                                     *   FILE 796\n//*                                                                 *   FILE 796\n//*           email:  lindy.mayfield@ssf.sas.com                    *   FILE 796\n//*                                                                 *   FILE 796\n//*    So far there are two utilities:                              *   FILE 796\n//*                                                                 *   FILE 796\n//*    1) A Rexx/ISPF exec that shows control blocks and            *   FILE 796\n//*       information regarding 522 timeouts.                       *   FILE 796\n//*                                                                 *   FILE 796\n//*    2) A Rexx assembler function to write SMF records.           *   FILE 796\n//*       Uses BPX1SMF.                                             *   FILE 796\n//*                                                                 *   FILE 796\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "D522": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00%\\x01\\x081O\\x01\\x085?\\x19@\\x04\\xa5\\x04\\xf4\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2008-11-09T00:00:00", "modifydate": "2008-12-18T19:40:25", "lines": 1189, "newlines": 1268, "modlines": 0, "user": "IBMUSER"}, "text": "/*  Rexx */\n\n/*  This exec allocates all ISPF libraries internally. To run it you\n    need only execute this exec.  Either TSO EX 'this.pds.(D522)' or\n    in the normal way if it is in SYSPROC.\n*/\n\n\n/*  Version 3.03\n\n    This exec shows information pertaining to the ASCBSWTL field in the\n    ASCB and related control blocks.\n\n    Written by Lindy Mayfield, SAS, Feb 2005\n    based on Rexx report from John H.\n\n    This exec has been hobbled together for over 3 years starting from\n    a simple batch report written in Rexx.  That's the excuse why the\n    code is a bit messy (to say the least).\n\n    Change History:\n    21-Feb-05  Added Seconds Idle field to detail.\n    25-Feb-05  Added Accounting Information Field.\n    12-Mar-06  Added CPU Time Used Field.\n    19-Mar-06  Changed ASCB display to pad left with 0.\n    20-Oct-06  Added ASCBINTS (Job start timestamp) and total seconds.\n    22-Oct-06  Added help screen.\n    23-Oct-06  Corrected CVTTZ Routine (thanks to Peter. G, Austraila)\n    25-Oct-06  Corrected CVTTZ Routine again... (-:\n    14-Nov-06  Added filter for jobtype from code changes by Peter.G.\n    27-May-07  Removed filter (our job id names changed)\n    28-Jun-07  Mistake. JSTL=86400 should have been JSTLS=86400.\n    -- Version 2.00 --\n    29-Jun-07  Renamed to CBEXPLR. Took call to BLSUXTOD out for every\n               job in system because it was making things slow.\n               Moved some logic and fields around.  Added some extra\n               fields.\n               The goal of this version is to turn it into a control\n               block explorer.  I'm not sure if I can do this or not\n               because I don't know yet what control blocks for other\n               address spaces I can see or not.\n               In any case, I am updating the 522 display and info.\n    -- Version 3.00 --\n    15-Aug-08  Added the LDA control block which uses RXGETCB assembler\n               program.  Selection now is S or ASCB for ASCB/522 info\n               and LDA for LDA control block.\n    -- Version 3.01 --\n    15-Aug-08  Fixed some problems with screen refresh on LDA screen.\n               Added a check for garbage in user name.  Now puts N/A\n               if it contains garbage.  Fixed JUSERID bug.\n    -- Version 3.02 --\n    17-Aug-08  More code cleanup.  All gets from storage use the\n               Get_Stor() procedure. (Thanks to whoever wrote it.)\n    23-Aug-08  Minor bug fix with acct info.  Put in option to igore\n               LDA display.\n    05 Nov-08  Cleaned up for CBT tape.  Removed the LDA because it\n               requires a called module that runs authorized.\n\n*/\n\nTrace Off\n\nSignal on NOVALUE\n\nParse source . . exec_mem . exec_dsn . . envname .\n\n\nIf envname <> 'ISPF'\n  Then Do\n    Say 'Error:  This exec only runs under ISPF.'\n    Exit 99\nEnd\n\nnumeric digits 256\n\nAddress ISPEXEC\n\n\"Control Errors Return\"\n\nx = MSG(\"OFF\")\n\n/* Initialize variables and constants */\n\nASCBJOBN = \"\"\nASCBJOBI = \"\"\nSEL      = \"\"\n\nIf InitISPF() /= 'OK'\n  Then Signal EndExec\n\n\n\nDo forever\n\n  If FillTable() /= 'OK' Then Leave\n\n  \"TBSORT ASCBLIST FIELDS(JOBNAME)\"\n  \"TBTOP ASCBLIST\"\n\n  \"TBDISPL ASCBLIST PANEL(ASCBLST)\"\n\n  If RC > 4 Then Leave\n\n  \"TBEND ASCBLIST\"\n\n  CMD = Word(ZCMD,1)\n\n  Select\n    When SEL <> \"\"\n      Then Call ShowASCBDetail\n    Otherwise Nop\n  End\n\n  SEL = \"\"\n\nEnd\n\n\nEndExec:\n\n\n\"LIBDEF ISPPLIB\"\n\"LIBDEF ISPSLIB\"\n\"LIBDEF ISPMLIB\"\n\nAddress TSO \"FREE DD(UTLPNLS UTLSKEL UTLMSGS)\"\n\n\"TBEND ASCBLIST\"\n\nExit 0\n\n\n\nFillTable:\n\n\n\"TBCREATE ASCBLIST NAMES(JOBNAME ASCBX ASCB JOBID ASID ASIDX SWTL\",\n\"         JSTL EWST EWSTTIM RCTF JUSERID) NOWRITE\"\n\nIf RC > 0\n  Then do\n    ZEDSMSG = 'TBCREATE Failed'\n    ZEDLMSG = 'Table Create for ASCBLIST Failed, RC=' RC\n    \"SETMSG MSG(ISRZ001)\"\n    Return \"ERROR\"\nEnd\n\nZONE  = getZONE()\nDATE  = DATE('U')\nTIME  = TIME()\n\nCVT  = Get_Stor('10'x)      /* psa+15 -> cvt   */\nASCB = Get_Stor(CVT,'234'x) /* CVT+564 -> ASCB */\nASCBX = right(c2x(ASCB),8,'0')\n\nASCBSUB  = 0\nASCBSTC  = 0\nASCBTSU  = 0\nASCBJOB  = 0\n\ndo while C2D(ASCB) /= 0\n call getASCBInfo\n if substr(JOBNAME,1,Length(ASCBJOBN)) = ASCBJOBN\n   Then\n     \"TBADD ASCBLIST\"\n ASCB = Get_Stor(ASCB,4)              /* ascb+4   -> next ascb */\n ASCBX = right(c2x(ASCB),8,'0')\nend\n\n\nReturn \"OK\"\n\n\n\ngetZONE: Procedure\n\nCVT = Get_Stor('10'x)\nCVTEXT2 = Get_Stor(CVT,'148'x)\nCVTLDTO = C2D(Get_Stor(CVTEXT2,'38'x,8),8)\n\nABSLDTO = Abs(CVTLDTO)\nhours   = absldto % x2d('D693A400000')\nminutes = (absldto % x2d('3938700000')) // 60\nzone    = Right(hours,2,\"0\" )\".\"Right(minutes,2,\"0\" )\nIf cvtldto < 0 Then Do\n   zone = \"-\"zone\nEnd\nElse Do\n   zone = \"+\"zone\nEnd\n\nReturn zone\n\n\ngetASCBInfo:\n\nDATE=DATE('U')\nTIME=TIME('L')\n\nJBNI = Get_Stor(ASCB,'AC'x)           /* ascb+ac -> jbni */\nJBNS = Get_Stor(ASCB,'B0'x)           /* ascb+b0 -> jbns */\n\nIf C2D(JBNI) /= 0\n  then\n    JOBNAME = Get_Stor(JBNI,0,8)\n  else\n    JOBNAME = Get_Stor(JBNS,0,8)\n\nASID  = Get_Stor(ASCB,'24'x,2)        /* ascb+24 -> asid */\nASID  = c2x(ASID)\nASIDX = Right(ASID,3,'0')\n\nASID  = ASIDX||'(x) '||x2d(ASID)||'(d)'\nSWTL  = c2x(Get_Stor(ASCB,'C4'x))     /* ascb+C4 -> swtl */\nJSTL  = c2x(Get_Stor(ASCB,'50'x))     /* ascb+50 -> jstl */\nINTS  = c2x(Get_Stor(ASCB,'130'x,8))  /* ascb+130 -> ints */\nINTSD = c2d(Get_Stor(ASCB,'130'x,4))  /* ascb+130 -> ints */\nEWST  = c2x(Get_Stor(ASCB,'48'x,8))   /* ascb+48 -> ewst */\nEWSTD = c2d(Get_Stor(ASCB,'48'x))     /* ascb+48 -> ewst */\nRCTF  = c2x(Get_Stor(ASCB,'66'x,1))   /* ascb+66 -> rctf */\nASSB  = Get_Stor(ASCB,'150'x)         /* ascb+150 -> assb  */\nJSAB  = Get_Stor(ASSB,'A8'x)          /* assb+A8  -> jsab  */\nJOBID = \"SUB=MSTR\"\n\nif C2D(JSAB) /= 0\n  then Do\n    JOBID = Get_Stor(JSAB,20,8)     /* jsab+14  -> jobid */\n    JUSERID = Get_Stor(JSAB,44,8)     /* jsab+2c  -> jsabusid */\nend\n  else JUSERID = 'N/A'\n\n\nRCTFB    = X2B(RCTF)\n\nMYASCB   = Get_Stor('224'x)               /* PSA+224 -> psaaold */\nCUREWST  = c2x(Get_Stor(MYASCB,'48'x,8))  /* ascb+48 -> ewst */\nCUREWSTD = c2d(Get_Stor(MYASCB,'48'x,4))  /* ascb+48 -> ewst */\n\nSWTLS = X2D(SWTL) * 1.048576\nSWTLS = Trunc(SWTLS)\n\nJSTLS = X2D(JSTL) * 1.048576\nJSTLS = Trunc(JSTLS)\n\nReturn\n\n\nShowASCBDetail:\n\nCall getASCBInfo\nCall getASCBDetInfo\n\n\"Addpop\"\n\ndo forever\n  \"Display Panel(ASCBDETP)\"\n  if RC > 4 then Leave\n  call getASCBInfo\n  call getASCBDetInfo\nend\n\nSEL = \"\"\n\n\"Rempop\"\n\nReturn\n\ngetASCBDetInfo:\n\nEWSTTIM  = Copies(0,26)  /* force result length=26 */\nTOD_val = X2c(EWST)\nAddress linkpgm \"BLSUXTOD TOD_val EWSTTIM\"\n\nINTSTIM  = Copies(0,26)  /* force result length=26 */\nTOD_val = X2c(INTS)\nAddress linkpgm \"BLSUXTOD TOD_val INTSTIM\"\n\nCUREWSTT = Copies(0,26)  /* force result length=26 */\nTOD_val = X2c(CUREWST)\nAddress linkpgm \"BLSUXTOD TOD_val CUREWSTT\"\n\nIf SWTL = \"0D286880\" | Substr(RCTFB,8,1) = \"1\" | JSTLS = \"86400\"\n  Then CTD522 = \"N/A\"\nElse Do\n  CTD522  = CUREWSTD - EWSTD\n  CTD522  = CTD522 * 1.048576\n  CTD522  = SWTLS - Trunc(CTD522)\nEnd\n\nTOTTIMES = CUREWSTD - INTSD\nTOTTIMES = TOTTIMES * 1.048576\nTOTTIMES = Trunc(TOTTIMES)\n\n/* Convert secs into hhhh:mm:ss  */\n\n\nTIMETMP = TOTTIMES\nHHHH = TIMETMP % (60*60)\nTIMETMP = TIMETMP - (HHHH * 60 * 60)\nMM = TIMETMP % 60\nTIMETMP = TIMETMP - (MM * 60)\nSS = TIMETMP\n\n\nHHHH = RIGHT(HHHH,4,'0')\nMM   = RIGHT(MM,2,'0')\nSS   = RIGHT(SS,2,'0')\n\nTOTTIME = HHHH\":\"MM\":\"SS\n\n\nCTDIDLE = CUREWSTD - EWSTD\nCTDIDLE = CTDIDLE * 1.048576\nCTDIDLE = Trunc(CTDIDLE)\n\n/* Get Accounting Info */\n\nOUCB   = Get_Stor(ASCB,'90'x)                 /* ASCB+90 -> oucb  */\nACNT   = c2x(Get_Stor(OUCB,'1C'x,1))          /* oucb+1c -> acnt */\nACNT   = x2b(ACNT)\nif substr(ACNT,8,1) /= '1'\n  then do\n    ACCTINFO = 'N/A'\nEnd\nElse do\n  ACTL   = c2d(Get_Stor(OUCB,'67'x,1))           /* oucb+67 -> actl */\n  ACTP   = Get_Stor(OUCB,'E8'x)                  /* oucb+e8 -> acnp */\n  ACCTINFO = Get_Stor(ACTP,,ACTL)\n  ACCTINFO = substr(ACCTINFO,2,ACTL-1)\nEnd\n\n/* Get CPU Time from ASCBEJST+ASCBSRBT+ASSBASST */\n\nEJST  = Get_Stor(ASCB,'40'x,8)     /* ascb+40  -> ejst */\nSRBT  = Get_Stor(ASCB,'C8'x,8)     /* ascb+c8  -> srbt */\nASST  = Get_Stor(ASSB,'160'x,8)    /* assb+160 -> srbt */\n\nWRK = x2d('0'left(c2x(EJST),13))\nCPUTIME = FORMAT(WRK/1000000, 6, 3)\n\nWRK = x2d('0'left(c2x(SRBT),13))\nCPUTIME = CPUTIME + FORMAT(WRK/1000000, 6, 3)\n\n\nReturn\n\n\n\n\nGet_Stor: PROCEDURE\n\n/*------------------------------------------------------------------*/\n/*                                                                  */\n/*      This procedure will extract data using the MVS Storage      */\n/*      function. Input arguments will be:                          */\n/*                                                                  */\n/*      1) Storage_Pointer or Literal, i.e. CVTPTR or '10'x, or     */\n/*         16 (like '10'x)                                          */\n/*      2) Offset in hex or dec (numnbe), i.e. 'FF'x or 256 or      */\n/*         D2C(256)                                                 */\n/*      3) Length of returned data in decimal, i.e. 256             */\n/*                                                                  */\n/*      NOTE - To make sure that this procedure will work all the   */\n/*      times, just include 'NUMERIC DIGITS 256' at the beginning   */\n/*      of the calling REXX exec.                                   */\n/*                                                                  */\n/*------------------------------------------------------------------*/\n\nParse Arg AREA,OFFSET,LENG\n\nIf Arg(2,'O') Then OFFSET=0\n\nIf Arg(3,'O') Then LENG=4\n\nIf DataType(AREA) = 'CHAR' Then Do\n   AREA =  C2D(AREA)\n   End\n\nIf DataType(OFFSET) = 'CHAR' Then Do\n   OFFSET =  C2D(OFFSET)\n   End\n\nReturn  Storage((D2X(AREA+OFFSET)),LENG)\n\n\n\nCommify : procedure expose (globals)\n  s = ARG(1) ;\n  s = s+0\n  l = LENGTH(s) - 3\n  do i = l by -3 while i > 0 ;\n    if substr(s,i,1) = '-' then leave\n    if substr(s,i+1,1) <> '.' then\n      s = INSERT(\",\", s, i) ;\n  end\n  return s\n\n\n/*------------------------------------------------------------------*/\n/*------------------------------------------------------------------*/\n/*           ISPF Stuff Below This Line                             */\n/*------------------------------------------------------------------*/\n/*------------------------------------------------------------------*/\n\n\nInitISPF:\n\nIf AllocISPF() /= \"OK\" Then Return \"ERROR\"\n\nIf ScanSrce() /= \"OK\"\n  Then do\n    If write == 'Y'\n      Then do\n        Select\n          When currtag == 'panel'\n            Then ClosePnl()\n          When currtag == 'message'\n            Then CloseMsg()\n          When currtag == 'skeleton'\n            Then CloseSkel()\n          Otherwise Nop\n        End\n    End\n    Return \"ERROR\"\nEnd\n\n\n\n\"LIBDEF ISPPLIB LIBRARY ID(UTLPNLS)\"\n\nIf RC > 0\n  Then do\n    ZEDSMSG = 'LIBDEF Failed'\n    ZEDLMSG = 'LIBDEF for UTLPNLS Failed, RC=' RC\n    \"SETMSG MSG(ISRZ001)\"\n    Return \"ERROR\"\nEnd\n\n\"LIBDEF ISPSLIB LIBRARY ID(UTLSKEL)\"\n\nIf RC > 0\n  Then do\n    ZEDSMSG = 'LIBDEF Failed'\n    ZEDLMSG = 'LIBDEF for UTLSKEL Failed, RC=' RC\n    \"SETMSG MSG(ISRZ001)\"\n    Return \"ERROR\"\nEnd\n\n\"LIBDEF ISPMLIB LIBRARY ID(UTLMSGS)\"\n\nIf RC > 0\n  Then do\n    ZEDSMSG = 'LIBDEF Failed'\n    ZEDLMSG = 'LIBDEF for UTLMSGS Failed, RC=' RC\n    \"SETMSG MSG(ISRZ001)\"\n    Return \"ERROR\"\nEnd\n\n\n\nReturn 'OK'\n\n\n\n\n\nAllocISPF:\n\nAddress TSO \"Alloc DD(UTLPNLS) NEW CATALOG UNIT(VIO) SPACE(2 2)\",\n            \"TRACKS DIR(5) RECFM(F B) LRECL(80) BLKSIZE(0)\"\n\nIf RC > 0\n  Then do\n    ZEDSMSG = 'Allocate Failed'\n    ZEDLMSG = 'TSO Allocate for UTLPNLS failed, RC=' RC\n    \"SETMSG MSG(ISRZ001)\"\n    Return \"ERROR\"\nEnd\n\nAddress TSO \"Alloc DD(UTLSKEL) NEW CATALOG UNIT(VIO) SPACE(2 2)\",\n            \"TRACKS DIR(5) RECFM(F B) LRECL(80) BLKSIZE(0)\"\n\nIf RC > 0\n  Then do\n    ZEDSMSG = 'Allocate Failed'\n    ZEDLMSG = 'TSO Allocate for UTLSKEL failed, RC=' RC\n    \"SETMSG MSG(ISRZ001)\"\n    Return \"ERROR\"\nEnd\n\nAddress TSO \"Alloc DD(UTLMSGS) NEW CATALOG UNIT(VIO) SPACE(2 2)\",\n            \"TRACKS DIR(5) RECFM(F B) LRECL(80) BLKSIZE(0)\"\n\nIf RC > 0\n  Then do\n    ZEDSMSG = 'Allocate Failed'\n    ZEDLMSG = 'TSO Allocate for UTLMSGS failed, RC=' RC\n    \"SETMSG MSG(ISRZ001)\"\n    Return \"ERROR\"\nEnd\n\n\n\nReturn \"OK\"\n\n\n\n\n\nScanSrce:\n\nWrite = \"N\"\n\npnlbegtag = \"<\"||\"panel\"      /* This kluge is to prevent the scan */\npnlendtag = \"<\"||\"/panel>\"    /* finding the tags in the wrong place.*/\n\nskelbegtag = \"<\"||\"skeleton\"\nskelendtag = \"<\"||\"/skeleton\"\n\nmsgbegtag = \"<\"||\"message\"\nmsgendtag = \"<\"||\"/message\"\n\ncurrtag = \"\"               /* Will be set to panel, skeleton, message */\n\n\nDo ix = 1 to sourceline()\n\n  If pos(pnlendtag, sourceline(ix)) > 0\n     Then Do\n       If ClosePnl() /= 'OK' Then Return 'ERROR'\n       write = 'N'\n       currtag = \"\"\n  End\n\n  If pos(skelendtag, sourceline(ix)) > 0\n     Then Do\n       If CloseSkel() /= 'OK' Then Return 'ERROR'\n       write = 'N'\n       currtag = \"\"\n  End\n\n  If pos(msgendtag, sourceline(ix)) > 0\n     Then Do\n       If CloseMsg() /= 'OK' Then Return 'ERROR'\n       write = 'N'\n       currtag = \"\"\n  End\n\n  If write = \"Y\"\n    Then do\n      Select\n        When currtag == \"panel\"\n          Then do\n            If WritePnl() /= 'OK' Then Return 'ERROR'\n        End\n        When currtag == \"skeleton\"\n          Then do\n            If WriteSkel() /= 'OK' Then Return 'ERROR'\n        End\n        When currtag == \"message\"\n          Then do\n            If WriteMsg() /= 'OK' Then Return 'ERROR'\n        End\n        Otherwise NOP /* Yeah, should handle this error... */\n      End\n  End\n\n  If pos(pnlbegtag, sourceline(ix)) > 0\n     Then do\n       If OpenPnl() /= 'OK' Then Return 'ERROR'\n       write = \"Y\"\n       currtag = \"panel\"\n  End\n\n  If pos(skelbegtag, sourceline(ix)) > 0\n     Then do\n       If OpenSkel() /= 'OK' Then Return 'ERROR'\n       write = \"Y\"\n       currtag = \"skeleton\"\n  End\n\n  If pos(msgbegtag, sourceline(ix)) > 0\n     Then do\n       If OpenMsg() /= 'OK' Then Return 'ERROR'\n       write = \"Y\"\n       currtag = \"message\"\n  End\n\nEnd\n\n\nReturn \"OK\"\n\n\n\n\n/* Process Panels  */\n\nOpenPnl:\n\n/* Make sure nothing already open */\n\nIf write == 'Y'\n  Then do\n    ZEDSMSG = 'XML Parse Error'\n    ZEDLMSG = 'New tag found before end tag. Line number ' ix\n    \"SETMSG MSG(ISRZ001)\"\n    Return \"ERROR\"\nEnd\n\n\n\n\"LMINIT Dataid(PANELID) DDNAME(UTLPNLS)\"\n\nIf RC > 0\n  Then do\n    ZEDSMSG = 'LMINIT Failed'\n    ZEDLMSG = 'LMINIT for UTLPNLS Failed, RC=' RC\n    \"SETMSG MSG(ISRZ001)\"\n    Return \"ERROR\"\nEnd\n\n\n\"LMOPEN Dataid(\"PANELID\") OPTION(OUTPUT)\"\n\nIf RC > 0\n  Then do\n    ZEDSMSG = 'LMOPEN Failed'\n    ZEDLMSG = 'LMOPEN for UTLPNLS Failed, RC=' RC\n    \"SETMSG MSG(ISRZ001)\"\n    Return \"ERROR\"\nEnd\n\nParse value sourceline(ix) with \"<\" xmlline \">\"\n\nParse value xmlline with \"panel \" attr \">\"\n\nInterpret attr\n\nIf RC > 0\n  Then do\n    ZEDSMSG = 'XML Attr Error'\n    ZEDLMSG = 'Error interpreting XML Attribute at line' ix\n    \"SETMSG MSG(ISRZ001)\"\n    Return \"ERROR\"\nEnd\n\nReturn 'OK'\n\n\n\nWritePnl:\n\nIf write == 'N'\n  Then do\n    ZEDSMSG = 'XML Parse Error'\n    ZEDLMSG = 'Attempting to write with no open file at line' ix\n    \"SETMSG MSG(ISRZ001)\"\n    Return \"ERROR\"\nEnd\n\nSrcline = sourceline(ix)\n\n\"LMPUT DATAID(\"PANELID\") MODE(INVAR) DATALOC(SRCLINE) DATALEN(80)\"\n\nIf RC > 0\n  Then do\n    ZEDSMSG = 'LMPUT Failed'\n    ZEDLMSG = 'LMPUT for UTLPNLS Failed, RC=' RC\n    \"SETMSG MSG(ISRZ001)\"\n    Return \"ERROR\"\nEnd\n\nReturn 'OK'\n\n\nClosePnl:\n\n/* Make sure something was open */\n\nIf write == 'N'\n  Then do\n    ZEDSMSG = 'XML Parse Error'\n    ZEDLMSG = 'Close tag found before new tag. Line number ' ix\n    \"SETMSG MSG(ISRZ001)\"\n    Return \"ERROR\"\nEnd\n\nIf currtag /= \"panel\"\n  Then do\n    ZEDSMSG = 'XML Parse Error'\n    ZEDLMSG = 'End tag with no matching begin tag at line' ix\n    \"SETMSG MSG(ISRZ001)\"\n    Return \"ERROR\"\nEnd\n\n\n\"LMMADD DATAID(\"PANELID\") MEMBER(\"MEMBER\")\"\n\nIf RC > 0\n  Then do\n    ZEDSMSG = 'LMMADD Failed'\n    ZEDLMSG = 'LMMADD for UTLPNLS Failed, RC=' RC\n    \"SETMSG MSG(ISRZ001)\"\n    Return \"ERROR\"\nEnd\n\n\n\"LMCLOSE DATAID(\"PANELID\")\"\n\nIf RC > 0\n  Then do\n    ZEDSMSG = 'LMCLOSE Failed'\n    ZEDLMSG = 'LMCLOSE for UTLPNLS Failed, RC=' RC\n    \"SETMSG MSG(ISRZ001)\"\n    Return \"ERROR\"\nEnd\n\n\nReturn 'OK'\n\n\n/* Process Skeletons */\n\nOpenSkel:\n\n/* Make sure nothing already open */\n\nIf write == 'Y'\n  Then do\n    ZEDSMSG = 'XML Parse Error'\n    ZEDLMSG = 'New tag found before end tag. Line number ' ix\n    \"SETMSG MSG(ISRZ001)\"\n    Return \"ERROR\"\nEnd\n\n\n\n\"LMINIT Dataid(SKELID) DDNAME(UTLSKEL)\"\n\nIf RC > 0\n  Then do\n    ZEDSMSG = 'LMINIT Failed'\n    ZEDLMSG = 'LMINIT for UTLPNLS Failed, RC=' RC\n    \"SETMSG MSG(ISRZ001)\"\n    Return \"ERROR\"\nEnd\n\n\n\"LMOPEN Dataid(\"SKELID\") OPTION(OUTPUT)\"\n\nIf RC > 0\n  Then do\n    ZEDSMSG = 'LMOPEN Failed'\n    ZEDLMSG = 'LMOPEN for UTLSKEL Failed, RC=' RC\n    \"SETMSG MSG(ISRZ001)\"\n    Return \"ERROR\"\nEnd\n\nParse value sourceline(ix) with \"<\" xmlline \">\"\n\nParse value xmlline with \"skeleton \" attr \">\"\n\nInterpret attr\n\nIf RC > 0\n  Then do\n    ZEDSMSG = 'XML Attr Error'\n    ZEDLMSG = 'Error interpreting XML Attribute at line' ix\n    \"SETMSG MSG(ISRZ001)\"\n    Return \"ERROR\"\nEnd\n\nReturn 'OK'\n\n\n\nWriteSkel:\n\nIf write == 'N'\n  Then do\n    ZEDSMSG = 'XML Parse Error'\n    ZEDLMSG = 'Attempting to write with no open file at line' ix\n    \"SETMSG MSG(ISRZ001)\"\n    Return \"ERROR\"\nEnd\n\nSrcline = sourceline(ix)\n\n\"LMPUT DATAID(\"SKELID\") MODE(INVAR) DATALOC(SRCLINE) DATALEN(80)\"\n\nIf RC > 0\n  Then do\n    ZEDSMSG = 'LMPUT Failed'\n    ZEDLMSG = 'LMPUT for UTLSKEL Failed, RC=' RC\n    \"SETMSG MSG(ISRZ001)\"\n    Return \"ERROR\"\nEnd\n\nReturn 'OK'\n\n\nCloseSkel:\n\n/* Make sure something was open */\n\nIf write == 'N'\n  Then do\n    ZEDSMSG = 'XML Parse Error'\n    ZEDLMSG = 'Close tag found before new tag. Line number ' ix\n    \"SETMSG MSG(ISRZ001)\"\n    Return \"ERROR\"\nEnd\n\nIf currtag /= \"skeleton\"\n  Then do\n    ZEDSMSG = 'XML Parse Error'\n    ZEDLMSG = 'End tag with no matching begin tag at line' ix\n    \"SETMSG MSG(ISRZ001)\"\n    Return \"ERROR\"\nEnd\n\n\"LMMADD DATAID(\"SKELID\") MEMBER(\"MEMBER\")\"\n\nIf RC > 0\n  Then do\n    ZEDSMSG = 'LMMADD Failed'\n    ZEDLMSG = 'LMMADD for UTLSKEL Failed, RC=' RC\n    \"SETMSG MSG(ISRZ001)\"\n    Return \"ERROR\"\nEnd\n\n\n\"LMCLOSE DATAID(\"SKELID\")\"\n\nIf RC > 0\n  Then do\n    ZEDSMSG = 'LMCLOSE Failed'\n    ZEDLMSG = 'LMCLOSE for UTLSKEL Failed, RC=' RC\n    \"SETMSG MSG(ISRZ001)\"\n    Return \"ERROR\"\nEnd\n\n\nReturn 'OK'\n\n\n\n/* Process Messages  */\n\nOpenMsg:\n\n/* Make sure nothing already open */\n\nIf write == 'Y'\n  Then do\n    ZEDSMSG = 'XML Parse Error'\n    ZEDLMSG = 'New tag found before end tag. Line number ' ix\n    \"SETMSG MSG(ISRZ001)\"\n    Return \"ERROR\"\nEnd\n\n\n\n\"LMINIT Dataid(MSGID) DDNAME(UTLMSGS)\"\n\nIf RC > 0\n  Then do\n    ZEDSMSG = 'LMINIT Failed'\n    ZEDLMSG = 'LMINIT for UTLMSGS Failed, RC=' RC\n    \"SETMSG MSG(ISRZ001)\"\n    Return \"ERROR\"\nEnd\n\n\n\"LMOPEN Dataid(\"MSGID\") OPTION(OUTPUT)\"\n\nIf RC > 0\n  Then do\n    ZEDSMSG = 'LMOPEN Failed'\n    ZEDLMSG = 'LMOPEN for UTLMSGS Failed, RC=' RC\n    \"SETMSG MSG(ISRZ001)\"\n    Return \"ERROR\"\nEnd\n\nParse value sourceline(ix) with \"<\" xmlline \">\"\n\nParse value xmlline with \"message \" attr \">\"\n\nInterpret attr\n\nIf RC > 0\n  Then do\n    ZEDSMSG = 'XML Attr Error'\n    ZEDLMSG = 'Error interpreting XML Attribute at line' ix\n    \"SETMSG MSG(ISRZ001)\"\n    Return \"ERROR\"\nEnd\n\nReturn 'OK'\n\n\n\nWriteMsg:\n\nIf write == 'N'\n  Then do\n    ZEDSMSG = 'XML Parse Error'\n    ZEDLMSG = 'Attempting to write with no open file at line' ix\n    \"SETMSG MSG(ISRZ001)\"\n    Return \"ERROR\"\nEnd\n\nSrcline = sourceline(ix)\n\n\"LMPUT DATAID(\"MSGID\") MODE(INVAR) DATALOC(SRCLINE) DATALEN(80)\"\n\nIf RC > 0\n  Then do\n    ZEDSMSG = 'LMPUT Failed'\n    ZEDLMSG = 'LMPUT for UTLMSGS Failed, RC=' RC\n    \"SETMSG MSG(ISRZ001)\"\n    Return \"ERROR\"\nEnd\n\nReturn 'OK'\n\n\nCloseMsg:\n\n/* Make sure something was open */\n\nIf write == 'N'\n  Then do\n    ZEDSMSG = 'XML Parse Error'\n    ZEDLMSG = 'Close tag found before new tag. Line number ' ix\n    \"SETMSG MSG(ISRZ001)\"\n    Return \"ERROR\"\nEnd\n\nIf currtag /= \"message\"\n  Then do\n    ZEDSMSG = 'XML Parse Error'\n    ZEDLMSG = 'End tag with no matching begin tag at line' ix\n    \"SETMSG MSG(ISRZ001)\"\n    Return \"ERROR\"\nEnd\n\n\n\"LMMADD DATAID(\"MSGID\") MEMBER(\"MEMBER\")\"\n\nIf RC > 0\n  Then do\n    ZEDSMSG = 'LMMADD Failed'\n    ZEDLMSG = 'LMMADD for UTLMSGS Failed, RC=' RC\n    \"SETMSG MSG(ISRZ001)\"\n    Return \"ERROR\"\nEnd\n\n\n\"LMCLOSE DATAID(\"MSGID\")\"\n\nIf RC > 0\n  Then do\n    ZEDSMSG = 'LMCLOSE Failed'\n    ZEDLMSG = 'LMCLOSE for UTLPNLS Failed, RC=' RC\n    \"SETMSG MSG(ISRZ001)\"\n    Return \"ERROR\"\nEnd\n\n\nReturn 'OK'\n\n\n\n\n\n\n\n\n\n\n\n/* ---  All XML Data below this line --- */\n\n<panel member=\"ASCBLST\">\n)ATTR\n  % TYPE(TEXT)   INTENS(HIGH) COLOR(TURQ)  CAPS(OFF)\n  _ TYPE(INPUT)  INTENS(HIGH) COLOR(TURQ)  HILITE(USCORE) CAPS(ON)\n  $ TYPE(OUTPUT) INTENS(LOW)  COLOR(GREEN)\n  | TYPE(OUTPUT) INTENS(LOW)  COLOR(GREEN) JUST(RIGHT)\n  + TYPE(TEXT)   INTENS(LOW)  COLOR(GREEN) CAPS(OFF) SKIP(ON)\n  @ TYPE(TEXT)   INTENS(LOW)  COLOR(WHITE) CAPS(OFF) HILITE(USCORE)\n)BODY EXPAND(\\\\)\n%\\-\\ &ZSYSID ASCB List \\-\\\n%\n%Command ===>_ZCMD\n%\n%Show ASCBs Starting with Jobname:_ASCBJOBN+\n%\n%Time Zone..........$ZONE  + (Adjust EWST timestamps by this value)\n%Current Date/Time..$DATE    $TIME\n%\n@Sel   Jobname  Jobid    ASID User    +\n)MODEL\n_Z   +$JOBNAME $JOBID   +$Z  $JUSERID +\n)INIT\n &ZTDMARK='                      ------ End of ASCB List -------'\n .ZVARS = '(SEL ASIDX)'\n .CURSOR = 'ASCBJOBN'\n .HELP   = 'ASCBHELP'\n)REINIT\n)PROC\n VER(&ASCBJOBN,NAME)\n)HELP\n)END\n</panel>\n\n\n<panel member=\"ASCBDETP\">\n)ATTR\n  % TYPE(TEXT)   INTENS(HIGH) COLOR(TURQ)  CAPS(OFF)\n  _ TYPE(INPUT)  INTENS(HIGH) COLOR(TURQ)  HILITE(USCORE) CAPS(ON)\n  $ TYPE(OUTPUT) INTENS(LOW)  COLOR(GREEN) CAPS(OFF)\n  | TYPE(OUTPUT) INTENS(LOW)  COLOR(GREEN) JUST(RIGHT)\n  + TYPE(TEXT)   INTENS(LOW)  COLOR(GREEN) CAPS(OFF) SKIP(ON)\n  @ TYPE(TEXT)   INTENS(LOW)  COLOR(WHITE) CAPS(OFF)\n)BODY WINDOW(66,22) EXPAND(\\\\)\n%\\-\\ &ZSYSID ASCB Detail \\-\\+\n%\n%Command ===>_ZCMD                                              +\n%\n%Time Zone..........$ZONE  + (Adjust EWST timestamps by this)\n%Current Date/Time..$DATE    $TIME\n%ASCB Addr..........$ASCBX   +\n%Jobname............$JOBNAME +     %JobID.............$JOBID   +\n%User ID............$JUSERID +\n%ASID...............$ASID\n%SWTL...............$SWTL    +     %SWTL Seconds......$SWTLS    +\n%JSTL...............$JSTL    +     %JSTL Seconds......$JSTLS    +\n%RCTF...............$RCTF+         %RCTF Bit String...$RCTFB   +\n%Job Started Time...$INTSTIM                                    +\n%EWST Time..........$EWSTTIM                                    +\n%Current EWST.......$CUREWSTT                                   +\n%Seconds to 522.....$CTD522   +\n%Total Run Time.....$TOTTIME   +\n%Seconds Idle.......$CTDIDLE  +\n%CPU Secs Used......$CPUTIME          +\n%Accounting Info....$ACCTINFO                                   +\n%\n)INIT\n .CURSOR = 'ZCMD'\n .HELP   = 'ASCBHELP'\n)REINIT\n)PROC\n)HELP\n)END\n</panel>\n\n<panel member=\"ascbhelp\">\n)ATTR\n @ AREA(SCRL) EXTEND(ON)\n)BODY EXPAND(\\\\)\n% \\-\\ ASCB Help \\-\\\n%\n%Command ===>_ZCMD                                                             +\n@SAREA                                                                         @\n)AREA SAREA                                                                    +\n+This utility shows address space control blocks that are related to\n+timeouts.\n+\n+From the ASCB List panel you can filter the list by jobname.\n+\n%The ASCB List panel has the following fields:\n+\n%Time Zone\n+This shows the offset from GMT.  EWST times should be\n+adjusted by this value to get the local time.\n+\n%Current Date/Time\n+The current date and time in local time zone.\n+\n%Jobname\n+The name of the job.\n+\n%Jobid\n+The JES jobid. If system address space, then this reads SUB=MSTR.\n+\n%ASID\n+The job address space ID in hex.\n+\n%SWTL\n+The Step Wait Time Limit in hex. (See detail for more info.)\n+\n%JSTL\n+The Job Step Time Limit in hex. (See detail for more info.)\n+\n%EWST Timestamp\n+The GMT time that this job was last active.\n+\n+To select the detail of an address space, place an S in the Sel field\n+and press ENTER.\n+\n%The ASCB Detail panel has the following fields:\n+\n%Time Zone\n+This shows the offset from GMT.  EWST times should be\n+adjusted by this value to get the local time.\n+\n%Current Date/Time\n+The current date and time in local time zone.\n+\n%Jobname\n+The name of the job.\n+\n%Jobid\n+The JES jobid. If system address space, then this reads SUB=MSTR.\n+\n%ASID\n+The job address space ID in hex.\n+\n%SWTL\n+The Step Wait Time Limit in hex and in seconds.  The SWTL is\n+stored in STCK format.  Initially this value comes from the JWT\n+setting in the SMFPRMxx parmlib member.\n+\n%JSTL\n+The Job Step Time Limit in hex and in seconds.  The JSTL is\n+stored in STCK format.  This represents the number of seconds of CPU\n+time that the job can use before it is cancelled.  This value would\n+be set, for example, by the TIME parameter on a JCL job card.\n+\n%RCTF\n+The ASCBRCTF flags as a hex byte and as a bit string.\n+\n%Job Started Time\n+The timestamp when the job was initially started.\n+\n%EWST Timestamp\n+The GMT time that this job was last active.\n+\n%Current EWST Timestamp\n+The current GMT time.  This time is subtracted from the EWST\n+Timestamp to calculate the number of seconds the job has been idle.\n+\n%Seconds to 522\n+The number of seconds until this job will cancel with\n+a 522 timeout.  This is calculated by SWTL - Number of Seconds Idle.\n+There are three values any one of which can disable 522 timeouts:\n+ 1) The ASCBTOFF bit in the ASCBRCTF is set\n+ 2) The SWTL contains the magic number x'0D286880'\n+ 3) The JSTL is 86400 seconds (Equivalent to TIME=1440 on Job card)\n+\n+\n%Total Time\n+The time in Hours:Minutes:Seconds that this job has been\n+running.\n+\n%Seconds Idle\n+Total time that this job has been swapped out.  When this\n+reaches the SWTL time, the job will cancel with a 522.\n+\n%CPU Seconds Used\n+The total CPU time in seconds that this job used.\n+\n%Accounting Info\n+The Accounting information.\n+\n+\n+\n)END\n</panel>\n\n<message member=\"m1\">\n  This is message 1\n</message>\n\n\n<skeleton member=\"s1\">\n  This is a skeleton line\n</skeleton>\n\n\n\n\n\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXSMFASM": {"ttr": 1028, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x15\\x01\\x081O\\x01\\x081O\\x13X\\x01\\x92\\x01\\x92\\x00\\x02\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2008-11-09T00:00:00", "modifydate": "2008-11-09T13:58:15", "lines": 402, "newlines": 402, "modlines": 2, "user": "IBMUSER"}, "text": "//RXSMFASM JOB (ACCT#),'LINDY M.',\n//         MSGLEVEL=(1,1),MSGCLASS=X,\n//         NOTIFY=&SYSUID\n//*\n//*********************************************************************\n//* ASSEMBLE AND LINK REXXSMF\n//*********************************************************************\n//*\n//ASMLK EXEC HLASMCL,PARM.C='OBJECT,NODECK,XREF(SHORT),TEST,LIBMAC',\n//      PARM.L='LIST,LET,RENT,XREF,NCAL,AMODE(31)'\n//C.SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//           DD DSN=SYS1.MODGEN,DISP=SHR\n//C.SYSIN    DD *\n*\n*\n* A REXX function to write SMF records\n*\n*\n*  Basic Syntax of call:\n*\n*      rc = REXXSMF(type,text)\n* or:\n*      CALL 'REXXSMF' type,text\n*\n* Example 1 -\n*\n*  /* Rexx */\n*  smftyp = '189'\n*  smftxt = userid()' accessing application A at 'date(e) time()\n*  rc = REXXSMF(smftyp,smftxt)\n*  .\n*  .\n*  .\n*  exit\n*\n*\n* Example 2 -\n*\n*  /* Rexx */\n*  .\n*  .\n*  call 'REXXSMF '172','User 'userid()' exiting application A at' ,\n*     date(e) time()\n*  .\n*  .\n*  Say 'Return code is' RESULT\n*  .\n*  exit\n*                                                                  @LM\n*                                                                  @LM\n* Example 3 -                                                      @LM\n*   An example showing possible return codes:                      @LM\n*                                                                  @LM\n* smfrc = rexxsmf('200','This is some SMF data')                   @LM\n* select                                                           @LM\n*   when smfrc=0                                                   @LM\n*     then say 'Successful call'                                   @LM\n*   when smfrc=157                                                 @LM\n*     then say 'EMVSERR: SMF not recording'                        @LM\n*   when smfrc=121                                                 @LM\n*     then say 'EINVAL: Invalid call to BPX1SMF'                   @LM\n*   when smfrc=132                                                 @LM\n*     then say 'ENOMEM: Not enought storage available'             @LM\n*   when smfrc=139                                                 @LM\n*     then say 'EPERM: No access to BPX.SMF Facility class'        @LM\n*   otherwise nop                                                  @LM\n* end                                                              @LM\n*\n*\n*\n*\nREXXSMF TITLE 'REXX FUNCTION TO WRITE SMF RECORDS'\n***********************************************************************\n***      Thit is a program that will execute as a rexx              ***\n***      function under TSO/E Rexx and will cut SMF rexords.        ***\n***      The function accepts 2 arguments:-                         ***\n***       1. The SMF record type number.                            ***\n***       2. The SMF record text.                                   ***\n***   eg                                                            ***\n***       CALL 'REXXSMF' '185','Test record data'                   ***\n***   or                                                            ***\n***       XXX = REXXSMF('185','Test record data')                   ***\n***                                                                 ***\n***   The parameters can be literal strings or valid Rexx symbols   ***\n***   that have been previously set.                                ***\n***   SMF types of 128 or below will cause a function error.        ***\n***   The function does not return any data other than the return   ***\n***   code from the SMF routine. This will be set into 'XXX' if     ***\n***   called as a function, or the Rexx special variable 'RESULT'   ***\n***   if 'CALL'ed as a subroutine.                                  ***\n***   Iif one or both parameters are omitted the function will      ***\n***   return Rexx error 40 - INVALID CALL TO ROUTINE, and will      ***\n***   set a result of 'ERROR'.                                      ***\n***   Possible RC values from BPX1SMF are:                         @LM\n***      X'9D' EMVSERR - SMF record not bing recorded              @LM\n***      X'79' EINVAL  - Bad call to BPX1SMF                       @LM\n***      X'84' ENOMEM  - Not enough storage available              @LM\n***      X'8B' EPERM   - No access to BPX.SMF FACILITY class       @LM\n***                                                                 ***\n***                                                                 ***\n***   The original version of this program used a \"MAGIC\" SVC to   @LM*\n***   get into an authorized state.                                @LM*\n***                                                                @LM*\n***   This Rexx function uses the USS assembler callable service   @LM*\n***   BPX1SMF to write the record.  It does not need to be run     @LM*\n***   authorized.  However to run the user has to be given access  @LM*\n***   by being permitted ot the BPX.SMF resource in the RACF       @LM*\n***   FACILITY class.                                              @LM*\n***                                                                @LM*\n***   Change Log:                                                  @LM*\n***   Apr 21, 2008 Converted \"magic\" SVC to BPX1SMF.               @LM*\n***   Lindy Mayfield                                               @LM*\n***   SAS Institute                                                @LM*\n***   lindy.mayfield@ssf.sas.com                                   @LM*\n***                                                                @LM*\n***   Note: Full credit is given to the original author of this    @LM*\n***         utility. Unfortunately the original author is unknown. @LM*\n***         As mentioned above, I simply changed this program to   @LM*\n***         use BPX1SMF to write the SMF records.                  @LM*\n***                                                                 ***\n***********************************************************************\nREXXSMF CSECT\nREXXSMF AMODE 31\nREXXSMF RMODE ANY\n         STM   R14,R12,12(R13)         * SAVE REGS\n         LR    R12,R15                 *R12 --> BASE REGISTER\n         USING REXXSMF,R12\n         LR    R10,R0                  *R10 --> A(ENVIRONMENT BLOCK)\n         USING ENVBLOCK,R10\n         LR    R11,R1                  *R11 --> A(PARAM LIST (EFPL))\n         USING EFPL,R11\n         GETMAIN RU,LV=DYNLEN,LOC=ANY  *** OBTAIN DYNAMIC STORAGE\n         LR    R2,R1                   * POINT AT WORKAREA\n         L     R3,=A(DYNLEN)           * SET ITS LENGTH\n         LA    R4,0                    * SET DUMMY FROM ADDRESS\n         LA    R5,0                    * SET DUMMY LENGTH\n         MVCL  R2,R4                   * BLANK OUT THE AREA\n         ST    R13,4(R1)               * SAVE R13\n         ST    R1,8(R13)               * BACK-CHAIN SAVE AREAS\n         LR    R13,R1                  *R13 --> A(REG SAVE/DYNAM AREA)\n         USING DYNAM,R13\n         L     R9,ENVBLOCK_IRXEXTE     *R9 --> A(EXTERNAL EP TABLE)\n         USING IRXEXTE,R9\n         LA    R8,SMFAREA              *R8 --> AREA TO BUILD SMF REC\n         USING SMFSMF,R8\n         ST    R8,BUFA                 Store address for BPX      @LM\n***      CHECK THE PARAMETER LIST FOR VALID ARGUMENTS               ***\n***      AND STORE VALUES IN WORKING STORAGE                        ***\n***      FIRST CHECK FOR SMF TYPE VALUE AND STORE                   ***\n         L     R6,EFPLARG              *R6 --> A(ARGUMENT TABLE)\n         USING ARGTABLE_ENTRY,R6\n         CLC   ARGTABLE_ARGSTRING_PTR(8),=2F'-1' *END OF ARGS?\n         BE    ERROR                   * --> YES - EXIT RC 40\n*                                      (INVALID CALL TO ROUTINE)\n         L     R2,ARGTABLE_ARGSTRING_PTR    *R2 --> A(ARGUMENT)\n         L     R1,ARGTABLE_ARGSTRING_LENGTH *R1 --> L(ARGUMENT)\n         LA    R4,SMFTYP                    *R4 --> A(ARGUMENT)\n         BCTR  R1,0                    * DECREASE FOR MOVE\n         EX    R1,MOVEARG              * SAVE ARGUMENT\n***      NOW CHECK FOR SMF DATA, ENSURE NOT > 256 CHARS AND STORE   ***\n         LA    R6,ARGTABLE_NEXT        *R6 --> A(NEXT ARGUMENT)\n         CLC   ARGTABLE_ARGSTRING_PTR(8),=2F'-1' *END OR ARGS?\n         BE    ERROR                   * --> YES - EXIT RC 40\n*                                      (INVALID CALL TO ROUTINE)\n         L     R2,ARGTABLE_ARGSTRING_PTR    *R2 --> A(ARGUMENT)\n         L     R1,ARGTABLE_ARGSTRING_LENGTH *R1 --> L(ARGUMENT)\n         CH    R1,=H'256'              * LENGTH <= 256 ?\n         BH    ERROR                   * --> NO - EXIT\n         STH   R1,SMFSLEN              * SAVE DATA LENGTH IN SMF AREA\n         LA    R4,SMFDATA              *R4 --> A(ARGUMENT)\n         BCTR  R1,0                    * DECREASE LENGTH FOR MOVE\n         EX    R1,MOVEARG              * --> SAVE ARGUMENT\n         LA    R6,8(R6)                *R6 --> A(NEXT ARGUMENT)\n         B     ARGOK                   * SKIP EXECUTE STATEMENT\nMOVEARG  MVC   0(0,R4),0(R2)           * EXECUTABLE MOVE\n***      ARGUMENTS STORED - BUILD SMF RECORD                        ***\nARGOK    DS    0H\n         PACK  PTEMP(8),SMFTYP         * PACK PASSED SMF RECORD TYPE\n         CVB   R5,PTEMP                *R5 - RECORD TYPE (HEX)\n         ST    R5,SMF_TYPE             * SAVE TYPE FOR BPX         @LM\n         STCM  R5,B'0001',SMFSTYPE     * SAVE SINGLE BYTE TYPE\n         CLI   SMFSTYPE,X'80'          * TYPE 128 OR BELOW?\n         BH    SMFBLD                  * --> NO ? - OK\n         B     ERROR                   * --> YES? - EXIT\n* BUILD SMF RECORD FIXED ENTRIES (EXCEPT RECORD LENGTH)\nSMFBLD   EQU   *\n         MVI   SMFSFLAG,X'00'           * SET SMF FLAG\n         MVC   SMFSFIL,=H'0'            * SECOND HALF WORD TO 0\n* EXTRACT CURRENT DATE FROM CVT\n         USING CVT,R0                   * ADDRESS CVT BASE\n         L     R3,CVTPTR                * GET THE CVT\n         DROP  R0                                                  @LM\n         USING CVT,R3                   * AND MAP\n         L     R3,CVTDATE               *R3 --> DATE(PACKED)\n         DROP  R3\n         ST    R3,SMFSDATE              * SAVE IN SMF AREA\n* EXTRACT SMFID                                                    @LM\n         USING CVT,R0                   * ADDRESS CVT BASE         @LM\n         L     R3,CVTPTR                * GET THE CVT              @LM\n         DROP  R0                                                  @LM\n         USING CVT,R3                   * AND MAP                  @LM\n         L     R3,CVTSMCA               * ADDR OF SMCA             @LM\n         USING SMCABASE,R3                                         @LM\n         MVC   SMFSYSID,SMCASID         * MOVE SMFID               @LM\n         DROP  R3                                                  @LM\n* EXTRACT CURRENT TIME IN BINARY\n         LA    R3,TIMEADDR              *R3 --> A(TIME SAVE AREA)\n         TIME  MIC,(3)                  * GET TIME\n         LM    R2,R3,TIMEADDR           *R2 - TIME, R3 - DATE\n         SRDL  R2,12                    *SHIFT FOR DIVIDE\n         L     R1,=AL4(10000)           *SET DIVISOR\n         DR    R2,R1                    *CONVERT TO HUNDREDTHS\n         ST    R3,SMFSTIME              * SAVE IN SMF\n         LH    R14,SMFSLEN              *R14 - DATA LENGTH\n         AH    R14,=AL2(SMFLEN)         *ADD IN LENGTH OF HEADER\n         STH   R14,SMFSLEN              *STORE TOTAL LENGTH\n         ST    R1,BUFLENA               * STORE LENGTH FOR BPX     @LM\n*\n* CHECK IF SMF RECORDING TURNED ON FOR THIS RECORD                @LM\n         LOAD  EP=BPX1SMF           USS Callable service          @LM\n         ST    R0,BPX_MOD           Save address                  @LM\n         L     R15,BPX_MOD                                        @LM\n         CALL  (15),                smf_record                    @LM  +\n               (SMF_TYPE,           SMF record type               @LM  +\n               =F'0',               SMF record subtype            @LM  +\n               =F'0',               SMF record length             @LM  +\n               =F'0',               SMF record address set to zero@LM  +\n               BPXRETVAL,           Return value: 0 or -1         @LM  +\n               BPXRETCD,            Return code                   @LM  +\n               BPXRSNCD),           Reason code                   @LM  +\n               VL,MF=(E,PLIST)      ------------------------------@LM\n         DELETE EP=BPX1SMF                                        @LM\n         ICM   R15,B'1111',BPXRETVAL   Test return value          @LM\n         BNZ   ALLOK                Not recording or error, quit  @LM\n*\n* WRITE RECORD TO SMF                                             @LM\n*                                                                 @LM\n         LOAD  EP=BPX1SMF           USS Callable service          @LM\n         L     R15,BPX_MOD                                        @LM\n         MVC   SMF_SUBTYPE,=F'0'    Set SMF record subtype        @LM\n         CALL  (15),                smf_record                    @LM  +\n               (SMF_TYPE,           SMF record type               @LM  +\n               SMF_SUBTYPE,         SMF record subtype            @LM  +\n               BUFLENA,             SMF record length             @LM  +\n               BUFA,                SMF record address            @LM  +\n               BPXRETVAL,           Return value: 0 or -1         @LM  +\n               BPXRETCD,            Return code                   @LM  +\n               BPXRSNCD),           Reason code                   @LM  +\n               VL,MF=(E,PLIST)      ----------------------------- @LM\n         DELETE EP=BPX1SMF                                        @LM\n         ICM   R15,B'1111',BPXRETVAL   Test return value          @LM\n         BNZ   ALLOK                Not recording or error, quit  @LM\n*\n*        ALL OK - SO SET SMF RETURN CODE AS 'RC' VARIABLE &\n*        FUNCTION RESULT.\nALLOK    DS    0H\n         L     R15,BPXRETCD         * RETRIEVE BPX RETURN CODE      @LM\n*        L     R15,SMFRC            * RETRIEVE SMF RETURN CODE      @LM\n         CVD   R15,PTEMP            * CONVERT TO PACKED\n         MVC   RETCODE,=X'40212020' * SET EDIT MASK\n         ED    RETCODE,PTEMP+6      * CONVERT TO CHARACTER\n*        INITIALISE IRXEXCOM PARAMETER AREA\n         LA    R0,COMID             *R0 --> A(IRXEXCOM ID)\n         ST    R0,COMAREA           * SAVE ADDRESS\n         LA    R0,COMDUMMY          *R0 --> NOT USED PARM\n         ST    R0,COMAREA+4         * SAVE ADDRESS\n         ST    R0,COMAREA+8         * AND AGAIN (PARM2&3 MUST BE SAME)\n         LA    R0,COMSHVB           *R0 --> A(SHVBLOCK AREA)\n         ST    R0,COMAREA+12        * SAVE ADDRESS\n         LA    R0,COMRET            *R0 --> A(RETURN CODE AREA)\n         ST    R0,COMAREA+16        * SAVE ADDRESS\n         OI    COMAREA+16,X'80'     * SET HIGH BIT ON FOR LIST END\n         MVC   COMID,=CL8'IRXEXCOM'\n*        BUILD IRXEXCOM PARAMETERS\n         ST    R10,COMRET           *STORE ENVBLOCK ADDRESS (R10)\n         LA    R6,COMSHVB           *R6 --> A(SHVBLOCK AREA)\n         USING SHVBLOCK,R6\n         XC    COMSHVB(SHVBLEN),COMSHVB * INITIALIZE SHVBLOCK\n         XC    SHVNEXT,SHVNEXT          * RESET POINTER\n         MVI   SHVCODE,C'S'          * SET FUNCTION CODE - 'SET'\n         LA    R0,=C'RC'             *R0 --> A(VARIABLE NAME)\n         ST    R0,SHVNAMA            * STORE IN SHVBLOCK\n         MVC   SHVNAML,=A(2)         * STORE NAME LENGTH\n         LA    R0,RETCODE            *R0 --> A(VARIABLE VALUE)\n         ST    R0,SHVVALA            * STORE IN SHVBLOCK\n         MVC   SHVVALL,=A(L'RETCODE) * STORE VALUE LENGTH\n*        INVOKE IRXEXCOM TO SET VARIABLE\n         LR    R0,R10                *R0 --> A(ENVBLOCK)\n         LA    R1,COMAREA            *R1 --> A(PARM ADDR LIST)\n         L     R15,IRXEXCOM          *R15 --> AIRXEXCOM) FROM IRXEXTE\n         BALR  R14,R15               * CALL ROUTINE\n         LTR   R15,R15               * SET OK ?\n         BZ    SETOK                 * --> YES? - SKIP ABEND\n         LA    R1,=CL4'IRXC'         * SET ERROR INDICATOR\n         SLR   R0,R0                 * CLEAR R0\n*        UNCOMMENT THE NEXT LINE TO ABEND WHEN THERE IS AN ERROR   @LM\n*        EX    R0,*                  * FORCE DIAGNOSTIC ABEND      @LM\n*        SET RETURN CODE VALUE AS FUNCTION RESULT\nSETOK    EQU   *\n         DROP  R6\n         L     R6,EFPLEVAL\n         L     R6,0(R6)              *R6 --> A(EVALUATION BLOCK)\n         USING EVALBLOCK,R6\n         MVC   EVALBLOCK_EVLEN,=A(L'RETCODE) * SET LENGTH\n         MVC   EVALBLOCK_EVDATA(L'RETCODE),RETCODE * SET VALUE\n         XR    R15,R15               * ZERO REXX RETURN CODE\n         B     RETURN                * AND RETURN TO CALLER\n*        IF FUNCTION ERROR - SET 'ERROR' AS FUNCTION RESULT,\n*        AND REXX ERROR CODE 40 AS RETURN CODE\nERROR    DS    0H\n         L     R6,EFPLEVAL\n         L     R6,0(R6)              *R6 --> A(EVALUATION BLOCK)\n         MVC   EVALBLOCK_EVLEN,=A(5) * SET LENGTH\n         MVC   EVALBLOCK_EVDATA(5),=CL5'ERROR' * SET VALUE\n         LA    R15,40  * SET RC=40 TO INDICATE INVALID FUNCTION CALL\n         B     RETURN  * AND RETURN TO CALLER\n***      RETURN TO CALLER                                           ***\nRETURN   LR    R1,R13                  *R1 --> A(DYNAMIC AREA)\n         L     R13,4(R13)              * RESTORED BACK POINTER\n         LR    R2,R15                  * SAVE R15 AROUND FREEMAIN\n         FREEMAIN RU,A=(R1),LV=DYNLEN  * RELEASE DYNAMIC STORAGE\n         LR    R15,R2                  * RESTORE R15 FOR RETURN\n         RETURN (14,12),RC=(15)        * RETURN TO CALLER\n***      WORKING STORAGE ETC.                                       ***\n         TITLE  'WORKING STORAGE / DSECTS'\n         LTORG\n*\nDYNAM    DSECT                  * DYNAMIC WORK AREA STORAGE\nSAVEAREA DS    9D               * REG SAVE AREA\nSMFAREA  DS    CL330            * AREA FOR BUILD OF SMF REC\nPTEMP    DS    PL8              * PACKED DECIMAL WORK AREA\nSMFTYP   DS    CL3              * SMF TYPE (CHARACTER FROM ARG)\nSMFRC    DS    F                * SAVE AREA FOR SMFEWTM RETURN CODE\nRETCODE  DS    CL4              * OUTPUT RETURN CODE (CHARACTER)\nSTORSTAT DS    C                * APF STATUS INDICATOR\nTIMEADDR DS    2F               * RETURN AREA FOR TIME MACRO\n***      IRXEXCOM PARAMETER AREA                                    ***\nCOMAREA  DS    5A               * PARAMETER ADDRESS LIST\nCOMID    DS    CL8              * IRXEXCOM ID - C'IRXEXCOM'\nCOMDUMMY DS    A                * NOT USED\nCOMSHVB  DS    (SHVBLEN)X       * IRXEXCOM SHVBLOCK (LENGTH FROM DSECT)\nCOMRET   DS    A                * IRXECOM RC\n         DS    0D\n***      BPX1SMF PARMS                                             @LM\nSMF_TYPE     DS    F               SMF record type                 @LM\nSMF_SUBTYPE  DS    F               SMF record subtype              @LM\nBUFLENA      DS    F               SMF record length               @LM\nBUFA         DS    A               SMF record address              @LM\nBPXRETVAL    DS    F               Return value: 0 or -1           @LM\nBPXRETCD     DS    F               Return code                     @LM\nBPXRSNCD     DS    F               Reason code                     @LM\n*                                                                  @LM\nPLIST        DS   13A              Maximum number of parms         @LM\nBPX_MOD      DS   A                Address of BPX1SMF\nDYNLEN   EQU   *-DYNAM\n***      SMF RECORD MAPPING                                         ***\nSMFSMF   DSECT\nSMFSLEN  DS    XL2              * LEN OF SMF RECORD\nSMFSFIL  DS    XL2              * NOT USED\nSMFSFLAG DS    XL1              * SMF RECORD FLAG\nSMFSTYPE DS    XL1              * SMF RECORD TYPE\nSMFSTIME DS    XL4              * CURRENT TIME (BINARY)\nSMFSDATE DS    PL4              * CURRENT DATE (PACKED)\nSMFSYSID DS    CL4              * SYSTEM NAME (IP01)\nSMFLEN   EQU   *-SMFSMF    LENGTH OF RECORD HEADER\nSMFDATA  DS    0C          RECORD\n***      REQUIRED DSECTS FOR REXX AND SMF                           ***\n         CVT   DSECT=YES,LIST=YES\n         IRXEFPL\n         IRXARGTB\n         IRXEVALB\n         IRXENVB\n         IRXEXTE\n         IRXSHVB\n         IEESMCA\n*********************************************************************\n*                REGISTER EQUATES                                   *\n*********************************************************************\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n/*\n//L.SYSLMOD  DD DISP=SHR,DSN=IBMUSER.LINDY.LOAD(REXXSMF)\n//L.SYSIN    DD  *\n ENTRY REXXSMF\n NAME  REXXSMF(R)\n/*\n//*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXSMFEX": {"ttr": 1035, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x14\\x01\\x081O\\x01\\x081o\\x14T\\x00\\x10\\x00\\x10\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2008-11-09T00:00:00", "modifydate": "2008-11-11T14:54:14", "lines": 16, "newlines": 16, "modlines": 0, "user": "IBMUSER"}, "text": "/* Rexx */\nsmfrc = rexxsmf('200','This is some SMF data at' date() time() )\nselect\n  when smfrc=0\n    then say 'Successful call'\n  when smfrc=157\n    then say 'EMVSERR: SMF not recording'\n  when smfrc=121\n    then say 'EINVAL: Invalid call to BPX1SMF'\n  when smfrc=132\n    then say 'ENOMEM: Not enought storage available'\n  when smfrc=139\n    then say 'EPERM: No access to BPX.SMF Facility class'\n  otherwise say 'Error was:' smfrc\nend\nExit smfrc\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXSMFTST": {"ttr": 1037, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00T\\x01\\x081O\\x01\\x081O\\x13W\\x00\\x1a\\x00\\x12\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2008-11-09T00:00:00", "modifydate": "2008-11-09T13:57:54", "lines": 26, "newlines": 18, "modlines": 0, "user": "IBMUSER"}, "text": "//RXSMFTST JOB (ACCNT#),'LINDY M.',\n//         MSGLEVEL=(1,1),MSGCLASS=X,\n//         NOTIFY=&SYSUID\n//*\n//* TEST OF REXXSMF\n//*\n//STEP1    EXEC PGM=IKJEFT1B\n//SYSTSPRT DD SYSOUT=*\n//SYSPROC  DD DISP=SHR,DSN=CBT.CBTNNN.FILENNN.PDS.LKMV001\n//SYSTSIN  DD *\n %RXSMFEX\n//*\n//*\n//\n//*\n//* GIVE SMF A CHANCE TO RECORD THEN RUN TO VERIFY\n//*\n//*\n//STEP1    EXEC PGM=IFASMFDP\n//INDD1    DD DISP=SHR,DSN=SYS1.MAN1\n//OUTDD1   DD SYSOUT=*\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *\n  INDD(INDD1,OPTIONS(DUMP))\n  OUTDD(OUTDD1,TYPE(200))\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT796/FILE796.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT796", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}