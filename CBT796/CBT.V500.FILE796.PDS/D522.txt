/*  Rexx */

/*  This exec allocates all ISPF libraries internally. To run it you
    need only execute this exec.  Either TSO EX 'this.pds.(D522)' or
    in the normal way if it is in SYSPROC.
*/


/*  Version 3.03

    This exec shows information pertaining to the ASCBSWTL field in the
    ASCB and related control blocks.

    Written by Lindy Mayfield, SAS, Feb 2005
    based on Rexx report from John H.

    This exec has been hobbled together for over 3 years starting from
    a simple batch report written in Rexx.  That's the excuse why the
    code is a bit messy (to say the least).

    Change History:
    21-Feb-05  Added Seconds Idle field to detail.
    25-Feb-05  Added Accounting Information Field.
    12-Mar-06  Added CPU Time Used Field.
    19-Mar-06  Changed ASCB display to pad left with 0.
    20-Oct-06  Added ASCBINTS (Job start timestamp) and total seconds.
    22-Oct-06  Added help screen.
    23-Oct-06  Corrected CVTTZ Routine (thanks to Peter. G, Austraila)
    25-Oct-06  Corrected CVTTZ Routine again... (-:
    14-Nov-06  Added filter for jobtype from code changes by Peter.G.
    27-May-07  Removed filter (our job id names changed)
    28-Jun-07  Mistake. JSTL=86400 should have been JSTLS=86400.
    -- Version 2.00 --
    29-Jun-07  Renamed to CBEXPLR. Took call to BLSUXTOD out for every
               job in system because it was making things slow.
               Moved some logic and fields around.  Added some extra
               fields.
               The goal of this version is to turn it into a control
               block explorer.  I'm not sure if I can do this or not
               because I don't know yet what control blocks for other
               address spaces I can see or not.
               In any case, I am updating the 522 display and info.
    -- Version 3.00 --
    15-Aug-08  Added the LDA control block which uses RXGETCB assembler
               program.  Selection now is S or ASCB for ASCB/522 info
               and LDA for LDA control block.
    -- Version 3.01 --
    15-Aug-08  Fixed some problems with screen refresh on LDA screen.
               Added a check for garbage in user name.  Now puts N/A
               if it contains garbage.  Fixed JUSERID bug.
    -- Version 3.02 --
    17-Aug-08  More code cleanup.  All gets from storage use the
               Get_Stor() procedure. (Thanks to whoever wrote it.)
    23-Aug-08  Minor bug fix with acct info.  Put in option to igore
               LDA display.
    05 Nov-08  Cleaned up for CBT tape.  Removed the LDA because it
               requires a called module that runs authorized.

*/

Trace Off

Signal on NOVALUE

Parse source . . exec_mem . exec_dsn . . envname .


If envname <> 'ISPF'
  Then Do
    Say 'Error:  This exec only runs under ISPF.'
    Exit 99
End

numeric digits 256

Address ISPEXEC

"Control Errors Return"

x = MSG("OFF")

/* Initialize variables and constants */

ASCBJOBN = ""
ASCBJOBI = ""
SEL      = ""

If InitISPF() /= 'OK'
  Then Signal EndExec



Do forever

  If FillTable() /= 'OK' Then Leave

  "TBSORT ASCBLIST FIELDS(JOBNAME)"
  "TBTOP ASCBLIST"

  "TBDISPL ASCBLIST PANEL(ASCBLST)"

  If RC > 4 Then Leave

  "TBEND ASCBLIST"

  CMD = Word(ZCMD,1)

  Select
    When SEL <> ""
      Then Call ShowASCBDetail
    Otherwise Nop
  End

  SEL = ""

End


EndExec:


"LIBDEF ISPPLIB"
"LIBDEF ISPSLIB"
"LIBDEF ISPMLIB"

Address TSO "FREE DD(UTLPNLS UTLSKEL UTLMSGS)"

"TBEND ASCBLIST"

Exit 0



FillTable:


"TBCREATE ASCBLIST NAMES(JOBNAME ASCBX ASCB JOBID ASID ASIDX SWTL",
"         JSTL EWST EWSTTIM RCTF JUSERID) NOWRITE"

If RC > 0
  Then do
    ZEDSMSG = 'TBCREATE Failed'
    ZEDLMSG = 'Table Create for ASCBLIST Failed, RC=' RC
    "SETMSG MSG(ISRZ001)"
    Return "ERROR"
End

ZONE  = getZONE()
DATE  = DATE('U')
TIME  = TIME()

CVT  = Get_Stor('10'x)      /* psa+15 -> cvt   */
ASCB = Get_Stor(CVT,'234'x) /* CVT+564 -> ASCB */
ASCBX = right(c2x(ASCB),8,'0')

ASCBSUB  = 0
ASCBSTC  = 0
ASCBTSU  = 0
ASCBJOB  = 0

do while C2D(ASCB) /= 0
 call getASCBInfo
 if substr(JOBNAME,1,Length(ASCBJOBN)) = ASCBJOBN
   Then
     "TBADD ASCBLIST"
 ASCB = Get_Stor(ASCB,4)              /* ascb+4   -> next ascb */
 ASCBX = right(c2x(ASCB),8,'0')
end


Return "OK"



getZONE: Procedure

CVT = Get_Stor('10'x)
CVTEXT2 = Get_Stor(CVT,'148'x)
CVTLDTO = C2D(Get_Stor(CVTEXT2,'38'x,8),8)

ABSLDTO = Abs(CVTLDTO)
hours   = absldto % x2d('D693A400000')
minutes = (absldto % x2d('3938700000')) // 60
zone    = Right(hours,2,"0" )"."Right(minutes,2,"0" )
If cvtldto < 0 Then Do
   zone = "-"zone
End
Else Do
   zone = "+"zone
End

Return zone


getASCBInfo:

DATE=DATE('U')
TIME=TIME('L')

JBNI = Get_Stor(ASCB,'AC'x)           /* ascb+ac -> jbni */
JBNS = Get_Stor(ASCB,'B0'x)           /* ascb+b0 -> jbns */

If C2D(JBNI) /= 0
  then
    JOBNAME = Get_Stor(JBNI,0,8)
  else
    JOBNAME = Get_Stor(JBNS,0,8)

ASID  = Get_Stor(ASCB,'24'x,2)        /* ascb+24 -> asid */
ASID  = c2x(ASID)
ASIDX = Right(ASID,3,'0')

ASID  = ASIDX||'(x) '||x2d(ASID)||'(d)'
SWTL  = c2x(Get_Stor(ASCB,'C4'x))     /* ascb+C4 -> swtl */
JSTL  = c2x(Get_Stor(ASCB,'50'x))     /* ascb+50 -> jstl */
INTS  = c2x(Get_Stor(ASCB,'130'x,8))  /* ascb+130 -> ints */
INTSD = c2d(Get_Stor(ASCB,'130'x,4))  /* ascb+130 -> ints */
EWST  = c2x(Get_Stor(ASCB,'48'x,8))   /* ascb+48 -> ewst */
EWSTD = c2d(Get_Stor(ASCB,'48'x))     /* ascb+48 -> ewst */
RCTF  = c2x(Get_Stor(ASCB,'66'x,1))   /* ascb+66 -> rctf */
ASSB  = Get_Stor(ASCB,'150'x)         /* ascb+150 -> assb  */
JSAB  = Get_Stor(ASSB,'A8'x)          /* assb+A8  -> jsab  */
JOBID = "SUB=MSTR"

if C2D(JSAB) /= 0
  then Do
    JOBID = Get_Stor(JSAB,20,8)     /* jsab+14  -> jobid */
    JUSERID = Get_Stor(JSAB,44,8)     /* jsab+2c  -> jsabusid */
end
  else JUSERID = 'N/A'


RCTFB    = X2B(RCTF)

MYASCB   = Get_Stor('224'x)               /* PSA+224 -> psaaold */
CUREWST  = c2x(Get_Stor(MYASCB,'48'x,8))  /* ascb+48 -> ewst */
CUREWSTD = c2d(Get_Stor(MYASCB,'48'x,4))  /* ascb+48 -> ewst */

SWTLS = X2D(SWTL) * 1.048576
SWTLS = Trunc(SWTLS)

JSTLS = X2D(JSTL) * 1.048576
JSTLS = Trunc(JSTLS)

Return


ShowASCBDetail:

Call getASCBInfo
Call getASCBDetInfo

"Addpop"

do forever
  "Display Panel(ASCBDETP)"
  if RC > 4 then Leave
  call getASCBInfo
  call getASCBDetInfo
end

SEL = ""

"Rempop"

Return

getASCBDetInfo:

EWSTTIM  = Copies(0,26)  /* force result length=26 */
TOD_val = X2c(EWST)
Address linkpgm "BLSUXTOD TOD_val EWSTTIM"

INTSTIM  = Copies(0,26)  /* force result length=26 */
TOD_val = X2c(INTS)
Address linkpgm "BLSUXTOD TOD_val INTSTIM"

CUREWSTT = Copies(0,26)  /* force result length=26 */
TOD_val = X2c(CUREWST)
Address linkpgm "BLSUXTOD TOD_val CUREWSTT"

If SWTL = "0D286880" | Substr(RCTFB,8,1) = "1" | JSTLS = "86400"
  Then CTD522 = "N/A"
Else Do
  CTD522  = CUREWSTD - EWSTD
  CTD522  = CTD522 * 1.048576
  CTD522  = SWTLS - Trunc(CTD522)
End

TOTTIMES = CUREWSTD - INTSD
TOTTIMES = TOTTIMES * 1.048576
TOTTIMES = Trunc(TOTTIMES)

/* Convert secs into hhhh:mm:ss  */


TIMETMP = TOTTIMES
HHHH = TIMETMP % (60*60)
TIMETMP = TIMETMP - (HHHH * 60 * 60)
MM = TIMETMP % 60
TIMETMP = TIMETMP - (MM * 60)
SS = TIMETMP


HHHH = RIGHT(HHHH,4,'0')
MM   = RIGHT(MM,2,'0')
SS   = RIGHT(SS,2,'0')

TOTTIME = HHHH":"MM":"SS


CTDIDLE = CUREWSTD - EWSTD
CTDIDLE = CTDIDLE * 1.048576
CTDIDLE = Trunc(CTDIDLE)

/* Get Accounting Info */

OUCB   = Get_Stor(ASCB,'90'x)                 /* ASCB+90 -> oucb  */
ACNT   = c2x(Get_Stor(OUCB,'1C'x,1))          /* oucb+1c -> acnt */
ACNT   = x2b(ACNT)
if substr(ACNT,8,1) /= '1'
  then do
    ACCTINFO = 'N/A'
End
Else do
  ACTL   = c2d(Get_Stor(OUCB,'67'x,1))           /* oucb+67 -> actl */
  ACTP   = Get_Stor(OUCB,'E8'x)                  /* oucb+e8 -> acnp */
  ACCTINFO = Get_Stor(ACTP,,ACTL)
  ACCTINFO = substr(ACCTINFO,2,ACTL-1)
End

/* Get CPU Time from ASCBEJST+ASCBSRBT+ASSBASST */

EJST  = Get_Stor(ASCB,'40'x,8)     /* ascb+40  -> ejst */
SRBT  = Get_Stor(ASCB,'C8'x,8)     /* ascb+c8  -> srbt */
ASST  = Get_Stor(ASSB,'160'x,8)    /* assb+160 -> srbt */

WRK = x2d('0'left(c2x(EJST),13))
CPUTIME = FORMAT(WRK/1000000, 6, 3)

WRK = x2d('0'left(c2x(SRBT),13))
CPUTIME = CPUTIME + FORMAT(WRK/1000000, 6, 3)


Return




Get_Stor: PROCEDURE

/*------------------------------------------------------------------*/
/*                                                                  */
/*      This procedure will extract data using the MVS Storage      */
/*      function. Input arguments will be:                          */
/*                                                                  */
/*      1) Storage_Pointer or Literal, i.e. CVTPTR or '10'x, or     */
/*         16 (like '10'x)                                          */
/*      2) Offset in hex or dec (numnbe), i.e. 'FF'x or 256 or      */
/*         D2C(256)                                                 */
/*      3) Length of returned data in decimal, i.e. 256             */
/*                                                                  */
/*      NOTE - To make sure that this procedure will work all the   */
/*      times, just include 'NUMERIC DIGITS 256' at the beginning   */
/*      of the calling REXX exec.                                   */
/*                                                                  */
/*------------------------------------------------------------------*/

Parse Arg AREA,OFFSET,LENG

If Arg(2,'O') Then OFFSET=0

If Arg(3,'O') Then LENG=4

If DataType(AREA) = 'CHAR' Then Do
   AREA =  C2D(AREA)
   End

If DataType(OFFSET) = 'CHAR' Then Do
   OFFSET =  C2D(OFFSET)
   End

Return  Storage((D2X(AREA+OFFSET)),LENG)



Commify : procedure expose (globals)
  s = ARG(1) ;
  s = s+0
  l = LENGTH(s) - 3
  do i = l by -3 while i > 0 ;
    if substr(s,i,1) = '-' then leave
    if substr(s,i+1,1) <> '.' then
      s = INSERT(",", s, i) ;
  end
  return s


/*------------------------------------------------------------------*/
/*------------------------------------------------------------------*/
/*           ISPF Stuff Below This Line                             */
/*------------------------------------------------------------------*/
/*------------------------------------------------------------------*/


InitISPF:

If AllocISPF() /= "OK" Then Return "ERROR"

If ScanSrce() /= "OK"
  Then do
    If write == 'Y'
      Then do
        Select
          When currtag == 'panel'
            Then ClosePnl()
          When currtag == 'message'
            Then CloseMsg()
          When currtag == 'skeleton'
            Then CloseSkel()
          Otherwise Nop
        End
    End
    Return "ERROR"
End



"LIBDEF ISPPLIB LIBRARY ID(UTLPNLS)"

If RC > 0
  Then do
    ZEDSMSG = 'LIBDEF Failed'
    ZEDLMSG = 'LIBDEF for UTLPNLS Failed, RC=' RC
    "SETMSG MSG(ISRZ001)"
    Return "ERROR"
End

"LIBDEF ISPSLIB LIBRARY ID(UTLSKEL)"

If RC > 0
  Then do
    ZEDSMSG = 'LIBDEF Failed'
    ZEDLMSG = 'LIBDEF for UTLSKEL Failed, RC=' RC
    "SETMSG MSG(ISRZ001)"
    Return "ERROR"
End

"LIBDEF ISPMLIB LIBRARY ID(UTLMSGS)"

If RC > 0
  Then do
    ZEDSMSG = 'LIBDEF Failed'
    ZEDLMSG = 'LIBDEF for UTLMSGS Failed, RC=' RC
    "SETMSG MSG(ISRZ001)"
    Return "ERROR"
End



Return 'OK'





AllocISPF:

Address TSO "Alloc DD(UTLPNLS) NEW CATALOG UNIT(VIO) SPACE(2 2)",
            "TRACKS DIR(5) RECFM(F B) LRECL(80) BLKSIZE(0)"

If RC > 0
  Then do
    ZEDSMSG = 'Allocate Failed'
    ZEDLMSG = 'TSO Allocate for UTLPNLS failed, RC=' RC
    "SETMSG MSG(ISRZ001)"
    Return "ERROR"
End

Address TSO "Alloc DD(UTLSKEL) NEW CATALOG UNIT(VIO) SPACE(2 2)",
            "TRACKS DIR(5) RECFM(F B) LRECL(80) BLKSIZE(0)"

If RC > 0
  Then do
    ZEDSMSG = 'Allocate Failed'
    ZEDLMSG = 'TSO Allocate for UTLSKEL failed, RC=' RC
    "SETMSG MSG(ISRZ001)"
    Return "ERROR"
End

Address TSO "Alloc DD(UTLMSGS) NEW CATALOG UNIT(VIO) SPACE(2 2)",
            "TRACKS DIR(5) RECFM(F B) LRECL(80) BLKSIZE(0)"

If RC > 0
  Then do
    ZEDSMSG = 'Allocate Failed'
    ZEDLMSG = 'TSO Allocate for UTLMSGS failed, RC=' RC
    "SETMSG MSG(ISRZ001)"
    Return "ERROR"
End



Return "OK"





ScanSrce:

Write = "N"

pnlbegtag = "<"||"panel"      /* This kluge is to prevent the scan */
pnlendtag = "<"||"/panel>"    /* finding the tags in the wrong place.*/

skelbegtag = "<"||"skeleton"
skelendtag = "<"||"/skeleton"

msgbegtag = "<"||"message"
msgendtag = "<"||"/message"

currtag = ""               /* Will be set to panel, skeleton, message */


Do ix = 1 to sourceline()

  If pos(pnlendtag, sourceline(ix)) > 0
     Then Do
       If ClosePnl() /= 'OK' Then Return 'ERROR'
       write = 'N'
       currtag = ""
  End

  If pos(skelendtag, sourceline(ix)) > 0
     Then Do
       If CloseSkel() /= 'OK' Then Return 'ERROR'
       write = 'N'
       currtag = ""
  End

  If pos(msgendtag, sourceline(ix)) > 0
     Then Do
       If CloseMsg() /= 'OK' Then Return 'ERROR'
       write = 'N'
       currtag = ""
  End

  If write = "Y"
    Then do
      Select
        When currtag == "panel"
          Then do
            If WritePnl() /= 'OK' Then Return 'ERROR'
        End
        When currtag == "skeleton"
          Then do
            If WriteSkel() /= 'OK' Then Return 'ERROR'
        End
        When currtag == "message"
          Then do
            If WriteMsg() /= 'OK' Then Return 'ERROR'
        End
        Otherwise NOP /* Yeah, should handle this error... */
      End
  End

  If pos(pnlbegtag, sourceline(ix)) > 0
     Then do
       If OpenPnl() /= 'OK' Then Return 'ERROR'
       write = "Y"
       currtag = "panel"
  End

  If pos(skelbegtag, sourceline(ix)) > 0
     Then do
       If OpenSkel() /= 'OK' Then Return 'ERROR'
       write = "Y"
       currtag = "skeleton"
  End

  If pos(msgbegtag, sourceline(ix)) > 0
     Then do
       If OpenMsg() /= 'OK' Then Return 'ERROR'
       write = "Y"
       currtag = "message"
  End

End


Return "OK"




/* Process Panels  */

OpenPnl:

/* Make sure nothing already open */

If write == 'Y'
  Then do
    ZEDSMSG = 'XML Parse Error'
    ZEDLMSG = 'New tag found before end tag. Line number ' ix
    "SETMSG MSG(ISRZ001)"
    Return "ERROR"
End



"LMINIT Dataid(PANELID) DDNAME(UTLPNLS)"

If RC > 0
  Then do
    ZEDSMSG = 'LMINIT Failed'
    ZEDLMSG = 'LMINIT for UTLPNLS Failed, RC=' RC
    "SETMSG MSG(ISRZ001)"
    Return "ERROR"
End


"LMOPEN Dataid("PANELID") OPTION(OUTPUT)"

If RC > 0
  Then do
    ZEDSMSG = 'LMOPEN Failed'
    ZEDLMSG = 'LMOPEN for UTLPNLS Failed, RC=' RC
    "SETMSG MSG(ISRZ001)"
    Return "ERROR"
End

Parse value sourceline(ix) with "<" xmlline ">"

Parse value xmlline with "panel " attr ">"

Interpret attr

If RC > 0
  Then do
    ZEDSMSG = 'XML Attr Error'
    ZEDLMSG = 'Error interpreting XML Attribute at line' ix
    "SETMSG MSG(ISRZ001)"
    Return "ERROR"
End

Return 'OK'



WritePnl:

If write == 'N'
  Then do
    ZEDSMSG = 'XML Parse Error'
    ZEDLMSG = 'Attempting to write with no open file at line' ix
    "SETMSG MSG(ISRZ001)"
    Return "ERROR"
End

Srcline = sourceline(ix)

"LMPUT DATAID("PANELID") MODE(INVAR) DATALOC(SRCLINE) DATALEN(80)"

If RC > 0
  Then do
    ZEDSMSG = 'LMPUT Failed'
    ZEDLMSG = 'LMPUT for UTLPNLS Failed, RC=' RC
    "SETMSG MSG(ISRZ001)"
    Return "ERROR"
End

Return 'OK'


ClosePnl:

/* Make sure something was open */

If write == 'N'
  Then do
    ZEDSMSG = 'XML Parse Error'
    ZEDLMSG = 'Close tag found before new tag. Line number ' ix
    "SETMSG MSG(ISRZ001)"
    Return "ERROR"
End

If currtag /= "panel"
  Then do
    ZEDSMSG = 'XML Parse Error'
    ZEDLMSG = 'End tag with no matching begin tag at line' ix
    "SETMSG MSG(ISRZ001)"
    Return "ERROR"
End


"LMMADD DATAID("PANELID") MEMBER("MEMBER")"

If RC > 0
  Then do
    ZEDSMSG = 'LMMADD Failed'
    ZEDLMSG = 'LMMADD for UTLPNLS Failed, RC=' RC
    "SETMSG MSG(ISRZ001)"
    Return "ERROR"
End


"LMCLOSE DATAID("PANELID")"

If RC > 0
  Then do
    ZEDSMSG = 'LMCLOSE Failed'
    ZEDLMSG = 'LMCLOSE for UTLPNLS Failed, RC=' RC
    "SETMSG MSG(ISRZ001)"
    Return "ERROR"
End


Return 'OK'


/* Process Skeletons */

OpenSkel:

/* Make sure nothing already open */

If write == 'Y'
  Then do
    ZEDSMSG = 'XML Parse Error'
    ZEDLMSG = 'New tag found before end tag. Line number ' ix
    "SETMSG MSG(ISRZ001)"
    Return "ERROR"
End



"LMINIT Dataid(SKELID) DDNAME(UTLSKEL)"

If RC > 0
  Then do
    ZEDSMSG = 'LMINIT Failed'
    ZEDLMSG = 'LMINIT for UTLPNLS Failed, RC=' RC
    "SETMSG MSG(ISRZ001)"
    Return "ERROR"
End


"LMOPEN Dataid("SKELID") OPTION(OUTPUT)"

If RC > 0
  Then do
    ZEDSMSG = 'LMOPEN Failed'
    ZEDLMSG = 'LMOPEN for UTLSKEL Failed, RC=' RC
    "SETMSG MSG(ISRZ001)"
    Return "ERROR"
End

Parse value sourceline(ix) with "<" xmlline ">"

Parse value xmlline with "skeleton " attr ">"

Interpret attr

If RC > 0
  Then do
    ZEDSMSG = 'XML Attr Error'
    ZEDLMSG = 'Error interpreting XML Attribute at line' ix
    "SETMSG MSG(ISRZ001)"
    Return "ERROR"
End

Return 'OK'



WriteSkel:

If write == 'N'
  Then do
    ZEDSMSG = 'XML Parse Error'
    ZEDLMSG = 'Attempting to write with no open file at line' ix
    "SETMSG MSG(ISRZ001)"
    Return "ERROR"
End

Srcline = sourceline(ix)

"LMPUT DATAID("SKELID") MODE(INVAR) DATALOC(SRCLINE) DATALEN(80)"

If RC > 0
  Then do
    ZEDSMSG = 'LMPUT Failed'
    ZEDLMSG = 'LMPUT for UTLSKEL Failed, RC=' RC
    "SETMSG MSG(ISRZ001)"
    Return "ERROR"
End

Return 'OK'


CloseSkel:

/* Make sure something was open */

If write == 'N'
  Then do
    ZEDSMSG = 'XML Parse Error'
    ZEDLMSG = 'Close tag found before new tag. Line number ' ix
    "SETMSG MSG(ISRZ001)"
    Return "ERROR"
End

If currtag /= "skeleton"
  Then do
    ZEDSMSG = 'XML Parse Error'
    ZEDLMSG = 'End tag with no matching begin tag at line' ix
    "SETMSG MSG(ISRZ001)"
    Return "ERROR"
End

"LMMADD DATAID("SKELID") MEMBER("MEMBER")"

If RC > 0
  Then do
    ZEDSMSG = 'LMMADD Failed'
    ZEDLMSG = 'LMMADD for UTLSKEL Failed, RC=' RC
    "SETMSG MSG(ISRZ001)"
    Return "ERROR"
End


"LMCLOSE DATAID("SKELID")"

If RC > 0
  Then do
    ZEDSMSG = 'LMCLOSE Failed'
    ZEDLMSG = 'LMCLOSE for UTLSKEL Failed, RC=' RC
    "SETMSG MSG(ISRZ001)"
    Return "ERROR"
End


Return 'OK'



/* Process Messages  */

OpenMsg:

/* Make sure nothing already open */

If write == 'Y'
  Then do
    ZEDSMSG = 'XML Parse Error'
    ZEDLMSG = 'New tag found before end tag. Line number ' ix
    "SETMSG MSG(ISRZ001)"
    Return "ERROR"
End



"LMINIT Dataid(MSGID) DDNAME(UTLMSGS)"

If RC > 0
  Then do
    ZEDSMSG = 'LMINIT Failed'
    ZEDLMSG = 'LMINIT for UTLMSGS Failed, RC=' RC
    "SETMSG MSG(ISRZ001)"
    Return "ERROR"
End


"LMOPEN Dataid("MSGID") OPTION(OUTPUT)"

If RC > 0
  Then do
    ZEDSMSG = 'LMOPEN Failed'
    ZEDLMSG = 'LMOPEN for UTLMSGS Failed, RC=' RC
    "SETMSG MSG(ISRZ001)"
    Return "ERROR"
End

Parse value sourceline(ix) with "<" xmlline ">"

Parse value xmlline with "message " attr ">"

Interpret attr

If RC > 0
  Then do
    ZEDSMSG = 'XML Attr Error'
    ZEDLMSG = 'Error interpreting XML Attribute at line' ix
    "SETMSG MSG(ISRZ001)"
    Return "ERROR"
End

Return 'OK'



WriteMsg:

If write == 'N'
  Then do
    ZEDSMSG = 'XML Parse Error'
    ZEDLMSG = 'Attempting to write with no open file at line' ix
    "SETMSG MSG(ISRZ001)"
    Return "ERROR"
End

Srcline = sourceline(ix)

"LMPUT DATAID("MSGID") MODE(INVAR) DATALOC(SRCLINE) DATALEN(80)"

If RC > 0
  Then do
    ZEDSMSG = 'LMPUT Failed'
    ZEDLMSG = 'LMPUT for UTLMSGS Failed, RC=' RC
    "SETMSG MSG(ISRZ001)"
    Return "ERROR"
End

Return 'OK'


CloseMsg:

/* Make sure something was open */

If write == 'N'
  Then do
    ZEDSMSG = 'XML Parse Error'
    ZEDLMSG = 'Close tag found before new tag. Line number ' ix
    "SETMSG MSG(ISRZ001)"
    Return "ERROR"
End

If currtag /= "message"
  Then do
    ZEDSMSG = 'XML Parse Error'
    ZEDLMSG = 'End tag with no matching begin tag at line' ix
    "SETMSG MSG(ISRZ001)"
    Return "ERROR"
End


"LMMADD DATAID("MSGID") MEMBER("MEMBER")"

If RC > 0
  Then do
    ZEDSMSG = 'LMMADD Failed'
    ZEDLMSG = 'LMMADD for UTLMSGS Failed, RC=' RC
    "SETMSG MSG(ISRZ001)"
    Return "ERROR"
End


"LMCLOSE DATAID("MSGID")"

If RC > 0
  Then do
    ZEDSMSG = 'LMCLOSE Failed'
    ZEDLMSG = 'LMCLOSE for UTLPNLS Failed, RC=' RC
    "SETMSG MSG(ISRZ001)"
    Return "ERROR"
End


Return 'OK'











/* ---  All XML Data below this line --- */

<panel member="ASCBLST">
)ATTR
  % TYPE(TEXT)   INTENS(HIGH) COLOR(TURQ)  CAPS(OFF)
  _ TYPE(INPUT)  INTENS(HIGH) COLOR(TURQ)  HILITE(USCORE) CAPS(ON)
  $ TYPE(OUTPUT) INTENS(LOW)  COLOR(GREEN)
  | TYPE(OUTPUT) INTENS(LOW)  COLOR(GREEN) JUST(RIGHT)
  + TYPE(TEXT)   INTENS(LOW)  COLOR(GREEN) CAPS(OFF) SKIP(ON)
  @ TYPE(TEXT)   INTENS(LOW)  COLOR(WHITE) CAPS(OFF) HILITE(USCORE)
)BODY EXPAND(\\)
%\-\ &ZSYSID ASCB List \-\
%
%Command ===>_ZCMD
%
%Show ASCBs Starting with Jobname:_ASCBJOBN+
%
%Time Zone..........$ZONE  + (Adjust EWST timestamps by this value)
%Current Date/Time..$DATE    $TIME
%
@Sel   Jobname  Jobid    ASID User    +
)MODEL
_Z   +$JOBNAME $JOBID   +$Z  $JUSERID +
)INIT
 &ZTDMARK='                      ------ End of ASCB List -------'
 .ZVARS = '(SEL ASIDX)'
 .CURSOR = 'ASCBJOBN'
 .HELP   = 'ASCBHELP'
)REINIT
)PROC
 VER(&ASCBJOBN,NAME)
)HELP
)END
</panel>


<panel member="ASCBDETP">
)ATTR
  % TYPE(TEXT)   INTENS(HIGH) COLOR(TURQ)  CAPS(OFF)
  _ TYPE(INPUT)  INTENS(HIGH) COLOR(TURQ)  HILITE(USCORE) CAPS(ON)
  $ TYPE(OUTPUT) INTENS(LOW)  COLOR(GREEN) CAPS(OFF)
  | TYPE(OUTPUT) INTENS(LOW)  COLOR(GREEN) JUST(RIGHT)
  + TYPE(TEXT)   INTENS(LOW)  COLOR(GREEN) CAPS(OFF) SKIP(ON)
  @ TYPE(TEXT)   INTENS(LOW)  COLOR(WHITE) CAPS(OFF)
)BODY WINDOW(66,22) EXPAND(\\)
%\-\ &ZSYSID ASCB Detail \-\+
%
%Command ===>_ZCMD                                              +
%
%Time Zone..........$ZONE  + (Adjust EWST timestamps by this)
%Current Date/Time..$DATE    $TIME
%ASCB Addr..........$ASCBX   +
%Jobname............$JOBNAME +     %JobID.............$JOBID   +
%User ID............$JUSERID +
%ASID...............$ASID
%SWTL...............$SWTL    +     %SWTL Seconds......$SWTLS    +
%JSTL...............$JSTL    +     %JSTL Seconds......$JSTLS    +
%RCTF...............$RCTF+         %RCTF Bit String...$RCTFB   +
%Job Started Time...$INTSTIM                                    +
%EWST Time..........$EWSTTIM                                    +
%Current EWST.......$CUREWSTT                                   +
%Seconds to 522.....$CTD522   +
%Total Run Time.....$TOTTIME   +
%Seconds Idle.......$CTDIDLE  +
%CPU Secs Used......$CPUTIME          +
%Accounting Info....$ACCTINFO                                   +
%
)INIT
 .CURSOR = 'ZCMD'
 .HELP   = 'ASCBHELP'
)REINIT
)PROC
)HELP
)END
</panel>

<panel member="ascbhelp">
)ATTR
 @ AREA(SCRL) EXTEND(ON)
)BODY EXPAND(\\)
% \-\ ASCB Help \-\
%
%Command ===>_ZCMD                                                             +
@SAREA                                                                         @
)AREA SAREA                                                                    +
+This utility shows address space control blocks that are related to
+timeouts.
+
+From the ASCB List panel you can filter the list by jobname.
+
%The ASCB List panel has the following fields:
+
%Time Zone
+This shows the offset from GMT.  EWST times should be
+adjusted by this value to get the local time.
+
%Current Date/Time
+The current date and time in local time zone.
+
%Jobname
+The name of the job.
+
%Jobid
+The JES jobid. If system address space, then this reads SUB=MSTR.
+
%ASID
+The job address space ID in hex.
+
%SWTL
+The Step Wait Time Limit in hex. (See detail for more info.)
+
%JSTL
+The Job Step Time Limit in hex. (See detail for more info.)
+
%EWST Timestamp
+The GMT time that this job was last active.
+
+To select the detail of an address space, place an S in the Sel field
+and press ENTER.
+
%The ASCB Detail panel has the following fields:
+
%Time Zone
+This shows the offset from GMT.  EWST times should be
+adjusted by this value to get the local time.
+
%Current Date/Time
+The current date and time in local time zone.
+
%Jobname
+The name of the job.
+
%Jobid
+The JES jobid. If system address space, then this reads SUB=MSTR.
+
%ASID
+The job address space ID in hex.
+
%SWTL
+The Step Wait Time Limit in hex and in seconds.  The SWTL is
+stored in STCK format.  Initially this value comes from the JWT
+setting in the SMFPRMxx parmlib member.
+
%JSTL
+The Job Step Time Limit in hex and in seconds.  The JSTL is
+stored in STCK format.  This represents the number of seconds of CPU
+time that the job can use before it is cancelled.  This value would
+be set, for example, by the TIME parameter on a JCL job card.
+
%RCTF
+The ASCBRCTF flags as a hex byte and as a bit string.
+
%Job Started Time
+The timestamp when the job was initially started.
+
%EWST Timestamp
+The GMT time that this job was last active.
+
%Current EWST Timestamp
+The current GMT time.  This time is subtracted from the EWST
+Timestamp to calculate the number of seconds the job has been idle.
+
%Seconds to 522
+The number of seconds until this job will cancel with
+a 522 timeout.  This is calculated by SWTL - Number of Seconds Idle.
+There are three values any one of which can disable 522 timeouts:
+ 1) The ASCBTOFF bit in the ASCBRCTF is set
+ 2) The SWTL contains the magic number x'0D286880'
+ 3) The JSTL is 86400 seconds (Equivalent to TIME=1440 on Job card)
+
+
%Total Time
+The time in Hours:Minutes:Seconds that this job has been
+running.
+
%Seconds Idle
+Total time that this job has been swapped out.  When this
+reaches the SWTL time, the job will cancel with a 522.
+
%CPU Seconds Used
+The total CPU time in seconds that this job used.
+
%Accounting Info
+The Accounting information.
+
+
+
)END
</panel>

<message member="m1">
  This is message 1
</message>


<skeleton member="s1">
  This is a skeleton line
</skeleton>








