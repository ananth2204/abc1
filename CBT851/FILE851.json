{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012953000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 117572, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE851.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE851.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x03\\x06'", "DS1TRBAL": "b'\\x89v'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x06\\x07\\x00\\x0e\\x06\\x08\\x00\\x02\\x00\\x04'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04R\\x00\\t\\x01\\x11\\x13o\\x01\\x11\\x13o\\x08V\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf2@@@'", "ispf": {"version": "04.82", "flags": 0, "createdate": "2011-05-16T00:00:00", "modifydate": "2011-05-16T08:56:09", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-482"}, "text": "REGULAR CBT TAPE - VERSION 482    FILE:  851\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT482.FILE851\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 9 MEMBERS COUNTED; CUMULATIVE SIZE IS 756 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   05/16/11    08:56:09    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE1": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x003\\x01\\x11\\x13o\\x01\\x11\\x13o\\x01R\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-05-16T00:00:00", "modifydate": "2011-05-16T01:52:33", "lines": 27, "newlines": 27, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  CBT Tape package - copy all files on a tape to another\n          tape, based on RMM information\nFrom:     \"Fred Schmidt\" <Fred.Schmidt@nt.gov.au>\nDate:     Fri, 13 May 2011 16:32:20 +0930\nTo:       <sbgolob@cbttape.org>\n\nHi Sam,\n\nHere is the package I wrote to copy tape to tape using RMM\ninformation, as discussed. It is in XMIT format, as requested.\n\nAny questions, let me know.\n\nRegards,\nFred\n\n\nFred Schmidt\nSenior Systems Programmer\nData Centre Services\nDepartment of Business and Employment\nNorthern Territory Government of Australia\n\nGPO Box 2391, Darwin NT 0801\nTel: (08) 8999 6891   Fax: (08) 8999 7493\nemail:  Fred.Schmidt@nt.gov.au\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$NOTES": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x002\\x01\\x11\\x13?\\x01\\x11\\x13?\\x16\"\\x00D\\x00d\\x00\\x00\\xc6\\xe4\\xe2@@@@@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2011-05-13T00:00:00", "modifydate": "2011-05-13T16:22:32", "lines": 68, "newlines": 100, "modlines": 0, "user": "FUS"}, "text": "             Notes for running the RMMCOPY tool\n\n\nIntroduction.\n\nThe RMMCOPY tool was written to copy all files from one tape to\nanother, for tapes managed by RMM.  Whilst this is a simple process to\ndo manually via a batch job, with modern tapes able to contain many\nthousands of files, a manual approach soon becomes very cumbersome.\nThere are commercial products available to copy tapes, however, that\ncosts money. This tool was written to perform such a copy without\nhaving to purchase a package. The tool should copy tapes with all\nvalid block sizes at the time of writing, including up to 256K.\n\nThe tool copies all DCB attributes and the expiry date from the source\ntape's datasets. You can override the expiry date to a single fixed\nvalue, for all datasets, by modifying the settings in the RMMEXEC (see\nbelow for details).\n\nOne restriction that the tool has, is that where there are more than\n255 files on the tape to be copied, the output tape must first have a\ndummy file written to it, so that its VOLSER is known. This is\nrequired because a maximum of 255 steps are permitted in a job. Since\nthere is no DD referback mechanism available between jobs, the\nVOLSER of the output tape must be known in advance and available to\nthe subsequent jobs. The result of this approach is that all files\non such an output tape appear one file sequence number later than they\ndo on the input tape.\n\n\nUse.\n\n- Update the job in member RMMALLOC, according to the instructions in\n  the job, and run it. This job creates 2 datasets required by RMM\n  to produce the report in the next job.\n\n- Update the job in member RMMLIST, according to the instructions in\n  the job, and run it. This generates a list of the datasets on the\n  tape to be copied, as known to RMM. The DCB attributes, expiry date,\n  file sequence number, tape location and other information for these\n  datasets are listed. Headings are removed from the list, to\n  simplify later processing of this list.\n\n- Identify from the RMMLIST job's output dataset whether more than 255\n  files are on the tape.  If there are more than 255 files on the\n  input tape, run the job in member RMMDUMMY. This writes a dummy\n  dataset to the first file on a scratch tape.  Note the VOLSER of the\n  tape written to.  This will be used as the output tape for the copy.\n\n- Customise the REXX exec in member RMMEXEC, according to the\n  instructions in the exec.\n\n- Update the job in member RMMGEN, according to the instructions in\n  the job, and run it. The RMMGEN job generates a PDS dataset, with\n  members containing the jobs to copy the tape datasets from the input\n  tape to the output tape.\n\n- Review the jobs generated by RMMGEN, update if required, and run\n  them one at a time, in order,\n  to copy the tape.  The jobs to copy the tape retain the input\n  tape on the same drive, for all steps in each job. Between jobs, the\n  tape will be dismounted.  Similarly for the output tape. The jobs\n  assume that the new datasets written to the output tape are not to\n  be cataloged, since they will have the same names as those on the\n  input tape. You can of course edit the JCL to change the output\n  dataset names and/or catalog them, according to your requirements.\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE851": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x04R\\x00\\x02\\x01\\x11\\x13o\\x01\\x11\\x13o\\x08V\\x00'\\x00'\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf2@@@\"", "ispf": {"version": "04.82", "flags": 0, "createdate": "2011-05-16T00:00:00", "modifydate": "2011-05-16T08:56:02", "lines": 39, "newlines": 39, "modlines": 0, "user": "CBT-482"}, "text": "//***FILE 851 is from Fred Schmidt and contains his tool to create  *   FILE 851\n//*           tape copying JCL that copies one tape to another.     *   FILE 851\n//*           His package is called RMMCOPY.                        *   FILE 851\n//*                                                                 *   FILE 851\n//*       email:  Fred.Schmidt@nt.gov.au                            *   FILE 851\n//*                                                                 *   FILE 851\n//*             Notes for running the RMMCOPY tool                  *   FILE 851\n//*                                                                 *   FILE 851\n//*     Introduction.                                               *   FILE 851\n//*                                                                 *   FILE 851\n//*     The RMMCOPY tool was written to copy all files from one     *   FILE 851\n//*     tape to another, for tapes managed by RMM.  Whilst this     *   FILE 851\n//*     is a simple process to do manually via a batch job, with    *   FILE 851\n//*     modern tapes able to contain many thousands of files, a     *   FILE 851\n//*     manual approach soon becomes very cumbersome.  There are    *   FILE 851\n//*     commercial products available to copy tapes, however,       *   FILE 851\n//*     that costs money. This tool was written to perform such     *   FILE 851\n//*     a copy without having to purchase a package. The tool       *   FILE 851\n//*     should copy tapes with all valid block sizes at the time    *   FILE 851\n//*     of writing, including up to 256K.                           *   FILE 851\n//*                                                                 *   FILE 851\n//*     The tool copies all DCB attributes and the expiry date      *   FILE 851\n//*     from the source tape's datasets. You can override the       *   FILE 851\n//*     expiry date to a single fixed value, for all datasets,      *   FILE 851\n//*     by modifying the settings in the RMMEXEC (see below for     *   FILE 851\n//*     details).                                                   *   FILE 851\n//*                                                                 *   FILE 851\n//*     One restriction that the tool has, is that where there      *   FILE 851\n//*     are more than 255 files on the tape to be copied, the       *   FILE 851\n//*     output tape must first have a dummy file written to it,     *   FILE 851\n//*     so that its VOLSER is known. This is required because a     *   FILE 851\n//*     maximum of 255 steps are permitted in a job. Since there    *   FILE 851\n//*     is no DD referback mechanism available between jobs, the    *   FILE 851\n//*     VOLSER of the output tape must be known in advance and      *   FILE 851\n//*     available to the subsequent jobs. The result of this        *   FILE 851\n//*     approach is that all files on such an output tape appear    *   FILE 851\n//*     one file sequence number later than they do on the input    *   FILE 851\n//*     tape.                                                       *   FILE 851\n//*                                                                 *   FILE 851\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RMMALLOC": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00T\\x01\\x11\\x13?\\x01\\x11\\x13?\\x15Q\\x00\\x1f\\x00'\\x00\\x00\\xc6\\xe4\\xe2@@@@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2011-05-13T00:00:00", "modifydate": "2011-05-13T15:51:54", "lines": 31, "newlines": 39, "modlines": 0, "user": "FUS"}, "text": "//RMMALLOC JOB (MFS,1206),'F.SCHMIDT X96891',CLASS=A,MSGCLASS=2,\n//             MSGLEVEL=(1,1),NOTIFY=&SYSUID,\n//             TIME=NOLIMIT,REGION=0M,\n//             LINES=100        100,000 LINES BEFORE WARNINGS\n//*********************************************************************\n//* PURPOSE:  ALLOCATE RMM OUTPUT DATASETS REQUIRED\n//* SOURCE:\n//* NOTES:\n//* UPDATE: - CHANGE \"#HLQ\" TO THE DATASET HLQ'S TO BE\n//*           GENERATED FOR THE DATASETS USED BY THIS TOOL.\n//*\n//*********************************************************************\n//CLEANUP  EXEC PGM=IDCAMS\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *\n  DELETE #HLQ.RMM.MESSAGE\n  DELETE #HLQ.RMM.EXTRACT\n  SET MAXCC=0\n/*\n//ALLOC    EXEC PGM=IEFBR14\n//SYSPRINT  DD SYSOUT=*\n//DD1       DD DSNAME=#HLQ.RMM.MESSAGE,\n//             UNIT=SYSDA,\n//             DCB=(RECFM=VB,LRECL=459,BLKSIZE=27998),\n//             SPACE=(CYL,(1,5)),\n//             DISP=(NEW,CATLG)\n//DD2       DD DSNAME=#HLQ.RMM.EXTRACT,\n//             UNIT=SYSDA,\n//             DCB=(RECFM=VB,LRECL=7004,BLKSIZE=27998),\n//             SPACE=(CYL,(50,100),RLSE),\n//             DISP=(NEW,CATLG)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RMMDUMMY": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00C\\x01\\x11\\x13?\\x01\\x11\\x13?\\x15@\\x00\\x19\\x00\\x1a\\x00\\x00\\xc6\\xe4\\xe2@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2011-05-13T00:00:00", "modifydate": "2011-05-13T15:40:43", "lines": 25, "newlines": 26, "modlines": 0, "user": "FUS"}, "text": "//RMMDUMMY JOB (MFS,1206),'F.SCHMIDT X96891',CLASS=A,MSGCLASS=2,\n//             MSGLEVEL=(1,1),NOTIFY=&SYSUID,\n//             TIME=NOLIMIT,    NO TIME LIMIT ON JOB\n//             LINES=100,       100,000 LINES BEFORE WARNINGS\n//             REGION=32M\n//*********************************************************************\n//* PURPOSE:  RMMCOPY - WRITE A DUMMY FIRST FILE TO A SCRATCH TAPE,\n//*           SO THAT ITS VOLSER IS KNOWN.\n//* SOURCE:\n//* NOTES:\n//*\n//* UPDATE:   UPDATE THE JOB AS REQUIRED, TO MEET YOUR INSTALLATION'S\n//*           STANDARDS.\n//*********************************************************************\n//COPY     EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD *\n  DUMMY FIRST FILE\n/*\n//SYSUT2   DD DSN=#HLQ.DUMMY.DATASET,\n//            DISP=(,CATLG),EXPDT=1999/365,\n//            UNIT=TAPE,\n//            LRECL=80,RECFM=FB,BLKSIZE=80,\n//            LABEL=(1,SL)\n//SYSIN    DD DUMMY\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RMMEXEC": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x006\\x01\\x11\\x13?\\x01\\x11\\x13?\\x15B\\x01<\\x01!\\x00\\x00\\xc6\\xe4\\xe2@@@@@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "2011-05-13T00:00:00", "modifydate": "2011-05-13T15:42:36", "lines": 316, "newlines": 289, "modlines": 0, "user": "FUS"}, "text": "/** REXX *************************************************************/\n/*                                                                   */\n/*                               RMMEXEC                             */\n/*                               -------                             */\n/*                                                                   */\n/* PURPOSE: REXX - BUILD JOBS TO COPY A TAPE USING IEBGENER          */\n/*                                                                   */\n/* SYNTAX : RMMEXEC volser_out                                       */\n/*                                                                   */\n/*          volser_out- the output tape's VOLSER. OPTIONAL. Required */\n/*                      if there are more than 255 files on the tape.*/\n/*                      This is because more than 255 files requires */\n/*                      more than 255 steps and hence more than one  */\n/*                      job. There is no way to pass the tape VOLSER */\n/*                      used to the subsequent jobs, if a scratch    */\n/*                      volume was used. Therefore, a dummy dataset  */\n/*                      must be allocated on file 1 of the output    */\n/*                      tape, then writing commencing from file 2.   */\n/*                                                                   */\n/* UPDATE : Customise this exec as follows, before using it.         */\n/*                                                                   */\n/*        - Refer to the section titled \"Set constants\". Update as   */\n/*          required the values set here.                            */\n/*                                                                   */\n/*        - Refer to the section where the jobcard is built. Update  */\n/*          as required, to your installation's standards.           */\n/*                                                                   */\n/* AUTHOR : Fred Schmidt                                             */\n/* SOURCE :                                                          */\n/* NOTES  :                                                          */\n/* HISTORY:                                                          */\n/* 28/04/11 1.0 Creation                                             */\n/*********************************************************************/\nPARSE   UPPER   ARG parms        /* Input parms to var parms         */\ncall Setup                       /* Setup standard environment       */\nif trace then trace r\n\n/*---------------------------------------------------------------------\nSet constants                                                      @h3\n---------------------------------------------------------------------*/\nJob_pref='FUSC'              /* First 4 chars of generated jobnames  */\nJobclass='E'                                    /* Jobclass for jobs */\nmaxsteps=255                                    /* Max steps per job */\ntyprun=\"HOLD\"                                   /* Job TYPRUN to use */\novexpdt=\"\"               /* Don't override EXPDT's for new tape dsns */\nprogram=\"ICEGENER\"          /* Program to do the copy, eg IEBGENER   */\n/*ovexpdt=\"1999/000\"*/      /* Override EXPDT to use for output dsns */\n\n/*---------------------------------------------------------------------\nSet static values                                                  @h3\n---------------------------------------------------------------------*/\noutlabel=\"1\"                /* First file on output tape to write to */\nvolser_out=''                    /* Default is no output tape VOLSER */\nk=1                                        /* Index for output lines */\nstep=1                        /* Counter for number of steps per job */\njobno=1                          /* Counter for job number generated */\n\n/**********************************************************************\nMain Code                                                          @h1\n**********************************************************************/\nPARSE VALUE parms WITH parms '(' options ')'\nPARSE   UPPER   VALUE parms WITH volser_out therest\nif therest<>'' then say 'Extraneous parms ignored:' therest<>''\nif volser_out<>'' then outlabel=\"2\" /* Start writing after dummy file*/\n\n/*=====================================================================\nRead List of dataset names and attributes\n=====================================================================*/\n'EXECIO * DISKR INDD (STEM LINE. FINIS'     /* FINIS Free's file  */\n  if rc<>0 then call exit rc,'Problems reading file' fileid\n\n/*=====================================================================\nExtract required info\n=====================================================================*/\nDo i=1 by 1 to line.0                /* For each dsn in list...      */\n\n  PARSE VALUE line.i WITH,\n                            2    dsn      46,\n                            49   volser   55,\n                            56   label    65,\n                            66   expdt    78,\n                            79   vrsprot  80,\n                            110  pgm      119,\n                            101  blksize  110,\n                            111  lrecl    119,\n                            120  recfm    124,\n                            127  loc      135,\n                            .\n\n  dsn=STRIP(dsn,'B')\n  label=STRIP(label,'B')\n  blksize=STRIP(blksize,'B')\n  lrecl=STRIP(lrecl,'B')\n  recfm=STRIP(recfm,'B')\n\n  Select\n    When ovexpdt <> \"\" then expdt=ovexpdt  /* allow override */\n    When expdt = \"00/00/1999\" then expdt=\"1999/000\"\n    When expdt = \"31/12/1999\" then expdt=\"1999/365\"\n    When expdt = \"32/12/1999\" then expdt=\"1999/365\"\n    Otherwise do                              /* Convert date format */\n      PARSE VALUE expdt WITH dd \"/\" mm \"/\" ccyy\n      yy=SUBSTR(ccyy,3,2)\n      Edate=yy||\"/\"mm||\"/\"dd\n      expdt=GREG2JUL(Edate)\n      expdt=SUBSTR(expdt,1,4)||\"/\"||SUBSTR(expdt,5,3)\n    /*if SUBSTR(expdt,3,2)||SUBSTR(expdt,6,3)\n    < DATE('J') then expired=1 */\n    End\n  End /* Select */\n\n  If DEBUG then say 'dsn='dsn 'volser='volser 'label='label,\n      'expdt='expdt,\n      'blksize='blksize 'lrecl='lrecl 'recfm='recfm 'loc='loc\n\n/*=====================================================================\nIf > maxsteps, write output to new file\n=====================================================================*/\nif step >= maxsteps then do\n    outfile=\"OUT\"||RIGHT('00000'||jobno,5)\n    'EXECIO * DISKW' outfile '(STEM out1. FINIS'\n    DROP out1.\n    jobno=jobno+1\n    step=1\nEnd\n/*=====================================================================\nIf first step, build jobcard\n=====================================================================*/\nif step=1 then do\n  jobname=job_pref||RIGHT('00000'||jobno,3)\n  step=1                            /* Reset step counter          */\n  Say \"Building job\" jobname\n\n  out1.1 =\"//$JOBNAME JOB (MFS,1206),'F.SCHMIDT X96891',\"\n  out1.1=OVERLAY(jobname,out1.1,3,8,\" \")\n  if DEBUG then say out1.1\n\n  out1.2 =\"//             MSGCLASS=2,MSGLEVEL=(1,1),CLASS=\"jobclass\",\"\n  out1.3 =\"//             LINES=100,TIME=NOLIMIT,TYPRUN=\"typrun\",\"\n  out1.4 =\"//             NOTIFY=FUS,REGION=0M,USER=O50\"\n  k=5                     /* Next output line index */\nEnd\n\n/*=====================================================================\nBuild step for this dataset\n=====================================================================*/\ncopystep=\"COPY\"||RIGHT(step,4,0)\nout1.k=\"//\"copystep\" EXEC PGM=\"program\nk=k+1\nout1.k=\"//SYSPRINT DD SYSOUT=*\"\nk=k+1\nout1.k=\"//SYSUT1   DD DSN=\"dsn\",\"\nk=k+1\nout1.k=\"//            DISP=OLD,\"\nk=k+1\nout1.k=\"//            LRECL=\"lrecl\",RECFM=\"recfm\",\",\n                       ||\"BLKSIZE=\"blksize\",\"\nk=k+1\nout1.k=\"//            UNIT=TAPE,LABEL=(\"label\",SL),\"\nk=k+1\nSelect\n  When step=\"1\" then do\n    out1.k=\"//            VOL=(,RETAIN,SER=\"volser\")\"\n    end\n  Otherwise do\n    out1.k=\"//            VOL=(,RETAIN,REF=*.\"prev_step\".SYSUT1)\"\n    end\nEnd /* Select */\nk=k+1\nout1.k=\"//SYSUT2   DD DSN=\"dsn\",\"\nk=k+1\nout1.k=\"//            DISP=(,KEEP),EXPDT=\"expdt\",\"\nk=k+1\nout1.k=\"//            UNIT=TAPE,DATACLAS=ATL3592,\"\nk=k+1\nout1.k=\"//            LRECL=\"lrecl\",RECFM=\"recfm\",BLKSIZE=\"blksize\",\"\nk=k+1\nout1.k=\"//            LABEL=(\"outlabel\",SL),\"\nk=k+1\nSelect\n  When step=\"1\" then do\n    if volser_out='' then,\n      out1.k=\"//            VOL=(,RETAIN)\"\n    else\n      out1.k=\"//            VOL=(,RETAIN,SER=\"volser_out\")\"\n    end\n  Otherwise do\n    out1.k=\"//            VOL=(,RETAIN,REF=*.\"prev_step\".SYSUT2)\"\n    end\nEnd /* Select */\nk=k+1\nout1.k=\"//SYSIN    DD DUMMY\"\nk=k+1\nout1.k=\"//*======================================================\"\nk=k+1\n\nprev_step=copystep   /* Save stepname for next step's referback */\nstep=step+1\noutlabel=outlabel+1   /* Point to next tape label on output tape */\n\nEnd  /* Do i=1 by 1 to line.0 */\n\n\n/* Write out last job built */\noutfile=\"OUT\"||RIGHT('00000'||jobno,5)\n'EXECIO * DISKW' outfile '(STEM out1. FINIS'\n\ncall exit 0\n\n/**********************************************************************\n                             SUBROUTINES\n**********************************************************************/\n/*===================================================================*/\n/* Routines specific to this exec                                    */\n/*===================================================================*/\n/*-------------------------------------------------------------------*/\nGREG2JUL: /* Convert Gregorian date to Julian                        */\n/*-------------------------------------------------------------------*/\n/* Convert a Gregorian date in one of the following formats to    */\n/* Julian YYYYDDD.                                                */\n/* Allowed formats: YYYY-MM-DD, YYYY/MM/DD, YY-MM-DD, YY/MM/DD    */\ngdate = ARG(1)\nIf LENGTH(gdate) = 8 then         /* Handle YY-MM-DD and YY/MM/DD */\n  Do\n    /* Add century to YY format year                              */\n    If SUBSTR(gdate,1,2) < 70 then gdate = \"20\"gdate\n    Else gdate = \"19\"gdate\n  End\ngdate = SUBSTR(gdate,1,4)\"\"SUBSTR(gdate,6,2)\"\"SUBSTR(gdate,9,2)\n                                                    /* YYYYMMDD   */\nday = date('D',gdate,'S')                 /* DDD since year start */\nday = RIGHT(day,3,'0')                    /* Ensure leading 0's   */\nyear = substr(gdate,1,4)                            /* YYYYY      */\njdate = year\"\"day                                   /* YYYYDDD    */\nreturn jdate\n\n\n/*===================================================================*/\n/* Standard Routines                                                 */\n/*===================================================================*/\n/*-------------------------------------------------------------------*/\nSetup:    /* Standard Routines for environment and error handling @r */\n/*-------------------------------------------------------------------*/\ntrace n                          /* Trace only failing expressions   */\nsignal on  syntax                /* Trap REXX syntax errors          */\nsignal on  halt                  /* Trap HI commands (interrupts)    */\nsignal on  novalue               /* Trap uninitialised REXX vars     */\nsignal on  error                 /* Trap any commands with rc<>0     */\nIf wordpos(\"?\",parms)>0 then call HELP '$' /* Show Help information  */\nIf wordpos(\"%\",parms)>0 then call HELP '%' /* Show Samples           */\n\nPARSE VALUE parms WITH parms '(' options ')'\nvalid_options='DEBUG TRACE'\n\npasson=''\nPARSE VALUE 0 WITH 1 debug 1 trace .\nDo while options <> ''\n   PARSE UPPER VAR options option options\n   If WORDPOS(option,valid_options)<>0 then INTERPRET option'=1'\n   Else passon=passon option\nend\nparms=parms '(' passon ')'\nrc=0                             /* Prime RC in case no host calls   */\nRETURN                           /* Return to the main code          */\n/*-------------------------------------------------------------------*/\nSYNTAX:\n/*-------------------------------------------------------------------*/\n parse upper source . how myname mytype . syn .\n call errexit rc,'REXX problem in' myname mytype 'line' sigl':' ,\n      'ERRORTEXT'(rc), sigl':'||'SOURCELINE'(sigl)\n/*-------------------------------------------------------------------*/\nHALT:\n/*-------------------------------------------------------------------*/\n parse upper source . how myname mytype . syn .\n call ERREXIT 5, myname mytype 'halted by HI command.'\n/*-------------------------------------------------------------------*/\nERROR:\n/*-------------------------------------------------------------------*/\n parse upper source . how myname mytype . syn .\n call ERREXIT rc, 'Retcode' rc 'from' 'CONDITION'('D'),,\n  'Error occurred at line' sigl 'in' myname mytype\n/*-------------------------------------------------------------------*/\nNOVALUE:\n/*-------------------------------------------------------------------*/\n parse upper source . how myname mytype . syn . '' undefvar\n parse version . rexxlvl .\n if rexxlvl>=3.46 then undefvar=' \"'||'CONDITION'('D')'\"'\n call errexit 99,'REXX problem in' myname mytype 'line' sigl,\n      'variable'|| undefvar 'not defined'\n/*-------------------------------------------------------------------*/\nERREXIT:                         /*  Exit with retcode & errormsg    */\n/*-------------------------------------------------------------------*/\n do i=2 to 'ARG'()\n    say 'ARG'(i)\n end\n call exit 99        /* Do any tidying up specific to the main code*/\n/*-------------------------------------------------------------------*/\nHELP:          /* Display Help info between $..$ comments            */\n/*-------------------------------------------------------------------*/\n PARSE ARG c\n Do line = 1 to 100 while SUBSTR(SOURCELINE(line),1,3)<>'/*'||c; end\n Do line = line+1 to 100 while SUBSTR(SOURCELINE(line),1,3)<>'/*'||c\n   parse value SOURCELINE(line) with \"/*\" helpline \"*/\"\n   say helpline\n end\n call exit 00\nRETURN\n/*-------------------------------------------------------------------*/\nEXIT: /*  Common  EXIT routine                                       */\n/*-------------------------------------------------------------------*/\n  parse arg retc,errmsg\n  signal off error\n  parse upper source . . myname .\n  if errmsg<>'' then do; say myname':' errmsg; end\n  if symbol('buffer')='VAR' then 'DROPBUF' buffer /* Drop MAKEBUF */\n exit retc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RMMGEN": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00W\\x01\\x11\\x13?\\x01\\x11\\x13?\\x16\\x10\\x00?\\x00%\\x00\\x00\\xc6\\xe4\\xe2@@@@@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2011-05-13T00:00:00", "modifydate": "2011-05-13T16:10:57", "lines": 63, "newlines": 37, "modlines": 0, "user": "FUS"}, "text": "//RMMGEN   JOB (MFS,1206),'F.SCHMIDT X96891',CLASS=A,MSGCLASS=2,        JOB32361\n//             MSGLEVEL=(1,1),NOTIFY=&SYSUID,\n//             TIME=NOLIMIT,    NO TIME LIMIT ON JOB\n//             LINES=100,       100,000 LINES BEFORE WARNINGS\n//             REGION=0M\n//*********************************************************************\n//*\n//* PURPOSE:  GENERATE JOBS TO COPY ALL FILES ON A TAPE\n//*\n//* SOURCE:\n//* NOTES:    SPECIFY AS MANY OUTNNNNN DD STATEMENTS AS REQUIRED FOR\n//*           THE NUMBER OF JOBS TO BE GENERATED. IT DOESN'T MATTER\n//*           IF THERE ARE MORE THAN REQUIRED. THE NUMBER OF FILES\n//*           ON THE INPUT TAPE DIVIDED BY 255 IS THE MINIMUM NUMBER\n//*           OF DD STATEMENTS REQUIRED.\n//*\n//* UPDATE: - CHANGE \"#VOLSER\" TO THE TAPE VOLSER TO BE COPIED.\n//*         - CHANGE \"#HLQ\" TO THE DATASET HLQ'S TO BE GENERATED FOR\n//*           THE DATASETS USED BY THIS TOOL.\n//*         - CHANGE #HLQ.EXECS TO THE DATASET CONTAINING THE\n//*           RMMEXEC REXX EXEC.\n//*         - IF THERE ARE MORE THAN 255 FILES ON THE INPUT TAPE,\n//*           THEN UNCOMMENT AND USE THE SECOND FORM OF CALLING THE\n//*           REXX EXEC, I.E. USE THE \"%RMMEXEC VOLSER_OUT\" FORM,\n//*           AND REPLACE \"VOLSER_OUT\" WITH THE TAPE VOLSER THAT YOU\n//*           HAVE WRITTEN A DUMMY FILE TO, IN JOB RMMDUMMY.\n//*\n//*********************************************************************\n//CLEANUP  EXEC PGM=IDCAMS\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *\n  DELETE #HLQ.T#VOLSER.JOBS\n  SET MAXCC=0\n/*\n//ALLOC    EXEC PGM=IEFBR14\n//SYSPRINT  DD SYSOUT=*\n//DD1       DD DSNAME=#HLQ.T#VOLSER.JOBS,\n//             UNIT=SYSDA,\n//             DCB=(RECFM=FB,LRECL=80),\n//             SPACE=(CYL,(1,5,50)),\n//             DISP=(NEW,CATLG)\n//*\n//RUNREXX  EXEC PGM=IKJEFT01\n//SYSPROC  DD   DISP=SHR,DSN=#HLQ.EXECS   <=== DATASET WITH REXX EXEC\n//INDD     DD   DISP=SHR,DSN=#HLQ.T#VOLSER\n//OUT00001 DD   DISP=SHR,DSN=#HLQ.T#VOLSER.JOBS(A000001)\n//OUT00002 DD   DISP=SHR,DSN=#HLQ.T#VOLSER.JOBS(A000002)\n//OUT00003 DD   DISP=SHR,DSN=#HLQ.T#VOLSER.JOBS(A000003)\n//OUT00004 DD   DISP=SHR,DSN=#HLQ.T#VOLSER.JOBS(A000004)\n//OUT00005 DD   DISP=SHR,DSN=#HLQ.T#VOLSER.JOBS(A000005)\n//OUT00006 DD   DISP=SHR,DSN=#HLQ.T#VOLSER.JOBS(A000006)\n//OUT00007 DD   DISP=SHR,DSN=#HLQ.T#VOLSER.JOBS(A000007)\n//OUT00008 DD   DISP=SHR,DSN=#HLQ.T#VOLSER.JOBS(A000008)\n//OUT00009 DD   DISP=SHR,DSN=#HLQ.T#VOLSER.JOBS(A000009)\n//OUT00010 DD   DISP=SHR,DSN=#HLQ.T#VOLSER.JOBS(A000010)\n//SYSTSPRT DD   SYSOUT=*\n//SYSPRINT DD   SYSOUT=*\n//SYSTSIN  DD   *\nPROFILE NOPREFIX MSGID WTPMSG\n    %RMMEXEC\n /* %RMMEXEC VOLSER_OUT */\n/*\n//SYSIN    DD   DUMMY\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RMMLIST": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00D\\x01\\x11\\x13?\\x01\\x11\\x13o\\x08T\\x00\\xaf\\x00\\x9a\\x00\\x00\\xc6\\xe4\\xe2@@@@@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2011-05-13T00:00:00", "modifydate": "2011-05-16T08:54:44", "lines": 175, "newlines": 154, "modlines": 0, "user": "FUS"}, "text": "//RMMLIST  JOB (MFS,1206),'F.SCHMIDT X96891',CLASS=A,MSGCLASS=2,\n//             MSGLEVEL=(1,1),NOTIFY=&SYSUID,\n//             TIME=NOLIMIT,REGION=0M,\n//             LINES=100        100,000 LINES BEFORE WARNINGS\n//*********************************************************************\n//* PURPOSE:  GENERATE A LIST OF DATASETS ON A GIVEN TAPE VOLSER,\n//*           FROM RMM.\n//* SOURCE:\n//* NOTES:\n//* UPDATE: -CHANGE \"#VOLSER\" TO THE TAPE VOLSER TO BE COPIED.\n//*         -CHANGE \"#HLQ\" TO THE DATASET HLQ'S TO BE GENERATED FOR\n//*          THE DATASETS USED BY THIS TOOL.\n//*\n//*********************************************************************\n//CLEANUP  EXEC PGM=IDCAMS\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *\n  DELETE #HLQ.T#VOLSER\n  SET MAXCC=0\n/*\n//*********************************************************************\n//**    SKELETON MEMBER EDGSGICE\n//**    TAILORED BY THE RMM REPORT GENERATOR FOR REPORT FUSGDSN2\n//*********************************************************************\n//STEP01  EXEC PGM=EDGHSKP,PARM='RPTEXT,DATEFORM(E)'\n//SYSPRINT DD SYSOUT=*\n//MESSAGE  DD DSN=#HLQ.RMM.MESSAGE,\n//            DISP=SHR\n//XREPTEXT DD DSN=#HLQ.RMM.EXTRACT,\n//            DISP=SHR\n//*********************************************************************\n//**  STEPS TO SOLVE TITLE VARIABLES                               @N2A\n//*********************************************************************\n//TITVAR1  EXEC PGM=IDCAMS\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *\n REPRO INFILE(TTINDD) OUTFILE(TTOUTDD) SKIP(0) COUNT(1)\n//TTINDD   DD DSN=#HLQ.RMM.EXTRACT,\n//            DISP=SHR\n//TTOUTDD  DD DSN=&VTIT,UNIT=SYSALLDA,SPACE=(TRK,1),DISP=(,PASS),\n//            DCB=(RECFM=VB,BLKSIZE=32760)\n//**\n//TITVAR2  EXEC PGM=SORT,REGION=0M\n//*********************************************************************\n//**  PLEASE CHECK THE SYNTAX OF YOUR REPORT TITLE VARIABLES,\n//**  IF THIS STEP FAILS, OR ENDS WITH A BAD RETURN CODE.\n//*********************************************************************\n//SYSOUT   DD SYSOUT=*\n//SORTIN   DD DSN=&VTIT,DISP=(SHR,PASS)\n//SORTOUT  DD DSN=&SYMN,UNIT=SYSALLDA,SPACE=(TRK,(1,1)),\n//            DISP=(,PASS),\n//            DCB=(RECFM=FB,LRECL=80)\n//SYSIN    DD *\n OPTION COPY\n OUTFIL BUILD=(C'VT1,''',\n   C'Datasets on a given tape',\n   C'''',\n   80:X,\n   /,\n  C'VT2,''',\n   C'                                                 ',\n   C'''',\n   /,\n  C'VT3,''',\n   C'        ',\n   53,10,\n   C' at ',\n   63,6,\n   C'''',80:X),VTOF\n//*********************************************************************\n//**  DATE CALCULATION STEP\n//**  COMPARE VALUES CONTAINING &TODAY ARE CALCULATED BASED ON RUN DATE\n//*********************************************************************\n//DATECONV EXEC PGM=IKJEFT01,PARM='%EDGRGDAT'\n//SYSPROC  DD DISP=SHR,DSN=SYS1.SEDGEXE1\n//SYSTSPRT DD SYSOUT=*\n//DATEFMT  DD *\nDATE PATTERN:DD/MM/YYYY\n//INCLIN   DD *\n OPTION VLSHRT,VLSCMP,NOCHALT\n INCLUDE COND=((5,1,CH,EQ,C'X'),\n        AND,\n               (9,6,CH,EQ,C'#VOLSER'))\n INREC FIELDS=(1,4,\n           809,44,C' ',\n           9,6,C' ',\n           1326,5,C' ',\n           1356,10,C' ',\n           1165,1,C' ',\n           1238,8,C' ',\n           937,6,C' ',\n           931,6,C' ',\n           923,4,C' ',\n           156,8,C' ')\n SORT FIELDS=(56,8,CH,A)\n//INCLOUT  DD DSN=&INCL,UNIT=SYSALLDA,SPACE=(TRK,(1,1)),DISP=(,PASS),\n//            DCB=(RECFM=FB,LRECL=80)\n//SYSTSIN  DD DUMMY\n//*********************************************************************\n//**\n//**    following the new positions in record after inrec\n//**    (variable record length needs a rdw field in column 1 to 4)\n//**\n//*********************************************************************\n//* XDDSNAME                   : orig pos:  805. pos after inrec:    5\n//* XVVOLSER                   : orig pos:    5. pos after inrec:   50\n//* XDDSNSEQ                   : orig pos: 1322. pos after inrec:   57\n//* XDEXPDT                    : orig pos: 1352. pos after inrec:   63\n//* XDVRSR                     : orig pos: 1161. pos after inrec:   74\n//* XDCPGM                     : orig pos: 1234. pos after inrec:   76\n//* XDBLKSZ                    : orig pos:  933. pos after inrec:   85\n//* XDLRECL                    : orig pos:  927. pos after inrec:   92\n//* XDRECFM                    : orig pos:  919. pos after inrec:   99\n//* XVSTORID                   : orig pos:  152. pos after inrec:  104\n//**\n//WRITE1   EXEC PGM=ICETOOL,REGION=0M,COND=(16,LE,TITVAR2)\n//SYSPRINT DD SYSOUT=*\n//TOOLMSG  DD SYSOUT=*\n//DFSMSG   DD SYSOUT=*\n//INDD     DD DSN=#HLQ.RMM.EXTRACT,\n//            DISP=SHR\n//OUTDD    DD DISP=(,CATLG),DSN=#HLQ.T#VOLSER,\n//            UNIT=SYSDA,\n//            SPACE=(CYL,(1,1)),\n//            RECFM=FB,LRECL=134\n//TEMP     DD UNIT=SYSALLDA,SPACE=(TRK,(5,25))\n//TOOLIN   DD *\n SORT FROM(INDD)  TO(TEMP) USING(INCL)\n DISPLAY FROM(TEMP) LIST(OUTDD) -\n TITLE(VT1) -\n TITLE(VT2) -\n TITLE(VT3) -\n PAGE DATE(DM4/) TIME -\n HEADER('Data set name                               ') -\n     ON(5,44,CH) -\n HEADER('Volser') -\n     ON(50,6,CH) -\n HEADER('FSEQ ') -\n     ON(57,5,CH) -\n HEADER('Data set','expiration','date') -\n     ON(63,10,CH) -\n HEADER('Retained','by VRS','Y/N') -\n     ON(74,1,CH) -\n HEADER('Creating','program','name') -\n     ON(76,8,CH) -\n HEADER('Physic','block','size') -\n     ON(85,6,CH) -\n HEADER('Logical','record','length') -\n     ON(92,6,CH) -\n HEADER('Reco','form') -\n     ON(99,4,CH) -\n HEADER('Current','location','name') -\n     ON(104,8,CH) -\n BLANK -\n TOTAL(' ')\n//**                             /* &INCL CONTAINS THE SORT     @02A*/\n//**                             /* INCLUDE STATEMENTS, MODIFIED @02A*/\n//**                             /* IN STEP DATECONV             @02A*/\n//INCLCNTL DD DSN=&INCL,DISP=(OLD,PASS)                       /*@02C*/\n//SYMNAMES DD DSN=&SYMN,DISP=(OLD,PASS)                       /*@N2A*/\n//*\n//SORT   EXEC PGM=ICETOOL     KEEP ONLY LINES WITH DSNAMES\n//TOOLMSG  DD SYSOUT=*   ICETOOL MESSAGES - REQUIRED\n//DFSMSG   DD SYSOUT=*   DFSORT  MESSAGES - REQUIRED\n//INDD     DD DISP=SHR,DSN=*.WRITE1.OUTDD\n//OUTDD1   DD DISP=SHR,DSN=*.WRITE1.OUTDD\n//TOOLIN   DD *          CONTROL STATEMENTS - REQUIRED\n COPY -                  COPY\n FROM(INDD) -            FROM THIS INPUT DDNAME (DD STMT CAN BE CONCATN)\n USING(COPY)\n//COPYCNTL DD *          SORT CNTL PARMS\n OUTFIL FNAMES=(OUTDD1),\n        INCLUDE=(6,1,CH,NE,C' ',\n        AND,6,1,CH,NE,C'-')\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT851/FILE851.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT851", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}