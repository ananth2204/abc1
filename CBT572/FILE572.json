{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012403000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 235144, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "CBT.V500.FILE572.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 235144, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 235144, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE572.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x04\\t'", "DS1TRBAL": "b'*<'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04I\\x00\\t\\x04I\\x00\\r\\x00\\x05'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x12\\x9f\\x01\\x02\\x12\\x9f\\x18Q\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xc8\\xc9\\xd7\\xc4\\xc1\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-05-09T00:00:00", "modifydate": "2002-05-09T18:51:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "SHIPDAT"}, "text": "REGULAR CBT TAPE - VERSION 446    FILE:  572\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT446.FILE572\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 5 MEMBERS COUNTED; CUMULATIVE SIZE IS 1,652 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   05/09/02    18:51:52    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE572": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x05\\x01\\x01\\x02_\\x01\\x02\\x12\\x9f\\x18Q\\x00\\x1a\\x00\\x02\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2001-01-25T00:00:00", "modifydate": "2002-05-09T18:51:05", "lines": 26, "newlines": 2, "modlines": 0, "user": "SBGOLOB"}, "text": "//***FILE 572 is from Jeff Kaplan and contains zip programs that    *   FILE 572\n//*           run on MVS.  As written, these programs are quite     *   FILE 572\n//*           specialized in what they do, but they are a beginning *   FILE 572\n//*           to show us the way.                                   *   FILE 572\n//*                                                                 *   FILE 572\n//*           There are two packages here.  One is a zip program    *   FILE 572\n//*           written in Assembler, which puts its output to an     *   FILE 572\n//*           HFS file, and which is designed to zip big reports    *   FILE 572\n//*           relatively quickly.                                   *   FILE 572\n//*                                                                 *   FILE 572\n//*           The second program is written in JAVA, and is a very  *   FILE 572\n//*           high-compression program compatible with the common   *   FILE 572\n//*           zipping programs from other platforms.                *   FILE 572\n//*                                                                 *   FILE 572\n//*             email:  jdkaplan@optonline.net                      *   FILE 572\n//*                                                                 *   FILE 572\n//*           ZIPPER   - An assembler program designed to zip       *   FILE 572\n//*                      large reports with ANSI control            *   FILE 572\n//*                      characters.  If the report exceeds a       *   FILE 572\n//*                      certain size, then the program breaks      *   FILE 572\n//*                      the resulting zipped files into chunks.    *   FILE 572\n//*                                                                 *   FILE 572\n//*           ZIPJAVA  - JAVA language zip program for MVS.         *   FILE 572\n//*                      This is an IEBUPDTE-format pds, with       *   FILE 572\n//*                      several members.                           *   FILE 572\n//*                                                                 *   FILE 572\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ZIPJAVA": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x12\\x9f\\x01\\x02\\x12\\x9f\\x18@\\x00\\xa4\\x00\\xa4\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xd1\\xd2\\xf1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-05-09T00:00:00", "modifydate": "2002-05-09T18:40:00", "lines": 164, "newlines": 164, "modlines": 0, "user": "SYSPJK1"}, "text": "./ ADD NAME=ZIP      0101-02115-02115-1443-00014-00015-00000-SYSPJK1\n/* REXX */\nparse arg idsn irecfm ilrecl . ;\nsay \"Production zip JOB entered\";\nsay \"Passed input filename:\" idsn;\nsay \"Passed input RECFM:\" irecfm;\nsay \"Passed input LRECL:\" ilrecl;\naddress syscall \"chdir /production\"; /* dir where zip.class is */\nclasspath = \"/usr/lpp/java/J1.1/lib/classes.zip\"; /* java 1.1.8 clas*/\nclasspath = classpath\":/usr/lpp/java/J1.1/lib/recordio.jar\";\nclasspath = classpath\":/production\"; /* dir where zip.class is */\n\"/usr/lpp/java/J1.1/bin/java -classpath\" classpath ,\n   \"zip\" idsn irecfm ilrecl;\nsay \"Production zip JOB ended\";\nexit 0;\n./ ADD NAME=ZIPJ$DOC 0108-02115-02115-1556-00040-00001-00039-SYSPJK1\nOS/390 USS Java-based zip exec/program\n\nThis was developed/tested on OS/390 V2.6 with Java JDK 1.1.8.\nA newer JDK may be used.\n\nZIPTEST - JCL to run ZIP REXX exec\n          This JCL runs the ZIP java program and copies all of the\n          output to SDSF-accessible output and also copies the\n          zipped file to an OS/390 file.\nZIP - REXX exec to invoke java-based program.\nZIPJAVA - Java program source\n\nPlease make sure that you have the following as a minimum in your\n.profile file in your personal USS directory\nPATH=$PATH:$HOME:/usr/lpp/java/J1.1/bin\nCLASSPATH=/usr/lpp/java/J1.1/lib/classes.zip\n\nAfter following standard XMIT process and the files are in an\nOS/390 library and you have a personal USS workarea directory\n\nCopy the files to your HFS directory as in the folowing sample:\nfrom TSO option 6:\noput 'YourOS390Library(ZIPJAVA)' '/YourDIR/zip.java' text\noput 'YourOS390Library(ZIP)' '/YourDIR/zip' text\n\nCompiling the zip.java program from within USS\njavac -verbose zip.java\nThis should create a zip.class file in your HFS subdirectory\n\nUpdate the zip REXX-based program first:\nChange all directory names, etc. as required\nFor example, the line:\naddress syscall \"chdir /production\";\n\"/production\" has to be changed to point to your install directory\n\nUpdate the ZIPTEST JCL as approriate.\n\nThe resulting zipped file is placed in an OS/390 dataset that\nmay be FTPed BINARY MODE down to another system to be unzipped OR\ncan be placed in an HFS file and accessed via NFS, etc.\n./ ADD NAME=ZIPJAVA  0100-02115-02115-1649-00070-00070-00000-SYSPJK1\nimport java.io.*;\nimport java.util.StringTokenizer;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipOutputStream;\nimport com.ibm.record.*;\nimport com.ibm.recordio.*;\n\npublic class zip {\n\n    static File zipFile = null;\n    static ZipEntry z = null;\n    static ZipOutputStream zip = null;\n\n    public static void format(String fromFile,\n                              String fromRECFM,\n                              String fromLRECLS) throws Exception {\n        int fromLRECL = Integer.parseInt(fromLRECLS.trim());\n        LineNumberReader from = null;\n        try {\n        zipFile = new File(\"/tmp/\"+fromFile+\".zip\");\n        z = new ZipEntry(fromFile);\n        zip = new ZipOutputStream(new FileOutputStream(zipFile));\n        zip.putNextEntry(z);\nIRecordFile rf = RecordFile.getInstanceOf(\"//\" + fromFile,\n                                          fromLRECL,\n                                          fromRECFM);\nIFileInputRecordStream inpFile = FileInputRecordStream.getInstanceOf(rf);\nbyte\u00dd\u00a8 buffer = new byte\u00ddfromLRECL\u00a8;\nfor(;;)\n{ int bytesRead = inpFile.read(buffer);\n  if (bytesRead != IConstants.JRIO_READ_EOF)\n      { // if\n        String linex = new String(buffer,0,fromLRECL,\"Cp1047\");\n                linex = 'x' + linex;\n                linex = linex.trim().substring(1);\n                if(linex.length() == 0)\n                    linex = \" \" + linex;\n                linex = linex + \"\\n\";\n                zip.write(linex.getBytes(\"8859_1\"));\n      } // end if\n    else {break;}\n} // end for\ninpFile.close();\n} // end try\n        finally {}\n            if(zip != null)\n                try {\n                    zip.closeEntry();\n                    zip.close();\n                }\n                catch(IOException _ex) { }\n    } // end format\n\n    public static void main(String args\u00dd\u00a8)\n        throws FileNotFoundException, IOException {\n        if(args.length != 3)\n            System.err.println(\"Usage: java zip <3 PARMS>\");\n        else\n            try {\n                format(args\u00dd0\u00a8, args\u00dd1\u00a8, args\u00dd2\u00a8);\n            }\n            catch(Exception e) {\n                System.err.println(e.getMessage());\n            }\n    } // end main\n\n    public zip() {\n    }\n\n} // end class\n./ ADD NAME=ZIPTEST  0105-01299-02115-1439-00036-00030-00018-SYSPJK1\n//SYSPJK1A JOB (SPJK,7583),'KAPLAN',NOTIFY=&SYSUID,\n//         MSGCLASS=X,CLASS=M,REGION=0M,TIME=1440\n//*\n//* Sample JCL to exercise java-based zip program\n//*\n//* The JOBNAME of this JOB\n//JOBNAME  SET J=SYSPJK1A\n//* Input DSNAME of the file to be zipped\n//INPUTDSN SET I=SYSPJK1.AJVINST.EXEC\n//* Input file RECFM - code FB or VB\n//INRECFM  SET R=FB\n//* Input file LRECL\n//INLRECL  SET L=80\n//*\n//S1 EXEC PGM=BPXBATCH,\n// PARM=('SH /production/zip &I &R &L') <== change directory name\n//STDOUT DD PATH='/tmp/&J..stdout',  <== /tmp/ directory\n// PATHOPTS=(OWRONLY,OCREAT,OTRUNC),PATHMODE=SIRWXU\n//STDERR DD PATH='/tmp/&J..stderr',\n// PATHOPTS=(OWRONLY,OCREAT,OTRUNC),PATHMODE=SIRWXU\n//*\n//S2 EXEC PGM=IKJEFT01,DYNAMNBR=255\n//ZIPIN   DD PATH='/tmp/&I..zip',PATHDISP=(DELETE,DELETE)\n//ZIPOUT  DD DSN=SYSPJK1.TEST.ZIP,DISP=(NEW,CATLG), <==OS/390 output\n//  UNIT=SYSDA,RECFM=U,LRECL=0,BLKSIZE=27998,\n//  AVGREC=M,SPACE=(1,(1,1))\n//HFSOUT  DD PATH='/tmp/&J..stdout',PATHDISP=(DELETE,DELETE)\n//HFSERR  DD PATH='/tmp/&J..stderr',PATHDISP=(DELETE,DELETE)\n//STDOUT DD SYSOUT=*,RECFM=VB,LRECL=133,BLKSIZE=137\n//STDERR DD SYSOUT=*,RECFM=VB,LRECL=133,BLKSIZE=137\n//SYSTSPRT DD DUMMY\n//SYSTSIN  DD *\n  OCOPY INDD(ZIPIN) OUTDD(ZIPOUT) BINARY\n  OCOPY INDD(HFSOUT) OUTDD(STDOUT)\n  OCOPY INDD(HFSERR) OUTDD(STDERR)\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZIPP$DOC": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00Y\\x01\\x02\\x12\\x7f\\x01\\x02\\x12\\x9f\\x15#\\x00\\x1e\\x00\\x06\\x00\\x1e\\xe2\\xe8\\xe2\\xd7\\xd1\\xd2\\xf1@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2002-05-07T00:00:00", "modifydate": "2002-05-09T15:23:59", "lines": 30, "newlines": 6, "modlines": 30, "user": "SYSPJK1"}, "text": "ZIPPER is a program that zips OS/390 files in PKZIP/WINZIP compatible\n       format and saves the resultant zip file as an HFS file.\n\nThe zip logic employed is extremely fast and is specifically\ndesigned to zip output-based reports; i.e. do not use this program\nto zip load modules, etc.\nThe input file should be RECFM=FBA with ANSI control characters.\nOur testing has achieved zip compression ratios of 50%-75%.\nOther OS/390 JAVA-based zip programs that we wrote have achieved\n90% compression but are extremely slow.\nAs an example, we have zipped 2+GB reports down to 450 MB in about\n15-20 minutes.\n\nOur requirements dictated that every 50 pages of output,\nas counted by \"1\" carriage controls, results in 1 zip \"chunk\" file.\nThus, the resulting zipped file for a report of 175 pages will\ncontain 4 embedded files of 50 pages each except for the last file\nnamed block0, block1, block2 and block3.\n\nI will be adding doc to explain the zip logic.\nAs is, the source is probably very difficult to follow but\nalso shows how to write an HFS file from assembler language.\n\nSAMPLE JCL AS FOLLOWS:\n//STEP1    EXEC PGM=ZIPPER,   <== Load module name\n// PARM='/sysda/test.zip' <== Target HFS zipped directory/filename\n//*\n//STEPLIB  DD   DSN=xxxxxxxxxxxxx.LOADLIB,DISP=SHR\n//*\n//INPUT    DD   DISP=OLD,DSN=your-input-dsname=here  <== input dsname\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZIPPER": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x008\\x01\\x02\\x12\\x7f\\x01\\x02\\x12\\x9f\\x14Y\\x05\\x8c\\x05\\x85\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xd1\\xd2\\xf1@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2002-05-07T00:00:00", "modifydate": "2002-05-09T14:59:38", "lines": 1420, "newlines": 1413, "modlines": 0, "user": "SYSPJK1"}, "text": "//SYSPJK1A JOB (SPJK,7583),'KAPLAN',NOTIFY=&SYSUID,\n//         MSGCLASS=X,CLASS=F,REGION=7M,TIME=1440\n//S EXEC ASMHCL,SYSOUT='*',PARM.L='MAP,LET,LIST'\n//C.SYSIN DD *\nZIPPER   CSECT\nZIPPER   AMODE 31\nZIPPER   RMODE 24\n         SYSSTATE ASCENV=P\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nRA       EQU   10\nRB       EQU   11\nRC       EQU   12\nRD       EQU   13\nRE       EQU   14\nRF       EQU   15\n         BAKR  RE,0 LINKAGE STACK\n         LAE   RB,0(,RF)\n         USING ZIPPER,RB,RC\n         LAE   RC,4095(,RB)\n         LAE   RC,1(,RC)\n         LA    RD,SAVEAREA\n         MVC   4(4,RD),=C'F1SA'\n         L     R2,0(,R1) save parm ptr\n         L     R0,=A(768*1024)\n         LR    R1,R0\n         STORAGE OBTAIN,LENGTH=((0),(1)),LOC=(BELOW,ANY)\n         ST    R1,BUFFRBGN\n         ST    R1,BUFFRPTR\n         AL    R1,=A(512*1024) arbitrary loc for tempstor of dir info\n         ST    R1,DIRPTR save dir temp stor ptr\n         ST    R1,DIRSTOR save dir temp stor ptr\n         LH    R3,0(,R2) passed parm len\n         LTR   R3,R3 any parm passed\n         BZ    NOPARM exit\n         ST    R3,PATHNLEN store passed USS filename len\n         BCTR  R3,0 save filename too\n         EX    R3,MOVUSSFN ...\n* encoded data is written to stream in reversed order\n* Thus code X'71' (fixed huff x41=A) 01110001 --> 10001110\n* this reversed code of 10001110 is written in bit chunks as\n* thus if the current writing byte is ?????011 then written as\n* 01110011 and then ?????100 where the next byte will fillin ?s\n         LA    R2,HUFFLLEN ptr fixed huffman table to be built\n         LA    R3,X'30' value starting point\n         LA    R4,144 loop\nHUFLOOP1 STC   R3,0(,R2) table\n         LA    R2,1(,R2)\n         LA    R3,1(,R3)\n         BCT   R4,HUFLOOP1 ...\n         LA    R3,X'90' value starting point\n         LA    R4,112 loop\nHUFLOOP2 STC   R3,0(,R2) table\n         LA    R2,1(,R2)\n         LA    R3,1(,R3)\n         BCT   R4,HUFLOOP2 ...\n         LA    R3,X'00' value starting point\n         LA    R4,24 loop\nHUFLOOP3 STC   R3,0(,R2) table\n         LA    R2,1(,R2)\n         LA    R3,1(,R3)\n         BCT   R4,HUFLOOP3 ...\n         LA    R3,X'C0' value starting point\n         LA    R4,8 loop\nHUFLOOP4 STC   R3,0(,R2) table\n         LA    R2,1(,R2)\n         LA    R3,1(,R3)\n         BCT   R4,HUFLOOP4 ...\n         LA    R2,HUFFLLEN ptr fixed huffman table to be built\n         LA    R4,288 loop\nHUFFREV0 LA    R3,8 bits to reverse\n         LA    R1,128 left to right\n         LA    RF,1 right to left\n         XC    DWORD,DWORD use as workarea to reverse bits\nHUFFREV1 EX    R1,HUFFTM is bit 0 or 1\n         BZ    HUFFREV2 zero\n         EX    RF,HUFFOI reverse bit 1\nHUFFREV2 SRL   R1,1 test next bit\n         SLL   RF,1 to set next bit\n         BCT   R3,HUFFREV1 loop\n         MVC   0(1,R2),DWORD fix up with reversed byte\n         LA    R2,1(,R2) next byte to reverse\n         BCT   R4,HUFFREV0\n         OPEN  (INPUT,INPUT)\n*OPEN (SNAPDCB,OUTPUT)\n         XC    SERVRETV,SERVRETV\n         XC    SERVRETC,SERVRETC\n         XC    SERVREAS,SERVREAS\n         CALL  BPX1OPN,(PATHNLEN,                                      X\n               PATHNAME,                                               X\n               FILEOPTN,                                               X\n               FILEMODE,                                               X\n               SERVRETV,                                               X\n               SERVRETC,                                               X\n               SERVREAS),                                              X\n               VL\n         ICM   RF,15,SERVRETV FD OR IF -1 THEN ERROR\n         BM    FAIL\n         ST    RF,FD SAVE FD\nNEXTBLK  MVC   BUFFRPTR,BUFFRBGN\n         MVC   BITCTR,=F'8' reset constant\n         XC    BITBUCKT(16),BITBUCKT\n         L     R2,BUFFRPTR\n         XC    DWORD(32),DWORD clear\n         XC    CURROFF,CURROFF\n         XC    NEXTOFF,NEXTOFF\n         XC    TOTALCHR,TOTALCHR\n         L     RE,=A(BLNKDUPL) clear\n         LR    R0,RE\n         SLR   R1,R1\n         L     RF,=A(258*4) len to clear\n         MVCL  RE,R0 ...\n         L     RE,=A(DASHDUPL) clear\n         LR    R0,RE\n         SLR   R1,R1\n         L     RF,=A(258*4) len to clear\n         MVCL  RE,R0 ...\n         L     RE,=A(STARDUPL) clear\n         LR    R0,RE\n         SLR   R1,R1\n         L     RF,=A(258*4) len to clear\n         MVCL  RE,R0 ...\n         L     RE,=A(EQULDUPL) clear\n         LR    R0,RE\n         SLR   R1,R1\n         L     RF,=A(258*4) len to clear\n         MVCL  RE,R0 ...\n         L     RE,=A(ZERODUPL) clear\n         LR    R0,RE\n         SLR   R1,R1\n         L     RF,=A(258*4) len to clear\n         MVCL  RE,R0 ...\n         L     RE,=A(HBARDUPL) clear\n         LR    R0,RE\n         SLR   R1,R1\n         L     RF,=A(258*4) len to clear\n         MVCL  RE,R0 ...\n         TIME  DEC,DWORD,LINKAGE=SYSTEM,DATETYPE=YYYYMMDD\n* pd time-hhmmssthmiju0000 date-yyyymmdd\n         TR    DWORD(3),CNVBIN convert pd time to bin\n         TR    DWORD+9(3),CNVBIN convert pd date to bin\n         SLR   R0,R0\n         IC    R0,DWORD hh\n         SLL   R0,11\n         SLR   R1,R1\n         IC    R1,DWORD+1 mm\n         SLL   R1,5\n         SLR   RF,RF\n         IC    RF,DWORD+2 ss\n         SRL   RF,1 /2\n         OR    R0,R1\n         OR    R0,RF\n         STCM  R0,2,FILETIME+1 INTEL reversed bytes order\n         STCM  R0,1,FILETIME+0 ...\n         SLR   R0,R0\n         IC    R0,DWORD+9 yy\n         AL    R0,=F'9' adjust year for zips\n         SLL   R0,10\n         SLR   R1,R1\n         IC    R1,DWORD+10 mm\n         SLL   R1,5\n         SLR   RF,RF\n         IC    RF,DWORD+11 dd\n         OR    R0,R1\n         OR    R0,RF\n         STCM  R0,2,FILEDATE+1 INTEL reversed bytes order\n         STCM  R0,1,FILEDATE+0 ...\n         MVC   0(L'LOCLSIGN,R2),LOCLSIGN\n         MVC   L'LOCLSIGN(LOCLFSIZ,R2),LOCLFHDR\n         LA    R2,L'LOCLSIGN+LOCLFSIZ(,R2)\n         ST    R2,FILENPTR save ptr to current filename\n         MVC   0(5,R2),=c'block'\n         SLR   RF,RF\n         ICM   RF,3,CENTFCNT update total file count\n         CVD   RF,DWORD\n         LA    RF,1(,RF)\n         STCM  RF,3,CENTFCNT\n         STCM  RF,3,CENTFCN2\n         UNPK  5(7,R2),DWORD+4(4)\n         OI    11(R2),C'0'\n         TR    0(12,R2),X0378859\n         MVCIN DWORD(7),11(R2) remove leading zeroes\n         LA    R1,1 min len of file literal\n         LA    RF,DWORD+1\n         CLC   ASCZEROS(6),5(R2)\n         BE    RBLOCK0 ...\n         LA    R1,1(,R1) incr filename len\n         LA    RF,1(,RF) incr ptr\n         CLC   ASCZEROS(5),5(R2)\n         BE    RBLOCK0 ...\n         LA    R1,1(,R1) incr filename len\n         LA    RF,1(,RF) incr ptr\n         CLC   ASCZEROS(4),5(R2)\n         BE    RBLOCK0 ...\n         LA    R1,1(,R1) incr filename len\n         LA    RF,1(,RF) incr ptr\n         CLC   ASCZEROS(3),5(R2)\n         BE    RBLOCK0 ...\n         LA    R1,1(,R1) incr filename len\n         LA    RF,1(,RF) incr ptr\n         CLC   ASCZEROS(2),5(R2)\n         BE    RBLOCK0 ...\n         LA    R1,1(,R1) incr filename len\n         LA    RF,1(,RF) incr ptr\n         CLC   ASCZEROS(1),5(R2)\n         BE    RBLOCK0 ...\n         LA    R1,1(,R1) incr filename len\n         LA    RF,1(,RF) incr ptr\nRBLOCK0  BCTR  R1,0 ex len\n         LA    RE,DWORD(R1) last valid char\n         EX    R1,RBLOCK0M\n         LR    RE,R2 save ptr to block???? filename for laterusage\n         LR    RF,R2 calc ptr to filename len field\n         SH    RF,=H'4' backtrack\n         LA    R2,6(R1,R2) ptr\n         LA    R1,6(,R1) total file name len\n         STCM  R1,1,0(RF) new len\n         STC   R1,FILENLEN central dir filenamelen\n         LR    RF,R1 save filename len #  for later usage\n         L     R1,DIRPTR start of current saved dir info area\n         USING XDIRMAP,R1\n         MVC   XFILETIM(2),FILETIME\n         MVC   XFILEDTE(2),FILEDATE\n         MVC   XFILENLN(2),FILENLEN\n         MVCIN XFILELFO(4),FILELOFF+3 save total local filehdr offset\n         BCTR  RF,0 for ex of filename\n         EX    RF,SAVEFN ...\n         B     BYPASSFN continue\nMOVUSSFN MVC   PATHNAME(*-*),2(R2) save passed USS filename\nSAVEFN   MVC   XFILEFNC(*-*),0(RE) copy filename from original loc\n         DROP  R1\nBYPASSFN ST    R2,BUFFRPTR\n         ST    R2,COMPRPTR save ptr to start compressed data\n* setup '01'b and '1'b fixed codes; last block\n         LA    R0,3      bit sequence='011'b\n         LA    R1,3      bit count - rightmost 3 bits\n         BAL   RE,BITWRITR ...\n         MVC   CRCCALC,CRCINIT crc pre-process with 'ffffffff'x\n         TM    FLAGS,X'40' block complete loop\n         BZ    LOOP no;normal\n         NI    FLAGS,X'BF' turn off this flag\n         B     LOOP1 use prev gotten rcd which was page #51\nLOOP     GET   INPUT,INAREA\n*SNAP DCB=SNAPDCB,ID=2,STORAGE=(INAREA,INAREA+200)\nLOOP1    CLI   INAREA,C'1' new page??\n         BNE   NOTPAGE no...\n         L     RF,PAGECTR\n         LA    RF,1(,RF) +1\n         ST    RF,PAGECTR\n         C     RF,=F'51' if 51st page then block chunk complete\n         BL    NOTPAGE no, continue\n         XC    PAGECTR,PAGECTR reset page ctr to zero\n         OI    FLAGS,X'40' block finished flag\n         B     EOD      continue writing out this block\nNOTPAGE  LA    R9,INPUT get record's LRECL\n         USING IHADCB,R9\n         LH    R9,DCBLRECL ...\n         DROP  R9\n         LA    RF,INAREA\n         ALR   RF,R9 add cr-lf to os/390 record oriented stream\n         MVI   0(RF),X'15' lf\n         LA    R9,1(,R9) incr input char count\n         MVC   CURROFF,NEXTOFF duplicate string offset\n         L     RF,TOTALCHR increment total uncompressed char count\n         AR    RF,R9 ...\n         ST    RF,TOTALCHR ...\n         ST    RF,NEXTOFF next duplicate string offset\n         BCTR  R9,0 for execute\n         EX    R9,TRASCII perform cp-037 to 8859-1 translation\n         LA    RF,INAREA set of crc input bytes\n         LA    R1,1(,R9) record byte count\n         L     R2,CRCCALC current running crc-32\nCRCLOOP  LR    R3,R2      current running crc-32\n         IC    R3,0(,RF)\n         XR    R3,R2 low byte is used as index into crc table\n         SLL   R3,2 for index\n         SRL   R2,8 shift current crc right 8\n         X     R2,CRC32TAB(R3) xor with table\n         LA    RF,1(,RF) next input crc byte\n         BCT   R1,CRCLOOP ...\n         ST    R2,CRCCALC current running crc-32\n         LA    R3,INAREA locate runs of blanks\n         LA    R4,INAREA2 locate runs of blanks\n         LA    RF,1(,R9) # of bytes to scan\n         L     RE,CURROFF current string offset within file\n         SLR   R2,R2     total# bytes\nLOOPBLK2 MVI   DUPLCHAR,X'20' ascii blank\n         CLC   =X'202020',0(R3) string of min run of 3\n         BE    RUNBLANK yes\n         MVI   DUPLCHAR,X'2D' ascii dash\n         CLC   =X'2D2D2D',0(R3) string of min run of 3\n         BE    RUNBLANK yes\n         MVI   DUPLCHAR,X'2A' ascii asterisk\n         CLC   =X'2A2A2A',0(R3) string of min run of 3\n         BE    RUNBLANK yes\n         MVI   DUPLCHAR,X'3D' ascii equal sign\n         CLC   =X'3D3D3D',0(R3) string of min run of 3\n         BE    RUNBLANK yes\n         MVI   DUPLCHAR,X'30' ascii zero\n         CLC   =X'303030',0(R3) string of min run of 3\n         BE    RUNBLANK yes\n         MVI   DUPLCHAR,X'C4' ascii horiz bar\n         CLC   =X'C4C4C4',0(R3) string of min run of 3\n         BE    RUNBLANK yes\n         MVC   0(1,R4),0(R3) propagate one byte\n         LA    R2,1(,R2) ...\n         LA    R3,1(,R3) ...\n         LA    R4,1(,R4) ...\n         LA    RE,1(,RE) ...\n         BCT   RF,LOOPBLK2 continue\n         B     XCHAR continue\nRUNBLANK MVC   0(2,R4),=X'FEFD' internal code for blank run\n         STCM  RE,15,2(R4) store in output stream\n         LA    R2,6(,R2) ...\n         LA    R4,6(,R4) ...\n         SLR   R1,R1 count of consecutive blanks\n         MVC   LOOPBLK5+1(1),DUPLCHAR ng but easiest-duplicated charac\nLOOPBLK5 CLI   0(R3),X'00' ascii blank or other duplic char\n         BNE   RUNBLNK3 nope\n         LA    R1,1(,R1) continue\n         LA    R3,1(,R3) continue\n         LA    RE,1(,RE) ...\n         BCT   RF,LOOPBLK5 ...\nRUNBLNK3 STC   R1,0(,R4) duplic char count\n         MVC   1(1,R4),DUPLCHAR save duplic char in stream\n         LA    R2,2(,R2) tot # out bytes\n         LA    R4,2(,R4) target position\n         LTR   RF,RF anything left to scan\n         BNZ   LOOPBLK2 yes\nXCHAR    LA    R4,INAREA2 set of input bytes\n         LR    R9,R2 total # bytes to write\n*SNAP DCB=SNAPDCB,ID=3,STORAGE=(INAREA2,INAREA2+200)\nXCHAR2   MVC   DWORD(1),0(R4) acquire a byte\n         NI    FLAGS,X'7F' turn off duplic str reduction processing\n         CLI   DWORD,X'90' is this one an extended char??\n         BNL   XCHAR3 yes\n         C     R9,=F'4' are there 4 bytes to write\n         BNL   XCHAR2K yes, try to speed up processing\nXCHAR2J  TR    DWORD(1),HUFFLLEN convert 1 char\n         SLR   R0,R0 clear\n         IC    R0,DWORD+0 bytes to be written\n         LA    R1,8      bit count\n         BAL   RE,BITWRITR ...\n         LA    R4,1(,R4) input ptr\n         BCT   R9,XCHAR2\n         B     LOOP\nXCHAR2K  CLI   1(R4),X'90' make sure no extended chars in these bytes\n         BNL   XCHAR2J skip optimization\n         CLI   2(R4),X'90' make sure no extended chars in these bytes\n         BNL   XCHAR2J skip optimization\n         CLI   3(R4),X'90' make sure no extended chars in these bytes\n         BNL   XCHAR2J skip optimization\n         MVCIN DWORD(4),3(R4) acquire 4 bytes\n         TR    DWORD(4),HUFFLLEN convert 4 chars\n         ICM   R0,15,DWORD bytes to be written\n         LA    R1,32     bit count\n         BAL   RE,BITWRITR ...\n         LA    R4,4(,R4) input ptr\n         S     R9,=F'3' reduce by chars processed\n         BCT   R9,XCHAR2\n         B     LOOP\nXCHAR3   CLC   =X'FEFD',0(R4) internal blank run code\n         BNE   XCHAR5 no\n         SLR   RE,RE count of blanks or other char\n         IC    RE,6(,R4) ...\n         BCTR  RE,0     indexinto prev blank string table\n         SLL   RE,2 x4\n         L     RF,=A(BLNKDUPL) index into table\n         CLI   7(R4),X'20' ascii blank\n         BE    XCHAR3A continue\n         L     RF,=A(DASHDUPL) index into table\n         CLI   7(R4),X'2D' ascii dash\n         BE    XCHAR3A continue\n         L     RF,=A(STARDUPL) index into table\n         CLI   7(R4),X'2A' ascii asterisk\n         BE    XCHAR3A continue\n         L     RF,=A(ZERODUPL) index into table\n         CLI   7(R4),X'30' ascii zero\n         BE    XCHAR3A continue\n         L     RF,=A(HBARDUPL) index into table\n         CLI   7(R4),X'C4' ascii horiz bar tr from bf to c4\n         BE    XCHAR3A continue\n         L     RF,=A(EQULDUPL) lastone-mustbe = sign\nXCHAR3A  LA    R3,0(RE,RF) calc ptr\n         L     R1,0(,R3) ...\n         LTR   R1,R1 if zero then no prev string with thislen\n         BZ    ADDXSTR\n         ICM   R2,15,2(R4) offset of this blank/etc run string\n         SR    R2,R1 old offset should be within 32768 bytes\n         C     R2,=F'32768' max distance offset\n         BH    ADDXSTR no good, use as if new offset\n         ST    R2,DWORD+12 save backwards distance here\n         ICM   R2,15,2(R4) offset of this blank run string\n         STCM  R2,15,0(R3) new offset into slot closer to where we are\nXCHARX0  L     RF,=A(LENTABLE) get correct LENTABLE entry\n         SLR   RE,RE count of blanks\n         IC    RE,6(,R4) ...\n         ST    RE,DWORD+8  save duplicate string len here\nXCHARX1  LM    R0,R3,0(RF) get whole entry\n         CR    RE,R3 entry maxlen\n         BNH   XCHARX3 continue\n         LA    RF,16(,RF) look at next entry\n         B     XCHARX1 ...\nADDXSTR  ICM   R2,15,2(R4) offset of this blank/etc run string\n         STCM  R2,15,0(R3) new offset into slot\n         SLR   RE,RE count of blanks/etc\n         IC    RE,6(,R4) ...\n         ST    RE,DWORD+16 save ORIGINAL blank/etc count here\nADDXSTR1 CLR   R3,RF loop backwards through blank dupltab forlong str\n         BNH   ADDXSTR2 nothing to match\n         SL    R3,=F'4' backup 1 entry\n         BCTR  RE,0 # consecutive blanks/etc for this entry\n         L     R1,0(,R3) ...\n         LTR   R1,R1 if zero then no prev string with thislen\n         BNZ   ADDXST11 continue\n         CL    RE,=F'2' doublechek- dont handle strlen less than 3\n         BNH   ADDXSTR2 forget this and continue regular way\n         STCM  R2,15,0(R3) new offset into slot - fillin backwards\n         B     ADDXSTR1 ...\nADDXST11 ICM   R2,15,2(R4) offset of this blank run string\n         SR    R2,R1 old offset should be within 32768 bytes\n         C     R2,=F'32768' max distance offset\n         BH    ADDXSTR2 no good, use as if new offset\n         ST    R2,DWORD+12 save backwards distance here\n         STC   RE,6(,R4) store revised lower blank/etc count\n         ST    RE,DWORD+20 max dupl string size to use for this\n         L     R0,DWORD+16 blanks/etc left to do\n         SLR   R0,RE ...\n         ST    R0,DWORD+16 blanks/etc left to do\n         OI    FLAGS,X'80' turn on duplic str reduction\n*SNAP DCB=SNAPDCB,ID=4,STORAGE=(DWORD,DWORD+23)\n         B     XCHARX0 continue processing with smaller duplic str\nADDXSTR2 SLR   R3,R3 count of blanks/etc\n         IC    R3,6(,R4) ...\n         MVC   ADDXSTR3+1(1),7(R4) get duplicate char\nADDXSTR3 MVI   DWORD,X'00' a blank or other char\n         CLI   DWORD,X'90' is this one an extended char??\n         BNL   ADDXSTX3 yes go handle those\n         TR    DWORD(1),HUFFLLEN convert 1 char\n         C     R3,=F'4' is the fillin count greater than 4 now\n         BH    ADDXSTZ3 yes, speed up bit conversion\n         SLR   R0,R0 clear\n         IC    R0,DWORD bytes to be written\n         LA    R1,8      bit count\nADDXSTY3 BAL   RE,BITWRITR ...\nADDXSTY4 BCT   R3,ADDXSTR3 loop for this many blanks\nXCHARX99 LA    R4,8(,R4) input ptr after dupl string declaration\n         SL    R9,=F'8' -declaration count\n         LTR   R9,R9 anymore\n         BNZ   XCHAR2\n         B     LOOP\nADDXSTZ3 MVC   DWORD+1(3),DWORD fillup with translated char\n         ICM   R0,15,DWORD for bit writer\n         LA    R1,32 bit count\n         BAL   RE,BITWRITR ...\n         SL    R3,=F'3' -count filled\n         B     ADDXSTY4 continue\nADDXSTX3 TR    DWORD(1),HUFFLLEN convert 1 char\n         SLR   R0,R0 clear\n         IC    R0,DWORD bytes to be written\n         SLL   R0,1 shift 1 bit to left to append reversed hi bit =1\n         O     R0,=A(X'00000001') add 1 bit for fixed huffman encoding\n         LA    R1,9      bit count\n         B     ADDXSTY3 move back to main loop ...\nXCHARX3  ST    RF,DWORD+4  save LENTABLE entry ptr here\n         LR    RF,R0 save code of 257, 258, etc.\n         L     R3,=A(HUFFLLEN) get huff code for this len\n         ALR   R3,R0 R0 contains code of 257, 258,...\n         MVC   DWORD(1),0(R3) work with this code\n         SLR   R0,R0 clear\n         IC    R0,DWORD bytes to be written\n         CL    RF,=F'280' codes 257-279=7 bits;280-287=8 bits\n         BNL   XCHARX5 use 8 bits\n         LA    R1,7      bit count forlens 257-279\n         SRL   R0,1 remove extraneous hi bit (reversed) for 7 bits\n         BAL   RE,BITWRITR ...\n         B     XCHARX6 ...\nXCHARX5  LA    R1,8 bit count for 280-287\n         BAL   RE,BITWRITR ...\nXCHARX6  L     RF,DWORD+4 restore LENTABLE entry\n         LM    R0,R3,0(RF) get whole entry- R1=extra bits to write\n         LTR   R1,R1 any more bits for length field\n         BZ    XCHARX7 continue\n         L     R3,DWORD+8 calc extra len field value\n         SLR   R3,R2 ...R3 now has correct len for extra bits\n         LR    R0,R3 for bit writer\n         BAL   RE,BITWRITR ...\nXCHARX7  L     RF,=A(DSTTABLE) get correct DSTTABLE entry\n         L     RE,DWORD+12 current distance value\nXCHARX8  LM    R0,R3,0(RF) get whole entry\n         CR    RE,R3 entry maxlen\n         BNH   XCHARX9 continue\n         LA    RF,16(,RF) look at next entry\n         B     XCHARX8 ...\nXCHARX9  ST    RF,DWORD save DSTTABLE entry ptr temporarily\n         LA    R1,5 5 bits to write\n         BAL   RE,BITWRITR R0 has reversed dist code already\n         L     RF,DWORD restore DSTTABLE entry\n         LM    R0,R3,0(RF) get whole entry- R1=extra bits to write\n         LTR   R1,R1 any more bits for dst field\n         BZ    XCHARX98 continue\n         L     R3,DWORD+12 calc extra dst field value\n         SLR   R3,R2 ...R3 now has correct value for extra bits\n         LR    R0,R3 for bit writer\n         BAL   RE,BITWRITR ...\nXCHARX98 TM    FLAGS,X'80' in midst of reduced duplstr processing??\n         BZ    XCHARX99 no ...\n         LM    R0,R1,DWORD+16 blanks/etc left to do;blnk/etc dupl size\n         STC   R0,6(,R4) update counter of blanks/etc to string out\n         B     ADDXSTR2 ...\nXCHAR5   TR    DWORD(1),HUFFLLEN convert 1 char\n         SLR   R0,R0 clear\n         IC    R0,DWORD bytes to be written\n         SLL   R0,1 shift 1 bit to left to append reversed hi bit =1\n         O     R0,=A(X'00000001') add 1 bit for fixed huffman encoding\n         LA    R1,9      bit count\n         BAL   RE,BITWRITR ...\n         LA    R4,1(,R4) input ptr\n         BCT   R9,XCHAR2\n         B     LOOP\nHUFFOI   OI    DWORD,*-*\nHUFFTM   TM    0(R2),*-*\nTRASCII  TR    INAREA(*-*),X0378859\nRBLOCK0M MVCIN 5(*-*,R2),0(RE)\nEOD      L     R2,CRCCALC running crc-32\n         X     R2,CRCINIT zip crc-32 calc ones complement at end\n         ST    R2,CRCCALC current running crc-32\n         SLR   R0,R0 eob = 256 huffman code\n         LA    R1,7 eob  bit count\n         BAL   RE,BITWRITR ...\n         L     RF,BUFFRPTR currently written byte ptr\n         CLC   =F'8',BITCTR whole # bytes written\n         BE    EOD3 yes\n         LA    RF,1(,RF) incr by 1 for partially written byte\n         ST    RF,BUFFRPTR store\nEOD3     LR    R0,RF save temp ptr to last compressed data byte\n         MVC   0(4,RF),DDESCHDR move in data descriptor header sign\n         MVCIN 4(4,RF),CRCCALC+3 move crc-32 result into position\n         MVCIN FILECRC(4),CRCCALC+3 move crc-32 result into position\n         LA    RF,8(,RF) next output spot\n         S     R0,COMPRPTR calc compressed data size\n         ST    R0,COMPRPTR ...\n         MVCIN 0(4,RF),COMPRPTR+3 move compressed count in\n         MVCIN FILECSIZ(4),COMPRPTR+3 move compressed count in\n         LA    RF,4(,RF) next output spot\n         MVCIN 0(4,RF),TOTALCHR+3 move uncompressed count in\n         MVCIN FILEUSIZ(4),TOTALCHR+3 move uncompressed count in\n         LA    RF,4(,RF) next output spot\n         ST    RF,BUFFRPTR store\n         L     R1,DIRPTR start of current saved dir info area\n         USING XDIRMAP,R1\n         MVC   XFILECRC(4),FILECRC\n         MVC   XFILECMP(4),FILECSIZ\n         MVC   XFILEUCP(4),FILEUSIZ\n         SLR   R2,R2 calc offset for next dir entry\n         IC    R2,XFILENLN get filename len for calc\n         LA    R1,22(R2,R1) next spot\n         ST    R1,DIRPTR saved\n         DROP  R1\n         XC    SERVRETV,SERVRETV\n         XC    SERVRETC,SERVRETC\n         XC    SERVREAS,SERVREAS\n         XC    BUFFALET,BUFFALET\n         L     R2,BUFFRBGN output buffer start\n         ST    R2,DATAPTR\n         L     RF,BUFFRPTR calc write len\n         SLR   RF,R2 ...\n         ST    RF,DATAWCTR ...\n         ICM   R0,15,FILELOFF get offset\n         ALR   RF,R0       total zipped file offset for cent dir\n         STCM  RF,15,FILELOFF save ...\n         CALL  BPX1WRT,(FD,                                            X\n               DATAPTR,                                                X\n               BUFFALET,                                               X\n               DATAWCTR,                                               X\n               SERVRETV,                                               X\n               SERVRETC,                                               X\n               SERVREAS),                                              X\n               VL\n         ICM   RF,15,SERVRETV IF -1 THEN ERROR\n         BM    FAIL\n         C     RF,DATAWCTR ALL CHARACTERS WRITTEN\n         BNE   FAIL\n         XC    FILECRC,FILECRC\n         XC    FILECSIZ,FILECSIZ\n         XC    FILEUSIZ,FILEUSIZ\n         TM    FLAGS,X'40' block complete loop\n         BO    NEXTBLK yes, continue\n         L     RF,BUFFRBGN restore to start buffer\n         ST    RF,CENTSPTR store for later usage start central dir\n         ST    RF,BUFFRPTR store for later usage start central dir\n         MVCIN CENTDOFF(4),FILELOFF+3 end central dir ptr to dir start\n         L     RE,DIRSTOR start of saved central dirinfo\n         LH    R3,CENTFCNT count of total# saved cent dir info entries\n         USING XDIRMAP,RE\nFILLCDIR MVC   FILETIME(2),XFILETIM\n         MVC   FILEDATE(2),XFILEDTE\n         MVC   FILECRC(4),XFILECRC\n         MVC   FILECSIZ(4),XFILECMP\n         MVC   FILEUSIZ(4),XFILEUCP\n         MVC   FILENLEN(2),XFILENLN\n         MVC   FILELOFF(4),XFILELFO\n         MVC   0(CENTFHRL,RF),CENTFHDR\n         LA    RF,CENTFHRL(,RF)\n         ST    RF,BUFFRPTR store\n         LA    R1,XFILEFNC ptr to current filename\n         DROP  RE\n         SLR   R2,R2 clear for ex\n         IC    R2,FILENLEN size of current filename\n         BCTR  R2,0 ..\n         EX    R2,MOVECFN move\n         LA    RF,1(R2,RF)\n         ST    RF,BUFFRPTR store\n         LA    RE,23(R2,RE) next saved cent dir info loc\n         BCT   R3,FILLCDIR loop\n         LR    R1,RF calc size of central dir\n         SL    R1,CENTSPTR calc size of central dir\n         ST    R1,DWORD ...\n         MVCIN CENTSIZE(4),DWORD+3 ...\n         ICM   R1,3,CENTFCNT intel reverse file counts\n         STCM  R1,1,CENTFCNT ...\n         STCM  R1,2,CENTFCNT+1 ...\n         MVC   CENTFCN2(2),CENTFCNT ditto\n         MVC   0(ECENTDRL,RF),ECENTDIR move in ending central dir\n         LA    RF,ECENTDRL(,RF) ...\n         ST    RF,BUFFRPTR updated\n         XC    SERVRETV,SERVRETV\n         XC    SERVRETC,SERVRETC\n         XC    SERVREAS,SERVREAS\n         XC    BUFFALET,BUFFALET\n         L     R2,BUFFRBGN output buffer start\n         ST    R2,DATAPTR\n         L     RF,BUFFRPTR calc write len\n         SLR   RF,R2 ...\n         ST    RF,DATAWCTR ...\n         CALL  BPX1WRT,(FD,                                            X\n               DATAPTR,                                                X\n               BUFFALET,                                               X\n               DATAWCTR,                                               X\n               SERVRETV,                                               X\n               SERVRETC,                                               X\n               SERVREAS),                                              X\n               VL\n         ICM   RF,15,SERVRETV IF -1 THEN ERROR\n         BM    FAIL\n         C     RF,DATAWCTR ALL CHARACTERS WRITTEN\n         BNE   FAIL\nTERM     CLOSE (INPUT)\n         FREEPOOL INPUT\n         XC    SERVRETV,SERVRETV\n         XC    SERVRETC,SERVRETC\n         XC    SERVREAS,SERVREAS\n         CALL  BPX1CLO,(FD,                                            X\n               SERVRETV,                                               X\n               SERVRETC,                                               X\n               SERVREAS),                                              X\n               VL\n         ICM   RF,15,SERVRETV IF -1 THEN ERROR\n         BM    FAIL\n         L     R0,=A(768*1024)\n         L     R1,BUFFRBGN\n         STORAGE RELEASE,ADDR=(1),LENGTH=(0) FREE WORKAREA\n         PR    ,\nFAIL     LA    RF,24 error\n         PR    ,\nNOPARM   LA    RF,28 error\n         PR    ,\nMOVECFN  MVC   0(*-*,RF),0(R1) move current filename\nBITWRITR EQU   * * bit serial writer\n* R0-up to 4 bytes data bits 31..30...2..1..0\n* R1-rightmost bit ctr of 1,2,3,...,32\n* RD-work - saved\n* RE-return ptr - saved\n* RF-work\n* ref BITBUCKT storage -  2D'0'; BITCTR - remaining bits to be filled\n         STM   R0,R1,BITBUCKT+0 save some regs\n         STM   RD,RE,BITBUCKT+8 save some regs\n*SNAP DCB=SNAPDCB,ID=1,STORAGE=(BITBUCKT,BITBUCKT+07,BITCTR,BITCTR+3,BU\n*              FFRPTR,BUFFRPTR+3)\n*LM    R0,R1,BITBUCKT+0 save some regs\n*LM    RD,RE,BITBUCKT+8 save some regs\nBITWTRI  L     RE,BUFFRPTR byte to be written loc\n         CLC   =F'8',BITCTR new byte to be written\n         BNE   BITWTR1 no, byte was prev initialized\n         MVI   0(RE),X'00' set new byte allzero bits\nBITWTR1  C     R1,BITCTR compare to be writtn #bits to bitsleftin byte\n         BH    BITWTR2 too many bits to write-use BITCTR\n         LR    RF,R1 use #bits to be written\n         B     BITWTR4 continue\nBITWTR2  L     RF,BITCTR use the most bits that we can fit in byte\nBITWTR4  LR    RD,RF index into mask for # bits to be written\n         BCTR  RD,0 ...\n         SLL   RD,2 x4\n         N     R0,BITMASK1(RD) only bits req for this round left\n         LA    RD,8      calc bit loc in target byte\n         S     RD,BITCTR calc bit loc in target byte\n         SLL   R0,0(RD) position bits to be saved for target byte\n         STC   R0,BITBUCKT+4 place into workarea for usage in OC\n         OC    0(1,RE),BITBUCKT+4 new bits written to output stream\n         SR    R1,RF remaining # of bits left to write for this req\n         L     R0,BITBUCKT+0 restore current bit seq to be written\n         SRL   R0,0(RF) shift off bits already written\n         ST    R0,BITBUCKT+0 save current to be written bits\n         L     R0,BITCTR calc # bits remaining in this target byte\n         SR    R0,RF new total bits left in this target byte\n         BZ    BITWTR7 nothing left\n         ST    R0,BITCTR save new total in storage\n         B     BITWTR9 continue\nBITWTR7  LA    R0,8 reset to 8 bits left in next byte\n         ST    R0,BITCTR save new total in storage\n         LA    RE,1(,RE) next target byte loc\n         ST    RE,BUFFRPTR byte to be written loc\nBITWTR9  L     R0,BITBUCKT+0 current to be written bits\n         LTR   R1,R1 any bits left to be written\n         BNZ   BITWTRI loop\n         LM    RD,RE,BITBUCKT+8 restore used regs\n         BR    RE return\n         LTORG\nSAVEAREA DC    9D'0'\nDWORD    DC    4D'0'\nBITBUCKT DC    2D'0'\nBITCTR   DC    F'8' number bits left to be filled in current byte\nFLAGS    DC    A(*-*) x80=duplic str reduction phase\n*                     x40=block of 50 pages finished\nBITMASK1 DC    X'00000001' mask for bits to be written\n         DC    X'00000003' mask for bits to be written\n         DC    X'00000007' mask for bits to be written\n         DC    X'0000000F' mask for bits to be written\n         DC    X'0000001F' mask for bits to be written\n         DC    X'0000003F' mask for bits to be written\n         DC    X'0000007F' mask for bits to be written\n         DC    X'000000FF' mask for bits to be written\nBUFFRBGN DC    A(*-*)\nBUFFRPTR DC    A(*-*)\nFILENPTR DC    A(*-*) ptr to current filename\nINPUT    DCB   DDNAME=INPUT,DSORG=PS,MACRF=(GM),EODAD=EOD\nPATHNLEN DC    A(*-*) PATH NAME LENGTH\nFILEOPTN DC    AL1(0),AL1(0),AL1(0),AL1(O_CREAT+O_TRUNC+O_WRONLY)\nFILEMODE DC    AL1(FT_REGFILE),AL1(0),AL1(S_IRUSR) +\n         DC    AL1(S_IRWXU2+S_IRWXG+S_IRWXO)\nBUFFALET DC    A(0)\nDATAPTR  DC    A(*-*)\nDATAWCTR DC    A(*-*)\nDIRSTOR  DC    A(*-*) ptr to start temp dir info stor\nDIRPTR   DC    A(*-*) ptr to temp dir info stor\nPAGECTR  DC    F'0' page ctr for each 50 page chunk\nSERVRETV DC    A(0)\nSERVRETC DC    A(0)\nSERVREAS DC    A(0)\nFD       DC    A(0)\nCENTSPTR DC    A(*-*) ptr to start of central dir\nTOTALCHR DC    A(*-*) total file uncompressed char count\nCOMPRPTR DC    A(*-*) beginning of compressed block data\nCRCCALC  DC    A(*-*) calculated crc-32 value\nCURROFF  DC    A(*-*) duplicate string offset\nNEXTOFF  DC    A(*-*) duplicate string offset\nCRCINIT  DC    A(X'FFFFFFFF')\nCRC32TAB EQU   * * crc32 values by byte table\nCRC0     DC    X'00000000'\nCRC1     DC    X'77073096'\nCRC2     DC    X'EE0E612C'\nCRC3     DC    X'990951BA'\nCRC4     DC    X'076DC419'\nCRC5     DC    X'706AF48F'\nCRC6     DC    X'E963A535'\nCRC7     DC    X'9E6495A3'\nCRC8     DC    X'0EDB8832'\nCRC9     DC    X'79DCB8A4'\nCRC10    DC    X'E0D5E91E'\nCRC11    DC    X'97D2D988'\nCRC12    DC    X'09B64C2B'\nCRC13    DC    X'7EB17CBD'\nCRC14    DC    X'E7B82D07'\nCRC15    DC    X'90BF1D91'\nCRC16    DC    X'1DB71064'\nCRC17    DC    X'6AB020F2'\nCRC18    DC    X'F3B97148'\nCRC19    DC    X'84BE41DE'\nCRC20    DC    X'1ADAD47D'\nCRC21    DC    X'6DDDE4EB'\nCRC22    DC    X'F4D4B551'\nCRC23    DC    X'83D385C7'\nCRC24    DC    X'136C9856'\nCRC25    DC    X'646BA8C0'\nCRC26    DC    X'FD62F97A'\nCRC27    DC    X'8A65C9EC'\nCRC28    DC    X'14015C4F'\nCRC29    DC    X'63066CD9'\nCRC30    DC    X'FA0F3D63'\nCRC31    DC    X'8D080DF5'\nCRC32    DC    X'3B6E20C8'\nCRC33    DC    X'4C69105E'\nCRC34    DC    X'D56041E4'\nCRC35    DC    X'A2677172'\nCRC36    DC    X'3C03E4D1'\nCRC37    DC    X'4B04D447'\nCRC38    DC    X'D20D85FD'\nCRC39    DC    X'A50AB56B'\nCRC40    DC    X'35B5A8FA'\nCRC41    DC    X'42B2986C'\nCRC42    DC    X'DBBBC9D6'\nCRC43    DC    X'ACBCF940'\nCRC44    DC    X'32D86CE3'\nCRC45    DC    X'45DF5C75'\nCRC46    DC    X'DCD60DCF'\nCRC47    DC    X'ABD13D59'\nCRC48    DC    X'26D930AC'\nCRC49    DC    X'51DE003A'\nCRC50    DC    X'C8D75180'\nCRC51    DC    X'BFD06116'\nCRC52    DC    X'21B4F4B5'\nCRC53    DC    X'56B3C423'\nCRC54    DC    X'CFBA9599'\nCRC55    DC    X'B8BDA50F'\nCRC56    DC    X'2802B89E'\nCRC57    DC    X'5F058808'\nCRC58    DC    X'C60CD9B2'\nCRC59    DC    X'B10BE924'\nCRC60    DC    X'2F6F7C87'\nCRC61    DC    X'58684C11'\nCRC62    DC    X'C1611DAB'\nCRC63    DC    X'B6662D3D'\nCRC64    DC    X'76DC4190'\nCRC65    DC    X'01DB7106'\nCRC66    DC    X'98D220BC'\nCRC67    DC    X'EFD5102A'\nCRC68    DC    X'71B18589'\nCRC69    DC    X'06B6B51F'\nCRC70    DC    X'9FBFE4A5'\nCRC71    DC    X'E8B8D433'\nCRC72    DC    X'7807C9A2'\nCRC73    DC    X'0F00F934'\nCRC74    DC    X'9609A88E'\nCRC75    DC    X'E10E9818'\nCRC76    DC    X'7F6A0DBB'\nCRC77    DC    X'086D3D2D'\nCRC78    DC    X'91646C97'\nCRC79    DC    X'E6635C01'\nCRC80    DC    X'6B6B51F4'\nCRC81    DC    X'1C6C6162'\nCRC82    DC    X'856530D8'\nCRC83    DC    X'F262004E'\nCRC84    DC    X'6C0695ED'\nCRC85    DC    X'1B01A57B'\nCRC86    DC    X'8208F4C1'\nCRC87    DC    X'F50FC457'\nCRC88    DC    X'65B0D9C6'\nCRC89    DC    X'12B7E950'\nCRC90    DC    X'8BBEB8EA'\nCRC91    DC    X'FCB9887C'\nCRC92    DC    X'62DD1DDF'\nCRC93    DC    X'15DA2D49'\nCRC94    DC    X'8CD37CF3'\nCRC95    DC    X'FBD44C65'\nCRC96    DC    X'4DB26158'\nCRC97    DC    X'3AB551CE'\nCRC98    DC    X'A3BC0074'\nCRC99    DC    X'D4BB30E2'\nCRC100   DC    X'4ADFA541'\nCRC101   DC    X'3DD895D7'\nCRC102   DC    X'A4D1C46D'\nCRC103   DC    X'D3D6F4FB'\nCRC104   DC    X'4369E96A'\nCRC105   DC    X'346ED9FC'\nCRC106   DC    X'AD678846'\nCRC107   DC    X'DA60B8D0'\nCRC108   DC    X'44042D73'\nCRC109   DC    X'33031DE5'\nCRC110   DC    X'AA0A4C5F'\nCRC111   DC    X'DD0D7CC9'\nCRC112   DC    X'5005713C'\nCRC113   DC    X'270241AA'\nCRC114   DC    X'BE0B1010'\nCRC115   DC    X'C90C2086'\nCRC116   DC    X'5768B525'\nCRC117   DC    X'206F85B3'\nCRC118   DC    X'B966D409'\nCRC119   DC    X'CE61E49F'\nCRC120   DC    X'5EDEF90E'\nCRC121   DC    X'29D9C998'\nCRC122   DC    X'B0D09822'\nCRC123   DC    X'C7D7A8B4'\nCRC124   DC    X'59B33D17'\nCRC125   DC    X'2EB40D81'\nCRC126   DC    X'B7BD5C3B'\nCRC127   DC    X'C0BA6CAD'\nCRC128   DC    X'EDB88320'\nCRC129   DC    X'9ABFB3B6'\nCRC130   DC    X'03B6E20C'\nCRC131   DC    X'74B1D29A'\nCRC132   DC    X'EAD54739'\nCRC133   DC    X'9DD277AF'\nCRC134   DC    X'04DB2615'\nCRC135   DC    X'73DC1683'\nCRC136   DC    X'E3630B12'\nCRC137   DC    X'94643B84'\nCRC138   DC    X'0D6D6A3E'\nCRC139   DC    X'7A6A5AA8'\nCRC140   DC    X'E40ECF0B'\nCRC141   DC    X'9309FF9D'\nCRC142   DC    X'0A00AE27'\nCRC143   DC    X'7D079EB1'\nCRC144   DC    X'F00F9344'\nCRC145   DC    X'8708A3D2'\nCRC146   DC    X'1E01F268'\nCRC147   DC    X'6906C2FE'\nCRC148   DC    X'F762575D'\nCRC149   DC    X'806567CB'\nCRC150   DC    X'196C3671'\nCRC151   DC    X'6E6B06E7'\nCRC152   DC    X'FED41B76'\nCRC153   DC    X'89D32BE0'\nCRC154   DC    X'10DA7A5A'\nCRC155   DC    X'67DD4ACC'\nCRC156   DC    X'F9B9DF6F'\nCRC157   DC    X'8EBEEFF9'\nCRC158   DC    X'17B7BE43'\nCRC159   DC    X'60B08ED5'\nCRC160   DC    X'D6D6A3E8'\nCRC161   DC    X'A1D1937E'\nCRC162   DC    X'38D8C2C4'\nCRC163   DC    X'4FDFF252'\nCRC164   DC    X'D1BB67F1'\nCRC165   DC    X'A6BC5767'\nCRC166   DC    X'3FB506DD'\nCRC167   DC    X'48B2364B'\nCRC168   DC    X'D80D2BDA'\nCRC169   DC    X'AF0A1B4C'\nCRC170   DC    X'36034AF6'\nCRC171   DC    X'41047A60'\nCRC172   DC    X'DF60EFC3'\nCRC173   DC    X'A867DF55'\nCRC174   DC    X'316E8EEF'\nCRC175   DC    X'4669BE79'\nCRC176   DC    X'CB61B38C'\nCRC177   DC    X'BC66831A'\nCRC178   DC    X'256FD2A0'\nCRC179   DC    X'5268E236'\nCRC180   DC    X'CC0C7795'\nCRC181   DC    X'BB0B4703'\nCRC182   DC    X'220216B9'\nCRC183   DC    X'5505262F'\nCRC184   DC    X'C5BA3BBE'\nCRC185   DC    X'B2BD0B28'\nCRC186   DC    X'2BB45A92'\nCRC187   DC    X'5CB36A04'\nCRC188   DC    X'C2D7FFA7'\nCRC189   DC    X'B5D0CF31'\nCRC190   DC    X'2CD99E8B'\nCRC191   DC    X'5BDEAE1D'\nCRC192   DC    X'9B64C2B0'\nCRC193   DC    X'EC63F226'\nCRC194   DC    X'756AA39C'\nCRC195   DC    X'026D930A'\nCRC196   DC    X'9C0906A9'\nCRC197   DC    X'EB0E363F'\nCRC198   DC    X'72076785'\nCRC199   DC    X'05005713'\nCRC200   DC    X'95BF4A82'\nCRC201   DC    X'E2B87A14'\nCRC202   DC    X'7BB12BAE'\nCRC203   DC    X'0CB61B38'\nCRC204   DC    X'92D28E9B'\nCRC205   DC    X'E5D5BE0D'\nCRC206   DC    X'7CDCEFB7'\nCRC207   DC    X'0BDBDF21'\nCRC208   DC    X'86D3D2D4'\nCRC209   DC    X'F1D4E242'\nCRC210   DC    X'68DDB3F8'\nCRC211   DC    X'1FDA836E'\nCRC212   DC    X'81BE16CD'\nCRC213   DC    X'F6B9265B'\nCRC214   DC    X'6FB077E1'\nCRC215   DC    X'18B74777'\nCRC216   DC    X'88085AE6'\nCRC217   DC    X'FF0F6A70'\nCRC218   DC    X'66063BCA'\nCRC219   DC    X'11010B5C'\nCRC220   DC    X'8F659EFF'\nCRC221   DC    X'F862AE69'\nCRC222   DC    X'616BFFD3'\nCRC223   DC    X'166CCF45'\nCRC224   DC    X'A00AE278'\nCRC225   DC    X'D70DD2EE'\nCRC226   DC    X'4E048354'\nCRC227   DC    X'3903B3C2'\nCRC228   DC    X'A7672661'\nCRC229   DC    X'D06016F7'\nCRC230   DC    X'4969474D'\nCRC231   DC    X'3E6E77DB'\nCRC232   DC    X'AED16A4A'\nCRC233   DC    X'D9D65ADC'\nCRC234   DC    X'40DF0B66'\nCRC235   DC    X'37D83BF0'\nCRC236   DC    X'A9BCAE53'\nCRC237   DC    X'DEBB9EC5'\nCRC238   DC    X'47B2CF7F'\nCRC239   DC    X'30B5FFE9'\nCRC240   DC    X'BDBDF21C'\nCRC241   DC    X'CABAC28A'\nCRC242   DC    X'53B39330'\nCRC243   DC    X'24B4A3A6'\nCRC244   DC    X'BAD03605'\nCRC245   DC    X'CDD70693'\nCRC246   DC    X'54DE5729'\nCRC247   DC    X'23D967BF'\nCRC248   DC    X'B3667A2E'\nCRC249   DC    X'C4614AB8'\nCRC250   DC    X'5D681B02'\nCRC251   DC    X'2A6F2B94'\nCRC252   DC    X'B40BBE37'\nCRC253   DC    X'C30C8EA1'\nCRC254   DC    X'5A05DF1B'\nCRC255   DC    X'2D02EF8D'\nPATHNAME DC    CL100' '\nDUPLCHAR DC    C' ' duplicate char working on -blnk,-,*,=\nASCZEROS DC    XL6'303030303030'\nLOCLSIGN DC    0F'0',X'504B0304' local file hdr signature\nDDESCHDR DC    X'504B0708' undocumented? data descriptor header\nCENTFHDR EQU   * * central file header\n         DC    X'504B0102' signature\n         DC    X'1400' version\nLOCLFHDR DC    X'1400' extract version\n         DC    X'0800' data descriptor on for crc and sizes\n         DC    X'0800' deflated compression\nFILETIME DC    X'0000' ms-dos time 11-15 hr 5-10 min 0-4 sec/2\nFILEDATE DC    X'0000' ms-dos date 10-15 yr-1980 5-9 mth 0-4 day\nFILECRC  DC    X'00000000' crc-32\nFILECSIZ DC    X'00000000' compressed size\nFILEUSIZ DC    X'00000000' uncompressed size\nFILENLEN DC    X'0000' file name len - blockxxxxxxx\n         DC    X'0000' xtra field len\nLOCLFSIZ EQU   *-LOCLFHDR\n         DC    X'0000' file comment len\n         DC    X'0000' disk# start\n         DC    X'0000' internal file attributes\n         DC    X'00000000' external file attributes\nFILELOFF DC    X'00000000' relative offset of local file hdr\nCENTFHRL EQU   *-CENTFHDR end central file header length\nECENTDIR DC    X'504B0506' end central directory\n         DC    X'0000' disk#\n         DC    X'0000' central directory disk#\nCENTFCNT DC    X'0000' zip entries - file count\nCENTFCN2 DC    X'0000' zip entries - file count ditto\nCENTSIZE DC    X'00000000' central dir size excl end dir record\nCENTDOFF DC    X'00000000' central dir start offset\n         DC    X'0000' zip comment len\nECENTDRL EQU   *-ECENTDIR end central directory length\nX0378859 EQU   * * CEE.SCEEGXLT(EDCUEAI1)\n         DC    X'00' <NUL>\n         DC    X'01' <SOH>\n         DC    X'02' <STX>\n         DC    X'03' <ETX>\n         DC    X'9C' <SEL>\n         DC    X'09' <TAB>\n         DC    X'86' <RNL>\n         DC    X'7F' <DEL>\n         DC    X'97' <GE>\n         DC    X'8D' <SPS>\n         DC    X'8E' <RPT>\n         DC    X'0B' <VERTICAL-TAB>\n         DC    X'0C' <FORM-FEED>\n         DC    X'0D' <CARRIAGE-RETURN>\n         DC    X'0E' <SO>\n         DC    X'0F' <SI>\n         DC    X'10' <DLE>\n         DC    X'11' <DC1>\n         DC    X'12' <DC2>\n         DC    X'13' <DC3>\n         DC    X'9D' <RES>\n         DC    X'0A' <NEWLINE>\n         DC    X'08' <BACKSPACE>\n         DC    X'87' <POC>\n         DC    X'18' <CAN>\n         DC    X'19' <EM>\n         DC    X'92' <UBS>\n         DC    X'8F' <CU1>\n         DC    X'1C' <IFS>\n         DC    X'1D' <IGS>\n         DC    X'1E' <IRS>\n         DC    X'1F' <IUS>\n         DC    X'80' <DS>\n         DC    X'81' <SOS>\n         DC    X'82' <FS>\n         DC    X'83' <WUS>\n         DC    X'84' <BYP>\n         DC    X'85' <LF>\n         DC    X'17' <ETB>\n         DC    X'1B' <ESC>\n         DC    X'88' <SA>\n         DC    X'89' <SFE>\n         DC    X'8A' <SM>\n         DC    X'8B' <CSP>\n         DC    X'8C' <MFA>\n         DC    X'05' <ENQ>\n         DC    X'06' <ACK>\n         DC    X'07' <ALERT>\n         DC    X'90'\n         DC    X'91'\n         DC    X'16' <SYN>\n         DC    X'93' <IR>\n         DC    X'94' <PP>\n         DC    X'95' <TRN>\n         DC    X'96' <NBS>\n         DC    X'04' <EOT>\n         DC    X'98' <SBS>\n         DC    X'99' <IT>\n         DC    X'9A' <RFF>\n         DC    X'9B' <CU3>\n         DC    X'14' <DC4>\n         DC    X'15' <NAK>\n         DC    X'9E'\n         DC    X'1A' <SUB>\n         DC    X'20' <SPACE>\n         DC    X'A0' <RSP>\n         DC    X'E2' <A-CIRCUMFLEX>\n         DC    X'E4' <A-DIAERESIS>\n         DC    X'E0' <A-GRAVE>\n         DC    X'E1' <A-ACUTE>\n         DC    X'E3' <A-TILDE>\n         DC    X'E5' <A-RING>\n         DC    X'E7' <C-CEDILLA>\n         DC    X'F1' <N-TILDE>\n         DC    X'A2' <CENT>\n         DC    X'2E' <PERIOD>\n         DC    X'3C' <LESS-THAN-SIGN>\n         DC    X'28' <LEFT-PARENTHESIS>\n         DC    X'2B' <PLUS-SIGN>\n         DC    X'7C' <VERTICAL-LINE>\n         DC    X'26' <AMPERSAND>\n         DC    X'E9' <E-ACUTE>\n         DC    X'EA' <E-CIRCUMFLEX>\n         DC    X'EB' <E-DIAERESIS>\n         DC    X'E8' <E-GRAVE>\n         DC    X'ED' <I-ACUTE>\n         DC    X'EE' <I-CIRCUMFLEX>\n         DC    X'EF' <I-DIAERESIS>\n         DC    X'EC' <I-GRAVE>\n         DC    X'DF' <S-SHARP>\n         DC    X'21' <EXCLAMATION-MARK>\n         DC    X'24' <DOLLAR-SIGN>\n         DC    X'2A' <ASTERISK>\n         DC    X'29' <RIGHT-PARENTHESIS>\n         DC    X'3B' <SEMICOLON>\n         DC    X'AC' <NOT>\n         DC    X'2D' <HYPHEN>\n         DC    X'2F' <SLASH>\n         DC    X'C2' <A-CIRCUMFLEX>\n         DC    X'C4' <A-DIAERESIS>\n         DC    X'C0' <A-GRAVE>\n         DC    X'C1' <A-ACUTE>\n         DC    X'C3' <A-TILDE>\n         DC    X'C5' <A-RING>\n         DC    X'C7' <C-CEDILLA>\n         DC    X'D1' <N-TILDE>\n         DC    X'A6' <BROKEN-BAR>\n         DC    X'2C' <COMMA>\n         DC    X'25' <PERCENT-SIGN>\n         DC    X'5F' <UNDERSCORE>\n         DC    X'3E' <GREATER-THAN-SIGN>\n         DC    X'3F' <QUESTION-MARK>\n         DC    X'F8' <O-SLASH>\n         DC    X'C9' <E-ACUTE>\n         DC    X'CA' <E-CIRCUMFLEX>\n         DC    X'CB' <E-DIAERESIS>\n         DC    X'C8' <E-GRAVE>\n         DC    X'CD' <I-ACUTE>\n         DC    X'CE' <I-CIRCUMFLEX>\n         DC    X'CF' <I-DIAERESIS>\n         DC    X'CC' <I-GRAVE>\n         DC    X'60' <GRAVE-ACCENT>\n         DC    X'3A' <COLON>\n         DC    X'23' <NUMBER-SIGN>\n         DC    X'40' <COMMERCIAL-AT>\n         DC    X'27' <APOSTROPHE>\n         DC    X'3D' <EQUALS-SIGN>\n         DC    X'22' <QUOTATION-MARK>\n         DC    X'D8' <O-SLASH>\n         DC    X'61' <A>\n         DC    X'62' <B>\n         DC    X'63' <C>\n         DC    X'64' <D>\n         DC    X'65' <E>\n         DC    X'66' <F>\n         DC    X'67' <G>\n         DC    X'68' <H>\n         DC    X'69' <I>\n         DC    X'AB' <LEFT-ANGLE-QUOTES>\n         DC    X'BB' <RIGHT-ANGLE-QUOTES>\n         DC    X'F0' <ETH>\n         DC    X'FD' <Y-ACUTE>\n         DC    X'FE' <THORN>\n         DC    X'B1' <PLUS-MINUS>\n         DC    X'B0' <DEGREE>\n         DC    X'6A' <J>\n         DC    X'6B' <K>\n         DC    X'6C' <L>\n         DC    X'6D' <M>\n         DC    X'6E' <N>\n         DC    X'6F' <O>\n         DC    X'70' <P>\n         DC    X'71' <Q>\n         DC    X'72' <R>\n         DC    X'AA' <FEMININE>\n         DC    X'BA' <MASCULINE>\n         DC    X'E6' <AE>\n         DC    X'B8' <CEDILLA>\n         DC    X'C6' <AE>\n         DC    X'A4' <CURRENCY>\n         DC    X'B5' <MU>\n         DC    X'7E' <TILDE>\n         DC    X'73' <S>\n         DC    X'74' <T>\n         DC    X'75' <U>\n         DC    X'76' <V>\n         DC    X'77' <W>\n         DC    X'78' <X>\n         DC    X'79' <Y>\n         DC    X'7A' <Z>\n         DC    X'A1' <EXCLAMATION-DOWN>\n*xAB     DC    X'BF' <QUESTION-DOWN> IBM replace lower left brack xasc\n         DC    X'C0' lower left corner bracket xascii\n*xAC     DC    X'D0' <ETH> IBM replace with upper left brack xascii\n         DC    X'DA' upper left corner bracket\n*xAD     DC    X'DD' <Y-ACUTE> IBM replace with x'5b' left sq brack\n         DC    X'5B' <LEFT-SQUARE-BRACKET>\n         DC    X'DE' <THORN>\n         DC    X'AE' <REGISTERED>\n         DC    X'5E' <CIRCUMFLEX>\n         DC    X'A3' <STERLING>\n         DC    X'A5' <YEN>\n         DC    X'B7' <DOT>\n         DC    X'A9' <COPYRIGHT>\n         DC    X'A7' <SECTION>\n         DC    X'B6' <PARAGRAPH>\n         DC    X'BC' <ONE-QUARTER>\n         DC    X'BD' <ONE-HALF>\n         DC    X'BE' <THREE-QUARTERS>\n         DC    X'5B' <LEFT-SQUARE-BRACKET>\n*xBB     DC    X'5D' <RIGHT-SQUARE-BRACKET> IBM low rt bracket xasc\n         DC    X'D9' lower right corner bracket xascii\n*xBC     DC    X'AF' <MACRON> IBM replace w/ upper rt corner brack xas\n         DC    X'BF' upper right corner bracket xascii\n*xBD     DC    X'A8' <DIAERESIS> IBM replace with x'5d' right sq brack\n         DC    X'5D' <RIGHT-SQUARE-BRACKET>\n         DC    X'B4' <ACUTE>\n*xBF     DC    X'D7' <MULTIPLY> IBM replace with x'C4' horiz bar xasc\n         DC    X'C4' horizontal bar\n         DC    X'7B' <LEFT-BRACE>\n         DC    X'41' <A>\n         DC    X'42' <B>\n         DC    X'43' <C>\n         DC    X'44' <D>\n         DC    X'45' <E>\n         DC    X'46' <F>\n         DC    X'47' <G>\n         DC    X'48' <H>\n         DC    X'49' <I>\n         DC    X'AD' <SYLLABLE-HYPHEN>\n         DC    X'F4' <O-CIRCUMFLEX>\n         DC    X'F6' <O-DIAERESIS>\n         DC    X'F2' <O-GRAVE>\n         DC    X'F3' <O-ACUTE>\n         DC    X'F5' <O-TILDE>\n         DC    X'7D' <RIGHT-BRACE>\n         DC    X'4A' <J>\n         DC    X'4B' <K>\n         DC    X'4C' <L>\n         DC    X'4D' <M>\n         DC    X'4E' <N>\n         DC    X'4F' <O>\n         DC    X'50' <P>\n         DC    X'51' <Q>\n         DC    X'52' <R>\n         DC    X'B9' <ONE-SUPERIOR>\n         DC    X'FB' <U-CIRCUMFLEX>\n         DC    X'FC' <U-DIAERESIS>\n         DC    X'F9' <U-GRAVE>\n         DC    X'FA' <U-ACUTE>\n         DC    X'FF' <Y-DIAERESIS>\n         DC    X'5C' <BACKSLASH>\n         DC    X'F7' <DIVIDE>\n         DC    X'53' <S>\n         DC    X'54' <T>\n         DC    X'55' <U>\n         DC    X'56' <V>\n         DC    X'57' <W>\n         DC    X'58' <X>\n         DC    X'59' <Y>\n         DC    X'5A' <Z>\n         DC    X'B2' <TWO-SUPERIOR>\n         DC    X'D4' <O-CIRCUMFLEX>\n         DC    X'D6' <O-DIAERESIS>\n         DC    X'D2' <O-GRAVE>\n         DC    X'D3' <O-ACUTE>\n         DC    X'D5' <O-TILDE>\n         DC    X'30' <ZERO>\n         DC    X'31' <ONE>\n         DC    X'32' <TWO>\n         DC    X'33' <THREE>\n         DC    X'34' <FOUR>\n         DC    X'35' <FIVE>\n         DC    X'36' <SIX>\n         DC    X'37' <SEVEN>\n         DC    X'38' <EIGHT>\n         DC    X'39' <NINE>\n         DC    X'B3' <THREE-SUPERIOR>\n         DC    X'DB' <U-CIRCUMFLEX>\n         DC    X'DC' <U-DIAERESIS>\n         DC    X'D9' <U-GRAVE>\n         DC    X'DA' <U-ACUTE>\n         DC    X'9F' <EO>\nCNVBIN   DC    X'00010203040506070809000000000000'\n         DC    X'0A0B0C0D0E0F10111213000000000000'\n         DC    X'1415161718191A1B1C1D000000000000'\n         DC    X'1E1F2021222324252627000000000000'\n         DC    X'28292A2B2C2D2E2F3031000000000000'\n         DC    X'32333435363738393A3B000000000000'\n         DC    X'3C3D3E3F404142434445000000000000'\nHUFFLLEN DC    288AL1(*-*) fixed huffman codes literal/len table\n* 000-143 8 bits codes 00110000-10111111\n* 144-255 9 bits codes 110010000-111111111 built table missing leftbit\n* 256-279 7 bits codes 0000000-0010111\n* 280-287 8 bits codes 11000000-11000111\nLENTABLE DC    A(257,0,3,3) code, xtrabits, minlen, maxlen\n         DC    AL4(258,0,4,4) code, xtrabits, minlen, maxlen\n         DC    AL4(259,0,5,5) code, xtrabits, minlen, maxlen\n         DC    AL4(260,0,6,6) code, xtrabits, minlen, maxlen\n         DC    AL4(261,0,7,7) code, xtrabits, minlen, maxlen\n         DC    AL4(262,0,8,8) code, xtrabits, minlen, maxlen\n         DC    AL4(263,0,9,9) code, xtrabits, minlen, maxlen\n         DC    AL4(264,0,10,10) code, xtrabits, minlen, maxlen\n         DC    AL4(265,1,11,12) code, xtrabits, minlen, maxlen\n         DC    AL4(266,1,13,14) code, xtrabits, minlen, maxlen\n         DC    AL4(267,1,15,16) code, xtrabits, minlen, maxlen\n         DC    AL4(268,1,17,18) code, xtrabits, minlen, maxlen\n         DC    AL4(269,2,19,22) code, xtrabits, minlen, maxlen\n         DC    AL4(270,2,23,26) code, xtrabits, minlen, maxlen\n         DC    AL4(271,2,27,30) code, xtrabits, minlen, maxlen\n         DC    AL4(272,2,31,34) code, xtrabits, minlen, maxlen\n         DC    AL4(273,3,35,42) code, xtrabits, minlen, maxlen\n         DC    AL4(274,3,43,50) code, xtrabits, minlen, maxlen\n         DC    AL4(275,3,51,58) code, xtrabits, minlen, maxlen\n         DC    AL4(276,3,59,66) code, xtrabits, minlen, maxlen\n         DC    AL4(277,4,67,82) code, xtrabits, minlen, maxlen\n         DC    AL4(278,4,83,98) code, xtrabits, minlen, maxlen\n         DC    AL4(279,4,99,114) code, xtrabits, minlen, maxlen\n         DC    AL4(280,4,115,130) code, xtrabits, minlen, maxlen\n         DC    AL4(281,5,131,162) code, xtrabits, minlen, maxlen\n         DC    AL4(282,5,163,194) code, xtrabits, minlen, maxlen\n         DC    AL4(283,5,195,226) code, xtrabits, minlen, maxlen\n         DC    AL4(284,5,227,257) code, xtrabits, minlen, maxlen\n         DC    AL4(285,0,258,258) code, xtrabits, minlen, maxlen\n* 5 bit distance codes 0-29 with 5 bits in reversed order\nDSTTABLE DC    AL4(0,0,1,1) code, xtrabits, mindist, maxdist\n         DC    AL4(16,0,2,2) code, xtrabits, mindist, maxdist\n         DC    AL4(8,0,3,3) code, xtrabits, mindist, maxdist\n         DC    AL4(24,0,4,4) code, xtrabits, mindist, maxdist\n         DC    AL4(4,1,5,6) code, xtrabits, mindist, maxdist\n         DC    AL4(20,1,7,8) code, xtrabits, mindist, maxdist\n         DC    AL4(12,2,9,12) code, xtrabits, mindist, maxdist\n         DC    AL4(28,2,13,16) code, xtrabits, mindist, maxdist\n         DC    AL4(2,3,17,24) code, xtrabits, mindist, maxdist\n         DC    AL4(18,3,25,32) code, xtrabits, mindist, maxdist\n         DC    AL4(10,4,33,48) code, xtrabits, mindist, maxdist\n         DC    AL4(26,4,49,64) code, xtrabits, mindist, maxdist\n         DC    AL4(6,5,65,96) code, xtrabits, mindist, maxdist\n         DC    AL4(22,5,97,128) code, xtrabits, mindist, maxdist\n         DC    AL4(14,6,129,192) code, xtrabits, mindist, maxdist\n         DC    AL4(30,6,193,256) code, xtrabits, mindist, maxdist\n         DC    AL4(1,7,257,384) code, xtrabits, mindist, maxdist\n         DC    AL4(17,7,385,512) code, xtrabits, mindist, maxdist\n         DC    AL4(9,8,513,768) code, xtrabits, mindist, maxdist\n         DC    AL4(25,8,769,1024) code, xtrabits, mindist, maxdist\n         DC    AL4(5,9,1025,1536) code, xtrabits, mindist, maxdist\n         DC    AL4(21,9,1537,2048) code, xtrabits, mindist, maxdist\n         DC    AL4(13,10,2049,3072) code, xtrabits, mindist, maxdist\n         DC    AL4(29,10,3073,4096) code, xtrabits, mindist, maxdist\n         DC    AL4(3,11,4097,6144) code, xtrabits, mindist, maxdist\n         DC    AL4(19,11,6145,8192) code, xtrabits, mindist, maxdist\n         DC    AL4(11,12,8193,12288) code, xtrabits, mindist, maxdist\n         DC    AL4(27,12,12289,16384) code, xtrabits, mindist, maxdist\n         DC    AL4(7,13,16385,24576) code, xtrabits, mindist, maxdist\n         DC    AL4(23,13,24577,32768) code, xtrabits, mindist, maxdist\nINAREA   DS    258C' ' report input area\nINAREA2  DS    1024C' ' report input area with duplicate strings\nBLNKDUPL DC    258A(*-*) offsets to last blank dupl with specified len\nDASHDUPL DC    258A(*-*) offsets to last dash  dupl with specified len\nSTARDUPL DC    258A(*-*) offsets to last star  dupl with specified len\nEQULDUPL DC    258A(*-*) offsets to last =     dupl with specified len\nZERODUPL DC    258A(*-*) offsets to last zero  dupl with specified len\nHBARDUPL DC    258A(*-*) offsets to last horzbar xbf-->xc4\n*NAPDCB DCB DDNAME=SNAP,RECFM=VBA,MACRF=(W),LRECL=125,BLKSIZE=1632,    X\n               DSORG=PS\n         BPXYOPNF\n         BPXYFTYP\n         BPXYMODE\n         PRINT NOGEN\n         DCBD  DSORG=PS\nXDIRMAP  DSECT ,\nXFILETIM DS    2X file time\nXFILEDTE DS    2X file date\nXFILECRC DS    4X file crc-32\nXFILECMP DS    4X compressed size\nXFILEUCP DS    4X uncompressed size\nXFILELFO DS    4X local file hdr offset\nXFILENLN DS    2X file name len\nXFILEFNC DS    0X variable file name\n         END\n/*\n//L.SYSLIB   DD  DSN=SYS1.CSSLIB,DISP=SHR <== required\n//L.SYSLMOD  DD  DSN=xxxxxxxxxxxxx.LOADLIB(ZIPPER),DISP=SHR\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT572/FILE572.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT572", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}