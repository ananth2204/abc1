{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012437000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 176358, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 8, "INMDSNAM": "CBT.V500.FILE602.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE602.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x04\\x04'", "DS1TRBAL": "b'\\xaaD'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04f\\x00\\x0b\\x04g\\x00\\x00\\x00\\x05'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x046\\x00\\x00\\x01\\x022\\x1f\\x01\\x022\\x1f\\x00\\x06\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf5\\xf4@@@'", "ispf": {"version": "04.54", "flags": 0, "createdate": "2002-11-17T00:00:00", "modifydate": "2002-11-17T00:06:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-454"}, "text": "REGULAR CBT TAPE - VERSION 454    FILE:  602\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT454.FILE602\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 12 MEMBERS COUNTED; CUMULATIVE SIZE IS 1,262 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   11/17/02    00:06:11    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00 \\x01\\x021o\\x01\\x022\\x0f!Y\\x00\\x1e\\x00\\x1e\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-16T21:59:20", "lines": 30, "newlines": 30, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject: A contribution to the CBT Tape\nDate: Tue, 12 Nov 2002 14:07:09 -0500\nFrom: \"Mike Newell\"\nTo: <sbgolob@attglobal.net>,\n     <sbgolob@aol.com>\n\nMr. Golob:\n\nThe attached .ZIP file contains a binary TSO TRANSMIT format\nfile, and this TSO file contains a couple of REXX execs and their\nassociated ISPF panels and documentation.\n\nThe two REXX execs are called PUT and LSPCR.\n\nPUT is an edit macro which lets you PUT lines from a dataset or\npds member that you are edting into another dataset or PDS\nmember. I used to do a lot of work on VM/CMS, and made good use\nof the CMS PUT command, so I decided to create a version for\nISPF.\n\nLSPCR is a REXX exec that executes the TSO LSPACE command and\ndisplays the output in a scrollable panel. You can sort the panel\ndisplay on one of several fields. The scrollable panel is a lot\neasier to read than the output from the TSO command.\n\nThank you,\n\nMike Newell\nAustin, TX\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE1": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x022\\x0f\\x01\\x022\\x0f#X\\x00\\x13\\x00\\x13\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-16T00:00:00", "modifydate": "2002-11-16T23:58:57", "lines": 19, "newlines": 19, "modlines": 0, "user": "SBGOLOB"}, "text": "In order for the LSPCR exec to work, you need to have the load module\nfor LSPACE (alias LSPC) installed.  Source code for this program can\nbe found on the CBT Tape collection, File 136.  A load library in\nXMIT format for the LSPC TSO command, is conveniently placed in this\nfile, as member LSPC.\n\nIn order to create the load library which contains the LSPACE TSO\ncommand, which can then be copied to the TSO-accessible load library\nof your choice, you need merely execute a TSO RECEIVE command against\nthe LSPC member of this pds, as follows:\n\n    RECEIVE INDS(userid.FILE602.PDS(LSPC))\n\nand answer the prompts by pressing enter, or overriding with the\nDSN(new.dsname) or VOL(yourvl) parameters.\n\nBy default, the new load library name will be:  yourid.LSPACE.LOADLIB\nand will contain members LSPACE and its alias LSPC.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$DOC": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00V\\x01\\x021o\\x01\\x021o\\x12R\\x00\\x15\\x00\\r\\x00\\x00\\xc3\\xc2\\xe3\\xe3\\xc1\\xd7\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T12:52:56", "lines": 21, "newlines": 13, "modlines": 0, "user": "CBTTAPE"}, "text": "--------------------Doc files--------------------------------\n\n$LSPCR    LSPCR exec documentation\n$PUT      PUT edit macro documentation\n\n--------------------REXX execs-------------------------------\n\nLSPCR     The LSPCR exec\nPUT       The PUT edit macro\n\nCopy these execs to a CLIST or REXX library that is allocated to your\nTSO session. See the members beginning with $ for documentation on each\nindividual exec.\n\n--------------------ISPF Panels------------------------------\n\nLSPCPNL   The main panel for REXX exec LSPCR\nLSPCPNLH  The help panel for REXX exec LSPCR\n\nCopy these panels to a panel library that is allocated to your TSO\nsession.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$LSPCR": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00E\\x01\\x021o\\x01\\x021o\\x123\\x008\\x00(\\x00\\x00\\xc3\\xc2\\xe3\\xe3\\xc1\\xd7\\xc5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-11-12T00:00:00", "modifydate": "2002-11-12T12:33:45", "lines": 56, "newlines": 40, "modlines": 0, "user": "CBTTAPE"}, "text": "                             REXX Exec LSPCR\n\n\n\nInstallation\n============\n\nCopy the LSPCR exec to a CLIST or REXX library that is allocated to\nyour TSO session.\n\nCopy panels LSPCPNL and LSPCPNLH to a panel library that is allocated\nto your TSO session.\n\n\n\nUsage\n======\n\nThe LSPCR exec executes the TSO command LSPACE and presents the results\nin a scrollable panel.\n\nTo invoke the exec just enter TSO LSPCR on an ISPF command line. If you\ndo not enter any volume serial numbers with the command you'll see\noutput for all DASD volumes.\n\nYou can also enter:\n    TSO LSPCR volser1 volser2 volser3 volser4 volser5 volser6\n\nWhere VOLSER1 through VOLSER6 are full or partial volume serial nubmers.\nYou can enter from one to six volumer serial numbers with the command.\n\nWhen the LSPCR panel is displayed you can sort the display. Under the\nheading of each column is a number. You can sort the display in\nascending or descending order by giving the column number and then\n'A' or 'D'.\n\nTo sort the display in ascending order of free cylinders, enter\nSORT 2 A in the ISPF command line. To sort the display in descending\norder of VOLSER, enter SORT 1 D in the command line.\n\nIt is important to note that the sorts are only done within volume\nserial groups.\n\nFor instance, if you have volumes listed that start with the letter\n'B', and another set of volumes listed that start with the letter 'S',\nthe 'B' volumes will always appear before the 'S' volumes. It is within\nthe group of 'B' volumes and within the group of 'S' volumes that the\nsorts will occur.\n\nWhen you press PF3 or PF4 to exit the exec, the current volume serial\nlist is saved. The next time you use the EXEC, if you just enter the\ncommand without any parameters, the previous list of volumes will be\ndisplayed. You won't have to re-enter them.\n\nPressing the PF1 key while the exec is active will display a detailed\nhelp panel for using the exec.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$PUT": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x003\\x01\\x021\\x1f\\x01\\x021o\\x121\\x00\\xaa\\x00\\x91\\x00\\x00\\xc3\\xc2\\xe3\\xe3\\xc1\\xd7\\xc5@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2002-11-07T00:00:00", "modifydate": "2002-11-12T12:31:33", "lines": 170, "newlines": 145, "modlines": 0, "user": "CBTTAPE"}, "text": "                             Edit Macro PUT\n\n\n\nInstallation\n============\n\nJust copy the PUT exec to a CLIST or REXX library that is allocated\nto your TSO session. There are no other execs or panels required.\n\n\n\nUsage\n=====\n\nUse the PUT edit macro to paste lines from the dataset or pds member\ncurrently being edited into another dataset or pds member.\n\nYou can specify the lines to be copied either by entering them with the\nmacro invocation, or by using the C, CC, M, or MM line commands.\n\nIf the pds member you specify does not exist, it will be created and the\nlines will be pasted into the new member.\n\nIf the target pds member is in the same pds as the source member, you\ncan specify just the member name instead of having to enter the dataset\nand member names. To tell the macro that the target name is a pds member\nand not a dataset name, put a hyphen (-) immediately before the member\nname.\n\nThere are two formats of the command. The first format is used when\nyou want to specify the lines to be copied when you enter the command.\n\nFORMAT: PUT firstline lastline datasetname targetline\n\n        where: firstline is the first line to be copied\n\n               lastline  is the last  line to be copied\n\n               datasetname is the name of the dataset or pds member\n               to copy the lines into\n\n               targetline is the line in the target dataset AFTER\n               which the new lines will be pasted.\n\n\n        EXAMPLES:\n\n\n        PUT 1 10 my.dataset 50\n\n        will copy lines 1 through 10 of the current dataset or member\n        into my.dataset, and will paste them in afte line 10 of\n        my.dataset\n\n\n        PUT 20 50 my.pds(pdsmbr) 100\n\n        will copy lines 20 through 50 of the current dataset or member\n        into member PDSMBR of my.pds, and will paste them in after line\n        100 of PDSMBR.\n\n\n        PUT 20 50 my.pds(pdsmbr) 0\n\n        will paste lines 20 through 50 of the current dataset or member\n        into the beginning of PDSMBR, before the first line of the\n        member.\n\n        If the pds member you want to paste lines to is in the same pds\n        as the member you're editing, you can specify just the member\n        name in the command.\n\n\n        PUT 1 10 -xyz 5\n\n        will paste lines 1 through 10 of the current member into member\n        XYZ, after line 5 of XYZ.\n\n\n        PUT 20 50 -xyz 0\n\n        will paste lines 20 through 50 of the current member into member\n        XYZ, at the beginning of XYZ before line 1.\n\n\nThe second format of the command allows you to use the C and CC, and the\nM and MM line commands to specify the lines to be copied.\n\nIn this format of the command you only enter the target dsn or member\nname and the target line number. You specify the lines to be copied by\nputting a C or CC, or an M or MM in the line command fields, like you do\nwith any other copy or paste command.\n\nIf you use C or CC, the lines are copied to the target dataset.\n\nIF you use M or MM, the lines are copied to the target dataset then\ndeleted from the source dataset.\n\n\nFORMAT: PUT datasetname targetline\n\n        where: datasetname is the name of the dataset or pds member\n               to copy the lines into\n\n               targetline is the line in the target dataset AFTER\n               which the new lines will be pasted\n\n        All the other rules specified for the first format of the\n        command apply.\n\n\n        EXAMPLES:\n\n\n        PUT my.dataset 10\n\n        to copy a line or range of lines into my.dataset after line 10.\n\n\n        PUT my.pds(pdsmbr) 50\n\n        to copy a line or range of lines into member PDSMBR of my.pds\n        after line 50 of PDSMBR.\n\n\n        PUT -pdsmbr 25\n\n        to copy a line or range of lines into member PDSMBR after line\n        25. The use of the hyphen before the membername says that PDSMBR\n        is a member of the same pds as the member currently being\n        edited.\n\n\n        PUT -pdsmbr 0\n\n        to copy a line or range of lines into member PDSMBR. The lines\n        will be pasted into the beginning of PDSMBR, before line 1.\n\n\nRegardless of the format of the command the following rules apply:\n\nIf you use the first format of the command and you only want to copy\none line to the target dataset or member, just make the values for\nfirstline and lastline the same, like this: PUT 2 2 my.dataset 10\n\nIf the target is a pds member and it does not exist it will be created.\nIn the case of a new pds member, it doesn't matter what the value of\ntargetline is, as long as it's numeric.\n\nIF the target dataset is a pds, and you enter just the dataset name\n(my.pds) instead of the dataset and member name (my.pds(mymember))\na member listing of the pds will be displayed. Just use the SELECT line\ncommand to select which member the lines of data are to be pasted into.\n\nIf the number specified for lastline is greater than the number of lines\nin the source dataset or member, the whole dataset or member will be\ncopied.\n\nIf the number specified for targetline is greater than the number of\nlines in the target dataset or member, the new lines will be pasted in\nat the end of the target dataset or member.\n\nIf the number specified for targetline is 0, the new lines will be\npasted in at the beginning of the target dataset or member, before the\nfirst line.\n\nIf the lines being copied are longer than the daaset or member they\nare being pasted into, a message will be issued that warns of possible\ndata truncation.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE602": {"ttr": 530, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x04\\x01\\x020/\\x01\\x022\\x1f\\x00\\x04\\x00!\\x00\\x02\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2002-10-29T00:00:00", "modifydate": "2002-11-17T00:04:04", "lines": 33, "newlines": 2, "modlines": 0, "user": "SBGOLOB"}, "text": "//***FILE 602 is from Mike Newell and contains two REXX execs and   *   FILE 602\n//*           accompanying panels for one of them.  The two         *   FILE 602\n//*           applications are called LSPCR and PUT.                *   FILE 602\n//*                                                                 *   FILE 602\n//*           email:  sbgolob.attglobal.net  (for questions)        *   FILE 602\n//*                                                                 *   FILE 602\n//*      This file consists of a pds which contains a couple of     *   FILE 602\n//*      REXX execs and their associated ISPF panels and            *   FILE 602\n//*      documentation.                                             *   FILE 602\n//*                                                                 *   FILE 602\n//*      The two REXX execs are called PUT and LSPCR.               *   FILE 602\n//*                                                                 *   FILE 602\n//*      PUT is an edit macro which lets you PUT lines from a       *   FILE 602\n//*      dataset or pds member that you are editing into another    *   FILE 602\n//*      dataset or PDS member. I used to do a lot of work on       *   FILE 602\n//*      VM/CMS, and made good use of the CMS PUT command, so I     *   FILE 602\n//*      decided to create a version for ISPF.                      *   FILE 602\n//*                                                                 *   FILE 602\n//*      LSPCR is a REXX exec that executes the TSO LSPACE          *   FILE 602\n//*      command and displays the output in a scrollable panel.     *   FILE 602\n//*      You can sort the panel display on one of several           *   FILE 602\n//*      fields. The scrollable panel is a lot easier to read       *   FILE 602\n//*      than the output from the TSO command.                      *   FILE 602\n//*                                                                 *   FILE 602\n//*      An XMIT for a load library containing the LSPACE and       *   FILE 602\n//*      LSPC TSO commands has been included in this pds, as        *   FILE 602\n//*      member LSPC.  You need only execute a TSO RECEIVE          *   FILE 602\n//*      command against this member (see member $$NOTE1 for        *   FILE 602\n//*      instructions), to get a load library containing the        *   FILE 602\n//*      LSPACE TSO command (source from File 136) and its          *   FILE 602\n//*      alias LSPC.  These may then be copied to the               *   FILE 602\n//*      TSO-accessible load library of your choice.                *   FILE 602\n//*                                                                 *   FILE 602\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LSPC": {"ttr": 532, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x022\\x0f\\x01\\x022\\x0f#Q\\x00A\\x00A\\x00\\x00\\xd3\\xd6\\xc1\\xc4\\xd4\\xd6\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-11-16T00:00:00", "modifydate": "2002-11-16T23:51:00", "lines": 65, "newlines": 65, "modlines": 0, "user": "LOADMOD"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "LSPCPNL": {"ttr": 534, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x01\\x16\\x9f\\x01\\x01\\x16\\x9f\\x14\\x04\\x00\\x16\\x00\\x17\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2001-06-18T00:00:00", "modifydate": "2001-06-18T14:04:00", "lines": 22, "newlines": 23, "modlines": 0, "user": "PANEL"}, "text": ")ATTR\n@ TYPE(TEXT)   INTENS(LOW)  COLOR(GREEN)\n# TYPE(TEXT)   INTENS(LOW)  SKIP(ON)\n* TYPE(OUTPUT) INTENS(LOW)  COLOR(YELLOW)\n$ TYPE(OUTPUT) INTENS(LOW)  COLOR(TURQ)\n? TYPE(INPUT)  INTENS(LOW)  HILITE(USCORE)\n)BODY EXPAND(!!)\n%!-!LSPCR  v 1.00 - Full Screen LSPC!-!\n+COMMAND ===>_zcmd                                            +SCROLL ===>_amt #\n+\n+Volume(s):?lspcpprm                                                           #\n+\n@Unit                Free     Free     Free        Contiguous     Contiguous\n@Addr     Volser     Cyls     Trks     Extents      Free Cyls      Free Trks\n+           (1)       (2)      (3)       (4)           (5)            (6)\n+\n)MODEL\n&dtl\n)INIT\n .help = LSPCPNLH\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LSPCPNLH": {"ttr": 536, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00%\\x01\\x01\\x16\\x9f\\x01\\x01\\x17o\\x12\\x15\\x00I\\x00A\\x00\\x00\\xd7\\xc1\\xd5\\xc5\\xd3@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2001-06-18T00:00:00", "modifydate": "2001-06-25T12:15:25", "lines": 73, "newlines": 65, "modlines": 0, "user": "PANEL"}, "text": ")ATTR\n< AREA(SCRL)   EXTEND(ON)\n)BODY EXPAND(!!)\n%!-!LSPCR Help!-!\n<MYAREA -----------------------------------------------------------------------<\n)AREA MYAREA\n+LSPCR is a full-screen ISPF version of the LSPC (LSPACE) TSO command.\n+You can specify full or partial VOLSERs, or unit addresses, device\n+names (3330, 2314, etc.), or mount status (PUBLIC, PRIVATE, STORAGE).\n+You cannot specify the FLAGS parameter.\n+\n+If you specify a parameter of 'ABC' you will only see those volumes\n+that begin with the letters ABC. Enter DEF to see all the DEF volumes,\n+etc. If you enter the LSCPR command with no parameters you will see all\n+available volumes.\n+\n+You can enter more than one volume parameter at a time. If you enter\n+TSO LSPCR ABC DEF GHI you will see all volumes beginning with those\n+three sets of letters. You may enter up to six volume parameters at a\n+time. You can mix full VOLSERs and partial VOLSERS. You mix VOLSERs\n+with ucb addresses, device names, or mount status, such as:\n+\n+TSO LSPCR ABC 3380 PRIVATE\n+\n+If any volume fits into more than one group it will be listed once for\n+each group. If a PRIVATE volume is also a 3380 volume it would be\n+listed twice in the above example.\n+\n+Any values that are in the VOLUMES line at the time you end the exec\n+will be recalled and used as the start up parameters the next time you\n+use the exec if you enter the LSPCR command by itself without any\n+parms.\n+\n+If you enter the LSPCR command with parameters then those will be used\n+instead of the previous parms.\n+\n+The volume display is initially sorted by two fields. First it is\n+sorted in ascending order by the first three letters of the volume\n+serial. So if you entered TSO LSPCR ABC DEF GHI, the ABC volumes would\n+appear first, then the DEF, then the GHI volumes.\n+\n+The display is then sorted in descending order by free space. Within a\n+group, volumes with the most free space will be first, followed by the\n+volume with the next highest amount of free space, etc.\n+\n+On the LSPCR panel, The input line labelled VOLUMES is where you can\n+enter different VOLSERS, ucb addresses, etc. Just separate each one\n+with a space. Just like on the initial command, you can enter up to six\n+fields at one time.\n+\n+LSPCR supports one primary command, which is SORT. You can sort the\n+display in either ascending or descending order by various fields. The\n+fields that you can sort on are VOLSER, Free Cyls, Free Trks, Free\n+Extents, Contiguous Free Cyls, and Contiguous Free Trks.\n+\n+To sort the display, enter the SORT command followed by a number and a\n+letter.  The number must be a whole number from 1 to 6. 1 is Volser, 2\n+is Free Cyls, etc. The sort field numbers are displayed below the field\n+names for clarity. The letter must be either A for ascending order or\n+D for descending order. If you do not enter the sort order it will\n+default to A.\n+\n+Once you enter a SORT command the fields will always be sorted that way\n+until you enter a new sort command. The sort order remains the same\n+even between different invocations of the command. If you sort the\n+display in ascending order by VOLSER, that's the way the display will\n+be sorted the next time you execute LSPCR. To change the sort order\n+just enter a new sort command.\n+\n+To exit LSPCR just press the PF3 key.\n)INIT\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LSPCR": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x003\\x01\\x02\\x15_\\x01\\x021o\\x12\\x10\\x01\\xd5\\x01\\xda\\x00\\x00\\xc5\\xe7\\xc5\\xc3@@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2002-06-04T00:00:00", "modifydate": "2002-11-12T12:10:33", "lines": 469, "newlines": 474, "modlines": 0, "user": "EXEC"}, "text": "/* REXX */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\\\n * 05/28/2001 - LSPCR - Full Screen LSPC command                     *\n *                                                                   *\n * Author:    Michael A. Newell, WB4HUC                              *\n *                                                                   *\n * Invocation - From the ISPF command line:                          *\n *                                                                   *\n *              TSO LSPCR                                            *\n *                                                                   *\n * This exec will allow you to execute the TSO LSPC command in       *\n * full screen mode, with scrolling, and will allow you to show      *\n * up to six groups of DASD volumes at one time.                     *\n *                                                                   *\n\\* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* Get list of volumes                                               */\n\nARG lspcprm1 lspcprm2 lspcprm3 lspcprm4 lspcprm5 lspcprm6 .\n\n/* Is ISPF active?                                                   */\n\nIF SYSVAR(\"SYSISPF\") = \"NOT ACTIVE\" THEN\n  DO\n    SAY 'This command can only be run from ISPF.'\n    SAY 'Start an ISPF session and try the command again.'\n    EXIT\n  END\n\n/* All commands default to ISPF                                      */\n\nADDRESS ISPEXEC\n\n/* Always return to ISPF after errors                                */\n\n\"CONTROL ERRORS RETURN\"\n\n/* Eliminate any duplicate parms that were entered                   */\n\nCALL Drop_Duplicate_Parms\n\n/* Initialize variables                                              */\n\nCALL Initialize_Variables\n\n/* Do until PF3 or PF4 pressed                                       */\n\nDO WHILE panel_rc < 8\n   IF LEFT(zcmd,4) = 'SORT' THEN\n      DO\n        CALL Sort_Table\n        Call Display_Panel\n        ITERATE\n      END\n   /*\n      The way the exec is shipped, you will see an updated display\n      each time you press the ENTER key. If you are displaying 100\n      volumes or more, there will be a noticeable delay in the updating\n      of the panel. If you DO NOT want the display to be updated when\n      you press the ENTER key, then simply uncomment the block of\n      code immediately below. After this code is uncommented, the\n      display will be updated only if you enter a SORT command or if\n      you enter new information on the VOLUMES line of the panel. Just\n      pressing the ENTER key without changing information will not\n      update the display.\n   */\n   /*\n   IF lspcpprm = old_lspcpprm THEN\n      DO\n        CALL Display_Panel\n        ITERATE\n      END\n   */\n   IF lspcpprm /= old_lspcpprm THEN\n      DO\n        old_lspcpprm = lspcpprm\n        csr_pos = 'CURSOR(LSPCPPRM)'\n      END\n   CALL Issue_Command\n   IF Build_Table() = 0 THEN\n        CALL Display_Panel\n   ELSE\n      panel_rc = 8\nEND\n\n/* Close the ISPF tables                                             */\n\n\"TBCLOSE LSPCTBL\"\n\"TBCLOSE LSPCTBL1\"\n\n/* Store DASD volume parms in user's profile pool                    */\n\nlspcprms = lspcpprm\n\"VPUT (lspcprms) PROFILE\"\n\nEXIT\n\nIssue_Command:\n\n   /* Issue TSO LSPACE command and capture the output          */\n\n   dummy = OUTTRAP(\"line.\",\"*\")\n   DO i = 1 to 6\n      INTERPRET 'lspcparm = lspcprm'i\n      IF lspcparm /= '' THEN\n         ADDRESS TSO \"LSPC \" lspcparm\n      IF lspcparm = '' & i = 1 THEN\n         ADDRESS TSO \"LSPC \" lspcparm\n      IF lspcparm = '' & i > 1 THEN LEAVE\n      x = line.0\n      IF LEFT(line.x,3) = 'HMD' THEN\n         line.x = line.x '-->' lspcparm\n   END\n   dummy = OUTTRAP('OFF')\nRETURN\n\nBuild_Table:\n\n   /* Create an ISPF table then write the LSPACE command output*/\n   /*    to it                                                 */\n   /*    This table is not the table displayed on the screen.  */\n   /*    This table is built to contain the intial LSPACE      */\n   /*    command output, then a new table is built and the     */\n   /*    LSPCACE output contained in this table is sorted and  */\n   /*    written to the new table, and displayed from the new  */\n   /*    table                                                 */\n\n   IF Create_Table() > 0 THEN\n      RETURN tbcreate_rc\n   DO i = 1 TO line.0\n      IF Add_to_Table() > 0 THEN\n         RETURN tbadd_rc\n   END\n   IF lspcsrtf = '' & lspcsrto = '' THEN\n      DO\n        \"TBSORT LSPCTBL FIELDS(vsl,C,A,fcyl,N,D)\"\n        CALL Fill_Display_Table\n      END\n   ELSE\n      CALL Sort_Table\nRETURN 0\n\nCreate_Table:\n\n   /* Subroutine to create the ISPF table                      */\n\n   \"TBCREATE LSPCTBL NAMES(\"tblflds\") NOWRITE REPLACE\"\n   tbcreate_rc = rc\n   IF tbcreate_rc = 4 THEN\n      tbcreate_rc = 0\n   IF tbcreate_rc > 0 THEN\n      DO\n        \"SETMSG MSG(ISRZ002)\"\n        RETURN tbcreate_rc\n      END\n   \"TBCREATE LSPCTBL1 NAMES(\"tblflds\") NOWRITE REPLACE\"\n   tbcreate_rc = rc\n   IF tbcreate_rc = 4 THEN\n      tbcreate_rc = 0\n   IF tbcreate_rc > 0 THEN\n      \"SETMSG MSG(ISRZ002)\"\nRETURN tbcreate_rc\n\nAdd_To_Table:\n\n   /* Subroutine to add LSPACE command output to ISPF table    */\n\n   lspcline = line.i\n   IF LEFT(lspcline,3) = 'HMD' | ,\n      LEFT(lspcline,3) = 'IKJ' THEN\n      DO\n        CALL Build_Error_Msg\n        RETURN 0\n      END\n   PARSE VAR line.i uaddr volser . . . . .\n   vsl = LEFT(volser,3)\n   i1 = i + 1\n   CALL Drop_Leading_Zeroes\n   \"TBADD LSPCTBL MULT(\"line.0\")\"\n   tbadd_rc = rc\n   IF tbadd_rc > 0 THEN\n      \"SETMSG MSG(ISRZ002)\"\n   i = i + 1\nRETURN tbadd_rc\n\nDrop_Leading_Zeroes:\n\n   /* Drop leading zeroes from all numbers displayed on screen */\n\n   PARSE VALUE line.i1 WITH fcyl ',' ftrk ',' fxtnt ',' ctrk\n   PARSE VALUE fcyl WITH garbage '=' fcyl\n   PARSE VALUE fxtnt WITH fxtnt '/' ccyl\n   fcyl = STRIP(fcyl)\n   ftrk = STRIP(ftrk)\n   fxtnt = STRIP(fxtnt)\n   ccyl = STRIP(ccyl)\n   ctrk = STRIP(ctrk)\n   IF fcyl > 0 THEN\n      fcyl  = RIGHT(STRIP(fcyl,'L','0'),4)\n   ELSE\n      DO\n        fcyl  = RIGHT(fcyl,1)\n        fcyl  = RIGHT(fcyl,4)\n      END\n   IF ftrk > 0 THEN\n      ftrk  = RIGHT(STRIP(ftrk,'L','0'),4)\n   ELSE\n      DO\n        ftrk  = RIGHT(ftrk,1)\n        ftrk  = RIGHT(ftrk,4)\n      END\n   IF fxtnt > 0 THEN\n      fxtnt = RIGHT(STRIP(fxtnt,'L','0'),7)\n   ELSE\n      DO\n        fxtnt  = RIGHT(fxtnt,1)\n        fxtnt  = RIGHT(fxtnt,7)\n      END\n   IF ccyl > 0 THEN\n      ccyl  = RIGHT(STRIP(ccyl,'L','0'),10)\n   ELSE\n      DO\n        ccyl  = RIGHT(ccyl,1)\n        ccyl  = RIGHT(ccyl,10)\n      END\n   IF ctrk > 0 THEN\n      ctrk  = RIGHT(STRIP(ctrk,'L','0'),10)\n   ELSE\n      DO\n        ctrk  = RIGHT(ctrk,1)\n        ctrk  = RIGHT(ctrk,10)\n      END\nRETURN\n\nFill_Display_Table:\n\n   /* Create a second ISPF table to hold sorted output where   */\n   /*    groups of DASD volumes are separated by a blank line  */\n   /*    This table is the one displayed on the ISPF screen    */\n\n   vsl = 'dummy'\n   old_vsl = vsl\n   \"TBTOP  LSPCTBL\"\n   \"TBQUERY LSPCTBL ROWNUM(\"nbrrows\")\"\n   DO j = 1 to nbrrows\n      \"TBSKIP LSPCTBL NUMBER(1)\"\n      \"TBGET LSPCTBL\"\n      IF vsl /= old_vsl THEN\n         DO\n           old_vsl = vsl\n           IF j > 1 THEN\n              CALL Add_Blank_Line\n         END\n      \"TBADD LSPCTBL1 MULT(\"nbrrows\")\"\n   END\n   \"TBTOP  LSPCTBL1\"\n   DROP NBRROWS\n   DROP line.\nRETURN\n\nAdd_Blank_Line:\n\n   /* Subroutine to add a blank line between groups of DASD    */\n   /*     volumes                                              */\n\n   old_uaddr  = uaddr\n   old_vsl    = vsl\n   old_volser = volser\n   old_fcyl   = fcyl\n   old_ftrk   = ftrk\n   old_fxtnt  = fxtnt\n   old_ccyl   = ccyl\n   old_ctrk   = ctrk\n   uaddr  = ''\n   vsl    = ''\n   volser = ''\n   fcyl   = ''\n   ftrk   = ''\n   fxtnt  = ''\n   ccyl   = ''\n   ctrk   = ''\n   \"TBADD LSPCTBL1 MULT(\"nbrrows\")\"\n   uaddr  = old_uaddr\n   vsl    = old_vsl\n   volser = old_volser\n   fcyl   = old_fcyl\n   ftrk   = old_ftrk\n   fxtnt  = old_fxtnt\n   ccyl   = old_ccyl\n   ctrk   = old_ctrk\nRETURN\n\nBuild_Error_Msg:\n\n   /* Subroutine to build error message display lines          */\n\n   error_flag = 1\n   errmsg_sub = errmsg.0 + 1\n   errmsg.errmsg_sub = LEFT(lspcline,term_width)\n   errmsg.0 = errmsg_sub\nRETURN\n\nSort_Table:\n\n   /* Subroutine to process the SORT command and sort table    */\n   /*     accordingly                                          */\n\n   IF LEFT(zcmd,4) = 'SORT' THEN\n      DO\n        PARSE VAR zcmd zcmd sort_field sort_order\n        lspcsrtf = sort_field\n        lspcsrto = sort_order\n        csr_pos = 'CURSOR(ZCMD)'\n      END\n   ELSE\n      DO\n        sort_order = lspcsrto\n        sort_field = lspcsrtf\n      END\n   IF sort_order = '' & sort_field = '' THEN\n      DO\n        sort_order = 'D'\n        sort_field = 2\n      END\n   IF sort_order = '' THEN\n      sort_order = 'A'\n   IF DATATYPE(sort_field) /= 'NUM' THEN\n      DO\n        zedsmsg = 'Sort Field Not Numeric'\n        zedlmsg = 'Sort Field Must Be Numeric'\n        \"SETMSG MSG(ISRZ001)\"\n        RETURN 12\n      END\n   sort_field = TRUNC(sort_field,0)\n   IF sort_field < 1 | sort_field > 6 THEN\n      DO\n        zedsmsg = 'Sort Field Out of Range'\n        zedlmsg = 'Sort Field Must Be From 1 to 6, Inclusive'\n        \"SETMSG MSG(ISRZ001)\"\n        RETURN 12\n      END\n   IF sort_order /= 'A' & sort_order /= 'D' THEN\n      DO\n        zedsmsg = 'Sort Order Invalid'\n        zedlmsg = 'Sort Order Must Be \"A\" or \"D\"'\n        \"SETMSG MSG(ISRZ001)\"\n        RETURN 12\n      END\n   \"VPUT (lspcsrtf lspcsrto) PROFILE\"\n   SELECT\n     WHEN sort_field = 1 THEN\n          \"TBSORT LSPCTBL FIELDS(VOLSER,C,\"sort_order\")\"\n     WHEN sort_field = 2 THEN\n          \"TBSORT LSPCTBL FIELDS(VSL,C,A,FCYL,N,\"sort_order\")\"\n     WHEN sort_field = 3 THEN\n          \"TBSORT LSPCTBL FIELDS(VSL,C,A,FTRK,N,\"sort_order\")\"\n     WHEN sort_field = 4 THEN\n          \"TBSORT LSPCTBL FIELDS(VSL,C,A,FXTNT,N,\"sort_order\")\"\n     WHEN sort_field = 5 THEN\n          \"TBSORT LSPCTBL FIELDS(VSL,C,A,CCYL,N,\"sort_order\")\"\n     WHEN sort_field = 6 THEN\n          \"TBSORT LSPCTBL FIELDS(VSL,C,A,CTRK,N,\"sort_order\")\"\n   OTHERWISE\n     NOP\n   END\n   tbsort_rc = rc\n   IF tbsort_rc > 0 THEN\n      DO\n        \"SETMSG MSG(ISRZ002)\"\n        RETURN 12\n      END\n   \"TBCLOSE  LSPCTBL1\"\n   \"TBCREATE LSPCTBL1 NAMES(\"tblflds\") NOWRITE REPLACE\"\n   tbcreate_rc = rc\n   IF tbcreate_rc = 4 THEN\n      tbcreate_rc = 0\n   IF tbcreate_rc > 0 THEN\n      DO\n        \"SETMSG MSG(ISRZ002)\"\n        RETURN 12\n      END\n   CALL Fill_Display_Table\nRETURN 0\n\nDisplay_Panel:\n\n   /* Subroutine to display the sorted ISPF table              */\n\n   IF error_flag = 1 THEN\n      CALL Build_Error_Messages\n   \"TBDISPL LSPCTBL1 PANEL(LSPCPNL)\" csr_pos\n   panel_rc = rc\n   IF panel_rc = 4 | panel_rc = 8 THEN\n      RETURN panel_rc\n   ELSE\n      IF panel_rc /= 0 THEN\n         \"SETMSG MSG(ISRZ002)\"\n   PARSE VAR lspcpprm lspcprm1 lspcprm2 lspcprm3 ,\n                      lspcprm4 lspcprm5 lspcprm6 . . . .\n   CALL Drop_Duplicate_Parms\n   lspcpprm = lspcprm1 lspcprm2 lspcprm3 ,\n              lspcprm4 lspcprm5 lspcprm6\nRETURN panel_rc\n\nBuild_Error_Messages:\n\n   /* Subroutine to display any error messages produced from   */\n   /*     TSO LSPACE command                                   */\n\n   zedlmsg = ''\n   DO i = 1 to errmsg.0\n      zedlmsg = zedlmsg || errmsg.i\n   END\n   \"SETMSG MSG(ISRZ001)\"\n   error_flag = 0\n   drop errmsg.\n   errmsg.0 = 0\nRETURN\n\nDrop_Duplicate_Parms:\n\n   /* Subroutine to eliminate any duplicate parameters         */\n\n  wordlist = lspcprm1 lspcprm2 lspcprm3  ,\n             lspcprm4 lspcprm5 lspcprm6\n  hadword. = 0\n  outlist  = ''\n  DO WHILE wordlist /= ''\n    PARSE VAR wordlist word wordlist\n    IF hadword.word then\n       ITERATE\n    hadword.word=1\n    outlist=outlist word\n  END\n  DO i = 1 to 6\n     INTERPRET 'DROP lspcprm'i\n  END\n  PARSE VAR outlist lspcprm1 lspcprm2 lspcprm3 ,\n                    lspcprm4 lspcprm5 lspcprm6\nRETURN\n\nInitialize_Variables:\n\n   /* Subroutine to initialize program variables               */\n\n   lspcsrtf   = ''\n   lspcsrto   = ''\n   first_time = 1\n   errmsg.0   = 0\n   errmsg_sub = 0\n   error_flag = 0\n   term_width = SYSVAR(SYSWTERM)\n   tblflds    = 'uaddr vsl volser fcyl ftrk fxtnt ccyl ctrk'\n   dtl        = '*'uaddr'   *'volser'    *'fcyl     ,\n                '   *'ftrk'    *'fxtnt'      *'ccyl   ,\n                '         *'ctrk\n   \"VGET (lspcsrtf lspcsrto lspcprms) PROFILE\"\n   csr_pos    = 'CURSOR(LSPCPPRM)'\n   lspcpprm   = lspcprm1 lspcprm2 lspcprm3 ,\n                lspcprm4 lspcprm5 lspcprm6\n   IF lspcpprm = '' THEN\n      DO\n        lspcpprm = lspcprms\n        PARSE VAR lspcpprm lspcprm1 lspcprm2 lspcprm3 ,\n                  lspcprm4 lspcprm5 lspcprm6 . . . .\n      END\n   old_lspcpprm = 'dummy'\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PUT": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x00E\\x01\\x021\\x1f\\x01\\x021_\\x11F\\x01$\\x00\\xef\\x00\\x00\\xc5\\xe7\\xc5\\xc3@@@@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "2002-11-07T00:00:00", "modifydate": "2002-11-11T11:46:45", "lines": 292, "newlines": 239, "modlines": 0, "user": "EXEC"}, "text": "/*-REXX edit macro--------------------------------------------------*\\\n|                                                                    |\n| Macro Name: Put  (created on 11/06/2002)                           |\n|                                                                    |\n|    Purpose: Use PUT to copy lines from the dataset or member       |\n|             currently being edited to another dataset or member    |\n|                                                                    |\n|     Syntax: PUT firstline lastline dsn|-member targetline          |\n|                                                                    |\n|             OR                                                     |\n|                                                                    |\n|             PUT dsn|-member targetline                             |\n|                                                                    |\n|                 and use C, CC, M, or MM line commands to indicate  |\n|                 the line(s) or range of lines to be copied and     |\n|                 pasted into the target daaset or member            |\n|                                                                    |\n|                 See the $PUT file for full documentation of the    |\n|                 macro.                                             |\n|                                                                    |\n|     Author: Michael A. Newell, WB4HUC                              |\n|                                                                    |\n|    Changes:                                                        |\n|                                                                    |\n\\*------------------------------------------------------------------*/\n ISREDIT \"MACRO  (parm1 parm2 parm3 parm4) NOPROCESS\"\n x = MSG('OFF')\n ADDRESS ISREDIT\n ADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n CALL Initialize_Variables\n\n /* If the variable PUTPARM is set to the value of \"IMAC\", then this\n    is the second invocation of the exec, and the lines that were\n    copied from the first invocation will be pasted into the target\n    dataset during this invocation\n */\n\n ADDRESS ISPEXEC \"VGET (putparm) PROFILE\"\n IF putparm = \"IMAC\" THEN\n    DO\n      CALL Paste_Lines\n      EXIT\n    END\n\n /* Make sure that the macro parameters were entered                 */\n\n IF WORDS(parm1) = 0 THEN\n    DO\n      zedlmsg = \"The correct syntax is: PUT firstline lastline dsn\" ,\n                \"targetline, or PUT dsn targetline if line command\" ,\n                \"ranges are specified\"\n      ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"\n      EXIT 16\n    END\n\n /* Get width of data being copied                                   */\n\n \"(putwidth) = DATA_WIDTH\"\n\n /* Find out if C, CC, M, or MM line command ranges were entered     */\n\n \"PROCESS RANGE C M\"\n\n range_rc = rc\n\n /* if range_rc >= 16, something is wrong with the line commands     */\n\n IF range_rc >= 16 THEN\n    DO\n      ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n      EXIT 16\n    END\n\n /* If rc = 0, valid line ranges were entered.\n    If rc not zero, then no line ranges were entered, and we'll use\n    the line number ranges that were entered with the macro invocation\n */\n\n IF range_rc = 0 THEN\n    DO\n      dsn   = parm1\n      tline = parm2\n      \"(rcmd) = RANGE_CMD\"\n      IF Validate_Line_Number(tline,'target line')  /= 0 THEN EXIT 16\n      \"CUT .ZFRANGE .ZLRANGE R\"\n      cut_rc = rc\n    END\n ELSE\n    IF Cut_Lines() > 0 THEN EXIT 16\n\n /* Validate the target dsn or member name                           */\n\n IF Validate_dsn(dsn) /= 0 THEN EXIT 16\n\n /* Set the PUTPARM variable and write it to the profile pool        */\n\n putparm = \"IMAC\"\n ADDRESS ISPEXEC \"VPUT (putparm tline putwidth) PROFILE\"\n\n /* Edit the target dataset using this PUT macro as the initial\n    macro. When the initial macro starts, it'll check the PUTPARM\n    variable, and if it is set, execution will jump to the Paste_Lines\n    subroutine\n */\n\n ADDRESS ISPEXEC \"CONTROL DISPLAY SAVE\"\n ADDRESS ISPEXEC \"EDIT DATASET(\"dsn\") MACRO(PUT)\"\n edit_rc = rc\n ADDRESS ISPEXEC \"CONTROL DISPLAY RESTORE\"\n\n /* Free any pds that was allocated because a new member was created */\n\n IF ddn /= \"DDN\" THEN\n    ADDRESS TSO \"FREE DDNAME(\"ddn\")\"\n\n DROP ddn              /* just to be sure the name is re-initialized */\n\n /* Check the return code from the editing of the target dataset     */\n\n IF edit_rc = 4  THEN edit_rc = 0\n IF edit_rc /= 0 THEN\n      ADDRESS ISPEXEC \"SETMSG MSG(ISRZ002)\"\n\n /* Reset the PUTPARM variable and write it to the profile pool      */\n\n putparm = \"\"\n ADDRESS ISPEXEC \"VPUT (putparm) PROFILE\"\n\n /* If the line commands were 'M' or 'MM', delete the lines          */\n\n IF cut_rc = 0 & rcmd = \"M\" THEN\n    \"DELETE .ZFRANGE .ZLRANGE\"\n\nEXIT 0\n\nCut_Lines:\n   fline = parm1\n   lline = parm2\n   dsn   = parm3\n   tline = parm4\n   IF Validate_Line_Number(fline,'first line')   /= 0 THEN RETURN 16\n   IF Validate_Line_Number(lline,'last line')    /= 0 THEN RETURN 16\n   IF Validate_Line_Number(tline,'target line')  /= 0 THEN RETURN 16\n   IF Validate_Line_Logic()                      /= 0 THEN RETURN 16\n   IF fline = lline THEN\n      DO\n        \"LABEL\" fline \"= .FL\"\n        \"CUT .FL .FL R\"\n      END\n   ELSE\n      DO\n        \"LABEL\" fline \"= .FL\"\n        \"LABEL\" lline \"= .LL\"\n        \"CUT .FL .LL R\"\n      END\nRETURN 0\n\nValidate_Line_Number:\n   ARG lnum, linename\n   PARSE VAR lnum lnum '.' trash\n   IF DATATYPE(lnum) /= \"NUM\" THEN\n      DO\n        zedlmsg = \"The\" linename \"parameter must be numeric\"\n        ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"\n        RETURN 16\n      END\n   IF lnum = 0 & linename /= \"TARGET LINE\" THEN\n      DO\n        zedlmsg = \"The\" linename \"parameter cannot be zero\"\n        ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"\n        RETURN 16\n      END\n   IF lnum < 0 THEN\n      DO\n        zedlmsg = \"The\" linename \"cannot be less than zero\"\n        ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"\n        RETURN 16\n      END\nRETURN 0\n\nValidate_Line_Logic:\n   If fline > lline THEN\n      DO\n        zedlmsg = \"The first line cannot be greater than the last line\"\n        ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"\n        RETURN 16\n      END\n   \"(lastline) = LINENUM .ZLAST\"\n   IF lline > lastline THEN lline = lastline\nRETURN 0\n\nValidate_dsn:\n   /* get datset name                                                */\n   \"(edsn,odsn,clevel) = DATASET\"\n\n   /* if only member name entered, construct the entire dsname       */\n   IF LEFT(dsn,1) = '-' THEN\n        dsn = \"'\"edsn\"(\"RIGHT(dsn,LENGTH(dsn)-1)\")'\"\n\n   /* get dataset status                                             */\n   x = SYSDSN(dsn)\n\n   /* if a new pds member name was entered, create it                */\n   IF x = \"MEMBER NOT FOUND\" THEN\n      DO\n        ddn = \"PUT\"random()\n        ADDRESS TSO \"ALLOCATE DD(\"ddn\") DA(\"dsn\") SHR\"\n        x = \"OK\"\n      END\n\n   /* if something is wrong with the dataset, display error message  */\n   IF x /= \"OK\" THEN\n      DO\n        zedlmsg = \"ERROR:\" x\n        ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"\n        RETURN 16\n      END\nRETURN 0\n\nPaste_Lines:\n   putparm  = \"\"\n   ADDRESS ISPEXEC \"VPUT (putparm) PROFILE\"\n   ADDRESS ISPEXEC \"VGET (tline putwidth) PROFILE\"\n   \"PROCESS DEST\"\n   dest_rc = rc\n\n   /* dest_rc = 20 means the dataset or pds member is empty          */\n   IF dest_rc = 20 THEN\n      DO\n        \"PASTE AFTER .ZFIRST\"\n        \"LINE_AFTER 0 = MSGLINE (msgtextn)\"\n        CALL Check_Line_Lengths\n        RETURN\n      END\n\n   /* new lines are added to the beginning of the dataset or member  */\n   IF tline = 0 THEN\n      DO\n        \"LABEL 1 = .TLP\"\n        \"PASTE BEFORE .ZFIRST\"\n        \"LINE_AFTER 0 = MSGLINE (msgtextb)\"\n        \"LINE_BEFORE .TLP = MSGLINE (msgtexte)\"\n        CALL Check_Line_Lengths\n        RETURN\n      END\n\n   \"(lastline) = LINENUM .ZLAST\"\n\n   /* new lines are added to the end of the dataset or pds member    */\n   IF tline >= lastline THEN\n      DO\n        tline = lastline\n        \"PASTE AFTER\" lastline\n        \"LINE_AFTER\" lastline \"= MSGLINE (msgtextb)\"\n        \"LINE_AFTER .ZLAST = MSGLINE (msgtexte)\"\n        CALL Check_Line_Lengths\n        RETURN\n      END\n\n   /* new lines are added somewhere in the middle of the dataset or  */\n   /* member - label .TLP is (T)arget (L)ine (P)lus 1                */\n   \"LABEL\" tline + 1 \"= .TLP\"\n   \"PASTE AFTER\" tline\n   \"LINE_AFTER\" tline \"= MSGLINE (msgtextb)\"\n   \"LINE_BEFORE .TLP = MSGLINE (msgtexte)\"\n   CALL Check_Line_Lengths\nRETURN\n\nCheck_Line_Lengths:\n   \"(linelen) = DATA_WIDTH\"\n   putwidth = STRIP(putwidth,'L','0')\n   linelen  = STRIP(linelen,'L','0')\n   IF putwidth > linelen THEN\n      DO\n        zedlmsg = \"Possible data truncation - lines that were\" ,\n                  putwidth \"characters long were pasted into lines\" ,\n                  \"that were\" linelen \"characters long\"\n        ADDRESS ISPEXEC \"SETMSG MSG(ISRZ001)\"\n      END\n   IF dest_rc /= 20 & tline > 5 THEN\n      \"LOCATE\" tline - 5\nRETURN\n\nInitialize_Variables:\n   zedsmsg = \"\"\n   msgtextb = \"----------------------------Begin New Lines----------------\" ||,\n              \"-----------\"\n   msgtexte = \"-----------------------------End New Lines-----------------\" ||,\n              \"-----------\"\n   msgtextn = \"-----------------------New Dataset or PDS Member-----------\" ||,\n              \"-----------\"\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT602/FILE602.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT602", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}