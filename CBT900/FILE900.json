{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013351000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 1998724, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 14, "INMDSNAM": "CBT.V500.FILE900.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 1998724, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 1998724, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE900.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00 \\x0b'", "DS1TRBAL": "b'\"\\x00'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x08\\xd1\\x00\\r\\x08\\xd4\\x00\\x00\\x00!'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00T\\x01 \\x16\\x8f\\x01 \\x16\\x8f\\x16E\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf5\\xf0\\xf0@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "2020-06-16T00:00:00", "modifydate": "2020-06-16T16:45:54", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-500"}, "text": "REGULAR CBT TAPE - VERSION 500    FILE:  900\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT500.FILE900\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 51 MEMBERS COUNTED; CUMULATIVE SIZE IS 18,395 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   06/16/20    16:45:53    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE01": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00U\\x01 \\x16\\x7f\\x01 \\x16\\x7f\"S\\x00.\\x001\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2020-06-15T00:00:00", "modifydate": "2020-06-15T22:53:55", "lines": 46, "newlines": 49, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  CKSUM command for CBT file 900\nDate:     6/15/2020, 8:50 PM\nTo:       Sam Golob <sbgolob@cbttape.org>\n\nHi Sam,\n\nThere are updates for file 900, including the addition of the\nCKSUM TSO command. It serves a similar purpose as the MD5SUM\ncommand but with a different checksum algorithm. Like MD5SUM, if\nthe results of CKSUM are the same on different systems, the file\ncontents are highly likely to be identical.  There is also a\nCKSPGM program that does the same thing as CKSUM in a batch job\nor a TSO CALL command.\n\nThere already is a \"cksum\" command in z/OS Unix System Services,\nbut it does not directly read data sets, just Unix files.\n\nWikipedia has an article about the Unix cksum command.\n\nhttps://en.wikipedia.org/wiki/Cksum\n\nHere is a list of members that are added or updated.\n\nThe first 2 are identical, and describe what the other CK*\nmembers are. The MD5* and SHA* updates are very minor, for\ncorrectly setting an RDW in VB files, which never caused a\nproblem but it might have just been luck that a getmained area\nhad zeroes in it.\n\n   Name         Size     Created         Changed\n  @FILECKS       29   2020/06/15   2020/06/15 12:32:24\n  CKS@           29   2020/06/15   2020/06/15 12:32:24\n  CKSPGM        507   2020/06/15   2020/06/15 10:48:16\n  CKSPGM$        17   2020/06/15   2020/06/15 11:26:37\n  CKSUM        1202   2020/06/14   2020/06/14 20:58:27\n  CKSUM$         17   2020/05/31   2020/05/31 18:44:00\n  CKSUM#         25   2020/06/11   2020/06/11 11:44:55\n  CKSUMR        316   2020/06/07   2020/06/07 14:43:32\n  CKSUMR24      316   2020/06/07   2020/06/07 14:43:33\n  CKSUM24      1117   2020/06/14   2020/06/14 21:00:03\n  CKSUM24$       30   2020/06/14   2020/06/14 21:20:54\n  MD5PGM        478   2020/05/13   2020/06/15 07:24:13\n  MD5P24        386   2020/05/13   2020/06/15 11:11:56\n  SHA1PGM       582   2020/05/20   2020/06/15 07:19:34\n  SHA2PGM       582   2020/05/20   2020/06/15 07:21:24\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE900": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00G\\x01 \\x16\\x8f\\x01 \\x16\\x8f\\x16E\\x00\\x92\\x00\\x92\\x00\\x00\\xc3\\xc2\\xe3`\\xf5\\xf0\\xf0@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "2020-06-16T00:00:00", "modifydate": "2020-06-16T16:45:47", "lines": 146, "newlines": 146, "modlines": 0, "user": "CBT-500"}, "text": "//***FILE 900 is a set of programs which run under either old MVS   *   FILE 900\n//*           or z/OS to calculate MD5 checksums.  Please see the   *   FILE 900\n//*           member called @FILEMD5, which contains descriptions   *   FILE 900\n//*           of all the MD5**  pds members found in this file.     *   FILE 900\n//*                                                                 *   FILE 900\n//*      support:  sbgolob@cbttape.org                              *   FILE 900\n//*                                                                 *   FILE 900\n//*      SHA-1 and SHA-2 support added, May 2016.                   *   FILE 900\n//*                                                                 *   FILE 900\n//*      SHA-384 and SHA-512 support added, Aug 2016.               *   FILE 900\n//*                                                                 *   FILE 900\n//*      Fixed for 8-character TSO prefixes in z/OS 2.3.            *   FILE 900\n//*                                                                 *   FILE 900\n//*      Fixed by Peter Glanzmann for Extended Address Volumes.     *   FILE 900\n//*                                                                 *   FILE 900\n//*      More new members for File 900.                             *   FILE 900\n//*                                                                 *   FILE 900\n//*      SHA1PGM  - batch version of SHA1SUM.                       *   FILE 900\n//*      SHA1PGM$ - JCL to assemble SHA1PGM.                        *   FILE 900\n//*      SHA2PGM  - batch version of SHA2SUM.                       *   FILE 900\n//*      SHA2PGM$ - JCL to assemble SHA2PGM.                        *   FILE 900\n//*      MD5P24$  - JCL to assemble MD5P24 (24 bit version)         *   FILE 900\n//*                 with IFOX00, using an MVS3.8 copy of            *   FILE 900\n//*                 SYS1.MACLIB. IFOX00 can't handle new            *   FILE 900\n//*                 macro features in z/OS SYS1.MACLIB.             *   FILE 900\n//*                                                                 *   FILE 900\n//*      And more new members for File 900.                         *   FILE 900\n//*                                                                 *   FILE 900\n//*      CKSPGM   - assembler source for the CKSPGM batch           *   FILE 900\n//*                 program which is independent from the           *   FILE 900\n//*                 CKSUM TSO command.                              *   FILE 900\n//*                                                                 *   FILE 900\n//*      CKSPGM$  - JCL to assemble CKSPGM and the CKSUMR           *   FILE 900\n//*                 subprogram.                                     *   FILE 900\n//*                                                                 *   FILE 900\n//*      CKSUM    - assembler source for the 31-bit CKSUM TSO       *   FILE 900\n//*                 command.  It calls the CKSUMR subprogram.       *   FILE 900\n//*                                                                 *   FILE 900\n//*      CKSUM$   - JCL to assemble CKSUM and the CKSUMR            *   FILE 900\n//*                 subprogram.                                     *   FILE 900\n//*                                                                 *   FILE 900\n//*      CKSUM#   - TSO HELP text for the CKSUM TSO command.        *   FILE 900\n//*                                                                 *   FILE 900\n//*      CKSUMR   - assembler source for CKSUMR subprogram          *   FILE 900\n//*                 This must be linked with the CKSUM TSO          *   FILE 900\n//*                 command, and the CKSPGM program.                *   FILE 900\n//*                                                                 *   FILE 900\n//*      CKSUMR24 - assembler source for same CKSUMR subprogram,    *   FILE 900\n//*                 with AMODE and RMODE removed for IFOX00         *   FILE 900\n//*                 assembler.                                      *   FILE 900\n//*                 Intended for MVS 3.8 systems.                   *   FILE 900\n//*                                                                 *   FILE 900\n//*      CKSUM24  - assembler source for the 24-bit CKSUM TSO       *   FILE 900\n//*                 command.  Intended for MVS 3.8 systems.         *   FILE 900\n//*                                                                 *   FILE 900\n//*      CKSUM24$ - JCL to assemble CKSUM24 and CKSUMR24 using      *   FILE 900\n//*                 the MVS 3.8 IFOX00 assembler, and link as       *   FILE 900\n//*                 the 24-bit CKSUM TSO command.                   *   FILE 900\n//*                                                                 *   FILE 900\n//*      - - - - - - - - - - - - - - - - - - - - - - - - - - -      *   FILE 900\n//*                                                                 *   FILE 900\n//*      SHA1SUM  - Assembler source for SHA-1 generating command   *   FILE 900\n//*                       (Fix. DS1LSTAR is always 0 for a PDSE,    *   FILE 900\n//*                        so always read the dataset even if       *   FILE 900\n//*                        DS1LSTAR is 0.)                          *   FILE 900\n//*                                                                 *   FILE 900\n//*      SHA2SUM  - Assembler source for SHA-2 generating command   *   FILE 900\n//*                       (Fix. DS1LSTAR is always 0 for a PDSE,    *   FILE 900\n//*                        so always read the dataset even if       *   FILE 900\n//*                        DS1LSTAR is 0.)                          *   FILE 900\n//*                                                                 *   FILE 900\n//*      SHA3SUM  - Assembler source for SHA-384 generating command *   FILE 900\n//*                       (Fix. DS1LSTAR is always 0 for a PDSE,    *   FILE 900\n//*                        so always read the dataset even if       *   FILE 900\n//*                        DS1LSTAR is 0.)                          *   FILE 900\n//*                                                                 *   FILE 900\n//*      SHA5SUM  - Assembler source for SHA-512 generating command *   FILE 900\n//*                       (Fix. DS1LSTAR is always 0 for a PDSE,    *   FILE 900\n//*                        so always read the dataset even if       *   FILE 900\n//*                        DS1LSTAR is 0.)                          *   FILE 900\n//*                                                                 *   FILE 900\n//*      MD5      - Assembler source for MD5 subprogram, which      *   FILE 900\n//*                 is a modification of the MD5 program for        *   FILE 900\n//*                 REXX.  This must be linked with the MD5SUM      *   FILE 900\n//*                 TSO command.                                    *   FILE 900\n//*                                                                 *   FILE 900\n//*      MD5A     - Assembler source for same MD5 subprogram,       *   FILE 900\n//*                 with inline macros changed for IFOX00           *   FILE 900\n//*                 assembler.  Intended for MVS370 systems.        *   FILE 900\n//*                                                                 *   FILE 900\n//*      MD5R     - Assembler source for same MD5 subprogram,       *   FILE 900\n//*                 with 8 STCM instructions replaced with 2        *   FILE 900\n//*                 STRV.  STRV is comparatively new, from circa    *   FILE 900\n//*                 2002.  STRV is like ST but the bytes are        *   FILE 900\n//*                 stored in reverse order, as in hex 12345678     *   FILE 900\n//*                 being stored as hex 78563412. The MVS 3.8       *   FILE 900\n//*                 assembler IFOX00 does not support the STRV      *   FILE 900\n//*                 op code.                                        *   FILE 900\n//*                                                                 *   FILE 900\n//*      MD5COB$  - JCL to compile and run an Enterprise Cobol      *   FILE 900\n//*                 program that calls the MD5 subroutine.          *   FILE 900\n//*                                                                 *   FILE 900\n//*      MD5DATA  - JCL to create test data for MD5SUM, the same    *   FILE 900\n//*                 test data used in MD5REXX                       *   FILE 900\n//*                                                                 *   FILE 900\n//*      MD5FORT$ - JCL to compile and run a Fortran G program      *   FILE 900\n//*                 that calls the MD5 subroutine.                  *   FILE 900\n//*                                                                 *   FILE 900\n//*      MD5PGM   - Batch program to produce the same output as     *   FILE 900\n//*                 the MD5SUM command.                             *   FILE 900\n//*                                                                 *   FILE 900\n//*      MD5P24   - 24-bit version of MV5PGM.                       *   FILE 900\n//*                                                                 *   FILE 900\n//*      MD5PLI$  - JCL to compile and run an Enterprise PL/I       *   FILE 900\n//*                 program that calls the MD5 subroutine.          *   FILE 900\n//*                                                                 *   FILE 900\n//*      MD5REXX  - A copy of the source code for the MD5 for       *   FILE 900\n//*                 REXX by Leland Lucius, which was the base       *   FILE 900\n//*                 from which member MD5 was created.              *   FILE 900\n//*                                                                 *   FILE 900\n//*      MD5SUM   - assembler source for the 31-bit MD5SUM TSO      *   FILE 900\n//*                 command.  It calls the MD5 subprogram.          *   FILE 900\n//*                       (Fix. DS1LSTAR is always 0 for a PDSE,    *   FILE 900\n//*                        so always read the dataset even if       *   FILE 900\n//*                        DS1LSTAR is 0.)                          *   FILE 900\n//*                                                                 *   FILE 900\n//*      MD5SUM$  - JCL to assemble MD5SUM and the MD5              *   FILE 900\n//*                 subprogram.                                     *   FILE 900\n//*                                                                 *   FILE 900\n//*      MD5SUM#  - TSO HELP text for the MD5SUM TSO command.       *   FILE 900\n//*                                                                 *   FILE 900\n//*      MD5SUMA$ - JCL to assemble MD5SUM24 and MD5A using         *   FILE 900\n//*                 IFOX00.  Intended for MVS370 systems.           *   FILE 900\n//*                                                                 *   FILE 900\n//*      MD5SUM2$ - JCL to assemble MD5SUM24 and MD5 using          *   FILE 900\n//*                 ASMA90.                                         *   FILE 900\n//*                                                                 *   FILE 900\n//*      MD5SUM24 - Assembler source for the 24-bit MD5SUM TSO      *   FILE 900\n//*                 command, which is the base from which the       *   FILE 900\n//*                 31-bit version was converted. Much of this      *   FILE 900\n//*                 code was borrowed from the COUNT TSO command    *   FILE 900\n//*                 in File 300.  Intended for MVS 3.8 systems.     *   FILE 900\n//*                                                                 *   FILE 900\n//*      MD5URL   - Information about testing Leland Lucius's code  *   FILE 900\n//*                 in MD5REXX                                      *   FILE 900\n//*                                                                 *   FILE 900\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CKS@": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00$\\x01 \\x16\\x7f\\x01 \\x16\\x7f\\x122\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-06-15T00:00:00", "modifydate": "2020-06-15T12:32:24", "lines": 29, "newlines": 29, "modlines": 0, "user": "UPDATED"}, "text": "//*      CKS@     - this member\n//*\n//*      CKSPGM   - assembler source for the CKSPGM batch program\n//*                 which is independent from the CKSUM TSO command.\n//*\n//*      CKSPGM$  - JCL to assemble CKSPGM and the CKSUMR subprogram.\n//*\n//*      CKSUM    - assembler source for the 31-bit CKSUM TSO command.\n//*                 It calls the CKSUMR subprogram.\n//*\n//*      CKSUM$   - JCL to assemble CKSUM and the CKSUMR subprogram.\n//*\n//*      CKSUM#   - TSO HELP text for the CKSUM TSO command.\n//*\n//*      CKSUMR   - assembler source for CKSUMR subprogram\n//*                 This must be linked with the CKSUM TSO command,\n//*                 and the CKSPGM program.\n//*\n//*      CKSUMR24 - assembler source for same CKSUMR subprogram,\n//*                 with AMODE and RMODE removed for IFOX00 assembler.\n//*                 Intended for MVS 3.8 systems.\n//*\n//*      CKSUM24  - assembler source for the 24-bit CKSUM TSO command.\n//*                 Intended for MVS 3.8 systems.\n//*\n//*      CKSUM24$ - JCL to assemble CKSUM24 and CKSUMR24 using the\n//*                 MVS 3.8 IFOX00 assembler, and link as the\n//*                 24-bit CKSUM TSO command.\n//*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CKSPGM": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x16\\x01 \\x16\\x7f\\x01 \\x16\\x7f\\x10H\\x01\\xfb\\x01\\xfb\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-06-15T00:00:00", "modifydate": "2020-06-15T10:48:16", "lines": 507, "newlines": 507, "modlines": 0, "user": "UPDATED"}, "text": "         TITLE '   C K S P G M   '\n************************************************************\n*                                                          *\n*        'CKSPGM' PROGRAM                                  *\n*                                                          *\n************************************************************\n         SPACE\n*  COMPUTE AND WRITE A CHECKSUM OF THE CONTENTS OF THE INPUT.\n*  THE CHECKSUM IS THE SAME TYPE USED IN THE\n*  Z/OS UNIX SYSTEM SERVICES 'CKSUM' COMMAND, AND IN THE\n*  'CKSUM' COMMAND IN AIX, LINUX, AND PROBABLY OTHER SYSTEMS.\n*  ALL OF THE CHECKSUM PROCESSING IS DONE IN THE SEPARATE\n*  'CKSUMR' SUBROUTINE CALLED BY THIS PROGRAM.\n*\n* WRITTEN JUNE 15 2020\n* UPDATED JUNE 15 2020\n*\n* DDNAMES: SYSUT1 (INPUT) AND SYSUT2 (OUTPUT)\n*\n* MUST BE LINKED WITH SUBPROGRAM 'CKSUMR'.\n*\n* IF PARM CONTAINS 'R' THEN RDW'S WILL BE INCLUDED IF INPUT IS V.\n* IF PARM CONTAINS 'L' THEN RESULT WILL BE SHOWN IN LOWERCASE.\n* IF PARM CONTAINS 'E' THEN RESULT WILL INCLUDE THE DATA SET NAME,\n* BUT ONLY THE FIRST DATA SET NAME IF CONCATENATED DATA SETS.\n*\n* OUTPUT WILL BE A FIXED-LENGTH 80-BYTE RECORD FILE,\n* UNLESS THE OUTPUT FILE ALREADY HAS OTHER ATTRIBUTES.\n*\n* MUCH OF THE SOURCE CODE IS BORROWED FROM MAKEB64 IN CBT FILE 741,\n* ALTHOUGH THAT PROGRAM HAS NOTHING TO DO WITH CHECKSUMS.\n*\n* CALL CKSUMR(IREC,80,CKSCTX,CKXRES,CKXWRK)\n*\n* DISCLAIMER: NO GUARANTEE; NO WARRANTY; INSTALL/USE AT YOUR OWN RISK.\n*\n* SAMPLE JCL:\n*  //STEPNAME EXEC PGM=CKSPGM\n*  //SYSUT1 DD DSN=HLQ.INPUT.DATA,DISP=SHR\n*  //SYSUT2 DD SYSOUT=*\n*\n* LOG OF CHANGES:\n         SPACE\nCKSPGM   RMODE ANY\nCKSPGM   AMODE 31\nCKSPGM   CSECT\n         USING *,R10\n         B     @PROLOG-*(,R15)\n         DC    AL1(7),CL7'CKSPGM'\n         DC    CL16' &SYSDATE &SYSTIME '\n@SIZE    DC    0F'0',AL1(0),AL3(@DATAL)\n@PROLOG  STM   14,12,12(13)\n         LR    R10,R15\n         LR    R2,R1               POINT R2 TO PARM ADDRESS\n         L     R0,@SIZE\n         STORAGE OBTAIN,LENGTH=(0)\n         LR    R9,R1               POINT R9 TO OBTAINED AREA\n         XC    0(@CLEARL,R9),0(R9)\n         USING @DATA,R9\n         ST    R13,4(,R9)          OLD ADDRESS IN NEW SAVE AREA\n         ST    R9,8(,R13)          NEW ADDRESS IN OLD SAVE AREA\n         LR    R13,R9              POINT R13 TOP NEW SAVE AREA\n         SPACE\n*\n*         GET STORAGE BELOW THE LINE FOR DCB'S ETC.\n*\n         LA    R0,@DATA24L\n         STORAGE OBTAIN,LENGTH=(0),LOC=24\n         LR    R8,R1               POINT R8 TO OBTAINED AREA\n         USING @DATA24,R8\n         SPACE\n         L     R1,0(,R2)           POINT TO PARM\n         LH    R14,0(,R1)          LENGTH OF PARM\n         LTR   R14,R14\n         BZ    PARMX\n         LA    R15,2(,R1)\nPARMLOOP CLI   0(R15),C'R'         IF PARM CONTAINS R (FOR RDW)\n         BNE   *+8                   THEN\n         MVI   OPTR,1                TURN ON RDW OPTION\n         CLI   0(R15),C'L'         IF PARM CONTAINS L (FOR LOWERCASE)\n         BNE   *+8                   THEN\n         MVI   OPTL,1                TURN ON LOWERCASE OPTION\n         CLI   0(R15),C'E'         IF PARM CONTAINS E (FOR EXTRA INFO)\n         BNE   *+8                   THEN\n         MVI   OPTE,1                TURN ON EXTRA OPTION\n         LA    R15,1(,R15)\n         BCT   R14,PARMLOOP\nPARMX    EQU   *\n         SPACE\n         LA    R15,12\n         ST    R15,RETCODE\n         SPACE\n         LA    R3,UT1DCBW\n         LA    R4,UT2DCBW\n         MVC   0(UT1DCBL,R3),UT1DCB\n         MVC   0(UT2DCBL,R4),UT2DCB\n         TM    0(R2),X'80'         ONLY 1 PARAMETER\n         BO    NODD                YES, BYPASS DD ROUTINE\n         L     R14,4(,R2)          POINT TO DDNAME LIST\n         LH    R1,0(,R14)          GET LENGTH OF DDNAME LIST\n         LA    R14,2(,R14)         POINT PAST LENGTH\n         SPACE\n*        CH    R1,=H'48'           LONG ENOUGH FOR SYSPRINT\n*        BL    NODD                NO, BRANCH\n*        CLI   40(R14),0           SYSPRINT OVERRIDE\n*        BE    *+10                NO, SKIP MVC\n*        MVC   DDNAM(8,R3),40(R14)\n         SPACE\n         CH    R1,=H'64'           LONG ENOUGH FOR SYSUT1\n         BL    NODD                NO, BRANCH\n         CLI   56(R14),0           SYSUT1 OVERRIDE\n         BE    *+10                NO, SKIP MVC\n         MVC   DDNAM(8,R3),56(R14)                                .FIX.\n         SPACE\n         CH    R1,=H'72'           LONG ENOUGH FOR SYSUT2\n         BL    NODD                NO, BRANCH\n         CLI   64(R14),0           SYSUT2 OVERRIDE\n         BE    *+10                NO, SKIP MVC\n         MVC   DDNAM(8,R4),64(R14)                                .FIX.\nNODD     EQU   *\n         SPACE\n         LA    R5,UT1DCBEW\n         LA    R6,UT2DCBEW\n         MVC   0(UT1DCBEL,R5),UT1DCBE\n         MVC   0(UT2DCBEL,R6),UT2DCBE\n         ST    R5,0(,R3)           ST    R5,DCBDCBE-IHADCB(,R3)\n         ST    R6,0(,R4)           ST    R5,DCBDCBE-IHADCB(,R3)\n         SPACE\n**********************************************************************\n*              OPEN INPUT DCB\n**********************************************************************\n         LA    R1,UT1EXLST         POINT TO INPUT DCB EXIT LIST\n         STCM  R1,7,EXLST+1(R3)    STORE ADDRESS OF EXIT LIST IN DCB\n         LA    R15,JFCB\n         ST    R15,0(,R1)          1ST EXLST WORD\n         MVI   0(R1),X'87'         JFCB ADDRESS FOR RDJFCB\n         SPACE\n         MVI   UT1RDJF,X'80'\n         RDJFCB ((R3)),MF=(E,UT1RDJF)\n         SPACE\n         MVC   OPEN31W(OPEN31L),OPEN31\n         OPEN  ((R3),INPUT),MODE=31,MF=(E,OPEN31W)\n*        TM    OFLGS(R3),X'10'     TEST FOR SUCCESSFUL OPEN\n*        TM    16(R5),X'C0'        TM    DCBEFLG1,DCBEOPEN+DCBEMD31\n*        TM    DCBEFLG1-DCBE(R5),DCBEOPEN+DCBEMD31 OPEN AND 31-BIT SAM\n         TM    DCBEFLG1-DCBE(R5),DCBEOPEN OPEN SUCCESSFUL\n         BNO   EXIT\n         TM    DCBEFLG1-DCBE(R5),DCBEMD31 31-BIT SAM SUPPORTED?\n         BO    NOT24I              YES, NOTHING TO CHANGE\n**********************************************************************\n*              MAKE CHANGES FOR 24-BIT GET\n**********************************************************************\n         LA    R15,EOD24S          POINT TO 24-BIT EODAD LOCATION\n         MVC   0(EOD24L,R15),EOD24I  COPY EOD24I CODE TO 24-BIT EODAD\n         LA    R0,UT1EOD           POINT TO 31-BIT EODAD\n*        O     R0,=A(X'80000000')  SET 31-BIT MODE IN UT1EOD ADDRESS\n         OILH  R0,X'8000'          SET 31-BIT MODE IN UT1EOD ADDRESS\n         ST    R0,EOD24P-EOD24I(,R15) STORE UT1EOD ADDRESS AND MODE\n         ST    R15,DCBEEODA-DCBE(R5) CHANGE DCBE EODAD TO EOD24S\n         MVC   GET24S(GET24L),GET24I COPY 24-BIT GET\nNOT24I   EQU   *\n**********************************************************************\n*              OPEN OUTPUT DCB\n**********************************************************************\n         LA    R1,UT2EXLST         POINT TO OPEN EXIT LIST\n         STCM  R1,7,EXLST+1(R4)    STORE ADDRESS OF EXIT LIST IN DCB\n         LA    R15,UT2OPENX        POINT TO OPEN EXIT ENTRY POINT\n         ST    R15,0(,R1)          STORE ADDRESS OF EXIT IN EXIT LIST\n         MVI   0(R1),X'85'         SET HIGH BYTE OF EXIT LIST\n         MVC   0(UT2OPENL,R15),UT2GLUE  COPY EXIT TO 24-BIT STORAGE\n         LA    R0,UT2EXIT          POINT TO 31-BIT EXIT\n*        O     R0,=A(X'80000000')  SET 31-BIT MODE IN ADDRESS\n         OILH  R0,X'8000'          SET 31-BIT MODE IN ADDRESS\n         ST    R0,UT2GLUEP-UT2GLUE(,R15) STORE EXIT ADDRESS FOR GLUE\n         SPACE\n         OPEN  ((R4),OUTPUT),MODE=31,MF=(E,OPEN31W)\n         TM    DCBEFLG1-DCBE(R6),DCBEOPEN OPEN SUCCESSFUL\n         BNO   EXITC1\n*        TM    DCBEFLG1-DCBE(R6),DCBEMD31 31-BIT SAM SUPPORTED?\n*        BNO   EXITC2              NO, CLOSE OUTPUT AND QUIT\n         SPACE\n**********************************************************************\n*              SET UP CKSUMR PARAMETER LIST\n**********************************************************************\n         LA    R1,CKXARGS\n         XC    CKXCTX(12),CKXCTX\n         LA    R0,CKXLEN\n         ST    R0,4(,R1)  2ND ARG\n         LA    R0,CKXCTX\n         ST    R0,8(,R1)  3RD ARG\n         LA    R0,CKXRES\n         ST    R0,12(,R1) 4TH ARG\n         LA    R0,CKXWRK\n*        O     R0,=A(X'80000000')  LAST PARAMETER\n         OILH  R0,X'8000'          LAST PARAMETER\n         ST    R0,16(,R1) 5TH ARG\n         SPACE\n**********************************************************************\n*              READ A RECORD\n**********************************************************************\nREADLOOP EQU   *\n         LA    R5,UT1DCBEW\n         TM    DCBEFLG1-DCBE(R5),DCBEMD31 31-BIT SAM SUPPORTED?\n         BNO   GET24               NO, USE 24-BIT MOOE FOR GET\n         GET   (R3)\n         B     GETRET\nGET24    LA    R15,GET24S\n*        MVC   0(GET24L,R15),GET24I (ALREADY MOVED, ONCE IS ENOUGH)\n         ST    R13,SAVE24+4        SAVE R13\n         LA    R13,SAVE24          GET NEEDS R13 TO POINT BELOW LINE\n         BASSM R7,R15              RUN GET IN 24-BIT MODE\n         L     R13,SAVE24+4        RESTORE R13\n         SPACE\nGETRET   LR    R5,R1               POINT TO RECORD\n         TM    RECFM(R3),X'C0'     RECFM U\n         BO    GETU\n         TM    RECFM(R3),X'80'     RECFM F\n         BO    GETF\nGETV     LA    R0,4\n         LH    R7,0(,R5)           LENGTH+4 FROM RDW\n         CLI   OPTR,0              IF R IN PARM\n         BNE   GOT                    INCLUDE RDW\n         AR    R5,R0               POINT PAST RDW\n         SR    R7,R0               REDUCE LENGTH\n         B     GOT\nGETU     LH    R7,LRECL(,R3)\n         B     GOT\nGETF     LH    R7,LRECL(,R3)       GET LENGTH FROM LRECL\n         TM    RECFM(R3),X'10'     IF NOT BLOCKED\n         BO    *+8                   THEN\n         LH    R7,BLKSI(,R3)         USE BLKSIZE AS LENGTH\n**********************************************************************\n*              CALL CKSUMR FOR EACH RECORD\n**********************************************************************\n*              CALL CKSUMR FOR EACH RECORD READ\nGOT      ST    R5,CKXARGS          RECORD ADDRESS\n         ST    R7,CKXLEN           RECORD LENGTH\n         LA    R1,CKXARGS\n         L     R15,=V(CKSUMR)\n         CALL  (15)\n         B     READLOOP\n         SPACE\n**********************************************************************\n*              END-OF-FILE, CALL CKSUMR ONE LAST TIME\n**********************************************************************\nUT1EOD   EQU   *\n         SR    R0,R0               LENGTH ZERO FOR FINAL CALL\n         ST    R0,CKXLEN\n         LA    R1,CKXARGS\n         L     R15,=V(CKSUMR)\n         CALL  (15)\n**********************************************************************\n*              OUTPUT THE RESULTS\n**********************************************************************\n         MVI   OBUF,C' '\n         MVC   OBUF+1(255),OBUF\n*        MVC   ORDW(4),=AL2(36,0)\n         LA    R15,OBUF\n         TM    RECFM(R4),X'04'     IF ASA CARRIAGE CONTROL\n         BZ    NOTASA                THEN\n         LA    R15,1(,R15)           POINT PAST 1ST COLUMN\nNOTASA   EQU   *\n         LA    R1,CKXRES+12        POINT TO 12-BYTE RESULT DIGITS\n         LA    R0,12\nSLOOP1   CLI   0(R1),C' '          IF LEADING BLANK\n         BE    SNEXT1               IGNORE IT\n         MVC   0(1,R15),0(R1)      ELSE COPY DIGIT TO MSGWK\n         LA    R15,1(,R15)          POINT TO NEXT DEST BYTE\nSNEXT1   LA    R1,1(,R1)           POINT TO NEXT SRC BYTE\n         BCT   R0,SLOOP1           LOOP UNTIL ALL 12 DONE\n         MVI   0(R15),C' '         SPACE BETWEEN\n         LA    R15,1(,R15)         POINT TO NEXT DEST BYTE\n*                                  R1 POINTS TO 16-BYTE COUNT DIGITS\n         LA    R0,16               NUMBER OF CHARACTERS\nSLOOP2   CLI   0(R1),C' '          IF LEADING BLANK\n         BE    SNEXT2               IGNORE IT\n         MVC   0(1,R15),0(R1)      ELSE COPY DIGIT TO MSGWK\n         LA    R15,1(,R15)          POINT TO NEXT DEST BYTE\nSNEXT2   LA    R1,1(,R1)           POINT TO NEXT SRC BYTE\n         BCT   R0,SLOOP2           LOOP UNTIL ALL 16 DONE\n         LR    R1,R15              SET R1 FOR SETLEN\n         CLI   OPTE,1              IF NO 'E' IN PARM, (SHOW DSN)\n         BNE   SETLEN                GO TO SETLEM\n         MVI   0(R15),C' '         SPACE BETWEEN\n         LA    R15,1(,R15)         POINT TO NEXT DEST BYTE\n         MVC   0(44,R15),JFCB      COPY DSNAME\n         LA    R1,43(,R15)         LAST CHAR OF DSNAME\n         LA    R0,44               INITIAL LENGTH\nFILEA    CLI   0(R1),C' '          IS THIS LAST NONBLANK\n         BNE   FILEB               YES, BRANCH\n         BCTR  R1,0                BACK UP 1 CHARACTER\n         BCT   R0,FILEA            DECREMENT LENGTH AND BRANCH\nFILEB    LA    R1,1(,R1)           POINT PAST LAST CHAR\n         CLI   JFCB+44,C' '        IF NO MEMBER IN JFCB\n         BE    SETLEN                GO TP SETLEM\n         MVI   0(R1),C'('\n         MVC   1(8,R1),JFCB+44     JFCBELNM IN IEFJFCBN\n         LA    R1,8(,R1)           LAST CHAR OF MEMBER NAME\n         LA    R0,8\nMEMA     CLI   0(R1),C' '\n         BNE   MEMB\n         BCTR  R1,0\n         BCT   R0,MEMA\nMEMB     MVI   1(R1),C')'\n         LA    R1,1(,R1)           POINT PAST LAST CHAR\nSETLEN   LA    R0,OBUF\n         SR    R1,R0               COMPUTE LENGTH\nNONAME   EQU   *\n         CLI   OPTL,1              IF 'L' IN PARM, FOR LOWERCASE\n         BNE   *+10                  THEN\n         TR    OBUF(256),LOWER       TRANSLATE TO LOWER CASE\n         LA    R0,OBUF             PUT WILL USE R0 AS RECORD ADDRESS\nPUTU     TM    RECFM(R4),X'C0'     IF OUTPUT RECFM U\n         BNO   PUTV\n         STH   R1,LRECL(,R4)       SET RECFM U RECORD SIZE\n         B     PUTT\nPUTV     TM    RECFM(R4),X'40'     IF RECFM V\n         BZ    PUTT                  THEN\n         LA    R1,4(,R1)             LENGTH + 4 FOR RDW\n         LH    R0,LRECL(,R4)         GET LRECL\n         CR    R1,R0                 IF LONGER THAN LRECL\n         BNH   *+6                     THEN\n         LR    R1,R0                   TRUNCATE TO LRECL\n         SLL   R1,16                 SHIFT LEFT 16 BITS\n         ST    R1,ORDW               SET RDW\n         LA    R0,ORDW               USE RDW FOR PUT\nPUTT     TM    DCBEFLG1-DCBE(R6),DCBEMD31 31-BIT SAM SUPPORTED?\n         BNO   PUT24               NO, USE 24-BIT MOOE FOR PUT\n         PUT   (R4),(0)\n         B     EXIT0\nPUT24    LA    R15,PUT24S\n         MVC   0(PUT24L,R15),PUT24I\n         ST    R13,SAVE24+4        SAVE R13\n         LA    R13,SAVE24          PUT NEEDS R13 TO POINT BELOW LINE\n         BASSM R7,R15              RUN PUT IN 24-BIT MODE\n         L     R13,SAVE24+4        RESTORE R13\n         B     EXIT0\n         SPACE\n*        THE FOLLOWING INSTRUCTIONS FROM PUT24I TO PUT24L ARE COPIED\n*        TO STORAGE BELOW THE LINE AND ARE CALLED BY THE BASSM ABOVE.\n*        THEY RUN IN 24-BIT MODE SO THE PUT WILL WORK FOR A TERMINAL.\n*        THEY DON'T USE A BASE REGISTER, SO THAT SIMPLIFIES IT.\nPUT24I   PUT   (R4),(0)\n         BSM   0,R7\nPUT24L   EQU   *-PUT24I\n         SPACE\n*        THE FOLLOWING INSTRUCTIONS FROM GET24I TO GET24L ARE COPIED\n*        TO STORAGE BELOW THE LINE AND ARE CALLED BY A BASSM.\nGET24I   GET   (R3)\n         BSM   0,R7\nGET24L   EQU   *-GET24I\n         SPACE\nEXITN    CLI   RETCODE+3,12        IF AN ERROR OCCURRED\n         BNE   EXITC2                DON'T SET RC 0\nEXIT0    MVI   RETCODE+3,0\nEXITC2   MVC   CLOSE31W(CLOSE31L),CLOSE31\n         CLOSE ((R4)),MODE=31,MF=(E,CLOSE31W)\n*        LR    R7,R4\n*        BAL   R2,FREEPOOL\nEXITC1   MVC   CLOSE31W(CLOSE31L),CLOSE31\n         CLOSE ((R3)),MODE=31,MF=(E,CLOSE31W)\n*        LR    R7,R3\n*        BAL   R2,FREEPOOL\n         B     EXIT\n*REEPOOL FREEPOOL (R7)\n*        BR    R2\nEXIT     L     R2,RETCODE\n         LR    R1,R8\n         LA    R0,@DATA24L\n         STORAGE RELEASE,ADDR=(1),LENGTH=(0)\n         LR    R1,R13\n         L     R0,@SIZE\n         L     R13,4(,R13)\n         STORAGE RELEASE,ADDR=(1),LENGTH=(0)\n         DROP  R9\n         LR    R15,R2\n         LM    0,12,20(R13)\n         L     R14,12(,R13)\n         BR    R14\n         SPACE\n*         DCB OPEN EXIT\nUT2EXIT  CLI   RECFM(R1),0         IF NO RECFM\n         BNE   UT2EXI2                THEN\n         MVI   RECFM(R1),X'90'        USE FB\nUT2EXI2  TM    RECFM(R1),X'10'     IF BLOCKED\n         BZ    UT2EXI3                AND\n         CLC   LRECL(2,R1),=H'0'      NO LRECL\n         BNE   UT2EXI3                THEN\n         MVC   LRECL(2,R1),=H'80'     USE 80\nUT2EXI3  CLC   BLKSI(2,R1),=H'0'   IF NO BLKSIZE\n         BNE   UT2EXI4                THEN\n         MVC   BLKSI(2,R1),LRECL(R1)  USE LRECL\nUT2EXI4  BR    R14\n         SPACE\n*        THIS ROUTINE IS COPIED TO 24-BIT STORAGE\n*        IT IS ENTERED IN 24-BIT MODE, CALLS UT2EXIT IN 31-BIT MODE\n*        LEAVING ORIGINAL R14 RETURN ADDRESS IN R14\n         CNOP  0,4                 ALIGN ON FULLWORD\nUT2GLUE  L     R15,UT2GLUEP-*(,R15)   GET ADDRESS OF UT2EXIT\n         BSM   R14,R15             CALL UT2EXIT WITH OLD MODE IN R14\nUT2GLUEP DC    F'0'                WILL CONTAIN ADDRESS OF UT2EXIT\nUT2OPENL EQU   *-UT2GLUE\n         SPACE\n*        THIS ROUTINE IS COPIED TO 24-BIT STORAGE\n*        IT IS ENTERED IN 24-BIT MODE, GOES TO UT1EOD IN 31-BIT MODE\n         CNOP  0,4                 ALIGN ON FULLWORD\nEOD24I   L     R15,EOD24P-*(,R15)  GET ADDRESS OF UT1EOD AND 31-BIT\n         L     R13,SAVE24+4        RESTORE R13 CHANGED BEFORE GET\n         BSM   R0,R15              GOTO UT1EOD IN 31-BIT MODE\nEOD24P   DC    F'0'                WILL CONTAIN ADDRESS OF UT2EXIT\nEOD24L   EQU   *-EOD24I\n         SPACE\n         LTORG\n         DC    0D'0'\n         PRINT NOGEN\nUT1DCB   DCB   DDNAME=SYSUT1,DSORG=PS,MACRF=(GL),EODAD=0,DCBE=0\nUT1DCBL  EQU   *-UT1DCB\nUT1DCBE  DCBE  RMODE31=BUFF,EODAD=UT1EOD\nUT1DCBEL EQU   *-UT1DCBE\nUT2DCB   DCB   DDNAME=SYSUT2,DSORG=PS,MACRF=(PM),EXLST=0,DCBE=0\nUT2DCBL  EQU   *-UT2DCB\nUT2DCBE  DCBE  RMODE31=BUFF\nUT2DCBEL EQU   *-UT2DCBE\nUT1EXL   DC    0F'0',X'87',AL3(0)\nUT2EXL   DC    0F'0',X'85',AL3(0)\nOPEN31   OPEN  (0,),MODE=31,MF=L\nOPEN31L  EQU   *-OPEN31\nCLOSE31  CLOSE (0,),MODE=31,MF=L\nCLOSE31L EQU   *-CLOSE31\n         DC    0D'0'\nLOWER    DC    256AL1(*-LOWER)\n         ORG   LOWER+C'A'\n         DC    X'818283848586878889'\n         ORG   LOWER+C'J'\n         DC    X'919293949596979899'\n         ORG   LOWER+C'S'\n         DC    X'A2A3A4A5A6A7A8A9'\n         ORG\n         DC    0D'0'\n         SPACE\n@DATA    DSECT\n         DS    18F\nRETCODE  DS    F\nOPEN31W  DS    F\nCLOSE31W DS    F\nOPTE     DS    H\nOPTL     DS    H\nOPTR     DS    H\n@CLEARL  EQU   *-@DATA\nUT1DCBEW DS    0F,(UT1DCBEL)X\nUT2DCBEW DS    0F,(UT2DCBEL)X\nCKXARGS  DS    5F\nCKXLEN   DS    F\nCKXCTX   DS    3F  (CKSUMR NEEDS 3F)\nCKXRES   DS    10F (CKSUMR NEEDS 10F)\nCKXWRK   DS    30F (CKSUMR NEEDS 30F)\nCKXSAVE  DS    F\n         DS    0D\n@DATAL   EQU   *-@DATA\n         SPACE\n@DATA24  DSECT\nSAVE24   DS    18F\nUT1DCBW  DS    0F,(UT1DCBL)X\nUT2DCBW  DS    0F,(UT2DCBL)X\nUT1EXLST DS    F\nUT2EXLST DS    F\nUT1RDJF  DS    F\nUT2OPENX DS    0F,(UT2OPENL)X  GLUE ROUTINE COPIED HERE\nGET24S   DS    0H,(GET24L)X\nPUT24S   DS    0H,(PUT24L)X\nEOD24S   DS    0H,(EOD24L)X\n*        OUTPUT BUFFERS ARE HERE IN CASE PUT TO TERMINAL, DCBEMD31 OFF\nORDW     DS    F\nOBUF     DS    256C\n         DS    0D\nJFCB     DS    CL176\n         DS    0D\n@DATA24L EQU   *-@DATA24\n         SPACE\n         PRINT NOGEN\n         IHADCBE\n         SPACE\n*         EQUATES FOR DCB FIELD OFFSETS\nEXLST    EQU   36\nRECFM    EQU   36\nDDNAM    EQU   44\nOFLGS    EQU   48\nBLKSI    EQU   62\nLRECL    EQU   82\n         SPACE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CKSPGM$": {"ttr": 774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x007\\x01 \\x16\\x7f\\x01 \\x16\\x7f\\x11&\\x00\\x11\\x00\\x11\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-06-15T00:00:00", "modifydate": "2020-06-15T11:26:37", "lines": 17, "newlines": 17, "modlines": 0, "user": "UPDATED"}, "text": "//CBTUSER1 JOB (ACCT),'PGMRNAME',NOTIFY=CBTUSER,\n//         MSGLEVEL=(1,1),MSGCLASS=H\n//ASM     EXEC PGM=ASMA90,\n//             PARM=(LIST,OBJ,NODECK,ASA,NOXREF,NODX,NOMX,NORX,NOUS,\n//             BATCH,'PC(NOUHD)')\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//SYSLIN   DD  DSN=&&OBJ,DISP=(NEW,PASS),SPACE=(TRK,(3,3)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=800)\n//SYSIN    DD  DSN=CBTUSER.LIB.ASM(CKSPGM),DISP=SHR\n//         DD  DSN=CBTUSER.LIB.ASM(CKSUMR),DISP=SHR\n//LKED   EXEC PGM=HEWLF064,PARM='MAP,NOXREF,RENT,REFR',\n//             COND=(0,NE)\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSNAME=&&OBJ,DISP=(OLD,DELETE)\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(TRK,(10,0))\n//SYSLMOD  DD  DSN=CBTUSER.LIB.LOAD(CKSPGM),DISP=SHR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CKSUM": {"ttr": 776, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00'\\x01 \\x16o\\x01 \\x16o X\\x04\\xb2\\x04\\xb2\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-06-14T00:00:00", "modifydate": "2020-06-14T20:58:27", "lines": 1202, "newlines": 1202, "modlines": 0, "user": "UPDATED"}, "text": "         TITLE '   C K S U M  '\n************************************************************\n*                                                          *\n*        'CKSUM' TSO COMMAND (31-BIT)                      *\n*                                                          *\n************************************************************\n         SPACE\n*  COMPUTE AND DISPLAY A CHECKSUM OF THE CONTENTS OF A DATASET,\n*  OR THE SEPARATE CHECKSUMS OF A LIST OF DATA SETS.\n*  THE CHECKSUM IS THE SAME TYPE USED IN THE\n*  Z/OS UNIX SYSTEM SERVICES 'CKSUM' COMMAND, AND IN THE\n*  'CKSUM' COMMAND IN AIX, LINUX, AND PROBABLY OTHER SYSTEMS.\n*  ALL OF THE CHECKSUM PROCESSING IS DONE IN THE SEPARATE\n*  'CKSUMR' SUBROUTINE CALLED BY THIS COMMAND.\n*\n*  WRITTEN MAY 31 2020 USING SOURCE CODE FOR THE 'MD5SUM'\n*  COMMAND IN FILE 900 OF THE CBT TAPE, WHICH IN TURN\n*  USED SOURCE CODE FROM THE 'COUNT' COMMAND IN FILE 300.\n*\n*  ATTRIBUTES. RE-ENTRANT.\n*\n*  THIS TSO COMMAND READS THE SPECIFIED SEQUENTIAL DATA SETS\n*  OR PDS MEMBERS AND DISPLAYS A CHECKSUM FOR EACH.\n*\n*        IF AN UNQUALIFIED DATA SET NAME IS ENTERED, THE\n*        CATALOG MUST BE READ TWICE, ONCE TO APPEND A\n*        TRAILING QUALIFIER IF NECESSARY, AND AGAIN DURING\n*        ALLOCATION. THE USER CAN ELIMINATE THE FIRST BY USING\n*        THE FULLY QUALIFIED NAME, PREFIX AND ALL, IN QUOTES,\n*        OR BY ENTERING ALL BUT THE PREFIX, WITHOUT QUOTES,\n*        PLUS THE KEYWORD 'Q'. THE LATTER IS MUCH SIMPLER\n*        AND GIVES THE SAME PERFORMANCE IMPROVEMENT AS A\n*        FULLY QUALIFIED NAME.\n*\n*        THE 'FILE' KEYWORD IS USEFUL FOR READING TEMPORARY\n*        DATA SETS.  IT TELLS THE COMMAND TO TREAT THE FIRST\n*        OPERAND AS A FILENAME (DDNAME) INSTEAD OF A DSNAME.\n*        WHATEVER DATA SET IS CURRENTLY ALLOCATED TO THE\n*        FILENAME WILL BE READ (AND QUICKLY, BECAUSE\n*        THE COMMAND DOESNT HAVE TO ALLOCATE ANYTHING).\n*\n*        UNIX FILES THAT ARE PREALLOCATED TO A DDNAME CAN BE\n*        READ. FOR EXAMPLE:\n*         ALLOC FI(DD1) PATH('/ETC/MAGIC') (BUT USE PATH IN LOWER CASE)\n*         CKSUM DD1 FILE\n*        IF UNIX FILES ARE NOT GIVEN RECFM WHEN ALLOCATED\n*        THEY DEFAULT TO RECFM=U, WHICH IS GOOD FOR CKSUM.\n*        RECFM=F WOULD BE LIKELY TO INTRODUCE PADDING IN THE\n*        LAST RECORD, WHICH WOULD CHANGE THE CKSUM RESULT.\n*\n*        NOTE - IF A NON-EXISTENT MEMBER OF A PDS IS SPECIFIED,\n*        THE RESULTING 013-18 ABEND IS TRAPPED BY A DCB ABEND\n*        EXIT, BUT A MESSAGE IS ISSUED BY OPEN ANYWAY. THIS\n*        METHOD IS USED BECAUSE THE ADDITIONAL OVERHEAD\n*        OF ALLOCATING THE PDS AND DOING A 'BLDL' WOULD\n*        DEGRADE THE PERFORMANCE UNACCEPTABLY.\n*\n*         INTERCEPT 'LINK' MACRO IMBEDDED IN STACK MACRO\n*         TO MAKE SF=(E,LINKAREA) THE DEFAULT.\n         MACRO\n&NAME    LINK  &EP=,&SF=(E,LINKAREA)\n&NAME    LA    15,&SF(2)\n         LA    0,*+8\n         B     *+12\n         DC    CL8'&EP'\n         ST    0,0(0,15)\n         SVC   6             ISSUE LINK SVC\n         MEND\n         SPACE\nCKSUM    START\nCKSUM    AMODE 31\nCKSUM    RMODE 31\n         USING *,R12,R11\n         B     @PROLOG-*(,R15)\n         DC    AL1(7),CL7'CKSUM'\n         DC    CL16' &SYSDATE &SYSTIME '\n@SIZE31  DC    0F'0',AL1(0),AL3(@DATA31L)\n@SIZE24  DC    0F'0',AL1(1),AL3(@DATA24L)\n@PROLOG  STM   14,12,12(13)\n         LR    R12,R15             BASE\n         LA    R15,1\n         LA    R11,4095(R15,R12)   BASE\n         LR    R2,R1\n         USING CPPL,R2\n         L     R0,@SIZE31\n         GETMAIN RU,LV=(0),SP=1,LOC=31\n         LR    R9,R1\n         USING @DATA31,R9\n         ST    13,4(,1)            CHAIN SAVEAREA\n         ST    1,8(,13)            CHAIN SAVEAREA\n         LR    13,1                NEW SAVEAREA\n         SPACE\n         L     R0,@SIZE24\n         GETMAIN R,LV=(0)\n         LR    R10,R1\n         USING @DATA24,R10\n         SPACE\n         MVI   STATUS,0\n         XC    LINKAREA(8),LINKAREA\n         SLR   R15,R15\n         STH   R15,RETCODE         SET RETCODE = 0\n         SPACE\n************************************************************\n*                                                          *\n*        SET UP IOPL FOR PUTLINE                           *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R15,MYIOPL\n         USING IOPL,R15\n         MVC   IOPLUPT(4),CPPLUPT\n         MVC   IOPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,IOPLECB\n         XC    MYECB,MYECB\n         LA    R0,MYPTPB\n         ST    R0,IOPLIOPB\n         DROP  R15                 IOPL\n         SPACE\n         L     R15,16              LOAD CVT POINTER\n         TM    444(R15),X'80'      IS PUTLINE LOADED? (VS2)\n         BNO   PUTLOAD             NO - BRANCH TO LOAD\n         L     R15,444(,R15)       YES - USE CVTPUTL\n         B     PUTLOADX            BRANCH AROUND LOAD\nPUTLOAD  LA    R0,=CL8'IKJPUTL '\n         LOAD  EPLOC=(0)\n         LR    R15,R0              GET ENTRY ADDRESS\n         LA    R15,0(,R15)         CLEAR HI BYTE FOR DELETE ROUTINE\nPUTLOADX ST    R15,MYPUTLEP        SAVE PUTLINE ENTRY ADDRESS\n         SPACE\n************************************************************\n*                                                          *\n*        SET UP PPL FOR PARSE                              *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R15,MYPPL\n         USING PPL,R15\n         MVC   PPLUPT(4),CPPLUPT\n         MVC   PPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,PPLECB\n         XC    MYECB,MYECB\n         L     R0,=A(CKSUMPCL)\n*        LA    R0,PCLADDR\n         ST    R0,PPLPCL\n         LA    R0,MYANS\n         ST    R0,PPLANS\n         XC    MYANS(4),MYANS\n         MVC   PPLCBUF(4),CPPLCBUF\n         ST    R9,PPLUWA\n         DROP  R15                 PPL\n         SPACE 1\n************************************************************\n*                                                          *\n*        CALL THE PARSE SERVICE ROUTINE                    *\n*                                                          *\n************************************************************\n         SPACE\n         LR    R1,R15              POINT TO PPL\n*        CALLTSSR EP=IKJPARS\n         L     R15,16              CVTPTR\n         TM    524(R15),X'80'      IF HI ORDER BIT NOT ON\n         BNO   PARSELNK               THEN DO LINK, NOT CALL\n         L     R15,524(,R15)       CVTPARS\n         BALR  R14,R15             CALL IKJPARS\n         B     PARSEEXT            SKIP AROUND LINK\nPARSELNK EQU   *\n         LINK  EP=IKJPARS,SF=(E,LINKAREA)\nPARSEEXT EQU   *\n         SPACE 1\n         LTR   R15,R15\n         BZ    PARSEOK\n         LA    R1,MSG01\n         LA    R0,L'MSG01\n         BAL   R14,PUTMSG\n         MVI   RETCODE+1,12\n         B     EXIT\nPARSEOK  EQU   *\n         SPACE\n         L     R3,MYANS\n         USING IKJPARMD,R3\n         SPACE\n************************************************************\n*                                                          *\n*        GET THE FIRST OR NEXT DSN IN THE LIST             *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R6,DSN\n         B     FIRSTDSN\nNEXTDSN  CLI   24(R6),X'FF'        END OF DSN LIST?\n         BE    DONE\n         L     R6,24(,R6)          POINT TO NEXT ENTRY\nFIRSTDSN EQU   *\n         SPACE\n************************************************************\n*                                                          *\n*        QUALIFY THE DSNAME IF NECESSARY                   *\n*                                                          *\n************************************************************\n         SPACE\n         TM    6(R6),X'80'         IS DATASET NAME SPECIFIED?\n         BO    OKDSN               YES - BRANCH\n         LA    R1,MSG05            NO - JUST MEMBER NAME\n         LA    R0,L'MSG05\n         BAL   R14,PUTMSG\n         B     NEXTD12\nOKDSN    EQU   *\n         LA    R15,DSNAME+2\n         MVI   0(R15),C' '         BLANK THE DSNAME AREA\n         MVC   1(43,R15),0(R15)\n         SLR   R1,R1\n         STH   R1,DSNAME           ZERO DSNAME LENGTH\n         TM    6(R6),X'40'         IS DSN QUOTED?\n         BO    NOPREF              YES, SKIP PREFIXING\n         CLI   FILEKW+1,1          DSN TO BE TREATED AS DDNAME\n         BE    NOPREF              YES, SKIP PREFIXING\n         L     R14,CPPLUPT         POINT TO UPT\n         USING UPT,R14\n         CLI   UPTPREFX,C'>'      IF PREFIX IS '>7BYTES' (8 BYTES)\n         BNE   PREF07                THEN\n         IC    R1,UPTPREFL+18        GET UPTPRF8L (SHOULD ALWAYS BE 8)\n         LTR   R1,R1                 IS IT ZERO\n         BZ    NOPREF                YES, SKIP PREFIXING\n         B     *+10\n         MVC   0(0,R15),UPTPREFX+17  COPY UPTPREF8\n         EX    R1,*-6              MOVE USERID TO DSNAME AREA\n         B     PREFDONE\nPREF07   IC    R1,UPTPREFL         GET LENGTH OF PREFIX\n         LTR   R1,R1               IS IT ZERO\n         BZ    NOPREF              YES, SKIP PREFIXING\n         B     *+10\n         MVC   0(0,R15),UPTPREFX\n         EX    R1,*-6              MOVE USERID TO DSNAME AREA\n         DROP  R14                 UPT\nPREFDONE LA    R15,0(R1,R15)       POINT PAST USERID\n         MVI   0(R15),C'.'         APPEND PERIOD\n         LA    R15,1(,R15)         POINT PAST PERIOD\n         LA    R1,1(,R1)           ADD 1 TO LENGTH\n         STH   R1,DSNAME           STORE LENGTH OF USERID PLUS 1\nNOPREF   EQU   *\n         LH    R1,4(,R6)           GET LENGTH\n         LR    R0,R1\n         AH    R0,DSNAME           ADD LENGTH OF PREFIX OR ZERO\n         STH   R0,DSNAME           SET COMBINED LENGTH\n         L     R14,0(,R6)          POINT TO DSN VALUE\n         BCTR  R1,0                LENGTH MINUS 1 FOR EX\n         B     *+10                BRANCH AROUND EXECUTED MVC\n         MVC   0(0,R15),0(R14)     (EXECUTED)\n         EX    R1,*-6              MOVE DSN TO DSNAME (AFTER PREFIX)\n         CH    R0,=H'44'\n         BNH   OKDSNLEN\n* DSNAME IS TOO LONG AFTER PREFIXING.\n* ISSUE MSG 'IKJ56709I INVALID DSN LENGTH, ' WITH SAME MESSAGE\n* ID AS MSG 'IKJ56709I INVALID DATA SET NAME, '\n* WHICH NORMALLY IS ISSUED BY IKJPARS AND IS NORMALLY FOLLOWED BY\n* 'IKJ56703A REENTER THIS OPERAND -'\n* BUT THIS COMMAND DOESN'T DO THE LATTER.\nERRDSNLN MVC   MSGWK(L'MSG09),MSG09\n         LA    R15,MSGWK+L'MSG09\n         LA    R14,DSNAME\n         LH    R1,0(,R14)\n         BCTR  R1,0\n         B     *+10\n         MVC   MSGWK+L'MSG09(0),2(R14)\n         EX    R1,*-6\n         LA    R15,1(R1,R15)\n         LA    R0,L'MSG09+1(,R1)\n         LA    R1,MSGWK\n         BAL   R14,PUTMSG\n         B     NEXTD12\nOKDSNLEN EQU   *\n         SPACE\n************************************************************\n*                                                          *\n*        IF 'FILE' KEYWORD IS SPECIFIED,                   *\n*        GET DSNAME FROM JFCB USING FILE NAME.             *\n*                                                          *\n************************************************************\n         SPACE\n         CLI   FILEKW+1,1          'FILE' SPECIFIED?\n         BNE   NOFILE              NO, BRANCH\n         CLI   DSNAME+1,8          IS LENGTH 8 OR LESS\n         BH    FILERR1             NO, BRANCH\n         DEVTYPE DSNAME+2,DEVDATA  GET DEVICE TYPE\n         LTR   R15,R15             WAS FILENAME VALID\n         BNZ   FILERR2             NO, BRANCH\n*        CLC   DEVDATA(8),=X'0000010300007FF8'\n*        BE    DEVOK\n*        TM    DEVDATA+2,X'20'     DIRECT ACCESS\n*        BZ    FILERR3             NO, BRANCH\nDEVOK    LA    R4,DYNDCBW\n         MVC   0(DYNDCBL,R4),DYNDCB\n         XC    DSNAME(2),DSNAME\n         XC    MEMLEN,MEMLEN\n         LA    R0,JFCB\n         LA    R1,DYNEXLST\n         ST    R0,0(,R1)\n         MVI   0(R1),X'07'\n         LA    R14,MYARL             ALLOCATION RETRIEVAL LIST\n         ST    R14,4(,R1)\n         MVI   4(R1),X'13'+X'80'\n         ST    R1,36(,R4)          DCBEXLST\n         USING ARL,R14\n         XC    0(36,R14),0(R14)\n         MVI   ARLLEN+1,36\n         MVC   ARLIDENT,=C'AR'\n         OI    ARLOPT1,ARLLANY+ARLUSS\n         MVC   40(8,R4),DSNAME+2   DCBDDNAM\n         MVC   DDSAVE,DSNAME+2\n         MVI   RDJFW,X'80'\n         RDJFCB ((R4)),MF=(E,RDJFW)\n         LA    R14,MYARL\n         L     R1,ARLAREA\n         LTR   R1,R1\n         BZ    NOARA\n         L     R0,ARLRTRVD\n         DROP  R14                 ARL\n         USING ARA,R1\nLOOPARA  TM    ARAFLG,ARAXINF\n         BZ    DONEARA\n         SR    R15,R15\n         IC    R15,ARAXINOF\n         SLL   R15,3\n         AR    R15,R1\n         USING ARAXINFO,R15\n         SR    R14,R14\n         ICM   R14,3,ARAPATHO      GET OFFSET TO PATH LEN\n         BZ    DONEARA\n         AR    R14,R15\n         DROP  R15                 ARAXINLN\n         SR    R15,R15\n         ICM   R15,3,0(R14)        GET ARAPATHLEN\n         CH    R15,=H'44'\n         BNH   *+8\n         LA    R15,44              JUST SHOW FIRST 44 FOR NOW\n         STH   R15,DSNAME\n         BCTR  R15,0\n         B     *+10\n         MVC   DSNAME+2(0),2(R14)  ARAPATHNAM\n         EX    R15,*-6\nDONEARA  LA    R14,MYARL           PREPARE FOR FREEMAIN\n         USING ARL,R14\n         SR    R15,R15             PREPARE FOR FREEMAIN\n         IC    R15,ARLPOOL\n         SR    R0,R0\n         ICM   R0,7,ARLRLEN\n         L     R1,ARLAREA\n         DROP  R14                 ARL\n         FREEMAIN RU,LV=(0),SP=(R15),A=(1)\nNOARA    CLC   DSNAME(2),=H'0'\n         BNE   FILESPEC\n         MVC   DSNAME+2(44),JFCB\n         LA    R1,DSNAME+45        LAST CHAR OF DSNAME\n         LA    R0,44               INITIAL LENGTH\nFILEA    CLI   0(R1),C' '          IS THIS LAST NONBLANK\n         BNE   FILEB               YES, BRANCH\n         BCTR  R1,0                BACK UP 1 CHARACTER\n         BCT   R0,FILEA            DECREMENT LENGTH AND BRANCH\nFILEB    STH   R0,DSNAME           STORE LENGTH OF DSNAME\n*        MVC   VOLUME(6),JFCB+118  GET VOLUME FROM JFCB\n         MVC   MEMNAME,JFCB+44     JFCBELNM IN IEFJFCBN\n         LA    R1,MEMNAME+7        LAST CHAR OF MEMBER NAME\n         LA    R0,8\nMEMA     CLI   0(R1),C' '\n         BNE   MEMB\n         BCTR  R1,0\n         BCT   R0,MEMA\nMEMB     STH   R0,MEMLEN\n         B     FILESPEC\nFILERR1  LA    R0,MSG14A\n         B     FILERR\nFILERR2  LA    R0,MSG14B\n         B     FILERR\nFILERR3  LA    R0,MSG14C\nFILERR   MVC   MSGWK(L'MSG14),MSG14\n         LA    R15,MSGWK+L'MSG14\n         LA    R14,DSNAME\n         LH    R1,0(,R14)\n         BCTR  R1,0\n         B     *+10\n         MVC   MSGWK+L'MSG14(0),2(R14)\n         EX    R1,*-6\n         LA    R15,1(R1,R15)\n         LR    R14,R0 POINT TO MSG14A, B, OR C\n         MVC   0(L'MSG14A,R15),0(R14)\n         LA    R0,L'MSG14+L'MSG14A+1(,R1)\n         LA    R1,MSGWK\n         BAL   R14,PUTMSG\n         B     QUITD12\nNOFILE   EQU   *\n         TM    6(R6),X'40'         IS IT QUOTED?\n         BO    DEFX                YES - SKIP DEFAULT SERVICE\n         CLI   QUICKW+1,1          QUICK SPECIFIED\n         BE    DEFX                YES, USER ENTERED ALL BUT PREFIX\n         SPACE\n************************************************************\n*                                                          *\n*        DEFAULT SERVICE ROUTINE TO GET QUALIFIERS         *\n*                                                          *\n************************************************************\n         SPACE\n*              ALL INPUT TO IKJEHDEF MUST BE BELOW THE LINE\n         MVC   DSNAME24(46),DSNAME\n         LA    R15,MYIOPL24\n         USING IOPL,R15\n         LA    R14,MYIOPL\n         MVC   IOPLUPT(4),IOPLUPT-IOPL(R14)\n         MVC   IOPLECT(4),IOPLECT-IOPL(R14)\n         LA    R0,MYECB24\n         ST    R0,IOPLECB\n         XC    MYECB24,MYECB24\n         LA    R14,MYDFPB\n         ST    R14,IOPLIOPB\n         USING DFPB,R14\n         XC    0(20,R14),0(R14)\n         LA    R0,DSNAME24\n         ST    R0,DFPBDSN\n         OI    DFPBCODE,X'04'      SEARCH CAT AND PROMPT IF MULTI\n         MVC   DFPBPSCB,CPPLPSCB\n*        MVI   DFPBCNTL,X'20'      PREFIX THE DSNAME\n         DROP  R14                 DFPB\n         DROP  R15                 IOPL\n         SPACE\n         LR    R1,R15              POINT TO IOPL\n         LA    R13,SAVE24          POINT TO SAVEAREA BELOW THE LINE\n         L     R15,16              CVTPTR\n         TM    736(R15),X'80'      IF HI ORDER BIT NOT ON\n         BNO   EHDEFLNK               THEN DO LINK, NOT CALL\n         L     R15,736(,R15)       CVTEHDEF\n         BALR  R14,R15             CALL IKJEHDEF\n         B     EHDEFEXT            SKIP AROUND LINK\nEHDEFLNK EQU   *\n         LINK  EP=IKJEHDEF,SF=(E,LINKAREA)\nEHDEFEXT EQU   *\n         SPACE\n         LR    R13,R9              RESTORE SAVEARE POINTER\n         B     DEFCODE(R15)\nDEFCODE  B     DEF00               SUCCESS\n         B     NEXTD12              MSG ALREADY ISSUED\n         B     DEF08               INVALID NAME GT 44\n         B     NEXTD12              MSG ALREADY ISUED\n         B     DEF16               NOT IN CATALOG\n         B     DEF20               NOT IN CATALOG\n         B     DEF24               IMPOSSIBLE\n         B     DEF28               COMMAND SYSTEM ERROR\n         B     DEF32               IMPOSSIBLE\n         B     DEF36               ?\nDEF08    EQU   *\nDEF16    EQU   *\n         B     DEF24\nDEF20    EQU   *\nLOCERR   EQU   *\n         MVC   MSGWK(L'MSG02),MSG02\n         LA    R15,MSGWK+L'MSG02\n         LA    R14,DSNAME\n         LH    R1,0(,R14)\n         BCTR  R1,0\n         B     *+10\n         MVC   MSGWK+L'MSG02(0),2(R14)\n         EX    R1,*-6\n         LA    R15,1(R1,R15)\n         MVC   0(L'MSG02A,R15),MSG02A\n         LA    R0,L'MSG02+L'MSG02A+1(,R1)\n         LA    R1,MSGWK\n         BAL   R14,PUTMSG\n         B     NEXTD12\nDEF24    EQU   *\nDEF28    EQU   *\nDEF32    EQU   *\nDEF36    EQU   *\n         LA    R1,MSG03\n         LA    R0,L'MSG03\n         BAL   R14,PUTMSG\nNEXTD12  MVI   RETCODE+1,12\n         B     NEXTDSN\n         SPACE\nDEF00    MVC   DSNAME(46),DSNAME24\nDEFX     EQU   *\n         SPACE\n************************************************************\n*                                                          *\n*        ALLOCATE THE DATASET                              *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R1,MYDAPL\n         USING DAPL,R1\n         MVC   DAPLUPT(4),CPPLUPT\n         MVC   DAPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,DAPLECB\n         MVC   DAPLPSCB(4),CPPLPSCB\n         LA    R15,MYDAPB\n         ST    R15,DAPLDAPB\n         DROP  R1                  DAPL\n         USING DAPB08,R15\n         XC    0(84,R15),0(R15)\n         MVI   DA08CD+1,X'08'\n         LA    R0,DSNAME\n         ST    R0,DA08PDSN\n         MVC   DA08DDN(8),=CL8' '\n         MVC   DA08UNIT,=CL8' '\n         MVC   DA08SER,=CL8' '\n         MVC   DA08MNM,=CL8' '\n         MVC   DA08PSWD,=CL8' '\n         MVI   DA08DSP1,DA08SHR\n         MVI   DA08DPS2,DA08KEEP\n         MVI   DA08DPS3,DA08KEP\n         TM    14(R6),X'80'        MEMBER SPECIFIED?\n         BZ    MEMBX               NO - BRANCH\n         LH    R1,12(,R6)          GET LENGTH OF MEMBER\n         STH   R1,MEMLEN\n         BCTR  R1,0                MINUS 1 FOR EX\n         L     R14,8(,R6)          GET ADDRESS OF MEMBER NAME\n         B     *+10\n         MVC   DA08MNM(0),0(R14)   MOVE MEMBER NAME\n         EX    R1,*-6\n         MVC   MEMNAME,DA08MNM\nMEMBX    EQU   *\n         TM    22(R6),X'80'        PASSWORD SPECIFIED?\n         BZ    PASSX               NO - BRANCH\n         LH    R1,20(,R6)          GET LENGTH OF PSWD\n         BCTR  R1,0                MINUS 1 FOR EX\n         L     R14,16(,R6)         GET ADDRESS OF PSWD\n         B     *+10\n         MVC   DA08PSWD(0),0(R14)  MOVE PSWD\n         EX    R1,*-6\nPASSX    EQU   *\n         LA    R1,MYDAPL\n         SPACE\n         BAL   R14,CALLDAIR\n         LTR   R15,R15\n         BZ    OKDAIR\n         BAL   R14,DAIRFAIL\n         B     NEXTD12\nOKDAIR   EQU   *\n         OI    STATUS,X'40'        TELL CLEANUP TO FREE IT\n         LA    R15,MYDAPB\n         MVC   DDSAVE,DA08DDN\n         TM    DA08DSO,X'40'       IS DSORG SEQUENTIAL?\n         BO    OKDSORG             YES - BRANCH\n         TM    DA08DSO,X'02'       IS DSORG PARTITIONED?\n         BO    OKDSORGP            YES, BRANCH\n*\n*              DSORG IS NEITHER PS NOR PO\n*              ISAM=X'80' DA=X'20' VSAM=X'00' NONE=X'00'\n*\nERRDSORG LA    R1,MSG06\n         LA    R0,L'MSG06\n         BAL   R14,PUTMSG\n         B     QUITD12\nOKDSORGP EQU   *\n         CLC   DA08MNM,=CL8' '     WAS MEMBER SPECIFIED?\n         BNE   OKDSORG             YES - BRANCH\n         LA    R1,MSG07\n         LA    R0,L'MSG07\n         BAL   R14,PUTMSG\n         B     NEXTD12\nOKDSORG  EQU   *\n         DROP  R15                 DAPB08\n         SPACE\nFILESPEC EQU   *\n         SPACE\n************************************************************\n*                                                          *\n*        SET UP THE DCB                                    *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R4,DYNDCBW\n         USING IHADCB,R4\n         MVC   0(DYNDCBL,R4),DYNDCB\n         MVC   DCBDDNAM(8),DDSAVE\n         SPACE\n         LA    R5,DYNDCBEW\n         USING DCBE,R5\n         MVC   0(DYNDCBEL,R5),DYNDCBE\n         ST    R5,DCBDCBE\n         SPACE\n         LA    R15,DYNEOD\n         ST    R15,DCBEEODA\n         SPACE\n         LA    R15,DYNSYNAD\n         ST    R15,DCBESYNA\n         SPACE\n         LA    R15,DYNEXLST\n         IC    R0,DCBEXLSA-1\n         ST    R15,DCBEXLSA-1      EXLST=DYNEXLST\n         STC   R0,DCBEXLSA-1\n         LA    R1,OPENEXIT         EXIT BELOW THE LINE\n         MVC   0(GLUELEN,R1),GLUE   WILL CONTAIN GLUE\n         ST    R1,0(,R15)          STORE IN 1ST EXLST WORD\n         MVI   0(R15),X'05'        MARK TYPE OF EXIT\n         LA    R0,DYNOPENX         EXIT ABOVE THE LINE\n         ST    R0,OPENEXAD         SAVE ITS ADDRESS\n         OI    OPENEXAD,X'80'      MAKE IT RUN IN31-BIT MODE\n         SPACE\n         LA    R1,ABENDXIT         EXIT BELOW THE LINE\n         MVC   0(GLUELEN,R1),GLUE   WILL CONTAIN GLUE\n         ST    R1,4(,R15)          STORE IN 2ND EXLST WORD\n         MVI   4(R15),128+X'11'    OPEN ABEND EXIT (MVS)\n         LA    R0,DYNABEND         EXIT ABOVE THE LINE\n         ST    R0,ABENDXAD         SAVE ITS ADDRESS\n         OI    ABENDXAD,X'80'      MAKE IT RUN IN31-BIT MODE\n         SPACE\n         OI    STATUS,X'80'        TELL CLEANUP TO CLOSE DCB\n         MVC   OPEND(OPEN31L),OPEN31\n         SPACE\n         OPEN  ((R4),INPUT),MODE=31,MF=(E,OPEND)\n         SPACE\n*        TM    DCBOFLGS,X'10'\n*        TM    DCBEFLG1,DCBEOPEN+DCBEMD31\n         TM    DCBEFLG1,DCBEOPEN\n         BO    OKOPEN\n         LA    R1,MSG08\n         LA    R0,L'MSG08\n         TM    STATUS,X'10'        MEMBER NOT FOUND?\n         BO    DYNOPENM            YES, BRANCH\n         LA    R1,MSG04\n         LA    R0,L'MSG04\nDYNOPENM BAL   R14,PUTMSG\n         B     QUITD12\n         SPACE\nDYNOPENX BSM   0,R14\n         SPACE\nDYNABEND L     R8,0(,R1)           GET COMPLETION CODE\n         N     R8,=A(X'FFF0FF00')\n         CL    R8,=A(X'01301800')  IS IT AN 013-18 ABEND\n         BE    DYNABENY            YES, BRANCH\n         MVI   4(R1),0             NO, ABNORMALLY TERMINATE\n         BSM   0,R14\nDYNABENY OI    STATUS,X'10'        INDICATE MEMBER NOT FOUND\n         MVI   3(R1),4             IGNORE THE ABEND\n         BSM   0,R14\n         SPACE\nOKOPEN   EQU   *\n         BAL   R14,CKXINIT         SET UP FOR SUBROUTINE\n         SPACE\nREADLOOP EQU   *\n         MVI   SYNADSW,0           SET SYNAD SWITCH OFF\n         SPACE\n         GET   (R4)\n         SPACE\n         CLI   SYNADSW,0           WAS SYNAD EXIT TAKEN?\n         BE    OKGET               NO - BRANCH\n         LA    R1,SYNADMSG\n         LA    R0,78\n         BAL   R14,PUTMSG\n         B     QUITD12\nOKGET    EQU   *\n         BAL   R14,CKXREC\n         B     READLOOP\n         SPACE\nCKXINIT  LA    R1,CKXARGS\n         LA    R15,CKXLEN\n         ST    R15,4(,R1)          ARG 2 IS WORD CONTAINING LENGTH\n         LA    R15,CKXCTX\n         ST    R15,8(,R1)          ARG 3 IS CONTEXT 3 WORDS\n         XC    0(12,R15),0(R15)    CLEAR THE CONTEXT\n         LA    R15,CKXRES\n         ST    R15,12(,R1)         ARG 4 IS RESULT\n         LA    R15,CKXWRK\n         ST    R15,16(,R1)         ARG 5 IS WORKSPACE 30 WORDS\n         BR    R14\n         SPACE\nCKXREC   ST    R14,CKXSAVE\n         LH    R0,DCBLRECL         GET RECORD LENGTH IF RECFM U OR FB\n         TM    DCBRECFM,X'C0'      IF RECFM U\n         BO    CKXRECX               BRANCH\n         TM    DCBRECFM,X'40'      IF RECFM V\n         BO    CKXRECV               BRANCH\n         TM    DCBRECFM,X'10'      IF RECFM FB\n         BO    CKXRECX               BRANCH\n         LH    R0,DCBBLKSI         GET RECORD LENGTH IF RECFM F\n         B     CKXRECX               BRANCH\nCKXRECV  CLI   RDWKW+1,1           IF RDW WAS SPECIFIED\n         BE    CKXRECX               INCLUDE RDW\n         LH    R0,0(,R1)           GET RECORD LENGTH +4 FROM RDW\n         SH    R0,=H'4'            SUBTRACT 4 TO EXCLUDE RDW\n         LA    R1,4(,R1)           GET RECORD ADDRESS AFTER RDW\nCKXRECX  ST    R0,CKXLEN           STORE RECORD LENGTH\n         LR    R15,R1              RECORD ADDRESS TO R15\n         LA    R1,CKXARGS          SET R1 FOR CALL\n         ST    R15,0(,R1)          STORE RECORD ADDRESS AS FIRST ARG\n         L     R15,=V(CKSUMR)      SET R15 FOR CALL\n         BALR  R14,R15             CALL CKSUMR(RECORD,LEN,CTX,HEX,WORK)\n         L     R14,CKXSAVE\n         BR    R14\n         SPACE\nCKXLAST  ST    R14,CKXSAVE\n         SR    R0,R0               STORE RECORD ADDRESS\n         ST    R0,CKXLEN           STORE RECORD LENGTH\n         LA    R1,CKXARGS\n         L     R15,=V(CKSUMR)\n         BALR  R14,R15             CALL CKSUMR(RECORD,LEN,CTX,HEX,WORK)\n         L     R14,CKXSAVE\n         BR    R14\n         SPACE\nDYNEOD   EQU   *\n         BAL   R14,CKXLAST\n         LA    R1,CKXRES+12        POINT TO 12-BYTE RESULT DIGITS\n         LA    R15,MSGWK\n         LA    R0,12\nSLOOP1   CLI   0(R1),C' '          IF LEADING BLANK\n         BE    SNEXT1               IGNORE IT\n         MVC   0(1,R15),0(R1)      ELSE COPY DIGIT TO MSGWK\n         LA    R15,1(,R15)          POINT TO NEXT DEST BYTE\nSNEXT1   LA    R1,1(,R1)           POINT TO NEXT SRC BYTE\n         BCT   R0,SLOOP1           LOOP UNTIL ALL 12 DONE\n         MVI   0(R15),C' '         SPACE BETWEEN\n         LA    R15,1(,R15)         POINT TO NEXT DEST BYTE\n*                                  R1 POINTS TO 16-BYTE COUNT DIGITS\n         LA    R0,16               NUMBER OF CHARACTERS\nSLOOP2   CLI   0(R1),C' '          IF LEADING BLANK\n         BE    SNEXT2               IGNORE IT\n         MVC   0(1,R15),0(R1)      ELSE COPY DIGIT TO MSGWK\n         LA    R15,1(,R15)          POINT TO NEXT DEST BYTE\nSNEXT2   LA    R1,1(,R1)           POINT TO NEXT SRC BYTE\n         BCT   R0,SLOOP2           LOOP UNTIL ALL 16 DONE\n         MVI   0(R15),C' '         SPACE BETWEEN\n         LA    R15,1(,R15)         POINT TO NEXT DEST BYTE\n         LA    R14,DSNAME\n         LH    R1,0(,R14)\n         BCTR  R1,0\n         B     *+10\n         MVC   0(0,R15),2(R14)     COPY DSNAME\n         EX    R1,*-6              COPY DSNAME\n         LA    R15,1(R1,R15)       POINT PAST LAST BYTE MOVED\n*        TM    14(R6),X'80'        MEMBER SPECIFIED?\n         CLI   MEMLEN+1,0          MEMBER ALLOCATED?\n         BZ    MEMAX               NO - BRANCH\n         MVI   0(R15),C'('\n         LA    R15,1(,R15)\n*        LH    R1,12(,R6)          GET LENGTH OF MEMBER\n         LH    R1,MEMLEN           GET LENGTH OF MEMBER\n         BCTR  R1,0                MINUS 1 FOR EX\n*        L     R14,8(,R6)          GET ADDRESS OF MEMBER NAME\n         LA    R14,MEMNAME\n         B     *+10\n         MVC   0(0,R15),0(R14)     MOVE MEMBER NAME\n         EX    R1,*-6\n         LA    R15,1(R1,R15)       POINT PAST LAST BYTE\n         MVI   0(R15),C')'\n         LA    R15,1(,R15)\nMEMAX    EQU   *\n         LA    R1,MSGWK\n         LR    R0,R15              POINT PAST LAST BYTE\n         SR    R0,R1               COMPUTE MESSAGE LENGTH  FOR PUTLINE\n         CLI   LOWKW+1,1           IF 'LOWER' SPECIFIED\n         BNE   LOWX\n         LR    R14,R0\n         BCTR  R14,0                  GET LENGTH MINUS 1\n         B     *+10\n         TR    MSGWK(0),LOWTABLE      TRANSLATE TO LOWER CASE\n         EX    R14,*-6\nLOWX     EQU   *\n         LA    R1,MSGWK\n         BAL   R14,PUTLINE\n         B     QUITDSN\n         SPACE\nQUITD12  MVI   RETCODE+1,12\n         SPACE\nQUITDSN  TM    STATUS,X'80'\n         BZ    NOCLOSE\n*        TM    DCBOFLGS,X'10'      IS IT OPEN?\n         TM    DCBEFLG1,DCBEOPEN\n         BZ    NOCLOSE             NO, BRANCH\n         MVC   CLOSED(CLOSE31L),CLOSE31\n         CLOSE ((R4)),MODE=31,MF=(E,CLOSED)\n         NI    STATUS,255-X'80'    CLOSED\n         DROP  R4                  IHADCB\nNOCLOSE  EQU   *\n         TM    STATUS,X'40'        FREE REQUIRED?\n         BZ    NOFREE\n         LA    R1,MYDAPL\n         LA    R15,MYDAPB\n         USING DAPB18,R15\n         XC    0(40,R15),0(R15)\n         MVI   DA18CD+1,X'18'\n         MVC   DA18DDN,DDSAVE\n         MVC   DA18MNM(8),=CL8' '\n         MVC   DA18SCLS(2),=CL8' '\n         BAL   R14,CALLDAIR        UNALLOCATE\n         NI    STATUS,255-X'40'    UNALLOCATED\n         DROP  R15                 DAPB18\nNOFREE   EQU   *\n         B     NEXTDSN\n         SPACE\nDONE     TM    MYPUTLEP,X'80'     WAS PUTLINE LOADED?\n         BO    NODELETE           NO - USED CVTPUTL - BRANCH\n         LA    R0,=CL8'IKJPUTL '\n         DELETE EPLOC=(0)\nNODELETE EQU   *\n         SPACE\n         IKJRLSA MYANS\n         SPACE\n         CLI   RETCODE+1,0         IS RETCODE ZERO?\n         BZ    STACKDX             YES, BRANCH\n         MVC   MYSTPB(STACKDL),STACKD\n         SPACE\n         STACK DELETE=ALL,PARM=MYSTPB,MF=(E,MYIOPL)\n         SPACE\n         TCLEARQ\nSTACKDX  EQU   *\n         SPACE\n         LH    R15,RETCODE\n         B     EXIT\n         SPACE\n************************************************************\n*                                                          *\n*         CALL IKJDAIR SERVICE ROUTINE                     *\n*                                                          *\n************************************************************\n          SPACE\nCALLDAIR ST    R14,DAIRREGS\n         L     R15,16\n         TM    732(R15),X'80'     CVTDAIR\n         BNO   DAIRLINK\n         L     R15,732(,R15)\n         BALR  R14,R15\n         B     DAIRFINI\nDAIRLINK EQU   *\n         LINK  EP=IKJDAIR,SF=(E,LINKAREA)\nDAIRFINI L     R14,DAIRREGS\n         BR    R14\n         SPACE\n************************************************************\n*                                                          *\n*        DYNAMIC ALLOCATION FAILURE ROUTINE                *\n*                                                          *\n************************************************************\n         SPACE\nDAIRFAIL ST    R14,MYDFREGS\n         LA    R1,MYDFPARM\n         USING DFDSECTD,R1\n         ST    R15,MYDFRC\n         LA    R15,MYDFRC\n         ST    R15,DFRCP\n         LA    R15,MYDAPL\n         ST    R15,DFDAPLP\n         SLR   R15,R15\n         ST    R15,MYJEFF02\n         LA    R15,MYJEFF02\n         ST    R15,DFJEFF02\n         LA    R15,DFDAIR\n         STH   R15,MYDFID\n         LA    R15,MYDFID\n         ST    R15,DFIDP\n         SLR   R15,R15\n         ST    R15,DFCPPLP\n         LINK  EP=IKJEFF18,SF=(E,LINKAREA)\n         L     R15,MYDFRC\n         DROP  R1                  DFDSECTD\n         L     R14,MYDFREGS\n         BR    R14\n         SPACE\n************************************************************\n*                                                          *\n*        PUTMSG ROUTINE                                    *\n*                                                          *\n************************************************************\n         SPACE\nPUTMSG   STM   R14,R1,PUTLINS\n         XC    MYOLD(8),MYOLD\n         XC    MYSEG1(4),MYSEG1\n         MVC   MYPTPB(12),MODLPTPM\n         LA    R14,1               NO. OF MESSAGE SEGMENTS\n         ST    R14,MYOLD\n         LA    R14,MYSEG1          POINT TO 1ST SEGMENT\n         ST    R14,MYOLD+4\n         LR    R14,R0              LENGTH IN R0\n         LA    R14,4(,R14)         ADD 4\n         LA    R15,MYSEG1+4\n         CLC   0(3,R1),=C'IKJ'     IS DATA PRECEEDED BY MESSAGE ID?\n         BE    *+16                YES - BRANCH\n         LA    R14,1(,R14)         ADD 1 TO LENGTH\n         MVI   0(R15),C' '         INSERT LEADING BLANK\n         LA    R15,1(,R15)         BUMP POINTER\n         STH   R14,MYSEG1\n         LR    R14,R0\n         BCTR  R14,0\n         B     *+10\n         MVC   0(0,R15),0(R1)      MOVE MESSAGE IN\n         EX    R14,*-6\n         L     R15,MYPUTLEP\n         SPACE\n         PUTLINE PARM=MYPTPB,OUTPUT=(MYOLD),ENTRY=(15),MF=(E,MYIOPL)\n         SPACE\n         LM    R14,R1,PUTLINS\n         BR    R14\n         SPACE\n************************************************************\n*                                                          *\n*        PUTLINE ROUTINE                                   *\n*                                                          *\n************************************************************\n         SPACE\nPUTLINE  STM   R14,R1,PUTLINS\n         XC    MYSEG1(4),MYSEG1\n         MVC   MYPTPB(12),MODLPTPB\n         LR    R14,R0              LENGTH IN R0\n         LA    R14,4(,R14)         ADD 4\n         STH   R14,MYSEG1\n         LR    R14,R0\n         BCTR  R14,0\n         B     *+10\n         MVC   MYSEG1+4(0),0(R1)   MOVE TEXT IN\n         EX    R14,*-6\n         LA    R1,MYIOPL\n         L     R15,MYPUTLEP\n         SPACE\n         PUTLINE PARM=MYPTPB,OUTPUT=(MYSEG1,DATA),ENTRY=(15),MF=(E,(1))\n         SPACE\n         LM    R14,R1,PUTLINS\n         BR    R14\n         SPACE 1\n*RRRECFM LA    R1,MSGRECFM\n*        LA    R0,L'MSGRECFM\n*        BAL   R14,PUTMSG\n*        B     QUITD12\n         SPACE\nEXIT     LR    R2,R15              SAVE R15\n         LR    R1,R10\n         L     R0,@SIZE24\n         FREEMAIN R,A=(1),LV=(0)\n         SPACE\n         LR    R1,R13\n         L     R0,@SIZE31\n         L     13,4(,13)\n         FREEMAIN RU,A=(1),LV=(0),SP=1\n         LR    R15,R2              RESTORE R15\n         LM    0,12,20(13)\n         L     14,12(,13)\n         BR    14\n         SPACE\n************************************************************\n*                                                          *\n*        SYNAD EXIT                                        *\n*                                                          *\n************************************************************\n         SPACE\n*        THIS ROUTINE IS ENTERED DURING THE 'GET' MACRO\n*        IF AN I/O ERROR OCCURS.\n         SPACE\nDYNSYNAD EQU   *\n         SYNADAF ACSMETH=QSAM\n         MVC   SYNADMSG(78),50(R1)\n         MVI   SYNADSW,X'FF'\n         SYNADRLS\n         BR    R14\n         SPACE\n************************************************************\n*                                                          *\n*        GLUE FOR DCB EXITS                                *\n*                                                          *\n************************************************************\n         SPACE\n*        THESE 2 INSTRUCTIONS ARE COPIED TO ABENDXIT, BELOW THE LINE,\n*        AND RUN THERE, NOT HERE. WHEN ABENDXIT IS ENTERED,\n*        R15 CONTAINS THE ENTRY ADDRESS, THE ADDRESS OF ABENDXIT.\n*        THEN USING R15 AS A BASE REGISTER, IT LOADS R15 FROM ABENDXAD,\n*        WHICH CONTAINS THE ADDRESS OF DYNABEND ABOVE THE LINE,\n*        WITH THE HIGH-ORDER BIT SET TO 1. THEN IT USES BSM TO\n*        BRANCH TO DYNABEND IN 31-BIT MODE. THE ROUTINE AT\n*        DYNABEND SHOULD RETURN USING 'BSM 0,R14'.\n*\nGLUE     L     R15,ABENDXAD-ABENDXIT(,R15)\n         BSM   R14,R15  OLD MODE INTO R14 HI BIT, BRANCH TO R15 IN 31\nGLUELEN  EQU   *-GLUE\n         SPACE\n*        SINCE ABENDXAD-ABENDEXIT IS IDENTICAL TO OPENEXAD-OPENEXIT\n*        THE FOLLOWING IS NOT REALLY NEEDED.\n         SPACE\nGLUE2    L     R15,OPENEXAD-OPENEXIT(,R15)\n         BSM   R14,R15  OLD MODE INTO R14 HI BIT, BRANCH TO R15 IN 31\nGLUELEN2 EQU   *-GLUE2\n         SPACE\n************************************************************\n*                                                          *\n*        CONSTANTS                                         *\n*                                                          *\n************************************************************\n         SPACE\nMODLPTPM PUTLINE OUTPUT=(1,TERM,SINGLE,INFOR),                         X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=L\n         SPACE\nMODLPTPB PUTLINE OUTPUT=(1,TERM,SINGLE,DATA),                          X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=L\n         SPACE\n*        PRINT NOGEN\n         SPACE\nOPEN31   OPEN  (0,),MODE=31,MF=L\nOPEN31L  EQU   *-OPEN31\nCLOSE31  CLOSE (0,),MODE=31,MF=L\nCLOSE31L EQU   *-CLOSE31\n         SPACE\nDYNDCB   DCB   DDNAME=DYNAM,DSORG=PS,MACRF=(GL),                       +\n               EODAD=0,SYNAD=0,EROPT=ACC,DCBE=0\nDYNDCBL  EQU   *-DYNDCB\n         SPACE\nDYNDCBE  DCBE  RMODE31=BUFF,EODAD=1\nDYNDCBEL EQU   *-DYNDCBE\n         SPACE\n         PRINT GEN\n         SPACE\nSTACKD   STACK DELETE=ALL,MF=L\nSTACKDL  EQU   *-STACKD\n         SPACE\nMSG01    DC    C'ERROR IN PARSE SERVICE ROUTINE'\nMSG02    DC    C'IKJ58503I DATA SET '\nMSG02A   DC    C' NOT IN CATALOG'\nMSG03    DC    C'ERROR IN DEFAULT SERVICE ROUTINE'\nMSG04    DC    C'UNABLE TO OPEN DATASET'\nMSG05    DC    C'IKJ58509I DATA SET NAME REQUIRED WHEN MEMBER IS SPECIF+\n               IED'\nMSG06    DC    C'ORGANIZATION OF DATA SET MUST BE PARTITIONED OR SEQUEN+\n               TIAL'\nMSG07    DC    C'DATA SET IS PARTITIONED, MEMBER NOT SPECIFIED'\nMSG08    DC    C'SPECIFIED MEMBER NOT FOUND IN DATASET'\nMSG09    DC    C'IKJ56709I INVALID DSN LENGTH, '\nMSG14    DC    C'FILENAME '\nMSG14A   DC    C' INVALID, MORE THAN 8 CHARACTERS  '\nMSG14B   DC    C' IS NOT CURRENTLY ALLOCATED       '\nMSG14C   DC    C' NOT ALLOCATED TO A DASD DATA SET '\n*SGRECFM DC    C'RECORD FORMAT U NOT SUPPORTED'\n*MSGDAIR DC    C'UNABLE TO ALLOCATE'\nLOWTABLE DC    0D'0',256AL1(*-LOWTABLE)\n         ORG   LOWTABLE+C'A'\n         DC    X'818283848586878889'\n         ORG   LOWTABLE+C'J'\n         DC    X'919293949596979899'\n         ORG   LOWTABLE+C'S'\n         DC    X'A2A3A4A5A6A7A8A9'\n         ORG\n         LTORG\nPCLADDR  DC    0D'0'               END OF CSECT\n         SPACE\n************************************************************\n*                                                          *\n*        PARSE PARAMETERS                                  *\n*                                                          *\n************************************************************\n         SPACE\n         PRINT NOGEN\nCKSUMPCL RMODE 31\nCKSUMPCL IKJPARM\nDSN      IKJPOSIT DSNAME,LIST,PROMPT='DATA SET NAME'\nFILEKW   IKJKEYWD\n         IKJNAME 'FILE'\nQUICKW   IKJKEYWD\n         IKJNAME 'QUICK'\nRDWKW    IKJKEYWD\n         IKJNAME 'RDW'\nLOWKW    IKJKEYWD\n         IKJNAME 'LOWER'\n         IKJENDP\n         PRINT GEN\n         SPACE\n************************************************************\n*                                                          *\n*        DSECTS                                            *\n*                                                          *\n************************************************************\n         SPACE\n@DATA31  DSECT\n         DS    18F                 REGISTER SAVEAREA\nLINKAREA DS    2F\nMYPPL    DS    7F\nMYANS    DS    F\nMYECB    DS    F                  USED BY PUTLINE ROUTINE\nMYIOPL   DS    4F                 USED BY PUTLINE ROUTINE\nMYPTPB   DS    3F                 USED BY PUTLINE ROUTINE\nMYOLD    DS    2F                 USED BY PUTLINE ROUTINE\nMYSEG1   DS    2H,CL256           USED BY PUTLINE ROUTINE\nPUTLINS  DS    4F                 USED BY PUTLINE ROUTINE\nMYPUTLEP DS    F                  ADDRESS OF IKJPUTL\nMYSTPB   DS    0F                 5 WORDS USED BY STACK DELETE\nMYDAPL   DS    5F\nMYDAPB   DS    21F\nDSNAME   DS    H,CL44\nMEMLEN   DS    H\nMEMNAME  DS    CL8\nMSGWK    DS    CL128\nSTATUS   DS    X\nRETCODE  DS    H\nMYDFPARM DS    5F  USED BY DAIRFAIL\nMYDFREGS DS    F   USED BY DAIRFAIL\nMYDFRC   DS    F   USED BY DAIRFAIL\nMYJEFF02 DS    F   USED BY DAIRFAIL\nMYDFID   DS    H   USED BY DAIRFAIL\nDOUBLE   DS    D\nEIGHT    DS    CL8\nDDSAVE   DS    CL8\nDAIRREGS DS    F\nOPEND    DS    0F,(OPEN31L)X\nCLOSED   DS    0F,(CLOSE31L)X\nDYNDCBEW DS    0F,(DYNDCBEL)X\nSYNADSW  DS    F\nSYNADMSG DS    CL78\nDEVDATA  DS    2F\nCKXARGS  DS    5F\nCKXLEN   DS    F\nCKXCTX   DS    3F  (CKSUMR NEEDS 3F)\nCKXRES   DS    10F (CKSUMR NEEDS 10F)\nCKXWRK   DS    30F (CKSUMR NEEDS 30F)\nCKXSAVE  DS    F\n         DS    0D\n@DATA31L EQU   *-@DATA31\n         SPACE\n@DATA24  DSECT\nSAVE24   DS    18F                USED BY IKJEHDEF\nRDJFW    DS    F\nMYIOPL24 DS    4F                 USED BY IKJEHDEF\nMYECB24  DS    F\nMYDFPB   DS    5F\nDSNAME24 DS    H,CL44\nDYNDCBW  DS    0D,XL(DYNDCBL)\nDYNEXLST DS    2F\nOPENEXIT DS    0H,(GLUELEN)X\nOPENEXAD DS    F  X'80' + ADDRESS OF DYNOPENX\nABENDXIT DS    0H,(GLUELEN)X\nABENDXAD DS    F  X'80' + ADDRESS OF DYNABEND\nJFCB     DS    0F,CL176\nMYARL    DS    9F\n         DS    0D\n@DATA24L EQU   *-@DATA24\n         SPACE\nIHADCB   DSECT\nDCBDCBE  DS    A\n         DS    28XL1\nDCBBFTEK DS    XL1\nDCBEODAD DS    AL3\nDCBRECFM DS    X\nDCBEXLSA DS    AL3\nDCBDDNAM DS    CL8\nDCBOFLGS DS    X\n         DS    7XL1\n         DS    X\nDCBSYNAD DS    AL3\nDCBBLKSI EQU   IHADCB+62,2\nDCBLRECL EQU   IHADCB+82,2\n         SPACE\n         IHADCBE\n         SPACE\nEFLG1    EQU   16\nEOPEN    EQU   X'80'\nEMD31    EQU   X'40'\nEEODA    EQU   40\nESYNA    EQU   44\n         SPACE\nXFLG1    EQU   DCBEFLG1-DCBE\nXOPEN    EQU   DCBEOPEN\nXMD31    EQU   DCBEMD31\nXEODA    EQU   DCBEEODA-DCBE\nXSYNA    EQU   DCBESYNA-DCBE\n         PRINT NOGEN\n         SPACE\n         IKJCPPL\n         SPACE 3\n         IKJPPL\n         SPACE\n         IKJDFPB\n         SPACE 2\n         IKJUPT\n         SPACE 2\n         IKJIOPL\n         SPACE 2\n         IKJDAPL\n         SPACE 2\n         IKJDAP08\n         SPACE 2\n         IKJDAP18\n         SPACE 2\n         IKJPSCB\n         SPACE 2\n         IKJEFFDF DFDSECT=YES\n         SPACE\n         IHAARL\n         SPACE\n         IHAARA\n         SPACE\n*        CVT   DSECT=YES\n         SPACE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CKSUM$": {"ttr": 1286, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01 \\x15/\\x01 \\x15/\\x18D\\x00\\x11\\x00\\x11\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-05-31T00:00:00", "modifydate": "2020-05-31T18:44:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "UPDATED"}, "text": "//CBTUSER1 JOB (ACCT),'PGMRNAME',NOTIFY=CBTUSER,\n//         MSGLEVEL=(1,1),MSGCLASS=H\n//ASM     EXEC PGM=ASMA90,\n//             PARM=(LIST,OBJ,NODECK,ASA,NOXREF,NODX,NOMX,NORX,NOUS,\n//             BATCH,'PC(NOUHD)')\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//SYSLIN   DD  DSN=&&OBJ,DISP=(NEW,PASS),SPACE=(TRK,(3,3)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=800)\n//SYSIN    DD  DSN=CBTUSER.LIB.ASM(CKSUM),DISP=SHR\n//         DD  DSN=CBTUSER.LIB.ASM(CKSUMR),DISP=SHR\n//LKED   EXEC PGM=HEWLF064,PARM='MAP,NOXREF,RENT,REFR',\n//             COND=(0,NE)\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSNAME=&&OBJ,DISP=(OLD,DELETE)\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(TRK,(10,0))\n//SYSLMOD  DD  DSN=CBTUSER.LIB.LOAD(CKSUM),DISP=SHR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CKSUM#": {"ttr": 1288, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00U\\x01 \\x16?\\x01 \\x16?\\x11D\\x00\\x19\\x00\\x19\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-06-11T00:00:00", "modifydate": "2020-06-11T11:44:55", "lines": 25, "newlines": 25, "modlines": 0, "user": "UPDATED"}, "text": ")F FUNCTION -\n  THE CKSUM COMMAND DISPLAYS THE CRC CHECKSUM OF DATA SETS SPECIFIED.\n  IN DATA SETS WITH VARIABLE-LENGTH RECORDS THE RDW'S AND SDW'S ARE\n  NOT INCLUDED WHEN THE CHECKSUM IS COMPUTED UNLESS THE RDW KEYWORD\n  IS SPECIFIED. THE CHECKSUM ALGORITHM IS THE SAME ONE USED IN THE\n  CKSUM COMMAND IN Z/OS UNIX SYSTEM SERVICES, LINUX, AIX, AND OTHERS.\n  TWO NUMBERS ARE DISPLAYED: THE CHECKSUM AND THE NUMBER OF BYTES.\n)X SYNTAX -\n         CKSUM    'DSLIST'  FILE  RDW  LOW  QUICK\n\n  REQUIRED - 'DSLIST'\n  DEFAULTS - NONE\n\n)O OPERANDS -\n  'DSLIST' - NAMES OF SEQUENTIAL DATA SETS OR MEMBERS OF PARTITIONED\n             DATA SETS. IF MULTIPLE NAMES, ENCLOSE THEM IN PARENTHESES.\n))FILE     - THE NAMES IN DSLIST ARE DDNAMES, NOT DSNAMES.\n))RDW      - INCLUDE RDW OR SDW IN VARIABLE LENGTH RECORDS.\n))LOW      - SHOW DSNAME IN LOWER CASE.\n))QUICK    - FOR UNQUOTED DSNAMES, BYPASS THE DEFAULT SERVICE ROUTINE.\n             SO FOR EXAMPLE, IF YOU SPECIFY THE NAME TEMP AND YOU\n             ONLY HAVE A DATA SET NAMED TEMP.DATA, IT WON'T BE FOUND\n             IF QUICK IS ALSO SPECIFIED. THE QUICK KEYWORD IS JUST\n             TO CUT OUT THE OVERHEAD OF LOOKING FOR EXTENSIONS AT\n             THE END OF THE SPECIFIED DATA SET NAME.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CKSUMR": {"ttr": 1290, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01 \\x15\\x9f\\x01 \\x15\\x9f\\x14C\\x01<\\x01<\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-06-07T00:00:00", "modifydate": "2020-06-07T14:43:32", "lines": 316, "newlines": 316, "modlines": 0, "user": "UPDATED"}, "text": "         TITLE ' C K S U M R '\n*\n*        SUBROUTINE TO COMPUTE THE SAME KIND OF CHECKSUM\n*        USED IN THE Z/OS UNIX SYSTEM SERVICES 'CKSUM' COMMAND,\n*        NOT TO MENTION THE SAME COMMAND IN AIX AND LINUX.\n*        THE ARGUMENT LIST IS SIMILAR IN MANY RESPECTS TO THE\n*        'MD5' SUBROUTINE IN FILE 900 OF THE CBT TAPE.\n*\n*        WRITTEN MAY 31 2020 FOR THE 'CKSUM' TSO COMMAND\n*\n*        JIM CONNELLEY DESERVES ACKNOWLEDGEMENT FOR THE ASSEMBLER\n*        CODE IN CBT FILE 493 MEMBER CRC32, WHICH COMPUTES A\n*        ANOTHER CRCSUM USING A SLIGHTLY DIFFERENT ALGORITHM\n*        AND A DIFFERENT POLYNOMIAL TABLE.\n*\n*        CALL CKSUMR(STRING,LENGTH,CONTEXT,RESULT,WORKSPACE)\n*\n*        LENGTH IS A FULLWORD CONTAINING THE LENGTH OF STRING.\n*\n*        CONTEXT IS 3 FULLWORDS WHICH SHOULD BE CLEARED TO BINARY\n*        ZEROES BEFORE THE FIRST CALL, AND LEFT UNCHANGED AFTER THAT,\n*        UNLESS AN ADDITIONAL CHECKSUM IS TO BE COMPUTED FOR ANOTHER\n*        STRING, IN WHICH CASE IT SHOULD BE CLEARED AGAIN FOR THE\n*        FIRST CALL FOR THE OTHER STRING.\n*\n*        RESULT IS 10 FULLWORDS WHICH WILL CONTAIN, AFTER THE\n*        FINAL CALL:\n*        1) THE CHECKSUM AS A 32-BIT UNSIGNED NUMBER,\n*        2) THE BYTE COUNT AS A 64-BIT NUMBER,\n*        3) A SPAN OF 3 WORDS CONTAINING A 12-BYTE EBCDIC STRING\n*           CONSISTING OF LEADING SPACES AND A 1-TO-10-DIGIT NUMBER\n*           REPRESENTING THE SAME CHECKSUM AS THE FIRST WORD,\n*           RANGING FROM '           0' TO '  4294967295'.\n*           THIS IS PROVIDED AS A CONVENIENCE FOR CASES WHERE THE\n*           THE CALLING PROGRAM IS IN A LANGUAGE THAT ONLY\n*           SUPPORTS CONVERTING SIGNED INTEGERS TO A PRINTABLE FORM.\n*        4) A SPAN OF 4 WORDS CONTAINING A 16-BYTE EBCDIC STRING\n*           REPRESENTING THE BYTE COUNT\n*           IF THE LEFTMOST BYTE IS A BLANK, THE NUMBER IS DECIMAL,\n*           WITH LEADING ZEROES CHANGED TO BLANKS.\n*           OTHERWISE THE NUMBER IS HEXADECIMAL EBCDIC DIGITS,\n*           WHICH ONLY HAPPENS IF THE BYTE COUNT EXCEEDS\n*           214,748,364,799,999.\n*\n*        WORKSPACE IS 30 FULLWORDS AND ITS CONTENTS DO NOT NEED TO\n*        BE SET BY THE CALLER. IT IS USED AS A REGISTER SAVE AREA\n*        AND TEMPORARY WORK SPACE.\n*\n*        AT LEAST 2 CALLS WILL BE NEEDED - ONE OR MORE WITH\n*        A STRING AND ONE WITH THE STRING LENGTH SET TO ZERO.\n*        IF LENGTH IS 0, RESULT WILL CONTAIN AN UNSIGNED\n*        32-BIT NUMBER, AMONG OTHER THINGS DESCRIBED EARLIER.\n*\n*        IF LENGTH IS NEGATIVE, ONLY ONE CALL IS NEEDED. IT IS THE\n*        EQUIVALENT OF ONE CALL WITH A POSITIVE LENGTH AND\n*        ANOTHER WITH A ZERO LENGTH. THE NEGATIVE LENGTH IS\n*        ZERO MINUS THE STRING LENGTH. THE CONTEXT IN THIS CASE\n*        DOES NOT NEED TO BE CLEARED TO ZEROES.\n*\nCKSUMR   CSECT\nCKSUMR   AMODE ANY31\nCKSUMR   RMODE 31\n         USING *,R12\n         B     BEGIN-*(,R15)\n         DC    AL1(7),CL7'CKSUMR'\n         DC    CL16' &SYSDATE &SYSTIME '\n*        DC    CL16' 05/31/20 11:00 '\nWORKSIZ  DC    0F'0',AL1(0),AL3(WORKLEN)\nBEGIN    STM   14,12,12(13)\n         LR    R12,R15\n         LR    R2,R1               POINT TO ARGS PASSED\n         L     R7,16(,R2)          POINT TO WORKSPACE, 5TH ARG\n*        L     R0,WORKSIZ\n*        GETMAIN R,LV=(0)\n*        LR    R7,R1\n         USING WORKD,R7\n         XC    0(WORKINI,R7),0(R7)\n         ST    R13,4(,R7)          OLD ADDRESS IN NEW SAVE AREA\n         ST    R7,8(,R13)          NEW ADDRESS IN OLD SAVE AREA\n         LR    R13,R7\n         MVC   ARGLIST(16),0(R2)   SAVE 1ST 4 ARG ADDRESSES\n         SPACE\n         LM    R8,R10,ARGLIST      GET STRING ADDR, LEN ADDR, CONTEXT\n         L     R2,4(,R10)          GET TOTAL LENGTH SO FAR\n         L     R3,8(,R10)          GET TOTAL LENGTH SO FAR\n         L     R10,0(,R10)         GET INITIAL/CURRENT CRC\n         L     R9,0(,R9)           GET LENGTH\n         LTR   R0,R9               IF LENGTH ZERO\n         BZ    FINAL                 DO FINAL PROCESSING\n         BM    BOTH                DO BOTH IF LENGTH NEGATIVE\n         ALR   R3,R9               ADD LENGTH TO TOTAL\n         BC    12,NOCARRY1\n*        AFI   R2,1\n         A     R2,=F'1'\nNOCARRY1 EQU   *\n         BAL   R11,CSUM            CHECKSUM THE STRING\n         B     DONE\nBOTH     LCR   R9,R9\n         ALR   R3,R9               ADD LENGTH TO TOTAL\n         BC    12,NOCARRY2         ADD LENGTH TO TOTAL\n*        AFI   R2,1\n         A     R2,=F'1'\nNOCARRY2 EQU   *\n         BAL   R11,CSUM            CHECKSUM THE STRING\nFINAL    BAL   R11,TERM            FINALIZE THE CHECKSUM\n         L     R1,ARGLIST+12       POINT TO RESULT\n         ST    R10,0(,R1)          SAVE CRC IN CONTEXT\n         ST    R2,4(,R1)           SAVE TOTAL LENGTH IN CONTEXT\n         ST    R3,8(,R1)           SAVE TOTAL LENGTH IN CONTEXT\n*              CONVERT INTEGERS TO EBCDIC\n         LA    R5,DOUBLE\n         LA    R5,7(,R5)           ROUND UP\n*        NILF  R5,-8               DOES SAME THING AS NEXT INSTR\n         N     R5,=A(X'FFFFFFF8')  TO DOUBLEWORD OUNDARY\n*              IF BYTECOUNT > ABOUT 200 TERABYTES\n*              THE DIVIDE-BY-100000 WILL GET A S0C9 EXCEPTION.\n*              HERE THE LIMIT IS CHECKED AND IF EXCEEDED\n*              THE DIVIDE WILL NOT BE USED, AND THE RESULT    .\n*              WILL BE 16 HEX DIGITS, WITH NO LEADING BLANK.\n*              SINCE 200 TERABYTES IS 15 DECIMAL DIGITS,\n*              AND THE RESULT AREA IS 16 BYTES, A DECIMAL RESULT\n*              WILL ALWAYS HAVE AT LEAST ONE LEADING BLANK.\n         CLC   4(8,R1),=X'0000C34FFFFFFFFF' 214,748,364,799,999\n         BNH   USEDEC\nUSEHEX   UNPK  UNPACK(9),4(5,R1)   HIGH WORD OF COUNT\n         UNPK  UNPACK+8(9),8(5,R1) LOW WORD OF COUNT\n         TR    UNPACK(16),HEXTAB-240\n         B     SETBYTES\nUSEDEC   D     R2,=F'100000'       DIVIDE BY 10 THOUSAND\n         CVD   R2,0(,R5)           REMAINDER TO PACKED DECIMAL\n         OI    7(R5),X'0F'         FIX SIGN IN DOUBLE+7 FOR UNPACK\n         UNPK  UNPACK+11(5),5(3,R5) DOUBLE+5(3) LAST 5 DIGITS\n         CVD   R3,0(,R5)           QUOTIENT TO PACKED DECIMAL\n         OI    7(R5),X'0F'         FIX SIGN IN DOUBLE+7 FOR UNPACK\n         UNPK  UNPACK(11),2(6,R5)  DOUBLE+2(6) FIRST 11 DIGITS\n         LA    R0,15\n         BAL   R11,ZEROSUP\nSETBYTES MVC   24(16,R1),UNPACK    COPY TO 7TH TO 10TH WORD OF RESULT\n         LR    R14,R1              SAVE R1\n         LR    R1,R10              GET CRC\n         SR    R0,R0               PREPARE TO DIVIDE\n         D     R0,=F'100000'       DIVIDE BY 10 THOUSAND\n         CVD   R0,0(,R5)           REMAINDER TO PACKED DECIMAL\n         OI    7(R5),X'0F'         FIX SIGN IN DOUBLE+7 FOR UNPACK\n         UNPK  UNPACK+7(5),5(3,R5) DOUBLE+5(3) LAST 5 DIGITS\n*                                  MAX QUOTIENT WILL BE 42949\n         CVD   R1,0(,R5)           QUOTIENT TO PACKED DECIMAL\n         OI    7(R5),X'0F'         FIX SIGN IN DOUBLE+7 FOR UNPACK\n         UNPK  UNPACK(7),3(5,R5)   DOUBLE+2(6) FIRST 7 DIGITS\n         LA    R0,11\n         BAL   R11,ZEROSUP\n         LR    R1,R14              RESTORE R1\n         MVC   12(12,R1),UNPACK    COPY TO 4TH TO 6TH WORD OF RESULT\n         B     DONE\nDONE     L     R1,ARGLIST+8        POINT TO CONTEXT\n         ST    R10,0(,R1)          SAVE CRC IN CONTEXT\n         ST    R2,4(,R1)           SAVE TOTAL LENGTH IN CONTEXT\n         ST    R3,8(,R1)           SAVE TOTAL LENGTH IN CONTEXT\n         B     EXIT0\n         SPACE\nZEROSUP  LA    R15,UNPACK\nZEROLOOP CLI   0(R15),C'0'\n         BNER  R11\n         MVI   0(R15),C' '\n         LA    R15,1(,R15)\n         BCT   R0,ZEROLOOP\n         BR    R11\n         SPACE\nCSUM     EQU   *\n         LA    R0,255              USED FOR 'NR'\nCSLOOP   SLR   R15,R15             CLEAR FOR IC\n         IC    R15,0(,R8)          GET NEXT CHAR\n         LR    R14,R10             GET INITIAL OR CURRENT CRC\n         SRL   R14,24              SHIFT RIGHT 24\n         XR    R15,R14             EXCLUSIVE OR\n         NR    R15,R0              ISOLATE LOW 8 BITS (LIKE NILF R,255)\n         SLL   R15,2               TIMES 4 FOR WORD OFFSET INTO TABLE\n         SLL   R10,8               SHIFT ORIGINAL/CURRENT CRC LEFT 8\n         X     R10,CRCTAB(R15)     EXCLUSIVE OR AGAINST TABLE WORD\n         LA    R8,1(,R8)           NEXT INPUT\n         BCT   R9,CSLOOP           DECREMENT, LOOP UNTIL LENGTH ZERO\n         BR    R11\n         SPACE\n*         FINALLY, WHEN ALL STRINGS FROM ALL CALLS ARE DONE,\n*         INSTEAD OF A STRING OF BYTES OF INPUT DATA,\n*         THE ENTIRE 64-BIT VALUE OF THE LENGTH IS USED,\n*         FOLLOWED BY THE VALUE SHIFTED RIGHT 8\n*         FOLLOWED BY THE VALUE SHIFTED RIGHT 8 AGAIN ...\n*         STOPPING AS SOON AS THE VALUE SHIFTED RIGHT 8 IS ZERO,\n*         FOLLOWED BY A BITWISE NOT USING HEX FFFFFFFF.\n*         A FINAL \"AND\" WITH HEX FFFFFFFF IS NOT NEEDED\n*         BECAUSE ONLY THE LOW 32 BITS ARE RETURNED TO CALLER.\nTERM     LR    R0,R2               GET TOTAL LENGTH HIGH HALF\n         LR    R1,R3               GET TOTAL LENGTH LOW HALF\nLENLOOP  LR    R14,R10             GET INITIAL OR CURRENT CRC\n         SRL   R14,24              SHIFT RIGHT 24\n         LR    R15,R1              COPY LENGTH\n*               WE ONLY NEED THE LOW HALF OF LENGTH,\n*               IN FACT, ONLY THE LOW 8 BITS OF LENGTH\n         XR    R15,R14             EXCLUSIVE OR WITH LENGTH\n*        NILF  R15,255             ISOLATE LOW 8 BITS\n         N     R15,=F'255'         ISOLATE LOW 8 BITS\n         SLL   R15,2               TIMES 4 FOR WORD OFFSET INTO TABLE\n         SLL   R10,8               SHIFT ORIGINAL/CURRENT CRC LEFT 8\n*                                  (IGNORING WHAT GETS SHIFTED OUT)\n         X     R10,CRCTAB(R15)     EXCLUSIVE OR AGAINST TABLE WORD\n         SRDA  R0,8                LENGTH SHIFTED RIGHT 8\n         BNZ   LENLOOP             BRANCH IF NOT ZERO\n*        XILF  R10,-1              (EQUIVALENT OF NEXT INSTR)\n         X     R10,=X'FFFFFFFF'    BITWISE NOT (TILDE IN C)\n         BR    R11\n*\nEXIT0    SR    R2,R2               RETURN CODE 0\n*        LR    R1,R13              POINT TO ADDRESS TO FREEMAIN\n*        L     R0,WORKSIZ          LENGTH TO FREEMAIN\n         L     R13,4(,R13)         RESTORE ORIGINAL R13\n*        FREEMAIN R,A=(1),LV=(0)\n         DROP  R7\n         LR    R15,R2\n         RETURN (14,12),RC=(15)\n         SPACE\n         LTORG\n         DC    0D'0'\nHEXTAB   DC    C'0123456789ABCDEF'\n         SPACE\nCRCTAB   DC    X'00000000',X'04C11DB7',X'09823B6E',X'0D4326D9'\n         DC    X'130476DC',X'17C56B6B',X'1A864DB2',X'1E475005'\n         DC    X'2608EDB8',X'22C9F00F',X'2F8AD6D6',X'2B4BCB61'\n         DC    X'350C9B64',X'31CD86D3',X'3C8EA00A',X'384FBDBD'\n         DC    X'4C11DB70',X'48D0C6C7',X'4593E01E',X'4152FDA9'\n         DC    X'5F15ADAC',X'5BD4B01B',X'569796C2',X'52568B75'\n         DC    X'6A1936C8',X'6ED82B7F',X'639B0DA6',X'675A1011'\n         DC    X'791D4014',X'7DDC5DA3',X'709F7B7A',X'745E66CD'\n         DC    X'9823B6E0',X'9CE2AB57',X'91A18D8E',X'95609039'\n         DC    X'8B27C03C',X'8FE6DD8B',X'82A5FB52',X'8664E6E5'\n         DC    X'BE2B5B58',X'BAEA46EF',X'B7A96036',X'B3687D81'\n         DC    X'AD2F2D84',X'A9EE3033',X'A4AD16EA',X'A06C0B5D'\n         DC    X'D4326D90',X'D0F37027',X'DDB056FE',X'D9714B49'\n         DC    X'C7361B4C',X'C3F706FB',X'CEB42022',X'CA753D95'\n         DC    X'F23A8028',X'F6FB9D9F',X'FBB8BB46',X'FF79A6F1'\n         DC    X'E13EF6F4',X'E5FFEB43',X'E8BCCD9A',X'EC7DD02D'\n         DC    X'34867077',X'30476DC0',X'3D044B19',X'39C556AE'\n         DC    X'278206AB',X'23431B1C',X'2E003DC5',X'2AC12072'\n         DC    X'128E9DCF',X'164F8078',X'1B0CA6A1',X'1FCDBB16'\n         DC    X'018AEB13',X'054BF6A4',X'0808D07D',X'0CC9CDCA'\n         DC    X'7897AB07',X'7C56B6B0',X'71159069',X'75D48DDE'\n         DC    X'6B93DDDB',X'6F52C06C',X'6211E6B5',X'66D0FB02'\n         DC    X'5E9F46BF',X'5A5E5B08',X'571D7DD1',X'53DC6066'\n         DC    X'4D9B3063',X'495A2DD4',X'44190B0D',X'40D816BA'\n         DC    X'ACA5C697',X'A864DB20',X'A527FDF9',X'A1E6E04E'\n         DC    X'BFA1B04B',X'BB60ADFC',X'B6238B25',X'B2E29692'\n         DC    X'8AAD2B2F',X'8E6C3698',X'832F1041',X'87EE0DF6'\n         DC    X'99A95DF3',X'9D684044',X'902B669D',X'94EA7B2A'\n         DC    X'E0B41DE7',X'E4750050',X'E9362689',X'EDF73B3E'\n         DC    X'F3B06B3B',X'F771768C',X'FA325055',X'FEF34DE2'\n         DC    X'C6BCF05F',X'C27DEDE8',X'CF3ECB31',X'CBFFD686'\n         DC    X'D5B88683',X'D1799B34',X'DC3ABDED',X'D8FBA05A'\n         DC    X'690CE0EE',X'6DCDFD59',X'608EDB80',X'644FC637'\n         DC    X'7A089632',X'7EC98B85',X'738AAD5C',X'774BB0EB'\n         DC    X'4F040D56',X'4BC510E1',X'46863638',X'42472B8F'\n         DC    X'5C007B8A',X'58C1663D',X'558240E4',X'51435D53'\n         DC    X'251D3B9E',X'21DC2629',X'2C9F00F0',X'285E1D47'\n         DC    X'36194D42',X'32D850F5',X'3F9B762C',X'3B5A6B9B'\n         DC    X'0315D626',X'07D4CB91',X'0A97ED48',X'0E56F0FF'\n         DC    X'1011A0FA',X'14D0BD4D',X'19939B94',X'1D528623'\n         DC    X'F12F560E',X'F5EE4BB9',X'F8AD6D60',X'FC6C70D7'\n         DC    X'E22B20D2',X'E6EA3D65',X'EBA91BBC',X'EF68060B'\n         DC    X'D727BBB6',X'D3E6A601',X'DEA580D8',X'DA649D6F'\n         DC    X'C423CD6A',X'C0E2D0DD',X'CDA1F604',X'C960EBB3'\n         DC    X'BD3E8D7E',X'B9FF90C9',X'B4BCB610',X'B07DABA7'\n         DC    X'AE3AFBA2',X'AAFBE615',X'A7B8C0CC',X'A379DD7B'\n         DC    X'9B3660C6',X'9FF77D71',X'92B45BA8',X'9675461F'\n         DC    X'8832161A',X'8CF30BAD',X'81B02D74',X'857130C3'\n         DC    X'5D8A9099',X'594B8D2E',X'5408ABF7',X'50C9B640'\n         DC    X'4E8EE645',X'4A4FFBF2',X'470CDD2B',X'43CDC09C'\n         DC    X'7B827D21',X'7F436096',X'7200464F',X'76C15BF8'\n         DC    X'68860BFD',X'6C47164A',X'61043093',X'65C52D24'\n         DC    X'119B4BE9',X'155A565E',X'18197087',X'1CD86D30'\n         DC    X'029F3D35',X'065E2082',X'0B1D065B',X'0FDC1BEC'\n         DC    X'3793A651',X'3352BBE6',X'3E119D3F',X'3AD08088'\n         DC    X'2497D08D',X'2056CD3A',X'2D15EBE3',X'29D4F654'\n         DC    X'C5A92679',X'C1683BCE',X'CC2B1D17',X'C8EA00A0'\n         DC    X'D6AD50A5',X'D26C4D12',X'DF2F6BCB',X'DBEE767C'\n         DC    X'E3A1CBC1',X'E760D676',X'EA23F0AF',X'EEE2ED18'\n         DC    X'F0A5BD1D',X'F464A0AA',X'F9278673',X'FDE69BC4'\n         DC    X'89B8FD09',X'8D79E0BE',X'803AC667',X'84FBDBD0'\n         DC    X'9ABC8BD5',X'9E7D9662',X'933EB0BB',X'97FFAD0C'\n         DC    X'AFB010B1',X'AB710D06',X'A6322BDF',X'A2F33668'\n         DC    X'BCB4666D',X'B8757BDA',X'B5365D03',X'B1F740B4'\n         DC    0D'0'\nWORKD    DSECT\n         DS    18F\nARGLIST  DS    4F\nDOUBLE   DS    3F\nUNPACK   DS    5F\nWORKINI  EQU   *-WORKD\n         DS    0D\nWORKLEN  EQU   *-WORKD\n         SPACE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CKSUMR24": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x003\\x01 \\x15\\x9f\\x01 \\x15\\x9f\\x14C\\x01<\\x01<\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-06-07T00:00:00", "modifydate": "2020-06-07T14:43:33", "lines": 316, "newlines": 316, "modlines": 0, "user": "UPDATED"}, "text": "         TITLE ' C K S U M R '\n*\n*        SUBROUTINE TO COMPUTE THE SAME KIND OF CHECKSUM\n*        USED IN THE Z/OS UNIX SYSTEM SERVICES 'CKSUM' COMMAND,\n*        NOT TO MENTION THE SAME COMMAND IN AIX AND LINUX.\n*        THE ARGUMENT LIST IS SIMILAR IN MANY RESPECTS TO THE\n*        'MD5' SUBROUTINE IN FILE 900 OF THE CBT TAPE.\n*\n*        WRITTEN MAY 31 2020 FOR THE 'CKSUM' TSO COMMAND\n*\n*        JIM CONNELLEY DESERVES ACKNOWLEDGEMENT FOR THE ASSEMBLER\n*        CODE IN CBT FILE 493 MEMBER CRC32, WHICH COMPUTES A\n*        ANOTHER CRCSUM USING A SLIGHTLY DIFFERENT ALGORITHM\n*        AND A DIFFERENT POLYNOMIAL TABLE.\n*\n*        CALL CKSUMR(STRING,LENGTH,CONTEXT,RESULT,WORKSPACE)\n*\n*        LENGTH IS A FULLWORD CONTAINING THE LENGTH OF STRING.\n*\n*        CONTEXT IS 3 FULLWORDS WHICH SHOULD BE CLEARED TO BINARY\n*        ZEROES BEFORE THE FIRST CALL, AND LEFT UNCHANGED AFTER THAT,\n*        UNLESS AN ADDITIONAL CHECKSUM IS TO BE COMPUTED FOR ANOTHER\n*        STRING, IN WHICH CASE IT SHOULD BE CLEARED AGAIN FOR THE\n*        FIRST CALL FOR THE OTHER STRING.\n*\n*        RESULT IS 10 FULLWORDS WHICH WILL CONTAIN, AFTER THE\n*        FINAL CALL:\n*        1) THE CHECKSUM AS A 32-BIT UNSIGNED NUMBER,\n*        2) THE BYTE COUNT AS A 64-BIT NUMBER,\n*        3) A SPAN OF 3 WORDS CONTAINING A 12-BYTE EBCDIC STRING\n*           CONSISTING OF LEADING SPACES AND A 1-TO-10-DIGIT NUMBER\n*           REPRESENTING THE SAME CHECKSUM AS THE FIRST WORD,\n*           RANGING FROM '           0' TO '  4294967295'.\n*           THIS IS PROVIDED AS A CONVENIENCE FOR CASES WHERE THE\n*           THE CALLING PROGRAM IS IN A LANGUAGE THAT ONLY\n*           SUPPORTS CONVERTING SIGNED INTEGERS TO A PRINTABLE FORM.\n*        4) A SPAN OF 4 WORDS CONTAINING A 16-BYTE EBCDIC STRING\n*           REPRESENTING THE BYTE COUNT\n*           IF THE LEFTMOST BYTE IS A BLANK, THE NUMBER IS DECIMAL,\n*           WITH LEADING ZEROES CHANGED TO BLANKS.\n*           OTHERWISE THE NUMBER IS HEXADECIMAL EBCDIC DIGITS,\n*           WHICH ONLY HAPPENS IF THE BYTE COUNT EXCEEDS\n*           214,748,364,799,999.\n*\n*        WORKSPACE IS 30 FULLWORDS AND ITS CONTENTS DO NOT NEED TO\n*        BE SET BY THE CALLER. IT IS USED AS A REGISTER SAVE AREA\n*        AND TEMPORARY WORK SPACE.\n*\n*        AT LEAST 2 CALLS WILL BE NEEDED - ONE OR MORE WITH\n*        A STRING AND ONE WITH THE STRING LENGTH SET TO ZERO.\n*        IF LENGTH IS 0, RESULT WILL CONTAIN AN UNSIGNED\n*        32-BIT NUMBER, AMONG OTHER THINGS DESCRIBED EARLIER.\n*\n*        IF LENGTH IS NEGATIVE, ONLY ONE CALL IS NEEDED. IT IS THE\n*        EQUIVALENT OF ONE CALL WITH A POSITIVE LENGTH AND\n*        ANOTHER WITH A ZERO LENGTH. THE NEGATIVE LENGTH IS\n*        ZERO MINUS THE STRING LENGTH. THE CONTEXT IN THIS CASE\n*        DOES NOT NEED TO BE CLEARED TO ZEROES.\n*\nCKSUMR   CSECT\n*CKSUMR  AMODE ANY31\n*CKSUMR  RMODE 31\n         USING *,R12\n         B     BEGIN-*(,R15)\n         DC    AL1(7),CL7'CKSUMR'\n         DC    CL16' &SYSDATE &SYSTIME '\n*        DC    CL16' 05/31/20 11:00 '\nWORKSIZ  DC    0F'0',AL1(0),AL3(WORKLEN)\nBEGIN    STM   14,12,12(13)\n         LR    R12,R15\n         LR    R2,R1               POINT TO ARGS PASSED\n         L     R7,16(,R2)          POINT TO WORKSPACE, 5TH ARG\n*        L     R0,WORKSIZ\n*        GETMAIN R,LV=(0)\n*        LR    R7,R1\n         USING WORKD,R7\n         XC    0(WORKINI,R7),0(R7)\n         ST    R13,4(,R7)          OLD ADDRESS IN NEW SAVE AREA\n         ST    R7,8(,R13)          NEW ADDRESS IN OLD SAVE AREA\n         LR    R13,R7\n         MVC   ARGLIST(16),0(R2)   SAVE 1ST 4 ARG ADDRESSES\n         SPACE\n         LM    R8,R10,ARGLIST      GET STRING ADDR, LEN ADDR, CONTEXT\n         L     R2,4(,R10)          GET TOTAL LENGTH SO FAR\n         L     R3,8(,R10)          GET TOTAL LENGTH SO FAR\n         L     R10,0(,R10)         GET INITIAL/CURRENT CRC\n         L     R9,0(,R9)           GET LENGTH\n         LTR   R0,R9               IF LENGTH ZERO\n         BZ    FINAL                 DO FINAL PROCESSING\n         BM    BOTH                DO BOTH IF LENGTH NEGATIVE\n         ALR   R3,R9               ADD LENGTH TO TOTAL\n         BC    12,NOCARRY1\n*        AFI   R2,1\n         A     R2,=F'1'\nNOCARRY1 EQU   *\n         BAL   R11,CSUM            CHECKSUM THE STRING\n         B     DONE\nBOTH     LCR   R9,R9\n         ALR   R3,R9               ADD LENGTH TO TOTAL\n         BC    12,NOCARRY2         ADD LENGTH TO TOTAL\n*        AFI   R2,1\n         A     R2,=F'1'\nNOCARRY2 EQU   *\n         BAL   R11,CSUM            CHECKSUM THE STRING\nFINAL    BAL   R11,TERM            FINALIZE THE CHECKSUM\n         L     R1,ARGLIST+12       POINT TO RESULT\n         ST    R10,0(,R1)          SAVE CRC IN CONTEXT\n         ST    R2,4(,R1)           SAVE TOTAL LENGTH IN CONTEXT\n         ST    R3,8(,R1)           SAVE TOTAL LENGTH IN CONTEXT\n*              CONVERT INTEGERS TO EBCDIC\n         LA    R5,DOUBLE\n         LA    R5,7(,R5)           ROUND UP\n*        NILF  R5,-8               DOES SAME THING AS NEXT INSTR\n         N     R5,=A(X'FFFFFFF8')  TO DOUBLEWORD OUNDARY\n*              IF BYTECOUNT > ABOUT 200 TERABYTES\n*              THE DIVIDE-BY-100000 WILL GET A S0C9 EXCEPTION.\n*              HERE THE LIMIT IS CHECKED AND IF EXCEEDED\n*              THE DIVIDE WILL NOT BE USED, AND THE RESULT    .\n*              WILL BE 16 HEX DIGITS, WITH NO LEADING BLANK.\n*              SINCE 200 TERABYTES IS 15 DECIMAL DIGITS,\n*              AND THE RESULT AREA IS 16 BYTES, A DECIMAL RESULT\n*              WILL ALWAYS HAVE AT LEAST ONE LEADING BLANK.\n         CLC   4(8,R1),=X'0000C34FFFFFFFFF' 214,748,364,799,999\n         BNH   USEDEC\nUSEHEX   UNPK  UNPACK(9),4(5,R1)   HIGH WORD OF COUNT\n         UNPK  UNPACK+8(9),8(5,R1) LOW WORD OF COUNT\n         TR    UNPACK(16),HEXTAB-240\n         B     SETBYTES\nUSEDEC   D     R2,=F'100000'       DIVIDE BY 10 THOUSAND\n         CVD   R2,0(,R5)           REMAINDER TO PACKED DECIMAL\n         OI    7(R5),X'0F'         FIX SIGN IN DOUBLE+7 FOR UNPACK\n         UNPK  UNPACK+11(5),5(3,R5) DOUBLE+5(3) LAST 5 DIGITS\n         CVD   R3,0(,R5)           QUOTIENT TO PACKED DECIMAL\n         OI    7(R5),X'0F'         FIX SIGN IN DOUBLE+7 FOR UNPACK\n         UNPK  UNPACK(11),2(6,R5)  DOUBLE+2(6) FIRST 11 DIGITS\n         LA    R0,15\n         BAL   R11,ZEROSUP\nSETBYTES MVC   24(16,R1),UNPACK    COPY TO 7TH TO 10TH WORD OF RESULT\n         LR    R14,R1              SAVE R1\n         LR    R1,R10              GET CRC\n         SR    R0,R0               PREPARE TO DIVIDE\n         D     R0,=F'100000'       DIVIDE BY 10 THOUSAND\n         CVD   R0,0(,R5)           REMAINDER TO PACKED DECIMAL\n         OI    7(R5),X'0F'         FIX SIGN IN DOUBLE+7 FOR UNPACK\n         UNPK  UNPACK+7(5),5(3,R5) DOUBLE+5(3) LAST 5 DIGITS\n*                                  MAX QUOTIENT WILL BE 42949\n         CVD   R1,0(,R5)           QUOTIENT TO PACKED DECIMAL\n         OI    7(R5),X'0F'         FIX SIGN IN DOUBLE+7 FOR UNPACK\n         UNPK  UNPACK(7),3(5,R5)   DOUBLE+2(6) FIRST 7 DIGITS\n         LA    R0,11\n         BAL   R11,ZEROSUP\n         LR    R1,R14              RESTORE R1\n         MVC   12(12,R1),UNPACK    COPY TO 4TH TO 6TH WORD OF RESULT\n         B     DONE\nDONE     L     R1,ARGLIST+8        POINT TO CONTEXT\n         ST    R10,0(,R1)          SAVE CRC IN CONTEXT\n         ST    R2,4(,R1)           SAVE TOTAL LENGTH IN CONTEXT\n         ST    R3,8(,R1)           SAVE TOTAL LENGTH IN CONTEXT\n         B     EXIT0\n         SPACE\nZEROSUP  LA    R15,UNPACK\nZEROLOOP CLI   0(R15),C'0'\n         BNER  R11\n         MVI   0(R15),C' '\n         LA    R15,1(,R15)\n         BCT   R0,ZEROLOOP\n         BR    R11\n         SPACE\nCSUM     EQU   *\n         LA    R0,255              USED FOR 'NR'\nCSLOOP   SLR   R15,R15             CLEAR FOR IC\n         IC    R15,0(,R8)          GET NEXT CHAR\n         LR    R14,R10             GET INITIAL OR CURRENT CRC\n         SRL   R14,24              SHIFT RIGHT 24\n         XR    R15,R14             EXCLUSIVE OR\n         NR    R15,R0              ISOLATE LOW 8 BITS (LIKE NILF R,255)\n         SLL   R15,2               TIMES 4 FOR WORD OFFSET INTO TABLE\n         SLL   R10,8               SHIFT ORIGINAL/CURRENT CRC LEFT 8\n         X     R10,CRCTAB(R15)     EXCLUSIVE OR AGAINST TABLE WORD\n         LA    R8,1(,R8)           NEXT INPUT\n         BCT   R9,CSLOOP           DECREMENT, LOOP UNTIL LENGTH ZERO\n         BR    R11\n         SPACE\n*         FINALLY, WHEN ALL STRINGS FROM ALL CALLS ARE DONE,\n*         INSTEAD OF A STRING OF BYTES OF INPUT DATA,\n*         THE ENTIRE 64-BIT VALUE OF THE LENGTH IS USED,\n*         FOLLOWED BY THE VALUE SHIFTED RIGHT 8\n*         FOLLOWED BY THE VALUE SHIFTED RIGHT 8 AGAIN ...\n*         STOPPING AS SOON AS THE VALUE SHIFTED RIGHT 8 IS ZERO,\n*         FOLLOWED BY A BITWISE NOT USING HEX FFFFFFFF.\n*         A FINAL \"AND\" WITH HEX FFFFFFFF IS NOT NEEDED\n*         BECAUSE ONLY THE LOW 32 BITS ARE RETURNED TO CALLER.\nTERM     LR    R0,R2               GET TOTAL LENGTH HIGH HALF\n         LR    R1,R3               GET TOTAL LENGTH LOW HALF\nLENLOOP  LR    R14,R10             GET INITIAL OR CURRENT CRC\n         SRL   R14,24              SHIFT RIGHT 24\n         LR    R15,R1              COPY LENGTH\n*               WE ONLY NEED THE LOW HALF OF LENGTH,\n*               IN FACT, ONLY THE LOW 8 BITS OF LENGTH\n         XR    R15,R14             EXCLUSIVE OR WITH LENGTH\n*        NILF  R15,255             ISOLATE LOW 8 BITS\n         N     R15,=F'255'         ISOLATE LOW 8 BITS\n         SLL   R15,2               TIMES 4 FOR WORD OFFSET INTO TABLE\n         SLL   R10,8               SHIFT ORIGINAL/CURRENT CRC LEFT 8\n*                                  (IGNORING WHAT GETS SHIFTED OUT)\n         X     R10,CRCTAB(R15)     EXCLUSIVE OR AGAINST TABLE WORD\n         SRDA  R0,8                LENGTH SHIFTED RIGHT 8\n         BNZ   LENLOOP             BRANCH IF NOT ZERO\n*        XILF  R10,-1              (EQUIVALENT OF NEXT INSTR)\n         X     R10,=X'FFFFFFFF'    BITWISE NOT (TILDE IN C)\n         BR    R11\n*\nEXIT0    SR    R2,R2               RETURN CODE 0\n*        LR    R1,R13              POINT TO ADDRESS TO FREEMAIN\n*        L     R0,WORKSIZ          LENGTH TO FREEMAIN\n         L     R13,4(,R13)         RESTORE ORIGINAL R13\n*        FREEMAIN R,A=(1),LV=(0)\n         DROP  R7\n         LR    R15,R2\n         RETURN (14,12),RC=(15)\n         SPACE\n         LTORG\n         DC    0D'0'\nHEXTAB   DC    C'0123456789ABCDEF'\n         SPACE\nCRCTAB   DC    X'00000000',X'04C11DB7',X'09823B6E',X'0D4326D9'\n         DC    X'130476DC',X'17C56B6B',X'1A864DB2',X'1E475005'\n         DC    X'2608EDB8',X'22C9F00F',X'2F8AD6D6',X'2B4BCB61'\n         DC    X'350C9B64',X'31CD86D3',X'3C8EA00A',X'384FBDBD'\n         DC    X'4C11DB70',X'48D0C6C7',X'4593E01E',X'4152FDA9'\n         DC    X'5F15ADAC',X'5BD4B01B',X'569796C2',X'52568B75'\n         DC    X'6A1936C8',X'6ED82B7F',X'639B0DA6',X'675A1011'\n         DC    X'791D4014',X'7DDC5DA3',X'709F7B7A',X'745E66CD'\n         DC    X'9823B6E0',X'9CE2AB57',X'91A18D8E',X'95609039'\n         DC    X'8B27C03C',X'8FE6DD8B',X'82A5FB52',X'8664E6E5'\n         DC    X'BE2B5B58',X'BAEA46EF',X'B7A96036',X'B3687D81'\n         DC    X'AD2F2D84',X'A9EE3033',X'A4AD16EA',X'A06C0B5D'\n         DC    X'D4326D90',X'D0F37027',X'DDB056FE',X'D9714B49'\n         DC    X'C7361B4C',X'C3F706FB',X'CEB42022',X'CA753D95'\n         DC    X'F23A8028',X'F6FB9D9F',X'FBB8BB46',X'FF79A6F1'\n         DC    X'E13EF6F4',X'E5FFEB43',X'E8BCCD9A',X'EC7DD02D'\n         DC    X'34867077',X'30476DC0',X'3D044B19',X'39C556AE'\n         DC    X'278206AB',X'23431B1C',X'2E003DC5',X'2AC12072'\n         DC    X'128E9DCF',X'164F8078',X'1B0CA6A1',X'1FCDBB16'\n         DC    X'018AEB13',X'054BF6A4',X'0808D07D',X'0CC9CDCA'\n         DC    X'7897AB07',X'7C56B6B0',X'71159069',X'75D48DDE'\n         DC    X'6B93DDDB',X'6F52C06C',X'6211E6B5',X'66D0FB02'\n         DC    X'5E9F46BF',X'5A5E5B08',X'571D7DD1',X'53DC6066'\n         DC    X'4D9B3063',X'495A2DD4',X'44190B0D',X'40D816BA'\n         DC    X'ACA5C697',X'A864DB20',X'A527FDF9',X'A1E6E04E'\n         DC    X'BFA1B04B',X'BB60ADFC',X'B6238B25',X'B2E29692'\n         DC    X'8AAD2B2F',X'8E6C3698',X'832F1041',X'87EE0DF6'\n         DC    X'99A95DF3',X'9D684044',X'902B669D',X'94EA7B2A'\n         DC    X'E0B41DE7',X'E4750050',X'E9362689',X'EDF73B3E'\n         DC    X'F3B06B3B',X'F771768C',X'FA325055',X'FEF34DE2'\n         DC    X'C6BCF05F',X'C27DEDE8',X'CF3ECB31',X'CBFFD686'\n         DC    X'D5B88683',X'D1799B34',X'DC3ABDED',X'D8FBA05A'\n         DC    X'690CE0EE',X'6DCDFD59',X'608EDB80',X'644FC637'\n         DC    X'7A089632',X'7EC98B85',X'738AAD5C',X'774BB0EB'\n         DC    X'4F040D56',X'4BC510E1',X'46863638',X'42472B8F'\n         DC    X'5C007B8A',X'58C1663D',X'558240E4',X'51435D53'\n         DC    X'251D3B9E',X'21DC2629',X'2C9F00F0',X'285E1D47'\n         DC    X'36194D42',X'32D850F5',X'3F9B762C',X'3B5A6B9B'\n         DC    X'0315D626',X'07D4CB91',X'0A97ED48',X'0E56F0FF'\n         DC    X'1011A0FA',X'14D0BD4D',X'19939B94',X'1D528623'\n         DC    X'F12F560E',X'F5EE4BB9',X'F8AD6D60',X'FC6C70D7'\n         DC    X'E22B20D2',X'E6EA3D65',X'EBA91BBC',X'EF68060B'\n         DC    X'D727BBB6',X'D3E6A601',X'DEA580D8',X'DA649D6F'\n         DC    X'C423CD6A',X'C0E2D0DD',X'CDA1F604',X'C960EBB3'\n         DC    X'BD3E8D7E',X'B9FF90C9',X'B4BCB610',X'B07DABA7'\n         DC    X'AE3AFBA2',X'AAFBE615',X'A7B8C0CC',X'A379DD7B'\n         DC    X'9B3660C6',X'9FF77D71',X'92B45BA8',X'9675461F'\n         DC    X'8832161A',X'8CF30BAD',X'81B02D74',X'857130C3'\n         DC    X'5D8A9099',X'594B8D2E',X'5408ABF7',X'50C9B640'\n         DC    X'4E8EE645',X'4A4FFBF2',X'470CDD2B',X'43CDC09C'\n         DC    X'7B827D21',X'7F436096',X'7200464F',X'76C15BF8'\n         DC    X'68860BFD',X'6C47164A',X'61043093',X'65C52D24'\n         DC    X'119B4BE9',X'155A565E',X'18197087',X'1CD86D30'\n         DC    X'029F3D35',X'065E2082',X'0B1D065B',X'0FDC1BEC'\n         DC    X'3793A651',X'3352BBE6',X'3E119D3F',X'3AD08088'\n         DC    X'2497D08D',X'2056CD3A',X'2D15EBE3',X'29D4F654'\n         DC    X'C5A92679',X'C1683BCE',X'CC2B1D17',X'C8EA00A0'\n         DC    X'D6AD50A5',X'D26C4D12',X'DF2F6BCB',X'DBEE767C'\n         DC    X'E3A1CBC1',X'E760D676',X'EA23F0AF',X'EEE2ED18'\n         DC    X'F0A5BD1D',X'F464A0AA',X'F9278673',X'FDE69BC4'\n         DC    X'89B8FD09',X'8D79E0BE',X'803AC667',X'84FBDBD0'\n         DC    X'9ABC8BD5',X'9E7D9662',X'933EB0BB',X'97FFAD0C'\n         DC    X'AFB010B1',X'AB710D06',X'A6322BDF',X'A2F33668'\n         DC    X'BCB4666D',X'B8757BDA',X'B5365D03',X'B1F740B4'\n         DC    0D'0'\nWORKD    DSECT\n         DS    18F\nARGLIST  DS    4F\nDOUBLE   DS    3F\nUNPACK   DS    5F\nWORKINI  EQU   *-WORKD\n         DS    0D\nWORKLEN  EQU   *-WORKD\n         SPACE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CKSUM24": {"ttr": 1543, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01 \\x16o\\x01 \\x16o!\\x00\\x04]\\x04]\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-06-14T00:00:00", "modifydate": "2020-06-14T21:00:03", "lines": 1117, "newlines": 1117, "modlines": 0, "user": "UPDATED"}, "text": "         TITLE '   C K S U M  '\n************************************************************\n*                                                          *\n*        'CKSUM' TSO COMMAND (24-BIT)                      *\n*                                                          *\n************************************************************\n         SPACE\n*  COMPUTE AND DISPLAY A CHECKSUM OF THE CONTENTS OF A DATASET,\n*  OR THE SEPARATE CHECKSUMS OF A LIST OF DATA SETS.\n*  THE CHECKSUM IS THE SAME TYPE USED IN THE\n*  Z/OS UNIX SYSTEM SERVICES 'CKSUM' COMMAND, AND IN THE\n*  'CKSUM' COMMAND IN AIX, LINUX, AND PROBABLY OTHER SYSTEMS.\n*  ALL OF THE CHECKSUM PROCESSING IS DONE IN THE SEPARATE\n*  'CKSUMR' SUBROUTINE CALLED BY THIS COMMAND.\n*\n*  WRITTEN MAY 31 2020 USING SOURCE CODE FOR THE 'MD5SUM'\n*  COMMAND IN FILE 900 OF THE CBT TAPE, WHICH IN TURN\n*  USED SOURCE CODE FROM THE 'COUNT' COMMAND IN FILE 300.\n*\n*  ATTRIBUTES. RE-ENTRANT.\n*\n*  THIS TSO COMMAND READS THE SPECIFIED SEQUENTIAL DATA SETS\n*  OR PDS MEMBERS AND DISPLAYS A CHECKSUM FOR EACH.\n*\n*        IF AN UNQUALIFIED DATA SET NAME IS ENTERED, THE\n*        CATALOG MUST BE READ TWICE, ONCE TO APPEND A\n*        TRAILING QUALIFIER IF NECESSARY, AND AGAIN DURING\n*        ALLOCATION. THE USER CAN ELIMINATE THE FIRST BY USING\n*        THE FULLY QUALIFIED NAME, PREFIX AND ALL, IN QUOTES,\n*        OR BY ENTERING ALL BUT THE PREFIX, WITHOUT QUOTES,\n*        PLUS THE KEYWORD 'Q'. THE LATTER IS MUCH SIMPLER\n*        AND GIVES THE SAME PERFORMANCE IMPROVEMENT AS A\n*        FULLY QUALIFIED NAME.\n*\n*        THE 'FILE' KEYWORD IS USEFUL FOR READING TEMPORARY\n*        DATA SETS.  IT TELLS THE COMMAND TO TREAT THE FIRST\n*        OPERAND AS A FILENAME (DDNAME) INSTEAD OF A DSNAME.\n*        WHATEVER DATA SET IS CURRENTLY ALLOCATED TO THE\n*        FILENAME WILL BE READ (AND QUICKLY, BECAUSE\n*        THE COMMAND DOESNT HAVE TO ALLOCATE ANYTHING).\n*\n*        NOTE - IF A NON-EXISTENT MEMBER OF A PDS IS SPECIFIED,\n*        THE RESULTING 013-18 ABEND IS TRAPPED BY A DCB ABEND\n*        EXIT, BUT A MESSAGE IS ISSUED BY OPEN ANYWAY. THIS\n*        METHOD IS USED BECAUSE THE ADDITIONAL OVERHEAD\n*        OF ALLOCATING THE PDS AND DOING A 'BLDL' WOULD\n*        DEGRADE THE PERFORMANCE UNACCEPTABLY.\n         MACRO                                                   JDM1\n&NAME    OBTAIN &LIST,&DUMMY=                                    JDM1\n         AIF   (T'&LIST EQ 'O').E1                               JDM1\n&NAME    IHBINNRA &LIST                 LOAD REG 1               JDM1\n         SVC   27                       ISSUE OBTAIN SVC         JDM1\n         MEXIT                                                   JDM1\n.E1      IHBERMAC 34                    LIST ADDR MISSING        JDM1\n         MEND                                                    JDM1\n*         INTERCEPT 'LINK' MACRO IMBEDDED IN STACK MACRO\n*         TO MAKE SF=(E,LINKAREA) THE DEFAULT.\n         MACRO\n&NAME    LINK  &EP=,&SF=(E,LINKAREA)\n&NAME    LA    15,&SF(2)\n         LA    0,*+8\n         B     *+12\n         DC    CL8'&EP'\n         ST    0,0(0,15)\n         SVC   6             ISSUE LINK SVC\n         MEND\n         SPACE\n         GBLB  &MVS\n&MVS     SETB  1                   1 - MVS   0 - SVS,MVT\n         SPACE\nCKSUM    START\n         USING *,R12,R11\n         B     @PROLOG-*(,R15)\n         DC    AL1(5),CL5'CKSUM'\n         DC    CL16' &SYSDATE &SYSTIME '\n@SIZE    DC    0F'0',AL1(1),AL3(@DATAL)\n@PROLOG  STM   14,12,12(13)\n         LR    R12,R15             BASE\n         LA    R15,1\n         LA    R11,4095(R15,R12)   BASE\n         LR    R2,R1\n         USING CPPL,R2\n         L     R0,@SIZE\n         GETMAIN R,LV=(0)\n         LR    R9,R1\n         USING @DATA,R9\n         ST    13,4(,1)            CHAIN SAVEAREA\n         ST    1,8(,13)            CHAIN SAVEAREA\n         LR    13,1                NEW SAVEAREA\n         SPACE 1\n         MVI   STATUS,0\n         XC    LINKAREA(8),LINKAREA\n         SLR   R15,R15\n         STH   R15,RETCODE         SET RETCODE = 0\n         SPACE\n************************************************************\n*                                                          *\n*        SET UP IOPL FOR PUTLINE                           *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R15,MYIOPL\n         USING IOPL,R15\n         MVC   IOPLUPT(4),CPPLUPT\n         MVC   IOPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,IOPLECB\n         XC    MYECB,MYECB\n         LA    R0,MYPTPB\n         ST    R0,IOPLIOPB\n         DROP  R15                 IOPL\n         SPACE\n         AIF   (NOT &MVS).SKIP1\n         L     R15,16              LOAD CVT POINTER\n         TM    444(R15),X'80'      IS PUTLINE LOADED? (VS2)\n         BNO   PUTLOAD             NO - BRANCH TO LOAD\n         L     R15,444(,R15)       YES - USE CVTPUTL\n         B     PUTLOADX            BRANCH AROUND LOAD\n.SKIP1   ANOP\nPUTLOAD  LA    R0,=CL8'IKJPUTL '\n         LOAD  EPLOC=(0)\n         LR    R15,R0              GET ENTRY ADDRESS\n         LA    R15,0(,R15)         CLEAR HI BYTE FOR DELETE ROUTINE\nPUTLOADX ST    R15,MYPUTLEP        SAVE PUTLINE ENTRY ADDRESS\n         SPACE\n************************************************************\n*                                                          *\n*        SET UP PPL FOR PARSE                              *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R15,MYPPL\n         USING PPL,R15\n         MVC   PPLUPT(4),CPPLUPT\n         MVC   PPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,PPLECB\n         XC    MYECB,MYECB\n         L     R0,=A(CKSUMPCL)\n*        LA    R0,PCLADDR\n         ST    R0,PPLPCL\n         LA    R0,MYANS\n         ST    R0,PPLANS\n         XC    MYANS(4),MYANS\n         MVC   PPLCBUF(4),CPPLCBUF\n         ST    R9,PPLUWA\n         DROP  R15                 PPL\n         SPACE 1\n************************************************************\n*                                                          *\n*        CALL THE PARSE SERVICE ROUTINE                    *\n*                                                          *\n************************************************************\n         SPACE 1\n         LR    R1,R15              POINT TO PPL\n         AIF   (NOT &MVS).SKIP2\n         L     R15,16              CVTPTR\n         TM    524(R15),X'80'      IF HI ORDER BIT NOT ON\n         BNO   PARSELNK               THEN DO LINK, NOT CALL\n         L     R15,524(,R15)       CVTPARS\n         BALR  R14,R15             CALL IKJPARS\n         B     PARSEEXT            SKIP AROUND LINK\nPARSELNK EQU   *\n.SKIP2   ANOP\n         LINK  EP=IKJPARS,SF=(E,LINKAREA)\nPARSEEXT EQU   *\n         SPACE 1\n         LTR   R15,R15\n         BZ    PARSEOK\n         LA    R1,MSG01\n         LA    R0,L'MSG01\n         BAL   R14,PUTMSG\n         LA    R15,12\n         B     EXIT\nPARSEOK  EQU   *\n         SPACE\n         L     R3,MYANS\n         USING IKJPARMD,R3\n         SPACE\n************************************************************\n*                                                          *\n*        GET THE FIRST OR NEXT DSN IN THE LIST             *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R6,DSN\n         B     FIRSTDSN\nNEXTDSN  CLI   24(R6),X'FF'        END OF DSN LIST?\n         BE    DONE\n         L     R6,24(,R6)          POINT TO NEXT ENTRY\nFIRSTDSN EQU   *\n         SPACE\n************************************************************\n*                                                          *\n*        QUALIFY THE DSNAME IF NECESSARY                   *\n*                                                          *\n************************************************************\n         SPACE\n         TM    6(R6),X'80'         IS DATASET NAME SPECIFIED?\n         BO    OKDSN               YES - BRANCH\n         LA    R1,MSG05            NO - JUST MEMBER NAME\n         LA    R0,L'MSG05\n         BAL   R14,PUTMSG\n         B     NEXTD12\nOKDSN    EQU   *\n         LA    R15,DSNAME+2\n         MVI   0(R15),C' '         BLANK THE DSNAME AREA\n         MVC   1(43,R15),0(R15)\n         SLR   R1,R1\n         STH   R1,DSNAME           ZERO DSNAME LENGTH\n         TM    6(R6),X'40'         IS DSN QUOTED?\n         BO    NOPREF              YES, SKIP PREFIXING\n         CLI   FILEKW+1,1          DSN TO BE TREATED AS DDNAME\n         BE    NOPREF              YES, SKIP PREFIXING\n         AIF   (NOT &MVS).SKIPP    PREFIX WITH PREFIX\n         L     R14,CPPLUPT         POINT TO UPT\n         USING UPT,R14\n         IC    R1,UPTPREFL         GET LENGTH OF PREFIX\n         LTR   R1,R1               IS IT ZERO\n         BZ    NOPREF              YES, SKIP PREFIXING\n         B     *+10\n         MVC   0(0,R15),UPTPREFX\n         DROP  R14                 UPT\n.SKIPP   AIF   (&MVS).SKIPU        PREFIX WITH USERID\n         L     R14,CPPLPSCB        POINT TO PSCB\n         USING PSCB,R14\n         IC    R1,PSCBUSRL         GET LENGTH OF USERID\n         LTR   R1,R1               IS IT ZERO\n         BZ    NOPREF              YES, SKIP PREFIXING\n         B     *+10\n         MVC   0(0,R15),PSCBUSER\n         DROP  R14                 PSCB\n.SKIPU   ANOP\n         EX    R1,*-6              MOVE USERID TO DSNAME AREA\n         LA    R15,0(R1,R15)       POINT PAST USERID\n         MVI   0(R15),C'.'         APPEND PERIOD\n         LA    R15,1(,R15)         POINT PAST PERIOD\n         LA    R1,1(,R1)           ADD 1 TO LENGTH\n         STH   R1,DSNAME           STORE LENGTH OF USERID PLUS 1\nNOPREF   EQU   *\n         LH    R1,4(,R6)           GET LENGTH\n         LR    R0,R1\n         AH    R0,DSNAME           ADD LENGTH OF PREFIX OR ZERO\n         STH   R0,DSNAME           SET COMBINED LENGTH\n         L     R14,0(,R6)          POINT TO DSN VALUE\n         BCTR  R1,0                LENGTH MINUS 1 FOR EX\n         B     *+10                BRANCH AROUND EXECUTED MVC\n         MVC   0(0,R15),0(R14)     (EXECUTED)\n         EX    R1,*-6              MOVE DSN TO DSNAME (AFTER PREFIX)\n         SPACE\n************************************************************\n*                                                          *\n*        IF 'FILE' KEYWORD IS SPECIFIED,                   *\n*        GET DSNAME FROM JFCB USING FILE NAME.             *\n*                                                          *\n************************************************************\n         SPACE\n         CLI   FILEKW+1,1          'FILE' SPECIFIED?\n         BNE   NOFILE              NO, BRANCH\n         CLI   DSNAME+1,8          IS LENGTH 8 OR LESS\n         BH    FILERR1             NO, BRANCH\n         DEVTYPE DSNAME+2,DEVDATA  GET DEVICE TYPE\n         LTR   R15,R15             WAS FILENAME VALID\n         BNZ   FILERR2             NO, BRANCH\n         TM    DEVDATA+2,X'20'     DIRECT ACCESS\n         BZ    FILERR3             NO, BRANCH\n         LA    R4,DYNDCBW\n         MVC   0(DYNDCBL,R4),DYNDCB\n         XC    MEMLEN,MEMLEN\n         LA    R0,JFCB\n         LA    R1,DYNEXLST\n         ST    R0,0(,R1)\n         MVI   0(R1),X'87'\n         ST    R1,36(,R4)          DCBEXLST\n         MVC   40(8,R4),DSNAME+2   DCBDDNAM\n         MVC   DDSAVE,DSNAME+2\n         MVI   OPEND,X'80'\n         RDJFCB ((R4)),MF=(E,OPEND)\n         MVC   DSNAME+2(44),JFCB\n         LA    R1,DSNAME+45        LAST CHAR OF DSNAME\n         LA    R0,44               INITIAL LENGTH\nFILEA    CLI   0(R1),C' '          IS THIS LAST NONBLANK\n         BNE   FILEB               YES, BRANCH\n         BCTR  R1,0                BACK UP 1 CHARACTER\n         BCT   R0,FILEA            DECREMENT LENGTH AND BRANCH\nFILEB    STH   R0,DSNAME           STORE LENGTH OF DSNAME\n*        MVC   VOLUME(6),JFCB+118  GET VOLUME FROM JFCB\n         MVC   MEMNAME,JFCB+44     JFCBELNM IN IEFJFCBN\n         LA    R1,MEMNAME+7        LAST CHAR OF MEMBER NAME\n         LA    R0,8\nMEMA     CLI   0(R1),C' '\n         BNE   MEMB\n         BCTR  R1,0\n         BCT   R0,MEMA\nMEMB     STH   R0,MEMLEN\n         B     FILESPEC\nFILERR1  LA    R0,MSG14A\n         B     FILERR\nFILERR2  LA    R0,MSG14B\n         B     FILERR\nFILERR3  LA    R0,MSG14C\nFILERR   MVC   MSGWK(L'MSG14),MSG14\n         LA    R15,MSGWK+L'MSG14\n         LA    R14,DSNAME\n         LH    R1,0(,R14)\n         BCTR  R1,0\n         B     *+10\n         MVC   MSGWK+L'MSG14(0),2(R14)\n         EX    R1,*-6\n         LA    R15,1(R1,R15)\n         LR    R14,R0 POINT TO MSG14A, B, OR C\n         MVC   0(L'MSG14A,R15),0(R14)\n         LA    R0,L'MSG14+L'MSG14A+1(,R1)\n         LA    R1,MSGWK\n         BAL   R14,PUTMSG\n         B     QUITD12\nNOFILE   EQU   *\n         TM    6(R6),X'40'         IS IT QUOTED?\n         BO    DEFX                YES - SKIP DEFAULT SERVICE\n         CLI   QUICKW+1,1          QUICK SPECIFIED\n         BE    DEFX                YES, USER ENTERED ALL BUT PREFIX\n         SPACE\n         LA    R15,MYIOPL\n         USING IOPL,R15\n         LA    R14,MYDFPB\n         ST    R14,IOPLIOPB\n         USING DFPB,R14\n         XC    0(20,R14),0(R14)\n         LA    R0,DSNAME\n         ST    R0,DFPBDSN\n         OI    DFPBCODE,X'04'      SEARCH CAT AND PROMPT IF MULTI\n         MVC   DFPBPSCB,CPPLPSCB\n*        MVI   DFPBCNTL,X'20'      PREFIX THE DSNAME\n         DROP  R14                 DFPB\n         SPACE\n         LA    R1,MYIOPL\n         SPACE\n         LR    R1,R15              POINT TO IOPL\n         AIF   (NOT &MVS).SKIP4\n         L     R15,16              CVTPTR\n         TM    736(R15),X'80'      IF HI ORDER BIT NOT ON\n         BNO   EHDEFLNK               THEN DO LINK, NOT CALL\n         L     R15,736(,R15)       CVTEHDEF\n         BALR  R14,R15             CALL IKJEHDEF\n         B     EHDEFEXT            SKIP AROUND LINK\nEHDEFLNK EQU   *\n.SKIP4   ANOP\n         LINK  EP=IKJEHDEF,SF=(E,LINKAREA)\nEHDEFEXT EQU   *\n         SPACE\n         B     DEFCODE(R15)\nDEFCODE  B     DEF00               SUCCESS\n         B     NEXTD12              MSG ALREADY ISSUED\n         B     DEF08               INVALID NAME GT 44\n         B     NEXTD12              MSG ALREADY ISUED\n         B     DEF16               NOT IN CATALOG\n         B     DEF20               NOT IN CATALOG\n         B     DEF24               IMPOSSIBLE\n         B     DEF28               COMMAND SYSTEM ERROR\n         B     DEF32               IMPOSSIBLE\n         B     DEF36               ?\nDEF08    EQU   *\nDEF16    EQU   *\n         B     DEF24\nDEF20    EQU   *\nLOCERR   EQU   *\n         MVC   MSGWK(L'MSG02),MSG02\n         LA    R15,MSGWK+L'MSG02\n         LA    R14,DSNAME\n         LH    R1,0(,R14)\n         BCTR  R1,0\n         B     *+10\n         MVC   MSGWK+L'MSG02(0),2(R14)\n         EX    R1,*-6\n         LA    R15,1(R1,R15)\n         MVC   0(L'MSG02A,R15),MSG02A\n         LA    R0,L'MSG02+L'MSG02A+1(,R1)\n         LA    R1,MSGWK\n         BAL   R14,PUTMSG\n         B     NEXTD12\nDEF24    EQU   *\nDEF28    EQU   *\nDEF32    EQU   *\nDEF36    EQU   *\n         LA    R1,MSG03\n         LA    R0,L'MSG03\n         BAL   R14,PUTMSG\nNEXTD12  MVI   RETCODE+1,12\n         B     NEXTDSN\n         SPACE\nDEF00    EQU   *\nDEFX     EQU   *\n         SPACE\n************************************************************\n*                                                          *\n*        ALLOCATE THE DATASET                              *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R1,MYDAPL\n         USING DAPL,R1\n         MVC   DAPLUPT(4),CPPLUPT\n         MVC   DAPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,DAPLECB\n         MVC   DAPLPSCB(4),CPPLPSCB\n         LA    R15,MYDAPB\n         ST    R15,DAPLDAPB\n         DROP  R1                  DAPL\n         USING DAPB08,R15\n         XC    0(84,R15),0(R15)\n         MVI   DA08CD+1,X'08'\n         LA    R0,DSNAME\n         ST    R0,DA08PDSN\n         MVC   DA08DDN(8),=CL8' '\n         MVC   DA08UNIT,=CL8' '\n         MVC   DA08SER,=CL8' '\n         MVC   DA08MNM,=CL8' '\n         MVC   DA08PSWD,=CL8' '\n         MVI   DA08DSP1,DA08SHR\n         MVI   DA08DPS2,DA08KEEP\n         MVI   DA08DPS3,DA08KEP\n         TM    14(R6),X'80'        MEMBER SPECIFIED?\n         BZ    MEMBX               NO - BRANCH\n         LH    R1,12(,R6)          GET LENGTH OF MEMBER\n         STH   R1,MEMLEN\n         BCTR  R1,0                MINUS 1 FOR EX\n         L     R14,8(,R6)          GET ADDRESS OF MEMBER NAME\n         B     *+10\n         MVC   DA08MNM(0),0(R14)   MOVE MEMBER NAME\n         EX    R1,*-6\n         MVC   MEMNAME,DA08MNM\nMEMBX    EQU   *\n         TM    22(R6),X'80'        PASSWORD SPECIFIED?\n         BZ    PASSX               NO - BRANCH\n         LH    R1,20(,R6)          GET LENGTH OF PSWD\n         BCTR  R1,0                MINUS 1 FOR EX\n         L     R14,16(,R6)         GET ADDRESS OF PSWD\n         B     *+10\n         MVC   DA08PSWD(0),0(R14)  MOVE PSWD\n         EX    R1,*-6\nPASSX    EQU   *\n         LA    R1,MYDAPL\n         SPACE\n         BAL   R14,CALLDAIR\n         LTR   R15,R15\n         BZ    OKDAIR\n         BAL   R14,DAIRFAIL\n         B     NEXTD12\nOKDAIR   EQU   *\n         OI    STATUS,X'40'        TELL CLEANUP TO FREE IT\n         LA    R15,MYDAPB\n         MVC   DDSAVE,DA08DDN\n         TM    DA08DSO,X'40'       IS DSORG SEQUENTIAL?\n         BO    OKDSORG             YES - BRANCH\n         TM    DA08DSO,X'02'       IS DSORG PARTITIONED?\n         BO    OKDSORGP            YES, BRANCH\n*\n*              DSORG IS NEITHER PS NOR PO\n*              ISAM=X'80' DA=X'20' VSAM=X'00' NONE=X'00'\n*\nERRDSORG LA    R1,MSG06\n         LA    R0,L'MSG06\n         BAL   R14,PUTMSG\n         B     QUITD12\nOKDSORGP EQU   *\n         CLC   DA08MNM,=CL8' '     WAS MEMBER SPECIFIED?\n         BNE   OKDSORG             YES - BRANCH\n         LA    R1,MSG07\n         LA    R0,L'MSG07\n         BAL   R14,PUTMSG\n         B     NEXTD12\nOKDSORG  EQU   *\n         DROP  R15                 DAPB08\n         SPACE\n************************************************************\n*                                                          *\n*        CHECK FORMAT-1 DSCB FOR EMPTY DATA SET            *\n*                                                          *\n************************************************************\n         SPACE\n         L     R1,16               CVTPTR\n         L     R1,0(,R1)           TCB WORDS\n         L     R1,4(,R1)           CURRENT TCB\n         L     R1,12(,R1)          TIOT\n         LA    R1,24(,R1)          TOIENTRY\nDDLOOP   CLI   0(R1),0             END OF TIOT\n         BE    QUITDSN             YES, BRANCH (NEVER HAPPENS)\n         CLC   4(8,R1),DDSAVE      DOES DDNAME MATCH\n         BE    DDFOUND\n         SLR   R15,R15\n         IC    R15,0(,R1)\n         LA    R1,0(R15,R1)\n         B     DDLOOP\nDDFOUND  L     R15,16(,R1)         TIOEFSRT-1\n         TM    18(R15),X'20'       DIRECT ACCESS DEVICE?\n         BZ    OBTX                NO, BYPASS OBTAIN\n         MVC   VOLSER,28(R15)      UCBVOLI\nOBTDSCB  LA    R1,OBTAINW\n         MVC   0(OBTAINL,R1),OBTAIN\n         LA    R0,DSNAME+2         DSN FOR OBTAIN\n         ST    R0,4(,R1)\n         LA    R0,VOLSER           VOLUME FOR OBTAIN\n         ST    R0,8(,R1)\n         LA    R0,MYDSCB           ANSWER AREA FOR OBTAIN\n         ST    R0,12(,R1)\n         OBTAIN (1)\n         LTR   R15,R15             WAS OBTAIN SUCCESSFUL\n         BZ    OKDSCB              YES, BRANCH\n         SPACE\n*               OBTAIN HAS FAILED. HOW CAN THAT HAPPEN WHEN\n*               DYNAMIC ALLOCATION WAS SUCCESSFUL? ONE WAY IT\n*               CAN HAPPEN IS IF THE DSNAME IS AN ALIAS ENTRY\n*               IN A VSAM CATALOG.  IF IT IS, A 'LOCATE' WILL\n*               PUT THE TRUE NAME IN THE DSNAME FIELD, SO NOW\n*               WE ISSUE A LOCATE, AND TRY THE OBTAIN AGAIN.\n         SPACE\n         TM    STATUS,X'08'        HAS LOCATE BEEN TRIED ALREADY?\n         BZ    ALIAS               NO, GO TRY IT\nERROBT   LA    R1,MSG09            UNABLE TO OBTAIN DSCB\n         LA    R0,L'MSG09\n         BAL   R14,PUTMSG\n         B     QUITD12\nALIAS    OI    STATUS,X'08'        TRIP THE SWITCH\n         LA    R1,LOCATEW\n         MVC   0(LOCATEL,R1),LOCATE\n         LA    R0,DSNAME+2         DSNAME FOR LOCATE\n         ST    R0,4(,R1)\n         LA    R0,LOCBUF           ANSWER AREA FOR LOCATE\n         ST    R0,12(,R1)\n         LOCATE (1)\n         LTR   15,15               WAS LOCATE SUCCESSFUL?\n         BZ    OBTDSCB             YES, GO OBTAIN AGAIN\n         B     ERROBT              NO, ISSUE MESSAGE\n         SPACE\nOKDSCB   NI    STATUS,255-X'08'    TURN OFF LOCATE SWITCH\n         TM    MYDSCB-44+X'52',X'42' DSORG = PS OR PO\n         BZ    ERRDSORG\n*        TM    MYDSCB-44+X'54',X'C0' RECFM = U\n*        BO    ERRRECFM\n*        CLC   MYDSCB-44+X'62'(3),=X'000000' CHECK DS1LSTAR\n*        BE    DYNEOD              BRANCH IF EMPTY DATA SET\nOBTX     EQU   *\nFILESPEC EQU   *\n         SPACE\n************************************************************\n*                                                          *\n*        SET UP THE DCB                                    *\n*                                                          *\n************************************************************\n         SPACE\n         MVC   DYNDCBW(DYNDCBL),DYNDCB\n         LA    R4,DYNDCBW\n         USING IHADCB,R4\n         MVC   DCBDDNAM(8),DDSAVE\n         SPACE\n         LA    R15,DYNEOD\n         IC    R0,DCBEODAD-1\n         ST    R15,DCBEODAD-1\n         STC   R0,DCBEODAD-1\n         SPACE\n         LA    R15,DYNSYNAD\n         IC    R0,DCBSYNAD-1\n         ST    R15,DCBSYNAD-1\n         STC   R0,DCBSYNAD-1\n         SPACE\n         LA    R15,DYNEXLST\n         IC    R0,DCBEXLSA-1\n         ST    R15,DCBEXLSA-1\n         STC   R0,DCBEXLSA-1\n         LA    R1,DYNDCBEX\n         ST    R1,0(,R15)\n         MVI   0(R15),X'05'\n         LA    R1,DYNABEND\n         ST    R1,4(,R15)\n         MVI   4(R15),128+X'11'    OPEN ABEND EXIT (MVS)\n         SPACE\n         OI    STATUS,X'80'        TELL CLEANUP TO CLOSE DCB\n         MVI   OPEND,X'80'\n         SPACE\n         OPEN  ((R4),INPUT),MF=(E,OPEND)\n         SPACE\n         TM    DCBOFLGS,X'10'\n         BO    OKOPEN\n         LA    R1,MSG08\n         LA    R0,L'MSG08\n         TM    STATUS,X'10'        MEMBER NOT FOUND?\n         BO    DYNOPENM            YES, BRANCH\n         LA    R1,MSG04\n         LA    R0,L'MSG04\nDYNOPENM BAL   R14,PUTMSG\n         B     QUITD12\n         SPACE\nDYNDCBEX BR    R14\n         SPACE\nDYNABEND EQU   *\n         L     R8,0(,R1)           GET COMPLETION CODE\n         N     R8,=A(X'FFF0FF00')\n         CL    R8,=A(X'01301800')  IS IT AN 013-18 ABEND\n         BE    *+10                YES, BRANCH\n         MVI   4(R1),0             ABNORMALLY TERMINATE\n         BR    R14\n         OI    STATUS,X'10'        INDICATE MEMBER NOT FOUND\n         MVI   3(R1),4             IGNORE THE ABEND\n         BR    R14\n         SPACE\nOKOPEN   EQU   *\n         BAL   R14,CKXINIT         SET UP FOR CKSUMR\n         SPACE\nREADLOOP EQU   *\n         MVI   SYNADSW,0           SET SYNAD SWITCH OFF\n         SPACE\n         GET   (R4)\n         SPACE\n         CLI   SYNADSW,0           WAS SYNAD EXIT TAKEN?\n         BE    OKGET               NO - BRANCH\n         LA    R1,SYNADMSG\n         LA    R0,78\n         BAL   R14,PUTMSG\n         B     QUITD12\nOKGET    EQU   *\n         BAL   R14,CKXREC\n         B     READLOOP\n         SPACE\nCKXINIT  LA    R1,CKXARGS\n         LA    R15,CKXLEN\n         ST    R15,4(,R1)          ARG 2 IS WORD CONTAINING LENGTH\n         LA    R15,CKXCTX\n         ST    R15,8(,R1)          ARG 3 IS CONTEXT 3 WORDS\n         XC    0(12,R15),0(R15)    CLEAR THE CONTEXT\n         LA    R15,CKXRES\n         ST    R15,12(,R1)         ARG 4 IS RESULT\n         LA    R15,CKXWRK\n         ST    R15,16(,R1)         ARG 5 IS WORKSPACE 30 WORDS\n         BR    R14\n         SPACE\nCKXREC   ST    R14,CKXSAVE\n         LH    R0,DCBLRECL         GET RECORD LENGTH IF RECFM U OR FB\n         TM    DCBRECFM,X'C0'      IF RECFM U\n         BO    CKXRECX               BRANCH\n         TM    DCBRECFM,X'40'      IF RECFM V\n         BO    CKXRECV               BRANCH\n         TM    DCBRECFM,X'10'      IF RECFM FB\n         BO    CKXRECX               BRANCH\n         LH    R0,DCBBLKSI         GET RECORD LENGTH IF RECFM F\n         B     CKXRECX               BRANCH\nCKXRECV  CLI   RDWKW+1,1           IF RDW WAS SPECIFIED\n         BE    CKXRECX               INCLUDE RDW\n         LH    R0,0(,R1)           GET RECORD LENGTH +4 FROM RDW\n         SH    R0,=H'4'            SUBTRACT 4 TO EXCLUDE RDW\n         LA    R1,4(,R1)           GET RECORD ADDRESS AFTER RDW\nCKXRECX  ST    R0,CKXLEN           STORE RECORD LENGTH\n         LR    R15,R1              RECORD ADDRESS TO R15\n         LA    R1,CKXARGS          SET R1 FOR CALL\n         ST    R15,0(,R1)          STORE RECORD ADDRESS AS FIRST ARG\n         L     R15,=V(CKSUMR)      SET R15 FOR CALL\n         BALR  R14,R15             CALL CKSUMR(RECORD,LEN,CTX,HEX,WORK)\n         L     R14,CKXSAVE\n         BR    R14\n         SPACE\nCKXLAST  ST    R14,CKXSAVE\n         SR    R0,R0               STORE RECORD ADDRESS\n         ST    R0,CKXLEN           STORE RECORD LENGTH\n         LA    R1,CKXARGS\n         L     R15,=V(CKSUMR)\n         BALR  R14,R15             CALL CKSUMR(RECORD,LEN,CTX,HEX,WORK)\n         L     R14,CKXSAVE\n         BR    R14\n         SPACE\nDYNEOD   EQU   *\n         BAL   R14,CKXLAST\n         LA    R1,CKXRES+12        POINT TO 12-BYTE RESULT DIGITS\n         LA    R15,MSGWK\n         LA    R0,12\nSLOOP1   CLI   0(R1),C' '          IF LEADING BLANK\n         BE    SNEXT1               IGNORE IT\n         MVC   0(1,R15),0(R1)      ELSE COPY DIGIT TO MSGWK\n         LA    R15,1(,R15)          POINT TO NEXT DEST BYTE\nSNEXT1   LA    R1,1(,R1)           POINT TO NEXT SRC BYTE\n         BCT   R0,SLOOP1           LOOP UNTIL ALL 12 DONE\n         MVI   0(R15),C' '         SPACE BETWEEN\n         LA    R15,1(,R15)         POINT TO NEXT DEST BYTE\n*                                  R1 POINTS TO 16-BYTE COUNT DIGITS\n         LA    R0,16               NUMBER OF CHARACTERS\nSLOOP2   CLI   0(R1),C' '          IF LEADING BLANK\n         BE    SNEXT2               IGNORE IT\n         MVC   0(1,R15),0(R1)      ELSE COPY DIGIT TO MSGWK\n         LA    R15,1(,R15)          POINT TO NEXT DEST BYTE\nSNEXT2   LA    R1,1(,R1)           POINT TO NEXT SRC BYTE\n         BCT   R0,SLOOP2           LOOP UNTIL ALL 16 DONE\n         MVI   0(R15),C' '         SPACE BETWEEN\n         LA    R15,1(,R15)         POINT TO NEXT DEST BYTE\n         LA    R14,DSNAME\n         LH    R1,0(,R14)\n         BCTR  R1,0\n         B     *+10\n         MVC   0(0,R15),2(R14)     COPY DSNAME\n         EX    R1,*-6              COPY DSNAME\n         LA    R15,1(R1,R15)       POINT PAST LAST BYTE MOVED\n*        TM    14(R6),X'80'        MEMBER SPECIFIED?\n         CLI   MEMLEN+1,0          MEMBER ALLOCATED?\n         BZ    MEMAX               NO - BRANCH\n         MVI   0(R15),C'('\n         LA    R15,1(,R15)\n*        LH    R1,12(,R6)          GET LENGTH OF MEMBER\n         LH    R1,MEMLEN           GET LENGTH OF MEMBER\n         BCTR  R1,0                MINUS 1 FOR EX\n*        L     R14,8(,R6)          GET ADDRESS OF MEMBER NAME\n         LA    R14,MEMNAME\n         B     *+10\n         MVC   0(0,R15),0(R14)     MOVE MEMBER NAME\n         EX    R1,*-6\n         LA    R15,1(R1,R15)       POINT PAST LAST BYTE\n         MVI   0(R15),C')'\n         LA    R15,1(,R15)\nMEMAX    EQU   *\n         LA    R1,MSGWK\n         LR    R0,R15              POINT PAST LAST BYTE\n         SR    R0,R1               COMPUTE MESSAGE LENGTH\n         CLI   LOWKW+1,1           IF 'LOWER' SPECIFIED\n         BNE   LOWX\n         LR    R14,R0\n         BCTR  R14,0                  GET LENGTH MINUS 1\n         B     *+10\n         TR    MSGWK(0),LOWTABLE      TRANSLATE TO LOWER CASE\n         EX    R14,*-6\nLOWX     EQU   *\n         LA    R1,MSGWK\n         BAL   R14,PUTLINE\n         B     QUITDSN\n         SPACE\nQUITD12  LA    R15,12\n         SPACE\nQUITDSN  TM    STATUS,X'80'\n         BZ    NOCLOSE\n         TM    DCBOFLGS,X'10'      IS IT OPEN?\n         BZ    NOCLOSE             NO, BRANCH\n         MVI   CLOSED,X'80'\n         CLOSE ((R4)),MF=(E,CLOSED)\n         NI    STATUS,255-X'80'    CLOSED\n         DROP  R4                  IHADCB\nNOCLOSE  EQU   *\n         TM    STATUS,X'40'        FREE REQUIRED?\n         BZ    NOFREE\n         LA    R1,MYDAPL\n         LA    R15,MYDAPB\n         USING DAPB18,R15\n         XC    0(40,R15),0(R15)\n         MVI   DA18CD+1,X'18'\n         MVC   DA18DDN,DDSAVE\n         MVC   DA18MNM(8),=CL8' '\n         MVC   DA18SCLS(2),=CL8' '\n         BAL   R14,CALLDAIR        UNALLOCATE\n         NI    STATUS,255-X'40'    UNALLOCATED\n         DROP  R15                 DAPB18\nNOFREE   EQU   *\n         B     NEXTDSN\n         SPACE\nDONE     TM    MYPUTLEP,X'80'     WAS PUTLINE LOADED?\n         BO    NODELETE           NO - USED CVTPUTL - BRANCH\n         LA    R0,=CL8'IKJPUTL '\n         DELETE EPLOC=(0)\nNODELETE EQU   *\n         SPACE\n         IKJRLSA MYANS\n         SPACE\n         CLI   RETCODE+1,0         IS RETCODE ZERO?\n         BZ    STACKDX             YES, BRANCH\n         MVC   MYSTPB(STACKDL),STACKD\n         SPACE\n         STACK DELETE=ALL,PARM=MYSTPB,MF=(E,MYIOPL)\n         SPACE\n         TCLEARQ\nSTACKDX  EQU   *\n         SPACE\n         LH    R15,RETCODE\n         B     EXIT\n         SPACE\n************************************************************\n*                                                          *\n*         CALL IKJDAIR SERVICE ROUTINE                     *\n*                                                          *\n************************************************************\n          SPACE\nCALLDAIR ST    R14,DAIRREGS\n         AIF   (NOT &MVS).SKIP6\n         L     R15,16\n         TM    732(R15),X'80'     CVTDAIR\n         BNO   DAIRLINK\n         L     R15,732(,R15)\n         BALR  R14,R15\n         B     DAIRFINI\nDAIRLINK EQU   *\n.SKIP6   ANOP\n         LINK  EP=IKJDAIR,SF=(E,LINKAREA)\nDAIRFINI L     R14,DAIRREGS\n         BR    R14\n         SPACE\n************************************************************\n*                                                          *\n*        DYNAMIC ALLOCATION FAILURE ROUTINE                *\n*                                                          *\n************************************************************\n         SPACE\nDAIRFAIL ST    R14,MYDFREGS\n         AIF   (NOT &MVS).SKIP7\n         LA    R1,MYDFPARM\n         USING DFDSECTD,R1\n         ST    R15,MYDFRC\n         LA    R15,MYDFRC\n         ST    R15,DFRCP\n         LA    R15,MYDAPL\n         ST    R15,DFDAPLP\n         SLR   R15,R15\n         ST    R15,MYJEFF02\n         LA    R15,MYJEFF02\n         ST    R15,DFJEFF02\n         LA    R15,DFDAIR\n         STH   R15,MYDFID\n         LA    R15,MYDFID\n         ST    R15,DFIDP\n         SLR   R15,R15\n         ST    R15,DFCPPLP\n         LINK  EP=IKJEFF18,SF=(E,LINKAREA)\n         L     R15,MYDFRC\n         DROP  R1                  DFDSECTD\n.SKIP7   ANOP\n         AIF   (&MVS).SKIP8\n         LA    R1,MSGDAIR\n         LA    R0,L'MSGDAIR\n         BAL   R14,PUTMSG\n.SKIP8   ANOP\n         L     R14,MYDFREGS\n         BR    R14\n         SPACE\n************************************************************\n*                                                          *\n*        PUTMSG ROUTINE                                    *\n*                                                          *\n************************************************************\n         SPACE\nPUTMSG   STM   R14,R1,PUTLINS\n         XC    MYOLD(8),MYOLD\n         XC    MYSEG1(4),MYSEG1\n         MVC   MYPTPB(12),MODLPTPM\n         LA    R14,1               NO. OF MESSAGE SEGMENTS\n         ST    R14,MYOLD\n         LA    R14,MYSEG1          POINT TO 1ST SEGMENT\n         ST    R14,MYOLD+4\n         LR    R14,R0              LENGTH IN R0\n         LA    R14,4(,R14)         ADD 4\n         LA    R15,MYSEG1+4\n         CLC   0(3,R1),=C'IKJ'     IS DATA PRECEEDED BY MESSAGE ID?\n         BE    *+16                YES - BRANCH\n         LA    R14,1(,R14)         ADD 1 TO LENGTH\n         MVI   0(R15),C' '         INSERT LEADING BLANK\n         LA    R15,1(,R15)         BUMP POINTER\n         STH   R14,MYSEG1\n         LR    R14,R0\n         BCTR  R14,0\n         B     *+10\n         MVC   0(0,R15),0(R1)      MOVE MESSAGE IN\n         EX    R14,*-6\n         L     R15,MYPUTLEP\n         SPACE\n         PUTLINE PARM=MYPTPB,OUTPUT=(MYOLD),ENTRY=(15),MF=(E,MYIOPL)\n         SPACE\n         LM    R14,R1,PUTLINS\n         BR    R14\n         SPACE\n************************************************************\n*                                                          *\n*        PUTLINE ROUTINE                                   *\n*                                                          *\n************************************************************\n         SPACE\nPUTLINE  STM   R14,R1,PUTLINS\n         XC    MYSEG1(4),MYSEG1\n         MVC   MYPTPB(12),MODLPTPB\n         LR    R14,R0              LENGTH IN R0\n         LA    R14,4(,R14)         ADD 4\n         STH   R14,MYSEG1\n         LR    R14,R0\n         BCTR  R14,0\n         B     *+10\n         MVC   MYSEG1+4(0),0(R1)   MOVE TEXT IN\n         EX    R14,*-6\n         LA    R1,MYIOPL\n         L     R15,MYPUTLEP\n         SPACE\n         PUTLINE PARM=MYPTPB,OUTPUT=(MYSEG1,DATA),ENTRY=(15),MF=(E,(1))\n         SPACE\n         LM    R14,R1,PUTLINS\n         BR    R14\n         SPACE 1\n*RRRECFM LA    R1,MSGRECFM\n*        LA    R0,L'MSGRECFM\n*        BAL   R14,PUTMSG\n*        B     QUITD12\n         SPACE\nEXIT     LR    2,15\n         LR    1,13\n         L     R0,@SIZE\n         L     13,4(,13)\n         ST    15,16(,13)\n         FREEMAIN R,A=(1),LV=(0)\n         LR    15,2\n         LM    0,12,20(13)\n         L     14,12(,13)\n         BR    14\n         SPACE\n************************************************************\n*                                                          *\n*        SYNAD EXIT                                        *\n*                                                          *\n************************************************************\n         SPACE\n*        THIS ROUTINE IS ENTERED DURING THE 'GET' MACRO\n*        IF AN I/O ERROR OCCURS.\n         SPACE\nDYNSYNAD EQU   *\n         SYNADAF ACSMETH=QSAM\n         MVC   SYNADMSG(78),50(R1)\n         MVI   SYNADSW,X'FF'\n         SYNADRLS\n         BR    R14\n         SPACE\n************************************************************\n*                                                          *\n*        CONSTANTS                                         *\n*                                                          *\n************************************************************\n         SPACE\nMODLPTPM PUTLINE OUTPUT=(1,TERM,SINGLE,INFOR),                         X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=L\n         SPACE\nMODLPTPB PUTLINE OUTPUT=(1,TERM,SINGLE,DATA),                          X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=L\n         SPACE\n         PRINT NOGEN\n         SPACE\nDYNDCB   DCB   DDNAME=DYNAM,DSORG=PS,MACRF=(GL),                       +\n               EODAD=0,SYNAD=0,EROPT=ACC\nDYNDCBL  EQU   *-DYNDCB\n         SPACE\n         PRINT GEN\n         SPACE\nOBTAIN   CAMLST SEARCH,2,3,4\nOBTAINL  EQU   *-OBTAIN\n         SPACE\nLOCATE   CAMLST NAME,2,,4\nLOCATEL  EQU   *-LOCATE\n         SPACE\nSTACKD   STACK DELETE=ALL,MF=L\nSTACKDL  EQU   *-STACKD\n         SPACE\nMSG01    DC    C'ERROR IN PARSE SERVICE ROUTINE'\nMSG02    DC    C'IKJ58503I DATA SET '\nMSG02A   DC    C' NOT IN CATALOG'\nMSG03    DC    C'ERROR IN DEFAULT SERVICE ROUTINE'\nMSG04    DC    C'UNABLE TO OPEN DATASET'\nMSG05    DC    C'IKJ58509I DATA SET NAME REQUIRED WHEN MEMBER IS SPECIF+\n               IED'\nMSG06    DC    C'ORGANIZATION OF DATA SET MUST BE PARTITIONED OR SEQUEN+\n               TIAL'\nMSG07    DC    C'DATA SET IS PARTITIONED, MEMBER NOT SPECIFIED'\nMSG08    DC    C'SPECIFIED MEMBER NOT FOUND IN DATASET'\nMSG09    DC    C'UNABLE TO OBTAIN DSCB FOR DATA SET'\nMSG14    DC    C'FILENAME '\nMSG14A   DC    C' INVALID, MORE THAN 8 CHARACTERS  '\nMSG14B   DC    C' IS NOT CURRENTLY ALLOCATED       '\nMSG14C   DC    C' NOT ALLOCATED TO A DASD DATA SET '\n*SGRECFM DC    C'RECORD FORMAT U NOT SUPPORTED'\nMSGDAIR  DC    C'UNABLE TO ALLOCATE'\nLOWTABLE DC    0D'0',256AL1(*-LOWTABLE)\n         ORG   LOWTABLE+C'A'\n         DC    X'818283848586878889'\n         ORG   LOWTABLE+C'J'\n         DC    X'919293949596979899'\n         ORG   LOWTABLE+C'S'\n         DC    X'A2A3A4A5A6A7A8A9'\n         ORG\n         LTORG\nPCLADDR  DC    0D'0'               END OF CSECT\n         SPACE\n************************************************************\n*                                                          *\n*        PARSE PARAMETERS                                  *\n*                                                          *\n************************************************************\n         SPACE\n         PRINT NOGEN\nCKSUMPCL IKJPARM\nDSN      IKJPOSIT DSNAME,LIST,PROMPT='DATA SET NAME'\nFILEKW   IKJKEYWD\n         IKJNAME 'FILE'\nQUICKW   IKJKEYWD\n         IKJNAME 'QUICK'\nRDWKW    IKJKEYWD\n         IKJNAME 'RDW'\nLOWKW    IKJKEYWD\n         IKJNAME 'LOWER'\n         IKJENDP\n         PRINT GEN\n         SPACE\n************************************************************\n*                                                          *\n*        DSECTS                                            *\n*                                                          *\n************************************************************\n         SPACE\n@DATA    DSECT\n         DS    18F                 REGISTER SAVEAREA\nLINKAREA DS    2F\nMYPPL    DS    7F\nMYANS    DS    F\nMYECB    DS    F                  USED BY PUTLINE ROUTINE\nMYIOPL   DS    4F                 USED BY PUTLINE ROUTINE\nMYPTPB   DS    3F                 USED BY PUTLINE ROUTINE\nMYOLD    DS    2F                 USED BY PUTLINE ROUTINE\nMYSEG1   DS    2H,CL256           USED BY PUTLINE ROUTINE\nPUTLINS  DS    4F                 USED BY PUTLINE ROUTINE\nMYPUTLEP DS    F                  ADDRESS OF IKJPUTL\nMYSTPB   DS    0F                 5 WORDS USED BY STACK DELETE\nMYDAPL   DS    5F\nMYDAPB   DS    21F\nMYDFPB   DS    5F\nDSNAME   DS    H,CL44\nMEMLEN   DS    H\nMEMNAME  DS    CL8\nVOLSER   DS    CL6\nLOCATEW  DS    0F\nOBTAINW  DS    4F\nLOCBUF   DS    0D                  USES NEXT 265 BYTES\nMYDSCB   DS    CL140               96 BYTES OF DSCB, 5 BYTES CCHHR\nMSGWK    DS    CL128\nSTATUS   DS    X\nRETCODE  DS    H\nMYDFPARM DS    5F  USED BY DAIRFAIL\nMYDFREGS DS    F   USED BY DAIRFAIL\nMYDFRC   DS    F   USED BY DAIRFAIL\nMYJEFF02 DS    F   USED BY DAIRFAIL\nMYDFID   DS    H   USED BY DAIRFAIL\nDOUBLE   DS    D\nEIGHT    DS    CL8\nDDSAVE   DS    CL8\nDAIRREGS DS    F\nOPEND    DS    0F\nCLOSED   DS    F\nDYNEXLST DS    2F\nDYNDCBW  DS    0D,XL(DYNDCBL)\nSYNADSW  DS    F\nSYNADMSG DS    CL78\nDEVDATA  DS    2F\nCKXARGS  DS    5F\nCKXLEN   DS    F\nCKXCTX   DS    3F  (CKSUMR NEEDS 3F)\nCKXRES   DS    10F (CKSUMR NEEDS 10F)\nCKXWRK   DS    30F (CKSUMR NEEDS 30F)\nCKXSAVE  DS    F\nJFCB     DS    0F,CL176\n         DS    0D\n@DATAL   EQU   *-@DATA\n         SPACE\nIHADCB   DSECT\n         DS    32XL1\nDCBBFTEK DS    XL1\nDCBEODAD DS    AL3\nDCBRECFM DS    X\nDCBEXLSA DS    AL3\nDCBDDNAM DS    CL8\nDCBOFLGS DS    X\n         DS    7XL1\n         DS    X\nDCBSYNAD DS    AL3\nDCBBLKSI EQU   IHADCB+62,2\nDCBLRECL EQU   IHADCB+82,2\n         SPACE\n         IKJCPPL\n         SPACE 3\n         IKJPPL\n         SPACE\n         IKJDFPB\n         SPACE 2\n         IKJUPT\n         SPACE 2\n         IKJIOPL\n         SPACE 2\n         IKJDAPL\n         SPACE 2\n         IKJDAP08\n         SPACE 2\n         IKJDAP18\n         SPACE 2\n         IKJPSCB\n         SPACE 2\n         AIF   (NOT &MVS).SKIP12\n         IKJEFFDF DFDSECT=YES\n.SKIP12  ANOP\n         SPACE 2\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CKSUM24$": {"ttr": 2053, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01 \\x16o\\x01 \\x16o! \\x00\\x1e\\x00\\x1e\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-06-14T00:00:00", "modifydate": "2020-06-14T21:20:54", "lines": 30, "newlines": 30, "modlines": 0, "user": "UPDATED"}, "text": "//CBTUSER1 JOB (ACCT),'PGMRNAME',NOTIFY=CBTUSER,\n//         MSGLEVEL=(1,1),MSGCLASS=H\n/* ASSEMBLE AND LINK THE CKSUM TSO COMMAND IN SOURCE MEMBER CKSUM24\n/* USING IFOX00 ASSEMBLER, MVS3.8 MACLIB. CKSUMR24 IS 24-BIT CKSUMR\n/* YOU MIGHT WANT TO CHANGE CKSUM24 TO CKSUM IN THE SYSLMOD DD.\n//ASM     EXEC PGM=IFOX00,\n//             PARM=(LIST,OBJ,NODECK,NOXREF,RLD)\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(TRK,20)\n//SYSUT2   DD  UNIT=SYSDA,SPACE=(TRK,20)\n//SYSUT3   DD  UNIT=SYSDA,SPACE=(TRK,20)\n//SYSLIB   DD  DSN=CBTUSER.MVS38.MACLIB,DISP=SHR\n//SYSGO    DD  DSN=&&OBJ,DISP=(NEW,PASS),SPACE=(TRK,(3,3)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=800)\n//SYSIN    DD  DSN=CBTUSER.LIB.ASM(CKSUM24),DISP=SHR\n//ASM2    EXEC PGM=IFOX00,\n//             PARM=(LIST,OBJ,NODECK,NOXREF,RLD),COND=(0,NE)\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(TRK,20)\n//SYSUT2   DD  UNIT=SYSDA,SPACE=(TRK,20)\n//SYSUT3   DD  UNIT=SYSDA,SPACE=(TRK,20)\n//SYSLIB   DD  DSN=CBTUSER.MVS38.MACLIB,DISP=SHR\n//SYSGO    DD  DSN=&&OBJ,DISP=(MOD,PASS)\n//SYSIN    DD  DSN=CBTUSER.LIB.ASM(CKSUMR24),DISP=SHR\n//LKED   EXEC PGM=HEWLF064,PARM='MAP,NOXREF,RENT,REFR',\n//             COND=(0,NE)\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSNAME=&&OBJ,DISP=(OLD,DELETE)\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(TRK,(10,0))\n//SYSLMOD  DD  DSN=CBTUSER.LIB.LOAD(CKSUM24),DISP=SHR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MD5": {"ttr": 2055, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x131_\\x01\\x14\\x10o\\x11\\x11\\x01\\xf3\\x01\\xf4\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2013-11-11T00:00:00", "modifydate": "2014-04-16T11:11:00", "lines": 499, "newlines": 500, "modlines": 0, "user": "UPDATED"}, "text": "         TITLE 'MD5'\n         SPACE\n*        Subroutine to compute the MD5 sum of a string\n*\n*        This is a modification, for non-REXX callers, of\n*        Leland Lucius' public domain MD5 program for REXX\n*        at http://homerow.net/asm/md5/\n*\n*        CALL MD5(STRING,LENGTH,CONTEXT,RESULT,WORKSPACE)\n*\n*        LENGTH IS A FULLWORD CONTAINING THE LENGTH OF STRING.\n*\n*        CONTEXT IS 22 FULLWORDS WHICH SHOULD BE CLEARED TO BINARY\n*        ZEROES BEFORE THE FIRST CALL, AND LEFT UNCHANGED AFTER THAT,\n*        UNLESS AN ADDITIONAL MD5SUM IS TO BE COMPUTED FOR ANOTHER\n*        STRING, IN WHICH CASE IT SHOULD BE CLEARED AGAIN FOR THE\n*        FIRST CALL FOR THE OTHER STRING.\n*\n*        WORKSPACE IS 44 FULLWORDS AND ITS CONTENTS DO NOT NEED TO\n*        BE SET BY THE CALLER. IT IS USED AS A REGISTER SAVE ARE\n*        AMONG OTHER THINGS.\n*\n*        AT LEAST 2 CALLS WILL BE NEEDED - ONE OR MORE WITH\n*        A STRING AND ONE WITH THE STRING LENGTH SET TO ZERO.\n*        IF LENGTH IS 0, RESULT WILL CONTAIN A 32-BYTE STRING\n*        OF HEXADECIMAL DIGITS WHICH IS THE FINAL RESULT.\n*\n*        IF LENGTH IS NEGATIVE, ONLY ONE CALL IS NEEDED. IT IS THE\n*        EQUIVALENT OF ONE CALL WITH A POSITIVE LENGTH AND\n*        ANOTHER WITH A ZERO LENGTH. THE NEGATIVE LENGTH IS\n*        ZERO MINUS THE STRING LENGTH. THE CONTEXT IN THIS CASE\n*        DOES NOT NEED TO BE CLEARED TO ZEROES.\n*\n* ---------------------------------------------------------------------\n* Swap bytes to convert to little endian\n* ---------------------------------------------------------------------\n         MACRO\n&LAB     SWAP     &PTR,&WORDS\n&LAB     LA       R15,&WORDS/2\n         LA       R14,&PTR\n$&SYSNDX LM       R0,R1,0(R14)\n         STCM     R0,B'0001',0(R14)\n         STCM     R0,B'0010',1(R14)\n         STCM     R0,B'0100',2(R14)\n         STCM     R0,B'1000',3(R14)\n         STCM     R1,B'0001',4(R14)\n         STCM     R1,B'0010',5(R14)\n         STCM     R1,B'0100',6(R14)\n         STCM     R1,B'1000',7(R14)\n         LA       R14,8(R14)\n         BCT      R15,$&SYSNDX\n         MEND\nMD5      CSECT\nMD5      AMODE ANY31\nMD5      RMODE 31\n         USING *,R12\n         B     BEGIN-*(,R15)\n         DC    AL1(7),CL7'MD5'\n*        DC    CL16' &SYSDATE &SYSTIME '\n         DC    CL16' 11/11/13 01:00 '\nWORKSIZ  DC    0F'0',AL1(0),AL3(WORKLEN)\nBEGIN    STM   14,12,12(13)\n         LR    R12,R15\n         LR    R2,R1               POINT TO ARGS PASSED\n         L     R7,16(,R2)          POINT TO WORKSPACE\n*        L     R0,WORKSIZ\n*        GETMAIN R,LV=(0)\n*        LR    R7,R1\n         USING WORKD,R7\n         XC    0(WORKINI,R7),0(R7)\n         ST    R13,4(,R7)          OLD ADDRESS IN NEW SAVE AREA\n         ST    R7,8(,R13)          NEW ADDRESS IN OLD SAVE AREA\n         LR    R13,R7\n         MVC   ARGLIST(16),0(R2)\n         SPACE\n         L     R15,ARGLIST+4       POINT TO LENGTH\n         L     R15,0(,R15)         GET LENGTH\n         LTR   R15,R15             IF LENGTH IS NEGATIVE\n         BM    INCTX                  SET INITIAL CONTEXT\n         L     R1,ARGLIST+8        POINT TO CONTEXT\n         NC    0(88,R1),0(R1)      TEST FOR INITIAL CONTEXT ALL ZEROES\n         BNZ   CPCTX\nINCTX    MVC   M5BUF(16),INITBUF   SET INITIAL VALUE OF M5BUF\n         B     OKCTX\nCPCTX    MVC   M5BUF(88),0(R1)     COPY SAVED CONTEXT\nOKCTX    EQU   *\n         SPACE\n         LM    R8,R9,ARGLIST       GET STRING ADDRESS AND LENGTH ADDR\n         L     R9,0(,R9)           GET LENGTH\n         LTR   R9,R9\n         BZ    FINAL\n         BM    BOTH\n         BAL   R11,HASH\n         B     DONE\nBOTH     LCR   R9,R9\n         BAL   R11,HASH\nFINAL    BAL   R11,TERM\n         SPACE\n         LA    R1,M5BUF            TOHEX SOURCE\n         LA    R0,4                TOHEX SOURCE LENGTH IN WORDS\n         L     R15,ARGLIST+12      POINT TO CALLER'S RESULT AREA\n         BAL   R14,TOHEX\nDONE     L     R1,ARGLIST+8        POINT TO CONTEXT\n         MVC   0(88,R1),M5BUF      SAVE CONTEXT IN CALLER'S ARG\n         B     EXIT0\n         SPACE\nTOHEX    MVC   0(4,R15),0(R1)\n         UNPK  M5IN(9),0(5,R15)\n         MVC   0(8,R15),M5IN\n         TR    0(8,R15),HEXTAB-240\n         LA    R15,8(,R15)\n         LA    R1,4(,R1)\n         BCT   R0,TOHEX\n         BR    R14\n         SPACE\n* =====================================================================\n* MD5Hash\n*\n* Update context to reflect the concatenation of another buffer full\n* of bytes.\n*\n* (Even though they are destroyed in MD5Trans, it is okay to use R2\n* and R3 here since they are reset after each call to MD5Trans.)\n*\n* =====================================================================\n* ---------------------------------------------------------------------\n* Update byte count\n* ---------------------------------------------------------------------\nHASH     L        R1,M5BYTES+(1*4)            RS = Bytes\u00dd 1 \u00a8\n         LR       R14,R1                      T1 = RS\n         ALR      R14,R9                      T1 += Len\n         BC       12,L10                      Overflow? No, branch\n* ---------------------------------------------------------------------\n* Carry from low to high\n* ---------------------------------------------------------------------\n         L        R15,M5BYTES+(0*4)           T2 = Bytes\u00dd 0 \u00a8\n         AL       R15,=F'1'                   T2++\n         ST       R15,M5BYTES+(0*4)           Bytes\u00dd 0 \u00a8 = T2\nL10      ST       R14,M5BYTES+(1*4)           Bytes\u00dd 1 \u00a8 = T1\n* ---------------------------------------------------------------------\n* Space available in ctx->in (at least 1)\n* ---------------------------------------------------------------------\n         LA       R10,64                      Cache\n         N        R1,=A(X'3F')                RS &= 0x3f (mod 64)\n         LR       R3,R10                      T = 64\n         SLR      R3,R1                       T -= RS\n         LR       R1,R10                      RS = 64\n         SLR      R1,R3                       RS -= T\n         LA       R1,M5IN(R1)                 RS = &In\u00dd RS \u00a8\n* ---------------------------------------------------------------------\n* Enough input to fill ctx->in?\n* ---------------------------------------------------------------------\n         CLR      R3,R9                       T > Len?\n         BH       L40                         Yes, not enough to fill\n* ---------------------------------------------------------------------\n* First chunk is an odd size\n* ---------------------------------------------------------------------\n         LR       R14,R3                      T1 = T\n         BCTR     R14,0                       T1-- (for execute)\n         EX       R14,MEMCPY                  do MEMCPY for T bytes\n* ---------------------------------------------------------------------\n* Adjust buffer and len\n* ---------------------------------------------------------------------\n         ALR      R8,R3                       Buf += T\n         SLR      R9,R3                       Len -= T\n* ---------------------------------------------------------------------\n* Convert to little endian\n* ---------------------------------------------------------------------\n         SWAP     M5IN,16                     byteSwap( In, 16 )\n* ---------------------------------------------------------------------\n* Add in the padding bytes\n* ---------------------------------------------------------------------\n         BAL      R6,MD5TRANS                 MD5Trans( Buf, In )\n* ---------------------------------------------------------------------\n* Process data in 64-byte chunks\n* ---------------------------------------------------------------------\nL20      CLR      R9,R10                      Len >= 64?\n         BL       L30                         No, don't have a block\n         MVC      M5IN(64),0(R8)              memcpy( In, Buf, 64 )\n* ---------------------------------------------------------------------\n* Adjust buffer and len\n* ---------------------------------------------------------------------\n         ALR      R8,R10                      Buf += 64\n         SLR      R9,R10                      Len -= 64\n* ---------------------------------------------------------------------\n* Convert to little endian\n* ---------------------------------------------------------------------\n         SWAP     M5IN,16                     byteSwap( In, 16 )\n* ---------------------------------------------------------------------\n* Add in 64 more bytes\n* ---------------------------------------------------------------------\n         BAL      R6,MD5TRANS                 MD5Trans( Buf, In )\n         B        L20                         Continue loop\n* ---------------------------------------------------------------------\n* Handle any remaining bytes of data.\n* ---------------------------------------------------------------------\nL30      LA       R1,M5IN                     RS = &In\u00dd 0 \u00a8\nL40      LTR      R9,R9                       Len == 0?\n         BZ       PUTCTX                      Yes, nothing to do\n         BCTR     R9,0                        Len-- (for execute)\n         EX       R9,MEMCPY                   do MEMCPY for Len bytes\n* ---------------------------------------------------------------------\n* Store the updated context variable\n* ---------------------------------------------------------------------\nPUTCTX   EQU      *\n         BR       R11\n         SPACE\n* =====================================================================\n* MD5Term\n*\n* Final wrapup...pad to 64-byte boundary with the bit pattern:\n*     1 0* (64-bit count of bits processed, MSB-first)\n*\n* (Even though they are destroyed in MD5Trans, it is okay to use R2\n* and R3 here since they are reset after each call to MD5Trans.)\n*\n* =====================================================================\n* ---------------------------------------------------------------------\n* Get number of bytes mod 64\n* ---------------------------------------------------------------------\nTERM     L        R3,M5BYTES+(1*4)            Cnt = Bytes\u00dd 1 \u00a8\n         N        R3,=A(X'3F')                Cnt &= 0x3f\n* ---------------------------------------------------------------------\n* Set ptr to start of padding\n* ---------------------------------------------------------------------\n         LA       R2,M5IN(R3)                 Ptr = &In\u00dd Cnt \u00a8\n* ---------------------------------------------------------------------\n* Set the first byte of padding to 0x80.  There is always room.\n* ---------------------------------------------------------------------\n         MVI      0(R2),X'80'                 *Ptr = x'80'\n         LA       R2,1(R2)                    Ptr++\n* ---------------------------------------------------------------------\n* Bytes of padding needed to make 56 bytes (-8..55)\n* ---------------------------------------------------------------------\n         LA       R1,56-1                     RS = 56 - 1\n         SLR      R1,R3                       RS -= Cnt\n* ---------------------------------------------------------------------\n* Padding forces an extra block\n* ---------------------------------------------------------------------\n         LTR      R3,R1                       ( Cnt = RS ) == 0\n         BZ       L60                         =0, no need to clear\n         BNL      L50                         >0, no extra block\n* ---------------------------------------------------------------------\n* Clear the remaining bytes\n* ---------------------------------------------------------------------\n         LA       R3,(8-1)(R3)                Cnt += 8 (-1 for execute)\n         EX       R3,MEMSET                   do MEMSET for Cnt bytes\n* ---------------------------------------------------------------------\n* Convert to little endian\n* ---------------------------------------------------------------------\n         SWAP     M5IN,16                     byteSwap( In, 16 )\n* ---------------------------------------------------------------------\n* Add in the padding bytes\n* ---------------------------------------------------------------------\n         BAL      R6,MD5TRANS                 MD5Trans( Buf, In )\n         LA       R2,M5IN                     Ptr = &In\u00dd 0 \u00a8\n         LA       R3,(15*4)                   Cnt = 56\n* ---------------------------------------------------------------------\n* Clear padding bytes\n* ---------------------------------------------------------------------\nL50      BCTR     R3,0                        Cnt-- (for execute)\n         EX       R3,MEMSET                   do MEMSET for Cnt bytes\n* ---------------------------------------------------------------------\n* Convert to little endian\n* ---------------------------------------------------------------------\nL60      SWAP     M5IN,14                     byteSwap( In, 14 )\n* ---------------------------------------------------------------------\n* Append length in bits and transform\n* ---------------------------------------------------------------------\n         LM       R14,R15,M5BYTES+(0*4)       Get longlong byte count\n         SLDL     R14,3                       Calc number of bits\n         ST       R15,M5IN+(14*4)             Little...\n         ST       R14,M5IN+(15*4)             ...endian\n         BAL      R6,MD5TRANS                 MD5Trans( Buf, In )\n* ---------------------------------------------------------------------\n* Convert to little endian\n* ---------------------------------------------------------------------\n         SWAP     M5BUF,4                     byteSwap( Buf, 4 )\n* ---------------------------------------------------------------------\n* Final transform is the digest\n* ---------------------------------------------------------------------\n         BR       R11\n* =====================================================================\n* MD5Trans\n*\n* The core of the MD5 algorithm, this alters an existing MD5 hash to\n* reflect the addition of 16 longwords of new data.  MD5Update blocks\n* the data and converts bytes into longwords for this routine.\n*\n* =====================================================================\nRS       EQU      R1\nA        EQU      R2  <--------------------\\\nB        EQU      R3                        \u00a6 Must be sequential since\nC        EQU      R4                        \u00a6 we use LM/STM opcodes\nD        EQU      R5  <--------------------/\nT1       EQU      R14\nT2       EQU      R15\n* ---------------------------------------------------------------------\n*        F1(x, y, z) \\\n*           (z \u00ac (x & (y \u00ac z)))\n* ---------------------------------------------------------------------\n         MACRO\n         F1       &X,&Y,&Z\n.*\n         LR       T1,&Y                       T1 = y\n         XR       T1,&Z                       T1 \u00ac= z\n         LR       T2,&X                       T2 = x\n         NR       T2,T1                       T2 &= T1\n         LR       RS,&Z                       RS = z\n         XR       RS,T2                       RS \u00ac= T2\n.*\n         MEND\n* ---------------------------------------------------------------------\n*        F2(x, y, z) \\\n*            F1(z, x, y)\n* ---------------------------------------------------------------------\n         MACRO\n         F2       &X,&Y,&Z\n.*\n         F1       &Z,&X,&Y                    RS = F1(z,x,y)\n.*\n         MEND\n* ---------------------------------------------------------------------\n*        F3(x, y, z) \\\n*            (x \u00ac y \u00ac z)\n* ---------------------------------------------------------------------\n         MACRO\n         F3       &X,&Y,&Z\n.*\n         LR       RS,&X                       RS = x\n         XR       RS,&Y                       RS \u00ac= y\n         XR       RS,&Z                       RS \u00ac= z\n.*\n         MEND\n* ---------------------------------------------------------------------\n*        F4(x, y, z) \\\n*            (y \u00ac (x \u00a6 ~z))\n* ---------------------------------------------------------------------\n         MACRO\n         F4       &X,&Y,&Z\n.*\n         LR       T1,&Z                       T1 = z\n         X        T1,=A(X'FFFFFFFF')          T1 \u00ac= -1\n         LR       T2,&X                       T2 = x\n         OR       T2,T1                       T2 \u00a6= T2\n         LR       RS,&Y                       RS = y\n         XR       RS,T2                       RS \u00ac= T2\n.*\n         MEND\n* ---------------------------------------------------------------------\n*        MD5STEP(f,w,x,y,z,in,ac,s) \\\n*            (w += f(x,y,z) + in + ac, w = (w<<s \u00a6 w>>(32-s)) + x)\n* ---------------------------------------------------------------------\n         MACRO\n         MD5STEP  &F,&W,&X,&Y,&Z,&IN,&AC,&S\n.*\n         &F       &X,&Y,&Z                    RS = f(x,y,z)\n         AL       RS,M5IN+(&IN*4)             RS += In\u00dd in \u00a8\n         AL       RS,=A(x'&AC')               RS += ac\n         ALR      &W,RS                       w += RS\n         LR       T1,&W                       T1 = w\n         SLL      &W,&S                       w << s\n         SRL      T1,32-&S                    T1 >> (32-s)\n         OR       &W,T1                       w \u00a6= T1\n         ALR      &W,&X                       w += x\n.*\n         MEND\nMD5TRANS LM       A,D,M5BUF\n* ---------------------------------------------------------------------\n* Round 1\n* ---------------------------------------------------------------------\n         MD5STEP  F1,A,B,C,D,00,D76AA478,07\n         MD5STEP  F1,D,A,B,C,01,E8C7B756,12\n         MD5STEP  F1,C,D,A,B,02,242070DB,17\n         MD5STEP  F1,B,C,D,A,03,C1BDCEEE,22\n         MD5STEP  F1,A,B,C,D,04,F57C0FAF,07\n         MD5STEP  F1,D,A,B,C,05,4787C62A,12\n         MD5STEP  F1,C,D,A,B,06,A8304613,17\n         MD5STEP  F1,B,C,D,A,07,FD469501,22\n         MD5STEP  F1,A,B,C,D,08,698098D8,07\n         MD5STEP  F1,D,A,B,C,09,8B44F7AF,12\n         MD5STEP  F1,C,D,A,B,10,FFFF5BB1,17\n         MD5STEP  F1,B,C,D,A,11,895CD7BE,22\n         MD5STEP  F1,A,B,C,D,12,6B901122,07\n         MD5STEP  F1,D,A,B,C,13,FD987193,12\n         MD5STEP  F1,C,D,A,B,14,A679438E,17\n         MD5STEP  F1,B,C,D,A,15,49B40821,22\n* ---------------------------------------------------------------------\n* Round 2\n* ---------------------------------------------------------------------\n         MD5STEP  F2,A,B,C,D,01,F61E2562,05\n         MD5STEP  F2,D,A,B,C,06,C040B340,09\n         MD5STEP  F2,C,D,A,B,11,265E5A51,14\n         MD5STEP  F2,B,C,D,A,00,E9B6C7AA,20\n         MD5STEP  F2,A,B,C,D,05,D62F105D,05\n         MD5STEP  F2,D,A,B,C,10,02441453,09\n         MD5STEP  F2,C,D,A,B,15,D8A1E681,14\n         MD5STEP  F2,B,C,D,A,04,E7D3FBC8,20\n         MD5STEP  F2,A,B,C,D,09,21E1CDE6,05\n         MD5STEP  F2,D,A,B,C,14,C33707D6,09\n         MD5STEP  F2,C,D,A,B,03,F4D50D87,14\n         MD5STEP  F2,B,C,D,A,08,455A14ED,20\n         MD5STEP  F2,A,B,C,D,13,A9E3E905,05\n         MD5STEP  F2,D,A,B,C,02,FCEFA3F8,09\n         MD5STEP  F2,C,D,A,B,07,676F02D9,14\n         MD5STEP  F2,B,C,D,A,12,8D2A4C8A,20\n* ---------------------------------------------------------------------\n* Round 3\n* ---------------------------------------------------------------------\n         MD5STEP  F3,A,B,C,D,05,FFFA3942,04\n         MD5STEP  F3,D,A,B,C,08,8771F681,11\n         MD5STEP  F3,C,D,A,B,11,6D9D6122,16\n         MD5STEP  F3,B,C,D,A,14,FDE5380C,23\n         MD5STEP  F3,A,B,C,D,01,A4BEEA44,04\n         MD5STEP  F3,D,A,B,C,04,4BDECFA9,11\n         MD5STEP  F3,C,D,A,B,07,F6BB4B60,16\n         MD5STEP  F3,B,C,D,A,10,BEBFBC70,23\n         MD5STEP  F3,A,B,C,D,13,289B7EC6,04\n         MD5STEP  F3,D,A,B,C,00,EAA127FA,11\n         MD5STEP  F3,C,D,A,B,03,D4EF3085,16\n         MD5STEP  F3,B,C,D,A,06,04881D05,23\n         MD5STEP  F3,A,B,C,D,09,D9D4D039,04\n         MD5STEP  F3,D,A,B,C,12,E6DB99E5,11\n         MD5STEP  F3,C,D,A,B,15,1FA27CF8,16\n         MD5STEP  F3,B,C,D,A,02,C4AC5665,23\n* ---------------------------------------------------------------------\n* Round 4\n* ---------------------------------------------------------------------\n         MD5STEP  F4,A,B,C,D,00,F4292244,06\n         MD5STEP  F4,D,A,B,C,07,432AFF97,10\n         MD5STEP  F4,C,D,A,B,14,AB9423A7,15\n         MD5STEP  F4,B,C,D,A,05,FC93A039,21\n         MD5STEP  F4,A,B,C,D,12,655B59C3,06\n         MD5STEP  F4,D,A,B,C,03,8F0CCC92,10\n         MD5STEP  F4,C,D,A,B,10,FFEFF47D,15\n         MD5STEP  F4,B,C,D,A,01,85845DD1,21\n         MD5STEP  F4,A,B,C,D,08,6FA87E4F,06\n         MD5STEP  F4,D,A,B,C,15,FE2CE6E0,10\n         MD5STEP  F4,C,D,A,B,06,A3014314,15\n         MD5STEP  F4,B,C,D,A,13,4E0811A1,21\n         MD5STEP  F4,A,B,C,D,04,F7537E82,06\n         MD5STEP  F4,D,A,B,C,11,BD3AF235,10\n         MD5STEP  F4,C,D,A,B,02,2AD7D2BB,15\n         MD5STEP  F4,B,C,D,A,09,EB86D391,21\n* ---------------------------------------------------------------------\n* Add back into state and return\n* ---------------------------------------------------------------------\n         AL       A,M5BUF+(0*4)\n         AL       B,M5BUF+(1*4)\n         AL       C,M5BUF+(2*4)\n         AL       D,M5BUF+(3*4)\n         STM      A,D,M5BUF\n         BR       R6\n         SPACE\nMEMCPY   MVC      0(0,R1),0(R8)               memcpy( RS, Buf, Len )\nMEMSET   XC       0(0,R2),0(R2)               Ptr\u00dd...\u00a8 \u00ac= Ptr\u00dd...\u00a8\n         SPACE\nEXIT0    SR    R2,R2              RETURN CODE 0\n*        LR    R1,R13             POINT TO ADDRESS TO FREEMAIN\n*        L     R0,WORKSIZ         LENGTH TO FREEMAIN\n         L     R13,4(,R13)        RESTORE ORIGINAL R13\n*        FREEMAIN R,A=(1),LV=(0)\n         DROP  R7\n         LR    R15,R2\n         LM    0,12,20(R13)\n         L     R14,12(,R13)\n         BR    R14\n         SPACE\n         LTORG\n         DC    0D'0'\nINITBUF  DC    X'67452301,EFCDAB89,98BADCFE,10325476'\nHEXTAB   DC    C'0123456789ABCDEF'\nWORKD    DSECT\n         DS    18F\nARGLIST  DS    4F\nM5BUF    DS    4F\nM5BYTES  DS    2F\nM5IN     DS    16F\nWORKINI  EQU   *-WORKD\n         DS    0D\nWORKLEN  EQU   *-WORKD\n         SPACE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MD5A": {"ttr": 2309, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x131_\\x01\\x14\\x10o\\x11\\x11\\x02\\x06\\x02\\x07\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2013-11-11T00:00:00", "modifydate": "2014-04-16T11:11:00", "lines": 518, "newlines": 519, "modlines": 0, "user": "UPDATED"}, "text": "         TITLE 'MD5 FOR IFOX00'\n         SPACE\n*        Assembles to exactly the same code as MD5, but this one\n*        does not require an assembler more advanced than IFOX00.\n*        Some macros and equates were moved, and amode/rmode removed.\n*        The MD5STEP macro was modified.\n*\n*        Subroutine to compute the MD5 sum of a string\n*\n*        This is a modification, for non-REXX callers, of\n*        Leland Lucius' public domain MD5 program for REXX\n*        at http://homerow.net/asm/md5/\n*\n*        CALL MD5(STRING,LENGTH,CONTEXT,RESULT,WORKSPACE)\n*\n*        LENGTH IS A FULLWORD CONTAINING THE LENGTH OF STRING.\n*\n*        CONTEXT IS 22 FULLWORDS WHICH SHOULD BE CLEARED TO BINARY\n*        ZEROES BEFORE THE FIRST CALL, AND LEFT UNCHANGED AFTER THAT,\n*        UNLESS AN ADDITIONAL MD5SUM IS TO BE COMPUTED FOR ANOTHER\n*        STRING, IN WHICH CASE IT SHOULD BE CLEARED AGAIN FOR THE\n*        FIRST CALL FOR THE OTHER STRING.\n*\n*        WORKSPACE IS 44 FULLWORDS AND ITS CONTENTS DO NOT NEED TO\n*        BE SET BY THE CALLER. IT IS USED AS A REGISTER SAVE ARE\n*        AMONG OTHER THINGS.\n*\n*        AT LEAST 2 CALLS WILL BE NEEDED - ONE OR MORE WITH\n*        A STRING AND ONE WITH THE STRING LENGTH SET TO ZERO.\n*        IF LENGTH IS 0, RESULT WILL CONTAIN A 32-BYTE STRING\n*        OF HEXADECIMAL DIGITS WHICH IS THE FINAL RESULT.\n*\n*        IF LENGTH IS NEGATIVE, ONLY ONE CALL IS NEEDED. IT IS THE\n*        EQUIVALENT OF ONE CALL WITH A POSITIVE LENGTH AND\n*        ANOTHER WITH A ZERO LENGTH. THE NEGATIVE LENGTH IS\n*        ZERO MINUS THE STRING LENGTH. THE CONTEXT IN THIS CASE\n*        DOES NOT NEED TO BE CLEARED TO ZEROES.\n*\n* ---------------------------------------------------------------------\n* Swap bytes to convert to little endian\n* ---------------------------------------------------------------------\n         MACRO\n&LAB     SWAP     &PTR,&WORDS\n&LAB     LA       R15,&WORDS/2\n         LA       R14,&PTR\n$&SYSNDX LM       R0,R1,0(R14)\n         STCM     R0,B'0001',0(R14)\n         STCM     R0,B'0010',1(R14)\n         STCM     R0,B'0100',2(R14)\n         STCM     R0,B'1000',3(R14)\n         STCM     R1,B'0001',4(R14)\n         STCM     R1,B'0010',5(R14)\n         STCM     R1,B'0100',6(R14)\n         STCM     R1,B'1000',7(R14)\n         LA       R14,8(R14)\n         BCT      R15,$&SYSNDX\n         MEND\n* --- THE FOLLOWING MACROS WERE FURTHER DOWN IN THE CODE IN THE\n* --- VERSION WRITTEN FOR ASMA90, AND ARE MOVED HERE FOR IFOX00.\n* ---------------------------------------------------------------------\n*        F1(x, y, z) \\\n*           (z \u00ac (x & (y \u00ac z)))\n* ---------------------------------------------------------------------\n         MACRO\n         F1       &X,&Y,&Z\n.*\n         LR       T1,&Y                       T1 = y\n         XR       T1,&Z                       T1 \u00ac= z\n         LR       T2,&X                       T2 = x\n         NR       T2,T1                       T2 &= T1\n         LR       RS,&Z                       RS = z\n         XR       RS,T2                       RS \u00ac= T2\n.*\n         MEND\n* ---------------------------------------------------------------------\n*        F2(x, y, z) \\\n*            F1(z, x, y)\n* ---------------------------------------------------------------------\n         MACRO\n         F2       &X,&Y,&Z\n.*\n         F1       &Z,&X,&Y                    RS = F1(z,x,y)\n.*\n         MEND\n* ---------------------------------------------------------------------\n*        F3(x, y, z) \\\n*            (x \u00ac y \u00ac z)\n* ---------------------------------------------------------------------\n         MACRO\n         F3       &X,&Y,&Z\n.*\n         LR       RS,&X                       RS = x\n         XR       RS,&Y                       RS \u00ac= y\n         XR       RS,&Z                       RS \u00ac= z\n.*\n         MEND\n* ---------------------------------------------------------------------\n*        F4(x, y, z) \\\n*            (y \u00ac (x \u00a6 ~z))\n* ---------------------------------------------------------------------\n         MACRO\n         F4       &X,&Y,&Z\n.*\n         LR       T1,&Z                       T1 = z\n         X        T1,=A(X'FFFFFFFF')          T1 \u00ac= -1\n         LR       T2,&X                       T2 = x\n         OR       T2,T1                       T2 \u00a6= T2\n         LR       RS,&Y                       RS = y\n         XR       RS,T2                       RS \u00ac= T2\n.*\n         MEND\n* ---------------------------------------------------------------------\n*        MD5STEP(f,w,x,y,z,in,ac,s) \\\n*            (w += f(x,y,z) + in + ac, w = (w<<s \u00a6 w>>(32-s)) + x)\n* ---------------------------------------------------------------------\n         MACRO\n         MD5STEP  &F,&W,&X,&Y,&Z,&IN,&AC,&S\n.*\n.* IFOX00 DOESN'T ALLOW THE NEXT LINE. IT WAS REPLACED BY .L1 THRU .L5\n.*       &F       &X,&Y,&Z                    RS = f(x,y,z)\n.L1      AIF      ('&F' NE 'F1').L2\n         F1       &X,&Y,&Z                    RS = f(x,y,z)\n         AGO      .L5\n.L2      AIF      ('&F' NE 'F2').L3\n         F2       &X,&Y,&Z                    RS = f(x,y,z)\n         AGO      .L5\n.L3      AIF      ('&F' NE 'F3').L4\n         F3       &X,&Y,&Z                    RS = f(x,y,z)\n         AGO      .L5\n.L4      F4       &X,&Y,&Z                    RS = f(x,y,z)\n.L5      ANOP\n         AL       RS,M5IN+(&IN*4)             RS += In\u00dd in \u00a8\n         AL       RS,=A(X'&AC')               RS += ac\n         ALR      &W,RS                       w += RS\n         LR       T1,&W                       T1 = w\n         SLL      &W,&S                       w << s\n         SRL      T1,32-&S                    T1 >> (32-s)\n         OR       &W,T1                       w \u00a6= T1\n         ALR      &W,&X                       w += x\n.*\n         MEND\nMD5      CSECT\n         USING *,R12\n         B     BEGIN-*(,R15)\n         DC    AL1(7),CL7'MD5'\n*        DC    CL16' &SYSDATE &SYSTIME '\n         DC    CL16' 11/11/13 01:00 '\nWORKSIZ  DC    0F'0',AL1(0),AL3(WORKLEN)\nBEGIN    STM   14,12,12(13)\n         LR    R12,R15\n         LR    R2,R1               POINT TO ARGS PASSED\n         L     R7,16(,R2)          POINT TO WORKSPACE\n*        L     R0,WORKSIZ\n*        GETMAIN R,LV=(0)\n*        LR    R7,R1\n         USING WORKD,R7\n         XC    0(WORKINI,R7),0(R7)\n         ST    R13,4(,R7)          OLD ADDRESS IN NEW SAVE AREA\n         ST    R7,8(,R13)          NEW ADDRESS IN OLD SAVE AREA\n         LR    R13,R7\n         MVC   ARGLIST(16),0(R2)\n         SPACE\n         L     R15,ARGLIST+4       POINT TO LENGTH\n         L     R15,0(,R15)         GET LENGTH\n         LTR   R15,R15             IF LENGTH IS NEGATIVE\n         BM    INCTX                  SET INITIAL CONTEXT\n         L     R1,ARGLIST+8        POINT TO CONTEXT\n         NC    0(88,R1),0(R1)      TEST FOR INITIAL CONTEXT ALL ZEROES\n         BNZ   CPCTX\nINCTX    MVC   M5BUF(16),INITBUF   SET INITIAL VALUE OF M5BUF\n         B     OKCTX\nCPCTX    MVC   M5BUF(88),0(R1)     COPY SAVED CONTEXT\nOKCTX    EQU   *\n         SPACE\n         LM    R8,R9,ARGLIST       GET STRING ADDRESS AND LENGTH ADDR\n         L     R9,0(,R9)           GET LENGTH\n         LTR   R9,R9\n         BZ    FINAL\n         BM    BOTH\n         BAL   R11,HASH\n         B     DONE\nBOTH     LCR   R9,R9\n         BAL   R11,HASH\nFINAL    BAL   R11,TERM\n         SPACE\n         LA    R1,M5BUF            TOHEX SOURCE\n         LA    R0,4                TOHEX SOURCE LENGTH IN WORDS\n         L     R15,ARGLIST+12      POINT TO CALLER'S RESULT AREA\n         BAL   R14,TOHEX\nDONE     L     R1,ARGLIST+8        POINT TO CONTEXT\n         MVC   0(88,R1),M5BUF      SAVE CONTEXT IN CALLER'S ARG\n         B     EXIT0\n         SPACE\nTOHEX    MVC   0(4,R15),0(R1)\n         UNPK  M5IN(9),0(5,R15)\n         MVC   0(8,R15),M5IN\n         TR    0(8,R15),HEXTAB-240\n         LA    R15,8(,R15)\n         LA    R1,4(,R1)\n         BCT   R0,TOHEX\n         BR    R14\n         SPACE\n* =====================================================================\n* MD5Hash\n*\n* Update context to reflect the concatenation of another buffer full\n* of bytes.\n*\n* (Even though they are destroyed in MD5Trans, it is okay to use R2\n* and R3 here since they are reset after each call to MD5Trans.)\n*\n* =====================================================================\n* ---------------------------------------------------------------------\n* Update byte count\n* ---------------------------------------------------------------------\nHASH     L        R1,M5BYTES+(1*4)            RS = Bytes\u00dd 1 \u00a8\n         LR       R14,R1                      T1 = RS\n         ALR      R14,R9                      T1 += Len\n         BC       12,L10                      Overflow? No, branch\n* ---------------------------------------------------------------------\n* Carry from low to high\n* ---------------------------------------------------------------------\n         L        R15,M5BYTES+(0*4)           T2 = Bytes\u00dd 0 \u00a8\n         AL       R15,=F'1'                   T2++\n         ST       R15,M5BYTES+(0*4)           Bytes\u00dd 0 \u00a8 = T2\nL10      ST       R14,M5BYTES+(1*4)           Bytes\u00dd 1 \u00a8 = T1\n* ---------------------------------------------------------------------\n* Space available in ctx->in (at least 1)\n* ---------------------------------------------------------------------\n         LA       R10,64                      Cache\n         N        R1,=A(X'3F')                RS &= 0x3f (mod 64)\n         LR       R3,R10                      T = 64\n         SLR      R3,R1                       T -= RS\n         LR       R1,R10                      RS = 64\n         SLR      R1,R3                       RS -= T\n         LA       R1,M5IN(R1)                 RS = &In\u00dd RS \u00a8\n* ---------------------------------------------------------------------\n* Enough input to fill ctx->in?\n* ---------------------------------------------------------------------\n         CLR      R3,R9                       T > Len?\n         BH       L40                         Yes, not enough to fill\n* ---------------------------------------------------------------------\n* First chunk is an odd size\n* ---------------------------------------------------------------------\n         LR       R14,R3                      T1 = T\n         BCTR     R14,0                       T1-- (for execute)\n         EX       R14,MEMCPY                  do MEMCPY for T bytes\n* ---------------------------------------------------------------------\n* Adjust buffer and len\n* ---------------------------------------------------------------------\n         ALR      R8,R3                       Buf += T\n         SLR      R9,R3                       Len -= T\n* ---------------------------------------------------------------------\n* Convert to little endian\n* ---------------------------------------------------------------------\n         SWAP     M5IN,16                     byteSwap( In, 16 )\n* ---------------------------------------------------------------------\n* Add in the padding bytes\n* ---------------------------------------------------------------------\n         BAL      R6,MD5TRANS                 MD5Trans( Buf, In )\n* ---------------------------------------------------------------------\n* Process data in 64-byte chunks\n* ---------------------------------------------------------------------\nL20      CLR      R9,R10                      Len >= 64?\n         BL       L30                         No, don't have a block\n         MVC      M5IN(64),0(R8)              memcpy( In, Buf, 64 )\n* ---------------------------------------------------------------------\n* Adjust buffer and len\n* ---------------------------------------------------------------------\n         ALR      R8,R10                      Buf += 64\n         SLR      R9,R10                      Len -= 64\n* ---------------------------------------------------------------------\n* Convert to little endian\n* ---------------------------------------------------------------------\n         SWAP     M5IN,16                     byteSwap( In, 16 )\n* ---------------------------------------------------------------------\n* Add in 64 more bytes\n* ---------------------------------------------------------------------\n         BAL      R6,MD5TRANS                 MD5Trans( Buf, In )\n         B        L20                         Continue loop\n* ---------------------------------------------------------------------\n* Handle any remaining bytes of data.\n* ---------------------------------------------------------------------\nL30      LA       R1,M5IN                     RS = &In\u00dd 0 \u00a8\nL40      LTR      R9,R9                       Len == 0?\n         BZ       PUTCTX                      Yes, nothing to do\n         BCTR     R9,0                        Len-- (for execute)\n         EX       R9,MEMCPY                   do MEMCPY for Len bytes\n* ---------------------------------------------------------------------\n* Store the updated context variable\n* ---------------------------------------------------------------------\nPUTCTX   EQU      *\n         BR       R11\n         SPACE\n* =====================================================================\n* MD5Term\n*\n* Final wrapup...pad to 64-byte boundary with the bit pattern:\n*     1 0* (64-bit count of bits processed, MSB-first)\n*\n* (Even though they are destroyed in MD5Trans, it is okay to use R2\n* and R3 here since they are reset after each call to MD5Trans.)\n*\n* =====================================================================\n* ---------------------------------------------------------------------\n* Get number of bytes mod 64\n* ---------------------------------------------------------------------\nTERM     L        R3,M5BYTES+(1*4)            Cnt = Bytes\u00dd 1 \u00a8\n         N        R3,=A(X'3F')                Cnt &= 0x3f\n* ---------------------------------------------------------------------\n* Set ptr to start of padding\n* ---------------------------------------------------------------------\n         LA       R2,M5IN(R3)                 Ptr = &In\u00dd Cnt \u00a8\n* ---------------------------------------------------------------------\n* Set the first byte of padding to 0x80.  There is always room.\n* ---------------------------------------------------------------------\n         MVI      0(R2),X'80'                 *Ptr = x'80'\n         LA       R2,1(R2)                    Ptr++\n* ---------------------------------------------------------------------\n* Bytes of padding needed to make 56 bytes (-8..55)\n* ---------------------------------------------------------------------\n         LA       R1,56-1                     RS = 56 - 1\n         SLR      R1,R3                       RS -= Cnt\n* ---------------------------------------------------------------------\n* Padding forces an extra block\n* ---------------------------------------------------------------------\n         LTR      R3,R1                       ( Cnt = RS ) == 0\n         BZ       L60                         =0, no need to clear\n         BNL      L50                         >0, no extra block\n* ---------------------------------------------------------------------\n* Clear the remaining bytes\n* ---------------------------------------------------------------------\n         LA       R3,(8-1)(R3)                Cnt += 8 (-1 for execute)\n         EX       R3,MEMSET                   do MEMSET for Cnt bytes\n* ---------------------------------------------------------------------\n* Convert to little endian\n* ---------------------------------------------------------------------\n         SWAP     M5IN,16                     byteSwap( In, 16 )\n* ---------------------------------------------------------------------\n* Add in the padding bytes\n* ---------------------------------------------------------------------\n         BAL      R6,MD5TRANS                 MD5Trans( Buf, In )\n         LA       R2,M5IN                     Ptr = &In\u00dd 0 \u00a8\n         LA       R3,(15*4)                   Cnt = 56\n* ---------------------------------------------------------------------\n* Clear padding bytes\n* ---------------------------------------------------------------------\nL50      BCTR     R3,0                        Cnt-- (for execute)\n         EX       R3,MEMSET                   do MEMSET for Cnt bytes\n* ---------------------------------------------------------------------\n* Convert to little endian\n* ---------------------------------------------------------------------\nL60      SWAP     M5IN,14                     byteSwap( In, 14 )\n* ---------------------------------------------------------------------\n* Append length in bits and transform\n* ---------------------------------------------------------------------\n         LM       R14,R15,M5BYTES+(0*4)       Get longlong byte count\n         SLDL     R14,3                       Calc number of bits\n         ST       R15,M5IN+(14*4)             Little...\n         ST       R14,M5IN+(15*4)             ...endian\n         BAL      R6,MD5TRANS                 MD5Trans( Buf, In )\n* ---------------------------------------------------------------------\n* Convert to little endian\n* ---------------------------------------------------------------------\n         SWAP     M5BUF,4                     byteSwap( Buf, 4 )\n* ---------------------------------------------------------------------\n* Final transform is the digest\n* ---------------------------------------------------------------------\n         BR       R11\n* =====================================================================\n* MD5Trans\n*\n* The core of the MD5 algorithm, this alters an existing MD5 hash to\n* reflect the addition of 16 longwords of new data.  MD5Update blocks\n* the data and converts bytes into longwords for this routine.\n*\n* =====================================================================\n* --- REGISTER EQUATES FOR RS,A,B,C,D,T1,T2 MOVED FOR IFOX00 ASSEMBLER\n* --- MACRO DEFINITIONS MOVED FOR IFOX00 ASSEMBLER\nMD5TRANS LM       A,D,M5BUF\n* ---------------------------------------------------------------------\n* Round 1\n* ---------------------------------------------------------------------\n         MD5STEP  F1,A,B,C,D,00,D76AA478,07\n         MD5STEP  F1,D,A,B,C,01,E8C7B756,12\n         MD5STEP  F1,C,D,A,B,02,242070DB,17\n         MD5STEP  F1,B,C,D,A,03,C1BDCEEE,22\n         MD5STEP  F1,A,B,C,D,04,F57C0FAF,07\n         MD5STEP  F1,D,A,B,C,05,4787C62A,12\n         MD5STEP  F1,C,D,A,B,06,A8304613,17\n         MD5STEP  F1,B,C,D,A,07,FD469501,22\n         MD5STEP  F1,A,B,C,D,08,698098D8,07\n         MD5STEP  F1,D,A,B,C,09,8B44F7AF,12\n         MD5STEP  F1,C,D,A,B,10,FFFF5BB1,17\n         MD5STEP  F1,B,C,D,A,11,895CD7BE,22\n         MD5STEP  F1,A,B,C,D,12,6B901122,07\n         MD5STEP  F1,D,A,B,C,13,FD987193,12\n         MD5STEP  F1,C,D,A,B,14,A679438E,17\n         MD5STEP  F1,B,C,D,A,15,49B40821,22\n* ---------------------------------------------------------------------\n* Round 2\n* ---------------------------------------------------------------------\n         MD5STEP  F2,A,B,C,D,01,F61E2562,05\n         MD5STEP  F2,D,A,B,C,06,C040B340,09\n         MD5STEP  F2,C,D,A,B,11,265E5A51,14\n         MD5STEP  F2,B,C,D,A,00,E9B6C7AA,20\n         MD5STEP  F2,A,B,C,D,05,D62F105D,05\n         MD5STEP  F2,D,A,B,C,10,02441453,09\n         MD5STEP  F2,C,D,A,B,15,D8A1E681,14\n         MD5STEP  F2,B,C,D,A,04,E7D3FBC8,20\n         MD5STEP  F2,A,B,C,D,09,21E1CDE6,05\n         MD5STEP  F2,D,A,B,C,14,C33707D6,09\n         MD5STEP  F2,C,D,A,B,03,F4D50D87,14\n         MD5STEP  F2,B,C,D,A,08,455A14ED,20\n         MD5STEP  F2,A,B,C,D,13,A9E3E905,05\n         MD5STEP  F2,D,A,B,C,02,FCEFA3F8,09\n         MD5STEP  F2,C,D,A,B,07,676F02D9,14\n         MD5STEP  F2,B,C,D,A,12,8D2A4C8A,20\n* ---------------------------------------------------------------------\n* Round 3\n* ---------------------------------------------------------------------\n         MD5STEP  F3,A,B,C,D,05,FFFA3942,04\n         MD5STEP  F3,D,A,B,C,08,8771F681,11\n         MD5STEP  F3,C,D,A,B,11,6D9D6122,16\n         MD5STEP  F3,B,C,D,A,14,FDE5380C,23\n         MD5STEP  F3,A,B,C,D,01,A4BEEA44,04\n         MD5STEP  F3,D,A,B,C,04,4BDECFA9,11\n         MD5STEP  F3,C,D,A,B,07,F6BB4B60,16\n         MD5STEP  F3,B,C,D,A,10,BEBFBC70,23\n         MD5STEP  F3,A,B,C,D,13,289B7EC6,04\n         MD5STEP  F3,D,A,B,C,00,EAA127FA,11\n         MD5STEP  F3,C,D,A,B,03,D4EF3085,16\n         MD5STEP  F3,B,C,D,A,06,04881D05,23\n         MD5STEP  F3,A,B,C,D,09,D9D4D039,04\n         MD5STEP  F3,D,A,B,C,12,E6DB99E5,11\n         MD5STEP  F3,C,D,A,B,15,1FA27CF8,16\n         MD5STEP  F3,B,C,D,A,02,C4AC5665,23\n* ---------------------------------------------------------------------\n* Round 4\n* ---------------------------------------------------------------------\n         MD5STEP  F4,A,B,C,D,00,F4292244,06\n         MD5STEP  F4,D,A,B,C,07,432AFF97,10\n         MD5STEP  F4,C,D,A,B,14,AB9423A7,15\n         MD5STEP  F4,B,C,D,A,05,FC93A039,21\n         MD5STEP  F4,A,B,C,D,12,655B59C3,06\n         MD5STEP  F4,D,A,B,C,03,8F0CCC92,10\n         MD5STEP  F4,C,D,A,B,10,FFEFF47D,15\n         MD5STEP  F4,B,C,D,A,01,85845DD1,21\n         MD5STEP  F4,A,B,C,D,08,6FA87E4F,06\n         MD5STEP  F4,D,A,B,C,15,FE2CE6E0,10\n         MD5STEP  F4,C,D,A,B,06,A3014314,15\n         MD5STEP  F4,B,C,D,A,13,4E0811A1,21\n         MD5STEP  F4,A,B,C,D,04,F7537E82,06\n         MD5STEP  F4,D,A,B,C,11,BD3AF235,10\n         MD5STEP  F4,C,D,A,B,02,2AD7D2BB,15\n         MD5STEP  F4,B,C,D,A,09,EB86D391,21\n* ---------------------------------------------------------------------\n* Add back into state and return\n* ---------------------------------------------------------------------\n         AL       A,M5BUF+(0*4)\n         AL       B,M5BUF+(1*4)\n         AL       C,M5BUF+(2*4)\n         AL       D,M5BUF+(3*4)\n         STM      A,D,M5BUF\n         BR       R6\n         SPACE\nMEMCPY   MVC      0(0,R1),0(R8)               memcpy( RS, Buf, Len )\nMEMSET   XC       0(0,R2),0(R2)               Ptr\u00dd...\u00a8 \u00ac= Ptr\u00dd...\u00a8\n         SPACE\nEXIT0    SR    R2,R2              RETURN CODE 0\n*        LR    R1,R13             POINT TO ADDRESS TO FREEMAIN\n*        L     R0,WORKSIZ         LENGTH TO FREEMAIN\n         L     R13,4(,R13)        RESTORE ORIGINAL R13\n*        FREEMAIN R,A=(1),LV=(0)\n         DROP  R7\n         LR    R15,R2\n         LM    0,12,20(R13)\n         L     R14,12(,R13)\n         BR    R14\n         SPACE\n         LTORG\n         DC    0D'0'\nINITBUF  DC    X'67452301,EFCDAB89,98BADCFE,10325476'\nHEXTAB   DC    C'0123456789ABCDEF'\nWORKD    DSECT\n         DS    18F\nARGLIST  DS    4F\nM5BUF    DS    4F\nM5BYTES  DS    2F\nM5IN     DS    16F\nWORKINI  EQU   *-WORKD\n         DS    0D\nWORKLEN  EQU   *-WORKD\n         SPACE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nRS       EQU      R1\nA        EQU      R2  <--------------------\\\nB        EQU      R3                        \u00a6 Must be sequential since\nC        EQU      R4                        \u00a6 we use LM/STM opcodes\nD        EQU      R5  <--------------------/\nT1       EQU      R14\nT2       EQU      R15\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MD5COB$": {"ttr": 2564, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x14\\x10o\\x01\\x14\\x10o\\x11\\x11\\x009\\x00<\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2014-04-16T00:00:00", "modifydate": "2014-04-16T11:11:00", "lines": 57, "newlines": 60, "modlines": 0, "user": "UPDATED"}, "text": "//CBTUSER1 JOB (ACCT),'COBOL',NOTIFY=CBTUSER,\n//         MSGLEVEL=(1,1),MSGCLASS=H\n//*       CALL MD5 FROM ENTERPRISE COBOL\n//*       OBJECT DECK FOR MD5 IS IN MD5.OBJ\n//RUN     EXEC IGYWCLG,COND.LKED=(0,NE,COBOL),COND.GO=(0,NE,COBOL)\n//COBOL.SYSIN DD *\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. MD5TEST.\n      * TEST THE MD5 SUBROUTINE\n      * READ DATA FROM DDNAME INDD,\n      * AT END WRITE MD5 SUM TO SYSOUT.\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       SOURCE-COMPUTER. IBM-SYSTEM-Z.\n       OBJECT-COMPUTER. IBM-SYSTEM-Z.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT INFILE ASSIGN TO INDD\n             ORGANIZATION IS SEQUENTIAL\n             ACCESS IS SEQUENTIAL.\n       DATA DIVISION.\n       FILE SECTION.\n       FD INFILE\n           LABEL RECORDS STANDARD\n           RECORDING MODE F\n           BLOCK CONTAINS 0 CHARACTERS\n           RECORD CONTAINS 80 CHARACTERS.\n       01  INREC.\n           02 IN-DATA PIC X(80).\n       WORKING-STORAGE SECTION.\n       01  SWITCHES.\n           02 EOF-SWITCH PIC X VALUE SPACE.\n           88 EOF VALUE 'Y'.\n       01  CONTEXT.\n           02 FILLER OCCURS 22 TIMES PIC 9(5) COMP-5.\n       01  IWRK.\n           02 FILLER OCCURS 44 TIMES PIC 9(5) COMP-5.\n       77  IZ PIC 9(5) COMP-5 VALUE 0.\n       77  I80 PIC 9(5) COMP-5 VALUE 80.\n       77  RESULT PIC X(32).\n       PROCEDURE DIVISION.\n           OPEN INPUT INFILE.\n           MOVE LOW-VALUES TO CONTEXT.\n           PERFORM UNTIL EOF\n             READ INFILE AT END SET EOF TO TRUE END-READ\n             IF NOT EOF\n               CALL 'MD5' USING INREC, I80, CONTEXT, RESULT, IWRK\n             END-IF\n           END-PERFORM\n           CLOSE INFILE.\n           CALL 'MD5' USING INREC, IZ, CONTEXT, RESULT, IWRK.\n           DISPLAY RESULT.\n           STOP RUN.\n//LKED.SYSIN DD DSNAME=CBTUSER.MD5.OBJ,DISP=SHR\n//GO.INDD DD *\nHELLO\n//GO.SYSOUT DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MD5DATA": {"ttr": 2566, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x131_\\x01\\x131_\\x11\\x11\\x00\\x13\\x00\\x13\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2013-11-11T00:00:00", "modifydate": "2013-11-11T11:11:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "UPDATED"}, "text": "//CBTUSER3 JOB (ACCT),'PGMRNAME',NOTIFY=CBTUSER,\n//         MSGLEVEL=(1,1),MSGCLASS=H\n//* CREATE TEST DATA FOR MD5SUM\n//DG      EXEC PGM=IEBDG\n//SYSPRINT DD  SYSOUT=*\n//SEQOUT   DD  DSN=CBTUSER.MD5.DATA,DISP=(NEW,CATLG),\n//             UNIT=SYSALLDA,SPACE=(TRK,1),\n//             DCB=(RECFM=VB,LRECL=255,BLKSIZE=3120)\n//SYSIN    DD  *\n DSD OUTPUT=(SEQOUT)\n FD NAME=FIELD1,LENGTH=17,STARTLOC=1,\n    PICTURE=17,'Fried Rattlesnake'\n FD NAME=FIELD2,LENGTH=17,STARTLOC=1,\n    PICTURE=17,'Turkey Neck Gumbo'\n FD NAME=FIELD3,LENGTH=9,STARTLOC=1,\n    PICTURE=9,'Pecan Pie'\n CREATE QUANTITY=1,NAME=(FIELD1)\n CREATE QUANTITY=1,NAME=(FIELD2)\n CREATE QUANTITY=1,NAME=(FIELD3)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MD5FORT$": {"ttr": 2568, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x131_\\x01\\x131_\\x11\\x11\\x00(\\x00&\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2013-11-11T00:00:00", "modifydate": "2013-11-11T11:11:00", "lines": 40, "newlines": 38, "modlines": 0, "user": "UPDATED"}, "text": "//CBTUSER1 JOB (ACCT),'PGMR',NOTIFY=CBTUSER,\n//         MSGLEVEL=(1,1),MSGCLASS=H\n//*       COMPILE WITH FORTRAN G\n//*       OBJECT DECK FOR MD5 IS IN MD5.OBJ\n//FORT   EXEC PGM=IEYFORT,PARM=(OBJ,NODECK,TERM,NOXREF,BATCH,\n//             ASA,NODX,NOMX,NORX,RLD,NOUS,'PC(NOUHD)')\n//STEPLIB  DD  DSN=CBTUSER.FORT.LOAD,DISP=SHR\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSNAME=&&OBJ,DISP=(NEW,PASS),\n//             UNIT=SYSDA,SPACE=(TRK,(3,0)),\n//             DCB=(BLKSIZE=3200)\n//SYSIN    DD  *\nC - TEST THE MD5 SUBROUTINE\nC - READ DATA FROM DDNAME FT05F001, AT END WRITE MD5 SUM TO DD FT06F001\n      DIMENSION IREC(20),ICTX(22),IRES(8),IWRK(44)\n      DO 10 I=1,22\n   10 ICTX(I) = 0\n   20 READ (5,21,END=30) (IREC(I),I=1,20)\n   21 FORMAT(20A4)\n      CALL MD5(IREC,80,ICTX,IRES,IWRK)\n      GOTO 20\n   30 CALL MD5(IREC, 0,ICTX,IRES,IWRK)\nC - 16-BYTE BINARY RESULT IN 1ST 4 WORDS OF CTX\n      WRITE(6,100) (ICTX(I),I=1,4)\n  100 FORMAT(1X,4Z8)\nC - 32-BYTE PRINTABLE HEX RESULT IN 8 WORDS OF IRES\n      WRITE(6,200) (IRES(I),I=1,8)\n  200 FORMAT(1X,8A4)\n      STOP\n      END\n//LKED   EXEC PGM=HEWLDIA,PARM='MAP',\n//             COND=(0,NE)\n//SYSLOUT  DD  SYSOUT=*\n//SYSLIN   DD  DSNAME=&&OBJ,DISP=(OLD,DELETE)\n//         DD  DSNAME=CBTUSER.MD5.OBJ,DISP=SHR\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(TRK,(10,0))\n//SYSLIB   DD  DSN=CBTUSER.FORT.LOAD,DISP=SHR\n//FT05F001 DD  *\nHELLO\n//FT06F001 DD  SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MD5PGM": {"ttr": 2570, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x13\\x01 \\x13O\\x01 \\x16\\x7f\\x07$\\x01\\xde\\x01\\xdc\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2020-05-13T00:00:00", "modifydate": "2020-06-15T07:24:13", "lines": 478, "newlines": 476, "modlines": 0, "user": "UPDATED"}, "text": "         TITLE '   M D 5 P G M   '\n* WRITTEN MAY 10 2020\n* UPDATED MAY 12 2020\n* WRITE THE MD5 HASH OF THE INPUT FILE\n*\n* DDNAMES: SYSUT1 (INPUT) AND SYSUT2 (OUTPUT)\n*\n* MUST BE LINKED WITH SUBPROGRAM 'MD5'.\n*\n* IF PARM CONTAINS 'R' THEN RDW'S WILL BE INCLUDED IF INPUT IS V.\n* IF PARM CONTAINS 'L' THEN RESULT WILL BE SHOWN IN LOWERCASE.\n* IF PARM CONTAINS 'E' THEN RESULT WILL INCLUDE THE DATA SET NAME,\n* BUT ONLY THE FIRST DATA SET NAME IF CONCATENATED DATA SETS.\n*\n* OUTPUT WILL BE A FIXED-LENGTH 80-BYTE RECORD FILE,\n* UNLESS THE OUTPUT FILE ALREADY HAS OTHER ATTRIBUTES.\n*\n* MUCH OF THE SOURCE CODE IS BORROWED FROM MAKEB64 IN CBT FILE 741,\n* ALTHOUGH THAT PROGRAM HAS NOTHING TO DO WITH THE MD5 HASH.\n*\n* CALL MD5(IREC,80,ICTX22,IRES08,IWRK44)\n*\n* DISCLAIMER: NO GUARANTEE; NO WARRANTY; INSTALL/USE AT YOUR OWN RISK.\n*\n* SAMPLE JCL:\n*  //STEPNAME EXEC PGM=MD5PGM\n*  //SYSUT1 DD DSN=HLQ.INPUT.DATA,DISP=SHR\n*  //SYSUT2 DD SYSOUT=*\n*\n* LOG OF CHANGES:\n*  JUNE 15 2020 - FIX RDW\n         SPACE\nMD5PGM   RMODE ANY\nMD5PGM   AMODE 31\nMD5PGM   CSECT\n         USING *,R10\n         B     @PROLOG-*(,R15)\n         DC    AL1(7),CL7'MD5PGM'\n         DC    CL16' &SYSDATE &SYSTIME '\n@SIZE    DC    0F'0',AL1(0),AL3(@DATAL)\n@PROLOG  STM   14,12,12(13)\n         LR    R10,R15\n         LR    R2,R1               POINT R2 TO PARM ADDRESS\n         L     R0,@SIZE\n         STORAGE OBTAIN,LENGTH=(0)\n         LR    R9,R1               POINT R9 TO OBTAINED AREA\n         XC    0(@CLEARL,R9),0(R9)\n         USING @DATA,R9\n         ST    R13,4(,R9)          OLD ADDRESS IN NEW SAVE AREA\n         ST    R9,8(,R13)          NEW ADDRESS IN OLD SAVE AREA\n         LR    R13,R9              POINT R13 TOP NEW SAVE AREA\n         SPACE\n*\n*         GET STORAGE BELOW THE LINE FOR DCB'S ETC.\n*\n         LA    R0,@DATA24L\n         STORAGE OBTAIN,LENGTH=(0),LOC=24\n         LR    R8,R1               POINT R8 TO OBTAINED AREA\n         USING @DATA24,R8\n         SPACE\n         L     R1,0(,R2)           POINT TO PARM\n         LH    R14,0(,R1)          LENGTH OF PARM\n         LTR   R14,R14\n         BZ    PARMX\n         LA    R15,2(,R1)\nPARMLOOP CLI   0(R15),C'R'         IF PARM CONTAINS R (FOR RDW)\n         BNE   *+8                   THEN\n         MVI   OPTR,1                TURN ON RDW OPTION\n         CLI   0(R15),C'L'         IF PARM CONTAINS L (FOR LOWERCASE)\n         BNE   *+8                   THEN\n         MVI   OPTL,1                TURN ON LOWERCASE OPTION\n         CLI   0(R15),C'E'         IF PARM CONTAINS E (FOR EXTRA INFO)\n         BNE   *+8                   THEN\n         MVI   OPTE,1                TURN ON EXTRA OPTION\n         LA    R15,1(,R15)\n         BCT   R14,PARMLOOP\nPARMX    EQU   *\n         SPACE\n         LA    R15,12\n         ST    R15,RETCODE\n         SPACE\n         LA    R3,UT1DCBW\n         LA    R4,UT2DCBW\n         MVC   0(UT1DCBL,R3),UT1DCB\n         MVC   0(UT2DCBL,R4),UT2DCB\n         TM    0(R2),X'80'         ONLY 1 PARAMETER\n         BO    NODD                YES, BYPASS DD ROUTINE\n         L     R14,4(,R2)          POINT TO DDNAME LIST\n         LH    R1,0(,R14)          GET LENGTH OF DDNAME LIST\n         LA    R14,2(,R14)         POINT PAST LENGTH\n         SPACE\n*        CH    R1,=H'48'           LONG ENOUGH FOR SYSPRINT\n*        BL    NODD                NO, BRANCH\n*        CLI   40(R14),0           SYSPRINT OVERRIDE\n*        BE    *+10                NO, SKIP MVC\n*        MVC   DDNAM(8,R3),40(R14)\n         SPACE\n         CH    R1,=H'64'           LONG ENOUGH FOR SYSUT1\n         BL    NODD                NO, BRANCH\n         CLI   56(R14),0           SYSUT1 OVERRIDE\n         BE    *+10                NO, SKIP MVC\n         MVC   DDNAM(8,R3),56(R14)                                .FIX.\n         SPACE\n         CH    R1,=H'72'           LONG ENOUGH FOR SYSUT2\n         BL    NODD                NO, BRANCH\n         CLI   64(R14),0           SYSUT2 OVERRIDE\n         BE    *+10                NO, SKIP MVC\n         MVC   DDNAM(8,R4),64(R14)                                .FIX.\nNODD     EQU   *\n         SPACE\n         LA    R5,UT1DCBEW\n         LA    R6,UT2DCBEW\n         MVC   0(UT1DCBEL,R5),UT1DCBE\n         MVC   0(UT2DCBEL,R6),UT2DCBE\n         ST    R5,0(,R3)           ST    R5,DCBDCBE-IHADCB(,R3)\n         ST    R6,0(,R4)           ST    R5,DCBDCBE-IHADCB(,R3)\n         SPACE\n**********************************************************************\n*              OPEN INPUT DCB\n**********************************************************************\n         LA    R1,UT1EXLST         POINT TO INPUT DCB EXIT LIST\n         STCM  R1,7,EXLST+1(R3)    STORE ADDRESS OF EXIT LIST IN DCB\n         LA    R15,JFCB\n         ST    R15,0(,R1)          1ST EXLST WORD\n         MVI   0(R1),X'87'         JFCB ADDRESS FOR RDJFCB\n         SPACE\n         MVI   UT1RDJF,X'80'\n         RDJFCB ((R3)),MF=(E,UT1RDJF)\n         SPACE\n         MVC   OPEN31W(OPEN31L),OPEN31\n         OPEN  ((R3),INPUT),MODE=31,MF=(E,OPEN31W)\n*        TM    OFLGS(R3),X'10'     TEST FOR SUCCESSFUL OPEN\n*        TM    16(R5),X'C0'        TM    DCBEFLG1,DCBEOPEN+DCBEMD31\n*        TM    DCBEFLG1-DCBE(R5),DCBEOPEN+DCBEMD31 OPEN AND 31-BIT SAM\n         TM    DCBEFLG1-DCBE(R5),DCBEOPEN OPEN SUCCESSFUL\n         BNO   EXIT\n         TM    DCBEFLG1-DCBE(R5),DCBEMD31 31-BIT SAM SUPPORTED?\n         BO    NOT24I              YES, NOTHING TO CHANGE\n**********************************************************************\n*              MAKE CHANGES FOR 24-BIT GET\n**********************************************************************\n         LA    R15,EOD24S          POINT TO 24-BIT EODAD LOCATION\n         MVC   0(EOD24L,R15),EOD24I  COPY EOD24I CODE TO 24-BIT EODAD\n         LA    R0,UT1EOD           POINT TO 31-BIT EODAD\n*        O     R0,=A(X'80000000')  SET 31-BIT MODE IN UT1EOD ADDRESS\n         OILH  R0,X'8000'          SET 31-BIT MODE IN UT1EOD ADDRESS\n         ST    R0,EOD24P-EOD24I(,R15) STORE UT1EOD ADDRESS AND MODE\n         ST    R15,DCBEEODA-DCBE(R5) CHANGE DCBE EODAD TO EOD24S\n         MVC   GET24S(GET24L),GET24I COPY 24-BIT GET\nNOT24I   EQU   *\n**********************************************************************\n*              OPEN OUTPUT DCB\n**********************************************************************\n         LA    R1,UT2EXLST         POINT TO OPEN EXIT LIST\n         STCM  R1,7,EXLST+1(R4)    STORE ADDRESS OF EXIT LIST IN DCB\n         LA    R15,UT2OPENX        POINT TO OPEN EXIT ENTRY POINT\n         ST    R15,0(,R1)          STORE ADDRESS OF EXIT IN EXIT LIST\n         MVI   0(R1),X'85'         SET HIGH BYTE OF EXIT LIST\n         MVC   0(UT2OPENL,R15),UT2GLUE  COPY EXIT TO 24-BIT STORAGE\n         LA    R0,UT2EXIT          POINT TO 31-BIT EXIT\n*        O     R0,=A(X'80000000')  SET 31-BIT MODE IN ADDRESS\n         OILH  R0,X'8000'          SET 31-BIT MODE IN ADDRESS\n         ST    R0,UT2GLUEP-UT2GLUE(,R15) STORE EXIT ADDRESS FOR GLUE\n         SPACE\n         OPEN  ((R4),OUTPUT),MODE=31,MF=(E,OPEN31W)\n         TM    DCBEFLG1-DCBE(R6),DCBEOPEN OPEN SUCCESSFUL\n         BNO   EXITC1\n*        TM    DCBEFLG1-DCBE(R6),DCBEMD31 31-BIT SAM SUPPORTED?\n*        BNO   EXITC2              NO, CLOSE OUTPUT AND QUIT\n         SPACE\n**********************************************************************\n*              SET UP MD5 PARAMETER LIST\n**********************************************************************\n         LA    R1,MD5ARGS\n         XC    ICTX22(22*4),ICTX22\n         LA    R0,ILEN\n         ST    R0,4(,R1)  2ND ARG\n         LA    R0,ICTX22\n         ST    R0,8(,R1)  3RD ARG\n         LA    R0,IRES08\n         ST    R0,12(,R1) 4TH ARG\n         LA    R0,IWRK44\n*        O     R0,=A(X'80000000')  LAST PARAMETER\n         OILH  R0,X'8000'          LAST PARAMETER\n         ST    R0,16(,R1) 5TH ARG\n         SPACE\n**********************************************************************\n*              READ A RECORD\n**********************************************************************\nREADLOOP EQU   *\n         LA    R5,UT1DCBEW\n         TM    DCBEFLG1-DCBE(R5),DCBEMD31 31-BIT SAM SUPPORTED?\n         BNO   GET24               NO, USE 24-BIT MOOE FOR GET\n         GET   (R3)\n         B     GETRET\nGET24    LA    R15,GET24S\n*        MVC   0(GET24L,R15),GET24I (ALREADY MOVED, ONCE IS ENOUGH)\n         ST    R13,SAVE24+4        SAVE R13\n         LA    R13,SAVE24          GET NEEDS R13 TO POINT BELOW LINE\n         BASSM R7,R15              RUN GET IN 24-BIT MODE\n         L     R13,SAVE24+4        RESTORE R13\n         SPACE\nGETRET   LR    R5,R1               POINT TO RECORD\n         TM    RECFM(R3),X'C0'     RECFM U\n         BO    GETU\n         TM    RECFM(R3),X'80'     RECFM F\n         BO    GETF\nGETV     LA    R0,4\n         LH    R7,0(,R5)           LENGTH+4 FROM RDW\n         CLI   OPTR,0              IF R IN PARM\n         BNE   GOT                    INCLUDE RDW\n         AR    R5,R0               POINT PAST RDW\n         SR    R7,R0               REDUCE LENGTH\n         B     GOT\nGETU     LH    R7,LRECL(,R3)\n         B     GOT\nGETF     LH    R7,LRECL(,R3)       GET LENGTH FROM LRECL\n         TM    RECFM(R3),X'10'     IF NOT BLOCKED\n         BO    *+8                   THEN\n         LH    R7,BLKSI(,R3)         USE BLKSIZE AS LENGTH\n**********************************************************************\n*              CALL MD5 FOR EACH RECORD\n**********************************************************************\n*              CALL MD5 FOR EACH RECORD READ\nGOT      ST    R5,MD5ARGS          RECORD ADDRESS\n         ST    R7,ILEN             RECORD LENGTH\n         LA    R1,MD5ARGS\n         L     R15,=V(MD5)\n         CALL  (15)\n         B     READLOOP\n         SPACE\n**********************************************************************\n*              END-OF-FILE, CALL MD5 ONE LAST TIME\n**********************************************************************\nUT1EOD   EQU   *\n         SR    R0,R0               LENGTH ZERO FOR FINAL CALL\n         ST    R0,ILEN\n         LA    R1,MD5ARGS\n         L     R15,=V(MD5)\n         CALL  (15)\n**********************************************************************\n*              OUTPUT THE RESULTS\n**********************************************************************\n         MVI   OBUF,C' '\n         MVC   OBUF+1(255),OBUF\n*        MVC   ORDW(4),=AL2(36,0)\n         LA    R15,OBUF\n         TM    RECFM(R4),X'04'     IF ASA CARRIAGE CONTROL\n         BZ    NOTASA                THEN\n         LA    R15,1(,R15)           POINT PAST 1ST COLUMN\nNOTASA   EQU   *\n         MVC   0(32,R15),IRES08    COPY HEX RESULT\n*        TR    0(32,R15),LOWER     TRANSLATE TO LOWER CASE\n         LA    R1,32(,R15)         POINT R1 PAST LAST BYTE\n         CLI   OPTE,1              IF NO 'E' IN PARM, (SHOW DSN)\n         BNE   SETLEN                GO TO SETLEM\n         MVI   33(R15),C'*'        ELSE ADD *\n         MVC   34(44,R15),JFCB     AND DSN\n         LA    R1,34+43(,R15)      LAST CHAR OF DSNAME\n         LA    R0,44               INITIAL LENGTH\nFILEA    CLI   0(R1),C' '          IS THIS LAST NONBLANK\n         BNE   FILEB               YES, BRANCH\n         BCTR  R1,0                BACK UP 1 CHARACTER\n         BCT   R0,FILEA            DECREMENT LENGTH AND BRANCH\nFILEB    LA    R1,1(,R1)           POINT PAST LAST CHAR\n         CLI   JFCB+44,C' '        IF NO MEMBER IN JFCB\n         BE    SETLEN                GO TP SETLEM\n         MVI   0(R1),C'('\n         MVC   1(8,R1),JFCB+44     JFCBELNM IN IEFJFCBN\n         LA    R1,8(,R1)           LAST CHAR OF MEMBER NAME\n         LA    R0,8\nMEMA     CLI   0(R1),C' '\n         BNE   MEMB\n         BCTR  R1,0\n         BCT   R0,MEMA\nMEMB     MVI   1(R1),C')'\n         LA    R1,1(,R1)           POINT PAST LAST CHAR\nSETLEN   LA    R0,OBUF\n         SR    R1,R0               COMPUTE LENGTH\nNONAME   EQU   *\n         CLI   OPTL,1              IF 'L' IN PARM, FOR LOWERCASE\n         BNE   *+10                  THEN\n         TR    OBUF(256),LOWER       TRANSLATE TO LOWER CASE\n         LA    R0,OBUF             PUT WILL USE R0 AS RECORD ADDRESS\nPUTU     TM    RECFM(R4),X'C0'     IF OUTPUT RECFM U\n         BNO   PUTV\n         STH   R1,LRECL(,R4)       SET RECFM U RECORD SIZE\n         B     PUTT\nPUTV     TM    RECFM(R4),X'40'     IF RECFM V\n         BZ    PUTT                  THEN\n         LA    R1,4(,R1)             LENGTH + 4 FOR RDW\n         LH    R0,LRECL(,R4)         GET LRECL\n         CR    R1,R0                 IF LONGER THAN LRECL\n         BNH   *+6                     THEN\n         LR    R1,R0                   TRUNCATE TO LRECL\n         SLL   R1,16                 SHIFT LEFT 16 BITS\n         ST    R1,ORDW               SET RDW\n         LA    R0,ORDW               USE RDW FOR PUT\nPUTT     TM    DCBEFLG1-DCBE(R6),DCBEMD31 31-BIT SAM SUPPORTED?\n         BNO   PUT24               NO, USE 24-BIT MOOE FOR PUT\n         PUT   (R4),(0)\n         B     EXIT0\nPUT24    LA    R15,PUT24S\n         MVC   0(PUT24L,R15),PUT24I\n         ST    R13,SAVE24+4        SAVE R13\n         LA    R13,SAVE24          PUT NEEDS R13 TO POINT BELOW LINE\n         BASSM R7,R15              RUN PUT IN 24-BIT MODE\n         L     R13,SAVE24+4        RESTORE R13\n         B     EXIT0\n         SPACE\n*        THE FOLLOWING INSTRUCTIONS FROM PUT24I TO PUT24L ARE COPIED\n*        TO STORAGE BELOW THE LINE AND ARE CALLED BY THE BASSM ABOVE.\n*        THEY RUN IN 24-BIT MODE SO THE PUT WILL WORK FOR A TERMINAL.\n*        THEY DON'T USE A BASE REGISTER, SO THAT SIMPLIFIES IT.\nPUT24I   PUT   (R4),(0)\n         BSM   0,R7\nPUT24L   EQU   *-PUT24I\n         SPACE\n*        THE FOLLOWING INSTRUCTIONS FROM GET24I TO GET24L ARE COPIED\n*        TO STORAGE BELOW THE LINE AND ARE CALLED BY A BASSM.\nGET24I   GET   (R3)\n         BSM   0,R7\nGET24L   EQU   *-GET24I\n         SPACE\nEXITN    CLI   RETCODE+3,12        IF AN ERROR OCCURRED\n         BNE   EXITC2                DON'T SET RC 0\nEXIT0    MVI   RETCODE+3,0\nEXITC2   MVC   CLOSE31W(CLOSE31L),CLOSE31\n         CLOSE ((R4)),MODE=31,MF=(E,CLOSE31W)\n*        LR    R7,R4\n*        BAL   R2,FREEPOOL\nEXITC1   MVC   CLOSE31W(CLOSE31L),CLOSE31\n         CLOSE ((R3)),MODE=31,MF=(E,CLOSE31W)\n*        LR    R7,R3\n*        BAL   R2,FREEPOOL\n         B     EXIT\n*REEPOOL FREEPOOL (R7)\n*        BR    R2\nEXIT     L     R2,RETCODE\n         LR    R1,R8\n         LA    R0,@DATA24L\n         STORAGE RELEASE,ADDR=(1),LENGTH=(0)\n         LR    R1,R13\n         L     R0,@SIZE\n         L     R13,4(,R13)\n         STORAGE RELEASE,ADDR=(1),LENGTH=(0)\n         DROP  R9\n         LR    R15,R2\n         LM    0,12,20(R13)\n         L     R14,12(,R13)\n         BR    R14\n         SPACE\n*         DCB OPEN EXIT\nUT2EXIT  CLI   RECFM(R1),0         IF NO RECFM\n         BNE   UT2EXI2                THEN\n         MVI   RECFM(R1),X'90'        USE FB\nUT2EXI2  TM    RECFM(R1),X'10'     IF BLOCKED\n         BZ    UT2EXI3                AND\n         CLC   LRECL(2,R1),=H'0'      NO LRECL\n         BNE   UT2EXI3                THEN\n         MVC   LRECL(2,R1),=H'80'     USE 80\nUT2EXI3  CLC   BLKSI(2,R1),=H'0'   IF NO BLKSIZE\n         BNE   UT2EXI4                THEN\n         MVC   BLKSI(2,R1),LRECL(R1)  USE LRECL\nUT2EXI4  BR    R14\n         SPACE\n*        THIS ROUTINE IS COPIED TO 24-BIT STORAGE\n*        IT IS ENTERED IN 24-BIT MODE, CALLS UT2EXIT IN 31-BIT MODE\n*        LEAVING ORIGINAL R14 RETURN ADDRESS IN R14\n         CNOP  0,4                 ALIGN ON FULLWORD\nUT2GLUE  L     R15,UT2GLUEP-*(,R15)   GET ADDRESS OF UT2EXIT\n         BSM   R14,R15             CALL UT2EXIT WITH OLD MODE IN R14\nUT2GLUEP DC    F'0'                WILL CONTAIN ADDRESS OF UT2EXIT\nUT2OPENL EQU   *-UT2GLUE\n         SPACE\n*        THIS ROUTINE IS COPIED TO 24-BIT STORAGE\n*        IT IS ENTERED IN 24-BIT MODE, GOES TO UT1EOD IN 31-BIT MODE\n         CNOP  0,4                 ALIGN ON FULLWORD\nEOD24I   L     R15,EOD24P-*(,R15)  GET ADDRESS OF UT1EOD AND 31-BIT\n         L     R13,SAVE24+4        RESTORE R13 CHANGED BEFORE GET\n         BSM   R0,R15              GOTO UT1EOD IN 31-BIT MODE\nEOD24P   DC    F'0'                WILL CONTAIN ADDRESS OF UT2EXIT\nEOD24L   EQU   *-EOD24I\n         SPACE\n         LTORG\n         DC    0D'0'\n         PRINT NOGEN\nUT1DCB   DCB   DDNAME=SYSUT1,DSORG=PS,MACRF=(GL),EODAD=0,DCBE=0\nUT1DCBL  EQU   *-UT1DCB\nUT1DCBE  DCBE  RMODE31=BUFF,EODAD=UT1EOD\nUT1DCBEL EQU   *-UT1DCBE\nUT2DCB   DCB   DDNAME=SYSUT2,DSORG=PS,MACRF=(PM),EXLST=0,DCBE=0\nUT2DCBL  EQU   *-UT2DCB\nUT2DCBE  DCBE  RMODE31=BUFF\nUT2DCBEL EQU   *-UT2DCBE\nUT1EXL   DC    0F'0',X'87',AL3(0)\nUT2EXL   DC    0F'0',X'85',AL3(0)\nOPEN31   OPEN  (0,),MODE=31,MF=L\nOPEN31L  EQU   *-OPEN31\nCLOSE31  CLOSE (0,),MODE=31,MF=L\nCLOSE31L EQU   *-CLOSE31\n         DC    0D'0'\nLOWER    DC    256AL1(*-LOWER)\n         ORG   LOWER+C'A'\n         DC    X'818283848586878889'\n         ORG   LOWER+C'J'\n         DC    X'919293949596979899'\n         ORG   LOWER+C'S'\n         DC    X'A2A3A4A5A6A7A8A9'\n         ORG\n         DC    0D'0'\n         SPACE\n@DATA    DSECT\n         DS    18F\nRETCODE  DS    F\nOPEN31W  DS    F\nCLOSE31W DS    F\nOPTE     DS    H\nOPTL     DS    H\nOPTR     DS    H\n@CLEARL  EQU   *-@DATA\nUT1DCBEW DS    0F,(UT1DCBEL)X\nUT2DCBEW DS    0F,(UT2DCBEL)X\nMD5ARGS  DS    5F\nILEN     DS    F\nICTX22   DS    0D,22F\nIRES08   DS    0D,8F\nIWRK44   DS    0D,44F\n         DS    0D\n@DATAL   EQU   *-@DATA\n         SPACE\n@DATA24  DSECT\nSAVE24   DS    18F\nUT1DCBW  DS    0F,(UT1DCBL)X\nUT2DCBW  DS    0F,(UT2DCBL)X\nUT1EXLST DS    F\nUT2EXLST DS    F\nUT1RDJF  DS    F\nUT2OPENX DS    0F,(UT2OPENL)X  GLUE ROUTINE COPIED HERE\nGET24S   DS    0H,(GET24L)X\nPUT24S   DS    0H,(PUT24L)X\nEOD24S   DS    0H,(EOD24L)X\n*        OUTPUT BUFFERS ARE HERE IN CASE PUT TO TERMINAL, DCBEMD31 OFF\nORDW     DS    F\nOBUF     DS    256C\n         DS    0D\nJFCB     DS    CL176\n         DS    0D\n@DATA24L EQU   *-@DATA24\n         SPACE\n         PRINT NOGEN\n         IHADCBE\n         SPACE\n*         EQUATES FOR DCB FIELD OFFSETS\nEXLST    EQU   36\nRECFM    EQU   36\nDDNAM    EQU   44\nOFLGS    EQU   48\nBLKSI    EQU   62\nLRECL    EQU   82\n         SPACE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MD5PGM$": {"ttr": 2820, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x18\\x01 \\x13O\\x01 \\x13O\\x19\\x19\\x00\\x11\\x00\\x11\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-05-13T00:00:00", "modifydate": "2020-05-13T19:19:18", "lines": 17, "newlines": 17, "modlines": 0, "user": "UPDATED"}, "text": "//CBTUSER1 JOB (ACCT),'PGMRNAME',NOTIFY=CBTUSER,\n//         MSGLEVEL=(1,1),MSGCLASS=H\n//ASM     EXEC PGM=ASMA90,\n//             PARM=(LIST,OBJ,NODECK,ASA,NOXREF,NODX,NOMX,NORX,NOUS,\n//             BATCH,'PC(NOUHD)')\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//SYSLIN   DD  DSN=&&OBJ,DISP=(NEW,PASS),SPACE=(TRK,(3,3)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=800)\n//SYSIN    DD  DSN=CBTUSER.LIB.ASM(MD5PGM),DISP=SHR\n//         DD  DSN=CBTUSER.LIB.ASM(MD5),DISP=SHR\n//LKED   EXEC PGM=HEWLF064,PARM='MAP,NOXREF,RENT,REFR',\n//             COND=(0,NE)\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSNAME=&&OBJ,DISP=(OLD,DELETE)\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(TRK,(10,0))\n//SYSLMOD  DD  DSN=CBTUSER.LIB.LOAD(MD5PGM),DISP=SHR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MD5PGM#": {"ttr": 2822, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00X\\x01 \\x13O\\x01 \\x14\\x1f\\x15\\x07\\x00\\x11\\x00\\x08\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2020-05-13T00:00:00", "modifydate": "2020-05-20T15:07:58", "lines": 17, "newlines": 8, "modlines": 0, "user": "SBGOLOB"}, "text": "//CBTUSER1 JOB (ACCT),'MD5PGM',NOTIFY=CBTUSER,\n//         MSGLEVEL=(1,1),MSGCLASS=H\n//ASM     EXEC PGM=ASMA90,\n//             PARM=(LIST,OBJ,NODECK,ASA,NOXREF,NODX,NOMX,NORX,NOUS,\n//             BATCH,'PC(NOUHD)')\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//SYSLIN   DD  DSN=&&OBJ,DISP=(NEW,PASS),SPACE=(TRK,(3,3)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=800)\n//SYSIN    DD  DSN=CBTUSER.LIB.ASM(MD5PGM),DISP=SHR\n//         DD  DSN=CBTUSER.LIB.ASM(MD5),DISP=SHR\n//LKED   EXEC PGM=HEWLF064,PARM='MAP,NOXREF,RENT,REFR',\n//             COND=(0,NE)\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSNAME=&&OBJ,DISP=(OLD,DELETE)\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(TRK,(10,0))\n//SYSLMOD  DD  DSN=CBTUSER.LIB.LOAD(MD5PGMT),DISP=SHR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MD5PLI$": {"ttr": 2824, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x14\\x10o\\x01\\x14\\x10o\\x11\\x11\\x00%\\x00&\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2014-04-16T00:00:00", "modifydate": "2014-04-16T11:11:00", "lines": 37, "newlines": 38, "modlines": 0, "user": "UPDATED"}, "text": "//CBTUSER1 JOB (ACCT),'PL/I',NOTIFY=CBTUSER,\n//         MSGLEVEL=(1,1),MSGCLASS=H,REGION=0M\n//*       CALL MD5 FROM ENTERPRISE PL/1\n//*       OBJECT DECK FOR MD5 IS IN MD5.OBJ\n//RUN     EXEC IBMZCPLG,PARM.PLI='SOURCE',LNGPRFX=IEL390,\n//        COND.LKED=(0,NE,PLI),COND.GO=(0,NE,PLI)\n//PLI.SYSIN DD *\n TESTMD5: PROCEDURE OPTIONS (MAIN);\n DCL INFILE FILE INPUT;\n DCL INREC CHARACTER(80);\n DCL END_FILE FIXED BINARY;\n DCL MD5 ENTRY (CHAR(80), FIXED BIN(31),\n                (*) FIXED BIN(31),\n                CHAR(32),\n                (*) FIXED BIN(31))\n         OPTIONS(ASM, INTER);\n DCL CONTEXT(22) FIXED BIN(31);\n DCL IWRK(44) FIXED BIN(31);\n DCL RESULT CHARACTER(32);\n OPEN FILE(INFILE) TITLE('INDD');\n END_FILE = 0;\n ON ENDFILE(INFILE) END_FILE = 1;\n CONTEXT = '';\n GET FILE(INFILE) EDIT(INREC) (L);\n DO WHILE (END_FILE = 0);\n   /* PUT SKIP LIST (INREC); */\n   CALL MD5(INREC,80,CONTEXT,RESULT,IWRK);\n   GET FILE(INFILE) EDIT(INREC) (L);\n END;\n CLOSE FILE(INFILE);\n CALL MD5(INREC,0,CONTEXT,RESULT,IWRK);\n PUT SKIP LIST (RESULT);\n END TESTMD5;\n//LKED.SYSIN DD DSNAME=CBTUSER.MD5.OBJ,DISP=SHR\n//GO.SYSPRINT DD SYSOUT=*\n//GO.INDD DD *\nHELLO\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MD5P24": {"ttr": 2826, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00V\\x01 \\x13O\\x01 \\x16\\x7f\\x11\\x11\\x01\\x82\\x01\\x80\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2020-05-13T00:00:00", "modifydate": "2020-06-15T11:11:56", "lines": 386, "newlines": 384, "modlines": 0, "user": "UPDATED"}, "text": "         TITLE '   M D 5 P G M   '\n* WRITTEN MAY 10 2020\n* UPDATED MAY 13 2020\n* WRITE THE MD5 HASH OF THE INPUT FILE (24-BIT VERSION OF MD5PGM)\n*\n* DDNAMES: SYSUT1 (INPUT) AND SYSUT2 (OUTPUT)\n*\n* MUST BE LINKED WITH SUBPROGRAM 'MD5'.\n*\n* IF PARM CONTAINS 'R' THEN RDW'S WILL BE INCLUDED IF INPUT IS V.\n* IF PARM CONTAINS 'L' THEN RESULT WILL BE SHOWN IN LOWERCASE.\n* IF PARM CONTAINS 'E' THEN RESULT WILL INCLUDE THE DATA SET NAME,\n* BUT ONLY THE FIRST DATA SET NAME IF CONCATENATED DATA SETS.\n*\n* OUTPUT WILL BE A FIXED-LENGTH 80-BYTE RECORD FILE,\n* UNLESS THE OUTPUT FILE ALREADY HAS OTHER ATTRIBUTES.\n*\n* MUCH OF THE SOURCE CODE IS BORROWED FROM MAKEB64 IN CBT FILE 741,\n* ALTHOUGH THAT PROGRAM HAS NOTHING TO DO WITH THE MD5 HASH.\n*\n* CALL MD5(IREC,80,ICTX22,IRES08,IWRK44)\n*\n* DISCLAIMER: NO GUARANTEE; NO WARRANTY; INSTALL/USE AT YOUR OWN RISK.\n*\n* SAMPLE JCL:\n*  //STEPNAME EXEC PGM=MD5PGM\n*  //SYSUT1 DD DSN=HLQ.INPUT.DATA,DISP=SHR\n*  //SYSUT2 DD SYSOUT=*\n*\n* LOG OF CHANGES:\n*  JUNE 15 2020 - FIX RDW\n         SPACE\nMD5PGM   CSECT\n         USING *,R10\n         B     @PROLOG-*(,R15)\n         DC    AL1(7),CL7'MD5PGM'\n         DC    CL16' &SYSDATE &SYSTIME '\n@SIZE    DC    0F'0',AL1(0),AL3(@DATAL)\n@PROLOG  STM   14,12,12(13)\n         LR    R10,R15\n         LR    R2,R1               POINT R2 TO PARM ADDRESS\n         L     R0,@SIZE\n         GETMAIN R,LV=(0)\n         LR    R9,R1               POINT R9 TO OBTAINED AREA\n         XC    0(@CLEARL,R9),0(R9)\n         USING @DATA,R9\n         ST    R13,4(,R9)          OLD ADDRESS IN NEW SAVE AREA\n         ST    R9,8(,R13)          NEW ADDRESS IN OLD SAVE AREA\n         LR    R13,R9              POINT R13 TOP NEW SAVE AREA\n         SPACE\n*\n*         GET STORAGE BELOW THE LINE FOR DCB'S ETC.\n*\n         LA    R0,@DATA24L\n         GETMAIN R,LV=(0)\n         LR    R8,R1               POINT R8 TO OBTAINED AREA\n         USING @DATA24,R8\n         SPACE\n         L     R1,0(,R2)           POINT TO PARM\n         LH    R14,0(,R1)          LENGTH OF PARM\n         LTR   R14,R14\n         BZ    PARMX\n         LA    R15,2(,R1)\nPARMLOOP CLI   0(R15),C'R'         IF PARM CONTAINS R (FOR RDW)\n         BNE   *+8                   THEN\n         MVI   OPTR,1                TURN ON RDW OPTION\n         CLI   0(R15),C'L'         IF PARM CONTAINS L (FOR LOWERCASE)\n         BNE   *+8                   THEN\n         MVI   OPTL,1                TURN ON LOWERCASE OPTION\n         CLI   0(R15),C'E'         IF PARM CONTAINS E (FOR EXTRA INFO)\n         BNE   *+8                   THEN\n         MVI   OPTE,1                TURN ON EXTRA OPTION\n         LA    R15,1(,R15)\n         BCT   R14,PARMLOOP\nPARMX    EQU   *\n         SPACE\n         LA    R15,12\n         ST    R15,RETCODE\n         SPACE\n         LA    R3,UT1DCBW\n         LA    R4,UT2DCBW\n         MVC   0(UT1DCBL,R3),UT1DCB\n         MVC   0(UT2DCBL,R4),UT2DCB\n         TM    0(R2),X'80'         ONLY 1 PARAMETER\n         BO    NODD                YES, BYPASS DD ROUTINE\n         L     R14,4(,R2)          POINT TO DDNAME LIST\n         LH    R1,0(,R14)          GET LENGTH OF DDNAME LIST\n         LA    R14,2(,R14)         POINT PAST LENGTH\n         SPACE\n*        CH    R1,=H'48'           LONG ENOUGH FOR SYSPRINT\n*        BL    NODD                NO, BRANCH\n*        CLI   40(R14),0           SYSPRINT OVERRIDE\n*        BE    *+10                NO, SKIP MVC\n*        MVC   DDNAM(8,R3),40(R14)\n         SPACE\n         CH    R1,=H'64'           LONG ENOUGH FOR SYSUT1\n         BL    NODD                NO, BRANCH\n         CLI   56(R14),0           SYSUT1 OVERRIDE\n         BE    *+10                NO, SKIP MVC\n         MVC   DDNAM(8,R3),56(R14)                                .FIX.\n         SPACE\n         CH    R1,=H'72'           LONG ENOUGH FOR SYSUT2\n         BL    NODD                NO, BRANCH\n         CLI   64(R14),0           SYSUT2 OVERRIDE\n         BE    *+10                NO, SKIP MVC\n         MVC   DDNAM(8,R4),64(R14)                                .FIX.\nNODD     EQU   *\n         SPACE\n**********************************************************************\n*              OPEN INPUT DCB\n**********************************************************************\n         LA    R1,UT1EXLST         POINT TO INPUT DCB EXIT LIST\n*        STCM  R1,7,EXLST+1(R3)    STORE ADDRESS OF EXIT LIST IN DCB\n         IC    R0,EXLST(,R3)\n         ST    R1,EXLST(,R3)       STORE ADDRESS OF EXIT LIST IN DCB\n         STC   R0,EXLST(,R3)\n         LA    R15,JFCB\n         ST    R15,0(,R1)          1ST EXLST WORD\n         MVI   0(R1),X'87'         JFCB ADDRESS FOR RDJFCB\n         SPACE\n         MVI   UT1RDJF,X'80'\n         RDJFCB ((R3)),MF=(E,UT1RDJF)\n         SPACE\n         MVI   OPENW,X'80'\n         OPEN  ((R3),INPUT),MF=(E,OPENW)\n         TM    OFLGS(R3),X'10'     TEST FOR SUCCESSFUL OPEN\n         BNO   EXIT\n**********************************************************************\n*              OPEN OUTPUT DCB\n**********************************************************************\n         LA    R1,UT2EXLST         POINT TO OPEN EXIT LIST\n*        STCM  R1,7,EXLST+1(R4)    STORE ADDRESS OF EXIT LIST IN DCB\n         IC    R0,EXLST(,R4)\n         ST    R1,EXLST(,R4)       STORE ADDRESS OF EXIT LIST IN DCB\n         STC   R0,EXLST(,R4)\n         LA    R15,UT2EXIT         POINT TO OPEN EXIT ENTRY POINT\n         ST    R15,0(,R1)          STORE ADDRESS OF EXIT IN EXIT LIST\n         MVI   0(R1),X'85'         SET HIGH BYTE OF EXIT LIST\n         SPACE\n         MVI   OPENW,X'80'\n         OPEN  ((R4),OUTPUT),MF=(E,OPENW)\n         TM    OFLGS(R3),X'10'     TEST FOR SUCCESSFUL OPEN\n         BNO   EXITC1\n         SPACE\n**********************************************************************\n*              SET UP MD5 PARAMETER LIST\n**********************************************************************\n         LA    R1,MD5ARGS\n         XC    ICTX22(22*4),ICTX22\n         LA    R0,ILEN\n         ST    R0,4(,R1)  2ND ARG\n         LA    R0,ICTX22\n         ST    R0,8(,R1)  3RD ARG\n         LA    R0,IRES08\n         ST    R0,12(,R1) 4TH ARG\n         LA    R0,IWRK44\n         O     R0,=A(X'80000000')  LAST PARAMETER\n*        OILH  R0,X'8000'          LAST PARAMETER\n         ST    R0,16(,R1) 5TH ARG\n         SPACE\n**********************************************************************\n*              READ A RECORD\n**********************************************************************\nREADLOOP EQU   *\n         GET   (R3)\n         LR    R5,R1               POINT TO RECORD\n         TM    RECFM(R3),X'C0'     RECFM U\n         BO    GETU\n         TM    RECFM(R3),X'80'     RECFM F\n         BO    GETF\nGETV     LA    R0,4\n         LH    R7,0(,R5)           LENGTH+4 FROM RDW\n         CLI   OPTR,0              IF R IN PARM\n         BNE   GOT                    INCLUDE RDW\n         AR    R5,R0               POINT PAST RDW\n         SR    R7,R0               REDUCE LENGTH\n         B     GOT\nGETU     LH    R7,LRECL(,R3)\n         B     GOT\nGETF     LH    R7,LRECL(,R3)       GET LENGTH FROM LRECL\n         TM    RECFM(R3),X'10'     IF NOT BLOCKED\n         BO    *+8                   THEN\n         LH    R7,BLKSI(,R3)         USE BLKSIZE AS LENGTH\n**********************************************************************\n*              CALL MD5 FOR EACH RECORD\n**********************************************************************\n*              CALL MD5 FOR EACH RECORD READ\nGOT      ST    R5,MD5ARGS          RECORD ADDRESS\n         ST    R7,ILEN             RECORD LENGTH\n         LA    R1,MD5ARGS\n         L     R15,=V(MD5)\n         CALL  (15)\n         B     READLOOP\n         SPACE\n**********************************************************************\n*              END-OF-FILE, CALL MD5 ONE LAST TIME\n**********************************************************************\nUT1EOD   EQU   *\n         SR    R0,R0               LENGTH ZERO FOR FINAL CALL\n         ST    R0,ILEN\n         LA    R1,MD5ARGS\n         L     R15,=V(MD5)\n         CALL  (15)\n**********************************************************************\n*              OUTPUT THE RESULTS\n**********************************************************************\n         MVI   OBUF,C' '\n         MVC   OBUF+1(255),OBUF\n*        MVC   ORDW(4),=AL2(36,0)\n         LA    R15,OBUF\n         TM    RECFM(R4),X'04'     IF ASA CARRIAGE CONTROL\n         BZ    NOTASA                THEN\n         LA    R15,1(,R15)           POINT PAST 1ST COLUMN\nNOTASA   EQU   *\n         MVC   0(32,R15),IRES08    COPY HEX RESULT\n*        TR    0(32,R15),LOWER     TRANSLATE TO LOWER CASE\n         LA    R1,32(,R15)         POINT R1 PAST LAST BYTE\n         CLI   OPTE,1              IF NO 'E' IN PARM, (SHOW DSN)\n         BNE   SETLEN                GO TO SETLEM\n         MVI   33(R15),C'*'        ELSE ADD *\n         MVC   34(44,R15),JFCB     AND DSN\n         LA    R1,34+43(,R15)      LAST CHAR OF DSNAME\n         LA    R0,44               INITIAL LENGTH\nFILEA    CLI   0(R1),C' '          IS THIS LAST NONBLANK\n         BNE   FILEB               YES, BRANCH\n         BCTR  R1,0                BACK UP 1 CHARACTER\n         BCT   R0,FILEA            DECREMENT LENGTH AND BRANCH\nFILEB    LA    R1,1(,R1)           POINT PAST LAST CHAR\n         CLI   JFCB+44,C' '        IF NO MEMBER IN JFCB\n         BE    SETLEN                GO TP SETLEM\n         MVI   0(R1),C'('\n         MVC   1(8,R1),JFCB+44     JFCBELNM IN IEFJFCBN\n         LA    R1,8(,R1)           LAST CHAR OF MEMBER NAME\n         LA    R0,8\nMEMA     CLI   0(R1),C' '\n         BNE   MEMB\n         BCTR  R1,0\n         BCT   R0,MEMA\nMEMB     MVI   1(R1),C')'\n         LA    R1,1(,R1)           POINT PAST LAST CHAR\nSETLEN   LA    R0,OBUF\n         SR    R1,R0               COMPUTE LENGTH\nNONAME   EQU   *\n         CLI   OPTL,1              IF 'L' IN PARM, FOR LOWERCASE\n         BNE   *+10                  THEN\n         TR    OBUF(256),LOWER       TRANSLATE TO LOWER CASE\n         LA    R0,OBUF             PUT WILL USE R0 AS RECORD ADDRESS\nPUTU     TM    RECFM(R4),X'C0'     IF OUTPUT RECFM U\n         BNO   PUTV\n         STH   R1,LRECL(,R4)       SET RECFM U RECORD SIZE\n         B     PUTT\nPUTV     TM    RECFM(R4),X'40'     IF RECFM V\n         BZ    PUTT                  THEN\n         LA    R1,4(,R1)             LENGTH + 4 FOR RDW\n         LH    R0,LRECL(,R4)         GET LRECL\n         CR    R1,R0                 IF LONGER THAN LRECL\n         BNH   *+6                     THEN\n         LR    R1,R0                   TRUNCATE TO LRECL\n         SLL   R1,16                 SHIFT LEFT 16 BITS\n         ST    R1,ORDW               SET RDW\n         LA    R0,ORDW               USE RDW FOR PUT\nPUTT     EQU   *\n         PUT   (R4),(0)\n         B     EXIT0\n         SPACE\nEXITN    CLI   RETCODE+3,12        IF AN ERROR OCCURRED\n         BNE   EXITC2                DON'T SET RC 0\nEXIT0    MVI   RETCODE+3,0\nEXITC2   MVC   CLOSEW(CLOSEMLL),CLOSEML\n         CLOSE ((R4)),MF=(E,CLOSEML)\n         LR    R7,R4\n         BAL   R2,FREEPOOL\nEXITC1   MVC   CLOSEW(CLOSEMLL),CLOSEML\n         CLOSE ((R3)),MF=(E,CLOSEW)\n         LR    R7,R3\n         BAL   R2,FREEPOOL\n         B     EXIT\nFREEPOOL FREEPOOL (R7)\n*        BR    R2\nEXIT     L     R2,RETCODE\n         LR    R1,R8\n         LA    R0,@DATA24L\n         FREEMAIN R,LV=(0),A=(1)\n         LR    R1,R13\n         L     R0,@SIZE\n         L     R13,4(,R13)\n         FREEMAIN R,LV=(0),A=(1)\n         DROP  R9\n         LR    R15,R2\n         LM    0,12,20(R13)\n         L     R14,12(,R13)\n         BR    R14\n         SPACE\n*         DCB OPEN EXIT\nUT2EXIT  CLI   RECFM(R1),0         IF NO RECFM\n         BNE   UT2EXI2                THEN\n         MVI   RECFM(R1),X'90'        USE FB\nUT2EXI2  TM    RECFM(R1),X'10'     IF BLOCKED\n         BZ    UT2EXI3                AND\n         CLC   LRECL(2,R1),=H'0'      NO LRECL\n         BNE   UT2EXI3                THEN\n         MVC   LRECL(2,R1),=H'80'     USE 80\nUT2EXI3  CLC   BLKSI(2,R1),=H'0'   IF NO BLKSIZE\n         BNE   UT2EXI4                THEN\n         MVC   BLKSI(2,R1),LRECL(R1)  USE LRECL\nUT2EXI4  BR    R14\n         SPACE\n         LTORG\n         DC    0D'0'\n         PRINT NOGEN\nUT1DCB   DCB   DDNAME=SYSUT1,DSORG=PS,MACRF=(GL),EODAD=UT1EOD\nUT1DCBL  EQU   *-UT1DCB\nUT2DCB   DCB   DDNAME=SYSUT2,DSORG=PS,MACRF=(PM),EXLST=0\nUT2DCBL  EQU   *-UT2DCB\nUT1EXL   DC    0F'0',X'87',AL3(0)\nUT2EXL   DC    0F'0',X'85',AL3(0)\nOPENML   OPEN  (0,),MF=L\nOPENMLL  EQU   *-OPENML\nCLOSEML  CLOSE (0,),MF=L\nCLOSEMLL EQU   *-CLOSEML\n         DC    0D'0'\nLOWER    DC    256AL1(*-LOWER)\n         ORG   LOWER+C'A'\n         DC    X'818283848586878889'\n         ORG   LOWER+C'J'\n         DC    X'919293949596979899'\n         ORG   LOWER+C'S'\n         DC    X'A2A3A4A5A6A7A8A9'\n         ORG\n         DC    0D'0'\n         SPACE\n@DATA    DSECT\n         DS    18F\nRETCODE  DS    F\nOPENW    DS    F\nCLOSEW   DS    F\nOPTE     DS    H\nOPTL     DS    H\nOPTR     DS    H\n@CLEARL  EQU   *-@DATA\nMD5ARGS  DS    5F\nILEN     DS    F\nICTX22   DS    0D,22F\nIRES08   DS    0D,8F\nIWRK44   DS    0D,44F\n         DS    0D\n@DATAL   EQU   *-@DATA\n         SPACE\n@DATA24  DSECT\nUT1DCBW  DS    0F,(UT1DCBL)X\nUT2DCBW  DS    0F,(UT2DCBL)X\nUT1EXLST DS    F\nUT2EXLST DS    F\nUT1RDJF  DS    F\nORDW     DS    F\nOBUF     DS    256C\n         DS    0D\nJFCB     DS    CL176\n         DS    0D\n@DATA24L EQU   *-@DATA24\n         SPACE\n*         EQUATES FOR DCB FIELD OFFSETS\nEXLST    EQU   36\nRECFM    EQU   36\nDDNAM    EQU   44\nOFLGS    EQU   48\nBLKSI    EQU   62\nLRECL    EQU   82\n         SPACE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MD5P24$": {"ttr": 3074, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00F\\x01 \\x14\\x1f\\x01 \\x14\\x1f\\x11Q\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-05-20T00:00:00", "modifydate": "2020-05-20T11:51:46", "lines": 27, "newlines": 27, "modlines": 0, "user": "UPDATED"}, "text": "//CBTUSER1 JOB (ACCT),'PGMRNAME',NOTIFY=CBTUSER,\n//         MSGLEVEL=(1,1),MSGCLASS=H\n//ASM     EXEC PGM=IFOX00,\n//             PARM=(LIST,OBJ,NODECK,NOXREF,RLD)\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(TRK,20)\n//SYSUT2   DD  UNIT=SYSDA,SPACE=(TRK,20)\n//SYSUT3   DD  UNIT=SYSDA,SPACE=(TRK,20)\n//SYSLIB   DD  DSN=CBTUSER.MVS38.MACLIB,DISP=SHR\n//SYSGO    DD  DSN=&&OBJ,DISP=(NEW,PASS),SPACE=(TRK,(3,3)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=800)\n//SYSIN    DD  DSN=CBTUSER.LIB.ASM(MD5P24),DISP=SHR\n//ASM2    EXEC PGM=IFOX00,\n//             PARM=(LIST,OBJ,NODECK,NOXREF,RLD),COND=(0,NE)\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(TRK,20)\n//SYSUT2   DD  UNIT=SYSDA,SPACE=(TRK,20)\n//SYSUT3   DD  UNIT=SYSDA,SPACE=(TRK,20)\n//SYSLIB   DD  DSN=CBTUSER.MVS38.MACLIB,DISP=SHR\n//SYSGO    DD  DSN=&&OBJ,DISP=(MOD,PASS)\n//SYSIN    DD  DSN=CBTUSER.LIB.ASM(MD5A),DISP=SHR\n//LKED   EXEC PGM=HEWLF064,PARM='MAP,NOXREF,RENT,REFR',\n//             COND=(0,NE)\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSNAME=&&OBJ,DISP=(OLD,DELETE)\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(TRK,(10,0))\n//SYSLMOD  DD  DSN=CBTUSER.LIB.LOAD(MD5P24),DISP=SHR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MD5P24B": {"ttr": 3076, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00F\\x01 \\x14\\x1f\\x01 \\x14\\x1f\\x11Q\\x00 \\x00 \\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-05-20T00:00:00", "modifydate": "2020-05-20T11:51:46", "lines": 32, "newlines": 32, "modlines": 0, "user": "UPDATED"}, "text": "//CBTUSER1 JOB (ACCT),'PGMRNAME',NOTIFY=CBTUSER,\n//         MSGLEVEL=(1,1),MSGCLASS=H\n//ASM     EXEC PGM=IFOX00,\n//             PARM=(LIST,OBJ,NODECK,NOXREF,RLD)\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(TRK,20)\n//SYSUT2   DD  UNIT=SYSDA,SPACE=(TRK,20)\n//SYSUT3   DD  UNIT=SYSDA,SPACE=(TRK,20)\n//SYSLIB   DD  DSN=CBTUSER.MVS38.MACLIB,DISP=SHR\n//SYSGO    DD  DSN=&&OBJ,DISP=(NEW,PASS),SPACE=(TRK,(3,3)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=800)\n//SYSIN    DD  DSN=CBTUSER.LIB.ASM(MD5P24),DISP=SHR\n//ASM2    EXEC PGM=IFOX00,\n//             PARM=(LIST,OBJ,NODECK,NOXREF,RLD),COND=(0,NE)\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(TRK,20)\n//SYSUT2   DD  UNIT=SYSDA,SPACE=(TRK,20)\n//SYSUT3   DD  UNIT=SYSDA,SPACE=(TRK,20)\n//SYSLIB   DD  DSN=CBTUSER.MVS38.MACLIB,DISP=SHR\n//SYSGO    DD  DSN=&&OBJ,DISP=(MOD,PASS)\n//SYSIN    DD  DSN=CBTUSER.LIB.ASM(MD5A),DISP=SHR\n//LKED   EXEC PGM=HEWLF064,PARM='MAP,NOXREF,RENT,REFR',\n//             COND=(0,NE)\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSNAME=&&OBJ,DISP=(OLD,PASS)\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(TRK,(10,0))\n//SYSLMOD  DD  DSN=CBTUSER.LIB.LOAD(MD5P24T),DISP=SHR\n//CPYOBJ EXEC PGM=IEBGENER,COND=(0,NE)\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  DSN=&&OBJ,DISP=(OLD,DELETE)\n//SYSUT2   DD  DSN=CBTUSER.OBJ.OBJ(MD5P24T),DISP=SHR\n//SYSIN    DD  DUMMY\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MD5R": {"ttr": 3078, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x131_\\x01\\x14\\x10o\\x11\\x11\\x01\\xf7\\x01\\xf8\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2013-11-11T00:00:00", "modifydate": "2014-04-16T11:11:00", "lines": 503, "newlines": 504, "modlines": 0, "user": "UPDATED"}, "text": "         TITLE 'MD5'\n         SPACE\n*        Subroutine to compute the MD5 sum of a string\n*\n*        This is a modification, for non-REXX callers, of\n*        Leland Lucius' public domain MD5 program for REXX\n*        at http://homerow.net/asm/md5/\n*\n*        CALL MD5(STRING,LENGTH,CONTEXT,RESULT,WORKSPACE)\n*\n*        LENGTH IS A FULLWORD CONTAINING THE LENGTH OF STRING.\n*\n*        CONTEXT IS 22 FULLWORDS WHICH SHOULD BE CLEARED TO BINARY\n*        ZEROES BEFORE THE FIRST CALL, AND LEFT UNCHANGED AFTER THAT,\n*        UNLESS AN ADDITIONAL MD5SUM IS TO BE COMPUTED FOR ANOTHER\n*        STRING, IN WHICH CASE IT SHOULD BE CLEARED AGAIN FOR THE\n*        FIRST CALL FOR THE OTHER STRING.\n*\n*        WORKSPACE IS 44 FULLWORDS AND ITS CONTENTS DO NOT NEED TO\n*        BE SET BY THE CALLER. IT IS USED AS A REGISTER SAVE ARE\n*        AMONG OTHER THINGS.\n*\n*        AT LEAST 2 CALLS WILL BE NEEDED - ONE OR MORE WITH\n*        A STRING AND ONE WITH THE STRING LENGTH SET TO ZERO.\n*        IF LENGTH IS 0, RESULT WILL CONTAIN A 32-BYTE STRING\n*        OF HEXADECIMAL DIGITS WHICH IS THE FINAL RESULT.\n*\n*        IF LENGTH IS NEGATIVE, ONLY ONE CALL IS NEEDED. IT IS THE\n*        EQUIVALENT OF ONE CALL WITH A POSITIVE LENGTH AND\n*        ANOTHER WITH A ZERO LENGTH. THE NEGATIVE LENGTH IS\n*        ZERO MINUS THE STRING LENGTH. THE CONTEXT IN THIS CASE\n*        DOES NOT NEED TO BE CLEARED TO ZEROES.\n*\n* ---------------------------------------------------------------------\n* Swap bytes to convert to little endian\n* ---------------------------------------------------------------------\n         MACRO\n&LAB     SWAP     &PTR,&WORDS\n&LAB     LA       R15,&WORDS/2\n         LA       R14,&PTR\n$&SYSNDX LM       R0,R1,0(R14)\n.*                MODIFIED 12/6/2013 TO USE STRV INSTEAD OF STCM\n         STRV     R0,0(,R14)\n         STRV     R1,4(,R14)\n         AGO      .LA\n         STCM     R0,B'0001',0(R14)\n         STCM     R0,B'0010',1(R14)\n         STCM     R0,B'0100',2(R14)\n         STCM     R0,B'1000',3(R14)\n         STCM     R1,B'0001',4(R14)\n         STCM     R1,B'0010',5(R14)\n         STCM     R1,B'0100',6(R14)\n         STCM     R1,B'1000',7(R14)\n.LA      LA       R14,8(R14)\n         BCT      R15,$&SYSNDX\n         MEND\nMD5      CSECT\nMD5      AMODE ANY31\nMD5      RMODE 31\n         USING *,R12\n         B     BEGIN-*(,R15)\n         DC    AL1(7),CL7'MD5'\n*        DC    CL16' &SYSDATE &SYSTIME '\n         DC    CL16' 11/11/13 01:00 '\nWORKSIZ  DC    0F'0',AL1(0),AL3(WORKLEN)\nBEGIN    STM   14,12,12(13)\n         LR    R12,R15\n         LR    R2,R1               POINT TO ARGS PASSED\n         L     R7,16(,R2)          POINT TO WORKSPACE\n*        L     R0,WORKSIZ\n*        GETMAIN R,LV=(0)\n*        LR    R7,R1\n         USING WORKD,R7\n         XC    0(WORKINI,R7),0(R7)\n         ST    R13,4(,R7)          OLD ADDRESS IN NEW SAVE AREA\n         ST    R7,8(,R13)          NEW ADDRESS IN OLD SAVE AREA\n         LR    R13,R7\n         MVC   ARGLIST(16),0(R2)\n         SPACE\n         L     R15,ARGLIST+4       POINT TO LENGTH\n         L     R15,0(,R15)         GET LENGTH\n         LTR   R15,R15             IF LENGTH IS NEGATIVE\n         BM    INCTX                  SET INITIAL CONTEXT\n         L     R1,ARGLIST+8        POINT TO CONTEXT\n         NC    0(88,R1),0(R1)      TEST FOR INITIAL CONTEXT ALL ZEROES\n         BNZ   CPCTX\nINCTX    MVC   M5BUF(16),INITBUF   SET INITIAL VALUE OF M5BUF\n         B     OKCTX\nCPCTX    MVC   M5BUF(88),0(R1)     COPY SAVED CONTEXT\nOKCTX    EQU   *\n         SPACE\n         LM    R8,R9,ARGLIST       GET STRING ADDRESS AND LENGTH ADDR\n         L     R9,0(,R9)           GET LENGTH\n         LTR   R9,R9\n         BZ    FINAL\n         BM    BOTH\n         BAL   R11,HASH\n         B     DONE\nBOTH     LCR   R9,R9\n         BAL   R11,HASH\nFINAL    BAL   R11,TERM\n         SPACE\n         LA    R1,M5BUF            TOHEX SOURCE\n         LA    R0,4                TOHEX SOURCE LENGTH IN WORDS\n         L     R15,ARGLIST+12      POINT TO CALLER'S RESULT AREA\n         BAL   R14,TOHEX\nDONE     L     R1,ARGLIST+8        POINT TO CONTEXT\n         MVC   0(88,R1),M5BUF      SAVE CONTEXT IN CALLER'S ARG\n         B     EXIT0\n         SPACE\nTOHEX    MVC   0(4,R15),0(R1)\n         UNPK  M5IN(9),0(5,R15)\n         MVC   0(8,R15),M5IN\n         TR    0(8,R15),HEXTAB-240\n         LA    R15,8(,R15)\n         LA    R1,4(,R1)\n         BCT   R0,TOHEX\n         BR    R14\n         SPACE\n* =====================================================================\n* MD5Hash\n*\n* Update context to reflect the concatenation of another buffer full\n* of bytes.\n*\n* (Even though they are destroyed in MD5Trans, it is okay to use R2\n* and R3 here since they are reset after each call to MD5Trans.)\n*\n* =====================================================================\n* ---------------------------------------------------------------------\n* Update byte count\n* ---------------------------------------------------------------------\nHASH     L        R1,M5BYTES+(1*4)            RS = Bytes\u00dd 1 \u00a8\n         LR       R14,R1                      T1 = RS\n         ALR      R14,R9                      T1 += Len\n         BC       12,L10                      Overflow? No, branch\n* ---------------------------------------------------------------------\n* Carry from low to high\n* ---------------------------------------------------------------------\n         L        R15,M5BYTES+(0*4)           T2 = Bytes\u00dd 0 \u00a8\n         AL       R15,=F'1'                   T2++\n         ST       R15,M5BYTES+(0*4)           Bytes\u00dd 0 \u00a8 = T2\nL10      ST       R14,M5BYTES+(1*4)           Bytes\u00dd 1 \u00a8 = T1\n* ---------------------------------------------------------------------\n* Space available in ctx->in (at least 1)\n* ---------------------------------------------------------------------\n         LA       R10,64                      Cache\n         N        R1,=A(X'3F')                RS &= 0x3f (mod 64)\n         LR       R3,R10                      T = 64\n         SLR      R3,R1                       T -= RS\n         LR       R1,R10                      RS = 64\n         SLR      R1,R3                       RS -= T\n         LA       R1,M5IN(R1)                 RS = &In\u00dd RS \u00a8\n* ---------------------------------------------------------------------\n* Enough input to fill ctx->in?\n* ---------------------------------------------------------------------\n         CLR      R3,R9                       T > Len?\n         BH       L40                         Yes, not enough to fill\n* ---------------------------------------------------------------------\n* First chunk is an odd size\n* ---------------------------------------------------------------------\n         LR       R14,R3                      T1 = T\n         BCTR     R14,0                       T1-- (for execute)\n         EX       R14,MEMCPY                  do MEMCPY for T bytes\n* ---------------------------------------------------------------------\n* Adjust buffer and len\n* ---------------------------------------------------------------------\n         ALR      R8,R3                       Buf += T\n         SLR      R9,R3                       Len -= T\n* ---------------------------------------------------------------------\n* Convert to little endian\n* ---------------------------------------------------------------------\n         SWAP     M5IN,16                     byteSwap( In, 16 )\n* ---------------------------------------------------------------------\n* Add in the padding bytes\n* ---------------------------------------------------------------------\n         BAL      R6,MD5TRANS                 MD5Trans( Buf, In )\n* ---------------------------------------------------------------------\n* Process data in 64-byte chunks\n* ---------------------------------------------------------------------\nL20      CLR      R9,R10                      Len >= 64?\n         BL       L30                         No, don't have a block\n         MVC      M5IN(64),0(R8)              memcpy( In, Buf, 64 )\n* ---------------------------------------------------------------------\n* Adjust buffer and len\n* ---------------------------------------------------------------------\n         ALR      R8,R10                      Buf += 64\n         SLR      R9,R10                      Len -= 64\n* ---------------------------------------------------------------------\n* Convert to little endian\n* ---------------------------------------------------------------------\n         SWAP     M5IN,16                     byteSwap( In, 16 )\n* ---------------------------------------------------------------------\n* Add in 64 more bytes\n* ---------------------------------------------------------------------\n         BAL      R6,MD5TRANS                 MD5Trans( Buf, In )\n         B        L20                         Continue loop\n* ---------------------------------------------------------------------\n* Handle any remaining bytes of data.\n* ---------------------------------------------------------------------\nL30      LA       R1,M5IN                     RS = &In\u00dd 0 \u00a8\nL40      LTR      R9,R9                       Len == 0?\n         BZ       PUTCTX                      Yes, nothing to do\n         BCTR     R9,0                        Len-- (for execute)\n         EX       R9,MEMCPY                   do MEMCPY for Len bytes\n* ---------------------------------------------------------------------\n* Store the updated context variable\n* ---------------------------------------------------------------------\nPUTCTX   EQU      *\n         BR       R11\n         SPACE\n* =====================================================================\n* MD5Term\n*\n* Final wrapup...pad to 64-byte boundary with the bit pattern:\n*     1 0* (64-bit count of bits processed, MSB-first)\n*\n* (Even though they are destroyed in MD5Trans, it is okay to use R2\n* and R3 here since they are reset after each call to MD5Trans.)\n*\n* =====================================================================\n* ---------------------------------------------------------------------\n* Get number of bytes mod 64\n* ---------------------------------------------------------------------\nTERM     L        R3,M5BYTES+(1*4)            Cnt = Bytes\u00dd 1 \u00a8\n         N        R3,=A(X'3F')                Cnt &= 0x3f\n* ---------------------------------------------------------------------\n* Set ptr to start of padding\n* ---------------------------------------------------------------------\n         LA       R2,M5IN(R3)                 Ptr = &In\u00dd Cnt \u00a8\n* ---------------------------------------------------------------------\n* Set the first byte of padding to 0x80.  There is always room.\n* ---------------------------------------------------------------------\n         MVI      0(R2),X'80'                 *Ptr = x'80'\n         LA       R2,1(R2)                    Ptr++\n* ---------------------------------------------------------------------\n* Bytes of padding needed to make 56 bytes (-8..55)\n* ---------------------------------------------------------------------\n         LA       R1,56-1                     RS = 56 - 1\n         SLR      R1,R3                       RS -= Cnt\n* ---------------------------------------------------------------------\n* Padding forces an extra block\n* ---------------------------------------------------------------------\n         LTR      R3,R1                       ( Cnt = RS ) == 0\n         BZ       L60                         =0, no need to clear\n         BNL      L50                         >0, no extra block\n* ---------------------------------------------------------------------\n* Clear the remaining bytes\n* ---------------------------------------------------------------------\n         LA       R3,(8-1)(R3)                Cnt += 8 (-1 for execute)\n         EX       R3,MEMSET                   do MEMSET for Cnt bytes\n* ---------------------------------------------------------------------\n* Convert to little endian\n* ---------------------------------------------------------------------\n         SWAP     M5IN,16                     byteSwap( In, 16 )\n* ---------------------------------------------------------------------\n* Add in the padding bytes\n* ---------------------------------------------------------------------\n         BAL      R6,MD5TRANS                 MD5Trans( Buf, In )\n         LA       R2,M5IN                     Ptr = &In\u00dd 0 \u00a8\n         LA       R3,(15*4)                   Cnt = 56\n* ---------------------------------------------------------------------\n* Clear padding bytes\n* ---------------------------------------------------------------------\nL50      BCTR     R3,0                        Cnt-- (for execute)\n         EX       R3,MEMSET                   do MEMSET for Cnt bytes\n* ---------------------------------------------------------------------\n* Convert to little endian\n* ---------------------------------------------------------------------\nL60      SWAP     M5IN,14                     byteSwap( In, 14 )\n* ---------------------------------------------------------------------\n* Append length in bits and transform\n* ---------------------------------------------------------------------\n         LM       R14,R15,M5BYTES+(0*4)       Get longlong byte count\n         SLDL     R14,3                       Calc number of bits\n         ST       R15,M5IN+(14*4)             Little...\n         ST       R14,M5IN+(15*4)             ...endian\n         BAL      R6,MD5TRANS                 MD5Trans( Buf, In )\n* ---------------------------------------------------------------------\n* Convert to little endian\n* ---------------------------------------------------------------------\n         SWAP     M5BUF,4                     byteSwap( Buf, 4 )\n* ---------------------------------------------------------------------\n* Final transform is the digest\n* ---------------------------------------------------------------------\n         BR       R11\n* =====================================================================\n* MD5Trans\n*\n* The core of the MD5 algorithm, this alters an existing MD5 hash to\n* reflect the addition of 16 longwords of new data.  MD5Update blocks\n* the data and converts bytes into longwords for this routine.\n*\n* =====================================================================\nRS       EQU      R1\nA        EQU      R2  <--------------------\\\nB        EQU      R3                        \u00a6 Must be sequential since\nC        EQU      R4                        \u00a6 we use LM/STM opcodes\nD        EQU      R5  <--------------------/\nT1       EQU      R14\nT2       EQU      R15\n* ---------------------------------------------------------------------\n*        F1(x, y, z) \\\n*           (z \u00ac (x & (y \u00ac z)))\n* ---------------------------------------------------------------------\n         MACRO\n         F1       &X,&Y,&Z\n.*\n         LR       T1,&Y                       T1 = y\n         XR       T1,&Z                       T1 \u00ac= z\n         LR       T2,&X                       T2 = x\n         NR       T2,T1                       T2 &= T1\n         LR       RS,&Z                       RS = z\n         XR       RS,T2                       RS \u00ac= T2\n.*\n         MEND\n* ---------------------------------------------------------------------\n*        F2(x, y, z) \\\n*            F1(z, x, y)\n* ---------------------------------------------------------------------\n         MACRO\n         F2       &X,&Y,&Z\n.*\n         F1       &Z,&X,&Y                    RS = F1(z,x,y)\n.*\n         MEND\n* ---------------------------------------------------------------------\n*        F3(x, y, z) \\\n*            (x \u00ac y \u00ac z)\n* ---------------------------------------------------------------------\n         MACRO\n         F3       &X,&Y,&Z\n.*\n         LR       RS,&X                       RS = x\n         XR       RS,&Y                       RS \u00ac= y\n         XR       RS,&Z                       RS \u00ac= z\n.*\n         MEND\n* ---------------------------------------------------------------------\n*        F4(x, y, z) \\\n*            (y \u00ac (x \u00a6 ~z))\n* ---------------------------------------------------------------------\n         MACRO\n         F4       &X,&Y,&Z\n.*\n         LR       T1,&Z                       T1 = z\n         X        T1,=A(X'FFFFFFFF')          T1 \u00ac= -1\n         LR       T2,&X                       T2 = x\n         OR       T2,T1                       T2 \u00a6= T2\n         LR       RS,&Y                       RS = y\n         XR       RS,T2                       RS \u00ac= T2\n.*\n         MEND\n* ---------------------------------------------------------------------\n*        MD5STEP(f,w,x,y,z,in,ac,s) \\\n*            (w += f(x,y,z) + in + ac, w = (w<<s \u00a6 w>>(32-s)) + x)\n* ---------------------------------------------------------------------\n         MACRO\n         MD5STEP  &F,&W,&X,&Y,&Z,&IN,&AC,&S\n.*\n         &F       &X,&Y,&Z                    RS = f(x,y,z)\n         AL       RS,M5IN+(&IN*4)             RS += In\u00dd in \u00a8\n         AL       RS,=A(x'&AC')               RS += ac\n         ALR      &W,RS                       w += RS\n         LR       T1,&W                       T1 = w\n         SLL      &W,&S                       w << s\n         SRL      T1,32-&S                    T1 >> (32-s)\n         OR       &W,T1                       w \u00a6= T1\n         ALR      &W,&X                       w += x\n.*\n         MEND\nMD5TRANS LM       A,D,M5BUF\n* ---------------------------------------------------------------------\n* Round 1\n* ---------------------------------------------------------------------\n         MD5STEP  F1,A,B,C,D,00,D76AA478,07\n         MD5STEP  F1,D,A,B,C,01,E8C7B756,12\n         MD5STEP  F1,C,D,A,B,02,242070DB,17\n         MD5STEP  F1,B,C,D,A,03,C1BDCEEE,22\n         MD5STEP  F1,A,B,C,D,04,F57C0FAF,07\n         MD5STEP  F1,D,A,B,C,05,4787C62A,12\n         MD5STEP  F1,C,D,A,B,06,A8304613,17\n         MD5STEP  F1,B,C,D,A,07,FD469501,22\n         MD5STEP  F1,A,B,C,D,08,698098D8,07\n         MD5STEP  F1,D,A,B,C,09,8B44F7AF,12\n         MD5STEP  F1,C,D,A,B,10,FFFF5BB1,17\n         MD5STEP  F1,B,C,D,A,11,895CD7BE,22\n         MD5STEP  F1,A,B,C,D,12,6B901122,07\n         MD5STEP  F1,D,A,B,C,13,FD987193,12\n         MD5STEP  F1,C,D,A,B,14,A679438E,17\n         MD5STEP  F1,B,C,D,A,15,49B40821,22\n* ---------------------------------------------------------------------\n* Round 2\n* ---------------------------------------------------------------------\n         MD5STEP  F2,A,B,C,D,01,F61E2562,05\n         MD5STEP  F2,D,A,B,C,06,C040B340,09\n         MD5STEP  F2,C,D,A,B,11,265E5A51,14\n         MD5STEP  F2,B,C,D,A,00,E9B6C7AA,20\n         MD5STEP  F2,A,B,C,D,05,D62F105D,05\n         MD5STEP  F2,D,A,B,C,10,02441453,09\n         MD5STEP  F2,C,D,A,B,15,D8A1E681,14\n         MD5STEP  F2,B,C,D,A,04,E7D3FBC8,20\n         MD5STEP  F2,A,B,C,D,09,21E1CDE6,05\n         MD5STEP  F2,D,A,B,C,14,C33707D6,09\n         MD5STEP  F2,C,D,A,B,03,F4D50D87,14\n         MD5STEP  F2,B,C,D,A,08,455A14ED,20\n         MD5STEP  F2,A,B,C,D,13,A9E3E905,05\n         MD5STEP  F2,D,A,B,C,02,FCEFA3F8,09\n         MD5STEP  F2,C,D,A,B,07,676F02D9,14\n         MD5STEP  F2,B,C,D,A,12,8D2A4C8A,20\n* ---------------------------------------------------------------------\n* Round 3\n* ---------------------------------------------------------------------\n         MD5STEP  F3,A,B,C,D,05,FFFA3942,04\n         MD5STEP  F3,D,A,B,C,08,8771F681,11\n         MD5STEP  F3,C,D,A,B,11,6D9D6122,16\n         MD5STEP  F3,B,C,D,A,14,FDE5380C,23\n         MD5STEP  F3,A,B,C,D,01,A4BEEA44,04\n         MD5STEP  F3,D,A,B,C,04,4BDECFA9,11\n         MD5STEP  F3,C,D,A,B,07,F6BB4B60,16\n         MD5STEP  F3,B,C,D,A,10,BEBFBC70,23\n         MD5STEP  F3,A,B,C,D,13,289B7EC6,04\n         MD5STEP  F3,D,A,B,C,00,EAA127FA,11\n         MD5STEP  F3,C,D,A,B,03,D4EF3085,16\n         MD5STEP  F3,B,C,D,A,06,04881D05,23\n         MD5STEP  F3,A,B,C,D,09,D9D4D039,04\n         MD5STEP  F3,D,A,B,C,12,E6DB99E5,11\n         MD5STEP  F3,C,D,A,B,15,1FA27CF8,16\n         MD5STEP  F3,B,C,D,A,02,C4AC5665,23\n* ---------------------------------------------------------------------\n* Round 4\n* ---------------------------------------------------------------------\n         MD5STEP  F4,A,B,C,D,00,F4292244,06\n         MD5STEP  F4,D,A,B,C,07,432AFF97,10\n         MD5STEP  F4,C,D,A,B,14,AB9423A7,15\n         MD5STEP  F4,B,C,D,A,05,FC93A039,21\n         MD5STEP  F4,A,B,C,D,12,655B59C3,06\n         MD5STEP  F4,D,A,B,C,03,8F0CCC92,10\n         MD5STEP  F4,C,D,A,B,10,FFEFF47D,15\n         MD5STEP  F4,B,C,D,A,01,85845DD1,21\n         MD5STEP  F4,A,B,C,D,08,6FA87E4F,06\n         MD5STEP  F4,D,A,B,C,15,FE2CE6E0,10\n         MD5STEP  F4,C,D,A,B,06,A3014314,15\n         MD5STEP  F4,B,C,D,A,13,4E0811A1,21\n         MD5STEP  F4,A,B,C,D,04,F7537E82,06\n         MD5STEP  F4,D,A,B,C,11,BD3AF235,10\n         MD5STEP  F4,C,D,A,B,02,2AD7D2BB,15\n         MD5STEP  F4,B,C,D,A,09,EB86D391,21\n* ---------------------------------------------------------------------\n* Add back into state and return\n* ---------------------------------------------------------------------\n         AL       A,M5BUF+(0*4)\n         AL       B,M5BUF+(1*4)\n         AL       C,M5BUF+(2*4)\n         AL       D,M5BUF+(3*4)\n         STM      A,D,M5BUF\n         BR       R6\n         SPACE\nMEMCPY   MVC      0(0,R1),0(R8)               memcpy( RS, Buf, Len )\nMEMSET   XC       0(0,R2),0(R2)               Ptr\u00dd...\u00a8 \u00ac= Ptr\u00dd...\u00a8\n         SPACE\nEXIT0    SR    R2,R2              RETURN CODE 0\n*        LR    R1,R13             POINT TO ADDRESS TO FREEMAIN\n*        L     R0,WORKSIZ         LENGTH TO FREEMAIN\n         L     R13,4(,R13)        RESTORE ORIGINAL R13\n*        FREEMAIN R,A=(1),LV=(0)\n         DROP  R7\n         LR    R15,R2\n         LM    0,12,20(R13)\n         L     R14,12(,R13)\n         BR    R14\n         SPACE\n         LTORG\n         DC    0D'0'\nINITBUF  DC    X'67452301,EFCDAB89,98BADCFE,10325476'\nHEXTAB   DC    C'0123456789ABCDEF'\nWORKD    DSECT\n         DS    18F\nARGLIST  DS    4F\nM5BUF    DS    4F\nM5BYTES  DS    2F\nM5IN     DS    16F\nWORKINI  EQU   *-WORKD\n         DS    0D\nWORKLEN  EQU   *-WORKD\n         SPACE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MD5REXX": {"ttr": 3329, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x04\\x07\\x8f\\x01\\x04\\x07\\x8f\\x12\\x14\\x03E\\x03E\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-03-18T00:00:00", "modifydate": "2004-03-18T12:14:00", "lines": 837, "newlines": 837, "modlines": 0, "user": "UPDATED"}, "text": "//* from http://homerow.net/cgi-bin/dl?md5-04.078.tar.gz\n//*\n//* -------------------------------------------------------------------\n//* Assemble\n//* -------------------------------------------------------------------\n//*\n//ASM      EXEC  PGM=ASMA90,\n//             PARM='NODECK,OBJECT,XREF(SHORT),RENT'\n//SYSLIB   DD  DSN=SYS1.MACLIB,\n//             DISP=SHR\n//SYSUT1   DD  SPACE=(CYL,1),\n//             UNIT=SYSDA\n//SYSPUNCH DD  DUMMY\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DISP=(,PASS),\n//             SPACE=(CYL,1),\n//             UNIT=SYSDA\n//SYSIN    DD  *\n*\u00a6 ====================================================================\n*\u00a6 Function : MD5 Message-Digest REXX function.\n*\u00a6\n*\u00a6 Rent     : Yes (SHOULD be placed in LPA if used frequently)\n*\u00a6\n*\u00a6 Amode    : Must run in 31-bit addressing mode\n*\u00a6\n*\u00a6 Rmode    : Above or below...\n*\u00a6\n*\u00a6 Return   : If no errors are encountered, the return value depends\n*\u00a6            on the parameters passed.  (See below)\n*\u00a6\n*\u00a6            In the event of an error, a SYNTAX condition is forced\n*\u00a6            and one of the following values will be placed in the\n*\u00a6            MD5RC return code variable.\n*\u00a6\n*\u00a6                    1 = No arguments specified\n*\u00a6                    2 = Failed to retrieve the CTX variable\n*\u00a6                    3 = CTX variable is invalid\n*\u00a6                    4 = Too many arguments\n*\u00a6                    5 = Failed to store the CTX variable\n*\u00a6                    6 = Failed to drop the CTX variable\n*\u00a6\n*\u00a6 Descript : This external REXX function implements the MD5 Message\n*\u00a6            Digest algorithm as documented in RFC1321.\n*\u00a6\n*\u00a6            This implementation is based on public domain source\n*\u00a6            code from the Debian project.\n*\u00a6\n*\u00a6 Usage    :                ---- Multi-Shot ----\n*\u00a6\n*\u00a6            Use this method when you need to pass multiple data items\n*\u00a6            before generating the final digest.  Simply call this\n*\u00a6            function with both arguments until you've processed all\n*\u00a6            the data.  Then, make one more call while leaving off\n*\u00a6            the data argument to get the digest.\n*\u00a6\n*\u00a6            CALL Md5( \"Ctx\", Data )\n*\u00a6            Digest = Md5( \"Ctx\" )\n*\u00a6\n*\u00a6            \"Ctx\"\n*\u00a6                This is the name (NOT value) of a variable where the\n*\u00a6                MD5 context is maintained.\n*\u00a6\n*\u00a6            Data\n*\u00a6                The data that you wish to digest.\n*\u00a6\n*\u00a6            Digest\n*\u00a6                The 16-byte digest.\n*\u00a6\n*\u00a6 Example  :\n*\u00a6\n*\u00a6            Data   = \"Something to digest\"\n*\u00a6            More   = \" and even more.\"\n*\u00a6            CALL Md5( \"Ctx\", Data )\n*\u00a6            CALL Md5( \"Ctx\", More )\n*\u00a6            Digest = Md5( \"Ctx\" )\n*\u00a6\n*\u00a6            SAY \"The MD5 digest for '\" \u00a6\u00a6 Data \u00a6\u00a6 More \u00a6\u00a6 \"' is:\"\n*\u00a6            SAY C2x( Digest )\n*\u00a6\n*\u00a6 Usage    :                 ---- One-Shot ----\n*\u00a6\n*\u00a6            Use this method when all you need to process is one data\n*\u00a6            item before generating the digest.  Just leave off the\n*\u00a6            first argument (or specify a null value) and specify the\n*\u00a6            second argument.\n*\u00a6\n*\u00a6            Digest = Md5( , Data )\n*\u00a6                         or\n*\u00a6            Digest = Md5( \"\", Data )\n*\u00a6\n*\u00a6            Data\n*\u00a6                The data that you with to digest.\n*\u00a6\n*\u00a6            Digest\n*\u00a6                The 16-byte digest.\n*\u00a6\n*\u00a6 Example  :\n*\u00a6\n*\u00a6            Data   = \"Something to digest\"\n*\u00a6            More   = \" and even more.\"\n*\u00a6            Digest = Md5( \"\", Data \u00a6\u00a6 More )\n*\u00a6\n*\u00a6            SAY \"The MD5 digest for '\" \u00a6\u00a6 Data \u00a6\u00a6 More \u00a6\u00a6 \"' is:\"\n*\u00a6            SAY C2x( Digest )\n*\u00a6\n*\u00a6 Author   : Leland Lucius <rexxfunc@homerow.net>\n*\u00a6\n*\u00a6 License  : This routine is released under terms of the Q Public\n*\u00a6            License.  Please refer to the LICENSE file for more\n*\u00a6            information.  Or for the latest license text go to:\n*\u00a6\n*\u00a6            http://www.trolltech.com/developer/licensing/qpl.html\n*\u00a6\n*\u00a6 Changes  : 2002/08/09 - LLL - Initial version\n*\u00a6            2004/03/18 - LLL - Placed into the Public Domain\n*\u00a6\n*\u00a6 ====================================================================\n* ---------------------------------------------------------------------\n* Swap bytes to convert to little endian\n* ---------------------------------------------------------------------\n         MACRO\n&LAB     SWAP     &PTR,&WORDS\n&LAB     LA       R15,&WORDS/2\n         LA       R14,&PTR\n$&SYSNDX LM       R0,R1,0(R14)\n         STCM     R0,B'0001',0(R14)\n         STCM     R0,B'0010',1(R14)\n         STCM     R0,B'0100',2(R14)\n         STCM     R0,B'1000',3(R14)\n         STCM     R1,B'0001',4(R14)\n         STCM     R1,B'0010',5(R14)\n         STCM     R1,B'0100',6(R14)\n         STCM     R1,B'1000',7(R14)\n         LA       R14,8(R14)\n         BCT      R15,$&SYSNDX\n         MEND\nMD5      CSECT                                Section\nMD5      AMODE    31                          Must be 31\nMD5      RMODE    ANY                         Could be 24, but why?\n* ---------------------------------------------------------------------\n* Setup base registers and addressability\n* ---------------------------------------------------------------------\n         SAVE     (14,12),,*                  Save caller's registers\n         LR       R12,R15                     Get base\n         USING    MD5,R12                     Map CSECT\n         LR       R9,R0                       Save ENVB ptr\n         LR       R10,R1                      Save EFPL ptr\n         USING    EFPL,R10                    Map EFPL\n* ---------------------------------------------------------------------\n* Grab some work area storage and map\n* ---------------------------------------------------------------------\n         STORAGE  OBTAIN,LENGTH=WORKLEN       Get storage\n         ST       R13,4(,R1)                  Save callers savearea\n         ST       R1,8(,R13)                  Store ours in callers\n         LR       R13,R1                      Establish ours\n         USING    WORKAREA,R13                Map WORK\n* ---------------------------------------------------------------------\n* Grab variable access routine ptr\n* ---------------------------------------------------------------------\n         ST       R9,ENVBA                    Save ENVB\n         USING    ENVBLOCK,R9                 Map ENVB\n         L        R1,ENVBLOCK_IRXEXTE         Get ptr to EXTE\n         USING    IRXEXTE,R1                  Map EXTE\n         L        R15,IRXEXCOM                Get ptr to EXCOM\n         ST       R15,EXCOMA                  Save it\n         DROP     R1                          Done with EXTE\n         DROP     R9                          Done with ENVB\n* ---------------------------------------------------------------------\n* Get addressability to EVALBLOCK\n* ---------------------------------------------------------------------\n         L        R11,EFPLEVAL                Get ptr to eval addr\n         L        R11,0(R11)                  Get EVAL addr\n         USING    EVALBLOCK,R11               Map EVAL\n         MVC      EVALBLOCK_EVLEN,=F'0'       Pre-init to null\n* ---------------------------------------------------------------------\n* Address and map the arguments\n* ---------------------------------------------------------------------\n         L        R2,EFPLARG                  Get ptr to arguments\n         USING    ARGTABLE_ENTRY,R2           Map ARGTABLE\n         DROP     R10                         Done with EFPL\n* ---------------------------------------------------------------------\n* Error if there are no arguments\n* ---------------------------------------------------------------------\n         CLC      ARGTABLE_END,ARGTABLE_ENTRY Last argument?\n         BE       ERR1                        Yes, need at least 1\n* ---------------------------------------------------------------------\n* Have a context variable name?\n* ---------------------------------------------------------------------\n         LM       R7,R8,ARGTABLE_ARGSTRING_PTR Get ptr and length\n         STM      R7,R8,CTXNAMEA              Save ptr and length\n         LTR      R8,R8                       Null or missing?\n         BZ       INIT                        Yes, must be one-shot\n* ---------------------------------------------------------------------\n* Retrieve the context variable\n* ---------------------------------------------------------------------\n         LA       R4,VREQ                     Get request ptr\n         XC       VREQ,VREQ                   Clear request block\n         USING    SHVBLOCK,R4                 Map SHVB\n* ---------------------------------------------------------------------\n* Initialize request block\n* ---------------------------------------------------------------------\n         MVI      SHVCODE,SHVSYFET            Function code\n         LA       R6,M5LEN                    Get buffer len\n         LA       R9,M5CTX                    Buffer ptr\n         STM      R6,R9,SHVBUFL               Store the lot\n* ---------------------------------------------------------------------\n* Retrieve the value\n* ---------------------------------------------------------------------\n         L        R15,EXCOMA                  Get IRXEXCOM addr\n         CALL     (15),(=C'IRXEXCOM',0,0,VREQ,ENVBA),VL,MF=(E,PLIST)\n* ---------------------------------------------------------------------\n* Good result?\n* ---------------------------------------------------------------------\n         CLI      SHVRET,SHVCLEAN             Execution OK?\n         BE       CHKID                       Yes, go check id\n         CLI      SHVRET,SHVNEWV              Execution OK?\n         BNE      ERR2                        No, error\n* =====================================================================\n* MD5Init\n* =====================================================================\n* ---------------------------------------------------------------------\n* Either a one-shot run or the first time using this CTX...\n* ---------------------------------------------------------------------\nINIT     XC       M5CTX(M5LEN),M5CTX          Clear context\n         MVC      M5CTX(5*4),INITCTX          Initialize context\n         B        GETDATA                     Go check data arg\n* ---------------------------------------------------------------------\n* Validate CTX\n* ---------------------------------------------------------------------\nCHKID    CLC      SHVVALL,=A(M5LEN)           Possibly one of ours?\n         BNE      ERR3                        No, error\n         CLC      M5CTX,INITCTX               One of ours?\n         BNE      ERR3                        No, error\n         DROP     R4                          No longer needed\n* ---------------------------------------------------------------------\n* Bump to next argument and verify it's there\n* ---------------------------------------------------------------------\nGETDATA  LA       R2,ARGTABLE_NEXT            Gen ptr to next arg\n         CLC      ARGTABLE_END,ARGTABLE_ENTRY Last argument?\n         BE       TERM                        Yes, return digest\n* ---------------------------------------------------------------------\n* Cache and validate \"DATA\" argument pointer and length\n* ---------------------------------------------------------------------\n         LM       R8,R9,ARGTABLE_ARGSTRING_PTR Get ptr and length\n         LTR      R8,R8                       Missing?\n         BZ       TERM                        Yes, get existing CTX\n* ---------------------------------------------------------------------\n* Don't need anymore arguments\n* ---------------------------------------------------------------------\n         LA       R2,ARGTABLE_NEXT            Gen ptr to next arg\n         CLC      ARGTABLE_END,ARGTABLE_ENTRY Last argument?\n         BNE      ERR4                        No, don't need anymore\n         DROP     R2                          Done with ARGTABLE\n* =====================================================================\n* MD5Hash\n*\n* Update context to reflect the concatenation of another buffer full\n* of bytes.\n*\n* (Even though they are destroyed in MD5Trans, it is okay to use R2\n* and R3 here since they are reset after each call to MD5Trans.)\n*\n* =====================================================================\n* ---------------------------------------------------------------------\n* Update byte count\n* ---------------------------------------------------------------------\nHASH     L        R1,M5BYTES+(1*4)            RS = Bytes\u00dd 1 \u00a8\n         LR       R14,R1                      T1 = RS\n         ALR      R14,R9                      T1 += Len\n         BC       12,L10                      Overflow? No, branch\n* ---------------------------------------------------------------------\n* Carry from low to high\n* ---------------------------------------------------------------------\n         L        R15,M5BYTES+(0*4)           T2 = Bytes\u00dd 0 \u00a8\n         AL       R15,=F'1'                   T2++\n         ST       R15,M5BYTES+(0*4)           Bytes\u00dd 0 \u00a8 = T2\nL10      ST       R14,M5BYTES+(1*4)           Bytes\u00dd 1 \u00a8 = T1\n* ---------------------------------------------------------------------\n* Space available in ctx->in (at least 1)\n* ---------------------------------------------------------------------\n         LA       R10,64                      Cache\n         N        R1,=A(X'3F')                RS &= 0x3f (mod 64)\n         LR       R3,R10                      T = 64\n         SLR      R3,R1                       T -= RS\n         LR       R1,R10                      RS = 64\n         SLR      R1,R3                       RS -= T\n         LA       R1,M5IN(R1)                 RS = &In\u00dd RS \u00a8\n* ---------------------------------------------------------------------\n* Enough input to fill ctx->in?\n* ---------------------------------------------------------------------\n         CLR      R3,R9                       T > Len?\n         BH       L40                         Yes, not enough to fill\n* ---------------------------------------------------------------------\n* First chunk is an odd size\n* ---------------------------------------------------------------------\n         LR       R14,R3                      T1 = T\n         BCTR     R14,0                       T1-- (for execute)\n         EX       R14,MEMCPY                  do MEMCPY for T bytes\n* ---------------------------------------------------------------------\n* Adjust buffer and len\n* ---------------------------------------------------------------------\n         ALR      R8,R3                       Buf += T\n         SLR      R9,R3                       Len -= T\n* ---------------------------------------------------------------------\n* Convert to little endian\n* ---------------------------------------------------------------------\n         SWAP     M5IN,16                     byteSwap( In, 16 )\n* ---------------------------------------------------------------------\n* Add in the padding bytes\n* ---------------------------------------------------------------------\n         BAL      R6,MD5TRANS                 MD5Trans( Buf, In )\n* ---------------------------------------------------------------------\n* Process data in 64-byte chunks\n* ---------------------------------------------------------------------\nL20      CLR      R9,R10                      Len >= 64?\n         BL       L30                         No, don't have a block\n         MVC      M5IN(64),0(R8)              memcpy( In, Buf, 64 )\n* ---------------------------------------------------------------------\n* Adjust buffer and len\n* ---------------------------------------------------------------------\n         ALR      R8,R10                      Buf += 64\n         SLR      R9,R10                      Len -= 64\n* ---------------------------------------------------------------------\n* Convert to little endian\n* ---------------------------------------------------------------------\n         SWAP     M5IN,16                     byteSwap( In, 16 )\n* ---------------------------------------------------------------------\n* Add in 64 more bytes\n* ---------------------------------------------------------------------\n         BAL      R6,MD5TRANS                 MD5Trans( Buf, In )\n         B        L20                         Continue loop\n* ---------------------------------------------------------------------\n* Handle any remaining bytes of data.\n* ---------------------------------------------------------------------\nL30      LA       R1,M5IN                     RS = &In\u00dd 0 \u00a8\nL40      LTR      R9,R9                       Len == 0?\n         BZ       PUTCTX                      Yes, nothing to do\n         BCTR     R9,0                        Len-- (for execute)\n         EX       R9,MEMCPY                   do MEMCPY for Len bytes\n* ---------------------------------------------------------------------\n* Store the updated context variable\n* ---------------------------------------------------------------------\nPUTCTX   LM       R6,R7,CTXNAMEA              Get name ptr and length\n         LTR      R7,R7                       Have a Ctx name?\n         BZ       TERM                        No, return digest\n         LA       R4,VREQ                     Get request ptr\n         XC       VREQ,VREQ                   Clear request block\n         USING    SHVBLOCK,R4                 Map SHVB\n* ---------------------------------------------------------------------\n* Initialize request block\n* ---------------------------------------------------------------------\n         MVI      SHVCODE,SHVSYSET            Function code\n         LA       R8,M5CTX                    Get CTX ptr\n         LA       R9,M5LEN                    Get CTX len\n         STM      R6,R9,SHVNAMA               Store the lot\n* ---------------------------------------------------------------------\n* Store the value\n* ---------------------------------------------------------------------\n         L        R15,EXCOMA                  Get IRXEXCOM ptr\n         CALL     (15),(=C'IRXEXCOM',0,0,VREQ,ENVBA),VL,MF=(E,PLIST)\n* ---------------------------------------------------------------------\n* Good result?\n* ---------------------------------------------------------------------\n         XR       R15,R15                     Good RC\n         CLI      SHVRET,SHVNEWV              Execution OK?\n         BE       RETURN                      Yes, return\n         CLI      SHVRET,SHVCLEAN             Execution OK?\n         BNE      ERR5                        No, error\n         DROP     R4                          No longer needed\n         B        RETURN                      Done\n* =====================================================================\n* MD5Term\n*\n* Final wrapup...pad to 64-byte boundary with the bit pattern:\n*     1 0* (64-bit count of bits processed, MSB-first)\n*\n* (Even though they are destroyed in MD5Trans, it is okay to use R2\n* and R3 here since they are reset after each call to MD5Trans.)\n*\n* =====================================================================\n* ---------------------------------------------------------------------\n* Get number of bytes mod 64\n* ---------------------------------------------------------------------\nTERM     L        R3,M5BYTES+(1*4)            Cnt = Bytes\u00dd 1 \u00a8\n         N        R3,=A(X'3F')                Cnt &= 0x3f\n* ---------------------------------------------------------------------\n* Set ptr to start of padding\n* ---------------------------------------------------------------------\n         LA       R2,M5IN(R3)                 Ptr = &In\u00dd Cnt \u00a8\n* ---------------------------------------------------------------------\n* Set the first byte of padding to 0x80.  There is always room.\n* ---------------------------------------------------------------------\n         MVI      0(R2),X'80'                 *Ptr = x'80'\n         LA       R2,1(R2)                    Ptr++\n* ---------------------------------------------------------------------\n* Bytes of padding needed to make 56 bytes (-8..55)\n* ---------------------------------------------------------------------\n         LA       R1,56-1                     RS = 56 - 1\n         SLR      R1,R3                       RS -= Cnt\n* ---------------------------------------------------------------------\n* Padding forces an extra block\n* ---------------------------------------------------------------------\n         LTR      R3,R1                       ( Cnt = RS ) == 0\n         BZ       L60                         =0, no need to clear\n         BNL      L50                         >0, no extra block\n* ---------------------------------------------------------------------\n* Clear the remaining bytes\n* ---------------------------------------------------------------------\n         LA       R3,(8-1)(R3)                Cnt += 8 (-1 for execute)\n         EX       R3,MEMSET                   do MEMSET for Cnt bytes\n* ---------------------------------------------------------------------\n* Convert to little endian\n* ---------------------------------------------------------------------\n         SWAP     M5IN,16                     byteSwap( In, 16 )\n* ---------------------------------------------------------------------\n* Add in the padding bytes\n* ---------------------------------------------------------------------\n         BAL      R6,MD5TRANS                 MD5Trans( Buf, In )\n         LA       R2,M5IN                     Ptr = &In\u00dd 0 \u00a8\n         LA       R3,(15*4)                   Cnt = 56\n* ---------------------------------------------------------------------\n* Clear padding bytes\n* ---------------------------------------------------------------------\nL50      BCTR     R3,0                        Cnt-- (for execute)\n         EX       R3,MEMSET                   do MEMSET for Cnt bytes\n* ---------------------------------------------------------------------\n* Convert to little endian\n* ---------------------------------------------------------------------\nL60      SWAP     M5IN,14                     byteSwap( In, 14 )\n* ---------------------------------------------------------------------\n* Append length in bits and transform\n* ---------------------------------------------------------------------\n         LM       R14,R15,M5BYTES+(0*4)       Get longlong byte count\n         SLDL     R14,3                       Calc number of bits\n         ST       R15,M5IN+(14*4)             Little...\n         ST       R14,M5IN+(15*4)             ...endian\n         BAL      R6,MD5TRANS                 MD5Trans( Buf, In )\n* ---------------------------------------------------------------------\n* Convert to little endian\n* ---------------------------------------------------------------------\n         SWAP     M5BUF,4                     byteSwap( Buf, 4 )\n* ---------------------------------------------------------------------\n* Final transform is the digest\n* ---------------------------------------------------------------------\n         MVC      EVALBLOCK_EVLEN,=F'16'      Length of digest\n         MVC      EVALBLOCK_EVDATA(16),M5BUF  memcpy( digest, buf, 16 )\n         DROP     R11                         Done with EVAL\n         XR       R15,R15                     Assume good RC\n* ---------------------------------------------------------------------\n* Drop the context variable if one was specified\n* ---------------------------------------------------------------------\n         LM       R6,R7,CTXNAMEA              Get name ptr and length\n         LTR      R7,R7                       Have a Ctx name?\n         BZ       RETURN                      No, return digest\n         LA       R4,VREQ                     Get request ptr\n         XC       VREQ,VREQ                   Clear request block\n         USING    SHVBLOCK,R4                 Map SHVB\n* ---------------------------------------------------------------------\n* Initialize request block\n* ---------------------------------------------------------------------\n         MVI      SHVCODE,SHVSYDRO            Function code\n         STM      R6,R7,SHVNAMA               Store the lot\n* ---------------------------------------------------------------------\n* Drop the variable\n* ---------------------------------------------------------------------\n         L        R15,EXCOMA                  Get IRXEXCOM ptr\n         CALL     (15),(=C'IRXEXCOM',0,0,VREQ,ENVBA),VL,MF=(E,PLIST)\n         LTR      R15,R15                     Success?\n         BNZ      ERR6                        No, error\n* ---------------------------------------------------------------------\n* Return to caller\n* ---------------------------------------------------------------------\nRETURN   LR       R2,R15                      Save RC\n         LR       R1,R13                      Get workarea ptr\n         L        R13,4(,R13)                 Restore callers savearea\n         STORAGE  RELEASE,LENGTH=WORKLEN,ADDR=(R1) Release workarea\n         LR       R15,R2                      Restore RC\n         L        R14,12(,R13)                Get return address\n         LM       R0,R12,20(R13)              Restore registers\n         BSM      0,R14                       Return to caller\n* =====================================================================\n* MD5Trans\n*\n* The core of the MD5 algorithm, this alters an existing MD5 hash to\n* reflect the addition of 16 longwords of new data.  MD5Update blocks\n* the data and converts bytes into longwords for this routine.\n*\n* =====================================================================\nRS       EQU      R1\nA        EQU      R2  <--------------------\\\nB        EQU      R3                        \u00a6 Must be sequential since\nC        EQU      R4                        \u00a6 we use LM/STM opcodes\nD        EQU      R5  <--------------------/\nT1       EQU      R14\nT2       EQU      R15\n* ---------------------------------------------------------------------\n*        F1(x, y, z) \\\n*           (z \u00ac (x & (y \u00ac z)))\n* ---------------------------------------------------------------------\n         MACRO\n         F1       &X,&Y,&Z\n.*\n         LR       T1,&Y                       T1 = y\n         XR       T1,&Z                       T1 \u00ac= z\n         LR       T2,&X                       T2 = x\n         NR       T2,T1                       T2 &= T1\n         LR       RS,&Z                       RS = z\n         XR       RS,T2                       RS \u00ac= T2\n.*\n         MEND\n* ---------------------------------------------------------------------\n*        F2(x, y, z) \\\n*            F1(z, x, y)\n* ---------------------------------------------------------------------\n         MACRO\n         F2       &X,&Y,&Z\n.*\n         F1       &Z,&X,&Y                    RS = F1(z,x,y)\n.*\n         MEND\n* ---------------------------------------------------------------------\n*        F3(x, y, z) \\\n*            (x \u00ac y \u00ac z)\n* ---------------------------------------------------------------------\n         MACRO\n         F3       &X,&Y,&Z\n.*\n         LR       RS,&X                       RS = x\n         XR       RS,&Y                       RS \u00ac= y\n         XR       RS,&Z                       RS \u00ac= z\n.*\n         MEND\n* ---------------------------------------------------------------------\n*        F4(x, y, z) \\\n*            (y \u00ac (x \u00a6 ~z))\n* ---------------------------------------------------------------------\n         MACRO\n         F4       &X,&Y,&Z\n.*\n         LR       T1,&Z                       T1 = z\n         X        T1,=A(X'FFFFFFFF')          T1 \u00ac= -1\n         LR       T2,&X                       T2 = x\n         OR       T2,T1                       T2 \u00a6= T2\n         LR       RS,&Y                       RS = y\n         XR       RS,T2                       RS \u00ac= T2\n.*\n         MEND\n* ---------------------------------------------------------------------\n*        MD5STEP(f,w,x,y,z,in,ac,s) \\\n*            (w += f(x,y,z) + in + ac, w = (w<<s \u00a6 w>>(32-s)) + x)\n* ---------------------------------------------------------------------\n         MACRO\n         MD5STEP  &F,&W,&X,&Y,&Z,&IN,&AC,&S\n.*\n         &F       &X,&Y,&Z                    RS = f(x,y,z)\n         AL       RS,M5IN+(&IN*4)             RS += In\u00dd in \u00a8\n         AL       RS,=A(x'&AC')               RS += ac\n         ALR      &W,RS                       w += RS\n         LR       T1,&W                       T1 = w\n         SLL      &W,&S                       w << s\n         SRL      T1,32-&S                    T1 >> (32-s)\n         OR       &W,T1                       w \u00a6= T1\n         ALR      &W,&X                       w += x\n.*\n         MEND\nMD5TRANS LM       A,D,M5BUF\n* ---------------------------------------------------------------------\n* Round 1\n* ---------------------------------------------------------------------\n         MD5STEP  F1,A,B,C,D,00,D76AA478,07\n         MD5STEP  F1,D,A,B,C,01,E8C7B756,12\n         MD5STEP  F1,C,D,A,B,02,242070DB,17\n         MD5STEP  F1,B,C,D,A,03,C1BDCEEE,22\n         MD5STEP  F1,A,B,C,D,04,F57C0FAF,07\n         MD5STEP  F1,D,A,B,C,05,4787C62A,12\n         MD5STEP  F1,C,D,A,B,06,A8304613,17\n         MD5STEP  F1,B,C,D,A,07,FD469501,22\n         MD5STEP  F1,A,B,C,D,08,698098D8,07\n         MD5STEP  F1,D,A,B,C,09,8B44F7AF,12\n         MD5STEP  F1,C,D,A,B,10,FFFF5BB1,17\n         MD5STEP  F1,B,C,D,A,11,895CD7BE,22\n         MD5STEP  F1,A,B,C,D,12,6B901122,07\n         MD5STEP  F1,D,A,B,C,13,FD987193,12\n         MD5STEP  F1,C,D,A,B,14,A679438E,17\n         MD5STEP  F1,B,C,D,A,15,49B40821,22\n* ---------------------------------------------------------------------\n* Round 2\n* ---------------------------------------------------------------------\n         MD5STEP  F2,A,B,C,D,01,F61E2562,05\n         MD5STEP  F2,D,A,B,C,06,C040B340,09\n         MD5STEP  F2,C,D,A,B,11,265E5A51,14\n         MD5STEP  F2,B,C,D,A,00,E9B6C7AA,20\n         MD5STEP  F2,A,B,C,D,05,D62F105D,05\n         MD5STEP  F2,D,A,B,C,10,02441453,09\n         MD5STEP  F2,C,D,A,B,15,D8A1E681,14\n         MD5STEP  F2,B,C,D,A,04,E7D3FBC8,20\n         MD5STEP  F2,A,B,C,D,09,21E1CDE6,05\n         MD5STEP  F2,D,A,B,C,14,C33707D6,09\n         MD5STEP  F2,C,D,A,B,03,F4D50D87,14\n         MD5STEP  F2,B,C,D,A,08,455A14ED,20\n         MD5STEP  F2,A,B,C,D,13,A9E3E905,05\n         MD5STEP  F2,D,A,B,C,02,FCEFA3F8,09\n         MD5STEP  F2,C,D,A,B,07,676F02D9,14\n         MD5STEP  F2,B,C,D,A,12,8D2A4C8A,20\n* ---------------------------------------------------------------------\n* Round 3\n* ---------------------------------------------------------------------\n         MD5STEP  F3,A,B,C,D,05,FFFA3942,04\n         MD5STEP  F3,D,A,B,C,08,8771F681,11\n         MD5STEP  F3,C,D,A,B,11,6D9D6122,16\n         MD5STEP  F3,B,C,D,A,14,FDE5380C,23\n         MD5STEP  F3,A,B,C,D,01,A4BEEA44,04\n         MD5STEP  F3,D,A,B,C,04,4BDECFA9,11\n         MD5STEP  F3,C,D,A,B,07,F6BB4B60,16\n         MD5STEP  F3,B,C,D,A,10,BEBFBC70,23\n         MD5STEP  F3,A,B,C,D,13,289B7EC6,04\n         MD5STEP  F3,D,A,B,C,00,EAA127FA,11\n         MD5STEP  F3,C,D,A,B,03,D4EF3085,16\n         MD5STEP  F3,B,C,D,A,06,04881D05,23\n         MD5STEP  F3,A,B,C,D,09,D9D4D039,04\n         MD5STEP  F3,D,A,B,C,12,E6DB99E5,11\n         MD5STEP  F3,C,D,A,B,15,1FA27CF8,16\n         MD5STEP  F3,B,C,D,A,02,C4AC5665,23\n* ---------------------------------------------------------------------\n* Round 4\n* ---------------------------------------------------------------------\n         MD5STEP  F4,A,B,C,D,00,F4292244,06\n         MD5STEP  F4,D,A,B,C,07,432AFF97,10\n         MD5STEP  F4,C,D,A,B,14,AB9423A7,15\n         MD5STEP  F4,B,C,D,A,05,FC93A039,21\n         MD5STEP  F4,A,B,C,D,12,655B59C3,06\n         MD5STEP  F4,D,A,B,C,03,8F0CCC92,10\n         MD5STEP  F4,C,D,A,B,10,FFEFF47D,15\n         MD5STEP  F4,B,C,D,A,01,85845DD1,21\n         MD5STEP  F4,A,B,C,D,08,6FA87E4F,06\n         MD5STEP  F4,D,A,B,C,15,FE2CE6E0,10\n         MD5STEP  F4,C,D,A,B,06,A3014314,15\n         MD5STEP  F4,B,C,D,A,13,4E0811A1,21\n         MD5STEP  F4,A,B,C,D,04,F7537E82,06\n         MD5STEP  F4,D,A,B,C,11,BD3AF235,10\n         MD5STEP  F4,C,D,A,B,02,2AD7D2BB,15\n         MD5STEP  F4,B,C,D,A,09,EB86D391,21\n* ---------------------------------------------------------------------\n* Add back into state and return\n* ---------------------------------------------------------------------\n         AL       A,M5BUF+(0*4)\n         AL       B,M5BUF+(1*4)\n         AL       C,M5BUF+(2*4)\n         AL       D,M5BUF+(3*4)\n         STM      A,D,M5BUF\n         BR       R6\n* ---------------------------------------------------------------------\n* Error routines\n* ---------------------------------------------------------------------\nERR6     LA       R15,C'6'                    Drop CTX failed\n         B        ERR\nERR5     LA       R15,C'5'                    Put CTX failed\n         B        ERR\nERR4     LA       R15,C'4'                    Too many arguments\n         B        ERR\nERR3     LA       R15,C'3'                    CTX Invalid\n         B        ERR\nERR2     LA       R15,C'2'                    Get CTX failed\n         B        ERR\nERR1     LA       R15,C'1'                    No arguments\n* ---------------------------------------------------------------------\n* Fill in the request block\n* ---------------------------------------------------------------------\nERR      STC      R15,RC                      Store the RC\n         LA       R4,VREQ                     Get request ptr\n         XC       VREQ,VREQ                   Clear request block\n         USING    SHVBLOCK,R4                 Map SHVB\n* ---------------------------------------------------------------------\n* Initialize request block\n* ---------------------------------------------------------------------\n         MVI      SHVCODE,SHVSTORE            Function code\n         LA       R6,MD5RC                    Get name ptr\n         LA       R7,L'MD5RC                  Get name length\n         LA       R8,RC                       Get RC ptr\n         LA       R9,1                        Get RC length\n         STM      R6,R9,SHVNAMA               Store the lot\n* ---------------------------------------------------------------------\n* Store the value\n* ---------------------------------------------------------------------\n         L        R15,EXCOMA                  Get IRXEXCOM ptr\n         CALL     (15),(=C'IRXEXCOM',0,0,VREQ,ENVBA),VL,MF=(E,PLIST)\n         LA       R15,1                       Bad RC\n         B        RETURN                      Go exit\n         DROP     R4                          Done with SHVB\n         DROP     R12                         Done with BASE\n         DROP     R13                         Done with WORK\n* ---------------------------------------------------------------------\n* Executed instructions\n* ---------------------------------------------------------------------\nMEMCPY   MVC      0(0,R1),0(R8)               memcpy( RS, Buf, Len )\nMEMSET   XC       0(0,R2),0(R2)               Ptr\u00dd...\u00a8 \u00ac= Ptr\u00dd...\u00a8\n* ---------------------------------------------------------------------\n* Pre-initialized CTX\n* ---------------------------------------------------------------------\nINITCTX  DC       A(M5ID),X'67452301,EFCDAB89,98BADCFE,10325476'\n* ---------------------------------------------------------------------\n* Static data area\n* ---------------------------------------------------------------------\nMD5RC    DC       C'MD5RC'                    Return code variable name\n         ORG\n* ---------------------------------------------------------------------\n* Literals\n* ---------------------------------------------------------------------\n         LTORG                                Literals\n* ---------------------------------------------------------------------\n* Put argument list here to get access to constant data\n* ---------------------------------------------------------------------\n         IRXARGTB DECLARE=YES                 Argument Table\n* ---------------------------------------------------------------------\n* Workarea DSECT with embedded MD5 context\n* ---------------------------------------------------------------------\nWORKAREA DSECT\nSAVEAREA DS       18F                         Must be at start\n* ---------------------------------------------------------------------\n* MD5 Context\n* ---------------------------------------------------------------------\nM5CTX    DS       A                           Control block ID\nM5ID     EQU      C'MD5X'                     And the ID itself\nM5BUF    DS       4F                          Accumulation buffer\nM5BYTES  DS       2F                          # of bytes processed\nM5IN     DS       16F                         Input buffer\nM5LEN    EQU      *-M5CTX                     Length of context\n* ---------------------------------------------------------------------\n* Remaining work fields\n* ---------------------------------------------------------------------\nCTXNAMEA DS       A\nCTXNAMEL DS       F\nEVALA    DS       A\nEVALL    DS       F\nENVBA    DS       A\nEXCOMA   DS       A\nRLTA     DS       A\nPLIST    CALL     ,(,,,,),MF=L\nVREQ     DS       XL(SHVBLEN)\nRC       DS       C\n*\nWORKLEN  EQU      *-WORKAREA\n* ---------------------------------------------------------------------\n* Register equates\n* ---------------------------------------------------------------------\n         YREGS                                Register equates\n* ---------------------------------------------------------------------\n* Rest of REXX control blocks\n* ---------------------------------------------------------------------\n         IRXEFPL                              Function Parameter List\n         IRXEVALB                             Evaluation Block\n         IRXENVB                              Environment Block\n         IRXSHVB                              Variable Request\n         IRXEXTE                              External Entry Points\n* ---------------------------------------------------------------------\n* The world is square ya know...careful you don't fall off!\n* ---------------------------------------------------------------------\n         END\n/*\n//*\n//* -------------------------------------------------------------------\n//* Link\n//* -------------------------------------------------------------------\n//LINK     EXEC  PGM=IEWL,\n//             PARM='MAP,LET,LIST,NCAL,RENT,REUS'\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  DSN=&SYSUT1,\n//             SPACE=(CYL,(3,2)),\n//             UNIT=VIO\n//SYSLMOD  DD  DISP=(,PASS),\n//             RECFM=U,LRECL=0,BLKSIZE=32760,\n//             SPACE=(CYL,(1,,1)),\n//             UNIT=SYSALLDA\n//SYSLIN   DD  DSN=*.ASM.SYSLIN,\n//             DISP=(OLD,DELETE)\n//         DD  *\n  ENTRY MD5\n  NAME MD5(R)\n/*\n//*\n//* -------------------------------------------------------------------\n//* Allocate temp EXEC PDS\n//* -------------------------------------------------------------------\n//ALCEXEC  EXEC  PGM=IEFBR14\n//SYSUT2   DD  DSN=&&EXEC,\n//             DISP=(,PASS),\n//             RECFM=FB,LRECL=80,\n//             SPACE=(CYL,(1,,1)),\n//             UNIT=SYSALLDA\n//*\n//* -------------------------------------------------------------------\n//* Copy EXEC to temp PDS\n//* -------------------------------------------------------------------\n//GENEXEC  EXEC  PGM=IEBGENER\n//SYSPRINT DD  DUMMY\n//SYSUT2   DD  DSN=&&EXEC(TEST),\n//             DISP=(OLD,PASS)\n//SYSIN    DD  DUMMY\n//SYSUT1   DD  *\n\n  SIGNAL ON SYNTAX\n\n  Appetizer      = \"Fried Rattlesnake\"\n  MainCourse     = \"Turkey Neck Gumbo\"\n  Dessert        = \"Pecan Pie\"\n\n  CALL Md5 \"Ctx\", Appetizer\n  CALL Md5 \"Ctx\", MainCourse\n  CALL Md5 \"Ctx\", Dessert\n  DigestedFood = Md5( \"Ctx\" )\n\n  SAY \"Digesting: \"Appetizer\n  SAY \"           \"MainCourse\n  SAY \"           \"Dessert\n  SAY \"Produces:  \"C2x( DigestedFood )\n  SAY\n\nEXIT\n\nSYNTAX:\n  SAY \"SYNTAX:\" md5rc\nEXIT\n/*\n//*\n//* -------------------------------------------------------------------\n//* Run the test\n//* -------------------------------------------------------------------\n//RUNTEST  EXEC  PGM=IRXJCL,\n//             PARM=TEST\n//STEPLIB  DD  DSN=*.LINK.SYSLMOD,\n//             DISP=(OLD,DELETE)\n//SYSEXEC  DD  DSN=*.ALCEXEC.SYSUT2,\n//             DISP=(OLD,DELETE)\n//MSGDD    DD  SYSOUT=*\n//SYSUDUMP DD  SYSOUT=*\n//SYSTSPRT DD  SYSOUT=*\n//SYSTSIN  DD  DUMMY\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MD5SUM": {"ttr": 3589, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01!\\x00V\\x01\\x131o\\x01\\x174_\\x01S\\x04\\xd1\\x04m\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.33", "flags": 0, "createdate": "2013-11-12T00:00:00", "modifydate": "2017-12-11T01:53:56", "lines": 1233, "newlines": 1133, "modlines": 0, "user": "UPDATED"}, "text": "         TITLE '   M D 5 S U M  '\n************************************************************\n*                                                          *\n*        'MD5SUM' TSO COMMAND (31-BIT)                     *\n*                                                          *\n************************************************************\n         SPACE\n*        WRITTEN OCTOBER 12 2013\n*        UPDATED NOV 11 2013 TO SUPPORT LIST OF DSNAMES.\n*        UPDATED NOV 12 2013 FOR AMODE 31 RMODE 31 AND RELEVANT CODE.\n*        UPDATED NOV 15 2013 TO SHOW MEMBER OR PATH WHEN DDNAME USED.\n*        UPDATED FEB  7 2014 TO USE UPTPREFX NOT PSCBUSER.\n*        UPDATED FEB  7 2014 TO ADD RMODE 31 FOR MD5SMPCL.\n*        UPDATED FEB  7 2014 TO DELETE UNUSED MSGDAIR.\n*        UPDATED APR 14 2015 TO CLEAR BITS AFTER LOADING TIOEFSRT\n*        UPDATED AUG 28 2016 TO IGNORE DS1LSTAR WHICH IS 0 FOR PDSE\n*        UPDATED SEP  3 2016 TO SET RETURN CODE 12 IF ANY ERROR\n*        UPDATED DEC 11 2017 TO SUPPORT 8-CHARACTER DSN PREFIX ZOS V2R3\n*        UPDATED DEC 11 2017 TO REMOVE USE OF TIOEFSRT, LOCATE, OBTAIN\n*        UPDATED DEC 11 2017 TO CHECK FOR DSN TOO LONG AFTER PREFIXING\n*        ATTRIBUTES. RE-ENTRANT.\n*\n*        MOST OF THE CODE APART FROM THE MD5 SUBROUTINE IS BORROWED\n*        FROM BILL GODFREY'S 'COUNT' TSO COMMAND IN CBT TAPE FILE 300.\n*\n*        THE MD5 SUBROUTINE, WHICH IS ASSEMBLED SEPARATELY FROM THIS,\n*        IS A MODIFIED VERSION OF LELAND LUCIUS' PUBLIC DOMAIN MD5\n*        SUBROUTINE, MODIFIED FOR NON-REXX CALLERS.\n*\n*        THIS TSO COMMAND READS THE SPECIFIED SEQUENTIAL DATA SETS\n*        OR PDS MEMBERS AND DISPLAYS THE MD5 CHECKSUM FOR EACH.\n*\n*        IF AN UNQUALIFIED DATA SET NAME IS ENTERED, THE\n*        CATALOG MUST BE READ TWICE, ONCE TO APPEND A\n*        TRAILING QUALIFIER IF NECESSARY, AND AGAIN DURING\n*        ALLOCATION. THE USER CAN ELIMINATE THE FIRST BY USING\n*        THE FULLY QUALIFIED NAME, PREFIX AND ALL, IN QUOTES,\n*        OR BY ENTERING ALL BUT THE PREFIX, WITHOUT QUOTES,\n*        PLUS THE KEYWORD 'Q'. THE LATTER IS MUCH SIMPLER\n*        AND GIVES THE SAME PERFORMANCE IMPROVEMENT AS A\n*        FULLY QUALIFIED NAME.\n*\n*        THE 'FILE' KEYWORD IS USEFUL FOR READING TEMPORARY\n*        DATA SETS.  IT TELLS THE COMMAND TO TREAT THE FIRST\n*        OPERAND AS A FILENAME (DDNAME) INSTEAD OF A DSNAME.\n*        WHATEVER DATA SET IS CURRENTLY ALLOCATED TO THE\n*        FILENAME WILL BE READ (AND QUICKLY, BECAUSE\n*        THE COMMAND DOESNT HAVE TO ALLOCATE ANYTHING).\n*\n*        UNIX FILES THAT ARE PREALLOCATED TO A DDNAME CAN BE\n*        READ. FOR EXAMPLE:\n*         ALLOC FI(DD1) PATH('/ETC/MAGIC') (BUT USE PATH IN LOWER CASE)\n*         MD5SUM DD1 FILE\n*        IF UNIX FILES ARE NOT GIVEN RECFM WHEN ALLOCATED\n*        THEY DEFAULT TO RECFM=U, WHICH IS GOOD FOR MD5SUM.\n*        RECFM=F WOULD BE LIKELY TO INTRODUCE PADDING IN THE\n*        LAST RECORD, WHICH WOULD CHANGE THE MD5SUM RESULT.\n*\n*        NOTE - IF A NON-EXISTENT MEMBER OF A PDS IS SPECIFIED,\n*        THE RESULTING 013-18 ABEND IS TRAPPED BY A DCB ABEND\n*        EXIT, BUT A MESSAGE IS ISSUED BY OPEN ANYWAY. THIS\n*        METHOD IS USED BECAUSE THE ADDITIONAL OVERHEAD\n*        OF ALLOCATING THE PDS AND DOING A 'BLDL' WOULD\n*        DEGRADE THE PERFORMANCE UNACCEPTABLY.\n*\n*        PROBLEMS FIXED:\n*        . IF THE SPECIFIED DDNAME (WITH 'FILE' KEYWORD) IS\n*          A MEMBER OF A PDS, ONLY THE PDS NAME WAS SHOWN.\n*          ADDED CODE TO GET MEMBER NAME FROM JFCBELNM.\n*        . IF THE SPECIFIED DDNAME (WITH 'FILE' KEYWORD) IS\n*          A UNIX PATH, ONLY \"...PATH=.SPECIFIED...\" IS SHOWN,\n*          THAT'S WHAT IS IN THE JFCB. ADDED ARL TO GET PATH.\n*\n*        IMPROVEMENTS NEEDED:\n*        . ALLOW PATH TO BE SPECIFIED AND ALLOCATE IT.\n*        . IF THE SPECIFIED DDNAME (WITH 'FILE' KEYWORD) IS\n*          A CONCATENATION, SHOW MORE THAN THE FIRST DSN OR PATH.\n*\n* CHNGE LOG: 02JUN92 - INCLUDED 'OBTAIN' MACRO IN THE SOURCE. WITH\n*                      MVS/XA 2.2.3, THE MACRO IS ONLY AVAILABLE IN\n*                      'SYS1.AMACLIB' (SOUNDS LIKE IBM IS TRYING TO\n*                      TELL US SOMETHING).  JIM MARSHALL         JDM1\n*\n* CHNGE LOG: 12OCT13 - MD5SUM COMMAND CREATED FROM SOURCE OF 'COUNT'.\n*                      RDW'S ARE NOT INCLUDED IN THE MD5 AT THIS TIME,\n*                      AS A RESULT, 2 FILES OF VARIABLE-LENGTH RECORDS,\n*                      ONE WITH 2 RECORDS \"AB\" AND \"CD\" AND THE OTHER\n*                      ONE WITH 2 RECORDS \"ABC' AND \"D\" WILL HAVE THE\n*                      SAME MD5 VALUE.\n*\n* CHNGE LOG: 11NOV13 - SUPPORT LIST OF DSNAMES, SHOW NAME AFTER MD5.\n*\n* CHNGE LOG: 12NOV13 - CONVERT TO 31-BIT.\n*\n* CHNGE LOG: 15NOV13 - ALLOW NON-DASD DEVTYPE INCLUDING UNIX AND DUMMY.\n*                      SHOW UNIX FILE NAME IF DDNAME ALLOCATED TO PATH.\n*                      SHOW MEMBER NAME IF DDNAME ALLOCATED TO MEMBER.\n*\n*         INTERCEPT 'LINK' MACRO IMBEDDED IN STACK MACRO\n*         TO MAKE SF=(E,LINKAREA) THE DEFAULT.\n         MACRO\n&NAME    LINK  &EP=,&SF=(E,LINKAREA)\n&NAME    LA    15,&SF(2)\n         LA    0,*+8\n         B     *+12\n         DC    CL8'&EP'\n         ST    0,0(0,15)\n         SVC   6             ISSUE LINK SVC\n         MEND\n         SPACE\nMD5SUM   START\nMD5SUM   AMODE 31\nMD5SUM   RMODE 31\n         USING *,R12,R11\n         B     @PROLOG-*(,R15)\n         DC    AL1(7),CL7'MD5SUM'\n         DC    CL16' &SYSDATE &SYSTIME '\n@SIZE31  DC    0F'0',AL1(0),AL3(@DATA31L)\n@SIZE24  DC    0F'0',AL1(1),AL3(@DATA24L)\n@PROLOG  STM   14,12,12(13)\n         LR    R12,R15             BASE\n         LA    R15,1\n         LA    R11,4095(R15,R12)   BASE\n         LR    R2,R1\n         USING CPPL,R2\n         L     R0,@SIZE31\n         GETMAIN RU,LV=(0),SP=1,LOC=31\n         LR    R9,R1\n         USING @DATA31,R9\n         ST    13,4(,1)            CHAIN SAVEAREA\n         ST    1,8(,13)            CHAIN SAVEAREA\n         LR    13,1                NEW SAVEAREA\n         SPACE\n         L     R0,@SIZE24\n         GETMAIN R,LV=(0)\n         LR    R10,R1\n         USING @DATA24,R10\n         SPACE\n         MVI   STATUS,0\n         XC    LINKAREA(8),LINKAREA\n         SLR   R15,R15\n         STH   R15,RETCODE         SET RETCODE = 0\n         ST    R15,KOUNT\n         ST    R15,KOUNTSP\n         SPACE\n************************************************************\n*                                                          *\n*        SET UP IOPL FOR PUTLINE                           *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R15,MYIOPL\n         USING IOPL,R15\n         MVC   IOPLUPT(4),CPPLUPT\n         MVC   IOPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,IOPLECB\n         XC    MYECB,MYECB\n         LA    R0,MYPTPB\n         ST    R0,IOPLIOPB\n         DROP  R15                 IOPL\n         SPACE\n         L     R15,16              LOAD CVT POINTER\n         TM    444(R15),X'80'      IS PUTLINE LOADED? (VS2)\n         BNO   PUTLOAD             NO - BRANCH TO LOAD\n         L     R15,444(,R15)       YES - USE CVTPUTL\n         B     PUTLOADX            BRANCH AROUND LOAD\nPUTLOAD  LA    R0,=CL8'IKJPUTL '\n         LOAD  EPLOC=(0)\n         LR    R15,R0              GET ENTRY ADDRESS\n         LA    R15,0(,R15)         CLEAR HI BYTE FOR DELETE ROUTINE\nPUTLOADX ST    R15,MYPUTLEP        SAVE PUTLINE ENTRY ADDRESS\n         SPACE\n************************************************************\n*                                                          *\n*        SET UP PPL FOR PARSE                              *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R15,MYPPL\n         USING PPL,R15\n         MVC   PPLUPT(4),CPPLUPT\n         MVC   PPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,PPLECB\n         XC    MYECB,MYECB\n         L     R0,=A(MD5SMPCL)\n*        LA    R0,PCLADDR\n         ST    R0,PPLPCL\n         LA    R0,MYANS\n         ST    R0,PPLANS\n         XC    MYANS(4),MYANS\n         MVC   PPLCBUF(4),CPPLCBUF\n         ST    R9,PPLUWA\n         DROP  R15                 PPL\n         SPACE 1\n************************************************************\n*                                                          *\n*        CALL THE PARSE SERVICE ROUTINE                    *\n*                                                          *\n************************************************************\n         SPACE\n         LR    R1,R15              POINT TO PPL\n*        CALLTSSR EP=IKJPARS\n         L     R15,16              CVTPTR\n         TM    524(R15),X'80'      IF HI ORDER BIT NOT ON\n         BNO   PARSELNK               THEN DO LINK, NOT CALL\n         L     R15,524(,R15)       CVTPARS\n         BALR  R14,R15             CALL IKJPARS\n         B     PARSEEXT            SKIP AROUND LINK\nPARSELNK EQU   *\n         LINK  EP=IKJPARS,SF=(E,LINKAREA)\nPARSEEXT EQU   *\n         SPACE 1\n         LTR   R15,R15\n         BZ    PARSEOK\n         LA    R1,MSG01\n         LA    R0,L'MSG01\n         BAL   R14,PUTMSG\n         MVI   RETCODE+1,12\n         B     EXIT\nPARSEOK  EQU   *\n         SPACE\n         L     R3,MYANS\n         USING IKJPARMD,R3\n         SPACE\n************************************************************\n*                                                          *\n*        GET THE FIRST OR NEXT DSN IN THE LIST             *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R6,DSN\n         B     FIRSTDSN\nNEXTDSN  CLI   24(R6),X'FF'        END OF DSN LIST?\n         BE    DONE\n         L     R6,24(,R6)          POINT TO NEXT ENTRY\nFIRSTDSN SR    R0,R0\n         ST    R0,KOUNT\n         SPACE\n************************************************************\n*                                                          *\n*        QUALIFY THE DSNAME IF NECESSARY                   *\n*                                                          *\n************************************************************\n         SPACE\n         TM    6(R6),X'80'         IS DATASET NAME SPECIFIED?\n         BO    OKDSN               YES - BRANCH\n         LA    R1,MSG05            NO - JUST MEMBER NAME\n         LA    R0,L'MSG05\n         BAL   R14,PUTMSG\n         B     NEXTD12\nOKDSN    EQU   *\n         LA    R15,DSNAME+2\n         MVI   0(R15),C' '         BLANK THE DSNAME AREA\n         MVC   1(43,R15),0(R15)\n         SLR   R1,R1\n         STH   R1,DSNAME           ZERO DSNAME LENGTH\n         TM    6(R6),X'40'         IS DSN QUOTED?\n         BO    NOPREF              YES, SKIP PREFIXING\n         CLI   FILEKW+1,1          DSN TO BE TREATED AS DDNAME\n         BE    NOPREF              YES, SKIP PREFIXING\n         L     R14,CPPLUPT         POINT TO UPT\n         USING UPT,R14\n         CLI   UPTPREFX,C'>'      IF PREFIX IS '>7BYTES' (8 BYTES)\n         BNE   PREF07                THEN\n         IC    R1,UPTPREFL+18        GET UPTPRF8L (SHOULD ALWAYS BE 8)\n         LTR   R1,R1                 IS IT ZERO\n         BZ    NOPREF                YES, SKIP PREFIXING\n         B     *+10\n         MVC   0(0,R15),UPTPREFX+17  COPY UPTPREF8\n         EX    R1,*-6              MOVE USERID TO DSNAME AREA\n         B     PREFDONE\nPREF07   IC    R1,UPTPREFL         GET LENGTH OF PREFIX\n         LTR   R1,R1               IS IT ZERO\n         BZ    NOPREF              YES, SKIP PREFIXING\n         B     *+10\n         MVC   0(0,R15),UPTPREFX\n         EX    R1,*-6              MOVE USERID TO DSNAME AREA\n         DROP  R14                 UPT\nPREFDONE LA    R15,0(R1,R15)       POINT PAST USERID\n         MVI   0(R15),C'.'         APPEND PERIOD\n         LA    R15,1(,R15)         POINT PAST PERIOD\n         LA    R1,1(,R1)           ADD 1 TO LENGTH\n         STH   R1,DSNAME           STORE LENGTH OF USERID PLUS 1\nNOPREF   EQU   *\n         LH    R1,4(,R6)           GET LENGTH\n         LR    R0,R1\n         AH    R0,DSNAME           ADD LENGTH OF PREFIX OR ZERO\n         STH   R0,DSNAME           SET COMBINED LENGTH\n         L     R14,0(,R6)          POINT TO DSN VALUE\n         BCTR  R1,0                LENGTH MINUS 1 FOR EX\n         B     *+10                BRANCH AROUND EXECUTED MVC\n         MVC   0(0,R15),0(R14)     (EXECUTED)\n         EX    R1,*-6              MOVE DSN TO DSNAME (AFTER PREFIX)\n         CH    R0,=H'44'\n         BNH   OKDSNLEN\n* DSNAME IS TOO LONG AFTER PREFIXING.\n* ISSUE MSG 'IKJ56709I INVALID DSN LENGTH, ' WITH SAME MESSAGE\n* ID AS MSG 'IKJ56709I INVALID DATA SET NAME, '\n* WHICH NORMALLY IS ISSUED BY IKJPARS AND IS NORMALLY FOLLOWED BY\n* 'IKJ56703A REENTER THIS OPERAND -'\n* BUT THIS COMMAND DOESN'T DO THE LATTER.\nERRDSNLN MVC   MSGWK(L'MSG09),MSG09\n         LA    R15,MSGWK+L'MSG09\n         LA    R14,DSNAME\n         LH    R1,0(,R14)\n         BCTR  R1,0\n         B     *+10\n         MVC   MSGWK+L'MSG09(0),2(R14)\n         EX    R1,*-6\n         LA    R15,1(R1,R15)\n         LA    R0,L'MSG09+1(,R1)\n         LA    R1,MSGWK\n         BAL   R14,PUTMSG\n         B     NEXTD12\nOKDSNLEN EQU   *\n         SPACE\n************************************************************\n*                                                          *\n*        IF 'FILE' KEYWORD IS SPECIFIED,                   *\n*        GET DSNAME FROM JFCB USING FILE NAME.             *\n*                                                          *\n************************************************************\n         SPACE\n         CLI   FILEKW+1,1          'FILE' SPECIFIED?\n         BNE   NOFILE              NO, BRANCH\n         CLI   DSNAME+1,8          IS LENGTH 8 OR LESS\n         BH    FILERR1             NO, BRANCH\n         DEVTYPE DSNAME+2,DEVDATA  GET DEVICE TYPE\n         LTR   R15,R15             WAS FILENAME VALID\n         BNZ   FILERR2             NO, BRANCH\n*        CLC   DEVDATA(8),=X'0000010300007FF8'\n*        BE    DEVOK\n*        TM    DEVDATA+2,X'20'     DIRECT ACCESS\n*        BZ    FILERR3             NO, BRANCH\nDEVOK    LA    R4,DYNDCBW\n         MVC   0(DYNDCBL,R4),DYNDCB\n         XC    DSNAME(2),DSNAME\n         XC    MEMLEN,MEMLEN\n         LA    R0,JFCB\n         LA    R1,DYNEXLST\n         ST    R0,0(,R1)\n         MVI   0(R1),X'07'\n         LA    R14,MYARL             ALLOCATION RETRIEVAL LIST\n         ST    R14,4(,R1)\n         MVI   4(R1),X'13'+X'80'\n         ST    R1,36(,R4)          DCBEXLST\n         USING ARL,R14\n         XC    0(36,R14),0(R14)\n         MVI   ARLLEN+1,36\n         MVC   ARLIDENT,=C'AR'\n         OI    ARLOPT1,ARLLANY+ARLUSS\n         MVC   40(8,R4),DSNAME+2   DCBDDNAM\n         MVC   DDSAVE,DSNAME+2\n         MVI   RDJFW,X'80'\n         RDJFCB ((R4)),MF=(E,RDJFW)\n         LA    R14,MYARL\n         L     R1,ARLAREA\n         LTR   R1,R1\n         BZ    NOARA\n         L     R0,ARLRTRVD\n         DROP  R14                 ARL\n         USING ARA,R1\nLOOPARA  TM    ARAFLG,ARAXINF\n         BZ    DONEARA\n         SR    R15,R15\n         IC    R15,ARAXINOF\n         SLL   R15,3\n         AR    R15,R1\n         USING ARAXINFO,R15\n         SR    R14,R14\n         ICM   R14,3,ARAPATHO      GET OFFSET TO PATH LEN\n         BZ    DONEARA\n         AR    R14,R15\n         DROP  R15                 ARAXINLN\n         SR    R15,R15\n         ICM   R15,3,0(R14)        GET ARAPATHLEN\n         CH    R15,=H'44'\n         BNH   *+8\n         LA    R15,44              JUST SHOW FIRST 44 FOR NOW\n         STH   R15,DSNAME\n         BCTR  R15,0\n         B     *+10\n         MVC   DSNAME+2(0),2(R14)  ARAPATHNAM\n         EX    R15,*-6\nDONEARA  LA    R14,MYARL           PREPARE FOR FREEMAIN\n         USING ARL,R14\n         SR    R15,R15             PREPARE FOR FREEMAIN\n         IC    R15,ARLPOOL\n         SR    R0,R0\n         ICM   R0,7,ARLRLEN\n         L     R1,ARLAREA\n         DROP  R14                 ARL\n         FREEMAIN RU,LV=(0),SP=(R15),A=(1)\nNOARA    CLC   DSNAME(2),=H'0'\n         BNE   FILESPEC\n         MVC   DSNAME+2(44),JFCB\n         LA    R1,DSNAME+45        LAST CHAR OF DSNAME\n         LA    R0,44               INITIAL LENGTH\nFILEA    CLI   0(R1),C' '          IS THIS LAST NONBLANK\n         BNE   FILEB               YES, BRANCH\n         BCTR  R1,0                BACK UP 1 CHARACTER\n         BCT   R0,FILEA            DECREMENT LENGTH AND BRANCH\nFILEB    STH   R0,DSNAME           STORE LENGTH OF DSNAME\n*        MVC   VOLUME(6),JFCB+118  GET VOLUME FROM JFCB\n         MVC   MEMNAME,JFCB+44     JFCBELNM IN IEFJFCBN\n         LA    R1,MEMNAME+7        LAST CHAR OF MEMBER NAME\n         LA    R0,8\nMEMA     CLI   0(R1),C' '\n         BNE   MEMB\n         BCTR  R1,0\n         BCT   R0,MEMA\nMEMB     STH   R0,MEMLEN\n         B     FILESPEC\nFILERR1  LA    R0,MSG14A\n         B     FILERR\nFILERR2  LA    R0,MSG14B\n         B     FILERR\nFILERR3  LA    R0,MSG14C\nFILERR   MVC   MSGWK(L'MSG14),MSG14\n         LA    R15,MSGWK+L'MSG14\n         LA    R14,DSNAME\n         LH    R1,0(,R14)\n         BCTR  R1,0\n         B     *+10\n         MVC   MSGWK+L'MSG14(0),2(R14)\n         EX    R1,*-6\n         LA    R15,1(R1,R15)\n         LR    R14,R0 POINT TO MSG14A, B, OR C\n         MVC   0(L'MSG14A,R15),0(R14)\n         LA    R0,L'MSG14+L'MSG14A+1(,R1)\n         LA    R1,MSGWK\n         BAL   R14,PUTMSG\n         B     QUITD12\nNOFILE   EQU   *\n         TM    6(R6),X'40'         IS IT QUOTED?\n         BO    DEFX                YES - SKIP DEFAULT SERVICE\n         CLI   QUICKW+1,1          QUICK SPECIFIED\n         BE    DEFX                YES, USER ENTERED ALL BUT PREFIX\n         SPACE\n************************************************************\n*                                                          *\n*        DEFAULT SERVICE ROUTINE TO GET QUALIFIERS         *\n*                                                          *\n************************************************************\n         SPACE\n*              ALL INPUT TO IKJEHDEF MUST BE BELOW THE LINE\n         MVC   DSNAME24(46),DSNAME\n         LA    R15,MYIOPL24\n         USING IOPL,R15\n         LA    R14,MYIOPL\n         MVC   IOPLUPT(4),IOPLUPT-IOPL(R14)\n         MVC   IOPLECT(4),IOPLECT-IOPL(R14)\n         LA    R0,MYECB24\n         ST    R0,IOPLECB\n         XC    MYECB24,MYECB24\n         LA    R14,MYDFPB\n         ST    R14,IOPLIOPB\n         USING DFPB,R14\n         XC    0(20,R14),0(R14)\n         LA    R0,DSNAME24\n         ST    R0,DFPBDSN\n         OI    DFPBCODE,X'04'      SEARCH CAT AND PROMPT IF MULTI\n         MVC   DFPBPSCB,CPPLPSCB\n*        MVI   DFPBCNTL,X'20'      PREFIX THE DSNAME\n         DROP  R14                 DFPB\n         DROP  R15                 IOPL\n         SPACE\n         LR    R1,R15              POINT TO IOPL\n         LA    R13,SAVE24          POINT TO SAVEAREA BELOW THE LINE\n         L     R15,16              CVTPTR\n         TM    736(R15),X'80'      IF HI ORDER BIT NOT ON\n         BNO   EHDEFLNK               THEN DO LINK, NOT CALL\n         L     R15,736(,R15)       CVTEHDEF\n         BALR  R14,R15             CALL IKJEHDEF\n         B     EHDEFEXT            SKIP AROUND LINK\nEHDEFLNK EQU   *\n         LINK  EP=IKJEHDEF,SF=(E,LINKAREA)\nEHDEFEXT EQU   *\n         SPACE\n         LR    R13,R9              RESTORE SAVEARE POINTER\n         B     DEFCODE(R15)\nDEFCODE  B     DEF00               SUCCESS\n         B     NEXTD12              MSG ALREADY ISSUED\n         B     DEF08               INVALID NAME GT 44\n         B     NEXTD12              MSG ALREADY ISUED\n         B     DEF16               NOT IN CATALOG\n         B     DEF20               NOT IN CATALOG\n         B     DEF24               IMPOSSIBLE\n         B     DEF28               COMMAND SYSTEM ERROR\n         B     DEF32               IMPOSSIBLE\n         B     DEF36               ?\nDEF08    EQU   *\nDEF16    EQU   *\n         B     DEF24\nDEF20    EQU   *\nLOCERR   EQU   *\n         MVC   MSGWK(L'MSG02),MSG02\n         LA    R15,MSGWK+L'MSG02\n         LA    R14,DSNAME\n         LH    R1,0(,R14)\n         BCTR  R1,0\n         B     *+10\n         MVC   MSGWK+L'MSG02(0),2(R14)\n         EX    R1,*-6\n         LA    R15,1(R1,R15)\n         MVC   0(L'MSG02A,R15),MSG02A\n         LA    R0,L'MSG02+L'MSG02A+1(,R1)\n         LA    R1,MSGWK\n         BAL   R14,PUTMSG\n         B     NEXTD12\nDEF24    EQU   *\nDEF28    EQU   *\nDEF32    EQU   *\nDEF36    EQU   *\n         LA    R1,MSG03\n         LA    R0,L'MSG03\n         BAL   R14,PUTMSG\nNEXTD12  MVI   RETCODE+1,12\n         B     NEXTDSN\n         SPACE\nDEF00    MVC   DSNAME(46),DSNAME24\nDEFX     EQU   *\n         SPACE\n************************************************************\n*                                                          *\n*        ALLOCATE THE DATASET                              *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R1,MYDAPL\n         USING DAPL,R1\n         MVC   DAPLUPT(4),CPPLUPT\n         MVC   DAPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,DAPLECB\n         MVC   DAPLPSCB(4),CPPLPSCB\n         LA    R15,MYDAPB\n         ST    R15,DAPLDAPB\n         DROP  R1                  DAPL\n         USING DAPB08,R15\n         XC    0(84,R15),0(R15)\n         MVI   DA08CD+1,X'08'\n         LA    R0,DSNAME\n         ST    R0,DA08PDSN\n         MVC   DA08DDN(8),=CL8' '\n         MVC   DA08UNIT,=CL8' '\n         MVC   DA08SER,=CL8' '\n         MVC   DA08MNM,=CL8' '\n         MVC   DA08PSWD,=CL8' '\n         MVI   DA08DSP1,DA08SHR\n         MVI   DA08DPS2,DA08KEEP\n         MVI   DA08DPS3,DA08KEP\n         TM    14(R6),X'80'        MEMBER SPECIFIED?\n         BZ    MEMBX               NO - BRANCH\n         LH    R1,12(,R6)          GET LENGTH OF MEMBER\n         STH   R1,MEMLEN\n         BCTR  R1,0                MINUS 1 FOR EX\n         L     R14,8(,R6)          GET ADDRESS OF MEMBER NAME\n         B     *+10\n         MVC   DA08MNM(0),0(R14)   MOVE MEMBER NAME\n         EX    R1,*-6\n         MVC   MEMNAME,DA08MNM\nMEMBX    EQU   *\n         TM    22(R6),X'80'        PASSWORD SPECIFIED?\n         BZ    PASSX               NO - BRANCH\n         LH    R1,20(,R6)          GET LENGTH OF PSWD\n         BCTR  R1,0                MINUS 1 FOR EX\n         L     R14,16(,R6)         GET ADDRESS OF PSWD\n         B     *+10\n         MVC   DA08PSWD(0),0(R14)  MOVE PSWD\n         EX    R1,*-6\nPASSX    EQU   *\n         LA    R1,MYDAPL\n         SPACE\n         BAL   R14,CALLDAIR\n         LTR   R15,R15\n         BZ    OKDAIR\n         BAL   R14,DAIRFAIL\n         B     NEXTD12\nOKDAIR   EQU   *\n         OI    STATUS,X'40'        TELL CLEANUP TO FREE IT\n         LA    R15,MYDAPB\n         MVC   DDSAVE,DA08DDN\n         TM    DA08DSO,X'40'       IS DSORG SEQUENTIAL?\n         BO    OKDSORG             YES - BRANCH\n         TM    DA08DSO,X'02'       IS DSORG PARTITIONED?\n         BO    OKDSORGP            YES, BRANCH\n*\n*              DSORG IS NEITHER PS NOR PO\n*              ISAM=X'80' DA=X'20' VSAM=X'00' NONE=X'00'\n*\nERRDSORG LA    R1,MSG06\n         LA    R0,L'MSG06\n         BAL   R14,PUTMSG\n         B     QUITD12\nOKDSORGP EQU   *\n         CLC   DA08MNM,=CL8' '     WAS MEMBER SPECIFIED?\n         BNE   OKDSORG             YES - BRANCH\n         LA    R1,MSG07\n         LA    R0,L'MSG07\n         BAL   R14,PUTMSG\n         B     NEXTD12\nOKDSORG  EQU   *\n         DROP  R15                 DAPB08\n         SPACE\nFILESPEC EQU   *\n         SPACE\n************************************************************\n*                                                          *\n*        SET UP THE DCB                                    *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R4,DYNDCBW\n         USING IHADCB,R4\n         MVC   0(DYNDCBL,R4),DYNDCB\n         MVC   DCBDDNAM(8),DDSAVE\n         SPACE\n         LA    R5,DYNDCBEW\n         USING DCBE,R5\n         MVC   0(DYNDCBEL,R5),DYNDCBE\n         ST    R5,DCBDCBE\n         SPACE\n         LA    R15,DYNEOD\n         ST    R15,DCBEEODA\n         SPACE\n         LA    R15,DYNSYNAD\n         ST    R15,DCBESYNA\n         SPACE\n         LA    R15,DYNEXLST\n         IC    R0,DCBEXLSA-1\n         ST    R15,DCBEXLSA-1      EXLST=DYNEXLST\n         STC   R0,DCBEXLSA-1\n         LA    R1,OPENEXIT         EXIT BELOW THE LINE\n         MVC   0(GLUELEN,R1),GLUE   WILL CONTAIN GLUE\n         ST    R1,0(,R15)          STORE IN 1ST EXLST WORD\n         MVI   0(R15),X'05'        MARK TYPE OF EXIT\n         LA    R0,DYNOPENX         EXIT ABOVE THE LINE\n         ST    R0,OPENEXAD         SAVE ITS ADDRESS\n         OI    OPENEXAD,X'80'      MAKE IT RUN IN31-BIT MODE\n         SPACE\n         LA    R1,ABENDXIT         EXIT BELOW THE LINE\n         MVC   0(GLUELEN,R1),GLUE   WILL CONTAIN GLUE\n         ST    R1,4(,R15)          STORE IN 2ND EXLST WORD\n         MVI   4(R15),128+X'11'    OPEN ABEND EXIT (MVS)\n         LA    R0,DYNABEND         EXIT ABOVE THE LINE\n         ST    R0,ABENDXAD         SAVE ITS ADDRESS\n         OI    ABENDXAD,X'80'      MAKE IT RUN IN31-BIT MODE\n         SPACE\n         OI    STATUS,X'80'        TELL CLEANUP TO CLOSE DCB\n         MVC   OPEND(OPEN31L),OPEN31\n         SPACE\n         OPEN  ((R4),INPUT),MODE=31,MF=(E,OPEND)\n         SPACE\n*        TM    DCBOFLGS,X'10'\n*        TM    DCBEFLG1,DCBEOPEN+DCBEMD31\n         TM    DCBEFLG1,DCBEOPEN\n         BO    OKOPEN\n         LA    R1,MSG08\n         LA    R0,L'MSG08\n         TM    STATUS,X'10'        MEMBER NOT FOUND?\n         BO    DYNOPENM            YES, BRANCH\n         LA    R1,MSG04\n         LA    R0,L'MSG04\nDYNOPENM BAL   R14,PUTMSG\n         B     QUITD12\n         SPACE\nDYNOPENX BSM   0,R14\n         SPACE\nDYNABEND L     R8,0(,R1)           GET COMPLETION CODE\n         N     R8,=A(X'FFF0FF00')\n         CL    R8,=A(X'01301800')  IS IT AN 013-18 ABEND\n         BE    DYNABENY            YES, BRANCH\n         MVI   4(R1),0             NO, ABNORMALLY TERMINATE\n         BSM   0,R14\nDYNABENY OI    STATUS,X'10'        INDICATE MEMBER NOT FOUND\n         MVI   3(R1),4             IGNORE THE ABEND\n         BSM   0,R14\n         SPACE\nOKOPEN   EQU   *\n         BAL   R14,MD5INIT         SET UP FOR MD5\n         SPACE\nREADLOOP EQU   *\n         MVI   SYNADSW,0           SET SYNAD SWITCH OFF\n         SPACE\n         GET   (R4)\n         SPACE\n         CLI   SYNADSW,0           WAS SYNAD EXIT TAKEN?\n         BE    OKGET               NO - BRANCH\n         LA    R1,SYNADMSG\n         LA    R0,78\n         BAL   R14,PUTMSG\n         B     QUITD12\nOKGET    EQU   *\n         BAL   R14,MD5REC\n         LA    R14,1\n         A     R14,KOUNT\n         ST    R14,KOUNT\n         B     READLOOP\n         SPACE\nMD5INIT  LA    R1,MD5ARGS\n         LA    R15,MD5LEN\n         ST    R15,4(,R1)          ARG 2 IS WORD CONTAINING LENGTH\n         LA    R15,MD5CTX\n         ST    R15,8(,R1)          ARG 3 IS CONTEXT 22 WORDS\n         XC    0(88,R15),0(R15)    CLEAR THE CONTEXT\n         LA    R15,MD5RES\n         ST    R15,12(,R1)         ARG 4 IS RESULT\n         LA    R15,MD5WRK\n         ST    R15,16(,R1)         ARG 5 IS WORKSPACE 44 WORDS\n         BR    R14\n         SPACE\nMD5REC   ST    R14,MD5SAVE\n         LH    R0,DCBLRECL         GET RECORD LENGTH IF RECFM U OR FB\n         TM    DCBRECFM,X'C0'      IF RECFM U\n         BO    MD5RECX               BRANCH\n         TM    DCBRECFM,X'40'      IF RECFM V\n         BO    MD5RECV               BRANCH\n         TM    DCBRECFM,X'10'      IF RECFM FB\n         BO    MD5RECX               BRANCH\n         LH    R0,DCBBLKSI         GET RECORD LENGTH IF RECFM F\n         B     MD5RECX               BRANCH\nMD5RECV  CLI   RDWKW+1,1           IF RDW WAS SPECIFIED\n         BE    MD5RECX               INCLUDE RDW\n         LH    R0,0(,R1)           GET RECORD LENGTH +4 FROM RDW\n         SH    R0,=H'4'            SUBTRACT 4 TO EXCLUDE RDW\n         LA    R1,4(,R1)           GET RECORD ADDRESS AFTER RDW\nMD5RECX  ST    R0,MD5LEN           STORE RECORD LENGTH\n         LR    R15,R1              RECORD ADDRESS TO R15\n         LA    R1,MD5ARGS          SET R1 FOR CALL\n         ST    R15,0(,R1)          STORE RECORD ADDRESS AS FIRST ARG\n         L     R15,=V(MD5)         SET R15 FOR CALL\n         BALR  R14,R15             CALL MD5(RECORD,LEN,CTX,HEX,WORK)\n         L     R14,MD5SAVE\n         BR    R14\n         SPACE\nMD5LAST  ST    R14,MD5SAVE\n         SR    R0,R0               STORE RECORD ADDRESS\n         ST    R0,MD5LEN           STORE RECORD LENGTH\n         LA    R1,MD5ARGS\n         L     R15,=V(MD5)\n         BALR  R14,R15             CALL MD5(RECORD,LEN,CTX,HEX,WORK)\n         L     R14,MD5SAVE\n         BR    R14\n         SPACE\nDYNEOD   EQU   *\n         BAL   R14,MD5LAST\n         MVC   MSGWK(32),MD5RES\n         MVI   MSGWK+32,C' '\n         MVI   MSGWK+33,C'*'\n         LA    R14,DSNAME\n         LH    R1,0(,R14)\n         BCTR  R1,0\n         B     *+10\n         MVC   MSGWK+34(0),2(R14)\n         EX    R1,*-6\n         LA    R15,MSGWK+35(R1)    POINT PAST LAST BYTE\n*        TM    14(R6),X'80'        MEMBER SPECIFIED?\n         CLI   MEMLEN+1,0          MEMBER ALLOCATED?\n         BZ    MEMAX               NO - BRANCH\n         MVI   0(R15),C'('\n         LA    R15,1(,R15)\n*        LH    R1,12(,R6)          GET LENGTH OF MEMBER\n         LH    R1,MEMLEN           GET LENGTH OF MEMBER\n         BCTR  R1,0                MINUS 1 FOR EX\n*        L     R14,8(,R6)          GET ADDRESS OF MEMBER NAME\n         LA    R14,MEMNAME\n         B     *+10\n         MVC   0(0,R15),0(R14)     MOVE MEMBER NAME\n         EX    R1,*-6\n         LA    R15,1(R1,R15)       POINT PAST LAST BYTE\n         MVI   0(R15),C')'\n         LA    R15,1(,R15)\nMEMAX    EQU   *\n         LA    R1,MSGWK\n         LR    R0,R15              POINT PAST LAST BYTE\n         SR    R0,R1               COMPUTE MESSAGE LENGTH\n         CLI   LOWKW+1,1           IF 'LOWER' SPECIFIED\n         BNE   LOWX\n         LR    R14,R0\n         BCTR  R14,0                  GET LENGTH MINUS 1\n         B     *+10\n         TR    MSGWK(0),LOWTABLE      TRANSLATE TO LOWER CASE\n         EX    R14,*-6\nLOWX     EQU   *\n         LA    R1,MSGWK\n         BAL   R14,PUTLINE\n         B     QUITDSN\n         SPACE\nQUITD12  MVI   RETCODE+1,12\n         SPACE\nQUITDSN  TM    STATUS,X'80'\n         BZ    NOCLOSE\n*        TM    DCBOFLGS,X'10'      IS IT OPEN?\n         TM    DCBEFLG1,DCBEOPEN\n         BZ    NOCLOSE             NO, BRANCH\n         MVC   CLOSED(CLOSE31L),CLOSE31\n         CLOSE ((R4)),MODE=31,MF=(E,CLOSED)\n         NI    STATUS,255-X'80'    CLOSED\n         DROP  R4                  IHADCB\nNOCLOSE  EQU   *\n         TM    STATUS,X'40'        FREE REQUIRED?\n         BZ    NOFREE\n         LA    R1,MYDAPL\n         LA    R15,MYDAPB\n         USING DAPB18,R15\n         XC    0(40,R15),0(R15)\n         MVI   DA18CD+1,X'18'\n         MVC   DA18DDN,DDSAVE\n         MVC   DA18MNM(8),=CL8' '\n         MVC   DA18SCLS(2),=CL8' '\n         BAL   R14,CALLDAIR        UNALLOCATE\n         NI    STATUS,255-X'40'    UNALLOCATED\n         DROP  R15                 DAPB18\nNOFREE   EQU   *\n         B     NEXTDSN\n         SPACE\nDONE     TM    MYPUTLEP,X'80'     WAS PUTLINE LOADED?\n         BO    NODELETE           NO - USED CVTPUTL - BRANCH\n         LA    R0,=CL8'IKJPUTL '\n         DELETE EPLOC=(0)\nNODELETE EQU   *\n         SPACE\n         IKJRLSA MYANS\n         SPACE\n         CLI   RETCODE+1,0         IS RETCODE ZERO?\n         BZ    STACKDX             YES, BRANCH\n         MVC   MYSTPB(STACKDL),STACKD\n         SPACE\n         STACK DELETE=ALL,PARM=MYSTPB,MF=(E,MYIOPL)\n         SPACE\n         TCLEARQ\nSTACKDX  EQU   *\n         SPACE\n         LH    R15,RETCODE\n         B     EXIT\n         SPACE\n************************************************************\n*                                                          *\n*         CALL IKJDAIR SERVICE ROUTINE                     *\n*                                                          *\n************************************************************\n          SPACE\nCALLDAIR ST    R14,DAIRREGS\n         L     R15,16\n         TM    732(R15),X'80'     CVTDAIR\n         BNO   DAIRLINK\n         L     R15,732(,R15)\n         BALR  R14,R15\n         B     DAIRFINI\nDAIRLINK EQU   *\n         LINK  EP=IKJDAIR,SF=(E,LINKAREA)\nDAIRFINI L     R14,DAIRREGS\n         BR    R14\n         SPACE\n************************************************************\n*                                                          *\n*        DYNAMIC ALLOCATION FAILURE ROUTINE                *\n*                                                          *\n************************************************************\n         SPACE\nDAIRFAIL ST    R14,MYDFREGS\n         LA    R1,MYDFPARM\n         USING DFDSECTD,R1\n         ST    R15,MYDFRC\n         LA    R15,MYDFRC\n         ST    R15,DFRCP\n         LA    R15,MYDAPL\n         ST    R15,DFDAPLP\n         SLR   R15,R15\n         ST    R15,MYJEFF02\n         LA    R15,MYJEFF02\n         ST    R15,DFJEFF02\n         LA    R15,DFDAIR\n         STH   R15,MYDFID\n         LA    R15,MYDFID\n         ST    R15,DFIDP\n         SLR   R15,R15\n         ST    R15,DFCPPLP\n         LINK  EP=IKJEFF18,SF=(E,LINKAREA)\n         L     R15,MYDFRC\n         DROP  R1                  DFDSECTD\n         L     R14,MYDFREGS\n         BR    R14\n         SPACE\n************************************************************\n*                                                          *\n*        PUTMSG ROUTINE                                    *\n*                                                          *\n************************************************************\n         SPACE\nPUTMSG   STM   R14,R1,PUTLINS\n         XC    MYOLD(8),MYOLD\n         XC    MYSEG1(4),MYSEG1\n         MVC   MYPTPB(12),MODLPTPM\n         LA    R14,1               NO. OF MESSAGE SEGMENTS\n         ST    R14,MYOLD\n         LA    R14,MYSEG1          POINT TO 1ST SEGMENT\n         ST    R14,MYOLD+4\n         LR    R14,R0              LENGTH IN R0\n         LA    R14,4(,R14)         ADD 4\n         LA    R15,MYSEG1+4\n         CLC   0(3,R1),=C'IKJ'     IS DATA PRECEEDED BY MESSAGE ID?\n         BE    *+16                YES - BRANCH\n         LA    R14,1(,R14)         ADD 1 TO LENGTH\n         MVI   0(R15),C' '         INSERT LEADING BLANK\n         LA    R15,1(,R15)         BUMP POINTER\n         STH   R14,MYSEG1\n         LR    R14,R0\n         BCTR  R14,0\n         B     *+10\n         MVC   0(0,R15),0(R1)      MOVE MESSAGE IN\n         EX    R14,*-6\n         L     R15,MYPUTLEP\n         SPACE\n         PUTLINE PARM=MYPTPB,OUTPUT=(MYOLD),ENTRY=(15),MF=(E,MYIOPL)\n         SPACE\n         LM    R14,R1,PUTLINS\n         BR    R14\n         SPACE\n************************************************************\n*                                                          *\n*        PUTLINE ROUTINE                                   *\n*                                                          *\n************************************************************\n         SPACE\nPUTLINE  STM   R14,R1,PUTLINS\n         XC    MYSEG1(4),MYSEG1\n         MVC   MYPTPB(12),MODLPTPB\n         LR    R14,R0              LENGTH IN R0\n         LA    R14,4(,R14)         ADD 4\n         STH   R14,MYSEG1\n         LR    R14,R0\n         BCTR  R14,0\n         B     *+10\n         MVC   MYSEG1+4(0),0(R1)   MOVE TEXT IN\n         EX    R14,*-6\n         LA    R1,MYIOPL\n         L     R15,MYPUTLEP\n         SPACE\n         PUTLINE PARM=MYPTPB,OUTPUT=(MYSEG1,DATA),ENTRY=(15),MF=(E,(1))\n         SPACE\n         LM    R14,R1,PUTLINS\n         BR    R14\n         SPACE 1\n*RRRECFM LA    R1,MSGRECFM\n*        LA    R0,L'MSGRECFM\n*        BAL   R14,PUTMSG\n*        B     QUITD12\n         SPACE\nEXIT     LR    R2,R15              SAVE R15\n         LR    R1,R10\n         L     R0,@SIZE24\n         FREEMAIN R,A=(1),LV=(0)\n         SPACE\n         LR    R1,R13\n         L     R0,@SIZE31\n         L     13,4(,13)\n         FREEMAIN RU,A=(1),LV=(0),SP=1\n         LR    R15,R2              RESTORE R15\n         LM    0,12,20(13)\n         L     14,12(,13)\n         BR    14\n         SPACE\n************************************************************\n*                                                          *\n*        SYNAD EXIT                                        *\n*                                                          *\n************************************************************\n         SPACE\n*        THIS ROUTINE IS ENTERED DURING THE 'GET' MACRO\n*        IF AN I/O ERROR OCCURS.\n         SPACE\nDYNSYNAD EQU   *\n         SYNADAF ACSMETH=QSAM\n         MVC   SYNADMSG(78),50(R1)\n         MVI   SYNADSW,X'FF'\n         SYNADRLS\n         BR    R14\n         SPACE\n************************************************************\n*                                                          *\n*        GLUE FOR DCB EXITS                                *\n*                                                          *\n************************************************************\n         SPACE\n*        THESE 2 INSTRUCTIONS ARE COPIED TO ABENDXIT, BELOW THE LINE,\n*        AND RUN THERE, NOT HERE. WHEN ABENDXIT IS ENTERED,\n*        R15 CONTAINS THE ENTRY ADDRESS, THE ADDRESS OF ABENDXIT.\n*        THEN USING R15 AS A BASE REGISTER, IT LOADS R15 FROM ABENDXAD,\n*        WHICH CONTAINS THE ADDRESS OF DYNABEND ABOVE THE LINE,\n*        WITH THE HIGH-ORDER BIT SET TO 1. THEN IT USES BSM TO\n*        BRANCH TO DYNABEND IN 31-BIT MODE. THE ROUTINE AT\n*        DYNABEND SHOULD RETURN USING 'BSM 0,R14'.\n*\nGLUE     L     R15,ABENDXAD-ABENDXIT(,R15)\n         BSM   R14,R15  OLD MODE INTO R14 HI BIT, BRANCH TO R15 IN 31\nGLUELEN  EQU   *-GLUE\n         SPACE\n*        SINCE ABENDXAD-ABENDEXIT IS IDENTICAL TO OPENEXAD-OPENEXIT\n*        THE FOLLOWING IS NOT REALLY NEEDED.\n         SPACE\nGLUE2    L     R15,OPENEXAD-OPENEXIT(,R15)\n         BSM   R14,R15  OLD MODE INTO R14 HI BIT, BRANCH TO R15 IN 31\nGLUELEN2 EQU   *-GLUE2\n         SPACE\n************************************************************\n*                                                          *\n*        CONSTANTS                                         *\n*                                                          *\n************************************************************\n         SPACE\nMODLPTPM PUTLINE OUTPUT=(1,TERM,SINGLE,INFOR),                         X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=L\n         SPACE\nMODLPTPB PUTLINE OUTPUT=(1,TERM,SINGLE,DATA),                          X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=L\n         SPACE\n*        PRINT NOGEN\n         SPACE\nOPEN31   OPEN  (0,),MODE=31,MF=L\nOPEN31L  EQU   *-OPEN31\nCLOSE31  CLOSE (0,),MODE=31,MF=L\nCLOSE31L EQU   *-CLOSE31\n         SPACE\nDYNDCB   DCB   DDNAME=DYNAM,DSORG=PS,MACRF=(GL),                       +\n               EODAD=0,SYNAD=0,EROPT=ACC,DCBE=0\nDYNDCBL  EQU   *-DYNDCB\n         SPACE\nDYNDCBE  DCBE  RMODE31=BUFF,EODAD=1\nDYNDCBEL EQU   *-DYNDCBE\n         SPACE\n         PRINT GEN\n         SPACE\nSTACKD   STACK DELETE=ALL,MF=L\nSTACKDL  EQU   *-STACKD\n         SPACE\nMSG01    DC    C'ERROR IN PARSE SERVICE ROUTINE'\nMSG02    DC    C'IKJ58503I DATA SET '\nMSG02A   DC    C' NOT IN CATALOG'\nMSG03    DC    C'ERROR IN DEFAULT SERVICE ROUTINE'\nMSG04    DC    C'UNABLE TO OPEN DATASET'\nMSG05    DC    C'IKJ58509I DATA SET NAME REQUIRED WHEN MEMBER IS SPECIF+\n               IED'\nMSG06    DC    C'ORGANIZATION OF DATA SET MUST BE PARTITIONED OR SEQUEN+\n               TIAL'\nMSG07    DC    C'DATA SET IS PARTITIONED, MEMBER NOT SPECIFIED'\nMSG08    DC    C'SPECIFIED MEMBER NOT FOUND IN DATASET'\nMSG09    DC    C'IKJ56709I INVALID DSN LENGTH, '\nMSG14    DC    C'FILENAME '\nMSG14A   DC    C' INVALID, MORE THAN 8 CHARACTERS  '\nMSG14B   DC    C' IS NOT CURRENTLY ALLOCATED       '\nMSG14C   DC    C' NOT ALLOCATED TO A DASD DATA SET '\n*SGRECFM DC    C'RECORD FORMAT U NOT SUPPORTED'\n*MSGDAIR DC    C'UNABLE TO ALLOCATE'\nLOWTABLE DC    0D'0',256AL1(*-LOWTABLE)\n         ORG   LOWTABLE+C'A'\n         DC    X'818283848586878889'\n         ORG   LOWTABLE+C'J'\n         DC    X'919293949596979899'\n         ORG   LOWTABLE+C'S'\n         DC    X'A2A3A4A5A6A7A8A9'\n         ORG\n         LTORG\nPCLADDR  DC    0D'0'               END OF CSECT\n         SPACE\n************************************************************\n*                                                          *\n*        PARSE PARAMETERS                                  *\n*                                                          *\n************************************************************\n         SPACE\n         PRINT NOGEN\nMD5SMPCL RMODE 31\nMD5SMPCL IKJPARM\nDSN      IKJPOSIT DSNAME,LIST,PROMPT='DATA SET NAME'\nFILEKW   IKJKEYWD\n         IKJNAME 'FILE'\nQUICKW   IKJKEYWD\n         IKJNAME 'QUICK'\nRDWKW    IKJKEYWD\n         IKJNAME 'RDW'\nLOWKW    IKJKEYWD\n         IKJNAME 'LOWER'\n         IKJENDP\n         PRINT GEN\n         SPACE\n************************************************************\n*                                                          *\n*        DSECTS                                            *\n*                                                          *\n************************************************************\n         SPACE\n@DATA31  DSECT\n         DS    18F                 REGISTER SAVEAREA\nLINKAREA DS    2F\nMYPPL    DS    7F\nMYANS    DS    F\nMYECB    DS    F                  USED BY PUTLINE ROUTINE\nMYIOPL   DS    4F                 USED BY PUTLINE ROUTINE\nMYPTPB   DS    3F                 USED BY PUTLINE ROUTINE\nMYOLD    DS    2F                 USED BY PUTLINE ROUTINE\nMYSEG1   DS    2H,CL256           USED BY PUTLINE ROUTINE\nPUTLINS  DS    4F                 USED BY PUTLINE ROUTINE\nMYPUTLEP DS    F                  ADDRESS OF IKJPUTL\nMYSTPB   DS    0F                 5 WORDS USED BY STACK DELETE\nMYDAPL   DS    5F\nMYDAPB   DS    21F\nDSNAME   DS    H,CL44\nMEMLEN   DS    H\nMEMNAME  DS    CL8\nMSGWK    DS    CL128\nSTATUS   DS    X\nRETCODE  DS    H\nMYDFPARM DS    5F  USED BY DAIRFAIL\nMYDFREGS DS    F   USED BY DAIRFAIL\nMYDFRC   DS    F   USED BY DAIRFAIL\nMYJEFF02 DS    F   USED BY DAIRFAIL\nMYDFID   DS    H   USED BY DAIRFAIL\nDOUBLE   DS    D\nEIGHT    DS    CL8\nDDSAVE   DS    CL8\nDAIRREGS DS    F\nOPEND    DS    0F,(OPEN31L)X\nCLOSED   DS    0F,(CLOSE31L)X\nDYNDCBEW DS    0F,(DYNDCBEL)X\nKOUNT    DS    F\nKOUNTSP  DS    F\nSYNADSW  DS    F\nSYNADMSG DS    CL78\nDEVDATA  DS    2F\nMD5ARGS  DS    5F\nMD5LEN   DS    F\nMD5CTX   DS    22F\nMD5RES   DS    8F\nMD5WRK   DS    44F\nMD5SAVE  DS    F\n         DS    0D\n@DATA31L EQU   *-@DATA31\n         SPACE\n@DATA24  DSECT\nSAVE24   DS    18F                USED BY IKJEHDEF\nRDJFW    DS    F\nMYIOPL24 DS    4F                 USED BY IKJEHDEF\nMYECB24  DS    F\nMYDFPB   DS    5F\nDSNAME24 DS    H,CL44\nDYNDCBW  DS    0D,XL(DYNDCBL)\nDYNEXLST DS    2F\nOPENEXIT DS    0H,(GLUELEN)X\nOPENEXAD DS    F  X'80' + ADDRESS OF DYNOPENX\nABENDXIT DS    0H,(GLUELEN)X\nABENDXAD DS    F  X'80' + ADDRESS OF DYNABEND\nJFCB     DS    0F,CL176\nMYARL    DS    9F\n         DS    0D\n@DATA24L EQU   *-@DATA24\n         SPACE\nIHADCB   DSECT\nDCBDCBE  DS    A\n         DS    28XL1\nDCBBFTEK DS    XL1\nDCBEODAD DS    AL3\nDCBRECFM DS    X\nDCBEXLSA DS    AL3\nDCBDDNAM DS    CL8\nDCBOFLGS DS    X\n         DS    7XL1\n         DS    X\nDCBSYNAD DS    AL3\nDCBBLKSI EQU   IHADCB+62,2\nDCBLRECL EQU   IHADCB+82,2\n         SPACE\n         IHADCBE\n         SPACE\nEFLG1    EQU   16\nEOPEN    EQU   X'80'\nEMD31    EQU   X'40'\nEEODA    EQU   40\nESYNA    EQU   44\n         SPACE\nXFLG1    EQU   DCBEFLG1-DCBE\nXOPEN    EQU   DCBEOPEN\nXMD31    EQU   DCBEMD31\nXEODA    EQU   DCBEEODA-DCBE\nXSYNA    EQU   DCBESYNA-DCBE\n         PRINT NOGEN\n         SPACE\n         IKJCPPL\n         SPACE 3\n         IKJPPL\n         SPACE\n         IKJDFPB\n         SPACE 2\n         IKJUPT\n         SPACE 2\n         IKJIOPL\n         SPACE 2\n         IKJDAPL\n         SPACE 2\n         IKJDAP08\n         SPACE 2\n         IKJDAP18\n         SPACE 2\n         IKJPSCB\n         SPACE 2\n         IKJEFFDF DFDSECT=YES\n         SPACE\n         IHAARL\n         SPACE\n         IHAARA\n         SPACE\n*        CVT   DSECT=YES\n         SPACE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MD5SUM$": {"ttr": 4101, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x131o\\x01\\x131o\\x14\\x15\\x00\\x13\\x00\\x16\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2013-11-12T00:00:00", "modifydate": "2013-11-12T14:15:00", "lines": 19, "newlines": 22, "modlines": 0, "user": "UPDATED"}, "text": "//CBTUSER1 JOB (ACCT),'PGMR',NOTIFY=CBTUSER,\n//         MSGLEVEL=(1,1),MSGCLASS=H\n//* ASSEMBLE THE 31-BIT MD5SUM TSO COMMAND AND THE MD5 SUBROUTINE\n//ASM    EXEC PGM=ASMA90,PARM=(OBJ,NODECK,TERM,NOXREF,BATCH,\n//             ASA,NODX,NOMX,NORX,RLD,NOUS,'PC(NOUHD)')\n//SYSPRINT DD  SYSOUT=*\n//SYSTERM  DD  SYSOUT=*\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//SYSLIN   DD  DSNAME=&&OBJ,DISP=(NEW,PASS),\n//             UNIT=SYSDA,SPACE=(TRK,(3,0)),\n//             DCB=(BLKSIZE=3200)\n//SYSIN    DD  DSN=CBTUSER.LIB.ASM(MD5SUM),DISP=SHR\n//         DD  DSN=CBTUSER.LIB.ASM(MD5),DISP=SHR\n//LKED   EXEC PGM=HEWLKED,PARM='LIST,MAP,RENT,REFR',\n//             COND=(0,NE)\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSNAME=&&OBJ,DISP=(OLD,DELETE)\n//SYSLMOD  DD  DSNAME=CBTUSER.LIB.LOAD(MD5SUM),DISP=SHR\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(TRK,(10,0))\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MD5SUM#": {"ttr": 4103, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x131_\\x01\\x131_\\x11\\x11\\x00\\x17\\x00\\x17\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2013-11-11T00:00:00", "modifydate": "2013-11-11T11:11:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "UPDATED"}, "text": ")F FUNCTION -\n  THE MD5SUM COMMAND DISPLAYS THE MD5 CHECKSUM OF DATA SETS SPECIFIED.\n  IN DATA SETS WITH VARIABLE-LENGTH RECORDS THE RDW'S AND SDW'S ARE\n  NOT INCLUDED WHEN THE CHECKSUM IS COMPUTED UNLESS THE RDW KEYWORD\n  IS SPECIFIED.\n)X SYNTAX -\n         MD5SUM   'DSLIST'  FILE  LOWER  RDW  QUICK\n\n  REQUIRED - 'DSLIST'\n  DEFAULTS - NONE\n\n)O OPERANDS -\n  'DSLIST' - NAMES OF SEQUENTIAL DATA SETS OR MEMBERS OF PARTITIONED\n             DATA SETS.\n))FILE     - THE NAMES IN DSLIST ARE DDNAMES, NOT DSNAMES.\n))LOWER    - DISPLAY THE RESULTS IN LOWER CASE.\n))RDW      - INCLUDE RDW OR SDW IN VARIABLE LENGTH RECORDS.\n))QUICK    - FOR UNQUOTED DSNAMES, BYPASS THE DEFAULT SERVICE ROUTINE.\n             SO FOR EXAMPLE, IF YOU SPECIFY THE NAME TEMP AND YOU\n             ONLY HAVE A DATA SET NAMED TEMP.DATA, IT WON'T BE FOUND\n             IF QUICK IS ALSO SPECIFIED. THE QUICK KEYWORD IS JUST\n             TO CUT OUT THE OVERHEAD OF LOOKING FOR EXTENSIONS AT\n             THE END OF THE SPECIFIED DATA SET NAME.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MD5SUMA$": {"ttr": 4105, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x131_\\x01\\x131_\\x11\\x11\\x00!\\x00\"\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2013-11-11T00:00:00", "modifydate": "2013-11-11T11:11:00", "lines": 33, "newlines": 34, "modlines": 0, "user": "UPDATED"}, "text": "//CBTUSER1 JOB (ACCT),'PGMR',NOTIFY=CBTUSER,\n//         MSGLEVEL=(1,1),MSGCLASS=H\n//* ASSEMBLE MD5SUM TSO COMMAND AND MD5 SUBROUTINE,\n//* USING IFOX00 ASSEMBLER.\n//* SOURCE MEMBER MD5A IS MD5 MODIFIED FOR IFOX00\n//* BUT GENERATES EXACTLY THE SAME CODE AS MD5 WITH ASMA90.\n//* THE 1ST ASSEMBLY WILL FAIL IF SYS1.MACLIB IS NOT FROM MVS370 SYSTEM\n//* BECAUSE IFOX00 CAN'T HANDLE SYSTEM MACROS FROM NEWER SYSTEMS.\n//ASM    EXEC PGM=IFOX00,REGION=0M,PARM='OBJ,NODECK,TERM,NOXREF'\n//SYSPRINT DD  SYSOUT=*\n//SYSTERM  DD  SYSOUT=*\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//SYSGO    DD  DSNAME=&&OBJ,DISP=(NEW,PASS),\n//             UNIT=SYSDA,SPACE=(TRK,(3,0)),\n//             DCB=(BLKSIZE=3200)\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(CYL,(3,0))\n//SYSUT2   DD  UNIT=SYSALLDA,SPACE=(CYL,(1,0))\n//SYSUT3   DD  UNIT=SYSALLDA,SPACE=(CYL,(1,0))\n//SYSIN    DD  DSN=CBTUSER.LIB.ASM(MD5SUM24),DISP=SHR\n//ASM    EXEC PGM=IFOX00,PARM='OBJ,NODECK,TERM,NOXREF',COND=(0,NE)\n//SYSPRINT DD  SYSOUT=*\n//SYSTERM  DD  SYSOUT=*\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//SYSGO    DD  DSNAME=&&OBJ,DISP=(MOD,PASS)\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(CYL,(3,0))\n//SYSUT2   DD  UNIT=SYSALLDA,SPACE=(CYL,(1,0))\n//SYSUT3   DD  UNIT=SYSALLDA,SPACE=(CYL,(1,0))\n//SYSIN    DD  DSN=CBTUSER.LIB.ASM(MD5A),DISP=SHR\n//LKED   EXEC PGM=HEWLF064,PARM='LIST,MAP,RENT,REFR',COND=(0,NE)\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSNAME=&&OBJ,DISP=(OLD,DELETE)\n//SYSLMOD  DD  DSNAME=CBTUSER.LIB.LOAD(MD5SUM),DISP=SHR\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(TRK,(10,0))\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MD5SUM2$": {"ttr": 4107, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x131_\\x01\\x131_\\x11\\x11\\x00\\x13\\x00\\x16\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2013-11-11T00:00:00", "modifydate": "2013-11-11T11:11:00", "lines": 19, "newlines": 22, "modlines": 0, "user": "UPDATED"}, "text": "//CBTUSER1 JOB (ACCT),'PGMR',NOTIFY=CBTUSER,\n//         MSGLEVEL=(1,1),MSGCLASS=H\n//* ASSEMBLE THE 24-BIT MD5SUM TSO COMMAND AND THE MD5 SUBROUTINE\n//ASM    EXEC PGM=ASMA90,PARM=(OBJ,NODECK,TERM,NOXREF,BATCH,\n//             ASA,NODX,NOMX,NORX,RLD,NOUS,'PC(NOUHD)')\n//SYSPRINT DD  SYSOUT=*\n//SYSTERM  DD  SYSOUT=*\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//SYSLIN   DD  DSNAME=&&OBJ,DISP=(NEW,PASS),\n//             UNIT=SYSDA,SPACE=(TRK,(3,0)),\n//             DCB=(BLKSIZE=3200)\n//SYSIN    DD  DSN=CBTUSER.LIB.ASM(MD5SUM24),DISP=SHR\n//         DD  DSN=CBTUSER.LIB.ASM(MD5),DISP=SHR\n//LKED   EXEC PGM=HEWLKED,PARM='LIST,MAP,RENT,REFR',\n//             COND=(0,NE)\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSNAME=&&OBJ,DISP=(OLD,DELETE)\n//SYSLMOD  DD  DSNAME=CBTUSER.LIB.LOAD(MD5SUM),DISP=SHR\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(TRK,(10,0))\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MD5SUM24": {"ttr": 4109, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x002\\x01\\x131_\\x01\\x16$\\x7f#&\\x04y\\x04k\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2013-11-11T00:00:00", "modifydate": "2016-09-03T23:26:32", "lines": 1145, "newlines": 1131, "modlines": 0, "user": "UPDATED"}, "text": "         TITLE '   M D 5 S U M  '\n************************************************************\n*                                                          *\n*        'MD5SUM' TSO COMMAND                              *\n*                                                          *\n************************************************************\n         SPACE\n*        WRITTEN OCTOBER 12 2013\n*        UPDATED NOV 11 2013 TO SUPPORT LIST OF DSNAMES.\n*        UPDATED NOV 19 2013 TO SHOW MEMBER WHEN DDNAME USED.\n*        UPDATED AUG 28 2016 TO IGNORE DS1LSTAR WHICH IS 0 FOR PDSE\n*        UPDATED SEP  3 2016 TO SET RETURN CODE 12 IF ANY ERROR\n*        ATTRIBUTES. RE-ENTRANT.\n*\n*        MOST OF THE CODE APART FROM THE MD5 SUBROUTINE IS BORROWED\n*        FROM BILL GODFREY'S 'COUNT' TSO COMMAND IN CBT TAPE FILE 300.\n*\n*        THE MD5 SUBROUTINE, WHICH IS ASSEMBLED SEPARATELY FROM THIS,\n*        IS A MODIFIED VERSION OF LELAND LUCIUS' PUBLIC DOMAIN MD5\n*        SUBROUTINE, MODIFIED FOR NON-REXX CALLERS.\n*\n*        THIS TSO COMMAND READS THE SPECIFIED SEQUENTIAL DATA SETS\n*        OR PDS MEMBERS AND DISPLAYS THE MD5 CHECKSUM FOR EACH.\n*\n*        IF AN UNQUALIFIED DATA SET NAME IS ENTERED, THE\n*        CATALOG MUST BE READ TWICE, ONCE TO APPEND A\n*        TRAILING QUALIFIER IF NECESSARY, AND AGAIN DURING\n*        ALLOCATION. THE USER CAN ELIMINATE THE FIRST BY USING\n*        THE FULLY QUALIFIED NAME, PREFIX AND ALL, IN QUOTES,\n*        OR BY ENTERING ALL BUT THE PREFIX, WITHOUT QUOTES,\n*        PLUS THE KEYWORD 'Q'. THE LATTER IS MUCH SIMPLER\n*        AND GIVES THE SAME PERFORMANCE IMPROVEMENT AS A\n*        FULLY QUALIFIED NAME.\n*\n*        THE 'FILE' KEYWORD IS USEFUL FOR READING TEMPORARY\n*        DATA SETS.  IT TELLS THE COMMAND TO TREAT THE FIRST\n*        OPERAND AS A FILENAME (DDNAME) INSTEAD OF A DSNAME.\n*        WHATEVER DATA SET IS CURRENTLY ALLOCATED TO THE\n*        FILENAME WILL BE READ (AND QUICKLY, BECAUSE\n*        THE COMMAND DOESNT HAVE TO ALLOCATE ANYTHING).\n*\n*        NOTE - IF A NON-EXISTENT MEMBER OF A PDS IS SPECIFIED,\n*        THE RESULTING 013-18 ABEND IS TRAPPED BY A DCB ABEND\n*        EXIT, BUT A MESSAGE IS ISSUED BY OPEN ANYWAY. THIS\n*        METHOD IS USED BECAUSE THE ADDITIONAL OVERHEAD\n*        OF ALLOCATING THE PDS AND DOING A 'BLDL' WOULD\n*        DEGRADE THE PERFORMANCE UNACCEPTABLY.\n         SPACE\n*\n* CHNGE LOG: 02JUN92 - INCLUDED 'OBTAIN' MACRO IN THE SOURCE. WITH\n*                      MVS/XA 2.2.3, THE MACRO IS ONLY AVAILABLE IN\n*                      'SYS1.AMACLIB' (SOUNDS LIKE IBM IS TRYING TO\n*                      TELL US SOMETHING).  JIM MARSHALL         JDM1\n*\n* CHNGE LOG: 12OCT13 - MD5SUM COMMAND CREATED FROM SOURCE OF 'COUNT'.\n*                      RDW'S ARE NOT INCLUDED IN THE MD5 AT THIS TIME,\n*                      AS A RESULT, 2 FILES OF VARIABLE-LENGTH RECORDS,\n*                      ONE WITH 2 RECORDS \"AB\" AND \"CD\" AND THE OTHER\n*                      ONE WITH 2 RECORDS \"ABC' AND \"D\" WILL HAVE THE\n*                      SAME MD5 VALUE.\n*\n* CHNGE LOG: 11NOV13 - SUPPORT LIST OF DSNAMES, SHOW NAME AFTER MD5.\n*\n* CHNGE LOG: 19NOV13 - SHOW MEMBER NAME IF DDNAME ALLOCATED TO MEMBER.\n*\n         MACRO                                                   JDM1\n&NAME    OBTAIN &LIST,&DUMMY=                                    JDM1\n         AIF   (T'&LIST EQ 'O').E1                               JDM1\n&NAME    IHBINNRA &LIST                 LOAD REG 1               JDM1\n         SVC   27                       ISSUE OBTAIN SVC         JDM1\n         MEXIT                                                   JDM1\n.E1      IHBERMAC 34                    LIST ADDR MISSING        JDM1\n         MEND                                                    JDM1\n*         INTERCEPT 'LINK' MACRO IMBEDDED IN STACK MACRO\n*         TO MAKE SF=(E,LINKAREA) THE DEFAULT.\n         MACRO\n&NAME    LINK  &EP=,&SF=(E,LINKAREA)\n&NAME    LA    15,&SF(2)\n         LA    0,*+8\n         B     *+12\n         DC    CL8'&EP'\n         ST    0,0(0,15)\n         SVC   6             ISSUE LINK SVC\n         MEND\n         SPACE\n         GBLB  &MVS\n&MVS     SETB  1                   1 - MVS   0 - SVS,MVT\n         SPACE\nMD5SUM   START\n         USING *,R12,R11\n         B     @PROLOG-*(,R15)\n         DC    AL1(7),CL7'MD5SUM'\n         DC    CL16' &SYSDATE &SYSTIME '\n@SIZE    DC    0F'0',AL1(1),AL3(@DATAL)\n@PROLOG  STM   14,12,12(13)\n         LR    R12,R15             BASE\n         LA    R15,1\n         LA    R11,4095(R15,R12)   BASE\n         LR    R2,R1\n         USING CPPL,R2\n         L     R0,@SIZE\n         GETMAIN R,LV=(0)\n         LR    R9,R1\n         USING @DATA,R9\n         ST    13,4(,1)            CHAIN SAVEAREA\n         ST    1,8(,13)            CHAIN SAVEAREA\n         LR    13,1                NEW SAVEAREA\n         SPACE 1\n         MVI   STATUS,0\n         XC    LINKAREA(8),LINKAREA\n         SLR   R15,R15\n         STH   R15,RETCODE         SET RETCODE = 0\n         ST    R15,KOUNT\n         ST    R15,KOUNTSP\n         SPACE\n************************************************************\n*                                                          *\n*        SET UP IOPL FOR PUTLINE                           *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R15,MYIOPL\n         USING IOPL,R15\n         MVC   IOPLUPT(4),CPPLUPT\n         MVC   IOPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,IOPLECB\n         XC    MYECB,MYECB\n         LA    R0,MYPTPB\n         ST    R0,IOPLIOPB\n         DROP  R15                 IOPL\n         SPACE\n         AIF   (NOT &MVS).SKIP1\n         L     R15,16              LOAD CVT POINTER\n         TM    444(R15),X'80'      IS PUTLINE LOADED? (VS2)\n         BNO   PUTLOAD             NO - BRANCH TO LOAD\n         L     R15,444(,R15)       YES - USE CVTPUTL\n         B     PUTLOADX            BRANCH AROUND LOAD\n.SKIP1   ANOP\nPUTLOAD  LA    R0,=CL8'IKJPUTL '\n         LOAD  EPLOC=(0)\n         LR    R15,R0              GET ENTRY ADDRESS\n         LA    R15,0(,R15)         CLEAR HI BYTE FOR DELETE ROUTINE\nPUTLOADX ST    R15,MYPUTLEP        SAVE PUTLINE ENTRY ADDRESS\n         SPACE\n************************************************************\n*                                                          *\n*        SET UP PPL FOR PARSE                              *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R15,MYPPL\n         USING PPL,R15\n         MVC   PPLUPT(4),CPPLUPT\n         MVC   PPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,PPLECB\n         XC    MYECB,MYECB\n         L     R0,=A(MD5SMPCL)\n*        LA    R0,PCLADDR\n         ST    R0,PPLPCL\n         LA    R0,MYANS\n         ST    R0,PPLANS\n         XC    MYANS(4),MYANS\n         MVC   PPLCBUF(4),CPPLCBUF\n         ST    R9,PPLUWA\n         DROP  R15                 PPL\n         SPACE 1\n************************************************************\n*                                                          *\n*        CALL THE PARSE SERVICE ROUTINE                    *\n*                                                          *\n************************************************************\n         SPACE 1\n         LR    R1,R15              POINT TO PPL\n         AIF   (NOT &MVS).SKIP2\n         L     R15,16              CVTPTR\n         TM    524(R15),X'80'      IF HI ORDER BIT NOT ON\n         BNO   PARSELNK               THEN DO LINK, NOT CALL\n         L     R15,524(,R15)       CVTPARS\n         BALR  R14,R15             CALL IKJPARS\n         B     PARSEEXT            SKIP AROUND LINK\nPARSELNK EQU   *\n.SKIP2   ANOP\n         LINK  EP=IKJPARS,SF=(E,LINKAREA)\nPARSEEXT EQU   *\n         SPACE 1\n         LTR   R15,R15\n         BZ    PARSEOK\n         LA    R1,MSG01\n         LA    R0,L'MSG01\n         BAL   R14,PUTMSG\n         LA    R15,12\n         B     EXIT\nPARSEOK  EQU   *\n         SPACE\n         L     R3,MYANS\n         USING IKJPARMD,R3\n         SPACE\n************************************************************\n*                                                          *\n*        GET THE FIRST OR NEXT DSN IN THE LIST             *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R6,DSN\n         B     FIRSTDSN\nNEXTDSN  CLI   24(R6),X'FF'        END OF DSN LIST?\n         BE    DONE\n         L     R6,24(,R6)          POINT TO NEXT ENTRY\nFIRSTDSN SR    R0,R0\n         ST    R0,KOUNT\n         SPACE\n************************************************************\n*                                                          *\n*        QUALIFY THE DSNAME IF NECESSARY                   *\n*                                                          *\n************************************************************\n         SPACE\n         TM    6(R6),X'80'         IS DATASET NAME SPECIFIED?\n         BO    OKDSN               YES - BRANCH\n         LA    R1,MSG05            NO - JUST MEMBER NAME\n         LA    R0,L'MSG05\n         BAL   R14,PUTMSG\n         B     NEXTD12\nOKDSN    EQU   *\n         LA    R15,DSNAME+2\n         MVI   0(R15),C' '         BLANK THE DSNAME AREA\n         MVC   1(43,R15),0(R15)\n         SLR   R1,R1\n         STH   R1,DSNAME           ZERO DSNAME LENGTH\n         TM    6(R6),X'40'         IS DSN QUOTED?\n         BO    NOPREF              YES, SKIP PREFIXING\n         CLI   FILEKW+1,1          DSN TO BE TREATED AS DDNAME\n         BE    NOPREF              YES, SKIP PREFIXING\n         AIF   (NOT &MVS).SKIPP    PREFIX WITH PREFIX\n         L     R14,CPPLUPT         POINT TO UPT\n         USING UPT,R14\n         IC    R1,UPTPREFL         GET LENGTH OF PREFIX\n         LTR   R1,R1               IS IT ZERO\n         BZ    NOPREF              YES, SKIP PREFIXING\n         B     *+10\n         MVC   0(0,R15),UPTPREFX\n         DROP  R14                 UPT\n.SKIPP   AIF   (&MVS).SKIPU        PREFIX WITH USERID\n         L     R14,CPPLPSCB        POINT TO PSCB\n         USING PSCB,R14\n         IC    R1,PSCBUSRL         GET LENGTH OF USERID\n         LTR   R1,R1               IS IT ZERO\n         BZ    NOPREF              YES, SKIP PREFIXING\n         B     *+10\n         MVC   0(0,R15),PSCBUSER\n         DROP  R14                 PSCB\n.SKIPU   ANOP\n         EX    R1,*-6              MOVE USERID TO DSNAME AREA\n         LA    R15,0(R1,R15)       POINT PAST USERID\n         MVI   0(R15),C'.'         APPEND PERIOD\n         LA    R15,1(,R15)         POINT PAST PERIOD\n         LA    R1,1(,R1)           ADD 1 TO LENGTH\n         STH   R1,DSNAME           STORE LENGTH OF USERID PLUS 1\nNOPREF   EQU   *\n         LH    R1,4(,R6)           GET LENGTH\n         LR    R0,R1\n         AH    R0,DSNAME           ADD LENGTH OF PREFIX OR ZERO\n         STH   R0,DSNAME           SET COMBINED LENGTH\n         L     R14,0(,R6)          POINT TO DSN VALUE\n         BCTR  R1,0                LENGTH MINUS 1 FOR EX\n         B     *+10                BRANCH AROUND EXECUTED MVC\n         MVC   0(0,R15),0(R14)     (EXECUTED)\n         EX    R1,*-6              MOVE DSN TO DSNAME (AFTER PREFIX)\n         SPACE\n************************************************************\n*                                                          *\n*        IF 'FILE' KEYWORD IS SPECIFIED,                   *\n*        GET DSNAME FROM JFCB USING FILE NAME.             *\n*                                                          *\n************************************************************\n         SPACE\n         CLI   FILEKW+1,1          'FILE' SPECIFIED?\n         BNE   NOFILE              NO, BRANCH\n         CLI   DSNAME+1,8          IS LENGTH 8 OR LESS\n         BH    FILERR1             NO, BRANCH\n         DEVTYPE DSNAME+2,DEVDATA  GET DEVICE TYPE\n         LTR   R15,R15             WAS FILENAME VALID\n         BNZ   FILERR2             NO, BRANCH\n         TM    DEVDATA+2,X'20'     DIRECT ACCESS\n         BZ    FILERR3             NO, BRANCH\n         LA    R4,DYNDCBW\n         MVC   0(DYNDCBL,R4),DYNDCB\n         XC    MEMLEN,MEMLEN\n         LA    R0,JFCB\n         LA    R1,DYNEXLST\n         ST    R0,0(,R1)\n         MVI   0(R1),X'87'\n         ST    R1,36(,R4)          DCBEXLST\n         MVC   40(8,R4),DSNAME+2   DCBDDNAM\n         MVC   DDSAVE,DSNAME+2\n         MVI   OPEND,X'80'\n         RDJFCB ((R4)),MF=(E,OPEND)\n         MVC   DSNAME+2(44),JFCB\n         LA    R1,DSNAME+45        LAST CHAR OF DSNAME\n         LA    R0,44               INITIAL LENGTH\nFILEA    CLI   0(R1),C' '          IS THIS LAST NONBLANK\n         BNE   FILEB               YES, BRANCH\n         BCTR  R1,0                BACK UP 1 CHARACTER\n         BCT   R0,FILEA            DECREMENT LENGTH AND BRANCH\nFILEB    STH   R0,DSNAME           STORE LENGTH OF DSNAME\n*        MVC   VOLUME(6),JFCB+118  GET VOLUME FROM JFCB\n         MVC   MEMNAME,JFCB+44     JFCBELNM IN IEFJFCBN\n         LA    R1,MEMNAME+7        LAST CHAR OF MEMBER NAME\n         LA    R0,8\nMEMA     CLI   0(R1),C' '\n         BNE   MEMB\n         BCTR  R1,0\n         BCT   R0,MEMA\nMEMB     STH   R0,MEMLEN\n         B     FILESPEC\nFILERR1  LA    R0,MSG14A\n         B     FILERR\nFILERR2  LA    R0,MSG14B\n         B     FILERR\nFILERR3  LA    R0,MSG14C\nFILERR   MVC   MSGWK(L'MSG14),MSG14\n         LA    R15,MSGWK+L'MSG14\n         LA    R14,DSNAME\n         LH    R1,0(,R14)\n         BCTR  R1,0\n         B     *+10\n         MVC   MSGWK+L'MSG14(0),2(R14)\n         EX    R1,*-6\n         LA    R15,1(R1,R15)\n         LR    R14,R0 POINT TO MSG14A, B, OR C\n         MVC   0(L'MSG14A,R15),0(R14)\n         LA    R0,L'MSG14+L'MSG14A+1(,R1)\n         LA    R1,MSGWK\n         BAL   R14,PUTMSG\n         B     QUITD12\nNOFILE   EQU   *\n         TM    6(R6),X'40'         IS IT QUOTED?\n         BO    DEFX                YES - SKIP DEFAULT SERVICE\n         CLI   QUICKW+1,1          QUICK SPECIFIED\n         BE    DEFX                YES, USER ENTERED ALL BUT PREFIX\n         SPACE\n         LA    R15,MYIOPL\n         USING IOPL,R15\n         LA    R14,MYDFPB\n         ST    R14,IOPLIOPB\n         USING DFPB,R14\n         XC    0(20,R14),0(R14)\n         LA    R0,DSNAME\n         ST    R0,DFPBDSN\n         OI    DFPBCODE,X'04'      SEARCH CAT AND PROMPT IF MULTI\n         MVC   DFPBPSCB,CPPLPSCB\n*        MVI   DFPBCNTL,X'20'      PREFIX THE DSNAME\n         DROP  R14                 DFPB\n         SPACE\n         LA    R1,MYIOPL\n         SPACE\n         LR    R1,R15              POINT TO IOPL\n         AIF   (NOT &MVS).SKIP4\n         L     R15,16              CVTPTR\n         TM    736(R15),X'80'      IF HI ORDER BIT NOT ON\n         BNO   EHDEFLNK               THEN DO LINK, NOT CALL\n         L     R15,736(,R15)       CVTEHDEF\n         BALR  R14,R15             CALL IKJEHDEF\n         B     EHDEFEXT            SKIP AROUND LINK\nEHDEFLNK EQU   *\n.SKIP4   ANOP\n         LINK  EP=IKJEHDEF,SF=(E,LINKAREA)\nEHDEFEXT EQU   *\n         SPACE\n         B     DEFCODE(R15)\nDEFCODE  B     DEF00               SUCCESS\n         B     NEXTD12              MSG ALREADY ISSUED\n         B     DEF08               INVALID NAME GT 44\n         B     NEXTD12              MSG ALREADY ISUED\n         B     DEF16               NOT IN CATALOG\n         B     DEF20               NOT IN CATALOG\n         B     DEF24               IMPOSSIBLE\n         B     DEF28               COMMAND SYSTEM ERROR\n         B     DEF32               IMPOSSIBLE\n         B     DEF36               ?\nDEF08    EQU   *\nDEF16    EQU   *\n         B     DEF24\nDEF20    EQU   *\nLOCERR   EQU   *\n         MVC   MSGWK(L'MSG02),MSG02\n         LA    R15,MSGWK+L'MSG02\n         LA    R14,DSNAME\n         LH    R1,0(,R14)\n         BCTR  R1,0\n         B     *+10\n         MVC   MSGWK+L'MSG02(0),2(R14)\n         EX    R1,*-6\n         LA    R15,1(R1,R15)\n         MVC   0(L'MSG02A,R15),MSG02A\n         LA    R0,L'MSG02+L'MSG02A+1(,R1)\n         LA    R1,MSGWK\n         BAL   R14,PUTMSG\n         B     NEXTD12\nDEF24    EQU   *\nDEF28    EQU   *\nDEF32    EQU   *\nDEF36    EQU   *\n         LA    R1,MSG03\n         LA    R0,L'MSG03\n         BAL   R14,PUTMSG\nNEXTD12  MVI   RETCODE+1,12\n         B     NEXTDSN\n         SPACE\nDEF00    EQU   *\nDEFX     EQU   *\n         SPACE\n************************************************************\n*                                                          *\n*        ALLOCATE THE DATASET                              *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R1,MYDAPL\n         USING DAPL,R1\n         MVC   DAPLUPT(4),CPPLUPT\n         MVC   DAPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,DAPLECB\n         MVC   DAPLPSCB(4),CPPLPSCB\n         LA    R15,MYDAPB\n         ST    R15,DAPLDAPB\n         DROP  R1                  DAPL\n         USING DAPB08,R15\n         XC    0(84,R15),0(R15)\n         MVI   DA08CD+1,X'08'\n         LA    R0,DSNAME\n         ST    R0,DA08PDSN\n         MVC   DA08DDN(8),=CL8' '\n         MVC   DA08UNIT,=CL8' '\n         MVC   DA08SER,=CL8' '\n         MVC   DA08MNM,=CL8' '\n         MVC   DA08PSWD,=CL8' '\n         MVI   DA08DSP1,DA08SHR\n         MVI   DA08DPS2,DA08KEEP\n         MVI   DA08DPS3,DA08KEP\n         TM    14(R6),X'80'        MEMBER SPECIFIED?\n         BZ    MEMBX               NO - BRANCH\n         LH    R1,12(,R6)          GET LENGTH OF MEMBER\n         STH   R1,MEMLEN\n         BCTR  R1,0                MINUS 1 FOR EX\n         L     R14,8(,R6)          GET ADDRESS OF MEMBER NAME\n         B     *+10\n         MVC   DA08MNM(0),0(R14)   MOVE MEMBER NAME\n         EX    R1,*-6\n         MVC   MEMNAME,DA08MNM\nMEMBX    EQU   *\n         TM    22(R6),X'80'        PASSWORD SPECIFIED?\n         BZ    PASSX               NO - BRANCH\n         LH    R1,20(,R6)          GET LENGTH OF PSWD\n         BCTR  R1,0                MINUS 1 FOR EX\n         L     R14,16(,R6)         GET ADDRESS OF PSWD\n         B     *+10\n         MVC   DA08PSWD(0),0(R14)  MOVE PSWD\n         EX    R1,*-6\nPASSX    EQU   *\n         LA    R1,MYDAPL\n         SPACE\n         BAL   R14,CALLDAIR\n         LTR   R15,R15\n         BZ    OKDAIR\n         BAL   R14,DAIRFAIL\n         B     NEXTD12\nOKDAIR   EQU   *\n         OI    STATUS,X'40'        TELL CLEANUP TO FREE IT\n         LA    R15,MYDAPB\n         MVC   DDSAVE,DA08DDN\n         TM    DA08DSO,X'40'       IS DSORG SEQUENTIAL?\n         BO    OKDSORG             YES - BRANCH\n         TM    DA08DSO,X'02'       IS DSORG PARTITIONED?\n         BO    OKDSORGP            YES, BRANCH\n*\n*              DSORG IS NEITHER PS NOR PO\n*              ISAM=X'80' DA=X'20' VSAM=X'00' NONE=X'00'\n*\nERRDSORG LA    R1,MSG06\n         LA    R0,L'MSG06\n         BAL   R14,PUTMSG\n         B     QUITD12\nOKDSORGP EQU   *\n         CLC   DA08MNM,=CL8' '     WAS MEMBER SPECIFIED?\n         BNE   OKDSORG             YES - BRANCH\n         LA    R1,MSG07\n         LA    R0,L'MSG07\n         BAL   R14,PUTMSG\n         B     NEXTD12\nOKDSORG  EQU   *\n         DROP  R15                 DAPB08\n         SPACE\n************************************************************\n*                                                          *\n*        CHECK FORMAT-1 DSCB FOR EMPTY DATA SET            *\n*                                                          *\n************************************************************\n         SPACE\n         L     R1,16               CVTPTR\n         L     R1,0(,R1)           TCB WORDS\n         L     R1,4(,R1)           CURRENT TCB\n         L     R1,12(,R1)          TIOT\n         LA    R1,24(,R1)          TOIENTRY\nDDLOOP   CLI   0(R1),0             END OF TIOT\n         BE    QUITDSN             YES, BRANCH (NEVER HAPPENS)\n         CLC   4(8,R1),DDSAVE      DOES DDNAME MATCH\n         BE    DDFOUND\n         SLR   R15,R15\n         IC    R15,0(,R1)\n         LA    R1,0(R15,R1)\n         B     DDLOOP\nDDFOUND  L     R15,16(,R1)         TIOEFSRT-1\n         TM    18(R15),X'20'       DIRECT ACCESS DEVICE?\n         BZ    OBTX                NO, BYPASS OBTAIN\n         MVC   VOLSER,28(R15)      UCBVOLI\nOBTDSCB  LA    R1,OBTAINW\n         MVC   0(OBTAINL,R1),OBTAIN\n         LA    R0,DSNAME+2         DSN FOR OBTAIN\n         ST    R0,4(,R1)\n         LA    R0,VOLSER           VOLUME FOR OBTAIN\n         ST    R0,8(,R1)\n         LA    R0,MYDSCB           ANSWER AREA FOR OBTAIN\n         ST    R0,12(,R1)\n         OBTAIN (1)\n         LTR   R15,R15             WAS OBTAIN SUCCESSFUL\n         BZ    OKDSCB              YES, BRANCH\n         SPACE\n*               OBTAIN HAS FAILED. HOW CAN THAT HAPPEN WHEN\n*               DYNAMIC ALLOCATION WAS SUCCESSFUL? ONE WAY IT\n*               CAN HAPPEN IS IF THE DSNAME IS AN ALIAS ENTRY\n*               IN A VSAM CATALOG.  IF IT IS, A 'LOCATE' WILL\n*               PUT THE TRUE NAME IN THE DSNAME FIELD, SO NOW\n*               WE ISSUE A LOCATE, AND TRY THE OBTAIN AGAIN.\n         SPACE\n         TM    STATUS,X'08'        HAS LOCATE BEEN TRIED ALREADY?\n         BZ    ALIAS               NO, GO TRY IT\nERROBT   LA    R1,MSG09            UNABLE TO OBTAIN DSCB\n         LA    R0,L'MSG09\n         BAL   R14,PUTMSG\n         B     QUITD12\nALIAS    OI    STATUS,X'08'        TRIP THE SWITCH\n         LA    R1,LOCATEW\n         MVC   0(LOCATEL,R1),LOCATE\n         LA    R0,DSNAME+2         DSNAME FOR LOCATE\n         ST    R0,4(,R1)\n         LA    R0,LOCBUF           ANSWER AREA FOR LOCATE\n         ST    R0,12(,R1)\n         LOCATE (1)\n         LTR   15,15               WAS LOCATE SUCCESSFUL?\n         BZ    OBTDSCB             YES, GO OBTAIN AGAIN\n         B     ERROBT              NO, ISSUE MESSAGE\n         SPACE\nOKDSCB   NI    STATUS,255-X'08'    TURN OFF LOCATE SWITCH\n         TM    MYDSCB-44+X'52',X'42' DSORG = PS OR PO\n         BZ    ERRDSORG\n*        TM    MYDSCB-44+X'54',X'C0' RECFM = U\n*        BO    ERRRECFM\n*        CLC   MYDSCB-44+X'62'(3),=X'000000' CHECK DS1LSTAR\n*        BE    DYNEOD              BRANCH IF EMPTY DATA SET\nOBTX     EQU   *\nFILESPEC EQU   *\n         SPACE\n************************************************************\n*                                                          *\n*        SET UP THE DCB                                    *\n*                                                          *\n************************************************************\n         SPACE\n         MVC   DYNDCBW(DYNDCBL),DYNDCB\n         LA    R4,DYNDCBW\n         USING IHADCB,R4\n         MVC   DCBDDNAM(8),DDSAVE\n         SPACE\n         LA    R15,DYNEOD\n         IC    R0,DCBEODAD-1\n         ST    R15,DCBEODAD-1\n         STC   R0,DCBEODAD-1\n         SPACE\n         LA    R15,DYNSYNAD\n         IC    R0,DCBSYNAD-1\n         ST    R15,DCBSYNAD-1\n         STC   R0,DCBSYNAD-1\n         SPACE\n         LA    R15,DYNEXLST\n         IC    R0,DCBEXLSA-1\n         ST    R15,DCBEXLSA-1\n         STC   R0,DCBEXLSA-1\n         LA    R1,DYNDCBEX\n         ST    R1,0(,R15)\n         MVI   0(R15),X'05'\n         LA    R1,DYNABEND\n         ST    R1,4(,R15)\n         MVI   4(R15),128+X'11'    OPEN ABEND EXIT (MVS)\n         SPACE\n         OI    STATUS,X'80'        TELL CLEANUP TO CLOSE DCB\n         MVI   OPEND,X'80'\n         SPACE\n         OPEN  ((R4),INPUT),MF=(E,OPEND)\n         SPACE\n         TM    DCBOFLGS,X'10'\n         BO    OKOPEN\n         LA    R1,MSG08\n         LA    R0,L'MSG08\n         TM    STATUS,X'10'        MEMBER NOT FOUND?\n         BO    DYNOPENM            YES, BRANCH\n         LA    R1,MSG04\n         LA    R0,L'MSG04\nDYNOPENM BAL   R14,PUTMSG\n         B     QUITD12\n         SPACE\nDYNDCBEX BR    R14\n         SPACE\nDYNABEND EQU   *\n         L     R8,0(,R1)           GET COMPLETION CODE\n         N     R8,=A(X'FFF0FF00')\n         CL    R8,=A(X'01301800')  IS IT AN 013-18 ABEND\n         BE    *+10                YES, BRANCH\n         MVI   4(R1),0             ABNORMALLY TERMINATE\n         BR    R14\n         OI    STATUS,X'10'        INDICATE MEMBER NOT FOUND\n         MVI   3(R1),4             IGNORE THE ABEND\n         BR    R14\n         SPACE\nOKOPEN   EQU   *\n         BAL   R14,MD5INIT         SET UP FOR MD5\n         SPACE\nREADLOOP EQU   *\n         MVI   SYNADSW,0           SET SYNAD SWITCH OFF\n         SPACE\n         GET   (R4)\n         SPACE\n         CLI   SYNADSW,0           WAS SYNAD EXIT TAKEN?\n         BE    OKGET               NO - BRANCH\n         LA    R1,SYNADMSG\n         LA    R0,78\n         BAL   R14,PUTMSG\n         B     QUITD12\nOKGET    EQU   *\n         BAL   R14,MD5REC\n         LA    R14,1\n         A     R14,KOUNT\n         ST    R14,KOUNT\n         B     READLOOP\n         SPACE\nMD5INIT  LA    R1,MD5ARGS\n         LA    R15,MD5LEN\n         ST    R15,4(,R1)          ARG 2 IS WORD CONTAINING LENGTH\n         LA    R15,MD5CTX\n         ST    R15,8(,R1)          ARG 3 IS CONTEXT 22 WORDS\n         XC    0(88,R15),0(R15)    CLEAR THE CONTEXT\n         LA    R15,MD5RES\n         ST    R15,12(,R1)         ARG 4 IS RESULT\n         LA    R15,MD5WRK\n         ST    R15,16(,R1)         ARG 5 IS WORKSPACE 44 WORDS\n         BR    R14\n         SPACE\nMD5REC   ST    R14,MD5SAVE\n         LH    R0,DCBLRECL         GET RECORD LENGTH IF RECFM U OR FB\n         TM    DCBRECFM,X'C0'      IF RECFM U\n         BO    MD5RECX               BRANCH\n         TM    DCBRECFM,X'40'      IF RECFM V\n         BO    MD5RECV               BRANCH\n         TM    DCBRECFM,X'10'      IF RECFM FB\n         BO    MD5RECX               BRANCH\n         LH    R0,DCBBLKSI         GET RECORD LENGTH IF RECFM F\n         B     MD5RECX               BRANCH\nMD5RECV  CLI   RDWKW+1,1           IF RDW WAS SPECIFIED\n         BE    MD5RECX               INCLUDE RDW\n         LH    R0,0(,R1)           GET RECORD LENGTH +4 FROM RDW\n         SH    R0,=H'4'            SUBTRACT 4 TO EXCLUDE RDW\n         LA    R1,4(,R1)           GET RECORD ADDRESS AFTER RDW\nMD5RECX  ST    R0,MD5LEN           STORE RECORD LENGTH\n         LR    R15,R1              RECORD ADDRESS TO R15\n         LA    R1,MD5ARGS          SET R1 FOR CALL\n         ST    R15,0(,R1)          STORE RECORD ADDRESS AS FIRST ARG\n         L     R15,=V(MD5)         SET R15 FOR CALL\n         BALR  R14,R15             CALL MD5(RECORD,LEN,CTX,HEX,WORK)\n         L     R14,MD5SAVE\n         BR    R14\n         SPACE\nMD5LAST  ST    R14,MD5SAVE\n         SR    R0,R0               STORE RECORD ADDRESS\n         ST    R0,MD5LEN           STORE RECORD LENGTH\n         LA    R1,MD5ARGS\n         L     R15,=V(MD5)\n         BALR  R14,R15             CALL MD5(RECORD,LEN,CTX,HEX,WORK)\n         L     R14,MD5SAVE\n         BR    R14\n         SPACE\nDYNEOD   EQU   *\n         BAL   R14,MD5LAST\n         MVC   MSGWK(32),MD5RES\n         MVI   MSGWK+32,C' '\n         MVI   MSGWK+33,C'*'\n         LA    R14,DSNAME\n         LH    R1,0(,R14)\n         BCTR  R1,0\n         B     *+10\n         MVC   MSGWK+34(0),2(R14)\n         EX    R1,*-6\n         LA    R15,MSGWK+35(R1)    POINT PAST LAST BYTE\n*        TM    14(R6),X'80'        MEMBER SPECIFIED?\n         CLI   MEMLEN+1,0          MEMBER ALLOCATED?\n         BZ    MEMAX               NO - BRANCH\n         MVI   0(R15),C'('\n         LA    R15,1(,R15)\n*        LH    R1,12(,R6)          GET LENGTH OF MEMBER\n         LH    R1,MEMLEN           GET LENGTH OF MEMBER\n         BCTR  R1,0                MINUS 1 FOR EX\n*        L     R14,8(,R6)          GET ADDRESS OF MEMBER NAME\n         LA    R14,MEMNAME\n         B     *+10\n         MVC   0(0,R15),0(R14)     MOVE MEMBER NAME\n         EX    R1,*-6\n         LA    R15,1(R1,R15)       POINT PAST LAST BYTE\n         MVI   0(R15),C')'\n         LA    R15,1(,R15)\nMEMAX    EQU   *\n         LA    R1,MSGWK\n         LR    R0,R15              POINT PAST LAST BYTE\n         SR    R0,R1               COMPUTE MESSAGE LENGTH\n         CLI   LOWKW+1,1           IF 'LOWER' SPECIFIED\n         BNE   LOWX\n         LR    R14,R0\n         BCTR  R14,0                  GET LENGTH MINUS 1\n         B     *+10\n         TR    MSGWK(0),LOWTABLE      TRANSLATE TO LOWER CASE\n         EX    R14,*-6\nLOWX     EQU   *\n         LA    R1,MSGWK\n         BAL   R14,PUTLINE\n         AGO   .NOCOUNT\n         LA    R1,MSGWK\n         MVC   0(10,R1),=X'40206B2020206B202120'\n         MVC   10(8,R1),=C' RECORDS'\n         CLC   KOUNT,=F'1'\n         BNE   *+8\n         MVI   17(R1),C' '      CHANGE 'RECORDS' TO 'RECORD '\n         L     R15,KOUNT\n         CVD   R15,DOUBLE\n         ED    0(10,R1),DOUBLE+4\n         SPACE\nSHIFLEFT CLI   0(R1),C' '       LEADING BLANK?\n         BNE   SHIFTED          NO - READY TO ISSUE\n         MVC   0(17,R1),1(R1)   SHIFT LEFT 1\n         MVI   17(R1),C' '      BLANK LAST BYTE\n         B     SHIFLEFT\nSHIFTED  EQU   *\nSHOWTOTL LA    R0,18\n         BAL   R14,PUTLINE\n.NOCOUNT ANOP\n         B     QUITDSN\n         SPACE\nQUITD12  LA    R15,12\n         SPACE\nQUITDSN  TM    STATUS,X'80'\n         BZ    NOCLOSE\n         TM    DCBOFLGS,X'10'      IS IT OPEN?\n         BZ    NOCLOSE             NO, BRANCH\n         MVI   CLOSED,X'80'\n         CLOSE ((R4)),MF=(E,CLOSED)\n         NI    STATUS,255-X'80'    CLOSED\n         DROP  R4                  IHADCB\nNOCLOSE  EQU   *\n         TM    STATUS,X'40'        FREE REQUIRED?\n         BZ    NOFREE\n         LA    R1,MYDAPL\n         LA    R15,MYDAPB\n         USING DAPB18,R15\n         XC    0(40,R15),0(R15)\n         MVI   DA18CD+1,X'18'\n         MVC   DA18DDN,DDSAVE\n         MVC   DA18MNM(8),=CL8' '\n         MVC   DA18SCLS(2),=CL8' '\n         BAL   R14,CALLDAIR        UNALLOCATE\n         NI    STATUS,255-X'40'    UNALLOCATED\n         DROP  R15                 DAPB18\nNOFREE   EQU   *\n         B     NEXTDSN\n         SPACE\nDONE     TM    MYPUTLEP,X'80'     WAS PUTLINE LOADED?\n         BO    NODELETE           NO - USED CVTPUTL - BRANCH\n         LA    R0,=CL8'IKJPUTL '\n         DELETE EPLOC=(0)\nNODELETE EQU   *\n         SPACE\n         IKJRLSA MYANS\n         SPACE\n         CLI   RETCODE+1,0         IS RETCODE ZERO?\n         BZ    STACKDX             YES, BRANCH\n         MVC   MYSTPB(STACKDL),STACKD\n         SPACE\n         STACK DELETE=ALL,PARM=MYSTPB,MF=(E,MYIOPL)\n         SPACE\n         TCLEARQ\nSTACKDX  EQU   *\n         SPACE\n         LH    R15,RETCODE\n         B     EXIT\n         SPACE\n************************************************************\n*                                                          *\n*         CALL IKJDAIR SERVICE ROUTINE                     *\n*                                                          *\n************************************************************\n          SPACE\nCALLDAIR ST    R14,DAIRREGS\n         AIF   (NOT &MVS).SKIP6\n         L     R15,16\n         TM    732(R15),X'80'     CVTDAIR\n         BNO   DAIRLINK\n         L     R15,732(,R15)\n         BALR  R14,R15\n         B     DAIRFINI\nDAIRLINK EQU   *\n.SKIP6   ANOP\n         LINK  EP=IKJDAIR,SF=(E,LINKAREA)\nDAIRFINI L     R14,DAIRREGS\n         BR    R14\n         SPACE\n************************************************************\n*                                                          *\n*        DYNAMIC ALLOCATION FAILURE ROUTINE                *\n*                                                          *\n************************************************************\n         SPACE\nDAIRFAIL ST    R14,MYDFREGS\n         AIF   (NOT &MVS).SKIP7\n         LA    R1,MYDFPARM\n         USING DFDSECTD,R1\n         ST    R15,MYDFRC\n         LA    R15,MYDFRC\n         ST    R15,DFRCP\n         LA    R15,MYDAPL\n         ST    R15,DFDAPLP\n         SLR   R15,R15\n         ST    R15,MYJEFF02\n         LA    R15,MYJEFF02\n         ST    R15,DFJEFF02\n         LA    R15,DFDAIR\n         STH   R15,MYDFID\n         LA    R15,MYDFID\n         ST    R15,DFIDP\n         SLR   R15,R15\n         ST    R15,DFCPPLP\n         LINK  EP=IKJEFF18,SF=(E,LINKAREA)\n         L     R15,MYDFRC\n         DROP  R1                  DFDSECTD\n.SKIP7   ANOP\n         AIF   (&MVS).SKIP8\n         LA    R1,MSGDAIR\n         LA    R0,L'MSGDAIR\n         BAL   R14,PUTMSG\n.SKIP8   ANOP\n         L     R14,MYDFREGS\n         BR    R14\n         SPACE\n************************************************************\n*                                                          *\n*        PUTMSG ROUTINE                                    *\n*                                                          *\n************************************************************\n         SPACE\nPUTMSG   STM   R14,R1,PUTLINS\n         XC    MYOLD(8),MYOLD\n         XC    MYSEG1(4),MYSEG1\n         MVC   MYPTPB(12),MODLPTPM\n         LA    R14,1               NO. OF MESSAGE SEGMENTS\n         ST    R14,MYOLD\n         LA    R14,MYSEG1          POINT TO 1ST SEGMENT\n         ST    R14,MYOLD+4\n         LR    R14,R0              LENGTH IN R0\n         LA    R14,4(,R14)         ADD 4\n         LA    R15,MYSEG1+4\n         CLC   0(3,R1),=C'IKJ'     IS DATA PRECEEDED BY MESSAGE ID?\n         BE    *+16                YES - BRANCH\n         LA    R14,1(,R14)         ADD 1 TO LENGTH\n         MVI   0(R15),C' '         INSERT LEADING BLANK\n         LA    R15,1(,R15)         BUMP POINTER\n         STH   R14,MYSEG1\n         LR    R14,R0\n         BCTR  R14,0\n         B     *+10\n         MVC   0(0,R15),0(R1)      MOVE MESSAGE IN\n         EX    R14,*-6\n         L     R15,MYPUTLEP\n         SPACE\n         PUTLINE PARM=MYPTPB,OUTPUT=(MYOLD),ENTRY=(15),MF=(E,MYIOPL)\n         SPACE\n         LM    R14,R1,PUTLINS\n         BR    R14\n         SPACE\n************************************************************\n*                                                          *\n*        PUTLINE ROUTINE                                   *\n*                                                          *\n************************************************************\n         SPACE\nPUTLINE  STM   R14,R1,PUTLINS\n         XC    MYSEG1(4),MYSEG1\n         MVC   MYPTPB(12),MODLPTPB\n         LR    R14,R0              LENGTH IN R0\n         LA    R14,4(,R14)         ADD 4\n         STH   R14,MYSEG1\n         LR    R14,R0\n         BCTR  R14,0\n         B     *+10\n         MVC   MYSEG1+4(0),0(R1)   MOVE TEXT IN\n         EX    R14,*-6\n         LA    R1,MYIOPL\n         L     R15,MYPUTLEP\n         SPACE\n         PUTLINE PARM=MYPTPB,OUTPUT=(MYSEG1,DATA),ENTRY=(15),MF=(E,(1))\n         SPACE\n         LM    R14,R1,PUTLINS\n         BR    R14\n         SPACE 1\n*RRRECFM LA    R1,MSGRECFM\n*        LA    R0,L'MSGRECFM\n*        BAL   R14,PUTMSG\n*        B     QUITD12\n         SPACE\nEXIT     LR    2,15\n         LR    1,13\n         L     R0,@SIZE\n         L     13,4(,13)\n         ST    15,16(,13)\n         FREEMAIN R,A=(1),LV=(0)\n         LR    15,2\n         LM    0,12,20(13)\n         L     14,12(,13)\n         BR    14\n         SPACE\n************************************************************\n*                                                          *\n*        SYNAD EXIT                                        *\n*                                                          *\n************************************************************\n         SPACE\n*        THIS ROUTINE IS ENTERED DURING THE 'GET' MACRO\n*        IF AN I/O ERROR OCCURS.\n         SPACE\nDYNSYNAD EQU   *\n         SYNADAF ACSMETH=QSAM\n         MVC   SYNADMSG(78),50(R1)\n         MVI   SYNADSW,X'FF'\n         SYNADRLS\n         BR    R14\n         SPACE\n************************************************************\n*                                                          *\n*        CONSTANTS                                         *\n*                                                          *\n************************************************************\n         SPACE\nMODLPTPM PUTLINE OUTPUT=(1,TERM,SINGLE,INFOR),                         X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=L\n         SPACE\nMODLPTPB PUTLINE OUTPUT=(1,TERM,SINGLE,DATA),                          X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=L\n         SPACE\n         PRINT NOGEN\n         SPACE\nDYNDCB   DCB   DDNAME=DYNAM,DSORG=PS,MACRF=(GL),                       +\n               EODAD=0,SYNAD=0,EROPT=ACC\nDYNDCBL  EQU   *-DYNDCB\n         SPACE\n         PRINT GEN\n         SPACE\nOBTAIN   CAMLST SEARCH,2,3,4\nOBTAINL  EQU   *-OBTAIN\n         SPACE\nLOCATE   CAMLST NAME,2,,4\nLOCATEL  EQU   *-LOCATE\n         SPACE\nSTACKD   STACK DELETE=ALL,MF=L\nSTACKDL  EQU   *-STACKD\n         SPACE\nMSG01    DC    C'ERROR IN PARSE SERVICE ROUTINE'\nMSG02    DC    C'IKJ58503I DATA SET '\nMSG02A   DC    C' NOT IN CATALOG'\nMSG03    DC    C'ERROR IN DEFAULT SERVICE ROUTINE'\nMSG04    DC    C'UNABLE TO OPEN DATASET'\nMSG05    DC    C'IKJ58509I DATA SET NAME REQUIRED WHEN MEMBER IS SPECIF+\n               IED'\nMSG06    DC    C'ORGANIZATION OF DATA SET MUST BE PARTITIONED OR SEQUEN+\n               TIAL'\nMSG07    DC    C'DATA SET IS PARTITIONED, MEMBER NOT SPECIFIED'\nMSG08    DC    C'SPECIFIED MEMBER NOT FOUND IN DATASET'\nMSG09    DC    C'UNABLE TO OBTAIN DSCB FOR DATA SET'\nMSG14    DC    C'FILENAME '\nMSG14A   DC    C' INVALID, MORE THAN 8 CHARACTERS  '\nMSG14B   DC    C' IS NOT CURRENTLY ALLOCATED       '\nMSG14C   DC    C' NOT ALLOCATED TO A DASD DATA SET '\n*SGRECFM DC    C'RECORD FORMAT U NOT SUPPORTED'\nMSGDAIR  DC    C'UNABLE TO ALLOCATE'\nLOWTABLE DC    0D'0',256AL1(*-LOWTABLE)\n         ORG   LOWTABLE+C'A'\n         DC    X'818283848586878889'\n         ORG   LOWTABLE+C'J'\n         DC    X'919293949596979899'\n         ORG   LOWTABLE+C'S'\n         DC    X'A2A3A4A5A6A7A8A9'\n         ORG\n         LTORG\nPCLADDR  DC    0D'0'               END OF CSECT\n         SPACE\n************************************************************\n*                                                          *\n*        PARSE PARAMETERS                                  *\n*                                                          *\n************************************************************\n         SPACE\n         PRINT NOGEN\nMD5SMPCL IKJPARM\nDSN      IKJPOSIT DSNAME,LIST,PROMPT='DATA SET NAME'\nFILEKW   IKJKEYWD\n         IKJNAME 'FILE'\nQUICKW   IKJKEYWD\n         IKJNAME 'QUICK'\nRDWKW    IKJKEYWD\n         IKJNAME 'RDW'\nLOWKW    IKJKEYWD\n         IKJNAME 'LOWER'\n         IKJENDP\n         PRINT GEN\n         SPACE\n************************************************************\n*                                                          *\n*        DSECTS                                            *\n*                                                          *\n************************************************************\n         SPACE\n@DATA    DSECT\n         DS    18F                 REGISTER SAVEAREA\nLINKAREA DS    2F\nMYPPL    DS    7F\nMYANS    DS    F\nMYECB    DS    F                  USED BY PUTLINE ROUTINE\nMYIOPL   DS    4F                 USED BY PUTLINE ROUTINE\nMYPTPB   DS    3F                 USED BY PUTLINE ROUTINE\nMYOLD    DS    2F                 USED BY PUTLINE ROUTINE\nMYSEG1   DS    2H,CL256           USED BY PUTLINE ROUTINE\nPUTLINS  DS    4F                 USED BY PUTLINE ROUTINE\nMYPUTLEP DS    F                  ADDRESS OF IKJPUTL\nMYSTPB   DS    0F                 5 WORDS USED BY STACK DELETE\nMYDAPL   DS    5F\nMYDAPB   DS    21F\nMYDFPB   DS    5F\nDSNAME   DS    H,CL44\nMEMLEN   DS    H\nMEMNAME  DS    CL8\nVOLSER   DS    CL6\nLOCATEW  DS    0F\nOBTAINW  DS    4F\nLOCBUF   DS    0D                  USES NEXT 265 BYTES\nMYDSCB   DS    CL140               96 BYTES OF DSCB, 5 BYTES CCHHR\nMSGWK    DS    CL128\nSTATUS   DS    X\nRETCODE  DS    H\nMYDFPARM DS    5F  USED BY DAIRFAIL\nMYDFREGS DS    F   USED BY DAIRFAIL\nMYDFRC   DS    F   USED BY DAIRFAIL\nMYJEFF02 DS    F   USED BY DAIRFAIL\nMYDFID   DS    H   USED BY DAIRFAIL\nDOUBLE   DS    D\nEIGHT    DS    CL8\nDDSAVE   DS    CL8\nDAIRREGS DS    F\nOPEND    DS    0F\nCLOSED   DS    F\nDYNEXLST DS    2F\nKOUNT    DS    F\nKOUNTSP  DS    F\nDYNDCBW  DS    0D,XL(DYNDCBL)\nSYNADSW  DS    F\nSYNADMSG DS    CL78\nDEVDATA  DS    2F\nJFCB     DS    0F,CL176\nMD5ARGS  DS    5F\nMD5LEN   DS    F\nMD5CTX   DS    22F\nMD5RES   DS    8F\nMD5WRK   DS    44F\nMD5SAVE  DS    F\n         DS    0D\n@DATAL   EQU   *-@DATA\n         SPACE\nIHADCB   DSECT\n         DS    32XL1\nDCBBFTEK DS    XL1\nDCBEODAD DS    AL3\nDCBRECFM DS    X\nDCBEXLSA DS    AL3\nDCBDDNAM DS    CL8\nDCBOFLGS DS    X\n         DS    7XL1\n         DS    X\nDCBSYNAD DS    AL3\nDCBBLKSI EQU   IHADCB+62,2\nDCBLRECL EQU   IHADCB+82,2\n         SPACE\n         IKJCPPL\n         SPACE 3\n         IKJPPL\n         SPACE\n         IKJDFPB\n         SPACE 2\n         IKJUPT\n         SPACE 2\n         IKJIOPL\n         SPACE 2\n         IKJDAPL\n         SPACE 2\n         IKJDAP08\n         SPACE 2\n         IKJDAP18\n         SPACE 2\n         IKJPSCB\n         SPACE 2\n         AIF   (NOT &MVS).SKIP12\n         IKJEFFDF DFDSECT=YES\n.SKIP12  ANOP\n         SPACE 2\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MD5URL": {"ttr": 4614, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x131_\\x01\\x131_\\x11\\x11\\x004\\x00\\x03\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2013-11-11T00:00:00", "modifydate": "2013-11-11T11:11:00", "lines": 52, "newlines": 3, "modlines": 0, "user": "UPDATED"}, "text": "from http://homerow.net/asm/md5\nwhich has a link to:\nhttp://homerow.net/cgi-bin/dl?md5-04.078.tar.gz\nThe file named md5-04.078/md5 inside the tar file has the assembler\nsource for the MD5 function callable by REXX, a REXX program\nto test it with, and JCL to assemble and test.\nThe results of the test job look like this:\n\n   Digesting: Fried Rattlesnake\n              Turkey Neck Gumbo\n              Pecan Pie\n   Produces:  A39F852688191291396F93DECB94DA57\n\nA test was run on a Windows PC to see if the same results\ncould be obtained.\n\nA command-line md5.exe for windows was downloaded from\nhttp://www.fourmilab.ch/md5/\n\nA zip file named UnxUtils.zip containing dd.exe, md5sum.exe, and\ntr.exe, ports of GNU utilities, was downloaded from\nhttp://sourceforge.net/projects/unxutils/\n\nThis md5sum.exe and the md5.exe mentioned previously work the same.\n\nThe command \"dd conv=ebcdic\" translates the input from ASCII to\nEBCDIC, and changes the hex 0d0a at end-of-line to hex 0d25.\n\nThe command tr -d \"\\r\\045\" tells tr.exe to copy input to\noutput deleting any end-of-line characters like hex 0d and hex 25.\nWe want to exclude the end-of-line characters from the md5 input.\n\nThe command used to test on windows was: (with tr operands omitted)\necho Fried RattlesnakeTurkey Neck GumboPecan Pie|dd conv=ebcdic|tr|md5\n0+1 records in\n0+1 records out\nA39F852688191291396F93DECB94DA57  -\n\nIf md5sum.exe is used instead of md5.exe, the result is:\na39f852688191291396f93decb94da57 *-\nwhich is the same, but in lower case.\n\nBoth results match the results of the REXX program.\n\nThe tr operands were omitted in the command line above so it would fit\nin the first 72 columns of this document. The command line as it should\nlook, but with a shorter input string:\necho Fried Rattlesnake|dd conv=ebcdic|tr -d \"\\r\\045\"|md5sum\n\nThe echo command will output a trailing blank if there is a space\nbetween the last character and the pipe symbol, and the md5 result\nwill be different.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SHA1PGM": {"ttr": 4616, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x004\\x01 \\x14\\x1f\\x01 \\x16\\x7f\\x07\\x19\\x02F\\x02D\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2020-05-20T00:00:00", "modifydate": "2020-06-15T07:19:34", "lines": 582, "newlines": 580, "modlines": 0, "user": "UPDATED"}, "text": "         TITLE '   S H A 1 P G M '\n* WRITTEN MAY 19 2020\n* UPDATED MAY 20 2020\n* WRITE THE SHA-1 HASH OF THE INPUT FILE (SYSUT1) TO SYSUT2\n*\n* DDNAMES: SYSUT1 (INPUT) AND SYSUT2 (OUTPUT)\n*\n* IF PARM CONTAINS 'R' THEN RDW'S WILL BE INCLUDED IF INPUT IS V.\n* IF PARM CONTAINS 'L' THEN RESULT WILL BE SHOWN IN LOWERCASE.\n* IF PARM CONTAINS 'E' THEN RESULT WILL INCLUDE THE DATA SET NAME,\n* BUT ONLY THE FIRST DATA SET NAME IF CONCATENATED DATA SETS.\n*\n* OUTPUT WILL BE A FIXED-LENGTH 80-BYTE RECORD FILE,\n* UNLESS THE OUTPUT FILE ALREADY HAS OTHER ATTRIBUTES.\n*\n* MUCH OF THE SOURCE CODE IS FROM MD5PGM AND SHA1SUM IN CBT FILE 900,\n*\n* DISCLAIMER: NO GUARANTEE; NO WARRANTY; INSTALL/USE AT YOUR OWN RISK.\n*\n* SAMPLE JCL:\n*  //STEPNAME EXEC PGM=SHA1PGM\n*  //SYSUT1 DD DSN=HLQ.INPUT.DATA,DISP=SHR\n*  //SYSUT2 DD SYSOUT=*\n*\n* LOG OF CHANGES:\n*  JUNE 15 2020 - FIX RDW\n         SPACE\nSHA1PGM  RMODE ANY\nSHA1PGM  AMODE 31\nSHA1PGM  CSECT\n         USING *,R10\n         B     @PROLOG-*(,R15)\n         DC    AL1(7),CL7'SHA1PGM'\n         DC    CL16' &SYSDATE &SYSTIME '\n@SIZE    DC    0F'0',AL1(0),AL3(@DATAL)\n@PROLOG  STM   14,12,12(13)\n         LR    R10,R15\n         LR    R2,R1               POINT R2 TO PARM ADDRESS\n         L     R0,@SIZE\n         STORAGE OBTAIN,LENGTH=(0)\n         LR    R9,R1               POINT R9 TO OBTAINED AREA\n         XC    0(@CLEARL,R9),0(R9)\n         USING @DATA,R9\n         ST    R13,4(,R9)          OLD ADDRESS IN NEW SAVE AREA\n         ST    R9,8(,R13)          NEW ADDRESS IN OLD SAVE AREA\n         LR    R13,R9              POINT R13 TOP NEW SAVE AREA\n         SPACE\n*\n*         GET STORAGE BELOW THE LINE FOR DCB'S ETC.\n*\n         LA    R0,@DATA24L\n         STORAGE OBTAIN,LENGTH=(0),LOC=24\n         LR    R8,R1               POINT R8 TO OBTAINED AREA\n         USING @DATA24,R8\n         SPACE\n         L     R1,0(,R2)           POINT TO PARM\n         LH    R14,0(,R1)          LENGTH OF PARM\n         LTR   R14,R14\n         BZ    PARMX\n         LA    R15,2(,R1)\nPARMLOOP CLI   0(R15),C'R'         IF PARM CONTAINS R (FOR RDW)\n         BNE   *+8                   THEN\n         MVI   OPTR,1                TURN ON RDW OPTION\n         CLI   0(R15),C'L'         IF PARM CONTAINS L (FOR LOWERCASE)\n         BNE   *+8                   THEN\n         MVI   OPTL,1                TURN ON LOWERCASE OPTION\n         CLI   0(R15),C'E'         IF PARM CONTAINS E (FOR EXTRA INFO)\n         BNE   *+8                   THEN\n         MVI   OPTE,1                TURN ON EXTRA OPTION\n         LA    R15,1(,R15)\n         BCT   R14,PARMLOOP\nPARMX    EQU   *\n         SPACE\n         LA    R15,64\n         ST    R15,I64\n         LA    R15,12\n         ST    R15,RETCODE\n         SPACE\n         LA    R3,UT1DCBW\n         LA    R4,UT2DCBW\n         MVC   0(UT1DCBL,R3),UT1DCB\n         MVC   0(UT2DCBL,R4),UT2DCB\n         TM    0(R2),X'80'         ONLY 1 PARAMETER\n         BO    NODD                YES, BYPASS DD ROUTINE\n         L     R14,4(,R2)          POINT TO DDNAME LIST\n         LH    R1,0(,R14)          GET LENGTH OF DDNAME LIST\n         LA    R14,2(,R14)         POINT PAST LENGTH\n         SPACE\n*        CH    R1,=H'48'           LONG ENOUGH FOR SYSPRINT\n*        BL    NODD                NO, BRANCH\n*        CLI   40(R14),0           SYSPRINT OVERRIDE\n*        BE    *+10                NO, SKIP MVC\n*        MVC   DDNAM(8,R3),40(R14)\n         SPACE\n         CH    R1,=H'64'           LONG ENOUGH FOR SYSUT1\n         BL    NODD                NO, BRANCH\n         CLI   56(R14),0           SYSUT1 OVERRIDE\n         BE    *+10                NO, SKIP MVC\n         MVC   DDNAM(8,R3),56(R14)                                .FIX.\n         SPACE\n         CH    R1,=H'72'           LONG ENOUGH FOR SYSUT2\n         BL    NODD                NO, BRANCH\n         CLI   64(R14),0           SYSUT2 OVERRIDE\n         BE    *+10                NO, SKIP MVC\n         MVC   DDNAM(8,R4),64(R14)                                .FIX.\nNODD     EQU   *\n         SPACE\n         LA    R5,UT1DCBEW\n         LA    R6,UT2DCBEW\n         MVC   0(UT1DCBEL,R5),UT1DCBE\n         MVC   0(UT2DCBEL,R6),UT2DCBE\n         ST    R5,0(,R3)           ST    R5,DCBDCBE-IHADCB(,R3)\n         ST    R6,0(,R4)           ST    R5,DCBDCBE-IHADCB(,R3)\n         SPACE\n**********************************************************************\n*              OPEN INPUT DCB\n**********************************************************************\n         LA    R1,UT1EXLST         POINT TO INPUT DCB EXIT LIST\n         STCM  R1,7,EXLST+1(R3)    STORE ADDRESS OF EXIT LIST IN DCB\n         LA    R15,JFCB\n         ST    R15,0(,R1)          1ST EXLST WORD\n         MVI   0(R1),X'87'         JFCB ADDRESS FOR RDJFCB\n         SPACE\n         MVI   UT1RDJF,X'80'\n         RDJFCB ((R3)),MF=(E,UT1RDJF)\n         SPACE\n         MVC   OPEN31W(OPEN31L),OPEN31\n         OPEN  ((R3),INPUT),MODE=31,MF=(E,OPEN31W)\n*        TM    OFLGS(R3),X'10'     TEST FOR SUCCESSFUL OPEN\n*        TM    16(R5),X'C0'        TM    DCBEFLG1,DCBEOPEN+DCBEMD31\n*        TM    DCBEFLG1-DCBE(R5),DCBEOPEN+DCBEMD31 OPEN AND 31-BIT SAM\n         TM    DCBEFLG1-DCBE(R5),DCBEOPEN OPEN SUCCESSFUL\n         BNO   EXIT\n         TM    DCBEFLG1-DCBE(R5),DCBEMD31 31-BIT SAM SUPPORTED?\n         BO    NOT24I              YES, NOTHING TO CHANGE\n**********************************************************************\n*              MAKE CHANGES FOR 24-BIT GET\n**********************************************************************\n         LA    R15,EOD24S          POINT TO 24-BIT EODAD LOCATION\n         MVC   0(EOD24L,R15),EOD24I  COPY EOD24I CODE TO 24-BIT EODAD\n         LA    R0,UT1EOD           POINT TO 31-BIT EODAD\n*        O     R0,=A(X'80000000')  SET 31-BIT MODE IN UT1EOD ADDRESS\n         OILH  R0,X'8000'          SET 31-BIT MODE IN UT1EOD ADDRESS\n         ST    R0,EOD24P-EOD24I(,R15) STORE UT1EOD ADDRESS AND MODE\n         ST    R15,DCBEEODA-DCBE(R5) CHANGE DCBE EODAD TO EOD24S\n         MVC   GET24S(GET24L),GET24I COPY 24-BIT GET\nNOT24I   EQU   *\n**********************************************************************\n*              OPEN OUTPUT DCB\n**********************************************************************\n         LA    R1,UT2EXLST         POINT TO OPEN EXIT LIST\n         STCM  R1,7,EXLST+1(R4)    STORE ADDRESS OF EXIT LIST IN DCB\n         LA    R15,UT2OPENX        POINT TO OPEN EXIT ENTRY POINT\n         ST    R15,0(,R1)          STORE ADDRESS OF EXIT IN EXIT LIST\n         MVI   0(R1),X'85'         SET HIGH BYTE OF EXIT LIST\n         MVC   0(UT2OPENL,R15),UT2GLUE  COPY EXIT TO 24-BIT STORAGE\n         LA    R0,UT2EXIT          POINT TO 31-BIT EXIT\n*        O     R0,=A(X'80000000')  SET 31-BIT MODE IN ADDRESS\n         OILH  R0,X'8000'          SET 31-BIT MODE IN ADDRESS\n         ST    R0,UT2GLUEP-UT2GLUE(,R15) STORE EXIT ADDRESS FOR GLUE\n         SPACE\n         OPEN  ((R4),OUTPUT),MODE=31,MF=(E,OPEN31W)\n         TM    DCBEFLG1-DCBE(R6),DCBEOPEN OPEN SUCCESSFUL\n         BNO   EXITC1\n*        TM    DCBEFLG1-DCBE(R6),DCBEMD31 31-BIT SAM SUPPORTED?\n*        BNO   EXITC2              NO, CLOSE OUTPUT AND QUIT\n         SPACE\n**********************************************************************\n*              SET UP SHA PARAMETER BLOCK\n**********************************************************************\n         MVC   SHA1PB(28),SHA1PI   SET UP PARAMETER BLOCK FOR SHA-1\n*+       MVC   SHA2PB(40),SHA2PI   SET UP PARAMETER BLOCK FOR SHA-256\n         SPACE\n**********************************************************************\n*              READ 64 BYTES AT A TIME\n**********************************************************************\nREADLOOP EQU   *\n         BAL   R14,GET64           READ UP TO 64 BYTES\n         LA    R5,IBUF             POINT TO 64-BYTE SEGMENT\n         LR    R7,R0               GET LENGTH\n         C     R0,=F'64'           DID GET64 GET 64 BYTES?\n         BNE   GOTLAST             NO, BRANCH\n         LM    R14,R15,FILESIZE\n         ALR   R15,R0\n         BC    12,NOCARRY\n         AL    R14,=F'1'\nNOCARRY  STM   R14,R15,FILESIZE\n         B     GOT\n         SPACE\n**********************************************************************\n*         GET64 - READ UP TO 64 BYTES INTO IBUF, SET R0 TO COUNT\n**********************************************************************\n         SPACE\nGET64    LM    R5,R6,GETREGS\n         LA    R15,IBUF\n         L     R0,I64\nGET6A    CR    R5,R6               IF END OF RECORD\n         BNL   GET6R                 THEN READ NEXT RECORD\n         MVC   0(1,R15),0(R5)      COPY ONE BYTE TO OBUF\n         LA    R15,1(,R15)         NEXT OBUF BYTE\n         LA    R5,1(,R5)           NEXT IBUF BYTE\n         BCT   R0,GET6A            DECREMENT R0 AND LOOP\n         L     R0,I64              SET RETURNED LENGTH\n         STM   R5,R6,GETREGS\n         BR    R14\nGET6R    STM   R14,R0,GETREGS+8\n         CLI   GOTEOD,0            IF WE ALREADY HIT EODAD\n         BNE   GET6E                 GO THERE AGAIN\n         LA    R5,UT1DCBEW\n         TM    DCBEFLG1-DCBE(R5),DCBEMD31 31-BIT SAM SUPPORTED?\n         BNO   GET24               NO, USE 24-BIT MOOE FOR GET\n         GET   (R3)\n         B     GETRET\nGET24    LA    R15,GET24S\n*        MVC   0(GET24L,R15),GET24I (ALREADY MOVED, ONCE IS ENOUGH)\n         ST    R13,SAVE24+4        SAVE R13\n         LA    R13,SAVE24          GET NEEDS R13 TO POINT BELOW LINE\n         BASSM R11,R15             RUN GET IN 24-BIT MODE\n         L     R13,SAVE24+4        RESTORE R13\nGETRET   EQU   *\n         LR    R5,R1               POINT R5 TO RECORD\n         TM    RECFM(R3),X'C0'     RECFM U\n         BO    GET6U\n         TM    RECFM(R3),X'80'     RECFM F\n         BO    GET6F\nGET6V    LA    R0,4\n         LH    R6,0(,R5)           LENGTH+4 FROM RDW\n         CLI   OPTR,0              IF R IN PARM\n         BNE   GET6W                  INCLUDE RDW\n         AR    R5,R0               POINT PAST RDW TO EXCLUDE IT\n         SR    R6,R0               REDUCE LENGTH TO EXCLUDE RDW\nGET6W    AR    R6,R5               POINT TO END OF RECORD\n         B     GET6X\nGET6U    LH    R6,LRECL(,R3)       GET LENGTH FROM DCBLRECL\n         AR    R6,R5               POINT TO END OF RECORD\n         B     GET6X\nGET6F    LH    R6,LRECL(,R3)       GET LENGTH FROM DCBLRECL\n         TM    RECFM(R3),X'10'     IF NOT BLOCKED\n         BO    *+8                   THEN\n         LH    R6,BLKSI(,R3)         USE DCBBLKSI AS LENGTH\n         AR    R6,R5               POINT TO END OF RECORD\nGET6X    LM    R14,R0,GETREGS+8\n         B     GET6A\n*              THIS IS INPUT DCB EODAD, IN SOME CASES VIA GLUE\nUT1EOD   DC    0H'0'\nGET6E    CLI   GOTEOD,0            WERE WE ALREADY HERE\n         BE    *+8                 NO\n         EX    R0,*                YES, SOC3 IF EOF TWICE\n         MVI   GOTEOD,1            THAT'S ONCE\n         L     R0,I64\n         S     R0,GETREGS+16       COMPUTE HOW MANY BYTES IN IBUF\n         XC    GETREGS(8),GETREGS\n         L     R14,GETREGS+8\n         BR    R14\n*        THE FOLLOWING INSTRUCTIONS FROM GET24I TO GET24L ARE COPIED\n*        TO STORAGE BELOW THE LINE AND ARE CALLED BY A BASSM.\nGET24I   GET   (R3)\n         BSM   0,R11\nGET24L   EQU   *-GET24I\n         SPACE\n**********************************************************************\n*              USE KIMD FOR EACH RECORD\n**********************************************************************\nGOT      LA    R14,IBUF            DATA ADDRESS\n         LR    R15,R0              DATA LENGTH 64\n         LA    R0,1                FUNCTION CODE 1, SHA-1\n*+       LA    R0,2                FUNCTION CODE 2, SHA-256\n         LA    R1,SHA1PB           SHA-1\n*+       LA    R1,SHA2PB           SHA-256\nKLOOPI   EQU   *\n         KIMD  R2,R14              R2 NOT USED, R14 --> DATA, R15 = LEN\n         BNZ   KLOOPI              LOOP IF PARTIAL\n         B     READLOOP\n         SPACE\n*              R0 CONTAINS 0 TO 63 OR MOD(FILESIZE,64)\n*              THE LENGTH OF ANY REMAINING DATA IN IBUF AFTER\n*              HAVING PROCESSED THE FILE IN 64-BYTE CHUNKS.\nGOTLAST  EQU   *\n         LM    R14,R15,FILESIZE\n         ALR   R15,R0              ADD LENGTH IN R0\n         BC    12,NOCARRYL\n         AL    R14,=F'1'\nNOCARRYL STM   R14,R15,FILESIZE\n**********************************************************************\n*              USE KLMD FOR LAST RECORD\n**********************************************************************\n         SLDL  R14,3               MULTIPLY BY 8, BYTES TO BITS\n*              A FILE OF 536,870,912 BYTES WILL HAVE HEX 100000000 BITS\n*              MAKING THE HIGH WORD OF THE MESSAGE BIT LENGTH NONZERO.\n*              THAT'S 5114 CYLINDERS ON A 3390, ABOUT HALF OF A 3390-9.\n         STM   R14,R15,SHA1PB+20   MESSAGE BIT LENGTH FOR SHA-1\n*+       STM   R14,R15,SHA2PB+32   MESSAGE BIT LENGTH FOR SHA-256\n         LA    R14,IBUF            DATA ADDRESS\n         LR    R15,R0              DATA LENGTH < 64\n         LA    R0,1                FUNCTION CODE 1, SHA-1\n*+       LA    R0,2                FUNCTION CODE 2, SHA-256\n         LA    R1,SHA1PB           SHA-1\n*+       LA    R1,SHA1PB           SHA-256\nKLOOPL   EQU   *\n         KLMD  R2,R14              R2 NOT USED, R14 --> DATA, R15 = LEN\n         BNZ   KLOOPL              LOOP IF PARTIAL\n         SPACE\n**********************************************************************\n*              OUTPUT THE RESULTS\n**********************************************************************\n         MVI   OBUF,C' '\n         MVC   OBUF+1(255),OBUF\n*        MVC   ORDW(4),=AL2(36,0)\n         LA    R15,OBUF\n         TM    RECFM(R4),X'04'     IF ASA CARRIAGE CONTROL\n         BZ    NOTASA                THEN\n         LA    R15,1(,R15)           POINT PAST 1ST COLUMN\nNOTASA   LR    R2,R15\n         LA    R1,SHA1PB           SHA-1\n*+       LA    R1,SHA2PB           SHA-256\n         LA    R0,20 FOR SHA-1\n*+       LA    R0,32 FOR SHA-256\n         BAL   R14,TOHEX\n         LR    R15,R2\n         SPACE\n         LA    R1,40(,R15)         POINT R1 PAST LAST BYTE\n*+       LA    R1,64(,R15)         POINT R1 PAST LAST BYTE SHA-256\n         CLI   OPTE,1              IF NO 'E' IN PARM, (SHOW DSN)\n         BNE   SETLEN                GO TO SETLEM\n         MVI   1(R1),C'*'          ELSE ADD *\n         MVC   2(44,R1),JFCB       AND DSN\n         LA    R1,45(,R1)          LAST CHAR OF DSNAME\n         LA    R0,44               INITIAL LENGTH\nFILEA    CLI   0(R1),C' '          IS THIS LAST NONBLANK\n         BNE   FILEB               YES, BRANCH\n         BCTR  R1,0                BACK UP 1 CHARACTER\n         BCT   R0,FILEA            DECREMENT LENGTH AND BRANCH\nFILEB    LA    R1,1(,R1)           POINT PAST LAST CHAR\n         CLI   JFCB+44,C' '        IF NO MEMBER IN JFCB\n         BE    SETLEN                GO TP SETLEM\n         MVI   0(R1),C'('\n         MVC   1(8,R1),JFCB+44     JFCBELNM IN IEFJFCBN\n         LA    R1,8(,R1)           LAST CHAR OF MEMBER NAME\n         LA    R0,8\nMEMA     CLI   0(R1),C' '\n         BNE   MEMB\n         BCTR  R1,0\n         BCT   R0,MEMA\nMEMB     MVI   1(R1),C')'\n         LA    R1,1(,R1)           POINT PAST LAST CHAR\nSETLEN   LA    R0,OBUF\n         SR    R1,R0               COMPUTE LENGTH\nNONAME   EQU   *\n         CLI   OPTL,1              IF 'L' IN PARM, FOR LOWERCASE\n         BNE   *+10                  THEN\n         TR    OBUF(256),LOWER       TRANSLATE TO LOWER CASE\n         LA    R0,OBUF             PUT WILL USE R0 AS RECORD ADDRESS\nPUTU     TM    RECFM(R4),X'C0'     IF OUTPUT RECFM U\n         BNO   PUTV\n         LH    R0,BLKSI(,R4)         GET BLKSI\n         CR    R1,R0                 IF LONGER THAN BLKSI\n         BNH   *+6                     THEN\n         LR    R1,R0                   TRUNCATE TO BLKSI\n         STH   R1,LRECL(,R4)         SET RECFM U RECORD SIZE\n         B     PUTT\nPUTV     TM    RECFM(R4),X'40'     IF RECFM V\n         BZ    PUTT                  THEN\n         LA    R1,4(,R1)             LENGTH + 4 FOR RDW\n         LH    R0,LRECL(,R4)         GET LRECL\n         CR    R1,R0                 IF LONGER THAN LRECL\n         BNH   *+6                     THEN\n         LR    R1,R0                   TRUNCATE TO LRECL\n         SLL   R1,16                 SHIFT LEFT 16 BITS\n         ST    R1,ORDW               SET RDW\n         LA    R0,ORDW               USE RDW FOR PUT\nPUTT     LA    R6,UT2DCBEW\n         TM    DCBEFLG1-DCBE(R6),DCBEMD31 31-BIT SAM SUPPORTED?\n         BNO   PUT24               NO, USE 24-BIT MOOE FOR PUT\n         PUT   (R4),(0)\n         B     EXIT0\nPUT24    LA    R15,PUT24S\n         MVC   0(PUT24L,R15),PUT24I\n         ST    R13,SAVE24+4        SAVE R13\n         LA    R13,SAVE24          PUT NEEDS R13 TO POINT BELOW LINE\n         BASSM R11,R15             RUN PUT IN 24-BIT MODE\n         L     R13,SAVE24+4        RESTORE R13\n         B     EXIT0\n         SPACE\n*        THE FOLLOWING INSTRUCTIONS FROM PUT24I TO PUT24L ARE COPIED\n*        TO STORAGE BELOW THE LINE AND ARE CALLED BY THE BASSM ABOVE.\n*        THEY RUN IN 24-BIT MODE SO THE PUT WILL WORK FOR A TERMINAL.\n*        THEY DON'T USE A BASE REGISTER, SO THAT SIMPLIFIES IT.\nPUT24I   PUT   (R4),(0)\n         BSM   0,R11\nPUT24L   EQU   *-PUT24I\n         SPACE\nEXITN    CLI   RETCODE+3,12        IF AN ERROR OCCURRED\n         BNE   EXITC2                DON'T SET RC 0\nEXIT0    MVI   RETCODE+3,0\nEXITC2   MVC   CLOSE31W(CLOSE31L),CLOSE31\n         CLOSE ((R4)),MODE=31,MF=(E,CLOSE31W)\n*        LR    R7,R4\n*        BAL   R2,FREEPOOL\nEXITC1   MVC   CLOSE31W(CLOSE31L),CLOSE31\n         CLOSE ((R3)),MODE=31,MF=(E,CLOSE31W)\n*        LR    R7,R3\n*        BAL   R2,FREEPOOL\n         B     EXIT\n*REEPOOL FREEPOOL (R7)\n*        BR    R2\n         SPACE\nTOHEX    MVC   1(1,R15),0(R1)\n         UNPK  0(3,R15),1(2,R15)\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)\n         LA    R1,1(,R1)\n         BCT   R0,TOHEX\n         MVI   0(R15),C' '\n         BR    R14\n         SPACE\nEXIT     L     R2,RETCODE\n         LR    R1,R8\n         LA    R0,@DATA24L\n         STORAGE RELEASE,ADDR=(1),LENGTH=(0)\n         LR    R1,R13\n         L     R0,@SIZE\n         L     R13,4(,R13)\n         STORAGE RELEASE,ADDR=(1),LENGTH=(0)\n         DROP  R9\n         LR    R15,R2\n         LM    0,12,20(R13)\n         L     R14,12(,R13)\n         BR    R14\n         SPACE\n*         DCB OPEN EXIT\nUT2EXIT  CLI   RECFM(R1),0         IF NO RECFM\n         BNE   UT2EXI2                THEN\n         MVI   RECFM(R1),X'90'        USE FB\nUT2EXI2  TM    RECFM(R1),X'10'     IF BLOCKED\n         BZ    UT2EXI3                AND\n         CLC   LRECL(2,R1),=H'0'      NO LRECL\n         BNE   UT2EXI3                THEN\n         MVC   LRECL(2,R1),=H'80'     USE 80\nUT2EXI3  CLC   BLKSI(2,R1),=H'0'   IF NO BLKSIZE\n         BNE   UT2EXI4                THEN\n         MVC   BLKSI(2,R1),LRECL(R1)  USE LRECL\nUT2EXI4  BR    R14\n         SPACE\n*        THIS ROUTINE IS COPIED TO 24-BIT STORAGE\n*        IT IS ENTERED IN 24-BIT MODE, CALLS UT2EXIT IN 31-BIT MODE\n*        LEAVING ORIGINAL R14 RETURN ADDRESS IN R14\n         CNOP  0,4                 ALIGN ON FULLWORD\nUT2GLUE  L     R15,UT2GLUEP-*(,R15)   GET ADDRESS OF UT2EXIT\n         BSM   R14,R15             CALL UT2EXIT WITH OLD MODE IN R14\nUT2GLUEP DC    F'0'                WILL CONTAIN ADDRESS OF UT2EXIT\nUT2OPENL EQU   *-UT2GLUE\n         SPACE\n*        THIS ROUTINE IS COPIED TO 24-BIT STORAGE\n*        IT IS ENTERED IN 24-BIT MODE, GOES TO UT1EOD IN 31-BIT MODE\n         CNOP  0,4                 ALIGN ON FULLWORD\nEOD24I   L     R15,EOD24P-*(,R15)  GET ADDRESS OF UT1EOD AND 31-BIT\n         L     R13,SAVE24+4        RESTORE R13 CHANGED BEFORE GET\n         BSM   R0,R15              GOTO UT1EOD IN 31-BIT MODE\nEOD24P   DC    F'0'                WILL CONTAIN ADDRESS OF UT2EXIT\nEOD24L   EQU   *-EOD24I\n         SPACE\n         LTORG\n         DC    0D'0'\n         PRINT NOGEN\nUT1DCB   DCB   DDNAME=SYSUT1,DSORG=PS,MACRF=(GL),EODAD=0,DCBE=0\nUT1DCBL  EQU   *-UT1DCB\nUT1DCBE  DCBE  RMODE31=BUFF,EODAD=UT1EOD\nUT1DCBEL EQU   *-UT1DCBE\nUT2DCB   DCB   DDNAME=SYSUT2,DSORG=PS,MACRF=(PM),EXLST=0,DCBE=0\nUT2DCBL  EQU   *-UT2DCB\nUT2DCBE  DCBE  RMODE31=BUFF\nUT2DCBEL EQU   *-UT2DCBE\nUT1EXL   DC    0F'0',X'87',AL3(0)\nUT2EXL   DC    0F'0',X'85',AL3(0)\nOPEN31   OPEN  (0,),MODE=31,MF=L\nOPEN31L  EQU   *-OPEN31\nCLOSE31  CLOSE (0,),MODE=31,MF=L\nCLOSE31L EQU   *-CLOSE31\n         DC    0D'0'\nHEXTAB   DC    C'0123456789ABCDEF'\nLOWER    DC    256AL1(*-LOWER)\n         ORG   LOWER+C'A'\n         DC    X'818283848586878889'\n         ORG   LOWER+C'J'\n         DC    X'919293949596979899'\n         ORG   LOWER+C'S'\n         DC    X'A2A3A4A5A6A7A8A9'\n         ORG\n         DC    0D'0'\n*+       AGO   .SKIP1\nSHA1PI   DC    X'67452301' H0\n         DC    X'EFCDAB89' H1\n         DC    X'98BADCFE' H2\n         DC    X'10325476' H3\n         DC    X'C3D2E1F0' H4\n         DC    X'00000000' MESSAGE BIT LENGTH HIGH\n         DC    X'00000000' MESSAGE BIT LENGTH LOW\n         SPACE\n.SKIP1   ANOP\n         AGO   .SKIP2\nSHA2PI   DC    X'6A09E667' H0\n         DC    X'BB67AE85' H1\n         DC    X'3C6EF372' H2\n         DC    X'A54FF53A' H3\n         DC    X'510E527F' H4\n         DC    X'9B05688C' H5\n         DC    X'1F83D9AB' H6\n         DC    X'5BE0CD19' H7\n         DC    X'00000000' MESSAGE BIT LENGTH HIGH\n         DC    X'00000000' MESSAGE BIT LENGTH LOW\n.SKIP2   ANOP\n         DC    0D'0'\n         SPACE\n@DATA    DSECT\n         DS    18F\nRETCODE  DS    F\nOPEN31W  DS    0F,(OPEN31L)X\nCLOSE31W DS    0F,(CLOSE31L)X\nOPTE     DS    H\nOPTL     DS    H\nOPTR     DS    H\nGOTEOD   DS    C\nI64      DS    F\nGETREGS  DS    5F\nFILESIZE DS    2F\nDOUBLE   DS    D\n@CLEARL  EQU   *-@DATA\nUT1DCBEW DS    0F,(UT1DCBEL)X\nUT2DCBEW DS    0F,(UT2DCBEL)X\nIBUF     DS    CL64\nSHA1PB   DS    0D,7F\nSHA2PB   DS    0D,10F\n         DS    0D\n@DATAL   EQU   *-@DATA\n         SPACE\n@DATA24  DSECT\nSAVE24   DS    18F\nUT1DCBW  DS    0F,(UT1DCBL)X\nUT2DCBW  DS    0F,(UT2DCBL)X\nUT1EXLST DS    F\nUT2EXLST DS    F\nUT1RDJF  DS    F\nUT2OPENX DS    0F,(UT2OPENL)X  GLUE ROUTINE COPIED HERE\nGET24S   DS    0H,(GET24L)X\nPUT24S   DS    0H,(PUT24L)X\nEOD24S   DS    0H,(EOD24L)X\n*        OUTPUT BUFFERS ARE HERE IN CASE PUT TO TERMINAL, DCBEMD31 OFF\nORDW     DS    F\nOBUF     DS    256C\n         DS    0D\nJFCB     DS    CL176\n         DS    0D\n@DATA24L EQU   *-@DATA24\n         SPACE\n         PRINT NOGEN\n         IHADCBE\n         SPACE\n*         EQUATES FOR DCB FIELD OFFSETS\nEXLST    EQU   36\nRECFM    EQU   36\nDDNAM    EQU   44\nOFLGS    EQU   48\nBLKSI    EQU   62\nLRECL    EQU   82\n         SPACE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SHA1PGM$": {"ttr": 4871, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00F\\x01 \\x14\\x1f\\x01 \\x14\\x1f\\x11Q\\x00\\x10\\x00\\x10\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-05-20T00:00:00", "modifydate": "2020-05-20T11:51:46", "lines": 16, "newlines": 16, "modlines": 0, "user": "UPDATED"}, "text": "//CBTUSER1 JOB (ACCT),'PGMRNAME',NOTIFY=CBTUSER,\n//         MSGLEVEL=(1,1),MSGCLASS=H\n//ASM     EXEC PGM=ASMA90,\n//             PARM=(LIST,OBJ,NODECK,ASA,NOXREF,NODX,NOMX,NORX,NOUS,\n//             BATCH,'PC(NOUHD)')\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//SYSLIN   DD  DSN=&&OBJ,DISP=(NEW,PASS),SPACE=(TRK,(3,3)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=800)\n//SYSIN    DD  DSN=CBTUSER.LIB.ASM(SHA1PGM),DISP=SHR\n//LKED   EXEC PGM=HEWLF064,PARM='MAP,NOXREF,RENT,REFR',\n//             COND=(0,NE)\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSNAME=&&OBJ,DISP=(OLD,DELETE)\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(TRK,(10,0))\n//SYSLMOD  DD  DSN=CBTUSER.LIB.LOAD(SHA1PGM),DISP=SHR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SHA1SUM": {"ttr": 4873, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x00Y\\x01\\x16\\x14\\x8f\\x01\\x19\\x07\\x7f\\x13#\\x05\\x8f\\x05{\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "2016-05-27T00:00:00", "modifydate": "2019-03-18T13:23:59", "lines": 1423, "newlines": 1403, "modlines": 0, "user": "UPDATED"}, "text": "         TITLE '   S H A 1 S U M  '\n************************************************************\n*                                                          *\n*        'SHA1SUM' TSO COMMAND (31-BIT)                    *\n*                                                          *\n************************************************************\n         SPACE\n*        WRITTEN MAY 22 2016 USING MD5SUM AS A TEMPLATE.\n*         NOTE: MD5SUM USED 'COUNT' (CBT FILE 300) AS A TEMPLATE.\n*        ATTRIBUTES. RE-ENTRANT.\n*        UPDATED MAY 27 2016 TO ADD BRIEF AND MULTI KEYWORDS.\n*        UPDATED AUG 28 2016 TO IGNORE DS1LSTAR WHICH IS 0 FOR PDSE\n*        UPDATED SEP  3 2016 TO SET RETURN CODE 12 IF ANY ERROR\n*        UPDATED DEC 27 2017 TO SUPPORT 8-BYTE PREFIX IN Z/OS V2R3\n*        UPDATED MAR 18 2019 TO SUPPORT EAV VOLUMES (SEE CHANGES BELOW)\n*\n*        THIS TSO COMMAND READS THE SPECIFIED SEQUENTIAL DATA SETS\n*        OR PDS MEMBERS AND DISPLAYS THE SHA-1 HASH FOR EACH.\n*        SHA = SECURE HASH ALGORITHM.\n*\n*        SYNTAX:\n*                SHA1SUM DSNAME\n*                SHA1SUM (DSNAME1 DSNAME2 ...)\n*        KEYWORDS:\n*                RDW - INCLUDE RDW'S\n*                LOWER - SHOW RESULTS IN LOWER CASE\n*                QUICK - DSNAME IS COMPLETE, NO IMPLIED EXTENSION\n*                FILE - DSNAME IS A DDNAME ALREADY ALLOCATED\n*                BRIEF - SHOW THE HASH ONLY, WITH NO DSNAME\n*                MULTI - SHOW THE HASH AND DSNAME ON SEPARATE LINES\n*\n*        IF AN UNQUALIFIED DATA SET NAME IS ENTERED, THE\n*        CATALOG MUST BE READ TWICE, ONCE TO APPEND A\n*        TRAILING QUALIFIER IF NECESSARY, AND AGAIN DURING\n*        ALLOCATION. THE USER CAN ELIMINATE THE FIRST BY USING\n*        THE FULLY QUALIFIED NAME, PREFIX AND ALL, IN QUOTES,\n*        OR BY ENTERING ALL BUT THE PREFIX, WITHOUT QUOTES,\n*        PLUS THE KEYWORD 'Q'. THE LATTER IS MUCH SIMPLER\n*        AND GIVES THE SAME PERFORMANCE IMPROVEMENT AS A\n*        FULLY QUALIFIED NAME.\n*\n*        THE 'FILE' KEYWORD IS USEFUL FOR READING TEMPORARY\n*        DATA SETS.  IT TELLS THE COMMAND TO TREAT THE FIRST\n*        OPERAND AS A FILENAME (DDNAME) INSTEAD OF A DSNAME.\n*        WHATEVER DATA SET IS CURRENTLY ALLOCATED TO THE\n*        FILENAME WILL BE READ (AND QUICKLY, BECAUSE\n*        THE COMMAND DOESNT HAVE TO ALLOCATE ANYTHING).\n*\n*        UNIX FILES THAT ARE PREALLOCATED TO A DDNAME CAN BE\n*        READ. FOR EXAMPLE:\n*         ALLOC FI(DD1) PATH('/ETC/MAGIC') (BUT USE PATH IN LOWER CASE)\n*         SHA?SUM DD1 FILE\n*        IF UNIX FILES ARE NOT GIVEN RECFM WHEN ALLOCATED\n*        THEY DEFAULT TO RECFM=U, WHICH IS GOOD FOR SHA?SUM.\n*        RECFM=F WOULD BE LIKELY TO INTRODUCE PADDING IN THE\n*        LAST RECORD, WHICH WOULD CHANGE THE SHA?SUM RESULT.\n*\n*        NOTE - IF A NON-EXISTENT MEMBER OF A PDS IS SPECIFIED,\n*        THE RESULTING 013-18 ABEND IS TRAPPED BY A DCB ABEND\n*        EXIT, BUT A MESSAGE IS ISSUED BY OPEN ANYWAY. THIS\n*        METHOD IS USED BECAUSE THE ADDITIONAL OVERHEAD\n*        OF ALLOCATING THE PDS AND DOING A 'BLDL' WOULD\n*        DEGRADE THE PERFORMANCE UNACCEPTABLY.\n*\n*        PROBLEMS FIXED:\n*        . IF THE SPECIFIED DDNAME (WITH 'FILE' KEYWORD) IS\n*          A MEMBER OF A PDS, ONLY THE PDS NAME WAS SHOWN.\n*          ADDED CODE TO GET MEMBER NAME FROM JFCBELNM.\n*        . IF THE SPECIFIED DDNAME (WITH 'FILE' KEYWORD) IS\n*          A UNIX PATH, ONLY \"...PATH=.SPECIFIED...\" IS SHOWN,\n*          THAT'S WHAT IS IN THE JFCB. ADDED ARL TO GET PATH.\n*\n*        IMPROVEMENTS NEEDED:\n*        . ALLOW PATH TO BE SPECIFIED AND ALLOCATE IT.\n*        . IF THE SPECIFIED DDNAME (WITH 'FILE' KEYWORD) IS\n*          A CONCATENATION, SHOW MORE THAN THE FIRST DSN OR PATH.\n*\n* CHNGE LOG: 02JUN92 - INCLUDED 'OBTAIN' MACRO IN THE SOURCE. WITH\n*                      MVS/XA 2.2.3, THE MACRO IS ONLY AVAILABLE IN\n*                      'SYS1.AMACLIB' (SOUNDS LIKE IBM IS TRYING TO\n*                      TELL US SOMETHING).  JIM MARSHALL         JDM1\n*\n* CHNGE LOG: 12OCT13 - MD5SUM COMMAND CREATED FROM SOURCE OF 'COUNT'.\n*                      RDW'S ARE NOT INCLUDED IN THE MD5 AT THIS TIME,\n*                      AS A RESULT, 2 FILES OF VARIABLE-LENGTH RECORDS,\n*                      ONE WITH 2 RECORDS \"AB\" AND \"CD\" AND THE OTHER\n*                      ONE WITH 2 RECORDS \"ABC' AND \"D\" WILL HAVE THE\n*                      SAME MD5 VALUE.\n*\n* CHNGE LOG: 11NOV13 - SUPPORT LIST OF DSNAMES, SHOW NAME AFTER MD5.\n*\n* CHNGE LOG: 12NOV13 - CONVERT TO 31-BIT.\n*\n* CHNGE LOG: 15NOV13 - ALLOW NON-DASD DEVTYPE INCLUDING UNIX AND DUMMY.\n*                      SHOW UNIX FILE NAME IF DDNAME ALLOCATED TO PATH.\n*                      SHOW MEMBER NAME IF DDNAME ALLOCATED TO MEMBER.\n*\n* CHNGE LOG: 13MAR19 - REVERSED THE CHANGE FROM JUNE 02, 1992 AND USED\n*                      THE ORIGINAL OBTAIN MACRO AGAIN. ADDITIONALLY\n*                      ADDED THE EADSCB=OK MACRO PARAMETER.\n*\n*--------------------------------------------------------------------\n*         MACRO                                                  JDM1\n*&NAME    OBTAIN &LIST,&DUMMY=                                   JDM1\n*         AIF   (T'&LIST EQ 'O').E1                              JDM1\n*&NAME    IHBINNRA &LIST                 LOAD REG 1              JDM1\n*         SVC   27                       ISSUE OBTAIN SVC        JDM1\n*         MEXIT                                                  JDM1\n*.E1      IHBERMAC 34                    LIST ADDR MISSING       JDM1\n*         MEND                                                   JDM1\n*--------------------------------------------------------------------\n*         INTERCEPT 'LINK' MACRO IMBEDDED IN STACK MACRO\n*         TO MAKE SF=(E,LINKAREA) THE DEFAULT.\n         MACRO\n&NAME    LINK  &EP=,&SF=(E,LINKAREA)\n&NAME    LA    15,&SF(2)\n         LA    0,*+8\n         B     *+12\n         DC    CL8'&EP'\n         ST    0,0(0,15)\n         SVC   6             ISSUE LINK SVC\n         MEND\n         SPACE\nSHA1SUM  START\nSHA1SUM  AMODE 31\nSHA1SUM  RMODE 31\n         USING *,R12,R11\n         B     @PROLOG-*(,R15)\n         DC    AL1(7),CL7'SHA1SUM'\n         DC    CL16' &SYSDATE &SYSTIME '\n@SIZE31  DC    0F'0',AL1(0),AL3(@DATA31L)\n@SIZE24  DC    0F'0',AL1(1),AL3(@DATA24L)\n@PROLOG  STM   14,12,12(13)\n         LR    R12,R15             BASE\n         LA    R15,1\n         LA    R11,4095(R15,R12)   BASE\n         LR    R2,R1\n         USING CPPL,R2\n         L     R0,@SIZE31\n         GETMAIN RU,LV=(0),SP=1,LOC=31\n         LR    R9,R1\n         USING @DATA31,R9\n         ST    13,4(,1)            CHAIN SAVEAREA\n         ST    1,8(,13)            CHAIN SAVEAREA\n         LR    13,1                NEW SAVEAREA\n         SPACE\n         L     R0,@SIZE24\n         GETMAIN R,LV=(0)\n         LR    R10,R1\n         USING @DATA24,R10\n         SPACE\n         MVI   STATUS,0\n         XC    LINKAREA(8),LINKAREA\n         SLR   R15,R15\n         STH   R15,RETCODE         SET RETCODE = 0\n         ST    R15,KOUNT\n         ST    R15,KOUNTSP\n         SPACE\n************************************************************\n*                                                          *\n*        SET UP IOPL FOR PUTLINE                           *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R15,MYIOPL\n         USING IOPL,R15\n         MVC   IOPLUPT(4),CPPLUPT\n         MVC   IOPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,IOPLECB\n         XC    MYECB,MYECB\n         LA    R0,MYPTPB\n         ST    R0,IOPLIOPB\n         DROP  R15                 IOPL\n         SPACE\n         L     R15,16              LOAD CVT POINTER\n         TM    444(R15),X'80'      IS PUTLINE LOADED? (VS2)\n         BNO   PUTLOAD             NO - BRANCH TO LOAD\n         L     R15,444(,R15)       YES - USE CVTPUTL\n         B     PUTLOADX            BRANCH AROUND LOAD\nPUTLOAD  LA    R0,=CL8'IKJPUTL '\n         LOAD  EPLOC=(0)\n         LR    R15,R0              GET ENTRY ADDRESS\n         LA    R15,0(,R15)         CLEAR HI BYTE FOR DELETE ROUTINE\nPUTLOADX ST    R15,MYPUTLEP        SAVE PUTLINE ENTRY ADDRESS\n         SPACE\n************************************************************\n*                                                          *\n*        SET UP PPL FOR PARSE                              *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R15,MYPPL\n         USING PPL,R15\n         MVC   PPLUPT(4),CPPLUPT\n         MVC   PPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,PPLECB\n         XC    MYECB,MYECB\n         L     R0,=A(SHASMPCL)\n*        LA    R0,PCLADDR\n         ST    R0,PPLPCL\n         LA    R0,MYANS\n         ST    R0,PPLANS\n         XC    MYANS(4),MYANS\n         MVC   PPLCBUF(4),CPPLCBUF\n         ST    R9,PPLUWA\n         DROP  R15                 PPL\n         SPACE 1\n************************************************************\n*                                                          *\n*        CALL THE PARSE SERVICE ROUTINE                    *\n*                                                          *\n************************************************************\n         SPACE\n         LR    R1,R15              POINT TO PPL\n*        CALLTSSR EP=IKJPARS\n         L     R15,16              CVTPTR\n         TM    524(R15),X'80'      IF HI ORDER BIT NOT ON\n         BNO   PARSELNK               THEN DO LINK, NOT CALL\n         L     R15,524(,R15)       CVTPARS\n         BALR  R14,R15             CALL IKJPARS\n         B     PARSEEXT            SKIP AROUND LINK\nPARSELNK EQU   *\n         LINK  EP=IKJPARS,SF=(E,LINKAREA)\nPARSEEXT EQU   *\n         SPACE 1\n         LTR   R15,R15\n         BZ    PARSEOK\n         LA    R1,MSG01\n         LA    R0,L'MSG01\n         BAL   R14,PUTMSG\n         LA    R15,12\n         B     EXIT\nPARSEOK  EQU   *\n         SPACE\n         L     R3,MYANS\n         USING IKJPARMD,R3\n         SPACE\n         MVC   OPTR,RDWKW+1\n         SPACE\n************************************************************\n*                                                          *\n*        GET THE FIRST OR NEXT DSN IN THE LIST             *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R6,DSN\n         ST    R6,DSL\n         B     FIRSTDSN\nNEXTDSN  L     R6,DSL\n         CLI   24(R6),X'FF'        END OF DSN LIST?\n         BE    DONE\n         L     R6,24(,R6)          POINT TO NEXT ENTRY\n         ST    R6,DSL\nFIRSTDSN SR    R0,R0\n         ST    R0,KOUNT\n         SPACE\n************************************************************\n*                                                          *\n*        QUALIFY THE DSNAME IF NECESSARY                   *\n*                                                          *\n************************************************************\n         SPACE\n         TM    6(R6),X'80'         IS DATASET NAME SPECIFIED?\n         BO    OKDSN               YES - BRANCH\n         LA    R1,MSG05            NO - JUST MEMBER NAME\n         LA    R0,L'MSG05\n         BAL   R14,PUTMSG\n         B     NEXTD12\nOKDSN    EQU   *\n         LA    R15,DSNAME+2\n         MVI   0(R15),C' '         BLANK THE DSNAME AREA\n         MVC   1(43,R15),0(R15)\n         SLR   R1,R1\n         STH   R1,DSNAME           ZERO DSNAME LENGTH\n         TM    6(R6),X'40'         IS DSN QUOTED?\n         BO    NOPREF              YES, SKIP PREFIXING\n         CLI   FILEKW+1,1          DSN TO BE TREATED AS DDNAME\n         BE    NOPREF              YES, SKIP PREFIXING\n         L     R14,CPPLUPT         POINT TO UPT\n         USING UPT,R14\n*         CHECK UPT FOR 8-BYTE PREFIX - Z/OS V2R3.\n         CLI   UPTPREFX,C'>'      IF PREFIX IS '>7BYTES' (8 BYTES)\n         BNE   PREF07                THEN\n         IC    R1,UPTPREFL+18        GET UPTPRF8L (SHOULD ALWAYS BE 8)\n         LTR   R1,R1                 IS IT ZERO\n         BZ    NOPREF                YES, SKIP PREFIXING\n         B     *+10\n         MVC   0(0,R15),UPTPREFX+17  COPY UPTPREF8\n         EX    R1,*-6              MOVE USERID TO DSNAME AREA\n         B     PREFDONE\nPREF07   EQU   *\n         IC    R1,UPTPREFL         GET LENGTH OF PREFIX\n         LTR   R1,R1               IS IT ZERO\n         BZ    NOPREF              YES, SKIP PREFIXING\n         B     *+10\n         MVC   0(0,R15),UPTPREFX\n         EX    R1,*-6              MOVE USERID TO DSNAME AREA\nPREFDONE EQU   *\n         DROP  R14                 UPT\n         LA    R15,0(R1,R15)       POINT PAST USERID\n         MVI   0(R15),C'.'         APPEND PERIOD\n         LA    R15,1(,R15)         POINT PAST PERIOD\n         LA    R1,1(,R1)           ADD 1 TO LENGTH\n         STH   R1,DSNAME           STORE LENGTH OF USERID PLUS 1\nNOPREF   EQU   *\n         LH    R1,4(,R6)           GET LENGTH\n         LR    R0,R1\n         AH    R0,DSNAME           ADD LENGTH OF PREFIX OR ZERO\n         STH   R0,DSNAME           SET COMBINED LENGTH\n         L     R14,0(,R6)          POINT TO DSN VALUE\n         BCTR  R1,0                LENGTH MINUS 1 FOR EX\n         B     *+10                BRANCH AROUND EXECUTED MVC\n         MVC   0(0,R15),0(R14)     (EXECUTED)\n         EX    R1,*-6              MOVE DSN TO DSNAME (AFTER PREFIX)\n         SPACE\n************************************************************\n*                                                          *\n*        IF 'FILE' KEYWORD IS SPECIFIED,                   *\n*        GET DSNAME FROM JFCB USING FILE NAME.             *\n*                                                          *\n************************************************************\n         SPACE\n         CLI   FILEKW+1,1          'FILE' SPECIFIED?\n         BNE   NOFILE              NO, BRANCH\n         CLI   DSNAME+1,8          IS LENGTH 8 OR LESS\n         BH    FILERR1             NO, BRANCH\n         DEVTYPE DSNAME+2,DEVDATA  GET DEVICE TYPE\n         LTR   R15,R15             WAS FILENAME VALID\n         BNZ   FILERR2             NO, BRANCH\n*        CLC   DEVDATA(8),=X'0000010300007FF8'\n*        BE    DEVOK\n*        TM    DEVDATA+2,X'20'     DIRECT ACCESS\n*        BZ    FILERR3             NO, BRANCH\nDEVOK    LA    R4,DYNDCBW\n         MVC   0(DYNDCBL,R4),DYNDCB\n         XC    DSNAME(2),DSNAME\n         XC    MEMLEN,MEMLEN\n         LA    R0,JFCB\n         LA    R1,DYNEXLST\n         ST    R0,0(,R1)\n         MVI   0(R1),X'07'\n         LA    R14,MYARL           ALLOCATION RETRIEVAL LIST\n         ST    R14,4(,R1)\n         MVI   4(R1),X'13'+X'80'\n         ST    R1,DCBEXLST-IHADCB(,R4)\n         USING ARL,R14\n         XC    0(36,R14),0(R14)\n         MVI   ARLLEN+1,36\n         MVC   ARLIDENT,=C'AR'\n         OI    ARLOPT1,ARLLANY+ARLUSS\n         MVC   40(8,R4),DSNAME+2   DCBDDNAM\n         MVC   DDSAVE,DSNAME+2\n         MVI   RDJFW,X'80'\n         RDJFCB ((R4)),MF=(E,RDJFW)\n         LA    R14,MYARL\n         L     R1,ARLAREA\n         LTR   R1,R1\n         BZ    NOARA\n         L     R0,ARLRTRVD\n         DROP  R14                 ARL\n         USING ARA,R1\nLOOPARA  TM    ARAFLG,ARAXINF\n         BZ    DONEARA\n         SR    R15,R15\n         IC    R15,ARAXINOF\n         SLL   R15,3\n         AR    R15,R1\n         USING ARAXINFO,R15\n         SR    R14,R14\n         ICM   R14,3,ARAPATHO      GET OFFSET TO PATH LEN\n         BZ    DONEARA\n         AR    R14,R15\n         DROP  R15                 ARAXINLN\n         SR    R15,R15\n         ICM   R15,3,0(R14)        GET ARAPATHLEN\n         CH    R15,=H'44'\n         BNH   *+8\n         LA    R15,44              JUST SHOW FIRST 44 FOR NOW\n         STH   R15,DSNAME\n         BCTR  R15,0\n         B     *+10\n         MVC   DSNAME+2(0),2(R14)  ARAPATHNAM\n         EX    R15,*-6\nDONEARA  LA    R14,MYARL           PREPARE FOR FREEMAIN\n         USING ARL,R14\n         SR    R15,R15             PREPARE FOR FREEMAIN\n         IC    R15,ARLPOOL\n         SR    R0,R0\n         ICM   R0,7,ARLRLEN\n         L     R1,ARLAREA\n         DROP  R14                 ARL\n         FREEMAIN RU,LV=(0),SP=(R15),A=(1)\nNOARA    CLC   DSNAME(2),=H'0'\n         BNE   FILESPEC\n         MVC   DSNAME+2(44),JFCB\n         LA    R1,DSNAME+45        LAST CHAR OF DSNAME\n         LA    R0,44               INITIAL LENGTH\nFILEA    CLI   0(R1),C' '          IS THIS LAST NONBLANK\n         BNE   FILEB               YES, BRANCH\n         BCTR  R1,0                BACK UP 1 CHARACTER\n         BCT   R0,FILEA            DECREMENT LENGTH AND BRANCH\nFILEB    STH   R0,DSNAME           STORE LENGTH OF DSNAME\n*        MVC   VOLUME(6),JFCB+118  GET VOLUME FROM JFCB\n         MVC   MEMNAME,JFCB+44     JFCBELNM IN IEFJFCBN\n         LA    R1,MEMNAME+7        LAST CHAR OF MEMBER NAME\n         LA    R0,8\nMEMA     CLI   0(R1),C' '\n         BNE   MEMB\n         BCTR  R1,0\n         BCT   R0,MEMA\nMEMB     STH   R0,MEMLEN\n         B     FILESPEC\nFILERR1  LA    R0,MSG14A\n         B     FILERR\nFILERR2  LA    R0,MSG14B\n         B     FILERR\nFILERR3  LA    R0,MSG14C\nFILERR   MVC   MSGWK(L'MSG14),MSG14\n         LA    R15,MSGWK+L'MSG14\n         LA    R14,DSNAME\n         LH    R1,0(,R14)\n         BCTR  R1,0\n         B     *+10\n         MVC   MSGWK+L'MSG14(0),2(R14)\n         EX    R1,*-6\n         LA    R15,1(R1,R15)\n         LR    R14,R0 POINT TO MSG14A, B, OR C\n         MVC   0(L'MSG14A,R15),0(R14)\n         LA    R0,L'MSG14+L'MSG14A+1(,R1)\n         LA    R1,MSGWK\n         BAL   R14,PUTMSG\n         B     QUITD12\nNOFILE   EQU   *\n         TM    6(R6),X'40'         IS IT QUOTED?\n         BO    DEFX                YES - SKIP DEFAULT SERVICE\n         CLI   QUICKW+1,1          QUICK SPECIFIED\n         BE    DEFX                YES, USER ENTERED ALL BUT PREFIX\n         SPACE\n************************************************************\n*                                                          *\n*        DEFAULT SERVICE ROUTINE TO GET QUALIFIERS         *\n*                                                          *\n************************************************************\n         SPACE\n*              ALL INPUT TO IKJEHDEF MUST BE BELOW THE LINE\n         MVC   DSNAME24(46),DSNAME\n         LA    R15,MYIOPL24\n         USING IOPL,R15\n         LA    R14,MYIOPL\n         MVC   IOPLUPT(4),IOPLUPT-IOPL(R14)\n         MVC   IOPLECT(4),IOPLECT-IOPL(R14)\n         LA    R0,MYECB24\n         ST    R0,IOPLECB\n         XC    MYECB24,MYECB24\n         LA    R14,MYDFPB\n         ST    R14,IOPLIOPB\n         USING DFPB,R14\n         XC    0(20,R14),0(R14)\n         LA    R0,DSNAME24\n         ST    R0,DFPBDSN\n         OI    DFPBCODE,X'04'      SEARCH CAT AND PROMPT IF MULTI\n         MVC   DFPBPSCB,CPPLPSCB\n*        MVI   DFPBCNTL,X'20'      PREFIX THE DSNAME\n         DROP  R14                 DFPB\n         DROP  R15                 IOPL\n         SPACE\n         LR    R1,R15              POINT TO IOPL\n         LA    R13,SAVE24          POINT TO SAVEAREA BELOW THE LINE\n         L     R15,16              CVTPTR\n         TM    736(R15),X'80'      IF HI ORDER BIT NOT ON\n         BNO   EHDEFLNK               THEN DO LINK, NOT CALL\n         L     R15,736(,R15)       CVTEHDEF\n         BALR  R14,R15             CALL IKJEHDEF\n         B     EHDEFEXT            SKIP AROUND LINK\nEHDEFLNK EQU   *\n         LINK  EP=IKJEHDEF,SF=(E,LINKAREA)\nEHDEFEXT EQU   *\n         SPACE\n         LR    R13,R9              RESTORE SAVEARE POINTER\n         B     DEFCODE(R15)\nDEFCODE  B     DEF00               SUCCESS\n         B     NEXTD12              MSG ALREADY ISSUED\n         B     DEF08               INVALID NAME GT 44\n         B     NEXTD12              MSG ALREADY ISSUED\n         B     DEF16               NOT IN CATALOG\n         B     DEF20               NOT IN CATALOG\n         B     DEF24               IMPOSSIBLE\n         B     DEF28               COMMAND SYSTEM ERROR\n         B     DEF32               IMPOSSIBLE\n         B     DEF36               ?\nDEF08    EQU   *\nDEF16    EQU   *\n         B     DEF24\nDEF20    EQU   *\nLOCERR   EQU   *\n         MVC   MSGWK(L'MSG02),MSG02\n         LA    R15,MSGWK+L'MSG02\n         LA    R14,DSNAME\n         LH    R1,0(,R14)\n         BCTR  R1,0\n         B     *+10\n         MVC   MSGWK+L'MSG02(0),2(R14)\n         EX    R1,*-6\n         LA    R15,1(R1,R15)\n         MVC   0(L'MSG02A,R15),MSG02A\n         LA    R0,L'MSG02+L'MSG02A+1(,R1)\n         LA    R1,MSGWK\n         BAL   R14,PUTMSG\n         B     NEXTD12\nDEF24    EQU   *\nDEF28    EQU   *\nDEF32    EQU   *\nDEF36    EQU   *\n         LA    R1,MSG03\n         LA    R0,L'MSG03\n         BAL   R14,PUTMSG\nNEXTD12  MVI   RETCODE+1,12\n         B     NEXTDSN\n         SPACE\nDEF00    MVC   DSNAME(46),DSNAME24\nDEFX     EQU   *\n         SPACE\n************************************************************\n*                                                          *\n*        ALLOCATE THE DATASET                              *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R1,MYDAPL\n         USING DAPL,R1\n         MVC   DAPLUPT(4),CPPLUPT\n         MVC   DAPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,DAPLECB\n         MVC   DAPLPSCB(4),CPPLPSCB\n         LA    R15,MYDAPB\n         ST    R15,DAPLDAPB\n         DROP  R1                  DAPL\n         USING DAPB08,R15\n         XC    0(84,R15),0(R15)\n         MVI   DA08CD+1,X'08'\n         LA    R0,DSNAME\n         ST    R0,DA08PDSN\n         MVC   DA08DDN(8),=CL8' '\n         MVC   DA08UNIT,=CL8' '\n         MVC   DA08SER,=CL8' '\n         MVC   DA08MNM,=CL8' '\n         MVC   DA08PSWD,=CL8' '\n         MVI   DA08DSP1,DA08SHR\n         MVI   DA08DPS2,DA08KEEP\n         MVI   DA08DPS3,DA08KEP\n         TM    14(R6),X'80'        MEMBER SPECIFIED?\n         BZ    MEMBX               NO - BRANCH\n         LH    R1,12(,R6)          GET LENGTH OF MEMBER\n         STH   R1,MEMLEN\n         BCTR  R1,0                MINUS 1 FOR EX\n         L     R14,8(,R6)          GET ADDRESS OF MEMBER NAME\n         B     *+10\n         MVC   DA08MNM(0),0(R14)   MOVE MEMBER NAME\n         EX    R1,*-6\n         MVC   MEMNAME,DA08MNM\nMEMBX    EQU   *\n         TM    22(R6),X'80'        PASSWORD SPECIFIED?\n         BZ    PASSX               NO - BRANCH\n         LH    R1,20(,R6)          GET LENGTH OF PSWD\n         BCTR  R1,0                MINUS 1 FOR EX\n         L     R14,16(,R6)         GET ADDRESS OF PSWD\n         B     *+10\n         MVC   DA08PSWD(0),0(R14)  MOVE PSWD\n         EX    R1,*-6\nPASSX    EQU   *\n         LA    R1,MYDAPL\n         SPACE\n         BAL   R14,CALLDAIR\n         LTR   R15,R15\n         BZ    OKDAIR\n         BAL   R14,DAIRFAIL\n         B     NEXTD12\nOKDAIR   EQU   *\n         OI    STATUS,X'40'        TELL CLEANUP TO FREE IT\n         LA    R15,MYDAPB\n         MVC   DDSAVE,DA08DDN\n         TM    DA08DSO,X'40'       IS DSORG SEQUENTIAL?\n         BO    OKDSORG             YES - BRANCH\n         TM    DA08DSO,X'02'       IS DSORG PARTITIONED?\n         BO    OKDSORGP            YES, BRANCH\n*\n*              DSORG IS NEITHER PS NOR PO\n*              ISAM=X'80' DA=X'20' VSAM=X'00' NONE=X'00'\n*\nERRDSORG LA    R1,MSG06\n         LA    R0,L'MSG06\n         BAL   R14,PUTMSG\n         B     QUITD12\nOKDSORGP EQU   *\n         CLC   DA08MNM,=CL8' '     WAS MEMBER SPECIFIED?\n         BNE   OKDSORG             YES - BRANCH\n         LA    R1,MSG07\n         LA    R0,L'MSG07\n         BAL   R14,PUTMSG\n         B     NEXTD12\nOKDSORG  EQU   *\n         DROP  R15                 DAPB08\n         SPACE\n************************************************************\n*                                                          *\n*        CHECK FORMAT-1 DSCB FOR EMPTY DATA SET            *\n*                                                          *\n************************************************************\n         SPACE\n         L     R1,16               CVTPTR\n         L     R1,0(,R1)           TCB WORDS\n         L     R1,4(,R1)           CURRENT TCB\n         L     R1,12(,R1)          TIOT\n         LA    R1,24(,R1)          TOIENTRY\nDDLOOP   CLI   0(R1),0             END OF TIOT\n         BE    QUITDSN             YES, BRANCH (NEVER HAPPENS)\n         CLC   4(8,R1),DDSAVE      DOES DDNAME MATCH\n         BE    DDFOUND\n         SLR   R15,R15\n         IC    R15,0(,R1)\n         LA    R1,0(R15,R1)\n         B     DDLOOP\nDDFOUND  L     R15,16(,R1)         TIOEFSRT-1\n         N     R15,=A(X'00FFFFFF') CLEAR HIGH 8 BITS\n         TM    18(R15),X'20'       DIRECT ACCESS DEVICE?\n         BZ    OBTX                NO, BYPASS OBTAIN\n         MVC   VOLSER,28(R15)      UCBVOLI\nOBTDSCB  LA    R1,OBTAINW\n         MVC   0(OBTAINL,R1),OBTAIN\n         LA    R0,DSNAME+2         DSN FOR OBTAIN\n         ST    R0,4(,R1)\n         LA    R0,VOLSER           VOLUME FOR OBTAIN\n         ST    R0,8(,R1)\n         LA    R0,MYDSCB           ANSWER AREA FOR OBTAIN\n         ST    R0,12(,R1)\n         OBTAIN (1),EADSCB=OK\n         LTR   R15,R15             WAS OBTAIN SUCCESSFUL\n         BZ    OKDSCB              YES, BRANCH\n         SPACE\n*               OBTAIN HAS FAILED. HOW CAN THAT HAPPEN WHEN\n*               DYNAMIC ALLOCATION WAS SUCCESSFUL? ONE WAY IT\n*               CAN HAPPEN IS IF THE DSNAME IS AN ALIAS ENTRY\n*               IN A VSAM CATALOG.  IF IT IS, A 'LOCATE' WILL\n*               PUT THE TRUE NAME IN THE DSNAME FIELD, SO NOW\n*               WE ISSUE A LOCATE, AND TRY THE OBTAIN AGAIN.\n         SPACE\n         TM    STATUS,X'08'        HAS LOCATE BEEN TRIED ALREADY?\n         BZ    ALIAS               NO, GO TRY IT\nERROBT   LA    R1,MSG09            UNABLE TO OBTAIN DSCB\n         LA    R0,L'MSG09\n         BAL   R14,PUTMSG\n         MVI   RETCODE+1,12\n         B     QUITDSN\nALIAS    OI    STATUS,X'08'        TRIP THE SWITCH\n         LA    R1,LOCATEW\n         MVC   0(LOCATEL,R1),LOCATE\n         LA    R0,DSNAME+2         DSNAME FOR LOCATE\n         ST    R0,4(,R1)\n         LA    R0,LOCBUF           ANSWER AREA FOR LOCATE\n         ST    R0,12(,R1)\n         LOCATE (1)\n         LTR   15,15               WAS LOCATE SUCCESSFUL?\n         BZ    OBTDSCB             YES, GO OBTAIN AGAIN\n         B     ERROBT              NO, ISSUE MESSAGE\n         SPACE\nOKDSCB   NI    STATUS,255-X'08'    TURN OFF LOCATE SWITCH\n         TM    MYDSCB-44+X'52',X'42' DSORG = PS OR PO\n         BZ    ERRDSORG\n*        TM    MYDSCB-44+X'54',X'C0' RECFM = U\n*        BO    ERRRECFM\n*        CLC   MYDSCB-44+X'62'(3),=X'000000' CHECK DS1LSTAR\n*        BE    EMPTYDS             BRANCH IF EMPTY DATA SET\nOBTX     EQU   *\nFILESPEC EQU   *\n         SPACE\n************************************************************\n*                                                          *\n*        SET UP THE DCB                                    *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R4,DYNDCBW\n         USING IHADCB,R4\n         MVC   0(DYNDCBL,R4),DYNDCB\n         MVC   DCBDDNAM(8),DDSAVE\n         SPACE\n         LA    R5,DYNDCBEW\n         USING DCBE,R5\n         MVC   0(DYNDCBEL,R5),DYNDCBE\n         ST    R5,DCBDCBE\n         SPACE\n         LA    R15,GET6E\n         ST    R15,DCBEEODA\n         SPACE\n         LA    R15,DYNSYNAD\n         ST    R15,DCBESYNA\n         SPACE\n         LA    R15,DYNEXLST\n         IC    R0,DCBEXLSA-1\n         ST    R15,DCBEXLSA-1      EXLST=DYNEXLST\n         STC   R0,DCBEXLSA-1\n         LA    R1,OPENEXIT         EXIT BELOW THE LINE\n         MVC   0(GLUELEN,R1),GLUE   WILL CONTAIN GLUE\n         ST    R1,0(,R15)          STORE IN 1ST EXLST WORD\n         MVI   0(R15),X'05'        MARK TYPE OF EXIT\n         LA    R0,DYNOPENX         EXIT ABOVE THE LINE\n         ST    R0,OPENEXAD         SAVE ITS ADDRESS\n         OI    OPENEXAD,X'80'      MAKE IT RUN IN31-BIT MODE\n         SPACE\n         LA    R1,ABENDXIT         EXIT BELOW THE LINE\n         MVC   0(GLUELEN,R1),GLUE   WILL CONTAIN GLUE\n         ST    R1,4(,R15)          STORE IN 2ND EXLST WORD\n         MVI   4(R15),128+X'11'    OPEN ABEND EXIT (MVS)\n         LA    R0,DYNABEND         EXIT ABOVE THE LINE\n         ST    R0,ABENDXAD         SAVE ITS ADDRESS\n         OI    ABENDXAD,X'80'      MAKE IT RUN IN31-BIT MODE\n         SPACE\n         OI    STATUS,X'80'        TELL CLEANUP TO CLOSE DCB\n         MVC   OPEND(OPEN31L),OPEN31\n         SPACE\n         OPEN  ((R4),INPUT),MODE=31,MF=(E,OPEND)\n         SPACE\n*        TM    DCBOFLGS,X'10'\n*        TM    DCBEFLG1,DCBEOPEN+DCBEMD31\n         TM    DCBEFLG1,DCBEOPEN\n         BO    OKOPEN\n         LA    R1,MSG08\n         LA    R0,L'MSG08\n         TM    STATUS,X'10'        MEMBER NOT FOUND?\n         BO    DYNOPENM            YES, BRANCH\n         LA    R1,MSG04\n         LA    R0,L'MSG04\nDYNOPENM BAL   R14,PUTMSG\n         B     QUITD12\n         SPACE\nDYNOPENX BSM   0,R14\n         SPACE\nDYNABEND L     R8,0(,R1)           GET COMPLETION CODE\n         N     R8,=A(X'FFF0FF00')\n         CL    R8,=A(X'01301800')  IS IT AN 013-18 ABEND\n         BE    DYNABENY            YES, BRANCH\n         MVI   4(R1),0             NO, ABNORMALLY TERMINATE\n         BSM   0,R14\nDYNABENY OI    STATUS,X'10'        INDICATE MEMBER NOT FOUND\n         MVI   3(R1),4             IGNORE THE ABEND\n         BSM   0,R14\n         SPACE\nOKOPEN   EQU   *\n         MVI   GOTEOD,0\n         MVC   SHA1PB(28),SHA1PI   SET UP PARAMETER BLOCK FOR SHA-1\n*        MVC   SHA2PB(40),SHA2PI   SET UP PARAMETER BLOCK FOR SHA-256\n         LA    R0,64\n         ST    R0,I64\n         XC    GETREGS(8),GETREGS\n         XC    PUTREGS(8),PUTREGS\n         XC    FILESIZE(8),FILESIZE\n         SR    R6,R6\n         SPACE\nREADLOOP EQU   *\n         BAL   R14,GET64\n         C     R0,=F'64'\n         BNE   READLAST\n         LM    R14,R15,FILESIZE\n         ALR   R15,R0\n         BC    12,NOCARRY\n         AL    R14,=F'1'\nNOCARRY  STM   R14,R15,FILESIZE\n         LA    R14,IBUF            DATA ADDRESS\n         LR    R15,R0              DATA LENGTH 64\n         LA    R0,1                FUNCTION CODE 1, SHA-1\n*        LA    R0,2                FUNCTION CODE 2, SHA-256\n         LA    R1,SHA1PB\nKLOOPI   EQU   *\n         KIMD  R2,R14              R2 NOT USED, R14 --> DATA, R15 = LEN\n         BNZ   KLOOPI              LOOP IF PARTIAL\n         B     READLOOP\n         SPACE\n*              R0 CONTAINS 0 TO 63 OR MOD(FILESIZE,64)\n*              THE LENGTH OF ANY REMAINING DATA IN IBUF AFTER\n*              HAVING PROCESSED THE FILE IN 64-BYTE CHUNKS.\nREADLAST EQU   *\n         LM    R14,R15,FILESIZE\n         ALR   R15,R0\n         BC    12,NOCARRYL\n         AL    R14,=F'1'\nNOCARRYL STM   R14,R15,FILESIZE\n         SLDL  R14,3               MULTIPLY BY 8, BYTES TO BITS\n*              A FILE OF 536,870,912 BYTES WILL HAVE HEX 100000000 BITS\n*              MAKING THE HIGH WORD OF THE MESSAGE BIT LENGTH NONZERO.\n*              THAT'S 5114 CYLINDERS ON A 3390, ABOUT HALF OF A 3390-9.\n         STM   R14,R15,SHA1PB+20   MESSAGE BIT LENGTH FOR SHA-1\n*        STM   R14,R15,SHA2PB+32   MESSAGE BIT LENGTH FIR SHA-256\n         LA    R14,IBUF            DATA ADDRESS\n         LR    R15,R0              DATA LENGTH < 64\n         LA    R0,1                FUNCTION CODE 1, SHA-1\n*        LA    R0,2                FUNCTION CODE 2, SHA-256\n         LA    R1,SHA1PB\nKLOOPL   EQU   *\n         KLMD  R2,R14              R2 NOT USED, R14 --> DATA, R15 = LEN\n         BNZ   KLOOPL              LOOP IF PARTIAL\n         B     DYNEOD\n         SPACE\n*         GET64 - READ UP TO 64 BYTES INTO IBUF, SET R0 TO COUNT\n         SPACE\nGET64    LM    R5,R6,GETREGS\n         LA    R15,IBUF\n         L     R0,I64\nGET6A    CR    R5,R6               IF END OF RECORD\n         BNL   GET6R                 THEN READ NEXT RECORD\n         MVC   0(1,R15),0(R5)      COPY ONE BYTE TO OBUF\n         LA    R15,1(,R15)         NEXT OBUF BYTE\n         LA    R5,1(,R5)           NEXT IBUF BYTE\n         BCT   R0,GET6A            DECREMENT R0 AND LOOP\n         L     R0,I64              SET RETURNED LENGTH\n         STM   R5,R6,GETREGS\n         BR    R14\nGET6R    STM   R14,R0,GETREGS+8\n         CLI   GOTEOD,0            IF WE ALREADY HIT EODAD\n         BNE   GET6E                 GO THERE AGAIN\n         GET   (R4)\n         LR    R5,R1\n         TM    DCBRECFM,X'C0'      RECFM U\n         BO    GET6U\n         TM    DCBRECFM,X'80'      RECFM F\n         BO    GET6F\nGET6V    LA    R0,4\n         LH    R6,0(,R5)           LENGTH+4 FROM RDW\n         CLI   OPTR,0              IF RDW KEYWORD\n         BNE   GET6W                  INCLUDE RDW\n         AR    R5,R0               POINT PAST RDW\n         SR    R6,R0               REDUCE LENGTH\nGET6W    AR    R6,R5               POINT TO END OF RECORD\n         B     GET6X\nGET6U    LH    R6,DCBLRECL\n         AR    R6,R5               POINT TO END OF RECORD\n         B     GET6X\nGET6F    LH    R6,DCBLRECL         GET LENGTH FROM LRECL\n         TM    DCBRECFM,X'10'      IF NOT BLOCKED\n         BO    *+8                   THEN\n         LH    R6,DCBBLKSI           USE BLKSIZE AS LENGTH\n         AR    R6,R5               POINT TO END OF RECORD\nGET6X    LM    R14,R0,GETREGS+8\n         B     GET6A\nGET6E    CLI   GOTEOD,0            WERE WE ALREADY HERE\n         BE    *+8                 NO\n         EX    R0,*                YES, SOC3 IF EOF TWICE\n         MVI   GOTEOD,1            THAT'S ONCE\n         L     R0,I64\n         S     R0,GETREGS+16       COMPUTE HOW MANY BYTES IN IBUF\n         XC    GETREGS(8),GETREGS\n         L     R14,GETREGS+8\n         BR    R14\n         SPACE\n*MPTYDS  MVC   MSGWK(21),=C'-- EMPTY DATA SET -- '\n*        LA    R15,MSGWK+21\n*        B     ADDDSN\nDYNEOD   EQU   *\n         LA    R1,SHA1PB\n         LA    R0,20 FOR SHA-1\n*        LA    R0,32 FOR SHA-256\n         LA    R15,MSGWK\n         BAL   R14,TOHEX\n         SPACE\n         LA    R15,MSGWK+40 FOR SHA-1\n*        LA    R15,MSGWK+64 FOR SHA-256\n         MVI   0(R15),C' '\n         MVI   1(R15),C'*'\n         LA    R15,2(,R15)\nADDDSN   LA    R14,DSNAME\n         LH    R1,0(,R14)\n         BCTR  R1,0\n         B     *+10\n         MVC   0(0,R15),2(R14)\n         EX    R1,*-6\n         LA    R15,1(R1,R15)       POINT PAST LAST BYTE\n*        TM    14(R6),X'80'        MEMBER SPECIFIED?\n         CLI   MEMLEN+1,0          MEMBER ALLOCATED?\n         BZ    MEMAX               NO - BRANCH\n         MVI   0(R15),C'('\n         LA    R15,1(,R15)\n*        LH    R1,12(,R6)          GET LENGTH OF MEMBER\n         LH    R1,MEMLEN           GET LENGTH OF MEMBER\n         BCTR  R1,0                MINUS 1 FOR EX\n*        L     R14,8(,R6)          GET ADDRESS OF MEMBER NAME\n         LA    R14,MEMNAME\n         B     *+10\n         MVC   0(0,R15),0(R14)     MOVE MEMBER NAME\n         EX    R1,*-6\n         LA    R15,1(R1,R15)       POINT PAST LAST BYTE\n         MVI   0(R15),C')'\n         LA    R15,1(,R15)\nMEMAX    EQU   *\n         LA    R1,MSGWK\n         LR    R0,R15              POINT PAST LAST BYTE\n         SR    R0,R1               COMPUTE MESSAGE LENGTH\n         CLI   LOWKW+1,1           IF 'LOWER' SPECIFIED\n         BNE   LOWX\n         LR    R14,R0\n         BCTR  R14,0                  GET LENGTH MINUS 1\n         B     *+10\n         TR    MSGWK(0),LOWTABLE      TRANSLATE TO LOWER CASE\n         EX    R14,*-6\nLOWX     EQU   *\n         ST    R0,MSGL\n         CLI   BRIEFKW+1,1         BRIEF, JUST THE HASH\n         BNE   *+8\n         LA    R0,40               FOR SHA-1\n*        LA    R0,64               FOR SHA-256\n         CLI   MULTIKW+1,1         MULTIPLE LINES, DSNAME SEPARATE\n         BNE   *+8\n         LA    R0,40               FOR SHA-1\n*        LA    R0,64               FOR SHA-256\n         LA    R1,MSGWK\n         BAL   R14,PUTLINE\n         CLI   MULTIKW+1,1         MULTIPLE LINES\n         BNE   MSGDONE\n         LA    R0,MSGWK\n         A     R0,MSGL\n         LA    R1,MSGWK+40         FOR SHA-1\n*        LA    R1,MSGWK+64         FOR SHA-256\n*        LA    R1,2(,R1)           POINT PAST SPACE AND '*'\n         SR    R0,R1               COMPUTE MESSAGE LENGTH\n         BAL   R14,PUTLINE         DISPLAY DSNAME ONLY\nMSGDONE  B     QUITDSN\n         SPACE\nQUITD12  MVI   RETCODE+1,12\n         SPACE\nQUITDSN  TM    STATUS,X'80'\n         BZ    NOCLOSE\n         LA    R5,DYNDCBEW\n*        TM    DCBOFLGS,X'10'      IS IT OPEN?\n         TM    DCBEFLG1,DCBEOPEN\n         BZ    NOCLOSE             NO, BRANCH\n         MVC   CLOSED(CLOSE31L),CLOSE31\n         CLOSE ((R4)),MODE=31,MF=(E,CLOSED)\n         NI    STATUS,255-X'80'    CLOSED\n         DROP  R4                  IHADCB\nNOCLOSE  EQU   *\n         TM    STATUS,X'40'        FREE REQUIRED?\n         BZ    NOFREE\n         LA    R1,MYDAPL\n         LA    R15,MYDAPB\n         USING DAPB18,R15\n         XC    0(40,R15),0(R15)\n         MVI   DA18CD+1,X'18'\n         MVC   DA18DDN,DDSAVE\n         MVC   DA18MNM(8),=CL8' '\n         MVC   DA18SCLS(2),=CL8' '\n         BAL   R14,CALLDAIR        UNALLOCATE\n         NI    STATUS,255-X'40'    UNALLOCATED\n         DROP  R15                 DAPB18\nNOFREE   EQU   *\n         B     NEXTDSN\n         SPACE\nDONE     TM    MYPUTLEP,X'80'     WAS PUTLINE LOADED?\n         BO    NODELETE           NO - USED CVTPUTL - BRANCH\n         LA    R0,=CL8'IKJPUTL '\n         DELETE EPLOC=(0)\nNODELETE EQU   *\n         SPACE\n         IKJRLSA MYANS\n         SPACE\n         CLI   RETCODE+1,0         IS RETCODE ZERO?\n         BZ    STACKDX             YES, BRANCH\n         MVC   MYSTPB(STACKDL),STACKD\n         SPACE\n         STACK DELETE=ALL,PARM=MYSTPB,MF=(E,MYIOPL)\n         SPACE\n         TCLEARQ\nSTACKDX  EQU   *\n         SPACE\n         LH    R15,RETCODE\n         B     EXIT\n         SPACE\n************************************************************\n*                                                          *\n*         CALL IKJDAIR SERVICE ROUTINE                     *\n*                                                          *\n************************************************************\n          SPACE\nCALLDAIR ST    R14,DAIRREGS\n         L     R15,16\n         TM    732(R15),X'80'     CVTDAIR\n         BNO   DAIRLINK\n         L     R15,732(,R15)\n         BALR  R14,R15\n         B     DAIRFINI\nDAIRLINK EQU   *\n         LINK  EP=IKJDAIR,SF=(E,LINKAREA)\nDAIRFINI L     R14,DAIRREGS\n         BR    R14\n         SPACE\n************************************************************\n*                                                          *\n*        DYNAMIC ALLOCATION FAILURE ROUTINE                *\n*                                                          *\n************************************************************\n         SPACE\nDAIRFAIL ST    R14,MYDFREGS\n         LA    R1,MYDFPARM\n         USING DFDSECTD,R1\n         ST    R15,MYDFRC\n         LA    R15,MYDFRC\n         ST    R15,DFRCP\n         LA    R15,MYDAPL\n         ST    R15,DFDAPLP\n         SLR   R15,R15\n         ST    R15,MYJEFF02\n         LA    R15,MYJEFF02\n         ST    R15,DFJEFF02\n         LA    R15,DFDAIR\n         STH   R15,MYDFID\n         LA    R15,MYDFID\n         ST    R15,DFIDP\n         SLR   R15,R15\n         ST    R15,DFCPPLP\n         LINK  EP=IKJEFF18,SF=(E,LINKAREA)\n         L     R15,MYDFRC\n         DROP  R1                  DFDSECTD\n         L     R14,MYDFREGS\n         BR    R14\n         SPACE\n************************************************************\n*                                                          *\n*        PUTMSG ROUTINE                                    *\n*                                                          *\n************************************************************\n         SPACE\nPUTMSG   STM   R14,R1,PUTLINS\n         XC    MYOLD(8),MYOLD\n         XC    MYSEG1(4),MYSEG1\n         MVC   MYPTPB(12),MODLPTPM\n         LA    R14,1               NO. OF MESSAGE SEGMENTS\n         ST    R14,MYOLD\n         LA    R14,MYSEG1          POINT TO 1ST SEGMENT\n         ST    R14,MYOLD+4\n         LR    R14,R0              LENGTH IN R0\n         LA    R14,4(,R14)         ADD 4\n         LA    R15,MYSEG1+4\n         CLC   0(3,R1),=C'IKJ'     IS DATA PRECEEDED BY MESSAGE ID?\n         BE    *+16                YES - BRANCH\n         LA    R14,1(,R14)         ADD 1 TO LENGTH\n         MVI   0(R15),C' '         INSERT LEADING BLANK\n         LA    R15,1(,R15)         BUMP POINTER\n         STH   R14,MYSEG1\n         LR    R14,R0\n         BCTR  R14,0\n         B     *+10\n         MVC   0(0,R15),0(R1)      MOVE MESSAGE IN\n         EX    R14,*-6\n         L     R15,MYPUTLEP\n         SPACE\n         PUTLINE PARM=MYPTPB,OUTPUT=(MYOLD),ENTRY=(15),MF=(E,MYIOPL)\n         SPACE\n         LM    R14,R1,PUTLINS\n         BR    R14\n         SPACE\n************************************************************\n*                                                          *\n*        PUTLINE ROUTINE                                   *\n*                                                          *\n************************************************************\n         SPACE\nPUTLINE  STM   R14,R1,PUTLINS\n         XC    MYSEG1(4),MYSEG1\n         MVC   MYPTPB(12),MODLPTPB\n         LR    R14,R0              LENGTH IN R0\n         LA    R14,4(,R14)         ADD 4\n         STH   R14,MYSEG1\n         LR    R14,R0\n         BCTR  R14,0\n         B     *+10\n         MVC   MYSEG1+4(0),0(R1)   MOVE TEXT IN\n         EX    R14,*-6\n         LA    R1,MYIOPL\n         L     R15,MYPUTLEP\n         SPACE\n         PUTLINE PARM=MYPTPB,OUTPUT=(MYSEG1,DATA),ENTRY=(15),MF=(E,(1))\n         SPACE\n         LM    R14,R1,PUTLINS\n         BR    R14\n         SPACE 1\n*RRRECFM LA    R1,MSGRECFM\n*        LA    R0,L'MSGRECFM\n*        BAL   R14,PUTMSG\n*        B     QUITD12\n         SPACE\nTOHEX    MVC   1(1,R15),0(R1)\n         UNPK  0(3,R15),1(2,R15)\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)\n         LA    R1,1(,R1)\n         BCT   R0,TOHEX\n         MVI   0(R15),C' '\n         BR    R14\n         SPACE\nEXIT     LR    R2,R15              SAVE R15\n         LR    R1,R10\n         L     R0,@SIZE24\n         FREEMAIN R,A=(1),LV=(0)\n         SPACE\n         LR    R1,R13\n         L     R0,@SIZE31\n         L     13,4(,13)\n         FREEMAIN RU,A=(1),LV=(0),SP=1\n         LR    R15,R2              RESTORE R15\n         LM    0,12,20(13)\n         L     14,12(,13)\n         BR    14\n         SPACE\n************************************************************\n*                                                          *\n*        SYNAD EXIT                                        *\n*                                                          *\n************************************************************\n         SPACE\n*        THIS ROUTINE IS ENTERED DURING THE 'GET' MACRO\n*        IF AN I/O ERROR OCCURS.\n         SPACE\nDYNSYNAD EQU   *\n         SYNADAF ACSMETH=QSAM\n         MVC   SYNADMSG(78),50(R1)\n         MVI   SYNADSW,X'FF'\n         SYNADRLS\n         BR    R14\n         SPACE\n************************************************************\n*                                                          *\n*        GLUE FOR DCB EXITS                                *\n*                                                          *\n************************************************************\n         SPACE\n*        THESE 2 INSTRUCTIONS ARE COPIED TO ABENDXIT, BELOW THE LINE,\n*        AND RUN THERE, NOT HERE. WHEN ABENDXIT IS ENTERED,\n*        R15 CONTAINS THE ENTRY ADDRESS, THE ADDRESS OF ABENDXIT.\n*        THEN USING R15 AS A BASE REGISTER, IT LOADS R15 FROM ABENDXAD,\n*        WHICH CONTAINS THE ADDRESS OF DYNABEND ABOVE THE LINE,\n*        WITH THE HIGH-ORDER BIT SET TO 1. THEN IT USES BSM TO\n*        BRANCH TO DYNABEND IN 31-BIT MODE. THE ROUTINE AT\n*        DYNABEND SHOULD RETURN USING 'BSM 0,R14'.\n*\nGLUE     L     R15,ABENDXAD-ABENDXIT(,R15)\n         BSM   R14,R15  OLD MODE INTO R14 HI BIT, BRANCH TO R15 IN 31\nGLUELEN  EQU   *-GLUE\n         SPACE\n*        SINCE ABENDXAD-ABENDEXIT IS IDENTICAL TO OPENEXAD-OPENEXIT\n*        THE FOLLOWING IS NOT REALLY NEEDED.\n         SPACE\nGLUE2    L     R15,OPENEXAD-OPENEXIT(,R15)\n         BSM   R14,R15  OLD MODE INTO R14 HI BIT, BRANCH TO R15 IN 31\nGLUELEN2 EQU   *-GLUE2\n         SPACE\n************************************************************\n*                                                          *\n*        CONSTANTS                                         *\n*                                                          *\n************************************************************\n         SPACE\nMODLPTPM PUTLINE OUTPUT=(1,TERM,SINGLE,INFOR),                         X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=L\n         SPACE\nMODLPTPB PUTLINE OUTPUT=(1,TERM,SINGLE,DATA),                          X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=L\n         SPACE\n*        PRINT NOGEN\n         SPACE\nOPEN31   OPEN  (0,),MODE=31,MF=L\nOPEN31L  EQU   *-OPEN31\nCLOSE31  CLOSE (0,),MODE=31,MF=L\nCLOSE31L EQU   *-CLOSE31\n         SPACE\nDYNDCB   DCB   DDNAME=DYNAM,DSORG=PS,MACRF=(GL),                       +\n               EODAD=0,SYNAD=0,EROPT=ACC,DCBE=0\nDYNDCBL  EQU   *-DYNDCB\n         SPACE\nDYNDCBE  DCBE  RMODE31=BUFF,EODAD=1\nDYNDCBEL EQU   *-DYNDCBE\n         SPACE\n         PRINT GEN\n         SPACE\nOBTAIN   CAMLST SEARCH,2,3,4\nOBTAINL  EQU   *-OBTAIN\n         SPACE\nLOCATE   CAMLST NAME,2,,4\nLOCATEL  EQU   *-LOCATE\n         SPACE\nSTACKD   STACK DELETE=ALL,MF=L\nSTACKDL  EQU   *-STACKD\n         SPACE\nSHA1PI   DC    X'67452301' H0\n         DC    X'EFCDAB89' H1\n         DC    X'98BADCFE' H2\n         DC    X'10325476' H3\n         DC    X'C3D2E1F0' H4\n         DC    X'00000000' MESSAGE BIT LENGTH HIGH\n         DC    X'00000000' MESSAGE BIT LENGTH LOW\n         SPACE\n         AGO   .SKIP2\nSHA2PI   DC    X'6A09E667' H0\n         DC    X'BB67AE85' H1\n         DC    X'3C6EF372' H2\n         DC    X'A54FF53A' H3\n         DC    X'510E527F' H4\n         DC    X'9B05688C' H5\n         DC    X'1F83D9AB' H6\n         DC    X'5BE0CD19' H7\n         DC    X'00000000' MESSAGE BIT LENGTH HIGH\n         DC    X'00000000' MESSAGE BIT LENGTH LOW\n.SKIP2   ANOP\nHEXTAB   DC    C'0123456789ABCDEF'\nMSG01    DC    C'ERROR IN PARSE SERVICE ROUTINE'\nMSG02    DC    C'IKJ58503I DATA SET '\nMSG02A   DC    C' NOT IN CATALOG'\nMSG03    DC    C'ERROR IN DEFAULT SERVICE ROUTINE'\nMSG04    DC    C'UNABLE TO OPEN DATASET'\nMSG05    DC    C'IKJ58509I DATA SET NAME REQUIRED WHEN MEMBER IS SPECIF+\n               IED'\nMSG06    DC    C'ORGANIZATION OF DATA SET MUST BE PARTITIONED OR SEQUEN+\n               TIAL'\nMSG07    DC    C'DATA SET IS PARTITIONED, MEMBER NOT SPECIFIED'\nMSG08    DC    C'SPECIFIED MEMBER NOT FOUND IN DATASET'\nMSG09    DC    C'UNABLE TO OBTAIN DSCB FOR DATA SET'\nMSG14    DC    C'FILENAME '\nMSG14A   DC    C' INVALID, MORE THAN 8 CHARACTERS  '\nMSG14B   DC    C' IS NOT CURRENTLY ALLOCATED       '\nMSG14C   DC    C' NOT ALLOCATED TO A DASD DATA SET '\n*SGRECFM DC    C'RECORD FORMAT U NOT SUPPORTED'\n*MSGDAIR DC    C'UNABLE TO ALLOCATE'\nLOWTABLE DC    0D'0',256AL1(*-LOWTABLE)\n         ORG   LOWTABLE+C'A'\n         DC    X'818283848586878889'\n         ORG   LOWTABLE+C'J'\n         DC    X'919293949596979899'\n         ORG   LOWTABLE+C'S'\n         DC    X'A2A3A4A5A6A7A8A9'\n         ORG\n         LTORG\nPCLADDR  DC    0D'0'               END OF CSECT\n         SPACE\n************************************************************\n*                                                          *\n*        PARSE PARAMETERS                                  *\n*                                                          *\n************************************************************\n         SPACE\n         PRINT NOGEN\nSHASMPCL RMODE 31\nSHASMPCL IKJPARM\nDSN      IKJPOSIT DSNAME,LIST,PROMPT='DATA SET NAME'\nFILEKW   IKJKEYWD\n         IKJNAME 'FILE'\nQUICKW   IKJKEYWD\n         IKJNAME 'QUICK'\nRDWKW    IKJKEYWD\n         IKJNAME 'RDW'\nLOWKW    IKJKEYWD\n         IKJNAME 'LOWER'\nBRIEFKW  IKJKEYWD\n         IKJNAME 'BRIEF'\nMULTIKW  IKJKEYWD\n         IKJNAME 'MULTI'\n         IKJENDP\n         PRINT GEN\n         SPACE\n************************************************************\n*                                                          *\n*        DSECTS                                            *\n*                                                          *\n************************************************************\n         SPACE\n@DATA31  DSECT\n         DS    18F                 REGISTER SAVEAREA\nLINKAREA DS    2F\nMYPPL    DS    7F\nMYANS    DS    F\nMYECB    DS    F                  USED BY PUTLINE ROUTINE\nMYIOPL   DS    4F                 USED BY PUTLINE ROUTINE\nMYPTPB   DS    3F                 USED BY PUTLINE ROUTINE\nMYOLD    DS    2F                 USED BY PUTLINE ROUTINE\nMYSEG1   DS    2H,CL256           USED BY PUTLINE ROUTINE\nPUTLINS  DS    4F                 USED BY PUTLINE ROUTINE\nMYPUTLEP DS    F                  ADDRESS OF IKJPUTL\nMYSTPB   DS    0F                 5 WORDS USED BY STACK DELETE\nMYDAPL   DS    5F\nMYDAPB   DS    21F\nDSNAME   DS    H,CL44\nMEMLEN   DS    H\nMEMNAME  DS    CL8\nVOLSER   DS    CL6\nLOCATEW  DS    0F\nOBTAINW  DS    4F\nLOCBUF   DS    0D                  USES NEXT 265 BYTES\nMYDSCB   DS    CL140               96 BYTES OF DSCB, 5 BYTES CCHHR\nMSGWK    DS    CL128\nSTATUS   DS    X\nRETCODE  DS    H\nMYDFPARM DS    5F  USED BY DAIRFAIL\nMYDFREGS DS    F   USED BY DAIRFAIL\nMYDFRC   DS    F   USED BY DAIRFAIL\nMYJEFF02 DS    F   USED BY DAIRFAIL\nMYDFID   DS    H   USED BY DAIRFAIL\nDOUBLE   DS    D\nEIGHT    DS    CL8\nDDSAVE   DS    CL8\nDAIRREGS DS    F\nOPEND    DS    0F,(OPEN31L)X\nCLOSED   DS    0F,(CLOSE31L)X\nDYNDCBEW DS    0F,(DYNDCBEL)X\nKOUNT    DS    F\nKOUNTSP  DS    F\nSYNADSW  DS    F\nSYNADMSG DS    CL78\nDEVDATA  DS    2F\nGETREGS  DS    5F\nPUTREGS  DS    8F\nI64      DS    F\nDSL      DS    F\nMSGL     DS    F\nGOTEOD   DS    C\nOPTR     DS    C\nSHA1PB   DS    0D,7F\n*SHA2PB  DS    0D,10F\nFILESIZE DS    D\nIBUF     DS    CL80\n         DS    0D\n@DATA31L EQU   *-@DATA31\n         SPACE\n@DATA24  DSECT\nSAVE24   DS    18F                USED BY IKJEHDEF\nRDJFW    DS    F\nMYIOPL24 DS    4F                 USED BY IKJEHDEF\nMYECB24  DS    F\nMYDFPB   DS    5F\nDSNAME24 DS    H,CL44\nDYNDCBW  DS    0D,XL(DYNDCBL)\nDYNEXLST DS    2F\nOPENEXIT DS    0H,(GLUELEN)X\nOPENEXAD DS    F  X'80' + ADDRESS OF DYNOPENX\nABENDXIT DS    0H,(GLUELEN)X\nABENDXAD DS    F  X'80' + ADDRESS OF DYNABEND\nJFCB     DS    0F,CL176\nMYARL    DS    9F\nTBUF     DS    CL8\n         DS    0D\n@DATA24L EQU   *-@DATA24\n         SPACE\nIHADCB   DSECT\nDCBDCBE  DS    A\n         DS    28XL1\nDCBBFTEK DS    XL1\nDCBEODAD DS    AL3\nDCBEXLST DS    0A\nDCBRECFM DS    X\nDCBEXLSA DS    AL3\nDCBDDNAM DS    CL8\nDCBOFLGS DS    X\n         DS    7XL1\n         DS    X\nDCBSYNAD DS    AL3\nDCBBLKSI EQU   IHADCB+62,2\nDCBLRECL EQU   IHADCB+82,2\n         SPACE\n         IHADCBE\n         SPACE\nEFLG1    EQU   16\nEOPEN    EQU   X'80'\nEMD31    EQU   X'40'\nEEODA    EQU   40\nESYNA    EQU   44\n         SPACE\nXFLG1    EQU   DCBEFLG1-DCBE\nXOPEN    EQU   DCBEOPEN\nXMD31    EQU   DCBEMD31\nXEODA    EQU   DCBEEODA-DCBE\nXSYNA    EQU   DCBESYNA-DCBE\n         PRINT NOGEN\n         SPACE\n         IKJCPPL\n         SPACE 3\n         IKJPPL\n         SPACE\n         IKJDFPB\n         SPACE 2\n         IKJUPT\n         SPACE 2\n         IKJIOPL\n         SPACE 2\n         IKJDAPL\n         SPACE 2\n         IKJDAP08\n         SPACE 2\n         IKJDAP18\n         SPACE 2\n         IKJPSCB\n         SPACE 2\n         IKJEFFDF DFDSECT=YES\n         SPACE\n         IHAARL\n         SPACE\n         IHAARA\n         SPACE\n*        CVT   DSECT=YES\n         SPACE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SHA1SUM$": {"ttr": 5386, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x16\\x14?\\x01\\x16\\x14?#S\\x00\\x12\\x00\\x12\\x00\\x00\\xc3\\xc2\\xe3\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-05-22T00:00:00", "modifydate": "2016-05-22T23:53:20", "lines": 18, "newlines": 18, "modlines": 0, "user": "CBTUSER"}, "text": "//CBTUSER1 JOB (ACCT),'PGMR',NOTIFY=CBTUSER,\n//         MSGLEVEL=(1,1),MSGCLASS=H\n//* ASSEMBLE THE 31-BIT SHA1SUM TSO COMMAND\n//ASM    EXEC PGM=ASMA90,PARM=(OBJ,NODECK,TERM,NOXREF,BATCH,\n//             ASA,NODX,NOMX,NORX,RLD,NOUS,'PC(NOUHD)')\n//SYSPRINT DD  SYSOUT=*\n//SYSTERM  DD  SYSOUT=*\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//SYSLIN   DD  DSNAME=&&OBJ,DISP=(NEW,PASS),\n//             UNIT=SYSDA,SPACE=(TRK,(3,0)),\n//             DCB=(BLKSIZE=3200)\n//SYSIN    DD  DSN=CBTUSER.LIB.ASM(SHA1SUM),DISP=SHR\n//LKED   EXEC PGM=HEWLKED,PARM='LIST,MAP,RENT,REFR',\n//             COND=(0,NE)\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSNAME=&&OBJ,DISP=(OLD,DELETE)\n//SYSLMOD  DD  DSNAME=CBTUSER.LIB.LOAD(SHA1SUM),DISP=SHR\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(TRK,(10,0))\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SHA1SUM#": {"ttr": 5388, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00P\\x01\\x16\\x14?\\x01\\x16\\x14\\x8f\\x01)\\x00\\x19\\x00\\x17\\x00\\x00\\xc3\\xc2\\xe3\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2016-05-22T00:00:00", "modifydate": "2016-05-27T01:29:50", "lines": 25, "newlines": 23, "modlines": 0, "user": "CBTUSER"}, "text": ")F FUNCTION -\n  THE SHA1SUM COMMAND DISPLAYS THE SHA-1 HASH OF DATA SETS.\n  IN DATA SETS WITH VARIABLE-LENGTH RECORDS THE RDW'S AND SDW'S ARE\n  NOT INCLUDED WHEN THE CHECKSUM IS COMPUTED UNLESS THE RDW KEYWORD\n  IS SPECIFIED.\n)X SYNTAX -\n         SHA1SUM  'DSLIST'  FILE  LOWER  RDW  BRIEF  MULTI  QUICK\n\n  REQUIRED - 'DSLIST'\n  DEFAULTS - NONE\n\n)O OPERANDS -\n  'DSLIST' - NAMES OF SEQUENTIAL DATA SETS OR MEMBERS OF PARTITIONED\n             DATA SETS. IF MORE THAN ONE, ENCLOSE LIST IN PARENTHESES.\n))FILE     - THE NAMES IN DSLIST ARE DDNAMES, NOT DSNAMES.\n))LOWER    - DISPLAY THE RESULTS IN LOWER CASE.\n))RDW      - INCLUDE RDW OR SDW IN VARIABLE LENGTH RECORDS.\n))BRIEF    - DISPLAY ONLY THE HASH, WITHOUT THE DATA SET NAME.\n))MULTI    - DISPLAY THE HASH AND DATA SET NAME ON SEPARATE LINES.\n))QUICK    - FOR UNQUOTED DSNAMES, BYPASS THE DEFAULT SERVICE ROUTINE.\n             SO FOR EXAMPLE, IF YOU SPECIFY THE NAME TEMP AND YOU\n             ONLY HAVE A DATA SET NAMED TEMP.DATA, IT WON'T BE FOUND\n             IF QUICK IS ALSO SPECIFIED. THE QUICK KEYWORD IS JUST\n             TO CUT OUT THE OVERHEAD OF LOOKING FOR EXTENSIONS AT\n             THE END OF THE SPECIFIED DATA SET NAME.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SHA2PGM": {"ttr": 5633, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00$\\x01 \\x14\\x1f\\x01 \\x16\\x7f\\x07!\\x02F\\x02D\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2020-05-20T00:00:00", "modifydate": "2020-06-15T07:21:24", "lines": 582, "newlines": 580, "modlines": 0, "user": "UPDATED"}, "text": "         TITLE '   S H A 2 P G M '\n* WRITTEN MAY 19 2020\n* UPDATED MAY 20 2020\n* WRITE THE SHA-256 HASH OF THE INPUT FILE (SYSUT1) TO SYSUT2\n*\n* DDNAMES: SYSUT1 (INPUT) AND SYSUT2 (OUTPUT)\n*\n* IF PARM CONTAINS 'R' THEN RDW'S WILL BE INCLUDED IF INPUT IS V.\n* IF PARM CONTAINS 'L' THEN RESULT WILL BE SHOWN IN LOWERCASE.\n* IF PARM CONTAINS 'E' THEN RESULT WILL INCLUDE THE DATA SET NAME,\n* BUT ONLY THE FIRST DATA SET NAME IF CONCATENATED DATA SETS.\n*\n* OUTPUT WILL BE A FIXED-LENGTH 80-BYTE RECORD FILE,\n* UNLESS THE OUTPUT FILE ALREADY HAS OTHER ATTRIBUTES.\n*\n* MUCH OF THE SOURCE CODE IS FROM MD5PGM AND SHA2SUM IN CBT FILE 900,\n*\n* DISCLAIMER: NO GUARANTEE; NO WARRANTY; INSTALL/USE AT YOUR OWN RISK.\n*\n* SAMPLE JCL:\n*  //STEPNAME EXEC PGM=SHA2PGM\n*  //SYSUT1 DD DSN=HLQ.INPUT.DATA,DISP=SHR\n*  //SYSUT2 DD SYSOUT=*\n*\n* LOG OF CHANGES:\n*  JUNE 15 2020 - FIX RDW\n         SPACE\nSHA2PGM  RMODE ANY\nSHA2PGM  AMODE 31\nSHA2PGM  CSECT\n         USING *,R10\n         B     @PROLOG-*(,R15)\n         DC    AL1(7),CL7'SHA2PGM'\n         DC    CL16' &SYSDATE &SYSTIME '\n@SIZE    DC    0F'0',AL1(0),AL3(@DATAL)\n@PROLOG  STM   14,12,12(13)\n         LR    R10,R15\n         LR    R2,R1               POINT R2 TO PARM ADDRESS\n         L     R0,@SIZE\n         STORAGE OBTAIN,LENGTH=(0)\n         LR    R9,R1               POINT R9 TO OBTAINED AREA\n         XC    0(@CLEARL,R9),0(R9)\n         USING @DATA,R9\n         ST    R13,4(,R9)          OLD ADDRESS IN NEW SAVE AREA\n         ST    R9,8(,R13)          NEW ADDRESS IN OLD SAVE AREA\n         LR    R13,R9              POINT R13 TOP NEW SAVE AREA\n         SPACE\n*\n*         GET STORAGE BELOW THE LINE FOR DCB'S ETC.\n*\n         LA    R0,@DATA24L\n         STORAGE OBTAIN,LENGTH=(0),LOC=24\n         LR    R8,R1               POINT R8 TO OBTAINED AREA\n         USING @DATA24,R8\n         SPACE\n         L     R1,0(,R2)           POINT TO PARM\n         LH    R14,0(,R1)          LENGTH OF PARM\n         LTR   R14,R14\n         BZ    PARMX\n         LA    R15,2(,R1)\nPARMLOOP CLI   0(R15),C'R'         IF PARM CONTAINS R (FOR RDW)\n         BNE   *+8                   THEN\n         MVI   OPTR,1                TURN ON RDW OPTION\n         CLI   0(R15),C'L'         IF PARM CONTAINS L (FOR LOWERCASE)\n         BNE   *+8                   THEN\n         MVI   OPTL,1                TURN ON LOWERCASE OPTION\n         CLI   0(R15),C'E'         IF PARM CONTAINS E (FOR EXTRA INFO)\n         BNE   *+8                   THEN\n         MVI   OPTE,1                TURN ON EXTRA OPTION\n         LA    R15,1(,R15)\n         BCT   R14,PARMLOOP\nPARMX    EQU   *\n         SPACE\n         LA    R15,64\n         ST    R15,I64\n         LA    R15,12\n         ST    R15,RETCODE\n         SPACE\n         LA    R3,UT1DCBW\n         LA    R4,UT2DCBW\n         MVC   0(UT1DCBL,R3),UT1DCB\n         MVC   0(UT2DCBL,R4),UT2DCB\n         TM    0(R2),X'80'         ONLY 1 PARAMETER\n         BO    NODD                YES, BYPASS DD ROUTINE\n         L     R14,4(,R2)          POINT TO DDNAME LIST\n         LH    R1,0(,R14)          GET LENGTH OF DDNAME LIST\n         LA    R14,2(,R14)         POINT PAST LENGTH\n         SPACE\n*        CH    R1,=H'48'           LONG ENOUGH FOR SYSPRINT\n*        BL    NODD                NO, BRANCH\n*        CLI   40(R14),0           SYSPRINT OVERRIDE\n*        BE    *+10                NO, SKIP MVC\n*        MVC   DDNAM(8,R3),40(R14)\n         SPACE\n         CH    R1,=H'64'           LONG ENOUGH FOR SYSUT1\n         BL    NODD                NO, BRANCH\n         CLI   56(R14),0           SYSUT1 OVERRIDE\n         BE    *+10                NO, SKIP MVC\n         MVC   DDNAM(8,R3),56(R14)                                .FIX.\n         SPACE\n         CH    R1,=H'72'           LONG ENOUGH FOR SYSUT2\n         BL    NODD                NO, BRANCH\n         CLI   64(R14),0           SYSUT2 OVERRIDE\n         BE    *+10                NO, SKIP MVC\n         MVC   DDNAM(8,R4),64(R14)                                .FIX.\nNODD     EQU   *\n         SPACE\n         LA    R5,UT1DCBEW\n         LA    R6,UT2DCBEW\n         MVC   0(UT1DCBEL,R5),UT1DCBE\n         MVC   0(UT2DCBEL,R6),UT2DCBE\n         ST    R5,0(,R3)           ST    R5,DCBDCBE-IHADCB(,R3)\n         ST    R6,0(,R4)           ST    R5,DCBDCBE-IHADCB(,R3)\n         SPACE\n**********************************************************************\n*              OPEN INPUT DCB\n**********************************************************************\n         LA    R1,UT1EXLST         POINT TO INPUT DCB EXIT LIST\n         STCM  R1,7,EXLST+1(R3)    STORE ADDRESS OF EXIT LIST IN DCB\n         LA    R15,JFCB\n         ST    R15,0(,R1)          1ST EXLST WORD\n         MVI   0(R1),X'87'         JFCB ADDRESS FOR RDJFCB\n         SPACE\n         MVI   UT1RDJF,X'80'\n         RDJFCB ((R3)),MF=(E,UT1RDJF)\n         SPACE\n         MVC   OPEN31W(OPEN31L),OPEN31\n         OPEN  ((R3),INPUT),MODE=31,MF=(E,OPEN31W)\n*        TM    OFLGS(R3),X'10'     TEST FOR SUCCESSFUL OPEN\n*        TM    16(R5),X'C0'        TM    DCBEFLG1,DCBEOPEN+DCBEMD31\n*        TM    DCBEFLG1-DCBE(R5),DCBEOPEN+DCBEMD31 OPEN AND 31-BIT SAM\n         TM    DCBEFLG1-DCBE(R5),DCBEOPEN OPEN SUCCESSFUL\n         BNO   EXIT\n         TM    DCBEFLG1-DCBE(R5),DCBEMD31 31-BIT SAM SUPPORTED?\n         BO    NOT24I              YES, NOTHING TO CHANGE\n**********************************************************************\n*              MAKE CHANGES FOR 24-BIT GET\n**********************************************************************\n         LA    R15,EOD24S          POINT TO 24-BIT EODAD LOCATION\n         MVC   0(EOD24L,R15),EOD24I  COPY EOD24I CODE TO 24-BIT EODAD\n         LA    R0,UT1EOD           POINT TO 31-BIT EODAD\n*        O     R0,=A(X'80000000')  SET 31-BIT MODE IN UT1EOD ADDRESS\n         OILH  R0,X'8000'          SET 31-BIT MODE IN UT1EOD ADDRESS\n         ST    R0,EOD24P-EOD24I(,R15) STORE UT1EOD ADDRESS AND MODE\n         ST    R15,DCBEEODA-DCBE(R5) CHANGE DCBE EODAD TO EOD24S\n         MVC   GET24S(GET24L),GET24I COPY 24-BIT GET\nNOT24I   EQU   *\n**********************************************************************\n*              OPEN OUTPUT DCB\n**********************************************************************\n         LA    R1,UT2EXLST         POINT TO OPEN EXIT LIST\n         STCM  R1,7,EXLST+1(R4)    STORE ADDRESS OF EXIT LIST IN DCB\n         LA    R15,UT2OPENX        POINT TO OPEN EXIT ENTRY POINT\n         ST    R15,0(,R1)          STORE ADDRESS OF EXIT IN EXIT LIST\n         MVI   0(R1),X'85'         SET HIGH BYTE OF EXIT LIST\n         MVC   0(UT2OPENL,R15),UT2GLUE  COPY EXIT TO 24-BIT STORAGE\n         LA    R0,UT2EXIT          POINT TO 31-BIT EXIT\n*        O     R0,=A(X'80000000')  SET 31-BIT MODE IN ADDRESS\n         OILH  R0,X'8000'          SET 31-BIT MODE IN ADDRESS\n         ST    R0,UT2GLUEP-UT2GLUE(,R15) STORE EXIT ADDRESS FOR GLUE\n         SPACE\n         OPEN  ((R4),OUTPUT),MODE=31,MF=(E,OPEN31W)\n         TM    DCBEFLG1-DCBE(R6),DCBEOPEN OPEN SUCCESSFUL\n         BNO   EXITC1\n*        TM    DCBEFLG1-DCBE(R6),DCBEMD31 31-BIT SAM SUPPORTED?\n*        BNO   EXITC2              NO, CLOSE OUTPUT AND QUIT\n         SPACE\n**********************************************************************\n*              SET UP SHA PARAMETER BLOCK\n**********************************************************************\n*-       MVC   SHA1PB(28),SHA1PI   SET UP PARAMETER BLOCK FOR SHA-1\n         MVC   SHA2PB(40),SHA2PI   SET UP PARAMETER BLOCK FOR SHA-256\n         SPACE\n**********************************************************************\n*              READ 64 BYTES AT A TIME\n**********************************************************************\nREADLOOP EQU   *\n         BAL   R14,GET64           READ UP TO 64 BYTES\n         LA    R5,IBUF             POINT TO 64-BYTE SEGMENT\n         LR    R7,R0               GET LENGTH\n         C     R0,=F'64'           DID GET64 GET 64 BYTES?\n         BNE   GOTLAST             NO, BRANCH\n         LM    R14,R15,FILESIZE\n         ALR   R15,R0\n         BC    12,NOCARRY\n         AL    R14,=F'1'\nNOCARRY  STM   R14,R15,FILESIZE\n         B     GOT\n         SPACE\n**********************************************************************\n*         GET64 - READ UP TO 64 BYTES INTO IBUF, SET R0 TO COUNT\n**********************************************************************\n         SPACE\nGET64    LM    R5,R6,GETREGS\n         LA    R15,IBUF\n         L     R0,I64\nGET6A    CR    R5,R6               IF END OF RECORD\n         BNL   GET6R                 THEN READ NEXT RECORD\n         MVC   0(1,R15),0(R5)      COPY ONE BYTE TO OBUF\n         LA    R15,1(,R15)         NEXT OBUF BYTE\n         LA    R5,1(,R5)           NEXT IBUF BYTE\n         BCT   R0,GET6A            DECREMENT R0 AND LOOP\n         L     R0,I64              SET RETURNED LENGTH\n         STM   R5,R6,GETREGS\n         BR    R14\nGET6R    STM   R14,R0,GETREGS+8\n         CLI   GOTEOD,0            IF WE ALREADY HIT EODAD\n         BNE   GET6E                 GO THERE AGAIN\n         LA    R5,UT1DCBEW\n         TM    DCBEFLG1-DCBE(R5),DCBEMD31 31-BIT SAM SUPPORTED?\n         BNO   GET24               NO, USE 24-BIT MOOE FOR GET\n         GET   (R3)\n         B     GETRET\nGET24    LA    R15,GET24S\n*        MVC   0(GET24L,R15),GET24I (ALREADY MOVED, ONCE IS ENOUGH)\n         ST    R13,SAVE24+4        SAVE R13\n         LA    R13,SAVE24          GET NEEDS R13 TO POINT BELOW LINE\n         BASSM R11,R15             RUN GET IN 24-BIT MODE\n         L     R13,SAVE24+4        RESTORE R13\nGETRET   EQU   *\n         LR    R5,R1               POINT R5 TO RECORD\n         TM    RECFM(R3),X'C0'     RECFM U\n         BO    GET6U\n         TM    RECFM(R3),X'80'     RECFM F\n         BO    GET6F\nGET6V    LA    R0,4\n         LH    R6,0(,R5)           LENGTH+4 FROM RDW\n         CLI   OPTR,0              IF R IN PARM\n         BNE   GET6W                  INCLUDE RDW\n         AR    R5,R0               POINT PAST RDW TO EXCLUDE IT\n         SR    R6,R0               REDUCE LENGTH TO EXCLUDE RDW\nGET6W    AR    R6,R5               POINT TO END OF RECORD\n         B     GET6X\nGET6U    LH    R6,LRECL(,R3)       GET LENGTH FROM DCBLRECL\n         AR    R6,R5               POINT TO END OF RECORD\n         B     GET6X\nGET6F    LH    R6,LRECL(,R3)       GET LENGTH FROM DCBLRECL\n         TM    RECFM(R3),X'10'     IF NOT BLOCKED\n         BO    *+8                   THEN\n         LH    R6,BLKSI(,R3)         USE DCBBLKSI AS LENGTH\n         AR    R6,R5               POINT TO END OF RECORD\nGET6X    LM    R14,R0,GETREGS+8\n         B     GET6A\n*              THIS IS INPUT DCB EODAD, IN SOME CASES VIA GLUE\nUT1EOD   DC    0H'0'\nGET6E    CLI   GOTEOD,0            WERE WE ALREADY HERE\n         BE    *+8                 NO\n         EX    R0,*                YES, SOC3 IF EOF TWICE\n         MVI   GOTEOD,1            THAT'S ONCE\n         L     R0,I64\n         S     R0,GETREGS+16       COMPUTE HOW MANY BYTES IN IBUF\n         XC    GETREGS(8),GETREGS\n         L     R14,GETREGS+8\n         BR    R14\n*        THE FOLLOWING INSTRUCTIONS FROM GET24I TO GET24L ARE COPIED\n*        TO STORAGE BELOW THE LINE AND ARE CALLED BY A BASSM.\nGET24I   GET   (R3)\n         BSM   0,R11\nGET24L   EQU   *-GET24I\n         SPACE\n**********************************************************************\n*              USE KIMD FOR EACH RECORD\n**********************************************************************\nGOT      LA    R14,IBUF            DATA ADDRESS\n         LR    R15,R0              DATA LENGTH 64\n*-       LA    R0,1                FUNCTION CODE 1, SHA-1\n         LA    R0,2                FUNCTION CODE 2, SHA-256\n*-       LA    R1,SHA1PB           SHA-1\n         LA    R1,SHA2PB           SHA-256\nKLOOPI   EQU   *\n         KIMD  R2,R14              R2 NOT USED, R14 --> DATA, R15 = LEN\n         BNZ   KLOOPI              LOOP IF PARTIAL\n         B     READLOOP\n         SPACE\n*              R0 CONTAINS 0 TO 63 OR MOD(FILESIZE,64)\n*              THE LENGTH OF ANY REMAINING DATA IN IBUF AFTER\n*              HAVING PROCESSED THE FILE IN 64-BYTE CHUNKS.\nGOTLAST  EQU   *\n         LM    R14,R15,FILESIZE\n         ALR   R15,R0              ADD LENGTH IN R0\n         BC    12,NOCARRYL\n         AL    R14,=F'1'\nNOCARRYL STM   R14,R15,FILESIZE\n**********************************************************************\n*              USE KLMD FOR LAST RECORD\n**********************************************************************\n         SLDL  R14,3               MULTIPLY BY 8, BYTES TO BITS\n*              A FILE OF 536,870,912 BYTES WILL HAVE HEX 100000000 BITS\n*              MAKING THE HIGH WORD OF THE MESSAGE BIT LENGTH NONZERO.\n*              THAT'S 5114 CYLINDERS ON A 3390, ABOUT HALF OF A 3390-9.\n*-       STM   R14,R15,SHA1PB+20   MESSAGE BIT LENGTH FOR SHA-1\n         STM   R14,R15,SHA2PB+32   MESSAGE BIT LENGTH FOR SHA-256\n         LA    R14,IBUF            DATA ADDRESS\n         LR    R15,R0              DATA LENGTH < 64\n*-       LA    R0,1                FUNCTION CODE 1, SHA-1\n         LA    R0,2                FUNCTION CODE 2, SHA-256\n*-       LA    R1,SHA1PB\n         LA    R1,SHA2PB\nKLOOPL   EQU   *\n         KLMD  R2,R14              R2 NOT USED, R14 --> DATA, R15 = LEN\n         BNZ   KLOOPL              LOOP IF PARTIAL\n         SPACE\n**********************************************************************\n*              OUTPUT THE RESULTS\n**********************************************************************\n         MVI   OBUF,C' '\n         MVC   OBUF+1(255),OBUF\n*        MVC   ORDW(4),=AL2(36,0)\n         LA    R15,OBUF\n         TM    RECFM(R4),X'04'     IF ASA CARRIAGE CONTROL\n         BZ    NOTASA                THEN\n         LA    R15,1(,R15)           POINT PAST 1ST COLUMN\nNOTASA   LR    R2,R15\n*-       LA    R1,SHA1PB           SHA-1\n         LA    R1,SHA2PB           SHA-256\n*-       LA    R0,20 FOR SHA-1\n         LA    R0,32 FOR SHA-256\n         BAL   R14,TOHEX\n         LR    R15,R2\n         SPACE\n*-       LA    R1,40(,R15)         POINT R1 PAST LAST BYTE\n         LA    R1,64(,R15)         POINT R1 PAST LAST BYTE SHA-256\n         CLI   OPTE,1              IF NO 'E' IN PARM, (SHOW DSN)\n         BNE   SETLEN                GO TO SETLEM\n         MVI   1(R1),C'*'          ELSE ADD *\n         MVC   2(44,R1),JFCB       AND DSN\n         LA    R1,45(,R1)          LAST CHAR OF DSNAME\n         LA    R0,44               INITIAL LENGTH\nFILEA    CLI   0(R1),C' '          IS THIS LAST NONBLANK\n         BNE   FILEB               YES, BRANCH\n         BCTR  R1,0                BACK UP 1 CHARACTER\n         BCT   R0,FILEA            DECREMENT LENGTH AND BRANCH\nFILEB    LA    R1,1(,R1)           POINT PAST LAST CHAR\n         CLI   JFCB+44,C' '        IF NO MEMBER IN JFCB\n         BE    SETLEN                GO TP SETLEM\n         MVI   0(R1),C'('\n         MVC   1(8,R1),JFCB+44     JFCBELNM IN IEFJFCBN\n         LA    R1,8(,R1)           LAST CHAR OF MEMBER NAME\n         LA    R0,8\nMEMA     CLI   0(R1),C' '\n         BNE   MEMB\n         BCTR  R1,0\n         BCT   R0,MEMA\nMEMB     MVI   1(R1),C')'\n         LA    R1,1(,R1)           POINT PAST LAST CHAR\nSETLEN   LA    R0,OBUF\n         SR    R1,R0               COMPUTE LENGTH\nNONAME   EQU   *\n         CLI   OPTL,1              IF 'L' IN PARM, FOR LOWERCASE\n         BNE   *+10                  THEN\n         TR    OBUF(256),LOWER       TRANSLATE TO LOWER CASE\n         LA    R0,OBUF             PUT WILL USE R0 AS RECORD ADDRESS\nPUTU     TM    RECFM(R4),X'C0'     IF OUTPUT RECFM U\n         BNO   PUTV\n         LH    R0,BLKSI(,R4)         GET BLKSI\n         CR    R1,R0                 IF LONGER THAN BLKSI\n         BNH   *+6                     THEN\n         LR    R1,R0                   TRUNCATE TO BLKSI\n         STH   R1,LRECL(,R4)         SET RECFM U RECORD SIZE\n         B     PUTT\nPUTV     TM    RECFM(R4),X'40'     IF RECFM V\n         BZ    PUTT                  THEN\n         LA    R1,4(,R1)             LENGTH + 4 FOR RDW\n         LH    R0,LRECL(,R4)         GET LRECL\n         CR    R1,R0                 IF LONGER THAN LRECL\n         BNH   *+6                     THEN\n         LR    R1,R0                   TRUNCATE TO LRECL\n         SLL   R1,16                 SHIFT LEFT 16\n         ST    R1,ORDW               SET RDW\n         LA    R0,ORDW               USE RDW FOR PUT\nPUTT     LA    R6,UT2DCBEW\n         TM    DCBEFLG1-DCBE(R6),DCBEMD31 31-BIT SAM SUPPORTED?\n         BNO   PUT24               NO, USE 24-BIT MOOE FOR PUT\n         PUT   (R4),(0)\n         B     EXIT0\nPUT24    LA    R15,PUT24S\n         MVC   0(PUT24L,R15),PUT24I\n         ST    R13,SAVE24+4        SAVE R13\n         LA    R13,SAVE24          PUT NEEDS R13 TO POINT BELOW LINE\n         BASSM R11,R15             RUN PUT IN 24-BIT MODE\n         L     R13,SAVE24+4        RESTORE R13\n         B     EXIT0\n         SPACE\n*        THE FOLLOWING INSTRUCTIONS FROM PUT24I TO PUT24L ARE COPIED\n*        TO STORAGE BELOW THE LINE AND ARE CALLED BY THE BASSM ABOVE.\n*        THEY RUN IN 24-BIT MODE SO THE PUT WILL WORK FOR A TERMINAL.\n*        THEY DON'T USE A BASE REGISTER, SO THAT SIMPLIFIES IT.\nPUT24I   PUT   (R4),(0)\n         BSM   0,R11\nPUT24L   EQU   *-PUT24I\n         SPACE\nEXITN    CLI   RETCODE+3,12        IF AN ERROR OCCURRED\n         BNE   EXITC2                DON'T SET RC 0\nEXIT0    MVI   RETCODE+3,0\nEXITC2   MVC   CLOSE31W(CLOSE31L),CLOSE31\n         CLOSE ((R4)),MODE=31,MF=(E,CLOSE31W)\n*        LR    R7,R4\n*        BAL   R2,FREEPOOL\nEXITC1   MVC   CLOSE31W(CLOSE31L),CLOSE31\n         CLOSE ((R3)),MODE=31,MF=(E,CLOSE31W)\n*        LR    R7,R3\n*        BAL   R2,FREEPOOL\n         B     EXIT\n*REEPOOL FREEPOOL (R7)\n*        BR    R2\n         SPACE\nTOHEX    MVC   1(1,R15),0(R1)\n         UNPK  0(3,R15),1(2,R15)\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)\n         LA    R1,1(,R1)\n         BCT   R0,TOHEX\n         MVI   0(R15),C' '\n         BR    R14\n         SPACE\nEXIT     L     R2,RETCODE\n         LR    R1,R8\n         LA    R0,@DATA24L\n         STORAGE RELEASE,ADDR=(1),LENGTH=(0)\n         LR    R1,R13\n         L     R0,@SIZE\n         L     R13,4(,R13)\n         STORAGE RELEASE,ADDR=(1),LENGTH=(0)\n         DROP  R9\n         LR    R15,R2\n         LM    0,12,20(R13)\n         L     R14,12(,R13)\n         BR    R14\n         SPACE\n*         DCB OPEN EXIT\nUT2EXIT  CLI   RECFM(R1),0         IF NO RECFM\n         BNE   UT2EXI2                THEN\n         MVI   RECFM(R1),X'90'        USE FB\nUT2EXI2  TM    RECFM(R1),X'10'     IF BLOCKED\n         BZ    UT2EXI3                AND\n         CLC   LRECL(2,R1),=H'0'      NO LRECL\n         BNE   UT2EXI3                THEN\n         MVC   LRECL(2,R1),=H'80'     USE 80\nUT2EXI3  CLC   BLKSI(2,R1),=H'0'   IF NO BLKSIZE\n         BNE   UT2EXI4                THEN\n         MVC   BLKSI(2,R1),LRECL(R1)  USE LRECL\nUT2EXI4  BR    R14\n         SPACE\n*        THIS ROUTINE IS COPIED TO 24-BIT STORAGE\n*        IT IS ENTERED IN 24-BIT MODE, CALLS UT2EXIT IN 31-BIT MODE\n*        LEAVING ORIGINAL R14 RETURN ADDRESS IN R14\n         CNOP  0,4                 ALIGN ON FULLWORD\nUT2GLUE  L     R15,UT2GLUEP-*(,R15)   GET ADDRESS OF UT2EXIT\n         BSM   R14,R15             CALL UT2EXIT WITH OLD MODE IN R14\nUT2GLUEP DC    F'0'                WILL CONTAIN ADDRESS OF UT2EXIT\nUT2OPENL EQU   *-UT2GLUE\n         SPACE\n*        THIS ROUTINE IS COPIED TO 24-BIT STORAGE\n*        IT IS ENTERED IN 24-BIT MODE, GOES TO UT1EOD IN 31-BIT MODE\n         CNOP  0,4                 ALIGN ON FULLWORD\nEOD24I   L     R15,EOD24P-*(,R15)  GET ADDRESS OF UT1EOD AND 31-BIT\n         L     R13,SAVE24+4        RESTORE R13 CHANGED BEFORE GET\n         BSM   R0,R15              GOTO UT1EOD IN 31-BIT MODE\nEOD24P   DC    F'0'                WILL CONTAIN ADDRESS OF UT2EXIT\nEOD24L   EQU   *-EOD24I\n         SPACE\n         LTORG\n         DC    0D'0'\n         PRINT NOGEN\nUT1DCB   DCB   DDNAME=SYSUT1,DSORG=PS,MACRF=(GL),EODAD=0,DCBE=0\nUT1DCBL  EQU   *-UT1DCB\nUT1DCBE  DCBE  RMODE31=BUFF,EODAD=UT1EOD\nUT1DCBEL EQU   *-UT1DCBE\nUT2DCB   DCB   DDNAME=SYSUT2,DSORG=PS,MACRF=(PM),EXLST=0,DCBE=0\nUT2DCBL  EQU   *-UT2DCB\nUT2DCBE  DCBE  RMODE31=BUFF\nUT2DCBEL EQU   *-UT2DCBE\nUT1EXL   DC    0F'0',X'87',AL3(0)\nUT2EXL   DC    0F'0',X'85',AL3(0)\nOPEN31   OPEN  (0,),MODE=31,MF=L\nOPEN31L  EQU   *-OPEN31\nCLOSE31  CLOSE (0,),MODE=31,MF=L\nCLOSE31L EQU   *-CLOSE31\n         DC    0D'0'\nHEXTAB   DC    C'0123456789ABCDEF'\nLOWER    DC    256AL1(*-LOWER)\n         ORG   LOWER+C'A'\n         DC    X'818283848586878889'\n         ORG   LOWER+C'J'\n         DC    X'919293949596979899'\n         ORG   LOWER+C'S'\n         DC    X'A2A3A4A5A6A7A8A9'\n         ORG\n         DC    0D'0'\n         AGO   .SKIP1\nSHA1PI   DC    X'67452301' H0\n         DC    X'EFCDAB89' H1\n         DC    X'98BADCFE' H2\n         DC    X'10325476' H3\n         DC    X'C3D2E1F0' H4\n         DC    X'00000000' MESSAGE BIT LENGTH HIGH\n         DC    X'00000000' MESSAGE BIT LENGTH LOW\n         SPACE\n.SKIP1   ANOP\n*-       AGO   .SKIP2\nSHA2PI   DC    X'6A09E667' H0\n         DC    X'BB67AE85' H1\n         DC    X'3C6EF372' H2\n         DC    X'A54FF53A' H3\n         DC    X'510E527F' H4\n         DC    X'9B05688C' H5\n         DC    X'1F83D9AB' H6\n         DC    X'5BE0CD19' H7\n         DC    X'00000000' MESSAGE BIT LENGTH HIGH\n         DC    X'00000000' MESSAGE BIT LENGTH LOW\n.SKIP2   ANOP\n         DC    0D'0'\n         SPACE\n@DATA    DSECT\n         DS    18F\nRETCODE  DS    F\nOPEN31W  DS    0F,(OPEN31L)X\nCLOSE31W DS    0F,(CLOSE31L)X\nOPTE     DS    H\nOPTL     DS    H\nOPTR     DS    H\nGOTEOD   DS    C\nI64      DS    F\nGETREGS  DS    5F\nFILESIZE DS    2F\nDOUBLE   DS    D\n@CLEARL  EQU   *-@DATA\nUT1DCBEW DS    0F,(UT1DCBEL)X\nUT2DCBEW DS    0F,(UT2DCBEL)X\nIBUF     DS    CL64\nSHA1PB   DS    0D,7F\nSHA2PB   DS    0D,10F\n         DS    0D\n@DATAL   EQU   *-@DATA\n         SPACE\n@DATA24  DSECT\nSAVE24   DS    18F\nUT1DCBW  DS    0F,(UT1DCBL)X\nUT2DCBW  DS    0F,(UT2DCBL)X\nUT1EXLST DS    F\nUT2EXLST DS    F\nUT1RDJF  DS    F\nUT2OPENX DS    0F,(UT2OPENL)X  GLUE ROUTINE COPIED HERE\nGET24S   DS    0H,(GET24L)X\nPUT24S   DS    0H,(PUT24L)X\nEOD24S   DS    0H,(EOD24L)X\n*        OUTPUT BUFFERS ARE HERE IN CASE PUT TO TERMINAL, DCBEMD31 OFF\nORDW     DS    F\nOBUF     DS    256C\n         DS    0D\nJFCB     DS    CL176\n         DS    0D\n@DATA24L EQU   *-@DATA24\n         SPACE\n         PRINT NOGEN\n         IHADCBE\n         SPACE\n*         EQUATES FOR DCB FIELD OFFSETS\nEXLST    EQU   36\nRECFM    EQU   36\nDDNAM    EQU   44\nOFLGS    EQU   48\nBLKSI    EQU   62\nLRECL    EQU   82\n         SPACE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SHA2PGM$": {"ttr": 5643, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00F\\x01 \\x14\\x1f\\x01 \\x14\\x1f\\x11Q\\x00\\x10\\x00\\x10\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-05-20T00:00:00", "modifydate": "2020-05-20T11:51:46", "lines": 16, "newlines": 16, "modlines": 0, "user": "UPDATED"}, "text": "//CBTUSER1 JOB (ACCT),'PGMRNAME',NOTIFY=CBTUSER,\n//         MSGLEVEL=(1,1),MSGCLASS=H\n//ASM     EXEC PGM=ASMA90,\n//             PARM=(LIST,OBJ,NODECK,ASA,NOXREF,NODX,NOMX,NORX,NOUS,\n//             BATCH,'PC(NOUHD)')\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//SYSLIN   DD  DSN=&&OBJ,DISP=(NEW,PASS),SPACE=(TRK,(3,3)),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=800)\n//SYSIN    DD  DSN=CBTUSER.LIB.ASM(SHA2PGM),DISP=SHR\n//LKED   EXEC PGM=HEWLF064,PARM='MAP,NOXREF,RENT,REFR',\n//             COND=(0,NE)\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSNAME=&&OBJ,DISP=(OLD,DELETE)\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(TRK,(10,0))\n//SYSLMOD  DD  DSN=CBTUSER.LIB.LOAD(SHA2PGM),DISP=SHR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SHA2SUM": {"ttr": 5889, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x00%\\x01\\x16\\x14\\x8f\\x01\\x19\\x07\\x7f\\x13&\\x05\\x8f\\x05x\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "2016-05-27T00:00:00", "modifydate": "2019-03-18T13:26:25", "lines": 1423, "newlines": 1400, "modlines": 0, "user": "UPDATED"}, "text": "         TITLE '   S H A 2 S U M  '\n************************************************************\n*                                                          *\n*        'SHA2SUM' TSO COMMAND (31-BIT)                    *\n*                                                          *\n************************************************************\n         SPACE\n*        WRITTEN MAY 22 2016 USING MD5SUM AS A TEMPLATE.\n*         NOTE: MD5SUM USED 'COUNT' (CBT FILE 300) AS A TEMPLATE.\n*        ATTRIBUTES. RE-ENTRANT.\n*        UPDATED MAY 27 2016 TO ADD BRIEF AND MULTI KEYWORDS.\n*        UPDATED AUG 28 2016 TO IGNORE DS1LSTAR WHICH IS 0 FOR PDSE\n*        UPDATED SEP  3 2016 TO SET RETURN CODE 12 IF ANY ERROR\n*        UPDATED DEC 27 2017 TO SUPPORT 8-BYTE PREFIX IN Z/OS V2R3\n*        UPDATED MAR 18 2019 TO SUPPORT EAV VOLUMES (SEE CHANGES BELOW)\n*\n*        THIS TSO COMMAND READS THE SPECIFIED SEQUENTIAL DATA SETS\n*        OR PDS MEMBERS AND DISPLAYS THE SHA-256 HASH FOR EACH.\n*        SHA = SECURE HASH ALGORITHM.\n*\n*        SYNTAX:\n*                SHA2SUM DSNAME\n*                SHA2SUM (DSNAME1 DSNAME2 ...)\n*        KEYWORDS:\n*                RDW - INCLUDE RDW'S\n*                LOWER - SHOW RESULTS IN LOWER CASE\n*                QUICK - DSNAME IS COMPLETE, NO IMPLIED EXTENSION\n*                FILE - DSNAME IS A DDNAME ALREADY ALLOCATED\n*                BRIEF - SHOW THE HASH ONLY, WITH NO DSNAME\n*                MULTI - SHOW THE HASH AND DSNAME ON SEPARATE LINES\n*\n*        IF AN UNQUALIFIED DATA SET NAME IS ENTERED, THE\n*        CATALOG MUST BE READ TWICE, ONCE TO APPEND A\n*        TRAILING QUALIFIER IF NECESSARY, AND AGAIN DURING\n*        ALLOCATION. THE USER CAN ELIMINATE THE FIRST BY USING\n*        THE FULLY QUALIFIED NAME, PREFIX AND ALL, IN QUOTES,\n*        OR BY ENTERING ALL BUT THE PREFIX, WITHOUT QUOTES,\n*        PLUS THE KEYWORD 'Q'. THE LATTER IS MUCH SIMPLER\n*        AND GIVES THE SAME PERFORMANCE IMPROVEMENT AS A\n*        FULLY QUALIFIED NAME.\n*\n*        THE 'FILE' KEYWORD IS USEFUL FOR READING TEMPORARY\n*        DATA SETS.  IT TELLS THE COMMAND TO TREAT THE FIRST\n*        OPERAND AS A FILENAME (DDNAME) INSTEAD OF A DSNAME.\n*        WHATEVER DATA SET IS CURRENTLY ALLOCATED TO THE\n*        FILENAME WILL BE READ (AND QUICKLY, BECAUSE\n*        THE COMMAND DOESNT HAVE TO ALLOCATE ANYTHING).\n*\n*        UNIX FILES THAT ARE PREALLOCATED TO A DDNAME CAN BE\n*        READ. FOR EXAMPLE:\n*         ALLOC FI(DD1) PATH('/ETC/MAGIC') (BUT USE PATH IN LOWER CASE)\n*         SHA2SUM DD1 FILE\n*        IF UNIX FILES ARE NOT GIVEN RECFM WHEN ALLOCATED\n*        THEY DEFAULT TO RECFM=U, WHICH IS GOOD FOR SHA2SUM.\n*        RECFM=F WOULD BE LIKELY TO INTRODUCE PADDING IN THE\n*        LAST RECORD, WHICH WOULD CHANGE THE SHA2SUM RESULT.\n*\n*        NOTE - IF A NON-EXISTENT MEMBER OF A PDS IS SPECIFIED,\n*        THE RESULTING 013-18 ABEND IS TRAPPED BY A DCB ABEND\n*        EXIT, BUT A MESSAGE IS ISSUED BY OPEN ANYWAY. THIS\n*        METHOD IS USED BECAUSE THE ADDITIONAL OVERHEAD\n*        OF ALLOCATING THE PDS AND DOING A 'BLDL' WOULD\n*        DEGRADE THE PERFORMANCE UNACCEPTABLY.\n*\n*        PROBLEMS FIXED:\n*        . IF THE SPECIFIED DDNAME (WITH 'FILE' KEYWORD) IS\n*          A MEMBER OF A PDS, ONLY THE PDS NAME WAS SHOWN.\n*          ADDED CODE TO GET MEMBER NAME FROM JFCBELNM.\n*        . IF THE SPECIFIED DDNAME (WITH 'FILE' KEYWORD) IS\n*          A UNIX PATH, ONLY \"...PATH=.SPECIFIED...\" IS SHOWN,\n*          THAT'S WHAT IS IN THE JFCB. ADDED ARL TO GET PATH.\n*\n*        IMPROVEMENTS NEEDED:\n*        . ALLOW PATH TO BE SPECIFIED AND ALLOCATE IT.\n*        . IF THE SPECIFIED DDNAME (WITH 'FILE' KEYWORD) IS\n*          A CONCATENATION, SHOW MORE THAN THE FIRST DSN OR PATH.\n*\n* CHNGE LOG: 02JUN92 - INCLUDED 'OBTAIN' MACRO IN THE SOURCE. WITH\n*                      MVS/XA 2.2.3, THE MACRO IS ONLY AVAILABLE IN\n*                      'SYS1.AMACLIB' (SOUNDS LIKE IBM IS TRYING TO\n*                      TELL US SOMETHING).  JIM MARSHALL         JDM1\n*\n* CHNGE LOG: 12OCT13 - MD5SUM COMMAND CREATED FROM SOURCE OF 'COUNT'.\n*                      RDW'S ARE NOT INCLUDED IN THE MD5 AT THIS TIME,\n*                      AS A RESULT, 2 FILES OF VARIABLE-LENGTH RECORDS,\n*                      ONE WITH 2 RECORDS \"AB\" AND \"CD\" AND THE OTHER\n*                      ONE WITH 2 RECORDS \"ABC' AND \"D\" WILL HAVE THE\n*                      SAME MD5 VALUE.\n*\n* CHNGE LOG: 11NOV13 - SUPPORT LIST OF DSNAMES, SHOW NAME AFTER MD5.\n*\n* CHNGE LOG: 12NOV13 - CONVERT TO 31-BIT.\n*\n* CHNGE LOG: 15NOV13 - ALLOW NON-DASD DEVTYPE INCLUDING UNIX AND DUMMY.\n*                      SHOW UNIX FILE NAME IF DDNAME ALLOCATED TO PATH.\n*                      SHOW MEMBER NAME IF DDNAME ALLOCATED TO MEMBER.\n*\n* CHNGE LOG: 13MAR19 - REVERSED THE CHANGE FROM JUNE 02, 1992 AND USED\n*                      THE ORIGINAL OBTAIN MACRO AGAIN. ADDITIONALLY\n*                      ADDED THE EADSCB=OK MACRO PARAMETER.\n*\n*--------------------------------------------------------------------\n*         MACRO                                                  JDM1\n*&NAME    OBTAIN &LIST,&DUMMY=                                   JDM1\n*         AIF   (T'&LIST EQ 'O').E1                              JDM1\n*&NAME    IHBINNRA &LIST                 LOAD REG 1              JDM1\n*         SVC   27                       ISSUE OBTAIN SVC        JDM1\n*         MEXIT                                                  JDM1\n*.E1      IHBERMAC 34                    LIST ADDR MISSING       JDM1\n*         MEND                                                   JDM1\n*--------------------------------------------------------------------\n*         INTERCEPT 'LINK' MACRO IMBEDDED IN STACK MACRO\n*         TO MAKE SF=(E,LINKAREA) THE DEFAULT.\n         MACRO\n&NAME    LINK  &EP=,&SF=(E,LINKAREA)\n&NAME    LA    15,&SF(2)\n         LA    0,*+8\n         B     *+12\n         DC    CL8'&EP'\n         ST    0,0(0,15)\n         SVC   6             ISSUE LINK SVC\n         MEND\n         SPACE\nSHA2SUM  START\nSHA2SUM  AMODE 31\nSHA2SUM  RMODE 31\n         USING *,R12,R11\n         B     @PROLOG-*(,R15)\n         DC    AL1(7),CL7'SHA2SUM'\n         DC    CL16' &SYSDATE &SYSTIME '\n@SIZE31  DC    0F'0',AL1(0),AL3(@DATA31L)\n@SIZE24  DC    0F'0',AL1(1),AL3(@DATA24L)\n@PROLOG  STM   14,12,12(13)\n         LR    R12,R15             BASE\n         LA    R15,1\n         LA    R11,4095(R15,R12)   BASE\n         LR    R2,R1\n         USING CPPL,R2\n         L     R0,@SIZE31\n         GETMAIN RU,LV=(0),SP=1,LOC=31\n         LR    R9,R1\n         USING @DATA31,R9\n         ST    13,4(,1)            CHAIN SAVEAREA\n         ST    1,8(,13)            CHAIN SAVEAREA\n         LR    13,1                NEW SAVEAREA\n         SPACE\n         L     R0,@SIZE24\n         GETMAIN R,LV=(0)\n         LR    R10,R1\n         USING @DATA24,R10\n         SPACE\n         MVI   STATUS,0\n         XC    LINKAREA(8),LINKAREA\n         SLR   R15,R15\n         STH   R15,RETCODE         SET RETCODE = 0\n         ST    R15,KOUNT\n         ST    R15,KOUNTSP\n         SPACE\n************************************************************\n*                                                          *\n*        SET UP IOPL FOR PUTLINE                           *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R15,MYIOPL\n         USING IOPL,R15\n         MVC   IOPLUPT(4),CPPLUPT\n         MVC   IOPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,IOPLECB\n         XC    MYECB,MYECB\n         LA    R0,MYPTPB\n         ST    R0,IOPLIOPB\n         DROP  R15                 IOPL\n         SPACE\n         L     R15,16              LOAD CVT POINTER\n         TM    444(R15),X'80'      IS PUTLINE LOADED? (VS2)\n         BNO   PUTLOAD             NO - BRANCH TO LOAD\n         L     R15,444(,R15)       YES - USE CVTPUTL\n         B     PUTLOADX            BRANCH AROUND LOAD\nPUTLOAD  LA    R0,=CL8'IKJPUTL '\n         LOAD  EPLOC=(0)\n         LR    R15,R0              GET ENTRY ADDRESS\n         LA    R15,0(,R15)         CLEAR HI BYTE FOR DELETE ROUTINE\nPUTLOADX ST    R15,MYPUTLEP        SAVE PUTLINE ENTRY ADDRESS\n         SPACE\n************************************************************\n*                                                          *\n*        SET UP PPL FOR PARSE                              *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R15,MYPPL\n         USING PPL,R15\n         MVC   PPLUPT(4),CPPLUPT\n         MVC   PPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,PPLECB\n         XC    MYECB,MYECB\n         L     R0,=A(SHASMPCL)\n*        LA    R0,PCLADDR\n         ST    R0,PPLPCL\n         LA    R0,MYANS\n         ST    R0,PPLANS\n         XC    MYANS(4),MYANS\n         MVC   PPLCBUF(4),CPPLCBUF\n         ST    R9,PPLUWA\n         DROP  R15                 PPL\n         SPACE 1\n************************************************************\n*                                                          *\n*        CALL THE PARSE SERVICE ROUTINE                    *\n*                                                          *\n************************************************************\n         SPACE\n         LR    R1,R15              POINT TO PPL\n*        CALLTSSR EP=IKJPARS\n         L     R15,16              CVTPTR\n         TM    524(R15),X'80'      IF HI ORDER BIT NOT ON\n         BNO   PARSELNK               THEN DO LINK, NOT CALL\n         L     R15,524(,R15)       CVTPARS\n         BALR  R14,R15             CALL IKJPARS\n         B     PARSEEXT            SKIP AROUND LINK\nPARSELNK EQU   *\n         LINK  EP=IKJPARS,SF=(E,LINKAREA)\nPARSEEXT EQU   *\n         SPACE 1\n         LTR   R15,R15\n         BZ    PARSEOK\n         LA    R1,MSG01\n         LA    R0,L'MSG01\n         BAL   R14,PUTMSG\n         LA    R15,12\n         B     EXIT\nPARSEOK  EQU   *\n         SPACE\n         L     R3,MYANS\n         USING IKJPARMD,R3\n         SPACE\n         MVC   OPTR,RDWKW+1\n         SPACE\n************************************************************\n*                                                          *\n*        GET THE FIRST OR NEXT DSN IN THE LIST             *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R6,DSN\n         ST    R6,DSL\n         B     FIRSTDSN\nNEXTDSN  L     R6,DSL\n         CLI   24(R6),X'FF'        END OF DSN LIST?\n         BE    DONE\n         L     R6,24(,R6)          POINT TO NEXT ENTRY\n         ST    R6,DSL\nFIRSTDSN SR    R0,R0\n         ST    R0,KOUNT\n         SPACE\n************************************************************\n*                                                          *\n*        QUALIFY THE DSNAME IF NECESSARY                   *\n*                                                          *\n************************************************************\n         SPACE\n         TM    6(R6),X'80'         IS DATASET NAME SPECIFIED?\n         BO    OKDSN               YES - BRANCH\n         LA    R1,MSG05            NO - JUST MEMBER NAME\n         LA    R0,L'MSG05\n         BAL   R14,PUTMSG\n         B     NEXTD12\nOKDSN    EQU   *\n         LA    R15,DSNAME+2\n         MVI   0(R15),C' '         BLANK THE DSNAME AREA\n         MVC   1(43,R15),0(R15)\n         SLR   R1,R1\n         STH   R1,DSNAME           ZERO DSNAME LENGTH\n         TM    6(R6),X'40'         IS DSN QUOTED?\n         BO    NOPREF              YES, SKIP PREFIXING\n         CLI   FILEKW+1,1          DSN TO BE TREATED AS DDNAME\n         BE    NOPREF              YES, SKIP PREFIXING\n         L     R14,CPPLUPT         POINT TO UPT\n         USING UPT,R14\n*         CHECK UPT FOR 8-BYTE PREFIX - Z/OS V2R3.\n         CLI   UPTPREFX,C'>'      IF PREFIX IS '>7BYTES' (8 BYTES)\n         BNE   PREF07                THEN\n         IC    R1,UPTPREFL+18        GET UPTPRF8L (SHOULD ALWAYS BE 8)\n         LTR   R1,R1                 IS IT ZERO\n         BZ    NOPREF                YES, SKIP PREFIXING\n         B     *+10\n         MVC   0(0,R15),UPTPREFX+17  COPY UPTPREF8\n         EX    R1,*-6              MOVE USERID TO DSNAME AREA\n         B     PREFDONE\nPREF07   EQU   *\n         IC    R1,UPTPREFL         GET LENGTH OF PREFIX\n         LTR   R1,R1               IS IT ZERO\n         BZ    NOPREF              YES, SKIP PREFIXING\n         B     *+10\n         MVC   0(0,R15),UPTPREFX\n         EX    R1,*-6              MOVE USERID TO DSNAME AREA\nPREFDONE EQU   *\n         DROP  R14                 UPT\n         LA    R15,0(R1,R15)       POINT PAST USERID\n         MVI   0(R15),C'.'         APPEND PERIOD\n         LA    R15,1(,R15)         POINT PAST PERIOD\n         LA    R1,1(,R1)           ADD 1 TO LENGTH\n         STH   R1,DSNAME           STORE LENGTH OF USERID PLUS 1\nNOPREF   EQU   *\n         LH    R1,4(,R6)           GET LENGTH\n         LR    R0,R1\n         AH    R0,DSNAME           ADD LENGTH OF PREFIX OR ZERO\n         STH   R0,DSNAME           SET COMBINED LENGTH\n         L     R14,0(,R6)          POINT TO DSN VALUE\n         BCTR  R1,0                LENGTH MINUS 1 FOR EX\n         B     *+10                BRANCH AROUND EXECUTED MVC\n         MVC   0(0,R15),0(R14)     (EXECUTED)\n         EX    R1,*-6              MOVE DSN TO DSNAME (AFTER PREFIX)\n         SPACE\n************************************************************\n*                                                          *\n*        IF 'FILE' KEYWORD IS SPECIFIED,                   *\n*        GET DSNAME FROM JFCB USING FILE NAME.             *\n*                                                          *\n************************************************************\n         SPACE\n         CLI   FILEKW+1,1          'FILE' SPECIFIED?\n         BNE   NOFILE              NO, BRANCH\n         CLI   DSNAME+1,8          IS LENGTH 8 OR LESS\n         BH    FILERR1             NO, BRANCH\n         DEVTYPE DSNAME+2,DEVDATA  GET DEVICE TYPE\n         LTR   R15,R15             WAS FILENAME VALID\n         BNZ   FILERR2             NO, BRANCH\n*        CLC   DEVDATA(8),=X'0000010300007FF8'\n*        BE    DEVOK\n*        TM    DEVDATA+2,X'20'     DIRECT ACCESS\n*        BZ    FILERR3             NO, BRANCH\nDEVOK    LA    R4,DYNDCBW\n         MVC   0(DYNDCBL,R4),DYNDCB\n         XC    DSNAME(2),DSNAME\n         XC    MEMLEN,MEMLEN\n         LA    R0,JFCB\n         LA    R1,DYNEXLST\n         ST    R0,0(,R1)\n         MVI   0(R1),X'07'\n         LA    R14,MYARL           ALLOCATION RETRIEVAL LIST\n         ST    R14,4(,R1)\n         MVI   4(R1),X'13'+X'80'\n         ST    R1,DCBEXLST-IHADCB(,R4)\n         USING ARL,R14\n         XC    0(36,R14),0(R14)\n         MVI   ARLLEN+1,36\n         MVC   ARLIDENT,=C'AR'\n         OI    ARLOPT1,ARLLANY+ARLUSS\n         MVC   40(8,R4),DSNAME+2   DCBDDNAM\n         MVC   DDSAVE,DSNAME+2\n         MVI   RDJFW,X'80'\n         RDJFCB ((R4)),MF=(E,RDJFW)\n         LA    R14,MYARL\n         L     R1,ARLAREA\n         LTR   R1,R1\n         BZ    NOARA\n         L     R0,ARLRTRVD\n         DROP  R14                 ARL\n         USING ARA,R1\nLOOPARA  TM    ARAFLG,ARAXINF\n         BZ    DONEARA\n         SR    R15,R15\n         IC    R15,ARAXINOF\n         SLL   R15,3\n         AR    R15,R1\n         USING ARAXINFO,R15\n         SR    R14,R14\n         ICM   R14,3,ARAPATHO      GET OFFSET TO PATH LEN\n         BZ    DONEARA\n         AR    R14,R15\n         DROP  R15                 ARAXINLN\n         SR    R15,R15\n         ICM   R15,3,0(R14)        GET ARAPATHLEN\n         CH    R15,=H'44'\n         BNH   *+8\n         LA    R15,44              JUST SHOW FIRST 44 FOR NOW\n         STH   R15,DSNAME\n         BCTR  R15,0\n         B     *+10\n         MVC   DSNAME+2(0),2(R14)  ARAPATHNAM\n         EX    R15,*-6\nDONEARA  LA    R14,MYARL           PREPARE FOR FREEMAIN\n         USING ARL,R14\n         SR    R15,R15             PREPARE FOR FREEMAIN\n         IC    R15,ARLPOOL\n         SR    R0,R0\n         ICM   R0,7,ARLRLEN\n         L     R1,ARLAREA\n         DROP  R14                 ARL\n         FREEMAIN RU,LV=(0),SP=(R15),A=(1)\nNOARA    CLC   DSNAME(2),=H'0'\n         BNE   FILESPEC\n         MVC   DSNAME+2(44),JFCB\n         LA    R1,DSNAME+45        LAST CHAR OF DSNAME\n         LA    R0,44               INITIAL LENGTH\nFILEA    CLI   0(R1),C' '          IS THIS LAST NONBLANK\n         BNE   FILEB               YES, BRANCH\n         BCTR  R1,0                BACK UP 1 CHARACTER\n         BCT   R0,FILEA            DECREMENT LENGTH AND BRANCH\nFILEB    STH   R0,DSNAME           STORE LENGTH OF DSNAME\n*        MVC   VOLUME(6),JFCB+118  GET VOLUME FROM JFCB\n         MVC   MEMNAME,JFCB+44     JFCBELNM IN IEFJFCBN\n         LA    R1,MEMNAME+7        LAST CHAR OF MEMBER NAME\n         LA    R0,8\nMEMA     CLI   0(R1),C' '\n         BNE   MEMB\n         BCTR  R1,0\n         BCT   R0,MEMA\nMEMB     STH   R0,MEMLEN\n         B     FILESPEC\nFILERR1  LA    R0,MSG14A\n         B     FILERR\nFILERR2  LA    R0,MSG14B\n         B     FILERR\nFILERR3  LA    R0,MSG14C\nFILERR   MVC   MSGWK(L'MSG14),MSG14\n         LA    R15,MSGWK+L'MSG14\n         LA    R14,DSNAME\n         LH    R1,0(,R14)\n         BCTR  R1,0\n         B     *+10\n         MVC   MSGWK+L'MSG14(0),2(R14)\n         EX    R1,*-6\n         LA    R15,1(R1,R15)\n         LR    R14,R0 POINT TO MSG14A, B, OR C\n         MVC   0(L'MSG14A,R15),0(R14)\n         LA    R0,L'MSG14+L'MSG14A+1(,R1)\n         LA    R1,MSGWK\n         BAL   R14,PUTMSG\n         B     QUITD12\nNOFILE   EQU   *\n         TM    6(R6),X'40'         IS IT QUOTED?\n         BO    DEFX                YES - SKIP DEFAULT SERVICE\n         CLI   QUICKW+1,1          QUICK SPECIFIED\n         BE    DEFX                YES, USER ENTERED ALL BUT PREFIX\n         SPACE\n************************************************************\n*                                                          *\n*        DEFAULT SERVICE ROUTINE TO GET QUALIFIERS         *\n*                                                          *\n************************************************************\n         SPACE\n*              ALL INPUT TO IKJEHDEF MUST BE BELOW THE LINE\n         MVC   DSNAME24(46),DSNAME\n         LA    R15,MYIOPL24\n         USING IOPL,R15\n         LA    R14,MYIOPL\n         MVC   IOPLUPT(4),IOPLUPT-IOPL(R14)\n         MVC   IOPLECT(4),IOPLECT-IOPL(R14)\n         LA    R0,MYECB24\n         ST    R0,IOPLECB\n         XC    MYECB24,MYECB24\n         LA    R14,MYDFPB\n         ST    R14,IOPLIOPB\n         USING DFPB,R14\n         XC    0(20,R14),0(R14)\n         LA    R0,DSNAME24\n         ST    R0,DFPBDSN\n         OI    DFPBCODE,X'04'      SEARCH CAT AND PROMPT IF MULTI\n         MVC   DFPBPSCB,CPPLPSCB\n*        MVI   DFPBCNTL,X'20'      PREFIX THE DSNAME\n         DROP  R14                 DFPB\n         DROP  R15                 IOPL\n         SPACE\n         LR    R1,R15              POINT TO IOPL\n         LA    R13,SAVE24          POINT TO SAVEAREA BELOW THE LINE\n         L     R15,16              CVTPTR\n         TM    736(R15),X'80'      IF HI ORDER BIT NOT ON\n         BNO   EHDEFLNK               THEN DO LINK, NOT CALL\n         L     R15,736(,R15)       CVTEHDEF\n         BALR  R14,R15             CALL IKJEHDEF\n         B     EHDEFEXT            SKIP AROUND LINK\nEHDEFLNK EQU   *\n         LINK  EP=IKJEHDEF,SF=(E,LINKAREA)\nEHDEFEXT EQU   *\n         SPACE\n         LR    R13,R9              RESTORE SAVEARE POINTER\n         B     DEFCODE(R15)\nDEFCODE  B     DEF00               SUCCESS\n         B     NEXTD12              MSG ALREADY ISSUED\n         B     DEF08               INVALID NAME GT 44\n         B     NEXTD12              MSG ALREADY ISSUED\n         B     DEF16               NOT IN CATALOG\n         B     DEF20               NOT IN CATALOG\n         B     DEF24               IMPOSSIBLE\n         B     DEF28               COMMAND SYSTEM ERROR\n         B     DEF32               IMPOSSIBLE\n         B     DEF36               ?\nDEF08    EQU   *\nDEF16    EQU   *\n         B     DEF24\nDEF20    EQU   *\nLOCERR   EQU   *\n         MVC   MSGWK(L'MSG02),MSG02\n         LA    R15,MSGWK+L'MSG02\n         LA    R14,DSNAME\n         LH    R1,0(,R14)\n         BCTR  R1,0\n         B     *+10\n         MVC   MSGWK+L'MSG02(0),2(R14)\n         EX    R1,*-6\n         LA    R15,1(R1,R15)\n         MVC   0(L'MSG02A,R15),MSG02A\n         LA    R0,L'MSG02+L'MSG02A+1(,R1)\n         LA    R1,MSGWK\n         BAL   R14,PUTMSG\n         B     NEXTD12\nDEF24    EQU   *\nDEF28    EQU   *\nDEF32    EQU   *\nDEF36    EQU   *\n         LA    R1,MSG03\n         LA    R0,L'MSG03\n         BAL   R14,PUTMSG\nNEXTD12  MVI   RETCODE+1,12\n         B     NEXTDSN\n         SPACE\nDEF00    MVC   DSNAME(46),DSNAME24\nDEFX     EQU   *\n         SPACE\n************************************************************\n*                                                          *\n*        ALLOCATE THE DATASET                              *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R1,MYDAPL\n         USING DAPL,R1\n         MVC   DAPLUPT(4),CPPLUPT\n         MVC   DAPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,DAPLECB\n         MVC   DAPLPSCB(4),CPPLPSCB\n         LA    R15,MYDAPB\n         ST    R15,DAPLDAPB\n         DROP  R1                  DAPL\n         USING DAPB08,R15\n         XC    0(84,R15),0(R15)\n         MVI   DA08CD+1,X'08'\n         LA    R0,DSNAME\n         ST    R0,DA08PDSN\n         MVC   DA08DDN(8),=CL8' '\n         MVC   DA08UNIT,=CL8' '\n         MVC   DA08SER,=CL8' '\n         MVC   DA08MNM,=CL8' '\n         MVC   DA08PSWD,=CL8' '\n         MVI   DA08DSP1,DA08SHR\n         MVI   DA08DPS2,DA08KEEP\n         MVI   DA08DPS3,DA08KEP\n         TM    14(R6),X'80'        MEMBER SPECIFIED?\n         BZ    MEMBX               NO - BRANCH\n         LH    R1,12(,R6)          GET LENGTH OF MEMBER\n         STH   R1,MEMLEN\n         BCTR  R1,0                MINUS 1 FOR EX\n         L     R14,8(,R6)          GET ADDRESS OF MEMBER NAME\n         B     *+10\n         MVC   DA08MNM(0),0(R14)   MOVE MEMBER NAME\n         EX    R1,*-6\n         MVC   MEMNAME,DA08MNM\nMEMBX    EQU   *\n         TM    22(R6),X'80'        PASSWORD SPECIFIED?\n         BZ    PASSX               NO - BRANCH\n         LH    R1,20(,R6)          GET LENGTH OF PSWD\n         BCTR  R1,0                MINUS 1 FOR EX\n         L     R14,16(,R6)         GET ADDRESS OF PSWD\n         B     *+10\n         MVC   DA08PSWD(0),0(R14)  MOVE PSWD\n         EX    R1,*-6\nPASSX    EQU   *\n         LA    R1,MYDAPL\n         SPACE\n         BAL   R14,CALLDAIR\n         LTR   R15,R15\n         BZ    OKDAIR\n         BAL   R14,DAIRFAIL\n         B     NEXTD12\nOKDAIR   EQU   *\n         OI    STATUS,X'40'        TELL CLEANUP TO FREE IT\n         LA    R15,MYDAPB\n         MVC   DDSAVE,DA08DDN\n         TM    DA08DSO,X'40'       IS DSORG SEQUENTIAL?\n         BO    OKDSORG             YES - BRANCH\n         TM    DA08DSO,X'02'       IS DSORG PARTITIONED?\n         BO    OKDSORGP            YES, BRANCH\n*\n*              DSORG IS NEITHER PS NOR PO\n*              ISAM=X'80' DA=X'20' VSAM=X'00' NONE=X'00'\n*\nERRDSORG LA    R1,MSG06\n         LA    R0,L'MSG06\n         BAL   R14,PUTMSG\n         B     QUITD12\nOKDSORGP EQU   *\n         CLC   DA08MNM,=CL8' '     WAS MEMBER SPECIFIED?\n         BNE   OKDSORG             YES - BRANCH\n         LA    R1,MSG07\n         LA    R0,L'MSG07\n         BAL   R14,PUTMSG\n         B     NEXTD12\nOKDSORG  EQU   *\n         DROP  R15                 DAPB08\n         SPACE\n************************************************************\n*                                                          *\n*        CHECK FORMAT-1 DSCB FOR EMPTY DATA SET            *\n*                                                          *\n************************************************************\n         SPACE\n         L     R1,16               CVTPTR\n         L     R1,0(,R1)           TCB WORDS\n         L     R1,4(,R1)           CURRENT TCB\n         L     R1,12(,R1)          TIOT\n         LA    R1,24(,R1)          TOIENTRY\nDDLOOP   CLI   0(R1),0             END OF TIOT\n         BE    QUITDSN             YES, BRANCH (NEVER HAPPENS)\n         CLC   4(8,R1),DDSAVE      DOES DDNAME MATCH\n         BE    DDFOUND\n         SLR   R15,R15\n         IC    R15,0(,R1)\n         LA    R1,0(R15,R1)\n         B     DDLOOP\nDDFOUND  L     R15,16(,R1)         TIOEFSRT-1\n         N     R15,=A(X'00FFFFFF') CLEAR HIGH 8 BITS\n         TM    18(R15),X'20'       DIRECT ACCESS DEVICE?\n         BZ    OBTX                NO, BYPASS OBTAIN\n         MVC   VOLSER,28(R15)      UCBVOLI\nOBTDSCB  LA    R1,OBTAINW\n         MVC   0(OBTAINL,R1),OBTAIN\n         LA    R0,DSNAME+2         DSN FOR OBTAIN\n         ST    R0,4(,R1)\n         LA    R0,VOLSER           VOLUME FOR OBTAIN\n         ST    R0,8(,R1)\n         LA    R0,MYDSCB           ANSWER AREA FOR OBTAIN\n         ST    R0,12(,R1)\n         OBTAIN (1),EADSCB=OK\n         LTR   R15,R15             WAS OBTAIN SUCCESSFUL\n         BZ    OKDSCB              YES, BRANCH\n         SPACE\n*               OBTAIN HAS FAILED. HOW CAN THAT HAPPEN WHEN\n*               DYNAMIC ALLOCATION WAS SUCCESSFUL? ONE WAY IT\n*               CAN HAPPEN IS IF THE DSNAME IS AN ALIAS ENTRY\n*               IN A VSAM CATALOG.  IF IT IS, A 'LOCATE' WILL\n*               PUT THE TRUE NAME IN THE DSNAME FIELD, SO NOW\n*               WE ISSUE A LOCATE, AND TRY THE OBTAIN AGAIN.\n         SPACE\n         TM    STATUS,X'08'        HAS LOCATE BEEN TRIED ALREADY?\n         BZ    ALIAS               NO, GO TRY IT\nERROBT   LA    R1,MSG09            UNABLE TO OBTAIN DSCB\n         LA    R0,L'MSG09\n         BAL   R14,PUTMSG\n         MVI   RETCODE+1,12\n         B     QUITDSN\nALIAS    OI    STATUS,X'08'        TRIP THE SWITCH\n         LA    R1,LOCATEW\n         MVC   0(LOCATEL,R1),LOCATE\n         LA    R0,DSNAME+2         DSNAME FOR LOCATE\n         ST    R0,4(,R1)\n         LA    R0,LOCBUF           ANSWER AREA FOR LOCATE\n         ST    R0,12(,R1)\n         LOCATE (1)\n         LTR   15,15               WAS LOCATE SUCCESSFUL?\n         BZ    OBTDSCB             YES, GO OBTAIN AGAIN\n         B     ERROBT              NO, ISSUE MESSAGE\n         SPACE\nOKDSCB   NI    STATUS,255-X'08'    TURN OFF LOCATE SWITCH\n         TM    MYDSCB-44+X'52',X'42' DSORG = PS OR PO\n         BZ    ERRDSORG\n*        TM    MYDSCB-44+X'54',X'C0' RECFM = U\n*        BO    ERRRECFM\n*        CLC   MYDSCB-44+X'62'(3),=X'000000' CHECK DS1LSTAR\n*        BE    EMPTYDS             BRANCH IF EMPTY DATA SET\nOBTX     EQU   *\nFILESPEC EQU   *\n         SPACE\n************************************************************\n*                                                          *\n*        SET UP THE DCB                                    *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R4,DYNDCBW\n         USING IHADCB,R4\n         MVC   0(DYNDCBL,R4),DYNDCB\n         MVC   DCBDDNAM(8),DDSAVE\n         SPACE\n         LA    R5,DYNDCBEW\n         USING DCBE,R5\n         MVC   0(DYNDCBEL,R5),DYNDCBE\n         ST    R5,DCBDCBE\n         SPACE\n         LA    R15,GET6E\n         ST    R15,DCBEEODA\n         SPACE\n         LA    R15,DYNSYNAD\n         ST    R15,DCBESYNA\n         SPACE\n         LA    R15,DYNEXLST\n         IC    R0,DCBEXLSA-1\n         ST    R15,DCBEXLSA-1      EXLST=DYNEXLST\n         STC   R0,DCBEXLSA-1\n         LA    R1,OPENEXIT         EXIT BELOW THE LINE\n         MVC   0(GLUELEN,R1),GLUE   WILL CONTAIN GLUE\n         ST    R1,0(,R15)          STORE IN 1ST EXLST WORD\n         MVI   0(R15),X'05'        MARK TYPE OF EXIT\n         LA    R0,DYNOPENX         EXIT ABOVE THE LINE\n         ST    R0,OPENEXAD         SAVE ITS ADDRESS\n         OI    OPENEXAD,X'80'      MAKE IT RUN IN31-BIT MODE\n         SPACE\n         LA    R1,ABENDXIT         EXIT BELOW THE LINE\n         MVC   0(GLUELEN,R1),GLUE   WILL CONTAIN GLUE\n         ST    R1,4(,R15)          STORE IN 2ND EXLST WORD\n         MVI   4(R15),128+X'11'    OPEN ABEND EXIT (MVS)\n         LA    R0,DYNABEND         EXIT ABOVE THE LINE\n         ST    R0,ABENDXAD         SAVE ITS ADDRESS\n         OI    ABENDXAD,X'80'      MAKE IT RUN IN31-BIT MODE\n         SPACE\n         OI    STATUS,X'80'        TELL CLEANUP TO CLOSE DCB\n         MVC   OPEND(OPEN31L),OPEN31\n         SPACE\n         OPEN  ((R4),INPUT),MODE=31,MF=(E,OPEND)\n         SPACE\n*        TM    DCBOFLGS,X'10'\n*        TM    DCBEFLG1,DCBEOPEN+DCBEMD31\n         TM    DCBEFLG1,DCBEOPEN\n         BO    OKOPEN\n         LA    R1,MSG08\n         LA    R0,L'MSG08\n         TM    STATUS,X'10'        MEMBER NOT FOUND?\n         BO    DYNOPENM            YES, BRANCH\n         LA    R1,MSG04\n         LA    R0,L'MSG04\nDYNOPENM BAL   R14,PUTMSG\n         B     QUITD12\n         SPACE\nDYNOPENX BSM   0,R14\n         SPACE\nDYNABEND L     R8,0(,R1)           GET COMPLETION CODE\n         N     R8,=A(X'FFF0FF00')\n         CL    R8,=A(X'01301800')  IS IT AN 013-18 ABEND\n         BE    DYNABENY            YES, BRANCH\n         MVI   4(R1),0             NO, ABNORMALLY TERMINATE\n         BSM   0,R14\nDYNABENY OI    STATUS,X'10'        INDICATE MEMBER NOT FOUND\n         MVI   3(R1),4             IGNORE THE ABEND\n         BSM   0,R14\n         SPACE\nOKOPEN   EQU   *\n         MVI   GOTEOD,0\n*        MVC   SHA1PB(28),SHA1PI   SET UP PARAMETER BLOCK FOR SHA-1\n         MVC   SHA2PB(40),SHA2PI   SET UP PARAMETER BLOCK FOR SHA-256\n         LA    R0,64\n         ST    R0,I64\n         XC    GETREGS(8),GETREGS\n         XC    PUTREGS(8),PUTREGS\n         XC    FILESIZE(8),FILESIZE\n         SR    R6,R6\n         SPACE\nREADLOOP EQU   *\n         BAL   R14,GET64\n         C     R0,=F'64'\n         BNE   READLAST\n         LM    R14,R15,FILESIZE\n         ALR   R15,R0\n         BC    12,NOCARRY\n         AL    R14,=F'1'\nNOCARRY  STM   R14,R15,FILESIZE\n         LA    R14,IBUF            DATA ADDRESS\n         LR    R15,R0              DATA LENGTH 64\n*        LA    R0,1                FUNCTION CODE 1, SHA-1\n         LA    R0,2                FUNCTION CODE 2, SHA-256\n         LA    R1,SHA2PB\nKLOOPI   EQU   *\n         KIMD  R2,R14              R2 NOT USED, R14 --> DATA, R15 = LEN\n         BNZ   KLOOPI              LOOP IF PARTIAL\n         B     READLOOP\n         SPACE\n*              R0 CONTAINS 0 TO 63 OR MOD(FILESIZE,64)\n*              THE LENGTH OF ANY REMAINING DATA IN IBUF AFTER\n*              HAVING PROCESSED THE FILE IN 64-BYTE CHUNKS.\nREADLAST EQU   *\n         LM    R14,R15,FILESIZE\n         ALR   R15,R0\n         BC    12,NOCARRYL\n         AL    R14,=F'1'\nNOCARRYL STM   R14,R15,FILESIZE\n         SLDL  R14,3               MULTIPLY BY 8, BYTES TO BITS\n*              A FILE OF 536,870,912 BYTES WILL HAVE HEX 100000000 BITS\n*              MAKING THE HIGH WORD OF THE MESSAGE BIT LENGTH NONZERO.\n*              THAT'S 5114 CYLINDERS ON A 3390, ABOUT HALF OF A 3390-9.\n*        STM   R14,R15,SHA2PB+20   MESSAGE BIT LENGTH FOR SHA-1\n         STM   R14,R15,SHA2PB+32   MESSAGE BIT LENGTH FIR SHA-256\n         LA    R14,IBUF            DATA ADDRESS\n         LR    R15,R0              DATA LENGTH < 64\n*        LA    R0,1                FUNCTION CODE 1, SHA-1\n         LA    R0,2                FUNCTION CODE 2, SHA-256\n         LA    R1,SHA2PB\nKLOOPL   EQU   *\n         KLMD  R2,R14              R2 NOT USED, R14 --> DATA, R15 = LEN\n         BNZ   KLOOPL              LOOP IF PARTIAL\n         B     DYNEOD\n         SPACE\n*         GET64 - READ UP TO 64 BYTES INTO IBUF, SET R0 TO COUNT\n         SPACE\nGET64    LM    R5,R6,GETREGS\n         LA    R15,IBUF\n         L     R0,I64\nGET6A    CR    R5,R6               IF END OF RECORD\n         BNL   GET6R                 THEN READ NEXT RECORD\n         MVC   0(1,R15),0(R5)      COPY ONE BYTE TO OBUF\n         LA    R15,1(,R15)         NEXT OBUF BYTE\n         LA    R5,1(,R5)           NEXT IBUF BYTE\n         BCT   R0,GET6A            DECREMENT R0 AND LOOP\n         L     R0,I64              SET RETURNED LENGTH\n         STM   R5,R6,GETREGS\n         BR    R14\nGET6R    STM   R14,R0,GETREGS+8\n         CLI   GOTEOD,0            IF WE ALREADY HIT EODAD\n         BNE   GET6E                 GO THERE AGAIN\n         GET   (R4)\n         LR    R5,R1\n         TM    DCBRECFM,X'C0'      RECFM U\n         BO    GET6U\n         TM    DCBRECFM,X'80'      RECFM F\n         BO    GET6F\nGET6V    LA    R0,4\n         LH    R6,0(,R5)           LENGTH+4 FROM RDW\n         CLI   OPTR,0              IF RDW KEYWORD\n         BNE   GET6W                  INCLUDE RDW\n         AR    R5,R0               POINT PAST RDW\n         SR    R6,R0               REDUCE LENGTH\nGET6W    AR    R6,R5               POINT TO END OF RECORD\n         B     GET6X\nGET6U    LH    R6,DCBLRECL\n         AR    R6,R5               POINT TO END OF RECORD\n         B     GET6X\nGET6F    LH    R6,DCBLRECL         GET LENGTH FROM LRECL\n         TM    DCBRECFM,X'10'      IF NOT BLOCKED\n         BO    *+8                   THEN\n         LH    R6,DCBBLKSI           USE BLKSIZE AS LENGTH\n         AR    R6,R5               POINT TO END OF RECORD\nGET6X    LM    R14,R0,GETREGS+8\n         B     GET6A\nGET6E    CLI   GOTEOD,0            WERE WE ALREADY HERE\n         BE    *+8                 NO\n         EX    R0,*                YES, SOC3 IF EOF TWICE\n         MVI   GOTEOD,1            THAT'S ONCE\n         L     R0,I64\n         S     R0,GETREGS+16       COMPUTE HOW MANY BYTES IN IBUF\n         XC    GETREGS(8),GETREGS\n         L     R14,GETREGS+8\n         BR    R14\n         SPACE\n*MPTYDS  MVC   MSGWK(21),=C'-- EMPTY DATA SET -- '\n*        LA    R15,MSGWK+21\n*        B     ADDDSN\nDYNEOD   EQU   *\n         LA    R1,SHA2PB\n*        LA    R0,20 FOR SHA-1\n         LA    R0,32 FOR SHA-256\n         LA    R15,MSGWK\n         BAL   R14,TOHEX\n         SPACE\n*        LA    R15,MSGWK+40 FOR SHA-1\n         LA    R15,MSGWK+64 FOR SHA-256\n         MVI   0(R15),C' '\n         MVI   1(R15),C'*'\n         LA    R15,2(,R15)\nADDDSN   LA    R14,DSNAME\n         LH    R1,0(,R14)\n         BCTR  R1,0\n         B     *+10\n         MVC   0(0,R15),2(R14)\n         EX    R1,*-6\n         LA    R15,1(R1,R15)       POINT PAST LAST BYTE\n*        TM    14(R6),X'80'        MEMBER SPECIFIED?\n         CLI   MEMLEN+1,0          MEMBER ALLOCATED?\n         BZ    MEMAX               NO - BRANCH\n         MVI   0(R15),C'('\n         LA    R15,1(,R15)\n*        LH    R1,12(,R6)          GET LENGTH OF MEMBER\n         LH    R1,MEMLEN           GET LENGTH OF MEMBER\n         BCTR  R1,0                MINUS 1 FOR EX\n*        L     R14,8(,R6)          GET ADDRESS OF MEMBER NAME\n         LA    R14,MEMNAME\n         B     *+10\n         MVC   0(0,R15),0(R14)     MOVE MEMBER NAME\n         EX    R1,*-6\n         LA    R15,1(R1,R15)       POINT PAST LAST BYTE\n         MVI   0(R15),C')'\n         LA    R15,1(,R15)\nMEMAX    EQU   *\n         LA    R1,MSGWK\n         LR    R0,R15              POINT PAST LAST BYTE\n         SR    R0,R1               COMPUTE MESSAGE LENGTH\n         CLI   LOWKW+1,1           IF 'LOWER' SPECIFIED\n         BNE   LOWX\n         LR    R14,R0\n         BCTR  R14,0                  GET LENGTH MINUS 1\n         B     *+10\n         TR    MSGWK(0),LOWTABLE      TRANSLATE TO LOWER CASE\n         EX    R14,*-6\nLOWX     EQU   *\n         ST    R0,MSGL\n         CLI   BRIEFKW+1,1         BRIEF, JUST THE HASH\n         BNE   *+8\n*        LA    R0,40               FOR SHA-1\n         LA    R0,64               FOR SHA-256\n         CLI   MULTIKW+1,1         MULTIPLE LINES, DSNAME SEPARATE\n         BNE   *+8\n*        LA    R0,40               FOR SHA-1\n         LA    R0,64               FOR SHA-256\n         LA    R1,MSGWK\n         BAL   R14,PUTLINE\n         CLI   MULTIKW+1,1         MULTIPLE LINES\n         BNE   MSGDONE\n         LA    R0,MSGWK\n         A     R0,MSGL\n*        LA    R1,MSGWK+40         FOR SHA-1\n         LA    R1,MSGWK+64         FOR SHA-256\n*        LA    R1,2(,R1)           POINT PAST SPACE AND '*'\n         SR    R0,R1               COMPUTE MESSAGE LENGTH\n         BAL   R14,PUTLINE         DISPLAY DSNAME ONLY\nMSGDONE  B     QUITDSN\n         SPACE\nQUITD12  MVI   RETCODE+1,12\n         SPACE\nQUITDSN  TM    STATUS,X'80'\n         BZ    NOCLOSE\n         LA    R5,DYNDCBEW\n*        TM    DCBOFLGS,X'10'      IS IT OPEN?\n         TM    DCBEFLG1,DCBEOPEN\n         BZ    NOCLOSE             NO, BRANCH\n         MVC   CLOSED(CLOSE31L),CLOSE31\n         CLOSE ((R4)),MODE=31,MF=(E,CLOSED)\n         NI    STATUS,255-X'80'    CLOSED\n         DROP  R4                  IHADCB\nNOCLOSE  EQU   *\n         TM    STATUS,X'40'        FREE REQUIRED?\n         BZ    NOFREE\n         LA    R1,MYDAPL\n         LA    R15,MYDAPB\n         USING DAPB18,R15\n         XC    0(40,R15),0(R15)\n         MVI   DA18CD+1,X'18'\n         MVC   DA18DDN,DDSAVE\n         MVC   DA18MNM(8),=CL8' '\n         MVC   DA18SCLS(2),=CL8' '\n         BAL   R14,CALLDAIR        UNALLOCATE\n         NI    STATUS,255-X'40'    UNALLOCATED\n         DROP  R15                 DAPB18\nNOFREE   EQU   *\n         B     NEXTDSN\n         SPACE\nDONE     TM    MYPUTLEP,X'80'     WAS PUTLINE LOADED?\n         BO    NODELETE           NO - USED CVTPUTL - BRANCH\n         LA    R0,=CL8'IKJPUTL '\n         DELETE EPLOC=(0)\nNODELETE EQU   *\n         SPACE\n         IKJRLSA MYANS\n         SPACE\n         CLI   RETCODE+1,0         IS RETCODE ZERO?\n         BZ    STACKDX             YES, BRANCH\n         MVC   MYSTPB(STACKDL),STACKD\n         SPACE\n         STACK DELETE=ALL,PARM=MYSTPB,MF=(E,MYIOPL)\n         SPACE\n         TCLEARQ\nSTACKDX  EQU   *\n         SPACE\n         LH    R15,RETCODE\n         B     EXIT\n         SPACE\n************************************************************\n*                                                          *\n*         CALL IKJDAIR SERVICE ROUTINE                     *\n*                                                          *\n************************************************************\n          SPACE\nCALLDAIR ST    R14,DAIRREGS\n         L     R15,16\n         TM    732(R15),X'80'     CVTDAIR\n         BNO   DAIRLINK\n         L     R15,732(,R15)\n         BALR  R14,R15\n         B     DAIRFINI\nDAIRLINK EQU   *\n         LINK  EP=IKJDAIR,SF=(E,LINKAREA)\nDAIRFINI L     R14,DAIRREGS\n         BR    R14\n         SPACE\n************************************************************\n*                                                          *\n*        DYNAMIC ALLOCATION FAILURE ROUTINE                *\n*                                                          *\n************************************************************\n         SPACE\nDAIRFAIL ST    R14,MYDFREGS\n         LA    R1,MYDFPARM\n         USING DFDSECTD,R1\n         ST    R15,MYDFRC\n         LA    R15,MYDFRC\n         ST    R15,DFRCP\n         LA    R15,MYDAPL\n         ST    R15,DFDAPLP\n         SLR   R15,R15\n         ST    R15,MYJEFF02\n         LA    R15,MYJEFF02\n         ST    R15,DFJEFF02\n         LA    R15,DFDAIR\n         STH   R15,MYDFID\n         LA    R15,MYDFID\n         ST    R15,DFIDP\n         SLR   R15,R15\n         ST    R15,DFCPPLP\n         LINK  EP=IKJEFF18,SF=(E,LINKAREA)\n         L     R15,MYDFRC\n         DROP  R1                  DFDSECTD\n         L     R14,MYDFREGS\n         BR    R14\n         SPACE\n************************************************************\n*                                                          *\n*        PUTMSG ROUTINE                                    *\n*                                                          *\n************************************************************\n         SPACE\nPUTMSG   STM   R14,R1,PUTLINS\n         XC    MYOLD(8),MYOLD\n         XC    MYSEG1(4),MYSEG1\n         MVC   MYPTPB(12),MODLPTPM\n         LA    R14,1               NO. OF MESSAGE SEGMENTS\n         ST    R14,MYOLD\n         LA    R14,MYSEG1          POINT TO 1ST SEGMENT\n         ST    R14,MYOLD+4\n         LR    R14,R0              LENGTH IN R0\n         LA    R14,4(,R14)         ADD 4\n         LA    R15,MYSEG1+4\n         CLC   0(3,R1),=C'IKJ'     IS DATA PRECEEDED BY MESSAGE ID?\n         BE    *+16                YES - BRANCH\n         LA    R14,1(,R14)         ADD 1 TO LENGTH\n         MVI   0(R15),C' '         INSERT LEADING BLANK\n         LA    R15,1(,R15)         BUMP POINTER\n         STH   R14,MYSEG1\n         LR    R14,R0\n         BCTR  R14,0\n         B     *+10\n         MVC   0(0,R15),0(R1)      MOVE MESSAGE IN\n         EX    R14,*-6\n         L     R15,MYPUTLEP\n         SPACE\n         PUTLINE PARM=MYPTPB,OUTPUT=(MYOLD),ENTRY=(15),MF=(E,MYIOPL)\n         SPACE\n         LM    R14,R1,PUTLINS\n         BR    R14\n         SPACE\n************************************************************\n*                                                          *\n*        PUTLINE ROUTINE                                   *\n*                                                          *\n************************************************************\n         SPACE\nPUTLINE  STM   R14,R1,PUTLINS\n         XC    MYSEG1(4),MYSEG1\n         MVC   MYPTPB(12),MODLPTPB\n         LR    R14,R0              LENGTH IN R0\n         LA    R14,4(,R14)         ADD 4\n         STH   R14,MYSEG1\n         LR    R14,R0\n         BCTR  R14,0\n         B     *+10\n         MVC   MYSEG1+4(0),0(R1)   MOVE TEXT IN\n         EX    R14,*-6\n         LA    R1,MYIOPL\n         L     R15,MYPUTLEP\n         SPACE\n         PUTLINE PARM=MYPTPB,OUTPUT=(MYSEG1,DATA),ENTRY=(15),MF=(E,(1))\n         SPACE\n         LM    R14,R1,PUTLINS\n         BR    R14\n         SPACE 1\n*RRRECFM LA    R1,MSGRECFM\n*        LA    R0,L'MSGRECFM\n*        BAL   R14,PUTMSG\n*        B     QUITD12\n         SPACE\nTOHEX    MVC   1(1,R15),0(R1)\n         UNPK  0(3,R15),1(2,R15)\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)\n         LA    R1,1(,R1)\n         BCT   R0,TOHEX\n         MVI   0(R15),C' '\n         BR    R14\n         SPACE\nEXIT     LR    R2,R15              SAVE R15\n         LR    R1,R10\n         L     R0,@SIZE24\n         FREEMAIN R,A=(1),LV=(0)\n         SPACE\n         LR    R1,R13\n         L     R0,@SIZE31\n         L     13,4(,13)\n         FREEMAIN RU,A=(1),LV=(0),SP=1\n         LR    R15,R2              RESTORE R15\n         LM    0,12,20(13)\n         L     14,12(,13)\n         BR    14\n         SPACE\n************************************************************\n*                                                          *\n*        SYNAD EXIT                                        *\n*                                                          *\n************************************************************\n         SPACE\n*        THIS ROUTINE IS ENTERED DURING THE 'GET' MACRO\n*        IF AN I/O ERROR OCCURS.\n         SPACE\nDYNSYNAD EQU   *\n         SYNADAF ACSMETH=QSAM\n         MVC   SYNADMSG(78),50(R1)\n         MVI   SYNADSW,X'FF'\n         SYNADRLS\n         BR    R14\n         SPACE\n************************************************************\n*                                                          *\n*        GLUE FOR DCB EXITS                                *\n*                                                          *\n************************************************************\n         SPACE\n*        THESE 2 INSTRUCTIONS ARE COPIED TO ABENDXIT, BELOW THE LINE,\n*        AND RUN THERE, NOT HERE. WHEN ABENDXIT IS ENTERED,\n*        R15 CONTAINS THE ENTRY ADDRESS, THE ADDRESS OF ABENDXIT.\n*        THEN USING R15 AS A BASE REGISTER, IT LOADS R15 FROM ABENDXAD,\n*        WHICH CONTAINS THE ADDRESS OF DYNABEND ABOVE THE LINE,\n*        WITH THE HIGH-ORDER BIT SET TO 1. THEN IT USES BSM TO\n*        BRANCH TO DYNABEND IN 31-BIT MODE. THE ROUTINE AT\n*        DYNABEND SHOULD RETURN USING 'BSM 0,R14'.\n*\nGLUE     L     R15,ABENDXAD-ABENDXIT(,R15)\n         BSM   R14,R15  OLD MODE INTO R14 HI BIT, BRANCH TO R15 IN 31\nGLUELEN  EQU   *-GLUE\n         SPACE\n*        SINCE ABENDXAD-ABENDEXIT IS IDENTICAL TO OPENEXAD-OPENEXIT\n*        THE FOLLOWING IS NOT REALLY NEEDED.\n         SPACE\nGLUE2    L     R15,OPENEXAD-OPENEXIT(,R15)\n         BSM   R14,R15  OLD MODE INTO R14 HI BIT, BRANCH TO R15 IN 31\nGLUELEN2 EQU   *-GLUE2\n         SPACE\n************************************************************\n*                                                          *\n*        CONSTANTS                                         *\n*                                                          *\n************************************************************\n         SPACE\nMODLPTPM PUTLINE OUTPUT=(1,TERM,SINGLE,INFOR),                         X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=L\n         SPACE\nMODLPTPB PUTLINE OUTPUT=(1,TERM,SINGLE,DATA),                          X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=L\n         SPACE\n*        PRINT NOGEN\n         SPACE\nOPEN31   OPEN  (0,),MODE=31,MF=L\nOPEN31L  EQU   *-OPEN31\nCLOSE31  CLOSE (0,),MODE=31,MF=L\nCLOSE31L EQU   *-CLOSE31\n         SPACE\nDYNDCB   DCB   DDNAME=DYNAM,DSORG=PS,MACRF=(GL),                       +\n               EODAD=0,SYNAD=0,EROPT=ACC,DCBE=0\nDYNDCBL  EQU   *-DYNDCB\n         SPACE\nDYNDCBE  DCBE  RMODE31=BUFF,EODAD=1\nDYNDCBEL EQU   *-DYNDCBE\n         SPACE\n         PRINT GEN\n         SPACE\nOBTAIN   CAMLST SEARCH,2,3,4\nOBTAINL  EQU   *-OBTAIN\n         SPACE\nLOCATE   CAMLST NAME,2,,4\nLOCATEL  EQU   *-LOCATE\n         SPACE\nSTACKD   STACK DELETE=ALL,MF=L\nSTACKDL  EQU   *-STACKD\n         SPACE\n         AGO   .SKIP1\nSHA1PI   DC    X'67452301' H0\n         DC    X'EFCDAB89' H1\n         DC    X'98BADCFE' H2\n         DC    X'10325476' H3\n         DC    X'C3D2E1F0' H4\n         DC    X'00000000' MESSAGE BIT LENGTH HIGH\n         DC    X'00000000' MESSAGE BIT LENGTH LOW\n.SKIP1   ANOP\n         SPACE\nSHA2PI   DC    X'6A09E667' H0\n         DC    X'BB67AE85' H1\n         DC    X'3C6EF372' H2\n         DC    X'A54FF53A' H3\n         DC    X'510E527F' H4\n         DC    X'9B05688C' H5\n         DC    X'1F83D9AB' H6\n         DC    X'5BE0CD19' H7\n         DC    X'00000000' MESSAGE BIT LENGTH HIGH\n         DC    X'00000000' MESSAGE BIT LENGTH LOW\nHEXTAB   DC    C'0123456789ABCDEF'\nMSG01    DC    C'ERROR IN PARSE SERVICE ROUTINE'\nMSG02    DC    C'IKJ58503I DATA SET '\nMSG02A   DC    C' NOT IN CATALOG'\nMSG03    DC    C'ERROR IN DEFAULT SERVICE ROUTINE'\nMSG04    DC    C'UNABLE TO OPEN DATASET'\nMSG05    DC    C'IKJ58509I DATA SET NAME REQUIRED WHEN MEMBER IS SPECIF+\n               IED'\nMSG06    DC    C'ORGANIZATION OF DATA SET MUST BE PARTITIONED OR SEQUEN+\n               TIAL'\nMSG07    DC    C'DATA SET IS PARTITIONED, MEMBER NOT SPECIFIED'\nMSG08    DC    C'SPECIFIED MEMBER NOT FOUND IN DATASET'\nMSG09    DC    C'UNABLE TO OBTAIN DSCB FOR DATA SET'\nMSG14    DC    C'FILENAME '\nMSG14A   DC    C' INVALID, MORE THAN 8 CHARACTERS  '\nMSG14B   DC    C' IS NOT CURRENTLY ALLOCATED       '\nMSG14C   DC    C' NOT ALLOCATED TO A DASD DATA SET '\n*SGRECFM DC    C'RECORD FORMAT U NOT SUPPORTED'\n*MSGDAIR DC    C'UNABLE TO ALLOCATE'\nLOWTABLE DC    0D'0',256AL1(*-LOWTABLE)\n         ORG   LOWTABLE+C'A'\n         DC    X'818283848586878889'\n         ORG   LOWTABLE+C'J'\n         DC    X'919293949596979899'\n         ORG   LOWTABLE+C'S'\n         DC    X'A2A3A4A5A6A7A8A9'\n         ORG\n         LTORG\nPCLADDR  DC    0D'0'               END OF CSECT\n         SPACE\n************************************************************\n*                                                          *\n*        PARSE PARAMETERS                                  *\n*                                                          *\n************************************************************\n         SPACE\n         PRINT NOGEN\nSHASMPCL RMODE 31\nSHASMPCL IKJPARM\nDSN      IKJPOSIT DSNAME,LIST,PROMPT='DATA SET NAME'\nFILEKW   IKJKEYWD\n         IKJNAME 'FILE'\nQUICKW   IKJKEYWD\n         IKJNAME 'QUICK'\nRDWKW    IKJKEYWD\n         IKJNAME 'RDW'\nLOWKW    IKJKEYWD\n         IKJNAME 'LOWER'\nBRIEFKW  IKJKEYWD\n         IKJNAME 'BRIEF'\nMULTIKW  IKJKEYWD\n         IKJNAME 'MULTI'\n         IKJENDP\n         PRINT GEN\n         SPACE\n************************************************************\n*                                                          *\n*        DSECTS                                            *\n*                                                          *\n************************************************************\n         SPACE\n@DATA31  DSECT\n         DS    18F                 REGISTER SAVEAREA\nLINKAREA DS    2F\nMYPPL    DS    7F\nMYANS    DS    F\nMYECB    DS    F                  USED BY PUTLINE ROUTINE\nMYIOPL   DS    4F                 USED BY PUTLINE ROUTINE\nMYPTPB   DS    3F                 USED BY PUTLINE ROUTINE\nMYOLD    DS    2F                 USED BY PUTLINE ROUTINE\nMYSEG1   DS    2H,CL256           USED BY PUTLINE ROUTINE\nPUTLINS  DS    4F                 USED BY PUTLINE ROUTINE\nMYPUTLEP DS    F                  ADDRESS OF IKJPUTL\nMYSTPB   DS    0F                 5 WORDS USED BY STACK DELETE\nMYDAPL   DS    5F\nMYDAPB   DS    21F\nDSNAME   DS    H,CL44\nMEMLEN   DS    H\nMEMNAME  DS    CL8\nVOLSER   DS    CL6\nLOCATEW  DS    0F\nOBTAINW  DS    4F\nLOCBUF   DS    0D                  USES NEXT 265 BYTES\nMYDSCB   DS    CL140               96 BYTES OF DSCB, 5 BYTES CCHHR\nMSGWK    DS    CL128\nSTATUS   DS    X\nRETCODE  DS    H\nMYDFPARM DS    5F  USED BY DAIRFAIL\nMYDFREGS DS    F   USED BY DAIRFAIL\nMYDFRC   DS    F   USED BY DAIRFAIL\nMYJEFF02 DS    F   USED BY DAIRFAIL\nMYDFID   DS    H   USED BY DAIRFAIL\nDOUBLE   DS    D\nEIGHT    DS    CL8\nDDSAVE   DS    CL8\nDAIRREGS DS    F\nOPEND    DS    0F,(OPEN31L)X\nCLOSED   DS    0F,(CLOSE31L)X\nDYNDCBEW DS    0F,(DYNDCBEL)X\nKOUNT    DS    F\nKOUNTSP  DS    F\nSYNADSW  DS    F\nSYNADMSG DS    CL78\nDEVDATA  DS    2F\nGETREGS  DS    5F\nPUTREGS  DS    8F\nI64      DS    F\nDSL      DS    F\nMSGL     DS    F\nGOTEOD   DS    C\nOPTR     DS    C\n*SHA1PB  DS    0D,7F\nSHA2PB   DS    0D,10F\nFILESIZE DS    D\nIBUF     DS    CL80\n         DS    0D\n@DATA31L EQU   *-@DATA31\n         SPACE\n@DATA24  DSECT\nSAVE24   DS    18F                USED BY IKJEHDEF\nRDJFW    DS    F\nMYIOPL24 DS    4F                 USED BY IKJEHDEF\nMYECB24  DS    F\nMYDFPB   DS    5F\nDSNAME24 DS    H,CL44\nDYNDCBW  DS    0D,XL(DYNDCBL)\nDYNEXLST DS    2F\nOPENEXIT DS    0H,(GLUELEN)X\nOPENEXAD DS    F  X'80' + ADDRESS OF DYNOPENX\nABENDXIT DS    0H,(GLUELEN)X\nABENDXAD DS    F  X'80' + ADDRESS OF DYNABEND\nJFCB     DS    0F,CL176\nMYARL    DS    9F\nTBUF     DS    CL8\n         DS    0D\n@DATA24L EQU   *-@DATA24\n         SPACE\nIHADCB   DSECT\nDCBDCBE  DS    A\n         DS    28XL1\nDCBBFTEK DS    XL1\nDCBEODAD DS    AL3\nDCBEXLST DS    0A\nDCBRECFM DS    X\nDCBEXLSA DS    AL3\nDCBDDNAM DS    CL8\nDCBOFLGS DS    X\n         DS    7XL1\n         DS    X\nDCBSYNAD DS    AL3\nDCBBLKSI EQU   IHADCB+62,2\nDCBLRECL EQU   IHADCB+82,2\n         SPACE\n         IHADCBE\n         SPACE\nEFLG1    EQU   16\nEOPEN    EQU   X'80'\nEMD31    EQU   X'40'\nEEODA    EQU   40\nESYNA    EQU   44\n         SPACE\nXFLG1    EQU   DCBEFLG1-DCBE\nXOPEN    EQU   DCBEOPEN\nXMD31    EQU   DCBEMD31\nXEODA    EQU   DCBEEODA-DCBE\nXSYNA    EQU   DCBESYNA-DCBE\n         PRINT NOGEN\n         SPACE\n         IKJCPPL\n         SPACE 3\n         IKJPPL\n         SPACE\n         IKJDFPB\n         SPACE 2\n         IKJUPT\n         SPACE 2\n         IKJIOPL\n         SPACE 2\n         IKJDAPL\n         SPACE 2\n         IKJDAP08\n         SPACE 2\n         IKJDAP18\n         SPACE 2\n         IKJPSCB\n         SPACE 2\n         IKJEFFDF DFDSECT=YES\n         SPACE\n         IHAARL\n         SPACE\n         IHAARA\n         SPACE\n*        CVT   DSECT=YES\n         SPACE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SHA2SUM$": {"ttr": 6405, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x13\\x01\\x16\\x14?\\x01\\x16\\x14?#T\\x00\\x12\\x00\\x12\\x00\\x00\\xc3\\xc2\\xe3\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-05-22T00:00:00", "modifydate": "2016-05-22T23:54:13", "lines": 18, "newlines": 18, "modlines": 0, "user": "CBTUSER"}, "text": "//CBTUSER1 JOB (ACCT),'PGMR',NOTIFY=CBTUSER,\n//         MSGLEVEL=(1,1),MSGCLASS=H\n//* ASSEMBLE THE 31-BIT SHA2SUM TSO COMMAND\n//ASM    EXEC PGM=ASMA90,PARM=(OBJ,NODECK,TERM,NOXREF,BATCH,\n//             ASA,NODX,NOMX,NORX,RLD,NOUS,'PC(NOUHD)')\n//SYSPRINT DD  SYSOUT=*\n//SYSTERM  DD  SYSOUT=*\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//SYSLIN   DD  DSNAME=&&OBJ,DISP=(NEW,PASS),\n//             UNIT=SYSDA,SPACE=(TRK,(3,0)),\n//             DCB=(BLKSIZE=3200)\n//SYSIN    DD  DSN=CBTUSER.LIB.ASM(SHA2SUM),DISP=SHR\n//LKED   EXEC PGM=HEWLKED,PARM='LIST,MAP,RENT,REFR',\n//             COND=(0,NE)\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSNAME=&&OBJ,DISP=(OLD,DELETE)\n//SYSLMOD  DD  DSNAME=CBTUSER.LIB.LOAD(SHA2SUM),DISP=SHR\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(TRK,(10,0))\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SHA2SUM#": {"ttr": 6407, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x004\\x01\\x16\\x14?\\x01\\x16\\x14\\x8f\\x010\\x00\\x19\\x00\\x17\\x00\\x00\\xc3\\xc2\\xe3\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-05-22T00:00:00", "modifydate": "2016-05-27T01:30:34", "lines": 25, "newlines": 23, "modlines": 0, "user": "CBTUSER"}, "text": ")F FUNCTION -\n  THE SHA2SUM COMMAND DISPLAYS THE SHA-256 HASH OF DATA SETS.\n  IN DATA SETS WITH VARIABLE-LENGTH RECORDS THE RDW'S AND SDW'S ARE\n  NOT INCLUDED WHEN THE CHECKSUM IS COMPUTED UNLESS THE RDW KEYWORD\n  IS SPECIFIED.\n)X SYNTAX -\n         SHA2SUM  'DSLIST'  FILE  LOWER  RDW  BRIEF  MULTI  QUICK\n\n  REQUIRED - 'DSLIST'\n  DEFAULTS - NONE\n\n)O OPERANDS -\n  'DSLIST' - NAMES OF SEQUENTIAL DATA SETS OR MEMBERS OF PARTITIONED\n             DATA SETS. IF MORE THAN ONE, ENCLOSE LIST IN PARENTHESES.\n))FILE     - THE NAMES IN DSLIST ARE DDNAMES, NOT DSNAMES.\n))LOWER    - DISPLAY THE RESULTS IN LOWER CASE.\n))RDW      - INCLUDE RDW OR SDW IN VARIABLE LENGTH RECORDS.\n))BRIEF    - DISPLAY ONLY THE HASH, WITHOUT THE DATA SET NAME.\n))MULTI    - DISPLAY THE HASH AND DATA SET NAME ON SEPARATE LINES.\n))QUICK    - FOR UNQUOTED DSNAMES, BYPASS THE DEFAULT SERVICE ROUTINE.\n             SO FOR EXAMPLE, IF YOU SPECIFY THE NAME TEMP AND YOU\n             ONLY HAVE A DATA SET NAMED TEMP.DATA, IT WON'T BE FOUND\n             IF QUICK IS ALSO SPECIFIED. THE QUICK KEYWORD IS JUST\n             TO CUT OUT THE OVERHEAD OF LOOKING FOR EXTENSIONS AT\n             THE END OF THE SPECIFIED DATA SET NAME.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SHA224S": {"ttr": 6409, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x13\\x00\"\\x01\\x16\\x14\\x8f\\x01\\x19\\x07\\x7f\\x13(\\x05\\x90\\x05x\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.19", "flags": 0, "createdate": "2016-05-27T00:00:00", "modifydate": "2019-03-18T13:28:22", "lines": 1424, "newlines": 1400, "modlines": 0, "user": "UPDATED"}, "text": "         TITLE '   S H A 2 2 4 S  '\n************************************************************\n*                                                          *\n*        'SHA224S' TSO COMMAND (31-BIT)                    *\n*                                                          *\n************************************************************\n         SPACE\n*        WRITTEN DEC 27 2017 USING SHA2SUM AS A TEMPLATE.\n*        SHA2SUM WRITTEN MAY 22 2016 USING MD5SUM AS A TEMPLATE.\n*         NOTE: MD5SUM USED 'COUNT' (CBT FILE 300) AS A TEMPLATE.\n*        ATTRIBUTES. RE-ENTRANT.\n*        UPDATED MAY 27 2016 TO ADD BRIEF AND MULTI KEYWORDS.\n*        UPDATED AUG 28 2016 TO IGNORE DS1LSTAR WHICH IS 0 FOR PDSE\n*        UPDATED SEP  3 2016 TO SET RETURN CODE 12 IF ANY ERROR\n*        UPDATED DEC 27 2017 TO SUPPORT 8-BYTE PREFIX IN Z/OS V2R3\n*        UPDATED MAR 18 2019 TO SUPPORT EAV VOLUMES (SEE CHANGES BELOW)\n*\n*        THIS TSO COMMAND READS THE SPECIFIED SEQUENTIAL DATA SETS\n*        OR PDS MEMBERS AND DISPLAYS THE SHA-224 HASH FOR EACH.\n*        SHA = SECURE HASH ALGORITHM.\n*\n*        SYNTAX:\n*                SHA224S DSNAME\n*                SHA224S (DSNAME1 DSNAME2 ...)\n*        KEYWORDS:\n*                RDW - INCLUDE RDW'S\n*                LOWER - SHOW RESULTS IN LOWER CASE\n*                QUICK - DSNAME IS COMPLETE, NO IMPLIED EXTENSION\n*                FILE - DSNAME IS A DDNAME ALREADY ALLOCATED\n*                BRIEF - SHOW THE HASH ONLY, WITH NO DSNAME\n*                MULTI - SHOW THE HASH AND DSNAME ON SEPARATE LINES\n*\n*        IF AN UNQUALIFIED DATA SET NAME IS ENTERED, THE\n*        CATALOG MUST BE READ TWICE, ONCE TO APPEND A\n*        TRAILING QUALIFIER IF NECESSARY, AND AGAIN DURING\n*        ALLOCATION. THE USER CAN ELIMINATE THE FIRST BY USING\n*        THE FULLY QUALIFIED NAME, PREFIX AND ALL, IN QUOTES,\n*        OR BY ENTERING ALL BUT THE PREFIX, WITHOUT QUOTES,\n*        PLUS THE KEYWORD 'Q'. THE LATTER IS MUCH SIMPLER\n*        AND GIVES THE SAME PERFORMANCE IMPROVEMENT AS A\n*        FULLY QUALIFIED NAME.\n*\n*        THE 'FILE' KEYWORD IS USEFUL FOR READING TEMPORARY\n*        DATA SETS.  IT TELLS THE COMMAND TO TREAT THE FIRST\n*        OPERAND AS A FILENAME (DDNAME) INSTEAD OF A DSNAME.\n*        WHATEVER DATA SET IS CURRENTLY ALLOCATED TO THE\n*        FILENAME WILL BE READ (AND QUICKLY, BECAUSE\n*        THE COMMAND DOESNT HAVE TO ALLOCATE ANYTHING).\n*\n*        UNIX FILES THAT ARE PREALLOCATED TO A DDNAME CAN BE\n*        READ. FOR EXAMPLE:\n*         ALLOC FI(DD1) PATH('/ETC/MAGIC') (BUT USE PATH IN LOWER CASE)\n*         SHA224S DD1 FILE\n*        IF UNIX FILES ARE NOT GIVEN RECFM WHEN ALLOCATED\n*        THEY DEFAULT TO RECFM=U, WHICH IS GOOD FOR SHA224S.\n*        RECFM=F WOULD BE LIKELY TO INTRODUCE PADDING IN THE\n*        LAST RECORD, WHICH WOULD CHANGE THE SHA2SUM RESULT.\n*\n*        NOTE - IF A NON-EXISTENT MEMBER OF A PDS IS SPECIFIED,\n*        THE RESULTING 013-18 ABEND IS TRAPPED BY A DCB ABEND\n*        EXIT, BUT A MESSAGE IS ISSUED BY OPEN ANYWAY. THIS\n*        METHOD IS USED BECAUSE THE ADDITIONAL OVERHEAD\n*        OF ALLOCATING THE PDS AND DOING A 'BLDL' WOULD\n*        DEGRADE THE PERFORMANCE UNACCEPTABLY.\n*\n*        PROBLEMS FIXED:\n*        . IF THE SPECIFIED DDNAME (WITH 'FILE' KEYWORD) IS\n*          A MEMBER OF A PDS, ONLY THE PDS NAME WAS SHOWN.\n*          ADDED CODE TO GET MEMBER NAME FROM JFCBELNM.\n*        . IF THE SPECIFIED DDNAME (WITH 'FILE' KEYWORD) IS\n*          A UNIX PATH, ONLY \"...PATH=.SPECIFIED...\" IS SHOWN,\n*          THAT'S WHAT IS IN THE JFCB. ADDED ARL TO GET PATH.\n*\n*        IMPROVEMENTS NEEDED:\n*        . ALLOW PATH TO BE SPECIFIED AND ALLOCATE IT.\n*        . IF THE SPECIFIED DDNAME (WITH 'FILE' KEYWORD) IS\n*          A CONCATENATION, SHOW MORE THAN THE FIRST DSN OR PATH.\n*\n* CHNGE LOG: 02JUN92 - INCLUDED 'OBTAIN' MACRO IN THE SOURCE. WITH\n*                      MVS/XA 2.2.3, THE MACRO IS ONLY AVAILABLE IN\n*                      'SYS1.AMACLIB' (SOUNDS LIKE IBM IS TRYING TO\n*                      TELL US SOMETHING).  JIM MARSHALL         JDM1\n*\n* CHNGE LOG: 12OCT13 - MD5SUM COMMAND CREATED FROM SOURCE OF 'COUNT'.\n*                      RDW'S ARE NOT INCLUDED IN THE MD5 AT THIS TIME,\n*                      AS A RESULT, 2 FILES OF VARIABLE-LENGTH RECORDS,\n*                      ONE WITH 2 RECORDS \"AB\" AND \"CD\" AND THE OTHER\n*                      ONE WITH 2 RECORDS \"ABC' AND \"D\" WILL HAVE THE\n*                      SAME MD5 VALUE.\n*\n* CHNGE LOG: 11NOV13 - SUPPORT LIST OF DSNAMES, SHOW NAME AFTER MD5.\n*\n* CHNGE LOG: 12NOV13 - CONVERT TO 31-BIT.\n*\n* CHNGE LOG: 15NOV13 - ALLOW NON-DASD DEVTYPE INCLUDING UNIX AND DUMMY.\n*                      SHOW UNIX FILE NAME IF DDNAME ALLOCATED TO PATH.\n*                      SHOW MEMBER NAME IF DDNAME ALLOCATED TO MEMBER.\n*\n* CHNGE LOG: 13MAR19 - REVERSED THE CHANGE FROM JUNE 02, 1992 AND USED\n*                      THE ORIGINAL OBTAIN MACRO AGAIN. ADDITIONALLY\n*                      ADDED THE EADSCB=OK MACRO PARAMETER.\n*\n*--------------------------------------------------------------------\n*         MACRO                                                  JDM1\n*&NAME    OBTAIN &LIST,&DUMMY=                                   JDM1\n*         AIF   (T'&LIST EQ 'O').E1                              JDM1\n*&NAME    IHBINNRA &LIST                 LOAD REG 1              JDM1\n*         SVC   27                       ISSUE OBTAIN SVC        JDM1\n*         MEXIT                                                  JDM1\n*.E1      IHBERMAC 34                    LIST ADDR MISSING       JDM1\n*         MEND                                                   JDM1\n*--------------------------------------------------------------------\n*         INTERCEPT 'LINK' MACRO IMBEDDED IN STACK MACRO\n*         TO MAKE SF=(E,LINKAREA) THE DEFAULT.\n         MACRO\n&NAME    LINK  &EP=,&SF=(E,LINKAREA)\n&NAME    LA    15,&SF(2)\n         LA    0,*+8\n         B     *+12\n         DC    CL8'&EP'\n         ST    0,0(0,15)\n         SVC   6             ISSUE LINK SVC\n         MEND\n         SPACE\nSHA224S  START\nSHA224S  AMODE 31\nSHA224S  RMODE 31\n         USING *,R12,R11\n         B     @PROLOG-*(,R15)\n         DC    AL1(7),CL7'SHA224S'\n         DC    CL16' &SYSDATE &SYSTIME '\n@SIZE31  DC    0F'0',AL1(0),AL3(@DATA31L)\n@SIZE24  DC    0F'0',AL1(1),AL3(@DATA24L)\n@PROLOG  STM   14,12,12(13)\n         LR    R12,R15             BASE\n         LA    R15,1\n         LA    R11,4095(R15,R12)   BASE\n         LR    R2,R1\n         USING CPPL,R2\n         L     R0,@SIZE31\n         GETMAIN RU,LV=(0),SP=1,LOC=31\n         LR    R9,R1\n         USING @DATA31,R9\n         ST    13,4(,1)            CHAIN SAVEAREA\n         ST    1,8(,13)            CHAIN SAVEAREA\n         LR    13,1                NEW SAVEAREA\n         SPACE\n         L     R0,@SIZE24\n         GETMAIN R,LV=(0)\n         LR    R10,R1\n         USING @DATA24,R10\n         SPACE\n         MVI   STATUS,0\n         XC    LINKAREA(8),LINKAREA\n         SLR   R15,R15\n         STH   R15,RETCODE         SET RETCODE = 0\n         ST    R15,KOUNT\n         ST    R15,KOUNTSP\n         SPACE\n************************************************************\n*                                                          *\n*        SET UP IOPL FOR PUTLINE                           *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R15,MYIOPL\n         USING IOPL,R15\n         MVC   IOPLUPT(4),CPPLUPT\n         MVC   IOPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,IOPLECB\n         XC    MYECB,MYECB\n         LA    R0,MYPTPB\n         ST    R0,IOPLIOPB\n         DROP  R15                 IOPL\n         SPACE\n         L     R15,16              LOAD CVT POINTER\n         TM    444(R15),X'80'      IS PUTLINE LOADED? (VS2)\n         BNO   PUTLOAD             NO - BRANCH TO LOAD\n         L     R15,444(,R15)       YES - USE CVTPUTL\n         B     PUTLOADX            BRANCH AROUND LOAD\nPUTLOAD  LA    R0,=CL8'IKJPUTL '\n         LOAD  EPLOC=(0)\n         LR    R15,R0              GET ENTRY ADDRESS\n         LA    R15,0(,R15)         CLEAR HI BYTE FOR DELETE ROUTINE\nPUTLOADX ST    R15,MYPUTLEP        SAVE PUTLINE ENTRY ADDRESS\n         SPACE\n************************************************************\n*                                                          *\n*        SET UP PPL FOR PARSE                              *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R15,MYPPL\n         USING PPL,R15\n         MVC   PPLUPT(4),CPPLUPT\n         MVC   PPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,PPLECB\n         XC    MYECB,MYECB\n         L     R0,=A(SHASMPCL)\n*        LA    R0,PCLADDR\n         ST    R0,PPLPCL\n         LA    R0,MYANS\n         ST    R0,PPLANS\n         XC    MYANS(4),MYANS\n         MVC   PPLCBUF(4),CPPLCBUF\n         ST    R9,PPLUWA\n         DROP  R15                 PPL\n         SPACE 1\n************************************************************\n*                                                          *\n*        CALL THE PARSE SERVICE ROUTINE                    *\n*                                                          *\n************************************************************\n         SPACE\n         LR    R1,R15              POINT TO PPL\n*        CALLTSSR EP=IKJPARS\n         L     R15,16              CVTPTR\n         TM    524(R15),X'80'      IF HI ORDER BIT NOT ON\n         BNO   PARSELNK               THEN DO LINK, NOT CALL\n         L     R15,524(,R15)       CVTPARS\n         BALR  R14,R15             CALL IKJPARS\n         B     PARSEEXT            SKIP AROUND LINK\nPARSELNK EQU   *\n         LINK  EP=IKJPARS,SF=(E,LINKAREA)\nPARSEEXT EQU   *\n         SPACE 1\n         LTR   R15,R15\n         BZ    PARSEOK\n         LA    R1,MSG01\n         LA    R0,L'MSG01\n         BAL   R14,PUTMSG\n         LA    R15,12\n         B     EXIT\nPARSEOK  EQU   *\n         SPACE\n         L     R3,MYANS\n         USING IKJPARMD,R3\n         SPACE\n         MVC   OPTR,RDWKW+1\n         SPACE\n************************************************************\n*                                                          *\n*        GET THE FIRST OR NEXT DSN IN THE LIST             *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R6,DSN\n         ST    R6,DSL\n         B     FIRSTDSN\nNEXTDSN  L     R6,DSL\n         CLI   24(R6),X'FF'        END OF DSN LIST?\n         BE    DONE\n         L     R6,24(,R6)          POINT TO NEXT ENTRY\n         ST    R6,DSL\nFIRSTDSN SR    R0,R0\n         ST    R0,KOUNT\n         SPACE\n************************************************************\n*                                                          *\n*        QUALIFY THE DSNAME IF NECESSARY                   *\n*                                                          *\n************************************************************\n         SPACE\n         TM    6(R6),X'80'         IS DATASET NAME SPECIFIED?\n         BO    OKDSN               YES - BRANCH\n         LA    R1,MSG05            NO - JUST MEMBER NAME\n         LA    R0,L'MSG05\n         BAL   R14,PUTMSG\n         B     NEXTD12\nOKDSN    EQU   *\n         LA    R15,DSNAME+2\n         MVI   0(R15),C' '         BLANK THE DSNAME AREA\n         MVC   1(43,R15),0(R15)\n         SLR   R1,R1\n         STH   R1,DSNAME           ZERO DSNAME LENGTH\n         TM    6(R6),X'40'         IS DSN QUOTED?\n         BO    NOPREF              YES, SKIP PREFIXING\n         CLI   FILEKW+1,1          DSN TO BE TREATED AS DDNAME\n         BE    NOPREF              YES, SKIP PREFIXING\n         L     R14,CPPLUPT         POINT TO UPT\n         USING UPT,R14\n*         CHECK UPT FOR 8-BYTE PREFIX - Z/OS V2R3.\n         CLI   UPTPREFX,C'>'      IF PREFIX IS '>7BYTES' (8 BYTES)\n         BNE   PREF07                THEN\n         IC    R1,UPTPREFL+18        GET UPTPRF8L (SHOULD ALWAYS BE 8)\n         LTR   R1,R1                 IS IT ZERO\n         BZ    NOPREF                YES, SKIP PREFIXING\n         B     *+10\n         MVC   0(0,R15),UPTPREFX+17  COPY UPTPREF8\n         EX    R1,*-6              MOVE USERID TO DSNAME AREA\n         B     PREFDONE\nPREF07   EQU   *\n         IC    R1,UPTPREFL         GET LENGTH OF PREFIX\n         LTR   R1,R1               IS IT ZERO\n         BZ    NOPREF              YES, SKIP PREFIXING\n         B     *+10\n         MVC   0(0,R15),UPTPREFX\n         EX    R1,*-6              MOVE USERID TO DSNAME AREA\nPREFDONE EQU   *\n         DROP  R14                 UPT\n         LA    R15,0(R1,R15)       POINT PAST USERID\n         MVI   0(R15),C'.'         APPEND PERIOD\n         LA    R15,1(,R15)         POINT PAST PERIOD\n         LA    R1,1(,R1)           ADD 1 TO LENGTH\n         STH   R1,DSNAME           STORE LENGTH OF USERID PLUS 1\nNOPREF   EQU   *\n         LH    R1,4(,R6)           GET LENGTH\n         LR    R0,R1\n         AH    R0,DSNAME           ADD LENGTH OF PREFIX OR ZERO\n         STH   R0,DSNAME           SET COMBINED LENGTH\n         L     R14,0(,R6)          POINT TO DSN VALUE\n         BCTR  R1,0                LENGTH MINUS 1 FOR EX\n         B     *+10                BRANCH AROUND EXECUTED MVC\n         MVC   0(0,R15),0(R14)     (EXECUTED)\n         EX    R1,*-6              MOVE DSN TO DSNAME (AFTER PREFIX)\n         SPACE\n************************************************************\n*                                                          *\n*        IF 'FILE' KEYWORD IS SPECIFIED,                   *\n*        GET DSNAME FROM JFCB USING FILE NAME.             *\n*                                                          *\n************************************************************\n         SPACE\n         CLI   FILEKW+1,1          'FILE' SPECIFIED?\n         BNE   NOFILE              NO, BRANCH\n         CLI   DSNAME+1,8          IS LENGTH 8 OR LESS\n         BH    FILERR1             NO, BRANCH\n         DEVTYPE DSNAME+2,DEVDATA  GET DEVICE TYPE\n         LTR   R15,R15             WAS FILENAME VALID\n         BNZ   FILERR2             NO, BRANCH\n*        CLC   DEVDATA(8),=X'0000010300007FF8'\n*        BE    DEVOK\n*        TM    DEVDATA+2,X'20'     DIRECT ACCESS\n*        BZ    FILERR3             NO, BRANCH\nDEVOK    LA    R4,DYNDCBW\n         MVC   0(DYNDCBL,R4),DYNDCB\n         XC    DSNAME(2),DSNAME\n         XC    MEMLEN,MEMLEN\n         LA    R0,JFCB\n         LA    R1,DYNEXLST\n         ST    R0,0(,R1)\n         MVI   0(R1),X'07'\n         LA    R14,MYARL           ALLOCATION RETRIEVAL LIST\n         ST    R14,4(,R1)\n         MVI   4(R1),X'13'+X'80'\n         ST    R1,DCBEXLST-IHADCB(,R4)\n         USING ARL,R14\n         XC    0(36,R14),0(R14)\n         MVI   ARLLEN+1,36\n         MVC   ARLIDENT,=C'AR'\n         OI    ARLOPT1,ARLLANY+ARLUSS\n         MVC   40(8,R4),DSNAME+2   DCBDDNAM\n         MVC   DDSAVE,DSNAME+2\n         MVI   RDJFW,X'80'\n         RDJFCB ((R4)),MF=(E,RDJFW)\n         LA    R14,MYARL\n         L     R1,ARLAREA\n         LTR   R1,R1\n         BZ    NOARA\n         L     R0,ARLRTRVD\n         DROP  R14                 ARL\n         USING ARA,R1\nLOOPARA  TM    ARAFLG,ARAXINF\n         BZ    DONEARA\n         SR    R15,R15\n         IC    R15,ARAXINOF\n         SLL   R15,3\n         AR    R15,R1\n         USING ARAXINFO,R15\n         SR    R14,R14\n         ICM   R14,3,ARAPATHO      GET OFFSET TO PATH LEN\n         BZ    DONEARA\n         AR    R14,R15\n         DROP  R15                 ARAXINLN\n         SR    R15,R15\n         ICM   R15,3,0(R14)        GET ARAPATHLEN\n         CH    R15,=H'44'\n         BNH   *+8\n         LA    R15,44              JUST SHOW FIRST 44 FOR NOW\n         STH   R15,DSNAME\n         BCTR  R15,0\n         B     *+10\n         MVC   DSNAME+2(0),2(R14)  ARAPATHNAM\n         EX    R15,*-6\nDONEARA  LA    R14,MYARL           PREPARE FOR FREEMAIN\n         USING ARL,R14\n         SR    R15,R15             PREPARE FOR FREEMAIN\n         IC    R15,ARLPOOL\n         SR    R0,R0\n         ICM   R0,7,ARLRLEN\n         L     R1,ARLAREA\n         DROP  R14                 ARL\n         FREEMAIN RU,LV=(0),SP=(R15),A=(1)\nNOARA    CLC   DSNAME(2),=H'0'\n         BNE   FILESPEC\n         MVC   DSNAME+2(44),JFCB\n         LA    R1,DSNAME+45        LAST CHAR OF DSNAME\n         LA    R0,44               INITIAL LENGTH\nFILEA    CLI   0(R1),C' '          IS THIS LAST NONBLANK\n         BNE   FILEB               YES, BRANCH\n         BCTR  R1,0                BACK UP 1 CHARACTER\n         BCT   R0,FILEA            DECREMENT LENGTH AND BRANCH\nFILEB    STH   R0,DSNAME           STORE LENGTH OF DSNAME\n*        MVC   VOLUME(6),JFCB+118  GET VOLUME FROM JFCB\n         MVC   MEMNAME,JFCB+44     JFCBELNM IN IEFJFCBN\n         LA    R1,MEMNAME+7        LAST CHAR OF MEMBER NAME\n         LA    R0,8\nMEMA     CLI   0(R1),C' '\n         BNE   MEMB\n         BCTR  R1,0\n         BCT   R0,MEMA\nMEMB     STH   R0,MEMLEN\n         B     FILESPEC\nFILERR1  LA    R0,MSG14A\n         B     FILERR\nFILERR2  LA    R0,MSG14B\n         B     FILERR\nFILERR3  LA    R0,MSG14C\nFILERR   MVC   MSGWK(L'MSG14),MSG14\n         LA    R15,MSGWK+L'MSG14\n         LA    R14,DSNAME\n         LH    R1,0(,R14)\n         BCTR  R1,0\n         B     *+10\n         MVC   MSGWK+L'MSG14(0),2(R14)\n         EX    R1,*-6\n         LA    R15,1(R1,R15)\n         LR    R14,R0 POINT TO MSG14A, B, OR C\n         MVC   0(L'MSG14A,R15),0(R14)\n         LA    R0,L'MSG14+L'MSG14A+1(,R1)\n         LA    R1,MSGWK\n         BAL   R14,PUTMSG\n         B     QUITD12\nNOFILE   EQU   *\n         TM    6(R6),X'40'         IS IT QUOTED?\n         BO    DEFX                YES - SKIP DEFAULT SERVICE\n         CLI   QUICKW+1,1          QUICK SPECIFIED\n         BE    DEFX                YES, USER ENTERED ALL BUT PREFIX\n         SPACE\n************************************************************\n*                                                          *\n*        DEFAULT SERVICE ROUTINE TO GET QUALIFIERS         *\n*                                                          *\n************************************************************\n         SPACE\n*              ALL INPUT TO IKJEHDEF MUST BE BELOW THE LINE\n         MVC   DSNAME24(46),DSNAME\n         LA    R15,MYIOPL24\n         USING IOPL,R15\n         LA    R14,MYIOPL\n         MVC   IOPLUPT(4),IOPLUPT-IOPL(R14)\n         MVC   IOPLECT(4),IOPLECT-IOPL(R14)\n         LA    R0,MYECB24\n         ST    R0,IOPLECB\n         XC    MYECB24,MYECB24\n         LA    R14,MYDFPB\n         ST    R14,IOPLIOPB\n         USING DFPB,R14\n         XC    0(20,R14),0(R14)\n         LA    R0,DSNAME24\n         ST    R0,DFPBDSN\n         OI    DFPBCODE,X'04'      SEARCH CAT AND PROMPT IF MULTI\n         MVC   DFPBPSCB,CPPLPSCB\n*        MVI   DFPBCNTL,X'20'      PREFIX THE DSNAME\n         DROP  R14                 DFPB\n         DROP  R15                 IOPL\n         SPACE\n         LR    R1,R15              POINT TO IOPL\n         LA    R13,SAVE24          POINT TO SAVEAREA BELOW THE LINE\n         L     R15,16              CVTPTR\n         TM    736(R15),X'80'      IF HI ORDER BIT NOT ON\n         BNO   EHDEFLNK               THEN DO LINK, NOT CALL\n         L     R15,736(,R15)       CVTEHDEF\n         BALR  R14,R15             CALL IKJEHDEF\n         B     EHDEFEXT            SKIP AROUND LINK\nEHDEFLNK EQU   *\n         LINK  EP=IKJEHDEF,SF=(E,LINKAREA)\nEHDEFEXT EQU   *\n         SPACE\n         LR    R13,R9              RESTORE SAVEARE POINTER\n         B     DEFCODE(R15)\nDEFCODE  B     DEF00               SUCCESS\n         B     NEXTD12              MSG ALREADY ISSUED\n         B     DEF08               INVALID NAME GT 44\n         B     NEXTD12              MSG ALREADY ISSUED\n         B     DEF16               NOT IN CATALOG\n         B     DEF20               NOT IN CATALOG\n         B     DEF24               IMPOSSIBLE\n         B     DEF28               COMMAND SYSTEM ERROR\n         B     DEF32               IMPOSSIBLE\n         B     DEF36               ?\nDEF08    EQU   *\nDEF16    EQU   *\n         B     DEF24\nDEF20    EQU   *\nLOCERR   EQU   *\n         MVC   MSGWK(L'MSG02),MSG02\n         LA    R15,MSGWK+L'MSG02\n         LA    R14,DSNAME\n         LH    R1,0(,R14)\n         BCTR  R1,0\n         B     *+10\n         MVC   MSGWK+L'MSG02(0),2(R14)\n         EX    R1,*-6\n         LA    R15,1(R1,R15)\n         MVC   0(L'MSG02A,R15),MSG02A\n         LA    R0,L'MSG02+L'MSG02A+1(,R1)\n         LA    R1,MSGWK\n         BAL   R14,PUTMSG\n         B     NEXTD12\nDEF24    EQU   *\nDEF28    EQU   *\nDEF32    EQU   *\nDEF36    EQU   *\n         LA    R1,MSG03\n         LA    R0,L'MSG03\n         BAL   R14,PUTMSG\nNEXTD12  MVI   RETCODE+1,12\n         B     NEXTDSN\n         SPACE\nDEF00    MVC   DSNAME(46),DSNAME24\nDEFX     EQU   *\n         SPACE\n************************************************************\n*                                                          *\n*        ALLOCATE THE DATASET                              *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R1,MYDAPL\n         USING DAPL,R1\n         MVC   DAPLUPT(4),CPPLUPT\n         MVC   DAPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,DAPLECB\n         MVC   DAPLPSCB(4),CPPLPSCB\n         LA    R15,MYDAPB\n         ST    R15,DAPLDAPB\n         DROP  R1                  DAPL\n         USING DAPB08,R15\n         XC    0(84,R15),0(R15)\n         MVI   DA08CD+1,X'08'\n         LA    R0,DSNAME\n         ST    R0,DA08PDSN\n         MVC   DA08DDN(8),=CL8' '\n         MVC   DA08UNIT,=CL8' '\n         MVC   DA08SER,=CL8' '\n         MVC   DA08MNM,=CL8' '\n         MVC   DA08PSWD,=CL8' '\n         MVI   DA08DSP1,DA08SHR\n         MVI   DA08DPS2,DA08KEEP\n         MVI   DA08DPS3,DA08KEP\n         TM    14(R6),X'80'        MEMBER SPECIFIED?\n         BZ    MEMBX               NO - BRANCH\n         LH    R1,12(,R6)          GET LENGTH OF MEMBER\n         STH   R1,MEMLEN\n         BCTR  R1,0                MINUS 1 FOR EX\n         L     R14,8(,R6)          GET ADDRESS OF MEMBER NAME\n         B     *+10\n         MVC   DA08MNM(0),0(R14)   MOVE MEMBER NAME\n         EX    R1,*-6\n         MVC   MEMNAME,DA08MNM\nMEMBX    EQU   *\n         TM    22(R6),X'80'        PASSWORD SPECIFIED?\n         BZ    PASSX               NO - BRANCH\n         LH    R1,20(,R6)          GET LENGTH OF PSWD\n         BCTR  R1,0                MINUS 1 FOR EX\n         L     R14,16(,R6)         GET ADDRESS OF PSWD\n         B     *+10\n         MVC   DA08PSWD(0),0(R14)  MOVE PSWD\n         EX    R1,*-6\nPASSX    EQU   *\n         LA    R1,MYDAPL\n         SPACE\n         BAL   R14,CALLDAIR\n         LTR   R15,R15\n         BZ    OKDAIR\n         BAL   R14,DAIRFAIL\n         B     NEXTD12\nOKDAIR   EQU   *\n         OI    STATUS,X'40'        TELL CLEANUP TO FREE IT\n         LA    R15,MYDAPB\n         MVC   DDSAVE,DA08DDN\n         TM    DA08DSO,X'40'       IS DSORG SEQUENTIAL?\n         BO    OKDSORG             YES - BRANCH\n         TM    DA08DSO,X'02'       IS DSORG PARTITIONED?\n         BO    OKDSORGP            YES, BRANCH\n*\n*              DSORG IS NEITHER PS NOR PO\n*              ISAM=X'80' DA=X'20' VSAM=X'00' NONE=X'00'\n*\nERRDSORG LA    R1,MSG06\n         LA    R0,L'MSG06\n         BAL   R14,PUTMSG\n         B     QUITD12\nOKDSORGP EQU   *\n         CLC   DA08MNM,=CL8' '     WAS MEMBER SPECIFIED?\n         BNE   OKDSORG             YES - BRANCH\n         LA    R1,MSG07\n         LA    R0,L'MSG07\n         BAL   R14,PUTMSG\n         B     NEXTD12\nOKDSORG  EQU   *\n         DROP  R15                 DAPB08\n         SPACE\n************************************************************\n*                                                          *\n*        CHECK FORMAT-1 DSCB FOR EMPTY DATA SET            *\n*                                                          *\n************************************************************\n         SPACE\n         L     R1,16               CVTPTR\n         L     R1,0(,R1)           TCB WORDS\n         L     R1,4(,R1)           CURRENT TCB\n         L     R1,12(,R1)          TIOT\n         LA    R1,24(,R1)          TOIENTRY\nDDLOOP   CLI   0(R1),0             END OF TIOT\n         BE    QUITDSN             YES, BRANCH (NEVER HAPPENS)\n         CLC   4(8,R1),DDSAVE      DOES DDNAME MATCH\n         BE    DDFOUND\n         SLR   R15,R15\n         IC    R15,0(,R1)\n         LA    R1,0(R15,R1)\n         B     DDLOOP\nDDFOUND  L     R15,16(,R1)         TIOEFSRT-1\n         N     R15,=A(X'00FFFFFF') CLEAR HIGH 8 BITS\n         TM    18(R15),X'20'       DIRECT ACCESS DEVICE?\n         BZ    OBTX                NO, BYPASS OBTAIN\n         MVC   VOLSER,28(R15)      UCBVOLI\nOBTDSCB  LA    R1,OBTAINW\n         MVC   0(OBTAINL,R1),OBTAIN\n         LA    R0,DSNAME+2         DSN FOR OBTAIN\n         ST    R0,4(,R1)\n         LA    R0,VOLSER           VOLUME FOR OBTAIN\n         ST    R0,8(,R1)\n         LA    R0,MYDSCB           ANSWER AREA FOR OBTAIN\n         ST    R0,12(,R1)\n         OBTAIN (1),EADSCB=OK\n         LTR   R15,R15             WAS OBTAIN SUCCESSFUL\n         BZ    OKDSCB              YES, BRANCH\n         SPACE\n*               OBTAIN HAS FAILED. HOW CAN THAT HAPPEN WHEN\n*               DYNAMIC ALLOCATION WAS SUCCESSFUL? ONE WAY IT\n*               CAN HAPPEN IS IF THE DSNAME IS AN ALIAS ENTRY\n*               IN A VSAM CATALOG.  IF IT IS, A 'LOCATE' WILL\n*               PUT THE TRUE NAME IN THE DSNAME FIELD, SO NOW\n*               WE ISSUE A LOCATE, AND TRY THE OBTAIN AGAIN.\n         SPACE\n         TM    STATUS,X'08'        HAS LOCATE BEEN TRIED ALREADY?\n         BZ    ALIAS               NO, GO TRY IT\nERROBT   LA    R1,MSG09            UNABLE TO OBTAIN DSCB\n         LA    R0,L'MSG09\n         BAL   R14,PUTMSG\n         MVI   RETCODE+1,12\n         B     QUITDSN\nALIAS    OI    STATUS,X'08'        TRIP THE SWITCH\n         LA    R1,LOCATEW\n         MVC   0(LOCATEL,R1),LOCATE\n         LA    R0,DSNAME+2         DSNAME FOR LOCATE\n         ST    R0,4(,R1)\n         LA    R0,LOCBUF           ANSWER AREA FOR LOCATE\n         ST    R0,12(,R1)\n         LOCATE (1)\n         LTR   15,15               WAS LOCATE SUCCESSFUL?\n         BZ    OBTDSCB             YES, GO OBTAIN AGAIN\n         B     ERROBT              NO, ISSUE MESSAGE\n         SPACE\nOKDSCB   NI    STATUS,255-X'08'    TURN OFF LOCATE SWITCH\n         TM    MYDSCB-44+X'52',X'42' DSORG = PS OR PO\n         BZ    ERRDSORG\n*        TM    MYDSCB-44+X'54',X'C0' RECFM = U\n*        BO    ERRRECFM\n*        CLC   MYDSCB-44+X'62'(3),=X'000000' CHECK DS1LSTAR\n*        BE    EMPTYDS             BRANCH IF EMPTY DATA SET\nOBTX     EQU   *\nFILESPEC EQU   *\n         SPACE\n************************************************************\n*                                                          *\n*        SET UP THE DCB                                    *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R4,DYNDCBW\n         USING IHADCB,R4\n         MVC   0(DYNDCBL,R4),DYNDCB\n         MVC   DCBDDNAM(8),DDSAVE\n         SPACE\n         LA    R5,DYNDCBEW\n         USING DCBE,R5\n         MVC   0(DYNDCBEL,R5),DYNDCBE\n         ST    R5,DCBDCBE\n         SPACE\n         LA    R15,GET6E\n         ST    R15,DCBEEODA\n         SPACE\n         LA    R15,DYNSYNAD\n         ST    R15,DCBESYNA\n         SPACE\n         LA    R15,DYNEXLST\n         IC    R0,DCBEXLSA-1\n         ST    R15,DCBEXLSA-1      EXLST=DYNEXLST\n         STC   R0,DCBEXLSA-1\n         LA    R1,OPENEXIT         EXIT BELOW THE LINE\n         MVC   0(GLUELEN,R1),GLUE   WILL CONTAIN GLUE\n         ST    R1,0(,R15)          STORE IN 1ST EXLST WORD\n         MVI   0(R15),X'05'        MARK TYPE OF EXIT\n         LA    R0,DYNOPENX         EXIT ABOVE THE LINE\n         ST    R0,OPENEXAD         SAVE ITS ADDRESS\n         OI    OPENEXAD,X'80'      MAKE IT RUN IN31-BIT MODE\n         SPACE\n         LA    R1,ABENDXIT         EXIT BELOW THE LINE\n         MVC   0(GLUELEN,R1),GLUE   WILL CONTAIN GLUE\n         ST    R1,4(,R15)          STORE IN 2ND EXLST WORD\n         MVI   4(R15),128+X'11'    OPEN ABEND EXIT (MVS)\n         LA    R0,DYNABEND         EXIT ABOVE THE LINE\n         ST    R0,ABENDXAD         SAVE ITS ADDRESS\n         OI    ABENDXAD,X'80'      MAKE IT RUN IN31-BIT MODE\n         SPACE\n         OI    STATUS,X'80'        TELL CLEANUP TO CLOSE DCB\n         MVC   OPEND(OPEN31L),OPEN31\n         SPACE\n         OPEN  ((R4),INPUT),MODE=31,MF=(E,OPEND)\n         SPACE\n*        TM    DCBOFLGS,X'10'\n*        TM    DCBEFLG1,DCBEOPEN+DCBEMD31\n         TM    DCBEFLG1,DCBEOPEN\n         BO    OKOPEN\n         LA    R1,MSG08\n         LA    R0,L'MSG08\n         TM    STATUS,X'10'        MEMBER NOT FOUND?\n         BO    DYNOPENM            YES, BRANCH\n         LA    R1,MSG04\n         LA    R0,L'MSG04\nDYNOPENM BAL   R14,PUTMSG\n         B     QUITD12\n         SPACE\nDYNOPENX BSM   0,R14\n         SPACE\nDYNABEND L     R8,0(,R1)           GET COMPLETION CODE\n         N     R8,=A(X'FFF0FF00')\n         CL    R8,=A(X'01301800')  IS IT AN 013-18 ABEND\n         BE    DYNABENY            YES, BRANCH\n         MVI   4(R1),0             NO, ABNORMALLY TERMINATE\n         BSM   0,R14\nDYNABENY OI    STATUS,X'10'        INDICATE MEMBER NOT FOUND\n         MVI   3(R1),4             IGNORE THE ABEND\n         BSM   0,R14\n         SPACE\nOKOPEN   EQU   *\n         MVI   GOTEOD,0\n*        MVC   SHA1PB(28),SHA1PI   SET UP PARAMETER BLOCK FOR SHA-1\n         MVC   SHA2PB(40),SHA2PI   SET UP PARAMETER BLOCK FOR SHA-224\n         LA    R0,64\n         ST    R0,I64\n         XC    GETREGS(8),GETREGS\n         XC    PUTREGS(8),PUTREGS\n         XC    FILESIZE(8),FILESIZE\n         SR    R6,R6\n         SPACE\nREADLOOP EQU   *\n         BAL   R14,GET64\n         C     R0,=F'64'\n         BNE   READLAST\n         LM    R14,R15,FILESIZE\n         ALR   R15,R0\n         BC    12,NOCARRY\n         AL    R14,=F'1'\nNOCARRY  STM   R14,R15,FILESIZE\n         LA    R14,IBUF            DATA ADDRESS\n         LR    R15,R0              DATA LENGTH 64\n*        LA    R0,1                FUNCTION CODE 1, SHA-1\n         LA    R0,2                FUNCTION CODE 2, SHA-256\n         LA    R1,SHA2PB\nKLOOPI   EQU   *\n         KIMD  R2,R14              R2 NOT USED, R14 --> DATA, R15 = LEN\n         BNZ   KLOOPI              LOOP IF PARTIAL\n         B     READLOOP\n         SPACE\n*              R0 CONTAINS 0 TO 63 OR MOD(FILESIZE,64)\n*              THE LENGTH OF ANY REMAINING DATA IN IBUF AFTER\n*              HAVING PROCESSED THE FILE IN 64-BYTE CHUNKS.\nREADLAST EQU   *\n         LM    R14,R15,FILESIZE\n         ALR   R15,R0\n         BC    12,NOCARRYL\n         AL    R14,=F'1'\nNOCARRYL STM   R14,R15,FILESIZE\n         SLDL  R14,3               MULTIPLY BY 8, BYTES TO BITS\n*              A FILE OF 536,870,912 BYTES WILL HAVE HEX 100000000 BITS\n*              MAKING THE HIGH WORD OF THE MESSAGE BIT LENGTH NONZERO.\n*              THAT'S 5114 CYLINDERS ON A 3390, ABOUT HALF OF A 3390-9.\n*        STM   R14,R15,SHA2PB+20   MESSAGE BIT LENGTH FOR SHA-1\n         STM   R14,R15,SHA2PB+32   MESSAGE BIT LENGTH FIR SHA-256\n         LA    R14,IBUF            DATA ADDRESS\n         LR    R15,R0              DATA LENGTH < 64\n*        LA    R0,1                FUNCTION CODE 1, SHA-1\n         LA    R0,2                FUNCTION CODE 2, SHA-256\n         LA    R1,SHA2PB\nKLOOPL   EQU   *\n         KLMD  R2,R14              R2 NOT USED, R14 --> DATA, R15 = LEN\n         BNZ   KLOOPL              LOOP IF PARTIAL\n         B     DYNEOD\n         SPACE\n*         GET64 - READ UP TO 64 BYTES INTO IBUF, SET R0 TO COUNT\n         SPACE\nGET64    LM    R5,R6,GETREGS\n         LA    R15,IBUF\n         L     R0,I64\nGET6A    CR    R5,R6               IF END OF RECORD\n         BNL   GET6R                 THEN READ NEXT RECORD\n         MVC   0(1,R15),0(R5)      COPY ONE BYTE TO OBUF\n         LA    R15,1(,R15)         NEXT OBUF BYTE\n         LA    R5,1(,R5)           NEXT IBUF BYTE\n         BCT   R0,GET6A            DECREMENT R0 AND LOOP\n         L     R0,I64              SET RETURNED LENGTH\n         STM   R5,R6,GETREGS\n         BR    R14\nGET6R    STM   R14,R0,GETREGS+8\n         CLI   GOTEOD,0            IF WE ALREADY HIT EODAD\n         BNE   GET6E                 GO THERE AGAIN\n         GET   (R4)\n         LR    R5,R1\n         TM    DCBRECFM,X'C0'      RECFM U\n         BO    GET6U\n         TM    DCBRECFM,X'80'      RECFM F\n         BO    GET6F\nGET6V    LA    R0,4\n         LH    R6,0(,R5)           LENGTH+4 FROM RDW\n         CLI   OPTR,0              IF RDW KEYWORD\n         BNE   GET6W                  INCLUDE RDW\n         AR    R5,R0               POINT PAST RDW\n         SR    R6,R0               REDUCE LENGTH\nGET6W    AR    R6,R5               POINT TO END OF RECORD\n         B     GET6X\nGET6U    LH    R6,DCBLRECL\n         AR    R6,R5               POINT TO END OF RECORD\n         B     GET6X\nGET6F    LH    R6,DCBLRECL         GET LENGTH FROM LRECL\n         TM    DCBRECFM,X'10'      IF NOT BLOCKED\n         BO    *+8                   THEN\n         LH    R6,DCBBLKSI           USE BLKSIZE AS LENGTH\n         AR    R6,R5               POINT TO END OF RECORD\nGET6X    LM    R14,R0,GETREGS+8\n         B     GET6A\nGET6E    CLI   GOTEOD,0            WERE WE ALREADY HERE\n         BE    *+8                 NO\n         EX    R0,*                YES, SOC3 IF EOF TWICE\n         MVI   GOTEOD,1            THAT'S ONCE\n         L     R0,I64\n         S     R0,GETREGS+16       COMPUTE HOW MANY BYTES IN IBUF\n         XC    GETREGS(8),GETREGS\n         L     R14,GETREGS+8\n         BR    R14\n         SPACE\n*MPTYDS  MVC   MSGWK(21),=C'-- EMPTY DATA SET -- '\n*        LA    R15,MSGWK+21\n*        B     ADDDSN\nDYNEOD   EQU   *\n         LA    R1,SHA2PB\n*        LA    R0,20 FOR SHA-1\n         LA    R0,28 FOR SHA-224\n         LA    R15,MSGWK\n         BAL   R14,TOHEX\n         SPACE\n*        LA    R15,MSGWK+40 FOR SHA-1\n         LA    R15,MSGWK+56 FOR SHA-224\n         MVI   0(R15),C' '\n         MVI   1(R15),C'*'\n         LA    R15,2(,R15)\nADDDSN   LA    R14,DSNAME\n         LH    R1,0(,R14)\n         BCTR  R1,0\n         B     *+10\n         MVC   0(0,R15),2(R14)\n         EX    R1,*-6\n         LA    R15,1(R1,R15)       POINT PAST LAST BYTE\n*        TM    14(R6),X'80'        MEMBER SPECIFIED?\n         CLI   MEMLEN+1,0          MEMBER ALLOCATED?\n         BZ    MEMAX               NO - BRANCH\n         MVI   0(R15),C'('\n         LA    R15,1(,R15)\n*        LH    R1,12(,R6)          GET LENGTH OF MEMBER\n         LH    R1,MEMLEN           GET LENGTH OF MEMBER\n         BCTR  R1,0                MINUS 1 FOR EX\n*        L     R14,8(,R6)          GET ADDRESS OF MEMBER NAME\n         LA    R14,MEMNAME\n         B     *+10\n         MVC   0(0,R15),0(R14)     MOVE MEMBER NAME\n         EX    R1,*-6\n         LA    R15,1(R1,R15)       POINT PAST LAST BYTE\n         MVI   0(R15),C')'\n         LA    R15,1(,R15)\nMEMAX    EQU   *\n         LA    R1,MSGWK\n         LR    R0,R15              POINT PAST LAST BYTE\n         SR    R0,R1               COMPUTE MESSAGE LENGTH\n         CLI   LOWKW+1,1           IF 'LOWER' SPECIFIED\n         BNE   LOWX\n         LR    R14,R0\n         BCTR  R14,0                  GET LENGTH MINUS 1\n         B     *+10\n         TR    MSGWK(0),LOWTABLE      TRANSLATE TO LOWER CASE\n         EX    R14,*-6\nLOWX     EQU   *\n         ST    R0,MSGL\n         CLI   BRIEFKW+1,1         BRIEF, JUST THE HASH\n         BNE   *+8\n*        LA    R0,40               FOR SHA-1\n         LA    R0,56               FOR SHA-224\n         CLI   MULTIKW+1,1         MULTIPLE LINES, DSNAME SEPARATE\n         BNE   *+8\n*        LA    R0,40               FOR SHA-1\n         LA    R0,56               FOR SHA-224\n         LA    R1,MSGWK\n         BAL   R14,PUTLINE\n         CLI   MULTIKW+1,1         MULTIPLE LINES\n         BNE   MSGDONE\n         LA    R0,MSGWK\n         A     R0,MSGL\n*        LA    R1,MSGWK+40         FOR SHA-1\n         LA    R1,MSGWK+56         FOR SHA-224\n*        LA    R1,2(,R1)           POINT PAST SPACE AND '*'\n         SR    R0,R1               COMPUTE MESSAGE LENGTH\n         BAL   R14,PUTLINE         DISPLAY DSNAME ONLY\nMSGDONE  B     QUITDSN\n         SPACE\nQUITD12  MVI   RETCODE+1,12\n         SPACE\nQUITDSN  TM    STATUS,X'80'\n         BZ    NOCLOSE\n         LA    R5,DYNDCBEW\n*        TM    DCBOFLGS,X'10'      IS IT OPEN?\n         TM    DCBEFLG1,DCBEOPEN\n         BZ    NOCLOSE             NO, BRANCH\n         MVC   CLOSED(CLOSE31L),CLOSE31\n         CLOSE ((R4)),MODE=31,MF=(E,CLOSED)\n         NI    STATUS,255-X'80'    CLOSED\n         DROP  R4                  IHADCB\nNOCLOSE  EQU   *\n         TM    STATUS,X'40'        FREE REQUIRED?\n         BZ    NOFREE\n         LA    R1,MYDAPL\n         LA    R15,MYDAPB\n         USING DAPB18,R15\n         XC    0(40,R15),0(R15)\n         MVI   DA18CD+1,X'18'\n         MVC   DA18DDN,DDSAVE\n         MVC   DA18MNM(8),=CL8' '\n         MVC   DA18SCLS(2),=CL8' '\n         BAL   R14,CALLDAIR        UNALLOCATE\n         NI    STATUS,255-X'40'    UNALLOCATED\n         DROP  R15                 DAPB18\nNOFREE   EQU   *\n         B     NEXTDSN\n         SPACE\nDONE     TM    MYPUTLEP,X'80'     WAS PUTLINE LOADED?\n         BO    NODELETE           NO - USED CVTPUTL - BRANCH\n         LA    R0,=CL8'IKJPUTL '\n         DELETE EPLOC=(0)\nNODELETE EQU   *\n         SPACE\n         IKJRLSA MYANS\n         SPACE\n         CLI   RETCODE+1,0         IS RETCODE ZERO?\n         BZ    STACKDX             YES, BRANCH\n         MVC   MYSTPB(STACKDL),STACKD\n         SPACE\n         STACK DELETE=ALL,PARM=MYSTPB,MF=(E,MYIOPL)\n         SPACE\n         TCLEARQ\nSTACKDX  EQU   *\n         SPACE\n         LH    R15,RETCODE\n         B     EXIT\n         SPACE\n************************************************************\n*                                                          *\n*         CALL IKJDAIR SERVICE ROUTINE                     *\n*                                                          *\n************************************************************\n          SPACE\nCALLDAIR ST    R14,DAIRREGS\n         L     R15,16\n         TM    732(R15),X'80'     CVTDAIR\n         BNO   DAIRLINK\n         L     R15,732(,R15)\n         BALR  R14,R15\n         B     DAIRFINI\nDAIRLINK EQU   *\n         LINK  EP=IKJDAIR,SF=(E,LINKAREA)\nDAIRFINI L     R14,DAIRREGS\n         BR    R14\n         SPACE\n************************************************************\n*                                                          *\n*        DYNAMIC ALLOCATION FAILURE ROUTINE                *\n*                                                          *\n************************************************************\n         SPACE\nDAIRFAIL ST    R14,MYDFREGS\n         LA    R1,MYDFPARM\n         USING DFDSECTD,R1\n         ST    R15,MYDFRC\n         LA    R15,MYDFRC\n         ST    R15,DFRCP\n         LA    R15,MYDAPL\n         ST    R15,DFDAPLP\n         SLR   R15,R15\n         ST    R15,MYJEFF02\n         LA    R15,MYJEFF02\n         ST    R15,DFJEFF02\n         LA    R15,DFDAIR\n         STH   R15,MYDFID\n         LA    R15,MYDFID\n         ST    R15,DFIDP\n         SLR   R15,R15\n         ST    R15,DFCPPLP\n         LINK  EP=IKJEFF18,SF=(E,LINKAREA)\n         L     R15,MYDFRC\n         DROP  R1                  DFDSECTD\n         L     R14,MYDFREGS\n         BR    R14\n         SPACE\n************************************************************\n*                                                          *\n*        PUTMSG ROUTINE                                    *\n*                                                          *\n************************************************************\n         SPACE\nPUTMSG   STM   R14,R1,PUTLINS\n         XC    MYOLD(8),MYOLD\n         XC    MYSEG1(4),MYSEG1\n         MVC   MYPTPB(12),MODLPTPM\n         LA    R14,1               NO. OF MESSAGE SEGMENTS\n         ST    R14,MYOLD\n         LA    R14,MYSEG1          POINT TO 1ST SEGMENT\n         ST    R14,MYOLD+4\n         LR    R14,R0              LENGTH IN R0\n         LA    R14,4(,R14)         ADD 4\n         LA    R15,MYSEG1+4\n         CLC   0(3,R1),=C'IKJ'     IS DATA PRECEEDED BY MESSAGE ID?\n         BE    *+16                YES - BRANCH\n         LA    R14,1(,R14)         ADD 1 TO LENGTH\n         MVI   0(R15),C' '         INSERT LEADING BLANK\n         LA    R15,1(,R15)         BUMP POINTER\n         STH   R14,MYSEG1\n         LR    R14,R0\n         BCTR  R14,0\n         B     *+10\n         MVC   0(0,R15),0(R1)      MOVE MESSAGE IN\n         EX    R14,*-6\n         L     R15,MYPUTLEP\n         SPACE\n         PUTLINE PARM=MYPTPB,OUTPUT=(MYOLD),ENTRY=(15),MF=(E,MYIOPL)\n         SPACE\n         LM    R14,R1,PUTLINS\n         BR    R14\n         SPACE\n************************************************************\n*                                                          *\n*        PUTLINE ROUTINE                                   *\n*                                                          *\n************************************************************\n         SPACE\nPUTLINE  STM   R14,R1,PUTLINS\n         XC    MYSEG1(4),MYSEG1\n         MVC   MYPTPB(12),MODLPTPB\n         LR    R14,R0              LENGTH IN R0\n         LA    R14,4(,R14)         ADD 4\n         STH   R14,MYSEG1\n         LR    R14,R0\n         BCTR  R14,0\n         B     *+10\n         MVC   MYSEG1+4(0),0(R1)   MOVE TEXT IN\n         EX    R14,*-6\n         LA    R1,MYIOPL\n         L     R15,MYPUTLEP\n         SPACE\n         PUTLINE PARM=MYPTPB,OUTPUT=(MYSEG1,DATA),ENTRY=(15),MF=(E,(1))\n         SPACE\n         LM    R14,R1,PUTLINS\n         BR    R14\n         SPACE 1\n*RRRECFM LA    R1,MSGRECFM\n*        LA    R0,L'MSGRECFM\n*        BAL   R14,PUTMSG\n*        B     QUITD12\n         SPACE\nTOHEX    MVC   1(1,R15),0(R1)\n         UNPK  0(3,R15),1(2,R15)\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)\n         LA    R1,1(,R1)\n         BCT   R0,TOHEX\n         MVI   0(R15),C' '\n         BR    R14\n         SPACE\nEXIT     LR    R2,R15              SAVE R15\n         LR    R1,R10\n         L     R0,@SIZE24\n         FREEMAIN R,A=(1),LV=(0)\n         SPACE\n         LR    R1,R13\n         L     R0,@SIZE31\n         L     13,4(,13)\n         FREEMAIN RU,A=(1),LV=(0),SP=1\n         LR    R15,R2              RESTORE R15\n         LM    0,12,20(13)\n         L     14,12(,13)\n         BR    14\n         SPACE\n************************************************************\n*                                                          *\n*        SYNAD EXIT                                        *\n*                                                          *\n************************************************************\n         SPACE\n*        THIS ROUTINE IS ENTERED DURING THE 'GET' MACRO\n*        IF AN I/O ERROR OCCURS.\n         SPACE\nDYNSYNAD EQU   *\n         SYNADAF ACSMETH=QSAM\n         MVC   SYNADMSG(78),50(R1)\n         MVI   SYNADSW,X'FF'\n         SYNADRLS\n         BR    R14\n         SPACE\n************************************************************\n*                                                          *\n*        GLUE FOR DCB EXITS                                *\n*                                                          *\n************************************************************\n         SPACE\n*        THESE 2 INSTRUCTIONS ARE COPIED TO ABENDXIT, BELOW THE LINE,\n*        AND RUN THERE, NOT HERE. WHEN ABENDXIT IS ENTERED,\n*        R15 CONTAINS THE ENTRY ADDRESS, THE ADDRESS OF ABENDXIT.\n*        THEN USING R15 AS A BASE REGISTER, IT LOADS R15 FROM ABENDXAD,\n*        WHICH CONTAINS THE ADDRESS OF DYNABEND ABOVE THE LINE,\n*        WITH THE HIGH-ORDER BIT SET TO 1. THEN IT USES BSM TO\n*        BRANCH TO DYNABEND IN 31-BIT MODE. THE ROUTINE AT\n*        DYNABEND SHOULD RETURN USING 'BSM 0,R14'.\n*\nGLUE     L     R15,ABENDXAD-ABENDXIT(,R15)\n         BSM   R14,R15  OLD MODE INTO R14 HI BIT, BRANCH TO R15 IN 31\nGLUELEN  EQU   *-GLUE\n         SPACE\n*        SINCE ABENDXAD-ABENDEXIT IS IDENTICAL TO OPENEXAD-OPENEXIT\n*        THE FOLLOWING IS NOT REALLY NEEDED.\n         SPACE\nGLUE2    L     R15,OPENEXAD-OPENEXIT(,R15)\n         BSM   R14,R15  OLD MODE INTO R14 HI BIT, BRANCH TO R15 IN 31\nGLUELEN2 EQU   *-GLUE2\n         SPACE\n************************************************************\n*                                                          *\n*        CONSTANTS                                         *\n*                                                          *\n************************************************************\n         SPACE\nMODLPTPM PUTLINE OUTPUT=(1,TERM,SINGLE,INFOR),                         X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=L\n         SPACE\nMODLPTPB PUTLINE OUTPUT=(1,TERM,SINGLE,DATA),                          X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=L\n         SPACE\n*        PRINT NOGEN\n         SPACE\nOPEN31   OPEN  (0,),MODE=31,MF=L\nOPEN31L  EQU   *-OPEN31\nCLOSE31  CLOSE (0,),MODE=31,MF=L\nCLOSE31L EQU   *-CLOSE31\n         SPACE\nDYNDCB   DCB   DDNAME=DYNAM,DSORG=PS,MACRF=(GL),                       +\n               EODAD=0,SYNAD=0,EROPT=ACC,DCBE=0\nDYNDCBL  EQU   *-DYNDCB\n         SPACE\nDYNDCBE  DCBE  RMODE31=BUFF,EODAD=1\nDYNDCBEL EQU   *-DYNDCBE\n         SPACE\n         PRINT GEN\n         SPACE\nOBTAIN   CAMLST SEARCH,2,3,4\nOBTAINL  EQU   *-OBTAIN\n         SPACE\nLOCATE   CAMLST NAME,2,,4\nLOCATEL  EQU   *-LOCATE\n         SPACE\nSTACKD   STACK DELETE=ALL,MF=L\nSTACKDL  EQU   *-STACKD\n         SPACE\n         AGO   .SKIP1\nSHA1PI   DC    X'67452301' H0\n         DC    X'EFCDAB89' H1\n         DC    X'98BADCFE' H2\n         DC    X'10325476' H3\n         DC    X'C3D2E1F0' H4\n         DC    X'00000000' MESSAGE BIT LENGTH HIGH\n         DC    X'00000000' MESSAGE BIT LENGTH LOW\n.SKIP1   ANOP\n         SPACE\nSHA2PI   DC    X'C1059ED8' H0\n         DC    X'367CD507' H1\n         DC    X'3070DD17' H2\n         DC    X'F70E5939' H3\n         DC    X'FFC00B31' H4\n         DC    X'68581511' H5\n         DC    X'64F98FA7' H6\n         DC    X'BEFA4FA4' H7\n         DC    X'00000000' MESSAGE BIT LENGTH HIGH\n         DC    X'00000000' MESSAGE BIT LENGTH LOW\nHEXTAB   DC    C'0123456789ABCDEF'\nMSG01    DC    C'ERROR IN PARSE SERVICE ROUTINE'\nMSG02    DC    C'IKJ58503I DATA SET '\nMSG02A   DC    C' NOT IN CATALOG'\nMSG03    DC    C'ERROR IN DEFAULT SERVICE ROUTINE'\nMSG04    DC    C'UNABLE TO OPEN DATASET'\nMSG05    DC    C'IKJ58509I DATA SET NAME REQUIRED WHEN MEMBER IS SPECIF+\n               IED'\nMSG06    DC    C'ORGANIZATION OF DATA SET MUST BE PARTITIONED OR SEQUEN+\n               TIAL'\nMSG07    DC    C'DATA SET IS PARTITIONED, MEMBER NOT SPECIFIED'\nMSG08    DC    C'SPECIFIED MEMBER NOT FOUND IN DATASET'\nMSG09    DC    C'UNABLE TO OBTAIN DSCB FOR DATA SET'\nMSG14    DC    C'FILENAME '\nMSG14A   DC    C' INVALID, MORE THAN 8 CHARACTERS  '\nMSG14B   DC    C' IS NOT CURRENTLY ALLOCATED       '\nMSG14C   DC    C' NOT ALLOCATED TO A DASD DATA SET '\n*SGRECFM DC    C'RECORD FORMAT U NOT SUPPORTED'\n*MSGDAIR DC    C'UNABLE TO ALLOCATE'\nLOWTABLE DC    0D'0',256AL1(*-LOWTABLE)\n         ORG   LOWTABLE+C'A'\n         DC    X'818283848586878889'\n         ORG   LOWTABLE+C'J'\n         DC    X'919293949596979899'\n         ORG   LOWTABLE+C'S'\n         DC    X'A2A3A4A5A6A7A8A9'\n         ORG\n         LTORG\nPCLADDR  DC    0D'0'               END OF CSECT\n         SPACE\n************************************************************\n*                                                          *\n*        PARSE PARAMETERS                                  *\n*                                                          *\n************************************************************\n         SPACE\n         PRINT NOGEN\nSHASMPCL RMODE 31\nSHASMPCL IKJPARM\nDSN      IKJPOSIT DSNAME,LIST,PROMPT='DATA SET NAME'\nFILEKW   IKJKEYWD\n         IKJNAME 'FILE'\nQUICKW   IKJKEYWD\n         IKJNAME 'QUICK'\nRDWKW    IKJKEYWD\n         IKJNAME 'RDW'\nLOWKW    IKJKEYWD\n         IKJNAME 'LOWER'\nBRIEFKW  IKJKEYWD\n         IKJNAME 'BRIEF'\nMULTIKW  IKJKEYWD\n         IKJNAME 'MULTI'\n         IKJENDP\n         PRINT GEN\n         SPACE\n************************************************************\n*                                                          *\n*        DSECTS                                            *\n*                                                          *\n************************************************************\n         SPACE\n@DATA31  DSECT\n         DS    18F                 REGISTER SAVEAREA\nLINKAREA DS    2F\nMYPPL    DS    7F\nMYANS    DS    F\nMYECB    DS    F                  USED BY PUTLINE ROUTINE\nMYIOPL   DS    4F                 USED BY PUTLINE ROUTINE\nMYPTPB   DS    3F                 USED BY PUTLINE ROUTINE\nMYOLD    DS    2F                 USED BY PUTLINE ROUTINE\nMYSEG1   DS    2H,CL256           USED BY PUTLINE ROUTINE\nPUTLINS  DS    4F                 USED BY PUTLINE ROUTINE\nMYPUTLEP DS    F                  ADDRESS OF IKJPUTL\nMYSTPB   DS    0F                 5 WORDS USED BY STACK DELETE\nMYDAPL   DS    5F\nMYDAPB   DS    21F\nDSNAME   DS    H,CL44\nMEMLEN   DS    H\nMEMNAME  DS    CL8\nVOLSER   DS    CL6\nLOCATEW  DS    0F\nOBTAINW  DS    4F\nLOCBUF   DS    0D                  USES NEXT 265 BYTES\nMYDSCB   DS    CL140               96 BYTES OF DSCB, 5 BYTES CCHHR\nMSGWK    DS    CL128\nSTATUS   DS    X\nRETCODE  DS    H\nMYDFPARM DS    5F  USED BY DAIRFAIL\nMYDFREGS DS    F   USED BY DAIRFAIL\nMYDFRC   DS    F   USED BY DAIRFAIL\nMYJEFF02 DS    F   USED BY DAIRFAIL\nMYDFID   DS    H   USED BY DAIRFAIL\nDOUBLE   DS    D\nEIGHT    DS    CL8\nDDSAVE   DS    CL8\nDAIRREGS DS    F\nOPEND    DS    0F,(OPEN31L)X\nCLOSED   DS    0F,(CLOSE31L)X\nDYNDCBEW DS    0F,(DYNDCBEL)X\nKOUNT    DS    F\nKOUNTSP  DS    F\nSYNADSW  DS    F\nSYNADMSG DS    CL78\nDEVDATA  DS    2F\nGETREGS  DS    5F\nPUTREGS  DS    8F\nI64      DS    F\nDSL      DS    F\nMSGL     DS    F\nGOTEOD   DS    C\nOPTR     DS    C\n*SHA1PB  DS    0D,7F\nSHA2PB   DS    0D,10F\nFILESIZE DS    D\nIBUF     DS    CL80\n         DS    0D\n@DATA31L EQU   *-@DATA31\n         SPACE\n@DATA24  DSECT\nSAVE24   DS    18F                USED BY IKJEHDEF\nRDJFW    DS    F\nMYIOPL24 DS    4F                 USED BY IKJEHDEF\nMYECB24  DS    F\nMYDFPB   DS    5F\nDSNAME24 DS    H,CL44\nDYNDCBW  DS    0D,XL(DYNDCBL)\nDYNEXLST DS    2F\nOPENEXIT DS    0H,(GLUELEN)X\nOPENEXAD DS    F  X'80' + ADDRESS OF DYNOPENX\nABENDXIT DS    0H,(GLUELEN)X\nABENDXAD DS    F  X'80' + ADDRESS OF DYNABEND\nJFCB     DS    0F,CL176\nMYARL    DS    9F\nTBUF     DS    CL8\n         DS    0D\n@DATA24L EQU   *-@DATA24\n         SPACE\nIHADCB   DSECT\nDCBDCBE  DS    A\n         DS    28XL1\nDCBBFTEK DS    XL1\nDCBEODAD DS    AL3\nDCBEXLST DS    0A\nDCBRECFM DS    X\nDCBEXLSA DS    AL3\nDCBDDNAM DS    CL8\nDCBOFLGS DS    X\n         DS    7XL1\n         DS    X\nDCBSYNAD DS    AL3\nDCBBLKSI EQU   IHADCB+62,2\nDCBLRECL EQU   IHADCB+82,2\n         SPACE\n         IHADCBE\n         SPACE\nEFLG1    EQU   16\nEOPEN    EQU   X'80'\nEMD31    EQU   X'40'\nEEODA    EQU   40\nESYNA    EQU   44\n         SPACE\nXFLG1    EQU   DCBEFLG1-DCBE\nXOPEN    EQU   DCBEOPEN\nXMD31    EQU   DCBEMD31\nXEODA    EQU   DCBEEODA-DCBE\nXSYNA    EQU   DCBESYNA-DCBE\n         PRINT NOGEN\n         SPACE\n         IKJCPPL\n         SPACE 3\n         IKJPPL\n         SPACE\n         IKJDFPB\n         SPACE 2\n         IKJUPT\n         SPACE 2\n         IKJIOPL\n         SPACE 2\n         IKJDAPL\n         SPACE 2\n         IKJDAP08\n         SPACE 2\n         IKJDAP18\n         SPACE 2\n         IKJPSCB\n         SPACE 2\n         IKJEFFDF DFDSECT=YES\n         SPACE\n         IHAARL\n         SPACE\n         IHAARA\n         SPACE\n*        CVT   DSECT=YES\n         SPACE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SHA224S$": {"ttr": 6921, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00R\\x01\\x176\\x1f\\x01\\x176\\x1f\\x009\\x00\\x12\\x00\\x12\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-12-27T00:00:00", "modifydate": "2017-12-27T00:39:52", "lines": 18, "newlines": 18, "modlines": 0, "user": "UPDATED"}, "text": "//CBTUSER1 JOB (ACCT),'PGMR',NOTIFY=CBTUSER,\n//         MSGLEVEL=(1,1),MSGCLASS=H\n//* ASSEMBLE THE 31-BIT SHA224S TSO COMMAND\n//ASM    EXEC PGM=ASMA90,PARM=(OBJ,NODECK,TERM,NOXREF,BATCH,\n//             ASA,NODX,NOMX,NORX,RLD,NOUS,'PC(NOUHD)')\n//SYSPRINT DD  SYSOUT=*\n//SYSTERM  DD  SYSOUT=*\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//SYSLIN   DD  DSNAME=&&OBJ,DISP=(NEW,PASS),\n//             UNIT=SYSDA,SPACE=(TRK,(3,0)),\n//             DCB=(BLKSIZE=3200)\n//SYSIN    DD  DSN=CBTUSER.LIB.ASM(SHA224S),DISP=SHR\n//LKED   EXEC PGM=HEWLKED,PARM='LIST,MAP,RENT,REFR',\n//             COND=(0,NE)\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSNAME=&&OBJ,DISP=(OLD,DELETE)\n//SYSLMOD  DD  DSNAME=CBTUSER.LIB.LOAD(SHA224S),DISP=SHR\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(TRK,(10,0))\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SHA224S#": {"ttr": 6923, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x05\\x01\\x176\\x1f\\x01\\x176\\x1f\\x00A\\x00\\x19\\x00\\x19\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-12-27T00:00:00", "modifydate": "2017-12-27T00:41:05", "lines": 25, "newlines": 25, "modlines": 0, "user": "UPDATED"}, "text": ")F FUNCTION -\n  THE SHA224S COMMAND DISPLAYS THE SHA-224 HASH OF DATA SETS.\n  IN DATA SETS WITH VARIABLE-LENGTH RECORDS THE RDW'S AND SDW'S ARE\n  NOT INCLUDED WHEN THE CHECKSUM IS COMPUTED UNLESS THE RDW KEYWORD\n  IS SPECIFIED.\n)X SYNTAX -\n         SHA224S  'DSLIST'  FILE  LOWER  RDW  BRIEF  MULTI  QUICK\n\n  REQUIRED - 'DSLIST'\n  DEFAULTS - NONE\n\n)O OPERANDS -\n  'DSLIST' - NAMES OF SEQUENTIAL DATA SETS OR MEMBERS OF PARTITIONED\n             DATA SETS. IF MORE THAN ONE, ENCLOSE LIST IN PARENTHESES.\n))FILE     - THE NAMES IN DSLIST ARE DDNAMES, NOT DSNAMES.\n))LOWER    - DISPLAY THE RESULTS IN LOWER CASE.\n))RDW      - INCLUDE RDW OR SDW IN VARIABLE LENGTH RECORDS.\n))BRIEF    - DISPLAY ONLY THE HASH, WITHOUT THE DATA SET NAME.\n))MULTI    - DISPLAY THE HASH AND DATA SET NAME ON SEPARATE LINES.\n))QUICK    - FOR UNQUOTED DSNAMES, BYPASS THE DEFAULT SERVICE ROUTINE.\n             SO FOR EXAMPLE, IF YOU SPECIFY THE NAME TEMP AND YOU\n             ONLY HAVE A DATA SET NAMED TEMP.DATA, IT WON'T BE FOUND\n             IF QUICK IS ALSO SPECIFIED. THE QUICK KEYWORD IS JUST\n             TO CUT OUT THE OVERHEAD OF LOOKING FOR EXTENSIONS AT\n             THE END OF THE SPECIFIED DATA SET NAME.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SHA3SUM": {"ttr": 6925, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00G\\x01\\x16$\\x1f\\x01\\x19\\x07\\x7f\\x13)\\x05\\xdf\\x05\\xc7\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2016-08-28T00:00:00", "modifydate": "2019-03-18T13:29:47", "lines": 1503, "newlines": 1479, "modlines": 0, "user": "UPDATED"}, "text": "         TITLE '   S H A 3 S U M  '\n************************************************************\n*                                                          *\n*        'SHA3SUM' TSO COMMAND (31-BIT)                    *\n*                                                          *\n************************************************************\n         SPACE\n*        WRITTEN MAY 22 2016 USING MD5SUM AS A TEMPLATE.\n*         NOTE: MD5SUM USED 'COUNT' (CBT FILE 300) AS A TEMPLATE.\n*        ATTRIBUTES. RE-ENTRANT.\n*        UPDATED MAY 27 2016 TO ADD BRIEF AND MULTI KEYWORDS.\n*        UPDATED AUG 28 2016 TO IGNORE DS1LSTAR WHICH IS 0 FOR PDSE\n*        UPDATED AUG 28 2016 TO CREATE SHA3SUM FROM SHA5SUM SOURCE\n*        UPDATED SEP  3 2016 TO SET RETURN CODE 12 IF ANY ERROR\n*        UPDATED DEC 27 2017 TO SUPPORT 8-BYTE PREFIX IN Z/OS V2R3\n*        UPDATED MAR 18 2019 TO SUPPORT EAV VOLUMES (SEE CHANGES BELOW)\n*\n*        THIS TSO COMMAND READS THE SPECIFIED SEQUENTIAL DATA SETS\n*        OR PDS MEMBERS AND DISPLAYS THE SHA-2 384-BIT HASH FOR EACH.\n*        SHA = SECURE HASH ALGORITHM.\n*\n*        SYNTAX:\n*                SHA3SUM DSNAME\n*                SHA3SUM (DSNAME1 DSNAME2 ...)\n*        KEYWORDS:\n*                RDW - INCLUDE RDW'S\n*                LOWER - SHOW RESULTS IN LOWER CASE\n*                QUICK - DSNAME IS COMPLETE, NO IMPLIED EXTENSION\n*                FILE - DSNAME IS A DDNAME ALREADY ALLOCATED\n*                BRIEF - SHOW THE HASH ONLY, WITH NO DSNAME\n*                MULTI - SHOW THE HASH AND DSNAME ON SEPARATE LINES\n*                HALF  - SHOW THE HASH IN TWO LINES, IMPLIES BRIEF\n*                        BUT HALF AND MULTI TOGETHER SHOWS DSNAME TOO\n*\n*        IF AN UNQUALIFIED DATA SET NAME IS ENTERED, THE\n*        CATALOG MUST BE READ TWICE, ONCE TO APPEND A\n*        TRAILING QUALIFIER IF NECESSARY, AND AGAIN DURING\n*        ALLOCATION. THE USER CAN ELIMINATE THE FIRST BY USING\n*        THE FULLY QUALIFIED NAME, PREFIX AND ALL, IN QUOTES,\n*        OR BY ENTERING ALL BUT THE PREFIX, WITHOUT QUOTES,\n*        PLUS THE KEYWORD 'Q'. THE LATTER IS MUCH SIMPLER\n*        AND GIVES THE SAME PERFORMANCE IMPROVEMENT AS A\n*        FULLY QUALIFIED NAME.\n*\n*        THE 'FILE' KEYWORD IS USEFUL FOR READING TEMPORARY\n*        DATA SETS.  IT TELLS THE COMMAND TO TREAT THE FIRST\n*        OPERAND AS A FILENAME (DDNAME) INSTEAD OF A DSNAME.\n*        WHATEVER DATA SET IS CURRENTLY ALLOCATED TO THE\n*        FILENAME WILL BE READ (AND QUICKLY, BECAUSE\n*        THE COMMAND DOESNT HAVE TO ALLOCATE ANYTHING).\n*\n*        UNIX FILES THAT ARE PREALLOCATED TO A DDNAME CAN BE\n*        READ. FOR EXAMPLE:\n*         ALLOC FI(DD1) PATH('/ETC/MAGIC') (BUT USE PATH IN LOWER CASE)\n*         SHA3SUM DD1 FILE\n*        IF UNIX FILES ARE NOT GIVEN RECFM WHEN ALLOCATED\n*        THEY DEFAULT TO RECFM=U, WHICH IS GOOD FOR SHA3SUM.\n*        RECFM=F WOULD BE LIKELY TO INTRODUCE PADDING IN THE\n*        LAST RECORD, WHICH WOULD CHANGE THE SHA3SUM RESULT.\n*\n*        NOTE - IF A NON-EXISTENT MEMBER OF A PDS IS SPECIFIED,\n*        THE RESULTING 013-18 ABEND IS TRAPPED BY A DCB ABEND\n*        EXIT, BUT A MESSAGE IS ISSUED BY OPEN ANYWAY. THIS\n*        METHOD IS USED BECAUSE THE ADDITIONAL OVERHEAD\n*        OF ALLOCATING THE PDS AND DOING A 'BLDL' WOULD\n*        DEGRADE THE PERFORMANCE UNACCEPTABLY.\n*\n*        PROBLEMS FIXED:\n*        . IF THE SPECIFIED DDNAME (WITH 'FILE' KEYWORD) IS\n*          A MEMBER OF A PDS, ONLY THE PDS NAME WAS SHOWN.\n*          ADDED CODE TO GET MEMBER NAME FROM JFCBELNM.\n*        . IF THE SPECIFIED DDNAME (WITH 'FILE' KEYWORD) IS\n*          A UNIX PATH, ONLY \"...PATH=.SPECIFIED...\" IS SHOWN,\n*          THAT'S WHAT IS IN THE JFCB. ADDED ARL TO GET PATH.\n*\n*        IMPROVEMENTS NEEDED:\n*        . ALLOW PATH TO BE SPECIFIED AND ALLOCATE IT.\n*        . IF THE SPECIFIED DDNAME (WITH 'FILE' KEYWORD) IS\n*          A CONCATENATION, SHOW MORE THAN THE FIRST DSN OR PATH.\n*\n* CHNGE LOG: 02JUN92 - INCLUDED 'OBTAIN' MACRO IN THE SOURCE. WITH\n*                      MVS/XA 2.2.3, THE MACRO IS ONLY AVAILABLE IN\n*                      'SYS1.AMACLIB' (SOUNDS LIKE IBM IS TRYING TO\n*                      TELL US SOMETHING).  JIM MARSHALL         JDM1\n*\n* CHNGE LOG: 12OCT13 - MD5SUM COMMAND CREATED FROM SOURCE OF 'COUNT'.\n*                      RDW'S ARE NOT INCLUDED IN THE MD5 AT THIS TIME,\n*                      AS A RESULT, 2 FILES OF VARIABLE-LENGTH RECORDS,\n*                      ONE WITH 2 RECORDS \"AB\" AND \"CD\" AND THE OTHER\n*                      ONE WITH 2 RECORDS \"ABC' AND \"D\" WILL HAVE THE\n*                      SAME MD5 VALUE.\n*\n* CHNGE LOG: 11NOV13 - SUPPORT LIST OF DSNAMES, SHOW NAME AFTER MD5.\n*\n* CHNGE LOG: 12NOV13 - CONVERT TO 31-BIT.\n*\n* CHNGE LOG: 15NOV13 - ALLOW NON-DASD DEVTYPE INCLUDING UNIX AND DUMMY.\n*                      SHOW UNIX FILE NAME IF DDNAME ALLOCATED TO PATH.\n*                      SHOW MEMBER NAME IF DDNAME ALLOCATED TO MEMBER.\n*\n* CHNGE LOG: 13MAR19 - REVERSED THE CHANGE FROM JUNE 02, 1992 AND USED\n*                      THE ORIGINAL OBTAIN MACRO AGAIN. ADDITIONALLY\n*                      ADDED THE EADSCB=OK MACRO PARAMETER.\n*\n*--------------------------------------------------------------------\n*         MACRO                                                  JDM1\n*&NAME    OBTAIN &LIST,&DUMMY=                                   JDM1\n*         AIF   (T'&LIST EQ 'O').E1                              JDM1\n*&NAME    IHBINNRA &LIST                 LOAD REG 1              JDM1\n*         SVC   27                       ISSUE OBTAIN SVC        JDM1\n*         MEXIT                                                  JDM1\n*.E1      IHBERMAC 34                    LIST ADDR MISSING       JDM1\n*         MEND                                                   JDM1\n*--------------------------------------------------------------------\n*         INTERCEPT 'LINK' MACRO IMBEDDED IN STACK MACRO\n*         TO MAKE SF=(E,LINKAREA) THE DEFAULT.\n         MACRO\n&NAME    LINK  &EP=,&SF=(E,LINKAREA)\n&NAME    LA    15,&SF(2)\n         LA    0,*+8\n         B     *+12\n         DC    CL8'&EP'\n         ST    0,0(0,15)\n         SVC   6             ISSUE LINK SVC\n         MEND\n         SPACE\nSHA3SUM  START\nSHA3SUM  AMODE 31\nSHA3SUM  RMODE 31\n         USING *,R12,R11\n         B     @PROLOG-*(,R15)\n         DC    AL1(7),CL7'SHA3SUM'\n         DC    CL16' &SYSDATE &SYSTIME '\n@SIZE31  DC    0F'0',AL1(0),AL3(@DATA31L)\n@SIZE24  DC    0F'0',AL1(1),AL3(@DATA24L)\n@PROLOG  STM   14,12,12(13)\n         LR    R12,R15             BASE\n         LA    R15,1\n         LA    R11,4095(R15,R12)   BASE\n         LR    R2,R1\n         USING CPPL,R2\n         L     R0,@SIZE31\n         GETMAIN RU,LV=(0),SP=1,LOC=31\n         LR    R9,R1\n         USING @DATA31,R9\n         ST    13,4(,1)            CHAIN SAVEAREA\n         ST    1,8(,13)            CHAIN SAVEAREA\n         LR    13,1                NEW SAVEAREA\n         SPACE\n         L     R0,@SIZE24\n         GETMAIN R,LV=(0)\n         LR    R10,R1\n         USING @DATA24,R10\n         SPACE\n         MVI   STATUS,0\n         XC    LINKAREA(8),LINKAREA\n         SLR   R15,R15\n         STH   R15,RETCODE         SET RETCODE = 0\n         ST    R15,KOUNT\n         ST    R15,KOUNTSP\n         SPACE\n************************************************************\n*                                                          *\n*        SET UP IOPL FOR PUTLINE                           *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R15,MYIOPL\n         USING IOPL,R15\n         MVC   IOPLUPT(4),CPPLUPT\n         MVC   IOPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,IOPLECB\n         XC    MYECB,MYECB\n         LA    R0,MYPTPB\n         ST    R0,IOPLIOPB\n         DROP  R15                 IOPL\n         SPACE\n         L     R15,16              LOAD CVT POINTER\n         TM    444(R15),X'80'      IS PUTLINE LOADED? (VS2)\n         BNO   PUTLOAD             NO - BRANCH TO LOAD\n         L     R15,444(,R15)       YES - USE CVTPUTL\n         B     PUTLOADX            BRANCH AROUND LOAD\nPUTLOAD  LA    R0,=CL8'IKJPUTL '\n         LOAD  EPLOC=(0)\n         LR    R15,R0              GET ENTRY ADDRESS\n         LA    R15,0(,R15)         CLEAR HI BYTE FOR DELETE ROUTINE\nPUTLOADX ST    R15,MYPUTLEP        SAVE PUTLINE ENTRY ADDRESS\n         SPACE\n************************************************************\n*                                                          *\n*        SET UP PPL FOR PARSE                              *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R15,MYPPL\n         USING PPL,R15\n         MVC   PPLUPT(4),CPPLUPT\n         MVC   PPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,PPLECB\n         XC    MYECB,MYECB\n         L     R0,=A(SHASMPCL)\n*        LA    R0,PCLADDR\n         ST    R0,PPLPCL\n         LA    R0,MYANS\n         ST    R0,PPLANS\n         XC    MYANS(4),MYANS\n         MVC   PPLCBUF(4),CPPLCBUF\n         ST    R9,PPLUWA\n         DROP  R15                 PPL\n         SPACE 1\n************************************************************\n*                                                          *\n*        CALL THE PARSE SERVICE ROUTINE                    *\n*                                                          *\n************************************************************\n         SPACE\n         LR    R1,R15              POINT TO PPL\n*        CALLTSSR EP=IKJPARS\n         L     R15,16              CVTPTR\n         TM    524(R15),X'80'      IF HI ORDER BIT NOT ON\n         BNO   PARSELNK               THEN DO LINK, NOT CALL\n         L     R15,524(,R15)       CVTPARS\n         BALR  R14,R15             CALL IKJPARS\n         B     PARSEEXT            SKIP AROUND LINK\nPARSELNK EQU   *\n         LINK  EP=IKJPARS,SF=(E,LINKAREA)\nPARSEEXT EQU   *\n         SPACE 1\n         LTR   R15,R15\n         BZ    PARSEOK\n         LA    R1,MSG01\n         LA    R0,L'MSG01\n         BAL   R14,PUTMSG\n         LA    R15,12\n         B     EXIT\nPARSEOK  EQU   *\n         SPACE\n         L     R3,MYANS\n         USING IKJPARMD,R3\n         SPACE\n         MVC   OPTR,RDWKW+1\n         SPACE\n************************************************************\n*                                                          *\n*        GET THE FIRST OR NEXT DSN IN THE LIST             *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R6,DSN\n         ST    R6,DSL\n         B     FIRSTDSN\nNEXTDSN  L     R6,DSL\n         CLI   24(R6),X'FF'        END OF DSN LIST?\n         BE    DONE\n         L     R6,24(,R6)          POINT TO NEXT ENTRY\n         ST    R6,DSL\nFIRSTDSN SR    R0,R0\n         ST    R0,KOUNT\n         SPACE\n************************************************************\n*                                                          *\n*        QUALIFY THE DSNAME IF NECESSARY                   *\n*                                                          *\n************************************************************\n         SPACE\n         TM    6(R6),X'80'         IS DATASET NAME SPECIFIED?\n         BO    OKDSN               YES - BRANCH\n         LA    R1,MSG05            NO - JUST MEMBER NAME\n         LA    R0,L'MSG05\n         BAL   R14,PUTMSG\n         B     NEXTD12\nOKDSN    EQU   *\n         LA    R15,DSNAME+2\n         MVI   0(R15),C' '         BLANK THE DSNAME AREA\n         MVC   1(43,R15),0(R15)\n         SLR   R1,R1\n         STH   R1,DSNAME           ZERO DSNAME LENGTH\n         TM    6(R6),X'40'         IS DSN QUOTED?\n         BO    NOPREF              YES, SKIP PREFIXING\n         CLI   FILEKW+1,1          DSN TO BE TREATED AS DDNAME\n         BE    NOPREF              YES, SKIP PREFIXING\n         L     R14,CPPLUPT         POINT TO UPT\n         USING UPT,R14\n*         CHECK UPT FOR 8-BYTE PREFIX - Z/OS V2R3.\n         CLI   UPTPREFX,C'>'      IF PREFIX IS '>7BYTES' (8 BYTES)\n         BNE   PREF07                THEN\n         IC    R1,UPTPREFL+18        GET UPTPRF8L (SHOULD ALWAYS BE 8)\n         LTR   R1,R1                 IS IT ZERO\n         BZ    NOPREF                YES, SKIP PREFIXING\n         B     *+10\n         MVC   0(0,R15),UPTPREFX+17  COPY UPTPREF8\n         EX    R1,*-6              MOVE USERID TO DSNAME AREA\n         B     PREFDONE\nPREF07   EQU   *\n         IC    R1,UPTPREFL         GET LENGTH OF PREFIX\n         LTR   R1,R1               IS IT ZERO\n         BZ    NOPREF              YES, SKIP PREFIXING\n         B     *+10\n         MVC   0(0,R15),UPTPREFX\n         EX    R1,*-6              MOVE USERID TO DSNAME AREA\nPREFDONE EQU   *\n         DROP  R14                 UPT\n         LA    R15,0(R1,R15)       POINT PAST USERID\n         MVI   0(R15),C'.'         APPEND PERIOD\n         LA    R15,1(,R15)         POINT PAST PERIOD\n         LA    R1,1(,R1)           ADD 1 TO LENGTH\n         STH   R1,DSNAME           STORE LENGTH OF USERID PLUS 1\nNOPREF   EQU   *\n         LH    R1,4(,R6)           GET LENGTH\n         LR    R0,R1\n         AH    R0,DSNAME           ADD LENGTH OF PREFIX OR ZERO\n         STH   R0,DSNAME           SET COMBINED LENGTH\n         L     R14,0(,R6)          POINT TO DSN VALUE\n         BCTR  R1,0                LENGTH MINUS 1 FOR EX\n         B     *+10                BRANCH AROUND EXECUTED MVC\n         MVC   0(0,R15),0(R14)     (EXECUTED)\n         EX    R1,*-6              MOVE DSN TO DSNAME (AFTER PREFIX)\n         SPACE\n************************************************************\n*                                                          *\n*        IF 'FILE' KEYWORD IS SPECIFIED,                   *\n*        GET DSNAME FROM JFCB USING FILE NAME.             *\n*                                                          *\n************************************************************\n         SPACE\n         CLI   FILEKW+1,1          'FILE' SPECIFIED?\n         BNE   NOFILE              NO, BRANCH\n         CLI   DSNAME+1,8          IS LENGTH 8 OR LESS\n         BH    FILERR1             NO, BRANCH\n         DEVTYPE DSNAME+2,DEVDATA  GET DEVICE TYPE\n         LTR   R15,R15             WAS FILENAME VALID\n         BNZ   FILERR2             NO, BRANCH\n*        CLC   DEVDATA(8),=X'0000010300007FF8'\n*        BE    DEVOK\n*        TM    DEVDATA+2,X'20'     DIRECT ACCESS\n*        BZ    FILERR3             NO, BRANCH\nDEVOK    LA    R4,DYNDCBW\n         MVC   0(DYNDCBL,R4),DYNDCB\n         XC    DSNAME(2),DSNAME\n         XC    MEMLEN,MEMLEN\n         LA    R0,JFCB\n         LA    R1,DYNEXLST\n         ST    R0,0(,R1)\n         MVI   0(R1),X'07'\n         LA    R14,MYARL           ALLOCATION RETRIEVAL LIST\n         ST    R14,4(,R1)\n         MVI   4(R1),X'13'+X'80'\n         ST    R1,DCBEXLST-IHADCB(,R4)\n         USING ARL,R14\n         XC    0(36,R14),0(R14)\n         MVI   ARLLEN+1,36\n         MVC   ARLIDENT,=C'AR'\n         OI    ARLOPT1,ARLLANY+ARLUSS\n         MVC   40(8,R4),DSNAME+2   DCBDDNAM\n         MVC   DDSAVE,DSNAME+2\n         MVI   RDJFW,X'80'\n         RDJFCB ((R4)),MF=(E,RDJFW)\n         LA    R14,MYARL\n         L     R1,ARLAREA\n         LTR   R1,R1\n         BZ    NOARA\n         L     R0,ARLRTRVD\n         DROP  R14                 ARL\n         USING ARA,R1\nLOOPARA  TM    ARAFLG,ARAXINF\n         BZ    DONEARA\n         SR    R15,R15\n         IC    R15,ARAXINOF\n         SLL   R15,3\n         AR    R15,R1\n         USING ARAXINFO,R15\n         SR    R14,R14\n         ICM   R14,3,ARAPATHO      GET OFFSET TO PATH LEN\n         BZ    DONEARA\n         AR    R14,R15\n         DROP  R15                 ARAXINLN\n         SR    R15,R15\n         ICM   R15,3,0(R14)        GET ARAPATHLEN\n         CH    R15,=H'44'\n         BNH   *+8\n         LA    R15,44              JUST SHOW FIRST 44 FOR NOW\n         STH   R15,DSNAME\n         BCTR  R15,0\n         B     *+10\n         MVC   DSNAME+2(0),2(R14)  ARAPATHNAM\n         EX    R15,*-6\nDONEARA  LA    R14,MYARL           PREPARE FOR FREEMAIN\n         USING ARL,R14\n         SR    R15,R15             PREPARE FOR FREEMAIN\n         IC    R15,ARLPOOL\n         SR    R0,R0\n         ICM   R0,7,ARLRLEN\n         L     R1,ARLAREA\n         DROP  R14                 ARL\n         FREEMAIN RU,LV=(0),SP=(R15),A=(1)\nNOARA    CLC   DSNAME(2),=H'0'\n         BNE   FILESPEC\n         MVC   DSNAME+2(44),JFCB\n         LA    R1,DSNAME+45        LAST CHAR OF DSNAME\n         LA    R0,44               INITIAL LENGTH\nFILEA    CLI   0(R1),C' '          IS THIS LAST NONBLANK\n         BNE   FILEB               YES, BRANCH\n         BCTR  R1,0                BACK UP 1 CHARACTER\n         BCT   R0,FILEA            DECREMENT LENGTH AND BRANCH\nFILEB    STH   R0,DSNAME           STORE LENGTH OF DSNAME\n*        MVC   VOLUME(6),JFCB+118  GET VOLUME FROM JFCB\n         MVC   MEMNAME,JFCB+44     JFCBELNM IN IEFJFCBN\n         LA    R1,MEMNAME+7        LAST CHAR OF MEMBER NAME\n         LA    R0,8\nMEMA     CLI   0(R1),C' '\n         BNE   MEMB\n         BCTR  R1,0\n         BCT   R0,MEMA\nMEMB     STH   R0,MEMLEN\n         B     FILESPEC\nFILERR1  LA    R0,MSG14A\n         B     FILERR\nFILERR2  LA    R0,MSG14B\n         B     FILERR\nFILERR3  LA    R0,MSG14C\nFILERR   MVC   MSGWK(L'MSG14),MSG14\n         LA    R15,MSGWK+L'MSG14\n         LA    R14,DSNAME\n         LH    R1,0(,R14)\n         BCTR  R1,0\n         B     *+10\n         MVC   MSGWK+L'MSG14(0),2(R14)\n         EX    R1,*-6\n         LA    R15,1(R1,R15)\n         LR    R14,R0 POINT TO MSG14A, B, OR C\n         MVC   0(L'MSG14A,R15),0(R14)\n         LA    R0,L'MSG14+L'MSG14A+1(,R1)\n         LA    R1,MSGWK\n         BAL   R14,PUTMSG\n         B     QUITD12\nNOFILE   EQU   *\n         TM    6(R6),X'40'         IS IT QUOTED?\n         BO    DEFX                YES - SKIP DEFAULT SERVICE\n         CLI   QUICKW+1,1          QUICK SPECIFIED\n         BE    DEFX                YES, USER ENTERED ALL BUT PREFIX\n         SPACE\n************************************************************\n*                                                          *\n*        DEFAULT SERVICE ROUTINE TO GET QUALIFIERS         *\n*                                                          *\n************************************************************\n         SPACE\n*              ALL INPUT TO IKJEHDEF MUST BE BELOW THE LINE\n         MVC   DSNAME24(46),DSNAME\n         LA    R15,MYIOPL24\n         USING IOPL,R15\n         LA    R14,MYIOPL\n         MVC   IOPLUPT(4),IOPLUPT-IOPL(R14)\n         MVC   IOPLECT(4),IOPLECT-IOPL(R14)\n         LA    R0,MYECB24\n         ST    R0,IOPLECB\n         XC    MYECB24,MYECB24\n         LA    R14,MYDFPB\n         ST    R14,IOPLIOPB\n         USING DFPB,R14\n         XC    0(20,R14),0(R14)\n         LA    R0,DSNAME24\n         ST    R0,DFPBDSN\n         OI    DFPBCODE,X'04'      SEARCH CAT AND PROMPT IF MULTI\n         MVC   DFPBPSCB,CPPLPSCB\n*        MVI   DFPBCNTL,X'20'      PREFIX THE DSNAME\n         DROP  R14                 DFPB\n         DROP  R15                 IOPL\n         SPACE\n         LR    R1,R15              POINT TO IOPL\n         LA    R13,SAVE24          POINT TO SAVEAREA BELOW THE LINE\n         L     R15,16              CVTPTR\n         TM    736(R15),X'80'      IF HI ORDER BIT NOT ON\n         BNO   EHDEFLNK               THEN DO LINK, NOT CALL\n         L     R15,736(,R15)       CVTEHDEF\n         BALR  R14,R15             CALL IKJEHDEF\n         B     EHDEFEXT            SKIP AROUND LINK\nEHDEFLNK EQU   *\n         LINK  EP=IKJEHDEF,SF=(E,LINKAREA)\nEHDEFEXT EQU   *\n         SPACE\n         LR    R13,R9              RESTORE SAVEARE POINTER\n         B     DEFCODE(R15)\nDEFCODE  B     DEF00               SUCCESS\n         B     NEXTD12              MSG ALREADY ISSUED\n         B     DEF08               INVALID NAME GT 44\n         B     NEXTD12              MSG ALREADY ISUED\n         B     DEF16               NOT IN CATALOG\n         B     DEF20               NOT IN CATALOG\n         B     DEF24               IMPOSSIBLE\n         B     DEF28               COMMAND SYSTEM ERROR\n         B     DEF32               IMPOSSIBLE\n         B     DEF36               ?\nDEF08    EQU   *\nDEF16    EQU   *\n         B     DEF24\nDEF20    EQU   *\nLOCERR   EQU   *\n         MVC   MSGWK(L'MSG02),MSG02\n         LA    R15,MSGWK+L'MSG02\n         LA    R14,DSNAME\n         LH    R1,0(,R14)\n         BCTR  R1,0\n         B     *+10\n         MVC   MSGWK+L'MSG02(0),2(R14)\n         EX    R1,*-6\n         LA    R15,1(R1,R15)\n         MVC   0(L'MSG02A,R15),MSG02A\n         LA    R0,L'MSG02+L'MSG02A+1(,R1)\n         LA    R1,MSGWK\n         BAL   R14,PUTMSG\n         B     NEXTD12\nDEF24    EQU   *\nDEF28    EQU   *\nDEF32    EQU   *\nDEF36    EQU   *\n         LA    R1,MSG03\n         LA    R0,L'MSG03\n         BAL   R14,PUTMSG\nNEXTD12  MVI   RETCODE+1,12\n         B     NEXTDSN\n         SPACE\nDEF00    MVC   DSNAME(46),DSNAME24\nDEFX     EQU   *\n         SPACE\n************************************************************\n*                                                          *\n*        ALLOCATE THE DATASET                              *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R1,MYDAPL\n         USING DAPL,R1\n         MVC   DAPLUPT(4),CPPLUPT\n         MVC   DAPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,DAPLECB\n         MVC   DAPLPSCB(4),CPPLPSCB\n         LA    R15,MYDAPB\n         ST    R15,DAPLDAPB\n         DROP  R1                  DAPL\n         USING DAPB08,R15\n         XC    0(84,R15),0(R15)\n         MVI   DA08CD+1,X'08'\n         LA    R0,DSNAME\n         ST    R0,DA08PDSN\n         MVC   DA08DDN(8),=CL8' '\n         MVC   DA08UNIT,=CL8' '\n         MVC   DA08SER,=CL8' '\n         MVC   DA08MNM,=CL8' '\n         MVC   DA08PSWD,=CL8' '\n         MVI   DA08DSP1,DA08SHR\n         MVI   DA08DPS2,DA08KEEP\n         MVI   DA08DPS3,DA08KEP\n         TM    14(R6),X'80'        MEMBER SPECIFIED?\n         BZ    MEMBX               NO - BRANCH\n         LH    R1,12(,R6)          GET LENGTH OF MEMBER\n         STH   R1,MEMLEN\n         BCTR  R1,0                MINUS 1 FOR EX\n         L     R14,8(,R6)          GET ADDRESS OF MEMBER NAME\n         B     *+10\n         MVC   DA08MNM(0),0(R14)   MOVE MEMBER NAME\n         EX    R1,*-6\n         MVC   MEMNAME,DA08MNM\nMEMBX    EQU   *\n         TM    22(R6),X'80'        PASSWORD SPECIFIED?\n         BZ    PASSX               NO - BRANCH\n         LH    R1,20(,R6)          GET LENGTH OF PSWD\n         BCTR  R1,0                MINUS 1 FOR EX\n         L     R14,16(,R6)         GET ADDRESS OF PSWD\n         B     *+10\n         MVC   DA08PSWD(0),0(R14)  MOVE PSWD\n         EX    R1,*-6\nPASSX    EQU   *\n         LA    R1,MYDAPL\n         SPACE\n         BAL   R14,CALLDAIR\n         LTR   R15,R15\n         BZ    OKDAIR\n         BAL   R14,DAIRFAIL\n         B     NEXTD12\nOKDAIR   EQU   *\n         OI    STATUS,X'40'        TELL CLEANUP TO FREE IT\n         LA    R15,MYDAPB\n         MVC   DDSAVE,DA08DDN\n         TM    DA08DSO,X'40'       IS DSORG SEQUENTIAL?\n         BO    OKDSORG             YES - BRANCH\n         TM    DA08DSO,X'02'       IS DSORG PARTITIONED?\n         BO    OKDSORGP            YES, BRANCH\n*\n*              DSORG IS NEITHER PS NOR PO\n*              ISAM=X'80' DA=X'20' VSAM=X'00' NONE=X'00'\n*\nERRDSORG LA    R1,MSG06\n         LA    R0,L'MSG06\n         BAL   R14,PUTMSG\n         B     QUITD12\nOKDSORGP EQU   *\n         CLC   DA08MNM,=CL8' '     WAS MEMBER SPECIFIED?\n         BNE   OKDSORG             YES - BRANCH\n         LA    R1,MSG07\n         LA    R0,L'MSG07\n         BAL   R14,PUTMSG\n         B     NEXTD12\nOKDSORG  EQU   *\n         DROP  R15                 DAPB08\n         SPACE\n************************************************************\n*                                                          *\n*        CHECK FORMAT-1 DSCB FOR EMPTY DATA SET            *\n*                                                          *\n************************************************************\n         SPACE\n         L     R1,16               CVTPTR\n         L     R1,0(,R1)           TCB WORDS\n         L     R1,4(,R1)           CURRENT TCB\n         L     R1,12(,R1)          TIOT\n         LA    R1,24(,R1)          TOIENTRY\nDDLOOP   CLI   0(R1),0             END OF TIOT\n         BE    QUITDSN             YES, BRANCH (NEVER HAPPENS)\n         CLC   4(8,R1),DDSAVE      DOES DDNAME MATCH\n         BE    DDFOUND\n         SLR   R15,R15\n         IC    R15,0(,R1)\n         LA    R1,0(R15,R1)\n         B     DDLOOP\nDDFOUND  L     R15,16(,R1)         TIOEFSRT-1\n         N     R15,=A(X'00FFFFFF') CLEAR HIGH 8 BITS\n         TM    18(R15),X'20'       DIRECT ACCESS DEVICE?\n         BZ    OBTX                NO, BYPASS OBTAIN\n         MVC   VOLSER,28(R15)      UCBVOLI\nOBTDSCB  LA    R1,OBTAINW\n         MVC   0(OBTAINL,R1),OBTAIN\n         LA    R0,DSNAME+2         DSN FOR OBTAIN\n         ST    R0,4(,R1)\n         LA    R0,VOLSER           VOLUME FOR OBTAIN\n         ST    R0,8(,R1)\n         LA    R0,MYDSCB           ANSWER AREA FOR OBTAIN\n         ST    R0,12(,R1)\n         OBTAIN (1),EADSCB=OK\n         LTR   R15,R15             WAS OBTAIN SUCCESSFUL\n         BZ    OKDSCB              YES, BRANCH\n         SPACE\n*               OBTAIN HAS FAILED. HOW CAN THAT HAPPEN WHEN\n*               DYNAMIC ALLOCATION WAS SUCCESSFUL? ONE WAY IT\n*               CAN HAPPEN IS IF THE DSNAME IS AN ALIAS ENTRY\n*               IN A VSAM CATALOG.  IF IT IS, A 'LOCATE' WILL\n*               PUT THE TRUE NAME IN THE DSNAME FIELD, SO NOW\n*               WE ISSUE A LOCATE, AND TRY THE OBTAIN AGAIN.\n         SPACE\n         TM    STATUS,X'08'        HAS LOCATE BEEN TRIED ALREADY?\n         BZ    ALIAS               NO, GO TRY IT\nERROBT   LA    R1,MSG09            UNABLE TO OBTAIN DSCB\n         LA    R0,L'MSG09\n         BAL   R14,PUTMSG\n         B     QUITD12\nALIAS    OI    STATUS,X'08'        TRIP THE SWITCH\n         LA    R1,LOCATEW\n         MVC   0(LOCATEL,R1),LOCATE\n         LA    R0,DSNAME+2         DSNAME FOR LOCATE\n         ST    R0,4(,R1)\n         LA    R0,LOCBUF           ANSWER AREA FOR LOCATE\n         ST    R0,12(,R1)\n         LOCATE (1)\n         LTR   15,15               WAS LOCATE SUCCESSFUL?\n         BZ    OBTDSCB             YES, GO OBTAIN AGAIN\n         B     ERROBT              NO, ISSUE MESSAGE\n         SPACE\nOKDSCB   NI    STATUS,255-X'08'    TURN OFF LOCATE SWITCH\n         TM    MYDSCB-44+X'52',X'42' DSORG = PS OR PO\n         BZ    ERRDSORG\n*        TM    MYDSCB-44+X'54',X'C0' RECFM = U\n*        BO    ERRRECFM\n*        CLC   MYDSCB-44+X'62'(3),=X'000000' CHECK DS1LSTAR\n*        BE    EMPTYDS             BRANCH IF EMPTY DATA SET\nOBTX     EQU   *\nFILESPEC EQU   *\n         SPACE\n************************************************************\n*                                                          *\n*        SET UP THE DCB                                    *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R4,DYNDCBW\n         USING IHADCB,R4\n         MVC   0(DYNDCBL,R4),DYNDCB\n         MVC   DCBDDNAM(8),DDSAVE\n         SPACE\n         LA    R5,DYNDCBEW\n         USING DCBE,R5\n         MVC   0(DYNDCBEL,R5),DYNDCBE\n         ST    R5,DCBDCBE\n         SPACE\n         LA    R15,GET6E\n         ST    R15,DCBEEODA\n         SPACE\n         LA    R15,DYNSYNAD\n         ST    R15,DCBESYNA\n         SPACE\n         LA    R15,DYNEXLST\n         IC    R0,DCBEXLSA-1\n         ST    R15,DCBEXLSA-1      EXLST=DYNEXLST\n         STC   R0,DCBEXLSA-1\n         LA    R1,OPENEXIT         EXIT BELOW THE LINE\n         MVC   0(GLUELEN,R1),GLUE   WILL CONTAIN GLUE\n         ST    R1,0(,R15)          STORE IN 1ST EXLST WORD\n         MVI   0(R15),X'05'        MARK TYPE OF EXIT\n         LA    R0,DYNOPENX         EXIT ABOVE THE LINE\n         ST    R0,OPENEXAD         SAVE ITS ADDRESS\n         OI    OPENEXAD,X'80'      MAKE IT RUN IN31-BIT MODE\n         SPACE\n         LA    R1,ABENDXIT         EXIT BELOW THE LINE\n         MVC   0(GLUELEN,R1),GLUE   WILL CONTAIN GLUE\n         ST    R1,4(,R15)          STORE IN 2ND EXLST WORD\n         MVI   4(R15),128+X'11'    OPEN ABEND EXIT (MVS)\n         LA    R0,DYNABEND         EXIT ABOVE THE LINE\n         ST    R0,ABENDXAD         SAVE ITS ADDRESS\n         OI    ABENDXAD,X'80'      MAKE IT RUN IN31-BIT MODE\n         SPACE\n         OI    STATUS,X'80'        TELL CLEANUP TO CLOSE DCB\n         MVC   OPEND(OPEN31L),OPEN31\n         SPACE\n         OPEN  ((R4),INPUT),MODE=31,MF=(E,OPEND)\n         SPACE\n*        TM    DCBOFLGS,X'10'\n*        TM    DCBEFLG1,DCBEOPEN+DCBEMD31\n         TM    DCBEFLG1,DCBEOPEN\n         BO    OKOPEN\n         LA    R1,MSG08\n         LA    R0,L'MSG08\n         TM    STATUS,X'10'        MEMBER NOT FOUND?\n         BO    DYNOPENM            YES, BRANCH\n         LA    R1,MSG04\n         LA    R0,L'MSG04\nDYNOPENM BAL   R14,PUTMSG\n         B     QUITD12\n         SPACE\nDYNOPENX BSM   0,R14\n         SPACE\nDYNABEND L     R8,0(,R1)           GET COMPLETION CODE\n         N     R8,=A(X'FFF0FF00')\n         CL    R8,=A(X'01301800')  IS IT AN 013-18 ABEND\n         BE    DYNABENY            YES, BRANCH\n         MVI   4(R1),0             NO, ABNORMALLY TERMINATE\n         BSM   0,R14\nDYNABENY OI    STATUS,X'10'        INDICATE MEMBER NOT FOUND\n         MVI   3(R1),4             IGNORE THE ABEND\n         BSM   0,R14\n         SPACE\nOKOPEN   EQU   *\n         MVI   GOTEOD,0\n*        MVC   SHA1PB(28),SHA1PI   SET UP PARAMETER BLOCK FOR SHA-1\n*        MVC   SHA2PB(40),SHA2PI   SET UP PARAMETER BLOCK FOR SHA-256\n         MVC   SHA5PB(80),SHA3PI   SET UP PARAMETER BLOCK FOR SHA-384\n*        MVC   SHA5PB(80),SHA5PI   SET UP PARAMETER BLOCK FOR SHA-512\n         LA    R0,128\n         ST    R0,I128\n         XC    GETREGS(8),GETREGS\n         XC    PUTREGS(8),PUTREGS\n         XC    FILESIZE(8),FILESIZE\n         SR    R6,R6\n         SPACE\nREADLOOP EQU   *\n         BAL   R14,GET128\n         C     R0,=F'128'\n         BNE   READLAST\n         LM    R14,R15,FILESIZE\n         ALR   R15,R0\n         BC    12,NOCARRY\n         AL    R14,=F'1'\nNOCARRY  STM   R14,R15,FILESIZE\n         LA    R14,IBUF            DATA ADDRESS\n         LR    R15,R0              DATA LENGTH 128\n*        LA    R0,1                FUNCTION CODE 1, SHA-1\n*        LA    R0,2                FUNCTION CODE 2, SHA-256\n         LA    R0,3                FUNCTION CODE 3, SHA-512 SHA-384\n         LA    R1,SHA5PB\nKLOOPI   EQU   *\n         KIMD  R2,R14              R2 NOT USED, R14 --> DATA, R15 = LEN\n         BNZ   KLOOPI              LOOP IF PARTIAL\n         B     READLOOP\n         SPACE\n*              R0 CONTAINS 0 TO 127 OR MOD(FILESIZE,128)\n*              THE LENGTH OF ANY REMAINING DATA IN IBUF AFTER\n*              HAVING PROCESSED THE FILE IN 128-BYTE CHUNKS.\nREADLAST EQU   *\n         LM    R14,R15,FILESIZE\n         ALR   R15,R0\n         BC    12,NOCARRYL\n         AL    R14,=F'1'\nNOCARRYL STM   R14,R15,FILESIZE\n         SLDL  R14,3               MULTIPLY BY 8, BYTES TO BITS\n*              A FILE OF 536,870,912 BYTES WILL HAVE HEX 100000000 BITS\n*              MAKING THE HIGH WORD OF THE MESSAGE BIT LENGTH NONZERO.\n*              THAT'S 5114 CYLINDERS ON A 3390, ABOUT HALF OF A 3390-9.\n*        STM   R14,R15,SHA1PB+20   MESSAGE BIT LENGTH FOR SHA-1\n*        STM   R14,R15,SHA2PB+32   MESSAGE BIT LENGTH FOR SHA-256\n         STM   R14,R15,SHA5PB+72   MESSAGE BIT LENGTH F0R SHA-512 LOW\n         SR    R14,R14\n         LR    R15,R14\n         STM   R14,R15,SHA5PB+64   MESSAGE BIT LENGTH F0R SHA-512 HIGH\n         LA    R14,IBUF            DATA ADDRESS\n         LR    R15,R0              DATA LENGTH < 128\n*        LA    R0,1                FUNCTION CODE 1, SHA-1\n*        LA    R0,2                FUNCTION CODE 2, SHA-256\n         LA    R0,3                FUNCTION CODE 3, SHA-512 SHA-384\n         LA    R1,SHA5PB\nKLOOPL   EQU   *\n         KLMD  R2,R14              R2 NOT USED, R14 --> DATA, R15 = LEN\n         BNZ   KLOOPL              LOOP IF PARTIAL\n         B     DYNEOD\n         SPACE\n*         GET128 - READ UP TO 128 BYTES INTO IBUF, SET R0 TO COUNT\n         SPACE\nGET128   LM    R5,R6,GETREGS\n         LA    R15,IBUF\n         L     R0,I128\nGET6A    CR    R5,R6               IF END OF RECORD\n         BNL   GET6R                 THEN READ NEXT RECORD\n         MVC   0(1,R15),0(R5)      COPY ONE BYTE TO OBUF\n         LA    R15,1(,R15)         NEXT OBUF BYTE\n         LA    R5,1(,R5)           NEXT IBUF BYTE\n         BCT   R0,GET6A            DECREMENT R0 AND LOOP\n         L     R0,I128             SET RETURNED LENGTH\n         STM   R5,R6,GETREGS\n         BR    R14\nGET6R    STM   R14,R0,GETREGS+8\n         CLI   GOTEOD,0            IF WE ALREADY HIT EODAD\n         BNE   GET6E                 GO THERE AGAIN\n         GET   (R4)\n         LR    R5,R1\n         TM    DCBRECFM,X'C0'      RECFM U\n         BO    GET6U\n         TM    DCBRECFM,X'80'      RECFM F\n         BO    GET6F\nGET6V    LA    R0,4\n         LH    R6,0(,R5)           LENGTH+4 FROM RDW\n         CLI   OPTR,0              IF RDW KEYWORD\n         BNE   GET6W                  INCLUDE RDW\n         AR    R5,R0               POINT PAST RDW\n         SR    R6,R0               REDUCE LENGTH\nGET6W    AR    R6,R5               POINT TO END OF RECORD\n         B     GET6X\nGET6U    LH    R6,DCBLRECL\n         AR    R6,R5               POINT TO END OF RECORD\n         B     GET6X\nGET6F    LH    R6,DCBLRECL         GET LENGTH FROM LRECL\n         TM    DCBRECFM,X'10'      IF NOT BLOCKED\n         BO    *+8                   THEN\n         LH    R6,DCBBLKSI           USE BLKSIZE AS LENGTH\n         AR    R6,R5               POINT TO END OF RECORD\nGET6X    LM    R14,R0,GETREGS+8\n         B     GET6A\nGET6E    CLI   GOTEOD,0            WERE WE ALREADY HERE\n         BE    *+8                 NO\n         EX    R0,*                YES, SOC3 IF EOF TWICE\n         MVI   GOTEOD,1            THAT'S ONCE\n         L     R0,I128\n         S     R0,GETREGS+16       COMPUTE HOW MANY BYTES IN IBUF\n         XC    GETREGS(8),GETREGS\n         L     R14,GETREGS+8\n         BR    R14\n         SPACE\nEMPTYDS  MVC   MSGWK(21),=C'-- EMPTY DATA SET -- '\n         LA    R15,MSGWK+21\n         B     ADDDSN\nDYNEOD   EQU   *\n         LA    R1,SHA5PB\n*        LA    R0,20 FOR SHA-1\n*        LA    R0,32 FOR SHA-256\n         LA    R0,48 FOR SHA-384\n*        LA    R0,64 FOR SHA-512\n         LA    R15,MSGWK\n         BAL   R14,TOHEX\n         SPACE\n*        LA    R15,MSGWK+40 FOR SHA-1\n*        LA    R15,MSGWK+64 FOR SHA-256\n         LA    R15,MSGWK+96 FOR SHA-384\n*        LA    R15,MSGWK+128 FOR SHA-512\n         MVI   0(R15),C' '\n         MVI   1(R15),C'*'\n         LA    R15,2(,R15)\nADDDSN   LA    R14,DSNAME\n         LH    R1,0(,R14)\n         BCTR  R1,0\n         B     *+10\n         MVC   0(0,R15),2(R14)\n         EX    R1,*-6\n         LA    R15,1(R1,R15)       POINT PAST LAST BYTE\n*        TM    14(R6),X'80'        MEMBER SPECIFIED?\n         CLI   MEMLEN+1,0          MEMBER ALLOCATED?\n         BZ    MEMAX               NO - BRANCH\n         MVI   0(R15),C'('\n         LA    R15,1(,R15)\n*        LH    R1,12(,R6)          GET LENGTH OF MEMBER\n         LH    R1,MEMLEN           GET LENGTH OF MEMBER\n         BCTR  R1,0                MINUS 1 FOR EX\n*        L     R14,8(,R6)          GET ADDRESS OF MEMBER NAME\n         LA    R14,MEMNAME\n         B     *+10\n         MVC   0(0,R15),0(R14)     MOVE MEMBER NAME\n         EX    R1,*-6\n         LA    R15,1(R1,R15)       POINT PAST LAST BYTE\n         MVI   0(R15),C')'\n         LA    R15,1(,R15)\nMEMAX    EQU   *\n         LA    R1,MSGWK\n         LR    R0,R15              POINT PAST LAST BYTE\n         SR    R0,R1               COMPUTE MESSAGE LENGTH\n         CLI   LOWKW+1,1           IF 'LOWER' SPECIFIED\n         BNE   LOWX\n         LR    R14,R0\n         BCTR  R14,0                  GET LENGTH MINUS 1\n         B     *+10\n         TR    MSGWK(0),LOWTABLE      TRANSLATE TO LOWER CASE\n         EX    R14,*-6\nLOWX     EQU   *\n         ST    R0,MSGL\n         CLI   HALFKW+1,1          HALF, HASH IN 2 PARTS\n         BNE   NOTHALF\n*        LA    R0,64               FOR SHA-512 HALVES\n         LA    R0,48               FOR SHA-384 HALVES\n         BAL   R14,PUTLINE         DISPLAY FIRST HALF\n         LA    R1,MSGWK+48\n*        LA    R0,64               FOR SHA-512 HALVES\n         LA    R0,48               FOR SHA-384 HALVES\n         BAL   R14,PUTLINE         DISPLAY OTHER HALF\n         B     MULTST\nNOTHALF  CLI   BRIEFKW+1,1         BRIEF, JUST THE HASH\n         BNE   *+8\n*        LA    R0,40               FOR SHA-1\n*        LA    R0,64               FOR SHA-256\n         LA    R0,96               FOR SHA-384\n*        LA    R0,128              FOR SHA-512\n         CLI   MULTIKW+1,1         MULTIPLE LINES, DSNAME SEPARATE\n         BNE   *+8\n*        LA    R0,40               FOR SHA-1\n*        LA    R0,64               FOR SHA-256\n         LA    R0,96               FOR SHA-384\n*        LA    R0,128              FOR SHA-512\n         LA    R1,MSGWK\n         BAL   R14,PUTLINE\nMULTST   CLI   MULTIKW+1,1         MULTIPLE LINES\n         BNE   MSGDONE\n         LA    R0,MSGWK\n         A     R0,MSGL\n*        LA    R1,MSGWK+40         FOR SHA-1\n*        LA    R1,MSGWK+64         FOR SHA-256\n         LA    R1,MSGWK+96         FOR SHA-384\n*        LA    R1,MSGWK+128        FOR SHA-512\n*        LA    R1,2(,R1)           POINT PAST SPACE AND '*'\n         SR    R0,R1               COMPUTE MESSAGE LENGTH\n         BAL   R14,PUTLINE         DISPLAY DSNAME ONLY\nMSGDONE  LA    R15,0\n         B     QUITDSN\n         SPACE\nQUITD12  LA    R15,12\n         SPACE\nQUITDSN  TM    STATUS,X'80'\n         BZ    NOCLOSE\n         LA    R5,DYNDCBEW\n*        TM    DCBOFLGS,X'10'      IS IT OPEN?\n         TM    DCBEFLG1,DCBEOPEN\n         BZ    NOCLOSE             NO, BRANCH\n         MVC   CLOSED(CLOSE31L),CLOSE31\n         CLOSE ((R4)),MODE=31,MF=(E,CLOSED)\n         NI    STATUS,255-X'80'    CLOSED\n         DROP  R4                  IHADCB\nNOCLOSE  EQU   *\n         TM    STATUS,X'40'        FREE REQUIRED?\n         BZ    NOFREE\n         LA    R1,MYDAPL\n         LA    R15,MYDAPB\n         USING DAPB18,R15\n         XC    0(40,R15),0(R15)\n         MVI   DA18CD+1,X'18'\n         MVC   DA18DDN,DDSAVE\n         MVC   DA18MNM(8),=CL8' '\n         MVC   DA18SCLS(2),=CL8' '\n         BAL   R14,CALLDAIR        UNALLOCATE\n         NI    STATUS,255-X'40'    UNALLOCATED\n         DROP  R15                 DAPB18\nNOFREE   EQU   *\n         B     NEXTDSN\n         SPACE\nDONE     TM    MYPUTLEP,X'80'     WAS PUTLINE LOADED?\n         BO    NODELETE           NO - USED CVTPUTL - BRANCH\n         LA    R0,=CL8'IKJPUTL '\n         DELETE EPLOC=(0)\nNODELETE EQU   *\n         SPACE\n         IKJRLSA MYANS\n         SPACE\n         CLI   RETCODE+1,0         IS RETCODE ZERO?\n         BZ    STACKDX             YES, BRANCH\n         MVC   MYSTPB(STACKDL),STACKD\n         SPACE\n         STACK DELETE=ALL,PARM=MYSTPB,MF=(E,MYIOPL)\n         SPACE\n         TCLEARQ\nSTACKDX  EQU   *\n         SPACE\n         LH    R15,RETCODE\n         B     EXIT\n         SPACE\n************************************************************\n*                                                          *\n*         CALL IKJDAIR SERVICE ROUTINE                     *\n*                                                          *\n************************************************************\n          SPACE\nCALLDAIR ST    R14,DAIRREGS\n         L     R15,16\n         TM    732(R15),X'80'     CVTDAIR\n         BNO   DAIRLINK\n         L     R15,732(,R15)\n         BALR  R14,R15\n         B     DAIRFINI\nDAIRLINK EQU   *\n         LINK  EP=IKJDAIR,SF=(E,LINKAREA)\nDAIRFINI L     R14,DAIRREGS\n         BR    R14\n         SPACE\n************************************************************\n*                                                          *\n*        DYNAMIC ALLOCATION FAILURE ROUTINE                *\n*                                                          *\n************************************************************\n         SPACE\nDAIRFAIL ST    R14,MYDFREGS\n         LA    R1,MYDFPARM\n         USING DFDSECTD,R1\n         ST    R15,MYDFRC\n         LA    R15,MYDFRC\n         ST    R15,DFRCP\n         LA    R15,MYDAPL\n         ST    R15,DFDAPLP\n         SLR   R15,R15\n         ST    R15,MYJEFF02\n         LA    R15,MYJEFF02\n         ST    R15,DFJEFF02\n         LA    R15,DFDAIR\n         STH   R15,MYDFID\n         LA    R15,MYDFID\n         ST    R15,DFIDP\n         SLR   R15,R15\n         ST    R15,DFCPPLP\n         LINK  EP=IKJEFF18,SF=(E,LINKAREA)\n         L     R15,MYDFRC\n         DROP  R1                  DFDSECTD\n         L     R14,MYDFREGS\n         BR    R14\n         SPACE\n************************************************************\n*                                                          *\n*        PUTMSG ROUTINE                                    *\n*                                                          *\n************************************************************\n         SPACE\nPUTMSG   STM   R14,R1,PUTLINS\n         XC    MYOLD(8),MYOLD\n         XC    MYSEG1(4),MYSEG1\n         MVC   MYPTPB(12),MODLPTPM\n         LA    R14,1               NO. OF MESSAGE SEGMENTS\n         ST    R14,MYOLD\n         LA    R14,MYSEG1          POINT TO 1ST SEGMENT\n         ST    R14,MYOLD+4\n         LR    R14,R0              LENGTH IN R0\n         LA    R14,4(,R14)         ADD 4\n         LA    R15,MYSEG1+4\n         CLC   0(3,R1),=C'IKJ'     IS DATA PRECEEDED BY MESSAGE ID?\n         BE    *+16                YES - BRANCH\n         LA    R14,1(,R14)         ADD 1 TO LENGTH\n         MVI   0(R15),C' '         INSERT LEADING BLANK\n         LA    R15,1(,R15)         BUMP POINTER\n         STH   R14,MYSEG1\n         LR    R14,R0\n         BCTR  R14,0\n         B     *+10\n         MVC   0(0,R15),0(R1)      MOVE MESSAGE IN\n         EX    R14,*-6\n         L     R15,MYPUTLEP\n         SPACE\n         PUTLINE PARM=MYPTPB,OUTPUT=(MYOLD),ENTRY=(15),MF=(E,MYIOPL)\n         SPACE\n         LM    R14,R1,PUTLINS\n         BR    R14\n         SPACE\n************************************************************\n*                                                          *\n*        PUTLINE ROUTINE                                   *\n*                                                          *\n************************************************************\n         SPACE\nPUTLINE  STM   R14,R1,PUTLINS\n         XC    MYSEG1(4),MYSEG1\n         MVC   MYPTPB(12),MODLPTPB\n         LR    R14,R0              LENGTH IN R0\n         LA    R14,4(,R14)         ADD 4\n         STH   R14,MYSEG1\n         LR    R14,R0\n         BCTR  R14,0\n         B     *+10\n         MVC   MYSEG1+4(0),0(R1)   MOVE TEXT IN\n         EX    R14,*-6\n         LA    R1,MYIOPL\n         L     R15,MYPUTLEP\n         SPACE\n         PUTLINE PARM=MYPTPB,OUTPUT=(MYSEG1,DATA),ENTRY=(15),MF=(E,(1))\n         SPACE\n         LM    R14,R1,PUTLINS\n         BR    R14\n         SPACE 1\n*RRRECFM LA    R1,MSGRECFM\n*        LA    R0,L'MSGRECFM\n*        BAL   R14,PUTMSG\n*        B     QUITD12\n         SPACE\nTOHEX    MVC   1(1,R15),0(R1)\n         UNPK  0(3,R15),1(2,R15)\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)\n         LA    R1,1(,R1)\n         BCT   R0,TOHEX\n         MVI   0(R15),C' '\n         BR    R14\n         SPACE\nEXIT     LR    R2,R15              SAVE R15\n         LR    R1,R10\n         L     R0,@SIZE24\n         FREEMAIN R,A=(1),LV=(0)\n         SPACE\n         LR    R1,R13\n         L     R0,@SIZE31\n         L     13,4(,13)\n         FREEMAIN RU,A=(1),LV=(0),SP=1\n         LR    R15,R2              RESTORE R15\n         LM    0,12,20(13)\n         L     14,12(,13)\n         BR    14\n         SPACE\n************************************************************\n*                                                          *\n*        SYNAD EXIT                                        *\n*                                                          *\n************************************************************\n         SPACE\n*        THIS ROUTINE IS ENTERED DURING THE 'GET' MACRO\n*        IF AN I/O ERROR OCCURS.\n         SPACE\nDYNSYNAD EQU   *\n         SYNADAF ACSMETH=QSAM\n         MVC   SYNADMSG(78),50(R1)\n         MVI   SYNADSW,X'FF'\n         SYNADRLS\n         BR    R14\n         SPACE\n************************************************************\n*                                                          *\n*        GLUE FOR DCB EXITS                                *\n*                                                          *\n************************************************************\n         SPACE\n*        THESE 2 INSTRUCTIONS ARE COPIED TO ABENDXIT, BELOW THE LINE,\n*        AND RUN THERE, NOT HERE. WHEN ABENDXIT IS ENTERED,\n*        R15 CONTAINS THE ENTRY ADDRESS, THE ADDRESS OF ABENDXIT.\n*        THEN USING R15 AS A BASE REGISTER, IT LOADS R15 FROM ABENDXAD,\n*        WHICH CONTAINS THE ADDRESS OF DYNABEND ABOVE THE LINE,\n*        WITH THE HIGH-ORDER BIT SET TO 1. THEN IT USES BSM TO\n*        BRANCH TO DYNABEND IN 31-BIT MODE. THE ROUTINE AT\n*        DYNABEND SHOULD RETURN USING 'BSM 0,R14'.\n*\nGLUE     L     R15,ABENDXAD-ABENDXIT(,R15)\n         BSM   R14,R15  OLD MODE INTO R14 HI BIT, BRANCH TO R15 IN 31\nGLUELEN  EQU   *-GLUE\n         SPACE\n*        SINCE ABENDXAD-ABENDEXIT IS IDENTICAL TO OPENEXAD-OPENEXIT\n*        THE FOLLOWING IS NOT REALLY NEEDED.\n         SPACE\nGLUE2    L     R15,OPENEXAD-OPENEXIT(,R15)\n         BSM   R14,R15  OLD MODE INTO R14 HI BIT, BRANCH TO R15 IN 31\nGLUELEN2 EQU   *-GLUE2\n         SPACE\n************************************************************\n*                                                          *\n*        CONSTANTS                                         *\n*                                                          *\n************************************************************\n         SPACE\nMODLPTPM PUTLINE OUTPUT=(1,TERM,SINGLE,INFOR),                         X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=L\n         SPACE\nMODLPTPB PUTLINE OUTPUT=(1,TERM,SINGLE,DATA),                          X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=L\n         SPACE\n*        PRINT NOGEN\n         SPACE\nOPEN31   OPEN  (0,),MODE=31,MF=L\nOPEN31L  EQU   *-OPEN31\nCLOSE31  CLOSE (0,),MODE=31,MF=L\nCLOSE31L EQU   *-CLOSE31\n         SPACE\nDYNDCB   DCB   DDNAME=DYNAM,DSORG=PS,MACRF=(GL),                       +\n               EODAD=0,SYNAD=0,EROPT=ACC,DCBE=0\nDYNDCBL  EQU   *-DYNDCB\n         SPACE\nDYNDCBE  DCBE  RMODE31=BUFF,EODAD=1\nDYNDCBEL EQU   *-DYNDCBE\n         SPACE\n         PRINT GEN\n         SPACE\nOBTAIN   CAMLST SEARCH,2,3,4\nOBTAINL  EQU   *-OBTAIN\n         SPACE\nLOCATE   CAMLST NAME,2,,4\nLOCATEL  EQU   *-LOCATE\n         SPACE\nSTACKD   STACK DELETE=ALL,MF=L\nSTACKDL  EQU   *-STACKD\n         SPACE\n         AGO   .SKIP1\nSHA1PI   DC    X'67452301' H0\n         DC    X'EFCDAB89' H1\n         DC    X'98BADCFE' H2\n         DC    X'10325476' H3\n         DC    X'C3D2E1F0' H4\n         DC    X'00000000' MESSAGE BIT LENGTH HIGH\n         DC    X'00000000' MESSAGE BIT LENGTH LOW\n.SKIP1   ANOP\n         SPACE\n         AGO   .SKIP2\nSHA2PI   DC    X'6A09E667' H0\n         DC    X'BB67AE85' H1\n         DC    X'3C6EF372' H2\n         DC    X'A54FF53A' H3\n         DC    X'510E527F' H4\n         DC    X'9B05688C' H5\n         DC    X'1F83D9AB' H6\n         DC    X'5BE0CD19' H7\n         DC    X'00000000' MESSAGE BIT LENGTH HIGH\n         DC    X'00000000' MESSAGE BIT LENGTH LOW\n.SKIP2   ANOP\n         SPACE\nSHA3PI   DC    X'CBBB9D5D' H0\n         DC    X'C1059ED8' H0\n         DC    X'629A292A' H1\n         DC    X'367CD507' H1\n         DC    X'9159015A' H2\n         DC    X'3070DD17' H2\n         DC    X'152FECD8' H3\n         DC    X'F70E5939' H3\n         DC    X'67332667' H4\n         DC    X'FFC00B31' H4\n         DC    X'8EB44A87' H5\n         DC    X'68581511' H5\n         DC    X'DB0C2E0D' H6\n         DC    X'64F98FA7' H6\n         DC    X'47B5481D' H7\n         DC    X'BEFA4FA4' H7\n         DC    X'00000000' MESSAGE BIT LENGTH HIGH\n         DC    X'00000000' MESSAGE BIT LENGTH HIGH\n         DC    X'00000000' MESSAGE BIT LENGTH LOW\n         DC    X'00000000' MESSAGE BIT LENGTH LOW\n         SPACE\n         AGO   .SKIP5\nSHA5PI   DC    X'6A09E667' H0\n         DC    X'F3BCC908' H0\n         DC    X'BB67AE85' H1\n         DC    X'84CAA73B' H1\n         DC    X'3C6EF372' H2\n         DC    X'FE94F82B' H2\n         DC    X'A54FF53A' H3\n         DC    X'5F1D36F1' H3\n         DC    X'510E527F' H4\n         DC    X'ADE682D1' H4\n         DC    X'9B05688C' H5\n         DC    X'2B3E6C1F' H5\n         DC    X'1F83D9AB' H6\n         DC    X'FB41BD6B' H6\n         DC    X'5BE0CD19' H7\n         DC    X'137E2179' H7\n         DC    X'00000000' MESSAGE BIT LENGTH HIGH\n         DC    X'00000000' MESSAGE BIT LENGTH HIGH\n         DC    X'00000000' MESSAGE BIT LENGTH LOW\n         DC    X'00000000' MESSAGE BIT LENGTH LOW\n.SKIP5   ANOP\nHEXTAB   DC    C'0123456789ABCDEF'\nMSG01    DC    C'ERROR IN PARSE SERVICE ROUTINE'\nMSG02    DC    C'IKJ58503I DATA SET '\nMSG02A   DC    C' NOT IN CATALOG'\nMSG03    DC    C'ERROR IN DEFAULT SERVICE ROUTINE'\nMSG04    DC    C'UNABLE TO OPEN DATASET'\nMSG05    DC    C'IKJ58509I DATA SET NAME REQUIRED WHEN MEMBER IS SPECIF+\n               IED'\nMSG06    DC    C'ORGANIZATION OF DATA SET MUST BE PARTITIONED OR SEQUEN+\n               TIAL'\nMSG07    DC    C'DATA SET IS PARTITIONED, MEMBER NOT SPECIFIED'\nMSG08    DC    C'SPECIFIED MEMBER NOT FOUND IN DATASET'\nMSG09    DC    C'UNABLE TO OBTAIN DSCB FOR DATA SET'\nMSG14    DC    C'FILENAME '\nMSG14A   DC    C' INVALID, MORE THAN 8 CHARACTERS  '\nMSG14B   DC    C' IS NOT CURRENTLY ALLOCATED       '\nMSG14C   DC    C' NOT ALLOCATED TO A DASD DATA SET '\n*SGRECFM DC    C'RECORD FORMAT U NOT SUPPORTED'\n*MSGDAIR DC    C'UNABLE TO ALLOCATE'\nLOWTABLE DC    0D'0',256AL1(*-LOWTABLE)\n         ORG   LOWTABLE+C'A'\n         DC    X'818283848586878889'\n         ORG   LOWTABLE+C'J'\n         DC    X'919293949596979899'\n         ORG   LOWTABLE+C'S'\n         DC    X'A2A3A4A5A6A7A8A9'\n         ORG\n         LTORG\nPCLADDR  DC    0D'0'               END OF CSECT\n         SPACE\n************************************************************\n*                                                          *\n*        PARSE PARAMETERS                                  *\n*                                                          *\n************************************************************\n         SPACE\n         PRINT NOGEN\nSHASMPCL RMODE 31\nSHASMPCL IKJPARM\nDSN      IKJPOSIT DSNAME,LIST,PROMPT='DATA SET NAME'\nFILEKW   IKJKEYWD\n         IKJNAME 'FILE'\nQUICKW   IKJKEYWD\n         IKJNAME 'QUICK'\nRDWKW    IKJKEYWD\n         IKJNAME 'RDW'\nLOWKW    IKJKEYWD\n         IKJNAME 'LOWER'\nBRIEFKW  IKJKEYWD\n         IKJNAME 'BRIEF'\nMULTIKW  IKJKEYWD\n         IKJNAME 'MULTI'\nHALFKW   IKJKEYWD\n         IKJNAME 'HALF'\n         IKJENDP\n         PRINT GEN\n         SPACE\n************************************************************\n*                                                          *\n*        DSECTS                                            *\n*                                                          *\n************************************************************\n         SPACE\n@DATA31  DSECT\n         DS    18F                 REGISTER SAVEAREA\nLINKAREA DS    2F\nMYPPL    DS    7F\nMYANS    DS    F\nMYECB    DS    F                  USED BY PUTLINE ROUTINE\nMYIOPL   DS    4F                 USED BY PUTLINE ROUTINE\nMYPTPB   DS    3F                 USED BY PUTLINE ROUTINE\nMYOLD    DS    2F                 USED BY PUTLINE ROUTINE\nMYSEG1   DS    2H,CL256           USED BY PUTLINE ROUTINE\nPUTLINS  DS    4F                 USED BY PUTLINE ROUTINE\nMYPUTLEP DS    F                  ADDRESS OF IKJPUTL\nMYSTPB   DS    0F                 5 WORDS USED BY STACK DELETE\nMYDAPL   DS    5F\nMYDAPB   DS    21F\nDSNAME   DS    H,CL44\nMEMLEN   DS    H\nMEMNAME  DS    CL8\nVOLSER   DS    CL6\nLOCATEW  DS    0F\nOBTAINW  DS    4F\nLOCBUF   DS    0D                  USES NEXT 265 BYTES\nMYDSCB   DS    CL140               96 BYTES OF DSCB, 5 BYTES CCHHR\nMSGWK    DS    CL200               INCREASED FROM 128 FOR SHA5SUM\nSTATUS   DS    X\nRETCODE  DS    H\nMYDFPARM DS    5F  USED BY DAIRFAIL\nMYDFREGS DS    F   USED BY DAIRFAIL\nMYDFRC   DS    F   USED BY DAIRFAIL\nMYJEFF02 DS    F   USED BY DAIRFAIL\nMYDFID   DS    H   USED BY DAIRFAIL\nDOUBLE   DS    D\nEIGHT    DS    CL8\nDDSAVE   DS    CL8\nDAIRREGS DS    F\nOPEND    DS    0F,(OPEN31L)X\nCLOSED   DS    0F,(CLOSE31L)X\nDYNDCBEW DS    0F,(DYNDCBEL)X\nKOUNT    DS    F\nKOUNTSP  DS    F\nSYNADSW  DS    F\nSYNADMSG DS    CL78\nDEVDATA  DS    2F\nGETREGS  DS    5F\nPUTREGS  DS    8F\nI128     DS    F\nDSL      DS    F\nMSGL     DS    F\nGOTEOD   DS    C\nOPTR     DS    C\n*SHA1PB  DS    0D,7F 5F PLUS 2F MESSAGE BIT LENGTH\n*SHA2PB  DS    5D    8F PLUS 2F MESSAGE BIT LENGTH\nSHA5PB   DS    10D   8D PLUS 4F MESSAGE BIT LENGTH\nFILESIZE DS    D\nIBUF     DS    CL128\n         DS    0D\n@DATA31L EQU   *-@DATA31\n         SPACE\n@DATA24  DSECT\nSAVE24   DS    18F                USED BY IKJEHDEF\nRDJFW    DS    F\nMYIOPL24 DS    4F                 USED BY IKJEHDEF\nMYECB24  DS    F\nMYDFPB   DS    5F\nDSNAME24 DS    H,CL44\nDYNDCBW  DS    0D,XL(DYNDCBL)\nDYNEXLST DS    2F\nOPENEXIT DS    0H,(GLUELEN)X\nOPENEXAD DS    F  X'80' + ADDRESS OF DYNOPENX\nABENDXIT DS    0H,(GLUELEN)X\nABENDXAD DS    F  X'80' + ADDRESS OF DYNABEND\nJFCB     DS    0F,CL176\nMYARL    DS    9F\nTBUF     DS    CL8\n         DS    0D\n@DATA24L EQU   *-@DATA24\n         SPACE\nIHADCB   DSECT\nDCBDCBE  DS    A\n         DS    28XL1\nDCBBFTEK DS    XL1\nDCBEODAD DS    AL3\nDCBEXLST DS    0A\nDCBRECFM DS    X\nDCBEXLSA DS    AL3\nDCBDDNAM DS    CL8\nDCBOFLGS DS    X\n         DS    7XL1\n         DS    X\nDCBSYNAD DS    AL3\nDCBBLKSI EQU   IHADCB+62,2\nDCBLRECL EQU   IHADCB+82,2\n         SPACE\n         IHADCBE\n         SPACE\nEFLG1    EQU   16\nEOPEN    EQU   X'80'\nEMD31    EQU   X'40'\nEEODA    EQU   40\nESYNA    EQU   44\n         SPACE\nXFLG1    EQU   DCBEFLG1-DCBE\nXOPEN    EQU   DCBEOPEN\nXMD31    EQU   DCBEMD31\nXEODA    EQU   DCBEEODA-DCBE\nXSYNA    EQU   DCBESYNA-DCBE\n         PRINT NOGEN\n         SPACE\n         IKJCPPL\n         SPACE 3\n         IKJPPL\n         SPACE\n         IKJDFPB\n         SPACE 2\n         IKJUPT\n         SPACE 2\n         IKJIOPL\n         SPACE 2\n         IKJDAPL\n         SPACE 2\n         IKJDAP08\n         SPACE 2\n         IKJDAP18\n         SPACE 2\n         IKJPSCB\n         SPACE 2\n         IKJEFFDF DFDSECT=YES\n         SPACE\n         IHAARL\n         SPACE\n         IHAARA\n         SPACE\n*        CVT   DSECT=YES\n         SPACE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SHA3SUM#": {"ttr": 7685, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x16$\\x1f\\x01\\x16$\\x1f#V\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-08-28T00:00:00", "modifydate": "2016-08-28T23:56:20", "lines": 27, "newlines": 27, "modlines": 0, "user": "UPDATED"}, "text": ")F FUNCTION -\n  THE SHA3SUM COMMAND DISPLAYS THE SHA-384 HASH OF DATA SETS.\n  IN DATA SETS WITH VARIABLE-LENGTH RECORDS THE RDW'S AND SDW'S ARE\n  NOT INCLUDED WHEN THE CHECKSUM IS COMPUTED UNLESS THE RDW KEYWORD\n  IS SPECIFIED.\n)X SYNTAX -\n         SHA5SUM  'DSLIST'  FILE  LOWER  RDW  BRIEF  MULTI  HALF QUICK\n\n  REQUIRED - 'DSLIST'\n  DEFAULTS - NONE\n\n)O OPERANDS -\n  'DSLIST' - NAMES OF SEQUENTIAL DATA SETS OR MEMBERS OF PARTITIONED\n             DATA SETS. IF MORE THAN ONE, ENCLOSE LIST IN PARENTHESES.\n))FILE     - THE NAMES IN DSLIST ARE DDNAMES, NOT DSNAMES.\n))LOWER    - DISPLAY THE RESULTS IN LOWER CASE.\n))RDW      - INCLUDE RDW OR SDW IN VARIABLE LENGTH RECORDS.\n))BRIEF    - DISPLAY ONLY THE HASH, WITHOUT THE DATA SET NAME.\n))MULTI    - DISPLAY THE HASH AND DATA SET NAME ON SEPARATE LINES.\n))HALF     - DISPLAY THE HASH IN TWO LINES. IMPLIES BRIEF BUT\n             HALF AND MULTI TOGETHER GIVES DATA SET NAME TOO.\n))QUICK    - FOR UNQUOTED DSNAMES, BYPASS THE DEFAULT SERVICE ROUTINE.\n             SO FOR EXAMPLE, IF YOU SPECIFY THE NAME TEMP AND YOU\n             ONLY HAVE A DATA SET NAMED TEMP.DATA, IT WON'T BE FOUND\n             IF QUICK IS ALSO SPECIFIED. THE QUICK KEYWORD IS JUST\n             TO CUT OUT THE OVERHEAD OF LOOKING FOR EXTENSIONS AT\n             THE END OF THE SPECIFIED DATA SET NAME.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SHA5SUM": {"ttr": 7687, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\t\\x01\\x16$\\x1f\\x01\\x19\\x07\\x7f\\x131\\x05\\xc0\\x05\\xab\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2016-08-28T00:00:00", "modifydate": "2019-03-18T13:31:09", "lines": 1472, "newlines": 1451, "modlines": 0, "user": "UPDATED"}, "text": "         TITLE '   S H A 5 S U M  '\n************************************************************\n*                                                          *\n*        'SHA5SUM' TSO COMMAND (31-BIT)                    *\n*                                                          *\n************************************************************\n         SPACE\n*        WRITTEN MAY 22 2016 USING MD5SUM AS A TEMPLATE.\n*         NOTE: MD5SUM USED 'COUNT' (CBT FILE 300) AS A TEMPLATE.\n*        ATTRIBUTES. RE-ENTRANT.\n*        UPDATED MAY 27 2016 TO ADD BRIEF AND MULTI KEYWORDS.\n*        UPDATED AUG 28 2016 TO IGNORE DS1LSTAR WHICH IS 0 FOR PDSE\n*        UPDATED AUG 28 2016 TO CREATE SHA5SUM FROM SHA2SUM SOURCE\n*        UPDATED SEP  3 2016 TO SET RETURN CODE 12 IF ANY ERROR\n*        UPDATED DEC 27 2017 TO SUPPORT 8-BYTE PREFIX IN Z/OS V2R3\n*        UPDATED MAR 18 2019 TO SUPPORT EAV VOLUMES (SEE CHANGES BELOW)\n*\n*        THIS TSO COMMAND READS THE SPECIFIED SEQUENTIAL DATA SETS\n*        OR PDS MEMBERS AND DISPLAYS THE SHA-2 512-BIT HASH FOR EACH.\n*        SHA = SECURE HASH ALGORITHM.\n*\n*        SYNTAX:\n*                SHA5SUM DSNAME\n*                SHA5SUM (DSNAME1 DSNAME2 ...)\n*        KEYWORDS:\n*                RDW - INCLUDE RDW'S\n*                LOWER - SHOW RESULTS IN LOWER CASE\n*                QUICK - DSNAME IS COMPLETE, NO IMPLIED EXTENSION\n*                FILE - DSNAME IS A DDNAME ALREADY ALLOCATED\n*                BRIEF - SHOW THE HASH ONLY, WITH NO DSNAME\n*                MULTI - SHOW THE HASH AND DSNAME ON SEPARATE LINES\n*                HALF  - SHOW THE HASH IN TWO LINES, IMPLIES BRIEF\n*                        BUT HALF AND MULTI TOGETHER SHOWS DSNAME TOO\n*\n*        IF AN UNQUALIFIED DATA SET NAME IS ENTERED, THE\n*        CATALOG MUST BE READ TWICE, ONCE TO APPEND A\n*        TRAILING QUALIFIER IF NECESSARY, AND AGAIN DURING\n*        ALLOCATION. THE USER CAN ELIMINATE THE FIRST BY USING\n*        THE FULLY QUALIFIED NAME, PREFIX AND ALL, IN QUOTES,\n*        OR BY ENTERING ALL BUT THE PREFIX, WITHOUT QUOTES,\n*        PLUS THE KEYWORD 'Q'. THE LATTER IS MUCH SIMPLER\n*        AND GIVES THE SAME PERFORMANCE IMPROVEMENT AS A\n*        FULLY QUALIFIED NAME.\n*\n*        THE 'FILE' KEYWORD IS USEFUL FOR READING TEMPORARY\n*        DATA SETS.  IT TELLS THE COMMAND TO TREAT THE FIRST\n*        OPERAND AS A FILENAME (DDNAME) INSTEAD OF A DSNAME.\n*        WHATEVER DATA SET IS CURRENTLY ALLOCATED TO THE\n*        FILENAME WILL BE READ (AND QUICKLY, BECAUSE\n*        THE COMMAND DOESNT HAVE TO ALLOCATE ANYTHING).\n*\n*        UNIX FILES THAT ARE PREALLOCATED TO A DDNAME CAN BE\n*        READ. FOR EXAMPLE:\n*         ALLOC FI(DD1) PATH('/ETC/MAGIC') (BUT USE PATH IN LOWER CASE)\n*         SHA5SUM DD1 FILE\n*        IF UNIX FILES ARE NOT GIVEN RECFM WHEN ALLOCATED\n*        THEY DEFAULT TO RECFM=U, WHICH IS GOOD FOR SHA5SUM.\n*        RECFM=F WOULD BE LIKELY TO INTRODUCE PADDING IN THE\n*        LAST RECORD, WHICH WOULD CHANGE THE SHA5SUM RESULT.\n*\n*        NOTE - IF A NON-EXISTENT MEMBER OF A PDS IS SPECIFIED,\n*        THE RESULTING 013-18 ABEND IS TRAPPED BY A DCB ABEND\n*        EXIT, BUT A MESSAGE IS ISSUED BY OPEN ANYWAY. THIS\n*        METHOD IS USED BECAUSE THE ADDITIONAL OVERHEAD\n*        OF ALLOCATING THE PDS AND DOING A 'BLDL' WOULD\n*        DEGRADE THE PERFORMANCE UNACCEPTABLY.\n*\n*        PROBLEMS FIXED:\n*        . IF THE SPECIFIED DDNAME (WITH 'FILE' KEYWORD) IS\n*          A MEMBER OF A PDS, ONLY THE PDS NAME WAS SHOWN.\n*          ADDED CODE TO GET MEMBER NAME FROM JFCBELNM.\n*        . IF THE SPECIFIED DDNAME (WITH 'FILE' KEYWORD) IS\n*          A UNIX PATH, ONLY \"...PATH=.SPECIFIED...\" IS SHOWN,\n*          THAT'S WHAT IS IN THE JFCB. ADDED ARL TO GET PATH.\n*\n*        IMPROVEMENTS NEEDED:\n*        . ALLOW PATH TO BE SPECIFIED AND ALLOCATE IT.\n*        . IF THE SPECIFIED DDNAME (WITH 'FILE' KEYWORD) IS\n*          A CONCATENATION, SHOW MORE THAN THE FIRST DSN OR PATH.\n*\n* CHNGE LOG: 02JUN92 - INCLUDED 'OBTAIN' MACRO IN THE SOURCE. WITH\n*                      MVS/XA 2.2.3, THE MACRO IS ONLY AVAILABLE IN\n*                      'SYS1.AMACLIB' (SOUNDS LIKE IBM IS TRYING TO\n*                      TELL US SOMETHING).  JIM MARSHALL         JDM1\n*\n* CHNGE LOG: 12OCT13 - MD5SUM COMMAND CREATED FROM SOURCE OF 'COUNT'.\n*                      RDW'S ARE NOT INCLUDED IN THE MD5 AT THIS TIME,\n*                      AS A RESULT, 2 FILES OF VARIABLE-LENGTH RECORDS,\n*                      ONE WITH 2 RECORDS \"AB\" AND \"CD\" AND THE OTHER\n*                      ONE WITH 2 RECORDS \"ABC' AND \"D\" WILL HAVE THE\n*                      SAME MD5 VALUE.\n*\n* CHNGE LOG: 11NOV13 - SUPPORT LIST OF DSNAMES, SHOW NAME AFTER MD5.\n*\n* CHNGE LOG: 12NOV13 - CONVERT TO 31-BIT.\n*\n* CHNGE LOG: 15NOV13 - ALLOW NON-DASD DEVTYPE INCLUDING UNIX AND DUMMY.\n*                      SHOW UNIX FILE NAME IF DDNAME ALLOCATED TO PATH.\n*                      SHOW MEMBER NAME IF DDNAME ALLOCATED TO MEMBER.\n*\n* CHNGE LOG: 13MAR19 - REVERSED THE CHANGE FROM JUNE 02, 1992 AND USED\n*                      THE ORIGINAL OBTAIN MACRO AGAIN. ADDITIONALLY\n*                      ADDED THE EADSCB=OK MACRO PARAMETER.\n*\n*--------------------------------------------------------------------\n*         MACRO                                                  JDM1\n*&NAME    OBTAIN &LIST,&DUMMY=                                   JDM1\n*         AIF   (T'&LIST EQ 'O').E1                              JDM1\n*&NAME    IHBINNRA &LIST                 LOAD REG 1              JDM1\n*         SVC   27                       ISSUE OBTAIN SVC        JDM1\n*         MEXIT                                                  JDM1\n*.E1      IHBERMAC 34                    LIST ADDR MISSING       JDM1\n*         MEND                                                   JDM1\n*--------------------------------------------------------------------\n*         INTERCEPT 'LINK' MACRO IMBEDDED IN STACK MACRO\n*         TO MAKE SF=(E,LINKAREA) THE DEFAULT.\n         MACRO\n&NAME    LINK  &EP=,&SF=(E,LINKAREA)\n&NAME    LA    15,&SF(2)\n         LA    0,*+8\n         B     *+12\n         DC    CL8'&EP'\n         ST    0,0(0,15)\n         SVC   6             ISSUE LINK SVC\n         MEND\n         SPACE\nSHA5SUM  START\nSHA5SUM  AMODE 31\nSHA5SUM  RMODE 31\n         USING *,R12,R11\n         B     @PROLOG-*(,R15)\n         DC    AL1(7),CL7'SHA5SUM'\n         DC    CL16' &SYSDATE &SYSTIME '\n@SIZE31  DC    0F'0',AL1(0),AL3(@DATA31L)\n@SIZE24  DC    0F'0',AL1(1),AL3(@DATA24L)\n@PROLOG  STM   14,12,12(13)\n         LR    R12,R15             BASE\n         LA    R15,1\n         LA    R11,4095(R15,R12)   BASE\n         LR    R2,R1\n         USING CPPL,R2\n         L     R0,@SIZE31\n         GETMAIN RU,LV=(0),SP=1,LOC=31\n         LR    R9,R1\n         USING @DATA31,R9\n         ST    13,4(,1)            CHAIN SAVEAREA\n         ST    1,8(,13)            CHAIN SAVEAREA\n         LR    13,1                NEW SAVEAREA\n         SPACE\n         L     R0,@SIZE24\n         GETMAIN R,LV=(0)\n         LR    R10,R1\n         USING @DATA24,R10\n         SPACE\n         MVI   STATUS,0\n         XC    LINKAREA(8),LINKAREA\n         SLR   R15,R15\n         STH   R15,RETCODE         SET RETCODE = 0\n         ST    R15,KOUNT\n         ST    R15,KOUNTSP\n         SPACE\n************************************************************\n*                                                          *\n*        SET UP IOPL FOR PUTLINE                           *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R15,MYIOPL\n         USING IOPL,R15\n         MVC   IOPLUPT(4),CPPLUPT\n         MVC   IOPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,IOPLECB\n         XC    MYECB,MYECB\n         LA    R0,MYPTPB\n         ST    R0,IOPLIOPB\n         DROP  R15                 IOPL\n         SPACE\n         L     R15,16              LOAD CVT POINTER\n         TM    444(R15),X'80'      IS PUTLINE LOADED? (VS2)\n         BNO   PUTLOAD             NO - BRANCH TO LOAD\n         L     R15,444(,R15)       YES - USE CVTPUTL\n         B     PUTLOADX            BRANCH AROUND LOAD\nPUTLOAD  LA    R0,=CL8'IKJPUTL '\n         LOAD  EPLOC=(0)\n         LR    R15,R0              GET ENTRY ADDRESS\n         LA    R15,0(,R15)         CLEAR HI BYTE FOR DELETE ROUTINE\nPUTLOADX ST    R15,MYPUTLEP        SAVE PUTLINE ENTRY ADDRESS\n         SPACE\n************************************************************\n*                                                          *\n*        SET UP PPL FOR PARSE                              *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R15,MYPPL\n         USING PPL,R15\n         MVC   PPLUPT(4),CPPLUPT\n         MVC   PPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,PPLECB\n         XC    MYECB,MYECB\n         L     R0,=A(SHASMPCL)\n*        LA    R0,PCLADDR\n         ST    R0,PPLPCL\n         LA    R0,MYANS\n         ST    R0,PPLANS\n         XC    MYANS(4),MYANS\n         MVC   PPLCBUF(4),CPPLCBUF\n         ST    R9,PPLUWA\n         DROP  R15                 PPL\n         SPACE 1\n************************************************************\n*                                                          *\n*        CALL THE PARSE SERVICE ROUTINE                    *\n*                                                          *\n************************************************************\n         SPACE\n         LR    R1,R15              POINT TO PPL\n*        CALLTSSR EP=IKJPARS\n         L     R15,16              CVTPTR\n         TM    524(R15),X'80'      IF HI ORDER BIT NOT ON\n         BNO   PARSELNK               THEN DO LINK, NOT CALL\n         L     R15,524(,R15)       CVTPARS\n         BALR  R14,R15             CALL IKJPARS\n         B     PARSEEXT            SKIP AROUND LINK\nPARSELNK EQU   *\n         LINK  EP=IKJPARS,SF=(E,LINKAREA)\nPARSEEXT EQU   *\n         SPACE 1\n         LTR   R15,R15\n         BZ    PARSEOK\n         LA    R1,MSG01\n         LA    R0,L'MSG01\n         BAL   R14,PUTMSG\n         LA    R15,12\n         B     EXIT\nPARSEOK  EQU   *\n         SPACE\n         L     R3,MYANS\n         USING IKJPARMD,R3\n         SPACE\n         MVC   OPTR,RDWKW+1\n         SPACE\n************************************************************\n*                                                          *\n*        GET THE FIRST OR NEXT DSN IN THE LIST             *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R6,DSN\n         ST    R6,DSL\n         B     FIRSTDSN\nNEXTDSN  L     R6,DSL\n         CLI   24(R6),X'FF'        END OF DSN LIST?\n         BE    DONE\n         L     R6,24(,R6)          POINT TO NEXT ENTRY\n         ST    R6,DSL\nFIRSTDSN SR    R0,R0\n         ST    R0,KOUNT\n         SPACE\n************************************************************\n*                                                          *\n*        QUALIFY THE DSNAME IF NECESSARY                   *\n*                                                          *\n************************************************************\n         SPACE\n         TM    6(R6),X'80'         IS DATASET NAME SPECIFIED?\n         BO    OKDSN               YES - BRANCH\n         LA    R1,MSG05            NO - JUST MEMBER NAME\n         LA    R0,L'MSG05\n         BAL   R14,PUTMSG\n         B     NEXTD12\nOKDSN    EQU   *\n         LA    R15,DSNAME+2\n         MVI   0(R15),C' '         BLANK THE DSNAME AREA\n         MVC   1(43,R15),0(R15)\n         SLR   R1,R1\n         STH   R1,DSNAME           ZERO DSNAME LENGTH\n         TM    6(R6),X'40'         IS DSN QUOTED?\n         BO    NOPREF              YES, SKIP PREFIXING\n         CLI   FILEKW+1,1          DSN TO BE TREATED AS DDNAME\n         BE    NOPREF              YES, SKIP PREFIXING\n         L     R14,CPPLUPT         POINT TO UPT\n         USING UPT,R14\n*         CHECK UPT FOR 8-BYTE PREFIX - Z/OS V2R3.\n         CLI   UPTPREFX,C'>'      IF PREFIX IS '>7BYTES' (8 BYTES)\n         BNE   PREF07                THEN\n         IC    R1,UPTPREFL+18        GET UPTPRF8L (SHOULD ALWAYS BE 8)\n         LTR   R1,R1                 IS IT ZERO\n         BZ    NOPREF                YES, SKIP PREFIXING\n         B     *+10\n         MVC   0(0,R15),UPTPREFX+17  COPY UPTPREF8\n         EX    R1,*-6              MOVE USERID TO DSNAME AREA\n         B     PREFDONE\nPREF07   EQU   *\n         IC    R1,UPTPREFL         GET LENGTH OF PREFIX\n         LTR   R1,R1               IS IT ZERO\n         BZ    NOPREF              YES, SKIP PREFIXING\n         B     *+10\n         MVC   0(0,R15),UPTPREFX\n         EX    R1,*-6              MOVE USERID TO DSNAME AREA\nPREFDONE EQU   *\n         DROP  R14                 UPT\n         LA    R15,0(R1,R15)       POINT PAST USERID\n         MVI   0(R15),C'.'         APPEND PERIOD\n         LA    R15,1(,R15)         POINT PAST PERIOD\n         LA    R1,1(,R1)           ADD 1 TO LENGTH\n         STH   R1,DSNAME           STORE LENGTH OF USERID PLUS 1\nNOPREF   EQU   *\n         LH    R1,4(,R6)           GET LENGTH\n         LR    R0,R1\n         AH    R0,DSNAME           ADD LENGTH OF PREFIX OR ZERO\n         STH   R0,DSNAME           SET COMBINED LENGTH\n         L     R14,0(,R6)          POINT TO DSN VALUE\n         BCTR  R1,0                LENGTH MINUS 1 FOR EX\n         B     *+10                BRANCH AROUND EXECUTED MVC\n         MVC   0(0,R15),0(R14)     (EXECUTED)\n         EX    R1,*-6              MOVE DSN TO DSNAME (AFTER PREFIX)\n         SPACE\n************************************************************\n*                                                          *\n*        IF 'FILE' KEYWORD IS SPECIFIED,                   *\n*        GET DSNAME FROM JFCB USING FILE NAME.             *\n*                                                          *\n************************************************************\n         SPACE\n         CLI   FILEKW+1,1          'FILE' SPECIFIED?\n         BNE   NOFILE              NO, BRANCH\n         CLI   DSNAME+1,8          IS LENGTH 8 OR LESS\n         BH    FILERR1             NO, BRANCH\n         DEVTYPE DSNAME+2,DEVDATA  GET DEVICE TYPE\n         LTR   R15,R15             WAS FILENAME VALID\n         BNZ   FILERR2             NO, BRANCH\n*        CLC   DEVDATA(8),=X'0000010300007FF8'\n*        BE    DEVOK\n*        TM    DEVDATA+2,X'20'     DIRECT ACCESS\n*        BZ    FILERR3             NO, BRANCH\nDEVOK    LA    R4,DYNDCBW\n         MVC   0(DYNDCBL,R4),DYNDCB\n         XC    DSNAME(2),DSNAME\n         XC    MEMLEN,MEMLEN\n         LA    R0,JFCB\n         LA    R1,DYNEXLST\n         ST    R0,0(,R1)\n         MVI   0(R1),X'07'\n         LA    R14,MYARL           ALLOCATION RETRIEVAL LIST\n         ST    R14,4(,R1)\n         MVI   4(R1),X'13'+X'80'\n         ST    R1,DCBEXLST-IHADCB(,R4)\n         USING ARL,R14\n         XC    0(36,R14),0(R14)\n         MVI   ARLLEN+1,36\n         MVC   ARLIDENT,=C'AR'\n         OI    ARLOPT1,ARLLANY+ARLUSS\n         MVC   40(8,R4),DSNAME+2   DCBDDNAM\n         MVC   DDSAVE,DSNAME+2\n         MVI   RDJFW,X'80'\n         RDJFCB ((R4)),MF=(E,RDJFW)\n         LA    R14,MYARL\n         L     R1,ARLAREA\n         LTR   R1,R1\n         BZ    NOARA\n         L     R0,ARLRTRVD\n         DROP  R14                 ARL\n         USING ARA,R1\nLOOPARA  TM    ARAFLG,ARAXINF\n         BZ    DONEARA\n         SR    R15,R15\n         IC    R15,ARAXINOF\n         SLL   R15,3\n         AR    R15,R1\n         USING ARAXINFO,R15\n         SR    R14,R14\n         ICM   R14,3,ARAPATHO      GET OFFSET TO PATH LEN\n         BZ    DONEARA\n         AR    R14,R15\n         DROP  R15                 ARAXINLN\n         SR    R15,R15\n         ICM   R15,3,0(R14)        GET ARAPATHLEN\n         CH    R15,=H'44'\n         BNH   *+8\n         LA    R15,44              JUST SHOW FIRST 44 FOR NOW\n         STH   R15,DSNAME\n         BCTR  R15,0\n         B     *+10\n         MVC   DSNAME+2(0),2(R14)  ARAPATHNAM\n         EX    R15,*-6\nDONEARA  LA    R14,MYARL           PREPARE FOR FREEMAIN\n         USING ARL,R14\n         SR    R15,R15             PREPARE FOR FREEMAIN\n         IC    R15,ARLPOOL\n         SR    R0,R0\n         ICM   R0,7,ARLRLEN\n         L     R1,ARLAREA\n         DROP  R14                 ARL\n         FREEMAIN RU,LV=(0),SP=(R15),A=(1)\nNOARA    CLC   DSNAME(2),=H'0'\n         BNE   FILESPEC\n         MVC   DSNAME+2(44),JFCB\n         LA    R1,DSNAME+45        LAST CHAR OF DSNAME\n         LA    R0,44               INITIAL LENGTH\nFILEA    CLI   0(R1),C' '          IS THIS LAST NONBLANK\n         BNE   FILEB               YES, BRANCH\n         BCTR  R1,0                BACK UP 1 CHARACTER\n         BCT   R0,FILEA            DECREMENT LENGTH AND BRANCH\nFILEB    STH   R0,DSNAME           STORE LENGTH OF DSNAME\n*        MVC   VOLUME(6),JFCB+118  GET VOLUME FROM JFCB\n         MVC   MEMNAME,JFCB+44     JFCBELNM IN IEFJFCBN\n         LA    R1,MEMNAME+7        LAST CHAR OF MEMBER NAME\n         LA    R0,8\nMEMA     CLI   0(R1),C' '\n         BNE   MEMB\n         BCTR  R1,0\n         BCT   R0,MEMA\nMEMB     STH   R0,MEMLEN\n         B     FILESPEC\nFILERR1  LA    R0,MSG14A\n         B     FILERR\nFILERR2  LA    R0,MSG14B\n         B     FILERR\nFILERR3  LA    R0,MSG14C\nFILERR   MVC   MSGWK(L'MSG14),MSG14\n         LA    R15,MSGWK+L'MSG14\n         LA    R14,DSNAME\n         LH    R1,0(,R14)\n         BCTR  R1,0\n         B     *+10\n         MVC   MSGWK+L'MSG14(0),2(R14)\n         EX    R1,*-6\n         LA    R15,1(R1,R15)\n         LR    R14,R0 POINT TO MSG14A, B, OR C\n         MVC   0(L'MSG14A,R15),0(R14)\n         LA    R0,L'MSG14+L'MSG14A+1(,R1)\n         LA    R1,MSGWK\n         BAL   R14,PUTMSG\n         B     QUITD12\nNOFILE   EQU   *\n         TM    6(R6),X'40'         IS IT QUOTED?\n         BO    DEFX                YES - SKIP DEFAULT SERVICE\n         CLI   QUICKW+1,1          QUICK SPECIFIED\n         BE    DEFX                YES, USER ENTERED ALL BUT PREFIX\n         SPACE\n************************************************************\n*                                                          *\n*        DEFAULT SERVICE ROUTINE TO GET QUALIFIERS         *\n*                                                          *\n************************************************************\n         SPACE\n*              ALL INPUT TO IKJEHDEF MUST BE BELOW THE LINE\n         MVC   DSNAME24(46),DSNAME\n         LA    R15,MYIOPL24\n         USING IOPL,R15\n         LA    R14,MYIOPL\n         MVC   IOPLUPT(4),IOPLUPT-IOPL(R14)\n         MVC   IOPLECT(4),IOPLECT-IOPL(R14)\n         LA    R0,MYECB24\n         ST    R0,IOPLECB\n         XC    MYECB24,MYECB24\n         LA    R14,MYDFPB\n         ST    R14,IOPLIOPB\n         USING DFPB,R14\n         XC    0(20,R14),0(R14)\n         LA    R0,DSNAME24\n         ST    R0,DFPBDSN\n         OI    DFPBCODE,X'04'      SEARCH CAT AND PROMPT IF MULTI\n         MVC   DFPBPSCB,CPPLPSCB\n*        MVI   DFPBCNTL,X'20'      PREFIX THE DSNAME\n         DROP  R14                 DFPB\n         DROP  R15                 IOPL\n         SPACE\n         LR    R1,R15              POINT TO IOPL\n         LA    R13,SAVE24          POINT TO SAVEAREA BELOW THE LINE\n         L     R15,16              CVTPTR\n         TM    736(R15),X'80'      IF HI ORDER BIT NOT ON\n         BNO   EHDEFLNK               THEN DO LINK, NOT CALL\n         L     R15,736(,R15)       CVTEHDEF\n         BALR  R14,R15             CALL IKJEHDEF\n         B     EHDEFEXT            SKIP AROUND LINK\nEHDEFLNK EQU   *\n         LINK  EP=IKJEHDEF,SF=(E,LINKAREA)\nEHDEFEXT EQU   *\n         SPACE\n         LR    R13,R9              RESTORE SAVEARE POINTER\n         B     DEFCODE(R15)\nDEFCODE  B     DEF00               SUCCESS\n         B     NEXTD12              MSG ALREADY ISSUED\n         B     DEF08               INVALID NAME GT 44\n         B     NEXTD12              MSG ALREADY ISUED\n         B     DEF16               NOT IN CATALOG\n         B     DEF20               NOT IN CATALOG\n         B     DEF24               IMPOSSIBLE\n         B     DEF28               COMMAND SYSTEM ERROR\n         B     DEF32               IMPOSSIBLE\n         B     DEF36               ?\nDEF08    EQU   *\nDEF16    EQU   *\n         B     DEF24\nDEF20    EQU   *\nLOCERR   EQU   *\n         MVC   MSGWK(L'MSG02),MSG02\n         LA    R15,MSGWK+L'MSG02\n         LA    R14,DSNAME\n         LH    R1,0(,R14)\n         BCTR  R1,0\n         B     *+10\n         MVC   MSGWK+L'MSG02(0),2(R14)\n         EX    R1,*-6\n         LA    R15,1(R1,R15)\n         MVC   0(L'MSG02A,R15),MSG02A\n         LA    R0,L'MSG02+L'MSG02A+1(,R1)\n         LA    R1,MSGWK\n         BAL   R14,PUTMSG\n         B     NEXTD12\nDEF24    EQU   *\nDEF28    EQU   *\nDEF32    EQU   *\nDEF36    EQU   *\n         LA    R1,MSG03\n         LA    R0,L'MSG03\n         BAL   R14,PUTMSG\nNEXTD12  MVI   RETCODE+1,12\n         B     NEXTDSN\n         SPACE\nDEF00    MVC   DSNAME(46),DSNAME24\nDEFX     EQU   *\n         SPACE\n************************************************************\n*                                                          *\n*        ALLOCATE THE DATASET                              *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R1,MYDAPL\n         USING DAPL,R1\n         MVC   DAPLUPT(4),CPPLUPT\n         MVC   DAPLECT(4),CPPLECT\n         LA    R0,MYECB\n         ST    R0,DAPLECB\n         MVC   DAPLPSCB(4),CPPLPSCB\n         LA    R15,MYDAPB\n         ST    R15,DAPLDAPB\n         DROP  R1                  DAPL\n         USING DAPB08,R15\n         XC    0(84,R15),0(R15)\n         MVI   DA08CD+1,X'08'\n         LA    R0,DSNAME\n         ST    R0,DA08PDSN\n         MVC   DA08DDN(8),=CL8' '\n         MVC   DA08UNIT,=CL8' '\n         MVC   DA08SER,=CL8' '\n         MVC   DA08MNM,=CL8' '\n         MVC   DA08PSWD,=CL8' '\n         MVI   DA08DSP1,DA08SHR\n         MVI   DA08DPS2,DA08KEEP\n         MVI   DA08DPS3,DA08KEP\n         TM    14(R6),X'80'        MEMBER SPECIFIED?\n         BZ    MEMBX               NO - BRANCH\n         LH    R1,12(,R6)          GET LENGTH OF MEMBER\n         STH   R1,MEMLEN\n         BCTR  R1,0                MINUS 1 FOR EX\n         L     R14,8(,R6)          GET ADDRESS OF MEMBER NAME\n         B     *+10\n         MVC   DA08MNM(0),0(R14)   MOVE MEMBER NAME\n         EX    R1,*-6\n         MVC   MEMNAME,DA08MNM\nMEMBX    EQU   *\n         TM    22(R6),X'80'        PASSWORD SPECIFIED?\n         BZ    PASSX               NO - BRANCH\n         LH    R1,20(,R6)          GET LENGTH OF PSWD\n         BCTR  R1,0                MINUS 1 FOR EX\n         L     R14,16(,R6)         GET ADDRESS OF PSWD\n         B     *+10\n         MVC   DA08PSWD(0),0(R14)  MOVE PSWD\n         EX    R1,*-6\nPASSX    EQU   *\n         LA    R1,MYDAPL\n         SPACE\n         BAL   R14,CALLDAIR\n         LTR   R15,R15\n         BZ    OKDAIR\n         BAL   R14,DAIRFAIL\n         B     NEXTD12\nOKDAIR   EQU   *\n         OI    STATUS,X'40'        TELL CLEANUP TO FREE IT\n         LA    R15,MYDAPB\n         MVC   DDSAVE,DA08DDN\n         TM    DA08DSO,X'40'       IS DSORG SEQUENTIAL?\n         BO    OKDSORG             YES - BRANCH\n         TM    DA08DSO,X'02'       IS DSORG PARTITIONED?\n         BO    OKDSORGP            YES, BRANCH\n*\n*              DSORG IS NEITHER PS NOR PO\n*              ISAM=X'80' DA=X'20' VSAM=X'00' NONE=X'00'\n*\nERRDSORG LA    R1,MSG06\n         LA    R0,L'MSG06\n         BAL   R14,PUTMSG\n         B     QUITD12\nOKDSORGP EQU   *\n         CLC   DA08MNM,=CL8' '     WAS MEMBER SPECIFIED?\n         BNE   OKDSORG             YES - BRANCH\n         LA    R1,MSG07\n         LA    R0,L'MSG07\n         BAL   R14,PUTMSG\n         B     NEXTD12\nOKDSORG  EQU   *\n         DROP  R15                 DAPB08\n         SPACE\n************************************************************\n*                                                          *\n*        CHECK FORMAT-1 DSCB FOR EMPTY DATA SET            *\n*                                                          *\n************************************************************\n         SPACE\n         L     R1,16               CVTPTR\n         L     R1,0(,R1)           TCB WORDS\n         L     R1,4(,R1)           CURRENT TCB\n         L     R1,12(,R1)          TIOT\n         LA    R1,24(,R1)          TOIENTRY\nDDLOOP   CLI   0(R1),0             END OF TIOT\n         BE    QUITDSN             YES, BRANCH (NEVER HAPPENS)\n         CLC   4(8,R1),DDSAVE      DOES DDNAME MATCH\n         BE    DDFOUND\n         SLR   R15,R15\n         IC    R15,0(,R1)\n         LA    R1,0(R15,R1)\n         B     DDLOOP\nDDFOUND  L     R15,16(,R1)         TIOEFSRT-1\n         N     R15,=A(X'00FFFFFF') CLEAR HIGH 8 BITS\n         TM    18(R15),X'20'       DIRECT ACCESS DEVICE?\n         BZ    OBTX                NO, BYPASS OBTAIN\n         MVC   VOLSER,28(R15)      UCBVOLI\nOBTDSCB  LA    R1,OBTAINW\n         MVC   0(OBTAINL,R1),OBTAIN\n         LA    R0,DSNAME+2         DSN FOR OBTAIN\n         ST    R0,4(,R1)\n         LA    R0,VOLSER           VOLUME FOR OBTAIN\n         ST    R0,8(,R1)\n         LA    R0,MYDSCB           ANSWER AREA FOR OBTAIN\n         ST    R0,12(,R1)\n         OBTAIN (1),EADSCB=OK\n         LTR   R15,R15             WAS OBTAIN SUCCESSFUL\n         BZ    OKDSCB              YES, BRANCH\n         SPACE\n*               OBTAIN HAS FAILED. HOW CAN THAT HAPPEN WHEN\n*               DYNAMIC ALLOCATION WAS SUCCESSFUL? ONE WAY IT\n*               CAN HAPPEN IS IF THE DSNAME IS AN ALIAS ENTRY\n*               IN A VSAM CATALOG.  IF IT IS, A 'LOCATE' WILL\n*               PUT THE TRUE NAME IN THE DSNAME FIELD, SO NOW\n*               WE ISSUE A LOCATE, AND TRY THE OBTAIN AGAIN.\n         SPACE\n         TM    STATUS,X'08'        HAS LOCATE BEEN TRIED ALREADY?\n         BZ    ALIAS               NO, GO TRY IT\nERROBT   LA    R1,MSG09            UNABLE TO OBTAIN DSCB\n         LA    R0,L'MSG09\n         BAL   R14,PUTMSG\n         B     QUITD12\nALIAS    OI    STATUS,X'08'        TRIP THE SWITCH\n         LA    R1,LOCATEW\n         MVC   0(LOCATEL,R1),LOCATE\n         LA    R0,DSNAME+2         DSNAME FOR LOCATE\n         ST    R0,4(,R1)\n         LA    R0,LOCBUF           ANSWER AREA FOR LOCATE\n         ST    R0,12(,R1)\n         LOCATE (1)\n         LTR   15,15               WAS LOCATE SUCCESSFUL?\n         BZ    OBTDSCB             YES, GO OBTAIN AGAIN\n         B     ERROBT              NO, ISSUE MESSAGE\n         SPACE\nOKDSCB   NI    STATUS,255-X'08'    TURN OFF LOCATE SWITCH\n         TM    MYDSCB-44+X'52',X'42' DSORG = PS OR PO\n         BZ    ERRDSORG\n*        TM    MYDSCB-44+X'54',X'C0' RECFM = U\n*        BO    ERRRECFM\n*        CLC   MYDSCB-44+X'62'(3),=X'000000' CHECK DS1LSTAR\n*        BE    EMPTYDS             BRANCH IF EMPTY DATA SET\nOBTX     EQU   *\nFILESPEC EQU   *\n         SPACE\n************************************************************\n*                                                          *\n*        SET UP THE DCB                                    *\n*                                                          *\n************************************************************\n         SPACE\n         LA    R4,DYNDCBW\n         USING IHADCB,R4\n         MVC   0(DYNDCBL,R4),DYNDCB\n         MVC   DCBDDNAM(8),DDSAVE\n         SPACE\n         LA    R5,DYNDCBEW\n         USING DCBE,R5\n         MVC   0(DYNDCBEL,R5),DYNDCBE\n         ST    R5,DCBDCBE\n         SPACE\n         LA    R15,GET6E\n         ST    R15,DCBEEODA\n         SPACE\n         LA    R15,DYNSYNAD\n         ST    R15,DCBESYNA\n         SPACE\n         LA    R15,DYNEXLST\n         IC    R0,DCBEXLSA-1\n         ST    R15,DCBEXLSA-1      EXLST=DYNEXLST\n         STC   R0,DCBEXLSA-1\n         LA    R1,OPENEXIT         EXIT BELOW THE LINE\n         MVC   0(GLUELEN,R1),GLUE   WILL CONTAIN GLUE\n         ST    R1,0(,R15)          STORE IN 1ST EXLST WORD\n         MVI   0(R15),X'05'        MARK TYPE OF EXIT\n         LA    R0,DYNOPENX         EXIT ABOVE THE LINE\n         ST    R0,OPENEXAD         SAVE ITS ADDRESS\n         OI    OPENEXAD,X'80'      MAKE IT RUN IN31-BIT MODE\n         SPACE\n         LA    R1,ABENDXIT         EXIT BELOW THE LINE\n         MVC   0(GLUELEN,R1),GLUE   WILL CONTAIN GLUE\n         ST    R1,4(,R15)          STORE IN 2ND EXLST WORD\n         MVI   4(R15),128+X'11'    OPEN ABEND EXIT (MVS)\n         LA    R0,DYNABEND         EXIT ABOVE THE LINE\n         ST    R0,ABENDXAD         SAVE ITS ADDRESS\n         OI    ABENDXAD,X'80'      MAKE IT RUN IN31-BIT MODE\n         SPACE\n         OI    STATUS,X'80'        TELL CLEANUP TO CLOSE DCB\n         MVC   OPEND(OPEN31L),OPEN31\n         SPACE\n         OPEN  ((R4),INPUT),MODE=31,MF=(E,OPEND)\n         SPACE\n*        TM    DCBOFLGS,X'10'\n*        TM    DCBEFLG1,DCBEOPEN+DCBEMD31\n         TM    DCBEFLG1,DCBEOPEN\n         BO    OKOPEN\n         LA    R1,MSG08\n         LA    R0,L'MSG08\n         TM    STATUS,X'10'        MEMBER NOT FOUND?\n         BO    DYNOPENM            YES, BRANCH\n         LA    R1,MSG04\n         LA    R0,L'MSG04\nDYNOPENM BAL   R14,PUTMSG\n         B     QUITD12\n         SPACE\nDYNOPENX BSM   0,R14\n         SPACE\nDYNABEND L     R8,0(,R1)           GET COMPLETION CODE\n         N     R8,=A(X'FFF0FF00')\n         CL    R8,=A(X'01301800')  IS IT AN 013-18 ABEND\n         BE    DYNABENY            YES, BRANCH\n         MVI   4(R1),0             NO, ABNORMALLY TERMINATE\n         BSM   0,R14\nDYNABENY OI    STATUS,X'10'        INDICATE MEMBER NOT FOUND\n         MVI   3(R1),4             IGNORE THE ABEND\n         BSM   0,R14\n         SPACE\nOKOPEN   EQU   *\n         MVI   GOTEOD,0\n*        MVC   SHA1PB(28),SHA1PI   SET UP PARAMETER BLOCK FOR SHA-1\n*        MVC   SHA2PB(40),SHA2PI   SET UP PARAMETER BLOCK FOR SHA-256\n         MVC   SHA5PB(80),SHA5PI   SET UP PARAMETER BLOCK FOR SHA-512\n         LA    R0,128\n         ST    R0,I128\n         XC    GETREGS(8),GETREGS\n         XC    PUTREGS(8),PUTREGS\n         XC    FILESIZE(8),FILESIZE\n         SR    R6,R6\n         SPACE\nREADLOOP EQU   *\n         BAL   R14,GET128\n         C     R0,=F'128'\n         BNE   READLAST\n         LM    R14,R15,FILESIZE\n         ALR   R15,R0\n         BC    12,NOCARRY\n         AL    R14,=F'1'\nNOCARRY  STM   R14,R15,FILESIZE\n         LA    R14,IBUF            DATA ADDRESS\n         LR    R15,R0              DATA LENGTH 128\n*        LA    R0,1                FUNCTION CODE 1, SHA-1\n*        LA    R0,2                FUNCTION CODE 2, SHA-256\n         LA    R0,3                FUNCTION CODE 3, SHA-512\n         LA    R1,SHA5PB\nKLOOPI   EQU   *\n         KIMD  R2,R14              R2 NOT USED, R14 --> DATA, R15 = LEN\n         BNZ   KLOOPI              LOOP IF PARTIAL\n         B     READLOOP\n         SPACE\n*              R0 CONTAINS 0 TO 127 OR MOD(FILESIZE,128)\n*              THE LENGTH OF ANY REMAINING DATA IN IBUF AFTER\n*              HAVING PROCESSED THE FILE IN 128-BYTE CHUNKS.\nREADLAST EQU   *\n         LM    R14,R15,FILESIZE\n         ALR   R15,R0\n         BC    12,NOCARRYL\n         AL    R14,=F'1'\nNOCARRYL STM   R14,R15,FILESIZE\n         SLDL  R14,3               MULTIPLY BY 8, BYTES TO BITS\n*              A FILE OF 536,870,912 BYTES WILL HAVE HEX 100000000 BITS\n*              MAKING THE HIGH WORD OF THE MESSAGE BIT LENGTH NONZERO.\n*              THAT'S 5114 CYLINDERS ON A 3390, ABOUT HALF OF A 3390-9.\n*        STM   R14,R15,SHA1PB+20   MESSAGE BIT LENGTH FOR SHA-1\n*        STM   R14,R15,SHA2PB+32   MESSAGE BIT LENGTH FOR SHA-256\n         STM   R14,R15,SHA5PB+72   MESSAGE BIT LENGTH F0R SHA-512 LOW\n         SR    R14,R14\n         LR    R15,R14\n         STM   R14,R15,SHA5PB+64   MESSAGE BIT LENGTH F0R SHA-512 HIGH\n         LA    R14,IBUF            DATA ADDRESS\n         LR    R15,R0              DATA LENGTH < 128\n*        LA    R0,1                FUNCTION CODE 1, SHA-1\n*        LA    R0,2                FUNCTION CODE 2, SHA-256\n         LA    R0,3                FUNCTION CODE 3, SHA-512\n         LA    R1,SHA5PB\nKLOOPL   EQU   *\n         KLMD  R2,R14              R2 NOT USED, R14 --> DATA, R15 = LEN\n         BNZ   KLOOPL              LOOP IF PARTIAL\n         B     DYNEOD\n         SPACE\n*         GET128 - READ UP TO 128 BYTES INTO IBUF, SET R0 TO COUNT\n         SPACE\nGET128   LM    R5,R6,GETREGS\n         LA    R15,IBUF\n         L     R0,I128\nGET6A    CR    R5,R6               IF END OF RECORD\n         BNL   GET6R                 THEN READ NEXT RECORD\n         MVC   0(1,R15),0(R5)      COPY ONE BYTE TO OBUF\n         LA    R15,1(,R15)         NEXT OBUF BYTE\n         LA    R5,1(,R5)           NEXT IBUF BYTE\n         BCT   R0,GET6A            DECREMENT R0 AND LOOP\n         L     R0,I128             SET RETURNED LENGTH\n         STM   R5,R6,GETREGS\n         BR    R14\nGET6R    STM   R14,R0,GETREGS+8\n         CLI   GOTEOD,0            IF WE ALREADY HIT EODAD\n         BNE   GET6E                 GO THERE AGAIN\n         GET   (R4)\n         LR    R5,R1\n         TM    DCBRECFM,X'C0'      RECFM U\n         BO    GET6U\n         TM    DCBRECFM,X'80'      RECFM F\n         BO    GET6F\nGET6V    LA    R0,4\n         LH    R6,0(,R5)           LENGTH+4 FROM RDW\n         CLI   OPTR,0              IF RDW KEYWORD\n         BNE   GET6W                  INCLUDE RDW\n         AR    R5,R0               POINT PAST RDW\n         SR    R6,R0               REDUCE LENGTH\nGET6W    AR    R6,R5               POINT TO END OF RECORD\n         B     GET6X\nGET6U    LH    R6,DCBLRECL\n         AR    R6,R5               POINT TO END OF RECORD\n         B     GET6X\nGET6F    LH    R6,DCBLRECL         GET LENGTH FROM LRECL\n         TM    DCBRECFM,X'10'      IF NOT BLOCKED\n         BO    *+8                   THEN\n         LH    R6,DCBBLKSI           USE BLKSIZE AS LENGTH\n         AR    R6,R5               POINT TO END OF RECORD\nGET6X    LM    R14,R0,GETREGS+8\n         B     GET6A\nGET6E    CLI   GOTEOD,0            WERE WE ALREADY HERE\n         BE    *+8                 NO\n         EX    R0,*                YES, SOC3 IF EOF TWICE\n         MVI   GOTEOD,1            THAT'S ONCE\n         L     R0,I128\n         S     R0,GETREGS+16       COMPUTE HOW MANY BYTES IN IBUF\n         XC    GETREGS(8),GETREGS\n         L     R14,GETREGS+8\n         BR    R14\n         SPACE\nEMPTYDS  MVC   MSGWK(21),=C'-- EMPTY DATA SET -- '\n         LA    R15,MSGWK+21\n         B     ADDDSN\nDYNEOD   EQU   *\n         LA    R1,SHA5PB\n*        LA    R0,20 FOR SHA-1\n*        LA    R0,32 FOR SHA-256\n         LA    R0,64 FOR SHA-512\n         LA    R15,MSGWK\n         BAL   R14,TOHEX\n         SPACE\n*        LA    R15,MSGWK+40 FOR SHA-1\n*        LA    R15,MSGWK+64 FOR SHA-256\n         LA    R15,MSGWK+128 FOR SHA-512\n         MVI   0(R15),C' '\n         MVI   1(R15),C'*'\n         LA    R15,2(,R15)\nADDDSN   LA    R14,DSNAME\n         LH    R1,0(,R14)\n         BCTR  R1,0\n         B     *+10\n         MVC   0(0,R15),2(R14)\n         EX    R1,*-6\n         LA    R15,1(R1,R15)       POINT PAST LAST BYTE\n*        TM    14(R6),X'80'        MEMBER SPECIFIED?\n         CLI   MEMLEN+1,0          MEMBER ALLOCATED?\n         BZ    MEMAX               NO - BRANCH\n         MVI   0(R15),C'('\n         LA    R15,1(,R15)\n*        LH    R1,12(,R6)          GET LENGTH OF MEMBER\n         LH    R1,MEMLEN           GET LENGTH OF MEMBER\n         BCTR  R1,0                MINUS 1 FOR EX\n*        L     R14,8(,R6)          GET ADDRESS OF MEMBER NAME\n         LA    R14,MEMNAME\n         B     *+10\n         MVC   0(0,R15),0(R14)     MOVE MEMBER NAME\n         EX    R1,*-6\n         LA    R15,1(R1,R15)       POINT PAST LAST BYTE\n         MVI   0(R15),C')'\n         LA    R15,1(,R15)\nMEMAX    EQU   *\n         LA    R1,MSGWK\n         LR    R0,R15              POINT PAST LAST BYTE\n         SR    R0,R1               COMPUTE MESSAGE LENGTH\n         CLI   LOWKW+1,1           IF 'LOWER' SPECIFIED\n         BNE   LOWX\n         LR    R14,R0\n         BCTR  R14,0                  GET LENGTH MINUS 1\n         B     *+10\n         TR    MSGWK(0),LOWTABLE      TRANSLATE TO LOWER CASE\n         EX    R14,*-6\nLOWX     EQU   *\n         ST    R0,MSGL\n         CLI   HALFKW+1,1          HALF, HASH IN 2 PARTS\n         BNE   NOTHALF\n         LA    R0,64               FOR SHA-512 HALVES\n         BAL   R14,PUTLINE         DISPLAY FIRST HALF\n         LA    R1,MSGWK+64\n         LA    R0,64               FOR SHA-512 HALVES\n         BAL   R14,PUTLINE         DISPLAY OTHER HALF\n         B     MULTST\nNOTHALF  CLI   BRIEFKW+1,1         BRIEF, JUST THE HASH\n         BNE   *+8\n*        LA    R0,40               FOR SHA-1\n*        LA    R0,64               FOR SHA-256\n         LA    R0,128              FOR SHA-512\n         CLI   MULTIKW+1,1         MULTIPLE LINES, DSNAME SEPARATE\n         BNE   *+8\n*        LA    R0,40               FOR SHA-1\n*        LA    R0,64               FOR SHA-256\n         LA    R0,128              FOR SHA-512\n         LA    R1,MSGWK\n         BAL   R14,PUTLINE\nMULTST   CLI   MULTIKW+1,1         MULTIPLE LINES\n         BNE   MSGDONE\n         LA    R0,MSGWK\n         A     R0,MSGL\n*        LA    R1,MSGWK+40         FOR SHA-1\n*        LA    R1,MSGWK+64         FOR SHA-256\n         LA    R1,MSGWK+128        FOR SHA-512\n*        LA    R1,2(,R1)           POINT PAST SPACE AND '*'\n         SR    R0,R1               COMPUTE MESSAGE LENGTH\n         BAL   R14,PUTLINE         DISPLAY DSNAME ONLY\nMSGDONE  LA    R15,0\n         B     QUITDSN\n         SPACE\nQUITD12  LA    R15,12\n         SPACE\nQUITDSN  TM    STATUS,X'80'\n         BZ    NOCLOSE\n         LA    R5,DYNDCBEW\n*        TM    DCBOFLGS,X'10'      IS IT OPEN?\n         TM    DCBEFLG1,DCBEOPEN\n         BZ    NOCLOSE             NO, BRANCH\n         MVC   CLOSED(CLOSE31L),CLOSE31\n         CLOSE ((R4)),MODE=31,MF=(E,CLOSED)\n         NI    STATUS,255-X'80'    CLOSED\n         DROP  R4                  IHADCB\nNOCLOSE  EQU   *\n         TM    STATUS,X'40'        FREE REQUIRED?\n         BZ    NOFREE\n         LA    R1,MYDAPL\n         LA    R15,MYDAPB\n         USING DAPB18,R15\n         XC    0(40,R15),0(R15)\n         MVI   DA18CD+1,X'18'\n         MVC   DA18DDN,DDSAVE\n         MVC   DA18MNM(8),=CL8' '\n         MVC   DA18SCLS(2),=CL8' '\n         BAL   R14,CALLDAIR        UNALLOCATE\n         NI    STATUS,255-X'40'    UNALLOCATED\n         DROP  R15                 DAPB18\nNOFREE   EQU   *\n         B     NEXTDSN\n         SPACE\nDONE     TM    MYPUTLEP,X'80'     WAS PUTLINE LOADED?\n         BO    NODELETE           NO - USED CVTPUTL - BRANCH\n         LA    R0,=CL8'IKJPUTL '\n         DELETE EPLOC=(0)\nNODELETE EQU   *\n         SPACE\n         IKJRLSA MYANS\n         SPACE\n         CLI   RETCODE+1,0         IS RETCODE ZERO?\n         BZ    STACKDX             YES, BRANCH\n         MVC   MYSTPB(STACKDL),STACKD\n         SPACE\n         STACK DELETE=ALL,PARM=MYSTPB,MF=(E,MYIOPL)\n         SPACE\n         TCLEARQ\nSTACKDX  EQU   *\n         SPACE\n         LH    R15,RETCODE\n         B     EXIT\n         SPACE\n************************************************************\n*                                                          *\n*         CALL IKJDAIR SERVICE ROUTINE                     *\n*                                                          *\n************************************************************\n          SPACE\nCALLDAIR ST    R14,DAIRREGS\n         L     R15,16\n         TM    732(R15),X'80'     CVTDAIR\n         BNO   DAIRLINK\n         L     R15,732(,R15)\n         BALR  R14,R15\n         B     DAIRFINI\nDAIRLINK EQU   *\n         LINK  EP=IKJDAIR,SF=(E,LINKAREA)\nDAIRFINI L     R14,DAIRREGS\n         BR    R14\n         SPACE\n************************************************************\n*                                                          *\n*        DYNAMIC ALLOCATION FAILURE ROUTINE                *\n*                                                          *\n************************************************************\n         SPACE\nDAIRFAIL ST    R14,MYDFREGS\n         LA    R1,MYDFPARM\n         USING DFDSECTD,R1\n         ST    R15,MYDFRC\n         LA    R15,MYDFRC\n         ST    R15,DFRCP\n         LA    R15,MYDAPL\n         ST    R15,DFDAPLP\n         SLR   R15,R15\n         ST    R15,MYJEFF02\n         LA    R15,MYJEFF02\n         ST    R15,DFJEFF02\n         LA    R15,DFDAIR\n         STH   R15,MYDFID\n         LA    R15,MYDFID\n         ST    R15,DFIDP\n         SLR   R15,R15\n         ST    R15,DFCPPLP\n         LINK  EP=IKJEFF18,SF=(E,LINKAREA)\n         L     R15,MYDFRC\n         DROP  R1                  DFDSECTD\n         L     R14,MYDFREGS\n         BR    R14\n         SPACE\n************************************************************\n*                                                          *\n*        PUTMSG ROUTINE                                    *\n*                                                          *\n************************************************************\n         SPACE\nPUTMSG   STM   R14,R1,PUTLINS\n         XC    MYOLD(8),MYOLD\n         XC    MYSEG1(4),MYSEG1\n         MVC   MYPTPB(12),MODLPTPM\n         LA    R14,1               NO. OF MESSAGE SEGMENTS\n         ST    R14,MYOLD\n         LA    R14,MYSEG1          POINT TO 1ST SEGMENT\n         ST    R14,MYOLD+4\n         LR    R14,R0              LENGTH IN R0\n         LA    R14,4(,R14)         ADD 4\n         LA    R15,MYSEG1+4\n         CLC   0(3,R1),=C'IKJ'     IS DATA PRECEEDED BY MESSAGE ID?\n         BE    *+16                YES - BRANCH\n         LA    R14,1(,R14)         ADD 1 TO LENGTH\n         MVI   0(R15),C' '         INSERT LEADING BLANK\n         LA    R15,1(,R15)         BUMP POINTER\n         STH   R14,MYSEG1\n         LR    R14,R0\n         BCTR  R14,0\n         B     *+10\n         MVC   0(0,R15),0(R1)      MOVE MESSAGE IN\n         EX    R14,*-6\n         L     R15,MYPUTLEP\n         SPACE\n         PUTLINE PARM=MYPTPB,OUTPUT=(MYOLD),ENTRY=(15),MF=(E,MYIOPL)\n         SPACE\n         LM    R14,R1,PUTLINS\n         BR    R14\n         SPACE\n************************************************************\n*                                                          *\n*        PUTLINE ROUTINE                                   *\n*                                                          *\n************************************************************\n         SPACE\nPUTLINE  STM   R14,R1,PUTLINS\n         XC    MYSEG1(4),MYSEG1\n         MVC   MYPTPB(12),MODLPTPB\n         LR    R14,R0              LENGTH IN R0\n         LA    R14,4(,R14)         ADD 4\n         STH   R14,MYSEG1\n         LR    R14,R0\n         BCTR  R14,0\n         B     *+10\n         MVC   MYSEG1+4(0),0(R1)   MOVE TEXT IN\n         EX    R14,*-6\n         LA    R1,MYIOPL\n         L     R15,MYPUTLEP\n         SPACE\n         PUTLINE PARM=MYPTPB,OUTPUT=(MYSEG1,DATA),ENTRY=(15),MF=(E,(1))\n         SPACE\n         LM    R14,R1,PUTLINS\n         BR    R14\n         SPACE 1\n*RRRECFM LA    R1,MSGRECFM\n*        LA    R0,L'MSGRECFM\n*        BAL   R14,PUTMSG\n*        B     QUITD12\n         SPACE\nTOHEX    MVC   1(1,R15),0(R1)\n         UNPK  0(3,R15),1(2,R15)\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)\n         LA    R1,1(,R1)\n         BCT   R0,TOHEX\n         MVI   0(R15),C' '\n         BR    R14\n         SPACE\nEXIT     LR    R2,R15              SAVE R15\n         LR    R1,R10\n         L     R0,@SIZE24\n         FREEMAIN R,A=(1),LV=(0)\n         SPACE\n         LR    R1,R13\n         L     R0,@SIZE31\n         L     13,4(,13)\n         FREEMAIN RU,A=(1),LV=(0),SP=1\n         LR    R15,R2              RESTORE R15\n         LM    0,12,20(13)\n         L     14,12(,13)\n         BR    14\n         SPACE\n************************************************************\n*                                                          *\n*        SYNAD EXIT                                        *\n*                                                          *\n************************************************************\n         SPACE\n*        THIS ROUTINE IS ENTERED DURING THE 'GET' MACRO\n*        IF AN I/O ERROR OCCURS.\n         SPACE\nDYNSYNAD EQU   *\n         SYNADAF ACSMETH=QSAM\n         MVC   SYNADMSG(78),50(R1)\n         MVI   SYNADSW,X'FF'\n         SYNADRLS\n         BR    R14\n         SPACE\n************************************************************\n*                                                          *\n*        GLUE FOR DCB EXITS                                *\n*                                                          *\n************************************************************\n         SPACE\n*        THESE 2 INSTRUCTIONS ARE COPIED TO ABENDXIT, BELOW THE LINE,\n*        AND RUN THERE, NOT HERE. WHEN ABENDXIT IS ENTERED,\n*        R15 CONTAINS THE ENTRY ADDRESS, THE ADDRESS OF ABENDXIT.\n*        THEN USING R15 AS A BASE REGISTER, IT LOADS R15 FROM ABENDXAD,\n*        WHICH CONTAINS THE ADDRESS OF DYNABEND ABOVE THE LINE,\n*        WITH THE HIGH-ORDER BIT SET TO 1. THEN IT USES BSM TO\n*        BRANCH TO DYNABEND IN 31-BIT MODE. THE ROUTINE AT\n*        DYNABEND SHOULD RETURN USING 'BSM 0,R14'.\n*\nGLUE     L     R15,ABENDXAD-ABENDXIT(,R15)\n         BSM   R14,R15  OLD MODE INTO R14 HI BIT, BRANCH TO R15 IN 31\nGLUELEN  EQU   *-GLUE\n         SPACE\n*        SINCE ABENDXAD-ABENDEXIT IS IDENTICAL TO OPENEXAD-OPENEXIT\n*        THE FOLLOWING IS NOT REALLY NEEDED.\n         SPACE\nGLUE2    L     R15,OPENEXAD-OPENEXIT(,R15)\n         BSM   R14,R15  OLD MODE INTO R14 HI BIT, BRANCH TO R15 IN 31\nGLUELEN2 EQU   *-GLUE2\n         SPACE\n************************************************************\n*                                                          *\n*        CONSTANTS                                         *\n*                                                          *\n************************************************************\n         SPACE\nMODLPTPM PUTLINE OUTPUT=(1,TERM,SINGLE,INFOR),                         X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=L\n         SPACE\nMODLPTPB PUTLINE OUTPUT=(1,TERM,SINGLE,DATA),                          X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),MF=L\n         SPACE\n*        PRINT NOGEN\n         SPACE\nOPEN31   OPEN  (0,),MODE=31,MF=L\nOPEN31L  EQU   *-OPEN31\nCLOSE31  CLOSE (0,),MODE=31,MF=L\nCLOSE31L EQU   *-CLOSE31\n         SPACE\nDYNDCB   DCB   DDNAME=DYNAM,DSORG=PS,MACRF=(GL),                       +\n               EODAD=0,SYNAD=0,EROPT=ACC,DCBE=0\nDYNDCBL  EQU   *-DYNDCB\n         SPACE\nDYNDCBE  DCBE  RMODE31=BUFF,EODAD=1\nDYNDCBEL EQU   *-DYNDCBE\n         SPACE\n         PRINT GEN\n         SPACE\nOBTAIN   CAMLST SEARCH,2,3,4\nOBTAINL  EQU   *-OBTAIN\n         SPACE\nLOCATE   CAMLST NAME,2,,4\nLOCATEL  EQU   *-LOCATE\n         SPACE\nSTACKD   STACK DELETE=ALL,MF=L\nSTACKDL  EQU   *-STACKD\n         SPACE\n         AGO   .SKIP1\nSHA1PI   DC    X'67452301' H0\n         DC    X'EFCDAB89' H1\n         DC    X'98BADCFE' H2\n         DC    X'10325476' H3\n         DC    X'C3D2E1F0' H4\n         DC    X'00000000' MESSAGE BIT LENGTH HIGH\n         DC    X'00000000' MESSAGE BIT LENGTH LOW\n.SKIP1   ANOP\n         SPACE\n         AGO   .SKIP2\nSHA2PI   DC    X'6A09E667' H0\n         DC    X'BB67AE85' H1\n         DC    X'3C6EF372' H2\n         DC    X'A54FF53A' H3\n         DC    X'510E527F' H4\n         DC    X'9B05688C' H5\n         DC    X'1F83D9AB' H6\n         DC    X'5BE0CD19' H7\n         DC    X'00000000' MESSAGE BIT LENGTH HIGH\n         DC    X'00000000' MESSAGE BIT LENGTH LOW\n.SKIP2   ANOP\n         SPACE\nSHA5PI   DC    X'6A09E667' H0\n         DC    X'F3BCC908' H0\n         DC    X'BB67AE85' H1\n         DC    X'84CAA73B' H1\n         DC    X'3C6EF372' H2\n         DC    X'FE94F82B' H2\n         DC    X'A54FF53A' H3\n         DC    X'5F1D36F1' H3\n         DC    X'510E527F' H4\n         DC    X'ADE682D1' H4\n         DC    X'9B05688C' H5\n         DC    X'2B3E6C1F' H5\n         DC    X'1F83D9AB' H6\n         DC    X'FB41BD6B' H6\n         DC    X'5BE0CD19' H7\n         DC    X'137E2179' H7\n         DC    X'00000000' MESSAGE BIT LENGTH HIGH\n         DC    X'00000000' MESSAGE BIT LENGTH HIGH\n         DC    X'00000000' MESSAGE BIT LENGTH LOW\n         DC    X'00000000' MESSAGE BIT LENGTH LOW\nHEXTAB   DC    C'0123456789ABCDEF'\nMSG01    DC    C'ERROR IN PARSE SERVICE ROUTINE'\nMSG02    DC    C'IKJ58503I DATA SET '\nMSG02A   DC    C' NOT IN CATALOG'\nMSG03    DC    C'ERROR IN DEFAULT SERVICE ROUTINE'\nMSG04    DC    C'UNABLE TO OPEN DATASET'\nMSG05    DC    C'IKJ58509I DATA SET NAME REQUIRED WHEN MEMBER IS SPECIF+\n               IED'\nMSG06    DC    C'ORGANIZATION OF DATA SET MUST BE PARTITIONED OR SEQUEN+\n               TIAL'\nMSG07    DC    C'DATA SET IS PARTITIONED, MEMBER NOT SPECIFIED'\nMSG08    DC    C'SPECIFIED MEMBER NOT FOUND IN DATASET'\nMSG09    DC    C'UNABLE TO OBTAIN DSCB FOR DATA SET'\nMSG14    DC    C'FILENAME '\nMSG14A   DC    C' INVALID, MORE THAN 8 CHARACTERS  '\nMSG14B   DC    C' IS NOT CURRENTLY ALLOCATED       '\nMSG14C   DC    C' NOT ALLOCATED TO A DASD DATA SET '\n*SGRECFM DC    C'RECORD FORMAT U NOT SUPPORTED'\n*MSGDAIR DC    C'UNABLE TO ALLOCATE'\nLOWTABLE DC    0D'0',256AL1(*-LOWTABLE)\n         ORG   LOWTABLE+C'A'\n         DC    X'818283848586878889'\n         ORG   LOWTABLE+C'J'\n         DC    X'919293949596979899'\n         ORG   LOWTABLE+C'S'\n         DC    X'A2A3A4A5A6A7A8A9'\n         ORG\n         LTORG\nPCLADDR  DC    0D'0'               END OF CSECT\n         SPACE\n************************************************************\n*                                                          *\n*        PARSE PARAMETERS                                  *\n*                                                          *\n************************************************************\n         SPACE\n         PRINT NOGEN\nSHASMPCL RMODE 31\nSHASMPCL IKJPARM\nDSN      IKJPOSIT DSNAME,LIST,PROMPT='DATA SET NAME'\nFILEKW   IKJKEYWD\n         IKJNAME 'FILE'\nQUICKW   IKJKEYWD\n         IKJNAME 'QUICK'\nRDWKW    IKJKEYWD\n         IKJNAME 'RDW'\nLOWKW    IKJKEYWD\n         IKJNAME 'LOWER'\nBRIEFKW  IKJKEYWD\n         IKJNAME 'BRIEF'\nMULTIKW  IKJKEYWD\n         IKJNAME 'MULTI'\nHALFKW   IKJKEYWD\n         IKJNAME 'HALF'\n         IKJENDP\n         PRINT GEN\n         SPACE\n************************************************************\n*                                                          *\n*        DSECTS                                            *\n*                                                          *\n************************************************************\n         SPACE\n@DATA31  DSECT\n         DS    18F                 REGISTER SAVEAREA\nLINKAREA DS    2F\nMYPPL    DS    7F\nMYANS    DS    F\nMYECB    DS    F                  USED BY PUTLINE ROUTINE\nMYIOPL   DS    4F                 USED BY PUTLINE ROUTINE\nMYPTPB   DS    3F                 USED BY PUTLINE ROUTINE\nMYOLD    DS    2F                 USED BY PUTLINE ROUTINE\nMYSEG1   DS    2H,CL256           USED BY PUTLINE ROUTINE\nPUTLINS  DS    4F                 USED BY PUTLINE ROUTINE\nMYPUTLEP DS    F                  ADDRESS OF IKJPUTL\nMYSTPB   DS    0F                 5 WORDS USED BY STACK DELETE\nMYDAPL   DS    5F\nMYDAPB   DS    21F\nDSNAME   DS    H,CL44\nMEMLEN   DS    H\nMEMNAME  DS    CL8\nVOLSER   DS    CL6\nLOCATEW  DS    0F\nOBTAINW  DS    4F\nLOCBUF   DS    0D                  USES NEXT 265 BYTES\nMYDSCB   DS    CL140               96 BYTES OF DSCB, 5 BYTES CCHHR\nMSGWK    DS    CL200               INCREASED FROM 128 FOR SHA5SUM\nSTATUS   DS    X\nRETCODE  DS    H\nMYDFPARM DS    5F  USED BY DAIRFAIL\nMYDFREGS DS    F   USED BY DAIRFAIL\nMYDFRC   DS    F   USED BY DAIRFAIL\nMYJEFF02 DS    F   USED BY DAIRFAIL\nMYDFID   DS    H   USED BY DAIRFAIL\nDOUBLE   DS    D\nEIGHT    DS    CL8\nDDSAVE   DS    CL8\nDAIRREGS DS    F\nOPEND    DS    0F,(OPEN31L)X\nCLOSED   DS    0F,(CLOSE31L)X\nDYNDCBEW DS    0F,(DYNDCBEL)X\nKOUNT    DS    F\nKOUNTSP  DS    F\nSYNADSW  DS    F\nSYNADMSG DS    CL78\nDEVDATA  DS    2F\nGETREGS  DS    5F\nPUTREGS  DS    8F\nI128     DS    F\nDSL      DS    F\nMSGL     DS    F\nGOTEOD   DS    C\nOPTR     DS    C\n*SHA1PB  DS    0D,7F 5F PLUS 2F MESSAGE BIT LENGTH\n*SHA2PB  DS    5D    8F PLUS 2F MESSAGE BIT LENGTH\nSHA5PB   DS    10D   8D PLUS 4F MESSAGE BIT LENGTH\nFILESIZE DS    D\nIBUF     DS    CL128\n         DS    0D\n@DATA31L EQU   *-@DATA31\n         SPACE\n@DATA24  DSECT\nSAVE24   DS    18F                USED BY IKJEHDEF\nRDJFW    DS    F\nMYIOPL24 DS    4F                 USED BY IKJEHDEF\nMYECB24  DS    F\nMYDFPB   DS    5F\nDSNAME24 DS    H,CL44\nDYNDCBW  DS    0D,XL(DYNDCBL)\nDYNEXLST DS    2F\nOPENEXIT DS    0H,(GLUELEN)X\nOPENEXAD DS    F  X'80' + ADDRESS OF DYNOPENX\nABENDXIT DS    0H,(GLUELEN)X\nABENDXAD DS    F  X'80' + ADDRESS OF DYNABEND\nJFCB     DS    0F,CL176\nMYARL    DS    9F\nTBUF     DS    CL8\n         DS    0D\n@DATA24L EQU   *-@DATA24\n         SPACE\nIHADCB   DSECT\nDCBDCBE  DS    A\n         DS    28XL1\nDCBBFTEK DS    XL1\nDCBEODAD DS    AL3\nDCBEXLST DS    0A\nDCBRECFM DS    X\nDCBEXLSA DS    AL3\nDCBDDNAM DS    CL8\nDCBOFLGS DS    X\n         DS    7XL1\n         DS    X\nDCBSYNAD DS    AL3\nDCBBLKSI EQU   IHADCB+62,2\nDCBLRECL EQU   IHADCB+82,2\n         SPACE\n         IHADCBE\n         SPACE\nEFLG1    EQU   16\nEOPEN    EQU   X'80'\nEMD31    EQU   X'40'\nEEODA    EQU   40\nESYNA    EQU   44\n         SPACE\nXFLG1    EQU   DCBEFLG1-DCBE\nXOPEN    EQU   DCBEOPEN\nXMD31    EQU   DCBEMD31\nXEODA    EQU   DCBEEODA-DCBE\nXSYNA    EQU   DCBESYNA-DCBE\n         PRINT NOGEN\n         SPACE\n         IKJCPPL\n         SPACE 3\n         IKJPPL\n         SPACE\n         IKJDFPB\n         SPACE 2\n         IKJUPT\n         SPACE 2\n         IKJIOPL\n         SPACE 2\n         IKJDAPL\n         SPACE 2\n         IKJDAP08\n         SPACE 2\n         IKJDAP18\n         SPACE 2\n         IKJPSCB\n         SPACE 2\n         IKJEFFDF DFDSECT=YES\n         SPACE\n         IHAARL\n         SPACE\n         IHAARA\n         SPACE\n*        CVT   DSECT=YES\n         SPACE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SHA5SUM#": {"ttr": 8202, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x005\\x01\\x16$\\x1f\\x01\\x16$\\x1f!\\x14\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe4\\xd7\\xc4\\xc1\\xe3\\xc5\\xc4@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-08-28T00:00:00", "modifydate": "2016-08-28T21:14:35", "lines": 27, "newlines": 27, "modlines": 0, "user": "UPDATED"}, "text": ")F FUNCTION -\n  THE SHA5SUM COMMAND DISPLAYS THE SHA-512 HASH OF DATA SETS.\n  IN DATA SETS WITH VARIABLE-LENGTH RECORDS THE RDW'S AND SDW'S ARE\n  NOT INCLUDED WHEN THE CHECKSUM IS COMPUTED UNLESS THE RDW KEYWORD\n  IS SPECIFIED.\n)X SYNTAX -\n         SHA5SUM  'DSLIST'  FILE  LOWER  RDW  BRIEF  MULTI  HALF QUICK\n\n  REQUIRED - 'DSLIST'\n  DEFAULTS - NONE\n\n)O OPERANDS -\n  'DSLIST' - NAMES OF SEQUENTIAL DATA SETS OR MEMBERS OF PARTITIONED\n             DATA SETS. IF MORE THAN ONE, ENCLOSE LIST IN PARENTHESES.\n))FILE     - THE NAMES IN DSLIST ARE DDNAMES, NOT DSNAMES.\n))LOWER    - DISPLAY THE RESULTS IN LOWER CASE.\n))RDW      - INCLUDE RDW OR SDW IN VARIABLE LENGTH RECORDS.\n))BRIEF    - DISPLAY ONLY THE HASH, WITHOUT THE DATA SET NAME.\n))MULTI    - DISPLAY THE HASH AND DATA SET NAME ON SEPARATE LINES.\n))HALF     - DISPLAY THE HASH IN TWO LINES. IMPLIES BRIEF BUT\n             HALF AND MULTI TOGETHER GIVES DATA SET NAME TOO.\n))QUICK    - FOR UNQUOTED DSNAMES, BYPASS THE DEFAULT SERVICE ROUTINE.\n             SO FOR EXAMPLE, IF YOU SPECIFY THE NAME TEMP AND YOU\n             ONLY HAVE A DATA SET NAMED TEMP.DATA, IT WON'T BE FOUND\n             IF QUICK IS ALSO SPECIFIED. THE QUICK KEYWORD IS JUST\n             TO CUT OUT THE OVERHEAD OF LOOKING FOR EXTENSIONS AT\n             THE END OF THE SPECIFIED DATA SET NAME.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT900/FILE900.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT900", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}