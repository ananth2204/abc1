{"INMR01": {"INMLRECL": 80, "INMFNODE": "N4", "INMFUID": "PST0705", "INMTNODE": "N4", "INMTUID": "PST0705", "INMFTIME": "20040422202621000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 117572, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 84, "INMBLKSZ": 8906, "INMRECFM": "VB", "INMDIR": 9, "INMDSNAM": "PST0705.IRXFLOC.DOC", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"PST0705.IRXFLOC.DOC": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 8906, "DS1LRECL": 84, "DS1RECFM": "VB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 128, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3339, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "040113", "DS1SCEXT": "b'\\x80\"\\xca'", "DS1SCALO": "b'P\\x00\\x00\\x01'", "DS1LSTAR": "b'\\x00\\x01\\x10'", "DS1TRBAL": "b']\\x1a'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x0b`\\x00\\x04\\x9a]p'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x0b`\\x00\\x04\\x9a]p'", "b'X\\xf4\\x13\\xa0\\x00\\x00\\x00\\x11\\x00\\r\\x00\\x11\\x00\\x0e\\x00\\x02'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$INDEX": {"ttr": 6, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x07\\x01\\x04\\x11?\\x01\\x04\\x11?\\x16\\x11\\x00\\x17\\x00\\x17\\x00\\x00\\xd7\\xe2\\xe3\\xf0\\xf7\\xf0\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-04-22T00:00:00", "modifydate": "2004-04-22T16:11:07", "lines": 23, "newlines": 23, "modlines": 0, "user": "PST0705"}, "text": "List of REXX functions subroutines\n\n    @CURSOR    Obtain data at the cursor position of a ISPF session\n    DELIMSTR   Extract a delimited string\n    DSN4DD     Obtain the dataset name of a specified DDname\n    DYNALLOC   Issue svc 99\n    JFCB       Obtain the JFCB of a specified DDname\n    MIN1POS    Determine the position of the first occurence of a (list\n               of) single character(s).\n    SCC@DSN    Determine a datasets existence\n    SCCALLOC   Allocate a DDname to an existing dataset. Free a DDname.\n    SCCD2O     Decimal to Octel conversion.\n    SCCO2D     Octel to decimal conversion.\n    SCCPDSD    Collect the directory entries of a DDname.\n    SCCPDSR    Read a specified member from a DDname.\n    SCCPWR2    Calculate the next higher power of 2.\n    SCCQWVAR   Extract a specified QwikRef item.\n    SCXAMS     Issue IDCAMS command(s) and 'stem' the results.\n    SCXSORT    Sort files and/or stem values.\n    VARLIST    List all defined variables and their values.\n    VOL4DD     Obtain the volume serial of a specified DDname.\n    WILDCARD   Does a specified value match a specified pattern?\n    XDATE      Date conversions.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@CURSOR": {"ttr": 8, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x08\\x00\\x951O\\x00\\x97\\x11\\x1f\\x11\\x17\\x00+\\x00F\\x00\\x00\\xd7\\xe2\\xe3\\xf0\\xf7\\xf0\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1995-11-10T00:00:00", "modifydate": "1997-04-21T11:17:08", "lines": 43, "newlines": 70, "modlines": 0, "user": "PST0705"}, "text": " Name:        @CURSOR\n\n Purpose:     Extract the data at the cursor position of an ISPF panel.\n\n Environment: REXX subroutine/function for ISPF.\n              @CURSOR resides in the IRXFLOC \"function package\".\n\n Features:    @CURSOR can be used within any ISPF application\n              regardless of the panel.\n\n              Non-ebcdic characters from the panel are replaced\n              with blanks (if no argument is specified).\n\n Arguments:\n           1. (optional) Specify an argument of any value\n              (even a \"null\" literal) to cause @CURSOR not to\n              replace non-ebcdic characters with blanks.\n\n Results:     Four values as follows:\n                 - the \"word\" (within REXX context) in which the\n                   cursor is positioned.\n                 - the position of the cursor within that string\n                 - the (screen) column number where the cursor was\n                   positioned\n                 - the data of the entire (screen) row where the cursor was\n                   positioned\n\n              Note that the entire screen row is the image of the\n              panel line. Attibute positions are mainatained but\n              will contain a blank unless an argument is specified\n              for @CURSOR\n\n              If the cursor was not positioned at a \"word\", @CURSOR\n              returns the four values as above except that \"word\" is\n              assigned the value of hexadecimal zero and the\n              position of the cursor within the word is zero.\n\n Errors/Warnings:\n              @CURSOR returns -3 when used outside a valid ISPF\n              environment.\n\n\n Examples:    Refer to the @SYSDSN command.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DELIMSTR": {"ttr": 10, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00S\\x00\\x97\\x03_\\x00\\x97\\x03o\\x08\\x05\\x00B\\x00,\\x00\\x00\\xd7\\xe2\\xe3\\xf0\\xf7\\xf0\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1997-02-04T00:00:00", "modifydate": "1997-02-05T08:05:53", "lines": 66, "newlines": 44, "modlines": 0, "user": "PST0705"}, "text": " Name:        DELIMSTR\n\n Purpose:     Extract the string whose (right) delimiter is\n              determined by the left character of the input string.\n\n Environment: REXX subroutine/function for all MVS/ESA environments.\n              DELIMSTR is part of the system function package\n              IRXFLOC as modified by Stelco.\n\n Features:    If the input string has an unbalanced right delimiter,\n              the result is padded with balancing characters.\n\n Arguments:\n           1. The string from which the delimited string is to be\n              extracted. The leftmost character of that string\n              determines the (expected) right delimiter.\n\n              If the (input) string begins with other than a single\n              quote, a double quote, or a left parenthesis; the\n              delimiting character is the first occurance of a\n              comma, a blank, or the end of the input string.  For\n              such a string, the right deimiter is not included in\n              DELIMSTR's result.\n\n              If the (input) string begins with a quote (single or\n              double), DELIMSTR will return a quoted string.\n              Quoted strings can contain embedded two-for-one\n              quotes. If a balancing quote is not found in the\n              input, one is generated in the result.\n\n              If the (input) string begins with a left parenthesis,\n              DELIMSTR will extract the string up to the balancing\n              right parenthesis.  If the parenthetical string itself\n              contains a quoted string, the quoted string is\n              honoured as described above. (Parenthesis within the\n              quoted string are excluded from the balancing\n              algorithm.)  If a balancing right parentheses are not\n              found in the input, they are generated in the result.\n\n Results:     The extracted string padded as necessary.\n\n Errors/Warnings:\n\n Notes:\n    An input string beginning with a blank or a comma will result in\n    a null string.\n\n    DELIMSTR was designed for (and is recommended for) parsing the\n    subparameters of JCL statements. This includes JOB, EXEC and DD\n    statements but care must be taken when the input string does\n    not conform to JCL syntax; see the example below.\n\n Examples:\n    1. Extract the SPACE parameter of a DD statement string.\n\n       dd_statement = jclstmnt(thisline)\n       parse var dd_statement . dd dd_operands\n       if dd \\= 'DD' then do; say 'Not a DD'; exit; end\n       @space = pos('SPACE=',dd_operands)\n       if @space = 0 then do; say 'No SPACE'; exit; end\n       space = delimstr(substr(dd_operands,@space+6))\n       if length(space) > length(substr(dd_operands,@space+6)) then\n         do\n            say 'SPACE operand contains unbalanced parens.'\n            exit\n         end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DSN4DD": {"ttr": 12, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x11\\x00\\x95\"o\\x00\\x951?\\x11\\x16\\x00G\\x00-\\x00\\x00\\xd7\\xe2\\xe3\\xf0\\xf7\\xf0\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1995-08-14T00:00:00", "modifydate": "1995-11-09T11:16:11", "lines": 71, "newlines": 45, "modlines": 0, "user": "PST0705"}, "text": " Name:        DSN4DD\n\n Purpose:     Return the name of (a concatenation level of) a dataset\n              for a specified DDname.\n\n Environment: REXX subroutine/function for all MVS/ESA environments.\n              DSN4DD resides in the IRXFLOC \"function package\".\n\n Features:    The value of the DSN is returned as per the invocation\n              contruct.\n\n              The REXX variable RC is set to the number of concatenation\n              levels for the DD.\n\n Argument:    The DDname for which the dataset name is required.\n\n              The DDname can be further qualified with a suffix in\n              format  +n  where \"n\" is a number relative to 1 of\n              the concatenation within the DDname.\n\n\n Results:     DSN4DD operates as a REXX subroutine/function. When used\n              as a subroutine, the caller retrieves the value from the\n              REXX variable RESULT. When used as a function, REXX makes\n              the requested assignment from the context of REXX\n              statement which invoked it.\n\n              DSN4DD always sets the REXX variable RC. For a request\n              which is matched without error, RC is asigned the number\n              of datasets which are concatenated together. If there is\n              no concatenation, RC will be assigned the value one.\n\n Errors/Warnings:\n              If the DDNAME is not allocated or the argument is missing,\n              RC will be assigned the value of minus one and the result\n              will be null.\n\n              If the DDNAME is allocated but the requested concatenation\n              level is invalid or beyond the allocated concatenation\n              level, the 'result' will be null and RC is assigned the\n              number of datasets allocated within the concatenation\n              level.\n\n Examples: 1. say dsn4dd('SYSPROC+1')  ==> TCS0TSO.SYSTEM.FUNCLIB\n\n           2. Identify the members (and the library) which have\n              multiple versions in the set of a concatenated DD.\n                 dd = 'SYSUT1'\n                 dsn.0 = dsn4dd(dd)\n                 concat_count = rc\n                 do i = 1 to concat_count-1; dsn.i = dsn4dd(dd'+'i); end\n                 call sccpdsd dd, '*', 'D.' /* build member list */\n                 do i = 1 to d.0-1\n                      ii = i + 1\n                      if left(d.i,8) == left(d.ii,8) then\n                        do\n                           parse value spfdir(d.i) with mem concat .\n                           ? = mem 'exists in' dsn.concat\n                           do while left(d.i,8) == left(d.ii,8)\n                                concat = c2d(substr(d.ii,12,1))\n                                ? = ? dsn.concat\n                                i = ii\n                                ii = ii + 1\n                           end\n                           say ?\n                        end\n                 end\n\n Notes:       If the DDname is allocated to a member of a partitioned\n              dataset, the member name is included in the result. This\n              makes DSN4DD distinct from the TSO LISTF command.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DYNALLOC": {"ttr": 14, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00Q\\x01\\x01\\x16_\\x01\\x014O\\x08Y\\x00?\\x00\\x8b\\x00\\x00\\xd7\\xe2\\xe3\\xf0\\xf7\\xf0\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2001-06-14T00:00:00", "modifydate": "2001-12-10T08:59:51", "lines": 63, "newlines": 139, "modlines": 0, "user": "PST0705"}, "text": " Name:        DYNALLOC\n\n Purpose:     Provide native REXX with dynamic allocation (SVC 99)\n\n Environment: REXX subroutine/function for any address under MVS.\n              The function is part of the IRXFLOC function package.\n\n Features:\n\n\n Arguments:   A series of \"tunit\" control blocks. These control blocks\n              are best built by the TUNIT function. See the 'Notes'\n              below.\n\n\n Results:     The direct result of the subroutine/function is a\n              logical value indicating whether or not the requested\n              function was performed.\n\n              The variable RC is set as per the return code from\n              SVC 99\n\n              There are 'keys' that can be set to request SVC 99\n              return information (e.g. key 0055). When such a key is\n              specified, DYNALLOC will pass the requested information\n              back to the caller instead of the 0/1 logical value.\n\n\n Notes:\n 1. The TUNIT function does not build the S99VERB nor does DYNALLOC make\n    any presumption as to what S99VERB is to be used. With that in mind,\n    the calling program must specify the S99VERB and the type of\n    allocation to be done.  For allocation of a dataset that would be\n    the following hex string (spaces are included here for clarity but\n    would be omitted from the program)\n       call dynalloc '0001 0052 0000 0053 0000'x ||,\n              tunit(.......)\n\n 2. The design of the DYNALLOC function to accept any SVC 99 parameters\n    makes it very versatile. Unfortunately, understanding how to\n    properly code the SVC 99 parameters is not simple. The IBM manual\n    \"Authorized Assembler Programming\" (GC28-1645) chapter 25. must be\n    studied in order to exploit this function.\n\n 3. Although it is possible (see note 2), DYNALLOC can perform all\n    the functions that SCCALLOC does but Rexx programmers will find\n    SCCALLOC much easier to use (and no less efficient) for:\n       - allocating to an existing dataset with DISP=SHR\n       - de-allocation\n       - conditional allocation\n       - re-assigning a DDname\n       - obtaining a system determined DDname\n\n Examples:\n  1. Allocate ddname SYSPRINT as DUMMY\n       call dynalloc '00010052000000240000000100010008'x || 'SYSPRINT'\n\n  2. Allocate ddname PDS to VIO\n       call dynalloc '00010052000000530000'x                ||,\n                tunit('PDS','DISP=(NEW,KEEP,KEEP),UNIT=VIO' ||,\n                ',SPACE=(8880,(6,6,2))'                     ||,\n                ',LRECL=80,BLKSIZE=8880,RECFM=FB,DSORG=PO')\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JFCB": {"ttr": 16, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x13\\x00\\x96&?\\x00\\x96&O\\x08\\x05\\x007\\x007\\x00\\x00\\xd7\\xe2\\xe3\\xf0\\xf7\\xf0\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1996-09-19T00:00:00", "modifydate": "1996-09-20T08:05:13", "lines": 55, "newlines": 55, "modlines": 0, "user": "PST0705"}, "text": " Name:        JFCB\n\n              Return the volume serial number(s) of (a concatenation\n              level of) a dataset for a specified DDname.\n\n Environment: REXX subroutine/function for all MVS/ESA environments.\n              JFCB resides in the IRXFLOC \"function package\".\n\n Features:\n              The REXX variable RC is set to the number of\n              concatenation levels for the DD.\n\n Argument:    The DDname for which the address of the JFCB\n              is required.\n\n              The DDname can be further qualified with a suffix in\n              format  +n  where \"n\" is a number relative to 1 of\n              the concatenation within the DDname.\n\n\n Results:     JFCB operates as a REXX subroutine/function. When\n              used as a subroutine, the caller retrieves the value\n              from the REXX variable RESULT. When used as a\n              function, REXX makes the requested assignment from the\n              context of REXX statement which invoked it.\n\n              The result is a four byte storage address expressed\n              in hexadecimal format. See the  notes  below.\n\n              JFCB always sets the REXX variable RC. For a request\n              which is matched without error, RC is asigned the number\n              of datasets which are concatenated together. If there is\n              no concatenation, RC will be assigned the value one.\n\n Errors/Warnings:\n              If the DDNAME is not allocated or the argument is missing,\n              RC will be assigned the value of minus one and the result\n              will be null.\n\n              If the DDNAME is allocated but the requested concatenation\n              level is invalid or beyond the allocated concatenation\n              level, the 'result' will be null and RC is assigned the\n              number of datasets allocated within the concatenation\n              level.\n\n Notes:\n    The user of JFCB must be familiar with the JFCB Dsect.\n\n    If the address is to be used in a REXX  storage  function, the\n    address must be converted to display format; i.e c2x().\n\n    If the address is to be subjected to arithmetic (or a\n    displacement into the JFCB Dsect is required), the address must\n    first be converted to decimal then the sum converted to display\n        storage(d2x(c2d(jfcb('MYDD'))+118,6)  ==> volser\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MIN1POS": {"ttr": 18, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x03\\x00\\x964o\\x00\\x97\\x10\\x0f\\x12\"\\x003\\x00,\\x00\\x00\\xd7\\xe2\\xe3\\xf0\\xf7\\xf0\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1996-12-11T00:00:00", "modifydate": "1997-04-10T12:22:03", "lines": 51, "newlines": 44, "modlines": 0, "user": "PST0705"}, "text": " Name:        MIN1POS\n\n Purpose:     Determine the leftmost occurance of a series of 'scan'\n              arguments within a string.\n\n Environment: REXX subroutine/function for all MVS/ESA environments.\n              MIN1POS  is part of the system function package\n              IRXFLOC as modified by Stelco.\n\n Features:\n\n Arguments:\n           1. The string to be scanned.\n\n           2 to n.  The scan values. Each of these arguments must\n              be one byte long.\n\n Results:     The position of each of the scan values is determined.\n              The minimum value (greater than zero) of those\n              positions is returned.\n\n              If none of the scan values occurs within the string,\n              then the position returned is the length of the string\n              plus 1.\n\n Errors/Warnings:\n\n Notes:\n    Unlike the POS function, MIN1POS does not allow for a starting\n    position. The equivalent can be accomplished via SUBSTR and\n    arithmetic. Refer to the example.\n\n    The prototype for MIN1POS was written as a REXX exec for\n    expediency of implementation.  That prototype is no longer\n    in effect.\n\n Examples:\n    1. Extract a symbolic variable name from a JCL statement.  This\n       example presumes the only valid (right) delimters for a\n       symbolic variable are .  ( and &   Note that blank and comma\n       are not specified with this usage of MINIPOS because the\n       DELIMSTR function would have excluded those two characters.\n\n       parse value jclstmnt(24) with ddname dd dd_ops\n       dsn = delimstr(substr(dd_ops,pos('DSN=',dd_ops)+4))\n       sym_pos = pos('&',dsn)+1\n       sym_length = MIN1POS(substr(dsn,sym_pos),'.','&','(') - 1\n       symbol = substr(dsn,sym_pos,sym_length)\n\n       In the code above, MIN1POS calculates the length of the\n       symbolic variable.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SCC@DSN": {"ttr": 20, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x008\\x00\\x95\\x19?\\x00\\x99\\x18o\\x11V\\x00\\x83\\x00\\x1e\\x00\\x00\\xd7\\xe2\\xe3\\xf0\\xf7\\xf0\\xf5@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "1995-07-12T00:00:00", "modifydate": "1999-07-05T11:56:38", "lines": 131, "newlines": 30, "modlines": 0, "user": "PST0705"}, "text": " Name:        SCC@DSN\n\n Purpose:     Determine if a specified dataset exits.\n\n Environment: REXX subroutine/function for all MVS/ESA environments.\n              SCC@DSN resides in the IRXFLOC \"function package\".\n\n Features:    SCC@DSN extracts the catalog entry to determine the\n              volume serial number. It then ensures that the dataset\n              exists on that volume.\n\n              Datasets belonging to a GenerationDataGroup are supported at\n              the relative generation level.  SCC@DSN will optionally\n              translate a relative level of a GDG to its absolute value.\n\n              Uncatalogued datasets can be verified.\n\n              A dataset which is catalogued to tape is partially\n              supported. SCC@DSN does not check that the dataset\n              exists on the volume.\n\n Arguments:   1. The dataset name as per JCL.\n\n                 For a GenerationDataGroup, the dataset name is\n                 qualified as per JCL. i.e. STP.XX00.GDG(0)\n\n              2. (optional; use for uncatalogued datasets)\n                 The volume serial number.\n\n                 When the second argument is specified, SCC@DSN avoids\n                 checking the system catalog via the LOCATE macro.\n\n              3. (optional) variable name to which the value of the\n                 volume serial number will be assigned.\n\n              4. (optional) variable name to which the value of the\n                 absolute dataset name (of a relative\n                 GenerationDataGroup) will be assigned.\n\n Results:     0 = dataset does not exist or dataset is migrated.\n\n              1 = dataset does exist.\n\n              (when 3rd argument is used.) The variable is assigned\n              the value of the series volume serial numbers. If the\n              dataset is catalogued to multiple volumes, the series\n              entries are separated by commas.\n\n Notes:\n   MIGRATED datasets.\n      Migrated datasets are supported but as per the 'tape dataset'\n      feature. If the 3rd argument is coded, the value returned in\n      that variable will be MIGRAT regardless of the level of\n      migration.  If the dataset is migrated to tape, it will be\n      considerd to exist (because SCC@DSN does not verify tape\n      datasets). If the dataset is migrated to dasd, it will be\n      considered to not exist.\n\n         dsn = 'STTEST.WHATEVER'\n         exist? = scc@dsn(dsn,,'VOL_SER')\n         if vol_ser = 'MIGRAT' then\n              say dsn 'is migrated to' word('dasd tape',exist?+1)\n\n\n   If the 3rd arguement is used, ensure the variable name is enclosed\n   within quotation marks so that REXX does not assign the variable's\n   (pre-set) value before passing it to the function/subroutine.\n\n   SCC@DSN was developed for a specfic jobstream where, under\n   (abnormal) situations, no levels of a generation data group would\n   be available to a jobstep which archives and deletes all the\n   levels of the generation data group.\n\n   SCC@DSN can be used effectively in a batch environment via the\n   RC@FUNC exec to support conditional JCL.  (Note that as a\n   function SCC@DSN does not set a return code but because RC@FUNC\n   is an exec it does set the return code.) See example 2 below.\n\n   If SCC@DSN is utilized to verify that a catalog entry for a disk\n   dataset actually exists on the speified volume, then the second\n   argument should be used to avoid re-checking the system catalog.\n\n   Although in most situations the functionality of SCC@DSN is the\n   same as SYSDSN, the following distinctions should be noted.\n      SCC@DSN is independent of the host environment; SYSDSN is\n      available only under address TSO.\n\n      The dataset name for SCC@DSN is as per JCL. The dataset name\n      for SYSDSN is as per TSO convention. i.e. unquoted dsn's have\n      the PROFILE PREFIX applied; fully qualified dsn's must be\n      enclosed within (single) quotation marks.\n\n      SCC@DSN does not support/validate member names within a\n      partiioned dataset; SYSDSN does.\n\n      SCC@DSN validates relative generation data groups; SYSDSN\n      validates generation data groups only as an absolute dataset\n      name.\n\n      SCC@DSN sets only a logical value (0 or 1) without\n      'explanation' of when the dataset is not found; SYSDSN sets a\n      text value which attempts to explain why the dataset was not\n      found.\n\n      SCC@DSN will validate a dataset name regardless of the system\n      catalog via the second (volser) argument; SYSDSN will only\n      validate a catalogued dataset name.\n\n      SCC@DSN determines the migration level of a dataset; SYSDSN will\n      cause a migrated dataset to be recalled.\n\n Examples:\n   1. Allocate to a dataset if it exists\n          if scc@dsn(userid()'.CLIST') then\n               call sccalloc 'CLISTDD', userid()'.CLIST'\n\n   2. Batch JCL to execute a step if a dataset exists\n          //SETCC  EXEC  PGM=IRXJCL,\n          //             PARM='RC@FUNC SCC@DSN(\"STP.XX00.D2\")\n          //    INCLUDE  MEMBER=SYSEXEC\n          //         IF  (SETCC.RUN & SETCC.RC = 1) THEN\n          //RUN    EXEC  PGM=STXX000\n          //HISTORY  DD  DISP=SHR,DSN=STP.XX00.D2\n          //RPT001OT DD  SYSOUT=(,)\n          //       ENDIF\n\n\n\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SCCALLOC": {"ttr": 22, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x96\\x14/\\x00\\x966_\\x10D\\x00\\x8b\\x00g\\x00\\x00\\xd7\\xe2\\xe3\\xf0\\xf7\\xf0\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1996-05-21T00:00:00", "modifydate": "1996-12-30T10:44:00", "lines": 139, "newlines": 103, "modlines": 0, "user": "PST0705"}, "text": " Name:        SCCALLOC\n\n Purpose:     Provide native REXX with the equivalent of TSO\n              ALLOCATE and FREE\n\n Environment: REXX subroutine/function for Address TSO or MVS\n\n Features:    Refer to argument 1 formats\n\n\n Arguments:\n           1. The first argument is the ddname operand. It may be\n              specified in one of six  formats.\n            .1  A single ddname representing the dd to be\n                allocated/freed.\n            .2  A list of ddnames to be freed. The ddnames must be\n                separated by at least one blank. With this format,\n                argument two is ignored.\n            .3  A single ddname with a plus sign (+) appended as a\n                suffix. This is to indicate that the dataset(s)\n                specified at argument 2 are to be concatenated ahead\n                of those aleady allocated to the specified ddname.\n                Note that the ddname does not necessarily have to\n                be pre-allocated for this format.\n            .4  A single ddname with a question mark (?) appended as a\n                suffix. This is to indicate that the dataset(s)\n                specified at argument 2 are to be allocated only if\n                the ddname is not already allocated. Note that the\n                dataset(s) specified at argument 2 are verified\n                even if the ddname is already allocated.\n            .5  A single ddname with a equal sign (=) appended as a\n                suffix. This is to indicate that the ddname\n                specified at argument 2 is to be allocated to the\n                datasets already allocated to the ddname (without\n                the suffix) at argument 1.\n            .6  A single ddname with an underscore (_) appended as a\n                suffix. This is special means of telling SCCALLOC\n                not to check the catalog and existence of the dataset(s)\n                specified at argument 2. This format should be reserved\n                for temporary (i.e. VIO) datasets.\n            .7  A single ddname with left parenthesis appended as a\n                suffix. This format will cause SCCALLOC to allocate a\n                system determined ddname to a member (specified in\n                argument 2) within the (first) dataset represented by the\n                ddname specified (without the suffix) at argument 1.\n                SCCALLOC will return the system determined ddname.\n           2. (optional - if omitted the specified ddname is freed)\n              The (list of) dataset name(s) to be allocated. Names\n              must be specified in JCL format; quotes are not used,\n              high level node is required.\n\n              If allocating to the member level, specify the member\n              name as per JCL; i.e. enclosed in parenthesis and\n              appended to the library name.\n\n              If allocating to a relative GDG, specify the GDG\n              level as per JCL; i.e. enclosed in parenthesis and\n              appended to the GDG index name.\n\n              For formats 2, 5 and 7 of argument 1, argument 2\n              also  has special format\n\n            .2  null\n\n            .5  The ddname from which the new allocation will be\n                made.\n\n            .7  The member name to which allocation is required.\n\n Results:     The direct result of the subroutine/function is a\n              logical value indicating whether or not the requested\n              function was performed. Refer to the example 1 below.\n\n              The variable RC is set as per the return code from\n              LOCATE/OBTAIN/DYNALLOC.\n\n              For format 7 of argument 1, the result is the system\n              determined ddname. If the dynamic allocation fails the\n              the result is 0 (zero).\n\n              In error situations, appropriate messages are generated.\n              The messages after a DYNALLOC failure are formatted to\n              assist the programmer maintaining the SCCALLOC program\n              and are to be used in conjunction with the IBM manual\n              \"Authorized Assembler Programming Langauge Programs\"\n              (GC28-1645) chapter 23.  Error code 0218 0000 will be\n              generated if the dataset is catalogued to a tape (i.e\n              \"not mounted\") device.\n\n\n Examples:\n  1. Conditional allocates as well as multiple frees.\n      /* REXX */\n      Call Initailize\n      Call Process\n      Call Terminate\n      exit\n      Initialize:\n           dd_s = ''\n           if SCCALLOC('DD1?','MY.DATASET')   then dd_s = dd_s 'DD1'\n           if SCCALLOC('DD2?','YOUR.DATASET') then dd_s = dd_s 'DD2'\n        return 0\n      Terminate::\n           if dd_s \\= '' then SCCALLOC(dd_s)\n        return 0\n\n  2. Remove a specified dataset from the SYSEXEC allocation.\n      /* REXX */\n      ? = dsn4dd('SYSEXEC')\n      if ? == arg(1) then dsn_s = ''\n      else dsn_s = ?\n      do i = 1 to rc-1\n           ? = dsn4dd('SYSEXEC+'i)\n           if ? \\== arg(1) then dsn_s = dsn_s ?\n      end\n      call SCCALLOC 'SYSEXEC', dsn_s\n      exit\n\n Notes:\n   SCCALLOC will allocate only to existing datasets. It always uses\n   a disposition of SHR.\n\n   A relative GDG is automatically resolved to its absolute dataset\n   name. Do not use SCCALLOC to achieve that resolution; rather use\n   SCC@DSN to determine an absolute gdg name without allocating it.\n\n   SCCALLOC provides only limited allocations operands i.e. DSNAME\n   DDNAME/FILE and SHR. SCCALLOC's purpose is to allow a non-TSO\n   application to allocate to existing datasets.  TSO applications\n   should utilize the ALLOCATE command unless a feature of SCCALLOC\n   is required.\n\n   If an uncataloged dataset is (pre)allocated and format 3 of\n   argument 1 for that ddname is requested, a DYNALLOC failure will\n   occur.\n\n   Failures may render an unexpected allocation environment i.e\n   partial unallocates/allocates\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SCCO2D": {"ttr": 24, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x15\\x00\\x950_\\x00\\x951?\\x14E\\x00\\n\\x00\\x0b\\x00\\x00\\xd7\\xe2\\xe3\\xf0\\xf7\\xf0\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1995-11-01T00:00:00", "modifydate": "1995-11-09T14:45:15", "lines": 10, "newlines": 11, "modlines": 0, "user": "PST0705"}, "text": " Name:        SCCO2D\n\n Purpose:     Convert a specified base 8 number to base 10.\n\n Environment: REXX subroutine/function for all MVS/ESA environments.\n              SCCD2O resides in the IRXFLOC \"function package\".\n\n Arguments: 1 The (octal) number to be converted.\n\n Results:     The number expressed in base 10.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SCCPDSD": {"ttr": 26, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x17\\x00\\x95\\x18/\\x01\\x014\\x1f\\x15#\\x00J\\x00.\\x00\\x00\\xd7\\xe2\\xe3\\xf0\\xf7\\xf0\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1995-07-01T00:00:00", "modifydate": "2001-12-07T15:23:17", "lines": 74, "newlines": 46, "modlines": 0, "user": "PST0705"}, "text": " Name:        SCCPDSD\n\n Purpose:     Obtain selected directory entries from the specified DDname\n              into a stemmed variable or into the data stack.\n\n Environment: REXX subroutine/function for all MVS/ESA environments.\n              SCCPDSD resides in the IRXFLOC \"function package\".\n\n\n Arguments:\n           1. The DDname of the library.\n\n              The DDname must be pre-allocated to the library. That\n              allocation must not be done at the member level.\n\n           2. The selection criterea. The critera is composed of\n              natural characters and/or the 'wildcard' values\n              '*' and '%'\n\n              Refer to the WILDCARD function for details of how this\n              critera may be used.\n\n           3. The name of the REXX stem variable to receive the\n              directory entries.  The caller must ensure this\n              specification is enclosed within quotes.\n\n              If argument 3 is not specified (or specified as null),\n              the directory entries are placed in the data stack.\n\n\n Results: (when 'stem.' is specified at argument 3)\n              'stem.0' contains a count of the number of directory entries.\n\n              'stem.1' through 'stem.stem.0' contains the individual\n              directory entries.\n\n          (when argument 3 is null):\n              The data stack contains directory entries read in FIFO order.\n\n          (independent of argument 3)\n              As a REXX subroutine/function SCCPDSD must return a result\n              to the caller. SCCPDSD returns the number (relative to 0)\n              of datasets concatenated within the DDname.\n\n\n Notes:\n   1. Choice of a technique to manage the 'data stack' is a\n      subjective matter. SCCPDSD makes no choice. If the REXX\n      program requires stack isolation, the programmer must\n      use an appropriate technique.\n\n   2. Each invokation off SCCPDSD collects all the directory\n      entries from all the datasets within the concatenation.\n      The resuts are produced by filtering the entire set against\n      the users selection criterea. If the application requires\n      more than one filter, it is probably more efficient to select\n      all members and apply the filtering (see Wildcard) within\n      the calling exec.\n\n   3. SPFDIR is an independent function that takes a directory entry with\n      SPF stats and reformats it into ebcdic format\n\n\n Examples:\n   1. List the unique member names and concatenation level for the\n      libraries allocated to DDname SYSUT1.\n\n      call sccpdsd 'SYSUT1', '*', 'D.'\n      member_name = ''\n      do d# = 1 to d.0\n           if left(d.d#,8) \\= member_name then\n                say left(d.d#,8) '+'c2d(substr(d.d#,12,1))\n           member_name = left(d.d#,8)\n      end\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SCCPDSR": {"ttr": 28, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00&\\x00\\x95\\x18/\\x00\\x96\\x02o\\x11\\x15\\x00J\\x000\\x00\\x00\\xd7\\xe2\\xe3\\xf0\\xf7\\xf0\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1995-07-01T00:00:00", "modifydate": "1996-01-26T11:15:26", "lines": 74, "newlines": 48, "modlines": 0, "user": "PST0705"}, "text": " Name:        SCCPDSR\n\n\n Purpose:     Read a specified member of a specified DDname into either\n              a stemmed variable or into the data stack.\n\n Features:    Determination of ISRLEMX compression is made internally and\n              decompression is performed automatically.\n\n Environment: REXX subroutine/function for all MVS/ESA environments.\n              SCCPDSR resides in the IRXFLOC \"function package\".\n\n Arguments:\n           1. The DDname of the library.\n\n              The DDname must be pre-allocated to the library. That\n              allocation must not be done at the member level.\n\n           2. The name of the member within the library. If the entire\n              directory entry (as per SCCPDSD) is available, then\n              the first 12 bytes of the directory should be provided\n              to SCCPDSR. See also argument 5.\n\n           3. The name of the REXX stem variable to receive the\n              records. The caller must ensure this specification is\n              enclosed within quotes.\n\n              If argument 3 is not specified (or specified as null),\n              the records are placed in the data stack.\n\n           4. (optional) The length of each record.hin the library.\n              By default, 80 is used. If the member records are\n              longer than 80 bytes, this argument must be spedcified\n              to receive the entire record.\n\n           5. (optional) The name of a variable which will be assigned\n              the value of the directory entry associated with the\n              member. The argument is redundant and ignored if argument\n              2 is coded with TTR information.  The value of the\n              directory entry will be formatted as per SCCPDSD; the\n              function SPFDIR can be used to format an ISPF style entry\n              in ebcdic values.\n\n Results: (when 'stem.' is specified at argument 3):\n              'stem.0' contains a count of the number of records.\n\n              'stem.1' through 'stem.stem.0' contains the individual\n              records.\n\n          (when argument 3 is null):\n              The data stack contains records read in FIFO order.\n\n          (independent of argument 3)\n              As a REXX subroutine/function SCCPDSR must return a\n              result to the caller. SCCPDSR returns a value indicative\n              of internal errors. Typically this value is 000; if it\n              is not all other results are suspect and incomplete.\n\n              If the specified member name (argument 2) is not found in the\n              concatenation of the directories, the result will be 004.\n\n Notes:\n    Choice of a technique to manage the 'data stack' is a subjective\n    matter. SCCPDSR makes no choice. If the REXX program requires stack\n    isolation, the programmer must use an appropriate technique.\n\n    If SCCPDSR is used subsequent to the use of SCCPDSD against the same\n    DDNAME and the DDNAME is a concatenation of multiple datasets with\n    unhomoginous blocksizes, special action is required.  For such a\n    situation, the allocation of the DDNAME must be such that the\n    largest blocksize is associated with the first dataset in the\n    concatenation either by coding a BLKSIZE parameter with the first\n    dataset or by placing the dataset with the largest blocksize first\n    in the concatenation.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SCCPWR2": {"ttr": 257, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x05\\x00\\x950O\\x00\\x951?\\x14T\\x005\\x00/\\x00\\x00\\xd7\\xe2\\xe3\\xf0\\xf7\\xf0\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1995-10-31T00:00:00", "modifydate": "1995-11-09T14:54:05", "lines": 53, "newlines": 47, "modlines": 0, "user": "PST0705"}, "text": " Name:        SCCPWR2\n\n Purpose:     Calculate the next higher power of 2 from a\n              specified number.\n\n Environment: REXX subroutine/function for all MVS/ESA environments.\n              SCCD2O resides in the IRXFLOC \"function package\".\n\n Arguments:\n           1. The number for which the next higher power of 2\n              is to be calculated.\n\n Results:     The lowest power of 2 which is greater than the argument.\n\n Notes:\n    SCCPWR2 is useful to the program which must perform a binary search.\n    A binary search for a REXX programs implies that a stemmed variable\n    has been loaded with a series of unique and sequenced values.\n    SCCPDSD creates such a table.\n\n    An efficient binary search has a 'do loop' which iterates the power of 2\n    times. Use the  FACTORS  function to determine that iteration count.\n\n Example: This example is used to demonstrate how to perform a binary search.\n          It is not necessarily a good example of how to use  SCCPDSD.\n\n         parse upper arg ddname member_list\n         call sccpdsd ddname, '*', 'D.0'\n         max_entries = sccpwr2(d.0)\n         mid_point = max_entries / 2\n         parse value factors(max_entries) with 4 loop_count\n         m.0 = 'does not exist'\n         m.1 = 'exists'\n         do while member_list \\= ''\n              parse var member_list member member_list\n              nay-yea = binary_search(member)\n              say member m.nay_yea 'in the ddname' ddname'.'\n         end\n         exit\n         Binary_search:\n              incr_decr = mid_point\n              point = mid_point\n              do loop_count\n                   ? = left(d.point,8)\n                   incr_decr = mid_point / 2\n                   select\n                        when point > d.0 then point = point - incr_decr\n                        when arg(1) == ? then return 1\n                        when arg(1) > ?  then point = point + incr_decr\n                        otherwise             point = point - incr_decr\n                   end\n              end\n            return 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SCCQWVAR": {"ttr": 259, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00Y\\x00\\x96\\x10\\x9f\\x00\\x97\\x08o\\t%\\x00F\\x00B\\x00\\x00\\xd7\\xe2\\xe3\\xf0\\xf7\\xf0\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1996-04-18T00:00:00", "modifydate": "1997-03-27T09:25:59", "lines": 70, "newlines": 66, "modlines": 0, "user": "PST0705"}, "text": " Name:        SCCQWVAR\n\n Purpose:     Extract QwikRef text into (REXX stem) variables.\n\n Environment: REXX subroutine/function for Address TSO or MVS.\n              Also available to CLISTs\n\n Features:    Optionally 'stack' the output\n\n              Environment independence\n\n              Echo return codes from QWIKREF1\n\n\n Arguments:   (For REXX, SCCQWVAR should only be used as a subroutine\n              or function.)\n\n           1. (required) The name of the QwikRef item to be retrieved.\n\n           2. (optional) The name of the REXX variable stem to be\n              populated. This specification should be terminated by\n              a period (a period is generated if not specified) and\n              enclosed in quotes (to avoid inadvertent symbolic\n              substitution).\n\n              If argument 2 is omitted, the extracted items are\n              placed in the program stack.\n\n\n Results: (REXX)\n              The variable name specified at argument 2 is\n              popualated.  stem.0 is assigned the value of the\n              number of stems used.\n\n              Alternately if argument 2 is not specified, the items\n              are placed in the program stack.\n\n Results: (CLIST)\n              The variable name QWTXTVAR is assigned the value of\n              the entire string of text.\n\n              The condition code is set to the length of the value\n              in QWTXTVAR\n\n Results: (exceptions)\n              SCCQWVAR will abend (S806) when the load module\n              QWIKREF1 is not available (via the LINK macro).\n\n              The REXX variable 'rc' (return code) is set as per\n              QWIKREF1. Refer to the MVS QwikRef manual for details.\n\n              If IKJCT441 (CLIST processing) fails, its return code\n              is reflected as a negative value.\n\n Notes:\n\n   All extraction from the QwikRef databases is performed by the\n   program QWIKREF1. SCCQWVAR is the interface between REXX/CLIST\n   and QWIKREF1. Refer to the MVS QwikRef Guide for more details.\n\n   Despite the fact that SCCQWVAR is environment independent, the\n   proper dataset allocations (for QWIKREF1) must be\n   pre-esatablished.\n\n   The items retrieved are 78 bytes each even when that 78 bytes is\n   all blanks.\n\n   SCCQWVAR has an arbitrary limit of 3000 * 78 bytes for the data\n   interface to QWIKREF1.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SCXAMS": {"ttr": 261, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00F\\x00\\x97!\\x8f\\x00\\x98\\x15_\\x16\\x14\\x00B\\x00F\\x00\\x00\\xd7\\xe2\\xe3\\xf0\\xf7\\xf0\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1997-08-06T00:00:00", "modifydate": "1998-06-04T16:14:46", "lines": 66, "newlines": 70, "modlines": 0, "user": "PST0705"}, "text": " Name:        SCXAMS\n\n Purpose:     Provide a REXX program with a direct interface to IDCAMS. e\n\n Environment: REXX subroutine/function for all MVS/ESA environments.\n              SCXAMS resides in the IRXFLOC \"function package\".\n\n Features:    All the capabilities of IDCAMS are available except\n              for those requiring APF. Only the DCOLLECT and SHCDS\n              commands are precluded.\n\n              The REXX variable \"rc\" is always set to the value\n              return code from IDCAMS\n\n              The results of the IDCAMS command are returned either\n              to the program stack (by default) or to a series\n              of stemmed variables.\n\n              The starting point for the series of stemmed variables\n              can be controlled by pre-setting the value for stem.0\n\n Arguments:   There are two possible arguments; both are optional.\n\n           1. The IDCAMS command(s) to be issued. If not not specified\n              LISTC (with no operands) is used.\n\n              Multiple commands may be 'strung together' provided each\n              command is terminated with a semicolon. The total length\n              of all commands must not exceed 32760 bytes.\n\n           2. The name of the stem variable to receive the output\n              \"records\".  (If this argument is omitted, SCXAMS will\n              dispose of the output records to the program stack.\n\n              The argument (when used) must specify a stem variable\n              name including the period. It should/must be enclosed\n              within quotation marks.\n\n              SCXAMS normally uses stem.1 for the first output\n              \"record\".  If stem.0 is assigned the value \"n\", then\n              output begins at stem.n. This technique can be used\n              to add entries to an existing range.\n\n Results:     The REXX special variable \"rc\" is set with the value\n              of the return code from IDCAMS's execution of the\n              command.\n\n              When argument 2 is omitted, the 'print' records generated\n              by IDCAMS are placed into the program stack.  The calling\n              REXX program must maintain the program stack.\n\n              When argument 2 is specified, the 'print' records\n              generated by IDCAMS are placed into the a series of\n              stemmed variables. 'stem.0' is assigned the value 'n'\n              where 'n' is the last stem variable completed by SCXAMS.\n\n\n Notes:\n    The calling program can collect all the results of a series of\n    IDCAMS commands into one series of stemmed variables by not\n    adjusting stem.0 between the calls to SCXAMS.\n\n    SCXAMS calls IDCAMS and provides I/O exit routines for the ddnames\n    SYSIN and SYSPRINT. SCXAMS filters out the page header and blank\n    lines directed to I/O exit for SYSPRINT. It also eliminates the\n    print carriage control characters.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SCXSORT": {"ttr": 263, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00A\\x00\\x96\\x07?\\x00\\x98\"O\\x11\\x05\\x00N\\x00?\\x00\\x00\\xd7\\xe2\\xe3\\xf0\\xf7\\xf0\\xf5@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1996-03-13T00:00:00", "modifydate": "1998-08-12T11:05:41", "lines": 78, "newlines": 63, "modlines": 0, "user": "PST0705"}, "text": " Name:        SCXSORT\n\n Purpose:     Sort from and/or into REXX stem variables.                e\n\n Environment: REXX subroutine/function for all MVS/ESA environments.\n              SCXSORT resides in the IRXFLOC \"function package\".\n\n Features:    All the capabilities of the system sort program are\n              available.\n\n              Use of stem variables is not mandatory. SCXSORT may be\n              used to manipulate files as per normal.\n\n              SORT's control statements are coded as values assigned\n              to specific REXX variables. Each control statement\n              uses a REXX variable name of the format SCX._____\n              where _____ is the name of the control statement\n              e.g. SCX.SORT = 'FIELDS=(1,8,BI,A)'\n\n Arguments:   There are two possible arguments; both are optional.\n\n           1. The name of the stem variable containing the\n              input \"records\". (If this argument is omitted, SORT\n              will obtain the input records from SORTIN or as per\n              the MODS control statement.)\n\n              The argument (when used) must specify a stem variable\n              name including the period. It should/must be enclosed\n              within quotation marks.\n\n              If there are non-existent variables within the range\n              of stem.1 and stem.n, then stem.0 must contain the\n              value of \"n\" to cause SCXSORT to ignore the\n              non-existent variables.\n\n           2. The name of the stem variable to receive the output\n              \"records\".  (If this argument is omitted, SORT will\n              dispose of the output records to SORTOUT or as per the\n              MODS control statement.)\n\n              The argument (when used) must specify a stem variable\n              name including the period. It should/must be enclosed\n              within quotation marks.\n\n              SCXSORT normally uses stem.1 for the first output\n              \"record\".  If stem.0 is assigned the value \"n\", then\n              output begins at stem.n. This technique can be used\n              to add entries to an existing range.\n\n Results:     Direct results for the REXX exec are only produced\n              when argument two is used. In that case the stem\n              variables are (re)filled and stem.0 contains the value\n              of the number of the last stem filled.\n\n\n Notes:\n    It is recommended that scx.RECORD always be used.  Default for\n    stemmed input is scx.RECORD = 'TYPE=F,LENGTH=(length(stem.1))'.\n    SCXSORT will abort when scx.RECORD is not assigned and stemmed\n    output is requested but stemmed input is not.\n\n    Misrepresentation of RECORD TYPE/LENGTH will create\n    unpredictable results.\n\n    If SCXSORT is to be used multiple times within one exec, ensure\n    that only those scx.____ variables required for each SCXSORT are\n    in force before the invocation. It may be necessary to DROP\n    SCX.___ variables (e.g. scx.SUM = 'FIELDS=NONE')\n\n    Control of SORT's message is accomplished through the $ORTPARM\n    DDname. Once a particular use of SCXSORT is stable and SORT's\n    messages are to be suppressed (and allocation of SYSOUT\n    avoided), then $ORTPARM should be allocated to\n    SYS1.UTILPARM(SORT@NOL)\n\n    In certain situations, SCXSORT can be an alternative to EXECIO.\n    SCXSORT can be used to read a VSAM dataset into REXX stem\n    variables\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TUNIT": {"ttr": 265, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x07\\x01\\x01\\x16_\\x01\\x01\\x16_\\x13T\\x000\\x000\\x00\\x00\\xd7\\xe2\\xe3\\xf0\\xf7\\xf0\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-06-14T00:00:00", "modifydate": "2001-06-14T13:54:07", "lines": 48, "newlines": 48, "modlines": 0, "user": "PST0705"}, "text": " Name:        TUNIT\n\n Purpose:     Convert JCL syntax into SVC 99 parameters (for DYNALLOC)\n\n Environment: REXX subroutine/function; can not be run as a TSO command\n              The function has no TSO dependencies.\n\n Features:\n\n\n Arguments:   If only one argument is specified, it is presumed to be the JCL\n     1. DDname\n\n     2. JCL to be converted.\n\n\n Results:     A series of 'tunit' values ready for the DYNALLOC function\n\n\n Notes:\n 1. JCL validity is not verified and incorrect syntax may cause the\n    function to abort.\n\n 2. Some non-JCL mnemonics can be used. They include  SVC 99 parameters\n    makes it very versatile. Unfortunately, understanding how to\n    properly code the SVC 99 parameters is not simple. The IBM manual\n    \"Authorized Assembler Programming\" (GC28-1645) chapter 25. must be\n    studied in order to exploit this function.\n\n 3. Although it is possible (see note 2), DYNALLOC can perform all\n    the functions that SCCALLOC does but Rexx programmers will find\n    SCCALLOC much easier to use (and no less efficient) for:\n       - allocating to an existing dataset with DISP=SHR\n       - de-allocation\n       - conditional allocation\n       - re-assigning a DDname\n       - obtaining a system determined DDname\n\n Examples:\n  1. Allocate ddname SYSPRINT as DUMMY\n       call dynalloc '00010052000000240000000100010008'x || 'SYSPRINT'\n\n  2. Allocate ddname PDS to VIO\n       call dynalloc '00010052000000530000'x                ||,\n                tunit('PDS','DISP=(NEW,KEEP,KEEP),UNIT=VIO' ||,\n                ',SPACE=(8880,(6,6,2))'                     ||,\n                ',LRECL=80,BLKSIZE=8880,RECFM=FB,DSORG=PO')\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VOL4DD": {"ttr": 267, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00V\\x00\\x95\"o\\x00\\x961\\x0f\\x15R\\x003\\x00-\\x00\\x00\\xd7\\xe2\\xe3\\xf0\\xf7\\xf0\\xf5@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1995-08-14T00:00:00", "modifydate": "1996-11-05T15:52:56", "lines": 51, "newlines": 45, "modlines": 0, "user": "PST0705"}, "text": " Name:        VOL4DD\n\n Purpose:     Return the volume serial number(s) of (a concatenation\n              level of) a dataset for a specified DDname.\n\n Environment: REXX subroutine/function for all MVS/ESA environments.\n              VOL4DD resides in the IRXFLOC \"function package\".\n\n Features:    The value of the volume serial number is returned as\n              per the invocation construct.\n\n              The REXX variable RC is set to the number of\n              concatenation levels for the DD.\n\n Argument:    The DDname for which the dataset name is required.\n\n              The DDname can be further qualified with a suffix in\n              format  +n  where \"n\" is a number relative to 1 of\n              the concatenation within the DDname.\n\n\n Results:     VOL4DD operates as a REXX subroutine/function. When\n              used as a subroutine, the caller retrieves the value\n              from the REXX variable RESULT. When used as a\n              function, REXX makes the requested assignment from the\n              context of REXX statement which invoked it.\n\n              If the specified DDname is allocated to multiple volumes,\n              VOL4DD returns a character string listing the volume\n              serial numbers separated by commas. If the DDname is\n              allocated to more than 5 volumes, only the first five\n              are listed by VOL4DD.\n\n              VOL4DD always sets the REXX variable RC. For a request\n              which is matched without error, RC is asigned the number\n              of datasets which are concatenated together. If there is\n              no concatenation, RC will be assigned the value one.\n\n Errors/Warnings:\n              If the DDNAME is not allocated or the argument is missing,\n              RC will be assigned the value of minus one and the result\n              will be null.\n\n              If the DDNAME is allocated but the requested concatenation\n              level is invalid or beyond the allocated concatenation\n              level, the 'result' will be null and RC is assigned the\n              number of datasets allocated within the concatenation\n              level.\n\n Examples: 1. say VOL4dd('SYSPROC+1')  ==> ST3S03\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WILDCARD": {"ttr": 269, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00G\\x00\\x95\\x18/\\x01\\x00\\x01\\x1f\\x16\"\\x005\\x00\\x11\\x00\\x00\\xd7\\xe2\\xe3\\xf0\\xf7\\xf0\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1995-07-01T00:00:00", "modifydate": "2000-01-11T16:22:47", "lines": 53, "newlines": 17, "modlines": 0, "user": "PST0705"}, "text": " Name:        WILDCARD\n\n Purpose:     Set a logical value as to whether or not the first\n              argument is 'matched' to the second argument.\n\n Environment: REXX subroutine/function for all MVS/ESA environments.\n              WILDCARD resides in the IRXFLOC \"function package\".\n\n Arguments:\n           1. The selection criterea. The criterea is composed of a\n              combination of natural characters and/or two 'wildcard'\n              values. The natural characters must be matched (within\n              positional context) to the second argument value.\n\n              The 'wildcard' values and their action are:\n                 '*' (asterisk) will 'match' to any value of any\n                     length (including zero) in the 'target'.\n                 '%' (percent sign) will 'match' any value in the\n                     'target' but the corresponding 'target' position\n                     must be occupied i.e not null\n\n              'Wildcard' values can be specified multiple times.\n\n\n           2. The 'target' field. This argument contains the value\n              the selection criterea will attempt to match.\n\n\n Results:    1 means the 'target' is matched.\n\n             0 means the 'target' is not matched.\n\n\n Examples:\n             wildcard('PST*','PST0705') --> 1\n\n             wildcard('*705','PST0705') --> 1\n\n             wildcard('*07*','PST0705') --> 1\n\n             wildcard('*0%0*','PST0705') --> 1\n\n             wildcard('PST0705%','PST0705') --> 0\n\n             wildcard('PST%','PST0705') --> 0\n\n             if wildcard('ANYMEM*',mem) then\n               do\n                  call sccpdsr('PDS1',mem,'MEM.')\n                  do i = 1 to mem.0\n                       if find(mem.i,'COPY') then call read_copy\n                  end\n               end\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XDATE": {"ttr": 271, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x05\\x00'\\x00\\x94\\x00?\\x00\\x97\\x14\\x0f\\tF\\x00x\\x00V\\x00\\x00\\xd7\\xe2\\xe3\\xf0\\xf7\\xf0\\xf5@@@\"", "ispf": {"version": "01.05", "flags": 0, "createdate": "1994-01-03T00:00:00", "modifydate": "1997-05-20T09:46:27", "lines": 120, "newlines": 86, "modlines": 0, "user": "PST0705"}, "text": " Name:        XDATE\n\n Purpose:     Convert a date from one format to another.\n\n Environment: REXX subroutine/function for all MVS/ESA environments.\n              XDATE  is part of the system function package\n              IRXFLOC as modified by Stelco.\n\n Features:    Various date formats are supported.\n\n              Logical dates can be converted to actual dates\n\n Arguments:\n           1. (optional) The date to be converted. This argument can\n              be specified in one of eight formats.\n\n              The default is to extract the current (calendar) date\n              from the system.\n\n            . (Gregorian)  yymmdd   yy-mm-dd   yy mm dd\n            . (U.S.)       mm/dd/yy\n            . (Julian)     yyjjj   yy jjj\n            . (shipping)   yy ww d\n            .              YESterday TODay TOMmorrow SUNday MONday ...\n               'yy' = two digit year\n               'mm' = month of year\n               'dd' = day of month\n              'jjj' = Julian day of year\n               'ww' = (Stelco shipping) week number\n                'd' = day of week (1=Sunday, 2=Monday, ..., 7=Saturday)\n              The punctuation characters of '-' (dash), '/' (slash) and\n              ' ' (blank) must be used as shown.  Formats which include\n              punctuation may omit high order zeros except that in the\n              'yy mm dd' format the 'dd' value must always be 2 digits\n              to distinguish it from the 'yy ww d' format.  Formats\n              without punctuation must specify all (high order) digits.\n\n              For the 5th format (alpha abbreviation), only the first 3\n              characters are significant to the XDATE function. The\n              day-of-the-week is presumed to be in the future (e.g.\n              next FRIday) unless the specifications is prefaced with\n              '-' (minus sign) (e.g. -SUN=last SUNday).  Similarily the\n              minus sign prefix can be used with YESterday, TODay and\n              TOMmorrow to yield a date a week earlier.\n\n\n           2. (optional) This argument is significant only when date is\n              specified as 'YESterday', 'TODay', or 'TOMmorrow'. It\n              specifies when the day's schedule begins.  Many\n              application schedules do not align with the start of a\n              calendar day, i.e. midnight. Thus, for a shift which\n              overlaps midnight, 'today's schedule at 02:00 a.m. refers\n              to the previous calendar day.\n\n              The default value is 08:00:00\n\n\n           3. (optional) A code indicating how the result is to be\n              formatted\n                 U - U.S. format             - mm/dd/yy\n                 E - European format         - dd/mm/yy\n                 I - International format    - yy-mm-dd\n                 J - Julian format           - yyjjj\n                 S - Stelco shipping format  - yy ww d  ('d' = numeric day of we\n\n              The default value is \"U\" which is also used (without\n              warning) if argument is specified as a value other than\n              those listed.\n\n           4. (optional) Any value (including a null character string)\n              to indicate an extened result is required.  The format of\n              the extended result is:\n                 result  yy  mm  dd  ww  d  jjj  mon  day  l  yyyy\n              where:\n                 'result' is as per the 'format' requested.\n                 'yy'     is the (two digit) year (excluding century)\n                 'mm'     is the month of the year\n                 'dd'     is the day of the month\n                 'ww'     is the (Stelco) week of the year\n                 'd'      is the day of the week (1 = Sunday; 7 = Saturday)\n                 'jjj'    is the Julian day of the year\n                 'mon'    is the 3 character abbreviation for month.\n                 'day'    is the 3 character abbreviation for the day of the wee\n                 'l'      is the leap year indicator\n                          (1 = leap year; 0 = non-leap year)\n                 'yyyy'   is the (4 digit) year including the century\n\n\n Results:     The date in the format requested.\n\n Errors/Warnings:\n\n Notes:\n\n Usage Notes:\n\n 1. The input date may represent a 'logical' date. The month, day,\n    and week values may be overstated or zero. When a value is\n    overstated only the rightmost significant digits are used. (e.g.\n    if 'ww' is specfied as 456, then 56 is used.). 'Logical' dates\n    are converted to their actual equivalent.\n\n    Use zero for day-of-month and overstate the value of month by\n    one to obtain the date for the last day of the required month.\n       e.g. XDATE('92 03 00',,'I') ==> '92-02-29'\n\n 2. Use of the extended results for Stelco shipping dates is\n    discouraged.  Year-end dates can be confusing.\n      e.g. XDATE('930102',,,'')  ==> 01/02/93 93 01 01 53 7 ...\n           XDATE('930102',,S,'') ==> 92 53 7  93 01 01 53 7 ...\n\n 3. A request to convert TODay may not yield the same result as a\n    request for the system date. The system date is always the current\n    calendar date. \"TODay\" may be adjusted according to the time of day\n    when the request is made. If a request for 'TODay' (using default\n    time) is made before 08:00, then the result is one day earlier than\n    calendar day.\n\n 3. XDATE is a REXX interface to Stelco's corporate date routine\n    named STSS011.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT753/CBT.V500.FILE753.PDS/HELP.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT753/CBT.V500.FILE753.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}