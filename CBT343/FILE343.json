{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011813000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 235144, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE343.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 235144, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 235144, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE343.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x05\\x02'", "DS1TRBAL": "b'\\xcbx'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x02\\x88\\x00\\n\\x02\\x89\\x00\\x00\\x00\\x06'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04O\\x00\\x17\\x01\\x10\\x02\\x7f\\x01\\x10\\x02\\x7f\\x14A\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf9@@@'", "ispf": {"version": "04.79", "flags": 0, "createdate": "2010-01-27T00:00:00", "modifydate": "2010-01-27T14:41:17", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-479"}, "text": "REGULAR CBT TAPE - VERSION 479    FILE:  343\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT479.FILE343\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 11 MEMBERS COUNTED; CUMULATIVE SIZE IS 1,748 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   01/27/10    14:41:17    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$ASM": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x08O\\x01\\x02\\x08O\\x087\\x00%\\x00%\\x00\\x00\\xe3\\xd9\\xc9\\xc4\\xd1\\xd2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-03-25T00:00:00", "modifydate": "2002-03-25T08:37:00", "lines": 37, "newlines": 37, "modlines": 0, "user": "TRIDJK"}, "text": "//TRIDJKAS JOB (1G70AA1RTRI),'KALINICH, JOHN',\n//             CLASS=B,\n//             NOTIFY=TRIDJK,\n//             MSGCLASS=R\n/*JOBPARM R=7K03,T=9999,L=9999\n//JCL      JCLLIB  ORDER=AD.PROCLIB\n//JOB      OUTPUT  NAME='KALINICH, JOHN',\n//             TITLE='',\n//             DEPT='',\n//             BUILDING='ROBERT A. YOUNG',\n//             ADDRESS=('COMPUTER SCIENCES CORP',\n//             'ROOM 7.103',\n//             '1222 SPRUCE STREET',\n//             'ST. LOUIS, MISSOURI  63103-2834'),\n//             JESDS=ALL,\n//             DEFAULT=YES\n//ASM      EXEC  PGM=ASMA90,REGION=32M,\n//             PARM=(NORLD,TERM,'XREF(SHORT),SIZE(MAX,ABOVE)')\n//SYSUT1   DD  UNIT=VIO,SPACE=(4096,(120,120),,,ROUND),DCB=BUFNO=1\n//SYSLIN   DD  UNIT=VIO,SPACE=(TRK,(5,5)),DISP=(MOD,PASS),DSN=&&X,\n//             DCB=BLKSIZE=3120\n//SYSPRINT DD  SYSOUT=*\n//SYSTERM  DD  SYSOUT=*\n//SYSIN    DD  DISP=SHR,DSN=AD.FILE343.PDS444(VTOCLIST)\n//SYSLIB   DD  DSN=SYS1.MODGEN,DISP=SHR\n//         DD  DSN=SYS1.MACLIB,DISP=SHR\n//LKED     EXEC  PGM=IEWL,COND=(0,LT),REGION=32M,\n//             PARM='MAP,NCAL'\n//SYSPRINT DD  SYSOUT=*\n//IN       DD  DSN=&&X,DISP=(OLD,DELETE)\n//SYSLMOD  DD  DISP=SHR,DSN=AD.CMDLIB               <<=== LINK TARGET\n//SYSUT1   DD  UNIT=VIO,SPACE=(1024,(120,120),,,ROUND),\n//             DCB=BUFNO=1\n//SYSLIN   DD  *\n  INCLUDE  IN\n  ALIAS    VTOCICF\n  NAME     VTOCLIST(R)                              <<=== LOADMOD NAME\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$DOC": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x004\\x00\\x98 \\x0f\\x01\\x02\\x08O\\x08F\\x00\\x07\\x00\\x0b\\x00\\x00\\xe3\\xd9\\xc9\\xc4\\xd1\\xd2@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1998-07-19T00:00:00", "modifydate": "2002-03-25T08:46:34", "lines": 7, "newlines": 11, "modlines": 0, "user": "TRIDJK"}, "text": "Member     Description\n-------- - ------------------------------------------------------------\n$$ASM    - High level assembly and linkedit JCL\n$$DOC    - What you are reading\n$$JCL    - Batch JCL to execute VTOCLIST\nVTOCLIST - Current version (3390-27/32 large DASD support)\nVT0CLIST - Prior version\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$JCL": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x12\\x01\\x02\\x08O\\x01\\x02\\x08O\\x08G\\x00\\x16\\x00\\x14\\x00\\x00\\xe3\\xd9\\xc9\\xc4\\xd1\\xd2@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2002-03-25T00:00:00", "modifydate": "2002-03-25T08:47:12", "lines": 22, "newlines": 20, "modlines": 0, "user": "TRIDJK"}, "text": "//TRIDJKVT JOB (1G70AA1RTRI),'KALINICH, JOHN',\n//             CLASS=B,\n//             NOTIFY=TRIDJK,\n//             MSGCLASS=R\n/*JOBPARM R=7K03,T=9999,L=9999\n//JCL      JCLLIB  ORDER=AD.PROCLIB\n//JOB      OUTPUT  NAME='KALINICH, JOHN',\n//             TITLE='',\n//             DEPT='',\n//             BUILDING='ROBERT A. YOUNG',\n//             ADDRESS=('COMPUTER SCIENCES CORP',\n//             'ROOM 7.103',\n//             '1222 SPRUCE STREET',\n//             'ST. LOUIS, MISSOURI  63103-2834'),\n//             JESDS=ALL,\n//             DEFAULT=YES\n//VTOCLIST EXEC  PGM=VTOCLIST\n//*                          ,PARM=PDS <--- DIRECTORY BLKS ALLOC/USED\n//*                                         MUST HAVE \"READALL\" AUTH\n//STEPLIB  DD  DSN=AD.CMDLIB,DISP=SHR\n//SYSUT1   DD  UNIT=SYSALLDA,DISP=SHR,VOL=SER=PERM99\n//SYSPRINT DD  SYSOUT=*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$JCL2": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01\\x10\\x02\\x7f\\x01\\x10\\x02\\x7f\\x148\\x00\\x12\\x00\\x12\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-01-27T00:00:00", "modifydate": "2010-01-27T14:38:32", "lines": 18, "newlines": 18, "modlines": 0, "user": "IBMUSER"}, "text": "//SBGOLOBK JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//VTOCLIST PROC SOUT='SYSOUT=*'\n//VOL      EXEC  PGM=VTOCLIST,PARM='MAP,VOLDD',REGION=6000K\n//STEPLIB  DD  DISP=SHR,DSN=SBGOLOB.W$$.LINKLIB\n//SYSUT1   DD  DISP=SHR,UNIT=SYSDA,VOL=SER=&VOL\n//SYSPRINT DD  &SOUT,\n//             SPACE=(CYL,(1,2)),\n//             DCB=BLKSIZE=990\n//         PEND\n//*\n//VOL001   EXEC VTOCLIST,VOL=DATA01\n//VOL002   EXEC VTOCLIST,VOL=DATA02\n//VOL003   EXEC VTOCLIST,VOL=DATA03\n//VOL004   EXEC VTOCLIST,VOL=DATA04\n//VOL005   EXEC VTOCLIST,VOL=DATA05\n//VOL006   EXEC VTOCLIST,VOL=DATA06\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE1": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00C\\x01\\x02\\x08O\\x01\\x02\\x08O\\x15@\\x00\\x0f\\x00\\x0f\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-03-25T00:00:00", "modifydate": "2002-03-25T15:40:43", "lines": 15, "newlines": 15, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  VTOCLIST Update (3390-27/32 Support)\nDate:     Mon, 25 Mar 2002 09:17:01 -0500\nFrom:     John Kalinich <jkalinic@scsnet.csc.com>\nTo:       \"Sam Golob (E-mail)\" <sbgolob@attglobal.net>\n\nSam,\n\nHere is a new VTOCLIST with 3390-27 (or 32) large DASD\nsupport.  I had to sacrifice the KEYLEN field in the\nreport to make room for the larger track and cylinder\nsizes.  I renamed the old version with a \"zero\" in the\n3rd position of VTxCLIST.\n\nRegards,\nJohn K\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE2": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00%\\x01\\x10\\x02\\x7f\\x01\\x10\\x02\\x7f\\x124\\x00\\x10\\x00\\x10\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-01-27T00:00:00", "modifydate": "2010-01-27T12:34:25", "lines": 16, "newlines": 16, "modlines": 0, "user": "IBMUSER"}, "text": "John Kalinich told this to me verbally.  (SG - 2010/01/27)\n\n\n  Somebody was running VTOCLIST against all of the DASD in his\nshop, and he noticed that storage was being tied up.  JK looked\ninto FREEMAIN and it didn't help.  Then he looked into FREEPOOL\nand it did help.  So here is the modified code, with the extra\nFREEPOOL invocations.\n\n  I didn't think it was necessary to keep the old source for\nVTOCLIST that didn't do the FREEPOOL, because it was probably\nimperfect code anyway, that was no more reliable or better than\nthe present code.  So I replaced the old code with the present\ncode.  (SG)\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE343": {"ttr": 530, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04O\\x00\\x08\\x01\\x10\\x02\\x7f\\x01\\x10\\x02\\x7f\\x14A\\x00\\x15\\x00\\x15\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf9@@@'", "ispf": {"version": "04.79", "flags": 0, "createdate": "2010-01-27T00:00:00", "modifydate": "2010-01-27T14:41:08", "lines": 21, "newlines": 21, "modlines": 0, "user": "CBT-479"}, "text": "//***FILE 343 is a VTOCLIST program from John Kalinich of Computer  *   FILE 343\n//*           Sciences Corp. in St. Louis, Missouri.  This program  *   FILE 343\n//*           originally came from a UK G.U.I.D.E. tape, and        *   FILE 343\n//*           was written by Peter Havercan.  It has been enhanced  *   FILE 343\n//*           for operating system improvements several times, by   *   FILE 343\n//*           John Kalinich.  This code currently does not support  *   FILE 343\n//*           Indexed VTOC freespace calculations, but besides that *   FILE 343\n//*           it works fine on modern systems.                      *   FILE 343\n//*                                                                 *   FILE 343\n//*         email:   jkalinic@scsnet.csc.com                        *   FILE 343\n//*                                                                 *   FILE 343\n//*    Updated:  06/20/03  to bypass HFS files and change BAL       *   FILE 343\n//*                        an BALR instructions to BAS and BASR.    *   FILE 343\n//*    Updated:  03/25/02  with old version still included.         *   FILE 343\n//*                                                                 *   FILE 343\n//*    Here is a new VTOCLIST with 3390-27 (or 32) large DASD       *   FILE 343\n//*    support.  I had to sacrifice the KEYLEN field in the         *   FILE 343\n//*    report to make room for the larger track and cylinder        *   FILE 343\n//*    sizes.  I renamed the old version with a \"zero\" in the       *   FILE 343\n//*    3rd position of VTxCLIST.                                    *   FILE 343\n//*                                                                 *   FILE 343\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ASMLINK": {"ttr": 532, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x06\\x01\\x01\\x04O\\x01\\x10\\x02\\x7f\\x129\\x00\\x1d\\x00\\x1e\\x00\\x00\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2001-02-13T00:00:00", "modifydate": "2010-01-27T12:39:06", "lines": 29, "newlines": 30, "modlines": 0, "user": "IBMUSER"}, "text": "//WSBGM JOB (CCMVS),'HI FOLKS',\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,FLAG(5))\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SBGOLOB.B.ASM\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(VTOCLIST)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETSSI  CB479343\n SETCODE AC(0)\n NAME    VTOCLIST(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VTOCLIST": {"ttr": 534, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x004\\x01\\x02\\t\\x1f\\x01\\x10\\x02\\x7f\\x08)\\x03&\\x03\\x17\\x00\\x00\\xe3\\xd9\\xc9\\xc4\\xd1\\xd2@@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2002-04-01T00:00:00", "modifydate": "2010-01-27T08:29:34", "lines": 806, "newlines": 791, "modlines": 0, "user": "TRIDJK"}, "text": "         TITLE 'VTOCLIST - LIST VTOC OF SYSUT1'\n***********************************************************************\n**@@NAME=U10001AS      EUROPEAN GUIDE MODS SEE ABSTR.FLE. 3-75 GUIDE  *\n*                                                                     *\n* AUTHOR -     P.E.HAVERCAN - C.A.V. LIMITED                          *\n*                                                                     *\n* TITLE -      VTOCLIST                                               *\n*                                                                     *\n* FUNCTION -   LIST THE VTOC ON A DASD VOLUME                         *\n*                                                                     *\n* JCL -        //VTOCLIST   EXEC  PGM=VTOCLIST                        *\n*              //SYSPRINT   DD  SYSOUT=*                              *\n*              //SYSUT1     DD  UNIT=SYS20DA,DISP=SHR,VOL=SER=VVVVVV  *\n*                                                                     *\n*              PARM='PDS' WILL PRINT DIRECTORY BLOCKS ALLOCATED/USED  *\n*              INSTEAD OF THE CREATION/LAST REFERENCE DATES.  THIS    *\n*              REQUIRES READALL IN ACF2 IN ORDER TO OPEN EACH         *\n*              PDS DIRECTORY ON THE VOLUME WITHOUT GETTING SECURITY   *\n*              VIOLATIONS.                                            *\n*                                                                     *\n* ATTRIBUTES - NONREUSABLE                                            *\n*                                                                     *\n* MODIFIED   - JOHN KALINICH, COMPUTER SCIENCES CORPORATION,          *\n*              ST. LOUIS, MO                                          *\n*              JKALINIC@CSC.COM                                       *\n*                                                                     *\n* 09/20/78 -   FIX MISCELLANEOUS BUGS AND 0C4 ABENDS                  *\n*                                                                     *\n*              PDS DIRECTORY BLOCKS ALLOCATED/USED OPTION             *\n*                                                                     *\n* 09/18/85 -   PRINT THE LAST REFERENCE DATE INSTEAD OF THE           *\n*              EXPIRATION DATE                                        *\n*                                                                     *\n*              3380/3390 SUPPORT                                      *\n*                                                                     *\n*              PRINT DATES IN AMERICAN (MM/DD/YY) FORMAT              *\n*              INSTEAD OF EUROPEAN (DD/MM/YY) FORMAT                  *\n*                                                                     *\n* 06/10/88 -   PRINT UP TO 123 EXTENTS FOR ICF VSAM DATA SETS         *\n*                                                                     *\n* 01/09/98 -   PROCESS YEAR 2000 VTOC DATES CORRECTLY                 *\n*                                                                     *\n* 08/12/99 -   DISPLAY NEW DSORG TYPES:  PDSE, HFS, AND VSAM EF       *\n*                                                                     *\n* 03/22/02 -   3390-9 AND 3390-27/32 SUPPORT                          *\n*              PRINT UP TO 255 EXTENTS                                *\n*                                                                     *\n* 06/20/03 -   IF PARM=PDS, BYPASS HFS FILES                          *\n*                                                                     *\n* 01/20/10 -   FREEMAIN FORMAT1 STORAGE AREA                          *\n*                                                                     *\n* 01/26/10 -   FREEPOOL QSAM BUFFERS                                  *\n*                                                                     *\n***********************************************************************\n         MACRO\n&NAME    #SORT &FIELDS=(1,1,CH,A),&FIRST=,&LAST=,&A=,&FORMAT=,         *\n               &LENGTH=\n.*       AUTHOR - PETER HAVERCAN\n         GBLC  &##EQU\n         LCLA  &X,&Y,&Z,&LEN\n         LCLC  &HI,&LO,&R0,&R1,&R14,&R15\n&X       SETA  N'&FIELDS\n         AIF   (&X NE 3 AND &X NE 4).ERR1\n         AIF   (&X EQ 4 AND '&FIELDS(3)' NE 'CH').ERR2\n&HI      SETC  'H'\n&LO      SETC  'L'\n         AIF   ('&FIELDS(&X)' NE 'D').TESTA\n&HI      SETC  'L'\n&LO      SETC  'H'\n         AGO   .SETREGS\n.TESTA   AIF   ('&FIELDS(&X)' EQ 'A').SETREGS\n         MNOTE *,'*** SORT TYPE NOT A OR D - A ASSUMED'\n.SETREGS ANOP\n&R0      SETC  '&##EQU.0'\n&R1      SETC  '&##EQU.1'\n&R14     SETC  '&##EQU.14'\n&R15     SETC  '&##EQU.15'\n         AIF   ('&LENGTH' EQ '').NOLNGTH\n&LEN     SETA  &LENGTH\n         AGO   .LENSET\n.NOLNGTH ANOP\n&LEN     SETA  L'&FIRST\n.LENSET  ANOP\n&X       SETA  &FIELDS(1)-1            OFFSET WITHIN RECORD\n&Y       SETA  &FIELDS(2)              LENGTH OF SORT-KEY\n&Z       SETA  &X+&LEN                 OFFSET WITHIN NEXT RECORD\n         AIF   ('&FIRST&LAST' EQ '').ATYPE\n&NAME    LA    &R15,&FIRST             ADDRESS FIRST ENTRY\n         LA    &R0,&LENGTH             LOAD WIDTH OF TABLE\n         LA    &R1,&LAST               ADDRESS LAST ENTRY\n         AGO   .STEPBCK\n.ATYPE   AIF   ('&A' EQ '').ERR3\n&NAME    LM    &R15,&R1,&A             FIRST ENTRY,WIDTH,LAST ENTRY\n.STEPBCK ANOP\n         SR    &R1,&R0                 R1 POINTS AT PENULTIMATE\n         CLC   &X.(&Y,&R15),&Z.(&R1)   COMPARE FIRST & LAST ENTRIES\n         B&LO  *+22                    RECDS IN SEQUENCE\n         XC    0(&LEN,&R15),&LEN.(&R1) SWITCH FIRST AND\n         XC    &LEN.(&LEN,&R1),0(&R15) LAST ENTRIES INTO\n         XC    0(&LEN,&R15),&LEN.(&R1) CORRECT SEQUENCE\n         LA    &R14,&LEN.(&R15)        ADDRESS NEXT RECORD\n         CLC   &X.(&Y,&R14),&X.(&R15)  COMPARE SORT KEYS\n         BN&LO *+26                    IN SEQUENCE FROM FRONT\n         XC    0(&LEN,&R14),0(&R15)    SWITCH FIELDS\n         XC    0(&LEN,&R15),0(&R14)    WHICH ARE OUT\n         XC    0(&LEN,&R14),0(&R15)    OF SEQUENCE\n         B     *+32                    GO TO LOOP CONTROL\n         CLC   &X.(&Y,&R14),&Z.(&R1)   COMPARE WITH FINAL RECORD\n         BN&HI *+22                    IN SEQUENCE FROM REAR\n         XC    0(&LEN,&R14),&LEN.(&R1) SWITCH FIELDS\n         XC    &LEN.(&LEN,&R1),0(&R14) WHICH ARE OUT\n         XC    0(&LEN,&R14),&LEN.(&R1) OF SEQUENCE\n         BXLE  &R14,&R0,*-60           INCREMENT & LOOP BACK\n         SR    &R1,&R0                 DECREMENT END POINTER\n         BXLE  &R15,&R0,*-98           ADVANCE FRONT POINTER\n         MEXIT\n.ERR1    MNOTE 8,'INVALID NO. OF ENTRIES IN FIELDS PARAMETER'\n         MEXIT\n.ERR2    MNOTE 4,'FORMAT TYPE IS NOT SUPPORTED'\n         MEXIT\n.ERR3    MNOTE 8,'NEITHER A NOR FIRST AND LAST ARE SPECIFIED'\n         MEND\n*\n         MACRO\n&NAME    ERROR &A\n&NAME    ABEND &A\n         MEND\n*\n         EJECT\nVTOCLIST CSECT\n*        AUTHOR - P.E.HAVERCAN - C.A.V. LIMITED\n*        REGEQU                        * SYMBOLIC REGISTERS\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         USING VTOCLIST,R15            * ADDRESS SAVEAREA\n         STM   R14,R12,12(R13)         * SAVE REGISTERS\n         ST    R13,SAVEAREA+4          * BACKWARD TO CALLER\n         LR    R5,R13                  * KEEP FOR A WHILE\n         CNOP  0,4                     * ALIGN TO FULLWORD FOR R13\n         BAS   R13,SAVEAREA+72         * PRIME 1ST BASE\n         DROP  R15\n         USING *,R13,R12               * DECLARE BASE REGISTERS\nSAVEAREA DC    18F'0'                  * 72-BYTE SAVEAREA\n         ST    R13,8(R5)               * FORWARD FROM CALLER\n         LA    R12,2048(R13)           * +2K PAST 1ST BASE\n         LA    R12,2048(R12)           * +4K PAST 1ST BASE\n         LM    R10,R11,0(R1)           * PICK UP PARM ADDR & DCB ADDR\n         CLC   0(2,R10),=XL2'0000'     * PARM ENTERED?\n         BE    NOPARM                  * NO\n         MVC   PARM(3),2(R10)          * YES, KEEP\nNOPARM   EQU   *\n         LTR   R10,R10                 * ONLY PARM SUPPLIED?\n         BNM   SKIPOPEN                * NO, OMIT INITIALIZATION OF DCB\n         RDJFCB MF=(E,OPENVTOC)        * READ VTOC JFCB\n         MVI   JFCBDSNM,X'04'          * SET UP\n         MVC   JFCBDSNM+1(43),JFCBDSNM * VTOC DSNAME\n         OI    JFCBAREA+52,X'08'       * INDICATE NO JFCB WRITE-BACK\n         OPEN  MF=(E,OPENVTOC),TYPE=J  * OPEN VTOC\n         LA    R11,VTOC                * ADDRESS THE OPENED DCB\nSKIPOPEN ST    R11,VTOCDECB+8          * AND SAVE IN DECB\n         TM    48(R11),X'10'           * CHECK DCB IS OPEN\n         BO    GOODOPEN                * LOOKS OK\nERR1     EQU   *\n         ERROR 1\nGOODOPEN TM    48(R11),X'02'           * DO I HAVE THE DCB TO MYSELF?\n         BO    NOUSER                  * I THINK SO\n         ERROR 2                       * MAYBE NOT\nNOUSER   EQU   *\n         OPEN  (PRINTER,OUTPUT)        * OPEN PRINT FILE\n         TM    PRINTER+48,X'10'        * TEST THAT OPEN WORKED\n         BZ    ERR1                    * ERROR OPENING PRINTER\n* SET UP HDR1 LINE FOR HEAD OF PAGE\n         MVC   HDR1VOL,JFCBVOLS        * VOLUME SERIAL NO\n         TIME  DEC                     * GET TIME OF JOB\n         ST    R0,DWORK+4              * SAVE TIME IN WORKAREA\n         ED    HDR1TIME,DWORK+4        * MOVE TO OUTPUT\n         SR    R0,R0                   * CLEAR OUT R0\n         STM   R0,R1,DWORK             * SAVE DECIMAL DATE\n         CVB   R1,DWORK                * CONVERT DEC DATE TO BIN\n         D     R0,=F'1000'             * SPLIT INTO YEAR & DAY\n         ST    R0,DWORK+4              * STORE BINARY DAYS\n         STH   R1,DWORK+4              * STORE BINARY YEAR\n         BAS   R9,DATECONV             * GO CONVERT DATE\n         ED    HDR1DATE,DWORK+4        * THEN USE CNVRTED RESULT\n         EJECT\n* SETUP TO READ FORMAT 4 DSCB\n         L     R3,44(R11)              * PICK UP DEB ADDR FROM DCB\n         MVC   VTOCFDAD+1(6),36(R3)    * MOVE BBCCHH OF EXTENT START\n         MVI   VTOCFDAD+7,1            * POINT TO 1ST RECD = FMT4\n         BAS   R9,READDSCB+6           * READ THE FORMAT 4\n         CLI   DS1FMTID,C'4'           * IS IT REALLY A FORMAT 4 ?\n         BE    MOVEFMT4                * FORTUNATELY, YES\n         ERROR 3                       * HOW DID WE GET HERE?\nMOVEFMT4 MVC   DS4DATA(71),DS1FMTID    * MOVE FORMAT4 DATA TO SPEC AREA\n         BAS   R9,POINTF5              * GO DO THE CALCULATION PROPERLY\n         LH    R4,46(R3)               * PICK # TRKS IN VTOC FROM DEB\n         SR    R5,R5                   * CLEAR R5\n         IC    R5,DS4DEVDT             * INSERT NO OF DSCB'S PER TRK\n         MR    R4,R4                   * WHENCE FIND # OF DSCBS IN VTOC\n         M     R4,TBLWIDTH             * MULT BY AMT OF CORE PER ENTRY\n         ST    R5,SAVER5               * SAVE TABLE SIZE      DRK JAN10\nGETMAIN  GETMAIN EC,LV=(5),A=TABLADDR  * ESTIMATE CORE REQ FOR FORMAT1S\n         B     *+4(R15)                * SEE IF CORE WAS AVAILABLE\n         B     GOTCORE                 * YES, GO BUILD TABLE\n* INSUFFICIENT CORE TO SORT FORMAT1 DSCBS - POINT ROUTINE TO PICK UP\n* THE SORTED ENTRIES TO THE ROUTINE WHICH READS THEM THE FIRST TIME\n         LA    R2,READFMT1             * GET ROUTINE ADDR\n         ST    R2,RTNADDR              * SAVE IT\n         LA    R2,ENDUP                * GET END-OF-FILE ROUTINE\n         ST    R2,EODADDR              * SAVE IT\n         B     PRNTDSCB                * AND GO IMMEDIATELY TO PRINT\n         EJECT\nGOTCORE  EQU   *\n         L     R4,TABLADDR             * R4 -> TABLE OF DSCBS\nBLDLOOP  BAS   R9,READFMT1             * READ A FORMAT1 DSCB\n         MVC   0(1,R4),DS1DSORG        * DSORG IS HI-ORDER SORT-KEY\n         NI    0(R4),B'10000000'       * TO DISTINGUISH ISAM FILES\n         MVC   1(44,R4),DS1DSNAM       * MOVE DSNAME INTO TABLE\n         MVC   45(5,R4),VTOCFDAD+3     * SET RECORD ADDR OF THIS DSCB\n         LA    R4,50(R4)               * BUMP TABLE POINTER\n         B     BLDLOOP                 * AND GO READ NEXT FORMAT 1\nVTOCEOD  EQU   *                       * COME HERE WHEN DSCBS EXHAUSTED\n         S     R4,TBLWIDTH             * POINT TO LAST TABLE ENTRY\n         ST    R4,TABLEND              * SAVE IN #SORT LIST\n         CP    FMT1CNT,=P'1'           * HOW MANY DATA SETS ON VOLUME\n         BE    VTOCEOD1                * ONLY 1, BYPASS THE SORT\n         BL    PRNTDSCB                * NO FORMAT 1 DSCBS READ\n         #SORT FIELDS=(1,45,CH,A),A=TABLADDR,LENGTH=50 SORT TABLE\nVTOCEOD1 EQU   *\n         L     R4,TABLADDR             * RESET R4 -> TABLE OF DSCBS\n         S     R4,TBLWIDTH             * THEN POINT TO PREVIOUS AREA\n         EJECT\nPRNTDSCB PUT   PRINTER                 * GET A PRINT BUFFER\n         USING HDRLINE,R1              * MAP OUTPUT LINE\n         MVI   0(R1),C' '              * SINGLE SPACE NORMALLY\n         SP    LINECNTR,=P'1'          * DECREMENT LINE-COUNTER\n         BP    PRINTBR                 * NOT HEAD OF PAGE\n         MVC   0(133,R1),HDR1          * MOVE IN A PAGE HEADER\n         AP    PAGECNTR,=P'1'          * ADD 1 TO PAGE-COUNTER\n         ED    HDPAGCNT,PAGECNTR       * AND MOVE TO HEADER LINE\n         PUT   PRINTER                 * GET A PRINT BUFFER\n         CLC   PARM(3),=CL3'PDS'       * DIR BLKS ALLOC/USED REQUEST\n         BNE   NOTPO1                  * NO, LEAVE HEADERS ALONE\n         MVC   HDR2(133),HDR2P         * DIRECTORY BLOCKS\n         MVC   HDR3(133),HDR3P         * ALLOC     USED\nNOTPO1   EQU   *\n         MVC   0(133,R1),HDR2          * MOVE SECOND LINE\n         PUT   PRINTER                 * GET A PRINT BUFFER\n         MVC   0(133,R1),HDR3          * MOVE THIRD LINE\n         PUT   PRINTER                 * GET A PRINT BUFFER\n         ZAP   LINECNTR,MAXLINES       * RESET LINE-COUNTER\n         CP    FMT1CNT,=P'1'           * HOW MANY DATA SETS ON VOLUME\n         BNL   FIRSTDTL                * AT LEAST ONE\n         LR    R10,R1                  * NO FORMAT 1 DSCBS READ\n         B     ENDUP                   * PRINT LAST TWO LINES\nFIRSTDTL EQU   *\n         MVI   0(R1),C'0'              * FIRST DETAIL LINE DOUBLE SPACE\nPRINTBR  NOP   XDPRLPND                * BR IF MULTIPLE EXTENT\n         EJECT\nGETDSCB  LR    R10,R1                  * SAVE POINTER TO BUFFER\n         USING DSNLINE,R10             * AND SET DSECT\n         L     R15,RTNADDR             * ADDR OF ROUTINE TO READ DSCB\n         BASR  R9,R15                  * GO AND DO IT\n         MVC   LNDSN,DS1DSNAM          * MOVE DSNAME\n         MVC   LNCREDT(88),LNEDMSK     * MOVE EDIT MASKS FOR OTHER FLDS\n         MVC   DWORK+5(3),DS1CREDT     * CREATION DATE\n         BAS   R9,DATECONV             * CONVERT DATE\n         ED    LNCREDT,DWORK+4         * MM/DD/YY FORMAT\n         OC    DS1REFD,DS1REFD         * CHECK FOR ZERO REFERENCE DATE\n         BNZ   CNVREFDT                * NON-ZERO, GO CONVERT IT\n         MVC   LNREFDT+1(8),LNREFDT    * ELSE CLEAR TO SPACES\n         B     PARMTEST                * AND CONTINUE\nCNVREFDT MVC   DWORK+5(3),DS1REFD      * REFERENCE DATE\n         BAS   R9,DATECONV             * CONVERT DATE\n         ED    LNREFDT,DWORK+4         * MM/DD/YY FORMAT\nPARMTEST EQU   *\n         CLC   PARM(3),=CL3'PDS'       * DIR BLKS ALLOC/USED REQUEST\n         BNE   NOTPO2                  * NO, SKIP READ OF PDS DIRECTORY\n         MVI   LNCREDT,C' '            * MOVE\n         MVC   LNCREDT+1(8),LNCREDT    * SPACES\n         MVI   LNREFDT,C' '            * MOVE\n         MVC   LNREFDT+1(8),LNREFDT    * SPACES\n         ZAP   DIRTOTAL(3),=PL3'0'     * ZERO COUNTER\n         ZAP   DIRUSED(3),=PL3'0'      * ZERO COUNTER\n         TM    DS1DSORG,B'00000010'    * PARTITIONED ORGANIZATION?\n         BNO   NOTPO2                  * NO\n         TM    DS1SMSFG,DS1PDSEX       * HFS?\n         BO    NOTPO2                  * YES, SKIP\n         MVC   JFCBDSNM,DS1DSNAM       * YES, MOVE DSNAME\n         OI    JFCBAREA+52,X'08'       * INDICATE NO JFCB WRITE BACK\n         OPEN  (PDS,INPUT),TYPE=J      * OPEN PDS\n         XC    DIRSTAT,DIRSTAT         * CLEAR DIRECTORY STATUS BYTE\nGETDIR   EQU   *\n         GET   PDS                     * READ PDS DIRECTORY BLOCKS\n         AP    DIRTOTAL(3),=PL3'1'     * ADD TO TOTAL\n         TM    DIRSTAT,X'80'           * END OF MEMBERS REACHED?\n         BO    GETDIR                  * YES\n         AP    DIRUSED(3),=PL3'1'      * NO, ADD TO USED\n         LR    R5,R1                   * PT AT DIRECTORY BLOCK\n         LH    R6,0(R5)                * # OF BYTES USED IN DIR BLOCK\n         AR    R6,R5                   * A(END OF DIR BLOCK)\n         LA    R5,2(R5)                * GO PAST BYTES USED FIELD\nNAMETTR  EQU   *\n         CR    R5,R6                   * END OF DIRECTORY BLOCK?\n         BNL   GETDIR                  * YES\n         CLC   0(8,R5),=8XL1'FF'       * END OF DIRECTORY MEMBERS?\n         BE    MBREOF                  * YES\n         SR    R1,R1                   * CLEAR A REGISTER\n         NI    11(R5),X'1F'            * TURN OFF BITS 0,1,2\n         IC    R1,11(R5)               * INDICATOR BYTE\n         SLL   R1,1                    * HALFWORDS OF USER DATA\n         AR    R5,R1                   * GO PAST USER DATA\n         LA    R5,12(R5)               * GO PAST NAME/TTR\n         B     NAMETTR                 * CHECK NEXT MEMBER\nMBREOF   EQU   *\n         OI    DIRSTAT,X'80'           * SET END OF MEMBERS FLAG\n         B     GETDIR                  * AND CONTINUE\nPDSEOF   EQU   *\n         CLOSE PDS                     * DISCONNECT\n         FREEPOOL PDS                  * FREE BUFFERS         DRK JAN10\n         MVC   LNCREDT(6),DIRPATT      * EDIT MASK\n         MVC   LNREFDT+2(6),DIRPATT    * EDIT MASK\n         ED    LNCREDT(6),DIRTOTAL     * MOVE TO OUTPUT LINE\n         ED    LNREFDT+2(6),DIRUSED    * MOVE TO OUTPUT LINE\nNOTPO2   EQU   *\n         TM    DS1DSORG,B'00000001'    * UNMOVABLE DATA?\n         BNO   *+8                     * NO, SKIP NEXT INSTR\n         MVI   LNDSORGU,C'U'           * INDICATE UNMOVABLE\n         LH    R0,DS1DSORG             * LOAD DSORG INTO R0\n         SLL   R0,16                   * AND SHIFT TO LHS OF REG\n         LA    R1,7                    * LOAD # OF BITS TO TEST\nDSORGLP  LTR   R0,R0                   * IS HI-ORDER BIT ON?\n         BM    DSORGFND                * YES, ASSUME ONLY BIT SET\n         SLL   R0,1                    * NO, SLIDE NEXT BIT TO SIGN\n         BCT   R1,DSORGLP              * AND TEST THAT\nDSORGFND SLL   R1,1                    * MULTIPLY R1 BY 2\n         LA    R2,ORGTYPES(R1)         * USE IT TO ADDRESS TABLE\n         MVC   LNDSORG,0(R2)           * MOVE CORRESPONDING DSORG\n         TM    DS1DSORG+1,DS1ORGAM     * VSAM?\n         BNO   *+4+6                   * NO\n         MVC   LNDSORG,=CL2'VS'        * YES\n         TM    DS1SMSFG,DS1PDSE        * PDSE?\n         BNO   *+4+6                   * NO\n         MVC   LNDSORG,=CL2'PE'        * YES\n         TM    DS1SMSFG,DS1PDSEX       * HFS?\n         BNO   *+4+6                   * NO\n         MVC   LNDSORG,=CL2'HF'        * YES\n         TM    DS1SMSFG,DS1STRP        * EXTENDED FORMAT DATASET?\n         BNO   *+4+4                   * NO\n         MVI   LNDSORGU,C'X'           * YES\n         EJECT\n         LA    R2,LNRECFM              * ADDRESS OUTPUT RECFM\n         L     R0,DS1RECFM             * LOAD INPUT RECFM\n         LA    R1,FMTYPES              * ADDRESS TABLE OF RECFM TYPES\n         LA    R3,7                    * NO OF BITS TO TEST\n         TM    DS1RECFM,B'11000000'    * FIRST CHECK FOR 'U'\n         BNO   FMLOOP                  * NOT UNDEFINED\n         MVI   0(R2),C'U'              * MOVE IN 'U'\n         N     R0,=X'3FFFFFFF'         * OFF 'F' & 'V' BITS\n         B     FMJUMP                  * AND JOIN LOOP\nFMLOOP   LTR   R0,R0                   * TEST SIGN BIT\n         BNM   FMEND                   * BIT IS OFF\n         MVC   0(1,R2),0(R1)           * MOVE CORRESP CHAR\nFMJUMP   LA    R2,1(R2)                * POINT TO NEXT OUTPUT SPOT\nFMEND    EQU   *\n         LA    R1,1(R1)                * POINT TO NEXT TYPE IN LIST\n         SLL   R0,1                    * SHIFT OVER NEXT BIT\n         BCT   R3,FMLOOP               * AND GO TEST IT\n         LH    R0,DS1BLKL              * PICK UP BLKSIZE\n         CVD   R0,DWORK                * CONVERT TO DECIMAL\n         ED    LNBLKSI,DWORK+5         * MOVE TO OUTPUT\n         LH    R0,DS1LRECL             * PICK UP LRECL\n         CH    R0,=X'8000'             * IF LRECL = X'8000'\n         BNE   NOT32K                  * THIS INDICATES  SPANNED RECDS\n         MVC   LNLRECL+1(5),=C' >32K'      WITH RECD LENGTH > 32756\n         B     CNVKEYLE                * AND THAT'S ALL\nNOT32K   CVD   R0,DWORK                * OTHERWISE WE JUST\n         ED    LNLRECL,DWORK+5         * MOVE VALUE TO OUTPUT\nCNVKEYLE EQU   *\n         SR    R0,R0                   * CLEAR REGISTER\n         IC    R0,DS1KEYL              * INSERT KEYLEN\n         CVD   R0,DWORK                * DECIMALISE\n*        ED    LNKEYLE,DWORK+6         * AND OUTPUT\n         EJECT\n* PICK UP SECONDARY ALLOCATION TYPE AND QUANTITY\n         MVC   DWORK(4),DS1SCALO       * ALIGNMENT\n         L     R2,DWORK                * LOAD SECONDARY ALLOC\n         LA    R1,0(R2)                * SAVE IN R1 WITH HI-ORDER OFF\n         SRL   R2,30                   * SHIFT OVER 2 BIT INDICATOR\n         LA    R0,0(R2,R2)             * DOUBLE IT\n         ALR   R2,R0                   * MAKE IT TRIPLE\n         BNZ   NOTABSTR                * NOT ABSOLUTE TRACK\n         MVC   LNSCALO(10),=C'     ABSTR' INDICATE ABSTR\n         B     SECALEND                * FINISHED\nNOTABSTR LA    R2,SECTYPES-3(R2)       * ADDRESS BLK, TRK OR CYL\n         MVC   LNSCTYPE,0(R2)          * AND MOVE IT TO OUTPUT\n         CVD   R1,DWORK                * CNVRT SEC ALLOC QTY\n*        ED    LNSCALO,DWORK+5         * MOVE TO OUTPUT\n         MVC   TRKSWORK(8),MASKTRKS    * EDIT MASK FOR SEC ALLOC\n         ED    TRKSWORK(8),DWORK+4     * EDIT 7 DIGIT SEC ALLOC\n         MVC   LNSCALO,TRKSWORK+2      * AND MOVE 6 TO OUTPUT\nSECALEND EQU   *                       * THROUGH WITH SEC ALLOC\n         SR    R0,R0                   * CLEAR A REG\n         IC    R0,DS1NOEPV             * INSERT NO. OF EXTENTS\n         CVD   R0,DWORK                * CONVERT TO DECIMAL\n         ED    LNNOEXT,DWORK+6         * MOVE TO OUT-PUT LINE\n         EJECT\n         MVC   LASTBLK,DS1LSTAR        * FIRST SAVE LAST-BLK POINTER\n* ROOM FOR 263 EXTENTS (1 FORMAT 1 PLUS 20 FORMAT 3 DSCB'S) IN TABLE\n* MAX OF 255 EXTENTS IS POSSIBLE\n         LA    R14,XTNTAREA            * AREA TO BE ZEROED\n         LA    R15,2630                * LENGTH\n         SR    R0,R0                   * NULL SOURCE\n         SR    R1,R1                   * NULL SOURCE\n         MVCL  R14,R0                  * FILL WITH PAD 0 FROM R1\n         MVC   XTNTAREA(30),DS1EXT1    * MOVE 1ST 3 EXTENT DESCRIPTS\n         LA    R5,10                   * LOAD MAX # OF F3'S TO READ\n         LA    R6,XTNTAREA+30          * START OF F3'S IN AREA\nCHKCHAIN OC    DS1PTRDS,DS1PTRDS       * IS THERE A FORMAT2 OR 3?\n         BZ    NOCHAIN                 * NO, CHAINING NOT NECC\n         MVC   VTOCFDAD+3(5),DS1PTRDS  * YES, SET ADDRESS\n         BAS   R9,READDSCB+6           * AND READ FORMAT3\n         CLI   DS1FMTID,C'3'           * IS IT A FORMAT 3?\n         BNE   CHKCHAIN                * NO SO CHAIN AGAIN\n         MVC   0(40,R6),DS1DSNAM+4     * MOVE NEXT 4 EXTENT DESCRIPTS\n         MVC   40(90,R6),DS1DSSN       * MOVE NEXT 9 EXTENT DESCRIPTS\n         LA    R6,130(R6)              * POINT TO NEXT SLOT IN AREA\n         BCT   R5,CHKCHAIN             * GO SEE IF MORE\n*\n* NOW FOR SOMETHING TRICKY AFTER ALL THOSE STRAIGHTFORWARD EDITS -\n* FIND THE NUMBER OF TRACKS ALLOCATED\n*\nNOCHAIN  EQU   *\n         LA    R5,XTNTAREA             * SET UP BEGINNING,\n         LA    R6,10                       INCREMENT,\n         LA    R7,XTNTAREA+2620              AND END POINTER FOR LOOP\n         SR    R0,R0                   * ZERO REGISTER TO STORE RESULT\nXTNTLOOP CLI   0(R5),X'00'             * IS THIS A VALID EXTENT?\n         BE    XTNTEXIT                * NO\n         LH    R1,6(R5)                * PICK UP CC FOR EXTENT END\n         SH    R1,2(R5)                * SUBTRACT CC FOR EXTENT START\n         MH    R1,DS4DEVSZ+2           * MULTIPLY BY # TRKS/CYL\n         AH    R1,8(R5)                * ADD HH FOR EXTENT END\n         SH    R1,4(R5)                * SUBTRACT HH FOR EXTENT START\n         LA    R1,1(R1)                * ALLOW FOR LAST TRK OF EXTENT\n         STH   R1,6(R5)                * SAVE # OF TRKS IN TABLE\n         AR    R0,R1                   * ADD IN TO TOTAL TRKS\n         BXLE  R5,R6,XTNTLOOP          * CHECK NEXT EXTENT\nXTNTEXIT SR    R5,R6                   * POINT R5 BACK TO LAST EXTENT\n         LR    R7,R5                   * RESET BXLE LIMIT\n         CVD   R0,DWORK                * CNVERT NO. OF TRKS\n*        ED    LNNOTRKS,DWORK+5        * AND MOVE TO OUTPUT\n         MVC   TRKSWORK(8),MASKTRKS    * EDIT MASK FOR TRKS ALLOC\n         ED    TRKSWORK(8),DWORK+4     * EDIT 7 DIGIT TRKS ALLOC\n         MVC   LNNOTRKS,TRKSWORK+2     * AND MOVE 6 TO OUTPUT\n         BNZ   CNVUSAGE                * OFF TO CONVERT % USAGE\n         MVC   LNUSAGE+1(3),LNUSAGE      EXCEPT WHEN INDETERMINATE\n         B     XDPRNT                  * BECAUSE ZERO ALLOC\n         EJECT\nCNVUSAGE LH    R3,LASTBLK              * PICK UP TT OF LAST BLOCK\n         LA    R3,1(R3)                * ALLOW FOR LAST (PART-USED) TRK\n         SR    R8,R8                   * ZERO REGISTER\n         ICM   R8,3,DS4DEVTK           * LOAD HALFWORD (UP TO 64K)\n         MR    R2,R8                   * CONVERT TO #BYTES USED\n         LR    R1,R0                   * LOAD ODD-REGISTER OF PAIR\n         MR    R0,R8                   * CONVERT TOTAL ALLOC\n         LR    R0,R1                   * COPY TOTAL BYTES ALLOC\n         SRL   R1,1                    * HALVE IT\n         XC    DWORK(8),DWORK          * CLEAR AREA FOR SUBTRACT\n         MVC   DWORK+6(2),LASTBLK+3    * MOVE FOR ALIGNMENT\n         S     R3,DWORK+4              * SUBTRACT TRACK BALANCE\n         M     R2,=F'100'              * MULT BY 100 FOR PERCENT\n         AR    R3,R1                   * ROUND UP BY HALF TOTAL ALLOC\n         DR    R2,R0                   * AND DIVIDE BY TOTAL ALLOCATION\n         CVD   R3,DWORK                * CNVERT RESULT TO DECIMAL\n         ED    LNUSAGE,DWORK+6         * THEN MOVE TO OUTPUT LINE\nXDPRNT   LA    R5,XTNTAREA             * RESET PNTR TO WORKAREA\nXDPRLOOP SR    R0,R0                   * CLEAR WORK REG\n         IC    R0,1(R5)                * OBTAIN EXTENT NUMBER (M)\n         CVD   R0,DWORK                * CONVERT TO DECIMAL\n         ED    LNXDM,DWORK+6           * MOVE TO LINE\n         LH    R15,2(R5)               * PICK UP CYL ADDRESS IN HEX\n         CVD   R15,DWORK               * GET IN PACKED DECIMAL\n         MVC   CCCCWORK(6),MASKCCCC    * USE EDIT MASK FOR 3380 E/K\n         ED    CCCCWORK(6),DWORK+5     * EDIT 5 DIGIT CYLINDER ADDRESS\n         MVC   LNXDCCHH(5),CCCCWORK+1  * SET CYL ADDRESS IN PRINT LINE\n         LH    R15,4(R5)               * PICK UP TRK ADDRESS IN HEX\n         CVD   R15,DWORK               * GET IN PACKED DECIMAL\n*        ED    LNXDCCHH+4(4),DWORK+6   * SET TRK ADDRESS IN PRINT LINE\n         MVC   CCCCWORK(4),=X'40202120' * HH EDIT MASK\n         ED    CCCCWORK(4),DWORK+6     * EDIT TRK ADDRESS\n         MVI   LNXDCCHH+5,C' '         * SPACE\n         MVC   LNXDCCHH+6(2),CCCCWORK+2 * SET TRK ADDRESS IN PRINT LINE\n         SR    R0,R0                   * ZERO REGISTER\n         ICM   R0,3,6(R5)              * PICK UP # TRKS\n         CVD   R0,DWORK                * CONVERT\n*        ED    LNXD#TRK,DWORK+5        * AND EDIT TO LINE\n         MVC   TRKSWORK(8),MASKTRKS    * EDIT MASK FOR # TRKS\n         ED    TRKSWORK(8),DWORK+4     * EDIT 7 DIGIT # TRKS\n         MVC   LNXD#TRK,TRKSWORK+2     * AND MOVE 6 TO OUTPUT\n         BXH   R5,R6,PRNTDSCB          * FINISH IF ALL EXTENTS DONE\n         MVI   PRINTBR+1,X'F0'         * MAKE A BRANCH\n         B     PRNTDSCB                * GO PRINT A LINE\nXDPRLPND MVI   PRINTBR+1,X'00'         * RESET TO NOP\n         LR    R10,R1                  * SET BUFFER POINTER\n         MVI   LNCC+1,C' '             * INITIALISE\n         MVC   LNCC+2(112),LNCC+1      * TO SPACES\n         MVC   LNXDM(21),LNEXTDSC      * MOVE IN NEW EDIT MSK\n         B     XDPRLOOP                * CONTINUE WITH NEXT EXTENT\n         EJECT\nREADDSCB MVC   VTOCFDAD,VTOCNEXT       * MOVE ADDRESS OF NEXT DSCB\n         READ  VTOCDECB,DIR,VTOC,DS1FMTID,'S',DS1DSNAM,                *\n               VTOCFDAD,VTOCNEXT\n         CHECK VTOCDECB                * WAIT FOR IT TO ARRIVE\n         TM    VTOCDECB+1,B'10000100'  * NO RECD FND / EOF\n         L     R15,EODADDR             * PICK UP EODAD\n         BCR   7,R15                   * GO THERE IF NRF OR EOF\nPOINTF5  EQU   *\n         MVC   VTOCNEXT,VTOCFDAD       * MOVE OLD DISC ADDRESS\n         SR    R15,R15                 * CLEAR R15\n         SR    R1,R1                   * AND R1\n         LA    R0,1                    * SET R0 TO 1\n         IC    R15,VTOCNEXT+7          * PICK UP RECD NO. ON TRK\n         IC    R1,DS4DEVDT             * PICK UP MAX RECDS PER TRK\n         BXH   R15,R0,NEXTTRK          * BRANCH IF HIGH\n         STC   R15,VTOCNEXT+7          * ELSE SAVE BUMPED VALUE\n         BR    R9                      * THEN RETURN\nNEXTTRK  MVI   VTOCNEXT+7,1            * RESET R TO 1\n         LH    R15,VTOCNEXT+5          * PICK UP CC\n         LH    R1,DS4DEVSZ+2           * AND NO. TRKS/CYL\n         BCTR  R1,0                    * MINUS ONE\n         BXH   R15,R0,NEXTCYL          * BUMP AND TEST\n         STH   R15,VTOCNEXT+5          * SAVE INCREMENTED VALUE\n         BR    R9                      * AND EXIT\nNEXTCYL  AH    R0,VTOCNEXT+3           * ADD 1 TO CC\n         SLL   R0,16                   * INSERT ZEROS ON RIGHT\n         ST    R0,VTOCNEXT+3           * SAVE NEW CCHH\n         BR    R9                      * THEN RETURN\n         EJECT\nREADFMT1 EQU   *                       * READ A FORMAT 1\n         LR    R3,R9                   * SAVE LINK REG\nTSTHPCHR CLC   VTOCNEXT+3(5),DS4HPCHR  * IS ADDR HIGHER THAN\n*                                          HIGHEST FORMAT 1 ?\n         L     R15,EODADDR             * PICK UP EODAD\n         BCR   2,R15                   * GO THERE IF FINISHED\n         BAS   R9,READDSCB             * READ A DSCB\n         CLI   DS1FMTID,C'1'           * IS IT A FORMAT1?\n         BNE   TSTHPCHR                * IF NO, TRY AGAIN\n         AP    FMT1CNT,=P'1'           * INCLUDE THIS DSCB IN COUNT\n         LR    R9,R3                   * RESTORE LINK\n         BR    R9                      * AND RETURN\n         EJECT\nREADTABL EQU   *\n         LA    R4,50(R4)               * BUMP POINTER\n         C     R4,TABLEND              * FINISHED?\n         BH    ENDUP                   * YES\n         MVC   VTOCFDAD+3(5),45(R4)    * MOVE CCHHR FROM TABLE\n         B     READDSCB+6              * GO READ NEXT DSCB\n         EJECT\nENDUP    ED    FLINE1CT,FMT1CNT+1      * SET NO OF DATA SETS IN PRT LNE\n         MVC   0(133,R10),FLINE1       * SET PRINT LINE PROPER\n         L     R11,VTOCDECB+8          * PT @ DCB\n         L     R3,44(R11)              * PICK UP DEB ADDR FROM DCB\n         L     R0,32(R3)               * PICK UP UCB ADDR FROM DEB\n         LA    R1,MESSAGE              * LSPACE MESSAGE AREA\n         SVC   78                      * LSPACE SVC\n         PACK  DBLWD1+5(3),TOTCYLS     * CONVERT TO PACKED DECIMAL\n         PACK  DBLWD2+5(3),TOTTRKS     * CONVERT TO PACKED DECIMAL\n         ED    FLINE2C,DBLWD1+5        * SET NO OF CYLS IN PRT LINE\n         ED    FLINE2T,DBLWD2+5        * SET NO OF TRKS IN PRT LINE\n         PUT   PRINTER                 * GET BUFFER POSITION\n         MVC   0(133,R1),FLINE2        * MOVE INTO BUFFER\n         CLOSE (VTOC,,PRINTER)         * CLOSE FILES\n         FREEPOOL PRINTER              * FREE BUFFERS         DRK JAN10\n         L     R1,TABLADDR             * LOAD TABLE ADDRESS   DRK JAN10\n         LTR   R1,R1                   * GETMAIN SUCCESSFUL?  DRK JAN10\n         BZ    RETURN                  * NO, SKIP FREEMAIN    DRK JAN10\n         L     R5,SAVER5               * RESTORE TABLE SIZE   DRK JAN10\nFREEMAIN FREEMAIN EC,LV=(5),A=TABLADDR * FREE FORMAT1 AREA    DRK JAN10\nRETURN   DS    0H\n         L     R13,4(R13)              * RESTORE R13\n         RETURN (14,12),RC=0           * RETURN TO CALLER\n         EJECT\n* DATE CONVERSION - DATE IN FORMAT YDD IS ASSUMED TO BE IN LAST\n* THREE BYTES OF DWORK\nDATECONV EQU   *                       * CONVERT DATE TO DECIMAL\n         LA    R0,28                   * LOAD 28 DAYS FOR FEBRUARY\n         TM    DWORK+5,3               * TEST FOR LEAP YEAR\n         BNZ   *+8                     * NO, SKIP NEXT INSTR\n         LA    R0,29                   * YES, 29 DAYS IN FEB\n         STH   R0,DATETABL+2           * STORE FEB DAYS\n         LA    R15,DATETABL            * POINT TO TABLE START\n         LA    R1,DATETABL+22          * AND TABLE END\n         LA    R0,2                    * LOAD BXLE INCREMENT\n         LH    R14,DWORK+6             * PICK UP # DAYS IN YEAR\nDATELOOP SH    R14,0(R15)              * SUBTRACT TABLE ENTRY\n         BNP   MNTHFND                 * IF -VE, HAVE HIT REQD MONTH\n         BXLE  R15,R0,DATELOOP         * ELSE LOOP AGAIN\n         XC    DWORK,DWORK             * IF NO MATCH, THEN ERROR\n         BR    R9                      * SO RETURN\nMNTHFND  AH    R14,0(R15)              * ALLOW FOR LAST SUBTRACT\n         S     R15,=A(DATETABL-2)      * FIND TABLE DISPLACEMENT\n         MH    R15,=H'5000'            * OBTAIN MONTH*10000\n         MH    R14,=H'100'             * AND DAY*100\n         SR    R0,R0                   * CLEAR R0\n         IC    R0,DWORK+5              * GET YEAR NO. 000000YY\n         C     R0,=F'100'              * Y2K DATE?\n         BL    *+8                     * NO\n         S     R0,=F'100'              * YES, AVOID OVERFLOW INTO DD\n         AR    R0,R14                  * ADD DAY      0000DDYY\n         AR    R0,R15                  * AND MONTH    00MMDDYY\n         CVD   R0,DWORK                * CONVERT      0MMDDYYC\n         MVO   DWORK,DWORK             * AND SHIFT    MMDDYYCC\n         BR    R9                      * RETURN FOR EDIT\nDATETABL DC    H'31,28,31,30,31,30'    * TABLE USED TO FIND\n         DC    H'31,31,30,31,30,31'    * THE NUMBER OF THE MONTH\n         PUSH  USING                   * SAVE USING STATUS\n         DROP  ,                       * DROP ALL BASE REGS\n         EJECT\nIOERR    EQU   *                       * SYNAD ROUTINE\n         USING *,R15                   * R13 IS CLOBBERED\n         SYNADAF ACSMETH=BDAM          * PERFORM SYSTEM ERROR ANALYSIS\n         MVC   SYNERMSG(60),68(R1)     * MOVE USEFUL PART OF SYSMSG\n         MVC   SYNADVOL,JFCBVOLS       * SET VOL SER NO IN MESSAGE\n         WTO   MF=(E,SYNADMSG)         * ISSUE ERROR MESSAGE\n         BASR  R15,0                   * R15 DESTROYED BY WTO\n         USING *,R15                   * SO BASE MUST BE RESET\n         MVI   DS1FMTID,X'00'          * ENSURE BAD DSCB IGNORED\n         SYNADRLS ,                    * RESTORE R13\n         DROP  R15                     * RELEASE R15\n         BR    R14                     * RETURN TO CHECK ROUTINE\n         POP   USING                   * RESTORE USING STATUS\n         EJECT\nDBLWD1   DC    D'0'                    * WORK AREA FOR FREE CYL COUNT\nDBLWD2   DC    D'0'                    * WORK AREA FOR FREE TRK COUNT\nDWORK    DC    D'0'                    * WORKAREA\nVTOCFDAD DC    D'0'                    * FULL DISC ADDR - MBBCCHHR\nSAVER5   DC    F'0'                    * SAVEAREA FOR R5      DRK JAN10\nTABLADDR DC    A(0)                    * ADDRESS OF TABLE OF DSCB'S\nTBLWIDTH DC    A(50)                   * SIZE OF TABLE ENTRY\nTABLEND  DC    A(0)                    * END OF TABLE\nRTNADDR  DC    A(READTABL)             * DEFAULT ROUTINE\nEODADDR  DC    A(VTOCEOD)              * END-OF-FILE ROUTINE\nFMT1CNT  DC    PL4'0'                  * NO OF FORMAT 1 DSCBS READ\nLASTBLK  DC    XL5'00'                 * SAVEAREA FOR LAST BLOCK PNTR\nVTOCNEXT DC    XL8'00'                 * MUST ALIGN AT FULLWD+1\nLINECNTR DC    P'000'                  * LINE COUNTER\nMAXLINES DC    P'54'                   * LINES PER PAGE\nPAGECNTR DC    P'000'                  * PAGE COUNTER\nPARM     DC    CL3' '                  * JCL PARM HOLD AREA\nHALFWD   DC    H'0'                    * WORK AREA FOR ALIGNMENT\nDIRSTAT  DC    XL1'00'                 * PDS DIR STATUS\nDIRTOTAL DC    PL3'0'                  * PDS DIR BLKS ALLOC\nDIRUSED  DC    PL3'0'                  * PDS DIR BLKS USED\nDIRPATT  DC    X'402020202120'         * EDIT MASK FOR DIR BLKS\nMASKCCCC DC    X'402020202120'         * EDIT MASK FOR CYLINDERS\nMASKTRKS DC    X'4020202020202120'     * EDIT MASK FOR TRKS ALLOC\nCCCCWORK DC    CL6' '                  * WORK AREA FOR CYLINDER EDIT\nTRKSWORK DC    CL8' '                  * WORK AREA FOR TRKS ALLOC EDIT\nFMTYPES  DC    CL8'FVTBSAM'            * PERMISSIBLE RECFM'S\nORGTYPES DC    C'  POMQCQCXDAPSIS'     * DSORG TYPES\nSECTYPES DC    C'BLKTRKCYL'            * TYPES OF ALLOCATION\nLNEDMSK  DS    0CL88                   * EDIT MASK FOR DSN OUTPUT LINE\n         DC    2X'402120612020612020'  * CREATION/LAST REF DATE\n         DC    C' '\n         DC    CL3' '                  * DSORG(U)\n         DC    C' '\n         DC    CL5' '                  * RECFM\n         DC    X'402020202020'         * BLKSIZE\n         DC    X'402020202020'         * LRECL\n         DC    C' '\n         DC    X'402020202120'         * TRKS ALLOC\n         DC    X'40202120'             * PERCENT USE\n         DC    X'40202120'             * NUMBER OF EXTENTS\n         DC    C' '\n         DC    X'402020202120'         * SECONDARY EXTENT QUANTITY\n         DC    C' '\n         DC    CL3' '                  * SECONDARY EXTENT TYPE\n         DC    C' '                    *\nLNEXTDSC DS    0CL21                   * EXTENT DESCRIPTION\n         DC    X'40202120'             * EXTENT NUMBER\n         DC    C' '\n         DC    X'4020212040202120'     * CCHH OF EXTENT\n         DC    CL2' '\n         DC    X'402020202120'         * NO OF TRKS IN EXTENT\n         PRINT NOGEN\nPRINTER  DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PL,LRECL=133,            *\n               RECFM=FBA\nVTOC     DCB   DDNAME=SYSUT1,DSORG=DA,MACRF=RIC,OPTCD=A,               *\n               SYNAD=IOERR,RECFM=FS,BLKSIZE=96,KEYLEN=44,EXLST=VTOCXLST\nPDS      DCB   DDNAME=SYSUT1,                                          *\n               RECFM=U,                                                *\n               BLKSIZE=256,                                            *\n               EODAD=PDSEOF,                                           *\n               DSORG=PS,                                               *\n               MACRF=GL,                                               *\n               EXLST=VTOCXLST\nOPENVTOC OPEN  (VTOC,INPUT),MF=L       * LIST FOR E-TYPE OPEN, RDJFCB\nVTOCXLST DC    X'87',AL3(JFCBAREA)     * JFCB ENTRY IN EXIT LIST\nSYNADMSG DC    AL2(JFCBDSNM+44-*,0)    * WTO RECD DESCRIPTOR WORD\n         DC    C'VTOCLIST - I/O ERROR READING VTOC ON '\nSYNADVOL DC    C'******'\n         DC    C', SYNADAF INFO ='\nSYNERMSG DC    CL16' '                 * INITIALISE TO SPACES\n         ORG   *-4                     * BACKSPACE\n         DS    0F                      * ALIGN TO FULLWORD\nJFCBAREA DS    0CL176                  * SPACE FOR VTOC JFCB\nJFCBDSNM DS    CL44                    * VTOC DSN - ALSO SYNAD WRKAREA\n         DS    CL132                   * SPACE FOR REST OF JFCB\nJFCBVOLS EQU   JFCBAREA+118            * VOLUME SERIAL NO.\n         EJECT\n         PRINT GEN\n         IECSDSL1 (1)                  * FORMAT 1 DSCB\nDS4DATA  DS    0CL71\n         IECSDSL1 (4)                  * FORMAT 4 DSCB\n         EJECT\nMESSAGE  DC    30C'0'                  * OUTPUT AREA FOR LSPACE SVC\n         ORG   MESSAGE\n         DS    CL6\nTOTCYLS  DS    CL4                     * FREE CYLINDERS\n         DS    CL1\nTOTTRKS  DS    CL4                     * FREE TRACKS\n         ORG   ,\nHDR1     DC    133C'*'\n         ORG   HDR1\n         DC    C'1*** CONTENTS OF '\nHDR1FILE DC    C'THE VOLUME TABLE OF CONTENTS'\n         DC    C' ON VOLUME '\nHDR1VOL  DC    C'******'\n         DC    C' *** DATE ='\nHDR1DATE DC    X'402120612020612020'\n         DC    C' *** TIME ='\nHDR1TIME DC    X'4021204B20204B202040'\n         ORG   HDR1+120\n         DC    C' PAGE'\n         DC    X'4020202040'\n         ORG   HDR1+133\nHDR2     DC    CL33'-                                              '\n         DC    C'               DATE     DATE   DS-        BLK-    '\n         DC    C'    TRKS   %  NO.    SEC-ALLOC  EXTENT-DESCRIPTION'\nHDR3     DC    CL33'    DATASET NAME                               '\n         DC    C'              CREATED  LASTREF ORG RECFM  SIZE LRE'\n         DC    C'CL  ALLOC USE EXTS   QTY TYPE   M    CC HH   #TRKS'\nHDR2P    DC    CL33'-                                              '\n         DC    C'             DIRECTORY  BLOCKS DS-        BLK-    '\n         DC    C'    TRKS   %  NO.    SEC-ALLOC  EXTENT-DESCRIPTION'\nHDR3P    DC    CL33'    DATASET NAME                               '\n         DC    C'             ALLOCATED  USED   ORG RECFM  SIZE LRE'\n         DC    C'CL  ALLOC USE EXTS   QTY TYPE   M    CC HH   #TRKS'\nFLINE1   DC    CL15'0 *** THERE ARE'\nFLINE1CT DC    X'402020202120'\n         DC    CL112' DATA SETS ON THIS VOLUME.'\nFLINE2   DC    CL15'  *** THERE ARE'\nFLINE2C  DC    XL6'402020202120'\n         DC    CL21' EMPTY CYLINDERS PLUS'\nFLINE2T  DC    XL6'402020202120'\n         DC    CL85' EMPTY TRACKS ON THIS VOLUME.'\n         LTORG\n         DC    0F'0'                   * ENSURE XTNTAREA ALIGNED\nXTNTAREA DC    30X'00'                 * EXTENTS 1-3   (F1)\n         DC    2600X'00'               * EXTENTS 4-263 (F3, 20 MAX)\n         EJECT\nHDRLINE  DSECT\n         DS    CL125\nHDPAGCNT DS    XL4\nDSNLINE  DSECT\nLNCC     DS    C                       * CARRIAGE CONTROL BYTE\nLNDSN    DS    CL44                    * DATASET NAME\nLNCREDT  DS    CL9                     * CREATION DATE\nLNREFDT  DS    CL9                     * LAST REFERENCE DATE\n         DS    C\nLNDSORG  DS    CL2                     * DSORG\nLNDSORGU DS    C                       * UNMOVABLE FLAG\n         DS    C\nLNRECFM  DS    5C                      * RECFM\nLNBLKSI  DS    CL6                     * BLKSIZE\nLNLRECL  DS    CL6                     * LRECL\n         DS    C\nLNNOTRKS DS    CL6                     * TOTAL NO. OF TRKS ALLOCATED\nLNUSAGE  DS    CL4                     * PERCENTAGE USE OF ALLOC SPACE\nLNNOEXT  DS    CL4                     * NUMBER OF EXTENTS\n         DS    C\nLNSCALO  DS    CL6                     * SECONDARY ALLOCATION QTY\n         DS    C\nLNSCTYPE DS    CL3                     * TYPE OF ALLOC - TRK/CYL/BLK\n         DS    C\nLNXDM    DS    CL4                     * EXTENT-DESCRIPTION - M\n         DS    C\nLNXDCCHH DS    CL8                     * EXTENT DESCRIPTION - CCHH\n         DS    CL2\nLNXD#TRK DS    CL6                     * EXTENT DESCRIPTION - NO OF TRK\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VT0CLIST": {"ttr": 778, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x19\\x00Y\\x00\\x85!\\x7f\\x01\\x02\\x08O\\x089\\x02\\xfd\\x02\\xa1\\x00\\x00\\xe3\\xd9\\xc9\\xc4\\xd1\\xd2@@@@'", "ispf": {"version": "01.25", "flags": 0, "createdate": "1985-08-05T00:00:00", "modifydate": "2002-03-25T08:39:59", "lines": 765, "newlines": 673, "modlines": 0, "user": "TRIDJK"}, "text": "         TITLE 'VTOCLIST - LIST VTOC OF SYSUT1'\n***********************************************************************\n**@@NAME=U10001AS      EUROPEAN GUIDE MODS SEE ABSTR.FLE. 3-75 GUIDE  *\n*                                                                     *\n* AUTHOR -     P.E.HAVERCAN - C.A.V. LIMITED                          *\n*                                                                     *\n* TITLE -      VTOCLIST                                               *\n*                                                                     *\n* FUNCTION -   LIST THE VTOC ON A DASD VOLUME                         *\n*                                                                     *\n* JCL -        //VTOCLIST   EXEC  PGM=VTOCLIST                        *\n*              //SYSPRINT   DD  SYSOUT=*                              *\n*              //SYSUT1     DD  UNIT=SYSALLDA,DISP=SHR,VOL=SER=VVVVVV *\n*                                                                     *\n*              PARM='PDS' WILL PRINT DIRECTORY BLOCKS ALLOCATED/USED  *\n*              INSTEAD OF THE CREATION/LAST REFERENCE DATES.  THIS    *\n*              REQUIRES READALL IN ACF2 (RACF?) IN ORDER TO OPEN EACH *\n*              PDS DIRECTORY ON THE VOLUME WITHOUT GETTING SECURITY   *\n*              VIOLATIONS.                                            *\n*                                                                     *\n* ATTRIBUTES - NONREUSABLE                                            *\n*                                                                     *\n* MODIFIED   - JOHN KALINICH, USA LOGISTICS SYSTEMS SUPPORT CENTER    *\n*                                                                     *\n* 09/20/78 -   FIX MISCELLANEOUS BUGS AND 0C4 ABENDS.                 *\n*                                                                     *\n*              PDS DIRECTORY BLOCKS ALLOCATED/USED OPTION.            *\n*                                                                     *\n* 09/18/85 -   PRINT THE LAST REFERENCE DATE INSTEAD OF THE           *\n*              EXPIRATION DATE.                                       *\n*                                                                     *\n*              3380/3390 SUPPORT.                                     *\n*                                                                     *\n*              PRINT DATES IN AMERICAN (MM/DD/YY) FORMAT              *\n*              INSTEAD OF EUROPEAN (DD/MM/YY) FORMAT.                 *\n*                                                                     *\n* 06/10/88 -   PRINT UP TO 123 EXTENTS FOR ICF VSAM DATA SETS.        *\n*                                                                     *\n* 01/09/98 -   PROCESS YEAR 2000 VTOC DATES CORRECTLY.                *\n*                                                                     *\n* 08/12/99 -   DISPLAY NEW DSORG TYPES:  PDSE, HFS, AND VSAM EF       *\n*                                                                     *\n***********************************************************************\n         MACRO\n&NAME    #SORT &FIELDS=(1,1,CH,A),&FIRST=,&LAST=,&A=,&FORMAT=,         *\n               &LENGTH=\n.*       AUTHOR - PETER HAVERCAN\n         GBLC  &##EQU\n         LCLA  &X,&Y,&Z,&LEN\n         LCLC  &HI,&LO,&R0,&R1,&R14,&R15\n&X       SETA  N'&FIELDS\n         AIF   (&X NE 3 AND &X NE 4).ERR1\n         AIF   (&X EQ 4 AND '&FIELDS(3)' NE 'CH').ERR2\n&HI      SETC  'H'\n&LO      SETC  'L'\n         AIF   ('&FIELDS(&X)' NE 'D').TESTA\n&HI      SETC  'L'\n&LO      SETC  'H'\n         AGO   .SETREGS\n.TESTA   AIF   ('&FIELDS(&X)' EQ 'A').SETREGS\n         MNOTE *,'*** SORT TYPE NOT A OR D - A ASSUMED'\n.SETREGS ANOP\n&R0      SETC  '&##EQU.0'\n&R1      SETC  '&##EQU.1'\n&R14     SETC  '&##EQU.14'\n&R15     SETC  '&##EQU.15'\n         AIF   ('&LENGTH' EQ '').NOLNGTH\n&LEN     SETA  &LENGTH\n         AGO   .LENSET\n.NOLNGTH ANOP\n&LEN     SETA  L'&FIRST\n.LENSET  ANOP\n&X       SETA  &FIELDS(1)-1            OFFSET WITHIN RECORD\n&Y       SETA  &FIELDS(2)              LENGTH OF SORT-KEY\n&Z       SETA  &X+&LEN                 OFFSET WITHIN NEXT RECORD\n         AIF   ('&FIRST&LAST' EQ '').ATYPE\n&NAME    LA    &R15,&FIRST             ADDRESS FIRST ENTRY\n         LA    &R0,&LENGTH             LOAD WIDTH OF TABLE\n         LA    &R1,&LAST               ADDRESS LAST ENTRY\n         AGO   .STEPBCK\n.ATYPE   AIF   ('&A' EQ '').ERR3\n&NAME    LM    &R15,&R1,&A             FIRST ENTRY,WIDTH,LAST ENTRY\n.STEPBCK ANOP\n         SR    &R1,&R0                 R1 POINTS AT PENULTIMATE\n         CLC   &X.(&Y,&R15),&Z.(&R1)   COMPARE FIRST & LAST ENTRIES\n         B&LO  *+22                    RECDS IN SEQUENCE\n         XC    0(&LEN,&R15),&LEN.(&R1) SWITCH FIRST AND\n         XC    &LEN.(&LEN,&R1),0(&R15) LAST ENTRIES INTO\n         XC    0(&LEN,&R15),&LEN.(&R1) CORRECT SEQUENCE\n         LA    &R14,&LEN.(&R15)        ADDRESS NEXT RECORD\n         CLC   &X.(&Y,&R14),&X.(&R15)  COMPARE SORT KEYS\n         BN&LO *+26                    IN SEQUENCE FROM FRONT\n         XC    0(&LEN,&R14),0(&R15)    SWITCH FIELDS\n         XC    0(&LEN,&R15),0(&R14)    WHICH ARE OUT\n         XC    0(&LEN,&R14),0(&R15)    OF SEQUENCE\n         B     *+32                    GO TO LOOP CONTROL\n         CLC   &X.(&Y,&R14),&Z.(&R1)   COMPARE WITH FINAL RECORD\n         BN&HI *+22                    IN SEQUENCE FROM REAR\n         XC    0(&LEN,&R14),&LEN.(&R1) SWITCH FIELDS\n         XC    &LEN.(&LEN,&R1),0(&R14) WHICH ARE OUT\n         XC    0(&LEN,&R14),&LEN.(&R1) OF SEQUENCE\n         BXLE  &R14,&R0,*-60           INCREMENT & LOOP BACK\n         SR    &R1,&R0                 DECREMENT END POINTER\n         BXLE  &R15,&R0,*-98           ADVANCE FRONT POINTER\n         MEXIT\n.ERR1    MNOTE 8,'INVALID NO. OF ENTRIES IN FIELDS PARAMETER'\n         MEXIT\n.ERR2    MNOTE 4,'FORMAT TYPE IS NOT SUPPORTED'\n         MEXIT\n.ERR3    MNOTE 8,'NEITHER A NOR FIRST AND LAST ARE SPECIFIED'\n         MEND\n*\n         MACRO\n&NAME    ERROR &A\n&NAME    ABEND &A\n         MEND\n*\n         EJECT\nVTOCLIST CSECT\n*        AUTHOR - P.E.HAVERCAN - C.A.V. LIMITED\n*        REGEQU                        * SYMBOLIC REGISTERS\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         USING VTOCLIST,R15            * ADDRESS SAVEAREA\n         STM   R14,R12,12(R13)         * SAVE REGISTERS\n         ST    R13,SAVEAREA+4          * BACKWARD TO CALLER\n         LR    R5,R13                  * KEEP FOR A WHILE\n         CNOP  0,4                     * ALIGN TO FULLWORD FOR R13\n         BAL   R13,SAVEAREA+72         * PRIME 1ST BASE\n         DROP  R15\n         USING *,R13,R12               * DECLARE BASE REGISTERS\nSAVEAREA DC    18F'0'                  * 72-BYTE SAVEAREA\n         ST    R13,8(R5)               * FORWARD FROM CALLER\n         LA    R12,2048(R13)           * +2K PAST 1ST BASE\n         LA    R12,2048(R12)           * +4K PAST 1ST BASE\n         LM    R10,R11,0(R1)           * PICK UP PARM ADDR & DCB ADDR\n         CLC   0(2,R10),=XL2'0000'     * PARM ENTERED?\n         BE    NOPARM                  * NO\n         MVC   PARM(3),2(R10)          * YES, KEEP\nNOPARM   EQU   *\n         LTR   R10,R10                 * ONLY PARM SUPPLIED?\n         BNM   SKIPOPEN                * NO, OMIT INITIALIZATION OF DCB\n         RDJFCB MF=(E,OPENVTOC)        * READ VTOC JFCB\n         MVI   JFCBDSNM,X'04'          * SET UP\n         MVC   JFCBDSNM+1(43),JFCBDSNM * VTOC DSNAME\n         OI    JFCBAREA+52,X'08'       * INDICATE NO JFCB WRITE-BACK\n         OPEN  MF=(E,OPENVTOC),TYPE=J  * OPEN VTOC\n         LA    R11,VTOC                * ADDRESS THE OPENED DCB\nSKIPOPEN ST    R11,VTOCDECB+8          * AND SAVE IN DECB\n         TM    48(R11),X'10'           * CHECK DCB IS OPEN\n         BO    GOODOPEN                * LOOKS OK\nERR1     EQU   *\n         ERROR 1\nGOODOPEN TM    48(R11),X'02'           * DO I HAVE THE DCB TO MYSELF?\n         BO    NOUSER                  * I THINK SO\n         ERROR 2                       * MAYBE NOT\nNOUSER   EQU   *\n         OPEN  (PRINTER,OUTPUT)        * OPEN PRINT FILE\n         TM    PRINTER+48,X'10'        * TEST THAT OPEN WORKED\n         BZ    ERR1                    * ERROR OPENING PRINTER\n* SET UP HDR1 LINE FOR HEAD OF PAGE\n         MVC   HDR1VOL,JFCBVOLS        * VOLUME SERIAL NO\n         TIME  DEC                     * GET TIME OF JOB\n         ST    R0,DWORK+4              * SAVE TIME IN WORKAREA\n         ED    HDR1TIME,DWORK+4        * MOVE TO OUTPUT\n         SR    R0,R0                   * CLEAR OUT R0\n         STM   R0,R1,DWORK             * SAVE DECIMAL DATE\n         CVB   R1,DWORK                * CONVERT DEC DATE TO BIN\n         D     R0,=F'1000'             * SPLIT INTO YEAR & DAY\n         ST    R0,DWORK+4              * STORE BINARY DAYS\n         STH   R1,DWORK+4              * STORE BINARY YEAR\n         BAL   R9,DATECONV             * GO CONVERT DATE\n         ED    HDR1DATE,DWORK+4        * THEN USE CNVRTED RESULT\n         EJECT\n* SETUP TO READ FORMAT 4 DSCB\n         L     R3,44(R11)              * PICK UP DEB ADDR FROM DCB\n         MVC   VTOCFDAD+1(6),36(R3)    * MOVE BBCCHH OF EXTENT START\n         MVI   VTOCFDAD+7,1            * POINT TO 1ST RECD = FMT4\n         BAL   R9,READDSCB+6           * READ THE FORMAT 4\n         CLI   DS1FMTID,C'4'           * IS IT REALLY A FORMAT 4 ?\n         BE    MOVEFMT4                * FORTUNATELY, YES\n         ERROR 3                       * HOW DID WE GET HERE?\nMOVEFMT4 MVC   DS4DATA(71),DS1FMTID    * MOVE FORMAT4 DATA TO SPEC AREA\n         BAL   R9,POINTF5              * GO DO THE CALCULATION PROPERLY\n         LH    R4,46(R3)               * PICK # TRKS IN VTOC FROM DEB\n         SR    R5,R5                   * CLEAR R5\n         IC    R5,DS4DEVDT             * INSERT NO OF DSCB'S PER TRK\n         MR    R4,R4                   * WHENCE FIND # OF DSCBS IN VTOC\n         M     R4,TBLWIDTH             * MULT BY AMT OF CORE PER ENTRY\nGETMAIN  GETMAIN EC,LV=(5),A=TABLADDR  * ESTIMATE CORE REQ FOR FORMAT1S\n         B     *+4(R15)                * SEE IF CORE WAS AVAILABLE\n         B     GOTCORE                 * YES, GO BUILD TABLE\n* INSUFFICIENT CORE TO SORT FORMAT1 DSCBS - POINT ROUTINE TO PICK UP\n* THE SORTED ENTRIES TO THE ROUTINE WHICH READS THEM THE FIRST TIME\n         LA    R2,READFMT1             * GET ROUTINE ADDR\n         ST    R2,RTNADDR              * SAVE IT\n         LA    R2,ENDUP                * GET END-OF-FILE ROUTINE\n         ST    R2,EODADDR              * SAVE IT\n         B     PRNTDSCB                * AND GO IMMEDIATELY TO PRINT\n         EJECT\nGOTCORE  EQU   *\n         L     R4,TABLADDR             * R4 -> TABLE OF DSCBS\nBLDLOOP  BAL   R9,READFMT1             * READ A FORMAT1 DSCB\n         MVC   0(1,R4),DS1DSORG        * DSORG IS HI-ORDER SORT-KEY\n         NI    0(R4),B'10000000'       * TO DISTINGUISH ISAM FILES\n         MVC   1(44,R4),DS1DSNAM       * MOVE DSNAME INTO TABLE\n         MVC   45(5,R4),VTOCFDAD+3     * SET RECORD ADDR OF THIS DSCB\n         LA    R4,50(R4)               * BUMP TABLE POINTER\n         B     BLDLOOP                 * AND GO READ NEXT FORMAT 1\nVTOCEOD  EQU   *                       * COME HERE WHEN DSCBS EXHAUSTED\n         S     R4,TBLWIDTH             * POINT TO LAST TABLE ENTRY\n         ST    R4,TABLEND              * SAVE IN #SORT LIST\n         CP    FMT1CNT,=P'1'           * HOW MANY DATA SETS ON VOLUME\n         BE    VTOCEOD1                * ONLY 1, BYPASS THE SORT\n         BL    PRNTDSCB                * NO FORMAT 1 DSCBS READ\n         #SORT FIELDS=(1,45,CH,A),A=TABLADDR,LENGTH=50 SORT TABLE\nVTOCEOD1 EQU   *\n         L     R4,TABLADDR             * RESET R4 -> TABLE OF DSCBS\n         S     R4,TBLWIDTH             * THEN POINT TO PREVIOUS AREA\n         EJECT\nPRNTDSCB PUT   PRINTER                 * GET A PRINT BUFFER\n         USING HDRLINE,R1              * MAP OUTPUT LINE\n         MVI   0(R1),C' '              * SINGLE SPACE NORMALLY\n         SP    LINECNTR,=P'1'          * DECREMENT LINE-COUNTER\n         BP    PRINTBR                 * NOT HEAD OF PAGE\n         MVC   0(133,R1),HDR1          * MOVE IN A PAGE HEADER\n         AP    PAGECNTR,=P'1'          * ADD 1 TO PAGE-COUNTER\n         ED    HDPAGCNT,PAGECNTR       * AND MOVE TO HEADER LINE\n         PUT   PRINTER                 * GET A PRINT BUFFER\n         CLC   PARM(3),=CL3'PDS'       * DIR BLKS ALLOC/USED REQUEST\n         BNE   NOTPO1                  * NO, LEAVE HEADERS ALONE\n         MVC   HDR2(133),HDR2P         * DIRECTORY BLOCKS\n         MVC   HDR3(133),HDR3P         * ALLOC     USED\nNOTPO1   EQU   *\n         MVC   0(133,R1),HDR2          * MOVE SECOND LINE\n         PUT   PRINTER                 * GET A PRINT BUFFER\n         MVC   0(133,R1),HDR3          * MOVE THIRD LINE\n         PUT   PRINTER                 * GET A PRINT BUFFER\n         ZAP   LINECNTR,MAXLINES       * RESET LINE-COUNTER\n         CP    FMT1CNT,=P'1'           * HOW MANY DATA SETS ON VOLUME\n         BNL   FIRSTDTL                * AT LEAST ONE\n         LR    R10,R1                  * NO FORMAT 1 DSCBS READ\n         B     ENDUP                   * PRINT LAST TWO LINES\nFIRSTDTL EQU   *\n         MVI   0(R1),C'0'              * FIRST DETAIL LINE DOUBLE SPACE\nPRINTBR  NOP   XDPRLPND                * BR IF MULTIPLE EXTENT\n         EJECT\nGETDSCB  LR    R10,R1                  * SAVE POINTER TO BUFFER\n         USING DSNLINE,R10             * AND SET DSECT\n         L     R15,RTNADDR             * ADDR OF ROUTINE TO READ DSCB\n         BALR  R9,R15                  * GO AND DO IT\n         MVC   LNDSN,DS1DSNAM          * MOVE DSNAME\n         MVC   LNCREDT(88),LNEDMSK     * MOVE EDIT MASKS FOR OTHER FLDS\n         MVC   DWORK+5(3),DS1CREDT     * CREATION DATE\n         BAL   R9,DATECONV             * CONVERT DATE\n         ED    LNCREDT,DWORK+4         * MM/DD/YY FORMAT\n         OC    DS1REFD,DS1REFD         * CHECK FOR ZERO REFERENCE DATE\n         BNZ   CNVREFDT                * NON-ZERO, GO CONVERT IT\n         MVC   LNREFDT+1(8),LNREFDT    * ELSE CLEAR TO SPACES\n         B     PARMTEST                * AND CONTINUE\nCNVREFDT MVC   DWORK+5(3),DS1REFD      * REFERENCE DATE\n         BAL   R9,DATECONV             * CONVERT DATE\n         ED    LNREFDT,DWORK+4         * MM/DD/YY FORMAT\nPARMTEST EQU   *\n         CLC   PARM(3),=CL3'PDS'       * DIR BLKS ALLOC/USED REQUEST\n         BNE   NOTPO2                  * NO, SKIP READ OF PDS DIRECTORY\n         MVI   LNCREDT,C' '            * MOVE\n         MVC   LNCREDT+1(8),LNCREDT    * SPACES\n         MVI   LNREFDT,C' '            * MOVE\n         MVC   LNREFDT+1(8),LNREFDT    * SPACES\n         ZAP   DIRTOTAL(3),=PL3'0'     * ZERO COUNTER\n         ZAP   DIRUSED(3),=PL3'0'      * ZERO COUNTER\n         TM    DS1DSORG,B'00000010'    * PARTITIONED ORGANIZATION?\n         BNO   NOTPO2                  * NO\n         MVC   JFCBDSNM,DS1DSNAM       * YES, MOVE DSNAME\n         OI    JFCBAREA+52,X'08'       * INDICATE NO JFCB WRITE BACK\n         OPEN  (PDS,INPUT),TYPE=J      * OPEN PDS\n         XC    DIRSTAT,DIRSTAT         * CLEAR DIRECTORY STATUS BYTE\nGETDIR   EQU   *\n         GET   PDS                     * READ PDS DIRECTORY BLOCKS\n         AP    DIRTOTAL(3),=PL3'1'     * ADD TO TOTAL\n         TM    DIRSTAT,X'80'           * END OF MEMBERS REACHED?\n         BO    GETDIR                  * YES\n         AP    DIRUSED(3),=PL3'1'      * NO, ADD TO USED\n         LR    R5,R1                   * PT AT DIRECTORY BLOCK\n         LH    R6,0(R5)                * # OF BYTES USED IN DIR BLOCK\n         AR    R6,R5                   * A(END OF DIR BLOCK)\n         LA    R5,2(R5)                * GO PAST BYTES USED FIELD\nNAMETTR  EQU   *\n         CR    R5,R6                   * END OF DIRECTORY BLOCK?\n         BNL   GETDIR                  * YES\n         CLC   0(8,R5),=8XL1'FF'       * END OF DIRECTORY MEMBERS?\n         BE    MBREOF                  * YES\n         SR    R1,R1                   * CLEAR A REGISTER\n         NI    11(R5),X'1F'            * TURN OFF BITS 0,1,2\n         IC    R1,11(R5)               * INDICATOR BYTE\n         SLL   R1,1                    * HALFWORDS OF USER DATA\n         AR    R5,R1                   * GO PAST USER DATA\n         LA    R5,12(R5)               * GO PAST NAME/TTR\n         B     NAMETTR                 * CHECK NEXT MEMBER\nMBREOF   EQU   *\n         OI    DIRSTAT,X'80'           * SET END OF MEMBERS FLAG\n         B     GETDIR                  * AND CONTINUE\nPDSEOF   EQU   *\n         CLOSE PDS                     * DISCONNECT\n         MVC   LNCREDT(6),DIRPATT      * EDIT MASK\n         MVC   LNREFDT+2(6),DIRPATT    * EDIT MASK\n         ED    LNCREDT(6),DIRTOTAL     * MOVE TO OUTPUT LINE\n         ED    LNREFDT+2(6),DIRUSED    * MOVE TO OUTPUT LINE\nNOTPO2   EQU   *\n         TM    DS1DSORG,B'00000001'    * UNMOVABLE DATA?\n         BNO   *+8                     * NO, SKIP NEXT INSTR\n         MVI   LNDSORGU,C'U'           * INDICATE UNMOVABLE\n         LH    R0,DS1DSORG             * LOAD DSORG INTO R0\n         SLL   R0,16                   * AND SHIFT TO LHS OF REG\n         LA    R1,7                    * LOAD # OF BITS TO TEST\nDSORGLP  LTR   R0,R0                   * IS HI-ORDER BIT ON?\n         BM    DSORGFND                * YES, ASSUME ONLY BIT SET\n         SLL   R0,1                    * NO, SLIDE NEXT BIT TO SIGN\n         BCT   R1,DSORGLP              * AND TEST THAT\nDSORGFND SLL   R1,1                    * MULTIPLY R1 BY 2\n         LA    R2,ORGTYPES(R1)         * USE IT TO ADDRESS TABLE\n         MVC   LNDSORG,0(R2)           * MOVE CORRESPONDING DSORG\n         TM    DS1DSORG+1,DS1ORGAM     * VSAM?\n         BNO   *+4+6                   * NO\n         MVC   LNDSORG,=CL2'VS'        * YES\n         TM    DS1SMSFG,DS1PDSE        * PDSE?\n         BNO   *+4+6                   * NO\n         MVC   LNDSORG,=CL2'PE'        * YES\n         TM    DS1SMSFG,DS1PDSEX       * HFS?\n         BNO   *+4+6                   * NO\n         MVC   LNDSORG,=CL2'HF'        * YES\n         TM    DS1SMSFG,DS1STRP        * EXTENDED FORMAT DATASET?\n         BNO   *+4+4                   * NO\n         MVI   LNDSORGU,C'X'           * YES\n         EJECT\n         LA    R2,LNRECFM              * ADDRESS OUTPUT RECFM\n         L     R0,DS1RECFM             * LOAD INPUT RECFM\n         LA    R1,FMTYPES              * ADDRESS TABLE OF RECFM TYPES\n         LA    R3,7                    * NO OF BITS TO TEST\n         TM    DS1RECFM,B'11000000'    * FIRST CHECK FOR 'U'\n         BNO   FMLOOP                  * NOT UNDEFINED\n         MVI   0(R2),C'U'              * MOVE IN 'U'\n         N     R0,=X'3FFFFFFF'         * OFF 'F' & 'V' BITS\n         B     FMJUMP                  * AND JOIN LOOP\nFMLOOP   LTR   R0,R0                   * TEST SIGN BIT\n         BNM   FMEND                   * BIT IS OFF\n         MVC   0(1,R2),0(R1)           * MOVE CORRESP CHAR\nFMJUMP   LA    R2,1(R2)                * POINT TO NEXT OUTPUT SPOT\nFMEND    EQU   *\n         LA    R1,1(R1)                * POINT TO NEXT TYPE IN LIST\n         SLL   R0,1                    * SHIFT OVER NEXT BIT\n         BCT   R3,FMLOOP               * AND GO TEST IT\n         LH    R0,DS1BLKL              * PICK UP BLKSIZE\n         CVD   R0,DWORK                * CONVERT TO DECIMAL\n         ED    LNBLKSI,DWORK+5         * MOVE TO OUTPUT\n         LH    R0,DS1LRECL             * PICK UP LRECL\n         CH    R0,=X'8000'             * IF LRECL = X'8000'\n         BNE   NOT32K                  * THIS INDICATES  SPANNED RECDS\n         MVC   LNLRECL+1(5),=C' >32K'      WITH RECD LENGTH > 32756\n         B     CNVKEYLE                * AND THAT'S ALL\nNOT32K   CVD   R0,DWORK                * OTHERWISE WE JUST\n         ED    LNLRECL,DWORK+5         * MOVE VALUE TO OUTPUT\nCNVKEYLE EQU   *\n         SR    R0,R0                   * CLEAR REGISTER\n         IC    R0,DS1KEYL              * INSERT KEYLEN\n         CVD   R0,DWORK                * DECIMALISE\n         ED    LNKEYLE,DWORK+6         * AND OUTPUT\n         EJECT\n* PICK UP SECONDARY ALLOCATION TYPE AND QUANTITY\n         MVC   DWORK(4),DS1SCALO       * ALIGNMENT\n         L     R2,DWORK                * LOAD SECONDARY ALLOC\n         LA    R1,0(R2)                * SAVE IN R1 WITH HI-ORDER OFF\n         SRL   R2,30                   * SHIFT OVER 2 BIT INDICATOR\n         LA    R0,0(R2,R2)             * DOUBLE IT\n         ALR   R2,R0                   * MAKE IT TRIPLE\n         BNZ   NOTABSTR                * NOT ABSOLUTE TRACK\n         MVC   LNSCALO(10),=C'     ABSTR' INDICATE ABSTR\n         B     SECALEND                * FINISHED\nNOTABSTR LA    R2,SECTYPES-3(R2)       * ADDRESS BLK, TRK OR CYL\n         MVC   LNSCTYPE,0(R2)          * AND MOVE IT TO OUTPUT\n         CVD   R1,DWORK                * CNVRT SEC ALLOC QTY\n         ED    LNSCALO,DWORK+5         * MOVE TO OUTPUT\nSECALEND EQU   *                       * THROUGH WITH SEC ALLOC\n         SR    R0,R0                   * CLEAR A REG\n         IC    R0,DS1NOEPV             * INSERT NO. OF EXTENTS\n         CVD   R0,DWORK                * CONVERT TO DECIMAL\n         ED    LNNOEXT,DWORK+6         * MOVE TO OUT-PUT LINE\n         EJECT\n         MVC   LASTBLK,DS1LSTAR        * FIRST SAVE LAST-BLK POINTER\n* MAX OF 133 EXTENTS (1 FORMAT 1 AND 10 FORMAT 3 DSCB'S)\n         XC    XTNTAREA(256),XTNAREA   * CLEAR AREA (133 *10 BYTES)\n         XC    XTNTAREA+256(256),XTNAREA+256   *\n         XC    XTNTAREA+512(256),XTNAREA+512   *\n         XC    XTNTAREA+768(256),XTNAREA+768   *\n         XC    XTNTAREA+1024(256),XTNAREA+1024 *\n         XC    XTNTAREA+1280(50),XTNAREA+1280  *\n         MVC   XTNTAREA(30),DS1EXT1    * MOVE 1ST 3 EXTENT DESCRIPTS\n         LA    R5,10                   * LOAD MAX # OF F3'S TO READ\n         LA    R6,XTNTAREA+30          * START OF F3'S IN AREA\nCHKCHAIN OC    DS1PTRDS,DS1PTRDS       * IS THERE A FORMAT2 OR 3?\n         BZ    NOCHAIN                 * NO, CHAINING NOT NECC\n         MVC   VTOCFDAD+3(5),DS1PTRDS  * YES, SET ADDRESS\n         BAL   R9,READDSCB+6           * AND READ FORMAT3\n         CLI   DS1FMTID,C'3'           * IS IT A FORMAT 3?\n         BNE   CHKCHAIN                * NO SO CHAIN AGAIN\n         MVC   0(40,R6),DS1DSNAM+4     * MOVE NEXT 4 EXTENT DESCRIPTS\n         MVC   40(90,R6),DS1DSSN       * MOVE NEXT 9 EXTENT DESCRIPTS\n         LA    R6,130(R6)              * POINT TO NEXT SLOT IN AREA\n         BCT   R5,CHKCHAIN             * GO SEE IF MORE\n*\n* NOW FOR SOMETHING TRICKY AFTER ALL THOSE STRAIGHTFORWARD EDITS -\n* FIND THE NUMBER OF TRACKS ALLOCATED\n*\nNOCHAIN  EQU   *\n         LA    R5,XTNAREA              * SET UP BEGINNING,\n         LA    R6,10                       INCREMENT,\n         LA    R7,XTNTAREA+1320              AND END POINTER FOR LOOP\n         SR    R0,R0                   * ZERO REGISTER TO STORE RESULT\nXTNTLOOP CLI   0(R5),X'00'             * IS THIS A VALID EXTENT?\n         BE    XTNTEXIT                * NO\n         LH    R1,6(R5)                * PICK UP CC FOR EXTENT END\n         SH    R1,2(R5)                * SUBTRACT CC FOR EXTENT START\n         MH    R1,DS4DEVSZ+2           * MULTIPLY BY # TRKS/CYL\n         AH    R1,8(R5)                * ADD HH FOR EXTENT END\n         SH    R1,4(R5)                * SUBTRACT HH FOR EXTENT START\n         LA    R1,1(R1)                * ALLOW FOR LAST TRK OF EXTENT\n         STH   R1,6(R5)                * SAVE # OF TRKS IN TABLE\n         AR    R0,R1                   * ADD IN TO TOTAL TRKS\n         BXLE  R5,R6,XTNTLOOP          * CHECK NEXT EXTENT\nXTNTEXIT SR    R5,R6                   * POINT R5 BACK TO LAST EXTENT\n         LR    R7,R5                   * RESET BXLE LIMIT\n         CVD   R0,DWORK                * CNVERT NO. OF TRKS\n         ED    LNNOTRKS,DWORK+5        * AND MOVE TO OUTPUT\n         BNZ   CNVUSAGE                * OFF TO CONVERT % USAGE\n         MVC   LNUSAGE+1(3),LNUSAGE      EXCEPT WHEN INDETERMINATE\n         B     XDPRNT                  * BECAUSE ZERO ALLOC\n         EJECT\nCNVUSAGE LH    R3,LASTBLK              * PICK UP TT OF LAST BLOCK\n         LA    R3,1(R3)                * ALLOW FOR LAST (PART-USED) TRK\n         SR    R8,R8                   * ZERO REGISTER\n         ICM   R8,3,DS4DEVTK           * LOAD HALFWORD (UP TO 64K)\n         MR    R2,R8                   * CONVERT TO #BYTES USED\n         LR    R1,R0                   * LOAD ODD-REGISTER OF PAIR\n         MR    R0,R8                   * CONVERT TOTAL ALLOC\n         LR    R0,R1                   * COPY TOTAL BYTES ALLOC\n         SRL   R1,1                    * HALVE IT\n         XC    DWORK(8),DWORK          * CLEAR AREA FOR SUBTRACT\n         MVC   DWORK+6(2),LASTBLK+3    * MOVE FOR ALIGNMENT\n         S     R3,DWORK+4              * SUBTRACT TRACK BALANCE\n         M     R2,=F'100'              * MULT BY 100 FOR PERCENT\n         AR    R3,R1                   * ROUND UP BY HALF TOTAL ALLOC\n         DR    R2,R0                   * AND DIVIDE BY TOTAL ALLOCATION\n         CVD   R3,DWORK                * CNVERT RESULT TO DECIMAL\n         ED    LNUSAGE,DWORK+6         * THEN MOVE TO OUTPUT LINE\nXDPRNT   LA    R5,XTNTAREA             * RESET PNTR TO WORKAREA\nXDPRLOOP SR    R0,R0                   * CLEAR WORK REG\n         IC    R0,1(R5)                * OBTAIN EXTENT NUMBER (M)\n         CVD   R0,DWORK                * CONVERT TO DECIMAL\n         ED    LNXDM,DWORK+6           * MOVE TO LINE\n         LH    R15,2(R5)               * PICK UP CYL ADDRESS IN HEX\n         CVD   R15,DWORK               * GET IN PACKED DECIMAL\n         MVC   CCCCWORK(6),MASKCCCC    * USE EDIT MASK FOR 3380 E/K\n         ED    CCCCWORK(6),DWORK+5     * EDIT 5 DIGIT CYLINDER ADDRESS\n         MVC   LNXDCCHH(4),CCCCWORK+2  * SET CYL ADDRESS IN PRINT LINE\n         LH    R15,4(R5)               * PICK UP TRK ADDRESS IN HEX\n         CVD   R15,DWORK               * GET IN PACKED DECIMAL\n         ED    LNXDCCHH+4(4),DWORK+6   * SET TRK ADDRESS IN PRINT LINE\n         SR    R0,R0                   * ZERO REGISTER\n         ICM   R0,3,6(R5)              * PICK UP # TRKS\n         CVD   R0,DWORK                * CONVERT\n         ED    LNXD#TRK,DWORK+5        * AND EDIT TO LINE\n         BXH   R5,R6,PRNTDSCB          * FINISH IF ALL EXTENTS DONE\n         MVI   PRINTBR+1,X'F0'         * MAKE A BRANCH\n         B     PRNTDSCB                * GO PRINT A LINE\nXDPRLPND MVI   PRINTBR+1,X'00'         * RESET TO NOP\n         LR    R10,R1                  * SET BUFFER POINTER\n         MVI   LNCC+1,C' '             * INITIALISE\n         MVC   LNCC+2(112),LNCC+1      * TO SPACES\n         MVC   LNXDM(19),LNEXTDSC      * MOVE IN NEW EDIT MSK\n         B     XDPRLOOP                * CONTINUE WITH NEXT EXTENT\n         EJECT\nREADDSCB MVC   VTOCFDAD,VTOCNEXT       * MOVE ADDRESS OF NEXT DSCB\n         READ  VTOCDECB,DIR,VTOC,DS1FMTID,'S',DS1DSNAM,                *\n               VTOCFDAD,VTOCNEXT\n         CHECK VTOCDECB                * WAIT FOR IT TO ARRIVE\n         TM    VTOCDECB+1,B'10000100'  * NO RECD FND / EOF\n         L     R15,EODADDR             * PICK UP EODAD\n         BCR   7,R15                   * GO THERE IF NRF OR EOF\nPOINTF5  EQU   *\n         MVC   VTOCNEXT,VTOCFDAD       * MOVE OLD DISC ADDRESS\n         SR    R15,R15                 * CLEAR R15\n         SR    R1,R1                   * AND R1\n         LA    R0,1                    * SET R0 TO 1\n         IC    R15,VTOCNEXT+7          * PICK UP RECD NO. ON TRK\n         IC    R1,DS4DEVDT             * PICK UP MAX RECDS PER TRK\n         BXH   R15,R0,NEXTTRK          * BRANCH IF HIGH\n         STC   R15,VTOCNEXT+7          * ELSE SAVE BUMPED VALUE\n         BR    R9                      * THEN RETURN\nNEXTTRK  MVI   VTOCNEXT+7,1            * RESET R TO 1\n         LH    R15,VTOCNEXT+5          * PICK UP CC\n         LH    R1,DS4DEVSZ+2           * AND NO. TRKS/CYL\n         BCTR  R1,0                    * MINUS ONE\n         BXH   R15,R0,NEXTCYL          * BUMP AND TEST\n         STH   R15,VTOCNEXT+5          * SAVE INCREMENTED VALUE\n         BR    R9                      * AND EXIT\nNEXTCYL  AH    R0,VTOCNEXT+3           * ADD 1 TO CC\n         SLL   R0,16                   * INSERT ZEROS ON RIGHT\n         ST    R0,VTOCNEXT+3           * SAVE NEW CCHH\n         BR    R9                      * THEN RETURN\n         EJECT\nREADFMT1 EQU   *                       * READ A FORMAT 1\n         LR    R3,R9                   * SAVE LINK REG\nTSTHPCHR CLC   VTOCNEXT+3(5),DS4HPCHR  * IS ADDR HIGHER THAN\n*                                          HIGHEST FORMAT 1 ?\n         L     R15,EODADDR             * PICK UP EODAD\n         BCR   2,R15                   * GO THERE IF FINISHED\n         BAL   R9,READDSCB             * READ A DSCB\n         CLI   DS1FMTID,C'1'           * IS IT A FORMAT1?\n         BNE   TSTHPCHR                * IF NO, TRY AGAIN\n         AP    FMT1CNT,=P'1'           * INCLUDE THIS DSCB IN COUNT\n         LR    R9,R3                   * RESTORE LINK\n         BR    R9                      * AND RETURN\n         EJECT\nREADTABL EQU   *\n         LA    R4,50(R4)               * BUMP POINTER\n         C     R4,TABLEND              * FINISHED?\n         BH    ENDUP                   * YES\n         MVC   VTOCFDAD+3(5),45(R4)    * MOVE CCHHR FROM TABLE\n         B     READDSCB+6              * GO READ NEXT DSCB\n         EJECT\nENDUP    ED    FLINE1CT,FMT1CNT+1      * SET NO OF DATA SETS IN PRT LNE\n         MVC   0(133,R10),FLINE1       * SET PRINT LINE PROPER\n         L     R11,VTOCDECB+8          * PT @ DCB\n         L     R3,44(R11)              * PICK UP DEB ADDR FROM DCB\n         L     R0,32(R3)               * PICK UP UCB ADDR FROM DEB\n         LA    R1,MESSAGE              * LSPACE MESSAGE AREA\n         SVC   78                      * LSPACE SVC\n         PACK  DBLWD1+5(3),TOTCYLS     * CONVERT TO PACKED DECIMAL\n         PACK  DBLWD2+5(3),TOTTRKS     * CONVERT TO PACKED DECIMAL\n         ED    FLINE2C,DBLWD1+5        * SET NO OF CYLS IN PRT LINE\n         ED    FLINE2T,DBLWD2+5        * SET NO OF TRKS IN PRT LINE\n         PUT   PRINTER                 * GET BUFFER POSITION\n         MVC   0(133,R1),FLINE2        * MOVE INTO BUFFER\n         CLOSE (VTOC,,PRINTER)         * CLOSE FILES\n         L     R13,4(R13)              * RESTORE R13\n         RETURN (14,12),RC=0           * RETURN TO CALLER\n         EJECT\n* DATE CONVERSION - DATE IN FORMAT YDD IS ASSUMED TO BE IN LAST\n* THREE BYTES OF DWORK\nDATECONV EQU   *                       * CONVERT DATE TO DECIMAL\n         LA    R0,28                   * LOAD 28 DAYS FOR FEBRUARY\n         TM    DWORK+5,3               * TEST FOR LEAP YEAR\n         BNZ   *+8                     * NO, SKIP NEXT INSTR\n         LA    R0,29                   * YES, 29 DAYS IN FEB\n         STH   R0,DATETABL+2           * STORE FEB DAYS\n         LA    R15,DATETABL            * POINT TO TABLE START\n         LA    R1,DATETABL+22          * AND TABLE END\n         LA    R0,2                    * LOAD BXLE INCREMENT\n         LH    R14,DWORK+6             * PICK UP # DAYS IN YEAR\nDATELOOP SH    R14,0(R15)              * SUBTRACT TABLE ENTRY\n         BNP   MNTHFND                 * IF -VE, HAVE HIT REQD MONTH\n         BXLE  R15,R0,DATELOOP         * ELSE LOOP AGAIN\n         XC    DWORK,DWORK             * IF NO MATCH, THEN ERROR\n         BR    R9                      * SO RETURN\nMNTHFND  AH    R14,0(R15)              * ALLOW FOR LAST SUBTRACT\n         S     R15,=A(DATETABL-2)      * FIND TABLE DISPLACEMENT\n         MH    R15,=H'5000'            * OBTAIN MONTH*10000\n         MH    R14,=H'100'             * AND DAY*100\n         SR    R0,R0                   * CLEAR R0\n         IC    R0,DWORK+5              * GET YEAR NO. 000000YY\n         C     R0,=F'100'              * Y2K DATE?\n         BL    *+8                     * NO\n         S     R0,=F'100'              * YES, AVOID OVERFLOW INTO DD\n         AR    R0,R14                  * ADD DAY      0000DDYY\n         AR    R0,R15                  * AND MONTH    00MMDDYY\n         CVD   R0,DWORK                * CONVERT      0MMDDYYC\n         MVO   DWORK,DWORK             * AND SHIFT    MMDDYYCC\n         BR    R9                      * RETURN FOR EDIT\nDATETABL DC    H'31,28,31,30,31,30'    * TABLE USED TO FIND\n         DC    H'31,31,30,31,30,31'    * THE NUMBER OF THE MONTH\n         PUSH  USING                   * SAVE USING STATUS\n         DROP  ,                       * DROP ALL BASE REGS\n         EJECT\nIOERR    EQU   *                       * SYNAD ROUTINE\n         USING *,R15                   * R13 IS CLOBBERED\n         SYNADAF ACSMETH=BDAM          * PERFORM SYSTEM ERROR ANALYSIS\n         MVC   SYNERMSG(60),68(R1)     * MOVE USEFUL PART OF SYSMSG\n         MVC   SYNADVOL,JFCBVOLS       * SET VOL SER NO IN MESSAGE\n         WTO   MF=(E,SYNADMSG)         * ISSUE ERROR MESSAGE\n         BALR  R15,0                   * R15 DESTROYED BY WTO\n         USING *,R15                   * SO BASE MUST BE RESET\n         MVI   DS1FMTID,X'00'          * ENSURE BAD DSCB IGNORED\n         SYNADRLS ,                    * RESTORE R13\n         DROP  R15                     * RELEASE R15\n         BR    R14                     * RETURN TO CHECK ROUTINE\n         POP   USING                   * RESTORE USING STATUS\n         EJECT\nDBLWD1   DC    D'0'                    * WORK AREA FOR FREE CYL COUNT\nDBLWD2   DC    D'0'                    * WORK AREA FOR FREE TRK COUNT\nDWORK    DC    D'0'                    * WORKAREA\nVTOCFDAD DC    D'0'                    * FULL DISC ADDR - MBBCCHHR\nTABLADDR DC    A(0)                    * ADDRESS OF TABLE OF DSCB'S\nTBLWIDTH DC    A(50)                   * SIZE OF TABLE ENTRY\nTABLEND  DC    A(0)                    * END OF TABLE\nRTNADDR  DC    A(READTABL)             * DEFAULT ROUTINE\nEODADDR  DC    A(VTOCEOD)              * END-OF-FILE ROUTINE\nFMT1CNT  DC    PL4'0'                  * NO OF FORMAT 1 DSCBS READ\nLASTBLK  DC    XL5'00'                 * SAVEAREA FOR LAST BLOCK PNTR\nVTOCNEXT DC    XL8'00'                 * MUST ALIGN AT FULLWD+1\nLINECNTR DC    P'000'                  * LINE COUNTER\nMAXLINES DC    P'54'                   * LINES PER PAGE\nPAGECNTR DC    P'000'                  * PAGE COUNTER\nPARM     DC    CL3' '                  * JCL PARM HOLD AREA\nHALFWD   DC    H'0'                    * WORK AREA FOR ALIGNMENT\nDIRSTAT  DC    XL1'00'                 * PDS DIR STATUS\nDIRTOTAL DC    PL3'0'                  * PDS DIR BLKS ALLOC\nDIRUSED  DC    PL3'0'                  * PDS DIR BLKS USED\nDIRPATT  DC    X'402020202120'         * EDIT MASK FOR DIR BLKS\nMASKCCCC DC    X'402020202120'         * EDIT MASK FOR CYLINDERS\nCCCCWORK DC    CL6' '                  * WORK AREA FOR CYLINDER EDIT\nFMTYPES  DC    CL8'FVTBSAM'            * PERMISSIBLE RECFM'S\nORGTYPES DC    C'  POMQCQCXDAPSIS'     * DSORG TYPES\nSECTYPES DC    C'BLKTRKCYL'            * TYPES OF ALLOCATION\nLNEDMSK  DS    0CL88                   * EDIT MASK FOR DSN OUTPUT LINE\n         DC    2X'402120612020612020'  * CREATION/LAST REF DATE\n         DC    C' '\n         DC    CL3' '                  * DSORG(U)\n         DC    C' '\n         DC    CL5' '                  * RECFM\n         DC    X'402020202020'         * BLKSIZE\n         DC    X'402020202020'         * LRECL\n         DC    X'40202020'             * KEYLEN\n         DC    C' '\n         DC    X'402020202120'         * TRKS ALLOC\n         DC    X'40202120'             * PERCENT USE\n         DC    X'40202120'             * NUMBER OF EXTENTS\n         DC    X'402020202120'         * SECONDARY EXTENT QUANTITY\n         DC    C' '\n         DC    CL3' '                  * SECONDARY EXTENT TYPE\nLNEXTDSC DS    0CL19                   * EXTENT DESCRIPTION\n         DC    X'40202120'             * EXTENT NUMBER\n         DC    C' '\n         DC    X'4020212040202120'     * CCHH OF EXTENT\n         DC    X'402020202120'         * NO OF TRKS IN EXTENT\n         PRINT NOGEN\nPRINTER  DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PL,LRECL=133,            *\n               RECFM=FBA\nVTOC     DCB   DDNAME=SYSUT1,DSORG=DA,MACRF=RIC,OPTCD=A,               *\n               SYNAD=IOERR,RECFM=FS,BLKSIZE=96,KEYLEN=44,EXLST=VTOCXLST\nPDS      DCB   DDNAME=SYSUT1,                                          *\n               RECFM=U,                                                *\n               BLKSIZE=256,                                            *\n               EODAD=PDSEOF,                                           *\n               DSORG=PS,                                               *\n               MACRF=GL,                                               *\n               EXLST=VTOCXLST\nOPENVTOC OPEN  (VTOC,INPUT),MF=L       * LIST FOR E-TYPE OPEN, RDJFCB\nVTOCXLST DC    X'87',AL3(JFCBAREA)     * JFCB ENTRY IN EXIT LIST\nSYNADMSG DC    AL2(JFCBDSNM+44-*,0)    * WTO RECD DESCRIPTOR WORD\n         DC    C'VTOCLIST - I/O ERROR READING VTOC ON '\nSYNADVOL DC    C'******'\n         DC    C', SYNADAF INFO ='\nSYNERMSG DC    CL16' '                 * INITIALISE TO SPACES\n         ORG   *-4                     * BACKSPACE\n         DS    0F                      * ALIGN TO FULLWORD\nJFCBAREA DS    0CL176                  * SPACE FOR VTOC JFCB\nJFCBDSNM DS    CL44                    * VTOC DSN - ALSO SYNAD WRKAREA\n         DS    CL132                   * SPACE FOR REST OF JFCB\nJFCBVOLS EQU   JFCBAREA+118            * VOLUME SERIAL NO.\n         EJECT\n         PRINT GEN\n         IECSDSL1 (1)                  * FORMAT 1 DSCB\nDS4DATA  DS    0CL71\n         IECSDSL1 (4)                  * FORMAT 4 DSCB\n         EJECT\nMESSAGE  DC    30C'0'                  * OUTPUT AREA FOR LSPACE SVC\n         ORG   MESSAGE\n         DS    CL6\nTOTCYLS  DS    CL4                     * FREE CYLINDERS\n         DS    CL1\nTOTTRKS  DS    CL4                     * FREE TRACKS\n         ORG   ,\nHDR1     DC    133C'*'\n         ORG   HDR1\n         DC    C'1*** CONTENTS OF '\nHDR1FILE DC    C'THE VOLUME TABLE OF CONTENTS'\n         DC    C' ON VOLUME '\nHDR1VOL  DC    C'******'\n         DC    C' *** DATE ='\nHDR1DATE DC    X'402120612020612020'\n         DC    C' *** TIME ='\nHDR1TIME DC    X'4021204B20204B202040'\n         ORG   HDR1+120\n         DC    C' PAGE'\n         DC    X'4020202040'\n         ORG   HDR1+133\nHDR2     DC    CL33'-                                              '\n         DC    C'               DATE     DATE   DS-        BLK-    '\n         DC    C'   KEY- TRKS   %  NO.   SEC-ALLOC EXTENT-DESCRIPTN.'\nHDR3     DC    CL33'    DATASET NAME                               '\n         DC    C'              CREATED  LASTREF ORG RECFM  SIZE LRE'\n         DC    C'CL LEN  ALLOC USE EXTS  QTY TYPE  M  CYL TRK #TRKS'\nHDR2P    DC    CL33'-                                              '\n         DC    C'             DIRECTORY  BLOCKS DS-        BLK-    '\n         DC    C'   KEY- TRKS   %  NO.   SEC-ALLOC EXTENT-DESCRIPTN.'\nHDR3P    DC    CL33'    DATASET NAME                               '\n         DC    C'             ALLOCATED  USED   ORG RECFM  SIZE LRE'\n         DC    C'CL LEN  ALLOC USE EXTS  QTY TYPE  M  CYL TRK #TRKS'\nFLINE1   DC    CL15'0 *** THERE ARE'\nFLINE1CT DC    X'402020202120'\n         DC    CL112' DATA SETS ON THIS VOLUME.'\nFLINE2   DC    CL15'  *** THERE ARE'\nFLINE2C  DC    XL6'402020202120'\n         DC    CL21' EMPTY CYLINDERS PLUS'\nFLINE2T  DC    XL6'402020202120'\n         DC    CL85' EMPTY TRACKS ON THIS VOLUME.'\n         LTORG\n         DC    0F'0'                   * ENSURE XTNTAREA ALIGNED\nXTNTAREA DC    30X'00'                 * EXTENTS 1-3   (F1)\n         DC    1300X'00'               * EXTENTS 4-133 (F3, 10 MAX)\nXTNAREA  EQU   XTNTAREA\n         EJECT\nHDRLINE  DSECT\n         DS    CL125\nHDPAGCNT DS    XL4\nDSNLINE  DSECT\nLNCC     DS    C                       * CARRIAGE CONTROL BYTE\nLNDSN    DS    CL44                    * DATASET NAME\nLNCREDT  DS    CL9                     * CREATION DATE\nLNREFDT  DS    CL9                     * LAST REFERENCE DATE\n         DS    C\nLNDSORG  DS    CL2                     * DSORG\nLNDSORGU DS    C                       * UNMOVABLE FLAG\n         DS    C\nLNRECFM  DS    5C                      * RECFM\nLNBLKSI  DS    CL6                     * BLKSIZE\nLNLRECL  DS    CL6                     * LRECL\nLNKEYLE  DS    CL4                     * KEYLEN\n         DS    C\nLNNOTRKS DS    CL6                     * TOTAL NO. OF TRKS ALLOCATED\nLNUSAGE  DS    CL4                     * PERCENTAGE USE OF ALLOC SPACE\nLNNOEXT  DS    CL4                     * NUMBER OF EXTENTS\nLNSCALO  DS    CL6                     * SECONDARY ALLOCATION QTY\n         DS    C\nLNSCTYPE DS    CL3                     * TYPE OF ALLOC - TRK/CYL/BLK\nLNXDM    DS    CL4                     * EXTENT-DESCRIPTION - M\n         DS    C\nLNXDCCHH DS    CL8                     * EXTENT DESCRIPTION - CCHH\nLNXD#TRK DS    CL6                     * EXTENT DESCRIPTION - NO OF TRK\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT343/FILE343.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT343", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}