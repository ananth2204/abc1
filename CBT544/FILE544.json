{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012319000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 587860, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE544.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 587860, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 587860, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE544.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\n\\x07'", "DS1TRBAL": "b'Q\\x8c'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\x03\\x00\\x04\\x04\\x03\\x00\\x0e\\x00\\x0b'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x02\\x8f\\x01\\x02\\x02\\x8f\\x17B\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xc8\\xc9\\xd7\\xc4\\xc1\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-01-28T00:00:00", "modifydate": "2002-01-28T17:42:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "SHIPDAT"}, "text": "REGULAR CBT TAPE - VERSION 441    FILE:  544\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT441.FILE544\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    3120    PO\n\n   PDS117I 11 MEMBERS COUNTED; CUMULATIVE SIZE IS 5,245 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   01/28/02    17:42:47    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$NOTE1": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x007\\x01\\x02\\x02\\x8f\\x01\\x02\\x02\\x8f\\x13U\\x00\\x90\\x00\\x8d\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-01-28T00:00:00", "modifydate": "2002-01-28T13:55:37", "lines": 144, "newlines": 141, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject: PL360 Update & address\nDate: Mon, 28 Jan 2002 01:56:56 -0500\nFrom: \"Phil Roberts\" <opplr@hotmail.com>\nTo: sbgolob@attglobal.net\n\nHi Sam,\n\nHere is the info you requested.\n\nPhil Roberts\nopplr@hotmail.com (email address)\n\nI have added the compile & go and the compile & link procs along\nwith the runtime library for PL360 for MVS along with \"Magic\nSquares\" test program for verification.\n\nBelow was my post to the Hercules list:\n\nIt is ready folks, the procs, PL360C, PL360CG, PL360CL, the load\nmodules, including the run library, a \"Magic Squares\" job to submit\nand the PL360 source are available at:\n\nhttp://us.f1.yahoofs.com/users/d89eb3c8/bc/Friends/PL360+for+MVS.zip?\nbcCPVp8AhFbNHr2e\n\nOr go here:\nhttp://briefcase.yahoo.com/halfmeg\nClick on Friends;\nThen download 'PL360 for MVS'\n\nAfter download and unzip, you can mount APL360.aws on your tape\ndevice, submit IEBCOPYR.jcl to restore the various members and source\nfile, then submit the PL360JOB.JCL to verify that things are working\ncorrectly. The print file is where you will see the output.\n\n  (The files you see here, came from there....   sbg)\n\nA \"Hello World\" type program was posted on the MVS group list, but I\nkinda like the Magic Squares generator better, 43 lines of code which\ngenerates those numeric cubes which add up to x no matter which way\nyou add. This program comes from a web site which has posted a\ntextbook style manual on PL360:\n\nhttp://lindy.stanford.edu/~guertin/document/pl360txt.html\n\nThe plain text manual available in the Hercules archives is from one\nof the Stanford PDF files below. Perhaps the next to the last one as\nthe last revision has some handwritten modifications to the document.\n\nThere are 5 technical papers on PL360 on Stanford's FTP server, the\nshort descriptions and links follow.\n\n(I have pulled the following reports, which have been scanned into\nPDF format--in that form, they are too big to include here.   sbg)\n\nReport Number: CS-TR-65-33\nInstitution: Stanford University, Department of Computer Science\nTitle: A programming language for the 360 computers\nAuthor: Wirth, Niklaus\nDate: December 1965\nAbstract: This paper is a prelimary definition of a programming\nlanguage which is specifically designed for use on IBM 360 computers,\nand is therefore appropriately called PL360.\nftp://reports.stanford.edu/pub/cstr/reports/cs/tr/65/33/CS-TR-65-\n33.pdf\n\nReport Number: CS-TR-66-53\nInstitution: Stanford University, Department of Computer Science\nTitle: A programming language for the 360 computers\nAuthor: Wirth, Niklaus\nDate: December 1966\nAbstract: A programming language for the IBM 360 computers and its\nimplementation are described. The language, called PL360, provides\nthe facilities of a symbolic machine language, but displays a\nstructure defined by a recursive syntax. The compiler, consisting of\na precedence syntax analyser and a set of interpretation rules with\nstrict one-to-one correspondence to the set of syntactic rules\ndirectly reflects the definition of the language. | k-th syntax rule\n| k-th interpretation rule | $S_0 ::= S_1 S_2 ... S_n$ | $V_0 := f_k\n(V_1 , V_2 , ... , V_n)$ | PL360 was designed to improve the\nreadability of programs which must take into account specific\ncharacteristics and limitations of a particular computer. It\nrepresents an attempt to further the state of the art of programming\nby encouraging and even forcing the programmer to improve his style\nof exposition and his principles and discipline in program\norganization, and not by merely providing a multitude of \"new\"\nfeatures and facilities. The language is therefore particularly well\nsuited for tutorial purposes. The attempt to present a computer as a\nsystematically organized entity is also hoped to be of interest to\ndesigners of future computers.\nftp://reports.stanford.edu/pub/cstr/reports/cs/tr/66/53/CS-TR-66-\n53.pdf\n\nReport Number: CS-TR-67-68\nInstitution: Stanford University, Department of Computer Science\nTitle: The PL360 system\nAuthor: Wirth, Niklaus\nDate: June 1967\nAbstract: This report describes the use and the organization of the\noperating system which serves as the environment of the PL360\nlanguage defined in the companion report, CS 53 [Niklaus Wirth, \"A\nProgramming Language for the 360 Computers,\" Stanford University\nDepartment of Computer Science, June 1967]. Edited by Niklaus Wirth.\nftp://reports.stanford.edu/pub/cstr/reports/cs/tr/67/68/CS-TR-67-\n68.pdf\n\nReport Number: CS-TR-68-91\nInstitution: Stanford University, Department of Computer Science\nTitle: The PL360 system\nAuthor: Wirth, Niklaus E.\nAuthor: Wells, Joseph W.\nAuthor: Satterthwaite, Edwin H.\nDate: April 1968\nAbstract: This report describes the use of two operating systems\nwhich serve as environments for the PL360 language defined in the\ncompanion report [Niklaus Wirth, \"A Programming Language for the 360\nComputers,\" Stanford University Computer Science Department report CS\n53 (revised), June 1967]. Some additions to that language, not\ndescribed in CS 53, are documented in the Appendix.\nftp://reports.stanford.edu/pub/cstr/reports/cs/tr/68/91/CS-TR-68-\n91.pdf\n\nReport Number: CS-TR-71-215\nInstitution: Stanford University, Department of Computer Science\nTitle: PL360 (revised): a programming language for the IBM 360\nAuthor: Malcolm, Michael A.\nDate: May 1972\nAbstract: In 1968, N. Wirth (Jan. JACM) published a formal\ndescription of PL360, a programming language designed specifically\nfor the IBM 360. PL360 has an appearance similar to that of Algol,\nbut it provides the facilities of a symbolic machine language. Since\n1968, numerous extensions and modifications have been made to the\nPL360 compiler which was originally designed and implemented by N.\nWirth and J. Wells. Interface and input-output subroutines have been\nwritten which allow the use of PL360 under OS, DOS, MTS and Orvyl. A\nformal description of PL360 as it is presently implemented is given.\nThe description of the language is followed by sections on the use of\nPL360 under various operating systems, namely OS, DOS and MTS.\nInstructions on how to use the PL360 compiler and PL360 programs in\nan interactive mode under the Orvyl time-sharing monitor are also\nincluded.\nftp://reports.stanford.edu/pub/cstr/reports/cs/tr/71/215/CS-TR-71-\n215.pdf\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$$NOTE2": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00$\\x01\\x02\\x02\\x8f\\x01\\x02\\x02\\x8f\\x17B\\x00\\r\\x00\\r\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-01-28T00:00:00", "modifydate": "2002-01-28T17:42:24", "lines": 13, "newlines": 13, "modlines": 0, "user": "SBGOLOB"}, "text": "\nThe five books on PL360 from the Stanford University archives, which\nhave been scanned in, and are in .PDF format, are in my possession.\nI have deemed them to be too big to include right now, on the CBT Tape,\nin their present format.  If I can OCR them later, all to the good,\nbut right now, they're downright enormous.  I think they deserve to be\nput on a cd-rom.  If anyone wants these materials, please contact:\n\n     Sam Golob at sbgolob@attglobal.net\n\nor they can be downloaded from Stanford University's FTP site, given\nthe URLs on member $$$NOTE1.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE544": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x009\\x01\\x01\\x02_\\x01\\x02\\x02\\x8f\\x14\\x04\\x00\\x10\\x00\\x02\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2001-01-25T00:00:00", "modifydate": "2002-01-28T14:04:39", "lines": 16, "newlines": 2, "modlines": 0, "user": "SBGOLOB"}, "text": "//***FILE 544 is material for setting up and running the Stanford   *   FILE 544\n//*           University PL360 compiler, prepared by Phil Roberts.  *   FILE 544\n//*                                                                 *   FILE 544\n//*           We would also like to ackowledge Mark Waterbury, for  *   FILE 544\n//*           his good work.  But this stuff was prepared by        *   FILE 544\n//*           Phil Roberts.                                         *   FILE 544\n//*                                                                 *   FILE 544\n//*      email:   opplr@hotmail.com                                 *   FILE 544\n//*                                                                 *   FILE 544\n//*      Included are:  PL360 procs, to compile and run PL360.      *   FILE 544\n//*                     PL360 source code.                          *   FILE 544\n//*                     PL360 load library, in TSO XMIT format.     *   FILE 544\n//*                                                                 *   FILE 544\n//*      See also, the Stanford PL360 EBCDIC compiler distribution  *   FILE 544\n//*      which is on File 545.                                      *   FILE 544\n//*                                                                 *   FILE 544\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IEBCOPYR": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00E\\x01\\x02\\x02\\x8f\\x01\\x02\\x02\\x8f\\x108\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-01-28T00:00:00", "modifydate": "2002-01-28T10:38:45", "lines": 27, "newlines": 27, "modlines": 0, "user": "SBGOLOB"}, "text": "//IEBCOPY JOB  DUMMY,DUMMY,CLASS=A,MSGCLASS=A,MSGLEVEL=(1,1)\n//* ***************************************************************** *\n//* RELOAD PL360 LOAD MODULE, SOURCE AND PROCEDURES                   *\n//*  FROM THE AWS FORMAT TAPE ORIGINALLY SUPPLIED                     *\n//* ***************************************************************** *\n//RELOAD  EXEC PGM=IEBCOPY,REGION=1024K\n//SYSPRINT DD  SYSOUT=A\n//TAPEIN1  DD  DSN=PL360.SOURCE,UNIT=TAPE,DISP=(OLD,KEEP),\n//             VOL=(PRIVATE,RETAIN,SER=APL360),LABEL=(1,SL)\n//TAPEIN2  DD  DSN=PL360.LOADMOD,UNIT=AFF=TAPEIN1,DISP=(OLD,KEEP),\n//             VOL=(PRIVATE,RETAIN,SER=APL360),LABEL=(2,SL)\n//TAPEIN3  DD  DSN=PL360.PROC,UNIT=AFF=TAPEIN1,DISP=(OLD,KEEP),\n//             VOL=(PRIVATE,RETAIN,SER=APL360),LABEL=(3,SL)\n//SOURCE   DD  DSN=SYS1.PL360.SOURCE,DISP=(NEW,CATLG,DELETE),\n//             UNIT=SYSDA,SPACE=(CYL,(2,1,15)),\n//             DCB=(BLKSIZE=6160,LRECL=80,RECFM=FB)\n//PL360LIB DD  DSN=SYS1.PL360LIB,DISP=(NEW,CATLG,DELETE),\n//             UNIT=SYSDA,SPACE=(CYL,(5,1,20)),\n//             DCB=(BLKSIZE=1024,LRECL=0,RECFM=U)\n//PROCLIB  DD  DSN=SYS1.PROCLIB,DISP=SHR\n//SYSUT3   DD  UNIT=SYSDA,SPACE=(80,(60,45)),DISP=(NEW,DELETE)\n//SYSIN    DD  *\n  COPY INDD=((TAPEIN1,R)),OUTDD=SOURCE\n  COPY INDD=((TAPEIN2,R)),OUTDD=PL360LIB\n  COPY INDD=((TAPEIN3,R)),OUTDD=PROCLIB\n/*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PL360": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00t\\x02_\\x00t\\x02_\\tE\\x10\\xa9\\x10\\xa9\\x00\\x00\\xc8\\xc5\\xd9\\xc3\\xf0\\xf2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1974-01-25T00:00:00", "modifydate": "1974-01-25T09:45:00", "lines": 4265, "newlines": 4265, "modlines": 0, "user": "HERC02"}, "text": "$OS\n$$SET M  |-- See COMPL360 and MAKPLLIB --|\n$$SET D  |-- See CMPL360X and MAKPLLIX for debugging --|\n$1\n$XREF\nCOMMENT\n\"The source code for this computer program is placed in the public\n domain and may be used by any party without notice to the copyright\n holder, Stanford University. Stanford University provides no\n support of any kind to this computer program.  Further:\n\n STANFORD MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED.\n BY WAY OF EXAMPLE, BUT NOT LIMITATION, STANFORD MAKES NO\n REPRESENTATIONS OR WARRANTIES OF MERCHANTABILITY OR FITNESS FOR ANY\n PARTICULAR PURPOSE OR THAT THE USE OF THE SOFTWARE WILL NOT INFRINGE\n ANY PATENTS, COPYRIGHTS, TRADEMARKS, OR OTHER RIGHTS. STANFORD SHALL\n NOT BE LIABLE FOR ANY LIABILITY OR DAMAGES WITH RESPECT TO ANY CLAIM\n BY A USER OF THIS COMPUTER PROGRAM OR ANY DERIVATIVES OF THIS\n COMPUTER PROGRAM.\"\n;\n  comment -- C O M P I L E    O P T I O N S --\n  *\n  *       THE FOLLOWING OPTIONS ARE AVALABLE:\n  *       $IFF   -- COMPILE FOR O/S - DOS SYSTEM.\n  *       $IFT   -- COMPILE FOR 65K DOS SYSTEM.\n  *       $IFT M -- COMPILE FOR MTS SYSTEM.\n  *       INCLUDE $SET FOR 65K DOS SYSTEM AS NEXT CARD.\n  *\n$IFF M M\n$IFT\n  *  - - - - - - -  6 5 K   D O S   S Y S T E M  - - - - - - -\n$END\n$IFF\n  *  - - - - - - -  O / S   -   D O S   S Y S T E M  - - - - - - -\n$END\n$END M\n$IFT M M\n    *  - - - - - - - - - - -  M T S   S Y S T E M  - - - - - - -\n$OPT\n$END M\n  *\n  *  NOTE - KEEP TRACK OF WHERE THE OBJECT MODULE IS BEING STORED;\n$IFF M M\n$IFT\n$TITLE   THE PL360 COMPILER  65K DOS VERSION,  1/1/90  V1.90\n$END\n$IFF\n$TITLE   THE PL360 COMPILER O/S - DOS VERSION, 1/1/90  V1.90\n$END\n$END M\n$IFT M M\n$TITLE   MTS PL360 COMPILER V1.90 Jan. 90\n$END M\n begin   |--  PL360 COMPILER --       --|\n    external procedure SYSINIT(R14); null;\n        |-- OBTAINS FREE STORAGE AND OPENS DATA SETS --|\n    external procedure SYSTERM(R14); null;\n        |-- RELEASES FREE STORAGE AND CLOSES DATA SETS --|\n$IFT M M\n    external procedure ERRBUFFR(R14); null;\n       |-- BUFFERS MOST ERROR MESSAGES -- SO WE CAN --|\n       |-- PRINT THEM AGAIN, AFTER THE XREF.        --|\n    external procedure ERRPRINT(R14); null;\n       |-- PRINTS ERROR MESSAGE SUMMARY ON SERCOM   --|\n       |-- AND SPRINT (IF THEY AREN'T THE SAME)     --|\n       |-- AFTER THE XREF.   ERROR MESSAGES ARE     --|\n       |-- STILL PRINTED IN THE USUAL MANNER,       --|\n       |-- INTERSPERSED IN THE LISTING.             --|\n    external procedure SERCOMPR(R14); null;\n       |-- PRINTS THE SUMMARY LINES ON SERCOM IF IT --|\n       |-- IS NOT ASSIGNED TO THE SAME FDNAME AS    --|\n       |-- SPRINT.                                  --|\n$END M\n\n    function SETZONE(8,#96F0);  |-- DEFINE FUNCTION TO SET ZONE --|\n    function DRAIN(0,#07F0);   |-- MODEL 91 PIPELINE DRAIN --|\n    function REDUCE(6,#0600);   |-- BCTR(RN,0) --|\n    function SB(4,#9600), RB(4,#94FF);  |-- SET/RESET BITS --|\n    byte OSSYSTEM; comment USED TO DETERMINE PROPER PROGRAM ENTRY AND\n                           EXIT CODE;\n    byte NOTMOVED;  |-- USED TO SUPPRESS REDUNDANT ERROR MESSAGES --|\n    byte OVER=#00;  |-- OVERPRNT/UNDERLINE FLAG --|\n    byte PRNT=#00;  |-- USED TO INDICATE INPUT IMAGE PRINT --|\n    byte FLGS=#00;  |-- GENERAL PURPOSE FLAGS --|\n    equate DOLR syn #80, XITF syn #40, NOGO syn #20, ASCI syn #10;\n    byte TRACE=0; comment USED TO CONTROL TRACE OUTPUT --\n       0 - NO TRACE, bit 1 - ESD AND RLD PRINTOUT,\n       bit 2 - NAME PRINTOUT, bit 4 - SEGMENT INITIALIZATION PRINTED;\n    byte RUNFLAG,SKIPFLAG,NOPROGSEG,NODATASEG;\n    byte FLAG;  |-- USED IN SYNTACTIC ANALYSIS --|\n    byte SIGN, EXPOSIGN;  |-- SIGN FLAGS FOR NUMBER CONVERSION --|\n    byte CARRCONT=\"1\";  |-- LISTING FORMS CONTROL CODE --|\n    byte BEGENDFLAG,REPFLAG=#00;\n    byte FILLFLAG=0;\n    byte DBGFLGS=0;\n    short integer BEGENDLVL,LITCOUNT=0,CBEGENDLVL;\n    integer N1,N2,N3,N4;  |-- NAME AND LABEL POINTERS --|\n    integer N5,N6;  |-- BRANCH TABLE POINTERS --|\n    short integer BLOCK;  |-- CURRENT BLOCK LEVEL --|\n    short integer FILLTYPE;  |-- USED IN DATA FILL --|\n    short integer PROCBR,PROCLK;  |-- USED FOR BRANCH AROUND PROC --|\n    short integer CSEGNO;  |-- CURRENT SEGMENT NUMBER --|\n    short integer NSEGNO;  |-- MAXIMUM USED SEGMENT NUMBER --|\n    short integer SEGNO;  |-- NEXT SEGMENT NUMBER --|\n    short integer MAXSEG;  |-- HIGHEST SEGMENT ASSIGNED --|\n    short integer LITX;  |-- LITERAL INDEX --|\n    short integer SYMTYPE; byte TYPEFLAG syn SYMTYPE(1);\n    short integer NAMEPOINTER;\n    short integer ERRCOUNT, ERRTOTL=0, LINECOUNT, PAGECOUNT, CARDCOUNT;\n    short integer ERRLIMIT=50, MAXLINE=60;\n    short integer ENDCHAIN=_1;\n    short integer MAXHASH=156;\n    array 5 short integer LENHASH=(0,32,64,96,128);\n    array 40 integer HASHCHAIN=40(_1);\n    array 47 byte ALPHASH=(2(0),3(4),11(8),4(12),3(16),2(20),\n       10(24),12(28));\n$IFT\n    byte XR=0;\n$END\n$IFF\n    byte XR=0, REFOUT=0, XREF=0;\n$IFT M M\n    byte TESTFLAG=0, SYM=0;\n    dummy base R0;  |-- Symbol block for SYM card output --|\n       array 7 integer SYMDATUM;\n       logical SYMLINK syn SYMDATUM;\n       short integer CARDNO syn SYMDATUM(4);\n       byte ORFIELD syn SYMDATUM(6);\n       array 3 byte AAFIELD syn SYMDATUM(7);\n       short integer DISPFIELD syn SYMDATUM(8);\n       array 10 byte SYMFIELD syn SYMDATUM(10);\n       byte FFIELD syn SYMDATUM(20);\n       byte LDFIELD syn SYMDATUM(21);\n       array 4 byte MFIELD syn SYMDATUM(24);\n       integer DUPFAC syn SYMDATUM(24);\n    close base;\n    integer DATAPTR syn 0;\n    integer PROCPTR;\n$END M\n    short integer LASTCARD;\n    array 40 integer REFCHAIN=40(_1);\n    dummy base R0;\n       integer LINKF;\n       array 10 byte REFNAME;\n       integer LINKN;\n       integer LINKL;\n    close base;\n    equate REFMOV syn REFNAME(10)-LINKF-1,\n           REFLEN syn LINKL(4)-LINKF;\n    integer REFLINK syn 0;\n    integer REFN1=0, REFN2=0, REFN3=0;  |-- REFERENCE POINTERS --|\n    integer REFSTART;\n$END\n    comment TO CHANGE THE LIMIT ON THE NUMBER OF DIFFERENT\n      SEGMENTS, CHANGE THE VALUE OF MAXSEGNO IN THE\n      FOLLOWING EQUATE DECLARATION. IT SHOULD NOT EXCEED 255;\n    equate ROUND syn 511, STACKLEN syn #800,\n$IFT\n           MAXSEGNO syn 75,   NAMEFILLSZ syn 606,\n$END\n$IFF\n           MAXSEGNO syn 255,  NAMEFILLSZ syn 1000,\n$END\n           ESDTBLLEN syn MAXSEGNO+1*8,\n           NAMETBLLEN syn MAXSEGNO+1*10,\n           NAMETABSZ syn NAMEFILLSZ * 2,\n           SIZE1 syn NAMETABSZ * 6;\n    integer LBTL=10, LTTL=30, NTBL=60, DTL=60, BRTBL=10; |PROG=86|\n    integer LTAB syn LBTL;  short integer QTAB syn LTAB(2);\n    array 10 byte SEGNAM=\"SEGNXXX   \";\n    byte MCCODE, MCTYPE;\n$IFT M M\n    integer PROCSTACK, DATASTACK, PSTAKBOT, DSTAKBOT, FREESPACE=0;\n$END M\n    integer I;  |-- STACK INDEX --|\n    integer DC1;  |-- DATA INITIALIZATION COUNTER --|\n    integer FUNC0,FUNC1,FUNC2;\n    integer FUNCCOUNT=0;\n    equate FT syn 20;   |-- FUNCTION TYPE LIMIT --|\n    integer EQUHOLD, STRNGADR;\n    integer STACKBASE,NAMEBASE,LITBASE,LABELBASE,DATABASE,PRTBASE;\n    integer BRANCHBASE;\n    integer PROGBASE, NAMEND;\n    integer SEGONEORG syn MEM(R13+72);\n    integer PTAG,  |-- USED TO PUT IN PROGRAM BASE REGISTER --|\n       STARTADR=@SEGONEORG,  |-- START OF INITIAL DATA AREA --|\n       DATAEND;  |-- END OF DATA FILL AREA --|\n    integer SAVERETURN;  |-- USED TO HOLD RETURN REGISTER FOR MAIN --|\n    long real CONWORK;  |-- USED TO CONVERT TO DECIMAL --|\n    array  32  byte TYPETABLE=\n       (0,1,3(0),1,4(0),1,3(0),1,1,16(0));\n    array 8 byte LENGTH=(1,2,3,2,4(0)),\n       ALENGTH=(1,3,7,3,4(0));\n    array 17 byte DTRTABLE=\" 0123456789ABCDEF\";\n       array 16 byte TRTABLE syn DTRTABLE(1);\n    byte OPTFLAG=0;  |-- CONTROLS OPTIMIZATION --|\n    short equate  CASESEQ      syn  18, |-- <CASE SEQ>  --|\n                  RELOP        syn  22, |-- <REL OP>    --|\n                  COMPAOR      syn  25, |-- <COMP AOR>  --|\n                  CONDTHEN     syn  26, |-- <COND THEN> --|\n                  DOTERM       syn  30, |-- <WHILE>     --|\n                  REPLIST1     syn  41, |-- <REP LIST1> --|\n                  TDECL3       syn  45, |-- <T DECL3>   --|\n                  BLOCKHEAD    syn  69, |-- <BLOCKHEAD> --|\n                  BLOCKBODY    syn  70, |-- <BLOCKBODY> --|\n                  PROGMINUS    syn  71, |-- <PROGRAM->  --|\n                  PROGSTAR     syn  72, |-- <PROGRAM*>  --|\n                  NUMBERSYMBOL syn  78, |-- <T NUMBER>  --|\n                  IFTERM       syn  79, |-- <IF>        --|\n                  RPTERM       syn  82, |-- <RP>        --|\n                  CONDEND      syn  86, |-- <COND END>  --|\n                  REPUNTIL     syn  92, |-- <REPUNTIL>  --|\n                  IDENTSYMBOL  syn  93, |-- <ID>        --|\n                  STRNGSYMBOL  syn  94, |-- <STRING>    --|\n                  SHIFTOP      syn  95, |-- <SHIFT OP>  --|\n                  ARITHOP      syn  96, |-- <ARITH OP>  --|\n                  ADROP        syn  97, |-- <ADR OP>    --|\n                  SEMICOLON    syn  98, |-- ;           --|\n                  EQUALSYM     syn  99, |-- =           --|\n                  NOTSYM       syn 100, |-- \u00ac           --|\n                  LPAREN       syn 101, |-- (           --|\n                  RPAREN       syn 102, |-- )           --|\n                  COLONSYMBOL  syn 103, |-- :           --|\n                  COMMASYM     syn 104, |-- ,           --|\n                  ENDFILE      syn 105, |-- .           --|\n                  ASSIGNSYMBOL syn 106, |-- :=          --|\n                  FT2          syn 107, |-- DO          --|\n                  FT3          syn 111, |-- AND         --|\n                  ENDSYMBOL    syn 112, |-- END         --|\n                  FORSYMBOL    syn 113, |-- FOR         --|\n                  FT4          syn 116, |-- BASE        --|\n                  FT5          syn 127, |-- ARRAY       --|\n                  BEGINSYMBOL  syn 128, |-- BEGIN       --|\n                  FT6          syn 134, |-- COMMON      --|\n                  FT7          syn 138, |-- INTEGER     --|\n                  FT8          syn 141, |-- EXTERNAL    --|\n                  FT9          syn 144; |-- CHARACTER   --|\n\n    array 12 short integer OPS = (\n                      SEMICOLON    ,    |-- ;           --|\n                      ARITHOP      ,    |-- <ARITH OP>  --|\n                      RELOP        ,    |-- <REL OP>    --|\n                      NOTSYM       ,    |-- \u00ac           --|\n                      LPAREN       ,    |-- (           --|\n                      RPAREN       ,    |-- )           --|\n                      COLONSYMBOL  ,    |-- :           --|\n                      COMMASYM     ,    |-- ,           --|\n                      ADROP        ,    |-- <ADR OP>    --|\n                      ENDFILE      ,    |-- .           --|\n                      ASSIGNSYMBOL ,    |-- :=          --|\n                      EQUALSYM     );   |-- =           --|\n\n    array DATAFILL short integer WORD2 =\n       (\"DO\",\"IF\",\"OF\",\"OR\");\n\n    array DATAFILL integer WORD3 =\n       (\"AND \",\"END \",\"FOR \",\"SYN \",\"XOR \");\n\n    array DATAFILL integer WORD4 =\n       (\"BASE\",\"BYTE\",\"CASE\",\"DATA\",\"ELSE\",\"GOTO\",\"LONG\",\"NULL\",\n        \"REAL\",\"STEP\",\"THEN\");\n\n    array DATAFILL integer WORD5 =\n       (\"ARRAY   \",\"BEGIN   \",\"CLOSE   \",\"DUMMY   \",\n        \"SHORT   \",\"UNTIL   \",\"WHILE   \");\n\n    array DATAFILL integer WORD6 =\n       (\"COMMON  \",\"EQUATE  \",\"GLOBAL  \",\"REPEAT  \");\n\n    array DATAFILL integer WORD7 =\n       (\"INTEGER \",\"LOGICAL \",\"SEGMENT \");\n\n    array DATAFILL integer WORD8 =\n       (\"EXTERNAL\",\"FUNCTION\",\"REGISTER\");\n\n    array DATAFILL integer WORD9 =\n       (\"CHARACTER   \",\"PROCEDURE   \");\n\n    array DATAFILL integer SHIFTWORD =\n       (\"SHRL\",\"SHLL\",\"SHRA\",\"SHLA\");\n\n    array 146 byte F      =\n       (0,5,3(10),5,3,3,7,7,3(5),7,3,3,7,4,4,7,3,2,7,5,4,4,6,2,2,6,4,5,\n       1,1,5,2,2,1,9,8,4,1,3,6,8,1,3,8,10,7,3,7,3,3,7,3,8,10,7,3,3,2,1,\n       5,1,2,2,1,9,9,4,5,1,1,7,3,3,8,10,4,5,3,4,3,2,2,6,9,7,7,4,7,4,12,\n       5,3(7),12,11,7,11,7,9,11,9,7,9,11,7,11,11,9,1,9,9,7,10,7,8,9,8,\n       11,3,10,7,9,7,12,2,3,3(11),10,9,10,9,4(10),9,8,10,8);\n\n    array 146 byte G      =\n       (0,7,8,7,8,7,4(8),3(7),3,7,8,8,5(7),4(5),4,7,6,6,7,4,3(1),6,5,4,\n       10,10,1,2,2,14(10),3(11),4(10),9,10,10,9,4,7,7,3(1),4(10),7,7,4,\n       7,5,4,5,4,4,7,5,10,7,2,4,8,7,3,3,7,1,6,5,10,3,12,3,1,5,4,7,5,\n       3(4),7,12,4,2,11,7,10,2,7,11,7,11,3,4,10,7,10,10,11,5,7,10,11,10,\n       7,11,11,3(10),9,11,11);\n\n    array 146 short integer MTB    =\n       (0,1,92,102,112,122,169,187,205,221,252,253,254,259,260,331,342,\n       368,373,390,396,402,412,417,426,456,468,469,479,484,485,504,505,\n       506,507,508,513,518,519,531,547,548,554,565,575,585,591,601,607,\n       613,619,625,631,637,647,663,673,680,686,692,698,703,714,720,726,\n       727,738,745,746,747,758,780,786,792,793,819,859,866,873,887,951,\n       952,975,988,989,990,991,992,1003,1004,1010,1028,1044,1045,1079,\n       1084,1085,1086,1097,1098,1103,1119,1128,1129,1130,1131,1142,1143,\n       1148,1153,1154,1159,1164,1165,1174,1175,1180,1181,1186,1194,1195,\n       1196,1202,1208,1213,1218,1219,1220,1227,1232,1238,1243,1254,1263,\n       1268,1284,1289,1306,1311,1316,1321,1331,1343,1348,1349,1354);\n\n$IFT M M\n    integer AATYPE syn WORD5(4);\n$END M\n    comment THE FOLLOWING TWO TABLES ARE USED IN THE INSYMBOL SCAN\n       ROUTINE -- SCANTAB1 SCANS TO THE END OF COMMENTS,\n       SCANTAB2 SCANS TO THE NEXT NON-BLANK CHARACTER\n       USING THE FOLLOWING CODE:\n          0 -- BLANK, 1 -- NUMBER START, 2 -- ID START,\n          3 -- HEX NUMBER START, 4 -- STRING START,\n          5 -- ILLEGAL CHARACTER, >= 10 -- THESE ARE THE SPECIAL\n          SYMBOLS FOR PL360 SYNTAX.  FS + CODE - 10 IS THE SYNTACTIC\n          SYMBOL CODE ASSUMING THE FOLLOWING ORDER\n             SEMICOLON + - = < > \u00ac ( ) * / : , @ .                ;\n\n    array 256 byte SCANTAB1=256(0);\n\n    array 256 byte SCANTAB2 =\n         (64(5),                            |-- X'00' TO X'3F' --|\n          0, 10(5), 38, 18, 24, 12, 6,      |-- X'40' TO X'4F' --|\n          11(5), 7, 28, 26, 10, 22,         |-- X'50' TO X'5F' --|\n          14, 30, 8(5), 6, 34, 5, 1, 20, 5, |-- X'60' TO X'6F' --|\n          10(5), 32, 3, 36, 5, 16, 4,       |-- X'70' TO X'7F' --|\n          2(5, 9(2), 6(5)),                 |-- X'80' TO X'9F' --|\n          5, 22, 8(2), 6(5),                |-- X'A0' TO X'AF' --|\n          16(5),                            |-- X'B0' TO X'BF' --|\n          2(5, 9(2), 6(5)),                 |-- X'C0' TO X'DF' --|\n          2(5), 8(2), 6(5),                 |-- X'E0' TO X'EF' --|\n          10(1), 6(5));                     |-- X'F0' TO X'FF' --|\n    array 64 byte CONDTAB;  byte CONDCK syn CONDTAB(#2A);\n\n    array 1000 byte ESDNAME syn MEM(R11);  |-- @ESDNAMETABLE --|\n\n    comment ALLOCATION FOR THE COMPILER TABLES AND ARRAYS IS DONE\n       AT RUN TIME USING AVAILABLE CORE SPACE.  THE LITERAL TABLE\n       HAS A MAXIMUM LENGTH OF #3000 BYTES, DATA INITIALIZATION\n       SECTION A MAXIMUM LENGTH OF #8000 BYTES.  THE MAXIMUM LENGTH\n       OF THE OTHER VARIABLES IS GIVEN BELOW;\n    array  512  integer V syn 0;  |-- TRANSLATION STACK --|\n       short integer S syn V(12), T syn V(14);\n    integer V1 syn V(16);  short integer T1 syn T(16);\n    integer V2 syn V1(16);  short integer T2 syn T1(16);\n    array  #800  short integer LABEL syn 0;  |-- LABEL TABLE --|\n    short integer LABELADR syn LABEL(10);\n    short integer LABELCHAIN syn LABEL(12);\n    array #800 integer BRANCH syn 0;  |-- BRANCH TABLE --|\n       short integer BRANCHADR syn BRANCH,\n                     BRANCHAIN syn BRANCH(2);\n    array #1800 short integer TYPE syn 0;\n       array 2 short integer ADR syn TYPE(2);\n       short integer LINK syn TYPE(6);\n       byte NAME syn TYPE(8);  |-- NAME IS 2,4,6,8, OR 10 BYTES LONG --|\n    short equate SD syn 0, LD syn 1, ER syn 2, CM syn 5, XCM syn 6,\n       WER syn ER + 8, RLD syn 255;\n    array 14 byte ESDCODE=\"SDLDER****CMER\";  |-- ESD TYPE NAMES --|\n    short equate ATYPE syn #0C, VTYPE syn #1C;\n    array 4 short integer ESDTBL syn MEM;\n       short integer PL360NO syn ESDTBL, RLDADDR syn ESDTBL(4),\n          ESDLINK syn ESDTBL(6);\n       byte ESDTYPE syn ESDTBL(2), RLDFLAG syn ESDTBL(3);\n    |-- DATA AND PROGRAM SEGMENT FORM --|\n    array 0 integer SEGAREA syn 0;\n       integer COUNTER syn SEGAREA, PREVSEG syn SEGAREA(4),\n          LASTINITIAL syn SEGAREA(8);\n       short integer SEGTYPE syn SEGAREA(12),\n          BLOCKLEVEL syn SEGAREA(14), SEGBASEREG syn SEGAREA(16);\n    short integer INITIALSTART syn 0, INITIALEN syn 2, TABLEN syn 0;\n    byte SEGHEAD syn 18;\n    short integer PROGRAM syn SEGHEAD(R9+4);\n    short integer PBREG syn SEGBASEREG(R9);\n    short integer DBREG syn SEGBASEREG(R10);\n    integer LC syn COUNTER(R9), DC syn COUNTER(R10);\n    byte GENFLAG=#FF, GENDECK=#FF;\n$IFF\n    byte XREFCC = \" \";  |-- CARRIAGE CONTROL FOR XREF --|\n$END\n    array 5 integer PARAMSAVE;\n    integer PROGESDADR,PROGESDEND,DATAESDADR,DATAESDEND;\n    short integer PROGREG=15;\n    short integer SEGHDLEN=@SEGHEAD;\n\n    array 10  byte RIGHTPART;  |-- USED IN SYNTACTIC ANALYSIS --|\n    equate NOMORERULES syn 255;  |-- END OF RIGHTPART RULES --|\n$IFF M M\n    array 20 integer CBUF;  |-- CARD BUFFER --|\n$END M\n$IFT M M\n    array 23 integer CBUF;  |-- CARD BUFFER, LINE NUMBER --|\n    array 6 byte EDMSK = (\" \",3(#20),#21,#20);\n$END M\n    array 20 integer PBUF;  |-- PUNCH BUFFER --|\n    array 3  integer BLANK=3(\"    \");\n    array 133 byte WBUFF;  |-- PRINT BUFFER --|\n    array 132 byte WBUF syn WBUFF(1);\n$IFT M M\n    equate WCRDLN syn 6, WHDRLN syn 40;\n    array 10 byte WLINENUM syn WBUF(21);\n    array 72 byte WCARD syn WBUF(WHDRLN+2);\n$END M\n$IFF M M\n    equate WCRDLN syn 4, WHDRLN syn 34;\n    array 72 byte WCARD syn WBUF(WHDRLN+1);\n$END M\n    array 8 byte WSEQ syn WCARD(76);\n    array WHDRLN byte WHDR = WHDRLN(\" \");  |-- LINE HEADER --|\n    array 3 byte WPSEG  syn WHDR(0);\n    array 4 byte WPDISP syn WHDR(4);\n    array 3 byte WDSEG  syn WHDR(11);\n    array 4 byte WDDISP syn WHDR(15);\n    array WCRDLN byte WCRDCNT syn WHDR(WHDRLN-WCRDLN-3);\n    array 2 byte WBGNEND syn WHDR(WHDRLN-2);\n    array 72 byte OBUF;      |-- OVERPRNT BUFFER --|\n    array 10 byte OMSK = 10(_1);  |-- MASK BYTES --|\n$IFT M M\n    array 32 byte ERRORBUF = 32(\" \");\n    array 6 byte ERRWCRDCNT syn ERRORBUF(10);\n    array 16 byte ERRMESSAGE syn ERRWCRDCNT(6);\n$END M\n    array 133 byte HEADER   |-- LISTING PAGE HEADER --|\n       =(\"1PL360 COMPILATION\",95(\" \"),\"PAGE\",16(\" \"));\n    array 133 byte SUBHEAD = 133(\" \");\n$IFF\n$IFF M M\n    array 39 byte IDRDATA = (\"1 DTR PL3600790\", 24(\" \"));\n$END M\n$IFT M M\n    array 39 byte IDRDATA = (4(\" \"),\"07-01-90 PL360\",21(\" \"));\n$END M\n$END\n    short integer LIST = _1;  byte LISTFLAG syn LIST;\n    array  2  long real VALUEF;  |-- VALUE OF CURRENT SYMBOL --|\n    integer VALUE syn VALUEF;\n    short integer IVALUE syn VALUEF;\n    array  64  integer STRINGV;  |-- VALUE OF CURRENT STRING --|\n    array  3  integer ZERO=3(0);\n    equate DTHI syn #8765, DTLO syn #4321,\n           DTFILL syn DTHI shll 16 or DTLO;\n    byte C1 syn B1, C2 syn B2, C6 syn B6;\n    short integer H6 syn B6;\n$PAGE\n procedure ERROREXIT(R4);   |-- EXIT FROM PROGRAM --|\n begin  SB(XITF,FLGS);  goto EXIT;  end;\n\n procedure PRINT(R14);\n    begin  logical SAVE14; SAVE14 := R14;\n       R0 := 1 + LINECOUNT; CLI(\"0\",CARRCONT); if = then\n       begin if R0 >= MAXLINE then CARRCONT := \"1\" else R0 := R0 + 1;\n       end;  CLI(\"1\",CARRCONT); if = then\n       begin  R0 := 1 + PAGECOUNT; PAGECOUNT := R0;\n          CVD(R0,CONWORK); HEADER(118) := \"`0`1`0\";\n          ED(3,HEADER(117),CONWORK(6)); R0 := @HEADER; WRITE;\n          R0 := 3;  CARRCONT := \"0\";  CLC(93,SUBHEAD(1),SUBHEAD);\n          if \u00ac= then  |-- SUPPLY SUB-HEADING --|\n          begin R0 := @SUBHEAD;  WRITE;  R0 := 4;\n          end;\n       end;\n       WBUFF(0/1) := CARRCONT; LINECOUNT := R0;\n       if R0 >= MAXLINE then CARRCONT := \"1\" else CARRCONT := \" \";\n       R0 := @WBUFF; WRITE; R14 := SAVE14;\n    end;\n\n procedure OUTPUTCARD(R14);  if PRNT then\n    begin  array 4 integer SAVE40;  STM(R14,R1,SAVE40);\n       WBUF(0/WHDRLN) := WHDR;  WCARD(0/72) := CBUF;\n$IFT M M\n       WLINENUM(0/10) := CBUF(80);\n$END M\n$IFF M M\n       WDDISP(5/6) := BLANK;\n$END M\n       WSEQ(0/8) := CBUF(72);  PRINT;  RESET(PRNT);\n       WBUFF(0/133) := BLANK;  if TM(#80,OVER); ON then\n       begin  SET(PBUF);  PBUF(1/71) := PBUF;\n          PBUF(0/72) := PBUF xor OBUF;  |-- REVERSE MASK --|\n          WCARD(0/72) := WCARD and PBUF;  |-- BLANK FILL --|\n          if TM(#40,OVER); ON then  |-- UNDERLINE --|\n          begin  PBUF := \"_\";  PBUF(1/71) := PBUF;\n          end else PBUF(0/72) := CBUF;\n          PBUF(0/72) := PBUF and OBUF;  |-- OVERPRNT --|\n          if \u00ac= then  |-- SOMETHING TO DO --|\n          begin  WCARD(0/72) := WCARD or PBUF;  WBUFF := \"+\";\n             R0 := @WBUFF;  WRITE;  |-- WRITE OVERPRNT --|\n          end;\n       end;  LM(R14,R1,SAVE40);  |-- RESTORE & RETURN --|\n    end;\n\n procedure ENDMESSAGES(R2);\n    begin  WBUF := \"*** FURTHER ERROR MESSAGES SUPPRESSED\";\n       PRINT; WBUFF(0/38) := BLANK; SETZONE(CARRCONT);\n    end;\n\n procedure ERROR (R4);\n    begin  array 3 integer ERRSAVE; STM(R0,R2,ERRSAVE);\n       if NOTMOVED then goto X;  SET(NOTMOVED);\n       R0 := 1 + ERRCOUNT; ERRCOUNT := R0; if R0 > ERRLIMIT then goto X;\n       SET(PRNT);  |-- INDICATE NEED TO PRINT IMAGE --|\n       WBUFF(0/125) := BLANK; R2 := R2-R2; IC(R2,XR);\n       R2 := R2 shll 4;   |-- RELATIVE ERROR MESSAGE --|\n       begin  segment base R1;  array 512 byte ERRORCODE=\n       (\"00 SYNTAX       \",\"01 VAR MIX TYPES\",\"02 FOR PARAMETER\",\n        \"03 REG ASS TYPES\",\"04 BIN OP TYPES \",\"05 SHIFT OP     \",\n        \"06 COMPARE TYPES\",\"07 REG TYPE OR #\",\"08 UNDEFINED ID \",\n        \"09 MULT LAB DEF \",\"10 EXC INI VALUE\",\"11 NOT INDEXABLE\",\n        \"12 DATA OVERFLOW\",\"13 NO. OF ARGS  \",\"14 ILLEGAL CHAR \",\n        \"15 MULTIPLE ID  \",\"16 PROGRAM OFLOW\",\"17 INITIAL OFLOW\",\n        \"18 ADDRESS OFLOW\",\"19 NUMBER OFLOW \",\"20 MISSING .    \",\n        \"21 STRING LENGTH\",\"22 NULL CASE ST.\",\"23 FUNC DEF NO. \",\n        \"24 ILLEGAL PARAM\",\"25 NUMBER       \",\"26 SYN MIX      \",\n        \"27 SEG NO OFLOW \",\"28 ILLEGAL CLOSE\",\"29 NO DATA SEG  \",\n        \"30 ILLEGAL INIT \",\"31 GET MORE CORE\");\n       end; R1 := R1+R2; WBUF(11/16) := B1;\n$IFF M M\n       WBUF(2) := \"ERROR NO\"; R1 := @WBUF(R6+35); B1 := \"|\";\n$END M\n$IFT M M\n       ERRMESSAGE(0/16) := B1;  R1 := @ERRORBUF;  ERRBUFFR;\n       WBUF(2) := \"ERROR NO\"; R1 := @WCARD(R6); B1 := \"|\";\n$END M\n       WBUF(108) := \"*\";  WBUF(109/16) := WBUF(108);\n       PRINT; WBUFF(0/133) := BLANK; RESET(RUNFLAG);\n       if GENFLAG then RESET(GENDECK);\n       R0 := ERRCOUNT; if R0 = ERRLIMIT then ENDMESSAGES;\n X:    LM(R0,R2,ERRSAVE);\n    end;\n\n procedure LABELERROR(R3);  |-- PRINTS OUT UNDEFINED LABELS --|\n    begin  integer TEMP, SAVE; WBUFF(0/121) := BLANK; SAVE := R0;\n       R2 := R1 + LABELBASE; WBUF(9/10) := LABEL(R2);\n       WBUF(20) := \"UNDEF LAB\";  RESET(RUNFLAG);\n       if GENFLAG then RESET(GENDECK);\n       R0 := CSEGNO; CVD(R0,CONWORK);\n       UNPK(2,7,WBUF,CONWORK); SETZONE(WBUF(2));\n       WBUF(108) := \"*\";  WBUF(109/16) := WBUF(108);\n       R2 := LABELCHAIN(R2); while R2 >= 0 do\n       begin TEMP := R2; UNPK(4,4,WBUF(4),TEMP); WBUF(8) := \" \";\n          TR(3,WBUF(4),TRTABLE(_240)); PRINT; R2 := PROGRAM(R2+2);\n          R0 := 1+ERRCOUNT =: ERRCOUNT; if R0 > ERRLIMIT then goto Y;\n       end; if R0 = ERRLIMIT then ENDMESSAGES;\n Y:    WBUFF(0/133) := BLANK;\n X:    R0 := SAVE;\n    end;\n\n procedure EDIT (R8);\n    begin R1 := LC; PROGRAM(R1) := R0; R1 := R1+2; LC := R1;\n    end;\n\n procedure EMIT (R8);\n    begin R0 := R0 shll 4 or R1 shll 4 or R2 shll 4 or R3;\n       R1 := LC; PROGRAM(R1) := R0; R1 := R1+2; LC := R1;\n    end;\n\n procedure EMYT (R8);\n    begin R0 := R0 shll 4 or R1 shll 4 or R2 shll 20 or R3;\n       R1 := LC; PROGRAM(R1+2) := R0; R0 := R0 shrl 16;\n       PROGRAM(R1) := R0; R1 := R1+4; LC := R1;\n    end;\n\n procedure EMYTBRANCH(R8);\n    begin R0 := R0 or #4700; R1 := LC; PROGRAM(R1) := R0;\n       R0 := ENDCHAIN =: PROGRAM(R1+2);\n       V(R7) := R1; R1 := R1 + 4; LC := R1;\n    end;\n\n procedure ANDTORCHAIN(R4);\n    begin integer ANDCHAIN syn MEM(R3), ORCHAIN syn MEM(R3+4);\n       byte OPCODE syn B2, COND syn B2(1);\n       if R1 := ANDCHAIN; R1 \u00ac= ENDCHAIN then\n       begin R1 := R1 and #FFFF;  R2 := @PROGRAM(R1);\n          if OPCODE = #46 then |-- BCT instruction --|\n          begin R0 := R1; R1 := LC;\n             R2 := #47F0S =: PROGRAM(R1);\n             R2 := @B1(4) =: LC;\n          end else\n          begin R0 := PROGRAM(R1+2);\n             if OPCODE = #47 and COND >= #F0 and OPTFLAG >= #80 then\n             begin LC := R1; goto X;\n             end; if < then XI(#F0,COND) else XI(#01,OPCODE);\n          end; R2 := ORCHAIN =: PROGRAM(R1+2); ORCHAIN := R1;\n X:       ANDCHAIN := R0;\n       end;\n    end;\n\n procedure MERGECHAIN (R4);\n    begin short integer NEXT syn B2(2);\n       R1 := NEXT; NEXT := R0; R0 := R1;\n       while R1 := NEXT; R1 >= 0 do R2 := @PROGRAM(R1);\n       NEXT := R0;\n    end;\n\n procedure CHAINFIXUP (R4);\n    if R1 \u00ac= ENDCHAIN then\n    begin integer SAVE4; SAVE4 := R4; R0 := R0 shll 16 shra 16;\n       R3 := N5 + BRANCHBASE; R2 := N6 + BRANCHBASE;\n       while R2 := @B2(4); R2 <= R3 do\n       begin if R0 = BRANCHADR(R2) then\n          begin R0 := R1; MERGECHAIN; R4 := SAVE4; goto X;\n          end;\n       end; BRANCHADR(R2) := R0; BRANCHAIN(R2) := R1;\n       R2 := R2 - BRANCHBASE =: N5; R1 := ENDCHAIN;\n X: end;\n\n procedure ENTERBRANCH(R8);\n    begin comment R1 = ADDRESS OF START OF BRANCH CHAIN,\n          R2 = LABEL ID;\n       R5 := N4 + LABELBASE;\n       for R4 := N3 + LABELBASE step _14S until R5 do\n       if B2(0/10) = LABEL(R4) then\n       begin R0 := R1; R2 := @LABELCHAIN(R4-2); MERGECHAIN; goto L;\n       end; R4 := 14 + N3 =: N3 + LABELBASE; LABEL(R4/10) := B2;\n       LABELCHAIN(R4) := R1; R0 := R0 -- R0 =: LABELADR(R4);\nL:  end;\n\n procedure ENTERNAME(R8);\n    begin R5 := R5-R5; IC(R5,B1); IC(R5,ALPHASH(R5-193));\n       R3 := @B3(1) and #E;  R14 := NAMEBASE;\n       R5 := R5 + LENHASH(R3-2); REDUCE(R3); R4 := HASHCHAIN(R5);\n       while R4 >= N2 do\n       begin R4 := R4 + R14; EX(R3,CLC(0,B1,NAME(R4))); if = then\n          begin XR := 15; ERROR; R4 := N1 + NAMEBASE; goto X;\n          end; R4 := LINK(R4);\n          if R4 \u00ac= ENDCHAIN then R4 := R4 and #FFFF;\n       end;\n       R4 := N1 + R14; EX(R3,MVC(0,NAME(R4),B1)); TYPE(R4) := R2;\n       ADR(R4+2) := R0; R0 := R0 shrl 16; ADR(R4) := R0;\n       R0 := HASHCHAIN(R5); LINK(R4) := R0;\n       R0 := N1; HASHCHAIN(R5) := R0; R0 := R0 + R3 + 9S; N1 := R0;\n       if R0 > NAMEND then    |NAMETABLE OVERFLOW|\n       begin  XR := 31;  ERROR;\n          WBUF := \"CORE SIZE TOO SMALL \";\n          WBUF(STRING/132-STRING) := WBUF(STRING-1);  PRINT;\n          SB(NOGO,FLGS);  ERROREXIT;\n       end;\n       if TM(2,TRACE); ON then\n       begin  WBUFF(0/132) := BLANK; WBUF(19/10) := B1;\n          R14 := #FF and R2;  CVD(R14,CONWORK);\n          OI(#0F,CONWORK(7)); UNPK(1,1,WBUFF(31),CONWORK(6));\n          if R2 \u00ac= 10S then\n          if R2 = 12S then\n          begin UNPK(8,4,WBUF(9),ADR(R4)); TR(7,WBUF(9),TRTABLE(_240));\n          end else\n          begin  UNPK(4,4,WBUF(13),ADR(R4));\n             TR(3,WBUF(13),TRTABLE(_240));\n             if R1 > R7 and R14 <= 4S then\n             begin  IC(R14,ALENGTH(R14));  R14 := @B14(1);\n                if R14 \u00ac= V(R7) then WBUF(35) := \"A\";\n             end;\n          end; WBUF(17) := \" \"; PRINT; WBUFF(0/40) := BLANK;\n       end;\n X: end;\n\n procedure EMITLIT (R4);  |-- USED BY FOR STATEMENT --|\n    begin integer TEMP; TEMP := R5; R0 := 5; R3 := R3-R3; EMIT;\n       R1 := LITX; R3 := R1 + LITBASE; R1 := R1 + 8S; LITX := R1;\n       MVI(2,B3); MVI(3,B3(1)); B3(2/2) := LC(2);\n       B3(4/4) := TEMP; R0 := 2 + LC; LC := R0;\n    end;\n\n procedure MAKELITERAL(R4);\n    begin comment R0 = TYPE, R1 = LENGTH, R2 = FIXUP ADDRESS,\n          R3 = ADDRESS OF FIRST BYTE IF NOT SHORT INTEGER TYPE 1\n             OR ADDRESS - 2 IF SHORT INTEGER;\n       short integer ADDRESS; ADDRESS := R2;\n       R2 := LITX + LITBASE; STC(R0,B2); STC(R1,B2(1));\n       B2(2/2) := ADDRESS; CLI(1,B2); if = then\n       EX(R1,MVC(0,B2(4),B3(2))) else EX(R1,MVC(0,B2(4),B3));\n       R2 := @B2(R1+5) - LITBASE; LITX := R2;\n    end;\n$PAGE\n$IFT M M\n segment procedure ENTERSYMLABEL(R8);\n    begin array 4 integer SAVE36;\n      STM(R3,R6,SAVE36); R4 := PROCSTACK; R6 := FREESPACE;\n      R5 := B6; FREESPACE := R5; R5 := DATAPTR(R4);\n      SYMLINK(R6) := R5; DATAPTR(R4) := R6; R0:= R0 and #0FFF;\n      MVI(0,AAFIELD(R6)); DISPFIELD(R6) := R0;\n      R4 := CARDCOUNT; CARDNO(R6) := R4;\n      case R1 of begin\n        begin SYMFIELD(R6/10) := V(R7); R1 := T(R7); end;\n        begin SYMFIELD(R6) := \"#B\"; R2 := CARDNO(R6);\n          CVD(R2,CONWORK); UNPK(5,3,FFIELD(R6),CONWORK(5));\n          SETZONE(MFIELD(R6+2)); SYMFIELD(R6+2/4) := FFIELD(R6);\n          R1 := 6;\n        end;\n        begin SYMFIELD(R6/10) := V1(R7); R1 := R3;\n           PROCPTR := R6;\n        end;\n        begin SYMFIELD(R6) := \"#E\"; R2 := CARDNO(R6);\n           CVD(R2,CONWORK); UNPK(5,3,FFIELD(R6),CONWORK(5));\n           SETZONE(MFIELD(R6+2)); SYMFIELD(R6+2/4) := FFIELD(R6);\n           R1 := 6;\n        end;\n        begin\n           SYMFIELD(R6) := \"#END\"; R1 := 4;\n        end;\n      end;\n      R1 := @B1(64); STC(R1,ORFIELD(R6)); LM(R3,R6,SAVE36);\n end;\n$PAGE\n segment procedure ENTERSYMDATA(R8);\n    begin array 7 integer SAVE06;\n      STM(R0,R6,SAVE06); R4 := DATASTACK; R6 := FREESPACE;\n      R5 := B6; FREESPACE := R5; R5 := DATAPTR(R4);\n      SYMLINK(R6) := R5; DATAPTR(R4) := R6; R0 := R0 and #0FFF;\n      MVI(0,AAFIELD(R6)); DISPFIELD(R6) := R0; R4 := CARDCOUNT;\n      CARDNO(R6) := R4; SYMFIELD(R6/10) := B1; R4:=128;\n      R5 := AATYPE; if R5 = B7(4) then begin R4 := @B4(64);\n         R5 := B7; end else R5 := R5 - R5;\n      R2 := 1 + T(R7) and #FF;  case R2 of begin\n        begin MVI(#14,FFIELD(R6)); MVI(1,LDFIELD(R6));\n           R5 := R5 shrl 1; end;\n        begin MVI(#10,FFIELD(R6)); MVI(3,LDFIELD(R6));\n           R5 := R5 shrl 2; end;\n        begin MVI(#1C,FFIELD(R6)); MVI(7,LDFIELD(R6));\n           R5 := R5 shrl 3; end;\n        begin MVI(#18,FFIELD(R6)); MVI(3,LDFIELD(R6));\n           R5 := R5 shrl 2; end;\n        begin MVI(#04,FFIELD(R6)); MVI(0,LDFIELD(R6)); end;\n        end;\n      DUPFAC(R6) := R5; MVI(0,MFIELD(R6));\n      R4 := R4 or R3; STC(R4,ORFIELD(R6)); LM(R0,R6,SAVE06);\n end;\n$PAGE\n$END M\n segment procedure ALLOCATELITERALS(R8);\n    begin  |-- R4 := LC IS A PARAMETER --|\n       array  3  integer TEMP; integer LITEND;\n       short integer ADDRESS;\n\n    procedure RLDCHAINEMIT(R8);\n       begin comment FIX UP RLD CHAIN ENTRIES AND EMIT RLD LITERAL --\n          R4 = LC, FIRST ENTRY IS MAIN PROGRAM;\n          R0 := PROGESDEND; R1 := PROGESDADR;\n          R5 := RLDADDR(R1); if R5 >= 0 then\n          begin while R5 >= 0 do\n             begin R6 := PROGRAM(R5+2); R2 := PROGRAM(R5);\n                R3 := R2 and #F shll 12 + R4 - R5; PROGRAM(R5+2) := R3;\n                R2 := R2 and #FFF0; PROGRAM(R5) := R2; R5 := R6;\n             end;\n             R3 := R3-R3; PROGRAM(R4) := R3; PROGRAM(R4+2) := R3;\n             RLDADDR(R1) := R4;  R4 := @B4(4);\n          end;\n          R1 := R1 + 8S; while R1 < R0 do\n          begin  if ESDTYPE(R1) \u00ac= SD then\n                 if ESDTYPE(R1) \u00ac= ER then\n                 if ESDTYPE(R1) \u00ac= WER then\n                 if ESDTYPE(R1) \u00ac= XCM then goto SKIP;\n             R5 := RLDADDR(R1); if R5 < 0 then goto SKIP;\n             while R5 >= 0 do\n             begin R6 := PROGRAM(R5+2); R3 := PTAG + R4;\n                PROGRAM(R5+2) := R3; R5 := R6;\n             end;\n             R3 := R3-R3; PROGRAM(R4) := R3; PROGRAM(R4+2) := R3;\n             RLDADDR(R1) := R4;  R4 := @B4(4);\nSKIP:        R1 := R1 + 8S;\n          end;  R5 := @PROGRAM(R4);  B5(0/4) := ZERO;\n       end;\n\n    procedure ALLTYPE(R8);\n       begin comment R0 = LENGTH AND R4 = LC ARE PARAMETERS --\n          R7 = START OF LITERALS -- LITEND = END OF LITERALS;\n          R6 := R7; while R6 < LITEND do\n          begin IC(R1,B6(1)); IC(R2,B6); if R0 = R2 then\n             begin ADDRESS(0/2) := B6(2); R3 := ADDRESS;\n                R4 := R4 + PTAG; PROGRAM(R3) := R4;\n                ADDRESS:=R4; B6(2/2) := ADDRESS;\n                R5 := @B6(R1+5); while R5 < LITEND do\n                begin IC(R2,B5(1)); CLC(1,B5,B6); if = then\n                   begin EX(R2,CLC(0,B5(4),B6(4))); if = then\n                      begin ADDRESS(0/2) := B5(2); R3 := ADDRESS;\n                         PROGRAM(R3) := R4; MVI(4,B5);\n                         ADDRESS:=R4; B5(2/2) := ADDRESS;\n                      end;\n                   end; R5 := @B5(R2+5);\n                end; R4 := R4 - PTAG; R5 := @PROGRAM(R4);\n                EX(R1,MVC(0,B5,B6(4))); R4 := @B4(R1+1);\n             end; R6 := @B6(R1+5);\n          end;  R5 := @PROGRAM(R4);  B5(0/4) := ZERO;\n       end;\n\n       STM(R6,R8,TEMP); R7 := LITBASE; R6 := R7 + LITX;\n       LITEND := R6; R6 := N4 + LABELBASE; R7 := R7 + LABEL(R6+2);\n       LM(R0,R2,ZERO);  ALLTYPE;\n       R0 := 1; R4 := R4 + 1 and _2; ALLTYPE;\n       R0 := 2; R4 := R4 + 3S and _4; ALLTYPE;\n       RLDCHAINEMIT; LM(R1,R2,ZERO);\n       R0 := 3; R4 := R4 + 7S and _8; ALLTYPE;\n       R6:=R7; while R6<LITEND do\n       begin IC(R2,B6); if R2>8S then\n          begin R2:=R2 shll 30; if R2<0 then\n             begin ADDRESS(0/2) := B6(8); R3:=ADDRESS+ LITBASE;\n                B6(8/2) := B3(2);\n             end; R2:=R2 shll 1; if R2<0 then\n             begin ADDRESS(0/2) := B6(6); R3:=ADDRESS+LITBASE;\n                B6(6/2) := B3(2);\n             end; R2:=8; STC(R2,B6);\n          end; IC(R1,B6(1)); R6:=@B6(R1+5);\n       end; R0:=8; ALLTYPE;\n       R3 := N4 + LABELBASE; R2 := LABEL(R3+2); LITX := R2;\n       LM(R6,R8,TEMP);\n    end;\n\n procedure SETDATAINIT(R8);\n    begin comment SET DATA INITIALIZATION --\n       R1 = COUNT -- AT EXIT R2 = ADDRESS TO MOVE DATA;\n       R3 := LASTINITIAL(R10); R2 := INITIALSTART(R3) + INITIALEN(R3);\n       R4 := DC1; if R2 \u00ac= R4 then\n       begin  if R2 \u00ac= INITIALSTART(R3) then\n          begin R3 := R3 + INITIALEN(R3) + 5S and _2;\n             LASTINITIAL(R10) := R3;  |-- NEW LAST --|\n             R0 := R0-R0; INITIALEN(R3) := R0;\n          end;  INITIALSTART(R3) := R4;\n       end;  R0 := 4 + R3 + R1 + INITIALEN(R3);  |-- @LAST BYTE --|\n       if R0 > DATAEND then\n       begin XR := 17; ERROR; SET(SKIPFLAG);\n          R1 := R1-R1; INITIALEN(R3) := R1;\n       end else\n       begin R0 := R4+R1;  if R0 > DC then\n          if FILLFLAG then DC := R0 else  |-- ERROR --|\n          begin XR := 10; ERROR; SET(SKIPFLAG); R1 := R1-R1;\n          end;\n       end;\n       R0 := R1 + INITIALEN(R3); R2 := 4 + R3 + INITIALEN(R3);\n       INITIALEN(R3) := R0; R0 := DC1 + R1; DC1 := R0;\n    end;\n\n procedure MOVETABLE(R4);\n    if R3 \u00ac= 0 then\n    begin  |-- MOVE R3 BYTES FROM B1 TO B2 --|\n       for R3 := R3 - 1 step _256 until 256 do\n       begin B2(0/256) := B1; R1 := R1 + 256; R2 := R2 + 256;\n       end; EX(R3,MVC(0,B2,B1));\n    end;\n\n procedure INCRSEGNO(R8);\n    begin  |-- GET NEXT SEGMENT NUMBER --|\n       R0 := 1 + NSEGNO; if R0 > MAXSEGNO then\n       begin XR := 27; ERROR; R0 := MAXSEGNO;\n       end; NSEGNO := R0; SEGNO := R0;\n       if R0 > MAXSEG then MAXSEG := R0;\n    end;\n\n procedure FINDESDENTRY(R8);\n    begin comment R0 = END OF ESD TABLE, R1 = START OF ESD TABLE,\n       R2 = ESD TYPE, R3 = RLD FLAG, R4 = CSEGNO -- AT EXIT\n       R0 = NEW END OF ESD TABLE, R1 = ADDRESS OF ESD ENTRY --\n       A NEW ENTRY IS MADE IF NO ENTRY IS FOUND;\n       while R1 < R0 do\n       if R4 = PL360NO(R1) then goto FOUND else R1 := R1 + 8S;\n       PL360NO(R1) := R4; R0 := ENDCHAIN; RLDADDR(R1) := R0;\n       ESDLINK(R1) := R0;\n       STC(R2,ESDTYPE(R1)); STC(R3,RLDFLAG(R1)); R0 := 8 + R1;\nFOUND:\n    end;\n\n procedure STACKSEG(R4);\n    begin comment STACK CURRENT SEG TO BE READY TO OPEN NEW SEG --\n       R0 = END OF ESD TABLE, R1 = START OF ESD TABLE,\n       R5 = START OF SEGMENT TO STACK -- AT EXIT\n       R5 = START OF NEW SEGMENT AND PREVSEG SET TO STACKED SEG;\n       STM(R0,R4,PARAMSAVE);\n       R2 := LASTINITIAL(R5) + INITIALEN(R2) + 5S and _2;\n       R3 := R0 - R1; TABLEN(R2) := R3; R2 := R2 + 2; R0 := R2 + R3;\n       MOVETABLE; R1 := R0 + 3S and _4;\n       PREVSEG(R1) := R5; R5 := R1;\n       LM(R0,R4,PARAMSAVE);\n    end;\n\n procedure UNSTACKSEG(R4);\n    begin comment UNSTACK SEG --\n       R1 = START OF ESD TABLE, R5 = START OF SEGMENT TO UNSTACK,\n       AT EXIT R0 = END OF ESD TABLE;\n       STM(R1,R4,PARAMSAVE(4));\n       R2 := R1; R1 := LASTINITIAL(R5) + INITIALEN(R1) + 5S and _2;\n       R3 := TABLEN(R1); R1 := R1 + 2;\n       R0 := R2 + R3; MOVETABLE;\n       LM(R1,R4,PARAMSAVE(4));\n    end;\n$PAGE\n procedure OPENSEG(R4);\n    begin comment OPEN NEW SEGMENT -- R5 = START OF SEGMENT,\n       R2 = TYPE OF SEG, R3 = BASE REGISTER FOR SEG;\n$IFF M M\n       STM(R0,R1,PARAMSAVE);\n$END M\n$IFT M M\n       STM(R0,R3,PARAMSAVE);\n$END M\n       SEGTYPE(R5) := R2; SEGBASEREG(R5) := R3;\n$IFF M M\n       R1 := R5 + SEGHDLEN; LASTINITIAL(R5) := R1; R0 := R0-R0;\n$END M\n$IFT M M\n       if TESTFLAG then\n       begin  if R2 > 10 then\n          begin  R3 := DATASTACK;  R3 := @B3(4);\n             if R3 = DSTAKBOT then\n             begin  RESET(TESTFLAG);  goto X;  end;\n             DATASTACK := R3;\n          end else\n          begin  R3 := PROCSTACK;  R3 := @B3(4);\n             if R3 = PSTAKBOT then\n             begin  RESET(TESTFLAG);  goto X;  end;\n             PROCSTACK := R3;\n          end;  R0 := neg 1;  DATAPTR(R3) := R0;\n       end;\n       X: R1 := R5 + SEGHDLEN; LASTINITIAL(R5) := R1; R0 := R0-R0;\n$END M\n       COUNTER(R5) := R0; INITIALSTART(R1) := R0; INITIALEN(R1) := R0;\n       R0 := BLOCK; BLOCKLEVEL(R5) := R0;\n$IFF M M\n       LM(R0,R1,PARAMSAVE);\n$END M\n$IFT M M\n       LM(R0,R3,PARAMSAVE);\n$END M\n    end;\n$PAGE\n segment procedure CLOSESEG(R4);\n    begin comment CLOSE CURRENT SEGMENT -- R5 = START OF SEGMENT,\n       R0 = END OF ESD TABLE, R1 = START OF ESD TABLE;\n       array 2 logical SAVE01;  array 8 logical SAVE07;\n       array 40 short integer CARD syn PBUF; integer CARDI syn PBUF;\n       short integer ESDID, SEQNO;\n       integer WORK syn CONWORK; byte DUMPLINE syn WBUF(17);\n\n    procedure DUMPHALF(R1);\n       begin UNPK(8,4,B2,B3); MVI(239,B2(8));\n          UNPK(8,4,B2(10),B3(4)); MVI(239,B2(18));\n          UNPK(8,4,B2(20),B3(8)); MVI(239,B2(28));\n          UNPK(8,4,B2(30),B3(12)); MVI(239,B2(38));\n          R2 := @B2(41); R3 := @B3(16);\n       end;\n\n    procedure PUNCHSEQ (R8);\n       begin  R0 := 1 + SEQNO; SEQNO := R0; CVD(R0,CONWORK);\n          UNPK(3,7,CARD(76),CONWORK); SETZONE(CARD(79));\n          CARD(72/4) := SEGNAM; R0 := @CARD; PUNCH;\n       end;\n\n    procedure CARDOUT (R8);\n       begin  logical SAVE8; SAVE8 := R8;\n          if R0 \u00ac= 0 then\n          begin  CARD(10) := R0; PUNCHSEQ;\n          end;\n          R0 := R0-R0; R6 := @CARD; CARD(5/75) := CARD(4);\n          R8 := SAVE8;\n       end;\n\n    procedure ESDPRINT(R8);\n       begin  comment PRINT ESD DICTIONARY ENTRY --\n          R6 + 16 = OBJECT ESD CARD ENTRY;\n          STM(R0,R1,SAVE01); WBUFF(0/133) := BLANK;\n          if C6(24) = ER then  |-- EXTRN --|\n          WBUF(40) := \"EXTERNAL REFERENCE\" else\n          if C6(24) = WER then  |-- WEAK EXTRN --|\n          WBUF(40) := \"WEAK EXT REFERENCE\" else\n          begin  WBUF(40) := \"ENTRY (XX) AT\";  R1 := R1-R1;\n             IC(R1,B6(24)); R1 := R1+R1; R1 := @ESDCODE(R1);\n             WBUF(47/2) := B1; UNPK(4,2,WBUF(54),B6(26));\n             TR(3,WBUF(54),TRTABLE(_240));  WBUF(58) := \" \";\n          end;\n          WBUF(30/8) := B6(16); PRINT; LM(R0,R1,SAVE01);\n       end;\n$PAGE\n$IFF M M\n       STM(R0,R7,SAVE07);  R4 := SEGTYPE(R5);\n$END M\n$IFT M M\n procedure GENLABEL(R7);\n    begin integer SAVE3;  SAVE3 := R3;  R3 := CARDNO(R5);\n       CVD(R3,CONWORK);  UNPK(5,3,WCARD(1),CONWORK(5));\n       SETZONE(WCARD(5));  WCARD := \"#\";  if R1 > 4S then\n       begin  SYMFIELD(R5+5/5) := WCARD;  R1 := 10;\n       end else\n       begin R3 := @B5(R1+1); SYMFIELD(R3/5) := WCARD; R1 := @B1(6);\n       end;  RB(#0F,ORFIELD(R5));  EX(R1,SB(0,ORFIELD(R5)));\n       R3 := SAVE3;\n    end;\n\n procedure PUTNAME(R7);\n    begin  R6 := @CARD(20);  R0 := 4;  if B3 = \"SEGN\" then\n       begin  B6(0/7) := B3;  R6 := @B6(7);  R1 := 7;  R0:= 11;\n       end else\n       begin  R1 := R1 - R1;\n LOOP:    if B3(0/1) \u00ac= \" \" then\n          begin  B6(0/1) := B3;  R3 := @B3(1);  R6 := @B6(1);\n             R0 := R0 + 1S; R1 := @B1(1); if R1 < 8S then goto LOOP;\n          end;\n       end;\n    end;\n\n procedure SEARCH(R8);\n   begin integer SAVE5;  SAVE5 := R5;  R2 := R5;  while R2 > 0 do\n      begin  IC(R1,ORFIELD(R2));  R1 := R1 and 15;  REDUCE(R1);\n         R3 := R3 - R3;  CLC(1,SYMFIELD(R2),\"#B\");  if \u00ac= then\n         begin  R5 := SYMLINK(R2);  RESET(SYM);  while R5 > 0 do\n            begin  IC(R3,ORFIELD(R5));  R3 := R3 and 15;\n               REDUCE(R3);  if R1 = R3 then\n               begin  EX(R1,CLC(0,SYMFIELD(R5),SYMFIELD(R2)));\n                  if = then\n                  begin  GENLABEL;  SET(SYM);  R1 := R3;\n                  end;\n               end;  R5 := SYMLINK(R5);\n            end;  if SYM then\n            begin  RESET(SYM);  R5 := R2;  GENLABEL;\n            end;\n         end;  R2 := SYMLINK(R2);\n      end;  R5 := SAVE5;\n   end;\n\n procedure CSECT(R8);\n    begin  R6 := PL360NO(R1);  R6 := R6 * 10S;  CARD := \"`BSYMPL3 \";\n       CARD(8/72) := CARD(7);  R3 := @ESDNAME(R6);  case R4 of\n       begin\n          begin  CARD(16/4) := #10000000;  PUTNAME;  end;\n          begin  CARD(16/4) := #30000000;  PUTNAME;  end;\n          null;\n          begin  R2 := CARDNO(R5);  REDUCE(R2);  CVD(R2,CONWORK);\n             UNPK(5,3,CARD(22),CONWORK(5));  SETZONE(CARD(26));\n             CARD(16/6) := #200000007BC4X;  R6 := @CARD(26);\n             R0 := 10;  R1 := 6;\n          end;\n       end;  EX(R1,SB(0,CARD(16)));\n    end;\n\n procedure OUTSYM(R7);\n    begin  R2 := R0 + R1;  if R2 <= 55S then R2 := R2 - R2 else\n       begin  R2 := R2 - 55S;  R1 := R1 - R2;\n       end;  EX(R1,MVC(0,B6,ORFIELD(R5)));  R1 := @B1(1);\n       R0 := R0 + R1;  R6 := R6 + R1;  if R0 = 56 then\n       begin  CARDOUT;  CARD := \"`BSYMPL3 \";  CARD(8/64) := CARD(7);\n          R6 := @CARD(16);  if R2 \u00ac= 0 then\n          begin  R3 := R5 + R1;  EX(R2,MVC(0,B6,ORFIELD(R3)));\n             R6 := R6 + R2;  R0 := R2;\n          end;\n       end; R3 := FREESPACE; R2 := SYMLINK(R5); SYMLINK(R5) := R3;\n       FREESPACE := R5; R5 := R2;\n    end;\n\n procedure SYMPRINT(R7);\n    begin  integer STOP=_1, SAVE7;  R0 := R0 - R0 =: SEQNO;\n       SAVE7 := R7;  if R1 \u00ac= DATAESDADR then\n       begin  R6 := PROCSTACK;  if R4 = 3S then\n          begin R6 := R6 - 4S; R5 := DATAPTR(R6); R2 := SYMLINK(R5);\n             DATAPTR(R6) := R2;  PROCSTACK := R6;  R2 := FREESPACE;\n             FREESPACE := R5;  B5 := R2;  goto FINISH;\n          end;  R5 := DATAPTR(R6);  R0 := STOP;  while R5 > 0 do\n          begin  R2 := SYMLINK(R5);  SYMLINK(R5) := R0;  R0 := R5;\n             R5 := R2;\n          end;  if R6 = DSTAKBOT then\n          begin  R5 := R0;  R6 := R6 - 4S;\n          end else\n          begin  R6 := R6 - 4S;  R3 := DATAPTR(R6);\n             R2 := SYMLINK(R3);  DATAPTR(R6) := R2;\n             SYMLINK(R3) := R0;  R5 := R3;\n             AAFIELD(R5/3) := #000000X;\n          end;  PROCSTACK := R6;  CSECT;  R1 := R1 - R1;  SEARCH;\n          while R5 > 0 do\n          begin  IC(R1,ORFIELD(R5));  R1 := R1 and 15;\n             R1 := @B1(3);  OUTSYM;\n          end;\n       end else\n       begin  R6 := DATASTACK;  R5 := DATAPTR(R6);  R6 := R6 - 4S;\n          DATASTACK := R6;  if R4 = 3S then\n          begin  R6 := FREESPACE;  while R5 > 0 do\n             begin  R2 := SYMLINK(R5);  SYMLINK(R5) := R6;\n                R6 := R5;  R5 := R2;\n             end;  FREESPACE := R6;  goto FINISH;\n          end;  if R5 = STOP then goto FINISH;\n          R0 := STOP;  while R5 > 0 do\n          begin  R2 := SYMLINK(R5);  SYMLINK(R5) := R0;  R0 := R5;\n             R5 := R2;\n          end;  R5 := R0;  CSECT;  R1 := R1 - R1;  SEARCH;\n          while R5 > 0 do\n          begin  IC(R1,ORFIELD(R5));  R3 := R1;  R1 := R1 and 15;\n             REDUCE(R1);  CLI(#04,FFIELD(R5));  if = then\n             begin  LDFIELD(R5+1/5) := MFIELD(R5);  R4 := 2;\n             end else\n             begin  LDFIELD(R5+1/4) := MFIELD(R5+1);  R4 := 1;\n             end;  if R1 \u00ac= 9S then\n             begin  R2 := R5 + R1;  B2(11/6) := FFIELD(R5);\n             end;  CLI(#C0,ORFIELD(R5));\n             if >= then R1 := @B1(R4+8) else R1 := @B1(R4+5);\n             OUTSYM;\n          end;\n       end; CARDOUT;\n FINISH:\n       R7 := SAVE7;\n    end;\n$PAGE\n       STM(R0,R7,SAVE07);  R4 := SEGTYPE(R5);\n       if TESTFLAG then if RUNFLAG or GENDECK then\n       begin SYMPRINT; LM(R0,R7,SAVE07); R4 := SEGTYPE(R5); end;\n$END M\n       if R4 >= 3S then goto FIN;  OUTPUTCARD;\n    |-- LIST CURRENT SEGMENT --|\n       WBUFF(0/133) := BLANK; SETZONE(CARRCONT);\n       WBUF(27) := \"SEGMENT\";  R2 := PL360NO(R1);\n       CVD(R2,CONWORK); UNPK(2,7,WBUF(35),CONWORK);\n       SETZONE(WBUF(37));  WBUF(40) := \"NAME =\";\n       R2 := R2 * 10S; R2 := @ESDNAME(R2); WBUF(47/10) := B2;\n       R6 := 1;  if R5 = R9 and R4 = R6 then  |-- PROGRAM SEGMENT --|\n       begin  R6 := NSEGNO;  R14 := R6 * 10S;  R14 := @ESDNAME(R14);\n          while R14 > R2 and SEGNAM(0/4) \u00ac= B14 do\n          begin  REDUCE(R6);  R14 := R14 - 10S;\n          end;  NSEGNO := R6;  |-- NEXT SEGMENT --|\n       end;  WBUF(58) := \"LENGTH =\";  UNPK(4,4,WBUF(67),COUNTER(R5));\n       TR(3,WBUF(67),TRTABLE(_240));  WBUF(71) := \"  BASE REG =\";\n       R2 := SEGBASEREG(R5); CVD(R2,CONWORK);\n       UNPK(1,7,WBUF(84),CONWORK); SETZONE(WBUF(85)); PRINT;\n       if TM(4,TRACE); OFF then goto X;\n       SETZONE(CARRCONT);  R7 := LASTINITIAL(R5);\n       R5 := R5 + SEGHDLEN;  WBUFF(0/133) := BLANK;\n       while R5 <= R7 do\n       begin R4 := R4-R4; R6 := INITIALEN(R5);\n          while R4 < R6 do\n          begin R2 := R4 + INITIALSTART(R5); WORK := R2;\n             MVI(239,DUMPLINE(8)); DUMPLINE(9/79) := DUMPLINE(8);\n             UNPK(4,4,DUMPLINE,WORK); R3 := @B5(R4+4);\n             TR(3,DUMPLINE,TRTABLE(_240));\n             CLC(27,B3,B3(4)); if = then\n             begin DUMPLINE(4) := \" TO\";\n                UNPK(8,4,DUMPLINE(18),B3); MVI(239,DUMPLINE(26));\n L1:            R4 := R4 + 32S; if R4 < R6 then\n                begin R3 := @B5(R4); CLC(31,B3,B3(4));\n                   if = then goto L1;\n                end;\n                if R4 > R6 then R4 := R6;\n                R2 := R4 + INITIALSTART(R5) - 4; WORK := R2;\n                UNPK(4,4,DUMPLINE(8),WORK); MVI(239,DUMPLINE(12));\n                TR(79,DUMPLINE(8),DTRTABLE(_239));\n                PRINT; DUMPLINE(5/2) := DUMPLINE(4);\n             end else\n             begin DUMPLINE(4) := \" \";  R0 := R6 - R4; R4 := @B4(32);\n                R2 := @DUMPLINE(8); if R0 >= 32S then\n                begin DUMPHALF; DUMPHALF;\n                end else\n                begin if R0 >= 16S then\n                   begin R0 := R0 - 16S; DUMPHALF;\n                   end;\n                   while R0 >= 4 do\n                   begin UNPK(8,4,B2,B3); MVI(239,B2(8));\n                      R0 := R0 - 4; R2 := @B2(10); R3 := @B3(4);\n                   end;\n                   while R0 > 0 do\n                   begin UNPK(2,1,B2,B3); R0 := R0 - 1S;\n                      R2 := @B2(2); R3 := @B3(1);\n                   end; MVI(239,B2);\n                end;\n                TR(79,DUMPLINE(8),DTRTABLE(_239)); PRINT;\n             end;\n          end;\n          R5 := @B5(R6+5) and _2;\n       end;\n X:    WBUFF(0/133) := BLANK; SETZONE(CARRCONT);\n       if \u00acGENDECK then goto FIN;\n    |-- PUNCH CURRENT SEGMENT AS CSECT --|\n       LM(R0,R7,SAVE07); R2 := R0;\n       if TM(1,TRACE); ON then\n       begin WBUF(27) := \"EXTERNAL SYMBOL DICTIONARY\";  PRINT;\n       end;\n       R0 := R0-R0; ESDID := R0; R6 := @CARD; R7 := \"  \";\n$IFF M M\n       SEQNO := R0;  |-- CLEAR SEQUENCE NUMBER --|\n$END M\n$IFT M M\n       if \u00acTESTFLAG then SEQNO := R0;\n$END M\n                    |-- *** PUNCH ESD CARDS ***  --|\n       CARD := \"`BESD \";  CARD(5/75) := CARD(4);\n       while R1 < R2 do\n       begin\n          if ESDTYPE(R1) \u00ac= LD then    |-- LD HAS NO ESDID --|\n          begin  R3 := ESDLINK(R1); if R3 >= 0 then\n             begin  R3 := R3 + SAVE07(4); R3 := ESDLINK(R3);\n             end else\n             begin  R3 := 1 + ESDID; ESDID := R3;\n             end;  ESDLINK(R1) := R3;\n             if ESDTYPE(R1) \u00ac= RLD and R7 = \"  \" then R7 := R3;\n          end;\n          if ESDTYPE(R1) \u00ac= RLD then\n          begin  R3 := PL360NO(R1)*10S; R3 := @ESDNAME(R3);\n             B6(16/8) := B3; R3 := R3-R3; R4 := BLANK;\n             if ESDTYPE(R1) = SD then\n             begin   |-- CSECT --|\n                R3 := R3-R3; R4 := COUNTER(R5); goto X;\n             end;\n             if ESDTYPE(R1) = LD then\n             begin   |-- ENTRY --|\n                R3 := RLDADDR(R1); R4 := 1; goto X;\n             end;\n             if ESDTYPE(R1) = ER then goto X;  |-- EXTRN --|\n             if ESDTYPE(R1) = WER then goto X; |-- WEAK EXTRN --|\n             if ESDTYPE(R1) = CM then\n             begin  |-- COMMON --|\n                R3 := R3-R3; R4 := COUNTER(R5); goto X;\n             end;\n             if ESDTYPE(R1) = XCM then\n             begin  |-- XCOMMON (EXTERNAL BLANK COMMON) --|\n                R3 := R3-R3; R4 := R4-R4; goto X;\n             end;\n X:          STM(R3,R4,B6(24));\n             if ESDTYPE(R1) = XCM then C6(24) := CM\n                                  else C6(24) := ESDTYPE(R1);\n             C6(28) := \" \";  if TM(1,TRACE); ON  or\n                C6(24) \u00ac= ER then ESDPRINT;\n             R0 := R0 + 16S; R6 := R6 + 16S;\n             if R0 = 48S then\n             begin  CARD(14) := R7; CARDOUT; R7 := \"  \";\n             end;\n          end;\n          R1 := R1 + 8S;\n       end;\n       CARD(14) := R7; CARDOUT;\n                    |--  *** PUNCH TXT CARDS ***  --|\n       CARD := \"`BTXT \";  CARD(5/75) := CARD(4);\n       R7 := LASTINITIAL(R5); R5 := R5 + SEGHDLEN;\n       while R5 <= R7 do\n       begin  R1 := INITIALSTART(R5); R2 := INITIALEN(R5);\n          R4 := 5 + R5 + R2 and _2;  R0 := 56;\n          while R2 >= R0 do\n          begin  CARD(14/2) := 1S; CARDI(4) := R1; CARD(4) := \" \";\n             CARD(16/56) := B5(4); CARDOUT; R0 := 56;\n             R5 := R5 + R0; R1 := R1 + R0; R2 := R2 - R0;\n          end;\n          if R2 > 0 then\n          begin\n             R0 := R2; R2 := R2 - 1S;\n             CARD(14/2) := 1S; CARDI(4) := R1; CARD(4) := \" \";\n             EX(R2,MVC(0,CARD(16),B5(4))); CARDOUT;\n          end;\n          R5 := R4;\n       end;\n                    |-- *** PUNCH RLD CARDS ***  --|\n       CARD := \"`BRLD \";  CARD(5/75) := CARD(4);\n       LM(R0,R1,SAVE07); R2 := R0; R0 := R0-R0; R6 := @CARD;\n       while R1 < R2 do\n       begin\n          R4 := RLDADDR(R1); if ESDTYPE(R1) \u00ac= LD and R4 >= 0 then\n          begin  if R0 = 56S then CARDOUT;\n             R3 := ESDLINK(R1);  H6(16) := R3;  H6(18) := 1S;\n             B6(20) := R4;  C6(20) := RLDFLAG(R1);\n             R6 := R6 + 8S; R0 := R0 + 8S;\n          end;\n          R1 := R1 + 8S;\n       end;\n       CARDOUT;\n                    |--  *** PUNCH END CARD ***  --|\n       CARD := \"`BEND \";  CARD(5/75) := CARD(4);\n       R1 := SAVE07(4); R1 := PL360NO(R1); if R1 = 1S then\n       begin  CARD(5/3) := 0; CARD(14/2) := 1S;\n$IFT\n       end; CARD(39/6) := HEADER(1); CARD(45/16) := HEADER(94);\n$END\n$IFF\n       end; if OSSYSTEM then CARD(32/39) := IDRDATA else\n       begin CARD(39/6) := HEADER(1); CARD(45/16) := HEADER(94);\n       end;\n$END\n       PUNCHSEQ;  SETZONE(CARRCONT);\n       WBUFF(0/133) := BLANK;\nFIN:\n       LM(R0,R7,SAVE07);\n    end;\n$PAGE\n procedure OPENPROCSEG(R4);\n    begin  |-- OPEN A NEW PROCEDURE SEGMENT --|\n    |--  T(R7) = TYPE OF PROCEDURE SEGMENT --|\n    |--  V(R7) = NAMETABLE ENTRY ADDRESS --|\n    |- V(R7+4) = RETURN REGISTER FOR PROCEDURE --|\n       integer SAVE; SAVE := R4; INCRSEGNO;\n       R0 := LC; R1 := LASTINITIAL(R9); INITIALEN(R1) := R0;\n       R0 := PROGESDEND; R1 := PROGESDADR; R5 := R9; STACKSEG;\n       R9 := R5; R2 := T(R7); R3 := PROGREG; OPENSEG;\n       R0 := R1; R2 := SD; R3 := VTYPE; R4 := SEGNO;\n       FINDESDENTRY; PROGESDEND := R0; R2 := 14 + N3;\n       R0 := N4; N4 := R2; N3 := R2; R2 := R2 + LABELBASE;\n       B2(0/12) := ZERO; LABELADR(R2) := R0;\n       R0 := LITX; LABEL(R2+2) := R0;\n       R0 := CSEGNO; LABEL(R2+8) := R0; CSEGNO := R4;\n       R0 := N6; R1 := 4 + N5 =: N5 =: N6 + BRANCHBASE;\n       BRANCHADR(R1) := R0;\n       R4 := SAVE;\n    end;\n\n procedure DATASEGERROR(R4);\n    begin  |-- NO DATA SEGMENT FOR DECLARED VARIABLE -- OPEN DUMMY --|\n       integer SAVER4; SAVER4 := R4;\n       XR := 29; ERROR; RESET(NODATASEG); INCRSEGNO; R1 := DATAESDADR;\n       R2 := 4; R3 := 13; R5 := R10; OPENSEG; R0 := R1;\n       R2 := SD; R3 := ATYPE; R4 := SEGNO; FINDESDENTRY;\n       DATAESDEND := R0; R4 := SAVER4;\n    end;\n\n$IFF\n$PAGE\n   procedure ENTEREF (R1);\n   begin  array 6 integer SAVE;  STM(R0,R5,SAVE);\n      if VALUE(3) = \" \" and VALUE(1) >= \"0\" then\n      if VALUE(2) = \" \" or  VALUE(2) >= \"0\" then\n      if VALUE = \"R\" or VALUE = \"B\"\n      or VALUE = \"C\" or VALUE = \"H\" then goto Y;\n      R3 := 1 + SYMTYPE and #E;\n      R5 := R5-R5;  IC(R5,VALUE);\n      IC(R5,ALPHASH(R5-193));\n      R5 := R5 + LENHASH(R3-2);  R3 := R3 - 1;\n      R4 := REFCHAIN(R5);  while R4 >= 0 do\n      begin  R4 := R4 + REFSTART;\n         EX(R3,CLC(0,REFNAME(R4),VALUE));\n         if = then goto X;\n         R4 := LINKN(R4);\n      end;  R1 := REFLEN + REFN1;  if R1 > REFN2 then\n      begin  SET(REFOUT);  goto Y;\n      end;  R4 := REFN1 + REFSTART;  REFNAME(R4/10) := VALUE;\n      R2 := REFN2;  LINKF(R4) := R2;  LINKL(R4) := R2;\n      R0 := REFCHAIN(R5);  LINKN(R4) := R0;\n      R0 := REFN1;  REFCHAIN(R5) := R0;  REFN1 := R1;\n X:   R0 := CARDCOUNT;  LASTCARD := R0;\n      R0 := REFN2;  R1 := REFSTART;  R2 := LINKL(R4) + R1;\n      LINKL(R4) := R0;  R4 := REFLINK(R2) or R0;\n      REFLINK(R2) := R4;  |-- ENDCHAIN IS 0 IN BITS 14-31 --|\n      R1 := R1+R0; R2 := CARDCOUNT shll 18; REFLINK(R1) := R2;\n      R0 := R0 - 4;  if R0 < REFN1 then SET(REFOUT)\n                                   else REFN2 := R0;\n Y:   LM(R0,R5,SAVE);\n   end;\n$PAGE\n   procedure PRINTREFS(R1);\n   begin array 10 integer SAVE;  STM(R0,R9,SAVE);\n      OUTPUTCARD;  R1 := REFN1;  if R1 \u00ac= 0 then\n      begin  R8 := R1;\n         R7 := REFLEN;  R9 := REFSTART - R7;\n    X1:  R0 := R0-R0; R1 := R1 / R7 shrl 1 * R7;\n         if R1 = 0 then goto X5;\n         R2 := R8 - R1;\n         R3 := R7;\n    X2:  R4 := R3;\n    X3:  R5 := R9 + R4;\n         R6 := R5 + R1;\n         CLC(9,REFNAME(R5),REFNAME(R6));\n         if <= then goto X4;\n         XC(REFMOV,LINKF(R6),LINKF(R5));\n         XC(REFMOV,LINKF(R5),LINKF(R6));\n         XC(REFMOV,LINKF(R6),LINKF(R5));\n         if R4 <= R1 then goto X4;\n         R4 := R4 - R1;  goto X3;\n    X4:  if R2 = R3 then goto X1;\n         R3 := R3 + R7;  goto X2;\n    X5:  HEADER(8) := \"ROSS REFERENCE\";\n         SUBHEAD(1/132) := SUBHEAD;  CARRCONT := \"1\";\n         if REFOUT then  |-- XREF TABLE FULL --|\n         begin  WBUFF(0/133) := BLANK;  R1 := LASTCARD;\n            WBUF := \"DECLARATIONS AND REFERENCES THROUGH LINE\";\n            CVD(R1,CONWORK);  UNPK(3,7,WBUF(41),CONWORK);\n            SETZONE(WBUF(44));  PRINT;  CARRCONT := \"0\";\n         end;  WBUFF(0/133) := BLANK;  WBUF(17) := \"SYMBOLS,\";\n         R8 := #3FFFF;  R1 := REFN1 shrl 1;  CVD(R1,CONWORK);\n         WBUF(12) := \"`0`0`1`0\";  ED(4,WBUF(11),CONWORK(5));\n         WBUF(33) := \"REFERENCES\";  R1 := REFN3--REFN2 shrl 2 * 10S;\n         CVD(R1,CONWORK);  WBUF(26) := \"`0`0`0`0`1`0\";\n         ED(6,WBUF(25),CONWORK(4));  PRINT;  CARRCONT := \"0\";\n         R9 := REFSTART;  R7 := R7-R7;  while R7 < REFN1 do\n         begin  WBUFF(0/133) := BLANK; OC(0,CARRCONT,XREFCC);\n            R4 := R7 + R9;  WBUF(0/10) := REFNAME(R4);\n            R4 := LINKF(R4);\n         X: R6 := R6-R6;  R5 := @WBUF(12);\n            while R6 < 108S and R4 \u00ac= 0 do\n            begin  R4 := R4 + R9;  R4 := REFLINK(R4);\n               R3 := R4 shrl 18;  R4 := R4 and R8;\n$IFT M M\n               CVD(R3,CONWORK); B5(0/6) := EDMSK;\n               ED(5,B5,CONWORK(5)); R6 := @B6(6); R5 := @B5(6);\n$END M\n$IFF M M\n               CVD(R3,CONWORK);  UNPK(3,7,B5,CONWORK);\n               SETZONE(B5(3));   R6 := @B6(6);  R5 := @B5(6);\n$END M\n            end;  if R6 \u00ac= 0 then\n            begin  PRINT;  WBUFF(0/133) := BLANK;  goto X;\n            end;  R7 := @B7(REFLEN);\n         end;\n      end;  HEADER(8) := \"OMPILATION    \";\n      LM(R0,R9,SAVE);\n   end;\n\n$END\n$PAGE\n  segment procedure  INSYMBOL(R8);  |-- USES R0 THRU R6 AND R8 --|\n    begin  |-- DEFINE PROCEDURES USED ONLY BY INSYMBOL --|\n\n    segment procedure GETCARD(R4);\n    begin logical SAVE14;   |-- READ NEXT CARD AND CHECK OPTIONS --|\n\n       procedure GETPARM (R14);\n          begin SAVE14:=R14; IC(R0,CBUF(7));\n             R0:=R0 and #F; CLI(\" \",CBUF(8)); if \u00ac= then\n             begin IC(R14,CBUF(8)); R14:=R14 and #F;\n                R0:=R0*10S+R14;\n             end; R14:=SAVE14;\n          end;\n\n       procedure PRNTDOLR (R14); if LISTFLAG then\n$IFT M M\n          if TM(DOLR,FLGS); ON then\n$END M\n$IFF M M\n          if TM(DOLR,FLGS); OFF then WDDISP(5/6) := CBUF else\n$END M\n          begin SAVE14 := R14;  WBUFF(0/WHDRLN+3) := BLANK;\n             WCARD(0/72) := CBUF; WSEQ(0/8) := CBUF(72);\n$IFT M M\n             WLINENUM(0/10) := CBUF(80);\n$END M\n             PRINT;  R14 := SAVE14;\n          end;\n\n          OUTPUTCARD; R0:=BEGENDLVL; CBEGENDLVL:=R0;\n TOP:     R0 := @CBUF; READ; if \u00ac= then\n          begin if \u00acNOPROGSEG then\n             begin R6 := R6-R6; XR := 20; ERROR;\n             end;  ERROREXIT;\n          end; CLI(\"$\",CBUF); if = then\n          begin CLI(\"0\",CBUF(1)); if >= then\n             begin  TRACE(0/1) := CBUF(1);  NI(7,TRACE);\n                TR(0,TRACE,#0001030704050602X);  goto PDC;\n             end; CLI(\"#\",CBUF(4)); if = then\n             begin if NOPROGSEG then\n                begin SEGNAM(0/3) := CBUF(1);  ESDNAME(0/3) := SEGNAM;\n                   ESDNAME(10/3) := SEGNAM;  goto PDC;\n                end;  goto DOLERR;\n             end; R0 := CBUF; if R0 = \"$NOL\" then\n             begin PRNTDOLR; R0 := 1+LIST; LIST := R0; goto TOP;\n$IFT M M\n             end;  if R0 = \"$TES\" then\n             begin  R0 := R0 - R0;\n                if R0 \u00ac= FREESPACE then SET(TESTFLAG);\n                goto PDC;\n$END M\n             end;  if CBUF(1) = \"IF\" then   |-- $IF-STATEMENT --|\n             if CBUF(3) = \"T\" or CBUF(3) = \"F\" or CBUF(3) = \"J\" then\n             begin PRNTDOLR; NI(#3F,CBUF(5)); R14 := R14-R14;\n                IC(R14,CBUF(5));  CLI(\"J\",CBUF(3));\n                if = then goto L;  IC(R14,CONDTAB(R14));\n                STC(R14,CONDCK); CLI(\"F\",CBUF(3));\n                if = then XI(#FF,CONDCK);\n                if CONDCK then goto TOP;\n                NI(#3F,CBUF(7));  IC(R14,CBUF(7));\n            L:  STC(R14,CONDCK);\n            COND: R0 := @CBUF; READ; if \u00ac= then\n                begin if \u00acNOPROGSEG then\n                   begin R6 := R6-R6; XR := 20; ERROR;\n                   end;  ERROREXIT;\n                end; CLC(3,CBUF,\"$END\"); if \u00ac= then goto COND;\n                IC(R0,CBUF(5)); NI(#3F,CBUF(5)); CLC(0,CBUF(5),CONDCK);\n                if \u00ac= then goto COND;  STC(R0,CBUF(5));  goto PDC;\n             end; if R0 = \"$TIT\" then\n             begin if LISTFLAG then CARRCONT := \"1\";\n                HEADER(30/63) := CBUF(9);\n                SUBHEAD(1/93) := SUBHEAD;  goto TOP;\n             end; if R0 = \"$STI\" then\n             begin  if LISTFLAG then CARRCONT := \"1\";\n                SUBHEAD(30/63) := CBUF(9); goto TOP;\n             end; if R0 = \"$PAG\" then\n             begin  R0 := \"$EJE\"; CBUF(0/2) := CBUF(6);\n                CBUF(7/2) := CBUF;\n             end; if R0 = \"$EJE\" then\n             begin GETPARM; if R0 = 0 then R0 := 1000;\n                R0 := R0 + LINECOUNT; if R0 > MAXLINE and LISTFLAG then\n                CARRCONT := \"1\"; goto TOP;\n             end; if R0 = \"$SPA\" and LISTFLAG and LINECOUNT<MAXLINE then\n             begin  logical SAVE0;  GETPARM;\n                if R0 = 0 then R0 := 1;\n             |-- R0 HAS NUMBER OF LINES TO SPACE --|\n                WBUFF(0/133) := BLANK; CLI(\" \",CARRCONT);\n                if \u00ac= then\n                begin SAVE0 := R0; PRINT; R0 := SAVE0 - 1;\n                end; R14 := MAXLINE - LINECOUNT;\n                if R0 >= R14 then CARRCONT := \"1\" else\n                begin  while R0 > 1 do\n                   begin  SAVE0 := R0; CARRCONT := \"0\"; PRINT;\n                      R0 := SAVE0 - 2;\n                   end;  if R0 = 0 then CARRCONT := \" \"\n                                   else CARRCONT := \"0\";\n                end;  goto TOP;\n$IFF\n             end; if R0=\"$XRE\" then\n             begin R0 := R0-R0; if R0 \u00ac= REFSTART then SET(XREF);\n                if CBUF(6) = \"1\" then XREFCC := \" \" else\n                   if CBUF(6) = \"2\" then XREFCC := \"0\";\n                goto PDC;\n             end; if R0 = \"$NOX\" then\n             begin RESET(XREF); goto PDC;\n             end; if R0 = \"$COP\" then\n             begin  external procedure COPY (R14);  null;\n                R0 := @CBUF(6);  COPY;  goto PDC;\n$END\n             end; if R0 = \"$SET\" or R0 = \"$RES\" then\n             begin R14 := R14-R14;  R0 := #FF;\n                CLI(\"R\",CBUF(1));  if = then\n                begin IC(R14,CBUF(7));  R0 := R0-R0;\n                end else IC(R14,CBUF(5));\n                R14 := R14 and #3F;\n                STC(R0,CONDTAB(R14)); goto PDC;\n             end; if R0 = \"$ON \" then\n             begin SB(DOLR,FLGS);  goto PDC;\n             end; if R0 = \"$OFF\" then\n             begin PRNTDOLR; RB(DOLR,FLGS); goto TOP;\n             end; if R0 = \"$GEN\" then\n             begin RESET(GENFLAG);  goto PDC;\n             end; if R0 = \"$OPT\" then\n             begin SB(#80,OPTFLAG);  goto PDC;\n             end; if R0 = \"$NOO\" or R0 = \"$NOP\" then\n             begin RB(#80,OPTFLAG);  goto PDC;\n             end; if R0 = \"$DBG\" then\n             begin DBGFLGS(0/1) := CBUF(5) and 7; goto PDC;\n             end; if R0 = \"$LIS\" then\n             begin R0 := LIST-1; LIST := R0; goto PDC;\n             end; if R0 = \"$OS \" then\n             begin SET(OSSYSTEM);  goto PDC;\n             end; if R0 = \"$DOS\" then\n             begin RESET(OSSYSTEM);  goto PDC;\n             end; if R0 = \"$BOL\" then\n             begin  OVER := #80;  goto PDC;\n             end; if R0 = \"$UND\" then\n             begin  OVER := #C0;  goto PDC;\n             end; if R0 = \"$NOU\" or R0 = \"$NOB\" then\n             begin  RESET(OVER);  goto PDC;\n             end; if R0 = \"$NOG\" then\n             begin SB(NOGO,FLGS); goto PDC;\n             end; if R0 = \"$ASC\" then\n             begin SB(ASCI,FLGS); goto PDC;\n             end; if R0 = \"$BAS\" then\n             begin  R14 := CARDCOUNT;  if R14 = 0 then\n                begin PACK(7,1,CONWORK,CBUF(6));\n                   OI(#0C,CONWORK(7));  CVB(R0,CONWORK);\n                   if R0 \u00ac= 0 and R0 <= 15 then\n                   begin PROGREG := R0; R0 := R0 shll 12;\n                      PTAG := R0;  goto PDC;\n                   end;\n                end;  goto DOLERR;\n             end;\n    PDC:     PRNTDOLR; goto TOP;\n    DOLERR:  WBUFF(0/WHDRLN+3) := BLANK;  WCARD(0/72) := CBUF;\n             WSEQ(0/8) := CBUF(72);  WBUF(2) := \"ILLEGAL $CARD\";\n             R0 := 1 + ERRCOUNT =: ERRCOUNT;  RESET(RUNFLAG);\n             PRINT;  goto TOP;\n          end;  R6 := R6-R6;  if BEGENDFLAG then\n          begin  R0:=CBEGENDLVL;  CVD(R0,CONWORK);\n             UNPK(1,7,WBGNEND,CONWORK);\n             SETZONE(WBGNEND(1)); RESET(BEGENDFLAG);\n          end else WBGNEND := \"  \";  PRNT := LISTFLAG;\n          R1 := DATAESDADR; R1 := PL360NO(R1);\n          CVD(R1,CONWORK); UNPK(2,7,WDSEG,CONWORK);\n          UNPK(4,4,WDDISP,DC); TR(3,WDDISP,TRTABLE(_240));\n          SETZONE(WDSEG(2));  WDDISP(4) := \" \";\n          R0 := CSEGNO; CVD(R0,CONWORK); UNPK(2,7,WPSEG,CONWORK);\n          UNPK(4,4,WPDISP,LC); TR(3,WPDISP,TRTABLE(_240));\n          SETZONE(WPSEG(2));  WPDISP(4) := \" \";\n          R1 := 1 + CARDCOUNT; CARDCOUNT := R1; CVD(R1,CONWORK);\n$IFT M M\n          WCRDCNT(0/6) := EDMSK;  ED(5,WCRDCNT,CONWORK(5));\n          ERRWCRDCNT(0/6) := WCRDCNT;  ERRORBUF(0/10) := CBUF(80);\n$END M\n$IFF M M\n          UNPK(3,7,WCRDCNT,CONWORK);  SETZONE(WCRDCNT(3));\n          R1 := 10 * R0;  R1 := @ESDNAME(R1);  SUBHEAD(113/8) := B1;\n$END M\n          if TM(#80,OVER); ON then  |-- ESTABLISH OVERPRNT BUFFER --|\n          begin  RESET(OBUF);  OBUF(1/71) := OBUF;\n          end;\n    end;\n\n    procedure NEXTCHAR(R4);\n    begin R6 := @B6(1); if R6 > 71S then\n       begin array 4 integer SAVER1R4;\n          STM(R1,R4,SAVER1R4); GETCARD; LM(R1,R4,SAVER1R4);\n       end;\n       R0 := R0-R0; IC(R0,CBUF(R6));\n    end;\n\n    |-- BEGIN INSYMBOL --|\n TOP:  R2 := 71 - R6; R1 := @CBUF(R6); EX(R2,TRT(0,B1,SCANTAB2));\n       if = then\n       begin GETCARD; goto TOP;\n       end;\n       R0 := @CBUF; R6 := R1 - R0; R0 := R0-R0; IC(R0,CBUF(R6));\n       VALUE(0/12) := BLANK;\n       if R2 < 10S then\n       case R2 of begin  |-- R2 HAS CODE FOR TYPE OF SYMBOL --|\n\n       begin  |-- CODE 1 -- READ A NUMBER --|\n          procedure ACCUM (R4);  |-- ACCUMULATE A DIGIT --|\n          begin logical SAVE4; SAVE4 := R4;\n             if R2 >= 214748364 then R1 := R1 + 1 else\n             begin R0 := R0 and #F; R4 := R2; R5 := R3;\n                SLDL (R4, 1); SLDL (R2, 3); R2 := R2 + R4;\n                R3 := R3 ++ R5; if > or OVERFLOW then R2 := R2 + 1;\n                R3 := R3 ++ R0; if > or OVERFLOW then R2 := R2 + 1;\n             end; NEXTCHAR; R4 := SAVE4;\n          end;\n          XC (7, VALUEF, VALUEF);  |-- CLEAR IN CASE INTEGER --|\n          RESET (SIGN); if R0 = \"_\" then\n          begin SET (SIGN); NEXTCHAR; if R0 < \"0\" or R0 > \"9\" then\n             begin XR := 0; ERROR; goto TOP; end; end;\n          TYPEFLAG := 1; R2 := R2 - R2; R3 := R0 and #F; NEXTCHAR;\n          R1 := R2; while R0 >= \"0\" and R0 <= \"9\" do ACCUM;\n       |-- WE ARE OVER THE INITIAL STRING OF DIGITS --|\n          if R0 = \".\" then\n          begin  |-- A DECIMAL POINT HAS BEEN FOUND --|\n             TYPEFLAG := 3; NEXTCHAR;\n             while R0 >= \"0\" and R0 <= \"9\" do\n             begin R1 := R1 - 1; ACCUM; end;\n          end;  |-- END OF DECIMAL POINT PROCESSING --|\n          if R0 = \"'\" then  |-- IS THERE AN EXPONENT? --|\n          begin NEXTCHAR; RESET (EXPOSIGN); TYPEFLAG := 3;\n             if R0 = \"_\" then begin SET (EXPOSIGN); NEXTCHAR; end;\n             if R0 < \"0\" or R0 > \"9\" then begin XR := 14; ERROR; end;\n             R5 := R5 - R5; while R0 >= \"0\" and R0 <= \"9\" do\n             begin R0 := R0 and #F; if R5 < 214748364 then\n                R5 := R5 * 10S + R0; NEXTCHAR; end;\n             if EXPOSIGN then R1 := R1 - R5 else R1 := R1 + R5;\n          end;  |-- CORRECT EXPONENT NOW IN R1 --|\n          R5 := #40 or R0;  |-- Force upper case --|\n          if TYPEFLAG = 1 and R5 = \"S\" then\n          begin TYPEFLAG := 0; NEXTCHAR;\n          end else if TYPEFLAG = 1 and R5 = \"X\" then\n          begin TYPEFLAG := 4; NEXTCHAR;\n          end else if R5 = \"L\" then\n          begin TYPEFLAG := 2; NEXTCHAR;\n          end else if R5 = \"R\" then\n          begin TYPEFLAG := 3; NEXTCHAR;\n          end; XR := 19;  |-- ONLY OVERFLOWS POSSIBLE NOW --|\n          if TYPEFLAG \u00ac= 2 and TYPEFLAG \u00ac= 3 then  |-- INTEGER CASE --|\n          begin if R2 \u00ac= 0 then ERROR\n             else if R3 < 0 then if \u00acSIGN then ERROR\n             else if R3 \u00ac= #80000000 then ERROR;\n             if SIGN then R3 := neg R3;\n             if TYPEFLAG = 0 then\n             begin if R3 > 32767S or R3 < _32768S then\n                begin ERROR; R3 := R3 shll 16 shra 16; end;\n             end else if TYPEFLAG = 4 then\n             begin if R3 < 0 or R3 > 255S then\n                begin ERROR; R3 := R3 and #000000FF; end;\n             end;\n             VALUE := R3;\n          end else\n          begin  |-- REAL OR LONG REAL --|\n             long real FIRST = #5600000000000000L,\n                       SECOND = #4E00000000000000L;\n             integer LEFT syn FIRST (4), RIGHT syn SECOND (4);\n             long real FACT syn B4;\n             long real TEN = 10L, MILLION = 1000000L;\n             byte SCALED syn EXPOSIGN;\n             long real X syn VALUEF;\n          procedure SCALEUP (R5);\n          begin R15 := R15 or #FF000000; DRAIN; F45 := F45 - F45;\n             F4 := neg F0; F45 := F45 + F01; F23 := F23 + F45;\n             F01 := F01 - F45 * FACT; F23 := F23 * FACT; DRAIN;\n             if R15 > 0 then  |-- SET BY PROGCHECK ROUTINE --|\n             begin R1 := R1 - R1; F01 := #7FFFFFFFFFFFFFFFL;\n                F23 := F23 - F23; ERROR;\n             end;  R15 := R15 and #00FFFFFF;\n          end;\n          procedure SCALEDOWN (R5);\n          if F01 = 0L and F23 = F01 then\n          R1 := R1 - R1   |-- UNDERFLOW --|  else\n          begin X := F01; F01 := F01 / FACT; F67 := F67 - F67;\n             F6 := F0; F45 := neg F67 + F01 * FACT;\n             F67 := F67 * FACT - X + F45;\n             F23 := F23 - F67 / FACT;\n          end;\n             LEFT := R2; F01 := FIRST + 0L; RIGHT := R3;\n             F23 := SECOND + 0L; F45 := F01; F01 := F01 + F23;\n             if \u00ac= then  |-- NOT ZERO --|\n             begin F45 := F45 - F01; F23 := F23 + F45; RESET (SCALED);\n                if R1 < 0 then begin SET (SCALED);\n                   F01 := F01 / #3310000000000000L;\n                   F23 := F23 / #3310000000000000L;\n                end; R4 := @MILLION;  |-- SCALE UP BY 10**6 --|\n                while R1 >= 6 do begin R1 := R1 - 6; SCALEUP; end;\n                R4 := @TEN;  |-- SCALE UP BY 10 --|\n                while R1 >= 1 do begin R1 := R1 - 1; SCALEUP; end;\n                R4 := @MILLION;  |-- SCALE DOWN BY 10**6 --|\n                while R1 <= _6 do begin R1 := R1 + 6; SCALEDOWN; end;\n                R4 := @TEN;  |-- SCALE DOWN BY 10 --|\n                while R1 <= _1 do begin R1 := R1 + 1; SCALEDOWN; end;\n                 |-- NOW ROUND TO LONG REAL --|\n                F45 := neg F01 - F23; F01 := F01 + F45 + F23;\n                F0 := F0 + F0; F01 := F01 - F45;\n                if SCALED then F01 := F01 / #4F10000000000000L;\n                if F01 = 0L then ERROR;  |-- UNDERFLOW --|\n             end;\n             VALUEF := F01;  |-- STORE LONG REAL VALUE --|\n             if TYPEFLAG = 3 then  |-- ROUND TO REAL --|\n             if F01 >= #7FFFFFFF80000000L then\n             begin ERROR;  VALUEF(0/8) := #7FFFFFFF00000000L;\n             end else\n             begin XC (2, VALUEF (1), VALUEF (1));\n                F01 := F01 + VALUEF; VALUEF := F01;\n                XC (3, VALUEF (4), VALUEF (4));\n             end;  |-- END OF ROUNDING ROUTINE --|\n             if SIGN then OI (#80, VALUEF);\n          end;\n          R5 := NUMBERSYMBOL;\n       end;\n\n       begin  |-- CODE 2 -- READ AN IDENTIFIER --|\n          R3 := @OBUF(R6);  |-- ID START FOR OVERPRNT --|\n          R2-R2; while R0>=\"a\" or R0=\"_\" or R0=\"$\" or R0=\"#\" do\n          begin if R2 < 10S then  |-- Allows certain nationals --|\n             begin  R1 := #40 or R0;  STC(R1,VALUE(R2));  R2 := @B2(1);\n             end;  if R6 = 71S then\n             begin  R6 := @B6(1);  R0 := \" \";\n             end else NEXTCHAR;\n          end;\n          SYMTYPE := R2;\n          if R2 < 10S then case R2 of\n          begin  |-- CHECK FOR RESERVED WORDS OF LENGTH R2 --|\n             begin  |-- NO TERMINALS OF LENGTH ONE --|\n             end;\n             begin R1 := IVALUE; for R5 := R5--R5 step 2S until 6S do\n                if R1 = WORD2(R5) then\n                begin  B3(0/2) := OMSK;\n                   R5 := R5 shrl 1 + FT2; goto Y;\n                end;  |-- TERMINALS OF LENGTH TWO --|\n             end;\n             begin R1 := VALUE; for R5 := R5-R5 step 4S until 16S do\n                if R1 = WORD3(R5) then\n                begin  B3(0/3) := OMSK;\n                   R5:=R5 shrl 2 + FT3; R2:=ENDSYMBOL-R5; if = then\n                   begin SET(BEGENDFLAG);R2:=BEGENDLVL-1; BEGENDLVL:=R2;\n$IFT M M\n                   if TESTFLAG then\n                   begin  R0 := LC;\n                      R4 := R8;  R1 := 4;\n                      ENTERSYMLABEL;  R8 := R4;\n                   end;\n$END M\n                   end; goto Y;\n                end;  |-- TERMINALS OF LENGTH THREE --|\n             end;\n             begin R1 := VALUE; for R5 := R5-R5 step 4 until 40 do\n                if R1 = WORD4(R5) then\n                begin  B3(0/4) := OMSK;\n                   R5 := R5 shrl 2 + FT4; goto Y;\n                end; for R5 := R5-R5 step 4 until 12 do\n                if R1 = SHIFTWORD(R5) then\n                begin  B3(0/4) := OMSK;\n                   R5 := R5 shrl 2 + 8S; VALUE := R5;\n                   R5 := SHIFTOP; goto Y;\n                end;  |-- TERMINALS OF LENGTH FOUR --|\n             end;\n             begin R1 := @WORD5; R2 := @WORD6; R5 := R1;\n                while R5 < R2 do\n                begin  if VALUE(0/5) = B5 then\n                   begin  B3(0/5) := OMSK; R5:=R5-R1 shrl 3 + FT5;\n                      R2:=BEGINSYMBOL; if R5 \u00ac= R2 then goto Y;\n                      SET(BEGENDFLAG); R2:=1+BEGENDLVL; BEGENDLVL:=R2;\n$IFT M M\n                      if TESTFLAG then\n                      begin  R0 := LC;  R1 := 2;  R4 := R8;\n                         ENTERSYMLABEL;  R8 := R4;\n                      end;\n$END M\n                      goto Y;\n                   end;  R5 := @B5(8);\n                end;  |-- TERMINALS OF LENGTH FIVE --|\n             end;\n             begin R1 := @WORD6; R2 := @WORD7; R5 := R1;\n                while R5 < R2 do\n                begin  if VALUE(0/6) = B5 then\n                   begin  B3(0/6) := OMSK;\n                      R5:=R5-R1 shrl 3 + FT6; goto Y;\n                   end;  R5 := @B5(8);\n                end;  |-- TERMINALS OF LENGTH SIX --|\n             end;\n             begin  if VALUE = \"COMMENT\" then\n                begin  B3(0/7) := OMSK;  if R6 > 71S then NEXTCHAR;\n                   SCANTAB1(#5E) := 1;  |-- Look for semicolon --|\n                   R1 := @CBUF(R6); R2 := 71 - R6;\n COMLOOP:          EX(R2,TRT(0,B1,SCANTAB1)); if = then\n                   begin GETCARD; R2 := 71; R1 := @CBUF; goto COMLOOP;\n                   end else if > then GETCARD else\n                   begin R0 := @CBUF(_1); R6 := R1 - R0;\n                   end;  RESET(SCANTAB1(#5E));  goto TOP;\n                end; R1 := @WORD7; R2 := @WORD8; R5 := R1;\n                while R5 < R2 do\n                begin  if VALUE(0/7) = B5 then\n                   begin  B3(0/7) := OMSK;\n                      R5 := R5-R1 shrl 3 + FT7; goto Y;\n                   end;  R5 := @B5(8);\n                end;  |-- TERMINALS OF LENGTH SEVEN AND COMMENT --|\n             end;\n             begin R1 := @WORD8; R2 := @WORD9; R5 := R1;\n                while R5 < R2 do\n                begin  if VALUE(0/8) = B5 then\n                   begin  B3(0/8) := OMSK;\n                      R5 := R5-R1 shrl 3 + FT8; goto Y;\n                   end;  R5 := @B5(8);\n                end;  |-- TERMINALS OF LENGTH EIGHT --|\n             end;\n             begin  if VALUE(0/9) = WORD9 then\n                begin  B3(0/9) := OMSK;\n                   R5 := FT9; goto Y;\n                end;  if VALUE(0/9) = WORD9(12) then\n                begin  B3(0/9) := OMSK;\n                   R5 := 1 + FT9; goto Y;\n                end;  |-- TERMINALS OF LENGTH NINE --|\n             end;\n          end; R5 := IDENTSYMBOL;\n Y:       if R6 > 71S then NEXTCHAR;\n       end;\n\n       begin  |-- CODE 3 -- READ HEXADECIMAL NUMBER --|\n          R1 := R1-R1; R2 := R1; R3 := R1; NEXTCHAR;\n X:       R5 := #40 or R0;  |-- Force upper case --|\n          if R0 >= \"0\" then R5 := R5 - 240 else\n          if R5<\"A\" or R5>\"F\" then goto Y else R5 := R5 - 183S;\n          SLDL(R2,4); R3 := R3 or R5; NEXTCHAR; R1 := R1+1; goto X;\n Y:       if R1 = 0 or R1 > 16 then\n          begin XR := 25;  ERROR;  R1 := 1;\n          end;  if R5 = \"X\" then\n          begin R1 := R1 + 1 shrl 1;  STM(R2,R3,VALUE);\n             R2 := 8 - R1;  R2 := @VALUE(R2);\n             STRINGV(0/8) := B2;  VALUE := R1;\n             R5 := STRNGADR;  ADR(R5+2) := R1;\n             NEXTCHAR;  R5 := STRNGSYMBOL;  goto Z;\n          end;  if R5 = \"L\" then\n          begin R1 := 2; STM(R2,R3,VALUE); NEXTCHAR;\n          end else\n          begin VALUE := R3; VALUE(4):= R2;\n             if R5 = \"S\" then\n             begin R1 := R1-R1; NEXTCHAR;\n             end else\n             if R5 = \"R\" then\n             begin R1 := 3; NEXTCHAR;\n             end else R1 := 1;\n          end; R5 := NUMBERSYMBOL; SYMTYPE := R1;\n Z:    end;\n\n       begin  |-- CODE 4 -- READ STRING --|\n          R0 := \"\"\"\";  VALUE := R0;  R2 := R2-R2;\n X:       NEXTCHAR; if R0 = VALUE then\n          begin NEXTCHAR; if R0 \u00ac= VALUE then goto Y;\n          end;  if R0 = #79 then  |-- Accent (`) escape --|\n          begin  |-- Process accent (`) escape --|\n              array DATAFILL byte ESCTABLE = (\n             |   ,  A,  B,  C,  D,  E,  F,  G,|\n              #40,#01,#02,#03,#37,#2D,#2E,#2F,\n             |  H,  I,  \u00a2,  .,  <,  (,  +,   ,|\n              #16,#05,#35,#1E,#1F,#1B,#1C,#40,\n             |  &,  J,  K,  L,  M,  N,  O,  P,|\n              #0A,#25,#0B,#0C,#0D,#0E,#0F,#10,\n             |  Q,  R,  !,  $,  *,  ),  ;,  \u00ac,|\n              #11,#12,#04,#14,#15,#2B,#55,#FA,\n             |  \\,  /,  S,  T,  U,  V,  W,  X,|\n              #22,#07,#13,#3C,#3D,#32,#26,#18,\n             |  Y,  Z,   ,   ,  %,  \u00dd,  >,  ?,|\n              #19,#3F,#40,#40,#17,#27,#28,#09,\n             |  0,  1,   ,   ,   ,   ,   ,   ,|\n              #20,#21,#40,#40,#40,#40,#40,#40,\n             |   ,  `,  :,  #,  @,  \u00a8,  =,  \",|\n              #40,#79,#08,#09,#00,#1D,#2C,#7F);\n             NEXTCHAR;  R4 := #3F and R0;  IC(R0,ESCTABLE(R4));\n          end; if R2 < 256S then STC(R0,STRINGV(R2)) else\n          begin R2 := R2-R2; XR := 21; ERROR;\n             R0 := \";\";  VALUE := R0;\n          end; R2 := R2 + 1; goto X;\n Y:       if R2 = 0 then begin XR := 21; ERROR; end else\n          if TM(ASCI,FLGS); ON then  |-- ASCII conversion --|\n          begin  segment base R5;  array 256 byte ASCIITAB =\n             | 0 1 2 3 4 5 6 7    8 9 A B C D E F |\n            (#000102037F097F7FX,#7F7F7F0B0C0D0E0FX,  | 00 |\n             #101112137F0A087FX,#18197F7F7F7F7F7FX,  | 10 |\n             #1F1D1C7F7F0A171BX,#7F7F7F7F7F050607X,  | 20 |\n             #7F7F167F7F1E7F04X,#7F7F7F7F14157F1AX,  | 30 |\n             #207F7F7F7F7F7F7FX,#7F7F5E2E3C282B7CX,  | 40 |\n             #267F7F7F7F7F7F7FX,#7F7F21242A293B7EX,  | 50 |\n             #2D2F7F7F7F7F7F7FX,#7F7F7C2C255F3E3FX,  | 60 |\n             #7F7F7F7F7F7F7F7FX,#7F603A2340273D22X,  | 70 |\n             #7F61626364656667X,#68697F7B7F7F7F7FX,  | 80 |\n             #7F6A6B6C6D6E6F70X,#71727F7D7F7F7F7FX,  | 90 |\n             #7F7E737475767778X,#797A7F7F7F5B7F7FX,  | A0 |\n             #7F7F7F7F7F7F7F7FX,#7F7F7F7F7F5D5C7FX,  | B0 |\n             #7B41424344454647X,#48497F7F7F7F7F7FX,  | C0 |\n             #7D4A4B4C4D4E4F50X,#51527F7F7F7F7F7FX,  | D0 |\n             #5C7F535455565758X,#595A7F7F7F7F7F7FX,  | E0 |\n             #3031323334353637X,#38397F7F7F7F7F7FX); | F0 |\n             R4 := R2;  REDUCE(R4);    |-- Len-1 --|\n             EX(R4,TR(0,STRINGV,B5));  |-- Translate --|\n          end;  R5 := STRNGADR;  ADR(R5+2) := R2;\n          VALUE := R2; R5 := STRNGSYMBOL;\n       end;\n\n       begin  |-- CODE 5 -- ILLEGAL CHARACTER --|\n          XR := 14; ERROR ; NEXTCHAR; goto TOP;\n       end;\n\n       begin  |-- CODE 6 -- SHORT COMMENT || --|\n          R1 := R0;  STC(R1,SCANTAB1(R1));\n          NEXTCHAR; R1 := @CBUF(R6); R2 := 71 - R6;\nCOMLOOP:  EX(R2,TRT(0,B1,SCANTAB1)); if = then\n          begin GETCARD; R2 := 71; R1 := @CBUF; goto COMLOOP;\n          end else if > then GETCARD else\n          begin R0 := @CBUF(_1); R6 := R1 - R0;\n          end; RESET(SCANTAB1(#4F)); RESET(SCANTAB1(#6A)); goto TOP;\n       end;\n\n       begin  |-- CODE 7 -- END OF LINE COMMENT $ ... --|\n          GETCARD;  goto TOP;\n       end;\n\n       end else\n       begin  |-- CODE >= 10 -- SPECIAL SYMBOL --|\n          array 15 integer TOPS=(\n          #00000000,#4E02A02E,#6002B02F,#7A160020,\n          #7E04B043,#7E04D045,#7E060049,#00080000,\n          #000A0000,#FF02C000,#FF02D000,#7E0C0140,\n          #000E0000,#7C100101,#00120000);\n          NEXTCHAR;\n          R2:=R2+R2; R2:=TOPS(R2-20); SRDL(R2,24); if R2\u00ac=0 then\n          begin while R0=\" \" do NEXTCHAR; if R2=R0 then\n             begin R3:=R3 shll 12; NEXTCHAR;\n             end; R2:=R3 shrl 20 and #F; VALUE:=R2; R2:=R2-R2;\n          end; SLDL(R2,8); R5:=OPS(R2);\n       end;\n    end;\n$PAGE\n segment procedure PROCCALL(R1);\n    begin integer SAVER1,RETREG; short integer VH syn V;\n       RETREG:=R0; SAVER1:=R1; R4:=VH(R7) shrl 8 and #FF;\n       R5:=LC; if R4\u00ac=CSEGNO then\n       begin R2:=VH(R7) and #F0 + #5800S; PROGRAM(R5):=R2;\n          R0:=PROGESDEND; R1:=PROGESDADR; R2:=ER; R3:=VTYPE;\n          FINDESDENTRY; PROGESDEND:=R0; R0:=RLDADDR(R1);\n          PROGRAM(R5+2):=R0; RLDADDR(R1):=R5; R5:=@B5(4);\n       end;\n       R3:=VH(R7+2); if R3=0 then\n       begin R2:=VH(R7) and #FF; SRDL(R2,4); R3:=R3 shrl 24 or R2+#500S;\n          PROGRAM(R5):=R3; R5:=@B5(2);\n       end else\n       begin R2:=VH(R7) and #F0 shll 8 + R3; PROGRAM(R5+2):=R2;\n          R3:=VH(R7) and #F shll 4 + #4500S;\n          PROGRAM(R5):=R3; R5:=@B5(4);\n       end;\n       R3:=PBREG; R0:=RETREG; R2:=VH(R7) and #F;\n       if R0\u00ac=16S then\n       begin R2:=R3; R3:=R3 shll 4; R1:=@B3(#500); PROGRAM(R5+2):=R1;\n          R1:= VH(R7) shrl 4 and #F; R0:=R0 shll 4 or R1 + #1200S;\n          PROGRAM(R5):=R0;  R5:=@B5(4);\n       end else\n       if R4=CSEGNO then goto Y;\n       R1:=PROGESDADR; R3:=PBREG shll 4 + #5800S + R2;\n       PROGRAM(R5):=R3; R2:=RLDADDR(R1); PROGRAM(R5+2):=R2;\n       RLDADDR(R1):=R5; R5:=@B5(4);\n  Y:   LC:=R5; R1:=SAVER1;\n$IFT D D\n       if TM(4,DBGFLGS); ON then SET(PRNT);\n$END D\n    end;\n$PAGE\n  |--  ***************  EXECUTE  *************** --|\n segment procedure EXECUTE (R4);\n\n begin  integer SAVE, SAVE2;\n array 5 integer SAVEREG;  |-- USED BY THE EXECUTE PROCEDURES --|\n equate XEQ0 syn 46,            |-- NULL PROCESSES --|\n        XEQ1 syn XEQ0 + 43,     |-- EXECUTE1'S RULES --|\n        XEQ2 syn XEQ1 + 09,     |-- EXECUTE2'S RULES --|\n        XEQ3 syn XEQ2 + 61,     |-- EXECUTE3'S RULES --|\n        XEQ4 syn XEQ3 + 48;     |-- EXECUTE4'S RULES --|\n\n segment procedure EXECUTE1(R4);   |-- RULES <= XEQ1 --|\n   begin  |-- LOCAL PROCEDURE FOLLOWS --|\n\n    procedure ASSCELL (R4);\n    begin SAVE := R4;\n       R0 := T2(R7); R1 := R0 shll 2 + T(R7); R1 := @TYPETABLE(R1);\n       CLI(0,B1); if = then begin XR := 3; ERROR; end;\n       R0 := R0 + 4; R1 := 8; R2 := V(R7);\n       R3 := V2(R7); EMYT; R4 := SAVE;\n    end;\n\n    procedure TCELLNUM (R4);\n    begin SAVE := R4;\n       R0 := V1(R7); R1 := V2(R7); R2 := T2(R7);\n       if R2 > 1 then begin XR := 25; ERROR; goto X; end;\n       R2 := V(R7+4);  if R0 = 11S then R1 := neg R1 else\n       if R0 \u00ac= 10S then\n       begin XR := 0;  if R0 = 13S and R2 = 0 and\n             R1 > 0 then V(R7+4) := R1\n          else ERROR;  goto X;\n       end;  if R2 \u00ac= 0 then\n       begin R1 := R1 + R2;  if <= then\n          begin XR := 24;  ERROR;\n          end else V(R7+4) := R1;  goto X;\n       end; R2 := V(R7); SRDL(R2,12); R3 := R3 shrl 20 + R1;\n       if R3>4095S or R3<0 then begin XR := 18; ERROR; goto X; end;\n       R2 := R2 shll 12 or R3; V(R7) := R2;\n   X:  R4 := SAVE;\n    end;\n\n    procedure ASSTNUM (R4);\n    begin SAVE := R4;\n       R2 := T2(R7); R1 := R2 shll 2 + T(R7); R1 := @TYPETABLE(R1);\n       CLI(0,B1); if = then begin XR := 3; ERROR; end;\n       R3 := V2(R7); if R2<2 and R3<4096S and R3>=0 then\n       begin R0 := 4; R1 := 1; R2 := V(R7); EMYT;\n       end else\n       begin R1 := R1-R1; IC(R1,ALENGTH(R2)); IC(R0,LENGTH(R2));\n          R2 := 2 + LC; R3 := @V2(R7);\n          MAKELITERAL; R0 := 4 + T2(R7); R1 := 8;\n          R2 := V(R7); R3 := R3-R3; EMYT;\n       end; R4 := SAVE;\n    end;\n\n    procedure NEWUNARY (R4);\n    begin  V2(R7/2) := V(R7+2);  V(R7/18) := V1(R7);\n    end;\n\n    procedure OLDUNARY (R4);\n    begin  byte VC syn V, VC2 syn V(32);\n       R1 := R1 -- R1;  R0 := V(R7);\n       IC(R1,VC2(R7));  R2 := @VC2(R7+R1+1);\n       if VC(R7+3) = 6 or VC(R7+3) = 4 or C2 = 6 or C2 = 4 then\n       begin  R1 := @B1(1);  STC(R1,VC2(R7));  R2 := @B2(1);\n       end else if VC(R7+3) = 3 then\n       begin  C2 := C2 xor #01X;  goto X;\n       end;  STC(R0,C2);\n    X: R1 := @B1(17);  EX(R1,MVC(0,V(R7),V1(R7)));\n    end;\n\n    procedure ASSUNOP (R4);\n    begin  byte VC syn V(48), OPCD syn B4;  SAVE := R4;\n       R0 := T2(R7);  R1 := R0 shll 2 + T(R7);\n       R1 := @TYPETABLE(R1);  if C1 = 0 then\n       begin  XR := 3;  ERROR;  end;  R4 := R4 -- R4;\n       R2 := V(R7);  R3 := V2(R7);  IC(R4,VC(R7));\n       R4 := @VC(R7+R4+2);  SET(OPCD);  |-- End signal --|\n       R4 := @VC(R7+1);  while \u00acOPCD do  |-- For all ops --|\n       begin  if OPCD = 6 then |-- DEC (aka BCTR) --|\n          begin  if R0 \u00ac= 1S then begin  XR := 7;  ERROR;  end;\n             if R2 \u00ac= R3 then begin  R1 := 8;  EMIT;  end;\n             R0 := R0 -- R0 =: R3;  |-- White lie --|\n          end else if OPCD = 4 then  |-- HALF (aka HDR and HER) --|\n          if R0 = 1S then begin  XR := 7;  ERROR;  end;\n          R1 := R1 -- R1;  IC(R1,OPCD);  EMIT;\n          R0 := T(R7);  R3 := R2;  R4 := @B4(1);\n       end;  R4 := SAVE;\n    end;\n\n    procedure ADRSOP (R5);  |-- ASSIGN <ADR OP> REGISTER --|\n    begin  SAVE := R5;  if = then REDUCE(R3) else\n       begin  R5 := R2 shll 12 or R3 =: R3 shrl 16;\n          if R2 = 0 or R2 = R5 then  |-- INVALID --|\n          begin  XR := 0;  ERROR;  R3 := R3-R3;\n             REDUCE(R3);   goto XIT;\n          end;  |-- LOAD ASSIGNMENT REGISTER --|\n       end;  SAVE2 := R3;  R3 := VTYPE;  R5 := LC;\n       R2 := @B2(#580) shll 4 =: PROGRAM(R5);  R2 := R0;\n       R1 := PROGESDADR;  R0 := PROGESDEND;  FINDESDENTRY;\n       PROGESDEND := R0;  R0 := RLDADDR(R1) =: PROGRAM(R5+2);\n       RLDADDR(R1) := R5;  R5 := @B5(4) =: LC;  R3 := SAVE2;\n  XIT: R2 := V(R7);  R5 := SAVE;\n    end;\n$PAGE\n    procedure STRTOINT (R4);  |- Convert <STRING> to <T NUM> -|\n    begin  SAVE := R4;\n       R3 := STRINGV;  R1 := 4 - V2(R7);  if < then\n       begin  XR := 21;  ERROR;  |- Invalid length -|\n       end else  |- Valid string length -|\n       for R2 := 1 step 1 until R1 do R3 := R3 shrl 8;\n       V2(R7) := R3;  T2(R7) := 1;  |- integer type -|\n       R4 := SAVE;\n    end;\n\n    procedure INDXTNUM (R4);  |- Start index with integer -|\n    begin  SAVE := R4;\n       R1 := V1(R7); R2 := T1(R7);\n       if R2 > 1 then begin XR := 0; ERROR; goto X; end;\n       R2 := V(R7); SRDL(R2,12); R3 := R3 shrl 20 + R1;\n       if R3>4095S or R3<0 then begin XR := 18; ERROR; goto X; end;\n       R2 := R2 shll 12 or R3; V(R7) := R2;\n    X: R4 := SAVE;\n    end;\n\n    procedure ARITHNUM (R4);  |- Do arith with number -|\n    begin  SAVE := R4;\n       R1 := R1-R1;\n       R2 := T2(R7); IC(R1,ALENGTH(R2)); IC(R0,LENGTH(R2));\n       R2 := 2 + LC; R3 := @V2(R7); MAKELITERAL;\n       XR := 4; R1 := V1(R7); R0 := T2(R7);\n       if R1 = 0 then begin ERROR; R1 := 8; end;\n       R2 := R0 shll 2 + T(R7); R2 := @TYPETABLE(R2);\n       CLI(0,B2);  if = then ERROR else\n       if R1>=13S and R0=0 then ERROR;\n       R2 := V(R7); if R0=1 then if R1=12S or R1=13S then\n       begin R2 := R2 and #E;  |-- ODD REGISTER MUST BE SPECIFIED --|\n          if R2=V(R7) then begin XR := 7; ERROR; end;\n       end;\n       R0 := R0 + 4; R3 := R3-R3; EMYT;\n       R4 := SAVE;\n    end;\n\n    procedure LOGTNUM (R4);  |- Do logical operator with number -|\n    begin  SAVE := R4;\n       R1 := R1-R1; R2 := T2(R7); if R2 = 0 then R2 := 1;\n       IC(R1,ALENGTH(R2)); IC(R0,LENGTH(R2));\n       R2 := 2 + LC; R3 := @V2(R7); MAKELITERAL;\n       R0 := 1; if R0\u00ac=T(R7) or R0\u00ac=T2(R7) then\n       begin XR := 4; ERROR; end;\n       R0 := 5; R1 := V1(R7); R2 := V(R7); R3 := R3-R3; EMYT;\n       R4 := SAVE;\n    end;\n$PAGE\n          |-- ********* THE FOLLOWING ARE NULL PROCESSES ********** --|\n          |- <T CELL>     ::= <T CELL ID> -|\n          |- <T CELL>     ::= <T CELL1> ) -|\n          |- <T CELL>     ::= <T CELL2> ) -|\n          |- <T CELL3>    ::= <T CELL ID> ( -|\n          |- <FUNC2>      ::= <FUNC1> , -|\n          |- <PROC1>      ::= <PROC ID> ( -|\n          |- <SIMPLE ST>  ::= <K REG ASS> -|\n          |- <SIMPLE ST>  ::= <CELL ST> -|\n          |- <SIMPLE ST>  ::= NULL -|\n          |- <SIMPLE ST>  ::= <PROC2> ) -|\n          |- <GOTO ST>    ::= <GOTO ST*> -|\n          |- <STATEMENT-> ::= <SIMPLE ST> -|\n          |- <STATEMENT*> ::= <STATEMENT-> -|\n          |- <STATEMENT>  ::= <STATEMENT*> -|\n          |- <REP LIST1>  ::= <REP LIST2> , -|\n          |- <REP LIST2>  ::= <REP LIST1><FILL> -|\n          |- <T DECL2>    ::= <T DECL4> , -|\n          |- <T DECL4>    ::= <T DECL1> -|\n          |- <FUNC DC1>   ::= FUNCTION -|\n          |- <FUNC DC1>   ::= <FUNC DC7> , -|\n          |- <FUNC DC3>   ::= <FUNC DC2> ( -|\n          |- <FUNC DC5>   ::= <FUNC DC4> , -|\n          |- <FUNC DC7>   ::= <FUNC DC6> ) -|\n          |- <SYN DC3>    ::= <SYN DC2> , -|\n          |- <PROC HD2>   ::= <PROC HD1> ( -|\n          |- <PROC HD4>   ::= <PROC HD3> ) -|\n          |- <GLOB HD>    ::= <GLOB HD1> -|\n          |- <DECL>       ::= <T DECL4> -|\n          |- <DECL>       ::= <FUNC DC7> -|\n          |- <DECL>       ::= <SYN DC2> -|\n          |- <BLOCKHEAD>  ::= <BLOCKHEAD><DECL> ; -|\n          |- <BLOCKBODY>  ::= <BLOCKHEAD> -|\n          |- <BLOCKBODY>  ::= <BLOCKBODY><STATEMENT> ; -|\n          |- <BLOCKBODY>  ::= <BLOCKBODY><LABEL DEF> -|\n          |- <PROGRAM>    ::= <PROGRAM*> . -|\n          |- <IF>         ::= IF -|\n          |- <IF>         ::= <IF><STATEMENT> ; -|\n          |- <COMP AOR>   ::= <COMP AOR><STATEMENT> ; -|\n          |- <WHILE>      ::= <WHILE><STATEMENT> ; -|\n          |- <PRIM COND>  ::= <COMP COND> -|\n          |- <RP>         ::= <RP><STATEMENT> ; -|\n          |- <CASE HEAD>  ::= <CASE HEAD><DECL> ; -|\n          |- <CASE SEQ>   ::= <CASE HEAD> -|\n          |- <CASE SEQ>   ::= <CASE SEQ><LABEL DEF> -|\n          |- <REPEAT>     ::= <REPEAT><LABEL DEF> -|\n          |- <REPEAT>     ::= <REPEAT><STATEMENT> ; -|\n$PAGE\n    R1 := R1 - XEQ0;   if > then  |-- NOT NULL RULE --|\n    case R1 of begin  |-- EXECUTE1'S RULES --|\n    begin |- <K REG ASS>  ::= <K REG> -|\n$IFT D D\n       if TM(1,DBGFLGS); ON then SET(PRNT); |-- List assignments --|\n$END D\n    end;\n    begin |- <K REG>      ::= <ID> -|\n       R1 := @V(R7); R3 := 1 + T(R7) and #E; R4 := R4-R4; IC(R4,V(R7));\n       IC(R4,ALPHASH(R4-193)); R4 := R4 + LENHASH(R3-2);\n       R4 := HASHCHAIN(R4);  REDUCE(R3);  R5 := NAMEBASE;\n       if R4 >= 0 then\n       begin  |-- SCAN NAME TABLE --|\n       Z: R4 := R4 + R5; EX(R3,CLC(0,B1,NAME(R4))); if = then\n          begin R0 := TYPE(R4); R2 := ADR(R4+2); SRDL(R2,16);\n             R2 := ADR(R4); SRDL(R2,16); R5 := #FF;\n             R4 := R0 and #FF00; R0 := R0 and R5; R5 := 80;\n             if R0 > R5 then R0 := R0 - R5 else SET(FLAG);\n             goto X;\n          end; R4 := LINK(R4);  if R4 \u00ac= ENDCHAIN then\n          begin  R4 := R4 and #FFFF;  goto Z;  end;\n       end; XR := 8; ERROR;\n       R3 := 1; R0 := R3;\n X:    V(R7) := R3; V(R7+8) := R4; T(R7) := R0;\n    end;\n    begin |- <T CELL ID>  ::= <ID> -|\n       R1 := 10; if R1 > T(R7) then\n       begin R0 := V(R7) and #FFFFF;\n          |- Check for DSTAR symbol reference -|\n          if R0 = #D0FFF then R0 := DBREG shll 12 + DC\n          |- Check for PSTAR symbol reference -|\n          else if R0 = #E0FFF then R0 := PTAG + LC;\n          V(R7) := R0;  R1 := R1-R1;  V(R7+4) := R1;\n       end else SET(FLAG);\n    end;\n    begin |- <PROC ID>    ::= <ID> -|\n       R1 := 10; if R1 \u00ac= T(R7) then SET(FLAG);\n    end;\n    begin |- <FUNC ID>    ::= <ID> -|\n       R1 := 11; if R1 \u00ac= T(R7) then SET(FLAG);\n    end;\n    begin |- <T NUMBER>   ::= <ID> -|\n       R1 := 1;  R2 := 12;  if R2 = T(R7) then goto X;\n       R1 := R1-R1;  R2 := 15;  if R2 = T(R7) then goto X;\n       SET(FLAG);  goto Z;\n    X: T(R7) := R1; R1 := R1-R1; V(R7+4) := R1;  Z:\n    end;\n    begin |- <UNARY OP>   ::= <ID> -|\n       R1 := 13;  if R1 \u00ac= T(R7) then SET(FLAG);\n    end;\n    begin |- <BRINDX OP>  ::= <ID> -|\n       R1 := 14;  if R1 \u00ac= T(R7) then SET(FLAG);\n    end;\n    begin |- <T CELL1>    ::= <T CELL1><ARITH OP><STRING> -|\n       STRTOINT;\n       TCELLNUM;\n    end;\n    begin |- <T CELL1>    ::= <T CELL1><ARITH OP><T NUMBER> -|\n       TCELLNUM;\n    end;\n    begin |- <T CELL1>    ::= <T CELL2><ARITH OP><T NUMBER> -|\n       TCELLNUM;\n    end;\n    begin |- <T CELL1>    ::= <T CELL2><ARITH OP><K REG> -|\n       R0 := 1; R1 := V2(R7); R2 := V(R7);\n       if R0 \u00ac= T2(R7) or R1 = 0 then\n       begin XR := 7; ERROR; goto X;\n       end;\n       if R2 > #FFFF then begin XR := 11; ERROR; goto X; end;\n       R0 := 10; if R0 \u00ac= V1(R7) then\n       begin XR := 0; ERROR; goto X;\n       end;\n       R2 := R2 and #FFFF; if R2 < 4096S then\n       R1 := R1 shll 12 else R1 := R1 shll 16;\n       R1 := R1 or R2; V(R7) := R1;\n X: end;\n    begin |- <T CELL1>    ::= <T CELL3><STRING> -|\n       R7 := R7 - 16S;  STRTOINT;  R7 := R7 + 16S;\n       INDXTNUM;  |- Assign as number -|\n    end;\n    begin |- <T CELL1>    ::= <T CELL3><T NUMBER> -|\n       INDXTNUM;\n    end;\n    begin |- <T CELL2>    ::= <T CELL3><K REG> -|\n       R0 := 1; R1 := V1(R7); R2 := V(R7);\n       if R0\u00ac=T1(R7) or R1=0 then begin XR := 7; ERROR; goto X; end;\n       if R2 > #FFFF then begin XR := 11; ERROR; goto X; end;\n       R2 := R2 and #FFFF; if R2 < 4096S then\n       R1 := R1 shll 12 else R1 := R1 shll 16;\n       R1 := R1 or R2; V(R7) := R1;\n X: end;\n    begin |- <UNARY CELL> ::= <UNARY OP><T CELL> -|\n       NEWUNARY;\n    end;\n    begin |- <UNARY CELL> ::= <UNARY OP><UNARY CELL> -|\n       OLDUNARY;\n    end;\n    begin |- <UNARY NUM>  ::= <UNARY OP><T NUMBER> -|\n       NEWUNARY;\n    end;\n    begin |- <UNARY NUM>  ::= <UNARY OP><UNARY NUM> -|\n       OLDUNARY;\n    end;\n    begin |- <UNARY REG>  ::= <UNARY OP><K REG> -|\n       NEWUNARY;\n    end;\n    begin |- <UNARY REG>  ::= <UNARY OP><UNARY REG> -|\n       OLDUNARY;\n    end;\n    begin |- <LOG OP>     ::= AND -|\n       R0 := #4; V(R7) := R0;\n    end;\n    begin |- <LOG OP>     ::= OR -|\n       R0 := #6; V(R7) := R0;\n    end;\n    begin |- <LOG OP>     ::= XOR -|\n       R0 := #7; V(R7) := R0;\n    end;\n    begin |- <K REG ASS>  ::= <K REG> := <T CELL> -|\n       ASSCELL;\n    end;\n    begin |- <K REG ASS>  ::= <K REG> := <T NUMBER> -|\n       ASSTNUM;\n    end;\n    begin |- <K REG ASS>  ::= <K REG> := <STRING> -|\n       STRTOINT;\n       ASSTNUM;\n    end;\n    begin |- <K REG ASS>  ::= <K REG> := <K REG> -|\n       R0 := T2(R7); R1 := R0 shll 2 + T(R7); R1 := @TYPETABLE(R1);\n       CLI(0,B1); if = then begin XR := 3; ERROR; end;\n       R1 := 8; R2 := V(R7); R3 := V2(R7); if R2 \u00ac= R3 then EMIT;\n    end;\n    begin |- <K REG ASS>  ::= <K REG> := <UNARY CELL> -|\n       ASSCELL;  V2(R7/16) := V(R7);  ASSUNOP;\n    end;\n    begin |- <K REG ASS>  ::= <K REG> := <UNARY NUM> -|\n       ASSTNUM;  V2(R7/16) := V(R7);  ASSUNOP;\n    end;\n    begin |- <K REG ASS>  ::= <K REG> := <UNARY REG> -|\n       ASSUNOP;\n    end;\n    begin |- <K REG ASS>  ::= <K REG> := <ADR OP><T CELL> -|\n       R0 := 1;  if R0 \u00ac= T(R7) then\n       begin  XR:=3;  ERROR;  |-- REG ASSIGN TYPE --|\n       end;  R2 := V(R7);  R3 := V(R7+48);  R4 := V2(R7);\n       if R4 \u00ac= 0 and  R4 := V(R7+56) shrl 8;\n          R4 < MAXSEGNO and R5 := R4 * 10S;\n          R5 := @ESDNAME(R5);  B5 \u00ac= \"DUMMY \" then\n       begin  R0 := ER;  R3 := R3 and #F0FFF;  ADRSOP;\n       end;  R0 := 4;  R1 := 1;  if R3 >= 0 then EMYT;\n    end;\n    begin |- <K REG ASS>  ::= <K REG> := <ADR OP><PROC ID> -|\n       R0:=T(R7); if R0\u00ac=1 then begin XR:=3; ERROR; end;\n       R4:=V(R7+48); SRDL(R4,12); R4:=R4 shrl 8; SRDL(R4,4);\n       R5:=R5 shrl 16; R2:=V(R7); if R4\u00ac=CSEGNO then\n       begin  R0 := ER;  R3 := V2(R7);  if R3 \u00ac= 0 then R0 := WER;\n          R3 := #FFF and R5;  ADRSOP;  R5 := R3;\n$IFT D D\n          if TM(4,DBGFLGS); ON then SET(PRNT); |-- List these --|\n$END D\n       end;  R0 := 4;  R1 := 1;  if LTR(R3,R5); > then EMYT;\n    end;\n    begin |- <K REG ASS>  ::= <K REG ASS><ARITH OP><STRING> -|\n       STRTOINT;\n       ARITHNUM;\n    end;\n    begin |- <K REG ASS>  ::= <K REG ASS><ARITH OP><T CELL> -|\n       R0 := T2(R7); R1 := R0 shll 2 + T(R7); R1 := @TYPETABLE(R1);\n       CLI(0,B1); if = then begin XR := 4; ERROR; end;\n       R1 := V1(R7); R2 := V(R7);\n       if R1>=13S and R0=0 then begin XR := 4; ERROR; end else\n       if R0=1 then if R1=12S or R1=13S then\n       begin R2 := R2 and #E;  |-- ODD REGISTER MUST BE SPECIFIED --|\n          if R2=V(R7) then begin XR := 7; ERROR; end;\n       end;\n       R0 := R0 + 4; R3 := V2(R7); EMYT;\n    end;\n    begin |- <K REG ASS>  ::= <K REG ASS><ARITH OP><T NUMBER> -|\n       ARITHNUM;\n    end;\n    begin |- <K REG ASS>  ::= <K REG ASS><ARITH OP><K REG> -|\n       R0 := T2(R7); R1 := R0 shll 2 + T(R7); R1 := @TYPETABLE(R1);\n       CLI(0,B1); if = then begin XR := 4; ERROR; end;\n       R1 := V1(R7); R2 := V(R7); R3 := V2(R7);\n       if R1 = 0 then  |-- REVERSE ASSIGNMENT --|\n       begin  if R2 = R3 then goto X;\n          R1 := R2;  R2 := R3;  R3 := R1;  R1 := 8;\n       end;  if R0=1 then if R1=12S or R1=13S then\n       begin R2 := R2 and #E;  |-- ODD REGISTER MUST BE SPECIFIED --|\n          if R2=V(R7) then begin XR := 7; ERROR; end;\n       end; EMIT;\n X: end;\n    begin |- <K REG ASS>  ::= <K REG ASS><LOG OP><STRING> -|\n       STRTOINT;\n       LOGTNUM;\n    end;\n    begin |- <K REG ASS>  ::= <K REG ASS><LOG OP><T CELL> -|\n       R0 := 1; if R0\u00ac=T(R7) or R0\u00ac=T2(R7) then\n       begin XR := 4; ERROR;\n       end;\n       R0 := 5; R1 := V1(R7); R2 := V(R7); R3 := V2(R7); EMYT;\n    end;\n    begin |- <K REG ASS>  ::= <K REG ASS><LOG OP><T NUMBER> -|\n       LOGTNUM;\n    end;\n    begin |- <K REG ASS>  ::= <K REG ASS><LOG OP><K REG> -|\n       R0 := 1; if R0\u00ac=T(R7) or R0\u00ac=T2(R7) then\n       begin XR := 4; ERROR;\n       end;\n       R1 := V1(R7); R2 := V(R7); R3 := V2(R7); EMIT;\n    end;\n    begin |- <K REG ASS>  ::= <K REG ASS><SHIFT OP><T NUMBER> -|\n       R0 := 1; if R0\u00ac=T(R7) or R0<T2(R7) then\n       begin XR := 5; ERROR;\n       end;\n       R0 := 8; R1 := V1(R7); R2 := V(R7); R3 := V2(R7);\n       if R3<0 or R3>=32S then\n       begin XR:=25; ERROR;\n       end;\n       if R3 \u00ac= 0 then EMYT;\n    end;\n    begin |- <K REG ASS>  ::= <K REG ASS><SHIFT OP><K REG> -|\n       R0 := 1; if R0\u00ac=T(R7) or R0\u00ac=T2(R7) then\n       begin XR := 5; ERROR;\n       end;\n       R0 := 8; R1 := V1(R7); R2 := V(R7);\n       R3 := V2(R7) shll 12; EMYT;\n    end;\n    end; LM(R1,R5,SAVEREG);\n    end;\n$PAGE\nsegment procedure EXECUTE2(R4);  |-- XEQ1 < RULES <= XEQ2 --|\n   begin  |-- LOCAL PROCEDURES FOLLOW --|\n\n    procedure  ARGUMENT(R8);  |-- Process FUNCTION arguments --|\n    begin R0 := V(R7); SRDL(R0,4); V(R7) := R0; R1 := R1 shrl 28;\n       R0 := V1(R7); R3 := T1(R7); XR := 24;\n       if R1 = 0 then begin XR := 13; ERROR; end else\n       case R1 of begin\n          begin  |-- PAR 1 -- REGISTER -- BITS 8-11 --|\n             if R2 \u00ac= 4 then ERROR;\n             R0 := R0 and #F shll 4 or FUNC0; FUNC0 := R0;\n          end;\n          begin  |-- PAR 2 -- NUMBER -- BITS 8-11 --|\n             if R2 \u00ac= 2 or R0 >= 16S or R0 < 0 then ERROR;\n             R0 := R0 and #F shll 4 or FUNC0; FUNC0 := R0;\n          end;\n          begin  |-- PAR 3 -- REGISTER -- BITS 12-15 --|\n             if R2 \u00ac= 4 then ERROR;\n             R0 := R0 and #F or FUNC0; FUNC0 := R0;\n          end;\n          begin  |-- PAR 4 -- NUMBER -- BITS 12-15 --|\n             if R2 \u00ac= 2 or R0 >= 16S or R0 < 0 then ERROR;\n             R0 := R0 and #F or FUNC0; FUNC0 := R0;\n          end;\n          begin  |-- PAR 5 -- NUMBER STRING VARIABLE -- BITS 8-15 --|\n             case R2 of begin\n                begin if R0 >= 256S then ERROR;\n                end;\n                begin if R3 < 2 then if R0 < 256S then\n                   if R0 < 0 then ERROR;\n                end;\n                begin if R0 \u00ac= 1 then begin XR := 21; ERROR; end;\n                   IC(R0,STRINGV);\n                end;\n                begin  ERROR;\n                end;\n             end;  R0 := R0 and #FF xor FUNC0;  FUNC0 := R0;\n          end;\n          begin  |-- PAR 6 -- NUMBER STRING VARIABLE -- BITS 12-31 --|\n             case R2 of begin\n                null;\n                begin if R3 < 2 then if R0 < 4096S then\n                   if R0 < 0 then ERROR;\n                end;\n                begin if R0 \u00ac= 1 then begin XR := 21; ERROR; end;\n                   IC(R0,STRINGV);\n                end;\n                begin  ERROR;\n                end;\n             end; FUNC1 := R0; R0 := R0 shrl 16 and #F or FUNC0;\n             FUNC0 := R0;\n          end;\n          begin  |-- PAR 7 -- LITERAL VARIABLE -- BITS 12-31 --|\n             case R2 of begin\n                begin FUNC1:=R0; R0:=R0 shrl 16 and #F or FUNC0;\n                   FUNC0:=R0;\n                end;\n                begin IC(R2,LENGTH(R3)); R1 := 1 shll R2 - 1;\n                   R3:=LITX; FUNC1:=R3; R3:=1; LITCOUNT:=R3;\n                   R0 := R2; R2 := 2 + LC; R3 := @V1(R7);\n                   if R1 = 0 then R3 := @B3(3);  MAKELITERAL;\n                end;\n                begin R1 := R0 - 1; R0 := R0-R0; R2 := 2 + LC;\n                   R3:=LITX; FUNC1:=R3; R3:=1; LITCOUNT:=R3;\n                   R3 := @STRINGV; MAKELITERAL;\n                end;\n                begin  ERROR;\n                end;\n             end;\n$IFT D D\n             if R3 \u00ac= 4 and CLI(#43,FUNC0(2)); = then SET(PRNT);\n$END D\n          end;\n          begin  |-- PAR 8 -- VARIABLE -- BITS 12-31 --|\n             if R2 \u00ac= 1 then ERROR; FUNC1 := R0;\n             R0 := R0 shrl 16 and #F or FUNC0; FUNC0 := R0;\n$IFT D D\n             if R3 \u00ac= 4 and CLI(#42,FUNC0(2)); = then SET(PRNT);\n$END D\n          end;\n          begin  |-- PAR 9 -- NUMBER VARIABLE -- BITS 16-31 --|\n             case R2 of begin\n                if R0 > #FFFF then begin XR := 11; ERROR; end;\n                begin if R3 < 2 then if R0 < 4096S then\n                   if R0 < 0 then ERROR;\n                end;\n                begin  ERROR;\n                end;\n                begin  ERROR;\n                end;\n             end; FUNC1 := R0;\n          end;\n          begin  |-- PAR A -- LITERAL VARIABLE -- BITS 16-31 --|\n             case R2 of begin\n                begin FUNC1:=R0;\n                   if R0 > #FFFF then begin XR:=11; ERROR; end;\n                end;\n                begin IC(R2,LENGTH(R3)); R1 := 1 shll R2 - 1;\n                   R3:=LITX; FUNC1:=R3; R3:=1; LITCOUNT:=R3;\n                   R0 := R2; R2 := 2 + LC; R3 := @V1(R7);\n                   if R1 = 0 then R3 := @B3(3);  MAKELITERAL;\n                end;\n                begin R1 := R0 - 1; R0 := R0-R0; R2 := 2 + LC;\n                   R3:=LITX; FUNC1:=R3; R3:=1; LITCOUNT:=R3;\n                   R3 := @STRINGV; MAKELITERAL;\n                end;\n                begin  ERROR;\n                end;\n             end;\n          end;\n          begin  |-- PAR B -- VARIABLE -- BITS 16-31 --|\n             if R2 \u00ac= 1 then ERROR else\n             if R0 > #FFFF then begin XR := 11; ERROR; end;\n             FUNC1 := R0;\n$IFT D D\n             if R3 \u00ac= 4 then  |-- Not BYTE --|\n             begin  |-- Test for certain functions --|\n                if CLI(#94,FUNC0(2)); = then  |-- NI --|\n                begin  if CLI(#7F,FUNC0(3)); \u00ac= then SET(PRNT);\n                end else  |-- Look for all others --|\n                if CLI(#91,FUNC0(2)); >= and CLI(#97,FUNC0(2)); <=\n                   and CLI(#80,FUNC0(3)); \u00ac= then SET(PRNT);\n             end;\n$END D\n          end;\n          begin  |-- PAR C -- LITERAL VARIABLE -- BITS 32-47 --|\n             case R2 of begin\n                begin FUNC2:=R0;\n                   if R0 > #FFFF then begin XR:=11; ERROR; end;\n                end;\n                begin IC(R2,LENGTH(R3)); R1 := 1 shll R2 - 1;\n                   R3:=LITX; FUNC2:=R3; R3:=LITCOUNT+2; LITCOUNT:=R3;\n                   R0:=R2; R2:=4+LC;\n                   R3:=FUNCCOUNT; if R3\u00ac=1 then R2:=R2-2;\n                   R3:=@V1(R7);\n                   if R1 = 0 then R3 := @B3(3);  MAKELITERAL;\n                end;\n                begin R1 := R0 - 1; R0 := R0-R0; R2 := 4 + LC;\n                   R3:=LITX; FUNC2:=R3; R3:=LITCOUNT+2; LITCOUNT:=R3;\n                   R3:=FUNCCOUNT; if R3\u00ac=1 then R2:=R2-2;\n                   R3 := @STRINGV; MAKELITERAL;\n                end;\n                begin  ERROR;\n                end;\n             end;\n          end;\n          begin  |-- PAR D -- REGISTER -- BITS 16-31 --|\n             if R2 \u00ac= 4 then ERROR;\n             R0 := R0 and #F shll 4;  FUNC1 := R0;\n          end;\n       end;\n    end;\n$PAGE\n\n    R1 := R1 - XEQ1; case R1 of begin  |-- EXECUTE2'S RULES --|\n    begin |- <FUNC1>      ::= <FUNC2><T NUMBER> -|\n       R2 := 2; ARGUMENT;\n    end;\n    begin |- <FUNC1>      ::= <FUNC2><K REG> -|\n       R2 := 4; ARGUMENT;\n    end;\n    begin |- <FUNC1>      ::= <FUNC2><T CELL> -|\n       R2 := 1; ARGUMENT;\n    end;\n    begin |- <FUNC1>      ::= <FUNC2><STRING> -|\n       R2 := 3; ARGUMENT;\n    end;\n    begin |- <FUNC1>      ::= <FUNC2><FUNC3> -|\n       R1 := FUNC2 and #FFFF;  R2 := FUNC0;\n       R3 := FUNC1 shll 16 or R1; R0 := LITCOUNT;\n       R1 := R2 shrl 8 - #44S; if = then begin XR := 24; ERROR; end;\n       if R0>0 then\n       begin R0 := R0+8S; SLDL(R2,16);\n       end else R0 := 1;\n       STM(R2,R3,STRINGV); R1 := FUNC0 shra 14 + 1 or 1;\n       R2:=2+LC; R3:=@STRINGV; MAKELITERAL; R0:=R0-R0; LITCOUNT:=R0;\n       V(R7):=R0; R0:=V1(R7+4); FUNC0:=R0;\n       R0:=R0 shrl 8 -#44S; if \u00ac= then begin XR:=24; ERROR; end;\n    end;\n    begin |- <FUNC2>      ::= <FUNC ID> ( -|\n       array FT short integer FUNCTYPE=(#0000,#0031,#0071,\n          #0B31,#00B5,#0CB5,#0001,#0005,#000B,#0091,#CB42,\n          #0061,#0081,#0CA5,#00CB,#0007,#0A41,#0B41,#000D,#0009);\n       R0:=FUNCCOUNT+1; FUNCCOUNT:=R0; R0:=FUNC0; V(R7+4):=R0;\n       R0:=R0-R0; LITCOUNT:=R0;\n       R2 := V(R7); SRDL(R2,16); R3 := R3 shrl 16; FUNC0 := R3;\n       R2 := R2 shll 1; R0 := FUNCTYPE(R2) and #FFFF; V(R7) := R0;\n    end;\n    begin |- <FUNC3>      ::= <FUNC1> ) -|\n       R0:=V(R7); if R0\u00ac=0 then begin XR:=13; ERROR; end;\n    end;\n    begin |- <CASE HEAD>  ::= CASE <K REG> OF BEGIN -|\n       R0 := 1; R2 := V1(R7);\n       if R0 \u00ac= T1(R7) or R2 = 0 then\n       begin XR := 7; ERROR;\n       end; R1 := #A; R3 := R2; EMIT;\n       R0 := 4; R1 := 8; EMIT;\n       R1 := LC =: V(R7+8); R0 := PTAG =: PROGRAM(R1+4);\n       R0 := #47F0 or R3 =: PROGRAM(R1+2); R1 := @B1(6) =: LC;\n       R0 := ENDCHAIN =: V(R7); R0 := R0 -- R0 =: V(R7+4);\n       R0 := N4; R1 := 14 + N3 =: N3 =: N4;     |-- OPEN BLOCK --|\n       R1 := R1 + LABELBASE; B1(0/12) := ZERO; LABELADR(R1) := R0;\n       R0 := N2; LABEL(R1+4) := R0; R0 := N1; N2 := R0;\n       R0 := DBREG; LABEL(R1) := R0;\n       R0 := PROCBR =: LABEL(R1+6);\n       R0 := 1 =: PROCBR;\n       R0 := PROCLK =: LABELCHAIN(R1);\n       R2 := 1 + BLOCK; BLOCK := R2;\n    end;\n    begin |- <CASE SEQ>   ::= <CASE SEQ><STATEMENT> ; -|\n       R0 := #F0; R2 := V(R7); EMYTBRANCH;\n       R1 := V(R7); PROGRAM(R1+2) := R2;\n       R1 := 2 + V(R7+4) =: V(R7+4);\n    end;\n    end; LM(R1,R5,SAVEREG);\n    end;\n$PAGE\n\nsegment procedure EXECUTE3(R4);  |-- XEQ2 < RULES <= XEQ3 --|\n   begin  |-- LOCAL PROCEDURES FOLLOW --|\n\n   procedure INITCOND(R4);\n   begin V(R7+8) := R1; R1 := ENDCHAIN =: V(R7) =: V(R7+4);\n   end;\n\n   segment procedure CLOSEBLOCK(R8);\n   begin array 3 integer SAVE68; integer SAVE8 syn SAVE68(8);\n      STM(R6,R8,SAVE68);\n      R14 := N4 + LABELBASE; R5 := LABELADR(R14) =: N4;\n      R0 := LABEL(R14+6) =: PROCBR; R0 := LABEL(R14+12) =: PROCLK;\n      R1 := N2; if R1 \u00ac= N1 then\n      begin for R2 := R2 -- R2 step 4S until MAXHASH do\n         begin R3 := HASHCHAIN(R2); while R3 >= R1 do\n            begin R3 := R3 + NAMEBASE; R3 := LINK(R3);\n               if R3 \u00ac= ENDCHAIN then R3 := R3 and #FFFF;\n            end; HASHCHAIN(R2) := R3;\n         end; N1 := R1;\n      end; R1 := LABEL(R14+4) and #FFFF =: N2;\n      if R14 \u00ac= LABELBASE then R14 := R14 - 14S;\n      R5 := R5 + LABELBASE; R5 := @B5(14);\n      R6 := R14; R12 := N3 + LABELBASE;\n      R7 := @B14(14); while R7 := @B7(14); R7 <= R12 do\n      if R0 := LABELADR(R7); R0 \u00ac= 0 then\n      begin R1 := LABELCHAIN(R7); CHAINFIXUP;\n      end else\n      begin for R8 := R6 step _14S until R5 do\n         begin if LABEL(R7/10) = LABEL(R8) then\n            begin R0 := LABELCHAIN(R7); R2:= @LABELCHAIN(R8-2);\n               MERGECHAIN; goto X;\n            end;\n         end; R14:= @B14(14); LABEL(R14/14) := LABEL(R7);\n  X:  end; R14 := R14 - LABELBASE =: N3; LM(R6,R7,SAVE68);\n      R2 := BLOCK; REDUCE(R2); BLOCK := R2; R5 := R10;\n      while R2 < BLOCKLEVEL(R5) and \u00acNODATASEG do\n      begin R2 := 7 + DC and _8 =: DC;\n         R0 := DATAESDEND; R1 := DATAESDADR; CLOSESEG;\n         R2 := PREVSEG(R5); if R2 = ENDCHAIN then\n         begin SET(NODATASEG); R2 := BLOCK; R2 := @B2(1);\n            R0 := R0 -- R0 =: COUNTER(R5) =: PL360NO(R1);\n         end else\n         begin R5 := R2; UNSTACKSEG; R2 := BLOCK; DATAESDEND := R0;\n         end;\n      end; R10 := R5; R8 := SAVE8;\n   end;\n\n   segment procedure GENMVCLC(R4);\n   begin  SAVE := R4;\n      R0 := V(R7) and #FFFF;  if R0 \u00ac= V(R7) then\n      begin XR := 11;  ERROR;  end;\n      R2 := T(R7);  R3 := R3-R3;  R1 := V(R7+4);\n      if R1 = R3 then  |-- CELL LENGTH NOT GIVEN --|\n      begin  IC(R1,ALENGTH(R2));  R1 := @B1(1);\n      end;  if R1 > 256 then  |-- TOO LONG --|\n      begin XR := 24;  ERROR;  R1 := 256;  end;\n      CLI(1,MCTYPE);  if = then\n      begin  |-- <T NUMBER> --|\n         R3 := T2(R7);  R4 := R4-R4;  IC(R4,ALENGTH(R3));\n         R4 := @B4(1);  R3 := R3 and 3;  if R3 > 1 or R1 > R4 then\n         begin if R1 \u00ac= R4 then\n            begin XR := 1;  ERROR;  end;  R3 := R3 xor 1;\n         end else if R1 <= 3 then\n         begin R3 := 3 - R1; EX(R3,CLC(0,V2(R7),0));\n            if \u00ac= then EX(R3,CLC(0,V2(R7),_1));\n            if \u00ac= then begin XR := 1; ERROR; end;\n            if R3 = 0 then V2(R7/3) := V2(R7+1);\n         end else R3 := 2;\n      end else if < then\n      begin  |-- <T CELL> --|\n         R4 := V(R7+4);  R3 := V2(R7) and #FFFF;\n         if R3 \u00ac= V2(R7) then XR := 11 else\n         begin if R4 \u00ac= 0 or R2 = T2(R7) then goto X;\n            XR := 1;   |-- INVALID TYPES --|\n         end;  ERROR;   |-- EITHER 1 OR 11 --|\n   X: end else\n      begin  |-- <STRING> --|\n         R3 := R3-R3; if R3=V(R7+4) or R1>V2(R7) then R1:=V2(R7);\n         if R1 = 1 then V2(R7+3/1) := STRINGV;\n      end;  V(R7+4) := R1;  REDUCE(R1);\n      CLI(0,MCTYPE);  if \u00ac= then if R1 \u00ac= 0 then\n      begin R0 := R0-R0;  CLI(2,MCTYPE);\n         if = then R3 := @STRINGV else\n         begin R0 := R3;  R3 := @V2(R7);\n         end;  R2 := 4 + LC;\n         MAKELITERAL;  R0 := R0-R0;  V2(R7) := R0;\n      end else\n      begin R3 := V2(R7) and #FF;  R0 := 9;  goto Y;\n      end;  R3 := R1;  R0 := 13;\n   Y: R2 := R2-R2;  R1 := R2;  IC(R1,MCCODE);  STC(R0,MCTYPE);\n      EMIT;  R0 := V(R7);  EDIT;  CLI(13,MCTYPE);\n      if = then  |-- MVC OR CLC --|\n      begin R0 := V2(R7);  EDIT;\n      end;  CLI(5,MCCODE);  if = then\n      begin R1 := V1(R7) =: V(R7+8); R0 := ENDCHAIN =: V(R7) =: V(R7+4);\n      end;  R4 := SAVE;\n   end;\n$PAGE\n    R1 := R1 - XEQ2; case R1 of begin  |-- EXECUTE3'S RULES --|\n    begin |- <PROC2>      ::= <PROC1><K REG> -|\n       R0:=V1(R7); PROCCALL;\n    end;\n    begin |- <CELL ST>    ::= <T CELL> := <K REG> -|\n       R0 := T(R7); R1 := R0 shll 2 + T2(R7); R1 := @TYPETABLE(R1);\n       CLI(0,B1); if = then begin XR := 1; ERROR; end;\n       R0 := R0 + 4; R1 := R1-R1; R2 := V2(R7); R3 := V(R7); EMYT;\n    end;\n    begin |- <CELL ST>    ::= <T CELL> := <T CELL> -|\n       CLC(3,V(R7),V2(R7));  if \u00ac= then\n       begin MCTYPE := 0;  MCCODE := 2;  GENMVCLC;  end;\n    end;\n    begin |- <CELL ST>    ::= <T CELL> := <T NUMBER> -|\n       MCTYPE := 1;  MCCODE := 2;  GENMVCLC;\n    end;\n    begin |- <CELL ST>    ::= <T CELL> := <STRING> -|\n       MCTYPE := 2;  MCCODE := 2;  GENMVCLC;\n    end;\n    begin |- <CELL ST>    ::= <CELL ST><LOG OP><T CELL> -|\n       MCTYPE := 0;  R1 := V1(R7);  STC(R1,MCCODE);  GENMVCLC;\n    end;\n    begin |- <CELL ST>    ::= <CELL ST><LOG OP><T NUMBER> -|\n       MCTYPE := 1;  R1 := V1(R7);  STC(R1,MCCODE);  GENMVCLC;\n    end;\n    begin |- <CELL ST>    ::= <CELL ST><LOG OP><STRING> -|\n       MCTYPE := 2;  R1 := V1(R7);  STC(R1,MCCODE);  GENMVCLC;\n    end;\n    begin |- <SIMPLE ST>  ::= <PROC ID> -|\n       R0 := 16; PROCCALL;\n    end;\n    begin |- <SIMPLE ST>  ::= <FUNC ID> -|\n       R0 := V(R7); EDIT;\n       if R0 > #FFFF then begin XR := 13; ERROR; end;\n    end;\n    begin |- <SIMPLE ST>  ::= <FUNC3> -|\n       R2 := FUNC0; R1 := LC; PROGRAM(R1) := R2;\n       R3 := 2; R4 := R3; R2 := R2 shra 14; if \u00ac= then\n       begin R0 := FUNC1; PROGRAM(R1+2) := R0; if R2 > R3 then\n          begin R0 := FUNC2; PROGRAM(R1+4) := R0; R4 := R4 + R3;\n          end;  R4 := R4 + R3;\n       end;  R1 := R1 + R4;\n       LC := R1;\n       R0:=R0-R0; FUNCCOUNT:=R0;\n    end;\n    begin |- <SIMPLE ST>  ::= <CASE SEQ> END -|\n       R0 := V(R7+4); if R0 = 0 then\n       begin XR := 22; ERROR;\n       end else\n       begin R0 := R0 + LC =: R4 =: LC + PTAG;\n          R1 := V(R7); R3 := PROGRAM(R1+2); if OPTFLAG < #80 then\n          begin R2 := PTAG shrl 12; R2 := @B2(#F0);\n             STC(R2,PROGRAM(R1+1)); PROGRAM(R1+2) := R4; R1 := R3;\n          end; while REDUCE(R4); REDUCE(R4); R3 >= 0 do\n          begin R2 := @B3(4) =: PROGRAM(R4); R3 := PROGRAM(R3+2);\n          end; R2 := V(R7+8); R3 := @B2(6) =: PROGRAM(R4);\n          REDUCE(R4); REDUCE(R4); R4 := R4 + PTAG =: PROGRAM(R2);\n          CHAINFIXUP;\n       end; CLOSEBLOCK;\n    end;\n    begin |- <SIMPLE ST>  ::= <BLOCKBODY> END -|\n       CLOSEBLOCK;\n    end;\n    begin |- <REL OP>     ::= = -|\n       R0 := 7; V(R7) := R0;\n    end;\n    begin |- <CONDITION>  ::= <K REG><REL OP><T CELL> -|\n       R0 := T2(R7); R1 := R0 shll 2 + T(R7); R1 := @TYPETABLE(R1);\n       CLI(0,B1); if = then begin XR := 6; ERROR; end;\n       R0 := R0 + 4; R1 := 9; R2 := V(R7); R3 := V2(R7); EMYT;\n       R1 := V1(R7); INITCOND;\n    end;\n    begin |- <CONDITION>  ::= <K REG><REL OP><T NUMBER> -|\n       R2 := T2(R7); R1 := R2 shll 2 + T(R7); R1 := @TYPETABLE(R1);\n       CLI(0,B1); if = then begin XR := 6; ERROR; end;\n       R1 := R1 - R1; if R1 = V2(R7) and R1 = V2(R7+4) then\n       begin R0 := T(R7); R1 := 2; R2 := V(R7); R3 := R2; EMIT;\n       end else\n       begin R1 := R1-R1; IC(R1,ALENGTH(R2)); IC(R0,LENGTH(R2));\n          R2 := 2 + LC; R3 := @V2(R7); MAKELITERAL;\n          R0 := 4 + T2(R7); R1 := 9; R2 := V(R7); R3 := R3-R3; EMYT;\n       end;\n       R1 := V1(R7); INITCOND;\n    end;\n    begin |- <CONDITION>  ::= <K REG><REL OP><K REG> -|\n       R0 := T(R7);\n       if R0 \u00ac= T2(R7) then begin XR := 6; ERROR; end;\n       R1 := 9; R2 := V(R7); R3 := V2(R7); EMIT;\n       R1 := V1(R7); INITCOND;\n    end;\n    begin |- <CONDITION>  ::= <K REG><REL OP><STRING> -|\n       R0 := STRINGV; R1 := 4 - V2(R7);\n       for R2 := 1 step 1 until R1 do R0 := R0 shrl 8;\n       if R1 < 0 then begin XR := 21; ERROR; end;\n       STRINGV := R0; R0 := 2; R1 := 3; R2 := 2 + LC;\n       R3 := @STRINGV; MAKELITERAL; R0 := T(R7);\n       if R0 \u00ac= 1 then begin XR := 6; ERROR; end;\n       R0 := 5; R1 := 9; R2 := V(R7); R3 := R3-R3; EMYT;\n       R1 := V1(R7); INITCOND;\n    end;\n    begin |- <CONDITION>  ::= <T NUMBER> -|\n       R1 := R7 - 16S;  R1 := S(R1);\n       if R1=REPLIST1 or R1=TDECL3 then SET(FLAG) else\n       begin R0 := 1; if R0 > T(R7) then\n          begin XR := 25; ERROR;\n          end; R1 := V(R7) and #F xor #F;\n          if OPTFLAG < #80 then R1 := @B1(16);  INITCOND;\n       end;\n    end;\n    begin |- <CONDITION>  ::= \u00ac <T NUMBER> -|\n       R0 := 1; R1 := V1(R7) and #F;\n       if R0 > T1(R7) then begin XR := 25; ERROR; end;\n       if OPTFLAG < #80 then R1 := @B1(16);  INITCOND;\n    end;\n    begin |- <CONDITION>  ::= <T CELL><REL OP><T CELL> -|\n       MCTYPE := 0;  MCCODE := 5;  GENMVCLC;\n    end;\n    begin |- <CONDITION>  ::= <T CELL><REL OP><T NUMBER> -|\n       MCTYPE := 1;  MCCODE := 5;  GENMVCLC;\n    end;\n    begin |- <CONDITION>  ::= <T CELL><REL OP><STRING> -|\n       MCTYPE := 2;  MCCODE := 5;  GENMVCLC;\n    end;\n    begin |- <CONDITION>  ::= <T CELL> -|\n       R0 := #95FFS; EDIT; R0 := V(R7); R1 := T(R7);\n       if R0 > #FFFF then begin XR := 11; ERROR; end else\n       if R1 < 4 then begin XR := 6; ERROR; end;\n       EDIT; R1 := 7; INITCOND;\n$IFT D D\n       if TM(2,DBGFLGS); ON then SET(PRNT); |-- List flag tests --|\n$END D\n    end;\n    begin |- <CONDITION>  ::= \u00ac <T CELL> -|\n       R0 := #95FFS; EDIT; R0 := V1(R7); R1 := T1(R7);\n       if R0 > #FFFF then begin XR := 11; ERROR; end else\n       if R1 < 4 then begin XR := 6; ERROR; end;\n       EDIT; R1 := 9; INITCOND;\n$IFT D D\n       if TM(2,DBGFLGS); ON then SET(PRNT); |-- List flag tests --|\n$END D\n    end;\n    begin |- <CONDITION>  ::= <REL OP> -|\n       R1 := V(R7); INITCOND;\n       |-- HAD TO TAKE THIS ONE OUT OF THE WOODWORK ... --|\n    end;\n    begin |- <CONDITION>  ::= <RP><PRIM COND> ) -|\n       V(R7/8) := V1(R7); R0 := R0 -- R0 =: V(R7+8);\n    end;\n    begin |- <CONDITION>  ::= <UNARY REG> -|\n       short integer VH syn V(16);  |-- For <UNARY OP> list --|\n       if R0 := 6;  R0 \u00ac= VH(R7) then\n       begin  XR := 0;  ERROR;\n       end;  if R0 := 1;  R0 \u00ac= T(R7) then\n       begin XR := 7;  ERROR;\n       end;  R1 := LC =: V(R7+4);\n       R0 := #460 or V(R7) shll 4 =: PROGRAM(R1);\n       R0 := #47F0S =: PROGRAM(R1+4);\n       R0 := ENDCHAIN =: PROGRAM(R1+2) =: PROGRAM(R1+6);\n       R1 := @B1(4) =: V(R7);  R1 := @B1(4) =: LC;\n       R0 := R0 -- R0 =: V(R7+8);\n    end;\n    begin |- <CONDITION>  ::= \u00ac <UNARY REG> -|\n       short integer VH syn V(32);  |-- For <UNARY OP> list --|\n       if R0 := 6;  R0 \u00ac= VH(R7) then\n       begin  XR := 0;  ERROR;\n       end;  if R0 := 1;  R0 \u00ac= T1(R7) then\n       begin XR := 7;  ERROR;\n       end;  R1 := LC =: V(R7);\n       R0 := #460 or V1(R7) shll 4 =: PROGRAM(R1);\n       R0 := ENDCHAIN =: V(R7+4) =: PROGRAM(R1+2);\n       R0 := R0 -- R0 =: V(R7+8);  R1 := @B1(4) =: LC;\n    end;\n    begin |- <CONDITION>  ::= <K REG><BRINDX OP><K REG> -|\n       if R0 := 1; R0 \u00ac= T(R7) or R0 \u00ac= T2(R7) then\n       begin XR := 7; ERROR;\n       end; R0 := V1(R7) or V(R7) shll 4 or V2(R7);\n       R1 := LC =: V(R7); PROGRAM(R1) := R0;\n       R0 := ENDCHAIN =: PROGRAM(R1+2) =: V(R7+4);\n       R1 := @B1(4) =: LC; R0 := R0 -- R0 =: V(R7+8);\n    end;\n    begin |- <RP>         ::= ( -|\n       R1 := R7 - 16S; R1 := S(R1);\n       if R1\u00ac=IFTERM and R1\u00ac=DOTERM and R1\u00ac=COMPAOR\n       and R1\u00ac=RPTERM and R1\u00ac=REPUNTIL then SET(FLAG);\n    end;\n    begin |- <COND>       ::= <CONDITION> -|\n       R1 := R7 - 16S;  R1 := S(R1);\n       if R1 \u00ac= COMPAOR then SET(FLAG);\n    end;\n    begin |- <COMP COND>  ::= <CONDITION> -|\n       if R0 := V(R7+8); R0 \u00ac= 0 then\n       begin R1 := LC; R0 := R0 shll 4 or #4700 =: PROGRAM(R1);\n          R0 := V(R7+4) =: PROGRAM(R1+2);\n          V(R7) := R1; R1 := @B1(4) =: LC;\n       end;\n    end;\n    begin |- <COMP COND>  ::= <COMP AOR><COND> -|\n       if R0 := V1(R7+8); R0 \u00ac= 0 then\n       begin R1 := LC; R0 := R0 shll 4 or #4700 =: PROGRAM(R1);\n          R0 := V(R7) =: PROGRAM(R1+2);\n          V(R7) := R1; R1 := @B1(4) =: LC;\n       end else\n       begin R0 := V1(R7); R2 := @V(R7); MERGECHAIN;\n          R0 := V1(R7+4); R2 := @V(R7+4); MERGECHAIN;\n       end;\n    end;\n    begin |- <COMP AOR>   ::= <COMP COND> AND -|\n       R0 := LC + PTAG; R1 := V(R7+4); CHAINFIXUP; V(R7+4) := R1;\n    end;\n    begin |- <COMP AOR>   ::= <COMP COND> OR -|\n       R3 := @V(R7); ANDTORCHAIN;\n       R0 := LC + PTAG; R1:= V(R7); CHAINFIXUP; V(R7) := R1;\n    end;\n    begin |- <COND END>   ::= <COMP COND> END -|\n       R0 := LC =: V(R7+8); CLOSEBLOCK;\n    end;\n    begin |- <COND THEN>  ::= <COMP COND> THEN -|\n       R0 := LC; V(R7+8) := R0;\n    end;\n    begin |- <GOTO ST*>   ::= GOTO <ID> -|\n       V(R7/10) := V1(R7);\n    end;\n    begin |- <TRUE PART>  ::= <SIMPLE ST> ELSE -|\n       R0 := #F0; EMYTBRANCH; R0 := R0-R0; T(R7) := R0;\n    end;\n    begin |- <TRUE PART>  ::= <GOTO ST*> ELSE -|\n       R0 := 1; T(R7) := R0;\n       R3 := R7 - 16S; R0 := S(R3); R2 := LC;\n       if R0 = CONDEND then\n       begin R1 := V(R3+4); R4 := V(R3);\n          if R4 = ENDCHAIN or R4 := @PROGRAM(R4);\n             CLI(#47,B4); \u00ac= or CLI(#F0,B4(1)); < then\n          begin R4 := R1; R1 := R2; PROGRAM(R1+2) := R4;\n             R0 := #47F0S =: PROGRAM(R1); R2 := @B1(4) =: LC;\n          end;\n       end else if R0 \u00ac= CONDTHEN then goto X else\n       begin ANDTORCHAIN; R1 := V(R3+4); R2 := LC;\n       end; V(R3+8) := R2; R2 := R7; ENTERBRANCH;\n X: end;\n    begin |- <REPEAT>     ::= REPEAT --|\n       R0 := LC; V(R7) := R0;\n    end;\n    begin |- <WHILE>      ::= WHILE -|\n       R0 := LC; V(R7) := R0;\n    end;\n    begin |- <COND DO>    ::= <COMP COND> DO -|\n       R0 := LC + PTAG; V(R7+8) := R0;\n    end;\n    begin |- <ASS STEP>   ::= <K REG ASS> STEP <T NUMBER> -|\n       R1 := T(R7); R0 := T2(R7);\n       if R1\u00ac=1 or R0>1 then begin XR := 2; ERROR; end;\n       T(R7) := R0; R0 := V2(R7); V(R7+4) := R0;\n    end;\n    begin |- <LIMIT>      ::= UNTIL <K REG> -|\n       R0 := 1; if R0 \u00ac= T1(R7) then begin XR := 2; ERROR; end;\n       T(R7) := R0; R1 := V1(R7); V(R7) := R1;\n    end;\n    begin |- <LIMIT>      ::= UNTIL <T CELL> -|\n       R0 := T1(R7); if R0 > 1 then begin XR := 2; ERROR; end;\n       R0 := R0 + 4; T(R7) := R0; R1 := V1(R7); V(R7) := R1;\n    end;\n    begin |- <LIMIT>      ::= UNTIL <T NUMBER> -|\n       R0 := 20; T(R7) := R0; R1 := V1(R7); V(R7) := R1;\n    end;\n    begin |- <DO>         ::= DO -|\n       R0 := #F0; EMYTBRANCH;\n    end;\n    begin |- <IF PART>    ::= <IF><COND END> -|\n       LM(R0,R1,V1(R7)); V(R7) := R0;\n       R0 := V1(R7+8) + PTAG =: R5; CHAINFIXUP;\n       R0 := R5; R1 := R7 - 32S; R1 := V(R1); CHAINFIXUP;\n    end;\n    begin |- <IF PART>    ::= <IF><COND END><STATEMENT-> -|\n       LM(R0,R1,V1(R7)); V(R7) := R0;\n       R0 := V1(R7+8) + PTAG; CHAINFIXUP;\n       R0 := LC + PTAG; R1 := R7 - 32S; R1 := V(R1); CHAINFIXUP;\n    end;\n    begin |- <IF PART>    ::= <IF><COND END><GOTO ST> -|\n       R1 := V1(R7+4); R2 := V1(R7) =: V(R7);\n       if R2 = ENDCHAIN or R2 := @PROGRAM(R2);\n         CLI(#47,B2); \u00ac= or CLI(#F0,B2(1)); < then\n       begin R2 := R1; R1 := LC; PROGRAM(R1+2) := R2;\n          R0 := #47F0S =: PROGRAM(R1); R2 := @B1(4) =: LC;\n       end; R2 := @V2(R7); ENTERBRANCH;\n       R0 := LC + PTAG; R1 := R7 - 32S; R1 := V(R1); CHAINFIXUP;\n    end;\n    begin |- <IF PART>    ::= <IF><COND END><TRUE PART><STATEMENT-> -|\n       if R0 := T2(R7); R0 \u00ac= 0 then R0 := V1(R7+8) else\n       begin R0 := V1(R7+8) + PTAG; R1 := V1(R7+4); CHAINFIXUP;\n          R0 := LC+PTAG; R1 := V2(R7); CHAINFIXUP; R0 := 4+V2(R7);\n       end;\n       R0 := R0 + PTAG; R1 := R7 - 32S; R1 := V(R1); CHAINFIXUP;\n       R0 := V1(R7) =: V(R7);\n    end;\n    begin |- <IF PART>    ::= <IF><COND END><TRUE PART><GOTO ST> -|\n       R1 := R7 - 32S; R1 := V(R1); R2 := @V(R7+48); ENTERBRANCH;\n       R0 := V1(R7) =: V(R7);\n       if R0 := T2(R7); R0 = 0 then\n       begin R0 := V1(R7+8) + PTAG; R1 := V1(R7+4); CHAINFIXUP;\n          R0 := V2(R7) =: LC;\n       end;\n    end;\n    begin |- <STATEMENT+> ::= <BLOCKBODY><IF PART> -|\n       R0 := V1(R7) =: V(R7);\n    end;\n    begin |- <STATEMENT-> ::= <IF><COND THEN><STATEMENT-> -|\n       R0 := V1(R7+8) + PTAG; R1 := V1(R7+4); CHAINFIXUP;\n       R0 := LC + PTAG; R1 := V1(R7); CHAINFIXUP;\n    end;\n    begin |- <STATEMENT-> ::= <IF><COND THEN><GOTO ST> -|\n       R3 := @V1(R7); ANDTORCHAIN;\n       R1 := V1(R7+4); R2 := @V2(R7); ENTERBRANCH;\n       R0 := LC + PTAG; R1 := V1(R7); CHAINFIXUP;\n    end;\n    begin |- <STATEMENT-> ::= <IF><COND THEN><TRUE PART><STATEMENT-> -|\n       if R0 := T2(R7); R0 \u00ac= 0 then R0 := V1(R7+8) else\n       begin R0 := V1(R7+8) + PTAG; R1 := V1(R7+4); CHAINFIXUP;\n          R0 := LC + PTAG; R1 := V2(R7) =: R5; CHAINFIXUP;\n          R0 := @B5(4);\n       end;\n       R0 := R0 + PTAG; R1 := V1(R7); CHAINFIXUP;\n    end;\n    begin |- <STATEMENT-> ::= <IF><COND THEN><TRUE PART><GOTO ST> -|\n       if R0 := T2(R7); R0 \u00ac= 0 then\n       begin LM(R1,R2,V1(R7)); if R2 = ENDCHAIN or R2 := @PROGRAM(R2);\n             CLI(#47,B2); \u00ac= or CLI(#F0,B2(1)); < then\n          begin R2 := R1; R1 := LC; PROGRAM(R1+2) := R2;\n             R0 := #47F0S =: PROGRAM(R1); R2 := @B1(4) =: LC;\n          end;\n       end else\n       begin R0 := V1(R7+8) + PTAG; R1 := V1(R7+4); CHAINFIXUP;\n          R0 := V2(R7) =: LC; R1 := V1(R7);\n       end;\n       R2 := @V(R7+48); ENTERBRANCH;\n    end;\n    begin |- <STATEMENT-> ::= <WHILE><COND DO><STATEMENT+> -|\n       R0 := V1(R7+8); R1 := V1(R7+4); CHAINFIXUP;\n       R0 := V(R7) + PTAG; R1 := V2(R7); CHAINFIXUP;\n    end;\n    begin |- <STATEMENT-> ::= <WHILE><COND DO><STATEMENT*> -|\n       if R1 := V1(R7); R1 := @B1(4); R1 \u00ac= LC then\n       begin  |-- NORMAL CASE, NOT A NULL STATEMENT --|\n          R0 := V1(R7+8); R1 := V1(R7+4); CHAINFIXUP;\n          R0 := #F0; R2 := V(R7); EMYTBRANCH;\n          R1 := V(R7); R0 := R2 + PTAG; CHAINFIXUP;\n       end else\n       begin  |-- HERE TO OPTIMIZE A NULL STATEMENT --|\n          R3 := @V1(R7); ANDTORCHAIN;\n          R0 := V(R7) + PTAG; R1 := V1(R7+4); CHAINFIXUP;\n       end;\n       R0 := LC + PTAG; R1 := V1(R7); CHAINFIXUP;\n    end;\n    end; LM(R1,R5,SAVEREG);\n    end;\n$PAGE\nsegment procedure EXECUTE4(R4);  |-- XEQ3 < RULES <= XEQ4 --|\n    begin  procedure MOVEID (R1);\n    begin  V(R7/10) := V1(R7); R0 := T1(R7); STC(R0,T(R7));\n    end;   procedure TAGCELL (R5);  |-- DOES NOT RETURN --|\n    begin  if R3 >= 4096S then begin XR := 12; ERROR; end;\n       R0 := DBREG shll 12 or R3; R1 := @V1(R7);\n       DC1 := R3; R3 := R3 + V(R7); DC := R3;\n       R4 := DATAESDADR;  R3 := PL360NO(R4);\n       R3 := R3 shll 8;  R2 := R2 or R3;  R3 := T1(R7);\n$IFT M M\n       if TESTFLAG then ENTERSYMDATA;\n$END M\n       ENTERNAME;  goto EXIT;\n    end;\n    R1 := R1 - XEQ3;  case R1 of begin  |-- EXECUTE4'S RULES --|\n    begin |- <STATEMENT-> ::= <REPEAT> UNTIL <PRIM COND> -|\n       R0 := V(R7) + PTAG; R1 := V2(R7); CHAINFIXUP;\n       R0 := LC + PTAG; R1 := V2(R7+4); CHAINFIXUP;\n    end;\n    begin |- <STATEMENT-> ::= FOR <ASS STEP><LIMIT><DO><STATEMENT*> -|\n       R5 := V1(R7+4); R2 := V1(R7); R1 := 10; EMITLIT;\n       R1 := V(R7+48); R0 := LC + PTAG;\n       PROGRAM(R1+2) := R0; R0 := T2(R7);\n       R1 := 9; R2 := V1(R7); R3 := V2(R7); R5 := R3;\n       if R0 = 1 then EMIT else\n       if R0 = 20S then EMITLIT else EMYT;\n       R0 := 4; R1 := 7; R3 := 4 + V(R7+48) + PTAG;\n       R2 := V1(R7+4); if R2 >= 0 then R2 := 12 else R2 := 10; EMYT;\n    end;\n    begin |- <STATEMENT*> ::= <GOTO ST> -|\n       R1 := LC; R0 := #47F0S; PROGRAM(R1) := R0;\n       R0 := ENDCHAIN; PROGRAM(R1+2) := R0; R0 := 4 + R1; LC := R0;\n       R2 := @V(R7); ENTERBRANCH;\n    end;\n    begin |- <SI T TYPE>  ::= SHORT INTEGER -|\n       R0 := R0-R0; T(R7) := R0; R0 := 2; V(R7) := R0;\n    end;\n    begin |- <SI T TYPE>  ::= INTEGER -|\n       R0 := 1; T(R7) := R0; R0 := 4; V(R7) := R0;\n    end;\n    begin |- <SI T TYPE>  ::= LOGICAL -|\n       R0 := 1; T(R7) := R0; R0 := 4; V(R7) := R0;\n    end;\n    begin |- <SI T TYPE>  ::= REAL -|\n       R0 := 3; T(R7) := R0; R0 := 4; V(R7) := R0;\n    end;\n    begin |- <SI T TYPE>  ::= LONG REAL -|\n       R0 := 2; T(R7) := R0; R0 := 8; V(R7) := R0;\n    end;\n    begin |- <SI T TYPE>  ::= BYTE -|\n       R0 := 4; T(R7) := R0; R0 := 1; V(R7) := R0;\n    end;\n    begin |- <SI T TYPE>  ::= CHARACTER -|\n       R0 := 4; T(R7) := R0; R0 := 1; V(R7) := R0;\n    end;\n    begin |- <T TYPE>     ::= <SI T TYPE> -|\n       RESET(FILLFLAG);  |-- No dynamic fill --|\n    end;\n    begin |- <T TYPE>     ::= ARRAY <T NUMBER><SI T TYPE> -|\n       R1 := T2(R7); T(R7) := R1; R0 := T1(R7);\n       R1 := V2(R7); R2 := V1(R7); RESET(FILLFLAG);\n       if R2 = DTFILL then  |-- DATAFILL --|\n       begin  R2 := R2-R2;  SET(FILLFLAG);\n       end;  if R0>1 or R2<0 then  |-- INVALID NUMBER --|\n       begin XR := 25; ERROR;\n       end else R1 := R1 * R2; V(R7) := R1;\n    end;\n    begin |- <FILL>       ::= <STRING> -|\n       if SKIPFLAG then goto X;\n       R1 := V(R7); SETDATAINIT; if R1 = 0 then goto X;\n       REDUCE(R1);  EX(R1,MVC(0,B2,STRINGV));\n X: end;\n    begin |- <FILL>       ::= <ADR OP><T CELL> -|\n       if SKIPFLAG then goto X;\n       R5 := FILLTYPE; R1 := R1-R1; IC(R1,ALENGTH(R5));\n       R1 := @B1(1); SETDATAINIT; if R1 = 0 then goto X;\n       R0:=V1(R7); R1:=V(R7); if R1=0 then\n       begin if R5>1 then XR:=24 else\n          if R5=0 and R0>#FFFF then XR:=11 else\n          begin if R5=0 then B2(0/2) := V1(R7+2) else\n             B2(0/4) := V1(R7); goto X;\n          end;\n       end else\n       begin if R5\u00ac=1 then XR:=24 else\n          if R0>#FFFF then XR:=11 else\n          if REPFLAG then XR:=30 else goto Z;\n       end;\n       ERROR; SET(SKIPFLAG); goto X;\n Z:    R1:=R0 and #FFF; R4:=V1(R7+4) shll 24;\n       R1:=R1 or R4;  V1(R7):= R1;  MVC(3,B2,V1(R7));\n       R4:=V1(R7+8) shrl 8;   |-- R4=SEGMENT NUMBER --|\n       R3 := R4*10S;  R3 := @ESDNAME(R3);\n       if R4 >= MAXSEGNO or B3 = \"DUMMY   \" then\n       if SEGTYPE(R10) > 2 then goto X else\n       begin  XR := 30; ERROR; goto X;\n       end;\n       R0:=DATAESDEND;R1:=DATAESDADR; R2:=ER; R3:=ATYPE; FINDESDENTRY;\n       if R0=DATAESDEND then  |-- NOT A NEW ENTRY --|\n       begin R2:=RLD; R5:=R1-DATAESDADR; R1:=R0; FINDESDENTRY;\n          ESDLINK(R1):=R5;  |-- RLD ENTRY POINTING TO MAIN ENTRY --|\n       end;\n       DATAESDEND:=R0; R0:=DC1-4; RLDADDR(R1):=R0;\n X: end;\n    begin |- <FILL>       ::= <ADR OP><PROC ID> -|\n       if SKIPFLAG then goto X;\n       R5:=FILLTYPE; R1:=R1-R1; IC(R1,ALENGTH(R5));\n       R1 := @B1(1); SETDATAINIT; if R1=0 then goto X;\n       R0:=V1(R7) shrl 24; R1:=V(R7); if R1=0 then\n       begin if R5>1 then XR:=24 else\n          begin  R0:=V1(R7); SRDL(R0,12); R0:=R0 shrl 8 and #F;\n             SLDL(R0,12); V1(R7):=R0; if R5=0 then\n             B2(0/2) := V1(R7+2) else B2(0/4) := V1(R7); goto X;\n          end;\n       end else\n       begin if R5\u00ac=1 then XR:=24 else\n          if REPFLAG then XR:=30 else goto Z;\n       end;\n       ERROR; SET(SKIPFLAG); goto X;\n Z:    R1:=V1(R7) and #FFF; V1(R7):=R1; B2(0/4) := V1(R7); R4:=R0;\n       R0:=DATAESDEND;R1:=DATAESDADR; R2:=ER; R3:=ATYPE; FINDESDENTRY;\n       if R0=DATAESDEND then  |-- NOT A NEW ENTRY --|\n       begin R2:=RLD; R5:=R1-DATAESDADR; R1:=R0; FINDESDENTRY;\n          ESDLINK(R1):=R5;  |-- RLD ENTRY POINTING TO MAIN ENTRY --|\n       end;\n       DATAESDEND:=R0; R0:=DC1-4; RLDADDR(R1):=R0;\n X: end;\n    begin |- <FILL>       ::= <T NUMBER> -|\n       if SKIPFLAG then goto X;\n       R5 := FILLTYPE; R1 := R1-R1; IC(R1,ALENGTH(R5));\n       R1 := @B1(1); SETDATAINIT; if R1 = 0 then goto X;\n       IC(R5,LENGTH(R5)); R5 := @B5(1);\n       case R5 of begin\n          B2(0/1) := V(R7+3);  |-- BYTE FILL --|\n          B2(0/2) := V(R7+2);  |-- HALF WORD FILL --|\n          B2(0/4) := V(R7);  |-- FULL WORD FILL --|\n          begin  |-- DOUBLE WORD FILL --|\n             R3 := T(R7); if R3 = 1 then\n             begin LM(R3,R4,V(R7)); R5 := R3; STM(R4,R5,V(R7));\n             end; B2(0/8) := V(R7);\n          end;\n       end;\n X: end;\n    begin |- <FILL>       ::= <REP LIST2> ) -|\n       if SKIPFLAG then goto X;\n       R1 := V(R7) - 1; if R1 = 0 then goto X;\n       R5 := DC1 - V(R7+4); R1 := R1 * R5;\n       SETDATAINIT; if R1 = 0 then goto X;\n       R4 := R2; R2 := R1 - 1; R1 := R1 + R4; R3 := V(R7+8);\n       while R4 < R1 do\n       begin  R5 := R2;  while R5 >= 256S do\n          begin  B4(0/256) := B3;  |-- MOVE DATA FIELD --|\n             R3 := @B3(256);  R4 := @B4(256);  R5 := R5 - 256S;\n          end;  EX(R5,MVC(0,B4,B3));  R4 := @B4(R5+1);\n       end;\n X:    R0 := T(R7);  STC(R0,SKIPFLAG);\n       R0:=R0 shrl 8; STC(R0,REPFLAG);\n    end;\n    begin |- <REP LIST1>  ::= <T NUMBER> ( -|\n       IC(R2,REPFLAG); R2:=R2 shll 8;\n       R0 := V(R7); R1 := T(R7); IC(R2,SKIPFLAG); T(R7) := R2;\n       if R0<0 or R1>1 then begin XR := 25; SET(SKIPFLAG); ERROR; end;\n       if R0=0 then SET(SKIPFLAG) else if R0>1 then SET(REPFLAG);\n       R1 := R1-R1; SETDATAINIT; V(R7+8) := R2;\n       R0 := DC1; V(R7+4) := R0;\n    end;\n    begin |- <REP LIST1>  ::= ( -|\n       R1 := R7 - 16S; R2 := S(R1); if R2 = REPLIST1 or R2 = TDECL3 then\n       begin\n          R0 := 1; V(R7) := R0; R0 := DC1; V(R7+4) := R0;\n          IC(R2,REPFLAG); R2:=R2 shll 8;\n          IC(R2,SKIPFLAG); T(R7) := R2;\n          R1 := R1-R1; SETDATAINIT; V(R7+8) := R2;\n       end else SET(FLAG);\n    end;\n    begin |- <T DECL1>    ::= <T TYPE><ID> -|\n       if NODATASEG then DATASEGERROR;\n       R1 := R1-R1; R2 := T(R7); IC(R1,ALENGTH(R2));\n       R3 := DC+R1; R1 := @B1(1); R1 := neg R1; R3 := R3 and R1;\n$IFT D D\n       if R3 \u00ac= DC then SET(PRNT);\n$END D\n       TAGCELL;  |-- DOES NOT RETURN HERE --|\n    end;\n    begin |- <T DECL1>    ::= <T DECL2><ID> -|\n       R3 := DC; R2 := T(R7);\n       TAGCELL;  |-- DOES NOT RETURN HERE --|\n    end;\n    begin |- <T DECL1>    ::= <T TYPE> -|\n       if NODATASEG then DATASEGERROR;\n       R1 := R1 - R1; R2 := T(R7); IC(R1,ALENGTH(R2));\n       R3 := DC+R1; R1 := @B1(1); R1 := neg R1; R3 := R3 and R1;\n       if R3 > 4096S then begin XR := 12; ERROR; end;\n$IFT D D\n       if R3 \u00ac= DC then SET(PRNT);\n$END D\n       DC1 := R3; R3 := R3 + V(R7); DC := R3;\n    end;\n    begin |- <T DECL1>    ::= <T DECL2> -|\n       R3 := DC; if R3 > 4096S then begin XR := 12; ERROR; end;\n       DC1 := R3; R3 := R3 + V(R7); DC := R3;\n    end;\n    begin |- <T DECL3>    ::= <T DECL1> = -|\n       R0 := T(R7); FILLTYPE := R0; R0 := SEGTYPE(R10);\n       if R0 \u00ac= 2 then RESET(SKIPFLAG) else\n       begin XR := 30; ERROR;\n       end;\n    end;\n    begin |- <T DECL4>    ::= <T DECL3><FILL> -|\n       R2 := T(R7);  R1 := R1-R1;  IC(R1,ALENGTH(R2));\n       R2 := DC + R1;  R1 := @B1(1);  R1 := neg R1;\n       R2 := R2 and R1;  |-- New ending --|\n$IFT D D\n       if R2 \u00ac= DC then SET(PRNT);  |-- Non-aligned --|\n$END D\n       DC := R2;  SET(SKIPFLAG);\n    end;\n    begin |- <FUNC DC2>   ::= <FUNC DC1><ID> -|\n       MOVEID;   |-- MOVE V AND T FIELDS --|\n    end;\n    begin |- <FUNC DC4>   ::= <FUNC DC3><T NUMBER> -|\n       R1 := V1(R7);\n       if R1 < 0 or R1 >= FT then\n       begin XR := 23; ERROR; R1 := R1-R1;\n       end;\n       STC(R1,T(R7+1));\n    end;\n    begin |- <FUNC DC6>   ::= <FUNC DC5><T NUMBER> -|\n       array FT byte TYPE =  |-- Function lengths --|\n          (_2,_2,0,0,0,2,_2,_2,0,0,2,0,0,2,2,0,0,0,0,0);\n       R2 := V1(R7);  R3 := T(R7);  R1 := #FF and R3;\n       if R2 < 0 or R2 > #FFFF then goto ERR;\n       R0 := R1 shll 16 or R2;  R3 := R3 shrl 8;\n       R2 := R2 shrl 14 - 1 and #FE;  IC(R1,TYPE(R1));\n       if R1 \u00ac= R2 then goto ERR;\n       R1 := @V(R7);  R2 := 11;  ENTERNAME;  goto X;\n ERR:  XR := 23;  ERROR;\n X: end;\n    begin |- <SYN DC1>    ::= <T TYPE><ID> SYN -|\n       MOVEID;   |-- MOVE V AND T FIELDS --|\n    end;\n    begin |- <SYN DC1>    ::= <SI T TYPE> REGISTER <ID> SYN -|\n       R0 := T(R7); V(R7/10) := V2(R7);\n       if R0=0 or R0>3S then begin XR := 7; ERROR; R0 := 1; end;\n       R0 := R0 + 80S; T(R7) := R0; R0 := T2(R7); STC(R0,T(R7));\n    end;\n    begin |- <SYN DC1>    ::= <SYN DC3><ID> SYN -|\n       MOVEID;   |-- MOVE V AND T FIELDS --|\n    end;\n    begin |- <SYN DC2>    ::= <SYN DC1><T CELL> -|\n       R0 := V1(R7); R1 := @V(R7); R2 := T(R7);\n       R3 := R2 shrl 8; R2 := R2 and #FF;\n       if R2 > 80S then begin XR := 26; ERROR; end else begin\n$IFT M M\n          if TESTFLAG then ENTERSYMDATA;\n$END M\n          R2 := R2 or V1(R7+8);  ENTERNAME;  end;\n    end;\n    begin |- <SYN DC2>    ::= <SYN DC1><T NUMBER> -|\n       R0 := V1(R7); R1 := @V(R7); R2 := T(R7);\n       R3 := R2 shrl 8; R2 := R2 and #FF; R4 := T1(R7);\n       if R0<0 or R4>1 then begin XR := 25; ERROR; end else\n       if R2 > 80S then begin XR := 26; ERROR; end else\n       begin  R2 := R2 or #FF00;  ENTERNAME;  end;\n    end;\n    begin |- <SYN DC2>    ::= <SYN DC1><K REG> -|\n       R0 := V1(R7); R1 := @V(R7); R2 := T(R7);\n       R3 := R2 shrl 8; R2 := R2 and #FF;\n       if R2 < 80S then begin XR := 26; ERROR; end else ENTERNAME;\n    end;\n    begin |- <EQUATE>     ::= SHORT EQUATE -|\n       R0 := 15;  S(R7-2) := R0;  |-- SHORT EQUATE type --|\n    end;\n    begin |- <EQUATE>     ::= EQUATE -|\n       R0 := 12;  S(R7-2) := R0;  |-- EQUATE type --|\n    end;\n    begin |- <PROC HD1>   ::= PROCEDURE <ID> -|\n       R2 := 10; R3 := T1(R7); T(R7) := R3;\n$IFT M M\n       if TESTFLAG then\n       begin R0 := LC; R1 := 3; ENTERSYMLABEL;\n       end;\n$END M\n       R1 := @V1(R7); R0 := R0-R0;\n       ENTERNAME; V(R7) := R4;\n    end;\n    begin |- <PROC HD3>   ::= <PROC HD2><K REG> -|\n       R1 := V1(R7); R2 := T1(R7); V(R7+4) := R1;\n       if R2\u00ac=1 or R1=0 then\n       begin XR := 7; ERROR;\n       end;\n    end;\n    begin |- <PROC HD5>   ::= GLOBAL <PROC HD4> -|\n       R1 := R7 - 16S;  R1 := S(R1);\n       if R1 = ENDFILE then SET(FLAG) else\n       begin\n          R0 := 1; T(R7) := R0; V(R7/8) := V1(R7); OPENPROCSEG;\n          R2 := CSEGNO*10S; R2 := @ESDNAME(R2); R1 := T1(R7) - 1;\n          R3 := V(R7); B2(0/10) := BLANK; EX(R1,MVC(0,B2,NAME(R3)));\n       end;\n    end;\n    begin |- <PROC HD5>   ::= EXTERNAL <PROC HD4> -|\n       R0 := 3; T(R7) := R0; V(R7/8) := V1(R7); OPENPROCSEG;\n       R2 := CSEGNO * 10S; R2 := @ESDNAME(R2); R1 := T1(R7) - 1;\n       R3 := V(R7); B2(0/10) := BLANK; EX(R1,MVC(0,B2,NAME(R3)));\n    end;\n    begin |- <PROC HD5>   ::= SEGMENT <PROC HD4> -|\n       R0 := 1; T(R7) := R0; V(R7/8) := V1(R7); OPENPROCSEG;\n       R2 := CSEGNO; CVD(R2,CONWORK); R2 := R2 * 10S;\n       R2:=@ESDNAME(R2); B2(0/10) := SEGNAM;\n       UNPK(2,7,B2(4),CONWORK); SETZONE(B2(6));\n    end;\n    begin |- <PROC HD6>   ::= COMMON <PROC HD4> -|\n       R5 := LC; if R5 \u00ac= PROCBR then\n       begin PROCLK := R5; R4 := #47F0S; PROGRAM(R5) := R4;\n          R5 := @B5(4);\n       end;  V(R7/8) := V1(R7);  R0 := R0-R0;  T(R7) := R0;\n$IFT M M\n       if TESTFLAG then\n       begin  R4 := PROCPTR;  DISPFIELD(R4) := R5;  end;\n$END M\n       INCRSEGNO;  R4 := R0;  R1 := PROGESDADR;\n       R2 := PBREG;  R3 := R2 shll 4 + R2 + #5800S;\n       PROGRAM(R5) := R3;  R0 := RLDADDR(R1);  PROGRAM(R5+2) := R0;\n       RLDADDR(R1) := R5;  R3 := ATYPE;  R2 := LD;\n       R0 := PROGESDEND;  FINDESDENTRY;  PROGESDEND := R0;\n       RLDADDR(R1) := R5;  R5 := @B5(4);  LC := R5;\n       R4 := R4 * 10S;  R4 := @ESDNAME(R4);  R3 := V(R7);\n       B4(0/10) := BLANK;  R2 := T1(R7) - 1;\n       EX(R2,MVC(0,B4,NAME(R3)));  ADR(R3+2) := R5;\n       R0 := CSEGNO shll 8;  R1 := PBREG shll 4\n          or R0 or V(R7+4);  ADR(R3) := R1;\n    end;\n    begin |- <PROC HD6>   ::= <PROC HD4> -|\n       R5 := LC; if R5 \u00ac= PROCBR then\n       begin PROCLK := R5; R4 := #47F0S; PROGRAM(R5) := R4;\n          R5 := R5 + 4; LC := R5;\n       end;\n$IFT M M\n       if TESTFLAG then\n       begin  R4 := PROCPTR;  DISPFIELD(R4) := R5;  end;\n$END M\n       R4 := V(R7); ADR(R4+2) := R5; R0 := CSEGNO shll 8;\n       R1 := PBREG shll 4 or R0 or V(R7+4); ADR(R4) := R1;\n       R0 := R0-R0; T(R7) := R0;\n    end;\n    begin |- <PROC HD6>   ::= <PROC HD5> -|\n      R1 := V(R7); R2 := PBREG shll 4 or V(R7+4);\n      R4 := CSEGNO shll 8 or R2; ADR(R1) := R4;\n    end;\n    begin |- <PROC HD6>   ::= <PROC HD5> BASE <K REG> -|\n      R0 := T2(R7); R1 := V2(R7); PBREG := R1;\n      if R0\u00ac=1 or R1=0 then begin XR := 7; ERROR; end;\n      R1 := V(R7); R2 := PBREG shll 4 or V(R7+4);\n      R4 := CSEGNO shll 8 or R2; ADR(R1) := R4;\n    end;\n    begin |- <PROC HD7>   ::= <PROC HD6> ; -|\n       R1 := PBREG shll 12; PTAG := R1;\n    end;\n    begin |- <GLOB HD1>   ::= GLOBAL <PROC HD4> -|\n       R0 := 1; T(R7) := R0; V(R7/8) := V1(R7); OPENPROCSEG;\n       R2 := CSEGNO * 10S; R2 := @ESDNAME(R2); R1 := T1(R7) - 1;\n       R3 := V(R7); B2(0/10) := BLANK; EX(R1,MVC(0,B2,NAME(R3)));\n       if SEGNAM = \"SEG\" then\n       begin  SEGNAM(1) := \"NN\";  R3 := 2;\n          if R1 > R3 then R1 := R3;  EX(R1,MVC(0,SEGNAM,B2));\n       end;\n    end;\n    begin |- <GLOB HD>    ::= <GLOB HD1> BASE <K REG> -|\n      R0 := T2(R7); R1 := V2(R7); PBREG := R1;\n      if R0\u00ac=1 or R1=0 then begin XR := 7; ERROR; end;\n    end;\n    end; EXIT: LM(R1,R5,SAVEREG);\n    end;\n$PAGE\n segment procedure BRANCHFIXUP(R8);\n begin  |-- This routine does branch optimization --|\n    dummy base R2;\n       byte OPCODE, COND;\n       short integer NEXT;\n       short integer OP syn OPCODE;\n    close base;\n    short integer WORK syn CONWORK;\n    R12 := N6 =: R0 + BRANCHBASE; R1 := BRANCHADR(R12) =: N6;\n    R3 := N5 + BRANCHBASE; R0 := R0 - 4S; if < then R0 := R0 -- R0;\n    N5 := R0; while R12 := @B12(4); R12 <= R3 do\n    begin R2 := BRANCHADR(R12) and #FFFF;\n       if OPTFLAG < #80 then goto B;  R0 := @PROGRAM(0) - PTAG;\n       while R2 := R2 + R0; OPCODE=#07 or OPCODE=#47 do\n       begin if OPCODE = #07 then\n          begin if TM(#0F,COND); OFF or TM(#F0,COND); OFF then\n             R2 := @B2(2) - R0 else\n             if MIXED then goto A else R2 := OP shll 12;\n          end else\n          if TM(#F0,COND); OFF then R2 := @B2(4) - R0 else\n          if CLI(#F0,COND); \u00ac= then goto A else\n          begin if R1 := NEXT; R1 >= ENDCHAIN and R1 < 4096S then\n             begin R0 := BRANCHAIN(R12) =: NEXT; R0 := R1; R4 := R2;\n                while R1 := NEXT; R1 \u00ac= ENDCHAIN and\n                      if < or R1 >= 4096S then goto X;\n                      R14 := @PROGRAM(R1); R14 \u00ac= R4 do R2 := R14;\n                NEXT := R0; if R1 = ENDCHAIN then goto X;\n                BRANCHAIN(R12) := R1; R2 := BRANCHADR(R12);\n             end else R2 := R1;\n          end; R2 := R2 and #FFFF; R1 := R2 and #F000;\n          if R1 \u00ac= PTAG then goto B;\n          if R1 := BRANCHADR(R12) and #FFFF; R2 = R1 then\n          begin R1 := 1 + ERRCOUNT =: ERRCOUNT;\n             if R1 > ERRLIMIT then goto B;\n             WBUFF(0/125) := BLANK; WBUF(11) := \"INFINITE LOOP AT\";\n             WORK := R2; NI(#0F,WORK); UNPK(4,2,WBUF(12+STRING),WORK);\n             TR(3,WBUF(12+STRING),TRTABLE(_240));\n             WBUF(16+STRING) := \" \"; WBUF(108) := \"*\";\n             WBUF(109/16) := WBUF(108); RESET(RUNFLAG);\n             if GENFLAG then RESET(GENDECK); PRINT;\n             if R1 = ERRLIMIT then ENDMESSAGES;\n             goto B;\n          end;\n       end;\n A:    R2 := R2 -- R0;\n B:    R1 := BRANCHAIN(R12); while R1 >= 0 do\n       begin R0 := PROGRAM(R1+2); PROGRAM(R1+2) := R2; R1 := R0;\n       end;\n X: end;\n end;\n$PAGE\n procedure SETNAME (R4);\n begin  R0 := EQUHOLD; R1 := @V(R7); R3 := T(R7);\n    if R3 \u00ac= 0 then ENTERNAME;  goto EXIT;\n end;\n procedure CHKEQUATE (R4);\n begin  R0 := 1;   CLI(1,T2(R7+1));  if > then\n    begin  SAVE := R4;  XR := 25;  ERROR;\n       R4 := SAVE;  R0 := R0-R0;  T(R7) := R0;\n    end;  LTR(R0,R0);\n end;\n procedure EQUARITH (R4);\n begin function SETUP(6,#0500);\n    SAVE := R4;  |- Save return -|\n    R0 := EQUHOLD; SRDA(R0,32); R3 := V2(R7);\n    R2 := V1(R7) - 10S + R2;  if < then\n    begin  XR := 4;  ERROR;  R2 := R2-R2;  R3 := R2;\n    end;  if R3 = 0 and R2 = 6 then\n    begin  |-- DIVISION BY ZERO --| XR := 19; ERROR; R3 := 1;\n    end; SETUP(R5); EX(R0,B5(R2+8)); goto X;\n       R1 := R1 + R3;\n       R1 := R1 - R3;\n       R1 := R1 * R3;\n       R1 := R1 / R3;\n       R1 := R1 ++ R3;\n       R1 := R1 -- R3;\n X: EQUHOLD := R1;  R4 := SAVE;\n end;\n  |-- MAIN CODE OF EXECUTE PROCEDURES --|\n STM(R1,R5,SAVEREG);\n if R1 <= XEQ2 then  |-- Low range --|\n begin  if R1 <= XEQ1 then EXECUTE1;  EXECUTE2;  end;\n if R1 <= XEQ4 then  |-- Mid range --|\n begin  if R1 <= XEQ3 then EXECUTE3;  EXECUTE4;  end;\n  |-- XEQ4 < RULES <= END --|\n    R1:=R1 - XEQ4; case R1 of begin\n    begin |- <DSEG TYPE>  ::= GLOBAL DATA <ID> -|\n       R0 := 1; T(R7) := R0; V(R7/10) := V2(R7); INCRSEGNO;\n    end;\n    begin |- <DSEG TYPE>  ::= EXTERNAL DATA <ID> -|\n       R0 := 3; T(R7) := R0; V(R7/10) := V2(R7); INCRSEGNO;\n    end;\n    begin |- <DSEG TYPE>  ::= COMMON DATA <ID> -|\n       R0 := 2; T(R7) := R0; V(R7/10) := V2(R7); INCRSEGNO;\n    end;\n    begin |- <DSEG TYPE>  ::= COMMON -|\n       R0 := 2; T(R7) := R0; V(R7/10) := BLANK; INCRSEGNO;\n    end;\n    begin |- <DSEG TYPE>  ::= SEGMENT -|\n       R0:=1; T(R7):=R0; V(R7/10) := SEGNAM; INCRSEGNO;\n       CVD(R0,CONWORK); UNPK(2,7,V(R7+4),CONWORK); SETZONE(V(R7+6));\n    end;\n    begin |- <DSEG TYPE>  ::= DUMMY -|\n       R0 := 4;  T(R7) := R0;  R0 := MAXSEGNO;\n       if NODATASEG and R0 > NSEGNO then SEGNO := R0 else INCRSEGNO;\n    end;\n    begin |- <DECL>       ::= <PROC HD7><STATEMENT*> -|\n       R0 := V(R7+4) or #07F0;  |-- EMIT RETURN INSTRUCTION --|\n       R4 := LC; PROGRAM(R4) := R0; R4 := R4 + 2;\n       R0 := T(R7); if R0 \u00ac= 0 then\n       begin  |-- CLOSE PROCEDURE SEGMENT --|\n          for R1 := 14 + N4 step 14S until N3 do LABELERROR;\n          ALLOCATELITERALS;\n          if R4 > 4096S then\n          begin R0 := R4; XR := 16; ERROR; R4 := R0;\n          end; LC := R4;\n$IFT M M\n          if TESTFLAG then\n          begin R0 := R4 - 2S; R1 := 5; ENTERSYMLABEL; end;\n$END M\n          BRANCHFIXUP;  |-- DO BRANCH OPTIMIZATION --|\n          R0 := LC; R1 := LASTINITIAL(R9); INITIALEN(R1) := R0;\n          R0 := PROGESDEND; R1 := PROGESDADR; R5 := R9; CLOSESEG;\n          R5 := PREVSEG(R5); UNSTACKSEG; PROGESDEND := R0;\n          R9 := R5; R3 := PBREG shll 12; PTAG := R3; R2 := N4;\n          R2 := R2 + LABELBASE; R0 := LABELADR(R2); N4 := R0;\n          R0 := LABEL(R2+8); CSEGNO := R0;\n          R2 := R2 - LABELBASE;\n          if R2 \u00ac= 0 then R2 := R2 - 14S; N3 := R2;\n       end else\n       begin R3 := R4 + PTAG; R2 := PROCLK;\n          PROGRAM(R2+2) := R3; PROCBR := R4; LC := R4;\n       end;\n    end;\n    begin |- <DECL>       ::= <DSEG TYPE> BASE <K REG> -|\n       R1 := T2(R7); R2 := V2(R7);\n       if R1 \u00ac= 1 then begin XR := 7; ERROR;  end;\nY:     R0 := DATAESDEND; R1 := DATAESDADR; R5 := R10;\n       if NODATASEG then RESET(NODATASEG) else STACKSEG;\n$IFF M M\n       R2 := T(R7); R3 := V2(R7); OPENSEG; R10 := R5;\n$END M\n$IFT M M\n       R2 := T(R7) + #010000; R3 := V2(R7); OPENSEG; R10 := R5;\n$END M\n       R0 := R1; R2 := T(R7); if R2 = 2 then R2 := CM else R2 := SD;\n       R3 := ATYPE; R4 := SEGNO; FINDESDENTRY; DATAESDEND := R0;\n       R0 := R0-R0; R2 := T(R7); if R2 \u00ac= 4 and R0 \u00ac= V2(R7) then\n       begin R0 := PROGESDEND; R1 := PROGESDADR;\n          CLC(9,V(R7),BLANK);\n          if = and R2=2 then R2:=XCM else R2:=ER;\n          R3 := ATYPE; R4 := SEGNO; FINDESDENTRY; PROGESDEND := R0;\n          R2 := RLDADDR(R1); R3 := LC; PROGRAM(R3+2) := R2;\n          RLDADDR(R1) := R3; R0 := V2(R7) shll 4 or #5800;\n          PROGRAM(R3) := R0; R3 := R3 + 4; LC := R3;\n       end;\n       R1 := SEGNO * 10S; R1 := @ESDNAME(R1); B1(0/10) := V(R7);\n    end;\n    begin |- <DECL>       ::= CLOSE BASE -|\n       R2 := BLOCK; if R2\u00ac=BLOCKLEVEL(R10) or NODATASEG then\n       begin XR := 28; ERROR;\n       end else\n       begin R0 := DATAESDEND; R1 := DATAESDADR; R5 := R10; CLOSESEG;\n          R2 := PREVSEG(R5); if R2 = ENDCHAIN then\n          begin SET(NODATASEG); R0 := R0-R0; DC:=R0; PL360NO(R1) := R0;\n          end else\n          begin R5 := R2; UNSTACKSEG; DATAESDEND := R0; R10 := R5;\n          end;\n       end;\n    end;\n    begin |- <DECL>       ::= <EQU SYN2> -|\n       R2 := S(R7-2);  SETNAME;  |-- NO RETURN --|\n    end;\n    begin |- <LABEL DEF>  ::= <ID> : -|\n       R8 := LABELBASE + N4; R0 := LC + PTAG;\n       for R2 := LABELBASE + N3 step _14S until R8 do\n       if V(R7/10) = LABEL(R2) then\n       begin if R4 := LABELADR(R2); R4 = 0 then goto X;\n          XR := 9; ERROR; goto L;\n       end; R2 := 14 + N3 =: N3 + LABELBASE;\n       LABEL(R2/10) := V(R7); R1 := ENDCHAIN =: LABELCHAIN(R2);\n X:    LABELADR(R2) := R0;\n L:\n$IFT M M\n       if TESTFLAG then begin R1 := 1; ENTERSYMLABEL; end;\n$END M\n    end;\n    begin |- <BLOCKHEAD>  ::= BEGIN -|\n       R0 := N4; R1 := 14 + N3 =: N3 =: N4;\n       R1 := R1 + LABELBASE; B1(0/12) := ZERO; LABELADR(R1) := R0;\n       R0 := N2; LABEL(R1+4) := R0; R0 := N1; N2 := R0;\n       R0 := DBREG; LABEL(R1) := R0;\n       R0 := PROCBR =: LABEL(R1+6);\n       R0 := 1 =: PROCBR;\n       R0 := PROCLK =: LABEL(R1+12);\n       R2 := 1 + BLOCK; BLOCK := R2;\n    end;\n    begin |- <PROGRAM->   ::= . -|\n       R0 := N6; R1 := 4 + N5 =: N5 =: N6 + BRANCHBASE;\n       BRANCHADR(R1) := R0;\n       R0 := R0-R0; T(R7) := R0; R0 := 14; V(R7+4) := R0;\n       R0 := PROGREG; PBREG := R0;\n       if OSSYSTEM then\n       begin  R0 := #90ECS; PROGRAM(0) := R0; R0 := #D00CS;\n          PROGRAM(2) := R0; R3 := 15; if R3 \u00ac= PROGREG then\n          begin R0 := 4; LC := R0; R0 := 1; R1 := 8; R2 := PROGREG;\n             EMIT; R1 := 2;\n          end else R1 := R1-R1;\n          R0 := #18EDS; PROGRAM(R1+4) := R0;\n          R0 := #58D0S; PROGRAM(R1+6) := R0;\n          R0 := #50E0S; PROGRAM(R1+10) := R0;\n          R0 := #D004S; PROGRAM(R1+12) := R0;\n          R0 := #50D0S; PROGRAM(R1+14) := R0;\n          R0 := #E008S; PROGRAM(R1+16) := R0;\n          R0 := #D703S; PROGRAM(R1+18) := R0;\n          R0 := #E010S; PROGRAM(R1+20) := R0; PROGRAM(R1+22) := R0;\n          R1 := R1 + 24S; LC := R1;\n       end else\n       begin  R0 := #05F0; PROGRAM(0) := R0; R0 := 2; LC := R0;\n          R0 := 5; R1 := 8; R2 := PROGREG; R3 := #F; EMIT;\n          R1 := PROGESDADR; R2 := RLDADDR(R1); PROGRAM(4) := R2;\n          R0 := 2; RLDADDR(R1) := R0;\n          R0 := #58D0S; PROGRAM(6) := R0; R0 := 10; LC := R0;\n       end;\n$IFF M M\n       R2 := 1; R3 := STARTADR shrl 12; R5 := R10; OPENSEG;\n$END M\n$IFT M M\n       R2 := #010001; R3 := STARTADR shrl 12; R5 := R10; OPENSEG;\n$END M\n       RESET(NODATASEG); R1 := DATAESDADR; R0 := R1; R2 := SD;\n       R3 := ATYPE; R4 := R4-R4; FINDESDENTRY; DATAESDEND := R0;\n       R0 := PROGESDEND; R1 := PROGESDADR; R2 := ER; FINDESDENTRY;\n       PROGESDEND := R0; R2 := RLDADDR(R1);  R0 := 15;\n       if R0 \u00ac= PROGREG and OSSYSTEM then\n       begin PROGRAM(10) := R2; R2 := 8;\n       end else\n       begin PROGRAM(8) := R2; R2 := 6;\n       end;\n       RLDADDR(R1) := R2; R0 := 1; BLOCKLEVEL(R10) := R0;\n       R0 := STARTADR and #FFF; DC := R0; RESET(NOPROGSEG);\n    end;\n    begin |- <PROGRAM->   ::= . <GLOB HD> ; -|\n       V(R7/16) := V1(R7); RESET(NOPROGSEG);\n       R1 := PBREG shll 12; PTAG := R1;\n       R1 := V(R7); R2 := PBREG shll 4 or V(R7+4);\n       R4 := CSEGNO shll 8 or R2; ADR(R1) := R4;\n    end;\n    begin |- <PROGRAM*>   ::= <PROGRAM-><STATEMENT*> -|\n       if R5 \u00ac= ENDFILE then begin SET(FLAG); goto X; end;\n       R4 := LC; R0 := T(R7); if R0 = 0 and OSSYSTEM then\n       begin R0 := #58D0S; PROGRAM(R4) := R0;\n          R0 := #D004S; PROGRAM(R4+2) := R0;\n          R0 := #98ECS; PROGRAM(R4+4) := R0;\n          R0 := #D00CS; PROGRAM(R4+6) := R0; R4 := R4 + 8S;\n       end else if R0 = 0 then\n       begin R0 := #0A0E; PROGRAM(R4) := R0; R4 := R4 + 2; goto Y;\n       end;\n       R0 := #07F0 or V(R7+4); PROGRAM(R4) := R0; R4 := R4 + 2;\nY:     ALLOCATELITERALS; LC := R4;\n$IFT M M\n       if TESTFLAG then\n       begin R0 := R4 - 2S; R1 := 5; ENTERSYMLABEL; end;\n$END M\n       R2 := LASTINITIAL(R9); INITIALEN(R2) := R4;\n       if R4 > 4096S then begin XR := 16; ERROR; end;\n       BRANCHFIXUP;  |-- DO BRANCH OPTIMIZATION --|\n       R1 := N4; while R1 := @B1(14); R1 <= N3 do\n       begin R2 := R1 + LABELBASE; R0 := LABELADR(R2);\n          if R0 = 0 then LABELERROR;\n       end;\n       R0 := PROGESDEND; R1 := PROGESDADR; R5 := R9; CLOSESEG;\n X:\n    end;\n    begin |- <EQU SYN1>   ::= <EQUATE><ID> SYN -|\n       V(R7/10) := V1(R7); R0 := T1(R7); T(R7) := R0;\n    end;\n    begin |- <EQU SYN2>   ::= <EQU SYN1><T NUMBER> -|\n       R0 := V1(R7);  CLI(1,T1(R7+1));  if > then\n       begin  XR := 25; ERROR; R0 := R0-R0; T(R7) := R0;\n       end;  EQUHOLD := R0;\n    end;\n    begin |- <EQU SYN2>   ::= <EQU SYN3><ARITH OP><T CELL> -|\n       R1 := V1(R7);  if R1 \u00ac= 11S then    |-- \u00ac= - --|\n       begin XR := 4; ERROR; R1 := R1-R1; T(R7) := R1; end;\n       R0 := V2(R7) and #FFFF; if R0\u00ac=V2(R7) then\n       begin XR:=11; ERROR; end;\n       R0 := EQUHOLD and #F000; R1 := V2(R7) and #F000;\n       if R0\u00ac=R1 then\n       begin XR:=26; ERROR; end;\n       R1 := EQUHOLD - V2(R7);\n       EQUHOLD := R1;\n    end;\n    begin |- <EQU SYN2>   ::= <EQU SYN2><ARITH OP><STRING> -|\n      R3 := STRINGV;  R1 := 4 - V2(R7);  if < then\n      begin  XR := 21;  ERROR;  |- Invalid length -|\n      end else  |- Valid string length -|\n      begin  for R2 := 1 step 1 until R1 do R3 := R3 shrl 8;\n         V2(R7) := R3;  EQUARITH;\n      end;\n    end;\n    begin |- <EQU SYN2>   ::= <EQU SYN2><ARITH OP><T NUMBER> -|\n      CHKEQUATE;  if \u00ac= then EQUARITH;\n    end;\n    begin |- <EQU SYN2>   ::= <EQU SYN2><LOG OP><STRING> -|\n      R3 := STRINGV;  R1 := 4 - V2(R7);  if < then\n      begin  XR := 21;  ERROR;  |- Invalid length -|\n      end else  |- Valid string length -|\n      begin  for R2 := 1 step 1 until R1 do R3 := R3 shrl 8;\n         R1 := EQUHOLD;  |- String in R3 -|\n         R2 := V1(R7) shll 8 + #1013S; EQUHOLD := R2;\n         EX(R0,EQUHOLD(2));  EQUHOLD := R1;\n      end;\n    end;\n    begin |- <EQU SYN2>   ::= <EQU SYN2><LOG OP><T NUMBER> -|\n      CHKEQUATE;  if \u00ac= then\n      begin R1 := EQUHOLD; R3 := V2(R7);\n         R2 := V1(R7) shll 8 + #1013S; EQUHOLD := R2;\n         EX(R0,EQUHOLD(2));  EQUHOLD := R1;\n      end;\n    end;\n    begin |- <EQU SYN2>   ::= <EQU SYN2><SHIFT OP><T NUMBER> -|\n      R3 := V2(R7); CHKEQUATE; if \u00ac= then\n      if R3 < 0 or R3 >= 32S then\n      begin XR := 25; ERROR; R0 := R0-R0; T(R7) := R0;\n      end else\n      begin R0 := EQUHOLD; R2 := #80 + V1(R7) shll 24 or R3;\n         EQUHOLD := R2;  EX(R0,EQUHOLD);  EQUHOLD := R0;\n      end;\n    end;\n    begin |- <EQU SYN2>   ::= <EQU SYN1><UNARY NUM> -|\n       byte VC syn V(32), OPCD syn B2;\n       R1 := V1(R7);  R2 := R2 -- R2;  if CLI(1,T1(R7+1)); \u00ac= then\n       begin  XR := 25;  ERROR;  R1 := R2 =: T(R7);\n       end;  IC(R2,VC(R7));  R2 := @VC(R7+R2+2);  SET(B2);\n       R2 := @VC(R7);  while R2 := @B2(1);  \u00acOPCD do\n       if OPCD = 4 then\n       begin  XR := 26;  ERROR;\n       end else if OPCD = 6 then REDUCE(R1) else\n       begin R0 := R0 -- R0;  IC(R0,OPCD);\n          R0 := R0 shll 8 or #1011 =: EQUHOLD;  EX(R0,EQUHOLD(2));\n       end;  EQUHOLD := R1;\n    end;\n    begin |- <EQU SYN3>   ::= <EQU SYN1><T CELL> -|\n      R0 := V1(R7);  EQUHOLD := R0;\n      R0 := R0 and #FFFF; if R0\u00ac=EQUHOLD then\n      begin XR:=11; ERROR; end;\n    end;\n    begin |- <EQU SYN2>   ::= <EQU SYN1><STRING> -|\n       R0 := STRINGV; R1 := 4 - V1(R7);\n       for R2 := 1 step 1 until R1 do R0 := R0 shrl 8;\n       if R1 < 0 then begin XR := 21; ERROR; end;\n       EQUHOLD := R0;\n    end;\n    begin |- <EQU SYN2>   ::= <EQU SYN1><K REG> -|\n       R0 := V1(R7);  EQUHOLD := R0;\n    end;\n    begin |- <EQUATE>     ::= <EQU SYN2> , -|\n       R2 := S(R7-2);  SETNAME;  |-- NO RETURN --|\n    end;\n    begin |- <PROC SYN>   ::= PROCEDURE <ID> SYN -|\n       V(R7/10) := V1(R7);  R0 := T1(R7);  T(R7) := R0;\n    end;\n    begin |- <DECL>       ::= <PROC SYN> <PROC ID> -|\n       R0 := V1(R7);  EQUHOLD := R0;  R2 := 10;  SETNAME;\n    end;\n    begin |- <FORUNTIL>   ::= UNTIL -|\n       R1 := R7 - 32S;  R2 := FORSYMBOL;\n       if R2 \u00ac= S(R1) then SET(FLAG);\n    end;\n    begin |- <REPUNTIL>   ::= UNTIL -|\n    end;\n    end;\n EXIT: LM(R1,R5,SAVEREG);\n    end;\n\n    close base;  |-- CLOSE DATA SEGMENT --|\n\n    segment base R11;  |-- USE R11 FOR BASE OF ESDNAMETABLE --|\n\n    array NAMETBLLEN byte ESDNAMETABLE=\n    (\"SEGN000   \",\"SEGN001   \",\"READ      \",\"WRITE     \",\"PUNCH     \",\n     \"PAGE      \",\"PRINT     \",\"OPEN      \",\"GET       \",\"PUT       \",\n     \"KLOSE     \",\"CANCEL    \",\"BCDTOVAL  \",\"VALTOBCD  \");\n    close base;\n    segment base R8;  |-- CHANGE BASE REGISTERS --|\n\n    array 1366 byte PRTB   =\n       (255,0,1,14,47,2,5,106,1,14,71,2,78,106,1,14,72,2,94,106,1,14,73,\n       2,1,106,1,14,74,2,10,106,1,14,75,2,11,106,1,14,76,2,12,106,1,14,\n       77,3,5,97,106,1,14,78,3,3,97,106,1,14,79,2,5,22,1,23,113,2,78,22,\n       1,23,114,2,1,22,1,23,115,2,94,22,1,23,116,2,1,88,1,23,128,255,0,\n       2,5,1,1,101,2,8,4,255,1,101,3,19,6,0,3,21,107,255,1,101,4,16,95,\n       0,4,21,108,255,2,1,106,5,81,100,2,5,106,5,81,101,2,78,106,5,81,\n       102,2,94,106,5,81,103,2,5,22,5,23,119,2,78,22,5,23,120,2,94,22,5,\n       23,121,0,5,23,122,255,1,102,6,5,2,2,94,96,6,6,55,2,78,96,6,6,56,\n       255,1,102,7,5,3,2,78,96,7,6,57,2,1,96,7,6,58,255,1,94,8,6,59,1,\n       78,8,6,60,1,1,8,7,61,255,1,5,9,10,62,1,10,9,10,63,1,78,9,11,64,1,\n       11,9,11,65,1,1,9,12,66,1,12,9,12,67,3(255),0,12,23,126,2(255),0,\n       14,21,7,2,94,96,14,14,80,2,5,96,14,14,81,2,78,96,14,14,82,2,1,96,\n       14,14,83,2,94,13,14,14,84,2,5,13,14,14,85,2,78,13,14,14,86,2,1,\n       13,14,14,87,2,78,95,14,14,88,2,1,95,14,14,89,2,78,125,14,32,143,\n       255,1,104,15,16,5,1,102,15,17,96,255,1,78,16,15,90,1,1,16,15,91,\n       1,5,16,15,92,1,94,16,15,93,1,17,16,15,94,255,0,17,21,109,255,1,\n       68,18,18,44,2,98,37,18,18,98,1,112,18,21,110,255,1,1,19,20,99,\n       255,1,102,20,21,10,255,0,21,35,12,1,120,21,29,138,255,0,22,23,\n       124,255,0,23,80,130,0,23,24,131,255,0,24,83,40,1,111,24,25,133,1,\n       110,24,25,134,1,112,24,86,135,1,126,24,26,136,1,107,24,31,142,\n       255,2,98,37,25,25,38,1,80,25,24,132,2(255),0,27,28,11,1,120,27,\n       29,139,255,0,28,36,162,2(255),2,98,37,30,30,39,2,84,31,30,35,158,\n       2,36,31,30,35,159,5(255),0,35,36,13,255,0,36,37,14,2(255),0,38,\n       39,170,3,114,93,143,38,54,189,255,1,93,39,43,179,0,39,43,181,2,\n       114,93,39,54,188,2(255),1,40,41,42,16,255,1,104,42,41,15,1,102,\n       42,40,176,255,0,43,46,18,1,99,43,45,183,255,1,93,44,43,180,0,44,\n       43,182,255,1,40,45,46,184,255,1,104,46,44,17,0,46,67,28,255,1,93,\n       47,48,185,255,1,101,48,49,21,255,1,78,49,50,186,255,1,104,50,51,\n       22,255,1,78,51,52,187,255,1,102,52,53,23,255,1,104,53,47,20,0,53,\n       67,29,255,1,5,54,55,191,1,78,54,55,192,1,1,54,55,193,255,1,104,\n       55,56,24,0,55,67,30,255,2,114,93,56,54,190,255,1,101,57,58,25,\n       255,1,1,58,59,197,255,1,102,59,60,26,255,0,60,62,202,255,0,61,62,\n       203,2,1,116,61,62,204,255,1,98,62,63,205,255,1,36,63,67,214,\n       2(255),0,65,64,27,2,1,116,65,64,207,255,2,1,116,66,67,215,3(255),\n       2,98,67,69,69,31,0,69,70,32,255,2,98,37,70,70,33,1,68,70,70,34,1,\n       112,70,21,111,1,85,70,84,153,255,1,36,71,72,222,255,1,105,72,73,\n       35,2(255),1,78,74,75,224,1,11,74,75,231,1,5,74,76,232,1,94,74,75,\n       233,1,1,74,75,234,255,0,75,67,217,2,94,96,75,75,226,2,78,96,75,\n       75,227,2,94,13,75,75,228,2,78,13,75,75,229,2,78,95,75,75,230,1,\n       104,75,77,235,255,2,5,96,76,75,225,255,2,114,93,77,74,223,255,0,\n       78,23,117,0,78,40,175,1,101,78,41,177,255,2,98,37,79,79,37,1,86,\n       79,85,148,2,35,86,79,85,149,2,28,86,79,85,150,3,35,29,86,79,85,\n       151,3,28,29,86,79,85,152,2,35,26,79,35,154,2,28,26,79,35,155,3,\n       35,29,26,79,35,156,3,28,29,26,79,35,157,2(255),0,81,21,8,2,5,13,\n       81,81,104,2,78,13,81,81,105,2,94,13,81,81,106,255,2,98,37,82,82,\n       41,2,102,83,82,23,125,5(255),2,98,67,87,87,42,0,87,18,43,2(255),\n       1,3,89,67,237,255,1,68,90,90,45,2,98,37,90,90,46,2,83,92,90,35,\n       160,255,1,1,91,33,144,1,5,91,33,145,1,78,91,33,146,2(255),0,93,1,\n       48,0,93,2,49,0,93,3,50,0,93,4,51,0,93,78,52,0,93,9,53,0,93,88,54,\n       1,103,93,68,218,255,0,94,40,172,3(255),1,5,97,40,173,1,3,97,40,\n       174,2(255),0,99,22,112,255,1,78,100,23,118,1,5,100,23,123,1,12,\n       100,23,127,255,0,101,82,129,0,101,41,178,4(255),0,105,71,220,2,\n       98,64,105,71,221,2(255),0,107,34,147,255,0,108,79,36,2(255),0,\n       110,13,69,255,0,111,13,68,2(255),4,36,34,33,32,113,35,161,2(255),\n       0,115,13,70,2(255),0,117,38,168,255,3,128,109,1,118,87,97,3(255),\n       1,93,121,27,137,255,1,124,122,38,167,255,0,123,21,9,255,0,124,38,\n       166,3(255),2,38,78,127,39,171,255,0,128,69,219,255,1,116,129,67,\n       216,255,0,130,66,213,255,1,138,131,38,163,1,135,131,77,194,255,0,\n       132,91,238,0,132,92,239,255,0,133,30,141,255,1,60,134,62,201,2,\n       93,119,134,66,210,0,134,66,211,255,0,135,77,195,255,1,60,136,61,\n       198,1,60,136,65,206,2,93,119,136,66,208,255,0,137,90,140,255,0,\n       138,38,164,255,0,139,38,165,255,1,60,140,61,200,0,140,66,212,255,\n       1,60,141,61,199,2,93,119,141,66,209,255,0,142,47,19,2(255),0,144,\n       38,169,255,1,93,145,57,196,2,114,93,145,89,236,255);\n\n    comment STANDARD IDENTIFIERS FOR THE NAME TABLE ARE GIVEN BELOW.\n       NEW ENTRIES, CHANGES, OR DELETIONS CAN BE MADE TO THE LIST IN\n       ANY ORDER.  HOWEVER, LATER ENTRIES ARE ACCESSED VIA THE\n       HASH CHAIN BEFORE EARLIER ENTRIES SO ORDER DOES AFFECT SPEED\n       OF ACCESS.\n\n       THE FOURTH AND FIFTH FIELDS OF EACH ENTRY DESCRIBE THE BCD\n       NAME. THE FOURTH FIELD GIVES THE ACTUAL LENGTH OF THE BCD\n       NAME (ONLY LENGTHS OF 2, 4, 6, 8, OR 10 ARE VALID).  THE FIFTH\n       FIELD IS THE ACTUAL STRING (A BLANK MUST BE USED ON THE RIGHT\n       TO MAKE ODD LENGTH ID'S HAVE AN EVEN LENGTH.).  AT RUN TIME\n       THE LENGTH FIELD IS CONVERTED TO A CHAIN FIELD FOR THE HASH\n       SCHEME USED.  A LENGTH FIELD OF _1 SIGNALS THE END OF THE\n       STANDARD IDENTIFIERS.\n\n       THE FIRST FIELD GIVES THE TYPE OF EACH ID.  FIELDS TWO AND THREE\n       ARE A FOUR BYTE ADDRESS OR VALUE FOR EACH ID AND ARE FILLED\n       ACCORDING TO THE TYPE OF THE ID.\n          0 -- ID IS A SHORT INTEGER, 1 -- ID IS AN INTEGER OR LOGICAL,\n          2 -- ID IS A LONG REAL, 3 -- ID IS A REAL,\n          11 -- ID IS A FUNCTION, 81 -- ID IS AN INTEGER REGISTER,\n          82 -- ID IS A LONG REAL REG., 83 -- ID IS A REAL REG,\n          10 -- ID IS A PROCEDURE, 12 -- ID IS AN EQUATE INTEGER.\n\n       FOR <T CELL> TYPES (TYPE < 10), FIELDS TWO AND THREE CONTAIN\n       THE RELATIVE ADDRESS AS A FOUR BYTE QUANTITY.  NORMALLY FIELD\n       TWO IS ZERO BECAUSE FIELD THREE CAN CONTAIN THE ENTIRE ADDRESS\n       UNLESS AN INDEX REGISTER IS PART OF THE RELATIVE ADDRESS.\n       FOR PROCEDURES, FIELD TWO CONTAINS THE SEGMENT NUMBER OF THE\n       PROCEDURE IN THE FIRST BYTE, THE ENTRY POINT REGISTER IN THE\n       UPPER HALF OF THE SECOND BYTE, AND THE RETURN REGISTER IN THE\n       LOWER HALF OF THE SECOND BYTE, WHILE FIELD THREE\n       CONTAINS THE RELATIVE ADDRESS OF THE PROCEDURE (WITHOUT BASE\n       REGISTER R15 SPECIFIED).\n       FOR FUNCTIONS, FIELD TWO CONTAINS THE FUNCTION CODE AND FIELD\n       THREE CONTAINS THE FIRST HALF WORD OF THE FUNCTION.  FOR <K REG>\n       TYPES (TYPE > 80) FIELD TWO IS 0 AND FIELD THREE IS THE ACTUAL\n       HARDWARE REGISTER NUMBER;\n    equate K0 syn #FF00,  |-- CELL TYPES NOT DEFINED IN SEGMENT --|\n           K1 syn #FF01,  K2 syn #FF02,  K3 syn #FF03, K4 syn #FF04;\n    array NAMEFILLSZ short integer NAMEFILL=(\n$IFF\n    (K4,   #E,#0FFF, 6,    \"PSTAR \"),(K4,   #D,#0FFF, 6,    \"DSTAR \"),\n $$ (K3,    0,#F000, 4,      \"E15 \"),(K3,    0,#E000, 4,      \"E14 \"),\n $$ (K3,    0,#D000, 4,      \"E13 \"),(K3,    0,#C000, 4,      \"E12 \"),\n $$ (K3,    0,#B000, 4,      \"E11 \"),(K3,    0,#A000, 4,      \"E10 \"),\n $$ (K3,    0,#9000, 2,        \"E9\"),(K3,    0,#8000, 2,        \"E8\"),\n $$ (K3,    0,#7000, 2,        \"E7\"),(K3,    0,#6000, 2,        \"E6\"),\n $$ (K3,    0,#5000, 2,        \"E5\"),(K3,    0,#4000, 2,        \"E4\"),\n $$ (K3,    0,#3000, 2,        \"E3\"),(K3,    0,#2000, 2,        \"E2\"),\n $$ (K3,    0,#1000, 2,        \"E1\"),\n    (K2,    0,#F000, 4,      \"L15 \"),(K2,    0,#E000, 4,      \"L14 \"),\n    (K2,    0,#D000, 4,      \"L13 \"),(K2,    0,#C000, 4,      \"L12 \"),\n    (K2,    0,#B000, 4,      \"L11 \"),(K2,    0,#A000, 4,      \"L10 \"),\n    (K2,    0,#9000, 2,        \"L9\"),(K2,    0,#8000, 2,        \"L8\"),\n    (K2,    0,#7000, 2,        \"L7\"),(K2,    0,#6000, 2,        \"L6\"),\n    (K2,    0,#5000, 2,        \"L5\"),(K2,    0,#4000, 2,        \"L4\"),\n    (K2,    0,#3000, 2,        \"L3\"),(K2,    0,#2000, 2,        \"L2\"),\n    (K2,    0,#1000, 2,        \"L1\"),\n    (K0,    0,#F000, 4,      \"H15 \"),(K0,    0,#E000, 4,      \"H14 \"),\n    (K0,    0,#D000, 4,      \"H13 \"),(K0,    0,#C000, 4,      \"H12 \"),\n    (K0,    0,#B000, 4,      \"H11 \"),(K0,    0,#A000, 4,      \"H10 \"),\n    (K0,    0,#9000, 2,        \"H9\"),(K0,    0,#8000, 2,        \"H8\"),\n    (K0,    0,#7000, 2,        \"H7\"),(K0,    0,#6000, 2,        \"H6\"),\n    (K0,    0,#5000, 2,        \"H5\"),(K0,    0,#4000, 2,        \"H4\"),\n    (K0,    0,#3000, 2,        \"H3\"),(K0,    0,#2000, 2,        \"H2\"),\n    (K0,    0,#1000, 2,        \"H1\"),\n    (K4,    0,#F000, 4,      \"C15 \"),(K4,    0,#E000, 4,      \"C14 \"),\n    (K4,    0,#D000, 4,      \"C13 \"),(K4,    0,#C000, 4,      \"C12 \"),\n    (K4,    0,#B000, 4,      \"C11 \"),(K4,    0,#A000, 4,      \"C10 \"),\n    (K4,    0,#9000, 2,        \"C9\"),(K4,    0,#8000, 2,        \"C8\"),\n    (K4,    0,#7000, 2,        \"C7\"),(K4,    0,#6000, 2,        \"C6\"),\n    (K4,    0,#5000, 2,        \"C5\"),(K4,    0,#4000, 2,        \"C4\"),\n    (K4,    0,#3000, 2,        \"C3\"),(K4,    0,#2000, 2,        \"C2\"),\n    (K4,    0,#1000, 2,        \"C1\"),\n$END\n    (K1,    0,#E000, 4,      \"B14 \"),(K1,    0,#F000, 4,      \"B15 \"),\n    (82,    0,    4, 4,      \"F45 \"),(82,    0,    6, 4,      \"F67 \"),\n    (82,    0,    0, 4,      \"F01 \"),(82,    0,    2, 4,      \"F23 \"),\n    (83,    0,    4, 2,        \"F4\"),(83,    0,    6, 2,        \"F6\"),\n    (83,    0,    0, 2,        \"F0\"),(83,    0,    2, 2,        \"F2\"),\n    (13,    0,    0, 4,      \"ABS \"),(13,    0,    3, 4,      \"NEG \"),\n    (13,    0,    6, 4,      \"DEC \"),(13,    0,    4, 4,      \"HALF\"),\n    (14,    0, #860, 2,        \"LE\"),(14,    0, #870, 2,        \"GT\"),\n    (10,#02FE,#0000, 4,      \"READ\"),(10,#03FE,#0000, 6,    \"WRITE \"),\n    (10,#04FE,#0000, 6,    \"PUNCH \"),(10,#05FE,#0000, 4,      \"PAGE\"),\n    (10,#06FE,#0000, 6,    \"PRINT \"),(10,#07FE,#0000, 4,      \"OPEN\"),\n    (10,#08FE,#0000, 4,      \"GET \"),(10,#09FE,#0000, 4,      \"PUT \"),\n    (10,#0AFE,#0000, 6,    \"KLOSE \"),(10,#0BFE,#0000, 6,    \"CANCEL\"),\n    (10,#0CFE,#0000, 8,  \"BCDTOVAL\"),(10,#0DFE,#0000, 8,  \"VALTOBCD\"),\n    (11,    5,#DC00, 2,        \"TR\"),(11,    5,#D100, 4,      \"MVN \"),\n    (11,    5,#DE00, 2,        \"ED\"),(11,    2,#4400, 2,        \"EX\"),\n    (11,   10,#F300, 4,      \"UNPK\"),(11,   12,#4E00, 4,      \"CVD \"),\n    (11,    8,#92FF, 4,      \"SET \"),(11,    8,#9200, 6,    \"RESET \"),\n    (11,    2,#4300, 2,        \"IC\"),(11,   12,#4200, 4,      \"STC \"),\n    (11,    9,#8C00, 4,      \"SRDL\"),(11,    9,#8D00, 4,      \"SLDL\"),\n    (11,    3,#9000, 4,      \"STM \"),(11,    3,#9800, 2,        \"LM\"),\n    (11,    4,#9200, 4,      \"MVI \"),(11,    4,#9500, 4,      \"CLI \"),\n    (11,    5,#D200, 4,      \"MVC \"),(11,   13,#D500, 4,      \"CLC \"),\n    (11,    8,#95FF, 4,      \"TEST\"),(11,    2,#4100, 2,        \"LA\"),\n    (11,    4,#9400, 2,        \"NI\"),(11,   12,#4F00, 4,      \"CVB \"),\n    (11,    4,#9700, 2,        \"XI\"),(11,    4,#9600, 2,        \"OI\"),\n    (11,   10,#F200, 4,      \"PACK\"),(11,    6,#0400, 4,      \"SPM \"),\n    (11,    9,#8F00, 4,      \"SLDA\"),(11,    9,#8E00, 4,      \"SRDA\"),\n    (11,    7,#0A00, 4,      \"SVC \"),(11,    4,#9100, 2,        \"TM\"),\n    (11,    5,#DD00, 4,      \"TRT \"),(11,    5,#DF00, 4,      \"EDMK\"),\n    (11,    1,#1200, 4,      \"LTR \"),(11,    5,#D300, 4,      \"MVZ \"),\n    (11,   12,#4000, 4,      \"STH \"),(11,   12,#4800, 2,        \"LH\"),\n    (11,    1,#0500, 4,      \"BALR\"),(11,    5,#D400, 2,        \"NC\"),\n    (11,    5,#D600, 2,        \"OC\"),(11,    5,#D700, 2,        \"XC\"),\n    (11,    8,#9300, 2,        \"TS\"),(11,   16,#BD00, 4,      \"CLM \"),\n    (11,   17,#BE00, 4,      \"STCM\"),(11,   16,#BF00, 4,      \"ICM \"),\n    (81,    0,   14, 4,      \"R14 \"),(81,    0,   15, 4,      \"R15 \"),\n    (81,    0,   12, 4,      \"R12 \"),(81,    0,   13, 4,      \"R13 \"),\n    (81,    0,   10, 4,      \"R10 \"),(81,    0,   11, 4,      \"R11 \"),\n    (81,    0,    8, 2,        \"R8\"),(81,    0,    9, 2,        \"R9\"),\n    (81,    0,    6, 2,        \"R6\"),(81,    0,    7, 2,        \"R7\"),\n    (81,    0,    4, 2,        \"R4\"),(81,    0,    5, 2,        \"R5\"),\n    (81,    0,    2, 2,        \"R2\"),(81,    0,    3, 2,        \"R3\"),\n    (81,    0,    0, 2,        \"R0\"),(81,    0,    1, 2,        \"R1\"),\n    (K1,    0,#C000, 4,      \"B12 \"),(K1,    0,#D000, 4,      \"B13 \"),\n    (K1,    0,#A000, 4,      \"B10 \"),(K1,    0,#B000, 4,      \"B11 \"),\n    (K1,    0,#8000, 2,        \"B8\"),(K1,    0,#9000, 2,        \"B9\"),\n    (K1,    0,#6000, 2,        \"B6\"),(K1,    0,#7000, 2,        \"B7\"),\n    (K1,    0,#4000, 2,        \"B4\"),(K1,    0,#5000, 2,        \"B5\"),\n    (K1,    0,#2000, 2,        \"B2\"),(K1,    0,#3000, 2,        \"B3\"),\n    (K1,    0,#0000, 4,      \"MEM \"),(K1,    0,#1000, 2,        \"B1\"),\n    (12,    0,    4, 6,    \"MIXED \"),(12,    0,    1, 2,        \"ON\"),\n    (12,    0,    8, 4,      \"OFF \"),(12,    0,    1, 8,  \"OVERFLOW\"),\n    (12,#FFFF,#FFFF, 4,      \"TRUE\"),(12,    0,    0, 6,    \"FALSE \"),\n    (12,    0,    3, 6,    \"CARRY \"),(12, DTHI, DTLO, 8,  \"DATAFILL\"),\n     |-- FOLLOW TWO ENTRIES MUST BE THE LAST TWO --|\n    (12,    0,    0, 6,    \"STRING\"),( 0,    0,    0,_1));\n$PAGE\n segment procedure MAIN(R6);\n begin  |-- ALLOCATE CORE FOR PROGRAM, DATA, LITERALS AND LABELS --|\n    SAVERETURN := R6;  |-- SAVE RETURN REGISTER --|\n    if R0 = 0 then goto RESTART;\n    SYSINIT(R9); comment FREE STORAGE BOUNDS RETURNED IN R3, R4,\n       R1 SET TO ADDRESS OF 16 CHARACTER SYSTEM ID;\n    STC(R9,OSSYSTEM);  |-- #FF => O/S, #00 => DOS --|\n$IFF\n$IFF M M\n    IDRDATA(15/5) := B1(16);  IDRDATA(21/16) := B1;\n$END M\n$IFT M M\n    IDRDATA(21/16) := B1;\n$END M\n$END\n    HEADER(94/16) := B1;\n$IFT M M\n    LISTFLAG(0/1) := B1(16); TESTFLAG(0/1) := B1(17);\n    XREF(0/1) := B1(18); TRACE(0/1) := B1(19);\n    OVER(0/1) := B1(21);\n    OPTFLAG(0/1) := B1(20);\n$END M\n    R3 := @B3(7) and _8;  R4 := R4 and _8;\n    PRTBASE := R8; R8 := @NAMEFILL; NAMEBASE := R8;\n    R4 := R4 - STACKLEN;  STACKBASE := R4;\n    R4 := R4 - ESDTBLLEN;  PROGESDADR := R4;\n    R4 := R4 - ESDTBLLEN;  DATAESDADR:=R4;\n    R5 := R4 - R3;  PROGBASE := R3;  R9 := R3;\n$IFF\n    if R5 > #7800S then\n    begin  |-- $XREF WILL BE POSSIBLE --|\n       R7 := R5 shrl 1 - 12000S and _8;\n       if R7 > 262144 then R7 := 262144;  R4 := R4-R7;\n       REFSTART := R4;  R5 := R5-R7;  R7 := R7-4;  REFN3 := R7;\n$IFT M M\n    end;  if R5 > #5000S and TESTFLAG then\n    begin  |-- $TEST WILL BE POSSIBLE --|\n       R1 := R4; R2 := R5 - #4000S shrl 1 + 3000S and _8;\n       if R2 > 262144 then R2 := 262144; R4 := R4 - R2;\n       R5 - R2; R7 := R4 - 4S; DATASTACK := R7; R2 := @B7(#300);\n       PROCSTACK := R2; R2 := @B2(4); DSTAKBOT := R2;\n       R2 := @B2(#100); PSTAKBOT := R2; FREESPACE := R2;\n       R7 := R2;  while R7 := @B7(28); R7 < R1 do\n       begin B2 := R7; R2 := R7;\n       end; R7 := neg 1; B2 := R7;\n$END M\n    end;\n$END\n    if R5 < SIZE1 then   |-- NOT ENOUGH CORE --|\n    begin  XR := 31;   ERROR;\n       WBUF := \"CORE SIZE TOO SMALL \";\n       WBUF(STRING/132-STRING) := WBUF(STRING-1);  PRINT;\n       SB(NOGO,FLGS);  ERROREXIT;\n    end;  R6 := neg ROUND;  REDUCE(R6);  R2 := #FE00;\n    for R7 := R7 -- R7 step 4S until 16S do\n    begin R14 := R5 * QTAB(R7) shrl 8;\n       R14 := @B14(ROUND) and R6;\n       if R14 > R2 then R14 := R2;  LTAB(R7) := R14;\n    end;\n    R4 := R4 - BRTBL;  BRANCHBASE := R4;\n    R4 := R4 - LTTL;  LITBASE := R4;\n    R4 := R4 - LBTL;  LABELBASE := R4;\n    R7 := R4 - 56S;  DATAEND := R7;\n    R4 := R4 - DTL;  DATABASE := R4;\n    R4 := R4 - NTBL;  R7 := R4;  R2 := NAMEBASE;\n    NAMEBASE := R4;  R1 := DATABASE;  R1 := R1 - R4;\n    NAMEND := R1;  R1 := NAMETABSZ;\n    while R1 >= 256S do  |-- MOVE NAME TABLE --|\n    begin  B7(0/256) := B2;  R1 := R1 - 256S;\n       R2 := @B2(256);  R7 := @B7(256);\n    end;  EX(R1,MVC(0,B7,B2));\n    R0 := R0-R0;  R7 := STACKBASE;  S(R7) := R0;\n    R7 := @B7(16);  STACKBASE := R7;\n    R3 := LINK(R4);  R2 := R2-R2;\n    while R3 > 0 do\n    begin IC(R2,NAME(R4)); IC(R2,ALPHASH(R2-193));\n       R1 := LENHASH(R3-2) + R2; R0 := HASHCHAIN(R1); LINK(R4) := R0;\n       R0 := R4 - NAMEBASE; HASHCHAIN(R1) := R0;\n       R5 := R4; R4 := @B4(R3+8); R3 := LINK(R4);\n    end;  STRNGADR := R5;\n    R4 := R4 - NAMEBASE; NAMEPOINTER := R4;\nRESTART:  |-- RESTART COMPILER FOR NEXT PROGRAM --|\n    SET(RUNFLAG); SET(SKIPFLAG); CARRCONT := \"1\"; SET(GENFLAG);\n    SET(GENDECK); SET(NOPROGSEG); SET(NODATASEG); RESET(NOTMOVED);\n    R0 := R0-R0; N3 := R0; N4 := R0; LITX := R0; ERRCOUNT := R0;\n    R0 =: N5 =: N6;\n$IFF\n    RESET(REFOUT);  REFN1 := R0;  R1 := REFN3;  REFN2:= R1;\n$END\n    BEGENDLVL := R0;  SEGNAM := \"SEG\";\n    ESDNAME(0/3) := SEGNAM; ESDNAME(10/3) := SEGNAM;\n    PAGECOUNT := R0; CARDCOUNT := R0; BLOCK := R0;\n    WBUFF(0/133) := BLANK; HEADER(19/75) := HEADER(18);\n    SUBHEAD(1/132) := SUBHEAD;\n    R0 := 13; SEGNO := R0; NSEGNO := R0; MAXSEG := R0;\n    R0 := 1; CSEGNO := R0; PROCBR := R0;\n    R9 := PROGBASE; R10 := DATABASE; R7 := STACKBASE - 16S;\n    R0 := R0-R0; R1 := DATAESDADR; DC := R0;\n    PL360NO(R1) := R0; SYMTYPE := R0;\n    R2 := STRNGADR;  ADR(R2+2) := R0;\n    R0 := ENDCHAIN; PREVSEG(R9) := R0; PREVSEG(R10) := R0;\n    R2 := 1; R3 := PROGREG; R5 := R9;\n    OPENSEG; R3 := R3 shll 12; PTAG := R3;\n    R1 := PROGESDADR; R0 := R1; R2 := SD; R3 := VTYPE; R4 := 1;\n    FINDESDENTRY; PROGESDEND := R0;\n    WBUFF(0/133) := BLANK; R1 := LABELBASE; B1(0/12) := ZERO;\n    R1 := NAMEPOINTER; N1 := R1; N2 := R1;\n    for R2 := R2-R2 step 4S until MAXHASH do\n    begin R3 := HASHCHAIN(R2); while R3 >= R1 do\n       begin R3 := R3 + NAMEBASE; R3 := LINK(R3);\n       end; HASHCHAIN(R2) := R3;\n$IFF\n       R3 := ENDCHAIN;  REFCHAIN(R2) := R3;\n$END\n    end;  CONDTAB(0/64) := CONDTAB xor CONDTAB;\n    RESET(PRNT);  R6 := 71;  CBUF(71) := \" \";  R5 := ENDFILE;\n     |-- END OF INITIALIZATION SECTION, SYNTAX LOOP NEXT --|\n$PAGE\n  |-- ALGORITHM FOR SYNTACTIC ANALYSIS --|\n\n SYNLOOP:\n    begin R7 := R7 + 16S; I := R7; S(R7) := R5;\n       R5:=SYMTYPE;  T(R7):=R5;\n       V(R7/10) := VALUE; INSYMBOL; RESET(NOTMOVED); R2 := S(R7);\n$IFF\n       if XREF and R5=IDENTSYMBOL and \u00acREFOUT then ENTEREF;\n$END\n X:    R1 := R1-R1; IC(R1,F(R2)); R4 := @G(R5); EX(R1,CLI(0,B4));\n       if < then  |-- G < F --|\n       begin R4 := S(R7); R2 := R2 - R2;\n Y:       R7 := R7 - 16S; R3 := S(R7); STC(R4,RIGHTPART(R2));\n          IC(R1,F(R3)); R0 := R5; R5 := @G(R4); EX(R1,CLI(0,B5));\n          R5 := R0; if = then\n          begin R4 := R3; R2 := @B2(1); if R2 < 10 then goto Y;\n          end; R7 := R7 + 16S; SET(FLAG);\n          R4 := R4 shll 1; R3 := MTB(R4) + PRTBASE;\n Z:       if FLAG then\n          begin IC(R1,B3); if R1 \u00ac= NOMORERULES then\n             begin if R1 = R2 then\n                begin EX(R2,CLC(0,RIGHTPART,B3(1))); if = then\n                   begin RESET(FLAG); IC(R1,B3(R2+3));\n                      EXECUTE;   |-- DO THE RULE --|\n                   end;\n                   R3 := @B3(R2+4); goto Z;\n                end;\n                R3 := @B3(R1+4); goto Z;\n             end;\n          end;\n          if FLAG then\n          begin XR := 0; ERROR; SET(SKIPFLAG);\n             R2 := 6 + LC;  LC := R2;\n             R7 := I; R2 := S(R7); if R2 = SEMICOLON then goto B;\n A:          if R5 = SEMICOLON then INSYMBOL else\n             if R5 \u00ac= BEGINSYMBOL and R5 \u00ac= ENDSYMBOL\n                and R5 \u00ac= ENDFILE then\n             begin INSYMBOL; goto A;\n             end;\n B:          R2 := S(R7); if R2 = BLOCKBODY then\n             begin R2 := BLOCKHEAD; S(R7) := R2;\n             end else if R7 = STACKBASE then\n             begin RESET(FLAG); if R2 = ENDFILE then\n                begin R2 := PROGMINUS; S(R7) := R2; RESET(NOPROGSEG);\n                end;\n             end else\n             if R2\u00ac=BLOCKHEAD and R2\u00ac=CASESEQ then\n             begin if R2 = BEGINSYMBOL then RESET(FLAG);\n                R7 := R7 - 16S; goto B;\n             end; if \u00acFLAG then\n             begin R2 := BLOCKHEAD; if R2 = S(R7) then\n                begin R2 := BLOCKBODY; S(R7) := R2;\n                end; R7 := R7 + 16S; R2 := BEGINSYMBOL; S(R7) := R2;\n             end; I := R7; if R5 = ENDFILE then goto C;\n          end else\n          begin I := R7; R3 := R3 - 2; IC(R2,B3); S(R7) := R2;\n          end; goto X;\n       end;\n       if R5 \u00ac= ENDFILE then goto SYNLOOP;\n C: end;\n    if R7 \u00ac= STACKBASE then\n    begin XR := 0; ERROR;\n    end;\n    R6 := SAVERETURN;  |-- RESTORE RETURN REGISTER --|\n end;\n$PAGE\n  |-- *************** START HERE *************** --|\n\n    R0 := 1;  |-- FIRST TIME IN MAIN --|\nLOOP:  |-- COMPILE NEXT PROGRAM --|\n    MAIN;  |-- EXECUTE MAIN PROGRAM --|\n\n$IFT\n EXIT:  OUTPUTCARD;  WBUFF(0/133) := BLANK;  SETZONE(CARRCONT);\n$END\n$IFF\n EXIT: PRINTREFS;  WBUFF(0/133) := BLANK; SETZONE(CARRCONT);\n$END\n    if TM(XITF,FLGS); OFF then  |-- PRINT SEGMENT COUNT --|\n    begin  WBUF := \" `0`0`1`0 MAX SEG ASSIGNED.\";\n       R1 := 10 * MAXSEG;  CVD(R1,CONWORK);\n       ED(4,WBUF,CONWORK(5));  CARRCONT := \"0\";  PRINT;\n       WBUFF(0/133) := BLANK;  SETZONE(CARRCONT);\n    end;  if \u00acRUNFLAG then\n    begin\n$IFT M M\n       ERRPRINT;  |-- PRODUCE THE ERROR SUMMARY --|\n$END M\n       R1 := 10 * ERRCOUNT;  WBUF := \"*** `0`0`1`0 ERRORS DETECTED ***\";\n       CVD(R1,CONWORK); ED(4,WBUF(3),CONWORK(5));\n       R1 := ERRCOUNT; if R1 > ERRLIMIT then\n       WBUF(25) := \"- ERROR MESSAGE LISTING INCOMPLETE ***\";\n       R1 := R1 + ERRTOTL; ERRTOTL := R1; SB(NOGO,FLGS);\n    end else if \u00acNOPROGSEG then\n    WBUF := \"      NO ERRORS DETECTED\";  CARRCONT := \"0\";  PRINT;\n$IFT M M\n    R1 := @WBUFF;  SERCOMPR;\n$END M\n    if TM(XITF,FLGS); OFF then begin R0 := R0-R0; goto LOOP; end;\n    if TM(NOGO,FLGS); ON then\n    begin WBUFF(0/133) := BLANK;  CARRCONT := \" \";\n       R1 := 10 * ERRTOTL;  if R1=0 then goto X;\n       WBUF := \"***        ERRORS DETECTED IN ENTIRE COMPILATION\";\n       WBUF(4) := \"`0`0`0`0`1`0\";\n       CVD(R1,CONWORK); ED(6,WBUF(3),CONWORK(4)); PRINT;\n$IFT M M\n       R1 := @WBUFF;  SERCOMPR;\n$END M\nX:     R0 := 16;\n    end else R0 := R0-R0;\n    SYSTERM(R9);  |-- RELEASE SYSTEM RESOURCES --|\n    if = then R0 := R0+8S;  |-- => NOLOADSW=X'00' --|\n    R2 := MEM(R13+4); MEM(R2+16) := R0;  |-- SET RETURN CODE --|\n end.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PL360C": {"ttr": 2309, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'P\\x00\\x00\\x00\\x00t\\x02_\\x00t\\x02_\\x019\\x00\\x07\\x00\\x07\\x00\\x00\\xc8\\xc5\\xd9\\xc3\\xf0\\xf2@@@@'", "ispf": {"version": "80.00", "flags": 0, "createdate": "1974-01-25T00:00:00", "modifydate": "1974-01-25T01:39:00", "lines": 7, "newlines": 7, "modlines": 0, "user": "HERC02"}, "text": "//PL360C   PROC\n//PL360    EXEC  PGM=PL360\n//SYSGO    DD  DSN=&&LOADSET,DISP=(MOD,PASS),UNIT=SYSDA,\n//             SPACE=(3120,(40,100),RLSE),\n//             DCB=(BLKSIZE=3120,LRECL=80,RECFM=FB)\n//SYSPRINT DD  SYSOUT=A\n//SYSPUNCH DD  SYSOUT=B\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PL360CG": {"ttr": 2311, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'P\\x05\\x00\\x00\\x00t\\x02\\x7f\\x00t\\x02\\x7f\\x17\\x08\\x00\\x0e\\x00\\x10\\x00\\x00\\xc8\\xc5\\xd9\\xc3\\xf0\\xf2@@@@'", "ispf": {"version": "80.05", "flags": 0, "createdate": "1974-01-27T00:00:00", "modifydate": "1974-01-27T17:08:00", "lines": 14, "newlines": 16, "modlines": 0, "user": "HERC02"}, "text": "//PL360CG  PROC\n//PL360    EXEC  PGM=PL360\n//SYSGO    DD  DSN=&&LOADSET,DISP=(MOD,PASS),UNIT=SYSDA,\n//             SPACE=(3120,(40,10),RLSE),\n//             DCB=(BLKSIZE=3120,LRECL=80,RECFM=FB)\n//SYSPRINT DD  SYSOUT=A\n//SYSPUNCH DD  SYSOUT=B\n//GO       EXEC  PGM=LOADER,PARM='MAP',COND=(0,NE,PL360)\n//SYSLIB   DD  DSN=SYS1.PL360LIB,DISP=SHR\n//SYSLIN   DD  DSN=*.PL360.SYSGO,DISP=(OLD,PASS)\n//SYSLOUT  DD  SYSOUT=A\n//SYSPRINT DD  SYSOUT=A\n//SYSPUNCH DD  SYSOUT=B\n//SYSUDUMP DD  SYSOUT=A\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PL360CL": {"ttr": 2313, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'P\\x03\\x00\\x00\\x00t\\x02\\x8f\\x00t\\x02\\x8f\\x04 \\x00\\x0f\\x00\\x0e\\x00\\x00\\xc8\\xc5\\xd9\\xc3\\xf0\\xf2@@@@'", "ispf": {"version": "80.03", "flags": 0, "createdate": "1974-01-28T00:00:00", "modifydate": "1974-01-28T04:20:00", "lines": 15, "newlines": 14, "modlines": 0, "user": "HERC02"}, "text": "//PL360CL  PROC\n//PL360    EXEC  PGM=PL360\n//SYSGO    DD  DSN=&&LOADSET,DISP=(MOD,PASS),UNIT=SYSDA,\n//             SPACE=(3120,(40,10),RLSE),\n//             DCB=(BLKSIZE=3120,LRECL=80,RECFM=FB)\n//SYSPRINT DD  SYSOUT=A\n//SYSPUNCH DD  SYSOUT=B\n//LKED     EXEC  PGM=IEWL,PARM='LET,LIST,MAP',COND=(0,NE,PL360)\n//SYSLIB   DD  DSN=SYS1.PL360LIB,DISP=SHR\n//SYSLIN   DD  DSN=*.PL360.SYSGO,DISP=(OLD,PASS)\n//         DD  DDNAME=SYSIN\n//SYSLMOD  DD  DSN=&&GOSET(MAIN),DISP=(,PASS),UNIT=SYSDA,\n//            SPACE=(CYL,(10,2,10))\n//SYSPRINT DD  SYSOUT=A\n//SYSUT1   DD  DSN=&&SYSUT1,UNIT=SYSDA,SPACE=(3120,(120,10),,,ROUND)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PL360IVP": {"ttr": 2315, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00R\\x01\\x02\\x02\\x8f\\x01\\x02\\x02\\x8f\\x105\\x000\\x000\\x00\\x00\\xc8\\xc5\\xd9\\xc3\\xf0\\xf2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-01-28T00:00:00", "modifydate": "2002-01-28T10:35:52", "lines": 48, "newlines": 48, "modlines": 0, "user": "HERC02"}, "text": "//PL3CMPGO JOB  DUMMY,DUMMY,CLASS=A,MSGCLASS=A,MSGLEVEL=(1,1)\n//STEP1 EXEC PL360CG\n//STEPLIB DD DSN=SYS1.PL360LIB,DISP=SHR\n//SYSIN   DD *\n|01|  BEGIN  ARRAY 133 BYTE LINE = 133(\" \");  |-- OUTPUT LINE AREA --|\n|02|     ARRAY 256 INTEGER XX;  |-- SPACE FOR UP TO 16 BY 16 SQUARE --|\n|03|     INTEGER SIZE, LIMIT;  |-- SQUARE SIZE AND SUB-SQUARE LIMIT --|\n|04|     PROCEDURE MAGIC (R6);   |-- MAGIC SQUARE GENERATOR --|\n|05|     BEGIN SHORT INTEGER NSQR;  |-- CURRENT SQUARE SIZE --|\n|06|        INTEGER REGISTER N SYN R0, I SYN R1, J SYN R2,\n|07|                         X SYN R3, IJ SYN R4, K SYN R5;\n|08|        NSQR := N;  I := N * NSQR;  NSQR := I;\n|09|        I := 1 + N SHRL 1;  J := N;\n|10|        FOR K := 1 STEP 1 UNTIL NSQR DO\n|11|        BEGIN  IJ := I SHLL 4 + J SHLL 2;\n|12|           X := XX(IJ-68);  IF X ~= 0 THEN\n|13|           BEGIN I := I - 1;  J := J - 2;\n|14|              IF I <= 0 THEN I := I + N;\n|15|              IF J <= 0 THEN J := J + N;\n|16|              IJ := I SHLL 4 + J SHLL 2;\n|17|           END;  XX(IJ-68) := K;  I := I + 1;\n|18|           IF I > N THEN I := I - N;\n|19|           J := J + 1;  IF J > N THEN J := J - N;\n|20|        END;\n|21|     END;\n|22|\n|23|  |-- MAIN PROGRAM CODE STARTS HERE --|\n|24|     R0 := 15 =: SIZE;   |-- ESTABLISH INITIAL 15 BY 15 --|\n|25|     WHILE R0 > 1 DO  |-- MAIN LOOP FOR SQUARE GENERATION --|\n|26|     BEGIN  R1 := 16 - SIZE SHLA 2 =: LIMIT;\n|27|        XX := 0;  XX(4/256) := XX;     |-- ZERO OUT --|\n|28|        XX(260/256) := XX;             |-- THE WORK --|\n|29|        XX(516/256) := XX;             |--  SPACE.  --|\n|30|        XX(772/252) := XX;\n|31|        R0 := SIZE;  MAGIC;   |-- FORM MAGIC SQUARE --|\n|32|        R2 := 1;  R4 := R4-R4;  R7 := R4;  R3 := 5;\n|33|        R6 := SIZE;  WHILE R4 < R6 DO  |-- OUTPUT LINES --|\n|34|        BEGIN  R1 := @LINE;  R5 := R5-R5;  WHILE R5 < R6 DO\n|35|           BEGIN R0 := XX(R7);  VALTOBCD;  R5 := @B5(1);\n|36|              R7 := @B7(4);  R1 := @B1(R3);\n|37|           END;  R0 := @LINE;  WRITE;  R7 := R7 + LIMIT;\n|38|           R4 := @B4(1);  |-- BUMP LINE COUNTER --|\n|39|        END;  LINE := \" \";  LINE(1/132) := LINE;\n|40|        R0 := @LINE;  WRITE;  |-- WRITE BLANK LINE --|\n|41|        R0 := SIZE - 2 =: SIZE;  |-- REDUCE SIZE BY 2 --|\n|42|     END;  |-- OF MAIN WHILE LOOP --|\n|43|  END.\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PL360LOA": {"ttr": 2317, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x02\\x8f\\x01\\x02\\x02\\x8f\\x10%\\x02\\xac\\x02\\xac\\x00\\x00\\xe7\\xd4\\xc9\\xe3@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-01-28T00:00:00", "modifydate": "2002-01-28T10:25:00", "lines": 684, "newlines": 684, "modlines": 0, "user": "XMIT"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT544/FILE544.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT544", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}