{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011635000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 117572, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "CBT.V500.FILE277.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE277.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x03\\x07'", "DS1TRBAL": "b'\\\\,'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x01\\xee\\x00\\x00\\x01\\xee\\x00\\x03\\x00\\x04'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04V\\x00\\x08\\x01\\x13\\x05\\x0f\\x01\\x13\\x05\\x0f\\x11F\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf6@@@'", "ispf": {"version": "04.86", "flags": 0, "createdate": "2013-02-19T00:00:00", "modifydate": "2013-02-19T11:46:08", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-486"}, "text": "REGULAR CBT TAPE - VERSION 486    FILE:  277\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT486.FILE277\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 4 MEMBERS COUNTED; CUMULATIVE SIZE IS 932 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   02/19/13    11:46:08    UTC-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$DOC": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x8f\\x00\\x97&\\x8f\\x187\\x00+\\x00+\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-25T00:00:00", "modifydate": "1997-09-25T18:37:00", "lines": 43, "newlines": 43, "modlines": 0, "user": "SBGOLOB"}, "text": "\nOne example of how UTILITY can be used:\n\nJCL:\n\n//DELETE  PROC  MEMBER=,DSN=\n//STEPNAME  EXEC  PGM=UTILITY,\n//    PARM='IEHPROGM,&MEMBER,&DSN'\n//SYSPRINT DD SYSOUT=*\n//VOL1     DD  DSN=&DSN,DISP=SHR\n//CONTROL  DD  DSN=IEHPROGM.CTL(DELETE),DISP=SHR\n//SYSIN    DD  UNIT=VIO,SPACE=(TRK,1)\n//VOLUME01 DD  DISP=SHR,DSN=&DSN\n\nThe member of IEHPROGM.CTL would look like this:\n\n SCRATCH MEMBER=&0,VOL=SYSALLDA=&L,                                    x\n               DSNAME=&1\n\nIf the EXEC statement for this proc was this:\n\n//  EXEC DELETE,DSN=SYS1.LINKLIB,MEMBER=TEMPNAME\n\nand the dataset SYS1.LINKLIB resided on volume RESPAC, then the control\nstatement for IEHPROGM would look like this:\n\n SCRATCH  MEMBER=TEMPNAME,VOL=SYSALLDA=RESPAC,                        x\n                DSNAME=SYS1.LINKLIB\n\nAnd that's the actual statement that IEHPROGM would receive.  I'm sure\nthat other readers can envision more decorative examples but I'm only\ntrying to demonstrate the basic functions.\n\nI have, on several occaissions, used this mechanism to pump JCL directly\ninto the JES2 internal reader.  Simply point the SYSIN DD statement at\nthe internal reader directly and invoke a program that does nothing, such\nas IEFBR14.\n\nWhen you write this up, please give proper credit to Mike Eager, since he\nwrote the original program; I only modified it.\n\nYou may add this to the tape, as long as you associate BOTH names.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE277": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04V\\x00Y\\x01\\x13\\x05\\x0f\\x01\\x13\\x05\\x0f\\x11E\\x00\\x10\\x00\\x10\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf6@@@'", "ispf": {"version": "04.86", "flags": 0, "createdate": "2013-02-19T00:00:00", "modifydate": "2013-02-19T11:45:59", "lines": 16, "newlines": 16, "modlines": 0, "user": "CBT-486"}, "text": "//***FILE 277 IS FROM RICK FOCHTMAN OF CHICAGO, ILLINOIS AND HAS    *   FILE 277\n//*           A PROGRAM CALLED UTILITY.  THIS PROGRAM ALLOWS THE    *   FILE 277\n//*           SUBSTITUTION OF VALUES IN JCL, DEPENDING ON PARMS,    *   FILE 277\n//*           AND IS VERY VERSATILE.  LOOK AT THE SAMPLE DOC AND    *   FILE 277\n//*           COMMENTS IN THE CODE, FOR THE POSSIBILITIES.  GOOD    *   FILE 277\n//*           FOR PRODUCTION JCL, AND USING JCL OVER AGAIN WITHOUT  *   FILE 277\n//*           CHANGING MUCH.                                        *   FILE 277\n//*                                                                 *   FILE 277\n//*           MOST OF THE CODE WAS WRITTEN BY MIKE EAGER.           *   FILE 277\n//*                                                                 *   FILE 277\n//*           THIS PROGRAM ALLOWS SUBSTITUTION OF VARIABLES         *   FILE 277\n//*           ANYWHERE IN JCL, INCLUDING SYSIN CARDS.               *   FILE 277\n//*                                                                 *   FILE 277\n//*           email - sbgolob@cbttape.org     or                    *   FILE 277\n//*                   sbgolob@attglobal.net                         *   FILE 277\n//*                                                                 *   FILE 277\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UTILITY": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97&\\x8f\\x00\\x97&\\x8f\\x187\\x03]\\x03]\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-09-25T00:00:00", "modifydate": "1997-09-25T18:37:00", "lines": 861, "newlines": 861, "modlines": 0, "user": "SBGOLOB"}, "text": "UTILITY  TITLE 'BUILD UTILITY CONTROL CARDS FROM PARAMETER ENTRIES'\n*\n*   FOLLOWING MACROS ARE USED IN THIS ASSEMBLY:\n*        #XA, XX, $BREAK, $MVCSTR, $LR, $BSM, $SETLEN\n*\n         MACRO\n&L       #XA   &OP,&R=R1\n.* XA ADDRESSING MODE UTILITY\n         AIF   (T'&L EQ 'O').NOL\n&L       DS    0H\n.NOL     ANOP\n         AIF   ('&OP' EQ 'SET31').SET31 GO INTO 31 BIT MODE\n         AIF   ('&OP' EQ 'SET24').SET24 GO INTO 24 BIT MODE\n         AIF   ('&OP' EQ 'SETV').SETV   GO INTO MODE PER BIT 0 &R\n         AIF   ('&OP' EQ 'VER31').VER31 ABEND IF NOT IN 31 BIT MODE\n         AIF   ('&OP' EQ 'VER24').VER24 ABEND IF NOT IN 24 BIT MODE\n         AIF   ('&OP' EQ 'MODE').MODE   DETERMINE MODE, SET BIT 0 &R\n         MNOTE 8,'XA MACRO - BAD OP: &OP'\n         MEXIT\n.SET31   ANOP\n         L     &R,XA&SYSNDX\n         BSM   0,&R\nXA&SYSNDX DC   A(*+4+X'80000000')\n         MEXIT\n.SET24   ANOP\n         L     &R,XA&SYSNDX\n         BSM   0,&R\nXA&SYSNDX DC   A(*+4)\n         MEXIT\n.SETV    ANOP\n         N     &R,=X'80000000'\n         O     &R,XA&SYSNDX\n         BSM   0,&R\nXA&SYSNDX DC   A(*+4)\n         MEXIT\n.VER24   ANOP\n         SR    &R,&R               ZERO BITS 1-31\n         BSM   &R,0                SET BIT 0\n         LTR   &R,&R\n         BZ    XA&SYSNDX+2\nXA&SYSNDX DC   H'0'                ABEND - NOT IN EXPECTED MODE\n         MEXIT\n.VER31   ANOP\n         SR    &R,&R               ZERO BITS 1-31\n         BSM   &R,0                SET BIT 0\n         LTR   &R,&R\n         BNZ   XA&SYSNDX+2\nXA&SYSNDX DC   H'0'                ABEND - NOT IN EXPECTED MODE\n         MEXIT\n.MODE    ANOP\nXA&SYSNDX DS   0S(XA&SYSNDX)       FOR XREF\n         SR    &R,&R               ZERO BITS 1-31\n         BSM   &R,0                SET BIT 0\n         MEND\n         MACRO\n&NAME    $SETLEN &STR,       INPUT AREA ADDRESS                        X\n               &COUNT        LENGTH OF SCANNED PARAMETER\n         LCLA  &TRCNT\n         LCLA  &LENGTH\n&NAME    DS    0H\n         LA    15,&STR       POINT TO INPUT STRING\n         SR    &COUNT,&COUNT       ZEROIZE COUNT REGISTER.\nIHC&SYSNDX DS  0H\n         CLI   0(15),C' '    BLANK HERE ??\n         BE    IHC&SYSNDX.A        YES; ALL DONE\n         LA    &COUNT,1(,&COUNT)   ADD ONE TO COUNT\n         LA    15,1(,15)           BUMP SCAN POINTER\n         B     IHC&SYSNDX\nIHC&SYSNDX.A DS  0H\n         MEND\n         MACRO\n&LAB     $BSM  &MODE=24\n         LCLC  &LL\n&LL      SETC  '#BSM&SYSNDX'\n         AIF   ('&LAB' EQ '').NOLAB CHECK FOR LABEL\n&LAB     DS    0H                  MVS/XA SET MODE MACRO\n.NOLAB   ANOP\n         AIF   ('&MODE' EQ '31').XAON\n         AIF   ('&MODE' EQ '24').XAOFF\n         MNOTE 8,'MODE &MODE INVALID'\n         MEXIT\n.XAON    ANOP                      GO TO 31 BIT MODE\n         CNOP  2,4                 FORCE FULL WORD ALIGNMENT\n         LA    15,&LL              POINT TO AMODE = 31 CODE\n         O     15,&LL-4            TURN ON AMODE = 31 BIT\n         BSM   0,15                BRANCH TO AMODE = 31 CODE\n         DC    X'80000000'         AMODE = 31 BIT\n&LL      DS    0H\n         MEXIT\n.XAOFF   ANOP\n         CNOP  2,4                 FORCE FULL WORD ALIGNMENT\n         LA    15,&LL              POINT TO AMODE = 24 CODE\n         N     15,&LL-4\n         BSM   0,15                BRANCH TO AMODE = 24 CODE\n         DC    X'00FFFFFF'\n&LL      DS    0H\n         MEND\n         MACRO -- $BREAK -- SEARCH STRING FOR CHAR(S)\n&NAME    $BREAK  &RTN,             BREAK ROUTINE FOR CALL              X\n               &STR=(R1),          STRING POINTER                      X\n               &LEN=(R2),          LENGTH                              X\n               &CHAR=,             CHARS TO STOP AT                    X\n               &TYPE=,             TRT TO USE TRT TABLE                X\n               &DEF=,              YES TO DEFINE $BREAK ROUTINE        X\n               &FAIL=              LABEL FOR FAIL BRANCH\n.*\n.*\n.*       SEARCH STRING FOR THE FIRST OCCURANCE OF ANY CHAR IN &CHAR\n.*       AND RETURN POINTER TO THE CHAR, THE LENGTH OF THE STRING\n.*       SEARCHED, AND THE REMAINING LENGTH.\n.*\n.*       RETURN:\n.*\n.*             R0 -- LEN OF STRING SEARCHED\n.*             R1 -- POINTS TO CHAR THAT STOPPED SCAN OR END OF STR\n.*             R2 -- LEN OF STRING REMAINING\n.*             R3 -- POINTS TO START OF STRING\n.*             R4 -- MAY BE CHANGED IF LITERAL IS NOT USED\n.*\n.*             CC = Z IF CHAR NOT FOUND\n.*             CC NOT = Z IF CHAR FOUND\n.*\n.*\n.*       IF &CHAR IS NOT A QUOTED STRING IT MAY EITHER POINT TO\n.*       A CHARACTER STRING OR A TRT TABLE.  IF L'&CHAR=256 IT\n.*       IS ASSUMED TO BE A TRT TABLE, OR IF &TYPE=TRT IS SPECIFIED.\n.*       OTHERWISE IT IS ASSUMED TO BE A STRING OF STOP CHARACTERS.\n.*       ITS LENGTH ATTRIBUTE WILL BE USED AS THE COUNT OF CHARACTERS\n.*       TO CHECK.\n.*\n.*\n.*       IF &DEF=YES A ROUTINE WITH LABEL &NAME IS EXPANDED WITH A\n.*       BR  R14 RETURN.  &RTN MAY NOT BE SPECIFIED.  IF &FAIL IS\n.*       SPECIFIED IT WILL OVERRIDE ANY SPECIFICATION IN THE CALL FORM\n.*       OF THE MACRO.\n.*\n.*       IF &RTN IS SPECIFIED A BAL R14,&RTN WILL BE GENERATED.  &FAIL\n.*       MAY BE SPECIFIED IF IT WAS NOT SPECIFIED IN &RTN. &CHAR, &STR,\n.*       AND &LEN ARE IGNORED.\n.*\n.*\n         LCLA  &N,&KCHAR\n         LCLC  &L,&LQ,&CH\n         LCLB  &TRT,&CLC\n&LQ      SETC  'L'''\n         AIF   ('&RTN' NE '').CALL\n.NOCALL  AIF   ('&STR' EQ '' OR '&LEN' EQ '' OR '&CHAR' EQ '').E1\n         AIF   ('&CHAR'(1,1) EQ '''').NOT\n&TRT     SETB  ('&TYPE' EQ 'TRT' OR L'&CHAR EQ 256)\n.NOT     ANOP\n&CLC     SETB  ('&CHAR'(1,1) NE '''')\n&KCHAR   SETA  K'&CHAR\n         AIF   (NOT (&TRT OR &CLC OR &KCHAR GT 2)).E2\n         AIF   ('&NAME' EQ '').NONM\n&NAME    DS    0H\n.NONM    $LR   R1,&STR             POINT R1 TO STRING\n         $LR   R2,&LEN             SET R2 TO STRING LENGTH\n         AIF   (&TRT).TRT\n         AIF   ('&CHAR'(1,1) NE '''').CLC\n.*\n.*       GENERATE CLI'S FOR CHARACTERS\n.*\n         LR    R3,R1               SAVE START ADDR\n&N       SETA  2\n&L       SETC  '#$BA&SYSNDX'\n.CHKQUOT AIF   ('&CHAR'(&N,2) EQ '''''' OR '&CHAR'(&N,2) EQ '&&').QA\n&CH      SETC  '&CHAR'(&N,1)\n         AGO   .BE\n.QA      ANOP\n&CH      SETC  '&CHAR'(&N,2)\n&N       SETA  &N+1\n.BE      ANOP\n&L       CLI   0(R1),C'&CH'\n         BE    #$BB&SYSNDX\n&N       SETA  &N+1\n&L       SETC  ''\n         AIF   (&N LT &KCHAR).CHKQUOT\n         LA    R1,1(R1)            MOVE TO NEXT CHAR\n         BCT   R2,#$BA&SYSNDX      CHECK IF MORE\n#$BB&SYSNDX LR R0,R1\n         SR    R0,R3               FIND LEN SEARCHED\n         LTR   R2,R2               SET CC\n         AGO   .TFAIL\n.*\n.*\n.*\n.*       GENERATE CLC LOOP FOR STRING\n.*\n.CLC     LR    R0,R1\n#$BA&SYSNDX LA R3,&LQ&CHAR         GET CHAR LENGTH\n         LA    R4,&CHAR-1(R3)      POINT TO LAST CHAR\n#$BB&SYSNDX CLC 0(1,R1),0(R4)      COMPARE\n         BE    #$BC&SYSNDX\n         BCTR  R4,0\n         BCT   R3,#$BB&SYSNDX      CHECK ALL\n         LA    R1,1(R1)            POINT TO NEXT\n         BCT   R2,#$BA&SYSNDX\n#$BC&SYSNDX LR R3,R0\n         LR    R0,R1\n         SR    R0,R3               FIND LEN SEARCHED\n         LTR   R2,R2               SET CC\n         AGO   .TFAIL\n.*\n.*\n.*\n.TRT     LR    R3,R1\n         LR    R0,R2\n         LTR   R2,R2\n         BZ    #$BA&SYSNDX\n         BCT   R2,*+10\n         TRT   0(*-*,R1),&CHAR\n         EX    R2,*-6\n         BZ    #$BA&SYSNDX\n         LR    R2,R0\n         LR    R0,R1\n         SR    R0,R3\n         SR    R2,R0\n#$BA&SYSNDX DS 0H\n         AGO   .TFAIL\n.CALL    AIF   ('&DEF' EQ 'YES' OR '&CHAR' NE '').E3\n&NAME    BAL   R14,&RTN\n.TFAIL   AIF   ('&FAIL' EQ '').DEFRET\n         BZ    &FAIL\n.DEFRET  AIF   ('&DEF' NE 'YES').MEXIT\n         BR    R14                 RETURN TO CALLER\n.MEXIT   MEXIT\n.E1      MNOTE 4,'$BREAK -- CHAR NOT SPECIFIED'\n         MEXIT\n.E2      MNOTE 4,'$BREAK -- CHAR IS NULL STRING'\n         MEXIT\n.E3      MNOTE 2,'&RTN -- INVALID SPECIFICATION IGNORED'\n         AGO   .NOCALL\n         MEND\n         EJECT\n         MACRO -- $MVCSTR -- MOVE STRING SEGMENT\n&NAME    $MVCSTR  &TO,             DESTINATION                         X\n               &STR=(R3),          STRING POINTER                      X\n               &LEN=(R0),          STRING LENGTH                       X\n               &MAX=,              MAXIMUM LENGTH TO MOVE              X\n               &WKREG=R15          WORK REGISTER\n.*\n.*\n.*       MOVE STRING SEGMENT TO &TO FORM &STR FOR LENGTH &LEN.\n.*\n.*       IF &MAX IS SPECIFIED ONLY THAT NUMBER OR LESS CHARACTERS\n.*       WILL BE MOVED.\n.*\n         LCLC  &RLEN,&TOR,&OH\n&NAME    DS    0H\n         AIF   ('&MAX' EQ '').NOMAX\n         $LR   &WKREG,&MAX         GET MAX LENGTH\n&RLEN    SETC  'R0'\n         AIF   ('&LEN'(1,1) NE '(').LR\n&RLEN    SETC  '&LEN'(2,K'&LEN-2)\n         AGO   .CR\n.LR      ANOP\n         $LR   R0,&LEN             GET CUR LEN\n.CR      CR    &WKREG,&RLEN        CHECK IF GREATER THAN MAX\n         BL    *+6                 YES, USE MAX\n         LR    &WKREG,&RLEN        USE CURRENT LENGTH\n.EXP     BCT   &WKREG,*+10         GET 360 LEN, SKIP MVC\n         AIF   ('&STR'(1,1) NE '(').MVC\n&OH      SETC  '0'\n.MVC     AIF   ('&TO'(1,1) EQ '(').TOR\n         MVC   &TO.(*-*),&OH&STR   MOVE STRING\n         AGO   .EX\n.TOR     ANOP\n&TOR     SETC  '&TO'(2,K'&TO-2)\n         MVC   0(*-*,&TOR),&OH&STR MOVE STRING\n.EX      EX    &WKREG,*-6          DO IT\n         MEXIT\n.NOMAX   $LR   &WKREG,&LEN\n         AGO   .EXP\n         MEND\n         SPACE 5\n         MACRO\n&L       $LR   &A,&B\n.*********************************************************************\n.*       $LR\n.*\n.*       A   --DESTINATION REGISTER.\n.*       B   --INPUT VALUE.\n.*\n.*********************************************************************\n         LCLA  &N                  STRING COUNT.\n         LCLC  &R                  REGISTER SYMBOL.\n         LCLC  &V                  VALUE DIGITS.\n         AIF   (T'&A NE 'O').OKA\n         MNOTE 8,'LRM100E DESTINATION REGISTER NOT SPECIFIED'\n         MEXIT\n.OKA     ANOP\n         AIF   (T'&B NE 'O').OKB\n         MNOTE 8,'LRM110E VALUE/STRING/REGISTER NOT SPECIFIED'\n         MEXIT\n.OKB     ANOP\n         AIF   ('&B'(1,1) EQ '''').STR\n         AIF   ('&B'(1,1) EQ '(').REG\n         AIF   (T'&B EQ 'N').LDNUM\n.VARBL   ANOP\n&L       LA    &A,&B               LOAD VARIABLE ADDRESS.\n         MEXIT\n.LDNUM   ANOP\n         AIF   ('&B'(1,1) EQ '+' OR '&B'(1,1) EQ '-').STRIP\n         AIF   (&B EQ 0).CLREG\n         AIF   (&B GT 32767).VAL\n         AIF   (&B GT 0 AND &B LT 4096).VARBL\n.VALH    ANOP\n&L       LH    &A,=Y'&B'           LOAD HALFWORD VALUE.\n         MEXIT\n.STRIP   ANOP\n&N       SETA  K'&B-1\n         AIF   (&N GT 5).VAL\n&V       SETC  '&B'(2,&N)\n         AIF   (&V GT 32767).VAL\n         AGO   .VALH\n.CLREG   ANOP\n&L       SLR   &A,&A               VALUE = 0.\n         MEXIT\n.VAL     ANOP\n&L       L     &A,=A'&B'           LOAD FULLWORD VALUE.\n         MEXIT\n.REG     ANOP\n&N       SETA  K'&B-2              COMPUTE NO. OF CHARS. IN STR.\n&R       SETC  '&B'(2,&N)          MOVE REGISTER SYMBOL TO VARIABLE.\n         AIF   ('&R' EQ '&A').EXIT\n         AIF   ('&R' EQ 'R&A' OR 'R&R' EQ '&A').EXIT\n&L       LR    &A,&R               MOVE REGISTER TO DESTINATION.\n         MEXIT\n.STR     ANOP\n&L       LA    &A,=C&B             LOAD ADDRESS OF  LITERAL.\n.EXIT    ANOP\n         MEND\n         EJECT\n***********************************************************************\n*                                                                     *\n*  TITLE:        UTILITY -- CONTROL CARD GENERATOR                    *\n*                                                                     *\n*  PROGRAMMER:   RICK FOCHTMAN                                        *\n*                TRAILER TRAIN COMPANY                                *\n*                300 S. WACKER DRIVE                                  *\n*                CHICAGO, IL                                          *\n*                                                                     *\n*  THIS IS A MODIFICATION OF AN ORIGINAL PROGRAM BY MIKE EAGER,       *\n*          AMERICAN MEDICAL ASSOCIATION, CHICAGO, IL.                 *\n*                                                                     *\n*  DATE:         13 NOVEMBER 1979                                     *\n*                                                                     *\n*  CSECT:        UTILITY                                              *\n*                                                                     *\n*  INPUT:        PARM FIELD:                                          *\n*                  FIELD 1 -- PROGRAM NAME                            *\n*                  FIELDS 2-11 -- ACTUAL PARAMETERS                   *\n*                                                                     *\n*                CONTROL (80 BYTE RECORDS)                            *\n*                  PROTOTYPE CONTROL CARDS TO BE MODIFIED             *\n*                                                                     *\n*  OUTPUT:       SYSIN (80 BYTE RECORDS)                              *\n*                  CONTROL CARDS MODIFIED WITH ACTUAL PARAMETERS      *\n*                                                                     *\n*  FUNCTION:     READ CONTROL CARDS FROM 'CONTROL' AND INSPECT        *\n*                FOR AMPERSAND FOLLOWED BY CHAR.  SUBSTITUTE          *\n*                ACTUAL PARAMETER FROM PARM FIELD USING 2ND PARM      *\n*                FOR &0, ETC.  IF A CONTROL CARD REFERENCES A         *\n*                NULL ACTUAL PARAMETER IGNORE THE CARD AND GET        *\n*                NEXT CARD.  AFTER ALL SUBSTITUTIONS ARE MADE CARD    *\n*                IS WRITTEN TO 'SYSIN'.                               *\n*                                                                     *\n*  SPECIAL SUBSTITUTIONS FOR 370'S RUNNING MVS AND JES2               *\n*                &A   SMF SYSTEM IDENTIFIER                           *\n*                &B   CPU MODEL NUMBER                                *\n*                &C   CPU SERIAL NUMBER                               *\n*                &D   CPU VERSION NUMBER                              *\n*                &E   RACF USERID, WHERE AVAILABLE                    *\n*                &F   RACF GROUP ID, WHERE AVAILABLE                  *\n*                &G   JES2 REMOTE NUMBER, IN THE FORM N##R##,         *\n*                     WHERE N## IS THE ORIGINATING NJE NODE AND       *\n*                     WHERE R## IS THE ORIGINATION RJE STATION        *\n*                &H   FIRST WORD OF THE CPU CLOCK, IN HEX             *\n*                &I   SECOND WORD OF THE CPU CLOCK, IN HEX            *\n*                &J   FIRST SEVEN CHARACTERS OF THE &H VALUE          *\n*                &K   LAST CHARACTER OF &H + FIRST SIX OF &I          *\n*                     SINCE THE LAST 12 BITS OF THE CPU CLOCK ARE     *\n*                     LESS THAN MICROSECOND VALUES, &J&K ARE THE      *\n*                     CPU CLOCK TO LESS THAN MICROSECOND PRECISION.   *\n*                 &L  VOLSER OF THE VOL1 DD STATEMENT, IF PRESENT     *\n*                 &M  VOLSER OF THE VOL2 DD STATEMENT, IF PRESENT     *\n*                 &N  VOLSER OF THE VOL3 DD STATEMENT, IF PRESENT     *\n*                 &O  VOLSER OF THE VOL4 DD STATEMENT, IF PRESENT     *\n*                 &P  VOLSER OF THE VOL5 DD STATEMENT, IF PRESENT     *\n*                 &Q  VOLSER OF THE VOL6 DD STATEMENT, IF PRESENT     *\n*                 &R  JES2 JOB IDENTIFIER ('JOB12345', E.G.)          *\n*                                                                     *\n*  LOGIC:        THE PARAMETER FIELD IS SCANNED TO PICK OFF THE       *\n*                PROGRAM NAME WHICH IS COPIED INTO 'PGM'.  THE        *\n*                REMAINING PARAMETER FIELDS ARE SCANNED AND THE       *\n*                STARTING ADDRESS AND LENGTH OF EACH FIELD IS         *\n*                PLACED INTO SUCCESSIVE WORDS STARTING WITH           *\n*                'PARMINDX'.  'CONTROL' AND 'SYSIN' DATASETS ARE      *\n*                OPENED AND VALIDATED.  EACH CARD IS READ FROM        *\n*                'CONTROL' AND THE SEQUENCE FIELD (COL 72-80)         *\n*                IS COPIED TO AN OUTPUT AREA.  THE FIRST 71 COLS      *\n*                ARE SCANNED FOR '&'.  THE CHARACTERS SKIPPED OVER    *\n*                ARE COPIED UP TO THE MAXIMUM LENGTH REMAINING IN     *\n*                THE OUTPUT AREA.  IF THERE IS NOT ENOUGH ROOM IN THE *\n*                OUTPUT AREA THE CARD IS TRUNCATED WITHOUT ANY        *\n*                ERROR MESSAGE.  THE DIGIT AFTER THE '&' IS USED TO   *\n*                INDEX INTO 'PARMINDX' AND IF THERE IS ENOUGH ROOM    *\n*                IN THE OUTPUT AREA, THE ACTUAL PARAMETER IS MOVED    *\n*                TO THE NEXT LOCATION IN THE OUTPUT AREA.  THE '&'    *\n*                AND DIGIT ARE SKIPPED AND THE SCAN RESUMES.  WHEN    *\n*                THE INPUT IS EXHAUSTED, THE REMAINDER OF THE INPUT   *\n*                IS COPIED TO THE OUTPUT AND THE CARD OUTPUT TO       *\n*                'SYSIN'. IF ANY ACTUAL PARAMETER REFERENCED IN THE   *\n*                CONTROL CARD IS OMITTED, THE CARD WILL NOT BE WRITTEN*\n*                TO 'SYSIN'. AT EOF ON 'CONTROL' BOTH 'SYSIN' AND     *\n*                'CONTROL' ARE CLOSED AND THE PROGRAM REFERENCED IN THE\n*                FIRST PARM IS LINKED TO.  IF THE RETURN CODE IS NON- *\n*                ZERO THE TIOT ADDRESS IS EXTRACTED AND A MESSAGE     *\n*                CONTAINING THE JOBNAME, STEPNAME, AND RETURN CODE    *\n*                IS WRITTEN TO THE OPERATOR.  UTILITY THEN RETURNS.   *\n*                                                                     *\n*  MODIFICATION HISTORY:                                              *\n*     1 DECEMBER, 1979 -- CHANGE PARAMETER SCAN TO RECOGNIZE QUOTE    *\n*           OR PAREN AND BREAK ON MATCHING QUOTE OR PAREN INSTEAD     *\n*           OF AN IMBEDDED COMMA.  LEADING AND TRAILING QUOTES ARE    *\n*           DELETED, OPEN AND CLOSE PARENS ARE KEPT AS PART OF        *\n*           PARM.  ALSO USE OS SAVE AND RETURN MACROS.                *\n*                                                                     *\n*     4 MARCH 1991 --- INCLUDE HOOKS TO FETCH NJE/RJE ORIGIN ID;      *\n*           ADD THE SPECIAL SUBSTITUTIONS FOR RACF, SYSTEM            *\n*           IDENTIFICATION, CPU CLOCK, VOLSERS, TIME AND DATE.        *\n*                                                                     *\n*  ATTRIBUTES:   SERIALLY REUSABLE, AUTHORIZED                        *\n*                                                                     *\n*  MACROS USED:  $BREAK, $MVCSTR, XX, OPEN, WTO, ABEND, RETURN,       *\n*                PUT, CLOSE, LINK, EXTRACT, DCB.                      *\n*                                                                     *\n***********************************************************************\n         EJECT\n         SPACE 5\nUTILITY  CSECT\n         PRINT ON,NOGEN\n         $HASPEQU\n         USING UTILITY,R15\n         STM   R14,R12,12(R13)     STANDARD LINKAGE\n         ST    R13,SAVEAREA+4\n         LA    R12,SAVEAREA\n         ST    R12,8(R13)\n         LR    R13,R12\n         LR    R12,R15             ESTABLISH BASE REGISTER\n         DROP  R15\n         USING UTILITY,R12\n         SPACE 5\n*\n*  PICK UP PROGRAM NAME FROM PARM LIST\n*\n         L     R1,0(R1)            POINT TO PARM LIST\n         LH    R2,0(R1)            PICK UP LENGTH\n         LA    R1,2(R1)            POINT TO START OF PARM\n         MVC   PGM,=CL8' '         CLEAR PROGRAM NAME\n        $BREAK CHAR=',',FAIL=PARMERR  GET PROGRAM NAME\n        $MVCSTR PGM                   SET FOR LINK\n*\n*  SPLIT OUT PARAMETER ENTRIES AND BUILD INDEX\n*\n         LA    R1,1(R1)            BUMP PAST COMMA\n         BCT   R2,*+8              DECR LENGTH\n         B     PARMERR             NO PARAMTERS\n         XC    PARMINDX(40),PARMINDX  MAKE SERIALLY REUSABLE\n         LA    R6,PARMINDX         POINT TO ZEROTH INDEX ENTRY\nPARMLP   DS    0H                  PICK OFF PARAMETER\n         ST    R1,0(R6)            SAVE PARM ADDRESS\n         STC   R2,0(R6)            SAVE LENGTH IF LAST\n         CLI   0(R1),C''''         QUOTED STRING?\n         BNE   CHKLPRN             NO, SEE IF PAREN\n         LA    R1,1(R1)            BUMP PAST QUOTE\n         ST    R1,0(R6)            SAVE START POINTER\n         BCT   R2,*+8              DECR COUNT\n         B     PARMERR             ISOLATED QUOTE\n        $BREAK CHAR='''',FAIL=PARMERR   FIND ENDING QUOTE\n         B     SETLEN              GO SET STRING LENGTH\n*\nCHKLPRN  DS    0H\n         CLI   0(R1),C'('          LEFT PAREN?\n         BNE   BRKNXT              NO, FIND END OF PARM\n         ST    R1,0(R6)            SAVE START POINTER\n        $BREAK CHAR=')',FAIL=PARMERR   FIND ENDING RT PAREN\n         A     R0,=F'1'            INCR COUNT TO INCLUDE PAREN\n*\nSETLEN   DS    0H\n         STC   R0,0(R6)            SAVE LENGTH\n         LA    R1,1(R1)            BUMP PAST QUOTE OR PAREN\n         BCT   R2,*+8              DECR LENGTH\n         B     LPARM               LAST ENTRY\n         CLI   0(R1),C','          MUST END WITH COMMA\n         BNE   PARMERR             BUT IT DOESN'T\n         LA    R1,1(R1)            BUMP PAST COMMA\n         BCT   R2,*+8\n         B     LPARM               OPEN DATASETS IF COMMA IS LAST CHAR\n         LA    R6,4(R6)            POINT TO NEXT ENTRY\n         B     PARMLP              GET NEXT PARM\n*\nBRKNXT   DS    0H\n        $BREAK CHAR=',',FAIL=LPARM SCAN FOR COMMA\n         STC   R0,0(R6)            SAVE LENGTH OF PARM\n         BCT   R2,*+8              COMMA IS LAST CHAR?\n         B     LPARM               OPEN DATASETS IF YES\n         LA    R1,1(R1)            BUMP OVER COMMA\n         LA    R6,4(R6)            POINT TO NEXT INDEX ENTRY\n         B     PARMLP              DO NEXT PARM\nLPARM    DS    0H                  SET LAST PARM ENTRY\n         SPACE 5\n***********************************************************************\n*        THE FOLLOWING THREE INSTRUCTIONS ARE THE ONLY AUTHORIZED     *\n*              CODE IN THIS ROUTINE, OTHER THAN POSSIBLY THE PROGRAM  *\n*              NAMED IN THE PARM FIELD.                               *\n***********************************************************************\n         MODESET MODE=SUP\n         STIDP DBLWD               STORE CPU IDENTIFIER\n         MODESET MODE=PROB\n         UNPK  CPU(5),DBLWD+4(3)\n         UNPK  CPUSER(7),DBLWD+1(4)\n         UNPK  VERSION(3),DBLWD(2)\n         EXTRACT TIOTADDR,'S',FIELDS=(TIOT)  FIND TIOT ADDR\n         LA    R2,S12              POINT TO VOLSER AREA\n         LA    R1,DDNLIST          AND DDNAME LIST\n         LA    R5,6                LOAD ITEM COUNT\nSER1     DS    0H\n         BAL   R9,GETUCB           GET THE UCB ADDRESS\n         LTR   R0,R0               GET AN ANYTHING BACK ??\n         BZ    SER2                NOPE ---\n         LR    R4,R0               COPY THE UCB ADDRESS\n         USING UCBOB,R4            AND BASE ITS DSECT\n         TM    UCBTBYT3,UCB3DACC   DASD DEVICE ??\n         BZ    SER2                NOPE; SKIP THIS\n         L     R15,0(,R2)          LOAD STRING ADDRESS\n         MVC   0(6,R15),UCBVOLI    COPY THE VOLSER\n         $SETLEN 0(,R15),R14\n         STC   R14,0(,R2)\nSER2     DS    0H\n         LA    R2,4(,R2)           POINT TO NEXT ENTRY\n         LA    R1,8(,R1)           POINT TO NEXT ENTRY\n         BCT   R5,SER1             AND LOOP ??\n*        B     NONODE              UN-COMMENT IF NOT JES2\n*---------------------------------------------------------------------*\n*---     THE FOLLOWING INSTRUCTIONS ARE ABSOLUTELY DEPENDANT UPON  ---*\n*---     THE VARIOUS CONTROL BLOCKS REFERENCED IN THE COMMENTS.    ---*\n*---------------------------------------------------------------------*\n         #XA   SET31,R=R15\n         L     R4,CVTPTR                      LOAD CVT ADDRESS\n         L     R4,CVTTCBP-CVT(,R4)            POINT TO TCBBOX\n         L     R4,4(,R4)                      POINT TO CURRENT TCB\n         L     R4,TCBJSCBB-1-TCB(,R4)         POINT TO CURRENT JSCB\n         L     R4,JSCBACT-IEZJSCB(,R4)        POINT TO ACTIVE JSCB\n         L     R4,JSCBSSIB-IEZJSCB(,R4)       POINT TO SSIB\n         L     R4,SSIBSUSE-SSIB(,R4)          POINT TO SJB\n         L     R4,SJBJCT-SJB(,R4)             POINT TO JES2 JCT\n         OC    JOBID,JCTJOBID-JCT(R4)         COPY JES2 JOBID\n         ICM   R4,15,JCTROUTE-JCT(R4)  INSERT NODE/RMT ID'S\n         #XA   SET24,R=R15\n*---------------------------------------------------------------------*\n*---     END OF JES2-LEVEL DEPENDANT INSTRUCTIONS                  ---*\n*---------------------------------------------------------------------*\n         SRDL  R4,16               SPLIT THE TWO\n         SRL   R5,16               SHIFT RMT NUMBER DOWN\n         CVD   R4,CVDWORK          DECIMALIZE NJE NODE ID\n         OI    CVDWORK+7,X'0F'     FORCE LAST SIGN POSITIVE\n         UNPK  CHAR1,CVDWORK       INSERT THE ZONES\n         MVI   CHAR1,C'N'          INSERT THE NJE MARKER\nL1       DS    0H\n         CLI   CHAR1+1,C'0'        LEADING ZERO ??\n         BNE   L2                  NOPE ---\n         MVC   CHAR1+1(8),CHAR1+2  SHIFT THE VALUE LEFT 1 POSITION\n         B     L1                  AND CONTINUE ---\nL2       DS    0H\n         LA    R4,CHAR1+1          POINT TO START OF NUMERICS\nL3       DS    0H\n         CLI   0(R4),C' '          TRAILING BLANK ??\n         BE    L4                  YES; ALL DONE\n         LA    R4,1(,R4)           NOPE; KEEP LOOKING ---\n         B     L3\nL4       DS    0H\n         LTR   R5,R5               WAS IT RMT 0 ??\n         BZ    RMT0                YES; SPECIAL 'FAST' PATH\n         CVD   R5,CVDWORK          DECIMALIZE IT\n         OI    CVDWORK+7,X'0F'     FORCE LAST SIGN POSITIVE\n         UNPK  CHAR2,CVDWORK       INSERT THE ZONES\n         MVI   CHAR2,C'R'\nL5       DS    0H\n         CLI   CHAR2+1,C'0'        LEADING ZERO ??\n         BNE   L6                  NOPE\n         MVC   CHAR2+1(8),CHAR2+2  CLOBBER A LEADING ZERO\n         B     L5                  AND RETRY ---\nRMT0     DS    0H\n         MVC   CHAR2(8),=CL8'R0'\nL6       DS    0H\n         MVC   0(8,R4),CHAR2       COMPRESS THEM TOGETHER\n         LA    R3,0                LOAD A ZERO VALUE\n         LA    R2,CHAR1            LOAD POINTER TO THE RESULT\nL7       DS    0H\n         CLI   0(R2),C' '          TRAILING BLANK ??\n         BE    L8                  YES; ALL DONE\n         LA    R3,1(,R3)           INCREMENT COUNT BY ONE\n         LA    R2,1(,R2)           INCREMENT POINTER BY ONE\n         B     L7                  AND CONTINUE\nL8       DS    0H\n         STC   R3,CHAR1-1          SAVE THE COUNT VALUE\n         L     R10,0(,R10)         LOAD PARM POINTER\n         MVC   NJEN,CHAR1-1        COPY TO CALLER'S AREA\nNONODE   DS    0H\n         L     R1,16               LOAD CVT ADDRESS\n         L     R1,196(,R1)         LOAD SMCA ADDRESS\n         MVC   SYSTEM,16(R1)       COPY SID TO PARM AREA\n         CLI   SYSTEM+3,64\n         BH    DOACEE\n         MVI   S1,3\n         CLI   SYSTEM+2,64\n         BH    DOACEE\n         MVI   S1,2\n         CLI   SYSTEM+1,64\n         BH    DOACEE\n         MVI   S1,1\nDOACEE   DS    0H\n         L     R1,X'224'           LOAD ASCB ADDRESS\n         L     R1,X'6C'(,R1)       POINT TO ASXB\n         L     R1,X'C8'(,R1)       POINT TO ACEE, IF ANY\n         LTR   R1,R1               ANY ACEE EXIST ??\n         BZ    NOACEE              NOPE ---\n         USING ACEE,R1             BASE ITS DSECT\n         MVC   USERID,ACEEUSRI     COPY USERID FROM ACEE\n         MVC   S5(1),ACEEUSRL      COPY USERID LENGTH FROM ACEE\n         MVC   GROUP,ACEEGRPN      COPY GROUP FROM ACEE\n         MVC   S6(1),ACEEGRPL      COPY GROUP LENGTH FROM ACEE\n         DROP  R1\nNOACEE   DS    0H\n         STCK  DBLWD               SAVE THE CPU CLOCK VALUE\n         UNPK  CLOCK1(9),DBLWD(5)   UNPACK THE FIRST HALF\n         UNPK  CLOCK2(9),DBLWD+4(5) AND SECOND HALF\n         NC    CLOCK1(16),=16X'0F'  DROP ZONES\n         TR    CLOCK1(16),=C'0123456789ABCDEF'\n         SPACE 5\nOPENDS   DS    0H                  OPEN DATASETS AND CHECK\n         OPEN  (CONTROL,INPUT,SYSIN,OUTPUT)\n         TM    CONTROL+DCBOFLGS,X'10' OPEN?\n         BNO   ABEND               NO, QUIT\n         TM    SYSIN+DCBOFLGS,X'10' OPEN?\n         BO    LOOP                YES, CONTINUE\nABEND    DS    0H\n         WTO   'UNABLE TO OPEN SYSIN OR CONTROL'\n         ABEND 100,DUMP\nPARMERR  WTO   'UTILITY PARM ERROR'\n         ABEND 101,DUMP\n         EJECT\n*\n*  START OF LOOP TO READ CARDS AND SUBSTITUTE PARM ENTRIES FOR\n*  VARIABLE SYMBOLS\n*\nLOOP     DS    0H\n         GET   CONTROL             READ CARD\n*                                  R1 NOW POINTS TO CARD\n         LA    R2,71               SCAN ONLY 71 COLUMNS\n         LA    R10,CARDOUT         POINT TO OUTPUT CARD AREA\n         LR    R11,R2              COPY ONLY 71 COLUMNS\n         MVC   SEQOUT,71(R1)       COPY SEQUENCE FIELD\n*\n*  SCAN FOR VARIABLE SYMBOLS\n*\nSCAN     DS    0H\n         LR    R6,R2               SAVE REMAINING STRING LENGTH\n        $BREAK CHAR='&&',FAIL=NOVAR LOOK FOR VARIABLE STARTING WITH '&'\n         LTR   R0,R0               WERE ANY SKIPPED?\n         BZ    NOSKIP              NO CHARACTERS JUMPED\n        $MVCSTR (R10),MAX=(R11)    COPY (NOT TOO MUCH)\n         SR    R11,R0              FIND REMAINING OUTPUT LENGTH\n         BNP   OVERFLOW            OVERFLOW IF TOO MUCH\n         AR    R10,R0              BUMP OUTPUT POINTER\nNOSKIP   DS    0H\n         BCT   R2,*+8              DECR LENGTH OF INPUT\n         B     OVERFLOW            OVERFLOW IF ZERO\n         SLR   R6,R6               CLEAR WORK REGS\n         LR    R7,R6\n         IC    R6,1(R1)            PICK UP DIGIT\n         IC    R6,TTAB(R6)         TRANSLATE TO INTERNAL VALUE\n*        N     R6,=F'15'           CONVERT TO BINARY\n         SLL   R6,2                CONVERT TO FULL WORD POINTER\n         IC    R7,PARMINDX(R6)     PICK UP PARM LENGTH\n         LTR   R7,R7               PARM OMITTED?\n         BZ    CLEARLN             YES, SKIP THIS CARD\n         CR    R7,R11              ENOUGH ROOM FOR PARM\n         BH    OVERFLOW            NO, OVERFLOW\n         L     R6,PARMINDX(R6)     POINT TO STRING\n        $MVCSTR (R10),LEN=(R7),STR=(R6)  COPY TO OUTPUT\n         SR    R11,R7              GET OUTPUT LENGTH REMAINING\n         AR    R10,R7              POINT TO NEXT OUTPUT POSITION\n         LA    R1,2(R1)            BUMP PAST VARIABLE\n         BCT   R2,SCAN             DO MORE IF MORE CHARS REMAIN\n         B     PUTCARD             NONE LEFT, OUTPUT CARD\n         SPACE 3\nTTAB     DC    XL16'00000000000000000000000000000000'  00\n         DC    XL16'00000000000000000000000000000000'  10\n         DC    XL16'00000000000000000000000000000000'  20\n         DC    XL16'00000000000000000000000000000000'  30\n         DC    XL16'00000000000000000000000000000000'  40\n         DC    XL16'00000000000000000000000000000000'  50\n         DC    XL16'00000000000000000000000000000000'  60\n         DC    XL16'00000000000000000000000000000000'  70\n         DC    XL16'00000000000000000000000000000000'  80\n         DC    XL16'00000000000000000000000000000000'  90\n         DC    XL16'00000000000000000000000000000000'  A0\n         DC    XL16'00000000000000000000000000000000'  B0\n         DC    XL16'000A0B0C0D0E0F101112000000000000'  C0\n         DC    XL16'00131415161718191A1B000000000000'  D0\n         DC    XL16'00001C1D1E1F20212223000000000000'  E0\n         DC    XL16'00010203040506070809000000000000'  F0\n*\n*  NO MORE VARIABLE SYMBOLS ON CARD\n*\nNOVAR    DS    0H\n        $MVCSTR (R10),STR=(R3),LEN=(R6),MAX=(R11)  COPY REMAINDER\n         SPACE 3\nOVERFLOW DS    0H                  NOT ENOUGH ROOM ON CARD\nPUTCARD  DS    0H                  OUTPUT MODIFIED CARD\n         PUT   SYSIN,CARDOUT\nCLEARLN  MVC   CARDOUT,=CL71' '    CLEAR OUTPUT CARD\n         B     LOOP                DO NEXT CARD\n         EJECT\n*\n*  ALL CARDS CONVERTED\n*  CLOSE FILES AND LINK TO PROGRAM WITH NULL PARM LIST\n*\nNOMORE   DS    0H                  END OF INPUT\n         CLOSE (CONTROL,,SYSIN)     CLOSE FILES\n         SPACE 3\n         LINK  EPLOC=PGM,PARAM=NULL,VL=1\n         LTR   R15,R15             OK RETURN\n         BZ    RETURN              YES\n*\n*  NON-ZERO RETURN CODE\n*  CONSTRUCT MESSAGE FOR OPERATOR\n*\n         LR    R8,R15              SAVE RETURN CODE\n         L     R6,TIOTADDR         PICK UP ADDR OF TIOT\n         MVC   MSG+8(8),0(R6)      SET JOBNAME\n         MVC   MSG+17(8),8(R6)     SET STEPNAME\n         CVD   R8,CVDWORK          CONVERT RC\n         UNPK  MSG+36(5),CVDWORK+5(3)  SET IN MSG\n         OI    MSG+40,X'F0'        SET TO NUMBER\n         MVI   MSG+36,C'='\nMSG      WTO   'JOBNAMEX STEPNAME ERROR CODE=XXXX'\n         LR    R15,R8              RESTORE RETURN CODE\n         SPACE 5\nRETURN   DS    0H\n         L     R13,SAVEAREA+4      POINT TO OLD SAVEAREA\n         RETURN (14,12),,RC=(15)   RETURN WITH RETURN CODE\n         EJECT\n*---------------------------------------------------------------------*\n*---                                                               ---*\n*---     THIS LITTLE LOCAL SUBROUTINE WILL LOCATE A DD STATEMENT   ---*\n*---     ENTRY IN THE TIOT AND RETURN THE ASSOCIATED UCB ADDRESS.  ---*\n*---     NOTE THAT IT RUNS IN AMODE-31.  NON-XA SYSTEMS BEWARE!!   ---*\n*---                                                               ---*\n*---------------------------------------------------------------------*\nGETUCB   DS    0H\n         $BSM  MODE=31\n         SLR   R0,R0               CLEAR RETURN REGISTER\n         L     R14,TIOTADDR        LOAD TIOT ADDRESS\n         LA    R14,24(,R14)        POINT TO FIRST DD ENTRY\nGU1      DS    0H\n         CLI   0(R14),0            AT TIOT END ??\n         BE    GU3                 YES; ALL DONE\n         CLC   4(8,R14),0(R1)      GOT THE DD ENTRY ??\n         BE    GU2                 YES ---\n         SR    R15,R15             CLEAR A WORK REGISTER\n         IC    R15,0(,R14)         INSERT TIOE LENGTH\n         LA    R14,0(R15,R14)      POINT TO NEXT TIOE\n         B     GU1                 AND LOOP\nGU2      DS    0H\n         ICM   R0,7,17(R14)        INSERT UCB ADDRESS\nGU3      DS    0H\n         $BSM  MODE=24\n         BR    R9                  RETURN TO LOCAL CALLER\n         EJECT\n*\n*  DCB'S AND WORK AREAS\n*\nCONTROL  DCB   DDNAME=CONTROL,DSORG=PS,MACRF=(GL),LRECL=80,            X\n               EODAD=NOMORE,RECFM=FB\nSYSIN    DCB   DDNAME=SYSIN,DSORG=PS,MACRF=(PM),LRECL=80,BLKSIZE=400,  X\n               RECFM=FB\n*\nDCBOFLGS EQU   48                  OPEN FLAGS\n*\nDDNLIST  DC    CL8'VOL1'\n         DC    CL8'VOL2'\n         DC    CL8'VOL3'\n         DC    CL8'VOL4'\n         DC    CL8'VOL5'\n         DC    CL8'VOL6'\nCARDOUT  DC    CL71' '             OUTPUT CARD AREA\n         ORG   CARDOUT\nCHAR1    DS    CL8\nCHAR2    DS    CL8\n         ORG\nSEQOUT   DC    CL9' '              OUTPUT SEQUENCE FIELD\n*\nDBLWD    DS    D\nPARMINDX DC    10F'0'              INDEX TO PARAMETER ENTRIES\nS1       DC    AL1(4),AL3(SYSTEM)\nS2       DC    AL1(4),AL3(CPU)\nS3       DC    AL1(6),AL3(CPUSER)\nS4       DC    AL1(2),AL3(VERSION)\nS5       DC    AL1(0),AL3(USERID)\nS6       DC    AL1(0),AL3(GROUP)\nS7       DC    AL1(0),AL3(NJEN+1)\nS8       DC    AL1(8),AL3(CLOCK1)\nS9       DC    AL1(8),AL3(CLOCK2)\nS10      DC    AL1(7),AL3(CLOCK1)\nS11      DC    AL1(7),AL3(CLOCK1+7)\nS12      DC    AL1(0),AL3(VOL1)\nS13      DC    AL1(0),AL3(VOL2)\nS14      DC    AL1(0),AL3(VOL3)\nS15      DC    AL1(0),AL3(VOL4)\nS16      DC    AL1(0),AL3(VOL5)\nS17      DC    AL1(0),AL3(VOL6)\nS18      DC    AL1(8),AL3(JOBID)\nSYSTEM   DC    CL4' '\nUSERID   DC    CL8' '\nGROUP    DC    CL8' '\nCPU      DC    CL4' '\nCPUSER   DC    CL6' '\nVERSION  DC    CL2' '\nNJEN     DC    CL9' '\nCLOCK1   DC    CL8' '              FIRST HALF OF CPU CLOCK\nCLOCK2   DC    CL8' '              SECOND HALF OF CPU CLOCK\n         DS    XL1                 SPACE FROM UNPACKER\nVOL1     DC    CL6' '              VOLSER OF THE VOL1 DD STATEMENT\nVOL2     DC    CL6' '              VOLSER OF THE VOL2 DD STATEMENT\nVOL3     DC    CL6' '              VOLSER OF THE VOL3 DD STATEMENT\nVOL4     DC    CL6' '              VOLSER OF THE VOL4 DD STATEMENT\nVOL5     DC    CL6' '              VOLSER OF THE VOL5 DD STATEMENT\nVOL6     DC    CL6' '              VOLSER OF THE VOL6 DD STATEMENT\nJOBID    DC    CL8'   00000'       JES2 JOBID ('JOB01234', E.G.)\nTIOTADDR DC    F'0'                TIOT POINTER\nCVDWORK  DC    D'0'\nNULL     DC    H'0'\nPGM      DC    CL8' '              PROGRAM NAME\n*\nSAVEAREA DS    18F                 SAVE AREA\n*\n         IHAACEE\n         CVT   LIST=NO,DSECT=YES\n         IEFUCBOB\n         IKJTCB\n         IEZJSCB\n         IEFJSSIB\n         $SJB\n         $JCT\n         $TQE\n         $BUFFER\n         IFGRPL\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT277/FILE277.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT277", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}