{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012415000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 470288, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "CBT.V500.FILE585.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 470288, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 470288, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE585.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x08\\x08'", "DS1TRBAL": "b'7\\x1e'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04P\\x00\\x03\\x04P\\x00\\x0b\\x00\\t'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\'/\\x01\\x02\\'/\")\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xc8\\xc9\\xd7\\xc4\\xc1\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-09-29T00:00:00", "modifydate": "2002-09-29T22:29:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "SHIPDAT"}, "text": "REGULAR CBT TAPE - VERSION 452    FILE:  585\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT452.FILE585\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 3 MEMBERS COUNTED; CUMULATIVE SIZE IS 4,149 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   09/29/02    22:29:00    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE585": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x009\\x01\\x01\\x02_\\x01\\x02'/#\\x03\\x00*\\x00\\x02\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "2001-01-25T00:00:00", "modifydate": "2002-09-29T23:03:39", "lines": 42, "newlines": 2, "modlines": 0, "user": "SBGOLOB"}, "text": "//***FILE 585 is from Reed Petty, and contains a program called     *   FILE 585\n//*           AWSSL, which takes disk datasets as input, and        *   FILE 585\n//*           creates an SL virtual tape, in AWS format, as output. *   FILE 585\n//*           Standard Labels are created for the \"tape\" files, by  *   FILE 585\n//*           the AWSSL program.                                    *   FILE 585\n//*                                                                 *   FILE 585\n//*           This program creates AWS structures which contain     *   FILE 585\n//*           one or more OS datasets of any record format          *   FILE 585\n//*           (except spanned blocks), with or without standard     *   FILE 585\n//*           labels, where the output AWS structure can also be    *   FILE 585\n//*           of any record format (including spanned blocks).      *   FILE 585\n//*                                                                 *   FILE 585\n//*           This program will also retrieve datasets from an      *   FILE 585\n//*           AWS structure of any record format (except spanned    *   FILE 585\n//*           blocks).  The retrieved datasets may be reblocked     *   FILE 585\n//*           if necessary.  If DCB attributes are omitted on the   *   FILE 585\n//*           receiving dataset, and if standard labels are         *   FILE 585\n//*           present within the AWS structure, then the DCB        *   FILE 585\n//*           attributes of the receiving dataset will be           *   FILE 585\n//*           defaulted to those within the HDR1 label.             *   FILE 585\n//*                                                                 *   FILE 585\n//*           AWS (acronym is unknown to me, someone please tell    *   FILE 585\n//*           me!)  was widely used by the IBM P/390 product        *   FILE 585\n//*           family to implement an entire tape volume as a byte   *   FILE 585\n//*           stream contained within an OS/2 file.  As             *   FILE 585\n//*           implementations of the System/360/370/zArch           *   FILE 585\n//*           architecture families in software expanded (such as   *   FILE 585\n//*           Hercules, Flex/ES, and others) the AWS presence       *   FILE 585\n//*           expanded as well.                                     *   FILE 585\n//*                                                                 *   FILE 585\n//*           If you want to cut a real tape from the output of     *   FILE 585\n//*           AWSSL, either you can create the output in FB-80      *   FILE 585\n//*           format, and run the VTT2TAPE program from File 533.   *   FILE 585\n//*                                                                 *   FILE 585\n//*           If the output of AWSSL is VB, you can convert that    *   FILE 585\n//*           file to AWS-format FB-80 using the VTT2CNVU program   *   FILE 585\n//*           from File 533 of this tape.  That FB-80 AWS-format    *   FILE 585\n//*           file can then be input into the VTT2TAPE program      *   FILE 585\n//*           from File 533, and a real tape will be created.       *   FILE 585\n//*                                                                 *   FILE 585\n//*           email:  rhp@draper.net                                *   FILE 585\n//*                                                                 *   FILE 585\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AWSSL": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x19\\x01\\x02\\'/\\x01\\x02\\'/\"\\'\\x10\\x16\\x10\\x16\\x00\\x00\\xd9\\xc8\\xd7\\xc5\\xe3\\xe3\\xe8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-09-29T00:00:00", "modifydate": "2002-09-29T22:27:19", "lines": 4118, "newlines": 4118, "modlines": 0, "user": "RHPETTY"}, "text": "          TITLE 'AWSSL 1.9G AWS  Virtual Tape (standard labels)'\n***********************************************************************\n* AWSSL 1.9G, AWS Virtual Tape  (standard labels)                     *\n*                                                                     *\n* This program moves datasets to/from AWS virtual tape files.  HET    *\n* virtual tape formats will likely be support in the \"not to distant\" *\n* future.                                                             *\n*                                                                     *\n* Copyright (C) 2002, By Reed H. Petty, rhp@draper.net                *\n*                                                                     *\n* You are free to make any changes you like to this code for any      *\n* purpose (including commercial for profit use) PROVIDED that you     *\n* carry the credits forward into derived works.                       *\n*                                                                     *\n* NO WARRANTY OF ANY KIND IS MADE!  USE AT YOUR OWN RISK!             *\n*                                                                     *\n* JCL quick start example:                                            *\n*                                                                     *\n*  //MAKETAPE EXEC PGM=AWSSL                                          *\n*  //STEPLIB  DD DSN=my.load.library,DISP=SHR                         *\n*  //AWSPRINT DD SYSOUT=*                                             *\n*  //myddnam1 DD DSN=my.file1,DISP=SHR (optional)                     *\n*  //myddnam2 DD DSN=my.file2,DISP=SHR (optional)                     *\n*  //AWSFILE  DD DSN=mytape.aws,DISP=(,CATLG,DELETE),                 *\n*  //       SPACE=(whatever make sense to you in your environment),   *\n*  //       DCB=(whatever makes sense to you in your environment)     *\n*  //AWSCNTL  DD *                                                    *\n*  AWSVOL  VOLSER=mytape                                              *\n*  AWSPUT  INDSN=catalogued dataset name 1                            *\n*  AWSPUT  INDSN=catalogued dataset name 2,UNLOAD=IEBCOPY             *\n*  AWSPUT  INDD=myddnam1                                              *\n*  AWSPUT  INDD=myddnam1,UNLOAD=IEBCOPY                               *\n*  ... or ...                                                         *\n*  AWSVOL  VOLSER=mytape                                              *\n*  AWSGET  OUTDD=dd1,INDSN=dataset name on tape,FILENO=1              *\n*  AWSGET  OUTDD=dd2,INDSN=dataset name on tape,FILENO=5,SL=NO        *\n*  AWSGET  OUTDD=dd7,INDSN=dataset name on tape,FILENO=2,LOAD=IEBCOPY *\n*  ... and so forth                                                   *\n*  /*                                                                 *\n*                                                                     *\n* Feedback, good or bad, is always welcome!                           *\n*                                                                     *\n* Kudo's to Roger Bowler, somitcw@erols.com (whoever you are),        *\n* Sam Golob, and to Linus Torvalds (who encouraged my trivial         *\n* contributions to the Linux kernel).                                 *\n*                                                                     *\n* Special thanks to Michael A. Quinlan who was my boss at the         *\n* University of Utah so many years ago.  Mike is by far the best      *\n* assembler programmer that I have ever known.                        *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*                                                                     *\n* AWS Virtual Tape Motivation, The Good, the Bad, and the Ugly.       *\n* -------------------------------------------------------------       *\n*                                                                     *\n* This program creates AWS structures which contain one or more       *\n* OS datasets of any record format (except spanned blocks), with or   *\n* without standard labels, where the output AWS structure can also    *\n* be of any record format (including spanned blocks).                 *\n*                                                                     *\n* This program will also retrieve datasets from an AWS structure of   *\n* any record format (except spanned blocks). The retrieved datasets   *\n* may be reblocked if necessary.  If DCB attributes are omitted on    *\n* the receiving dataset, and if standard labels are present within    *\n* the AWS structure, then the DCB attributes of the receiving dataset *\n* will be defaulted to those within the HDR1 label.                   *\n*                                                                     *\n* AWS (acronym is unknown to me, someone please tell me!) was widely  *\n* used by the IBM P/390 product family to implement an entire tape    *\n* volume as a byte stream contained within an OS/2 file.  As          *\n* implementations of the System/360/370/zArch architecture families   *\n* in software expanded (such as Hercules, Flex/ES, and others) the    *\n* AWS presence expanded as well.                                      *\n*                                                                     *\n* Recommended reading: Sam Golob's AWS article published by NaSPA.    *\n* See URL: http://www.naspa.com/PDF/2001/1201%20PDF/T0112012.pdf      *\n*                                                                     *\n* Hercules provided the means for me to rekindle my MVT and MVS 3.8   *\n* memories.  I found myself constantly moving datasets between        *\n* these older operating systems and OS/390 running on real blue       *\n* hardware.  As neither MVT nor MVS 3.8J implement TCP/IP it became   *\n* necessary to move 1) entire disk volumes, 2) AWS tape volumes, or   *\n* 3) card decks.  Hercules does an excellent job of reading/writing   *\n* AWS tape volumes, but support in OS/390 was lacking (IMHO).         *\n*                                                                     *\n* Utilities available on OS/390 were a bit cumbersome.  If standard   *\n* label functionality was needed then the structure first had to be   *\n* copied to a real tape volume (AWSUTIL by Brandon Hill).  If a need  *\n* existed to pluck a single file from an AWS structure, without first *\n* copying the entire structure to a real volume, RAWSTAPE (written    *\n* by Jan Jaeger) was required.  Also, RAWSTAPE requires that DCB      *\n* attributes be manually set in a subsequent step.                    *\n*                                                                     *\n* As Jay Maynard (Hercules Maintainer) is fond of saying: If you have *\n* an itch, then scratch it!  This work represents my scratching.      *\n*                                                                     *\n* The itch: find a way to easily and quickly move sequential files    *\n* and PDS' (including PDSE's) between my OS/390 and MVS 3.8J systems. *\n* The goals: easy syntax, standard label exploitation to set default  *\n* DCB attributes in the receiving system, multiple file insertion     *\n* or extraction in a single step execution, automatic PDS staging     *\n* (this itch actually belongs to Roger Bowler but the idea is handy), *\n* compatibility with all known AWS utilities, and so forth.           *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*                                                                     *\n* Assembly                                                            *\n* --------                                                            *\n*                                                                     *\n* To assemble on a MVS 3.8J system:                                   *\n*                                                                     *\n*  //my job card                                                      *\n*  // EXEC ASMFCL,COND=(0,NE),MAC1='SYS1.AMODGEN',REGION=4096K,       *\n*  //   PARM.LKED='LIST,LET,MAP,XREF,RENT,REFR'                       *\n*  //SYSIN DD *                                                       *\n*    this code                                                        *\n*  //LKED.SYSLMOD DD DSN=my.load.library(AWSSL),DISP=SHR              *\n*  //SYSIN DD *                                                       *\n*   SETCODE AC(1)   (if UNLOAD=IEBCOPY is used)                       *\n*  //                                                                 *\n*                                                                     *\n* To assemble on an OS/390 R2.10 system:                              *\n*  //my job card                                                      *\n*  // EXEC HLASMCL,COND=(0,NE),                                       *\n*  //   PARM.L='LIST,LET,MAP,XREF,RENT,REFR'                          *\n*  //SYSIN DD *                                                       *\n*    this code                                                        *\n*  //L.SYSLMOD DD DSN=my.load.library(AWSSL),DISP=SHR                 *\n*  //SYSIN DD *                                                       *\n*   SETCODE AC(1)   (if UNLOAD=IEBCOPY is used)                       *\n*  //                                                                 *\n*                                                                     *\n* If the UNLOAD=IEBCOPY option is utilized this code must execute     *\n* authorized.  This code runs in 24 bit mode and is reentrant.        *\n* Assembly on older releases of MVS require that SYS1.AMODGEN be      *\n* available to the assembler.                                         *\n*                                                                     *\n*                                                                     *\n* Rant                                                                *\n* ----                                                                *\n*                                                                     *\n* Some critical comments have been received regarding my programming  *\n* style (too much uppercase, too much register saving, avoidance of   *\n* new and spiffy instructions, linkage conventions, short 8 byte      *\n* labels, uppercase labels, opcodes, operands, etc).                  *\n*                                                                     *\n* Normally I strive to generate reentrant 31 bit code sprinkled       *\n* liberally with capabilities found in the \"more recent MVS world\".   *\n* However, as this code is intended to assemble and run on any        *\n* incarnation of MVS from 3.8J forward, I have tried hard to avoid    *\n* dependency on facilities not present in older releases of MVS.      *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*                                                                     *\n* Random thoughts for the future                                      *\n* ------------------------------                                      *\n* 1) Add HET format support (does anyone know of a gzip               *\n*    implementation, preferably in System/370 assembler or others not *\n*    requiring run time library support, and not encumbered by        *\n*    overly restrictive licensing?                                    *\n*    *** Found, implementation in progress ***                        *\n*                                                                     *\n* 2) Add capability to internally call IEBCOPY, IDCAMS, etc to create *\n*    datasets in portable formats before adding to the AWS structure. *\n*    *** Done ***                                                     *\n*                                                                     *\n* 3) Add capability to retrieve a dataset from a standard label AWS   *\n*    structure and create an equivalent OS dataset.                   *\n*    *** Done ***                                                     *\n*                                                                     *\n* 4) Implement a decent multiple input record keyword parser.         *\n*    *** Done ***                                                     *\n*                                                                     *\n* 5) Implement capability to generate AWS structures in file formats  *\n*    of undefined lengths (PREFERRED!!!), variable lengths (for       *\n*    compatibility with output produced by AWSUTIL written by         *\n*    Brandon Hill), and fixed lengths (for compatibility with         *\n*    the VTT2* utilities written by Sam Golob).                       *\n*    *** Done ***                                                     *\n*                                                                     *\n* 6) Add capability to IDCAMS repro and export VSAM objects.          *\n*                                                                     *\n* 7) Rewrite to position for never ending expansion while keeping     *\n*    the code base maintainable.                                      *\n*    *** Done ***                                                     *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*                                                                     *\n* Change History                                                      *\n* --------------                                                      *\n* August  5, 2002   - Released to the public as v1.0                  *\n*                                                                     *\n* August 13, 2002   - V1.1 RELEASE                                    *\n*   - corrected a never ending wait on a never posted ECB in some     *\n*     environments (BSAM back to single buffering).                   *\n*   - added INDD= keyword support.                                    *\n*   - added DSN retrieval via RDJFCB support.                         *\n*   - added AWSVOL verb support.                                      *\n*   - revised DATASET verb format (removed VOLSER keyword).           *\n*   - Ported to MVS 3.8J (TIOT structure changes, SVC99 RB            *\n*     assembler F backward reference assembly problems, etc).         *\n*   - added support for input datasets having RECFM=U (thanks to      *\n*     Roger Bowler who identified the bug).                           *\n*   - brought label formats forward to that documented in the         *\n*     OS/390 R2.10 SMS manuals.                                       *\n*                                                                     *\n* August 16, 2002   - V1.2 Release (Internal Only)                    *\n*   - added automatic staging (unload) of PDS(E) datasets.            *\n*   - corrected RECFM=U ommission from HDR2/EOF2.                     *\n*   - corrected RDJFCB end of list indicator.                         *\n*   - converted input I/O from BSAM to QSAM for performance.          *\n*                                                                     *\n* September 9, 2002 - V1.9a Release Candidate (Internal Only)         *\n*   - Nearly 100% rewrite.                                            *\n*                                                                     *\n* September 18, 2002- 1.9c  Release Candidate (public)                *\n*   - Added retrieve from aws tape into OS dataset function.          *\n*   - Added AWSGET PDS(e) staging.                                    *\n*   - Renamed TAPEVOL, IMPORT, EXPORT to AWSVOL, AWSGET and AWSPUT.   *\n*                                                                     *\n* September 19, 2002- V1.9D Release Candidate (public)                *\n*   - Bug! subtle, grrr... AWSIGET... when block fragmentation occurs *\n*     between bytes 1 and 2 of AWSLENC then we cannot compute the     *\n*     length of the fragmented block and therefore cannot aggregate   *\n*     the remainder of the block.  The exposure is rare and is more   *\n*     likely to be visible when using short record lengths (as is the *\n*     case with AWS text produced by Sam Golob's VTT2DISK utility).   *\n*                                                                     *\n* September 23, 2002- V1.9E Release Candidate (public)                *\n*   - Incompatibility between AWSSL and VTT2TAPE.  VTT2TAPE expects:  *\n*     1) the last text record to be padded with x'20' characters, and *\n*     2) that an additional record be written completedly filled with *\n*        x'20' bytes.                                                 *\n*     Modified AWSSL accordingly when producing fixed length output.  *\n*                                                                     *\n* September 25, 2002- V1.9F                                           *\n*   - Added owner= keyword to AWSVOL function.                        *\n*                                                                     *\n* September 26, 2002- V1.9G                                           *\n*   - Rewrite of AWSIGET csect, new AWSGTXT csect.                    *\n*   - Force recfm=u when spanned records/blocks are encountered.      *\n*     Issue warnings when spanned and other than IEBCOPY load.        *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*                                                                     *\n* Input Parameters                                                    *\n* ----------------                                                    *\n* All input parameters are taken from control statements supplied by  *\n* the dataset represented by the AWSCNTL dd statement.  Statements    *\n* consist of a major function to be performed (i.e. TAPEVOL, EXPORT,  *\n* etc), and a series of keywords which supply values to that function.*\n*                                                                     *\n* Control statement keywords may be continued to as many records as   *\n* necessary.  Continued statements are indicated by the last keyword  *\n* argument suffixed with a comma and additional keywords supplied     *\n* on the next record.  Additional keywords must not begin in column   *\n* one.                                                                *\n*                                                                     *\n* Example:                                                            *\n*                                                                     *\n* AWSVOL VOLSER=MYTAPE                                                *\n* AWSPUT INDSN=SYS1.PROCLIB,OUTDSN=MY.SPECIAL.PROCLIB.D090802,        *\n*        UNLOAD=IEBCOPY                                               *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n* AWSVOL Control Statement                                            *\n* -------------------------                                           *\n* The AWSVOL control statement supplies characteristics of the        *\n* virtual tape volume include volume serial number, compression       *\n* techniques, and so forth.  TAPEVOL must also be the first control   *\n* statement specified.                                                *\n*                                                                     *\n* Keywords: VOLSER=(1 to 6 byte argument),                            *\n*           OWNER=(1 to 10 byte argument placed into VOL1 owner),     *\n*           COMPRESS=0:1, (compress and IDRC control whether or not   *\n*                   compression is to be used.  IDRC and COMPRESS     *\n*                   are durrently synomyms of each other).            *\n*           METHOD=1:2, (1 = gzip, 2=bzip2)                           *\n*           LEVEL=1-9, (specifies the degree of compression required) *\n*           IDRC=0:1,  (currently a synonym of COMPRESS)              *\n*           CHUNKSIZE=nnnnn (specifies the size of the \"chunk\" to be  *\n*                   compressed, should be avoided IMHO).              *\n*                                                                     *\n* If COMPRESS=0 then an AWS format is assumed.  Note that compression *\n* related keywords will be implemented at a future date.              *\n*                                                                     *\n* Note COMPRESS, METHOD, LEVEL, IDRC, CHUNKSIZE have the same meaning *\n* as in the Hercules configuration.                                   *\n*                                                                     *\n*                                                                     *\n* Example:                                                            *\n*                                                                     *\n* AWSVOL  VOLSER=MYTAPE,COMPRESS=1,METHOD=1,LEVEL=9,IDRC=1,           *\n*         CHUNKSIZE=65536,OWNER='AWSSL 1.9G'                          *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*                                                                     *\n* AWSGET Control Statement                                            *\n* ------------------------                                            *\n* The AWSGET control statement will supply values necessary to        *\n* retrieve a dataset FROM an AWS or HET virtual tape volume.          *\n*                                                                     *\n* keywords: INDSN=(up to 44 byte dsn of dataset stored inside of      *\n*                   the AWS virtual tape)                             *\n*           OUTDD=(ddname representing the dataset to receive data)   *\n*           FILENO=nnnnn (file number of the dataset inside of the    *\n*                   AWS virtual tape, may be a standard label file    *\n*                   number or absolute file number depending on the   *\n*                   value of the SL= keyword)                         *\n*           SL=YES:NO (specifies if standard labels are present, also *\n*                   impacts the meaning of the FILENO= keyword)       *\n*                                                                     *\n* Example:                                                            *\n*                                                                     *\n* AWSGET INDSN=sys1.proclib,OUTDD=dd1,SL=YES                          *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*                                                                     *\n* AWSPUT Control Statement                                            *\n* ------------------------                                            *\n* The AWSPUT control statement causes a dataset to be copied into the *\n* AWS or HET virtual tape file.  Multiple EXPORT statements may be    *\n* specified.  A set of standard labels are produced as each statement *\n* is processed.                                                       *\n*                                                                     *\n* If necessary the dataset is staged into a temporary dynamically     *\n* allocated dataset prior to insertion into the virtual temp.         *\n*                                                                     *\n* Keywords: INDD=(statically allocated ddname representing the file   *\n*                 to be copied and placed into the virtual tape file),*\n*           INDSN=(dsname to be dynamically allocated and placed into *\n*                 the virtual tape file),                             *\n*           OUTDSN=(44 byte dataset name to be placed into the labels *\n*                 which preceed and follow the file on virtual tape), *\n*           TAPEDSN=(17 byte dataset name to be placed in label),     *\n*           UNLOAD=IEBCOPY:IDCAMS, (the utility called to stage the   *\n*                 input dataset prior to insertion into the virtual   *\n*                 tape),                                              *\n*           TYPE=EXPORT:REPRO (if UNLOAD=IDCAMS then TYPE specifies   *\n*                 the method to be used to stage the dataset prior to *\n*                 to insertion into the virtual tape)                 *\n*                                                                     *\n* The AWS or HET virtual tape OUTPUT file may specify any DCB         *\n* attributes that are meaningful in the users environment.            *\n*                                                                     *\n* RECFM=V - Variable length output, lrecl and blksize as specified.   *\n*           Records are output in a format consistent with that       *\n*           produced by Brandon Hill's AWSUTIL (i.e. no aggregation   *\n*           of AWS structures within a single output record).         *\n*                                                                     *\n* RECFM=F - Fixed length output, lrecl and blksize as specified.      *\n*           Records are output in a format consistent with that       *\n*           produced by Sam Golob's VTT2* family of utilities         *\n*           (i.e. AWS structures are aggregated and \"folded\" at the   *\n*           specified lrecl).                                         *\n*                                                                     *\n* RECFM=U - Undefined length output, blksize as specified.  Records   *\n*           are output in an aggregated BLKSIZE length block.         *\n*           (THIS IS THE PREFERRED METHOD WHEN THE VIRTUAL TAPE IS TO *\n*           BE TRANSPORTED TO OTHER ENVIRONMENTS SUCH AS HERCULES).   *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*                                                                     *\n* Implementation Conventions                                          *\n* --------------------------                                          *\n* An effort was made to structure the code such that a nearly endless *\n* set of new features can be added without becoming unwieldly.  For   *\n* that reason functions tend to be implemented as small discrete      *\n* CSECTS.                                                             *\n*                                                                     *\n* Each CSECT name should begin with the string AWS to avoid name      *\n* space collision with other code which may be statically linked in   *\n* the future.  It is recommended that all labels within an individual *\n* CSECT follow a name space convention unique to that CSECT.          *\n*                                                                     *\n* Each CSECT should contain an LTORG statement.  This reduces the     *\n* need for multiple base registers to establish addressability to     *\n* large literal pools.                                                *\n*                                                                     *\n* To avoid subtle addressability related bugs, each CSECT should      *\n* contain a 'DROP ,' statement to release all USINGS in effect.       *\n*                                                                     *\n* A register save area stack mechanism is provided to ease linkage    *\n* between internal functions and to minimize contention for scarce    *\n* register resource.  All CSECTS should utilize the AWSENTRY and      *\n* AWSEXIT macro instructions where possible.                          *\n*                                                                     *\n* This code is reentrant and refreshable.  All data areas which       *\n* require modification should be placed in CSECT AWSDATA between      *\n* labels DSDYNAM and DSBUFFER.  If the data areas contain initialized *\n* data then they should be placed between labels DSBEGIN and DSBUFFER.*\n* Data areas located between labels DSDYNAM and DSBEGIN have storage  *\n* allocated for them but are not initialized (to other than nulls).   *\n*                                                                     *\n* Dynamic storage ADCON relocation, etc, code should be placed into   *\n* CSECT AWSINIT.                                                      *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*                                                                     *\n* Register Usage Conventions                                          *\n* --------------------------                                          *\n*                                                                     *\n* R14 - Linkage, contains the address at which instruction streaming  *\n*       should resume.  May be used as an internal work register.     *\n*                                                                     *\n* R15 - Linkage, contains the address of the CSECT to be called.      *\n*       Upon return contains the return code from the called CSECT.   *\n*       May be used as an internal work register.                     *\n*                                                                     *\n* R0 through R6 - Preserved by AWSENTRY and AWSEXIT.  Available for   *\n*       whatever usage the programmer desires within the scope of     *\n*       the local CSECTs.                                             *\n*                                                                     *\n* R7 through R9 - Reserved for future unforeseen needs.  Please avoid *\n*       usage except in the most dire of circumstances.               *\n*                                                                     *\n* R10 - Common storage addressability.  Set by AWSENTRY.              *\n*                                                                     *\n* R11 - Dynamic storage addressability.  Set by AWSENTRY.             *\n*                                                                     *\n* R12 - Local CSECT base register.  Set by AWSENTRY.                  *\n*                                                                     *\n* R13 - Pointer to current savearea.  Set to the next save area stack *\n*       entry by AWSENTRY.                                            *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n* Customizable Symbols                                                *\n***********************************************************************\n         SPACE 1\n         GBLA  &AWSDBUG            debug switch\n&AWSDBUG SETA  0                   1 = enable debugging support\n         SPACE 1\nSTACKCT  EQU   10                  savearea stack entries\nBUFSIZE  EQU   70000               max blksize + hdrs + aws cb + pad\n         SPACE 1\n***********************************************************************\n* Register Equates (make registers visible in xref)                   *\n***********************************************************************\n         SPACE 1\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         TITLE 'AWSSL - macro definitions'\n***********************************************************************\n* MACRO DEFINITIONS                                                   *\n***********************************************************************\n         EJECT\n         MACRO\n&LBL     AWSENTRY\n.**********************************************************************\n.* AWSENTRY - push caller's registers into provided savearea, obtain  *\n.*            a new savearea from the savearea stack, addressability. *\n.**********************************************************************\n         GBLA  &AWSDBUG            debug switch\n         LCLA  &L,&I\n         AIF   ('&LBL' EQ '').A010\n&LBL     DS    0H\n.A010    ANOP\n&L       SETA  (K'&SYSECT+2+4)/2*2 offset to stm\n&I       SETA  K'&SYSECT\n         B     &L.(,R15)           branch around eyecatcher\n         DC    AL1(&I)             eyecatcher length\n         DC    C'&SYSECT'          CSECT name\n         STM   R14,R12,12(R13)     save caller's environment\n         LR    R12,R15             base register\n         LA    R15,72(,R13)        next stack entry\n         ST    R15,8(,R13)         forward linkage\n         ST    R13,4(,R15)         backward linkage\n         LR    R13,R15             establish new current savearea\n         USING &SYSECT,R12         addressability\n         USING AWSDYNAM,R11        addressability\n         USING AWSCOMST,R10        addressability\n         AIF   (&AWSDBUG EQ 0).MEND\n         AIF   ('&SYSECT' EQ 'AWSPRNT').MEND\n         AIF   ('&SYSECT' EQ 'AWSINIT').MEND\n         AWSMSG 000I,'&SYSECT Entry'\n.MEND    MEND\n         EJECT\n         MACRO\n&LBL     AWSEXIT\n.**********************************************************************\n.* AWSEXIT  - release savearea stack entry, pop user's environment,   *\n.*            return to caller.                                       *\n.**********************************************************************\n         GBLA  &AWSDBUG            debug switch\n         AIF   ('&LBL' EQ '').A010\n&LBL     DS    0H\n.A010    AIF   (&AWSDBUG EQ 0).A020\n         AIF   ('&SYSECT' EQ 'AWSPRNT').A020\n         AIF   ('&SYSECT' EQ 'AWSTERM').A020\n         MVC   DSMSG+1(7),=CL7'AWS000I'\n         MVC   DSMSG+19(14),=CL14'&SYSECT EXIT'\n         MVC   DSMSG+35(3),=CL3'RC:'\n         CVD   R15,DSDWORK         convert to decimal\n         MVC   DSMSG+38(6),=X'402020202120'\n         ED    DSMSG+38(6),DSDWORK+5 make printable\n         OI    DSMSG+43,C'0'\n         LR    R2,R15              save return code\n         AWSMSG ,                  print exit message\n         LR    R15,R2              restore retern code\n.A020    ANOP\n         L     R13,4(,R13)         restore savearea pointer\n         LM    R0,R12,20(R13)      restore caller's registers\n         L     R14,12(,R13)        restore savearea address\n         LTR   R15,R15             set condition code into psw\n         BR    R14                 return to caller\n         SPACE 1\n         MEND\n         EJECT\n         MACRO\n&LBL     AWSMSG &ID,&TXT\n.**********************************************************************\n.* AWSMSG - output a message to the AWSPRINT log                      *\n.**********************************************************************\n         GBLA  &AWSDBUG            debug switch\n         LCLA  &L1,&L2\n         LCLC  &C\n         AIF   ('&ID' EQ '' AND '&TXT' EQ '').A040\n         AIF   ('&ID' NE '').A010\n         MNOTE 8,'*** MSG CSECT ID OMITTED'\n.A010    AIF   ('&TXT' NE '').A020\n         MNOTE 8,'*** MSG TEXT OMITTED'\n.A020    AIF   ('&LBL' EQ '').A030\n&LBL     DS    0H\n.A030    ANOP\n&C       SETC  'AWS&ID'\n&L1      SETA  K'&C\n         MVC   DSMSG+1(&L1),=C'&C'\n&L2      SETA  K'&TXT-2\n         MVC   DSMSG+19(&L2),=C&TXT\n.A040    ANOP\n         AWSCALL AWSPRNT           print function\n         MEND\n         EJECT\n         MACRO\n&LBL     AWSDMP &ID,&L,&R,&T\n.**********************************************************************\n.* AWSDMP - hex dump register (and optionally 16 bytes of storage)    *\n.*          i.e. AWSDMP 00I,IGET900,R3   (dumps r3 and 16 bytes strg) *\n.*          i.e. AWSDMP 00I,IGET100,R4,N (dumps r4 only)              *\n.*                                                                    *\n.* This macro is intended for debugging purposes only.                *\n.**********************************************************************\n         GBLA  &AWSDBUG            debug switch\n         LCLA  &L1,&L2\n         LCLC  &C\n         STM   R14,R12,12(R13)\n         LA    R13,72(,R13)\n         AIF   ('&ID' NE '').A010\n         MNOTE 8,'*** MSG CSECT ID OMITTED'\n.A010    AIF   ('&R' NE '').A020\n         MNOTE 8,'*** REGISTER OMITTED'\n.A020    AIF   ('&LBL' EQ '').A030\n&LBL     DS    0H\n.A030    ANOP\n&C       SETC  'AWS&ID'\n&L1      SETA  K'&C\n         MVC   DSMSG+1(&L1),=C'&C'\n         AIF   ('&L' EQ '').A035\n&L1      SETA  K'&L+1\n         MVC   DSMSG+10(&L1),=C'&L:'\n.A035    ANOP\n&L1      SETA  K'&R\n         MVC   DSMSG+19(&L1),=C'&R'\n&L1      SETA  23\n         ST    &R,DSFWORK                  register\n         UNPK  DSHEXWK(9),DSFWORK(5)       unpack data\n         TR    DSHEXWK(8),CSHEXTR          make printable\n         MVC   DSMSG+&L1.(8),DSHEXWK       return code\n         AIF   ('&T' EQ 'N').A040\n&L1      SETA  &L1+12\n         UNPK  DSHEXWK(9),0(5,&R)\n         TR    DSHEXWK(8),CSHEXTR\n         MVC   DSMSG+&L1.(8),DSHEXWK\n&L1      SETA  &L1+9\n         UNPK  DSHEXWK(9),4(5,&R)\n         TR    DSHEXWK(8),CSHEXTR\n         MVC   DSMSG+&L1.(8),DSHEXWK\n&L1      SETA  &L1+9\n         UNPK  DSHEXWK(9),8(5,&R)\n         TR    DSHEXWK(8),CSHEXTR\n         MVC   DSMSG+&L1.(8),DSHEXWK\n&L1      SETA  &L1+9\n         UNPK  DSHEXWK(9),12(5,&R)\n         TR    DSHEXWK(8),CSHEXTR\n         MVC   DSMSG+&L1.(8),DSHEXWK\n         MVI   DSMSG+72,C'*'\n         MVC   DSMSG+73(16),0(&R)\n         MVI   DSMSG+89,C'*'\n.A040    ANOP\n         AWSCALL AWSPRNT           print function\n         SH    R13,=H'72'\n         LM    R14,12,12(R13)\n         MEND\n         EJECT\n         MACRO\n&LBL     AWSCALL &FUN\n.**********************************************************************\n.* AWSCALL - Call a function                                          *\n.**********************************************************************\n         AIF   ('&LBL' EQ '').A010\n&LBL     DS    0H\n.A010    ANOP\n         AIF   ('&FUN' NE 'AWSDYNE').A020\n         L     R15,CSAWSDYE        dynamic allocatione error handler\n         AGO   .A999\n.A020    AIF   ('&FUN' NE 'AWSEPUT').A030\n         L     R15,CSAWSEPT        put text to virtual tape\n         AGO   .A999\n.A030    AIF   ('&FUN' NE 'AWSMARK').A040\n         L     R15,CSAWSMRK        put tapemark to virtual tape\n         AGO   .A999\n.A040    AIF   ('&FUN' NE 'AWSPRNT').A050\n         L     R15,CSAWSPRT        write to log\n         AGO   .A999\n.A050    AIF   ('&FUN' NE 'AWSIGET').A900\n         L     R15,CSAWSIGE        read a logical aws block\n         AGO   .A999\n.A900    ANOP\n         L     R15,=A(&FUN)        function to be called\n.A999    ANOP\n         BALR  R14,R15             issue call\n         MEND\n         EJECT\n         MACRO\n&LBL     AWSSWAP\n.**********************************************************************\n.* AWSSWAP - swap byte orders, set sizes                              *\n.**********************************************************************\n         AIF   ('&LBL' EQ '').A010\n&LBL     DS    0H\n.A010    ANOP\n         ICM   R0,3,DSLSTSIZ       reverse previous size byte order\n         STCM  R0,1,AWSLENP\n         STCM  R0,2,AWSLENP+1\n         ICM   R0,3,AWSLENC        size of current block\n         STCM  R0,3,DSLSTSIZ       set new last size\n         STCM  R0,1,AWSLENC        reverse current size byte order\n         STCM  R0,2,AWSLENC+1\n         MEND\n         SPACE 1\n         MACRO\n&LBL     AWSSWAPR\n.**********************************************************************\n.* AWSSWAPR - swap byte orders, no sizes                              *\n.**********************************************************************\n         AIF   ('&LBL' EQ '').A010\n&LBL     DS    0H\n.A010    ANOP\n         ICM   R0,3,AWSLENC        size of current block\n         STCM  R0,1,AWSLENC        reverse current  size byte order\n         STCM  R0,2,AWSLENC+1\n         MEND\n         SPACE 1\n         MACRO\n&LBL     AWSDUMMY ,                Dummy function\n.**********************************************************************\n.* AWSDUMMY - dummy function, merely returns                          *\n.**********************************************************************\n&LBL     CSECT ,                   dummy function\n         AWSENTRY ,\n         SLR   R15,R15             zero return code\n         AWSEXIT ,\n         DROP  ,\n         MEND\n         EJECT\n***********************************************************************\n* System control block definitions (Assembler F forward referenced)   *\n***********************************************************************\n         SPACE 1\n         PRINT OFF\n         DCBD  DSORG=PS\n         IEFZB4D0 ,\n         IEFZB4D2 ,\n         IHAPSA ,                  PSA\n         IKJTCB ,                  TCB\nTIOT     DSECT  ,                  TIOT\n         IEFTIOT1 ,\n         PRINT ON\n         EJECT\n***********************************************************************\n* AWSSL - Utility entry point                                         *\n***********************************************************************\n         SPACE 1\nAWSSL    CSECT ,                   module entry point\n         SAVE  (14,12),,'AWSSL &SYSDATE &SYSTIME'\n         LR    R12,R15             base register\n         USING AWSSL,R12           addressability\n         SPACE 1\n         GETMAIN R,LV=AWSDATAL+3*BUFSIZE Dynamic storage\n         ST    R13,4(,R1)          backward linkage\n         ST    R1,8(,R13)          forward linkage\n         LR    R13,R1              current savearea\n         LR    R11,R1              set dynamic storage location\n         USING AWSDATA,R11         addressability\n         ST    R11,DSDATAP         set pointer to awsdata origin\n         LA    R0,DSSTACK          stack origin\n         ST    R0,DSSTACKP         set stack origin pointer\n         LA    R11,AWSDYNAM-AWSDATA(,R11) position beyond stack\n         USING AWSDYNAM,R11        addressability\n         SPACE 1\n         L     R10,=A(AWSCOMST)    constant common data\n         USING AWSCOMST,R10        addressability\n         SPACE 1\n         AWSCALL AWSINIT           initialization\n         BNZ   SSLXIT              if not successful, branch\n         SPACE 1\nSSL010   DS    0H                  main processing loop\n         AWSCALL AWSMAIN           invoke verb handler\n         BZ    SSL010              continue until eof or error\n         SPACE 1\nSSLXIT   DS      0H                return to caller\n         CH    R15,=H'-4'          eof from main?\n         BNE   *+6                 no, branch\n         SLR   R15,R15             else force zero return code\n         LR    R2,R15              save rc for now\n         AWSCALL AWSTERM           clean up for termination\n         SPACE 1\n         L     R3,4(,R13)          Callers savearea\n         L     R4,DSDATAP          dynamic storage origin\n         FREEMAIN R,LV=AWSDATAL+3*BUFSIZE,A=(R4) release storage\n         SPACE 1\n         LR    R15,R2              restore return code\n         LR    R13,R3              restore savearea pointer\n         RETURN (14,12),RC=(15)    return to caller\n         SPACE 1\n         LTORG ,\n         DROP\n         TITLE 'AWSSL - Initialization'\n***********************************************************************\n* AWSINIT - initialization, relocation, open files                    *\n*           msgs AWS01n                                               *\n***********************************************************************\n         SPACE 1\nAWSINIT  CSECT ,                   initialization logic\n         AWSENTRY ,                csect entry\n         SPACE 1\n         L     R2,=A(AWSRELOC)     start  of relocatable storage\n         L     R3,=A(DSENDL)       length of relocateable storage\n         LR    R1,R3               origin length = destination\n         LA    R0,AWSRELOC-AWSDYNAM(,R11) target of move\n         MVCL  R0,R2               copy storage model into dynamic area\n         SPACE 1\n         LA    R0,INFMJFCB         jfcb work area\n         STCM  R0,7,DSJFCBL+1\n         LA    R0,DSJFCBL          rdjfcb exist list location\n         STCM  R0,7,AWSUT1+(DCBEXLSA-IHADCB)\n         STCM  R0,7,AWSUT2+(DCBEXLSA-IHADCB)\n         STCM  R0,7,AWSUT3+(DCBEXLSA-IHADCB)\n         SPACE 1\n         LA    R0,DSBUFFER         Buffer location\n         ST    R0,DSBUFTP          Set location of next text\n         SPACE 1\n         LA    R0,DSARB            input dataset request block\n         STCM  R0,7,DSARBP+1\n         LA    R0,DSADDNM          input ddname\n         ST    R0,DSATXTP\n         LA    R0,DSADSNM          input dsn\n         ST    R0,DSATXTP+4\n         LA    R0,DSASTATS         input stats\n         ST    R0,DSATXTP+8\n         LA    R0,DSADISP          input disposition\n         STCM  R0,7,DSATXTP+13\n         LA    R1,DSARB            input rb location\n         USING S99RB,R1            addressability\n         LA    R0,DSATXTP          input text pointer\n         ST    R0,S99TXTPP\n         MVI   S99RBLN,S99RBEND-S99RB length of rb\n         MVI   S99VERB,S99VRBAL    allocation request\n         MVI   S99FLAG1,S99NOCNV+S99NOMNT do not issue mounts\n         DROP  R1\n         SPACE 1\n         LA    R0,DSTARB           temp work dataset request block\n         STCM  R0,7,DSTARBP+1\n         LA    R0,DSTADDNM         temp work ddname\n         ST    R0,DSTATXTP\n         LA    R0,DSTAUNIT         temp work unit\n         ST    R0,DSTATXTP+4\n         LA    R0,DSTASPCU         temp work space primary   units\n         ST    R0,DSTATXTP+8\n         LA    R0,DSTASPCP         temp work space primary   qty\n         ST    R0,DSTATXTP+12\n         LA    R0,DSTASPCS         temp work space secondary qty\n         STCM  R0,7,DSTATXTP+17\n         LA    R1,DSTARB           temp work rb location\n         USING S99RB,R1            addressability\n         LA    R0,DSTATXTP         input text pointer\n         ST    R0,S99TXTPP\n         MVI   S99RBLN,S99RBEND-S99RB length of rb\n         MVI   S99VERB,S99VRBAL    allocation request\n         MVI   S99FLAG1,S99NOCNV+S99NOMNT do not issue mounts\n         DROP  R1\n         SPACE 1\n         LA    R0,DSSARB           sysin dataset request block\n         STCM  R0,7,DSSARBP+1\n         LA    R0,DSSADDNM         sysin ddname\n         ST    R0,DSSATXTP\n         LA    R0,DSSAUNIT         sysin unit\n         ST    R0,DSSATXTP+4\n         LA    R0,DSSASPCU         sysin space primary   units\n         ST    R0,DSSATXTP+8\n         LA    R0,DSSASPCP         sysin space primary   qty\n         ST    R0,DSSATXTP+12\n         LA    R0,DSSASPCS         sysin space secondary qty\n         STCM  R0,7,DSSATXTP+17\n         LA    R1,DSSARB           sysin rb location\n         USING S99RB,R1            addressability\n         LA    R0,DSSATXTP         input text pointer\n         ST    R0,S99TXTPP\n         MVI   S99RBLN,S99RBEND-S99RB length of rb\n         MVI   S99VERB,S99VRBAL    allocation request\n         MVI   S99FLAG1,S99NOCNV+S99NOMNT do not issue mounts\n         DROP  R1\n         SPACE 1\n         LA    R0,DSPARB           sysprint dataset request block\n         STCM  R0,7,DSPARBP+1\n         LA    R0,DSPADDNM         sysprint ddname\n         ST    R0,DSPATXTP\n         LA    R0,DSPADUMY         dummy dataset\n         STCM  R0,7,DSPATXTP+5\n         LA    R1,DSPARB           sysin rb location\n         USING S99RB,R1            addressability\n         LA    R0,DSPATXTP         input text pointer\n         ST    R0,S99TXTPP\n         MVI   S99RBLN,S99RBEND-S99RB length of rb\n         MVI   S99VERB,S99VRBAL    allocation request\n         MVI   S99FLAG1,S99NOCNV+S99NOMNT do not issue mounts\n         SPACE 1\n         LA    R0,DSURB            unallocation request block\n         STCM  R0,7,DSURBP+1\n         LA    R0,DSUDDNM          ddname\n         STCM  R0,7,DSUTXTP+1\n         LA    R1,DSURB            unallocation rb location\n         USING S99RB,R1            addressability\n         LA    R0,DSUTXTP          input text pointer\n         ST    R0,S99TXTPP\n         MVI   S99RBLN,S99RBEND-S99RB length of rb\n         MVI   S99VERB,S99VRBUN    unallocation request\n         MVI   S99FLAG1,S99NOCNV+S99NOMNT do not issue mounts\n         DROP  R1\n         SPACE 1\nINIT010  DS    0H                  prepare AWSPRINT\n         OPEN  (AWSPRINT,(OUTPUT)),MF=(E,DSOPENL)  open awsprint\n         TM    AWSPRINT+(DCBOFLGS-IHADCB),DCBOFOPN open successful?\n         BO    INIT020             yes, branch\n         WTO   'AWS010E AWSPRINT OPEN FAILED'\n         LA    R15,12              sysprint open failed\n         B     INITXIT             exit with error\n         SPACE 1\nINIT020  DS    0H                  prepare AWSOUT\n         AIF   (&AWSDBUG EQ 0).INIT010\n         AWSMSG 011I,'AWSINIT Entry'\n.INIT010 ANOP\n         OPEN  (AWSCNTL,(INPUT)),MF=(E,DSOPENL)  open awscntl\n         TM    AWSCNTL+(DCBOFLGS-IHADCB),DCBOFOPN open successful?\n         BO    INIT030             yes, branch\n         AWSMSG 012E,'AWSCNTL open failed'\n         LA    R15,12              16=awscntl open failed\n         B     INITXIT             exit with error\n         SPACE 1\nINIT030  DS    0H\n         AWSCALL AWSJOBNM          Capture job and step name info\n         SPACE 1\nINIT040  DS    0H\n         SPACE 1\nINITXIT  DS    0H                  function exit\n         AWSEXIT ,                 return to caller\n         SPACE 1\n         LTORG ,\n         DROP ,\n         TITLE 'AWSMAIN - Process next control statement'\n***********************************************************************\n* AWSMAIN - Verb dispatcher                                           *\n*           msgs AWS02n                                               *\n***********************************************************************\n         SPACE 1\nAWSMAIN  CSECT ,                   Process next control statement\n         AWSENTRY ,\n         SPACE 1\n         LA    R0,MAINEOF          AWSCNTL eof\n         STCM  R0,7,AWSCNTL+(DCBEODA-IHADCB) place into dcb\n         SPACE 1\nMAIN010  DS    0H                  scan for dataset verb\n         GET   AWSCNTL             retrieve a cntl record\n         LR    R3,R1               record location\n         MVC   DSMSG+1(17),=C'AWS020I  AWSCNTL:'\n         MVC   DSMSG+19(80),0(R3)  set statement into message buffer\n         AWSMSG ,                  print function\n         CLI   0(R1),C'*'          comment?\n         BE    MAIN010             yes, branch\n         CLC   0(80,R3),CSBLNKS    blank line?\n         BE    MAIN010             yes, branch\n         CLC   =C'AWSVOL ',0(R3)   tapevol verb?\n         BE    MAIN020             yes, branch\n         CLC   =C'AWSGET ',0(R3)   import verb?\n         BE    MAIN030             yes, branch\n         CLC   =C'AWSPUT ',0(R3)   export verb?\n         BE    MAIN040             yes, branch\n         AWSMSG 021E,'Statement is not recognized'\n         LA    R15,8               rc=4, invalid statement\n         B     MAINXIT             return to caller\n         SPACE 1\nMAIN020  DS    0H                  tapevol verb\n         AWSCALL AWSTVOL           invoke tapevol\n         B     MAINXIT\n         SPACE 1\nMAIN030  DS    0H                  import verb\n         TM    DSFLAGS2,DSFEXPRT   export invoked previously?\n         BO    MAIN050             yes, branch\n         OI    DSFLAGS2,DSFIMPRT   indicate import invoked\n         AWSCALL AWSIMPRT          invoke import\n         B     MAINXIT\n         SPACE 1\nMAIN040  DS    0H                  export verb\n         TM    DSFLAGS2,DSFIMPRT   import invoked previously?\n         BO    MAIN060             yes, branch\n         OI    DSFLAGS2,DSFEXPRT   indicate import invoked\n         AWSCALL AWSEXPRT          invoke export\n         B     MAINXIT\n         SPACE 1\nMAIN050  DS    0H                  import invoked after export\n         AWSMSG 022E,'AWSGET is mutually exclusive with AWSPUT'\n         LA    R15,8\n         B     MAINXIT\n         SPACE 1\nMAIN060  DS    0H                  export invoked after import\n         AWSMSG 023E,'AWSPUT is mutually exclusive with AWSGET'\n         LA    R15,8\n         B     MAINXIT\n         SPACE 1\nMAINEOF  DS    0H                  AWSCNTL reached eof\n         MVC   DSMSG+10(8),=C'AWSCNTL:'\n         AWSMSG 024I,'End of AWSCNTL input detected'\n         L     R15,=F'-4'          indicate eof\n         SPACE 1\nMAINXIT  DS    0H                  function exit\n         AWSEXIT ,                 return to caller\n         SPACE 1\n         LTORG ,\n         DROP ,\n         TITLE 'AWSTERM - Termination processing'\n***********************************************************************\n* AWSTERM - Termination, close files and release resources            *\n*           msg AWS03n                                                *\n***********************************************************************\n         SPACE 1\nAWSTERM  CSECT ,                   Termination processing\n         AWSENTRY ,\n         SPACE 1\n         TM    DSFLAGS,DSFOPNEX    AWSFILE open for export?\n         BZ    TERM010             no, branch\n         OI    DSFLAGS,DSFFLUSH    flush last buffer (just in case)\n         AWSCALL AWSMARK           write final tape mark\n         SPACE 1\nTERM010  DS    0H                  check stack integrity\n         L     R1,DSSTACKP         stack origin\n         LA    R0,STACKCT          max entries in stack\n         SLR   R2,R2               clear counter\nTERM020  DS    0H                  calculate max stack depth\n         CLC   CSF0,4(R1)          entry ever been used?\n         BE    TERM030             no, branch\n         LA    R2,1(,R2)           increment count\n         LA    R1,18*4(,R1)        position at next stack entry\n         BCT   R0,TERM020          continue until exhausted\n         AWSMSG 030W,'WARNING! Stack overflow detected, contact rhp@dra*\n               per.net'\n         B     TERM040\n         SPACE 1\nTERM030  DS    0H                  write max stack depth used\n         AIF   (&AWSDBUG EQ 0).TERM030\n         CVD   R2,DSDWORK          convert to packed\n         MVC   DSXL16(4),=X'40202120' edit mask\n         ED    DSXL16(4),DSDWORK+6\n         OI    DSXL16+3,C'0'       make printable\n         MVC   DSMSG+1(7),=C'AWS031I'\n         MVC   DSMSG+19(20),=C'Maximum stack depth:'\n         MVC   DSMSG+39(2),DSXL16+2 set count into message\n         AWSMSG ,                  write the message\n.TERM030 ANOP\n         SPACE 1\nTERM040  DS    0H                  unallocate as needed\n         AWSCALL AWSUNALC          dynamic unallocation\n         LR    R3,R15              save return code\n         SPACE 1\n         TM    AWSCNTL+(DCBOFLGS-IHADCB),DCBOFOPN   open?\n         BZ    TERM050                              no, branch\n         CLOSE AWSCNTL,MF=(E,DSCLOSEL)              close it\n         FREEPOOL AWSCNTL                           release buffers\n         SPACE 1\nTERM050  DS    0H                  cleanup AWSFILE\n         TM    AWSFILE+(DCBOFLGS-IHADCB),DCBOFOPN    open?\n         BZ    TERM060                              no, branch\n         CLOSE AWSFILE,MF=(E,DSCLOSEL)              close it\n         FREEPOOL AWSFILE                           release buffers\n         SPACE 1\nTERM060  DS    0H                  cleanup AWSPRINT\n         TM    AWSPRINT+(DCBOFLGS-IHADCB),DCBOFOPN  open?\n         BZ    TERM070                              no, branch\n         CLOSE AWSPRINT,MF=(E,DSCLOSEL)             close it\n         FREEPOOL AWSPRINT                          release buffers\n         SPACE 1\nTERM070  DS    0H                  cleanup SYSIN\n         TM    SYSIN+(DCBOFLGS-IHADCB),DCBOFOPN     open?\n         BZ    TERM080                              no, branch\n         CLOSE SYSIN,MF=(E,DSCLOSEL)                close it\n         FREEPOOL SYSIN                             release buffers\n         SPACE 1\nTERM080  DS    0H                  cleanup AWSUT2\n         TM    AWSUT2+(DCBOFLGS-IHADCB),DCBOFOPN    open?\n         BZ    TERM090                              no, branch\n         CLOSE AWSUT2,MF=(E,DSCLOSEL)               close it\n         FREEPOOL AWSUT2                            release buffers\n         SPACE 1\nTERM090  DS    0H                  cleanup AWSUT2\n         TM    AWSUT3+(DCBOFLGS-IHADCB),DCBOFOPN    open?\n         BZ    TERM100                              no, branch\n         CLOSE AWSUT3,MF=(E,DSCLOSEL)               close it\n         FREEPOOL AWSUT3                            release buffers\n         SPACE 1\nTERM100  DS    0H\n         LR    R15,R3              return code from unalloc\n         SPACE 1\nTERMXIT  DS    0H                  exit\n         AWSEXIT ,                 return to caller\n         SPACE 1\n         LTORG ,\n         DROP ,\n         TITLE 'AWSTVOL - AWSVOL verb handler'\n***********************************************************************\n* AWSTVOL - AWSVOL verb handler                                       *\n*           msg AWS04n                                                *\n***********************************************************************\n         SPACE 1\nAWSTVOL  CSECT ,                   TAPEVOL verb handler\n         AWSENTRY ,\n         SPACE 1\n         AWSCALL AWSTVPAR          invoke keyword parser\n         SPACE 1\n         AWSMSG ,                  print blank line\n         AWSMSG ,                  print blank line\n         SPACE 1\n         AWSEXIT ,                 return to caller\n         SPACE 1\n         LTORG ,\n         DROP ,\n         TITLE 'AWSIMPRT - Import verb handler'\n***********************************************************************\n* AWSIMPRT - AWSGET verb handler                                      *\n*            msg AWS05n                                               *\n***********************************************************************\n         SPACE 1\nAWSIMPRT CSECT ,                   Import verb handler\n         AWSENTRY ,\n         SPACE 1\n         LR    R3,R1               future reference\n         TM    AWSUT2+(DCBOFLGS-IHADCB),DCBOFOPN  AWSUT2 open?\n         BZ    IMPRT010            no, branch\n         CLOSE AWSUT2,MF=(E,DSCLOSEL) close awsfile\n         FREEPOOL AWSUT2           release buffers\n         SPACE 1\nIMPRT010 DS    0H                  prepare to open\n         NI    DSFLAGS,255-DSFOPNEX clear open for export (in case)\n         SPACE 1\n         XC    DSBUFEND,DSBUFEND   indicate no blocks read\n         XC    DSBUFTP,DSBUFTP\n         LA    R2,AWSUT2           dcb location\n         USING IHADCB,R2           addressability\n         MVC   DCBDDNAM,=CL8'AWSFILE' set ddname\n         XC    DCBBLKSI,DCBBLKSI   clear blocksize\n         XC    DCBLRECL,DCBLRECL   clear lrecl\n         OPEN  (AWSUT2,(INPUT)),MF=(E,DSOPENL)  open awsfile\n         TM    DCBOFLGS,DCBOFOPN   open successful?\n         BO    IMPRT020            yes, branch\n         AWSMSG 050E,'AWSFILE open for AWSGET failed'\n         LA    R15,8               awsout open failed\n         B     IMPRTXIT            exit with error\n         SPACE 1\nIMPRT020 DS    0H                  import\n         TM    AWSFILE+(DCBOFLGS-IHADCB),DCBOFOPN file open?\n         BZ    IMPRT030            no, branch\n         CLOSE AWSFILE,MF=(E,DSCLOSEL) else close it\n         FREEPOOL AWSFILE\n         SPACE 1\nIMPRT030 DS    0H                  prepare to import\n         SLR   R0,R0               clear register\n         ICM   R0,3,DCBLRECL       get lrecl\n         BZ    IMPRT040            if zero, branch\n         CH    R0,=H'16'           at least 16 bytes?\n         BNL   IMPRT050            yes, branch\n         AWSMSG 051E,'Input lrecl must be at least 16 bytes'\n         LA    R15,8\n         B     IMPRTXIT\n         SPACE 1\nIMPRT040 DS    0H                  check blksize\n         ICM   R0,3,DCBBLKSI       load blksize\n         CH    R0,=H'16'           at least 16 bytes?\n         BNL   IMPRT050            yes, branch\n         AWSMSG 052E,'Input blksize must be at least 16 bytes'\n         LA    R15,8\n         B     IMPRTXIT\n         DROP  R2\n         SPACE 1\nIMPRT050 DS    0H\n         SLR   R0,R0               clear register\n         ST    R0,DSGTXTP          clear pointer\n         STH   R0,DSGTXTL          clear length\n         RDJFCB AWSUT2,MF=(E,DSRDJFCB) read the jfcb\n         SPACE 1\n         AWSMSG ,                  blank line\n         MVC   DSMSG+1(7),=C'AWS053I'\n         MVC   DSMSG+19(31),=C'Virtual tape dataset name     :'\n         MVC   DSMSG+51(44),JFCBDSNM\n         AWSMSG ,\n         SPACE 1\n         MVC   DSRECFM,CSBLNKS     clear default recfm\n         SLR   R0,R0               clear register\n         STH   R0,DSLRECL          clear lrecl\n         STH   R0,DSBLKSIZ         clear blksize\n         SPACE 1\n         LR    R1,R3               current control statement\n         AWSCALL AWSIMPAR          parse import keywords\n         BNZ   IMPRTXIT\n         AWSCALL AWSSKPTF          position to file\n         BNZ   IMPRTXIT\n         AWSCALL AWSIMLBL          process header labels\n         BNZ   IMPRTXIT\n         AWSCALL AWSICOPY          copy data into MVS dataset\n         BNZ   IMPRTXIT\n         AWSCALL AWSIMTLR          process trailer labels\n         SPACE 1\nIMPRTXIT DS    0H                  EXIT\n         AWSEXIT ,                 return to caller\n         SPACE 1\n         LTORG ,\n         DROP  ,\n         TITLE 'AWSEXPRT - Export verb handler'\n***********************************************************************\n* AWSEXPRT - AWSPUT verb handler                                      *\n*            msg AWS06n                                               *\n***********************************************************************\n         SPACE 1\nAWSEXPRT CSECT ,                   Export verb handler\n         AWSENTRY ,\n         SPACE 1\n         LR    R2,R1               future reference\n         TM    AWSFILE+(DCBOFLGS-IHADCB),DCBOFOPN  already open?\n         BO    EXPRT010            yes, branch\n         CLOSE AWSFILE,MF=(E,DSCLOSEL) close file\n         FREEPOOL AWSFILE\n         SPACE 1\n         OPEN  (AWSFILE,(OUTPUT)),MF=(E,DSOPENL)  open awsfile\n         TM    AWSFILE+(DCBOFLGS-IHADCB),DCBOFOPN  open successful?\n         BO    EXPRT010            yes, branch\n         AWSMSG 060E,'AWSFILE open for EXPORT failed'\n         LA    R15,8               awsout open failed\n         B     EXPRTXIT            exit with error\n         SPACE 1\nEXPRT010 DS    0H                  prepare awscntl\n         TM    AWSFILE+(DCBRECFM-IHADCB),DCBRECU recfm=u?\n         BO    EXPRT020            yes, branch\n         TM    AWSFILE+(DCBRECFM-IHADCB),DCBRECV recfm=v?\n         BZ    EXPRT020            no, branch\n         OI    DSFLAGS,DSFRECV     indicate variable length output\n         SPACE 1\nEXPRT020 DS    0H                  export main line\n         OI    DSFLAGS,DSFOPNEX    indicate open for export\n         LR    R1,R2               current control statement\n         AWSCALL AWSEXPAR          parse export keywords\n         BNZ   EXPRTXIT\n         AWSCALL AWSJFDSN          extract JFCB dsname\n         BNZ   EXPRTXIT\n         AWSCALL AWSTPDSN          set 17 byte tape dsname\n         BNZ   EXPRTXIT\n         AWSCALL AWSUNLD           unload (stage) file if necessary\n         BNZ   EXPRTXIT\n         AWSCALL AWSECOPY          copy the file into AWS structure\n         BNZ   EXPRTXIT\n         AWSCALL AWSMARK           write tape mark\n         BNZ   EXPRTXIT\n         AWSCALL AWSTLR            write trailer labels\n         BNZ   EXPRTXIT\n         AWSCALL AWSUNALC          unallocate files\n         SPACE 1\nEXPRTXIT DS    0H                  return to caller\n         AWSEXIT ,\n         SPACE 1\n         LTORG ,\n         DROP ,\n         TITLE 'AWSTVPAR - Parse AWSVOL verb parameters'\n***********************************************************************\n* AWSTVPAR - Parse AWSVOL verb parameters                             *\n*            msg AWS07n                                               *\n*                                                                     *\n* On entry, r1 = cntl card image containing extract verb.             *\n* On exit,  appropriate data areas updated.                           *\n***********************************************************************\n         SPACE 1\nAWSTVPAR CSECT ,                   Parse extract verb parameters\n         AWSENTRY ,\n         SPACE 1\n         MVC   DSTVOL,CSBLNKS      clear volser\n         MVI   DSHETCMP,C' '       clear\n         MVI   DSHETMTH,C' '\n         MVI   DSHETLVL,C' '\n         MVI   DSHETIDR,C' '\n         MVC   DSHETCSZ,CSBLNKS\n         MVC   DSOWNER,=CL10'AWSSL 1.9G'\n         SPACE 1\n         LR    R3,R1               cntl statement image\n         LR    R5,R1               current location in scan\n         LA    R1,7                point beyond verb\n         SPACE 1\nTVPAR010 DS    0H                  locate a keyword\n         ALR   R5,R1               end of previous keyword if any\n         LA    R1,80(,R3)          end of statement\n         SLR   R1,R3               length remaining\n         BCTR  R1,0                machine relative\n         EX    R1,TVPAREX1         locate keyword\n         BZ    TVPARRC0            if no keyword found, exit\n         LR    R4,R1               keyword suffix location\n         LA    R5,1(,R1)           argument origin\nTVPAR020 DS    0H                  locate origin of keyword\n         BCTR  R4,0                backup one byte\n         CLI   0(R4),C','          comma delimiter?\n         BE    TVPAR030            yes, branch\n         CLI   0(R4),C' '          space delimiter?\n         BE    TVPAR030            yes, branch\n         CR    R4,R3               origin of statement reached?\n         BH    TVPAR020            no, continue search\n         AWSMSG 070E,'TAPEVOL parameter syntax error'\n         LA    R15,8               export parameter syntax error\n         B     TVPARXIT            return to caller\n         SPACE 1\nTVPAR030 DS    0H                  dispatch keyword handler\n         LA    R4,1(,R4)           keyword origin\n         CLC   =C'VOLSER=',0(R4)   volser= keyword?\n         BE    TVPAR100            yes, branch\n         CLC   =C'COMPRESS=',0(r4) COMPRESS= keyword?\n         BE    TVPAR110            yes, branch\n         CLC   =C'METHOD=',0(r4)   METHOD= keyword?\n         BE    TVPAR120            yes, branch\n         CLC   =C'LEVEL=',0(R4)    LEVEL= keyword?\n         BE    TVPAR130            yes, branch\n         CLC   =C'IDRC=',0(r4)     IDRC= keyword?\n         BE    TVPAR140            yes, branch\n         CLC   =C'CHUNKSIZE=',0(r4) CHUNKSIZE= keyword?\n         BE    TVPAR150            yes, branch\n         CLC   =C'OWNER=',0(R4)    OWNER= keyword?\n         BE    TVPAR160            yes, branch\n         MVC   DSMSG+1(7),=C'AWS071E'\n         MVC   DSMSG+19(29),=C'TAPEVOL KEYWORD UNRECOGNIZED:'\n         LR    R1,R5               argument origin\n         SLR   R1,R4               length of argument\n         BCTR  R1,0                machine relative\n         EX    R1,TVPAREX2         set keyword into message\n         AWSMSG ,                  write the message\n         LA    R15,8               export  keyword unrecognized\n         B     TVPARXIT            return to caller\n         SPACE 1\nTVPAR100 DS    0H                  tapevol= keyword handler\n         MVC   DSTVOL,CSBLNKS      clear volser\n         LA    R1,80(,R3)          end of cntl statement\n         SLR   R1,R5               length of statement remaining\n         EX    R1,TVPAREX3         locate delimiter\n         LR    R6,R1               delimiter location\n         SR    R1,R5               length of argument\n         BZ    TVPAR930            if null, branch\n         CH    R1,=Y(L'DSTVOL)     greater than maximum length?\n         BL    *+8                 no, branch\n         LA    R1,L'DSTVOL         else force to max length\n         BCTR  R1,0                machine relative\n         EX    R1,TVPAREX4         capture dsn\n         B     TVPAR900\n         SPACE 1\nTVPAR110 DS    0H                  HET= keyword handler\n         MVI   DSHETCMP,C' '       clear\n         LA    R1,80(,R3)          end of cntl statement\n         SLR   R1,R5               length of statement remaining\n         EX    R1,TVPAREX3         locate delimiter\n         LR    R6,R1               delimiter location\n         SR    R1,R5               length of argument\n         BZ    TVPAR930            if null, branch\n         CH    R1,=Y(L'DSHETCMP)   greater than maximum length?\n         BL    *+8                 no, branch\n         LA    R1,L'DSHETCMP       else force to max length\n         BCTR  R1,0                machine relative\n         EX    R1,TVPAREX5         capture argument\n         AWSMSG 072W,'Warning, COMPRESS keyword is not yet implemented,*\n                ignored'\n         B     TVPAR900\n         SPACE 1\nTVPAR120 DS    0H                  METHOD= keyword handler\n         MVI   DSHETMTH,C' '       clear HETLVL\n         LA    R1,80(,R3)          end of cntl statement\n         SLR   R1,R5               length of statement remaining\n         EX    R1,TVPAREX3         locate delimiter\n         LR    R6,R1               delimiter location\n         SR    R1,R5               length of argument\n         BZ    TVPAR930            if null, branch\n         CH    R1,=Y(L'DSHETMTH)   greater than maximum length?\n         BL    *+8                 no, branch\n         LA    R1,L'DSHETMTH       else force to max length\n         BCTR  R1,0                machine relative\n         EX    R1,TVPAREX6         capture argument\n         AWSMSG 073W,'Warning, METHOD keyword is not yet implemented, i*\n               gnored'\n         B     TVPAR900\n         SPACE 1\nTVPAR130 DS    0H                  LEVEL= keyword handler\n         MVI   DSHETLVL,C' '       clear HETLVL\n         LA    R1,80(,R3)          end of cntl statement\n         SLR   R1,R5               length of statement remaining\n         EX    R1,TVPAREX3         locate delimiter\n         LR    R6,R1               delimiter location\n         SR    R1,R5               length of argument\n         BZ    TVPAR930            if null, branch\n         CH    R1,=Y(L'DSHETLVL)   greater than maximum length?\n         BL    *+8                 no, branch\n         LA    R1,L'DSHETLVL       else force to max length\n         BCTR  R1,0                machine relative\n         EX    R1,TVPAREX7         capture argument\n         AWSMSG 074W,'Warning, LEVEL keyword is not yet implemented, ig*\n               nored'\n         B     TVPAR900\n         SPACE 1\nTVPAR140 DS    0H                  IDRC= keyword handler\n         MVI   DSHETIDR,C' '       clear\n         LA    R1,80(,R3)          end of cntl statement\n         SLR   R1,R5               length of statement remaining\n         EX    R1,TVPAREX3         locate delimiter\n         LR    R6,R1               delimiter location\n         SR    R1,R5               length of argument\n         BZ    TVPAR930            if null, branch\n         CH    R1,=Y(L'DSHETIDR)   greater than maximum length?\n         BL    *+8                 no, branch\n         LA    R1,L'DSHETIDR       else force to max length\n         BCTR  R1,0                machine relative\n         EX    R1,TVPAREX8         capture argument\n         AWSMSG 075W,'Warning, IDRC keyword is not yet implemented, ign*\n               ored'\n         B     TVPAR900\n         SPACE 1\nTVPAR150 DS    0H                  CHUNKSIZE= keyword handler\n         MVC   DSHETCSZ,CSBLNKS    clear\n         LA    R1,80(,R3)          end of cntl statement\n         SLR   R1,R5               length of statement remaining\n         EX    R1,TVPAREX3         locate delimiter\n         LR    R6,R1               delimiter location\n         SR    R1,R5               length of argument\n         BZ    TVPAR930            if null, branch\n         CH    R1,=Y(L'DSHETCSZ)   greater than max length?\n         BL    *+8                 no, branch\n         LA    R1,L'DSHETCSZ       else force to max length\n         BCTR  R1,0                machine relative\n         EX    R1,TVPAREX9         capture argument\n         AWSMSG 076W,'Warning, CHUNKSIZE keyword is not yet implemented*\n               , ignored'\n         B     TVPAR900\n         SPACE 1\nTVPAR160 DS    0H                  OWNER= keyword handler\n         MVC   DSOWNER,CSBLNKS\n         LA    R1,80(,R3)          end of cntl statement\n         SLR   R1,R5               length of statement remaining\n         TRT   0(1,R5),CSPARST3    quoted string?\n         BZ    TVPAR162            no, branch\n         LA    R5,1(,R5)           position at string origin\n         EX    R1,TVPAREXA         locate trailing quote\n         B     TVPAR164\nTVPAR162 DS    0H                  handle non quoted string\n         EX    R1,TVPAREX3         locate delimiter\nTVPAR164 DS    0H\n         LR    R6,R1               delimiter location\n         SR    R1,R5               length of argument\n         BZ    TVPAR930            if null, branch\n         CH    R1,=Y(L'DSOWNER)    greater than max length?\n         BL    *+8                 no, branch\n         LA    R1,L'DSOWNER        else force to max length\n         BCTR  R1,0                machine relative\n         EX    R1,TVPAREXB         capture argument\n*        B     TVPAR900\n         SPACE 1\nTVPAR900 DS    0H                  handle continuation if present\n         CLC   =C', ',0(R6)        continuation to next card?\n         BNE   TVPAR010            no, continue this statement, branch\n         SPACE 1\nTVPAR910 DS    0H                  retrieve continued statement\n         GET   AWSCNTL             retrieve a cntl record\n         LR    R3,R1               record location\n         MVC   DSMSG+1(7),=C'AWS077I'\n         MVC   DSMSG+19(80),0(R3)  set statement into message buffer\n         AWSMSG ,                  print function\n         CLI   0(R1),C'*'          comment?\n         BE    TVPAR910            yes, branch\n         CLC   0(80,R3),CSBLNKS    blank line?\n         BE    TVPAR910            yes, branch\n         CLI   0(R3),C' '          first byte non blank?\n         BE    TVPAR920            yes, branch\n         AWSMSG 078E,'Continuation statement error, 1st byte not blank'\n         LA    R15,8               continuation error\n         B     TVPARXIT            return to caller\n         SPACE 1\nTVPAR920 DS    0H                  setup for continue scan\n         LA    R5,1(,R1)           current location in scan\n         SLR   R1,R1               offset to argument\n         B     TVPAR010            continue\n         SPACE 1\nTVPAR930 DS    0H                  keyword with null argument found\n         LA    R1,1                position beyond delimiter\n         B     TVPAR900            continue\n         SPACE 1\nTVPARRC0 DS    0H                  exit with rc = 0\n         SLR   R15,R15             clear register\n         SPACE 1\nTVPARXIT DS    0H                  function exit\n         AWSEXIT ,\n         SPACE 1\nTVPAREX1 TRT   0(0,R5),CSPARST1    *** execute only ***\nTVPAREX2 MVC   DSMSG+49(0),0(R4)   *** execute only ***\nTVPAREX3 TRT   0(0,R5),CSPARST2    *** execute only ***\nTVPAREX4 MVC   DSTVOL(0),0(R5)     *** execute only ***\nTVPAREX5 MVC   DSHETCMP(0),0(R5)   *** execute only ***\nTVPAREX6 MVC   DSHETMTH(0),0(R5)   *** execute only ***\nTVPAREX7 MVC   DSHETLVL(0),0(R5)   *** execute only ***\nTVPAREX8 MVC   DSHETIDR(0),0(R5)   *** execute only ***\nTVPAREX9 MVC   DSHETCSZ(0),0(R5)   *** execute only ***\nTVPAREXA TRT   0(0,R5),CSPARST3    *** execute only ***\nTVPAREXB MVC   DSOWNER(0),0(R5)    *** execute only ***\n         SPACE 1\n         LTORG ,\n         DROP ,\n         TITLE 'AWSIMPAR - Parse IMPORT verb parameters'\n***********************************************************************\n* AWSIMPAR - Parse IMPORT verb parameters                             *\n*            msg AWS08n                                               *\n*                                                                     *\n* On entry, r1 = cntl card image containing extract verb.             *\n* On exit,  appropriate data areas updated.                           *\n***********************************************************************\n         SPACE 1\nAWSIMPAR CSECT ,                   Parse IMPORT verb parameters\n         AWSENTRY ,\n         SPACE 1\n         MVC   DSOUTDD,CSBLNKS     clear\n         MVC   DSINDSN,CSBLNKS\n         MVC   DSINFLNC,CSBLNKS\n         MVC   DSINFLNO,=H'1'\n         MVI   DSUSESL,C' '\n         MVC   DSLODPGM,CSBLNKS\n         SPACE 1\n         LR    R3,R1               cntl statement image\n         LR    R5,R1               current location in scan\n         LA    R6,6(,R5)           point beyond verb\n         SPACE 1\nIMPAR010 DS    0H                  locate a keyword\n         LA    R5,1(,R6)           end of previous keyword if any\n         LA    R1,80(,R3)          end of statement\n         SLR   R1,R3               length remaining\n         BCTR  R1,0                machine relative\n         EX    R1,IMPAREX1         locate keyword\n         BZ    IMPAR940            if no keyword found, exit\n         LR    R4,R1               keyword suffix location\n         LA    R5,1(,R1)           argument origin\nIMPAR020 DS    0H                  locate origin of keyword\n         BCTR  R4,0                backup one byte\n         CLI   0(R4),C','          comma delimiter?\n         BE    IMPAR030            yes, branch\n         CLI   0(R4),C' '          space delimiter?\n         BE    IMPAR030            yes, branch\n         CR    R4,R3               origin of statement reached?\n         BH    IMPAR020            no, continue search\n         AWSMSG 080E,'AWSGET parameter syntax error'\n         LA    R15,8               import parameter syntax error\n         B     IMPARXIT            return to caller\n         SPACE 1\nIMPAR030 DS    0H                  dispatch keyword handler\n         LA    R4,1(,R4)           keyword origin\n         CLC   =C'OUTDD=',0(R4)    OUTDD= keyword?\n         BE    IMPAR100            yes, branch\n         CLC   =C'INDSN=',0(R4)    INDSN= keyword?\n         BE    IMPAR110            yes, branch\n         CLC   =C'FILENO=',0(R4)   FILENO= keyword?\n         BE    IMPAR120            yes, branch\n         CLC   =C'SL=',0(R4)       SL= keyword?\n         BE    IMPAR140            yes, branch\n         CLC   =C'LOAD=',0(R4)     LOAD= keyword?\n         BE    IMPAR150            yes, branch\n         MVC   DSMSG+1(7),=C'AWS081E'\n         MVC   DSMSG+19(29),=C'AWSGET keyword unrecognized:'\n         LR    R1,R5               argument origin\n         SLR   R1,R4               length of argument\n         BCTR  R1,0                machine relative\n         EX    R1,IMPAREX2         set keyword into message\n         AWSMSG ,                  write the message\n         LA    R15,8               import  keyword unrecognized\n         B     IMPARXIT            return to caller\n         SPACE 1\nIMPAR100 DS    0H                  outdd= keyword handler\n         MVC   DSOUTDD,CSBLNKS     clear volser\n         LA    R1,80(,R3)          end of cntl statement\n         SLR   R1,R5               length of statement remaining\n         EX    R1,IMPAREX3         locate delimiter\n         LR    R6,R1               delimiter location\n         SR    R1,R5               length of argument\n         BZ    IMPAR930            if null, branch\n         CH    R1,=Y(L'DSOUTDD)    greater than maximum length?\n         BL    *+8                 no, branch\n         LA    R1,L'DSOUTDD        else force to max length\n         BCTR  R1,0                machine relative\n         EX    R1,IMPAREX4         capture\n         B     IMPAR900\n         SPACE 1\nIMPAR110 DS    0H                  indsn= keyword handler\n         MVC   DSINDSN,CSBLNKS     clear\n         LA    R1,80(,R3)          end of cntl statement\n         SLR   R1,R5               length of statement remaining\n         EX    R1,IMPAREX3         locate delimiter\n         LR    R6,R1               delimiter location\n         SR    R1,R5               length of argument\n         BZ    IMPAR930            if null, branch\n         CH    R1,=Y(L'DSINDSN)    greater than maximum length?\n         BL    *+8                 no, branch\n         LA    R1,L'DSINDSN        else force to max length\n         BCTR  R1,0                machine relative\n         EX    R1,IMPAREX5         capture argument\n         B     IMPAR900\n         SPACE 1\nIMPAR120 DS    0H                  fileno= keyword handler\n         MVC   DSINFLNC,CSBLNKS    clear\n         MVC   DSINFLNO,=H'1'      default\n         LA    R1,80(,R3)          end of cntl statement\n         SLR   R1,R5               length of statement remaining\n         EX    R1,IMPAREX3         locate delimiter\n         LR    R6,R1               delimiter location\n         SR    R1,R5               length of argument\n         BZ    IMPAR930            if null, branch\n         CH    R1,=Y(L'DSINFLNC)   greater than maximum length?\n         BL    *+8                 no, branch\n         LA    R1,L'DSINFLNC       else force to max length\n         BCTR  R1,0                machine relative\n         LR    R14,R1              save for future reference\n         EX    R1,IMPAREX6         numeric?\n         BZ    IMPAR130            yes, branch\n         AWSMSG 082E,'FILENO= Argument is not numeric'\n         LA    R15,8               return code\n         B     IMPARXIT\nIMPAR130 DS    0H\n         EX    R14,IMPAREX7        pack fileno character argument\n         CVB   R0,DSDWORK          convert to binary\n         STH   R0,DSINFLNO         ... AND SAVE\n         B     IMPAR900\n         SPACE 1\nIMPAR140 DS    0H                  SL= keyword handler\n         MVI   DSUSESL,C' '        clear\n         LA    R1,80(,R3)          end of cntl statement\n         SLR   R1,R5               length of statement remaining\n         EX    R1,IMPAREX3         locate delimiter\n         LR    R6,R1               delimiter location\n         SR    R1,R5               length of argument\n         BZ    IMPAR930            if null, branch\n         CH    R1,=Y(L'DSUSESL)    greater than maximum length?\n         BL    *+8                 no, branch\n         LA    R1,L'DSUSESL        else force to max length\n         BCTR  R1,0                machine relative\n         EX    R1,IMPAREX8         capture argument\n         SPACE 1\n         CLI   DSUSESL,C' '        default?\n         BE    IMPAR900            yes, branch\n         CLI   DSUSESL,C'N'        sl=no?\n         BE    IMPAR900            yes, branch\n         CLI   DSUSESL,C'Y'        sl=yes?\n         BE    IMPAR900            yes, branch\n         AWSMSG 083E,'SL= Argument is invalid'\n         LA    R15,8\n         B     IMPARXIT\n         SPACE 1\nIMPAR150 DS    0H\n         MVC   DSLODPGM,CSBLNKS    clear\n         LA    R1,80(,R3)          end of cntl statement\n         SLR   R1,R5               length of statement remaining\n         EX    R1,IMPAREX3         locate delimiter\n         LR    R6,R1               delimiter location\n         SR    R1,R5               length of argument\n         BZ    IMPAR930            if null, branch\n         CH    R1,=Y(L'DSLODPGM)   greater than maximum length?\n         BL    *+8                 no, branch\n         LA    R1,L'DSLODPGM       else force to max length\n         BCTR  R1,0                machine relative\n         EX    R1,IMPAREX9         capture argument\n*        B     IMPAR900\n         SPACE 1\nIMPAR900 DS    0H                  handle continuation if present\n         CLC   =C', ',0(R6)        continuation to next card?\n         BNE   IMPAR010            no, continue this statement, branch\n         SPACE 1\nIMPAR910 DS    0H                  retrieve continued statement\n         GET   AWSCNTL             retrieve a cntl record\n         LR    R3,R1               record location\n         MVC   DSMSG+1(7),=C'AWS084I'\n         MVC   DSMSG+19(80),0(R3)  set statement into message buffer\n         AWSMSG ,                  print function\n         CLI   0(R1),C'*'          comment?\n         BE    IMPAR910            yes, branch\n         CLC   0(80,R3),CSBLNKS    blank line?\n         BE    IMPAR910            yes, branch\n         CLI   0(R3),C' '          first byte non blank?\n         BE    IMPAR920            yes, branch\n         AWSMSG 085E,'Continuation statement error, 1st byte not blank'\n         LA    R15,8               continuation error\n         B     IMPARXIT            return to caller\n         SPACE 1\nIMPAR920 DS    0H                  setup for continue scan\n         LA    R5,1(,R1)           current location in scan\n         SLR   R1,R1               offset to argument\n         B     IMPAR010            continue\n         SPACE 1\nIMPAR930 DS    0H                  keyword with null argument found\n         LA    R1,1                position beyond delimiter\n         B     IMPAR900            continue\n         SPACE 1\nIMPAR940 DS    0H                  exit with rc = 0\n         CLI   DSOUTDD,C' '        output ddname specified?\n         BH    IMPAR950            yes, branch\n         AWSMSG 086E,'AWSGET requires that OUTDD= be specified'\n         LA    R15,8\n         B     IMPARXIT\n         SPACE 1\nIMPAR950 DS    0H                  normal return\n         SLR   R15,R15             clear register\n         SPACE 1\nIMPARXIT DS    0H                  function exit\n         AWSEXIT ,\n         SPACE 1\nIMPAREX1 TRT   0(0,R5),CSPARST1    *** execute only ***\nIMPAREX2 MVC   DSMSG+49(0),0(R4)   *** execute only ***\nIMPAREX3 TRT   0(0,R4),CSPARST2    *** execute only ***\nIMPAREX4 MVC   DSOUTDD(0),0(R5)    *** execute only ***\nIMPAREX5 MVC   DSINDSN(0),0(R5)    *** execute only ***\nIMPAREX6 TRT   0(0,R5),CSNUMTRT    *** execute only ***\nIMPAREX7 PACK  DSDWORK,0(0,R5)     *** execute only ***\nIMPAREX8 MVC   DSUSESL(0),0(R5)    *** execute only ***\nIMPAREX9 MVC   DSLODPGM(0),0(R5)   *** execute only ***\n         SPACE 1\n         LTORG ,\n         DROP ,\n         TITLE 'AWSEXPAR - Parse extract verb parameters'\n***********************************************************************\n* AWSEXPAR - Parse extract verb parameters                            *\n*            msg AWS09n                                               *\n*                                                                     *\n* On entry, r1 = cntl card image containing extract verb.             *\n* On Exit,  appropriate data areas updated.                           *\n***********************************************************************\n         SPACE 1\nAWSEXPAR CSECT ,                   Parse extract verb parameters\n         AWSENTRY ,\n         SPACE 1\n         MVC   DSINDSN,CSBLNKS     clear input dsn\n         MVC   DSOUTDSN,CSBLNKS    clear output dsn\n         MVC   DSTDSN,CSBLNKS      clear tape dsn\n         MVC   DSINDD,CSBLNKS      clear input dd name\n         MVC   DSUNLPGM,CSBLNKS    clear unload program\n         MVC   DSUNLTYP,CSBLNKS    clear unload type\n         MVI   DSUSESL,C' '        clear use standard labels flag\n         SPACE 1\n         LR    R3,R1               cntl statement image\n         LR    R5,R1               current location in scan\n         LA    R1,7                point beyond verb\n         SPACE 1\nEXPAR010 DS    0H                  locate a keyword\n         ALR   R5,R1               end of previous keyword if any\n         LA    R1,80(,R3)          end of statement\n         SLR   R1,R3               length remaining\n         BCTR  R1,0                machine relative\n         EX    R1,EXPAREX1         locate keyword\n         BZ    EXPARRC0            if no keyword found, exit\n         LR    R4,R1               keyword suffix location\n         LA    R5,1(,R1)           argument origin\nEXPAR020 DS    0H                  locate origin of keyword\n         BCTR  R4,0                backup one byte\n         CLI   0(R4),C','          comma delimiter?\n         BE    EXPAR030            yes, branch\n         CLI   0(R4),C' '          space delimiter?\n         BE    EXPAR030            yes, branch\n         CR    R4,R3               origin of statement reached?\n         BH    EXPAR020            no, continue search\n         AWSMSG 090E,'AWSPUT parameter syntax error'\n         LA    R15,8               export parameter syntax error\n         B     EXPARXIT            return to caller\n         SPACE 1\nEXPAR030 DS    0H                  dispatch keyword handler\n         LA    R4,1(,R4)           keyword origin\n         CLC   =C'INDSN=',0(R4)    INDSN= keyword?\n         BE    EXPAR100            yes, branch\n         CLC   =C'OUTDSN=',0(R4)   OUTDSN= keyword?\n         BE    EXPAR110            yes, branch\n         CLC   =C'TAPEDSN=',0(R4)  TAPEDSN= keyword?\n         BE    EXPAR120            yes, branch\n         CLC   =C'INDD=',0(R4)     INDD= keyword?\n         BE    EXPAR130            yes, branch\n         CLC   =C'UNLOAD=',0(R4)   UNLOAD= keyword?\n         BE    EXPAR140            yes, branch\n         CLC   =C'TYPE=',0(R4)     TYPE= keyword?\n         BE    EXPAR150            yes, branch\n         CLC   =C'SL=',0(R4)       SL= keyword?\n         BE    EXPAR160            yes, branch\n         MVC   DSMSG+1(7),=C'AWS091E'\n         MVC   DSMSG+19(28),=C'AWSPUT keyword unrecognized:'\n         LR    R1,R5               argument origin\n         SLR   R1,R4               length of argument\n         BCTR  R1,0                machine relative\n         EX    R1,EXPAREX2         set keyword into message\n         AWSMSG ,                  write the message\n         LA    R15,8               export  keyword unrecognized\n         B     EXPARXIT            return to caller\n         SPACE 1\nEXPAR100 DS    0H                  indsn= keyword handler\n         MVC   DSINDSN,CSBLNKS     clear dataset name\n         LA    R1,80(,R3)          end of cntl statement\n         SLR   R1,R5               length of statement remaining\n         EX    R1,EXPAREX3         locate delimiter\n         LR    R6,R1               delimiter location\n         SR    R1,R5               length of argument\n         BZ    EXPAR930            if null, branch\n         CH    R1,=Y(L'DSINDSN)    greater than maximum length?\n         BL    *+8                 no, branch\n         LA    R1,L'DSINDSN        else force to max length\n         BCTR  R1,0                machine relative\n         EX    R1,EXPAREX4         capture dsn\n         B     EXPAR900\n         SPACE 1\nEXPAR110 DS    0H                  outdsn= keyword handler\n         MVC   DSOUTDSN,CSBLNKS    clear out dataset name\n         LA    R1,80(,R3)          end of cntl statement\n         SLR   R1,R5               length of statement remaining\n         EX    R1,EXPAREX3         locate delimiter\n         LR    R6,R1               delimiter location\n         SR    R1,R5               length of argument\n         BZ    EXPAR930            if null, branch\n         CH    R1,=Y(L'DSOUTDSN)   greater than maximum length?\n         BL    *+8                 no, branch\n         LA    R1,L'DSOUTDSN       else force to max length\n         BCTR  R1,0                machine relative\n         EX    R1,EXPAREX5         capture dsn\n         B     EXPAR900\n         SPACE 1\nEXPAR120 DS    0H                  tapedsn= keyword handler\n         MVC   DSTDSN,CSBLNKS      clear tape dsn\n         LA    R1,80(,R3)          end of cntl statement\n         SLR   R1,R5               length of statement remaining\n         EX    R1,EXPAREX3         locate delimiter\n         LR    R6,R1               delimiter location\n         SR    R1,R5               length of argument\n         BZ    EXPAR930            if null, branch\n         CH    R1,=Y(L'DSTDSN)     greater than maximum length?\n         BL    *+8                 no, branch\n         LA    R1,L'DSTDSN         else force to maximum length\n         BCTR  R1,0                machine relative\n         EX    R1,EXPAREX6         capture dsn\n         B     EXPAR900\n         SPACE 1\nEXPAR130 DS    0H                  INDD= keyword handler\n         MVC   DSINDD,CSBLNKS      clear input dd name\n         LA    R1,80(,R3)          end of cntl statement\n         SLR   R1,R5               length of statement remaining\n         EX    R1,EXPAREX3         locate delimiter\n         LR    R6,R1               delimiter location\n         SR    R1,R5               length of argument\n         BZ    EXPAR930            if null, branch\n         CH    R1,=Y(L'DSINDD)     maximum length\n         BL    *+8                 no, branch\n         LA    R1,L'DSINDD         else force to max length\n         BCTR  R1,0                machine relative\n         EX    R1,EXPAREX7         capture indd\n         B     EXPAR900\n         SPACE 1\nEXPAR140 DS    0H                  UNLOAD= keyword handler\n         MVC   DSUNLPGM,CSBLNKS    clear unload program name\n         LA    R1,80(,R3)          end of cntl statement\n         SLR   R1,R5               length of statement remaining\n         EX    R1,EXPAREX3         locate delimiter\n         LR    R6,R1               delimiter location\n         SR    R1,R5               length of argument\n         BZ    EXPAR930            if null, branch\n         CH    R1,=Y(L'DSUNLPGM)   maximum length\n         BL    *+8                 no, branch\n         LA    R1,L'DSUNLPGM       else force to max length\n         BCTR  R1,0                machine relative\n         EX    R1,EXPAREX8         capture unload program\n         B     EXPAR900\n         SPACE 1\nEXPAR150 DS    0H                  TYPE= keyword handler\n         MVC   DSUNLTYP,CSBLNKS    clear unload type\n         LA    R1,80(,R3)          end of cntl statement\n         SLR   R1,R5               length of statement remaining\n         EX    R1,EXPAREX3         locate delimiter\n         LR    R6,R1               delimiter location\n         SR    R1,R5               length of argument\n         BZ    EXPAR930            if null, branch\n         CH    R1,=Y(L'DSUNLTYP)   maximum length\n         BL    *+8                 no, branch\n         LA    R1,L'DSUNLTYP       else force to max length\n         BCTR  R1,0                machine relative\n         EX    R1,EXPAREX9         capture unload program\n         B     EXPAR900\n         SPACE 1\nEXPAR160 DS    0H                  TYPE= keyword handler\n         MVI   DSUNLTYP,C' '       clear use standard labels flag\n         LA    R1,80(,R3)          end of cntl statement\n         SLR   R1,R5               length of statement remaining\n         EX    R1,EXPAREX3         locate delimiter\n         LR    R6,R1               delimiter location\n         SR    R1,R5               length of argument\n         BZ    EXPAR170            if null, branch\n         CH    R1,=Y(L'DSUSESL)    maximum length\n         BL    *+8                 no, branch\n         LA    R1,L'DSUSESL        else force to max length\n         BCTR  R1,0                machine relative\n         EX    R1,EXPAREXA         capture\n         SPACE 1\n         CLI   DSUSESL,C' '        default?\n         BE    EXPAR170            yes, branch\n         CLI   DSUSESL,C'N'        sl=no?\n         BE    EXPAR170            yes, branch\n         CLI   DSUSESL,C'Y'        sl=yes?\n         BE    EXPAR170            yes, branch\n         AWSMSG 054E,'SL= Argument is invalid'\n         LA    R15,8\n         B     EXPARXIT\n         SPACE 1\nEXPAR170 DS    0H\n         SPACE 1\nEXPAR900 DS    0H                  handle continuation if present\n         CLC   =C', ',0(R6)        continuation to next card?\n         BNE   EXPAR010            no, continue this statement, branch\n         SPACE 1\nEXPAR910 DS    0H                  retrieve continued statement\n         GET   AWSCNTL             retrieve a cntl record\n         LR    R3,R1               record location\n         MVC   DSMSG+1(7),=C'AWS052I'\n         MVC   DSMSG+19(80),0(R3)  set statement into message buffer\n         AWSMSG ,                  print function\n         CLI   0(R1),C'*'          comment?\n         BE    EXPAR910            yes, branch\n         CLC   0(80,R3),CSBLNKS    blank line?\n         BE    EXPAR910            yes, branch\n         CLI   0(R3),C' '          first byte non blank?\n         BE    EXPAR920            yes, branch\n         AWSMSG 092E,'Continuation statement error, 1st byte not blank'\n         LA    R15,8               continuation error\n         B     EXPARXIT            return to caller\n         SPACE 1\nEXPAR920 DS    0H                  setup for continue scan\n         LA    R5,1(,R1)           current location in scan\n         SLR   R1,R1               offset to argument\n         B     EXPAR010            continue\n         SPACE 1\nEXPAR930 DS    0H                  keyword with null argument found\n         LA    R1,1                position beyond delimiter\n         B     EXPAR900            continue\n         SPACE 1\nEXPARRC0 DS    0H                  exit with rc = 0\n         SLR   R15,R15             clear register\n         SPACE 1\nEXPARXIT DS    0H                  function exit\n         AWSEXIT ,\n         SPACE 1\nEXPAREX1 TRT   0(0,R5),CSPARST1    *** execute only ***\nEXPAREX2 MVC   DSMSG+48(0),0(R4)   *** execute only ***\nEXPAREX3 TRT   0(0,R5),CSPARST2    *** execute only ***\nEXPAREX4 MVC   DSINDSN(0),0(R5)    *** execute only ***\nEXPAREX5 MVC   DSOUTDSN(0),0(R5)   *** execute only ***\nEXPAREX6 MVC   DSTDSN(0),0(R5)     *** execute only ***\nEXPAREX7 MVC   DSINDD(0),0(R5)     *** execute only ***\nEXPAREX8 MVC   DSUNLPGM(0),0(R5)   *** execute only ***\nEXPAREX9 MVC   DSUNLTYP(0),0(R5)   *** execute only ***\nEXPAREXA MVC   DSUSESL(0),0(R5)    *** execute only ***\n         SPACE 1\n         LTORG ,\n         DROP ,\n         TITLE 'AWSJFDSN - Extract input dsn'\n***********************************************************************\n* AWSJFDSN - Extract input dsn                                        *\n*            msg AWS10n                                               *\n***********************************************************************\n         SPACE 1\nAWSJFDSN CSECT ,                   Extract input dsn\n         AWSENTRY ,\n         SPACE 1\n         CLI   DSOUTDSN,C' '       output dsn specified?\n         BH    JFDSNXIT            yes, exit\n         CLI   DSTDSN,C' '         explicit tape dsn specified?\n         BH    JFDSNXIT            yes, exit\n         SPACE 1\n         CLI   DSINDD,C' '         indd specified?\n         BH    JFDSN010            yes, branch\n         MVC   DSOUTDSN,DSINDSN    else default outdsn to indsn\n         B     JFDSNXIT            exit\n         SPACE 1\nJFDSN010 DS    0H                  capture outdsn from indd=\n         MVC   AWSUT1+(DCBDDNAM-IHADCB)(8),=CL8'AWSUT1'\n         CLI   DSINDD,C' '         input dd present?\n         BE    *+10                no, use awsut1, branch\n         MVC   AWSUT1+(DCBDDNAM-IHADCB)(8),DSINDD\n         SPACE 1\n         RDJFCB AWSUT1,MF=(E,DSRDJFCB) read the jfcb\n         MVC   DSOUTDSN,JFCBDSNM   default outdsn to input dsn\n         SPACE 1\nJFDSNXIT DS    0H                  function exit\n         SLR   R15,R15             zero return code\n         AWSEXIT ,                 return to caller\n         SPACE 1\n         LTORG ,\n         DROP\n         TITLE 'AWSTPDSN - Set 17 byte tape dsn'\n***********************************************************************\n* AWSTPDSN - Set 17 byte tape dsn                                     *\n*            msg AWS11n                                               *\n***********************************************************************\n         SPACE 1\nAWSTPDSN CSECT ,                   Set 17 byte tape dsn\n         AWSENTRY ,\n         SPACE 1\n         CLI   DSTDSN,C' '         tape dsn explicitly given?\n         BH    TPDSNXIT            yes, branch\n         SPACE 1\n         LA    R1,DSOUTDSN+L'DSOUTDSN point beyond outdsn\n         TRT   DSOUTDSN,CSPARST2   locate end of outdsn\n         LA    R2,DSOUTDSN         outdsn origin\n         SLR   R1,R2               length of outdsn\n         CH    R1,=Y(L'DSTDSN)     greater than maximum length?\n         BH    TPDSN010            yes, branch\n         MVC   DSTDSN,DSOUTDSN     else default outdsn as is\n         B     TPDSNXIT            exit\n         SPACE 1\nTPDSN010 DS    0H                  capture right most 17 bytes\n         SH    R1,=Y(L'DSTDSN)     offset to start of name\n         ALR   R2,R1               origin of move\n         MVC   DSTDSN,0(R2)        capture\n         SPACE 1\nTPDSNXIT DS    0H                  function exit\n         SLR   R15,R15             zero return code\n         AWSEXIT ,                 return to caller\n         SPACE 1\n         LTORG ,\n         DROP  ,\n         TITLE 'AWSJOBNM - Capture job and step name info'\n***********************************************************************\n* AWSJOBNM - Capture job and step name info                           *\n*            msg AWS12n                                               *\n***********************************************************************\n         SPACE 1\nAWSJOBNM CSECT ,                   Capture job and step name info\n         AWSENTRY ,\n         USING PSA,R0\n         L     R3,PSATOLD          current TCB location\n         USING TCB,R3              TCB addressasbility\n         L     R4,TCBTIO           TIOT location\n         USING TIOT,R4\n         MVC   DSJOBNM,TIOCNJOB    set job  name\n         MVC   DSSTEPNM,TIOCSTEP+8 set step name\n         CLI   DSSTEPNM,C' '       blank stepname?\n         BNE   JOBNMXIT            no, branch\n         MVC   DSSTEPNM,TIOCSTEP   else try w/o procstep\n         SPACE 1\nJOBNMXIT DS    0H                  function exit\n         SLR   R15,R15             zero return code\n         AWSEXIT ,                 return to caller\n         SPACE 1\n         LTORG ,\n         DROP ,\n         TITLE 'AWSUNLD - Unload (stage) dataset'\n***********************************************************************\n* AWSUNLD - Unload (stage) dataset                                    *\n*           msg AWS13n                                                *\n***********************************************************************\n         SPACE 1\nAWSUNLD  CSECT ,                   Unload (stage) dataset\n         AWSENTRY ,\n         SPACE 1\n         SLR   R15,R15             zero return code\n         CLI   DSUNLPGM,C' '       unload requested?\n         BE    UNLODXIT            no, branch\n         SPACE 1\n         AWSCALL AWSALCI           allocate input dataset\n         BNZ   UNLODXIT\n         SPACE 1\n         AWSCALL AWSALCT           allocate work dataset\n         BNZ   UNLODXIT\n         SPACE 1\n         AWSCALL AWSALCS           allocate sysin dataset\n         BNZ   UNLODXIT\n         SPACE 1\n         AWSCALL AWSALCP           allocate sysprint dataset\n         BNZ   UNLODXIT\n         SPACE 1\n         OPEN  (SYSIN,(OUTPUT)),MF=(E,DSOPENL) open sysin for output\n         SPACE 1\n         TM    SYSIN+(DCBOFLGS-IHADCB),DCBOFOPN open ok?\n         BO    UNLOD010            yes, branch\n         AWSMSG 130E,'SYSIN open for output failed'\n         LA    R15,8               set return code\n         B     UNLODXIT\n         SPACE 1\nUNLOD010 DS    0H                  determine type of unload\n         CLC   =C'IEBCOPY',DSUNLPGM iebcopy unload?\n         BE    UNLOD100            yes, branch\n         CLC   =C'IDCAMS',DSUNLPGM idcams export?\n         BE    UNLOD200            yes, branch\n         AWSMSG 131E,'Unrecognized unload program specified'\n         LA    R15,8               unrecognized unload pgm\n         B     UNLODXIT            exit\n         SPACE 1\nUNLOD100 DS    0H                  iebcopy unload request\n         MVI   DSCARD,C' '         clear card image\n         MVC   DSCARD+1(L'DSCARD-1),DSCARD\n         MVC   DSCARD(15),=C' C O=AWSTEMP,I='\n         MVC   DSCARD+15(8),DSINDD assume indd= statement present\n         CLI   DSINDD,C' '         indd= keyword present?\n         BH    UNLOD110            yes, branch\n         MVC   DSCARD+15(8),=CL8'AWSUT1' else use default\n         SPACE 1\nUNLOD110 DS    0H                  write control statement\n         PUT   SYSIN,DSCARD\n         SPACE 1\n         CLOSE SYSIN,MF=(E,DSCLOSEL) close file\n         FREEPOOL SYSIN            release buffer pool\n         SPACE 1\n         SLR   R1,R1               clear parameter register\n         LINK  EP=IEBCOPY          invoke iebcopy\n         LTR   R15,R15             success?\n         BZ    UNLOD120            yes, branch\n         AWSMSG 132E,'IEBCOPY unload failed'\n         LA    R15,8               set return code\n         B     UNLODXIT            exit\n         space 1\nUNLOD120 DS    0H                  Unload via iebcopy successful msg\n         AWSMSG ,                  blank line\n         AWSMSG 133I,'PDS(E) unload successful'\n         B     UNLODXIT            exit\n         SPACE 1\nUNLOD200 DS    0H                  idcams export\n         AWSMSG 134F,'IDCAMS export not yet supported'\n         LA    R15,12\n*        B     UNLODXIT\n         SPACE 1\nUNLODXIT DS    0H                  return to caller\n         AWSEXIT ,\n         SPACE 1\n         LTORG ,\n         DROP\n         TITLE 'AWSALCI - Dynamically allocate input'\n***********************************************************************\n* AWSALCI - Dynamically allocate input                                *\n*           msg AWS14n                                                *\n***********************************************************************\n         SPACE 1\nAWSALCI  CSECT ,                   Dynamically allocate input\n         AWSENTRY ,\n         SPACE 1\n         CLI   DSINDD,C' '         input dataset already allocated?\n         BNE   ALOCI030            yes, branch\n         SPACE 1\n         MVC   DSADSNMT,DSINDSN    input dataset name\n         LA    R1,DSARBP           input rb pointer\n         SVC   99                  input allocation\n         LTR   R15,R15             successful?\n         BZ    ALOCI020            yes, branch\n         LA    R3,DSARB            rb location\n         USING S99RB,R3            input rb addressability\n         CH    R15,CSH4            rc=4?\n         BNE   ALOCI010            no, error, branch\n         CLC   S99ERROR,=X'0410'   ddname already allocated?\n         BE    ALOCI030            yes, branch\n         SPACE 1\nALOCI010 DS    0H                  allocation error occured\n         LR    R1,R3               set rb location\n         LR    R0,R15              return code\n         AWSCALL AWSDYNE           format dynalloc error messages\n         AWSMSG 140E,'Input dataset dynamic allocation failed'\n         LA    R15,8               set return code\n         B     ALOCIXIT            exit\n         SPACE 1\nALOCI020 DS    0H                  successful dynamic allocation\n         OI    DSFLAGS,DSFDYUT1    awsut1 dynamically allocated\n         SPACE 1\nALOCI030 DS    0H                  normal return\n         SLR   R15,R15             zero return code\n         SPACE 1\nALOCIXIT DS    0H                  return to caller\n         AWSEXIT ,\n         SPACE 1\n         LTORG ,\n         DROP\n         TITLE 'AWSALCT - Dynamically allocate temporary work'\n***********************************************************************\n* AWSALCT - Dynamically allocate temporary work                       *\n*           msg AWS15n                                                *\n***********************************************************************\n         SPACE 1\nAWSALCT  CSECT ,                   Dynamically allocate temporary work\n         AWSENTRY ,\n         SPACE 1\n         LA    R1,DSTARBP          temp work rb pointer\n         SVC   99                  temp work allocation\n         LTR   R15,R15             successful?\n         BZ    ALOCT020            yes, branch\n         LA    R3,DSTARB           rb location\n         USING S99RB,R3            input rb addressability\n         CH    R15,CSH4            rc=4?\n         BNE   ALOCT010            no, error, branch\n         CLC   S99ERROR,=X'0410'   ddname already allocated?\n         BE    ALOCT030            yes, branch\n         SPACE 1\nALOCT010 DS    0H                  allocation error occured\n         LR    R1,R3               set rb location\n         LR    R0,R15              return code\n         AWSCALL AWSDYNE           format dynalloc error messages\n         AWSMSG 150E,'Temp work dataset dynamic allocation failed'\n         LA    R15,8               set return code\n         B     ALOCTXIT            exit\n         SPACE 1\nALOCT020 DS    0H                  successful dynamic allocation\n         OI    DSFLAGS,DSFDYTMP    awstemp dynamically allocated\n         SPACE 1\nALOCT030 DS    0H                  normal return\n         SLR   R15,R15             zero return code\n         SPACE 1\nALOCTXIT DS    0H                  return to caller\n         AWSEXIT ,\n         SPACE 1\n         LTORG ,\n         DROP\n         TITLE 'AWSALCS - Dynamically allocate sysin'\n***********************************************************************\n* AWSALCS - Dynamically allocate temporary sysin                      *\n*           msg AWS16n                                                *\n***********************************************************************\n         SPACE 1\nAWSALCS  CSECT ,                   Dynamically allocate temporary work\n         AWSENTRY ,\n         SPACE 1\n         LA    R1,DSSARBP          temp work rb pointer\n         SVC   99                  temp work allocation\n         LTR   R15,R15             successful?\n         BZ    ALOCS020            yes, branch\n         LA    R3,DSSARB           rb location\n         USING S99RB,R3            input rb addressability\n         CH    R15,CSH4            rc=4?\n         BNE   ALOCS010            no, error, branch\n         CLC   S99ERROR,=X'0410'   ddname already allocated?\n         BE    ALOCS030            yes, branch\n         SPACE 1\nALOCS010 DS    0H                  allocation error occured\n         LR    R1,R3               set rb location\n         LR    R0,R15              return code\n         AWSCALL AWSDYNE           format dynalloc error messages\n         AWSMSG 160E,'SYSIN dataset dynamic allocation failed'\n         LA    R15,8               set return code\n         B     ALOCSXIT            exit\n         SPACE 1\nALOCS020 DS    0H                  successful dynamic allocation\n         OI    DSFLAGS,DSFDYSYI    sysin dynamically allocated\n         SPACE 1\nALOCS030 DS    0H                  normal return\n         SLR   R15,R15             zero return code\n         SPACE 1\nALOCSXIT DS    0H                  return to caller\n         AWSEXIT ,\n         SPACE 1\n         LTORG ,\n         DROP\n         TITLE 'AWSALCP - Dynamically allocate sysprint'\n***********************************************************************\n* AWSALCP - Dynamically allocate sysprint                             *\n*           msg AWS17n                                                *\n***********************************************************************\n         SPACE 1\nAWSALCP  CSECT ,                   Dynamically allocate sysprint\n         AWSENTRY ,\n         SPACE 1\n         LA    R1,DSPARBP          temp work rb pointer\n         SVC   99                  temp work allocation\n         LTR   R15,R15             successful?\n         BZ    ALOCP020            yes, branch\n         LA    R3,DSPARB           rb location\n         USING S99RB,R3            input rb addressability\n         CH    R15,CSH4            rc=4?\n         BNE   ALOCP010            no, error, branch\n         CLC   S99ERROR,=X'0410'   ddname already allocated?\n         BE    ALOCP030            yes, branch\n         SPACE 1\nALOCP010 DS    0H                  allocation error occured\n         LR    R1,R3               set rb location\n         LR    R0,R15              return code\n         AWSCALL AWSDYNE           format dynalloc error messages\n         AWSMSG 170E,'SYSPRINT dataset dynamic allocation failed'\n         LA    R15,8               set return code\n         B     ALOCPXIT            exit\n         SPACE 1\nALOCP020 DS    0H                  successful dynamic allocation\n         OI    DSFLAGS,DSFDYSYP    sysprint dynamically allocated\n         SPACE 1\nALOCP030 DS    0H                  normal return\n         SLR   R15,R15             zero return code\n         SPACE 1\nALOCPXIT DS    0H                  return to caller\n         AWSEXIT ,\n         SPACE 1\n         LTORG ,\n         DROP\n         TITLE 'AWSDYNE - Dyanamic allocation error'\n***********************************************************************\n* AWSDYNE - Dynamic allocation error, on entry r1 = s99rb, r0=rc      *\n*           msg AWS18n                                                *\n***********************************************************************\n         SPACE 1\nAWSDYNE  CSECT ,                   Dynamic allocation error\n         AWSENTRY ,\n         SPACE 1\n         LR    R3,R1               dynalloc rb location\n         USING S99RB,R3            addressability\n         LR    R4,R0               dynalloc return code\n         SPACE 1\n         MVC   DSMSG+1(7),=C'AWS180E'\n         MVC   DSMSG+19(54),=C'DYNALLOC FAILURE, RC=XXXX, S99ERROR=XXXX*\n               , S99INFO=XXXX'\n         ST    R4,DSFWORK                  rc\n         UNPK  DSHEXWK(9),DSFWORK(5)       unpack data\n         TR    DSHEXWK,CSHEXTR             make printable\n         MVC   DSMSG+19+21(4),DSHEXWK+4    return code\n         SPACE 1\n         UNPK  DSHEXWK(5),S99ERROR(3)      s99error code\n         TR    DSHEXWK,CSHEXTR             make printable\n         MVC   DSMSG+19+36(4),DSHEXWK\n         SPACE 1\n         UNPK  DSHEXWK(5),S99INFO(3)       s99info code\n         TR    DSHEXWK,CSHEXTR             make printable\n         MVC   DSMSG+19+50(4),DSHEXWK\n         SPACE 1\n         AWSMSG ,                  write the message\n         SPACE 1\n         CH    R4,CSH4             RC = 4?\n         BNE   DYNERXIT            NO, BRANCH\n         CLC   S99ERROR,=X'1708'   ERROR = 1708?\n         BNE   DYNERXIT            NO, BRANCH\n         CLC   S99INFO,=X'0002'    INFO = 0002?\n         BNE   DYNERXIT            NO, BRANCH\n         AWSMSG 181E,'Dataset could not be found'\n         SPACE 1\nDYNERXIT DS    0H                  function exit\n         SLR   R15,R15             zero return code\n         AWSEXIT ,\n         SPACE 1\n         LTORG ,\n         DROP\n         TITLE 'AWSHDR - Header labels'\n***********************************************************************\n* AWSHDR - header labels                                              *\n*          msg AWS19n                                                 *\n***********************************************************************\n         SPACE 1\nAWSHDR   CSECT ,                   header labels\n         AWSENTRY ,\n         SPACE 1\n         SLR   R15,R15             zero return code for now\n         CLI   DSUSESL,C'N'        suppress standard labels?\n         BE    HDRLBXIT            yes, branch\n         TM    DSFLAGS,DSFVOLF     vol1 written previously?\n         BO    HDRLB100            yes, branch\n         L     R3,DSBUFTP          Next text location\n         USING AWSREC,R3           Addressability\n         MVC   AWSLENC,CSH80       block length\n         AWSSWAP ,                 set sizes\n         MVC   AWSFLGS,CSXA000     data follows\n         LA    R3,6(,R3)           position beyond aws cb\n         ST    R3,DSBUFTP          set current text pointer\n         TM    DSFLAGS,DSFRECV     variable length output?\n         BZ    HDRLB010            no, branch\n         AWSCALL AWSEPUT           write the aws cb\n         L     R3,DSBUFTP          current buffer pointer\n         USING AWSDBLK,R3          data block origin\n         SPACE 1\nHDRLB010 DS    0H                  build vol1 label\n         MVC   DSVOL1SR,DSTVOL     set volser into label\n         MVC   DSVOL1OW,DSOWNER    set owner\n         MVC   AWSDBLK(80),DSVOL1  VOL1 LABEL\n         LA    R3,80(,R3)          Next data record origin\n         ST    R3,DSBUFTP          Set current text pointer\n         TM    DSFLAGS,DSFRECV     Variable length output?\n         BZ    HDRLB100            No, branch\n         AWSCALL AWSEPUT           Write the block\n         SPACE 1\nHDRLB100 DS    0H                  HDR1 LABEL\n         L     R3,DSBUFTP          Next text location\n         USING AWSREC,R3\n         MVC   AWSLENC,CSH80       block length\n         AWSSWAP ,                 set sizes\n         MVC   AWSFLGS,CSXA000     data follows\n         MVC   DSHDR1SR,DSTVOL     volser\n         LA    R3,6(,R3)           position beyond aws cb\n         ST    R3,DSBUFTP          set current text pointer\n         TM    DSFLAGS,DSFRECV     variable length output?\n         BZ    HDBLB110            no, branch\n         AWSCALL AWSEPUT           write the aws cb\n         L     R3,DSBUFTP          current buffer pointer\n         USING AWSDBLK,R3          data block origin\n         SPACE 1\nHDBLB110 DS    0H                  build hdr1\n         LH    R1,DSFILECT         file sequence number\n         LA    R1,1(,R1)           ...increment\n         STH   R1,DSFILECT         ...and save\n         CVD   R1,DSDWORK          convert to decimal\n         MVC   DSXL16(6),=X'F02020202020' edit mask\n         ED    DSXL16(6),DSDWORK+5\n         MVC   DSHDR1SQ,DSXL16+2   set file number into HDR1\n         OI    DSHDR1SQ+L'DSHDR1SQ-1,C'0'\n         MVC   DSHDR1NM,DSTDSN     Set dataset name into label\n         SPACE 1\n         TIME  DEC                 get todays date\n         ST    R1,DSFWORK          set into work area\n         MVC   DSXL16(8),=X'F020202020202020' edit mask\n         UNPK  DSXL16(8),DSFWORK   unpack date\n         OI    DSXL16+7,C'0'       valid last digit\n         MVC   DSHDR1CD,DSXL16+2   set into header\n         MVI   DSHDR1CD,C'0'       assume 2000-2099 for now\n         CLI   DSXL16+2,C'0'       1900-1999?\n         BNE   *+8                 no, branch\n         MVI   DSHDR1CD,C' '       else so indicate\n         SPACE 1\n         MVC   AWSDBLK(80),DSHDR1  HDR1 label\n         LA    R3,80(,R3)          Next data record origin\n         ST    R3,DSBUFTP          Set current text pointer\n         TM    DSFLAGS,DSFRECV     Variable length output?\n         BZ    HDRLB200            No, branch\n         AWSCALL AWSEPUT           Write the block\n         SPACE 1\nHDRLB200 DS    0H                  HDR2 label\n         L     R3,DSBUFTP          Next text location\n         USING AWSREC,R3\n         MVC   AWSLENC,CSH80       block length\n         AWSSWAP ,                 set sizes\n         MVC   AWSFLGS,CSXA000     data follows\n         LA    R3,6(,R3)           position beyond aws cb\n         ST    R3,DSBUFTP          new current text pointer\n         TM    DSFLAGS,DSFRECV     variable length output?\n         BZ    HDRLB210            no, branch\n         AWSCALL AWSEPUT           write the aws cb\n         L     R3,DSBUFTP          current buffer pointer\n         USING AWSDBLK,R3          data block\n         SPACE 1\nHDRLB210 DS    0H                  build hdr2\n         LA    R15,AWSUT1          awsut1 DCB location\n         USING IHADCB,R15          addressability\n         MVI   DSHDR2RF,C'U'       assume recfm=u for now\n         TM    DCBRECFM,DCBRECU    recfm=u?\n         BO    HDRLB220            yes, branch\n         MVI   DSHDR2RF,C'F'       assume fixed for now\n         TM    DCBRECFM,DCBRECF    recfm=f?\n         BO    HDRLB220            yes, branch\n         MVI   DSHDR2RF,C'V'       else assume variable\n         EJECT\nHDRLB220 DS    0H\n         SLR   R0,R0               clear register\n         ICM   R0,3,DCBBLKSI       blocksize\n         CVD   R0,DSDWORK          convert to decimal\n         MVC   DSXL16(6),=X'F02020202020'\n         ED    DSXL16(6),DSDWORK+5\n         MVC   DSHDR2BL,DSXL16+1\n         OI    DSHDR2BL+L'DSHDR2BL-1,C'0'\n         SPACE 1\n         SLR   R0,R0               clear register\n         ICM   R0,3,DCBLRECL       lrecl\n         CVD   R0,DSDWORK          convert to decimal\n         MVC   DSXL16(6),=X'F02020202020'\n         ED    DSXL16(6),DSDWORK+5\n         MVC   DSHDR2RL,DSXL16+1\n         OI    DSHDR2RL+L'DSHDR2RL-1,C'0'\n         SPACE 1\n         MVI   DSHDR2CC,C'A'       assume asa for now\n         TM    DCBRECFM,DCBRECCA   asa carriage control?\n         BO    HDRLB230            yes, branch\n         MVI   DSHDR2CC,C'M'       assume machine for now\n         TM    DCBRECFM,DCBRECCM   machine carriage control?\n         BO    HDRLB230            yes, branch\n         MVI   DSHDR2CC,C' '       else no carriage control\n         SPACE 1\nHDRLB230 DS    0H                  handle spanned and blocking\n         MVI   DSHDR2BA,C'S'       assume spanned or standard\n         TM    DCBRECFM,DCBRECSB   spanned or standard?\n         BO    HDRLB240            yes, branch\n         MVI   DSHDR2BA,C'B'       assume blocked for now\n         TM    DCBRECFM,DCBRECBR   blocked?\n         BO    HDRLB240            yes, branch\n         MVI   DSHDR2BA,C' '       else unblocked\n         EJECT\nHDRLB240 DS    0H\n         MVC   DSHDR2JB,DSJOBNM    Set job name\n         MVC   DSHDR2ST,DSSTEPNM   Set step name\n         SPACE 1\n         SLR   R0,R0               clear register\n         ICM   R0,3,AWSUT1+(DCBBLKSI-IHADCB) blocksize\n         CVD   R0,DSDWORK          convert to decimal\n         MVC   DSXL16(12),=X'F02120202020202020202020'\n         ED    DSXL16(12),DSDWORK+2 edit\n         OI    DSXL16+11,C'0'      make printable\n         MVC   DSHDR2LB,DSXL16+2   set large blocksize\n         SPACE 1\n         MVC   AWSDBLK(80),DSHDR2  HDR2 label\n         LA    R3,80(,R3)          Next data record origin\n         ST    R3,DSBUFTP          Set current text pointer\n         TM    DSFLAGS,DSFRECV     Variable length output?\n         BZ    HDRLB250            No, branch\n         AWSCALL AWSEPUT           Write the block\n         SPACE 1\nHDRLB250 DS    0H                  Write labels to log\n         AWSMSG ,                  blank line\n         TM    DSFLAGS,DSFVOLF     volume header already written?\n         BO    HDRLB260            yes, branch\n         OI    DSFLAGS,DSFVOLF     indicate vol1 has been written\n         MVC   DSMSG+1(7),=C'AWS190I'\n         MVC   DSMSG+19(80),DSVOL1 vol1 label\n         AWSMSG ,\n         SPACE 1\nHDRLB260 DS    0H                  log hdr1 and hdr2\n         MVC   DSMSG+1(7),=C'AWS191I'\n         MVC   DSMSG+19(80),DSHDR1 hdr1 label\n         AWSMSG ,\n         MVC   DSMSG+1(7),=C'AWS192I'\n         MVC   DSMSG+19(80),DSHDR2 hdr2 label\n         AWSMSG ,\n         AWSMSG ,                  blank line\n         SPACE 1\n         AWSCALL AWSMARK           write tape mark\n         SPACE 1\nHDRLBXIT DS    0H                  exit\n         AWSEXIT ,\n         SPACE 1\n         LTORG ,\n         DROP\n         TITLE 'AWSTLR - Write trailer labels'\n***********************************************************************\n* AWSTLR - Write trailer labels                                       *\n*          msg AWS20n                                                 *\n***********************************************************************\n         SPACE 1\nAWSTLR   CSECT ,                   Write trailer labels\n         AWSENTRY ,\n         SPACE 1\n         CLI   DSUSESL,C'N'        suppress standard labels?\n         BE    TLRLBXIT            yes, branch\n         L     R3,DSBUFTP          current text pointer\n         USING AWSREC,R3           addressability\n         MVC   AWSLENC,CSH80       BLOCK LENGTH\n         AWSSWAP ,                 swap byte order, set size\n         MVC   AWSFLGS,CSXA000     DATA FOLLOWS\n         LA    R3,6(,R3)           next output text\n         ST    R3,DSBUFTP          set current pointer\n         TM    DSFLAGS,DSFRECV     variable length output?\n         BZ    TLRLB010            no, branch\n         AWSCALL AWSEPUT           write the aws cb\n         L     R3,DSBUFTP          current text pointer\n         USING AWSDBLK,R3          ... addressability\n         SPACE 1\nTLRLB010 DS    0H                  eof1\n         MVC   DSEOF1,DSHDR1       COPY HDR1 INTO EOF1\n         MVC   DSEOF1(3),=C'EOF'\n         SPACE 1\n         MVC   DSXL16(12),=X'F02020202020202020202020'\n         ED    DSXL16(12),DSBLKCNT\n         OI    DSXL16+11,C'0'\n         MVC   DSEOF1BL,DSXL16+6   low  block count\n         MVC   DSEOF1BH,DSXL16+2   high block count\n         MVC   AWSDBLK(80),DSEOF1  EOF1 label\n         LA    R3,80(,R3)          next text pointer\n         ST    R3,DSBUFTP          ...and save\n         TM    DSFLAGS,DSFRECV     variable length output?\n         BZ    TLRLB200            no, branch\n         AWSCALL AWSEPUT           write the output text\n         L     R3,DSBUFTP          current buffer location\n         USING AWSREC,R3           addressability\n         SPACE 1\nTLRLB200 DS    0H                  TLR2 LABEL\n         MVC   AWSLENC,CSH80       BLOCK LENGTH\n         AWSSWAP ,                 swap byte order, set size\n         MVC   AWSFLGS,CSXA000     DATA FOLLOWS\n         LA    R3,6(,R3)           next current text pointer\n         ST    R3,DSBUFTP          ... make current\n         TM    DSFLAGS,DSFRECV     variable length output?\n         BZ    TLRLB210            no, branch\n         AWSCALL AWSEPUT           write aws cb\n         L     R3,DSBUFTP          current text pointer\n         USING AWSDBLK,R3          ... addressability\n         SPACE 1\nTLRLB210 DS    0H                  label text\n         MVC   DSEOF2,DSHDR2       copy hdr2 to eof2\n         MVC   DSEOF2(3),=C'EOF'\n         MVC   AWSDBLK(80),DSEOF2  EOF2 label\n         LA    R3,80(,R3)          current text pointer\n         ST    R3,DSBUFTP          ... make current\n         TM    DSFLAGS,DSFRECV     variable length output?\n         BZ    TLRLB220            no, branch\n         AWSCALL AWSEPUT           write text\n         SPACE 1\nTLRLB220 DS    0H\n         AWSMSG ,                  blank line\n         MVC   DSMSG+1(7),=C'AWS200I'\n         MVC   DSMSG+19(80),DSEOF1 EOF1 LABEL\n         AWSMSG ,\n         MVC   DSMSG+1(7),=C'AWS201I'\n         MVC   DSMSG+19(80),DSEOF2 EOF2 LABEL\n         AWSMSG ,\n         AWSMSG ,                  blank line\n         SPACE 1\n         AWSCALL AWSMARK           write tape mark\n         AWSMSG ,                  blank line\n         AWSMSG ,\n         SPACE 1\nTLRLBXIT DS    0H                  exit\n         SLR   R15,R15             zero return code\n         AWSEXIT ,\n         SPACE 1\n         LTORG ,\n         DROP  ,\n         TITLE 'AWSPRNT - Write to AWSPRINT log'\n***********************************************************************\n* AWSPRNT - Write contents of DSBUF to AWSPRINT log                   *\n*           msg AWS21n                                                *\n***********************************************************************\n         SPACE 1\nAWSPRNT  CSECT ,                   Print Function\n         AWSENTRY ,                Function Entry\n         SPACE 1\n         AP    DSLINECT,CSP1       increment line count\n         CP    DSLINECT,=P'60'     page eject needed?\n         BNH   PRINT010            no, branch\n         ZAP   DSLINECT,CSP1\n         AP    DSPAGECT,CSP1       increment page count\n         MVC   DSPAGE,=X'40202120' page mask\n         ED    DSPAGE,DSPAGECT     insert page count\n         PUT   AWSPRINT,DSHEADER   write header\n         PUT   AWSPRINT,DSMSG1     double space\n         SPACE 1\n         MVC   DSMSG1+1(22),=C'AWS210I  Execution Log'\n         PUT   AWSPRINT,DSMSG1\n         MVI   DSMSG1+6,C'1'\n         MVI   DSMSG1+10,C'-'      fill with dashes\n         MVC   DSMSG1+11(L'DSMSG1-11),DSMSG1+10\n         PUT   AWSPRINT,DSMSG1\n         SPACE 1\nPRINT010 DS    0H                  write user specified line\n         PUT   AWSPRINT,DSMSG      write record\n         MVC   DSMSG,CSBLNKS       clear print buffer\n         MVC   DSMSG1,CSBLNKS\n         SLR   R15,R15             zero return code\n         SPACE 1\n         AWSEXIT ,                 Return to caller\n         SPACE 1\n         LTORG ,\n         DROP ,\n         TITLE 'AWSMARK - Output a tape mark'\n***********************************************************************\n* AWSMARK - Output a tape mark                                        *\n*           msg AWS22n                                                *\n***********************************************************************\n         SPACE 1\nAWSMARK  CSECT ,                   Write a tape mark\n         AWSENTRY ,\n         SPACE 1\n         L     R3,DSBUFTP          Next text location\n         USING AWSREC,R3\n         XC    AWSLENC,AWSLENC     zero block length\n         AWSSWAP ,                 set sizes\n         MVC   AWSFLGS,CSX4000     tape mark\n         SPACE 1\n         LA    R3,6(,R3)           Next data record origin\n         ST    R3,DSBUFTP          Set current text pointer\n         TM    DSFLAGS,DSFRECV+DSFFLUSH write required?\n         BZ    MARK010             No, branch\n         AWSCALL AWSEPUT           Write the block\n         SPACE 1\nMARK010  DS    0H                  return\n         AWSMSG 220I,'*** tape mark ***'\n         SLR   R15,R15             zero return code\n         AWSEXIT ,\n         SPACE 1\n         LTORG ,\n         DROP  ,\n         TITLE 'AWSEPUT - Write text to AWSFILE output'\n***********************************************************************\n* AWSEPUT - Write output text                                         *\n*           msg AWS23n                                                *\n***********************************************************************\n         SPACE 1\nAWSEPUT  CSECT ,\n         AWSENTRY ,\n         SPACE 1\n         LA    R3,DSBUFFER         output buffer origin\n         TM    DSFLAGS,DSFRECV     variable length output?\n         BZ    EPUT100             no, branch\n         SPACE 1\n***********************************************************************\n* awsfile output is variable (recfm=v) test... good for debugging.    *\n***********************************************************************\n         SPACE 1\nEPUT010  DS    0H                  handle variable length output\n         L     R4,DSBUFTP          end of text\n         SR    R4,R3               r4 = length of text\n         BNP   EPUT900             if zero, done, branch\n         SLR   R2,R2               clear register\n         ICM   R2,3,AWSFILE+(DCBLRECL-IHADCB) r2 = awsfile lrecl\n         SH    R2,CSH4             allow room for rdw\n         CR    R4,R2               text at or exceeds lrecl?\n         BL    *+6                 no, branch\n         LR    R4,R2               else length = lrecl - 4\n         SPACE 1\n         LA    R2,DSBUFFER         buffer origin\n         AL    R2,=A(BUFSIZE*2)    offset to variable length buffer\n         LA    R0,4(,R2)           target of move\n         LR    R1,R4               length of data to write\n         LR    R14,R3              origin of data\n         LR    R15,R4              length of source\n         MVCL  R0,R14              copy data to variable buffer\n         LA    R1,4(,R4)           length of variable record\n         STCM  R1,3,0(R2)          set length into rdw\n         XC    2(2,R2),2(R2)       clear rdw flags\n         PUT   AWSFILE,(R2)        write the record\n         SPACE 1\n         ALR   R3,R4               position at next origin\n         B     EPUT010             continue until done\n         EJECT\n***********************************************************************\n* awsfile output is undefined (recfm=u) text... preferred.            *\n***********************************************************************\n         SPACE 1\nEPUT100  DS    0H                  handle undefined length output\n         TM    AWSFILE+(DCBRECFM-IHADCB),DCBRECU recfm=u?\n         BNO   EPUT200             no, must be recfm=f, branch\n         SPACE 1\nEPUT110  DS    0H\n         L     R4,DSBUFTP          end of current text\n         SR    R4,R3               r4=length of text\n         BNP   EPUT900             if zero, done, branch\n         SLR   R2,R2               clear register\n         ICM   R2,3,AWSFILE+(DCBBLKSI-IHADCB) r2 = awsfile blksize\n         CR    R4,R2               text at or exceeds blksize?\n         BL    EPUT130             no, branch\n         LR    R4,R2               else length = blksize\n         SPACE 1\nEPUT120  DS    0H                  write undefined length record\n         STCM  R4,3,AWSFILE+(DCBLRECL-IHADCB)  set length into dcb\n         PUT   AWSFILE,(R3)        write the text\n         SPACE 1\n         ALR   R3,R4               position at next origin\n         B     EPUT110             continue writing all possible\n         SPACE 1\nEPUT130  DS    0H                  short undefined block found\n         TM    DSFLAGS,DSFFLUSH    flush requested?\n         BO    EPUT120             else write short block\n         LA    R1,DSBUFFER         output buffer origin\n         CR    R1,R3               wrote from origin?\n         BNL   EPUT900             yes, branch\n         LA    R0,DSBUFFER         target of move\n         LR    R1,R4               length of move\n         LR    R14,R3              source of move\n         LR    R15,R4              length of move\n         MVCL  R0,R14              copy short block to buffer origin\n         LA    R3,DSBUFFER         buffer origin\n         ALR   R4,R3               offset to end of short block\n         ST    R4,DSBUFTP          set new next pointer\n         B     EPUTXIT\n         EJECT\n***********************************************************************\n* awsfile output is fixed length (recfm=f) (folded) text... grrr.     *\n***********************************************************************\n         SPACE 1\nEPUT200  DS    0H                  handle fixed length output\n         L     R4,DSBUFTP          end of current text\n         SR    R4,R3               r4=length of text\n         BNP   EPUT900             if zero, done, branch\n         SLR   R2,R2               clear register\n         ICM   R2,3,AWSFILE+(DCBLRECL-IHADCB) r2 = awsfile lrecl\n         CR    R4,R2               text at or exceeds lrecl?\n         BL    EPUT220             no, branch\n         LR    R4,R2               else length = blksize\n         SPACE 1\nEPUT210  DS    0H                  write undefined length record\n         PUT   AWSFILE,(R3)        write the text\n         SPACE 1\n         ALR   R3,R4               position at next origin\n         B     EPUT200             continue writing all possible\n         SPACE 1\nEPUT220  DS    0H                  short undefined block found\n         TM    DSFLAGS,DSFFLUSH    flush requested?\n         BO    EPUT230             else write short block\n         LA    R1,DSBUFFER         output buffer origin\n         CR    R1,R3               wrote from origin?\n         BNL   EPUT900             yes, branch\n         LA    R0,DSBUFFER         target of move\n         LR    R1,R4               length of move\n         LR    R14,R3              source of move\n         LR    R15,R4              length of move\n         MVCL  R0,R14              copy short block to buffer origin\n         LA    R3,DSBUFFER         buffer origin\n         ALR   R4,R3               offset to end of short block\n         ST    R4,DSBUFTP          set new next pointer\n         B     EPUTXIT\n         SPACE 1\nEPUT230  DS    0H                  flush short text\n         LA    R2,DSBUFFER         target of move\n         AL    R2,=A(BUFSIZE*2)    offset to variable length buffer\n         LR    R0,R2               target of move\n         SLR   R1,R1               clear high order nibbles\n         ICM   R1,3,AWSFILE+(DCBLRECL-IHADCB) length of target\n         LR    R14,R3              source of move\n         LR    R15,R4              length of source\n         ICM   R15,8,=X'20'        padding required by VTT2TAPE\n         MVCL  R0,R14              copy and pad with nulls short text\n         PUT   AWSFILE,(R2)        write short text\n         LR    R0,R2               buffer location\n         SLR   R1,R1               clear high order nibbles\n         ICM   R1,3,AWSFILE+(DCBLRECL-IHADCB) length of target\n         SLR   R15,R15             zero length source\n         ICM   R15,8,=X'20'        padding required b y vtt2tape\n         MVCL  R0,R14              propogate through entire record\n         PUT   AWSFILE,(R2)\n         SPACE 1\nEPUT900  DS    0H                  all data has been written\n         LA    R0,DSBUFFER         buffer origin\n         ST    R0,DSBUFTP          set current text pointer\n         SPACE 1\nEPUTXIT  DS    0H                  return\n         NI    DSFLAGS,255-DSFFLUSH reset forced flush flag\n         SLR   R15,R15             zero return code\n         AWSEXIT ,\n         SPACE 1\n         LTORG ,\n         DROP\n         TITLE 'AWSICOPY - copy from aws input'\n***********************************************************************\n* AWSICOPY - copy from aws input dataset (awsfile)                    *\n*            msg AWS24n                                               *\n***********************************************************************\n         SPACE 1\nAWSICOPY CSECT ,                   copy from aws input dataset\n         AWSENTRY ,\n         SPACE 1\n         ZAP   DSIBLKCT,=P'0'      ZERO BLOCK COUNT\n         ZAP   DSIRECCT,=P'0'      ... AND RECORD COUNT\n         SPACE 1\n         LA    R5,AWSUT3           input dcb location\n         USING IHADCB,R5           addressability\n         MVC   DCBDDNAM,DSOUTDD    set ddname\n         SLR   R0,R0               clear register\n         STCM  R0,3,DCBLRECL       clear previous lrecl\n         STCM  R0,3,DCBBLKSI       clear previous blksize\n         SPACE 1\n         CLI   DSRECFM+1,C'S'      spanned records?\n         BE    ICOPY010            yes, branch\n         CLC   =C'IEBCOPY',DSLODPGM iebcopy load?\n         BE    ICOPY010            yes, branch\n         RDJFCB AWSUT3,MF=(E,DSRDJFCB) read the jfcb\n         SPACE 1\n         ICM   R0,3,JFCLRECL       lrecl specified in jcl?\n         BZ    *+8                 no, branch\n         STCM  R0,3,DCBLRECL       else set into dcb\n         SPACE 1\n         ICM   R0,3,JFCBLKSI       blksize specified in jcl?\n         BZ    *+8                 no, branch\n         STCM  R0,3,DCBBLKSI       else set into dcb\n         SPACE 1\nICOPY010 DS    0H                  default from label if needed\n         ICM   R0,3,DCBLRECL       lrecl specified?\n         BNZ   *+10                no, branch\n         MVC   DCBLRECL,DSLRECL    else default from tape label\n         SPACE 1\n         ICM   R0,3,DCBBLKSI       blocksize specified?\n         BNZ   *+10                no, branch\n         MVC   DCBBLKSI,DSBLKSIZ   else default from tape label\n         SPACE 1\n         OI    DCBRECFM,DCBRECU    assume undefined for now\n         CLI   DSRECFM,C' '        recfm specified?\n         BNH   ICOPY020            no, branch\n         CLI   DSRECFM,C'U'        label undefined?\n         BE    ICOPY020            yes, branch\n         NI    DCBRECFM,255-DCBRECU reset bits\n         OI    DCBRECFM,DCBRECF    assume fixed for now\n         CLI   DSRECFM,C'F'        label fixed?\n         BE    ICOPY020            yes, branch\n         NI    DCBRECFM,255-DCBRECU reset bits\n         OI    DCBRECFM,DCBRECV    else must be variable\n         SPACE 1\nICOPY020 DS    0H                  set blocked attribute\n         CLI   DSRECFM+1,C' '      blocked specified?\n         BNH   ICOPY030            no, branch\n         CLI   DSRECFM+1,C'B'      blocked records?\n         BNE   *+8                 no, branch\n         OI    DCBRECFM,DCBRECBR   else so indicate\n         SPACE 1\n         CLI   DSRECFM+1,C'S'      spanned records?\n         BNE   *+8                 no, branch\n         OI    DCBRECFM,DCBRECSB   else so indicate\n         SPACE 1\nICOPY030 DS    0H                  allocate files if needed\n         CLI   DSLODPGM,C' '       load program specified?\n         BNH   ICOPY070            no, branch\n         MVC   DCBDDNAM,=CL8'AWSTEMP' temporary file\n         SPACE 1\n         AWSCALL AWSALCI           allocate input dataset\n         BNZ   ICOPYXIT\n         SPACE 1\n         AWSCALL AWSALCT           allocate work dataset\n         BNZ   ICOPYXIT\n         SPACE 1\n         AWSCALL AWSALCS           allocate sysin dataset\n         BNZ   ICOPYXIT\n         SPACE 1\n         AWSCALL AWSALCP           allocate sysprint dataset\n         BNZ   ICOPYXIT\n         SPACE 1\n         OPEN  (SYSIN,(OUTPUT)),MF=(E,DSOPENL) open sysin for output\n         SPACE 1\n         TM    SYSIN+(DCBOFLGS-IHADCB),DCBOFOPN open ok?\n         BO    ICOPY040            yes, branch\n         AWSMSG 241E,'SYSIN open for output failed'\n         LA    R15,8               set return code\n         B     ICOPYXIT\n         SPACE 1\nICOPY040 DS    0H                  determine type of unload\n         CLC   =C'IEBCOPY',DSLODPGM iebcopy unload?\n         BE    ICOPY050            yes, branch\n         AWSMSG 242E,'Unrecognized load program specified'\n         LA    R15,8               unrecognized unload pgm\n         B     ICOPYXIT            exit\n         SPACE 1\nICOPY050 DS    0H                  iebcopy load request\n         MVC   DSCARD,CSBLNKS      clear\n         MVC   DSCARD(15),=C' C I=AWSTEMP,O='\n         MVC   DSCARD+15(8),DSOUTDD set OUTDD statement\n         CLI   DSOUTDD,C' '        outdd= keyword present?\n         BH    ICOPY060            yes, branch\n         MVC   DSCARD+15(8),=CL8'AWSUT1' else use default\n         SPACE 1\nICOPY060 DS    0H                  write control statement\n         PUT   SYSIN,DSCARD\n         SPACE 1\n         CLOSE SYSIN,MF=(E,DSCLOSEL) close file\n         FREEPOOL SYSIN            release buffer pool\n         SPACE 1\nICOPY070 DS    0H                  open files\n         RDJFCB AWSUT3,MF=(E,DSRDJFCB) read the jfcb\n         SPACE 1\n         AWSMSG ,                  blank line\n         MVC   DSMSG+1(7),=C'AWS240I'\n         MVC   DSMSG+19(31),=C'Writing to dataset            :'\n         MVC   DSMSG+51(44),JFCBDSNM\n         AWSMSG ,\n         SPACE 1\n         TM    DCBRECFM,DCBRECSB   spanned blocks?                      panned b\n         BZ    ICOPY090            no, branch\n         CLC   =C'IEBCOPY',DSLODPGM iebcopy load?\n         BE    ICOPY080            yes, bypass warning, branch\n         AWSMSG ,\n         AWSMSG 24BW,'*** Warning, spanned formats not supported, force*\n               d to recfm=u'\n         AWSMSG 24CI,'*** Note that IEBCOPY can process unloaded PDS as*\n                recfm=u'\n         AWSMSG ,\nICOPY080 DS    0H                  spanned, force to RECFM=U\n         OI    DCBRECFM,DCBRECU    indciate undefined lrecl\n         NI    DCBRECFM,255-DCBRECSB reset spanned indicator\n         SPACE 1\nICOPY090 DS    0H\n         OPEN  (AWSUT3,(OUTPUT)),MF=(E,DSOPENL)\n         TM    DCBOFLGS,DCBOFOPN   open successful?\n         BO    ICOPY100            yes, branch\n         AWSMSG 243E,'Open output file for import failed'\n         LA    R15,8               return code\n         B     ICOPYXIT            exit\n         SPACE 1\nICOPY100 DS    0H                  produce messages\n         SLR   R0,R0               clear register\n         ICM   R0,3,DCBLRECL       load blocksize\n         CVD   R0,DSDWORK          convert to decimal\n         MVC   DSXL16(6),=X'F02020202120'\n         ED    DSXL16(6),DSDWORK+5 edit\n         MVI   DSXL16+5,C'0'       make printable\n         MVC   DSMSG+1(7),=C'AWS244I'\n         MVC   DSMSG+19(31),=C'Output dataset lrecl          :'\n         MVC   DSMSG+51(5),DSXL16+1 set blksize into message\n         AWSMSG ,                  write message\n         SPACE 1\n         SLR   R0,R0               clear register\n         ICM   R0,3,DCBBLKSI       load blocksize\n         CVD   R0,DSDWORK          convert to decimal\n         MVC   DSXL16(6),=X'F02020202120'\n         ED    DSXL16(6),DSDWORK+5 edit\n         MVI   DSXL16+5,C'0'       make printable\n         MVC   DSMSG+1(7),=C'AWS245I'\n         MVC   DSMSG+19(31),=C'Output dataset blksize        :'\n         MVC   DSMSG+51(5),DSXL16+1 set blksize into message\n         AWSMSG ,                  write message\n         SPACE 1\n         MVC   DSMSG+1(7),=C'AWS246I'\n         MVC   DSMSG+19(31),=C'Output dataset recfm          :'\n         NI    DSFLAGS,255-DSFRECV reset variable length flag\n         MVI   DSMSG+51,C'U'       assume recfm=u for now\n         TM    DCBRECFM,DCBRECU    recfm=u?\n         BO    ICOPY110            yes, branch\n         MVI   DSMSG+51,C'F'       assume fixed for now\n         TM    DCBRECFM,DCBRECF    recfm=f?\n         BO    ICOPY110            yes, branch\n         MVI   DSMSG+51,C'V'       else assume variable\n         OI    DSFLAGS,DSFRECV     set variable length flag\nICOPY110 DS    0H\n         MVI   DSMSG+53,C'A'       assume asa for now\n         TM    DCBRECFM,DCBRECCA   asa carriage control?\n         BO    ICOPY120            yes, branch\n         MVI   DSMSG+53,C'M'       assume machine for now\n         TM    DCBRECFM,DCBRECCM   machine carriage control?\n         BO    ICOPY120            yes, branch\n         MVI   DSMSG+53,C' '       else no carriage control\n         SPACE 1\nICOPY120 DS    0H                  handle spanned and blocking\n         MVI   DSMSG+52,C'S'       assume spanned or standard\n         TM    DCBRECFM,DCBRECSB   spanned or standard?\n         BO    ICOPY130            yes, branch\n         MVI   DSMSG+52,C'B'       assume blocked for now\n         TM    DCBRECFM,DCBRECBR   blocked?\n         BO    ICOPY130            yes, branch\n         MVI   DSMSG+52,C' '       else unblocked\n         SPACE 1\nICOPY130 DS    0H                  produce recfm message\n         CLI   DSMSG+52,C' '       not blocked or spanned?\n         BNE   ICOPY140            no, branch\n         MVC   DSMSG+52(1),DSMSG+53\n         MVI   DSMSG+53,C' '\nICOPY140 DS    0H                  write recfm\n         AWSMSG ,                  write message\n         SPACE 1\nICOPY150 DS    0H                  copy aws input text to output file\n         AWSCALL AWSIGET           retrieve a block\n         BNZ   ICOPYEOF            if eof, branch\n         L     R3,DSBUFTP          block location\n         CLC   CSX4000,4(R3)       tape mark read?\n         BE    ICOPYE10            yes, simulate eof, branch\n         AP    DSIBLKCT,=P'1'      increment block count\n         SLR   R4,R4               clear register\n         ICM   R4,3,0(R3)          size of aws block\n         lr    r14,r4              future reference\n         ALR   R4,R3               end of aws block\n         LA    R3,6(,R3)           position beyond aws header\n         TM    DSFLAGS,DSFRECV     variable length records?\n         BZ    ICOPY160            no, branch\n         SLR   R4,R4               clear register\n         ICM   R4,3,0(R3)          block length from rdw\n         ALR   R4,R3               end of block\n         LA    R3,4(,R3)           position beyond block rdw\n         SPACE 1\nICOPY160 DS    0H                  copy logical records to output\n         CLR   R3,R4               reached end of block?\n         BNL   ICOPY150            yes, do next one, branch\n         TM    DCBRECFM,DCBRECU    undefined output?\n         BNO   *+8                 no, branch\n         STCM  R14,3,DCBLRECL      else set lrecl\n         PUT   AWSUT3,(R3)         else write logical record\n         AP    DSIRECCT,=P'1'      increment record count\n         TM    DSFLAGS,DSFRECV     variable length records?\n         BO    ICOPY170            yes, branch\n         AH    R3,DCBLRECL         position at next logical block\n         B     ICOPY160            continue\n         SPACE 1\nICOPY170 DS    0H                  position at next variable length rec\n         SLR   R0,R0               clear register\n         ICM   R0,3,0(R3)          record length\n         ALR   R3,R0               origin of next record\n         B     ICOPY160            continue\n         SPACE 1\nICOPYEOF DS    0H                  eof reached?\n         CH    R15,=H'-4'          eof?\n         BNE   ICOPYXIT            no, error, branch\n         SPACE 1\nICOPYE10 DS    0H                  logical eof detected\n         CLOSE AWSUT3,MF=(E,DSCLOSEL) close file\n         FREEPOOL AWSUT3           release buffers\n         SPACE 1\n         AWSMSG ,                  blank line\n         MVC   DSXL16,=X'40202020202020202020202020202120'\n         ED    DSXL16,DSIBLKCT     edit record count\n         OI    DSXL16+15,C'0'      make last digit printable\n         MVC   DSMSG+1(7),=C'AWS247I' message id\n         MVC   DSMSG+19(31),=C'Total physical aws blocks read:'\n         MVC   DSMSG+51(16),DSXL16 set count into message\n         AWSMSG ,\n         SPACE 1\n         MVC   DSXL16,=X'40202020202020202020202020202120'\n         ED    DSXL16,DSIRECCT     edit record count\n         OI    DSXL16+15,C'0'      make last digit printable\n         MVC   DSMSG+1(7),=C'AWS248I' message id\n         MVC   DSMSG+19(31),=C'Total logical records written :'\n         MVC   DSMSG+51(16),DSXL16 set count into message\n         AWSMSG ,\n         SPACE 1\n***********************************************************************\n* iebcopy                                                             *\n***********************************************************************\n         CLI   DSLODPGM,C' '       load program specified?\n         BNH   ICOPYX00            no, branch\n         SPACE 1\n         AWSMSG ,                  blank line\n         MVC   DCBDDNAM,DSOUTDD    output ddname\n         RDJFCB AWSUT3,MF=(E,DSRDJFCB) read the jfcb\n         MVC   DSMSG+1(7),=C'AWS240I'\n         MVC   DSMSG+19(31),=C'PDS(E) loading to dataset     :'\n         MVC   DSMSG+51(44),JFCBDSNM\n         AWSMSG ,\n         SPACE 1\n         SLR   R1,R1               clear parameter register\n         LINK  EP=IEBCOPY          invoke iebcopy\n         LTR   R15,R15             success?\n         BZ    ICOPYE90            yes, branch\n         AWSMSG 24AE,'IEBCOPY unload failed'\n         LA    R15,8               set return code\n         B     ICOPYXIT            exit\n         SPACE 1\nICOPYE90 DS    0H                  unallocate if needed\n         AWSMSG 249I,'PDS(E) load successful'\n         AWSCALL AWSUNALC          dynamic unallocation\n         SPACE 1\nICOPYX00 DS    0H\n         AWSMSG ,                  blank line\n         SLR   R15,R15             zero return code\n         SPACE 1\nICOPYXIT DS    0H                  return\n         AWSEXIT ,\n         SPACE 1\n         LTORG ,\n         DROP\n         TITLE 'AWSECOPY - copy to aws output'\n***********************************************************************\n* AWSECOPY - copy to aws output dataset (awsfile)                     *\n*            msg AWS25n                                               *\n***********************************************************************\n         SPACE 1\nAWSECOPY CSECT ,                   copy to aws output dataset\n         AWSENTRY ,\n         SPACE 1\n         ZAP   DSBLKCNT,=P'0'      clear block counter\n         SPACE 1\n         MVC   AWSUT1+(DCBDDNAM-IHADCB)(L'DCBDDNAM),=CL8'AWSTEMP'\n         CLI   DSUNLPGM,C' '       unload requested?\n         BH    ECOPY010            yes, use awstemp, branch\n         MVC   AWSUT1+(DCBDDNAM-IHADCB)(L'DCBDDNAM),DSINDD\n         CLI   DSINDD,C' '         dataset already allocated?\n         BH    ECOPY010            yes, use indd argument, branch\n         MVC   AWSUT1+(DCBDDNAM-IHADCB)(L'DCBDDNAM),=CL8'AWSUT1'\n         AWSCALL AWSALCI           else allocate input dataset\n         BNZ   ECOPYXIT            if error, branch\n         SPACE 1\nECOPY010 DS    0H                  dataset is allocated, now open it\n         LA    R0,ECOPYEOF         eof location\n         STCM  R0,7,AWSUT1+(DCBEODA-IHADCB)\n         SLR   R0,R0               clear register\n         STH   R0,AWSUT1+(DCBBLKSI-IHADCB) clear blocksize\n         STH   R0,AWSUT1+(DCBLRECL-IHADCB) clear lrecl\n         OPEN  (AWSUT1,(INPUT)),MF=(E,DSOPENL)    open input dataset\n         TM    AWSUT1+(DCBOFLGS-IHADCB),DCBOFOPN  opened ok?\n         BO    ECOPY020            yes, branch\n         AWSMSG 250E,'Input dataset could not be opened'\n         LA    R15,8               return code\n         B     ECOPYXIT            return\nECOPY020 DS    0H                  write header labels\n         AWSCALL AWSHDR            write header labels\n         BNZ   ECOPYXIT\n         SPACE 1\n         CLOSE AWSUT1,MF=(E,DSCLOSEL)             close the file\n         OI    AWSUT1+(DCBRECFM-IHADCB),DCBRECU   force to recfm=u\n         OPEN  (AWSUT1,(INPUT)),MF=(E,DSOPENL)    reopen\n         TM    AWSUT1+(DCBOFLGS-IHADCB),DCBOFOPN  opened ok?\n         BO    ECOPY030            yes, branch\n         AWSMSG 251E,'Input dataset could not be re-opened'\n         LA    R15,8               return code\n         B     ECOPYXIT            return\n         SPACE 1\nECOPY030 DS    0H                  copy input dataset\n         L     R3,DSBUFTP          current text pointer\n         USING AWSREC,R3           addressability\n         SPACE 1\n         GET   AWSUT1              retrieve a block\n         LR    R4,R1               save location for future reference\n         AP    DSBLKCNT,CSP1       increment block count\n         SLR   R2,R2               clear register\n         ICM   R2,3,AWSUT1+(DCBLRECL-IHADCB) get block length\n         STH   R2,AWSLENC          data block length\n         AWSSWAP ,                 set size and swap bytes\n         MVC   AWSFLGS,CSXA000     DATA FOLLOWS\n         LA    R3,6(,R3)           point beyond aws cb\n         ST    R3,DSBUFTP          ... make it so\n         SPACE 1\n         TM    DSFLAGS,DSFRECV     variable length output?\n         BZ    ECOPY040            no, branch\n         AWSCALL AWSEPUT           else write variable output\n         L     R3,DSBUFTP          new current text pointer\n         USING AWSDBLK,R3          data block addressability\n         SPACE 1\nECOPY040 DS    0H                  copy block into output buffer\n         LR    R0,R3               target of move\n         LR    R1,R2               target length\n         LR    R14,R4              source of move\n         LR    R15,R2              source length\n         MVCL  R0,R14              copy block into text buffer\n         SPACE 1\n         ALR   R3,R2               new current text pointer\n         ST    R3,DSBUFTP          ... make it so\n         SPACE 1\n         LA    R0,DSBUFFER         buffer origin\n         AL    R0,=A(BUFSIZE)      r0 = origin of 2nd buffer\n         CR    R3,R0               text has extended into 2nd buffer?\n         BL    ECOPY050            no, branch\n         AWSCALL AWSEPUT           else write block immediately\n         B     ECOPY030            process next block\n         SPACE 1\nECOPY050 DS    0H                  handle variable case if appropriate\n         TM    DSFLAGS,DSFRECV     variable length output?\n         BZ    ECOPY030            no, process next block, branch\n         AWSCALL AWSEPUT           write the block now\n         B     ECOPY030            process next block\n         EJECT\nECOPYEOF DS    0H                  awsut1 reached eof\n         MVC   DSMSG+1(7),=C'AWS252I' blocks copied message\n         MVC   DSMSG+19(35),=c'Blocks exported into AWS tape file:'\n         MVC   DSMSG+54(12),=X'402020202020202020202120'\n         ED    DSMSG+54(12),DSBLKCNT set count into message\n         OI    DSMSG+65,C'0'\n         AWSMSG ,                  write the message\n         SPACE 1\n         CLOSE AWSUT1,MF=(E,DSCLOSEL) close input file\n         FREEPOOL AWSUT1           release buffers\n         SPACE 1\n         NI    AWSUT1+(DCBRECFM-IHADCB),255-DCBRECU  clear recfm\n         SLR   R0,R0               clear register\n         STH   R0,AWSUT1+(DCBBLKSI-IHADCB) clear blocksize\n         STH   R0,AWSUT1+(DCBLRECL-IHADCB) clear lrecl\n         SPACE 1\n         SLR   R15,R15             zero return code\n         SPACE 1\nECOPYXIT DS    0H                  exit\n         AWSEXIT ,                 return to caller\n         SPACE 1\n         LTORG ,\n         DROP  ,\n         TITLE 'AWSUNALC - Unallocate files'\n***********************************************************************\n* AWSUNALC - Unallocate files                                         *\n*            msg AWS26n                                               *\n***********************************************************************\n         SPACE 1\nAWSUNALC CSECT ,                   Unallocate files\n         AWSENTRY ,\n         SPACE 1\n         TM    DSFLAGS,DSFDYUT1    awsut1 dynamically allocated?\n         BZ    UNALC010            no, branch\n         MVC   DSUDDNM1,=CL8'AWSUT1'\n         LA    R1,DSURBP\n         SVC   99                  release awsut1\n         LTR   R15,R15             ok?\n         BZ    UNALC010            yes, branch\n         LA    R3,DSURB            rb location\n         USING S99RB,R3            input rb addressability\n         LR    R1,R3               set rb location\n         LR    R0,R15              return code\n         AWSCALL AWSDYNE           format dynalloc error messages\n         AWSMSG 260E,'Unallocation of ddname AWSUT1 failed'\n         LA    R15,8               set return code\n         B     UNALCXIT            exit\n         SPACE 1\nUNALC010 DS    0H                  unallocate awstemp\n         TM    DSFLAGS,DSFDYTMP    awstemp dynamically allocated?\n         BZ    UNALC020            no, branch\n         MVC   DSUDDNM1,=CL8'AWSTEMP'\n         LA    R1,DSURBP\n         SVC   99                  release awstemp\n         LTR   R15,R15             ok?\n         BZ    UNALC020            yes, branch\n         LA    R3,DSURB            rb location\n         USING S99RB,R3            input rb addressability\n         LR    R1,R3               set rb location\n         LR    R0,R15              return code\n         AWSCALL AWSDYNE           format dynalloc error messages\n         AWSMSG 261E,'Unallocation of ddname AWSTEMP failed'\n         LA    R15,8               set return code\n         B     UNALCXIT            exit\n         SPACE 1\nUNALC020 DS    0H                  unallocate sysin\n         TM    DSFLAGS,DSFDYSYI    sysinp dynamically allocated?\n         BZ    UNALC030            no, branch\n         MVC   DSUDDNM1,=CL8'SYSIN'\n         LA    R1,DSURBP\n         SVC   99                  release sysin\n         LTR   R15,R15             ok?\n         BZ    UNALC030            yes, branch\n         LA    R3,DSURB            rb location\n         USING S99RB,R3            input rb addressability\n         LR    R1,R3               set rb location\n         LR    R0,R15              return code\n         AWSCALL AWSDYNE           format dynalloc error messages\n         AWSMSG 262E,'Unallocation of ddname AWSTEMP failed'\n         LA    R15,8               set return code\n         B     UNALCXIT            exit\n         SPACE 1\nUNALC030 DS    0H                  unallocate sysprint\n         TM    DSFLAGS,DSFDYSYP    sysinp dynamically allocated?\n         BZ    UNALC040            no, branch\n         MVC   DSUDDNM1,=CL8'SYSPRINT'\n         LA    R1,DSURBP\n         SVC   99                  release sysin\n         LTR   R15,R15             ok?\n         BZ    UNALC040            yes, branch\n         LA    R3,DSURB            rb location\n         USING S99RB,R3            input rb addressability\n         LR    R1,R3               set rb location\n         LR    R0,R15              return code\n         AWSCALL AWSDYNE           format dynalloc error messages\n         AWSMSG 263E,'UNALLOCATION of ddname SYSPRINT failed'\n         LA    R15,8               set return code\n         B     UNALCXIT            exit\n         SPACE 1\nUNALC040 DS    0H                  successful\n         NI    DSFLAGS,255-DSFDYUT1-DSFDYTMP-DSFDYSYI-DSFDYSYP\n         SLR   R15,R15             zero return code\n         SPACE 1\nUNALCXIT DS    0H                  exit\n         AWSEXIT ,\n         SPACE 1\n         LTORG ,\n         DROP  ,\n         TITLE 'AWSSKPTF - skip to file'\n***********************************************************************\n* AWSSKPTF - skip to file                                             *\n*            msg AWS27n                                               *\n***********************************************************************\n         SPACE 1\nAWSSKPTF CSECT ,                   skip to file\n         AWSENTRY ,\n         SPACE 1\n         LH    R3,DSINFLNO         file number requested\n         CLI   DSUSESL,C'N'        standard labels in use?\n         BE    SKPTF010            no, branch\n         MH    R3,=H'3'            multiply by 3 (hdr + data + tlr)\n         SH    R3,=H'2'            header absolute file number\n         SPACE 1\nSKPTF010 DS    0H                  position to absolute file number\n         SLR   R2,R2               tape marks encountered\n         BCTR  R3,0                tape marks needed relative to zero\n         SPACE 1\nSKPTF020 DS    0H                  check position\n         CLR   R2,R3               desired tapemark?\n         BE    SKPTF900            yes, exit\n         SPACE 1\nSKPTF030 DS    0H                  find next tape mark\n         AWSCALL AWSIGET           get a block\n         BNZ   SKPTF040            if error, branch\n         L     R4,DSBUFTP          block location\n         USING AWSREC,R4           addressability\n         CLC   AWSFLGS,CSX4000     tape mark?\n         BNE   SKPTF030            no, continue\n         LA    R2,1(,R2)           increment tape marks found\n         B     SKPTF020            continue\n         SPACE 1\nSKPTF040 DS    0H                  error handler\n         CH    R15,=H'-4'          eof reached?\n         BNE   SKPTFXIT            no, error, branch\n         AWSMSG 270E,'End of tape reached while positioning'\n         LA    R15,8\n         B     SKPTFXIT\n         SPACE 1\nSKPTF900 DS    0H                  good return\n         SLR   R15,R15             zero return code\n         SPACE 1\nSKPTFXIT DS    0H                  exit\n         AWSEXIT ,\n         SPACE 1\n         LTORG ,\n         DROP  ,\n         TITLE 'AWSIMLBL - get label values'\n***********************************************************************\n* AWSIMLBL - get label values                                         *\n*            msg AWS28n, AWS29n, AWS30n                               *\n***********************************************************************\n         SPACE 1\nAWSIMLBL CSECT ,                   process input labels\n         AWSENTRY ,\n         SPACE 1\n         CLI   DSUSESL,C'N'        standard labels expected?\n         BE    ILBL900             no, branch\n         SPACE 1\n         TM    DSFLAGS,DSFVOLF     vol1 encountered previously?\n         BO    ILBL100             yes, branch\n         OI    DSFLAGS,DSFVOLF     else indicate vol1 checked\n         AWSCALL AWSIGET           get a block\n         BNZ   ILBLXIT\n         L     R3,DSBUFTP          current text pointer\n         USING AWSREC,R3           addressability\n         SPACE 1\nILBL010  DS    0H                  check vol1 if present\n         CLC   AWSFLGS,CSXA000     correct flags?\n         BE    ILBL030             yes, branch\n         CLC   AWSFLGS,CSX4000     end of tape?\n         BNE   ILBL020             no, branch\n         AWSMSG 280E,'End of tape reached while positioning'\n         LA    R15,8\n         B     ILBLXIT\nILBL020  DS    0H\n         AWSMSG 281E,'AWSFLGS unexpected value encountered'\n         LA    R15,8\n         B     ILBLXIT\n         SPACE 1\nILBL030  DS    0H                  check vol1 length\n         CLC   =C'HDR1',6(R3)      hdr1 found?\n         BE    ILBL110             yes, branch\n         SLR   R0,R0               clear register\n         ICM   R0,3,AWSLENC        current block length\n         CH    R0,=H'80'           80 bytes?\n         BE    ILBL040             yes, branch\n         AWSMSG 282E,'VOL1 label record length is other than 80 bytes'\n         LA    R15,8\n         B     ILBLXIT\n         SPACE 1\nILBL040  DS    0H                  validate vol1\n         LA    R3,6(,R3)           position at data block\n         CLC   =C'VOL1',0(R3)      vol1 label?\n         BE    ILBL050             yes, branch\n         AWSMSG 283E,'VOL1 label not found'\n         LA    R15,8\n         B     ILBLXIT\n         SPACE 1\nILBL050  DS    0H                  verify volser\n         SPACE 1\n         CLC   DSTVOL,DSVOL1SR-DSVOL1(R3) volser correct?\n         BE    ILBL100             yes, branch\n         AWSMSG 285E,'Incorrect volume serial number encountered'\n         LA    R15,8\n         B     ILBLXIT\n         SPACE 1\nILBL100  DS    0H                  validate hdr1 values\n         AWSCALL AWSIGET           get a block\n         BNZ   ILBLXIT\n         L     R3,DSBUFTP          current text pointer\n         CLC   AWSFLGS,CSXA000     correct flags?\n         BE    ILBL110             yes, branch\n         AWSMSG 286E,'HDR1 AWSFLGS invalid'\n         LA    R15,8\n         B     ILBLXIT\n         SPACE 1\nILBL110  DS    0H                  check lengths\n         SLR   R0,R0               clear register\n         ICM   R0,3,AWSLENC        length of current block\n         CH    R0,=H'80'           80 byte block?\n         BE    ILBL120             yes, branch\n         AWSMSG 287E,'HDR1 length is other than 80 bytes'\n         LA    R15,8\n         B     ILBLXIT             exit\n         SPACE 1\nILBL120  DS    0H                  perform hdr1 checks\n         LA    R3,6(,R3)           position beyond aws control block\n         CLC   =C'HDR1',0(R3)      HDR1 label?\n         BE    ILBL130             yes, branch\n         SH    R3,=H'6'            backup six bytes\n         CLC   =C'VOL1',6(R3)      VOL1 label?\n         BE    ILBL030             yes, branch\n         AWSMSG 288E,'HDR1 label not found'\n         LA    R15,8\n         B     ILBLXIT\n         SPACE 1\nILBL130  DS    0H                  process HDR1 values\n         MVC   DSMSG+1(7),=C'AWS284I'\n         MVC   DSMSG+19(31),=C'AWS HDR1 volume serial number :'\n         MVC   DSMSG+51(6),DSHDR1SR-DSHDR1(R3)\n         AWSMSG ,\n         SPACE 1\n         PACK  DSDWORK,DSHDR1SQ-DSHDR1(4,R3)\n         CVB   R0,DSDWORK          convert seq to binary\n         CH    R0,DSINFLNO         agrees with file number requested?\n         BE    ILBL140             yes, branch\n         AWSMSG 289E,'HDR1 file number disagrees with that expected'\n         LA    R15,8\n         B     ILBLXIT\n         SPACE 1\nILBL140  DS    0H                  validate dataset name\n         MVC   DSTDSN,CSBLNKS      clear\n         MVC   DSOUTDSN,DSINDSN\n         AWSCALL AWSTPDSN          set 17 byte dsn expected\n         MVC   DSMSG+1(7),=C'AWS290I'\n         MVC   DSMSG+19(31),=C'Requested 44 byte dataset name:'\n         MVC   DSMSG+51(44),DSINDSN\n         AWSMSG ,\n         SPACE 1\n         MVC   DSMSG+1(7),=C'AWS291I'\n         MVC   DSMSG+19(31),=C'AWS HDR1  17 byte dataset name:'\n         MVC   DSMSG+51(17),DSHDR1NM-DSHDR1(R3)\n         AWSMSG ,\n         SPACE 1\n         CLC   DSTDSN,DSHDR1NM-DSHDR1(R3)   tape dsn correct?\n         BE    ILBL150             yes, branch\n         CLC   DSTDSN,CSBLNKS      input dsn omitted?\n         BE    ILBL150             yes, branch\n         AWSMSG 292E,'HDR1 dataset name disagrees with that specified'\n         LA    R15,8\n         B     ILBLXIT\n         SPACE 1\nILBL150  DS    0H                  capture number blocks expected\n         MVC   DSXL16(4),=4C'0'    fill with zeros\n         MVC   DSXL16+4(6),DSHDR1BL-DSHDR1(R3) low block count\n         CLI   DSHDR1BH-DSHDR1(R3),C'0' high block count specified?\n         BL    *+10                no, branch\n         MVC   DSXL16(4),DSHDR1BH-DSHDR1(R3)\n         PACK  DSDWORK,DSXL16(10)  pack block count\n         CVB   R0,DSDWORK          total block count\n         ST    R0,DSBLKCTI         save for future reference\n         SPACE 1\nILBL200  DS    0H                  process hdr2\n         AWSCALL AWSIGET           get a block\n         BNZ   ILBLXIT\n         L     R3,DSBUFTP          block location\n         CLC   AWSFLGS,CSXA000     correct flags?\n         BE    ILBL210             yes, branch\n         AWSMSG 293E,'AWSFLGS is other than expected value'\n         LA    R15,8\n         B     ILBLXIT\n         SPACE 1\nILBL210  DS    0H                  check hdr2 length\n         SLR   R0,R0               clear register\n         ICM   R0,3,AWSLENC        length of current block\n         CH    R0,=H'80'           80 bytes?\n         BE    ILBL220             yes, branch\n         AWSMSG 294E,'HDR2 record length other than 80 bytes'\n         LA    R15,8\n         B     ILBLXIT\n         SPACE 1\nILBL220  DS    0H                  validate hdr2 label\n         LA    R3,6(,R3)           position at data record\n         CLC   =C'HDR2',0(R3)      hdr2 label?\n         BE    ILBL230             yes, branch\n         AWSMSG 295E,'HDR2 label not found'\n         LA    R15,8\n         B     ILBLXIT\n         SPACE 1\nILBL230  DS    0H                  gather hdr2 values\n         MVC   DSRECFM(1),DSHDR2RF-DSHDR2(R3)    recfm\n         MVC   DSRECFM+1(1),DSHDR2BA-DSHDR2(R3)  block attribute\n         MVC   DSASA,DSHDR2CC-DSHDR2(R3)         carriage control\n         PACK  DSDWORK,DSHDR2BL-DSHDR2(L'DSHDR2BL,R3)  block size\n         CVB   R0,DSDWORK                        ... convert to binary\n         STCM  R0,3,DSBLKSIZ                     ... and save\n         PACK  DSDWORK,DSHDR2RL-DSHDR2(L'DSHDR2RL,R3)  lrecl\n         CVB   R0,DSDWORK                        ... convert to binary\n         STCM  R0,3,DSLRECL                      ... and save\n         CVD   R0,DSDWORK          convert to decimal\n         MVC   DSXL16(6),=X'F02020202120'\n         ED    DSXL16(6),DSDWORK+5 edit\n         MVI   DSXL16+5,C'0'       make printable\n         MVC   DSMSG+1(7),=C'AWS296I'\n         MVC   DSMSG+19(31),=C'AWS HDR2 tape dataset lrecl   :'\n         MVC   DSMSG+51(5),DSXL16+1 set lrecl into message\n         AWSMSG ,                  write message\n         SPACE 1\n         TRT   DSHDR2LB-DSHDR2(L'DSHDR2LB,R3),CSNUMTRT   lb numeric?\n         BNZ   ILBL240                           no, branch\n         PACK  DSDWORK,DSHDR2LB-DSHDR2(L'DSHDR2LB,R3)  large blocksize\n         CVB   R0,DSDWORK                        convert to binary\n         LTR   R0,R0                             specified?\n         BZ    ILBL240                           no, branch\n         STCM  R0,3,DSBLKSIZ                     else save as blocksize\n         SPACE 1\nILBL240  DS    0H                  write messages\n         SLR   R0,R0               clear register\n         ICM   R0,3,DSBLKSIZ       load blocksize\n         CVD   R0,DSDWORK          convert to decimal\n         MVC   DSXL16(6),=X'F02020202120'\n         ED    DSXL16(6),DSDWORK+5 edit\n         MVI   DSXL16+5,C'0'       make printable\n         MVC   DSMSG+1(7),=C'AWS297I'\n         MVC   DSMSG+19(31),=C'AWS HDR2 tape dataset blksize :'\n         MVC   DSMSG+51(5),DSXL16+1 set blksize into message\n         AWSMSG ,                  write message\n         SPACE 1\n         MVC   DSMSG+1(7),=C'AWS298I'\n         MVC   DSMSG+19(31),=C'AWS HDR2 tape dataset recfm   :'\n         MVC   DSMSG+51(2),DSRECFM\n         AWSMSG ,                  write message\n         SPACE 1\nILBL250  DS    0H                  prepare for next block\n         AWSCALL AWSIGET           get next block (should be tape mark)\n         BNZ   ILBLXIT\n         L     R3,DSBUFTP          text location\n         CLC   AWSFLGS,CSX4000     tape mark?\n         BE    ILBL900             yes, branch\n         AWSMSG 299E,'Expected tape mark after HDR2 label'\n         LA    R15,8\n         B     ILBLXIT\n         SPACE 1\nILBL900  DS    0H                  good return\n         SLR   R15,R15             zero return code\n         SPACE 1\nILBLXIT  DS    0H                  exit\n         AWSEXIT ,\n         SPACE 1\n         LTORG ,\n         DROP  ,\n         TITLE 'AWSIMTLR - import process trailer label'\n***********************************************************************\n* AWSIMTLR - import process trailer label                             *\n*            msg AWS31n                                               *\n***********************************************************************\n         space 1\nAWSIMTLR CSECT ,                   import process trailer label\n         AWSENTRY ,\n         SPACE 1\n         CLI   DSUSESL,C'N'        standard labels expected?\n         BE    ITLR900             no, branch\n         AWSCALL AWSIGET           get a block\n         BNZ   ITLRXIT\n         L     R3,DSBUFTP          current text pointer\n         USING AWSREC,R3           addressability\n         SPACE 1\n         CLC   AWSFLGS,CSXA000     correct flags?\n         BE    ITLR020             yes, branch\n         CLC   AWSFLGS,CSX4000     end of tape?\n         BNE   ITLR010             no, branch\n         AWSMSG 310E,'End of tape reached while positioning'\n         LA    R15,8\n         B     ITLRXIT\nITLR010  DS    0H\n         AWSMSG 311E,'AWSFLGS unexpected value encountered'\n         LA    R15,8\n         B     ITLRXIT\n         SPACE 1\nITLR020  DS    0H                  check vol1 length\n         CLC   =C'EOF1',6(R3)      EOF1 found?\n         BE    ITLR030             yes, branch\n         AWSMSG 312E,'EOF1 label expected and not found'\n         LA    R15,8\n         B     ITLRXIT\n         space 1\nITLR030  DS    0H\n         LA    R3,6(,R3)           position beyond aws cb\n         MVC   DSXL16(4),=4C'0'    fill with zeros\n         MVC   DSXL16+4(6),DSHDR1BL-DSHDR1(R3) low block count\n         CLI   DSHDR1BH-DSHDR1(R3),C'0' high block count specified?\n         BL    *+10                no, branch\n         MVC   DSXL16(4),DSHDR1BH-DSHDR1(R3)\n         PACK  DSDWORK,DSXL16(10)  pack block count\n         CVB   R0,DSDWORK          total block count\n         ST    R0,DSBLKCTI         save for future reference\n         MVC   DSXL16,=X'40202020202020202020202020202120'\n         ED    DSXL16,DSDWORK      edit value\n         OI    DSXL16+15,C'0'      make printable\n         MVC   DSMSG+1(7),=C'AWS313I' message id\n         MVC   DSMSG+19(31),=C'AWS EOF1 label block count    :'\n         MVC   DSMSG+51(16),DSXL16 set count into message\n         AWSMSG ,\n         AWSMSG ,                  blank line\n         AWSMSG ,                  blank line\n         SPACE 1\nITLR900  DS    0H                  normal exit\n         SLR   R15,r15             zero return code\n         SPACE 1\nITLRXIT  DS    0H                  return\n         AWSEXIT ,\n         SPACE 1\n         LTORG ,\n         DROP  ,\n         TITLE 'AWSIGET - import (get) a block'\n***********************************************************************\n* AWSIGET - import (get) a block                                      *\n*           msg AWS32n                                                *\n*                                                                     *\n* This function returns a pointer (dsbuftp) pointing to the next      *\n* block in the input AWSFILE dataset.                                 *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nAWSIGET  CSECT ,                   import (get) a block\n         AWSENTRY ,\n         SPACE 1\n         LA    R0,6                r0=amount of text needed\n         LA    R1,DSBUFFER         r1=position to place text\n         ST    R1,DSBUFTP          for caller's reference\n         SLR   R4,R4               r4=amount of text satisfied\n         LR    R5,R0               r5=amount of text needed\n         SPACE 1\nIGET010  DS    0H                  retrieve aws header\n         AWSCALL AWSGTXT           get some text\n         BNZ   IGETEOF             if eof, branch\n         ALR   R4,R0               amount of text accumlated\n         ALR   R1,R0               r1=put text here\n         LR    R0,R5               compute amount still needed\n         SR    R0,R4               r0=amount of text still needed\n         BNZ   IGET010             if more needed, branch\n         SPACE 1\n         LA    R3,DSBUFFER         aws header location\n         USING AWSREC,R3           addressability\n         AWSSWAP ,                 swap bytes, set sizes                wap byte\n         SLR   R0,R0               clear register\n         ICM   R0,3,AWSLENC        r0=amount of text needed\n         LA    R1,6(,R3)           r1=position to place text\n         SLR   R4,R4               r4=amount of text satisfied\n         LR    R5,R0               r5=amount of text needed\n         SPACE 1\nIGET020  DS    0H                  retrieve data block\n         AWSCALL AWSGTXT           get some text\n         BNZ   IGETEOF             if eof, branch\n         ALR   R4,R0               amount of text accumlated\n         ALR   R1,R0               r1=put text here\n         LR    R0,R5               compute amount still needed\n         SR    R0,R4               r0=amount of text still needed\n         BNZ   IGET020             if more needed, branch\n         SPACE 1\nIGET900  DS    0H                  exit\n         SLR   R15,R15             zero return code\n         B     IGETXIT             exit\n         SPACE 1\nIGETEOF  DS    0H                  eof reached\n         LH    R15,=H'-4'          indicate eof\n         SPACE 1\nIGETXIT  DS    0H                  return to caller\n         AWSEXIT ,\n         SPACE 1\n         LTORG ,\n         DROP  ,\n         TITLE 'AWSGTXT - get AWS  text'\n***********************************************************************\n* AWSGTXT - get AWS text                                              *\n*                                                                     *\n* calling parameters: r1 -> location where text is to be placed       *\n*                     r0 -> length of text requested                  *\n*                                                                     *\n* exit    parameters: r0 -> length of text returned                   *\n*                     r15= -4 when eof                                *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nAWSGTXT  CSECT ,                   get AWS text\n         AWSENTRY ,\n         SPACE 1\n         LR    R3,R1               r3=location at which to return text\n         LR    R4,R0               r4=length of text requested\n         LA    R5,AWSUT2           r5=input dcb location\n         USING IHADCB,R5           ... addressability\n         LA    R0,GTXTEOF          eof routine location\n         STCM  R0,7,DCBEODA        ... set into dcb\n         SPACE 1\n         SLR   R2,R2               clear register\n         LR    R15,R2              clear registger\n         ICM   R15,3,DSGTXTL       r15=length of source\n         ICM   R14,15,DSGTXTP      r14=current location in input buffer\n         ST    R2,DSGTXTP          assume all text will be used\n         STH   R2,DSGTXTL          ... and entire length\n*        LTR   R14,R14             r14=source text already present?\n         BNZ   GTXT010             yes, branch\n         SPACE 1\n         GET   AWSUT2              get some data\n         LR    R14,R1              r14=source text location\n         SLR   R15,R15             clear register\n         ICM   R15,3,DCBLRECL      r15=length of source\n         TM    DCBRECFM,DCBRECU    undefined?\n         BO    GTXT010             yes, branch\n         TM    DCBRECFM,DCBRECF    fixed?\n         BO    GTXT010             yes, branch\n         LA    R14,4(,R14)         r14=source text location (after rdw)\n         SH    R15,=H'4'           r15=source text length   (minus rdw)\n         SPACE 1\nGTXT010  DS     0H                 r3=trg,r4=trglen,r14=src,r15=srclen\n         CLR   R15,R4              source length exceeds target length?\n         BNH   GTXT020             no, branch\n         LA    R0,0(R4,R14)        r0= *next* source location\n         ST    R0,DSGTXTP          ... set next pointer (for next call)\n         SLR   R15,R4              r15=*next* source length\n         STCM  R15,3,DSGTXTL       ... set next length  (for next call)\n         LR    R15,R4              override current source length\n         SPACE 1\nGTXT020  DS     0H                 r3=trg,r4=trglen,r14=src,r15=trglen\n         LR    R2,R15              save length for later use\n         LR    R0,R3               target location\n         LR    R1,R15              target length\n         MVCL  R0,R14              copy into user buffer\n         SLR   R15,R15\n         B     GTXTXIT             return\n         SPACE 1\nGTXTEOF  DS     0H                 end of input reached\n         SLR   R2,R2               zero length returned\n         ST    R2,DSGTXTP          zero pointer\n         STH   R2,DSGTXTL          clear remaining length\n         LH    R15,=H'-4'          indicate eof\n         SPACE 1\nGTXTXIT  DS     0H\n         L     R1,4(,R13)          caller's savearea\n         ST    R2,20(,R1)          length returned in caller's r0\n         SPACE 1\n         AWSEXIT ,\n         SPACE 1\n         LTORG ,\n         DROP\n         TITLE 'Dummy functions pending implementation'\n***********************************************************************\n* Dummy functions pending implementation                              *\n***********************************************************************\n         SPACE 1\n*AWSDUMMY AWSDUMMY ,               dummy csect (expansion?)\n         TITLE 'AWSCOMST - Constant common data'\n***********************************************************************\n* AWSCOMST - Constant common data                                     *\n***********************************************************************\n         SPACE 1\nAWSCOMST CSECT ,                   constant common data\n         SPACE 1\nCSPARST1 DC    256YL1(0)           locate keyword\n         ORG   CSPARST1+C'='       keyword suffix\n         DC    C'='\n         ORG   ,\n         SPACE 1\nCSPARST2 DC    256YL1(0)           locate keyword\n         ORG   CSPARST2+C' '       delimiter #1\n         DC    C' '\n         ORG   CSPARST2+C','       delimiter #2\n         DC    C','\n         ORG   ,\n         SPACE 1\nCSPARST3 DC    256YL1(0)           locate keyword\n         ORG   CSPARST3+c'\"'       delimiter #1\n         DC    C'\"'\n         ORG   CSPARST3+C''''      delimiter #2\n         DC    C''''\n         ORG   ,\n         SPACE 1\nCSNUMTRT DC    256X'FF'            NUMERIC TEXT TRT TABLE\n         ORG   CSNUMTRT+C'0'\n         DC    10X'00'\n         ORG   ,\n         SPACE 1\nCSHEXTR  EQU   *-C'0'              hexadecimal translate table\n         DC    C'0123456789ABCDEF'\n         ORG   ,\n         SPACE 1\nCSAWSPRT DC    A(AWSPRNT)          print function\nCSAWSDYE DC    A(AWSDYNE)          dynamic allocation error function\nCSAWSEPT DC    A(AWSEPUT)          put function\nCSAWSMRK DC    A(AWSMARK)          write tape mark function\nCSAWSIGE DC    A(AWSIGET)          read a logical aws block\nCSF0     DC    F'0'                full word of zero\nCSH4     DC    Y(4)                half word 4\nCSH80    DC    Y(80)               half word 80\nCSP1     DC    P'1'                packed value 1\nCSXA000  DC    X'A000'             block flags\nCSX4000  DC    X'4000'             tape mark flags\nCSBLNKS  DC    CL133' '            some blanks\n         LTORG ,\n         TITLE 'AWSDATA - Dynamic common data'\n***********************************************************************\n* AWSDATA - Dynamic common data                                       *\n***********************************************************************\n         SPACE 1\nAWSDATA  CSECT ,                   dynamic storage data areas\nDSSTACK  DS    (STACKCT*18)F       savearea stack\nAWSDYNAM EQU   *                   origin addressable dynamic storage\nDSDWORK  DS    D                   double word workarea\nDSFWORK  DS    F                   full word work area\nDSDATAP  DS    A                   origin of relocated awsdata\nDSSTACKP DS    A                   origin of stack\nDSBUFTP  DS    A                   loc of next text in output buffer\nDSBUFEND DS    A                   end of current block\nDSGTXTP  DS    A                   get text pointer\nDSBLKCTI DS    F                   block count expected\nDSHWORK  DS    H                   half word work area\nDSFILECT DS    H                   logical file number\nDSLSTSIZ DS    H                   size of last block written\nDSCURSIZ DS    H                   size of current block written\nDSINFLNO DS    H                   infile= numeric argument\nDSBLKSIZ DS    H                   block size\nDSGTXTL  DS    H                   get text length\nDSLRECL  DS    H                   lrecl\nDSRECFM  DS    CL2                 recfm\nDSASA    DS    C                   carriage control\nDSFLAGS  DS    X                   State flags\nDSFVOLF  EQU   X'80'               ... VOL1 has been written\nDSFRECV  EQU   X'40'               ... output variable length records\nDSFFLUSH EQU   X'20'               ... flush residual output\nDSFDYUT1 EQU   X'10'               ... awsut1   dynamically allocated\nDSFDYTMP EQU   X'08'               ... awstemp  dynamically allocated\nDSFDYSYI EQU   X'04'               ... sysin    dynamically allocated\nDSFDYSYP EQU   X'02'               ... sysprint dynamically allocated\nDSFOPNEX EQU   X'01'               ... awsfile is open for export\nDSFLAGS2 DS    X                   State flags 2\nDSFIMPRT EQU   X'80'               ... import function invoked\nDSFEXPRT EQU   X'40'               ... export function invoked\nDSFFRAGD EQU   X'20'               ... AWS CB ITSELF IS FRAGMENTED\n         SPACE 1\nDSHETCMP DS    CL1                 HET COMPRESSION REQUESTED\nDSHETMTH DS    CL1                 HET COMPRESSION METHOD\nDSHETLVL DS    CL1                 HET COMPRESSION LEVEL\nDSHETIDR DS    CL1                 HET IDRC\nDSHETCSZ DS    CL5                 HET CHUNK SIZE\nDSBLKCNT DS    PL6                 DATASET BLOCK COUNT\nDSOWNER  DS    CL10                owner=   volume owner\nDSINDSN  DS    CL44                indsn=   dataset name\nDSOUTDSN DS    CL44                outdsn=  dataset name\nDSTDSN   DS    CL17                tapedsn= dataset name\nDSINDD   DS    CL8                 indd=    ddname\nDSOUTDD  DS    CL8                 outdd=   ddname\nDSINFLNC DS    CL8                 infile=  character argument\nDSUNLPGM DS    CL8                 unload=  program\nDSLODPGM DS    CL8                 load=    program\nDSUNLTYP DS    CL8                 unload type (repro, export, etc)\nDSUSESL  DS    CL1                 use standard labels flag\nDSCARD   DS    CL80                sysin control statements\nDSTVOL   DS    CL6                 tape volser\nDSJOBNM  DS    CL8                 job name\nDSSTEPNM DS    CL8                 step name\n         SPACE 1\nDSXL16   DS    XL16                16 byte work area\nDSHEXWK  DS    CL9                 hex work area\nDSIBLKCT DS    PL8                 aws input block count\nDSIRECCT DS    PL8                 aws input record count\n         SPACE 1\n         DS    0D\nAWSRELOC EQU   *                   beginning of relocated storage\n         SPACE 1\nDSOPENL  OPEN  0,MF=L              open  parameter list\nDSCLOSEL CLOSE 0,MF=L              close parameter list\nDSRDJFCB RDJFCB 0,MF=L             rdjfcb parameter list\n         SPACE 1\nDSPAGECT DC    PL2'0'              page count\nDSLINECT DC    PL2'90'             line count\nDSMSG    DC    CL133' '            message buffer\nDSMSG1   DC    CL133' '            message buffer\nDSHEADER DC    CL133' '\n         ORG   DSHEADER\n         DC    C'1AWSSL - AWS Virtual Tape (standard labels) - '\n         DC    C'Version 1.9G - Copyright (C) 2002 - '\n         DC    C'By Reed H. Petty, rhp@draper.net'\n         ORG   DSHEADER+123\n         DC    C' Page'\nDSPAGE   DC    CL4'   1'\n         ORG   ,\n         SPACE 1\nDSJFCBL  DS    0F                  RDJFCB LIST\n         DC    X'87',AL3(INFMJFCB) JFCB EXIT LST\n         SPACE 1\n         PRINT NOGEN\n         IEFJFCBN LIST=YES         JFCB\n         PRINT GEN\n         EJECT\n***********************************************************************\n* Dynamic allocation control blocks                                   *\n***********************************************************************\n         SPACE 1\n         DS    0F\nDSARBP   DC    X'80',AL3(DSARB)    input dataset request block\nDSARB    DC    XL(S99RBEND-S99RB)'00' request block\n         SPACE 1\nDSATXTP  DC    A(DSADDNM)          ddname\n         DC    A(DSADSNM)          dataset name\n         DC    A(DSASTATS)         dataset status\n         DC    X'80',AL3(DSADISP)  normal disposition\n         SPACE 1\nDSADDNM  DC    YL2(DALDDNAM),YL2(1),YL2(8)\nDSADDNM1 DC    CL8'AWSUT1'\n         SPACE 1\nDSADSNM  DC    YL2(DALDSNAM),YL2(1),YL2(DSADSNML)\nDSADSNMT DC    CL44' '\nDSADSNML EQU   *-DSADSNMT\n         SPACE 1\nDSASTATS DC    YL2(DALSTATS),YL2(1),YL2(1),X'08' SHR\n         SPACE 1\nDSADISP  DC    YL2(DALNDISP),YL2(1),YL2(1),X'08' KEEP\n         SPACE 1\n         DS    0F\nDSTARBP  DC    X'80',AL3(DSTARB)   awstemp dataset request block\nDSTARB   DC    XL(S99RBEND-S99RB)'00' request block\nDSTATXTP DC    A(DSTADDNM)         ddname (AWSTEMP)\n         DC    A(DSTAUNIT)         unit (SYSDA)\n         DC    A(DSTASPCU)         space primary units (CYL)\n         DC    A(DSTASPCP)         space primary qty   (100)\n         DC    X'80',AL3(DSTASPCS) space secondary qty (100)\nDSTADDNM DC    YL2(DALDDNAM),YL2(1),YL2(7),CL7'AWSTEMP'\nDSTAUNIT DC    YL2(DALUNIT),YL2(1),YL2(5),CL5'SYSDA'\nDSTASPCU DC    YL2(DALCYL),YL2(0)\nDSTASPCP DC    YL2(DALPRIME),YL2(1),YL2(3),AL3(100)\nDSTASPCS DC    YL2(DALSECND),YL2(1),YL2(3),AL3(100)\n         SPACE 1\n         DS    0F\nDSSARBP  DC    X'80',AL3(DSSARB)   sysin dataset request block\nDSSARB   DC    XL(S99RBEND-S99RB)'00' request block\nDSSATXTP DC    A(DSSADDNM)         ddname (SYSIN)\n         DC    A(DSSAUNIT)         unit (SYSDA)\n         DC    A(DSSASPCU)         space primary units (CYL)\n         DC    A(DSSASPCP)         space primary qty   (1)\n         DC    X'80',AL3(DSSASPCS) space secondary qty (1)\nDSSADDNM DC    YL2(DALDDNAM),YL2(1),YL2(5),CL7'SYSIN'\nDSSAUNIT DC    YL2(DALUNIT),YL2(1),YL2(5),CL5'SYSDA'\nDSSASPCU DC    YL2(DALTRK),YL2(0)\nDSSASPCP DC    YL2(DALPRIME),YL2(1),YL2(3),AL3(1)\nDSSASPCS DC    YL2(DALSECND),YL2(1),YL2(3),AL3(1)\n         SPACE 1\n         DS    0F\nDSPARBP  DC    X'80',AL3(DSPARB)   sysprint dataset request block\nDSPARB   DC    XL(S99RBEND-S99RB)'00' request block\nDSPATXTP DC    A(DSPADDNM)         ddname (SYSPRINT)\n         DC    X'80',AL3(DSPADUMY) dummy dd statement\nDSPADDNM DC    YL2(DALDDNAM),YL2(1),YL2(8),CL8'SYSPRINT'\nDSPADUMY DC    YL2(DALDUMMY),YL2(0)\n         SPACE 1\n         DS    0F\nDSURBP   DC    X'80',AL3(DSURB)    unallocation request block\nDSURB    DC    XL(S99RBEND-S99RB)'00' request block\nDSUTXTP  DC    X'80',AL3(DSUDDNM)  ddname\nDSUDDNM  DC    YL2(DUNDDNAM),YL2(1),YL2(8)\nDSUDDNM1 DC    CL8'AWSUT1'\n         EJECT\n***********************************************************************\n* VOL1 label                                                          *\n***********************************************************************\n         SPACE 1\nDSVOL1   DC    CL80' '             vol1 label\n         ORG   DSVOL1\n         DC    CL4'VOL1'\nDSVOL1SR DS    CL6                 volser\n         DC    CL1' '              reserved\n         DC    CL5' '              vtoc pointer\n         DC    CL25' '             reserved\nDSVOL1OW DC    CL10' '             owner\n         DC    CL29' '             reserved\n         SPACE 1\n***********************************************************************\n* HDR1 label                                                          *\n***********************************************************************\n         SPACE 1\nDSHDR1   DC    CL80' '             hdr1 label\n         ORG   DSHDR1\n         DC    CL4'HDR1'\nDSHDR1NM DS    CL17                last 17 bytes of dsn\nDSHDR1SR DS    CL6                 volser\n         DC    CL4'0001'           file section number\nDSHDR1SQ DC    CL4'0000'           file sequence number\n         DC    CL4' '              generation number\n         DC    CL2' '              generation version number\nDSHDR1CD DC    CL6'000001'         creation date, cyyddd,c=' '=1900\n         DC    CL6'000000'         expiration date\n         DC    CL1'0'              not password protected\nDSHDR1BL DC    CL6'000000'         block count low order 6 bytes\n         DC    CL13'IBM OS/VS 370' system code\n         DC    CL3' '              reserved\nDSHDR1BH DC    CL4' '              block count high order 4 bytes\n         ORG   ,\n         SPACE 1\n***********************************************************************\n* HDR2 label                                                          *\n***********************************************************************\n         SPACE 1\nDSHDR2   DC    CL80' '             hdr2 label\n         ORG   DSHDR2\n         DC    C'HDR2'\nDSHDR2RF DS    CL1                 record format\nDSHDR2BL DS    CL5                 block length\nDSHDR2RL DS    CL5                 record length\n         DC    C'0'                tape density, 0 = cartridge\n         DC    C'0'                volume switch is not in progress\nDSHDR2JB DC    CL8' '              jobname\n         DC    CL1'/'\nDSHDR2ST DC    CL8' '              step name\n         DC    CL2'  '             recording technique\nDSHDR2CC DC    CL1' '              a=asa,m=machine,' '=none\n         DC    CL1' '              reserved\nDSHDR2BA DC    CL1' '              block attribute\n*                                  b=blocked records\n*                                  s=spanned or standard\n*                                  r=blocked and spanned or standard\n*                                  unblocked\n         DC    CL2' '              reserved\n         DC    CL6'AWS19G'         serial number of creating device\n         DC    CL1' '              checkpoint identifier\n         DC    CL22' '             reserved\nDSHDR2LB DC    CL10' '             large block length\n         ORG   ,\n         EJECT\n***********************************************************************\n* EOF1 label                                                          *\n***********************************************************************\nDSEOF1   DC    CL80' '             eof1 label\n         ORG   DSEOF1\n         DC    CL4'EOF1'\nDSEOF1NM DS    CL17                last 17 bytes of dsn\nDSEOF1SR DS    CL6                 volser\n         DC    CL4'0001'           file section number\nDSEOF1SQ DC    CL4'0000'           file sequence number\n         DC    CL4' '              generation number\n         DC    CL2' '              generation version number\n         DC    CL6'000001'         creation date, cyyddd,c=' '=1900\n         DC    CL6'000001'         expiration date\n         DS    CL1'0'              not password protected\nDSEOF1BL DC    CL6'000000'         block count low order 6 bytes\n         DC    CL13'IBM OS/VS 370' system code\n         DC    CL3' '              reserved\nDSEOF1BH DC    CL4'0000'           block count high order 4 bytes\n         ORG   ,\n         SPACE 1\n***********************************************************************\n* EOF2 label                                                          *\n***********************************************************************\n         SPACE 1\nDSEOF2   DC    CL80' '             eof2 label\n         ORG   DSEOF2\n         DC    C'EOF2'\nDSEOF2RF DS    CL1                 record format\nDSEOF2BL DS    CL5                 block length\nDSEOF2RL DS    CL5                 record length\n         DC    C'0'                tape density, 0 = cartridge\n         DC    C'0'                volume switch is not in progress\nDSEOF2JB DC    CL8' '              jobname\n         DC    CL1'/'\nDSEOF2ST DC    CL8' '              step name\n         DC    CL2'  '             recording technique\nDSEOF2CC DC    CL1' '              a=asa,m=machine,' '=none\n         DC    CL1' '              reserved\nDSEOF2BA DC    CL1' '              block attribute\n*                                  b=blocked records\n*                                  s=spanned or standard\n*                                  r=blocked and spanned or standard\n*                                  unblocked\n         DC    CL2' '              reserved\n         DC    CL6'AWSSL '         serial number of creating device\n         DC    CL1' '              checkpoint identifier\n         DC    CL22' '             reserved\n         DC    CL10' '             large block length\n         ORG   ,\n         SPACE 1\n***********************************************************************\n* Data control blocks                                                 *\n***********************************************************************\n         SPACE 1\n         PRINT NOGEN\nAWSPRINT DCB   DDNAME=AWSPRINT,DSORG=PS,MACRF=PM,RECFM=FBA,LRECL=133\n         SPACE 1\nAWSUT1   DCB   DDNAME=AWSUT1,DSORG=PS,MACRF=GL,EXLST=DSJFCBL\nAWSUT2   DCB   DDNAME=AWSFILE,DSORG=PS,MACRF=GL\nAWSUT3   DCB   DDNAME=AWSUT3,DSORG=PS,MACRF=PM\n         SPACE 1\nAWSFILE  DCB   DDNAME=AWSFILE,DSORG=PS,MACRF=PM\n         SPACE 1\nAWSCNTL  DCB   DDNAME=AWSCNTL,DSORG=PS,MACRF=GL\n         SPACE 1\nSYSIN    DCB   DDNAME=SYSIN,DSORG=PS,MACRF=PM,RECFM=FB,LRECL=80,       *\n               BLKSIZE=3120\n         PRINT GEN\n         DROP\n         SPACE 1\nDSBUFFER DS    0D                  128k I/O buffer location\nDSENDL   EQU   *-AWSRELOC          length of relocatable storage\nAWSDATAL EQU   *-AWSDATA           data areas length\n         EJECT\n***********************************************************************\n* AWS block header definition                                         *\n***********************************************************************\n         SPACE 1\nAWSREC   DSECT ,                   AWS block header\nAWSLENC  DS    H                   block length\nAWSLENP  DS    H                   file data preceeding this block\nAWSFLGS  DS    H                   block flags\nAWSDBLK  DS    0X                  data block origin\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT585/FILE585.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT585", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}