/* rexx */
Rexx_IPCSKEN:
  rexxpgm_version = "01.01"           /* ver lev */

  Parse Arg parameters_are_not_used

/*===================================================================*
 *                                                                   *
 *  Name:       IPCSKEN                                              *
 *  Type:       IPCS Rexx exec                                       *
 *                                                                   *
 *  Purpose:    Provide hints and tips while using real data.        *
 *  Abstract:   Using an actual IPCS session, build a file of hints  *
 *              and tips to aid the casual user have a productive    *
 *              debugging session. Based on the actual source, go    *
 *              ahead and execute those commands that will work.     *
 *                                                                   *
 *  Syntax:     IPCSKEN                                              *
 *                                                                   *
 *  Example:    ip ipcsken                                           *
 *                                                                   *
 *  Author:     Kenneth E. Tomiak                                    *
 *  Date:       2003-03-18  2003.077                                 *
 *  E-Mail:     <K.Tomiak@Schunk-Associates.com>                     *
 *  SNAIL-MAIL: Schunk and Associates, Inc.                          *
 *              7 Innex Avenue                                       *
 *              P.O. Box 474                                         *
 *              New Paltz, NY 12561-0474                             *
 *              U.S.A.                                               *
 *  PHONE:      (845) 256-1010                                       *
 *  FAX2EMAIL:  (888) 785-7710                                       *
 *  WEB:        HTTP://WWW.SCHUNK-ASSOCIATES.COM                     *
 *                                                                   *
 *  Disclaimers:                                                     *
 *  I support my code using a best-effort philosophy. As long as I   *
 *  have access to an image where I can test, I will maintain it as  *
 *  best as I can. If you find a flaw, please do let me know.        *
 *                                                                   *
 *  The code released by Kenneth E. Tomiak may change your IPCS      *
 *  default settings. You can use IPCS option 0 to tailor them back  *
 *  to what you want. An attempt is made to reset your values if you *
 *  do not HALT processing.                                          *
 *                                                                   *
 *  BUYER BEWARE!                                                    *
 *                                                                   *
 *  What could go wrong? If I knew that I would have coded something *
 *  different. I do not expect anything to go wrong. I am going to   *
 *  be adding symbols and stack pointers so your DDIR is going to    *
 *  be updated. Is it big enough? You use DropDump to remove dumps   *
 *  you ar eno longer working with, right?                           *
 *                                                                   *
 *  BUYER BEWARE!                                                    *
 *                                                                   *
 *  In no event will the author be liable to the user of this code   *
 *  for any damages. Including, but not limited to, any lost         *
 *  profits, lost savings or other incidental, consequential or      *
 *  special damages arising out of the operation of or inability to  *
 *  operate this code, even if the user has been advised of the      *
 *  possibility of such damages.                                     *
 *                                                                   *
 *  With that stated, enjoy all this has to offer.                   *
 *                                                                   *
 *===================================================================*
 *===================================================================*
 *                                                                   *
 * History of changes (top entry is the most recent change)          *
 * ----------------------------------------------------------------- *
 *                                                                   *
 * 2003-04-17 KTomiak <K.Tomiak@Schunk-Associates.com>               *
 *                    Added list of bls* members.                    *
 *                                                                   *
 * 2003-04-16 KTomiak <K.Tomiak@Schunk-Associates.com>               *
 *                    Added retrieval of VERIFY setting, warning     *
 *                    about CONFIRM needing extra <ENTER>.           *
 *                                                                   *
 * 2003-04-07 KTomiak <K.Tomiak@Schunk-Associates.com>               *
 *                    Added list of *ipcs* members from DDNAMEs      *
 *                    SYSPROC and SYSEXEC.                           *
 *                    If SOURCE(NODSNAME) then default to ACTIVE.    *
 *                    SHOW MVS commands for displaying DUMP options. *
 *                                                                   *
 * 2003-04-04 KTomiak <K.Tomiak@Schunk-Associates.com>               *
 *                    Added more hints&tips and included showing     *
 *                    real data from the source, when appropriate.   *
 *                    Source can be a dump, VSAM, or memory.         *
 *                                                                   *
 * 2003-04-03 KTomiak <K.Tomiak@Schunk-Associates.com>               *
 *                    Added hints&tips from scattered notes.         *
 *                                                                   *
 * 2003-04-02 KTomiak <K.Tomiak@Schunk-Associates.com>               *
 *                    If SOURCE(NODSNAME) then default to            *
 *                    using ACTIVE.                                  *
 *                    Add a few more entries to the stack.           *
 *                                                                   *
 * 2003-03-11 KTomiak <K.Tomiak@Schunk-Associates.com>               *
 *                    Original concept design, code                  *
 *                    cloned from BLSXWHER, then modified.           *
 *                                                                   *
 * ----------------------------------------------------------------- *
 *                                                                   *
 *===================================================================*/

  Address IPCS
  trace off
  opsys = MVSVAR("SYSOPSYS")
  sysname = MVSVAR("SYSNAME")
  parse upper var opsys rootsys rootlvl rootfmid
  parse var rootlvl rootver "." rootrel "." rootmod
  rootver = rootver + 0
  rootrel = rootrel + 0
  rootmod = rootmod + 0
  CVT  = C2d(Storage(10,4))                  /* point to CVT         */
  ECVT   = C2d(Storage(D2x(CVT + 140),4))    /* point to CVTECVT     */
  ipaarchl = 1
  if (Substr(rootfmid,4,4) >= 6602) then,
    do
      ECVTIPA = C2d(Storage(D2x(ECVT + 392),4)) /* point to IPA      */
      If Substr(rootfmid,4,4) > 6609 then ,  /* OS/390 R10 or above  */
        IPAARCHL = Storage(D2x(ECVTIPA + 2143),1) /* ARCHLVL (1 or 2) */
    end
  current_address = Address()

  Call OUTTRAP "lines."     /* Suppress CBFormat output when
                               not in the IPCS dialog environment.   */
/*-------------------------------------------------------------------*
 * VERSION=>REXX_Language,Language_level,Level_Date                  *
 *-------------------------------------------------------------------*/
  Parse Version Rexx_Language Language_Level Level_Date

/*-------------------------------------------------------------------*
 * SOURCE==>    (A set of platform dependent values)                 *
 *-------------------------------------------------------------------*/
  Parse Source,
    Host_Environment Call_Type Uc_Exec_Name,
    Hostdd Hostdsn,
    Nf_Exec_Name Initial_Cmd_Env Asid_Name,
    Char8_User_Token HostOtherParameter

/*-------------------------------------------------------------------*
 * Now make sure IPCS is actively working.                           *
 *-------------------------------------------------------------------*/

  Signal ON HALT

/* --------------------------------------------------------- */
/* Save the current default environment.  Although all of    */
/* the defaults saved are not changed in this exec, saving   */
/* them ensures they will be returned to their initial value */
/* if in the future they are changed in this exec.           */
/* --------------------------------------------------------- */

  "EVALDEF REXX(CONFIRM(con) PRINT(prt) SOURCE(src)",
      "TERMINAL(trm) FLAG(flg) DISPLAY(dsp) VERIFY(vfy))"
  Retc = rc
  If (Retc > 12) | (retc < 0) then,
    do
      say left("Hey, you need to be in IPCS!",76)
      signal No_restore_exit    /* Error exit                    */
    end
  If (src = "NODSNAME") then,
    do
      "SETDEF LOCAL ACTIVE"
      Retc = rc
      "EVALDEF REXX(CONFIRM(ktcon) PRINT(ktprt) SOURCE(ktsrc)",
        "TERMINAL(kettrm) FLAG(ketflg) DISPLAY(ketdsp) VERIFY(ketvfy))"
      If (Retc > 12) | (retc < 0) then,
        do
          msgtext = left("Hey, you need to open something!",76)
          Call Put
          signal No_restore_exit    /* Error exit           */
        end
      src = ktsrc
      call putitout ,
       Left("** Using NODSNAME would only show help",
        "so I changed to ACTIVE",103) "**"
      dispsrc = "SOURCE("src")"
    end

  MsgText = " "
  Call Put
  MsgText = Copies("=",79)
  Call Put
  Call Put
  MsgText = "Continue to scroll down as I execute some of these"
  Call Put
  MsgText = "commands for you. PF3(END) ay anytime to HALT execution."
  Call Put
  MsgText = "Some commands are tailored to the SOURCE you are using."
  Call Put
  showitall = "n"
  if (left(src,3) = "DSN") then showitall = "?"
  select
    when (src = "NODSNAME") then,
      do
        call putitout ,
         Left("** Using NODSNAME will only show help",103) "**"
        dispsrc = "SOURCE("src")"
      end
    when (showitall = "n") then,
      do
        dispsrc = "SOURCE("src")"
        call putitout ,
         Left("** Using" dispsrc "will not show",
           "all that DSNAME() would.",103) "**"
      end
    otherwise,
    do
      parse var src . "'" namesrc "'" .
      parse var namesrc srcdsn "(" srcext ")" .
      lrc = Listdsi("'"srcdsn"'")
      if (srcext >< "") then,
        do
          dispsrc = "SOURCE("srcdsn"("srcext"))"
        end
      else,
        do
          dispsrc = "SOURCE("srcdsn")"
        end
      call putitout Left("**" srcdsn "DSORG("sysdsorg")",103) "**"
      if (sysdsorg >< "VS") then showitall = "y"
    end
  end
  MsgText = Copies("=",79)
  Call Put
  Call Put
  MsgText = " "
  Call Put

/*-------------------------------------------------------------------*
 * Display Ken's standard header.                                    *
 *-------------------------------------------------------------------*/
  call putitout ""
  call putitout Copies("=",78)
  call putitout Left("=" uc_exec_name,76) "="
  call putitout Left("= Executing under" Host_Environment||,
    " as a" Call_type,76) "="
  call putitout Left("= with Address("current_address")",76) "="
  call putitout Left("= On" date() "at" time()".",76) "="
  call putitout Left("= Language:" REXX_Language,76) "="
  call putitout Left("= Level:" Language_Level,76) "="
  call putitout Left("= Date:" Level_Date,76) "="
  call putitout Copies("=",78)
  call putitout " "
  call putitout "This IPCS Reference provided by Kenneth E. Tomiak",
    "(SaAI)."
  call putitout "Much of this information comes from Jerry Ng (IBM)."
  call putitout " "
  call putitout "Your current IPCS settings:"
  call putitout "---------------------------"
  call putitout "  CONFIRM ="con"."
  if (con = "CONFIRM") then,
    do
      call putitout "      IF AFTER PRESSING <DOWN>"
      call putitout "      IT LOOKS LIKE NOTHING IS HAPPENING,"
      call putitout "      KEEP PRESSING ENTER."
      call putitout "      You can change this under settings by"
      call putitout "      using NOCONFIRM."
      call putitout "      "
    end
  call putitout "  VERIFY  ="vfy"."
  call putitout "  PRINT   ="prt"."
  call putitout "  TERMINAL="trm"."
  call putitout "  FLAG    ="flg"."
  call putitout "  DISPLAY ="dsp"."
  call putitout " "
  call putitout " "
  call putitout "Open something:"
  call putitout "---------------"
  call putitout "Under your defaults you can use:"
  call putitout "  ACTIVE, MAIN, or STORAGE."
  call putitout "  DSNAME(''some.dump.dsname''),"
  call putitout "  or DSNAME(''some.vsam.cluster.dsname''),"
  call putitout "  or DSNAME(''some.vsam.cluster.dsname(DATA)'')!"
  call putitout "From the IPCS 3.4 screen use the line command:"
  call putitout "  setdef dsname(/)"
  call putitout ,
   Left("** You are using" dispsrc".",103) "**"
  call putitout " "
  call putitout "To find how" sysname "processes dumps, issue MVS",
    "commands:"
  call putitout "D D,O        - Display Dump options"
  call putitout "               Shows what gets dumped."
  call putitout "D D,S        - Display Dump Status allocation defaults"
  call putitout "               Shows where it gets dumped to."
  call putitout " "
  call putitout "Remember to DropDump once in awhile when using"
  call putitout "SOURCE(dsname). I like to delete my dump directory"
  call putitout "every now and then. TSO DEL DDIR does it."
  call putitout " "
  call putitout Copies("-",78)
  call putitout "Jerry Ng (IBM) says:"
  call putitout " "
  call putitout "There are four types of dumps in two major categories:"
  call putitout "  Synchronous"
  call putitout "  Asynchronous"
  call putitout "    SLIP"
  call putitout "    Console initiated dump"
  call putitout "    Disabled/SRB"
  call putitout "To determine the type, look at the DUMP TITLE."
  if (showitall = "y") then,
    do
      msgtext = ,
        "EVALUATE 58. LENGTH(100) REXX(STORAGE(dtitle)) BLOCK(0) CHAR"
      Call Put
      msgtext
      "EQUATE DMPTITLE 58. LENGTH(100) BLOCK(0) CHAR",
        "REMARK(''Kens - DUMP Title'')"
      "STACK DMPTITLE"      /* Add it to the pointer list     */
      call putitout left("** The dump title is:",103) "**"
      call putitout Copies("*",106)
      call putitout left("**" dtitle,103) "**"
      call putitout Copies("*",106)
    end
  call putitout "  Issue ''IPCS STATUS SYSTEM''."
  call putitout "  Look at ''Program Requesting Dump''."
  call putitout "    an SVCDUMP is Synchronous,"
  call putitout "    an IEAVTSDT is Asynchronous."
  call putitout Copies("-",78)
  if (showitall = "y") then,
    do
      "EVALUATE 40. LENGTH(8) REXX(STORAGE(reqpgm)) BLOCK(0) CHAR"
      "EVALUATE CC. LENGTH(8) REXX(STORAGE(failsys)) BLOCK(0) CHAR"
      "EVALUATE 1BC. LENGTH(44) REXX(STORAGE(dmpdsn)) BLOCK(0) CHAR"
      dmpdsn = strip(dmpdsn,"B"," ")
      call putitout Copies("*",106)
      call putitout ,
        Left("** The requesting program is" reqpgm".",103) "**"
      call putitout ,
      left("** The dump was taken on system:" failsys".",103),
        "**"
      call putitout ,
      left("** You are viewing it on system:" sysname".",103),
        "**"
      call putitout Copies("*",106)
    end
  call putitout " "
  call putitout "While examining anything:"
  call putitout "-------------------------"
  call putitout "Use ''%'' for 24 bit addresses,"
  call putitout "Use ''?'' for 31 bit addresses,"
  call putitout "Use ''!'' for 64 bit addresses."
  call putitout "Your Architecture Level is" ipaarchl"."
  select
    when (ipaarchl = 1) then,
      do
        call putitout "  You are not 64 bit enabled."
      end
    when (ipaarchl = 2) then,
      do
        call putitout "  64 bit is enabled."
        call putitout "    Recognize a 64 bit address:",
          "01_80203040 is one example."
      end
    otherwise,
      do
        call putitout "  Neither 64 bit nor not 64 bit, how odd!"
      end
  end
  call putitout "Use ''L'' to add a 24 bit address to the stack."
  call putitout "Use ''H'' to add a 31 bit address to the stack."
  call putitout " "
  call putitout "Toggle between Ebcdic or Ascii."
  call putitout " "
  call putitout "Use ''CBF addr. str(cbfname)'' to format a CB."
  call putitout "Use ''LIST PRIVATE'' and ''LIST PRIVATEX''."
  call putitout "Use ''LISTSYM *'' to list defined symbols."
  call putitout "Use F t''literal'' NOB to find without breaking."
  call putitout "Use F x''hex-lit'' mask(x''0000FFFF'') BDY(4)   "
  call putitout "  would compare the right half-word on word boundries."
  call putitout "Using ''IPCS OPCODE xxxxxxxx'' will describe the  "
  call putitout "  opcode instruction. Make sure you pass the entire"
  call putitout "  length''s data. From 2 to 12 bytes."
  "OPCODE 849C7BBA REXX(MNEMONIC(opins))"
  retc = rc
  call putitout "OPCODE 849C7BBA should show BRXH, it shows:" opins
  call putitout " "
  call putitout "You can ''PATCH'' data if you need to fix a corrupted"
  call putitout "control block."
  call putitout "  PATCH LIST            - shows what is patched."
  call putitout "  DROPMAP               - clears any patched del."
  call putitout "  PATCH DEL ..."
  call putitout "  PATCH ADD x''C1E2C3C2'' ADDR(F49880.) - adds ASCB."
  call putitout " "
  call putitout "CBF addr. STR(todclock) - CONVERTS TO DATE AND TIME"
  if (showitall = "y") then,
    do
      "EVALUATE 48. L(8) REXX(STORAGE(dmpclk)) BLOCK(0)"
      call putitout Copies("*",106)
      call putitout ,
       Left("** This dump was taken:",103)
      call putitout ,
        Left("** CBF 48. str(TODCLOCK) BLOCK(0)",103) "**"
      "CBF 48. str(TODCLOCK) BLOCK(0)"
      call putitout Copies("*",106)
  end
  call putitout " "
  call putitout " "
  call putitout "While examining a dump (not ACTIVE):"
  call putitout "------------------------------------"
  call putitout "Look at ''Program Requesting Dump''."
  call putitout "  DFHKETCB is CICS  (so says Ken)"
  if (showitall = "y") then,
    do
      call putitout Copies("*",106)
      call putitout ,
        Left("** The requesting program of dump" ,
        dmpdsn "is:" reqpgm".",103),
        "**"
      call putitout Copies("*",106)
    end
  call putitout "IPCS SUMM FORMAT     - for a quick look."
  call putitout "IPCS EVAL PSW        - Locate PSW."
  if (showitall = "y") then,
    do
      call putitout ,
        "EVAL PSW     - let IBM find it."
      call putitout Copies("*",106)
      "EVAL PSW"
      call putitout Copies("*",106)
      call putitout ,
        "EQUATE PSW X",
          "REMARK(''IBMs - Program Status Word'') STR(PSW)"
      call putitout Copies("*",106)
      "EQUATE PSW X",
        "REMARK('IBMs - Program Status Word') STR(PSW)"
      call putitout Copies("*",106)
      call putitout ,
        "STACK PSW"           /* Add it to the pointer list     */
      call putitout Copies("*",106)
      "STACK PSW"           /* Add it to the pointer list     */
      call putitout Copies("*",106)
      call putitout ,
        "L PSW"
      call putitout Copies("*",106)
      "L PSW"
      call putitout Copies("*",106)
    end
  call putitout "L 13R?               - Current save area in reg 13"
  call putitout " "
  call putitout "Use ''WHERE addr.'' to have IPCS find where it is."
  if (showitall = "y") then,
    do
      call putitout ,
        "Where PSW      - find out which ASID or area the PSW is in."
      call putitout Copies("*",106)
      "Where PSW"
      call putitout Copies("*",106)
    end
  call putitout " "
  call putitout "L dumptimestamp      - shows when dump was taken."
  call putitout "  or ip status worksheet or ip status system."
  call putitout " "
  call putitout "LIST E0. BLOCK(0) LENGTH(16) AREA - shows sdrsn"
  call putitout "  This will indicate if it is a partial dump."
  call putitout "  The fourth word is SDRSN from IEA611I or IEA911E."
  call putitout " "
  call putitout "CBF RTCT - shows which address spaces were dumped."
  call putitout "CBF RTCT+9C? STR(SDUMP) VIEW(FLAGS) - what areas."
  call putitout " "
  call putitout "You are running on" rootsys rootver"."rootrel"."
  call putitout " "
  call putitout "z/OS 1.2+ enhancements:"
  call putitout "  SORTBY   - with OA02037"
  call putitout "  verbx blsaispt    - shows how long IPL routines take"
  call putitout "                      until you get to z/OS 1.3, then"
  call putitout "                      you should use IPLDATA."
  call putitout "    (from SYS1.MIGLIB)"
  call putitout " "
  call putitout "z/OS 1.3+ enhancements:"
  call putitout "IPLDATA INFORMATION - shows ''D IPLINFO'' data."
  call putitout "IPLDATA STATUS      - shows how long IPL routines take"
  call putitout " "
  call putitout "z/OS 1.4+ enhancements:"
  call putitout "Ltod 8hex-digits            - converts to todclock."
  call putitout "Ltod 32hex-digits Extended  - converts to todclock."
  call putitout " "
  call putitout " "
  call putitout "You can use ASID() or BLOCK()."
  call putitout "  ASID() lets IPCS work some magic"
  call putitout "  BLOCK() gives you raw access"
  call putitout "    IP L 58. BLOCK(0) L(100) CHAR - shows the title."
  call putitout " "
  call putitout " "
  call putitout "use these commands if you dumped these:"
  call putitout "---------------------------------------"
  call putitout "IPCS VERBX MTRACE    - master console output"
  call putitout "IPCS VERBX LOGDATA   - logrec output"
  call putitout "IPCS systrace        - system trace"
  call putitout "IPCS lpamap          - print lpa module''s addresses"
  call putitout " "
  call putitout "Other fun things to look at:"
  call putitout "----------------------------"
  call putitout "Issue ''IPCS STATUS FAILDATA'' to find failure data."
  call putitout "Issue ''IPCS STATUS REGISTERS'' to find registers."
  if (showitall = "y") then,
    do
      call putitout Copies("*",106)
      call putitout "**",
      "ST registers"        /* show register 13 savearea chaining */
      "ST registers"        /* show register 13 savearea chaining */
      call putitout Copies("*",106)
    end
  call putitout " "
  call putitout "Things to watch out for:"
  call putitout "------------------------"
  call putitout "Correct ''ASID(x''0000'')'' if not your data."
  call putitout "XMD under ASID(0002) is not normally available."
  call putitout " "
  call putitout "If you dumped ASID(0002):"
  call putitout "-------------------------"
  call putitout "Run the chain to find lost ASIDs"
  call putitout "  Enter the next two lines as one command."
  call putitout "   runc addr(cvt+364%+138?) link(x''88'') +"
  call putitout "   exec((l x+48?+1c len(8) asid(2) char)) nodisplay"
  call putitout " "
  call putitout "When analyzing a CICS dump:"
  call putitout "---------------------------"
  call putitout "May need to allocate SDFHPARM to //IPCSPARM DD."
  call putitout "May need to allocate SDFHLINK as a TSOLIB or LNKLST."
  call putitout "May need to allocate DFHSNAP to eliminate messages."
  call putitout "SUMMARY DATA should not be used for CICS because"
  call putitout "  it uses three keys."
  call putitout "Change options(NOMACHINE) to (MACHINE)"
  if (showitall = "y") &,
     (reqpgm = "DFHKETCB") then,
    do
      call putitout Copies("*",106)
      call putitout ,
        Left("** This is a CICS dump so I''ll switch it for you",103),
        "**"
      call putitout Copies("*",106)
      parse var dsp mch other
      if (mch >< "MACHINE") then,
        do
      call putitout Copies("*",106)
          "SETDEF DISPLAY(MACHINE" other")"
          set_rc = rc
      call putitout Copies("*",106)
        end
    end
  call putitout "VERBX DFHPDxxx uses the continuing vrm for CICS TS."
  call putitout "           510 was CICS TS 1.0"
  call putitout " "
  call putitout "When analyzing an IMS dump:"
  call putitout "---------------------------"
  call putitout "You will need DFSOFMD0 from //IPCSPARM DD."
  call putitout "   I copied BLSCECTX from PARMLIB and added:"
  call putitout ,
    "    EXIT EP(DFSOFMD0) VERB(IMSDUMP) ABSTRACT(''IMS ANALYSIS'') +"
  call putitout ,
    "        PARM(''PDBCTL'')"
  call putitout "   and make sure you have IRLM support if you need it:"
  call putitout ,
    "EXIT EP(DXRRLM50) VERB(IRLM) AMASK(X''00FFFFFF'') ABSTRACT(+"
  call putitout ,
    "    ''IMS RESOURCE LOCK MANAGER ANALYSIS'')"
  call putitout "Allocate //DFSFRMAT to a pds member with this in it:"
  call putitout "FMTIMS(AUTO)"
  call putitout "Allocate DFSCLST  to //SYSPROC  DD."
  call putitout "Allocate RESLIB   to //ISPLLIB  DD."
  call putitout "Allocate DFSMLIB  to //ISPMLIB  DD."
  call putitout "Allocate DFSPLIB  to //ISPPLIB  DD."
  call putitout "Allocate DFSSLIB  to //ISPSLIB  DD."
  call putitout " "
  call putitout "When analyzing a JES2 dump:"
  call putitout "---------------------------"
  call putitout "VERBX HASMFMTM - to get LE control blocks."
  call putitout "SYS1.*.SHASMIG contains verbexit code."
  call putitout "SYS1.*.SHASPNL0 contains panels for JES2 analysis."
  call putitout " "
  call putitout "When analyzing a JES3 dump:"
  call putitout "---------------------------"
  call putitout "SYS1.*.SIATTBL0 contains members required by"
  call putitout "  IATIJPCS. May need to allocate //IATTABL DD."
  call putitout " "
  call putitout "When analyzing a Language Environment (LE) dump:"
  call putitout "------------------------------------------------"
  call putitout "VERBX LEDATA  - to get LE control blocks."
  call putitout "CEEIPCSP needs to be in PARMLIB or //IPCSPARM DD."
  call putitout "May need to allocate MIGLIB as a TSOLIB or LNKLST."
  call putitout "May need to allocate SCEESAMP to //IPCSPARM DD."
  call putitout " "
  call putitout "When analyzing a Communication Server (VTAM/IP) dump:"
  call putitout "-----------------------------------------------------"
  call putitout "May need to allocate SISTCLS1 to //SYSPROC  DD."
  call putitout "May need to allocate SEZAINST to //SYSEXEC  DD "
  call putitout "        and allocate SEZAINST to //SYSPROC  DD."
  call putitout "May need to allocate SEZAHELP to //SYSHELP  DD "
  call putitout "May need to allocate SEZAMIG as a TSOLIB or LNKLST "
  call putitout "        and allocate SEZAMIG  to //ISPLLIB  DD."
  call putitout "May need to allocate SEZAMENU to //ISPMLIB  DD "
  call putitout "May need to allocate SEZAPENU to //ISPPLIB  DD "
  call putitout "May need to allocate SBLSPNL0 to //ISPTLIB  DD "
  call putitout "VERBX VTAMMAP - to get VTAM mapping."
  call putitout " "
  call putitout "When analyzing a STAND-ALONE dump:"
  call putitout "----------------------------------"
  call putitout "COPYCAPD     - copy a captured and yet unwritten dump."

/* --------------------------------------------------------- */
/* Use SETDEF and EVALDEF to normalize the ASID since it     */
/* will be used for comparison with the normalized form      */
/* further down.                                             */
/*                                                           */
/* Initially, ASID(x'0001') *MASTER* is used.                */
/* --------------------------------------------------------- */

      call putitout Copies("*",106)
  ASID = "ASID(x'0001')"
  "SETDEF LOCAL" asid
  Retc = rc
  If (Retc >< 0) Then
    Do
      MsgText = "Invalid ASID" asid
      Call Put            /* Transmit message              */
      Retc = 16
      Signal Exit
    End

  "EVALDEF LOCAL REXX(QUALIFICATION(qual))" /* qual may be null */
  Qual_Retc = rc

  If (qual = "") & (Length(asid) = 0) Then
    Do
      MsgText = "No ASID is available" /*                  @P1C*/
      Call Put                /* Transmit message              */
      MsgText = "A proper ASID must be provided" /*        @P1C*/
      Call Put                /* Transmit message              */
      Retc = 16
      Signal Exit
    End

/* --------------------------------------------------------- */
/* Determine the ASID number.                                */
/* --------------------------------------------------------- */

  If substr(asid,1,3) = 'CPU' Then,
    Do
      "SETDEF LOCAL NOCPU"
      "EVALDEF REXX(QUALIFICATION(asid))" /*               @P1C*/
      asid_number = substr(asid,14,4)
    End
  Else,
  If substr(asid,1,5) = 'NOCPU' Then,
    asid_number = substr(asid,14,4)
  Else
    parse var asid . "'" asid_number "'" .

  msgtext = ,
  "EVALUATE 10. LENGTH(4) REXX(STORAGE($CVTADDR))"
  Call Put
  msgtext
  call putitout "The CVT address is:" $CVTADDR

  $cvtaddr = c2x(d2c(c2d(x2c($cvtaddr)) + 0))
  msgtext = ,
  "EQUATE CVT" $cvtaddr". POSITION(X''-28'')",
    "REMARK(''Kens - Communication Vector Table'') STR(cvt)"
  Call Put
  "EQUATE CVT" $cvtaddr". POSITION(X'-28')",
    "REMARK('Kens - Communication Vector Table') STR(cvt)"
  equ_rc = rc
  if (equ_rc = 0) then,
    do
      call putitout "An EQUATE for symbol CVT has been defined as",
        "a structure."
      "STACK CVT"           /* Add it to the pointer list     */
      equ_rc = rc
      if (equ_rc = 0) then,
        do
          call putitout "  The CVT has been added to the STACK"
          call putitout "    The ''S'' line command will show storage."
          call putitout "    The ''F'' line command will format",
            "the control block."
        end
    end
  else,
    do
      MsgText = "EQUate CVT failed, rc="equ_rc
      Call Put
    end
  call putitout " "

  "EVALUATE "$cvtaddr".+8C LENGTH(4) REXX(STORAGE(ECVTADDR))"
  "EQUATE ECVT" ECVTaddr".",
    "REMARK('Kens - Extended CVT') STR(ecvt)"
  equ_rc = rc
  if (equ_rc = 0) then,
    do
      "STACK ECVT"          /* Add it to the pointer list     */
    end
  else,
    do
      MsgText = "EQUate ECVT failed, rc="equ_rc
      Call Put
    end

  "EVALUATE "$cvtaddr".+64 LENGTH(4) REXX(STORAGE(CUCBADDR))"
  "EQUATE CUCB" CUCBaddr".",
    "REMARK('Kens - C U C B') STR(CUCB)"
  equ_rc = rc
  if (equ_rc = 0) then,
    do
      "STACK CUCB"          /* Add it to the pointer list     */
    end
  else,
    do
      MsgText = "EQUate CUCB failed, rc="equ_rc
      Call Put
    end

  "EVALUATE "$cvtaddr".+128 LENGTH(4) REXX(STORAGE(JESCTADDR))"
  "EQUATE JESCT" JESCTaddr".",
    "REMARK('Kens - JES Control Task') STR(JESCT)"
  equ_rc = rc
  if (equ_rc = 0) then,
    do
      "STACK JESCT"         /* Add it to the pointer list     */
    end
  else,
    do
      MsgText = "EQUate JESCT failed, rc="equ_rc
      Call Put
    end

  "EVALUATE "$cvtaddr".+364 LENGTH(4) REXX(STORAGE(SVTADDR))"
  "EQUATE SVT" svtaddr".",
    "REMARK('Kens - Subsystem Vector Table') STR(SVT)"
  equ_rc = rc
  if (equ_rc = 0) then,
    do
      "STACK SVT"           /* Add it to the pointer list     */
    end
  else,
    do
      MsgText = "EQUate SVT failed, rc="equ_rc
      Call Put
    end

  "EVALUATE "svtaddr".+94 LENGTH(4) REXX(STORAGE(xmdADDR)) ASID(0002)"
  "EQUATE XMD" xmdaddr". ASID(0002)",
    "REMARK('Kens - Cross Memory Descriptor') STR(XMD)"
  equ_rc = rc
  if (equ_rc = 0) then,
    do
      "STACK XMD"           /* Add it to the pointer list     */
    end
  else,
    do
      MsgText = "EQUate XMD failed, rc="equ_rc
      Call Put
    end

  if (showitall = "y") then,
    do
      "EQUATE DUMPTIME 48. BLOCK(0) LENGTH(16) AREA",
        "REMARK('Time dump was taken.')"
      equ_rc = rc
      if (equ_rc = 0) then,
        do
          "STACK DUMPTIME" /* Add it to the pointer list     */
        end
      else,
        do
          MsgText = "EQUate dumptime failed, rc="equ_rc
          Call Put
        end
    end

  Call OUTTRAP "OFF"         /* Turn suppression off           */

/* --------------------------------------------------------- */
/* Use SETDEF to indicate that IPCS should suppress IPCS     */
/* messages that are not terminating.  Note that IPCS will   */
/* not suppress all IPCS informational, warning, error, and  */
/* severe messages.  See the IPCS documentation for details  */
/* on using SETDEF to suppress IPCS messages.                */
/* --------------------------------------------------------- */

  "SETDEF FLAG(TERMINATING)" /* Only display terminating
                                messages                       */

  signal exit

/* --------------------------------------------------------- */
/*   Let ISPF do the hard work.                              */
/* --------------------------------------------------------- */

Show_IPCS_members:
  ADDRESS ISPEXEC "CONTROL ERRORS RETURN"
  Numeric Digits 12
  MsgText = " "
  Call Put
  MsgText = " "
  Call Put
  MsgText = "Other members in SYSPROC and SYSEXEC with *IPCS*:"
  Call Put
  MsgText = "-------------------------------------------------"
  Call Put

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*
 * MAIN procedure which invokes sub-functions.                       *
 *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
  pattern_mask = "*IPCS*"
  ddname = "SYSPROC"
  MsgText = "SYSPROC:"
  Call Put
  MsgText = "--------"
  Call Put
  Call Init_MemList
  Call Main_MemList
  Call Term_MemList
  ddname = "SYSEXEC"
  MsgText = " "
  Call Put
  MsgText = "SYSEXEC:"
  Call Put
  MsgText = "--------"
  Call Put
  Call Init_MemList
  Call Main_MemList
  Call Term_MemList
  call putitout " "
  pattern_mask = "BLS*"
  ddname = "SYSPROC"
  MsgText = "SYSPROC:"
  Call Put
  MsgText = "--------"
  Call Put
  Call Init_MemList
  Call Main_MemList
  Call Term_MemList
  ddname = "SYSEXEC"
  MsgText = " "
  Call Put
  MsgText = "SYSEXEC:"
  Call Put
  MsgText = "--------"
  Call Put
  Call Init_MemList
  Call Main_MemList
  Call Term_MemList
  call putitout " "
  call putitout Copies("*",106)
  call putitout " "
  call putitout "CBF RTCT - shows which address spaces were dumped."
  "CBF RTCT"
  call putitout " "
  call putitout Copies("*",106)
  call putitout " "
  call putitout "CBF RTCT+9C? STR(SDUMP) VIEW(FLAGS) - what areas."
  "CBF RTCT+9C? STR(SDUMP) VIEW(FLAGS)"
  call putitout " "
  call putitout Copies("*",106)
  MsgText = "This is all of the help" uc_exec_name,
    "is designed to give."
  Call Put

  call putitout " "
  Call Putitout Copies("=",79)
  Call Putitout " "
  msgtext = " End of" strip(uc_exec_name)"."
  call put
  Call Putitout " "
  return


/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*
 * Initialize variables used by the code.                            *
 *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
Init_MemList:
  call fetch_dsnames
  Return


/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*
 * The meat and potatoes of the code.                                *
 *+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
Main_MemList:
    ZERRALRM = "NO"
    ZERRHM = "*"
    ADDRESS ISPEXEC "LMINIT DATAID(PDSID)",
      "DDNAME("ddname") ENQ(SHR)"
    IF (RC >< 0) THEN,
      DO
        ZERRSM = "FILE IN USE"
        ZERRLM = "THE FILE "ddname" IS IN USE"
        ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
        SIGNAL ABNEXIT
      END
    ADDRESS ISPEXEC "LMOPEN DATAID("PDSID")",
      "OPTION(INPUT)"
    MYCC = RC
    IF (MYCC >< 0) THEN,
      DO
        ZERRSM = "FILE FAILED TO OPEN"
        ZERRLM = "THE FILE "ddname" FAILED TO"
        ZERRLM = ZERRLM "OPEN RC=MYCC"
        ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
        SIGNAL ABNEXIT
      END
    PDSMBR = ""
  here = 0
Read_MemList:
    ADDRESS ISPEXEC "LMMLIST DATAID("PDSID")",
      "OPTION(LIST) MEMBER(PDSMBR) STATS(YES)",
      "PATTERN("pattern_mask")"
    MYCC = RC
    IF (MYCC >< 0) THEN,
      DO
        SIGNAL EOPM_MemList
      END
    PDSMBR = STRIP(PDSMBR,"B"," ")
    HERE = HERE + 1
    call putitout right("     "HERE,5) "=" left(PDSMBR,8),
      dd_dsn.zllib
    SIGNAL Read_MemList

EOPM_MemList:
    finish_rc = 0
    return

ABNEXIT:
    finish_rc = 4
    return

term_MemList:
    ADDRESS ISPEXEC "LMMLIST DATAID("PDSID") OPTION(FREE)"
    ADDRESS ISPEXEC "LMCLOSE DATAID("PDSID")"
    return
/*                                                              */
/* FIND OUT WHAT IS ALREADY ALLOCATED                           */
fetch_dsnames:
  PSATOLD  = STORAGE(21C,4)                     /* POINTER TO TCB  */
  PTRTIOT  = STORAGE(D2X(C2D(psatold)+12),4)    /* POINTER TO TIOT */
  tiotptr = d2c(c2d(ptr2tiot)+24)
  tiotelen = c2d(STORAGE(D2X(C2D(tiotptr)+0),1))
  alcddname_list = ""
  max_entry = 0
  do while tiotelen > 0
    tiotflag = c2d(STORAGE(D2X(C2D(tiotptr)+1),1))
    tiotddnm = STORAGE(D2X(C2D(tiotptr)+4),8)
    IF BITAND(tiotflag,'80'X) = '80'X THEN,
      do
        if tiotddnm = copies("00"x,8) then,
          do
            Leave
          end
        else,
        if tiotddnm >< "        " then,
          do
            alcddname = tiotddnm
          end
        tioejfcb = storage(d2x(c2d(tiotptr)+12),3)
        jfcb = swareq(tioejfcb)
        jfcbqnam  = strip(alcddname,"B"," ")
        jfcbdsn   = strip(storage(d2x(jfcb+000),44),"B"," ")
        jfcbelnm  = strip(storage(d2x(jfcb+044),8),"B"," ")
        if jfcbelnm <> "" then,
          fullname = jfcbdsn"("jfcbelnm")"
        else,
          fullname = jfcbdsn
        if (alcddname = ddname) then,
          do
            max_entry = max_entry + 1
            dd_dsn.max_entry = fullname
          end
      end
    tiotptr = D2C(C2D(tiotptr)+tiotelen)
    tiotelen = c2d(STORAGE(D2X(C2D(tiotptr)+0),1))
  end
  Return

/*-------------------------------------------------------------------*/
swareq:   Procedure
If right(c2x(Arg(1)),1) <> 'F' Then    /* Swa=Below ?                */
  Return c2d(Arg(1))+16                /* Yes, return sva+16         */
sva = c2d(Arg(1))                      /* Convert to decimal         */
tcb = ptr(540)                         /* Tcb psatold                */
jscb = ptr(tcb+180)                    /* Jscb tcbjscb               */
qmpl = ptr(jscb+244)                   /* Qmpl jscbqmpi              */
qmat = ptr(qmpl+24)                    /* Qmat qmadd                 */
Do While sva>65536
  qmat = ptr(qmat+12)                  /* Next qmat qmat+12          */
  sva=sva-65536                        /* 010006F -> 000006F         */
End
Return ptr(qmat+sva+1)+16

/*-------------------------------------------------------------------*/
ptr:  Return c2d(storage(d2x(Arg(1)),4)) /* Return a pointer         */

/*
  ISPEXEC  LMMSTATS DATAID(DATAID)   MEMBER(MBRNAME) VERSION(VER1)    +
                    MODLEVEL(MOD1)   CREATED(CDATE)  MODDATE(MDATE)   +
                    MODTIME(MTIME)   CURSIZE(CSIZE)  INITSIZE(ISIZE)  +
                    MODRECS(MRECS)   USER(USERID)    CREATED4(CDATE4) +
                    MODDATE4(MDATE4) DELETE

     LMMSTATS - NAME OF THE DIALOG SERVICE
     DATAID   - THE DATA-ID ASSOCIATED WITH THE DATA SET CONTAINING THE
              - MEMBER(S) WHOSE STATISTICS ARE BEING SET.
     MBRNAME  - THE MEMBER(S) NAMES WHOSE STATISTICS ARE BEING SET.
                FULLY OR PARTIALLY SPECIFIED MEMBER NAMES ARE ACCEPTED
                AS WELL AS '*' FOR ALL MEMBERS.
     VER1     - OPTIONAL, THE VERSION NUMBER, VALID VALUES ARE 1 - 99.
     MOD1     - OPTIONAL, THE MODIFICATION LEVEL, VALID VALUES ARE
                0 - 99.
     CDATE    - OPTIONAL, THE DATE THE MEMBER WAS CREATED. FORMAT MUST
                BE YY/MM/DD OR A NLS FORMAT.
     CDATE4   - OPTIONAL, THE DATE THE MEMBER WAS CREATED. FORMAT MUST
                BE YYYY/MM/DD OR A NLS FORMAT.
     MDATE    - OPTIONAL, THE DATE THE MEMBER WAS LAST MODIFIED. FORMAT
                MUST BE YY/MM/DD OR A NLS FORMAT.
     MDATE4   - OPTIONAL, THE DATE THE MEMBER WAS LAST MODIFIED. FORMAT
                MUST BE YYYY/MM/DD OR A NLS FORMAT.
     MTIME    - OPTIONAL, THE TIME THE MEMBER WAS LAST MODIFIED. FORMAT
                MUST BE HH:MM.
     CSIZE    - OPTIONAL, THE CURRENT NUMBER OF RECORDS IN THE MEMBER.
                VALID VALUES ARE 0 - 65535.
     ISIZE    - OPTIONAL, THE INITIAL NUMBER OF RECORDS IN THE MEMBER
                WHEN IT WAS CREATED. VALID VALUES ARE 0 - 65535.
     MRECS    - OPTIONAL, THE NUMBER OF RECORDS MODIFIED IN THE MEMBER.
                VALID RANGE IS 0 - 65535.
     USERID   - OPTIONAL, THE USERID OF THE USER WHO LAST MODIFIED THE
                DATA.
     DELETE   - OPTIONAL, INDICATES THAT STATISTICS ARE TO BE DELETED.

   EXAMPLE:  ISPEXEC LMMSTATS DATAID(&INDID ) MEMBER(MBRNAME)        +
                              VERSION(20)     MODLEVEL(0)
*/
  IF rc     <>  0 THEN    /* RETURN CODES -                        */
    DO                    /*  4 - NO MEMBERS MATCH PATTERN.        */
    END                   /*    - NO MEMBER IN DATA SET.           */
  ELSE                    /*  8 - MEMBER NOT FOUND.                */
    DO                    /* 10 - NO DATA SET ASSOCIATED WITH THE  */
    END                   /*      GIVEN DATA-ID.                   */
                          /* 12 - INVALID PARAMETER VALUE.         */
                          /*    - DATA SET IS NOT OPEN OR IS NOT   */
                          /*      PARTITIONED.                     */
                          /* 20 - SEVERE ERROR, UNABLE TO CONTINUE.*/
  Return


/* --------------------------------------------------------- */
/* Restore the default environment that was active upon      */
/* entry.                                                    */
/* --------------------------------------------------------- */
Exit:

  Call Show_IPCS_members     /* Using ISPF services of course  */

restore_exit:
  if (retc >< 0) then,
    do
      call putitout "Return code >< 0, =" retc"."
      call putitout "Exiting early!"
    end

  "SETDEF "con prt src trm "FLAG("flg")"

  If (Qual_retc = 0) Then
    "SETDEF "qual
No_restore_exit:
  Exit Retc

HALT:
  failed_condition = Condition("D")

  Parse Source,
    Host_Environment Call_Type Uc_Exec_Name,
    everythingelse
  call putitout " "
  Call Putitout Copies("=",79)
  Call Putitout " "
  msgtext = " Halt of" strip(uc_exec_name)"."
  call put
  Call Putitout " "
      exit 4

error:
  failed_condition = Condition("D")
      msgtext = left("Hey, you really need to be in IPCS!",76)
      say msgtext
      msgtext = failed_condition
      say msgtext
      exit 12

Put: procedure expose MsgText  /*                        @P1C*/
  /* --------------------------------------------------------- */
  /* Function:  Put                                            */
  /*                                                           */
  /* Invoke the IPCS NOTE subcommand to transmit data to the   */
  /* terminal, IPCS print file or both, depending on the IPCS  */
  /* message routing default.                                  */
  /*                                                           */
  /* Input:     Data to transmit.                              */
  /*                                                           */
  /*                                                           */
  /* Output:    Data is transmitted.                           */
  /* --------------------------------------------------------- */

  "NOTE '"MsgText"' ASIS"     /*                           @P1C*/
  if (rc>0) then
    signal Put_Error
  return

Putitout:
  parse arg msgtext
  call put
  return

Put_Error:
  say msgtext
  return
