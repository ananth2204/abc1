rexx_SDUMPKT:  /* We still need rexx in comment if read from SYSPROC */
  rexxpgm_version = "02.12"
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================

 Dataset:  REXX(SDUMPKT)
           Storage DUMP ala Kenneth Tomiak's version.
 Author:   ?
 Contact:  "Kenneth Tomiak"<CBT_Ken@KTomiak.BIZ>
 Syntax:   SDUMPKT {Address {O+/-ffset} {Length} {Display {Rows}}}
           tso %sdumpkt '0'x 128
             Takes the defaults for Offset, Length, and Display.
           tso %sdumpkt '0'x +16 4 t 33
             Without keyword labels the positional sequence is needed.
           tso %sdumpkt =a'0'x =0+16 =l4 =dt =r33
             When using the keyword labels they can be in any order.
           1) Address: The starting location in X, D, or named format.
              DEFAULT: "0"x
              Mimimum: "0"x | 0
              Maximum: 4TB-16 ((2 ** 40) - 16)
                       "03FFFFFFFFF0"x
                       4398046511088
              Named  : Limited control block support.
                        ACEE
                        ASCB
                        ASXB
                        CVT
                        PSA
                        RCVT
           2) Offset : Added to starting address in X or D format.
              DEFAULT: +"0"x
                +    : Move starting address forward.
                -    : Move starting address backward.
              Minimum: Result cannot be less than 0
              Maximum: Result cannot exceed starting address maximum.
           3) Length:  How much storage is retrieved.
              DEFAULT: 256
              Minimum: 16
              Maximum: output-based.
           4) {T}erminal | {P}anel | {V}iew
              DEFAULT: Panel when ISPF is ACTIVE, else TSO/E.
                Panel: ISPF based table.
                TSO/E: linemode.
                View : temporary data set.
           5) {R}ows for TSO/E paging.
              DEFAULT: 23 on a 24x80 terminal.
              If you set this higher than what fits you will not get
              the heading at the top.

 Overview: Similar to using IPCS to view storage.

-----------------------------------------------------------------------

 History of Modifications
 ------------------------
vv.mm When     Who / What you did ... (Newest change at the top.)
----- -------- --------------------------------------------------------
02.12 20170524 KTOMIAK "Kenneth Tomiak"
               1) Add TBDISPL processing routines for zcmd and ztdsel.
                  a) "B" shows bits.
                  b) "2" Grab more storage using 24 bit address.
                  c) "3" Grab more storage using 31 bit address.
                  d) "6" Grab more storage using 64 bit address.
----- -------- --------------------------------------------------------
02.11 20170523 KTOMIAK "Kenneth Tomiak"
               1) Working on Panel display: TBCREATE and TBADD.
               2) Reworked plib_allocated to be smarter.
----- -------- --------------------------------------------------------
02.10 20170522 KTOMIAK "Kenneth Tomiak"
               1) View can have more data per row and >bracketed<.
               2) "T" Show adjusted @address on double-word boundary.
----- -------- --------------------------------------------------------
02.09 20170521 KTOMIAK "Kenneth Tomiak"
               1) Filling in length for named control block support.
               2) Sorted and added CVTPFX, ECVT, and XCVT.
               3) Display named control block information before start.
               4) Added dump of data to a temporary data set and
                  invoke view.
                  1) Additional logic for @display.
                  2) Allocate //SDUMP.
               5) Converted the heading lines to stem a variable.
               6) Validate @address => 0 and not above 4TB.
----- -------- --------------------------------------------------------
02.09 20170520 KTOMIAK "Kenneth Tomiak"
               mailto:CBT_Ken@KTomiak.BIZ
               1) Decrease NUMERIC DIGITS to 14 (handles 4 Terabytes).
               2) Handle Terabyte address and length (12/6 characters).
               3) First pass of TSO/E display.
               4) More mucking with decimal/hexadecimal input.
               5) Added 24x80 screen chunking of output.
               6) Additional work on the intake of user parameters.
                  a) Keyword labels.
                  b) Limited control block name support. Needs length.
                     1) ACEE
                     2) ASCB
                     3) ASXB
                     4) CVT
                     5) PSA
                     6) RCVT
               7) Quietly try CLEAR and prompt base on result.
               8) Modified TSO/E headings and output lines.
               9) Started processing Offset.
----- -------- --------------------------------------------------------
02.08 20170519 KTOMIAK "Kenneth Tomiak"
               mailto:CBT_Ken@KTomiak.BIZ
               1) Reformatted to conform with PUTKTM-REXX.
               2) Support decimal address conversion to hexadecimal.
               3) Added ISPF panel support.
----- -------- --------------------------------------------------------
02.07 20161218 SBGOLOB "Sam Golob"
               mailto:sbgolob@cbttape.org
               1) Increase NUMERIC DIGITS to 20 to allow higher storage
                  addresses.
----- -------- --------------------------------------------------------
01.00 19940329 ??
               1) Original base code.
----- -------- --------------------------------------------------------

-----------------------------------------------------------------------

STANDARD GLOBAL DISCLAIMER
--------------------------
The author explicitly disavows any claim whatsoever about the
correctness or functionality of this program, and disclaims liability
for anything and everything bad that might happen in connection with,
before, during, or after using it. I have tried to make it work Right,
and I am personally pretty confident that it does, but everybody makes
mistakes, so if you use it, you do so at your own risk.

=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */

  Parse Upper Arg all_parameters
  Numeric Digits 14  /* Handles Terabyte+ */

  my_rc = Prologue()
  If (my_rc = 0) Then my_rc = Storybook()
  my_rc = Epilogue()
  Return 0

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Initialize variables used in this ISPF-based REXX Dialog.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Prologue:
/* Logic manipulated variables. */
  return_code = 0
  plib_alloc = -1
  table_create = -1
  @all_char = XRange("00"x,"FF"x)
  @show_char = ,
    "................" || ,
    "................" || ,
    "................" || ,
    "................" || ,
    "........."        || XRange("4A"x,"4F"x) || ,
    "..........."      || XRange("5A"x,"5F"x) || ,
    XRange("60"x,"61"x) || "........"  || XRange("6A"x,"6F"x) || ,
    ".........."       || XRange("7A"x,"7F"x) || ,
    "." || XRange("81"x,"89"x) || "......" || ,
    "." || XRange("91"x,"99"x) || "......" || ,
    ".." || XRange("A2"x,"A9"x) || "......" || ,
    "................" || ,
    "." || XRange("C1"x,"C9"x) || "......" || ,
    "." || XRange("D1"x,"D9"x) || "......" || ,
    ".." || XRange("E2"x,"E9"x) || "......" || ,
    XRange("F0"x,"F9"x) || "......"
  @dflt_address = D2X(0)
  @page_length = 23
  @dflt_length = 226
  @dflt_offset = 0
  @dflt_display = "T"
  @min_address = 0
  @max_address = ((2 ** 40) * 4) - 16  /* 4TB-16 */
/* User manipulated variables. */
  @address = ""
  @offset = ""
  @length = ""
  @display = ""
/* Intake user input. */
  @num_parameters = Words(all_parameters)
  If (@num_parameters > 0) Then Do
    @pos_offset = Pos("+",all_parameters)
    @neg_offset = Pos("-",all_parameters)
    @key_equals = Pos("=",all_parameters)
    Select
      When (@key_equals > 0) Then Do
        @address = ""
        @offset = ""
        @length = ""
        @display = ""
        @rows = ""
        Do kx = 1 to @num_parameters
          @keywd.kx = Strip(Word(all_parameters,kx),"L","=")
          Select
            When (Left(@keywd.kx,1) = "A") Then Do
              Parse Var @keywd.kx . +1 @address
            End
            When (Left(@keywd.kx,1) = "O") Then Do
              Parse Var @keywd.kx . +1 @offset
            End
            When (Left(@keywd.kx,1) = "L") Then Do
              Parse Var @keywd.kx . +1 @length
            End
            When (Left(@keywd.kx,1) = "D") Then Do
              Parse Var @keywd.kx . +1 @display
            End
            When (Left(@keywd.kx,1) = "R") Then Do
              Parse Var @keywd.kx . +1 @rows
            End
            Otherwise Do
              Say "Keyword garbage:" @keywd.kx "ignored."
            End
          End
        End
      End
      When ((@pos_offset > 0) | (@neg_offset > 0)) Then Do
        Parse Var all_parameters ,
          @address @offset @length @display @rows @naught
      End
      Otherwise Do
        Parse Var all_parameters ,
          @address @length @display @rows @naught
        @offset = ""
      End
    End
    If (@display = "T") Then do
      say @address DataType(@address) DataType(@address,"U")
    End

/* Check address for control block names. */
    If (DataType(@address,"U") > 0) Then Do
      PSA  = 0                                     /* Pointer to PSA */
      CVTPTR = STORAGE(D2X(PSA + 16),4)            /* Pointer to CVT */
      CVT  = C2D(BitAnd(CVTPTR,"7FFFFFFF"X))  /* Flip high order bit */
      RCVT = C2d(Storage(D2x(CVT + 992),4))     /* point to RACF CVT */
      ASCB = Storage(D2x(PSA + 548),4)       /* Pointer to curr ASCB */
      ASXB = Storage(D2x(C2d(ASCB)+108),4)       /* Get ASXB address */
      Select
        When (@address = "ACEE") Then Do
          ACEE = Storage(D2x(C2d(ASXB)+200),4)   /* Get ACEE address */
          @address = C2X(ACEE)
          @length = 192
          @cbname = "ACEE"
          @cbmacro = "IHAACEE"
        End
        When (@address = "ASCB") Then Do
          @address = C2X(ASCB)
          @length = 384
          @cbname = "ASCB"
          @cbmacro = "IHAASCB"
        End
        When (@address = "ASXB") Then Do
          @address = C2X(ASXB)
          @length = 776
          @cbname = "ASXB"
          @cbmacro = "IHAASXB"
        End
        When (@address = "CVTPFX") Then Do
          @address = D2X(CVT - 256)
          @length = 256
          @cbname = "CVT-256"
          @cbmacro = "CVT"
        End
        When (@address = "CVT") Then Do
          @address = D2X(CVT)
          @length = 1280
          @cbname = "CVT"
          @cbmacro = "CVT"
        End
        When (@address = "ECVT") Then Do
          ECVT = STORAGE(D2X(PSA + 1952),8)       /* Pointer to ECVT */
          @address = C2X(ECVT)
          @length = 928
          @cbname = "ECVT"
          @cbmacro = "IHAECVT"
        End
        When (@address = "PSA") Then Do
          @address = D2X(PSA)
          @length = 200
          @cbname = "PSA"
          @cbmacro = "IHAPSAE"
        End
        When (@address = "RCVT") Then Do
          @address = D2X(RCVT)
          @length = 2308
          @cbname = "RCVT"
          @cbmacro = "ICHPRCVT"
        End
        When (@address = "XCVT") Then Do
          XCVT = STORAGE(D2X(PSA + 1960),8)       /* Pointer to XCVT */
          @address = C2X(XCVT)
          @length = 40
          @cbname = "XCVT"
          @cbmacro = "IHAXCVT"
        End
        Otherwise Do
          Say "Control block" @address "unsupported."
          @address = ""
        End
      End
      If (@display = "T") Then do
        say "Control block:" Left(@cbname,8) "Macro:" Left(@cbmacro,8) ,
          "Address:" Right(@address,12) "Length:" @length
      End
    End
    Else Do
      If (Pos("X",@address) > 0) Then Do
        Select
          When (Pos('"',@address) > 0) Then Do
            Parse Var @address '"' @address '"' .
          End
          When (Pos("'",@address) > 0) Then Do
            Parse Var @address "'" @address "'" .
          End
          Otherwise Do
            @address = Strip(@address,"B","X")
          End
        End
      End
      Else Do
        @address = D2X(@address)
      End
    End
  End
/* Validate address, offset, length, and output. */
  If (@address = "") Then @address = @dflt_address
  If (@offset = "") Then @offset = @dflt_offset
  If (@length = "") Then @length = @dflt_length
  If (@display = "") Then @display = @dflt_display
  If (@rows = "") Then @rows = @dflt_rows

  If (Pos("X",@offset) > 0) Then Do
    Select
      When (Pos('"',@offset) > 0) Then Do
        Parse Var @offset '"' @offset '"' .
      End
      When (Pos("'",@offset) > 0) Then Do
        Parse Var @offset "'" @offset "'" .
      End
      Otherwise Do
        @offset = Strip(@offset,"B","X")
      End
    End
  End
  Else Do
    @offset = D2X(Strip(Strip(@offset,"L","-"),"L","+"))
  End

/* Adjust address when offset is used. */
  If (@neg_offset > 0) Then Do
    @address = D2X(X2D(@address) - X2D(@offset))
  End
  Else Do
    @address = D2X(X2D(@address) + X2D(@offset))
  End

/* Validate @length and @address are within reasonable ranges. */
  Select
    When (@display = "V") Then do
      If (@length > (32 * 1024)) Then Do
        @length = 1024 * 32
        Say "Lowering length to a 32K page size ("@length")."
        Say "That is a lot of data to view."
      End
    End
    Otherwise Do
      If (@length > 4096) Then Do
        Say "Lowering length to a 4K page size (4096)."
        Say "That is a lot of data to look at."
        @length = 4096
      End
    End
  End
  Select
    When (x2d(@address) < 0) Then Do
      Say "Check your address and offset, less than 0 is not an option."
      return 1
    End
    When (x2d(@address) > @max_address) Then do
      Say "@address exceeds 4TB, lowering by @length."
      @address = D2X(@max_address - @length)
    End
    When ((X2D(@address) + @length) > @max_address) Then Do
      Say "address + length exceeds 4TB, lowering length."
      @length = @max_address - X2D(@address)
    End
    Otherwise Do
    End
  End

/* Calculate a double word boundary. */
  blocks16 = Ceiling_rtn(@length, 16) / 16

/* Display specific setup. */
  Select
    When (@display = "P") Then Do
      If (SYSVAR("SYSISPF") = "ACTIVE") Then Do
        Address IspExec "CONTROL ERRORS RETURN"
        plib_alloc = plib_allocated()
        If (plib_alloc >< 0) Then Do
          Say ""
          Say "Tried to load panels."
          Say "Process failed, RC("plib_alloc")."
          Say "Defaulting to TSO/E linemode."
          Say ""
          @display = "T"
        End
        Else Do
          table_create = create_table()
          If (table_create >< 0) Then Do
            Say ""
            Say "Say TBCreate failure, RC("table_create")."
            Say "Defaulting to TSO/E linemode."
            Say ""
            @display = "T"
          End
        End
      End
    End
    When (@display = "V") Then Do
      sdump_alloc = sdump_allocate()
      If (sdump_alloc > 1) Then Do
        Say ""
        Say "Tried to allocate a temporary data set."
        Say "Allocate failed, RC("sdump_alloc")."
        Say "Defaulting to TSO/E linemode."
        Say ""
        @display = "T"
      End
    End
    Otherwise Do
    End
  End

  Select
    When (@display = "T") Then Do
      say "Press <ENTER> when ready to begin."
      Parse Pull @Response
      @heading.  = " "
      @heading.0 = 6
      @heading.1 = " "
      @heading.2 = ,
        "Storage dump beginning at" Right(@address,12,"0") ,
        "for" blocks16 "blocks."
      @heading.3 = " "
      @heading.4 = ,
        "                    <------ HEXADECIMAL DATA ------->" ,
        "<-- CHARACTER -->"
      @heading.5 = ,
        " Hex ADDRESS OFFSET 0011223344556677+8899AABBCCDDEEFF" ,
        "01234567+89ABCDEF"
      @heading.6 = ,
        "------------ ------ ----------------+----------------" ,
        "--------+--------"

      @trap_state = TRAPMSG("On")
      @msg_state = Msg("On")
      @outtrap_state = OutTrap(@caughtit.)
      Address TSO "CLEAR"
      @clear_works = RC
      @outtrap = OutTrap("Off")
      @msg_state = Msg(@msg_state)
      @trap_state = TRAPMSG(@trap_state)
      Say ""
    End
    When (@display = "V") Then Do
      @heading.  = " "
      @heading.0 = 6
      @heading.1 = " "
      @heading.2 = ,
        "Storage dump beginning at" Right(@address,12,"0") ,
        "for" @length "bytes."
      @heading.3 = " "
      @heading.4 = ,
        "                    >-Character data-<"
      @heading.5 = ,
        " Hex ADDRESS OFFSET  0123456789ABCDEF"
      @heading.6 = ,
        "------------ ------ >----------------<"
    End
    Otherwise Do
    End
  End

  Return 0

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 This is the main processing routine.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Storybook:
  Select
    When (@display = "P") Then do
      function_rc = add_storage(@address)
  Address IspExec "TBTOP SDUMPTBL"
    End
    When (@display = "T") Then do
      @page_used = 0
      function_rc = tso_heading()
      @hex_address = D2X(Floor_rtn(X2D(@address), 16))
      @indent = X2D(@address) - X2D(@hex_address)
      If (@indent > 0) Then @add_spaces = Copies(">",@indent)
      Else @add_spaces = ""
      offset = 0
      @amount = 16 - @indent
      @hex_address = D2X(X2D(@hex_address) + @indent)
      Do i = 1 to blocks16
        @chr_data = @add_spaces""STORAGE(@hex_address,@amount)
        If (Length(@chr_data) = 0) Then Do
          outline = Right(@hex_address,12,0) Right(D2X(offset),6,0) ,
            "--Storage inaccessible--"
        End
        Else Do
          @hex_data = C2X(@chr_data)
          outline = Right(@hex_address,12,0) Right(D2X(offset),6,0) ,
              SubStr(@hex_data,1,8)""SubStr(@hex_data,9,8)"|" || ,
              SubStr(@hex_data,17,8)""SubStr(@hex_data,25,8) ,
              Showable(SubStr(@chr_data,1,8))"|" || ,
              Showable(SubStr(@chr_data,9,8))
        End
        Say outline
        @hex_address = D2X(X2D(@hex_address) + @amount)
        @page_used = @page_used + 1
        @add_spaces = ""
        offset = offset + @amount
        @amount = 16
        @indent = 0
        If (@page_used > @page_length) Then Do
          function_rc = tso_heading()
        End
      End
    End
    When (@display = "V") Then do
      Do rx = 1 to @heading.0
        outline = @heading.rx
        Address IspExec "LMPut" ,
          "DATAID(&TMPDSN) MODE(INVAR) DATALOC(outline) DATALEN(80)"
      End
      @hex_address = D2X(Floor_rtn(X2D(@address), 16))
      @indent = X2D(@address) - X2D(@hex_address)
      If (@indent > 0) Then @add_spaces = Copies(">",@indent)
      Else @add_spaces = ""
      offset = 0
      @amount = 16 - @indent
      @hex_address = D2X(X2D(@hex_address) + @indent)
      @chr_data = @add_spaces||STORAGE(@hex_address,@length)
      Do While (@chr_data >< "")
        Parse Var @chr_data @chr_chunk +16 @chr_data
        outline = Right(@hex_address,12,0) ,
          Right(D2X(offset),6,0) ,
          ">"@chr_chunk"<"
        Address IspExec "LMPut" ,
          "DATAID(&TMPDSN) MODE(INVAR) DATALOC(outline) DATALEN(80)"
        @hex_address = D2X(X2D(@hex_address) + @amount)
        @add_spaces = ""
        offset = offset + @amount
        @amount = 16
        @indent = 0
      End
    End
    Otherwise Do
    End
  End
  Select
    When (@display = "P") Then Do
      function_rc = table_processing()
    End
    When (@display = "T") Then Do
      Say ""
    End
    When (@display = "V") Then Do
      outline = " "
      Address IspExec "LMPut" ,
        "DATAID(&TMPDSN) MODE(INVAR) DATALOC(outline) DATALEN(80)"
      Address IspExec,
        "LMCLOSE DATAID(&TMPDSN)"
      Address IspExec "View DATAID(&TMPDSN)"
                               /* Return codes                     */
                               /* 16 - No members in library       */
                               /* 18 - VSAM processing unavailable */
                               /* 20 - Severe error                */
                               /*                                  */
      Address IspExec,
        "LMFREE DATAID(&TMPDSN)"
    End
    Otherwise Do
    End
  End
  Return 0

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Clean up before termination.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Epilogue:
  If (sdump_alloc = 0) Then Do
    "FREE File("sdump_dd")"
  End
  If (table_create = 0) Then Do
    Address IspExec "TBEND SDUMPTBL"
  End
  If (plib_alloc = 0) Then Do
    Address IspExec,
      "LIBDEF ISPPLIB"
    Address IspExec,
      "LMFREE DATAID(&TMPPNL)"
    Address TSO ,
      "FREE File("panel_dd")"
  End
  Return 0

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Create an ISPF table for TBDISPL.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
create_table:
  Address IspExec,
    "TBEnd SDUMPTBL"
  Address IspExec,
    "TBCREATE SDUMPTBL" ,
    "Keys(SDUMPDEC) Names(SDUMPADD," ,
      "ZSL1, SDUMPWD1, ZSL2, SDUMPWD2, ZSL3, SDUMPWD3," ,
      "ZSL4, SDUMPWD4, SDUMPCHR)" ,
    "REPLACE",
    "NOWRITE"
  tbcreate_rc = RC
  /* Return codes                      */
  /*  4 - Duplicate table exists but   */
  /*      "replace" specified          */
  /*  8 - Table already exists;        */
  /*      "replace" not specified      */
  /* 12 - Table in use; enq failed     */
  /* 16 - Table input library not      */
  /*      allocated with "write"       */
  /* 20 - Severe error                 */
  If (tbcreate_rc >< 0) Then Do
    Say "Uh Oh, table(SDUMPTBL) failed to create, rc("tbcreate_rc")."
    Return tbcreate_rc
  End
  Address IspExec "TBSort SDUMPTBL Fields(sdumpdec,N,A)"
  Return 0

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 Add storage to the table.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
add_storage:
  Parse Arg @stg_address
  @hex_address = D2X(Floor_rtn(X2D(@stg_address), 16))
  @indent = X2D(@stg_address) - X2D(@hex_address)
  If (@indent > 0) Then @add_spaces = Copies(".",@indent)
  Else @add_spaces = ""
  offset = 0
  @amount = 16 - @indent
  @hex_address = D2X(X2D(@hex_address) + @indent)
  Do i = 1 to blocks16
    Address IspExec "TBVClear SDUMPTBL"
    sdumpdec = X2D(@hex_address)
    sdumpadd = Right(@hex_address,14,0)
    @chr_data = STORAGE(@hex_address,@amount)
    If (Length(@chr_data) = 0) Then Do
      sdumpchr = ">Inaccessible <"
    End
    Else Do
      sdumpchr = @add_spaces""@chr_data
      @hex_data = C2X(sdumpchr)
      sdumpchr = Showable(sdumpchr)
      @word = 0
      Do While (@hex_data >< "")
        @word = @word + 1
        Parse Var @hex_data @chunk +8 @hex_data
        Select
          When (@word = 1) Then SDUMPWD1 = @chunk
          When (@word = 2) Then SDUMPWD2 = @chunk
          When (@word = 3) Then SDUMPWD3 = @chunk
          When (@word = 4) Then SDUMPWD4 = @chunk
          Otherwise Do
            Say "Too much data" @chunk
          End
        End
      End
    End
    Address IspExec "TBAdd SDUMPTBL"
                                  /* Return codes                    */
                                  /*  4 - Number of rows parameter   */
                                  /*      was specified but storage  */
                                  /*      was only obtained for a    */
                                  /*      single row                 */
                                  /*  8 - Key tables: a row with the */
                                  /*      same key already exists;   */
                                  /*      crp set to top             */
                                  /* 12 - Table is not open          */
                                  /* 20 - Severe error               */
    tbadd_rc = RC
    If (tbadd_rc > 8) Then Do
      Say "TBadd error, rc("tbadd_rc")."
    end
    @hex_address = D2X(X2D(@hex_address) + @amount)
    @add_spaces = ""
    offset = offset + @amount
    @amount = 16
    @indent = 0
  End
  Return 0

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 More than just rounding.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Floor_rtn: Procedure
  Parse Arg @number, @height
  @occurs = (@number % @height)
  Select
    When (@remainder = 0) Then @adjustment = 0
    When (@number < 0) Then @adjustment = -1
    Otherwise Do
      @adjustment = 0
    End
  End
  @result = (@occurs + @adjustment) * @height
  return @result

Ceiling_rtn: Procedure
  Parse Arg @number, @height
  @occurs = @number % @height
  @remainder = @number - (@occurs * @height)
  Select
    When (@remainder = 0) Then @adjustment = 0
    When (@number > 0) Then @adjustment = 1
    Otherwise Do
      @adjustment = 0
    End
  End
  @result = (@occurs + @adjustment) * @height
  return @result

Showable: Procedure Expose @all_char @show_char
  Arg @arg
  Return Translate(@Arg,@show_char,@all_char)

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
-----------------------------------------------------------------------
 Clear the screen and use TSO mode.
-----------------------------------------------------------------------
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
tso_heading:
  If (@page_used > 0 ) Then Do
    If (@clear_works = 1) Then Do
      say "Press the <CLEAR> key and then <ENTER> for the next screen."
      Parse Pull @Response
    End
    Else Do
      say "Press <ENTER> for the next screen."
      Parse Pull @Response
      Address TSO "CLEAR"
      Say @heading.1
    End
  End
  Do rx = 2 to @heading.0
    say @heading.rx
  End
  @page_used = 6
  Return 0

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
-----------------------------------------------------------------------
 Keep processing user requests while the table is displayed.
-----------------------------------------------------------------------
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
table_processing:
  keep_going = 0
  Do While keep_going = 0
    ZCMD = ""
    Address IspExec,
      "TBDISPL SDUMPTBL PANEL(SDUMPPRI)" ,
      "MSG(ISPZZ102)"
    keep_going = RC
    If (keep_going = 8) Then Do
      ZERRALRM = "NO"
      ZERRSM = "OK"
      ZERRLM = "You asked to end this dialog."
      Address IspExec "VPUT (ZERRSM ZERRLM ZERRHM ZERRALRM) SHARED"
      Address IspExec "SETMSG MSG(ISRZ002)"
      Return 0
    End
    If (keep_going > 4) Then Do
      ZERRALRM = "YES"
      ZERRSM = "NO"
      zerrlm = "Uh Oh, panel(SDUMPPRI)",
        "failed to tbdispl, rc("keep_going")."
      Address IspExec "VPUT (ZERRSM ZERRLM ZERRHM ZERRALRM) SHARED"
      Address IspExec "SETMSG MSG(ISRZ002)"
      If (Pos("E",debuglvl) > 0) Then Do
        Say "my_control_rtn: jump out RC:" keep_going
      End
      Return keep_going
    End
    keep_going = 0
    now_what = zcmd_processing()
    If (now_what >< 0) then keep_going = 1
    If (keep_going = 0) Then now_what = zdtsel_processing()
  End
  Return 0

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
-----------------------------------------------------------------------
 See what the COMMAND field has in it.
-----------------------------------------------------------------------
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
zcmd_processing:
  uppercase_zcmd = translate(zcmd)
  zcmd = ""
  resume_address = ""
  Parse Var uppercase_zcmd uppercase_verb uppercase_noun
  Select
    When (uppercase_verb = "GRAB") Then Do
      If (Pos("X",uppercase_noun) > 0) Then do
        Select
          When (Pos("'",uppercase_noun) > 0) Then do
            Parse Var uppercase_noun "'" resume_address "'" .
          end
          When (Pos('"',uppercase_noun) > 0) Then do
            Parse Var uppercase_noun '"' resume_address '"' .
          end
          When (Pos("X",uppercase_noun) > 0) Then do
            resume_address = Strip(uppercase_noun,"B","X")
          end
          Otherwise Do
            resume_address = uppercase_noun
          End
        End
      End
      Else Do
        resume_address = D2X(uppercase_noun)
      End
      functrion_rc = add_storage(resume_address)
    End
    When (uppercase_verb = "SORT") Then Do
      Address IspExec "TBSort SDUMPTBL Fields(sdumpdec,N,A)"
    End
    Otherwise Do
      NOp
    End
    If (resume_address >< "") Then Do
      functrion_rc = loc_storage(resume_address)
    End
  End
  return 0

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
-----------------------------------------------------------------------
 Process the )MODEL section of the panel - ROW selection.
-----------------------------------------------------------------------
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
zdtsel_processing:
  Do While (ZTDSELS > 0)
    ZSL1 = To_Uppercase(ZSL1)
    ZSL2 = To_Uppercase(ZSL2)
    ZSL3 = To_Uppercase(ZSL3)
    ZSL4 = To_Uppercase(ZSL4)
    resume_address = ""
    Select
      When (ZSL1 = "") Then Do
        NOp
      End
      When (ZSL1 = "B") Then Do
        function_rc = show_as_Bits(X2C(SDUMPWD1))
      End
      When (ZSL1 = "2") Then Do
        resume_address = C2X(BitAnd(X2C(sdumpwd1),"7FFFFFFF"X))
        functrion_rc = add_storage(resume_address)
      End
      When (ZSL1 = "3") Then Do
        resume_address = sdumpwd1
        functrion_rc = add_storage(resume_address)
      End
      When (ZSL1 = "6") Then Do
        resume_address = sdumpwd1||sdumpwd2
        functrion_rc = add_storage(resume_address)
      End
      Otherwise Do
        Say "1: Ignoring:" ZSL1"."
      End
    End
    Select
      When (ZSL2 = "") Then Do
        NOp
      End
      When (ZSL2 = "B") Then Do
        function_rc = show_as_Bits(X2C(SDUMPWD2))
      End
      When (ZSL2 = "2") Then Do
        resume_address = C2X(BitAnd(X2C(sdumpwd2),"7FFFFFFF"X))
        functrion_rc = add_storage(resume_address)
      End
      When (ZSL2 = "3") Then Do
        resume_address = sdumpwd2
        functrion_rc = add_storage(resume_address)
      End
      When (ZSL2 = "6") Then Do
        resume_address = sdumpwd2||sdumpwd3
        functrion_rc = add_storage(resume_address)
      End
      Otherwise Do
        Say "2: Ignoring:" ZSL2"."
      End
    End
    Select
      When (ZSL3 = "") Then Do
        NOp
      End
      When (ZSL3 = "B") Then Do
        function_rc = show_as_Bits(X2C(SDUMPWD3))
      End
      When (ZSL3 = "2") Then Do
        resume_address = C2X(BitAnd(X2C(sdumpwd3),"7FFFFFFF"X))
        functrion_rc = add_storage(resume_address)
      End
      When (ZSL3 = "3") Then Do
        resume_address = sdumpwd3
        functrion_rc = add_storage(resume_address)
      End
      When (ZSL3 = "6") Then Do
        resume_address = sdumpwd3||sdumpwd4
        functrion_rc = add_storage(resume_address)
      End
      Otherwise Do
        Say "3: Ignoring:" ZSL3"."
      End
    End
    Select
      When (ZSL4 = "") Then Do
        NOp
      End
      When (ZSL4 = "B") Then Do
        function_rc = show_as_Bits(X2C(SDUMPWD4))
      End
      When (ZSL4 = "2") Then Do
        resume_address = C2X(BitAnd(X2C(sdumpwd4),"7FFFFFFF"X))
        functrion_rc = add_storage(resume_address)
      End
      When (ZSL4 = "3") Then Do
        resume_address = sdumpwd4
        functrion_rc = add_storage(resume_address)
      End
      When (ZSL4 = "3") Then Do
        resume_address = sdumpwd4
        Address IspExec "TBSkip"
        resume_address = resume_address||sdumpwd1
        functrion_rc = add_storage(resume_address)
      End
      Otherwise Do
        Say "4: Ignoring:" ZSL4"."
      End
    End
    ZSL1 = ""
    ZSL2 = ""
    ZSL3 = ""
    ZSL4 = ""
    Address IspExec "TBPUT SDUMPTBL"
    If (ZTDSELS > 1) Then Do
      Address IspExec "TBDISPL SDUMPTBL"
    End
    Else Do
      ZTDSELS = 0
    End
    Address IspExec "TBSort SDUMPTBL Fields(sdumpdec,N,A)"
    If (resume_address >< "") Then Do
      functrion_rc = loc_storage(resume_address)
    End
  End
  Return 0

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
-----------------------------------------------------------------------
 Find where the last added storage first row is.
-----------------------------------------------------------------------
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
loc_storage:
  Parse Arg loc_address
  Address IspExec "TBTOP SDUMPTBL"
  Address IspExec "TBVClear SDUMPTBL"
  sdumpdec = X2D(loc_address)
  Address IspExec "TBSARG SDUMPTBL" ,
    "Next NameCond(SDUMPDEC,GE)"
  tbsarg_rc = RC
  Address IspExec "TBScan SDUMPTBL"
  tbscan_rc = RC
  return 0

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
-----------------------------------------------------------------------
 Convert a string to bits and show on a pop-up panel.
-----------------------------------------------------------------------
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
show_as_Bits:
  Parse Arg the_string
  SDUMPBIT = "Bits:" one_word
  bits_l = Length(the_string)
  If ((bits_l + (bits_l * 9) + 9) > 79) Then Do
    Say "Too much data for a panel display:"
    Say SDUMPBIT
    Do bx = 1 to bits_l
      one_byte = C2B(SubStr(the_string,bx,1))
      @bin = Copies(" ",bx * 2)
      Say "   " @bin C2X(one_byte) "=" one_byte
    End
  End
  Else Do
    SDUMPBIT = SDUMPBIT "="
    Do bx = 1 to bits_l
      one_byte = C2B(SubStr(the_string,bx,1))
      @bin = Copies(" ",bx * 2)
      SDUMPBIT = SDUMPBIT  one_byte
    End
    Address IspExec "AddPop"
    Address IspExec "Display Panel(SDUMPINF)"
    Address IspExec "RemPop"
  End
  Return 0
  info_rc = 0
  Do While (info_rc = 0)
    Address IspExec "Display Panel(SDUMPINF)"
    info_rc = RC
  End

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
-----------------------------------------------------------------------
 Allocate a temporary PDS to hold storage dump.
-----------------------------------------------------------------------
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
sdump_allocate:
  If (sdump_alloc = 1) Then Return 1

  sdump_dd = "SDUMP"Right(Random(999),3,"0")
  "ALLOC NEW DEL File("sdump_dd") DSOrg(PS) SPace(5,15) TRACK",
         "REUSE RECFM(F B) BLKSIZE(0) LRECL(80) UNIT(SYSALLDA)"
  sdump_rc = RC
  If (sdump_rc >< 0) Then do
    Say "Allocation of sdump dd failed, rc("sdump_rc")."
    Return sdump_rc
  End
  Address IspExec,
    "LMINIT DATAID(TMPDSN) ENQ(EXCLU) DDNAME("sdump_dd")"
  lminit_rc = RC
  If (lminit_rc > 0) Then Do
    Say "LMINIT Failure, RC("lminit_rc")."
    return lminit_rc
  End
  Address IspExec,
    "LMOPEN DATAID("tmpdsn") OPTION(OUTPUT)"
  If (lmopen_rc > 0) Then Do
    Say "LMopen Failure, RC("lmopen_rc")."
    return lmopen_rc
  End
  Return 1

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 Convert string to lowercase.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
To_Lowercase: Parse arg myarg
  If (lowercase_letters = "LOWERCASE_LETTERS") Then Do
    lowercase_letters = "abcdefghijklmnopqrstuvwxyz"
  End
  If (uppercase_letters = "UPPERCASE_LETTERS") Then Do
    uppercase_letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  End
  Return Translate(myarg,lowercase_letters,uppercase_letters)

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 Convert string to uppercase.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
To_Uppercase: Parse arg myarg
  If (lowercase_letters = "LOWERCASE_LETTERS") Then Do
    lowercase_letters = "abcdefghijklmnopqrstuvwxyz"
  End
  If (uppercase_letters = "UPPERCASE_LETTERS") Then Do
    uppercase_letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  End
  Return Translate(myarg,uppercase_letters,lowercase_letters)

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
-----------------------------------------------------------------------
 Function to turn a character string into binary bits.
-----------------------------------------------------------------------
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
C2B: PROCEDURE EXPOSE bits
  data = ARG(1)
  IF (bits.F <> "1111") THEN DO
    bits.0="0000"; bits.1="0001"; bits.2="0010"; bits.3="0011"
    bits.4="0100"; bits.5="0101"; bits.6="0110"; bits.7="0111"
    bits.8="1000"; bits.9="1001"; bits.A="1010"; bits.B="1011"
    bits.C="1100"; bits.D="1101"; bits.E="1110"; bits.F="1111"
  END
  c2x_data = C2X(data)
  bs = ""
  DO ix = 1 TO LENGTH(c2x_data)
    bx = SUBSTR(c2x_data,ix,1)
    bs =bs||bits.bx
  END
  RETURN bs

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
-----------------------------------------------------------------------
 Allocate a temporary PDS and load dynamically generated panels.
-----------------------------------------------------------------------
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
plib_allocated:
  If (plib_alloc = 0) Then Return 0

  panel_dd = "BULK"Right("0000"RANDOM(99999),4)
  "ALLOC NEW DEL F("panel_dd") DSO(PO) DIR(1) SP(3,3) TRACK",
         "REUSE RECFM(F B) BLKSIZE(0) LRECL(80) UNIT(SYSDA)"
  alloc_rc = RC
  If (alloc_rc >< 0) Then do
    Say "Allocation of BULK dd failed, rc("alloc_rc")."
    Return alloc_rc
  end
  Address IspExec,
    "LMINIT DATAID(TMPPNL) ENQ(EXCLU) DDNAME("panel_dd")"
  Signal On Syntax Name End_Of_Code
  @search = "/*PLIB"
  a_ix = get_sigl_near_plib()            /* Get near PLIB using SIGL */
  Do Until srcline = "/*PLIB"            /* Find PLIB */
    srcline = sourceline(a_ix)
    a_ix = a_ix + 1
  End
  srcline = sourceline(a_ix)
  Signal On Syntax Name End_Of_Code
  @search = "PLIB*/"
  Do Until (srcline = "PLIB*/")
    Select
      When (Left(srcline,6) = "PANEL ") Then Do
        Parse var srcline . panelname .
        Address IspExec,
          "LMOPEN DATAID(&tmppnl) OPTION(OUTPUT)"
      End
      When (srcline = "PANELEND") Then Do
        Address IspExec,
          "LMMADD DATAID(&TMPPNL) MEMBER("panelname")"
        Address IspExec,
          "LMClose DATAID(&tmppnl)"
        lmclose_rc = RC
                                /* Return codes                     */
                                /*  8  - Data set is not open       */
                                /* 10  - No data set associated     */
                                /*       with the given data id     */
                                /* 20  - Severe error               */
      End
      Otherwise Do
        Address IspExec,
          "LMPUT DATAID(&TMPPNL) MODE(INVAR)" ,
          "DATALOC(SRCLINE) DATALEN(80)"
      End
    End
    a_ix = a_ix + 1
    srcline = sourceline(a_ix)
  End
  Address IspExec,
    "LIBDEF ISPPLIB LIBRARY ID("panel_dd") STACK"
  Return 0

End_Of_Code :
  Signal Off Syntax
  Say "End of source found before" @search "was found."
  return 4

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
-----------------------------------------------------------------------
 Part of capturing where the /*PLIB data starts.  */
-----------------------------------------------------------------------
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
SYNTAX:
  Signal OFF SYNTAX
  say "Did not use this"
  Return SIGL+1

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
-----------------------------------------------------------------------
get_sigl_near_plib thru /*PLIB absolutley MUST remain in the same sequence. */
-----------------------------------------------------------------------
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
get_sigl_near_plib:
  Signal ON SYNTAX
  Return next_line()
next_line:
  Return sigl+4

/*PLIB
PANEL SDUMPPRI
)ATTR DEFAULT(%+_) FORMAT(MIX)
 /* % TYPE(TEXT) INTENS(HIGH)                                         */
 + TYPE(TEXT) INTENS(LOW)
 /* _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(Left)                    */
 _ TYPE(Input)  Intens(High) Caps(Off) Just(Left) Hilite(uscore)
 # Type(Output) Intens(High) Caps(Off) Just(Left) Pas(On)
 @ Type(Output) Intens(High) Caps(Off) Just(Left)
 $ Type(Output) Intens(Low)  Caps(Off) Just(Left)
)BODY EXPAND(\\)
%-\-\- Storage DUMP -\-\-
%COMMAND ==>_ZCMD \ \%SCROLL ==>_ZSCR
%
+       Address   HexWord1   HexWord2   HexWord3   HexWord4   Character  1->16
+-------------- - -------- - -------- - -------- - --------   ----------------
)Model
$SDUMPADD      _Z#SDUMPWD1_Z#SDUMPWD2_Z#SDUMPWD3_Z#SDUMPWD4+|$SDUMPCHR        +|
)INIT
.ZVARS = 'ZSL1, ZSL2, ZSL3, ZSL4'
)REINIT
)PROC
)END
PANELEND
PANEL SDUMPINF
)ATTR DEFAULT(%+_)
 %   TYPE(TEXT) INTENS(HIGH) Caps(Off)
 +   TYPE(TEXT) INTENS(LOW) Caps(Off)
 _   TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) Hilite(UScore)
 $ Type(Output) Caps(Off) Intens(Low) Color(Green)
 ? TYPE(PIN)                         /* panel instruction line       */
 # TYPE(NT)                          /* normal text attribute        */
 ! TYPE(DT)                          /* description text             */
)BODY Expand(\\)
%-\-\- SDUMP Word to Bit Conversion -\-\-
#
%&SDUMPBIT
#
)INIT
)PROC
)END
PANELEND
PLIB*/
