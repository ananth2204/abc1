/* rexx */
Rexx_Steroids:
  rexxpgm_version = "01.04"           /* ver lev */

  PARSE ARG all_my_arguments
  NUMERIC DIGITS 16                   /* Handles Petabyte addressing */

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 This code drives Initialization, Process, and Termination routines.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Main_Routine:
  return_code = Initialization_Routine()
  IF (return_code = 0) THEN DO
    return_code = Process_Routine()
  END
  IF (return_code = -1) THEN DO
    return_code = 0
  END
  return_code = Termination_Routine()
  RETURN return_code

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================

  Dataset:  DEMO.REXX(STEROIDS)
  Contact: "Kenneth Tomiak"<CBT_Ken@KTomiak.BIZ>
  Overview: Demonstrate advanced REXX features.  This code was developed
            to be part of a SHARE presentation. It serves no other
            purpose than to demonstrate how to put some advanced
            features to use.

  Syntax:   %Steroids |optional parameters|
  Example:  %Steroids ALL

-----------------------------------------------------------------------

  Important Guidelines:
  This code was written as a basis for presenting some of the advanced
  features you can put to use in REXX for a www.SHARE.org technical
  conference.

-----------------------------------------------------------------------

  Disclaimers:

  I support my code using a best-effort philosophy. As long as I have
  access to an image where I can test, I will maintain it as best as I
  can. IF you find a flaw, please DO let me know.

  The code released by Kenneth E. Tomiak does not alter anything.  It
  merely uses features to show how someone might access the information
  available on a system. It is up to you to THEN make use of that
  information in a meaningful way.

  In no event will the author be liable to the user of this code for any
  damages. Including, but not limited to, any lost profits, lost savings
  or other incidental, consequential or special damages arising out of
  the operation of or inability to operate this code, even IF the user
  has been advised of the possibility of such damages.

  With that stated, enjoy all this has to offer.

-----------------------------------------------------------------------

  History of Modifications
  ------------------------
vv.mm When     Who  /  What you did
----- -------- --------------------------------------------------------
01.04 20180504 KTOMIAK "Kenneth Tomiak"<CBT_Ken@KTomiak.BIZ>
               1) Stylize using Edit Macro @putktm:
                  Programming Using The Kenneth Tomiak Method.
----- -------- --------------------------------------------------------
01.04 20180504 "Kenneth E Tomiak"<KenTomiak@KTomiak.org>
               1) Add Scan for GETMAIN.
----- -------- --------------------------------------------------------
01.03 20180423 "Kenneth E Tomiak"<KenTomiak@KTomiak.org>
               1) Stylize using the
                  Programming Using The Kenneth Tomiak Method.
----- -------- --------------------------------------------------------
01.02 20180201 KTOMIAK "Kenneth Tomiak"<CBT_Ken@KTomiak.BIZ>
               1) Reduced NUMERIC DIGITS to 16, Petabyte is enough.
----- -------- --------------------------------------------------------
01.01 20180201 KTOMIAK "Kenneth Tomiak"<CBT_Ken@KTomiak.BIZ>
               1) Stylized using the 'Programming Using The Kenneth
                  Tomiak Method' (PUTKTM).
               2) Corrected steriods to steroids.
               3) Added several SWAREQ replacement methods.
                  a) IBM's needed Obtain_Storage.
                  b) Swareq22 checks a bit for above the bar.
                     Uses NUMERIC DIGITS 20.
----- -------- --------------------------------------------------------
01.00 20041028 Kenneth E. Tomiak <K.Tomiak@Schunk-IT.com>
               1) Original code
----- -------- --------------------------------------------------------

-----------------------------------------------------------------------

=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================

=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Initialization_Routine:
  return_code = 0

  ARG uc_whatever_parameters_were_passed
  PARSE ARG samecase_whatever_parameters_were_passed

  SAY ""
  SAY "REXX on Steroids for Systems Programmers"
  SAY "----------------------------------------"
  SAY "Ever find yourself looking to DO an ad-hoc function and just"
  SAY "didn't want to code, compile, link, and THEN execute? The"
  SAY "difficult takes awhile, the impossible a little longer. Minus"
  SAY "25 percent IF you used REXX. From accessing storage (control"
  SAY "blocks), extending your environment, through calling system"
  SAY "exits, this session will cover topics for those seeking to"
  SAY "take REXX beyond the normal read and process a file."
  SAY ""

  NUMERIC DIGITS 16          /* Handles Petabyte Addressing */

  getmain_addr = " "

  SIGNAL ON FAILURE          /* IF something fails, goto estae EXIT  */
  SIGNAL ON SYNTAX           /* IF I code it wrong, goto estae EXIT  */
  SIGNAL ON NOVALUE          /* IF something nulls, goto estae EXIT  */

  SAY "/*-------------------------------------------------------*/"
  SAY "/* GET VERSION OF REXX AND HOW REXX CODE WAS EXECUTED    */"
  SAY "/*-------------------------------------------------------*/"
  PARSE VERSION version_rexx_ver,
                version_rexx_lvl,
                version_rexx_date
  SAY "Version:" version_rexx_ver,
      "Level:"  version_rexx_lvl,
      "Date:"   version_rexx_date

  PARSE SOURCE  source_host_env,
                source_call_type,
                source_uc_exec_name,
                source_HOSTDD,
                source_HOSTDSN,
                source_nf_exec_name,
                source_initial_cmd_env,
                source_asid_name,
                source_char8_user_token,
                source_HOSTOTHER
  SAY "Source:" source_host_env,
      "Call:"   source_call_type,
       "Exec:"  source_uc_exec_name,
       "DD:"    source_HOSTDD,
       "DSN:"   source_HOSTDSN,
       "NF:"    source_nf_exec_name,
       "ICmd:"  source_initial_cmd_env,
       "ASID:"  source_asid_name,
       "Token:" source_char8_user_token,
       "Other:" source_HOSTOTHER

/*---------------------------------------------------------------------
   See IF ISPF is active. IF not, re-invoke ourselves after
   starting ISPF.
---------------------------------------------------------------------*/
  msgwas.0 = 0
  msgwas = OUTTRAP("NOMSGS.")             /* msgwas will = 'NOMSGS.' */
  SAY "Messaging("msgwas")"
  IF (source_host_env <> "OMVS") THEN DO /* ARE WE UNDER UNIX ?  */
    IF (SYSVAR("SYSISPF") <> "ACTIVE") THEN DO /* NO, ISPF IS NOT  */
      SAY ""
      SAY "------------------------------------------------------"
      SAY "- Redrive this command under ISPF.                   -"
      SAY "------------------------------------------------------"
      "ISPSTART CMD("source_uc_exec_name")"
      return_code = -1
      RETURN return_code
    END
    /*
    ELSE DO
        CALL Main_Routine
    END
    */
  END
  ELSE DO /* We are under OMVS    */
    SAY "NOT FROM UNIX SYSTEM SERVICES!"
    return_code = 16
    RETURN 16
  END
  msgnow = OUTTRAP("OFF")
  SAY "Messaging("msgnow")"
  IF (msgwas.0 > 0) THEN DO
    SAY ""
    SAY "Captured messages:"
    SAY "------------------"
    DO mx = 1 TO msgwas.0
      SAY RIGHT("     "mx,5) msgwas.mx
    END
    SAY ""
  END

/*--------------------------------------------------------------*/
/* Userid and system name using function CALLs                  */
/*--------------------------------------------------------------*/
  sys_sysuid = SYSVAR("SYSUID")
  mvs_sysname = MVSVAR("SYSNAME")

/*--------------------------------------------------------------*/
/* Format all of the accessible PSA fields in one swoop         */
/*   IHAPSA = STORAGE(some_hexoffset,4105)                      */
/*--------------------------------------------------------------*/
  IHAPSA = STORAGE(0,2048)   /* we can only see part of the PSA */
  CALL Fmt_Ihapsa

/*--------------------------------------------------------------*/
/* System name following control blocks.                        */
/*   ADDRESSABILITY TO CVT FROM PSA                             */
/*   ADDRESSABILITY TO SMCA, THEN GET SMF SYSTEM ID             */
/*--------------------------------------------------------------*/
  Ptr2psa = 0
  stg_cvtPtr = STORAGE(D2X(Ptr2psa + 16),4)
  stg_cvtsmca = STORAGE(D2X(C2D(stg_cvtPtr)+197),3)
  stg_smfid = STORAGE(D2X(C2D(stg_cvtsmca)+16),4)

/*--------------------------------------------------------------*/
/* GET jobname, STEP, AND PROCEDURE from TIOT                   */
/*--------------------------------------------------------------*/
  stg_psatold = STORAGE(21C,4)                   /* Ptr TO TCB */
  stg_Ptrjscb = STORAGE(D2X(C2D(stg_psatold)+180),4) /* Ptr TO jscb */
  stg_Ptrssib = STORAGE(D2X(C2D(stg_Ptrjscb)+316),4) /* Ptr TO SSIB */
  stg_jobtype = STORAGE(D2X(C2D(stg_Ptrssib)+12),3) /* Ptr TO JT   */
  stg_tasknum = STORAGE(D2X(C2D(stg_Ptrssib)+15),5) /* Ptr TO JN   */
  stg_Ptrtiot = STORAGE(D2X(C2D(stg_psatold)+12),4) /* Ptr TO TIOT */
  stg_jobname = STRIP(STORAGE(D2X(C2D(stg_Ptrtiot)),8),"B"," ")
  stg_stepname = STRIP(STORAGE(D2X(C2D(stg_Ptrtiot)+8),8),"B"," ")
  stg_procname = STRIP(STORAGE(D2X(C2D(stg_Ptrtiot)+16),8),"B"," ")

  SAY COPIES("*",23)
  SAY "*" LEFT("CMD",8) "*" LEFT(source_uc_exec_name,8) "*"
  SAY COPIES("*",23)
  SAY "*" LEFT("USERID",8) "*" LEFT(sys_sysuid,8) "*"
  SAY "*" LEFT("TASK# ",8) "*" LEFT(stg_jobtype||stg_tasknum,8) "*"
  SAY "*" LEFT("Jobname",8) "*" LEFT(stg_jobname,8) "*"
  SAY "*" LEFT("Step",8) "*" LEFT(stg_stepname,8) "*"
  SAY "*" LEFT("Proc",8) "*" LEFT(stg_procname,8) "*"
  SAY COPIES("*",23)

  RETURN return_code

/*===================================================================*/
/* ESTAE error handling routines placed here for performance.        */
/*- handle any problems encountered                                 -*/
/*-------------------------------------------------------------------*/
Failure:
  SAY "Failure occured on line" SIGL
  CALL Termination_Routine
  EXIT 12
Syntax:
  SAY "Failure occured on line" SIGL
  CALL Termination_Routine
  EXIT 12
Novalue:
  SAY "Failure occured on line" SIGL
  CALL Termination_Routine
  EXIT 12

/*===================================================================*/
/* Main body of code.                                                */
/*===================================================================*/
/*-------------------------------------------------------------------*/
/*- The main exec routine.                                          -*/
/*-------------------------------------------------------------------*/
Process_Routine:
  PSATOLD = STORAGE(21C,4)                      /* POINTER TO TCB  */
  PtrTIOT = STORAGE(D2X(C2D(PSATOLD)+12),4)     /* POINTER TO TIOT */
  tiotPtr = D2C(C2D(PtrTIOT)+24)                /* TIOT pointer    */
  tiotelen = C2D(STORAGE(D2X(C2D(tiotPtr)+0),1))
  ddname_list = ""
  MAX_ENTRY=0
  DO WHILE ,
   (tiotelen > 0) ,

    tiotflag = C2D(STORAGE(D2X(C2D(tiotPtr)+1),1))
    tiotddnm = STORAGE(D2X(C2D(tiotPtr)+4),8)
    IF (BITAND(tiotflag,'80'X) = '80'X) THEN DO /* active ddname   */
      IF (tiotddnm = COPIES("00"x,8)) THEN DO
        LEAVE
      END
      IF (tiotddnm <> "        ") THEN DO
        ddname = tiotddnm
      END
      tioejfcb = STORAGE(D2X(C2D(tiotPtr)+12),3)
  /*  jfcb = Swareq_Old(tioejfcb)  */
      jfcb = Swareq22(tioejfcb)
  /*  jfcb = SWAREQ(psatold, tioejfcb)  */
      IF (jfcb <> "*") THEN DO
        jfcbqnam = ddname
        jfcbdsn = STRIP(STORAGE(D2X(jfcb+000),44),"B"," ")
        jfcbelnm = STRIP(STORAGE(D2X(jfcb+044),8),"B"," ")
        IF (jfcbelnm <> "") THEN DO
          fullname = "'"jfcbdsn"("jfcbelnm")'"
        END
        ELSE DO
          fullname = "'"jfcbdsn"'"
        END
        SAY ddname " DSN="fullname
      END
    END
    tiotPtr = D2C(C2D(tiotPtr)+tiotelen)
    tiotelen = C2D(STORAGE(D2X(C2D(tiotPtr)+0),1))
  END

/*--------------------------------------------------------------*/
/* Parse a variable with self-defining variable length fields.  */
/*   Note: The length field must be a pre-determined length.    */
/*--------------------------------------------------------------*/
  myvar = "03Ken06Tomiak"
  PARSE VAR myvar len1 +2 data1 +(len1),
                  len2 +2 data2 +(len2)
  SAY data2","data1

/*--------------------------------------------------------------*/
/* Ensure DEMO.LOADLIB is accessible.                           */
/*--------------------------------------------------------------*/
  scancheck_rc = Scan_Steplib_And_Tsolib()
  IF (scancheck_rc = 0) THEN DO
    SAY "Unable to fully demonstrate GETMAIN" ,
      "at this time."
    SAY "There is a STEPLIB/TSOLIB type of issue."
    SAY ""
    SAY "Your OPTIONS are:"
    SAY "1) Update and submit DEMO.CNTL(DEMOATCP)."
    SAY "2) Alter your TSO/E logon PROCEDURE so" ,
      "that STEPLIB includes:"
    SAY "  a) DEMO.LOADLIB"
    SAY "3) Prior to launching ISPF" ,
      "(from the TSO/E READY prompt) issue TSOLIB:"
    SAY "  a) DEMO.CLIST(ADDTSOLB) is an example of how to use"
    SAY "     TSOLIB before ISPF is started."
  END
  ELSE DO

/*--------------------------------------------------------------*/
/* CALL an assembler function to getmain some dynamic memory    */
/*--------------------------------------------------------------*/
    getmain_data = COPIES("Kenneth E.Tomiak--",10)
    getmain_use = LENGTH(getmain_data)
    getmain_len = 4096
    SAY "Requesting" getmain_use "bytes of storage for" getmain_len"."
    getmain_addr = GETMAIN('OBTAIN',getmain_len)
    xgetmain_addr =  C2X(D2C(getmain_addr))
    IF (getmain_addr <= 0) THEN DO
      SAY source_uc_exec_name "GETMAIN failed, RC("getmain_addr")"
      return_code = 24
      RETURN return_code
    END

/*--------------------------------------------------------------*/
/* Change the data. Verify the change worked.                   */
/*--------------------------------------------------------------*/
    odata = STORAGE(xgetmain_addr,getmain_use,getmain_data)
    ndata = STORAGE(xgetmain_addr,getmain_use)
    IF (ndata <> getmain_data) THEN DO
      SAY "My attempt to change my own getmain'ed area failed."
    END

/*--------------------------------------------------------------*/
/* IF a foreground session THEN allocate SYSOUT.                */
/*--------------------------------------------------------------*/
    sysvar_sysenv = SYSVAR("SYSENV")
    IF (sysvar_sysenv = "FORE") THEN DO
      "ALLOC FILE(SYSOUT) NEW DELETE REUSE" ,
        "UNIT(SYSDA) TRACKS SPACE(2,2)" ,
        "DSORG(PS) RECFM(V B A) BLKSIZE(0) LRECL(255)"
    END

/*--------------------------------------------------------------*/
/* Different ways to CALL a program.                            */
/*--------------------------------------------------------------*/
    stemout.0 = 2
    stemout.1 = " "
    plist = xgetmain_addr||ndata
    exit_name = "CBL3PARM"
    stemout.2 = "STEROIDS:" exit_name plist
    SAY "TSO COMMAND::                  "
    SAY stemout.2
    "EXECIO * DISKW SYSOUT (STEM stemout."
    exit_name plist                 /* let it be done like a TSO cmd */

    stemout.2 = "STEROIDS: CALLing *(cbl3parm)" plist
    SAY "indirect CALL:: parameter      "
    SAY "Expect message: IKJ56003I PARM FIELD TRUNCATED" ,
      "TO 100 CHARACTERS"
    SAY stemout.2
    "EXECIO * DISKW SYSOUT (STEM stemout."
    ADDRESS TSO,
      "CALL *(cbl3parm)" "'"plist"'"    /* passes parameter          */

    stemout.2 = "STEROIDS: link" exit_name plist
    SAY "link:: parameter               "
    SAY stemout.2
    "EXECIO * DISKW SYSOUT (STEM stemout."
    ADDRESS LINK exit_name  plist       /* passes parameter          */

    stemout.2 = "STEROIDS: linkpgm" exit_name '"plist"'
    SAY "linkpgm:: Ptr with no length   "
    SAY stemout.2
    "EXECIO * DISKW SYSOUT (STEM stemout."
    ADDRESS LINKPGM exit_name "plist"  /* passes Ptr with no lengths */

    stemout.2 = "STEROIDS: linkmvs" exit_name plist
    SAY "linkmvs:: Ptr with length      "
    SAY stemout.2
    "EXECIO * DISKW SYSOUT (STEM stemout."
    ADDRESS LINKMVS exit_name "plist"   /* passes Ptrs with lengths  */

    stemout.2 = "STEROIDS: attach" exit_name plist
    SAY "attach:: parameter             "
    SAY stemout.2
    "EXECIO * DISKW SYSOUT (STEM stemout."
    ADDRESS ATTACH  exit_name  plist    /* passes parameter          */

    stemout.2 = "STEROIDS: attachpgm" exit_name plist
    SAY "attachpgm:: Ptr with no length "
    SAY stemout.2
    "EXECIO * DISKW SYSOUT (STEM stemout."
    ADDRESS ATTCHPGM exit_name "PLIST" /* passes Ptr with no lengths */

    stemout.2 = "STEROIDS: attachmvs" exit_name plist
    SAY "attachmvs:: Ptr with length    "
    SAY stemout.2
    "EXECIO * DISKW SYSOUT (STEM stemout."
    ADDRESS ATTCHMVS exit_name "plist"  /* passes Ptrs with lengths  */
    "EXECIO 0 DISKW SYSOUT (FINIS"

/*--------------------------------------------------------------*/
/* IF a foreground session THEN view SYSOUT.                    */
/*--------------------------------------------------------------*/
    IF (sysvar_sysenv = "FORE") THEN DO
      ADDRESS ISPEXEC ,
        "LMINIT DATAID(fileid) DDNAME(SYSOUT) ENQ(SHR)"
      lminit_rc = RC
      ADDRESS ISPEXEC ,
        "VIEW DATAID("fileid")"
      ADDRESS ISPEXEC ,
        "LMCLOSE DATAID("fileid")"
      lmclose_rc = RC
      "FREE FILE(SYSOUT)"
    END

/*--------------------------------------------------------------*/
/* Free the getmain'ed area.                                    */
/*--------------------------------------------------------------*/
    faddr = GETMAIN('RELEASE',getmain_len,getmain_addr)
    SAY "RELEASE RC("faddr")"
    getmain_addr = " "
  END

/*--------------------------------------------------------------*/
/* Use a CONSOLE to display active tasks.                       */
/*--------------------------------------------------------------*/
  myid = SYSVAR("SYSUID")
  "CONSOLE ACTIVATE NAME("myid"2)"       /* avoid dupe name with sdsf*/
  ADDRESS CONSOLE "CART REXXMVS"         /* ESTABLISH A CART TOKEN   */
  "CONSPROF SOLDISPLAY(NO)  SOLNUM(1000)"
  "CONSOLE SYSCMD(d a,l) CART('REXXMVS')"
                                         /* GET RESPONSE FROM CMD    */
  GETCODE = GETMSG('PRTMSG.','SOL','REXXMVS',,5)
  SELECT
    WHEN (getcode = 0) THEN DO /* GOT RESPONSE?             */
      SAY "CONSOLE MESSAGES FOR 'D a,l'"
      DO I = 1 TO PRTMSG.0
        SAY PRTMSG.I                   /* DISPLAY CONSOLE MSGS     */
      END
    END
    WHEN (getcode = 4) THEN DO /* No msg to retrieve        */
      SAY "No messages to retrieve. See job log for messages,",
         "RETURN CODE IS "GETCODE" "
    END
    OTHERWISE DO
      SAY "FAILED TO GET MESAGES FOR COMMAND 'd a,l',",
          "RETURN CODE IS "GETCODE" "
    END
  END
  "CONSPROF SOLDISPLAY(YES) UNSOLDISPLAY(YES)"
  "CONSOLE DEACTIVATE"                   /* STOP THE CONSOLE SESSION */


  dsn = "SYS1.LINKLIB"
  mbr = "IEFBR14"
  ADDRESS ISPEXEC "CONTROL ERRORS RETURN"
  ADDRESS ISPEXEC "LMINIT DATAID(DATAID)",
    "DATASET('"dsn"') ENQ(SHR)"
  mycc = RC
                                /* RETURN codes                     */
                                /*  8 - Data set or file not        */
                                /*      allocated                   */
                                /*    - DDname not found            */
                                /*    - Data set or file            */
                                /*      organization not supported  */
                                /* 12 - Invalid parameter value     */
                                /* 16 - Truncation or translation   */
                                /*      error in accessing dialog   */
                                /*      variables                   */
                                /* 20 - Severe error                */
  IF (mycc <> 0) THEN DO
    SAY "THE FILE" dsn "COULD NOT BE LMINITed("mycc")"
    return_code = 32
    RETURN return_code
  END
  ADDRESS ISPEXEC "LMOPEN DATAID("DATAID")",
    "OPTION(INPUT)"
  mycc = RC
  IF (mycc > 0) THEN DO
    SAY "THE FILE" dsn "FAILED TO OPEN RC="mycc
    return_code = 32
    RETURN return_code
  END
  lmget_ctr = 0
  ADDRESS ISPEXEC,
    "LMMFIND DATAID("dataid") MEMBER("mbr")",
    "LRECL(reclen) RECFM(recfmvr)",
    "STATS(NO)"
Lmget_Loop:
  ADDRESS ISPEXEC,
    "LMGET DATAID("dataid") MODE(INVAR) DATALOC(locvar)",
    "DATALEN(lenvar) MAXLEN(32760)"
  ispexec_rc = RC
  IF (ispexec_rc = 8) THEN DO
    SIGNAL End_Lmget
  END
  lmget_ctr = lmget_ctr + 1
  loadmem.lmget_ctr = locvar
/* RETURN codes                     */
/*  8 - End-of-file condition       */
/* 10 - No data set or file         */
/*      associated with the dataid  */
/* 12 - Data file not OPEN          */
/*    - Data file not OPEN for      */
/*      input                       */
/*    - LMMFIND was not done for a  */
/*      partitioned data set        */
/*    - Invalid parameter value     */
/* 16 - Truncation or translation   */
/*      error in accessing dialog   */
/*      variables                   */
/* 20 - Severe error                */
  loadmem.0 = lmget_ctr
  mem_line = locvar
  rec_type = C2X(LEFT(mem_line,3))
  IF (rec_type <> "801502") THEN DO
    SIGNAL Lmget_Loop
  END
  lmod_time = SUBSTR(mem_line,16,3)
  disp_time = C2X(lmod_time)
  lmod_yy = SUBSTR(disp_time,1,2)
  lmod_ddd = SUBSTR(disp_time,3,3)
  lmod_time = SUBSTR(mem_line,19,4)
  disp_time = C2X(lmod_time)
  lmod_hr = SUBSTR(disp_time,2,2)
  lmod_mn = SUBSTR(disp_time,4,2)
  lmod_sc = SUBSTR(disp_time,6,2)
  SAY "'SYS1.LINKLIB(IEFBR14)' was linked:" lmod_yy"."lmod_ddd,
      lmod_hr":"lmod_mn":"lmod_sc

End_Lmget:
  ADDRESS ISPEXEC "LMCLOSE DATAID("DATAID")"
  ADDRESS ISPEXEC "LMFREE DATAID("DATAID")"
  RETURN return_code

/*-------------------------------------------------------------------*/
/*- Close and free any OPEN objects here                            -*/
/*-------------------------------------------------------------------*/
Termination_Routine:
  IF (getmain_addr <> " ") THEN DO
    faddr = GETMAIN('RELEASE',getmain_len,getmain_addr)
    SAY "RELEASE RC("faddr")"
  END
  RETURN return_code

/*===================================================================*/
/* Other subroutines/internal functions/procedures.                  */
/*===================================================================*/

/*--------------------------------------------------------------*/
/* SWAREQ - swa request converter                               */
/*        - Requires internal functions:                        */
/*        -   Hex_To_Bit                                        */
/*        -   Obtain_Data                                       */
/*--------------------------------------------------------------*/
Swareq_Ibm: PROCEDURE
  ARG TCB_address, jfcb_address
  xb = Hex_To_Bit(SUBSTR(jfcb_address, 6, 1))
  IF (SUBSTR(xb,4,1) = '1') THEN DO /* SWA above the line  */
     jscb_address = Obtain_Data(TCB_address, X2D("B4"), 4)
     IF (jscb_address = '*') THEN DO
       RETURN '*'
     END
     jscb_address = Obtain_Data(jscb_address,X2D("15C"), 4)
     IF (jscb_address = '*') THEN DO
       RETURN '*'
     END
     qmpa_address = Obtain_Data(jscb_address,X2D("F4"), 4)
     IF (qmpa_address = '*') THEN DO
       RETURN '*'
     END
     junk_address = Obtain_Data(qmpa_address,X2D("18"), 4)
     IF (junk_address = '*') THEN DO
       RETURN '*'
     END
     i1 = X2D(SUBSTR(jfcb_address,1,2))
     i2 = X2D(SUBSTR(jfcb_address,3))
     DO WHILE ,
      (i1 > 0) ,

        junk_address = Obtain_Data(junk_address, 12, 4)
        IF (junk_address = '*') THEN DO
          RETURN '*'
        END
        i1 = i1 - 1
     END
     junk_address = D2X(X2D(junk_address)+i2+1)
     jfcb_address = Obtain_Data(junk_address, 0, 4)
  END
  IF (jfcb_address = '*') THEN DO
    RETURN '*'
  END
  jfcb_address = D2X(X2D(jfcb_address)+16)
  RETURN jfcb_address

/*--------------------------------------------------------------*/
/* Handle SWA above or below the bar.
   Fix from Don Poitras to adjust to z/OS 2.2 putting
   a control block above the 64-bit bar.                            */

     https://groups.google.com/forum/#!
     msg/bit.listserv.ibm-main/E-fMschhS2M/Na4x_Vc9BgAJ

     Comes out of
     http://www.cbttape.org/ftp/cbt/CBT183.zip

/*--------------------------------------------------------------*/
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
=======================================================================
 Convert an ADDRESS in SWA format to usable location
=======================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
Swareq22: PROCEDURE
  NUMERIC DIGITS 16                   /* Handles Petabyte addressing */
  sva = C2D(ARG(1))                         /* convert to decimal   */
  tcb = C2D(STORAGE(21C,4))                 /* TCB         PSATOLD  */
  jscb = C2D(STORAGE(D2X(tcb+180),4))       /* jscb        TCBjscb  */
  qmpl = C2D(STORAGE(D2X(jscb+244),4))      /* QMPL        jscbQMPI */
  /* See IF qmat can be above the bar */
  qmsta = C2X(STORAGE(D2X(qmpl+16),1))       /* JOB STATUS BYTE    */
  IF (SUBSTR(Hex_To_Bit(qmsta),6,1)) THEN DO /* QMQMAT64 bit on   */
    IF (RIGHT(Hex_To_Bit(C2X(ARG(1))),1) <> '1') /* SWA=BELOW  */ ,
    THEN DO
      RETURN C2D(ARG(1))+16                 /* yes, RETURN sva+16   */
    END
    qmat = C2D(STORAGE(D2X(qmpl+10),2))*(2**48) +, /* QMAT+0 QMADD01 */
         C2D(STORAGE(D2X(qmpl+18),2))*(2**32) +, /* QMAT+2 QMADD23  */
         C2D(STORAGE(D2X(qmpl+24),4))           /*  QMAT+4 QMADD    */
    RETURN C2D(STORAGE(D2X(qmat+(sva*12)+64),4))+16
  END
  ELSE DO /* NO, QMAT IS BTB       */
    IF (RIGHT(C2X(ARG(1)),1) <> 'F') THEN DO /* SWA=BELOW ?         */
      RETURN C2D(ARG(1))+16                 /* yes, RETURN sva+16   */
    END
    qmat = C2D(STORAGE(D2X(qmpl+24),4))     /* QMAT        QMADD    */
    DO WHILE ,
     (sva > 65536) ,

      qmat = C2D(STORAGE(D2X(qmat+12),4))   /* next QMAT   QMAT+12  */
      sva=sva - 65536                       /* 010006F -> 000006F   */
    END
    RETURN C2D(STORAGE(D2X(qmat+sva+1),4))+16
  END
  RETURN "ERROR, SHOULD NOT REACH HERE!"

/*--------------------------------------------------------------*/
/* Convert a byte to its bitstring.                             */
/*--------------------------------------------------------------*/
Hex_To_Bit:
  IF (bits.F <> "1111") THEN DO
    bits.0="0000"; bits.1="0001"; bits.2="0010"; bits.3="0011"
    bits.4="0100"; bits.5="0101"; bits.6="0110"; bits.7="0111"
    bits.8="1000"; bits.9="1001"; bits.A="1010"; bits.B="1011"
    bits.C="1100"; bits.D="1101"; bits.E="1110"; bits.F="1111"
  END
  hexchr = ARG(1)
  bit_str = ''
  DO ix = 1 TO LENGTH(hexchr)
    str = SUBSTR(hexchr,ix,1)
    bit_str = bit_str||bits.str
  END
  RETURN bit_str

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 This routine searches STEPLIB/TSOLIB for DEMO.LOADLIB.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Scan_Steplib_And_Tsolib:
  loadlib_good = 0
  ADDRESS ISPEXEC "CONTROL ERRORS RETURN"
  ADDRESS ISPEXEC,
    "QBASELIB STEPLIB ID(dsnames)"
  qbaselib_rc = RC
  IF (qbaselib_rc = 0) THEN DO
    list_of_dsnames = dsnames
    DO WHILE ,
     (list_of_dsnames <> "") ,

      PARSE VAR list_of_dsnames dsn "," list_of_dsnames
      IF (POS("DEMO.LOADLIB",dsn) > 0) THEN DO
        loadlib_good = 1
      END
    END
  END

  @trap_state = TRAPMSG("ON")
  @msg_state = MSG("ON")
  @outtrap_state = OUTTRAP(caughtit.)
  ADDRESS TSO "TSOLIB DISPLAY"
  tsolib_rc = RC
  @outtrap = OUTTRAP("OFF")
  @msg_state = MSG(@msg_state)
  @trap_state = TRAPMSG(@trap_state)
  IF (caughtit.0 > 2) THEN DO
    DO cx = 1 TO caughtit.0
      IF (POS("= ",caughtit.cx) = 0) THEN DO
        ITERATE cx
      END
      PARSE VAR caughtit.cx . "= " ddname .
      ADDRESS ISPEXEC,
        "QBASELIB" ddname "ID(dsnames)"
      qbaselib_rc = RC
      IF (qbaselib_rc = 0) THEN DO
        list_of_dsnames = dsnames
        DO WHILE ,
         (list_of_dsnames <> "") ,

          PARSE VAR list_of_dsnames dsn "," list_of_dsnames
          IF (POS("DEMO.LOADLIB",dsn) > 0) THEN DO
            loadlib_good = 2
          END
        END
      END
    END
  END
  RETURN loadlib_good

/*--------------------------------------------------------------*/
/* get # bytes of data. An old post claims this can be found    */
/*                      in a Data areas manual. I did not find  */
/*                      it so I created this from its use of    */
/*                      three arguments.                        */
/*   ARG(1) = ADDRESS                                           */
/*   ARG(2) = offset                                            */
/*   ARG(3) = length                                            */
/*--------------------------------------------------------------*/
Obtain_Data: PROCEDURE
  ARG hex_address hex_offset decimal_length
  arg_address = D2X(X2D(hex_address) + X2D(hex_offset))
  RETURN STORAGE(stg_address,decimal_length)

/*--------------------------------------------------------------*/
/* SWAREQ - swa request converter                               */
/*--------------------------------------------------------------*/
Swareq_Old:   PROCEDURE
  IF (RIGHT(C2X(ARG(1)),1) <> 'F') /* Swa=Below ?                 */ ,
  THEN DO
    RETURN C2D(ARG(1))+16              /* Yes, RETURN sva+16         */
  END
  sva = C2D(ARG(1))                    /* Convert to decimal         */
  tcb = Ptr(540)                       /* Tcb psatold                */
  jscb = Ptr(tcb+180)                  /* jscb tcbjscb               */
  qmpl = Ptr(jscb+244)                 /* Qmpl jscbqmpi              */
  qmat = Ptr(qmpl+24)                  /* Qmat qmadd                 */
  DO WHILE ,
   (sva > 65536) ,

    qmat = Ptr(qmat+12)                /* Next qmat qmat+12          */
    sva=sva - 65536                    /* 010006F -> 000006F         */
  END
  RETURN Ptr(qmat+sva+1)+16

/*--------------------------------------------------------------*/
/* get 4 bytes and treat as a pointer                           */
/*--------------------------------------------------------------*/
Ptr:
  RETURN C2D(STORAGE(D2X(ARG(1)),4))     /* RETURN a pointer         */

/*--------------------------------------------------------------*/
/* forcibly ensure two bytes of data                            */
/*--------------------------------------------------------------*/
Halfword:
  PARSE ARG myword
  RETURN RIGHT(hexzeroes||myword,2)

/*--------------------------------------------------------------*/
/* forcibly ensure four bytes of data                           */
/*--------------------------------------------------------------*/
Fullword:
  PARSE ARG myword
  RETURN RIGHT(hexzeroes||myword,4)

/*--------------------------------------------------------------*/
/* Format the first 2K of the PSA.                              */
/*--------------------------------------------------------------*/
/* ----------------------------------------------------------------- */
/* Book:   IEA2D320   GA22-7583-02                                   */
/* Title:  z/OS: MVS Data Areas, Volume 3 (IVT - RCWK)               */
/* Copyright:   Copyright IBM Corp. 1988, 2002                       */
/* Area: PSA 192.1.1                                                 */
/* Name: Prefixed Save Area                                          */
/* Macro: IHAPSA                                                     */
/* Size: 4096                                                        */
/* ----------------------------------------------------------------- */
Fmt_Ihapsa:
/* IHAPSA = STORAGE(some_hexoffset,4105)                             */
  PARSE VAR IHAPSA,
    1 SA +0     /* STRUCTURE Offset(0) len(0)                        */,
    1 FLC +0     /* X'0' Offset(0) len(0)                            */,
    1 FLCIPPSW +8     /* CHARACTER Offset(0) len(8)                  */,
    1 FLCRNPSW +4     /* BITSTRING Offset(0) len(4)                  */,
    5 rsvd5 +4     /* ADDRESS Offset(4) len(4)                       */,
    5 IPLPSW +0     /* X'0' Offset(4) len(0)                         */,
    9 FLCICCW1 +8     /* CHARACTER Offset(8) len(8)                  */,
    9 FLCROPSW +8     /* BITSTRING Offset(8) len(8)                  */,
    17 FLCICCW2 +8     /* CHARACTER Offset(10) len(8)                */,
    17 FLCCVT +4     /* ADDRESS Offset(10) len(4)                    */,
    21 rsvd11 +4     /* BITSTRING Offset(14) len(4)                  */,
    25 FLCEOPSW +8     /* BITSTRING Offset(18) len(8)                */,
    25 EXOPSW +0     /* X'18' Offset(18) len(0)                      */,
    33 FLCSOPSW +8     /* BITSTRING Offset(20) len(8)                */,
    33 SVCOPSW +0     /* X'20' Offset(20) len(0)                     */,
    41 FLCPOPSW +8     /* BITSTRING Offset(28) len(8)                */,
    41 PIOPSW +0     /* X'28' Offset(28) len(0)                      */,
    49 FLCMOPSW +8     /* BITSTRING Offset(30) len(8)                */,
    49 MCOPSW +0     /* X'30' Offset(30) len(0)                      */,
    57 FLCIOPSW +8     /* BITSTRING Offset(38) len(8)                */,
    57 IOOPSW +0     /* X'38' Offset(38) len(0)                      */,
    65 rsvd22 +12     /* BITSTRING Offset(40) len(12)                */,
    77 FLCCVT2 +4     /* ADDRESS Offset(4C) len(4)                   */,
    81 rsvd24 +4     /* BITSTRING Offset(50) len(4)                  */,
    85 rsvd25 +4     /* BITSTRING Offset(54) len(4)                  */,
    89 FLCENPSW +4     /* BITSTRING Offset(58) len(4)                */,
    93 rsvd27 +4     /* ADDRESS Offset(5C) len(4)                    */,
    93 EXNPSW +0     /* X'58' Offset(5C) len(0)                      */,
    97 FLCSNPSW +4     /* BITSTRING Offset(60) len(4)                */,
    101 rsvd30 +4     /* ADDRESS Offset(64) len(4)                   */,
    101 SVCNPSW +0     /* X'60' Offset(64) len(0)                    */,
    105 FLCPNPSW +4     /* BITSTRING Offset(68) len(4)               */,
    109 rsvd33 +4     /* ADDRESS Offset(6C) len(4)                   */,
    109 PINPSW +0     /* X'68' Offset(6C) len(0)                     */,
    113 FLCMNPSW +4     /* BITSTRING Offset(70) len(4)               */,
    117 rsvd36 +4     /* ADDRESS Offset(74) len(4)                   */,
    117 MCNPSW +0     /* X'70' Offset(74) len(0)                     */,
    121 FLCINPSW +4     /* BITSTRING Offset(78) len(4)               */,
    125 rsvd39 +4     /* ADDRESS Offset(7C) len(4)                   */,
    125 IONPSW +0     /* X'78' Offset(7C) len(0)                     */,
    129 PSAEPARM +4     /* SIGNED Offset(80) len(4)                  */,
    133 PSAEEPSW +4     /* SIGNED Offset(84) len(4)                  */,
    133 PSASPAD +2     /* SIGNED Offset(84) len(2)                   */,
    135 FLCEICOD +2     /* SIGNED Offset(86) len(2)                  */,
    135 EXCODE +0     /* X'86' Offset(86) len(0)                     */,
    137 PSAESPSW +4     /* SIGNED Offset(88) len(4)                  */,
    137 rsvd47 +1     /* BITSTRING Offset(88) len(1)                 */,
    138 FLCSVILC +1     /* SIGNED Offset(89) len(1)                  */,
    138 SVCILC +0     /* X'89' Offset(89) len(0)                     */,
    139 FLCSVCN +2     /* SIGNED Offset(8A) len(2)                   */,
    139 SVCNUM +0     /* X'8A' Offset(8A) len(0)                     */,
    141 PSAEPPSW +8     /* CHARACTER Offset(8C) len(8)               */,
    141 rsvd53 +1     /* BITSTRING Offset(8C) len(1)                 */,
    142 FLCPIILC +1     /* SIGNED Offset(8D) len(1)                  */,
    142 PIILC +0     /* X'8D' Offset(8D) len(0)                      */,
    143 FLCPICOD +2     /* SIGNED Offset(8E) len(2)                  */,
    143 PICODE +0     /* X'8E' Offset(8E) len(0)                     */,
    143 PSAEECOD +1     /* SIGNED Offset(8E) len(1)                  */,
    144 PSAPICOD +1     /* SIGNED Offset(8F) len(1)                  */,
    145 rsvd60 +4     /* SIGNED Offset(90) len(4)                    */,
    145 rsvd61 +3     /* BITSTRING Offset(90) len(3)                 */,
    148 rsvd62 +1     /* BITSTRING Offset(93) len(1)                 */,
    148 FLCTEAB3 +1     /* BITSTRING Offset(93) len(1)               */,
    148 FLCTEACL +0     /* BITSTRING Offset(93) len(0)               */,
    149 rsvd65 +1     /* BITSTRING Offset(94) len(1)                 */,
    150 FLCMCNUM +1     /* BITSTRING Offset(95) len(1)               */,
    151 FLCPERCD +1     /* BITSTRING Offset(96) len(1)               */,
    152 FLCATMID +1     /* BITSTRING Offset(97) len(1)               */,
    153 FLCPER +4     /* ADDRESS Offset(98) len(4)                   */,
    157 rsvd70 +1     /* BITSTRING Offset(9C) len(1)                 */,
    158 FLCMTRCD +3     /* BITSTRING Offset(9D) len(3)               */,
    161 FLCTEARN +1     /* BITSTRING Offset(A0) len(1)               */,
    162 FLCPERRN +1     /* BITSTRING Offset(A1) len(1)               */,
    163 rsvd74 +1     /* BITSTRING Offset(A2) len(1)                 */,
    164 FLCARCH +1     /* BITSTRING Offset(A3) len(1)                */,
    165 PSAMPL +4     /* ADDRESS Offset(A4) len(4)                   */,
    169 rsvd77 +344     /* BITSTRING Offset(A8) len(344)             */,
    169 rsvd78 +16     /* BITSTRING Offset(A8) len(16)               */,
    185 FLCIOCDP +8     /* BITSTRING Offset(B8) len(8)               */,
    185 FLCSID +4     /* BITSTRING Offset(B8) len(4)                 */,
    189 FLCIOFP +4     /* BITSTRING Offset(BC) len(4)                */,
    193 rsvd82 +8     /* BITSTRING Offset(C0) len(8)                 */,
    201 FLCFACL +4     /* BITSTRING Offset(C8) len(4)                */,
    205 rsvd84 +8     /* BITSTRING Offset(CC) len(8)                 */,
    213 FLCESAR +4     /* ADDRESS Offset(D4) len(4)                  */,
    217 FLCCTSA +8     /* BITSTRING Offset(D8) len(8)                */,
    225 FLCCCSA +8     /* BITSTRING Offset(E0) len(8)                */,
    233 FLCMCIC +8     /* BITSTRING Offset(E8) len(8)                */,
    241 rsvd89 +8     /* BITSTRING Offset(F0) len(8)                 */,
    249 FLCFSA +4     /* ADDRESS Offset(F8) len(4)                   */,
    253 rsvd91 +4     /* BITSTRING Offset(FC) len(4)                 */,
    257 FLCFLA +16     /* BITSTRING Offset(100 len(16)               */,
    273 FLCRV110 +16     /* BITSTRING Offset(110 len(16)             */,
    289 FLCARSAV +4     /* SIGNED Offset(120 len(4)                  */,
    353 FLCFPSAV +32     /* BITSTRING Offset(160 len(32)             */,
    385 FLCGRSAV +4     /* SIGNED Offset(180 len(4)                  */,
    449 FLCCRSAV +4     /* SIGNED Offset(1C0 len(4)                  */,
    513 FLCHDEND +8     /* DBL WORD Offset(200 len(8)                */,
    513 PSAPSA +4     /* CHARACTER Offset(200 len(4)                 */,
    517 PSACPUPA +2     /* SIGNED Offset(204 len(2)                  */,
    519 PSACPULA +2     /* SIGNED Offset(206 len(2)                  */,
    521 PSAPCCAV +4     /* ADDRESS Offset(208 len(4)                 */,
    525 PSAPCCAR +4     /* ADDRESS Offset(20C len(4)                 */,
    529 PSALCCAV +4     /* ADDRESS Offset(210 len(4)                 */,
    533 PSALCCAR +4     /* ADDRESS Offset(214 len(4)                 */,
    537 PSATNEW +4     /* ADDRESS Offset(218 len(4)                  */,
    537 IEATCBP +0     /* X'218' Offset(218 len(0)                   */,
    541 PSATOLD +4     /* ADDRESS Offset(21C len(4)                  */,
    545 PSAANEW +4     /* ADDRESS Offset(220 len(4)                  */,
    549 PSAAOLD +4     /* ADDRESS Offset(224 len(4)                  */,
    553 PSASUPER +4     /* BITSTRING Offset(228 len(4)               */,
    553 PSASUP1 +1     /* BITSTRING Offset(228 len(1)                */,
    554 PSASUP2 +1     /* BITSTRING Offset(229 len(1)                */,
    555 PSASUP3 +1     /* BITSTRING Offset(22A len(1)                */,
    556 PSASUP4 +1     /* BITSTRING Offset(22B len(1)                */,
    557 PSARV22C +16     /* BITSTRING Offset(22C len(16)             */,
    573 PSAPTYPE +1     /* BITSTRING Offset(23C len(1)               */,
    574 PSAILS +1     /* BITSTRING Offset(23D len(1)                 */,
    575 PSALSVCI +2     /* BITSTRING Offset(23E len(2)               */,
    577 PSAFLAGS +1     /* BITSTRING Offset(240 len(1)               */,
    578 PSARV241 +10     /* BITSTRING Offset(241 len(10)             */,
    588 PSASCAFF +1     /* BITSTRING Offset(24B len(1)               */,
    589 PSALKCRF +4     /* ADDRESS Offset(24C len(4)                 */,
    593 rsvd124 +8     /* DBL WORD Offset(250 len(8)                 */,
    593 PSAMPSW +8     /* BITSTRING Offset(250 len(8)                */,
    601 rsvd126 +8     /* DBL WORD Offset(258 len(8)                 */,
    601 PSAMCHEX +8     /* BITSTRING Offset(258 len(8)               */,
    609 PSATCLIN +4     /* SIGNED Offset(260 len(4)                  */,
    613 PSAINTIN +4     /* SIGNED Offset(264 len(4)                  */,
    617 PSAIPCIN +4     /* SIGNED Offset(268 len(4)                  */,
    617 PSAIPCSM +0     /* X'269' Offset(268 len(0)                  */,
    621 PSAEMS2S +4     /* SIGNED Offset(26C len(4)                  */,
    621 PSAEMS2M +0     /* X'26D' Offset(26C len(0)                  */,
    625 PSASTOSM +4     /* SIGNED Offset(270 len(4)                  */,
    625 PSASTSSM +0     /* X'271' Offset(270 len(0)                  */,
    629 PSAHLHIS +4     /* SIGNED Offset(274 len(4)                  */,
    633 PSARECUR +1     /* BITSTRING Offset(278 len(1)               */,
    634 PSARSSM +1     /* BITSTRING Offset(279 len(1)                */,
    635 PSASNSM2 +1     /* BITSTRING Offset(27A len(1)               */,
    636 PSARTM1S +1     /* BITSTRING Offset(27B len(1)               */,
    637 PSALWTSA +4     /* ADDRESS Offset(27C len(4)                 */,
    641 PSACLHT +116     /* CHARACTER Offset(280 len(116)            */,
    641 PSACLHT1 +80     /* CHARACTER Offset(280 len(80)             */,
    641 PSADISPL +4     /* ADDRESS Offset(280 len(4)                 */,
    645 PSAASML +4     /* ADDRESS Offset(284 len(4)                  */,
    649 PSASALCL +4     /* ADDRESS Offset(288 len(4)                 */,
    653 PSAIOSSL +4     /* ADDRESS Offset(28C len(4)                 */,
    657 PSARSMDL +4     /* ADDRESS Offset(290 len(4)                 */,
    661 PSAIOSUL +4     /* ADDRESS Offset(294 len(4)                 */,
    665 PSARVLK1 +4     /* ADDRESS Offset(298 len(4)                 */,
    669 PSARV29C +4     /* ADDRESS Offset(29C len(4)                 */,
    673 PSARV2A0 +4     /* ADDRESS Offset(2A0 len(4)                 */,
    677 PSATPACL +4     /* ADDRESS Offset(2A4 len(4)                 */,
    681 PSAOPTL +4     /* ADDRESS Offset(2A8 len(4)                  */,
    685 PSARSMGL +4     /* ADDRESS Offset(2AC len(4)                 */,
    689 PSAVFIXL +4     /* ADDRESS Offset(2B0 len(4)                 */,
    693 PSAASMGL +4     /* ADDRESS Offset(2B4 len(4)                 */,
    697 PSARSMSL +4     /* ADDRESS Offset(2B8 len(4)                 */,
    701 PSARSMXL +4     /* ADDRESS Offset(2BC len(4)                 */,
    705 PSARSMAL +4     /* ADDRESS Offset(2C0 len(4)                 */,
    709 PSAVPAGL +4     /* ADDRESS Offset(2C4 len(4)                 */,
    713 PSARSMCL +4     /* ADDRESS Offset(2C8 len(4)                 */,
    713 PSALKS1 +0     /* X'13' Offset(2C8 len(0)                    */,
    717 PSARVLK2 +4     /* ADDRESS Offset(2CC len(4)                 */,
    721 PSACLHT2 +16     /* CHARACTER Offset(2D0 len(16)             */,
    721 PSARSML +4     /* ADDRESS Offset(2D0 len(4)                  */,
    725 PSATRCEL +4     /* ADDRESS Offset(2D4 len(4)                 */,
    729 PSAIOSL +4     /* ADDRESS Offset(2D8 len(4)                  */,
    729 PSALKS2 +0     /* X'3' Offset(2D8 len(0)                     */,
    733 PSARVLK4 +4     /* ADDRESS Offset(2DC len(4)                 */,
    737 PSACLHT3 +8     /* CHARACTER Offset(2E0 len(8)               */,
    737 PSACPUL +4     /* ADDRESS Offset(2E0 len(4)                  */,
    737 PSALKS3 +0     /* X'1' Offset(2E0 len(0)                     */,
    741 PSARVLK5 +4     /* ADDRESS Offset(2E4 len(4)                 */,
    745 PSACLHT4 +12     /* CHARACTER Offset(2E8 len(12)             */,
    745 PSACMSL +4     /* ADDRESS Offset(2E8 len(4)                  */,
    749 PSALOCAL +4     /* ADDRESS Offset(2EC len(4)                 */,
    749 PSALKS4 +0     /* X'2' Offset(2EC len(0)                     */,
    753 PSARVLK6 +4     /* ADDRESS Offset(2F0 len(4)                 */,
    757 PSALCPUA +4     /* ADDRESS Offset(2F4 len(4)                 */,
    761 PSAHLHI +4     /* SIGNED Offset(2F8 len(4)                   */,
    761 PSACLHS +4     /* SIGNED Offset(2F8 len(4)                   */,
    761 PSACLHS1 +1     /* BITSTRING Offset(2F8 len(1)               */,
    762 PSACLHS2 +1     /* BITSTRING Offset(2F9 len(1)               */,
    763 PSACLHS3 +1     /* BITSTRING Offset(2FA len(1)               */,
    764 PSACLHS4 +1     /* BITSTRING Offset(2FB len(1)               */,
    765 PSALITA +4     /* ADDRESS Offset(2FC len(4)                  */,
    769 PSASTOR8 +8     /* BITSTRING Offset(300 len(8)               */,
    777 PSACR0 +4     /* SIGNED Offset(308 len(4)                    */,
    781 PSAMCHFL +1     /* BITSTRING Offset(30C len(1)               */,
    782 PSASYMSK +1     /* BITSTRING Offset(30D len(1)               */,
    783 PSAACTCD +1     /* BITSTRING Offset(30E len(1)               */,
    784 PSAMCHIC +1     /* BITSTRING Offset(30F len(1)               */,
    785 PSAWKRAP +4     /* ADDRESS Offset(310 len(4)                 */,
    789 PSAWKVAP +4     /* ADDRESS Offset(314 len(4)                 */,
    793 PSAVSTAP +2     /* SIGNED Offset(318 len(2)                  */,
    795 PSACPUSA +2     /* SIGNED Offset(31A len(2)                  */,
    797 PSASTOR +4     /* SIGNED Offset(31C len(4)                   */,
    801 PSAIDAWK +90     /* BITSTRING Offset(320 len(90)             */,
    891 PSARET +2     /* SIGNED Offset(37A len(2)                    */,
    893 PSARETCD +2     /* SIGNED Offset(37C len(2)                  */,
    895 rsvd202 +2     /* BITSTRING Offset(37E len(2)                */,
    897 PSARSVT +64     /* CHARACTER Offset(380 len(64)              */,
    897 PSARSVTE +64     /* CHARACTER Offset(380 len(64)             */,
    897 PSACSTK +4     /* ADDRESS Offset(380 len(4)                  */,
    901 PSANSTK +4     /* ADDRESS Offset(384 len(4)                  */,
    905 PSASSTK +4     /* ADDRESS Offset(388 len(4)                  */,
    909 PSASSAV +4     /* ADDRESS Offset(38C len(4)                  */,
    913 PSAMSTK +4     /* ADDRESS Offset(390 len(4)                  */,
    917 PSAMSAV +4     /* ADDRESS Offset(394 len(4)                  */,
    921 PSAPSTK +4     /* ADDRESS Offset(398 len(4)                  */,
    925 PSAPSAV +4     /* ADDRESS Offset(39C len(4)                  */,
    929 PSAESTK1 +4     /* ADDRESS Offset(3A0 len(4)                 */,
    933 PSAESAV1 +4     /* ADDRESS Offset(3A4 len(4)                 */,
    937 PSAESTK2 +4     /* ADDRESS Offset(3A8 len(4)                 */,
    941 PSAESAV2 +4     /* ADDRESS Offset(3AC len(4)                 */,
    945 PSAESTK3 +4     /* ADDRESS Offset(3B0 len(4)                 */,
    949 PSAESAV3 +4     /* ADDRESS Offset(3B4 len(4)                 */,
    953 PSARSTK +4     /* ADDRESS Offset(3B8 len(4)                  */,
    957 PSARSAV +4     /* ADDRESS Offset(3BC len(4)                  */,
    961 rsvd221 +8     /* DBL WORD Offset(3C0 len(8)                 */,
    961 PSALWPSW +8     /* BITSTRING Offset(3C0 len(8)               */,
    969 rsvd223 +8     /* DBL WORD Offset(3C8 len(8)                 */,
    969 PSARSPSW +8     /* BITSTRING Offset(3C8 len(8)               */,
    977 PSATSTK +4     /* ADDRESS Offset(3D0 len(4)                  */,
    981 PSATSAV +4     /* ADDRESS Offset(3D4 len(4)                  */,
    985 PSAASTK +4     /* ADDRESS Offset(3D8 len(4)                  */,
    989 PSAASAV +4     /* ADDRESS Offset(3DC len(4)                  */,
    993 rsvd229 +8     /* DBL WORD Offset(3E0 len(8)                 */,
    993 PSARTPSW +8     /* BITSTRING Offset(3E0 len(8)               */,
    1001 PSARV3E8 +8     /* BITSTRING Offset(3E8 len(8)              */,
    1009 rsvd232 +4     /* SIGNED Offset(3F0 len(4)                  */,
    1009 PSASFACC +4     /* BITSTRING Offset(3F0 len(4)              */,
    1013 PSALSFCC +4     /* SIGNED Offset(3F4 len(4)                 */,
    1017 PSASVC13 +2     /* SIGNED Offset(3F8 len(2)                 */,
    1019 rsvd236 +1     /* BITSTRING Offset(3FA len(1)               */,
    1020 PSAINTE +1     /* BITSTRING Offset(3FB len(1)               */,
    1021 PSARTM1R +4     /* SIGNED Offset(3FC len(4)                 */,
    1021 PSARTM1M +0     /* X'3FD' Offset(3FC len(0)                 */,
    1025 rsvd240 +8     /* DBL WORD Offset(400 len(8)                */,
    1025 PSAPCPSW +8     /* BITSTRING Offset(400 len(8)              */,
    1033 PSAATCVT +4     /* ADDRESS Offset(408 len(4)                */,
    1037 PSAWTCOD +4     /* ADDRESS Offset(40C len(4)                */,
    1041 PSASCWA +4     /* ADDRESS Offset(410 len(4)                 */,
    1045 PSARSMSA +4     /* ADDRESS Offset(414 len(4)                */,
    1049 rsvd246 +8     /* DBL WORD Offset(418 len(8)                */,
    1049 PSASCPSW +4     /* BITSTRING Offset(418 len(4)              */,
    1053 rsvd248 +4     /* ADDRESS Offset(41C len(4)                 */,
    1057 rsvd249 +8     /* DBL WORD Offset(420 len(8)                */,
    1057 PSASMPSW +4     /* BITSTRING Offset(420 len(4)              */,
    1061 rsvd251 +4     /* ADDRESS Offset(424 len(4)                 */,
    1065 PSARV428 +64     /* BITSTRING Offset(428 len(64)            */,
    1129 rsvd253 +8     /* DBL WORD Offset(468 len(8)                */,
    1129 PSAPSWSV +8     /* BITSTRING Offset(468 len(8)              */,
    1137 rsvd255 +8     /* DBL WORD Offset(470 len(8)                */,
    1137 PSACPUT +8     /* BITSTRING Offset(470 len(8)               */,
    1145 PSAPCFUN +4     /* SIGNED Offset(478 len(4)                 */,
    1145 PSAPCFB1 +1     /* BITSTRING Offset(478 len(1)              */,
    1146 PSAPCFB2 +1     /* BITSTRING Offset(479 len(1)              */,
    1147 PSAPCFB3 +1     /* BITSTRING Offset(47A len(1)              */,
    1148 PSAPCFB4 +1     /* BITSTRING Offset(47B len(1)              */,
    1149 PSAPCPS2 +2     /* SIGNED Offset(47C len(2)                 */,
    1151 PSARV47E +2     /* BITSTRING Offset(47E len(2)              */,
    1153 PSAPCWKA +24     /* BITSTRING Offset(480 len(24)            */,
    1177 PSAPCPS3 +2     /* SIGNED Offset(498 len(2)                 */,
    1179 PSAPCPS4 +2     /* SIGNED Offset(49A len(2)                 */,
    1181 PSAMODEW +4     /* SIGNED Offset(49C len(4)                 */,
    1181 rsvd268 +1     /* BITSTRING Offset(49C len(1)               */,
    1182 PSAMFLGS +1     /* BITSTRING Offset(49D len(1)              */,
    1183 PSAMODEH +1     /* BITSTRING Offset(49E len(1)              */,
    1184 PSAMODE +1     /* BITSTRING Offset(49F len(1)               */,
    1185 rsvd272 +3     /* BITSTRING Offset(4A0 len(3)               */,
    1188 PSASTNSM +1     /* BITSTRING Offset(4A3 len(1)              */,
    1189 PSALKJW +4     /* SIGNED Offset(4A4 len(4)                  */,
    1193 PSADZERO +8     /* DBL WORD Offset(4A8 len(8)               */,
    1193 PSAFZERO +4     /* SIGNED Offset(4A8 len(4)                 */,
    1197 rsvd277 +4     /* SIGNED Offset(4AC len(4)                  */,
    1201 PSALKJW2 +4     /* SIGNED Offset(4B0 len(4)                 */,
    1205 PSALKPT +4     /* ADDRESS Offset(4B4 len(4)                 */,
    1209 PSARV4B8 +4     /* BITSTRING Offset(4B8 len(4)              */,
    1213 PSALIT2 +4     /* ADDRESS Offset(4BC len(4)                 */,
    1217 PSAECLTP +4     /* ADDRESS Offset(4C0 len(4)                */,
    1221 PSACLHSE +4     /* SIGNED Offset(4C4 len(4)                 */,
    1221 PSALHEB0 +1     /* BITSTRING Offset(4C4 len(1)              */,
    1222 PSALHEB1 +1     /* BITSTRING Offset(4C5 len(1)              */,
    1223 PSALHEB2 +1     /* BITSTRING Offset(4C6 len(1)              */,
    1224 PSALHEB3 +1     /* BITSTRING Offset(4C7 len(1)              */,
    1225 PSARV4C8 +8     /* BITSTRING Offset(4C8 len(8)              */,
    1233 PSARV4D0 +184     /* BITSTRING Offset(4D0 len(184)          */,
    1417 PSAHWFB +1     /* BITSTRING Offset(588 len(1)               */,
    1418 PSACR0CB +1     /* BITSTRING Offset(589 len(1)              */,
    1419 rsvd292 +2     /* BITSTRING Offset(58A len(2)               */,
    1421 PSACR0SV +4     /* SIGNED Offset(58C len(4)                 */,
    1425 PSAPCCR0 +4     /* SIGNED Offset(590 len(4)                 */,
    1429 PSARCR0 +4     /* SIGNED Offset(594 len(4)                  */,
    1433 PSASTKE +8     /* DBL WORD Offset(598 len(8)                */,
    1433 PSATKN +2     /* SIGNED Offset(598 len(2)                   */,
    1435 PSAASD +2     /* SIGNED Offset(59A len(2)                   */,
    1437 PSASEL +4     /* SIGNED Offset(59C len(4)                   */,
    1441 rsvd300 +8     /* DBL WORD Offset(5A0 len(8)                */,
    1441 PSASKPSW +4     /* BITSTRING Offset(5A0 len(4)              */,
    1445 PSASKPS2 +4     /* ADDRESS Offset(5A4 len(4)                */,
    1449 PSACPCLS +4     /* ADDRESS Offset(5A8 len(4)                */,
    1453 PSARV5AC +4     /* BITSTRING Offset(5AC len(4)              */,
    1457 PSASCFS +4     /* ADDRESS Offset(5B0 len(4)                 */,
    1461 PSAPAWA +4     /* ADDRESS Offset(5B4 len(4)                 */,
    1465 PSASCFB +1     /* BITSTRING Offset(5B8 len(1)               */,
    1466 rsvd308 +3     /* BITSTRING Offset(5B9 len(3)               */,
    1469 PSACR0M1 +4     /* BITSTRING Offset(5BC len(4)              */,
    1473 PSACR0M2 +4     /* BITSTRING Offset(5C0 len(4)              */,
    1477 PSARV5C4 +148     /* BITSTRING Offset(5C4 len(148)          */,
    1625 PSATIME +8     /* DBL WORD Offset(658 len(8)                */,
    1633 PSASRSAV +4     /* SIGNED Offset(660 len(4)                 */,
    1637 PSAESC8 +12     /* BITSTRING Offset(664 len(12)             */,
    1649 PSADXMSI +8     /* DBL WORD Offset(670 len(8)               */,
    1649 PSADCR3I +4     /* SIGNED Offset(670 len(4)                 */,
    1649 PSADPKMI +2     /* SIGNED Offset(670 len(2)                 */,
    1651 PSADSASI +2     /* SIGNED Offset(672 len(2)                 */,
    1653 PSADCR4I +4     /* SIGNED Offset(674 len(4)                 */,
    1653 PSADAXI +2     /* SIGNED Offset(674 len(2)                  */,
    1655 PSADPASI +2     /* SIGNED Offset(676 len(2)                 */,
    1657 PSADSARS +64     /* BITSTRING Offset(678 len(64)            */,
    1721 PSADXMSV +8     /* DBL WORD Offset(6B8 len(8)               */,
    1721 PSADCR3 +4     /* SIGNED Offset(6B8 len(4)                  */,
    1721 PSADPKM +2     /* SIGNED Offset(6B8 len(2)                  */,
    1723 PSADSAS +2     /* SIGNED Offset(6BA len(2)                  */,
    1725 PSADCR4 +4     /* SIGNED Offset(6BC len(4)                  */,
    1725 PSADAX +2     /* SIGNED Offset(6BC len(2)                   */,
    1727 PSADPAS +2     /* SIGNED Offset(6BE len(2)                  */,
    1729 PSADTSAV +8     /* DBL WORD Offset(6C0 len(8)               */,
    1729 PSAFF6C0 +1     /* BITSTRING Offset(6C0 len(1)              */,
    1737 PSAUSEND +8     /* DBL WORD Offset(6C8 len(8)               */,
    1737 PSARV6C8 +232     /* BITSTRING Offset(6C8 len(232)          */,
    1969 rsvd334 +8     /* DBL WORD Offset(7B0 len(8)                */,
    1969 PSADATLK +1     /* BITSTRING Offset(7B0 len(1)              */,
    2017 PSADATOF +4     /* ADDRESS Offset(7E0 len(4)                */,
    2021 PSADATLN +4     /* SIGNED Offset(7E4 len(4)                 */,
    2025 PSARV7E8 +4     /* BITSTRING Offset(7E8 len(4)              */,
    2025 PSAFF7E8 +1     /* BITSTRING Offset(7E8 len(1)              */,
    2029 PSATRACE +1     /* BITSTRING Offset(7EC len(1)              */,
    2030 rsvd341 +3     /* BITSTRING Offset(7ED len(3)               */,
    2033 PSATBVTR +4     /* ADDRESS Offset(7F0 len(4)                */,
    2037 PSATBVTV +4     /* ADDRESS Offset(7F4 len(4)                */,
    2041 PSATRVT +4     /* ADDRESS Offset(7F8 len(4)                 */,
    2045 PSATOT +4     /* ADDRESS Offset(7FC len(4)                  */
  RETURN

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 End of code.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
