/* rexx */
Rexx_DFHR1388:
  rexxpgm_version = "02.01"           /* ver lev */

  PARSE UPPER ARG all_my_arguments
  NUMERIC DIGITS 16                   /* Handles Petabyte addressing */

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 This code drives Initialization, Process, and Termination routines.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Main_Routine:
  return_code = Initialization_Routine()
  IF (return_code = 0) THEN DO
    return_code = Process_Routine()
  END
  return_code = Termination_Routine()
  RETURN return_code

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================

 Dataset:  DEMO.REXX(DFHR1388)
 Contact:  "Kenneth Tomiak"<CBT_Ken@KTomiak.BIZ>
 Overview: Read the output from a repro of a DFHCSD to a flat file.
 Syntax:   DFHR1388 |SECPRFX=rdefine_prefix LIST=startlist|SHOW|DEBUG|,
 JCL:      DEMO.CNTL(DFHR1388)

    //jobname  JOB ...
    //CLEANUP EXEC PGM=IEFBR14
    //DELME     DD DISP=(MOD,DELETE),DSN=&SYSUID..CICS540.DFHCSDSQ,
    //             SPACE=(0,0)
    //REPRO   EXEC PGM=IDCAMS,
    //             REGION=32M
    //SYSIN     DD DATA,DLM='!!'
             REPRO INFILE(SYSUT1) OUTFILE(SYSUT2)
    !!
    //SYSPRINT  DD SYSOUT=*
    //SYSUT1    DD DISP=SHR,DSN=&SYSUID..CICS540.DFHCSD
    //SYSUT2    DD DISP=(NEW,CATLG),DSN=&SYSUID..CICS540.DFHCSDSQ,
    //             UNIT=SYSALLDA,
    //             SPACE=(TRK,(45,15),RLSE),
    //             DCB=(DSORG=PS,RECFM=VB,BLKSIZE=0,LRECL=2004)
    //R1388   EXEC PGM=IKJEFT1B,PARM='',
    //             DYNAMNBR=32,REGION=32M
    //SYSTSIN   DD DATA,DLM='!!'
    %DFHR1388 SECPRFX=SYSX LIST=DFHLIST
    LOGOFF
    %DFHR1388 SECPRFX=rdefine_prefix LIST=startup_list SHOW
    !!
    //SYSEXEC   DD DISP=SHR,DSN=&SYSUID..DEMO.REXX
    //SYSTSPRT  DD SYSOUT=*
    //DFHCSDSQ  DD DISP=SHR,DSN=&SYSUID..CICS540.DFHCSDSQ
    //DFHRMETA  DD DISP=SHR,DSN=&SYSUID..DEMO.DATA(DFHRMETA)
    //TXIDDESC  DD DISP=SHR,DSN=&SYSUID..DEMO.DATA(TXID0GRP)
    //          DD DISP=SHR,DSN=&SYSUID..DEMO.DATA(TXID1CIC)
    //          DD DISP=SHR,DSN=&SYSUID..DEMO.DATA(TXID1CRX)
    //          DD DISP=SHR,DSN=&SYSUID..DEMO.DATA(TXID1CSD)
    //          DD DISP=SHR,DSN=&SYSUID..DEMO.DATA(TXID1DB2)
    //          DD DISP=SHR,DSN=&SYSUID..DEMO.DATA(TXID1LE)
    //          DD DISP=SHR,DSN=&SYSUID..DEMO.DATA(TXID1WSP)
    //          DD DISP=SHR,DSN=&SYSUID..DEMO.DATA(TXID2VDR)
    //          DD DISP=SHR,DSN=&SYSUID..DEMO.DATA(TXID3USR)
    //CICSCMD   DD SYSOUT=*                                     OR
    //CICSCMD   DD DISP=OLD,DSN=&SYSUID..DEMO.CNTL(DFHRCICS)
    //RACFCMD   DD SYSOUT=*                                     OR
    //RACFCMD   DD DISP=OLD,DSN=&SYSUID..DEMO.CNTL(DFHRRACF)
    //TXIDDEF   DD SYSOUT=*                                     OR
    //TXIDDEF   DD DISP=OLD,DSN=&SYSUID..DEMO.DATA(TXID1CSD)

-----------------------------------------------------------------------

 History of Modifications
 ------------------------
vv.mm When     Who / What you did ... (Newest change at the top.)
----- -------- --------------------------------------------------------
02.01 20180510 KTOMIAK "Kenneth Tomiak"<CBT_Ken@KTomiak.BIZ>
         -     1) Lots of manual changes to conform to PUTKTM and
      20180506    fit with copied potions of DFHRXALL.
               2) Stylize using Edit Macro @putktm:
                  Programming Using The Kenneth Tomiak Method.
               3) Added JCL to comment block.
               4) Added SHOW option for debugging purposes.
               5) Completed the logic to create DFHCSDUP commands
                  for non-IBMINITIAL group transactions missing
                  their description. Requires manually adding them
                  to the TXIDDESC concatenation.
               6) Completed the logic to create RDEFINE commands
                  defining profiles with their assigned transactions.
----- -------- --------------------------------------------------------
02.00 20180506 KTOMIAK "Kenneth Tomiak"<CBT_Ken@KTomiak.BIZ>
         -     1) Copied major portions of DFHRXALL. Kept:
      20180427    a) Added Delstr_Apost to remove apostrophes.
                  b) Removed txid_txt output.
                  c) Reads new security and description file.
                  d) Writes smarter RACF groupings.
                  e) Changed format of txid_txt output.
                  f) Expanded list of transactions.
                  g) Added TXIDTXT to show list of transactions and
                     their descriptions. IBM manuals have them
                     scattered all over the place.
               2) Stylize using:
                  Programming Using The Kenneth Tomiak Method.
                 a) Remove superfluous rexx comment.
                 b) Updated Syntax.
                 c) Parentheses on DO WHILE.
                 d) ADDRESS MVS before EXECIO.
               3) Update Load_Object_Types using new types from
                  testing DFHRXALL on CICS 4.2 and 5.4.
                    ATOMSERVICE          480 ( 01E0)
                    PARTNER             2500 ( 09C4)
                    ENQMODEL            5500 ( 157C)
                    LIBRARY             5600 ( 15E0)
                    MQCONN              5800 ( 16A8)
                    URIMAPS             9300 ( 2454)
                    PIPELINES           9400 ( 24B8)
                    WEBSERVICE          9500 ( 251C)
                    IPCONN              9600 ( 2580)
                    JVMSERVERS          9700 ( 25E4)
                    BUNDLES            30000 ( 7530)
----- -------- --------------------------------------------------------
----- -------- --------------------------------------------------------
01.10 20180506 KTOMIAK "Kenneth Tomiak"<CBT_Ken@KTomiak.BIZ>
         -     1) Add the routine to retrieve ddnames allocated.
      20180505 2) Include Swareq22 and Hex_To_Bit.
               3) Added JCL to comment block.
----- -------- --------------------------------------------------------
01.09 20180505 KTOMIAK "Kenneth Tomiak"<CBT_Ken@KTomiak.BIZ>
         -     1) Stylize using Edit Macro @putktm:
      20180427    Programming Using The Kenneth Tomiak Method.
               2) Updated Ctlblk_Jobspecs.
               3) Stylize using:
                  Programming Using The Kenneth Tomiak Method.
                 a) Remove superfluous rexx comment.
                 b) Remove unused PARSE ARG.
                 c) Parentheses on DO WHILE.
               4) Stylize using template $putktm:
                  Programming Using The Kenneth Tomiak Method.
               5) Stylize using Edit Macro @putktm:
                  Programming Using The Kenneth Tomiak Method.
----- -------- --------------------------------------------------------
01.08 20180215 KTOMIAK "Kenneth Tomiak"<CBT_Ken@KTomiak.BIZ>
               1) Added 9500/251C WEBSERVICE.
----- -------- --------------------------------------------------------
01.07 20180215 KTOMIAK "Kenneth Tomiak"<CBT_Ken@KTomiak.BIZ>
               1) Added 5600/15E0 LIBRARY.
               2) Added 5800/16A8 MQCONN.
----- -------- --------------------------------------------------------
01.06 20180213 KTOMIAK "Kenneth Tomiak"<CBT_Ken@KTomiak.BIZ>
               1) Added 9600/2580 IPCONN.
               2) Added 9300/2454 URIMAPS.
----- -------- --------------------------------------------------------
01.05 20180213 KTOMIAK "Kenneth Tomiak"<CBT_Ken@KTomiak.BIZ>
               1) Added 480/01E0 ATOMSERVICE.
----- -------- --------------------------------------------------------
01.04 20180203 KTOMIAK "Kenneth Tomiak"<CBT_Ken@KTomiak.BIZ>
               1) Added 9400/24B5 PIPELINES.
               2) Added 9700/25E4 JVMSERVERS.
               3) Added 30000/7530 BUNDLES.
               4) Added SIGNAL ON ERROR CALL New_Record_Type prior to
                  INTERPRET CALL "Unbundle_"call_rtn
               5) Added routine New_Record_Type to dump the new record.
               6) Added code for WHEN (field_type = "D") THEN DO
                  This is a timestamp field.
----- -------- --------------------------------------------------------
01.03 20070504 KTOMIAK "Kenneth Tomiak"<CBT_Ken@KTomiak.BIZ>
               1) Working on using metadata descriptions
----- -------- --------------------------------------------------------
01.02 20070503 KTOMIAK "Kenneth Tomiak"<CBT_Ken@KTomiak.BIZ>
               1) read and parse metadata description of records.
----- -------- --------------------------------------------------------
01.01 20070502 KTOMIAK "Kenneth Tomiak"<CBT_Ken@KTomiak.BIZ>
               1) Added deparsing and show routines.
                    Added calls on each record type.
                    Added flag code.
                    Added RETURN before each field description block.
                    Added types, where known, to FDB.
----- -------- --------------------------------------------------------
01.00 20070420 KTOMIAK "Kenneth Tomiak"<CBT_Ken@KTomiak.BIZ>
               1) Original code.
----- -------- --------------------------------------------------------

-----------------------------------------------------------------------

STANDARD GLOBAL DISCLAIMER
--------------------------
The author explicitly disavows any claim whatsoever about the
correctness or functionality of this program, and disclaims liability
for anything and everything bad that might happen in connection with,
before, during, or after using it. I have tried to make it work right,
and I am personally pretty confident that it does, but everybody makes
mistakes, so if you use it, you do so at your own risk.

=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 This routine initializes constants and variables.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Initialization_Routine:
  return_code = 0
  PARSE SOURCE,
    source_host_env,
    source_call_type,
    source_uc_exec_name,
    source_hostdd,
    source_hostdsn,
    source_nf_exec_name,
    source_initial_cmd_env,
    source_asid_name,
    source_char8_user_token,
    source_hostother
  sysvar_sysuid = SYSVAR("SYSUID")
  sysvar_sysenv = SYSVAR("SYSENV")
  mvsvar_sysname = MVSVAR("SYSNAME")
  job_specs = Ctlblk_Jobspecs()
  SAY ""
  SAY COPIES("=",79)
  SAY LEFT("=" jobspecs_jobname ,
    jobspecs_ssibjbid jobspecs_stepname ,
    jobspecs_procname,77) "="
  SAY LEFT("=" source_uc_exec_name rexxpgm_version,77) "="
  SAY LEFT("= executing under" source_host_env,77) "="
  SAY LEFT("= as a" source_call_type,77) "="
  SAY LEFT("= on" DATE() "at" TIME()".",77) "="
  SAY COPIES("=",79)
  SAY ""

  IF (source_host_env <> "TSO") THEN DO
    SAY LEFT("= Wrong host environment" source_host_env".",77) "="
    SAY COPIES("=",79)
    return_code = 20
    return return_code
  END

  PARSE UPPER VAR all_my_arguments,
    =1 . "SECPRFX=" rdefine_secprfx " ",
    =1 . "LIST=" startup_list " ",
    .

  IF (POS("SHOW",all_my_arguments) > 0) THEN DO
    show_sw = 1
    SAY LEFT("= on" DATE() "at" TIME()".",77) "="
    SAY COPIES("=",79)
  END
  ELSE DO
    show_sw = 0
  END
  IF (POS("DEBUG",all_my_arguments) > 0) THEN DO
    debug_sw = 1
    SAY LEFT("= DEBUG turned on.",77) "="
    SAY COPIES("=",79)
  END
  ELSE DO
    debug_sw = 0
  END
  SAY ""

  IF (rdefine_secprfx = "") THEN DO
    rdefine_secprfx = "|security_pfx|"
  END

  alpha_upper_chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

  startup_groups = ""
  group_protected. = "N"

  role_txid. = ""
  role_descr. = ""
  role_descr.0 = 0

  ctr_type. = 0
  grp_ctr. = 0
  last_object = ""
  meta_object. = ""
  meta_orb = ""
  meta_orb. = ""
  mxct_orb = 0
  stem_orb. = ""

  cics_cmd.0 = 0
  cics_cmd.0 = Add_Cics_Cmd("//*")
  cics_cmd.0 = Add_Cics_Cmd("//* Created:" DATE("S") TIME() "*/")
  cics_cmd.0 = Add_Cics_Cmd("//*")
  cics_cmd.0 = ,
    Add_Cics_Cmd("//         SET CICSLOAD='DFH540.CICS.SDFHLOAD'")
  cics_cmd.0 = Add_Cics_Cmd("//*")
  cics_cmd.0 = Add_Cics_Cmd("//ALTERS  EXEC PGM=DFHCSDUP")
  cics_cmd.0 = Add_Cics_Cmd("//STEPLIB   DD DISP=SHR,DSN=&CICSLOAD")
  cics_cmd.0 = Add_Cics_Cmd("//SYSIN     DD DATA,DLM=ED")
  cics_cmd.0 = Add_Cics_Cmd("//LIST ALL OBJECTS")
  racf_cmd.0 = 0
  racf_cmd.0 = Add_Racf_Cmd("//*")
  racf_cmd.0 = Add_Racf_Cmd("//RDEFINE EXEC PGM=IKJEFT1B,PARM='',")
  racf_cmd.0 = Add_Racf_Cmd("//             DYNAMNBR=32,REGION=32M")
  racf_cmd.0 = Add_Racf_Cmd("//SYSTSIN   DD DATA,DLM=ED")
  txid_def.0 = 0
  txid_def.0 = Add_Txid_Def("*----- --------" COPIES("-",54))
  txid_def.0 = Add_Txid_Def("*01.00" DATE("S") "DFHR1388 REXX program")

  allcblk = Retrieve_Allocations()
  function_rc = Parse_Allcblk()

  find_dd = "DFHCSDSQ"
  read_rc = Read_Any_Ddname(find_dd)
  IF (read_rc <> 0) THEN DO
    SAY "Read ERROR on" find_dd", RC("read_rc")"
    return_code = read_rc
    return return_code
  END
  IF (dfhcsdsq_record.0 = 0) THEN DO
    SAY find_dd "is empty. Nothing to do!"
    return_code = 16
    return return_code
  END

  find_dd = "DFHRMETA"
  read_rc = Read_Any_Ddname(find_dd)
  IF (read_rc <> 0) THEN DO
    SAY "Read ERROR on" find_dd", RC("read_rc")"
    return_code = read_rc
    return return_code
  END
  IF (dfhrmeta_record.0 = 0) THEN DO
    SAY find_dd "is empty. Nothing to do!"
    return_code = 16
    return return_code
  END
  function_rc = Load_Object_Types()
  parse_rc = Parse_Dfhrmeta()

  find_dd = "TXIDDESC"
  read_rc = Read_Any_Ddname(find_dd)
  IF (read_rc <> 0) THEN DO
    SAY "Read ERROR on" find_dd", RC("read_rc")"
    return_code = read_rc
    return return_code
  END
  IF (txiddesc_record.0 = 0) THEN DO
    SAY find_dd "is empty. Nothing to do!"
    return_code = 16
    return return_code
  END
  function_rc = Load_Undescribed_Txid()

  RETURN return_code

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 This routine does the processing.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Process_Routine:
  DO ix = 1 TO dfhcsdsq_record.0 BY 1
    PARSE VAR dfhcsdsq_record.ix,
      record_key +22,
      =1 record_name +8,
         record_sequence +3,
         record_flag +1,
         record_type +2,
         record_entry +8,
         record_data_length +2,
         record_upddttm +6,
         record_flags +14,
         record_nbr_fields +1,
         record_nbr_flags +1,
         record_data

    record_name = STRIP(record_name)
    decimal_sequence = C2D(record_sequence)
    hex_objtype = C2X(record_type)
    IF (hex_objtype = "000D") THEN DO
      function_rc = Unbundle_Dfhcsd_Records()
      unbundle_rc = Unbundle_Groupinalist()
    END
  END

  IF (show_sw = 1) THEN DO
    SAY "Groups in startup list" startup_list
    DO wx = 1 TO WORDS(startup_groups)
      SAY " " WORD(startup_groups,wx)
  END
  END

  DO ix = 1 TO dfhcsdsq_record.0 BY 1
    PARSE VAR dfhcsdsq_record.ix,
      record_key +22,
      =1 record_name +8,
         record_sequence +3,
         record_flag +1,
         record_type +2,
         record_entry +8,
         record_data_length +2,
         record_upddttm +6,
         record_flags +14,
         record_nbr_fields +1,
         record_nbr_flags +1,
         record_data

    record_name = STRIP(record_name)
    decimal_sequence = C2D(record_sequence)
    hex_objtype = C2X(record_type)
    record_description = meta_orb.hex_objtype
    decimal_data_length = C2D(record_data_length)
    record_date_time = LEFT(C2X(record_upddttm),11)
    record_update_date = LEFT(record_date_time,5)
    record_update_greg = DATE("S",record_update_date,"j")
    record_update_time = RIGHT(record_date_time,6)
    decimal_nbr_fields = C2D(record_nbr_fields)
    decimal_nbr_flags = C2D(record_nbr_flags) * 2
    IF (C2D(X2C(hex_objtype)) > 0) THEN DO
      function_rc = Unbundle_Dfhcsd_Records()
    END
    ELSE DO
      SAY "I am not parsing: '"hex_objtype"'x."
      ITERATE
    END
    IF (record_description = "") THEN DO
      call_rtn = "Error"
    END
    ELSE DO
      call_rtn = record_description
    END
    new_val = VALUE("ctr_type."call_rtn) + 1
    old_val = VALUE("ctr_type."call_rtn,new_val)
    IF (show_sw = 1) THEN DO
      SAY "Record("ix") Type("hex_objtype")",
        "Group("record_name") Description("record_description")",
        "#" new_val
    END
    SIGNAL ON ERROR NAME New_Record_Type
    INTERPRET "function_rc = Unbundle_"call_rtn"()"
Continue_On:
  END
  RETURN return_code

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 This routine does cleanup before exiting.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Termination_Routine:
  function_rc = Show_Record_Type_Totals()
  cics_cmd.0 = Add_Cics_Cmd("ED")
  cics_cmd.0 = Add_Cics_Cmd("//SYSPRINT  DD SYSOUT=*")
  cics_cmd.0 = Add_Cics_Cmd("//DFHCSD    DD DISP=OLD," || ,
    "DSN=&SYSUID..CICS540.DFHCSD")
  cics_cmd.0 = Add_Cics_Cmd("//*")
  cics_cmd.0 = Add_Cics_Cmd("//* End of job DFHRCICS.")
  cics_cmd.0 = Add_Cics_Cmd("//")
  ADDRESS MVS "EXECIO",
    cics_cmd.0 "DISKW CICSCMD (FINIS STEM cics_cmd.)"
  DO rx = 1 TO 34
    IF (role_txid.rx = "") THEN DO
      ITERATE rx
    END
    rxw = WORDS(role_txid.rx)
    racf_cmd.0 = Add_Racf_Cmd(" ")
    racf_cmd.0 = Add_Racf_Cmd(" /* Desc("func_descr.rx "*/")
    racf_cmd.0 = Add_Racf_Cmd("  RDEFINE GCICSTRN" ,
      "("rdefine_secprfx || role_descr.rx") UACC(NONE) +")
    racf_cmd.0 = Add_Racf_Cmd("    ADDMEM( +")
    stem. = ""
    stem.0 = 0
    DO rxx = 1 TO rxw
      tmp_ctr = stem.0 + 1
      stem.tmp_ctr = WORD(role_txid.rx,rxx)
      stem.0 = tmp_ctr
    END
    sort_rc = Sort_Stem_Asc()
    DO sx = 1 TO stem.0
      one_txid = stem.sx
      racf_cmd.0 = Add_Racf_Cmd("          " one_txid "+")
    END
    racf_cmd.0 = Add_Racf_Cmd("          ) +")
    racf_cmd.0 = Add_Racf_Cmd("    NOTIFY(security_admin_userid) +")
    racf_cmd.0 = Add_Racf_Cmd("    OWNER(groupid)")
  END
  racf_cmd.0 = Add_Racf_Cmd("LOGOFF")
  DO rx = 1 TO 34
    IF (role_txid.rx = "") THEN DO
      ITERATE rx
    END
    racf_cmd.0 = ,
      Add_Racf_Cmd("  PERMIT" rdefine_secprfx || role_descr.rx ,
      "CLASS(GCICSTRN) ACCESS(READ)")
    racf_cmd.0 = ,
      Add_Racf_Cmd("  CONNECT (userid) GROUP(" || ,
      rdefine_secprfx || role_descr.rx")")
  END
  racf_cmd.0 = Add_Racf_Cmd("ED")
  racf_cmd.0 = Add_Racf_Cmd("//SYSTSPRT  DD SYSOUT=*")
  racf_cmd.0 = Add_Racf_Cmd("//*")
  racf_cmd.0 = Add_Racf_Cmd("//* END OF JOB DFHRRACF.")
  racf_cmd.0 = Add_Racf_Cmd("//")
  ADDRESS MVS "EXECIO",
    racf_cmd.0 "DISKW RACFCMD (FINIS STEM racf_cmd.)"
  ADDRESS MVS "EXECIO",
    txid_def.0 "DISKW TXIDDEF (FINIS STEM txid_def.)"
  RETURN return_code

/* hereken - bulid single RDEFINE per profile */
    IF (grp_ctr.one_func = 0) THEN DO
    END
    ELSE DO
      racf_verb = "RALTER "
    END
    grp_ctr.one_func = VALUE("grp_ctr."one_func,grp_ctr.one_func) + 1
    racf_cmd.0 = Add_Racf_Cmd(" "racf_verb "GCICSTRN",
      racf_group||one_func,
      "ADDMEM("data_data.01")",
      "/*" record_group "*/ +")
    IF (grp_ctr.one_func = 1) THEN DO
      racf_cmd.0 = Add_Racf_Cmd("   DATA('"data_data.15"') +")
    END
    racf_cmd.0 = Add_Racf_Cmd("   UACC(NONE) OWNER(CICS)")

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 Load the known record types (as of this time).
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
Load_Object_Types:
  all_types = ""
  all_types = all_types "1 PRIMERECORD"                   /* x'0001' */
  all_types = all_types "5 IBMINITIAL"                    /* x'0005' */
  all_types = all_types "6 GROUP"                         /* x'0006' */
  all_types = all_types "13 GROUPINALIST"                 /* x'000D' */
  all_types = all_types "480 ATOMSERVICE"                 /* x'01E0' */
  all_types = all_types "500 CONNECTION"                  /* x'01F4' */
  all_types = all_types "550 CORBASERVER"                 /* x'0226' */
  all_types = all_types "600 DJAR"                        /* x'0258' */
  all_types = all_types "650 LSRPOOL"                     /* x'028A' */
  all_types = all_types "800 FILE"                        /* x'0320' */
  all_types = all_types "900 JOURNALMODEL"                /* x'0384' */
  all_types = all_types "1000 MAPSET"                     /* x'03E8' */
  all_types = all_types "2000 PARTITIONSET"               /* x'07D0' */
  all_types = all_types "2500 PARTNER"                    /* x'09C4' */
  all_types = all_types "3000 PROFILE"                    /* x'0BB8' */
  all_types = all_types "4000 PROGRAM"                    /* x'0FA0' */
  all_types = all_types "4333 SESSIONS"                   /* x'10ED' */
  all_types = all_types "4555 TYPETERM"                   /* x'11CB' */
  all_types = all_types "4666 TERMINAL"                   /* x'123A' */
  all_types = all_types "4888 TRANCLASS"                  /* x'1318' */
  all_types = all_types "5000 TRANSACTION"                /* x'1388' */
  all_types = all_types "5500 ENQMODEL"                   /* x'157C' */
  all_types = all_types "5600 LIBRARY"                    /* x'15E0' */
  all_types = all_types "5800 MQCONN"                     /* x'16A8' */
  all_types = all_types "6000 TDQUEUE"                    /* x'1770' */
  all_types = all_types "7000 DB2CONN"                    /* x'1B58' */
  all_types = all_types "7500 DB2ENTRY"                   /* x'1D4C' */
  all_types = all_types "7900 DB2TRAN"                    /* x'1EDC' */
  all_types = all_types "8000 TSMODEL"                    /* x'1F40' */
  all_types = all_types "8500 PROCESSTYPE"                /* x'2134' */
  all_types = all_types "9000 REQUESTMODEL"               /* x'2328' */
  all_types = all_types "9100 DOCTEMPLATE"                /* x'238C' */
  all_types = all_types "9200 TCPIPSERVICE"               /* x'23F0' */
  all_types = all_types "9300 URIMAPS"                    /* x'2454' */
  all_types = all_types "9400 PIPELINES"                  /* x'25B8' */
  all_types = all_types "9500 WEBSERVICE"                 /* x'251C' */
  all_types = all_types "9600 IPCONN"                     /* x'2580' */
  all_types = all_types "9700 JVMSERVERS"                 /* x'25E4' */
  all_types = all_types "30000 BUNDLES"                   /* x'7530' */
  DO ix = 1 TO WORDS(all_types) BY 2
    old_val = VALUE("ctr_type."WORD(all_types,ix),0)
  END
  RETURN 0

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 In this routine we try to dump a new record type.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
New_Record_Type:
  SAY ""
  SAY ">>ERROR>>-1"
  new_data = dfhcsdsq_record.ix
  DO WHILE (new_data <> "")
    PARSE VAR new_data new_block +80 new_data
    hex_data = C2X(new_block)
    SAY "CHAR:" new_block
    new_hex = ""
    DO nhi = 1 TO LENGTH(hex_data) BY 2
      new_hex = new_hex||SUBSTR(hex_data,nhi,1)
    END
    SAY "HEX1:" new_hex
    new_hex = ""
    DO nhi = 2 TO LENGTH(hex_data) BY 2
      new_hex = new_hex||SUBSTR(hex_data,nhi,1)
    END
    SAY "HEX2:" new_hex
  END
  SAY ">>ERROR>>-2"
  SIGNAL Continue_On

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 In this routine we show totals.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
Show_Record_Type_Totals:
  IF (return_code = 0) THEN DO
    SAY " "
    SAY " Record type totals"
    total_records = 0
    DO ix = 1 TO mxct_orb
      hex_objtype = stem_orb.ix
      record_description = meta_orb.hex_objtype
      old_val = VALUE("ctr_type."record_description)
      total_records = total_records + old_val
      SAY RIGHT("   "ix,3) "Type("hex_objtype")",
        RIGHT("        "old_val,8),
        "Description("record_description")"
    END
    SAY ""
    SAY "Total counted=" RIGHT("        "total_records,8)
    SAY "Total read   =" RIGHT("        "dfhcsdsq_record.0,8)
  END
  RETURN return_code

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 Follow control blocks to identify jobname, type, and JES number.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
Ctlblk_Jobspecs:
  ptr2psa = 0
  cvtptr = STORAGE(D2X(ptr2psa + 16),4)
  cvtsmca = STORAGE(D2X(C2D(cvtptr)+197),3)
  smfid = STORAGE(D2X(C2D(cvtsmca)+16),4)
  psatold = STORAGE(21C,4)
  ptr2tiot = STORAGE(D2X(C2D(psatold)+12),4)
  jobspecs_jobname = STORAGE(D2X(C2D(ptr2tiot)),8)
  jobspecs_stepname = STORAGE(D2X(C2D(ptr2tiot)+8),8)
  jobspecs_procname = STORAGE(D2X(C2D(ptr2tiot)+16),8)
  tcbjscbb = STORAGE(D2X(C2D(psatold)+181),3)
  jscbssib = STORAGE(D2X(C2D(tcbjscbb)+316),4)
  jobspecs_ssibjbid = STORAGE(D2X(C2D(jscbssib)+12),8)
  RETURN jobspecs_jobname jobspecs_ssibjbid ,
    jobspecs_stepname jobspecs_procname

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 Make sure the DD is allocated, then read everything.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
Read_Any_Ddname:
  PARSE UPPER ARG my_ddname
  found_dd = tiotddnm.my_ddname
  IF (found_dd = "") THEN DO
    return_code = 16
    RETURN return_code
  END
  ELSE DO
    SAY "Reading DDname("my_ddname")"
    found_dsns = dd_dsname.my_ddname.0
    DO ds_x = 1 TO found_dsns
      SAY "  DSN="dd_dsname.my_ddname.ds_x
    END
  END
  trap_msg = OUTTRAP("io_msgs.")
  quietly = MSG("OFF")
  ADDRESS MVS "EXECIO",
    "* DISKR" my_ddname "0 (FINIS STEM" my_ddname"_record.)"
  read_rc = RC
  trap_msg = OUTTRAP("OFF")
  noisily = MSG("ON")
  IF (read_rc <> 0) THEN DO
    return_code = read_rc
    RETURN return_code
  END
  records_read = VALUE(my_ddname"_record.0")
  SAY "  Records read ("records_read") from" find_dd"."
  RETURN 0

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 Chase control blocks and build a STEM of DDnames and DSnames.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
Retrieve_Allocations:
  psatold = STORAGE(21C,4)                       /* POINTER TO TCB  */
  ptr2tiot = STORAGE(D2X(C2D(psatold)+12),4)     /* POINTER TO TIOT */
  tiotptr = D2C(C2D(ptr2tiot)+24)                /* TIOT pointer    */
  tiotelen = C2D(STORAGE(D2X(C2D(tiotptr)+0),1))
  dd_names = 0
  DO WHILE (tiotelen > 0)
    tiotflag = C2D(STORAGE(D2X(C2D(tiotptr)+1),1))
    tiotddnm = SPACE(STORAGE(D2X(C2D(tiotptr)+4),8))
    IF (BITAND(tiotflag,'80'X) = '80'X) THEN DO /* active ddname   */
      IF (tiotddnm = COPIES("00"x,8)) THEN DO
        LEAVE
      END
      IF (tiotddnm <> "      ") THEN DO
        dd_name = STRIP(tiotddnm,"B"," ")
        dd_names = dd_names + 1
        dd_name.dd_names = dd_name
        dd_nnbr.tiotddnm = dd_names
        dsname.dd_names.0 = 0
      END
      tioejfcb = STORAGE(D2X(C2D(tiotptr)+12),3)
      jfcb = Swareq22(tioejfcb)
      IF (jfcb > 0) THEN DO
        jfcbdsn = STRIP(STORAGE(D2X(jfcb+000),44),"B"," ")
        jfcbelnm = STRIP(STORAGE(D2X(jfcb+044),8),"B"," ")
        IF (jfcbelnm <> "") THEN DO
          fullname = jfcbdsn"("jfcbelnm")"
        END
        ELSE DO
          fullname = jfcbdsn
        END
        ds_temp = dsname.dd_names.0 + 1
        dsname.dd_names.0 = ds_temp
        dsname.dd_names.ds_temp = fullname
      END
      ELSE DO
        SAY "Oh my gosh, SWAREQ and BATCH do not mix."
        LEAVE
      END
    END
    tiotptr = D2C(C2D(tiotptr)+tiotelen)
    tiotelen = C2D(STORAGE(D2X(C2D(tiotptr)+0),1))
  END
  RETURN dd_names

/* --------------------------------------------------------------------
   Handle SWA above or below the bar.
   Fix from Don Poitras to adjust to z/OS 2.2 putting
   a control block above the 64-bit bar.

     https://groups.google.com/forum/#!
     msg/bit.listserv.ibm-main/E-fMschhS2M/Na4x_Vc9BgAJ

     Comes out of
     http://www.cbttape.org/ftp/cbt/CBT183.zip

-------------------------------------------------------------------- */
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 Convert an ADDRESS in SWA format to usable location
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
Swareq22: PROCEDURE
  NUMERIC DIGITS 16                   /* Handles Petabyte addressing */
  sva = C2D(ARG(1))                         /* convert to decimal   */
  tcb = C2D(STORAGE(21C,4))                 /* TCB         psatold  */
  jscb = C2D(STORAGE(D2X(tcb+180),4))       /* JSCB        TCBJSCB  */
  qmpl = C2D(STORAGE(D2X(jscb+244),4))      /* QMPL        JSCBQMPI */
  /* See if qmat can be above the bar */
  qmsta = C2X(STORAGE(D2X(qmpl+16),1))     /* JOB STATUS BYTE      */
  IF (SUBSTR(Hex_To_Bit(qmsta),6,1)) THEN DO /* QMQMAT64 bit on   */
    IF (RIGHT(Hex_To_Bit(C2X(ARG(1))),1) <> "1") THEN DO /* BELOW  */
      RETURN C2D(ARG(1)) + 16             /* yes, RETURN sva+16   */
    END
    qmat = C2D(STORAGE(D2X(qmpl+10),2))*(2**48) +, /* QMAT+0 QMADD01 */
         C2D(STORAGE(D2X(qmpl+18),2))*(2**32) + ,  /* QMAT+2 QMADD23 */
         C2D(STORAGE(D2X(qmpl+24),4))              /* QMAT+4 QMADD */
    RETURN C2D(STORAGE(D2X(qmat+(sva*12)+64),4))+16
  END
  ELSE DO /* NO, QMAT IS BTB      */
    IF (RIGHT(C2X(ARG(1)),1) <> "F") THEN DO /* SWA=BELOW ?          */
      RETURN C2D(ARG(1))+16                 /* yes, RETURN sva+16   */
    END
    qmat = C2D(STORAGE(D2X(qmpl+24),4))     /* QMAT        QMADD    */
    DO WHILE (sva > 65536)
      qmat = C2D(STORAGE(D2X(qmat+12),4))   /* next QMAT   QMAT+12  */
      sva = sva - 65536                     /* 010006F -> 000006F   */
    END
    RETURN C2D(STORAGE(D2X(qmat+sva+1),4))+16
  END
  RETURN "ERROR, SHOULD NOT REACH HERE!"

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 Convert a hexadecimal VALUE to its bitstring value.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
Hex_To_Bit:
  IF (bits.F <> "1111") THEN DO
    bits.0="0000"; bits.1="0001"; bits.2="0010"; bits.3="0011"
    bits.4="0100"; bits.5="0101"; bits.6="0110"; bits.7="0111"
    bits.8="1000"; bits.9="1001"; bits.A="1010"; bits.B="1011"
    bits.C="1100"; bits.D="1101"; bits.E="1110"; bits.F="1111"
  END
  hexchr = ARG(1)
  bit_str = ''
  DO ix = 1 TO LENGTH(hexchr)
    str = SUBSTR(hexchr,ix,1)
    bit_str = bit_str||bits.str
  END
  RETURN bit_str

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 Parse the stream of ddname information.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
/* #dds;dd#;ddname;#dsn;dsn#;dsname;...                              */
Parse_Allcblk:
  allofit = allcblk
  tiotddnm. = ""
  tiotddnm.0 = DD#
  erc = dd_names
  DO dd# = 1 TO dd_names
    dn = dd_name.dd#
    tiotddnm.dn = dd#
    nd = dsname.dd#.0
    erc = erc";"dd#";"dn";"nd
    dd_dsname.dn.0 = nd
    DO ds# = 1 TO nd
      dd_dsname.dn.ds# = dsname.dd#.ds#
    END
  END
  RETURN 0

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 Show all the flag fields in hexadecimal.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
Show_Flag_Fields:
  IF (show_sw = 0) THEN DO
    RETURN 0
  END
  SAY "  Flag fields:"
  DO ffx = 1 TO WORDS(flag_types)
    one_flag = WORD(flag_types,ffx)
    flag_nbr = C2D(flag_data.one_flag)
    field_name = VALUE(meta_flag"."hex_objtype"."one_flag)
    field_type = VALUE(meta_type"."hex_objtype"."one_flag)
    flag_value = VALUE(meta_flag"."hex_objtype"."one_flag"."flag_nbr)
    SAY "  " RIGHT("    "ffx,3) "("one_flag")",
      field_name"("C2X(flag_data.one_flag)")",
      flag_value
  END
  RETURN 0

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 Show all the data fields.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
Show_Data_Fields:
  IF (show_sw = 0) THEN DO
    RETURN 0
  END
  SAY "  Data fields:"
  DO ffx = 1 TO WORDS(data_types)
    one_data = WORD(data_types,ffx)
    field_name = VALUE(meta_data"."hex_objtype"."one_data)
    field_type = VALUE(meta_type"."hex_objtype"."one_data)
    SELECT
      WHEN (field_type = "T") THEN DO
        SAY "  " RIGHT("   "ffx,3) "("one_data")",
          field_name"("data_data.one_data")"
      END
      WHEN (field_type = "D") THEN DO
        tunits = data_data.one_data /* from Mark Zelden */
        TIMESTAMP = COPIES(0,26)  /* force RESULT length=26 */
        ADDRESS LINKPGM "BLSUXTOD TUNITS TIMESTAMP"
        SAY "  " RIGHT("   "ffx,3) "("one_data")",
          field_name"("timestamp")"
      END
      WHEN (field_type = "N") THEN DO
        SAY "  " RIGHT("   "ffx,3) "("one_data")",
          field_name"("C2D(data_data.one_data)")"
      END
      WHEN (field_type = "X") THEN DO
        SAY "  " RIGHT("   "ffx,3) "("one_data")",
          field_name"("C2X(data_data.one_data)")"
      END
      WHEN (LENGTH(field_type) > 1) THEN DO
        SAY "  " RIGHT("    "ffx,3) "("one_data")",
          field_name"("C2X(data_data.one_data)")"
      END
      OTHERWISE DO
        repeat_count = POS(field_type,alpha_upper_chars)
        repeat_data = data_data.one_data
        display_data = ""
        DO rx = 1 TO repeat_count
          repeat_off = ((rx - 1) * 4) + 1
          repeat_one = C2D(SUBSTR(repeat_data,repeat_off,4))
          display_data = display_data||repeat_one","
        END
        display_data = STRIP(display_data,"B",",")
        SAY "  " RIGHT("    "ffx,3) "("one_data")",
          field_name"("display_data")"
      END
    END
  END
  RETURN 0

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 An ERROR occurred,
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
Unbundle_Error:
  SAY ""
  SAY ">>ERROR>>-3"
  SAY "Record("ix") type("record_type") is not yet defined."
  RETURN 0

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 Parse the records from the DFHCSD.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
Unbundle_Dfhcsd_Records:
  flag_data. = ""
  flag_types = ""
  IF (decimal_nbr_flags > 0) THEN DO
    PARSE VAR record_data,
      record_flags +(decimal_nbr_flags),
      record_fields
    DO WHILE (record_flags <> "")
      PARSE VAR record_flags,
        field_type +1,
        field_data +1,
        record_flags
      hex_type = C2X(field_type)
      flag_types = flag_types||hex_type" "
      flag_data.hex_type = field_data
    END
    flag_types = STRIP(flag_types,"B"," ")
  END
  ELSE DO
    record_fields = record_data
  END

  data_data. = ""
  data_types = ""
  DO WHILE (record_fields <> "")
    PARSE VAR record_fields,
      field_type +1,
      field_length +1,
      record_fields
    hex_type = C2X(field_type)
    data_types = data_types||hex_type" "
    extract_length = C2D(field_length)
    PARSE VAR record_fields,
      data_data +(extract_length),
      record_fields
    data_data.hex_type = data_data
  END

  data_types = STRIP(data_types,"B"," ")
  RETURN 0

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 These routines break down each record by type.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
/* PRIMER                                   1 ( 0001)                */
Unbundle_Primerecord:
  PARSE VAR dfhcsdsq_record.ix,
    record_key +22,
    record_data_length +2,
    primerecord_upddttm +6,
    primerecord_crddttm +6,
    =37 primerecord_vermodrel +4,
    =45 primerecord_cics +4,
    =57 primerecord_prodid +12,
    =71 primerecord_80 +1,
    .

  primerecord_date_time = LEFT(C2X(primerecord_upddttm),11)
  primerecord_update_date = LEFT(primerecord_date_time,5)
  primerecord_update_greg = DATE("S",primerecord_update_date,"J")
  primerecord_update_time = RIGHT(primerecord_date_time,6)
  primerecord_date_time = LEFT(C2X(primerecord_crddttm),11)
  primerecord_create_date = LEFT(primerecord_date_time,5)
  primerecord_create_greg = DATE("S",primerecord_create_date,"J")
  primerecord_create_time = RIGHT(primerecord_date_time,6)

  IF (show_sw = 1) THEN DO
    SAY "Record("ix")",
      "This is the primer record.",
      primerecord_cics primerecord_vermodrel primerecord_prodid
    SAY "The DFHCSD was last updated:",
      primerecord_update_date,
      primerecord_update_greg,
      primerecord_update_time
    SAY "The DFHCSD was initialized:",
      primerecord_create_date,
      primerecord_create_greg,
      primerecord_create_time
  END
  RETURN 0

/* IBMINITIAL (entry)                       5 ( 0005)                */
Unbundle_Ibminitial:
  PARSE VAR dfhcsdsq_record.ix,
    record_key +22,
    record_data_length +2,
    record_upddttm +6,
    ibminitial_eyecatcher +11,
    .

  group_protected.record_name = "Y"
  record_date_time = LEFT(C2X(record_upddttm),11)
  record_update_date = LEFT(record_date_time,5)
  record_update_greg = DATE("S",record_update_date,"J")
  record_update_time = RIGHT(record_date_time,6)

  IF (show_sw = 1) THEN DO
    SAY "Record("ix")",
      "Group("record_name")",
      record_update_date,
      record_update_greg,
      record_update_time,
      "(IBM INITIAL)"
  END
  RETURN 0

/* GROUP (every)                            6 ( 0006)                */
Unbundle_Group:
  PARSE VAR dfhcsdsq_record.ix,
    record_key +22,
    record_data_length +2,
    record_upddttm +6,
    record_flag +3,
    group_type +1,
    .

  record_date_time = LEFT(C2X(record_upddttm),11)
  record_update_date = LEFT(record_date_time,5)
  record_update_greg = DATE("S",record_update_date,"J")
  record_update_time = RIGHT(record_date_time,6)

  IF (show_sw = 1) THEN DO
    SELECT
      WHEN (group_type = '0F'x) THEN DO
        SAY "Record("ix")",
          "GROUP("record_name")",
          record_update_date,
          record_update_time
      END
      WHEN (group_type = 'FF'x) THEN DO
        SAY "Record("ix")",
          "LIST("record_name")",
          record_update_date,
          record_update_time
      END
      OTHERWISE DO
        SAY "Record("ix")",
          "UNKNOWN("record_name")",
          "TYPE("C2X(group_type)")"
      END
    END
  END
  RETURN 0

/* GROUPINALIST                            13 ( 000D)                */
Unbundle_Groupinalist:
  function_rc = Show_Flag_Fields()
  function_rc = Show_Data_Fields()
  IF (show_sw = 1) THEN DO
    SAY "Record("ix")",
      "Group" data_data.02 ,
      "in list" data_data.01", type("C2X(record_type)")."
  END
  IF (data_data.01 = startup_list) THEN DO
    IF (POS(data_data.02,startup_groups) = 0) THEN DO
      startup_groups = startup_groups " " data_data.02
    END
  END
  RETURN 0

/* ATOMSERVICE                            480 ( 01E0)                */
Unbundle_Atomservice:
  function_rc = Show_Flag_Fields()
  function_rc = Show_Data_Fields()
  RETURN 0

/* CONNECTION                             500 ( 01F4)                */
Unbundle_Connection:
  function_rc = Show_Flag_Fields()
  function_rc = Show_Data_Fields()
  RETURN 0

/* CORBASERVER                            550 ( 0226)                */
Unbundle_Corbaserver:
  function_rc = Show_Flag_Fields()
  function_rc = Show_Data_Fields()
  RETURN 0

/* DJAR                                   600 ( 0258)                */
Unbundle_Djar:
  function_rc = Show_Flag_Fields()
  function_rc = Show_Data_Fields()
  RETURN 0

/* LSRPOOL                                650 ( 028A)                */
Unbundle_Lsrpool:
  function_rc = Show_Flag_Fields()
  function_rc = Show_Data_Fields()
  RETURN 0

/* FILE                                   800 ( 0320)                */
Unbundle_File:
  function_rc = Show_Flag_Fields()
  function_rc = Show_Data_Fields()
  RETURN 0

/* JOURNALMODEL                           900 ( 0384)                */
Unbundle_Journalmodel:
  function_rc = Show_Flag_Fields()
  function_rc = Show_Data_Fields()
  RETURN 0

/* MAPSET                                1000 ( 03E8)                */
Unbundle_Mapset:
  function_rc = Show_Flag_Fields()
  function_rc = Show_Data_Fields()
  RETURN 0

/* PARTITIONSET                          2000 ( 07D0)                */
Unbundle_Partitionset:
  function_rc = Show_Flag_Fields()
  function_rc = Show_Data_Fields()
  RETURN 0

/* PARTNER                               2500 ( 09C4)                */
Unbundle_Partner:
  function_rc = Show_Flag_Fields()
  function_rc = Show_Data_Fields()
  RETURN 0

/* PROFILE                               3000 ( 0BB8)                */
Unbundle_Profile:
  function_rc = Show_Flag_Fields()
  function_rc = Show_Data_Fields()
  RETURN 0

/* PROGRAM                               4000 ( 0FA0)                */
Unbundle_Program:
  function_rc = Show_Flag_Fields()
  function_rc = Show_Data_Fields()
  RETURN 0

/* SESSIONS                              4333 ( 10ED)                */
Unbundle_Sessions:
  function_rc = Show_Flag_Fields()
  function_rc = Show_Data_Fields()
  RETURN 0

/* TYPETERM                              4555 ( 11CB)                */
Unbundle_Typeterm:
  function_rc = Show_Flag_Fields()
  function_rc = Show_Data_Fields()
  RETURN 0

/* TERMINAL                              4666 ( 123A)                */
Unbundle_Terminal:
  function_rc = Show_Flag_Fields()
  function_rc = Show_Data_Fields()
  RETURN 0

/* TRANCLASS                             4888 ( 1318)                */
Unbundle_Tranclass:
  function_rc = Show_Flag_Fields()
  function_rc = Show_Data_Fields()
  RETURN 0

/* TRANSACTION                           5000 ( 1388)                */
Unbundle_Transaction:
  function_rc = Show_Flag_Fields()
  function_rc = Show_Data_Fields()

  the_txid = STRIP(data_data.01,"T"," ")
  record_group = STRIP(data_data.02,"T"," ")
  IF (txid_descr.the_txid = "") THEN DO
    txid_def.0 = Add_Txid_Def(the_txid data_data.06 COPIES(".",34))
    txid_def.0 = Add_Txid_Def(data_data.15)
  END

  IF ((data_data.15 = " ") & (txid_descr.the_txid <> "")) THEN DO
    IF (group_protected.record_group <> "Y") THEN DO
      say "1080:" record_group "-" the_txid":" data_data.15
      cics_cmd.0 = Add_Cics_Cmd("ALTER TRANSACTION("||,
        data_data.01")",
      "GROUP("||,
        record_group")")
      cics_cmd.0 = Add_Cics_Cmd("  DESCRIPTION("||,
        data_data.15")")
    END
    ELSE DO
      NOP
    END
  END
  ELSE DO
    NOP
  END

  IF (WORDPOS(record_group,startup_groups) = 0) THEN DO
    RETURN 0
  END

  DO yy = 1 TO LENGTH(txid_funct.the_txid)
    one_func = SUBSTR(txid_funct.the_txid,yy,1)
    IF (one_func = ".") THEN DO
      ITERATE yy
    END
    IF (POS(the_txid,role_txid.yy) = 0) THEN DO
      role_txid.yy = role_txid.yy the_txid
    END
  END
  RETURN 0

/* ENQMODEL                              5500 ( 157C)                */
Unbundle_Enqmodel:
  function_rc = Show_Flag_Fields()
  function_rc = Show_Data_Fields()
  RETURN 0

/* LIBRARY                               5600 ( 15E0)                */
Unbundle_Library:
  function_rc = Show_Flag_Fields()
  function_rc = Show_Data_Fields()
  RETURN 0

/* MQCONN                                5800 ( 16A8)                */
Unbundle_Mqconn:
  function_rc = Show_Flag_Fields()
  function_rc = Show_Data_Fields()
  RETURN 0

/* TDQUEUE                               6000 ( 1770)                */
Unbundle_Tdqueue:
  function_rc = Show_Flag_Fields()
  function_rc = Show_Data_Fields()
  RETURN 0

/* DB2CONN                               7000 ( 1B58)                */
Unbundle_Db2conn:
  function_rc = Show_Flag_Fields()
  function_rc = Show_Data_Fields()
  RETURN 0

/* DB2ENTRY                              7500 ( 1D4C)                */
Unbundle_Db2entry:
  function_rc = Show_Flag_Fields()
  function_rc = Show_Data_Fields()
  RETURN 0

/* DB2TRAN                               7900 ( 1EDC)                */
Unbundle_Db2tran:
  function_rc = Show_Flag_Fields()
  function_rc = Show_Data_Fields()
  RETURN 0

/* TSMODEL                               8000 ( 1F40)                */
Unbundle_Tsmodel:
  function_rc = Show_Flag_Fields()
  function_rc = Show_Data_Fields()
  RETURN 0

/* PROCESSTYPE                           8500 ( 2134)                */
Unbundle_Processtype:
  function_rc = Show_Flag_Fields()
  function_rc = Show_Data_Fields()
  RETURN 0

/* REQUESTMODEL                          9000 ( 2328)                */
Unbundle_Requestmodel:
  function_rc = Show_Flag_Fields()
  function_rc = Show_Data_Fields()
  RETURN 0

/* DOCTEMPLATE                           9100 ( 238C)                */
Unbundle_Doctemplate:
  function_rc = Show_Flag_Fields()
  function_rc = Show_Data_Fields()
  RETURN 0

/* TCPIPSERVICE                          9200 ( 23F0)                */
Unbundle_Tcpipservice:
  function_rc = Show_Flag_Fields()
  function_rc = Show_Data_Fields()
  RETURN 0

/* URIMAPS                               9300 ( 2454)                */
Unbundle_Urimaps:
  function_rc = Show_Flag_Fields()
  function_rc = Show_Data_Fields()
  RETURN 0

/* PIPELINES                             9400 ( 24B8)                */
Unbundle_Pipelines:
  function_rc = Show_Flag_Fields()
  function_rc = Show_Data_Fields()
  RETURN 0

/* WEBSERVICE                            9500 ( 251C)                */
Unbundle_Webservice:
  function_rc = Show_Flag_Fields()
  function_rc = Show_Data_Fields()
  RETURN 0

/* IPCONN                                9600 ( 2580)                */
Unbundle_Ipconn:
  function_rc = Show_Flag_Fields()
  function_rc = Show_Data_Fields()
  RETURN 0

/* JVMSERVERS                            9700 ( 25E4)                */
Unbundle_Jvmservers:
  function_rc = Show_Flag_Fields()
  function_rc = Show_Data_Fields()
  RETURN 0

/* BUNDLES                              30000 ( 7530)                */
Unbundle_Bundles:
  function_rc = Show_Flag_Fields()
  function_rc = Show_Data_Fields()
  RETURN 0

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 A new record type has shown up.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
I_Give_Up:
  SAY "Record("ix") I give up?"
  SAY dfhcsdsq_record.ix
  RETURN 0

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 Create stem. from dfhrmeta_record. STEM
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
Parse_Dfhrmeta:
  DO dfhrmeta_ix = 1 TO dfhrmeta_record.0
    IF (LEFT(dfhrmeta_record.dfhrmeta_ix,1) = "*") THEN DO
      ITERATE
    END
    PARSE VAR dfhrmeta_record.dfhrmeta_ix,
      nbr_objtype,
      hex_objtype,
      txt_rectype,
      hex_fldtype,
      txt_fldtype,
      txt_fldname
    txt_fldname = STRIP(txt_fldname,"B"," ")
    IF (debug_sw = 1) THEN DO
      SAY RIGHT("     "dfhrmeta_ix,5),
        "("nbr_objtype")",
        "("hex_objtype")",
        "("txt_rectype")",
        "("hex_fldtype")",
        "("txt_fldtype")",
        "("txt_fldname")"
    END
    SELECT
      WHEN (txt_rectype = 1) THEN DO
        function_rc = Parse_Meta_Object()
      END
      WHEN (txt_rectype = 2) THEN DO
        function_rc = Parse_Meta_Flag()
      END
      WHEN (txt_rectype = 3) THEN DO
        function_rc = Parse_meta_flag()
      END
      WHEN (txt_rectype = 4) THEN DO
        function_rc = Parse_Meta_Data()
      END
      OTHERWISE DO
        SAY "What is this txt_rectype("txt_rectype")?"
      END
    END
  END
  RETURN 0

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 New object type
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
Parse_Meta_Object:
  IF (hex_objtype <> last_object) THEN DO
    my_pos = POS(hex_objtype,meta_orb)
    IF (my_pos = 0) THEN DO
      meta_orb = meta_orb||hex_objtype" "
      meta_orb.hex_objtype = txt_fldname
      meta_orb.txt_fldname = hex_objtype
      mxct_orb = mxct_orb + 1
      stem_orb.mxct_orb = hex_objtype
      last_object = hex_objtype
      meta_flag.hex_objtype. = ""
      meta_data.hex_objtype. = ""
      flag_orb.hex_objtype = ""
      data_orb.hex_objtype = ""
    END
    ELSE DO
      SAY "Duplicate '1 00 R" hex_objtype"'."
      SAY "Previous VALUE("meta_orb.hex_objtype")"
      SAY "CURRENT  VALUE("txt_fldname"), keeping PREVIOUS value."
    END
  END
  ELSE DO
    SAY "Having two 'R' entries for the same objtype is an error"
    SAY "Search for '1 00 R" hex_objtype"' and fix one."
  END
  RETURN 0

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 FLAG field.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
Parse_Meta_Flag:
  my_pos = POS(hex_fldtype,flag_orb.hex_objtype)
  IF (my_pos = 0) THEN DO
    flag_orb.hex_objtype = flag_orb.hex_objtype||hex_fldtype" "
  END
  meta_flag.hex_objtype.hex_fldtype = txt_fldname
  meta_flag.hex_objtype.hex_fldtype. = ""
  meta_orb.hex_objtype.hex_fldtype = ""
  RETURN 0

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 VALUE of a flag.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
Parse_meta_flag:
  my_pos = POS(txx_fldtype,meta_orb.hex_objtype.hex_fldtype)
  IF (my_pos = 0) THEN DO
    meta_orb.hex_objtype.hex_fldtype = ,
      meta_orb.hex_objtype.hex_fldtype||txt_fldtype" "
  END
  meta_flag.hex_objtype.hex_fldtype.txt_fldtype = txt_fldname
  RETURN 0

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 DATA field.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
Parse_Meta_Data:
  my_pos = POS(hex_fldtype,data_orb.hex_objtype)
  IF (my_pos = 0) THEN DO
    data_orb.hex_objtype = data_orb.hex_objtype||hex_fldtype" "
  END
  meta_data.hex_objtype.hex_fldtype = txt_fldname
  meta_type.hex_objtype.hex_fldtype = txt_fldtype
  RETURN 0

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 Load descriptions into a stem.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
Load_Undescribed_Txid:
  txid_descr. = ""
  func_descr. = ""
  period = "."
  func_descr.period = "Not assigned - put in holding bucket"
  DO ix = 1 TO txiddesc_record.0
    SELECT
      WHEN (LEFT(txiddesc_record.ix,1) = "*") THEN DO
        ITERATE
      END
      WHEN (LEFT(txiddesc_record.ix,1) = "#") THEN DO
        PARSE VAR txiddesc_record.ix ,
          . ,
          =15 txiddesc_security_group +34 . ,
          =50 txiddesc_role +4 . ,
          =54 txiddesc_security_name
        one_func = " "
        DO ct = 1 TO LENGTH(txiddesc_security_group)
          one_func = SUBSTR(txiddesc_security_group,ct,1)
          IF ((one_func <> " ") & (one_func <> ".")) THEN DO
            txiddesc_security_name = ,
              Delstr_Apost(txiddesc_security_name)
            IF (func_descr.ct <> "") THEN DO
              SAY "Clobbering" ct":"func_descr.ct
            END
            role_descr.ct = STRIP(txiddesc_role,"B"," ")
            func_descr.ct = STRIP(txiddesc_security_name,"B"," ")
          END
        END
      END
      OTHERWISE DO
        PARSE VAR txiddesc_record.ix ,
          =1 txiddesc_txid +4 ,
          =6 txiddesc_prog +8 ,
          =15 txiddesc_security_group +27 .
        ix = ix + 1
        txiddesc_txid_name = txiddesc_record.ix
        IF (txid_descr.txiddesc_txid <> "") THEN DO
          SAY "Clobbering" txiddesc_txid":"txid_descr.txiddesc_txid
        END
        txid_descr.txiddesc_txid = ,
          STRIP(txiddesc_txid_name,"B"," ")
        txid_funct.txiddesc_txid = txiddesc_security_group
      END
    END
  END
  RETURN 0

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 Get rid of apostrophes for RACF installation data field
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
Delstr_Apost: PROCEDURE
  PARSE ARG any_string
  any_apost = POS("'",any_string)
  DO WHILE (any_apost > 0)
    any_string = DELSTR(any_string,"'",any_apost,1)
    any_apost = POS("'",any_string)
  END
  RETURN any_string

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 Append a record to the racf_cmd. stem.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
Add_Racf_Cmd: PROCEDURE EXPOSE racf_cmd.
  PARSE ARG rptargs
  rpt_ix = racf_cmd.0 + 1
  racf_cmd.rpt_ix = rptargs
  RETURN rpt_ix

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 Append a record to the cics_cmd. stem.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
Add_Cics_Cmd: PROCEDURE EXPOSE cics_cmd.
  PARSE ARG rptargs
  rpt_ix = cics_cmd.0 + 1
  cics_cmd.rpt_ix = rptargs
  RETURN rpt_ix

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 Append a record to the txid_def. stem.
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
Add_Txid_Def: PROCEDURE EXPOSE txid_def.
  PARSE ARG rptargs
  rpt_ix = txid_def.0 + 1
  txid_def.rpt_ix = rptargs
  RETURN rpt_ix

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 Loop thru the stem variable putting the higher VALUE next.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Sort_Stem_Asc: PROCEDURE EXPOSE stem.
  count_of_elements = stem.0
  DO i = 1 TO  (count_of_elements - 1)
    DO j = 1 TO (count_of_elements - 1)
      j_plus1 = j + 1
      IF (stem.j > stem.j_plus1) THEN DO
        temp = stem.j
        stem.j = stem.j_plus1
        stem.j_plus1 = temp
      END
    END j
  END i
  RETURN 0

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
End of code.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */

/*
Category 1
https://www.ibm.com/support/knowledgecenter/SSGMCP_5.4.0/security/cics/ +
dfht56s.html#dfht56s
RDEFINE GCICSTRN cicscat1 UACC(NONE)
         ADDMEM(cskp cspq cdbd . . . . . . . . cxre csne)
         NOTIFY(security_admin_userid)
         OWNER(groupid)
PERMIT CICSCAT1 CLASS(GCICSTRN) ID(cicscat1) ACCESS(READ)
CONNECT (userid) GROUP(cicscat1)

Category 2
DFH540.CICS.SDFHSAMP(DFH$CAT2)
RDEFINE &classname SYSADM UACC(NONE) +
         ADDMEM(CDBC,CEMT,CETR,CEDA,CIND,CESD,CCRL,CEMN) +
         NOTIFY(&notify) +
         OWNER(&owner)
PERMIT   SYSADM  CLASS(&classname) ID(&SYSADM_ACCESS_LIST)

Category 3
https://www.ibm.com/support/knowledgecenter/SSGMCP_5.4.0/security/cics/ +
dfht53x.html#dfht53x
For category 3 transactions you are recommended to specify
RESSEC(NO) and CMDSEC(NO) on the CICS transaction resource
definition. These transactions should be defined to RACF;
although this definition does not affect task attach-time
processing, it is required to support the QUERY SECURITY
command.

*/
