/* rexx */
Rexx_CSRDSN:
  rexxpgm_version = "01.06"           /* ver lev */

  ADDRESS ISREDIT "MACRO (method) PROCESS"
  NUMERIC DIGITS 10   /* Handles Gigabyte */
  ADDRESS ISPEXEC "CONTROL ERRORS RETURN"

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 This code drives Initialization, Process, and Termination routines.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Main_Routine:
  return_code = Initialization_Routine()
  IF (return_code = 0) THEN DO
    return_code = Process_Routine()
  END
  return_code = Termination_Routine()
  ADDRESS ISREDIT "MEND"
  RETURN return_code

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================

 Dataset:  DEMO.REXX(CSRDSN)
 Author:   Kenneth Tomiak
 Contact:  "Kenneth Tomiak"<CBT_Ken@KTomiak.BIZ>
 Syntax:   %csrdsn |help|
           %csrdsn (with cursor on a data set or file name)
           %csrdsn |BROWSE|DCB|EDIT|INFO|LISTCAT|VIEW|
 Purpose:  Pop up EDIT, VIEW, or BROWSE on a data set name.
 Abstract: Validate method (default to VIEW), validate cursor in data
           area (currcol > 0), retrieve data set name,
           substitute &SYSUID., invoke method.

-----------------------------------------------------------------------

 History of Modifications
 ------------------------
vv.mm WHEN     Who / What you did ... (Newest change at the top.)
----- -------- --------------------------------------------------------
01.06 20180505 KTOMIAK "Kenneth Tomiak"<CBT_Ken@KTomiak.BIZ>
               1) Fixed &SYSUID. replacement.
----- -------- --------------------------------------------------------
01.05 20180505 KTOMIAK "Kenneth Tomiak"<CBT_Ken@KTomiak.BIZ>
               1) Stylize using Edit Macro @putktm:
                  Programming Using The Kenneth Tomiak Method.
----- -------- --------------------------------------------------------
01.04 20180426 KTOMIAK "Kenneth Tomiak"<CBT_Ken@KTomiak.BIZ>
               1) Stylize using template $putktm:
                  Programming Using The Kenneth Tomiak Method.
----- -------- --------------------------------------------------------
01.03 20180425 KTOMIAK "Kenneth Tomiak"<CBT_Ken@KTomiak.BIZ>
               1) Stylize using Edit Macro %putktm:
                  Programming Using The Kenneth Tomiak Method.
               2) Added BPXMTEXT when RETVAL = -1.
----- -------- --------------------------------------------------------
01.02 20180422 KTOMIAK "Kenneth Tomiak"<CBT_Ken@KTomiak.BIZ>
               1) Add z/OS UNIX System Services directory and file.
                  At least one forward slash (/) is required.
----- -------- --------------------------------------------------------
01.01 20180421 KTOMIAK "Kenneth Tomiak"<CBT_Ken@KTomiak.BIZ>
               1) Add ISPEXEC DSINFO as it has APF and LNK flags.
               2) Convert LISTDSI SAY to temporary VIEW data set.
----- -------- --------------------------------------------------------
01.00 20180408 KTOMIAK "Kenneth Tomiak"<CBT_Ken@KTomiak.BIZ>
      20180420
               1) Major rewrite to be more intelligent.
                  a) Handle cursor errors in non data areas.
                  b) Keep the displayed lines on the screen when done.
                  c) Handle VSAM - requires IBM File Manager.
                  d) Show existing BASE in proper LIFO/FIFO order.
                  e) Use ZSCREENI for MSGLINE.
                  f) Invoke EDREC DEFER since it could HALT EDIT.
                  g) Handle data set names as in-stream data.
                  h) Method HELP shows what can be done.
                  i) SYSDSORG=VS methods DSCB, INFO, and LISTCAT all
                     DO a VIEW on LISTCAT output.
                  j) Data set name can also be bounded by apostrophes.
                  k) ZSCREENI width = colright - colleft + 1!
----- -------- --------------------------------------------------------

-----------------------------------------------------------------------

STANDARD GLOBAL DISCLAIMER
--------------------------
The author explicitly disavows any claim whatsoever about the
correctness or functionality of this program, and disclaims liability
for anything and everything bad that might happen in connection with,
before, during, or after using it. I have tried to make it work right,
and I am personally pretty confident that it does, but everybody makes
mistakes, so if you use it, you do so at your own risk.

=======================================================================

=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 This routine initializes constants and variables.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Initialization_Routine:
  return_code = 0
  done = 0
  DO WHILE (done = 0)
    ADDRESS ISPEXEC "EDREC QUERY"
    IF (RC = 4) THEN DO
      ADDRESS ISPEXEC "EDREC DEFER"
    END
    ELSE DO
      done = 1
    END
  END

  method = To_Uppercase(method)
  hex_A1 = 'A1'X
  IF (ABBREV("HELP",method,1) > 0) THEN DO
    ZERRHM = "*"
    ZERRALRM = "YES"
    ZERRSM = "Usage help"
    ZERRLM = COPIES(hex_A1,32) "USAGE HELP" COPIES(hex_A1,32)
    ZERRLM = ZERRLM LEFT("Type csrdsn on the command line.",76)
    ZERRLM = ZERRLM LEFT("Optionally type a method:",76)
    ZERRLM = ZERRLM COPIES(hex_A1,2) ,
      LEFT("BROWSE/EDIT/VIEW  - VIEW is the default",76)
    ZERRLM = ZERRLM COPIES(hex_A1,2) LEFT("DSCB/INFO/LISTCAT",76)
    ZERRLM = ZERRLM LEFT("Place the cursor on a data set name.",76)
    ZERRLM = ZERRLM LEFT("Press ENTER.",76)
    ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
    return_code = 1
    RETURN return_code
  END

  ADDRESS ISREDIT "(currline,currcol) = CURSOR"
  myrc = RC
  IF (myrc > 0) THEN DO
    ZERRHM = "*"
    ZERRALRM = "YES"
    ZERRSM = "ISREDIT error"
    ZERRLM = "Retrieving the CURSOR location failed, RC("myrc")."
    ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
    return_code = myrc
    RETURN return_code
  END
  currline = currline + 0
  currcol = currcol + 0
  ADDRESS ISREDIT "(lrecl) = LRECL"
  ADDRESS ISREDIT "(linetop,linebttm) = DISPLAY_LINES"
  ADDRESS ISREDIT "(colleft,colright) = DISPLAY_COLS"
  img_width = colright - colleft + 1
  ADDRESS ISREDIT "(datawid) = DATA_WIDTH"
  ADDRESS ISPEXEC "VGET (ZSCREEND, ZSCREENW)"

  myrc = RC
  IF (myrc > 0) THEN DO
    ZERRHM = "*"
    ZERRALRM = "YES"
    ZERRSM = "ISREDIT error"
    ZERRLM = "Retrieving the LRECL LENGTH failed, RC("myrc")."
    ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
    return_code = myrc
    RETURN return_code
  END
  lrecl = lrecl + 0
  IF ((currcol = 0) | (currcol > lrecl)) THEN DO
    ADDRESS ISPEXEC "VGET (ZSCREENC, ZSCREENI)"
    imgline = ZSCREENC / (img_width + 8)
    IF (imgline < 4) THEN DO
      ZERRHM = "*"
      ZERRALRM = "YES"
      ZERRSM = "Headers"
      ZERRLM = "Header lines are not usable."
      ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
      return_code = 12
      RETURN return_code
    END
    PARSE VAR imgline imgline "." realnbr
    imgcol = ZSCREENC - (imgline * (img_width + 8)) + 1
    IF (imgcol < 9) THEN DO
      ZERRHM = "*"
      ZERRALRM = "YES"
      ZERRSM = "Line numbers"
      ZERRLM = "Line numbers are not usable."
      ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
      return_code = 12
      RETURN return_code
    END
    img_start = imgline * (img_width + 8) + 1
    img_end = img_width + 8
    img_data = SUBSTR(ZSCREENI,img_start,img_end)
    start_dsn = imgcol
    DO dsn_ix = imgcol TO 1 BY -1
      one_char = SUBSTR(img_data,dsn_ix,1)
      IF ((one_char = "=") | ,
          (one_char = "'") | ,
          (one_char = " ")) THEN DO
        start_dsn = dsn_ix + 1
        LEAVE
      END
    END
    end_dsn = imgcol
    img_stop = LENGTH(img_data)
    DO dsn_ix = imgcol TO img_stop
      one_char = SUBSTR(img_data,dsn_ix,1)
      IF ((one_char = ",") | ,
          (one_char = "'") | ,
          (one_char = " ")) THEN DO
        end_dsn = dsn_ix - 1
        LEAVE
      END
    END
    dsn_len = end_dsn - start_dsn + 1
    full_dsn = SUBSTR(img_data,start_dsn,dsn_len)
    IF (LEFT(full_dsn,1) = "(") THEN DO
      full_dsn = STRIP(full_dsn,"L","(")
      full_dsn = STRIP(full_dsn,"T",")")
    END
  END
  ELSE DO
    ADDRESS ISREDIT "(linedata) = LINE" currline
    myrc = RC
    IF (myrc > 0) THEN DO
      ZERRHM = "*"
      ZERRALRM = "YES"
      ZERRSM = "ISREDIT error"
      ZERRLM = "Retrieving LINE" currline "failed, RC("myrc")."
      ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
      return_code = 12
      RETURN return_code
    END
    start_dsn = currcol
    DO dsn_ix = currcol TO 1 BY -1
      one_char = SUBSTR(linedata,dsn_ix,1)
      IF ((one_char = "=") | ,
          (one_char = "'") | ,
          (one_char = " ")) THEN DO
        start_dsn = dsn_ix + 1
        LEAVE
      END
      start_dsn = dsn_ix
    END
    end_dsn = currcol
    DO dsn_ix = currcol TO datawid
      one_char = SUBSTR(linedata,dsn_ix,1)
      IF ((one_char = ",") | ,
          (one_char = "'") | ,
          (one_char = " ")) THEN DO
        end_dsn = dsn_ix - 1
        LEAVE
      END
      end_dsn = dsn_ix
    END
    dsn_len = end_dsn - start_dsn + 1
    full_dsn = SUBSTR(linedata,start_dsn,dsn_len)
    IF (LEFT(full_dsn,1) = "(") THEN DO
      full_dsn = STRIP(full_dsn,"L","(")
      full_dsn = STRIP(full_dsn,"T",")")
    END
  END

  RETURN return_code

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 This routine does the processing.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Process_Routine:
  IF (POS("&&",full_dsn) > 0) THEN DO
    ZERRHM = "*"
    ZERRALRM = "YES"
    ZERRSM = "Temporary DSN"
    ZERRLM = "Temporary data set names are not usable."
    ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
    return_code = 12
    RETURN return_code
  END
  IF (POS("/",full_dsn) > 0) THEN DO
    return_code = Zos_Unix_Name()
    RETURN return_code
  END

  missing_symbol = ""

  DO WHILE (POS("&",full_dsn) > 0)
    full_dsn = Seek_Next_Symbolic(POS("&",full_dsn))
  END
  IF (POS(full_dsn,"?") > 0) THEN DO
    ZERRHM = "*"
    ZERRALRM = "YES"
    ZERRSM = "Missing symbol"
    ZERRLM = "One or more symbols could not be substituted." full_dsn
    ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
    return_code = 12
    RETURN return_code
  END

  good_chars = "QWERTYUIOPASDFGHJKLZXCVBNM@#$1234567890"
  PARSE VAR full_dsn temp_dsn "(" temp_mbr ")"
  IF (LENGTH(temp_dsn) > 44) THEN DO
    ZERRHM = "*"
    ZERRALRM = "YES"
    ZERRSM = "Bad DSNAME"
    ZERRLM = "A DSNAME cannot be more than 44 characters."
    ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
    return_code = 12
    RETURN return_code
  END
  good_dsn = 1
  apost_tmp = "'"temp_dsn"'"
  DO WHILE (temp_dsn <> "")
    PARSE VAR temp_dsn temp_lvl "." temp_dsn
    IF (POS(LEFT(temp_lvl,1),LEFT(good_chars,29)) = 0) THEN DO
      good_dsn = 0
      LEAVE
    END
    DO tix = 2 TO LENGTH(temp_lvl)
      one_char = SUBSTR(temp_lvl,tix,1)
      IF (POS(one_char,LEFT(good_chars,39)) = 0) THEN DO
        good_dsn = 0
        LEAVE
      END
    END
  END
  IF (good_dsn = 0) THEN DO
    ZERRHM = "*"
    ZERRALRM = "YES"
    ZERRSM = "Bad DSNAME"
    ZERRLM = "Was your cursor on a data set name or some other" ,
      "riff-raff? I parsed out:" full_dsn "and found invalid" ,
      "characters for a data set name."
    ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
    return_code = 12
    RETURN return_code
  END
  PARSE VAR full_dsn temp_dsn "(" temp_mbr ")"

  gdg_gds = ""
  IF (temp_mbr <> "") THEN DO
    left_one = LEFT(temp_mbr,1)
    SELECT
      WHEN ((left_one = 0) | ,
            (temp_mbr == "-0") | ,
            (temp_mbr == "+0")) THEN DO
        gdg_gds = 0
        listcat.0 = 1
        listcat.1 = "  LISTCAT ENTRY("apost_tmp") GDG ALL"
        listcat_rc = Linkmvs_Idcams()
        "FREE FILE(SYSPRINT)"
        IF (listcat_rc > 0) THEN DO
          RETURN listcat_rc
        END
        last = nonvsam.0
        apost_tmp = "'"nonvsam.last"'"
        temp_dsn = nonvsam.last
        temp_mbr = ""
      END
      WHEN (left_one = "+") THEN DO
        ZERRHM = "*"
        ZERRALRM = "YES"
        ZERRSM = "GDS+"
        ZERRLM = "A future GDS is not supported within" ,
          "this edit macro."
        ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
        return_code = 12
        RETURN return_code
      END
      WHEN (left_one = "-") THEN DO
        gdg_gds = "GDS"
        gdg_gds = LEFT(temp_mbr,2)
        listcat.0 = 1
        listcat.1 = "  LISTCAT ENTRY("apost_tmp") GDG ALL"
        listcat_rc = Linkmvs_Idcams()
        "FREE FILE(SYSPRINT)"
        IF (listcat_rc > 0) THEN DO
          RETURN listcat_rc
        END
        sign_mbr = temp_mbr * -1
        IF (sign_mbr > gdg_limit) THEN DO
          ZERRHM = "*"
          ZERRALRM = "YES"
          ZERRSM = sign_mbr "> GDG limit"
          ZERRLM = sign_mbr "is higher than the GDG limit" gdg_limit"."
          ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
          return_code = 12
          RETURN return_code
        END
        IF (sign_mbr > nonvsam.0) THEN DO
          ZERRHM = "*"
          ZERRALRM = "YES"
          ZERRSM = sign_mbr "> GDS count"
          ZERRLM = sign_mbr "is higher than the GDS count" nonvsam.0"."
          ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
          return_code = 12
          RETURN return_code
        END
        last = nonvsam.0 + temp_mbr
        apost_tmp = "'"nonvsam.last"'"
        temp_dsn = nonvsam.last
        temp_mbr = ""
      END
      OTHERWISE DO
        IF (LENGTH(temp_mbr) > 8) THEN DO
          ZERRHM = "*"
          ZERRALRM = "YES"
          ZERRSM = "Bad member"
          ZERRLM = "A member cannot be more than 8 characters."
          ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
          return_code = 12
          RETURN return_code
        END
        good_mbr = 1
        IF (POS(LEFT(temp_mbr,1),LEFT(good_chars,29)) = 0) THEN DO
          good_mbr = 0
        END
        DO tix = 2 TO LENGTH(temp_mbr)
          one_char = SUBSTR(temp_mbr,tix,1)
          IF (POS(one_char,LEFT(good_chars,39)) = 0) THEN DO
            good_mbr = 0
          END
        END
        IF (good_mbr = 0) THEN DO
          ZERRHM = "*"
          ZERRALRM = "YES"
          ZERRSM = "Bad member name"
          ZERRLM = "Was your cursor on a data set name or some other" ,
            "riff-raff? I parsed out:" temp_mbr "and found invalid" ,
            "characters for a member name."
          ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
          return_code = 12
          RETURN return_code
        END
      END
    END
  END

  apost_tmp = "'"temp_dsn"'"
  IF (temp_mbr = "") THEN DO
    apost_dsn = "'"temp_dsn"'"
  END
  ELSE DO
    apost_dsn = "'"temp_dsn"("temp_mbr")'"
  END

  reset_rc = Reset_Sys()
  listdsi_rc = LISTDSI(apost_tmp "DIRECTORY SMSINFO")
  SELECT
    WHEN (listdsi_rc = 0) THEN DO
      NOP
    END
    WHEN ((listdsi_rc = 16) & (SYSREASON = 5)) THEN DO
      listcat.0 = 1
      listcat.1 = "  LISTCAT ENTRY("apost_tmp") GDG ALL"
      listcat_rc = Linkmvs_Idcams()
      "FREE FILE(SYSPRINT)"
      IF (listcat_rc = 0) THEN DO
        ZERRHM = "*"
        ZERRALRM = "YES"
        ZERRSM = "GDG Base"
        ZERRLM = ,
          LEFT("You must choose one and only one of the" ,
          "GDS entries",76)
        ZERRLM = ZERRLM || LEFT("DSN: "apost_tmp lifofifo".",76," ")
        IF (lifofifo = "FIFO") THEN DO
          DO nx = nonvsam.0 TO 1 BY -1
            ZERRLM = ZERRLM || LEFT("GDS-"nx": "nonvsam.nx".",76," ")
            llqr = REVERSE(nonvsam.nx)
            PARSE VAR llqr llq "." .
            llq = REVERSE(llq)
            msgtext = "//*"llq ,
              "DD DISP=OLD,DSN="nonvsam.nx "    FIFO"
            ADDRESS ISREDIT ,
              "LINE_AFTER" currline "= MSGLINE (msgtext)"
            isredit_rc = RC
            IF (isredit_rc <> 0) THEN DO
              ZERRHM = "*"
              ZERRALRM = "YES"
              ZERRSM = "Insert error, RC("isredit_rc")"
              ZERRLM = "Really, text has a problem, MSGLINE:" msgtext
              ADDRESS ISPEXEC "setmsg MSG(ISRZ002)"
              return_code = 1
            END
          END
        END
        ELSE DO
          gx = 0
          DO nx = 1 TO nonvsam.0
            gx = gx + 1
            ZERRLM = ZERRLM || LEFT("GDS-"gx": "nonvsam.nx".",76," ")
            llqr = REVERSE(nonvsam.nx)
            PARSE VAR llqr llq "." .
            llq = REVERSE(llq)
            msgtext = "//*"llq ,
              "DD DISP=OLD,DSN="nonvsam.nx "    LIFO"
            ADDRESS ISREDIT ,
              "LINE_AFTER" currline "= MSGLINE (msgtext)"
            isredit_rc = RC
            IF (isredit_rc <> 0) THEN DO
              ZERRHM = "*"
              ZERRALRM = "YES"
              ZERRSM = "Insert error, RC("isredit_rc")"
              ZERRLM = "Really, text has a problem, MSGLINE:" msgtext
              ADDRESS ISPEXEC "setmsg MSG(ISRZ002)"
              return_code = 1
            END
          END
        END
        ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
        return_code = 12
        RETURN return_code
      END
      ZERRHM = "*"
      ZERRALRM = "YES"
      ZERRSM = "LISTDSI error"
      ZERRLM = ,
        LEFT("LISTDSI reports back with RC("listdsi_rc"). ",76," ")
      ZERRLM = ZERRLM || LEFT("REASON("SYSREASON")",76," ")
      ZERRLM = ZERRLM || LEFT("DSN: "apost_dsn".",76," ")
      temp_msg2 = SYSMSGLVL2
      short_msg = ""
      DO WHILE (temp_msg2 <> "")
        PARSE VAR temp_msg2 one_word " " temp_msg2
        IF (LENGTH(short_msg one_word) > 75) THEN DO
          ZERRLM = ZERRLM || short_msg || " "
          short_msg = one_word || hex_A1
        END
        ELSE DO
          short_msg = short_msg || one_word || hex_A1
        END
      END
      IF (short_msg <> "") THEN DO
        ZERRLM = ZERRLM || short_msg
      END
      ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
      return_code = 12
      RETURN return_code
    END
    WHEN (listdsi_rc > 4) THEN DO
      ZERRHM = "*"
      ZERRALRM = "YES"
      ZERRSM = "LISTDSI error"
      ZERRLM = ,
        LEFT("LISTDSI reports back with RC("listdsi_rc"). ",76," ")
      ZERRLM = ZERRLM || LEFT("REASON("SYSREASON")",76," ")
      ZERRLM = ZERRLM || LEFT("DSN: "apost_tmp".",76," ")
      temp_msg2 = SYSMSGLVL2
      short_msg = ""
      DO WHILE (temp_msg2 <> "")
        PARSE VAR temp_msg2 one_word " " temp_msg2
        IF (LENGTH(short_msg one_word) > 75) THEN DO
          ZERRLM = ZERRLM || short_msg || " "
          short_msg = one_word || hex_A1
        END
        ELSE DO
          short_msg = short_msg || one_word || hex_A1
        END
      END
      IF (short_msg <> "") THEN DO
        ZERRLM = ZERRLM || short_msg
      END
      ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
      return_code = 12
      RETURN return_code
    END
    WHEN ((listdsi_rc = 4) & (SYSREASON = 12)) THEN DO
      NOP /* sysdsorg=VS is handled below. */
    END
    WHEN ((listdsi_rc = 4) & (SYSREASON = 30)) THEN DO
      NOP /* SMSINFO requested, but not SMS managed. */
    END
    OTHERWISE DO
      ZERRHM = "*"
      ZERRALRM = "YES"
      ZERRSM = "NOT CATLG"
      ZERRLM = "LISTDSI" apost_tmp ,
        "RC("listdsi_rc") REASON("SYSREASON")."
      temp_msg2 = SYSMSGLVL2
      short_msg = ""
      DO WHILE (temp_msg2 <> "")
        PARSE VAR temp_msg2 one_word " " temp_msg2
        IF (LENGTH(short_msg one_word) > 75) THEN DO
          ZERRLM = ZERRLM || short_msg || " "
          short_msg = one_word || hex_A1
        END
        ELSE DO
          short_msg = short_msg || one_word || hex_A1
        END
      END
      IF (short_msg <> "") THEN DO
        ZERRLM = ZERRLM || short_msg
      END
      ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
      return_code = 12
      RETURN return_code
    END
  END

  select_rc = 0
  SELECT
    WHEN (SYSDSORG = "VS") THEN DO
      SELECT
        WHEN (ABBREV("BROWSE",method,1) > 0) THEN DO
          ADDRESS ISPEXEC "SELECT PGM(FILEMGR)" ,
            "PARM(DSB" apost_tmp") NEWAPPL(FMN)"
          select_rc = RC
        END
        WHEN (ABBREV("EDIT",method,1) > 0) THEN DO
          ADDRESS ISPEXEC "SELECT PGM(FILEMGR)" ,
            "PARM(DSE" apost_tmp") NEWAPPL(FMN)"
          select_rc = RC
        END
        WHEN ((ABBREV("DSCB",method,1) > 0) | ,
              (ABBREV("INFO",method,1) > 0) | ,
              (ABBREV("LISTCAT",method,1) > 0)) THEN DO
          listcat.0 = 1
          listcat.1 = "  LISTCAT ENTRY("apost_tmp") ALL"
          listcat_rc = Linkmvs_Idcams()
          ADDRESS ISPEXEC ,
            "LMINIT DATAID(fileid) DDNAME(SYSPRINT) ENQ(SHR)"
          lminit_rc = RC
          ADDRESS ISPEXEC ,
            "VIEW DATAID("fileid")"
          ADDRESS ISPEXEC ,
            "LMCLOSE DATAID("fileid")"
          lmclose_rc = RC
          "FREE FILE(SYSPRINT)"
        END
        OTHERWISE DO
          ADDRESS ISPEXEC "SELECT PGM(FILEMGR)" ,
            "PARM(DSV" apost_dsn") NEWAPPL(FMN)"
          select_rc = RC
        END
      END
      IF (select_rc = 20) THEN DO
        ZERRHM = "*"
        ZERRALRM = "YES"
        ZERRSM = "No IBM FILEMGR"
        ZERRLM = "If you are licensed for IBM FILEMGR, then" ,
          "your logon PROCEDURE does not have it pre-allocated."
        ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
        return_code = 12
        RETURN return_code
      END
    END
    WHEN (ABBREV("BROWSE",method,1) > 0) THEN DO
      ADDRESS ISPEXEC "BROWSE DATASET("apost_tmp")"
      browse_rc = RC
    END
    WHEN (ABBREV("DSCB",method,1) > 0) THEN DO
      IF (SYSMGMTCLASS <> "") THEN DO
        infotext = "//*           MGMTCLASS="SYSMGMTCLASS
        ADDRESS ISREDIT ,
          "LINE_AFTER" currline "= INFOLINE (infotext)"
        isredit_rc = RC
      END
      IF (SYSDATACLASS <> "") THEN DO
        infotext = "//*           DATACLASS="SYSDATACLASS
        ADDRESS ISREDIT ,
          "LINE_AFTER" currline "= INFOLINE (infotext)"
        isredit_rc = RC
      END
      IF (SYSSTORCLASS <> "") THEN DO
        infotext = "//*           STORCLASS="SYSSTORCLASS
        ADDRESS ISREDIT ,
          "LINE_AFTER" currline "= INFOLINE (infotext)"
        isredit_rc = RC
      END
      infotext = "//*           BLKS/TRK="SYSBLKSTRK
      ADDRESS ISREDIT ,
        "LINE_AFTER" currline "= INFOLINE (infotext)"
      isredit_rc = RC
      infotext = "//*          " ,
        "DCB=(DSORG="SYSDSORG",RECFM="SYSRECFM","||,
        "BLKSIZE="SYSBLKSIZE",LRECL="SYSLRECL")"
      ADDRESS ISREDIT ,
        "LINE_AFTER" currline "= INFOLINE (infotext)"
      isredit_rc = RC
      infotext = "//*          " ,
        " USED=("SYSUNITS",("SYSALLOC",,"SYSUDIRBLK"))"
      ADDRESS ISREDIT ,
        "LINE_AFTER" currline "= INFOLINE (infotext)"
      isredit_rc = RC
      infotext = "//*          " ,
        "SPACE=("SYSUNITS",("SYSPRIMARY","SYSSECONDS","SYSADIRBLK"))"
      ADDRESS ISREDIT ,
        "LINE_AFTER" currline "= INFOLINE (infotext)"
      isredit_rc = RC
      infotext = "//*           UNIT="SYSUNIT",VOL=SER="SYSVOLUME
      ADDRESS ISREDIT ,
        "LINE_AFTER" currline "= INFOLINE (infotext)"
      isredit_rc = RC
    END
    WHEN (ABBREV("EDIT",method,1) > 0) THEN DO
      ADDRESS ISPEXEC "EDIT DATASET("apost_dsn")"
    END
    WHEN (ABBREV("INFO",method,1) > 0) THEN DO
      function_rc = Data_Set_Info()
    END
    WHEN (ABBREV("LISTCAT",method,1) > 0) THEN DO
      listcat.0 = 1
      listcat.1 = "  LISTCAT ENTRY("apost_tmp") ALL"
      listcat_rc = Linkmvs_Idcams()
      ADDRESS ISPEXEC ,
        "LMINIT DATAID(fileid) DDNAME(SYSPRINT) ENQ(SHR)"
      lminit_rc = RC
      ADDRESS ISPEXEC ,
        "VIEW DATAID("fileid")"
      ADDRESS ISPEXEC ,
        "LMCLOSE DATAID("fileid")"
      lmclose_rc = RC
      "FREE FILE(SYSPRINT)"
    END
    OTHERWISE DO
      ADDRESS ISPEXEC "VIEW DATASET("apost_dsn")"
    END
  END
  RETURN return_code

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 This routine does cleanup before exiting.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Termination_Routine:
  ADDRESS ISREDIT "LOCATE" linetop
  RETURN return_code

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 Retrieve &symbolic. and see if it was SET in the JCL.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Seek_Next_Symbolic:
  IF (POS("&SYSUID.",full_dsn) > 0) THEN DO
    sys_sysuid = SYSVAR("SYSUID")
    new_dsn = Replace_String("&SYSUID.",sys_sysuid)
    RETURN new_dsn
  END
  symbol_start = POS("&",full_dsn)
  DO symbol_end = (symbol_start + 1) TO (symbol_start + 9)
    SELECT
      WHEN (SUBSTR(full_dsn,symbol_end,1) = ".") THEN DO
        LEAVE
      END
      WHEN (POS(SUBSTR(full_dsn,symbol_end,1)," ,()&") > 0 ) THEN DO
        symbol_end = symbol_end - 1
        LEAVE
      END
      OTHERWISE DO
      END
    END
  END
  symbolic_len = symbol_end - symbol_start + 1
  symbolic_name = SUBSTR(full_dsn,symbol_start,symbolic_len)
  symbol_len = symbol_end - symbol_start
  symbol_name = SUBSTR(full_dsn,symbol_start+1,symbol_len)
  symbol_name = STRIP(symbol_name,"T",".")
  symbol_len = LENGTH(symbol_name)
  ADDRESS ISREDIT "SEEK '"symbol_name"=' PREV"
  seek_rc = RC
  IF (seek_rc > 0) THEN DO
    new_dsn = Replace_String("&","?")
    missing_symbol = missing_symbol||symbolic_name" "
    RETURN new_dsn
  END
  ADDRESS ISREDIT "(seekline,seekcol) = CURSOR"
  seekline = seekline + 0
  seekcol = seekcol + 0
  ADDRESS ISREDIT "CURSOR =" currline currcol
  ADDRESS ISREDIT "(seekdata) = LINE" seekline
  seek_start = seekcol + symbol_len + 1
  IF (POS("'",SUBSTR(seekdata,seek_start,1)) > 0) THEN DO
    seek_start = seek_start + 1
  END
  DO seek_end = seek_start TO datawid
    SELECT
      WHEN (SUBSTR(seekdata,seek_end,1) = "&") THEN DO
        seek_end = seek_end - 1
        LEAVE
      END
      WHEN (POS(SUBSTR(seekdata,seek_end,1)," ,'") > 0 ) THEN DO
        seek_end = seek_end - 1
        LEAVE
      END
      OTHERWISE DO
      END
    END
  END
  seek_len = seek_end - seek_start + 1
  IF (seek_len > 0) THEN DO
    seek_text = SUBSTR(seekdata,seek_start,seek_len)
    new_dsn = Replace_String(symbolic_name,seek_text)
  END
  ELSE DO
    new_dsn = Delete_Symbolic(symbolic_name)
  END
  RETURN new_dsn

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 This routine swaps one string for another.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Replace_String: PROCEDURE EXPOSE full_dsn
  from_string = ARG(1)
  to_string = ARG(2)
  from_len = LENGTH(from_string)
  from_loc = POS(from_string,full_dsn)
  SELECT
    WHEN (from_loc = 1) THEN DO
      end_dsn = SUBSTR(full_dsn,(from_loc + from_len))
      new_dsn = to_string||end_dsn
    END
    OTHERWISE DO
      from_loc = from_loc - 1
      PARSE VAR full_dsn begin_dsn +(from_loc) . +(from_len) end_dsn
      new_dsn = begin_dsn||to_string||end_dsn
    END
  END
  RETURN new_dsn

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 This routine removes a symbolic whose VALUE is null.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Delete_Symbolic: PROCEDURE EXPOSE full_dsn
  del_string = ARG(1)
  del_len = LENGTH(del_string)
  del_pos = POS(del_string,full_dsn)
  new_dsn = DELSTR(full_dsn,del_pos,del_len)
  RETURN new_dsn

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 This routine executes IDCAMS to check LIFO/FIFO stats and get GDS.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Linkmvs_Idcams:
  "ALLOC FILE(SYSIN) NEW DELETE REUSE" ,
    "UNIT(SYSDA) TRACKS SPACE(1,0)" ,
    "DSORG(PS) RECFM(F B) BLKSIZE(0) LRECL(80)"
  "ALLOC FILE(SYSPRINT) NEW DELETE REUSE" ,
    "UNIT(SYSDA) TRACKS SPACE(2,2)" ,
    "DSORG(PS) RECFM(V B A) BLKSIZE(0) LRECL(125)"
  ADDRESS MVS "EXECIO * DISKW SYSIN (STEM listcat. FINIS)"
  execio_rc = RC
  IF (execio_rc <> 0) THEN DO
    ZERRHM = "*"
    ZERRALRM = "YES"
    ZERRSM = "EXECIO failure"
    ZERRLM = "EXECIO DISKW error," execio_rc
    ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
    return_code = 12
    RETURN return_code
  END
  ADDRESS LINKMVS "IDCAMS"
  linkmvs_rc = RC
  "FREE FILE(SYSIN)"
  IF (linkmvs_rc = 0) THEN DO
    ADDRESS MVS "EXECIO * DISKR SYSPRINT (STEM listcat. FINIS)"
    lifofifo = ""
    nonvsam. = ""
    nonvsam.0 = 0
    gdg_limit = 0
    DO lx = 1 TO listcat.0
      IF (POS(" LIMIT---",listcat.lx) > 0) THEN DO
        PARSE VAR listcat.lx . "LIMIT------------------" gdg_limit ,
          " " .
      END
      IF (POS(" NONVSAM--",listcat.lx) > 0) THEN DO
        tmp_ctr = nonvsam.0 + 1
        PARSE VAR listcat.lx . "--" nonvsam_tmp " " .
        nonvsam.tmp_ctr = nonvsam_tmp
        nonvsam.0 = tmp_ctr
      END
      IF (POS(" LIFO",listcat.lx) > 0) THEN DO
        lifofifo = "LIFO"
      END
      IF (POS(" FIFO",listcat.lx) > 0) THEN DO
        lifofifo = "FIFO"
      END
    END
  END
  ELSE DO
    ZERRHM = "*"
    ZERRALRM = "YES"
    ZERRSM = "LISTCAT failed"
    ZERRLM = "LISTCAT ENTRY("apost_tmp")" ,
      "RC("linkmvs_rc")."
    ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
    return_code = 12
    RETURN return_code
  END
  RETURN 0

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 LISTDSI retrieves lots of information about data sets.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Data_Set_Info:
  ZERRSM = ""
  ZERRLM = ""
  ADDRESS ISPEXEC "DSINFO" ,
    "DATASET("apost_dsn")"
  dsinfo_rc = RC
  SELECT
    WHEN (dsinfo_rc = 0) THEN DO
      /* Normal completion. */
      NOP
    END
    WHEN (dsinfo_rc = 8) THEN DO
      /* User requested information is unavailable. Dialog ERROR
         variables (ZERRLM, and so on) contain further information. */
      SAY "Ask your programmer to handle the error."
      SAY ZERRSM
      SAY ZERRLM
      reset_rc = Reset_Zds()
    END
    WHEN (dsinfo_rc = 12) THEN DO
      /* One of these:
         -> FAMS ERROR
         -> Obtain ERROR
         -> ERROR obtaining directory information
      */
      SAY "Ask your programmer to handle the error."
      SAY ZERRSM
      SAY ZERRLM
      reset_rc = Reset_Zds()
    END
    WHEN (dsinfo_rc = 20) THEN DO
      /* Severe error. */
      SAY "Ask your programmer to fix the DSINFO statement."
      SAY ZERRSM
      SAY ZERRLM
      reset_rc = Reset_Zds()
    END
    OTHERWISE DO
      SAY "Something very unexpected happened, RC("dsinfo_rc")."
      reset_rc = Reset_Zds()
    END
  END

  dsninfo. = ""
  dsninfo.0 = 0
  ctr = Append_Output(" ")
  ctr = Append_Output("Data Set Information")
  ctr = Append_Output(COPIES("=",73))
  ctr = Append_Output(" ")
  ctr = Append_Output("Data set name:" apost_dsn)
  ctr = Append_Output(" ")
  ctr = Append_Output(LEFT("Description",35) ,
    LEFT("LISTDSI",18) "ISPF-DSINFO")
  ctr = Append_Output(COPIES("-",35) COPIES("-",18) COPIES("-",18))
  ctr = Append_Output("Request result")
  ctr = Append_Output(COPIES("-",35) COPIES("-",18) COPIES("-",18))
  ctr = Append_Output("RC/LASTCC.........................." ,
    RIGHT(listdsi_rc,18,".") RIGHT(dsinfo_rc,18,"."))
  ctr = Append_Output("REASON............................." ,
    LEFT(SYSREASON,18,".") )
  IF (SYSMSGLVL1 <> "") THEN DO
    desc = "MSGLVL1............................"
    temp_msglvl1 = SYSMSGLVL1
    DO WHILE (temp_msglvl1 <> "")
      PARSE VAR temp_msglvl1 one_msglvl1 +70 temp_msglvl1
      ctr = Append_Output(desc one_msglvl1)
      desc = "        ..........................."
    END
  END
  IF (SYSMSGLVL2 <> "") THEN DO
    desc = "MSGLVL2............................"
    temp_msglvl2 = SYSMSGLVL2
    DO WHILE (temp_msglvl2 <> "")
      PARSE VAR temp_msglvl2 one_msglvl2 +70 temp_msglvl2
      ctr = Append_Output(desc one_msglvl2)
      desc = "        ..........................."
    END
  END
  IF (ZERRSM <> "") THEN DO
    ctr = Append_Output(" ZERRSM............................" ZERRSM)
  END
  IF (ZERRLM <> "") THEN DO
    desc = " ZERRLM............................"
    temp_zerrlm = ZERRLM
    DO WHILE (temp_zerrlm <> "")
      PARSE VAR temp_zerrlm one_zerrlm +64 temp_zerrlm
      ctr = Append_Output(desc one_zerrlm)
      desc = "        ..........................."
    END
  END
  ctr = Append_Output(" ")
  ctr = Append_Output("Storage MEDIA")
  ctr = Append_Output(COPIES("-",35) COPIES("-",18) COPIES("-",18))
  ctr = Append_Output("Number of volumes.................." ,
    RIGHT(" ",18,".") RIGHT(ZDS#VOLS,18,"."))
  ctr = Append_Output("Device type........................" ,
    LEFT(SYSUNIT,18,".") LEFT(ZDSDEVT,18,"."))
  ctr = Append_Output("First or only volume..............." ,
    LEFT(SYSVOLUME,18,".") LEFT(ZDSVOL,18,"."))
  temp_ZDSVTAB = STRIP(ZDSVTAB,"B"," ")
  IF (temp_ZDSVTAB <> "") THEN DO
    desc = "Volume table (All volumes)........."
    DO WHILE (temp_ZDSVTAB <> "")
      PARSE VAR temp_ZDSVTAB one_ZDSVTAB +8 temp_ZDSVTAB
      ctr = Append_Output(desc LEFT(" ",18,".") one_ZDSVTAB)
      desc = "        ..........................."
    END
  END
  ctr = Append_Output(" ")
  ctr = Append_Output("Allocated space")
  ctr = Append_Output(COPIES("-",35) COPIES("-",18) COPIES("-",18))
  ctr = Append_Output("Blocks per track..................." ,
    RIGHT(SYSBLKSTRK,18,".") )
  ctr = Append_Output("Primary space units................" ,
    LEFT(SYSUNITS,18,".") LEFT(ZDSSPC,18,"."))
  ctr = Append_Output("Secondary space units.............." ,
    RIGHT(" ",18,".") LEFT(ZDS2SPC,18,"."))
  ctr = Append_Output("Primary space allocation..........." ,
    RIGHT(SYSPRIMARY,18,".") RIGHT(ZDS1EX,18,"."))
  ctr = Append_Output("Secondary space allocation........." ,
    RIGHT(SYSSECONDS,18,".") RIGHT(ZDS2EX,18,"."))
  ctr = Append_Output("Allocated extents.................." ,
    RIGHT(SYSEXTENTS,18,".") RIGHT(ZDSEXTA,18,"."))
  IF (ZDSOVF = "NO") THEN DO
    ctr = Append_Output("Allocated space units.............." ,
      RIGHT(SYSALLOC,18,".") RIGHT(ZDSTOTA,18,"."))
  END
  ELSE DO
    ctr = Append_Output("Allocated space units (long format)" ,
      RIGHT(SYSALLOC,18,".") RIGHT(ZDSTOTAX,18,"."))
  END
  IF (SYSDSSMS = "PDS") THEN DO
    ctr = Append_Output("Allocated directory blocks........." ,
      RIGHT(SYSADIRBLK,18,".") RIGHT(ZDSDIRA,18,"."))
  END
  ctr = Append_Output(" ")
  ctr = Append_Output("Used space")
  ctr = Append_Output(COPIES("-",35) COPIES("-",18) COPIES("-",18))
  ctr = Append_Output("Used extents......................." ,
      RIGHT(" ",18,".") RIGHT(ZDSEXTU,18,"."))
  IF (ZDSOVF = "NO") THEN DO
    ctr = Append_Output("Used space units..................." ,
      RIGHT(SYSALLOC,18,".") RIGHT(ZDSTOTU,18,"."))
  END
  ELSE DO
    ctr = Append_Output("Used space units (long format)....." ,
      RIGHT(SYSALLOC,18,".") RIGHT(ZDSTOTUX,18,"."))
  END
  IF (SYSDSSMS = "PDS") THEN DO
    ctr = Append_Output("Used directory blocks.............." ,
      RIGHT(SYSUDIRBLK,18,".") RIGHT(ZDSDIRU,18,"."))
    ctr = Append_Output("Number of members.................." ,
      RIGHT(SYSMEMBERS,18,".") RIGHT(ZDS#MEM,18,"."))
  END
  IF (SYSDSSMS = "PROGRAM_LIBRARY") THEN DO
    ctr = Append_Output("PDSE directory blocks.............." ,
      RIGHT(" ",18,".") RIGHT(ZDSDIR,18,"."))
    ctr = Append_Output("Pages used (PDSE).................." ,
      RIGHT(SYSUSEDPAGES,18,".") RIGHT(ZDSPAGU,18,"."))
    ctr = Append_Output("Percent used (PDSE)................" ,
      RIGHT(" ",18,".") RIGHT(ZDSPERU,18,"."))
  END
  ctr = Append_Output(" ")
  ctr = Append_Output("DCB")
  ctr = Append_Output(COPIES("-",35) COPIES("-",18) COPIES("-",18))
  ctr = Append_Output("Data set organization.............." ,
    LEFT(SYSDSORG,18,".") LEFT(ZDSORG,18,"."))
  ctr = Append_Output("Record format......................" ,
    LEFT(SYSRECFM,18,".") LEFT(ZDSRF,18,"."))
  ctr = Append_Output("Block size........................." ,
    RIGHT(SYSBLKSIZE,18,".") RIGHT(ZDSBLK,18,"."))
  ctr = Append_Output("Logical record length.............." ,
    RIGHT(SYSLRECL,18,".") RIGHT(ZDSLREC,18,"."))
  ctr = Append_Output("Key length........................." ,
    RIGHT(SYSKEYLEN,18,".") )
  ctr = Append_Output(" ")
  ctr = Append_Output("Security")
  ctr = Append_Output(COPIES("-",35) COPIES("-",18) COPIES("-",18))
  IF (SYSPASSWORD = "SYSPASSWORD") THEN DO
    SYSPASSWORD = ""
  END
  ctr = Append_Output("MVS password......................." ,
    LEFT(SYSPASSWORD,18) )
  IF (SYSRACFA = "SYSRACFA") THEN DO
    SYSRACFA = ""
  END
  ctr = Append_Output("RACF..............................." ,
    LEFT(SYSRACFA,18) )
  ctr = Append_Output(" ")
  ctr = Append_Output("Dates")
  ctr = Append_Output(COPIES("-",35) COPIES("-",18) COPIES("-",18))
  ctr = Append_Output("Creation date (National format)...." ,
    LEFT(SYSCREATE,18,".") RIGHT(ZDSCDATE,18,"."))
  ctr = Append_Output("Referenced date (National format).." ,
    LEFT(SYSREFDATE,18,".") RIGHT(ZDSRDATE,18,"."))
  ctr = Append_Output("Expiration date (National format).." ,
    LEFT(SYSEXDATE,18,".") RIGHT(ZDSXDATE,18,"."))
  ctr = Append_Output("Updated since backup..............." ,
    LEFT(SYSUPDATED,18,".") )
  ctr = Append_Output("Create jobname....................." ,
    LEFT(" ",18,".") LEFT(ZDSCJOBN,18,"."))
  ctr = Append_Output("Create stepname...................." ,
    LEFT(" ",18,".") LEFT(ZDSCSTPN,18,"."))
  ctr = Append_Output(" ")
  ctr = Append_Output("SMS DATA")
  ctr = Append_Output(COPIES("-",35) COPIES("-",18) COPIES("-",18))
  ctr = Append_Output("SYSDSSMS..........................." ,
    LEFT(SYSDSSMS,18,".") LEFT(ZDSDSNT,18,"."))
  ctr = Append_Output("Storage class......................" ,
    LEFT(SYSSTORCLASS,18,".") LEFT(ZDSSC,18,"."))
  ctr = Append_Output("Data class........................." ,
    LEFT(SYSDATACLASS,18,".") LEFT(ZDSDC,18,"."))
  ctr = Append_Output("Management class..................." ,
    LEFT(SYSMGMTCLASS,18,".") LEFT(ZDSMC,18,"."))
  ctr = Append_Output("Compressible (YES/NO).............." ,
    LEFT(" ",18,".") LEFT(ZDSSEQ,18,"."))
  ctr = Append_Output(" ")
  ctr = Append_Output("Miscellaneous")
  ctr = Append_Output(COPIES("-",35) COPIES("-",18) COPIES("-",18))
  ctr = Append_Output("APF status of the data set........." ,
    LEFT(" ",18,".") LEFT(ZDSAPF,18,"."))
  ctr = Append_Output("LNKLST status of the data set......" ,
    LEFT(" ",18,".") LEFT(ZDSLNK,18,"."))
  ctr = Append_Output("Extended attribute indicator......." ,
    LEFT(" ",18,".") LEFT(ZDSEATR,18,"."))
  ctr = Append_Output("Data set version..................." ,
    LEFT(" ",18,".") RIGHT(ZDSDSNV,18,"."))
  ctr = Append_Output("Maximum number of generations......" ,
    LEFT(" ",18,".") RIGHT(ZDSNGEN,18,"."))
  ctr = Append_Output("Format 1 data control block........" ,
    "----+----1----+----2----+----3" || ,
    "----+----4----+----5----+----6" || ,
    "----+----7----+----8----+----9----+-")
  temp_ZDSCB1 = ZDSCB1
  DO WHILE (temp_ZDSCB1 <> "")
    PARSE VAR temp_ZDSCB1 one_ZDSCB1 +96 temp_ZDSCB1
    ctr = Append_Output("                                   " ,
      one_ZDSCB1)
    hex_ZDSCB1 = C2X(one_ZDSCB1)
    chr = ""
    DO hx = 1 TO LENGTH(hex_ZDSCB1) BY 2
      chr = chr || SUBSTR(hex_ZDSCB1,hx,1)
    END
    ctr = Append_Output("                                   " chr)
    chr = ""
    DO hx = 2 TO LENGTH(hex_ZDSCB1) BY 2
      chr = chr || SUBSTR(hex_ZDSCB1,hx,1)
    END
    ctr = Append_Output("                                   " chr)
    ctr = Append_Output("                                   " ,
    "----+----1----+----2----+----3" || ,
    "----+----4----+----5----+----6" || ,
    "----+----7----+----8----+----9----+-")
  END

  "ALLOC FILE(DSNINFO) NEW DELETE REUSE" ,
    "UNIT(SYSDA) TRACKS SPACE(2,2)" ,
    "DSORG(PS) RECFM(V B) BLKSIZE(0) LRECL(147)"

  ADDRESS MVS "EXECIO" dsninfo.0 ,
    "DISKW DSNINFO (STEM dsninfo. FINIS)"
  execio_rc = RC
  IF (execio_rc <> 0) THEN DO
    ZERRHM = "*"
    ZERRALRM = "YES"
    ZERRSM = "EXECIO failure"
    ZERRLM = "EXECIO DISKW error("execio_rc") on DSNINFO."
    ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
    return_code = 12
    RETURN return_code
  END
  ADDRESS ISPEXEC ,
    "LMINIT DATAID(fileid) DDNAME(DSNINFO) ENQ(SHR)"
  lminit_rc = RC
  ADDRESS ISPEXEC ,
    "VIEW DATAID("fileid")"
  ADDRESS ISPEXEC ,
    "LMCLOSE DATAID("fileid")"
  lmclose_rc = RC
  "FREE FILE(DSNINFO)"

  RETURN 0

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 LISTDSI had trouble so blank out variables.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Reset_Sys:
  sysadirblk   = ""
  sysalloc     = ""
  sysblksize   = ""
  sysblkstrk   = ""
  syscreate    = ""
  sysdataclass = ""
  sysdsname    = ""
  sysdsorg     = ""
  sysdssms     = ""
  sysexdate    = ""
  sysextents   = ""
  syskeylen    = ""
  syslrecl     = ""
  sysmembers   = ""
  sysmgmtclass = ""
  syspassword  = ""
  sysprimary   = ""
  sysracfa     = ""
  sysrecfm     = ""
  sysrefdate   = ""
  sysseconds   = ""
  sysstorclass = ""
  systrkscyl   = ""
  sysudirblk   = ""
  sysunit      = ""
  sysunits     = ""
  sysupdated   = ""
  sysused      = ""
  sysusedpages = ""
  sysvolume    = ""

  RETURN 0

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 DSINFO had trouble so blank out variables.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Reset_Zds:
  ZDS#MEM  = ""
  ZDS#VOLS = ""
  ZDSAPF   = ""
  ZDSBLK   = ""
  ZDSCB1   = ""
  ZDSCDATE = ""
  ZDSCJOBN = ""
  ZDSCSTPN = ""
  ZDSDC    = ""
  ZDSDEVT  = ""
  ZDSDIR   = ""
  ZDSDIRA  = ""
  ZDSDIRU  = ""
  ZDSDSNT  = ""
  ZDSDSNV  = ""
  ZDSEATR  = ""
  ZDSEXTA  = ""
  ZDSEXTU  = ""
  ZDSLNK   = ""
  ZDSLREC  = ""
  ZDSMC    = ""
  ZDSNGEN  = ""
  ZDSORG   = ""
  ZDSOVF   = ""
  ZDSPAGU  = ""
  ZDSPERU  = ""
  ZDSRDATE = ""
  ZDSRF    = ""
  ZDSSC    = ""
  ZDSSEQ   = ""
  ZDSSPC   = ""
  ZDSTOTA  = ""
  ZDSTOTAX = ""
  ZDSTOTU  = ""
  ZDSTOTUX = ""
  ZDSVOL   = ""
  ZDSVTAB  = ""
  ZDSXDATE = ""
  ZDS1EX   = ""
  ZDS2EX   = ""
  ZDS2SPC  = ""

  RETURN 0

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 Append STEM dsninfo. with argument.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Append_Output:
  actr = dsninfo.0 + 1
  dsninfo.actr = ARG(1)
  dsninfo.0 = actr
  RETURN actr

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 Convert string to lowercase.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
To_Lowercase: PARSE ARG myarg
  IF (lowercase_letters = "LOWERCASE_LETTERS") THEN DO
    lowercase_letters = "abcdefghijklmnopqrstuvwxyz"
  END
  IF (uppercase_letters = "UPPERCASE_LETTERS") THEN DO
    uppercase_letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  END
  RETURN TRANSLATE(myarg,lowercase_letters,uppercase_letters)

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 Convert string to uppercase.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
To_Uppercase: PARSE ARG myarg
  IF (lowercase_letters = "LOWERCASE_LETTERS") THEN DO
    lowercase_letters = "abcdefghijklmnopqrstuvwxyz"
  END
  IF (uppercase_letters = "UPPERCASE_LETTERS") THEN DO
    uppercase_letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  END
  RETURN TRANSLATE(myarg,uppercase_letters,lowercase_letters)

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 Found a forward slash (/) in the name.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Zos_Unix_Name:
  unixname = full_dsn
  SELECT
    WHEN (ABBREV("BROWSE",method,1) > 0) THEN DO
      ADDRESS ISPEXEC "BROWSE FILE(unixname)"
    END
    WHEN (ABBREV("DSCB",method,1) > 0) THEN DO
      IF (SYSMGMTCLASS <> "") THEN DO
        infotext = "//             PATHOPTS=(" || ,
          "OCREAT,OTRUNC,OWRONLY),PATHMODE=(SIRWXU,SIRGRP,SIROTH)"
/*
PATHMODE=file-access-attribute |,file-access-attribute|...)
  file-access-attribute: (Use as many as you need.)
    file owner class: SIRUSR, SIWUSR, SIXUSR, SIRWXU
    file group class: SIRGRP, SIWGRP, SIXGRP, MSIRWXG
    file other class: SIROTH, SIWOTH, SIXOTH, MSIRWXO
    set process IDs: SISUID, SISGID

PATHOPTS=(file-option|,file-option|...)
  for access group: ORDONLY, OWRONLY, ORDWR
  for status group: OAPPEND, OCREAT, OEXCL, ONOCTTY,
                    ONONBLOCK, OSYNC, OTRUNC
  ->You can specify up to 7 file-options.
*/
        ADDRESS ISREDIT ,
          "LINE_AFTER" currline "= INFOLINE (infotext)"
        isredit_rc = RC
      END
    END
    WHEN (ABBREV("EDIT",method,1) > 0) THEN DO
      ADDRESS ISPEXEC "EDIT FILE(unixname)"
    END
    WHEN (ABBREV("INFO",method,1) > 0) THEN DO
      function_rc = Zos_Unix_Stats()
    END
    WHEN (ABBREV("LISTCAT",method,1) > 0) THEN DO
    END
    OTHERWISE DO
      ADDRESS ISPEXEC "VIEW FILE(unixname)"
    END
  END
  RETURN 0

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 Found a forward slash (/) in the name.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Zos_Unix_Stats:
  syscalls_rc = SYSCALLS("ON")
  ADDRESS SYSCALL 'stat (unixname) stem.'
  syscalls_rc = RC
  uss_stat_retval = RETVAL
  uss_stat_errno = ERRNO
  IF ((syscalls_rc >= 0) & (uss_stat_retval = -1)) THEN DO
    uss_stat_errnojr = ERRNOJR
    ADDRESS TSO "BPXMTEXT" uss_stat_errnojr
    bpxmtext_rc = RC
    ZERRHM = "*"
    ZERRALRM = "YES"
    ZERRSM = "UNIX stat failure"
    ZERRLM = "The message text was displayed on your terminal."
    ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
    return_code = 12
    RETURN return_code
  END
  ELSE DO
    uss_stat_errnojr = ""
  END

  dsninfo. = ""
  dsninfo.0 = 0
  ctr = Append_Output(" ")
  ctr = Append_Output("z/OS UNIX System Services - fstat")
  ctr = Append_Output(COPIES("=",73))
  ctr = Append_Output(" ")
  ctr = Append_Output("Data set name:" full_dsn)
  ctr = Append_Output(" ")
  ctr = Append_Output(LEFT("Description",35) "Value")
  ctr = Append_Output(COPIES("-",35) COPIES("-",18))
  ctr = Append_Output("Request result")
  ctr = Append_Output(COPIES("-",35) COPIES("-",18))
  ctr = Append_Output("SYSCALLS..........................." ,
    RIGHT(syscalls_rc,18,".") )
  ctr = Append_Output("RETVAL............................." ,
    RIGHT(uss_stat_retval,18,".") )
  ctr = Append_Output("ERRNO.............................." ,
    RIGHT(uss_stat_errno,18,".") )
  IF ((syscalls_rc >= 0) & (uss_stat_retval = -1)) THEN DO
    ctr = Append_Output("ERRNOJR............................" ,
      RIGHT(uss_stat_errnojr,18,".") )
  END
  ctr = Append_Output(" ")
  ctr = Append_Output("Storage MEDIA")
  ctr = Append_Output(COPIES("-",35) COPIES("-",18))
  ctr = Append_Output("RACF File ID for auditing.........." ,
    LEFT(stem.ST_AUDITID,6) "x'"C2X(SUBSTR(stem.ST_AUDITID,7))"'")
  ctr = Append_Output("Device ID of the file.............." ,
    stem.ST_DEV)
  ctr = Append_Output("File identifier...................." ,
    "x'"C2X(stem.ST_FID)"'")
  ctr = Append_Output(" ")
  ctr = Append_Output("Allocated space")
  ctr = Append_Output(COPIES("-",35) COPIES("-",18))
  ctr = Append_Output("Blocks allocated..................." ,
    RIGHT(stem.ST_BLOCKS,18,".") )
  ctr = Append_Output(" ")
  ctr = Append_Output("Used space")
  ctr = Append_Output(COPIES("-",35) COPIES("-",18))
  IF (POS("M",stem.ST_SIZE) > 0) THEN DO
    show_size = stem.ST_SIZE"egabytes"
  END
  ELSE DO
    show_size = stem.ST_SIZE"Bytes"
  END
  ctr = Append_Output("File size for a regular file (B/M)." ,
    RIGHT(show_size,18,".") )
  ctr = Append_Output(" ")
  ctr = Append_Output("DCB")
  ctr = Append_Output(COPIES("-",35) COPIES("-",18))
  SELECT
    WHEN (stem.ST_FILEFMT = S_FFBINARY) THEN DO
      desc = "Binary data"
    END
    WHEN (stem.ST_FILEFMT = S_FFCR) THEN DO
      desc = "Text data delimited by CR"
    END
    WHEN (stem.ST_FILEFMT = S_FFCRLF) THEN DO
      desc = "Text data delimited by CRLF"
    END
    WHEN (stem.ST_FILEFMT = S_FFCRNL) THEN DO
      desc = "Text data delimited by CRNL"
    END
    WHEN (stem.ST_FILEFMT = S_FFLF) THEN DO
      desc = "Text data delimited by LF"
    END
    WHEN (stem.ST_FILEFMT = S_FFLFCR) THEN DO
      desc = "Text data delimited by LFCR"
    END
    WHEN (stem.ST_FILEFMT = S_FFNA) THEN DO
      desc = "Text data delimiter not available"
    END
    WHEN (stem.ST_FILEFMT = S_FFNL) THEN DO
      desc = "Text data delimited by NL"
    END
    WHEN (stem.ST_FILEFMT = S_FFRECORD) THEN DO
      desc = "File data prefixed with length"
    END
    OTHERWISE DO
      desc = stem.ST_FILEFMT "is new to me"
    END
  END
  ctr = Append_Output("Format of the file................." desc)
  SELECT
    WHEN (stem.ST_TYPE = S_ISCHR) THEN DO
      desc = "Character special file"
    END
    WHEN (stem.ST_TYPE = S_ISDIR) THEN DO
      desc = "Directory"
    END
    WHEN (stem.ST_TYPE = S_ISFIFO) THEN DO
      desc = "FIFO special file"
    END
    WHEN (stem.ST_TYPE = S_ISREG) THEN DO
      desc = "Regular file"
    END
    WHEN (stem.ST_TYPE = S_ISSYM) THEN DO
      desc = "Symbolic link"
    END
    OTHERWISE DO
      desc = stem.ST_TYPE "is new to me"
    END
  END
  ctr = Append_Output("File type.........................." desc)
  ctr = Append_Output("File block size...................." ,
    RIGHT(stem.ST_BLKSIZE,18,".") )
  ctr = Append_Output("Coded character set ID............." ,
    "x'"C2X(stem.ST_CCSID)"'")
  ctr = Append_Output(" ")
  ctr = Append_Output("Security")
  ctr = Append_Output(COPIES("-",35) COPIES("-",18))
  ctr = Append_Output("User ID of the owner of the file..." ,
    RIGHT(stem.ST_UID,18,".") )
  ctr = Append_Output("Group ID of the group of the file.." ,
    RIGHT(stem.ST_GID,18,".") )
  ctr = Append_Output("File mode, permission bits only...." ,
    RIGHT(stem.ST_MODE,18,".") )
  ctr = Append_Output("Auditor audit information.........." ,
    RIGHT(stem.ST_AAUDIT,18,".") )
  ctr = Append_Output("Area for user audit information...." ,
    stem.ST_UAUDIT)
  ctr = Append_Output("Access ACL (access control list)..." ,
    RIGHT(stem.ST_ACCESSACL,18,".") )
/* Before using aclget, variable must be initialized using aclinit. */
  ctr = Append_Output("Directory model ACL................" ,
    RIGHT(stem.ST_DMODELACL,18,".") )
  ctr = Append_Output("File model ACL....................." ,
    RIGHT(stem.ST_FMODELACL,18,".") )
  ctr = Append_Output("Security Label....................." ,
    stem.ST_SECLABEL)
  ctr = Append_Output(" ")
  ctr = Append_Output("Dates")
  ctr = Append_Output(COPIES("-",35) COPIES("-",18))
  ADDRESS SYSCALL 'gmtime (stem.ST_CRTIME) tm.'
  syscalls_rc = RC
  gmtime_retval = RETVAL
  crtime = ,
    tm.TM_YEAR"/"RIGHT(VALUE(tm.TM_MON + 1),2,0)"/" || ,
    RIGHT(tm.TM_MDAY,2,0) ,
    RIGHT(tm.TM_HOUR,2,0)":"RIGHT(tm.TM_MIN,2,0)":" || ,
    RIGHT(tm.TM_SEC,2,0) ,
    "DST("tm.TM_ISDST")"
  ctr = Append_Output("File creation time................." crtime)
  ADDRESS SYSCALL 'gmtime (stem.ST_CTIME) tm.'
  syscalls_rc = RC
  gmtime_retval = RETVAL
  ctime = ,
    tm.TM_YEAR"/"RIGHT(VALUE(tm.TM_MON + 1),2,0)"/" || ,
    RIGHT(tm.TM_MDAY,2,0) ,
    RIGHT(tm.TM_HOUR,2,0)":"RIGHT(tm.TM_MIN,2,0)":" || ,
    RIGHT(tm.TM_SEC,2,0) ,
    "DST("tm.TM_ISDST")"
  ctr = Append_Output("Time of last file status change...." ctime)
  ADDRESS SYSCALL 'gmtime (stem.ST_ATIME) tm.'
  syscalls_rc = RC
  gmtime_retval = RETVAL
  atime = ,
    tm.TM_YEAR"/"RIGHT(VALUE(tm.TM_MON + 1),2,0)"/" || ,
    RIGHT(tm.TM_MDAY,2,0) ,
    RIGHT(tm.TM_HOUR,2,0)":"RIGHT(tm.TM_MIN,2,0)":" || ,
    RIGHT(tm.TM_SEC,2,0) ,
    "DST("tm.TM_ISDST")"
  ctr = Append_Output("Time of last access................" atime)
  ADDRESS SYSCALL 'gmtime (stem.ST_MTIME) tm.'
  syscalls_rc = RC
  gmtime_retval = RETVAL
  mtime = ,
    tm.TM_YEAR"/"RIGHT(VALUE(tm.TM_MON + 1),2,0)"/" || ,
    RIGHT(tm.TM_MDAY,2,0) ,
    RIGHT(tm.TM_HOUR,2,0)":"RIGHT(tm.TM_MIN,2,0)":" || ,
    RIGHT(tm.TM_SEC,2,0) ,
    "DST("tm.TM_ISDST")"
  ctr = Append_Output("Time of last data modification....." mtime)
  ADDRESS SYSCALL 'gmtime (stem.ST_RTIME) tm.'
  syscalls_rc = RC
  gmtime_retval = RETVAL
  rtime = ,
    tm.TM_YEAR"/"RIGHT(VALUE(tm.TM_MON + 1),2,0)"/" || ,
    RIGHT(tm.TM_MDAY,2,0) ,
    RIGHT(tm.TM_HOUR,2,0)":"RIGHT(tm.TM_MIN,2,0)":" || ,
    RIGHT(tm.TM_SEC,2,0) ,
    "DST("tm.TM_ISDST")"
  ctr = Append_Output("File backup time stamp............." rtime)
  ctr = Append_Output(" ")
  ctr = Append_Output("Miscellaneous")
  ctr = Append_Output(COPIES("-",35) COPIES("-",18))
  ctr = Append_Output("External symbolic link flag........" ,
    RIGHT(stem.ST_EXTLINK,18,".") )
  ctr = Append_Output("General attribute values..........." ,
    "x'"C2X(stem.ST_GENVALUE)"'")
  ctr = Append_Output("File serial number................." ,
    RIGHT(stem.ST_INO      ,18,".") )
  ctr = Append_Output("Major number (char special file)..." ,
    RIGHT(stem.ST_MAJOR,18,".") )
  ctr = Append_Output("Minor number (char special file)..." ,
    RIGHT(stem.ST_MINOR,18,".") )
  ctr = Append_Output("Number of links...................." ,
    RIGHT(stem.ST_NLINK,18,".") )
  ctr = Append_Output("Set Group ID on execution flag....." ,
    RIGHT(stem.ST_SETGID,18,".") )
  ctr = Append_Output("Set User ID on execution flag......" ,
    RIGHT(stem.ST_SETUID,18,".") )
  ctr = Append_Output("Sticky bit flag (keep loaded)......" ,
    RIGHT(stem.ST_STICKY,18,".") )

  "ALLOC FILE(DSNINFO) NEW DELETE REUSE" ,
    "UNIT(SYSDA) TRACKS SPACE(2,2)" ,
    "DSORG(PS) RECFM(V B) BLKSIZE(0) LRECL(147)"

  ADDRESS MVS "EXECIO" dsninfo.0 ,
    "DISKW DSNINFO (STEM dsninfo. FINIS)"
  execio_rc = RC
  IF (execio_rc <> 0) THEN DO
    ZERRHM = "*"
    ZERRALRM = "YES"
    ZERRSM = "EXECIO failure"
    ZERRLM = "EXECIO DISKW error("execio_rc") on DSNINFO."
    ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
    return_code = 12
    RETURN return_code
  END
  ADDRESS ISPEXEC ,
    "LMINIT DATAID(fileid) DDNAME(DSNINFO) ENQ(SHR)"
  lminit_rc = RC
  ADDRESS ISPEXEC ,
    "VIEW DATAID("fileid")"
  ADDRESS ISPEXEC ,
    "LMCLOSE DATAID("fileid")"
  lmclose_rc = RC
  "FREE FILE(DSNINFO)"
  RETURN 0

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
End of code.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
