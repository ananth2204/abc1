{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011549000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 1410864, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 12, "INMDSNAM": "CBT.V500.FILE243.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 1410864, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 1410864, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE243.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x17\\x12'", "DS1TRBAL": "b'1\\x02'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x01\\xaf\\x00\\x03\\x01\\xb0\\x00\\x0b\\x00\\x18'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04G\\x00\\x00\\x01\\x06\\x03?\\x01\\x06\\x03?\\tX\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf1@@@'", "ispf": {"version": "04.71", "flags": 0, "createdate": "2006-02-02T00:00:00", "modifydate": "2006-02-02T09:58:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-471"}, "text": "REGULAR CBT TAPE - VERSION 471    FILE:  243\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT471.FILE243\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 36 MEMBERS COUNTED; CUMULATIVE SIZE IS 13,115 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   02/02/06    09:58:35    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#LKED": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x1e\\x00\\x00V\\x00\\x976_\\x00\\x976_\\x00I\\x00\\x15\\x00\\x15\\x00\\x00\\xd7\\xc7\\xd4\\xe5\\xe8\\xc3@@@@'", "ispf": {"version": "30.00", "flags": 0, "createdate": "1997-12-31T00:00:00", "modifydate": "1997-12-31T00:49:56", "lines": 21, "newlines": 21, "modlines": 0, "user": "PGMVYC"}, "text": "//PGMVYCI JOB 'IBI','V CHERNYAK',REGION=6M,NOTIFY=PGMVYC,CLASS=A,\n//        MSGCLASS=A,MSGLEVEL=(1,1)\n//LKED     EXEC PGM=HEWLKED,PARM='NOLIST,LET'\n//SYSPRINT DD   SYSOUT=*\n//SYSUT1   DD   UNIT=VIO,SPACE=(TRK,(30,30))\n//SYSLIB   DD   DSN=PLI.V2R3M0.PLIBASE,DISP=SHR\n//         DD   DSN=PLI.V2R3M0.SIBMBASE,DISP=SHR\n//         DD   DSN=ISP.V4R1M0.SISPLOAD,DISP=SHR\n//         DD   DSN=PGMVYC.REASM.SUBLOAD,DISP=SHR\n//SYSLMOD  DD   DSN=PGMVYC.REASM.LOAD,DISP=SHR\n//*SYSLMOD  DD   UNIT=VIO,SPACE=(TRK,(20,20,1)),\n//*         DCB=(DSORG=PO,BLKSIZE=13030,RECFM=U)\n//SYSOLD   DD   DSN=PGMVYC.REASM.LOAD,DISP=SHR\n//SYSLIN   DD   *\n           INCLUDE SYSLIB(REASMM)\n           INCLUDE SYSLIB(REASCNV)\n           INCLUDE SYSLIB(REASMLIV)\n           INCLUDE SYSLIB(REASQPW$)\n           ENTRY PLISTART\n           NAME  REASM(R)\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE242": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04G\\x00\\x00\\x01\\x06\\x03?\\x01\\x06\\x03?\\tX\\x00\\x10\\x00\\x10\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf1@@@'", "ispf": {"version": "04.71", "flags": 0, "createdate": "2006-02-02T00:00:00", "modifydate": "2006-02-02T09:58:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "CBT-471"}, "text": "//***FILE 242 is from Valentin Chernyak and contains REASM, which   *   FILE 242\n//*           is a Super Disassembler that runs interactively       *   FILE 242\n//*           under ISPF.  This file contains a collection of       *   FILE 242\n//*           \"pre-digested\" MVS macros for REASM, to interactively *   FILE 242\n//*           supply mapping labels.  You can add to this           *   FILE 242\n//*           collection with the PRCBGEN utility that is           *   FILE 242\n//*           supplied on File 238 (JCL on File 241).               *   FILE 242\n//*                                                                 *   FILE 242\n//*           This collection has been greatly enlarged by the      *   FILE 242\n//*           author.                                               *   FILE 242\n//*                                                                 *   FILE 242\n//*           Current Release:  4.0                                 *   FILE 242\n//*                                                                 *   FILE 242\n//*        email:   volic@kspus.org                                 *   FILE 242\n//*                 valentin.chernyak@multex.com                    *   FILE 242\n//*                                                                 *   FILE 242\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE243": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04G\\x00\\x00\\x01\\x06\\x03?\\x01\\x06\\x03?\\tW\\x00\\x1a\\x00\\x1a\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf1@@@'", "ispf": {"version": "04.71", "flags": 0, "createdate": "2006-02-02T00:00:00", "modifydate": "2006-02-02T09:57:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "CBT-471"}, "text": "//***FILE 243 is from Valentin Chernyak and contains source code    *   FILE 243\n//*           for his Super Disassembler called REASM.              *   FILE 243\n//*                                                                 *   FILE 243\n//*           Current Release:  4.0                                 *   FILE 243\n//*                                                                 *   FILE 243\n//*        email:   volic@kspus.org                                 *   FILE 243\n//*                 valentin.chernyak@multex.com                    *   FILE 243\n//*                                                                 *   FILE 243\n//*           There are 3 members in IEBUPDTE SYSIN format (or      *   FILE 243\n//*           rather PDSLOAD format with the ISPF statistics        *   FILE 243\n//*           included.  They are:                                  *   FILE 243\n//*                                                                 *   FILE 243\n//*           You can run REASM without assembling and compiling    *   FILE 243\n//*           it from source code, using the load modules           *   FILE 243\n//*           supplied in File 238.                                 *   FILE 243\n//*                                                                 *   FILE 243\n//*           ASM      -  Assembler source                          *   FILE 243\n//*                                                                 *   FILE 243\n//*           PLI      -  PL/I source                               *   FILE 243\n//*                                                                 *   FILE 243\n//*           MACLIB   -  Assembler Macros - there may be a few     *   FILE 243\n//*                       more than necessary.  If some are         *   FILE 243\n//*                       missing, please contact Sam Golob at      *   FILE 243\n//*                       sbgolob@attglobal.net or Valentin         *   FILE 243\n//*                       Chernyak at  volic@kspus.org .            *   FILE 243\n//*                                                                 *   FILE 243\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PLIXCL": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x06\\x01?\\x01\\x06\\x01?\\x15B\\x00\\x15\\x00\\x15\\x00\\x00\\xd7\\xc7\\xd4\\xe5\\xc3@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-01-13T00:00:00", "modifydate": "2006-01-13T15:42:54", "lines": 21, "newlines": 21, "modlines": 0, "user": "PGMVC"}, "text": "//PLIXCL   PROC LNGPRFX='IEL.V1R1M1',LIBPRFX='CEE',\n//         SYSLBLK=3200,GOPGM=GO\n//PLI      EXEC PGM=IEL1AA,PARM='OBJECT,NODECK'\n//STEPLIB  DD  DSN=&LNGPRFX..SIELCOMP,DISP=SHR\n//         DD  DSN=&LIBPRFX..SCEERUN,DISP=SHR\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSN=&&LOADSET,DISP=(MOD,PASS),UNIT=SYSDA,\n//             SPACE=(80,(250,100)),DCB=(BLKSIZE=&SYSLBLK)\n//SYSUT1   DD  DSN=&&SYSUT1,UNIT=SYSDA,\n//             SPACE=(1024,(200,50),,CONTIG,ROUND),DCB=BLKSIZE=1024\n//LKED     EXEC PGM=IEWL,PARM='XREF,LIST',COND=(9,LT,PLI)\n//SYSLIB   DD  DSN=&LIBPRFX..SCEELKED,DISP=SHR\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSN=&&LOADSET,DISP=(OLD,DELETE)\n//         DD  DDNAME=SYSIN\n//SYSLMOD  DD  DSN=&&GOSET(&GOPGM),DISP=(MOD,PASS),UNIT=SYSDA,\n//             SPACE=(1024,(50,20,1))\n//SYSUT1   DD  DSN=&&SYSUT1,UNIT=SYSDA,SPACE=(1024,(200,20)),\n//             DCB=BLKSIZE=1024\n//SYSIN    DD  DUMMY\n//         PEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REAPSWD": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x1e\\x00\\x00\\x00\\x00\\x976_\\x00\\x976_\\x00I\\x00\\x1d\\x00\\x1d\\x00\\x00\\xd7\\xc7\\xd4\\xe5\\xe8\\xc3@@@@'", "ispf": {"version": "30.00", "flags": 0, "createdate": "1997-12-31T00:00:00", "modifydate": "1997-12-31T00:49:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "PGMVYC"}, "text": "*PROCESS S,OPTIONS;\n /*\n//REAPSWD JOB REGION=1000K\n// EXEC PLXCM,I1='MVS.REASM.PLI',B1=,M=REAPSWD\n//LKED.SYSLIB DD\n// DD DSN=MVS.REASM.SUBLOAD,DISP=SHR\n//\n */\n REAPSWD: PROC OPTIONS(MAIN);\n   DCL   REASQPW ENTRY EXT,\n         CPU     CHAR(12),\n         DATE    CHAR(6),\n         PSWD    CHAR(19);\n\n\n   DO WHILE('1'B);\n      DISPLAY\n        ('REASQPW:ENTER CPU NUMBER AND DATE \"NNNNNNNNNNNN,YY.DDD\"')\n        REPLY(PSWD);\n      IF PSWD='U' THEN LEAVE;\n      GET STRING(PSWD) EDIT(CPU,DATE)(A(12),X(1),A(6));\n      IF CPU='************' THEN CPU='';\n      PSWD = CPU;\n      CALL REASQPW('CRYPT',PSWD,DATE);\n      DISPLAY('REASQPW:PASSWORD FOR CPU \"' || CPU || ' DATE \"' || DATE\n              || '\"   IS \"' || PSWD || '\"');\n   END;\n\n END REAPSWD;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REASCNV": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x1e\\x01\\x00E\\x00\\x976_\\x01\\x06\\x01?\\x15S\\x00\\xb8\\x00\\xb7\\x00\\x02\\xd7\\xc7\\xd4\\xe5\\xc3@@@@@'", "ispf": {"version": "30.01", "flags": 0, "createdate": "1997-12-31T00:00:00", "modifydate": "2006-01-13T15:53:45", "lines": 184, "newlines": 183, "modlines": 2, "user": "PGMVC"}, "text": "*PROCESS M,OPT(TIME),S,GN;\n /*\n//PGMVCI  JOB 'IBI','V CHERNYAK',REGION=1000K,NOTIFY=PGMVC,CLASS=A,\n//        MSGCLASS=A,MSGLEVEL=(1,1)\n//PROCLIB  JCLLIB ORDER=PGMVYC.REASM.PLI\n//        EXEC PLIXCL,PARM.LKED='LET,NCAL'\n//PLI.SYSIN     DD DSN=PGMVYC.REASM.PLI(REASCNV),DISP=SHR\n//PLI.SYSLIB    DD DSN=PGMVYC.REASM.PLI,DISP=SHR\n//LKED.SYSLMOD  DD DSN=PGMVYC.REASM.SUBLOAD(REASCNV),DISP=SHR\n//\n */\n         /*   --------------------------------   */\n         /*   UTILITY    SUBROUTINES FOR REASM   */\n         /*   --------------------------------   */\n /*********************************************************************/\n /*  CONVERT FROM HEX TO BIN FIXED 31                                 */\n /*********************************************************************/\n $HBF:\n     PROC(HEX)  REORDER RED  RETURNS(BIN FIXED(31));\n     DCL    HEX     CHAR(*) VAR,\n            ALFA    CHAR(16) STATIC INT INIT('0123456789ABCDEF'),\n            (LENGTH,SUBSTR,INDEX,UNSPEC) BUILTIN,\n            (I,L,K) BIN FIXED INIT(0),\n            J       BIN FIXED(31) INIT(0);\n      L=LENGTH(HEX);\n      DO I=L TO 1 BY -1;\n         K=INDEX(ALFA,SUBSTR(HEX,I,1));\n         IF K=0 THEN RETURN(-1);\n         J=J+(K-1)*(16**(L-I));\n      END;\n      RETURN(J);\n END $HBF;\n\n*PROCESS M,OPT(TIME),S,GN;\n /*********************************************************************/\n /*  CONVERT FROM HEX TO BIT 16                                       */\n /*********************************************************************/\n $HB:\n     PROC(HEX)  REORDER RED RETURNS(BIT(16));\n     DCL  HEX CHAR(*) VAR,\n          (SUBSTR,UNSPEC) BUILTIN,\n          J   BIN FIXED(31);\n     DCL  $HBF EXT ENTRY(CHAR(*) VAR) RETURNS(BIN FIXED(31));\n     J = $HBF(HEX);\n     RETURN (SUBSTR(UNSPEC(J),17));\n END $HB;\n\n*PROCESS M,OPT(TIME),S,GN;\n /*********************************************************************/\n /*  BIN(31) -> HEX(8) CONVERTION SUBROUTINE                          */\n /*********************************************************************/\n $BH:\n     PROC(BIN31) REORDER RED RETURNS(CHAR(8));\n     DCL BIN31 BIN FIXED(31),\n         IPTR  PTR,\n         #I    CHAR(4) BASED(IPTR);\n     DCL $CH   ENTRY(CHAR(*) VAR) EXT RETURNS(CHAR(80) VAR);\n     DCL ADDR  BUILTIN;\n     IPTR = ADDR(BIN31);\n     RETURN($CH(#I));\n END $BH;\n\n*PROCESS M,OPT(TIME),S,GN;\n /*********************************************************************/\n /*  CHAR(*) -> HEX(*) CONVERTION SUBROUTINE                          */\n /*********************************************************************/\n $CH:\n     PROC(CH) REORDER RED RETURNS(CHAR(80) VAR);\n     DCL    CH         CHAR(*)  VAR,\n            B          CHAR(1),\n         1 $B          BASED($BPTR),\n          2  B1        BIT(4),\n          2  B2        BIT(4),\n            $BPTR      PTR,\n            I          BIN FIXED,\n            RT         CHAR(80) VAR INIT(''),\n            $HEX(0:15) CHAR(1) STATIC INT INIT\n     ('0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F');\n     DCL (LENGTH, SUBSTR, ADDR) BUILTIN;\n\n     DO I=1 TO LENGTH(CH);\n        B     = SUBSTR(CH,I,1);\n        $BPTR = ADDR(B);\n        RT    = RT || $HEX(B1) || $HEX(B2);\n     END;\n     RETURN(RT);\n END $CH;\n\n*PROCESS M,OPT(TIME),S,GN;\n %SKIP;\n /*********************************************************************/\n /*  CONVERT BINARY -> CHAR WITHOUT LEADING BLANKS                    */\n /*********************************************************************/\n $DIGIT:\n     PROC(BINF) REORDER RED RETURNS(CHAR(16) VAR);\n     DCL  BINF BIN FIXED(31),\n          C    CHAR(16) VAR;\n     DCL  (VERIFY, SUBSTR) BUILTIN;\n     PUT STRING(C) EDIT(BINF)(F(16));\n     RETURN(SUBSTR(C,VERIFY(C,' ')));\n END $DIGIT;\n\n*PROCESS M,OPT(TIME),S,GN;\n /*********************************************************************/\n /*  CONVERT IMMIDIATE OPERAND TO CHAR STRING                         */\n /*********************************************************************/\n $IMM:\n     PROC(IMM)   REORDER RED RETURNS(CHAR(5) VAR);\n     DCL  IMM    BIT(8),\n          VAL    CHAR(2),\n          (SUBSTR,UNSPEC) BUILTIN,\n          $HEX(0:15) CHAR(1) STATIC INT INIT\n     ('0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F');\n\n     SUBSTR(VAL,1,1) = $HEX(SUBSTR(UNSPEC(IMM),1,4));\n     SUBSTR(VAL,2,1) = $HEX(SUBSTR(UNSPEC(IMM),5,4));\n     RETURN('X''' || VAL || '''');\n END $IMM;\n\n*PROCESS M,OPT(TIME),S,GN;\n /*********************************************************************/\n /*  NEXTEL - TYPE SUBROUTINE                                         */\n /*********************************************************************/\n $NEXTEL:\n     PROC(STR) REORDER RETURNS(CHAR(80) VAR);\n\n DCL STR    CHAR(80) VAR,\n     RT     CHAR(80) VAR INIT(''),\n     (I,J,K,L)  BIN FIXED,\n     (LENGTH,INDEX,VERIFY,SUBSTR,MIN,MAX) BUILTIN;\n\n     DO WHILE (LENGTH(STR)>1 &\n               (SUBSTR(STR,1,1)=' ' | SUBSTR(STR,1,1)=',') );\n        STR = SUBSTR(STR,2);\n     END;\n\n     L=LENGTH(STR);\n     I=INDEX(STR,' ');\n     J=INDEX(STR,',');\n     IF (L>1) & ((I>1) | (J>1)) THEN DO;\n        K = MIN(I,J);\n        IF (K=0) THEN K = MAX(I,J);\n        RT=SUBSTR(STR,1,K-1);\n        STR=SUBSTR(STR,K+1);\n     END;\n     ELSE DO;\n        RT=STR;\n        STR='';\n     END;\n     RETURN(RT);\n END $NEXTEL;\n\n*PROCESS M,OPT(TIME),S,GN;\n /*********************************************************************/\n /*   RECIEVE NAME FOR DUMMY                                          */\n /*********************************************************************/\n $DNAME:\n       PROC(P,OFFSET,II) REORDER RED RETURNS(CHAR(8) VAR);\n DCL   (P,Q)          PTR,\n       (OFFSET,II)    BIN FIXED(31),\n       V              CHAR(8) VAR;\n DCL   (SUBSTR,NULL)  BUILTIN;\n DCL   $NEXTEL ENTRY(CHAR(*) VAR)   EXT RETURNS(CHAR(20) VAR);\n DCL   $BH     ENTRY(BIN FIXED(31)) EXT RETURNS(CHAR(8));\n %NOPRINT;\n %INCLUDE REASMBAS;\n %PRINT;\n\n       V    = $NEXTEL(SUBSTR(P->LBLOCK.NAME,2,3));\n       V    = V || SUBSTR($BH(OFFSET),4,5);\n       II   = 1;\n\n       Q = P->LBLOCK.ADUMMY;\n       DO WHILE(Q\u00ac=NULL);\n          IF Q->DUMMY.OFF = OFFSET &\n             Q->DUMMY.NAME  \u00ac= ''     THEN DO;\n             V  = Q->DUMMY.NAME;\n             II = 0;\n          END;\n          Q = Q->DUMMY.NEXT;\n       END;\n\n       RETURN($NEXTEL(V));\n END $DNAME;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REASESD": {"ttr": 532, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x1e\\x01\\x005\\x00\\x976_\\x01\\x06\\x01?\\x15T\\x00\\xbf\\x00\\xbe\\x00\\x02\\xd7\\xc7\\xd4\\xe5\\xc3@@@@@'", "ispf": {"version": "30.01", "flags": 0, "createdate": "1997-12-31T00:00:00", "modifydate": "2006-01-13T15:54:35", "lines": 191, "newlines": 190, "modlines": 2, "user": "PGMVC"}, "text": "*PROCESS M,OPT(TIME),S,GN,OL,XREF;\n /*\n//PGMVCI  JOB 'IBI','V CHERNYAK',REGION=1000K,NOTIFY=PGMVC,CLASS=A,\n//        MSGCLASS=A,MSGLEVEL=(1,1)\n//PROCLIB  JCLLIB ORDER=PGMVYC.REASM.PLI\n//        EXEC PLIXCL,PARM.LKED='LET,NCAL'\n//PLI.SYSIN     DD DSN=PGMVYC.REASM.PLI(REASESD),DISP=SHR\n//PLI.SYSLIB    DD DSN=PGMVYC.REASM.PLI,DISP=SHR\n//LKED.SYSLMOD  DD DSN=PGMVYC.REASM.SUBLOAD(REASESD),DISP=SHR\n//\n */\n REASESD:\n    PROC (ESDARR, DIME) REORDER RETURNS(CHAR(8));\n\n DCL 1   ESDARR(*),\n      2  NAME          CHAR(8),\n      2  TYPE          BIT(8),\n      2  OFFSET        BIT(24),\n      2  ALIGN         BIT(8),\n      2  LENGTH        BIT(24),\n      2  REF           BIN FIXED,\n      2  ID            BIN FIXED,\n         DIME          BIN FIXED;\n\n DCL     (I,J),\n         #CSECT        BIT(8) STATIC INT INIT('00000000'B),\n         #ENTRY        BIT(8) STATIC INT INIT('00000011'B),\n         #MASK         BIT(8) STATIC INT INIT('00001111'B),\n         F1            BIN FIXED(31) STATIC INT INIT(1),\n         F4            BIN FIXED(31) STATIC INT INIT(4),\n         F5            BIN FIXED(31) STATIC INT INIT(5),\n         F8            BIN FIXED(31) STATIC INT INIT(8),\n         F60           BIN FIXED(31) STATIC INT INIT(60),\n         CSECT         CHAR(8)                  INIT('........'),\n         NROWS         BIN FIXED                INIT(0),\n         ROW           BIN FIXED(31),\n         TABNAME       CHAR(8),\n         BYTE          BIT(8),\n         LOCVAR        CHAR(60) VAR             INIT(''),\n         TABLE         CHAR(9) STATIC INT       INIT('REASM03 '),\n         RTBCRP        BIN FIXED(31),\n         RTBCMD        CHAR(60)                 INIT(''),\n         C             CHAR(1)                  INIT(''),\n         RTBNAME       CHAR(8)                  INIT(''),\n         RTBOFF        BIN FIXED(31)            INIT(0),\n         RTBOFF1       BIN FIXED(31)            INIT(0),\n         RTBLEN        BIN FIXED(31)            INIT(0),\n         RTBLENB       BIN FIXED(31)            INIT(0),\n         RTBTYPE       CHAR(5)                  INIT(''),\n         RTBREF        CHAR(8)                  INIT('');\n\n DCL     ISPLINK ENTRY EXT OPTIONS(ASM INTER RETCODE),\n         (VERIFY,SUBSTR,UNSPEC,DIM,BIN,PLIRETV) BUILTIN;\n\n     CALL ISPLINK ('VDEFINE ', 'RTBCRP  ', RTBCRP,  'FIXED ',  F4 );\n     CALL ISPLINK ('VDEFINE ', 'RTBCMD  ', RTBCMD,  'CHAR  ', F60 );\n     CALL ISPLINK ('VDEFINE ', 'C       ', C,       'CHAR  ',  F1 );\n     CALL ISPLINK ('VDEFINE ', 'RTBNAME ', RTBNAME, 'CHAR  ',  F8 );\n     CALL ISPLINK ('VDEFINE ', 'RTBOFF  ', RTBOFF,  'HEX   ',  F4 );\n     CALL ISPLINK ('VDEFINE ', 'RTBOFF1 ', RTBOFF1, 'FIXED ',  F4 );\n     CALL ISPLINK ('VDEFINE ', 'RTBLEN  ', RTBLEN,  'HEX   ',  F4 );\n     CALL ISPLINK ('VDEFINE ', 'RTBLENB ', RTBLENB, 'FIXED ',  F4 );\n     CALL ISPLINK ('VDEFINE ', 'RTBTYPE ', RTBTYPE, 'CHAR  ',  F5 );\n     CALL ISPLINK ('VDEFINE ', 'RTBREF  ', RTBREF,  'CHAR  ',  F8 );\n\n     CALL ISPLINK ('TBCREATE', TABLE, '(RTBNAME)',\n          '(C,RTBOFF,RTBOFF1,RTBLEN,RTBLENB,RTBTYPE,RTBREF)',\n          'NOWRITE ', ' ');\n     IF PLIRETV() \u00ac= 0 THEN DO;\n        CALL ISPLINK('SETMSG ', 'REAS071 ');\n        GOTO L_DEL;\n     END;\n\n     DO I=1 TO DIME;\n        UNSPEC(BYTE) = UNSPEC(ESDARR(I).TYPE) & #MASK;\n        C       = '';\n        RTBTYPE = '';\n        RTBREF  = '';\n        RTBNAME = ESDARR(I).NAME;\n        RTBOFF  = BIN(ESDARR(I).OFFSET,31);\n        RTBOFF1 = RTBOFF;\n        RTBLEN  = BIN(ESDARR(I).LENGTH,31);\n        SELECT (UNSPEC(BYTE));\n          WHEN (#CSECT) DO;\n             RTBTYPE = 'CSECT';\n          END;\n          WHEN (#ENTRY) DO;\n             RTBTYPE = 'ENTRY';\n             DO J=1 TO DIME;\n                IF (ESDARR(J).ID = ESDARR(I).REF) & (J\u00ac=I) THEN DO;\n                   RTBREF = ESDARR(J).NAME;\n                   RTBLEN = ESDARR(J).LENGTH;\n                END;\n             END;\n          END;\n          OTHER;\n        END;\n        RTBLENB = RTBLEN;\n\n        IF RTBTYPE \u00ac= '' THEN DO;\n           CALL ISPLINK ('TBADD ', TABLE);\n           NROWS = NROWS+1;\n        END;\n     END;\n\n     IF NROWS=0 THEN DO;\n        CALL ISPLINK('SETMSG ', 'REAS072 ');\n        GOTO L_END;\n     END;\n\n L_TBTOP:\n     CALL ISPLINK ('TBTOP   ', TABLE);\n     ROW = 1;\n L_DISPL:\n     IF ROW > 1 THEN DO;\n        CALL ISPLINK ('TBTOP   ', TABLE);\n        CALL ISPLINK ('TBSKIP  ', TABLE, ROW);\n     END;\n     CALL ISPLINK ('TBDISPL ', TABLE, TABLE, ' ', ' ', ROW, F1,\n                   'YES ', ' ', ' ');\n\n     IF PLIRETV() = 0  & RTBCMD \u00ac= '' THEN DO;\n\n        IF SUBSTR(RTBCMD,1,1) = 'L' THEN DO;\n           LOCVAR = SUBSTR(RTBCMD,2);\n           IF LOCVAR\u00ac='' THEN DO;\n              RTBNAME = SUBSTR(LOCVAR,VERIFY(LOCVAR,' '));\n              CALL ISPLINK ('TBTOP   ', TABLE);\n              CALL ISPLINK ('TBSCAN ', TABLE, '(RTBNAME)',\n                           ' ',' ','NEXT ','NOREAD ',\n                           'RTBCRP ', '(GE) ' );\n              IF PLIRETV() = 0 THEN DO;\n                CALL ISPLINK ('TBTOP   ', TABLE);\n                CALL ISPLINK ('TBSKIP ', TABLE, RTBCRP);\n              END;\n           END;\n           GOTO L_DISPL;\n        END;\n\n        SELECT (RTBCMD);\n          WHEN  ('SA', 'S A', 'SORT A', 'SORT ADDR') DO;\n            CALL ISPLINK ('TBSORT ', TABLE, '(RTBOFF1,N)');\n            CALL ISPLINK('SETMSG ','REAS077 ');\n            GOTO L_TBTOP;\n          END;\n          WHEN  ('SN', 'S N', 'SORT N', 'SORT NAME', 'SORT') DO;\n            CALL ISPLINK ('TBSORT ', TABLE, '(RTBNAME,C)');\n            CALL ISPLINK('SETMSG ','REAS078 ');\n            GOTO L_TBTOP;\n          END;\n          WHEN  ('SL', 'S L', 'SORT L', 'SORT LEN') DO;\n            CALL ISPLINK ('TBSORT ', TABLE,\n                          '(RTBLENB,N,D,RTBOFF1,N,A)');\n            CALL ISPLINK('SETMSG ','REAS078 ');\n            GOTO L_TBTOP;\n          END;\n          WHEN (' ')\n            GOTO L_DISPL;\n          OTHER DO;\n            CALL ISPLINK('SETMSG ','REAS075 ');\n            GOTO L_TBTOP;\n          END;\n        END;\n     END;\n\n     IF PLIRETV() < 8 THEN DO;\n        SELECT (C);\n          WHEN ('S','*',':','B') DO;\n            CSECT = RTBNAME;\n            GOTO L_END;\n          END;\n          WHEN (' ')\n            GOTO L_DISPL;\n          OTHER DO;\n            CALL ISPLINK ('TBPUT ', TABLE);\n            CALL ISPLINK('SETMSG ','REAS073 ');\n            GOTO L_DISPL;\n          END;\n        END;\n     END;\n\n L_END:\n     CALL ISPLINK ('TBEND   ', TABLE);\n L_DEL:\n     CALL ISPLINK ('VDELETE ',\n     '(RTBCMD, C, RTBNAME, RTBOFF, RTBLEN, RTBTYPE, RTBREF)');\n     CALL ISPLINK ('VDELETE ',\n     '(RTBCRP, RTBOFF1)' );\n\n     RETURN(CSECT);\n END REASESD;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REASLIB": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x1e\\x01\\x00\\x06\\x00\\x976_\\x01\\x06\\x01?\\x15U\\x00\\x95\\x00\\x94\\x00\\x02\\xd7\\xc7\\xd4\\xe5\\xc3@@@@@'", "ispf": {"version": "30.01", "flags": 0, "createdate": "1997-12-31T00:00:00", "modifydate": "2006-01-13T15:55:06", "lines": 149, "newlines": 148, "modlines": 2, "user": "PGMVC"}, "text": "*PROCESS M,OPT(TIME),S,GN;\n /*\n//PGMVCI JOB 'IBI','V CHERNYAK',REGION=1000K,NOTIFY=PGMVC,CLASS=A,\n//        MSGCLASS=A,MSGLEVEL=(1,1)\n//PROCLIB  JCLLIB ORDER=PGMVYC.REASM.PLI\n//        EXEC PLIXCL,PARM.LKED='LET,NCAL'\n//PLI.SYSIN     DD DSN=PGMVYC.REASM.PLI(REASLIB),DISP=SHR\n//PLI.SYSLIB    DD DSN=PGMVYC.REASM.PLI,DISP=SHR\n//LKED.SYSLMOD  DD DSN=PGMVYC.REASM.SUBLOAD(REASLIB),DISP=SHR\n//\n */\n REASLIB: PROC(DDNAME,MODE,CARD) REORDER RETURNS(BIN FIXED);\n   DCL    DDNAME   CHAR(8),\n          MODE     CHAR(*),\n          CARD     CHAR(*),\n          RC       BIN FIXED INIT(1),\n          ERRMSG   CHAR(8)   INIT(''),\n          MTIME    CHAR(5)   INIT(''),\n          MUSER    CHAR(8)   INIT(''),\n          MDATE    CHAR(8)   INIT(''),\n          MEMBER   CHAR(12)  INIT(''),\n          MEMOUT   CHAR(8)   STATIC INT INIT(''),\n          #C       CHAR(80)  INIT(''),\n          DATAIDV  CHAR(8)   INIT(''),\n          ORG      CHAR(2)   INIT(''),\n          PRJ      CHAR(8)   INIT(''),\n          LIB      CHAR(8)   INIT(''),\n          TYP      CHAR(8)   INIT(''),\n          DSN      CHAR(44)  INIT(''),\n          VOL      CHAR(6)   INIT(''),\n          PSWD     CHAR(8)   INIT(''),\n          YN       CHAR(3)   INIT(''),\n          F2                 INIT(2)  BIN FIXED(31),\n          F3                 INIT(3)  BIN FIXED(31),\n          F5                 INIT(5)  BIN FIXED(31),\n          F6                 INIT(6)  BIN FIXED(31),\n          F8                 INIT(8)  BIN FIXED(31),\n          F12                INIT(12) BIN FIXED(31),\n          F44                INIT(44) BIN FIXED(31),\n          F80                INIT(80) BIN FIXED(31),\n          (CSIZE,ISIZE,MSIZE)INIT(0)  BIN FIXED(31),\n          ISPLINK            ENTRY  EXT OPTIONS(ASM INTER RETCODE),\n          (PLIRETV)          BUILTIN;\n\n\n   CALL ISPLINK ('VDEFINE ', 'DATAIDV ', DATAIDV,  'CHAR ',  F8 );\n   CALL ISPLINK ('VDEFINE ', 'ORG     ', ORG,      'CHAR ',  F2 );\n   CALL ISPLINK ('VDEFINE ', 'PRJ2    ', PRJ,      'CHAR ',  F8 );\n   CALL ISPLINK ('VDEFINE ', 'LIB2    ', LIB,      'CHAR ',  F8 );\n   CALL ISPLINK ('VDEFINE ', 'TYP2    ', TYP,      'CHAR ',  F8 );\n   CALL ISPLINK ('VDEFINE ', 'MEM2    ', MEMOUT,   'CHAR ',  F8 );\n   CALL ISPLINK ('VDEFINE ', 'DSN2    ', DSN,      'CHAR ',  F44);\n   CALL ISPLINK ('VDEFINE ', 'VOL2    ', VOL,      'CHAR ',  F6 );\n   CALL ISPLINK ('VDEFINE ', 'PSWD2   ', PSWD,     'CHAR ',  F8 );\n   CALL ISPLINK ('VDEFINE ', 'YN2     ', YN,       'CHAR ',  F3 );\n   CALL ISPLINK ('VDEFINE ', '#C      ', #C,       'CHAR ',  F80);\n\n   SELECT (MODE);\n     WHEN ('OPEN') DO;\n        MEMOUT = CARD;\n L_DISPL:\n        CALL ISPLINK ('DISPLAY ', 'REASM05 ');\n        RC = PLIRETV();\n        IF RC \u00ac= 0 THEN GOTO L_RET;\n        CALL ISPLINK ('LMINIT ', 'DATAIDV ', PRJ, LIB, ' ', ' ',\n                      ' ', TYP, DSN, ' ', VOL, PSWD,\n                      'EXCLU ', 'ORG ');\n        DDNAME = DATAIDV;\n        RC = PLIRETV();\n        IF RC\u00ac=0 THEN DO;\n           CALL ISPLINK('VCOPY  ', 'ZERRMSG ', F8, ERRMSG, 'MOVE ');\n           CALL ISPLINK('SETMSG ', ERRMSG);\n           GOTO L_DISPL;\n        END;\n        IF ORG \u00ac= 'PO'  &  ORG \u00ac= 'POU' THEN DO;\n           CALL ISPLINK('SETMSG ', 'REAS065 ');\n           GOTO L_DISPL;\n        END;\n\n        CALL ISPLINK ('LMOPEN ', DDNAME, 'OUTPUT ');\n        RC = PLIRETV();\n\n        IF RC=0 THEN DO;\n           IF MEMOUT='*' | MEMOUT=':' | MEMOUT=' ' THEN DO;\n              CALL ISPLINK ('LMMDISP ', DDNAME, 'DISPLAY ', ' ');\n              RC = PLIRETV();\n              CALL ISPLINK ('LMMDISP ', DDNAME, 'FREE ');\n              IF RC=0 THEN DO;\n                 CALL ISPLINK ('VCOPY ','ZLMEMBER ',F12,MEMBER,'MOVE ');\n                 MEMOUT = MEMBER;\n L_RETRY:        CALL ISPLINK ('LMCLOSE ', DDNAME);\n                 CALL ISPLINK ('LMFREE  ', DDNAME);\n                 GOTO L_DISPL;\n              END;\n           END;\n           ELSE DO;\n              IF YN = 'NO' THEN DO;        /* DO NOT REPLACE MEMBER */\n                 CALL ISPLINK ('LMCLOSE ', DDNAME);\n                 CALL ISPLINK ('LMOPEN  ', DDNAME, 'INPUT  ');\n                 CALL ISPLINK ('LMMFIND ', DDNAME, MEMOUT);\n                 IF PLIRETV()=0 THEN DO;  /* MEMBER EXISTS YET     */\n                    CALL ISPLINK('SETMSG ', 'REAS048 ');\n                    GOTO L_RETRY;\n                 END;\n                 CALL ISPLINK ('LMCLOSE ', DDNAME);\n                 CALL ISPLINK ('LMOPEN  ', DDNAME, 'OUTPUT ');\n              END;\n           END;\n        END;\n        CSIZE,ISIZE,MSIZE = 0;\n        CARD = MEMOUT;\n     END;\n\n     WHEN ('CLOSE') DO;\n L_CLOSE:\n        CALL ISPLINK ('LMMREP  ', DDNAME, MEMOUT, 'YES ');\n        CALL ISPLINK ('LMCLOSE ', DDNAME);\n\n        CALL ISPLINK ('LMOPEN  ', DDNAME, 'INPUT  ');\n        CALL ISPLINK ('VCOPY ', 'ZTIME ', F5, MTIME, 'MOVE ');\n        CALL ISPLINK ('VCOPY ', 'ZDATE ', F8, MDATE, 'MOVE ');\n        CALL ISPLINK ('VCOPY ', 'ZUSER ', F8, MUSER, 'MOVE ');\n        CALL ISPLINK ('LMMSTATS', DDNAME, MEMOUT, ' ', ' ',\n                      MDATE, MDATE, MTIME, CSIZE, ISIZE, MSIZE, MUSER);\n        CALL ISPLINK ('LMCLOSE ', DDNAME);\n        CALL ISPLINK ('LMFREE  ', DDNAME);\n\n        CALL ISPLINK('SETMSG ', 'REAS005 ');\n        RC = 0;\n     END;\n\n     WHEN ('WRITE') DO;\n        #C = CARD;\n        CALL ISPLINK ('LMPUT ', DDNAME, 'INVAR ', '#C ', F80, MEMOUT,\n                      'NOBSCAN ', ' ', ' ', 'YES');\n        RC = PLIRETV();\n        IF RC \u00ac= 0 THEN GOTO L_CLOSE;\n        ISIZE = ISIZE+1;\n        CSIZE = CSIZE+1;\n     END;\n   END;\n\n L_RET:\n   CALL ISPLINK ('VDELETE ',\n   '(DATAIDV,ORG,PRJ2,LIB2,TYP2,DSN2,VOL2,PSWD2,MEM2,YN2,#C)');\n\n   RETURN (RC);\n\n END REASLIB;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REASLOA": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x1e\\x08\\x009\\x00\\x976_\\x01\\x06\\x01\\x7f\\x15\\x02\\x00\\xbf\\x00\\xb8\\x00\\x0b\\xd7\\xc7\\xd4\\xe5\\xc3@@@@@'", "ispf": {"version": "30.08", "flags": 0, "createdate": "1997-12-31T00:00:00", "modifydate": "2006-01-17T15:02:39", "lines": 191, "newlines": 184, "modlines": 11, "user": "PGMVC"}, "text": "*PROCESS M,OPT(TIME),S,GN;\n /*\n//PGMVCI JOB 'IBI','V CHERNYAK',REGION=1M,NOTIFY=PGMVC,CLASS=0,\n//        MSGCLASS=A,MSGLEVEL=(1,1)\n//PROCLIB  JCLLIB ORDER=PGMVYC.REASM.PLI\n//        EXEC PLIXCL,PARM.LKED='LET,NCAL'\n//PLI.SYSIN     DD DSN=PGMVYC.REASM.PLI(REASLOA),DISP=SHR\n//PLI.SYSLIB    DD DSN=PGMVYC.REASM.PLI,DISP=SHR\n//LKED.SYSLMOD  DD DSN=PGMVYC.REASM.SUBLOAD(REASLOA),DISP=SHR\n//\n */\n REASLOA: PROC(MODE,DSNAME,VOLUME,MEMBER,CSECT,BLOCK)\n              REORDER RETURNS(BIN FIXED);\n   DCL    MODE     CHAR(*),\n          DSNAME   CHAR(*),\n          VOLUME   CHAR(*),\n          MEMBER   CHAR(*),\n          CSECT    CHAR(*),\n          BLOCK    CHAR(*),\n          LOCVAR   CHAR(128)     VAR,\n          RC       BIN FIXED     INIT(1),\n          ZMEM     CHAR(80)      INIT(''),\n          ERRMSG   CHAR(8)       INIT(''),\n          INBLK    CHAR(32767),\n          MEMLOOP  BIT(1)        INIT('0'B) STATIC INT,\n          PREVMEM  CHAR(8)       INIT('')   STATIC INT,\n          PREVDD   CHAR(8)       INIT('')   STATIC INT,\n\n          DDNAME   CHAR(8)   INIT('') STATIC INT,\n          ORG      CHAR(2)   INIT(''),\n          RECFM    CHAR(8)   INIT(''),\n          PRJ      CHAR(8)   INIT(''),\n          LIB      CHAR(8)   INIT(''),\n          TYP      CHAR(8)   INIT(''),\n          MEM      CHAR(8)   INIT(''),\n          CSE      CHAR(8)   INIT(''),\n          DSN      CHAR(44)  INIT(''),\n          VOL      CHAR(6)   INIT(''),\n          PSWD     CHAR(8)   INIT(''),\n          ZZCMD1   CHAR(60)  INIT(''),\n          LEN      CHAR(8)   INIT(''),\n          F2                 INIT(2)  BIN FIXED(31),\n          F3                 INIT(3)  BIN FIXED(31),\n          F5                 INIT(5)  BIN FIXED(31),\n          F6                 INIT(6)  BIN FIXED(31),\n          F8                 INIT(8)  BIN FIXED(31),\n          F12                INIT(12) BIN FIXED(31),\n          F44                INIT(44) BIN FIXED(31),\n          F60                INIT(60) BIN FIXED(31),\n          F80                INIT(80) BIN FIXED(31),\n          F32767          INIT(32767) BIN FIXED(31),\n          $NEXTEL        EXT ENTRY(CHAR(*) VAR) RETURNS(CHAR(100) VAR),\n          ISPLINK            ENTRY  EXT OPTIONS(ASM INTER RETCODE),\n          (PLIRETV,SUBSTR,LENGTH)   BUILTIN;\n\n   CALL ISPLINK ('VDEFINE ', 'DD      ', DDNAME,   'CHAR ',  F8 );\n   CALL ISPLINK ('VDEFINE ', 'ORG     ', ORG,      'CHAR ',  F2 );\n   CALL ISPLINK ('VDEFINE ', 'RECFM   ', RECFM,    'CHAR ',  F8 );\n   CALL ISPLINK ('VDEFINE ', 'PRJ1    ', PRJ,      'CHAR ',  F8 );\n   CALL ISPLINK ('VDEFINE ', 'LIB1    ', LIB,      'CHAR ',  F8 );\n   CALL ISPLINK ('VDEFINE ', 'TYP1    ', TYP,      'CHAR ',  F8 );\n   CALL ISPLINK ('VDEFINE ', 'MEM     ', MEM,      'CHAR ',  F8 );\n   CALL ISPLINK ('VDEFINE ', 'CSECT   ', CSE,      'CHAR ',  F8 );\n   CALL ISPLINK ('VDEFINE ', 'DSN     ', DSN,      'CHAR ',  F44);\n   CALL ISPLINK ('VDEFINE ', 'VOL     ', VOL,      'CHAR ',  F6 );\n   CALL ISPLINK ('VDEFINE ', 'PSWD    ', PSWD,     'CHAR ',  F8 );\n   CALL ISPLINK ('VDEFINE ', 'ZZCMD1  ', ZZCMD1,   'CHAR ',  F60);\n   CALL ISPLINK ('VDEFINE ', 'INBLK   ', INBLK,    'CHAR ',  F32767);\n   CALL ISPLINK ('VDEFINE ', 'LEN     ', LEN,      'CHAR ',  F8 );\n\n   SELECT (MODE);\n     /************************************/\n     /*  A L L O C A T E     DATA SET    */\n     /************************************/\n     WHEN ('ALLOC') DO;\n L_DISP:IF MEMLOOP THEN DO;\n           MEMBER = PREVMEM;\n           DDNAME = PREVDD;\n           CALL ISPLINK ('LMCLOSE ', DDNAME);\n           RC = 0;\n        END;\n        ELSE DO;\n          CALL ISPLINK ('DISPLAY ', 'REASM01 ', ' ');\n          RC = PLIRETV();\n          IF DDNAME \u00ac= '' THEN DO;\n             CALL ISPLINK ('LMFREE  ', DDNAME);\n             DDNAME = '';\n          END;\n          CSECT = CSE;\n          IF RC\u00ac=0  |  ZZCMD1='R' THEN GOTO L_RET;  /* RECOVERY/END */\n          CALL ISPLINK ('LMINIT ', 'DD ', PRJ, LIB, ' ', ' ',\n                        ' ', TYP, DSN, ' ', VOL, PSWD,\n                        'SHR ', 'ORG ');\n          RC = PLIRETV();\n          IF RC\u00ac=0 THEN DO;\n             CALL ISPLINK('VCOPY  ', 'ZERRMSG ', F8, ERRMSG, 'MOVE ');\n             CALL ISPLINK('SETMSG ', ERRMSG);\n             GOTO L_DISP;\n          END;\n          IF ORG \u00ac= 'PO' & ORG \u00ac= 'POU'  THEN DO;\n             CALL ISPLINK('SETMSG ','REAS065 ');\n             GOTO L_DISP;\n          END;\n        END;\n\n        CALL ISPLINK ('LMOPEN ', DDNAME, 'INPUT ', ' ', 'RECFM ' );\n        IF RECFM \u00ac= 'U' & RECFM \u00ac= 'UT' THEN DO;\n           CALL ISPLINK ('LMCLOSE ', DDNAME);\n           CALL ISPLINK('SETMSG ','REAS066 ');\n           GOTO L_DISP;\n        END;\n        IF MEM=':' | MEM=' ' | INDEX(MEM,'*') THEN DO;\n           IF MEM=':' THEN MEM='*';\n           MEMLOOP = '1'B;\n           PREVMEM = MEMBER;\n           PREVDD  = DDNAME;\n           CALL ISPLINK ('LMMDISP ', DDNAME, 'DISPLAY ', MEM);\n           RC = PLIRETV();\n           IF RC\u00ac=0 THEN DO;\n              CALL ISPLINK ('LMMDISP ', DDNAME, 'FREE ');\n              CALL ISPLINK ('LMCLOSE ', DDNAME);\n              MEMLOOP = '0'B;\n              GOTO L_DISP;\n           END;\n           ELSE DO;\n              CALL ISPLINK ('VCOPY ','ZLMEMBER ', F80, ZMEM,'MOVE ');\n              MEM = ZMEM;\n              CALL ISPLINK ('VPUT ', '(MEM)', 'PROFILE ');\n              CALL ISPLINK ('VPUT ', '(MEM)', 'ASIS ');\n              CALL ISPLINK ('LMMDISP ', DDNAME, 'FREE ');\n           END;\n        END;\n        CALL ISPLINK ('LMMFIND ', DDNAME, MEM,\n                      ' ', ' ', ' ', ' ', 'YES');\n        RC = PLIRETV();\n        CALL ISPLINK ('LMCLOSE ', DDNAME);\n        IF RC \u00ac= 0 THEN DO;\n           CALL ISPLINK ('SETMSG ', 'REAS059 ');\n           GOTO L_DISP;\n        END;\n\n        DSNAME = DSN;\n        IF DSNAME = '' THEN\n           DSNAME = $NEXTEL(PRJ) || '.' ||\n                    $NEXTEL(LIB) || '.' ||\n                    $NEXTEL(TYP);\n        ELSE DO;\n           LOCVAR = $NEXTEL(DSN);\n           IF (SUBSTR(LOCVAR,1,1) = '''') THEN\n              LOCVAR = SUBSTR(LOCVAR,2);\n           IF (SUBSTR(LOCVAR,LENGTH(LOCVAR),1) = '''') THEN\n              LOCVAR = SUBSTR(LOCVAR,1,LENGTH(LOCVAR)-1);\n           DSNAME = LOCVAR;\n        END;\n\n        VOLUME = VOL;\n        MEMBER = MEM;\n        CSECT  = CSE;\n     END;\n\n     WHEN ('OPEN') DO;\n        CALL ISPLINK ('LMOPEN  ', DDNAME, 'INPUT ');\n        CALL ISPLINK ('VGET ', '(MEM)' );\n        CALL ISPLINK ('LMMFIND ', DDNAME, MEM,\n                      ' ', ' ', ' ', ' ', 'YES');\n        RC = PLIRETV();\n     END;\n\n     WHEN ('CLOSE') DO;\n        CALL ISPLINK ('LMCLOSE ', DDNAME);\n        RC = 0;\n     END;\n\n     WHEN ('READ') DO;\n       CALL ISPLINK ('LMGET ',DDNAME,'INVAR ','INBLK ','LEN ',F32767);\n       RC = PLIRETV();\n       BLOCK = INBLK;\n       IF RC\u00ac= 0 THEN\n          CALL ISPLINK ('LMCLOSE ', DDNAME);\n     END;\n\n   END;\n\n L_RET:\n   CALL ISPLINK ('VDELETE ',\n   '(DD,ORG,RECFM,PRJ1,LIB1,TYP1,MEM,CSECT,DSN,VOL,PSWD,ZZCMD1,\n     INBLK,LEN)');\n\n   RETURN (RC);\n\n END REASLOA;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REASLST": {"ttr": 777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x1e\\x01\\x00!\\x00\\x976_\\x01\\x06\\x01?\\x15V\\x003\\x003\\x00\\x02\\xd7\\xc7\\xd4\\xe5\\xc3@@@@@'", "ispf": {"version": "30.01", "flags": 0, "createdate": "1997-12-31T00:00:00", "modifydate": "2006-01-13T15:56:21", "lines": 51, "newlines": 51, "modlines": 2, "user": "PGMVC"}, "text": "*PROCESS M,OPT(TIME),S,GN;\n /*\n//PGMVCI JOB 'IBI','V CHERNYAK',REGION=2M,NOTIFY=PGMVC,CLASS=A,\n//        MSGCLASS=A,MSGLEVEL=(1,1)\n//PROCLIB  JCLLIB ORDER=PGMVYC.REASM.PLI\n//        EXEC PLIXCL,PARM.LKED='LET,NCAL'\n//PLI.SYSIN     DD DSN=PGMVYC.REASM.PLI(REASLST),DISP=SHR\n//PLI.SYSLIB    DD DSN=PGMVYC.REASM.PLI,DISP=SHR\n//LKED.SYSLMOD  DD DSN=PGMVYC.REASM.SUBLOAD(REASLST),DISP=SHR\n//\n */\n REASLST: PROC REORDER;\n   DCL    SYSPRINT  PRINT,\n          SYS       FILE INPUT RECORD,\n          LINE      CHAR(200) VAR,\n          F120      BIN FIXED(31) INIT(120),\n          ISPLINK   EXT ENTRY OPTIONS(ASM INTER RETCODE),\n          $TR       BIT(1) INIT('0'B),\n          STRING    CHAR(120) INIT('');\n\n   CALL ISPLINK ('VDEFINE ', 'STRING ', STRING, 'CHAR ', F120 );\n\n   CLOSE FILE(SYSPRINT);\n\n   ON TRANSMIT(SYS) BEGIN;\n      ON TRANSMIT(SYS) SYSTEM;\n      $TR = '1'B; GOTO L_ESYS;\n   END;\n\n   ON ENDFILE(SYS) GOTO L_ESYS;\n   OPEN  FILE(SYS) TITLE('REAPRINT');\n   DO WHILE('1'B);\n      READ FILE(SYS) INTO(LINE);\n      STRING = LINE;\n      IF STRING\u00ac='' THEN\n         CALL ISPLINK ('LIST ', 'STRING ', F120, ' ', ' ', ' ', 'CC ');\n   END;\n\n L_ESYS:\n   CLOSE FILE(SYS);\n   CALL ISPLINK ('VDELETE ', 'STRING  ');\n\n   /*\n   IF $TR THEN CALL ISPLINK ('SETMSG  ', 'REAS064 ');\n   ELSE        CALL ISPLINK ('SETMSG  ', 'REAS079 ');\n   */\n\n   CLOSE FILE(SYSPRINT);\n   OPEN FILE(SYSPRINT) TITLE('REAPRINT') PRINT;\n\n END REASLST;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REASM$": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x1e\\x00\\x007\\x00\\x976_\\x00\\x976_\\x00I\\x00\\xdf\\x00\\xdf\\x00\\x00\\xd7\\xc7\\xd4\\xe5\\xe8\\xc3@@@@'", "ispf": {"version": "30.00", "flags": 0, "createdate": "1997-12-31T00:00:00", "modifydate": "1997-12-31T00:49:37", "lines": 223, "newlines": 223, "modlines": 0, "user": "PGMVYC"}, "text": " REASM$:\n    PROC;\n DCL  ID(100) BIN FIXED(31),\n      II(2)   BIN FIXED(31),\n      #0      CHAR(1) INIT('0') STATIC INT,\n      #1      CHAR(1) INIT('1') STATIC INT,\n      #2      CHAR(1) INIT('2') STATIC INT,\n      #3      CHAR(1) INIT('3') STATIC INT,\n      #4      CHAR(1) INIT('4') STATIC INT,\n      #5      CHAR(1) INIT('5') STATIC INT,\n      #6      CHAR(1) INIT('6') STATIC INT,\n      #7      CHAR(1) INIT('7') STATIC INT,\n      #8      CHAR(1) INIT('8') STATIC INT,\n      #9      CHAR(1) INIT('9') STATIC INT,\n      #A      CHAR(1) INIT('A') STATIC INT,\n      #B      CHAR(1) INIT('B') STATIC INT,\n      #C      CHAR(1) INIT('C') STATIC INT,\n      #D      CHAR(1) INIT('D') STATIC INT,\n      #E      CHAR(1) INIT('E') STATIC INT,\n      #F      CHAR(1) INIT('F') STATIC INT,\n      C       BIN FIXED INIT(16),\n      C1      BIN FIXED INIT(16);\n\n II(1)=$HBF\n           (#D||#7||#F||#F||#0||#0||#0||#0);\n II(2)=$HBF\n           (#0||#0||#0||#1||#0||#0||#0||#0);\n\n ID=0;\n\n ID(1)= $HBF                           /* BHUUJA        1046  */\n            (#0||#2||#6||#8||#8||#2);\n ID(2)= $HBF                           /* BHUUJA        1046  */\n            (#0||#2||#7||#8||#8||#2);\n ID(3)= $HBF                           /* GOLBDBEPG     1035  */\n            (#2||#9||#2||#8||#8||#0);\n ID(4)= $HBF                           /* ABEPBUX       1046  */\n            (#0||#5||#8||#8||#4||#0);\n ID(5)= $HBF                           /* ABEPBUX       1046  */\n            (#0||#3||#1||#8||#6||#0);\n ID(6)= $HBF                           /* BEPE3KUH      1045  */\n            (#1||#0||#3||#8||#4||#0);\n ID(7)= $HBF                           /* BEPE3KUH      1055M */\n            (#1||#0||#0||#1||#7||#4);\n ID(8)= $HBF                           /* BUHU4         1055M */\n            (#1||#0||#0||#C||#3||#3);\n ID(9)= $HBF                           /* PUDAKOB       1045  */\n            (#2||#4||#7||#8||#4||#0);\n ID(10)=$HBF                           /* LUBMAH        1036  */\n            (#0||#0||#1||#3||#7||#4);\n ID(11)=$HBF                           /* LUBMAH        1036  */\n            (#2||#2||#4||#8||#8||#0);\n ID(12)=$HBF                           /* OMCK          1036  */\n            (#0||#4||#4||#8||#6||#0);\n ID(13)=$HBF                           /* KOBALEB       1045  */\n            (#0||#4||#5||#8||#6||#0);\n ID(14)=$HBF                           /* KOBALEB       1045  */\n            (#0||#8||#6||#8||#7||#0);\n ID(15)=$HBF                           /* LEBAWOB       1045  */\n            (#0||#5||#1||#8||#6||#0);\n ID(16)=$HBF                           /* LEBAWOB       1045  */\n            (#2||#4||#7||#8||#5||#0);\n ID(17)=$HBF                           /* 3ABEJUHCKUY   1045  */\n            (#0||#1||#2||#8||#1||#0);\n ID(18)=$HBF                           /* KA3BTU        1046  */\n            (#1||#0||#0||#C||#3||#F);\n ID(19)=$HBF                           /* CUMOH H.      1036  */\n            (#0||#0||#0||#1||#5||#0);\n ID(20)=$HBF                           /* ZUPLUH        1045  */\n            (#5||#0||#0||#1||#8||#D);\n ID(21)=$HBF                           /* DEJUT         1060  */\n            (#0||#5||#0||#8||#6||#0);\n ID(22)=$HBF                           /* JOPHUZKUY     1066  */\n            (#0||#0||#8||#1||#0||#4);\n ID(23)=$HBF                           /* JOPHUZKUY     1066  */\n            (#0||#0||#8||#1||#0||#5);\n ID(24)=$HBF                           /* PLUJHUKOB     1045  */\n            (#0||#0||#0||#0||#0||#0);\n ID(25)=$HBF                           /* PLUJHUKOB     1045  */\n            (#0||#0||#0||#0||#0||#0);\n ID(26)=$HBF                           /* JOPHUZKUY     1045  */\n            (#0||#4||#7||#8||#3||#0);\n ID(27)=$HBF                           /* JOPHUZKUY     1045  */\n            (#5||#0||#0||#1||#E||#5);\n ID(28)=$HBF                           /* BEPE3KUH      1061  */\n            (#0||#0||#0||#1||#5||#C);\n ID(29)=$HBF                           /* JOPHUZKUY     1045  */\n            (#2||#7||#2||#8||#5||#0);\n ID(30)=$HBF                           /* JOPHUZKUY       1045  */\n            (#2||#7||#3||#8||#5||#0);\n ID(31)=$HBF                           /* JOPHUZKUY       1045  */\n            (#1||#0||#9||#8||#7||#0);\n ID(32)=$HBF                           /* JOPHUZKUY       1045  */\n            (#1||#1||#0||#8||#7||#0);\n ID(33)=$HBF                           /* GPUDHEB         1055M */\n            (#1||#0||#0||#C||#0||#9);\n ID(34)=$HBF                           /* BOPOBEY         1045  */\n            (#0||#0||#8||#8||#3||#0);\n ID(35)=$HBF                           /* BOPOBEY         1045  */\n            (#0||#9||#8||#8||#3||#0);\n ID(36)=$HBF                           /* BOPOBEY         1045  */\n            (#0||#9||#9||#8||#3||#0);\n ID(37)=$HBF                           /* BOPOBEY         1045  */\n            (#0||#2||#6||#8||#7||#0);\n ID(38)=$HBF                           /* 3ACLABCKUY      1045  */\n            (#1||#3||#2||#8||#3||#0);\n ID(39)=$HBF                           /* LOBAHOB         1045  */\n            (#1||#1||#1||#8||#4||#0);\n ID(40)=$HBF                           /* CELINOGRAD      1045  */\n            (#0||#6||#0||#8||#3||#0);\n ID(41)=$HBF                           /* CELINOGRAD      1045  */\n            (#0||#8||#0||#8||#3||#0);\n ID(42)=$HBF                           /* CELINOGRAD      1060  */\n            (#0||#0||#0||#0||#6||#F);\n ID(43)=$HBF                           /* CELINOGRAD      1060  */\n            (#0||#0||#0||#0||#7||#0);\n ID(44)=$HBF                           /* OB4UHHUKOB      1036  */\n            (#0||#0||#0||#4||#1||#0);\n ID(45)=$HBF                           /* OB4UHHUKOB      1035  */\n            (#0||#0||#1||#0||#8||#0);\n ID(46)=$HBF                           /* BOBK            1035  */\n            (#1||#0||#0||#0||#A||#3);\n ID(47)=$HBF                           /* GPUDHEB         1055  */\n            (#1||#0||#0||#0||#C||#C);\n ID(48)=$HBF                           /* GPUDHEB         1055  */\n            (#1||#0||#0||#1||#3||#5);\n ID(49)=$HBF                           /* GPUDHEB         1055  */\n            (#1||#0||#0||#1||#A||#6);\n ID(50)=$HBF                           /* BOLOTOB         1035  */\n            (#0||#0||#0||#6||#7||#7);\n ID(51)=$HBF                           /* BOLOTOB         1045  */\n            (#2||#8||#0||#8||#6||#0);\n ID(52)=$HBF                           /* JBAHHUKOB       1035  */\n           (#0||#0||#0||#2||#1||#3);\n ID(53)=$HBF                           /* JBAHHUKOB       1035  */\n           (#0||#0||#1||#1||#5||#1);\n ID(54)=$HBF                           /* JBAHHUKOB       1035  */\n            (#0||#0||#1||#1||#5||#2);\n ID(55)=$HBF                           /* FPUDMAH         1045  */\n            (#0||#6||#9||#8||#6||#0);\n ID(56)=$HBF                           /* FPUDMAH         1045  */\n            (#0||#7||#0||#8||#6||#0);\n ID(57)=$HBF                           /* PAPWUXUH        1035  */\n            (#0||#0||#0||#3||#7||#5);\n ID(58)=$HBF                           /* GEPMAHOBU4      1035  */\n            (#0||#0||#0||#9||#3||#9);\n ID(59)=$HBF                           /* GEPMAHOBU4      1046  */\n            (#1||#7||#7||#8||#8||#0);\n ID(60)=$HBF                           /* WHEEPOB         1035  */\n            (#0||#0||#1||#6||#2||#9);\n ID(61)=$HBF                           /* WHEEPOB         1035  */\n            (#0||#0||#1||#3||#9||#0);\n ID(62)=$HBF                           /* WHEEPOB         1035  */\n            (#0||#0||#0||#0||#2||#8);\n ID(63)=$HBF                           /* VIATICH         1046  */\n            (#5||#0||#0||#0||#D||#A);\n ID(65)=$HBF                           /* VIATICH         1046  */\n            (#5||#0||#0||#0||#F||#A);\n ID(66)=$HBF                           /* VIATICH         1045  */\n            (#5||#0||#0||#1||#F||#3);\n ID(67)=$HBF                           /* VIATICH         1046  */\n            (#0||#0||#6||#5||#1||#0);\n\n ID(68)=$HBF                           /* JBAHHUKOB       1046  */\n            (#1||#0||#5||#8||#8||#0);\n ID(69)=$HBF                           /* EXPRESS         1037  */\n            (#0||#0||#0||#1||#1||#5);\n ID(70)=$HBF                           /* KOHOBALOB       1055  */\n            (#1||#0||#0||#1||#3||#C);\n ID(71)=$HBF                           /* KOHOBALOB       1055  */\n            (#1||#0||#0||#0||#6||#5);\n ID(72)=$HBF                           /* MOCUH       1045  */\n            (#0||#7||#9||#8||#8||#0);\n ID(73)=$HBF                           /* MOCUH       1035  */\n            (#0||#0||#1||#8||#7||#7);\n ID(74)=$HBF                           /* MOCUH       1035  */\n            (#0||#0||#0||#0||#1||#8);\n ID(75)=$HBF                           /* MOCUH       1035  */\n            (#0||#0||#0||#5||#0||#7);\n ID(76)=$HBF                           /* MOCUH       1035  */\n            (#0||#0||#1||#7||#2||#9);\n ID(77)=$HBF                           /* DAPDBIK         1046  */\n            (#1||#8||#1||#8||#8||#0);\n ID(78)=$HBF                           /* DAPDBIK         1046  */\n            (#1||#8||#2||#8||#8||#0);\n\n ID(79)=$HBF                           /* DABUDUK         1061  */\n            (#5||#0||#0||#0||#9||#E);\n ID(80)=$HBF                           /* DABUDUK         1061  */\n            (#5||#0||#0||#0||#3||#8);\n ID(81)=$HBF                           /* DABUDUK         1046  */\n            (#3||#1||#5||#8||#8||#0);\n ID(82)=$HBF                           /* DABUDUK         1046  */\n            (#1||#9||#4||#8||#7||#0);\n ID(83)=$HBF                           /* DABUDUK         1046  */\n            (#1||#7||#3||#8||#7||#0);\n ID(84)=$HBF                           /* DABUDUK         1036  */\n            (#0||#0||#1||#1||#6||#3);\n\n /* CALL REASM$$(ID(1),C,C1,II(1));\n\n IF C\u00ac=16 THEN\n    CALL REASM$$(ID(1),C,C1,II(1)); */\n\n $HBF:\n     PROC(HEX) RETURNS(BIN FIXED(31));\n     DCL    HEX     CHAR(*) VAR,\n            ALFA    CHAR(16) STATIC INT INIT('0123456789ABCDEF'),\n            (I,L)   BIN FIXED,\n         1  BIT_STR,\n          2 RSRV    BIT(16),\n          2 BIT16   BIT(16),\n            J       BIN FIXED(31) DEF BIT_STR;\n      L=LENGTH(HEX);\n      J=0;\n      DO I=L TO 1 BY -1;\n         K=INDEX(ALFA,SUBSTR(HEX,I,1));\n         IF K=0 THEN RETURN(-1);\n         J=J+(K-1)*(16**(L-I));\n      END;\n      RETURN (J);\n END $HBF;\n END REASM$;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REASMBAS": {"ttr": 1027, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x1e\\x01\\x00P\\x00\\x976_\\x01\\x06\\x01\\x7f\\x02\\x03\\x00R\\x00R\\x00\\x01\\xd7\\xc7\\xd4\\xe5\\xc3@@@@@'", "ispf": {"version": "30.01", "flags": 0, "createdate": "1997-12-31T00:00:00", "modifydate": "2006-01-17T02:03:50", "lines": 82, "newlines": 82, "modlines": 1, "user": "PGMVC"}, "text": " DCL 1   RLD     BASED(RLD_PTR),\n      2  LENGTH        BIN FIXED,\n      2  TYPE          CHAR(1),\n      2  SUBT          BIT(1) ALIGNED,\n      2  NAME          CHAR(8),\n      2  OFF           BIN FIXED(31),\n      2  NEXT          PTR,\n         RLD_PTR       PTR,\n\n     1   USING   BASED(USING_PTR) UNALIGNED,\n      2  OFF           BIN FIXED(31),\n      2  PLACE         BIN FIXED(31),\n      2  LENGTH        BIN FIXED(31),\n      2  NAME          CHAR(9),\n      2  NEXT          PTR,\n      2  REG           BIN FIXED,\n      2  FIX           BIT(1) ALIGNED,\n         USING_PTR     PTR,\n\n     1   QUALIFY BASED(QUALIFY_PTR) UNALIGNED,\n      2  OFF           BIN FIXED(31),\n      2  NEXT          PTR,\n      2  NAME          CHAR(8),\n      2  DESC          CHAR(50),\n         QUALIFY_PTR   PTR,\n\n     1   DSC     BASED(DSC_PTR) ALIGNED,\n      2  NAME          CHAR(8),\n      2  OFF           BIN FIXED(31),\n      2  LENGTH        BIN FIXED(31),\n      2  NEXT          PTR,\n      2  TYPE          CHAR(1),\n      2  SUBT          ALIGNED BIT(1),\n      2  NORED         ALIGNED BIT(1),\n      2  NEW           ALIGNED BIT(1),\n      2  FIX           ALIGNED BIT(1),\n      2  EXTRN         ALIGNED BIT(1),\n         DSC_PTR       PTR,\n\n     1   LABL    BASED(LABL_PTR) UNALIGNED,\n      2  NEXT          PTR,\n      2  NAME          CHAR(8),\n      2  OFF           BIN FIXED(31),\n      2  NORED         ALIGNED BIT(1),\n      2  FIX           ALIGNED BIT(1),\n      2  BLINK         ALIGNED BIT(1),\n      2  REG           BIN FIXED,\n         LABL_PTR      PTR,\n\n     1   XREF    BASED(XREF_PTR),\n      2  NAME          CHAR(16),\n      2  NEXT          PTR,\n      2  CONT          PTR,\n      2  STMT(20)      BIN FIXED,\n      2  ISTMT         BIN FIXED,\n         XREF_PTR      PTR,\n\n     1   LBLOCK  BASED(LBLOCK_PTR),\n      2  NAME          CHAR(9),\n      2  ADR           BIN FIXED(31),\n      2  NEXT          PTR,\n      2  ADUMMY        PTR,\n      2  MACRO         CHAR(60),\n         LBLOCK_PTR    PTR,\n\n     1   DUMMY   BASED(DUMMY_PTR),\n      2  OFF           BIN FIXED(31),\n      2  NAME          CHAR(8),              /* USER-SUPPLIED NAME */\n      2  NEXT          PTR,\n         DUMMY_PTR     PTR,\n\n     1   ORG     BASED(ORG_PTR),\n      2  OFF           BIN FIXED(31),\n      2  LENGTH        BIN FIXED(31),\n      2  NEXT          PTR,\n         ORG_PTR       PTR,\n\n     1   COM     BASED(COM_PTR),\n      2  OFF           BIN FIXED(31),\n      2  TXT           CHAR(30),\n      2  NEXT          PTR,\n         COM_PTR       PTR;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REASMCM": {"ttr": 1030, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x1e\\x00\\x00\\x00\\x00\\x976_\\x00\\x976_\\x00I\\x002\\x002\\x00\\x00\\xd7\\xc7\\xd4\\xe5\\xe8\\xc3\\xf2@@@'", "ispf": {"version": "30.00", "flags": 0, "createdate": "1997-12-31T00:00:00", "modifydate": "1997-12-31T00:49:00", "lines": 50, "newlines": 50, "modlines": 0, "user": "PGMVYC2"}, "text": "*PROCESS M,OPT(TIME);\n /*\n//PGMVYCI JOB 'IBI','V CHERNYAK',REGION=1000K,NOTIFY=PGMVYC,CLASS=A,\n//        MSGCLASS=A,MSGLEVEL=(1,1),USER=PGMVYC,PASSWORD=CH\n//        EXEC PLIXCL,PARM.LKED='LET,NCAL'\n/*ROUTE PRINT IBIVM.PGMVYC\n//PLI.SYSIN     DD DSN=PGMVYC.REASM.PLI(REASMCM),DISP=SHR\n//PLI.SYSLIB    DD DSN=PGMVYC.REASM.PLI,DISP=SHR\n//LKED.SYSLMOD  DD DSN=PGMVYC.REASM.SUBLOAD(REASMCM),DISP=SHR\n//\n */\n /* REASMCM: SUBROUTINE TO TEST COMMAND FOR SOME CONDITION.\n             'BRANCH' - TEST IF COMMAND IS BRANCH-CLASS COMMAND\n             'USING'  - TEST IF COMMAND IS USING/DROP TYPE\n             'PRIV'   - TEST IF IT'S PRIVATE COMMAND\n    EXAMPLE OF USE:\n    IF REASMCM(@, OPER, 'PRIV') THEN ...\n */\n REASMCM:\n   PROC(@, CMD, COND) REORDER RED RETURNS(BIT(1));\n   DCL 1   @(256) ALIGNED CONNECTED,\n        2  N     CHAR(6),\n        2  V     BIT(16) ALIGNED,\n        2  F     BIN FIXED,\n        2  P     BIT(1),\n        CMD      CHAR(*),\n        COND     CHAR(*);\n   DCL  I;\n   DCL  SUBSTR BUILTIN;\n\n   IF  (COND='BRANCH') &\n       (SUBSTR(CMD,1,1) = 'B') THEN RETURN('1'B);\n\n   IF  (COND='USING') &\n       (CMD='USING' | CMD='DROP') THEN RETURN('1'B);\n\n   DO I=1 TO 256 WHILE(@(I).V \u00ac= 0);\n     IF CMD = @(I).N THEN DO;\n       SELECT (COND);\n         WHEN ('PRIV') DO;\n           RETURN (@(I).P);\n         END;\n         OTHER\n           RETURN ('0'B);\n       END;\n     END;\n   END;\n\n   RETURN('0'B);\n END REASMCM;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REASMCMD": {"ttr": 1032, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x1e\\x1c\\x00A\\x00\\x976_\\x01\\x06\\x01\\x7f\\x01\\x05\\x00:\\x00\\x1d\\x00)\\xd7\\xc7\\xd4\\xe5\\xc3@@@@@'", "ispf": {"version": "30.28", "flags": 0, "createdate": "1997-12-31T00:00:00", "modifydate": "2006-01-17T01:05:41", "lines": 58, "newlines": 29, "modlines": 41, "user": "PGMVC"}, "text": " /****************************/\n /*    INCLUDE REASMCMD      */\n /****************************/\n\n DCL 1   @(550) ALIGNED,        /* IBM ASM COMMANDS ARRAY */\n      2  N     CHAR(6),         /* COMMAND NAME           */\n      2  V     BIT(16) ALIGNED, /* COMMAND CODE 1/2 BYTES */\n      2  F     BIN FIXED,       /* COMMAND TYPE (BELOW)   */\n      2  PRIV  BIT (1),         /* '1' FOR PRIVILEGED     */\n\n        ($RR1  INIT(1),\n         $RR2  INIT(2),\n         $RR3  INIT(3),\n         $RRE  INIT(4),\n         $RR5  INIT(5),\n         $R    INIT(6),\n         $RS1  INIT(7),\n         $RS2  INIT(8),\n         $RX   INIT(9),\n         $RM   INIT(10),\n         $SI   INIT(11),\n         $S1   INIT(12),\n         $S2   INIT(13),\n         $SS1  INIT(14),\n         $SS2  INIT(15),\n         $SS3  INIT(16),\n         $SS4  INIT(17),\n         $SSE  INIT(18),\n\n   /* CHANGES IN 2006 */\n         $RI   INIT(19),\n         $RIM  INIT(20),\n         $RIM1 INIT(21),\n         $RIL  INIT(22),\n         $RILM INIT(23),\n         $RXY  INIT(24),\n         $RXY1 INIT(25),\n         $SIY  INIT(26),\n         $RSI  INIT(27),\n         $RIE  INIT(28),\n         $RSY  INIT(29),\n         $RSY1 INIT(30),\n         $E    INIT(31),\n         $RXE  INIT(32),\n         $RXF  INIT(33),\n         $RRF  INIT(34),\n         $RSL  INIT(35),\n\n         $ZZZ  INIT(99)\n         ) BIN FIXED STATIC INT;\n\n DCL 1   CMDSET,\n      2  CMDNUM(5) BIN FIXED,   /* 1-360;2-370;3-SP/XA;4-ESA;5-ZOS */\n      2  FLOATMIN  BIN FIXED,   /* MIN  FLOAT NUMBER         */\n      2  FLOATMAX  BIN FIXED,   /* MAX  FLOAT NUMBER         */\n      2  PACKMIN   BIN FIXED,   /* MIN  PACK  NUMBER         */\n      2  PACKMAX   BIN FIXED;   /* MAX  PACK  NUMBER         */\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REASMCR": {"ttr": 1034, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x1e\\x01\\x00\\x18\\x00\\x976_\\x01\\x06\\x01?\\x15W\\x00*\\x00*\\x00\\x03\\xd7\\xc7\\xd4\\xe5\\xc3@@@@@'", "ispf": {"version": "30.01", "flags": 0, "createdate": "1997-12-31T00:00:00", "modifydate": "2006-01-13T15:57:18", "lines": 42, "newlines": 42, "modlines": 3, "user": "PGMVC"}, "text": "*PROCESS M,NOINSOURCE,S;\n /*\n//PGMVCI JOB 'IBI','V CHERNYAK',REGION=1000K,NOTIFY=PGMVC,CLASS=A,\n//        MSGCLASS=A,MSGLEVEL=(1,1)\n//PROCLIB  JCLLIB ORDER=PGMVYC.REASM.PLI\n//        EXEC PLIXCL,PARM.LKED='LET,NCAL'\n//PLI.SYSIN     DD DSN=PGMVYC.REASM.PLI(REASMCR),DISP=SHR\n//PLI.SYSLIB    DD DSN=PGMVYC.REASM.PLI,DISP=SHR\n//LKED.SYSLMOD  DD DSN=PGMVYC.REASM.SUBLOAD(REASMCR),DISP=SHR\n//\n */\n REASMCR:PROC(SCREEN_PTR);\n    DCL SCREEN_PTR PTR;\n    %INCLUDE SCREEN,REASM99;\n    #FORM('REASM99',LOAD);\n    SOUND=#YES;\n    MODE=#OUTB;\n    #CUR(LINE1,2,NAME);\n    LINE1='I';\n    #CALLTV;\n    DELAY(1000*2);\n    #CUR(LINE2,4,NAME);\n    LINE2=' AM';\n    #CALLTV;\n    DELAY(1000*2);\n    #CUR(LINE3,5,NAME);\n    LINE3='VERY';\n    #CALLTV;\n    DELAY(1000*2);\n    #CUR(LINE4,2,NAME);\n    LINE4=' ';\n    #CALLTV;\n    DELAY(1000*2);\n    #CUR(LINE5,6,NAME);\n    LINE5='TIRED';\n    #CALLTV;\n    DO I=1 TO 5;\n      #CALLTV;\n      DELAY(1000*1);\n    END;\n    STOP;\n END REASMCR;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REASMD": {"ttr": 1036, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x1e\"\\x00\\x14\\x00\\x976_\\x01\\x06\\x02\\x0f\\x01\\x08\\x01\\xf5\\x01\\x88\\x00u\\xd7\\xc7\\xd4\\xe5\\xc3@@@@@'", "ispf": {"version": "30.34", "flags": 0, "createdate": "1997-12-31T00:00:00", "modifydate": "2006-01-20T01:08:14", "lines": 501, "newlines": 392, "modlines": 117, "user": "PGMVC"}, "text": " /********************************************************************/\n /*    INCLUDE REASMD                                                */\n /*    DCLS FOR REASM                                                */\n /********************************************************************/\n\n DCL 1   RR1   BASED(CMD_PTR) UNALIGNED,\n      2  CODE  BIT(8) ALIGNED,\n      2  R1    BIT(4),\n      2  R2    BIT(4),\n     1   RR2   BASED(CMD_PTR) UNALIGNED,\n      2  CODE  BIT(8) ALIGNED,\n      2  OPER  BIT(8),\n     1   RR3   BASED(CMD_PTR) UNALIGNED,\n      2  CODE  BIT(8) ALIGNED,\n      2  MASK  BIT(4),\n      2  R2    BIT(4),\n     1   RRE   BASED(CMD_PTR) UNALIGNED,\n      2  CODE  BIT(16) ALIGNED,\n      2  RSRV  BIT(8),\n      2  R1    BIT(4),\n      2  R2    BIT(4),\n     1   RRF   BASED(CMD_PTR) UNALIGNED,\n      2  CODE  BIT(16) ALIGNED,\n      2  R1    BIT(4),\n      2  RSRV  BIT(4),\n      2  R3    BIT(4),\n      2  R2    BIT(4),\n     1   RRE1  BASED(CMD_PTR) UNALIGNED,\n      2  CODE  BIT(16) ALIGNED,\n      2  RSRV  BIT(8),\n      2  R1    BIT(4),\n      2  RSRV1 BIT(4),\n     1   R     BASED(CMD_PTR) UNALIGNED,\n      2  CODE  BIT(8) ALIGNED,\n      2  R1    BIT(4),\n      2  RSRV  BIT(4),\n     1   RR6   BASED(CMD_PTR) UNALIGNED,\n      2  CODE  BIT(16) ALIGNED,\n     1   RS1   BASED(CMD_PTR) UNALIGNED,\n      2  CODE  BIT(8) ALIGNED,\n      2  R1    BIT(4),\n      2  R3    BIT(4),\n      2  B2    BIT(4),\n      2  D2    BIT(12),\n     1   RS2   BASED(CMD_PTR) UNALIGNED,\n      2  CODE  BIT(8) ALIGNED,\n      2  R1    BIT(4),\n      2  MASK  BIT(4),\n      2  B2    BIT(4),\n      2  D2    BIT(12),\n     1   RSI   BASED(CMD_PTR) UNALIGNED,\n      2  CODE  BIT(8) ALIGNED,\n      2  R1    BIT(4),\n      2  R3    BIT(4),\n      2  I2    BIN FIXED(15) UNALIGNED,\n     1   RX    BASED(CMD_PTR) UNALIGNED,\n      2  CODE  BIT(8) ALIGNED,\n      2  R1    BIT(4),\n      2  X2    BIT(4),\n      2  B2    BIT(4),\n      2  D2    BIT(12),\n     1   RXY   BASED(CMD_PTR) UNALIGNED,\n      2  CODE  BIT(8) ALIGNED,\n      2  R1    BIT(4),\n      2  X2    BIT(4),\n      2  B2    BIT(4),\n      2  DL2   BIT(12),\n      2  DH2   BIT(8),\n      2  CODE1 BIT(8),\n     1   RXY1  BASED(CMD_PTR) UNALIGNED,\n      2  CODE  BIT(8) ALIGNED,\n      2  R1    BIT(4),\n      2  R3    BIT(4),\n      2  B2    BIT(4),\n      2  DL2   BIT(12),\n      2  DH2   BIT(8),\n      2  CODE1 BIT(8),\n     1   RXE   BASED(CMD_PTR) UNALIGNED,\n      2  CODE  BIT(8) ALIGNED,\n      2  R1    BIT(4),\n      2  X2    BIT(4),\n      2  B2    BIT(4),\n      2  D2    BIT(12),\n      2  RSRV  BIT(8),\n      2  CODE1 BIT(8),\n     1   RXF   BASED(CMD_PTR) UNALIGNED,\n      2  CODE  BIT(8) ALIGNED,\n      2  R3    BIT(4),\n      2  X2    BIT(4),\n      2  B2    BIT(4),\n      2  D2    BIT(12),\n      2  R1    BIT(4),\n      2  RSRV  BIT(4),\n      2  CODE1 BIT(8),\n     1   RSY   BASED(CMD_PTR) UNALIGNED,\n      2  CODE  BIT(8) ALIGNED,\n      2  R1    BIT(4),\n      2  R3    BIT(4),\n      2  B2    BIT(4),\n      2  DL2   BIT(12),\n      2  DH2   BIT(8),\n      2  CODE1 BIT(8),\n     1   RSY1  BASED(CMD_PTR) UNALIGNED,\n      2  CODE  BIT(8) ALIGNED,\n      2  R1    BIT(4),\n      2  MASK  BIT(4),\n      2  B2    BIT(4),\n      2  DL2   BIT(12),\n      2  DH2   BIT(8),\n      2  CODE1 BIT(8),\n     1   RSL   BASED(CMD_PTR) UNALIGNED,\n      2  CODE  BIT(8) ALIGNED,\n      2  L1    BIT(4),\n      2  RSRV  BIT(4),\n      2  B1    BIT(4),\n      2  D1    BIT(12),\n      2  RSRV2 BIT(8),\n      2  CODE1 BIT(8),\n     1   RM    BASED(CMD_PTR) UNALIGNED,\n      2  CODE  BIT(8) ALIGNED,\n      2  MASK  BIT(4),\n      2  X2    BIT(4),\n      2  B2    BIT(4),\n      2  D2    BIT(12),\n     1   RI    BASED(CMD_PTR) UNALIGNED,\n      2  CODE  BIT(8) ALIGNED,\n      2  R1    BIT(4),\n      2  CODE1 BIT(4),\n      2  I2    BIN FIXED(15) UNALIGNED,\n     1   RIM   BASED(CMD_PTR) UNALIGNED,\n      2  CODE  BIT(8) ALIGNED,\n      2  MASK  BIT(4),\n      2  CODE1 BIT(4),\n      2  I2    BIN FIXED(15) UNALIGNED,\n     1   RIM1  BASED(CMD_PTR) UNALIGNED,\n      2  CODE  BIT(8) ALIGNED,\n      2  R1    BIT(4),\n      2  CODE1 BIT(4),\n      2  I2    BIN FIXED(15) UNALIGNED,\n     1   RIL   BASED(CMD_PTR) UNALIGNED,\n      2  CODE  BIT(8) ALIGNED,\n      2  R1    BIT(4),\n      2  CODE1 BIT(4),\n      2  I2    BIN FIXED(31) UNALIGNED,\n     1   RILM  BASED(CMD_PTR) UNALIGNED,\n      2  CODE  BIT(8) ALIGNED,\n      2  MASK  BIT(4),\n      2  CODE1 BIT(4),\n      2  I2    BIN FIXED(31) UNALIGNED,\n     1   RIE   BASED(CMD_PTR) UNALIGNED,\n      2  CODE  BIT(8) ALIGNED,\n      2  R1    BIT(4),\n      2  R3    BIT(4),\n      2  I2    BIN FIXED(15) UNALIGNED,\n      2  RSRV  BIT(8),\n      2  CODE1 BIT(8),\n     1   SI    BASED(CMD_PTR) UNALIGNED,\n      2  CODE  BIT(8) ALIGNED,\n      2  $I    BIT(8),\n      2  B2    BIT(4),\n      2  D2    BIT(12),\n     1   SIY   BASED(CMD_PTR) UNALIGNED,\n      2  CODE  BIT(8) ALIGNED,\n      2  $I    BIT(8),\n      2  B2    BIT(4),\n      2  DL2   BIT(12),\n      2  DH2   BIT(8),\n      2  CODE1 BIT(8),\n     1   S1    BASED(CMD_PTR) UNALIGNED,\n      2  CODE  BIT(8) ALIGNED,\n      2  RSRV  BIT(8),\n      2  B2    BIT(4),\n      2  D2    BIT(12),\n     1   S2    BASED(CMD_PTR) UNALIGNED,\n      2  CODE  BIT (16) ALIGNED,\n      2  B2    BIT(4),\n      2  D2    BIT(12),\n     1   SS1   BASED(CMD_PTR) UNALIGNED,\n      2  CODE  BIT(8) ALIGNED,\n      2  LEN1  BIT(4),\n      2  LEN2  BIT(4),\n      2  B1    BIT(4),\n      2  D1    BIT(12),\n      2  B2    BIT(4),\n      2  D2    BIT(12),\n     1   SS2   BASED(CMD_PTR) UNALIGNED,\n      2  CODE  BIT(8) ALIGNED,\n      2  LEN   BIT(8),\n      2  B1    BIT(4),\n      2  D1    BIT(12),\n      2  B2    BIT(4),\n      2  D2    BIT(12),\n     1   SS3   BASED(CMD_PTR) UNALIGNED,\n      2  CODE  BIT(8) ALIGNED,\n      2  LEN   BIT(4),\n      2  I3    BIT(4),\n      2  B1    BIT(4),\n      2  D1    BIT(12),\n      2  B2    BIT(4),\n      2  D2    BIT(12),\n     1   SS4   BASED(CMD_PTR) UNALIGNED,\n      2  CODE  BIT(8) ALIGNED,\n      2  R1    BIT(4),\n      2  R3    BIT(4),\n      2  B1    BIT(4),\n      2  D1    BIT(12),\n      2  B2    BIT(4),\n      2  D2    BIT(12),\n     1   SSE   BASED(CMD_PTR) UNALIGNED,\n      2  CODE  BIT(16) ALIGNED,\n      2  B1    BIT(4),\n      2  D1    BIT(12),\n      2  B2    BIT(4),\n      2  D2    BIT(12),\n     1   E     BASED(CMD_PTR) UNALIGNED,\n      2  CODE  BIT(16) ALIGNED;\n\n DCL     CMDDEF      BIT(2) ALIGNED BASED(CMD_PTR),\n         CMD_PTR     PTR    INIT(NULL),\n         #CMD_PTR    BIN    FIXED(31) BASED(#PTR04),\n         #PTR04      PTR,\n         CMDLEN(0:3) BIN    FIXED STATIC INT INIT(2,4,4,6);\n         #PTR04 = ADDR(CMD_PTR);\n\n DCL     @COMPT      CHAR(20) VAR,\n         PARM        CHAR(100) VAR,\n         OS          BIN FIXED,  /* 1-360; 2-370; 3-SP/XA; 4-ESA */\n         (PC,FC)     BIN FIXED,  /* 0-PACKED/FLOAT SET DISABLED  */\n\n         SAVEFL      FILE STREAM,\n         SYSPRINT    PRINT,\n         SOURCE      CHAR(8)  INIT(''),\n         SAVE        CHAR(8)  INIT('REASMSAV'),\n         CONTROL     CHAR(8)  INIT('REASMBLK'),\n\n         DSN         CHAR(44) INIT(''),\n         VOL         CHAR(6)  INIT(''),\n         DSNSAVE     CHAR(44) INIT(''),\n         MEMSAVE     CHAR(8)  INIT(''),\n         VOLSAVE     CHAR(6)  INIT(''),\n         MEMBER      CHAR(8)  INIT(''),\n         CSECT       CHAR(8)  INIT(''),\n         MEMOUT      CHAR(8)  INIT(''),\n         BLKNAME     CHAR(8)  INIT(''),\n\n         BLOCK       CHAR(32767),\n         TEXTLEN     BIN FIXED(31),\n\n         (I,II,J,K,RC) BIN FIXED,\n         GLOBAL_IP   BIN FIXED,\n         #OFFSET     BIN FIXED(31),\n         OFFSET      BIN FIXED(31),\n         $OFFSET     BIN FIXED(31),\n         LOCVAR      CHAR(255) VAR,\n         #COM        CHAR(80) VAR,\n         #SCRCOM(100) CHAR(80) VAR,\n         PASS(10)    CHAR(8)  INIT(''),\n         JDAT        CHAR(6)  INIT(''),\n         ESDID       BIN FIXED,\n         CURESD      BIN FIXED INIT(0),\n         ARRINDX     BIN FIXED,\n         PREV        PTR,\n         #FIND       CHAR(50) VAR INIT(''),\n         FINDTXT     CHAR(50),\n         FOFFSET     BIN FIXED(31),\n         BOFFSET     BIN FIXED(31),\n         IV          CHAR(4),\n         FIELD       CHAR(8) INIT(' '),\n         FIELDP      BIN FIXED(31) INIT(1),\n         POS         BIN FIXED(31),\n         LVL         BIN FIXED(31),\n         MAXLVL      BIN FIXED(31) INIT(100),\n         (STRIN,COLIN) BIN FIXED,\n         PDFCHAR     CHAR(15) INIT(''),\n         PDFBYTE     CHAR(1)  INIT(''),\n         REASMVER    CHAR(3) STATIC INT INIT('4.0'), /* VERSION */\n\n         DSRG        BIT(16),\n           PO        BIT(16) STATIC INT INIT('0000001000000000'B),\n           POU       BIT(16) STATIC INT INIT('0000001100000000'B),\n\n         #PAGE       BIN FIXED INIT(0),\n         PRINTNUM    BIN FIXED INIT(0),\n         SAVENUM     BIN FIXED INIT(0),\n\n         LINE_I(100)  BIN FIXED,\n         LINE_O(100)  BIN FIXED(31),\n         LINE_C(100)  BIN FIXED,\n\n         PRINTBIT    BIT(1)  ALIGNED  INIT('0'B),\n         SAVEBIT     BIT(1)  ALIGNED  INIT('0'B),\n         ESDLOOP     BIT(1)  ALIGNED  INIT('0'B),\n         $EOF        BIT(1)  ALIGNED  INIT('0'B),\n         $DSOFF      BIT(1)  ALIGNED  INIT('0'B),\n         $MSG        BIT(1)  ALIGNED  INIT('0'B),\n         $TRACE      BIT(1)  ALIGNED  INIT('0'B),\n         $FIND       BIT(1)  ALIGNED  INIT('0'B),\n         $CONF       BIT(1)  ALIGNED  INIT('0'B),\n         $CONFP      BIT(1)  ALIGNED  INIT('0'B),\n         $FIRST      BIT(1)  ALIGNED  INIT('1'B),\n         $REM        BIT(1)  ALIGNED  INIT('0'B),\n         $XREF       BIT(1)  ALIGNED  INIT('0'B),\n         $AUTO       BIT(1)  ALIGNED  INIT('1'B),\n         $BIT        BIT(1)  ALIGNED  INIT('0'B),\n         $MATCH      BIT(1)  ALIGNED  INIT('0'B),\n         $NOOP       BIT(1)  ALIGNED  INIT('0'B),\n         LINELEN     BIN FIXED INIT(4),\n         #ABSA       BIN FIXED INIT(12),\n         #ABSB       BIN FIXED INIT(8),\n         REMTIME     BIN FIXED INIT(0),\n         REMCOUNT    BIN FIXED INIT(0),\n         OPPREV      CHAR(5) INIT(''),\n         $ORGIMM     CHAR(5) INIT(''),\n         $ORGIMM_B   CHAR(3) INIT(''),\n         $ORGIMM_F   CHAR(3) INIT(''),\n         $SAVE       CHAR(1) INIT('N'),\n         SCREEN_PTR  PTR,\n         #CURI       BIN FIXED,\n         #FORWARD    BIN FIXED INIT(0),\n         1   BLOCK_CMD,\n          2  TYPE    CHAR(1),\n          2  O1      BIN FIXED(31),\n          2  O2      BIN FIXED(31),\n          2  LEN     BIN FIXED(31),\n          2  PENDING BIT(1) ALIGNED INIT('0'B);\n\n DCL 1   ESD_BLOCK BASED(ESD_BLOCK_PTR) ALIGNED,\n      2  IDENT       BIT(8),\n      2  RSERV       BIT(24),\n      2  FIRST_ESDID BIN FIXED,\n      2  ESDLEN      BIN FIXED,\n\n     1   ESD_ELEMENT BASED(ESD_ELEMENT_PTR) ALIGNED,\n      2  NAME        CHAR(8),\n      2  TYPE        BIT(8),\n      2  OFF         BIT(24),\n      2  ALIGN       BIT(8),\n      2  LENGTH      BIT(24),\n      2  REF         BIN FIXED,\n      2  ID          BIN FIXED,\n\n     1   CNTL_BLOCK BASED(CNTL_BLOCK_PTR) UNALIGNED,\n      2  ER          BIT(1),\n      2  RS01        BIT(3),\n      2  LAST        BIT(1),\n      2  RS02        BIT(1),\n      2  RLDYES      BIT(1),\n      2  CNTLYES     BIT(1),\n      2  RS03        BIT(24),\n      2  CNTLNO      BIN FIXED,\n      2  RLDNO       BIN FIXED,\n      2  RS04        BIT(8),\n      2  TXTOFF      BIT(24),\n      2  RS05        BIN FIXED,\n      2  TXTLEN      BIN FIXED,\n\n     1   CNTL_ELEMENT BASED(CNTL_ELEMENT_PTR) UNALIGNED,\n      2  CNTLID      BIN FIXED,\n      2  CNTLLEN     BIN FIXED,\n\n     1   RLDA_ELEMENT BASED(RLD_ELEMENT_PTR) UNALIGNED,\n      2  TOID        BIN FIXED,\n      2  FROMID      BIN FIXED,\n\n     1   RLDE_ELEMENT BASED(RLD_ELEMENT_PTR) UNALIGNED,\n      2  RS01        BIT(2),\n      2  RLDTYPE     BIT(2),\n      2  RLDLEN      BIT(2),\n      2  SUBT        BIT(1),\n      2  NOTLAST     BIT(1),\n      2  RLDOFF      BIT(24);\n\n DCL 1   BYTE    BASED(BYTE_PTR) UNALIGNED,\n      2  BIT0          BIT(1),\n      2  BIT1          BIT(1),\n      2  BIT2          BIT(1),\n      2  BIT3          BIT(1),\n      2  BIT4          BIT(1),\n      2  BIT5          BIT(1),\n      2  BIT6          BIT(1),\n      2  BIT7          BIT(1),\n         BYTE_PTR      PTR,\n         ONEBYTE       BIT(8);\n\n         BYTE_PTR = ADDR(ONEBYTE);\n\n DCL     (ESD_BLOCK_PTR,    ESD_ELEMENT_PTR, CNTL_BLOCK_PTR,\n          CNTL_ELEMENT_PTR, RLD_ELEMENT_PTR) PTR;\n\n DCL     #ESD_BLOCK_PTR     BIN FIXED(31) BASED(#PTR05), #PTR05 PTR,\n         #ESD_ELEMENT_PTR   BIN FIXED(31) BASED(#PTR06), #PTR06 PTR,\n         #CNTL_BLOCK_PTR    BIN FIXED(31) BASED(#PTR07), #PTR07 PTR,\n         #CNTL_ELEMENT_PTR  BIN FIXED(31) BASED(#PTR08), #PTR08 PTR,\n         #RLD_ELEMENT_PTR   BIN FIXED(31) BASED(#PTR09), #PTR09 PTR;\n\n         #PTR05 = ADDR(ESD_BLOCK_PTR);\n         #PTR06 = ADDR(ESD_ELEMENT_PTR);\n         #PTR07 = ADDR(CNTL_BLOCK_PTR);\n         #PTR08 = ADDR(CNTL_ELEMENT_PTR);\n         #PTR09 = ADDR(RLD_ELEMENT_PTR);\n\n DCL 1   ESD_ARRAY(*)       CTL LIKE ESD_ELEMENT,\n         DIM_ESD_ARRAY      BIN FIXED;\n\n DCL     USING_START   PTR INIT(NULL),\n         RLD_START     PTR INIT(NULL),\n         QUALIFY_START PTR INIT(NULL),\n         DSC_START     PTR INIT(NULL),\n         LABL_START    PTR INIT(NULL),\n         LBLOCK_START  PTR INIT(NULL),\n         XREF_START    PTR INIT(NULL),\n         ORG_START     PTR INIT(NULL),\n         COM_START     PTR INIT(NULL);\n\n\n DCL  1  CARD   DEF #CARD,\n       2 LABEL  CHAR(9),\n       2 OPER   CHAR(6),\n       2 OPERANDS CHAR(56),\n       2 CONTPOS CHAR(1),\n       2 CARDNUM PIC'99999999',\n         #CARD  CHAR(80) INIT('');\n\n DCL     GOODA   CHAR(256)     INIT(''),\n         ICH     BIN FIXED(15) INIT(0),\n      1  CH_STR  BASED(#PTR03),\n       2 CH_RS   CHAR(1),\n       2 CH      CHAR(1),\n         #PTR03  PTR;\n         #PTR03 = ADDR(ICH);\n\n\n DCL        DYNAM        ENTRY OPTIONS(ASSEMBLER, RETCODE, INTER),\n            DYNWORK      BIN FIXED(31)  INIT(0),\n            DYNMSG       CHAR(256) INIT(''),\n\n          1 DYNAREA      UNALIGNED,\n            2 DDNAME     CHAR(8)  INIT(''),\n            2 DSNAME     CHAR(44) INIT(''),\n            2 DSORG      BIT(16)  INIT('0'B),\n            2 VOL        CHAR(6)  INIT(''),\n\n          1 DYNINFO      UNALIGNED,\n            2 DDNAME     CHAR(8)  INIT(''),\n            2 DSNAME     CHAR(44) INIT(''),\n            2 MEMBER     CHAR(8)  INIT(''),\n            2 STATUS     BIT(8)   INIT('0'B),\n            2 DISP       BIT(8)   INIT('0'B),\n            2 COND_DISP  BIT(8)   INIT('0'B),\n            2 DSORG      BIT(16)  INIT('0'B),\n            2 LIMIT      BIN FIXED(15) INIT(0),\n            2 ATTRIBUTE  BIT(8)   INIT('0'B),\n            2 LAST_ENTRY BIT(8)   INIT('0'B),\n            2 TYPE       BIT(8)   INIT('0'B);\n\n      /* -------------------------------------------- */\n      /* UTILITY    SUBROUTINES  FROM MODULE REASCNV  */\n      /* -------------------------------------------- */\n DCL $HB     ENTRY(CHAR(*) VAR)           EXT RETURNS(BIT(16));\n DCL $HBF    ENTRY(CHAR(*) VAR)           EXT RETURNS(BIN FIXED(31));\n DCL $BH     ENTRY(BIN FIXED(31))         EXT RETURNS(CHAR(8));\n DCL $DIGIT  ENTRY(BIN FIXED(31))         EXT RETURNS(CHAR(16) VAR);\n DCL $CH     ENTRY(CHAR(*) VAR)           EXT RETURNS(CHAR(80) VAR);\n DCL $IMM    ENTRY(BIT(8))                EXT RETURNS(CHAR(5) VAR);\n DCL $NEXTEL ENTRY(CHAR(*) VAR)           EXT RETURNS(CHAR(100) VAR);\n DCL $DNAME  ENTRY(PTR,BIN FIXED(31),BIN FIXED(31))\n                                          EXT RETURNS(CHAR(8) VAR);\n\n      /* -------------------------------------------- */\n      /* UTILITY    SUBROUTINES FROM MODULE REASMLIV  */\n      /* -------------------------------------------- */\n DCL $INTLIV  ENTRY(CHAR(*), PTR, CHAR(*)) EXT;\n DCL $DELLIV  ENTRY(CHAR(*), PTR) EXT;\n DCL $LFIND   ENTRY(PTR, BIN FIXED, BIT(1), CHAR(*) VAR,)\n              EXT RETURNS(CHAR(20) VAR);\n\n      /* -------------------------------------------- */\n      /* EXTERNAL SUBROUTINES:                        */\n      /* -------------------------------------------- */\n DCL     REASMLD ENTRY(CHAR(8), BIN FIXED(31), CHAR(8))\n                                           EXT OPTIONS(ASM INTER),\n         REASMDL ENTRY(CHAR(8))            EXT OPTIONS(ASM INTER),\n         REASMRC ENTRY(CHAR(8),CHAR(1))    EXT RETURNS(BIN FIXED),\n         REASMCM ENTRY(, CHAR(*), CHAR(*)) EXT RETURNS(BIT(1)),\n         REASESD ENTRY(,BIN FIXED)         EXT RETURNS(CHAR(8)),\n         REASMLB ENTRY(CHAR(*))            EXT RETURNS(CHAR(8) VAR),\n         REASQFY ENTRY(PTR)                EXT RETURNS(BIN FIXED(31)),\n         REASLIB ENTRY(CHAR(8),CHAR(*),)   EXT RETURNS(BIN FIXED),\n         REASLOA ENTRY(CHAR(*),,,,,)       EXT RETURNS(BIN FIXED),\n         REASLST ENTRY                     EXT,\n         REASPRF ENTRY                     EXT,\n         REASQPW ENTRY                     EXT,\n         REASMTL ENTRY(CHAR(256))          EXT OPTIONS(ASM INTER),\n         REASMI  ENTRY                     EXT,\n         MATCH   ENTRY                     EXT RETURNS(BIN FIXED),\n         (ALLOCATION,BIN,VERIFY,MIN,DATE,TIME,ABS,HIGH,HBOUND,ONCODE,\n         TRANSLATE,PLIRETV,STRING,MAX,LOW,NULL,BIT,DIM,ADDR,UNSPEC,\n         LENGTH,MOD,ALL,INDEX,SUBSTR,PLIRETC)  BUILTIN,\n         ISPLINK ENTRY(,,,,BIN FIXED(31),)\n                 EXT OPTIONS(ASM INTER RETCODE);\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REASMHRD": {"ttr": 1286, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x1e\\x02\\x00I\\x00\\x976_\\x01\\x06\\x01\\x7f\\x02\\x14\\x001\\x00+\\x00\\x07\\xd7\\xc7\\xd4\\xe5\\xc3@@@@@'", "ispf": {"version": "30.02", "flags": 0, "createdate": "1997-12-31T00:00:00", "modifydate": "2006-01-17T02:14:49", "lines": 49, "newlines": 43, "modlines": 7, "user": "PGMVC"}, "text": " /*********************************************************************/\n /*    INCLUDE REASMHRD                                               */\n /*********************************************************************/\n\n DCL     $RLDTYPE(0:3) CHAR(1) STATIC INT\n               INIT ('A','V','Q','D'),\n\n         $ALIGN(0:7)   CHAR(1) STATIC INT\n               INIT ('C','H','C','F','C','C','C','D'),\n\n         $REGS(0:15)   CHAR(3) STATIC INT VAR\n               INIT ('R0','R1','R2','R3','R4','R5','R6','R7','R8','R9',\n                     'R10','R11','R12','R13','R14','R15'),\n\n         $NUMBER(16)   CHAR(6) STATIC INT VAR\n               INIT ('ONE ','TWO','THREE','FOUR','FIVE','SIX','SEVEN',\n                     'EIGHT','NINE','TEN','ELEVEN','TWELVE','13','14',\n                     '15','16'),\n\n         $KEYNAME(0:15) CHAR(10) STATIC INT VAR\n               INIT ('SUPR','JES','KEY2','KEY3','KEY4','DATAMGT',\n                     'VTAM/TCAM','KEY7','KEY8','KEY9','KEY10',\n                     'KEY11','KEY12','KEY13','KEY14','KEY15'),\n\n         $EMNEM(0:15)  CHAR(3) STATIC INT VAR\n               INIT ('NOP','BO','BP','','BM','','','BNZ','BZ','','',\n                     'BNM','','BNP','BNO','B'),\n         $EMNEM1(0:15) CHAR(3) STATIC INT VAR\n               INIT ('NOP','BO','BH','','BL','','','BNE','BE','','',\n                     'BNL','','BNH','BNO','B'),\n\n         $JMNEM(0:15)  CHAR(3) STATIC INT VAR\n               INIT ('JOP','JO','JP','','JM','','','JNZ','JZ','','',\n                     'JNM','','JNP','JNO','J'),\n         $JMNEM1(0:15) CHAR(3) STATIC INT VAR\n               INIT ('NOP','JO','JH','','JL','','','JNE','JE','','',\n                     'JNL','','JNH','JNO','J'),\n\n         $CTLREG(0:15) CHAR(20) VAR STATIC INT\n               INIT ('SYSTEM MASK',   'SEGTABLE ',   'CHANEL MASK' ,\n                     ''           ,   ''         ,   ''            ,\n                     ''           ,   ''         ,   'MONITOR MASK',\n                     'PER MASK'   ,   'PER START',   'PER END'     ,\n                     ''           ,   ''         ,   'HARDERR MASK',\n                     'MCEL ADDR' ),\n\n         $PSWMASK(8) CHAR(4) VAR STATIC INT\n               INIT ('', 'PER', '', '', '', 'DAT', 'I/O', 'EXT');\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REASMI": {"ttr": 1288, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x1e$\\x00\\x17\\x00\\x976_\\x01\\x06\\x01o\\x15(\\x02\\x92\\x01U\\x01a\\xd7\\xc7\\xd4\\xe5\\xc3@@@@@'", "ispf": {"version": "30.36", "flags": 0, "createdate": "1997-12-31T00:00:00", "modifydate": "2006-01-16T15:28:17", "lines": 658, "newlines": 341, "modlines": 353, "user": "PGMVC"}, "text": "*PROCESS M,OPT(2),OPTIONS,NOINSOURCE,S,GN;\n /*\n//PGMVCI  JOB 'IBI','V CHERNYAK',REGION=3M,NOTIFY=PGMVC,CLASS=A,\n//        MSGCLASS=A,MSGLEVEL=(1,1)\n//PROCLIB  JCLLIB ORDER=PGMVYC.REASM.PLI\n//REA      EXEC PLIXCL\n//PLI.SYSIN     DD DSN=PGMVYC.REASM.PLI(REASMI),DISP=SHR\n//PLI.SYSLIB    DD DSN=PGMVYC.REASM.PLI,DISP=SHR\n//LKED.SYSLMOD  DD DSN=PGMVYC.REASM.SUBLOAD(REASMI),DISP=SHR\n//\n */\n REASMI:\n      PROC(@,CMDSET,@COMPT) REORDER;\n\n %DCL    @I  FIXED;\n %@I=0;\n %@MN:   PROC(N,V,F,P,DUMMY) RETURNS(CHAR);\n     DCL (N,V,F,P,DUMMY) CHAR;\n     DCL J FIXED;\n     DCL (C,VV,RET) CHAR;\n\n     VV = '';\n     DO J=1 TO LENGTH(V);\n        C = SUBSTR(V,J,1);\n        IF C='0' THEN VV = VV || '0000';\n        IF C='1' THEN VV = VV || '0001';\n        IF C='2' THEN VV = VV || '0010';\n        IF C='3' THEN VV = VV || '0011';\n        IF C='4' THEN VV = VV || '0100';\n        IF C='5' THEN VV = VV || '0101';\n        IF C='6' THEN VV = VV || '0110';\n        IF C='7' THEN VV = VV || '0111';\n        IF C='8' THEN VV = VV || '1000';\n        IF C='9' THEN VV = VV || '1001';\n        IF C='A' THEN VV = VV || '1010';\n        IF C='B' THEN VV = VV || '1011';\n        IF C='C' THEN VV = VV || '1100';\n        IF C='D' THEN VV = VV || '1101';\n        IF C='E' THEN VV = VV || '1110';\n        IF C='F' THEN VV = VV || '1111';\n     END;\n\n     IF LENGTH(V)<4 THEN\n        VV = '00000000' || VV;\n\n     @I=@I+1;\n     RET =\n      '@('     || @I || ').V='''    || VV ||\n      '''B;@(' || @I || ').N='''    || N  ||\n      ''';@('  || @I || ').F=$'     || F  ||\n      ';@('    || @I || ').PRIV=''' || P  || '''B;';\n\n     RETURN(RET);\n\n %END @MN;\n %ACT @MN;\n\n %@COMPTSET:PROC RETURNS(CHAR);\n  RETURN('@COMPT=''' || COMPILETIME || ''';');\n %END;\n %ACT @COMPTSET;\n\n     @COMPTSET;\n\n %INCLUDE REASMCMD;\n\n DCL     @COMPT CHAR(*) VAR,\n         I, IND,\n         (UNSPEC,DIM) BUILTIN;\n\n     IND = DIM(@.V,1);\n     DO I=1 TO IND;\n        @(I).V    =   0;\n        @(I).N    = ' ';\n     END;\n\n %PAGE;\n /**** IBM/360 ******/\n @MN(DR,1D,RR1,0,+     )\n @MN(D,5D,RX,0,+       )\n @MN(EX,44,RX,0,+      )\n @MN(MVC,D2,SS2,0,+    )\n @MN(S,5B,RX,0,+       )\n @MN(SL,5F,RX,0,+      )\n @MN(SR,1B,RR1,0,+     )\n @MN(SLR,1F,RR1,0,+    )\n @MN(SH,4B,RX,0,+      )\n @MN(LR,18,RR1,0,+     )\n @MN(L,58,RX,0,+       )\n @MN(LA,41,RX,0,+      )\n @MN(LM,98,RS1,0,+     )\n @MN(LCR,13,RR1,0,+    )\n @MN(LTR,12,RR1,0,+    )\n @MN(LNR,11,RR1,0,+    )\n @MN(LPR,10,RR1,0,+    )\n @MN(LH,48,RX,0,+      )\n @MN(ST,50,RX,0,+      )\n @MN(STM,90,RS1,0,+    )\n @MN(STH,40,RX,0,+     )\n @MN(STC,42,RX,0,+     )\n @MN(NR,14,RR1,0,+     )\n @MN(N,54,RX,0,+       )\n @MN(NI,94,SI,0,+      )\n @MN(NC,D4,SS2,0,+     )\n @MN(OR,16,RR1,0,+     )\n @MN(O,56,RX,0,+       )\n @MN(OI,96,SI,0,+      )\n @MN(OC,D6,SS2,0,+     )\n @MN(XR,17,RR1,0,+     )\n @MN(X,57,RX,0,+       )\n @MN(XI,97,SI,0,+      )\n @MN(XC,D7,SS2,0,+     )\n @MN(SVC,0A,RR2,0,+    )\n @MN(MVI,92,SI,0,+     )\n @MN(TR,DC,SS2,0,+     )\n @MN(TRT,DD,SS2,0,+    )\n @MN(BXH,86,RS1,0,+    )\n @MN(BXLE,87,RS1,0,+   )\n @MN(BCTR,06,RR1,0,+   )\n @MN(BCT,46,RX,0,+     )\n @MN(BAL,45,RX,0,+     )\n @MN(BALR,05,RR1,0,+   )\n @MN(BCR,07,RR3,0,+    )\n @MN(BC,47,RM,0,+      )\n @MN(TM,91,SI,0,+      )\n @MN(IC,43,RX,0,+      )\n @MN(SLA,8B,RX,0,+     )\n @MN(SLDA,8F,RX,0,+   )\n @MN(SLDL,8D,RX,0,+   )\n @MN(SLL,89,RX,0,+     )\n @MN(SRA,8A,RX,0,+    )\n @MN(SRL,88,RX,0,+    )\n @MN(SRDA,8E,RX,0,+   )\n @MN(SRDL,8C,RX,0,+   )\n @MN(AR,1A,RR1,0,+     )\n @MN(A,5A,RX,0,+       )\n @MN(ALR,1E,RR1,0,+    )\n @MN(AL,5E,RX,0,+      )\n @MN(AH,4A,RX,0,+      )\n @MN(CR,19,RR1,0,+     )\n @MN(C,59,RX,0,+       )\n @MN(CLR,15,RR1,0,+    )\n @MN(CL,55,RX,0,+      )\n @MN(CLC,D5,SS2,0,+    )\n @MN(CLI,95,SI,0,+     )\n @MN(CH,49,RX,0,+      )\n @MN(MR,1C,RR1,0,+     )\n @MN(M,5C,RX,0,+       )\n @MN(MH,4C,RX,0,+      )\n @MN(TS,93,S1,0,+      )\n @MN(SPM,04,R,0,+      )\n\n @MN(MC,AF,SI,1,+      )\n @MN(SSM,80,S1,1,+     )\n @MN(SSK,08,RR1,1,+    )\n @MN(WRD,84,SI,1,+     )\n @MN(RDD,85,SI,1,+     )\n @MN(ISK,09,RR1,1,+    )\n @MN(SIO,9C00,S2,1,+   )\n @MN(HIO,9E00,S2,1,+   )\n @MN(TIO,9D00,S2,1,+   )\n @MN(TCH,9F00,S2,1,+   )\n @MN(LPSW,82,S1,1,+    )\n                               /* FEW PACK COMMANDS */\n @MN(ED,DE,SS2,0,+     )\n @MN(EDMK,DF,SS2,0,+   )\n @MN(PACK,F2,SS1,0,+   )\n @MN(PKA,E9,SS1,0,+   )\n @MN(PKU,E1,SS1,0,+   )\n @MN(UNPK,F3,SS1,0,+   )\n @MN(UNPKA,EA,SS1,0,+   )\n @MN(UNPKU,E2,SS1,0,+   )\n @MN(MVZ,D3,SS2,0,+    )\n @MN(MVO,F1,SS1,0,+    )\n @MN(MVN,D1,SS2,0,+    )\n @MN(CVB,4F,RX,0,+     )\n @MN(CVD,4E,RX,0,+     )\n                               /*  PACK  COMMANDS  */\n   PACKMIN  = @I+1;\n @MN(AP,FA,SS1,0,+     )\n @MN(CP,F9,SS1,0,+     )\n @MN(MP,FC,SS1,0,+     )\n @MN(SP,FB,SS1,0,+     )\n @MN(DP,FD,SS1,0,+     )\n @MN(ZAP,F8,SS1,0,+    )\n @MN(SRP,F0,SS3,0,+    )\n @MN(TP,EBC0,RSL,0,+   )\n   PACKMAX  = @I;\n                               /*  FLOAT COMMANDS  */\n   FLOATMIN = @I+1;\n @MN(SWR,2F,RR1,0,+    )\n @MN(SW,6F,RX,0,+      )\n @MN(SUR,3F,RR1,0,+    )\n @MN(SU,7F,RX,0,+      )\n @MN(SXR,37,RR1,0,+    )\n @MN(SDR,2B,RR1,0,+    )\n @MN(SD,6B,RX,0,+      )\n @MN(SER,3B,RR1,0,+    )\n @MN(SE,7B,RX,0,+      )\n @MN(DDR,2D,RR1,0,+    )\n @MN(DD,6D,RX,0,+      )\n @MN(DE,7D,RX,0,+      )\n @MN(DER,3D,RR1,0,+    )\n @MN(DE,7D,RX,0,+      )\n @MN(LDR,28,RR1,0,+    )\n @MN(LD,68,RX,0,+      )\n @MN(LER,38,RR1,0,+    )\n @MN(LE,78,RX,0,+      )\n @MN(LCDR,23,RR1,0,+   )\n @MN(LCER,33,RR1,0,+   )\n @MN(LCXR,B363,RRE,0,+   )\n @MN(LTDR,22,RR1,0,+   )\n @MN(LTER,32,RR1,0,+   )\n @MN(LTXR,B362,RRE,0,+   )\n @MN(LNDR,21,RR1,0,+   )\n @MN(LNER,31,RR1,0,+   )\n @MN(LNXR,B361,RRE,0,+   )\n @MN(LPDR,20,RR1,0,+   )\n @MN(LPER,30,RR1,0,+   )\n @MN(LPXR,B360,RRE,0,+   )\n @MN(LDXR,25,RR1,0,+   )\n @MN(LEDR,35,RR1,0,+   )\n @MN(LEXR,B366,RRE,0,+ )\n @MN(STD,60,RX,0,+     )\n @MN(STE,70,RX,0,+     )\n @MN(HDR,24,RR1,0,+    )\n @MN(HER,34,RR1,0,+    )\n @MN(AWR,2E,RR1,0,+    )\n @MN(AW,6E,RX,0,+      )\n @MN(AUR,3E,RR1,0,+    )\n @MN(AU,7E,RX,0,+      )\n @MN(AXR,36,RR1,0,+    )\n @MN(ADR,2A,RR1,0,+    )\n @MN(AD,6A,RX,0,+      )\n @MN(AER,3A,RR1,0,+    )\n @MN(AE,7A,RX,0,+      )\n @MN(CDR,29,RR1,0,+    )\n @MN(CD,69,RX,0,+      )\n @MN(CER,39,RR1,0,+    )\n @MN(CE,79,RX,0,+      )\n @MN(MXR,26,RR1,0,+    )\n @MN(MDR,2C,RR1,0,+    )\n @MN(MD,6C,RX,0,+      )\n @MN(MXDR,27,RR1,0,+   )\n @MN(MEER,B337,RRE,0,+   )\n @MN(MXD,67,RX,0,+     )\n @MN(MER,3C,RR1,0,+    )\n @MN(ME,7C,RX,0,+      )\n\n @MN(MAER,B32E,RRF,0,+   )\n @MN(MADR,B33E,RRF,0,+   )\n @MN(MSER,B32F,RRF,0,+   )\n @MN(MSDR,B33F,RRF,0,+   )\n\n @MN(CEFR,B3B4,RRE,0,+ )\n @MN(CDFR,B3B5,RRE,0,+ )\n @MN(CXFR,B3B6,RRE,0,+ )\n @MN(CEGR,B3C4,RRE,0,+ )\n @MN(CDGR,B3C5,RRE,0,+ )\n @MN(CXGR,B3C6,RRE,0,+ )\n\n @MN(CFER,B3B8,RRE,0,+ )\n @MN(CFDR,B3B9,RRE,0,+ )\n @MN(CFXR,B3BA,RRE,0,+ )\n @MN(CGER,B3C8,RRE,0,+ )\n @MN(CGDR,B3C9,RRE,0,+ )\n @MN(CGXR,B3CA,RRE,0,+ )\n\n @MN(FIER,B377,RRE,0,+ )\n @MN(FIDR,B37F,RRE,0,+ )\n @MN(FIXR,B367,RRE,0,+ )\n\n @MN(LDER,B324,RRE,0,+ )\n @MN(LXDR,B325,RRE,0,+ )\n @MN(LXER,B326,RRE,0,+ )\n\n @MN(LDE,ED24,RXE,0,+ )\n @MN(LXD,ED25,RXE,0,+ )\n @MN(LXE,ED26,RXE,0,+ )\n\n @MN(MAE,ED2E,RXF,0,+ )\n @MN(MAD,ED3E,RXF,0,+ )\n @MN(MSE,ED2F,RXF,0,+ )\n @MN(MSD,ED3F,RXF,0,+ )\n\n @MN(SQER,B245,RRE,0,+ )\n @MN(SQDR,B244,RRE,0,+ )\n @MN(SQXR,B336,RRE,0,+ )\n @MN(SQE,ED34,RXE,0,+ )\n @MN(SQD,ED35,RXE,0,+ )\n\n   FLOATMAX = @I;\n\n CMDNUM(1) = @I;\n\n /**** IBM/370 ******/\n @MN(MVCL,0E,RR1,0,+   )\n @MN(CLCL,0F,RR1,0,+   )\n @MN(CS,BA,RS1,0,+     )\n @MN(CDS,BB,RS1,0,+    )\n @MN(CLM,BD,RS2,0,+    )\n @MN(STCM,BE,RS2,0,+   )\n @MN(ICM,BF,RS2,0,+    )\n @MN(SIGP,F0,RS2,1,+   )\n @MN(LRA,B1,RX,1,+     )\n @MN(HDV,9E01,S2,1,+   )\n @MN(CLRIO,9D01,S2,1,+ )\n @MN(SIOF,9C01,S2,1,+  )\n @MN(STNSM,AC,SI,1,+   )\n @MN(STOSM,AD,SI,1,+   )\n @MN(LCTL,B7,RS1,1,+   )\n @MN(STCTL,B6,RS1,1,+  )\n @MN(STIDP,B202,S2,1,+ )\n @MN(STIDC,B203,S2,1,+ )\n @MN(SCK,B204,S2,1,+   )\n @MN(STCK,B205,S2,0,+  )\n @MN(SCKC,B206,S2,1,+  )\n @MN(STCKC,B207,S2,1,+ )\n @MN(SPT,B208,S2,1,+   )\n @MN(STPT,B209,S2,1,+  )\n @MN(SPKA,B20A,S2,1,+  )\n @MN(IPK,B20B,S2,1,+   )\n @MN(PTLB,B20D,E,1,+  )\n @MN(SPX,B210,S2,1,+   )\n @MN(STPX,B211,S2,1,+  )\n @MN(STAP,B212,S2,1,+  )\n @MN(RRB,B213,S2,1,+   )\n CMDNUM(2) = @I;\n\n /**** SP,XA   ******/\n @MN(BASR,0D,RR1,0,+   )\n @MN(BAS,4D,RX,0,+     )\n @MN(BASSM,0C,RR1,0,+  )\n @MN(BSM,0B,RR1,0,+    )\n @MN(RIO,9C01,S2,1,+   )\n @MN(CLRCH,9F01,S2,1,+ )\n @MN(CONCS,B200,S2,1,+ )\n @MN(DISCS,B201,S2,1,+ )\n @MN(PC,B218,S2,1,+    )\n @MN(SAC,B219,S2,1,+   )\n @MN(EPAR,B226,RRE1,1,+ )\n @MN(ESAR,B227,RRE1,1,+ )\n @MN(SSAR,B225,RRE1,1,+ )\n @MN(IAC,B224,RRE1,1,+ )\n @MN(IPTE,B221,RRE,1,+ )\n @MN(ISKE,B229,RRE,1,+ )\n @MN(IVSK,B223,RRE,1,+ )\n @MN(PT,B228,RRE,1,+   )\n @MN(RRBE,B22A,RRE,1,+ )\n @MN(SSKE,B22B,RRE,1,+ )\n @MN(TB,B22C,RRE,1,+   )\n @MN(MVCK,D9,SS4,1,+   )\n @MN(MVCP,DA,SS4,1,+   )\n @MN(MVCS,DB,SS4,1,+   )\n @MN(LASP,E500,SSE,1,+ )\n @MN(TPROT,E501,SSE,1,+)\n @MN(MVCIN,E8,SS2,0,+  )\n    CMDNUM(3) = @I;\n\n /****  ESA    ******/\n @MN(PR,0101,E,0,+   )\n @MN(UPT,0102,E,0,+  )\n @MN(LAE,51,RX,0,+     )\n @MN(TRACE,99,RS1,0,+  )\n @MN(LAM,9A,RS1,0,+    )\n @MN(STAM,9B,RS1,0,+   )\n @MN(CFC,B21A,S2,1,+   )\n @MN(IPM,B222,RRE1,0,+ )\n @MN(DXR,B22D,RRE,0,+  )\n @MN(CSCH,B230,S2,1,+  )\n @MN(HSCH,B231,S2,1,+  )\n @MN(MSCH,B232,S2,1,+  )\n @MN(SSCH,B233,S2,1,+  )\n @MN(STSCH,B234,S2,1,+ )\n @MN(TSCH,B235,S2,1,+  )\n @MN(TPI,B236,RS2,1,+  )\n @MN(SAL,B237,S2,1,+   )\n @MN(RSCH,B238,S2,1,+  )\n @MN(STCRW,B239,RS2,1,+)\n @MN(STCPS,B23A,RS2,1,+)\n @MN(RCHP,B23B,S2,1,+  )\n @MN(SCHM,B23C,S2,1,+  )\n @MN(PALB,B248,E,1,+  )\n @MN(BAKR,B240,RRE,0,+ )\n @MN(STURA,B246,RRE,0,+)\n @MN(EREG,B249,RRE,0,+ )\n @MN(ESTA,B24A,RRE,0,+ )\n @MN(MSTA,B247,RRE1,0,+ )\n @MN(LURA,B24B,RRE,0,+ )\n @MN(TAR,B24C,RRE,0,+  )\n @MN(SAR,B24E,RRE,0,+  )\n @MN(EAR,B24F,RRE,0,+  )\n @MN(CPYA,B24D,RRE,0,+ )\n @MN(MVPG,B254,RRE,0,+ )\n\n @MN(PLO,EE,SS4,0,+   )\n @MN(BSA,B25A,RRE,0,+ )\n\n @MN(MVCDK,E50F,SSE,0,+ )\n @MN(MVCSK,E50E,SSE,0,+ )\n\n    CMDNUM(5) = @I;\n\n /* 2006 ZOS CHANGES */\n\n @MN(AGR,B908,RRE,0,+ )\n @MN(AGFR,B918,RRE,0,+ )\n @MN(AY,E35A,RXY,0,+ )\n @MN(AG,E308,RXY,0,+ )\n @MN(AGF,E318,RXY,0,+ )\n @MN(AHY,E37A,RXY,0,+ )\n @MN(ALY,E35E,RXY,0,+ )\n @MN(ALG,E30A,RXY,0,+ )\n @MN(ALGF,E31A,RXY,0,+ )\n @MN(ALCR,B998,RRE,0,+ )\n @MN(ALCGR,B988,RRE,0,+ )\n @MN(ALC,E398,RXY,0,+ )\n @MN(ALCG,E388,RXY,0,+ )\n @MN(NY,E354,RXY,0,+ )\n @MN(NG,E380,RXY,0,+ )\n @MN(NG,E380,RXY,0,+ )\n @MN(NIY,EB54,SIY,0,+ )\n @MN(NIHH,A540,RI,0,+ )\n @MN(NIHL,A550,RI,0,+ )\n @MN(NILH,A560,RI,0,+ )\n @MN(NILL,A570,RI,0,+ )\n @MN(TMLH,A700,RI,0,+ )\n @MN(TMLL,A730,RI,0,+ )\n @MN(TMHH,A720,RI,0,+ )\n @MN(THML,A730,RI,0,+ )\n @MN(LHI,A780,RI,0,+ )\n @MN(LGHI,A790,RI,0,+ )\n @MN(AHI,A7A0,RI,0,+ )\n @MN(AGHI,A7B0,RI,0,+ )\n @MN(MHI,A7C0,RI,0,+ )\n @MN(MGHI,A7D0,RI,0,+ )\n @MN(CHI,A7E0,RI,0,+ )\n @MN(CGHI,A7F0,RI,0,+ )\n @MN(BRC,A740,RIM,0,+ )\n @MN(BRAS,A750,RIM1,0,+ )\n @MN(BRCT,A760,RIM1,0,+ )\n @MN(BRCTG,A770,RIM1,0,+ )\n @MN(BRCL,C040,RILM,0,+ )\n @MN(BCTGR,B946,RRE,0,+ )\n @MN(BCTG,E346,RXY,0,+ )\n @MN(BXHG,EB44,RXY1,0,+ )\n @MN(BXLEG,EB45,RXY1,0,+ )\n @MN(BRXH,84,RSI,0,+ )\n @MN(BRXHG,EC44,RIE,0,+ )\n @MN(BRXLE,85,RSI,0,+ )\n @MN(BRXLG,EC45,RIE,0,+ )\n @MN(BRASL,C050,RIL,0,+ )\n @MN(CKSM,B241,RRE,0,+ )\n @MN(KM,B92E,RRE,0,+ )\n @MN(KMC,B92F,RRE,0,+ )\n @MN(CGR,B920,RRE,0,+ )\n @MN(CGFR,B930,RRE,0,+ )\n @MN(CY,E359,RXY,0,+ )\n @MN(CG,E320,RXY,0,+ )\n @MN(CGF,E330,RXY,0,+ )\n @MN(CFC,B21A,S2,0,+ )\n @MN(CSY,EB14,RSY,0,+ )\n @MN(CSG,EB30,RSY,0,+ )\n @MN(CDSY,EB31,RSY,0,+ )\n @MN(CDSG,EB3E,RSY,0,+ )\n @MN(CHY,E379,RXY,0,+ )\n @MN(CLGR,B921,RRE,0,+ )\n @MN(CLGFR,B931,RRE,0,+ )\n @MN(CLY,E355,RXY,0,+ )\n @MN(CLG,E321,RXY,0,+ )\n @MN(CLGF,E331,RXY,0,+ )\n @MN(CLIY,EB55,SIY,0,+ )\n @MN(CLMY,EB21,RSY1,0,+ )\n @MN(CLMH,EB20,RSY1,0,+ )\n @MN(CLCLE,A9,RS1,0,+ )\n @MN(CLCLU,EB8F,RSY,0,+ )\n @MN(CLST,B25D,RRE,0,+ )\n @MN(CUSE,B257,RRE,0,+ )\n @MN(CMPSC,B263,RRE,0,+ )\n @MN(KIMD,B93E,RRE,0,+ )\n @MN(KLMD,B93F,RRE,0,+ )\n @MN(KLMD,B93F,RRE,0,+ )\n @MN(KMAC,B91E,RRE,0,+ )\n @MN(CVBY,E306,RXY,0,+ )\n @MN(CVBG,E30E,RXY,0,+ )\n @MN(CVDY,E326,RXY,0,+ )\n @MN(CVDG,E32E,RXY,0,+ )\n @MN(CUUTF,B2A6,RRE,0,+ )\n @MN(CUTFU,B2A7,RRE,0,+ )\n @MN(CU14,B9B0,RRE,0,+ )\n @MN(CU24,B9B1,RRE,0,+ )\n @MN(CU41,B9B2,RRE,0,+ )\n @MN(CU42,B9B3,RRE,0,+ )\n @MN(DLR,B997,RRE,0,+ )\n @MN(DLGR,B987,RRE,0,+ )\n @MN(DL,E397,RXY,0,+ )\n @MN(DLG,E387,RXY,0,+ )\n @MN(DSGR,B90D,RRE,0,+ )\n @MN(DSGFR,B91D,RRE,0,+ )\n @MN(DSG,E30D,RXY,0,+ )\n @MN(DSGF,E31D,RXY,0,+ )\n @MN(XGR,B982,RRE,0,+ )\n @MN(XY,E357,RXY,0,+ )\n @MN(XG,E382,RXY,0,+ )\n @MN(XIY,EB57,SIY,0,+ )\n @MN(EPSW,B98D,RRE,0,+ )\n @MN(ICY,E373,RXY,0,+ )\n @MN(ICMY,EB81,RSY,0,+ )\n @MN(ICMH,EB80,RSY,0,+ )\n @MN(LGR,B904,RRE,0,+ )\n @MN(LGFR,B914,RRE,0,+ )\n @MN(LY,E358,RXY,0,+ )\n @MN(LG,E304,RXY,0,+ )\n @MN(LGF,E314,RXY,0,+ )\n @MN(LAMY,EB9A,RSY,0,+ )\n @MN(LAY,E371,RXY,0,+ )\n @MN(LARL,C000,RIL,0,+ )\n @MN(LTGR,B902,RRE,0,+ )\n @MN(LTGFR,B912,RRE,0,+ )\n @MN(LCGR,B903,RRE,0,+ )\n @MN(LCGFR,B913,RRE,0,+ )\n @MN(LLGFR,B916,RRE,0,+ )\n @MN(LLGTR,B917,RRE,0,+ )\n @MN(LNGR,B901,RRE,0,+ )\n @MN(LNGFR,B911,RRE,0,+ )\n @MN(LPGR,B900,RRE,0,+ )\n @MN(LPGFR,B910,RRE,0,+ )\n @MN(MLR,B996,RRE,0,+ )\n @MN(MLGR,B986,RRE,0,+ )\n @MN(MSR,B252,RRE,0,+ )\n @MN(MSGR,B90C,RRE,0,+ )\n @MN(MSGFR,B91C,RRE,0,+ )\n @MN(OGR,B981,RRE,0,+ )\n @MN(LRVR,B91F,RRE,0,+ )\n @MN(LRVGR,B90F,RRE,0,+ )\n @MN(LB,E376,RXY,0,+ )\n @MN(LGB,E377,RXY,0,+ )\n @MN(LHY,E378,RXY,0,+ )\n @MN(LGH,E315,RXY,0,+ )\n @MN(LLGF,E316,RXY,0,+ )\n @MN(LLGT,E317,RXY,0,+ )\n @MN(LLGC,E390,RXY,0,+ )\n @MN(LLGH,E391,RXY,0,+ )\n @MN(IIHH,A500,RI,0,+ )\n @MN(IIHL,A510,RI,0,+ )\n @MN(IILH,A520,RI,0,+ )\n @MN(IILL,A530,RI,0,+ )\n @MN(OIHH,A580,RI,0,+ )\n @MN(OIHL,A590,RI,0,+ )\n @MN(OILH,A5A0,RI,0,+ )\n @MN(OILL,A5B0,RI,0,+ )\n @MN(LLIHH,A5C0,RI,0,+ )\n @MN(LLIHL,A5D0,RI,0,+ )\n @MN(LLILH,A5E0,RI,0,+ )\n @MN(LLILL,A5F0,RI,0,+ )\n @MN(LMY,EB98,RSY,0,+ )\n @MN(LMG,EB04,RSY,0,+ )\n @MN(LMD,EF,SS4,0,+ )\n @MN(LMH,EB96,RSY,0,+ )\n @MN(LPQ,E38F,RXY,0,+ )\n @MN(LRVH,E31F,RXY,0,+ )\n @MN(LRV,E31E,RXY,0,+ )\n @MN(LRVG,E30F,RXY,0,+ )\n @MN(ML,E396,RXY,0,+ )\n @MN(MLG,E386,RXY,0,+ )\n @MN(MS,71,RX,0,+ )\n @MN(MSY,E351,RXY,0,+ )\n @MN(MSG,E30C,RXY,0,+ )\n @MN(MSGF,E31C,RXY,0,+ )\n @MN(OY,E356,RXY,0,+ )\n @MN(OG,E381,RXY,0,+ )\n @MN(OIY,EB56,SIY,0,+ )\n @MN(MVIY,EB52,SIY,0,+ )\n @MN(MVCLE,A8,RS1,0,+ )\n @MN(MVCLU,EB8E,RSY,0,+ )\n @MN(MVST,B255,RRE,0,+ )\n @MN(SRST,B25E,RRE,0,+ )\n @MN(SRSTU,B9BE,RRE,0,+ )\n @MN(RLL,EB1D,RSY,0,+ )\n @MN(RLLG,EB1C,RSY,0,+ )\n @MN(TAM,010B,E,0,+ )\n @MN(SAM24,010C,E,0,+ )\n @MN(SAM31,010D,E,0,+ )\n @MN(SAM64,010E,E,0,+ )\n @MN(SLAG,EB0B,RSY,0,+ )\n @MN(SLLG,EB0D,RSY,0,+ )\n @MN(SRAG,EB0A,RSY,0,+ )\n @MN(SRLG,EB0C,RSY,0,+ )\n @MN(STY,E350,RXY,0,+ )\n @MN(STG,E324,RXY,0,+ )\n @MN(STAMY,EB9B,RSY,0,+ )\n @MN(STCY,E372,RXY,0,+ )\n @MN(STCMY,EB2D,RSY1,0,+ )\n @MN(STCMH,EB2C,RSY1,0,+ )\n @MN(STCKE,B278,S2,0,+  )\n @MN(STHY,E370,RXY,0,+ )\n @MN(STMY,EB90,RSY,0,+ )\n @MN(STMG,EB24,RSY,0,+ )\n @MN(STMH,EB26,RSY,0,+ )\n @MN(STPQ,E38E,RXY,0,+ )\n @MN(STRVH,E33F,RXY,0,+ )\n @MN(STRV,E33E,RXY,0,+ )\n @MN(STRVG,E32F,RXY,0,+ )\n @MN(SGR,B909,RRE,0,+ )\n @MN(SGFR,B919,RRE,0,+ )\n @MN(SY,E35B,RXY,0,+ )\n @MN(SG,E309,RXY,0,+ )\n @MN(SGF,E319,RXY,0,+ )\n @MN(SHY,E37B,RXY,0,+ )\n @MN(SLGR,B90B,RRE,0,+ )\n @MN(SLGFR,B91B,RRE,0,+ )\n @MN(SLY,E35F,RXY,0,+ )\n @MN(SLG,E30B,RXY,0,+ )\n @MN(SLGF,E31B,RXY,0,+ )\n @MN(SLBR,B999,RRE,0,+ )\n @MN(SLBGR,B98B,RRE,0,+ )\n @MN(SLB,E399,RXY,0,+ )\n @MN(SLBG,E389,RXY,0,+ )\n @MN(TMY,EB51,SIY,0,+    )\n @MN(TRTR,D0,SS2,0,+     )\n @MN(TRE,B2A5,RRE,0,+    )\n @MN(TROO,B993,RRE,0,+   )\n @MN(TROT,B992,RRE,0,+   )\n @MN(TRTO,B991,RRE,0,+   )\n @MN(TRTT,B990,RRE,0,+   )\n @MN(BSG,B258,RRE,0,+    )\n @MN(CSP,B250,RRE,0,+    )\n @MN(CSPG,B98A,RRE,0,+   )\n @MN(ESEA,B99D,RRE1,0,+  )\n @MN(EPAIR,B99A,RRE1,0,+ )\n @MN(ESAIR,B99A,RRE1,0,+ )\n @MN(EREGG,B90E,RRE,0,+  )\n @MN(IDTE,B98E,RRF,0,+  )\n @MN(LCTLG,EB2F,RSY,0,+  )\n @MN(LPSWE,B2B2,S2,0,+  )\n @MN(LRAY,E313,RXY,0,+  )\n @MN(LRAG,E303,RXY,0,+  )\n @MN(LURAG,B905,RRE,0,+ )\n @MN(PGIN,B22E,RRE,0,+  )\n @MN(PGOUT,B22F,RRE,0,+ )\n @MN(PTI,B99E,RRE,0,+   )\n @MN(RP,B277,S2,0,+     )\n @MN(SACF,B279,S2,1,+   )\n @MN(SCKPF,0107,E,1,+   )\n @MN(SSAIR,B99F,RRE1,0,+ )\n @MN(STCTG,EB25,RSY,0,+  )\n @MN(STFL,B2B1,S2,0,+   )\n @MN(STRAG,E502,SSE,0,+   )\n @MN(STSI,B27D,S2,0,+   )\n @MN(STURA,B246,RRE,0,+ )\n @MN(STURG,B925,RRE,0,+ )\n @MN(TRACG,EB0F,RSY,0,+ )\n @MN(TRAP2,01FF,E,0,+   )\n @MN(TRAP4,B2FF,S2,0,+   )\n\n    CMDNUM(5) = @I;\n\n END REASMI;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REASMIDP": {"ttr": 1544, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x1e\\x00\\x00\\x00\\x00\\x976_\\x00\\x976_\\x00I\\x00\\x1a\\x00\\x1a\\x00\\x00\\xc3\\xc8@@@@@@@@'", "ispf": {"version": "30.00", "flags": 0, "createdate": "1997-12-31T00:00:00", "modifydate": "1997-12-31T00:49:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "CH"}, "text": ")BODY\n      /**************************************************/\n      /*                                                */\n      /* This panel is unexecutable.                    */\n      /* You must fill password field(s) and date field */\n      /*                                                */\n      /* If you'll not do so MVS REASM will not be      */\n      /* accessible at your computer.                   */\n      /*                                                */\n      /**************************************************/\n)INIT\n  .RESP = END\n)PROC\n  &REAPWD01  = '47715206'      /* PASSWORD  1 FOR EC 1037 EXPRESS     */\n  &REAPWD02  = '45765703'      /* PASSWORD  2 FOR    4381 mmf         */\n  &REAPWD03  = '45765704'      /* PASSWORD  3 FOR    4381 mmf         */\n  &REAPWD04  = ''              /* PASSWORD  4 FOR ....................*/\n  &REAPWD05  = ''              /* PASSWORD  5 FOR ....................*/\n  &REAPWD06  = ''              /* PASSWORD  6 FOR ....................*/\n  &REAPWD07  = ''              /* PASSWORD  7 FOR ....................*/\n  &REAPWD08  = ''              /* PASSWORD  8 FOR ....................*/\n  &REAPWD09  = ''              /* PASSWORD  9 FOR ....................*/\n  &REAPWD10  = ''              /* PASSWORD 10 FOR ....................*/\n\n  &REAJDATE  = '99.320'        /* EXPIRATION DATE (LIMIT DATE)        */\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "REASMLB": {"ttr": 1546, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x1e\\x01\\x00H\\x00\\x976_\\x01\\x06\\x01?\\x15X\\x007\\x007\\x00\\x02\\xd7\\xc7\\xd4\\xe5\\xc3@@@@@'", "ispf": {"version": "30.01", "flags": 0, "createdate": "1997-12-31T00:00:00", "modifydate": "2006-01-13T15:58:48", "lines": 55, "newlines": 55, "modlines": 2, "user": "PGMVC"}, "text": "*PROCESS M,OPT(TIME),S,GN;\n /*\n//PGMVCM JOB 'IBI','V CHERNYAK',REGION=1000K,NOTIFY=PGMVC,CLASS=A,\n//        MSGCLASS=A,MSGLEVEL=(1,1)\n//PROCLIB  JCLLIB ORDER=PGMVYC.REASM.PLI\n//        EXEC PLIXCL,PARM.LKED='LET,NCAL'\n//PLI.SYSIN     DD DSN=PGMVYC.REASM.PLI(REASMLB),DISP=SHR\n//PLI.SYSLIB    DD DSN=PGMVYC.REASM.PLI,DISP=SHR\n//LKED.SYSLMOD  DD DSN=PGMVYC.REASM.SUBLOAD(REASMLB),DISP=SHR\n//\n */\n REASMLB:\n    PROC (DDNAME) REORDER RETURNS(CHAR(8) VAR);\n\n     DCL  DDNAME   CHAR(8);\n     DCL  DID      CHAR(8);\n     DCL  MLBMEM    CHAR(8) VAR INIT('?');\n     DCL  MEM       CHAR(8);\n     DCL  ZPDFREL   CHAR(8);\n     DCL  REL       BIN FIXED INIT(0);\n     DCL  F8        BIN FIXED(31) INIT(8);\n     DCL  #F8       BIN FIXED(31);\n\n     DCL     ISPLINK ENTRY EXT OPTIONS(ASM INTER RETCODE),\n            (SUBSTR,UNSPEC,DIM,BIN,PLIRETV) BUILTIN;\n\n     #F8 = 8;\n     CALL ISPLINK ('VCOPY ', 'ZPDFREL ', #F8, ZPDFREL, 'MOVE ');\n     IF  PLIRETV() = 0 THEN\n         REL = BIN(SUBSTR(ZPDFREL,5,1));\n\n     CALL ISPLINK ('VDEFINE ', 'DID     ', DID,     'CHAR  ',  F8 );\n\n     CALL ISPLINK ('LMINIT ', 'DID', ' ', ' ', ' ', ' ', ' ', ' ',\n                   ' ', DDNAME, ' ', ' ', 'SHR', ' ');\n     IF PLIRETV() = 0 THEN DO;\n        CALL ISPLINK ('LMOPEN  ', DID, 'INPUT ', ' ', ' ' );\n        IF REL>=3 THEN\n           CALL ISPLINK ('ADDPOP  ', ' ', ' ', ' ');\n        CALL ISPLINK ('LMMDISP ', DID, 'DISPLAY ', '*');\n        IF PLIRETV() = 0 THEN DO;\n           #F8 = 8;\n           CALL ISPLINK ('VCOPY ',   'ZLMEMBER ', #F8, MEM,'MOVE ');\n           MLBMEM = MEM;\n        END;\n        IF MLBMEM='' THEN MLBMEM = '?';\n        IF REL>=3 THEN\n           CALL ISPLINK ('REMPOP  ', ' ');\n        CALL ISPLINK ('LMCLOSE ', DID);\n        CALL ISPLINK ('LMFREE  ', DID);\n     END;\n\n     CALL ISPLINK ('VDELETE ','(DID)' );\n     RETURN(MLBMEM);\n END REASMLB;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REASMLIV": {"ttr": 1548, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x1e\\x01\\x00H\\x00\\x976_\\x01\\x06\\x01?\\x16\\x05\\x00\\xce\\x00\\xce\\x00\\x03\\xd7\\xc7\\xd4\\xe5\\xc3@@@@@'", "ispf": {"version": "30.01", "flags": 0, "createdate": "1997-12-31T00:00:00", "modifydate": "2006-01-13T16:05:48", "lines": 206, "newlines": 206, "modlines": 3, "user": "PGMVC"}, "text": "*PROCESS M,OPT(TIME),S,GN;\n /*\n//PGMVCI  JOB 'IBI','V CHERNYAK',REGION=1000K,NOTIFY=PGMVC,CLASS=A,\n//        MSGCLASS=A,MSGLEVEL=(1,1)\n//PROCLIB  JCLLIB ORDER=PGMVYC.REASM.PLI\n//        EXEC PLIXCL,PARM.LKED='LET,NCAL'\n//PLI.SYSIN     DD DSN=PGMVYC.REASM.PLI(REASMLIV),DISP=SHR\n//PLI.SYSLIB    DD DSN=PGMVYC.REASM.PLI,DISP=SHR\n//LKED.SYSLMOD  DD DSN=PGMVYC.REASM.SUBLOAD(REASMLIV),DISP=SHR\n//\n */\n %SKIP;\n /*********************************************************************/\n /*  FILL LIVSHIC - BLOCK                                             */\n /*********************************************************************/\n $INTLIV:\n      PROC(N,LBLOCK_START,CONTROL);\n DCL  N            CHAR(8),\n      LBLOCK_START PTR,\n      CONTROL      CHAR(8),\n      P            PTR,\n      NULL         BUILTIN;\n DCL  REASMLD      ENTRY(CHAR(8), BIN FIXED(31), CHAR(8))\n                   EXT OPTIONS(ASM INTER);\n %NOPRINT;\n %INCLUDE REASMBAS;\n %PRINT;\n\n     P=LBLOCK_START;\n     DO WHILE(P \u00ac= NULL);\n        IF P->LBLOCK.NAME=N THEN  RETURN;\n        P= P->LBLOCK.NEXT;\n     END;\n\n     ALLOCATE LBLOCK;\n     LBLOCK.NEXT   = LBLOCK_START;\n     LBLOCK_START  = LBLOCK_PTR;\n     LBLOCK.NAME   = N;\n     CALL REASMLD(N,LBLOCK.ADR,CONTROL);\n     LBLOCK.ADUMMY = NULL;\n     LBLOCK.MACRO  = '';\n END $INTLIV;\n\n*PROCESS M,OPT(TIME),S,GN;\n /*********************************************************************/\n /*  DELETE LIVSHIC BLOCK                                             */\n /*********************************************************************/\n $DELLIV:\n      PROC(N,LBLOCK_START);\n DCL  N            CHAR(8),\n      LBLOCK_START PTR,\n      NULL         BUILTIN,\n      (P,Q)        PTR INIT(NULL);\n DCL  REASMDL ENTRY(CHAR(8)) EXT OPTIONS(ASM INTER);\n %NOPRINT;\n %INCLUDE REASMBAS;\n %PRINT;\n\n     LBLOCK_PTR = LBLOCK_START;\n     DO WHILE(LBLOCK_PTR \u00ac= NULL);\n        IF LBLOCK.NAME = N THEN DO;\n           IF P \u00ac= NULL THEN P->LBLOCK.NEXT = LBLOCK.NEXT;\n                        ELSE LBLOCK_START   = LBLOCK.NEXT;\n           CALL REASMDL(N);\n           P = LBLOCK.ADUMMY;\n           DO WHILE(P \u00ac= NULL);\n              Q = P;\n              P = P->DUMMY.NEXT;\n              FREE Q->DUMMY;\n           END;\n           FREE LBLOCK;\n           RETURN;\n        END;\n        P = LBLOCK_PTR;\n        LBLOCK_PTR = LBLOCK.NEXT;\n     END;\n END $DELLIV;\n\n*PROCESS M,OPT(TIME),S,GN;\n /*********************************************************************/\n /*  FIND LAME IN LIVSHIC BLOCK BY OFFSET                             */\n /*********************************************************************/\n $LFIND:\n     PROC(LBLOCK_PTR,OFFSET,$XREF,#COM,$PUTXRF)\n          RETURNS(CHAR(20) VAR);\n DCL    OFFSET       BIN FIXED,\n        $XREF        BIT(1),\n        #COM         CHAR(*) VAR,\n        $PUTXRF      ENTRY(CHAR(*)),\n        (I,K)        BIN FIXED INIT(0),\n        (CUR,TOTAL)  BIN FIXED INIT(0),\n        INITOFF      BIN FIXED INIT(0),    /* INITIAL OFFSET */\n        ROFF         BIN FIXED,\n        GPTR         BIN FIXED(31) INIT(0),\n        CM           CHAR(80) VAR;\n\n DCL 1   LEL BASED(LEL_PTR) ALIGNED,\n      2  NAME          CHAR(12),\n      2  LTYPE         CHAR(1),\n      2  RS01          CHAR(1),\n      2  ENTOFF        BIN FIXED,    /* OFFSET FOR ENTRY ELEMENT */\n      2  LEN           BIN FIXED,\n      2  OFF           BIN FIXED,\n      2  COMLEN        BIN FIXED(31),\n      2  COMMENT       CHAR(80),\n         LEL_PTR       PTR,\n         LEL_START     PTR,\n         #LEL_PTR BIN FIXED(31) BASED(#PTR01),\n         $DSECT        CHAR(1) STATIC INT INIT('J'),\n         $ENTRY        CHAR(1) STATIC INT INIT('%'),\n         #PTR01        PTR;\n\n DCL     $NEXTEL  ENTRY(CHAR(*) VAR) EXT RETURNS(CHAR(100) VAR),\n         $DIGIT   ENTRY(BIN FIXED(31)) EXT RETURNS(CHAR(16) VAR),\n         (INDEX,SUBSTR,UNSPEC,ADDR,LENGTH,TRANSLATE) BUILTIN;\n %NOPRINT;\n %INCLUDE REASMBAS;\n %PRINT;\n\n     #PTR01 = ADDR(LEL_PTR);\n\n     IF LBLOCK.ADR \u00ac= 0 THEN DO;\n        #LEL_PTR=LBLOCK.ADR;\n        IF LTYPE \u00ac= $DSECT &  LTYPE \u00ac= $ENTRY &\n           LTYPE \u00ac= '9'    &  LTYPE \u00ac= 'N'    &  LTYPE \u00ac= 'U'\n           THEN RETURN('');\n\n        #LEL_PTR = LBLOCK.ADR;\n        DO WHILE ((LTYPE \u00ac= $DSECT) & (LTYPE \u00ac= $ENTRY));\n           IF COMLEN<0 THEN DO;\n              SIGNAL ERROR;\n              ON ERROR SNAP SYSTEM;\n              STOP;\n           END;\n           K=20+4+COMLEN;\n           #LEL_PTR = #LEL_PTR + K;\n        END;\n\n        TOTAL = LEL.LEN;\n        IF LTYPE = $ENTRY THEN INITOFF = ENTOFF;\n        IF COMLEN>0 THEN LBLOCK.MACRO = SUBSTR(COMMENT,1,COMLEN);\n        LEL_START = LEL_PTR;\n\n        DO WHILE(CUR < TOTAL);\n           ROFF = LEL.OFF - INITOFF;\n           IF LTYPE \u00ac= 'U'   &  LTYPE \u00ac= 'N' &  LTYPE \u00ac= 'L' &\n              LTYPE \u00ac= $DSECT & LTYPE \u00ac= $ENTRY &\n              OFFSET >= ROFF  &  OFFSET < ROFF+LEL.LEN\n              THEN DO;\n                 GPTR = #LEL_PTR;\n                 IF OFFSET=ROFF & LEL_START\u00ac=LEL_PTR THEN\n                    CUR = TOTAL;\n              END;\n           IF COMLEN<0 THEN DO;\n              SIGNAL ERROR;\n              ON ERROR SNAP SYSTEM;\n              STOP;\n           END;\n           K = 20+4+COMLEN;\n           CUR = CUR + K;\n           #LEL_PTR = #LEL_PTR+K;\n        END;\n\n        IF GPTR \u00ac= 0 THEN DO;\n           #LEL_PTR = GPTR;\n           ROFF = LEL.OFF - INITOFF;\n           CM = SUBSTR(COMMENT,1,COMLEN);\n           /************************************/\n           /*               NON-FORMALS        */\n           /************************************/\n           CM=TRANSLATE(CM,'     ','_-.,;');\n           /*************************************/\n           IF CM \u00ac= '' THEN DO;\n              DO WHILE(SUBSTR(CM,LENGTH(CM),1)=' ');\n                 CM=SUBSTR(CM,1,LENGTH(CM)-1);\n              END;\n              DO WHILE(SUBSTR(CM,1,1)=' ');\n                 CM=SUBSTR(CM,2);\n              END;\n              I=INDEX(CM,'  ');\n              DO WHILE(I & CM\u00ac='');\n                 SUBSTR(CM,I,2) = ' ';\n                 I=INDEX(CM,'  ');\n              END;\n           END;\n           ELSE  CM='';\n           #COM = CM;\n           IF $XREF THEN\n              CALL $PUTXRF(LEL.NAME);\n           IF OFFSET > ROFF THEN\n              RETURN($NEXTEL(LEL.NAME) || '+' ||\n                     $DIGIT(OFFSET-ROFF) );\n           ELSE\n              RETURN($NEXTEL(LEL.NAME));\n        END;\n     END;\n\n     IF OFFSET=0 THEN DO;\n        IF $XREF THEN\n           CALL $PUTXRF(SUBSTR(LBLOCK.NAME,2));\n        RETURN($NEXTEL(SUBSTR(LBLOCK.NAME,2)));\n     END;\n\n     RETURN('');\n\n END $LFIND;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REASMM": {"ttr": 1795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x1e;\\x00B\\x00\\x976_\\x01\\x06\\x02\\x1f\\x16\\x01\\x12c\\x11@\\x01\\xeb\\xd7\\xc7\\xd4\\xe5\\xc3@@@@@'", "ispf": {"version": "30.59", "flags": 0, "createdate": "1997-12-31T00:00:00", "modifydate": "2006-01-21T16:01:42", "lines": 4707, "newlines": 4416, "modlines": 491, "user": "PGMVC"}, "text": "*PROCESS FLAG(E),NEST,OPT(TIME),M,NOINSOURCE,GN,S;\n /*\n//PGMVCR  JOB 'IBI','V CHERNYAK',REGION=6M,NOTIFY=PGMVC,CLASS=A,\n//        MSGCLASS=A,MSGLEVEL=(0,0)\n//PROCLIB  JCLLIB ORDER=PGMVYC.REASM.PLI\n//*\n//COMPILE EXEC PLIXCL,PARM.LKED='LET,NCAL'\n//PLI.SYSLIN  DD UNIT=VIO,SPACE=(TRK,(50,50)),DISP=(,PASS),\n//    DSN=&&LOADSET\n//PLI.SYSIN     DD DSN=PGMVYC.REASM.PLI(REASMM),DISP=SHR\n//PLI.SYSLIB    DD DSN=PGMVYC.REASM.PLI,DISP=SHR\n//LKED.SYSLMOD  DD UNIT=VIO,SPACE=(CYL,(5,1,1)),DISP=(,PASS),\n//     DCB=(BLKSIZE=13030,RECFM=U,DSORG=PO),DSN=&&LOAD(REASMM)\n//*\n//LKED2    EXEC PGM=IEWL,PARM='LIST,LET'\n//SYSPRINT DD   SYSOUT=*\n//SYSUT1   DD   UNIT=VIO,SPACE=(TRK,(30,30))\n//SYSLIB   DD   DSN=CEE.SCEELKED,DISP=SHR\n//         DD   DSN=PLI.V2R3M0.PLIBASE,DISP=SHR\n//         DD   DSN=PLI.V2R3M0.SIBMBASE,DISP=SHR\n//         DD   DSN=ISP.SISPLOAD,DISP=SHR\n//         DD   DSN=&&LOAD,DISP=(OLD,DELETE)\n//         DD   DSN=PGMVYC.REASM.SUBLOAD,DISP=SHR\n//*SYSLMOD  DD   DSN=PGMVC.TEST.LOAD,DISP=SHR\n//SYSLMOD  DD   DSN=PGMVYC.REASM.LOAD,DISP=SHR\n//SYSLIN   DD   *\n           INCLUDE SYSLIB(REASMM)\n           INCLUDE SYSLIB(REASCNV)\n           INCLUDE SYSLIB(REASMLIV)\n           INCLUDE SYSLIB(REASQPW$)\n           ENTRY PLISTART\n           NAME  REASM(R)\n//COMPRESS  EXEC  PGM=IEBCOPY\n//SYSPRINT  DD    SYSOUT=*\n//SYSIN     DD    DUMMY\n//SYSUT1    DD    DSN=*.LKED2.SYSLMOD,DISP=SHR\n//SYSUT2    DD    DSN=*.LKED2.SYSLMOD,DISP=SHR\n//\n */\n\n\n /*  ----------------------------------------------------------- */\n /*  MVS/ESA REASM COPYRIGHT (C) 2006, BY VALENTIN CHERNYAK      */\n /*  ----------------------------------------------------------- */\n\n REASM:\n     PROC(PARM) RED OPTIONS(MAIN);\n\n     DCL TEXT    (256000) CHAR(1),\n         TEXTCOPY(256000) CHAR(1);\n     DCL TEXTIND     BIN FIXED(31) INIT(0);\n\n     %PRINT;\n     %INCLUDE REASMMAC;    /* GENERIC MACROS */\n     %INCLUDE REASMD;      /* VARIABLES      */\n     %INCLUDE REASMCMD;    /* COMMAND ARR    */\n     %INCLUDE REASMBAS;    /* DATA BASE      */\n     %INCLUDE REASMSVC;    /* SVC NUMBERS    */\n     %INCLUDE REASMHRD;    /* HRD CONTS      */\n     %PRINT;\n\n     ON ERROR SNAP GOTO $ERROR;\n\n     IF PARM\u00ac='' THEN DO;\n     END;\n\n     CALL REASMTL(GOODA);\n\n     CALL REASMI(@,CMDSET,@COMPT);\n\n     CALL REASPRF('NODISPLAY',       /* READ PROFILE VARIABLES */\n          $AUTO, $DSOFF, $REM, #ABSA, #ABSB, LINELEN, REMTIME,\n          OS,    PC,     FC );\n\n %NOPRINT;\n     %INCLUDE SCREEN;\n     %INCLUDE REASMSCR;\n %PRINT;\n\n     CALL ISPLINK ('VDEFINE ', 'FIELD    ', FIELD,    'CHAR ',  8);\n     CALL ISPLINK ('VDEFINE ', 'POS      ', POS,      'FIXED ', 4);\n     CALL ISPLINK ('VDEFINE ', 'LVL      ', LVL,      'FIXED ', 4);\n     CALL ISPLINK ('VDEFINE ', 'MEMOUT   ', MEMOUT,   'CHAR  ', 8);\n     CALL ISPLINK ('VDEFINE ', 'FINDTXT  ', FINDTXT,  'CHAR  ', 30);\n     CALL ISPLINK ('VDEFINE ', 'IV       ', IV,       'CHAR  ', 4);\n     CALL ISPLINK ('VDEFINE ', 'PDFCHAR  ', PDFCHAR,  'CHAR  ', 15);\n     CALL ISPLINK ('VDEFINE ', 'PDFBYTE  ', PDFBYTE,  'CHAR  ', 1);\n     CALL ISPLINK ('VDEFINE ', 'REASMVER ', REASMVER, 'CHAR  ', 3);\n     CALL ISPLINK ('VDEFINE ', 'R01DSN   ', DSN,      'CHAR  ', 44);\n\n     CALL ISPLINK ('VDEFINE ', 'REAPWD01 ', PASS(01), 'CHAR  ', 8);\n     CALL ISPLINK ('VDEFINE ', 'REAPWD02 ', PASS(02), 'CHAR  ', 8);\n     CALL ISPLINK ('VDEFINE ', 'REAPWD03 ', PASS(03), 'CHAR  ', 8);\n     CALL ISPLINK ('VDEFINE ', 'REAPWD04 ', PASS(04), 'CHAR  ', 8);\n     CALL ISPLINK ('VDEFINE ', 'REAPWD05 ', PASS(05), 'CHAR  ', 8);\n     CALL ISPLINK ('VDEFINE ', 'REAPWD06 ', PASS(06), 'CHAR  ', 8);\n     CALL ISPLINK ('VDEFINE ', 'REAPWD07 ', PASS(07), 'CHAR  ', 8);\n     CALL ISPLINK ('VDEFINE ', 'REAPWD08 ', PASS(08), 'CHAR  ', 8);\n     CALL ISPLINK ('VDEFINE ', 'REAPWD09 ', PASS(09), 'CHAR  ', 8);\n     CALL ISPLINK ('VDEFINE ', 'REAPWD10 ', PASS(10), 'CHAR  ', 8);\n     CALL ISPLINK ('VDEFINE ', 'REAJDATE ', JDAT,     'CHAR  ', 6);\n     CALL ISPLINK ('VDEFINE ', 'DYNMSG   ', DYNMSG,   'CHAR  ', 256);\n\n     CALL ISPLINK ('DISPLAY ', 'REASMIDP '); /* GET IDP PARMS */\n     CALL CALCULATE_LVL;\n\n     CALL DYNAM(DYNWORK, 'INIT ', DYNMSG);\n     CALL DYNAM(DYNWORK, 'ALLOC ', 'DD=REAPRINT;',\n                         'PRIM=5 SEC=10 BLKSIZE=3000 TRK;');\n\n     OPEN FILE(SYSPRINT) TITLE('REAPRINT') PRINT;\n     /*\n     PUT SKIP EDIT('*** MVS/ESA REASM ', REASMVER,\n         '. COPYRIGHT (C) 1985,1987,1991,2006   CHERNYAK VALENTIN')(A);\n     */\n     ON ENDPAGE(SYSPRINT) BEGIN;\n        #PAGE=#PAGE+1;\n        PUT PAGE    EDIT('--- MVS/ESA REASM ',\n                      REASMVER, '   ', REASM02_DSN,'PAGE ',#PAGE)\n                      (A,A,A,A,COL(80),A,F(4));\n        PUT SKIP(3);\n     END;\n\n     DYNINFO.DSNAME = '';\n     DYNINFO.DSORG  = '0'B;\n     CALL DYNAM(DYNWORK, 'INFO ', DYNINFO, 'DD=' || SAVE || ';');\n     DSRG           = DYNINFO.DSORG;\n     DSNSAVE        = DYNINFO.DSNAME;\n     MEMSAVE        = DYNINFO.MEMBER;\n     VOLSAVE        = '';\n     IF DSNSAVE     = 'NULLFILE ' THEN DSRG='0'B;\n\n     /*******************************/\n     /* GET MEMBER & CSECT NAMES    */\n     /*******************************/\n L_AGAIN:\n     CALL FREETEXT();\n     @@FREE_CTL (ESD_ARRAY);\n     @@FREE_LIST(RLD);\n     CALL $FREE;\n\n     I = REASLOA('ALLOC', DSN, VOL, MEMBER, CSECT, ' ');\n\n     /********************************************/\n     /*  R E T U R N         HANDLING            */\n     /********************************************/\n     IF I \u00ac= 0 THEN DO;       /* END KEY PRESSED */\n $RETURN: CALL DYNAM(DYNWORK, 'END ');\n          RETURN;\n     END;\n\n     /********************************************/\n     /*  R E C O V E R Y     HANDLING            */\n     /********************************************/\n     IF REASM02_PRIMARY = 'R' THEN DO;\n        IF DSRG=PO | DSRG=POU THEN DO;\n           CALL $REALLOC(SAVE, DSNSAVE, '', '');\n           IF CSECT='' THEN DO;\n              CSECT = REASMLB(SAVE);\n              IF CSECT='?' | CSECT='' THEN DO;\n                 #CUR(CSECT,1);\n                 CALL ISPLINK('SETMSG ', 'REAS055 ');\n                 GOTO L_AGAIN;\n              END;\n           END;\n           MEMSAVE = CSECT;\n           CALL $REALLOC(SAVE, DSNSAVE, MEMSAVE, '');\n        END;\n        ON ERROR GOTO $REC_ERR;\n        CALL REASMR;\n        IF PLIRETV()\u00ac=0 THEN DO;\n $REC_ERR: CLOSE FILE(SAVEFL);\n           CALL ISPLINK('SETMSG ', 'REAS056 ');\n           ON ERROR SNAP GOTO $ERROR;\n           GOTO L_AGAIN;\n        END;\n        ON ERROR SNAP GOTO $ERROR;\n        $CONF    =   '0'B;\n        REMCOUNT =      0;\n        LVL      =      MAXLVL-3;\n\n        DSN = '''' || $NEXTEL(DSN) || '''';\n        CALL ISPLINK ('VREPLACE', 'DSN   ', BIN(44,31), DSN   );\n        DSN = SUBSTR(DSN,2,INDEX(DSN,' ')-3);\n        CALL ISPLINK ('VREPLACE', 'MEM   ', BIN( 8,31), MEMBER);\n        CALL ISPLINK ('VREPLACE', 'CSECT ', BIN( 8,31), CSECT );\n        GOTO $FORM_REASM02;\n     END;\n\n     /********************************************/\n     /*  N E W   L I B R A R Y    HANDLING       */\n     /********************************************/\n     MEMBER = TRANSLATE(MEMBER,'{','\u00a2');\n     CALL $OPEN;\n\n     IF REASM02_PRIMARY='M' | CSECT = '' THEN DO;\n L_ESD: CSECT = REASESD(ESD_ARRAY, DIM_ESD_ARRAY);\n        ESDLOOP = '1'B;\n        IF CSECT = '........' THEN DO;\n           ESDLOOP = '0'B;\n           CSECT = ''; GOTO L_AGAIN;\n        END;\n        CALL ISPLINK ('VREPLACE', 'CSECT ', BIN(8,31), CSECT);\n     END;\n     MEMOUT = CSECT;\n\n     CALL $CSECT;\n\n     IF ESDID = 0 THEN DO;       /* CSECT WAS NOT FOUND OR TOO LONG */\n        IF TEXTLEN = 0 THEN\n           CALL ISPLINK('SETMSG ', 'REAS062 ');\n        ELSE\n           CALL ISPLINK('SETMSG ', 'REAS063 ');\n        GOTO L_AGAIN;\n     END;\n\n     $REM   ='0'B;\n     CALL   $INITDSC;\n %PAGE;\n\n     IF DSRG=PO | DSRG=POU THEN DO;\n        MEMSAVE = CSECT;\n        CALL $REALLOC(SAVE,DSNSAVE,MEMSAVE,'');\n     END;\n\n     LINE_C  =    0;\n     OFFSET  =    0;\n     PENDING = '0'B;\n     $FIND   = '0'B;\n     #FIND   =   '';\n     BOFFSET =    0;\n     $CONF   = '0'B;\n     $CONFP  = '0'B;\n     LVL     = MAXLVL-3;\n\n $FORM_REASM02:\n     LOCVAR=SUBSTR(DSN,1,INDEX(DSN,' ')-1);\n     LOCVAR=LOCVAR || '(' || MEMBER || ' ';\n     LOCVAR=SUBSTR(LOCVAR,1,INDEX(LOCVAR,' ')-1);\n     LOCVAR=LOCVAR || ',' || CSECT  || ' ';\n     LOCVAR=SUBSTR(LOCVAR,1,INDEX(LOCVAR,' ')-1);\n     LOCVAR=LOCVAR || ') LEN=' || SUBSTR($BH(TEXTLEN),3);\n     REASM02_DSN = LOCVAR;\n\n     IV = ' ';\n     #CUR(ZZCMD, 1);\n     REASM02_PRIMARY = '';\n\n $SHOW_LOOP:\n     DO WHILE(IV \u00ac= 'PF03');\n        CALL $CLEAR_SCR;\n        CALL $SHOW;\n     END;\n\n     IF $CONF & \u00ac$CONFP THEN DO;\n        IV              = ' ';\n        $CONFP          = '1'B;\n        CALL ISPLINK ('SETMSG ', 'REAS001 ');  /* CONFIRM END */\n        REASM02_PRIMARY = '';\n        GOTO $SHOW_LOOP;\n     END;\n     $CONF = '0'B;\n     CALL FREETEXT();\n     IF ESDLOOP THEN DO;\n       @@FREE_LIST(RLD);\n       J = REASLOA('CLOSE', '', '', '', '', '');\n       J = REASLOA('OPEN',  '', '', '', '', '');\n       GOTO L_ESD;\n     END;\n     GOTO L_AGAIN;\n\n\n %PAGE;\n /*********************************************************************/\n /*  SCAN COMMAND SUBROUTINE                                          */\n /*********************************************************************/\n $CMD:\n     PROC (PTR,IP);\n     DCL  LINE      CHAR(80),\n          LABEL     CHAR(8)  DEF LINE,\n          OPNAME    CHAR(6)  DEF LINE POS(10),\n          OPERANDS  CHAR(50) DEF LINE POS(16),\n          P         PTR,\n          #P        BIN FIXED(31) BASED(ADDR(P)),\n          PTR       BIN FIXED(31),\n          IP        BIN FIXED(31),\n          QH        CHAR(1),\n          #NOPR     CHAR(1),\n          #HEX      CHAR(64) INT STATIC INIT(\n 'X''0''X''1''X''2''X''3''X''4''X''5''X''6''X''7''X''8''X''9''X''A''X''B\n ''X''C''X''D''X''E''X''F'''),\n          $HEX(0:15) CHAR(4) DEF #HEX,\n          (B1,B2)   BIT(16) ALIGNED,\n          (I,J,K)   BIN FIXED(31);\n\n\n     P        = ADDRTEXT();\n     #CMD_PTR = PTR+#P;\n     LINE     = ' ';\n     #COM     = '';\n     UNSPEC(#NOPR)='00000111'B;\n     GLOBAL_IP = IP;    /* FOR EX IN $ADDR */\n\n     B1='00000000'B || RR1.CODE;    /* 00XX */\n     B2=S2.CODE;                    /* XXXX */\n\n     IF B1 = '0000000010100111' |     /* A7 - RI FORMAT  */\n        B1 = '0000000010100101' |     /* A5 - RI FORMAT  */\n        B1 = '0000000011000000'       /* C0 - RIL FORMAT */\n        THEN\n        B1 = RI.CODE || RI.CODE1 || '0000'B;\n\n     IF B1 = '0000000011100011' |     /* E3 - RXY FORMAT */\n        B1 = '0000000011101011' |     /* EB - SIY FORMAT */\n        B1 = '0000000011101100' |     /* EC - RIE FORMAT */\n        B1 = '0000000011101101'       /* ED - RXE FORMAT */\n        THEN\n        B1 = RXY.CODE || RXY.CODE1;\n\n     J = -1;\n CMD:DO I=1 TO CMDNUM(OS);\n        SELECT (@(I).F);\n          WHEN ($S2,$SSE,$RRE,$RRF,$RRE1,$E) DO;\n             IF B2 = @(I).V THEN DO;\n                J = I;\n                GOTO CONTCMD;\n             END;\n          END;\n          OTHER DO;\n             IF  B1 = @(I).V THEN DO;\n                J = I;\n                GOTO CONTCMD;\n             END;\n          END;\n        END;\n CONTCMD:;\n     END CMD;\n     IF J = -1 THEN\n        GOTO $RETURN_FROM_$CMD;\n\n     I = J;\n     IF PC=0 & I>=PACKMIN  & I<=PACKMAX  THEN GOTO $RETURN_FROM_$CMD;\n     IF FC=0 & I>=FLOATMIN & I<=FLOATMAX THEN GOTO $RETURN_FROM_$CMD;\n     IF @(I).V \u00ac= 0 THEN DO;\n        #FORWARD=0;\n        OPNAME=@.N(I);\n        IF $NOOP THEN GOTO $RETURN_FROM_$CMD;\n\n        SELECT (@(I).F);\n          WHEN ($RR1) DO;\n            OPERANDS=$REGS(BIN(RR1.R1,15)) || ',' ||\n                     $REGS(BIN(RR1.R2,15));\n            SELECT (OPNAME);\n              WHEN ('NR','OR') DO;\n                IF  RR1.R1 = RR1.R2 THEN\n                  #COM=#COM || ' ' || 'TEST ' || $REGS(RR1.R1);\n                ELSE DO;\n                  IF OPNAME='NR' THEN LOCVAR = ' & ';\n                  ELSE                LOCVAR = ' | ';\n                  #COM=#COM || ' ' || $REGS(RR1.R1) || '=' ||\n                       $REGS(RR1.R1) || LOCVAR || $REGS(RR1.R2);\n                END;\n              END;\n              WHEN ('SR','SLR','XR') DO;\n                IF  RR1.R1 = RR1.R2 THEN\n                  #COM=#COM || ' ' || $REGS(RR1.R1) || '=0';\n                ELSE\n                  IF OPNAME='SR' | OPNAME='SLR' THEN\n                    #COM=#COM || ' ' || $REGS(RR1.R1) || '=' ||\n                         $REGS(RR1.R1) || '-' || $REGS(RR1.R2);\n                  ELSE\n                    #COM=#COM || ' ' || $REGS(RR1.R1) || '=' ||\n                         $REGS(RR1.R1) || ' X ' || $REGS(RR1.R2);\n              END;\n              WHEN ('AR','ALR') DO;\n                IF  RR1.R1 = RR1.R2 THEN\n                  #COM=#COM || ' ' || $REGS(RR1.R1) ||\n                         '*2';\n                ELSE\n                  #COM=#COM || ' ' || $REGS(RR1.R1) || '=' ||\n                       $REGS(RR1.R1) || '+' || $REGS(RR1.R2);\n              END;\n              WHEN ('LR')\n                #COM=#COM || ' ' || $REGS(RR1.R1) || '=' ||\n                     $REGS(RR1.R2);\n              WHEN ('LNR')\n                #COM=#COM || ' ' || $REGS(RR1.R1) || '= -' ||\n                     $REGS(RR1.R2);\n              WHEN ('LPR')\n                #COM=#COM || ' ' || $REGS(RR1.R1) || '= +' ||\n                     $REGS(RR1.R2);\n              WHEN ('MR')\n                #COM=#COM || ' ' || $REGS(RR1.R1) || $REGS(RR1.R1+1) ||\n                     '=' || $REGS(RR1.R1+1) || '*' || $REGS(RR1.R2);\n              WHEN ('DR') DO;\n                IF RR1.R1 <=14 THEN\n                #COM=#COM || ' ' || $REGS(RR1.R1) || '=REMNDR ' ||\n                     $REGS(RR1.R1+1) || '=DIVDR';\n              END;\n              WHEN ('BCTR') DO;\n                IF RR1.R2=0 THEN\n                   #COM=#COM || ' ' || $REGS(RR1.R1) || '=' ||\n                        $REGS(RR1.R1) || '-1';\n              END;\n              WHEN ('BALR') DO;\n                IF RR1.R1=14 & RR1.R2=15 THEN\n                   #COM=#COM || ' CALL ';\n              END;\n              WHEN ('MVCL')\n                #COM=#COM || ' \u00a2' || $REGS(RR1.R1) || '! <-- \u00a2' ||\n                 $REGS(RR1.R2) || '! LEN(' || $REGS(RR1.R1+1) || ')';\n              WHEN ('CLCL')\n                #COM=#COM || ' COMP ' || $REGS(RR1.R1) || ' & ' ||\n                 $REGS(RR1.R2) || ' LEN(' || $REGS(RR1.R1+1) || ')';\n              OTHER;\n            END;\n            IF $XREF THEN DO;\n               CALL $PUTXRF($REGS(BIN(RR1.R1,15)));\n               CALL $PUTXRF($REGS(BIN(RR1.R2,15)));\n            END;\n          END;\n          WHEN ($RR2) DO;\n            I=BIN(RR2.OPER,15);\n            OPERANDS=$DIGIT(I);\n            IF OPNAME='SVC' & I <= HBOUND(SVCTABLE,1) THEN DO;\n               LOCVAR=SVCTABLE(I);\n               IF LOCVAR\u00ac='' THEN DO;\n                  #COM=LOCVAR || ' ' || #COM;\n               END;\n            END;\n          END;\n          WHEN ($RR3) DO;\n            OPERANDS=$HEX(BIN(RR3.MASK,15)) || ',' ||\n                     $REGS(BIN(RR3.R2,15));\n            IF $XREF THEN\n               CALL $PUTXRF($REGS(BIN(RR3.R2,15)));\n            IF  OPNAME='BCR' THEN DO;\n               IF OPPREV\u00ac='' & SUBSTR(OPPREV,1,1)='C' THEN\n                  LOCVAR=$EMNEM1(BIN(RR3.MASK,15));   /* COMPARING */\n               ELSE\n                  LOCVAR=$EMNEM(BIN(RR3.MASK,15));\n               IF LOCVAR\u00ac='' THEN DO;\n                  OPNAME=LOCVAR||'R';\n                  OPERANDS=$REGS(BIN(RR3.R2,15));\n               END;\n               IF OPNAME='BR' & OPERANDS='R14' THEN DO;\n                  IF #COM\u00ac='' THEN #COM = #COM || ' ' || 'RETURN';\n                  ELSE             #COM = 'RETURN';\n               END;\n               IF OPNAME='NOPR' & OPERANDS='R0' &\n                  SUBSTRTEXT(PTR+3,1)\u00ac=#NOPR THEN DO;\n                  OPNAME='CNOP';\n                  SELECT (MOD(#OFFSET+2,8));\n                  WHEN (0) OPERANDS='0,4';\n                  WHEN (2) OPERANDS='2,8';\n                  WHEN (4) OPERANDS='0,4';\n                  WHEN (6) OPERANDS='6,8';\n                  OTHER\n                    OPNAME='NOPR';\n                  END;\n               END;\n            END;\n          END;\n          WHEN ($RRE) DO;\n            OPERANDS=$REGS(BIN(RRE.R1,15)) || ',' ||\n                     $REGS(BIN(RRE.R2,15));\n            IF RRE.RSRV\u00ac=0 THEN DO;\n               $ORGIMM   = $IMM(RRE.RSRV);\n               $ORGIMM_B = '*-2';\n               $ORGIMM_F = '*+1';\n            END;\n          END;\n          WHEN ($RRF) DO;\n            OPERANDS=$REGS(BIN(RRF.R1,15)) || ',' ||\n                     $REGS(BIN(RRF.R3,15)) || ',' ||\n                     $REGS(BIN(RRF.R2,15));\n          END;\n          WHEN ($RRE1) DO;\n            OPERANDS=$REGS(BIN(RRE1.R1,15));\n            IF BIN(RRE1.RSRV,15) \u00ac= 0 THEN\n               #COM = #COM || ' !!! SECOND NIBBLE IS NONZERO !!!';\n          END;\n          WHEN ($R) DO;\n            OPERANDS=$REGS(BIN(R.R1,15));\n            IF OPNAME='SPM' & BIN(R.RSRV,15) \u00ac= 0 THEN\n               #COM = #COM || ' !!! SECOND NIBBLE IS NONZERO !!!';\n            IF $XREF THEN\n               CALL $PUTXRF($REGS(BIN(R.R1,15)));\n          END;\n          WHEN ($RS1) DO;\n            PUT STRING(OPERANDS) EDIT\n                    ($REGS(BIN(RS1.R1,15)),',',\n                     $REGS(BIN(RS1.R3,15)),',',\n                     $ADDR(RS1.B2,RS1.D2,0,'0'B,0,'0'B,OPNAME,PTR))\n                     (A,A,A,A,A);\n            SELECT (OPNAME);\n            WHEN ('LM','STM') DO;\n               SELECT;\n                 WHEN (RS1.R1=RS1.R3) II=1;\n                 WHEN (RS1.R3>RS1.R1) II=RS1.R3-RS1.R1+1;\n                 OTHER                II=15-RS1.R1+1+RS1.R3+1;\n               END;\n               IF II>=1 & II<=16 THEN\n                  #COM=#COM || ' PROCESS ' || $NUMBER(II) || ' REGS';\n            END;\n            WHEN ('LCTL')\n               #COM = #COM || ' ' || $CTLREG(RS1.R1);\n            WHEN ('BXH') DO;\n              I=RS1.R3;\n              IF MOD(I,2)=0 THEN\n                 I=I+1;\n              #COM=#COM || ' ' || $REGS(RS1.R1) || '=' ||\n                   $REGS(RS1.R1) || '+' || $REGS(RS1.R3) || ' ' ||\n                   $REGS(RS1.R1) || '>' || $REGS(I);\n            END;\n            WHEN ('BXLE') DO;\n              I=RS1.R3;\n              IF MOD(I,2)=0 THEN\n                 I=I+1;\n              #COM=#COM || ' ' || $REGS(RS1.R1) || '=' ||\n                   $REGS(RS1.R1) || '+' || $REGS(RS1.R3) || ' ' ||\n                   $REGS(RS1.R1) || '<=' || $REGS(I);\n            END;\n            WHEN ('CS')\n              #COM='IF ' || $REGS(RS1.R1) || '=OP ST ' || $REGS(RS1.R3)\n                   || ' OP';\n            OTHER;\n            END;\n            IF $XREF THEN\n               CALL $PUTXRF($REGS(BIN(RS1.R1,15)));\n            IF $XREF THEN\n               CALL $PUTXRF($REGS(BIN(RS1.R3,15)));\n          END;\n          WHEN ($RS2) DO;\n            LOCVAR   = $REGS(BIN(RS2.R1,15))   || ',' ||\n                       $HEX (BIN(RS2.MASK,15)) || ',' ||\n                       $ADDR(RS2.B2,RS2.D2,0,'0'B,0,'0'B,OPNAME,PTR);\n            OPERANDS = LOCVAR;\n          END;\n\n          WHEN ($RX) DO;\n            IF $AUTO          &  OPNAME = 'L' &\n               RX.B2  = '0'B  &  RX.X2  = '0'B\n               THEN DO;\n               IF BIN(RX.D2,15)\u00ac=16 THEN\n                  CALL $USING_PSA(PTR);\n               ELSE DO;\n                  #COM = 'LOAD CVT POINTER';\n                  IF  RX.R1\u00ac=0 THEN CALL $USING_CVT(PTR+4,RX.R1);\n               END;\n            END;\n\n            PUT STRING(OPERANDS) EDIT\n                    ($REGS(BIN(RX.R1,15)),',',\n                     $ADDR(RX.B2,RX.D2,RX.X2,'1'B,0,'0'B,OPNAME,PTR))\n                     (A,A,A);\n            SELECT (OPNAME);\n            WHEN ('LA') DO;\n               SELECT;\n               WHEN (RX.B2=0 & RX.X2=0)\n                  #COM=#COM || ' ' || $REGS(RX.R1) || '=' ||\n                       $DIGIT(RX.D2);\n               WHEN ((RX.R1=RX.B2 & RX.X2=0)|(RX.R1=RX.X2 & RX.B2=0))\n                  IF RX.D2\u00ac=0 THEN\n                     #COM=#COM || ' ' || $REGS(RX.R1) || '=' ||\n                          $REGS(RX.R1) || '+' || $DIGIT(RX.D2);\n                  ELSE\n                     #COM=#COM || ' CLEAR HI BYTE/BIT';\n               OTHER;END;\n            END;\n            WHEN ('SLDL','SLDA','SRDL','SRDA') DO;\n               PUT STRING(OPERANDS) EDIT\n                       ($REGS(BIN(RX.R1,15)),',',\n                        $ADDR(RX.B2,RX.D2,0,'0'B,0,'0'B,OPNAME,PTR))\n                        (A,A,A);\n            END;\n            WHEN ('SLL','SLA') DO;\n               PUT STRING(OPERANDS) EDIT\n                       ($REGS(BIN(RX.R1,15)),',',\n                        $ADDR(RX.B2,RX.D2,0,'0'B,0,'0'B,OPNAME,PTR))\n                        (A,A,A);\n               IF RX.B2=0 THEN DO;\n                 SELECT (RX.D2);\n                 WHEN (16)\n                    #COM=#COM || ' ' || 'SHIFT ' || $REGS(RX.R1) ||\n                         ' LEFT 2 BYTES';\n                 WHEN (24)\n                    #COM=#COM || ' ' || 'SHIFT ' || $REGS(RX.R1) ||\n                         ' LEFT 3 BYTES';\n                 OTHER\n            /*      #COM=#COM || ' ' || $REGS(RX.R1) || '=' ||\n                         $REGS(RX.R1) || '*' || $DIGIT(2**RX.D2);    */\n                    #COM=#COM;\n                 END;\n               END;\n            END;\n            WHEN ('SRL','SRA') DO;\n               PUT STRING(OPERANDS) EDIT\n                       ($REGS(BIN(RX.R1,15)),',',\n                        $ADDR(RX.B2,RX.D2,0,'0'B,0,'0'B,OPNAME,PTR))\n                        (A,A,A);\n               IF RX.B2=0 THEN DO;\n                 SELECT (RX.D2);\n                 WHEN (16)\n                    #COM=#COM || ' ' || 'SHIFT ' || $REGS(RX.R1) ||\n                         ' RIGHT 2 BYTES';\n                 WHEN (24)\n                    #COM=#COM || ' ' || 'SHIFT ' || $REGS(RX.R1) ||\n                         ' RIGHT 3 BYTES';\n                 OTHER\n                    #COM=#COM || ' ' || $REGS(RX.R1) || '=' ||\n                         $REGS(RX.R1) || '/' || $DIGIT(2**RX.D2);\n                 END;\n               END;\n            END;\n            OTHER;\n            END;\n          END;\n\n          WHEN ($RM) DO;\n            PUT STRING(OPERANDS) EDIT\n                    ($HEX(BIN(RM.MASK,15)),',',\n                     $ADDR(RM.B2,RM.D2,RM.X2,'1'B,0,'0'B,OPNAME,PTR))\n                     (A,A,A);\n            IF OPNAME='BC' THEN DO;\n               IF OPPREV\u00ac='' & SUBSTR(OPPREV,1,1)='C' THEN\n                  LOCVAR=$EMNEM1(BIN(RM.MASK,15));   /* COMPARING */\n               ELSE\n                  LOCVAR=$EMNEM(BIN(RM.MASK,15));\n               IF LOCVAR\u00ac='' THEN DO;\n                  OPNAME=LOCVAR;\n                  OPERANDS=\n                    $ADDR(RM.B2,RM.D2,RM.X2,'1'B,0,'0'B,OPNAME,PTR);\n               END;\n            END;\n          END;\n\n          /* 2006 */\n          WHEN ($SIY) DO;\n            PUT STRING(OPERANDS) EDIT\n                ($ADDR(SIY.B2,SIY.DH2||SIY.DL2,0,\n                      '0'B,0,'0'B,OPNAME,PTR),\n                ',',$IMM(SIY.$I))\n                (A,A,A);\n          END;\n\n          WHEN ($RXY) DO;\n            PUT STRING(OPERANDS) EDIT\n             ($REGS(BIN(RXY.R1,15)),',',\n              $ADDR(RXY.B2,RXY.DH2||RXY.DL2,RXY.X2,\n                           '1'B,0,'0'B,OPNAME,PTR)  )\n              (A,A,A);\n          END;\n\n          WHEN ($RXY1) DO;\n            PUT STRING(OPERANDS) EDIT\n             ($REGS(BIN(RXY1.R1,15)),',',\n              $REGS(BIN(RXY1.R3,15)),',',\n              $ADDR(RXY1.B2,RXY1.DH2||RXY1.DL2,'0'B,\n                           '1'B,0,'0'B,OPNAME,PTR)  )\n              (A,A,A);\n          END;\n\n          WHEN ($RXE) DO;\n            OPERANDS =\n             $REGS(BIN(RXE.R1,15)) || ',' ||\n             $ADDR(RXE.B2,RXE.D2,RXE.X2,'1'B,0,'0'B,OPNAME,PTR);\n            IF RXE.RSRV\u00ac=0 THEN DO;\n               $ORGIMM=$IMM(RXE.RSRV);\n               $ORGIMM_B = '*-2';\n               $ORGIMM_F = '*+1';\n            END;\n          END;\n\n          WHEN ($RXF) DO;\n            OPERANDS =\n             $REGS(BIN(RXF.R1,15)) || ',' ||\n             $REGS(BIN(RXF.R3,15)) || ',' ||\n             $ADDR(RXF.B2,RXF.D2,'0'B,'1'B,0,'0'B,OPNAME,PTR);\n            IF BIN(RXF.RSRV,15) \u00ac= 0 THEN\n               #COM = #COM || ' !!! SECOND NIBBLE IS NONZERO !!!';\n          END;\n\n          WHEN ($RSY) DO;\n            OPERANDS =\n             $REGS(BIN(RSY.R1,15)) || ',' ||\n             $REGS(BIN(RSY.R3,15)) || ',' ||\n             $ADDR(RSY.B2,SIY.DH2||RSY.DL2,0,'0'B,0,'0'B,OPNAME,PTR);\n          END;\n\n          WHEN ($RSY1) DO;\n            OPERANDS =\n             $REGS(BIN(RSY1.R1,15)) || ',' ||\n             $HEX(BIN(RSY1.MASK,15)) || ',' ||\n             $ADDR(RSY1.B2,SIY.DH2||RSY1.DL2,0,'0'B,0,'0'B,OPNAME,PTR);\n          END;\n\n          WHEN ($RSL) DO;\n            OPERANDS =\n             $ADDR(RSL.B1,RSL.D1,0,'0'B,RSL.L1,'1'B,OPNAME,PTR);\n            IF BIN(RSL.RSRV,15) \u00ac= 0 THEN\n               #COM = #COM || ' !!! SECOND NIBBLE IS NONZERO !!!';\n            IF RSL.RSRV2\u00ac=0 THEN DO;\n               $ORGIMM=$IMM(RSL.RSRV2);\n               $ORGIMM_B = '*-2';\n               $ORGIMM_F = '*+1';\n            END;\n          END;\n\n          WHEN ($RI) DO;\n            PUT STRING(LOCVAR) EDIT(RI.I2)(F(6));\n            LOCVAR = SUBSTR(LOCVAR,VERIFY(LOCVAR,' '));\n            PUT STRING(OPERANDS) EDIT\n                ($REGS(BIN(RI.R1,15)),',',LOCVAR)(A,A,A);\n          END;\n\n          WHEN ($RIM) BEGIN;\n            DCL LABNAME CHAR(16) VAR;\n            LABNAME = $JUMPOFF(RIM.I2, PTR);\n\n            OPERANDS = $HEX(BIN(RIM.MASK,15)) || ',' || LABNAME;\n            IF OPPREV\u00ac='' & SUBSTR(OPPREV,1,1)='C' THEN\n               LOCVAR=$JMNEM1(BIN(RIM.MASK,15));   /* COMPARING */\n            ELSE\n               LOCVAR=$JMNEM(BIN(RIM.MASK,15));\n\n            IF LOCVAR\u00ac='' THEN DO;\n               OPNAME   = LOCVAR;\n               OPERANDS = LABNAME;\n            END;\n          END;\n\n          WHEN ($RIM1) BEGIN;\n             OPERANDS = $REGS(BIN(RIM1.R1,15)) || ',' ||\n                 $JUMPOFF(RIM1.I2, PTR);\n             IF OPNAME = 'BRCT' THEN OPNAME='JCT';\n          END;\n\n          WHEN ($RIE) BEGIN;\n             OPERANDS = $REGS(BIN(RIE.R1,15)) || ',' ||\n                 $REGS(BIN(RIE.R3,15)) || ',' ||\n                 $JUMPOFF(RIE.I2, PTR);\n            IF RIE.RSRV\u00ac=0 THEN DO;\n               $ORGIMM=$IMM(RIE.RSRV);\n               $ORGIMM_B = '*-2';\n               $ORGIMM_F = '*+1';\n            END;\n          END;\n\n          WHEN ($RSI) BEGIN;\n             OPERANDS = $REGS(BIN(RSI.R1,15)) || ',' ||\n                 $REGS(BIN(RSI.R3,15)) || ',' ||\n                 $JUMPOFF(RSI.I2, PTR);\n          END;\n\n          WHEN ($RIL) BEGIN;\n            OPERANDS = $REGS(BIN(RIL.R1,15)) || ',' ||\n                 $JUMPOFF(RIL.I2, PTR);\n          END;\n\n          WHEN ($RILM) DO;\n            OPERANDS = $HEX(BIN(RILM.MASK,15)) || ',' ||\n                  $JUMPOFF(RILM.I2, PTR);\n          END;\n\n          WHEN ($E) DO;\n\n          END;\n\n          WHEN ($SI) DO;\n            QH=SUBSTR(GOODA,BIN(SI.$I,15)+1,1);\n            SELECT (OPNAME);\n              WHEN ('MVI','CLI') DO;\n                IF QH\u00ac=HIGH(1) THEN #COM = 'C''' || QH || '''' || #COM;\n              END;\n              WHEN ('OI','NI','XI','TM') DO;\n                UNSPEC(QH) = UNSPEC(SI.$I);\n                #COM = $BITSTR(QH);\n              END;\n              WHEN ('STOSM','STNSM') DO;\n                DO I=1 TO 8;\n                 IF SUBSTR(UNSPEC(SI.$I),I,1) = '1'B & OPNAME='STOSM'\n                    THEN #COM = #COM || ' ' || $PSWMASK(I);\n                 IF SUBSTR(UNSPEC(SI.$I),I,1) = '0'B & OPNAME='STNSM'\n                    THEN #COM = #COM || ' ' || $PSWMASK(I);\n                END;\n              END;\n              OTHER;\n            END;\n            PUT STRING(OPERANDS) EDIT\n                ($ADDR(SI.B2,SI.D2,0,'0'B,0,'0'B,OPNAME,PTR),\n                ',',$IMM(SI.$I))\n                (A,A,A);\n            IF OPNAME='NI' THEN DO;\n               I  = SI.$I;\n               IF I=255-01  |  I=255-02  | I=255-04 | I=255-08  |\n                  I=255-16  |  I=255-32  | I=255-64 | I=255-128 THEN DO;\n                  ICH = 255 - I;\n                  PUT STRING(OPERANDS) EDIT\n                     ($ADDR(SI.B2,SI.D2,0,'0'B,0,'0'B,OPNAME,PTR),\n                     ',', 'X''FF''-', $IMM(UNSPEC(CH)))\n                     (A,A,A,A);\n               END;\n            END;\n          END;\n          WHEN ($S1) DO;\n            OPERANDS=$ADDR(S1.B2,S1.D2,0,'0'B,0,'0'B,OPNAME,PTR);\n            IF S1.RSRV\u00ac=0 THEN DO;\n               $ORGIMM=$IMM(S1.RSRV);\n               $ORGIMM_B = '*-3';\n               $ORGIMM_F = '*+2';\n            END;\n          END;\n          WHEN ($S2) DO;\n            OPERANDS=$ADDR(S1.B2,S1.D2,0,'0'B,0,'0'B,OPNAME,PTR);\n            SELECT (OPNAME);\n            WHEN ('SPKA') DO;\n              IF S1.B2=0 & S1.D2<16 THEN\n                #COM = #COM || ' ' || 'SET EXTKEY=' || $KEYNAME(S1.D2);\n            END;\n            WHEN ('IPK') DO;\n              #COM = #COM || ' ' || 'INSERT PSW KEY INTO R2';\n            END;\n            OTHER;\n            END;\n          END;\n          WHEN ($SS1)\n            PUT STRING(OPERANDS) EDIT\n             ($ADDR(SS1.B1,SS1.D1,0,'0'B,SS1.LEN1,'1'B,OPNAME,PTR),',',\n              $ADDR(SS1.B2,SS1.D2,0,'0'B,SS1.LEN2,'1'B,OPNAME,PTR))\n             (A,A,A);\n          WHEN ($SS2) DO;\n            PUT STRING(OPERANDS) EDIT\n             ($ADDR(SS2.B1,SS2.D1,0,'0'B,SS2.LEN,'1'B,OPNAME,PTR),',',\n              $ADDR(SS2.B2,SS2.D2,0,'0'B,0,'0'B,OPNAME,PTR))\n              (A,A,A);\n            SELECT (OPNAME);\n              WHEN ('XC','OC','NC') DO;\n                IF OPNAME = 'XC' THEN LOCVAR='CLEAR ';\n                ELSE                  LOCVAR='TEST ';\n                IF (SS2.B1=SS2.B2) & (SS2.D1=SS2.D2) THEN\n                   #COM = #COM || ' ' || LOCVAR ||\n                   $ADDR(SS2.B2,SS2.D2,0,'0'B,0,'0'B,OPNAME,PTR);\n              END;\n              OTHER;\n            END;\n          END;\n          WHEN ($SS3)\n            PUT STRING(OPERANDS) EDIT\n             ($ADDR(SS3.B1,SS3.D1,0,'0'B,SS3.LEN,'1'B,OPNAME,PTR),',',\n              $ADDR(SS3.B2,SS3.D2,0,'0'B,0,'0'B,OPNAME,PTR),',',\n              $HEX(SS3.I3))\n              (A,A,A,A,A);\n          WHEN ($SS4)\n            PUT STRING(OPERANDS) EDIT\n             ($ADDR(SS4.B1,SS4.D1,SS4.R1,'1'B,0,'1'B,OPNAME,PTR),',',\n              $ADDR(SS4.B2,SS4.D2,0,     '0'B,0,'0'B,OPNAME,PTR),',',\n              $REGS(BIN(SS4.R3,15)))\n              (A,A,A,A,A);\n          WHEN ($SSE)\n            PUT STRING(OPERANDS) EDIT\n             ($ADDR(SSE.B1,SSE.D1,0,'0'B,0,'0'B,OPNAME,PTR),',',\n              $ADDR(SSE.B2,SSE.D2,0,'0'B,0,'0'B,OPNAME,PTR))\n              (A,A,A);\n          OTHER DO;\n            PUT SKIP DATA(SS2,@(I));\n            CALL REASLST;\n            SIGNAL ERROR;\n            STOP;\n          END;\n        END;\n     END;\n\n $RETURN_FROM_$CMD:\n     REASM02_LINE(IP).LABEL=SUBSTR(LINE,1,8);\n     REASM02_LINE(IP).OPER=SUBSTR(LINE,10,5);\n     REASM02_LINE(IP).OPERANDS=SUBSTR(LINE,16);\n     IF REASM02_LINE(IP).OPER \u00ac= '' THEN     /* COMMAND MADE ? */\n        CALL $PUTOBJ(PTR,CMDLEN(CMDDEF),IP);\n     OPPREV=REASM02_LINE(IP).OPER;\n END $CMD;\n %SKIP;\n /*********************************************************************/\n /*  DETERMINE NAME BY BASE/OFFST/INDEX                               */\n /*********************************************************************/\n $ADDR:\n     PROC(#B,#D,#X,#FX,#LEN,#FLEN,OPNAME,PTR)\n          RETURNS(CHAR(50) VAR);\n     DCL  (#B,#X)     BIT(*) ALIGNED,\n          (B,X)       BIN FIXED(31),\n          #D          BIT(*) ALIGNED,\n          D           BIN FIXED(31),\n          #LEN        BIT(*) ALIGNED,\n          LEN         BIN FIXED(31),\n          #FX         BIT(1) ALIGNED,\n          FX          BIT(1) ALIGNED,\n          #FLEN       BIT(1) ALIGNED,\n          FLEN        BIT(1) ALIGNED,\n          OPNAME      CHAR(*),\n          PTR         BIN FIXED(31),\n          (I,J,II,JJ) BIN FIXED(31),\n          #I          CHAR(4) BASED(ADDR(I)),\n          (P,Q)       PTR,\n          #P          BIN FIXED(31) BASED(ADDR(P)),\n          N           CHAR(8) VAR,\n          ($FB,$FX)   BIT(1) INIT('0'B) ALIGNED,\n          #VAL        BIN FIXED(31),\n          VAL         CHAR(4) BASED(ADDR(#VAL)),\n          #HVAL       BIN FIXED(15),\n          HVAL        CHAR(2) BASED(ADDR(#HVAL)),\n          1 XLINE     LIKE REASM02_LINE,\n          IP          BIN FIXED(31),\n          XCMD        PTR,\n          C1          CHAR(50) VAR;\n\n     B      = BIN(#B,15);\n     X      = BIN(#X,15);\n     D      = BIN(#D,15);\n     FX     = #FX;\n     FLEN   = #FLEN;\n     LEN    = BIN(#LEN,15);\n\n     C1=$DIGIT(D);\n     IF FLEN | (FX & X\u00ac=0) | B\u00ac=0 THEN DO;\n        C1 = C1 || '(';\n        IF FLEN THEN C1=C1 || $DIGIT(LEN+1) || ',';\n        IF FX THEN DO;\n           IF X\u00ac= 0 THEN DO;\n              C1  = C1 || $REGS(X);\n              $FX = '1'B;\n           END;\n           IF B\u00ac=0 THEN DO;\n              C1  = C1 || ',' || $REGS(B);\n              $FB = '1'B;\n           END;\n        END;\n        ELSE DO;\n           IF B\u00ac=0 THEN DO;\n              C1  = C1 || $REGS(B);\n              $FB = '1'B;\n           END;\n           ELSE\n              C1 = SUBSTR(C1,1,LENGTH(C1)-1);\n        END;\n        C1 = C1 || ')';\n     END;\n     /**********************************/\n     /* TRY MAKE SYMBOLIC NAME         */\n     /**********************************/\n     USING_PTR=USING_START;\n NEW_USING:\n     P=NULL;\n     DO WHILE(USING_PTR\u00ac=NULL);\n        IF (USING.REG  = B             &\n            PTR       >= USING.PLACE   &\n            PTR       <  USING.PLACE+USING.LENGTH)   |\n           (FX & USING.REG=X           &\n            PTR       >= USING.PLACE   &\n            PTR       <  USING.PLACE+USING.LENGTH)   THEN DO;\n            IF P\u00ac=NULL THEN DO;\n               IF P->USING.PLACE < USING.PLACE THEN /* NEW IS LOWER */\n                  P=USING_PTR;                      /* 08.12.87 */\n            END;\n            ELSE  P=USING_PTR;\n        END;\n        USING_PTR=USING.NEXT;\n     END;\n\n #TEST_USING_AGAIN:\n     IF P\u00ac=NULL THEN DO;\n        USING_PTR=P;\n                                         /* 14.09.88 */\n        P=USING_START;\n        DO WHILE(P\u00ac=NULL);\n           IF P->USING.REG   = USING.REG      &\n              P->USING.PLACE > USING.PLACE    &\n              P->USING.PLACE <=PTR            THEN DO;\n              P=NULL;\n              GOTO #TEST_USING_AGAIN;\n           END;\n           P = P->USING.NEXT;\n        END;\n\n        IF USING.REG=X & FX THEN  FX, $FX = '0'B;\n        ELSE                      $FB = '0'B;\n        IF USING.NAME='' THEN DO;         /* BASE */\n           I = USING.OFF + D;             /* ABS DISPL */\n           J = I - PTR;\n           IF ((J>=0) & ( J<=#ABSA)) |\n              ((J<=0) & (-J<=#ABSB)) THEN DO;\n              LOCVAR = ''; IF J>=0 THEN LOCVAR = '+';\n              C1='*' || LOCVAR || $DIGIT(J);\n           END;\n           ELSE DO;\n              LOCVAR = #I;\n              C1     = $NAME(LOCVAR);\n              IF B\u00ac=0 THEN  CALL $INITLAB(C1,I,B,'0'B,PTR);\n              ELSE          CALL $INITLAB(C1,I,X,'0'B,PTR);\n              IF $XREF THEN CALL $PUTXRF(C1);\n           END;\n\n           SELECT (OPNAME);\n             WHEN ('EX') DO;\n               IP = GLOBAL_IP;\n               XLINE = REASM02_LINE(IP), BY NAME;\n               XCMD  = CMD_PTR;\n               CALL $CMD(I,IP);\n               IF REASM02_LINE(IP).OPER \u00ac= '' THEN\n                  #COM = REASM02_LINE(IP).OPER     ||\n                         REASM02_LINE(IP).OPERANDS;\n               ELSE\n                  #COM = #COM || '/' || $CH(SUBSTRTEXT(I+1,6));\n               REASM02_LINE(IP) = XLINE, BY NAME;\n               CMD_PTR = XCMD;\n             END;\n             WHEN ('L') DO;\n               IF I <= TEXTLEN THEN DO;\n                  VAL     = SUBSTRTEXT(I+1,4);\n                  LOCVAR  = '=X''' || $CH(VAL)     || '''' || '; ' ||\n                            '=F''' || $DIGIT(#VAL) || '''';\n                  P       = DSC_PTR;\n                  CALL $FINDDSC(I);\n                  Q       = DSC_PTR;\n                  DSC_PTR = P;\n                  SELECT (Q->DSC.TYPE);\n                  WHEN ('A') DO;\n                    IF Q->DSC.LENGTH=4 THEN\n                       #COM='=A(' ||\n                         $NAME(SUBSTRTEXT(Q->DSC.OFF+1,4)) || ')';\n                  END;\n                  WHEN ('V') DO;\n                    IF Q->DSC.LENGTH=4 THEN DO;\n                       LOCVAR = '';\n                       HVAL = SUBSTRTEXT(Q->DSC.OFF+3,2);\n                       IF #HVAL > 0 THEN LOCVAR='+' || $DIGIT(#HVAL);\n                       IF #HVAL < 0 THEN LOCVAR= $DIGIT(#HVAL);\n                       LOCVAR = $NEXTEL(Q->DSC.NAME) || LOCVAR;\n                       #COM='=V(' || LOCVAR || ')';\n                    END;\n                  END;\n                  OTHER DO;\n                    IF #COM\u00ac='' THEN #COM=#COM ||'/' || LOCVAR;\n                    ELSE             #COM=LOCVAR;\n                  END;\n                  END;\n               END;\n             END;\n             WHEN ('C','S','M','D','ST','STM','LM','LCTL','STCTL',\n                   'A','AL','CL','SL') DO;\n                IF MOD(I,4)=0 THEN DO;\n                   P = DSC_PTR;\n                   IF $AUTO THEN CALL $INCLUDE(I,4,'F');\n                   DSC_PTR = P;\n                END;\n                SELECT (OPNAME);\n                WHEN ('C','A','S','CL','AL','SL','M','D') DO;\n                  VAL     = SUBSTRTEXT(I+1,4);\n                  LOCVAR  = '=X''' || $CH(VAL)     || '''' || '; ' ||\n                            '=F''' || $DIGIT(#VAL) || '''';\n                  IF #COM\u00ac='' THEN #COM=#COM || '/' || LOCVAR;\n                  ELSE             #COM=LOCVAR;\n                END;\n                OTHER;\n                END;\n             END;\n             WHEN ('N','O','X') DO;\n               VAL     = SUBSTRTEXT(I+1,4);\n               LOCVAR  = '=X''' || $CH(VAL)     || '''' || '; ' ||\n                         '=F''' || $DIGIT(#VAL) || '''';\n               IF #COM\u00ac='' THEN #COM=#COM || '/' || LOCVAR;\n               ELSE             #COM=LOCVAR;\n             END;\n             WHEN ('LH','STH','MH','AH','SH','DH','CH') DO;\n                IF MOD(I,2)=0 THEN DO;\n                   P = DSC_PTR;\n                   IF $AUTO THEN CALL $INCLUDE(I,2,'H');\n                   DSC_PTR = P;\n                END;\n                HVAL=SUBSTRTEXT(I+1,2);\n                LOCVAR='=H''' || $DIGIT(#HVAL) || '''';\n                IF #COM\u00ac='' THEN #COM=#COM ||'/' || LOCVAR;\n                ELSE             #COM=LOCVAR;\n             END;\n\n             WHEN ('MVC','CLC','ED','EDMK') DO;\n               J = BIN(SS2.LEN+1,15);\n               IF I+J > TEXTLEN THEN J = TEXTLEN-I-1;\n               IF J < 0          THEN J = 0;\n               IF J > 255        THEN J = 255;\n               LOCVAR     = SUBSTRTEXT(I+1,J);\n               IF $CHARSTR(LOCVAR) THEN DO;\n                  IF J>20 THEN J=20;\n                  #COM = '=C''' ||     SUBSTRTEXT(I+1,J)  || '''';\n               END;\n               ELSE DO;\n                  IF J>10 THEN J=10;\n                  #COM = '=X''' || $CH(SUBSTRTEXT(I+1,J)) || '''';\n                  P = DSC_PTR;\n                  CALL $FINDDSC(I);\n                  Q = DSC_PTR;\n                  DSC_PTR = P;\n                  SELECT (Q->DSC.TYPE);\n                  WHEN ('A') DO;\n                    IF Q->DSC.LENGTH=4 THEN\n                       #COM='=A(' ||\n                         $NAME(SUBSTRTEXT(Q->DSC.OFF+1,4)) || ')';\n                  END;\n                  WHEN ('V') DO;\n                    IF Q->DSC.LENGTH=4 THEN DO;\n                       LOCVAR = '';\n                       HVAL = SUBSTRTEXT(Q->DSC.OFF+3,2);\n                       IF #HVAL > 0 THEN LOCVAR='+' || $DIGIT(#HVAL);\n                       IF #HVAL < 0 THEN LOCVAR= $DIGIT(#HVAL);\n                       LOCVAR = $NEXTEL(Q->DSC.NAME) || LOCVAR;\n                       #COM='=V(' || LOCVAR || ')';\n                    END;\n                  END;\n                  OTHER;\n                  END;\n               END;\n             END;\n\n             WHEN ('LPSW') DO;\n               #COM = '=X''' || $CH(SUBSTRTEXT(I+1,8)) || '''';\n             END;\n\n             WHEN ('BAL')\n               IF I > PTR THEN              #FORWARD = I;\n             WHEN ('B')\n               IF I > PTR THEN              #FORWARD = I;\n             WHEN ('BC')\n               IF RM.MASK=15 & I > PTR THEN #FORWARD = I;\n\n             OTHER;\n           END;\n\n $PUTLENX: IF (FX & X\u00ac=0) | FLEN THEN DO;\n              IF FLEN THEN C1=C1 || '(' || $DIGIT(LEN+1) || ')';\n                      ELSE C1=C1 || '(' || $REGS(X) || ')';\n           END;\n        END;\n\n        ELSE DO;                         /* DSECT USING */\n           LBLOCK_PTR=LBLOCK_START;\n           DO WHILE(LBLOCK_PTR\u00ac=NULL);\n              IF LBLOCK.NAME=USING.NAME THEN DO; /* APPROPRIATE LIVB */\n                 IF (USING.REG=0 & B=0 & X=0) | USING.REG\u00ac=0 THEN\n                    GOTO $GOODLIV;\n              END;\n              LBLOCK_PTR=LBLOCK.NEXT;\n           END;\n\n $GOODLIV: IF LBLOCK_PTR=NULL THEN DO;\n              IF USING.REG=0 THEN DO;\n                 USING_PTR = USING.NEXT;\n                 GOTO NEW_USING;\n              END;\n              SIGNAL ERROR;\n              STOP;\n           END;\n\n           IF LBLOCK.ADR = 0 THEN DO;\n $PUTC1:      C1 = $DNAME(LBLOCK_PTR,BIN(D,15),I);\n              CALL $PUTDUMMY(LBLOCK.NAME,D);\n              IF $XREF THEN CALL $PUTXRF(C1);\n              IF $DSOFF & (I=1) THEN\n                 C1=$NEXTEL(SUBSTR(LBLOCK.NAME,2)) || '+' || $DIGIT(D);\n              GOTO $PUTLENX;\n           END;\n           ELSE DO;\n              C1=$LFIND(LBLOCK_PTR,D,$XREF,#COM,$PUTXRF);\n              IF C1='' THEN GOTO $PUTC1;\n                       ELSE GOTO $PUTLENX;\n           END;\n        END;\n     END;\n     ELSE DO;     /* DO NOT HAVE RELEVAND BASE REG  */\n $NOLIV:\n       IF OPNAME='B' THEN DO;\n          IF (RM.B2=15 & RM.X2=0) | (RM.B2=0 & RM.X2=15) THEN\n             #FORWARD=RM.D2;\n       END;\n     END;\n\n     IF $XREF THEN DO;\n        IF $FB THEN\n           CALL $PUTXRF($REGS(B));\n        IF $FX THEN\n           CALL $PUTXRF($REGS(X));\n     END;\n     RETURN (C1);\n END $ADDR;\n %PAGE;\n /*********************************************************************/\n /*  OPEN MEMBER SUBROUTINE                                           */\n /*  IF FIRST TIME THEN CREATE ESD TABLE                              */\n /*********************************************************************/\n $OPEN:\n     PROC ;\n     DCL  (I,J,K,LASTSD) BIN FIXED(31) INIT(0);\n\n     J = REASLOA('OPEN', '', '', '', '', '');\n\n     ESD_BLOCK_PTR=ADDR(BLOCK);\n\n     DO J=1 TO 10;\n        CALL REASQPW('CHECK',PASS(J),JDAT);\n     END;\n\n     CALL $READ;\n     DO WHILE(UNSPEC(IDENT)='01000000'B);      /*  LOOP SYM     */\n        CALL $READ;\n     END;\n     DO WHILE(UNSPEC(IDENT)='00100000'B);      /*  LOOP ESD     */\n        I=I+ESDLEN/16;                         /*  ESD EL NUM   */\n        CALL $READ;\n     END;\n     ALLOCATE ESD_ARRAY(I);\n     DIM_ESD_ARRAY = I;\n\n     J = REASLOA('CLOSE', '', '', '', '', '');\n     J = REASLOA('OPEN',  '', '', '', '', '');\n\n     I=0; CALL $READ;\n     DO WHILE(UNSPEC(IDENT)='01000000'B);      /*  LOOP SYM     */\n        CALL $READ;\n     END;\n     DO WHILE(UNSPEC(IDENT)='00100000'B); /*  ESD LOOP    */\n        #ESD_ELEMENT_PTR=#ESD_BLOCK_PTR+8;\n        DO K=1 TO ESDLEN/16;\n          I=I+1;\n          ESD_ARRAY(I) = ESD_ELEMENT, BY NAME;\n          ONEBYTE = ESD_ARRAY(I).TYPE;\n          ESD_ARRAY(I).ID  = FIRST_ESDID+K-1;\n          ESD_ARRAY(I).REF = 0;\n          IF \u00acBIT4 &  BIT5 & \u00acBIT6 & \u00acBIT7 THEN   /* 04  **** PC */\n             ESD_ARRAY(I).TYPE = '0'B;            /*     MAKE SD */\n          IF \u00acBIT4 & \u00acBIT5 & \u00acBIT6 & \u00acBIT7 THEN   /* 0F  **** SD */\n             LASTSD = ESD_ARRAY(I).ID;            /*     REMEMBER*/\n          IF  BIT4 & \u00acBIT5 &  BIT6 & \u00acBIT7 THEN   /* 0A  **** WX */\n             ESD_ARRAY(I).REF = LASTSD;           /*     SET REF */\n          IF (\u00acBIT4 & \u00acBIT5 &  BIT6 &  BIT7) |    /* 03  **** LD */\n             (\u00acBIT4 &  BIT5 &  BIT6 & \u00acBIT7) THEN /* 06  **** XD */\n             ESD_ARRAY(I).REF=\n                 BIN(SUBSTR(UNSPEC(ESD_ARRAY(I).LENGTH),9),15);\n          #ESD_ELEMENT_PTR=#ESD_ELEMENT_PTR+16;\n        END;\n        CALL $READ;\n     END;\n END $OPEN;\n %PAGE;\n /*********************************************************************/\n /*  FIND CSECT AND READ ITS BODY                                     */\n /*********************************************************************/\n $CSECT:\n     PROC ;\n     DCL  (I,J,K,L) BIN FIXED(31),\n          (#F,#T)   BIN FIXED(31),\n          $RYES     BIT(1),\n          NN        CHAR(8);\n\n     ESDID   = 0;\n     TEXTLEN = 0;\n $CSECT_ESD_LOOP:\n     DO I=1 TO DIM_ESD_ARRAY;\n        IF  ESD_ARRAY(I).NAME=CSECT THEN DO;\n            ONEBYTE = ESD_ARRAY(I).TYPE;\n            IF  \u00acBIT4 & \u00acBIT5 & \u00acBIT6 & \u00acBIT7 THEN DO; /* SD */\n                ESDID=ESD_ARRAY(I).ID;\n                K=ESD_ARRAY(I).LENGTH;\n                ARRINDX=I;\n                LEAVE $CSECT_ESD_LOOP;\n            END;\n            IF  \u00acBIT4 & \u00acBIT5 & BIT6 & BIT7 THEN DO;   /* LD */\n                ESDID=ESD_ARRAY(I).REF;\n                DO J=1 TO DIM_ESD_ARRAY;\n                   ONEBYTE = ESD_ARRAY(J).TYPE;\n                   IF  ESDID=ESD_ARRAY(J).ID &\n                       \u00acBIT4 & \u00acBIT5 & \u00acBIT6 & \u00acBIT7 THEN DO;\n                       CSECT=ESD_ARRAY(J).NAME;\n                       K=ESD_ARRAY(J).LENGTH;\n                       ARRINDX=J;\n                       LEAVE $CSECT_ESD_LOOP;\n                   END;\n                END;\n                SIGNAL ERROR;\n                STOP;\n            END;\n        END;\n     END $CSECT_ESD_LOOP;\n\n     IF ESDID=0 THEN RETURN;\n\n     IF K > HBOUND(TEXT,1) | K=0 THEN DO;\n        TEXTLEN = 0;\n        ESDID=0;\n        RETURN;\n     END;\n\n     CALL ALLOCATETEXT(0);\n     TEXTLEN = K;\n\n     CNTL_BLOCK_PTR=ADDR(BLOCK);\n\n $CSECT_CNTL_LOOP:\n     DO WHILE(\u00ac$EOF);\n        IF CNTLYES & CNTLNO\u00ac=0 THEN DO;\n           #CNTL_ELEMENT_PTR=#CNTL_BLOCK_PTR+16+RLDNO;\n           DO I=1 TO CNTLNO/4;\n              IF  CNTLID=ESDID THEN DO;\n                J=ESD_ARRAY(ARRINDX).OFF-TXTOFF;\n                K=CNTLLEN;        /* LENGTH IN THIS BLOCK         */\n                CALL $READ;       /* READ BLOCK AFTER CNTL RECORD */\n                IF $EOF THEN GOTO EOF;\n                CALL SETTEXT(SUBSTR(BLOCK,J+1,K));\n                LEAVE $CSECT_CNTL_LOOP;\n              END;\n              #CNTL_ELEMENT_PTR=#CNTL_ELEMENT_PTR+4;\n           END;\n           CALL $READ;\n           IF $EOF THEN GOTO EOF;\n        END;\n        CALL $READ;\n        IF $EOF THEN GOTO EOF;\n     END $CSECT_CNTL_LOOP;\n     CALL $READ;\n     IF $EOF THEN GOTO EOF;\n\n $CSECT_GETTEXT_LOOP:\n     DO WHILE(\u00ac$EOF);\n         /***************************/\n         /* RLD INFO EXISTS         */\n         /***************************/\n         IF RLDYES & RLDNO\u00ac=0 THEN DO;\n            #RLD_ELEMENT_PTR=#CNTL_BLOCK_PTR+16;\n            I=1;\n            DO WHILE(I <= RLDNO/4);\n               #F=FROMID;\n               #T=TOID;\n               I=I+1;\n               #RLD_ELEMENT_PTR=#RLD_ELEMENT_PTR+4;\n               IF #F=ESDID THEN DO;\n                  DO J=1 TO DIM_ESD_ARRAY;\n                     K=J;\n                     IF #T=ESD_ARRAY(K).ID THEN LEAVE;\n                  END;\n                  NN=ESD_ARRAY(K).NAME;\n                  DO WHILE('1'B);\n                     ALLOCATE RLD;\n                     IF RLD_START=NULL THEN RLD_START=RLD_PTR;\n                                       ELSE PREV->RLD.NEXT=RLD_PTR;\n                     PREV=RLD_PTR;\n                     RLD.NEXT=NULL;\n                     RLD.LENGTH=RLDLEN+1;\n                     RLD.OFF=RLDOFF-ESD_ARRAY(ARRINDX).OFF;\n                     RLD.NAME=NN;\n                     RLD.SUBT=RLDE_ELEMENT.SUBT;\n                     RLD.TYPE=$RLDTYPE(RLDTYPE);\n                     IF RLD.TYPE='A' & #F\u00ac=#T THEN DO;\n                        RLD.TYPE='V';\n                     END;\n                     IF \u00acNOTLAST THEN LEAVE;\n                     #RLD_ELEMENT_PTR=#RLD_ELEMENT_PTR+4;\n                     I=I+1;\n                  END;\n               END;\n               ELSE DO;\n                  DO WHILE('1'B);\n                     IF \u00acNOTLAST THEN LEAVE;\n                     #RLD_ELEMENT_PTR=#RLD_ELEMENT_PTR+4;\n                     I=I+1;\n                  END;\n               END;\n               I=I+1;\n               #RLD_ELEMENT_PTR=#RLD_ELEMENT_PTR+4;\n            END;\n            IF CNTL_BLOCK.LAST THEN\n               LEAVE $CSECT_GETTEXT_LOOP;\n         END;\n         /***************************/\n         /* CNTL INFO EXISTS        */\n         /***************************/\n         IF CNTLYES & CNTLNO\u00ac=0 THEN DO;\n            #CNTL_ELEMENT_PTR=#CNTL_BLOCK_PTR+16+RLDNO;\n            $RYES='0'B;\n $CSECT_CNTL_LOOP_#1:\n            DO I=1 TO CNTLNO/4;\n               IF CNTLID=ESDID THEN DO;\n                  K=TXTOFF-ESD_ARRAY(ARRINDX).OFF-LENGTHTEXT();\n                  IF K > 0 THEN DO;\n                     ALLOCATE ORG;\n                     ORG.NEXT=ORG_START;\n                     ORG_START=ORG_PTR;\n                     ORG.OFF=LENGTHTEXT();\n                     ORG.LENGTH=K;\n                     CALL CONCATTEXT(HIGH(K));\n                  END;\n                  J=TEXTLEN-LENGTHTEXT();\n                  IF CNTLLEN < J THEN J=CNTLLEN;\n                  CALL $READ;\n                  IF $EOF THEN GOTO EOF;\n                  $RYES='1'B;\n                  CALL CONCATTEXT(SUBSTR(BLOCK,1,J));\n                  LEAVE $CSECT_CNTL_LOOP_#1;\n               END;\n               #CNTL_ELEMENT_PTR=#CNTL_ELEMENT_PTR+4;\n               IF TEXTLEN=LENGTHTEXT() THEN\n                  LEAVE $CSECT_CNTL_LOOP_#1;\n            END;\n            IF \u00ac$RYES THEN CALL $READ;\n            IF $EOF THEN GOTO EOF;\n         END;\n         CALL $READ;\n         IF $EOF THEN GOTO EOF;\n     END $CSECT_GETTEXT_LOOP;\n\n EOF:\n     IF LENGTHTEXT() < TEXTLEN THEN DO;\n        ALLOCATE     ORG;\n        ORG.NEXT   = ORG_START;\n        ORG_START  = ORG_PTR;\n        ORG.OFF    = LENGTHTEXT();\n        ORG.LENGTH = TEXTLEN-LENGTHTEXT();\n        CALL CONCATTEXT(HIGH(TEXTLEN-LENGTHTEXT()));\n     END;\n\n     CALL COPYTEXT();\n\n END $CSECT;\n %PAGE;\n /*********************************************************************/\n /*  READ NEXT RECORD                                                 */\n /*********************************************************************/\n $READ: PROC ;\n  DCL  I;\n     I = REASLOA('READ', '', '', '', '', BLOCK);\n     IF I \u00ac= 0 THEN $EOF = '1'B;\n     ELSE           $EOF = '0'B;\n END $READ;\n %SKIP;\n /*********************************************************************/\n /*  SORT KNOWLEDGE BASE                                              */\n /*********************************************************************/\n $SORTDSC:\n     PROC RECURSIVE ;\n DCL   SORT  BIT(1) INIT('1'B),\n       (P,Q) PTR INIT(NULL);\n\n     IF DSC_START=NULL THEN RETURN;\n\n     DO WHILE(SORT);\n        SORT='0'B;\n        DSC_PTR=DSC_START;\n        P=DSC.NEXT;\n        DO WHILE(P\u00ac=NULL);\n           IF P->DSC.OFF < DSC.OFF THEN DO;\n             IF DSC_PTR=DSC_START THEN DSC_START=P;\n                                  ELSE Q->DSC.NEXT=P;\n             DSC.NEXT=P->DSC.NEXT;\n             P->DSC.NEXT=DSC_PTR;\n             SORT='1'B;\n             Q=P;\n           END;\n           ELSE DO;\n             Q=DSC_PTR;\n             DSC_PTR=P;\n           END;\n           P=DSC.NEXT;\n        END;\n     END;\n END $SORTDSC;\n %PAGE;\n /*********************************************************************/\n /*  INIT KNOWLEDGE BASE                                              */\n /*********************************************************************/\n $INITDSC:\n     PROC ;\n DCL P      PTR,\n     #VAL   BIN FIXED(31),\n     VAL    CHAR(2) BASED(ADDR(#VAL)),\n     I      BIN FIXED(31);\n\n     CALL $FREE;\n\n     RLD_PTR = RLD_START;\n     DO WHILE(RLD_PTR\u00ac=NULL);\n        ALLOCATE DSC;\n        DSC.NEW='0'B;\n        DSC.FIX='0'B;\n        IF DSC_START=NULL THEN DSC_START      = DSC_PTR;\n                          ELSE PREV->DSC.NEXT = DSC_PTR;\n        PREV = DSC_PTR;\n        DSC  = RLD, BY NAME;\n        DSC.NORED = '1'B;        /* CANN'T REDEFINE |     */\n        DSC.EXTRN = '0'B;\n        DSC.NEXT  = NULL;\n        IF RLD.TYPE='A' THEN\n           CALL $SUBT(RLD.OFF,RLD.LENGTH,ESD_ARRAY(ARRINDX).OFF);\n        IF RLD.TYPE='V' THEN DO;\n           DO I=1 TO DIM_ESD_ARRAY WHILE(ESD_ARRAY(I).NAME \u00ac= RLD.NAME);\n           END;\n           IF ESD_ARRAY(I).NAME = RLD.NAME THEN DO;\n              CALL $SUBT(RLD.OFF,RLD.LENGTH,ESD_ARRAY(I).OFF);\n              ONEBYTE = ESD_ARRAY(I).TYPE;\n              IF \u00acBIT4 & \u00acBIT5 & BIT6 & \u00acBIT7 THEN DSC.EXTRN='1'B;\n           END;\n        END;\n        IF RLD.LENGTH=4 THEN VAL=SUBSTRTEXT(RLD.OFF+1+2,2);\n        ELSE                 VAL=SUBSTRTEXT(RLD.OFF+1+1,2);\n        IF RLD.TYPE='A' THEN\n           CALL $INITLAB($NAME(SUBSTRTEXT(RLD.OFF+1,RLD.LENGTH)),\n                         #VAL,0,'0'B,0);\n        IF SUBSTRTEXT(RLD.OFF+1,RLD.LENGTH) \u00ac= LOW(RLD.LENGTH) &\n           RLD.TYPE='V' THEN\n           DSC.EXTRN='1'B;\n        RLD_PTR=RLD.NEXT;\n     END;\n     DO I=1 TO DIM_ESD_ARRAY;\n        ONEBYTE = ESD_ARRAY(I).TYPE;\n        IF ESD_ARRAY(I).REF=ESDID &\n           \u00acBIT4 & \u00acBIT5 & BIT6 & BIT7 THEN DO;\n           CALL $INITLAB(ESD_ARRAY(I).NAME,\n                         ESD_ARRAY(I).OFF-ESD_ARRAY(ARRINDX).OFF,\n                         0,'1'B,0);\n           LABL.NORED = '1'B;    /* 17/05/91 */\n        END;\n     END;\n     CALL $SORTDSC;\n     ORG_PTR=ORG_START;\n     DO WHILE(ORG_PTR\u00ac=NULL);\n        CALL $INCLUDE(ORG.OFF,ORG.LENGTH,'O');\n        PREV=ORG_PTR;\n        ORG_PTR=ORG.NEXT;\n        FREE PREV->ORG;\n     END;\n     ORG_START=NULL;\n     I=0;\n     DSC_PTR=DSC_START;\n     DO WHILE(DSC_PTR\u00ac=NULL);\n        DSC.NORED='1'B;\n        I=I+DSC.LENGTH;\n        DSC_PTR=DSC.NEXT;\n     END;\n     IF I < TEXTLEN THEN\n        CALL $INCLUDE(0,TEXTLEN,'X');\n END $INITDSC;\n %PAGE;\n /*********************************************************************/\n /*  CONNECT NEIGHBOUR PIECES IN KNOWLEDGE BASE                       */\n /*********************************************************************/\n $CONNECT:\n     PROC RECURSIVE ;\n\n DCL (P,Q) PTR INIT(NULL);\n     DSC_PTR=DSC_START;\n     P=DSC.NEXT;\n     DO WHILE(DSC_PTR\u00ac=NULL & P\u00ac=NULL);\n        IF DSC.OFF+DSC.LENGTH = P->DSC.OFF         &\n           DSC.TYPE              = P->DSC.TYPE     &\n           DSC.NORED             = P->DSC.NORED    &\n           (DSC.TYPE='I' | DSC.TYPE='X' | DSC.TYPE='C' |\n            DSC.TYPE='#' | DSC.TYPE='B'                 ) &\n           \u00acDSC.NORED                              THEN DO;\n           DSC.LENGTH=DSC.LENGTH+P->DSC.LENGTH;\n           DSC.NEXT=P->DSC.NEXT;\n           FREE P->DSC;\n        END;\n        ELSE DO;\n           Q=DSC_PTR;\n           DSC_PTR=P;\n        END;\n        P=DSC.NEXT;\n        IF DSC.LENGTH=0 THEN DO;\n           IF Q\u00ac=NULL THEN Q->DSC.NEXT=DSC.NEXT;\n                      ELSE DSC_START=DSC.NEXT;\n           FREE DSC;\n           DSC_PTR=P;\n           IF DSC_PTR\u00ac=NULL THEN P=DSC.NEXT;\n        END;\n     END;\n\n END $CONNECT;\n %SKIP;\n /*********************************************************************/\n /*  INCLUDE NEW ELEMENT INTO BASE                                    */\n /*********************************************************************/\n $INCLUDE:\n     PROC(FROM,LEN,T) RECURSIVE;\n\n DCL (FROM,LEN,TO) BIN FIXED(31),\n     T        CHAR(1),\n     P        PTR;\n\n     $CONF='1'B;\n\n     IF $REM THEN\n        CALL $AUTOREC;\n\n     /* 1. CREATE NEW ELEMENT AND INCLUDE IT AT TOP OF BASE */\n     ALLOCATE DSC;\n     DSC.OFF=FROM;\n     DSC.LENGTH=LEN;\n     DSC.TYPE=T;\n     DSC.NORED='0'B;\n     DSC.SUBT='0'B;\n     DSC.NEW='1'B;\n     DSC.FIX='0'B;\n     DSC.EXTRN='0'B;\n     DSC.NEXT=DSC_START;\n     DSC.NAME='*';\n     DSC_START=DSC_PTR;\n     /* 2. BASE SORT */\n     CALL $SORTDSC;\n     IF $TRACE THEN\n        CALL $PRINTDSC('NEW ELEMENT:AFTER SORT');\n     /* 3. PRESS TRASH INFO         */\n     CALL $PRESS;\n     IF $TRACE THEN\n        CALL $PRINTDSC('AFTER $PRESS');\n     CALL $CONNECT;\n     IF $TRACE THEN\n        CALL $PRINTDSC('AFTER $CONNECT');\n END $INCLUDE;\n %PAGE;\n /*********************************************************************/\n /*  PRESS TRASH SUBROUTINE                                           */\n /*********************************************************************/\n $PRESS:\n     PROC RECURSIVE ;\n DCL (I,J,K)        BIN FIXED(31),\n     $BIT(4)        BIT(1),\n     (D,SPTR,P,Q,R) PTR;\n\n $PRESS_BEGIN:\n     Q=NULL;\n     D=DSC_START;\n     DO WHILE(\u00acD->DSC.NEW);    /* FIND NEW-ELEMENT */\n        Q=D;\n        D=D->DSC.NEXT;\n     END;\n     P=D->DSC.NEXT;\n\n     IF Q\u00ac=NULL THEN           /* NOT FIRST        */\n        IF Q->DSC.OFF+Q->DSC.LENGTH > D->DSC.OFF THEN DO;\n           P=D;\n           D=Q;\n        END;\n\n $TEST_AGAIN:\n     $BIT='0'B;\n     $BIT(1) = D->DSC.NORED;\n     $BIT(2) = D->DSC.NEW;\n     IF P\u00ac=NULL THEN DO;\n       $BIT(3) = P->DSC.NORED;\n       $BIT(4) = P->DSC.NEW;\n     END;\n     K=0;\n     IF $BIT(1) THEN K=K+8;\n     IF $BIT(2) THEN K=K+4;\n     IF $BIT(3) THEN K=K+2;\n     IF $BIT(4) THEN K=K+1;\n\n     IF $TRACE THEN DO;\n        PUT SKIP DATA($BIT,K);\n        PUT SKIP EDIT('  Q->:',Q->DSC.NAME,$BH(Q->DSC.OFF),\n                      $BH(Q->DSC.LENGTH),Q->DSC.TYPE,Q->DSC.NORED,\n                      Q->DSC.NEW,Q->DSC.FIX,Q->DSC.EXTRN,Q->DSC.SUBT)\n                     ((5)(A,X(1)),(5)(B(1),X(1)));\n        PUT SKIP EDIT('  D->:',D->DSC.NAME,$BH(D->DSC.OFF),\n                      $BH(D->DSC.LENGTH),D->DSC.TYPE,D->DSC.NORED,\n                      D->DSC.NEW,D->DSC.FIX,D->DSC.EXTRN,D->DSC.SUBT)\n                     ((5)(A,X(1)),(5)(B(1),X(1)));\n        PUT SKIP EDIT('  P->:',P->DSC.NAME,$BH(P->DSC.OFF),\n                      $BH(P->DSC.LENGTH),P->DSC.TYPE,P->DSC.NORED,\n                      P->DSC.NEW,P->DSC.FIX,P->DSC.EXTRN,P->DSC.SUBT)\n                     ((5)(A,X(1)),(5)(B(1),X(1)));\n        CALL REASLST;\n     END;\n\n     /*        BITS COORDINATION AND OVERLAY:\n        D->R D->N P->R P->N    WHICH\n        BIT1 BIT2 BIT3 BIT4 WILL BE OVERAYED\n        ---- ---- ---- ---- ----------------\n     0   0    0    0    0      -\"-    0\n     1   0    0    0    1       L     1\n     2   0    0    1    0      -\"-    2\n     3   0    0    1    1       L     3\n     4   0    1    0    0       R     4\n     5   0    1    0    1      -\"-    5\n     6   0    1    1    0       L     6\n     7   0    1    1    1      -\"-    7\n     8   1    0    0    0      -\"-    8\n     9   1    0    0    1       R     9\n    10   1    0    1    0      -\"-   10\n    11   1    0    1    1      -\"-   11\n    12   1    1    0    0       R    12\n    13   1    1    0    1      -\"-   13\n    14   1    1    1    0      -\"-   14\n    15   1    1    1    1      -\"-   15\n     */\n     P=D->DSC.NEXT;\n     IF P\u00ac=NULL THEN DO;\n        I=D->DSC.OFF+D->DSC.LENGTH - P->DSC.OFF;\n        IF I>0 THEN DO;             /* INTERVALS OVERAPPING        */\n           IF K=4 | K=9 | K=12 THEN DO;/* CAN REDEFINE RIGHT       */\n             IF $TRACE THEN\n                PUT SKIP LIST('REDEFINE RIGHT');\n             IF D->DSC.OFF+D->DSC.LENGTH >= /* AFTER OVERLAY       */\n                P->DSC.OFF+P->DSC.LENGTH THEN DO;\n                IF $TRACE THEN\n                   PUT SKIP LIST('FULL OVERLAP');\n                D->DSC.NEXT=P->DSC.NEXT;\n                FREE P->DSC;\n                P=D->DSC.NEXT;\n                IF $TRACE THEN\n                   PUT SKIP LIST('PERFORM TEST_AGAIN');\n                GOTO $TEST_AGAIN;\n             END;\n             ELSE DO;                          /* PARTIAL OVERLAY */\n               P->DSC.OFF=D->DSC.OFF+D->DSC.LENGTH;\n               P->DSC.LENGTH=P->DSC.LENGTH-I;\n               IF P->DSC.TYPE\u00ac='X' & P->DSC.TYPE\u00ac='C' &\n                  P->DSC.TYPE\u00ac='I' & P->DSC.TYPE\u00ac='#' &\n                  P->DSC.TYPE\u00ac='B' THEN\n                  P->DSC.TYPE='X';\n             END;\n           END;\n           ELSE DO;                   /* REDEFINE LEFT            */\n             IF $TRACE THEN\n                PUT SKIP LIST('REDEFINE LEFT');\n             J=D->DSC.LENGTH;\n             D->DSC.LENGTH=P->DSC.OFF - D->DSC.OFF;\n             IF D->DSC.TYPE='F' | D->DSC.TYPE='H' THEN\n                D->DSC.TYPE='X';\n             J=J-D->DSC.LENGTH-P->DSC.LENGTH;\n             IF J>0 THEN DO;          /* SMALL PIECE REST           */\n                IF $TRACE THEN\n                   PUT SKIP EDIT('SMALL PIECE SIZE: ',\n                   $BH(J),' BYTES')(A,A,A);\n                R=DSC_START;\n                DO WHILE(R\u00ac=NULL);\n                   R->DSC.NEW='0'B;\n                   R=R->DSC.NEXT;\n                END;\n                CALL $INCLUDE(P->DSC.OFF+P->DSC.LENGTH,\n                              J,D->DSC.TYPE);\n             END;\n             ELSE DO;\n                Q=P->DSC.NEXT;\n                IF Q\u00ac=NULL & P->DSC.NEW THEN DO;\n                   IF P->DSC.OFF+P->DSC.LENGTH > Q->DSC.OFF THEN\n                      GOTO $PRESS_BEGIN;\n                END;\n             END;\n           END;\n        END;\n        D=P;\n     END;\n     P=DSC_START;\n     DO WHILE(P\u00ac=NULL);\n        P->DSC.NEW='0'B;\n        P=P->DSC.NEXT;\n     END;\n     IF $TRACE THEN CALL REASLST;\n END $PRESS;\n %PAGE;\n /*********************************************************************/\n /*  FILL OFFST  AND OBJECT CODE                                      */\n /*********************************************************************/\n $PUTOBJ:\n     PROC(FROM,LEN,I);\n DCL (FROM,LEN,I) BIN FIXED(31),\n     #CHAR        CHAR(4) BASED(ADDR(FROM));\n\n     REASM02_LINE(I).OFF=$CH(SUBSTR(#CHAR,2));\n     REASM02_LINE(I).OBJECT=$CH(SUBSTRTEXTCOPY(FROM+1,LEN));\n END $PUTOBJ;\n %PAGE;\n /*********************************************************************/\n /*  SHOW PROJECT FROM SPECIFIED OFFST                                */\n /*********************************************************************/\n $SHOW:\n     PROC ;\n DCL\n     $CHAR(4) CHAR(1) STATIC INT INIT('1','2','3','4'),\n     MAXLEN   BIN FIXED(31),\n     #VAL     BIN FIXED(31),\n     VAL      CHAR(4) BASED(ADDR(#VAL)),\n     #HVAL    BIN FIXED(15),\n     HVAL     CHAR(2) BASED(ADDR(#HVAL)),\n     #LOCVAR  CHAR(60) VAR,\n     (Q,P,LAB,XLAB)    PTR,\n     1 SLINE  LIKE REASM02_LINE,\n     1 SCONST UNALIGNED BASED(SPTR),\n       2 B    BIT(4),      /* BASE REG */\n       2 D    BIT(12),     /* OFFST    */\n     SPTR     PTR,\n     (I,K,NOLABEL)    BIN FIXED(31) INIT(0);\n\n     IF OFFSET < 0 THEN OFFSET=0;\n     #OFFSET,$OFFSET = OFFSET;\n\n     #CURI=1;\n     IV = ' ';\n     DO I=1 TO 10;\n        CALL REASQPW('CHECK',PASS(I),JDAT);\n     END;\n\n     DO WHILE('1'B);\n\n        IF #OFFSET=0 THEN DO;\n           CALL PRINT_CSECT;\n           CALL PRINT_DXD;\n        END;\n\n        #COM='';\n        IF #OFFSET >= TEXTLEN THEN   GOTO $AFTER_FIND;\n        CALL $FINDDSC(#OFFSET);      /* FIND DSC ELEMENT */\n        MAXLEN=TEXTLEN-#OFFSET;\n        $ORGIMM='';\n\n        IF DSC.TYPE='I' THEN DO;     /* COMMAND */\n           IF MOD(#OFFSET,2)\u00ac=0 THEN GOTO $SHOW_X;\n           CALL $CMD(#OFFSET,#CURI);\n           CALL $FINDDSC(#OFFSET);\n           IF REASM02_LINE(#CURI).OPER='' THEN GOTO $SHOW_X;\n           I=CMDLEN(CMDDEF);\n           IF I > MAXLEN THEN DO;\n              CALL $INCLUDE(#OFFSET,I-MAXLEN,'X');\n              GOTO $SHOW_X;\n           END;\n           IF I > DSC.LENGTH-(#OFFSET-DSC.OFF) THEN\n              GOTO $SHOW_X;\n        END;\n\n        IF REASM02_LINE(#CURI).OPER = '' THEN\n           REASM02_LINE(#CURI).OPER = 'DC';\n\n        IF DSC.TYPE='F' THEN DO;       /* F-CONST */\n           MAXLEN=TEXTLEN-#OFFSET;\n           IF MAXLEN < 4 THEN GOTO $SHOW_X;\n           CALL $PUTOBJ(#OFFSET,4,#CURI);\n           VAL=SUBSTRTEXT(#OFFSET+1,4);\n           IF MOD(#OFFSET,4)=0 THEN LOCVAR='';\n           ELSE                     LOCVAR='L4';\n           REASM02_LINE(#CURI).OPERANDS=\n             'F' || LOCVAR || '''' ||  $DIGIT(#VAL) || '''';\n           I=4;\n        END;\n\n        IF DSC.TYPE='3' THEN DO;       /* 3-BYTE CONST */\n           MAXLEN=TEXTLEN-#OFFSET;\n           IF MAXLEN < 3 THEN GOTO $SHOW_X;\n           CALL $PUTOBJ(#OFFSET,3,#CURI);\n           VAL=SUBSTRTEXT(#OFFSET,4);\n           SUBSTR(VAL,1,1)=LOW(1);\n           REASM02_LINE(#CURI).OPERANDS=\n             'AL3(' ||  $DIGIT(#VAL) || ')';\n           I=3;\n        END;\n\n        IF DSC.TYPE='S' THEN DO;                 /* S-CONST   */\n           MAXLEN=TEXTLEN-#OFFSET;\n           IF MAXLEN<2          THEN GOTO $SHOW_X;\n           IF MOD(#OFFSET,2)\u00ac=0 THEN GOTO $SHOW_X;\n           CALL $PUTOBJ(#OFFSET,2,#CURI);\n           HVAL  = SUBSTRTEXT(#OFFSET+1,2);\n           SPTR = ADDR(HVAL);\n           GLOBAL_IP = 0;\n           #LOCVAR = $ADDR(SCONST.B,SCONST.D,0,'0'B,0,'0'B,'',#OFFSET);\n           IF SUBSTR(#LOCVAR,LENGTH(#LOCVAR),1)=')' THEN\n              GOTO $SHOW_X;\n           IF #LOCVAR='*-0' | #LOCVAR='*+0' THEN #LOCVAR='*'; /*BELLS*/\n           REASM02_LINE(#CURI).OPERANDS = 'S(' || #LOCVAR || ')';\n           I=2;\n        END;\n\n        IF DSC.TYPE='H' | DSC.TYPE='Y' THEN DO;  /* H/Y-CONST */\n           MAXLEN = TEXTLEN-#OFFSET;\n           IF MAXLEN<2 THEN GOTO $SHOW_X;\n           CALL $PUTOBJ(#OFFSET,2,#CURI);\n           HVAL=SUBSTRTEXT(#OFFSET+1,2);\n           #VAL=0; SUBSTR(VAL,3,2) = HVAL;\n           IF MOD(#OFFSET,2)=0 THEN LOCVAR='';\n           ELSE                     LOCVAR='L2';\n           IF DSC.TYPE='H' THEN   /* H-CONST */\n              REASM02_LINE(#CURI).OPERANDS=\n                     'H' || LOCVAR || '''' || $DIGIT(#HVAL) || '''';\n           ELSE                   /* Y-CONST */\n              REASM02_LINE(#CURI).OPERANDS=\n                     'Y' || LOCVAR || '('  ||  $DIGIT(#VAL)  || ')';\n           I=2;\n        END;\n\n        IF DSC.TYPE='1' THEN DO;       /* 1-BYTE CONST */\n           CALL $PUTOBJ(#OFFSET,1,#CURI);\n           ICH = 0;\n           CH  = SUBSTRTEXT(#OFFSET+1,1);\n           REASM02_LINE(#CURI).OPERANDS=\n             'AL1(' || $DIGIT(ICH) || ')';\n           I=1;\n        END;\n\n        IF DSC.TYPE='P' THEN DO;     /* PACKED DECIMAL DATA */\n           DCL SIGN CHAR(1)  VAR;\n           I = DSC.LENGTH;\n           IF I > 8 THEN GOTO $SHOW_X;\n           LOCVAR=$CH(SUBSTRTEXTCOPY(#OFFSET+1,I));\n           SELECT (SUBSTR(LOCVAR,LENGTH(LOCVAR),1));\n              WHEN ('D') SIGN = '-';\n              WHEN ('C') SIGN = '';\n              OTHERWISE GOTO $SHOW_X;\n           END;\n           LOCVAR = SUBSTR(LOCVAR,1,LENGTH(LOCVAR)-1);\n           DO J=1 TO LENGTH(LOCVAR);\n              IF SUBSTR(LOCVAR,J,1)<'0' | SUBSTR(LOCVAR,J,1)>'9' THEN\n                 GOTO $SHOW_X;\n           END;\n           CALL $PUTOBJ(#OFFSET,I,#CURI);\n           REASM02_LINE(#CURI).OPERANDS =\n                'P''' || SIGN || LOCVAR || '''';\n        END;\n\n        IF DSC.TYPE='X' THEN DO;    /* HEX-DATA */\n $SHOW_X:  I=MIN(DSC.LENGTH-(#OFFSET-DSC.OFF),4,MAXLEN);   /* 1995 */\n           REASM02_LINE(#CURI).OPER = 'DC';\n           LABL_PTR=LABL_START;\n           DO WHILE(LABL_PTR\u00ac=NULL);\n              IF LABL.OFF > #OFFSET THEN\n                 I=MIN(I,LABL.OFF-#OFFSET);\n              LABL_PTR=LABL.NEXT;\n           END;\n           CALL $PUTOBJ(#OFFSET,I,#CURI);\n           LOCVAR = SUBSTR(REASM02_LINE(#CURI).OBJECT,1,I*2);\n           REASM02_LINE(#CURI).OPERANDS = 'X''' || LOCVAR || '''' ;\n           LOCVAR = SUBSTRTEXT(#OFFSET+1,I);\n           IF $CHARSTR(LOCVAR) THEN\n              #COM = 'C''' || LOCVAR || '''';\n        END;\n\n        IF DSC.TYPE='B' THEN DO; /* BIT CONSTANT */\n           CALL $PUTOBJ(#OFFSET,1,#CURI);\n           REASM02_LINE(#CURI).OPERANDS =\n                  $BITSTR(SUBSTRTEXT(#OFFSET+1,1));\n           I=1;\n        END;\n\n        IF DSC.TYPE='C' THEN DO;    /* CHAR-DATA */\n           I=MIN(DSC.LENGTH-(#OFFSET-DSC.OFF),LINELEN,MAXLEN);\n           LABL_PTR=LABL_START;\n           DO WHILE(LABL_PTR\u00ac=NULL);\n              IF LABL.OFF > #OFFSET THEN\n                 I=MIN(I,LABL.OFF-#OFFSET);\n              LABL_PTR=LABL.NEXT;\n           END;\n           CALL $PUTOBJ(#OFFSET,I,#CURI);\n           LOCVAR='';\n           ICH=0;\n           DO J=1 TO I;\n              CH=SUBSTRTEXT(#OFFSET+J,1);\n              CH=SUBSTR(GOODA,ICH+1,1);\n              LOCVAR=LOCVAR || CH;\n              IF CH='''' | CH='&' THEN\n                 LOCVAR=LOCVAR || CH;\n           END;\n           REASM02_LINE(#CURI).OPERANDS = 'C''' || LOCVAR || '''';\n        END;\n\n        IF DSC.TYPE='Q' THEN DO;    /* Q-CONST */\n           #OFFSET = MIN(DSC.OFF,#OFFSET);\n           CALL $PUTOBJ(#OFFSET,DSC.LENGTH,#CURI);\n           I=DSC.LENGTH;\n           REASM02_LINE(#CURI).OPERANDS=\n             'QL' || $CHAR(DSC.LENGTH) || '(' ||\n             $NEXTEL(DSC.NAME) || ')';\n           #AZO(REASM02_LINE(#CURI).CMD#);\n           IF $XREF THEN\n              CALL $PUTXRF(DSC.NAME);\n        END;\n\n        IF DSC.TYPE='D' THEN DO;    /* CXD-CONST */\n           #OFFSET = MIN(DSC.OFF,#OFFSET);\n           CALL $PUTOBJ(#OFFSET,DSC.LENGTH,#CURI);\n           I=DSC.LENGTH;\n           REASM02_LINE(#CURI).OPER='CXD';\n           REASM02_LINE(#CURI).LABEL='';\n           #AZO(REASM02_LINE(#CURI).CMD#);\n        END;\n\n        IF DSC.TYPE='A' THEN DO; /* A-CONST */\n           #OFFSET = MIN(DSC.OFF,#OFFSET);\n           CALL $PUTOBJ(#OFFSET,DSC.LENGTH,#CURI);\n           I=DSC.LENGTH;\n           IF DSC.LENGTH\u00ac=4 THEN\n             REASM02_LINE(#CURI).OPERANDS=\n             'AL' || $CHAR(DSC.LENGTH) ||\n             '('||$NAME(SUBSTRTEXT(#OFFSET+1,DSC.LENGTH))||')';\n           ELSE\n             REASM02_LINE(#CURI).OPERANDS=\n             'A('||$NAME(SUBSTRTEXT(#OFFSET+2,3))||')';\n           #AZO(REASM02_LINE(#CURI).CMD#);\n\n           /* INSERTED ON FLKEYS */\n           IF DSC.LENGTH=4 & SUBSTRTEXT(#OFFSET+1,1)\u00ac=LOW(1) THEN DO;\n              CALL $LABEL(#OFFSET,I);\n              NOLABEL = 1;\n              CALL $PUTLINE;\n              REASM02_LINE(#CURI).OPER='ORG';\n              REASM02_LINE(#CURI).OPERANDS='*-4';\n              #AZP(REASM02_LINE(#CURI).CMD#);\n              #AZP(REASM02_LINE(#CURI).LABEL#);\n              LINE_I(#CURI),LINE_C(#CURI)=0;\n              LINE_O(#CURI)=I;\n              CALL $PUTLINE;\n              REASM02_LINE(#CURI).OPER='DC';\n              CALL $PUTOBJ(#OFFSET,1,#CURI);\n              LOCVAR = SUBSTR(REASM02_LINE(#CURI).OBJECT,1,2);\n              REASM02_LINE(#CURI).OPERANDS = 'X''' || LOCVAR || '''' ;\n              #AZP(REASM02_LINE(#CURI).CMD#);\n              #AZP(REASM02_LINE(#CURI).LABEL#);\n              LINE_I(#CURI),LINE_C(#CURI)=0;\n              LINE_O(#CURI)=I;\n              CALL $PUTLINE;\n              REASM02_LINE(#CURI).OPER='ORG';\n              REASM02_LINE(#CURI).OPERANDS='*+3';\n              #AZP(REASM02_LINE(#CURI).CMD#);\n              #AZP(REASM02_LINE(#CURI).LABEL#);\n              LINE_I(#CURI),LINE_C(#CURI)=0;\n              LINE_O(#CURI)=I+1;\n           END;\n        END;\n\n        IF DSC.TYPE='V' THEN DO;    /* V-CONST */\n           #OFFSET = MIN(DSC.OFF,#OFFSET);\n           CALL $PUTOBJ(#OFFSET,DSC.LENGTH,#CURI);\n\n           I = DSC.LENGTH;\n           IF DSC.LENGTH=3 THEN HVAL=SUBSTRTEXT(#OFFSET+2,2);\n           ELSE                 HVAL=SUBSTRTEXT(#OFFSET+3,2);\n           IF DSC.LENGTH=4 THEN #LOCVAR='';\n           ELSE                 #LOCVAR='L' || $CHAR(DSC.LENGTH);\n           IF \u00acDSC.EXTRN THEN DO;\n              REASM02_LINE(#CURI).OPERANDS=\n                'V' || #LOCVAR || '(' || DSC.NAME;\n              DO J=1 TO DIM_ESD_ARRAY;\n                 ONEBYTE = ESD_ARRAY(J).TYPE;\n                 IF ESD_ARRAY(J).NAME=DSC.NAME &\n                    (BIT4 & \u00acBIT5 & BIT6 & \u00acBIT7) THEN   /* 0A */\n                    REASM02_LINE(#CURI).OPERANDS=\n                      'A' || #LOCVAR || '(' || DSC.NAME;\n              END;\n           END;\n           ELSE DO;\n              LOCVAR='';\n              IF #HVAL > 0 THEN LOCVAR='+' || $DIGIT(#HVAL);\n              IF #HVAL < 0 THEN LOCVAR= $DIGIT(#HVAL);\n              REASM02_LINE(#CURI).OPERANDS=\n                'A' || #LOCVAR || '(' || $NEXTEL(DSC.NAME) || LOCVAR;\n           END;\n           SUBSTR(REASM02_LINE(#CURI).OPERANDS,\n                  INDEX(REASM02_LINE(#CURI).OPERANDS,' '),1)=')';\n           #AZO(REASM02_LINE(#CURI).CMD#);\n           IF $XREF THEN\n              CALL $PUTXRF(DSC.NAME);\n        END;\n\n        IF DSC.TYPE='O' THEN DO;          /* ORG */\n           #OFFSET = MIN(DSC.OFF,#OFFSET);\n           CALL $PUTOBJ(#OFFSET,DSC.LENGTH,#CURI);\n           REASM02_LINE(#CURI).OBJECT='';\n           I=DSC.LENGTH;\n           REASM02_LINE(#CURI).OPER='ORG';\n           REASM02_LINE(#CURI).OPERANDS='*+' || $DIGIT(DSC.LENGTH);\n           #AZO(REASM02_LINE(#CURI).CMD#);\n        END;\n\n        IF DSC.TYPE='#' THEN DO;          /* DS XL ?  */\n           #OFFSET = MIN(DSC.OFF,#OFFSET);        /* 08.12.87 */\n           I=MIN(DSC.LENGTH-(#OFFSET-DSC.OFF),MAXLEN);\n           LABL_PTR=LABL_START;\n           DO WHILE(LABL_PTR\u00ac=NULL);\n              IF LABL.OFF > #OFFSET THEN\n                 I=MIN(I,LABL.OFF-#OFFSET);\n              LABL_PTR=LABL.NEXT;\n           END;\n           REASM02_LINE(#CURI).OPER='DS';\n           REASM02_LINE(#CURI).OPERANDS=\n             'XL' || $DIGIT(I);                  /* 08.12.87 */\n        END;\n\n        IF REASM02_LINE(#CURI).OPER='' THEN DO;\n           PUT SKIP LIST('UNKNOWN ANIMAL:');\n           PUT SKIP DATA(REASM02_LINE(#CURI),#OFFSET,DSC);\n           CALL REASLST;\n           SIGNAL ERROR;\n           STOP;\n        END;\n\n        IF NOLABEL=0 THEN\n           CALL $LABEL(#OFFSET,I);\n        NOLABEL=0;\n\n        SLINE=REASM02_LINE(#CURI), BY NAME;\n\n        USING_PTR=USING_START;\n        DO WHILE(USING_PTR\u00ac=NULL);\n           /**********************/\n           /* SHOW DROPS         */\n           /**********************/\n           K=USING.PLACE+USING.LENGTH;\n           IF K>=#OFFSET & K<#OFFSET+I THEN DO;\n              REASM02_LINE(#CURI).OBJECT='';\n              REASM02_LINE(#CURI).OFF='';\n              #AZO(REASM02_LINE(#CURI).CMD#);\n              #AZO(REASM02_LINE(#CURI).LABEL#);\n              REASM02_LINE(#CURI).LABEL='';\n              REASM02_LINE(#CURI).OPER='DROP';\n              REASM02_LINE(#CURI).OPERANDS=$REGS(USING.REG);\n              #AZP(REASM02_LINE(#CURI).OPER#);\n              #AZP(REASM02_LINE(#CURI).OPERANDS#);\n              LINE_I(#CURI),LINE_C(#CURI)=0;\n              LINE_O(#CURI)=#OFFSET;\n              CALL $PUTLINE;\n           END;\n           USING_PTR=USING.NEXT;\n        END;\n        /**********************/\n        /* PROCESS   USING    */\n        /**********************/\n        USING_PTR=USING_START;\n        DO WHILE(USING_PTR\u00ac=NULL);\n           IF USING.PLACE >= #OFFSET & USING.PLACE < #OFFSET+I THEN DO;\n              #AZO(REASM02_LINE(#CURI).CMD#);\n              #AZO(REASM02_LINE(#CURI).LABEL#);\n              REASM02_LINE(#CURI).LABEL='';\n              REASM02_LINE(#CURI).OPER='USING';\n              REASM02_LINE(#CURI).OFF='';\n              REASM02_LINE(#CURI).OBJECT='';\n              #AZP(REASM02_LINE(#CURI).OPER#);\n              #AZP(REASM02_LINE(#CURI).OPERANDS#);\n              J=USING.OFF-#OFFSET;\n              IF USING.NAME='' THEN DO;\n                 IF J=0 THEN\n                    REASM02_LINE(#CURI).OPERANDS='*,'||$REGS(USING.REG);\n                 ELSE DO;\n                    LOCVAR=$BH(USING.OFF);      /* 14.09.88 */\n                    DO WHILE(LENGTH(LOCVAR)>1 & SUBSTR(LOCVAR,1,1)='0');\n                       LOCVAR=SUBSTR(LOCVAR,2);\n                    END;\n                    REASM02_LINE(#CURI).OPERANDS=$NEXTEL(CSECT) ||\n                             '+X''' || LOCVAR || ''',' ||\n                             $REGS(USING.REG);\n\n                    IF 1 /*USING.OFF <= USING.PLACE*/ THEN DO;\n                       XLAB = NULL;\n                       LAB  = LABL_START;     /* FIND GOOD LABEL */\n                       DO WHILE(LAB\u00ac=NULL);\n                          IF LAB->LABL.OFF <= USING.OFF THEN DO;\n                             IF XLAB=NULL |\n                              LAB->LABL.OFF > XLAB->LABL.OFF THEN\n                              XLAB=LAB;\n                          END;\n                          LAB = LAB->LABL.NEXT;\n                       END;\n                       IF XLAB\u00ac=NULL THEN DO;\n                         J = USING.OFF-XLAB->LABL.OFF;\n                         IF J<=#ABSA THEN DO;\n                            LOCVAR = '';\n                            IF J>0 THEN LOCVAR = '+' || $DIGIT(J);\n                            REASM02_LINE(#CURI).OPERANDS=\n                                  $NEXTEL(XLAB->LABL.NAME) || LOCVAR ||\n                                  ',' || $REGS(USING.REG);\n                         END;\n                       END;\n                   END;\n                 END;\n              END;\n              ELSE\n                 REASM02_LINE(#CURI).OPERANDS=\n                            $NEXTEL(SUBSTR(USING.NAME,2)) || ',' ||\n                            $REGS(USING.REG);\n              LINE_I(#CURI),LINE_C(#CURI)=0;\n              LINE_O(#CURI)=#OFFSET;\n              CALL $PUTLINE;\n           END;\n           USING_PTR=USING.NEXT;\n        END;\n\n        REASM02_LINE(#CURI)=SLINE, BY NAME;\n\n        LINE_I(#CURI)=I;\n        LINE_O(#CURI)=#OFFSET;\n        LINE_C(#CURI)=0;\n        CALL $PUTCOM(#CURI);\n        CALL $PUTLINE;\n\n        IF $ORGIMM\u00ac='' THEN DO;\n           REASM02_LINE(#CURI).OPER='ORG';\n           REASM02_LINE(#CURI).OPERANDS = $ORGIMM_B;\n           #AZP(REASM02_LINE(#CURI).CMD#);\n           #AZP(REASM02_LINE(#CURI).LABEL#);\n           LINE_I(#CURI),LINE_C(#CURI)=0;\n           LINE_O(#CURI)=I;\n           CALL $PUTLINE;\n           REASM02_LINE(#CURI).OPER='DC';\n           REASM02_LINE(#CURI).OPERANDS=$ORGIMM;\n           CALL $PUTOBJ(#OFFSET+1,1,#CURI);\n           #AZP(REASM02_LINE(#CURI).CMD#);\n           #AZP(REASM02_LINE(#CURI).LABEL#);\n           LINE_I(#CURI),LINE_C(#CURI)=0;\n           LINE_O(#CURI)=I;\n           CALL $PUTLINE;\n           REASM02_LINE(#CURI).OPER='ORG';\n           REASM02_LINE(#CURI).OPERANDS = $ORGIMM_F;\n           #AZP(REASM02_LINE(#CURI).CMD#);\n           #AZP(REASM02_LINE(#CURI).LABEL#);\n           LINE_I(#CURI),LINE_C(#CURI)=0;\n           LINE_O(#CURI)=I;\n           CALL $PUTLINE;\n           $ORGIMM='';\n        END;\n\n        #OFFSET = #OFFSET + I;\n\n $AFTER_FIND:                            /* 27.11.87 */\n        IF #CURI=1 & ($FIND | IV = 'PF08') THEN\n           $OFFSET=#OFFSET;\n        OFFSET=$OFFSET;\n        IF #OFFSET >= TEXTLEN THEN DO;\n           CALL PRINT_EXTRN_WXTRN;\n           CALL PRINT_REGEQ_LTORG;\n           CALL PRINT_DSECTS;\n           CALL PRINT_END_STMT;\n\n           IF PRINTBIT THEN DO;\n              PRINTBIT='0'B;\n              OFFSET=FOFFSET;\n              $CONF='0'B;\n              IF $XREF THEN DO;\n                 CALL $PRINT_XREF;\n                 CALL ISPLINK('SETMSG ', 'REAS004 ');/* PRINTED XREF */\n              END;\n              ELSE\n                 CALL ISPLINK('SETMSG ', 'REAS003 ');/* PRINTED */\n              $XREF='0'B;\n              CALL REASLST;\n              GOTO $RETURN_FROM_$SHOW;\n           END;\n           IF SAVEBIT THEN DO;\n              SAVEBIT='0'B;\n              I = REASLIB(SOURCE, 'CLOSE', '');\n              OFFSET=FOFFSET;\n              $CONF='0'B;\n              GOTO $RETURN_FROM_$SHOW;\n           END;\n           IF $FIND THEN DO;  /* FIND WAS ACTIVE BUT UNSUCCESSFUL */\n              $FIND='0'B;\n              #CUR(ZZCMD,1);\n              CALL $CLEAR_SCR;\n              FINDTXT = #FIND;\n              CALL ISPLINK('SETMSG ', 'REAS006 '); /* NOT FOUND */\n              GOTO $RETURN_FROM_$SHOW;\n           END;\n           #OFFSET=0;\n        END;\n     END;\n $RETURN_FROM_$SHOW:\n     RETURN;\n %PAGE;\n /*********************************************************************/\n /*  WRITE STRING ON SCREEN                                           */\n /*********************************************************************/\n $PUTLINE: PROC;\n DCL PRIMARY    CHAR(80) VAR,\n     (T1,T2,T3) CHAR(1),\n     LOCV       CHAR(10) VAR,\n     NN         CHAR(8) VAR,\n     (P,Q,R)    PTR,\n     GLOBAL     BIT(1) INIT('0'B),\n     LINE       CHAR(80) BASED(LINE_PTR),\n     LINE_PTR   PTR,\n     BYTE       CHAR(1),\n     COMMENT    CHAR(80) VAR,\n     (I,II,III,II1,II2,IJ,J,JJ,JJJ,K) BIN FIXED(31);\n\n     IF $XREF THEN DO;\n        LOCVAR=REASM02_LINE(#CURI).OPER;\n        IF LOCVAR\u00ac='' & LOCVAR\u00ac='ENTRY' THEN\n           CALL $PUTXRF(LOCVAR);\n     END;\n\n     IF #CURI >= MAXLVL-3 THEN DO;\n\n        IF PRINTBIT THEN DO;\n           CALL $PUTLINE_PRINT;\n           GOTO $PUTLINE_END;\n        END;\n\n        IF SAVEBIT THEN DO;\n           CALL $PUTLINE_SAVE;\n           GOTO $PUTLINE_END;\n        END;\n\n        IF $FIND THEN DO;\n           DO I=1 TO MAXLVL-3;\n              IF $MATCH THEN J=MATCH(REASM02_CHARL(I),#FIND);\n              ELSE           J=INDEX(REASM02_CHARL(I),#FIND);\n              IF J\u00ac=0 & LINE_O(I) < TEXTLEN THEN DO;\n                 #CUR(SCREEN,(I-1)*80+2);\n                 /* #CUR(REASM02_LINE(I).LABEL#,J+1,NAME); */\n                 #ANP(REASM02_LINE(I).LABEL#);\n                 #AZP(REASM02_LINE(I).OFF#);\n                 BOFFSET = LINE_O(I)+LINE_I(I);\n                 IF LINE_I(I) = 0 THEN BOFFSET=LINE_O(I)+2;\n                 FINDTXT = #FIND;\n                 CALL ISPLINK('SETMSG ','REAS007 ');\n                 $FIND   = '0'B;\n                 CALL $GOODCMD(BOFFSET);\n                 IF (I>LVL) THEN DO;\n                   OFFSET = LINE_O(I);\n                   CALL $CLEAR_SCR;\n                   #AZP(REASM02_LINE(1).OFF#);\n                   REASM02_PRIMARY = ' ';\n                   GOTO $RETURN_FROM_$SHOW;\n                 END;\n                 GOTO CALLTV02;\n              END;\n           END;\n           GOTO $PUTLINE_END;\n        END;\n\n CALLTV02:\n        CALL ISPLINK('DISPLAY ','REASM02 ', ' ');\n\n        COLIN, STRIN = 2;\n        IF FIELD = 'SCREEN' THEN DO;\n           STRIN = POS/80+4;\n           COLIN = POS - (STRIN-4)*80 + 1;\n        END;\n\n        IF PLIRETV() = 8 THEN IV = 'PF03';\n\n        CALL CALCULATE_LVL;\n\n        PRIMARY=REASM02_PRIMARY || (80)' ';\n        DO I=1 TO MAXLVL-3; #AZO(REASM02_LINE(I).OFF#); END;\n\n        #CUR(ZZCMD,1);\n        IF STRIN > 3 THEN DO;\n           #AZP(REASM02_LINE(STRIN-3).OFF#);\n           I = COLIN;\n           IF I<=4 THEN I=3;\n           #CUR(SCREEN,(STRIN-4)*80+I-1);\n        END;\n\n        IF $CONFP &\n           (IV = 'PF03'            |\n            REASM02_PRIMARY = 'E'  |\n            REASM02_PRIMARY= 'END' |\n            REASM02_PRIMARY= 'Y'   ) THEN\n            GOTO $RETURN_FROM_$SHOW;\n        $CONFP='0'B;\n\n        IF IV = 'PF03'  THEN GOTO $RETURN_FROM_$SHOW;\n\n                        /*********************************************/\n                        /*  LINE COMMAND PROCESS SECTION             */\n                        /*********************************************/\n        DO II=1 TO LVL;\n          IF REASM02_LINE(II).CMD\u00ac='' THEN DO;\n             LOCVAR = REASM02_LINE(II).CMD;\n             IF LOCVAR\u00ac='' THEN\n                LOCVAR = SUBSTR(LOCVAR,VERIFY(LOCVAR,' '));\n             LOCVAR = LOCVAR || '   ';\n             T1 = SUBSTR(LOCVAR,1,1);\n             T2 = SUBSTR(LOCVAR,2,1);\n             T3 = SUBSTR(LOCVAR,3,1);\n             IF T1='_' THEN T1=' ';\n             IF T2='_' THEN T2=' ';\n             IF T3='_' THEN T3=' ';\n             IF (T1||T2||T3 \u00ac= '') THEN DO;\n                IF T1= ' ' THEN DO; T1=T2;T2=T3;T3=' '; END;\n                IF T1= ' ' THEN DO; T1=T2;T2=T3;T3=' '; END;\n             END;\n             UNSPEC(T1) = UNSPEC(T1) | UNSPEC(' ');\n             UNSPEC(T2) = UNSPEC(T2) | UNSPEC(' ');\n             UNSPEC(T3) = UNSPEC(T3) | UNSPEC(' ');\n             NN = T2 || T3;\n\n             IF T1='U' THEN DO;            /* LINE USING COMMAND */\n                 IF NN\u00ac='' THEN DO;            /* UXX SPECIFIED */\n                    ON CONV GOTO $LREG;\n                    GET STRING(NN) LIST(J);\n                    REVERT CONV;\n                    IF J<=0 | J>15 THEN DO;\n $LREG:                CALL ISPLINK('SETMSG ','REAS008 '); /* INVREG*/\n                       REVERT CONV;\n                       GOTO $ERR_PRIMARY;\n                    END;\n                    CALL $INITUSING(LINE_O(II),J,LINE_O(II),'',0);\n                    GOTO $LCMD_END;\n                 END;\n                 ELSE DO;         /* USING WITHOUT REGISTER */\n                    REASM02_PRIMARY =\n                    'U '||SUBSTR($BH(LINE_O(II)),3)||',R?';\n                    CALL ISPLINK('SETMSG ','REAS009 '); /* SPECREG */\n                    REASM02_LINE(II).CMD='';\n                    #CUR(ZZCMD,11);\n                    GOTO CALLTV02;\n                 END;\n             END;\n\n             IF T1='D' THEN DO;            /* DROP COMMAND */\n                 IF NN\u00ac='' THEN DO;\n                    ON CONV GOTO $LREG;\n                    GET STRING(NN) LIST(J);\n                    REVERT CONV;\n                    IF J<0 | J>15 THEN GOTO $LREG;\n                    P=NULL;\n                    USING_PTR=USING_START;\n                    DO WHILE(USING_PTR\u00ac=NULL);\n                       IF USING.REG=J &\n                          USING.PLACE < LINE_O(II) THEN DO;\n                          IF P=NULL THEN P=USING_PTR;\n                          ELSE DO;\n                             IF P->USING.PLACE < USING.PLACE THEN\n                                P=USING_PTR;\n                          END;\n                       END;\n                       USING_PTR=USING.NEXT;\n                    END;\n                    IF P=NULL THEN GOTO $LREG;\n                    P->USING.LENGTH=LINE_O(II) - P->USING.PLACE;\n                    Q=LABL_START;\n                    R=NULL;\n                    DO WHILE(Q\u00ac=NULL);\n                       IF Q->LABL.REG = P->USING.REG &\n                          Q->LABL.OFF>P->USING.PLACE+P->USING.LENGTH\n                          THEN DO;\n                          IF R=NULL THEN   LABL_START=Q->LABL.NEXT;\n                                    ELSE R->LABL.NEXT=Q->LABL.NEXT;\n                          FREE Q->LABL;\n                          IF R=NULL THEN   Q=LABL_START;\n                                    ELSE   Q=R->LABL.NEXT;\n                       END;\n                       ELSE DO;\n                          R=Q;\n                          Q=Q->LABL.NEXT;\n                       END;\n                    END;\n                 END;\n                 ELSE DO;\n $DROP_BY_ADR:      P=NULL;\n                    USING_PTR=USING_START;\n                    DO WHILE(USING_PTR\u00ac=NULL);\n                       IF USING.PLACE=LINE_O(II) THEN DO;\n                          IF P=NULL THEN USING_START=USING.NEXT;\n                                    ELSE P->USING.NEXT=USING.NEXT;\n                          FREE USING;\n                          GOTO $DROP_BY_ADR;\n                       END;\n                       P=USING_PTR;\n                       USING_PTR=USING.NEXT;\n                    END;\n                 END;\n                 GOTO $LCMD_END;\n             END;\n\n             IF T1 = 'R' THEN DO;        /* LINE RETRANSLATE */\n                J = LINE_O(II);\n                IF COLIN > 14  &  COLIN < 14+LINE_I(II)*2 THEN DO;\n                   J = J + (COLIN-14)/2;\n                END;\n                GLOBAL = '0'B;\n                GOTO $RETRANSLATE;\n             END;\n\n             I = LINE_I(II);\n             SELECT (T1);\n               WHEN ('X');                           /* HEX     */\n               WHEN ('C');                           /* CHAR    */\n               WHEN ('P');                           /* PACKED  */\n               WHEN ('#');                           /* DS      */\n               WHEN ('B');                           /* BIT     */\n               WHEN ('A','F') DO; I=4; T1='F'; END;  /* WORD    */\n               WHEN ('H','Y')     I=2;               /* HALFWORD*/\n               WHEN ('S')         I=2;               /* S-CONST */\n               OTHER DO;\n                 CALL ISPLINK('SETMSG ','REAS011 '); /* INVTYPE */\n                 GOTO $ERR_PRIMARY;\n               END;\n             END;\n             IF T2='' THEN DO;\n $SETLINE:      CALL $INCLUDE(LINE_O(II),I,T1);\n                IF T1='C' THEN DO;\n                  ICH=0;\n                  DO III=LINE_O(II) BY 1 TO LINE_O(II)+I;\n                     CH = SUBSTRTEXT(III+1,1);\n                     IF SUBSTR(GOODA,ICH+1,1)=HIGH(1) THEN\n                        CALL $INCLUDE(III,1,'X');\n                  END;\n                END;\n             END;\n             ELSE DO;\n                IF T1=T2 THEN DO;    /* BLOCK COMMAND   */\n                   IF PENDING THEN DO;\n                      IF BLOCK_CMD.TYPE\u00ac=T1 THEN DO;\n                         CALL ISPLINK('SETMSG ','REAS012 '); /*DFTYP*/\n                         GOTO $ERR_PRIMARY;\n                      END;\n                      PENDING='0'B;\n                      BLOCK_CMD.O2=LINE_O(II);\n                      K=MIN(BLOCK_CMD.O1,BLOCK_CMD.O2);\n                      J=ABS(BLOCK_CMD.O1-BLOCK_CMD.O2);\n                      IF BLOCK_CMD.O1 > BLOCK_CMD.O2 THEN\n                         J=J+BLOCK_CMD.LEN;\n                      ELSE\n                         J=J+I;\n                      CALL $INCLUDE(K,J,T1);\n                      IF T1='C' THEN DO;\n                        ICH=0;\n                        DO III=K BY 1 TO K+J-1;    /* 14.09.88 */\n                           CH=SUBSTRTEXT(III+1,1);\n                           IF SUBSTR(GOODA,ICH+1,1)=HIGH(1) THEN\n                              CALL $INCLUDE(III,1,'X');\n                        END;\n                      END;\n                   END;\n                   ELSE DO;\n                      BLOCK_CMD.TYPE = T1;\n                      PDFBYTE        = T1;\n                      BLOCK_CMD.O1   = LINE_O(II);\n                      BLOCK_CMD.LEN  = I;\n                      PENDING        = '1'B;\n                   END;\n                END;\n                ELSE DO;\n                   IF T2='L' THEN DO;\n                      I  = $HBF(T3);\n                      IF I<=0 THEN GOTO $ERRL;\n                      IF T1='F' THEN DO;\n                         SELECT (I);\n                            WHEN (1) T1='1';\n                            WHEN (2) T1='H';\n                            WHEN (3) T1='3';\n                            WHEN (4);\n                            OTHER GOTO $ERRL;\n                         END;\n                      END;\n                      IF T1='H' | T1='Y' THEN DO;\n                         SELECT (I);\n                            WHEN (1) T1='1';\n                            WHEN (2);\n                            WHEN (3) T1='3';\n                            WHEN (4) T1='F';\n                            OTHER GOTO $ERRL;\n                         END;\n                      END;\n                      GOTO $SETLINE;\n                   END;\n                   ELSE DO;\n $ERRL:               REVERT CONV;\n                      CALL ISPLINK('SETMSG ','REAS013 '); /*INVCMD*/\n                      GOTO $ERR_PRIMARY;\n                   END;\n                END;\n             END;\n $LCMD_END:\n             REASM02_LINE(II).CMD='';\n          END;\n\n          IF UNSPEC(REASM02_LINE(II).LABEL#) = #MOD THEN DO;\n             IF $DUBLAB(REASM02_LINE(II).LABEL,LINE_O(II)) THEN\n                GOTO L_DUBLAB;\n             CALL $INITLAB(REASM02_LINE(II).LABEL,\n                           LINE_O(II),0,'1'B,LINE_O(II));\n          END;\n\n          IF LINE_C(II)\u00ac=0 THEN DO;\n             BYTE = REASM02_CHAR(II,LINE_C(II));\n             IF UNSPEC(BYTE) = #MOD THEN DO;\n                LINE_PTR=ADDR(REASM02_LINE(II).CMD#);\n                COM_PTR=COM_START;\n                Q=NULL;\n                DO WHILE(COM_PTR\u00ac=NULL);\n                   IF COM.OFF=LINE_O(II) THEN DO;\n                      COM.TXT=SUBSTR(LINE,LINE_C(II)+1);\n                      IF COM.TXT='' THEN DO;\n                         IF Q=NULL THEN COM_START=COM.NEXT;\n                                   ELSE Q->COM.NEXT=COM.NEXT;\n                         FREE COM;\n                      END;\n                      IF $REM THEN\n                         CALL $AUTOREC;\n                      GOTO $OK_COM;\n                   END;\n                   Q=COM_PTR;\n                   COM_PTR=COM.NEXT;\n                END;\n                ALLOCATE COM;\n                COM.NEXT=COM_START;\n                COM_START=COM_PTR;\n                COM.OFF=LINE_O(II);\n                COM.TXT=SUBSTR(LINE,LINE_C(II)+1);\n                IF $REM THEN\n                   CALL $AUTOREC;\n $OK_COM:    END;\n          END;\n        END;\n %SKIP;\n                        /*********************************************/\n                        /*  PRIMARY COMMAND PROCESS                  */\n                        /*********************************************/\n        LOCVAR=$NEXTEL(PRIMARY);\n\n        /* ----------------------------------------------------------*/\n        /* PROCESS '.XXX' COMMAND AS 'Q XXX' FOR BROWSE COMPATIBILITY*/\n        /* ----------------------------------------------------------*/\n        IF  LENGTH(LOCVAR)>0 & SUBSTR(LOCVAR,1,1)='.' THEN DO;\n            IF LENGTH(LOCVAR)>1 THEN\n               PRIMARY = SUBSTR(LOCVAR,2) || ' ' || PRIMARY;\n            ELSE\n               PRIMARY = '';\n            LOCVAR = 'Q';\n        END;\n\n        /* ----------------------------------------------------------*/\n        /* PROCESS 'DSA+XXX=NAME' COMMAND                            */\n        /* ----------------------------------------------------------*/\n L_SET: I = INDEX(LOCVAR,'+');\n        J = INDEX(LOCVAR,'=');\n        IF I>1 & J>1  & I<J-1 THEN DO;\n           LOCV = SUBSTR(LOCVAR,1,I-1);                /* DUMMY NAME */\n           ON CONV GOTO L_WROFF;\n           GET STRING(SUBSTR(LOCVAR,I+1,J-I-1)) LIST(K); /* OFFST    */\n           REVERT CONV;\n           NN = SUBSTR(LOCVAR,J+1);                    /* USER NAME  */\n           IF SUBSTR(LOCV,1,1)\u00ac='@' THEN LOCV = '@' || LOCV;\n           IF $DUBLAB(NN,-1) THEN DO;\n L_DUBLAB:    CALL ISPLINK('SETMSG ','REAS015 '); /*DUP LAB */\n              GOTO $ERR_PRIMARY;\n           END;\n           LBLOCK_PTR = LBLOCK_START;\n           DO WHILE (LBLOCK_PTR\u00ac=NULL);\n              IF LBLOCK.NAME  = LOCV &\n                 LBLOCK.ADR   = 0    THEN DO;\n                 DUMMY_PTR = LBLOCK.ADUMMY;\n                 DO WHILE (DUMMY_PTR\u00ac=NULL);\n                    IF DUMMY.OFF = K THEN DO;\n                       DUMMY.NAME = NN;\n                       PDFCHAR = LOCVAR;\n                       CALL ISPLINK('SETMSG ','REAS016 '); /*... SET */\n                       GOTO $RESHOW;\n                    END;\n                    DUMMY_PTR = DUMMY.NEXT;\n                 END;\n L_WROFF:        PDFCHAR = LOCV;\n                 CALL ISPLINK('SETMSG ','REAS017 '); /*INV DS OFF */\n                 GOTO $ERR_PRIMARY;\n              END;\n              LBLOCK_PTR = LBLOCK.NEXT;\n           END;\n           PDFCHAR = LOCV;\n           CALL ISPLINK('SETMSG ','REAS018 '); /*INV DS NAME */\n           GOTO $ERR_PRIMARY;\n        END;\n\n        SELECT (LOCVAR);\n\n          WHEN  (' ');\n\n          WHEN  ('STOP','CAN','CANCEL') DO;\n            STOP;\n          END;\n          /*\n          WHEN  ('LISTX') DO;\n            CALL  REASLST;\n          END;\n          */\n          WHEN  ('PROF','PROFILE') DO;\n            CALL REASPRF('DISPLAY',       /* UPDT PROFILE VARIABLES */\n                 $AUTO, $DSOFF, $REM, #ABSA, #ABSB, LINELEN, REMTIME,\n                 OS,    PC,     FC );\n          END;\n\n          WHEN  ('SET') DO;\n            LOCVAR = $NEXTEL(PRIMARY);\n            GOTO L_SET;\n          END;\n\n          WHEN  ('O','OFF','OFFSET') DO;\n            LOCVAR=$NEXTEL(PRIMARY);\n            IF LOCVAR='' THEN DO;\n               #ABSA = 12;\n               #ABSB =  8;\n            END;\n            ELSE DO;\n               ON CONV GOTO $ERRA;\n               GET STRING(LOCVAR) LIST(I);\n               REVERT CONV;\n               IF I<0 THEN DO;\n $ERRA:           REVERT CONV;\n                  CALL ISPLINK('SETMSG ', 'REAS019 '); /* INV VAL */\n                  GOTO $ERR_PRIMARY;\n               END;\n               #ABSA,#ABSB = I;\n               IF PRIMARY\u00ac='' THEN DO;\n                  ON CONV GOTO $ERRA;\n                  GET STRING(PRIMARY) LIST(I);\n                  REVERT CONV;\n                  IF I<0 THEN GOTO $ERRA;\n                  #ABSB = I;\n               END;\n            END;\n            OFFSET = $OFFSET;\n            REASM02_PRIMARY = ' ';\n            GOTO $RETURN_FROM_$SHOW;\n          END;\n\n          WHEN  ('#','#SNAP') DO;\n             CALL $PRINTDSC('USER-REQUEST SNAP');\n             CALL ISPLINK('SETMSG ', 'REAS021 '); /* SNAP IS COMPL */\n             OFFSET = $OFFSET;\n             REASM02_PRIMARY = '';\n             GOTO $RETURN_FROM_$SHOW;\n          END;\n\n          WHEN  ('ML','MEMLIST','BL','BLOCKLIST') DO;\n             BLKNAME=REASMLB(CONTROL);\n             OFFSET = $OFFSET;\n             REASM02_PRIMARY = BLKNAME;\n             GOTO $RETURN_FROM_$SHOW;\n          END;\n\n          WHEN  ('E','END','EXIT','QUIT') DO;\n            IV = 'PF03';\n            GOTO $RETURN_FROM_$SHOW;\n          END;\n\n          WHEN  ('F','FIND') DO;\n            LOCVAR = PRIMARY;\n            IF LOCVAR = '' THEN DO;\n               IF #FIND = '' THEN DO;\n                  CALL ISPLINK('SETMSG ', 'REAS022 '); /* REQSTR MIS */\n                  REASM02_PRIMARY='F ?';\n                  #CUR(ZZCMD,3);\n                  GOTO $ERR_PRIMARY;\n               END;\n            END;\n            ELSE DO;\n               DO WHILE(SUBSTR(LOCVAR,1,1)=' ');  /* CUT LEAD BLANKS */\n                  LOCVAR = SUBSTR(LOCVAR,2);\n               END;\n               DO WHILE(SUBSTR(LOCVAR,LENGTH(LOCVAR),1)=' '); /* TAIL */\n                  LOCVAR = SUBSTR(LOCVAR,1,LENGTH(LOCVAR)-1);\n               END;\n               #FIND  = LOCVAR;\n               $MATCH = '0'B;\n               IF INDEX(#FIND,'*')\u00ac=0 |  INDEX(#FIND,'%')\u00ac=0 |\n                  INDEX(#FIND,'?')\u00ac=0 THEN DO;\n                  #FIND='*' || #FIND || '*';\n                  $MATCH='1'B;\n               END;\n            END;\n            $FIND           = '1'B;\n            REASM02_PRIMARY = ' ';\n            IF STRIN>3 THEN\n               OFFSET  = LINE_O(STRIN-3)+LINE_I(STRIN-3);\n            ELSE\n               OFFSET  = LINE_O(1)+LINE_I(1);\n            CALL $CLEAR_SCR;\n            FOFFSET = OFFSET;\n            BOFFSET = OFFSET;\n            $OFFSET = OFFSET;\n            #OFFSET = OFFSET;\n            GOTO $RETURN_FROM_$SHOW;\n          END;\n\n          WHEN  ('M','MAX') DO;\n              CALL ISPLINK('SETMSG ', 'REAS023 '); /* PRESS UP/D */\n              #CUR(ZZCMD,1);\n              GOTO $ERR_PRIMARY;\n $RESHOW:     REASM02_PRIMARY = ' ';\n              GOTO $RETURN_FROM_$SHOW;\n          END;\n\n          WHEN  ('T','TRACE') DO;\n            $TRACE=\u00ac$TRACE;\n            REASM02_PRIMARY = ' ';\n            IF $TRACE THEN\n               CALL ISPLINK('SETMSG ', 'REAS024 '); /* TRACE ON */\n            ELSE\n               CALL ISPLINK('SETMSG ', 'REAS025 '); /* TRACE ON */\n            #CUR(ZZCMD,1);\n            OFFSET=$OFFSET;\n            GOTO $RETURN_FROM_$SHOW;\n          END;\n\n          WHEN  ('DS','DSECT') DO;\n            LOCVAR=$NEXTEL(PRIMARY);\n            SELECT (LOCVAR);\n               WHEN ('N','NAME')         $DSOFF='0'B;\n               WHEN ('OFFSET','OFF','O') $DSOFF='1'B;\n               OTHER                     $DSOFF=\u00ac$DSOFF;\n            END;\n            REASM02_PRIMARY = ' ';\n            IF $DSOFF THEN\n               CALL ISPLINK('SETMSG ', 'REAS026 '); /* DS OFF */\n            ELSE\n               CALL ISPLINK('SETMSG ', 'REAS027 '); /* DS NAM */\n            #CUR(ZZCMD,1);\n            OFFSET=$OFFSET;\n            GOTO $RETURN_FROM_$SHOW;\n          END;\n          WHEN  ('A','AUTO') DO;\n            LOCVAR=$NEXTEL(PRIMARY);\n            SELECT (LOCVAR);\n               WHEN ('ON')  $AUTO='1'B;\n               WHEN ('OFF') $AUTO='0'B;\n               OTHER        $AUTO=\u00ac$AUTO;\n            END;\n            REASM02_PRIMARY = ' ';\n            IF $AUTO THEN\n               CALL ISPLINK('SETMSG ', 'REAS028 '); /* AU ON */\n            ELSE\n               CALL ISPLINK('SETMSG ', 'REAS029 '); /* AU OFF */\n            #CUR(ZZCMD,1);\n            OFFSET=$OFFSET;\n            GOTO $RETURN_FROM_$SHOW;\n          END;\n\n          WHEN  ('Q','QUALIFY','QFY','MARK') DO;\n            LOCVAR=$NEXTEL(PRIMARY);\n            IF LENGTH(LOCVAR) > 8 THEN DO;\n               CALL ISPLINK('SETMSG ', 'REAS031 '); /* INVMARK */\n               #CUR(ZZCMD,1);\n               GOTO $ERR_PRIMARY;\n            END;\n            IF LOCVAR = '' THEN DO;\n               OFFSET = REASQFY(QUALIFY_START);\n               IF OFFSET < 0 THEN  OFFSET = $OFFSET;\n               IV = ' ';\n               GOTO $FORM_REASM02;\n            END;\n            QUALIFY_PTR=QUALIFY_START;\n            DO WHILE(QUALIFY_PTR\u00ac=NULL);\n               IF QUALIFY.NAME=LOCVAR THEN DO;\n                  QUALIFY.OFF = $OFFSET;\n                  QUALIFY.DESC   = PRIMARY;\n                  CALL ISPLINK('SETMSG ', 'REAS032 '); /* MARKUPD */\n                  GOTO $QUALIFY_EXIT;\n               END;\n               QUALIFY_PTR=QUALIFY.NEXT;\n            END;\n            ALLOCATE QUALIFY;\n            QUALIFY.NEXT   = QUALIFY_START;\n            QUALIFY_START  = QUALIFY_PTR;\n            QUALIFY.NAME   = LOCVAR;\n            QUALIFY.OFF = $OFFSET;\n            QUALIFY.DESC   = PRIMARY;\n            CALL ISPLINK('SETMSG ', 'REAS033 '); /* MARKUPD */\n $QUALIFY_EXIT: REASM02_PRIMARY='';\n            #CUR(ZZCMD,1);\n            OFFSET=$OFFSET;\n            GOTO $RETURN_FROM_$SHOW;\n          END;\n          WHEN  ('L','LI','LOCATE','LINESIZE') DO;\n            BOFFSET=0;\n            PRIMARY=$NEXTEL(PRIMARY);   /* OPERAND */\n            IF PRIMARY\u00ac='' THEN DO;\n               I=$HB(PRIMARY);\n               SELECT (SUBSTR(REASM02_PRIMARY,2,1));\n                 WHEN  ('I') DO;       /* LINE */\n                   IF I <=0 | I > 32 THEN DO;\n                      CALL ISPLINK('SETMSG ', 'REAS034 '); /* INVLEN */\n                      #CUR(ZZCMD,1);\n                      GOTO $ERR_PRIMARY;\n                   END;\n                   LINELEN=I;\n $SETLINELEN:      OFFSET=$OFFSET;\n                   REASM02_PRIMARY = ' ';\n                   CALL $CLEAR_SCR;\n                   GOTO $RETURN_FROM_$SHOW;\n                 END;\n                 OTHER DO;\n                   LABL_PTR=LABL_START;\n                   DO WHILE(LABL_PTR\u00ac=NULL);\n                      IF LABL.NAME=PRIMARY THEN DO;\n                         I=LABL.OFF;\n                         CALL ISPLINK('SETMSG ', 'REAS035 ');\n                      END;\n                      LABL_PTR=LABL.NEXT;\n                   END;\n                   QUALIFY_PTR=QUALIFY_START;\n                   DO WHILE(QUALIFY_PTR\u00ac=NULL);\n                      IF QUALIFY.NAME=PRIMARY THEN DO;\n                         I=QUALIFY.OFF;\n                         CALL ISPLINK('SETMSG ', 'REAS035 ');\n                      END;\n                      QUALIFY_PTR=QUALIFY.NEXT;\n                   END;\n                   IF I < 0 | I > TEXTLEN THEN DO;\n                      CALL ISPLINK('SETMSG ', 'REAS036 '); /*INVOFF*/\n                      #CUR(ZZCMD,1);\n                      GOTO $ERR_PRIMARY;\n                   END;\n                   OFFSET=I;\n                   IF I\u00ac=0 THEN DO;\n                      CALL $FINDDSC(OFFSET);\n                      IF DSC.TYPE='I' THEN DO;\n                         I=0;\n                         IF MOD(#OFFSET,2)\u00ac=0 THEN\n                            #OFFSET=#OFFSET-1;\n                         DO WHILE(DSC.OFF+I < OFFSET); /* ||| */\n                            CMD_PTR=ADDRTEXT();\n                            #CMD_PTR=#CMD_PTR+DSC.OFF+I;\n                            I=I+CMDLEN(CMDDEF);\n                         END;\n                         OFFSET=DSC.OFF+I;\n                      END;\n                   END;\n                   CALL $CLEAR_SCR;\n                   REASM02_PRIMARY = ' ';\n                   GOTO $RETURN_FROM_$SHOW;\n                 END;\n               END;\n            END;\n          END;\n          WHEN  ('U','US','USING') DO;\n             IF PRIMARY='' THEN DO;\n                CALL ISPLINK('SETMSG ', 'REAS037 '); /*MISSOP*/\n                #CUR(ZZCMD,1);\n                GOTO $ERR_PRIMARY;\n             END;\n             LOCVAR=$NEXTEL(PRIMARY);\n\n             IF LOCVAR = '?' THEN DO;      /* MEMBERLIST ? */\n                LOCVAR = REASMLB(CONTROL);\n             END;\n\n             IF SUBSTR(LOCVAR,1,1)='@' THEN DO;    /* @NAME */\n                IF LENGTH(LOCVAR)<2 | LENGTH(LOCVAR)>9 THEN DO;\n                   CALL ISPLINK('SETMSG ', 'REAS038 '); /*INVBLK*/\n                   #CUR(ZZCMD,1);\n                   GOTO $ERR_PRIMARY;\n                END;\n                NN=LOCVAR;\n                I=0;\n             END;\n             ELSE DO;                             /*LOCATION*/\n                NN='';\n                IF LOCVAR='*' THEN I=$OFFSET;\n                ELSE DO;\n                  IF SUBSTR(LOCVAR,LENGTH(LOCVAR),1)=')' THEN DO;\n                     LOCV=LOCVAR;\n                     LOCVAR='';\n                     DO J=1 TO LENGTH(LOCV)\n                        WHILE(SUBSTR(LOCV,1,1)\u00ac='(');\n                        LOCVAR=LOCVAR || SUBSTR(LOCV,1,1);\n                        LOCV=SUBSTR(LOCV,2);\n                     END;\n                     LOCV=SUBSTR(LOCV,2,LENGTH(LOCV)-2);\n                     IF LOCV='' THEN\n                        GOTO $ERR_BREG;\n                     IF SUBSTR(LOCV,1,1)='R' & LENGTH(LOCV)>1 THEN\n                        LOCV=SUBSTR(LOCV,2);\n                     ON CONV GOTO $ERR_BREG;\n                     GET STRING(LOCV) LIST(J);\n                     IF J<=0 | J>15 THEN DO;\n $ERR_BREG:             REVERT CONV;\n                        CALL ISPLINK('SETMSG ', 'REAS039 '); /*INVREF*/\n                        #CUR(ZZCMD,1);\n                        GOTO $ERR_PRIMARY;\n                     END;\n                     USING_PTR=USING_START;\n                     DO WHILE(USING_PTR\u00ac=NULL);\n                        IF USING.REG=J & USING.NAME='' THEN LEAVE;\n                        USING_PTR=USING.NEXT;\n                     END;\n                     IF USING_PTR=NULL THEN GOTO $ERR_BREG;\n                     GET STRING(LOCVAR) LIST(I);\n                     REVERT CONV;\n                     I=I+USING.OFF;\n                     GOTO $TEST_FORW;\n                  END;\n                  I=$HB(LOCVAR);\n                  IF LOCVAR\u00ac='0' THEN\n                     IF I <= 0 | I > TEXTLEN THEN DO;\n                        CALL ISPLINK('SETMSG ', 'REAS041 '); /*INVOFF*/\n                        #CUR(ZZCMD,1);\n                        GOTO $ERR_PRIMARY;\n                     END;\n                END;\n             END;\n $TEST_FORW: LOCVAR=$NEXTEL(PRIMARY);\n             IF LENGTH(LOCVAR) > 1 & SUBSTR(LOCVAR,1,1)='R' THEN\n                LOCVAR=SUBSTR(LOCVAR,2);\n             ON CONV GOTO $ERR_REG;\n             IF LOCVAR = '' THEN GOTO $ERR_REG;\n             GET STRING(LOCVAR) LIST(J);\n             REVERT CONV;\n             IF J < 0 | J > 15 THEN DO;      /* 04/23/91 */\n $ERR_REG:      REVERT CONV;\n                CALL ISPLINK('SETMSG ', 'REAS042 '); /*INVREG*/\n                #CUR(ZZCMD,1);\n                GOTO $ERR_PRIMARY;\n             END;\n             LOCVAR=$NEXTEL(PRIMARY);\n             IF LOCVAR='' | LOCVAR='*' THEN DO;\n                K = I;\n                IF STRIN > 3 THEN K=LINE_O(STRIN-3);\n             END;\n             ELSE DO;\n                K=$HB(LOCVAR);\n                IF LOCVAR='0' THEN\n                   K=0;\n                ELSE DO;\n                   IF K<=0 | K>TEXTLEN THEN DO;\n                      CALL ISPLINK('SETMSG ', 'REAS043 '); /*INVPLC*/\n                      GOTO $ERR_PRIMARY;\n                   END;\n                END;\n             END;\n             CALL $INITUSING(I,J,K,NN,0);\n             GOTO $RESHOW;\n          END;\n          WHEN  ('D','DROP') DO;                       /* DROP */\n            IF PRIMARY='' THEN DO;\n               CALL ISPLINK('SETMSG ', 'REAS044 '); /*MISSOP*/\n               #CUR(ZZCMD,1);\n               GOTO $ERR_PRIMARY;\n            END;\n            LOCVAR=$NEXTEL(PRIMARY);\n            IF LOCVAR='ALL' THEN DO;\n               DO J=1 TO 15;\n                  CALL $DROP(J);\n               END;\n               DO WHILE(QUALIFY_START\u00ac=NULL);\n                  QUALIFY_PTR=QUALIFY_START;\n                  QUALIFY_START=QUALIFY.NEXT;\n                  FREE QUALIFY;\n               END;\n            END;\n            ELSE DO;\n               P=NULL;\n               QUALIFY_PTR=QUALIFY_START;\n               DO WHILE(QUALIFY_PTR\u00ac=NULL);\n                  IF QUALIFY.NAME=LOCVAR THEN DO;\n                     IF P=NULL THEN QUALIFY_START=QUALIFY.NEXT;\n                               ELSE P->QUALIFY.NEXT=QUALIFY.NEXT;\n                     FREE QUALIFY;\n                  END;\n                  P=QUALIFY_PTR;\n                  QUALIFY_PTR=QUALIFY.NEXT;\n                  GOTO $DROP_END;\n               END;\n               IF SUBSTR(LOCVAR,1,1)='R' & LENGTH(LOCVAR)>1 THEN\n                  LOCVAR=SUBSTR(LOCVAR,2);\n               ON CONV GOTO $ERR_DROP;\n               GET STRING(LOCVAR) LIST(J);\n               REVERT CONV;\n               IF J<0 | J>15 THEN DO;\n $ERR_DROP:       REVERT CONV;\n                  CALL ISPLINK('SETMSG ', 'REAS045 '); /*INVREG*/\n                  #CUR(ZZCMD,1);\n                  GOTO $ERR_PRIMARY;\n               END;\n               CALL $DROP(J);\n            END;\n $DROP_END:\n          END;\n          WHEN  ('RES','RESET') DO;\n            PENDING='0'B;\n            GOTO $RESHOW;\n          END;\n          WHEN  ('TOP', 'UP MAX')\n            GOTO TOP;\n          WHEN  ('BOTTOM', 'DOWN MAX')\n            GOTO BOTTOM;\n          WHEN  ('REC','RECOVERY') DO;\n               LOCVAR=$NEXTEL(PRIMARY);\n               LOCV='C';                  /* <CREATE> */\n               IF LOCVAR='LIB' THEN DO;\n                  LOCV='L';               /* <CREATE LIB> */\n                  LOCVAR=$NEXTEL(PRIMARY);\n                  I = REASMRC(SAVE,'L');\n                  MEMSAVE=CSECT;\n                  CALL $REALLOC(SAVE,DSNSAVE,MEMSAVE,'');\n                  DSRG=PO;\n               END;\n               IF LOCVAR='OFF' THEN LOCVAR='0';\n               IF LOCVAR='' THEN\n                  CALL REASMS('1'B,LOCV);\n               ELSE DO;\n                  ON CONV GOTO $ERRREM;\n                  GET STRING(LOCVAR) LIST(I);\n                  REVERT CONV;\n                  IF I<0 THEN DO;\n $ERRREM:            REVERT CONV;\n                     CALL ISPLINK('SETMSG ', 'REAS046 '); /*INVREG*/\n                     GOTO $ERR_PRIMARY;\n                  END;\n                  IF I\u00ac=0 THEN DO;\n                     REMTIME=I;\n                     $REM='1'B;\n                     REMCOUNT=0;\n                     CALL REASMS('1'B,LOCV);\n                  END;\n                  ELSE\n                     $REM='0'B;\n               END;\n               GOTO $RESHOW;\n         END;\n         WHEN ('R','RETRANSLATE') DO;\n            J = $OFFSET;                             /** RETRANSLATE**/\n            GLOBAL = '0'B;\n            LOCVAR = $NEXTEL(PRIMARY);\n            IF LOCVAR \u00ac= '' THEN DO;\n               IF SUBSTR(LOCVAR,1,1) = 'G' THEN GLOBAL='1'B;\n               ELSE DO;\n                  J = $HB(LOCVAR);\n                  IF J=0 & LOCVAR\u00ac='0' THEN DO;\n                     CALL ISPLINK('SETMSG ', 'REAS047 '); /*INVOFF*/\n                     #CUR(ZZCMD,1);\n                     GOTO $ERR_PRIMARY;\n                  END;\n                  LOCVAR=$NEXTEL(PRIMARY);\n                  IF LOCVAR\u00ac='' & SUBSTR(LOCVAR,1,1)='G' THEN\n                     GLOBAL='1'B;\n               END;\n            END;\n $RETRANSLATE:\n            K=0; /* LENGTH */\n            JJ=J; /* START */\n            IF MOD(JJ,2)\u00ac=0 THEN /* MAKE ADDR EVEN */\n               JJ=JJ+1;\n            IF J > TEXTLEN-1 THEN /* JUMPED OVER BORDER ?      */\n               GOTO $TEST_GLOBAL;  /* PIECE COMPLETE           */\n            CALL $FINDDSC(J);      /* WHERE WE ARE ???         */\n            IF DSC.NORED THEN      /* FIXED PART ?             */\n               GOTO $TEST_GLOBAL;  /* PIECE COMPLETE           */\n          /*$NOOP='1'B */          /* NO OPERANDS PROCESS (SPEED) */\n            CALL $CMD(J,1);        /* COMMAND IN FIRST LINE    */\n            $NOOP='0'B;            /* PROCESS OPERANDS         */\n            IF USING_START=NULL & $AUTO THEN /* BASE NECESSARY ? */\n               CALL $TESTUS(J);    /* TEST SET BASE REG        */\n            DO WHILE(REASM02_LINE(1).OPER\u00ac='' & J < TEXTLEN);\n               I=CMDLEN(CMDDEF);   /* COMMAND LENGTH           */\n               J=J+I;              /* INCREMENT OFFSET         */\n               K=K+I;              /* INCREMENT LENGTH         */\n               IF J > TEXTLEN-1 THEN /* OVER BORDER?           */\n                  GOTO $TEST_GLOBAL; /* FINISH PIECE           */\n               CALL $FINDDSC(J);   /* WHERE WE ARE NOW ?       */\n               IF (DSC.OFF+DSC.LENGTH-J < I) | DSC.NORED THEN\n                  GOTO $TEST_GLOBAL; /* ||||| */\n             /*$NOOP='1'B */\n               CALL $CMD(J,1);\n               $NOOP='0'B;\n               IF USING_START=NULL & $AUTO THEN\n                  CALL $TESTUS(J);\n            END;\n $TEST_GLOBAL:\n            IF K\u00ac=0 THEN             /* LENGTH EXISTS        */\n               CALL $INCLUDE(JJ,K,'I');\n            IF GLOBAL THEN DO;       /* GLOBAL STATUS        */\n               J=MAX(JJ+K,#FORWARD); /* TRY GO FORWARD MAX   */\n               IF MOD(J,2)\u00ac=0 THEN   /* ROUND TO             */\n                  J=J+1;             /*    4                 */\n               IF MOD(J,4)\u00ac=0 THEN   /*    FORWARD           */\n                  J=J+2;             /*                      */\n               IF J>TEXTLEN THEN     /* DO NO JUMP TOO       */\n                  J=TEXTLEN;         /*    FAR AWAY          */\n               II1,II2=0;\n               DO III=JJ+K BY 1 TO J WHILE(III < J);\n                  ICH=0;\n                  CH=SUBSTRTEXT(III+1,1);\n                  II1=II1+1;\n                  IF SUBSTR(GOODA,ICH+1,1)\u00ac=HIGH(1) THEN\n                     II2=II2+1;\n               END;\n               IF II1=II2 & $AUTO THEN\n                  CALL $INCLUDE(JJ+K,II2,'C');\n               DO J=J BY 4 WHILE(J < TEXTLEN);\n                  CALL $FINDDSC(J);    /* SET KUDA NADO       */\n                  IF DSC.NORED THEN    /* SKIP OVER           */\n                     J=DSC.OFF+DSC.LENGTH-4;\n                  ELSE DO;             /* TRY MAKE COMMAND    */\n                   /*$NOOP='1'B */\n                     CALL $CMD(J,1);\n                     $NOOP='0'B;\n                     IF REASM02_LINE(1).OPER\u00ac='' THEN /* OK    ||| */\n                        GOTO $RETRANSLATE; /* START FROM HERE      */\n                     LOCVAR='';\n                     ICH=0;\n                     DO JJJ=J TO J+3;   /* 26.11.87 */\n                        CH=SUBSTRTEXT(JJJ+1,1);\n                        LOCVAR=LOCVAR || SUBSTR(GOODA,ICH+1,1);\n                     END;\n                     IF INDEX(LOCVAR,HIGH(1))=0 & $AUTO THEN\n                        CALL $INCLUDE(J,4,'C');\n                  END;\n               END;\n            END;\n\n            OFFSET=$OFFSET;\n            REASM02_PRIMARY = ' ';\n            CALL $CLEAR_SCR;\n            GOTO $RETURN_FROM_$SHOW;\n          END;\n          WHEN  ('P','PRINT') DO;\n             LOCVAR=$NEXTEL(PRIMARY);\n             IF LOCVAR='XREF' | LOCVAR='X' THEN DO;\n                XREF_START=NULL;\n                $XREF='1'B;                   /* 08.12.87 */\n             END;\n             PRINTBIT='1'B;\n             PRINTNUM=0;\n             FOFFSET=$OFFSET;\n             #PAGE=0;\n             SIGNAL ENDPAGE(SYSPRINT);\n             OFFSET=0;\n             REASM02_PRIMARY = ' ';\n             CALL $CLEAR_SCR;\n             GOTO $RETURN_FROM_$SHOW;\n          END;\n          WHEN  ('S','SAVE') DO;\n            LOCVAR=$NEXTEL(PRIMARY);\n            REASM02_PRIMARY = ' ';\n            IF LOCVAR\u00ac='' THEN  MEMOUT=LOCVAR;\n            ELSE                MEMOUT=CSECT;\n            IF MEMOUT='' THEN   MEMOUT='TEMPNAME';\n            I = REASLIB(SOURCE, 'OPEN', MEMOUT);\n            IF I\u00ac=0 THEN DO;\n               OFFSET=$OFFSET;\n               GOTO $RETURN_FROM_$SHOW;\n            END;\n\n            #CARD='';\n            CARD.LABEL = '*';\n            CARD.OPER  = '';\n            CARD.OPERANDS='* MVS/ESA REASM ' || REASMVER;\n            CARDNUM    = 10000;\n            I = REASLIB(SOURCE, 'WRITE', #CARD);\n            CARD.LABEL='*';\n            CARD.OPER='';\n            LOCVAR=SUBSTR(REASM02_DSN,VERIFY(REASM02_DSN,' '));\n            IF LENGTH(LOCVAR) > 50 THEN\n               LOCVAR=SUBSTR(LOCVAR,1,50);\n            CARD.OPERANDS=LOCVAR;\n            CARDNUM=20000;\n            I = REASLIB(SOURCE, 'WRITE', #CARD);\n            SAVEBIT='1'B;\n            FOFFSET=$OFFSET;\n            OFFSET=0;\n            CALL $CLEAR_SCR;\n            SAVENUM=20000;\n            GOTO $RETURN_FROM_$SHOW;\n          END;\n          OTHER DO;\n            CALL ISPLINK('SETMSG ', 'REAS049 '); /*INVCMD*/\n            #CUR(ZZCMD,1);\n $ERR_PRIMARY:\n            GOTO CALLTV02;\n          END;\n        END;\n %SKIP;\n                        /*********************************************/\n                        /*  FUNCTIONAL KEY PROCESS                   */\n                        /*********************************************/\n     SELECT (IV);\n\n       WHEN ('PF07') DO;  /* UP */\n            SELECT (SCROLL);\n               WHEN ('MAX') DO;\n TOP:            OFFSET, BOFFSET = 0;\n               END;\n               WHEN ('HALF') OFFSET = $OFFSET-4*(LVL/2);\n               WHEN ('PAGE') OFFSET = $OFFSET-4*LVL;\n               OTHER DO;\n                  I = STRIN-3;\n                  IF I > 0 THEN DO;\n                     IF STRIN=LVL+3 THEN DO;\n                        #CUR(ZZCMD,1);\n                        OFFSET = $OFFSET-4*LVL;\n                     END;\n                     ELSE DO;\n                        #CUR(SCREEN,(LVL-1)*80+COLIN-1);\n                        OFFSET = LINE_O(I)-4*LVL;\n                     END;\n                  END;\n                  ELSE\n                     OFFSET=$OFFSET-4*LVL;\n               END;\n            END;\n            DO I=1 TO MAXLVL-3;\n               #AZO(REASM02_LINE(I).OFF#);\n            END;\n            CALL $GOODCMD(OFFSET);\n            CALL $CLEAR_SCR;\n            GOTO $RETURN_FROM_$SHOW;\n       END;\n\n       WHEN ('PF08') DO; /* DOWN */\n            IF OFFSET >= TEXTLEN THEN DO;\n               CALL $CLEAR_SCR;\n               GOTO $PUTLINE_END;\n            END;\n            SELECT (SCROLL);\n               WHEN ('MAX') DO;\n BOTTOM:         BOFFSET = 0;\n                 OFFSET  = TEXTLEN-4*LVL;\n                 #CUR(ZZCMD,1);\n                 CALL $GOODCMD(OFFSET);\n               END;\n               WHEN ('PAGE') DO;\n PF08_PAGE:      I = LINE_O(LVL)+LINE_I(LVL);\n                 IF OFFSET=I THEN OFFSET = I+1;\n                 ELSE             OFFSET = I;\n                 #CUR(ZZCMD,1);\n               END;\n               WHEN ('HALF') DO;\n                 OFFSET = LINE_O(LVL/2+1);\n                 #CUR(ZZCMD,1);\n               END;\n               OTHER DO;  /* CSR */\n                  I = STRIN-4;\n                  IF I>0 THEN DO;\n                     OFFSET = LINE_O(I);\n                     #CUR(SCREEN,COLIN);\n                     CALL $GOODCMD(OFFSET);\n                  END;\n                  ELSE  GOTO PF08_PAGE;\n               END;\n            END;\n            CALL $CLEAR_SCR;\n            GOTO $RETURN_FROM_$SHOW;\n       END;\n       WHEN ('PF19')\n         GOTO TOP;\n       WHEN ('PF20')\n         GOTO BOTTOM;\n       OTHER\n         GOTO $RESHOW;\n     END;\n\n %SKIP;\n $PUTLINE_END:\n        CALL $CLEAR_SCR;\n        #CURI = 0;\n     END;\n     #CURI=#CURI+1;\n\n /*************/\n /* PRINTLINE */\n /*************/\n $PUTLINE_PRINT: PROC ;\n DCL (PRIV,BRANCH)  CHAR(1),\n     (I,J);\n\n    DO I=1 TO MAXLVL-3;\n       IF REASM02_LINE(I).OPER\u00ac='' |\n          REASM02_LINE(I).OPERANDS\u00ac='' THEN DO;\n          IF SUBSTR(REASM02_LINE(I).LABEL,1,1)='*' &\n             REASM02_LINE(I).OPER\u00ac='EQU' THEN\n             REASM02_LINE(I).LABEL='';       /* 08.12.87 */\n          LINE_PTR=ADDR(REASM02_LINE(I).CMD#);\n          COMMENT = #SCRCOM(I);\n          IF LINE_C(I)\u00ac=0 THEN SUBSTR(LINE,LINE_C(I))=' ';\n          PRINTNUM=PRINTNUM+1;\n          PRIV, BRANCH = ' ';\n          IF REASMCM(@, REASM02_LINE(I).OPER, 'PRIV') THEN\n             PRIV   = '*';\n          IF REASMCM(@, REASM02_LINE(I).OPER, 'BRANCH') THEN\n             BRANCH = '-';\n          PUT SKIP EDIT(\n            PRIV,\n            REASM02_LINE(I).OFF,\n            REASM02_LINE(I).OBJECT,\n            PRINTNUM,\n            REASM02_LINE(I).LABEL,\n            BRANCH,\n            REASM02_LINE(I).OPER,\n            REASM02_LINE(I).OPERANDS)\n            (A(1),X(1),A,X(1),A,X(5),F(4),X(2),A,A(1),A,X(1),A);\n\n      /*  IF REASMCM(@, REASM02_LINE(I).OPER, 'USING') THEN\n             PUT SKIP(0) EDIT(\n                 PRIV,\n                 REASM02_LINE(I).OFF,\n                 REASM02_LINE(I).OBJECT,\n                 PRINTNUM,\n                 REASM02_LINE(I).LABEL,\n                 BRANCH,\n                 REASM02_LINE(I).OPER,\n                 REASM02_LINE(I).OPERANDS)\n                 (A(1),X(1),A,X(1),A,X(5),F(4),X(2),A,A(1),A,X(1),A);*/\n\n          DO WHILE(LENGTH(COMMENT)>1 &\n                   (SUBSTR(COMMENT,1,1)=' ' | SUBSTR(COMMENT,1,1)='/'));\n             COMMENT = SUBSTR(COMMENT,2);\n          END;\n          IF COMMENT \u00ac= '' THEN DO;\n             COMMENT = '/* ' || COMMENT;\n             IF LENGTH(COMMENT)>40 THEN COMMENT=SUBSTR(COMMENT,1,40);\n             DO J=1 TO 2;\n           /*   PUT SKIP(0) EDIT(COMMENT) (COL(80), A); */\n             END;\n          END;\n       END;\n    END;\n END $PUTLINE_PRINT;\n\n /*************/\n /* SAVETLINE */\n /*************/\n $PUTLINE_SAVE: PROC ;\n    DCL (I, J, POS)  BIN FIXED(31);\n    DCL APOS BIN FIXED INIT(60);\n\n    DO I=1 TO MAXLVL-3;\n       LINE_PTR=ADDR(REASM02_LINE(I).CMD#);\n       IF LINE_C(I)\u00ac=0 THEN DO;\n          J = LINE_C(I);\n          SUBSTR(LINE,J,1)=' ';\n          POS = J - 44;\n       END;\n       #CARD='';\n       IF SUBSTR(REASM02_LINE(I).LABEL,1,1)='*' &\n          REASM02_LINE(I).OPER\u00ac='EQU' THEN\n          REASM02_LINE(I).LABEL='';       /* 08.12.87 */\n\n       CARD.LABEL    = REASM02_LINE(I).LABEL;\n       CARD.OPER     = REASM02_LINE(I).OPER;\n       CARD.OPERANDS = REASM02_LINE(I).OPERANDS;\n       CARD.CONTPOS  = ' ';\n       IF #CARD\u00ac='' THEN DO;\n          SAVENUM = SAVENUM+10000;\n          CARDNUM = SAVENUM;\n          J = REASLIB(SOURCE, 'WRITE', #CARD);\n       END;\n    END;\n END $PUTLINE_SAVE;\n\n END $PUTLINE;\n %SKIP;\n /*********************************************************************/\n /*  FILL LABEL IN IT'S  PLACE                                        */\n /*********************************************************************/\n $LABEL:\n     PROC(OFF,LEN);\n DCL J    BIN FIXED(31),\n     1 SLINE LIKE REASM02_LINE,\n     $MOVE BIT(1) INIT('0'B),\n     OFF BIN FIXED(31),\n     LEN BIN FIXED(31);\n\n     IF ALL(PASS='') THEN DO;\n        ON ERROR STOP;\n        PUT SKIP LIST('UNAUTHORIZED COPY. EXECUTION PROHIBITED');\n        STOP;\n     END;\n\n     REASM02_LINE(#CURI).LABEL=''; /* START FROM BLANK   */\n     LABL_PTR=LABL_START;\n     DO WHILE(LABL_PTR\u00ac=NULL);\n        IF OFF      = LABL.OFF THEN LEAVE; /* COMPARED     ? */\n        LABL_PTR=LABL.NEXT;\n     END;\n     IF LABL_PTR\u00ac=NULL THEN DO;\n        REASM02_LINE(#CURI).LABEL=LABL.NAME;\n        IF LABL.NORED THEN\n           #AZP(REASM02_LINE(#CURI).LABEL#);\n     END;\n\n     LABL_PTR=LABL_START;\n     DO WHILE(LABL_PTR\u00ac=NULL);\n        IF OFF     <= LABL.OFF & OFF+LEN >     LABL.OFF THEN DO;\n           IF \u00ac$MOVE THEN\n              SLINE=REASM02_LINE(#CURI), BY NAME;\n           $MOVE='1'B;\n           IF LABL.NAME\u00ac=SLINE.LABEL THEN DO;\n              REASM02_LINE(#CURI).OBJECT='';\n              REASM02_LINE(#CURI).OFF='';\n              REASM02_LINE(#CURI).LABEL=LABL.NAME;\n              REASM02_LINE(#CURI).OPER='EQU';\n              REASM02_LINE(#CURI).OPERANDS=\n                      '*+' || $DIGIT(LABL.OFF-OFF);\n              #AZO(REASM02_LINE(#CURI).CMD#);\n              IF LABL.NORED THEN\n                 #AZO(REASM02_LINE(#CURI).LABEL#);\n              ELSE\n                 IF SUBSTR(REASM02_LINE(#CURI).LABEL,1,1)='*' THEN\n                    #ANO(REASM02_LINE(#CURI).LABEL#);  /* 08.12.87 */\n              IF $XREF THEN\n                 CALL $PUTXRF(LABL.NAME);\n              LINE_O(#CURI)=LABL.OFF;\n              LINE_I(#CURI),LINE_C(#CURI)=0;\n              CALL $PUTLINE;\n           END;\n        END;\n        LABL_PTR=LABL.NEXT;\n     END;\n     IF $MOVE THEN\n        REASM02_LINE(#CURI)=SLINE, BY NAME;\n     IF REASM02_LINE(#CURI).LABEL\u00ac='' & $XREF THEN\n        CALL $PUTXRF(REASM02_LINE(#CURI).LABEL);\n     IF SUBSTR(REASM02_LINE(#CURI).LABEL,1,1)='*' THEN\n        #ANO(REASM02_LINE(#CURI).LABEL#);              /* 08.12.87 */\n END $LABEL;\n\n\n PRINT_EXTRN_WXTRN: PROC;\n      DO I=1 TO DIM_ESD_ARRAY;\n         ONEBYTE = ESD_ARRAY(I).TYPE;\n         IF ESD_ARRAY(I).REF=ESDID THEN DO;\n            IF \u00acBIT4 & \u00acBIT5 & BIT6 & BIT7 THEN DO;\n               REASM02_LINE(#CURI).OPER='ENTRY';\n               REASM02_LINE(#CURI).OPERANDS=ESD_ARRAY(I).NAME;\n               REASM02_LINE(#CURI).OFF='';\n               REASM02_LINE(#CURI).OBJECT='';\n               #AZO(REASM02_LINE(#CURI).CMD#);\n               #AZO(REASM02_LINE(#CURI).LABEL#);\n               LINE_O(#CURI)=TEXTLEN;\n               LINE_I(#CURI),LINE_C(#CURI)=0;\n               CALL $PUTLINE;\n            END;\n         END;\n         IF  BIT4 & \u00acBIT5 & BIT6 & \u00acBIT7 THEN DO;\n            P = DSC_START;\n L_WXTRN:   DO WHILE(P\u00ac=NULL);\n               IF P->DSC.NAME = ESD_ARRAY(I).NAME THEN DO;\n                 REASM02_LINE(#CURI).OPER='WXTRN';\n                 REASM02_LINE(#CURI).OPERANDS=ESD_ARRAY(I).NAME;\n                 REASM02_LINE(#CURI).OFF='';\n                 REASM02_LINE(#CURI).OBJECT='';\n                 #AZO(REASM02_LINE(#CURI).CMD#);\n                 #AZO(REASM02_LINE(#CURI).LABEL#);\n                 LINE_O(#CURI)=TEXTLEN;\n                 LINE_I(#CURI),LINE_C(#CURI)=0;\n                 CALL $PUTLINE;\n                 LEAVE L_WXTRN;\n               END;\n               P = P->DSC.NEXT;\n            END;\n         END;\n      END;\n\n      P=DSC_START;\n      DO WHILE(P\u00ac=NULL);\n         IF P->DSC.EXTRN THEN DO;\n            Q=DSC_START;\n            DO WHILE (Q\u00ac=P);\n               IF Q->DSC.NAME=P->DSC.NAME &\n                  Q->DSC.TYPE=P->DSC.TYPE THEN\n                  LEAVE;\n               Q=Q->DSC.NEXT;\n            END;\n            IF Q=P THEN DO;\n               REASM02_LINE(#CURI).OPER='EXTRN';\n               REASM02_LINE(#CURI).OPERANDS=P->DSC.NAME;\n               REASM02_LINE(#CURI).OFF='';\n               REASM02_LINE(#CURI).OBJECT='';\n               #AZO(REASM02_LINE(#CURI).CMD#);\n               #AZO(REASM02_LINE(#CURI).LABEL#);\n               LINE_O(#CURI)=TEXTLEN;\n               LINE_I(#CURI),LINE_C(#CURI)=0;\n               CALL $PUTLINE;\n            END;\n         END;\n         P=P->DSC.NEXT;\n      END;\n END PRINT_EXTRN_WXTRN;\n\n %PAGE;\n PRINT_DXD: PROC;\n   DO I=1 TO DIM_ESD_ARRAY;\n      ONEBYTE = ESD_ARRAY(I).TYPE;\n      IF \u00acBIT4 & BIT5 & BIT6 & \u00acBIT7 THEN DO;   /* CXD-CONST */\n         REASM02_LINE(#CURI).LABEL=ESD_ARRAY(I).NAME;\n         IF $XREF THEN CALL $PUTXRF(REASM02_LINE(#CURI).LABEL);\n         P = DSC_START;\n L_DXD:  DO WHILE(P\u00ac=NULL);\n            IF P->DSC.NAME = ESD_ARRAY(I).NAME THEN DO;\n               REASM02_LINE(#CURI).OPER='DXD';\n               IF ESD_ARRAY(I).ALIGN <= 7 THEN\n                        LOCVAR=$ALIGN(ESD_ARRAY(I).ALIGN);\n               ELSE     LOCVAR='C';\n               IF LOCVAR='C' THEN\n                  REASM02_LINE(#CURI).OPERANDS='XL' ||\n                      $DIGIT(ESD_ARRAY(I).REF);\n               ELSE   REASM02_LINE(#CURI).OPERANDS=LOCVAR;\n               REASM02_LINE(#CURI).OFF='';\n               REASM02_LINE(#CURI).OBJECT='';\n               #AZO(REASM02_LINE(#CURI).CMD#);\n               #AZO(REASM02_LINE(#CURI).LABEL#);\n               LINE_O(#CURI)=TEXTLEN;\n               LINE_I(#CURI),LINE_C(#CURI)=0;\n               CALL $PUTLINE;\n               LEAVE L_DXD;\n            END;\n            P = P->DSC.NEXT;\n         END;\n      END;\n   END;\n END PRINT_DXD;\n\n %PAGE;\n PRINT_CSECT: PROC;\n   REASM02_LINE(#CURI).LABEL=CSECT;\n   REASM02_LINE(#CURI).OPER='CSECT';\n   #AZO(REASM02_LINE(#CURI).CMD#);\n   #AZP(REASM02_LINE(#CURI).LABEL#);\n   LINE_O(#CURI),LINE_I(#CURI),LINE_C(#CURI)=0;\n   CALL $PUTLINE;\n END PRINT_CSECT;\n\n %PAGE;\n PRINT_REGEQ_LTORG: PROC;\n   DO I=0 TO 15;\n      REASM02_LINE(#CURI).LABEL=$REGS(I);\n      IF $XREF THEN\n         CALL $PUTXRF($REGS(I));\n      REASM02_LINE(#CURI).OPER='EQU';\n      REASM02_LINE(#CURI).OPERANDS=$DIGIT(I);\n      #AZO(REASM02_LINE(#CURI).CMD#);\n      #AZO(REASM02_LINE(#CURI).LABEL#);\n      LINE_O(#CURI)=TEXTLEN;\n      LINE_I(#CURI),LINE_C(#CURI)=0;\n      CALL $PUTLINE;\n   END;\n   REASM02_LINE(#CURI).LABEL='';\n   REASM02_LINE(#CURI).OPER='LTORG';\n   REASM02_LINE(#CURI).OPERANDS=',';\n   #AZO(REASM02_LINE(#CURI).CMD#);\n   #AZO(REASM02_LINE(#CURI).LABEL#);\n   LINE_O(#CURI)=TEXTLEN;\n   LINE_I(#CURI),LINE_C(#CURI)=0;\n   CALL $PUTLINE;\n\n END PRINT_REGEQ_LTORG;\n\n %PAGE;\n PRINT_DSECTS: PROC;\n   USING_PTR=USING_START;\n   DO WHILE(USING_PTR\u00ac=NULL);\n      IF USING.NAME\u00ac='' THEN DO;\n         P=USING_START;\n         DO WHILE(P\u00ac=NULL & P\u00ac=USING_PTR);\n            IF P->USING.NAME=USING.NAME THEN\n               GOTO $NEXT_USING_REGISTER;\n            P=P->USING.NEXT;\n         END;\n         LBLOCK_PTR=LBLOCK_START;\n         DO WHILE(LBLOCK_PTR\u00ac=NULL & LBLOCK.NAME\u00ac=USING.NAME);\n            LBLOCK_PTR=LBLOCK.NEXT;\n         END;\n         IF LBLOCK.ADR=0 THEN DO;    /* NEW DUMMY DSECT */\n            REASM02_LINE(#CURI).LABEL=SUBSTR(USING.NAME,2);\n            REASM02_LINE(#CURI).OPER='DSECT';\n            REASM02_LINE(#CURI).OPERANDS='';\n         END;\n         ELSE DO;                    /* CONTROL BLOCK   */\n            REASM02_LINE(#CURI).LABEL='';\n            REASM02_LINE(#CURI).OPER='';\n            IF LBLOCK.MACRO = '' THEN\n               REASM02_LINE(#CURI).OPERANDS=\n                       SUBSTR(LBLOCK.NAME,2);\n            ELSE\n               REASM02_LINE(#CURI).OPERANDS=\n                       SUBSTR(LBLOCK.MACRO,2);\n         END;\n         #AZO(REASM02_LINE(#CURI).CMD#);\n         #AZO(REASM02_LINE(#CURI).LABEL#);\n         LINE_O(#CURI)=TEXTLEN;\n         LINE_I(#CURI),LINE_C(#CURI)=0;\n         CALL $PUTLINE;\n         IF LBLOCK.ADR=0 THEN DO;\n            DUMMY_PTR = LBLOCK.ADUMMY;\n            I=0;\n            DO WHILE(DUMMY_PTR\u00ac=NULL);\n              IF DUMMY.OFF > I THEN DO;\n                 REASM02_LINE(#CURI).OPER='DS';\n                 REASM02_LINE(#CURI).OPERANDS='XL' ||\n                            $DIGIT(DUMMY.OFF-I)    ||\n                            '      +'              ||\n                            $DIGIT(DUMMY.OFF); /*29.12.87*/\n                 #AZP(REASM02_LINE(#CURI).CMD#);\n                 #AZP(REASM02_LINE(#CURI).LABEL#);\n                 LINE_O(#CURI)=TEXTLEN;\n                 LINE_I(#CURI),LINE_C(#CURI)=0;\n                 CALL $PUTLINE;\n              END;\n              I = DUMMY.OFF;\n              REASM02_LINE(#CURI).LABEL=$DNAME(LBLOCK_PTR,I,J);\n              #AZP(REASM02_LINE(#CURI).CMD#);\n              #AZP(REASM02_LINE(#CURI).LABEL#);\n              REASM02_LINE(#CURI).OPER='EQU';\n              REASM02_LINE(#CURI).OPERANDS='*';\n              P=DUMMY.NEXT;\n              IF P\u00ac=NULL THEN DO;\n                 REASM02_LINE(#CURI).OPER='DS';\n                 REASM02_LINE(#CURI).OPERANDS='XL'   ||\n                           $DIGIT(P->DUMMY.OFF-I);\n                 I=P->DUMMY.OFF;\n              END;\n              DO WHILE\n                     (LENGTH(REASM02_LINE(#CURI).OPERANDS)<10);\n                 REASM02_LINE(#CURI).OPERANDS =\n                      REASM02_LINE(#CURI).OPERANDS || ' ';\n              END;\n              REASM02_LINE(#CURI).OPERANDS =\n                      REASM02_LINE(#CURI).OPERANDS || '+' ||\n                      $DIGIT(DUMMY.OFF);\n              LINE_O(#CURI)=TEXTLEN;\n              LINE_I(#CURI),LINE_C(#CURI)=0;\n              CALL $PUTLINE;\n              DUMMY_PTR=DUMMY.NEXT;\n            END;\n         END;\n         REASM02_LINE(#CURI).LABEL=CSECT;\n         REASM02_LINE(#CURI).OPER='CSECT';\n         REASM02_LINE(#CURI).OPERANDS='';\n         #AZO(REASM02_LINE(#CURI).CMD#);\n         #AZO(REASM02_LINE(#CURI).LABEL#);\n         LINE_O(#CURI)=TEXTLEN;\n         LINE_I(#CURI),LINE_C(#CURI)=0;\n         CALL $PUTLINE;\n      END;\n $NEXT_USING_REGISTER:\n      USING_PTR=USING.NEXT;\n   END;\n END PRINT_DSECTS;\n\n %PAGE;\n PRINT_END_STMT: PROC;\n   REASM02_LINE(#CURI).LABEL='';\n   REASM02_LINE(#CURI).OPER='END';\n   REASM02_LINE(#CURI).OPERANDS='';\n   LINE_O(#CURI)=TEXTLEN;\n   LINE_I(#CURI),LINE_C(#CURI)=0;\n   CALL $PUTLINE;\n   IF #CURI\u00ac=1 THEN DO;\n      DO I=#CURI TO MAXLVL-3;\n         #AZP(REASM02_LINE(I).CMD#);\n         #AZP(REASM02_LINE(I).LABEL#);\n      END;\n      #CURI=MAXLVL-3;\n      CALL $PUTLINE;\n   END;\n END PRINT_END_STMT;\n\n END $SHOW;\n\n %PAGE;\n /*********************************************************************/\n /*  FIND NECESSARY DSC ELEMENT BY OFFSET                             */\n /*********************************************************************/\n $FINDDSC:\n     PROC(OFFSET);\n DCL OFFSET BIN FIXED(31);\n\n     IF ALL(PASS='') THEN DO;\n        ON ERROR STOP;\n        PUT SKIP LIST('UNAUTHORIZED COPY. EXECUTION PROHIBITED');\n        CALL REASLST;\n        STOP;\n     END;\n     DSC_PTR=DSC_START;\n     DO WHILE (DSC_PTR \u00ac= NULL);\n        IF (OFFSET>=DSC.OFF) & (OFFSET<DSC.OFF+DSC.LENGTH) THEN\n           RETURN;\n        DSC_PTR=DSC.NEXT;\n     END;\n     PUT SKIP EDIT('INVALID OFFSET SPECIFIED: ' || $BH(OFFSET))(A);\n     CALL REASLST;\n     SIGNAL ERROR; STOP;\n END $FINDDSC;\n %SKIP;\n\n /*********************************************************************/\n /*  FILL UP THE OFFSET AND #COM                                      */\n /*********************************************************************/\n $JUMPOFF: PROC(OFF, CUR) RETURNS(CHAR(16) VAR);\n   DCL OFF BIN FIXED(15),\n       CUR BIN FIXED(31),\n         I BIN FIXED(31),\n        #I CHAR(4) BASED(ADDR(I)),\n         LABNAME CHAR(16) VAR,\n         REF CHAR(20) VAR;\n\n   PUT STRING(REF) EDIT(OFF*2)(F(7));\n   REF = SUBSTR(REF,VERIFY(REF,' '));\n   IF OFF >= 0 THEN\n      REF = '+' || REF;\n   REF = '*' || REF;\n\n   I = OFF*2 + CUR;\n   LOCVAR = #I;\n   LABNAME = $NAME(LOCVAR);\n\n   CALL $INITLAB(LABNAME,I,0,'1'B,I);\n   IF $XREF THEN CALL $PUTXRF(LABNAME);\n\n   #COM = REF;\n\n   RETURN (LABNAME);\n\n END $JUMPOFF;\n\n /*********************************************************************/\n /*  DETERMINE NAME BY OFFSET                                         */\n /*********************************************************************/\n $NAME:\n     PROC(VAL)  RETURNS(CHAR(16) VAR);\n DCL VAL     CHAR(*) VAR,\n     (O,OFF) BIN FIXED(31),\n     (P,Q)   PTR,\n     NAME    CHAR(16) VAR;\n\n     NAME = $CH(VAL);\n     O    = $HBF(NAME);\n     IF LENGTH(NAME)=6 THEN\n        NAME='00'||NAME;\n     SUBSTR(NAME,1,1)='A';\n     NAME='A' || SUBSTR(NAME,4);\n\n     IF O > TEXTLEN THEN DO;\n        NAME=$NEXTEL(CSECT) || '+' || $DIGIT(O);\n        GOTO $NAME_RETURN;\n     END;\n     P=LABL_START;\n     DO WHILE(P\u00ac=NULL);\n        IF P->LABL.OFF=O THEN DO;\n           NAME=P->LABL.NAME;\n           IF SUBSTR(NAME,1,1)='*' THEN DO;\n              NAME='';\n              OFF=0;\n              Q=LABL_START;\n              DO WHILE(Q\u00ac=NULL);\n                 IF SUBSTR(Q->LABL.NAME,1,1)\u00ac='*' &\n                    Q->LABL.OFF < P->LABL.OFF        &\n                    Q->LABL.OFF > OFF THEN DO;\n                       NAME=$NEXTEL(Q->LABL.NAME) || '+' ||\n                            $DIGIT(P->LABL.OFF-Q->LABL.OFF);\n                       OFF=Q->LABL.OFF;\n                 END;\n                 Q=Q->LABL.NEXT;\n              END;\n              IF NAME='' THEN\n                 NAME=$NEXTEL(CSECT) || '+' || $DIGIT(P->LABL.OFF);\n           END;\n           GOTO $EXIT_NAME;\n        END;\n        P=P->LABL.NEXT;\n     END;\n $EXIT_NAME:\n     IF INDEX(NAME,' ')\u00ac= 0 THEN\n        NAME=SUBSTR(NAME,1,INDEX(NAME,' ')-1);\n $NAME_RETURN:\n     RETURN(NAME);\n END $NAME;\n %SKIP;\n /*********************************************************************/\n /*  CLEAR ALL SCREEN PGM                                             */\n /*********************************************************************/\n $CLEAR_SCR: PROC;\n DCL I BIN FIXED(31);\n     DO I=1 TO MAXLVL-3;\n        #ANPU(REASM02_LINE(I).CMD#);\n        #AZO(REASM02_LINE(I).OFF#);\n        #AZO(REASM02_LINE(I).OBJECT#);\n        #ANP(REASM02_LINE(I).LABEL#);\n        #AZO(REASM02_LINE(I).OPER#);\n        #AZO(REASM02_LINE(I).OPERANDS#);\n        REASM02_LINE(I).CMD=' ';\n        REASM02_LINE(I).OFF=' ';\n        REASM02_LINE(I).OBJECT=' ';\n        REASM02_LINE(I).LABEL=' ';\n        REASM02_LINE(I).OPER=' ';\n        REASM02_LINE(I).OPERANDS=' ';\n        LINE_O(I),LINE_I(#CURI),LINE_C(#CURI)=0;\n        #SCRCOM(I) = '';\n     END;\n\n     IF PENDING THEN DO;\n        CALL ISPLINK('SETMSG ', 'REAS051 '); /*BLKPEN*/\n     END;\n     ELSE DO;\n        /*\n        IF $REM THEN\n           CALL ISPLINK('SETMSG ', 'REAS052 ');\n           REASM02_MESSAGE='R(' || $DIGIT(REMTIME)  || '/' ||\n                                   $DIGIT(REMCOUNT) || ')' ||\n                           REASM02_MESSAGE;\n        */\n     END;\n END $CLEAR_SCR;\n %SKIP;\n /*********************************************************************/\n /*  SUBSTRACT VALUE FROM A/V CONSTANT                                */\n /*********************************************************************/\n $SUBT:\n     PROC(OFF,LEN,DECR);\n DCL (OFF,LEN,DECR) BIN FIXED(31),\n     B      CHAR(1),\n     F4     BIN FIXED(31),\n     C4     CHAR(4) BASED(ADDR(F4)),\n     C(4)   CHAR(1) BASED(ADDR(F4));\n\n     IF LEN=4 THEN C4=SUBSTRTEXT(OFF+1,4);\n              ELSE C4=SUBSTRTEXT(OFF,4);\n     B    = C(1);\n     C(1) = LOW(1);\n     F4   = F4-DECR;\n     C(1) = B;\n     IF LEN=4 THEN CALL SUBSTRTEXT2(OFF+1,4,C4);\n              ELSE CALL SUBSTRTEXT2(OFF,4,C4);\n END $SUBT;\n %SKIP;\n /*********************************************************************/\n /*  ADD LABEL TO LABEL LIST POOL                                     */\n /*********************************************************************/\n $INITLAB:\n     PROC(N,O,R,F,P);\n DCL N    CHAR(8),        /* NAME*/\n     O    BIN FIXED(31),  /* OFF */\n     R    BIN FIXED,      /* REG */\n     F    BIT(1),         /* FIX */\n     P    BIN FIXED(31),  /* PLACE */\n     B    BIT(1) INIT('0'B),\n     Q    PTR INIT(NULL);\n\n     LABL_PTR=LABL_START;\n     DO WHILE(LABL_PTR\u00ac=NULL);\n        IF LABL.OFF = O THEN DO; /* THE SAME OFFSET     */\n           IF \u00acLABL.NORED THEN DO;  /* MAY TOUGHT       */\n               IF F | \u00acLABL.FIX THEN DO; /* REDEFINE    */\n                  IF  LABL.NAME\u00ac=N |\n                     (LABL.REG\u00ac=R & LABL.REG\u00ac=0)  |\n                      LABL.FIX\u00ac=F THEN\n                      B='1'B;\n                  LABL.NAME=N;\n                  IF LABL.REG\u00ac=0 THEN\n                     LABL.REG=R;\n                  LABL.FIX=F;\n               END;\n           END;\n           IF N='' THEN DO;\n              IF Q\u00ac=NULL THEN Q->LABL.NEXT=LABL.NEXT;\n                         ELSE LABL_START=LABL.NEXT;\n              FREE LABL;\n           END;\n           IF B THEN DO;\n              $CONF='1'B;\n              IF $REM THEN\n                 CALL $AUTOREC;\n           END;\n           RETURN;\n        END;\n        Q=LABL_PTR;\n        LABL_PTR=LABL.NEXT;\n     END;\n\n     IF N='' THEN RETURN;\n\n     IF R\u00ac=0 THEN DO;\n        USING_PTR=USING_START;\n        DO WHILE(USING_PTR\u00ac=NULL);\n           IF USING.REG=R & USING.NAME='' & USING.PLACE <= P &\n              USING.PLACE+USING.LENGTH > P THEN\n              GOTO $ALLOCATE_LABEL;\n           USING_PTR=USING.NEXT;\n        END;\n        RETURN;\n     END;\n\n $ALLOCATE_LABEL:\n     ALLOCATE LABL;\n     LABL.NEXT   = LABL_START;\n     LABL_START  = LABL_PTR;\n     LABL.NAME   = N;\n     LABL.REG    = R;\n     LABL.OFF = O;\n     LABL.FIX    = '0'B;\n     LABL.NORED  = '0'B;\n     $CONF       = '1'B;\n     IF $REM THEN\n        CALL $AUTOREC;\n END $INITLAB;\n %PAGE;\n /*********************************************************************/\n /*  MOVE USING ELEMENT INTO USING LIST                               */\n /*********************************************************************/\n $INITUSING:\n     PROC(O,R,PL,N,LEN);\n DCL O      BIN FIXED(31),\n     R      BIN FIXED(31),\n     PL     BIN FIXED(31),\n     N      CHAR(8),\n     LEN    BIN FIXED(31),\n     SORT   BIT(1),\n     (P,Q)  PTR;\n\n     ALLOCATE USING;\n     USING.NEXT   = USING_START;\n     USING_START  = USING_PTR;\n     USING.REG    = R;\n     USING.OFF    = O;\n     USING.PLACE  = PL;\n     USING.NAME   = N;\n     USING.FIX    = '0'B;\n     USING.LENGTH = TEXTLEN-PL;\n     IF LEN\u00ac=0 THEN USING.LENGTH=LEN;\n     IF N\u00ac='' THEN\n        CALL $INTLIV(N,LBLOCK_START,CONTROL);\n\n     $CONF='1'B;\n     IF $REM THEN\n        CALL $AUTOREC;\n END $INITUSING;\n %SKIP;\n /*********************************************************************/\n /*  DROP SUBROUTINE                                                  */\n /*********************************************************************/\n $DROP:\n     PROC(R);\n DCL R BIN FIXED(31),\n     N CHAR(8),\n     P PTR;\n     IF R=0 THEN RETURN;\n $DROP_START#1:\n     P=NULL;\n     USING_PTR=USING_START;\n     DO WHILE(USING_PTR\u00ac=NULL);\n        IF USING.REG=R THEN DO;\n           IF P\u00ac=NULL THEN P->USING.NEXT=USING.NEXT;\n                      ELSE USING_START=USING.NEXT;\n           N=USING.NAME;\n           FREE USING;\n           GOTO $DROP_START#1;\n        END;\n        P=USING_PTR;\n        USING_PTR=USING.NEXT;\n     END;\n $DROP_START#2:\n     P=NULL;\n     LABL_PTR=LABL_START;\n     DO WHILE(LABL_PTR\u00ac=NULL);\n        IF LABL.REG=R THEN DO;\n           IF P\u00ac=NULL THEN P->LABL.NEXT=LABL.NEXT;\n                      ELSE LABL_START=LABL.NEXT;\n           FREE LABL;\n           GOTO $DROP_START#2;\n        END;\n        P=LABL_PTR;\n        LABL_PTR=LABL.NEXT;\n     END;\n     IF N='' THEN RETURN;\n     USING_PTR=USING_START;\n     DO WHILE(USING_PTR\u00ac=NULL);\n        IF USING.NAME=N THEN RETURN;\n        USING_PTR=USING.NEXT;\n     END;\n     CALL $DELLIV(N,LBLOCK_START);\n END $DROP;\n %SKIP;\n /*********************************************************************/\n /*  TRY SET BASE REGISTER SUBROUTINE                                 */\n /*********************************************************************/\n $TESTUS:\n     PROC(J);\n DCL    J BIN FIXED(31);\n     IF USING_START\u00ac=NULL THEN RETURN;\n     SELECT (REASM02_LINE(1).OPER);\n       WHEN  ('BALR') DO;\n         IF RR1.R2=0 & RR1.R1\u00ac=0  & RR1.R1\u00ac=1  &\n                       RR1.R1\u00ac=14 & RR1.R1\u00ac=15 THEN\n            CALL $INITUSING(J+2,RR1.R1,J+2,'',0);\n       END;\n       WHEN  ('BAL') DO;\n         IF RX.B2=15 & RX.R1\u00ac=0  & RX.R1\u00ac=1  &\n                       RX.R1\u00ac=14 & RX.R1\u00ac=15 THEN\n            CALL $INITUSING(J+4,RX.R1,J+4,'',0);\n       END;\n       WHEN  ('LR') DO;\n         IF RR1.R2=15 & RR1.R1\u00ac=0  & RR1.R1\u00ac=1  &\n                        RR1.R1\u00ac=14 & RR1.R1\u00ac=15 THEN\n            CALL $INITUSING(0,RR1.R1,J+2,'',0);\n       END;\n       OTHER;\n     END;\n END $TESTUS;\n %PAGE;\n /*********************************************************************/\n /*  SET XREF ELEMENT                                                 */\n /*********************************************************************/\n $PUTXRF:\n     PROC(N);\n DCL N      CHAR(*),               /* NAME TO PUT     */\n     NAME   CHAR(16),\n     I      BIN FIXED(31),\n     #STMT  BIN FIXED(31),\n     (Q,P)  PTR INIT(NULL);\n\n     NAME = N;\n     IF NAME = '' THEN RETURN;         /* IF BLANK NAME   */\n     #STMT=PRINTNUM+#CURI;        /* STATEMENT NUMB  */\n\n     XREF_PTR=XREF_START;                     /* FROM XREF START     */\n L_XREF:\n     DO WHILE(XREF_PTR\u00ac=NULL);                /* WHILE XREF_PTR EXST */\n        IF XREF.NAME=NAME THEN DO;            /* TH SAME NAME ?      */\n           DO WHILE(XREF.CONT\u00ac=NULL);         /* GO BROTHER LINE     */\n              DO I=1 TO XREF.ISTMT;           /* BY STMT NUMBER      */\n                 IF XREF.STMT(I)=#STMT THEN RETURN;\n              END;                            /*                     */\n              XREF_PTR=XREF.CONT;             /* NEXT BROTHER        */\n           END;                               /*                     */\n           DO I=1 TO XREF.ISTMT;              /* BY STMT NUMBER      */\n              IF XREF.STMT(I)=#STMT THEN RETURN;\n           END;\n           IF XREF.ISTMT < DIM(XREF.STMT,1) THEN DO;\n              XREF.ISTMT=XREF.ISTMT+1;\n              XREF.STMT(XREF.ISTMT)=#STMT;\n           END;\n           ELSE DO;                           /* CREATE NEW BROTHER  */\n              P=XREF_PTR;                     /*                     */\n              ALLOCATE XREF;                  /* ALLOCATE HIM        */\n              P->XREF.CONT=XREF_PTR;          /* SET CONT VALUE      */\n              XREF.STMT=0;                    /* FILL                */\n              XREF.NAME=NAME;                 /*     ALL             */\n              XREF.ISTMT=1;                   /*        FIELDS       */\n              XREF.STMT(1)=#STMT;             /*                     */\n              XREF.NEXT=P->XREF.NEXT;         /* NEXT FIELD IS SAME  */\n              XREF.CONT=NULL;                 /* NO NEXT BROTHER     */\n           END;                               /*                     */\n           RETURN;                            /*                     */\n        END;                                  /*                     */\n        ELSE DO;                              /* NON EQUAL NAME      */\n          IF UNSPEC(XREF.NAME) > UNSPEC(NAME) THEN LEAVE L_XREF;\n        END;                                  /*                     */\n        Q=XREF_PTR;                           /* SAVE XREF POINTER   */\n        XREF_PTR=XREF.NEXT;                   /* GOTO NEXT ONE       */\n     END L_XREF;                              /*                     */\n                                              /*                     */\n     P=XREF_PTR;                              /*                     */\n     ALLOCATE XREF;                           /*                     */\n     IF Q=NULL THEN   XREF_START=XREF_PTR;    /*                     */\n               ELSE Q->XREF.NEXT=XREF_PTR;    /*                     */\n     XREF.STMT=0;                             /*                     */\n     XREF.NAME=NAME;                          /*                     */\n     XREF.NEXT=P;                             /*                     */\n     XREF.CONT=NULL;                          /*                     */\n     XREF.ISTMT=1;                            /*                     */\n     XREF.STMT(1)=#STMT;                      /*                     */\n END $PUTXRF;                                 /*                     */\n %SKIP;\n /*********************************************************************/\n /*  PRINT XREF TABLE                                                 */\n /*********************************************************************/\n $PRINT_XREF:\n     PROC;\n DCL (P,Q) PTR,\n     SORT  BIT(1),\n     (I,N) BIN FIXED(31);\n\n     SIGNAL ENDPAGE(SYSPRINT);\n     PUT SKIP EDIT('=== CROSS REFERENCE LISTING ===')\n                   (COL(40),A,SKIP(2));\n     XREF_PTR=XREF_START;\n     DO WHILE(XREF_PTR\u00ac=NULL);\n        PUT SKIP EDIT(XREF.NAME)(COL(2),A(16));\n        N=1;\n $PUTSTMT:\n        DO I=1 TO XREF.ISTMT;\n           PUT EDIT(XREF.STMT(I))(X(1),F(4));\n           N=N+1;\n           IF N > 20 THEN DO;\n              N=1;\n              PUT SKIP EDIT((16)' ')(COL(2),A(16));\n           END;\n        END;\n        P=XREF_PTR;\n        IF XREF.CONT\u00ac=NULL THEN DO;\n           XREF_PTR=XREF.CONT;\n           FREE P->XREF;\n           GOTO $PUTSTMT;\n        END;\n        XREF_PTR=XREF.NEXT;\n        FREE P->XREF;\n     END;\n     XREF_START=NULL;\n\n     PUT SKIP(3) EDIT('--------------- END OF XREF LIST')(A);\n END $PRINT_XREF;\n %PAGE;\n /*********************************************************************/\n /*  COMMENT FILL SUBROUTINE                                          */\n /*********************************************************************/\n $PUTCOM:\n     PROC(I);\n DCL   (I,J,K,L) BIN FIXED(31),\n       (P,Q,R)   PTR,\n       LINE_PTR  PTR,\n       BYTE      CHAR(1),\n       LINE      CHAR(80) BASED(LINE_PTR);\n\n     LINE_PTR=ADDR(REASM02_LINE(I).CMD#);\n     IF REASM02_LINE(I).OPERANDS\u00ac='' THEN DO;\n        J = LENGTH(REASM02_LINE(I).OPERANDS);\n        DO K=80 BY -1 WHILE(SUBSTR(LINE,K,1)=' ');\n           J = J-1;\n        END;\n     END;\n     ELSE   DO;\n        K = 50;\n        J = 2;\n     END;\n\n     LINE_C(I)=0;\n     IF K >= 79 THEN RETURN;\n\n     #ANPL(BYTE);\n     SUBSTR(REASM02_LINE(I).OPERANDS, J+1, 1) = BYTE;\n\n     LINE_C(I)=K+1;\n     COM_PTR=COM_START;\n     DO WHILE(COM_PTR\u00ac=NULL);\n        IF LINE_O(I)           <= COM.OFF &\n           LINE_O(I)+LINE_I(I) >  COM.OFF THEN\n           SUBSTR(LINE,K+2)=COM.TXT;\n        COM_PTR=COM.NEXT;\n     END;\n     IF SUBSTR(LINE,K+2)='' THEN   /* NOT FILLED   */\n        SUBSTR(LINE,K+2)=#COM;\n     #SCRCOM(I) = SUBSTR(LINE,K+2);\n END $PUTCOM;\n %SKIP;\n /*********************************************************************/\n /*  MEMORY FREE SUBROUTINE                                           */\n /*********************************************************************/\n $FREE:\n     PROC ;\n     @@FREE_LIST(DSC);\n     @@FREE_LIST(LABL);\n     @@FREE_LIST(QUALIFY);\n     @@FREE_LIST(USING);\n     @@FREE_LIST(COM);\n     @@FREE_LIST(LBLOCK);\n\n END $FREE;\n %SKIP;\n /*********************************************************************/\n /*  AUTO RECOVERY PROCESS SUBROUTINE                                 */\n /*********************************************************************/\n $AUTOREC:\n     PROC ;\n     REMCOUNT=REMCOUNT+1;\n     IF REMCOUNT=REMTIME THEN\n        CALL REASMS('0'B,'*');\n END $AUTOREC;\n %SKIP;\n /*********************************************************************/\n /*  FILL DUMMY SUBROUTINE                                            */\n /*********************************************************************/\n $PUTDUMMY:\n     PROC(NAME,OFFSET);\n DCL NAME   CHAR(*),\n     OFFSET BIN FIXED(31),\n     (P,Q,R)  PTR INIT(NULL);\n\n     P=LBLOCK_START;\n     DO WHILE(P\u00ac=NULL);\n        IF  P->LBLOCK.NAME=NAME THEN LEAVE;\n        P = P->LBLOCK.NEXT;\n     END;\n     IF P = NULL THEN RETURN;\n     IF P->LBLOCK.ADR \u00ac= 0 THEN RETURN;    /* DO NOT FILL LIV | */\n\n     R = P->LBLOCK.ADUMMY;\n     DO WHILE(R\u00ac=NULL);\n        IF R->DUMMY.OFF = OFFSET THEN     RETURN;\n        IF R->DUMMY.OFF > OFFSET THEN     LEAVE;\n        Q=R;\n        R=R->DUMMY.NEXT;\n     END;\n     ALLOCATE DUMMY;\n     DUMMY.OFF = OFFSET;\n     DUMMY.NEXT   = R;\n     DUMMY.NAME   = '';\n     IF Q=NULL THEN P->LBLOCK.ADUMMY=DUMMY_PTR;\n     ELSE           Q->DUMMY.NEXT=DUMMY_PTR;\n END $PUTDUMMY;\n\n /*********************************************************************/\n /*  RETURN BIT STRING WHICH REPRESENTS BYTE                          */\n /*********************************************************************/\n $BITSTR:PROC(BYTE) RETURNS(CHAR(20) VAR);\n DCL BYTE   CHAR(1),\n     HALF   BIN FIXED,\n     LOCVAR CHAR(20) VAR INIT('');\n     ICH = 0;\n     DO HALF=128,64,32,16,8,4,2,1;\n        CH = BYTE;\n        UNSPEC(ICH) = UNSPEC(ICH) & UNSPEC(HALF);\n        IF ICH = 0 THEN LOCVAR = LOCVAR || '0';\n        ELSE            LOCVAR = LOCVAR || '1';\n     END;\n     LOCVAR = 'B''' || LOCVAR || '''';\n     RETURN(LOCVAR);\n END $BITSTR;\n\n /*********************************************************************/\n /*  TEST FOR LABEL REDEFINITION                                      */\n /*********************************************************************/\n $DUBLAB:PROC(NAME,OFFSET) RETURNS(BIT(1));\n DCL NAME    CHAR(*),\n     OFFSET  BIN FIXED(31),\n     (P,Q)   PTR;\n    IF NAME='' THEN RETURN('0'B);\n    P=LABL_START;\n    DO WHILE(P\u00ac=NULL);\n       IF P->LABL.NAME=NAME & OFFSET\u00ac=P->LABL.OFF THEN RETURN('1'B);\n       P=P->LABL.NEXT;\n    END;\n    P=LBLOCK_START;\n    DO WHILE(P\u00ac=NULL);\n       IF P->LBLOCK.ADR=0 THEN DO;\n          Q = P->LBLOCK.ADUMMY;\n          DO WHILE(Q\u00ac=NULL);\n             IF Q->DUMMY.NAME = NAME THEN RETURN('1'B);\n             Q = Q->DUMMY.NEXT;\n          END;\n       END;\n       P=P->LBLOCK.NEXT;\n    END;\n    RETURN ('0'B);\n END $DUBLAB;\n\n /*********************************************************************/\n /*  TEST IF CHAR STRING IS GOOD                                      */\n /*********************************************************************/\n $CHARSTR: PROC(STR)  RETURNS(BIT(1));\n DCL STR  CHAR(*) VAR;\n DCL I;\n     ICH = 0;\n     DO I=1 TO LENGTH(STR);\n        CH = SUBSTR(STR,I,1);\n        CH = SUBSTR(GOODA,ICH+1,1);\n        IF CH = HIGH(1) THEN RETURN('0'B);\n     END;\n     RETURN('1'B);\n END $CHARSTR;\n\n /*********************************************************************/\n /*  TEST PSA USING                                                   */\n /*********************************************************************/\n $USING_PSA:\n     PROC(PTR);\n DCL PTR       BIN     FIXED(31),\n     TRY       BIT(1)  STATIC INT INIT('0'B),\n     PSAOK     BIT(1)  STATIC INT INIT('0'B),\n     PSANAME   CHAR(8) STATIC INT INIT('@PSA'),\n     P         PTR,\n     RC        BIN     FIXED(31);\n\n     IF \u00acTRY THEN DO;\n        CALL REASMLD(PSANAME,RC,CONTROL);\n        CALL REASMDL(PSANAME);\n        TRY = '1'B;\n        IF RC THEN PSAOK='1'B;\n     END;\n\n     IF PSAOK THEN DO;\n        P = USING_START;\n        DO WHILE(P \u00ac= NULL);\n           IF  P->USING.REG                    = 0   &\n               P->USING.PLACE                 <= PTR &\n               P->USING.PLACE+P->USING.LENGTH >  PTR THEN  RETURN;\n           P = P->USING.NEXT;\n        END;\n        CALL $INITUSING(PTR,0,PTR,PSANAME,4);\n     END;\n\n END $USING_PSA;\n\n /*********************************************************************/\n /*  TEST CVT USING                                                   */\n /*********************************************************************/\n $USING_CVT:\n     PROC(PTR, REG);\n DCL PTR       BIN     FIXED(31),\n     REG       BIN     FIXED,\n     TRY       BIT(1)  STATIC INT INIT('0'B),\n     CVTOK     BIT(1)  STATIC INT INIT('0'B),\n     CVTNAME   CHAR(8) STATIC INT INIT('@CVT'),\n     P         PTR,\n     RC        BIN     FIXED(31);\n\n     IF \u00acTRY THEN DO;\n        CALL REASMLD(CVTNAME,RC,CONTROL);\n        CALL REASMDL(CVTNAME);\n        TRY = '1'B;\n        IF RC THEN CVTOK='1'B;\n     END;\n\n     IF CVTOK THEN DO;\n        P = USING_START;\n        DO WHILE(P \u00ac= NULL);\n           IF  P->USING.REG                    = REG &\n               P->USING.PLACE                 <= PTR &\n               P->USING.PLACE+P->USING.LENGTH >  PTR &\n               P->USING.NAME                   = CVTNAME THEN RETURN;\n           P = P->USING.NEXT;\n        END;\n        CALL $INITUSING(PTR,REG,PTR,CVTNAME,4);\n     END;\n\n END $USING_CVT;\n\n $GOODCMD: PROC(OFFSET);\n  DCL (OFFSET,I)  BIN FIXED(31);\n\n    IF OFFSET<0 THEN OFFSET=0;\n    IF OFFSET>= TEXTLEN THEN OFFSET = TEXTLEN-1;\n    IF OFFSET\u00ac=0 THEN DO;\n       CALL $FINDDSC(OFFSET);\n       IF DSC.TYPE='I' THEN DO;\n          I=0;\n          IF MOD(OFFSET,2)\u00ac=0 THEN OFFSET=OFFSET-1;\n          DO WHILE(DSC.OFF+I <= OFFSET);\n             CMD_PTR  = ADDRTEXT();\n             #CMD_PTR = #CMD_PTR+DSC.OFF+I;\n             I=I+CMDLEN(CMDDEF);\n          END;\n          OFFSET=DSC.OFF+I;\n       END;\n    END;\n END $GOODCMD;\n %PAGE;\n\n\n $ERROR:\n     ON ERROR SNAP GOTO $RETURN;\n     CALL $PRINTDSC('--- ABNORMAL END OF REASM PROGRAMM');\n     IF $CONF THEN DO;\n        CALL ISPLINK ('SETMSG ', 'REAS002 ');  /* SYSTEM ERROR */\n        OFFSET = $OFFSET;\n        ON ERROR GOTO $ERROR;\n        GOTO $SHOW_LOOP;\n     END;\n     GOTO $RETURN;\n\n $REALLOC:\n     PROC(DDNAME, DSNAME, MEMNAME, VOLNAME) RED REORDER;\n     DCL DDNAME  CHAR(8),\n         DSNAME  CHAR(44),\n         MEMNAME CHAR(8),\n         VOLNAME CHAR(6);\n     DCL TXT CHAR(255) VAR INIT('');\n     DCL T   CHAR(255);\n\n     CALL DYNAM(DYNWORK, 'UNALLOC ',\n                'DD=' || DDNAME || ' UNALLOC;');\n     TXT = 'DD='  || DDNAME ||\n           ' DSN='  || $CUTDSN(DSNAME);\n     MEMNAME = TRANSLATE(MEMNAME,'#','*');\n     IF MEMNAME \u00ac= '' THEN TXT = TXT || ' MEMBER=' || MEMNAME;\n     IF VOLNAME \u00ac= '' THEN TXT = TXT || ' VOLUME=' || VOLNAME;\n     TXT = TXT || ' SHR;';\n     T = TXT;\n     DYNAREA.VOL = '';\n     CALL DYNAM(DYNWORK,'ALLOCR ',DYNAREA,T);\n END $REALLOC;\n\n $CUTDSN:\n     PROC(OLDNAME) RED REORDER RETURNS(CHAR(44) VAR);\n     DCL OLDNAME CHAR(44),\n         NEWNAME CHAR(44) VAR;\n     DCL I;\n     OLDNAME = TRANSLATE(OLDNAME, ' ', LOW(1));\n     I = INDEX(OLDNAME,' ');\n     IF I>1 THEN NEWNAME=SUBSTR(OLDNAME,1,I-1);\n     ELSE        NEWNAME=OLDNAME;\n     RETURN(NEWNAME);\n END $CUTDSN;\n\n $PRINTDSC:\n     PROC(T) RED REORDER;\n     DCL T CHAR(*),\n         I;\n\n     ON ERROR SYSTEM;\n\n     PUT SKIP EDIT(T,' DATE: ',DATE,' TIME: ',TIME)(A);\n     PUT SKIP EDIT('DSN=',DSN,' MEM=',MEMBER,' CSECT=',CSECT)(A);\n\n     IF DSC_START\u00ac=NULL THEN DO;\n     PUT SKIP(2) EDIT('*** DSC TABLE ***',\n     '..NAME.. ..OFFSET ..LENGTH  TYPE RD N F E S')(A,SKIP,COL(9),A);\n     DSC_PTR=DSC_START;\n     DO WHILE(DSC_PTR\u00ac=NULL);\n        PUT SKIP\n            EDIT(DSC.NAME,$BH(DSC.OFF),$BH(DSC.LENGTH),DSC.TYPE,\n                 DSC.NORED,DSC.NEW,DSC.FIX,DSC.EXTRN,DSC.SUBT)\n            (COL(9),A(8),X(1),A(8),X(1),A(8),X(4),A(1),X(3),B(1),X(1),\n                    B(1),X(1),B(1),X(1),B(1),X(1),B(1));\n        DSC_PTR=DSC.NEXT;\n     END;\n     PUT SKIP LIST('-----------------------------------');\n     END;\n\n     IF LABL_START\u00ac=NULL THEN DO;\n     LABL_PTR=LABL_START;\n     PUT SKIP(2) EDIT('*** LABEL TABLE ***',\n     '...LABEL ..OFFSET RG F NR')(A,SKIP,COL(9),A);\n     DO WHILE(LABL_PTR\u00ac=NULL);\n        PUT SKIP EDIT(LABL.NAME,$BH(LABL.OFF),LABL.REG,LABL.FIX,\n                     LABL.NORED)\n                     (COL(9),A,X(1),A(8),X(1),F(2),X(1),B(1),X(2),B(1));\n        LABL_PTR=LABL.NEXT;\n     END;\n     PUT SKIP LIST('-----------------------------------');\n     END;\n\n     IF USING_START\u00ac=NULL THEN DO;\n     USING_PTR=USING_START;\n     PUT SKIP(2) EDIT('*** USING TABLE ***',\n     '..NAME.. ..OFFSET ..LENGTH ...PLACE REG  F')(A,SKIP,COL(9),A);\n     DO WHILE(USING_PTR\u00ac=NULL);\n        PUT SKIP EDIT(USING.NAME,\n                      $BH(USING.OFF),\n                      $BH(USING.LENGTH),\n                      $BH(USING.PLACE),\n                      $REGS(USING.REG),\n                      USING.FIX)\n                     (COL(9),A(8),X(1),A,X(1),A,X(1),A,X(1),A(3),\n                       X(2),B(1));\n        USING_PTR=USING.NEXT;\n     END;\n     PUT SKIP LIST('-----------------------------------');\n     END;\n\n     IF COM_START\u00ac=NULL THEN DO;\n     COM_PTR=COM_START;\n     PUT SKIP(2) EDIT('*** COMMENT TABLE ***',\n     '..OFFSET ..TXT..')(A,SKIP,COL(9),A);\n     DO WHILE(COM_PTR\u00ac=NULL);\n        PUT SKIP EDIT($BH(COM.OFF),COM.TXT)\n                     (COL(9),A(8),X(1),A);\n        COM_PTR=COM.NEXT;\n     END;\n     PUT SKIP LIST('-----------------------------------');\n     END;\n\n     IF LBLOCK_START\u00ac=NULL THEN DO;\n     LBLOCK_PTR=LBLOCK_START;\n     PUT SKIP(2) EDIT('*** LBLOCK TABLE ***',\n     '..NAME..  ...ADR.. ..DUMMY. ...MACRO STATEMENT...')\n     (A,SKIP,COL(9),A);\n     DO WHILE(LBLOCK_PTR\u00ac=NULL);\n        PUT SKIP EDIT(LBLOCK.NAME,\n                      $BH(LBLOCK.ADR),\n                      $BH(BIN(UNSPEC(LBLOCK.ADUMMY),31)),\n                      LBLOCK.MACRO)\n                     (COL(9),A(9),X(1),A,X(1),A,X(1),A);\n        LBLOCK_PTR=LBLOCK.NEXT;\n     END;\n     PUT SKIP LIST('-----------------------------------');\n     END;\n\n     IF QUALIFY_START\u00ac=NULL THEN DO;\n     QUALIFY_PTR=QUALIFY_START;\n     PUT SKIP(2) EDIT('*** QUALIFY TABLE ***',\n     '..OFFSET ..NAME..')(A,SKIP,COL(9),A);\n     DO WHILE(QUALIFY_PTR\u00ac=NULL);\n        PUT SKIP EDIT($BH(QUALIFY.OFF),QUALIFY.NAME)\n                     (COL(9),A(8),X(1),A);\n        QUALIFY_PTR=QUALIFY.NEXT;\n     END;\n     PUT SKIP LIST('-----------------------------------');\n     END;\n\n     PUT SKIP(2) EDIT('*** ESD ARRAY TABLE *** (CURRENT ESDID =',\n                      ESDID, ')',\n                      'NNNNN ..NAME.. .TYPE ..OFFSET ALIGN LEN ..REF')\n                     (A,F(5),A,SKIP,COL(9),A);\n     DO I=1 TO DIM_ESD_ARRAY;\n        PUT SKIP EDIT(ESD_ARRAY(I).ID,\n                      ESD_ARRAY(I).NAME,\n                      $IMM(ESD_ARRAY(I).TYPE),\n                      $BH(BIN(ESD_ARRAY(I).OFF,31)),\n                      $IMM(ESD_ARRAY(I).ALIGN),\n                      BIN(ESD_ARRAY(I).LENGTH,15),\n                      ESD_ARRAY(I).REF)\n        (COL(9),F(5),X(1),A,X(1),A,X(1),A,X(1),A,X(1),F(3),X(1),F(5));\n     END;\n     PUT SKIP LIST('-----------------------------------');\n\n     IF XREF_START\u00ac=NULL THEN CALL $PRINT_XREF;\n\n     REVERT ERROR;\n     CALL REASLST;\n\n END $PRINTDSC;\n\n CALCULATE_LVL: PROC;\n       DCL  ISPLINK ENTRY EXT OPTIONS(INTER ASM RETCODE);\n       DCL  F4      BIN   FIXED(31) INIT(4);\n       DCL  SCR     CHAR(4);\n       CALL ISPLINK ('VCOPY ', 'ZSCREEND ', F4, SCR, 'MOVE ');\n       GET STRING(SCR) LIST(MAXLVL);\n       LVL = MAXLVL - 3;\n END CALCULATE_LVL;\n\n /*  TEXTARRAY MANIPULATION ROUTINES */\n SUBSTRTEXT: PROC(OFF, LEN) RETURNS(CHAR(32767) VAR);  /***/\n   DCL (OFF,LEN) BIN FIXED(31);\n   RETURN (SUBSTRARRAY(TEXT,OFF,LEN));\n END SUBSTRTEXT;\n\n SUBSTRTEXT1: PROC(OFF) RETURNS(CHAR(32767) VAR);   /***/\n   DCL (OFF) BIN FIXED(31);\n   RETURN (SUBSTRARRAY(TEXT,OFF,0));\n END SUBSTRTEXT1;\n\n SUBSTRTEXT2: PROC(OFF, LEN, VAL);                /***/\n   DCL (OFF,LEN,I) BIN FIXED(31);\n   DCL VAL CHAR(*) VAR;\n   IF (LEN > 32767) THEN\n      SIGNAL ERROR;\n   DO I=0 TO LEN-1;\n      TEXT(OFF+I) = SUBSTR(VAL,I+1,1);\n   END;\n END SUBSTRTEXT2;\n\n SUBSTRTEXTCOPY: PROC(OFF, LEN) RETURNS(CHAR(32767) VAR);  /***/\n   DCL (OFF,LEN) BIN FIXED(31);\n   RETURN (SUBSTRARRAY(TEXTCOPY,OFF,LEN));\n END SUBSTRTEXTCOPY;\n\n SUBSTRARRAY: PROC(ARRAY,OFF,L) RETURNS(CHAR(32767) VAR);  /***/\n   DCL ARRAY(*) CHAR(1);\n   DCL (OFF,LEN,L) BIN FIXED(31);\n   DCL SUB  CHAR(32767) BASED(PSUB), PSUB PTR;\n   DCL SUBS CHAR(32767) VAR INIT('');\n\n   LEN = L;\n   IF (LEN = 0) | ((OFF+LEN-1) > TEXTIND) THEN\n      LEN = TEXTIND-OFF+1;\n\n   IF (LEN > 32767) THEN\n      SIGNAL ERROR;\n\n   /*\n   DCL I BIN FIXED(31);\n   DO I=0 TO LEN-1;\n      SUBS = SUBS || ARRAY(OFF+I);\n   END;\n   */\n   PSUB = ADDR(ARRAY(OFF));\n   SUBS = SUBSTR(SUB,1,LEN);\n\n   RETURN (SUBS);\n END SUBSTRARRAY;\n\n ALLOCATETEXT: PROC(LEN);      /***/\n   DCL LEN BIN FIXED(31);\n   TEXTIND = 0;\n END ALLOCATETEXT;\n\n FREETEXT: PROC;                          /***/\n END FREETEXT;\n\n LENGTHTEXT: PROC RETURNS(BIN FIXED(31));  /***/\n   RETURN (TEXTIND);\n END LENGTHTEXT;\n\n SETTEXT: PROC(VAL);                      /***/\n   DCL VAL CHAR(*) VAR;\n   TEXTIND = 0;\n   CALL CONCATTEXT(VAL);\n END SETTEXT;\n\n CONCATTEXT: PROC(VAL);       /***/\n   DCL VAL CHAR(*) VAR;\n   DCL I BIN FIXED(31);\n   DO  I=1 TO LENGTH(VAL);\n     TEXT(TEXTIND+1) = SUBSTR(VAL,I,1);\n     TEXTIND = TEXTIND + 1;\n   END;\n END CONCATTEXT;\n\n COPYTEXT: PROC;               /***/\n   DCL I BIN FIXED(31);\n   TEXTCOPY = TEXT;\n END COPYTEXT;\n\n ADDRTEXT: PROC RETURNS(PTR);  /***/\n   RETURN (ADDR(TEXT));\n END ADDRTEXT;\n\n %PAGE;\n     %INCLUDE REASMS;\n     %INCLUDE REASMR;\n\n END REASM;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REASMM#O": {"ttr": 3592, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\'\\x01\\x06\\x01\\x8f\\x01\\x06\\x01\\x9f#&\\x12#\\x12\"\\x00\\x01\\xd7\\xc7\\xd4\\xe5\\xc3@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2006-01-18T00:00:00", "modifydate": "2006-01-19T23:26:27", "lines": 4643, "newlines": 4642, "modlines": 1, "user": "PGMVC"}, "text": "*PROCESS FLAG(E),NEST,OPT(TIME),M,NOINSOURCE,GN,S;\n /*\n//PGMVCR  JOB 'IBI','V CHERNYAK',REGION=6M,NOTIFY=PGMVC,CLASS=A,\n//        MSGCLASS=A,MSGLEVEL=(0,0)\n//PROCLIB  JCLLIB ORDER=PGMVYC.REASM.PLI\n//*\n//COMPILE EXEC PLIXCL,PARM.LKED='LET,NCAL'\n//PLI.SYSLIN  DD UNIT=VIO,SPACE=(TRK,(50,50)),DISP=(,PASS),\n//    DSN=&&LOADSET\n//PLI.SYSIN     DD DSN=PGMVYC.REASM.PLI(REASMM),DISP=SHR\n//PLI.SYSLIB    DD DSN=PGMVYC.REASM.PLI,DISP=SHR\n//LKED.SYSLMOD  DD UNIT=VIO,SPACE=(CYL,(5,1,1)),DISP=(,PASS),\n//     DCB=(BLKSIZE=13030,RECFM=U,DSORG=PO),DSN=&&LOAD(REASMM)\n//*\n//LKED2    EXEC PGM=IEWL,PARM='LIST,LET'\n//SYSPRINT DD   SYSOUT=*\n//SYSUT1   DD   UNIT=VIO,SPACE=(TRK,(30,30))\n//SYSLIB   DD   DSN=CEE.SCEELKED,DISP=SHR\n//         DD   DSN=PLI.V2R3M0.PLIBASE,DISP=SHR\n//         DD   DSN=PLI.V2R3M0.SIBMBASE,DISP=SHR\n//         DD   DSN=ISP.SISPLOAD,DISP=SHR\n//         DD   DSN=&&LOAD,DISP=(OLD,DELETE)\n//         DD   DSN=PGMVYC.REASM.SUBLOAD,DISP=SHR\n//SYSLMOD  DD   DSN=PGMVC.TEST.LOAD,DISP=SHR\n//*SYSLMOD  DD   DSN=PGMVYC.REASM.LOAD,DISP=SHR\n//SYSLIN   DD   *\n           INCLUDE SYSLIB(REASMM)\n           INCLUDE SYSLIB(REASCNV)\n           INCLUDE SYSLIB(REASMLIV)\n           INCLUDE SYSLIB(REASQPW$)\n           ENTRY PLISTART\n           NAME  REASM(R)\n//COMPRESS  EXEC  PGM=IEBCOPY\n//SYSPRINT  DD    SYSOUT=*\n//SYSIN     DD    DUMMY\n//SYSUT1    DD    DSN=*.LKED2.SYSLMOD,DISP=SHR\n//SYSUT2    DD    DSN=*.LKED2.SYSLMOD,DISP=SHR\n//\n */\n\n\n /*  ----------------------------------------------------------- */\n /*  MVS/ESA REASM COPYRIGHT (C) 2006, BY VALENTIN CHERNYAK      */\n /*  ----------------------------------------------------------- */\n\n REASM:\n     PROC(PARM) RED OPTIONS(MAIN);\n\n     DCL TEXT        CHAR(*)     VAR CTL ALIGNED,\n         TEXTCOPY    CHAR(*)     VAR CTL ALIGNED;\n     DCL TEXTIND     BIN FIXED(31) INIT(0);\n\n     %PRINT;\n     %INCLUDE REASMMAC;    /* GENERIC MACROS */\n     %INCLUDE REASMD;      /* VARIABLES      */\n     %INCLUDE REASMCMD;    /* COMMAND ARR    */\n     %INCLUDE REASMBAS;    /* DATA BASE      */\n     %INCLUDE REASMSVC;    /* SVC NUMBERS    */\n     %INCLUDE REASMHRD;    /* HRD CONTS      */\n     %PRINT;\n\n     ON ERROR SNAP GOTO $ERROR;\n\n     IF PARM\u00ac='' THEN DO;\n     END;\n\n     CALL REASMTL(GOODA);\n\n     CALL REASMI(@,CMDSET,@COMPT);\n\n     CALL REASPRF('NODISPLAY',       /* READ PROFILE VARIABLES */\n          $AUTO, $DSOFF, $REM, #ABSA, #ABSB, LINELEN, REMTIME,\n          OS,    PC,     FC );\n\n %NOPRINT;\n     %INCLUDE SCREEN;\n     %INCLUDE REASMSCR;\n %PRINT;\n\n     CALL ISPLINK ('VDEFINE ', 'FIELD    ', FIELD,    'CHAR ',  8);\n     CALL ISPLINK ('VDEFINE ', 'POS      ', POS,      'FIXED ', 4);\n     CALL ISPLINK ('VDEFINE ', 'LVL      ', LVL,      'FIXED ', 4);\n     CALL ISPLINK ('VDEFINE ', 'MEMOUT   ', MEMOUT,   'CHAR  ', 8);\n     CALL ISPLINK ('VDEFINE ', 'FINDTXT  ', FINDTXT,  'CHAR  ', 30);\n     CALL ISPLINK ('VDEFINE ', 'IV       ', IV,       'CHAR  ', 4);\n     CALL ISPLINK ('VDEFINE ', 'PDFCHAR  ', PDFCHAR,  'CHAR  ', 15);\n     CALL ISPLINK ('VDEFINE ', 'PDFBYTE  ', PDFBYTE,  'CHAR  ', 1);\n     CALL ISPLINK ('VDEFINE ', 'REASMVER ', REASMVER, 'CHAR  ', 3);\n     CALL ISPLINK ('VDEFINE ', 'R01DSN   ', DSN,      'CHAR  ', 44);\n\n     CALL ISPLINK ('VDEFINE ', 'REAPWD01 ', PASS(01), 'CHAR  ', 8);\n     CALL ISPLINK ('VDEFINE ', 'REAPWD02 ', PASS(02), 'CHAR  ', 8);\n     CALL ISPLINK ('VDEFINE ', 'REAPWD03 ', PASS(03), 'CHAR  ', 8);\n     CALL ISPLINK ('VDEFINE ', 'REAPWD04 ', PASS(04), 'CHAR  ', 8);\n     CALL ISPLINK ('VDEFINE ', 'REAPWD05 ', PASS(05), 'CHAR  ', 8);\n     CALL ISPLINK ('VDEFINE ', 'REAPWD06 ', PASS(06), 'CHAR  ', 8);\n     CALL ISPLINK ('VDEFINE ', 'REAPWD07 ', PASS(07), 'CHAR  ', 8);\n     CALL ISPLINK ('VDEFINE ', 'REAPWD08 ', PASS(08), 'CHAR  ', 8);\n     CALL ISPLINK ('VDEFINE ', 'REAPWD09 ', PASS(09), 'CHAR  ', 8);\n     CALL ISPLINK ('VDEFINE ', 'REAPWD10 ', PASS(10), 'CHAR  ', 8);\n     CALL ISPLINK ('VDEFINE ', 'REAJDATE ', JDAT,     'CHAR  ', 6);\n     CALL ISPLINK ('VDEFINE ', 'DYNMSG   ', DYNMSG,   'CHAR  ', 256);\n\n     CALL ISPLINK ('DISPLAY ', 'REASMIDP '); /* GET IDP PARMS */\n     CALL CALCULATE_LVL;\n\n     CALL DYNAM(DYNWORK, 'INIT ', DYNMSG);\n     CALL DYNAM(DYNWORK, 'ALLOC ', 'DD=REAPRINT;',\n                         'PRIM=5 SEC=10 BLKSIZE=3000 TRK;');\n\n     OPEN FILE(SYSPRINT) TITLE('REAPRINT') PRINT;\n     /*\n     PUT SKIP EDIT('*** MVS/ESA REASM ', REASMVER,\n         '. COPYRIGHT (C) 1985,1987,1991,2006   CHERNYAK VALENTIN')(A);\n     */\n     ON ENDPAGE(SYSPRINT) BEGIN;\n        #PAGE=#PAGE+1;\n        PUT PAGE    EDIT('--- MVS/ESA REASM ',\n                      REASMVER, '   ', REASM02_DSN,'PAGE ',#PAGE)\n                      (A,A,A,A,COL(80),A,F(4));\n        PUT SKIP(3);\n     END;\n\n     DYNINFO.DSNAME = '';\n     DYNINFO.DSORG  = '0'B;\n     CALL DYNAM(DYNWORK, 'INFO ', DYNINFO, 'DD=' || SAVE || ';');\n     DSRG           = DYNINFO.DSORG;\n     DSNSAVE        = DYNINFO.DSNAME;\n     MEMSAVE        = DYNINFO.MEMBER;\n     VOLSAVE        = '';\n     IF DSNSAVE     = 'NULLFILE ' THEN DSRG='0'B;\n\n     /*******************************/\n     /* GET MEMBER & CSECT NAMES    */\n     /*******************************/\n L_AGAIN:\n     CALL FREETEXT();\n     @@FREE_CTL (ESD_ARRAY);\n     @@FREE_LIST(RLD);\n     CALL $FREE;\n\n     I = REASLOA('ALLOC', DSN, VOL, MEMBER, CSECT, ' ');\n\n     /********************************************/\n     /*  R E T U R N         HANDLING            */\n     /********************************************/\n     IF I \u00ac= 0 THEN DO;       /* END KEY PRESSED */\n $RETURN: CALL DYNAM(DYNWORK, 'END ');\n          RETURN;\n     END;\n\n     /********************************************/\n     /*  R E C O V E R Y     HANDLING            */\n     /********************************************/\n     IF REASM02_PRIMARY = 'R' THEN DO;\n        IF DSRG=PO | DSRG=POU THEN DO;\n           CALL $REALLOC(SAVE, DSNSAVE, '', '');\n           IF CSECT='' THEN DO;\n              CSECT = REASMLB(SAVE);\n              IF CSECT='?' | CSECT='' THEN DO;\n                 #CUR(CSECT,1);\n                 CALL ISPLINK('SETMSG ', 'REAS055 ');\n                 GOTO L_AGAIN;\n              END;\n           END;\n           MEMSAVE = CSECT;\n           CALL $REALLOC(SAVE, DSNSAVE, MEMSAVE, '');\n        END;\n        ON ERROR GOTO $REC_ERR;\n        CALL REASMR;\n        IF PLIRETV()\u00ac=0 THEN DO;\n $REC_ERR: CLOSE FILE(SAVEFL);\n           CALL ISPLINK('SETMSG ', 'REAS056 ');\n           ON ERROR SNAP GOTO $ERROR;\n           GOTO L_AGAIN;\n        END;\n        ON ERROR SNAP GOTO $ERROR;\n        $CONF    =   '0'B;\n        REMCOUNT =      0;\n        LVL      =      MAXLVL-3;\n\n        DSN = '''' || $NEXTEL(DSN) || '''';\n        CALL ISPLINK ('VREPLACE', 'DSN   ', BIN(44,31), DSN   );\n        DSN = SUBSTR(DSN,2,INDEX(DSN,' ')-3);\n        CALL ISPLINK ('VREPLACE', 'MEM   ', BIN( 8,31), MEMBER);\n        CALL ISPLINK ('VREPLACE', 'CSECT ', BIN( 8,31), CSECT );\n        GOTO $FORM_REASM02;\n     END;\n\n     /********************************************/\n     /*  N E W   L I B R A R Y    HANDLING       */\n     /********************************************/\n     MEMBER = TRANSLATE(MEMBER,'{','\u00a2');\n     CALL $OPEN;\n\n     IF REASM02_PRIMARY='M' | CSECT = '' THEN DO;\n L_ESD: CSECT = REASESD(ESD_ARRAY, DIM_ESD_ARRAY);\n        ESDLOOP = '1'B;\n        IF CSECT = '........' THEN DO;\n           ESDLOOP = '0'B;\n           CSECT = ''; GOTO L_AGAIN;\n        END;\n        CALL ISPLINK ('VREPLACE', 'CSECT ', BIN(8,31), CSECT);\n     END;\n     MEMOUT = CSECT;\n\n     CALL $CSECT;\n\n     IF ESDID = 0 THEN DO;       /* CSECT WAS NOT FOUND OR TOO LONG */\n        IF TEXTLEN = 0 THEN\n           CALL ISPLINK('SETMSG ', 'REAS062 ');\n        ELSE\n           CALL ISPLINK('SETMSG ', 'REAS063 ');\n        GOTO L_AGAIN;\n     END;\n\n     $REM   ='0'B;\n     CALL   $INITDSC;\n %PAGE;\n\n     IF DSRG=PO | DSRG=POU THEN DO;\n        MEMSAVE = CSECT;\n        CALL $REALLOC(SAVE,DSNSAVE,MEMSAVE,'');\n     END;\n\n     LINE_C  =    0;\n     OFFSET  =    0;\n     PENDING = '0'B;\n     $FIND   = '0'B;\n     #FIND   =   '';\n     BOFFSET =    0;\n     $CONF   = '0'B;\n     $CONFP  = '0'B;\n     LVL     = MAXLVL-3;\n\n $FORM_REASM02:\n     LOCVAR=SUBSTR(DSN,1,INDEX(DSN,' ')-1);\n     LOCVAR=LOCVAR || '(' || MEMBER || ' ';\n     LOCVAR=SUBSTR(LOCVAR,1,INDEX(LOCVAR,' ')-1);\n     LOCVAR=LOCVAR || ',' || CSECT  || ' ';\n     LOCVAR=SUBSTR(LOCVAR,1,INDEX(LOCVAR,' ')-1);\n     LOCVAR=LOCVAR || ') LEN=' || SUBSTR($BH(TEXTLEN),3);\n     REASM02_DSN = LOCVAR;\n\n     IV = ' ';\n     #CUR(ZZCMD, 1);\n     REASM02_PRIMARY = '';\n\n $SHOW_LOOP:\n     DO WHILE(IV \u00ac= 'PF03');\n        CALL $CLEAR_SCR;\n        CALL $SHOW;\n     END;\n\n     IF $CONF & \u00ac$CONFP THEN DO;\n        IV              = ' ';\n        $CONFP          = '1'B;\n        CALL ISPLINK ('SETMSG ', 'REAS001 ');  /* CONFIRM END */\n        REASM02_PRIMARY = '';\n        GOTO $SHOW_LOOP;\n     END;\n     $CONF = '0'B;\n     CALL FREETEXT();\n     IF ESDLOOP THEN DO;\n       @@FREE_LIST(RLD);\n       J = REASLOA('CLOSE', '', '', '', '', '');\n       J = REASLOA('OPEN',  '', '', '', '', '');\n       GOTO L_ESD;\n     END;\n     GOTO L_AGAIN;\n\n\n %PAGE;\n /*********************************************************************/\n /*  SCAN COMMAND SUBROUTINE                                          */\n /*********************************************************************/\n $CMD:\n     PROC (PTR,IP);\n     DCL  LINE      CHAR(80),\n          LABEL     CHAR(8)  DEF LINE,\n          OPNAME    CHAR(6)  DEF LINE POS(10),\n          OPERANDS  CHAR(50) DEF LINE POS(16),\n          P         PTR,\n          #P        BIN FIXED(31) BASED(ADDR(P)),\n          PTR       BIN FIXED(31),\n          IP        BIN FIXED,\n          QH        CHAR(1),\n          #NOPR     CHAR(1),\n          #HEX      CHAR(64) INT STATIC INIT(\n 'X''0''X''1''X''2''X''3''X''4''X''5''X''6''X''7''X''8''X''9''X''A''X''B\n ''X''C''X''D''X''E''X''F'''),\n          $HEX(0:15) CHAR(4) DEF #HEX,\n          (B1,B2)   BIT(16) ALIGNED,\n          (I,J,K)   BIN FIXED;\n\n\n     P        = ADDRTEXT();\n     #CMD_PTR = PTR+#P+2;\n     LINE     = ' ';\n     #COM     = '';\n     UNSPEC(#NOPR)='00000111'B;\n     GLOBAL_IP = IP;    /* FOR EX IN $ADDR */\n\n     B1='00000000'B || RR1.CODE;    /* 00XX */\n     B2=S2.CODE;                    /* XXXX */\n\n     IF B1 = '0000000010100111' |     /* A7 - RI FORMAT  */\n        B1 = '0000000010100101' |     /* A5 - RI FORMAT  */\n        B1 = '0000000011000000'       /* C0 - RIL FORMAT */\n        THEN\n        B1 = RI.CODE || RI.CODE1 || '0000'B;\n\n     IF B1 = '0000000011100011' |     /* E3 - RXY FORMAT */\n        B1 = '0000000011101011' |     /* EB - SIY FORMAT */\n        B1 = '0000000011101100' |     /* EC - RIE FORMAT */\n        B1 = '0000000011101101'       /* ED - RXE FORMAT */\n        THEN\n        B1 = RXY.CODE || RXY.CODE1;\n\n     J = -1;\n CMD:DO I=1 TO CMDNUM(OS);\n        SELECT (@(I).F);\n          WHEN ($S2,$SSE,$RRE,$RRF,$RRE1,$E) DO;\n             IF B2 = @(I).V THEN DO;\n                J = I;\n                GOTO CONTCMD;\n             END;\n          END;\n          OTHER DO;\n             IF  B1 = @(I).V THEN DO;\n                J = I;\n                GOTO CONTCMD;\n             END;\n          END;\n        END;\n CONTCMD:;\n     END CMD;\n     IF J = -1 THEN\n        GOTO $RETURN_FROM_$CMD;\n\n     I = J;\n     IF PC=0 & I>=PACKMIN  & I<=PACKMAX  THEN GOTO $RETURN_FROM_$CMD;\n     IF FC=0 & I>=FLOATMIN & I<=FLOATMAX THEN GOTO $RETURN_FROM_$CMD;\n     IF @(I).V \u00ac= 0 THEN DO;\n        #FORWARD=0;\n        OPNAME=@.N(I);\n        IF $NOOP THEN GOTO $RETURN_FROM_$CMD;\n\n        SELECT (@(I).F);\n          WHEN ($RR1) DO;\n            OPERANDS=$REGS(BIN(RR1.R1,15)) || ',' ||\n                     $REGS(BIN(RR1.R2,15));\n            SELECT (OPNAME);\n              WHEN ('NR','OR') DO;\n                IF  RR1.R1 = RR1.R2 THEN\n                  #COM=#COM || ' ' || 'TEST ' || $REGS(RR1.R1);\n                ELSE DO;\n                  IF OPNAME='NR' THEN LOCVAR = ' & ';\n                  ELSE                LOCVAR = ' | ';\n                  #COM=#COM || ' ' || $REGS(RR1.R1) || '=' ||\n                       $REGS(RR1.R1) || LOCVAR || $REGS(RR1.R2);\n                END;\n              END;\n              WHEN ('SR','SLR','XR') DO;\n                IF  RR1.R1 = RR1.R2 THEN\n                  #COM=#COM || ' ' || $REGS(RR1.R1) || '=0';\n                ELSE\n                  IF OPNAME='SR' | OPNAME='SLR' THEN\n                    #COM=#COM || ' ' || $REGS(RR1.R1) || '=' ||\n                         $REGS(RR1.R1) || '-' || $REGS(RR1.R2);\n                  ELSE\n                    #COM=#COM || ' ' || $REGS(RR1.R1) || '=' ||\n                         $REGS(RR1.R1) || ' X ' || $REGS(RR1.R2);\n              END;\n              WHEN ('AR','ALR') DO;\n                IF  RR1.R1 = RR1.R2 THEN\n                  #COM=#COM || ' ' || $REGS(RR1.R1) ||\n                         '*2';\n                ELSE\n                  #COM=#COM || ' ' || $REGS(RR1.R1) || '=' ||\n                       $REGS(RR1.R1) || '+' || $REGS(RR1.R2);\n              END;\n              WHEN ('LR')\n                #COM=#COM || ' ' || $REGS(RR1.R1) || '=' ||\n                     $REGS(RR1.R2);\n              WHEN ('LNR')\n                #COM=#COM || ' ' || $REGS(RR1.R1) || '= -' ||\n                     $REGS(RR1.R2);\n              WHEN ('LPR')\n                #COM=#COM || ' ' || $REGS(RR1.R1) || '= +' ||\n                     $REGS(RR1.R2);\n              WHEN ('MR')\n                #COM=#COM || ' ' || $REGS(RR1.R1) || $REGS(RR1.R1+1) ||\n                     '=' || $REGS(RR1.R1+1) || '*' || $REGS(RR1.R2);\n              WHEN ('DR') DO;\n                IF RR1.R1 <=14 THEN\n                #COM=#COM || ' ' || $REGS(RR1.R1) || '=REMNDR ' ||\n                     $REGS(RR1.R1+1) || '=DIVDR';\n              END;\n              WHEN ('BCTR') DO;\n                IF RR1.R2=0 THEN\n                   #COM=#COM || ' ' || $REGS(RR1.R1) || '=' ||\n                        $REGS(RR1.R1) || '-1';\n              END;\n              WHEN ('BALR') DO;\n                IF RR1.R1=14 & RR1.R2=15 THEN\n                   #COM=#COM || ' CALL ';\n              END;\n              WHEN ('MVCL')\n                #COM=#COM || ' \u00a2' || $REGS(RR1.R1) || '! <-- \u00a2' ||\n                 $REGS(RR1.R2) || '! LEN(' || $REGS(RR1.R1+1) || ')';\n              WHEN ('CLCL')\n                #COM=#COM || ' COMP ' || $REGS(RR1.R1) || ' & ' ||\n                 $REGS(RR1.R2) || ' LEN(' || $REGS(RR1.R1+1) || ')';\n              OTHER;\n            END;\n            IF $XREF THEN DO;\n               CALL $PUTXRF($REGS(BIN(RR1.R1,15)));\n               CALL $PUTXRF($REGS(BIN(RR1.R2,15)));\n            END;\n          END;\n          WHEN ($RR2) DO;\n            I=BIN(RR2.OPER,15);\n            OPERANDS=$DIGIT(I);\n            IF OPNAME='SVC' & I <= HBOUND(SVCTABLE,1) THEN DO;\n               LOCVAR=SVCTABLE(I);\n               IF LOCVAR\u00ac='' THEN DO;\n                  #COM=LOCVAR || ' ' || #COM;\n               END;\n            END;\n          END;\n          WHEN ($RR3) DO;\n            OPERANDS=$HEX(BIN(RR3.MASK,15)) || ',' ||\n                     $REGS(BIN(RR3.R2,15));\n            IF $XREF THEN\n               CALL $PUTXRF($REGS(BIN(RR3.R2,15)));\n            IF  OPNAME='BCR' THEN DO;\n               IF OPPREV\u00ac='' & SUBSTR(OPPREV,1,1)='C' THEN\n                  LOCVAR=$EMNEM1(BIN(RR3.MASK,15));   /* COMPARING */\n               ELSE\n                  LOCVAR=$EMNEM(BIN(RR3.MASK,15));\n               IF LOCVAR\u00ac='' THEN DO;\n                  OPNAME=LOCVAR||'R';\n                  OPERANDS=$REGS(BIN(RR3.R2,15));\n               END;\n               IF OPNAME='BR' & OPERANDS='R14' THEN DO;\n                  IF #COM\u00ac='' THEN #COM = #COM || ' ' || 'RETURN';\n                  ELSE             #COM = 'RETURN';\n               END;\n               IF OPNAME='NOPR' & OPERANDS='R0' &\n                  SUBSTRTEXT(PTR+3,1)\u00ac=#NOPR THEN DO;\n                  OPNAME='CNOP';\n                  SELECT (MOD(#OFFSET+2,8));\n                  WHEN (0) OPERANDS='0,4';\n                  WHEN (2) OPERANDS='2,8';\n                  WHEN (4) OPERANDS='0,4';\n                  WHEN (6) OPERANDS='6,8';\n                  OTHER\n                    OPNAME='NOPR';\n                  END;\n               END;\n            END;\n          END;\n          WHEN ($RRE) DO;\n            OPERANDS=$REGS(BIN(RRE.R1,15)) || ',' ||\n                     $REGS(BIN(RRE.R2,15));\n            IF RRE.RSRV\u00ac=0 THEN\n               $ORGIMM=$IMM(RRE.RSRV);\n          END;\n          WHEN ($RRF) DO;\n            OPERANDS=$REGS(BIN(RRF.R1,15)) || ',' ||\n                     $REGS(BIN(RRF.R3,15)) || ',' ||\n                     $REGS(BIN(RRF.R2,15));\n          END;\n          WHEN ($RRE1) DO;\n            OPERANDS=$REGS(BIN(RRE1.R1,15));\n            IF RRE1.RSRV\u00ac=0 THEN\n               $ORGIMM=$IMM(RRE1.RSRV);\n          END;\n          WHEN ($R) DO;\n            OPERANDS=$REGS(BIN(R.R1,15));\n            IF OPNAME='SPM' & BIN(R.RSRV,15) \u00ac= 0 THEN\n               #COM = #COM || ' !!! SECOND NIBBLE IS NONZERO !!!';\n            IF $XREF THEN\n               CALL $PUTXRF($REGS(BIN(R.R1,15)));\n          END;\n          WHEN ($RS1) DO;\n            PUT STRING(OPERANDS) EDIT\n                    ($REGS(BIN(RS1.R1,15)),',',\n                     $REGS(BIN(RS1.R3,15)),',',\n                     $ADDR(RS1.B2,RS1.D2,0,'0'B,0,'0'B,OPNAME,PTR))\n                     (A,A,A,A,A);\n            SELECT (OPNAME);\n            WHEN ('LM','STM') DO;\n               SELECT;\n                 WHEN (RS1.R1=RS1.R3) II=1;\n                 WHEN (RS1.R3>RS1.R1) II=RS1.R3-RS1.R1+1;\n                 OTHER                II=15-RS1.R1+1+RS1.R3+1;\n               END;\n               IF II>=1 & II<=16 THEN\n                  #COM=#COM || ' PROCESS ' || $NUMBER(II) || ' REGS';\n            END;\n            WHEN ('LCTL')\n               #COM = #COM || ' ' || $CTLREG(RS1.R1);\n            WHEN ('BXH') DO;\n              I=RS1.R3;\n              IF MOD(I,2)=0 THEN\n                 I=I+1;\n              #COM=#COM || ' ' || $REGS(RS1.R1) || '=' ||\n                   $REGS(RS1.R1) || '+' || $REGS(RS1.R3) || ' ' ||\n                   $REGS(RS1.R1) || '>' || $REGS(I);\n            END;\n            WHEN ('BXLE') DO;\n              I=RS1.R3;\n              IF MOD(I,2)=0 THEN\n                 I=I+1;\n              #COM=#COM || ' ' || $REGS(RS1.R1) || '=' ||\n                   $REGS(RS1.R1) || '+' || $REGS(RS1.R3) || ' ' ||\n                   $REGS(RS1.R1) || '<=' || $REGS(I);\n            END;\n            WHEN ('CS')\n              #COM='IF ' || $REGS(RS1.R1) || '=OP ST ' || $REGS(RS1.R3)\n                   || ' OP';\n            OTHER;\n            END;\n            IF $XREF THEN\n               CALL $PUTXRF($REGS(BIN(RS1.R1,15)));\n            IF $XREF THEN\n               CALL $PUTXRF($REGS(BIN(RS1.R3,15)));\n          END;\n          WHEN ($RS2) DO;\n            LOCVAR   = $REGS(BIN(RS2.R1,15))   || ',' ||\n                       $HEX (BIN(RS2.MASK,15)) || ',' ||\n                       $ADDR(RS2.B2,RS2.D2,0,'0'B,0,'0'B,OPNAME,PTR);\n            OPERANDS = LOCVAR;\n          END;\n\n          WHEN ($RX) DO;\n            IF $AUTO          &  OPNAME = 'L' &\n               RX.B2  = '0'B  &  RX.X2  = '0'B\n               THEN DO;\n               IF BIN(RX.D2,15)\u00ac=16 THEN\n                  CALL $USING_PSA(PTR);\n               ELSE DO;\n                  #COM = 'LOAD CVT POINTER';\n                  IF  RX.R1\u00ac=0 THEN CALL $USING_CVT(PTR+4,RX.R1);\n               END;\n            END;\n\n            PUT STRING(OPERANDS) EDIT\n                    ($REGS(BIN(RX.R1,15)),',',\n                     $ADDR(RX.B2,RX.D2,RX.X2,'1'B,0,'0'B,OPNAME,PTR))\n                     (A,A,A);\n            SELECT (OPNAME);\n            WHEN ('LA') DO;\n               SELECT;\n               WHEN (RX.B2=0 & RX.X2=0)\n                  #COM=#COM || ' ' || $REGS(RX.R1) || '=' ||\n                       $DIGIT(RX.D2);\n               WHEN ((RX.R1=RX.B2 & RX.X2=0)|(RX.R1=RX.X2 & RX.B2=0))\n                  IF RX.D2\u00ac=0 THEN\n                     #COM=#COM || ' ' || $REGS(RX.R1) || '=' ||\n                          $REGS(RX.R1) || '+' || $DIGIT(RX.D2);\n                  ELSE\n                     #COM=#COM || ' CLEAR HI BYTE/BIT';\n               OTHER;END;\n            END;\n            WHEN ('SLDL','SLDA','SRDL','SRDA') DO;\n               PUT STRING(OPERANDS) EDIT\n                       ($REGS(BIN(RX.R1,15)),',',\n                        $ADDR(RX.B2,RX.D2,0,'0'B,0,'0'B,OPNAME,PTR))\n                        (A,A,A);\n            END;\n            WHEN ('SLL','SLA') DO;\n               PUT STRING(OPERANDS) EDIT\n                       ($REGS(BIN(RX.R1,15)),',',\n                        $ADDR(RX.B2,RX.D2,0,'0'B,0,'0'B,OPNAME,PTR))\n                        (A,A,A);\n               IF RX.B2=0 THEN DO;\n                 SELECT (RX.D2);\n                 WHEN (16)\n                    #COM=#COM || ' ' || 'SHIFT ' || $REGS(RX.R1) ||\n                         ' LEFT 2 BYTES';\n                 WHEN (24)\n                    #COM=#COM || ' ' || 'SHIFT ' || $REGS(RX.R1) ||\n                         ' LEFT 3 BYTES';\n                 OTHER\n            /*      #COM=#COM || ' ' || $REGS(RX.R1) || '=' ||\n                         $REGS(RX.R1) || '*' || $DIGIT(2**RX.D2);    */\n                    #COM=#COM;\n                 END;\n               END;\n            END;\n            WHEN ('SRL','SRA') DO;\n               PUT STRING(OPERANDS) EDIT\n                       ($REGS(BIN(RX.R1,15)),',',\n                        $ADDR(RX.B2,RX.D2,0,'0'B,0,'0'B,OPNAME,PTR))\n                        (A,A,A);\n               IF RX.B2=0 THEN DO;\n                 SELECT (RX.D2);\n                 WHEN (16)\n                    #COM=#COM || ' ' || 'SHIFT ' || $REGS(RX.R1) ||\n                         ' RIGHT 2 BYTES';\n                 WHEN (24)\n                    #COM=#COM || ' ' || 'SHIFT ' || $REGS(RX.R1) ||\n                         ' RIGHT 3 BYTES';\n                 OTHER\n                    #COM=#COM || ' ' || $REGS(RX.R1) || '=' ||\n                         $REGS(RX.R1) || '/' || $DIGIT(2**RX.D2);\n                 END;\n               END;\n            END;\n            OTHER;\n            END;\n          END;\n\n          WHEN ($RM) DO;\n            PUT STRING(OPERANDS) EDIT\n                    ($HEX(BIN(RM.MASK,15)),',',\n                     $ADDR(RM.B2,RM.D2,RM.X2,'1'B,0,'0'B,OPNAME,PTR))\n                     (A,A,A);\n            IF OPNAME='BC' THEN DO;\n               IF OPPREV\u00ac='' & SUBSTR(OPPREV,1,1)='C' THEN\n                  LOCVAR=$EMNEM1(BIN(RM.MASK,15));   /* COMPARING */\n               ELSE\n                  LOCVAR=$EMNEM(BIN(RM.MASK,15));\n               IF LOCVAR\u00ac='' THEN DO;\n                  OPNAME=LOCVAR;\n                  OPERANDS=\n                    $ADDR(RM.B2,RM.D2,RM.X2,'1'B,0,'0'B,OPNAME,PTR);\n               END;\n            END;\n          END;\n\n          /* 2006 */\n          WHEN ($SIY) DO;\n            PUT STRING(OPERANDS) EDIT\n                ($ADDR(SIY.B2,SIY.DH2||SIY.DL2,0,\n                      '0'B,0,'0'B,OPNAME,PTR),\n                ',',$IMM(SIY.$I))\n                (A,A,A);\n          END;\n\n          WHEN ($RXY) DO;\n            PUT STRING(OPERANDS) EDIT\n             ($REGS(BIN(RXY.R1,15)),',',\n              $ADDR(RXY.B2,RXY.DH2||RXY.DL2,RXY.X2,\n                           '1'B,0,'0'B,OPNAME,PTR)  )\n              (A,A,A);\n          END;\n\n          WHEN ($RXY1) DO;\n            PUT STRING(OPERANDS) EDIT\n             ($REGS(BIN(RXY1.R1,15)),',',\n              $REGS(BIN(RXY1.R3,15)),',',\n              $ADDR(RXY1.B2,RXY1.DH2||RXY1.DL2,'0'B,\n                           '1'B,0,'0'B,OPNAME,PTR)  )\n              (A,A,A);\n          END;\n\n          WHEN ($RXE) DO;\n            OPERANDS =\n             $REGS(BIN(RXE.R1,15)) || ',' ||\n             $ADDR(RXE.B2,RXE.D2,RXE.X2,'1'B,0,'0'B,OPNAME,PTR);\n          END;\n\n          WHEN ($RXF) DO;\n            OPERANDS =\n             $REGS(BIN(RXF.R1,15)) || ',' ||\n             $REGS(BIN(RXF.R3,15)) || ',' ||\n             $ADDR(RXF.B2,RXF.D2,'0'B,'1'B,0,'0'B,OPNAME,PTR);\n          END;\n\n          WHEN ($RSY) DO;\n            OPERANDS =\n             $REGS(BIN(RSY.R1,15)) || ',' ||\n             $REGS(BIN(RSY.R3,15)) || ',' ||\n             $ADDR(RSY.B2,SIY.DH2||RSY.DL2,0,'0'B,0,'0'B,OPNAME,PTR);\n          END;\n\n          WHEN ($RSY1) DO;\n            OPERANDS =\n             $REGS(BIN(RSY1.R1,15)) || ',' ||\n             $HEX(BIN(RSY1.MASK,15)) || ',' ||\n             $ADDR(RSY1.B2,SIY.DH2||RSY1.DL2,0,'0'B,0,'0'B,OPNAME,PTR);\n          END;\n\n          WHEN ($RSL)\n            OPERANDS =\n             $ADDR(RSL.B1,RSL.D1,0,'0'B,RSL.L1,'1'B,OPNAME,PTR);\n\n          WHEN ($RI) DO;\n            PUT STRING(LOCVAR) EDIT(RI.I2)(F(6));\n            LOCVAR = SUBSTR(LOCVAR,VERIFY(LOCVAR,' '));\n            PUT STRING(OPERANDS) EDIT\n                ($REGS(BIN(RI.R1,15)),',',LOCVAR)(A,A,A);\n          END;\n\n          WHEN ($RIM) BEGIN;\n            DCL LABNAME CHAR(16) VAR;\n            LABNAME = $JUMPOFF(RIM.I2, PTR);\n\n            OPERANDS = $HEX(BIN(RIM.MASK,15)) || ',' || LABNAME;\n            IF OPPREV\u00ac='' & SUBSTR(OPPREV,1,1)='C' THEN\n               LOCVAR=$JMNEM1(BIN(RIM.MASK,15));   /* COMPARING */\n            ELSE\n               LOCVAR=$JMNEM(BIN(RIM.MASK,15));\n\n            IF LOCVAR\u00ac='' THEN DO;\n               OPNAME   = LOCVAR;\n               OPERANDS = LABNAME;\n            END;\n          END;\n\n          WHEN ($RIM1) BEGIN;\n             OPERANDS = $REGS(BIN(RIM1.R1,15)) || ',' ||\n                 $JUMPOFF(RIM1.I2, PTR);\n             IF OPNAME = 'BRCT' THEN OPNAME='JCT';\n          END;\n\n          WHEN ($RIE) BEGIN;\n             OPERANDS = $REGS(BIN(RIE.R1,15)) || ',' ||\n                 $REGS(BIN(RIE.R3,15)) || ',' ||\n                 $JUMPOFF(RIE.I2, PTR);\n          END;\n\n          WHEN ($RSI) BEGIN;\n             OPERANDS = $REGS(BIN(RSI.R1,15)) || ',' ||\n                 $REGS(BIN(RSI.R3,15)) || ',' ||\n                 $JUMPOFF(RSI.I2, PTR);\n          END;\n\n          WHEN ($RIL) BEGIN;\n            OPERANDS = $REGS(BIN(RIL.R1,15)) || ',' ||\n                 $JUMPOFF(RIL.I2, PTR);\n          END;\n\n          WHEN ($RILM) DO;\n            OPERANDS = $HEX(BIN(RILM.MASK,15)) || ',' ||\n                  $JUMPOFF(RILM.I2, PTR);\n          END;\n\n          WHEN ($E) DO;\n\n          END;\n\n          WHEN ($SI) DO;\n            QH=SUBSTR(GOODA,BIN(SI.$I,15)+1,1);\n            SELECT (OPNAME);\n              WHEN ('MVI','CLI') DO;\n                IF QH\u00ac=HIGH(1) THEN #COM = 'C''' || QH || '''' || #COM;\n              END;\n              WHEN ('OI','NI','XI','TM') DO;\n                UNSPEC(QH) = UNSPEC(SI.$I);\n                #COM = $BITSTR(QH);\n              END;\n              WHEN ('STOSM','STNSM') DO;\n                DO I=1 TO 8;\n                 IF SUBSTR(UNSPEC(SI.$I),I,1) = '1'B & OPNAME='STOSM'\n                    THEN #COM = #COM || ' ' || $PSWMASK(I);\n                 IF SUBSTR(UNSPEC(SI.$I),I,1) = '0'B & OPNAME='STNSM'\n                    THEN #COM = #COM || ' ' || $PSWMASK(I);\n                END;\n              END;\n              OTHER;\n            END;\n            PUT STRING(OPERANDS) EDIT\n                ($ADDR(SI.B2,SI.D2,0,'0'B,0,'0'B,OPNAME,PTR),\n                ',',$IMM(SI.$I))\n                (A,A,A);\n            IF OPNAME='NI' THEN DO;\n               I  = SI.$I;\n               IF I=255-01  |  I=255-02  | I=255-04 | I=255-08  |\n                  I=255-16  |  I=255-32  | I=255-64 | I=255-128 THEN DO;\n                  ICH = 255 - I;\n                  PUT STRING(OPERANDS) EDIT\n                     ($ADDR(SI.B2,SI.D2,0,'0'B,0,'0'B,OPNAME,PTR),\n                     ',', 'X''FF''-', $IMM(UNSPEC(CH)))\n                     (A,A,A,A);\n               END;\n            END;\n          END;\n          WHEN ($S1) DO;\n            IF S1.RSRV\u00ac=0 THEN\n               $ORGIMM=$IMM(S1.RSRV);\n            OPERANDS=$ADDR(S1.B2,S1.D2,0,'0'B,0,'0'B,OPNAME,PTR);\n          END;\n          WHEN ($S2) DO;\n            OPERANDS=$ADDR(S1.B2,S1.D2,0,'0'B,0,'0'B,OPNAME,PTR);\n            SELECT (OPNAME);\n            WHEN ('SPKA') DO;\n              IF S1.B2=0 & S1.D2<16 THEN\n                #COM = #COM || ' ' || 'SET EXTKEY=' || $KEYNAME(S1.D2);\n            END;\n            WHEN ('IPK') DO;\n              #COM = #COM || ' ' || 'INSERT PSW KEY INTO R2';\n            END;\n            OTHER;\n            END;\n          END;\n          WHEN ($SS1)\n            PUT STRING(OPERANDS) EDIT\n             ($ADDR(SS1.B1,SS1.D1,0,'0'B,SS1.LEN1,'1'B,OPNAME,PTR),',',\n              $ADDR(SS1.B2,SS1.D2,0,'0'B,SS1.LEN2,'1'B,OPNAME,PTR))\n             (A,A,A);\n          WHEN ($SS2) DO;\n            PUT STRING(OPERANDS) EDIT\n             ($ADDR(SS2.B1,SS2.D1,0,'0'B,SS2.LEN,'1'B,OPNAME,PTR),',',\n              $ADDR(SS2.B2,SS2.D2,0,'0'B,0,'0'B,OPNAME,PTR))\n              (A,A,A);\n            SELECT (OPNAME);\n              WHEN ('XC','OC','NC') DO;\n                IF OPNAME = 'XC' THEN LOCVAR='CLEAR ';\n                ELSE                  LOCVAR='TEST ';\n                IF (SS2.B1=SS2.B2) & (SS2.D1=SS2.D2) THEN\n                   #COM = #COM || ' ' || LOCVAR ||\n                   $ADDR(SS2.B2,SS2.D2,0,'0'B,0,'0'B,OPNAME,PTR);\n              END;\n              OTHER;\n            END;\n          END;\n          WHEN ($SS3)\n            PUT STRING(OPERANDS) EDIT\n             ($ADDR(SS3.B1,SS3.D1,0,'0'B,SS3.LEN,'1'B,OPNAME,PTR),',',\n              $ADDR(SS3.B2,SS3.D2,0,'0'B,0,'0'B,OPNAME,PTR),',',\n              $HEX(SS3.I3))\n              (A,A,A,A,A);\n          WHEN ($SS4)\n            PUT STRING(OPERANDS) EDIT\n             ($ADDR(SS4.B1,SS4.D1,SS4.R1,'1'B,0,'1'B,OPNAME,PTR),',',\n              $ADDR(SS4.B2,SS4.D2,0,     '0'B,0,'0'B,OPNAME,PTR),',',\n              $REGS(BIN(SS4.R3,15)))\n              (A,A,A,A,A);\n          WHEN ($SSE)\n            PUT STRING(OPERANDS) EDIT\n             ($ADDR(SSE.B1,SSE.D1,0,'0'B,0,'0'B,OPNAME,PTR),',',\n              $ADDR(SSE.B2,SSE.D2,0,'0'B,0,'0'B,OPNAME,PTR))\n              (A,A,A);\n          OTHER DO;\n            PUT SKIP DATA(SS2,@(I));\n            CALL REASLST;\n            SIGNAL ERROR;\n            STOP;\n          END;\n        END;\n     END;\n\n $RETURN_FROM_$CMD:\n     REASM02_LINE(IP).LABEL=SUBSTR(LINE,1,8);\n     REASM02_LINE(IP).OPER=SUBSTR(LINE,10,5);\n     REASM02_LINE(IP).OPERANDS=SUBSTR(LINE,16);\n     IF REASM02_LINE(IP).OPER \u00ac= '' THEN     /* COMMAND MADE ? */\n        CALL $PUTOBJ(PTR,CMDLEN(CMDDEF),IP);\n     OPPREV=REASM02_LINE(IP).OPER;\n END $CMD;\n %SKIP;\n /*********************************************************************/\n /*  DETERMINE NAME BY BASE/OFFST/INDEX                               */\n /*********************************************************************/\n $ADDR:\n     PROC(#B,#D,#X,#FX,#LEN,#FLEN,OPNAME,PTR)\n          RETURNS(CHAR(50) VAR);\n     DCL  (#B,#X)     BIT(*) ALIGNED,\n          (B,X)       BIN FIXED,\n          #D          BIT(*) ALIGNED,\n          D           BIN FIXED,\n          #LEN        BIT(*) ALIGNED,\n          LEN         BIN FIXED,\n          #FX         BIT(1) ALIGNED,\n          FX          BIT(1) ALIGNED,\n          #FLEN       BIT(1) ALIGNED,\n          FLEN        BIT(1) ALIGNED,\n          OPNAME      CHAR(*),\n          PTR         BIN FIXED(31),\n          (I,J,II,JJ) BIN FIXED(31),\n          #I          CHAR(4) BASED(ADDR(I)),\n          (P,Q)       PTR,\n          #P          BIN FIXED(31) BASED(ADDR(P)),\n          N           CHAR(8) VAR,\n          ($FB,$FX)   BIT(1) INIT('0'B) ALIGNED,\n          #VAL        BIN FIXED(31),\n          VAL         CHAR(4) BASED(ADDR(#VAL)),\n          #HVAL       BIN FIXED(15),\n          HVAL        CHAR(2) BASED(ADDR(#HVAL)),\n          1 XLINE     LIKE REASM02_LINE,\n          IP          BIN FIXED,\n          XCMD        PTR,\n          C1          CHAR(50) VAR;\n\n     B      = BIN(#B,15);\n     X      = BIN(#X,15);\n     D      = BIN(#D,15);\n     FX     = #FX;\n     FLEN   = #FLEN;\n     LEN    = BIN(#LEN,15);\n\n     C1=$DIGIT(D);\n     IF FLEN | (FX & X\u00ac=0) | B\u00ac=0 THEN DO;\n        C1 = C1 || '(';\n        IF FLEN THEN C1=C1 || $DIGIT(LEN+1) || ',';\n        IF FX THEN DO;\n           IF X\u00ac= 0 THEN DO;\n              C1  = C1 || $REGS(X);\n              $FX = '1'B;\n           END;\n           IF B\u00ac=0 THEN DO;\n              C1  = C1 || ',' || $REGS(B);\n              $FB = '1'B;\n           END;\n        END;\n        ELSE DO;\n           IF B\u00ac=0 THEN DO;\n              C1  = C1 || $REGS(B);\n              $FB = '1'B;\n           END;\n           ELSE\n              C1 = SUBSTR(C1,1,LENGTH(C1)-1);\n        END;\n        C1 = C1 || ')';\n     END;\n     /**********************************/\n     /* TRY MAKE SYMBOLIC NAME         */\n     /**********************************/\n     USING_PTR=USING_START;\n NEW_USING:\n     P=NULL;\n     DO WHILE(USING_PTR\u00ac=NULL);\n        IF (USING.REG  = B             &\n            PTR       >= USING.PLACE   &\n            PTR       <  USING.PLACE+USING.LENGTH)   |\n           (FX & USING.REG=X           &\n            PTR       >= USING.PLACE   &\n            PTR       <  USING.PLACE+USING.LENGTH)   THEN DO;\n            IF P\u00ac=NULL THEN DO;\n               IF P->USING.PLACE < USING.PLACE THEN /* NEW IS LOWER */\n                  P=USING_PTR;                      /* 08.12.87 */\n            END;\n            ELSE  P=USING_PTR;\n        END;\n        USING_PTR=USING.NEXT;\n     END;\n\n #TEST_USING_AGAIN:\n     IF P\u00ac=NULL THEN DO;\n        USING_PTR=P;\n                                         /* 14.09.88 */\n        P=USING_START;\n        DO WHILE(P\u00ac=NULL);\n           IF P->USING.REG   = USING.REG      &\n              P->USING.PLACE > USING.PLACE    &\n              P->USING.PLACE <=PTR            THEN DO;\n              P=NULL;\n              GOTO #TEST_USING_AGAIN;\n           END;\n           P = P->USING.NEXT;\n        END;\n\n        IF USING.REG=X & FX THEN  FX, $FX = '0'B;\n        ELSE                      $FB = '0'B;\n        IF USING.NAME='' THEN DO;         /* BASE */\n           I = USING.OFF + D;             /* ABS DISPL */\n           J = I - PTR;\n           IF ((J>=0) & ( J<=#ABSA)) |\n              ((J<=0) & (-J<=#ABSB)) THEN DO;\n              LOCVAR = ''; IF J>=0 THEN LOCVAR = '+';\n              C1='*' || LOCVAR || $DIGIT(J);\n           END;\n           ELSE DO;\n              LOCVAR = #I;\n              C1     = $NAME(LOCVAR);\n              IF B\u00ac=0 THEN  CALL $INITLAB(C1,I,B,'0'B,PTR);\n              ELSE          CALL $INITLAB(C1,I,X,'0'B,PTR);\n              IF $XREF THEN CALL $PUTXRF(C1);\n           END;\n\n           SELECT (OPNAME);\n             WHEN ('EX') DO;\n               IP = GLOBAL_IP;\n               XLINE = REASM02_LINE(IP), BY NAME;\n               XCMD  = CMD_PTR;\n               CALL $CMD(I,IP);\n               IF REASM02_LINE(IP).OPER \u00ac= '' THEN\n                  #COM = REASM02_LINE(IP).OPER     ||\n                         REASM02_LINE(IP).OPERANDS;\n               ELSE\n                  #COM = #COM || '/' || $CH(SUBSTRTEXT(I+1,6));\n               REASM02_LINE(IP) = XLINE, BY NAME;\n               CMD_PTR = XCMD;\n             END;\n             WHEN ('L') DO;\n               IF I <= TEXTLEN THEN DO;\n                  VAL     = SUBSTRTEXT(I+1,4);\n                  LOCVAR  = '=X''' || $CH(VAL)     || '''' || '; ' ||\n                            '=F''' || $DIGIT(#VAL) || '''';\n                  P       = DSC_PTR;\n                  CALL $FINDDSC(I);\n                  Q       = DSC_PTR;\n                  DSC_PTR = P;\n                  SELECT (Q->DSC.TYPE);\n                  WHEN ('A') DO;\n                    IF Q->DSC.LENGTH=4 THEN\n                       #COM='=A(' ||\n                         $NAME(SUBSTRTEXT(Q->DSC.OFF+1,4)) || ')';\n                  END;\n                  WHEN ('V') DO;\n                    IF Q->DSC.LENGTH=4 THEN DO;\n                       LOCVAR = '';\n                       HVAL = SUBSTRTEXT(Q->DSC.OFF+3,2);\n                       IF #HVAL > 0 THEN LOCVAR='+' || $DIGIT(#HVAL);\n                       IF #HVAL < 0 THEN LOCVAR= $DIGIT(#HVAL);\n                       LOCVAR = $NEXTEL(Q->DSC.NAME) || LOCVAR;\n                       #COM='=V(' || LOCVAR || ')';\n                    END;\n                  END;\n                  OTHER DO;\n                    IF #COM\u00ac='' THEN #COM=#COM ||'/' || LOCVAR;\n                    ELSE             #COM=LOCVAR;\n                  END;\n                  END;\n               END;\n             END;\n             WHEN ('C','S','M','D','ST','STM','LM','LCTL','STCTL',\n                   'A','AL','CL','SL') DO;\n                IF MOD(I,4)=0 THEN DO;\n                   P = DSC_PTR;\n                   IF $AUTO THEN CALL $INCLUDE(I,4,'F');\n                   DSC_PTR = P;\n                END;\n                SELECT (OPNAME);\n                WHEN ('C','A','S','CL','AL','SL','M','D') DO;\n                  VAL     = SUBSTRTEXT(I+1,4);\n                  LOCVAR  = '=X''' || $CH(VAL)     || '''' || '; ' ||\n                            '=F''' || $DIGIT(#VAL) || '''';\n                  IF #COM\u00ac='' THEN #COM=#COM || '/' || LOCVAR;\n                  ELSE             #COM=LOCVAR;\n                END;\n                OTHER;\n                END;\n             END;\n             WHEN ('N','O','X') DO;\n               VAL     = SUBSTRTEXT(I+1,4);\n               LOCVAR  = '=X''' || $CH(VAL)     || '''' || '; ' ||\n                         '=F''' || $DIGIT(#VAL) || '''';\n               IF #COM\u00ac='' THEN #COM=#COM || '/' || LOCVAR;\n               ELSE             #COM=LOCVAR;\n             END;\n             WHEN ('LH','STH','MH','AH','SH','DH','CH') DO;\n                IF MOD(I,2)=0 THEN DO;\n                   P = DSC_PTR;\n                   IF $AUTO THEN CALL $INCLUDE(I,2,'H');\n                   DSC_PTR = P;\n                END;\n                HVAL=SUBSTRTEXT(I+1,2);\n                LOCVAR='=H''' || $DIGIT(#HVAL) || '''';\n                IF #COM\u00ac='' THEN #COM=#COM ||'/' || LOCVAR;\n                ELSE             #COM=LOCVAR;\n             END;\n\n             WHEN ('MVC','CLC','ED','EDMK') DO;\n               J = BIN(SS2.LEN+1,15);\n               IF I+J > TEXTLEN THEN J = TEXTLEN-I-1;\n               IF J < 0          THEN J = 0;\n               IF J > 255        THEN J = 255;\n               LOCVAR     = SUBSTRTEXT(I+1,J);\n               IF $CHARSTR(LOCVAR) THEN DO;\n                  IF J>20 THEN J=20;\n                  #COM = '=C''' ||     SUBSTRTEXT(I+1,J)  || '''';\n               END;\n               ELSE DO;\n                  IF J>10 THEN J=10;\n                  #COM = '=X''' || $CH(SUBSTRTEXT(I+1,J)) || '''';\n                  P = DSC_PTR;\n                  CALL $FINDDSC(I);\n                  Q = DSC_PTR;\n                  DSC_PTR = P;\n                  SELECT (Q->DSC.TYPE);\n                  WHEN ('A') DO;\n                    IF Q->DSC.LENGTH=4 THEN\n                       #COM='=A(' ||\n                         $NAME(SUBSTRTEXT(Q->DSC.OFF+1,4)) || ')';\n                  END;\n                  WHEN ('V') DO;\n                    IF Q->DSC.LENGTH=4 THEN DO;\n                       LOCVAR = '';\n                       HVAL = SUBSTRTEXT(Q->DSC.OFF+3,2);\n                       IF #HVAL > 0 THEN LOCVAR='+' || $DIGIT(#HVAL);\n                       IF #HVAL < 0 THEN LOCVAR= $DIGIT(#HVAL);\n                       LOCVAR = $NEXTEL(Q->DSC.NAME) || LOCVAR;\n                       #COM='=V(' || LOCVAR || ')';\n                    END;\n                  END;\n                  OTHER;\n                  END;\n               END;\n             END;\n\n             WHEN ('LPSW') DO;\n               #COM = '=X''' || $CH(SUBSTRTEXT(I+1,8)) || '''';\n             END;\n\n             WHEN ('BAL')\n               IF I > PTR THEN              #FORWARD = I;\n             WHEN ('B')\n               IF I > PTR THEN              #FORWARD = I;\n             WHEN ('BC')\n               IF RM.MASK=15 & I > PTR THEN #FORWARD = I;\n\n             OTHER;\n           END;\n\n $PUTLENX: IF (FX & X\u00ac=0) | FLEN THEN DO;\n              IF FLEN THEN C1=C1 || '(' || $DIGIT(LEN+1) || ')';\n                      ELSE C1=C1 || '(' || $REGS(X) || ')';\n           END;\n        END;\n\n        ELSE DO;                         /* DSECT USING */\n           LBLOCK_PTR=LBLOCK_START;\n           DO WHILE(LBLOCK_PTR\u00ac=NULL);\n              IF LBLOCK.NAME=USING.NAME THEN DO; /* APPROPRIATE LIVB */\n                 IF (USING.REG=0 & B=0 & X=0) | USING.REG\u00ac=0 THEN\n                    GOTO $GOODLIV;\n              END;\n              LBLOCK_PTR=LBLOCK.NEXT;\n           END;\n\n $GOODLIV: IF LBLOCK_PTR=NULL THEN DO;\n              IF USING.REG=0 THEN DO;\n                 USING_PTR = USING.NEXT;\n                 GOTO NEW_USING;\n              END;\n              SIGNAL ERROR;\n              STOP;\n           END;\n\n           IF LBLOCK.ADR = 0 THEN DO;\n $PUTC1:      C1 = $DNAME(LBLOCK_PTR,BIN(D,15),I);\n              CALL $PUTDUMMY(LBLOCK.NAME,D);\n              IF $XREF THEN CALL $PUTXRF(C1);\n              IF $DSOFF & (I=1) THEN\n                 C1=$NEXTEL(SUBSTR(LBLOCK.NAME,2)) || '+' || $DIGIT(D);\n              GOTO $PUTLENX;\n           END;\n           ELSE DO;\n              C1=$LFIND(LBLOCK_PTR,D,$XREF,#COM,$PUTXRF);\n              IF C1='' THEN GOTO $PUTC1;\n                       ELSE GOTO $PUTLENX;\n           END;\n        END;\n     END;\n     ELSE DO;     /* DO NOT HAVE RELEVAND BASE REG  */\n $NOLIV:\n       IF OPNAME='B' THEN DO;\n          IF (RM.B2=15 & RM.X2=0) | (RM.B2=0 & RM.X2=15) THEN\n             #FORWARD=RM.D2;\n       END;\n     END;\n\n     IF $XREF THEN DO;\n        IF $FB THEN\n           CALL $PUTXRF($REGS(B));\n        IF $FX THEN\n           CALL $PUTXRF($REGS(X));\n     END;\n     RETURN (C1);\n END $ADDR;\n %PAGE;\n /*********************************************************************/\n /*  OPEN MEMBER SUBROUTINE                                           */\n /*  IF FIRST TIME THEN CREATE ESD TABLE                              */\n /*********************************************************************/\n $OPEN:\n     PROC ;\n     DCL  (I,J,K,LASTSD) BIN FIXED(31) INIT(0);\n\n     J = REASLOA('OPEN', '', '', '', '', '');\n\n     ESD_BLOCK_PTR=ADDR(BLOCK);\n\n     DO J=1 TO 10;\n        CALL REASQPW('CHECK',PASS(J),JDAT);\n     END;\n\n     CALL $READ;\n     DO WHILE(UNSPEC(IDENT)='01000000'B);      /*  LOOP SYM     */\n        CALL $READ;\n     END;\n     DO WHILE(UNSPEC(IDENT)='00100000'B);      /*  LOOP ESD     */\n        I=I+ESDLEN/16;                         /*  ESD EL NUM   */\n        CALL $READ;\n     END;\n     ALLOCATE ESD_ARRAY(I);\n     DIM_ESD_ARRAY = I;\n\n     J = REASLOA('CLOSE', '', '', '', '', '');\n     J = REASLOA('OPEN',  '', '', '', '', '');\n\n     I=0; CALL $READ;\n     DO WHILE(UNSPEC(IDENT)='01000000'B);      /*  LOOP SYM     */\n        CALL $READ;\n     END;\n     DO WHILE(UNSPEC(IDENT)='00100000'B); /*  ESD LOOP    */\n        #ESD_ELEMENT_PTR=#ESD_BLOCK_PTR+8;\n        DO K=1 TO ESDLEN/16;\n          I=I+1;\n          ESD_ARRAY(I) = ESD_ELEMENT, BY NAME;\n          ONEBYTE = ESD_ARRAY(I).TYPE;\n          ESD_ARRAY(I).ID  = FIRST_ESDID+K-1;\n          ESD_ARRAY(I).REF = 0;\n          IF \u00acBIT4 &  BIT5 & \u00acBIT6 & \u00acBIT7 THEN   /* 04  **** PC */\n             ESD_ARRAY(I).TYPE = '0'B;            /*     MAKE SD */\n          IF \u00acBIT4 & \u00acBIT5 & \u00acBIT6 & \u00acBIT7 THEN   /* 0F  **** SD */\n             LASTSD = ESD_ARRAY(I).ID;            /*     REMEMBER*/\n          IF  BIT4 & \u00acBIT5 &  BIT6 & \u00acBIT7 THEN   /* 0A  **** WX */\n             ESD_ARRAY(I).REF = LASTSD;           /*     SET REF */\n          IF (\u00acBIT4 & \u00acBIT5 &  BIT6 &  BIT7) |    /* 03  **** LD */\n             (\u00acBIT4 &  BIT5 &  BIT6 & \u00acBIT7) THEN /* 06  **** XD */\n             ESD_ARRAY(I).REF=\n                 BIN(SUBSTR(UNSPEC(ESD_ARRAY(I).LENGTH),9),15);\n          #ESD_ELEMENT_PTR=#ESD_ELEMENT_PTR+16;\n        END;\n        CALL $READ;\n     END;\n END $OPEN;\n %PAGE;\n /*********************************************************************/\n /*  FIND CSECT AND READ ITS BODY                                     */\n /*********************************************************************/\n $CSECT:\n     PROC ;\n     DCL  (I,J,K,L) BIN FIXED(31),\n          (#F,#T)   BIN FIXED,\n          $RYES     BIT(1),\n          NN        CHAR(8);\n\n     ESDID    = 0;\n     TEXTLEN = 0;\n $CSECT_ESD_LOOP:\n     DO I=1 TO DIM_ESD_ARRAY;\n        IF  ESD_ARRAY(I).NAME=CSECT THEN DO;\n            ONEBYTE = ESD_ARRAY(I).TYPE;\n            IF  \u00acBIT4 & \u00acBIT5 & \u00acBIT6 & \u00acBIT7 THEN DO; /* SD */\n                ESDID=ESD_ARRAY(I).ID;\n                K=ESD_ARRAY(I).LENGTH;\n                ARRINDX=I;\n                LEAVE $CSECT_ESD_LOOP;\n            END;\n            IF  \u00acBIT4 & \u00acBIT5 & BIT6 & BIT7 THEN DO;   /* LD */\n                ESDID=ESD_ARRAY(I).REF;\n                DO J=1 TO DIM_ESD_ARRAY;\n                   ONEBYTE = ESD_ARRAY(J).TYPE;\n                   IF  ESDID=ESD_ARRAY(J).ID &\n                       \u00acBIT4 & \u00acBIT5 & \u00acBIT6 & \u00acBIT7 THEN DO;\n                       CSECT=ESD_ARRAY(J).NAME;\n                       K=ESD_ARRAY(J).LENGTH;\n                       ARRINDX=J;\n                       LEAVE $CSECT_ESD_LOOP;\n                   END;\n                END;\n                SIGNAL ERROR;\n                STOP;\n            END;\n        END;\n     END $CSECT_ESD_LOOP;\n\n     IF ESDID=0 THEN RETURN;\n\n     IF K > 32767 | K=0 THEN DO;\n        TEXTLEN = 0;\n        ESDID=0;\n        RETURN;\n     END;\n\n     CALL ALLOCATETEXT(32767);\n     TEXTLEN = K;\n\n     CNTL_BLOCK_PTR=ADDR(BLOCK);\n\n $CSECT_CNTL_LOOP:\n     DO WHILE(\u00ac$EOF);\n        IF CNTLYES & CNTLNO\u00ac=0 THEN DO;\n           #CNTL_ELEMENT_PTR=#CNTL_BLOCK_PTR+16+RLDNO;\n           DO I=1 TO CNTLNO/4;\n              IF  CNTLID=ESDID THEN DO;\n                J=ESD_ARRAY(ARRINDX).OFF-TXTOFF;\n                K=CNTLLEN;        /* LENGTH IN THIS BLOCK         */\n                CALL $READ;       /* READ BLOCK AFTER CNTL RECORD */\n                IF $EOF THEN GOTO EOF;\n                CALL SETTEXT(SUBSTR(BLOCK,J+1,K));\n                LEAVE $CSECT_CNTL_LOOP;\n              END;\n              #CNTL_ELEMENT_PTR=#CNTL_ELEMENT_PTR+4;\n           END;\n           CALL $READ;\n           IF $EOF THEN GOTO EOF;\n        END;\n        CALL $READ;\n        IF $EOF THEN GOTO EOF;\n     END $CSECT_CNTL_LOOP;\n     CALL $READ;\n     IF $EOF THEN GOTO EOF;\n\n $CSECT_GETTEXT_LOOP:\n     DO WHILE(\u00ac$EOF);\n         /***************************/\n         /* RLD INFO EXISTS         */\n         /***************************/\n         IF RLDYES & RLDNO\u00ac=0 THEN DO;\n            #RLD_ELEMENT_PTR=#CNTL_BLOCK_PTR+16;\n            I=1;\n            DO WHILE(I <= RLDNO/4);\n               #F=FROMID;\n               #T=TOID;\n               I=I+1;\n               #RLD_ELEMENT_PTR=#RLD_ELEMENT_PTR+4;\n               IF #F=ESDID THEN DO;\n                  DO J=1 TO DIM_ESD_ARRAY;\n                     K=J;\n                     IF #T=ESD_ARRAY(K).ID THEN LEAVE;\n                  END;\n                  NN=ESD_ARRAY(K).NAME;\n                  DO WHILE('1'B);\n                     ALLOCATE RLD;\n                     IF RLD_START=NULL THEN RLD_START=RLD_PTR;\n                                       ELSE PREV->RLD.NEXT=RLD_PTR;\n                     PREV=RLD_PTR;\n                     RLD.NEXT=NULL;\n                     RLD.LENGTH=RLDLEN+1;\n                     RLD.OFF=RLDOFF-ESD_ARRAY(ARRINDX).OFF;\n                     RLD.NAME=NN;\n                     RLD.SUBT=RLDE_ELEMENT.SUBT;\n                     RLD.TYPE=$RLDTYPE(RLDTYPE);\n                     IF RLD.TYPE='A' & #F\u00ac=#T THEN DO;\n                        RLD.TYPE='V';\n                     END;\n                     IF \u00acNOTLAST THEN LEAVE;\n                     #RLD_ELEMENT_PTR=#RLD_ELEMENT_PTR+4;\n                     I=I+1;\n                  END;\n               END;\n               ELSE DO;\n                  DO WHILE('1'B);\n                     IF \u00acNOTLAST THEN LEAVE;\n                     #RLD_ELEMENT_PTR=#RLD_ELEMENT_PTR+4;\n                     I=I+1;\n                  END;\n               END;\n               I=I+1;\n               #RLD_ELEMENT_PTR=#RLD_ELEMENT_PTR+4;\n            END;\n            IF CNTL_BLOCK.LAST THEN\n               LEAVE $CSECT_GETTEXT_LOOP;\n         END;\n         /***************************/\n         /* CNTL INFO EXISTS        */\n         /***************************/\n         IF CNTLYES & CNTLNO\u00ac=0 THEN DO;\n            #CNTL_ELEMENT_PTR=#CNTL_BLOCK_PTR+16+RLDNO;\n            $RYES='0'B;\n $CSECT_CNTL_LOOP_#1:\n            DO I=1 TO CNTLNO/4;\n               IF CNTLID=ESDID THEN DO;\n                  K=TXTOFF-ESD_ARRAY(ARRINDX).OFF-LENGTHTEXT();\n                  IF K > 0 THEN DO;\n                     ALLOCATE ORG;\n                     ORG.NEXT=ORG_START;\n                     ORG_START=ORG_PTR;\n                     ORG.OFF=LENGTHTEXT();\n                     ORG.LENGTH=K;\n                     CALL CONCATTEXT(HIGH(K));\n                  END;\n                  J=TEXTLEN-LENGTHTEXT();\n                  IF CNTLLEN < J THEN J=CNTLLEN;\n                  CALL $READ;\n                  IF $EOF THEN GOTO EOF;\n                  $RYES='1'B;\n                  CALL CONCATTEXT(SUBSTR(BLOCK,1,J));\n                  LEAVE $CSECT_CNTL_LOOP_#1;\n               END;\n               #CNTL_ELEMENT_PTR=#CNTL_ELEMENT_PTR+4;\n               IF TEXTLEN=LENGTHTEXT() THEN\n                  LEAVE $CSECT_CNTL_LOOP_#1;\n            END;\n            IF \u00ac$RYES THEN CALL $READ;\n            IF $EOF THEN GOTO EOF;\n         END;\n         CALL $READ;\n         IF $EOF THEN GOTO EOF;\n     END $CSECT_GETTEXT_LOOP;\n\n EOF:\n     IF LENGTHTEXT() < TEXTLEN THEN DO;\n        ALLOCATE     ORG;\n        ORG.NEXT   = ORG_START;\n        ORG_START  = ORG_PTR;\n        ORG.OFF    = LENGTHTEXT();\n        ORG.LENGTH = TEXTLEN-LENGTHTEXT();\n        CALL CONCATTEXT(HIGH(TEXTLEN-LENGTHTEXT()));\n     END;\n\n     CALL COPYTEXT();\n\n END $CSECT;\n %PAGE;\n /*********************************************************************/\n /*  READ NEXT RECORD                                                 */\n /*********************************************************************/\n $READ: PROC ;\n  DCL  I;\n     I = REASLOA('READ', '', '', '', '', BLOCK);\n     IF I \u00ac= 0 THEN $EOF = '1'B;\n     ELSE           $EOF = '0'B;\n END $READ;\n %SKIP;\n /*********************************************************************/\n /*  SORT KNOWLEDGE BASE                                              */\n /*********************************************************************/\n $SORTDSC:\n     PROC RECURSIVE ;\n DCL   SORT  BIT(1) INIT('1'B),\n       (P,Q) PTR INIT(NULL);\n\n     IF DSC_START=NULL THEN RETURN;\n\n     DO WHILE(SORT);\n        SORT='0'B;\n        DSC_PTR=DSC_START;\n        P=DSC.NEXT;\n        DO WHILE(P\u00ac=NULL);\n           IF P->DSC.OFF < DSC.OFF THEN DO;\n             IF DSC_PTR=DSC_START THEN DSC_START=P;\n                                  ELSE Q->DSC.NEXT=P;\n             DSC.NEXT=P->DSC.NEXT;\n             P->DSC.NEXT=DSC_PTR;\n             SORT='1'B;\n             Q=P;\n           END;\n           ELSE DO;\n             Q=DSC_PTR;\n             DSC_PTR=P;\n           END;\n           P=DSC.NEXT;\n        END;\n     END;\n END $SORTDSC;\n %PAGE;\n /*********************************************************************/\n /*  INIT KNOWLEDGE BASE                                              */\n /*********************************************************************/\n $INITDSC:\n     PROC ;\n DCL P      PTR,\n     #VAL   BIN FIXED,\n     VAL    CHAR(2) BASED(ADDR(#VAL)),\n     I      BIN FIXED(31);\n\n     CALL $FREE;\n\n     RLD_PTR = RLD_START;\n     DO WHILE(RLD_PTR\u00ac=NULL);\n        ALLOCATE DSC;\n        DSC.NEW='0'B;\n        DSC.FIX='0'B;\n        IF DSC_START=NULL THEN DSC_START      = DSC_PTR;\n                          ELSE PREV->DSC.NEXT = DSC_PTR;\n        PREV = DSC_PTR;\n        DSC  = RLD, BY NAME;\n        DSC.NORED = '1'B;        /* CANN'T REDEFINE |     */\n        DSC.EXTRN = '0'B;\n        DSC.NEXT  = NULL;\n        IF RLD.TYPE='A' THEN\n           CALL $SUBT(RLD.OFF,RLD.LENGTH,ESD_ARRAY(ARRINDX).OFF);\n        IF RLD.TYPE='V' THEN DO;\n           DO I=1 TO DIM_ESD_ARRAY WHILE(ESD_ARRAY(I).NAME \u00ac= RLD.NAME);\n           END;\n           IF ESD_ARRAY(I).NAME = RLD.NAME THEN DO;\n              CALL $SUBT(RLD.OFF,RLD.LENGTH,ESD_ARRAY(I).OFF);\n              ONEBYTE = ESD_ARRAY(I).TYPE;\n              IF \u00acBIT4 & \u00acBIT5 & BIT6 & \u00acBIT7 THEN DSC.EXTRN='1'B;\n           END;\n        END;\n        IF RLD.LENGTH=4 THEN VAL=SUBSTRTEXT(RLD.OFF+1+2,2);\n        ELSE                 VAL=SUBSTRTEXT(RLD.OFF+1+1,2);\n        IF RLD.TYPE='A' THEN\n           CALL $INITLAB($NAME(SUBSTRTEXT(RLD.OFF+1,RLD.LENGTH)),\n                         #VAL,0,'0'B,0);\n        IF SUBSTRTEXT(RLD.OFF+1,RLD.LENGTH) \u00ac= LOW(RLD.LENGTH) &\n           RLD.TYPE='V' THEN\n           DSC.EXTRN='1'B;\n        RLD_PTR=RLD.NEXT;\n     END;\n     DO I=1 TO DIM_ESD_ARRAY;\n        ONEBYTE = ESD_ARRAY(I).TYPE;\n        IF ESD_ARRAY(I).REF=ESDID &\n           \u00acBIT4 & \u00acBIT5 & BIT6 & BIT7 THEN DO;\n           CALL $INITLAB(ESD_ARRAY(I).NAME,\n                         ESD_ARRAY(I).OFF-ESD_ARRAY(ARRINDX).OFF,\n                         0,'1'B,0);\n           LABL.NORED = '1'B;    /* 17/05/91 */\n        END;\n     END;\n     CALL $SORTDSC;\n     ORG_PTR=ORG_START;\n     DO WHILE(ORG_PTR\u00ac=NULL);\n        CALL $INCLUDE(ORG.OFF,ORG.LENGTH,'O');\n        PREV=ORG_PTR;\n        ORG_PTR=ORG.NEXT;\n        FREE PREV->ORG;\n     END;\n     ORG_START=NULL;\n     I=0;\n     DSC_PTR=DSC_START;\n     DO WHILE(DSC_PTR\u00ac=NULL);\n        DSC.NORED='1'B;\n        I=I+DSC.LENGTH;\n        DSC_PTR=DSC.NEXT;\n     END;\n     IF I < TEXTLEN THEN\n        CALL $INCLUDE(0,TEXTLEN,'X');\n END $INITDSC;\n %PAGE;\n /*********************************************************************/\n /*  CONNECT NEIGHBOUR PIECES IN KNOWLEDGE BASE                       */\n /*********************************************************************/\n $CONNECT:\n     PROC RECURSIVE ;\n\n DCL (P,Q) PTR INIT(NULL);\n     DSC_PTR=DSC_START;\n     P=DSC.NEXT;\n     DO WHILE(DSC_PTR\u00ac=NULL & P\u00ac=NULL);\n        IF DSC.OFF+DSC.LENGTH = P->DSC.OFF         &\n           DSC.TYPE              = P->DSC.TYPE     &\n           DSC.NORED             = P->DSC.NORED    &\n           (DSC.TYPE='I' | DSC.TYPE='X' | DSC.TYPE='C' |\n            DSC.TYPE='#' | DSC.TYPE='B'                 ) &\n           \u00acDSC.NORED                              THEN DO;\n           DSC.LENGTH=DSC.LENGTH+P->DSC.LENGTH;\n           DSC.NEXT=P->DSC.NEXT;\n           FREE P->DSC;\n        END;\n        ELSE DO;\n           Q=DSC_PTR;\n           DSC_PTR=P;\n        END;\n        P=DSC.NEXT;\n        IF DSC.LENGTH=0 THEN DO;\n           IF Q\u00ac=NULL THEN Q->DSC.NEXT=DSC.NEXT;\n                      ELSE DSC_START=DSC.NEXT;\n           FREE DSC;\n           DSC_PTR=P;\n           IF DSC_PTR\u00ac=NULL THEN P=DSC.NEXT;\n        END;\n     END;\n\n END $CONNECT;\n %SKIP;\n /*********************************************************************/\n /*  INCLUDE NEW ELEMENT INTO BASE                                    */\n /*********************************************************************/\n $INCLUDE:\n     PROC(FROM,LEN,T) RECURSIVE;\n\n DCL (FROM,LEN,TO) BIN FIXED(31),\n     T        CHAR(1),\n     P        PTR;\n\n     $CONF='1'B;\n\n     IF $REM THEN\n        CALL $AUTOREC;\n\n     /* 1. CREATE NEW ELEMENT AND INCLUDE IT AT TOP OF BASE */\n     ALLOCATE DSC;\n     DSC.OFF=FROM;\n     DSC.LENGTH=LEN;\n     DSC.TYPE=T;\n     DSC.NORED='0'B;\n     DSC.SUBT='0'B;\n     DSC.NEW='1'B;\n     DSC.FIX='0'B;\n     DSC.EXTRN='0'B;\n     DSC.NEXT=DSC_START;\n     DSC.NAME='*';\n     DSC_START=DSC_PTR;\n     /* 2. BASE SORT */\n     CALL $SORTDSC;\n     IF $TRACE THEN\n        CALL $PRINTDSC('NEW ELEMENT:AFTER SORT');\n     /* 3. PRESS TRASH INFO         */\n     CALL $PRESS;\n     IF $TRACE THEN\n        CALL $PRINTDSC('AFTER $PRESS');\n     CALL $CONNECT;\n     IF $TRACE THEN\n        CALL $PRINTDSC('AFTER $CONNECT');\n END $INCLUDE;\n %PAGE;\n /*********************************************************************/\n /*  PRESS TRASH SUBROUTINE                                           */\n /*********************************************************************/\n $PRESS:\n     PROC RECURSIVE ;\n DCL (I,J,K)        BIN FIXED(31),\n     $BIT(4)        BIT(1),\n     (D,SPTR,P,Q,R) PTR;\n\n $PRESS_BEGIN:\n     Q=NULL;\n     D=DSC_START;\n     DO WHILE(\u00acD->DSC.NEW);    /* FIND NEW-ELEMENT */\n        Q=D;\n        D=D->DSC.NEXT;\n     END;\n     P=D->DSC.NEXT;\n\n     IF Q\u00ac=NULL THEN           /* NOT FIRST        */\n        IF Q->DSC.OFF+Q->DSC.LENGTH > D->DSC.OFF THEN DO;\n           P=D;\n           D=Q;\n        END;\n\n $TEST_AGAIN:\n     $BIT='0'B;\n     $BIT(1) = D->DSC.NORED;\n     $BIT(2) = D->DSC.NEW;\n     IF P\u00ac=NULL THEN DO;\n       $BIT(3) = P->DSC.NORED;\n       $BIT(4) = P->DSC.NEW;\n     END;\n     K=0;\n     IF $BIT(1) THEN K=K+8;\n     IF $BIT(2) THEN K=K+4;\n     IF $BIT(3) THEN K=K+2;\n     IF $BIT(4) THEN K=K+1;\n\n     IF $TRACE THEN DO;\n        PUT SKIP DATA($BIT,K);\n        PUT SKIP EDIT('  Q->:',Q->DSC.NAME,$BH(Q->DSC.OFF),\n                      $BH(Q->DSC.LENGTH),Q->DSC.TYPE,Q->DSC.NORED,\n                      Q->DSC.NEW,Q->DSC.FIX,Q->DSC.EXTRN,Q->DSC.SUBT)\n                     ((5)(A,X(1)),(5)(B(1),X(1)));\n        PUT SKIP EDIT('  D->:',D->DSC.NAME,$BH(D->DSC.OFF),\n                      $BH(D->DSC.LENGTH),D->DSC.TYPE,D->DSC.NORED,\n                      D->DSC.NEW,D->DSC.FIX,D->DSC.EXTRN,D->DSC.SUBT)\n                     ((5)(A,X(1)),(5)(B(1),X(1)));\n        PUT SKIP EDIT('  P->:',P->DSC.NAME,$BH(P->DSC.OFF),\n                      $BH(P->DSC.LENGTH),P->DSC.TYPE,P->DSC.NORED,\n                      P->DSC.NEW,P->DSC.FIX,P->DSC.EXTRN,P->DSC.SUBT)\n                     ((5)(A,X(1)),(5)(B(1),X(1)));\n        CALL REASLST;\n     END;\n\n     /*        BITS COORDINATION AND OVERLAY:\n        D->R D->N P->R P->N    WHICH\n        BIT1 BIT2 BIT3 BIT4 WILL BE OVERAYED\n        ---- ---- ---- ---- ----------------\n     0   0    0    0    0      -\"-    0\n     1   0    0    0    1       L     1\n     2   0    0    1    0      -\"-    2\n     3   0    0    1    1       L     3\n     4   0    1    0    0       R     4\n     5   0    1    0    1      -\"-    5\n     6   0    1    1    0       L     6\n     7   0    1    1    1      -\"-    7\n     8   1    0    0    0      -\"-    8\n     9   1    0    0    1       R     9\n    10   1    0    1    0      -\"-   10\n    11   1    0    1    1      -\"-   11\n    12   1    1    0    0       R    12\n    13   1    1    0    1      -\"-   13\n    14   1    1    1    0      -\"-   14\n    15   1    1    1    1      -\"-   15\n     */\n     P=D->DSC.NEXT;\n     IF P\u00ac=NULL THEN DO;\n        I=D->DSC.OFF+D->DSC.LENGTH - P->DSC.OFF;\n        IF I>0 THEN DO;             /* INTERVALS OVERAPPING        */\n           IF K=4 | K=9 | K=12 THEN DO;/* CAN REDEFINE RIGHT       */\n             IF $TRACE THEN\n                PUT SKIP LIST('REDEFINE RIGHT');\n             IF D->DSC.OFF+D->DSC.LENGTH >= /* AFTER OVERLAY       */\n                P->DSC.OFF+P->DSC.LENGTH THEN DO;\n                IF $TRACE THEN\n                   PUT SKIP LIST('FULL OVERLAP');\n                D->DSC.NEXT=P->DSC.NEXT;\n                FREE P->DSC;\n                P=D->DSC.NEXT;\n                IF $TRACE THEN\n                   PUT SKIP LIST('PERFORM TEST_AGAIN');\n                GOTO $TEST_AGAIN;\n             END;\n             ELSE DO;                          /* PARTIAL OVERLAY */\n               P->DSC.OFF=D->DSC.OFF+D->DSC.LENGTH;\n               P->DSC.LENGTH=P->DSC.LENGTH-I;\n               IF P->DSC.TYPE\u00ac='X' & P->DSC.TYPE\u00ac='C' &\n                  P->DSC.TYPE\u00ac='I' & P->DSC.TYPE\u00ac='#' &\n                  P->DSC.TYPE\u00ac='B' THEN\n                  P->DSC.TYPE='X';\n             END;\n           END;\n           ELSE DO;                   /* REDEFINE LEFT            */\n             IF $TRACE THEN\n                PUT SKIP LIST('REDEFINE LEFT');\n             J=D->DSC.LENGTH;\n             D->DSC.LENGTH=P->DSC.OFF - D->DSC.OFF;\n             IF D->DSC.TYPE='F' | D->DSC.TYPE='H' THEN\n                D->DSC.TYPE='X';\n             J=J-D->DSC.LENGTH-P->DSC.LENGTH;\n             IF J>0 THEN DO;          /* SMALL PIECE REST           */\n                IF $TRACE THEN\n                   PUT SKIP EDIT('SMALL PIECE SIZE: ',\n                   $BH(J),' BYTES')(A,A,A);\n                R=DSC_START;\n                DO WHILE(R\u00ac=NULL);\n                   R->DSC.NEW='0'B;\n                   R=R->DSC.NEXT;\n                END;\n                CALL $INCLUDE(P->DSC.OFF+P->DSC.LENGTH,\n                              J,D->DSC.TYPE);\n             END;\n             ELSE DO;\n                Q=P->DSC.NEXT;\n                IF Q\u00ac=NULL & P->DSC.NEW THEN DO;\n                   IF P->DSC.OFF+P->DSC.LENGTH > Q->DSC.OFF THEN\n                      GOTO $PRESS_BEGIN;\n                END;\n             END;\n           END;\n        END;\n        D=P;\n     END;\n     P=DSC_START;\n     DO WHILE(P\u00ac=NULL);\n        P->DSC.NEW='0'B;\n        P=P->DSC.NEXT;\n     END;\n     IF $TRACE THEN CALL REASLST;\n END $PRESS;\n %PAGE;\n /*********************************************************************/\n /*  FILL OFFST  AND OBJECT CODE                                      */\n /*********************************************************************/\n $PUTOBJ:\n     PROC(FROM,LEN,I);\n DCL (FROM,LEN,I) BIN FIXED(31),\n     #CHAR        CHAR(4) BASED(ADDR(FROM));\n\n     REASM02_LINE(I).OFF=$CH(SUBSTR(#CHAR,2));\n     REASM02_LINE(I).OBJECT=$CH(SUBSTRTEXTCOPY(FROM+1,LEN));\n END $PUTOBJ;\n %PAGE;\n /*********************************************************************/\n /*  SHOW PROJECT FROM SPECIFIED OFFST                                */\n /*********************************************************************/\n $SHOW:\n     PROC ;\n DCL\n     $CHAR(4) CHAR(1) STATIC INT INIT('1','2','3','4'),\n     MAXLEN   BIN FIXED,\n     #VAL     BIN FIXED(31),\n     VAL      CHAR(4) BASED(ADDR(#VAL)),\n     #HVAL    BIN FIXED(15),\n     HVAL     CHAR(2) BASED(ADDR(#HVAL)),\n     #LOCVAR  CHAR(60) VAR,\n     (Q,P,LAB,XLAB)    PTR,\n     1 SLINE  LIKE REASM02_LINE,\n     1 SCONST UNALIGNED BASED(SPTR),\n       2 B    BIT(4),      /* BASE REG */\n       2 D    BIT(12),     /* OFFST    */\n     SPTR     PTR,\n     (I,K,NOLABEL)    BIN FIXED(31) INIT(0);\n\n     IF OFFSET < 0 THEN OFFSET=0;\n     #OFFSET,$OFFSET = OFFSET;\n\n     #CURI=1;\n     IV = ' ';\n     DO I=1 TO 10;\n        CALL REASQPW('CHECK',PASS(I),JDAT);\n     END;\n     DO WHILE('1'B);\n        IF #OFFSET=0 THEN DO;\n           CALL PRINT_CSECT;\n           CALL PRINT_DXD;\n        END;\n\n        #COM='';\n        IF #OFFSET >= TEXTLEN THEN   GOTO $AFTER_FIND;\n        CALL $FINDDSC(#OFFSET);      /* FIND DSC ELEMENT */\n        MAXLEN=TEXTLEN-#OFFSET;\n        $ORGIMM='';\n\n        IF DSC.TYPE='I' THEN DO;     /* COMMAND */\n           IF MOD(#OFFSET,2)\u00ac=0 THEN GOTO $SHOW_X;\n           CALL $CMD(#OFFSET,#CURI);\n           CALL $FINDDSC(#OFFSET);\n           IF REASM02_LINE(#CURI).OPER='' THEN GOTO $SHOW_X;\n           I=CMDLEN(CMDDEF);\n           IF I > MAXLEN THEN DO;\n              CALL $INCLUDE(#OFFSET,I-MAXLEN,'X');\n              GOTO $SHOW_X;\n           END;\n           IF I > DSC.LENGTH-(#OFFSET-DSC.OFF) THEN\n              GOTO $SHOW_X;\n        END;\n\n        IF REASM02_LINE(#CURI).OPER = '' THEN\n           REASM02_LINE(#CURI).OPER = 'DC';\n\n        IF DSC.TYPE='F' THEN DO;       /* F-CONST */\n           MAXLEN=TEXTLEN-#OFFSET;\n           IF MAXLEN < 4 THEN GOTO $SHOW_X;\n           CALL $PUTOBJ(#OFFSET,4,#CURI);\n           VAL=SUBSTRTEXT(#OFFSET+1,4);\n           IF MOD(#OFFSET,4)=0 THEN LOCVAR='';\n           ELSE                     LOCVAR='L4';\n           REASM02_LINE(#CURI).OPERANDS=\n             'F' || LOCVAR || '''' ||  $DIGIT(#VAL) || '''';\n           I=4;\n        END;\n\n        IF DSC.TYPE='3' THEN DO;       /* 3-BYTE CONST */\n           MAXLEN=TEXTLEN-#OFFSET;\n           IF MAXLEN < 3 THEN GOTO $SHOW_X;\n           CALL $PUTOBJ(#OFFSET,3,#CURI);\n           VAL=SUBSTRTEXT(#OFFSET,4);\n           SUBSTR(VAL,1,1)=LOW(1);\n           REASM02_LINE(#CURI).OPERANDS=\n             'AL3(' ||  $DIGIT(#VAL) || ')';\n           I=3;\n        END;\n\n        IF DSC.TYPE='S' THEN DO;                 /* S-CONST   */\n           MAXLEN=TEXTLEN-#OFFSET;\n           IF MAXLEN<2          THEN GOTO $SHOW_X;\n           IF MOD(#OFFSET,2)\u00ac=0 THEN GOTO $SHOW_X;\n           CALL $PUTOBJ(#OFFSET,2,#CURI);\n           HVAL  = SUBSTRTEXT(#OFFSET+1,2);\n           SPTR = ADDR(HVAL);\n           GLOBAL_IP = 0;\n           #LOCVAR = $ADDR(SCONST.B,SCONST.D,0,'0'B,0,'0'B,'',#OFFSET);\n           IF SUBSTR(#LOCVAR,LENGTH(#LOCVAR),1)=')' THEN\n              GOTO $SHOW_X;\n           IF #LOCVAR='*-0' | #LOCVAR='*+0' THEN #LOCVAR='*'; /*BELLS*/\n           REASM02_LINE(#CURI).OPERANDS = 'S(' || #LOCVAR || ')';\n           I=2;\n        END;\n\n        IF DSC.TYPE='H' | DSC.TYPE='Y' THEN DO;  /* H/Y-CONST */\n           MAXLEN = TEXTLEN-#OFFSET;\n           IF MAXLEN<2 THEN GOTO $SHOW_X;\n           CALL $PUTOBJ(#OFFSET,2,#CURI);\n           HVAL=SUBSTRTEXT(#OFFSET+1,2);\n           #VAL=0; SUBSTR(VAL,3,2) = HVAL;\n           IF MOD(#OFFSET,2)=0 THEN LOCVAR='';\n           ELSE                     LOCVAR='L2';\n           IF DSC.TYPE='H' THEN   /* H-CONST */\n              REASM02_LINE(#CURI).OPERANDS=\n                     'H' || LOCVAR || '''' || $DIGIT(#HVAL) || '''';\n           ELSE                   /* Y-CONST */\n              REASM02_LINE(#CURI).OPERANDS=\n                     'Y' || LOCVAR || '('  ||  $DIGIT(#VAL)  || ')';\n           I=2;\n        END;\n\n        IF DSC.TYPE='1' THEN DO;       /* 1-BYTE CONST */\n           CALL $PUTOBJ(#OFFSET,1,#CURI);\n           ICH = 0;\n           CH  = SUBSTRTEXT(#OFFSET+1,1);\n           REASM02_LINE(#CURI).OPERANDS=\n             'AL1(' || $DIGIT(ICH) || ')';\n           I=1;\n        END;\n\n        IF DSC.TYPE='P' THEN DO;     /* PACKED DECIMAL DATA */\n           DCL SIGN CHAR(1)  VAR;\n           I = DSC.LENGTH;\n           IF I > 8 THEN GOTO $SHOW_X;\n           LOCVAR=$CH(SUBSTRTEXTCOPY(#OFFSET+1,I));\n           SELECT (SUBSTR(LOCVAR,LENGTH(LOCVAR),1));\n              WHEN ('D') SIGN = '-';\n              WHEN ('C') SIGN = '';\n              OTHERWISE GOTO $SHOW_X;\n           END;\n           LOCVAR = SUBSTR(LOCVAR,1,LENGTH(LOCVAR)-1);\n           DO J=1 TO LENGTH(LOCVAR);\n              IF SUBSTR(LOCVAR,J,1)<'0' | SUBSTR(LOCVAR,J,1)>'9' THEN\n                 GOTO $SHOW_X;\n           END;\n           CALL $PUTOBJ(#OFFSET,I,#CURI);\n           REASM02_LINE(#CURI).OPERANDS =\n                'P''' || SIGN || LOCVAR || '''';\n        END;\n\n        IF DSC.TYPE='X' THEN DO;    /* HEX-DATA */\n $SHOW_X:  I=MIN(DSC.LENGTH-(#OFFSET-DSC.OFF),4,MAXLEN);   /* 1995 */\n           REASM02_LINE(#CURI).OPER = 'DC';\n           LABL_PTR=LABL_START;\n           DO WHILE(LABL_PTR\u00ac=NULL);\n              IF LABL.OFF > #OFFSET THEN\n                 I=MIN(I,LABL.OFF-#OFFSET);\n              LABL_PTR=LABL.NEXT;\n           END;\n           CALL $PUTOBJ(#OFFSET,I,#CURI);\n           LOCVAR = SUBSTR(REASM02_LINE(#CURI).OBJECT,1,I*2);\n           REASM02_LINE(#CURI).OPERANDS = 'X''' || LOCVAR || '''' ;\n           LOCVAR = SUBSTRTEXT(#OFFSET+1,I);\n           IF $CHARSTR(LOCVAR) THEN\n              #COM = 'C''' || LOCVAR || '''';\n        END;\n\n        IF DSC.TYPE='B' THEN DO; /* BIT CONSTANT */\n           CALL $PUTOBJ(#OFFSET,1,#CURI);\n           REASM02_LINE(#CURI).OPERANDS =\n                  $BITSTR(SUBSTRTEXT(#OFFSET+1,1));\n           I=1;\n        END;\n\n        IF DSC.TYPE='C' THEN DO;    /* CHAR-DATA */\n           I=MIN(DSC.LENGTH-(#OFFSET-DSC.OFF),LINELEN,MAXLEN);\n           LABL_PTR=LABL_START;\n           DO WHILE(LABL_PTR\u00ac=NULL);\n              IF LABL.OFF > #OFFSET THEN\n                 I=MIN(I,LABL.OFF-#OFFSET);\n              LABL_PTR=LABL.NEXT;\n           END;\n           CALL $PUTOBJ(#OFFSET,I,#CURI);\n           LOCVAR='';\n           ICH=0;\n           DO J=1 TO I;\n              CH=SUBSTRTEXT(#OFFSET+J,1);\n              CH=SUBSTR(GOODA,ICH+1,1);\n              LOCVAR=LOCVAR || CH;\n              IF CH='''' | CH='&' THEN\n                 LOCVAR=LOCVAR || CH;\n           END;\n           REASM02_LINE(#CURI).OPERANDS = 'C''' || LOCVAR || '''';\n        END;\n\n        IF DSC.TYPE='Q' THEN DO;    /* Q-CONST */\n           #OFFSET = MIN(DSC.OFF,#OFFSET);\n           CALL $PUTOBJ(#OFFSET,DSC.LENGTH,#CURI);\n           I=DSC.LENGTH;\n           REASM02_LINE(#CURI).OPERANDS=\n             'QL' || $CHAR(DSC.LENGTH) || '(' ||\n             $NEXTEL(DSC.NAME) || ')';\n           #AZO(REASM02_LINE(#CURI).CMD#);\n           IF $XREF THEN\n              CALL $PUTXRF(DSC.NAME);\n        END;\n\n        IF DSC.TYPE='D' THEN DO;    /* CXD-CONST */\n           #OFFSET = MIN(DSC.OFF,#OFFSET);\n           CALL $PUTOBJ(#OFFSET,DSC.LENGTH,#CURI);\n           I=DSC.LENGTH;\n           REASM02_LINE(#CURI).OPER='CXD';\n           REASM02_LINE(#CURI).LABEL='';\n           #AZO(REASM02_LINE(#CURI).CMD#);\n        END;\n\n        IF DSC.TYPE='A' THEN DO; /* A-CONST */\n           #OFFSET = MIN(DSC.OFF,#OFFSET);\n           CALL $PUTOBJ(#OFFSET,DSC.LENGTH,#CURI);\n           I=DSC.LENGTH;\n           IF DSC.LENGTH\u00ac=4 THEN\n             REASM02_LINE(#CURI).OPERANDS=\n             'AL' || $CHAR(DSC.LENGTH) ||\n             '('||$NAME(SUBSTRTEXT(#OFFSET+1,DSC.LENGTH))||')';\n           ELSE\n             REASM02_LINE(#CURI).OPERANDS=\n             'A('||$NAME(SUBSTRTEXT(#OFFSET+2,3))||')';\n           #AZO(REASM02_LINE(#CURI).CMD#);\n\n           /* INSERTED ON FLKEYS */\n           IF DSC.LENGTH=4 & SUBSTRTEXT(#OFFSET+1,1)\u00ac=LOW(1) THEN DO;\n              CALL $LABEL(#OFFSET,I);\n              NOLABEL = 1;\n              CALL $PUTLINE;\n              REASM02_LINE(#CURI).OPER='ORG';\n              REASM02_LINE(#CURI).OPERANDS='*-4';\n              #AZP(REASM02_LINE(#CURI).CMD#);\n              #AZP(REASM02_LINE(#CURI).LABEL#);\n              LINE_I(#CURI),LINE_C(#CURI)=0;\n              LINE_O(#CURI)=I;\n              CALL $PUTLINE;\n              REASM02_LINE(#CURI).OPER='DC';\n              CALL $PUTOBJ(#OFFSET,1,#CURI);\n              LOCVAR = SUBSTR(REASM02_LINE(#CURI).OBJECT,1,2);\n              REASM02_LINE(#CURI).OPERANDS = 'X''' || LOCVAR || '''' ;\n              #AZP(REASM02_LINE(#CURI).CMD#);\n              #AZP(REASM02_LINE(#CURI).LABEL#);\n              LINE_I(#CURI),LINE_C(#CURI)=0;\n              LINE_O(#CURI)=I;\n              CALL $PUTLINE;\n              REASM02_LINE(#CURI).OPER='ORG';\n              REASM02_LINE(#CURI).OPERANDS='*+3';\n              #AZP(REASM02_LINE(#CURI).CMD#);\n              #AZP(REASM02_LINE(#CURI).LABEL#);\n              LINE_I(#CURI),LINE_C(#CURI)=0;\n              LINE_O(#CURI)=I+1;\n           END;\n        END;\n\n        IF DSC.TYPE='V' THEN DO;    /* V-CONST */\n           #OFFSET = MIN(DSC.OFF,#OFFSET);\n           CALL $PUTOBJ(#OFFSET,DSC.LENGTH,#CURI);\n\n           I = DSC.LENGTH;\n           IF DSC.LENGTH=3 THEN HVAL=SUBSTRTEXT(#OFFSET+2,2);\n           ELSE                 HVAL=SUBSTRTEXT(#OFFSET+3,2);\n           IF DSC.LENGTH=4 THEN #LOCVAR='';\n           ELSE                 #LOCVAR='L' || $CHAR(DSC.LENGTH);\n           IF \u00acDSC.EXTRN THEN DO;\n              REASM02_LINE(#CURI).OPERANDS=\n                'V' || #LOCVAR || '(' || DSC.NAME;\n              DO J=1 TO DIM_ESD_ARRAY;\n                 ONEBYTE = ESD_ARRAY(J).TYPE;\n                 IF ESD_ARRAY(J).NAME=DSC.NAME &\n                    (BIT4 & \u00acBIT5 & BIT6 & \u00acBIT7) THEN   /* 0A */\n                    REASM02_LINE(#CURI).OPERANDS=\n                      'A' || #LOCVAR || '(' || DSC.NAME;\n              END;\n           END;\n           ELSE DO;\n              LOCVAR='';\n              IF #HVAL > 0 THEN LOCVAR='+' || $DIGIT(#HVAL);\n              IF #HVAL < 0 THEN LOCVAR= $DIGIT(#HVAL);\n              REASM02_LINE(#CURI).OPERANDS=\n                'A' || #LOCVAR || '(' || $NEXTEL(DSC.NAME) || LOCVAR;\n           END;\n           SUBSTR(REASM02_LINE(#CURI).OPERANDS,\n                  INDEX(REASM02_LINE(#CURI).OPERANDS,' '),1)=')';\n           #AZO(REASM02_LINE(#CURI).CMD#);\n           IF $XREF THEN\n              CALL $PUTXRF(DSC.NAME);\n        END;\n\n        IF DSC.TYPE='O' THEN DO;          /* ORG */\n           #OFFSET = MIN(DSC.OFF,#OFFSET);\n           CALL $PUTOBJ(#OFFSET,DSC.LENGTH,#CURI);\n           REASM02_LINE(#CURI).OBJECT='';\n           I=DSC.LENGTH;\n           REASM02_LINE(#CURI).OPER='ORG';\n           REASM02_LINE(#CURI).OPERANDS='*+' || $DIGIT(DSC.LENGTH);\n           #AZO(REASM02_LINE(#CURI).CMD#);\n        END;\n\n        IF DSC.TYPE='#' THEN DO;          /* DS XL ?  */\n           #OFFSET = MIN(DSC.OFF,#OFFSET);        /* 08.12.87 */\n           I=MIN(DSC.LENGTH-(#OFFSET-DSC.OFF),MAXLEN);\n           LABL_PTR=LABL_START;\n           DO WHILE(LABL_PTR\u00ac=NULL);\n              IF LABL.OFF > #OFFSET THEN\n                 I=MIN(I,LABL.OFF-#OFFSET);\n              LABL_PTR=LABL.NEXT;\n           END;\n           REASM02_LINE(#CURI).OPER='DS';\n           REASM02_LINE(#CURI).OPERANDS=\n             'XL' || $DIGIT(I);                  /* 08.12.87 */\n        END;\n\n        IF REASM02_LINE(#CURI).OPER='' THEN DO;\n           PUT SKIP LIST('UNKNOWN ANIMAL:');\n           PUT SKIP DATA(REASM02_LINE(#CURI),#OFFSET,DSC);\n           CALL REASLST;\n           SIGNAL ERROR;\n           STOP;\n        END;\n\n        IF NOLABEL=0 THEN\n           CALL $LABEL(#OFFSET,I);\n        NOLABEL=0;\n\n        SLINE=REASM02_LINE(#CURI), BY NAME;\n\n        USING_PTR=USING_START;\n        DO WHILE(USING_PTR\u00ac=NULL);\n           /**********************/\n           /* SHOW DROPS         */\n           /**********************/\n           K=USING.PLACE+USING.LENGTH;\n           IF K>=#OFFSET & K<#OFFSET+I THEN DO;\n              REASM02_LINE(#CURI).OBJECT='';\n              REASM02_LINE(#CURI).OFF='';\n              #AZO(REASM02_LINE(#CURI).CMD#);\n              #AZO(REASM02_LINE(#CURI).LABEL#);\n              REASM02_LINE(#CURI).LABEL='';\n              REASM02_LINE(#CURI).OPER='DROP';\n              REASM02_LINE(#CURI).OPERANDS=$REGS(USING.REG);\n              #AZP(REASM02_LINE(#CURI).OPER#);\n              #AZP(REASM02_LINE(#CURI).OPERANDS#);\n              LINE_I(#CURI),LINE_C(#CURI)=0;\n              LINE_O(#CURI)=#OFFSET;\n              CALL $PUTLINE;\n           END;\n           USING_PTR=USING.NEXT;\n        END;\n        /**********************/\n        /* PROCESS   USING    */\n        /**********************/\n        USING_PTR=USING_START;\n        DO WHILE(USING_PTR\u00ac=NULL);\n           IF USING.PLACE >= #OFFSET & USING.PLACE < #OFFSET+I THEN DO;\n              #AZO(REASM02_LINE(#CURI).CMD#);\n              #AZO(REASM02_LINE(#CURI).LABEL#);\n              REASM02_LINE(#CURI).LABEL='';\n              REASM02_LINE(#CURI).OPER='USING';\n              REASM02_LINE(#CURI).OFF='';\n              REASM02_LINE(#CURI).OBJECT='';\n              #AZP(REASM02_LINE(#CURI).OPER#);\n              #AZP(REASM02_LINE(#CURI).OPERANDS#);\n              J=USING.OFF-#OFFSET;\n              IF USING.NAME='' THEN DO;\n                 IF J=0 THEN\n                    REASM02_LINE(#CURI).OPERANDS='*,'||$REGS(USING.REG);\n                 ELSE DO;\n                    LOCVAR=$BH(USING.OFF);      /* 14.09.88 */\n                    DO WHILE(LENGTH(LOCVAR)>1 & SUBSTR(LOCVAR,1,1)='0');\n                       LOCVAR=SUBSTR(LOCVAR,2);\n                    END;\n                    REASM02_LINE(#CURI).OPERANDS=$NEXTEL(CSECT) ||\n                             '+X''' || LOCVAR || ''',' ||\n                             $REGS(USING.REG);\n\n                    IF 1 /*USING.OFF <= USING.PLACE*/ THEN DO;\n                       XLAB = NULL;\n                       LAB  = LABL_START;     /* FIND GOOD LABEL */\n                       DO WHILE(LAB\u00ac=NULL);\n                          IF LAB->LABL.OFF <= USING.OFF THEN DO;\n                             IF XLAB=NULL |\n                              LAB->LABL.OFF > XLAB->LABL.OFF THEN\n                              XLAB=LAB;\n                          END;\n                          LAB = LAB->LABL.NEXT;\n                       END;\n                       IF XLAB\u00ac=NULL THEN DO;\n                         J = USING.OFF-XLAB->LABL.OFF;\n                         IF J<=#ABSA THEN DO;\n                            LOCVAR = '';\n                            IF J>0 THEN LOCVAR = '+' || $DIGIT(J);\n                            REASM02_LINE(#CURI).OPERANDS=\n                                  $NEXTEL(XLAB->LABL.NAME) || LOCVAR ||\n                                  ',' || $REGS(USING.REG);\n                         END;\n                       END;\n                   END;\n                 END;\n              END;\n              ELSE\n                 REASM02_LINE(#CURI).OPERANDS=\n                            $NEXTEL(SUBSTR(USING.NAME,2)) || ',' ||\n                            $REGS(USING.REG);\n              LINE_I(#CURI),LINE_C(#CURI)=0;\n              LINE_O(#CURI)=#OFFSET;\n              CALL $PUTLINE;\n           END;\n           USING_PTR=USING.NEXT;\n        END;\n\n        REASM02_LINE(#CURI)=SLINE, BY NAME;\n\n        LINE_I(#CURI)=I;\n        LINE_O(#CURI)=#OFFSET;\n        LINE_C(#CURI)=0;\n        CALL $PUTCOM(#CURI);\n        CALL $PUTLINE;\n\n        IF $ORGIMM\u00ac='' THEN DO;\n           REASM02_LINE(#CURI).OPER='ORG';\n           REASM02_LINE(#CURI).OPERANDS='*-3';\n           #AZP(REASM02_LINE(#CURI).CMD#);\n           #AZP(REASM02_LINE(#CURI).LABEL#);\n           LINE_I(#CURI),LINE_C(#CURI)=0;\n           LINE_O(#CURI)=I;\n           CALL $PUTLINE;\n           REASM02_LINE(#CURI).OPER='DC';\n           REASM02_LINE(#CURI).OPERANDS=$ORGIMM;\n           CALL $PUTOBJ(#OFFSET+1,1,#CURI);\n           #AZP(REASM02_LINE(#CURI).CMD#);\n           #AZP(REASM02_LINE(#CURI).LABEL#);\n           LINE_I(#CURI),LINE_C(#CURI)=0;\n           LINE_O(#CURI)=I;\n           CALL $PUTLINE;\n           REASM02_LINE(#CURI).OPER='ORG';\n           REASM02_LINE(#CURI).OPERANDS='*+2';\n           #AZP(REASM02_LINE(#CURI).CMD#);\n           #AZP(REASM02_LINE(#CURI).LABEL#);\n           LINE_I(#CURI),LINE_C(#CURI)=0;\n           LINE_O(#CURI)=I;\n           CALL $PUTLINE;\n           $ORGIMM='';\n        END;\n        #OFFSET=#OFFSET+I;\n $AFTER_FIND:                            /* 27.11.87 */\n        IF #CURI=1 & ($FIND | IV = 'PF08') THEN\n           $OFFSET=#OFFSET;\n        OFFSET=$OFFSET;\n        IF #OFFSET >= TEXTLEN THEN DO;\n           CALL PRINT_EXTRN_WXTRN;\n           CALL PRINT_REGEQ_LTORG;\n           CALL PRINT_DSECTS;\n           CALL PRINT_END_STMT;\n\n           IF PRINTBIT THEN DO;\n              PRINTBIT='0'B;\n              OFFSET=FOFFSET;\n              $CONF='0'B;\n              IF $XREF THEN DO;\n                 CALL $PRINT_XREF;\n                 CALL ISPLINK('SETMSG ', 'REAS004 ');/* PRINTED XREF */\n              END;\n              ELSE\n                 CALL ISPLINK('SETMSG ', 'REAS003 ');/* PRINTED */\n              $XREF='0'B;\n              CALL REASLST;\n              GOTO $RETURN_FROM_$SHOW;\n           END;\n           IF SAVEBIT THEN DO;\n              SAVEBIT='0'B;\n              I = REASLIB(SOURCE, 'CLOSE', '');\n              OFFSET=FOFFSET;\n              $CONF='0'B;\n              GOTO $RETURN_FROM_$SHOW;\n           END;\n           IF $FIND THEN DO;  /* FIND WAS ACTIVE BUT UNSUCCESSFUL */\n              $FIND='0'B;\n              #CUR(ZZCMD,1);\n              CALL $CLEAR_SCR;\n              FINDTXT = #FIND;\n              CALL ISPLINK('SETMSG ', 'REAS006 '); /* NOT FOUND */\n              GOTO $RETURN_FROM_$SHOW;\n           END;\n           #OFFSET=0;\n        END;\n     END;\n $RETURN_FROM_$SHOW:\n     RETURN;\n %PAGE;\n /*********************************************************************/\n /*  WRITE STRING ON SCREEN                                           */\n /*********************************************************************/\n $PUTLINE: PROC;\n DCL PRIMARY    CHAR(80) VAR,\n     (T1,T2,T3) CHAR(1),\n     LOCV       CHAR(10) VAR,\n     NN         CHAR(8) VAR,\n     (P,Q,R)    PTR,\n     GLOBAL     BIT(1) INIT('0'B),\n     LINE       CHAR(80) BASED(LINE_PTR),\n     LINE_PTR   PTR,\n     BYTE       CHAR(1),\n     COMMENT    CHAR(80) VAR,\n     (I,II,III,II1,II2,IJ,J,JJ,JJJ,K) BIN FIXED(31);\n\n     IF $XREF THEN DO;\n        LOCVAR=REASM02_LINE(#CURI).OPER;\n        IF LOCVAR\u00ac='' & LOCVAR\u00ac='ENTRY' THEN\n           CALL $PUTXRF(LOCVAR);\n     END;\n\n     IF #CURI >= MAXLVL-3 THEN DO;\n\n        IF PRINTBIT THEN DO;\n           CALL $PUTLINE_PRINT;\n           GOTO $PUTLINE_END;\n        END;\n\n        IF SAVEBIT THEN DO;\n           CALL $PUTLINE_SAVE;\n           GOTO $PUTLINE_END;\n        END;\n\n        IF $FIND THEN DO;\n           DO I=1 TO MAXLVL-3;\n              IF $MATCH THEN J=MATCH(REASM02_CHARL(I),#FIND);\n              ELSE           J=INDEX(REASM02_CHARL(I),#FIND);\n              IF J\u00ac=0 & LINE_O(I) < TEXTLEN THEN DO;\n                 #CUR(SCREEN,(I-1)*80+2);\n                 /* #CUR(REASM02_LINE(I).LABEL#,J+1,NAME); */\n                 #ANP(REASM02_LINE(I).LABEL#);\n                 #AZP(REASM02_LINE(I).OFF#);\n                 BOFFSET = LINE_O(I)+LINE_I(I);\n                 IF LINE_I(I) = 0 THEN BOFFSET=LINE_O(I)+2;\n                 FINDTXT = #FIND;\n                 CALL ISPLINK('SETMSG ','REAS007 ');\n                 $FIND   = '0'B;\n                 CALL $GOODCMD(BOFFSET);\n                 IF (I>LVL) THEN DO;\n                   OFFSET = LINE_O(I);\n                   CALL $CLEAR_SCR;\n                   #AZP(REASM02_LINE(1).OFF#);\n                   REASM02_PRIMARY = ' ';\n                   GOTO $RETURN_FROM_$SHOW;\n                 END;\n                 GOTO CALLTV02;\n              END;\n           END;\n           GOTO $PUTLINE_END;\n        END;\n\n CALLTV02:\n        CALL ISPLINK('DISPLAY ','REASM02 ', ' ');\n\n        COLIN, STRIN = 2;\n        IF FIELD = 'SCREEN' THEN DO;\n           STRIN = POS/80+4;\n           COLIN = POS - (STRIN-4)*80 + 1;\n        END;\n\n        IF PLIRETV() = 8 THEN IV = 'PF03';\n\n        CALL CALCULATE_LVL;\n\n        PRIMARY=REASM02_PRIMARY || (80)' ';\n        DO I=1 TO MAXLVL-3; #AZO(REASM02_LINE(I).OFF#); END;\n\n        #CUR(ZZCMD,1);\n        IF STRIN > 3 THEN DO;\n           #AZP(REASM02_LINE(STRIN-3).OFF#);\n           I = COLIN;\n           IF I<=4 THEN I=3;\n           #CUR(SCREEN,(STRIN-4)*80+I-1);\n        END;\n\n        IF $CONFP &\n           (IV = 'PF03'            |\n            REASM02_PRIMARY = 'E'  |\n            REASM02_PRIMARY= 'END' |\n            REASM02_PRIMARY= 'Y'   ) THEN\n            GOTO $RETURN_FROM_$SHOW;\n        $CONFP='0'B;\n\n        IF IV = 'PF03'  THEN GOTO $RETURN_FROM_$SHOW;\n\n                        /*********************************************/\n                        /*  LINE COMMAND PROCESS SECTION             */\n                        /*********************************************/\n        DO II=1 TO LVL;\n          IF REASM02_LINE(II).CMD\u00ac='' THEN DO;\n             LOCVAR = REASM02_LINE(II).CMD;\n             IF LOCVAR\u00ac='' THEN\n                LOCVAR = SUBSTR(LOCVAR,VERIFY(LOCVAR,' '));\n             LOCVAR = LOCVAR || '   ';\n             T1 = SUBSTR(LOCVAR,1,1);\n             T2 = SUBSTR(LOCVAR,2,1);\n             T3 = SUBSTR(LOCVAR,3,1);\n             IF T1='_' THEN T1=' ';\n             IF T2='_' THEN T2=' ';\n             IF T3='_' THEN T3=' ';\n             IF (T1||T2||T3 \u00ac= '') THEN DO;\n                IF T1= ' ' THEN DO; T1=T2;T2=T3;T3=' '; END;\n                IF T1= ' ' THEN DO; T1=T2;T2=T3;T3=' '; END;\n             END;\n             UNSPEC(T1) = UNSPEC(T1) | UNSPEC(' ');\n             UNSPEC(T2) = UNSPEC(T2) | UNSPEC(' ');\n             UNSPEC(T3) = UNSPEC(T3) | UNSPEC(' ');\n             NN = T2 || T3;\n\n             IF T1='U' THEN DO;            /* LINE USING COMMAND */\n                 IF NN\u00ac='' THEN DO;            /* UXX SPECIFIED */\n                    ON CONV GOTO $LREG;\n                    GET STRING(NN) LIST(J);\n                    REVERT CONV;\n                    IF J<=0 | J>15 THEN DO;\n $LREG:                CALL ISPLINK('SETMSG ','REAS008 '); /* INVREG*/\n                       REVERT CONV;\n                       GOTO $ERR_PRIMARY;\n                    END;\n                    CALL $INITUSING(LINE_O(II),J,LINE_O(II),'',0);\n                    GOTO $LCMD_END;\n                 END;\n                 ELSE DO;         /* USING WITHOUT REGISTER */\n                    REASM02_PRIMARY =\n                    'U '||SUBSTR($BH(LINE_O(II)),3)||',R?';\n                    CALL ISPLINK('SETMSG ','REAS009 '); /* SPECREG */\n                    REASM02_LINE(II).CMD='';\n                    #CUR(ZZCMD,11);\n                    GOTO CALLTV02;\n                 END;\n             END;\n\n             IF T1='D' THEN DO;            /* DROP COMMAND */\n                 IF NN\u00ac='' THEN DO;\n                    ON CONV GOTO $LREG;\n                    GET STRING(NN) LIST(J);\n                    REVERT CONV;\n                    IF J<0 | J>15 THEN GOTO $LREG;\n                    P=NULL;\n                    USING_PTR=USING_START;\n                    DO WHILE(USING_PTR\u00ac=NULL);\n                       IF USING.REG=J &\n                          USING.PLACE < LINE_O(II) THEN DO;\n                          IF P=NULL THEN P=USING_PTR;\n                          ELSE DO;\n                             IF P->USING.PLACE < USING.PLACE THEN\n                                P=USING_PTR;\n                          END;\n                       END;\n                       USING_PTR=USING.NEXT;\n                    END;\n                    IF P=NULL THEN GOTO $LREG;\n                    P->USING.LENGTH=LINE_O(II) - P->USING.PLACE;\n                    Q=LABL_START;\n                    R=NULL;\n                    DO WHILE(Q\u00ac=NULL);\n                       IF Q->LABL.REG = P->USING.REG &\n                          Q->LABL.OFF>P->USING.PLACE+P->USING.LENGTH\n                          THEN DO;\n                          IF R=NULL THEN   LABL_START=Q->LABL.NEXT;\n                                    ELSE R->LABL.NEXT=Q->LABL.NEXT;\n                          FREE Q->LABL;\n                          IF R=NULL THEN   Q=LABL_START;\n                                    ELSE   Q=R->LABL.NEXT;\n                       END;\n                       ELSE DO;\n                          R=Q;\n                          Q=Q->LABL.NEXT;\n                       END;\n                    END;\n                 END;\n                 ELSE DO;\n $DROP_BY_ADR:      P=NULL;\n                    USING_PTR=USING_START;\n                    DO WHILE(USING_PTR\u00ac=NULL);\n                       IF USING.PLACE=LINE_O(II) THEN DO;\n                          IF P=NULL THEN USING_START=USING.NEXT;\n                                    ELSE P->USING.NEXT=USING.NEXT;\n                          FREE USING;\n                          GOTO $DROP_BY_ADR;\n                       END;\n                       P=USING_PTR;\n                       USING_PTR=USING.NEXT;\n                    END;\n                 END;\n                 GOTO $LCMD_END;\n             END;\n\n             IF T1 = 'R' THEN DO;        /* LINE RETRANSLATE */\n                J = LINE_O(II);\n                IF COLIN > 14  &  COLIN < 14+LINE_I(II)*2 THEN DO;\n                   J = J + (COLIN-14)/2;\n                END;\n                GLOBAL = '0'B;\n                GOTO $RETRANSLATE;\n             END;\n\n             I = LINE_I(II);\n             SELECT (T1);\n               WHEN ('X');                           /* HEX     */\n               WHEN ('C');                           /* CHAR    */\n               WHEN ('P');                           /* PACKED  */\n               WHEN ('#');                           /* DS      */\n               WHEN ('B');                           /* BIT     */\n               WHEN ('A','F') DO; I=4; T1='F'; END;  /* WORD    */\n               WHEN ('H','Y')     I=2;               /* HALFWORD*/\n               WHEN ('S')         I=2;               /* S-CONST */\n               OTHER DO;\n                 CALL ISPLINK('SETMSG ','REAS011 '); /* INVTYPE */\n                 GOTO $ERR_PRIMARY;\n               END;\n             END;\n             IF T2='' THEN DO;\n $SETLINE:      CALL $INCLUDE(LINE_O(II),I,T1);\n                IF T1='C' THEN DO;\n                  ICH=0;\n                  DO III=LINE_O(II) BY 1 TO LINE_O(II)+I;\n                     CH = SUBSTRTEXT(III+1,1);\n                     IF SUBSTR(GOODA,ICH+1,1)=HIGH(1) THEN\n                        CALL $INCLUDE(III,1,'X');\n                  END;\n                END;\n             END;\n             ELSE DO;\n                IF T1=T2 THEN DO;    /* BLOCK COMMAND   */\n                   IF PENDING THEN DO;\n                      IF BLOCK_CMD.TYPE\u00ac=T1 THEN DO;\n                         CALL ISPLINK('SETMSG ','REAS012 '); /*DFTYP*/\n                         GOTO $ERR_PRIMARY;\n                      END;\n                      PENDING='0'B;\n                      BLOCK_CMD.O2=LINE_O(II);\n                      K=MIN(BLOCK_CMD.O1,BLOCK_CMD.O2);\n                      J=ABS(BLOCK_CMD.O1-BLOCK_CMD.O2);\n                      IF BLOCK_CMD.O1 > BLOCK_CMD.O2 THEN\n                         J=J+BLOCK_CMD.LEN;\n                      ELSE\n                         J=J+I;\n                      CALL $INCLUDE(K,J,T1);\n                      IF T1='C' THEN DO;\n                        ICH=0;\n                        DO III=K BY 1 TO K+J-1;    /* 14.09.88 */\n                           CH=SUBSTRTEXT(III+1,1);\n                           IF SUBSTR(GOODA,ICH+1,1)=HIGH(1) THEN\n                              CALL $INCLUDE(III,1,'X');\n                        END;\n                      END;\n                   END;\n                   ELSE DO;\n                      BLOCK_CMD.TYPE = T1;\n                      PDFBYTE        = T1;\n                      BLOCK_CMD.O1   = LINE_O(II);\n                      BLOCK_CMD.LEN  = I;\n                      PENDING        = '1'B;\n                   END;\n                END;\n                ELSE DO;\n                   IF T2='L' THEN DO;\n                      I  = $HBF(T3);\n                      IF I<=0 THEN GOTO $ERRL;\n                      IF T1='F' THEN DO;\n                         SELECT (I);\n                            WHEN (1) T1='1';\n                            WHEN (2) T1='H';\n                            WHEN (3) T1='3';\n                            WHEN (4);\n                            OTHER GOTO $ERRL;\n                         END;\n                      END;\n                      IF T1='H' | T1='Y' THEN DO;\n                         SELECT (I);\n                            WHEN (1) T1='1';\n                            WHEN (2);\n                            WHEN (3) T1='3';\n                            WHEN (4) T1='F';\n                            OTHER GOTO $ERRL;\n                         END;\n                      END;\n                      GOTO $SETLINE;\n                   END;\n                   ELSE DO;\n $ERRL:               REVERT CONV;\n                      CALL ISPLINK('SETMSG ','REAS013 '); /*INVCMD*/\n                      GOTO $ERR_PRIMARY;\n                   END;\n                END;\n             END;\n $LCMD_END:\n             REASM02_LINE(II).CMD='';\n          END;\n\n          IF UNSPEC(REASM02_LINE(II).LABEL#) = #MOD THEN DO;\n             IF $DUBLAB(REASM02_LINE(II).LABEL,LINE_O(II)) THEN\n                GOTO L_DUBLAB;\n             CALL $INITLAB(REASM02_LINE(II).LABEL,\n                           LINE_O(II),0,'1'B,LINE_O(II));\n          END;\n\n          IF LINE_C(II)\u00ac=0 THEN DO;\n             BYTE = REASM02_CHAR(II,LINE_C(II));\n             IF UNSPEC(BYTE) = #MOD THEN DO;\n                LINE_PTR=ADDR(REASM02_LINE(II).CMD#);\n                COM_PTR=COM_START;\n                Q=NULL;\n                DO WHILE(COM_PTR\u00ac=NULL);\n                   IF COM.OFF=LINE_O(II) THEN DO;\n                      COM.TXT=SUBSTR(LINE,LINE_C(II)+1);\n                      IF COM.TXT='' THEN DO;\n                         IF Q=NULL THEN COM_START=COM.NEXT;\n                                   ELSE Q->COM.NEXT=COM.NEXT;\n                         FREE COM;\n                      END;\n                      IF $REM THEN\n                         CALL $AUTOREC;\n                      GOTO $OK_COM;\n                   END;\n                   Q=COM_PTR;\n                   COM_PTR=COM.NEXT;\n                END;\n                ALLOCATE COM;\n                COM.NEXT=COM_START;\n                COM_START=COM_PTR;\n                COM.OFF=LINE_O(II);\n                COM.TXT=SUBSTR(LINE,LINE_C(II)+1);\n                IF $REM THEN\n                   CALL $AUTOREC;\n $OK_COM:    END;\n          END;\n        END;\n %SKIP;\n                        /*********************************************/\n                        /*  PRIMARY COMMAND PROCESS                  */\n                        /*********************************************/\n        LOCVAR=$NEXTEL(PRIMARY);\n\n        /* ----------------------------------------------------------*/\n        /* PROCESS '.XXX' COMMAND AS 'Q XXX' FOR BROWSE COMPATIBILITY*/\n        /* ----------------------------------------------------------*/\n        IF  LENGTH(LOCVAR)>0 & SUBSTR(LOCVAR,1,1)='.' THEN DO;\n            IF LENGTH(LOCVAR)>1 THEN\n               PRIMARY = SUBSTR(LOCVAR,2) || ' ' || PRIMARY;\n            ELSE\n               PRIMARY = '';\n            LOCVAR = 'Q';\n        END;\n\n        /* ----------------------------------------------------------*/\n        /* PROCESS 'DSA+XXX=NAME' COMMAND                            */\n        /* ----------------------------------------------------------*/\n L_SET: I = INDEX(LOCVAR,'+');\n        J = INDEX(LOCVAR,'=');\n        IF I>1 & J>1  & I<J-1 THEN DO;\n           LOCV = SUBSTR(LOCVAR,1,I-1);                /* DUMMY NAME */\n           ON CONV GOTO L_WROFF;\n           GET STRING(SUBSTR(LOCVAR,I+1,J-I-1)) LIST(K); /* OFFST    */\n           REVERT CONV;\n           NN = SUBSTR(LOCVAR,J+1);                    /* USER NAME  */\n           IF SUBSTR(LOCV,1,1)\u00ac='@' THEN LOCV = '@' || LOCV;\n           IF $DUBLAB(NN,-1) THEN DO;\n L_DUBLAB:    CALL ISPLINK('SETMSG ','REAS015 '); /*DUP LAB */\n              GOTO $ERR_PRIMARY;\n           END;\n           LBLOCK_PTR = LBLOCK_START;\n           DO WHILE (LBLOCK_PTR\u00ac=NULL);\n              IF LBLOCK.NAME  = LOCV &\n                 LBLOCK.ADR   = 0    THEN DO;\n                 DUMMY_PTR = LBLOCK.ADUMMY;\n                 DO WHILE (DUMMY_PTR\u00ac=NULL);\n                    IF DUMMY.OFF = K THEN DO;\n                       DUMMY.NAME = NN;\n                       PDFCHAR = LOCVAR;\n                       CALL ISPLINK('SETMSG ','REAS016 '); /*... SET */\n                       GOTO $RESHOW;\n                    END;\n                    DUMMY_PTR = DUMMY.NEXT;\n                 END;\n L_WROFF:        PDFCHAR = LOCV;\n                 CALL ISPLINK('SETMSG ','REAS017 '); /*INV DS OFF */\n                 GOTO $ERR_PRIMARY;\n              END;\n              LBLOCK_PTR = LBLOCK.NEXT;\n           END;\n           PDFCHAR = LOCV;\n           CALL ISPLINK('SETMSG ','REAS018 '); /*INV DS NAME */\n           GOTO $ERR_PRIMARY;\n        END;\n\n        SELECT (LOCVAR);\n\n          WHEN  (' ');\n\n          WHEN  ('STOP','CAN','CANCEL') DO;\n            STOP;\n          END;\n          /*\n          WHEN  ('LISTX') DO;\n            CALL  REASLST;\n          END;\n          */\n          WHEN  ('PROF','PROFILE') DO;\n            CALL REASPRF('DISPLAY',       /* UPDT PROFILE VARIABLES */\n                 $AUTO, $DSOFF, $REM, #ABSA, #ABSB, LINELEN, REMTIME,\n                 OS,    PC,     FC );\n          END;\n\n          WHEN  ('SET') DO;\n            LOCVAR = $NEXTEL(PRIMARY);\n            GOTO L_SET;\n          END;\n\n          WHEN  ('O','OFF','OFFSET') DO;\n            LOCVAR=$NEXTEL(PRIMARY);\n            IF LOCVAR='' THEN DO;\n               #ABSA = 12;\n               #ABSB =  8;\n            END;\n            ELSE DO;\n               ON CONV GOTO $ERRA;\n               GET STRING(LOCVAR) LIST(I);\n               REVERT CONV;\n               IF I<0 THEN DO;\n $ERRA:           REVERT CONV;\n                  CALL ISPLINK('SETMSG ', 'REAS019 '); /* INV VAL */\n                  GOTO $ERR_PRIMARY;\n               END;\n               #ABSA,#ABSB = I;\n               IF PRIMARY\u00ac='' THEN DO;\n                  ON CONV GOTO $ERRA;\n                  GET STRING(PRIMARY) LIST(I);\n                  REVERT CONV;\n                  IF I<0 THEN GOTO $ERRA;\n                  #ABSB = I;\n               END;\n            END;\n            OFFSET = $OFFSET;\n            REASM02_PRIMARY = ' ';\n            GOTO $RETURN_FROM_$SHOW;\n          END;\n\n          WHEN  ('#','#SNAP') DO;\n             CALL $PRINTDSC('USER-REQUEST SNAP');\n             CALL ISPLINK('SETMSG ', 'REAS021 '); /* SNAP IS COMPL */\n             OFFSET = $OFFSET;\n             REASM02_PRIMARY = '';\n             GOTO $RETURN_FROM_$SHOW;\n          END;\n\n          WHEN  ('ML','MEMLIST','BL','BLOCKLIST') DO;\n             BLKNAME=REASMLB(CONTROL);\n             OFFSET = $OFFSET;\n             REASM02_PRIMARY = BLKNAME;\n             GOTO $RETURN_FROM_$SHOW;\n          END;\n\n          WHEN  ('E','END','EXIT','QUIT') DO;\n            IV = 'PF03';\n            GOTO $RETURN_FROM_$SHOW;\n          END;\n\n          WHEN  ('F','FIND') DO;\n            LOCVAR = PRIMARY;\n            IF LOCVAR = '' THEN DO;\n               IF #FIND = '' THEN DO;\n                  CALL ISPLINK('SETMSG ', 'REAS022 '); /* REQSTR MIS */\n                  REASM02_PRIMARY='F ?';\n                  #CUR(ZZCMD,3);\n                  GOTO $ERR_PRIMARY;\n               END;\n            END;\n            ELSE DO;\n               DO WHILE(SUBSTR(LOCVAR,1,1)=' ');  /* CUT LEAD BLANKS */\n                  LOCVAR = SUBSTR(LOCVAR,2);\n               END;\n               DO WHILE(SUBSTR(LOCVAR,LENGTH(LOCVAR),1)=' '); /* TAIL */\n                  LOCVAR = SUBSTR(LOCVAR,1,LENGTH(LOCVAR)-1);\n               END;\n               #FIND  = LOCVAR;\n               $MATCH = '0'B;\n               IF INDEX(#FIND,'*')\u00ac=0 |  INDEX(#FIND,'%')\u00ac=0 |\n                  INDEX(#FIND,'?')\u00ac=0 THEN DO;\n                  #FIND='*' || #FIND || '*';\n                  $MATCH='1'B;\n               END;\n            END;\n            $FIND           = '1'B;\n            REASM02_PRIMARY = ' ';\n            IF STRIN>3 THEN\n               OFFSET  = LINE_O(STRIN-3)+LINE_I(STRIN-3);\n            ELSE\n               OFFSET  = LINE_O(1)+LINE_I(1);\n            CALL $CLEAR_SCR;\n            FOFFSET = OFFSET;\n            BOFFSET = OFFSET;\n            $OFFSET = OFFSET;\n            #OFFSET = OFFSET;\n            GOTO $RETURN_FROM_$SHOW;\n          END;\n\n          WHEN  ('M','MAX') DO;\n              CALL ISPLINK('SETMSG ', 'REAS023 '); /* PRESS UP/D */\n              #CUR(ZZCMD,1);\n              GOTO $ERR_PRIMARY;\n $RESHOW:     REASM02_PRIMARY = ' ';\n              GOTO $RETURN_FROM_$SHOW;\n          END;\n\n          WHEN  ('T','TRACE') DO;\n            $TRACE=\u00ac$TRACE;\n            REASM02_PRIMARY = ' ';\n            IF $TRACE THEN\n               CALL ISPLINK('SETMSG ', 'REAS024 '); /* TRACE ON */\n            ELSE\n               CALL ISPLINK('SETMSG ', 'REAS025 '); /* TRACE ON */\n            #CUR(ZZCMD,1);\n            OFFSET=$OFFSET;\n            GOTO $RETURN_FROM_$SHOW;\n          END;\n\n          WHEN  ('DS','DSECT') DO;\n            LOCVAR=$NEXTEL(PRIMARY);\n            SELECT (LOCVAR);\n               WHEN ('N','NAME')         $DSOFF='0'B;\n               WHEN ('OFFSET','OFF','O') $DSOFF='1'B;\n               OTHER                     $DSOFF=\u00ac$DSOFF;\n            END;\n            REASM02_PRIMARY = ' ';\n            IF $DSOFF THEN\n               CALL ISPLINK('SETMSG ', 'REAS026 '); /* DS OFF */\n            ELSE\n               CALL ISPLINK('SETMSG ', 'REAS027 '); /* DS NAM */\n            #CUR(ZZCMD,1);\n            OFFSET=$OFFSET;\n            GOTO $RETURN_FROM_$SHOW;\n          END;\n          WHEN  ('A','AUTO') DO;\n            LOCVAR=$NEXTEL(PRIMARY);\n            SELECT (LOCVAR);\n               WHEN ('ON')  $AUTO='1'B;\n               WHEN ('OFF') $AUTO='0'B;\n               OTHER        $AUTO=\u00ac$AUTO;\n            END;\n            REASM02_PRIMARY = ' ';\n            IF $AUTO THEN\n               CALL ISPLINK('SETMSG ', 'REAS028 '); /* AU ON */\n            ELSE\n               CALL ISPLINK('SETMSG ', 'REAS029 '); /* AU OFF */\n            #CUR(ZZCMD,1);\n            OFFSET=$OFFSET;\n            GOTO $RETURN_FROM_$SHOW;\n          END;\n\n          WHEN  ('Q','QUALIFY','QFY','MARK') DO;\n            LOCVAR=$NEXTEL(PRIMARY);\n            IF LENGTH(LOCVAR) > 8 THEN DO;\n               CALL ISPLINK('SETMSG ', 'REAS031 '); /* INVMARK */\n               #CUR(ZZCMD,1);\n               GOTO $ERR_PRIMARY;\n            END;\n            IF LOCVAR = '' THEN DO;\n               OFFSET = REASQFY(QUALIFY_START);\n               IF OFFSET < 0 THEN  OFFSET = $OFFSET;\n               IV = ' ';\n               GOTO $FORM_REASM02;\n            END;\n            QUALIFY_PTR=QUALIFY_START;\n            DO WHILE(QUALIFY_PTR\u00ac=NULL);\n               IF QUALIFY.NAME=LOCVAR THEN DO;\n                  QUALIFY.OFF = $OFFSET;\n                  QUALIFY.DESC   = PRIMARY;\n                  CALL ISPLINK('SETMSG ', 'REAS032 '); /* MARKUPD */\n                  GOTO $QUALIFY_EXIT;\n               END;\n               QUALIFY_PTR=QUALIFY.NEXT;\n            END;\n            ALLOCATE QUALIFY;\n            QUALIFY.NEXT   = QUALIFY_START;\n            QUALIFY_START  = QUALIFY_PTR;\n            QUALIFY.NAME   = LOCVAR;\n            QUALIFY.OFF = $OFFSET;\n            QUALIFY.DESC   = PRIMARY;\n            CALL ISPLINK('SETMSG ', 'REAS033 '); /* MARKUPD */\n $QUALIFY_EXIT: REASM02_PRIMARY='';\n            #CUR(ZZCMD,1);\n            OFFSET=$OFFSET;\n            GOTO $RETURN_FROM_$SHOW;\n          END;\n          WHEN  ('L','LI','LOCATE','LINESIZE') DO;\n            BOFFSET=0;\n            PRIMARY=$NEXTEL(PRIMARY);   /* OPERAND */\n            IF PRIMARY\u00ac='' THEN DO;\n               I=$HB(PRIMARY);\n               SELECT (SUBSTR(REASM02_PRIMARY,2,1));\n                 WHEN  ('I') DO;       /* LINE */\n                   IF I <=0 | I > 32 THEN DO;\n                      CALL ISPLINK('SETMSG ', 'REAS034 '); /* INVLEN */\n                      #CUR(ZZCMD,1);\n                      GOTO $ERR_PRIMARY;\n                   END;\n                   LINELEN=I;\n $SETLINELEN:      OFFSET=$OFFSET;\n                   REASM02_PRIMARY = ' ';\n                   CALL $CLEAR_SCR;\n                   GOTO $RETURN_FROM_$SHOW;\n                 END;\n                 OTHER DO;\n                   LABL_PTR=LABL_START;\n                   DO WHILE(LABL_PTR\u00ac=NULL);\n                      IF LABL.NAME=PRIMARY THEN DO;\n                         I=LABL.OFF;\n                         CALL ISPLINK('SETMSG ', 'REAS035 ');\n                      END;\n                      LABL_PTR=LABL.NEXT;\n                   END;\n                   QUALIFY_PTR=QUALIFY_START;\n                   DO WHILE(QUALIFY_PTR\u00ac=NULL);\n                      IF QUALIFY.NAME=PRIMARY THEN DO;\n                         I=QUALIFY.OFF;\n                         CALL ISPLINK('SETMSG ', 'REAS035 ');\n                      END;\n                      QUALIFY_PTR=QUALIFY.NEXT;\n                   END;\n                   IF I < 0 | I > TEXTLEN THEN DO;\n                      CALL ISPLINK('SETMSG ', 'REAS036 '); /*INVOFF*/\n                      #CUR(ZZCMD,1);\n                      GOTO $ERR_PRIMARY;\n                   END;\n                   OFFSET=I;\n                   IF I\u00ac=0 THEN DO;\n                      CALL $FINDDSC(OFFSET);\n                      IF DSC.TYPE='I' THEN DO;\n                         I=0;\n                         IF MOD(#OFFSET,2)\u00ac=0 THEN\n                            #OFFSET=#OFFSET-1;\n                         DO WHILE(DSC.OFF+I < OFFSET); /* ||| */\n                            CMD_PTR=ADDRTEXT();\n                            #CMD_PTR=#CMD_PTR+2+DSC.OFF+I;\n                            I=I+CMDLEN(CMDDEF);\n                         END;\n                         OFFSET=DSC.OFF+I;\n                      END;\n                   END;\n                   CALL $CLEAR_SCR;\n                   REASM02_PRIMARY = ' ';\n                   GOTO $RETURN_FROM_$SHOW;\n                 END;\n               END;\n            END;\n          END;\n          WHEN  ('U','US','USING') DO;\n             IF PRIMARY='' THEN DO;\n                CALL ISPLINK('SETMSG ', 'REAS037 '); /*MISSOP*/\n                #CUR(ZZCMD,1);\n                GOTO $ERR_PRIMARY;\n             END;\n             LOCVAR=$NEXTEL(PRIMARY);\n\n             IF LOCVAR = '?' THEN DO;      /* MEMBERLIST ? */\n                LOCVAR = REASMLB(CONTROL);\n             END;\n\n             IF SUBSTR(LOCVAR,1,1)='@' THEN DO;    /* @NAME */\n                IF LENGTH(LOCVAR)<2 | LENGTH(LOCVAR)>9 THEN DO;\n                   CALL ISPLINK('SETMSG ', 'REAS038 '); /*INVBLK*/\n                   #CUR(ZZCMD,1);\n                   GOTO $ERR_PRIMARY;\n                END;\n                NN=LOCVAR;\n                I=0;\n             END;\n             ELSE DO;                             /*LOCATION*/\n                NN='';\n                IF LOCVAR='*' THEN I=$OFFSET;\n                ELSE DO;\n                  IF SUBSTR(LOCVAR,LENGTH(LOCVAR),1)=')' THEN DO;\n                     LOCV=LOCVAR;\n                     LOCVAR='';\n                     DO J=1 TO LENGTH(LOCV)\n                        WHILE(SUBSTR(LOCV,1,1)\u00ac='(');\n                        LOCVAR=LOCVAR || SUBSTR(LOCV,1,1);\n                        LOCV=SUBSTR(LOCV,2);\n                     END;\n                     LOCV=SUBSTR(LOCV,2,LENGTH(LOCV)-2);\n                     IF LOCV='' THEN\n                        GOTO $ERR_BREG;\n                     IF SUBSTR(LOCV,1,1)='R' & LENGTH(LOCV)>1 THEN\n                        LOCV=SUBSTR(LOCV,2);\n                     ON CONV GOTO $ERR_BREG;\n                     GET STRING(LOCV) LIST(J);\n                     IF J<=0 | J>15 THEN DO;\n $ERR_BREG:             REVERT CONV;\n                        CALL ISPLINK('SETMSG ', 'REAS039 '); /*INVREF*/\n                        #CUR(ZZCMD,1);\n                        GOTO $ERR_PRIMARY;\n                     END;\n                     USING_PTR=USING_START;\n                     DO WHILE(USING_PTR\u00ac=NULL);\n                        IF USING.REG=J & USING.NAME='' THEN LEAVE;\n                        USING_PTR=USING.NEXT;\n                     END;\n                     IF USING_PTR=NULL THEN GOTO $ERR_BREG;\n                     GET STRING(LOCVAR) LIST(I);\n                     REVERT CONV;\n                     I=I+USING.OFF;\n                     GOTO $TEST_FORW;\n                  END;\n                  I=$HB(LOCVAR);\n                  IF LOCVAR\u00ac='0' THEN\n                     IF I <= 0 | I > TEXTLEN THEN DO;\n                        CALL ISPLINK('SETMSG ', 'REAS041 '); /*INVOFF*/\n                        #CUR(ZZCMD,1);\n                        GOTO $ERR_PRIMARY;\n                     END;\n                END;\n             END;\n $TEST_FORW: LOCVAR=$NEXTEL(PRIMARY);\n             IF LENGTH(LOCVAR) > 1 & SUBSTR(LOCVAR,1,1)='R' THEN\n                LOCVAR=SUBSTR(LOCVAR,2);\n             ON CONV GOTO $ERR_REG;\n             IF LOCVAR = '' THEN GOTO $ERR_REG;\n             GET STRING(LOCVAR) LIST(J);\n             REVERT CONV;\n             IF J < 0 | J > 15 THEN DO;      /* 04/23/91 */\n $ERR_REG:      REVERT CONV;\n                CALL ISPLINK('SETMSG ', 'REAS042 '); /*INVREG*/\n                #CUR(ZZCMD,1);\n                GOTO $ERR_PRIMARY;\n             END;\n             LOCVAR=$NEXTEL(PRIMARY);\n             IF LOCVAR='' | LOCVAR='*' THEN DO;\n                K = I;\n                IF STRIN > 3 THEN K=LINE_O(STRIN-3);\n             END;\n             ELSE DO;\n                K=$HB(LOCVAR);\n                IF LOCVAR='0' THEN\n                   K=0;\n                ELSE DO;\n                   IF K<=0 | K>TEXTLEN THEN DO;\n                      CALL ISPLINK('SETMSG ', 'REAS043 '); /*INVPLC*/\n                      GOTO $ERR_PRIMARY;\n                   END;\n                END;\n             END;\n             CALL $INITUSING(I,J,K,NN,0);\n             GOTO $RESHOW;\n          END;\n          WHEN  ('D','DROP') DO;                       /* DROP */\n            IF PRIMARY='' THEN DO;\n               CALL ISPLINK('SETMSG ', 'REAS044 '); /*MISSOP*/\n               #CUR(ZZCMD,1);\n               GOTO $ERR_PRIMARY;\n            END;\n            LOCVAR=$NEXTEL(PRIMARY);\n            IF LOCVAR='ALL' THEN DO;\n               DO J=1 TO 15;\n                  CALL $DROP(J);\n               END;\n               DO WHILE(QUALIFY_START\u00ac=NULL);\n                  QUALIFY_PTR=QUALIFY_START;\n                  QUALIFY_START=QUALIFY.NEXT;\n                  FREE QUALIFY;\n               END;\n            END;\n            ELSE DO;\n               P=NULL;\n               QUALIFY_PTR=QUALIFY_START;\n               DO WHILE(QUALIFY_PTR\u00ac=NULL);\n                  IF QUALIFY.NAME=LOCVAR THEN DO;\n                     IF P=NULL THEN QUALIFY_START=QUALIFY.NEXT;\n                               ELSE P->QUALIFY.NEXT=QUALIFY.NEXT;\n                     FREE QUALIFY;\n                  END;\n                  P=QUALIFY_PTR;\n                  QUALIFY_PTR=QUALIFY.NEXT;\n                  GOTO $DROP_END;\n               END;\n               IF SUBSTR(LOCVAR,1,1)='R' & LENGTH(LOCVAR)>1 THEN\n                  LOCVAR=SUBSTR(LOCVAR,2);\n               ON CONV GOTO $ERR_DROP;\n               GET STRING(LOCVAR) LIST(J);\n               REVERT CONV;\n               IF J<0 | J>15 THEN DO;\n $ERR_DROP:       REVERT CONV;\n                  CALL ISPLINK('SETMSG ', 'REAS045 '); /*INVREG*/\n                  #CUR(ZZCMD,1);\n                  GOTO $ERR_PRIMARY;\n               END;\n               CALL $DROP(J);\n            END;\n $DROP_END:\n          END;\n          WHEN  ('RES','RESET') DO;\n            PENDING='0'B;\n            GOTO $RESHOW;\n          END;\n          WHEN  ('TOP', 'UP MAX')\n            GOTO TOP;\n          WHEN  ('BOTTOM', 'DOWN MAX')\n            GOTO BOTTOM;\n          WHEN  ('REC','RECOVERY') DO;\n               LOCVAR=$NEXTEL(PRIMARY);\n               LOCV='C';                  /* <CREATE> */\n               IF LOCVAR='LIB' THEN DO;\n                  LOCV='L';               /* <CREATE LIB> */\n                  LOCVAR=$NEXTEL(PRIMARY);\n                  I = REASMRC(SAVE,'L');\n                  MEMSAVE=CSECT;\n                  CALL $REALLOC(SAVE,DSNSAVE,MEMSAVE,'');\n                  DSRG=PO;\n               END;\n               IF LOCVAR='OFF' THEN LOCVAR='0';\n               IF LOCVAR='' THEN\n                  CALL REASMS('1'B,LOCV);\n               ELSE DO;\n                  ON CONV GOTO $ERRREM;\n                  GET STRING(LOCVAR) LIST(I);\n                  REVERT CONV;\n                  IF I<0 THEN DO;\n $ERRREM:            REVERT CONV;\n                     CALL ISPLINK('SETMSG ', 'REAS046 '); /*INVREG*/\n                     GOTO $ERR_PRIMARY;\n                  END;\n                  IF I\u00ac=0 THEN DO;\n                     REMTIME=I;\n                     $REM='1'B;\n                     REMCOUNT=0;\n                     CALL REASMS('1'B,LOCV);\n                  END;\n                  ELSE\n                     $REM='0'B;\n               END;\n               GOTO $RESHOW;\n         END;\n         WHEN ('R','RETRANSLATE') DO;\n            J = $OFFSET;                             /** RETRANSLATE**/\n            GLOBAL = '0'B;\n            LOCVAR = $NEXTEL(PRIMARY);\n            IF LOCVAR \u00ac= '' THEN DO;\n               IF SUBSTR(LOCVAR,1,1) = 'G' THEN GLOBAL='1'B;\n               ELSE DO;\n                  J = $HB(LOCVAR);\n                  IF J=0 & LOCVAR\u00ac='0' THEN DO;\n                     CALL ISPLINK('SETMSG ', 'REAS047 '); /*INVOFF*/\n                     #CUR(ZZCMD,1);\n                     GOTO $ERR_PRIMARY;\n                  END;\n                  LOCVAR=$NEXTEL(PRIMARY);\n                  IF LOCVAR\u00ac='' & SUBSTR(LOCVAR,1,1)='G' THEN\n                     GLOBAL='1'B;\n               END;\n            END;\n $RETRANSLATE:\n            K=0; /* LENGTH */\n            JJ=J; /* START */\n            IF MOD(JJ,2)\u00ac=0 THEN /* MAKE ADDR EVEN */\n               JJ=JJ+1;\n            IF J > TEXTLEN-1 THEN /* JUMPED OVER BORDER ?      */\n               GOTO $TEST_GLOBAL;  /* PIECE COMPLETE           */\n            CALL $FINDDSC(J);      /* WHERE WE ARE ???         */\n            IF DSC.NORED THEN      /* FIXED PART ?             */\n               GOTO $TEST_GLOBAL;  /* PIECE COMPLETE           */\n          /*$NOOP='1'B */          /* NO OPERANDS PROCESS (SPEED) */\n            CALL $CMD(J,1);        /* COMMAND IN FIRST LINE    */\n            $NOOP='0'B;            /* PROCESS OPERANDS         */\n            IF USING_START=NULL & $AUTO THEN /* BASE NECESSARY ? */\n               CALL $TESTUS(J);    /* TEST SET BASE REG        */\n            DO WHILE(REASM02_LINE(1).OPER\u00ac='' & J < TEXTLEN);\n               I=CMDLEN(CMDDEF);   /* COMMAND LENGTH           */\n               J=J+I;              /* INCREMENT OFFSET         */\n               K=K+I;              /* INCREMENT LENGTH         */\n               IF J > TEXTLEN-1 THEN /* OVER BORDER?           */\n                  GOTO $TEST_GLOBAL; /* FINISH PIECE           */\n               CALL $FINDDSC(J);   /* WHERE WE ARE NOW ?       */\n               IF (DSC.OFF+DSC.LENGTH-J < I) | DSC.NORED THEN\n                  GOTO $TEST_GLOBAL; /* ||||| */\n             /*$NOOP='1'B */\n               CALL $CMD(J,1);\n               $NOOP='0'B;\n               IF USING_START=NULL & $AUTO THEN\n                  CALL $TESTUS(J);\n            END;\n $TEST_GLOBAL:\n            IF K\u00ac=0 THEN             /* LENGTH EXISTS        */\n               CALL $INCLUDE(JJ,K,'I');\n            IF GLOBAL THEN DO;       /* GLOBAL STATUS        */\n               J=MAX(JJ+K,#FORWARD); /* TRY GO FORWARD MAX   */\n               IF MOD(J,2)\u00ac=0 THEN   /* ROUND TO             */\n                  J=J+1;             /*    4                 */\n               IF MOD(J,4)\u00ac=0 THEN   /*    FORWARD           */\n                  J=J+2;             /*                      */\n               IF J>TEXTLEN THEN     /* DO NO JUMP TOO       */\n                  J=TEXTLEN;         /*    FAR AWAY          */\n               II1,II2=0;\n               DO III=JJ+K BY 1 TO J WHILE(III < J);\n                  ICH=0;\n                  CH=SUBSTRTEXT(III+1,1);\n                  II1=II1+1;\n                  IF SUBSTR(GOODA,ICH+1,1)\u00ac=HIGH(1) THEN\n                     II2=II2+1;\n               END;\n               IF II1=II2 & $AUTO THEN\n                  CALL $INCLUDE(JJ+K,II2,'C');\n               DO J=J BY 4 WHILE(J < TEXTLEN);\n                  CALL $FINDDSC(J);    /* SET KUDA NADO       */\n                  IF DSC.NORED THEN    /* SKIP OVER           */\n                     J=DSC.OFF+DSC.LENGTH-4;\n                  ELSE DO;             /* TRY MAKE COMMAND    */\n                   /*$NOOP='1'B */\n                     CALL $CMD(J,1);\n                     $NOOP='0'B;\n                     IF REASM02_LINE(1).OPER\u00ac='' THEN /* OK    ||| */\n                        GOTO $RETRANSLATE; /* START FROM HERE      */\n                     LOCVAR='';\n                     ICH=0;\n                     DO JJJ=J TO J+3;   /* 26.11.87 */\n                        CH=SUBSTRTEXT(JJJ+1,1);\n                        LOCVAR=LOCVAR || SUBSTR(GOODA,ICH+1,1);\n                     END;\n                     IF INDEX(LOCVAR,HIGH(1))=0 & $AUTO THEN\n                        CALL $INCLUDE(J,4,'C');\n                  END;\n               END;\n            END;\n\n            OFFSET=$OFFSET;\n            REASM02_PRIMARY = ' ';\n            CALL $CLEAR_SCR;\n            GOTO $RETURN_FROM_$SHOW;\n          END;\n          WHEN  ('P','PRINT') DO;\n             LOCVAR=$NEXTEL(PRIMARY);\n             IF LOCVAR='XREF' | LOCVAR='X' THEN DO;\n                XREF_START=NULL;\n                $XREF='1'B;                   /* 08.12.87 */\n             END;\n             PRINTBIT='1'B;\n             PRINTNUM=0;\n             FOFFSET=$OFFSET;\n             #PAGE=0;\n             SIGNAL ENDPAGE(SYSPRINT);\n             OFFSET=0;\n             REASM02_PRIMARY = ' ';\n             CALL $CLEAR_SCR;\n             GOTO $RETURN_FROM_$SHOW;\n          END;\n          WHEN  ('S','SAVE') DO;\n            LOCVAR=$NEXTEL(PRIMARY);\n            REASM02_PRIMARY = ' ';\n            IF LOCVAR\u00ac='' THEN  MEMOUT=LOCVAR;\n            ELSE                MEMOUT=CSECT;\n            IF MEMOUT='' THEN   MEMOUT='TEMPNAME';\n            I = REASLIB(SOURCE, 'OPEN', MEMOUT);\n            IF I\u00ac=0 THEN DO;\n               OFFSET=$OFFSET;\n               GOTO $RETURN_FROM_$SHOW;\n            END;\n\n            #CARD='';\n            CARD.LABEL = '*';\n            CARD.OPER  = '';\n            CARD.OPERANDS='* MVS/ESA REASM ' || REASMVER;\n            CARDNUM    = 10000;\n            I = REASLIB(SOURCE, 'WRITE', #CARD);\n            CARD.LABEL='*';\n            CARD.OPER='';\n            LOCVAR=SUBSTR(REASM02_DSN,VERIFY(REASM02_DSN,' '));\n            IF LENGTH(LOCVAR) > 50 THEN\n               LOCVAR=SUBSTR(LOCVAR,1,50);\n            CARD.OPERANDS=LOCVAR;\n            CARDNUM=20000;\n            I = REASLIB(SOURCE, 'WRITE', #CARD);\n            SAVEBIT='1'B;\n            FOFFSET=$OFFSET;\n            OFFSET=0;\n            CALL $CLEAR_SCR;\n            SAVENUM=20000;\n            GOTO $RETURN_FROM_$SHOW;\n          END;\n          OTHER DO;\n            CALL ISPLINK('SETMSG ', 'REAS049 '); /*INVCMD*/\n            #CUR(ZZCMD,1);\n $ERR_PRIMARY:\n            GOTO CALLTV02;\n          END;\n        END;\n %SKIP;\n                        /*********************************************/\n                        /*  FUNCTIONAL KEY PROCESS                   */\n                        /*********************************************/\n     SELECT (IV);\n\n       WHEN ('PF07') DO;  /* UP */\n            SELECT (SCROLL);\n               WHEN ('MAX') DO;\n TOP:            OFFSET, BOFFSET = 0;\n               END;\n               WHEN ('HALF') OFFSET = $OFFSET-4*(LVL/2);\n               WHEN ('PAGE') OFFSET = $OFFSET-4*LVL;\n               OTHER DO;\n                  I = STRIN-3;\n                  IF I > 0 THEN DO;\n                     IF STRIN=LVL+3 THEN DO;\n                        #CUR(ZZCMD,1);\n                        OFFSET = $OFFSET-4*LVL;\n                     END;\n                     ELSE DO;\n                        #CUR(SCREEN,(LVL-1)*80+COLIN-1);\n                        OFFSET = LINE_O(I)-4*LVL;\n                     END;\n                  END;\n                  ELSE\n                     OFFSET=$OFFSET-4*LVL;\n               END;\n            END;\n            DO I=1 TO MAXLVL-3;\n               #AZO(REASM02_LINE(I).OFF#);\n            END;\n            CALL $GOODCMD(OFFSET);\n            CALL $CLEAR_SCR;\n            GOTO $RETURN_FROM_$SHOW;\n       END;\n\n       WHEN ('PF08') DO; /* DOWN */\n            IF OFFSET >= TEXTLEN THEN DO;\n               CALL $CLEAR_SCR;\n               GOTO $PUTLINE_END;\n            END;\n            SELECT (SCROLL);\n               WHEN ('MAX') DO;\n BOTTOM:         BOFFSET = 0;\n                 OFFSET  = TEXTLEN-4*LVL;\n                 #CUR(ZZCMD,1);\n                 CALL $GOODCMD(OFFSET);\n               END;\n               WHEN ('PAGE') DO;\n PF08_PAGE:      I = LINE_O(LVL)+LINE_I(LVL);\n                 IF OFFSET=I THEN OFFSET = I+1;\n                 ELSE             OFFSET = I;\n                 #CUR(ZZCMD,1);\n               END;\n               WHEN ('HALF') DO;\n                 OFFSET = LINE_O(LVL/2+1);\n                 #CUR(ZZCMD,1);\n               END;\n               OTHER DO;  /* CSR */\n                  I = STRIN-4;\n                  IF I>0 THEN DO;\n                     OFFSET = LINE_O(I);\n                     #CUR(SCREEN,COLIN);\n                     CALL $GOODCMD(OFFSET);\n                  END;\n                  ELSE  GOTO PF08_PAGE;\n               END;\n            END;\n            CALL $CLEAR_SCR;\n            GOTO $RETURN_FROM_$SHOW;\n       END;\n       WHEN ('PF19')\n         GOTO TOP;\n       WHEN ('PF20')\n         GOTO BOTTOM;\n       OTHER\n         GOTO $RESHOW;\n     END;\n\n %SKIP;\n $PUTLINE_END:\n        CALL $CLEAR_SCR;\n        #CURI = 0;\n     END;\n     #CURI=#CURI+1;\n\n /*************/\n /* PRINTLINE */\n /*************/\n $PUTLINE_PRINT: PROC ;\n DCL (PRIV,BRANCH)  CHAR(1),\n     (I,J);\n\n    DO I=1 TO MAXLVL-3;\n       IF REASM02_LINE(I).OPER\u00ac='' |\n          REASM02_LINE(I).OPERANDS\u00ac='' THEN DO;\n          IF SUBSTR(REASM02_LINE(I).LABEL,1,1)='*' &\n             REASM02_LINE(I).OPER\u00ac='EQU' THEN\n             REASM02_LINE(I).LABEL='';       /* 08.12.87 */\n          LINE_PTR=ADDR(REASM02_LINE(I).CMD#);\n          COMMENT = #SCRCOM(I);\n          IF LINE_C(I)\u00ac=0 THEN SUBSTR(LINE,LINE_C(I))=' ';\n          PRINTNUM=PRINTNUM+1;\n          PRIV, BRANCH = ' ';\n          IF REASMCM(@, REASM02_LINE(I).OPER, 'PRIV') THEN\n             PRIV   = '*';\n          IF REASMCM(@, REASM02_LINE(I).OPER, 'BRANCH') THEN\n             BRANCH = '-';\n          PUT SKIP EDIT(\n            PRIV,\n            REASM02_LINE(I).OFF,\n            REASM02_LINE(I).OBJECT,\n            PRINTNUM,\n            REASM02_LINE(I).LABEL,\n            BRANCH,\n            REASM02_LINE(I).OPER,\n            REASM02_LINE(I).OPERANDS)\n            (A(1),X(1),A,X(1),A,X(5),F(4),X(2),A,A(1),A,X(1),A);\n\n      /*  IF REASMCM(@, REASM02_LINE(I).OPER, 'USING') THEN\n             PUT SKIP(0) EDIT(\n                 PRIV,\n                 REASM02_LINE(I).OFF,\n                 REASM02_LINE(I).OBJECT,\n                 PRINTNUM,\n                 REASM02_LINE(I).LABEL,\n                 BRANCH,\n                 REASM02_LINE(I).OPER,\n                 REASM02_LINE(I).OPERANDS)\n                 (A(1),X(1),A,X(1),A,X(5),F(4),X(2),A,A(1),A,X(1),A);*/\n\n          DO WHILE(LENGTH(COMMENT)>1 &\n                   (SUBSTR(COMMENT,1,1)=' ' | SUBSTR(COMMENT,1,1)='/'));\n             COMMENT = SUBSTR(COMMENT,2);\n          END;\n          IF COMMENT \u00ac= '' THEN DO;\n             COMMENT = '/* ' || COMMENT;\n             IF LENGTH(COMMENT)>40 THEN COMMENT=SUBSTR(COMMENT,1,40);\n             DO J=1 TO 2;\n           /*   PUT SKIP(0) EDIT(COMMENT) (COL(80), A); */\n             END;\n          END;\n       END;\n    END;\n END $PUTLINE_PRINT;\n\n /*************/\n /* SAVETLINE */\n /*************/\n $PUTLINE_SAVE: PROC ;\n    DCL (I, J, POS)  BIN FIXED;\n    DCL APOS BIN FIXED INIT(60);\n\n    DO I=1 TO MAXLVL-3;\n       LINE_PTR=ADDR(REASM02_LINE(I).CMD#);\n       IF LINE_C(I)\u00ac=0 THEN DO;\n          J = LINE_C(I);\n          SUBSTR(LINE,J,1)=' ';\n          POS = J - 44;\n       END;\n       #CARD='';\n       IF SUBSTR(REASM02_LINE(I).LABEL,1,1)='*' &\n          REASM02_LINE(I).OPER\u00ac='EQU' THEN\n          REASM02_LINE(I).LABEL='';       /* 08.12.87 */\n\n       CARD.LABEL    = REASM02_LINE(I).LABEL;\n       CARD.OPER     = REASM02_LINE(I).OPER;\n       CARD.OPERANDS = REASM02_LINE(I).OPERANDS;\n       CARD.CONTPOS  = ' ';\n       IF #CARD\u00ac='' THEN DO;\n          SAVENUM = SAVENUM+10000;\n          CARDNUM = SAVENUM;\n          J = REASLIB(SOURCE, 'WRITE', #CARD);\n       END;\n    END;\n END $PUTLINE_SAVE;\n\n END $PUTLINE;\n %SKIP;\n /*********************************************************************/\n /*  FILL LABEL IN IT'S  PLACE                                        */\n /*********************************************************************/\n $LABEL:\n     PROC(OFF,LEN);\n DCL J    BIN FIXED,\n     1 SLINE LIKE REASM02_LINE,\n     $MOVE BIT(1) INIT('0'B),\n     OFF BIN FIXED(31),\n     LEN BIN FIXED(31);\n\n     IF ALL(PASS='') THEN DO;\n        ON ERROR STOP;\n        PUT SKIP LIST('UNAUTHORIZED COPY. EXECUTION PROHIBITED');\n        STOP;\n     END;\n\n     REASM02_LINE(#CURI).LABEL=''; /* START FROM BLANK   */\n     LABL_PTR=LABL_START;\n     DO WHILE(LABL_PTR\u00ac=NULL);\n        IF OFF      = LABL.OFF THEN LEAVE; /* COMPARED     ? */\n        LABL_PTR=LABL.NEXT;\n     END;\n     IF LABL_PTR\u00ac=NULL THEN DO;\n        REASM02_LINE(#CURI).LABEL=LABL.NAME;\n        IF LABL.NORED THEN\n           #AZP(REASM02_LINE(#CURI).LABEL#);\n     END;\n\n     LABL_PTR=LABL_START;\n     DO WHILE(LABL_PTR\u00ac=NULL);\n        IF OFF     <= LABL.OFF & OFF+LEN >     LABL.OFF THEN DO;\n           IF \u00ac$MOVE THEN\n              SLINE=REASM02_LINE(#CURI), BY NAME;\n           $MOVE='1'B;\n           IF LABL.NAME\u00ac=SLINE.LABEL THEN DO;\n              REASM02_LINE(#CURI).OBJECT='';\n              REASM02_LINE(#CURI).OFF='';\n              REASM02_LINE(#CURI).LABEL=LABL.NAME;\n              REASM02_LINE(#CURI).OPER='EQU';\n              REASM02_LINE(#CURI).OPERANDS=\n                      '*+' || $DIGIT(LABL.OFF-OFF);\n              #AZO(REASM02_LINE(#CURI).CMD#);\n              IF LABL.NORED THEN\n                 #AZO(REASM02_LINE(#CURI).LABEL#);\n              ELSE\n                 IF SUBSTR(REASM02_LINE(#CURI).LABEL,1,1)='*' THEN\n                    #ANO(REASM02_LINE(#CURI).LABEL#);  /* 08.12.87 */\n              IF $XREF THEN\n                 CALL $PUTXRF(LABL.NAME);\n              LINE_O(#CURI)=LABL.OFF;\n              LINE_I(#CURI),LINE_C(#CURI)=0;\n              CALL $PUTLINE;\n           END;\n        END;\n        LABL_PTR=LABL.NEXT;\n     END;\n     IF $MOVE THEN\n        REASM02_LINE(#CURI)=SLINE, BY NAME;\n     IF REASM02_LINE(#CURI).LABEL\u00ac='' & $XREF THEN\n        CALL $PUTXRF(REASM02_LINE(#CURI).LABEL);\n     IF SUBSTR(REASM02_LINE(#CURI).LABEL,1,1)='*' THEN\n        #ANO(REASM02_LINE(#CURI).LABEL#);              /* 08.12.87 */\n END $LABEL;\n\n\n PRINT_EXTRN_WXTRN: PROC;\n      DO I=1 TO DIM_ESD_ARRAY;\n         ONEBYTE = ESD_ARRAY(I).TYPE;\n         IF ESD_ARRAY(I).REF=ESDID THEN DO;\n            IF \u00acBIT4 & \u00acBIT5 & BIT6 & BIT7 THEN DO;\n               REASM02_LINE(#CURI).OPER='ENTRY';\n               REASM02_LINE(#CURI).OPERANDS=ESD_ARRAY(I).NAME;\n               REASM02_LINE(#CURI).OFF='';\n               REASM02_LINE(#CURI).OBJECT='';\n               #AZO(REASM02_LINE(#CURI).CMD#);\n               #AZO(REASM02_LINE(#CURI).LABEL#);\n               LINE_O(#CURI)=TEXTLEN;\n               LINE_I(#CURI),LINE_C(#CURI)=0;\n               CALL $PUTLINE;\n            END;\n         END;\n         IF  BIT4 & \u00acBIT5 & BIT6 & \u00acBIT7 THEN DO;\n            P = DSC_START;\n L_WXTRN:   DO WHILE(P\u00ac=NULL);\n               IF P->DSC.NAME = ESD_ARRAY(I).NAME THEN DO;\n                 REASM02_LINE(#CURI).OPER='WXTRN';\n                 REASM02_LINE(#CURI).OPERANDS=ESD_ARRAY(I).NAME;\n                 REASM02_LINE(#CURI).OFF='';\n                 REASM02_LINE(#CURI).OBJECT='';\n                 #AZO(REASM02_LINE(#CURI).CMD#);\n                 #AZO(REASM02_LINE(#CURI).LABEL#);\n                 LINE_O(#CURI)=TEXTLEN;\n                 LINE_I(#CURI),LINE_C(#CURI)=0;\n                 CALL $PUTLINE;\n                 LEAVE L_WXTRN;\n               END;\n               P = P->DSC.NEXT;\n            END;\n         END;\n      END;\n\n      P=DSC_START;\n      DO WHILE(P\u00ac=NULL);\n         IF P->DSC.EXTRN THEN DO;\n            Q=DSC_START;\n            DO WHILE (Q\u00ac=P);\n               IF Q->DSC.NAME=P->DSC.NAME &\n                  Q->DSC.TYPE=P->DSC.TYPE THEN\n                  LEAVE;\n               Q=Q->DSC.NEXT;\n            END;\n            IF Q=P THEN DO;\n               REASM02_LINE(#CURI).OPER='EXTRN';\n               REASM02_LINE(#CURI).OPERANDS=P->DSC.NAME;\n               REASM02_LINE(#CURI).OFF='';\n               REASM02_LINE(#CURI).OBJECT='';\n               #AZO(REASM02_LINE(#CURI).CMD#);\n               #AZO(REASM02_LINE(#CURI).LABEL#);\n               LINE_O(#CURI)=TEXTLEN;\n               LINE_I(#CURI),LINE_C(#CURI)=0;\n               CALL $PUTLINE;\n            END;\n         END;\n         P=P->DSC.NEXT;\n      END;\n END PRINT_EXTRN_WXTRN;\n\n %PAGE;\n PRINT_DXD: PROC;\n   DO I=1 TO DIM_ESD_ARRAY;\n      ONEBYTE = ESD_ARRAY(I).TYPE;\n      IF \u00acBIT4 & BIT5 & BIT6 & \u00acBIT7 THEN DO;   /* CXD-CONST */\n         REASM02_LINE(#CURI).LABEL=ESD_ARRAY(I).NAME;\n         IF $XREF THEN CALL $PUTXRF(REASM02_LINE(#CURI).LABEL);\n         P = DSC_START;\n L_DXD:  DO WHILE(P\u00ac=NULL);\n            IF P->DSC.NAME = ESD_ARRAY(I).NAME THEN DO;\n               REASM02_LINE(#CURI).OPER='DXD';\n               IF ESD_ARRAY(I).ALIGN <= 7 THEN\n                        LOCVAR=$ALIGN(ESD_ARRAY(I).ALIGN);\n               ELSE     LOCVAR='C';\n               IF LOCVAR='C' THEN\n                  REASM02_LINE(#CURI).OPERANDS='XL' ||\n                      $DIGIT(ESD_ARRAY(I).REF);\n               ELSE   REASM02_LINE(#CURI).OPERANDS=LOCVAR;\n               REASM02_LINE(#CURI).OFF='';\n               REASM02_LINE(#CURI).OBJECT='';\n               #AZO(REASM02_LINE(#CURI).CMD#);\n               #AZO(REASM02_LINE(#CURI).LABEL#);\n               LINE_O(#CURI)=TEXTLEN;\n               LINE_I(#CURI),LINE_C(#CURI)=0;\n               CALL $PUTLINE;\n               LEAVE L_DXD;\n            END;\n            P = P->DSC.NEXT;\n         END;\n      END;\n   END;\n END PRINT_DXD;\n\n %PAGE;\n PRINT_CSECT: PROC;\n   REASM02_LINE(#CURI).LABEL=CSECT;\n   REASM02_LINE(#CURI).OPER='CSECT';\n   #AZO(REASM02_LINE(#CURI).CMD#);\n   #AZP(REASM02_LINE(#CURI).LABEL#);\n   LINE_O(#CURI),LINE_I(#CURI),LINE_C(#CURI)=0;\n   CALL $PUTLINE;\n END PRINT_CSECT;\n\n %PAGE;\n PRINT_REGEQ_LTORG: PROC;\n   DO I=0 TO 15;\n      REASM02_LINE(#CURI).LABEL=$REGS(I);\n      IF $XREF THEN\n         CALL $PUTXRF($REGS(I));\n      REASM02_LINE(#CURI).OPER='EQU';\n      REASM02_LINE(#CURI).OPERANDS=$DIGIT(I);\n      #AZO(REASM02_LINE(#CURI).CMD#);\n      #AZO(REASM02_LINE(#CURI).LABEL#);\n      LINE_O(#CURI)=TEXTLEN;\n      LINE_I(#CURI),LINE_C(#CURI)=0;\n      CALL $PUTLINE;\n   END;\n   REASM02_LINE(#CURI).LABEL='';\n   REASM02_LINE(#CURI).OPER='LTORG';\n   REASM02_LINE(#CURI).OPERANDS=',';\n   #AZO(REASM02_LINE(#CURI).CMD#);\n   #AZO(REASM02_LINE(#CURI).LABEL#);\n   LINE_O(#CURI)=TEXTLEN;\n   LINE_I(#CURI),LINE_C(#CURI)=0;\n   CALL $PUTLINE;\n\n END PRINT_REGEQ_LTORG;\n\n %PAGE;\n PRINT_DSECTS: PROC;\n   USING_PTR=USING_START;\n   DO WHILE(USING_PTR\u00ac=NULL);\n      IF USING.NAME\u00ac='' THEN DO;\n         P=USING_START;\n         DO WHILE(P\u00ac=NULL & P\u00ac=USING_PTR);\n            IF P->USING.NAME=USING.NAME THEN\n               GOTO $NEXT_USING_REGISTER;\n            P=P->USING.NEXT;\n         END;\n         LBLOCK_PTR=LBLOCK_START;\n         DO WHILE(LBLOCK_PTR\u00ac=NULL & LBLOCK.NAME\u00ac=USING.NAME);\n            LBLOCK_PTR=LBLOCK.NEXT;\n         END;\n         IF LBLOCK.ADR=0 THEN DO;    /* NEW DUMMY DSECT */\n            REASM02_LINE(#CURI).LABEL=SUBSTR(USING.NAME,2);\n            REASM02_LINE(#CURI).OPER='DSECT';\n            REASM02_LINE(#CURI).OPERANDS='';\n         END;\n         ELSE DO;                    /* CONTROL BLOCK   */\n            REASM02_LINE(#CURI).LABEL='';\n            REASM02_LINE(#CURI).OPER='';\n            IF LBLOCK.MACRO = '' THEN\n               REASM02_LINE(#CURI).OPERANDS=\n                       SUBSTR(LBLOCK.NAME,2);\n            ELSE\n               REASM02_LINE(#CURI).OPERANDS=\n                       SUBSTR(LBLOCK.MACRO,2);\n         END;\n         #AZO(REASM02_LINE(#CURI).CMD#);\n         #AZO(REASM02_LINE(#CURI).LABEL#);\n         LINE_O(#CURI)=TEXTLEN;\n         LINE_I(#CURI),LINE_C(#CURI)=0;\n         CALL $PUTLINE;\n         IF LBLOCK.ADR=0 THEN DO;\n            DUMMY_PTR = LBLOCK.ADUMMY;\n            I=0;\n            DO WHILE(DUMMY_PTR\u00ac=NULL);\n              IF DUMMY.OFF > I THEN DO;\n                 REASM02_LINE(#CURI).OPER='DS';\n                 REASM02_LINE(#CURI).OPERANDS='XL' ||\n                            $DIGIT(DUMMY.OFF-I)    ||\n                            '      +'              ||\n                            $DIGIT(DUMMY.OFF); /*29.12.87*/\n                 #AZP(REASM02_LINE(#CURI).CMD#);\n                 #AZP(REASM02_LINE(#CURI).LABEL#);\n                 LINE_O(#CURI)=TEXTLEN;\n                 LINE_I(#CURI),LINE_C(#CURI)=0;\n                 CALL $PUTLINE;\n              END;\n              I = DUMMY.OFF;\n              REASM02_LINE(#CURI).LABEL=$DNAME(LBLOCK_PTR,I,J);\n              #AZP(REASM02_LINE(#CURI).CMD#);\n              #AZP(REASM02_LINE(#CURI).LABEL#);\n              REASM02_LINE(#CURI).OPER='EQU';\n              REASM02_LINE(#CURI).OPERANDS='*';\n              P=DUMMY.NEXT;\n              IF P\u00ac=NULL THEN DO;\n                 REASM02_LINE(#CURI).OPER='DS';\n                 REASM02_LINE(#CURI).OPERANDS='XL'   ||\n                           $DIGIT(P->DUMMY.OFF-I);\n                 I=P->DUMMY.OFF;\n              END;\n              DO WHILE\n                     (LENGTH(REASM02_LINE(#CURI).OPERANDS)<10);\n                 REASM02_LINE(#CURI).OPERANDS =\n                      REASM02_LINE(#CURI).OPERANDS || ' ';\n              END;\n              REASM02_LINE(#CURI).OPERANDS =\n                      REASM02_LINE(#CURI).OPERANDS || '+' ||\n                      $DIGIT(DUMMY.OFF);\n              LINE_O(#CURI)=TEXTLEN;\n              LINE_I(#CURI),LINE_C(#CURI)=0;\n              CALL $PUTLINE;\n              DUMMY_PTR=DUMMY.NEXT;\n            END;\n         END;\n         REASM02_LINE(#CURI).LABEL=CSECT;\n         REASM02_LINE(#CURI).OPER='CSECT';\n         REASM02_LINE(#CURI).OPERANDS='';\n         #AZO(REASM02_LINE(#CURI).CMD#);\n         #AZO(REASM02_LINE(#CURI).LABEL#);\n         LINE_O(#CURI)=TEXTLEN;\n         LINE_I(#CURI),LINE_C(#CURI)=0;\n         CALL $PUTLINE;\n      END;\n $NEXT_USING_REGISTER:\n      USING_PTR=USING.NEXT;\n   END;\n END PRINT_DSECTS;\n\n %PAGE;\n PRINT_END_STMT: PROC;\n   REASM02_LINE(#CURI).LABEL='';\n   REASM02_LINE(#CURI).OPER='END';\n   REASM02_LINE(#CURI).OPERANDS='';\n   LINE_O(#CURI)=TEXTLEN;\n   LINE_I(#CURI),LINE_C(#CURI)=0;\n   CALL $PUTLINE;\n   IF #CURI\u00ac=1 THEN DO;\n      DO I=#CURI TO MAXLVL-3;\n         #AZP(REASM02_LINE(I).CMD#);\n         #AZP(REASM02_LINE(I).LABEL#);\n      END;\n      #CURI=MAXLVL-3;\n      CALL $PUTLINE;\n   END;\n END PRINT_END_STMT;\n\n END $SHOW;\n\n %PAGE;\n /*********************************************************************/\n /*  FIND NECESSARY DSC ELEMENT BY OFFSET                             */\n /*********************************************************************/\n $FINDDSC:\n     PROC(OFFSET);\n DCL OFFSET BIN FIXED(31);\n\n     IF ALL(PASS='') THEN DO;\n        ON ERROR STOP;\n        PUT SKIP LIST('UNAUTHORIZED COPY. EXECUTION PROHIBITED');\n        CALL REASLST;\n        STOP;\n     END;\n     DSC_PTR=DSC_START;\n     DO WHILE (DSC_PTR \u00ac= NULL);\n        IF (OFFSET>=DSC.OFF) & (OFFSET<DSC.OFF+DSC.LENGTH) THEN\n           RETURN;\n        DSC_PTR=DSC.NEXT;\n     END;\n     PUT SKIP EDIT('INVALID OFFSET SPECIFIED: ' || $BH(OFFSET))(A);\n     CALL REASLST;\n     SIGNAL ERROR; STOP;\n END $FINDDSC;\n %SKIP;\n\n /*********************************************************************/\n /*  FILL UP THE OFFSET AND #COM                                      */\n /*********************************************************************/\n $JUMPOFF: PROC(OFF, CUR) RETURNS(CHAR(16) VAR);\n   DCL OFF BIN FIXED(31),\n       CUR BIN FIXED(31),\n         I BIN FIXED(31),\n        #I CHAR(4) BASED(ADDR(I)),\n         LABNAME CHAR(16) VAR,\n         REF CHAR(20) VAR;\n\n   PUT STRING(REF) EDIT(OFF*2)(F(6));\n   REF = SUBSTR(REF,VERIFY(REF,' '));\n   IF OFF >= 0 THEN\n      REF = '+' || REF;\n   REF = '*' || REF;\n\n   I = OFF*2 + CUR;\n   LOCVAR = #I;\n   LABNAME = $NAME(LOCVAR);\n\n   CALL $INITLAB(LABNAME,I,0,'1'B,I);\n   IF $XREF THEN CALL $PUTXRF(LABNAME);\n\n   #COM = REF;\n\n   RETURN (LABNAME);\n\n END $JUMPOFF;\n\n /*********************************************************************/\n /*  DETERMINE NAME BY OFFSET                                         */\n /*********************************************************************/\n $NAME:\n     PROC(VAL)  RETURNS(CHAR(16) VAR);\n DCL VAL     CHAR(*) VAR,\n     (O,OFF) BIN FIXED(31),\n     (P,Q)   PTR,\n     NAME    CHAR(16) VAR;\n\n     NAME = $CH(VAL);\n     O    = $HBF(NAME);\n     IF LENGTH(NAME)=6 THEN\n        NAME='00'||NAME;\n     SUBSTR(NAME,1,1)='A';\n     NAME='A' || SUBSTR(NAME,4);\n     IF O > TEXTLEN THEN DO;\n        NAME=$NEXTEL(CSECT) || '+' || $DIGIT(O);\n        GOTO $NAME_RETURN;\n     END;\n     P=LABL_START;\n     DO WHILE(P\u00ac=NULL);\n        IF P->LABL.OFF=O THEN DO;\n           NAME=P->LABL.NAME;\n           IF SUBSTR(NAME,1,1)='*' THEN DO;\n              NAME='';\n              OFF=0;\n              Q=LABL_START;\n              DO WHILE(Q\u00ac=NULL);\n                 IF SUBSTR(Q->LABL.NAME,1,1)\u00ac='*' &\n                    Q->LABL.OFF < P->LABL.OFF        &\n                    Q->LABL.OFF > OFF THEN DO;\n                       NAME=$NEXTEL(Q->LABL.NAME) || '+' ||\n                            $DIGIT(P->LABL.OFF-Q->LABL.OFF);\n                       OFF=Q->LABL.OFF;\n                 END;\n                 Q=Q->LABL.NEXT;\n              END;\n              IF NAME='' THEN\n                 NAME=$NEXTEL(CSECT) || '+' || $DIGIT(P->LABL.OFF);\n           END;\n           GOTO $EXIT_NAME;\n        END;\n        P=P->LABL.NEXT;\n     END;\n $EXIT_NAME:\n     IF INDEX(NAME,' ')\u00ac= 0 THEN\n        NAME=SUBSTR(NAME,1,INDEX(NAME,' ')-1);\n $NAME_RETURN:\n     RETURN(NAME);\n END $NAME;\n %SKIP;\n /*********************************************************************/\n /*  CLEAR ALL SCREEN PGM                                             */\n /*********************************************************************/\n $CLEAR_SCR: PROC;\n DCL I BIN FIXED;\n     DO I=1 TO MAXLVL-3;\n        #ANPU(REASM02_LINE(I).CMD#);\n        #AZO(REASM02_LINE(I).OFF#);\n        #AZO(REASM02_LINE(I).OBJECT#);\n        #ANP(REASM02_LINE(I).LABEL#);\n        #AZO(REASM02_LINE(I).OPER#);\n        #AZO(REASM02_LINE(I).OPERANDS#);\n        REASM02_LINE(I).CMD=' ';\n        REASM02_LINE(I).OFF=' ';\n        REASM02_LINE(I).OBJECT=' ';\n        REASM02_LINE(I).LABEL=' ';\n        REASM02_LINE(I).OPER=' ';\n        REASM02_LINE(I).OPERANDS=' ';\n        LINE_O(I),LINE_I(#CURI),LINE_C(#CURI)=0;\n        #SCRCOM(I) = '';\n     END;\n\n     IF PENDING THEN DO;\n        CALL ISPLINK('SETMSG ', 'REAS051 '); /*BLKPEN*/\n     END;\n     ELSE DO;\n        /*\n        IF $REM THEN\n           CALL ISPLINK('SETMSG ', 'REAS052 ');\n           REASM02_MESSAGE='R(' || $DIGIT(REMTIME)  || '/' ||\n                                   $DIGIT(REMCOUNT) || ')' ||\n                           REASM02_MESSAGE;\n        */\n     END;\n END $CLEAR_SCR;\n %SKIP;\n /*********************************************************************/\n /*  SUBSTRACT VALUE FROM A/V CONSTANT                                */\n /*********************************************************************/\n $SUBT:\n     PROC(OFF,LEN,DECR);\n DCL (OFF,LEN,DECR) BIN FIXED(31),\n     B      CHAR(1),\n     F4     BIN FIXED(31),\n     C4     CHAR(4) BASED(ADDR(F4)),\n     C(4)   CHAR(1) BASED(ADDR(F4));\n\n     IF LEN=4 THEN C4=SUBSTRTEXT1(OFF+1);\n              ELSE C4=SUBSTRTEXT1(OFF);\n     B    = C(1);\n     C(1) = LOW(1);\n     F4   = F4-DECR;\n     C(1) = B;\n     IF LEN=4 THEN CALL SUBSTRTEXT2(OFF+1,4,C4);\n              ELSE CALL SUBSTRTEXT2(OFF,4,C4);\n END $SUBT;\n %SKIP;\n /*********************************************************************/\n /*  ADD LABEL TO LABEL LIST POOL                                     */\n /*********************************************************************/\n $INITLAB:\n     PROC(N,O,R,F,P);\n DCL N    CHAR(8),        /* NAME*/\n     O    BIN FIXED(31),  /* OFF */\n     R    BIN FIXED,      /* REG */\n     F    BIT(1),         /* FIX */\n     P    BIN FIXED(31),  /* PLACE */\n     B    BIT(1) INIT('0'B),\n     Q    PTR INIT(NULL);\n\n     LABL_PTR=LABL_START;\n     DO WHILE(LABL_PTR\u00ac=NULL);\n        IF LABL.OFF = O THEN DO; /* THE SAME OFFSET     */\n           IF \u00acLABL.NORED THEN DO;  /* MAY TOUGHT       */\n               IF F | \u00acLABL.FIX THEN DO; /* REDEFINE    */\n                  IF  LABL.NAME\u00ac=N |\n                     (LABL.REG\u00ac=R & LABL.REG\u00ac=0)  |\n                      LABL.FIX\u00ac=F THEN\n                      B='1'B;\n                  LABL.NAME=N;\n                  IF LABL.REG\u00ac=0 THEN\n                     LABL.REG=R;\n                  LABL.FIX=F;\n               END;\n           END;\n           IF N='' THEN DO;\n              IF Q\u00ac=NULL THEN Q->LABL.NEXT=LABL.NEXT;\n                         ELSE LABL_START=LABL.NEXT;\n              FREE LABL;\n           END;\n           IF B THEN DO;\n              $CONF='1'B;\n              IF $REM THEN\n                 CALL $AUTOREC;\n           END;\n           RETURN;\n        END;\n        Q=LABL_PTR;\n        LABL_PTR=LABL.NEXT;\n     END;\n\n     IF N='' THEN RETURN;\n\n     IF R\u00ac=0 THEN DO;\n        USING_PTR=USING_START;\n        DO WHILE(USING_PTR\u00ac=NULL);\n           IF USING.REG=R & USING.NAME='' & USING.PLACE <= P &\n              USING.PLACE+USING.LENGTH > P THEN\n              GOTO $ALLOCATE_LABEL;\n           USING_PTR=USING.NEXT;\n        END;\n        RETURN;\n     END;\n\n $ALLOCATE_LABEL:\n     ALLOCATE LABL;\n     LABL.NEXT   = LABL_START;\n     LABL_START  = LABL_PTR;\n     LABL.NAME   = N;\n     LABL.REG    = R;\n     LABL.OFF = O;\n     LABL.FIX    = '0'B;\n     LABL.NORED  = '0'B;\n     $CONF       = '1'B;\n     IF $REM THEN\n        CALL $AUTOREC;\n END $INITLAB;\n %PAGE;\n /*********************************************************************/\n /*  MOVE USING ELEMENT INTO USING LIST                               */\n /*********************************************************************/\n $INITUSING:\n     PROC(O,R,PL,N,LEN);\n DCL O      BIN FIXED(31),\n     R      BIN FIXED,\n     PL     BIN FIXED(31),\n     N      CHAR(8),\n     LEN    BIN FIXED,\n     SORT   BIT(1),\n     (P,Q)  PTR;\n\n     ALLOCATE USING;\n     USING.NEXT   = USING_START;\n     USING_START  = USING_PTR;\n     USING.REG    = R;\n     USING.OFF    = O;\n     USING.PLACE  = PL;\n     USING.NAME   = N;\n     USING.FIX    = '0'B;\n     USING.LENGTH = TEXTLEN-PL;\n     IF LEN\u00ac=0 THEN USING.LENGTH=LEN;\n     IF N\u00ac='' THEN\n        CALL $INTLIV(N,LBLOCK_START,CONTROL);\n\n     $CONF='1'B;\n     IF $REM THEN\n        CALL $AUTOREC;\n END $INITUSING;\n %SKIP;\n /*********************************************************************/\n /*  DROP SUBROUTINE                                                  */\n /*********************************************************************/\n $DROP:\n     PROC(R);\n DCL R BIN FIXED(31),\n     N CHAR(8),\n     P PTR;\n     IF R=0 THEN RETURN;\n $DROP_START#1:\n     P=NULL;\n     USING_PTR=USING_START;\n     DO WHILE(USING_PTR\u00ac=NULL);\n        IF USING.REG=R THEN DO;\n           IF P\u00ac=NULL THEN P->USING.NEXT=USING.NEXT;\n                      ELSE USING_START=USING.NEXT;\n           N=USING.NAME;\n           FREE USING;\n           GOTO $DROP_START#1;\n        END;\n        P=USING_PTR;\n        USING_PTR=USING.NEXT;\n     END;\n $DROP_START#2:\n     P=NULL;\n     LABL_PTR=LABL_START;\n     DO WHILE(LABL_PTR\u00ac=NULL);\n        IF LABL.REG=R THEN DO;\n           IF P\u00ac=NULL THEN P->LABL.NEXT=LABL.NEXT;\n                      ELSE LABL_START=LABL.NEXT;\n           FREE LABL;\n           GOTO $DROP_START#2;\n        END;\n        P=LABL_PTR;\n        LABL_PTR=LABL.NEXT;\n     END;\n     IF N='' THEN RETURN;\n     USING_PTR=USING_START;\n     DO WHILE(USING_PTR\u00ac=NULL);\n        IF USING.NAME=N THEN RETURN;\n        USING_PTR=USING.NEXT;\n     END;\n     CALL $DELLIV(N,LBLOCK_START);\n END $DROP;\n %SKIP;\n /*********************************************************************/\n /*  TRY SET BASE REGISTER SUBROUTINE                                 */\n /*********************************************************************/\n $TESTUS:\n     PROC(J);\n DCL    J BIN FIXED(31);\n     IF USING_START\u00ac=NULL THEN RETURN;\n     SELECT (REASM02_LINE(1).OPER);\n       WHEN  ('BALR') DO;\n         IF RR1.R2=0 & RR1.R1\u00ac=0  & RR1.R1\u00ac=1  &\n                       RR1.R1\u00ac=14 & RR1.R1\u00ac=15 THEN\n            CALL $INITUSING(J+2,RR1.R1,J+2,'',0);\n       END;\n       WHEN  ('BAL') DO;\n         IF RX.B2=15 & RX.R1\u00ac=0  & RX.R1\u00ac=1  &\n                       RX.R1\u00ac=14 & RX.R1\u00ac=15 THEN\n            CALL $INITUSING(J+4,RX.R1,J+4,'',0);\n       END;\n       WHEN  ('LR') DO;\n         IF RR1.R2=15 & RR1.R1\u00ac=0  & RR1.R1\u00ac=1  &\n                        RR1.R1\u00ac=14 & RR1.R1\u00ac=15 THEN\n            CALL $INITUSING(0,RR1.R1,J+2,'',0);\n       END;\n       OTHER;\n     END;\n END $TESTUS;\n %PAGE;\n /*********************************************************************/\n /*  SET XREF ELEMENT                                                 */\n /*********************************************************************/\n $PUTXRF:\n     PROC(N);\n DCL N      CHAR(*),               /* NAME TO PUT     */\n     NAME   CHAR(16),\n     I      BIN FIXED,\n     #STMT  BIN FIXED,\n     (Q,P)  PTR INIT(NULL);\n\n     NAME = N;\n     IF NAME = '' THEN RETURN;         /* IF BLANK NAME   */\n     #STMT=PRINTNUM+#CURI;        /* STATEMENT NUMB  */\n\n     XREF_PTR=XREF_START;                     /* FROM XREF START     */\n L_XREF:\n     DO WHILE(XREF_PTR\u00ac=NULL);                /* WHILE XREF_PTR EXST */\n        IF XREF.NAME=NAME THEN DO;            /* TH SAME NAME ?      */\n           DO WHILE(XREF.CONT\u00ac=NULL);         /* GO BROTHER LINE     */\n              DO I=1 TO XREF.ISTMT;           /* BY STMT NUMBER      */\n                 IF XREF.STMT(I)=#STMT THEN RETURN;\n              END;                            /*                     */\n              XREF_PTR=XREF.CONT;             /* NEXT BROTHER        */\n           END;                               /*                     */\n           DO I=1 TO XREF.ISTMT;              /* BY STMT NUMBER      */\n              IF XREF.STMT(I)=#STMT THEN RETURN;\n           END;\n           IF XREF.ISTMT < DIM(XREF.STMT,1) THEN DO;\n              XREF.ISTMT=XREF.ISTMT+1;\n              XREF.STMT(XREF.ISTMT)=#STMT;\n           END;\n           ELSE DO;                           /* CREATE NEW BROTHER  */\n              P=XREF_PTR;                     /*                     */\n              ALLOCATE XREF;                  /* ALLOCATE HIM        */\n              P->XREF.CONT=XREF_PTR;          /* SET CONT VALUE      */\n              XREF.STMT=0;                    /* FILL                */\n              XREF.NAME=NAME;                 /*     ALL             */\n              XREF.ISTMT=1;                   /*        FIELDS       */\n              XREF.STMT(1)=#STMT;             /*                     */\n              XREF.NEXT=P->XREF.NEXT;         /* NEXT FIELD IS SAME  */\n              XREF.CONT=NULL;                 /* NO NEXT BROTHER     */\n           END;                               /*                     */\n           RETURN;                            /*                     */\n        END;                                  /*                     */\n        ELSE DO;                              /* NON EQUAL NAME      */\n          IF UNSPEC(XREF.NAME) > UNSPEC(NAME) THEN LEAVE L_XREF;\n        END;                                  /*                     */\n        Q=XREF_PTR;                           /* SAVE XREF POINTER   */\n        XREF_PTR=XREF.NEXT;                   /* GOTO NEXT ONE       */\n     END L_XREF;                              /*                     */\n                                              /*                     */\n     P=XREF_PTR;                              /*                     */\n     ALLOCATE XREF;                           /*                     */\n     IF Q=NULL THEN   XREF_START=XREF_PTR;    /*                     */\n               ELSE Q->XREF.NEXT=XREF_PTR;    /*                     */\n     XREF.STMT=0;                             /*                     */\n     XREF.NAME=NAME;                          /*                     */\n     XREF.NEXT=P;                             /*                     */\n     XREF.CONT=NULL;                          /*                     */\n     XREF.ISTMT=1;                            /*                     */\n     XREF.STMT(1)=#STMT;                      /*                     */\n END $PUTXRF;                                 /*                     */\n %SKIP;\n /*********************************************************************/\n /*  PRINT XREF TABLE                                                 */\n /*********************************************************************/\n $PRINT_XREF:\n     PROC;\n DCL (P,Q) PTR,\n     SORT  BIT(1),\n     (I,N) BIN FIXED;\n\n     SIGNAL ENDPAGE(SYSPRINT);\n     PUT SKIP EDIT('=== CROSS REFERENCE LISTING ===')\n                   (COL(40),A,SKIP(2));\n     XREF_PTR=XREF_START;\n     DO WHILE(XREF_PTR\u00ac=NULL);\n        PUT SKIP EDIT(XREF.NAME)(COL(2),A(16));\n        N=1;\n $PUTSTMT:\n        DO I=1 TO XREF.ISTMT;\n           PUT EDIT(XREF.STMT(I))(X(1),F(4));\n           N=N+1;\n           IF N > 20 THEN DO;\n              N=1;\n              PUT SKIP EDIT((16)' ')(COL(2),A(16));\n           END;\n        END;\n        P=XREF_PTR;\n        IF XREF.CONT\u00ac=NULL THEN DO;\n           XREF_PTR=XREF.CONT;\n           FREE P->XREF;\n           GOTO $PUTSTMT;\n        END;\n        XREF_PTR=XREF.NEXT;\n        FREE P->XREF;\n     END;\n     XREF_START=NULL;\n\n     PUT SKIP(3) EDIT('--------------- END OF XREF LIST')(A);\n END $PRINT_XREF;\n %PAGE;\n /*********************************************************************/\n /*  COMMENT FILL SUBROUTINE                                          */\n /*********************************************************************/\n $PUTCOM:\n     PROC(I);\n DCL   (I,J,K,L) BIN FIXED,\n       (P,Q,R)   PTR,\n       LINE_PTR  PTR,\n       BYTE      CHAR(1),\n       LINE      CHAR(80) BASED(LINE_PTR);\n\n     LINE_PTR=ADDR(REASM02_LINE(I).CMD#);\n     IF REASM02_LINE(I).OPERANDS\u00ac='' THEN DO;\n        J = LENGTH(REASM02_LINE(I).OPERANDS);\n        DO K=80 BY -1 WHILE(SUBSTR(LINE,K,1)=' ');\n           J = J-1;\n        END;\n     END;\n     ELSE   DO;\n        K = 50;\n        J = 2;\n     END;\n\n     LINE_C(I)=0;\n     IF K >= 79 THEN RETURN;\n\n     #ANPL(BYTE);\n     SUBSTR(REASM02_LINE(I).OPERANDS, J+1, 1) = BYTE;\n\n     LINE_C(I)=K+1;\n     COM_PTR=COM_START;\n     DO WHILE(COM_PTR\u00ac=NULL);\n        IF LINE_O(I)           <= COM.OFF &\n           LINE_O(I)+LINE_I(I) >  COM.OFF THEN\n           SUBSTR(LINE,K+2)=COM.TXT;\n        COM_PTR=COM.NEXT;\n     END;\n     IF SUBSTR(LINE,K+2)='' THEN   /* NOT FILLED   */\n        SUBSTR(LINE,K+2)=#COM;\n     #SCRCOM(I) = SUBSTR(LINE,K+2);\n END $PUTCOM;\n %SKIP;\n /*********************************************************************/\n /*  MEMORY FREE SUBROUTINE                                           */\n /*********************************************************************/\n $FREE:\n     PROC ;\n     @@FREE_LIST(DSC);\n     @@FREE_LIST(LABL);\n     @@FREE_LIST(QUALIFY);\n     @@FREE_LIST(USING);\n     @@FREE_LIST(COM);\n     @@FREE_LIST(LBLOCK);\n\n END $FREE;\n %SKIP;\n /*********************************************************************/\n /*  AUTO RECOVERY PROCESS SUBROUTINE                                 */\n /*********************************************************************/\n $AUTOREC:\n     PROC ;\n     REMCOUNT=REMCOUNT+1;\n     IF REMCOUNT=REMTIME THEN\n        CALL REASMS('0'B,'*');\n END $AUTOREC;\n %SKIP;\n /*********************************************************************/\n /*  FILL DUMMY SUBROUTINE                                            */\n /*********************************************************************/\n $PUTDUMMY:\n     PROC(NAME,OFFSET);\n DCL NAME   CHAR(*),\n     OFFSET BIN FIXED(31),\n     (P,Q,R)  PTR INIT(NULL);\n\n     P=LBLOCK_START;\n     DO WHILE(P\u00ac=NULL);\n        IF  P->LBLOCK.NAME=NAME THEN LEAVE;\n        P = P->LBLOCK.NEXT;\n     END;\n     IF P = NULL THEN RETURN;\n     IF P->LBLOCK.ADR \u00ac= 0 THEN RETURN;    /* DO NOT FILL LIV | */\n\n     R = P->LBLOCK.ADUMMY;\n     DO WHILE(R\u00ac=NULL);\n        IF R->DUMMY.OFF = OFFSET THEN     RETURN;\n        IF R->DUMMY.OFF > OFFSET THEN     LEAVE;\n        Q=R;\n        R=R->DUMMY.NEXT;\n     END;\n     ALLOCATE DUMMY;\n     DUMMY.OFF = OFFSET;\n     DUMMY.NEXT   = R;\n     DUMMY.NAME   = '';\n     IF Q=NULL THEN P->LBLOCK.ADUMMY=DUMMY_PTR;\n     ELSE           Q->DUMMY.NEXT=DUMMY_PTR;\n END $PUTDUMMY;\n\n /*********************************************************************/\n /*  RETURN BIT STRING WHICH REPRESENTS BYTE                          */\n /*********************************************************************/\n $BITSTR:PROC(BYTE) RETURNS(CHAR(20) VAR);\n DCL BYTE   CHAR(1),\n     HALF   BIN FIXED,\n     LOCVAR CHAR(20) VAR INIT('');\n     ICH = 0;\n     DO HALF=128,64,32,16,8,4,2,1;\n        CH = BYTE;\n        UNSPEC(ICH) = UNSPEC(ICH) & UNSPEC(HALF);\n        IF ICH = 0 THEN LOCVAR = LOCVAR || '0';\n        ELSE            LOCVAR = LOCVAR || '1';\n     END;\n     LOCVAR = 'B''' || LOCVAR || '''';\n     RETURN(LOCVAR);\n END $BITSTR;\n\n /*********************************************************************/\n /*  TEST FOR LABEL REDEFINITION                                      */\n /*********************************************************************/\n $DUBLAB:PROC(NAME,OFFSET) RETURNS(BIT(1));\n DCL NAME    CHAR(*),\n     OFFSET  BIN FIXED(31),\n     (P,Q)   PTR;\n    IF NAME='' THEN RETURN('0'B);\n    P=LABL_START;\n    DO WHILE(P\u00ac=NULL);\n       IF P->LABL.NAME=NAME & OFFSET\u00ac=P->LABL.OFF THEN RETURN('1'B);\n       P=P->LABL.NEXT;\n    END;\n    P=LBLOCK_START;\n    DO WHILE(P\u00ac=NULL);\n       IF P->LBLOCK.ADR=0 THEN DO;\n          Q = P->LBLOCK.ADUMMY;\n          DO WHILE(Q\u00ac=NULL);\n             IF Q->DUMMY.NAME = NAME THEN RETURN('1'B);\n             Q = Q->DUMMY.NEXT;\n          END;\n       END;\n       P=P->LBLOCK.NEXT;\n    END;\n    RETURN ('0'B);\n END $DUBLAB;\n\n /*********************************************************************/\n /*  TEST IF CHAR STRING IS GOOD                                      */\n /*********************************************************************/\n $CHARSTR: PROC(STR)  RETURNS(BIT(1));\n DCL STR  CHAR(*) VAR;\n DCL I;\n     ICH = 0;\n     DO I=1 TO LENGTH(STR);\n        CH = SUBSTR(STR,I,1);\n        CH = SUBSTR(GOODA,ICH+1,1);\n        IF CH = HIGH(1) THEN RETURN('0'B);\n     END;\n     RETURN('1'B);\n END $CHARSTR;\n\n /*********************************************************************/\n /*  TEST PSA USING                                                   */\n /*********************************************************************/\n $USING_PSA:\n     PROC(PTR);\n DCL PTR       BIN     FIXED(31),\n     TRY       BIT(1)  STATIC INT INIT('0'B),\n     PSAOK     BIT(1)  STATIC INT INIT('0'B),\n     PSANAME   CHAR(8) STATIC INT INIT('@PSA'),\n     P         PTR,\n     RC        BIN     FIXED(31);\n\n     IF \u00acTRY THEN DO;\n        CALL REASMLD(PSANAME,RC,CONTROL);\n        CALL REASMDL(PSANAME);\n        TRY = '1'B;\n        IF RC THEN PSAOK='1'B;\n     END;\n\n     IF PSAOK THEN DO;\n        P = USING_START;\n        DO WHILE(P \u00ac= NULL);\n           IF  P->USING.REG                    = 0   &\n               P->USING.PLACE                 <= PTR &\n               P->USING.PLACE+P->USING.LENGTH >  PTR THEN  RETURN;\n           P = P->USING.NEXT;\n        END;\n        CALL $INITUSING(PTR,0,PTR,PSANAME,4);\n     END;\n\n END $USING_PSA;\n\n /*********************************************************************/\n /*  TEST CVT USING                                                   */\n /*********************************************************************/\n $USING_CVT:\n     PROC(PTR, REG);\n DCL PTR       BIN     FIXED(31),\n     REG       BIN     FIXED,\n     TRY       BIT(1)  STATIC INT INIT('0'B),\n     CVTOK     BIT(1)  STATIC INT INIT('0'B),\n     CVTNAME   CHAR(8) STATIC INT INIT('@CVT'),\n     P         PTR,\n     RC        BIN     FIXED(31);\n\n     IF \u00acTRY THEN DO;\n        CALL REASMLD(CVTNAME,RC,CONTROL);\n        CALL REASMDL(CVTNAME);\n        TRY = '1'B;\n        IF RC THEN CVTOK='1'B;\n     END;\n\n     IF CVTOK THEN DO;\n        P = USING_START;\n        DO WHILE(P \u00ac= NULL);\n           IF  P->USING.REG                    = REG &\n               P->USING.PLACE                 <= PTR &\n               P->USING.PLACE+P->USING.LENGTH >  PTR &\n               P->USING.NAME                   = CVTNAME THEN RETURN;\n           P = P->USING.NEXT;\n        END;\n        CALL $INITUSING(PTR,REG,PTR,CVTNAME,4);\n     END;\n\n END $USING_CVT;\n\n $GOODCMD: PROC(OFFSET);\n  DCL (OFFSET,I)  BIN FIXED(31);\n\n    IF OFFSET<0 THEN OFFSET=0;\n    IF OFFSET>= TEXTLEN THEN OFFSET = TEXTLEN-1;\n    IF OFFSET\u00ac=0 THEN DO;\n       CALL $FINDDSC(OFFSET);\n       IF DSC.TYPE='I' THEN DO;\n          I=0;\n          IF MOD(OFFSET,2)\u00ac=0 THEN OFFSET=OFFSET-1;\n          DO WHILE(DSC.OFF+I <= OFFSET);\n             CMD_PTR  = ADDRTEXT();\n             #CMD_PTR = #CMD_PTR+2+DSC.OFF+I;\n             I=I+CMDLEN(CMDDEF);\n          END;\n          OFFSET=DSC.OFF+I;\n       END;\n    END;\n END $GOODCMD;\n %PAGE;\n\n\n $ERROR:\n     ON ERROR SNAP GOTO $RETURN;\n     CALL $PRINTDSC('--- ABNORMAL END OF REASM PROGRAMM');\n     IF $CONF THEN DO;\n        CALL ISPLINK ('SETMSG ', 'REAS002 ');  /* SYSTEM ERROR */\n        OFFSET = $OFFSET;\n        ON ERROR GOTO $ERROR;\n        GOTO $SHOW_LOOP;\n     END;\n     GOTO $RETURN;\n\n $REALLOC:\n     PROC(DDNAME, DSNAME, MEMNAME, VOLNAME) RED REORDER;\n     DCL DDNAME  CHAR(8),\n         DSNAME  CHAR(44),\n         MEMNAME CHAR(8),\n         VOLNAME CHAR(6);\n     DCL TXT CHAR(255) VAR INIT('');\n     DCL T   CHAR(255);\n\n     CALL DYNAM(DYNWORK, 'UNALLOC ',\n                'DD=' || DDNAME || ' UNALLOC;');\n     TXT = 'DD='  || DDNAME ||\n           ' DSN='  || $CUTDSN(DSNAME);\n     MEMNAME = TRANSLATE(MEMNAME,'#','*');\n     IF MEMNAME \u00ac= '' THEN TXT = TXT || ' MEMBER=' || MEMNAME;\n     IF VOLNAME \u00ac= '' THEN TXT = TXT || ' VOLUME=' || VOLNAME;\n     TXT = TXT || ' SHR;';\n     T = TXT;\n     DYNAREA.VOL = '';\n     CALL DYNAM(DYNWORK,'ALLOCR ',DYNAREA,T);\n END $REALLOC;\n\n $CUTDSN:\n     PROC(OLDNAME) RED REORDER RETURNS(CHAR(44) VAR);\n     DCL OLDNAME CHAR(44),\n         NEWNAME CHAR(44) VAR;\n     DCL I;\n     OLDNAME = TRANSLATE(OLDNAME, ' ', LOW(1));\n     I = INDEX(OLDNAME,' ');\n     IF I>1 THEN NEWNAME=SUBSTR(OLDNAME,1,I-1);\n     ELSE        NEWNAME=OLDNAME;\n     RETURN(NEWNAME);\n END $CUTDSN;\n\n $PRINTDSC:\n     PROC(T) RED REORDER;\n     DCL T CHAR(*),\n         I;\n\n     ON ERROR SYSTEM;\n\n     PUT SKIP EDIT(T,' DATE: ',DATE,' TIME: ',TIME)(A);\n     PUT SKIP EDIT('DSN=',DSN,' MEM=',MEMBER,' CSECT=',CSECT)(A);\n\n     IF DSC_START\u00ac=NULL THEN DO;\n     PUT SKIP(2) EDIT('*** DSC TABLE ***',\n     '..NAME.. ..OFFSET ..LENGTH  TYPE RD N F E S')(A,SKIP,COL(9),A);\n     DSC_PTR=DSC_START;\n     DO WHILE(DSC_PTR\u00ac=NULL);\n        PUT SKIP\n            EDIT(DSC.NAME,$BH(DSC.OFF),$BH(DSC.LENGTH),DSC.TYPE,\n                 DSC.NORED,DSC.NEW,DSC.FIX,DSC.EXTRN,DSC.SUBT)\n            (COL(9),A(8),X(1),A(8),X(1),A(8),X(4),A(1),X(3),B(1),X(1),\n                    B(1),X(1),B(1),X(1),B(1),X(1),B(1));\n        DSC_PTR=DSC.NEXT;\n     END;\n     PUT SKIP LIST('-----------------------------------');\n     END;\n\n     IF LABL_START\u00ac=NULL THEN DO;\n     LABL_PTR=LABL_START;\n     PUT SKIP(2) EDIT('*** LABEL TABLE ***',\n     '...LABEL ..OFFSET RG F NR')(A,SKIP,COL(9),A);\n     DO WHILE(LABL_PTR\u00ac=NULL);\n        PUT SKIP EDIT(LABL.NAME,$BH(LABL.OFF),LABL.REG,LABL.FIX,\n                     LABL.NORED)\n                     (COL(9),A,X(1),A(8),X(1),F(2),X(1),B(1),X(2),B(1));\n        LABL_PTR=LABL.NEXT;\n     END;\n     PUT SKIP LIST('-----------------------------------');\n     END;\n\n     IF USING_START\u00ac=NULL THEN DO;\n     USING_PTR=USING_START;\n     PUT SKIP(2) EDIT('*** USING TABLE ***',\n     '..NAME.. ..OFFSET ..LENGTH ...PLACE REG  F')(A,SKIP,COL(9),A);\n     DO WHILE(USING_PTR\u00ac=NULL);\n        PUT SKIP EDIT(USING.NAME,\n                      $BH(USING.OFF),\n                      $BH(USING.LENGTH),\n                      $BH(USING.PLACE),\n                      $REGS(USING.REG),\n                      USING.FIX)\n                     (COL(9),A(8),X(1),A,X(1),A,X(1),A,X(1),A(3),\n                       X(2),B(1));\n        USING_PTR=USING.NEXT;\n     END;\n     PUT SKIP LIST('-----------------------------------');\n     END;\n\n     IF COM_START\u00ac=NULL THEN DO;\n     COM_PTR=COM_START;\n     PUT SKIP(2) EDIT('*** COMMENT TABLE ***',\n     '..OFFSET ..TXT..')(A,SKIP,COL(9),A);\n     DO WHILE(COM_PTR\u00ac=NULL);\n        PUT SKIP EDIT($BH(COM.OFF),COM.TXT)\n                     (COL(9),A(8),X(1),A);\n        COM_PTR=COM.NEXT;\n     END;\n     PUT SKIP LIST('-----------------------------------');\n     END;\n\n     IF LBLOCK_START\u00ac=NULL THEN DO;\n     LBLOCK_PTR=LBLOCK_START;\n     PUT SKIP(2) EDIT('*** LBLOCK TABLE ***',\n     '..NAME..  ...ADR.. ..DUMMY. ...MACRO STATEMENT...')\n     (A,SKIP,COL(9),A);\n     DO WHILE(LBLOCK_PTR\u00ac=NULL);\n        PUT SKIP EDIT(LBLOCK.NAME,\n                      $BH(LBLOCK.ADR),\n                      $BH(BIN(UNSPEC(LBLOCK.ADUMMY),31)),\n                      LBLOCK.MACRO)\n                     (COL(9),A(9),X(1),A,X(1),A,X(1),A);\n        LBLOCK_PTR=LBLOCK.NEXT;\n     END;\n     PUT SKIP LIST('-----------------------------------');\n     END;\n\n     IF QUALIFY_START\u00ac=NULL THEN DO;\n     QUALIFY_PTR=QUALIFY_START;\n     PUT SKIP(2) EDIT('*** QUALIFY TABLE ***',\n     '..OFFSET ..NAME..')(A,SKIP,COL(9),A);\n     DO WHILE(QUALIFY_PTR\u00ac=NULL);\n        PUT SKIP EDIT($BH(QUALIFY.OFF),QUALIFY.NAME)\n                     (COL(9),A(8),X(1),A);\n        QUALIFY_PTR=QUALIFY.NEXT;\n     END;\n     PUT SKIP LIST('-----------------------------------');\n     END;\n\n     PUT SKIP(2) EDIT('*** ESD ARRAY TABLE *** (CURRENT ESDID =',\n                      ESDID, ')',\n                      'NNNNN ..NAME.. .TYPE ..OFFSET ALIGN LEN ..REF')\n                     (A,F(5),A,SKIP,COL(9),A);\n     DO I=1 TO DIM_ESD_ARRAY;\n        PUT SKIP EDIT(ESD_ARRAY(I).ID,\n                      ESD_ARRAY(I).NAME,\n                      $IMM(ESD_ARRAY(I).TYPE),\n                      $BH(BIN(ESD_ARRAY(I).OFF,31)),\n                      $IMM(ESD_ARRAY(I).ALIGN),\n                      BIN(ESD_ARRAY(I).LENGTH,15),\n                      ESD_ARRAY(I).REF)\n        (COL(9),F(5),X(1),A,X(1),A,X(1),A,X(1),A,X(1),F(3),X(1),F(5));\n     END;\n     PUT SKIP LIST('-----------------------------------');\n\n     IF XREF_START\u00ac=NULL THEN CALL $PRINT_XREF;\n\n     REVERT ERROR;\n     CALL REASLST;\n\n END $PRINTDSC;\n\n CALCULATE_LVL: PROC;\n       DCL  ISPLINK ENTRY EXT OPTIONS(INTER ASM RETCODE);\n       DCL  F4      BIN   FIXED(31) INIT(4);\n       DCL  SCR     CHAR(4);\n       CALL ISPLINK ('VCOPY ', 'ZSCREEND ', F4, SCR, 'MOVE ');\n       GET STRING(SCR) LIST(MAXLVL);\n       LVL = MAXLVL - 3;\n END CALCULATE_LVL;\n\n SUBSTRTEXT: PROC(OFF, LEN) RETURNS(CHAR(32767) VAR);\n   DCL (OFF,LEN) BIN FIXED(31);\n   RETURN (SUBSTR(TEXT,OFF,LEN));\n END SUBSTRTEXT;\n\n SUBSTRTEXT1: PROC(OFF) RETURNS(CHAR(32767) VAR);\n   DCL (OFF) BIN FIXED(31);\n   RETURN (SUBSTR(TEXT,OFF));\n END SUBSTRTEXT1;\n\n SUBSTRTEXT2: PROC(OFF, LEN, VAL);\n   DCL (OFF,LEN) BIN FIXED(31);\n   DCL VAL CHAR(*) VAR;\n   SUBSTR(TEXT,OFF,LEN) = VAL;\n END SUBSTRTEXT2;\n\n SUBSTRTEXTCOPY: PROC(OFF, LEN) RETURNS(CHAR(32767) VAR);\n   DCL (OFF,LEN) BIN FIXED(31);\n   RETURN (SUBSTR(TEXTCOPY,OFF,LEN));\n END SUBSTRTEXTCOPY;\n\n FREETEXT: PROC;\n   @@FREE_CTL (TEXT);\n   @@FREE_CTL (TEXTCOPY);\n END FREETEXT;\n\n LENGTHTEXT: PROC RETURNS(BIN FIXED(31));\n   RETURN (LENGTH(TEXT));\n END LENGTHTEXT;\n\n SETTEXT: PROC(VAL);\n   DCL VAL CHAR(*) VAR;\n   TEXT = VAL;\n END SETTEXT;\n\n CONCATTEXT: PROC(VAL);\n   DCL VAL CHAR(*) VAR;\n   TEXT = TEXT || VAL;\n END CONCATTEXT;\n\n ALLOCATETEXT: PROC(LEN);\n   DCL LEN BIN FIXED(31);\n   ALLOCATE TEXT     CHAR(LEN);\n   ALLOCATE TEXTCOPY CHAR(LEN);\n END ALLOCATETEXT;\n\n COPYTEXT: PROC;\n   TEXTCOPY = TEXT;\n END COPYTEXT;\n\n ADDRTEXT: PROC RETURNS(PTR);\n   RETURN (ADDR(TEXT));\n END ADDRTEXT;\n\n %PAGE;\n     %INCLUDE REASMS;\n     %INCLUDE REASMR;\n\n END REASM;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REASMMAC": {"ttr": 5635, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x1e\\x01\\x00V\\x00\\x976_\\x00\\x98\\x01\\x9f\\x00B\\x001\\x00)\\x00\\t\\xd7\\xc7\\xd4\\xe5\\xe8\\xc3@@@@'", "ispf": {"version": "30.01", "flags": 0, "createdate": "1997-12-31T00:00:00", "modifydate": "1998-01-19T00:42:56", "lines": 49, "newlines": 41, "modlines": 9, "user": "PGMVYC"}, "text": " /* %INCLUDE REASMMAC */\n\n /* -------------------------- */\n /* FREE A CONTROLLED VARIABLE */\n /* -------------------------- */\n %DCL @@FREE_CTL ENTRY;\n %@@FREE_CTL:     PROC(VARIABLE) RETURNS(CHAR);\n     DCL VARIABLE CHAR;\n     RETURN ( 'DO WHILE (ALLOCATION(' || VARIABLE || ')); '  ||\n              'FREE '                 || VARIABLE ||   '; '  ||\n              'END'\n            );\n %END;\n\n\n /* ------------------ */\n /* FREE A LINKED LIST */\n /* ------------------ */\n %DCL @@FREE_LIST ENTRY;\n %@@FREE_LIST:     PROC(NAME) RETURNS(CHAR);\n     DCL NAME CHAR;\n\n     RETURN (\n              @@NEAT('IF ' || NAME || '_START\u00ac=NULL THEN BEGIN;') ||\n              @@NEAT('   DCL (P,Q) PTR;')                         ||\n              @@NEAT('   P = ' || NAME || '_START;')              ||\n              @@NEAT('   DO WHILE (P\u00ac=NULL);')                    ||\n              @@NEAT('      Q  = P;')                             ||\n              @@NEAT('      P  = P->' || NAME || '.NEXT;')        ||\n              @@NEAT('      FREE Q->' || NAME || ';')             ||\n              @@NEAT('   END;')                                   ||\n              @@NEAT('   ' || NAME || '_START = NULL;')           ||\n              @@NEAT('END')\n           );\n\n %END;\n\n /* ------------------------------ */\n /* INTERNAL FORMATTING SUBROUTINE */\n /* ------------------------------ */\n %DCL @@NEAT ENTRY;\n %@@NEAT:     PROC(LINE) RETURNS(CHAR);\n      DCL LINE CHAR;\n      DCL I    FIXED;\n      DO I = 1 TO 71-LENGTH(LINE);\n         LINE = LINE || ' ';\n      END;\n      RETURN (LINE);\n %END;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REASMR": {"ttr": 5637, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x1e\\x08\\x00\\x04\\x00\\x976_\\x01\\x06\\x02\\x0f\\x01\\x15\\x00\\x89\\x00\\x8b\\x00\\x05\\xd7\\xc7\\xd4\\xe5\\xc3@@@@@'", "ispf": {"version": "30.08", "flags": 0, "createdate": "1997-12-31T00:00:00", "modifydate": "2006-01-20T01:15:04", "lines": 137, "newlines": 139, "modlines": 5, "user": "PGMVC"}, "text": " %PAGE;\n /********************************************************************/\n /*      REASM 'RESTORE STATUS' SUBROUTINE                           */\n /********************************************************************/\n REASMR:\n     PROC;\n\n DCL (Q,P)      PTR,\n     IDENT      CHAR(30) VAR,\n     (I,J,K,L)  BIN FIXED;\n\n     I = REASMRC(SAVE,'C');\n     IF I\u00ac=0 THEN RETURN;\n\n     OPEN FILE(SAVEFL) TITLE(SAVE) INPUT;\n\n     GET FILE(SAVEFL) LIST(IDENT);\n\n     GET FILE(SAVEFL)  LIST(TEXTLEN);\n     CALL ALLOCATETEXT(TEXTLEN);\n     TEXTIND = TEXTLEN;             /***/\n     GET FILE(SAVEFL) LIST(TEXT);\n     CALL COPYTEXT();\n\n     GET FILE(SAVEFL) LIST(DSN,MEMBER,CSECT,OFFSET,\n                           $OFFSET,FOFFSET,BOFFSET,\n                           ESDID,ARRINDX,#FIND,BLOCK_CMD);\n\n     GET FILE(SAVEFL) LIST(DIM_ESD_ARRAY);\n     ALLOCATE ESD_ARRAY(DIM_ESD_ARRAY);\n     GET FILE(SAVEFL) LIST(ESD_ARRAY);\n\n     GET FILE(SAVEFL) LIST(I);\n     DSC_START=NULL;\n     Q=NULL;\n     DO J=1 BY 1 WHILE(J <= I);\n        ALLOCATE DSC;\n        IF Q\u00ac=NULL THEN Q->DSC.NEXT=DSC_PTR;\n                   ELSE    DSC_START=DSC_PTR;\n        GET FILE(SAVEFL) LIST(DSC);\n        Q=DSC_PTR;\n        DSC.NEXT=NULL;\n     END;\n\n     GET FILE(SAVEFL) LIST(I);\n     RLD_START=NULL;\n     Q=NULL;\n     DO J=1 BY 1 WHILE(J <= I);\n        ALLOCATE RLD;\n        IF Q\u00ac=NULL THEN Q->RLD.NEXT=RLD_PTR;\n                   ELSE    RLD_START=RLD_PTR;\n        GET FILE(SAVEFL) LIST(RLD);\n        Q=RLD_PTR;\n        RLD.NEXT=NULL;\n     END;\n\n     GET FILE(SAVEFL) LIST(I);\n     USING_START=NULL;\n     Q=NULL;\n     DO J=1 BY 1 WHILE(J <= I);\n        ALLOCATE USING;\n        IF Q\u00ac=NULL THEN Q->USING.NEXT=USING_PTR;\n                   ELSE    USING_START=USING_PTR;\n        GET FILE(SAVEFL) LIST(USING);\n        Q=USING_PTR;\n        USING.NEXT=NULL;\n     END;\n\n     GET FILE(SAVEFL) LIST(I);\n     LABL_START=NULL;\n     Q=NULL;\n     DO J=1 BY 1 WHILE(J <= I);\n        ALLOCATE LABL;\n        IF Q\u00ac=NULL THEN Q->LABL.NEXT=LABL_PTR;\n                   ELSE    LABL_START=LABL_PTR;\n        GET FILE(SAVEFL) LIST(LABL);\n        Q=LABL_PTR;\n        LABL.NEXT=NULL;\n     END;\n\n     GET FILE(SAVEFL) LIST(I);\n     LBLOCK_START=NULL;\n     Q=NULL;\n     DO J=1 BY 1 WHILE(J <= I);\n        ALLOCATE LBLOCK;\n        IF Q\u00ac=NULL THEN Q->LBLOCK.NEXT=LBLOCK_PTR;\n                   ELSE    LBLOCK_START=LBLOCK_PTR;\n        GET FILE(SAVEFL) LIST(LBLOCK);\n        Q = LBLOCK_PTR;\n        LBLOCK.NEXT = NULL;\n        P,LBLOCK.ADUMMY = NULL;\n        IF LBLOCK.ADR = 0 THEN DO;\n           CALL REASMLD(LBLOCK.NAME,LBLOCK.ADR,CONTROL);\n           GET FILE(SAVEFL) LIST(K);\n           DO L=1 BY 1 WHILE(L<=K);\n              IF LBLOCK.ADR=0 THEN DO;\n                 ALLOCATE DUMMY;\n                 IF P\u00ac=NULL THEN P->DUMMY.NEXT    = DUMMY_PTR;\n                 ELSE               LBLOCK.ADUMMY = DUMMY_PTR;\n              END;\n              GET FILE(SAVEFL) LIST(DUMMY);\n              IF LBLOCK.ADR=0 THEN DO;\n                 P = DUMMY_PTR;\n                 DUMMY.NEXT = NULL;\n              END;\n           END;\n        END;\n        ELSE\n           CALL REASMLD(LBLOCK.NAME,LBLOCK.ADR,CONTROL);\n     END;\n\n     GET FILE(SAVEFL) LIST(I);\n     COM_START=NULL;\n     Q=NULL;\n     DO J=1 BY 1 WHILE(J <= I);\n        ALLOCATE COM;\n        IF Q\u00ac=NULL THEN Q->COM.NEXT=COM_PTR;\n                   ELSE    COM_START=COM_PTR;\n        GET FILE(SAVEFL) LIST(COM);\n        Q=COM_PTR;\n        COM.NEXT=NULL;\n     END;\n\n     GET FILE(SAVEFL) LIST(I);\n     QUALIFY_START=NULL;\n     Q=NULL;\n     DO J=1 BY 1 WHILE(J <= I);\n        ALLOCATE QUALIFY;\n        IF Q\u00ac=NULL THEN Q->QUALIFY.NEXT=QUALIFY_PTR;\n                   ELSE    QUALIFY_START=QUALIFY_PTR;\n        GET FILE(SAVEFL) LIST(QUALIFY);\n        Q=QUALIFY_PTR;\n        QUALIFY.NEXT=NULL;\n     END;\n\n     CLOSE FILE(SAVEFL);\n END REASMR;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REASMRC": {"ttr": 5640, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x1e\\x02\\x00\\x13\\x00\\x976_\\x01\\x06\\x01\\x7f\\x02\\x14\\x00U\\x00T\\x00\\n\\xd7\\xc7\\xd4\\xe5\\xc3@@@@@'", "ispf": {"version": "30.02", "flags": 0, "createdate": "1997-12-31T00:00:00", "modifydate": "2006-01-17T02:14:13", "lines": 85, "newlines": 84, "modlines": 10, "user": "PGMVC"}, "text": " /*\n//PGMVCI  JOB 'IBI','V CHERNYAK',REGION=1000K,NOTIFY=PGMVC,CLASS=A,\n//        MSGCLASS=A,MSGLEVEL=(1,1)\n//PROCLIB  JCLLIB ORDER=PGMVYC.REASM.PLI\n//        EXEC PLIXCL,PARM.LKED='LET,NCAL'\n//PLI.SYSIN     DD DSN=PGMVYC.REASM.PLI(REASMRC),DISP=SHR\n//PLI.SYSLIB    DD DSN=PGMVYC.REASM.PLI,DISP=SHR\n//LKED.SYSLMOD  DD DSN=PGMVYC.REASM.SUBLOAD(REASMRC),DISP=SHR\n//\n */\n REASMRC:\n   PROC(DDNAME, OPT) RETURNS(BIN FIXED);\n   DCL  DDNAME CHAR(8),     /* RECOVERY DD NAME */\n        OPT    CHAR(1);     /* OPTION: 'C'-CREATE, 'L'-CREATE AS LIB */\n                            /*         'D'-DELETE                    */\n\n   DCL  ISPLINK        EXT ENTRY OPTIONS(ASM INTER RETCODE);\n   DCL  DYNWORK        BIN FIXED(31)  INIT(0);\n   DCL  DYNMSG         CHAR(256);\n   DCL  1 DYNAREA      UNALIGNED,\n          2 DDNAME     CHAR(8),\n          2 DSNAME     CHAR(44),\n          2 DSORG      BIT(16),\n          2 VOL        CHAR(6);\n   DCL  1 DYNINFO      UNALIGNED,\n          2 DDNAME     CHAR(8),\n          2 DSNAME     CHAR(44),\n          2 MEMBER     CHAR(8),\n          2 STATUS     BIT(8),\n          2 DISP       BIT(8),\n          2 COND_DISP  BIT(8),\n          2 DSORG      BIT(16),\n          2 LIMIT      BIN FIXED(15),\n          2 ATTRIBUTE  BIT(8),\n          2 LAST_ENTRY BIT(8),\n          2 TYPE       BIT(8);\n\n   DCL  DYNAM   ENTRY OPTIONS(ASSEMBLER, RETCODE);\n   DCL  (PLIRETV, INDEX, SUBSTR) BUILTIN;\n   DCL  DSNAME  CHAR(44) VAR,\n        JOBNAME CHAR(8), JN CHAR(8) VAR,\n        TXT     CHAR(255) VAR,\n        T       CHAR(255),\n        #8      BIN FIXED(31) INIT(8),\n        RC      BIN FIXED INIT(0);\n\n   CALL ISPLINK('VCOPY ', 'ZUSER ', #8, JOBNAME, 'MOVE ');\n   JN = JOBNAME;\n   IF INDEX(JN,' ') >1 THEN JN = SUBSTR(JN,1,INDEX(JN,' ')-1);\n   DSNAME = JN || '.REASM.RECOVERY';\n   SELECT (OPT);\n     WHEN   ('D');\n     WHEN   ('C','L') DO;\n       CALL DYNAM(DYNWORK, 'INIT ', DYNMSG);\n       CALL DYNAM(DYNWORK, 'INFO ', DYNINFO,\n                  'DD=' || DDNAME || ';');\n       IF (PLIRETV \u00ac= 0)  |\n          (DYNINFO.TYPE = '10000000'B) |\n          (DYNINFO.DSNAME  = 'NULLFILE ') THEN DO;\n          IF PLIRETV=0 THEN\n             CALL DYNAM(DYNINFO, 'UNALLOC ',\n                        'DD=' || DDNAME || ';');\n          TXT = 'DD=' || DDNAME || ' DSN=' || DSNAME;\n          T = TXT || ' SHR;';\n          CALL DYNAM(DYNWORK, 'ALLOCR ', DYNAREA, T);\n          /* PUT SKIP LIST(MESSAGE); */\n          IF PLIRETV \u00ac= 0 THEN DO;\n             TXT = TXT || ' NEW CATLG RECFM=UT BLKSIZE=32000';\n             TXT = TXT || ' TRK PRIMARY=5 SECONDARY=5';\n             IF OPT='C' THEN\n                TXT = TXT || ' DSORG=PS';\n             ELSE\n                TXT = TXT || ' DSORG=PO DIRECTORY=2';\n             T = TXT || ';';\n             CALL DYNAM(DYNWORK, 'ALLOCR ', DYNAREA, T);\n             /* PUT SKIP LIST(MESSAGE); */\n             RC = PLIRETV;\n          END;\n       END;\n       CALL DYNAM(DYNWORK, 'END ');\n     END;\n   END;\n\n   RETURN(RC);\n END REASMRC;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REASMS": {"ttr": 5643, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x1e\\x02\\x00A\\x00\\x976_\\x01\\x06\\x02\\x0f\\x01\\x14\\x00\\x89\\x00\\x89\\x00\\x02\\xd7\\xc7\\xd4\\xe5\\xc3@@@@@'", "ispf": {"version": "30.02", "flags": 0, "createdate": "1997-12-31T00:00:00", "modifydate": "2006-01-20T01:14:41", "lines": 137, "newlines": 137, "modlines": 2, "user": "PGMVC"}, "text": " %PAGE;\n /********************************************************************/\n /*      REASM 'SAVE STATUS' SUBROUTINE                              */\n /********************************************************************/\n REASMS:\n     PROC(MSG,CREATE_TYPE);\n DCL (Q,P)       PTR,\n     MSG         BIT(1),\n     CREATE_TYPE CHAR(1),\n     IDENT       CHAR(20) VAR STATIC INT INIT('REASM 4.0 RECOVERY'),\n     I BIN FIXED INIT(0);\n\n     REMCOUNT=0;\n     IF CREATE_TYPE \u00ac= '*' THEN\n        I = REASMRC(SAVE,CREATE_TYPE);\n\n     IF I \u00ac= 0 THEN DO;\n        CALL ISPLINK('SETMSG ','REAS053 ');\n        GOTO $REC_EXIT;\n     END;\n\n     $CONF='0'B;\n\n     IF MSG THEN DO;\n        CALL ISPLINK('CONTROL ','DISPLAY ','LOCK ');\n        CALL ISPLINK('SETMSG  ','REAS076 ');\n        CALL ISPLINK('DISPLAY ','REASM02 ');\n     END;\n\n     OPEN FILE(SAVEFL) TITLE(SAVE) OUTPUT;\n\n     PUT FILE(SAVEFL) LIST(IDENT);\n\n     PUT FILE(SAVEFL) LIST(TEXTLEN,TEXT);\n\n     PUT FILE(SAVEFL) LIST(DSN,     MEMBER,  CSECT,  OFFSET,\n                           $OFFSET, FOFFSET, BOFFSET,\n                           ESDID,   ARRINDX, #FIND,  BLOCK_CMD);\n\n     PUT FILE(SAVEFL) LIST(DIM_ESD_ARRAY, ESD_ARRAY);\n\n     I=0;\n     Q=DSC_START;\n     DO WHILE(Q\u00ac=NULL);\n        I=I+1; Q=Q->DSC.NEXT;\n     END;\n     PUT FILE(SAVEFL) LIST(I);\n     Q=DSC_START;\n     DO WHILE(Q\u00ac=NULL);\n        PUT FILE(SAVEFL) LIST(Q->DSC); Q=Q->DSC.NEXT;\n     END;\n\n     I=0;\n     Q=RLD_START;\n     DO WHILE(Q\u00ac=NULL);\n        I=I+1; Q=Q->RLD.NEXT;\n     END;\n     PUT FILE(SAVEFL) LIST(I);\n     Q=RLD_START;\n     DO WHILE(Q\u00ac=NULL);\n        PUT FILE(SAVEFL) LIST(Q->RLD); Q=Q->RLD.NEXT;\n     END;\n\n     I=0;\n     Q=USING_START;\n     DO WHILE(Q\u00ac=NULL);\n        I=I+1; Q=Q->USING.NEXT;\n     END;\n     PUT FILE(SAVEFL) LIST(I);\n     Q=USING_START;\n     DO WHILE(Q\u00ac=NULL);\n        PUT FILE(SAVEFL) LIST(Q->USING); Q=Q->USING.NEXT;\n     END;\n\n     I=0;\n     Q=LABL_START;\n     DO WHILE(Q\u00ac=NULL);\n        I=I+1; Q=Q->LABL.NEXT;\n     END;\n     PUT FILE(SAVEFL) LIST(I);\n     Q=LABL_START;\n     DO WHILE(Q\u00ac=NULL);\n        PUT FILE(SAVEFL) LIST(Q->LABL); Q=Q->LABL.NEXT;\n     END;\n\n     I=0;\n     Q=LBLOCK_START;\n     DO WHILE(Q\u00ac=NULL);\n        I=I+1; Q=Q->LBLOCK.NEXT;\n     END;\n     PUT FILE(SAVEFL) LIST(I);\n     Q=LBLOCK_START;\n     DO WHILE(Q\u00ac=NULL);\n        PUT FILE(SAVEFL) LIST(Q->LBLOCK);\n        IF Q->LBLOCK.ADR=0 THEN DO; /*DUMMY*/\n           I = 0;\n           P = Q->LBLOCK.ADUMMY;\n           DO WHILE(P\u00ac=NULL);\n              I=I+1; P = P->DUMMY.NEXT;\n           END;\n           PUT FILE(SAVEFL) LIST(I);\n           P = Q->LBLOCK.ADUMMY;\n           DO WHILE(P\u00ac=NULL);\n              PUT FILE(SAVEFL) LIST(P->DUMMY); P = P->DUMMY.NEXT;\n           END;\n        END;\n        Q=Q->LBLOCK.NEXT;\n     END;\n\n     I=0;\n     Q=COM_START;\n     DO WHILE(Q\u00ac=NULL);\n        I=I+1; Q=Q->COM.NEXT;\n     END;\n     PUT FILE(SAVEFL) LIST(I);\n     Q=COM_START;\n     DO WHILE(Q\u00ac=NULL);\n        PUT FILE(SAVEFL) LIST(Q->COM); Q=Q->COM.NEXT;\n     END;\n\n     I=0;\n     Q=QUALIFY_START;\n     DO WHILE(Q\u00ac=NULL);\n        I=I+1; Q=Q->QUALIFY.NEXT;\n     END;\n     PUT FILE(SAVEFL) LIST(I);\n     Q=QUALIFY_START;\n     DO WHILE(Q\u00ac=NULL);\n        PUT FILE(SAVEFL) LIST(Q->QUALIFY); Q=Q->QUALIFY.NEXT;\n     END;\n\n     CLOSE FILE(SAVEFL);\n     CALL ISPLINK('SETMSG ','REAS054 ');\n\n $REC_EXIT:\n\n END REASMS;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REASMSCR": {"ttr": 5646, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x1e\\x01\\x00\\x11\\x00\\x976_\\x01\\x06\\x02\\x1f\\x155\\x00\\x1f\\x00\\x1f\\x00\\x02\\xd7\\xc7\\xd4\\xe5\\xc3@@@@@'", "ispf": {"version": "30.01", "flags": 0, "createdate": "1997-12-31T00:00:00", "modifydate": "2006-01-21T15:35:11", "lines": 31, "newlines": 31, "modlines": 2, "user": "PGMVC"}, "text": " /***********************************/\n /* DYNAMIC AREA FOR REASM02 PANEL  */\n /***********************************/\n DCL 1 #REASM02,\n      2 REASM02_LINE(0100),\n       3 CMD#     CHAR (1),\n       3 CMD      CHAR (0003),\n       3 OFF#     CHAR (1),\n       3 OFF      CHAR (0006),\n       3 OBJECT#  CHAR (1),\n       3 OBJECT   CHAR (0016),\n       3 LABEL#   CHAR (1),\n       3 LABEL    CHAR (0008),\n       3 OPER#    CHAR (1),\n       3 OPER     CHAR (0005),\n       3 OPERANDS# CHAR (1),\n       3 OPERANDS CHAR (0036),\n     REASM02_CHAR(100,80) CHAR(1) BASED(#REASM02_PTR),\n     REASM02_CHARL(100) CHAR(80)  BASED(#REASM02_PTR),\n     #REASM02_PTR PTR;\n     #REASM02_PTR = ADDR(#REASM02);\n\n DCL   REASM02_DSN     CHAR(60) INIT(''),\n       REASM02_PRIMARY CHAR(70) INIT(''),\n       SCROLL  CHAR(4);\n\n CALL ISPLINK ('VDEFINE ', 'R02DSN ', REASM02_DSN,     'CHAR ', 60 );\n CALL ISPLINK ('VDEFINE ', 'ZZCMD  ', REASM02_PRIMARY, 'CHAR ', 70 );\n CALL ISPLINK ('VDEFINE ', 'SCROLL ', SCROLL,          'CHAR ',  4 );\n CALL ISPLINK ('VDEFINE ', 'SCREEN ', REASM02_CHAR,    'CHAR ',100*80 );\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REASMSVC": {"ttr": 5648, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x1e\\x00\\x00\\x00\\x00\\x976_\\x00\\x976_\\x00I\\x00\\x91\\x00\\x91\\x00\\x00\\xc3\\xc8@@@@@@@@'", "ispf": {"version": "30.00", "flags": 0, "createdate": "1997-12-31T00:00:00", "modifydate": "1997-12-31T00:49:00", "lines": 145, "newlines": 145, "modlines": 0, "user": "CH"}, "text": "\n DCL     SVCTABLE(0:140) CHAR(30) VAR STATIC INT INIT(\n         'EXCP (R1->IOB)',\n         'WAIT (R1->ECB,R0=COUNTER)',\n         'POST (R1->ECB,R0=CODE)',\n         'EXIT (R15=RET.CODE)',\n         'GETMAIN (R1->PARMLIST)',\n         'FREEMAIN (R1->PARMLIST)',\n         'LINK (R15->PARMLIST)',\n         'XCTL (R15->PARMLIST)',\n         'LOAD (R1->DCB,R0->MODNAME)',\n         'DELETE (R0->MODNAME)',\n         'GM/FM (R1->ADR,R0=SP,LEN)',\n         'TIME (R1=TYPE OF REQ)',\n         'SYNCH (R15->ENTRY POINT)',\n         'ABEND (R1=CODE)',\n         'SPIE (R1->PICA)',\n         'ERREXCP (R1->RQE)',\n         'PURGE (R1->PURGE LIST)',\n         'RESTORE (R1->IOB CHAIN)',\n         'BLDL/FIND (R1->DCB,R0->LIST)',\n         'OPEN (R1->PARMLIST)',\n         'CLOSE (R1->PARMLIST)',\n         'STOW (R1->DCB,R0->LIST)',\n         'OPEN TYPE=J (R1->LIST)',\n         'CLOSE TYPE=T (R1->LIST)',\n         'DEVTYPE (R1->DDN,R0->WA)',\n         'TRKBAL (R1->DCB)',\n         'CATALOG (R1->LIST)',\n         'OBTAIN (R1->LIST)',\n         'CVOL (R1->LIST)',\n         'SCRATCH (R1->LIST)',\n         'RENAME (R1->LIST,R0->UCB)',\n         'FEOV (R1->DCB)',\n         'ALLOC (R1->UCBL,R0->JFCB)',\n         'IOHALT (R1->UCB)',\n         'QEDIT (R1,R0->PARMS)',\n         'WTO/WTOR (R1->MSG,R0=ID)',\n         'WTL (R1->PARMLIST)',\n         'SEGLD (R1->SEGNAM,R0=IND)',\n         '', /* SVC38 */\n         'LABEL (R1->PARMLIST)',\n         'EXTRACT (R1->PARMLIST)',\n         'IDENTIFY (R1->EP,R0->NM)',\n         'ATTACH (R1->US,R15->LIST)',\n         'CIRB (R1=DWSZ,R0->EP)',\n         'CHAP (R1->@TCB,R0=VALUE)',\n         'OVLYBRCH (R15->ENTAB)',\n         'TTIMER (R1=1 - CANCEL)',\n         'STIMER (R1->INTR,R0->PGM)',\n         'DEQ (R1->PARMLIST)',\n         'TEST',\n         '', /* SVC50 */\n         'SNAP (R1->PARMLIST)',\n         'RESTART (R1->DCB)',\n         'RELEX (R1->DCB,R0->KEY)',\n         'DISABLE (R1->DCB)',\n         'EOV (R1->DCB,R0->IOB)',\n         'ENQ/RESERVE (R1->LIST)',\n         'FREEDBUF (R1->DCB)',\n         'RELBUF (R1->DCB)',\n         'OLTEP (R0:4-D;8-OV;R1->LST)',\n         'STAE (R1->LIST)',\n         'IKJEGS6A R0->FWA,R1->-DCB',\n         'DETACH (R1->@TCB)',\n         'CHKPT (R1->DCB)',\n         'RDJFCB (R1->PARMLIST)',\n         'QWAIT (R2->PARMLIST)',\n         'BTAMTEST',\n         'ENDREADY',\n         'SYNADAF',\n         'BSP (R1->DCB)',\n         'GSERV (R1->PARMLIST)',\n         'ASGNBFR (R1->PARMLIST)',\n         'BUFINQ/CHATR (R1->LIST)',\n         'SPAR (R1->PARMLIST)',\n         'DAR (R1->PARMLIST)',\n         'DQUEUE (R1->PARMLIST)',\n         'IFBSTAT (LOGREC)',\n         'QTAMTEST',\n         'LSPACE (R1->MSG,R0->UCB)',\n         'STATUS (R1-LIST,R0->LIST)',\n         '', /* SVC 80 */\n         'SETPRT (R1->LIST)',\n         'DASDR (R1->LIST)',\n         'SMFWTM (R1->MSG)',\n         'GRAPHICS (R0->UCB)',\n         'DDRSWAP',\n         'ATLAS (R1->PARMLIST)',\n         'DOM (R1->LST/NO,R0<0,=0)',\n         'MOD88 (R1->DCB,R0=CODE)',\n         'EMRSV (R1->PARMLIST)',\n         'QMNGR (R1->QMPA)',\n         'VOLSTAT (R0->DCB/UCB)',\n         'TCBEXCP (R1->IOB,R0->TCB)',\n         'TGET/TPUT (R1->MSG,R0=TJID)',\n         'TERMINAL (R0=CODE)',\n         'TSEVENT (R0=CODE/0)',\n         'STAX (R1->PARMLIST)',\n         'IKJEGS9G (R1->LIST)',\n         'PROTECT (R1->PARMLIST)',\n         'DYNALLOC',\n         'IKJEFFIB',\n         'QTIP (R1->LIST,R0=CODE)',\n         'AQCTL (R1->LIST)',\n         'XLATE (R1->AR,R0=LEN)',\n         'TOPCTL (R1->AREA)',\n         'IMGLIB (R1=REQ,R0->DCB)',\n         '', /* SVC106 */\n         'MODESET (''3C''-Z/S,''24''-NZ/P)',\n         'ISOLATE',\n         'ESR (R15->SVCEP)',\n         'CSCBPROC',\n         'HASP (R1->RPL/ACB)',\n         'PGRLSE (R0->BEG,R1->END)',\n         'PGFIX/PGFREE(R1->L,R0->ECB)',\n         'EXCPVR (R1->IOB,R0=CD)',\n         'BLKPAGE',\n         'ESR TYPE 1',\n         'DEBCHK (R1->DEB,R0=REQ)',\n         '',\n         'TESTAUTH',\n         'GETM/FREEM',\n         'VSAM',\n         'ESR TYPE 2',\n         'PURGEDQ',\n         'TPIO (R1->EL,R0->ACB)',\n         'EVENTS (R1->TAB,R0->ENTRY)',\n         'MSS (R1->REQ.BLK)',\n         'DIS',\n         '',\n         'DIS',\n         'RACCHECK (R1->LST)',\n         'RACINIT (R1->LST)',\n         'RACLIST (R1->LST)',\n         'RACDEF (R1->LST)',\n         '',\n         '',\n         'CTCOPEN',\n         'ESR TYPE6 (R15=SVC TYPE)',\n         'PGSER',\n         'CVAF',\n         ''\n         );\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REASPRF": {"ttr": 5892, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x1e\\x00\\x00\\x00\\x00\\x976_\\x00\\x976_\\x00I\\x00:\\x00:\\x00\\x00\\xd7\\xc7\\xd4\\xe5\\xe8\\xc3\\xf2@@@'", "ispf": {"version": "30.00", "flags": 0, "createdate": "1997-12-31T00:00:00", "modifydate": "1997-12-31T00:49:00", "lines": 58, "newlines": 58, "modlines": 0, "user": "PGMVYC2"}, "text": "*PROCESS M,S,GN;\n /*\n//PGMVYCI JOB 'IBI','V CHERNYAK',REGION=1000K,NOTIFY=PGMVYC,CLASS=A,\n//        MSGCLASS=A,MSGLEVEL=(1,1),USER=PGMVYC,PASSWORD=CH\n//        EXEC PLIXCL,PARM.LKED='LET,NCAL'\n/*ROUTE PRINT IBIVM.PGMVYC\n//PLI.SYSIN     DD DSN=PGMVYC.REASM.PLI(REASPRF),DISP=SHR\n//PLI.SYSLIB    DD DSN=PGMVYC.REASM.PLI,DISP=SHR\n//LKED.SYSLMOD  DD DSN=PGMVYC.REASM.SUBLOAD(REASPRF),DISP=SHR\n//\n */\n REASPRF: PROC( MODE,\n   $AUTO, $DSOFF, $REM, #ABSA, #ABSB, LINELEN, REMTIME, OS, PC, FC);\n\n   DCL    MODE      CHAR(*),\n          ($AUTO, $DSOFF, $REM)  BIT(1),\n          (#ABSA, #ABSB,  LINELEN, REMTIME, OS, PC, FC) BIN FIXED;\n   DCL    (#I,#A,#B,#T,#D,#U,#O,#P,#F)      BIN FIXED INIT(0),\n          #NOND   CHAR(2)  INIT(''),\n          F2      INIT(2)  BIN FIXED(31),\n          PLIRETV   BUILTIN,\n          ISPLINK   EXT ENTRY OPTIONS(ASM INTER RETCODE);\n\n   CALL ISPLINK ('VDEFINE ', '#I ',    #I,    'FIXED ', F2 );\n   CALL ISPLINK ('VDEFINE ', '#A ',    #A,    'FIXED ', F2 );\n   CALL ISPLINK ('VDEFINE ', '#B ',    #B,    'FIXED ', F2 );\n   CALL ISPLINK ('VDEFINE ', '#T ',    #T,    'FIXED ', F2 );\n   CALL ISPLINK ('VDEFINE ', '#D ',    #D,    'FIXED ', F2 );\n   CALL ISPLINK ('VDEFINE ', '#U ',    #U,    'FIXED ', F2 );\n   CALL ISPLINK ('VDEFINE ', '#O ',    #O,    'FIXED ', F2 );\n   CALL ISPLINK ('VDEFINE ', '#P ',    #P,    'FIXED ', F2 );\n   CALL ISPLINK ('VDEFINE ', '#F ',    #F,    'FIXED ', F2 );\n   CALL ISPLINK ('VDEFINE ', '#NOND ', #NOND, 'CHAR ',  F2 );\n\n   IF MODE\u00ac='DISPLAY' THEN #NOND = 'ND';\n\n L_DISPL:\n   CALL ISPLINK('DISPLAY ', 'REASM06 ');\n   IF PLIRETV() = 0 THEN GOTO L_DISPL;\n\n   CALL ISPLINK ('VDELETE ',\n        '(#I, #A, #B, #T, #D, #U, #O, #P, #F, #NOND)' );\n\n   LINELEN  = #I;\n   #ABSA    = #A;\n   #ABSB    = #B;\n   REMTIME  = #T;\n   IF #U THEN $AUTO  = '1'B;\n   ELSE       $AUTO  = '0'B;\n   IF #D THEN $DSOFF = '1'B;\n   ELSE       $DSOFF = '0'B;\n   IF REMTIME > 0 THEN $REM = '1'B;\n   ELSE                $REM = '0'B;\n   OS       = #O;\n   PC       = #P;\n   FC       = #F;\n\n END REASPRF;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REASQFY": {"ttr": 5894, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x1e\\x01\\x00\\x02\\x00\\x976_\\x01\\x06\\x01?\\x16\\x01\\x00W\\x00W\\x00\\x02\\xd7\\xc7\\xd4\\xe5\\xc3@@@@@'", "ispf": {"version": "30.01", "flags": 0, "createdate": "1997-12-31T00:00:00", "modifydate": "2006-01-13T16:01:02", "lines": 87, "newlines": 87, "modlines": 2, "user": "PGMVC"}, "text": "*PROCESS M,OPT(TIME),S,GN;\n /*\n//PGMVCI  JOB 'IBI','V CHERNYAK',REGION=1000K,NOTIFY=PGMVC,CLASS=A,\n//        MSGCLASS=A,MSGLEVEL=2\n//PROCLIB  JCLLIB ORDER=PGMVYC.REASM.PLI\n//        EXEC PLIXCL,PARM.LKED='LET,NCAL'\n//PLI.SYSIN     DD DSN=PGMVYC.REASM.PLI(REASQFY),DISP=SHR\n//PLI.SYSLIB    DD DSN=PGMVYC.REASM.PLI,DISP=SHR\n//LKED.SYSLMOD  DD DSN=PGMVYC.REASM.SUBLOAD(REASQFY),DISP=SHR\n//\n */\n REASQFY:\n    PROC (Q) REORDER RETURNS(BIN FIXED(31));\n\n %NOPRINT;\n %INCLUDE REASMBAS;\n %PRINT;\n\n DCL     (Q,P)         PTR,\n         F1            BIN FIXED(31)            INIT( 1),\n         F4            BIN FIXED(31)            INIT( 4),\n         F8            BIN FIXED(31)            INIT( 8),\n         F50           BIN FIXED(31)            INIT(50),\n         OFFSET        BIN FIXED(31)            INIT(-1),\n         NROWS         BIN FIXED                INIT(0),\n         TABLE         CHAR(9) STATIC INT       INIT('REASM04 '),\n         C             CHAR(1)                  INIT(''),\n         RQFNAME       CHAR(8)                  INIT(''),\n         RQFOFF        BIN FIXED(31)            INIT(0),\n         RQFOFF1       BIN FIXED(31)            INIT(0),\n         RQFDESC       CHAR(50)                 INIT('');\n\n DCL     ISPLINK ENTRY EXT OPTIONS(ASM INTER RETCODE),\n         (NULL,BIN,PLIRETV) BUILTIN;\n\n     CALL ISPLINK ('VDEFINE ', 'C       ', C,       'CHAR ',  F1, ' ' );\n     CALL ISPLINK ('VDEFINE ', 'RQFNAME ', RQFNAME, 'CHAR ',  F8, ' ' );\n     CALL ISPLINK ('VDEFINE ', 'RQFOFF  ', RQFOFF,  'HEX  ',  F4, ' ' );\n     CALL ISPLINK ('VDEFINE ', 'RQFOFF1 ', RQFOFF1, 'FIXED ', F4, ' ' );\n     CALL ISPLINK ('VDEFINE ', 'RQFDESC ', RQFDESC, 'CHAR ', F50, ' ' );\n\n     CALL ISPLINK ('TBCREATE', TABLE, ' ',\n          '(C,RQFNAME,RQFOFF,RQFOFF1,RQFDESC)',\n          'NOWRITE ', ' ');\n     IF PLIRETV() \u00ac= 0 THEN DO;\n        CALL ISPLINK('SETMSG ', 'REAS074 ');\n        GOTO L_DEL;\n     END;\n\n     P = Q;\n     DO WHILE(P\u00ac=NULL);\n        RQFNAME = P->QUALIFY.NAME;\n        RQFOFF  = P->QUALIFY.OFF;\n        RQFOFF1 = RQFOFF;\n        RQFDESC = P->QUALIFY.DESC;\n        CALL ISPLINK ('TBADD ', TABLE);\n        NROWS   = NROWS+1;\n        P       = P->QUALIFY.NEXT;\n     END;\n\n     CALL ISPLINK ('TBSORT  ', TABLE, '(RQFOFF1,N)');\n     CALL ISPLINK ('TBTOP   ', TABLE);\n\n L_DISPL:\n     CALL ISPLINK ('TBDISPL ', TABLE, TABLE, ' ', ' ', F1, F1,\n                   'YES ', ' ', ' ');\n     IF PLIRETV() <  8 THEN DO;\n        SELECT (C);\n          WHEN ('S','*',':') DO;\n            OFFSET = RQFOFF;\n            GOTO L_END;\n          END;\n          OTHER DO;\n            CALL ISPLINK('SETMSG ','REAS073 ');\n            GOTO L_DISPL;\n          END;\n        END;\n     END;\n\n L_END:\n     CALL ISPLINK ('TBEND   ', TABLE);\n L_DEL:\n     CALL ISPLINK ('VDELETE ',\n          '(C,RQFNAME,RQFOFF,RQFOFF1,RQFDESC)');\n\n     RETURN(OFFSET);\n END REASQFY;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REASQPW": {"ttr": 5897, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x1e\\x00\\x00\\x00\\x00\\x976_\\x00\\x976_\\x00I\\x00T\\x00T\\x00\\x00\\xd7\\xc7\\xd4\\xe5\\xe8\\xc3\\xf2@@@'", "ispf": {"version": "30.00", "flags": 0, "createdate": "1997-12-31T00:00:00", "modifydate": "1997-12-31T00:49:00", "lines": 84, "newlines": 84, "modlines": 0, "user": "PGMVYC2"}, "text": "*PROCESS S,OPTIONS;\n /*\n//PGMVYCI JOB 'IBI','V CHERNYAK',REGION=1000K,NOTIFY=PGMVYC,CLASS=A,\n//        MSGCLASS=A,MSGLEVEL=(1,1),USER=PGMVYC,PASSWORD=CH\n//        EXEC PLIXCL,PARM.LKED='LET,NCAL'\n/*ROUTE PRINT IBIVM.PGMVYC\n//PLI.SYSIN     DD DSN=PGMVYC.REASM.PLI(REASQPW),DISP=SHR\n//PLI.SYSLIB    DD DSN=PGMVYC.REASM.PLI,DISP=SHR\n//LKED.SYSLMOD  DD DSN=PGMVYC.REASM.SUBLOAD(REASQPW),DISP=SHR\n//\n */\n REASQPW: PROC(MODE, PSWD, DATE);\n\n    DCL   MODE   CHAR(*),       /* 'CRYPT' - RETURN PSWD       */\n                                /* (PSWD='' - FOR CURRENT)     */\n                                /* (PSWD=12BYTE - FOR ???      */\n\n                                /* 'CHECK' - CHECK  PSWD       */\n                                /* ON EXIT: PSWD='' -ERROR     */\n          PSWD   CHAR(*),\n          DATE   CHAR(*);       /* YY.DDD FORMAT DATE          */\n\n    DCL 1 PCCA       BASED(PCCAPTR),\n         2 PCCAID    CHAR(4),\n         2 PCCAIDP   CHAR(12),\n          L520       BIN FIXED(31) INIT(520),\n          PCCAPTR    PTR BASED(PCCAPTRPTR),\n          PCCAPTRPTR PTR,\n\n        1 CVT        BASED(CVTPTR) UNALIGNED,\n         2 CVTSKIP   CHAR(116),\n         2 CVTSYS(8) BIT(1),\n          L16        BIN FIXED(31) INIT(16),\n          CVTPTR     PTR BASED(CVTPTRPTR),\n          CVTPTRPTR  PTR,\n\n          PASS       CHAR(20) VAR,\n          (IDP,MCEL) BIN FIXED(31),\n          (YY,DDD)   BIN FIXED(31),\n          (I,J,K);\n\n    DCL   (UNSPEC,LOG,SIN)  BUILTIN;\n\n          UNSPEC(PCCAPTRPTR) = 1000;\n\n          GET STRING('1.2 0.67 520 16') LIST(L520,L520,L520,L16);\n\n          UNSPEC(PCCAPTRPTR) = UNSPEC(L520);\n          GET STRING(DATE) EDIT(YY,DDD)(A(2),X(1),A(3));\n          UNSPEC(CVTPTRPTR)  = UNSPEC(L16);\n\n          DO I=1 TO L520;\n             J = I*3;\n          END;\n\n          PASS = PCCAIDP;\n          IF MODE='CRYPT' & PSWD\u00ac='' THEN  PASS = PSWD;\n\n          GET STRING(PASS) EDIT(IDP,MCEL)(A(8),A(4));\n\n          DO I=1 TO L520;\n             J = I*5;\n          END;\n\n          PUT STRING(PASS)\n              EDIT(SIN(IDP)-LOG(IDP)+MCEL*15+(YY*3+DDD/2)*100000)\n              (P'99999999');\n\n          SELECT (MODE);\n            WHEN ('CRYPT') DO;\n              I=5; J=6;\n              PSWD = PASS;\n            END;\n            WHEN ('CHECK') DO;\n              I=6; J=4;\n              IF PSWD \u00ac= PASS THEN DO;\n                 I=0; J=0;\n                 PSWD = '';\n              END;\n              IF CVTSYS(1) THEN PSWD='*';\n            END;\n          END;\n\n END REASQPW;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REASQPW$": {"ttr": 5900, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x1e\\x01\\x00#\\x00\\x976_\\x01\\x06\\x01?\\x16\\x03\\x00\\x0f\\x00\\x0f\\x00\\x03\\xd7\\xc7\\xd4\\xe5\\xc3@@@@@'", "ispf": {"version": "30.01", "flags": 0, "createdate": "1997-12-31T00:00:00", "modifydate": "2006-01-13T16:03:23", "lines": 15, "newlines": 15, "modlines": 3, "user": "PGMVC"}, "text": "*PROCESS S,OPTIONS;\n /*\n//PGMVCI  JOB 'IBI','V CHERNYAK',REGION=1000K,NOTIFY=PGMVC,CLASS=A,\n//        MSGCLASS=A,MSGLEVEL=(1,1)\n//PROCLIB  JCLLIB ORDER=PGMVYC.REASM.PLI\n//        EXEC PLIXCL,PARM.LKED='LET,NCAL'\n//PLI.SYSIN     DD DSN=PGMVYC.REASM.PLI(REASQPW$),DISP=SHR\n//PLI.SYSLIB    DD DSN=PGMVYC.REASM.PLI,DISP=SHR\n//LKED.SYSLMOD  DD DSN=PGMVYC.REASM.SUBLOAD(REASQPW$),DISP=SHR\n//\n */\n REASQPW: PROC(MODE, PSWD);\n   DCL  (MODE,PSWD) CHAR(*);\n   PSWD = '*';  /* ALWAYS SUCCESFULL */\n END REASQPW;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SCREEN": {"ttr": 5902, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x1e\\x00\\x00\\x00\\x00\\x976_\\x00\\x976_\\x00I\\x00K\\x00K\\x00\\x00\\xd7\\xc7\\xd4\\xe5\\xe8\\xc3@@@@'", "ispf": {"version": "30.00", "flags": 0, "createdate": "1997-12-31T00:00:00", "modifydate": "1997-12-31T00:49:00", "lines": 75, "newlines": 75, "modlines": 0, "user": "PGMVYC"}, "text": " %DCL (#ANO,#ANP,#ANN,#ANF,#AZO,#AZP,#AZN,#AZF,#NNO,#NNP,\n       #NNN,#NNF,#AZOM,#AZPM,#ANPL,#ANPU,#CUR)  ENTRY;\n\n %#ANO:PROC(A) RETURNS(CHAR);\n  DCL A CHAR;\n  RETURN('UNSPEC('||A||')=''00001000''B /* ANO */');\n %END;\n %#ANP:PROC(A) RETURNS(CHAR);\n  DCL A CHAR;\n  RETURN('UNSPEC('||A||')=''00001001''B /* ANP */');\n %END;\n %#ANN:PROC(A) RETURNS(CHAR);\n  DCL A CHAR;\n  RETURN('UNSPEC('||A||')=''00001010''B /* ANN */');\n %END;\n %#ANF:PROC(A) RETURNS(CHAR);\n  DCL A CHAR;\n  RETURN('UNSPEC('||A||')=''00001011''B /* ANF */');\n %END;\n %#AZO:PROC(A) RETURNS(CHAR);\n  DCL A CHAR;\n  RETURN('UNSPEC('||A||')=''00000001''B /* AZO */');\n %END;\n %#AZP:PROC(A) RETURNS(CHAR);\n  DCL A CHAR;\n  RETURN('UNSPEC('||A||')=''00000010''B /* AZP */');\n %END;\n %#AZN:PROC(A) RETURNS(CHAR);\n  DCL A CHAR;\n  RETURN('UNSPEC('||A||')=''00000011''B /* AZN */');\n %END;\n %#AZF:PROC(A) RETURNS(CHAR);\n  DCL A CHAR;\n  RETURN('UNSPEC('||A||')=''00000100''B /* AZF */');\n %END;\n %#NNO:PROC(A) RETURNS(CHAR);\n  DCL A CHAR;\n  RETURN('UNSPEC('||A||')=''00001100''B /* NNO */');\n %END;\n %#NNP:PROC(A) RETURNS(CHAR);\n  DCL A CHAR;\n  RETURN('UNSPEC('||A||')=''00001101''B /* NNP */');\n %END;\n %#NNN:PROC(A) RETURNS(CHAR);\n  DCL A CHAR;\n  RETURN('UNSPEC('||A||')=''00001110''B /* NNN */');\n %END;\n %#NNF:PROC(A) RETURNS(CHAR);\n  DCL A CHAR;\n  RETURN('UNSPEC('||A||')=''00001111''B /* NNF */');\n %END;\n %#AZOM:PROC(A) RETURNS(CHAR);\n  DCL A CHAR;\n  RETURN('UNSPEC('||A||')=''00000101''B /* AZOM */');\n %END;\n %#AZPM:PROC(A) RETURNS(CHAR);\n  DCL A CHAR;\n  RETURN('UNSPEC('||A||')=''00000110''B /* AZPM */');\n %END;\n\n %#ANPL:PROC(A) RETURNS(CHAR);\n  DCL A CHAR;\n  RETURN('UNSPEC('||A||')=''00010000''B /* ANPL */');\n %END;\n %#ANPU:PROC(A) RETURNS(CHAR);\n  DCL A CHAR;\n  RETURN('UNSPEC('||A||')=''00010001''B /* ANPU */');\n %END;\n\n %#CUR:PROC(A,B) RETURNS(CHAR);\n  DCL (A,B) CHAR;\n  RETURN('FIELD = '''||A||' ''; POS = '||B  /* #CUR */);\n %END;\n\n DCL  #MOD   BIT(8) STATIC INT INIT('00111111');   /* 3F */\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ZZTEST": {"ttr": 5905, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x1e\\x00\\x00\\x01\\x00\\x976_\\x00\\x976_\\x00I\\x00\\x15\\x00\\x15\\x00\\x00\\xd7\\xc7\\xd4\\xe5\\xe8\\xc3@@@@'", "ispf": {"version": "30.00", "flags": 0, "createdate": "1997-12-31T00:00:00", "modifydate": "1997-12-31T00:49:01", "lines": 21, "newlines": 21, "modlines": 0, "user": "PGMVYC"}, "text": "//PGMVYCI JOB 'IBI','V CHERNYAK',REGION=3M,NOTIFY=PGMVYC,CLASS=A,\n//        MSGCLASS=A,MSGLEVEL=(1,1)\n//        EXEC PLIXCL\n//PLI.SYSIN     DD *\n ZZJOPA:\n      PROC(PARM) OPTIONS(MAIN);\n\n DCL   PLIXOPT CHAR(62) VAR STATIC EXT INIT('ISA(2K),NOSPIE,NOSTAE');\n DCL   PARM         BIN FIXED(31),\n       PARMPTR      PTR,\n       STRING       CHAR(10) BASED(PARMPTR);\n\n PARMPTR = ADDR(PARM);\n\n DISPLAY(STRING);\n\n END;\n//LKED.SYSLIN   DD\n//              DD *\n   ENTRY PLICALLA\n//LKED.SYSLMOD  DD DSN=PGMVYC.CONS.LOAD(ZZJOPA),DISP=SHR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT243/FILE243.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT243", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}