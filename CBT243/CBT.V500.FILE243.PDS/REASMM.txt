*PROCESS FLAG(E),NEST,OPT(TIME),M,NOINSOURCE,GN,S;
 /*
//PGMVCR  JOB 'IBI','V CHERNYAK',REGION=6M,NOTIFY=PGMVC,CLASS=A,
//        MSGCLASS=A,MSGLEVEL=(0,0)
//PROCLIB  JCLLIB ORDER=PGMVYC.REASM.PLI
//*
//COMPILE EXEC PLIXCL,PARM.LKED='LET,NCAL'
//PLI.SYSLIN  DD UNIT=VIO,SPACE=(TRK,(50,50)),DISP=(,PASS),
//    DSN=&&LOADSET
//PLI.SYSIN     DD DSN=PGMVYC.REASM.PLI(REASMM),DISP=SHR
//PLI.SYSLIB    DD DSN=PGMVYC.REASM.PLI,DISP=SHR
//LKED.SYSLMOD  DD UNIT=VIO,SPACE=(CYL,(5,1,1)),DISP=(,PASS),
//     DCB=(BLKSIZE=13030,RECFM=U,DSORG=PO),DSN=&&LOAD(REASMM)
//*
//LKED2    EXEC PGM=IEWL,PARM='LIST,LET'
//SYSPRINT DD   SYSOUT=*
//SYSUT1   DD   UNIT=VIO,SPACE=(TRK,(30,30))
//SYSLIB   DD   DSN=CEE.SCEELKED,DISP=SHR
//         DD   DSN=PLI.V2R3M0.PLIBASE,DISP=SHR
//         DD   DSN=PLI.V2R3M0.SIBMBASE,DISP=SHR
//         DD   DSN=ISP.SISPLOAD,DISP=SHR
//         DD   DSN=&&LOAD,DISP=(OLD,DELETE)
//         DD   DSN=PGMVYC.REASM.SUBLOAD,DISP=SHR
//*SYSLMOD  DD   DSN=PGMVC.TEST.LOAD,DISP=SHR
//SYSLMOD  DD   DSN=PGMVYC.REASM.LOAD,DISP=SHR
//SYSLIN   DD   *
           INCLUDE SYSLIB(REASMM)
           INCLUDE SYSLIB(REASCNV)
           INCLUDE SYSLIB(REASMLIV)
           INCLUDE SYSLIB(REASQPW$)
           ENTRY PLISTART
           NAME  REASM(R)
//COMPRESS  EXEC  PGM=IEBCOPY
//SYSPRINT  DD    SYSOUT=*
//SYSIN     DD    DUMMY
//SYSUT1    DD    DSN=*.LKED2.SYSLMOD,DISP=SHR
//SYSUT2    DD    DSN=*.LKED2.SYSLMOD,DISP=SHR
//
 */


 /*  ----------------------------------------------------------- */
 /*  MVS/ESA REASM COPYRIGHT (C) 2006, BY VALENTIN CHERNYAK      */
 /*  ----------------------------------------------------------- */

 REASM:
     PROC(PARM) RED OPTIONS(MAIN);

     DCL TEXT    (256000) CHAR(1),
         TEXTCOPY(256000) CHAR(1);
     DCL TEXTIND     BIN FIXED(31) INIT(0);

     %PRINT;
     %INCLUDE REASMMAC;    /* GENERIC MACROS */
     %INCLUDE REASMD;      /* VARIABLES      */
     %INCLUDE REASMCMD;    /* COMMAND ARR    */
     %INCLUDE REASMBAS;    /* DATA BASE      */
     %INCLUDE REASMSVC;    /* SVC NUMBERS    */
     %INCLUDE REASMHRD;    /* HRD CONTS      */
     %PRINT;

     ON ERROR SNAP GOTO $ERROR;

     IF PARM¬='' THEN DO;
     END;

     CALL REASMTL(GOODA);

     CALL REASMI(@,CMDSET,@COMPT);

     CALL REASPRF('NODISPLAY',       /* READ PROFILE VARIABLES */
          $AUTO, $DSOFF, $REM, #ABSA, #ABSB, LINELEN, REMTIME,
          OS,    PC,     FC );

 %NOPRINT;
     %INCLUDE SCREEN;
     %INCLUDE REASMSCR;
 %PRINT;

     CALL ISPLINK ('VDEFINE ', 'FIELD    ', FIELD,    'CHAR ',  8);
     CALL ISPLINK ('VDEFINE ', 'POS      ', POS,      'FIXED ', 4);
     CALL ISPLINK ('VDEFINE ', 'LVL      ', LVL,      'FIXED ', 4);
     CALL ISPLINK ('VDEFINE ', 'MEMOUT   ', MEMOUT,   'CHAR  ', 8);
     CALL ISPLINK ('VDEFINE ', 'FINDTXT  ', FINDTXT,  'CHAR  ', 30);
     CALL ISPLINK ('VDEFINE ', 'IV       ', IV,       'CHAR  ', 4);
     CALL ISPLINK ('VDEFINE ', 'PDFCHAR  ', PDFCHAR,  'CHAR  ', 15);
     CALL ISPLINK ('VDEFINE ', 'PDFBYTE  ', PDFBYTE,  'CHAR  ', 1);
     CALL ISPLINK ('VDEFINE ', 'REASMVER ', REASMVER, 'CHAR  ', 3);
     CALL ISPLINK ('VDEFINE ', 'R01DSN   ', DSN,      'CHAR  ', 44);

     CALL ISPLINK ('VDEFINE ', 'REAPWD01 ', PASS(01), 'CHAR  ', 8);
     CALL ISPLINK ('VDEFINE ', 'REAPWD02 ', PASS(02), 'CHAR  ', 8);
     CALL ISPLINK ('VDEFINE ', 'REAPWD03 ', PASS(03), 'CHAR  ', 8);
     CALL ISPLINK ('VDEFINE ', 'REAPWD04 ', PASS(04), 'CHAR  ', 8);
     CALL ISPLINK ('VDEFINE ', 'REAPWD05 ', PASS(05), 'CHAR  ', 8);
     CALL ISPLINK ('VDEFINE ', 'REAPWD06 ', PASS(06), 'CHAR  ', 8);
     CALL ISPLINK ('VDEFINE ', 'REAPWD07 ', PASS(07), 'CHAR  ', 8);
     CALL ISPLINK ('VDEFINE ', 'REAPWD08 ', PASS(08), 'CHAR  ', 8);
     CALL ISPLINK ('VDEFINE ', 'REAPWD09 ', PASS(09), 'CHAR  ', 8);
     CALL ISPLINK ('VDEFINE ', 'REAPWD10 ', PASS(10), 'CHAR  ', 8);
     CALL ISPLINK ('VDEFINE ', 'REAJDATE ', JDAT,     'CHAR  ', 6);
     CALL ISPLINK ('VDEFINE ', 'DYNMSG   ', DYNMSG,   'CHAR  ', 256);

     CALL ISPLINK ('DISPLAY ', 'REASMIDP '); /* GET IDP PARMS */
     CALL CALCULATE_LVL;

     CALL DYNAM(DYNWORK, 'INIT ', DYNMSG);
     CALL DYNAM(DYNWORK, 'ALLOC ', 'DD=REAPRINT;',
                         'PRIM=5 SEC=10 BLKSIZE=3000 TRK;');

     OPEN FILE(SYSPRINT) TITLE('REAPRINT') PRINT;
     /*
     PUT SKIP EDIT('*** MVS/ESA REASM ', REASMVER,
         '. COPYRIGHT (C) 1985,1987,1991,2006   CHERNYAK VALENTIN')(A);
     */
     ON ENDPAGE(SYSPRINT) BEGIN;
        #PAGE=#PAGE+1;
        PUT PAGE    EDIT('--- MVS/ESA REASM ',
                      REASMVER, '   ', REASM02_DSN,'PAGE ',#PAGE)
                      (A,A,A,A,COL(80),A,F(4));
        PUT SKIP(3);
     END;

     DYNINFO.DSNAME = '';
     DYNINFO.DSORG  = '0'B;
     CALL DYNAM(DYNWORK, 'INFO ', DYNINFO, 'DD=' || SAVE || ';');
     DSRG           = DYNINFO.DSORG;
     DSNSAVE        = DYNINFO.DSNAME;
     MEMSAVE        = DYNINFO.MEMBER;
     VOLSAVE        = '';
     IF DSNSAVE     = 'NULLFILE ' THEN DSRG='0'B;

     /*******************************/
     /* GET MEMBER & CSECT NAMES    */
     /*******************************/
 L_AGAIN:
     CALL FREETEXT();
     @@FREE_CTL (ESD_ARRAY);
     @@FREE_LIST(RLD);
     CALL $FREE;

     I = REASLOA('ALLOC', DSN, VOL, MEMBER, CSECT, ' ');

     /********************************************/
     /*  R E T U R N         HANDLING            */
     /********************************************/
     IF I ¬= 0 THEN DO;       /* END KEY PRESSED */
 $RETURN: CALL DYNAM(DYNWORK, 'END ');
          RETURN;
     END;

     /********************************************/
     /*  R E C O V E R Y     HANDLING            */
     /********************************************/
     IF REASM02_PRIMARY = 'R' THEN DO;
        IF DSRG=PO | DSRG=POU THEN DO;
           CALL $REALLOC(SAVE, DSNSAVE, '', '');
           IF CSECT='' THEN DO;
              CSECT = REASMLB(SAVE);
              IF CSECT='?' | CSECT='' THEN DO;
                 #CUR(CSECT,1);
                 CALL ISPLINK('SETMSG ', 'REAS055 ');
                 GOTO L_AGAIN;
              END;
           END;
           MEMSAVE = CSECT;
           CALL $REALLOC(SAVE, DSNSAVE, MEMSAVE, '');
        END;
        ON ERROR GOTO $REC_ERR;
        CALL REASMR;
        IF PLIRETV()¬=0 THEN DO;
 $REC_ERR: CLOSE FILE(SAVEFL);
           CALL ISPLINK('SETMSG ', 'REAS056 ');
           ON ERROR SNAP GOTO $ERROR;
           GOTO L_AGAIN;
        END;
        ON ERROR SNAP GOTO $ERROR;
        $CONF    =   '0'B;
        REMCOUNT =      0;
        LVL      =      MAXLVL-3;

        DSN = '''' || $NEXTEL(DSN) || '''';
        CALL ISPLINK ('VREPLACE', 'DSN   ', BIN(44,31), DSN   );
        DSN = SUBSTR(DSN,2,INDEX(DSN,' ')-3);
        CALL ISPLINK ('VREPLACE', 'MEM   ', BIN( 8,31), MEMBER);
        CALL ISPLINK ('VREPLACE', 'CSECT ', BIN( 8,31), CSECT );
        GOTO $FORM_REASM02;
     END;

     /********************************************/
     /*  N E W   L I B R A R Y    HANDLING       */
     /********************************************/
     MEMBER = TRANSLATE(MEMBER,'{','¢');
     CALL $OPEN;

     IF REASM02_PRIMARY='M' | CSECT = '' THEN DO;
 L_ESD: CSECT = REASESD(ESD_ARRAY, DIM_ESD_ARRAY);
        ESDLOOP = '1'B;
        IF CSECT = '........' THEN DO;
           ESDLOOP = '0'B;
           CSECT = ''; GOTO L_AGAIN;
        END;
        CALL ISPLINK ('VREPLACE', 'CSECT ', BIN(8,31), CSECT);
     END;
     MEMOUT = CSECT;

     CALL $CSECT;

     IF ESDID = 0 THEN DO;       /* CSECT WAS NOT FOUND OR TOO LONG */
        IF TEXTLEN = 0 THEN
           CALL ISPLINK('SETMSG ', 'REAS062 ');
        ELSE
           CALL ISPLINK('SETMSG ', 'REAS063 ');
        GOTO L_AGAIN;
     END;

     $REM   ='0'B;
     CALL   $INITDSC;
 %PAGE;

     IF DSRG=PO | DSRG=POU THEN DO;
        MEMSAVE = CSECT;
        CALL $REALLOC(SAVE,DSNSAVE,MEMSAVE,'');
     END;

     LINE_C  =    0;
     OFFSET  =    0;
     PENDING = '0'B;
     $FIND   = '0'B;
     #FIND   =   '';
     BOFFSET =    0;
     $CONF   = '0'B;
     $CONFP  = '0'B;
     LVL     = MAXLVL-3;

 $FORM_REASM02:
     LOCVAR=SUBSTR(DSN,1,INDEX(DSN,' ')-1);
     LOCVAR=LOCVAR || '(' || MEMBER || ' ';
     LOCVAR=SUBSTR(LOCVAR,1,INDEX(LOCVAR,' ')-1);
     LOCVAR=LOCVAR || ',' || CSECT  || ' ';
     LOCVAR=SUBSTR(LOCVAR,1,INDEX(LOCVAR,' ')-1);
     LOCVAR=LOCVAR || ') LEN=' || SUBSTR($BH(TEXTLEN),3);
     REASM02_DSN = LOCVAR;

     IV = ' ';
     #CUR(ZZCMD, 1);
     REASM02_PRIMARY = '';

 $SHOW_LOOP:
     DO WHILE(IV ¬= 'PF03');
        CALL $CLEAR_SCR;
        CALL $SHOW;
     END;

     IF $CONF & ¬$CONFP THEN DO;
        IV              = ' ';
        $CONFP          = '1'B;
        CALL ISPLINK ('SETMSG ', 'REAS001 ');  /* CONFIRM END */
        REASM02_PRIMARY = '';
        GOTO $SHOW_LOOP;
     END;
     $CONF = '0'B;
     CALL FREETEXT();
     IF ESDLOOP THEN DO;
       @@FREE_LIST(RLD);
       J = REASLOA('CLOSE', '', '', '', '', '');
       J = REASLOA('OPEN',  '', '', '', '', '');
       GOTO L_ESD;
     END;
     GOTO L_AGAIN;


 %PAGE;
 /*********************************************************************/
 /*  SCAN COMMAND SUBROUTINE                                          */
 /*********************************************************************/
 $CMD:
     PROC (PTR,IP);
     DCL  LINE      CHAR(80),
          LABEL     CHAR(8)  DEF LINE,
          OPNAME    CHAR(6)  DEF LINE POS(10),
          OPERANDS  CHAR(50) DEF LINE POS(16),
          P         PTR,
          #P        BIN FIXED(31) BASED(ADDR(P)),
          PTR       BIN FIXED(31),
          IP        BIN FIXED(31),
          QH        CHAR(1),
          #NOPR     CHAR(1),
          #HEX      CHAR(64) INT STATIC INIT(
 'X''0''X''1''X''2''X''3''X''4''X''5''X''6''X''7''X''8''X''9''X''A''X''B
 ''X''C''X''D''X''E''X''F'''),
          $HEX(0:15) CHAR(4) DEF #HEX,
          (B1,B2)   BIT(16) ALIGNED,
          (I,J,K)   BIN FIXED(31);


     P        = ADDRTEXT();
     #CMD_PTR = PTR+#P;
     LINE     = ' ';
     #COM     = '';
     UNSPEC(#NOPR)='00000111'B;
     GLOBAL_IP = IP;    /* FOR EX IN $ADDR */

     B1='00000000'B || RR1.CODE;    /* 00XX */
     B2=S2.CODE;                    /* XXXX */

     IF B1 = '0000000010100111' |     /* A7 - RI FORMAT  */
        B1 = '0000000010100101' |     /* A5 - RI FORMAT  */
        B1 = '0000000011000000'       /* C0 - RIL FORMAT */
        THEN
        B1 = RI.CODE || RI.CODE1 || '0000'B;

     IF B1 = '0000000011100011' |     /* E3 - RXY FORMAT */
        B1 = '0000000011101011' |     /* EB - SIY FORMAT */
        B1 = '0000000011101100' |     /* EC - RIE FORMAT */
        B1 = '0000000011101101'       /* ED - RXE FORMAT */
        THEN
        B1 = RXY.CODE || RXY.CODE1;

     J = -1;
 CMD:DO I=1 TO CMDNUM(OS);
        SELECT (@(I).F);
          WHEN ($S2,$SSE,$RRE,$RRF,$RRE1,$E) DO;
             IF B2 = @(I).V THEN DO;
                J = I;
                GOTO CONTCMD;
             END;
          END;
          OTHER DO;
             IF  B1 = @(I).V THEN DO;
                J = I;
                GOTO CONTCMD;
             END;
          END;
        END;
 CONTCMD:;
     END CMD;
     IF J = -1 THEN
        GOTO $RETURN_FROM_$CMD;

     I = J;
     IF PC=0 & I>=PACKMIN  & I<=PACKMAX  THEN GOTO $RETURN_FROM_$CMD;
     IF FC=0 & I>=FLOATMIN & I<=FLOATMAX THEN GOTO $RETURN_FROM_$CMD;
     IF @(I).V ¬= 0 THEN DO;
        #FORWARD=0;
        OPNAME=@.N(I);
        IF $NOOP THEN GOTO $RETURN_FROM_$CMD;

        SELECT (@(I).F);
          WHEN ($RR1) DO;
            OPERANDS=$REGS(BIN(RR1.R1,15)) || ',' ||
                     $REGS(BIN(RR1.R2,15));
            SELECT (OPNAME);
              WHEN ('NR','OR') DO;
                IF  RR1.R1 = RR1.R2 THEN
                  #COM=#COM || ' ' || 'TEST ' || $REGS(RR1.R1);
                ELSE DO;
                  IF OPNAME='NR' THEN LOCVAR = ' & ';
                  ELSE                LOCVAR = ' | ';
                  #COM=#COM || ' ' || $REGS(RR1.R1) || '=' ||
                       $REGS(RR1.R1) || LOCVAR || $REGS(RR1.R2);
                END;
              END;
              WHEN ('SR','SLR','XR') DO;
                IF  RR1.R1 = RR1.R2 THEN
                  #COM=#COM || ' ' || $REGS(RR1.R1) || '=0';
                ELSE
                  IF OPNAME='SR' | OPNAME='SLR' THEN
                    #COM=#COM || ' ' || $REGS(RR1.R1) || '=' ||
                         $REGS(RR1.R1) || '-' || $REGS(RR1.R2);
                  ELSE
                    #COM=#COM || ' ' || $REGS(RR1.R1) || '=' ||
                         $REGS(RR1.R1) || ' X ' || $REGS(RR1.R2);
              END;
              WHEN ('AR','ALR') DO;
                IF  RR1.R1 = RR1.R2 THEN
                  #COM=#COM || ' ' || $REGS(RR1.R1) ||
                         '*2';
                ELSE
                  #COM=#COM || ' ' || $REGS(RR1.R1) || '=' ||
                       $REGS(RR1.R1) || '+' || $REGS(RR1.R2);
              END;
              WHEN ('LR')
                #COM=#COM || ' ' || $REGS(RR1.R1) || '=' ||
                     $REGS(RR1.R2);
              WHEN ('LNR')
                #COM=#COM || ' ' || $REGS(RR1.R1) || '= -' ||
                     $REGS(RR1.R2);
              WHEN ('LPR')
                #COM=#COM || ' ' || $REGS(RR1.R1) || '= +' ||
                     $REGS(RR1.R2);
              WHEN ('MR')
                #COM=#COM || ' ' || $REGS(RR1.R1) || $REGS(RR1.R1+1) ||
                     '=' || $REGS(RR1.R1+1) || '*' || $REGS(RR1.R2);
              WHEN ('DR') DO;
                IF RR1.R1 <=14 THEN
                #COM=#COM || ' ' || $REGS(RR1.R1) || '=REMNDR ' ||
                     $REGS(RR1.R1+1) || '=DIVDR';
              END;
              WHEN ('BCTR') DO;
                IF RR1.R2=0 THEN
                   #COM=#COM || ' ' || $REGS(RR1.R1) || '=' ||
                        $REGS(RR1.R1) || '-1';
              END;
              WHEN ('BALR') DO;
                IF RR1.R1=14 & RR1.R2=15 THEN
                   #COM=#COM || ' CALL ';
              END;
              WHEN ('MVCL')
                #COM=#COM || ' ¢' || $REGS(RR1.R1) || '! <-- ¢' ||
                 $REGS(RR1.R2) || '! LEN(' || $REGS(RR1.R1+1) || ')';
              WHEN ('CLCL')
                #COM=#COM || ' COMP ' || $REGS(RR1.R1) || ' & ' ||
                 $REGS(RR1.R2) || ' LEN(' || $REGS(RR1.R1+1) || ')';
              OTHER;
            END;
            IF $XREF THEN DO;
               CALL $PUTXRF($REGS(BIN(RR1.R1,15)));
               CALL $PUTXRF($REGS(BIN(RR1.R2,15)));
            END;
          END;
          WHEN ($RR2) DO;
            I=BIN(RR2.OPER,15);
            OPERANDS=$DIGIT(I);
            IF OPNAME='SVC' & I <= HBOUND(SVCTABLE,1) THEN DO;
               LOCVAR=SVCTABLE(I);
               IF LOCVAR¬='' THEN DO;
                  #COM=LOCVAR || ' ' || #COM;
               END;
            END;
          END;
          WHEN ($RR3) DO;
            OPERANDS=$HEX(BIN(RR3.MASK,15)) || ',' ||
                     $REGS(BIN(RR3.R2,15));
            IF $XREF THEN
               CALL $PUTXRF($REGS(BIN(RR3.R2,15)));
            IF  OPNAME='BCR' THEN DO;
               IF OPPREV¬='' & SUBSTR(OPPREV,1,1)='C' THEN
                  LOCVAR=$EMNEM1(BIN(RR3.MASK,15));   /* COMPARING */
               ELSE
                  LOCVAR=$EMNEM(BIN(RR3.MASK,15));
               IF LOCVAR¬='' THEN DO;
                  OPNAME=LOCVAR||'R';
                  OPERANDS=$REGS(BIN(RR3.R2,15));
               END;
               IF OPNAME='BR' & OPERANDS='R14' THEN DO;
                  IF #COM¬='' THEN #COM = #COM || ' ' || 'RETURN';
                  ELSE             #COM = 'RETURN';
               END;
               IF OPNAME='NOPR' & OPERANDS='R0' &
                  SUBSTRTEXT(PTR+3,1)¬=#NOPR THEN DO;
                  OPNAME='CNOP';
                  SELECT (MOD(#OFFSET+2,8));
                  WHEN (0) OPERANDS='0,4';
                  WHEN (2) OPERANDS='2,8';
                  WHEN (4) OPERANDS='0,4';
                  WHEN (6) OPERANDS='6,8';
                  OTHER
                    OPNAME='NOPR';
                  END;
               END;
            END;
          END;
          WHEN ($RRE) DO;
            OPERANDS=$REGS(BIN(RRE.R1,15)) || ',' ||
                     $REGS(BIN(RRE.R2,15));
            IF RRE.RSRV¬=0 THEN DO;
               $ORGIMM   = $IMM(RRE.RSRV);
               $ORGIMM_B = '*-2';
               $ORGIMM_F = '*+1';
            END;
          END;
          WHEN ($RRF) DO;
            OPERANDS=$REGS(BIN(RRF.R1,15)) || ',' ||
                     $REGS(BIN(RRF.R3,15)) || ',' ||
                     $REGS(BIN(RRF.R2,15));
          END;
          WHEN ($RRE1) DO;
            OPERANDS=$REGS(BIN(RRE1.R1,15));
            IF BIN(RRE1.RSRV,15) ¬= 0 THEN
               #COM = #COM || ' !!! SECOND NIBBLE IS NONZERO !!!';
          END;
          WHEN ($R) DO;
            OPERANDS=$REGS(BIN(R.R1,15));
            IF OPNAME='SPM' & BIN(R.RSRV,15) ¬= 0 THEN
               #COM = #COM || ' !!! SECOND NIBBLE IS NONZERO !!!';
            IF $XREF THEN
               CALL $PUTXRF($REGS(BIN(R.R1,15)));
          END;
          WHEN ($RS1) DO;
            PUT STRING(OPERANDS) EDIT
                    ($REGS(BIN(RS1.R1,15)),',',
                     $REGS(BIN(RS1.R3,15)),',',
                     $ADDR(RS1.B2,RS1.D2,0,'0'B,0,'0'B,OPNAME,PTR))
                     (A,A,A,A,A);
            SELECT (OPNAME);
            WHEN ('LM','STM') DO;
               SELECT;
                 WHEN (RS1.R1=RS1.R3) II=1;
                 WHEN (RS1.R3>RS1.R1) II=RS1.R3-RS1.R1+1;
                 OTHER                II=15-RS1.R1+1+RS1.R3+1;
               END;
               IF II>=1 & II<=16 THEN
                  #COM=#COM || ' PROCESS ' || $NUMBER(II) || ' REGS';
            END;
            WHEN ('LCTL')
               #COM = #COM || ' ' || $CTLREG(RS1.R1);
            WHEN ('BXH') DO;
              I=RS1.R3;
              IF MOD(I,2)=0 THEN
                 I=I+1;
              #COM=#COM || ' ' || $REGS(RS1.R1) || '=' ||
                   $REGS(RS1.R1) || '+' || $REGS(RS1.R3) || ' ' ||
                   $REGS(RS1.R1) || '>' || $REGS(I);
            END;
            WHEN ('BXLE') DO;
              I=RS1.R3;
              IF MOD(I,2)=0 THEN
                 I=I+1;
              #COM=#COM || ' ' || $REGS(RS1.R1) || '=' ||
                   $REGS(RS1.R1) || '+' || $REGS(RS1.R3) || ' ' ||
                   $REGS(RS1.R1) || '<=' || $REGS(I);
            END;
            WHEN ('CS')
              #COM='IF ' || $REGS(RS1.R1) || '=OP ST ' || $REGS(RS1.R3)
                   || ' OP';
            OTHER;
            END;
            IF $XREF THEN
               CALL $PUTXRF($REGS(BIN(RS1.R1,15)));
            IF $XREF THEN
               CALL $PUTXRF($REGS(BIN(RS1.R3,15)));
          END;
          WHEN ($RS2) DO;
            LOCVAR   = $REGS(BIN(RS2.R1,15))   || ',' ||
                       $HEX (BIN(RS2.MASK,15)) || ',' ||
                       $ADDR(RS2.B2,RS2.D2,0,'0'B,0,'0'B,OPNAME,PTR);
            OPERANDS = LOCVAR;
          END;

          WHEN ($RX) DO;
            IF $AUTO          &  OPNAME = 'L' &
               RX.B2  = '0'B  &  RX.X2  = '0'B
               THEN DO;
               IF BIN(RX.D2,15)¬=16 THEN
                  CALL $USING_PSA(PTR);
               ELSE DO;
                  #COM = 'LOAD CVT POINTER';
                  IF  RX.R1¬=0 THEN CALL $USING_CVT(PTR+4,RX.R1);
               END;
            END;

            PUT STRING(OPERANDS) EDIT
                    ($REGS(BIN(RX.R1,15)),',',
                     $ADDR(RX.B2,RX.D2,RX.X2,'1'B,0,'0'B,OPNAME,PTR))
                     (A,A,A);
            SELECT (OPNAME);
            WHEN ('LA') DO;
               SELECT;
               WHEN (RX.B2=0 & RX.X2=0)
                  #COM=#COM || ' ' || $REGS(RX.R1) || '=' ||
                       $DIGIT(RX.D2);
               WHEN ((RX.R1=RX.B2 & RX.X2=0)|(RX.R1=RX.X2 & RX.B2=0))
                  IF RX.D2¬=0 THEN
                     #COM=#COM || ' ' || $REGS(RX.R1) || '=' ||
                          $REGS(RX.R1) || '+' || $DIGIT(RX.D2);
                  ELSE
                     #COM=#COM || ' CLEAR HI BYTE/BIT';
               OTHER;END;
            END;
            WHEN ('SLDL','SLDA','SRDL','SRDA') DO;
               PUT STRING(OPERANDS) EDIT
                       ($REGS(BIN(RX.R1,15)),',',
                        $ADDR(RX.B2,RX.D2,0,'0'B,0,'0'B,OPNAME,PTR))
                        (A,A,A);
            END;
            WHEN ('SLL','SLA') DO;
               PUT STRING(OPERANDS) EDIT
                       ($REGS(BIN(RX.R1,15)),',',
                        $ADDR(RX.B2,RX.D2,0,'0'B,0,'0'B,OPNAME,PTR))
                        (A,A,A);
               IF RX.B2=0 THEN DO;
                 SELECT (RX.D2);
                 WHEN (16)
                    #COM=#COM || ' ' || 'SHIFT ' || $REGS(RX.R1) ||
                         ' LEFT 2 BYTES';
                 WHEN (24)
                    #COM=#COM || ' ' || 'SHIFT ' || $REGS(RX.R1) ||
                         ' LEFT 3 BYTES';
                 OTHER
            /*      #COM=#COM || ' ' || $REGS(RX.R1) || '=' ||
                         $REGS(RX.R1) || '*' || $DIGIT(2**RX.D2);    */
                    #COM=#COM;
                 END;
               END;
            END;
            WHEN ('SRL','SRA') DO;
               PUT STRING(OPERANDS) EDIT
                       ($REGS(BIN(RX.R1,15)),',',
                        $ADDR(RX.B2,RX.D2,0,'0'B,0,'0'B,OPNAME,PTR))
                        (A,A,A);
               IF RX.B2=0 THEN DO;
                 SELECT (RX.D2);
                 WHEN (16)
                    #COM=#COM || ' ' || 'SHIFT ' || $REGS(RX.R1) ||
                         ' RIGHT 2 BYTES';
                 WHEN (24)
                    #COM=#COM || ' ' || 'SHIFT ' || $REGS(RX.R1) ||
                         ' RIGHT 3 BYTES';
                 OTHER
                    #COM=#COM || ' ' || $REGS(RX.R1) || '=' ||
                         $REGS(RX.R1) || '/' || $DIGIT(2**RX.D2);
                 END;
               END;
            END;
            OTHER;
            END;
          END;

          WHEN ($RM) DO;
            PUT STRING(OPERANDS) EDIT
                    ($HEX(BIN(RM.MASK,15)),',',
                     $ADDR(RM.B2,RM.D2,RM.X2,'1'B,0,'0'B,OPNAME,PTR))
                     (A,A,A);
            IF OPNAME='BC' THEN DO;
               IF OPPREV¬='' & SUBSTR(OPPREV,1,1)='C' THEN
                  LOCVAR=$EMNEM1(BIN(RM.MASK,15));   /* COMPARING */
               ELSE
                  LOCVAR=$EMNEM(BIN(RM.MASK,15));
               IF LOCVAR¬='' THEN DO;
                  OPNAME=LOCVAR;
                  OPERANDS=
                    $ADDR(RM.B2,RM.D2,RM.X2,'1'B,0,'0'B,OPNAME,PTR);
               END;
            END;
          END;

          /* 2006 */
          WHEN ($SIY) DO;
            PUT STRING(OPERANDS) EDIT
                ($ADDR(SIY.B2,SIY.DH2||SIY.DL2,0,
                      '0'B,0,'0'B,OPNAME,PTR),
                ',',$IMM(SIY.$I))
                (A,A,A);
          END;

          WHEN ($RXY) DO;
            PUT STRING(OPERANDS) EDIT
             ($REGS(BIN(RXY.R1,15)),',',
              $ADDR(RXY.B2,RXY.DH2||RXY.DL2,RXY.X2,
                           '1'B,0,'0'B,OPNAME,PTR)  )
              (A,A,A);
          END;

          WHEN ($RXY1) DO;
            PUT STRING(OPERANDS) EDIT
             ($REGS(BIN(RXY1.R1,15)),',',
              $REGS(BIN(RXY1.R3,15)),',',
              $ADDR(RXY1.B2,RXY1.DH2||RXY1.DL2,'0'B,
                           '1'B,0,'0'B,OPNAME,PTR)  )
              (A,A,A);
          END;

          WHEN ($RXE) DO;
            OPERANDS =
             $REGS(BIN(RXE.R1,15)) || ',' ||
             $ADDR(RXE.B2,RXE.D2,RXE.X2,'1'B,0,'0'B,OPNAME,PTR);
            IF RXE.RSRV¬=0 THEN DO;
               $ORGIMM=$IMM(RXE.RSRV);
               $ORGIMM_B = '*-2';
               $ORGIMM_F = '*+1';
            END;
          END;

          WHEN ($RXF) DO;
            OPERANDS =
             $REGS(BIN(RXF.R1,15)) || ',' ||
             $REGS(BIN(RXF.R3,15)) || ',' ||
             $ADDR(RXF.B2,RXF.D2,'0'B,'1'B,0,'0'B,OPNAME,PTR);
            IF BIN(RXF.RSRV,15) ¬= 0 THEN
               #COM = #COM || ' !!! SECOND NIBBLE IS NONZERO !!!';
          END;

          WHEN ($RSY) DO;
            OPERANDS =
             $REGS(BIN(RSY.R1,15)) || ',' ||
             $REGS(BIN(RSY.R3,15)) || ',' ||
             $ADDR(RSY.B2,SIY.DH2||RSY.DL2,0,'0'B,0,'0'B,OPNAME,PTR);
          END;

          WHEN ($RSY1) DO;
            OPERANDS =
             $REGS(BIN(RSY1.R1,15)) || ',' ||
             $HEX(BIN(RSY1.MASK,15)) || ',' ||
             $ADDR(RSY1.B2,SIY.DH2||RSY1.DL2,0,'0'B,0,'0'B,OPNAME,PTR);
          END;

          WHEN ($RSL) DO;
            OPERANDS =
             $ADDR(RSL.B1,RSL.D1,0,'0'B,RSL.L1,'1'B,OPNAME,PTR);
            IF BIN(RSL.RSRV,15) ¬= 0 THEN
               #COM = #COM || ' !!! SECOND NIBBLE IS NONZERO !!!';
            IF RSL.RSRV2¬=0 THEN DO;
               $ORGIMM=$IMM(RSL.RSRV2);
               $ORGIMM_B = '*-2';
               $ORGIMM_F = '*+1';
            END;
          END;

          WHEN ($RI) DO;
            PUT STRING(LOCVAR) EDIT(RI.I2)(F(6));
            LOCVAR = SUBSTR(LOCVAR,VERIFY(LOCVAR,' '));
            PUT STRING(OPERANDS) EDIT
                ($REGS(BIN(RI.R1,15)),',',LOCVAR)(A,A,A);
          END;

          WHEN ($RIM) BEGIN;
            DCL LABNAME CHAR(16) VAR;
            LABNAME = $JUMPOFF(RIM.I2, PTR);

            OPERANDS = $HEX(BIN(RIM.MASK,15)) || ',' || LABNAME;
            IF OPPREV¬='' & SUBSTR(OPPREV,1,1)='C' THEN
               LOCVAR=$JMNEM1(BIN(RIM.MASK,15));   /* COMPARING */
            ELSE
               LOCVAR=$JMNEM(BIN(RIM.MASK,15));

            IF LOCVAR¬='' THEN DO;
               OPNAME   = LOCVAR;
               OPERANDS = LABNAME;
            END;
          END;

          WHEN ($RIM1) BEGIN;
             OPERANDS = $REGS(BIN(RIM1.R1,15)) || ',' ||
                 $JUMPOFF(RIM1.I2, PTR);
             IF OPNAME = 'BRCT' THEN OPNAME='JCT';
          END;

          WHEN ($RIE) BEGIN;
             OPERANDS = $REGS(BIN(RIE.R1,15)) || ',' ||
                 $REGS(BIN(RIE.R3,15)) || ',' ||
                 $JUMPOFF(RIE.I2, PTR);
            IF RIE.RSRV¬=0 THEN DO;
               $ORGIMM=$IMM(RIE.RSRV);
               $ORGIMM_B = '*-2';
               $ORGIMM_F = '*+1';
            END;
          END;

          WHEN ($RSI) BEGIN;
             OPERANDS = $REGS(BIN(RSI.R1,15)) || ',' ||
                 $REGS(BIN(RSI.R3,15)) || ',' ||
                 $JUMPOFF(RSI.I2, PTR);
          END;

          WHEN ($RIL) BEGIN;
            OPERANDS = $REGS(BIN(RIL.R1,15)) || ',' ||
                 $JUMPOFF(RIL.I2, PTR);
          END;

          WHEN ($RILM) DO;
            OPERANDS = $HEX(BIN(RILM.MASK,15)) || ',' ||
                  $JUMPOFF(RILM.I2, PTR);
          END;

          WHEN ($E) DO;

          END;

          WHEN ($SI) DO;
            QH=SUBSTR(GOODA,BIN(SI.$I,15)+1,1);
            SELECT (OPNAME);
              WHEN ('MVI','CLI') DO;
                IF QH¬=HIGH(1) THEN #COM = 'C''' || QH || '''' || #COM;
              END;
              WHEN ('OI','NI','XI','TM') DO;
                UNSPEC(QH) = UNSPEC(SI.$I);
                #COM = $BITSTR(QH);
              END;
              WHEN ('STOSM','STNSM') DO;
                DO I=1 TO 8;
                 IF SUBSTR(UNSPEC(SI.$I),I,1) = '1'B & OPNAME='STOSM'
                    THEN #COM = #COM || ' ' || $PSWMASK(I);
                 IF SUBSTR(UNSPEC(SI.$I),I,1) = '0'B & OPNAME='STNSM'
                    THEN #COM = #COM || ' ' || $PSWMASK(I);
                END;
              END;
              OTHER;
            END;
            PUT STRING(OPERANDS) EDIT
                ($ADDR(SI.B2,SI.D2,0,'0'B,0,'0'B,OPNAME,PTR),
                ',',$IMM(SI.$I))
                (A,A,A);
            IF OPNAME='NI' THEN DO;
               I  = SI.$I;
               IF I=255-01  |  I=255-02  | I=255-04 | I=255-08  |
                  I=255-16  |  I=255-32  | I=255-64 | I=255-128 THEN DO;
                  ICH = 255 - I;
                  PUT STRING(OPERANDS) EDIT
                     ($ADDR(SI.B2,SI.D2,0,'0'B,0,'0'B,OPNAME,PTR),
                     ',', 'X''FF''-', $IMM(UNSPEC(CH)))
                     (A,A,A,A);
               END;
            END;
          END;
          WHEN ($S1) DO;
            OPERANDS=$ADDR(S1.B2,S1.D2,0,'0'B,0,'0'B,OPNAME,PTR);
            IF S1.RSRV¬=0 THEN DO;
               $ORGIMM=$IMM(S1.RSRV);
               $ORGIMM_B = '*-3';
               $ORGIMM_F = '*+2';
            END;
          END;
          WHEN ($S2) DO;
            OPERANDS=$ADDR(S1.B2,S1.D2,0,'0'B,0,'0'B,OPNAME,PTR);
            SELECT (OPNAME);
            WHEN ('SPKA') DO;
              IF S1.B2=0 & S1.D2<16 THEN
                #COM = #COM || ' ' || 'SET EXTKEY=' || $KEYNAME(S1.D2);
            END;
            WHEN ('IPK') DO;
              #COM = #COM || ' ' || 'INSERT PSW KEY INTO R2';
            END;
            OTHER;
            END;
          END;
          WHEN ($SS1)
            PUT STRING(OPERANDS) EDIT
             ($ADDR(SS1.B1,SS1.D1,0,'0'B,SS1.LEN1,'1'B,OPNAME,PTR),',',
              $ADDR(SS1.B2,SS1.D2,0,'0'B,SS1.LEN2,'1'B,OPNAME,PTR))
             (A,A,A);
          WHEN ($SS2) DO;
            PUT STRING(OPERANDS) EDIT
             ($ADDR(SS2.B1,SS2.D1,0,'0'B,SS2.LEN,'1'B,OPNAME,PTR),',',
              $ADDR(SS2.B2,SS2.D2,0,'0'B,0,'0'B,OPNAME,PTR))
              (A,A,A);
            SELECT (OPNAME);
              WHEN ('XC','OC','NC') DO;
                IF OPNAME = 'XC' THEN LOCVAR='CLEAR ';
                ELSE                  LOCVAR='TEST ';
                IF (SS2.B1=SS2.B2) & (SS2.D1=SS2.D2) THEN
                   #COM = #COM || ' ' || LOCVAR ||
                   $ADDR(SS2.B2,SS2.D2,0,'0'B,0,'0'B,OPNAME,PTR);
              END;
              OTHER;
            END;
          END;
          WHEN ($SS3)
            PUT STRING(OPERANDS) EDIT
             ($ADDR(SS3.B1,SS3.D1,0,'0'B,SS3.LEN,'1'B,OPNAME,PTR),',',
              $ADDR(SS3.B2,SS3.D2,0,'0'B,0,'0'B,OPNAME,PTR),',',
              $HEX(SS3.I3))
              (A,A,A,A,A);
          WHEN ($SS4)
            PUT STRING(OPERANDS) EDIT
             ($ADDR(SS4.B1,SS4.D1,SS4.R1,'1'B,0,'1'B,OPNAME,PTR),',',
              $ADDR(SS4.B2,SS4.D2,0,     '0'B,0,'0'B,OPNAME,PTR),',',
              $REGS(BIN(SS4.R3,15)))
              (A,A,A,A,A);
          WHEN ($SSE)
            PUT STRING(OPERANDS) EDIT
             ($ADDR(SSE.B1,SSE.D1,0,'0'B,0,'0'B,OPNAME,PTR),',',
              $ADDR(SSE.B2,SSE.D2,0,'0'B,0,'0'B,OPNAME,PTR))
              (A,A,A);
          OTHER DO;
            PUT SKIP DATA(SS2,@(I));
            CALL REASLST;
            SIGNAL ERROR;
            STOP;
          END;
        END;
     END;

 $RETURN_FROM_$CMD:
     REASM02_LINE(IP).LABEL=SUBSTR(LINE,1,8);
     REASM02_LINE(IP).OPER=SUBSTR(LINE,10,5);
     REASM02_LINE(IP).OPERANDS=SUBSTR(LINE,16);
     IF REASM02_LINE(IP).OPER ¬= '' THEN     /* COMMAND MADE ? */
        CALL $PUTOBJ(PTR,CMDLEN(CMDDEF),IP);
     OPPREV=REASM02_LINE(IP).OPER;
 END $CMD;
 %SKIP;
 /*********************************************************************/
 /*  DETERMINE NAME BY BASE/OFFST/INDEX                               */
 /*********************************************************************/
 $ADDR:
     PROC(#B,#D,#X,#FX,#LEN,#FLEN,OPNAME,PTR)
          RETURNS(CHAR(50) VAR);
     DCL  (#B,#X)     BIT(*) ALIGNED,
          (B,X)       BIN FIXED(31),
          #D          BIT(*) ALIGNED,
          D           BIN FIXED(31),
          #LEN        BIT(*) ALIGNED,
          LEN         BIN FIXED(31),
          #FX         BIT(1) ALIGNED,
          FX          BIT(1) ALIGNED,
          #FLEN       BIT(1) ALIGNED,
          FLEN        BIT(1) ALIGNED,
          OPNAME      CHAR(*),
          PTR         BIN FIXED(31),
          (I,J,II,JJ) BIN FIXED(31),
          #I          CHAR(4) BASED(ADDR(I)),
          (P,Q)       PTR,
          #P          BIN FIXED(31) BASED(ADDR(P)),
          N           CHAR(8) VAR,
          ($FB,$FX)   BIT(1) INIT('0'B) ALIGNED,
          #VAL        BIN FIXED(31),
          VAL         CHAR(4) BASED(ADDR(#VAL)),
          #HVAL       BIN FIXED(15),
          HVAL        CHAR(2) BASED(ADDR(#HVAL)),
          1 XLINE     LIKE REASM02_LINE,
          IP          BIN FIXED(31),
          XCMD        PTR,
          C1          CHAR(50) VAR;

     B      = BIN(#B,15);
     X      = BIN(#X,15);
     D      = BIN(#D,15);
     FX     = #FX;
     FLEN   = #FLEN;
     LEN    = BIN(#LEN,15);

     C1=$DIGIT(D);
     IF FLEN | (FX & X¬=0) | B¬=0 THEN DO;
        C1 = C1 || '(';
        IF FLEN THEN C1=C1 || $DIGIT(LEN+1) || ',';
        IF FX THEN DO;
           IF X¬= 0 THEN DO;
              C1  = C1 || $REGS(X);
              $FX = '1'B;
           END;
           IF B¬=0 THEN DO;
              C1  = C1 || ',' || $REGS(B);
              $FB = '1'B;
           END;
        END;
        ELSE DO;
           IF B¬=0 THEN DO;
              C1  = C1 || $REGS(B);
              $FB = '1'B;
           END;
           ELSE
              C1 = SUBSTR(C1,1,LENGTH(C1)-1);
        END;
        C1 = C1 || ')';
     END;
     /**********************************/
     /* TRY MAKE SYMBOLIC NAME         */
     /**********************************/
     USING_PTR=USING_START;
 NEW_USING:
     P=NULL;
     DO WHILE(USING_PTR¬=NULL);
        IF (USING.REG  = B             &
            PTR       >= USING.PLACE   &
            PTR       <  USING.PLACE+USING.LENGTH)   |
           (FX & USING.REG=X           &
            PTR       >= USING.PLACE   &
            PTR       <  USING.PLACE+USING.LENGTH)   THEN DO;
            IF P¬=NULL THEN DO;
               IF P->USING.PLACE < USING.PLACE THEN /* NEW IS LOWER */
                  P=USING_PTR;                      /* 08.12.87 */
            END;
            ELSE  P=USING_PTR;
        END;
        USING_PTR=USING.NEXT;
     END;

 #TEST_USING_AGAIN:
     IF P¬=NULL THEN DO;
        USING_PTR=P;
                                         /* 14.09.88 */
        P=USING_START;
        DO WHILE(P¬=NULL);
           IF P->USING.REG   = USING.REG      &
              P->USING.PLACE > USING.PLACE    &
              P->USING.PLACE <=PTR            THEN DO;
              P=NULL;
              GOTO #TEST_USING_AGAIN;
           END;
           P = P->USING.NEXT;
        END;

        IF USING.REG=X & FX THEN  FX, $FX = '0'B;
        ELSE                      $FB = '0'B;
        IF USING.NAME='' THEN DO;         /* BASE */
           I = USING.OFF + D;             /* ABS DISPL */
           J = I - PTR;
           IF ((J>=0) & ( J<=#ABSA)) |
              ((J<=0) & (-J<=#ABSB)) THEN DO;
              LOCVAR = ''; IF J>=0 THEN LOCVAR = '+';
              C1='*' || LOCVAR || $DIGIT(J);
           END;
           ELSE DO;
              LOCVAR = #I;
              C1     = $NAME(LOCVAR);
              IF B¬=0 THEN  CALL $INITLAB(C1,I,B,'0'B,PTR);
              ELSE          CALL $INITLAB(C1,I,X,'0'B,PTR);
              IF $XREF THEN CALL $PUTXRF(C1);
           END;

           SELECT (OPNAME);
             WHEN ('EX') DO;
               IP = GLOBAL_IP;
               XLINE = REASM02_LINE(IP), BY NAME;
               XCMD  = CMD_PTR;
               CALL $CMD(I,IP);
               IF REASM02_LINE(IP).OPER ¬= '' THEN
                  #COM = REASM02_LINE(IP).OPER     ||
                         REASM02_LINE(IP).OPERANDS;
               ELSE
                  #COM = #COM || '/' || $CH(SUBSTRTEXT(I+1,6));
               REASM02_LINE(IP) = XLINE, BY NAME;
               CMD_PTR = XCMD;
             END;
             WHEN ('L') DO;
               IF I <= TEXTLEN THEN DO;
                  VAL     = SUBSTRTEXT(I+1,4);
                  LOCVAR  = '=X''' || $CH(VAL)     || '''' || '; ' ||
                            '=F''' || $DIGIT(#VAL) || '''';
                  P       = DSC_PTR;
                  CALL $FINDDSC(I);
                  Q       = DSC_PTR;
                  DSC_PTR = P;
                  SELECT (Q->DSC.TYPE);
                  WHEN ('A') DO;
                    IF Q->DSC.LENGTH=4 THEN
                       #COM='=A(' ||
                         $NAME(SUBSTRTEXT(Q->DSC.OFF+1,4)) || ')';
                  END;
                  WHEN ('V') DO;
                    IF Q->DSC.LENGTH=4 THEN DO;
                       LOCVAR = '';
                       HVAL = SUBSTRTEXT(Q->DSC.OFF+3,2);
                       IF #HVAL > 0 THEN LOCVAR='+' || $DIGIT(#HVAL);
                       IF #HVAL < 0 THEN LOCVAR= $DIGIT(#HVAL);
                       LOCVAR = $NEXTEL(Q->DSC.NAME) || LOCVAR;
                       #COM='=V(' || LOCVAR || ')';
                    END;
                  END;
                  OTHER DO;
                    IF #COM¬='' THEN #COM=#COM ||'/' || LOCVAR;
                    ELSE             #COM=LOCVAR;
                  END;
                  END;
               END;
             END;
             WHEN ('C','S','M','D','ST','STM','LM','LCTL','STCTL',
                   'A','AL','CL','SL') DO;
                IF MOD(I,4)=0 THEN DO;
                   P = DSC_PTR;
                   IF $AUTO THEN CALL $INCLUDE(I,4,'F');
                   DSC_PTR = P;
                END;
                SELECT (OPNAME);
                WHEN ('C','A','S','CL','AL','SL','M','D') DO;
                  VAL     = SUBSTRTEXT(I+1,4);
                  LOCVAR  = '=X''' || $CH(VAL)     || '''' || '; ' ||
                            '=F''' || $DIGIT(#VAL) || '''';
                  IF #COM¬='' THEN #COM=#COM || '/' || LOCVAR;
                  ELSE             #COM=LOCVAR;
                END;
                OTHER;
                END;
             END;
             WHEN ('N','O','X') DO;
               VAL     = SUBSTRTEXT(I+1,4);
               LOCVAR  = '=X''' || $CH(VAL)     || '''' || '; ' ||
                         '=F''' || $DIGIT(#VAL) || '''';
               IF #COM¬='' THEN #COM=#COM || '/' || LOCVAR;
               ELSE             #COM=LOCVAR;
             END;
             WHEN ('LH','STH','MH','AH','SH','DH','CH') DO;
                IF MOD(I,2)=0 THEN DO;
                   P = DSC_PTR;
                   IF $AUTO THEN CALL $INCLUDE(I,2,'H');
                   DSC_PTR = P;
                END;
                HVAL=SUBSTRTEXT(I+1,2);
                LOCVAR='=H''' || $DIGIT(#HVAL) || '''';
                IF #COM¬='' THEN #COM=#COM ||'/' || LOCVAR;
                ELSE             #COM=LOCVAR;
             END;

             WHEN ('MVC','CLC','ED','EDMK') DO;
               J = BIN(SS2.LEN+1,15);
               IF I+J > TEXTLEN THEN J = TEXTLEN-I-1;
               IF J < 0          THEN J = 0;
               IF J > 255        THEN J = 255;
               LOCVAR     = SUBSTRTEXT(I+1,J);
               IF $CHARSTR(LOCVAR) THEN DO;
                  IF J>20 THEN J=20;
                  #COM = '=C''' ||     SUBSTRTEXT(I+1,J)  || '''';
               END;
               ELSE DO;
                  IF J>10 THEN J=10;
                  #COM = '=X''' || $CH(SUBSTRTEXT(I+1,J)) || '''';
                  P = DSC_PTR;
                  CALL $FINDDSC(I);
                  Q = DSC_PTR;
                  DSC_PTR = P;
                  SELECT (Q->DSC.TYPE);
                  WHEN ('A') DO;
                    IF Q->DSC.LENGTH=4 THEN
                       #COM='=A(' ||
                         $NAME(SUBSTRTEXT(Q->DSC.OFF+1,4)) || ')';
                  END;
                  WHEN ('V') DO;
                    IF Q->DSC.LENGTH=4 THEN DO;
                       LOCVAR = '';
                       HVAL = SUBSTRTEXT(Q->DSC.OFF+3,2);
                       IF #HVAL > 0 THEN LOCVAR='+' || $DIGIT(#HVAL);
                       IF #HVAL < 0 THEN LOCVAR= $DIGIT(#HVAL);
                       LOCVAR = $NEXTEL(Q->DSC.NAME) || LOCVAR;
                       #COM='=V(' || LOCVAR || ')';
                    END;
                  END;
                  OTHER;
                  END;
               END;
             END;

             WHEN ('LPSW') DO;
               #COM = '=X''' || $CH(SUBSTRTEXT(I+1,8)) || '''';
             END;

             WHEN ('BAL')
               IF I > PTR THEN              #FORWARD = I;
             WHEN ('B')
               IF I > PTR THEN              #FORWARD = I;
             WHEN ('BC')
               IF RM.MASK=15 & I > PTR THEN #FORWARD = I;

             OTHER;
           END;

 $PUTLENX: IF (FX & X¬=0) | FLEN THEN DO;
              IF FLEN THEN C1=C1 || '(' || $DIGIT(LEN+1) || ')';
                      ELSE C1=C1 || '(' || $REGS(X) || ')';
           END;
        END;

        ELSE DO;                         /* DSECT USING */
           LBLOCK_PTR=LBLOCK_START;
           DO WHILE(LBLOCK_PTR¬=NULL);
              IF LBLOCK.NAME=USING.NAME THEN DO; /* APPROPRIATE LIVB */
                 IF (USING.REG=0 & B=0 & X=0) | USING.REG¬=0 THEN
                    GOTO $GOODLIV;
              END;
              LBLOCK_PTR=LBLOCK.NEXT;
           END;

 $GOODLIV: IF LBLOCK_PTR=NULL THEN DO;
              IF USING.REG=0 THEN DO;
                 USING_PTR = USING.NEXT;
                 GOTO NEW_USING;
              END;
              SIGNAL ERROR;
              STOP;
           END;

           IF LBLOCK.ADR = 0 THEN DO;
 $PUTC1:      C1 = $DNAME(LBLOCK_PTR,BIN(D,15),I);
              CALL $PUTDUMMY(LBLOCK.NAME,D);
              IF $XREF THEN CALL $PUTXRF(C1);
              IF $DSOFF & (I=1) THEN
                 C1=$NEXTEL(SUBSTR(LBLOCK.NAME,2)) || '+' || $DIGIT(D);
              GOTO $PUTLENX;
           END;
           ELSE DO;
              C1=$LFIND(LBLOCK_PTR,D,$XREF,#COM,$PUTXRF);
              IF C1='' THEN GOTO $PUTC1;
                       ELSE GOTO $PUTLENX;
           END;
        END;
     END;
     ELSE DO;     /* DO NOT HAVE RELEVAND BASE REG  */
 $NOLIV:
       IF OPNAME='B' THEN DO;
          IF (RM.B2=15 & RM.X2=0) | (RM.B2=0 & RM.X2=15) THEN
             #FORWARD=RM.D2;
       END;
     END;

     IF $XREF THEN DO;
        IF $FB THEN
           CALL $PUTXRF($REGS(B));
        IF $FX THEN
           CALL $PUTXRF($REGS(X));
     END;
     RETURN (C1);
 END $ADDR;
 %PAGE;
 /*********************************************************************/
 /*  OPEN MEMBER SUBROUTINE                                           */
 /*  IF FIRST TIME THEN CREATE ESD TABLE                              */
 /*********************************************************************/
 $OPEN:
     PROC ;
     DCL  (I,J,K,LASTSD) BIN FIXED(31) INIT(0);

     J = REASLOA('OPEN', '', '', '', '', '');

     ESD_BLOCK_PTR=ADDR(BLOCK);

     DO J=1 TO 10;
        CALL REASQPW('CHECK',PASS(J),JDAT);
     END;

     CALL $READ;
     DO WHILE(UNSPEC(IDENT)='01000000'B);      /*  LOOP SYM     */
        CALL $READ;
     END;
     DO WHILE(UNSPEC(IDENT)='00100000'B);      /*  LOOP ESD     */
        I=I+ESDLEN/16;                         /*  ESD EL NUM   */
        CALL $READ;
     END;
     ALLOCATE ESD_ARRAY(I);
     DIM_ESD_ARRAY = I;

     J = REASLOA('CLOSE', '', '', '', '', '');
     J = REASLOA('OPEN',  '', '', '', '', '');

     I=0; CALL $READ;
     DO WHILE(UNSPEC(IDENT)='01000000'B);      /*  LOOP SYM     */
        CALL $READ;
     END;
     DO WHILE(UNSPEC(IDENT)='00100000'B); /*  ESD LOOP    */
        #ESD_ELEMENT_PTR=#ESD_BLOCK_PTR+8;
        DO K=1 TO ESDLEN/16;
          I=I+1;
          ESD_ARRAY(I) = ESD_ELEMENT, BY NAME;
          ONEBYTE = ESD_ARRAY(I).TYPE;
          ESD_ARRAY(I).ID  = FIRST_ESDID+K-1;
          ESD_ARRAY(I).REF = 0;
          IF ¬BIT4 &  BIT5 & ¬BIT6 & ¬BIT7 THEN   /* 04  **** PC */
             ESD_ARRAY(I).TYPE = '0'B;            /*     MAKE SD */
          IF ¬BIT4 & ¬BIT5 & ¬BIT6 & ¬BIT7 THEN   /* 0F  **** SD */
             LASTSD = ESD_ARRAY(I).ID;            /*     REMEMBER*/
          IF  BIT4 & ¬BIT5 &  BIT6 & ¬BIT7 THEN   /* 0A  **** WX */
             ESD_ARRAY(I).REF = LASTSD;           /*     SET REF */
          IF (¬BIT4 & ¬BIT5 &  BIT6 &  BIT7) |    /* 03  **** LD */
             (¬BIT4 &  BIT5 &  BIT6 & ¬BIT7) THEN /* 06  **** XD */
             ESD_ARRAY(I).REF=
                 BIN(SUBSTR(UNSPEC(ESD_ARRAY(I).LENGTH),9),15);
          #ESD_ELEMENT_PTR=#ESD_ELEMENT_PTR+16;
        END;
        CALL $READ;
     END;
 END $OPEN;
 %PAGE;
 /*********************************************************************/
 /*  FIND CSECT AND READ ITS BODY                                     */
 /*********************************************************************/
 $CSECT:
     PROC ;
     DCL  (I,J,K,L) BIN FIXED(31),
          (#F,#T)   BIN FIXED(31),
          $RYES     BIT(1),
          NN        CHAR(8);

     ESDID   = 0;
     TEXTLEN = 0;
 $CSECT_ESD_LOOP:
     DO I=1 TO DIM_ESD_ARRAY;
        IF  ESD_ARRAY(I).NAME=CSECT THEN DO;
            ONEBYTE = ESD_ARRAY(I).TYPE;
            IF  ¬BIT4 & ¬BIT5 & ¬BIT6 & ¬BIT7 THEN DO; /* SD */
                ESDID=ESD_ARRAY(I).ID;
                K=ESD_ARRAY(I).LENGTH;
                ARRINDX=I;
                LEAVE $CSECT_ESD_LOOP;
            END;
            IF  ¬BIT4 & ¬BIT5 & BIT6 & BIT7 THEN DO;   /* LD */
                ESDID=ESD_ARRAY(I).REF;
                DO J=1 TO DIM_ESD_ARRAY;
                   ONEBYTE = ESD_ARRAY(J).TYPE;
                   IF  ESDID=ESD_ARRAY(J).ID &
                       ¬BIT4 & ¬BIT5 & ¬BIT6 & ¬BIT7 THEN DO;
                       CSECT=ESD_ARRAY(J).NAME;
                       K=ESD_ARRAY(J).LENGTH;
                       ARRINDX=J;
                       LEAVE $CSECT_ESD_LOOP;
                   END;
                END;
                SIGNAL ERROR;
                STOP;
            END;
        END;
     END $CSECT_ESD_LOOP;

     IF ESDID=0 THEN RETURN;

     IF K > HBOUND(TEXT,1) | K=0 THEN DO;
        TEXTLEN = 0;
        ESDID=0;
        RETURN;
     END;

     CALL ALLOCATETEXT(0);
     TEXTLEN = K;

     CNTL_BLOCK_PTR=ADDR(BLOCK);

 $CSECT_CNTL_LOOP:
     DO WHILE(¬$EOF);
        IF CNTLYES & CNTLNO¬=0 THEN DO;
           #CNTL_ELEMENT_PTR=#CNTL_BLOCK_PTR+16+RLDNO;
           DO I=1 TO CNTLNO/4;
              IF  CNTLID=ESDID THEN DO;
                J=ESD_ARRAY(ARRINDX).OFF-TXTOFF;
                K=CNTLLEN;        /* LENGTH IN THIS BLOCK         */
                CALL $READ;       /* READ BLOCK AFTER CNTL RECORD */
                IF $EOF THEN GOTO EOF;
                CALL SETTEXT(SUBSTR(BLOCK,J+1,K));
                LEAVE $CSECT_CNTL_LOOP;
              END;
              #CNTL_ELEMENT_PTR=#CNTL_ELEMENT_PTR+4;
           END;
           CALL $READ;
           IF $EOF THEN GOTO EOF;
        END;
        CALL $READ;
        IF $EOF THEN GOTO EOF;
     END $CSECT_CNTL_LOOP;
     CALL $READ;
     IF $EOF THEN GOTO EOF;

 $CSECT_GETTEXT_LOOP:
     DO WHILE(¬$EOF);
         /***************************/
         /* RLD INFO EXISTS         */
         /***************************/
         IF RLDYES & RLDNO¬=0 THEN DO;
            #RLD_ELEMENT_PTR=#CNTL_BLOCK_PTR+16;
            I=1;
            DO WHILE(I <= RLDNO/4);
               #F=FROMID;
               #T=TOID;
               I=I+1;
               #RLD_ELEMENT_PTR=#RLD_ELEMENT_PTR+4;
               IF #F=ESDID THEN DO;
                  DO J=1 TO DIM_ESD_ARRAY;
                     K=J;
                     IF #T=ESD_ARRAY(K).ID THEN LEAVE;
                  END;
                  NN=ESD_ARRAY(K).NAME;
                  DO WHILE('1'B);
                     ALLOCATE RLD;
                     IF RLD_START=NULL THEN RLD_START=RLD_PTR;
                                       ELSE PREV->RLD.NEXT=RLD_PTR;
                     PREV=RLD_PTR;
                     RLD.NEXT=NULL;
                     RLD.LENGTH=RLDLEN+1;
                     RLD.OFF=RLDOFF-ESD_ARRAY(ARRINDX).OFF;
                     RLD.NAME=NN;
                     RLD.SUBT=RLDE_ELEMENT.SUBT;
                     RLD.TYPE=$RLDTYPE(RLDTYPE);
                     IF RLD.TYPE='A' & #F¬=#T THEN DO;
                        RLD.TYPE='V';
                     END;
                     IF ¬NOTLAST THEN LEAVE;
                     #RLD_ELEMENT_PTR=#RLD_ELEMENT_PTR+4;
                     I=I+1;
                  END;
               END;
               ELSE DO;
                  DO WHILE('1'B);
                     IF ¬NOTLAST THEN LEAVE;
                     #RLD_ELEMENT_PTR=#RLD_ELEMENT_PTR+4;
                     I=I+1;
                  END;
               END;
               I=I+1;
               #RLD_ELEMENT_PTR=#RLD_ELEMENT_PTR+4;
            END;
            IF CNTL_BLOCK.LAST THEN
               LEAVE $CSECT_GETTEXT_LOOP;
         END;
         /***************************/
         /* CNTL INFO EXISTS        */
         /***************************/
         IF CNTLYES & CNTLNO¬=0 THEN DO;
            #CNTL_ELEMENT_PTR=#CNTL_BLOCK_PTR+16+RLDNO;
            $RYES='0'B;
 $CSECT_CNTL_LOOP_#1:
            DO I=1 TO CNTLNO/4;
               IF CNTLID=ESDID THEN DO;
                  K=TXTOFF-ESD_ARRAY(ARRINDX).OFF-LENGTHTEXT();
                  IF K > 0 THEN DO;
                     ALLOCATE ORG;
                     ORG.NEXT=ORG_START;
                     ORG_START=ORG_PTR;
                     ORG.OFF=LENGTHTEXT();
                     ORG.LENGTH=K;
                     CALL CONCATTEXT(HIGH(K));
                  END;
                  J=TEXTLEN-LENGTHTEXT();
                  IF CNTLLEN < J THEN J=CNTLLEN;
                  CALL $READ;
                  IF $EOF THEN GOTO EOF;
                  $RYES='1'B;
                  CALL CONCATTEXT(SUBSTR(BLOCK,1,J));
                  LEAVE $CSECT_CNTL_LOOP_#1;
               END;
               #CNTL_ELEMENT_PTR=#CNTL_ELEMENT_PTR+4;
               IF TEXTLEN=LENGTHTEXT() THEN
                  LEAVE $CSECT_CNTL_LOOP_#1;
            END;
            IF ¬$RYES THEN CALL $READ;
            IF $EOF THEN GOTO EOF;
         END;
         CALL $READ;
         IF $EOF THEN GOTO EOF;
     END $CSECT_GETTEXT_LOOP;

 EOF:
     IF LENGTHTEXT() < TEXTLEN THEN DO;
        ALLOCATE     ORG;
        ORG.NEXT   = ORG_START;
        ORG_START  = ORG_PTR;
        ORG.OFF    = LENGTHTEXT();
        ORG.LENGTH = TEXTLEN-LENGTHTEXT();
        CALL CONCATTEXT(HIGH(TEXTLEN-LENGTHTEXT()));
     END;

     CALL COPYTEXT();

 END $CSECT;
 %PAGE;
 /*********************************************************************/
 /*  READ NEXT RECORD                                                 */
 /*********************************************************************/
 $READ: PROC ;
  DCL  I;
     I = REASLOA('READ', '', '', '', '', BLOCK);
     IF I ¬= 0 THEN $EOF = '1'B;
     ELSE           $EOF = '0'B;
 END $READ;
 %SKIP;
 /*********************************************************************/
 /*  SORT KNOWLEDGE BASE                                              */
 /*********************************************************************/
 $SORTDSC:
     PROC RECURSIVE ;
 DCL   SORT  BIT(1) INIT('1'B),
       (P,Q) PTR INIT(NULL);

     IF DSC_START=NULL THEN RETURN;

     DO WHILE(SORT);
        SORT='0'B;
        DSC_PTR=DSC_START;
        P=DSC.NEXT;
        DO WHILE(P¬=NULL);
           IF P->DSC.OFF < DSC.OFF THEN DO;
             IF DSC_PTR=DSC_START THEN DSC_START=P;
                                  ELSE Q->DSC.NEXT=P;
             DSC.NEXT=P->DSC.NEXT;
             P->DSC.NEXT=DSC_PTR;
             SORT='1'B;
             Q=P;
           END;
           ELSE DO;
             Q=DSC_PTR;
             DSC_PTR=P;
           END;
           P=DSC.NEXT;
        END;
     END;
 END $SORTDSC;
 %PAGE;
 /*********************************************************************/
 /*  INIT KNOWLEDGE BASE                                              */
 /*********************************************************************/
 $INITDSC:
     PROC ;
 DCL P      PTR,
     #VAL   BIN FIXED(31),
     VAL    CHAR(2) BASED(ADDR(#VAL)),
     I      BIN FIXED(31);

     CALL $FREE;

     RLD_PTR = RLD_START;
     DO WHILE(RLD_PTR¬=NULL);
        ALLOCATE DSC;
        DSC.NEW='0'B;
        DSC.FIX='0'B;
        IF DSC_START=NULL THEN DSC_START      = DSC_PTR;
                          ELSE PREV->DSC.NEXT = DSC_PTR;
        PREV = DSC_PTR;
        DSC  = RLD, BY NAME;
        DSC.NORED = '1'B;        /* CANN'T REDEFINE |     */
        DSC.EXTRN = '0'B;
        DSC.NEXT  = NULL;
        IF RLD.TYPE='A' THEN
           CALL $SUBT(RLD.OFF,RLD.LENGTH,ESD_ARRAY(ARRINDX).OFF);
        IF RLD.TYPE='V' THEN DO;
           DO I=1 TO DIM_ESD_ARRAY WHILE(ESD_ARRAY(I).NAME ¬= RLD.NAME);
           END;
           IF ESD_ARRAY(I).NAME = RLD.NAME THEN DO;
              CALL $SUBT(RLD.OFF,RLD.LENGTH,ESD_ARRAY(I).OFF);
              ONEBYTE = ESD_ARRAY(I).TYPE;
              IF ¬BIT4 & ¬BIT5 & BIT6 & ¬BIT7 THEN DSC.EXTRN='1'B;
           END;
        END;
        IF RLD.LENGTH=4 THEN VAL=SUBSTRTEXT(RLD.OFF+1+2,2);
        ELSE                 VAL=SUBSTRTEXT(RLD.OFF+1+1,2);
        IF RLD.TYPE='A' THEN
           CALL $INITLAB($NAME(SUBSTRTEXT(RLD.OFF+1,RLD.LENGTH)),
                         #VAL,0,'0'B,0);
        IF SUBSTRTEXT(RLD.OFF+1,RLD.LENGTH) ¬= LOW(RLD.LENGTH) &
           RLD.TYPE='V' THEN
           DSC.EXTRN='1'B;
        RLD_PTR=RLD.NEXT;
     END;
     DO I=1 TO DIM_ESD_ARRAY;
        ONEBYTE = ESD_ARRAY(I).TYPE;
        IF ESD_ARRAY(I).REF=ESDID &
           ¬BIT4 & ¬BIT5 & BIT6 & BIT7 THEN DO;
           CALL $INITLAB(ESD_ARRAY(I).NAME,
                         ESD_ARRAY(I).OFF-ESD_ARRAY(ARRINDX).OFF,
                         0,'1'B,0);
           LABL.NORED = '1'B;    /* 17/05/91 */
        END;
     END;
     CALL $SORTDSC;
     ORG_PTR=ORG_START;
     DO WHILE(ORG_PTR¬=NULL);
        CALL $INCLUDE(ORG.OFF,ORG.LENGTH,'O');
        PREV=ORG_PTR;
        ORG_PTR=ORG.NEXT;
        FREE PREV->ORG;
     END;
     ORG_START=NULL;
     I=0;
     DSC_PTR=DSC_START;
     DO WHILE(DSC_PTR¬=NULL);
        DSC.NORED='1'B;
        I=I+DSC.LENGTH;
        DSC_PTR=DSC.NEXT;
     END;
     IF I < TEXTLEN THEN
        CALL $INCLUDE(0,TEXTLEN,'X');
 END $INITDSC;
 %PAGE;
 /*********************************************************************/
 /*  CONNECT NEIGHBOUR PIECES IN KNOWLEDGE BASE                       */
 /*********************************************************************/
 $CONNECT:
     PROC RECURSIVE ;

 DCL (P,Q) PTR INIT(NULL);
     DSC_PTR=DSC_START;
     P=DSC.NEXT;
     DO WHILE(DSC_PTR¬=NULL & P¬=NULL);
        IF DSC.OFF+DSC.LENGTH = P->DSC.OFF         &
           DSC.TYPE              = P->DSC.TYPE     &
           DSC.NORED             = P->DSC.NORED    &
           (DSC.TYPE='I' | DSC.TYPE='X' | DSC.TYPE='C' |
            DSC.TYPE='#' | DSC.TYPE='B'                 ) &
           ¬DSC.NORED                              THEN DO;
           DSC.LENGTH=DSC.LENGTH+P->DSC.LENGTH;
           DSC.NEXT=P->DSC.NEXT;
           FREE P->DSC;
        END;
        ELSE DO;
           Q=DSC_PTR;
           DSC_PTR=P;
        END;
        P=DSC.NEXT;
        IF DSC.LENGTH=0 THEN DO;
           IF Q¬=NULL THEN Q->DSC.NEXT=DSC.NEXT;
                      ELSE DSC_START=DSC.NEXT;
           FREE DSC;
           DSC_PTR=P;
           IF DSC_PTR¬=NULL THEN P=DSC.NEXT;
        END;
     END;

 END $CONNECT;
 %SKIP;
 /*********************************************************************/
 /*  INCLUDE NEW ELEMENT INTO BASE                                    */
 /*********************************************************************/
 $INCLUDE:
     PROC(FROM,LEN,T) RECURSIVE;

 DCL (FROM,LEN,TO) BIN FIXED(31),
     T        CHAR(1),
     P        PTR;

     $CONF='1'B;

     IF $REM THEN
        CALL $AUTOREC;

     /* 1. CREATE NEW ELEMENT AND INCLUDE IT AT TOP OF BASE */
     ALLOCATE DSC;
     DSC.OFF=FROM;
     DSC.LENGTH=LEN;
     DSC.TYPE=T;
     DSC.NORED='0'B;
     DSC.SUBT='0'B;
     DSC.NEW='1'B;
     DSC.FIX='0'B;
     DSC.EXTRN='0'B;
     DSC.NEXT=DSC_START;
     DSC.NAME='*';
     DSC_START=DSC_PTR;
     /* 2. BASE SORT */
     CALL $SORTDSC;
     IF $TRACE THEN
        CALL $PRINTDSC('NEW ELEMENT:AFTER SORT');
     /* 3. PRESS TRASH INFO         */
     CALL $PRESS;
     IF $TRACE THEN
        CALL $PRINTDSC('AFTER $PRESS');
     CALL $CONNECT;
     IF $TRACE THEN
        CALL $PRINTDSC('AFTER $CONNECT');
 END $INCLUDE;
 %PAGE;
 /*********************************************************************/
 /*  PRESS TRASH SUBROUTINE                                           */
 /*********************************************************************/
 $PRESS:
     PROC RECURSIVE ;
 DCL (I,J,K)        BIN FIXED(31),
     $BIT(4)        BIT(1),
     (D,SPTR,P,Q,R) PTR;

 $PRESS_BEGIN:
     Q=NULL;
     D=DSC_START;
     DO WHILE(¬D->DSC.NEW);    /* FIND NEW-ELEMENT */
        Q=D;
        D=D->DSC.NEXT;
     END;
     P=D->DSC.NEXT;

     IF Q¬=NULL THEN           /* NOT FIRST        */
        IF Q->DSC.OFF+Q->DSC.LENGTH > D->DSC.OFF THEN DO;
           P=D;
           D=Q;
        END;

 $TEST_AGAIN:
     $BIT='0'B;
     $BIT(1) = D->DSC.NORED;
     $BIT(2) = D->DSC.NEW;
     IF P¬=NULL THEN DO;
       $BIT(3) = P->DSC.NORED;
       $BIT(4) = P->DSC.NEW;
     END;
     K=0;
     IF $BIT(1) THEN K=K+8;
     IF $BIT(2) THEN K=K+4;
     IF $BIT(3) THEN K=K+2;
     IF $BIT(4) THEN K=K+1;

     IF $TRACE THEN DO;
        PUT SKIP DATA($BIT,K);
        PUT SKIP EDIT('  Q->:',Q->DSC.NAME,$BH(Q->DSC.OFF),
                      $BH(Q->DSC.LENGTH),Q->DSC.TYPE,Q->DSC.NORED,
                      Q->DSC.NEW,Q->DSC.FIX,Q->DSC.EXTRN,Q->DSC.SUBT)
                     ((5)(A,X(1)),(5)(B(1),X(1)));
        PUT SKIP EDIT('  D->:',D->DSC.NAME,$BH(D->DSC.OFF),
                      $BH(D->DSC.LENGTH),D->DSC.TYPE,D->DSC.NORED,
                      D->DSC.NEW,D->DSC.FIX,D->DSC.EXTRN,D->DSC.SUBT)
                     ((5)(A,X(1)),(5)(B(1),X(1)));
        PUT SKIP EDIT('  P->:',P->DSC.NAME,$BH(P->DSC.OFF),
                      $BH(P->DSC.LENGTH),P->DSC.TYPE,P->DSC.NORED,
                      P->DSC.NEW,P->DSC.FIX,P->DSC.EXTRN,P->DSC.SUBT)
                     ((5)(A,X(1)),(5)(B(1),X(1)));
        CALL REASLST;
     END;

     /*        BITS COORDINATION AND OVERLAY:
        D->R D->N P->R P->N    WHICH
        BIT1 BIT2 BIT3 BIT4 WILL BE OVERAYED
        ---- ---- ---- ---- ----------------
     0   0    0    0    0      -"-    0
     1   0    0    0    1       L     1
     2   0    0    1    0      -"-    2
     3   0    0    1    1       L     3
     4   0    1    0    0       R     4
     5   0    1    0    1      -"-    5
     6   0    1    1    0       L     6
     7   0    1    1    1      -"-    7
     8   1    0    0    0      -"-    8
     9   1    0    0    1       R     9
    10   1    0    1    0      -"-   10
    11   1    0    1    1      -"-   11
    12   1    1    0    0       R    12
    13   1    1    0    1      -"-   13
    14   1    1    1    0      -"-   14
    15   1    1    1    1      -"-   15
     */
     P=D->DSC.NEXT;
     IF P¬=NULL THEN DO;
        I=D->DSC.OFF+D->DSC.LENGTH - P->DSC.OFF;
        IF I>0 THEN DO;             /* INTERVALS OVERAPPING        */
           IF K=4 | K=9 | K=12 THEN DO;/* CAN REDEFINE RIGHT       */
             IF $TRACE THEN
                PUT SKIP LIST('REDEFINE RIGHT');
             IF D->DSC.OFF+D->DSC.LENGTH >= /* AFTER OVERLAY       */
                P->DSC.OFF+P->DSC.LENGTH THEN DO;
                IF $TRACE THEN
                   PUT SKIP LIST('FULL OVERLAP');
                D->DSC.NEXT=P->DSC.NEXT;
                FREE P->DSC;
                P=D->DSC.NEXT;
                IF $TRACE THEN
                   PUT SKIP LIST('PERFORM TEST_AGAIN');
                GOTO $TEST_AGAIN;
             END;
             ELSE DO;                          /* PARTIAL OVERLAY */
               P->DSC.OFF=D->DSC.OFF+D->DSC.LENGTH;
               P->DSC.LENGTH=P->DSC.LENGTH-I;
               IF P->DSC.TYPE¬='X' & P->DSC.TYPE¬='C' &
                  P->DSC.TYPE¬='I' & P->DSC.TYPE¬='#' &
                  P->DSC.TYPE¬='B' THEN
                  P->DSC.TYPE='X';
             END;
           END;
           ELSE DO;                   /* REDEFINE LEFT            */
             IF $TRACE THEN
                PUT SKIP LIST('REDEFINE LEFT');
             J=D->DSC.LENGTH;
             D->DSC.LENGTH=P->DSC.OFF - D->DSC.OFF;
             IF D->DSC.TYPE='F' | D->DSC.TYPE='H' THEN
                D->DSC.TYPE='X';
             J=J-D->DSC.LENGTH-P->DSC.LENGTH;
             IF J>0 THEN DO;          /* SMALL PIECE REST           */
                IF $TRACE THEN
                   PUT SKIP EDIT('SMALL PIECE SIZE: ',
                   $BH(J),' BYTES')(A,A,A);
                R=DSC_START;
                DO WHILE(R¬=NULL);
                   R->DSC.NEW='0'B;
                   R=R->DSC.NEXT;
                END;
                CALL $INCLUDE(P->DSC.OFF+P->DSC.LENGTH,
                              J,D->DSC.TYPE);
             END;
             ELSE DO;
                Q=P->DSC.NEXT;
                IF Q¬=NULL & P->DSC.NEW THEN DO;
                   IF P->DSC.OFF+P->DSC.LENGTH > Q->DSC.OFF THEN
                      GOTO $PRESS_BEGIN;
                END;
             END;
           END;
        END;
        D=P;
     END;
     P=DSC_START;
     DO WHILE(P¬=NULL);
        P->DSC.NEW='0'B;
        P=P->DSC.NEXT;
     END;
     IF $TRACE THEN CALL REASLST;
 END $PRESS;
 %PAGE;
 /*********************************************************************/
 /*  FILL OFFST  AND OBJECT CODE                                      */
 /*********************************************************************/
 $PUTOBJ:
     PROC(FROM,LEN,I);
 DCL (FROM,LEN,I) BIN FIXED(31),
     #CHAR        CHAR(4) BASED(ADDR(FROM));

     REASM02_LINE(I).OFF=$CH(SUBSTR(#CHAR,2));
     REASM02_LINE(I).OBJECT=$CH(SUBSTRTEXTCOPY(FROM+1,LEN));
 END $PUTOBJ;
 %PAGE;
 /*********************************************************************/
 /*  SHOW PROJECT FROM SPECIFIED OFFST                                */
 /*********************************************************************/
 $SHOW:
     PROC ;
 DCL
     $CHAR(4) CHAR(1) STATIC INT INIT('1','2','3','4'),
     MAXLEN   BIN FIXED(31),
     #VAL     BIN FIXED(31),
     VAL      CHAR(4) BASED(ADDR(#VAL)),
     #HVAL    BIN FIXED(15),
     HVAL     CHAR(2) BASED(ADDR(#HVAL)),
     #LOCVAR  CHAR(60) VAR,
     (Q,P,LAB,XLAB)    PTR,
     1 SLINE  LIKE REASM02_LINE,
     1 SCONST UNALIGNED BASED(SPTR),
       2 B    BIT(4),      /* BASE REG */
       2 D    BIT(12),     /* OFFST    */
     SPTR     PTR,
     (I,K,NOLABEL)    BIN FIXED(31) INIT(0);

     IF OFFSET < 0 THEN OFFSET=0;
     #OFFSET,$OFFSET = OFFSET;

     #CURI=1;
     IV = ' ';
     DO I=1 TO 10;
        CALL REASQPW('CHECK',PASS(I),JDAT);
     END;

     DO WHILE('1'B);

        IF #OFFSET=0 THEN DO;
           CALL PRINT_CSECT;
           CALL PRINT_DXD;
        END;

        #COM='';
        IF #OFFSET >= TEXTLEN THEN   GOTO $AFTER_FIND;
        CALL $FINDDSC(#OFFSET);      /* FIND DSC ELEMENT */
        MAXLEN=TEXTLEN-#OFFSET;
        $ORGIMM='';

        IF DSC.TYPE='I' THEN DO;     /* COMMAND */
           IF MOD(#OFFSET,2)¬=0 THEN GOTO $SHOW_X;
           CALL $CMD(#OFFSET,#CURI);
           CALL $FINDDSC(#OFFSET);
           IF REASM02_LINE(#CURI).OPER='' THEN GOTO $SHOW_X;
           I=CMDLEN(CMDDEF);
           IF I > MAXLEN THEN DO;
              CALL $INCLUDE(#OFFSET,I-MAXLEN,'X');
              GOTO $SHOW_X;
           END;
           IF I > DSC.LENGTH-(#OFFSET-DSC.OFF) THEN
              GOTO $SHOW_X;
        END;

        IF REASM02_LINE(#CURI).OPER = '' THEN
           REASM02_LINE(#CURI).OPER = 'DC';

        IF DSC.TYPE='F' THEN DO;       /* F-CONST */
           MAXLEN=TEXTLEN-#OFFSET;
           IF MAXLEN < 4 THEN GOTO $SHOW_X;
           CALL $PUTOBJ(#OFFSET,4,#CURI);
           VAL=SUBSTRTEXT(#OFFSET+1,4);
           IF MOD(#OFFSET,4)=0 THEN LOCVAR='';
           ELSE                     LOCVAR='L4';
           REASM02_LINE(#CURI).OPERANDS=
             'F' || LOCVAR || '''' ||  $DIGIT(#VAL) || '''';
           I=4;
        END;

        IF DSC.TYPE='3' THEN DO;       /* 3-BYTE CONST */
           MAXLEN=TEXTLEN-#OFFSET;
           IF MAXLEN < 3 THEN GOTO $SHOW_X;
           CALL $PUTOBJ(#OFFSET,3,#CURI);
           VAL=SUBSTRTEXT(#OFFSET,4);
           SUBSTR(VAL,1,1)=LOW(1);
           REASM02_LINE(#CURI).OPERANDS=
             'AL3(' ||  $DIGIT(#VAL) || ')';
           I=3;
        END;

        IF DSC.TYPE='S' THEN DO;                 /* S-CONST   */
           MAXLEN=TEXTLEN-#OFFSET;
           IF MAXLEN<2          THEN GOTO $SHOW_X;
           IF MOD(#OFFSET,2)¬=0 THEN GOTO $SHOW_X;
           CALL $PUTOBJ(#OFFSET,2,#CURI);
           HVAL  = SUBSTRTEXT(#OFFSET+1,2);
           SPTR = ADDR(HVAL);
           GLOBAL_IP = 0;
           #LOCVAR = $ADDR(SCONST.B,SCONST.D,0,'0'B,0,'0'B,'',#OFFSET);
           IF SUBSTR(#LOCVAR,LENGTH(#LOCVAR),1)=')' THEN
              GOTO $SHOW_X;
           IF #LOCVAR='*-0' | #LOCVAR='*+0' THEN #LOCVAR='*'; /*BELLS*/
           REASM02_LINE(#CURI).OPERANDS = 'S(' || #LOCVAR || ')';
           I=2;
        END;

        IF DSC.TYPE='H' | DSC.TYPE='Y' THEN DO;  /* H/Y-CONST */
           MAXLEN = TEXTLEN-#OFFSET;
           IF MAXLEN<2 THEN GOTO $SHOW_X;
           CALL $PUTOBJ(#OFFSET,2,#CURI);
           HVAL=SUBSTRTEXT(#OFFSET+1,2);
           #VAL=0; SUBSTR(VAL,3,2) = HVAL;
           IF MOD(#OFFSET,2)=0 THEN LOCVAR='';
           ELSE                     LOCVAR='L2';
           IF DSC.TYPE='H' THEN   /* H-CONST */
              REASM02_LINE(#CURI).OPERANDS=
                     'H' || LOCVAR || '''' || $DIGIT(#HVAL) || '''';
           ELSE                   /* Y-CONST */
              REASM02_LINE(#CURI).OPERANDS=
                     'Y' || LOCVAR || '('  ||  $DIGIT(#VAL)  || ')';
           I=2;
        END;

        IF DSC.TYPE='1' THEN DO;       /* 1-BYTE CONST */
           CALL $PUTOBJ(#OFFSET,1,#CURI);
           ICH = 0;
           CH  = SUBSTRTEXT(#OFFSET+1,1);
           REASM02_LINE(#CURI).OPERANDS=
             'AL1(' || $DIGIT(ICH) || ')';
           I=1;
        END;

        IF DSC.TYPE='P' THEN DO;     /* PACKED DECIMAL DATA */
           DCL SIGN CHAR(1)  VAR;
           I = DSC.LENGTH;
           IF I > 8 THEN GOTO $SHOW_X;
           LOCVAR=$CH(SUBSTRTEXTCOPY(#OFFSET+1,I));
           SELECT (SUBSTR(LOCVAR,LENGTH(LOCVAR),1));
              WHEN ('D') SIGN = '-';
              WHEN ('C') SIGN = '';
              OTHERWISE GOTO $SHOW_X;
           END;
           LOCVAR = SUBSTR(LOCVAR,1,LENGTH(LOCVAR)-1);
           DO J=1 TO LENGTH(LOCVAR);
              IF SUBSTR(LOCVAR,J,1)<'0' | SUBSTR(LOCVAR,J,1)>'9' THEN
                 GOTO $SHOW_X;
           END;
           CALL $PUTOBJ(#OFFSET,I,#CURI);
           REASM02_LINE(#CURI).OPERANDS =
                'P''' || SIGN || LOCVAR || '''';
        END;

        IF DSC.TYPE='X' THEN DO;    /* HEX-DATA */
 $SHOW_X:  I=MIN(DSC.LENGTH-(#OFFSET-DSC.OFF),4,MAXLEN);   /* 1995 */
           REASM02_LINE(#CURI).OPER = 'DC';
           LABL_PTR=LABL_START;
           DO WHILE(LABL_PTR¬=NULL);
              IF LABL.OFF > #OFFSET THEN
                 I=MIN(I,LABL.OFF-#OFFSET);
              LABL_PTR=LABL.NEXT;
           END;
           CALL $PUTOBJ(#OFFSET,I,#CURI);
           LOCVAR = SUBSTR(REASM02_LINE(#CURI).OBJECT,1,I*2);
           REASM02_LINE(#CURI).OPERANDS = 'X''' || LOCVAR || '''' ;
           LOCVAR = SUBSTRTEXT(#OFFSET+1,I);
           IF $CHARSTR(LOCVAR) THEN
              #COM = 'C''' || LOCVAR || '''';
        END;

        IF DSC.TYPE='B' THEN DO; /* BIT CONSTANT */
           CALL $PUTOBJ(#OFFSET,1,#CURI);
           REASM02_LINE(#CURI).OPERANDS =
                  $BITSTR(SUBSTRTEXT(#OFFSET+1,1));
           I=1;
        END;

        IF DSC.TYPE='C' THEN DO;    /* CHAR-DATA */
           I=MIN(DSC.LENGTH-(#OFFSET-DSC.OFF),LINELEN,MAXLEN);
           LABL_PTR=LABL_START;
           DO WHILE(LABL_PTR¬=NULL);
              IF LABL.OFF > #OFFSET THEN
                 I=MIN(I,LABL.OFF-#OFFSET);
              LABL_PTR=LABL.NEXT;
           END;
           CALL $PUTOBJ(#OFFSET,I,#CURI);
           LOCVAR='';
           ICH=0;
           DO J=1 TO I;
              CH=SUBSTRTEXT(#OFFSET+J,1);
              CH=SUBSTR(GOODA,ICH+1,1);
              LOCVAR=LOCVAR || CH;
              IF CH='''' | CH='&' THEN
                 LOCVAR=LOCVAR || CH;
           END;
           REASM02_LINE(#CURI).OPERANDS = 'C''' || LOCVAR || '''';
        END;

        IF DSC.TYPE='Q' THEN DO;    /* Q-CONST */
           #OFFSET = MIN(DSC.OFF,#OFFSET);
           CALL $PUTOBJ(#OFFSET,DSC.LENGTH,#CURI);
           I=DSC.LENGTH;
           REASM02_LINE(#CURI).OPERANDS=
             'QL' || $CHAR(DSC.LENGTH) || '(' ||
             $NEXTEL(DSC.NAME) || ')';
           #AZO(REASM02_LINE(#CURI).CMD#);
           IF $XREF THEN
              CALL $PUTXRF(DSC.NAME);
        END;

        IF DSC.TYPE='D' THEN DO;    /* CXD-CONST */
           #OFFSET = MIN(DSC.OFF,#OFFSET);
           CALL $PUTOBJ(#OFFSET,DSC.LENGTH,#CURI);
           I=DSC.LENGTH;
           REASM02_LINE(#CURI).OPER='CXD';
           REASM02_LINE(#CURI).LABEL='';
           #AZO(REASM02_LINE(#CURI).CMD#);
        END;

        IF DSC.TYPE='A' THEN DO; /* A-CONST */
           #OFFSET = MIN(DSC.OFF,#OFFSET);
           CALL $PUTOBJ(#OFFSET,DSC.LENGTH,#CURI);
           I=DSC.LENGTH;
           IF DSC.LENGTH¬=4 THEN
             REASM02_LINE(#CURI).OPERANDS=
             'AL' || $CHAR(DSC.LENGTH) ||
             '('||$NAME(SUBSTRTEXT(#OFFSET+1,DSC.LENGTH))||')';
           ELSE
             REASM02_LINE(#CURI).OPERANDS=
             'A('||$NAME(SUBSTRTEXT(#OFFSET+2,3))||')';
           #AZO(REASM02_LINE(#CURI).CMD#);

           /* INSERTED ON FLKEYS */
           IF DSC.LENGTH=4 & SUBSTRTEXT(#OFFSET+1,1)¬=LOW(1) THEN DO;
              CALL $LABEL(#OFFSET,I);
              NOLABEL = 1;
              CALL $PUTLINE;
              REASM02_LINE(#CURI).OPER='ORG';
              REASM02_LINE(#CURI).OPERANDS='*-4';
              #AZP(REASM02_LINE(#CURI).CMD#);
              #AZP(REASM02_LINE(#CURI).LABEL#);
              LINE_I(#CURI),LINE_C(#CURI)=0;
              LINE_O(#CURI)=I;
              CALL $PUTLINE;
              REASM02_LINE(#CURI).OPER='DC';
              CALL $PUTOBJ(#OFFSET,1,#CURI);
              LOCVAR = SUBSTR(REASM02_LINE(#CURI).OBJECT,1,2);
              REASM02_LINE(#CURI).OPERANDS = 'X''' || LOCVAR || '''' ;
              #AZP(REASM02_LINE(#CURI).CMD#);
              #AZP(REASM02_LINE(#CURI).LABEL#);
              LINE_I(#CURI),LINE_C(#CURI)=0;
              LINE_O(#CURI)=I;
              CALL $PUTLINE;
              REASM02_LINE(#CURI).OPER='ORG';
              REASM02_LINE(#CURI).OPERANDS='*+3';
              #AZP(REASM02_LINE(#CURI).CMD#);
              #AZP(REASM02_LINE(#CURI).LABEL#);
              LINE_I(#CURI),LINE_C(#CURI)=0;
              LINE_O(#CURI)=I+1;
           END;
        END;

        IF DSC.TYPE='V' THEN DO;    /* V-CONST */
           #OFFSET = MIN(DSC.OFF,#OFFSET);
           CALL $PUTOBJ(#OFFSET,DSC.LENGTH,#CURI);

           I = DSC.LENGTH;
           IF DSC.LENGTH=3 THEN HVAL=SUBSTRTEXT(#OFFSET+2,2);
           ELSE                 HVAL=SUBSTRTEXT(#OFFSET+3,2);
           IF DSC.LENGTH=4 THEN #LOCVAR='';
           ELSE                 #LOCVAR='L' || $CHAR(DSC.LENGTH);
           IF ¬DSC.EXTRN THEN DO;
              REASM02_LINE(#CURI).OPERANDS=
                'V' || #LOCVAR || '(' || DSC.NAME;
              DO J=1 TO DIM_ESD_ARRAY;
                 ONEBYTE = ESD_ARRAY(J).TYPE;
                 IF ESD_ARRAY(J).NAME=DSC.NAME &
                    (BIT4 & ¬BIT5 & BIT6 & ¬BIT7) THEN   /* 0A */
                    REASM02_LINE(#CURI).OPERANDS=
                      'A' || #LOCVAR || '(' || DSC.NAME;
              END;
           END;
           ELSE DO;
              LOCVAR='';
              IF #HVAL > 0 THEN LOCVAR='+' || $DIGIT(#HVAL);
              IF #HVAL < 0 THEN LOCVAR= $DIGIT(#HVAL);
              REASM02_LINE(#CURI).OPERANDS=
                'A' || #LOCVAR || '(' || $NEXTEL(DSC.NAME) || LOCVAR;
           END;
           SUBSTR(REASM02_LINE(#CURI).OPERANDS,
                  INDEX(REASM02_LINE(#CURI).OPERANDS,' '),1)=')';
           #AZO(REASM02_LINE(#CURI).CMD#);
           IF $XREF THEN
              CALL $PUTXRF(DSC.NAME);
        END;

        IF DSC.TYPE='O' THEN DO;          /* ORG */
           #OFFSET = MIN(DSC.OFF,#OFFSET);
           CALL $PUTOBJ(#OFFSET,DSC.LENGTH,#CURI);
           REASM02_LINE(#CURI).OBJECT='';
           I=DSC.LENGTH;
           REASM02_LINE(#CURI).OPER='ORG';
           REASM02_LINE(#CURI).OPERANDS='*+' || $DIGIT(DSC.LENGTH);
           #AZO(REASM02_LINE(#CURI).CMD#);
        END;

        IF DSC.TYPE='#' THEN DO;          /* DS XL ?  */
           #OFFSET = MIN(DSC.OFF,#OFFSET);        /* 08.12.87 */
           I=MIN(DSC.LENGTH-(#OFFSET-DSC.OFF),MAXLEN);
           LABL_PTR=LABL_START;
           DO WHILE(LABL_PTR¬=NULL);
              IF LABL.OFF > #OFFSET THEN
                 I=MIN(I,LABL.OFF-#OFFSET);
              LABL_PTR=LABL.NEXT;
           END;
           REASM02_LINE(#CURI).OPER='DS';
           REASM02_LINE(#CURI).OPERANDS=
             'XL' || $DIGIT(I);                  /* 08.12.87 */
        END;

        IF REASM02_LINE(#CURI).OPER='' THEN DO;
           PUT SKIP LIST('UNKNOWN ANIMAL:');
           PUT SKIP DATA(REASM02_LINE(#CURI),#OFFSET,DSC);
           CALL REASLST;
           SIGNAL ERROR;
           STOP;
        END;

        IF NOLABEL=0 THEN
           CALL $LABEL(#OFFSET,I);
        NOLABEL=0;

        SLINE=REASM02_LINE(#CURI), BY NAME;

        USING_PTR=USING_START;
        DO WHILE(USING_PTR¬=NULL);
           /**********************/
           /* SHOW DROPS         */
           /**********************/
           K=USING.PLACE+USING.LENGTH;
           IF K>=#OFFSET & K<#OFFSET+I THEN DO;
              REASM02_LINE(#CURI).OBJECT='';
              REASM02_LINE(#CURI).OFF='';
              #AZO(REASM02_LINE(#CURI).CMD#);
              #AZO(REASM02_LINE(#CURI).LABEL#);
              REASM02_LINE(#CURI).LABEL='';
              REASM02_LINE(#CURI).OPER='DROP';
              REASM02_LINE(#CURI).OPERANDS=$REGS(USING.REG);
              #AZP(REASM02_LINE(#CURI).OPER#);
              #AZP(REASM02_LINE(#CURI).OPERANDS#);
              LINE_I(#CURI),LINE_C(#CURI)=0;
              LINE_O(#CURI)=#OFFSET;
              CALL $PUTLINE;
           END;
           USING_PTR=USING.NEXT;
        END;
        /**********************/
        /* PROCESS   USING    */
        /**********************/
        USING_PTR=USING_START;
        DO WHILE(USING_PTR¬=NULL);
           IF USING.PLACE >= #OFFSET & USING.PLACE < #OFFSET+I THEN DO;
              #AZO(REASM02_LINE(#CURI).CMD#);
              #AZO(REASM02_LINE(#CURI).LABEL#);
              REASM02_LINE(#CURI).LABEL='';
              REASM02_LINE(#CURI).OPER='USING';
              REASM02_LINE(#CURI).OFF='';
              REASM02_LINE(#CURI).OBJECT='';
              #AZP(REASM02_LINE(#CURI).OPER#);
              #AZP(REASM02_LINE(#CURI).OPERANDS#);
              J=USING.OFF-#OFFSET;
              IF USING.NAME='' THEN DO;
                 IF J=0 THEN
                    REASM02_LINE(#CURI).OPERANDS='*,'||$REGS(USING.REG);
                 ELSE DO;
                    LOCVAR=$BH(USING.OFF);      /* 14.09.88 */
                    DO WHILE(LENGTH(LOCVAR)>1 & SUBSTR(LOCVAR,1,1)='0');
                       LOCVAR=SUBSTR(LOCVAR,2);
                    END;
                    REASM02_LINE(#CURI).OPERANDS=$NEXTEL(CSECT) ||
                             '+X''' || LOCVAR || ''',' ||
                             $REGS(USING.REG);

                    IF 1 /*USING.OFF <= USING.PLACE*/ THEN DO;
                       XLAB = NULL;
                       LAB  = LABL_START;     /* FIND GOOD LABEL */
                       DO WHILE(LAB¬=NULL);
                          IF LAB->LABL.OFF <= USING.OFF THEN DO;
                             IF XLAB=NULL |
                              LAB->LABL.OFF > XLAB->LABL.OFF THEN
                              XLAB=LAB;
                          END;
                          LAB = LAB->LABL.NEXT;
                       END;
                       IF XLAB¬=NULL THEN DO;
                         J = USING.OFF-XLAB->LABL.OFF;
                         IF J<=#ABSA THEN DO;
                            LOCVAR = '';
                            IF J>0 THEN LOCVAR = '+' || $DIGIT(J);
                            REASM02_LINE(#CURI).OPERANDS=
                                  $NEXTEL(XLAB->LABL.NAME) || LOCVAR ||
                                  ',' || $REGS(USING.REG);
                         END;
                       END;
                   END;
                 END;
              END;
              ELSE
                 REASM02_LINE(#CURI).OPERANDS=
                            $NEXTEL(SUBSTR(USING.NAME,2)) || ',' ||
                            $REGS(USING.REG);
              LINE_I(#CURI),LINE_C(#CURI)=0;
              LINE_O(#CURI)=#OFFSET;
              CALL $PUTLINE;
           END;
           USING_PTR=USING.NEXT;
        END;

        REASM02_LINE(#CURI)=SLINE, BY NAME;

        LINE_I(#CURI)=I;
        LINE_O(#CURI)=#OFFSET;
        LINE_C(#CURI)=0;
        CALL $PUTCOM(#CURI);
        CALL $PUTLINE;

        IF $ORGIMM¬='' THEN DO;
           REASM02_LINE(#CURI).OPER='ORG';
           REASM02_LINE(#CURI).OPERANDS = $ORGIMM_B;
           #AZP(REASM02_LINE(#CURI).CMD#);
           #AZP(REASM02_LINE(#CURI).LABEL#);
           LINE_I(#CURI),LINE_C(#CURI)=0;
           LINE_O(#CURI)=I;
           CALL $PUTLINE;
           REASM02_LINE(#CURI).OPER='DC';
           REASM02_LINE(#CURI).OPERANDS=$ORGIMM;
           CALL $PUTOBJ(#OFFSET+1,1,#CURI);
           #AZP(REASM02_LINE(#CURI).CMD#);
           #AZP(REASM02_LINE(#CURI).LABEL#);
           LINE_I(#CURI),LINE_C(#CURI)=0;
           LINE_O(#CURI)=I;
           CALL $PUTLINE;
           REASM02_LINE(#CURI).OPER='ORG';
           REASM02_LINE(#CURI).OPERANDS = $ORGIMM_F;
           #AZP(REASM02_LINE(#CURI).CMD#);
           #AZP(REASM02_LINE(#CURI).LABEL#);
           LINE_I(#CURI),LINE_C(#CURI)=0;
           LINE_O(#CURI)=I;
           CALL $PUTLINE;
           $ORGIMM='';
        END;

        #OFFSET = #OFFSET + I;

 $AFTER_FIND:                            /* 27.11.87 */
        IF #CURI=1 & ($FIND | IV = 'PF08') THEN
           $OFFSET=#OFFSET;
        OFFSET=$OFFSET;
        IF #OFFSET >= TEXTLEN THEN DO;
           CALL PRINT_EXTRN_WXTRN;
           CALL PRINT_REGEQ_LTORG;
           CALL PRINT_DSECTS;
           CALL PRINT_END_STMT;

           IF PRINTBIT THEN DO;
              PRINTBIT='0'B;
              OFFSET=FOFFSET;
              $CONF='0'B;
              IF $XREF THEN DO;
                 CALL $PRINT_XREF;
                 CALL ISPLINK('SETMSG ', 'REAS004 ');/* PRINTED XREF */
              END;
              ELSE
                 CALL ISPLINK('SETMSG ', 'REAS003 ');/* PRINTED */
              $XREF='0'B;
              CALL REASLST;
              GOTO $RETURN_FROM_$SHOW;
           END;
           IF SAVEBIT THEN DO;
              SAVEBIT='0'B;
              I = REASLIB(SOURCE, 'CLOSE', '');
              OFFSET=FOFFSET;
              $CONF='0'B;
              GOTO $RETURN_FROM_$SHOW;
           END;
           IF $FIND THEN DO;  /* FIND WAS ACTIVE BUT UNSUCCESSFUL */
              $FIND='0'B;
              #CUR(ZZCMD,1);
              CALL $CLEAR_SCR;
              FINDTXT = #FIND;
              CALL ISPLINK('SETMSG ', 'REAS006 '); /* NOT FOUND */
              GOTO $RETURN_FROM_$SHOW;
           END;
           #OFFSET=0;
        END;
     END;
 $RETURN_FROM_$SHOW:
     RETURN;
 %PAGE;
 /*********************************************************************/
 /*  WRITE STRING ON SCREEN                                           */
 /*********************************************************************/
 $PUTLINE: PROC;
 DCL PRIMARY    CHAR(80) VAR,
     (T1,T2,T3) CHAR(1),
     LOCV       CHAR(10) VAR,
     NN         CHAR(8) VAR,
     (P,Q,R)    PTR,
     GLOBAL     BIT(1) INIT('0'B),
     LINE       CHAR(80) BASED(LINE_PTR),
     LINE_PTR   PTR,
     BYTE       CHAR(1),
     COMMENT    CHAR(80) VAR,
     (I,II,III,II1,II2,IJ,J,JJ,JJJ,K) BIN FIXED(31);

     IF $XREF THEN DO;
        LOCVAR=REASM02_LINE(#CURI).OPER;
        IF LOCVAR¬='' & LOCVAR¬='ENTRY' THEN
           CALL $PUTXRF(LOCVAR);
     END;

     IF #CURI >= MAXLVL-3 THEN DO;

        IF PRINTBIT THEN DO;
           CALL $PUTLINE_PRINT;
           GOTO $PUTLINE_END;
        END;

        IF SAVEBIT THEN DO;
           CALL $PUTLINE_SAVE;
           GOTO $PUTLINE_END;
        END;

        IF $FIND THEN DO;
           DO I=1 TO MAXLVL-3;
              IF $MATCH THEN J=MATCH(REASM02_CHARL(I),#FIND);
              ELSE           J=INDEX(REASM02_CHARL(I),#FIND);
              IF J¬=0 & LINE_O(I) < TEXTLEN THEN DO;
                 #CUR(SCREEN,(I-1)*80+2);
                 /* #CUR(REASM02_LINE(I).LABEL#,J+1,NAME); */
                 #ANP(REASM02_LINE(I).LABEL#);
                 #AZP(REASM02_LINE(I).OFF#);
                 BOFFSET = LINE_O(I)+LINE_I(I);
                 IF LINE_I(I) = 0 THEN BOFFSET=LINE_O(I)+2;
                 FINDTXT = #FIND;
                 CALL ISPLINK('SETMSG ','REAS007 ');
                 $FIND   = '0'B;
                 CALL $GOODCMD(BOFFSET);
                 IF (I>LVL) THEN DO;
                   OFFSET = LINE_O(I);
                   CALL $CLEAR_SCR;
                   #AZP(REASM02_LINE(1).OFF#);
                   REASM02_PRIMARY = ' ';
                   GOTO $RETURN_FROM_$SHOW;
                 END;
                 GOTO CALLTV02;
              END;
           END;
           GOTO $PUTLINE_END;
        END;

 CALLTV02:
        CALL ISPLINK('DISPLAY ','REASM02 ', ' ');

        COLIN, STRIN = 2;
        IF FIELD = 'SCREEN' THEN DO;
           STRIN = POS/80+4;
           COLIN = POS - (STRIN-4)*80 + 1;
        END;

        IF PLIRETV() = 8 THEN IV = 'PF03';

        CALL CALCULATE_LVL;

        PRIMARY=REASM02_PRIMARY || (80)' ';
        DO I=1 TO MAXLVL-3; #AZO(REASM02_LINE(I).OFF#); END;

        #CUR(ZZCMD,1);
        IF STRIN > 3 THEN DO;
           #AZP(REASM02_LINE(STRIN-3).OFF#);
           I = COLIN;
           IF I<=4 THEN I=3;
           #CUR(SCREEN,(STRIN-4)*80+I-1);
        END;

        IF $CONFP &
           (IV = 'PF03'            |
            REASM02_PRIMARY = 'E'  |
            REASM02_PRIMARY= 'END' |
            REASM02_PRIMARY= 'Y'   ) THEN
            GOTO $RETURN_FROM_$SHOW;
        $CONFP='0'B;

        IF IV = 'PF03'  THEN GOTO $RETURN_FROM_$SHOW;

                        /*********************************************/
                        /*  LINE COMMAND PROCESS SECTION             */
                        /*********************************************/
        DO II=1 TO LVL;
          IF REASM02_LINE(II).CMD¬='' THEN DO;
             LOCVAR = REASM02_LINE(II).CMD;
             IF LOCVAR¬='' THEN
                LOCVAR = SUBSTR(LOCVAR,VERIFY(LOCVAR,' '));
             LOCVAR = LOCVAR || '   ';
             T1 = SUBSTR(LOCVAR,1,1);
             T2 = SUBSTR(LOCVAR,2,1);
             T3 = SUBSTR(LOCVAR,3,1);
             IF T1='_' THEN T1=' ';
             IF T2='_' THEN T2=' ';
             IF T3='_' THEN T3=' ';
             IF (T1||T2||T3 ¬= '') THEN DO;
                IF T1= ' ' THEN DO; T1=T2;T2=T3;T3=' '; END;
                IF T1= ' ' THEN DO; T1=T2;T2=T3;T3=' '; END;
             END;
             UNSPEC(T1) = UNSPEC(T1) | UNSPEC(' ');
             UNSPEC(T2) = UNSPEC(T2) | UNSPEC(' ');
             UNSPEC(T3) = UNSPEC(T3) | UNSPEC(' ');
             NN = T2 || T3;

             IF T1='U' THEN DO;            /* LINE USING COMMAND */
                 IF NN¬='' THEN DO;            /* UXX SPECIFIED */
                    ON CONV GOTO $LREG;
                    GET STRING(NN) LIST(J);
                    REVERT CONV;
                    IF J<=0 | J>15 THEN DO;
 $LREG:                CALL ISPLINK('SETMSG ','REAS008 '); /* INVREG*/
                       REVERT CONV;
                       GOTO $ERR_PRIMARY;
                    END;
                    CALL $INITUSING(LINE_O(II),J,LINE_O(II),'',0);
                    GOTO $LCMD_END;
                 END;
                 ELSE DO;         /* USING WITHOUT REGISTER */
                    REASM02_PRIMARY =
                    'U '||SUBSTR($BH(LINE_O(II)),3)||',R?';
                    CALL ISPLINK('SETMSG ','REAS009 '); /* SPECREG */
                    REASM02_LINE(II).CMD='';
                    #CUR(ZZCMD,11);
                    GOTO CALLTV02;
                 END;
             END;

             IF T1='D' THEN DO;            /* DROP COMMAND */
                 IF NN¬='' THEN DO;
                    ON CONV GOTO $LREG;
                    GET STRING(NN) LIST(J);
                    REVERT CONV;
                    IF J<0 | J>15 THEN GOTO $LREG;
                    P=NULL;
                    USING_PTR=USING_START;
                    DO WHILE(USING_PTR¬=NULL);
                       IF USING.REG=J &
                          USING.PLACE < LINE_O(II) THEN DO;
                          IF P=NULL THEN P=USING_PTR;
                          ELSE DO;
                             IF P->USING.PLACE < USING.PLACE THEN
                                P=USING_PTR;
                          END;
                       END;
                       USING_PTR=USING.NEXT;
                    END;
                    IF P=NULL THEN GOTO $LREG;
                    P->USING.LENGTH=LINE_O(II) - P->USING.PLACE;
                    Q=LABL_START;
                    R=NULL;
                    DO WHILE(Q¬=NULL);
                       IF Q->LABL.REG = P->USING.REG &
                          Q->LABL.OFF>P->USING.PLACE+P->USING.LENGTH
                          THEN DO;
                          IF R=NULL THEN   LABL_START=Q->LABL.NEXT;
                                    ELSE R->LABL.NEXT=Q->LABL.NEXT;
                          FREE Q->LABL;
                          IF R=NULL THEN   Q=LABL_START;
                                    ELSE   Q=R->LABL.NEXT;
                       END;
                       ELSE DO;
                          R=Q;
                          Q=Q->LABL.NEXT;
                       END;
                    END;
                 END;
                 ELSE DO;
 $DROP_BY_ADR:      P=NULL;
                    USING_PTR=USING_START;
                    DO WHILE(USING_PTR¬=NULL);
                       IF USING.PLACE=LINE_O(II) THEN DO;
                          IF P=NULL THEN USING_START=USING.NEXT;
                                    ELSE P->USING.NEXT=USING.NEXT;
                          FREE USING;
                          GOTO $DROP_BY_ADR;
                       END;
                       P=USING_PTR;
                       USING_PTR=USING.NEXT;
                    END;
                 END;
                 GOTO $LCMD_END;
             END;

             IF T1 = 'R' THEN DO;        /* LINE RETRANSLATE */
                J = LINE_O(II);
                IF COLIN > 14  &  COLIN < 14+LINE_I(II)*2 THEN DO;
                   J = J + (COLIN-14)/2;
                END;
                GLOBAL = '0'B;
                GOTO $RETRANSLATE;
             END;

             I = LINE_I(II);
             SELECT (T1);
               WHEN ('X');                           /* HEX     */
               WHEN ('C');                           /* CHAR    */
               WHEN ('P');                           /* PACKED  */
               WHEN ('#');                           /* DS      */
               WHEN ('B');                           /* BIT     */
               WHEN ('A','F') DO; I=4; T1='F'; END;  /* WORD    */
               WHEN ('H','Y')     I=2;               /* HALFWORD*/
               WHEN ('S')         I=2;               /* S-CONST */
               OTHER DO;
                 CALL ISPLINK('SETMSG ','REAS011 '); /* INVTYPE */
                 GOTO $ERR_PRIMARY;
               END;
             END;
             IF T2='' THEN DO;
 $SETLINE:      CALL $INCLUDE(LINE_O(II),I,T1);
                IF T1='C' THEN DO;
                  ICH=0;
                  DO III=LINE_O(II) BY 1 TO LINE_O(II)+I;
                     CH = SUBSTRTEXT(III+1,1);
                     IF SUBSTR(GOODA,ICH+1,1)=HIGH(1) THEN
                        CALL $INCLUDE(III,1,'X');
                  END;
                END;
             END;
             ELSE DO;
                IF T1=T2 THEN DO;    /* BLOCK COMMAND   */
                   IF PENDING THEN DO;
                      IF BLOCK_CMD.TYPE¬=T1 THEN DO;
                         CALL ISPLINK('SETMSG ','REAS012 '); /*DFTYP*/
                         GOTO $ERR_PRIMARY;
                      END;
                      PENDING='0'B;
                      BLOCK_CMD.O2=LINE_O(II);
                      K=MIN(BLOCK_CMD.O1,BLOCK_CMD.O2);
                      J=ABS(BLOCK_CMD.O1-BLOCK_CMD.O2);
                      IF BLOCK_CMD.O1 > BLOCK_CMD.O2 THEN
                         J=J+BLOCK_CMD.LEN;
                      ELSE
                         J=J+I;
                      CALL $INCLUDE(K,J,T1);
                      IF T1='C' THEN DO;
                        ICH=0;
                        DO III=K BY 1 TO K+J-1;    /* 14.09.88 */
                           CH=SUBSTRTEXT(III+1,1);
                           IF SUBSTR(GOODA,ICH+1,1)=HIGH(1) THEN
                              CALL $INCLUDE(III,1,'X');
                        END;
                      END;
                   END;
                   ELSE DO;
                      BLOCK_CMD.TYPE = T1;
                      PDFBYTE        = T1;
                      BLOCK_CMD.O1   = LINE_O(II);
                      BLOCK_CMD.LEN  = I;
                      PENDING        = '1'B;
                   END;
                END;
                ELSE DO;
                   IF T2='L' THEN DO;
                      I  = $HBF(T3);
                      IF I<=0 THEN GOTO $ERRL;
                      IF T1='F' THEN DO;
                         SELECT (I);
                            WHEN (1) T1='1';
                            WHEN (2) T1='H';
                            WHEN (3) T1='3';
                            WHEN (4);
                            OTHER GOTO $ERRL;
                         END;
                      END;
                      IF T1='H' | T1='Y' THEN DO;
                         SELECT (I);
                            WHEN (1) T1='1';
                            WHEN (2);
                            WHEN (3) T1='3';
                            WHEN (4) T1='F';
                            OTHER GOTO $ERRL;
                         END;
                      END;
                      GOTO $SETLINE;
                   END;
                   ELSE DO;
 $ERRL:               REVERT CONV;
                      CALL ISPLINK('SETMSG ','REAS013 '); /*INVCMD*/
                      GOTO $ERR_PRIMARY;
                   END;
                END;
             END;
 $LCMD_END:
             REASM02_LINE(II).CMD='';
          END;

          IF UNSPEC(REASM02_LINE(II).LABEL#) = #MOD THEN DO;
             IF $DUBLAB(REASM02_LINE(II).LABEL,LINE_O(II)) THEN
                GOTO L_DUBLAB;
             CALL $INITLAB(REASM02_LINE(II).LABEL,
                           LINE_O(II),0,'1'B,LINE_O(II));
          END;

          IF LINE_C(II)¬=0 THEN DO;
             BYTE = REASM02_CHAR(II,LINE_C(II));
             IF UNSPEC(BYTE) = #MOD THEN DO;
                LINE_PTR=ADDR(REASM02_LINE(II).CMD#);
                COM_PTR=COM_START;
                Q=NULL;
                DO WHILE(COM_PTR¬=NULL);
                   IF COM.OFF=LINE_O(II) THEN DO;
                      COM.TXT=SUBSTR(LINE,LINE_C(II)+1);
                      IF COM.TXT='' THEN DO;
                         IF Q=NULL THEN COM_START=COM.NEXT;
                                   ELSE Q->COM.NEXT=COM.NEXT;
                         FREE COM;
                      END;
                      IF $REM THEN
                         CALL $AUTOREC;
                      GOTO $OK_COM;
                   END;
                   Q=COM_PTR;
                   COM_PTR=COM.NEXT;
                END;
                ALLOCATE COM;
                COM.NEXT=COM_START;
                COM_START=COM_PTR;
                COM.OFF=LINE_O(II);
                COM.TXT=SUBSTR(LINE,LINE_C(II)+1);
                IF $REM THEN
                   CALL $AUTOREC;
 $OK_COM:    END;
          END;
        END;
 %SKIP;
                        /*********************************************/
                        /*  PRIMARY COMMAND PROCESS                  */
                        /*********************************************/
        LOCVAR=$NEXTEL(PRIMARY);

        /* ----------------------------------------------------------*/
        /* PROCESS '.XXX' COMMAND AS 'Q XXX' FOR BROWSE COMPATIBILITY*/
        /* ----------------------------------------------------------*/
        IF  LENGTH(LOCVAR)>0 & SUBSTR(LOCVAR,1,1)='.' THEN DO;
            IF LENGTH(LOCVAR)>1 THEN
               PRIMARY = SUBSTR(LOCVAR,2) || ' ' || PRIMARY;
            ELSE
               PRIMARY = '';
            LOCVAR = 'Q';
        END;

        /* ----------------------------------------------------------*/
        /* PROCESS 'DSA+XXX=NAME' COMMAND                            */
        /* ----------------------------------------------------------*/
 L_SET: I = INDEX(LOCVAR,'+');
        J = INDEX(LOCVAR,'=');
        IF I>1 & J>1  & I<J-1 THEN DO;
           LOCV = SUBSTR(LOCVAR,1,I-1);                /* DUMMY NAME */
           ON CONV GOTO L_WROFF;
           GET STRING(SUBSTR(LOCVAR,I+1,J-I-1)) LIST(K); /* OFFST    */
           REVERT CONV;
           NN = SUBSTR(LOCVAR,J+1);                    /* USER NAME  */
           IF SUBSTR(LOCV,1,1)¬='@' THEN LOCV = '@' || LOCV;
           IF $DUBLAB(NN,-1) THEN DO;
 L_DUBLAB:    CALL ISPLINK('SETMSG ','REAS015 '); /*DUP LAB */
              GOTO $ERR_PRIMARY;
           END;
           LBLOCK_PTR = LBLOCK_START;
           DO WHILE (LBLOCK_PTR¬=NULL);
              IF LBLOCK.NAME  = LOCV &
                 LBLOCK.ADR   = 0    THEN DO;
                 DUMMY_PTR = LBLOCK.ADUMMY;
                 DO WHILE (DUMMY_PTR¬=NULL);
                    IF DUMMY.OFF = K THEN DO;
                       DUMMY.NAME = NN;
                       PDFCHAR = LOCVAR;
                       CALL ISPLINK('SETMSG ','REAS016 '); /*... SET */
                       GOTO $RESHOW;
                    END;
                    DUMMY_PTR = DUMMY.NEXT;
                 END;
 L_WROFF:        PDFCHAR = LOCV;
                 CALL ISPLINK('SETMSG ','REAS017 '); /*INV DS OFF */
                 GOTO $ERR_PRIMARY;
              END;
              LBLOCK_PTR = LBLOCK.NEXT;
           END;
           PDFCHAR = LOCV;
           CALL ISPLINK('SETMSG ','REAS018 '); /*INV DS NAME */
           GOTO $ERR_PRIMARY;
        END;

        SELECT (LOCVAR);

          WHEN  (' ');

          WHEN  ('STOP','CAN','CANCEL') DO;
            STOP;
          END;
          /*
          WHEN  ('LISTX') DO;
            CALL  REASLST;
          END;
          */
          WHEN  ('PROF','PROFILE') DO;
            CALL REASPRF('DISPLAY',       /* UPDT PROFILE VARIABLES */
                 $AUTO, $DSOFF, $REM, #ABSA, #ABSB, LINELEN, REMTIME,
                 OS,    PC,     FC );
          END;

          WHEN  ('SET') DO;
            LOCVAR = $NEXTEL(PRIMARY);
            GOTO L_SET;
          END;

          WHEN  ('O','OFF','OFFSET') DO;
            LOCVAR=$NEXTEL(PRIMARY);
            IF LOCVAR='' THEN DO;
               #ABSA = 12;
               #ABSB =  8;
            END;
            ELSE DO;
               ON CONV GOTO $ERRA;
               GET STRING(LOCVAR) LIST(I);
               REVERT CONV;
               IF I<0 THEN DO;
 $ERRA:           REVERT CONV;
                  CALL ISPLINK('SETMSG ', 'REAS019 '); /* INV VAL */
                  GOTO $ERR_PRIMARY;
               END;
               #ABSA,#ABSB = I;
               IF PRIMARY¬='' THEN DO;
                  ON CONV GOTO $ERRA;
                  GET STRING(PRIMARY) LIST(I);
                  REVERT CONV;
                  IF I<0 THEN GOTO $ERRA;
                  #ABSB = I;
               END;
            END;
            OFFSET = $OFFSET;
            REASM02_PRIMARY = ' ';
            GOTO $RETURN_FROM_$SHOW;
          END;

          WHEN  ('#','#SNAP') DO;
             CALL $PRINTDSC('USER-REQUEST SNAP');
             CALL ISPLINK('SETMSG ', 'REAS021 '); /* SNAP IS COMPL */
             OFFSET = $OFFSET;
             REASM02_PRIMARY = '';
             GOTO $RETURN_FROM_$SHOW;
          END;

          WHEN  ('ML','MEMLIST','BL','BLOCKLIST') DO;
             BLKNAME=REASMLB(CONTROL);
             OFFSET = $OFFSET;
             REASM02_PRIMARY = BLKNAME;
             GOTO $RETURN_FROM_$SHOW;
          END;

          WHEN  ('E','END','EXIT','QUIT') DO;
            IV = 'PF03';
            GOTO $RETURN_FROM_$SHOW;
          END;

          WHEN  ('F','FIND') DO;
            LOCVAR = PRIMARY;
            IF LOCVAR = '' THEN DO;
               IF #FIND = '' THEN DO;
                  CALL ISPLINK('SETMSG ', 'REAS022 '); /* REQSTR MIS */
                  REASM02_PRIMARY='F ?';
                  #CUR(ZZCMD,3);
                  GOTO $ERR_PRIMARY;
               END;
            END;
            ELSE DO;
               DO WHILE(SUBSTR(LOCVAR,1,1)=' ');  /* CUT LEAD BLANKS */
                  LOCVAR = SUBSTR(LOCVAR,2);
               END;
               DO WHILE(SUBSTR(LOCVAR,LENGTH(LOCVAR),1)=' '); /* TAIL */
                  LOCVAR = SUBSTR(LOCVAR,1,LENGTH(LOCVAR)-1);
               END;
               #FIND  = LOCVAR;
               $MATCH = '0'B;
               IF INDEX(#FIND,'*')¬=0 |  INDEX(#FIND,'%')¬=0 |
                  INDEX(#FIND,'?')¬=0 THEN DO;
                  #FIND='*' || #FIND || '*';
                  $MATCH='1'B;
               END;
            END;
            $FIND           = '1'B;
            REASM02_PRIMARY = ' ';
            IF STRIN>3 THEN
               OFFSET  = LINE_O(STRIN-3)+LINE_I(STRIN-3);
            ELSE
               OFFSET  = LINE_O(1)+LINE_I(1);
            CALL $CLEAR_SCR;
            FOFFSET = OFFSET;
            BOFFSET = OFFSET;
            $OFFSET = OFFSET;
            #OFFSET = OFFSET;
            GOTO $RETURN_FROM_$SHOW;
          END;

          WHEN  ('M','MAX') DO;
              CALL ISPLINK('SETMSG ', 'REAS023 '); /* PRESS UP/D */
              #CUR(ZZCMD,1);
              GOTO $ERR_PRIMARY;
 $RESHOW:     REASM02_PRIMARY = ' ';
              GOTO $RETURN_FROM_$SHOW;
          END;

          WHEN  ('T','TRACE') DO;
            $TRACE=¬$TRACE;
            REASM02_PRIMARY = ' ';
            IF $TRACE THEN
               CALL ISPLINK('SETMSG ', 'REAS024 '); /* TRACE ON */
            ELSE
               CALL ISPLINK('SETMSG ', 'REAS025 '); /* TRACE ON */
            #CUR(ZZCMD,1);
            OFFSET=$OFFSET;
            GOTO $RETURN_FROM_$SHOW;
          END;

          WHEN  ('DS','DSECT') DO;
            LOCVAR=$NEXTEL(PRIMARY);
            SELECT (LOCVAR);
               WHEN ('N','NAME')         $DSOFF='0'B;
               WHEN ('OFFSET','OFF','O') $DSOFF='1'B;
               OTHER                     $DSOFF=¬$DSOFF;
            END;
            REASM02_PRIMARY = ' ';
            IF $DSOFF THEN
               CALL ISPLINK('SETMSG ', 'REAS026 '); /* DS OFF */
            ELSE
               CALL ISPLINK('SETMSG ', 'REAS027 '); /* DS NAM */
            #CUR(ZZCMD,1);
            OFFSET=$OFFSET;
            GOTO $RETURN_FROM_$SHOW;
          END;
          WHEN  ('A','AUTO') DO;
            LOCVAR=$NEXTEL(PRIMARY);
            SELECT (LOCVAR);
               WHEN ('ON')  $AUTO='1'B;
               WHEN ('OFF') $AUTO='0'B;
               OTHER        $AUTO=¬$AUTO;
            END;
            REASM02_PRIMARY = ' ';
            IF $AUTO THEN
               CALL ISPLINK('SETMSG ', 'REAS028 '); /* AU ON */
            ELSE
               CALL ISPLINK('SETMSG ', 'REAS029 '); /* AU OFF */
            #CUR(ZZCMD,1);
            OFFSET=$OFFSET;
            GOTO $RETURN_FROM_$SHOW;
          END;

          WHEN  ('Q','QUALIFY','QFY','MARK') DO;
            LOCVAR=$NEXTEL(PRIMARY);
            IF LENGTH(LOCVAR) > 8 THEN DO;
               CALL ISPLINK('SETMSG ', 'REAS031 '); /* INVMARK */
               #CUR(ZZCMD,1);
               GOTO $ERR_PRIMARY;
            END;
            IF LOCVAR = '' THEN DO;
               OFFSET = REASQFY(QUALIFY_START);
               IF OFFSET < 0 THEN  OFFSET = $OFFSET;
               IV = ' ';
               GOTO $FORM_REASM02;
            END;
            QUALIFY_PTR=QUALIFY_START;
            DO WHILE(QUALIFY_PTR¬=NULL);
               IF QUALIFY.NAME=LOCVAR THEN DO;
                  QUALIFY.OFF = $OFFSET;
                  QUALIFY.DESC   = PRIMARY;
                  CALL ISPLINK('SETMSG ', 'REAS032 '); /* MARKUPD */
                  GOTO $QUALIFY_EXIT;
               END;
               QUALIFY_PTR=QUALIFY.NEXT;
            END;
            ALLOCATE QUALIFY;
            QUALIFY.NEXT   = QUALIFY_START;
            QUALIFY_START  = QUALIFY_PTR;
            QUALIFY.NAME   = LOCVAR;
            QUALIFY.OFF = $OFFSET;
            QUALIFY.DESC   = PRIMARY;
            CALL ISPLINK('SETMSG ', 'REAS033 '); /* MARKUPD */
 $QUALIFY_EXIT: REASM02_PRIMARY='';
            #CUR(ZZCMD,1);
            OFFSET=$OFFSET;
            GOTO $RETURN_FROM_$SHOW;
          END;
          WHEN  ('L','LI','LOCATE','LINESIZE') DO;
            BOFFSET=0;
            PRIMARY=$NEXTEL(PRIMARY);   /* OPERAND */
            IF PRIMARY¬='' THEN DO;
               I=$HB(PRIMARY);
               SELECT (SUBSTR(REASM02_PRIMARY,2,1));
                 WHEN  ('I') DO;       /* LINE */
                   IF I <=0 | I > 32 THEN DO;
                      CALL ISPLINK('SETMSG ', 'REAS034 '); /* INVLEN */
                      #CUR(ZZCMD,1);
                      GOTO $ERR_PRIMARY;
                   END;
                   LINELEN=I;
 $SETLINELEN:      OFFSET=$OFFSET;
                   REASM02_PRIMARY = ' ';
                   CALL $CLEAR_SCR;
                   GOTO $RETURN_FROM_$SHOW;
                 END;
                 OTHER DO;
                   LABL_PTR=LABL_START;
                   DO WHILE(LABL_PTR¬=NULL);
                      IF LABL.NAME=PRIMARY THEN DO;
                         I=LABL.OFF;
                         CALL ISPLINK('SETMSG ', 'REAS035 ');
                      END;
                      LABL_PTR=LABL.NEXT;
                   END;
                   QUALIFY_PTR=QUALIFY_START;
                   DO WHILE(QUALIFY_PTR¬=NULL);
                      IF QUALIFY.NAME=PRIMARY THEN DO;
                         I=QUALIFY.OFF;
                         CALL ISPLINK('SETMSG ', 'REAS035 ');
                      END;
                      QUALIFY_PTR=QUALIFY.NEXT;
                   END;
                   IF I < 0 | I > TEXTLEN THEN DO;
                      CALL ISPLINK('SETMSG ', 'REAS036 '); /*INVOFF*/
                      #CUR(ZZCMD,1);
                      GOTO $ERR_PRIMARY;
                   END;
                   OFFSET=I;
                   IF I¬=0 THEN DO;
                      CALL $FINDDSC(OFFSET);
                      IF DSC.TYPE='I' THEN DO;
                         I=0;
                         IF MOD(#OFFSET,2)¬=0 THEN
                            #OFFSET=#OFFSET-1;
                         DO WHILE(DSC.OFF+I < OFFSET); /* ||| */
                            CMD_PTR=ADDRTEXT();
                            #CMD_PTR=#CMD_PTR+DSC.OFF+I;
                            I=I+CMDLEN(CMDDEF);
                         END;
                         OFFSET=DSC.OFF+I;
                      END;
                   END;
                   CALL $CLEAR_SCR;
                   REASM02_PRIMARY = ' ';
                   GOTO $RETURN_FROM_$SHOW;
                 END;
               END;
            END;
          END;
          WHEN  ('U','US','USING') DO;
             IF PRIMARY='' THEN DO;
                CALL ISPLINK('SETMSG ', 'REAS037 '); /*MISSOP*/
                #CUR(ZZCMD,1);
                GOTO $ERR_PRIMARY;
             END;
             LOCVAR=$NEXTEL(PRIMARY);

             IF LOCVAR = '?' THEN DO;      /* MEMBERLIST ? */
                LOCVAR = REASMLB(CONTROL);
             END;

             IF SUBSTR(LOCVAR,1,1)='@' THEN DO;    /* @NAME */
                IF LENGTH(LOCVAR)<2 | LENGTH(LOCVAR)>9 THEN DO;
                   CALL ISPLINK('SETMSG ', 'REAS038 '); /*INVBLK*/
                   #CUR(ZZCMD,1);
                   GOTO $ERR_PRIMARY;
                END;
                NN=LOCVAR;
                I=0;
             END;
             ELSE DO;                             /*LOCATION*/
                NN='';
                IF LOCVAR='*' THEN I=$OFFSET;
                ELSE DO;
                  IF SUBSTR(LOCVAR,LENGTH(LOCVAR),1)=')' THEN DO;
                     LOCV=LOCVAR;
                     LOCVAR='';
                     DO J=1 TO LENGTH(LOCV)
                        WHILE(SUBSTR(LOCV,1,1)¬='(');
                        LOCVAR=LOCVAR || SUBSTR(LOCV,1,1);
                        LOCV=SUBSTR(LOCV,2);
                     END;
                     LOCV=SUBSTR(LOCV,2,LENGTH(LOCV)-2);
                     IF LOCV='' THEN
                        GOTO $ERR_BREG;
                     IF SUBSTR(LOCV,1,1)='R' & LENGTH(LOCV)>1 THEN
                        LOCV=SUBSTR(LOCV,2);
                     ON CONV GOTO $ERR_BREG;
                     GET STRING(LOCV) LIST(J);
                     IF J<=0 | J>15 THEN DO;
 $ERR_BREG:             REVERT CONV;
                        CALL ISPLINK('SETMSG ', 'REAS039 '); /*INVREF*/
                        #CUR(ZZCMD,1);
                        GOTO $ERR_PRIMARY;
                     END;
                     USING_PTR=USING_START;
                     DO WHILE(USING_PTR¬=NULL);
                        IF USING.REG=J & USING.NAME='' THEN LEAVE;
                        USING_PTR=USING.NEXT;
                     END;
                     IF USING_PTR=NULL THEN GOTO $ERR_BREG;
                     GET STRING(LOCVAR) LIST(I);
                     REVERT CONV;
                     I=I+USING.OFF;
                     GOTO $TEST_FORW;
                  END;
                  I=$HB(LOCVAR);
                  IF LOCVAR¬='0' THEN
                     IF I <= 0 | I > TEXTLEN THEN DO;
                        CALL ISPLINK('SETMSG ', 'REAS041 '); /*INVOFF*/
                        #CUR(ZZCMD,1);
                        GOTO $ERR_PRIMARY;
                     END;
                END;
             END;
 $TEST_FORW: LOCVAR=$NEXTEL(PRIMARY);
             IF LENGTH(LOCVAR) > 1 & SUBSTR(LOCVAR,1,1)='R' THEN
                LOCVAR=SUBSTR(LOCVAR,2);
             ON CONV GOTO $ERR_REG;
             IF LOCVAR = '' THEN GOTO $ERR_REG;
             GET STRING(LOCVAR) LIST(J);
             REVERT CONV;
             IF J < 0 | J > 15 THEN DO;      /* 04/23/91 */
 $ERR_REG:      REVERT CONV;
                CALL ISPLINK('SETMSG ', 'REAS042 '); /*INVREG*/
                #CUR(ZZCMD,1);
                GOTO $ERR_PRIMARY;
             END;
             LOCVAR=$NEXTEL(PRIMARY);
             IF LOCVAR='' | LOCVAR='*' THEN DO;
                K = I;
                IF STRIN > 3 THEN K=LINE_O(STRIN-3);
             END;
             ELSE DO;
                K=$HB(LOCVAR);
                IF LOCVAR='0' THEN
                   K=0;
                ELSE DO;
                   IF K<=0 | K>TEXTLEN THEN DO;
                      CALL ISPLINK('SETMSG ', 'REAS043 '); /*INVPLC*/
                      GOTO $ERR_PRIMARY;
                   END;
                END;
             END;
             CALL $INITUSING(I,J,K,NN,0);
             GOTO $RESHOW;
          END;
          WHEN  ('D','DROP') DO;                       /* DROP */
            IF PRIMARY='' THEN DO;
               CALL ISPLINK('SETMSG ', 'REAS044 '); /*MISSOP*/
               #CUR(ZZCMD,1);
               GOTO $ERR_PRIMARY;
            END;
            LOCVAR=$NEXTEL(PRIMARY);
            IF LOCVAR='ALL' THEN DO;
               DO J=1 TO 15;
                  CALL $DROP(J);
               END;
               DO WHILE(QUALIFY_START¬=NULL);
                  QUALIFY_PTR=QUALIFY_START;
                  QUALIFY_START=QUALIFY.NEXT;
                  FREE QUALIFY;
               END;
            END;
            ELSE DO;
               P=NULL;
               QUALIFY_PTR=QUALIFY_START;
               DO WHILE(QUALIFY_PTR¬=NULL);
                  IF QUALIFY.NAME=LOCVAR THEN DO;
                     IF P=NULL THEN QUALIFY_START=QUALIFY.NEXT;
                               ELSE P->QUALIFY.NEXT=QUALIFY.NEXT;
                     FREE QUALIFY;
                  END;
                  P=QUALIFY_PTR;
                  QUALIFY_PTR=QUALIFY.NEXT;
                  GOTO $DROP_END;
               END;
               IF SUBSTR(LOCVAR,1,1)='R' & LENGTH(LOCVAR)>1 THEN
                  LOCVAR=SUBSTR(LOCVAR,2);
               ON CONV GOTO $ERR_DROP;
               GET STRING(LOCVAR) LIST(J);
               REVERT CONV;
               IF J<0 | J>15 THEN DO;
 $ERR_DROP:       REVERT CONV;
                  CALL ISPLINK('SETMSG ', 'REAS045 '); /*INVREG*/
                  #CUR(ZZCMD,1);
                  GOTO $ERR_PRIMARY;
               END;
               CALL $DROP(J);
            END;
 $DROP_END:
          END;
          WHEN  ('RES','RESET') DO;
            PENDING='0'B;
            GOTO $RESHOW;
          END;
          WHEN  ('TOP', 'UP MAX')
            GOTO TOP;
          WHEN  ('BOTTOM', 'DOWN MAX')
            GOTO BOTTOM;
          WHEN  ('REC','RECOVERY') DO;
               LOCVAR=$NEXTEL(PRIMARY);
               LOCV='C';                  /* <CREATE> */
               IF LOCVAR='LIB' THEN DO;
                  LOCV='L';               /* <CREATE LIB> */
                  LOCVAR=$NEXTEL(PRIMARY);
                  I = REASMRC(SAVE,'L');
                  MEMSAVE=CSECT;
                  CALL $REALLOC(SAVE,DSNSAVE,MEMSAVE,'');
                  DSRG=PO;
               END;
               IF LOCVAR='OFF' THEN LOCVAR='0';
               IF LOCVAR='' THEN
                  CALL REASMS('1'B,LOCV);
               ELSE DO;
                  ON CONV GOTO $ERRREM;
                  GET STRING(LOCVAR) LIST(I);
                  REVERT CONV;
                  IF I<0 THEN DO;
 $ERRREM:            REVERT CONV;
                     CALL ISPLINK('SETMSG ', 'REAS046 '); /*INVREG*/
                     GOTO $ERR_PRIMARY;
                  END;
                  IF I¬=0 THEN DO;
                     REMTIME=I;
                     $REM='1'B;
                     REMCOUNT=0;
                     CALL REASMS('1'B,LOCV);
                  END;
                  ELSE
                     $REM='0'B;
               END;
               GOTO $RESHOW;
         END;
         WHEN ('R','RETRANSLATE') DO;
            J = $OFFSET;                             /** RETRANSLATE**/
            GLOBAL = '0'B;
            LOCVAR = $NEXTEL(PRIMARY);
            IF LOCVAR ¬= '' THEN DO;
               IF SUBSTR(LOCVAR,1,1) = 'G' THEN GLOBAL='1'B;
               ELSE DO;
                  J = $HB(LOCVAR);
                  IF J=0 & LOCVAR¬='0' THEN DO;
                     CALL ISPLINK('SETMSG ', 'REAS047 '); /*INVOFF*/
                     #CUR(ZZCMD,1);
                     GOTO $ERR_PRIMARY;
                  END;
                  LOCVAR=$NEXTEL(PRIMARY);
                  IF LOCVAR¬='' & SUBSTR(LOCVAR,1,1)='G' THEN
                     GLOBAL='1'B;
               END;
            END;
 $RETRANSLATE:
            K=0; /* LENGTH */
            JJ=J; /* START */
            IF MOD(JJ,2)¬=0 THEN /* MAKE ADDR EVEN */
               JJ=JJ+1;
            IF J > TEXTLEN-1 THEN /* JUMPED OVER BORDER ?      */
               GOTO $TEST_GLOBAL;  /* PIECE COMPLETE           */
            CALL $FINDDSC(J);      /* WHERE WE ARE ???         */
            IF DSC.NORED THEN      /* FIXED PART ?             */
               GOTO $TEST_GLOBAL;  /* PIECE COMPLETE           */
          /*$NOOP='1'B */          /* NO OPERANDS PROCESS (SPEED) */
            CALL $CMD(J,1);        /* COMMAND IN FIRST LINE    */
            $NOOP='0'B;            /* PROCESS OPERANDS         */
            IF USING_START=NULL & $AUTO THEN /* BASE NECESSARY ? */
               CALL $TESTUS(J);    /* TEST SET BASE REG        */
            DO WHILE(REASM02_LINE(1).OPER¬='' & J < TEXTLEN);
               I=CMDLEN(CMDDEF);   /* COMMAND LENGTH           */
               J=J+I;              /* INCREMENT OFFSET         */
               K=K+I;              /* INCREMENT LENGTH         */
               IF J > TEXTLEN-1 THEN /* OVER BORDER?           */
                  GOTO $TEST_GLOBAL; /* FINISH PIECE           */
               CALL $FINDDSC(J);   /* WHERE WE ARE NOW ?       */
               IF (DSC.OFF+DSC.LENGTH-J < I) | DSC.NORED THEN
                  GOTO $TEST_GLOBAL; /* ||||| */
             /*$NOOP='1'B */
               CALL $CMD(J,1);
               $NOOP='0'B;
               IF USING_START=NULL & $AUTO THEN
                  CALL $TESTUS(J);
            END;
 $TEST_GLOBAL:
            IF K¬=0 THEN             /* LENGTH EXISTS        */
               CALL $INCLUDE(JJ,K,'I');
            IF GLOBAL THEN DO;       /* GLOBAL STATUS        */
               J=MAX(JJ+K,#FORWARD); /* TRY GO FORWARD MAX   */
               IF MOD(J,2)¬=0 THEN   /* ROUND TO             */
                  J=J+1;             /*    4                 */
               IF MOD(J,4)¬=0 THEN   /*    FORWARD           */
                  J=J+2;             /*                      */
               IF J>TEXTLEN THEN     /* DO NO JUMP TOO       */
                  J=TEXTLEN;         /*    FAR AWAY          */
               II1,II2=0;
               DO III=JJ+K BY 1 TO J WHILE(III < J);
                  ICH=0;
                  CH=SUBSTRTEXT(III+1,1);
                  II1=II1+1;
                  IF SUBSTR(GOODA,ICH+1,1)¬=HIGH(1) THEN
                     II2=II2+1;
               END;
               IF II1=II2 & $AUTO THEN
                  CALL $INCLUDE(JJ+K,II2,'C');
               DO J=J BY 4 WHILE(J < TEXTLEN);
                  CALL $FINDDSC(J);    /* SET KUDA NADO       */
                  IF DSC.NORED THEN    /* SKIP OVER           */
                     J=DSC.OFF+DSC.LENGTH-4;
                  ELSE DO;             /* TRY MAKE COMMAND    */
                   /*$NOOP='1'B */
                     CALL $CMD(J,1);
                     $NOOP='0'B;
                     IF REASM02_LINE(1).OPER¬='' THEN /* OK    ||| */
                        GOTO $RETRANSLATE; /* START FROM HERE      */
                     LOCVAR='';
                     ICH=0;
                     DO JJJ=J TO J+3;   /* 26.11.87 */
                        CH=SUBSTRTEXT(JJJ+1,1);
                        LOCVAR=LOCVAR || SUBSTR(GOODA,ICH+1,1);
                     END;
                     IF INDEX(LOCVAR,HIGH(1))=0 & $AUTO THEN
                        CALL $INCLUDE(J,4,'C');
                  END;
               END;
            END;

            OFFSET=$OFFSET;
            REASM02_PRIMARY = ' ';
            CALL $CLEAR_SCR;
            GOTO $RETURN_FROM_$SHOW;
          END;
          WHEN  ('P','PRINT') DO;
             LOCVAR=$NEXTEL(PRIMARY);
             IF LOCVAR='XREF' | LOCVAR='X' THEN DO;
                XREF_START=NULL;
                $XREF='1'B;                   /* 08.12.87 */
             END;
             PRINTBIT='1'B;
             PRINTNUM=0;
             FOFFSET=$OFFSET;
             #PAGE=0;
             SIGNAL ENDPAGE(SYSPRINT);
             OFFSET=0;
             REASM02_PRIMARY = ' ';
             CALL $CLEAR_SCR;
             GOTO $RETURN_FROM_$SHOW;
          END;
          WHEN  ('S','SAVE') DO;
            LOCVAR=$NEXTEL(PRIMARY);
            REASM02_PRIMARY = ' ';
            IF LOCVAR¬='' THEN  MEMOUT=LOCVAR;
            ELSE                MEMOUT=CSECT;
            IF MEMOUT='' THEN   MEMOUT='TEMPNAME';
            I = REASLIB(SOURCE, 'OPEN', MEMOUT);
            IF I¬=0 THEN DO;
               OFFSET=$OFFSET;
               GOTO $RETURN_FROM_$SHOW;
            END;

            #CARD='';
            CARD.LABEL = '*';
            CARD.OPER  = '';
            CARD.OPERANDS='* MVS/ESA REASM ' || REASMVER;
            CARDNUM    = 10000;
            I = REASLIB(SOURCE, 'WRITE', #CARD);
            CARD.LABEL='*';
            CARD.OPER='';
            LOCVAR=SUBSTR(REASM02_DSN,VERIFY(REASM02_DSN,' '));
            IF LENGTH(LOCVAR) > 50 THEN
               LOCVAR=SUBSTR(LOCVAR,1,50);
            CARD.OPERANDS=LOCVAR;
            CARDNUM=20000;
            I = REASLIB(SOURCE, 'WRITE', #CARD);
            SAVEBIT='1'B;
            FOFFSET=$OFFSET;
            OFFSET=0;
            CALL $CLEAR_SCR;
            SAVENUM=20000;
            GOTO $RETURN_FROM_$SHOW;
          END;
          OTHER DO;
            CALL ISPLINK('SETMSG ', 'REAS049 '); /*INVCMD*/
            #CUR(ZZCMD,1);
 $ERR_PRIMARY:
            GOTO CALLTV02;
          END;
        END;
 %SKIP;
                        /*********************************************/
                        /*  FUNCTIONAL KEY PROCESS                   */
                        /*********************************************/
     SELECT (IV);

       WHEN ('PF07') DO;  /* UP */
            SELECT (SCROLL);
               WHEN ('MAX') DO;
 TOP:            OFFSET, BOFFSET = 0;
               END;
               WHEN ('HALF') OFFSET = $OFFSET-4*(LVL/2);
               WHEN ('PAGE') OFFSET = $OFFSET-4*LVL;
               OTHER DO;
                  I = STRIN-3;
                  IF I > 0 THEN DO;
                     IF STRIN=LVL+3 THEN DO;
                        #CUR(ZZCMD,1);
                        OFFSET = $OFFSET-4*LVL;
                     END;
                     ELSE DO;
                        #CUR(SCREEN,(LVL-1)*80+COLIN-1);
                        OFFSET = LINE_O(I)-4*LVL;
                     END;
                  END;
                  ELSE
                     OFFSET=$OFFSET-4*LVL;
               END;
            END;
            DO I=1 TO MAXLVL-3;
               #AZO(REASM02_LINE(I).OFF#);
            END;
            CALL $GOODCMD(OFFSET);
            CALL $CLEAR_SCR;
            GOTO $RETURN_FROM_$SHOW;
       END;

       WHEN ('PF08') DO; /* DOWN */
            IF OFFSET >= TEXTLEN THEN DO;
               CALL $CLEAR_SCR;
               GOTO $PUTLINE_END;
            END;
            SELECT (SCROLL);
               WHEN ('MAX') DO;
 BOTTOM:         BOFFSET = 0;
                 OFFSET  = TEXTLEN-4*LVL;
                 #CUR(ZZCMD,1);
                 CALL $GOODCMD(OFFSET);
               END;
               WHEN ('PAGE') DO;
 PF08_PAGE:      I = LINE_O(LVL)+LINE_I(LVL);
                 IF OFFSET=I THEN OFFSET = I+1;
                 ELSE             OFFSET = I;
                 #CUR(ZZCMD,1);
               END;
               WHEN ('HALF') DO;
                 OFFSET = LINE_O(LVL/2+1);
                 #CUR(ZZCMD,1);
               END;
               OTHER DO;  /* CSR */
                  I = STRIN-4;
                  IF I>0 THEN DO;
                     OFFSET = LINE_O(I);
                     #CUR(SCREEN,COLIN);
                     CALL $GOODCMD(OFFSET);
                  END;
                  ELSE  GOTO PF08_PAGE;
               END;
            END;
            CALL $CLEAR_SCR;
            GOTO $RETURN_FROM_$SHOW;
       END;
       WHEN ('PF19')
         GOTO TOP;
       WHEN ('PF20')
         GOTO BOTTOM;
       OTHER
         GOTO $RESHOW;
     END;

 %SKIP;
 $PUTLINE_END:
        CALL $CLEAR_SCR;
        #CURI = 0;
     END;
     #CURI=#CURI+1;

 /*************/
 /* PRINTLINE */
 /*************/
 $PUTLINE_PRINT: PROC ;
 DCL (PRIV,BRANCH)  CHAR(1),
     (I,J);

    DO I=1 TO MAXLVL-3;
       IF REASM02_LINE(I).OPER¬='' |
          REASM02_LINE(I).OPERANDS¬='' THEN DO;
          IF SUBSTR(REASM02_LINE(I).LABEL,1,1)='*' &
             REASM02_LINE(I).OPER¬='EQU' THEN
             REASM02_LINE(I).LABEL='';       /* 08.12.87 */
          LINE_PTR=ADDR(REASM02_LINE(I).CMD#);
          COMMENT = #SCRCOM(I);
          IF LINE_C(I)¬=0 THEN SUBSTR(LINE,LINE_C(I))=' ';
          PRINTNUM=PRINTNUM+1;
          PRIV, BRANCH = ' ';
          IF REASMCM(@, REASM02_LINE(I).OPER, 'PRIV') THEN
             PRIV   = '*';
          IF REASMCM(@, REASM02_LINE(I).OPER, 'BRANCH') THEN
             BRANCH = '-';
          PUT SKIP EDIT(
            PRIV,
            REASM02_LINE(I).OFF,
            REASM02_LINE(I).OBJECT,
            PRINTNUM,
            REASM02_LINE(I).LABEL,
            BRANCH,
            REASM02_LINE(I).OPER,
            REASM02_LINE(I).OPERANDS)
            (A(1),X(1),A,X(1),A,X(5),F(4),X(2),A,A(1),A,X(1),A);

      /*  IF REASMCM(@, REASM02_LINE(I).OPER, 'USING') THEN
             PUT SKIP(0) EDIT(
                 PRIV,
                 REASM02_LINE(I).OFF,
                 REASM02_LINE(I).OBJECT,
                 PRINTNUM,
                 REASM02_LINE(I).LABEL,
                 BRANCH,
                 REASM02_LINE(I).OPER,
                 REASM02_LINE(I).OPERANDS)
                 (A(1),X(1),A,X(1),A,X(5),F(4),X(2),A,A(1),A,X(1),A);*/

          DO WHILE(LENGTH(COMMENT)>1 &
                   (SUBSTR(COMMENT,1,1)=' ' | SUBSTR(COMMENT,1,1)='/'));
             COMMENT = SUBSTR(COMMENT,2);
          END;
          IF COMMENT ¬= '' THEN DO;
             COMMENT = '/* ' || COMMENT;
             IF LENGTH(COMMENT)>40 THEN COMMENT=SUBSTR(COMMENT,1,40);
             DO J=1 TO 2;
           /*   PUT SKIP(0) EDIT(COMMENT) (COL(80), A); */
             END;
          END;
       END;
    END;
 END $PUTLINE_PRINT;

 /*************/
 /* SAVETLINE */
 /*************/
 $PUTLINE_SAVE: PROC ;
    DCL (I, J, POS)  BIN FIXED(31);
    DCL APOS BIN FIXED INIT(60);

    DO I=1 TO MAXLVL-3;
       LINE_PTR=ADDR(REASM02_LINE(I).CMD#);
       IF LINE_C(I)¬=0 THEN DO;
          J = LINE_C(I);
          SUBSTR(LINE,J,1)=' ';
          POS = J - 44;
       END;
       #CARD='';
       IF SUBSTR(REASM02_LINE(I).LABEL,1,1)='*' &
          REASM02_LINE(I).OPER¬='EQU' THEN
          REASM02_LINE(I).LABEL='';       /* 08.12.87 */

       CARD.LABEL    = REASM02_LINE(I).LABEL;
       CARD.OPER     = REASM02_LINE(I).OPER;
       CARD.OPERANDS = REASM02_LINE(I).OPERANDS;
       CARD.CONTPOS  = ' ';
       IF #CARD¬='' THEN DO;
          SAVENUM = SAVENUM+10000;
          CARDNUM = SAVENUM;
          J = REASLIB(SOURCE, 'WRITE', #CARD);
       END;
    END;
 END $PUTLINE_SAVE;

 END $PUTLINE;
 %SKIP;
 /*********************************************************************/
 /*  FILL LABEL IN IT'S  PLACE                                        */
 /*********************************************************************/
 $LABEL:
     PROC(OFF,LEN);
 DCL J    BIN FIXED(31),
     1 SLINE LIKE REASM02_LINE,
     $MOVE BIT(1) INIT('0'B),
     OFF BIN FIXED(31),
     LEN BIN FIXED(31);

     IF ALL(PASS='') THEN DO;
        ON ERROR STOP;
        PUT SKIP LIST('UNAUTHORIZED COPY. EXECUTION PROHIBITED');
        STOP;
     END;

     REASM02_LINE(#CURI).LABEL=''; /* START FROM BLANK   */
     LABL_PTR=LABL_START;
     DO WHILE(LABL_PTR¬=NULL);
        IF OFF      = LABL.OFF THEN LEAVE; /* COMPARED     ? */
        LABL_PTR=LABL.NEXT;
     END;
     IF LABL_PTR¬=NULL THEN DO;
        REASM02_LINE(#CURI).LABEL=LABL.NAME;
        IF LABL.NORED THEN
           #AZP(REASM02_LINE(#CURI).LABEL#);
     END;

     LABL_PTR=LABL_START;
     DO WHILE(LABL_PTR¬=NULL);
        IF OFF     <= LABL.OFF & OFF+LEN >     LABL.OFF THEN DO;
           IF ¬$MOVE THEN
              SLINE=REASM02_LINE(#CURI), BY NAME;
           $MOVE='1'B;
           IF LABL.NAME¬=SLINE.LABEL THEN DO;
              REASM02_LINE(#CURI).OBJECT='';
              REASM02_LINE(#CURI).OFF='';
              REASM02_LINE(#CURI).LABEL=LABL.NAME;
              REASM02_LINE(#CURI).OPER='EQU';
              REASM02_LINE(#CURI).OPERANDS=
                      '*+' || $DIGIT(LABL.OFF-OFF);
              #AZO(REASM02_LINE(#CURI).CMD#);
              IF LABL.NORED THEN
                 #AZO(REASM02_LINE(#CURI).LABEL#);
              ELSE
                 IF SUBSTR(REASM02_LINE(#CURI).LABEL,1,1)='*' THEN
                    #ANO(REASM02_LINE(#CURI).LABEL#);  /* 08.12.87 */
              IF $XREF THEN
                 CALL $PUTXRF(LABL.NAME);
              LINE_O(#CURI)=LABL.OFF;
              LINE_I(#CURI),LINE_C(#CURI)=0;
              CALL $PUTLINE;
           END;
        END;
        LABL_PTR=LABL.NEXT;
     END;
     IF $MOVE THEN
        REASM02_LINE(#CURI)=SLINE, BY NAME;
     IF REASM02_LINE(#CURI).LABEL¬='' & $XREF THEN
        CALL $PUTXRF(REASM02_LINE(#CURI).LABEL);
     IF SUBSTR(REASM02_LINE(#CURI).LABEL,1,1)='*' THEN
        #ANO(REASM02_LINE(#CURI).LABEL#);              /* 08.12.87 */
 END $LABEL;


 PRINT_EXTRN_WXTRN: PROC;
      DO I=1 TO DIM_ESD_ARRAY;
         ONEBYTE = ESD_ARRAY(I).TYPE;
         IF ESD_ARRAY(I).REF=ESDID THEN DO;
            IF ¬BIT4 & ¬BIT5 & BIT6 & BIT7 THEN DO;
               REASM02_LINE(#CURI).OPER='ENTRY';
               REASM02_LINE(#CURI).OPERANDS=ESD_ARRAY(I).NAME;
               REASM02_LINE(#CURI).OFF='';
               REASM02_LINE(#CURI).OBJECT='';
               #AZO(REASM02_LINE(#CURI).CMD#);
               #AZO(REASM02_LINE(#CURI).LABEL#);
               LINE_O(#CURI)=TEXTLEN;
               LINE_I(#CURI),LINE_C(#CURI)=0;
               CALL $PUTLINE;
            END;
         END;
         IF  BIT4 & ¬BIT5 & BIT6 & ¬BIT7 THEN DO;
            P = DSC_START;
 L_WXTRN:   DO WHILE(P¬=NULL);
               IF P->DSC.NAME = ESD_ARRAY(I).NAME THEN DO;
                 REASM02_LINE(#CURI).OPER='WXTRN';
                 REASM02_LINE(#CURI).OPERANDS=ESD_ARRAY(I).NAME;
                 REASM02_LINE(#CURI).OFF='';
                 REASM02_LINE(#CURI).OBJECT='';
                 #AZO(REASM02_LINE(#CURI).CMD#);
                 #AZO(REASM02_LINE(#CURI).LABEL#);
                 LINE_O(#CURI)=TEXTLEN;
                 LINE_I(#CURI),LINE_C(#CURI)=0;
                 CALL $PUTLINE;
                 LEAVE L_WXTRN;
               END;
               P = P->DSC.NEXT;
            END;
         END;
      END;

      P=DSC_START;
      DO WHILE(P¬=NULL);
         IF P->DSC.EXTRN THEN DO;
            Q=DSC_START;
            DO WHILE (Q¬=P);
               IF Q->DSC.NAME=P->DSC.NAME &
                  Q->DSC.TYPE=P->DSC.TYPE THEN
                  LEAVE;
               Q=Q->DSC.NEXT;
            END;
            IF Q=P THEN DO;
               REASM02_LINE(#CURI).OPER='EXTRN';
               REASM02_LINE(#CURI).OPERANDS=P->DSC.NAME;
               REASM02_LINE(#CURI).OFF='';
               REASM02_LINE(#CURI).OBJECT='';
               #AZO(REASM02_LINE(#CURI).CMD#);
               #AZO(REASM02_LINE(#CURI).LABEL#);
               LINE_O(#CURI)=TEXTLEN;
               LINE_I(#CURI),LINE_C(#CURI)=0;
               CALL $PUTLINE;
            END;
         END;
         P=P->DSC.NEXT;
      END;
 END PRINT_EXTRN_WXTRN;

 %PAGE;
 PRINT_DXD: PROC;
   DO I=1 TO DIM_ESD_ARRAY;
      ONEBYTE = ESD_ARRAY(I).TYPE;
      IF ¬BIT4 & BIT5 & BIT6 & ¬BIT7 THEN DO;   /* CXD-CONST */
         REASM02_LINE(#CURI).LABEL=ESD_ARRAY(I).NAME;
         IF $XREF THEN CALL $PUTXRF(REASM02_LINE(#CURI).LABEL);
         P = DSC_START;
 L_DXD:  DO WHILE(P¬=NULL);
            IF P->DSC.NAME = ESD_ARRAY(I).NAME THEN DO;
               REASM02_LINE(#CURI).OPER='DXD';
               IF ESD_ARRAY(I).ALIGN <= 7 THEN
                        LOCVAR=$ALIGN(ESD_ARRAY(I).ALIGN);
               ELSE     LOCVAR='C';
               IF LOCVAR='C' THEN
                  REASM02_LINE(#CURI).OPERANDS='XL' ||
                      $DIGIT(ESD_ARRAY(I).REF);
               ELSE   REASM02_LINE(#CURI).OPERANDS=LOCVAR;
               REASM02_LINE(#CURI).OFF='';
               REASM02_LINE(#CURI).OBJECT='';
               #AZO(REASM02_LINE(#CURI).CMD#);
               #AZO(REASM02_LINE(#CURI).LABEL#);
               LINE_O(#CURI)=TEXTLEN;
               LINE_I(#CURI),LINE_C(#CURI)=0;
               CALL $PUTLINE;
               LEAVE L_DXD;
            END;
            P = P->DSC.NEXT;
         END;
      END;
   END;
 END PRINT_DXD;

 %PAGE;
 PRINT_CSECT: PROC;
   REASM02_LINE(#CURI).LABEL=CSECT;
   REASM02_LINE(#CURI).OPER='CSECT';
   #AZO(REASM02_LINE(#CURI).CMD#);
   #AZP(REASM02_LINE(#CURI).LABEL#);
   LINE_O(#CURI),LINE_I(#CURI),LINE_C(#CURI)=0;
   CALL $PUTLINE;
 END PRINT_CSECT;

 %PAGE;
 PRINT_REGEQ_LTORG: PROC;
   DO I=0 TO 15;
      REASM02_LINE(#CURI).LABEL=$REGS(I);
      IF $XREF THEN
         CALL $PUTXRF($REGS(I));
      REASM02_LINE(#CURI).OPER='EQU';
      REASM02_LINE(#CURI).OPERANDS=$DIGIT(I);
      #AZO(REASM02_LINE(#CURI).CMD#);
      #AZO(REASM02_LINE(#CURI).LABEL#);
      LINE_O(#CURI)=TEXTLEN;
      LINE_I(#CURI),LINE_C(#CURI)=0;
      CALL $PUTLINE;
   END;
   REASM02_LINE(#CURI).LABEL='';
   REASM02_LINE(#CURI).OPER='LTORG';
   REASM02_LINE(#CURI).OPERANDS=',';
   #AZO(REASM02_LINE(#CURI).CMD#);
   #AZO(REASM02_LINE(#CURI).LABEL#);
   LINE_O(#CURI)=TEXTLEN;
   LINE_I(#CURI),LINE_C(#CURI)=0;
   CALL $PUTLINE;

 END PRINT_REGEQ_LTORG;

 %PAGE;
 PRINT_DSECTS: PROC;
   USING_PTR=USING_START;
   DO WHILE(USING_PTR¬=NULL);
      IF USING.NAME¬='' THEN DO;
         P=USING_START;
         DO WHILE(P¬=NULL & P¬=USING_PTR);
            IF P->USING.NAME=USING.NAME THEN
               GOTO $NEXT_USING_REGISTER;
            P=P->USING.NEXT;
         END;
         LBLOCK_PTR=LBLOCK_START;
         DO WHILE(LBLOCK_PTR¬=NULL & LBLOCK.NAME¬=USING.NAME);
            LBLOCK_PTR=LBLOCK.NEXT;
         END;
         IF LBLOCK.ADR=0 THEN DO;    /* NEW DUMMY DSECT */
            REASM02_LINE(#CURI).LABEL=SUBSTR(USING.NAME,2);
            REASM02_LINE(#CURI).OPER='DSECT';
            REASM02_LINE(#CURI).OPERANDS='';
         END;
         ELSE DO;                    /* CONTROL BLOCK   */
            REASM02_LINE(#CURI).LABEL='';
            REASM02_LINE(#CURI).OPER='';
            IF LBLOCK.MACRO = '' THEN
               REASM02_LINE(#CURI).OPERANDS=
                       SUBSTR(LBLOCK.NAME,2);
            ELSE
               REASM02_LINE(#CURI).OPERANDS=
                       SUBSTR(LBLOCK.MACRO,2);
         END;
         #AZO(REASM02_LINE(#CURI).CMD#);
         #AZO(REASM02_LINE(#CURI).LABEL#);
         LINE_O(#CURI)=TEXTLEN;
         LINE_I(#CURI),LINE_C(#CURI)=0;
         CALL $PUTLINE;
         IF LBLOCK.ADR=0 THEN DO;
            DUMMY_PTR = LBLOCK.ADUMMY;
            I=0;
            DO WHILE(DUMMY_PTR¬=NULL);
              IF DUMMY.OFF > I THEN DO;
                 REASM02_LINE(#CURI).OPER='DS';
                 REASM02_LINE(#CURI).OPERANDS='XL' ||
                            $DIGIT(DUMMY.OFF-I)    ||
                            '      +'              ||
                            $DIGIT(DUMMY.OFF); /*29.12.87*/
                 #AZP(REASM02_LINE(#CURI).CMD#);
                 #AZP(REASM02_LINE(#CURI).LABEL#);
                 LINE_O(#CURI)=TEXTLEN;
                 LINE_I(#CURI),LINE_C(#CURI)=0;
                 CALL $PUTLINE;
              END;
              I = DUMMY.OFF;
              REASM02_LINE(#CURI).LABEL=$DNAME(LBLOCK_PTR,I,J);
              #AZP(REASM02_LINE(#CURI).CMD#);
              #AZP(REASM02_LINE(#CURI).LABEL#);
              REASM02_LINE(#CURI).OPER='EQU';
              REASM02_LINE(#CURI).OPERANDS='*';
              P=DUMMY.NEXT;
              IF P¬=NULL THEN DO;
                 REASM02_LINE(#CURI).OPER='DS';
                 REASM02_LINE(#CURI).OPERANDS='XL'   ||
                           $DIGIT(P->DUMMY.OFF-I);
                 I=P->DUMMY.OFF;
              END;
              DO WHILE
                     (LENGTH(REASM02_LINE(#CURI).OPERANDS)<10);
                 REASM02_LINE(#CURI).OPERANDS =
                      REASM02_LINE(#CURI).OPERANDS || ' ';
              END;
              REASM02_LINE(#CURI).OPERANDS =
                      REASM02_LINE(#CURI).OPERANDS || '+' ||
                      $DIGIT(DUMMY.OFF);
              LINE_O(#CURI)=TEXTLEN;
              LINE_I(#CURI),LINE_C(#CURI)=0;
              CALL $PUTLINE;
              DUMMY_PTR=DUMMY.NEXT;
            END;
         END;
         REASM02_LINE(#CURI).LABEL=CSECT;
         REASM02_LINE(#CURI).OPER='CSECT';
         REASM02_LINE(#CURI).OPERANDS='';
         #AZO(REASM02_LINE(#CURI).CMD#);
         #AZO(REASM02_LINE(#CURI).LABEL#);
         LINE_O(#CURI)=TEXTLEN;
         LINE_I(#CURI),LINE_C(#CURI)=0;
         CALL $PUTLINE;
      END;
 $NEXT_USING_REGISTER:
      USING_PTR=USING.NEXT;
   END;
 END PRINT_DSECTS;

 %PAGE;
 PRINT_END_STMT: PROC;
   REASM02_LINE(#CURI).LABEL='';
   REASM02_LINE(#CURI).OPER='END';
   REASM02_LINE(#CURI).OPERANDS='';
   LINE_O(#CURI)=TEXTLEN;
   LINE_I(#CURI),LINE_C(#CURI)=0;
   CALL $PUTLINE;
   IF #CURI¬=1 THEN DO;
      DO I=#CURI TO MAXLVL-3;
         #AZP(REASM02_LINE(I).CMD#);
         #AZP(REASM02_LINE(I).LABEL#);
      END;
      #CURI=MAXLVL-3;
      CALL $PUTLINE;
   END;
 END PRINT_END_STMT;

 END $SHOW;

 %PAGE;
 /*********************************************************************/
 /*  FIND NECESSARY DSC ELEMENT BY OFFSET                             */
 /*********************************************************************/
 $FINDDSC:
     PROC(OFFSET);
 DCL OFFSET BIN FIXED(31);

     IF ALL(PASS='') THEN DO;
        ON ERROR STOP;
        PUT SKIP LIST('UNAUTHORIZED COPY. EXECUTION PROHIBITED');
        CALL REASLST;
        STOP;
     END;
     DSC_PTR=DSC_START;
     DO WHILE (DSC_PTR ¬= NULL);
        IF (OFFSET>=DSC.OFF) & (OFFSET<DSC.OFF+DSC.LENGTH) THEN
           RETURN;
        DSC_PTR=DSC.NEXT;
     END;
     PUT SKIP EDIT('INVALID OFFSET SPECIFIED: ' || $BH(OFFSET))(A);
     CALL REASLST;
     SIGNAL ERROR; STOP;
 END $FINDDSC;
 %SKIP;

 /*********************************************************************/
 /*  FILL UP THE OFFSET AND #COM                                      */
 /*********************************************************************/
 $JUMPOFF: PROC(OFF, CUR) RETURNS(CHAR(16) VAR);
   DCL OFF BIN FIXED(15),
       CUR BIN FIXED(31),
         I BIN FIXED(31),
        #I CHAR(4) BASED(ADDR(I)),
         LABNAME CHAR(16) VAR,
         REF CHAR(20) VAR;

   PUT STRING(REF) EDIT(OFF*2)(F(7));
   REF = SUBSTR(REF,VERIFY(REF,' '));
   IF OFF >= 0 THEN
      REF = '+' || REF;
   REF = '*' || REF;

   I = OFF*2 + CUR;
   LOCVAR = #I;
   LABNAME = $NAME(LOCVAR);

   CALL $INITLAB(LABNAME,I,0,'1'B,I);
   IF $XREF THEN CALL $PUTXRF(LABNAME);

   #COM = REF;

   RETURN (LABNAME);

 END $JUMPOFF;

 /*********************************************************************/
 /*  DETERMINE NAME BY OFFSET                                         */
 /*********************************************************************/
 $NAME:
     PROC(VAL)  RETURNS(CHAR(16) VAR);
 DCL VAL     CHAR(*) VAR,
     (O,OFF) BIN FIXED(31),
     (P,Q)   PTR,
     NAME    CHAR(16) VAR;

     NAME = $CH(VAL);
     O    = $HBF(NAME);
     IF LENGTH(NAME)=6 THEN
        NAME='00'||NAME;
     SUBSTR(NAME,1,1)='A';
     NAME='A' || SUBSTR(NAME,4);

     IF O > TEXTLEN THEN DO;
        NAME=$NEXTEL(CSECT) || '+' || $DIGIT(O);
        GOTO $NAME_RETURN;
     END;
     P=LABL_START;
     DO WHILE(P¬=NULL);
        IF P->LABL.OFF=O THEN DO;
           NAME=P->LABL.NAME;
           IF SUBSTR(NAME,1,1)='*' THEN DO;
              NAME='';
              OFF=0;
              Q=LABL_START;
              DO WHILE(Q¬=NULL);
                 IF SUBSTR(Q->LABL.NAME,1,1)¬='*' &
                    Q->LABL.OFF < P->LABL.OFF        &
                    Q->LABL.OFF > OFF THEN DO;
                       NAME=$NEXTEL(Q->LABL.NAME) || '+' ||
                            $DIGIT(P->LABL.OFF-Q->LABL.OFF);
                       OFF=Q->LABL.OFF;
                 END;
                 Q=Q->LABL.NEXT;
              END;
              IF NAME='' THEN
                 NAME=$NEXTEL(CSECT) || '+' || $DIGIT(P->LABL.OFF);
           END;
           GOTO $EXIT_NAME;
        END;
        P=P->LABL.NEXT;
     END;
 $EXIT_NAME:
     IF INDEX(NAME,' ')¬= 0 THEN
        NAME=SUBSTR(NAME,1,INDEX(NAME,' ')-1);
 $NAME_RETURN:
     RETURN(NAME);
 END $NAME;
 %SKIP;
 /*********************************************************************/
 /*  CLEAR ALL SCREEN PGM                                             */
 /*********************************************************************/
 $CLEAR_SCR: PROC;
 DCL I BIN FIXED(31);
     DO I=1 TO MAXLVL-3;
        #ANPU(REASM02_LINE(I).CMD#);
        #AZO(REASM02_LINE(I).OFF#);
        #AZO(REASM02_LINE(I).OBJECT#);
        #ANP(REASM02_LINE(I).LABEL#);
        #AZO(REASM02_LINE(I).OPER#);
        #AZO(REASM02_LINE(I).OPERANDS#);
        REASM02_LINE(I).CMD=' ';
        REASM02_LINE(I).OFF=' ';
        REASM02_LINE(I).OBJECT=' ';
        REASM02_LINE(I).LABEL=' ';
        REASM02_LINE(I).OPER=' ';
        REASM02_LINE(I).OPERANDS=' ';
        LINE_O(I),LINE_I(#CURI),LINE_C(#CURI)=0;
        #SCRCOM(I) = '';
     END;

     IF PENDING THEN DO;
        CALL ISPLINK('SETMSG ', 'REAS051 '); /*BLKPEN*/
     END;
     ELSE DO;
        /*
        IF $REM THEN
           CALL ISPLINK('SETMSG ', 'REAS052 ');
           REASM02_MESSAGE='R(' || $DIGIT(REMTIME)  || '/' ||
                                   $DIGIT(REMCOUNT) || ')' ||
                           REASM02_MESSAGE;
        */
     END;
 END $CLEAR_SCR;
 %SKIP;
 /*********************************************************************/
 /*  SUBSTRACT VALUE FROM A/V CONSTANT                                */
 /*********************************************************************/
 $SUBT:
     PROC(OFF,LEN,DECR);
 DCL (OFF,LEN,DECR) BIN FIXED(31),
     B      CHAR(1),
     F4     BIN FIXED(31),
     C4     CHAR(4) BASED(ADDR(F4)),
     C(4)   CHAR(1) BASED(ADDR(F4));

     IF LEN=4 THEN C4=SUBSTRTEXT(OFF+1,4);
              ELSE C4=SUBSTRTEXT(OFF,4);
     B    = C(1);
     C(1) = LOW(1);
     F4   = F4-DECR;
     C(1) = B;
     IF LEN=4 THEN CALL SUBSTRTEXT2(OFF+1,4,C4);
              ELSE CALL SUBSTRTEXT2(OFF,4,C4);
 END $SUBT;
 %SKIP;
 /*********************************************************************/
 /*  ADD LABEL TO LABEL LIST POOL                                     */
 /*********************************************************************/
 $INITLAB:
     PROC(N,O,R,F,P);
 DCL N    CHAR(8),        /* NAME*/
     O    BIN FIXED(31),  /* OFF */
     R    BIN FIXED,      /* REG */
     F    BIT(1),         /* FIX */
     P    BIN FIXED(31),  /* PLACE */
     B    BIT(1) INIT('0'B),
     Q    PTR INIT(NULL);

     LABL_PTR=LABL_START;
     DO WHILE(LABL_PTR¬=NULL);
        IF LABL.OFF = O THEN DO; /* THE SAME OFFSET     */
           IF ¬LABL.NORED THEN DO;  /* MAY TOUGHT       */
               IF F | ¬LABL.FIX THEN DO; /* REDEFINE    */
                  IF  LABL.NAME¬=N |
                     (LABL.REG¬=R & LABL.REG¬=0)  |
                      LABL.FIX¬=F THEN
                      B='1'B;
                  LABL.NAME=N;
                  IF LABL.REG¬=0 THEN
                     LABL.REG=R;
                  LABL.FIX=F;
               END;
           END;
           IF N='' THEN DO;
              IF Q¬=NULL THEN Q->LABL.NEXT=LABL.NEXT;
                         ELSE LABL_START=LABL.NEXT;
              FREE LABL;
           END;
           IF B THEN DO;
              $CONF='1'B;
              IF $REM THEN
                 CALL $AUTOREC;
           END;
           RETURN;
        END;
        Q=LABL_PTR;
        LABL_PTR=LABL.NEXT;
     END;

     IF N='' THEN RETURN;

     IF R¬=0 THEN DO;
        USING_PTR=USING_START;
        DO WHILE(USING_PTR¬=NULL);
           IF USING.REG=R & USING.NAME='' & USING.PLACE <= P &
              USING.PLACE+USING.LENGTH > P THEN
              GOTO $ALLOCATE_LABEL;
           USING_PTR=USING.NEXT;
        END;
        RETURN;
     END;

 $ALLOCATE_LABEL:
     ALLOCATE LABL;
     LABL.NEXT   = LABL_START;
     LABL_START  = LABL_PTR;
     LABL.NAME   = N;
     LABL.REG    = R;
     LABL.OFF = O;
     LABL.FIX    = '0'B;
     LABL.NORED  = '0'B;
     $CONF       = '1'B;
     IF $REM THEN
        CALL $AUTOREC;
 END $INITLAB;
 %PAGE;
 /*********************************************************************/
 /*  MOVE USING ELEMENT INTO USING LIST                               */
 /*********************************************************************/
 $INITUSING:
     PROC(O,R,PL,N,LEN);
 DCL O      BIN FIXED(31),
     R      BIN FIXED(31),
     PL     BIN FIXED(31),
     N      CHAR(8),
     LEN    BIN FIXED(31),
     SORT   BIT(1),
     (P,Q)  PTR;

     ALLOCATE USING;
     USING.NEXT   = USING_START;
     USING_START  = USING_PTR;
     USING.REG    = R;
     USING.OFF    = O;
     USING.PLACE  = PL;
     USING.NAME   = N;
     USING.FIX    = '0'B;
     USING.LENGTH = TEXTLEN-PL;
     IF LEN¬=0 THEN USING.LENGTH=LEN;
     IF N¬='' THEN
        CALL $INTLIV(N,LBLOCK_START,CONTROL);

     $CONF='1'B;
     IF $REM THEN
        CALL $AUTOREC;
 END $INITUSING;
 %SKIP;
 /*********************************************************************/
 /*  DROP SUBROUTINE                                                  */
 /*********************************************************************/
 $DROP:
     PROC(R);
 DCL R BIN FIXED(31),
     N CHAR(8),
     P PTR;
     IF R=0 THEN RETURN;
 $DROP_START#1:
     P=NULL;
     USING_PTR=USING_START;
     DO WHILE(USING_PTR¬=NULL);
        IF USING.REG=R THEN DO;
           IF P¬=NULL THEN P->USING.NEXT=USING.NEXT;
                      ELSE USING_START=USING.NEXT;
           N=USING.NAME;
           FREE USING;
           GOTO $DROP_START#1;
        END;
        P=USING_PTR;
        USING_PTR=USING.NEXT;
     END;
 $DROP_START#2:
     P=NULL;
     LABL_PTR=LABL_START;
     DO WHILE(LABL_PTR¬=NULL);
        IF LABL.REG=R THEN DO;
           IF P¬=NULL THEN P->LABL.NEXT=LABL.NEXT;
                      ELSE LABL_START=LABL.NEXT;
           FREE LABL;
           GOTO $DROP_START#2;
        END;
        P=LABL_PTR;
        LABL_PTR=LABL.NEXT;
     END;
     IF N='' THEN RETURN;
     USING_PTR=USING_START;
     DO WHILE(USING_PTR¬=NULL);
        IF USING.NAME=N THEN RETURN;
        USING_PTR=USING.NEXT;
     END;
     CALL $DELLIV(N,LBLOCK_START);
 END $DROP;
 %SKIP;
 /*********************************************************************/
 /*  TRY SET BASE REGISTER SUBROUTINE                                 */
 /*********************************************************************/
 $TESTUS:
     PROC(J);
 DCL    J BIN FIXED(31);
     IF USING_START¬=NULL THEN RETURN;
     SELECT (REASM02_LINE(1).OPER);
       WHEN  ('BALR') DO;
         IF RR1.R2=0 & RR1.R1¬=0  & RR1.R1¬=1  &
                       RR1.R1¬=14 & RR1.R1¬=15 THEN
            CALL $INITUSING(J+2,RR1.R1,J+2,'',0);
       END;
       WHEN  ('BAL') DO;
         IF RX.B2=15 & RX.R1¬=0  & RX.R1¬=1  &
                       RX.R1¬=14 & RX.R1¬=15 THEN
            CALL $INITUSING(J+4,RX.R1,J+4,'',0);
       END;
       WHEN  ('LR') DO;
         IF RR1.R2=15 & RR1.R1¬=0  & RR1.R1¬=1  &
                        RR1.R1¬=14 & RR1.R1¬=15 THEN
            CALL $INITUSING(0,RR1.R1,J+2,'',0);
       END;
       OTHER;
     END;
 END $TESTUS;
 %PAGE;
 /*********************************************************************/
 /*  SET XREF ELEMENT                                                 */
 /*********************************************************************/
 $PUTXRF:
     PROC(N);
 DCL N      CHAR(*),               /* NAME TO PUT     */
     NAME   CHAR(16),
     I      BIN FIXED(31),
     #STMT  BIN FIXED(31),
     (Q,P)  PTR INIT(NULL);

     NAME = N;
     IF NAME = '' THEN RETURN;         /* IF BLANK NAME   */
     #STMT=PRINTNUM+#CURI;        /* STATEMENT NUMB  */

     XREF_PTR=XREF_START;                     /* FROM XREF START     */
 L_XREF:
     DO WHILE(XREF_PTR¬=NULL);                /* WHILE XREF_PTR EXST */
        IF XREF.NAME=NAME THEN DO;            /* TH SAME NAME ?      */
           DO WHILE(XREF.CONT¬=NULL);         /* GO BROTHER LINE     */
              DO I=1 TO XREF.ISTMT;           /* BY STMT NUMBER      */
                 IF XREF.STMT(I)=#STMT THEN RETURN;
              END;                            /*                     */
              XREF_PTR=XREF.CONT;             /* NEXT BROTHER        */
           END;                               /*                     */
           DO I=1 TO XREF.ISTMT;              /* BY STMT NUMBER      */
              IF XREF.STMT(I)=#STMT THEN RETURN;
           END;
           IF XREF.ISTMT < DIM(XREF.STMT,1) THEN DO;
              XREF.ISTMT=XREF.ISTMT+1;
              XREF.STMT(XREF.ISTMT)=#STMT;
           END;
           ELSE DO;                           /* CREATE NEW BROTHER  */
              P=XREF_PTR;                     /*                     */
              ALLOCATE XREF;                  /* ALLOCATE HIM        */
              P->XREF.CONT=XREF_PTR;          /* SET CONT VALUE      */
              XREF.STMT=0;                    /* FILL                */
              XREF.NAME=NAME;                 /*     ALL             */
              XREF.ISTMT=1;                   /*        FIELDS       */
              XREF.STMT(1)=#STMT;             /*                     */
              XREF.NEXT=P->XREF.NEXT;         /* NEXT FIELD IS SAME  */
              XREF.CONT=NULL;                 /* NO NEXT BROTHER     */
           END;                               /*                     */
           RETURN;                            /*                     */
        END;                                  /*                     */
        ELSE DO;                              /* NON EQUAL NAME      */
          IF UNSPEC(XREF.NAME) > UNSPEC(NAME) THEN LEAVE L_XREF;
        END;                                  /*                     */
        Q=XREF_PTR;                           /* SAVE XREF POINTER   */
        XREF_PTR=XREF.NEXT;                   /* GOTO NEXT ONE       */
     END L_XREF;                              /*                     */
                                              /*                     */
     P=XREF_PTR;                              /*                     */
     ALLOCATE XREF;                           /*                     */
     IF Q=NULL THEN   XREF_START=XREF_PTR;    /*                     */
               ELSE Q->XREF.NEXT=XREF_PTR;    /*                     */
     XREF.STMT=0;                             /*                     */
     XREF.NAME=NAME;                          /*                     */
     XREF.NEXT=P;                             /*                     */
     XREF.CONT=NULL;                          /*                     */
     XREF.ISTMT=1;                            /*                     */
     XREF.STMT(1)=#STMT;                      /*                     */
 END $PUTXRF;                                 /*                     */
 %SKIP;
 /*********************************************************************/
 /*  PRINT XREF TABLE                                                 */
 /*********************************************************************/
 $PRINT_XREF:
     PROC;
 DCL (P,Q) PTR,
     SORT  BIT(1),
     (I,N) BIN FIXED(31);

     SIGNAL ENDPAGE(SYSPRINT);
     PUT SKIP EDIT('=== CROSS REFERENCE LISTING ===')
                   (COL(40),A,SKIP(2));
     XREF_PTR=XREF_START;
     DO WHILE(XREF_PTR¬=NULL);
        PUT SKIP EDIT(XREF.NAME)(COL(2),A(16));
        N=1;
 $PUTSTMT:
        DO I=1 TO XREF.ISTMT;
           PUT EDIT(XREF.STMT(I))(X(1),F(4));
           N=N+1;
           IF N > 20 THEN DO;
              N=1;
              PUT SKIP EDIT((16)' ')(COL(2),A(16));
           END;
        END;
        P=XREF_PTR;
        IF XREF.CONT¬=NULL THEN DO;
           XREF_PTR=XREF.CONT;
           FREE P->XREF;
           GOTO $PUTSTMT;
        END;
        XREF_PTR=XREF.NEXT;
        FREE P->XREF;
     END;
     XREF_START=NULL;

     PUT SKIP(3) EDIT('--------------- END OF XREF LIST')(A);
 END $PRINT_XREF;
 %PAGE;
 /*********************************************************************/
 /*  COMMENT FILL SUBROUTINE                                          */
 /*********************************************************************/
 $PUTCOM:
     PROC(I);
 DCL   (I,J,K,L) BIN FIXED(31),
       (P,Q,R)   PTR,
       LINE_PTR  PTR,
       BYTE      CHAR(1),
       LINE      CHAR(80) BASED(LINE_PTR);

     LINE_PTR=ADDR(REASM02_LINE(I).CMD#);
     IF REASM02_LINE(I).OPERANDS¬='' THEN DO;
        J = LENGTH(REASM02_LINE(I).OPERANDS);
        DO K=80 BY -1 WHILE(SUBSTR(LINE,K,1)=' ');
           J = J-1;
        END;
     END;
     ELSE   DO;
        K = 50;
        J = 2;
     END;

     LINE_C(I)=0;
     IF K >= 79 THEN RETURN;

     #ANPL(BYTE);
     SUBSTR(REASM02_LINE(I).OPERANDS, J+1, 1) = BYTE;

     LINE_C(I)=K+1;
     COM_PTR=COM_START;
     DO WHILE(COM_PTR¬=NULL);
        IF LINE_O(I)           <= COM.OFF &
           LINE_O(I)+LINE_I(I) >  COM.OFF THEN
           SUBSTR(LINE,K+2)=COM.TXT;
        COM_PTR=COM.NEXT;
     END;
     IF SUBSTR(LINE,K+2)='' THEN   /* NOT FILLED   */
        SUBSTR(LINE,K+2)=#COM;
     #SCRCOM(I) = SUBSTR(LINE,K+2);
 END $PUTCOM;
 %SKIP;
 /*********************************************************************/
 /*  MEMORY FREE SUBROUTINE                                           */
 /*********************************************************************/
 $FREE:
     PROC ;
     @@FREE_LIST(DSC);
     @@FREE_LIST(LABL);
     @@FREE_LIST(QUALIFY);
     @@FREE_LIST(USING);
     @@FREE_LIST(COM);
     @@FREE_LIST(LBLOCK);

 END $FREE;
 %SKIP;
 /*********************************************************************/
 /*  AUTO RECOVERY PROCESS SUBROUTINE                                 */
 /*********************************************************************/
 $AUTOREC:
     PROC ;
     REMCOUNT=REMCOUNT+1;
     IF REMCOUNT=REMTIME THEN
        CALL REASMS('0'B,'*');
 END $AUTOREC;
 %SKIP;
 /*********************************************************************/
 /*  FILL DUMMY SUBROUTINE                                            */
 /*********************************************************************/
 $PUTDUMMY:
     PROC(NAME,OFFSET);
 DCL NAME   CHAR(*),
     OFFSET BIN FIXED(31),
     (P,Q,R)  PTR INIT(NULL);

     P=LBLOCK_START;
     DO WHILE(P¬=NULL);
        IF  P->LBLOCK.NAME=NAME THEN LEAVE;
        P = P->LBLOCK.NEXT;
     END;
     IF P = NULL THEN RETURN;
     IF P->LBLOCK.ADR ¬= 0 THEN RETURN;    /* DO NOT FILL LIV | */

     R = P->LBLOCK.ADUMMY;
     DO WHILE(R¬=NULL);
        IF R->DUMMY.OFF = OFFSET THEN     RETURN;
        IF R->DUMMY.OFF > OFFSET THEN     LEAVE;
        Q=R;
        R=R->DUMMY.NEXT;
     END;
     ALLOCATE DUMMY;
     DUMMY.OFF = OFFSET;
     DUMMY.NEXT   = R;
     DUMMY.NAME   = '';
     IF Q=NULL THEN P->LBLOCK.ADUMMY=DUMMY_PTR;
     ELSE           Q->DUMMY.NEXT=DUMMY_PTR;
 END $PUTDUMMY;

 /*********************************************************************/
 /*  RETURN BIT STRING WHICH REPRESENTS BYTE                          */
 /*********************************************************************/
 $BITSTR:PROC(BYTE) RETURNS(CHAR(20) VAR);
 DCL BYTE   CHAR(1),
     HALF   BIN FIXED,
     LOCVAR CHAR(20) VAR INIT('');
     ICH = 0;
     DO HALF=128,64,32,16,8,4,2,1;
        CH = BYTE;
        UNSPEC(ICH) = UNSPEC(ICH) & UNSPEC(HALF);
        IF ICH = 0 THEN LOCVAR = LOCVAR || '0';
        ELSE            LOCVAR = LOCVAR || '1';
     END;
     LOCVAR = 'B''' || LOCVAR || '''';
     RETURN(LOCVAR);
 END $BITSTR;

 /*********************************************************************/
 /*  TEST FOR LABEL REDEFINITION                                      */
 /*********************************************************************/
 $DUBLAB:PROC(NAME,OFFSET) RETURNS(BIT(1));
 DCL NAME    CHAR(*),
     OFFSET  BIN FIXED(31),
     (P,Q)   PTR;
    IF NAME='' THEN RETURN('0'B);
    P=LABL_START;
    DO WHILE(P¬=NULL);
       IF P->LABL.NAME=NAME & OFFSET¬=P->LABL.OFF THEN RETURN('1'B);
       P=P->LABL.NEXT;
    END;
    P=LBLOCK_START;
    DO WHILE(P¬=NULL);
       IF P->LBLOCK.ADR=0 THEN DO;
          Q = P->LBLOCK.ADUMMY;
          DO WHILE(Q¬=NULL);
             IF Q->DUMMY.NAME = NAME THEN RETURN('1'B);
             Q = Q->DUMMY.NEXT;
          END;
       END;
       P=P->LBLOCK.NEXT;
    END;
    RETURN ('0'B);
 END $DUBLAB;

 /*********************************************************************/
 /*  TEST IF CHAR STRING IS GOOD                                      */
 /*********************************************************************/
 $CHARSTR: PROC(STR)  RETURNS(BIT(1));
 DCL STR  CHAR(*) VAR;
 DCL I;
     ICH = 0;
     DO I=1 TO LENGTH(STR);
        CH = SUBSTR(STR,I,1);
        CH = SUBSTR(GOODA,ICH+1,1);
        IF CH = HIGH(1) THEN RETURN('0'B);
     END;
     RETURN('1'B);
 END $CHARSTR;

 /*********************************************************************/
 /*  TEST PSA USING                                                   */
 /*********************************************************************/
 $USING_PSA:
     PROC(PTR);
 DCL PTR       BIN     FIXED(31),
     TRY       BIT(1)  STATIC INT INIT('0'B),
     PSAOK     BIT(1)  STATIC INT INIT('0'B),
     PSANAME   CHAR(8) STATIC INT INIT('@PSA'),
     P         PTR,
     RC        BIN     FIXED(31);

     IF ¬TRY THEN DO;
        CALL REASMLD(PSANAME,RC,CONTROL);
        CALL REASMDL(PSANAME);
        TRY = '1'B;
        IF RC THEN PSAOK='1'B;
     END;

     IF PSAOK THEN DO;
        P = USING_START;
        DO WHILE(P ¬= NULL);
           IF  P->USING.REG                    = 0   &
               P->USING.PLACE                 <= PTR &
               P->USING.PLACE+P->USING.LENGTH >  PTR THEN  RETURN;
           P = P->USING.NEXT;
        END;
        CALL $INITUSING(PTR,0,PTR,PSANAME,4);
     END;

 END $USING_PSA;

 /*********************************************************************/
 /*  TEST CVT USING                                                   */
 /*********************************************************************/
 $USING_CVT:
     PROC(PTR, REG);
 DCL PTR       BIN     FIXED(31),
     REG       BIN     FIXED,
     TRY       BIT(1)  STATIC INT INIT('0'B),
     CVTOK     BIT(1)  STATIC INT INIT('0'B),
     CVTNAME   CHAR(8) STATIC INT INIT('@CVT'),
     P         PTR,
     RC        BIN     FIXED(31);

     IF ¬TRY THEN DO;
        CALL REASMLD(CVTNAME,RC,CONTROL);
        CALL REASMDL(CVTNAME);
        TRY = '1'B;
        IF RC THEN CVTOK='1'B;
     END;

     IF CVTOK THEN DO;
        P = USING_START;
        DO WHILE(P ¬= NULL);
           IF  P->USING.REG                    = REG &
               P->USING.PLACE                 <= PTR &
               P->USING.PLACE+P->USING.LENGTH >  PTR &
               P->USING.NAME                   = CVTNAME THEN RETURN;
           P = P->USING.NEXT;
        END;
        CALL $INITUSING(PTR,REG,PTR,CVTNAME,4);
     END;

 END $USING_CVT;

 $GOODCMD: PROC(OFFSET);
  DCL (OFFSET,I)  BIN FIXED(31);

    IF OFFSET<0 THEN OFFSET=0;
    IF OFFSET>= TEXTLEN THEN OFFSET = TEXTLEN-1;
    IF OFFSET¬=0 THEN DO;
       CALL $FINDDSC(OFFSET);
       IF DSC.TYPE='I' THEN DO;
          I=0;
          IF MOD(OFFSET,2)¬=0 THEN OFFSET=OFFSET-1;
          DO WHILE(DSC.OFF+I <= OFFSET);
             CMD_PTR  = ADDRTEXT();
             #CMD_PTR = #CMD_PTR+DSC.OFF+I;
             I=I+CMDLEN(CMDDEF);
          END;
          OFFSET=DSC.OFF+I;
       END;
    END;
 END $GOODCMD;
 %PAGE;


 $ERROR:
     ON ERROR SNAP GOTO $RETURN;
     CALL $PRINTDSC('--- ABNORMAL END OF REASM PROGRAMM');
     IF $CONF THEN DO;
        CALL ISPLINK ('SETMSG ', 'REAS002 ');  /* SYSTEM ERROR */
        OFFSET = $OFFSET;
        ON ERROR GOTO $ERROR;
        GOTO $SHOW_LOOP;
     END;
     GOTO $RETURN;

 $REALLOC:
     PROC(DDNAME, DSNAME, MEMNAME, VOLNAME) RED REORDER;
     DCL DDNAME  CHAR(8),
         DSNAME  CHAR(44),
         MEMNAME CHAR(8),
         VOLNAME CHAR(6);
     DCL TXT CHAR(255) VAR INIT('');
     DCL T   CHAR(255);

     CALL DYNAM(DYNWORK, 'UNALLOC ',
                'DD=' || DDNAME || ' UNALLOC;');
     TXT = 'DD='  || DDNAME ||
           ' DSN='  || $CUTDSN(DSNAME);
     MEMNAME = TRANSLATE(MEMNAME,'#','*');
     IF MEMNAME ¬= '' THEN TXT = TXT || ' MEMBER=' || MEMNAME;
     IF VOLNAME ¬= '' THEN TXT = TXT || ' VOLUME=' || VOLNAME;
     TXT = TXT || ' SHR;';
     T = TXT;
     DYNAREA.VOL = '';
     CALL DYNAM(DYNWORK,'ALLOCR ',DYNAREA,T);
 END $REALLOC;

 $CUTDSN:
     PROC(OLDNAME) RED REORDER RETURNS(CHAR(44) VAR);
     DCL OLDNAME CHAR(44),
         NEWNAME CHAR(44) VAR;
     DCL I;
     OLDNAME = TRANSLATE(OLDNAME, ' ', LOW(1));
     I = INDEX(OLDNAME,' ');
     IF I>1 THEN NEWNAME=SUBSTR(OLDNAME,1,I-1);
     ELSE        NEWNAME=OLDNAME;
     RETURN(NEWNAME);
 END $CUTDSN;

 $PRINTDSC:
     PROC(T) RED REORDER;
     DCL T CHAR(*),
         I;

     ON ERROR SYSTEM;

     PUT SKIP EDIT(T,' DATE: ',DATE,' TIME: ',TIME)(A);
     PUT SKIP EDIT('DSN=',DSN,' MEM=',MEMBER,' CSECT=',CSECT)(A);

     IF DSC_START¬=NULL THEN DO;
     PUT SKIP(2) EDIT('*** DSC TABLE ***',
     '..NAME.. ..OFFSET ..LENGTH  TYPE RD N F E S')(A,SKIP,COL(9),A);
     DSC_PTR=DSC_START;
     DO WHILE(DSC_PTR¬=NULL);
        PUT SKIP
            EDIT(DSC.NAME,$BH(DSC.OFF),$BH(DSC.LENGTH),DSC.TYPE,
                 DSC.NORED,DSC.NEW,DSC.FIX,DSC.EXTRN,DSC.SUBT)
            (COL(9),A(8),X(1),A(8),X(1),A(8),X(4),A(1),X(3),B(1),X(1),
                    B(1),X(1),B(1),X(1),B(1),X(1),B(1));
        DSC_PTR=DSC.NEXT;
     END;
     PUT SKIP LIST('-----------------------------------');
     END;

     IF LABL_START¬=NULL THEN DO;
     LABL_PTR=LABL_START;
     PUT SKIP(2) EDIT('*** LABEL TABLE ***',
     '...LABEL ..OFFSET RG F NR')(A,SKIP,COL(9),A);
     DO WHILE(LABL_PTR¬=NULL);
        PUT SKIP EDIT(LABL.NAME,$BH(LABL.OFF),LABL.REG,LABL.FIX,
                     LABL.NORED)
                     (COL(9),A,X(1),A(8),X(1),F(2),X(1),B(1),X(2),B(1));
        LABL_PTR=LABL.NEXT;
     END;
     PUT SKIP LIST('-----------------------------------');
     END;

     IF USING_START¬=NULL THEN DO;
     USING_PTR=USING_START;
     PUT SKIP(2) EDIT('*** USING TABLE ***',
     '..NAME.. ..OFFSET ..LENGTH ...PLACE REG  F')(A,SKIP,COL(9),A);
     DO WHILE(USING_PTR¬=NULL);
        PUT SKIP EDIT(USING.NAME,
                      $BH(USING.OFF),
                      $BH(USING.LENGTH),
                      $BH(USING.PLACE),
                      $REGS(USING.REG),
                      USING.FIX)
                     (COL(9),A(8),X(1),A,X(1),A,X(1),A,X(1),A(3),
                       X(2),B(1));
        USING_PTR=USING.NEXT;
     END;
     PUT SKIP LIST('-----------------------------------');
     END;

     IF COM_START¬=NULL THEN DO;
     COM_PTR=COM_START;
     PUT SKIP(2) EDIT('*** COMMENT TABLE ***',
     '..OFFSET ..TXT..')(A,SKIP,COL(9),A);
     DO WHILE(COM_PTR¬=NULL);
        PUT SKIP EDIT($BH(COM.OFF),COM.TXT)
                     (COL(9),A(8),X(1),A);
        COM_PTR=COM.NEXT;
     END;
     PUT SKIP LIST('-----------------------------------');
     END;

     IF LBLOCK_START¬=NULL THEN DO;
     LBLOCK_PTR=LBLOCK_START;
     PUT SKIP(2) EDIT('*** LBLOCK TABLE ***',
     '..NAME..  ...ADR.. ..DUMMY. ...MACRO STATEMENT...')
     (A,SKIP,COL(9),A);
     DO WHILE(LBLOCK_PTR¬=NULL);
        PUT SKIP EDIT(LBLOCK.NAME,
                      $BH(LBLOCK.ADR),
                      $BH(BIN(UNSPEC(LBLOCK.ADUMMY),31)),
                      LBLOCK.MACRO)
                     (COL(9),A(9),X(1),A,X(1),A,X(1),A);
        LBLOCK_PTR=LBLOCK.NEXT;
     END;
     PUT SKIP LIST('-----------------------------------');
     END;

     IF QUALIFY_START¬=NULL THEN DO;
     QUALIFY_PTR=QUALIFY_START;
     PUT SKIP(2) EDIT('*** QUALIFY TABLE ***',
     '..OFFSET ..NAME..')(A,SKIP,COL(9),A);
     DO WHILE(QUALIFY_PTR¬=NULL);
        PUT SKIP EDIT($BH(QUALIFY.OFF),QUALIFY.NAME)
                     (COL(9),A(8),X(1),A);
        QUALIFY_PTR=QUALIFY.NEXT;
     END;
     PUT SKIP LIST('-----------------------------------');
     END;

     PUT SKIP(2) EDIT('*** ESD ARRAY TABLE *** (CURRENT ESDID =',
                      ESDID, ')',
                      'NNNNN ..NAME.. .TYPE ..OFFSET ALIGN LEN ..REF')
                     (A,F(5),A,SKIP,COL(9),A);
     DO I=1 TO DIM_ESD_ARRAY;
        PUT SKIP EDIT(ESD_ARRAY(I).ID,
                      ESD_ARRAY(I).NAME,
                      $IMM(ESD_ARRAY(I).TYPE),
                      $BH(BIN(ESD_ARRAY(I).OFF,31)),
                      $IMM(ESD_ARRAY(I).ALIGN),
                      BIN(ESD_ARRAY(I).LENGTH,15),
                      ESD_ARRAY(I).REF)
        (COL(9),F(5),X(1),A,X(1),A,X(1),A,X(1),A,X(1),F(3),X(1),F(5));
     END;
     PUT SKIP LIST('-----------------------------------');

     IF XREF_START¬=NULL THEN CALL $PRINT_XREF;

     REVERT ERROR;
     CALL REASLST;

 END $PRINTDSC;

 CALCULATE_LVL: PROC;
       DCL  ISPLINK ENTRY EXT OPTIONS(INTER ASM RETCODE);
       DCL  F4      BIN   FIXED(31) INIT(4);
       DCL  SCR     CHAR(4);
       CALL ISPLINK ('VCOPY ', 'ZSCREEND ', F4, SCR, 'MOVE ');
       GET STRING(SCR) LIST(MAXLVL);
       LVL = MAXLVL - 3;
 END CALCULATE_LVL;

 /*  TEXTARRAY MANIPULATION ROUTINES */
 SUBSTRTEXT: PROC(OFF, LEN) RETURNS(CHAR(32767) VAR);  /***/
   DCL (OFF,LEN) BIN FIXED(31);
   RETURN (SUBSTRARRAY(TEXT,OFF,LEN));
 END SUBSTRTEXT;

 SUBSTRTEXT1: PROC(OFF) RETURNS(CHAR(32767) VAR);   /***/
   DCL (OFF) BIN FIXED(31);
   RETURN (SUBSTRARRAY(TEXT,OFF,0));
 END SUBSTRTEXT1;

 SUBSTRTEXT2: PROC(OFF, LEN, VAL);                /***/
   DCL (OFF,LEN,I) BIN FIXED(31);
   DCL VAL CHAR(*) VAR;
   IF (LEN > 32767) THEN
      SIGNAL ERROR;
   DO I=0 TO LEN-1;
      TEXT(OFF+I) = SUBSTR(VAL,I+1,1);
   END;
 END SUBSTRTEXT2;

 SUBSTRTEXTCOPY: PROC(OFF, LEN) RETURNS(CHAR(32767) VAR);  /***/
   DCL (OFF,LEN) BIN FIXED(31);
   RETURN (SUBSTRARRAY(TEXTCOPY,OFF,LEN));
 END SUBSTRTEXTCOPY;

 SUBSTRARRAY: PROC(ARRAY,OFF,L) RETURNS(CHAR(32767) VAR);  /***/
   DCL ARRAY(*) CHAR(1);
   DCL (OFF,LEN,L) BIN FIXED(31);
   DCL SUB  CHAR(32767) BASED(PSUB), PSUB PTR;
   DCL SUBS CHAR(32767) VAR INIT('');

   LEN = L;
   IF (LEN = 0) | ((OFF+LEN-1) > TEXTIND) THEN
      LEN = TEXTIND-OFF+1;

   IF (LEN > 32767) THEN
      SIGNAL ERROR;

   /*
   DCL I BIN FIXED(31);
   DO I=0 TO LEN-1;
      SUBS = SUBS || ARRAY(OFF+I);
   END;
   */
   PSUB = ADDR(ARRAY(OFF));
   SUBS = SUBSTR(SUB,1,LEN);

   RETURN (SUBS);
 END SUBSTRARRAY;

 ALLOCATETEXT: PROC(LEN);      /***/
   DCL LEN BIN FIXED(31);
   TEXTIND = 0;
 END ALLOCATETEXT;

 FREETEXT: PROC;                          /***/
 END FREETEXT;

 LENGTHTEXT: PROC RETURNS(BIN FIXED(31));  /***/
   RETURN (TEXTIND);
 END LENGTHTEXT;

 SETTEXT: PROC(VAL);                      /***/
   DCL VAL CHAR(*) VAR;
   TEXTIND = 0;
   CALL CONCATTEXT(VAL);
 END SETTEXT;

 CONCATTEXT: PROC(VAL);       /***/
   DCL VAL CHAR(*) VAR;
   DCL I BIN FIXED(31);
   DO  I=1 TO LENGTH(VAL);
     TEXT(TEXTIND+1) = SUBSTR(VAL,I,1);
     TEXTIND = TEXTIND + 1;
   END;
 END CONCATTEXT;

 COPYTEXT: PROC;               /***/
   DCL I BIN FIXED(31);
   TEXTCOPY = TEXT;
 END COPYTEXT;

 ADDRTEXT: PROC RETURNS(PTR);  /***/
   RETURN (ADDR(TEXT));
 END ADDRTEXT;

 %PAGE;
     %INCLUDE REASMS;
     %INCLUDE REASMR;

 END REASM;
