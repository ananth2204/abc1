IORTNS   START
         USING SELF,R12
         EJECT
COUNTS   DS    0F
USERBASE EQU   *
         USING *,R5
         DS    CL8192
         ORG   *-8192
PRCNT    DC    PL4'0'
IN1CNT   DC    PL4'0'
IN2CNT   DC    PL4'0'
IN3CNT   DC    PL4'0'
O1CNT    DC    PL4'0'
O2CNT    DC    PL4'0'
O3CNT    DC    PL4'0'
CRDCNT   DC    PL4'0'
PCHCNT   DC    PL4'0'
IN1MOD   DC    1F'0'         * THESE WILL
IN2MOD   DC    1F'0'         *   CONTAIN THE
IN3MOD   DC    1F'0'         *     ADDRESS OF
OT1MOD   DC    1F'0'         *       THE I/O MODULE
OT2MOD   DC    1F'0'         *         AFTER LOAD
OT3MOD   DC    1F'0'         *
PRTMOD   DC    1F'0'         *
RDCDMOD  DC    1F'0'         *
         DS    0D
         DC    XL8'00'
CVDWORD  DC    XL8'00'
RTCD     DC    CL8'00000000' 1ST J= RETURN CODE / LAST 4 = WORKAREA
DATE6    DC    CL6'YYMMDD'
DATE9    DC    CL9'DD MMM YY'
DATE5    DC    CL5'YYDDD'
         DS    0D                                                     *
INXWK    DC    XL8'00'                                                *
INX1     DC    CL4'0000'                                             **
INX2     DC    CL4'0000'                                             **
IOMOD    DC    A(IORTNS)
AUGSUM   DS    CL9
ADDEND   DS    CL9
EXITSK   DC    S(USERR)
         DS    CL40
FCON     DC    XL2'FFFF'
CON2     DC    XL2'02'
ONE      DC    PL1'1'
FIELD8   DC    CL8' '
FIELD16  DC    CL16' '
RESULT   DC    CL30' '
         DS    0F
USERR    EQU   *              (EXIT EXECUTED WITHOUT ENTER)
         LA    R15,9(0,0)        SET RETURN CODE TO 09-EXIT W/O ENTER
         B     RETURN
RETURN   EQU   *              * RETURN
         L     R13,4(0,13)    *  CONTROL
         RETURN (14,12),T,RC=(15)
EOJRTN   EQU   *    THIS RTN SHOULD LOAD EOJ MODULE TO PRT TOTALS
         LOAD  EPLOC=EOJMOD       LOAD EOJ MOD  TO PRT TOTALS
         LR    R15,R0             LOAD 15 WITH EOJMOD EP LOCATION
         BALR  R14,R15            BR TO EOJ MOD
         PACK  CVDWORD,RTCD(4)     PACK RETURN CODE
         CVB   R15,CVDWORD         CONVERT RETURN CODE TO BINARY IN R15
         B     RETURN
EOJMOD   DC    CL8'RREOJMOT'
BADPARMS EQU   *  THIS RTN HANDLES BAD PARAMETERS = RETURNS WITH '900'
         LA    R15,8(0,0)        SET RETURN CODE TO 08-PARAMETER ERROR
         B     RETURN
* NOTE: USED FOR RRGENSRT LOGIC
         DS    0F
SRT4     DC    XL4'04'   SORT ENTRY POINT + 4  'RELEASE'
SRT8     DC    XL4'08'                    + 8  'SORT   '
SRT12    DC    XL4'0C'                    + 12 'RETURN '
SORTBR   L     R15,SRT8   LOAD SORT ENTRY POINT ADR + 8
         BR    R15        GO TO INPUT EXIT RTN
INPROC   B     *+0        TO BE FILLED IN WITH TAG ADR OF INPUT AND
OUTPROC  B     *+0         OUTPUT PROCEDURES BEFORE PASSING CONTROL
*                          TO USER . POINTED TO IN CALL LOGIC GENERATED
*                          FOR RRGENSRT
         EJECT
USERCODE DS    0D
         ORG
         EJECT
SELF     DS    CL1772
CARDID   DS    CL10
CARD     DS    CL80
PRTID    DS    CL11
PRTAREA  DS    CL133
PUNCHID  DS    CL10
PCHREC   DS    CL80
CONS     DC    8CL250' '
         EJECT
         DS    0D
OURCODE  DS    CL8192
         ORG   *-8192
         USING *,R6,R7,R2
         SAVE  (2,12),T,*
         LR    R6,15       SET BASE 12 TO OURCODE
HERE     L     R7,BR7
         LA    R9,TAGTAB
         L     R5,BR5
         L    R12,=A(SELF)
         ST    13,SYSAVE+4
         LA    13,SYSAVE
         MVC   CARDID(4),=CL4'CARD'
         MVC   PUNCHID(5),=CL5'PUNCH'
         MVC   PRTID(7),=CL7'PRINTER'
         MVI   PRTAREA-1,X'40'
         OPEN  (INCARD,INPUT,PRINTER,OUTPUT)
         BAL   R14,DATERTN
         MVC   DATE+6(9),DATEDMY   PUT SYS DATE IN TO HDR
         BAL   R14,PRTHDR
         B     RDPARM
BR5      DC    A(IORTNS)
BR7      DC    A(OURCODE+4096)
BR13     DC    A(SYSAVE)
         EJECT
MLRTN    EQU   *
ML01     CLI   CARD+23,C'-'             Q. A-ADR INDEXED
         BNE   ML02                       NO
         MVC   AXIND,CARD+24              YES-SAVE INDEX NUMBER
         MVC   CARD+23(9),CARD+25            -SHIFT TO ELIM DASH + INX
ML02     CLI   CARD+28,C'-'             O. B-ADR INDEXED
         BNE   ML03                       NO
         MVC   BXIND,CARD+29              YES-SAVE INDEX NUMBER
ML03     LA    R8,OPCODE+304   POINT 8 TO MIDPOINT OF TABLE
         LA    R5,0                     LOAD 5 WITH 0
         LA    R4,6            LOAD 4 WITH TALLY CT OF 6
ML04     CLC   CARD+6(5),0(R8)     Q. OPCODE = TABLE
         BE    ML08                       YES
         BCT   R4,ML05                 Q. NO-IS SEARCH FINI
ML04A    MVI   OPERR,C'E'                YES SET OPERATION ERR
         MVI   NOGOSW,C'1'               TURN ON NO GO SWITCH.
         B     PARPRT
ML05     BH    ML06                    Q. CARD OP > TABLE //YES ADD
         S     R8,OPADRS(R5)       //NO SUB FROM TABLE ADR
         B     ML07
ML06     A     R8,OPADRS(R5)
ML07     LA    R5,4(R5)                   BUMP REG 5 BY 4
         B     ML04                       GO COMPARE AGAIN
ML08     MVC   OP(2),10(R8)        MOVE OPCODE+MASK TO INST
         MVC   CONTROL(3),5(R8)    MOVE CONTROL INFO
         MVC   ADR1(4),12(R8)
         MVC   ML09+2(2),8(R8)     SETUP BRANCH TO APPRO OP CODE
ML09     B     ML09     *RTN & BRANCH TO IT
OPCODE   DS    0F
         DC    CL5'ADD  '          ADD
         DC    CL3'016'
         DC    S(SIZERTN)
         DC    XL2'FA00'
         DC    S(ADRRTN)
         DC    S(ADDRTN)
         DC    CL5'AP   '          AP
         DC    CL3'016'
         DC    S(SIZERTN2)
         DC    XL2'FA00'
         DC    S(ADRRTN)
         DC    S(APRTN)
         DC    CL8'CALL    '       CALL
         DC    S(CALLRTN)
         DC    XL2'0000'
         DS    CL4
         DC    CL5'COM  '          COM
         DC    CL3'256'
         DC    S(SIZERTN)
         DC    XL2'D500'
         DC    S(ADRRTN)
         DC    S(COMRTN)
         DC    CL5'CONS '          CONS
         DC    CL3'040'
         DC    S(SIZERTN)
         DC    XL2'0000'
         DC    S(AADRRTN)
         DC    S(CONSRTN)
         DC    CL5'CP   '          CP
         DC    CL3'016'
         DC    S(SIZERTN2)
         DC    XL2'F900'
         DC    S(ADRRTN)
         DC    S(CPRTN)
         DC    CL5'CVBZ'          CVBZ
         DC    CL3'016'
         DC    S(SIZERTN2)
         DC    XL2'FFFF'
         DC    S(ADRRTN)
         DC    S(CVBZNRTN)
         DC    CL5'CVZB'          CVZB
         DC    CL3'016'
         DC    S(SIZERTN2)
         DC    XL2'FFFF'
         DC    S(ADRRTN)
         DC    S(CVBINRTN)
         DC    CL5'DVD  '          DIVIDE
         DC    CL3'015'
         DC    S(SIZERTN2)
         DC    XL2'FFFF'
         DC    S(ADRRTN)
         DC    S(DVDRTN)
         DC    CL8'ENTER   '       ENTER
         DC    S(ENTRTN)
         DC    XL2'47F0'
         DS    CL4
         DC    CL8'EXIT    '       EXIT
         DC    S(EXRTN)
         DS    CL6
         DC    CL8'GE      '        GE
         DC    S(BRRTN)
         DC    XL2'4780'
         DS    CL4
         DC    CL8'GH      '        GH
         DC    S(BRRTN)
         DC    XL2'4720'
         DS    CL4
         DC    CL8'GL      '        GL
         DC    S(BRRTN)
         DC    XL2'4740'
         DS    CL4
         DC    CL8'GNE     '        GNE
         DC    S(BRRTN)
         DC    XL2'4770'
         DS    CL4
         DC    CL8'GO      '       GO
         DC    S(BRRTN)
         DC    XL2'47F0'
         DS    CL4
         DC    CL5'MOVE '          MOVE
         DC    CL3'900'
         DC    S(SIZERTN)
         DC    XL2'D200'
         DC    S(ADRRTN)
         DC    S(MOVERTN)
         DC    CL5'MPY  '          MULTIPLY
         DC    CL3'015'
         DC    S(SIZERTN2)
         DC    XL2'FFFF'
         DC    S(ADRRTN)
         DC    S(MPYRTN)
         DC    CL5'MVN  '          MVN
         DC    CL3'256'
         DC    S(SIZERTN)
         DC    XL2'D100'
         DC    S(ADRRTN)
         DC    S(MVNRTN)
         DC    CL5'MVO  '          MVO
         DC    CL3'016'
         DC    S(SIZERTN2)
         DC    XL2'F100'
         DC    S(ADRRTN)
         DC    S(MVORTN)
         DC    CL5'MVZ  '          MVZ
         DC    CL3'256'
         DC    S(SIZERTN)
         DC    XL2'D300'
         DC    S(ADRRTN)
         DC    S(MVZRTN)
         DC    CL5'NC   '          NC
         DC    CL3'256'
         DC    S(SIZERTN)
         DC    XL2'D400'
         DC    S(ADRRTN)
         DC    S(NCRTN)
         DC    CL5'OC   '          OC
         DC    CL3'256'
         DC    S(SIZERTN)
         DC    XL2'D600'
         DC    S(ADRRTN)
         DC    S(OCRTN)
         DC    CL5'PACK '          PACK
         DC    CL3'016'
         DC    S(SIZERTN2)
         DC    XL2'F200'
         DC    S(ADRRTN)
         DC    S(PACKRTN)
         DC    CL8'PRINT   '       PRINT
         DC    S(PRTRTN)
         DC    XL2'0000'
         DS    CL4
         DC    CL8'READ    '       READ
         DC    S(RDRTN)
         DC    XL2'0000'
         DS    CL4
         DC    CL5'SP   '          SP
         DC    CL3'016'
         DC    S(SIZERTN2)
         DC    XL2'FB00'
         DC    S(ADRRTN)
         DC    S(SPRTN)
         DC    CL5'SUB  '          SUB
         DC    CL3'016'
         DC    S(SIZERTN)
         DC    XL2'FB00'
         DC    S(ADRRTN)
         DC    S(SUBRTN)
         DC    CL8'TPM     '       TPM
         DC    S(TPMRTN)
         DC    XL2'4720'
         DS    CL4
         DC    CL5'TRANS'     TRANS
         DC    CL3'256'
         DC    S(SIZERTN)
         DC    XL2'DC00'
         DC    S(ADRRTN)
         DC    S(TRRTN)
         DC    CL8'TRZ     '       TRZ
         DC    S(BRRTN)
         DC    XL2'4780'
         DS    CL4
         DC    CL5'UNPK '          UNPK
         DC    CL3'016'
         DC    S(SIZERTN2)
         DC    XL2'F300'
         DC    S(ADRRTN)
         DC    S(UNPKRTN)
         DC    CL8'UTC     '       UTC
         DC    S(BRRTN)
         DC    XL2'47F0'
         DS    CL4
         DC    CL8'WRITE   '       WRITE
         DC    S(WRTRTN)
         DC    XL2'0000'
         DS    CL4
         DC    CL5'XC   '          XC
         DC    CL3'256'
         DC    S(SIZERTN)
         DC    XL2'D700'
         DC    S(ADRRTN)
         DC    S(XCRTN)
         DC    CL5'XCONS'          XCONS
         DC    CL3'020'
         DC    S(SIZERTN)
         DC    XL2'0000'
         DC    S(AADRRTN)
         DC    S(XCONSRTN)
         DC    3CL16'ZZZZZZZZZZZZZZZZ'
OPADRS   DS    0F            * THIS TABLE IS USED TO BINARY
         DC    XL4'A0'        * SEARCH THE OPCODE TABLE  * DECIMAL 160
         DC    XL4'50'        *                                     80
         DC    XL4'20'        *                                     32
         DC    XL4'10'        *                                     16
         DC    XL4'10'             *                         *DEC 16
         EJECT
IN1      DC    CL6'ITAPE1'
ADRA      DC   XL2'7000'     LHE ADR OF REC AREA
         DC    F'0'                     SIZE OF REC AREA
         DC    F'0'                     BLOCK FACTOR
         DC    F'0'                     BLOCK SIZE
         DS    CL20                     STORAGE FOR CARD COL 22 THRU 41
IN2      DC    CL6'ITAPE2'
ADRB      DC   XL2'8000'
         DS    CL32
IN3      DC    CL6'ITAPE3'
ADRC      DC   XL2'9000'
         DS    CL32
DK1      DC    CL6'DISK1 '
ADRD     DC    H'0'
         DS    CL32
DK2      DC    CL6'DISK2 '
ADRE     DC    H'0'
         DS    CL32
OUT1     DC    CL6'OTAPE1'
ADRJ     DC    XL2'B000'                0 + R 10
         DS    CL32
OUT2     DC    CL6'OTAPE2'
ADRK     DC    XL2'B384'      900 DECIMAL + R 10
         DS    CL32
OUT3     DC    CL6'OTAPE3'
ADRL     DC    XL2'B708'     1800 DECIMAL + R 10
         DS    CL32
         DS    0F                      *FORMAT AABBBBBB
AINXAR   DC    6XL4'FFFFFFFF'                                    ******
BINXAR   DC    6XL4'FFFFFFFF'                                    ******
INSHOLD  DS    0XL80                   * WHERE  A= SIZE OF INST-1
         DC    10XL8'FFFFFFFFFFFFFFFF' *        B= INSTRUCTION
XIND     DS    0CL2      INDEXING INDICATOR
AXIND    DC    XL1'00'   00=NO INDEXING ON A-ADR F1= INX1 F2=INX2 *****
BXIND    DC    XL1'00'   00=NO INDEXING ON B-ADR F1= INX1 F2=INX2 *****
**** INSTUCTION BUILD AREA
         DS    0F
SSINST   DS    0CL6      OP/L1L2/B1D1/B2D2 OR OP/LENGTH/B1D1/B2D2
RXINST   DS    0CL4      OP/M1X1/B1D1
OP       DS    CL1
LEN      DS    CL1       L1L1L2L2 OR LLLLLLLL OR MMMMXXXX
B1D1     DS    0CL2      BBBBDDDD/DDDDDDDD
B1       DS    CL1
D1       DS    CL1
B2D2     DS    0CL2      BBBBDDDD/DDDDDDDD
B2       DS    CL1
D2       DS    CL1
**                       EXECUTING THE GENERATED CODE. IF = 1 PROGRAM
LOCERR   DC    CL1' '   *ERROR FLAGS * SPACE=NO ERROR
OPERR    DC    CL1' '   *               E   =ERROR
SIZEERR  DC    CL1' '
ADRERR   DC    CL1' '
NOGOSW   DC    CL1'0'   * THIS SW IS SET IF AN ERROR IS FOUND IN A
**                       PARAMETER DURING GENERATION. IS CKED BEFORE
**                       IS ABORTED.
CONTROL  DS    0CL9
SZEDIT   DS    CL3       EDIT CRITERIA FOR SIZE RTN.
ADR1     DS    CL2
ADR2     DS    CL2
ISCON    DC    CL3'IS '
ISRCON   DC    CL3'ISR'
EOJCON   DC    CL3'EOJ'
ENDUSER  DC    A(USERBASE+8192)
CENDUSER DC    A(USERBASE+8192)
BDLIST   DC    XL2'6FFF'
         EJECT
         DS    0F
RDPARM   EQU   *
******** THIS  ROUTINE READS INPUT PARAMETERS.
         GET   INCARD,CARD
         CLI   CARD,C'T'    Q. IS THERE A TAG
         BNE   NOTAG     NO
         PUT   PRINTER,PRTAREA    YES SPACE 1 LINE
NOTAG    MVC   PRTAREA+18(80),CARD
         CLI   CARD,C'*'           Q. IS THIS A REMARK
         BNE   NOREMARK              NO
         PUT   PRINTER,PRTAREA+1        YES PRINT IT
         MVC   PRTAREA(133),PRTAREA-1   CLEAR REMARK OUT OF PRT AREA
         B     RDPARM                   GO READ NEXT RECORD
NOREMARK MVC   AXIND(2),=XL2'0000'  TURN INDEX IND OFF
IOSWITCH BC    15,IOCK01          * THIS INS NOP AFTER LAST IO PARM.
NONIO    CLC   CARD(4),=CL4'STOP'
         BE    PAREND
         CLC   CARD(4),=C'    '
         BE    MLRTN
         BAL   R14,TAGRTN
         B     MLRTN
IOCK01   MVI   IOSWITCH+1,X'00'
         L     R11,RECAR
         LH    R10,USERBD
         B     NONIO
RECAR    DC    A(USERCODE)
USERBD   DC    S(USERCODE)
         EJECT
PARPRT   EQU   *
*******  THIS ROUTINE PRINTS THE INPUT CARD AND THE MACHINE CODE ******
*** GENERATED FOR THE PARAMETER. THE MACHINE CODE AND ITS MACHINE *****
*** ADDRESS WILL BE PRINTED IN HEXIDECIMAL.                      ******
         MVI   PARM01C+1,X'00'   TURN OFF PRT BYPASS SW
         LA    R3,AINXAR                ***********************  ******
         CLC   AINXAR(2),FFCON        *SET UP INSTRUCTION HOLD*  ******
         BE    PARPRT01               * AREA FOR PARAMETER    *  ******
         CLC   BINXAR(2),FFCON        * PRINT ROUTINE.        *  ******
         BNE   PARPRTR                * INSTUCTIONS START AT  *  ******
         MVC   BINXAR(80),INSHOLD     *  INSHOLD IF NO INDEXES*  ******
         B     PARPRTR                *     IF INDEXING       *  ******
PARPRT01 LA    R3,BINXAR              *  INSTRUCTIONS WILL BE *  ******
         CLC   BINXAR(2),FFCON        *  IN AINXAR OR BINXAR  *  ******
         BNE   PARPRTR                  *      OR                 *****
         LA    R3,INSHOLD               *     BOTH                *****
PARPRTR  LA    R5,8(0)
         CLC   LOCERR(4),=CL4'    '
         BNE   PARMERR
         CLC   0(2,R3),FFCON
         BE    PARM02
PARM01   MVC   HEXHLD(6),FFCON
         ST    R11,HEXHLD         STORE ACTUAL INST ADR
         BAL   R14,HEXRTN         GO CONVERT TO HEX PRINT A=C1
         MVC   PRTAREA+111(6),CONVHEX+2      ACT ADR TO PRT LINE
         STH   R10,HEXHLD
         C     R11,ENDUSER      Q. OUT OF MEM FOR GEN USER INSTRUCTIONS
         BL    PARM01A                 NO
         LA    R15,10(0,0)     YES-SET RETURN CODE TO 10-OUT OF MEMORY
         LA    R5,USERBASE         LOAD R5 SO THE RETURN RTN CAN BE USE
         B     RETURN               GO TO RETURN
PARM01A  MVC   0(6,R11),2(R3)      MOVE INST TO USERCODE
         LA    R8,1(0)
         MVI   0(R3),X'00'
         AH    R8,0(R3)
         AR    R10,R8
PARM01B  AR    R11,R8
         BAL   R14,HEXRTN
         MVC   PRTAREA+103(4),CONVHEX
PARM01C  NOP   PARM02A    BYPASS PRINTING EXCEPT 1ST LINE
PARM02   PUT   PRINTER,PRTAREA+1
         MVI   PARM01C+1,X'F0'  TURN ON SW
PARM02A  MVC   PRTAREA(133),PRTAREA-1
         MVC   0(2,R3),FFCON
         AR    R3,R5
         CLC   0(2,R3),FFCON
         BNE   PARM01
         B     RDPARM
PARMERR  MVI   NOGOSW,C'1'
         CLC   LOCERR(1),=C'E'
         BE    ERR01
         CLC   OPERR(1),=C'E'
         BE    ERR02
         CLC   SIZEERR(1),=C'E'
         BE    ERR03
         MVC   PRTAREA+1(13),=CL13'ADDRESS ERROR'
ERREXIT  MVC   LOCERR(4),=C'    '
         MVI   AINXAR,X'FF'                                      ******
         MVC   AINXAR+1(127),AINXAR                              ******
         B     PARM02
ERR01    MVC   PRTAREA+1(14),=CL14'LOCATION ERROR'
         B     ERREXIT
ERR02    MVC   PRTAREA+1(15),=CL15'OPERATION ERROR'
         B     ERREXIT
ERR03    MVC   PRTAREA+1(10),=CL10'SIZE ERROR'
         B     ERREXIT
         EJECT
BXRTN    EQU   *                                                 ******
*******  THIS  ROUTINE ALTERS THE CODE THAT ALLOWS INDEXING FOR  ******
**@****  ADDRESS AT B1D1. THE CODE TO PACK THE INDEX FIELD,       *****
*******  CONVERT INDEX TO BINARY AND ADD THE INDEX TO THE BASE   ******
*******  IS PLACED IN LINE. R3= B ADDR IND REG,R2='A'ADDR INX.   ******
         XR    R4,R4         *CLEAR REG 4.                       ******
         IC    R4,B1D1       *GET REAL BASE REG.                 ******
         SRL   R4,4(0)       *MOVE BASE REG TO LOW DIGIT OF R4.   *****
         MVZ   B1D1(1),=X'30'                                        **
         STC   R4,INSTIX3+3  *BASE REG TO ADD REG INS.            *****
         MVZ   INSTIX3+3(1),=X'30' *B INDEX REG   TO ADD REG INS.******
         MVZ   INSTIX2+3(1),=X'30' *B INDEX REG TO CVB INS.      ******
         CLI   BXIND,X'F1'   *'B' ADDR NEED INX1 2               ******
         BNE   BXRTN02        NO                                 ******
ABXCOM   MVC   BINXAR(8),INSTIX1  * PACK INX1 INS TO HOLD AREA.  ******
BXRTN01  MVC   BINXAR+8(6),INSTIX2 * CVB INS TO HOLD AREA.       ******
         MVC   BINXAR+16(4),INSTIX3 * AR INS TO HOLD AREA.        *****
         BR    R14                    RETURN                     ******
BXRTN02  MVC   BINXAR(8),INSTIX4   * PACK INX2 INS TO HOLD AREA. ******
         CLI   BXIND,X'F2'        *B ADR NEED IN2                ******
         BE    BXRTN01                                           ******
         MVI   ADRERR,C'E'                                        *****
         B     PARPRT                                            ******
AXRTN    EQU   *                                                  *****
***  THIS RTN INDEXES THE ADDRESS AT B2D2.                        *****
         XR    R4,R4         * CLEAR REG 4                        *****
         IC    R4,B2D2       * GET REAL BASE                      *****
         SRL   R4,4(0)       * BASE REG TO LOW DIGIT OF R4.       *****
         STC   R4,INSTIX3+3  * BASE REG TO AR INS.                *****
         MVZ   B2D2(1),=X'20'                                        **
         MVZ   INSTIX3+3(1),=X'20' 'A' INX REG TO AR INS.         *****
         MVZ   INSTIX2+3(1),=X'20' 'A' INX REG TO CVB INS.        *****
         CLI   AXIND,X'F1'        *'A' ADDR NEED INX1.?           *****
         BNE   AXRTN02                                            *****
         MVC   AINXAR(8),INSTIX1   * PK INX1 INS TO HOLD AREA.    *****
AXRTN01  MVC   AINXAR+8(6),INSTIX2  * CVB INS TO HOLD AREA.       *****
         MVC   AINXAR+16(4),INSTIX3  * AR INS TO HOLD AREA.       *****
         BR    R14                                                *****
AXRTN02  MVC   AINXAR(8),INSTIX4      * PK INX2 INS TO HOLD AREA. *****
         CLI   AXIND,X'F2'                                        *****
         BE    AXRTN01                                            *****
         MVI   ADRERR,C'E'                                        *****
         B     PARPRT                                             *****
INSTIX1  DC    XL2'05'                                            *****
         PACK  INXWK(8),INX1(4)                                   *****
INSTIX2  DC    XL2'03'                                            *****
         CVB   R2,INXWK                                           *****
INSTIX3  DC    XL2'01'                                            *****
         AR    R2,R3                                              *****
INSTIX4  DC    XL2'05'                                            *****
         PACK  INXWK(8),INX2(4)                                   *****
         EJECT
PRTHDR   EQU   *
******* THIS ROUTINE PRINTS THE HEADER AND RESTORES THE LINE COUNT.****
         ST    R14,HDRSAVE
         MVC   PRTAREA(133),PRTAREA-1
         MVI   PRTAREA,X'89'
         PUT   PRINTER,PRTAREA+1
         MVC   PRTAREA+1(132),HEADER1
         MVI   PRTAREA,X'09'
         PUT   PRINTER,PRTAREA+1
         MVC   PRTAREA+1(132),HEADER2
         MVI   PRTAREA,X'19'
         PUT   PRINTER,PRTAREA+1
         MVC   PRTAREA(133),PRTAREA-1
         MVI   LINECT,X'3E'
         PUT   PRINTER,PRTAREA+1         SPACE ATER HDRS
         L     R14,HDRSAVE
         BR    R14
HDRSAVE  DS    F'0'
         DS    0F
PKONE    DC    PL2'1'
PAGECT   DC    PL2'+0'
HEADER1  DS    0CL132
DATE     DC    CL20'DATE                '
         DC    CL31'360 GENERATOR PARAMETER LISTING'
         DC    CL53' '
         DC    CL10'ADDRESS   '
         DC    CL18' '
HEADER2  DS    0CL132
         DC    CL17'ERROR FLAGS     /'
         DC    CL29'LOC    OP    SIZE   ADDRESS  '
         DC    CL32'      CONSTANTS OR REMARKS      '
         DC    CL33'                     BASE/DISP   '
         DC    CL21'ACTUAL               '
LINECT   DS    CL1
         DS    0F
         EJECT
HEXRTN   EQU   *
**** THIS ROUTINE CONVERTS THE SIX BYTE FIELD AT HEXHLD. ONE BYTE *****
***** AT HEXHLD IS CONVERTED TO ITS TWO BYTE HEX EQUIVILANT FOR   *****
*****  PRINTING. ('A' AT HEXHLD =  'C1' AT CONVHEX. CNVCNT IS     *****
***** USED TO BUMP THE ADDRESS COUNTERS (R10 AND R11) AFTER INS   *****
*****  IS MOVED TO USER AREA.                                     *****
         UNPK  CONVHEX(13),HEXHLD(7)    UNPACK HEXHLD
         CLC   CONVHEX+8(4),FFCON      Q. DATA = 6 POS9
         BNE   HEX01                    A.YES
         CLC   CONVHEX+4(4),FFCON      Q. DATA = 4 POS
         BNE   HEX02                    A.YES
         MVI   CNVCNT,X'03'
         B     HEX03
HEX01    MVI   CNVCNT,X'0B'
         B     HEX03
HEX02    MVI   CNVCNT,X'07'
HEX03    TR    CONVHEX(12),HEXTAB       CONVERT TO HEX FOR PRINT.
         MVC   HEXHLD(6),FFCON               CLEAR HEXHOLD
         BR    R14
         DS    0F
HEXHLD   DC    XL7'FFFFFFFFFFFF04'
         DC    CL1' '
CONVHEX  DC    XL12'00'
CNVCNT   DC    XL1'00'
PACK1    DC    PL2'1'
PAGECNT  DC    PL2'0'
LINECNT  DC    H'56'
         EJECT
BRRTN    EQU   *
**** THIS ROUTINE HANDLES GENERATION OF TAG ADDRESSES FOR BRANCH ******
***** INSTRUCTIONS. THIS ROUTINE PLACES A '2' IN REG5 FOR TGRTN. ******
         LA    R4,2(0)
         BAL   R14,TGRTN
         MVC   INSHOLD+2(4),RXINST
         MVI   INSHOLD+1,X'03'
         B     PARPRT
         EJECT
TPMRTN   EQU   *
**** THIS RTN HANDLES GENERATION OF A&B ADRS FOR TPM INST. THIS  ******
***** RTN GENERATES TWO INST.(BH&BL),PLACES A'2'IN R4 IF'A'ADR OF******
***** TPM AND A'6'IN R4 IF'B'ADR OF TPM.                         ******
         LA    R4,2(0)
         BAL   R14,TGRTN
         MVI   INSHOLD+1,X'03'
         MVC   INSHOLD+2(4),RXINST
         LA    R4,6(0)
         MVC   0(4,R11),INSHOLD+2      * MOVE 1 BR IN LINE
         MVC   OP(2),=XL2'4740'
         MVC   CARD+19(4),CARD+24
         BAL   R14,TGRTN
         MVI   INSHOLD+9,X'03'
         MVC   INSHOLD+10(4),RXINST
         MVC   INSHOLD+2(4),0(R11) * MOVE IT BACK / TGRTN MAY CHG IT
         B     PARPRT
         EJECT
SIZERTN  EQU   *
**** THIS ROUTINE VALIDATES SIZE ENTRY ACCORDING TO CONTROL INFO.******
***** THE SIZE IS PASSED TO CONVERSION RTN RIGHT JUSTIFIED IN    ******
****** SIZEWK.                                                   ******
         MVC   SIZEWK,SZZERO
         CLC   CARD+13(1),=C' '        Q. SIZE 1 POS.
         BE    SZ01                     A.YES
         CLC   CARD+14(1),=C' '        Q. SIZE 2 POS
         BE    SZ02                     A.YES
         CLC   CARD+15(1),=C' '        Q. SIZE TOO BIG
         BNE   SZERR                    A.YES
         MVC   SIZEWK+1(3),CARD+12      MOVE 3 POS SIZE TO SIZEWK.
         B     SZ03
SZ01     MVC   SIZEWK+3(1),CARD+12      MOVE 1 POS SIZE TO SIZEWK.
         B     SZ03
SZ02     MVC   SIZEWK+2(2),CARD+12      MOVE 2  POS SIZE TO SIZEWK.
SZ03     CLC   SZEDIT(3),SIZEWK+1      Q. SIZE GREATER THAN MAX.
         BL    SZERR                    A.YES
         BAL   R14,CNVRTN               PERFORM CONVERSION RTN.
         C     R3,FFCON                Q. CONVERSION GOOD.
         BE    SZERR                    A.NO
         C     R3,ZERO                 Q. SIZE = ZERO.
         BE    SZERR                    A.YES
         BCTR  R3,0                     DECREMENT SIZE BY 1.
         ST    R3,SIZEHLD               HOLD IN SIZE HOLD.
         MVC   SZEXIT+2(2),ADR1         MOVE NEXT RTN ADR TO BR.
SZEXIT   B     SZEXIT                   BRANCH TO NEXT RTN.
SZERR    MVI   SIZEERR,C'E'             SET SIZE ERROR FLAG.
         MVI   NOGOSW,C'1'
         B     PARPRT                   GO PRT PARMETER.
         DS    0D
SIZWK    DC    CL4'0000'
SIZEWK   DC    CL4'0000'
FFCON    DC    XL8'FFFFFFFFFFFFFFFF'
SIZEHLD  DC    XL4'00'
SZZERO   DC    CL4'0000'
         EJECT
SIZERTN2 EQU   *
* THIS RTN HANDLES INST WITH  TWO SIZE ENTRIES  EG 4,6
         DS    0F
         MVC   HOLDSZ,CARD+12      SAVE SIZE FIELD
         MVC   SZ2RTNEX+2(2),ADR1  SAVE ADR OF WHERE SIZE RTN GOES NEXT
         MVC   ADR1,SZRETRN1       MAKE SIZE RTN COME BACK AFTER 1ST
         MVI   CARD+12,X'40'       * CLEAR
         MVC   CARD+13(5),CARD+12  *  SIZE FIELD
         CLI   HOLDSZ+1,C','       Q. 1 POS SIZE
         BNE   SZ2RTN9        NO
         MVC   CARD+12(1),HOLDSZ       YES- MOVE 1 POS SIZE BK TO CARD
         MVC   HOLDSZ2(3),HOLDSZ+2      SAVE SECOND SIZE
         B     SIZERTN                  PERFORM SIZE RTN
SZ2RTN3  MVC   HLDSZRS,SIZEHLD          SAVE SIZE FROM SIZE RTN
         MVC   ADR1,SZRETRN2            CHG RETURN IN SIZE RTN
         MVC   CARD+12(3),HOLDSZ2       MOVE SECOND SIZE TO SIZE FIELD
         B     SIZERTN        GO CONVERT SECOND SIZE
SZ2RTN6  SLA   R3,4(0)                  MOVE RESULTS TO TOP OF BYTE
         ST    R3,SIZEHLD               STORE SHIFTED RESULTS
         OC    SIZEHLD+3(1),HLDSZRS+3   PUT SIZES TOGETHER
SZ2RTNEX B     *+0
SZ2RTN9  CLI   HOLDSZ+2,C','     Q. 2 POS SIZE
         BNE   SZERR                 NO-SIZE ERROR
         MVC   CARD+12(2),HOLDSZ     MOVE 2 POS SIZE TO SIZE FIELD
         MVC   HOLDSZ2(3),HOLDSZ+3   SAVE 2ND SIZE
         B     SIZERTN               PERFORM SIZE RTN/RETURN TO SZ2RTN3
SZRETRN1 DC    S(SZ2RTN3)
SZRETRN2 DC    S(SZ2RTN6)
HOLDSZ   DS    CL6
HLDSZRS  DS    1F
HOLDSZ2  DC    CL6'      '
         DS    0F
         EJECT
ADRRTN   MVC   ADRWK,CARD+24            MOVE B-ADR TO WORK AREA
         BAL   R14,ADR01                PERFORM ADR CONVERSION
         STH   R4,B1D1
         CLI   BXIND,X'00'                                           **
         BE    *+8                                                   **
         BAL   R14,BXRTN                                             **
AADRRTN  MVC   ADRWK,CARD+19            MOVE A-ADR TO WORK AREA
         BAL   R14,ADR01                PERFORM ADR CONVERSION
         STH   R4,B2D2
         CLI   AXIND,X'00'                                           **
         BE    *+8                                                   **
         BAL   R14,AXRTN                                             **
         MVC   ADRRTNX+2(2),ADR2        SET UP TO BR TO INST GEN RTN
         L     R2,OUR8192 LOAD BASE FOR I/O IN CASE THEY USE ADRRTN
ADRRTNX  B     ADRRTNX                  BRANCH TO APPRO RTN
ADR01    ST    R14,ADRSV                SAVE RETURN ADR
         CLC   ADRWK(2),=C'CD'       Q. ADDRESS CD
         BNE   ADR05                     NO
         LH    R4,ADRCD                  YES-LOAD REG 4 WITH CD ADDRESS
ADR03    MVC   SIZEWK+2(2),ADRWK+2       MOVE RELATIVE ADR TO SIZE WK
         BAL   R14,CNVRTN
         C     R3,FFCON              Q. WAS ADR VALID
         BE    ADR27                    NO
         CLC   ADRWK+2(2),=C'80'     Q. YES-IS RELATIVE > 80
         BH    ADR27                    YES- INVALID
ADR04    N     R4,=X'0000FFFF'
         AR    R4,R3                    NO - ADD RELATIVE ADR TO LHE
         B     ADR0X                    GO EXIT RTN
ADR05    CLI   ADRWK,C'P'            Q. ADR  P OR PC
         BNE   ADR09                    NO- GO CK FOR OTHER ADRS
         CLI   ADRWK+1,C'C'          Q. YES - IS IT PC
         BNE   ADR07                    NO- MUST BE PRINT
         LH    R4,ADRPC                 YES- LOAD REG 4 WITH PUNCH ADR
         B     ADR03                    GO VALIDATE
ADR07    LH    R4,ADRPT                 LOAD REG 4 WITH PRINT ADR
         MVC   SIZEWK+1(3),ADRWK+1      MOVE RELATIVE ADR TO SIZE WORK
         BAL   R14,CNVRTN                VALIDATE AND CONVERT TO BINARY
         C     R3,FFCON         Q. WAS ADR VALID
         BE    ADR27               NO-
         CLC   ADRWK+1(3),=C'132' Q. IS RELATIVE > 132
         BH    ADR27                 YES- INVALID
         B     ADR04                 NO-VALID-PREPARE TO EXIT
ADR09    CLC   ADRWK,=C'SELF'     Q. IS IT SELF ADR
         BNE   ADR11                 NO
         BAL   R14,SELF01            YES-PEFORM SELF RTN
         B     ADR0X                 GO EXIT RTN
ADR11    CLC   ADRWK,=C'DATE'     Q. IS IT DATE ADR
         BNE   ADR13                 NO
         CLI   CARD+12,C'9'        Q. WANT DD MMM YY
         BNE   ADR11A                 NO
         LH    R4,DATEAL9             YES- LOAD IT'S ADR
         B     ADR0X
ADR11A   CLI   CARD+12,C'5'        Q. WANT YYDDD
         BNE   ADR11B                 NO - ASSUME HE WANTS YYMMDD
         LH    R4,DATEJU5             YES- LOAD IT'S ADR
         B     ADR0X
ADR11B   LH    R4,DATENU6             LOAD ADR OF  YYMMDD
         B     ADR0X                 GO EXIT RTN
ADR13    CLI   ADRWK,C'2'      Q. IS IT THE WORK AREA ADR (2000-5999)
         BL    ADR13A             NO- CK CONS
         LH    R4,ADRWORK            YES-LOAD ADR OF WORK
         MVC   SIZEWK,ADRWK       MOVE REL ADR TO SIZE WORK
         BAL   R14,CNVRTN         VALIDATE & CONVERT TO BINARY
         C     R3,FFCON        Q. WAS IT VALID
         BE    ADR27              NO
         CLC   ADRWK,=C'5999'     Q. UNDER 5999
         BH    ADR27              NO-INVALID
         L     R2,BIN2000        * MAKE RELATIVE TO *
         SR    R3,R2                 * ZERO *
         B     ADR04              YES-VALID PREPARE TO EXIT
ADR13A   CLI   ADRWK,C'0'      Q. IS IT THE CONS AREA ADR (0000-1999)
         BL    ADR15                 NO-CK RECORD AREA
         LH    R4,ADRCON             YES- LOAD ADR OF CONS
         MVC   SIZEWK,ADRWK          MOVE RELATIVE ADR TO SIZE WORK
         BAL   R14,CNVRTN             VALIDATE AND CONVERT TO BINARY
         C     R3,FFCON     Q. WAS ADR VALID
         BE    ADR27             NO
         CLC   ADRWK,=C'1999'     Q. ADR UNDER 2000
         BH    ADR27                 NO-INVALID
         B     ADR04                 YES-VALID-PREPARE TO EXIT
ADR15    CLI   ADRWK,C'A'            Q. INP1 REC AREA (A)
         BL    ADR27                    NO < A = INVALID
         BE    ADR17                    YES-PUT IN ADDR OF A
ADR15A   CLI   ADRWK,C'E'            Q. DSK2 REC AREA (E)
         BH    ADR21                    NO-GO CK FOR J,K + L
         BE    ADR18                    YES-PUT IN ADR OF E
         CLI   ADRWK,C'C'            Q. INP3 REC AREA (C)
         BH    ADR19                    > MEANS IT MUST BE (E)
         BL    ADR20                    < MEANS IT MUST BE (B)
         LH    R4,ADRC                  LOAD REG 4 WITH C ADR
         B     ADR24                    GO VALIDATE LENGTH
ADR17    LH    R4,ADRA                  LOAD REG 4 WITH A ADR
         B     ADR24                    GO VALIDATE LENGTH
ADR18    LH    R4,ADRD                                  D
         B     ADR24                    GO VALIDATE LENGTH
ADR19    LH    R4,ADRE                                  E
         B     ADR24                    GO VALIDATE LENGTH
ADR20    LH    R4,ADRB                                  B
         B     ADR24                    GO VALIDATE LENGTH
ADR21    CLI   ADRWK,C'J'            Q. OUT1 REC AREA (J)
         BL    ADR28                                                 **
         BE    ADR23                    YES-PUT IN ADR OF (J)
         CLI   ADRWK,C'L'            Q. OUT3 REC AREA (L)
         BH    ADR31         > CK TO SEE IF RTCD OR RSXX(RESULTOF X//)
         BE    ADR23A                   YES-PUT IN ADR OF (L)
         LH    R4,ADRK                  LOAD REG 4 WITH K ADR
         B     ADR24                    GO VALIDATE LENGTH
ADR23    LH    R4,ADRJ                  LOAD REG 4 WITH J ADR
         B     ADR24                    GO VALIDATE LENGTH
ADR23A   LH    R4,ADRL                  LOA REG  4 WITH L ADR
ADR24    CLC   ADRWK+1(3),=C'899'    Q. IS LENGTH VALID (MAX REC 900)
         BH    ADR27                    NO-INVALID
         MVC   SIZEWK+1(3),ADRWK+1      MOVE RELATIVE ADR TO WORK
         BAL   R14,CNVRTN               VALIDATE AND CONVERT TO BINARY
         C     R3,FFCON              Q. WAS ADR VALID
         BE    ADR27                    NO
         B     ADR04                    YES-GO ADD REL ADR TO LHE ADR
ADR27    MVI   ADRERR,C'E'              FLAG ADR ERROR
         MVI   NOGOSW,C'1'              FLAG NO GO SWITCH (ABORT EXEC)
ADR0X    L     R14,ADRSV                LOAD RETURN ADR
         BR    R14                      BRANCH BACK
ADR28    CLC   ADRWK(3),=CL3'INX'       ADDR = INDEX                 **
         BNE   ADR27                     ERROR                       **
         CLC   CARD+12(2),=C'4 '     Q. SIZE = 4                    ***
         BNE   SZERR                     ERROR                       **
         CLI   ADRWK+3,C'1'             INDEX = 1                    **
         BNE   ADR30                     NO                          **
         LH    R4,INDEX1                GET ADDR OF INDEX1           **
ADR29    N     R4,=X'0000FFFF'          CLEAR HIGH HALFWORD IN R4.   **
         B     ADR0X                                                 **
ADR30    CLI   ADRWK+3,C'2'             INDEX = 2                    **
         BNE   ADR27                     NO,ERROR                    **
         LH    R4,INDEX2                GET ADR OF INDEX2.           **
         B     ADR29                                                 **
ADR31    CLC   ADRWK,CRTCD    Q.  RETURN CODE
         BNE   ADR32               NO-SEE IF RSXX(RESULT OF X OR /)
         CLC   CARD+12(2),SP4  Q.  SIZE = 4
         BNE   SZERR             NO
         LH    R4,ACRTCD       LOAD R4 WITH B/D ADR OF RETURN CODE
         B     ADR29
ADR32    CLC   ADRWK(2),CRS        Q-RSXX(RESULT OF MULTIPLY/DISVDE)
         BNE   ADR27               A-NO
         LH    R4,ARESULT          A-YES/LOAD R4 W/ LHE ADDRESS OF RS
         MVC   SIZEWK+2(2),ADRWK+2      MOVE RELATIVE ADDR OF SIZE WK
         BAL   R14,CNVRTN               GO CONVERT TO BINARY NR
         C     R3,FFCON            Q-WAS ADDR VALID
         BE    ADR27               A-NO
         CLC   ADRWK+2(2),=C'29'   A-YES/BUT IS IT > 29
         BH    ADR27               A/YES/INVALID ADDR
         B     ADR04               A-NO/VALID ADDR (RS00-RS29)
INDEX1   DC    S(INX1)                                               **
INDEX2   DC    S(INX2)                                               **
ADRCD    DC    S(CARD)
ADRPC    DC    S(PCHREC)
ADRPT    DC    S(PRTAREA+1)
ADRDT    DC    S(DATE)
ADRCON   DC    S(CONS)
ADRWORK  DC    XL2'A000'
ADRWK    DS    CL4
ADRSV    DS    F
BIN2000  DC    XL4'000007D0'
DATENU6  DC    S(DATE6)
DATEAL9  DC    S(DATE9)
DATEJU5  DC    S(DATE5)
CRTCD    DC    CL4'RTCD'
SP4      DC    CL2'4 '
ACRTCD   DC    S(RTCD)
CRS      DC    C'RS'
ARESULT  DC    S(RESULT)
SORTTAGS DC    CL9'0'
         DS    0F
         EJECT
ADDRTN   MVC   ADDGEN+18(1),OP
SUBRTN   EQU   ADDRTN
         MVI   ADDGEN+3,X'80'    * INIT
         MVI   ADDGEN+11,X'80'   *   LENGTH
         MVI   ADDGEN+39,X'08'    *       FIELDS
         MVC   ADDGEN+6(2),B1D1
         MVC   ADDGEN+14(2),B2D2
         MVC   ADDGEN+40(2),B1D1
         OC    ADDGEN+3(1),SIZEHLD+3
         OC    ADDGEN+11(1),SIZEHLD+3
         MVO   SIZEHLD+1(1),SIZEHLD+3(1)
         OC    ADDGEN+39(1),SIZEHLD+1
         LR    R4,R10
         AH    R4,=H'26'
         STH   R4,ADDGEN+28
         MVC   INSHOLD(8),INSTA1
         MVC   INSHOLD+8(8),INSTA2
         MVC   INSHOLD+16(8),INSTA3
         MVC   INSHOLD+24(6),INSTA4
         MVC   INSHOLD+32(6),INSTA5
         MVC   INSHOLD+40(8),INSTA6
         B     PARPRT
ADDGEN   DS    0CL44
INSTA1   DC    XL2'05'
         PACK  AUGSUM,B2D2(1)           B-ADR = B-ADR OF ADD OR SUB
INSTA2   DC    XL2'05'
         PACK  ADDEND,B1D1(1)           B-ADR = A-ADR OF ADD OR SUB
INSTA3   DC    XL2'05'
         AP    AUGSUM,ADDEND            AP OR SP
INSTA4   DC    XL2'03'
         BM    *+8                      BRANCH ADR MUST BE FILLED IN
INSTA5   DC    XL2'03'
         OI    AUGSUM+8,X'0F'           THIS CHGS C TO F ON POSITIVE
INSTA6   DC    XL2'05'
         UNPK  B2D2(1),AUGSUM
         EJECT
APRTN    EQU   *
CPRTN    EQU   *
MVORTN   EQU   *
SPRTN    EQU   *
*  THIS WILL MAKE SIZES COMPAT WITH ADDRESS  EG. 'B-ADR TO A-ADR
         L     R3,SIZEHLD        LOAD SIZE INTO R3
         NI    SIZEHLD+3,X'0F'  REMOVE HIGH ORDER SIZE IN SHIEHLD
         SRA   R3,4(0)           SHIFT TO REMOVE LOW ORDER SIZE IN R3
         L     R4,SIZEHLD         LOAD SIZE INTO R4
         SLA   R4,4(0)             MOVE SIZE TO HIGH ORDER BITS-
         OR    R3,R4            PUT SIZES TOGETHER
         ST    R3,SIZEHLD        STORE REVERSED SIZE
MVNRTN   EQU   *
MVZRTN   EQU   *
NCRTN    EQU   *
XCRTN    EQU   *
OCRTN    EQU   *
TRRTN    EQU   *
COMRTN   EQU   *
**** THIS ROUTINE PUTS LENGTH INTO COMPARE INSTRUCTION.          ******
         MVC   LEN(1),SIZEHLD+3
         LH    R2,B1D1           *REVERSE
         MVC   B1D1,B2D2         * ADDRESS ON COM INST
         STH   R2,B2D2           * (ADR-RTN PUTS A IN B2D2 & B IN B1D1
         MVC   INSHOLD+2(6),SSINST
         MVI   INSHOLD+1,X'05'
         B     PARPRT
         EJECT
CONSRTN  EQU   *
**** THIS RTN PLACE CONSTANT FROM CONS PARAMETER INTO PROGRAM    ******
*****  CONSTANT AREA.                                            ******
         CLI   CARD+19,X'F0'        Q ADR IN CON AREA
         BL    MVERR                     NO-BELOW-INVALID
         CLI   CARD+19,X'F2'   Q. ADR OUTSIDE CON AREA (1999)
         BNL   MVERR              YES-INVALID
         MVC   CONS01+1(1),SIZEHLD+3    MOVE SIZE TO MOVE INS.
         MVC   CONS01+2(2),B2D2
CONS01   MVC   CONS01,CARD+33           MOVE CONSTANT TO MEMORY.
         MVC   CONS02+2(2),B2D2  PUT BASE DISP ADR IN LOAD ADR INST
CONS02   LA    R5,CONS02         LOAD R5 WITH ACTUAL ADR OF CON ADR
         ST    R5,HEXHLD         STOR CON ADR
         BAL   R14,HEXRTN        GO HAVE HEX RTN CONVERT IT TO ZONE
         MVC   PRTAREA+111(6),CONVHEX+2   PUT ACTUAL CON ADR IN PRTAREA
         B     PARPRT
B1D1LHE  DC    XL2'682F'      LHE CONS AREA / BASE DISPLACEMENT FORMAT
         EJECT
ENTRTN   EQU   *
****  THIS RTN GENERATES ENTER CODING. (I HOPE)                  ******
         XR    R4,R4
         IC    R4,=X'16'
         BAL   R14,TGRTN                PERFORM TAG ROUTINE
         MVC   INSTE5+4(2),B1D1
         XR    R4,R4                                 ,
         IC    R4,=X'18'
         AR    R4,R10                   R4 POINTS TO NEXT.
         STH   R4,INSTE4+6
         XR    R5,R5                                 ,
         IC    R5,=X'02'                             ,
         AR    R4,R5                    R4 POINTS TO NEXT USER INSR.
         STH   R4,NEXT+2                STORE USER RETURN ADDR IN LINE
         MVC   INSHOLD(6),INSTE1        *
         MVC   INSHOLD+8(8),INSTE2      * MOVE GENERATE INST. TO HOLD .
         MVC   INSHOLD+16(6),INSTE3     *
         MVC   INSHOLD+24(8),INSTE4
         MVC   INSHOLD+32(6),INSTE5
         MVC   INSHOLD+40(4),NEXT
         B     PARPRT
***** ENTER ROUTINE TO BE TAILORED AND PLACED IN USER CODE.      ******
         DS    0F
INSTE1   DC    XL2'03'                  COUNT FIELD.
         AH    R4,CON2        BUMP REG4 TO NEXT STACK POSITION.
INSTE2   DC    XL2'05'
         CLC   0(2,R4),FCON
INSTE3   DC    XL2'03'
         BE    USERR
INSTE4   DC    XL2'05'
         MVC   0(2,R4),NEXT
INSTE5   DC    XL2'03'
         B     ENTRTN
NEXT     DC    XL4'00010000'            1ST 2 BYTES=COUNT,2ND 2=RETURN
         EJECT
EXRTN    EQU   *
****** THIS RTN GENERATES EXIT CODING. (I HOPE)                  ******
         XR    R4,R4
         IC    R4,=X'0C'
         AR    R4,R10                   R4 POINTS TO GEN. BRANCH INST.
         STH   R4,INSTX1+4              MOVE BRANCH ADDR TO MOVE INST.
         MVC   INSHOLD(8),INSTX1        *
         MVC   INSHOLD+8(6),INSTX2      *MOVE GEN INST. TO HOLD AREA.
         MVC   INSHOLD+16(6),INSTX3     *
         B     PARPRT
**** EXIT ROUTINE TO BE TAILORED AND PLACED IN USER CODE.        ******
         DS    0F
INSTX1   DC    XL2'05'                  COUNT FIELD
         MVC   *+12(2),0(R4)  MOVE ADDR FROM RETURN STACK TO BRANCH.
INSTX2   DC    XL2'03'
         SH    R4,CON2        ADJ R4 TO NEXT RETURN ADD.
INSTX3   DC    XL2'03'
         B     EXRTN                    BRANCH TO STACK ADR .
         EJECT
MOVERTN  EQU   *
**** THIS GENERATES MULTIPLE MOVE INSTRUCTIONS IF THE SIZE OF THE******
***** IS GREATER THAN 256. IF GENERATED DISPLACEMENT EXCEEDS BASE******
****** REG LIMITS(4096) AN ADDRESS ERROR OCCURS.                 ******
         LA    R8,INSHOLD
         LH    R9,=H'8'
         L     R3,SIZEHLD
         LH    R4,=H'256'
         MVZ   BASE1(1),B1D1
         MVZ   BASE2(1),B2D2
         MVC   AHLD+2(2),B1D1
         MVC   BHLD+2(2),B2D2
MV01     CR    R3,R4
         BL    MV02
         MVI   LEN,X'FF'
         SR    R3,R4
         MVC   0(2,R8),=XL2'05'
         MVC   B1D1(2),AHLD+2
         MVC   B2D2(2),BHLD+2
         MVC   2(6,R8),SSINST
         AR    R8,R9
         L     R2,AHLD
         AR    R2,R4
         ST    R2,AHLD
         L     R2,BHLD
         AR    R2,R4
         ST    R2,BHLD
         B     MV01
MV02     STC   R3,LEN
         MVC   B1D1(2),AHLD+2
         MVC   B2D2(2),BHLD+2
         MVC   0(2,R8),=XL2'05'
         MVC   2(6,R8),SSINST
         B     PARPRT
MVERR    MVI   ADRERR,C'E'
         MVI   NOGOSW,C'1'
         B     PARPRT
         DS    0F
AHLD     DC    F'0'
BHLD     DC    F'0'
BASE1    DC    XL1'0F'
BASE2    DC    XL1'0F'
         EJECT
TAGRTN   EQU   *
**** THIS RTN DEFINES TAG ADDRESSES. IF TAG HAS BEEN REFENCED    ******
***** BEFORE IT HAS BEEN DEFINED THE RTN INSERTS THE TAG ADDRESS ******
***** WHERE IT IS NEEDED USING THE CHAIN SET IN TGRTN.           ******
         ST    R14,TAGSAVE              SAVE RETURN
         L     R5,ADRUBASE
         LA    R9,TAGTAB
         CLC   CARD(2),=C'TG'          Q.VALID LOC ENTRY.
         BNE   TAGERR                   A.NO
         MVC   SIZEWK+2(2),CARD+2
         BAL   R14,CNVRTN               PERFORM BINARY CONVERSION .
         C     R3,FFCON                Q. CONVERSION GOOD.
         BE    TAGERR
         C     R3,ZERO                 Q. TAG # VALID.
         BE    TAGERR
         SLA   R3,2(0)                  MULTIPLY TAG# BY 4.
         AR    R3,R9                    R9 HAS LHE TAG TABLE.
         CLC   0(2,R3),=C'00'
         BNE   TAGERR                   A.YES,DUPLICATE TAG.
         CLI   NOGOSW,C'0'      Q. NO GO SWITCH OFF
         BNE   TAGEXIT            NO'IT'S ON' -BYPASS RESOLVING TG ADRS
         MVC   0(2,R3),CARD+2           MOVE TAG # TO TAG TABLE.
         CLC   2(2,R3),=C'00'
         BNE   TAG01                    A. YES
         STH   R10,2(R3)                PUT TAG ADR IN TABLE.
         B     TAGEXIT
TAG01    MVC   TAG02+2(2),2(R3)         MOVE CHAIN ADR TO COMPARE INS.
         LA    R6,USERBASE+4095
         LA    R6,1(0,6)
         STH   R10,2(R3)                PUT TAG ADR IN TABLE.
TAG02    CLC   2(2,R3),=C'00'
         BE    TAG05                    A.YES
         MVC   TAG03+2(2),TAG02+2       SET TAG03 TO CHAIN ENTRY
         MVC   TAG04+4(2),TAG02+2       SET TAG04 TO CHAIN ENTRY
TAG04    MVC   TAG02+2(2),TAG04         SET TAG02 TO NEXT CHAIN ENTRY.
TAG03    STH   R10,TAG03                INSERT TAG ADR IN GENERATED INS
         B     TAG02
TAG05    MVC   TAG06+2(2),TAG02+2       SET TAG06 TO CHAIN ENTRY.
TAG06    STH   R10,TAG06                INSERT TAG ADR IN LAST ENTRY
TAGEXIT  L     R14,TAGSAVE              RETURN
         L     R6,AOURCODE
         BR    R14
TGERR    EQU   *
TAGERR   L     R6,AOURCODE
         MVI   LOCERR,C'E'
         MVI   NOGOSW,C'1'
         B     PARPRT
         DS    0F
TAGSAVE  DC    CL4' '
TAGTAB   DC   80C'00000'
         EJECT
TGRTN    EQU   *
*** THIS ROUTINE MUST BE PERFORMED (BAL). THIS ROUTINE RESOLVES ******
*** TAG ADDRESSES. IF TAG IS UNDEFINED,REFERENCES ARE CHAINED FOR ****
*** RESOLUTION AT TIME TAG IS DEFINED.  REG 4 CONTAIN REL ADR OF BRANCH
*   ADDRESS EG  GO TGXX 4 WOULD = 2 (OP/CODE +  MASK = 2)
         ST    R14,TGSAVE
         L     R5,ADRUBASE
         LA    R9,TAGTAB
         CLC   CARD+19(2),=C'TG'
         BNE   TG07
         MVC   SIZEWK+2(2),CARD+21      MOVE TG# TO SIZE WORK FOR CONV.
         BAL   R14,CNVRTN               PERFORM BINARY CONVERSION.
         C     R3,FFCON                Q. CONVERSION GOOD.
         BE    TGERR                    A. NO.
         C     R3,ZERO                 Q. TAG # = ZERO
         BE    TGERR                    A. YES
         SLA   R3,2(0)                  MULTIPLY R3 BY 4.
         AR    R3,R9                    R4 NOW HAS TAG TABLE ENTRY ADR.
         CLC   0(2,R3),=C'00'          Q. HAS TAG BEEN DEFINED.
         BE    TG01                     A. NO.
         MVC   B1D1(2),2(R3)              YES,MOVE TAG ADR TO INS.
TGEXIT   L     R14,TGSAVE                EXIT
         L     R6,AOURCODE
         BR    R14
TG01     AR    R4,R10
         L     R5,ADRUBASE
         LA    R6,USERBASE+4095    *POINT REG 6
         LA    R6,1(0,6)           * TO USER CODE + 4096
         CLC   2(2,R3),=C'00'          Q. ANY REFERENCE TO TAG.
         BNE   TG02                     A. YES
         STH   R4,2(0,R3)
TG08     L     R6,AOURCODE
         MVC   B1D1(2),=C'00'           SET END OF CHAIN
         B     TGEXIT
TG02     MVC   TG03+4(2),2(R3)          POINT COMPARE TO NEXT CHAIN ENT
TG03     CLC   =CL2'00',TG03           Q.END OF CHAIN.
         BNE   TG05                     A. NO
         MVC   TG04+2(2),TG03+4          ADJUST STORE HALFWORD ADR.
TG04     STH   R4,TG04
         B     TG08
TG05     MVC   TG06+4(2),TG03+4         SET UP TO CHECK NEXT ENTRY
TG06     MVC   TG03+4(2),TG06               FOR END OF CHAIN.
         B     TG03
TG07     CLC   CARD+19(3),=C'EOJ'
         BE    TG09
         CLC   CARD+19(4),CSORT  Q.  IS IT SORT
         BNE   TGERR                    NO - ERROR
         L     R6,AOURCODE        GET 6 POINT CORRECTLY B1D1 USES R6
         MVC   B1D1(2),SORTBD   YES - MOVE IN BASE DISP OF SORT
         B     TGEXIT                   GO EXIT RTN
TG09     L     R6,AOURCODE
         MVC   B1D1(2),EOJADR
         B     TGEXIT
         DS    0F
ADRUBASE DC    A(USERBASE)
TGSAVE   DS    CL4
ZERO     DC    XL4'00'
CSORT    DC    CL4'SORT'
SORTBD   DC    S(SORTBR)
         EJECT
SELF01   ST    R14,SLFSV                SAVE RETURN ADDRESS
SLFSW    BC    0,SELF05
         CLC   SIZEHLD,=X'00000028'  Q. IS SIZE > 40 DEC
         BH    SELF04A               YES-MAYBE INVALID
         L     R8,SIZEHLD            PUT BINARY SIZE IN R8
SELF01A  LH    R4,SLFBD              LOAD BASE DISP ADR OF SELF
         SR    R4,R8
         S     R4,=F'1'
         L     R5,SLFACT             LOAD ACTUAL ADR OF SELF
         STH   R4,SLFBD
         A     R4,=F'1'
         CLC   SLFBD,SLFBEG
         BH    SELF02
         BE    SELF02
         MVI   SLFSW+1,X'F0'
         B     SELF05
SELF02   SR    R5,R8
         STC   R8,SELF03+1
SELF03   MVC   0(1,R5),CARD+33
         S     R5,=F'1'                 POINT TO NEXT AVAIL POS OF SELF
         ST    R5,SLFACT                SAVE ACT ADR OF SELF
SELF04   L     R14,SLFSV                LOAD RETURN ADR
         BR    R14                      GO BACK
SELF04A  CLI   PRTAREA+31,C','   Q.  IS THERE 2 SIZES
         BE    SELF04B               YES
         CLI   PRTAREA+32,C','       CHECK NEXT POS EG X,X OR XX,X
         BNE   SELF05                NO-FLAG AS ERROR
SELF04B  LA    R8,15(0)              YES-FORCE SIZE TO 16 (F) LENGTH
         B     SELF01A               GO FINISH UP SELF GENERATION
SELF05   MVI   ADRERR,C'E'              FLAG AS ADR ERROR
         MVI   NOGOSW,C'1'              FLAG NO GO SWITCH
         B     SELF04                   GO EXIT RTN
SLFBEG   DC    S(SELF)
SLFBD    DC    S(SELF+1771)
EOJADR   DC    S(EOJRTN)
SLFACT   DC    A(SELF+1771)
AOURCODE DC    A(OURCODE)
SLFSV    DS    F
         EJECT
CNVRTN   EQU   *
**** THIS ROUTINE PACKS AND CONVERTS TO BINARY THE FULLWORD AT   ******
***** SIZEWK. THE RESULT IS PLACED IN R3.                        ******
         ST    R2,CVREG2     STORE REG 2 (REG2 IS USED AS BASE
*                            FOR I/O RTNS AND THE TRT USES REG 2)
         TRT   SIZWK(8),DECTAB         Q. ALL NUMERIC.
         BC    6,CV02                   A. NO BRANCH.
         PACK  SIZWK(8),SIZWK(8)
         CVB   R3,SIZWK                 CONVERT TO BINARY IN REG 3.
CV01     MVC   SIZWK(8),CONF0
         L     R2,CVREG2     RELOAD REG 2 / IN CASE WE CAME FROM I/O
         BR    R14
CV02     L     R3,FFCON
         B     CV01
         DS    0F
CVREG2   DS    1F             HOLD AREA FOR REG 2
CONF0    DC    CL8'00000000'
DECTAB   DC    CL16' '
HEXTAB   DC    CL224' '
         DC    XL10'00'
         DC    CL6' '
         DC    CL16'0123456789ABCDEF'
         EJECT
CVBINRTN EQU   *
*  THIS RTN GENERATES THE CODE TO CONVERT ZONED TO BINARY
         L     R3,SIZEHLD        LOAD SIZE INTO R3
         NI    SIZEHLD+3,X'0F'  REMOVE HIGH ORDER SIZE IN SIZEHOLD
         CLI   SIZEHLD+3,X'0A' Q.  SIZE FOR A-ADR 10 OR LESS
         BH    SZERR              NO - SIZE ERROR
         SRA   R3,4(0)           SHIFT TO REMOVE LOW ORDER SIZE IN R3
         C     R3,CVB4         Q. SIZE FOR B-ADR 4 OR LESS
         BH    SZERR              NO - SIZE ERROR
         MVI   CVBIPACK+1,X'70'
         OC    CVBIPACK+1(1),SIZEHLD+3  PUT SIZE ON PACK INST
         MVC   CVBIPACK+4(2),B2D2      PUT ADR OF DATA TO BE PACKED
         MVC   CVBIMVC+2(2),B1D1   PUT ADR TO RECEIVE DATA INLINE
         STH   R3,SIZEHLD              STORE SIZE OF RECEIVING FIELD
         MVC   CVBIMVC+1(1),SIZEHLD+1    MOVE SIZE IN-LINE
         LH    R4,CVDCON         POINT 4 AT BINARY RESULTS
         LA    R2,3                 LOAD 2 WITH MAX SIZE OF RESULT
         SR    R2,R3                   SUB SIZE FROM MAX SIZE
         AR    R4,R2                   ADD RESULTS TO ADJUST ADR
         STH   R4,CVBIMVC+4            STORE RESULTS IN LINE
         MVC   INSHOLD(8),CVBIN1       *  MOVE GEN-ED
         MVC   INSHOLD+8(6),CVBIN2     *  INST
         MVC   INSHOLD+16(6),CVBIN3    *   INLINE
         MVC   INSHOLD+24(8),CVBIN4    *
         B     PARPRT
         DS    0F
CVB4     DC    XL4'04'
CVB10    DC    XL4'0A'
*  THIS IS THE GENERATED CODE TO CONVERT ZONED TO BINARY (CVBIN)
*
CVBIN1   DC    XL2'05'
CVBIPACK PACK  CVDWORD(8),*+0(1)   PACK ZONED FIELD (A-ADR)
CVBIN2   DC    XL2'03'
         CVB   R2,CVDWORD          CONVERT PACK TO BINARY
CVBIN3   DC    XL2'03'
         ST    R2,CVDWORD+4        STORE BINARY NUMBER
CVBIN4   DC    XL2'05'
CVBIMVC  MVC   *+0(1),CVDWORD+4    MOVE BINARY # TO B-ADR
         EJECT
CVBZNRTN EQU   *
*  THIS RTN GENERATES THE CODE TO CONVERT BINARY TO ZONED
*
         L     R3,SIZEHLD      LOAD SIZE INTO R3
         NI    SIZEHLD+3,X'0F'  REMOVE HIGH ORDER SIZE IN SIZEHLD
         SRA   R3,4(0)           SHIFT TO REMOVE LOW ORDER SIZE IN R3
         CLI   SIZEHLD+3,X'04'  Q.  SIZE OF BINARY FIELD= OR < 4
         BH    SZERR              NO SIZE ERROR
         MVC   CVBZMVC+1(1),SIZEHLD+3  PUT SIZE INTO MOVE
         LH    R2,CVDCON         * ADJUST ADR (RECEIVING)
         LA    R4,3           *  OF MOVE
         ST    R11,SYSAVE+64  *   INST FIELD
         L     R11,SIZEHLD    *     TO BE
         SR    R4,R11         *       CONVERTED
         L     R11,SYSAVE+64 *
         AR    R2,R4          *
         STH   R2,CVBZMVC+2         *
         MVC   CVBZMVC+4(2),B2D2    PUT ADR TO MOVE FROM INLINE
         C     R3,CVB10          Q. SIZE OF ZONED FIELD= OR < 10
         BH    SZERR               NO SIZE ERROR
         MVC   CVBZUNPK+2(2),B1D1  PUT ADR OF WHERE TO UNPK AT INLINE
         LA    R2,3       LOAD R2 WITH MAX SIZE-1 FOR RESULTS
         SLA   R3,4(0)    SHIFT SIZE TO HI ORDER BITS
         STH   R3,SIZEHLD               * PUT SIZE OF UNPACKED
         MVI   CVBZUNPK+1,X'07'  PUT SIZE OF CVDWORD INTO UNPK INST
         OC    CVBZUNPK+1(1),SIZEHLD+1  PUT 2 SIZES TOGETHER
         SRA   R3,4(0)   SHIFT SIZE BACK TO LOWER BYTE
         LH    R2,B1D1                   * COMPUTE RHE
         AR    R2,R3                   *  TO CHG UNPKED DATA (LAST
         STH   R2,CVBZOI+2           * POS) TO DISPLAY
         MVC   INSHOLD(8),CVBZN1   * MOVE GENERATED INST INLINE
         MVC   INSHOLD+8(8),CVBZN2  *
         MVC   INSHOLD+16(6),CVBZN3  *
         MVC   INSHOLD+24(6),CVBZN4  *
         MVC   INSHOLD+32(8),CVBZN5   *
         MVC   INSHOLD+40(6),CVBZN6  *
         B     PARPRT
*                THIS IS THE GENERATED CODE    TO CONVERT BINARY
*                  TO ZONED (CVBZN)
CVBZN1   DC    XL2'05'
         MVC   CVDWORD(8),CVDWORD-1  CLEAR WORK AREA
CVBZN2   DC    XL2'05'
CVBZMVC  MVC   CVDWORD(1),*+0       *A-ADR MUST BE ADJUSTED BY A-ADR
CVBZN3   DC    XL2'03'              *SIZE(E.G. SIZE= 2/A-ADR IS +6)
        L      R2,CVDWORD+4          LOAD BINARY # INTO REG2
CVBZN4   DC    XL2'03'
         CVD   R2,CVDWORD        CONVERT BINARY # TO DECIMAL
CVBZN5   DC    XL2'05'
CVBZUNPK UNPK  *+0(1),CVDWORD        UNPACK DECIMAL INTO B-ADR
CVBZN6   DC    XL2'03'
CVBZOI   OI    *+0,X'F0'             CHG SIGN TO F (RHE B-ADR)
CVDCON   DC    S(CVDWORD+4)
         EJECT
PACKRTN  EQU   *
         MVC   LEN(1),SIZEHLD+3         MOVE SIZE TO INST
         MVC   INSHOLD+2(6),SSINST      MOVE INST TO HOLD AREA
         MVI   INSHOLD+1,X'05'     MOVE SIZE OF INSTRUCTION -1
         B     PARPRT                   GO PRT & PUT INST INLINE
         EJECT
UNPKRTN  EQU   *
         MVC   LEN(1),SIZEHLD+3         MOVE SIZE TO UNPK INST
         MVC   INSHOLD+2(6),SSINST      MOVE INST TO HOLD AREA
         MVI   INSHOLD+1,X'05'          MOVE SIZE OF INST -1
         L     R3,SIZEHLD               LOAD SIZE
         SRA   R3,4(0)                  SHIFT TO REMOVE SENDING SIZE
         MVC    SIZEWK+2(2),B1D1
         LH    R2,SIZEWK+2
         AR    R2,R3
         STH   R2,UNPKOR+2     STORE RHE ADR IN OR INSTRUCTION
         MVC   INSHOLD+8(6),UNPKCODE    MOVE 'OI' INST TO HOLD
         MVC   SIZEWK,SZZERO  CLEAR SIZE WORK AREA
         B     PARPRT                   'THIS ELIM C ON LAST POS
UNPKCODE DC    XL2'03'
UNPKOR   OI    *+0,X'F0'
         EJECT                    CONVERT SYSTEMS DATE TO YYMMDD, ETC
DATERTN  EQU   *                  CONVERT SYSTEMS DATE TO YYMMDD
         CNOP  0,4
         TIME  DEC                GET THE TIME
         ST    R1,DATESY          SAVE IN FORMAT '00YYJJJF'
         UNPK  DATEYJ,DATESY+1(3)  GET YYJJJ IN UNPACKED FORMAT
         UNPK  DATEYMD(3),DATESY+1(2)  GOT YEAR IN 'FYFYXX' FORMAT
         PACK  DATEWK(2),DATEYMD(2)    PACK YEAR INTO '0YYC' FORMAYY
DATETG1  SP    DATEWK(2),DATE4         SUBTRACT 4 FROM YEAR TRYING TO
         BH    DATETG1                 FIGURE OUT IF IT WAS LEAP YEAR
         BL    DATETG2                 NO -JULIAN DAY TABLE WAS OKAY
        MVC   DATEJDAY(84),DATEJDAY+84 YES-SUBSTITUTE LEAP YEAR TABLE
DATETG2  LA    R2,DATEJDAY             POINT R2 TO JULIAN DAY TABLE
DATETG3  CLC   DATESY+2(2),2(R2)   COMPARE SYSTEMS 'JJJF' TO TABLE
         BNH   DATETG4  SYSTEMS JJJ = OR < TABLE ENTRY-SEARCH COMPLETE
         LA    R2,7(R2)            POINT TO NEXT TABLE ENTRY
         SP    DATETLY,DATE1    Q-HAVE WE SEARCHED ALL ENTRIES
         BNZ   DATETG3          NO-GO BACK AND COMPARE TO NEXT ENTRY
         MVC   DATEYMD,DATEUNK YES-SYSTEMS DATE IS BAD
         B     DATEXIT             GO BACK TO USER
DATETG4  MVC   DATEYMD+2(2),0(R2)  GET MONTH IN 'MM' FORMAT FROM TABLE
         S     R2,DATEBUMP         BUMP BACK ONE ENTRY
         SP    DATESY+2(2),2(2,R2) SUBTRACT LAST JJJ OF LAST MONTH FROM
         UNPK  DATEYMD+4(2),DATESY+2(2)  SYSTEM JJJ & UNPK IT TO 'FJFJ'
         MVZ   DATEYMD+5(1),DATEYMD+4
         MVC   DATEDMY(2),DATEYMD+4  BUILD SYSTEMS DATE IN DD
         MVC   DATEDMY+3(3),11(R2)                         MMM(ALPHA)
         MVC   DATEDMY+7(2),DATEYMD                        YY  FORMAT
DATEXIT  BR    R14                 GO BACK TO USER
         DC    X'000F000000'
DATEJDAY DC    X'F0F1031FD1C1D5F0F2059FC6C5C2F0F3090FD4C1D9'
         DC    X'F0F4120FC1D7D9F0F5151FD4C1E8F0F6181FD1E4D5'
         DC    X'F0F7212FD1E4D3F0F8243FC1E4C7F0F9273FE2C5D7'
         DC    X'F1F0304FD6C3E3F1F1334FD5D6E5F1F2365FC4C5C3'
         DC    X'F0F1031FD1C1D5F0F2060FC6C5C2F0F3091FD4C1D9'
         DC    X'F0F4121FC1D7D9F0F5152FD4C1E8F0F6182FD1E4D5'
         DC    X'F0F7213FD1E4D3F0F8244FC1E4C7F0F9274FE2C5D7'
         DC    X'F1F0305FD6C3E3F1F1335FD5D6E5F1F2366FC4C5C3'
DATESY   DC    F'0'
DATEYMD  DC    C'      '
DATEDMY  DC    C'XX XXX XX'
DATEYJ   DC    C'XXXXX'
DATEWK   DC    C'  '
DATE1    DC    P'1'
DATE4    DC    P'4'
DATETLY  DC    PL2'12'
DATEUNK  DC    C'UNKNOW'
DATEBUMP DC    F'7'
         CNOP  0,4
         EJECT
MPYRTN   EQU   *    MULTIPLY ROUTINE
*    MPY  XX,YY  A-ADDRESS BY B-ADDRESS  PRODUCT IN RESULT - 30 BYTES
         MVN   MPYGEN1+3(1),SIZEHLD+3  -MULTIPLIER SIZE
         L     R3,SIZEHLD
         SRA   R3,4(0)
         ST    R3,SIZEHLD
         MVN   MPYGEN2+3(1),SIZEHLD+3  -MULTIPLICAND SIZE
         MVC   MPYGEN1+6(2),B2D2       -MULTIPLIER ADDRESS
         MVC   MPYGEN2+6(2),B1D1       -MULTIPLICAND ADDRESS
         LR    R3,R10
         AH    R3,=H'30'
         STH   R3,MPYGEN5+4
         MVC   INSHOLD+00(8),MPYGEN1   *MOVE GENERATED INSTRS INLINE
         MVC   INSHOLD+08(8),MPYGEN2   *
         MVC   INSHOLD+16(8),MPYGEN3   *
         MVC   INSHOLD+24(6),MPYGEN4   *
         MVC   INSHOLD+32(6),MPYGEN5   *
         MVC   INSHOLD+40(6),MPYGEN6   *
         MVC   INSHOLD+48(8),MPYGEN7   *
         MVC   INSHOLD+56(8),MPYGEN8   *
         B     PARPRT
********* THEIR GENERATED CODE
MPYGEN1  DC    XL2'05'
         PACK  FIELD8(8),*+0(1)         PACK THEIR MULTIPLIER
MPYGEN2  DC    XL2'05'
         PACK  FIELD16,*+0(1)           PACK THEIR MULTIPLICAND
MPYGEN3  DC    XL2'05'
         MP    FIELD16,FIELD8           MULTIPLY
MPYGEN4  DC    XL2'03'
         TM    FIELD16+15,X'01'         Q-NEGATIVE PRODUCT
MPYGEN5  DC    XL2'03'
         BO    *+8                      A-YES/LEAVE NEGATIVE BITS ON
MPYGEN6  DC    XL2'03'
         OI    FIELD16+15,X'0F'         A-NO/MAKE PRODUCT DISPLAYABLE
MPYGEN7  DC    XL2'05'
         UNPK  RESULT(16),FIELD16(9)    UNPACK
MPYGEN8  DC    XL2'05'                         PRODUCT INTO
         UNPK  RESULT+15(15),FIELD16+8(8)           RESULT   - 30 BYTES
         EJECT
DVDRTN   EQU   *    DIVIDE ROUTINE
*   DVD  XX,YY  A-ADDRESS INTO B-ADDRESS   QUOTENT IN RESULT - 15 BYTES
*                                          REMAINDER IN RESULT+15 - 15B
         MVN   DVDGEN1+3(1),SIZEHLD+3  -DIVIDEND SIZE
         L     R3,SIZEHLD
         SRA   R3,4(0)
         ST    R3,SIZEHLD
         MVN   DVDGEN2+3(1),SIZEHLD+3  -DIVISOR SIZE
         MVC   DVDGEN1+6(2),B2D2       -DIVISOR ADDRESS
         MVC   DVDGEN2+6(2),B1D1       -DIVIDEND ADDRESS
         LR    R3,R10
         AH    R3,=H'34'
         STH   R3,DVDGEN5+4
         MVC   INSHOLD+00(8),DVDGEN1   *MOVE GENERATED INST INLINE
         MVC   INSHOLD+08(8),DVDGEN2   *
         MVC   INSHOLD+16(8),DVDGEN3   *
         MVC   INSHOLD+24(6),DVDGEN4   *
         MVC   INSHOLD+32(6),DVDGEN5   *
         MVC   INSHOLD+40(6),DVDGEN6   *
         MVC   INSHOLD+48(6),DVDGEN7   *
         MVC   INSHOLD+56(8),DVDGEN8   *
         MVC   INSHOLD+64(8),DVDGEN9   *
         B     PARPRT
********* THEIR GENERATED CODE
DVDGEN1  DC    XL2'05'
         PACK  FIELD8(8),*+0(1)         PACK  THEIR DIVISOR
DVDGEN2  DC    XL2'05'
         PACK  FIELD16,*+0(1)   1)      PACK  THEIR DIVIDEND
DVDGEN3  DC    XL2'05'
         DP    FIELD16,FIELD8           DIVIDE
DVDGEN4  DC    XL2'03'
         TM    FIELD16+7,X'01'          Q-NEGATIVE QUOTENT
DVDGEN5  DC    XL2'03'
         BO    *+12                     A-YES/LEAVE NEGATIVE BITS ON
DVDGEN6  DC    XL2'03'
         OI    FIELD16+7,X'0F'          A-NO/MAKE POSITIVE QUOTENT
DVDGEN7  DC    XL2'03'                       DISPLAYABLE
         OI    FIELD16+15,X'0F'              MAKE POSITIVE REMAINDER
DVDGEN8  DC    XL2'05'                       DISPLAYABLE
         UNPK  RESULT(15),FIELD16(8)    UNPACK QUOTENT INTO RESULT
DVDGEN9  DC    XL2'05'
         UNPK  RESULT+15(15),FIELD16+8(8) UNPK REMAINDER INTO RESULT+15
         EJECT
PRINTER  DCB   DDNAME=SYSOUT,DSORG=PS,MACRF=PM,RECFM=U,                C
               LRECL=120,BLKSIZE=120
INCARD   DCB   DDNAME=SYSIN,DSORG=PS,MACRF=GM,EODAD=PAREND
         EJECT
         DS    0D
DISKWRT  EQU   *
DISKRD   EQU   *
PAREND   EQU   *
         L     R5,ADRUBASE
SORTSW   B     SORTBP                   / NOP IF SORT WAS CALLED
         MVC   CARD+19(4),SORTTAGS      /GET ADDR
         LA    R4,2(0)  ONLY NEED TO MEET TGRTN REQUIREMENTS
         BAL   R14,TGRTN                / OF  INPUT
         MVC   INPROC+2(2),RXINST+2     / AND OUT PUT
         MVC   CARD+19(4),SORTTAGS+5    / PROCEDURE TAGS
         LA    R4,2(0)  ONLY NEED TO MEET TGRTN REQUIREMENTS
         BAL   R14,TGRTN                / AND PUT IN
         MVC   OUTPROC+2(2),RXINST+2    / COMM AREA FOR SORT
SORTBP   LA    R9,TAGTAB          * R9=LHE TAG TABLE
PAR01    MVC   PRTAREA(133),PRTAREA-1   CLEAR PRT AREA
PAR02    LA    R9,4(R9)
         CP    TGCNT(2),=PL2'100' *ANY MORE TAGS ?
         BE    PAR10          00' *NO
         MVC   PRTAREA+1(4),TGO1  *MOVE TAG ID TO PRT LINE.
         AP    TGCNT(2),ONE(1) 1' *BUMP TAG COUNT BY 1.
         UNPK  TGO1+2(2),TGCNT(2) *UPDATE TAG ID
         OI    TGO1+3,X'F0'   (2) *FIX ZONE
         CLC   0(2,R9),=C'00'     *TAG DEFINED ?
         BNE   PAR04              *YES
         CLC   2(2,R9),=C'00'     *TAG REFERENED?
         BE    PAR02          (2) *NO
         CLI   NOGOSW,C'1'     Q. NO GO SWITCH SET
         BE    PAR03             YES-BYPASS PRINTING UNDEFINED
         MVI   NOGOSW,C'1'    (2) *YES, ERROR.
         MVC   PRTAREA+6(9),=C'UNDEFINED'
PAR03    MVI   PRTAREA,X'09'      *SKIP1 TO PRT CNTL.
         PUT   PRINTER,PRTAREA+1
         B     PAR01
PAR04    MVC   HEXHLD(2),2(R9)    *MOVE TAG ADDR TO CONV WORKAREA.
         BAL   R14,HEXRTN         *CONVERT TO EBCDIC.
         MVC   PRTAREA+6(4),CONVHEX    *EDCDIC TO PRT LINE
         B     PAR03
TGCNT    DC    PL2'1'
TGO1     DC    CL4'TG01'
PAR10    MVC   PRTAREA(133),PRTAREA-1
         MVI   PRTAREA,X'89'
         PUT   PRINTER,PRTAREA+1
         MVC   PRTAREA(133),PRTAREA-1
         LA    R4,EXITSK
         CLI   NOGOSW,C'0'      Q. ANY PARAMETERS FLAGGED
         BE    PAR20             NO-CONTINUE PROCESSING
TAPECLSW B     BADPARMS   THIS NOP IF TAPE CLASS HAS BEEN CALLED
         ABEND 8           TO FORCE ABNORNAL TERMINATION ON BAD PARMS
         CNOP 2,4  FORCE ALIGNMENT SO FOLLOWING ACON IS FULL WORD ORIEN
PAR20    MVC   DATE6(20),DATEYMD  PUT SYSTEM DATE IN USER AREA
PAREND1  CLC   IN1MOD,ZEROS      Q. IN 1 MODULE LOADED
         BE    PAREND2
         L     15,IN1MOD             YES-LOAD 15 WITH ADR OF MODULE
         BALR  14,15                BRANCH TO MODULE TO EXEC OPEN
         DC    A(OURCODE)    USED BY READ DIRECT (AREA ADDRESS)       *
         DC    XL2'7000'                                              *
         DS    CL6
PAREND2  CLC   IN2MOD,ZEROS
         BE    PAREND3
         L     15,IN2MOD
         BALR  14,15
         DC    A(OURCODE)                                             *
         DC    XL2'8000'                                              *
         DS    CL6
PAREND3  CLC   IN3MOD,ZEROS
         BE    PAREND4
         L     15,IN3MOD
         BALR  14,15
         DC    A(OURCODE)                                             *
         DC    XL2'9000'                                              *
         DS    CL6
PAREND4  CLC   OT1MOD,ZEROS
         BE    PAREND5
         L     15,OT1MOD
         BALR  14,15
         DC    A(OURCODE)     USED BY READ DIRECT MOD FOR AREA ADR
         DC    XL2'B000'     *GIVE OUT MODULE ADR OF REC AREA
         DS    CL6           *
PAREND5  CLC   OT2MOD,ZEROS
         BE    PAREND6
         L     15,OT2MOD
         BALR  14,15
         DC    A(OURCODE)     USED BY READ DIRECT MOD FOR AREA ADR
         DC    XL2'B384'     *GIVE OUT MODULE ADR OF REC AREA
         DS    CL6           *
PAREND6  CLC   OT3MOD,ZEROS
         BE    PAREND7
         L     15,OT3MOD
         BALR  14,15
         DC    A(OURCODE)     USED BY READ DIRECT MOD FOR AREA ADR
         DC    XL2'B708'     *GIVE OUT MODULE ADR OF REC AREA
         DS    CL6           *
PAREND7  CLC   PRTMOD,ZEROS
         BE    PAREND8
         L     15,PRTMOD
         BALR  14,15
         DC    S(PRTAREA)
PAREND8  CLC   RDCDMOD,ZEROS
         BE    PAREND9
         L     15,RDCDMOD
         BALR  14,15
         DS    CL4             * DUMMY CODE NEEDED FOR RD MODULE
         DC    S(CARD)      REC AREA ADR NEEDED BY RD MODULE
         DS    CL6             NEEDED BY RD CD MODULE
PAREND9  B     DEBUGAID
ZEROS    DC    1F'0'
         EJECT
         ORG   OURCODE+7700            *
CLEAR01  MVI   OURCODE,X'40'           * CLEAR
         CLOSE (INCARD,,PRINTER)
         LA    R2,28(0,0)              *   7680
         LA    R1,OURCODE+256          *     POS OF OUR CODE
         MVI   OURCODE,X'40'           * TO BE USED BY USER
         MVC   OURCODE+1(256),OURCODE  *  FOR WORK AREA (2000/5999)
CLEAR02  MVC   0(256,1),OURCODE        *   AND FOR OUTPUT REC AREAS
         LA    R1,256(0,1)             *
         BCT   R2,CLEAR02              *
         MVI   0(R11),X'00'      PUT ZEROS AFTER LAST USER INSTRUCT
         LA    R10,OURCODE         SET 10 TO WORK AREA
         LA    R11,OURCODE+4096    SET 11 TO LHE OF OUT1 REC AREA
         LA    R9,PUNCHID+60    * THIS IS DONE IN CASE ONE OF THE
         LA    R8,PUNCHID+30    * INPUT FILE ARE DA / OTHERWISE
         LA    R7,PUNCHID       * REGS WILL BO RELOADED BY THE I/O MOD
         LA    R6,USERBASE+4095
         LA    R6,1(0,6)
         B     USERCODE                 GO EXEC USER CODE
SYSAVE   DS    18F
         EJECT
RDRTN    L     R2,OUR8192     LOAD BASE REG FOR RTN
         B     RDRTN1
WRTRTN   L     R2,OUR8192     LOAD BASE REG FOR RTN
         B     WRTRTN1
PRTRTN   L     R2,OUR8192     LOAD BASE REG FOR RTN
         B     PRTRTN1
CALLRTN  L     R2,OUR8192    LOAD BASE REG FOR RTN
         B     CALL1
XCONSRTN L     R2,OUR8192      LOAD BASE REG FOR RTN
         B     XCONS1
DEBUGAID L     R2,OUR8192
         B     DEBUGRTN    GO PRINT DEBUGGING AIDS
OUR8192  DC    A(OURCODE+8192)
         EJECT
         LTORG
         EJECT
         ORG   OURCODE+8192    PLACE AFTER LTORG
*  R2 IS LOADED BEFORE BRANCHING TO THESE RTNS
READCARD DC    CL8'RRDCART '
READINP1 DC    CL8'RRDINP1 '
READINP2 DC    CL8'RRDINP2 '
READINP3 DC    CL8'RRDINP3 '
OUT1MOD  DC    CL8'RROUT1MD'
OUT2MOD  DC    CL8'RROUT2MD'
OUT3MOD  DC    CL8'RROUT3MD'
PTMOD    DC    CL8'RRPRTMOT'       USED TO LOAD MOD (MOD NAME)
OUT1IS   DC    CL8'RROT1ISM'
OUT2IS   DC    CL8'RROT2ISM'
OUT3IS   DC    CL8'RROT3ISM'
INP1IS   DC    CL8'RRINP1IS'
INP2IS   DC    CL8'RRINP2IS'
INP3IS   DC    CL8'RRINP3IS'
INP1ISR  DC    CL8'RRIN1ISR'
INP2ISR  DC    CL8'RRIN2ISR'
INP3ISR  DC    CL8'RRIN3ISR'
INP1DI   DC    CL8'RRINP1DI'                                          *
INP2DI   DC    CL8'RRINP2DI'                                          *
INP3DI   DC    CL8'RRINP3DI'                                          *
INP1DK   DC    CL8'RRINP1DK'                                          *
INP2DK   DC    CL8'RRINP2DK'                                          *
INP3DK   DC    CL8'RRINP3DK'                                          *
OUT1DA   DC    CL8'RROUT1DA'                                          *
OUT2DA   DC    CL8'RROUT2DA'                                          *
OUT3DA   DC    CL8'RROUT3DA'                                          *
MODNAME1 DS    CL8
MODNAME2 DS    CL8
MODNAME3 DS    CL8
         EJECT
PRTRTN1  EQU   *
**** THIS ROUTINE GENERATE LINKAGE TO PRINTER IOMODULE AND       ******
***** CARRIAGE CONTROL INFO.                                     ******
         L     R5,ADRUBASE NEED TO POINT TO COMM AREA
         CLC   CARD+19(4),=CL4'SKIP'
         BE    PRT02
         CLC   CARD+19(4),=CL4'CHAN'
         BNE   RDERR
         CLC   CARD+23(2),=CL2'12'
         BH    RDERR
         MVC   SIZEWK+2(2),CARD+23
         LA    R8,CHTAB
PRT01    BAL   R14,CNVRTN
         C     R3,FFCON
         BE    RDERR
         AR    R8,R3
         MVC   PRTCTL+1(1),0(R8)   MOVE CONTROL CHAR TO IN-LINE CODE
         MVC   INSHOLD(6),PRTCODE1     * MOVE
         MVC   INSHOLD+8(6),PRTCODE2   *    IN-LINE
         MVC   INSHOLD+16(4),PRTCODE3  *      CODE
         MVC   INSHOLD+24(4),PRTCODE4  *        TO
         MVC   INSHOLD+32(8),PRTCODE5  *          INST HOLD AREA
         MVC   INSHOLD+40(8),PRTCODE6  *
PRT01A   NOP   PRT01B    USED TO BYPASS LOAD OF MOD AFTER FIRST TIME
         LOAD  EPLOC=PTMOD     LOAD PRT MODULE AND STORE
         ST    R0,PRTMOD              ADR OF MOD
         MVI   PRT01A+1,X'F0'     TURN ON SN TO BYPASS RELOADING MOD
PRT01B   B     PARPRT
PRT02    CLI   CARD+23,C'3'
         BH    RDERR
         LA    R8,SKTAB
         MVC   SIZEWK+3(1),CARD+23
         B     PRT01
SKTAB    DC    XL4'01091119'
CHTAB    DC    XL13'01899199A1A9B1B9C1C9D1D9E1'
         DS    0F
*INLINE CODE FOR  PRINT INST
*   I/O MOD MUST RETURN CONTROL VIA REG-14 + 2
*    (SKIP PRT AREA ADR)
PRTCODE1 DC    XL2'03'
PRTCTL   MVI   PRTAREA,C'1' * MOVE IN PRT CONTROL CHAR
PRTCODE2 DC    XL2'03'
         L     R15,PRTMOD     *  LOAD 15 WITH ADR OF PRTMOD
PRTCODE3 DC    XL2'01'
         BALR  R14,R15        *  BR TO PRTMOD
PRTCODE4 DC    XL2'01'
         DC    S(PRTAREA)     * ADR OF PRINT ATEA
PRTCODE5 DC    XL2'05'
         AP    PRCNT,ONE      *  ADD 1  TO REC COUNT
PRTCODE6 DC    XL2'05'
         MVC   PRTAREA(133),PRTAREA-1  * CLEAR PRINT AREA
         EJECT
WRTRTN1  EQU   *
*
*
*
         L     R5,ADRUBASE NEED TO POINT TO COMM AREA
WRT01    CLC   CARD+19(4),=CL4'OUT1'   Q. OUT1
         BNE   WRT05                       NO
WRT02    NOP   WRT03                      YES-1 TIME SWITCH TO BY PASS
         MVC   WRT02(2),WRT04           CHG NOP TO B INST
         CLC   CARD+12(2),ISCON   Q. IS THIS AN INDEX SEQ DATA SET
         BNE   WRT0201A                                               *
         MVC   OUT1MOD(8),OUT1IS YES-CHG TO LOAD ISAM MODULE
         B     WRT0201                                                *
WRT0201A CLC   CARD+12(2),DACON   Q. IS THIS A DIRECT WRT             *
         BNE   WRT0201                                                *
         MVC   OUT1MOD(8),OUT1DA                                      *
WRT0201  LOAD  EPLOC=OUT1MOD   LOAD OF MODULE AND STORING
WRT02A   ST    R0,OT1MOD    ENTRY POINT ADR OF I/O MODULE
WRT03    MVC   IOREC,ADRJ     PUT REC AREA ADR IN
         MVC   IOCODE+4(2),WRT02A+2  PUT ADR OF LOADED MOD INLINE
         MVC   IOADD+2(2),ADROCT1    PUT ADR OF CT IN GEN CODE
WRT03A   MVC   INSHOLD(6),IOCODE   * MOVE
         MVC   INSHOLD+8(4),IOCODE1    *   INLINE INST
         MVC   INSHOLD+16(6),IOCODE2   *     TO INST HOLD
         MVC   INSHOLD+24(4),IOCODE3   *       AREA FOR  PRINT
         MVC   INSHOLD+32(8),IOCODE4   *         AND BEING
         MVC   INSHOLD+40(8),IOCODE5   *           MOVED INLINE
WRT04    B     PARPRT
WRT05    CLC   CARD+19(4),=CL4'OUT2'   Q. OUT2
         BNE   WRT07                      NO- CK TO SEE IF OUT 3
WRT06    NOP   WRT06B                     YES - 1 TIME SWITCH
         MVI   WRT06+1,X'F0'                CHG SW TO BRANCH AROUND
         CLC   CARD+12(2),ISCON   Q. IS THIS AN INDEX SEQ DATA SET
         BNE   WRT0601A       NO
         MVC   OUT2MOD(8),OUT2IS    YES-CHG TO LOAD ISAM
         B     WRT0601       LOAD MODULE
WRT0601A CLC   CARD+12(2),DACON   Q. IS THIS DIRECT
         BNE   WRT0601               NO - LOAD SEQ
         MVC   OUT2MOD(8),OUT2DA  YES-SET TO LOAD WRT DIRECT MODULE
WRT0601  LOAD  EPLOC=OUT2MOD       LOAD OUT 2 MODULE
WRT06A   ST    R0,OT2MOD         SAVE ENTRY POINT ADR OF OUT 2 MODULE
WRT06B   MVC   IOREC,ADRK
         MVC   IOCODE+4(2),WRT06A+2  PUT ADR OF LOADED MOD INLINE
         MVC   IOADD+2(2),ADROCT2    PUT ADR OF COUNT IN CODE
         B     WRT03A                GO MOVE IT ALL INLINE
WRT07    CLC   CARD+19(4),=CL4'OUT3'   Q. OUT 3
         BNE   RDERR                       NO- FLAG AS ADR ERROR
WRT08    NOP   WRT08B                     YES
         MVI   WRT08+1,X'F0'               CHG SW TO BRANCH AROUND LOAD
         CLC   CARD+12(2),ISCON   Q. IS THIS AN INDEX SEQ DATA SET
         BNE   WRT0801A       NO
         MVC   OUT3MOD(8),OUT3IS     YES-CHG TO LOAD ISAM
         B     WRT0801
WRT0801A CLC   CARD+12(2),DACON   Q. IS THIS DIRECT
         BNE   WRT0801              NO - LOAD SEQ
         MVC   OUT3MOD(8),OUT3DA YES-SET TO LOAD WRT DIRECT MODULE
WRT0801  LOAD  EPLOC=OUT3MOD        LOAD OUT 3 MODULE
WRT08A   ST    R0,OT3MOD                  SAVE ENTRY POINT OF MODULE
WRT08B   MVC   IOREC,ADRL
         MVC   IOCODE+4(2),WRT08A+2       PUT ADR OF LOADED MOD INLINE
         MVC   IOADD+2(2),ADROCT3         PUT ADR OF COUNT IN CODE
         B     WRT03A                     GO MOVE IT ALL INLINE
ADROCT1  DC    S(O1CNT)
ADROCT2  DC    S(O2CNT)
ADROCT3  DC    S(O3CNT)
REG10    DC    XL2'A000'    REG 10 FOR WRITE OUT 1  REC AREA
REG11    DC    XL2'B000'           REG 11 FOR OUT 2
REG12    DC    XL2'C000'           REG 12 FOR OUT 3
DACON    DC    CL2'DA'                                                *
         EJECT
** INLINE CODING FOR USER READ AND WRITES OF PS DATA SETS
*   I/O MOD MUST ADD 12 TO R14 TO BY PASS PARMS
IOCODE   DC    XL2'03'
         L     R15,SIZEWK   * LOAD ADR OF I/O MOD  *VTO BE FILLED IN
IOCODE1  DC    XL2'01'
         BALR  R14,R15            BRANCH TO I/O MOD
IOCODE2  DC    XL2'03'
INPEOF   B     *+0              * BRANCH TO EOF  (FOR READ ONLY)
IOCODE3  DC    XL2'01'
IOREC    DC    XL2'0000'        * REC AREA ADDRESS OR REG
IOCODE4  DC    XL2'05'
         DC    XL6'FFFFFFFFFFFF'  FIRST 2 POS KEY ADR BISAM/  4  FUTURE
IOCODE5  DC    XL2'05'
IOADD    AP    *+0(4),ONE  * ADD 1 TO RECORD COUNT
         EJECT
RDRTN1   EQU   *
*  THIS RTN SETS UP THE CODE
*   NECESSARY TO READ CARDS
*
         L     R5,ADRUBASE NEED TO POINT TO COMM AREA
         CLC   CARD+19(4),=CL4'CARD'  Q. READ CARD PARM
         BE    RDCARD                    YES
         CLC   CARD+19(3),=CL3'INP'    Q.READ INPUT
         BE    RDINPUT                   YES
         B     RDERR                     NO- FLAG AS ADR ERR
RDINPUT  CLC   CARD+12(3),ISCON    Q. SEQ IS READ  (IS)
         BNE   RDINPUT3
         MVC   MODNAME1(24),INP1IS    SET MOD NAMES TO IS
         B     RDINPUT6               GO CONV
RDINPUT3 CLC   CARD+12(3),ISRCON   Q. INDEX SEQ/RANDOM (ISR)
         BNE   RDINPUT5
         MVC   MODNAME1(24),INP1ISR   SET MOD NAMES TO ISR
RDINPUT4 BAL   R14,RDISR01            CONVERT KEY  ADDRESS
         B     RDINPUT9
RDINPUT5 CLC   CARD+12(2),DICON    Q. RD DIRECT USING BLK ADR (DI)
         BNE   RDINPT5A
         MVC   MODNAME1(24),INP1DI    SET MOD NAMES TO DI
         B     RDINPUT6
RDINPT5A CLC   CARD+12(2),DKCON    Q. RD DIRECT USING KEY  (DK
         BNE   RDINPT5B
         MVC   MODNAME1(24),INP1DK    SET MOD NAMES TO DK
         B     RDINPUT4
RDINPT5B CLI   CARD+12,X'40'       Q. PS OR PO READ
         BNE   RDERR                  NO ERROR
         MVC   MODNAME1(24),READINP1  SET MOD NAMES TO PS/PO
RDINPUT6 LA    R4,8(0)                *CONV-EOF ADR/ GIVE TAGRTN REL
         MVC   CARD+60(4),CARD+19     * LOC OF WHERE INST WILL BE AT
         MVC   CARD+19(4),CARD+24        *  MOVE TAG TO A-ADR-FOR TAGRT
         BAL   R14,TGRTN              *  PERFORM RTN
         MVC   INPEOF+2(2),RXINST+2   * MOVE EOF ADR TO GEN CODE
         MVC   CARD+19(4),CARD+60    * PUT ORIGINAL A-ADR BACK
RDINPUT9 CLI   CARD+22,C'1'         Q. INP 1
         BE    RDINP1                     YES
         CLI   CARD+22,C'2'            Q. INP 2
         BE    RDINP2                     YES
         CLI   CARD+22,C'3'            Q. INP 3
         BE    RDINP3                     YES
         B     RDERR                      NO-ADR ERR
RDCARD   NOP   RDCARD01
         LOAD  EPLOC=READCARD      LOAD CARD READ MODULE
         ST    R0,RDCDMOD           SAVE ADR OF MOD
         MVI   RDCARD+1,X'F0'   * SET TO BYPASS LOADING MOD AGAIN
RDCARD01 MVC   IOREC,ACONCARD     * PUT LHE ADR OF RECORD AREA
         MVC   IOADD+2(2),CDCNT   * PUT ADR OF COUNT IN CODE
         MVC   IOCODE+4(2),RDCDADR * PUT ADR OF LOAD MOD ADR IN CODE
         LA    R4,8(0)                *CONV-EOF ADR/ GIVE TAGRTN REL
         MVC   CARD+19(4),CARD+24        *  MOVE TAG TO A-ADR-FOR TAGRT
         BAL   R14,TGRTN              *  PERFORM RTN
         MVC   INPEOF+2(2),RXINST+2   * MOVE EOF ADR TO GEN CODE
         B     RDMOVE01            * GO GET EOF ADR & MOVE INST IN
RDMOVE01 MVC   INSHOLD(6),IOCODE   * MOVE
         MVC   INSHOLD+8(4),IOCODE1  *  CODE
         MVC   INSHOLD+16(6),IOCODE2  * TO BE
         MVC   INSHOLD+24(4),IOCODE3 *     PRINTED
         MVC   INSHOLD+32(8),IOCODE4 *       AND
         MVC   INSHOLD+40(8),IOCODE5 *        INSERTED IN LINE
         B     PARPRT    GO PRINT + INSERT CODE
RDERR    MVI   ADRERR,C'E'        FLAG AS ADDRESS ERROR
         MVI   NOGOSW,C'1'       SET NO GO SWITCH
         B     PARPRT
ACONCARD DC    S(CARD)
CDCNT    DC    S(CRDCNT)
RDCDADR  DC    S(RDCDMOD)
INP1CT   DC    S(IN1CNT)
INP1ADR  DC    S(IN1MOD)
INP2CT   DC    S(IN2CNT)
INP2ADR  DC    S(IN2MOD)
INP3CT   DC    S(IN3CNT)
INP3ADR  DC    S(IN3MOD)
RDINP1   NOP   RDINP101             ONE TIME SWITCH
         LOAD  EPLOC=MODNAME1
         ST    R0,IN1MOD            SAVE ADR OF MOD
         MVI   RDINP1+1,X'F0'       SET TO BYPASS LOADING OF MOD AGAIN
RDINP101 MVC   IOADD+2(2),INP1CT    PUT ADR OF COUNT IN - INLINE CODE
         MVC   IOCODE+4(2),INP1ADR  PUT ADR OF LOAD MOD ADR IN  CODE
         MVC   IOREC,ADRA      PUT REC AREA ADR INLINE
         B     RDMOVE01          GO GET EOF ADR & MOVE INST INLINE
RDINP2   NOP   RDINP201            ONE TIME SW
         LOAD  EPLOC=MODNAME2
         ST    R0,IN2MOD           SAVE ADR OF MOD
         MVI   RDINP2+1,X'F0'      SET TO BYPASS LOADING OF MOD AGAIN
RDINP201 MVC   IOADD+2(2),INP2CT   PUT ADR OF COUNT IN INLINE CODE
         MVC   IOCODE+4(2),INP2ADR PUT ADR OF LOAD  MOD ADR IN CODE
         MVC   IOREC,ADRB      PUT ADR OF REC AREA INLINE
         B     RDMOVE01            GO GET EOF ADR & MOVE INST INLINE
RDINP3   NOP   RDINP301            ONE TIME SW
         LOAD  EPLOC=MODNAME3
         ST    R0,IN3MOD           SAVE ADR OF MOD
         MVI   RDINP3+1,X'F0'      SET TO BYPASS LOADING OF MOD AGAIN
RDINP301 MVC   IOADD+2(2),INP3CT   PUT ADR OF COUNT IN INLINE CODE
         MVC   IOCODE+4(2),INP3ADR PUT ADR OF LOAD MOD ADR IN CODE
         MVC   IOREC,ADRC      PUT REC AREA ADR INLINE
         B     RDMOVE01            GO GET EOF ADR & MOVE INST INLINE
RDISR01  EQU   *  THIS RTN HANDLES RANDOM READS TO AN ISAM DATA SET
*                 BY CONV OF KEY ADR (COL 24)
         ST    R14,RD14HOLD     SAVE RETURN ADR
         MVC   ADR2,RDISR1AC        PUT RETURN ADR IN ADR RTN
         MVC   CARD+60(4),CARD+19   SAVE A ADR
         MVC   CARD+19(4),CARD+24   MOVE KEY ADR TO A-ADR
         B     AADRRTN              CONV KEY ADR
RDISR01A MVC   IOCODE4+2(2),B2D2    MOVE ADR OF KEY TO INLINE CODE
         MVC   CARD+19(4),CARD+60   PUT A-ADR BACK
         L     R14,RD14HOLD         RETURN
         BR    R14
RD14HOLD DC    1F'0'                HOLD AREA FOR RETURN ADR
RDISR1AC DC    S(RDISR01A)
AMSW     DC    CL1'0'    ACCESS METHOD SW 0=PS 1=IS 2=ISR
DICON    DC    CL2'DICON'                                             *
DKCON    DC    CL2'DKCON'                                             *
         EJECT
         DS    0F
CALL1    EQU   *
* THIS RTN GENERATES THE CODE TO CALL LOAD MODULES
*   THIS RTN IS RESPONSIBLE FOR LOADING THE MODULE & MAKING SURE THE
*     MODULE IS ONLY LOADED ONE TIME.
* FORMAT OF LIST STORED AT END OF USERCODE
*         0000-0031 = PARM LIST ADRS (8)
*         0032-0035 = ACT LIST ADR
*         0036-0039 = ACT EPLOC
*         0040-0047 = MOD NAME
*         0048-0049 = BASE/DISP OF LIST STORED AT END OF USERCODE
*
         MVI   CALL02A+1,X'00'   * RESETS SWS THAT MAY HAVE BEEN SET
         MVI   CALL02AA+1,X'00'   * BY SORT OR BINARY BUT NOT RESET
CALLSR01 CLC   RRGENSRT,CARD+19   Q. CALL OF RRGEN SORT
         BE    CALLSR10              YES
         CLC   RELEASE,CARD+19    Q. CALL OF RELEASE FOR SORT
         BE    CALLSR20              YES
         CLC   RETURNC,CARD+19    Q. CALL OF RETURN FOR SORT
         BE    CALLSR30              YES
         CLC   RRBINARY,CARD+19    Q. CALL OF RRBINARY
         BNE   CALL01                 NO
         MVC   BINPARMS,CARD+44   YES-STORE PARMS PASSED        C9 (-)
         MVI   CALL02AA+1,X'F0'      SET SW FOR RRBINARY
         MVI   CARD+43,X'40'      ONLY LET IT CK FOR 2 PARMS
CALL01   MVC   MODULENA,CARD+19  MOVE IN MODULE NAME FOR LOAD INST
         CLI   CARD+27,X'40'   Q.ARE THE ANY PARAMETERS TO PASS
         BE    CALL01AA          NO-BYPASS CREATING PARAM LIST
         CLC   CARD+27(7),USINGCON    Q. IS ',USING,' IN CARD
         BNE   RDERR                     NO- GO TO FLAG AS ERROR
CALL01AA CLC   ENDUSER,CENDUSER    Q. FIRST MODULE TO BE CALLED
         BE    CALL01B                YES
         L     R4,ENDUSER
CALL01A  CLC   40(8,R4),CARD+19   Q.  MODULE CALLED BEFORE
         BE    CALL0105               YES
         LA    R4,52(R4)       NO - BUMP TO LOOK AT NEXT ENTRY
         C     R4,CENDUSER          Q. HAVE WE LOOKED AT ALL MOD CALLED
         BNE   CALL01A                NO-TRY AGAIN
         B     CALL01B                NEVER USED BEFORE
CALL0105 MVI   CALL05+1,X'F0'         BRANCH AROUND LOAD OF MOD
         MVC   CARD(4),36(R4)    SAVE EPLOC FOR MODILE
CALL01B  LH    R4,BDLIST      * KEEP BASE/DISP
         LA    R5,52(0)      * ADR POINT TO LIST
         SR    R4,R5          *  BEING CREATED
         STH   R4,BDLIST      *
         L     R4,ENDUSER      *PARMS LIST ARE STORE AT END
         LA    R5,52(0)        * OF USERCODE
         SR    R4,R5           * FORMAT             32POS/PARM-ADR
         ST    R4,ENDUSER      *  4POS/EPLOC 4POS/LIST ADR  8POS-MODID
         LA    R5,CARD+33       *    2POS/BD-OF-LIST-ADR  2POS FILLER
         LA    R9,8(0)          *TALLY CT 8 PARMS MAX
CALL02   CLI   0(R5),C','       * Q. LAST PARM
         BE    CALL03           *    NO
CALL02A  NOP   CALLSR12   THIS BR IS EXEC WHEN CALL OF RRGEN SORT MOD
CALL02AA NOP   CALLBIN1   THIS BR EXEC WHEN CALL OF RRBINARY
         LA    R3,4(0)       ***POINT R4
         SR    R4,R3         ***BACK TO LAST PARM IN LIST
CALL02B  MVI   0(R4),X'80'    * YES FLAG AS LAST ONE
         L     R4,ENDUSER
         B     CALL04
CALL03   MVC   CARD+19(4),1(R5)   MOVE IN NEXT PARM
         BAL   R14,CALLST01         GO CONVERT IT TO ACTUAL
         ST    R3,0(R4)             STORE ACTUAL ADR IN LIST
         LA    R4,4(R4)         POINT R4 TO ADR TO STORE NEXT PARM ADR
         LA    R5,5(R5)             BUMP 5 TO POINT TO NEXT PARM IN CD
         BCT   R9,CALL02          Q. END OF PARM (MAX 8)
         B     CALL02A            A-YES
CALL04   MVC   40(8,R4),MODULENA     YES-PUT MOD NAME AT END
         LH    R5,BDLIST     * BUMP BASE/DISP OF LIST BY 1
         LA    R5,1(R5)      *  TO ADJUST FOR IT BEING OFF
         STH   R5,48(R4)     *    STORE RESULT
         CLI   CARD+27,X'40'  Q. WERE ANY PARMS PASSED
         BE    CALL09A            NO - GO PUT ZEROS IN ACTUAL LIST ADR
         ST    R4,32(R4)         PUT ACTUAL LIST ADR IN
CALL04A  ST    R4,BINLISTA   STORE ACTUAL LIST ADR FOR BINARY SCH RTN
CALL05   NOP   CALL07              SW TO BYPASS CALLING MOD AGAIN
CALL06   LOAD  EPLOC=MODULENA       LOAD MODULE
         ST    R0,36(R4)  STORE ENTRY POINT LOC
         CLC   MODULENA,RRGENSRT  Q. IS IT CALL OF RRGEN SORT
         BNE   CALL08                NO
         L     R5,ADRUBASE  MUST BE LOADED, SRT4,8,12 IN COMM AREA
         L     R3,36(R4)             YES-GET ACT ADR
         LA    R3,10(R3)             BUMP ACT BY 10
         ST    R3,SRT4               STORE FOR RELEASE ADR
         LA    R3,14(R3)           BUMP ACT BY 14
         ST    R3,SRT8               STORE FOR  SORT ADR
         LA    R3,14(R3)           BUMP ACT BY 14
         ST    R3,SRT12              STORE FOR RETURN ADR
CALL08   CLC   MODULENA,TAPECLAS       Q. TAPECLASS
         BNE   CALL08A                     NO
         MVI   TAPECLSW+1,X'00'  TURN ON SW TO TAKE ABEND IF PARMS BAD
         L     R1,32(R4)                   YES - LOAD LIST ADR
         L     R15,36(R4)                      LOAD EPLOC
         BALR  R14,R15                   GO TO TAPECLASS
         LA    R14,0(0,0)
         CR    R14,R15                 Q. GOOD RETURN
         BNE   RDERR                       NO - GO FLAG AS ERROR
         B     PARPRT                      YES - GO PRINT
CALL08A  CLC   MODULENA,RRBINARY       Q. IS IT THE BINARY SEARCH
         BNE   CALL09                    NO
         MVC   BINADR,36(R4)    YES MOVE IN EPA OF RRBINARY MODULE
CALL09   MVC   CALLINST+2(2),48(R4)      BASE/DISP ADR TO GEN CODE
         MVI   CALL05+1,X'00'        NOP BYPASSING LOAD INST
         MVC   INSHOLD(6),CALLGEN1    * MOVE
         MVC   INSHOLD+8(6),CALLGEN2  *  GENERATED
         MVC   INSHOLD+16(6),CALLGEN3 *   CODE
         MVC   INSHOLD+24(4),CALLGEN4  *    IN-LINE
         MVC   INSHOLD+32(6),CALLGEN5
         MVC   INSHOLD+40(8),CALLGEN6
         MVC   INSHOLD+48(6),CALLGEN7
         CLC   MODULENA,RRBINARY   Q. IS THIS RRBINARY SEARCH
         BNE   PARPRT                 NO-GO PRT & INSERT CODE
         L     R1,BINLISTA     ACTUAL LIST ADR
         L     R15,BINADR      EPA OF BINARY SEARCH
         BALR  R14,R15         GO LET HIM DO HSKING
         LA    R14,0(0,0)      SET 14 TO ZEROS
         CR    R14,R15      Q. WAS PARMS VALID
         BNE   RDERR           NO-GO TO FLAG AS ERROR
         B     PARPRT         YES- GO PRT & INSERT CODE
CALL09A  MVC   32(4,R4),CHEXZERO    R1 WILL EQ ZEROS IF NO PARMS
         B     CALL04A                WERE PASSED
CHEXZERO DC    XL4'00'
CALL07   MVC   36(4,R4),CARD   PUT EPLOC IN FOR PREVIOUSLY LOADED
         MVI   CALL05+1,X'00'    NOP BYPASSING LOAD INST
         B      CALL08
* GEN CODE FOR CALL MACRO
CALLGEN1 DC    XL2'03'
CALLINST LA    R2,0(0)            LOAD ADR OF INFO ABOUT MOD
CALLGEN2 DC    XL2'03'
         L     R1,32(R2)      LOAD ACTUAL LIST ADR
CALLGEN3 DC    XL2'03'
         L     R15,36(R2)     LOAD ACTUAL EPLOC
CALLGEN4 DC    XL2'01'
         BALR  R14,R15            GO TO MOD
CALLGEN5 DC    XL2'03'
         CVD   R15,RTCD       CONVERT RETURN CODE TO DEC
CALLGEN6 DC    XL2'05'
         UNPK  RTCD(4),RTCD+4(4)      CONVERT RETURN CODE TO ZONED
CALLGEN7 DC    XL2'03'
         OI    RTCD+3,X'F0'  ELIM C ON LAST POS
* THIS RTN CONVERTS LIST ADR  WHICH SHOULD BE IN CARD+19 TO:1ST
*  BASE/DISP AND THEN TO ACTUAL
CALLST01 ST    R14,CALLHOLD  SAVE RETURN ADR
         CLC   CARD+19(4),C0000    Q. IS ADR > OR = 0000
         BL    RDERR                  NO . ERROR
         CLC   CARD+19(4),C5999    Q. IS ADR < 5999
         BH    RDERR                  YES - ERROR
         MVC   ADR2,CALST03A         *PUT RTN ADR IN ADRRTN AND GO LET
         ST    R4,CALLWK       SAVE 4
         B     AADRRTN               *ADRRTN CONV IT TO BASE/DISP
CALLST03 L     R4,CALLWK          RELOAD 4 AFTER ADR RTN
         ST    R10,CALLWK
         LA    R10,OURCODE   CHG 10 TO WHAT IT WILL BE AT USER TIME
         MVC   CALLST04+2(2),B2D2    /CHG BASE/DISP
CALLST04 LA    R3,*+0                /  TO ACTUAL
         L     R10,CALLWK           RELOAD REG 10
         L     R14,CALLHOLD         (RETURN
         BR    R14                    TO USER)
CALLHOLD DC    1F'0'       HOLD AREA FOR RETURN ADR
CALLWK   DC    1F'0'
CALST03A DC    S(CALLST03)    THE ADR WHERE WE WANT THE ADRRTN TO RETN
USINGCON DC    CL7',USING,'
         DS    0F
C0000    DC    CL4'0000'
C5999    DC    CL4'5999'
MODULENA DC    CL8' '
TAPECLAS DC    CL8'TAPECLAS'
CALLSR10 NOP   RDERR            *CAN ONLY CALL RRGENSRT
         MVI   CALLSR10+1,X'F0'   * ONE TIME
         MVC   SORTTAGS,CARD+44    SAVE TGS FOR END OF PARS LOGIC
*  VALID AT TAGS FOR IN + OUT PROCEDURES
         CLC   CARD+44(2),=C'TG'       Q. VALID TAG , IN ADR
         BNE   RDERR                      NO
         CLC   CARD+49(2),=C'TG'       Q. VALID TAG , OUTPUT PROC ADR
         BNE   RDERR                      NO
         MVC   SIZEWK+2(2),CARD+46
         BAL   R14,CNVRTN                 *CONVERT TG # TO BINARY
         C     R3,FFCON                Q.          WAS IT VALID
         BE    RDERR                      NO
         C     R3,ZERO                 Q  TAG # ZERO
         BE    RDERR                         YES-INVALID
         MVI   SORTSW+1,X'00'  SET SORT SW IN PAREND LOGIC
         MVC   SIZEWK+2(2),CARD+51
         BAL   R14,CNVRTN
         C     R3,FFCON                Q. VALID TG #
         BE    RDERR                             NO-INVALID
         C     R3,ZERO                 Q. TAG # ZERO
         BE    RDERR                         YES-INVALID
         MVI   CARD+43,C' '        CLEAR COMMA BEFORE TAGS IN CARD
*  ELIMINATES CALL RTN LOOKING AT 2 TG ADR IN CALL OF RRGEN SRT CARD '
         MVI   CALL02A+1,X'F0'  THIS WILL SET A SWITCH TO BRANCH BACK
*                               TO CALLSR12 BEFORE CALL RTN FLAGS
*                               LAST PARM IN LIST. WE MUST ADD TWO ADRS
*                               TO LIST(INPUT + OUTPUT PROCEDURE ADRS)
*                NOTE: REG 4 WILL POINT TO WHERE NEXT PARM ADR IS TO
*                      BE STORED
         B     CALL01           GO BACK TO NORMAL CALL LOGIC
CALLSR12 MVC   0(4,R4),INADR    MOVE ACT ADR OF INPUT PROC TO LIST
         LA    R4,4(R4)         BUMP BY 4
         MVC   0(4,R4),OUTADR   MOVE ACT ADR OF OUTPUT PROC TO LIST
         LA    R4,4(R4)     BUMP BY 4
         MVC   0(4,R4),SORTREC   MOVE SORT REC ACT ADR INTO LIST
         B     CALL02B          GO BACK TO NORMAL LOGIC
CALLSR20 MVC   SORTRI1+2(2),BDSRT4  MOVE BD ADR OF EPA OF RELEASE
         B     CALLSR32
CALLSR30 MVC   SORTRI1+2(2),BDSRT12 MOVE BD ADR OF EPA OF RETURN
CALLSR32 MVC   INSHOLD(6),SORTRS1   *MOVE GEN CODE
         MVC   INSHOLD+8(4),SORTRS2    IN-LINE
         B     PARPRT               GO PRINT AND INSERT CODE
CALLBIN1 L     R5,ADRUBASE   MUST BE LOADED
         MVC   0(4,R4),INX1ADRB     MOVE ACT ADR OF INX1 TO LIST
         LA    R4,4(R4)             BUMP 4 BY 4
         MVC   0(4,R4),BINPMADR   MOVE ADR OF PARMS IN       PARENDS
         B     CALL02B            GO BACK TO NORMAL       LOGIC
INADR    DC    A(INPROC)
OUTADR   DC    A(OUTPROC)
SORTREC  DC    A(OURCODE+3000)     SORT RECORD AREA 5000
RRBINARY DC    CL8'RRBINARY'
BINADR   DC    1F'0'       ENTRY POINT ADR OF RRBINARY STORED HERE
BINPARMS DC    CL20'0'
BINPMADR DC    A(BINPARMS)
BINLISTA DC    1F'0'
INX1ADRB DC    A(INX1)
SORTRS1  DC    XL2'03'
SORTRI1  L     R15,HEXWORK LOAD ADR OF ENTRY POINT
SORTRS2  DC    XL2'01'
         BALR  R14,R15     BR TO IT
BDSRT4   DC    S(SRT4)
BDSRT12  DC    S(SRT12)
RRGENSRT DC    CL8'RRGENSRT'
RELEASE  DC    CL8'RELEASE '
RETURNC  DC    CL8'RETURN  '
         EJECT
XCONS1   EQU   *
* THIS RTN CONVERTS HEX DIGITS TO BYTES  EG C1 ON CARD = A IN STORAGE
*   AFTER  CONVERSION TO BYTES CONTROL IS PASSED TO CONSRTN TO PLACE
*    CONSTANT IN MEMORY
         L     R3,SIZEHLD    *LOAD BINARY SIZE
         AR    R3,R3         *ADD IT TO ITSELF
         LA    R3,1(R3)      *ADD 1 TO IT = # OF HEX DIGITS
         ST    R3,HEXWORK     STORE IT
         MVC   XCONS02+1(1),HEXWORK+3  MOVE COMPUTED SIZE TO TRANSLATE
         MVC   XCONS03+1(1),HEXWORK+3
         MVC   HEXTR(40),HEXTR+50    CLEAR FIRST 40 POSITIONS
XCONS02  TR    CARD+33(40),HEXTR     TRANSLATE  F0=00 F9=09 C1=0A C6=0F
XCONS03  NC    HEXTR(40),CARD+33    Q.  ALL TOP BITS OFF
         BM    ML04A                    NO-BAD HEX DIGIT - GO FLAG ERR
         MVC   HEXTR(40),CARD+33     MOVE CARD FOR PACKING
         PACK  CARD+33(8),HEXTR(15)    * CONVERT
         PACK  CARD+40(8),HEXTR+14(15) *  DIGITS TO
         PACK  CARD+47(7),HEXTR+28(13) *   CHARACTERS
         B     CONSRTN         GO LET CONSTANT RTN STORE IT
HEXWORK  DC    1F'0'
HEXTR    DC    CL193' '
         DC    XL6'0A0B0C0D0E0F'
         DC    CL41' '
         DC    XL10'00010203040506070809'
         DC    CL6' '
         EJECT
DEBUGRTN EQU   *
         L     R5,UBASE      SET 5 TO USER BASE
         ST    R5,HEXHLD               STORE ADR
         BAL   R14,HEXRTN              CONVERT TO HEX  A=C1
         MVC   RECCTCON+30(6),CONVHEX+2
         LA    R5,4(R5)                POINT 5 TO INP1 REC COUNT
         ST    R5,HEXHLD
         BAL   R14,HEXRTN
         MVC   RECCTCON+42(6),CONVHEX+2
         LA    R5,4(R5)                5=INP2
         ST    R5,HEXHLD
         BAL   R14,HEXRTN
         MVC   RECCTCON+54(6),CONVHEX+2
         LA    R5,4(R5)                INP3
         ST    R5,HEXHLD
         BAL   R14,HEXRTN
         MVC   RECCTCON+66(6),CONVHEX+2
         LA    R5,4(R5)                OUT1
         ST    R5,HEXHLD
         BAL   R14,HEXRTN
         MVC   RECCTCON+78(6),CONVHEX+2
         LA    R5,4(R5)                OUT2
         ST    R5,HEXHLD
         BAL   R14,HEXRTN
         MVC   RECCTCON+90(6),CONVHEX+2
         LA    R5,4(R5)                OUT3
         ST    R5,HEXHLD
         BAL   R14,HEXRTN
         MVC   RECCTCON+102(6),CONVHEX+2
      LA       R5,4(R5)                CARD
         ST    R5,HEXHLD
         BAL   R14,HEXRTN
         MVC   RECCTCON+114(6),CONVHEX+2
         MVC   HEXHLD(4),P000           CONVERT
         BAL   R14,HEXRTN                  ACTUAL PRT ADR
         MVC   AREALCON+30(6),CONVHEX+2
         MVC   HEXHLD(4),CD00
         BAL   R14,HEXRTN               CARD ADR
         MVC   AREALCON+114(6),CONVHEX+2
         MVC   HEXHLD(4),CONSACT
         BAL   R14,HEXRTN              CONS ADR
         MVC   AREALCO2+52(6),CONVHEX+2
         LA    R10,OURCODE+4096         R10=LHE OUT 1
         ST    R10,HEXHLD
         BAL   R14,HEXRTN
         MVC   AREALCON+78(6),CONVHEX+2
         LA    R10,900(R10)             OUT I
         ST    R10,HEXHLD
         BAL   R14,HEXRTN
         MVC   AREALCON+90(6),CONVHEX+2
         LA    R10,900(R10)            OUT 3
         ST    R10,HEXHLD
         BAL   R14,HEXRTN
         MVC   AREALCON+102(6),CONVHEX+2
         MVC   HEXHLD(4),INX1ACON
         BAL   R14,HEXRTN
         MVC   AREALCO2+10(6),CONVHEX+2
         MVC   HEXHLD(4),INX2ACON
         BAL   R14,HEXRTN
         MVC   AREALCO2+24(6),CONVHEX+2
         MVC   HEXHLD(4),RESULTAC
         BAL   R14,HEXRTN
         MVC   AREALCO2+38(6),CONVHEX+2
         MVC   PRTAREA(133),PRTAREA-1
         PUT   PRINTER,PRTAREA+1
         MVC   PRTAREA+50(14),DEBUGCON   MOVE IN DEBUG HDR
         PUT   PRINTER,PRTAREA+1
         MVC   PRTAREA+1(120),RECCTCON  RECORD COUNT LOC
         PUT   PRINTER,PRTAREA+1
         MVC   PRTAREA+1(120),AREALCON   AREA LOCATIONS
         PUT   PRINTER,PRTAREA+1
         MVC   PRTAREA(133),PRTAREA-1
         MVC   PRTAREA+16(58),AREALCO2
         PUT   PRINTER,PRTAREA+1
         L     R5,UBASE      SET 5 TO USER BASE
         MVC   PRTAREA(133),PRTAREA-1
         PUT   PRINTER,PRTAREA+1    SPACE 1 LINE
         B     CLEAR01
UBASE    DC    A(USERBASE)
P000     DC    A(PRTAREA+1)
CD00     DC    A(CARD)
CONSACT  DC    A(CONS)
INX1ACON DC    A(INX1)
INX2ACON DC    A(INX2)
RESULTAC DC    A(RESULT)
DEBUGCON DC    CL14'DEBUGGING AIDS'
RECCTCON DC    CL49'RECORD COUNT LOCATIONS  PRINT=XXXXXX INP1=XXXXXX '
         DC    CL48'INP2=XXXXXX INP3=XXXXXX OUT1=XXXXXX OUT2=XXXXXX '
         DC    CL23'OUT3=XXXXXX CARD=XXXXXX'
AREALCON DC    CL50'AREA LOCATIONS          P000 =XXXXXX A000=REG7   B'
ARE      DC    CL50'000=REG8   C000=REG9   J000=XXXXXX K000=XXXXXX L00'
         DC    CL20'0=XXXXXX CD00=XXXXXX'
AREALCO2 DC    CL47'     INX1=XXXXXX   INX2=XXXXXX   RS00=XXXXXX   '
         DC    CL11'0000=XXXXXX'
         EJECT
REGS     DSECT
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         END   OURCODE
