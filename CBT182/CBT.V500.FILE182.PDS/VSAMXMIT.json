{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "TRIDJK", "INMTNODE": "TO", "INMTUID": "CBT", "INMFTIME": "20200428155740000000", "INMNUMF": 2}, "INMR02": {"1": {"INMUTILN": "INMCOPY", "INMSIZE": 96, "INMDSORG": "PS", "INMLRECL": 251, "INMBLKSZ": 3120, "INMRECFM": "VB", "numfile": 1}, "2": {"INMUTILN": "IEBCOPY", "INMSIZE": 176358, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 3120, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "TRIDJK.VI.PDS", "numfile": 2}, "3": {"INMUTILN": "INMCOPY", "INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 2}}, "INMR03": {"1": {"INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}, "2": {"INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "message": {"file": "b'\\xe2\\xd4\\xe2a\\xd9\\xd3\\xe2@\\x89\\x95\\x86\\x96\\x99\\x94\\x81\\xa3\\x89\\x96\\x95@\\x81\\x84\\x84\\x85\\x84@\\x82\\xa8@\\xd1\\x89\\x94@\\xe3\\xa4\\x99\\x95\\x85\\x99k@\\xe3\\xd9\\xc9\\xe2\\xc5\\xd9\\xe5'", "lrecl": 80, "text": "SMS/RLS information added by Jim Turner, TRISERV\n"}, "file": {"TRIDJK.VI.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 3120, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 32, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200119", "DS1SCEXT": "b'\\x80\\x0c0'", "DS1SCALO": "b'P\\x00\\x00\\x0f'", "DS1LSTAR": "b'\\x00\\x04\\x12'", "DS1TRBAL": "b'=~'"}, "COPYR2": {"deb": "b'\\x02\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x1a\\x80\\x00\\x04\\x9a\\x80P'", "extents": ["b'\\x02\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x1a\\x80\\x00\\x04\\x9a\\x80P'", "b'X\\xf4\\xec\\x00\\x00\\x00\\x03\\x0b\\x00\\x0c\\x03\\x0c\\x00\\x00\\x00\\x04'", "b'X\\xf4\\xec\\x00\\x00\\x00\\x02\\xec\\x00\\x0c\\x02\\xec\\x00\\x0c\\x00\\x01'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$VSAM": {"ttr": 9, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x0e\\x00!\\x01\\x10\\x04\\x8f\\x01\\x17'\\x0f\\x08S\\x00\\r\\x00\\x08\\x00\\x00\\xe3\\xd9\\xc9\\xc4\\xd1\\xd2@@@@\"", "ispf": {"version": "01.14", "flags": 0, "createdate": "2010-02-17T00:00:00", "modifydate": "2017-09-27T08:53:21", "lines": 13, "newlines": 8, "modlines": 0, "user": "TRIDJK"}, "text": "To install the Steve Kleeves VSAM Information dialog (CBT File 137).\n\n1.  TSO RECEIVE the VSAMXMIT member.\n2.  Copy panels VI#1 and VI#1H to an ISPPLIB dataset.\n3.  Copy rexxes VI, VIX, and RXDATE to a SYSPROC or SYSEXEC dataset.\n\nTo run the VSAM Information dialog.\n\n1.  Enter the VS line command on the PDS LISTC function display.\n2.  Enter the VI/VIX line command on the ISPF 3.4 DSLIST display.\n\nNote: use the VIX rexx exec if you need to define LIBDEF's.\n      First, it must be customized with your own exec and panel DSN's.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$CHANGES": {"ttr": 1028, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00X\\x01 \\x11\\x9f\\x01 \\x11\\x9f\\x10H\\x00\\x08\\x00\\x08\\x00\\x00\\xe3\\xd9\\xc9\\xc4\\xd1\\xd2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-04-28T00:00:00", "modifydate": "2020-04-28T10:48:58", "lines": 8, "newlines": 8, "modlines": 0, "user": "TRIDJK"}, "text": "*----------------------------------------------------------------------*\n*                          VI - Changes                                *\n*----------------------------------------------------------------------*\n\n  28 Apr 2020\n     - Jim Turner (jim_turner@triserv.com) added additional\n       informational fields for SMS/RLS and made the VI#1 panel\n       scrollable.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXDATE": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x11\\x00$\\x00\\x97(\\x9f\\x01 \\x11\\x9f\\x10C\\x03\\xb9\\x03\\xb1\\x00\\x00\\xe3\\xd9\\xc9\\xc4\\xd1\\xd2@@@@'", "ispf": {"version": "01.17", "flags": 0, "createdate": "1997-10-16T00:00:00", "modifydate": "2020-04-28T10:43:24", "lines": 953, "newlines": 945, "modlines": 0, "user": "TRIDJK"}, "text": "/*% NOCOMMENT REXX\n\n  RXDATE -- provides enhancements to all options of the DATE() function\n  provided by REXX, and also provides 9 additional options.\n\n  Source:   Bruce Sacco (dc.sysf80@ts3.teale.ca.gov)\n            via the TSO REXX Discussion List\n\n  Author:   Steve Rushing of the Health and Welfare Data\n            Center, State of Calif.\n\n  Mods:     John Kalinich (jkalinic@csc.com) Year 2000 (Oct 1997)\n\nThe format of the RXDATE function is:\n\n  +--------------------------------------------------------------+\n    RXDATE((option,parm1,parm2))\n  +--------------------------------------------------------------+\n\nOptions:\n\n  NULL option i.e. RXDATE() or RXDATE(,parm1) converts the date\n     supplied in parm1 to the format 'dd Mmm yyyy', and returns it\n     as the value of the function.\n\n     parm1 = a Date in the format mm/dd/yy or mm/dd/yyyy\n     parm2 = not used\n\n     e.g.  RXDATE(,'10/06/85')   returns ===> 06 Oct 1985\n           RXDATE(,'10/06/2000') returns ===> 06 Oct 2000\n\n  C  (Century); returns as the function value, the number of day into\n     the century the date represents. The returned value is of the form\n     ddddd with no leading zeroes.\n\n     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy\n     parm2 = not used\n\n     e.g.  RXDATE(c,'01/10/85')   returns ===> 31056\n           RXDATE(c,'01/10/1800') returns ===> 10\n\n  D  (Days); returns as the function value, the number of days into the\n     year, the date represents.\n\n     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy\n     parm2 = not used\n\n     e.g.  RXDATE(d,'01/10/85')   returns ===> 10\n           RXDATE(d,'07/10/1800') returns ===> 191\n\n  E  (European); returns as the value of the function, dd/mm/yy if\n     the date supplied in parm1 is >= the 1900's, or dd/mm/yyyy if\n     the date supplied in parm1 is < the 1900's.\n\n     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy\n     parm2 = not used\n\n     e.g.  RXDATE(e,'01/23/85')   returns ===> 23/01/85\n           RXDATE(e,'01/23/1800') returns ===> 23/01/1800\n\n  J  (Julian-OS); returns as the value of the function, yyddd\n     representing the date supplied in parm1.\n\n     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy\n     parm2 = not used\n\n     e.g.  RXDATE(j,'07/23/85')   returns ===> 85204\n           RXDATE(j,'07/23/1885') returns ===> 85204\n\n  M  (Month); returns as the value of the function, the full name of\n     the month, for the date supplied in parm1.\n\n     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy\n     parm2 = not used\n\n     e.g.  RXDATE(m,'01/23/85')   returns ===> January\n           RXDATE(m,'07/23/1885') returns ===> July\n\n  O  (Ordered); returns as the value of the function,  yy/mm/dd if the\n     date supplied in parm1 is >= the 1900's, or yyyy/mm/dd if the date\n     supplied in parm1 is < the 1900's.\n\n     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy\n     parm2 = not used\n\n     e.g.  RXDATE(o,'07/23/85')   returns ===> 85/07/23\n           RXDATE(o,'07/23/1885') returns ===> 1885/07/23\n\n  S  (Sorted); returns as the value of the function, yyyymmdd\n     representing the date supplied in parm1\n\n     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy\n     parm2 = not used\n\n     e.g.  RXDATE(s,'07/23/85')   returns ===> 19850723\n           RXDATE(s,'07/23/1885') returns ===> 18850723\n\n  U  (USA); returns as the value of the function,  mm/dd/yy if the\n     date supplied in parm1 is >= the 1900's, or mm/dd/yyyy if the date\n     supplied in parm1 is < the 1900's. If you just want the\n     current date, the built-in DATE() function is more efficient.\n\n     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy\n     parm2 = not used\n\n     e.g.  RXDATE(u,'07/23/85')   returns ===> 07/23/85\n           RXDATE(u,'07/23/1985') returns ===> 07/23/85\n           RXDATE(u,'07/23/1885') returns ===> 07/23/1885\n\n  W  (WEEKDAY) returns as the value of the function, the full name of\n     the day-of-the-week, for the date specified in parm1.\n\n     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy\n     parm2 = not used\n\n     e.g.  RXDATE(w,'01/01/2000') returns ===> Saturday\n           RXDATE(w,'07/04/1776') returns ===> Thursday\n\n  1  Converts TRUE Julian number to corresponding GREGORIAN date,\n     and returns the GREGORIAN date as the value of the function.\n\n     parm1 = null (TRUE julian number for current date) or\n             number in range 1721426-5373484 inclusive.\n                 1721426 = 01/01/0001\n                 5373484 = 12/31/9999\n     parm2 = not used\n\n     e.g.  RXDATE(1,2446270)   returns ===> 07/23/85\n           RXDATE(1,2455198)   returns ===> 01/01/2010\n\n  2  Converts GREGORIAN date to corresponding TRUE Julian number, and\n     returns the TRUE julian number as the value of the function.\n\n     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy\n     parm2 = not used\n\n     e.g.  RXDATE(2,'07/23/85')   returns ===> 2446270\n           RXDATE(2,'01/01/2010') returns ===> 2455198\n\n  3  Converts Julian-OS (yyddd) to TRUE Julian number, and returns the\n     TRUE julian number as the value of the function.\n\n     parm1 = null (Julian-OS for current date) or yyddd\n             yy assumed if >= 1900's\n     parm2 = not used\n\n     e.g.  RXDATE(3,85100)   returns ===> 2446166\n\n  4  Converts TRUE Julian number to Julian-OS, and returns the\n     Julian-OS as the value of the function.\n\n     parm1 = null (TRUE julian number for current date) or\n             number in range 1721426-5373120 inclusive.\n                 1721426 = 01/01/0001\n                 5373120 = 12/31/9999\n     parm2 = not used\n\n     e.g.  RXDATE(4,2446270)   returns ===> 85204    07/23/85\n           RXDATE(4,2455198)   returns ===> 10001    01/01/2010\n\n     *** note -- Obviously this makes sense only for the 1900's.\n\n  5  Converts Julian-OS to GREGORIAN date, and returns the GREGORIAN\n     date as the value of the function.\n\n     parm1 = null (Julian-OS for current date) or yyddd\n             yy assumed if >= 1900's\n     parm2 = not used\n\n     e.g.  RXDATE(5,85205)   returns ===>  07/24/85\n\n  6  Returns the date xx days hence or before.  Base date supplied in\n     parm1, number of days hence (+ or -) supplied in parm2.\n\n     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy\n     parm2 = null (0) or positive/negative integer\n\n     e.g.  RXDATE(6,,1)            returns ===>  next day's date\n           RXDATE(6,'07/23/85',10) returns ===>  08/02/85\n           RXDATE(6,'07/23/85',-5) returns ===>  07/18/85\n\n  7  Returns as the value of the function, the number of days from one\n     date to another. The number of days from one day to the next is\n     considered one (1).\n\n     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy\n     parm2 = null (current date) or mm/dd/yy or mm/dd/yyyy\n\n     e.g.  RXDATE(7,,'01/01/2000')             returns ===>  5288\n                  (assuming current date is 7/10/85)\n           RXDATE(7,'01/01/1900','01/01/2000') returns ===> 36524\n           RXDATE(7,'01/01/2000','01/01/1900') returns ===> 36524\n\n  8  Returns as the value of the function, the number of the\n     day-of-the-week, 1-7 for Sunday-Saturday respectively, for\n     date specified in parm1.\n\n     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy\n     parm2 = not used\n\n     e.g.  RXDATE(8,'01/01/2000') returns ===> 7\n           RXDATE(8,'07/04/1776') returns ===> 5\n\n  9  Edits the supplied date.  Returns '1' if date supplied in parm1 is\n     valid; returns 'ERROR' if date is invalid.\n\n     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy\n     parm2 = not used\n\n     e.g.  RXDATE(9,'a1/01/2000') returns ===> ERROR\n           RXDATE(9,'01/33/1985') returns ===> ERROR    (33 not valid)\n           RXDATE(9,'07/04/1776') returns ===> 1\n           RXDATE(9,'02/29/85')   returns ===> ERROR    (not leap year)\n           RXDATE(9,'02/29/84')   returns ===> 1\n\n\nDefaults:\n\n  Discussed under each option.\n\n====================== NOTES NOTES NOTES =======================\n\nWhen specifying dates in the parms, the date can be supplied as\nmm/dd/yy, or mm/dd/yyyy. This allows for dates not in the 1900's.\nAny date of the form mm/dd/yy is assumed in the 1900's if yy is >=\nthe value of the date window variable (win19xx)..\n\nFor options requesting a date be returned in the form mm/dd/yy,\ndd/mm/yy, or yy/mm/dd, the yy portion will be 2 digits if the year is\n>= the 1900's or 4 digits if < the 1900's.\n\nThe RXDATE function emulates all of the options of the REXX built-\nin function DATE(), and also has nine (9) other options.  The REXX\nbuilt-in DATE() function however, returns data concerning the current\ndate only; for example DATE(M) will return the full name of the current\nmonth, whereas RXDATE(M) will do the same thing, but you can specify\na parm i.e. RXDATE(M,'02/13/86') which will return 'February'.\n\nThis is true for all of the RXDATE options which correspond to the\nsame option for the REXX DATE built-in function.\n\nOptions C, D, E, J, M, O, S, U, and W are the same as for the DATE\nbuilt-in function, except you can specify any date as a parm. As another\nexample of this, if today is Wednesday, and you execute code DATE(W),\nor RXDATE(W), 'Wednesday' will be returned from the function; if you\nwant to know what day January 1, 2000 is, you can code:\n\n          day = RXDATE(W,'01/01/2000')\n\nand the variable 'day' will contain 'Saturday'.\n\n===================== END OF NOTES ============================= */\n\n   trace\n\n   option = arg(1)\n   parm1  = arg(2)\n   parm2  = arg(3)\n\n   CALL INIT_LOGIC\n   CALL MAIN_LOGIC\n   CALL CLOSING_LOGIC\n   If errors_present = true\n   then\n   EXIT 'ERROR'\n   else\n   EXIT answer\n\nINIT_LOGIC:\n\n   ONCE = 1\n   TRUE = 1\n   FALSE = 0\n   NULL = ''\n   ERRORS_PRESENT = FALSE\n   STACK_DELIMITER = 'FAFBFCFDFEFFFEFDFCFBFA'X\n   HI = '1DC8'X\n   LO = '1D60'X\n   existing_date_options = 'CDEJMOSUW'\n   new_date_options = '123456789'\n   option_string = 'CDEJMOSUW123456789'\n   options_returning_data_with_slashes = 'EOU156'\n   first_parm_mmddyy_options = 'CDEJMOSUW26789'\n   first_parm_true_julian_options = '14'\n   first_parm_false_julian_options = '35'\n   second_parm_numeric_options = '6'\n   second_parm_mmddyy_options = '7'\n\n   RETURN\n\nMAIN_LOGIC:\n\n   call edit_options_and_parms\n\n   do once while errors_present = false\n      select\n         when option = ''  then\n         answer = date_function_for_null_option(parm1)\n         when index(existing_date_options,option) /= 0 then\n         call emulate_existing_function_with_extended_capability\n         when index(new_date_options,option) /= 0 then\n         call perform_functions_of_new_options\n         otherwise\n         nop\n      end\n   end\n\n   RETURN\n\nemulate_existing_function_with_extended_capability:\n\n   select\n      when option = 'C' then\n      answer = number_of_days_from_start_of_century(parm1)\n      when option = 'D' then\n      answer = number_of_days_from_start_of_year(parm1)\n      when option = 'E' then\n      answer = date_in_european_format(parm1)\n      when option = 'J' then\n      answer = julian_os_the_false_julian(parm1)\n      when option = 'M' then\n      answer = full_name_of_the_month(parm1)\n      when option = 'O' then\n      answer = date_in_form_YY_MM_DD(parm1)\n      when option = 'S' then\n      answer = date_in_form_YYYYMMDD(parm1)\n      when option = 'U' then\n      answer = date_in_form_MM_DD_YY(parm1)\n      when option = 'W' then\n      answer = full_name_of_the_day(parm1)\n      otherwise\n      nop\n   end\n\n   Return answer\n\nperform_functions_of_new_options:\n\n   select\n      when option =  1  then\n      answer = convert_true_julian_to_gregorian(parm1)\n      when option =  2  then\n      answer = convert_gregorian_to_true_julian(parm1)\n      when option =  3  then\n      answer = convert_false_julian_to_true_julian(parm1)\n      when option =  4  then\n      answer = convert_true_julian_to_false_julian(parm1)\n      when option =  5  then\n      answer = convert_false_julian_to_gregorian(parm1)\n      when option =  6  then\n      answer = number_of_days_hence_plus_or_minus(parm1,parm2)\n      when option =  7  then\n      answer = difference_in_days_between_two_dates(parm1,parm2)\n      when option =  8  then\n      answer = return_day_of_week_1_thru_7(parm1)\n      when option =  9  then\n      answer = just_edit_the_date(parm1)\n      otherwise\n      nop\n   end\n\n   Return\n\nCLOSING_LOGIC:\n\n   call reformat_year_in_answer_to_2_digits_if_1900s\n\n   RETURN\n\nreformat_year_in_answer_to_2_digits_if_1900s:\n\n   do once while errors_present = false &,\n        index(options_returning_data_with_slashes,option) /= 0\n      parse value answer with v1 '/' v2 '/' v3 .\n      select\n         when length(v1) > 2 then\n         do\n            if substr(v1,1,2) >= '19' then v1 = 2digit(v1)\n         end\n         when length(v2) > 2 then\n         do\n            if substr(v2,1,2) >= '19' then v2 = 2digit(v2)\n         end\n         when length(v3) > 2 then\n         do\n            if substr(v3,1,2) >= '19' then v3 = 2digit(v3)\n         end\n         otherwise\n         nop\n      end\n      answer = v1 '/' v2 '/' v3\n      answer = space(answer,'0')\n   end\n\n   Return\n\ndate_function_for_null_option: procedure\n\n   arg parm1\n   parse value parm1 with mm '/' dd '/' yy .\n\n   answer = right(dd,2,'0') substr(name_of_month_text(mm),1,3),\n     4digit_year(yy)\n\n   answer = space(answer,'1')\n\n   Return answer\n\nnumber_of_days_from_start_of_century: procedure\n\n   arg parm1\n   parse value parm1 with mm '/' dd '/' yy .\n   yy = 4digit_year(yy)\n   century_yr = century(yy)\n   answer = jnum(mm,dd,yy) - jnum(1,1,century_yr) + 1\n\n   Return answer\n\nnumber_of_days_from_start_of_year: procedure\n\n   arg parm1\n   parse value parm1 with mm '/' dd '/' yy .\n   yy = 4digit_year(yy)\n   answer = jnum(mm,dd,yy) - jnum(01,01,yy) + 1\n\n   Return answer\n\ndate_in_european_format: procedure\n\n   arg parm1\n   parse value parm1 with mm '/' dd '/' yy .\n   answer = space(dd '/' mm '/' yy,'0')\n\n   Return answer\n\njulian_os_the_false_julian: procedure\n\n   arg parm1\n   parse value parm1 with mm '/' dd '/' yy .\n   v1 = 2digit(yy)\n   v2 = number_of_days_from_start_of_year(parm1)\n   answer = v1||right(v2,3,'0')\n\n   Return answer\n\nfull_name_of_the_month: procedure\n\n   arg parm1\n   parse value parm1 with mm '/' .\n   answer = name_of_month_text(mm)\n\n   Return answer\n\ndate_in_form_YY_MM_DD: procedure\n\n   arg parm1\n   parse value parm1 with mm '/' dd '/' yy .\n   answer = yy '/' mm '/' dd\n   answer = space(answer,'0')\n\n   Return answer\n\ndate_in_form_YYYYMMDD: procedure\n\n   arg parm1\n   parse value parm1 with mm '/' dd '/' yy .\n   answer = 4digit_year(yy) 2digit(mm) 2digit(dd)\n   answer = space(answer,'0')\n\n   Return answer\n\ndate_in_form_MM_DD_YY: procedure\n\n   arg parm1\n   answer = parm1\n\n   Return answer\n\nfull_name_of_the_day: procedure\n\n   arg parm1\n   parse value parm1 with mm '/' dd '/' yy .\n   answer = name_of_day_text(day_of_week(mm,dd,yy))\n\n   Return answer\n\nconvert_true_julian_to_gregorian: procedure\n\n   arg parm1\n   answer = gregday(parm1)\n\n   Return answer\n\nconvert_gregorian_to_true_julian: procedure\n\n   arg parm1\n   parse value parm1 with mm '/' dd '/' yy .\n   answer = jnum(mm,dd,yy)\n\n   Return answer\n\nconvert_false_julian_to_true_julian: procedure\n\n   arg parm1\n   answer =  fjul_tjul(parm1)\n\n   Return answer\n\nconvert_true_julian_to_false_julian: procedure\n\n   arg parm1\n   answer =  tjul_fjul(parm1)\n\n   Return answer\n\nconvert_false_julian_to_gregorian: procedure\n\n   arg parm1\n   answer =  gregday(fjul_tjul(parm1))\n\n   Return answer\n\nnumber_of_days_hence_plus_or_minus:\n\n   procedure expose errors_present true\n\n   parm1 = arg(1)\n   parm2 = arg(2)\n   parse value parm1 with mm '/' dd '/' yy .\n   select\n      when parm2 < 0 & abs(parm2) > (jnum(mm,dd,yy) - 1721426) then\n      do\n         errors_present = true\n      end\n      when parm2 >= 0 & parm2 >  (5373484 - jnum(mm,dd,yy)) then\n      do\n         errors_present = true\n      end\n      otherwise\n      do\n         answer = gregday(jnum(mm,dd,yy) + parm2)\n      end\n   end\n\n   Return answer\n\ndifference_in_days_between_two_dates: procedure\n\n   parm1 = arg(1)\n   parm2 = arg(2)\n   parse value parm1 with mm1 '/' dd1 '/' yy1 .\n   parse value parm2 with mm2 '/' dd2 '/' yy2 .\n   answer = abs(jnum(mm1,dd1,yy1) - jnum(mm2,dd2,yy2))\n\n   Return answer\n\nreturn_day_of_week_1_thru_7: procedure\n\n   arg parm1\n   parse value parm1 with mm '/' dd '/' yy .\n   yy = 4digit_year(yy)\n   answer = day_of_week(mm,dd,yy)\n\n   Return  answer\n\njust_edit_the_date: procedure\n\n/* date must be good or we would not get here */\n\n   answer = 1\n\n   Return answer\n\njnum: procedure\n\n   month = arg(1)\n   day   = arg(2)\n   year  = arg(3)\n\n   year  = 4digit_year(year)\n\n   numeric digits 15\n\n   If month > 2\n   then\n   month = month - 3\n   else\n   do\n      month = month + 9\n      year = year - 1\n   end\n\n   c =     year % 100\n   ya =     year - 100 * c\n   julian_number =    (146097 * c  % 4) +    ((1461 * ya) % 4) +,\n     ((153 * month + 2) % 5) + day + 1721119\n\n   return julian_number\n\nGREGDAY: procedure\n\n   jn = arg(1)\n   numeric digits 15\n   jn = jn - 1721119\n   year =    ((4 * jn - 1) % 146097)\n   jn =    (4 * jn - 1 - 146097 * year)\n   day =     jn % 4\n   jn =    ((4 * day + 3) % 1461)\n   day =    (4 * day + 3 - 1461 * jn)\n   day =    ((day + 4) % 4)\n   month =    ((5 * day - 3) % 153)\n   day   =    (5 * day - 3 - 153 * month)\n   day =    ((day + 5) % 5)\n   year =    (100 * year + jn)\n\n   If month < 10\n   Then\n   month = month + 3\n   Else\n   Do\n      month = month - 9\n      year  = year + 1\n   End\n\n   return mm_dd_yyyy(month,day,year)\n\nmm_dd_yy: procedure\n\n   mm = arg(1)\n   dd = arg(2)\n   yy = arg(3)\n\n   answer = right(month,2,'0') '/' right(day,2,'0') '/',\n     right(year,2,'0')\n   answer = space(answer,0)\n\n   return answer\n\nday_of_week: procedure\n\n   mm = arg(1)\n   dd = arg(2)\n   yy = arg(3)\n\n   w_var  =     (jnum(mm,dd,yy) - jnum(1,1,1984)) // 7\n\n   if w_var >= 0 then\n   answer = w_var + 1\n   else\n   answer = w_var + 8\n\n   Return answer\n\nTJUL_FJUL: procedure /* true julian to false julian */\n\n   true_julian_number = arg(1)\n   greg_date = gregday(true_julian_number)\n   greg_year = substr(greg_date,7,4)\n   false_julian_day = true_julian_number - jnum(1,1,greg_year) + 1\n   answer = substr(greg_year,3,2)||right(false_julian_day,3,'0')\n\n   return answer\n\nFJUL_TJUL: procedure /* false julian to true julian */\n\n   false_julian_number = arg(1)\n   false_julian_year   = substr(false_julian_number,1,2)\n   false_julian_day    = substr(false_julian_number,3,3)\n   answer = jnum(1,1,false_julian_year) + false_julian_day - 1\n\n   return answer\n\nmm_dd_yyyy: procedure\n\n   mm   = arg(1)\n   dd   = arg(2)\n   yyyy = arg(3)\n\n   answer = right(mm,2,'0') '/' right(dd,2,'0') '/',\n     right(yyyy,4,'0')\n   answer = space(answer,'0')\n\n   return answer\n\nedit_options_and_parms:\n\n   call edit_options\n   do once while errors_present = false\n      call edit_parms\n   end\n\n   Return\n\nedit_options:\n\n   upper option\n\n   select\n      when option = null then nop\n      when index(option_string,option) /= 0 then nop\n      otherwise\n      do\n         errors_present = true\n      end\n   end\n\n   Return\n\nedit_parms:\n\n   call edit_the_first_parm\n   call edit_the_second_parm\n\n   Return\n\nedit_the_first_parm:\n\n   parm1 = space(parm1,'0')\n\n   select\n      when parm1 = null then\n      call generate_default_value_for_parm1\n      when index(first_parm_mmddyy_options,option) /= 0 &,\n        mmddyy_edit_ok(parm1) = true then\n      NOP\n      when index(first_parm_true_Julian_options,option) /= 0 &,\n        true_julian_edit_ok(parm1) = true then\n      NOP\n      when index(first_parm_false_julian_options,option) /= 0 &,\n        false_julian_edit_ok(parm1) = true then\n      NOP\n      when option = null & mmddyy_edit_ok(parm1) = true then\n      NOP\n      otherwise\n      errors_present = true\n   end\n\n   Return\n\ngenerate_default_value_for_parm1:\n\n   select\n      when index(first_parm_mmddyy_options,option) /= 0 then\n      parm1 = DATE(U)\n      when index(first_parm_true_julian_options,option) /= 0 then\n      do\n         parse value DATE(U) with mm '/' dd '/' yy .\n         parm1 = jnum(mm,dd,yy)\n      end\n      when index(first_parm_false_julian_options,option) /= 0 then\n      parm1 = DATE(J)\n      when option = null then parm1 = DATE(U)\n      otherwise\n      nop\n   end\n\n   Return\n\n\nedit_the_second_parm:\n\n   parm2 = space(parm2,'0')\n\n   select\n      when parm2 = null then\n      call generate_default_value_for_parm2\n      when index(second_parm_numeric_options,option) /= 0 &,\n        datatype(parm2,'N') = true then\n      NOP\n      when index(second_parm_mmddyy_options,option) /= 0 &,\n        mmddyy_edit_ok(parm2) = true then\n      NOP\n      otherwise\n      errors_present = true\n   end\n\n   Return\n\ngenerate_default_value_for_parm2:\n\n   select\n      when index(second_parm_mmddyy_options,option) /= 0 then\n      parm2 = DATE(U)\n      when index(second_parm_numeric_options,option) /= 0 then\n      parm2 = '0'\n      otherwise\n      nop\n   end\n\n   Return\n\nmmddyy_edit_ok: procedure\n\n   arg mmddyy\n\n   parse value mmddyy with mm '/' dd '/' yy .\n   answer = 0\n\n   If datatype(mm,'N') & datatype(dd,'N') & datatype(yy,'N')\n   then\n   do\n      yy = 4digit_year(yy)\n      If gregday(jnum(mm,dd,yy)) = mm_dd_yyyy(mm,dd,yy)\n      then\n      do\n         answer = 1\n      end\n   end\n\n   return answer\n\nfalse_julian_edit_ok: procedure\n\n   arg false_julian\n\n   select\n      when datatype(false_julian,'N') /= 1  then\n      do\n         answer = 0\n      end\n      when length(false_julian) /= 5        then\n      do\n         answer = 0\n      end\n      when tjul_fjul(fjul_tjul(false_julian)) /= false_julian then\n      do\n         answer = 0\n      end\n      otherwise\n      do\n         answer = 1\n      end\n   end\n\n   return answer\n\ntrue_julian_edit_ok: procedure\n\n   arg true_julian\n\n   select\n      when datatype(true_julian,'N') /= 1 then\n      do\n         answer = 0\n      end\n      when true_julian <  1721426   true_julian >  5373484 then\n      do\n         answer = 0\n      end\n      otherwise\n      do\n         answer = 1\n      end\n   end\n\n   return answer\n\nname_of_month_text: procedure\n\n   mm = arg(1)\n\n   answer = word('January February March April May June',\n     ' July August September October',\n     ' November December',mm)\n\n   Return answer\n\nname_of_day_text: procedure\n\n   arg dd\n\n   answer = word('Sunday Monday Tuesday Wednesday',\n     ' Thursday Friday Saturday Sunday',dd)\n\n   Return answer\n\ncentury: procedure\n\n   win19xx = 66          /* Start of 19xx date window */\n\n   yyyy = arg(1)\n\n   century_year = 100 * (yyyy % 100)\n\n   If century_year < 100\n   then\n   do\n      If century_year < win19xx\n      then\n      century_year = 2000\n      else\n      century_year = 1900\n   end\n\n   return century_year\n\n2digit: procedure\n\n   var = arg(1)\n\n   var = right(var,2,'0')\n\n   return var\n\n   return\n\n4digit: procedure\n\n   var = arg(1)\n\n   var = right(var,4,'0')\n\n   return var\n\n4digit_year: procedure\n\n   win19xx = 66          /* Start of 19xx date window */\n\n   yy = arg(1)\n\n   If length(yy) < 3\n   then\n   do\n      If yy < win19xx\n      then\n      yy = yy + 2000\n      else\n      yy = yy + 1900\n   end\n\n   return yy\n\nFormat_year_to_two_or_four_digit_year: procedure\n\n   ddate = arg(1)\n   parse value ddate with mm '/' dd '/' yy .\n\n   select\n      when length(yy) > 2 & substr(yy,1,2) >= '19' then\n      do\n         yy = 2digit(yy)\n      end\n      otherwise\n      nop\n   end\n\n   answer = mm '/' dd '/' yy\n   answer = space(answer,'0')\n\n   return answer\n\n/* J. Kalinich, 1-800-UNDR-DOG                                        */\n/* Rexx date conversion function                                      */\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VI": {"ttr": 1036, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x07\\x01 \\x11\\x9f\\x01 \\x11\\x9f\\x10Q\\x00\\xdb\\x00\\xdb\\x00\\x00\\xd1\\xe3\\xe4\\xd9\\xd5\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2020-04-28T00:00:00", "modifydate": "2020-04-28T10:51:07", "lines": 219, "newlines": 219, "modlines": 0, "user": "JTURNER"}, "text": "/* REXX */\n/**************************************************/\n/* VSAM LISTCAT FORMATTED IN ISPF                 */\n/**************************************************/\nIF SYSVAR(SYSISPF) = 'NOT ACTIVE' THEN DO\n   SAY 'ISPF must be active to use the VI dialog.'\n   EXIT\nEND\nARG DSNAME\nIF DSNAME = ' ' THEN DO\n   SAY 'Please enter a VSAM data set name:'\n   PULL DSNAME\nEND\nTDSN = STRIP(DSNAME,,'''')\nSTATUS=SYSDSN(''''TDSN'''')\nIF STATUS /= 'OK' THEN DO\n /* SAY TDSN \"NOT FOUND\" */\n    zedsmsg = 'NOT CATALOGED'\n    zedlmsg = 'The specified data set is not catalogued.'\n    \"ISPEXEC SETMSG MSG(ISRZ001)\"\n    EXIT\nEND\nX=OUTTRAP('CLS.')\n\"LISTC EN('\"TDSN\"') ALL\"\nX=OUTTRAP('OFF')\nIF POS('NONVSAM',CLS.1) /= 0 THEN DO\n /* SAY TDSN \"IS NOT A VSAM DATASET\" */\n    zedsmsg = 'ERROR: NONVSAM'\n    zedlmsg = 'The VI dialog neither supports nor processes non-VSAM data sets.'\n    \"ISPEXEC SETMSG MSG(ISRZ001)\"\n    EXIT\nEND\nIF POS('USERCATALOG',CLS.1) /= 0 THEN DO\n /* SAY TDSN \"CAN'T HANDLE CATALOGS\" */\n    zedsmsg  = 'ERROR: CATALOG'\n    zedlmsg = 'The VI dialog neither supports nor processes VSAM catalogs.'\n    \"ISPEXEC SETMSG MSG(ISRZ001)\"\n    EXIT\nEND\nIF POS('INDEX',CLS.1) /= 0 THEN INDEX = 'Y'\nCDATE = SUBSTR(CLS.4,53,8)\nEDATE = SUBSTR(CLS.5,53,8)\n\n/* CSC date mod  */\nyyddd = Substr(cdate,3,2)||Substr(cdate,6,3)\nmmyydd   = Rxdate(5,yyddd)\nyyyymmdd = Rxdate(S,mmyydd)\ncdate = Substr(yyyymmdd,1,4)||'/'||,\n        Substr(yyyymmdd,5,2)||'/'||,\n        Substr(yyyymmdd,7,2)\n\nyyddd = Substr(edate,3,2)||Substr(edate,6,3)\nIf yyddd = '00000' Then\n  edate = ''\nElse\n  Do\n    mmyydd   = Rxdate(5,yyddd)\n    yyyymmdd = Rxdate(S,mmyydd)\n    edate = Substr(yyyymmdd,1,4)||'/'||,\n            Substr(yyyymmdd,5,2)||'/'||,\n            Substr(yyyymmdd,7,2)\n  End\n/* CSC date mod */\n\nCATNME = ''\nSCLS = ''\nMCLS = ''\nDCLS = ''\nLG   = ''\nIUSE = ''\nIF POS('IN-CAT',CLS.2) = 6 THEN\n   CATNME = STRIP(WORD(CLS.2,3),B,' ')\nDO I=6 TO CLS.0\nIF POS('STORAGECLASS',CLS.I) = 8 THEN\nDO\n   WRKLNE = TRANSLATE(CLS.I,'   ','-()')\n   SCLS = WORD(WRKLNE,2)\n   MCLS = WORD(WRKLNE,4)\n   I = I + 1\n   WRKLNE = TRANSLATE(CLS.I,'   ','-()')\n   DCLS = WORD(WRKLNE,2)\nEND\nIF WORD(CLS.I,1) = 'RLSDATA' THEN\nDO\n   I = I + 1\n   WRKLNE = TRANSLATE(CLS.I,'   ','-()')\n   LG = WORD(WRKLNE,2)\n   I = I + 1\n   WRKLNE = TRANSLATE(CLS.I,'   ','-()')\n   IUSE = WORD(WRKLNE,7)\nEND\nIF POS('ATTRIBUTE',CLS.I) = 6 THEN DO\n   I = I + 1\n   IF POS('NOUPGRADE',CLS.I) = 8 | POS('UPGRADE',CLS.I) =8 THEN DO\n       PARSE VAR CLS.I OPTF\n       ITERATE\n   END\n   KLEN = STRIP(SUBSTR(CLS.I,25,8),,'-')\n   ALEN = STRIP(SUBSTR(CLS.I,54,7),,'-')\n   CISZ = STRIP(SUBSTR(CLS.I,114,5),,'-')\n   I = I + 1\n   RKP  = STRIP(SUBSTR(CLS.I,25,8),,'-')\n   MLEN = STRIP(SUBSTR(CLS.I,54,7),,'-')\n   CICA = STRIP(SUBSTR(CLS.I,114,5),,'-')\n   I = I + 1\n   IF POS('BUFND',CLS.I) /=0 THEN I = I + 1\n   IF POS('STRIPE-COUNT',CLS.I) /=0 THEN I = I + 1\n   IF POS('RECORDS/CI',CLS.I) /=0 THEN I = I + 1\n   IF POS('AXRKP',CLS.I) /=0 THEN I = I + 1\n   IF POS('VERSION-NUMBER',CLS.I) /=0 THEN I = I + 1\n   IF POS('ACT-DIC-TOKEN',CLS.I) /=0 THEN I = I + 1\n   TYPE = 'INDEXED'\n   IF POS('NONINDEX',CLS.I) /=0 THEN\n      TYPE = 'NONINDEXED'\n   IF POS('NUMBERED',CLS.I) /=0 THEN\n      TYPE = 'NUMBERED'\n   IF POS('LINEAR',CLS.I) /=0 THEN\n      TYPE = 'LINEAR'\n   IF POS(' IMBED',CLS.I) /=0 & INDEX = 'Y' THEN SEQ = 'Y'\n   PARSE VAR CLS.I OPT1 OPT2 OPT3 OPT4 OPT5 OPT6 OPT7 OPT8\n   I = I + 1\n   IF POS('NONINDEX',CLS.I) /=0 THEN\n      TYPE = 'NONINDEXED'\n   IF POS('NUMBERED',CLS.I) /=0 THEN\n      TYPE = 'NUMBERED'\n   IF POS('LINEAR',CLS.I) /=0 THEN\n      TYPE = 'LINEAR'\n   IF POS(' IMBED',CLS.I) /=0 & INDEX = 'Y' THEN SEQ = 'Y'\n   IF POS('STATISTIC',CLS.I) = 6 THEN\n      LEAVE\n   PARSE VAR CLS.I OPTA OPTB OPTC OPTD OPTE\n   IF OPTF /= 'OPTF' THEN OPTE = OPTF\n\n   LEAVE\nEND\nEND\nDO I=I TO CLS.0\nIF POS('STATISTIC',CLS.I) = 6 THEN DO\n   I = I + 1\n   RTOT = STRIP(SUBSTR(CLS.I,21,11),,'-')\n   CISP = STRIP(SUBSTR(CLS.I,54,7),,'-')\n   I = I + 1\n   RDEL = STRIP(SUBSTR(CLS.I,21,11),,'-')\n   CASP = STRIP(SUBSTR(CLS.I,54,7),,'-')\n   EXTS = STRIP(SUBSTR(CLS.I,87,3),,'-')\n   I = I + 1\n   RINT = STRIP(SUBSTR(CLS.I,21,11),,'-')\n   CIFR = STRIP(SUBSTR(CLS.I,58,3),,'-')\n   I = I + 1\n   RUPD = STRIP(SUBSTR(CLS.I,21,11),,'-')\n   CAFR = STRIP(SUBSTR(CLS.I,58,3),,'-')\n   I = I + 1\n   RRET = STRIP(SUBSTR(CLS.I,21,11),,'-')\n   LEAVE\nEND\nEND\nDO I=I TO CLS.0\nIF POS('ALLOCATION',CLS.I) = 6 THEN DO\n   I = I + 1\n   ATYP = 'cylinders:'\n   IF SUBSTR(CLS.I,29,3) = 'ACK' THEN\n   ATYP = 'tracks:'\n   IF SUBSTR(CLS.I,29,3) = 'ORD' THEN\n   ATYP = 'records:'\n   BTYP = ATYP\n   ARBA = STRIP(SUBSTR(CLS.I,50,11),,'-')\n   I = I + 1\n   SPRI = STRIP(SUBSTR(CLS.I,24,8),,'-')\n   URBA = STRIP(SUBSTR(CLS.I,50,11),,'-')\n   I = I + 1\n   SSEC = STRIP(SUBSTR(CLS.I,24,8),,'-')\n   LEAVE\nEND\nEND\nA = 1\nDO I=I TO CLS.0\nIF POS('INDEX',CLS.I) = 4 THEN LEAVE\nIF POS('VOLSER',CLS.I) = 8 THEN DO\n   VSER.A = STRIP(SUBSTR(CLS.I,26,6),,'-')\n   IF SEQ = 'Y' & A=1 THEN DO\n   ARBA = STRIP(SUBSTR(CLS.I,80,10),,'-')\n   EXTS = STRIP(SUBSTR(CLS.I,116,3),,'-')\n   END\n   A = A +1\nIF A = 2 THEN DO\n   I = I + 1\n   IF SEQ = 'Y' THEN DO\n   URBA = STRIP(SUBSTR(CLS.I,80,10),,'-')\n   I = I + 1\n   TRKS = STRIP(SUBSTR(CLS.I,59,2),,'-')\n   LEAVE\n   END\n   I = I + 1\n   TRKS = STRIP(SUBSTR(CLS.I,59,2),,'-')\nEND\nEND\nEND\nVOL1 = VSER.1\nIF VSER.2 /= 'VSER.2' THEN VOL2 = VSER.2\nIF VSER.3 /= 'VSER.3' THEN VOL3 = VSER.3\nATRK = ARBA/CISZ/CICA*TRKS\nUTRK = URBA/CISZ/CICA*TRKS\nUPER = UTRK/ATRK*100\nATRK = FORMAT(ATRK,,0)\nUTRK = FORMAT(UTRK,,0)\nUPER = FORMAT(UPER,,0)\nzedsmsg  = 'VSAM INFO     '\nzedlmsg  = 'VSAM INFO is distributed with the PDS TSO command package.'\n\"ISPEXEC SETMSG MSG(ISRZ001)\"\n\ndo while virc < 8\n  \"ISPEXEC DISPLAY PANEL(VI#1)\"\n  virc = rc\n  end\n\n/*  From Steve Kleeves, Makita USA Inc, CBT File 137  */\n/*  Mod  John Kalinich, CSC  */\n/*  With corrections and enhancements, William (Bill) Smith, US Steel */\n/*  Add SMS/RLS/Catalog, Jim Turner, Trident Services */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VI#1": {"ttr": 1030, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x015\\x00G\\x00\\x901\\x8f\\x01 \\x11\\x9f\\x10Q\\x00,\\x00\\x1a\\x00\\x00\\xd1\\xe3\\xe4\\xd9\\xd5\\xc5\\xd9@@@'", "ispf": {"version": "01.53", "flags": 0, "createdate": "1990-11-14T00:00:00", "modifydate": "2020-04-28T10:51:47", "lines": 44, "newlines": 26, "modlines": 0, "user": "JTURNER"}, "text": ")ATTR DEFAULT(%+_)\n  %   TYPE(TEXT)   INTENS(HIGH)  COLOR(WHITE) SKIP(ON)\n  +   TYPE(TEXT)   INTENS(LOW)   COLOR(TURQ) SKIP(ON)\n  !   TYPE(OUTPUT) INTENS(HIGH)  JUST(LEFT) CAPS(OFF)  COLOR(WHITE)\n  #   TYPE(OUTPUT) INTENS(HIGH)  JUST(LEFT) CAPS(OFF)  COLOR(YELLOW)\n  ?   TYPE(OUTPUT) INTENS(LOW)   JUST(LEFT) CAPS(OFF) COLOR(BLUE)\n  @   TYPE(OUTPUT) INTENS(LOW)   JUST(RIGHT) CAPS(OFF) COLOR(TURQ)\n  {   TYPE(OUTPUT) INTENS(LOW)   JUST(RIGHT) CAPS(OFF) COLOR(TURQ)\n  $   TYPE(TEXT)   INTENS(HIGH)  COLOR(BLUE)\n  ~   TYPE(OUTPUT) INTENS(LOW)   JUST(LEFT)  CAPS(OFF) COLOR(TURQ)\n  }   AREA(SCRL)   EXTEND(ON)\n)BODY EXPAND(\\\\)\n+-\\-\\-%VSAM Data Set Information+-\\-\\-\n%COMMAND ===>_ZCMD                                                             +\n}TXTAREA                                               \\ \\                     }\n)AREA TXTAREA\n$Data Set Name:!TDSN                                        +\n$Catalog Name: ~CATNME                                      +\n$General Data:                                 Current Allocation:\n+   Volume serials:         @VOL1  @VOL2  @VOL3  +Allocated trks:   @ATRK      +\n+   Type:               {TYPE      +              Allocated extents:@EXTS      +\n+   Ave record length:    @ALEN    +\n+   Max record length:    @MLEN    +          $Current Utilization:\n+   Key length:           @KLEN    +              Used trks:      @UTRK        +\n+   Relative key position:@RKP     +              Used percent:   @UPER        +\n+   CI size:              @CISZ    +\n+   CI freespace:         @CIFR    +          $Usage Data:                     +\n+   CA freespace:         @CAFR    +              Total records:  @RTOT        +\n+   1st extent?ATYP      +@SPRI    +              Records deleted:@RDEL        +\n+   Secondary?BTYP      + @SSEC    +              Records inserted:@RINT       +\n+   Creation date:      {CDATE     +              Records updated:@RUPD        +\n+   Expiration date:    {EDATE     +              Records retrieved:@RRET      +\n$RLS Data:                                      + CI splits:      @CISP        +\n+   In-Use:~IUSE       +LOG: ~LG                + CA splits:      @CASP        +\n$SMS Data:\n+   MGMTCLAS:~MCLS    + STORCLAS:~SCLS    + DATACLAS:~DCLS    +\n#OPTC           #OPTD           #OPTE           +\n#OPT1           #OPT2           #OPT3           #OPT4           #OPT5\n#OPT6           #OPT7           #OPT8           #OPTA           #OPTB\n)INIT\n  .HELP = VI#1H\n  &ZCMD = &Z\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VI#1H": {"ttr": 1033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x017\\x00\\x14\\x00\\x901\\x8f\\x01 \\x11\\x9f\\x10S\\x001\\x00\\x1a\\x00\\x00\\xd1\\xe3\\xe4\\xd9\\xd5\\xc5\\xd9@@@'", "ispf": {"version": "01.55", "flags": 0, "createdate": "1990-11-14T00:00:00", "modifydate": "2020-04-28T10:53:14", "lines": 49, "newlines": 26, "modlines": 0, "user": "JTURNER"}, "text": ")ATTR DEFAULT(%+_)\n  %   TYPE(TEXT)   INTENS(HIGH)  COLOR(WHITE) SKIP(ON)\n  +   TYPE(TEXT)   INTENS(LOW)   COLOR(TURQ) SKIP(ON)\n  !   TYPE(OUTPUT) INTENS(HIGH)  JUST(LEFT) CAPS(OFF)  COLOR(WHITE)\n  ?   TYPE(TEXT) INTENS(LOW)   JUST(LEFT) CAPS(OFF) COLOR(BLUE)\n  @   TYPE(OUTPUT) INTENS(LOW)   JUST(RIGHT) CAPS(OFF) COLOR(TURQ)\n  {   TYPE(OUTPUT) INTENS(LOW)   JUST(LEFT) CAPS(OFF) COLOR(TURQ)\n  $   TYPE(TEXT)   INTENS(HIGH)  COLOR(YELLOW)\n  # AREA(SCRL) EXTEND(ON)\n)BODY EXPAND(\\\\)\n+Tutorial \\-\\-%VSAM Dataset Information+-\\-\\ Tutorial\n%COMMAND ===>_ZCMD                                                             +\n#CODEAREA -----------------------------------------------------------------#\n)AREA CODEAREA\n+   Data Set Name:        ?Name of VSAM dataset\n+   Catalog Name:         ?Name of catalog dataset\n+   Volume serials:       ?Up to 3 volsers are displayed\n+   Type:                 ?INDEXED, NONINDEXED, NUMBERED, LINEAR\n+                         $KSDS     ESDS        RRDS      LDS\n+   Ave record length:    ?Average record length\n+   Max record length:    ?Maximum record length\n+   Key length:           ?Record key length\n+   Relative key position:?Relative key position\n+   CI size:              ?Control interval size\n+   CI freespace:         ?Control interval free space\n+   CA freespace:         ?Control area free space\n+   1st extent <type>:    ?First extent amount in TRKS/CYLS/RCDS\n+   Secondary <type>:     ?Secondary amount in TRKS/CYLS/RCDS\n+   Creation date:        ?Creation   date in the format:  yyyy/mm/dd\n+   Expiration date:      ?Expiration date in the format:  yyyy/mm/dd\n+   Allocated trks:       ?Number of tracks allocated\n+   Allocated extents:    ?Number of allocated DASD extents\n+   Used trks:            ?Number of used tracks\n+   Used percent:         ?Percent used\n+   Total records:        ?Total records in file\n+   Records deleted:      ?Number of records deleted from file\n+   Records inserted:     ?Number of records inserted into file\n+   Records updated:      ?Number of records updated in file\n+   Records retrieved:    ?Number of records retrieved from file\n+   CI splits:            ?Number of control interval splits\n+   CA splits:            ?Number of control area splits\n+   RLS data:             ?In-Use and LOG attributes for RLS\n+   SMS data:             ?SMS management, storage and data classes\n+   Attributes 1-13:      ?VSAM file attributes defined with IDCAMS\n)INIT\n  &ZCMD = &Z\n  &ZUP = VI#1H\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VIX": {"ttr": 271, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\n\\x00H\\x01\\x17&\\x9f\\x01\\x17'\\x0f\\x086\\x00\\x16\\x00\\x0c\\x00\\x00\\xe3\\xd9\\xc9\\xc4\\xd1\\xd2@@@@\"", "ispf": {"version": "01.10", "flags": 0, "createdate": "2017-09-26T00:00:00", "modifydate": "2017-09-27T08:36:48", "lines": 22, "newlines": 12, "modlines": 0, "user": "TRIDJK"}, "text": "/* --------------------  rexx procedure  -------------------- *\n * Name:      vix                                             *\n *                                                            *\n * Function:  dynamically allocate the VSAMINFO libraries     *\n *            for testing purposes                            *\n *                                                            *\n * Syntax:    %vix dsn                                        *\n *                                                            *\n * ---------------------------------------------------------- */\n\narg dsn\nexec   = \"'ad.clist'\"          /* customize     */\npanels = \"'ad.ispplib'\"        /* customize     */\n\nAddress TSO\n'altlib activate dataset('exec') application(exec)'\nAddress ISPExec\n'libdef ispplib dataset id('panels') stack'\n'select cmd(%vi' dsn') scrname(vsaminfo)'\n'libdef ispplib'\nAddress TSO\n'altlib deactivate application(exec)'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT182/CBT.V500.FILE182.PDS/VSAMXMIT.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT182/CBT.V500.FILE182.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}