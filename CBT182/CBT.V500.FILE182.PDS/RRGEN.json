{"INMR01": {"INMLRECL": 80, "INMFNODE": "JESNODE", "INMFUID": "USERID", "INMTNODE": "TO", "INMTUID": "SAMG", "INMFTIME": "20100916184944000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 529074, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 27920, "INMRECFM": "FB", "INMDIR": 11, "INMDSNAM": "SSO.RRGEN.SOURCE", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 529074, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 529074, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"SSO.RRGEN.SOURCE": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 27920, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 32, "DS1SMSFG": 32, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3339, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "100259", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\n'", "DS1LSTAR": "b'\\x00\\x12\\x02'", "DS1TRBAL": "b'\\xa94'"}, "COPYR2": {"deb": "b'\\x03\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x110\\x00\\x04\\x8a\\xd0@'", "extents": ["b'\\x03\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x110\\x00\\x04\\x8a\\xd0@'", "b'X\\xf3\\xa2@\\x00\\x00\\x00\\\\\\x00\\x00\\x00\\\\\\x00\\t\\x00\\n'", "b'X\\xf3\\xa2@\\x00\\x00\\x00h\\x00\\x03\\x00h\\x00\\x07\\x00\\x05'", "b'X\\xf3\\xa2@\\x00\\x00\\x02\\x0e\\x00\\x01\\x02\\x0e\\x00\\n\\x00\\n'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$GENASM": {"ttr": 2563, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x006\\x01\\x10\"\\x8f\\x01\\x10#/\\x08(\\x008\\x00*\\x00!\\xe2\\xd7\\xc5\\xd5\\xc3\\xc5\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2010-08-16T00:00:00", "modifydate": "2010-08-20T08:28:36", "lines": 56, "newlines": 42, "modlines": 33, "user": "SPENCER"}, "text": "//RRGENASM JOB (RCPAC),'SPENCER, AL'\n//RRGEN    PROC  MEMBER=MISSING,\n//             INSTLIB='SSO.RRGEN.SOURCE'\n//* INVOKE HIGH LEVEL ASSEMBLER\n//ASM      EXEC  PGM=ASMA90,REGION=32M,\n//             PARM=(NORLD,TERM,OBJ,\n//             'XREF(SHORT,UNREFS),SIZE(MAX,ABOVE)',\n//             'SYSPARM(RCPAC)')\n//SYSUT1   DD  UNIT=VIO,SPACE=(4096,(120,1200),,,ROUND),DCB=BUFNO=1\n//SYSLIN   DD  UNIT=VIO,SPACE=(TRK,(5,5)),DISP=(NEW,PASS),\n//             DCB=BLKSIZE=3120\n//SYSPRINT DD  SYSOUT=*\n//SYSTERM  DD  SYSOUT=*\n//SYSIN    DD  DISP=SHARE,DSN=&INSTLIB.(&MEMBER)\n//SYSLIB   DD  DSN=SYS1.MODGEN,DISP=SHARE\n//         DD  DSN=SYS1.MACLIB,DISP=SHARE\n//         DD  DSN=&INSTLIB,DISP=SHARE\n//LKED     EXEC  PGM=IEWL,REGION=32M,\n//             COND=(0,LT,ASM),\n//             PARM='MAP,NCAL'\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSN=*.ASM.SYSLIN,DISP=(OLD,DELETE)\n//SYSLMOD  DD  DISP=SHARE,DSN=SSO.RRGEN.LOAD(&MEMBER)\n//SYSUT1   DD  UNIT=VIO,SPACE=(1024,(120,120),,,ROUND),\n//             DCB=BUFNO=1\n//         PEND\n//RRGEN    EXEC  RRGEN,MEMBER=RRGEN\n//RRBINARY EXEC  RRGEN,MEMBER=RRBINARY\n//RRDCART  EXEC  RRGEN,MEMBER=RRDCART\n//RRDINP1  EXEC  RRGEN,MEMBER=RRDINP1\n//RRDINP2  EXEC  RRGEN,MEMBER=RRDINP2\n//RRDINP3  EXEC  RRGEN,MEMBER=RRDINP3\n//RREOJMOT EXEC  RRGEN,MEMBER=RREOJMOT\n//RRGENSRT EXEC  RRGEN,MEMBER=RRGENSRT\n//RRINP1DI EXEC  RRGEN,MEMBER=RRINP1DI\n//RRINP1DK EXEC  RRGEN,MEMBER=RRINP1DK\n//RRINP1IS EXEC  RRGEN,MEMBER=RRINP1IS\n//RRINP2DI EXEC  RRGEN,MEMBER=RRINP2DI\n//RRINP2DK EXEC  RRGEN,MEMBER=RRINP2DK\n//RRINP2IS EXEC  RRGEN,MEMBER=RRINP2IS\n//RRINP3DI EXEC  RRGEN,MEMBER=RRINP3DI\n//RRINP3DK EXEC  RRGEN,MEMBER=RRINP3DK\n//RRINP3IS EXEC  RRGEN,MEMBER=RRINP3IS\n//RRIN1ISR EXEC  RRGEN,MEMBER=RRIN1ISR\n//RRIN2ISR EXEC  RRGEN,MEMBER=RRIN2ISR\n//RRIN3ISR EXEC  RRGEN,MEMBER=RRIN3ISR\n//RROT1ISM EXEC  RRGEN,MEMBER=RROT1ISM\n//RROT2ISM EXEC  RRGEN,MEMBER=RROT2ISM\n//RROT3ISM EXEC  RRGEN,MEMBER=RROT3ISM\n//RROUT1DA EXEC  RRGEN,MEMBER=RROUT1DA\n//RROUT1MD EXEC  RRGEN,MEMBER=RROUT1MD\n//RROUT2DA EXEC  RRGEN,MEMBER=RROUT2DA\n//RROUT2MD EXEC  RRGEN,MEMBER=RROUT2MD\n//RROUT3DA EXEC  RRGEN,MEMBER=RROUT3DA\n//RROUT3MD EXEC  RRGEN,MEMBER=RROUT3MD\n//RRPRTMOT EXEC  RRGEN,MEMBER=RRPRTMOT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$GENDOC": {"ttr": 4099, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x006\\x01\\x10#\\x1f\\x01\\x10%\\x9f\\x14H\\x04\\xc3\\x04\\x17\\x00\\x00\\xe2\\xd7\\xc5\\xd5\\xc3\\xc5\\xd9@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "2010-08-19T00:00:00", "modifydate": "2010-09-16T14:48:36", "lines": 1219, "newlines": 1047, "modlines": 0, "user": "SPENCER"}, "text": "GENERAL\n\na. RRGEN was developed in the early 1970's at USA RCPAC, St. Louis, MO\n(SHARE installation code URV).  RRGEN translates program instructions\nand creates IBM System/360 machine instructions in memory before passing\ncontrol to them for execution.  The results of most RRGEN instructions\nare stored in the second operand (B-address).  The exception to this\nis the System Programmer instructions which operate as documented in\nthe IBM System/360 Principles of Operation.\n\nb. The program instructions of an RRGEN program usually reside in-\nstream with other JCL (job control language) statements and are\naccessed via the SYSIN DD statement.  However, these instructions can\nbe also defined as a member of a partitioned data set and referenced\nusing that data set name.\n\nc. Each RRGEN program must have at least one input file.  The file can\nbe defined using either the CARD DD statement or the INPx statement(s)\n(See paragraph 3.3 below).\n\nd. There is a PROCedure available which EXECutes program RRGEN5.\nIncluded in the PROC are the JCL DD statements for STEPLIB,\nSYSUDUMP, SYSOUT, and PRINT.\n\nREQUIRED JCL STATEMENTS\nSTATEMENT                   PURPOSE\n(REQ)    JOB                Initiates the job.\n(REQ)    EXEC               Specifies the program name, PGM=RRGENx,\n                            where   x is the version number.\n(REQ)    SYSOUT DD          Defines a sequential data set used for listing\n                            RRGEN instructions and associated generated\n                            machine instructions or error messages.     It\n                            also includes total number of records read or\n                            written for each data set.\n *       INP1/2/3 DD        Defines an input data set.  This can include a\n                            sequential data set (PS/PDS), an index\n                            sequential data set (IS), or a direct data set\n                            (DA).\n *       CARD DD            Specifies input from a card reader only.\n\n *       NOTE: One of these DDname statements must be used to specify\n               the input data set.\n\n(OPT)    OUT1/2/3 DD        Defines an output data set.   It can include\n                            a sequential data set (PS/PDS), an index\n                            index sequential data set (IS), or a direct\n                            data set (DA).\n(OPT)    PRINT DD           Defines an output data set being written to a\n                            printer.\n(OPT)    SORTLIB DD         Defines a data set that contains sort/\n                            merge program modules.\n(OPT)    SORTWK01 DD        Defines intermediate storage data sets\n         SORTWK02 DD        used by a sort program.\n         SORTWK03 DD\n\n(REQ)    SYSIN DD           Defines the instruction data set.  The\n                            instruction data set normally resides in the\n                            input stream; however, it can be defined as a\n                            member of a partitioned data set.\n\nEXAMPLE:\n----+----1----+----2----+----3----+----4----+----5\n//STEP01   EXEC  RRGEN\n//OUT1     DD  DSN=DARGTE.UES.GTE3101,UNIT=DISK,\n//             DISP=(,CATLG,DELETE),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=6080),\n//             SPACE=(TRK,(5,5),RLSE)\n//CARD      DD *\n.\ninput data (80-column records)\n.\n/*\n//SYSIN     DD *\n.\nRRGEN instructions\n.\n/*\n\nPROCedure RRGEN\na. Below are the JCL statements contained in the PROC named RRGEN.\n\n----+----1----+----2----+----3----+----4----+----5\n//RRGEN    PROC  RPTNAME='*'\n//RRGEN    EXEC  PGM=RRGEN,REGION=128K\n//STEPLIB  DD  DSN=SSO.RRGEN.LOAD.DISP=SHR\n//SYSUDUMP DD  SYSOUT=*\n//SYSOUT   DD  SYSOUT=*\n//PRINT    DD  SYSOUT=&RPTNAME\n\nREQUIRED FORMAT FOR INSTRUCTIONS\na. There can be five parts to an RRGEN instruction.  These five parts are\ndescribed in detail below.  All instructions must contain an Operation.\nGenerally, most RRGEN instructions will require at least an Operation and\nan Address (Exception: the EXIT instruction does not require an address).\n\n(1) Location.  Provides a unique address (tag) to the line of coding\nor indicates a comment statement if an asterisk (*) appears in\ncolumn 1.  Valid tags are TG0l thru TG99.  Tags are always coded\nin column 1 thru column 4.    (See example below)\n\n(2) Operation.  This entry is used to designate a programming\ninstruction or an I/O macro.  The Operation is always coded in\ncolumn 7 thru column 11.      (See example below)\n\n(3) Size. This entry is used to designate a count for the\nprogramming instruction appearing in the Operation field.  When\nused, Size is always coded beginning in column 13. (Example\nbelow)\n\n(4) Address.  This field is used for A or B addresses of\nprogramming instructions.  A Address should be coded beginning\nin column 20; B Address should be coded beginning in column 25.\nIf A or B addresses contain SELF, columns 34 thru 73 are used for\nthe contents of the SELF constant.  If there is a B Address, it must\nbe preceded by a comma in column 24.  (See example below)\n\n(5) Constants or Remarks.     Self explanatory.\n\n(6) Sample coding:\n\n 1      2      3        4                   5\nLOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS\n0        1         2         3         4         5         6\n123456789012345678901234567890123456789012345678901234567890\n * READ AND WRITE CARDS\nTG01  READ         CARD,EOJ\n      MOVE  80     CD00,J000\n      MOVE  3      SELF,J080     JOE\n      WRITE        OUT1\n      GO           TG01\n\nAREA ADDRESS\nRefer to the section in this chapter which shows the assigned\naddresses for all available records or work areas.\n\nSTORAGE OF CONSTANT DATA\na. Storage of Constant data. There are two storage areas assigned to\nhold constant data: SELF and the Constant Area (positions 0000-1999).\n\nb. SELF. The SELF storage area is used by the program to store\nconstants which are used in the execution of the instruction.\n\n       (1) Sample coding.\n\nLOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS\n0        1         2         3         4         5         6\n123456789012345678901234567890123456789012345678901234567890\n      CONS  3      0000          000\n      ADD   3      SELF,0000     001\n\n      NOTE: The ADD instruction above would be read as:\n      Add the 3-digit number stored at address 0000 to the\n      3-digit number stored in the address SELF. The\n      contents of SELF are defined in the constant area of\n      the same line of code as the instruction being\n      executed.\n\nc. The Constant Area. The Constant Area from 0000-1999 is initialized to\nblanks prior to storage of constant data supplied via the CONS or XCON\nparameters.   Detailed descriptions of the CONS and XCON parameters\nfollow.\n\n(1) CONS. This parameter is used to store character constants.\nNo object code is generated.\n\n       FORMAT:\n       Operation =  CONS\n       Size      =  Size of constant(Max 40 bytes)\n       A Address =  LHE address of area to receive constant\n                    (0000-1999)\n       CC 34-73  =  Constant data\n\n       (a) Sample Coding.\n\nLOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS\n0        1         2         3         4         5         6\n123456789012345678901234567890123456789012345678901234567890\n      CONS  3      0000          123\n      CONS  4      0003          ABCD\n\n(2) XCONS.    This parameter is used to store hexadecimal\nconstants.   The hexadecimal digits, (0-9 and A-F), are converted to\none byte per pair of digits. No object code is generated.\n\n       FORMAT:\n       Operation  =  XCONS\n       Size       =  Size of constant (max 20 bytes)\n       A Address  =  LHE address of area to receive\n                     constant (0000-1999)\n       CC 34-74   =  Hexadecimal digits\n\n       (a) Sample Coding.\n\nLOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS\n0        1         2         3         4         5         6\n123456789012345678901234567890123456789012345678901234567890\n      XCONS 3      1000          F1F2F3\n      XCONS 4      1003          C1C2C3C4\n\nAcceptable Branch Addresses\na. Acceptable addresses are TG0l through TG99, EOJ, and SORT, if the\nsort has been CALLed. A branch to EOJ will close all files and terminate\nthe program.\n\nRTCD (Return Code)\na. The return code can be set or tested by either MOVEing to or\nCOMparing against the RTCD field.  The field is initialized to zero. The\nmaximum value is 4095.  A size of four (4) should be used when  moving\nto or comparing against the RTCD field.  Appendix B of this Section\ncontains a table which shows standard RRGEN return code meanings.\n\nb. Sample Coding.\n\nLOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS\n0        1         2         3         4         5         6\n123456789012345678901234567890123456789012345678901234567890\n      MOVE  4      SELF,RTCD     0016\n      GO           EOJ\n\nINSTRUCTION SET\n\na. READ (Sequential). The READ sequential macro instruction obtains the\nnext record from a Physical Sequential (PS) or a Partitioned Data Set\n(PDS).  Transfer of control to B operand will take place when the end of\nthe data set is reached.\n\n       (1) FORMAT:\n           Operation = READ\n           Size      = blank\n           A Address = ddname (CARD, INP1, INP2 or INP3)\n           B Address = Valid TAG or EOJ\n\n       (2) Sample Coding.\n\nLOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS\n0        1         2         3         4         5         6\n123456789012345678901234567890123456789012345678901234567890\n      READ         INP1,TG01\n\n\nb. READ (Index sequential). The READ index sequential macro instruction\nobtains records sequentially or randomly from index sequential data sets.\nIf a record is not found when processing randomly, the\ncorresponding record area will contain \"NOHITb\".  It is the programmer's\nresponsibility to check for this condition after each read.\n\n       (1) FORMAT:\n           Operation = READ\n           Size      = IS if processing sequentially ISR if processing\n                       randomly\n           A Address = ddname (INP1, INP2 or INP3)\n           B Address = Valid TAG or EOJ if processing sequentially;\n                       Key Address if processing randomly (SELF not\n                       valid).\n       (2) Sample Coding.\n\nLOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS\n0        1         2         3         4         5         6\n123456789012345678901234567890123456789012345678901234567890\n      READ  IS     INP1,TG01     NOTE: TG01 = End of Data address\n      READ  ISR    INP1,0000     NOTE: 0000 = Address of area containing the Key\n\n\nc. READ (Direct). The READ direct macro instruction causes a data block\n(max 4000 bytes) to be retrieved from a direct data set and placed into the\nWork Area (2000-5999).  The associated Record Area (A000, B000, or\nC000) must contain the Block Address (Relative track, relative block, or\nactual device address - See OS Data Management Services Guide for\nfurther details).  The programmer is responsible for any de-blocking that is\nrequired, If DI is specified in the Size field, transfer of control to B operand\nwill take place if end-of-data is reached.    If DK is specified, and the\nrequest Key cannot be found, the Work Area will contain \"NOHITb\".\n\n       (1) FORMAT:\n           Operation = READ\n           Size      = DI specifies that data and a key, if any,\n                       are to be read.   The address of the data\n                       block to be read is contained in the Record\n                       Area.  If a key exists, it will precede the data\n                       block in the Work Area. DK specifies that data\n                       only is to be read and that a key is to be used\n                       as the search argument.  The search for the\n                       key starts at the block address contained in the\n                       record area.\n           A Address = ddname (INP1, INP2 or INP3)\n           B Address = Valid TAG or EOJ if DI is specified; Key\n                       Address if DK is specified.\n\n       (2) Sample Coding.\n\nLOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS\n0        1         2         3         4         5         6\n123456789012345678901234567890123456789012345678901234567890\n      CONS  3      0000          000\nTG01  CVZB  3,3    0000A000      NOTE: Read entire file\n      READ  DI     INP1,EOJ            by relative block\n      ADD   3      SELF,0000     001   address\n      GO           TG01\n*\n      READ  DK     INP1,0000     NOTE: 0000 = Address of\n      COM   6      2000,SELF     NOHIT area containing the key\n\n\nd. WRITE.  The WRITE macro is used to place a record into an output\ndata set.  WRITE can be used to: (1) create a Physical Sequential (PS)\ndata set, (2) add a member to a Partitioned data set (PDS), (3) create an\nDirect data set (DA).\n\n       (1) FORMAT:\n           Operation   =  WRITE\n           Size        =  IS if an index sequential data set is to be\n                          created.\n                          DA if a direct data set is to be created.\n                          blank if a sequential or partitioned data set\n                          is to be created.\n           A Address   =  ddname (OUT1, OUT2 or OUT3)\n           B Address   =  not used\n\n       (2) NOTE: If a Direct data set is being created, the programmer is\n       responsible for any blocking that is required (record area does not\n       exist for DA data sets).  The Work Area (2000-5999) is used for the\n       block area.  If keys are used, the key must start in 2000 followed\n       by the data block.\n\n       (3) Sample Coding.\n\nLOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS\n0        1         2         3         4         5         6\n123456789012345678901234567890123456789012345678901234567890\n      WRITE IS     OUT1\n      WRITE DA     OUT2\n      WRITE        OUT3\n\n\ne. GO (Unconditional Branch).  This instruction causes an unconditional\nbreak in the normal sequence of performed instructions.  Control is\ntransferred to the specified TAG.\n       (1) FORMAT:\n           Operation = GO\n           Size      = not used\n           A Address = Tag representing the next instruc tion to\n                       be executed (TG01 thru TG99, EOJ, or SORT).\n           B Address = not used\n\n       (2) Sample Coding.\n\nLOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS\n0        1         2         3         4         5         6\n123456789012345678901234567890123456789012345678901234567890\n      GO           TG01\n      GO           EOJ\n\n\nf. MOVE. This instruction transfers a specified number of consecutive\nbytes from one area to another area.\n       (1) FORMAT:\n           Operation  =  MOVE\n           Size       =  Number of bytes (1-900) to be transferred.\n           A Address  =  Address of Sending area\n           B Address  =  Address of Receiving area\n\n       (2) Sample Coding.\n\nLOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS\n0        1         2         3         4         5         6\n123456789012345678901234567890123456789012345678901234567890\n      MOVE   80    CD00,J000\n\n\ng. COM (Compare).    This instruction is used to determine the relative\nmagnitude of two operands of equal length.\n       (1) FORMAT:\n           Operation = COM\n           Size      = Number of bytes (1-256) to be compared.\n           A Address = Address of first operand\n           B Address = Address of second operand\n\n       (2) Sample Coding.\n\nLOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS\n0        1         2         3         4         5         6\n123456789012345678901234567890123456789012345678901234567890\n      COM   3      SELF,A000     JOE\n      GE           TG03\n\nNOTE:  > indicator set if A > B. (A high) < indicator set if A < B. (A\nlow) = indicator set if A = B. (A equal B) = indicator set if A = B. (A\nnot equal B)\n\n\nh. Test COMPARE results. This instruction senses the indicators set by\nthe compare (COM) instruction and branches accordingly.\n\n       (1) FORMAT:\n           Operation  =  GE, GH, GL or GNE *\n           Size       =  not used\n           A Address  =  TG (tag) to go to if condition is true.\n           B Address  =  not used\n\n           GE (Go Equal)      go on A = B  (A equal B)\n           GL (Go Low)        go on A < B  (A low)\n           GH (Go High)       go on A > B  (A high)\n           GNE (Go Not Equal) go on A = B  (A not equal B)\n\n       (2) Sample Coding.\n\nLOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS\n0        1         2         3         4         5         6\n123456789012345678901234567890123456789012345678901234567890\n      COM   3      A000,CD000\n      GE           TG02\n      GNE          TG01\n      COM    2     A100,SELF     00\n      GH           TG03\n      GL           TG04\n\n\ni. ADD. This instruction performs decimal addition on zoned decimal\noperands.  The result is stored in the area originally occupied by the B\noperand.  The two operands must be equal in length and may not exceed\n16 bytes per operand.\n\n\n       (1) FORMAT:\n           Operation   =  ADD\n           Size        =  Number of bytes (1-16) to be added.\n           A Address   =  Address of the Addend (first of the numbers\n                          being added)\n           B Address   =  Address of the Augend (number added to first\n                          number) and Sum (result of addition)\n\n       (2) Sample Coding.\n\nLOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS\n0        1         2         3         4         5         6\n123456789012345678901234567890123456789012345678901234567890\n      ADD   6      SELF,A003     000001\n\n\nj. SUB. This instruction performs decimal subtraction on zoned decimal\noperands.  The result is stored in the area originally occupied by the B\noperand.  The two operands must be equal in length and may not exceed\n 16 bytes per operand.\n       (1) FORMAT:\n           Operation   =  SUB\n           Size        =  Number of bytes (1-16) to be subtract ed\n           A Address   =  Address of the Subtrahend (first of the\n                          numbers being subtracted)\n           B Address   =  Address of the Minuend (number added to\n                          first number) and Difference (result of\n                          subtraction)\n       (2) Sample Coding.\n\nLOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS\n0        1         2         3         4         5         6\n123456789012345678901234567890123456789012345678901234567890\n      SUB    5     SELF,CD00     00126\n\n\nk. MPY. (Multiply).  This instruction performs decimal multiplication with\nzoned decimal operands.      The product is right-justified in a 30-position\nresult area (RS00-RS29).\n       (1) FORMAT:\n           Operation   =  MPY\n           Size        =  Number of bytes (1-15) in multiplier, a comma,\n                          number of bytes (1-15) in multiplicand.\n           A Address    = Address of Multiplier (number used to multiply\n                          by).\n           B Address    = Address of Multiplicand (number being\n                          multiplied).\n\n       (2) Sample Coding.\n\nLOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS\n0        1         2         3         4         5         6\n123456789012345678901234567890123456789012345678901234567890\n      CONS  7      0000          1234567\n      MPY   2,7    SELF,0000     10\n      MOVE  9      RS21,P0000\n\n      NOTE: After execution of this instruction, P000=012345670\n\n\nl. DVD (Divide).  This instruction performs decimal division with zoned\ndecimal operands.  The quotient is right-justified in the first 15 positions of\nthe Result Area (RS00-RS14) and the remainder is right-justified in the\nlast 15 positions of the Result Area (RS15-RS29).\n       (1) FORMAT:\n           Operation   =  DVD\n           Size        =  Number of bytes (1-15) in divisor, a comma,\n                          and number of bytes (1-15) in dividend.\n           A Address   =  Address of Divisor (number used to divide by).\n           B Address   =  Address of Dividend (number being divided).\n\n       (2) Sample Coding.\n\nLOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS\n0        1         2         3         4         5         6\n123456789012345678901234567890123456789012345678901234567890\n      CONS  5      OUT1          45001\n      DVD   2,5    SELF,0000     22\n      MOVE  5      RS10,P000\n      MOVE  2      RS28,P020\n\n      NOTE: After execution of this instruction, P000=02045 P020=11\n\n\nm. PRINT.    The PRINT instruction is used to print a record (ddname\nPRINT).\n       (1) FORMAT:\n              Operation   = PRINT\n              Size        =  not used\n              A Address   =  SKIP0, SKIP1, SKIP2, SKIP3 or CHANxx\n                            (where xx = Channel Number 01 thru 12)\n              B Address   =  not used\n\n       NOTE:  Spacing takes place after printing.\n\n       (2). Sample Coding.\n\nLOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS\n0        1         2         3         4         5         6\n123456789012345678901234567890123456789012345678901234567890\n      PRINT        SKIP2\n      PRINT        CHAN01\n\n\nn. CALL. The CALL macro instruction causes control to be passed to a\nspecified load module.  The load module containing the program is\nbrought into main storage if a useable copy is not already available. The\nCALL macro also provides, via the USING option, the ability to pass\naddress parameters to the CALLed program.  If the CALLed module sets\nthe return code before returning, this return code will be available to the\nuser in the RTCD field. (Refer to RTCD)\n       (1) FORMAT:\n             Operation  =  CALL\n             Size       =  not used\n             Address    =  aaaaaaaa,USING,bbbb,.....\n             Where:\n             aaaaaaaa =  the name of the program that is being CALLed\n                         or the name of the entry point in the CALLed\n                         program.  The name must be padded with\n                         blanks to eight bytes, if necessary.\n             USING   =   indicates that address parameters are to be\n                   passed to the CALLed program.   bbbb = addresses\n                   of parameters (max of 8) to be passed to the CALLed\n                   program.   The addresses must be in either the\n                   constant storage area (0000-1999) or in Working\n                   Storage area (2000-5999).\n\n       (2) Sample Coding.\n\nLOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS\n0        1         2         3         4         5         6\n123456789012345678901234567890123456789012345678901234567890\nTG01  CALL         GETPMFSQ,USING,0000,0100\n      COM   4      RTCD,SELF     0000\n      GE           TG02\n      COM   4      RTCD,SELF     0002\n      GE           TG03\n      GO           EOJ\nTG02  MOVE  450    0100,J000\n      WRITE        OUT1\n      GO           TG01\nTG03  MOVE  4      SELF,RTCD\n      GO           EOJ\n\n\no. ENTER. This instruction permits the execution of a subroutine and, with\nthe use of EXIT, returns control to the instruction following the ENTER.\n       (1) FORMAT:\n           Operation = ENTER\n           Size      = not used\n           A Address = TG (tag) representing the next instruction to\n                       be executed.\n           B Address = not used\n\n\np. EXIT. This instruction reverses the actions performed by the ENTER\ninstruction and provides the exit from a subroutine.\n\nNOTE: Executing an EXIT without a previous ENTER will cause\ntermination of the program with a completion code of 901.\n\n       (1) FORMAT:\n           Operation = EXIT\n           Size      = not used\n           A Address = not used\n           B Address = not used\n\n       (2) Sample Coding.\n\nLOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS\n0        1         2         3         4         5         6\n123456789012345678901234567890123456789012345678901234567890\n      ENTER        TG01\n      MOVE  2      A000,J000\n      GO           TG02\nTG01  READ         INP1,EOF\n      EXIT\nTG02  WRITE        OUT1\n\n\nq. CVBZ   (Convert binary to zoned).  The format of A operand is changed\nfrom binary to zoned, and the result is placed in the B operand.\n       (1) FORMAT:\n           Operation  =  CVBZ\n           Size       =  Number of bytes (1-4) in A operand, a comma,\n                         and number of bytes (1-10) in B operand\n           A Address  =  Address of Sending area (binary)\n           B Address  =  Address of Receiving area (zoned results)\n\n       (2) Sample Coding.\n\nLOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS\n0        1         2         3         4         5         6\n123456789012345678901234567890123456789012345678901234567890\n      CVBZ  4,10   A000,0100     After execution:\n*                                A000 = 499602D2\n*                                0100 = F1F2F3F4F5F6F7F8F9F0\n      CVBZ  1,2    1000,2000     After execution:\n*                                1000 = 0A\n*                                2000 = F1F0\n\n\nr. CVZB (Convert zoned to binary).   The format of A operand is changed\nfrom zoned to binary, and the result is placed in the B operand.  The A\noperand is assumed to have the zoned format.  All zones are ignored\nexcept the zone over the low-order digit.  The largest number that can be\nconverted is:  2,147,483,647; the smallest number is:  - 2,147,483,648.\n       (1) FORMAT:\n               Operation   =  CVZB\n               Size        =  Number of bytes (1-4) in A operand, a comma,\n                              and number of bytes (1-10) in B operand\n               A Address   =  Address of Sending area (zoned)\n               B Address   =  Address of Receiving area (binary results)\n\n       (2) Sample Coding.\n\nLOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS\n0        1         2         3         4         5         6\n123456789012345678901234567890123456789012345678901234567890\n      CVZB  10,4   0000,0100     After execution:\n*                                0000 = F1F2F3F4F5F6F7F8F9F0\n*                                0100 = 499602D2\n      CVZB  2,1    0100,0200     After execution:\n*                                0100 = F1F0\n*                                0200 = 0A\n\n\ns. PACK. The format of the A operand is changed from zoned to packed,\nand the result is placed in the B operand.  The A operand is assumed to\nhave the zoned format.  All zones are ignored execpt the zone over\nthe low-order digit.\n       (1) FORMAT:\n               Operation = PACK\n               Size      = Number of bytes (1-16) in A operand, a comma,\n                           and number of bytes (1-16) in B operand.\n               A Address = Address of Sending area (zoned)\n               B Address = Address of Receiving area (packed results)\n\n       (2) Sample Coding.\n\nLOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS\n0        1         2         3         4         5         6\n123456789012345678901234567890123456789012345678901234567890\n      PACK  5,3    A000,J000     After execution:\n                                 A000 = F1 F2 F3 F4 F5\n                                 J000 = 12 34 5F\n      PACK  5,4    A000,J000     After execution:\n                                 A000 = F1 F2 F3 F4 F5\n                                 J000 = 00 12 34 5F\n      PACK  5,2    A000,J000     After execution:\n                                 A000 = F1 F2 F3 F4 F5\n                                 J000 = 34 5F\n\n\nt. UNPK (Unpack).    The format of the A operand is changed from packed\nto zoned, and the result is placed in the B operand.\n       (1) FORMAT:\n              Operation = UNPK\n              Size      = Number of bytes (1-16) in A operand, a comma,\n                          and number of bytes (1-16) in B operand.\n              A Address = Address of Sending area (packed)\n              B Address = Address of Receiving area (zoned results)\n\n       (2) Sample Coding.\n\nLOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS\n0        1         2         3         4         5         6\n123456789012345678901234567890123456789012345678901234567890\n      UNPK  3,5    J000,A000     After execution:\n                                 A000 = 12 34 5F\n                                 J000 = F1 F2 F3 F4 F5\n      UNPK  3,6    J000,A000     After execution:\n                                 A000 = 12 34 5F\n                                 J000 = F0 F1 F2 F3 F4 F5\n      UNPK  3,3    J000,A000     After execution:\n                                 A000 = 12 34 5F\n                                 J000 = F3 F4 F5\n\n\nu. TRANS. (Translate).   This instruction translates bytes from one bit\nconfiguration to another by the use of a 256-byte translate table. The hex\nvalue of each byte to be translated is added to the left hand\nend address of the table to generate the address within the table that\nholds the translated equivalent.\n\n       (1) FORMAT:\n              Operation  =  TRANS\n              Size       =  Number of bytes (1-256) to be translated\n              A Address  =  Data to be translated and results of translation\n              B Address  =  Address of 256-byte table to be used for\n                            translation\n       (2) Sample Coding.\n\nLOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS\n0        1         2         3         4         5         6\n123456789012345678901234567890123456789012345678901234567890\n      CONS  1      0064          1\n      CONS  9      0193          222222222\n      CONS  9      0209          333333333\n      CONS  8      0226          444444444\n      CONS  10     0240          ABCDEFGHIJ\n      TRANS 21     J000,0000\n\nNOTE 1: CONS Area (0000-1999) is initialized to blanks\nprior to storing user constants.\n\nNOTE 2: Before execution, J000 = 0123456789bbAIJRSZ*$&\nAfter execution, J000 = ABCDEFGHIJ11223344bbb\n\nINDEXING\na. There are two index registers available (INX1 and INX2).  The size of\neach register is four positions. To set or increment an index register, the\nprogrammer must MOVE or ADD a value to either INX1 or INX2.  The\nindex registers may be assigned to A or B addresses by suffixing the\naddress with a dash   - and either 1 or 2 (see Address field of 4th line of\ncode below).  The index register will then be added to the address before\nexecution.  Numbers used when moving, adding, subtracting, or\ncomparing an index register must be four positions in size.\n\nb. Sample Coding.\n\nLOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS\n0        1         2         3         4         5         6\n123456789012345678901234567890123456789012345678901234567890\n      CONS  15     0000          AA1BB2CC3DD4EE5\n      MOVE  4      SELF,INX1     0000\n      MOVE  4      SELF,INX2     0000\nTG01  MOVE  1      0002-1,P000-2\n      COM   4      INX1,SELF     0012\n      GE           TG02\n      ADD    4     SELF,INX1     0003\n      ADD    4     SELF,INX2     0001\n      GO           TG01\nTG02  PRINT        SKIP1\n      GO           EOJ\n\nProgram would execute as follows:\n        Line 1 initializes a constant\n        Line 2 sets INX1 to zero\n        Line 3 sets INX2 to zero\n        Line 4 TG01 - moves data to print area\n        Line 5 checks to see if all data has been moved to print area\n        Line 6 goes to TG02 if all data moved\n        Line 7 adds 3 to INX1 if all data not moved\n        Line 8 adds 1 to INX2\n        Line 9 goes back to beginning of program (MOVE)\n        Line 10 TG02 - prints data\n        Line 11 ends program\n\nNOTE: Printed output = \"12345\"\n\n\nSORT\na. General. The RRGENSRT, RELEASE, and RETURN subroutines\nprovide the linkage for RRGEN users to sort a file and define procedures\nfor handling these files both before and after they have been sorted.  Both\nan Input and Output procedure MUST be coded.  The input and output\narea for the sort is 5000-5999.   The user must branch to the tag SORT to\ninitiate the sort after all desired records have been RELEASEd to the Sort.\nOnly one sort may be executed within a RRGEN program.  A Region Size\nof approximately 80K will be necessary if SORT is used.  Refer to the\nsection on RRGEN examples.\n\nb. RRGENSRT. This subroutine provides the information that controls the\nsort operation.  Control is received following this CALL when the last\nrecord has been RETURNed to the user.  The user is responsible for\nchecking the return code (RTCD) for successful completion of the sort.\n       (1) FORMAT:\n               Operation = CALL\n               Size      = not used\n               Address   = RRGENSRT,USING,aaaa,bbbb,TGcc,TGdd\n       Where:\n               aaaa = location of the SORT statement *\n                      within the CONS area.\n\n               bbbb = location of the RECORD statement *\n                      within the CONS area.\n               TGcc = Tag of the user Input procedure.\n               TGdd = Tag of the user Output procedure.\n\n             * NOTE: See OS SORT/MERGE manual for description.\n\nc. RELEASE. Transfers a record located at 5000 to the input phase of the\nSort operation.\n       (1) FORMAT:\n              Operation = CALL\n              Size      = not used\n              Address   = RELEASE\n\nd. RETURN. Obtains individual records in sorted order from the final\nphase of the sort and moves them to 5000-5999 for processing by the\nuser.  After the last record has been RETURNed, the sort passes control\nto the instruction following the call of RRGENSRT.\n       (1) FORMAT:\n              Operation = CALL\n              Size      = not used\n              Address   = RETURN\n\n\nBINARY SEARCH\na. General. The binary search subroutine performs a logical binary search\nof a table for a specified argument.\n\nb. When an equal key is found:\n       (1) Index Register One (INX1) is set to the relative address of the\n       table entry that produced the equal condition.\n       (2) Control is returned to the user following the CALL instruction\n       with the 'EQUAL' condition code set.\n\nc. When an equal key is NOT found:\n       (1) Contents of INX1 are unpredictable.\n       (2) Control is returned to the user following the CALL instruction\n       with the 'NOT EQUAL' condition code set.\n\nd. FORMAT:\n       Operation = CALL\n       Size      = not used\n       Address   = RRBINARY,USING,aaaa,bbbb,(c,d,e,f)\n              where:\n                     aaaa = CONS/Working Storage address for the\n                            argument to be searched against the table.\n                     bbbb = CONS/Working Storage address for the table\n                            being searched.\n\n\n                     c = Number of entries in the table.\n                     d = Size of each entry.\n                     e = Size of key within the entry (0-255).\n                     f = Relative position of the key within the entry (first\n                         position = 0, maximum = 255).\n\nSYSTEM PROGRAMMER INSTRUCTIONS\na. The following instructions have been provided for programmers who\nare familiar with IBM Assembly language.  The format of the instructions\nare the same as for the RRGEN instruction set.  The description of their\noperation can be found in the IBM Principles of Operation Manual.\n\nb. Instructions.\n       AP   (Add decimal)         MVN   (Move numerics)\n       CP   (Compare decimal)     MVO   (Move with offset)\n       SP   (Subtract decimal)    MVZ   (Move zones)\n       NC   (Logical AND)\n       OC   (Logical OR)\n       XC   (Logical Exclusive OR)\n\nc. Sample Coding.\n\nLOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS\n0        1         2         3         4         5         6\n123456789012345678901234567890123456789012345678901234567890\n      XCONS 1      0000          0F\n      XCONS 1      1000          F1\n      NC    1      0000,1000     LOGICAL AND\n\nAfter execution:  0000 = Hex 01      e.g. 0000 1111    1st operand\n                  1000 = Hex F1           1111 0001    2nd operand\n                                          0000 0001    Results in 1st\n\nNOTE: Operands and Results are as described in the Principle of\n       Operations manual.\n\nTABLE OF ASSIGNED RECORD/WORK AREAS ADDRESSES\n\n     AREA                     ADDRESS         SIZE\nCARD record area              CD00-CD79       80\nPRINT record area             P000-P131       132\nINP1 record area              A000-A899       900\nINP2 record area              B000-B899       900\nINP3 record area              C000-C899       900\nOUT1 record area              J000-J899       900\nOUT2 record area              K000-K899       900\nOUT3 record area              L000-L899       900\nConstant Storage area *       0000-1999       2000\nWORK AREA **                  2000-5999       4000\nResult of Multiply or Divide  RS00-RS29       30\nSELF constant storage ***     SELF            1772\nRETURN CODE                   RTCD            4\nINDEX 1                       INX1            4\nINDEX 2                       INX2            4\nJULIAN DATE (YYJJJ) ****      DATE            5\nNUMERIC DATE (YYMMDD) ****    DATE            6\nALPHA DATE (DD_MMM_YY) ****   DATE            9\n\n\n* NOTE: The Constant Area (0000-1999) is initialized to blanks prior to\nstorage of user-supplied CONS or XCONS.\n\n** NOTE: The Work Area (2000-5999) is initialized to blanks.   This area is\nalso where the data block is written from or read into if direct access data\nsets are being processed.\n\n*** NOTE: This area is used by the program to store constants which\nappear in an instruction parameter.\n\n**** NOTE: The size determines which date is being addressed.  Table of\nStandard RRGEN Return Codes\n\nTABLE OF STANDARD RRGEN RETURN CODES\n\nReturn Code                         Meaning\n   0000             Successful completion (unless changed by user).\n   0008             Parameter errors.\n   0009             EXIT executed without a corresponding ENTER.\n   0010             8096 bytes available for storing user-generated\n                    instructions has been exceeded.\n   0011             Sort RECORD statement invalid (length > 900 or = 0).\n\n\nRRGEN Program Examples\n\nExample 1 - RRGEN program within a Job JCL stream\n\nLOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS\n0        1         2         3         4         5         6\n123456789012345678901234567890123456789012345678901234567890\n\n//MYJOB    JOB\n//STEP1    EXEC  RRGEN\n//OUT1     DD  DSN=&&TESTDATA,UNIT=DISK,DISP=(NEW,PASS),\n//             DCB=(RECFM=FB,LRECL=85,BLKSIZE=170,\n//             SPACE=(TRK,(1,1))\n//CARD     DD  *\n//SYSIN    DD  *\n      CONS  5      0000          00001\nTG01  READ         CARD,EOJ      READ CARD\n      MOVE  80     CD00,J000     MOVE CARD TO OUT1 RECORD AREA\n      MOVE  5      0000,J080     MOVE COUNT TO END OF RECORD\n      MOVE  85     J000,P000     MOVE OUT1 REC TO PRINT AREA\n      PRINT        SKIP1         PRINT RECORD\n      WRITE        OUT1          WRITE OUT1 RECORD\n      ADD   5      SELF,0000     00001    ADD 1 TO COUNT\n      GO           TG01          GO TO READ NEXT CARD\n//STEP2    EXEC\n\nExample 2 - RRGEN program with required JCL statements\n\nLOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS\n0        1         2         3         4         5         6\n123456789012345678901234567890123456789012345678901234567890\n\n//STEP2    EXEC  RRGEN\n//OUT1     DD  DSN=SP-A001,UNIT=DISK,DISP=(NEW,PASS),\n//             DCB=(RECFM=FB,LRECL=450,BLKSIZE=2250),\n//             SPACE=(TRK,(20))\n//PMFMAST  DD  DSN=ATENLMAS,DISP=SHR,VOL=PRIVATE,UNIT=(DISK,1)\n//         DD  DSN=ATOFFMAS,DISP=SHR,VOL=PRIVATE,UNIT=AFF=PMFMAST\n//PMFGAIN  DD  DSN=ATEGAINS,DISP=SHR,VOL=PRIVATE,UNIT=(DISK,1)\n//         DD  DSN=ATOGRAIN,DISP=SHR,VOL=PRIVATE,UNIT=AFF=PMFGAIN\n//SYSIN    DD  *\n      MOVE  8      SELF,0000     RCPACGEN USER PASSWORD\n      MOVE  7      SELF,0008     SW1=NO   NO DELETE RECS\n      MOVE  7      SELF,0015     SW2=YES  WANTS RECS UNPACKED\nTG01  CALL         GETPMFSQ,USING,0000,1000,0008,0015\n      COM   4      SELF,RTCD     0000     Q. NORMAL RETURN?\n      GE           TG02                      YES IF GE IS TAKEN\n      COM   4      SELF,RTCD     0002     Q. END OF DATA?\n      GE           EOJ                       YES IF GE IS TAKEN\n      MOVE  35     SELF,P000     OUT OF SEQUENCE OR BAD PARM\n      PRINT        CHAN01\n      GO           EOJ\nTG02  COM   2      1014,SELF     99  SELECT SSN'S ENDING 99\n      GNE          TG01\n      MOVE  450    1000,J000     MOVE TO RECORD AREA\n      WRITE        OUT1\n      GO           TG01\n\nExample 3 - RRGEN SORT subroutine\n\nLOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS\n0        1         2         3         4         5         6\n123456789012345678901234567890123456789012345678901234567890\n\n      NOTE: \"SORT\" and \"RECORD\" statements must be preceded and\n            followed by a space.\n\n      CONS  24     0000           SORT FIELDS=(1,4,CH,A)\n      CONS  26     0040           RECORD TYPE=A,LENGTH=100\n*1    CALL         RRGENSRT,USING,0000,0040,TG05,TG09\n*4    COM   4      RTCD,SELF     0000 CONTROL RECEIVED HERE AFTER\n      GE           EOJ           THE LAST REC RETURNED\n      MOVE  12     SELF,P000     SORT NO GOOD\n      PRINT        SKIP1\n      GO           EOJ\n***   INPUT PROCEDURE   ***\n*2\nTG05  READ         INP1,SORT     AT EOF GO SORT RELEASE RECORDS\n      MOVE  100    A000,5000     MOVE RECORD TO SORT AREA\n      CALL         RELEASE       RELEASE RECORD AT 5000 TO SORT\n      GO           TG05\n***   OUTPUT PROCEDURE   ***\n*3\nTG09  CALL         RETURN        ASK SORT FOR A SORTED RECORD\n      MOVE  100    5000,P000     MOVE SORTED RECORD TO PRINT AREA\n      PRINT        SKIP1         PRINT RECORD\n      GO           TG09          GO GET NEXT RECORD\n\n* Execution Sequence\n  1 will execute one time\n  2 will execute n times ( n = nr of recs RELEASEd)\n  3 will execute n times ( n = nr of recs RETURNed)\n  4 will execute one time\n\nExample 4 - RRGEN binary search routine\n\nLOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS\n0        1         2         3         4         5         6\n123456789012345678901234567890123456789012345678901234567890\n      CONS  2      0000          WORK AREA FOR ARGUMENT\n      CONS  30     0100          01JAN02FEB03MAR04APR05MAY06JUN\n      CONS  30     0130          07JUL08AUG09SEP10OCT11NOV12DEC\nTG01  READ         CARD,EOJ\n      MOVE  2      CD05,0000     MOVE NUMERIC MONTH TO ARGUMENT\n      CALL         RRBINARY,USING,0000,0100,(12,5,2,0)\n      GNE          TG02\n      MOVE  3      0102-1,P000   MOVE ALPHA MONTH TO PRINT AREA\n      PRINT        SKIP1         PRINT ALPHA MONTH\n      GO           TG01\nTG02  MOVE  21     SELF,P000     INVALID NUMERIC MONTH\n      PRINT        SKIP1\n      GO           TG01\n\nExample 5 - RRGEN PDS directory list\n\nLOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS\n0        1         2         3         4         5         6\n123456789012345678901234567890123456789012345678901234567890\n\n//RRGEN    EXEC  PGM=RRGEN\n//STEPLIB  DD  DSN=SSO.RRGEN.LOAD,DISP=SHR\n//SYSOUT   DD  SYSOUT=*\n//SYSUDUMP DD  SYSOUT=*\n//PRINT    DD  SYSOUT=*\n//INP1     DD  DSN=SYS1.PROCLIB,DISP=SHR,\n//             DSORG=PS,RECFM=F,LRECL=256,BLKSIZE=256\n//OUT1     DD  SYSOUT=*,DSORG=PS,RECFM=FB,LRECL=80,BLKSIZE=0\n//SYSIN    DD  *\n      XCONS 1      0000          1F        ISOLATE USERDATA LENGTH\n      XCONS 1      0001          80        ISOLATE ALIAS INDICATOR\n      XCONS 1      0002          0F        SIGN HALF BYTE\n      XCONS 8      0010          FFFFFFFFFFFFFFFF  HIGH VALUES\n      CONS  40     0020          MEMBER     VV.MM CDATE  MDATE  TIME\n      CONS  40     0060          SIZE   INIT  ID       XSIZE     XINIT\n      XCONS 4      1000          00000000  USED BYTES\n      XCONS 1      1004          00        PDS2INDC\n      XCONS 1      1005          00        PDS2INDC\n      XCONS 1      1006          0F        SPF STATS\n      XCONS 1      1007          14        SPF XSTATS\n      CONS  4      1008          0000\n      XCONS 3      1012          000000    0HHMM0 AFTER MVO\n      MOVE  80     0020,J000     HEADER\n      WRITE        OUT1\n      MOVE  80     0500,J000     CLEAR OUTPUT\n      WRITE        OUT1\nTG01  READ         INP1,EOJ      READ DIRECTORY BLOCK\n      CVBZ  2,4    A000,1000     USED BYTES IN BLOCK\n      MOVE  4      SELF,INX1     0002  SKIP USED BYTES IN BLOCK\nTG05  COM   4      INX1,1000     INDEX >= USED?\n      GE           TG01          YES\n      GH           TG01          YES\n      COM   8      A000-1,0010   MEMBER NAME = HIGH VALUES?\n      GE           EOJ           YES, DONE\n      MOVE  4      INX1,INX2     SAVE MEMBER NAME START\n      ADD   4      SELF,INX1     0011  SKIP MEMBER NAME/TTR\n      ENTER        TG10\n      MOVE  1      A000-1,1004   PDS2INDC\n      NC    1      1004,0000     <--- ISOLATE USERDATA LENGTH\n      CVBZ  1,4    1004,1008\n      ADD   4      SELF,INX1     0001  SKIP PDS2INDC\n      ADD   4      1008,INX1     USERDATA LENGTH IN HALFWORDS\n      ADD   4      1008,INX1     *2\n      GO           TG05\nTG10  MOVE  80     0500,J000     CLEAR OUTPUT\n      MOVE  8      A000-2,J000   PDS2NAME\n      MOVE  1      A000-1,1005   PDS2INDC\n      NC    1      1005,0001     <--- ISOLATE ALIAS IDENTIFIER\n      COM   1      1005,0001     ALIAS?\n      GNE          TG15          NO\n      MOVE  2      SELF,J007     -A\nTG15  MOVE  1      A000-1,1005   PDS2INDC\n      NC    1      1005,0000     <--- ISOLATE USERDATA LENGTH\n      COM   1      1005,1006     SPF STATS?\n      GE           TG20          YES\n      COM   1      1005,1007     SPF XSTATS?\n      GE           TG20          YES\n      GO           TG99\nTG20  ADD   4      SELF,INX2     0012  SKIP MEMBER NAME/TTR/INDICATOR\n      CVBZ  1,2    A000-2,J011         ISPVERS\n      MOVE  1      SELF,J013     .\n      ADD   4      SELF,INX2     0001\n      CVBZ  1,2    A000-2,J014         ISPMOD\n      ADD   4      SELF,INX2     0004\n      UNPK  3,5    A000-2,J017         ISPCDATE\n      ADD   4      SELF,INX2     0004\n      UNPK  3,5    A000-2,J024         ISPMDATE\n      ADD   4      SELF,INX2     0003\n      MOVE  2      A000-2,1013         ISPMTIME\n      MVO   3,3    1012,1012     0HHMM0\n      OC    1      1014,0002     0HHMMF\n      UNPK  3,4    1012,J031     HHMM\n      ADD   4      SELF,INX2     0002\n      CVBZ  2,5    A000-2,J040         ISPCLINE\n      ADD   4      SELF,INX2     0002\n      CVBZ  2,5    A000-2,J047         ISPILINE\n      ADD   4      SELF,INX2     0004\n      MOVE  8      A000-2,J053         ISPUSRID\n      COM   1      1005,1007     SPF XSTATS?\n      GNE          TG99          NO\n      ADD   4      SELF,INX2     0008\n      CVBZ  4,8    A000-2,J062         ISPECLIN\n      ADD   4      SELF,INX2     0004\n      CVBZ  4,8    A000-2,J072         ISPEILIN\nTG99  WRITE        OUT1\n      EXIT\n\nExample 6 - RRGEN Call JES2 separator routine\n\nLOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS\n0        1         2         3         4         5         6\n123456789012345678901234567890123456789012345678901234567890\n\n//RRGEN    EXEC  PGM=RRGEN\n//STEPLIB  DD  DSN=SSO.RRGEN.LOAD,DISP=SHR\n//SYSOUT   DD  SYSOUT=*\n//SYSUDUMP DD  SYSOUT=*\n//PRINT    DD  SYSOUT=*\n//CARD     DD  *\nJOHNNY\nROTTEN\n//SYSIN    DD  *\n      CONS  8      0000                    P1\n      XCONS 4      0008          00000000  P2 LINE NUMBER (BINARY)\n*                                          P3 LINE OUTPUT AREA\n      CONS  40     0100\n      CONS  40     0140\n      CONS  30     0180\n      XCONS 4      0210          00000008  P4 LENGTH(P1)  (BINARY)\n      CONS  8      0214                    P5\n      CONS  8      0222                    P6\n      CONS  8      0230                    P7\n      CONS  40     0300\n      CONS  40     0340\n      CONS  30     0380\n*\nTG05  READ         CARD,TG99\n      MOVE  8      CD00,0000     8-BYTE STRING\n      MOVE  4      SELF,INX1     0001\n      ENTER        TG10\n      GO           TG05\nTG10  COM   4      INX1,SELF     0012\n      GH           TG20\n      CVZB  4,4    INX1,0008     P2    LINE 1-12\n      MOVE  110    0300,0100\n      CALL         IEFSD095,USING,0000,0008,0100,0210\n      MOVE  110    0100,P000\n      PRINT        SKIP1\n      ADD   4      SELF,INX1     0001  NEXT LINE\n      GO           TG10\nTG20  MOVE  110    0300,P000\n      PRINT        SKIP1         BLANK LINE\n      EXIT\nTG99  MOVE  4      SELF,RTCD     0000\n      GO           EOJ\n\nExample 7 - RRGEN Call SMS Data Set Attribute Retrieval\n\nLOC   OPN   SIZE   ADDRESS       CONSTANT OR REMARKS\n0        1         2         3         4         5         6\n123456789012345678901234567890123456789012345678901234567890\n\n//RRGEN    EXEC  PGM=RRGEN\n//STEPLIB  DD  DSN=SSO.RRGEN.LOAD,DISP=SHR\n//SYSOUT   DD  SYSOUT=*\n//PRINT    DD  SYSOUT=*\n      XCONS 4      0000          00000000\n      XCONS 4      0004          00000000\n      XCONS 8      0008          0000000000000000\n      XCONS 4      0016          0000002C\n      CONS  40     0020          SSO.SMS.PARMLIB\n      CONS  4      0060\n      CONS  30     0100\n      CONS  30     0130\n      CONS  30     0160\n      CONS  4      0200\n      CALL         IGWASMS ,USING,0000,0004,0008,0016,0020,0100,0200\n      MOVE  9      SELF,P000     STORCLAS=\n      MOVE  8      0100,P009\n      PRINT        SKIP1\n      MOVE  9      SELF,P000     MGMTCLAS=\n      MOVE  8      0130,P009\n      PRINT        SKIP1\n      MOVE  9      SELF,P000     DATACLAS=\n      MOVE  8      0160,P009\n      PRINT        SKIP1\n      GO           EOJ\n\n**************************** Bottom of Data ****************************\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RRBINARY": {"ttr": 27, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00C\\x00\\x890o\\x00\\x890o\\x14\\x18\\x00\\xe3\\x00\\xe3\\x00\\x00\\xe2\\xd7\\xc5\\xd5\\xc3\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-02T00:00:00", "modifydate": "1989-11-02T14:18:43", "lines": 227, "newlines": 227, "modlines": 0, "user": "SPENCER"}, "text": "BINARY01  CSECT\nR1       EQU        1\nR2       EQU        2\nR3       EQU        3\nR4       EQU        4\nR5       EQU        5\nR6       EQU        6\nR7       EQU        7\nR8       EQU        8\nR9       EQU        9\nR10      EQU        10\nR11      EQU        11\nR12      EQU        12\nR13      EQU        13\nR14      EQU        14\nR15      EQU        15\nEP1      SAVE      (14,12)\n         BALR       12,0\n         USING      *,12\n         ST         R13,SAVE+4\n         LR         R6,R13\n         LA         R13,SAVE\n         ST         R13,8(R6)\n         CLI       12(R1),X'80'    INSURE A COMPLETE PARM LIST.\n         BNE       ATEND\n         CLI       0(R1),X'80'      HAVE I CKED THIS PARM BEFORE\n         BE        LOADEM          YES SET UP FOR A SEARCH\nEP2      XR         R9,R9\n         LA         R10,PARM            LOOK  THRU MY PARM LIST\nLOOK     L          R11,0(R10)           IF REG 14 HAS BEEN SAVED\n         L          R15,0(R11)           IN IT- THEN I ASSUME THIS\n         CR         R9,R15\n         BE         INSERT\n         CLI        0(R10),X'80'         THIS IS A BUILD & EDIT.\n         BE        ATEND\n         LA         R10,4(R10)\n         B          LOOK\nLOADEM   LA        R14,14(R14)       SET UP 14 FOR RETURN TO RRGEN\n         L         R11,0(R1)\n         ST        R14,12(R6)           PUT R14 IN HIS SAVE FOR ME\n****    LOAD MY REGISTERS HERE........\n         LM         R2,R10,4(R11)       ONLY 4 DIFFERENT SEARCHES CAN\n*                                       CALL THIS MODULE AT ONE TIME-\n         MVC       COMP(6),40(R11)      FOR I BUILD IN HOLD AND ONLY\n         B          INCR                RESTORE REG & COMP FOR A SEARCH\nINSERT   L          R3,0(R1)            BUILD 4 HOLD AREAS HERE:\n         L          R6,4(R1)           * R3 = INQUIRY ADR\n         L          R2,4(R1)           * R2,R6,R5,HAVE LHE OF TABLE ADR\n         L          R5,4(R1)           * R4 = LENGTH OF EACH ENTRY\n         ST          R1,0(R11)         * R7 = RHE OF TABLE-1 ENTRY\n         ST        R11,0(R1)\n         MVI       0(R1),X'80'\n         MVC       36(4,R11),8(R1)        INDEX ADR\n******     WHAT WE HANDLE IN THIS RTN. LOOKS LIKE THIS.\n*********                    (0012,005,000,002)\n**********                   (12,5,0,2)\n**********                   (12,5,,2)\n**********           THE DEFAULT IS ZERO.\n         L         R8,12(R1)       SET 8 AT TBL DESCP.\n         LA        R7,WRK1            SET  7 AT RECEIVE FIELD\n         CLI       0(R8),X'4D'           FIRST MUST BE A (.\n         BNE       ATEND          ITS AN ERROR BYE.\nINCRR8   LA        R8,1(R8)        BUMP R8 BY ONE.\n         ST        R8,REGHLD        SAVE R8 FOR LATER USE.\n         LA        R4,WRK5        SET 5 AT A WOKR AREA.\nCOMMA    CLI       0(R8),X'6B'       IS A COMMA HERE.\n         BE        GOTONE           YES IT IS.\n         CLI       0(R8),X'5D'          IS A ). RHE\n         BE        GOTONE       YES IT IS.\n         C         R4,LOOKAT4         HAVE WE EXCEEDED RHE\n         BH        ATEND          YES ITS AN ERROR.\n         MVC       0(1,R4),0(R8)        MOVE A CHAR IN WRK5.\n         LA        R4,1(R4)      INCR WRK5 ADR\n         LA        R8,1(R8)          BUMP THRU TBL DESCP.\n         B         COMMA        GO LOOK SOME MORE.\nGOTONE   ST        R8,RHLD          SAVE 8 FOR LATER USE.\n         S         R8,REGHLD     HOW MANY DID I MOVE 0-4.\n         CL        R8,CON4      WAS IT MORE THAN 4.\n         BH        ATEND        YES ITS A USER ERROR.\n         L         R4,CON32      MAX NR OF BITS IN A REG IS 32.\n         LR        R9,R8          FOR THE MPY\n         M         R8,CON8    NR MOVED X 8 = NR BITS MOVED.\n         SR        R4,R9       MINUS MAX NR BITS = EXCESS BITS.\n         STC       R4,SRL1+3   PUT EM IN SHIFT INST.\n         L         R8,WRK5        WHO GETS IT.\nSRL1     SRL       R8,0(0)         SHIFT IT OVER.\n         ST        R8,0(R7)     STORE IT IN WRK1-4\n         MVZ       0(4,R7),HIVAL        ALL F ZONE.\n         LA        R7,4(R7)    INCR 7 TO NEXT WRK AREA.\n         L         R8,RHLD        RESTORE 8 TO THE COMMA\n         CLI       0(R8),X'5D'     WAS A ).  RHE\n         BE        OUT       YES GET OUT OF HERE.\n         CL        R7,ENDOF\n         BH        ATEND   WE ARE OUT OF THE WRK AREA.\n         B         INCRR8      GO LOOK SOME MORE.\n********        DO SOME EDITING HERE.\nOUT      CLC       WRK4(4),CON255     REL KEY POS CANNOT EXCEED 255.\n         BH        ATEND\n         CLC       WRK3(4),CON256   LENGTH OF KEY NOT 256\n         BH        ATEND        YES ITS GREATER SORRY.\n         CLC       WRK3(4),WRK2    KEYLEN CANNOT BE GREATER THAN THE\n         BH        ATEND           SIZE OF AN ENTRY.\n         CLC       WRK2(4),ZERO      SIZE CANNOT BE ZERO.\n         BE        ATEND\n         CLC       WRK1(4),ZERO      NR OF ENTRIES CANNOT BE ZERO.\n         BE        ATEND\n         CLC       WRK3(4),ZERO      KEYLEN CANNOT BE ZERO.\n         BE        ATEND\n         CLC       WRK4(4),WRK2     REL KEY POS CANNOT BE GREATER\n         BH        ATEND             THAN THE SIZE.\n         PACK       DBLWRD(8),WRK1(4)\n         CVB        R7,DBLWRD\n         PACK       DBLWRD(8),WRK2(4)\n         CVB        R4,DBLWRD\n         PACK       DBLWRD(8),WRK4(4)\n         CVB       R9,DBLWRD\n         STC       R9,COMP+3        REL KEY POS IN COMPARE DISP.\n         PACK       DBLWRD(8),WRK3(4)\n         CVB        R8,DBLWRD\n         AR        R9,R8       REL POS + KEYLEN\n         CLR       R9,R4         CANNOT BE GREATER THAN THE SIZE.\n         BH        ATEND\n         S         R8,ONE       DECR BY ONE FOR COMP SIZE INST.\n         STC        R8,COMP+1              SIZE OF COMP\n         S          R7,ONE\n         LR        R9,R7\n         MR         R8,R4                NR ENTRIES-1 X SIZE OF ENTRY\n         LR         R7,R6               PLUS LHE ADR = RHE ADR.\n         AR        R7,R9\n         MVC       40(6,R11),COMP\n         STM        R2,R7,4(R11)       STORE REG INTO HOLD AREA.\n*  CHANGE 14 TO GO BACK +14 WHEN TESTING IS DONE.\n*   EXCEPT WHEN RRGEN CALLS,DONT GO BACK WHERE 14 POINTS.\nGOBACK   L          R13,SAVE+4\n         RETURN     (14,12),T,RC=0\nATEND    L          R13,SAVE+4\n         RETURN     (14,12),T,RC=1\n*****  THIS IS THE SEARCH ROUTINE.  IT WORKS ON AN ADDRESS PRINCIPLE.\n*****  THE COMPARE IS HERE. SIZE AND DISPLACEMENT CHANGES WITH EACH\n*****  SEARCH.\nCOMP     CLC        0(1,R2),0(R3)\n         BE         POSHIT\n         BL        LOOKUP\n         SR         R2,R4\n         LR         R7,R2\n         B          GOON\nLOOKUP   AR         R2,R4\n         LR         R6,R2\nGOON     CLR        R6,R7\n         BH         ATEND\n         LR         R9,R4\n         AR         R9,R7\n         SR         R9,R6\n         SR         R8,R8\n         DR         R8,R4\n         LR        R8,R9\n         SRL        R8,1(0)\n         SLL        R8,1(0)\n         CLR        R8,R9\n         LR         R2,R7\n         BNE        INCR\n         SR         R2,R4\n***** ADD THE TWO ADRESSES TOGETHER AND DIVIDE BY 2 TO GET THE NEXT\n*****   LOOK IN THE TABLE.\nINCR     AR         R2,R6\n         SLL       R2,8(0)\n         SRL       R2,9(0)\n         B          COMP\nPOSHIT   SR         R2,R5\n         CVD       R2,DBLWRD\n         UNPK      WRK4(4),DBLWRD+5(3)\n         MVZ       WRK4+3(1),WRK4+2\n         MVC       0(4,R10),WRK4\n         CR         R2,R2\n         B          GOBACK\nSAVE     DC         18F'0'\nPARM     DC         AL4(HOLD1)\n         DC         AL4(HOLD2)\n         DC         AL4(HOLD3)\n         DC        AL4(HOLD4)\n         DC        AL4(HOLD5)\n         DC        AL4(HOLD6)\n         DC        AL4(HOLD7)\n         DC        AL4(HOLD8)\n         DC        AL4(HOLD9)\n         DC         X'80'\n         DC        AL3(HOLD10)\nWRK      DS        0F\nWRK1     DC        1F'0'\nWRK2     DC        1F'0'\nWRK3     DC        1F'0'\nWRK4     DC        1F'0'\nWRK5     DC        1F'0'\nENDOF    DC        AL4(WRK4)\nLOOKAT4  DC        AL4(WRK5+4)\nREGHLD   DC        1F'0'\nRHLD     DC        1F'0'\nHIVAL    DC        XL4'FFFFFFFF'\nZERO     DC        CL4'0000'\nONE      DC         XL4'00000001'\nCON4     DC        XL4'00000004'\nCON8     DC        XL4'00000008'\nCON32    DC        XL4'00000020'\nCON255   DC        CL4'0255'\nCON256   DC        CL4'0256'\nDBLWRD   DC        1D'0'\nHOLD1    DC        1F'0'           H    HOLD  R14\n         DC        1F'0'           H    LHETBL  R2\n         DC        1F'0'                INQUIRY R3\n         DC        1F'0'                ENTLEN  R4\n         DC        1F'0'                LHETBL  R5\n         DC        1F'0'                LHETBL  R6\n         DC        1F'0'                RHETBL  R7\n         DC        1F'0'               ZERO FOR R8\n         DC        1F'0'               ZERO FOR R9\n         DC        1F'0'           H    INDEX ADR   R10\n         DC        1D'0'               CLC  HOLD\nHOLD2    DC        12F'0'               SAME AS HOLD1\nHOLD3    DC        12F'0'               SAME AS HOLD1\nHOLD4    DC        12F'0'               SAME AS HOLD1\nHOLD5    DC        12F'0'               SAME AS HOLD1\nHOLD6    DC        12F'0'               SAME AS HOLD1\nHOLD7    DC        12F'0'               SAME AS HOLD1\nHOLD8    DC        12F'0'               SAME AS HOLD1\nHOLD9    DC        12F'0'               SAME AS HOLD1\nHOLD10   DC        12F'0'               SAME AS HOLD1\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RRDCART": {"ttr": 29, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00C\\x00\\x890o\\x00\\x890o\\x14\\x18\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe2\\xd7\\xc5\\xd5\\xc3\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-02T00:00:00", "modifydate": "1989-11-02T14:18:43", "lines": 28, "newlines": 28, "modlines": 0, "user": "SPENCER"}, "text": "RRDCARD   CSECT\n*  THIS MODULE IS CALLED BY THE GENERATOR PROGRAM\n*       TO HANDLE READ MACROS\n*\n         SAVE  (2,12),T,*\n         BALR  10,0\n         USING *,10\n         ST    13,SAVEAREA+4\n         LA    13,SAVEAREA\nML01     B     ML03           1 ST  TIME  SWITCH\nML02     GET   DCBIN,*+0        READ  RECORD\nML02A    L     13,SAVEAREA+4\n         LM    14,12,12(13)   RELOAD REGS\n         LA    15,0(0,0)      SET RETURN CODE TO 0\n         LA    14,12(0,14)    BUMP 14 BY 12 TO RETURN TO ADD TO REC CT\n         BR    14             RETURN\nML03     OPEN  (DCBIN)\n         LA    11,4(0,14) 14+4POINTS TO ADR OF RECORD AREA\n         MVC   ML02+6(2),0(11)  PUT RECORD AREA ADR IN GET MACRO\n         MVI   ML01+1,X'00'     NOP ML01\n         B     ML02A\nDCBIN    DCB   DDNAME=CARD,DSORG=PS,MACRF=GM,EODAD=ML04\nSAVEAREA DC    18F'0'\nML04     L     13,SAVEAREA+4\n         LM    14,12,12(13)\n         LA    15,0(0,0)        REG AND\n         BR    14                BR TO HIS EOF\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RRDINP1": {"ttr": 257, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00C\\x00\\x890o\\x00\\x890o\\x14\\x18\\x00\\x1f\\x00\\x1f\\x00\\x00\\xe2\\xd7\\xc5\\xd5\\xc3\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-02T00:00:00", "modifydate": "1989-11-02T14:18:43", "lines": 31, "newlines": 31, "modlines": 0, "user": "SPENCER"}, "text": "RRDINP1   CSECT\n*  THIS  MODULE  IS CALLED BY THE GENERATOR PROGRAM\n*         TO HANDLE READ INP1  / ONLY DIFF BETWEEN INP1 2 & 3 ARE\n*          REG USED FOR REC AREA AND DDNAME IN DCB\n         SAVE  (2,12),T,*\n         BALR  12,0\n         USING *,12\n         ST    13,SAVEAREA+4\n         LR    4,13\n         LA    13,SAVEAREA\n         ST    13,8(4)\nML01     B     ML03             1ST SWITCH\nML02     GET   DCBIN,RECAREA\n         LA    7,RECAREA      LOAD 7 WITH REC AREA ADR                *\nML02A    L     13,SAVEAREA+4  RELOAD HIS REGS\n         LM    14,6,12(13)    BYPASS LOADING 7  SINCE IT IS\n         LM    8,12,52(13)     ASSIGN TO HIS INP1 REC AREA\n         LA    15,0(0,0)      SET RETURN CODE TO 0\n         LA    14,12(0,14)    BUMP 14 BY 12 TO RETURN TO ADD TO REC CT\n         BR    14\nML03     OPEN  (DCBIN)\n         MVI   ML01+1,X'00'   NOP 1ST TIME SWITCH\n         B     ML02A\nML04     L     13,SAVEAREA+4\n         LM    14,12,12(13)\n         LA    15,0(0,0)\n         BR    14\nSAVEAREA DC    18F'0'\nRECAREA  DS    CL900\nDCBIN    DCB   DDNAME=INP1,DSORG=PS,MACRF=GM,EODAD=ML04\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RRDINP2": {"ttr": 259, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00C\\x00\\x890o\\x00\\x890o\\x14\\x18\\x00\\x1f\\x00\\x1f\\x00\\x00\\xe2\\xd7\\xc5\\xd5\\xc3\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-02T00:00:00", "modifydate": "1989-11-02T14:18:43", "lines": 31, "newlines": 31, "modlines": 0, "user": "SPENCER"}, "text": "RRDINP2   CSECT\n*  THIS  MODULE  IS CALLED BY THE GENERATOR PROGRAM\n*         TO HANDLE READ INP1  / ONLY DIFF BETWEEN INP1 2 & 3 ARE\n*          REG USED FOR REC AREA AND DDNAME IN DCB\n         SAVE  (2,12),T,*\n         BALR  12,0\n         USING *,12\n         ST    13,SAVEAREA+4\n         LR    4,13\n         LA    13,SAVEAREA\n         ST    13,8(4)\nML01     B     ML03             1ST SWITCH\nML02     GET   DCBIN,RECAREA\n         LA    8,RECAREA      LOAD 7 WITH REC AREA ADR                *\nML02A    L     13,SAVEAREA+4  RELOAD HIS REGS\n         LM    9,12,56(13)     ASSIGN TO HIS INP1 REC AREA\n         LM    14,7,12(13)     BYPASS LOADING 8 SINCE IT IS\n         LA    15,0(0,0)      SET RETURN CODE TO 0\n         LA    14,12(0,14)    BUMP 14 BY 12 TO RETURN TO ADD TO REC CT\n         BR    14\nML03     OPEN  (DCBIN)\n         MVI   ML01+1,X'00'   NOP 1ST TIME SWITCH\n         B     ML02A\nML04     L     13,SAVEAREA+4\n         LM    14,12,12(13)\n         LA    15,0(0,0)\n         BR    14\nSAVEAREA DC    18F'0'\nRECAREA  DS    CL900\nDCBIN    DCB   DDNAME=INP2,DSORG=PS,MACRF=GM,EODAD=ML04\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RRDINP3": {"ttr": 261, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00C\\x00\\x890o\\x00\\x890o\\x14\\x18\\x00\\x1f\\x00\\x1f\\x00\\x00\\xe2\\xd7\\xc5\\xd5\\xc3\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-02T00:00:00", "modifydate": "1989-11-02T14:18:43", "lines": 31, "newlines": 31, "modlines": 0, "user": "SPENCER"}, "text": "RRDINP3   CSECT\n*  THIS  MODULE  IS CALLED BY THE GENERATOR PROGRAM\n*         TO HANDLE READ INP1  / ONLY DIFF BETWEEN INP1 2 & 3 ARE\n*          REG USED FOR REC AREA AND DDNAME IN DCB\n         SAVE  (2,12),T,*\n         BALR  12,0\n         USING *,12\n         ST    13,SAVEAREA+4\n         LR    4,13\n         LA    13,SAVEAREA\n         ST    13,8(4)\nML01     B     ML03             1ST SWITCH\nML02     GET   DCBIN,RECAREA\n         LA    9,RECAREA      LOAD 7 WITH REC AREA ADR                *\nML02A    L     13,SAVEAREA+4  RELOAD HIS REGS\n         LM    10,12,60(13)    ASSIGN TO HIS INP1 REC AREZ\n         LM    14,8,12(13)     BYPASS LOADING 9 SINCE IT IS\n         LA    15,0(0,0)      SET RETURN CODE TO 0\n         LA    14,12(0,14)    BUMP 14 BY 12 TO RETURN TO ADD TO REC CT\n         BR    14\nML03     OPEN  (DCBIN)\n         MVI   ML01+1,X'00'   NOP 1ST TIME SWITCH\n         B     ML02A\nML04     L     13,SAVEAREA+4\n         LM    14,12,12(13)\n         LA    15,0(0,0)\n         BR    14\nSAVEAREA DC    18F'0'\nRECAREA  DS    CL900\nDCBIN    DCB   DDNAME=INP3,DSORG=PS,MACRF=GM,EODAD=ML04\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RREOJMOT": {"ttr": 263, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00C\\x00\\x890o\\x00\\x890o\\x14\\x18\\x005\\x005\\x00\\x00\\xe2\\xd7\\xc5\\xd5\\xc3\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-02T00:00:00", "modifydate": "1989-11-02T14:18:43", "lines": 53, "newlines": 53, "modlines": 0, "user": "SPENCER"}, "text": "RREOJMOD  CSECT\n*  THIS MODULE IS CALLED BY THE GENERATOR PROGRAM\n*    TO PRINT OUT\n*      TOTALS AT EOJ OF GOOD RUN  NOTE: R5 POINTS TO TOTALS\n         SAVE  (2,12),T,*\n         BALR  12,0\n         USING *,12\n         ST    13,SAVEAREA+4\n         LA    13,SAVEAREA\n         OPEN  (DCBPRT,(OUTPUT))\n         MVC   PRTREC(133),PRTREC-1    CLEAR PRT REC\n         PUT   DCBPRT,PRTREC+1    SPACE 1 LINE\n         MVI   PRTREC,X'09'            CHG TO SKIP 1\n         LR    6,5          R6= LHE ADR OF TOTALS\n         LA    7,PRTLINES   R7= HEADER LINES\n         LA    8,8(0,0)           R8=9 FOR TALLY\nML08     MVC   PRTREC+1(16),0(7)  MOVE HEADER INFO TO PRT RECORD\n         UNPK   PRTREC+9(8),0(4,6) UNPACK TOTAL\n         OI    PRTREC+16,X'F0'     REMOVE SIGN\n         PUT   DCBPRT,PRTREC+1     PRINT TOTAL\n         BCT   8,ML10           Q. PRINTED ALL TOTALS\n         CLOSE (DCBPRT)\n         L     13,SAVEAREA+4      *YES\n         LM    14,12,12(13)       * RETURN\n         LA    15,0(0,0)          *  CONTROL\n         BR    14                 *\nML10     LA    6,4(6)              BUMP R6 BY 4 (POINT TO NEXT TOTAL)\n         LA    7,16(7)             BUMP R7 BY 16 (POINT TO NEXT HDR)\n         B     ML08\nSAVEAREA DC    18F'0'\n         DC    CL2' '\nPRTREC   DS    CL133\nPRTLINES DC    CL8'PRINT---'\n         DC    CL8'0'\n         DC    CL8'INP1----'\n         DC    CL8'0'\n         DC    CL8'INP2----'\n         DC    CL8'0'\n         DC    CL8'INP3----'\n         DC    CL8'0'\n         DC    CL8'OUT1----'\n         DC    CL8'0'\n         DC    CL8'OUT2----'\n         DC    CL8'0'\n         DC    CL8'OUT3----'\n         DC    CL8'0'\n         DC    CL8'CARDIN--'\n         DC    CL8'0'\n         DC    CL8'PUNCH---'\n         DC    CL8'0'\nDCBPRT   DCB   DDNAME=SYSOUT,DSORG=PS,MACRF=PM,RECFM=U,                C\n               LRECL=120,BLKSIZE=120\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RRGEN": {"ttr": 265, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00C\\x00\\x890o\\x00\\x890o\\x14\\x18\\x08\\xee\\x08\\xee\\x00\\x00\\xe2\\xd7\\xc5\\xd5\\xc3\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-02T00:00:00", "modifydate": "1989-11-02T14:18:43", "lines": 2286, "newlines": 2286, "modlines": 0, "user": "SPENCER"}, "text": "IORTNS   START\n         USING SELF,R12\n         EJECT\nCOUNTS   DS    0F\nUSERBASE EQU   *\n         USING *,R5\n         DS    CL8192\n         ORG   *-8192\nPRCNT    DC    PL4'0'\nIN1CNT   DC    PL4'0'\nIN2CNT   DC    PL4'0'\nIN3CNT   DC    PL4'0'\nO1CNT    DC    PL4'0'\nO2CNT    DC    PL4'0'\nO3CNT    DC    PL4'0'\nCRDCNT   DC    PL4'0'\nPCHCNT   DC    PL4'0'\nIN1MOD   DC    1F'0'         * THESE WILL\nIN2MOD   DC    1F'0'         *   CONTAIN THE\nIN3MOD   DC    1F'0'         *     ADDRESS OF\nOT1MOD   DC    1F'0'         *       THE I/O MODULE\nOT2MOD   DC    1F'0'         *         AFTER LOAD\nOT3MOD   DC    1F'0'         *\nPRTMOD   DC    1F'0'         *\nRDCDMOD  DC    1F'0'         *\n         DS    0D\n         DC    XL8'00'\nCVDWORD  DC    XL8'00'\nRTCD     DC    CL8'00000000' 1ST J= RETURN CODE / LAST 4 = WORKAREA\nDATE6    DC    CL6'YYMMDD'\nDATE9    DC    CL9'DD MMM YY'\nDATE5    DC    CL5'YYDDD'\n         DS    0D                                                     *\nINXWK    DC    XL8'00'                                                *\nINX1     DC    CL4'0000'                                             **\nINX2     DC    CL4'0000'                                             **\nIOMOD    DC    A(IORTNS)\nAUGSUM   DS    CL9\nADDEND   DS    CL9\nEXITSK   DC    S(USERR)\n         DS    CL40\nFCON     DC    XL2'FFFF'\nCON2     DC    XL2'02'\nONE      DC    PL1'1'\nFIELD8   DC    CL8' '\nFIELD16  DC    CL16' '\nRESULT   DC    CL30' '\n         DS    0F\nUSERR    EQU   *              (EXIT EXECUTED WITHOUT ENTER)\n         LA    R15,9(0,0)        SET RETURN CODE TO 09-EXIT W/O ENTER\n         B     RETURN\nRETURN   EQU   *              * RETURN\n         L     R13,4(0,13)    *  CONTROL\n         RETURN (14,12),T,RC=(15)\nEOJRTN   EQU   *    THIS RTN SHOULD LOAD EOJ MODULE TO PRT TOTALS\n         LOAD  EPLOC=EOJMOD       LOAD EOJ MOD  TO PRT TOTALS\n         LR    R15,R0             LOAD 15 WITH EOJMOD EP LOCATION\n         BALR  R14,R15            BR TO EOJ MOD\n         PACK  CVDWORD,RTCD(4)     PACK RETURN CODE\n         CVB   R15,CVDWORD         CONVERT RETURN CODE TO BINARY IN R15\n         B     RETURN\nEOJMOD   DC    CL8'RREOJMOT'\nBADPARMS EQU   *  THIS RTN HANDLES BAD PARAMETERS = RETURNS WITH '900'\n         LA    R15,8(0,0)        SET RETURN CODE TO 08-PARAMETER ERROR\n         B     RETURN\n* NOTE: USED FOR RRGENSRT LOGIC\n         DS    0F\nSRT4     DC    XL4'04'   SORT ENTRY POINT + 4  'RELEASE'\nSRT8     DC    XL4'08'                    + 8  'SORT   '\nSRT12    DC    XL4'0C'                    + 12 'RETURN '\nSORTBR   L     R15,SRT8   LOAD SORT ENTRY POINT ADR + 8\n         BR    R15        GO TO INPUT EXIT RTN\nINPROC   B     *+0        TO BE FILLED IN WITH TAG ADR OF INPUT AND\nOUTPROC  B     *+0         OUTPUT PROCEDURES BEFORE PASSING CONTROL\n*                          TO USER . POINTED TO IN CALL LOGIC GENERATED\n*                          FOR RRGENSRT\n         EJECT\nUSERCODE DS    0D\n         ORG\n         EJECT\nSELF     DS    CL1772\nCARDID   DS    CL10\nCARD     DS    CL80\nPRTID    DS    CL11\nPRTAREA  DS    CL133\nPUNCHID  DS    CL10\nPCHREC   DS    CL80\nCONS     DC    8CL250' '\n         EJECT\n         DS    0D\nOURCODE  DS    CL8192\n         ORG   *-8192\n         USING *,R6,R7,R2\n         SAVE  (2,12),T,*\n         LR    R6,15       SET BASE 12 TO OURCODE\nHERE     L     R7,BR7\n         LA    R9,TAGTAB\n         L     R5,BR5\n         L    R12,=A(SELF)\n         ST    13,SYSAVE+4\n         LA    13,SYSAVE\n         MVC   CARDID(4),=CL4'CARD'\n         MVC   PUNCHID(5),=CL5'PUNCH'\n         MVC   PRTID(7),=CL7'PRINTER'\n         MVI   PRTAREA-1,X'40'\n         OPEN  (INCARD,INPUT,PRINTER,OUTPUT)\n         BAL   R14,DATERTN\n         MVC   DATE+6(9),DATEDMY   PUT SYS DATE IN TO HDR\n         BAL   R14,PRTHDR\n         B     RDPARM\nBR5      DC    A(IORTNS)\nBR7      DC    A(OURCODE+4096)\nBR13     DC    A(SYSAVE)\n         EJECT\nMLRTN    EQU   *\nML01     CLI   CARD+23,C'-'             Q. A-ADR INDEXED\n         BNE   ML02                       NO\n         MVC   AXIND,CARD+24              YES-SAVE INDEX NUMBER\n         MVC   CARD+23(9),CARD+25            -SHIFT TO ELIM DASH + INX\nML02     CLI   CARD+28,C'-'             O. B-ADR INDEXED\n         BNE   ML03                       NO\n         MVC   BXIND,CARD+29              YES-SAVE INDEX NUMBER\nML03     LA    R8,OPCODE+304   POINT 8 TO MIDPOINT OF TABLE\n         LA    R5,0                     LOAD 5 WITH 0\n         LA    R4,6            LOAD 4 WITH TALLY CT OF 6\nML04     CLC   CARD+6(5),0(R8)     Q. OPCODE = TABLE\n         BE    ML08                       YES\n         BCT   R4,ML05                 Q. NO-IS SEARCH FINI\nML04A    MVI   OPERR,C'E'                YES SET OPERATION ERR\n         MVI   NOGOSW,C'1'               TURN ON NO GO SWITCH.\n         B     PARPRT\nML05     BH    ML06                    Q. CARD OP > TABLE //YES ADD\n         S     R8,OPADRS(R5)       //NO SUB FROM TABLE ADR\n         B     ML07\nML06     A     R8,OPADRS(R5)\nML07     LA    R5,4(R5)                   BUMP REG 5 BY 4\n         B     ML04                       GO COMPARE AGAIN\nML08     MVC   OP(2),10(R8)        MOVE OPCODE+MASK TO INST\n         MVC   CONTROL(3),5(R8)    MOVE CONTROL INFO\n         MVC   ADR1(4),12(R8)\n         MVC   ML09+2(2),8(R8)     SETUP BRANCH TO APPRO OP CODE\nML09     B     ML09     *RTN & BRANCH TO IT\nOPCODE   DS    0F\n         DC    CL5'ADD  '          ADD\n         DC    CL3'016'\n         DC    S(SIZERTN)\n         DC    XL2'FA00'\n         DC    S(ADRRTN)\n         DC    S(ADDRTN)\n         DC    CL5'AP   '          AP\n         DC    CL3'016'\n         DC    S(SIZERTN2)\n         DC    XL2'FA00'\n         DC    S(ADRRTN)\n         DC    S(APRTN)\n         DC    CL8'CALL    '       CALL\n         DC    S(CALLRTN)\n         DC    XL2'0000'\n         DS    CL4\n         DC    CL5'COM  '          COM\n         DC    CL3'256'\n         DC    S(SIZERTN)\n         DC    XL2'D500'\n         DC    S(ADRRTN)\n         DC    S(COMRTN)\n         DC    CL5'CONS '          CONS\n         DC    CL3'040'\n         DC    S(SIZERTN)\n         DC    XL2'0000'\n         DC    S(AADRRTN)\n         DC    S(CONSRTN)\n         DC    CL5'CP   '          CP\n         DC    CL3'016'\n         DC    S(SIZERTN2)\n         DC    XL2'F900'\n         DC    S(ADRRTN)\n         DC    S(CPRTN)\n         DC    CL5'CVBZ'          CVBZ\n         DC    CL3'016'\n         DC    S(SIZERTN2)\n         DC    XL2'FFFF'\n         DC    S(ADRRTN)\n         DC    S(CVBZNRTN)\n         DC    CL5'CVZB'          CVZB\n         DC    CL3'016'\n         DC    S(SIZERTN2)\n         DC    XL2'FFFF'\n         DC    S(ADRRTN)\n         DC    S(CVBINRTN)\n         DC    CL5'DVD  '          DIVIDE\n         DC    CL3'015'\n         DC    S(SIZERTN2)\n         DC    XL2'FFFF'\n         DC    S(ADRRTN)\n         DC    S(DVDRTN)\n         DC    CL8'ENTER   '       ENTER\n         DC    S(ENTRTN)\n         DC    XL2'47F0'\n         DS    CL4\n         DC    CL8'EXIT    '       EXIT\n         DC    S(EXRTN)\n         DS    CL6\n         DC    CL8'GE      '        GE\n         DC    S(BRRTN)\n         DC    XL2'4780'\n         DS    CL4\n         DC    CL8'GH      '        GH\n         DC    S(BRRTN)\n         DC    XL2'4720'\n         DS    CL4\n         DC    CL8'GL      '        GL\n         DC    S(BRRTN)\n         DC    XL2'4740'\n         DS    CL4\n         DC    CL8'GNE     '        GNE\n         DC    S(BRRTN)\n         DC    XL2'4770'\n         DS    CL4\n         DC    CL8'GO      '       GO\n         DC    S(BRRTN)\n         DC    XL2'47F0'\n         DS    CL4\n         DC    CL5'MOVE '          MOVE\n         DC    CL3'900'\n         DC    S(SIZERTN)\n         DC    XL2'D200'\n         DC    S(ADRRTN)\n         DC    S(MOVERTN)\n         DC    CL5'MPY  '          MULTIPLY\n         DC    CL3'015'\n         DC    S(SIZERTN2)\n         DC    XL2'FFFF'\n         DC    S(ADRRTN)\n         DC    S(MPYRTN)\n         DC    CL5'MVN  '          MVN\n         DC    CL3'256'\n         DC    S(SIZERTN)\n         DC    XL2'D100'\n         DC    S(ADRRTN)\n         DC    S(MVNRTN)\n         DC    CL5'MVO  '          MVO\n         DC    CL3'016'\n         DC    S(SIZERTN2)\n         DC    XL2'F100'\n         DC    S(ADRRTN)\n         DC    S(MVORTN)\n         DC    CL5'MVZ  '          MVZ\n         DC    CL3'256'\n         DC    S(SIZERTN)\n         DC    XL2'D300'\n         DC    S(ADRRTN)\n         DC    S(MVZRTN)\n         DC    CL5'NC   '          NC\n         DC    CL3'256'\n         DC    S(SIZERTN)\n         DC    XL2'D400'\n         DC    S(ADRRTN)\n         DC    S(NCRTN)\n         DC    CL5'OC   '          OC\n         DC    CL3'256'\n         DC    S(SIZERTN)\n         DC    XL2'D600'\n         DC    S(ADRRTN)\n         DC    S(OCRTN)\n         DC    CL5'PACK '          PACK\n         DC    CL3'016'\n         DC    S(SIZERTN2)\n         DC    XL2'F200'\n         DC    S(ADRRTN)\n         DC    S(PACKRTN)\n         DC    CL8'PRINT   '       PRINT\n         DC    S(PRTRTN)\n         DC    XL2'0000'\n         DS    CL4\n         DC    CL8'READ    '       READ\n         DC    S(RDRTN)\n         DC    XL2'0000'\n         DS    CL4\n         DC    CL5'SP   '          SP\n         DC    CL3'016'\n         DC    S(SIZERTN2)\n         DC    XL2'FB00'\n         DC    S(ADRRTN)\n         DC    S(SPRTN)\n         DC    CL5'SUB  '          SUB\n         DC    CL3'016'\n         DC    S(SIZERTN)\n         DC    XL2'FB00'\n         DC    S(ADRRTN)\n         DC    S(SUBRTN)\n         DC    CL8'TPM     '       TPM\n         DC    S(TPMRTN)\n         DC    XL2'4720'\n         DS    CL4\n         DC    CL5'TRANS'     TRANS\n         DC    CL3'256'\n         DC    S(SIZERTN)\n         DC    XL2'DC00'\n         DC    S(ADRRTN)\n         DC    S(TRRTN)\n         DC    CL8'TRZ     '       TRZ\n         DC    S(BRRTN)\n         DC    XL2'4780'\n         DS    CL4\n         DC    CL5'UNPK '          UNPK\n         DC    CL3'016'\n         DC    S(SIZERTN2)\n         DC    XL2'F300'\n         DC    S(ADRRTN)\n         DC    S(UNPKRTN)\n         DC    CL8'UTC     '       UTC\n         DC    S(BRRTN)\n         DC    XL2'47F0'\n         DS    CL4\n         DC    CL8'WRITE   '       WRITE\n         DC    S(WRTRTN)\n         DC    XL2'0000'\n         DS    CL4\n         DC    CL5'XC   '          XC\n         DC    CL3'256'\n         DC    S(SIZERTN)\n         DC    XL2'D700'\n         DC    S(ADRRTN)\n         DC    S(XCRTN)\n         DC    CL5'XCONS'          XCONS\n         DC    CL3'020'\n         DC    S(SIZERTN)\n         DC    XL2'0000'\n         DC    S(AADRRTN)\n         DC    S(XCONSRTN)\n         DC    3CL16'ZZZZZZZZZZZZZZZZ'\nOPADRS   DS    0F            * THIS TABLE IS USED TO BINARY\n         DC    XL4'A0'        * SEARCH THE OPCODE TABLE  * DECIMAL 160\n         DC    XL4'50'        *                                     80\n         DC    XL4'20'        *                                     32\n         DC    XL4'10'        *                                     16\n         DC    XL4'10'             *                         *DEC 16\n         EJECT\nIN1      DC    CL6'ITAPE1'\nADRA      DC   XL2'7000'     LHE ADR OF REC AREA\n         DC    F'0'                     SIZE OF REC AREA\n         DC    F'0'                     BLOCK FACTOR\n         DC    F'0'                     BLOCK SIZE\n         DS    CL20                     STORAGE FOR CARD COL 22 THRU 41\nIN2      DC    CL6'ITAPE2'\nADRB      DC   XL2'8000'\n         DS    CL32\nIN3      DC    CL6'ITAPE3'\nADRC      DC   XL2'9000'\n         DS    CL32\nDK1      DC    CL6'DISK1 '\nADRD     DC    H'0'\n         DS    CL32\nDK2      DC    CL6'DISK2 '\nADRE     DC    H'0'\n         DS    CL32\nOUT1     DC    CL6'OTAPE1'\nADRJ     DC    XL2'B000'                0 + R 10\n         DS    CL32\nOUT2     DC    CL6'OTAPE2'\nADRK     DC    XL2'B384'      900 DECIMAL + R 10\n         DS    CL32\nOUT3     DC    CL6'OTAPE3'\nADRL     DC    XL2'B708'     1800 DECIMAL + R 10\n         DS    CL32\n         DS    0F                      *FORMAT AABBBBBB\nAINXAR   DC    6XL4'FFFFFFFF'                                    ******\nBINXAR   DC    6XL4'FFFFFFFF'                                    ******\nINSHOLD  DS    0XL80                   * WHERE  A= SIZE OF INST-1\n         DC    10XL8'FFFFFFFFFFFFFFFF' *        B= INSTRUCTION\nXIND     DS    0CL2      INDEXING INDICATOR\nAXIND    DC    XL1'00'   00=NO INDEXING ON A-ADR F1= INX1 F2=INX2 *****\nBXIND    DC    XL1'00'   00=NO INDEXING ON B-ADR F1= INX1 F2=INX2 *****\n**** INSTUCTION BUILD AREA\n         DS    0F\nSSINST   DS    0CL6      OP/L1L2/B1D1/B2D2 OR OP/LENGTH/B1D1/B2D2\nRXINST   DS    0CL4      OP/M1X1/B1D1\nOP       DS    CL1\nLEN      DS    CL1       L1L1L2L2 OR LLLLLLLL OR MMMMXXXX\nB1D1     DS    0CL2      BBBBDDDD/DDDDDDDD\nB1       DS    CL1\nD1       DS    CL1\nB2D2     DS    0CL2      BBBBDDDD/DDDDDDDD\nB2       DS    CL1\nD2       DS    CL1\n**                       EXECUTING THE GENERATED CODE. IF = 1 PROGRAM\nLOCERR   DC    CL1' '   *ERROR FLAGS * SPACE=NO ERROR\nOPERR    DC    CL1' '   *               E   =ERROR\nSIZEERR  DC    CL1' '\nADRERR   DC    CL1' '\nNOGOSW   DC    CL1'0'   * THIS SW IS SET IF AN ERROR IS FOUND IN A\n**                       PARAMETER DURING GENERATION. IS CKED BEFORE\n**                       IS ABORTED.\nCONTROL  DS    0CL9\nSZEDIT   DS    CL3       EDIT CRITERIA FOR SIZE RTN.\nADR1     DS    CL2\nADR2     DS    CL2\nISCON    DC    CL3'IS '\nISRCON   DC    CL3'ISR'\nEOJCON   DC    CL3'EOJ'\nENDUSER  DC    A(USERBASE+8192)\nCENDUSER DC    A(USERBASE+8192)\nBDLIST   DC    XL2'6FFF'\n         EJECT\n         DS    0F\nRDPARM   EQU   *\n******** THIS  ROUTINE READS INPUT PARAMETERS.\n         GET   INCARD,CARD\n         CLI   CARD,C'T'    Q. IS THERE A TAG\n         BNE   NOTAG     NO\n         PUT   PRINTER,PRTAREA    YES SPACE 1 LINE\nNOTAG    MVC   PRTAREA+18(80),CARD\n         CLI   CARD,C'*'           Q. IS THIS A REMARK\n         BNE   NOREMARK              NO\n         PUT   PRINTER,PRTAREA+1        YES PRINT IT\n         MVC   PRTAREA(133),PRTAREA-1   CLEAR REMARK OUT OF PRT AREA\n         B     RDPARM                   GO READ NEXT RECORD\nNOREMARK MVC   AXIND(2),=XL2'0000'  TURN INDEX IND OFF\nIOSWITCH BC    15,IOCK01          * THIS INS NOP AFTER LAST IO PARM.\nNONIO    CLC   CARD(4),=CL4'STOP'\n         BE    PAREND\n         CLC   CARD(4),=C'    '\n         BE    MLRTN\n         BAL   R14,TAGRTN\n         B     MLRTN\nIOCK01   MVI   IOSWITCH+1,X'00'\n         L     R11,RECAR\n         LH    R10,USERBD\n         B     NONIO\nRECAR    DC    A(USERCODE)\nUSERBD   DC    S(USERCODE)\n         EJECT\nPARPRT   EQU   *\n*******  THIS ROUTINE PRINTS THE INPUT CARD AND THE MACHINE CODE ******\n*** GENERATED FOR THE PARAMETER. THE MACHINE CODE AND ITS MACHINE *****\n*** ADDRESS WILL BE PRINTED IN HEXIDECIMAL.                      ******\n         MVI   PARM01C+1,X'00'   TURN OFF PRT BYPASS SW\n         LA    R3,AINXAR                ***********************  ******\n         CLC   AINXAR(2),FFCON        *SET UP INSTRUCTION HOLD*  ******\n         BE    PARPRT01               * AREA FOR PARAMETER    *  ******\n         CLC   BINXAR(2),FFCON        * PRINT ROUTINE.        *  ******\n         BNE   PARPRTR                * INSTUCTIONS START AT  *  ******\n         MVC   BINXAR(80),INSHOLD     *  INSHOLD IF NO INDEXES*  ******\n         B     PARPRTR                *     IF INDEXING       *  ******\nPARPRT01 LA    R3,BINXAR              *  INSTRUCTIONS WILL BE *  ******\n         CLC   BINXAR(2),FFCON        *  IN AINXAR OR BINXAR  *  ******\n         BNE   PARPRTR                  *      OR                 *****\n         LA    R3,INSHOLD               *     BOTH                *****\nPARPRTR  LA    R5,8(0)\n         CLC   LOCERR(4),=CL4'    '\n         BNE   PARMERR\n         CLC   0(2,R3),FFCON\n         BE    PARM02\nPARM01   MVC   HEXHLD(6),FFCON\n         ST    R11,HEXHLD         STORE ACTUAL INST ADR\n         BAL   R14,HEXRTN         GO CONVERT TO HEX PRINT A=C1\n         MVC   PRTAREA+111(6),CONVHEX+2      ACT ADR TO PRT LINE\n         STH   R10,HEXHLD\n         C     R11,ENDUSER      Q. OUT OF MEM FOR GEN USER INSTRUCTIONS\n         BL    PARM01A                 NO\n         LA    R15,10(0,0)     YES-SET RETURN CODE TO 10-OUT OF MEMORY\n         LA    R5,USERBASE         LOAD R5 SO THE RETURN RTN CAN BE USE\n         B     RETURN               GO TO RETURN\nPARM01A  MVC   0(6,R11),2(R3)      MOVE INST TO USERCODE\n         LA    R8,1(0)\n         MVI   0(R3),X'00'\n         AH    R8,0(R3)\n         AR    R10,R8\nPARM01B  AR    R11,R8\n         BAL   R14,HEXRTN\n         MVC   PRTAREA+103(4),CONVHEX\nPARM01C  NOP   PARM02A    BYPASS PRINTING EXCEPT 1ST LINE\nPARM02   PUT   PRINTER,PRTAREA+1\n         MVI   PARM01C+1,X'F0'  TURN ON SW\nPARM02A  MVC   PRTAREA(133),PRTAREA-1\n         MVC   0(2,R3),FFCON\n         AR    R3,R5\n         CLC   0(2,R3),FFCON\n         BNE   PARM01\n         B     RDPARM\nPARMERR  MVI   NOGOSW,C'1'\n         CLC   LOCERR(1),=C'E'\n         BE    ERR01\n         CLC   OPERR(1),=C'E'\n         BE    ERR02\n         CLC   SIZEERR(1),=C'E'\n         BE    ERR03\n         MVC   PRTAREA+1(13),=CL13'ADDRESS ERROR'\nERREXIT  MVC   LOCERR(4),=C'    '\n         MVI   AINXAR,X'FF'                                      ******\n         MVC   AINXAR+1(127),AINXAR                              ******\n         B     PARM02\nERR01    MVC   PRTAREA+1(14),=CL14'LOCATION ERROR'\n         B     ERREXIT\nERR02    MVC   PRTAREA+1(15),=CL15'OPERATION ERROR'\n         B     ERREXIT\nERR03    MVC   PRTAREA+1(10),=CL10'SIZE ERROR'\n         B     ERREXIT\n         EJECT\nBXRTN    EQU   *                                                 ******\n*******  THIS  ROUTINE ALTERS THE CODE THAT ALLOWS INDEXING FOR  ******\n**@****  ADDRESS AT B1D1. THE CODE TO PACK THE INDEX FIELD,       *****\n*******  CONVERT INDEX TO BINARY AND ADD THE INDEX TO THE BASE   ******\n*******  IS PLACED IN LINE. R3= B ADDR IND REG,R2='A'ADDR INX.   ******\n         XR    R4,R4         *CLEAR REG 4.                       ******\n         IC    R4,B1D1       *GET REAL BASE REG.                 ******\n         SRL   R4,4(0)       *MOVE BASE REG TO LOW DIGIT OF R4.   *****\n         MVZ   B1D1(1),=X'30'                                        **\n         STC   R4,INSTIX3+3  *BASE REG TO ADD REG INS.            *****\n         MVZ   INSTIX3+3(1),=X'30' *B INDEX REG   TO ADD REG INS.******\n         MVZ   INSTIX2+3(1),=X'30' *B INDEX REG TO CVB INS.      ******\n         CLI   BXIND,X'F1'   *'B' ADDR NEED INX1 2               ******\n         BNE   BXRTN02        NO                                 ******\nABXCOM   MVC   BINXAR(8),INSTIX1  * PACK INX1 INS TO HOLD AREA.  ******\nBXRTN01  MVC   BINXAR+8(6),INSTIX2 * CVB INS TO HOLD AREA.       ******\n         MVC   BINXAR+16(4),INSTIX3 * AR INS TO HOLD AREA.        *****\n         BR    R14                    RETURN                     ******\nBXRTN02  MVC   BINXAR(8),INSTIX4   * PACK INX2 INS TO HOLD AREA. ******\n         CLI   BXIND,X'F2'        *B ADR NEED IN2                ******\n         BE    BXRTN01                                           ******\n         MVI   ADRERR,C'E'                                        *****\n         B     PARPRT                                            ******\nAXRTN    EQU   *                                                  *****\n***  THIS RTN INDEXES THE ADDRESS AT B2D2.                        *****\n         XR    R4,R4         * CLEAR REG 4                        *****\n         IC    R4,B2D2       * GET REAL BASE                      *****\n         SRL   R4,4(0)       * BASE REG TO LOW DIGIT OF R4.       *****\n         STC   R4,INSTIX3+3  * BASE REG TO AR INS.                *****\n         MVZ   B2D2(1),=X'20'                                        **\n         MVZ   INSTIX3+3(1),=X'20' 'A' INX REG TO AR INS.         *****\n         MVZ   INSTIX2+3(1),=X'20' 'A' INX REG TO CVB INS.        *****\n         CLI   AXIND,X'F1'        *'A' ADDR NEED INX1.?           *****\n         BNE   AXRTN02                                            *****\n         MVC   AINXAR(8),INSTIX1   * PK INX1 INS TO HOLD AREA.    *****\nAXRTN01  MVC   AINXAR+8(6),INSTIX2  * CVB INS TO HOLD AREA.       *****\n         MVC   AINXAR+16(4),INSTIX3  * AR INS TO HOLD AREA.       *****\n         BR    R14                                                *****\nAXRTN02  MVC   AINXAR(8),INSTIX4      * PK INX2 INS TO HOLD AREA. *****\n         CLI   AXIND,X'F2'                                        *****\n         BE    AXRTN01                                            *****\n         MVI   ADRERR,C'E'                                        *****\n         B     PARPRT                                             *****\nINSTIX1  DC    XL2'05'                                            *****\n         PACK  INXWK(8),INX1(4)                                   *****\nINSTIX2  DC    XL2'03'                                            *****\n         CVB   R2,INXWK                                           *****\nINSTIX3  DC    XL2'01'                                            *****\n         AR    R2,R3                                              *****\nINSTIX4  DC    XL2'05'                                            *****\n         PACK  INXWK(8),INX2(4)                                   *****\n         EJECT\nPRTHDR   EQU   *\n******* THIS ROUTINE PRINTS THE HEADER AND RESTORES THE LINE COUNT.****\n         ST    R14,HDRSAVE\n         MVC   PRTAREA(133),PRTAREA-1\n         MVI   PRTAREA,X'89'\n         PUT   PRINTER,PRTAREA+1\n         MVC   PRTAREA+1(132),HEADER1\n         MVI   PRTAREA,X'09'\n         PUT   PRINTER,PRTAREA+1\n         MVC   PRTAREA+1(132),HEADER2\n         MVI   PRTAREA,X'19'\n         PUT   PRINTER,PRTAREA+1\n         MVC   PRTAREA(133),PRTAREA-1\n         MVI   LINECT,X'3E'\n         PUT   PRINTER,PRTAREA+1         SPACE ATER HDRS\n         L     R14,HDRSAVE\n         BR    R14\nHDRSAVE  DS    F'0'\n         DS    0F\nPKONE    DC    PL2'1'\nPAGECT   DC    PL2'+0'\nHEADER1  DS    0CL132\nDATE     DC    CL20'DATE                '\n         DC    CL31'360 GENERATOR PARAMETER LISTING'\n         DC    CL53' '\n         DC    CL10'ADDRESS   '\n         DC    CL18' '\nHEADER2  DS    0CL132\n         DC    CL17'ERROR FLAGS     /'\n         DC    CL29'LOC    OP    SIZE   ADDRESS  '\n         DC    CL32'      CONSTANTS OR REMARKS      '\n         DC    CL33'                     BASE/DISP   '\n         DC    CL21'ACTUAL               '\nLINECT   DS    CL1\n         DS    0F\n         EJECT\nHEXRTN   EQU   *\n**** THIS ROUTINE CONVERTS THE SIX BYTE FIELD AT HEXHLD. ONE BYTE *****\n***** AT HEXHLD IS CONVERTED TO ITS TWO BYTE HEX EQUIVILANT FOR   *****\n*****  PRINTING. ('A' AT HEXHLD =  'C1' AT CONVHEX. CNVCNT IS     *****\n***** USED TO BUMP THE ADDRESS COUNTERS (R10 AND R11) AFTER INS   *****\n*****  IS MOVED TO USER AREA.                                     *****\n         UNPK  CONVHEX(13),HEXHLD(7)    UNPACK HEXHLD\n         CLC   CONVHEX+8(4),FFCON      Q. DATA = 6 POS9\n         BNE   HEX01                    A.YES\n         CLC   CONVHEX+4(4),FFCON      Q. DATA = 4 POS\n         BNE   HEX02                    A.YES\n         MVI   CNVCNT,X'03'\n         B     HEX03\nHEX01    MVI   CNVCNT,X'0B'\n         B     HEX03\nHEX02    MVI   CNVCNT,X'07'\nHEX03    TR    CONVHEX(12),HEXTAB       CONVERT TO HEX FOR PRINT.\n         MVC   HEXHLD(6),FFCON               CLEAR HEXHOLD\n         BR    R14\n         DS    0F\nHEXHLD   DC    XL7'FFFFFFFFFFFF04'\n         DC    CL1' '\nCONVHEX  DC    XL12'00'\nCNVCNT   DC    XL1'00'\nPACK1    DC    PL2'1'\nPAGECNT  DC    PL2'0'\nLINECNT  DC    H'56'\n         EJECT\nBRRTN    EQU   *\n**** THIS ROUTINE HANDLES GENERATION OF TAG ADDRESSES FOR BRANCH ******\n***** INSTRUCTIONS. THIS ROUTINE PLACES A '2' IN REG5 FOR TGRTN. ******\n         LA    R4,2(0)\n         BAL   R14,TGRTN\n         MVC   INSHOLD+2(4),RXINST\n         MVI   INSHOLD+1,X'03'\n         B     PARPRT\n         EJECT\nTPMRTN   EQU   *\n**** THIS RTN HANDLES GENERATION OF A&B ADRS FOR TPM INST. THIS  ******\n***** RTN GENERATES TWO INST.(BH&BL),PLACES A'2'IN R4 IF'A'ADR OF******\n***** TPM AND A'6'IN R4 IF'B'ADR OF TPM.                         ******\n         LA    R4,2(0)\n         BAL   R14,TGRTN\n         MVI   INSHOLD+1,X'03'\n         MVC   INSHOLD+2(4),RXINST\n         LA    R4,6(0)\n         MVC   0(4,R11),INSHOLD+2      * MOVE 1 BR IN LINE\n         MVC   OP(2),=XL2'4740'\n         MVC   CARD+19(4),CARD+24\n         BAL   R14,TGRTN\n         MVI   INSHOLD+9,X'03'\n         MVC   INSHOLD+10(4),RXINST\n         MVC   INSHOLD+2(4),0(R11) * MOVE IT BACK / TGRTN MAY CHG IT\n         B     PARPRT\n         EJECT\nSIZERTN  EQU   *\n**** THIS ROUTINE VALIDATES SIZE ENTRY ACCORDING TO CONTROL INFO.******\n***** THE SIZE IS PASSED TO CONVERSION RTN RIGHT JUSTIFIED IN    ******\n****** SIZEWK.                                                   ******\n         MVC   SIZEWK,SZZERO\n         CLC   CARD+13(1),=C' '        Q. SIZE 1 POS.\n         BE    SZ01                     A.YES\n         CLC   CARD+14(1),=C' '        Q. SIZE 2 POS\n         BE    SZ02                     A.YES\n         CLC   CARD+15(1),=C' '        Q. SIZE TOO BIG\n         BNE   SZERR                    A.YES\n         MVC   SIZEWK+1(3),CARD+12      MOVE 3 POS SIZE TO SIZEWK.\n         B     SZ03\nSZ01     MVC   SIZEWK+3(1),CARD+12      MOVE 1 POS SIZE TO SIZEWK.\n         B     SZ03\nSZ02     MVC   SIZEWK+2(2),CARD+12      MOVE 2  POS SIZE TO SIZEWK.\nSZ03     CLC   SZEDIT(3),SIZEWK+1      Q. SIZE GREATER THAN MAX.\n         BL    SZERR                    A.YES\n         BAL   R14,CNVRTN               PERFORM CONVERSION RTN.\n         C     R3,FFCON                Q. CONVERSION GOOD.\n         BE    SZERR                    A.NO\n         C     R3,ZERO                 Q. SIZE = ZERO.\n         BE    SZERR                    A.YES\n         BCTR  R3,0                     DECREMENT SIZE BY 1.\n         ST    R3,SIZEHLD               HOLD IN SIZE HOLD.\n         MVC   SZEXIT+2(2),ADR1         MOVE NEXT RTN ADR TO BR.\nSZEXIT   B     SZEXIT                   BRANCH TO NEXT RTN.\nSZERR    MVI   SIZEERR,C'E'             SET SIZE ERROR FLAG.\n         MVI   NOGOSW,C'1'\n         B     PARPRT                   GO PRT PARMETER.\n         DS    0D\nSIZWK    DC    CL4'0000'\nSIZEWK   DC    CL4'0000'\nFFCON    DC    XL8'FFFFFFFFFFFFFFFF'\nSIZEHLD  DC    XL4'00'\nSZZERO   DC    CL4'0000'\n         EJECT\nSIZERTN2 EQU   *\n* THIS RTN HANDLES INST WITH  TWO SIZE ENTRIES  EG 4,6\n         DS    0F\n         MVC   HOLDSZ,CARD+12      SAVE SIZE FIELD\n         MVC   SZ2RTNEX+2(2),ADR1  SAVE ADR OF WHERE SIZE RTN GOES NEXT\n         MVC   ADR1,SZRETRN1       MAKE SIZE RTN COME BACK AFTER 1ST\n         MVI   CARD+12,X'40'       * CLEAR\n         MVC   CARD+13(5),CARD+12  *  SIZE FIELD\n         CLI   HOLDSZ+1,C','       Q. 1 POS SIZE\n         BNE   SZ2RTN9        NO\n         MVC   CARD+12(1),HOLDSZ       YES- MOVE 1 POS SIZE BK TO CARD\n         MVC   HOLDSZ2(3),HOLDSZ+2      SAVE SECOND SIZE\n         B     SIZERTN                  PERFORM SIZE RTN\nSZ2RTN3  MVC   HLDSZRS,SIZEHLD          SAVE SIZE FROM SIZE RTN\n         MVC   ADR1,SZRETRN2            CHG RETURN IN SIZE RTN\n         MVC   CARD+12(3),HOLDSZ2       MOVE SECOND SIZE TO SIZE FIELD\n         B     SIZERTN        GO CONVERT SECOND SIZE\nSZ2RTN6  SLA   R3,4(0)                  MOVE RESULTS TO TOP OF BYTE\n         ST    R3,SIZEHLD               STORE SHIFTED RESULTS\n         OC    SIZEHLD+3(1),HLDSZRS+3   PUT SIZES TOGETHER\nSZ2RTNEX B     *+0\nSZ2RTN9  CLI   HOLDSZ+2,C','     Q. 2 POS SIZE\n         BNE   SZERR                 NO-SIZE ERROR\n         MVC   CARD+12(2),HOLDSZ     MOVE 2 POS SIZE TO SIZE FIELD\n         MVC   HOLDSZ2(3),HOLDSZ+3   SAVE 2ND SIZE\n         B     SIZERTN               PERFORM SIZE RTN/RETURN TO SZ2RTN3\nSZRETRN1 DC    S(SZ2RTN3)\nSZRETRN2 DC    S(SZ2RTN6)\nHOLDSZ   DS    CL6\nHLDSZRS  DS    1F\nHOLDSZ2  DC    CL6'      '\n         DS    0F\n         EJECT\nADRRTN   MVC   ADRWK,CARD+24            MOVE B-ADR TO WORK AREA\n         BAL   R14,ADR01                PERFORM ADR CONVERSION\n         STH   R4,B1D1\n         CLI   BXIND,X'00'                                           **\n         BE    *+8                                                   **\n         BAL   R14,BXRTN                                             **\nAADRRTN  MVC   ADRWK,CARD+19            MOVE A-ADR TO WORK AREA\n         BAL   R14,ADR01                PERFORM ADR CONVERSION\n         STH   R4,B2D2\n         CLI   AXIND,X'00'                                           **\n         BE    *+8                                                   **\n         BAL   R14,AXRTN                                             **\n         MVC   ADRRTNX+2(2),ADR2        SET UP TO BR TO INST GEN RTN\n         L     R2,OUR8192 LOAD BASE FOR I/O IN CASE THEY USE ADRRTN\nADRRTNX  B     ADRRTNX                  BRANCH TO APPRO RTN\nADR01    ST    R14,ADRSV                SAVE RETURN ADR\n         CLC   ADRWK(2),=C'CD'       Q. ADDRESS CD\n         BNE   ADR05                     NO\n         LH    R4,ADRCD                  YES-LOAD REG 4 WITH CD ADDRESS\nADR03    MVC   SIZEWK+2(2),ADRWK+2       MOVE RELATIVE ADR TO SIZE WK\n         BAL   R14,CNVRTN\n         C     R3,FFCON              Q. WAS ADR VALID\n         BE    ADR27                    NO\n         CLC   ADRWK+2(2),=C'80'     Q. YES-IS RELATIVE > 80\n         BH    ADR27                    YES- INVALID\nADR04    N     R4,=X'0000FFFF'\n         AR    R4,R3                    NO - ADD RELATIVE ADR TO LHE\n         B     ADR0X                    GO EXIT RTN\nADR05    CLI   ADRWK,C'P'            Q. ADR  P OR PC\n         BNE   ADR09                    NO- GO CK FOR OTHER ADRS\n         CLI   ADRWK+1,C'C'          Q. YES - IS IT PC\n         BNE   ADR07                    NO- MUST BE PRINT\n         LH    R4,ADRPC                 YES- LOAD REG 4 WITH PUNCH ADR\n         B     ADR03                    GO VALIDATE\nADR07    LH    R4,ADRPT                 LOAD REG 4 WITH PRINT ADR\n         MVC   SIZEWK+1(3),ADRWK+1      MOVE RELATIVE ADR TO SIZE WORK\n         BAL   R14,CNVRTN                VALIDATE AND CONVERT TO BINARY\n         C     R3,FFCON         Q. WAS ADR VALID\n         BE    ADR27               NO-\n         CLC   ADRWK+1(3),=C'132' Q. IS RELATIVE > 132\n         BH    ADR27                 YES- INVALID\n         B     ADR04                 NO-VALID-PREPARE TO EXIT\nADR09    CLC   ADRWK,=C'SELF'     Q. IS IT SELF ADR\n         BNE   ADR11                 NO\n         BAL   R14,SELF01            YES-PEFORM SELF RTN\n         B     ADR0X                 GO EXIT RTN\nADR11    CLC   ADRWK,=C'DATE'     Q. IS IT DATE ADR\n         BNE   ADR13                 NO\n         CLI   CARD+12,C'9'        Q. WANT DD MMM YY\n         BNE   ADR11A                 NO\n         LH    R4,DATEAL9             YES- LOAD IT'S ADR\n         B     ADR0X\nADR11A   CLI   CARD+12,C'5'        Q. WANT YYDDD\n         BNE   ADR11B                 NO - ASSUME HE WANTS YYMMDD\n         LH    R4,DATEJU5             YES- LOAD IT'S ADR\n         B     ADR0X\nADR11B   LH    R4,DATENU6             LOAD ADR OF  YYMMDD\n         B     ADR0X                 GO EXIT RTN\nADR13    CLI   ADRWK,C'2'      Q. IS IT THE WORK AREA ADR (2000-5999)\n         BL    ADR13A             NO- CK CONS\n         LH    R4,ADRWORK            YES-LOAD ADR OF WORK\n         MVC   SIZEWK,ADRWK       MOVE REL ADR TO SIZE WORK\n         BAL   R14,CNVRTN         VALIDATE & CONVERT TO BINARY\n         C     R3,FFCON        Q. WAS IT VALID\n         BE    ADR27              NO\n         CLC   ADRWK,=C'5999'     Q. UNDER 5999\n         BH    ADR27              NO-INVALID\n         L     R2,BIN2000        * MAKE RELATIVE TO *\n         SR    R3,R2                 * ZERO *\n         B     ADR04              YES-VALID PREPARE TO EXIT\nADR13A   CLI   ADRWK,C'0'      Q. IS IT THE CONS AREA ADR (0000-1999)\n         BL    ADR15                 NO-CK RECORD AREA\n         LH    R4,ADRCON             YES- LOAD ADR OF CONS\n         MVC   SIZEWK,ADRWK          MOVE RELATIVE ADR TO SIZE WORK\n         BAL   R14,CNVRTN             VALIDATE AND CONVERT TO BINARY\n         C     R3,FFCON     Q. WAS ADR VALID\n         BE    ADR27             NO\n         CLC   ADRWK,=C'1999'     Q. ADR UNDER 2000\n         BH    ADR27                 NO-INVALID\n         B     ADR04                 YES-VALID-PREPARE TO EXIT\nADR15    CLI   ADRWK,C'A'            Q. INP1 REC AREA (A)\n         BL    ADR27                    NO < A = INVALID\n         BE    ADR17                    YES-PUT IN ADDR OF A\nADR15A   CLI   ADRWK,C'E'            Q. DSK2 REC AREA (E)\n         BH    ADR21                    NO-GO CK FOR J,K + L\n         BE    ADR18                    YES-PUT IN ADR OF E\n         CLI   ADRWK,C'C'            Q. INP3 REC AREA (C)\n         BH    ADR19                    > MEANS IT MUST BE (E)\n         BL    ADR20                    < MEANS IT MUST BE (B)\n         LH    R4,ADRC                  LOAD REG 4 WITH C ADR\n         B     ADR24                    GO VALIDATE LENGTH\nADR17    LH    R4,ADRA                  LOAD REG 4 WITH A ADR\n         B     ADR24                    GO VALIDATE LENGTH\nADR18    LH    R4,ADRD                                  D\n         B     ADR24                    GO VALIDATE LENGTH\nADR19    LH    R4,ADRE                                  E\n         B     ADR24                    GO VALIDATE LENGTH\nADR20    LH    R4,ADRB                                  B\n         B     ADR24                    GO VALIDATE LENGTH\nADR21    CLI   ADRWK,C'J'            Q. OUT1 REC AREA (J)\n         BL    ADR28                                                 **\n         BE    ADR23                    YES-PUT IN ADR OF (J)\n         CLI   ADRWK,C'L'            Q. OUT3 REC AREA (L)\n         BH    ADR31         > CK TO SEE IF RTCD OR RSXX(RESULTOF X//)\n         BE    ADR23A                   YES-PUT IN ADR OF (L)\n         LH    R4,ADRK                  LOAD REG 4 WITH K ADR\n         B     ADR24                    GO VALIDATE LENGTH\nADR23    LH    R4,ADRJ                  LOAD REG 4 WITH J ADR\n         B     ADR24                    GO VALIDATE LENGTH\nADR23A   LH    R4,ADRL                  LOA REG  4 WITH L ADR\nADR24    CLC   ADRWK+1(3),=C'899'    Q. IS LENGTH VALID (MAX REC 900)\n         BH    ADR27                    NO-INVALID\n         MVC   SIZEWK+1(3),ADRWK+1      MOVE RELATIVE ADR TO WORK\n         BAL   R14,CNVRTN               VALIDATE AND CONVERT TO BINARY\n         C     R3,FFCON              Q. WAS ADR VALID\n         BE    ADR27                    NO\n         B     ADR04                    YES-GO ADD REL ADR TO LHE ADR\nADR27    MVI   ADRERR,C'E'              FLAG ADR ERROR\n         MVI   NOGOSW,C'1'              FLAG NO GO SWITCH (ABORT EXEC)\nADR0X    L     R14,ADRSV                LOAD RETURN ADR\n         BR    R14                      BRANCH BACK\nADR28    CLC   ADRWK(3),=CL3'INX'       ADDR = INDEX                 **\n         BNE   ADR27                     ERROR                       **\n         CLC   CARD+12(2),=C'4 '     Q. SIZE = 4                    ***\n         BNE   SZERR                     ERROR                       **\n         CLI   ADRWK+3,C'1'             INDEX = 1                    **\n         BNE   ADR30                     NO                          **\n         LH    R4,INDEX1                GET ADDR OF INDEX1           **\nADR29    N     R4,=X'0000FFFF'          CLEAR HIGH HALFWORD IN R4.   **\n         B     ADR0X                                                 **\nADR30    CLI   ADRWK+3,C'2'             INDEX = 2                    **\n         BNE   ADR27                     NO,ERROR                    **\n         LH    R4,INDEX2                GET ADR OF INDEX2.           **\n         B     ADR29                                                 **\nADR31    CLC   ADRWK,CRTCD    Q.  RETURN CODE\n         BNE   ADR32               NO-SEE IF RSXX(RESULT OF X OR /)\n         CLC   CARD+12(2),SP4  Q.  SIZE = 4\n         BNE   SZERR             NO\n         LH    R4,ACRTCD       LOAD R4 WITH B/D ADR OF RETURN CODE\n         B     ADR29\nADR32    CLC   ADRWK(2),CRS        Q-RSXX(RESULT OF MULTIPLY/DISVDE)\n         BNE   ADR27               A-NO\n         LH    R4,ARESULT          A-YES/LOAD R4 W/ LHE ADDRESS OF RS\n         MVC   SIZEWK+2(2),ADRWK+2      MOVE RELATIVE ADDR OF SIZE WK\n         BAL   R14,CNVRTN               GO CONVERT TO BINARY NR\n         C     R3,FFCON            Q-WAS ADDR VALID\n         BE    ADR27               A-NO\n         CLC   ADRWK+2(2),=C'29'   A-YES/BUT IS IT > 29\n         BH    ADR27               A/YES/INVALID ADDR\n         B     ADR04               A-NO/VALID ADDR (RS00-RS29)\nINDEX1   DC    S(INX1)                                               **\nINDEX2   DC    S(INX2)                                               **\nADRCD    DC    S(CARD)\nADRPC    DC    S(PCHREC)\nADRPT    DC    S(PRTAREA+1)\nADRDT    DC    S(DATE)\nADRCON   DC    S(CONS)\nADRWORK  DC    XL2'A000'\nADRWK    DS    CL4\nADRSV    DS    F\nBIN2000  DC    XL4'000007D0'\nDATENU6  DC    S(DATE6)\nDATEAL9  DC    S(DATE9)\nDATEJU5  DC    S(DATE5)\nCRTCD    DC    CL4'RTCD'\nSP4      DC    CL2'4 '\nACRTCD   DC    S(RTCD)\nCRS      DC    C'RS'\nARESULT  DC    S(RESULT)\nSORTTAGS DC    CL9'0'\n         DS    0F\n         EJECT\nADDRTN   MVC   ADDGEN+18(1),OP\nSUBRTN   EQU   ADDRTN\n         MVI   ADDGEN+3,X'80'    * INIT\n         MVI   ADDGEN+11,X'80'   *   LENGTH\n         MVI   ADDGEN+39,X'08'    *       FIELDS\n         MVC   ADDGEN+6(2),B1D1\n         MVC   ADDGEN+14(2),B2D2\n         MVC   ADDGEN+40(2),B1D1\n         OC    ADDGEN+3(1),SIZEHLD+3\n         OC    ADDGEN+11(1),SIZEHLD+3\n         MVO   SIZEHLD+1(1),SIZEHLD+3(1)\n         OC    ADDGEN+39(1),SIZEHLD+1\n         LR    R4,R10\n         AH    R4,=H'26'\n         STH   R4,ADDGEN+28\n         MVC   INSHOLD(8),INSTA1\n         MVC   INSHOLD+8(8),INSTA2\n         MVC   INSHOLD+16(8),INSTA3\n         MVC   INSHOLD+24(6),INSTA4\n         MVC   INSHOLD+32(6),INSTA5\n         MVC   INSHOLD+40(8),INSTA6\n         B     PARPRT\nADDGEN   DS    0CL44\nINSTA1   DC    XL2'05'\n         PACK  AUGSUM,B2D2(1)           B-ADR = B-ADR OF ADD OR SUB\nINSTA2   DC    XL2'05'\n         PACK  ADDEND,B1D1(1)           B-ADR = A-ADR OF ADD OR SUB\nINSTA3   DC    XL2'05'\n         AP    AUGSUM,ADDEND            AP OR SP\nINSTA4   DC    XL2'03'\n         BM    *+8                      BRANCH ADR MUST BE FILLED IN\nINSTA5   DC    XL2'03'\n         OI    AUGSUM+8,X'0F'           THIS CHGS C TO F ON POSITIVE\nINSTA6   DC    XL2'05'\n         UNPK  B2D2(1),AUGSUM\n         EJECT\nAPRTN    EQU   *\nCPRTN    EQU   *\nMVORTN   EQU   *\nSPRTN    EQU   *\n*  THIS WILL MAKE SIZES COMPAT WITH ADDRESS  EG. 'B-ADR TO A-ADR\n         L     R3,SIZEHLD        LOAD SIZE INTO R3\n         NI    SIZEHLD+3,X'0F'  REMOVE HIGH ORDER SIZE IN SHIEHLD\n         SRA   R3,4(0)           SHIFT TO REMOVE LOW ORDER SIZE IN R3\n         L     R4,SIZEHLD         LOAD SIZE INTO R4\n         SLA   R4,4(0)             MOVE SIZE TO HIGH ORDER BITS-\n         OR    R3,R4            PUT SIZES TOGETHER\n         ST    R3,SIZEHLD        STORE REVERSED SIZE\nMVNRTN   EQU   *\nMVZRTN   EQU   *\nNCRTN    EQU   *\nXCRTN    EQU   *\nOCRTN    EQU   *\nTRRTN    EQU   *\nCOMRTN   EQU   *\n**** THIS ROUTINE PUTS LENGTH INTO COMPARE INSTRUCTION.          ******\n         MVC   LEN(1),SIZEHLD+3\n         LH    R2,B1D1           *REVERSE\n         MVC   B1D1,B2D2         * ADDRESS ON COM INST\n         STH   R2,B2D2           * (ADR-RTN PUTS A IN B2D2 & B IN B1D1\n         MVC   INSHOLD+2(6),SSINST\n         MVI   INSHOLD+1,X'05'\n         B     PARPRT\n         EJECT\nCONSRTN  EQU   *\n**** THIS RTN PLACE CONSTANT FROM CONS PARAMETER INTO PROGRAM    ******\n*****  CONSTANT AREA.                                            ******\n         CLI   CARD+19,X'F0'        Q ADR IN CON AREA\n         BL    MVERR                     NO-BELOW-INVALID\n         CLI   CARD+19,X'F2'   Q. ADR OUTSIDE CON AREA (1999)\n         BNL   MVERR              YES-INVALID\n         MVC   CONS01+1(1),SIZEHLD+3    MOVE SIZE TO MOVE INS.\n         MVC   CONS01+2(2),B2D2\nCONS01   MVC   CONS01,CARD+33           MOVE CONSTANT TO MEMORY.\n         MVC   CONS02+2(2),B2D2  PUT BASE DISP ADR IN LOAD ADR INST\nCONS02   LA    R5,CONS02         LOAD R5 WITH ACTUAL ADR OF CON ADR\n         ST    R5,HEXHLD         STOR CON ADR\n         BAL   R14,HEXRTN        GO HAVE HEX RTN CONVERT IT TO ZONE\n         MVC   PRTAREA+111(6),CONVHEX+2   PUT ACTUAL CON ADR IN PRTAREA\n         B     PARPRT\nB1D1LHE  DC    XL2'682F'      LHE CONS AREA / BASE DISPLACEMENT FORMAT\n         EJECT\nENTRTN   EQU   *\n****  THIS RTN GENERATES ENTER CODING. (I HOPE)                  ******\n         XR    R4,R4\n         IC    R4,=X'16'\n         BAL   R14,TGRTN                PERFORM TAG ROUTINE\n         MVC   INSTE5+4(2),B1D1\n         XR    R4,R4                                 ,\n         IC    R4,=X'18'\n         AR    R4,R10                   R4 POINTS TO NEXT.\n         STH   R4,INSTE4+6\n         XR    R5,R5                                 ,\n         IC    R5,=X'02'                             ,\n         AR    R4,R5                    R4 POINTS TO NEXT USER INSR.\n         STH   R4,NEXT+2                STORE USER RETURN ADDR IN LINE\n         MVC   INSHOLD(6),INSTE1        *\n         MVC   INSHOLD+8(8),INSTE2      * MOVE GENERATE INST. TO HOLD .\n         MVC   INSHOLD+16(6),INSTE3     *\n         MVC   INSHOLD+24(8),INSTE4\n         MVC   INSHOLD+32(6),INSTE5\n         MVC   INSHOLD+40(4),NEXT\n         B     PARPRT\n***** ENTER ROUTINE TO BE TAILORED AND PLACED IN USER CODE.      ******\n         DS    0F\nINSTE1   DC    XL2'03'                  COUNT FIELD.\n         AH    R4,CON2        BUMP REG4 TO NEXT STACK POSITION.\nINSTE2   DC    XL2'05'\n         CLC   0(2,R4),FCON\nINSTE3   DC    XL2'03'\n         BE    USERR\nINSTE4   DC    XL2'05'\n         MVC   0(2,R4),NEXT\nINSTE5   DC    XL2'03'\n         B     ENTRTN\nNEXT     DC    XL4'00010000'            1ST 2 BYTES=COUNT,2ND 2=RETURN\n         EJECT\nEXRTN    EQU   *\n****** THIS RTN GENERATES EXIT CODING. (I HOPE)                  ******\n         XR    R4,R4\n         IC    R4,=X'0C'\n         AR    R4,R10                   R4 POINTS TO GEN. BRANCH INST.\n         STH   R4,INSTX1+4              MOVE BRANCH ADDR TO MOVE INST.\n         MVC   INSHOLD(8),INSTX1        *\n         MVC   INSHOLD+8(6),INSTX2      *MOVE GEN INST. TO HOLD AREA.\n         MVC   INSHOLD+16(6),INSTX3     *\n         B     PARPRT\n**** EXIT ROUTINE TO BE TAILORED AND PLACED IN USER CODE.        ******\n         DS    0F\nINSTX1   DC    XL2'05'                  COUNT FIELD\n         MVC   *+12(2),0(R4)  MOVE ADDR FROM RETURN STACK TO BRANCH.\nINSTX2   DC    XL2'03'\n         SH    R4,CON2        ADJ R4 TO NEXT RETURN ADD.\nINSTX3   DC    XL2'03'\n         B     EXRTN                    BRANCH TO STACK ADR .\n         EJECT\nMOVERTN  EQU   *\n**** THIS GENERATES MULTIPLE MOVE INSTRUCTIONS IF THE SIZE OF THE******\n***** IS GREATER THAN 256. IF GENERATED DISPLACEMENT EXCEEDS BASE******\n****** REG LIMITS(4096) AN ADDRESS ERROR OCCURS.                 ******\n         LA    R8,INSHOLD\n         LH    R9,=H'8'\n         L     R3,SIZEHLD\n         LH    R4,=H'256'\n         MVZ   BASE1(1),B1D1\n         MVZ   BASE2(1),B2D2\n         MVC   AHLD+2(2),B1D1\n         MVC   BHLD+2(2),B2D2\nMV01     CR    R3,R4\n         BL    MV02\n         MVI   LEN,X'FF'\n         SR    R3,R4\n         MVC   0(2,R8),=XL2'05'\n         MVC   B1D1(2),AHLD+2\n         MVC   B2D2(2),BHLD+2\n         MVC   2(6,R8),SSINST\n         AR    R8,R9\n         L     R2,AHLD\n         AR    R2,R4\n         ST    R2,AHLD\n         L     R2,BHLD\n         AR    R2,R4\n         ST    R2,BHLD\n         B     MV01\nMV02     STC   R3,LEN\n         MVC   B1D1(2),AHLD+2\n         MVC   B2D2(2),BHLD+2\n         MVC   0(2,R8),=XL2'05'\n         MVC   2(6,R8),SSINST\n         B     PARPRT\nMVERR    MVI   ADRERR,C'E'\n         MVI   NOGOSW,C'1'\n         B     PARPRT\n         DS    0F\nAHLD     DC    F'0'\nBHLD     DC    F'0'\nBASE1    DC    XL1'0F'\nBASE2    DC    XL1'0F'\n         EJECT\nTAGRTN   EQU   *\n**** THIS RTN DEFINES TAG ADDRESSES. IF TAG HAS BEEN REFENCED    ******\n***** BEFORE IT HAS BEEN DEFINED THE RTN INSERTS THE TAG ADDRESS ******\n***** WHERE IT IS NEEDED USING THE CHAIN SET IN TGRTN.           ******\n         ST    R14,TAGSAVE              SAVE RETURN\n         L     R5,ADRUBASE\n         LA    R9,TAGTAB\n         CLC   CARD(2),=C'TG'          Q.VALID LOC ENTRY.\n         BNE   TAGERR                   A.NO\n         MVC   SIZEWK+2(2),CARD+2\n         BAL   R14,CNVRTN               PERFORM BINARY CONVERSION .\n         C     R3,FFCON                Q. CONVERSION GOOD.\n         BE    TAGERR\n         C     R3,ZERO                 Q. TAG # VALID.\n         BE    TAGERR\n         SLA   R3,2(0)                  MULTIPLY TAG# BY 4.\n         AR    R3,R9                    R9 HAS LHE TAG TABLE.\n         CLC   0(2,R3),=C'00'\n         BNE   TAGERR                   A.YES,DUPLICATE TAG.\n         CLI   NOGOSW,C'0'      Q. NO GO SWITCH OFF\n         BNE   TAGEXIT            NO'IT'S ON' -BYPASS RESOLVING TG ADRS\n         MVC   0(2,R3),CARD+2           MOVE TAG # TO TAG TABLE.\n         CLC   2(2,R3),=C'00'\n         BNE   TAG01                    A. YES\n         STH   R10,2(R3)                PUT TAG ADR IN TABLE.\n         B     TAGEXIT\nTAG01    MVC   TAG02+2(2),2(R3)         MOVE CHAIN ADR TO COMPARE INS.\n         LA    R6,USERBASE+4095\n         LA    R6,1(0,6)\n         STH   R10,2(R3)                PUT TAG ADR IN TABLE.\nTAG02    CLC   2(2,R3),=C'00'\n         BE    TAG05                    A.YES\n         MVC   TAG03+2(2),TAG02+2       SET TAG03 TO CHAIN ENTRY\n         MVC   TAG04+4(2),TAG02+2       SET TAG04 TO CHAIN ENTRY\nTAG04    MVC   TAG02+2(2),TAG04         SET TAG02 TO NEXT CHAIN ENTRY.\nTAG03    STH   R10,TAG03                INSERT TAG ADR IN GENERATED INS\n         B     TAG02\nTAG05    MVC   TAG06+2(2),TAG02+2       SET TAG06 TO CHAIN ENTRY.\nTAG06    STH   R10,TAG06                INSERT TAG ADR IN LAST ENTRY\nTAGEXIT  L     R14,TAGSAVE              RETURN\n         L     R6,AOURCODE\n         BR    R14\nTGERR    EQU   *\nTAGERR   L     R6,AOURCODE\n         MVI   LOCERR,C'E'\n         MVI   NOGOSW,C'1'\n         B     PARPRT\n         DS    0F\nTAGSAVE  DC    CL4' '\nTAGTAB   DC   80C'00000'\n         EJECT\nTGRTN    EQU   *\n*** THIS ROUTINE MUST BE PERFORMED (BAL). THIS ROUTINE RESOLVES ******\n*** TAG ADDRESSES. IF TAG IS UNDEFINED,REFERENCES ARE CHAINED FOR ****\n*** RESOLUTION AT TIME TAG IS DEFINED.  REG 4 CONTAIN REL ADR OF BRANCH\n*   ADDRESS EG  GO TGXX 4 WOULD = 2 (OP/CODE +  MASK = 2)\n         ST    R14,TGSAVE\n         L     R5,ADRUBASE\n         LA    R9,TAGTAB\n         CLC   CARD+19(2),=C'TG'\n         BNE   TG07\n         MVC   SIZEWK+2(2),CARD+21      MOVE TG# TO SIZE WORK FOR CONV.\n         BAL   R14,CNVRTN               PERFORM BINARY CONVERSION.\n         C     R3,FFCON                Q. CONVERSION GOOD.\n         BE    TGERR                    A. NO.\n         C     R3,ZERO                 Q. TAG # = ZERO\n         BE    TGERR                    A. YES\n         SLA   R3,2(0)                  MULTIPLY R3 BY 4.\n         AR    R3,R9                    R4 NOW HAS TAG TABLE ENTRY ADR.\n         CLC   0(2,R3),=C'00'          Q. HAS TAG BEEN DEFINED.\n         BE    TG01                     A. NO.\n         MVC   B1D1(2),2(R3)              YES,MOVE TAG ADR TO INS.\nTGEXIT   L     R14,TGSAVE                EXIT\n         L     R6,AOURCODE\n         BR    R14\nTG01     AR    R4,R10\n         L     R5,ADRUBASE\n         LA    R6,USERBASE+4095    *POINT REG 6\n         LA    R6,1(0,6)           * TO USER CODE + 4096\n         CLC   2(2,R3),=C'00'          Q. ANY REFERENCE TO TAG.\n         BNE   TG02                     A. YES\n         STH   R4,2(0,R3)\nTG08     L     R6,AOURCODE\n         MVC   B1D1(2),=C'00'           SET END OF CHAIN\n         B     TGEXIT\nTG02     MVC   TG03+4(2),2(R3)          POINT COMPARE TO NEXT CHAIN ENT\nTG03     CLC   =CL2'00',TG03           Q.END OF CHAIN.\n         BNE   TG05                     A. NO\n         MVC   TG04+2(2),TG03+4          ADJUST STORE HALFWORD ADR.\nTG04     STH   R4,TG04\n         B     TG08\nTG05     MVC   TG06+4(2),TG03+4         SET UP TO CHECK NEXT ENTRY\nTG06     MVC   TG03+4(2),TG06               FOR END OF CHAIN.\n         B     TG03\nTG07     CLC   CARD+19(3),=C'EOJ'\n         BE    TG09\n         CLC   CARD+19(4),CSORT  Q.  IS IT SORT\n         BNE   TGERR                    NO - ERROR\n         L     R6,AOURCODE        GET 6 POINT CORRECTLY B1D1 USES R6\n         MVC   B1D1(2),SORTBD   YES - MOVE IN BASE DISP OF SORT\n         B     TGEXIT                   GO EXIT RTN\nTG09     L     R6,AOURCODE\n         MVC   B1D1(2),EOJADR\n         B     TGEXIT\n         DS    0F\nADRUBASE DC    A(USERBASE)\nTGSAVE   DS    CL4\nZERO     DC    XL4'00'\nCSORT    DC    CL4'SORT'\nSORTBD   DC    S(SORTBR)\n         EJECT\nSELF01   ST    R14,SLFSV                SAVE RETURN ADDRESS\nSLFSW    BC    0,SELF05\n         CLC   SIZEHLD,=X'00000028'  Q. IS SIZE > 40 DEC\n         BH    SELF04A               YES-MAYBE INVALID\n         L     R8,SIZEHLD            PUT BINARY SIZE IN R8\nSELF01A  LH    R4,SLFBD              LOAD BASE DISP ADR OF SELF\n         SR    R4,R8\n         S     R4,=F'1'\n         L     R5,SLFACT             LOAD ACTUAL ADR OF SELF\n         STH   R4,SLFBD\n         A     R4,=F'1'\n         CLC   SLFBD,SLFBEG\n         BH    SELF02\n         BE    SELF02\n         MVI   SLFSW+1,X'F0'\n         B     SELF05\nSELF02   SR    R5,R8\n         STC   R8,SELF03+1\nSELF03   MVC   0(1,R5),CARD+33\n         S     R5,=F'1'                 POINT TO NEXT AVAIL POS OF SELF\n         ST    R5,SLFACT                SAVE ACT ADR OF SELF\nSELF04   L     R14,SLFSV                LOAD RETURN ADR\n         BR    R14                      GO BACK\nSELF04A  CLI   PRTAREA+31,C','   Q.  IS THERE 2 SIZES\n         BE    SELF04B               YES\n         CLI   PRTAREA+32,C','       CHECK NEXT POS EG X,X OR XX,X\n         BNE   SELF05                NO-FLAG AS ERROR\nSELF04B  LA    R8,15(0)              YES-FORCE SIZE TO 16 (F) LENGTH\n         B     SELF01A               GO FINISH UP SELF GENERATION\nSELF05   MVI   ADRERR,C'E'              FLAG AS ADR ERROR\n         MVI   NOGOSW,C'1'              FLAG NO GO SWITCH\n         B     SELF04                   GO EXIT RTN\nSLFBEG   DC    S(SELF)\nSLFBD    DC    S(SELF+1771)\nEOJADR   DC    S(EOJRTN)\nSLFACT   DC    A(SELF+1771)\nAOURCODE DC    A(OURCODE)\nSLFSV    DS    F\n         EJECT\nCNVRTN   EQU   *\n**** THIS ROUTINE PACKS AND CONVERTS TO BINARY THE FULLWORD AT   ******\n***** SIZEWK. THE RESULT IS PLACED IN R3.                        ******\n         ST    R2,CVREG2     STORE REG 2 (REG2 IS USED AS BASE\n*                            FOR I/O RTNS AND THE TRT USES REG 2)\n         TRT   SIZWK(8),DECTAB         Q. ALL NUMERIC.\n         BC    6,CV02                   A. NO BRANCH.\n         PACK  SIZWK(8),SIZWK(8)\n         CVB   R3,SIZWK                 CONVERT TO BINARY IN REG 3.\nCV01     MVC   SIZWK(8),CONF0\n         L     R2,CVREG2     RELOAD REG 2 / IN CASE WE CAME FROM I/O\n         BR    R14\nCV02     L     R3,FFCON\n         B     CV01\n         DS    0F\nCVREG2   DS    1F             HOLD AREA FOR REG 2\nCONF0    DC    CL8'00000000'\nDECTAB   DC    CL16' '\nHEXTAB   DC    CL224' '\n         DC    XL10'00'\n         DC    CL6' '\n         DC    CL16'0123456789ABCDEF'\n         EJECT\nCVBINRTN EQU   *\n*  THIS RTN GENERATES THE CODE TO CONVERT ZONED TO BINARY\n         L     R3,SIZEHLD        LOAD SIZE INTO R3\n         NI    SIZEHLD+3,X'0F'  REMOVE HIGH ORDER SIZE IN SIZEHOLD\n         CLI   SIZEHLD+3,X'0A' Q.  SIZE FOR A-ADR 10 OR LESS\n         BH    SZERR              NO - SIZE ERROR\n         SRA   R3,4(0)           SHIFT TO REMOVE LOW ORDER SIZE IN R3\n         C     R3,CVB4         Q. SIZE FOR B-ADR 4 OR LESS\n         BH    SZERR              NO - SIZE ERROR\n         MVI   CVBIPACK+1,X'70'\n         OC    CVBIPACK+1(1),SIZEHLD+3  PUT SIZE ON PACK INST\n         MVC   CVBIPACK+4(2),B2D2      PUT ADR OF DATA TO BE PACKED\n         MVC   CVBIMVC+2(2),B1D1   PUT ADR TO RECEIVE DATA INLINE\n         STH   R3,SIZEHLD              STORE SIZE OF RECEIVING FIELD\n         MVC   CVBIMVC+1(1),SIZEHLD+1    MOVE SIZE IN-LINE\n         LH    R4,CVDCON         POINT 4 AT BINARY RESULTS\n         LA    R2,3                 LOAD 2 WITH MAX SIZE OF RESULT\n         SR    R2,R3                   SUB SIZE FROM MAX SIZE\n         AR    R4,R2                   ADD RESULTS TO ADJUST ADR\n         STH   R4,CVBIMVC+4            STORE RESULTS IN LINE\n         MVC   INSHOLD(8),CVBIN1       *  MOVE GEN-ED\n         MVC   INSHOLD+8(6),CVBIN2     *  INST\n         MVC   INSHOLD+16(6),CVBIN3    *   INLINE\n         MVC   INSHOLD+24(8),CVBIN4    *\n         B     PARPRT\n         DS    0F\nCVB4     DC    XL4'04'\nCVB10    DC    XL4'0A'\n*  THIS IS THE GENERATED CODE TO CONVERT ZONED TO BINARY (CVBIN)\n*\nCVBIN1   DC    XL2'05'\nCVBIPACK PACK  CVDWORD(8),*+0(1)   PACK ZONED FIELD (A-ADR)\nCVBIN2   DC    XL2'03'\n         CVB   R2,CVDWORD          CONVERT PACK TO BINARY\nCVBIN3   DC    XL2'03'\n         ST    R2,CVDWORD+4        STORE BINARY NUMBER\nCVBIN4   DC    XL2'05'\nCVBIMVC  MVC   *+0(1),CVDWORD+4    MOVE BINARY # TO B-ADR\n         EJECT\nCVBZNRTN EQU   *\n*  THIS RTN GENERATES THE CODE TO CONVERT BINARY TO ZONED\n*\n         L     R3,SIZEHLD      LOAD SIZE INTO R3\n         NI    SIZEHLD+3,X'0F'  REMOVE HIGH ORDER SIZE IN SIZEHLD\n         SRA   R3,4(0)           SHIFT TO REMOVE LOW ORDER SIZE IN R3\n         CLI   SIZEHLD+3,X'04'  Q.  SIZE OF BINARY FIELD= OR < 4\n         BH    SZERR              NO SIZE ERROR\n         MVC   CVBZMVC+1(1),SIZEHLD+3  PUT SIZE INTO MOVE\n         LH    R2,CVDCON         * ADJUST ADR (RECEIVING)\n         LA    R4,3           *  OF MOVE\n         ST    R11,SYSAVE+64  *   INST FIELD\n         L     R11,SIZEHLD    *     TO BE\n         SR    R4,R11         *       CONVERTED\n         L     R11,SYSAVE+64 *\n         AR    R2,R4          *\n         STH   R2,CVBZMVC+2         *\n         MVC   CVBZMVC+4(2),B2D2    PUT ADR TO MOVE FROM INLINE\n         C     R3,CVB10          Q. SIZE OF ZONED FIELD= OR < 10\n         BH    SZERR               NO SIZE ERROR\n         MVC   CVBZUNPK+2(2),B1D1  PUT ADR OF WHERE TO UNPK AT INLINE\n         LA    R2,3       LOAD R2 WITH MAX SIZE-1 FOR RESULTS\n         SLA   R3,4(0)    SHIFT SIZE TO HI ORDER BITS\n         STH   R3,SIZEHLD               * PUT SIZE OF UNPACKED\n         MVI   CVBZUNPK+1,X'07'  PUT SIZE OF CVDWORD INTO UNPK INST\n         OC    CVBZUNPK+1(1),SIZEHLD+1  PUT 2 SIZES TOGETHER\n         SRA   R3,4(0)   SHIFT SIZE BACK TO LOWER BYTE\n         LH    R2,B1D1                   * COMPUTE RHE\n         AR    R2,R3                   *  TO CHG UNPKED DATA (LAST\n         STH   R2,CVBZOI+2           * POS) TO DISPLAY\n         MVC   INSHOLD(8),CVBZN1   * MOVE GENERATED INST INLINE\n         MVC   INSHOLD+8(8),CVBZN2  *\n         MVC   INSHOLD+16(6),CVBZN3  *\n         MVC   INSHOLD+24(6),CVBZN4  *\n         MVC   INSHOLD+32(8),CVBZN5   *\n         MVC   INSHOLD+40(6),CVBZN6  *\n         B     PARPRT\n*                THIS IS THE GENERATED CODE    TO CONVERT BINARY\n*                  TO ZONED (CVBZN)\nCVBZN1   DC    XL2'05'\n         MVC   CVDWORD(8),CVDWORD-1  CLEAR WORK AREA\nCVBZN2   DC    XL2'05'\nCVBZMVC  MVC   CVDWORD(1),*+0       *A-ADR MUST BE ADJUSTED BY A-ADR\nCVBZN3   DC    XL2'03'              *SIZE(E.G. SIZE= 2/A-ADR IS +6)\n        L      R2,CVDWORD+4          LOAD BINARY # INTO REG2\nCVBZN4   DC    XL2'03'\n         CVD   R2,CVDWORD        CONVERT BINARY # TO DECIMAL\nCVBZN5   DC    XL2'05'\nCVBZUNPK UNPK  *+0(1),CVDWORD        UNPACK DECIMAL INTO B-ADR\nCVBZN6   DC    XL2'03'\nCVBZOI   OI    *+0,X'F0'             CHG SIGN TO F (RHE B-ADR)\nCVDCON   DC    S(CVDWORD+4)\n         EJECT\nPACKRTN  EQU   *\n         MVC   LEN(1),SIZEHLD+3         MOVE SIZE TO INST\n         MVC   INSHOLD+2(6),SSINST      MOVE INST TO HOLD AREA\n         MVI   INSHOLD+1,X'05'     MOVE SIZE OF INSTRUCTION -1\n         B     PARPRT                   GO PRT & PUT INST INLINE\n         EJECT\nUNPKRTN  EQU   *\n         MVC   LEN(1),SIZEHLD+3         MOVE SIZE TO UNPK INST\n         MVC   INSHOLD+2(6),SSINST      MOVE INST TO HOLD AREA\n         MVI   INSHOLD+1,X'05'          MOVE SIZE OF INST -1\n         L     R3,SIZEHLD               LOAD SIZE\n         SRA   R3,4(0)                  SHIFT TO REMOVE SENDING SIZE\n         MVC    SIZEWK+2(2),B1D1\n         LH    R2,SIZEWK+2\n         AR    R2,R3\n         STH   R2,UNPKOR+2     STORE RHE ADR IN OR INSTRUCTION\n         MVC   INSHOLD+8(6),UNPKCODE    MOVE 'OI' INST TO HOLD\n         MVC   SIZEWK,SZZERO  CLEAR SIZE WORK AREA\n         B     PARPRT                   'THIS ELIM C ON LAST POS\nUNPKCODE DC    XL2'03'\nUNPKOR   OI    *+0,X'F0'\n         EJECT                    CONVERT SYSTEMS DATE TO YYMMDD, ETC\nDATERTN  EQU   *                  CONVERT SYSTEMS DATE TO YYMMDD\n         CNOP  0,4\n         TIME  DEC                GET THE TIME\n         ST    R1,DATESY          SAVE IN FORMAT '00YYJJJF'\n         UNPK  DATEYJ,DATESY+1(3)  GET YYJJJ IN UNPACKED FORMAT\n         UNPK  DATEYMD(3),DATESY+1(2)  GOT YEAR IN 'FYFYXX' FORMAT\n         PACK  DATEWK(2),DATEYMD(2)    PACK YEAR INTO '0YYC' FORMAYY\nDATETG1  SP    DATEWK(2),DATE4         SUBTRACT 4 FROM YEAR TRYING TO\n         BH    DATETG1                 FIGURE OUT IF IT WAS LEAP YEAR\n         BL    DATETG2                 NO -JULIAN DAY TABLE WAS OKAY\n        MVC   DATEJDAY(84),DATEJDAY+84 YES-SUBSTITUTE LEAP YEAR TABLE\nDATETG2  LA    R2,DATEJDAY             POINT R2 TO JULIAN DAY TABLE\nDATETG3  CLC   DATESY+2(2),2(R2)   COMPARE SYSTEMS 'JJJF' TO TABLE\n         BNH   DATETG4  SYSTEMS JJJ = OR < TABLE ENTRY-SEARCH COMPLETE\n         LA    R2,7(R2)            POINT TO NEXT TABLE ENTRY\n         SP    DATETLY,DATE1    Q-HAVE WE SEARCHED ALL ENTRIES\n         BNZ   DATETG3          NO-GO BACK AND COMPARE TO NEXT ENTRY\n         MVC   DATEYMD,DATEUNK YES-SYSTEMS DATE IS BAD\n         B     DATEXIT             GO BACK TO USER\nDATETG4  MVC   DATEYMD+2(2),0(R2)  GET MONTH IN 'MM' FORMAT FROM TABLE\n         S     R2,DATEBUMP         BUMP BACK ONE ENTRY\n         SP    DATESY+2(2),2(2,R2) SUBTRACT LAST JJJ OF LAST MONTH FROM\n         UNPK  DATEYMD+4(2),DATESY+2(2)  SYSTEM JJJ & UNPK IT TO 'FJFJ'\n         MVZ   DATEYMD+5(1),DATEYMD+4\n         MVC   DATEDMY(2),DATEYMD+4  BUILD SYSTEMS DATE IN DD\n         MVC   DATEDMY+3(3),11(R2)                         MMM(ALPHA)\n         MVC   DATEDMY+7(2),DATEYMD                        YY  FORMAT\nDATEXIT  BR    R14                 GO BACK TO USER\n         DC    X'000F000000'\nDATEJDAY DC    X'F0F1031FD1C1D5F0F2059FC6C5C2F0F3090FD4C1D9'\n         DC    X'F0F4120FC1D7D9F0F5151FD4C1E8F0F6181FD1E4D5'\n         DC    X'F0F7212FD1E4D3F0F8243FC1E4C7F0F9273FE2C5D7'\n         DC    X'F1F0304FD6C3E3F1F1334FD5D6E5F1F2365FC4C5C3'\n         DC    X'F0F1031FD1C1D5F0F2060FC6C5C2F0F3091FD4C1D9'\n         DC    X'F0F4121FC1D7D9F0F5152FD4C1E8F0F6182FD1E4D5'\n         DC    X'F0F7213FD1E4D3F0F8244FC1E4C7F0F9274FE2C5D7'\n         DC    X'F1F0305FD6C3E3F1F1335FD5D6E5F1F2366FC4C5C3'\nDATESY   DC    F'0'\nDATEYMD  DC    C'      '\nDATEDMY  DC    C'XX XXX XX'\nDATEYJ   DC    C'XXXXX'\nDATEWK   DC    C'  '\nDATE1    DC    P'1'\nDATE4    DC    P'4'\nDATETLY  DC    PL2'12'\nDATEUNK  DC    C'UNKNOW'\nDATEBUMP DC    F'7'\n         CNOP  0,4\n         EJECT\nMPYRTN   EQU   *    MULTIPLY ROUTINE\n*    MPY  XX,YY  A-ADDRESS BY B-ADDRESS  PRODUCT IN RESULT - 30 BYTES\n         MVN   MPYGEN1+3(1),SIZEHLD+3  -MULTIPLIER SIZE\n         L     R3,SIZEHLD\n         SRA   R3,4(0)\n         ST    R3,SIZEHLD\n         MVN   MPYGEN2+3(1),SIZEHLD+3  -MULTIPLICAND SIZE\n         MVC   MPYGEN1+6(2),B2D2       -MULTIPLIER ADDRESS\n         MVC   MPYGEN2+6(2),B1D1       -MULTIPLICAND ADDRESS\n         LR    R3,R10\n         AH    R3,=H'30'\n         STH   R3,MPYGEN5+4\n         MVC   INSHOLD+00(8),MPYGEN1   *MOVE GENERATED INSTRS INLINE\n         MVC   INSHOLD+08(8),MPYGEN2   *\n         MVC   INSHOLD+16(8),MPYGEN3   *\n         MVC   INSHOLD+24(6),MPYGEN4   *\n         MVC   INSHOLD+32(6),MPYGEN5   *\n         MVC   INSHOLD+40(6),MPYGEN6   *\n         MVC   INSHOLD+48(8),MPYGEN7   *\n         MVC   INSHOLD+56(8),MPYGEN8   *\n         B     PARPRT\n********* THEIR GENERATED CODE\nMPYGEN1  DC    XL2'05'\n         PACK  FIELD8(8),*+0(1)         PACK THEIR MULTIPLIER\nMPYGEN2  DC    XL2'05'\n         PACK  FIELD16,*+0(1)           PACK THEIR MULTIPLICAND\nMPYGEN3  DC    XL2'05'\n         MP    FIELD16,FIELD8           MULTIPLY\nMPYGEN4  DC    XL2'03'\n         TM    FIELD16+15,X'01'         Q-NEGATIVE PRODUCT\nMPYGEN5  DC    XL2'03'\n         BO    *+8                      A-YES/LEAVE NEGATIVE BITS ON\nMPYGEN6  DC    XL2'03'\n         OI    FIELD16+15,X'0F'         A-NO/MAKE PRODUCT DISPLAYABLE\nMPYGEN7  DC    XL2'05'\n         UNPK  RESULT(16),FIELD16(9)    UNPACK\nMPYGEN8  DC    XL2'05'                         PRODUCT INTO\n         UNPK  RESULT+15(15),FIELD16+8(8)           RESULT   - 30 BYTES\n         EJECT\nDVDRTN   EQU   *    DIVIDE ROUTINE\n*   DVD  XX,YY  A-ADDRESS INTO B-ADDRESS   QUOTENT IN RESULT - 15 BYTES\n*                                          REMAINDER IN RESULT+15 - 15B\n         MVN   DVDGEN1+3(1),SIZEHLD+3  -DIVIDEND SIZE\n         L     R3,SIZEHLD\n         SRA   R3,4(0)\n         ST    R3,SIZEHLD\n         MVN   DVDGEN2+3(1),SIZEHLD+3  -DIVISOR SIZE\n         MVC   DVDGEN1+6(2),B2D2       -DIVISOR ADDRESS\n         MVC   DVDGEN2+6(2),B1D1       -DIVIDEND ADDRESS\n         LR    R3,R10\n         AH    R3,=H'34'\n         STH   R3,DVDGEN5+4\n         MVC   INSHOLD+00(8),DVDGEN1   *MOVE GENERATED INST INLINE\n         MVC   INSHOLD+08(8),DVDGEN2   *\n         MVC   INSHOLD+16(8),DVDGEN3   *\n         MVC   INSHOLD+24(6),DVDGEN4   *\n         MVC   INSHOLD+32(6),DVDGEN5   *\n         MVC   INSHOLD+40(6),DVDGEN6   *\n         MVC   INSHOLD+48(6),DVDGEN7   *\n         MVC   INSHOLD+56(8),DVDGEN8   *\n         MVC   INSHOLD+64(8),DVDGEN9   *\n         B     PARPRT\n********* THEIR GENERATED CODE\nDVDGEN1  DC    XL2'05'\n         PACK  FIELD8(8),*+0(1)         PACK  THEIR DIVISOR\nDVDGEN2  DC    XL2'05'\n         PACK  FIELD16,*+0(1)   1)      PACK  THEIR DIVIDEND\nDVDGEN3  DC    XL2'05'\n         DP    FIELD16,FIELD8           DIVIDE\nDVDGEN4  DC    XL2'03'\n         TM    FIELD16+7,X'01'          Q-NEGATIVE QUOTENT\nDVDGEN5  DC    XL2'03'\n         BO    *+12                     A-YES/LEAVE NEGATIVE BITS ON\nDVDGEN6  DC    XL2'03'\n         OI    FIELD16+7,X'0F'          A-NO/MAKE POSITIVE QUOTENT\nDVDGEN7  DC    XL2'03'                       DISPLAYABLE\n         OI    FIELD16+15,X'0F'              MAKE POSITIVE REMAINDER\nDVDGEN8  DC    XL2'05'                       DISPLAYABLE\n         UNPK  RESULT(15),FIELD16(8)    UNPACK QUOTENT INTO RESULT\nDVDGEN9  DC    XL2'05'\n         UNPK  RESULT+15(15),FIELD16+8(8) UNPK REMAINDER INTO RESULT+15\n         EJECT\nPRINTER  DCB   DDNAME=SYSOUT,DSORG=PS,MACRF=PM,RECFM=U,                C\n               LRECL=120,BLKSIZE=120\nINCARD   DCB   DDNAME=SYSIN,DSORG=PS,MACRF=GM,EODAD=PAREND\n         EJECT\n         DS    0D\nDISKWRT  EQU   *\nDISKRD   EQU   *\nPAREND   EQU   *\n         L     R5,ADRUBASE\nSORTSW   B     SORTBP                   / NOP IF SORT WAS CALLED\n         MVC   CARD+19(4),SORTTAGS      /GET ADDR\n         LA    R4,2(0)  ONLY NEED TO MEET TGRTN REQUIREMENTS\n         BAL   R14,TGRTN                / OF  INPUT\n         MVC   INPROC+2(2),RXINST+2     / AND OUT PUT\n         MVC   CARD+19(4),SORTTAGS+5    / PROCEDURE TAGS\n         LA    R4,2(0)  ONLY NEED TO MEET TGRTN REQUIREMENTS\n         BAL   R14,TGRTN                / AND PUT IN\n         MVC   OUTPROC+2(2),RXINST+2    / COMM AREA FOR SORT\nSORTBP   LA    R9,TAGTAB          * R9=LHE TAG TABLE\nPAR01    MVC   PRTAREA(133),PRTAREA-1   CLEAR PRT AREA\nPAR02    LA    R9,4(R9)\n         CP    TGCNT(2),=PL2'100' *ANY MORE TAGS ?\n         BE    PAR10          00' *NO\n         MVC   PRTAREA+1(4),TGO1  *MOVE TAG ID TO PRT LINE.\n         AP    TGCNT(2),ONE(1) 1' *BUMP TAG COUNT BY 1.\n         UNPK  TGO1+2(2),TGCNT(2) *UPDATE TAG ID\n         OI    TGO1+3,X'F0'   (2) *FIX ZONE\n         CLC   0(2,R9),=C'00'     *TAG DEFINED ?\n         BNE   PAR04              *YES\n         CLC   2(2,R9),=C'00'     *TAG REFERENED?\n         BE    PAR02          (2) *NO\n         CLI   NOGOSW,C'1'     Q. NO GO SWITCH SET\n         BE    PAR03             YES-BYPASS PRINTING UNDEFINED\n         MVI   NOGOSW,C'1'    (2) *YES, ERROR.\n         MVC   PRTAREA+6(9),=C'UNDEFINED'\nPAR03    MVI   PRTAREA,X'09'      *SKIP1 TO PRT CNTL.\n         PUT   PRINTER,PRTAREA+1\n         B     PAR01\nPAR04    MVC   HEXHLD(2),2(R9)    *MOVE TAG ADDR TO CONV WORKAREA.\n         BAL   R14,HEXRTN         *CONVERT TO EBCDIC.\n         MVC   PRTAREA+6(4),CONVHEX    *EDCDIC TO PRT LINE\n         B     PAR03\nTGCNT    DC    PL2'1'\nTGO1     DC    CL4'TG01'\nPAR10    MVC   PRTAREA(133),PRTAREA-1\n         MVI   PRTAREA,X'89'\n         PUT   PRINTER,PRTAREA+1\n         MVC   PRTAREA(133),PRTAREA-1\n         LA    R4,EXITSK\n         CLI   NOGOSW,C'0'      Q. ANY PARAMETERS FLAGGED\n         BE    PAR20             NO-CONTINUE PROCESSING\nTAPECLSW B     BADPARMS   THIS NOP IF TAPE CLASS HAS BEEN CALLED\n         ABEND 8           TO FORCE ABNORNAL TERMINATION ON BAD PARMS\n         CNOP 2,4  FORCE ALIGNMENT SO FOLLOWING ACON IS FULL WORD ORIEN\nPAR20    MVC   DATE6(20),DATEYMD  PUT SYSTEM DATE IN USER AREA\nPAREND1  CLC   IN1MOD,ZEROS      Q. IN 1 MODULE LOADED\n         BE    PAREND2\n         L     15,IN1MOD             YES-LOAD 15 WITH ADR OF MODULE\n         BALR  14,15                BRANCH TO MODULE TO EXEC OPEN\n         DC    A(OURCODE)    USED BY READ DIRECT (AREA ADDRESS)       *\n         DC    XL2'7000'                                              *\n         DS    CL6\nPAREND2  CLC   IN2MOD,ZEROS\n         BE    PAREND3\n         L     15,IN2MOD\n         BALR  14,15\n         DC    A(OURCODE)                                             *\n         DC    XL2'8000'                                              *\n         DS    CL6\nPAREND3  CLC   IN3MOD,ZEROS\n         BE    PAREND4\n         L     15,IN3MOD\n         BALR  14,15\n         DC    A(OURCODE)                                             *\n         DC    XL2'9000'                                              *\n         DS    CL6\nPAREND4  CLC   OT1MOD,ZEROS\n         BE    PAREND5\n         L     15,OT1MOD\n         BALR  14,15\n         DC    A(OURCODE)     USED BY READ DIRECT MOD FOR AREA ADR\n         DC    XL2'B000'     *GIVE OUT MODULE ADR OF REC AREA\n         DS    CL6           *\nPAREND5  CLC   OT2MOD,ZEROS\n         BE    PAREND6\n         L     15,OT2MOD\n         BALR  14,15\n         DC    A(OURCODE)     USED BY READ DIRECT MOD FOR AREA ADR\n         DC    XL2'B384'     *GIVE OUT MODULE ADR OF REC AREA\n         DS    CL6           *\nPAREND6  CLC   OT3MOD,ZEROS\n         BE    PAREND7\n         L     15,OT3MOD\n         BALR  14,15\n         DC    A(OURCODE)     USED BY READ DIRECT MOD FOR AREA ADR\n         DC    XL2'B708'     *GIVE OUT MODULE ADR OF REC AREA\n         DS    CL6           *\nPAREND7  CLC   PRTMOD,ZEROS\n         BE    PAREND8\n         L     15,PRTMOD\n         BALR  14,15\n         DC    S(PRTAREA)\nPAREND8  CLC   RDCDMOD,ZEROS\n         BE    PAREND9\n         L     15,RDCDMOD\n         BALR  14,15\n         DS    CL4             * DUMMY CODE NEEDED FOR RD MODULE\n         DC    S(CARD)      REC AREA ADR NEEDED BY RD MODULE\n         DS    CL6             NEEDED BY RD CD MODULE\nPAREND9  B     DEBUGAID\nZEROS    DC    1F'0'\n         EJECT\n         ORG   OURCODE+7700            *\nCLEAR01  MVI   OURCODE,X'40'           * CLEAR\n         CLOSE (INCARD,,PRINTER)\n         LA    R2,28(0,0)              *   7680\n         LA    R1,OURCODE+256          *     POS OF OUR CODE\n         MVI   OURCODE,X'40'           * TO BE USED BY USER\n         MVC   OURCODE+1(256),OURCODE  *  FOR WORK AREA (2000/5999)\nCLEAR02  MVC   0(256,1),OURCODE        *   AND FOR OUTPUT REC AREAS\n         LA    R1,256(0,1)             *\n         BCT   R2,CLEAR02              *\n         MVI   0(R11),X'00'      PUT ZEROS AFTER LAST USER INSTRUCT\n         LA    R10,OURCODE         SET 10 TO WORK AREA\n         LA    R11,OURCODE+4096    SET 11 TO LHE OF OUT1 REC AREA\n         LA    R9,PUNCHID+60    * THIS IS DONE IN CASE ONE OF THE\n         LA    R8,PUNCHID+30    * INPUT FILE ARE DA / OTHERWISE\n         LA    R7,PUNCHID       * REGS WILL BO RELOADED BY THE I/O MOD\n         LA    R6,USERBASE+4095\n         LA    R6,1(0,6)\n         B     USERCODE                 GO EXEC USER CODE\nSYSAVE   DS    18F\n         EJECT\nRDRTN    L     R2,OUR8192     LOAD BASE REG FOR RTN\n         B     RDRTN1\nWRTRTN   L     R2,OUR8192     LOAD BASE REG FOR RTN\n         B     WRTRTN1\nPRTRTN   L     R2,OUR8192     LOAD BASE REG FOR RTN\n         B     PRTRTN1\nCALLRTN  L     R2,OUR8192    LOAD BASE REG FOR RTN\n         B     CALL1\nXCONSRTN L     R2,OUR8192      LOAD BASE REG FOR RTN\n         B     XCONS1\nDEBUGAID L     R2,OUR8192\n         B     DEBUGRTN    GO PRINT DEBUGGING AIDS\nOUR8192  DC    A(OURCODE+8192)\n         EJECT\n         LTORG\n         EJECT\n         ORG   OURCODE+8192    PLACE AFTER LTORG\n*  R2 IS LOADED BEFORE BRANCHING TO THESE RTNS\nREADCARD DC    CL8'RRDCART '\nREADINP1 DC    CL8'RRDINP1 '\nREADINP2 DC    CL8'RRDINP2 '\nREADINP3 DC    CL8'RRDINP3 '\nOUT1MOD  DC    CL8'RROUT1MD'\nOUT2MOD  DC    CL8'RROUT2MD'\nOUT3MOD  DC    CL8'RROUT3MD'\nPTMOD    DC    CL8'RRPRTMOT'       USED TO LOAD MOD (MOD NAME)\nOUT1IS   DC    CL8'RROT1ISM'\nOUT2IS   DC    CL8'RROT2ISM'\nOUT3IS   DC    CL8'RROT3ISM'\nINP1IS   DC    CL8'RRINP1IS'\nINP2IS   DC    CL8'RRINP2IS'\nINP3IS   DC    CL8'RRINP3IS'\nINP1ISR  DC    CL8'RRIN1ISR'\nINP2ISR  DC    CL8'RRIN2ISR'\nINP3ISR  DC    CL8'RRIN3ISR'\nINP1DI   DC    CL8'RRINP1DI'                                          *\nINP2DI   DC    CL8'RRINP2DI'                                          *\nINP3DI   DC    CL8'RRINP3DI'                                          *\nINP1DK   DC    CL8'RRINP1DK'                                          *\nINP2DK   DC    CL8'RRINP2DK'                                          *\nINP3DK   DC    CL8'RRINP3DK'                                          *\nOUT1DA   DC    CL8'RROUT1DA'                                          *\nOUT2DA   DC    CL8'RROUT2DA'                                          *\nOUT3DA   DC    CL8'RROUT3DA'                                          *\nMODNAME1 DS    CL8\nMODNAME2 DS    CL8\nMODNAME3 DS    CL8\n         EJECT\nPRTRTN1  EQU   *\n**** THIS ROUTINE GENERATE LINKAGE TO PRINTER IOMODULE AND       ******\n***** CARRIAGE CONTROL INFO.                                     ******\n         L     R5,ADRUBASE NEED TO POINT TO COMM AREA\n         CLC   CARD+19(4),=CL4'SKIP'\n         BE    PRT02\n         CLC   CARD+19(4),=CL4'CHAN'\n         BNE   RDERR\n         CLC   CARD+23(2),=CL2'12'\n         BH    RDERR\n         MVC   SIZEWK+2(2),CARD+23\n         LA    R8,CHTAB\nPRT01    BAL   R14,CNVRTN\n         C     R3,FFCON\n         BE    RDERR\n         AR    R8,R3\n         MVC   PRTCTL+1(1),0(R8)   MOVE CONTROL CHAR TO IN-LINE CODE\n         MVC   INSHOLD(6),PRTCODE1     * MOVE\n         MVC   INSHOLD+8(6),PRTCODE2   *    IN-LINE\n         MVC   INSHOLD+16(4),PRTCODE3  *      CODE\n         MVC   INSHOLD+24(4),PRTCODE4  *        TO\n         MVC   INSHOLD+32(8),PRTCODE5  *          INST HOLD AREA\n         MVC   INSHOLD+40(8),PRTCODE6  *\nPRT01A   NOP   PRT01B    USED TO BYPASS LOAD OF MOD AFTER FIRST TIME\n         LOAD  EPLOC=PTMOD     LOAD PRT MODULE AND STORE\n         ST    R0,PRTMOD              ADR OF MOD\n         MVI   PRT01A+1,X'F0'     TURN ON SN TO BYPASS RELOADING MOD\nPRT01B   B     PARPRT\nPRT02    CLI   CARD+23,C'3'\n         BH    RDERR\n         LA    R8,SKTAB\n         MVC   SIZEWK+3(1),CARD+23\n         B     PRT01\nSKTAB    DC    XL4'01091119'\nCHTAB    DC    XL13'01899199A1A9B1B9C1C9D1D9E1'\n         DS    0F\n*INLINE CODE FOR  PRINT INST\n*   I/O MOD MUST RETURN CONTROL VIA REG-14 + 2\n*    (SKIP PRT AREA ADR)\nPRTCODE1 DC    XL2'03'\nPRTCTL   MVI   PRTAREA,C'1' * MOVE IN PRT CONTROL CHAR\nPRTCODE2 DC    XL2'03'\n         L     R15,PRTMOD     *  LOAD 15 WITH ADR OF PRTMOD\nPRTCODE3 DC    XL2'01'\n         BALR  R14,R15        *  BR TO PRTMOD\nPRTCODE4 DC    XL2'01'\n         DC    S(PRTAREA)     * ADR OF PRINT ATEA\nPRTCODE5 DC    XL2'05'\n         AP    PRCNT,ONE      *  ADD 1  TO REC COUNT\nPRTCODE6 DC    XL2'05'\n         MVC   PRTAREA(133),PRTAREA-1  * CLEAR PRINT AREA\n         EJECT\nWRTRTN1  EQU   *\n*\n*\n*\n         L     R5,ADRUBASE NEED TO POINT TO COMM AREA\nWRT01    CLC   CARD+19(4),=CL4'OUT1'   Q. OUT1\n         BNE   WRT05                       NO\nWRT02    NOP   WRT03                      YES-1 TIME SWITCH TO BY PASS\n         MVC   WRT02(2),WRT04           CHG NOP TO B INST\n         CLC   CARD+12(2),ISCON   Q. IS THIS AN INDEX SEQ DATA SET\n         BNE   WRT0201A                                               *\n         MVC   OUT1MOD(8),OUT1IS YES-CHG TO LOAD ISAM MODULE\n         B     WRT0201                                                *\nWRT0201A CLC   CARD+12(2),DACON   Q. IS THIS A DIRECT WRT             *\n         BNE   WRT0201                                                *\n         MVC   OUT1MOD(8),OUT1DA                                      *\nWRT0201  LOAD  EPLOC=OUT1MOD   LOAD OF MODULE AND STORING\nWRT02A   ST    R0,OT1MOD    ENTRY POINT ADR OF I/O MODULE\nWRT03    MVC   IOREC,ADRJ     PUT REC AREA ADR IN\n         MVC   IOCODE+4(2),WRT02A+2  PUT ADR OF LOADED MOD INLINE\n         MVC   IOADD+2(2),ADROCT1    PUT ADR OF CT IN GEN CODE\nWRT03A   MVC   INSHOLD(6),IOCODE   * MOVE\n         MVC   INSHOLD+8(4),IOCODE1    *   INLINE INST\n         MVC   INSHOLD+16(6),IOCODE2   *     TO INST HOLD\n         MVC   INSHOLD+24(4),IOCODE3   *       AREA FOR  PRINT\n         MVC   INSHOLD+32(8),IOCODE4   *         AND BEING\n         MVC   INSHOLD+40(8),IOCODE5   *           MOVED INLINE\nWRT04    B     PARPRT\nWRT05    CLC   CARD+19(4),=CL4'OUT2'   Q. OUT2\n         BNE   WRT07                      NO- CK TO SEE IF OUT 3\nWRT06    NOP   WRT06B                     YES - 1 TIME SWITCH\n         MVI   WRT06+1,X'F0'                CHG SW TO BRANCH AROUND\n         CLC   CARD+12(2),ISCON   Q. IS THIS AN INDEX SEQ DATA SET\n         BNE   WRT0601A       NO\n         MVC   OUT2MOD(8),OUT2IS    YES-CHG TO LOAD ISAM\n         B     WRT0601       LOAD MODULE\nWRT0601A CLC   CARD+12(2),DACON   Q. IS THIS DIRECT\n         BNE   WRT0601               NO - LOAD SEQ\n         MVC   OUT2MOD(8),OUT2DA  YES-SET TO LOAD WRT DIRECT MODULE\nWRT0601  LOAD  EPLOC=OUT2MOD       LOAD OUT 2 MODULE\nWRT06A   ST    R0,OT2MOD         SAVE ENTRY POINT ADR OF OUT 2 MODULE\nWRT06B   MVC   IOREC,ADRK\n         MVC   IOCODE+4(2),WRT06A+2  PUT ADR OF LOADED MOD INLINE\n         MVC   IOADD+2(2),ADROCT2    PUT ADR OF COUNT IN CODE\n         B     WRT03A                GO MOVE IT ALL INLINE\nWRT07    CLC   CARD+19(4),=CL4'OUT3'   Q. OUT 3\n         BNE   RDERR                       NO- FLAG AS ADR ERROR\nWRT08    NOP   WRT08B                     YES\n         MVI   WRT08+1,X'F0'               CHG SW TO BRANCH AROUND LOAD\n         CLC   CARD+12(2),ISCON   Q. IS THIS AN INDEX SEQ DATA SET\n         BNE   WRT0801A       NO\n         MVC   OUT3MOD(8),OUT3IS     YES-CHG TO LOAD ISAM\n         B     WRT0801\nWRT0801A CLC   CARD+12(2),DACON   Q. IS THIS DIRECT\n         BNE   WRT0801              NO - LOAD SEQ\n         MVC   OUT3MOD(8),OUT3DA YES-SET TO LOAD WRT DIRECT MODULE\nWRT0801  LOAD  EPLOC=OUT3MOD        LOAD OUT 3 MODULE\nWRT08A   ST    R0,OT3MOD                  SAVE ENTRY POINT OF MODULE\nWRT08B   MVC   IOREC,ADRL\n         MVC   IOCODE+4(2),WRT08A+2       PUT ADR OF LOADED MOD INLINE\n         MVC   IOADD+2(2),ADROCT3         PUT ADR OF COUNT IN CODE\n         B     WRT03A                     GO MOVE IT ALL INLINE\nADROCT1  DC    S(O1CNT)\nADROCT2  DC    S(O2CNT)\nADROCT3  DC    S(O3CNT)\nREG10    DC    XL2'A000'    REG 10 FOR WRITE OUT 1  REC AREA\nREG11    DC    XL2'B000'           REG 11 FOR OUT 2\nREG12    DC    XL2'C000'           REG 12 FOR OUT 3\nDACON    DC    CL2'DA'                                                *\n         EJECT\n** INLINE CODING FOR USER READ AND WRITES OF PS DATA SETS\n*   I/O MOD MUST ADD 12 TO R14 TO BY PASS PARMS\nIOCODE   DC    XL2'03'\n         L     R15,SIZEWK   * LOAD ADR OF I/O MOD  *VTO BE FILLED IN\nIOCODE1  DC    XL2'01'\n         BALR  R14,R15            BRANCH TO I/O MOD\nIOCODE2  DC    XL2'03'\nINPEOF   B     *+0              * BRANCH TO EOF  (FOR READ ONLY)\nIOCODE3  DC    XL2'01'\nIOREC    DC    XL2'0000'        * REC AREA ADDRESS OR REG\nIOCODE4  DC    XL2'05'\n         DC    XL6'FFFFFFFFFFFF'  FIRST 2 POS KEY ADR BISAM/  4  FUTURE\nIOCODE5  DC    XL2'05'\nIOADD    AP    *+0(4),ONE  * ADD 1 TO RECORD COUNT\n         EJECT\nRDRTN1   EQU   *\n*  THIS RTN SETS UP THE CODE\n*   NECESSARY TO READ CARDS\n*\n         L     R5,ADRUBASE NEED TO POINT TO COMM AREA\n         CLC   CARD+19(4),=CL4'CARD'  Q. READ CARD PARM\n         BE    RDCARD                    YES\n         CLC   CARD+19(3),=CL3'INP'    Q.READ INPUT\n         BE    RDINPUT                   YES\n         B     RDERR                     NO- FLAG AS ADR ERR\nRDINPUT  CLC   CARD+12(3),ISCON    Q. SEQ IS READ  (IS)\n         BNE   RDINPUT3\n         MVC   MODNAME1(24),INP1IS    SET MOD NAMES TO IS\n         B     RDINPUT6               GO CONV\nRDINPUT3 CLC   CARD+12(3),ISRCON   Q. INDEX SEQ/RANDOM (ISR)\n         BNE   RDINPUT5\n         MVC   MODNAME1(24),INP1ISR   SET MOD NAMES TO ISR\nRDINPUT4 BAL   R14,RDISR01            CONVERT KEY  ADDRESS\n         B     RDINPUT9\nRDINPUT5 CLC   CARD+12(2),DICON    Q. RD DIRECT USING BLK ADR (DI)\n         BNE   RDINPT5A\n         MVC   MODNAME1(24),INP1DI    SET MOD NAMES TO DI\n         B     RDINPUT6\nRDINPT5A CLC   CARD+12(2),DKCON    Q. RD DIRECT USING KEY  (DK\n         BNE   RDINPT5B\n         MVC   MODNAME1(24),INP1DK    SET MOD NAMES TO DK\n         B     RDINPUT4\nRDINPT5B CLI   CARD+12,X'40'       Q. PS OR PO READ\n         BNE   RDERR                  NO ERROR\n         MVC   MODNAME1(24),READINP1  SET MOD NAMES TO PS/PO\nRDINPUT6 LA    R4,8(0)                *CONV-EOF ADR/ GIVE TAGRTN REL\n         MVC   CARD+60(4),CARD+19     * LOC OF WHERE INST WILL BE AT\n         MVC   CARD+19(4),CARD+24        *  MOVE TAG TO A-ADR-FOR TAGRT\n         BAL   R14,TGRTN              *  PERFORM RTN\n         MVC   INPEOF+2(2),RXINST+2   * MOVE EOF ADR TO GEN CODE\n         MVC   CARD+19(4),CARD+60    * PUT ORIGINAL A-ADR BACK\nRDINPUT9 CLI   CARD+22,C'1'         Q. INP 1\n         BE    RDINP1                     YES\n         CLI   CARD+22,C'2'            Q. INP 2\n         BE    RDINP2                     YES\n         CLI   CARD+22,C'3'            Q. INP 3\n         BE    RDINP3                     YES\n         B     RDERR                      NO-ADR ERR\nRDCARD   NOP   RDCARD01\n         LOAD  EPLOC=READCARD      LOAD CARD READ MODULE\n         ST    R0,RDCDMOD           SAVE ADR OF MOD\n         MVI   RDCARD+1,X'F0'   * SET TO BYPASS LOADING MOD AGAIN\nRDCARD01 MVC   IOREC,ACONCARD     * PUT LHE ADR OF RECORD AREA\n         MVC   IOADD+2(2),CDCNT   * PUT ADR OF COUNT IN CODE\n         MVC   IOCODE+4(2),RDCDADR * PUT ADR OF LOAD MOD ADR IN CODE\n         LA    R4,8(0)                *CONV-EOF ADR/ GIVE TAGRTN REL\n         MVC   CARD+19(4),CARD+24        *  MOVE TAG TO A-ADR-FOR TAGRT\n         BAL   R14,TGRTN              *  PERFORM RTN\n         MVC   INPEOF+2(2),RXINST+2   * MOVE EOF ADR TO GEN CODE\n         B     RDMOVE01            * GO GET EOF ADR & MOVE INST IN\nRDMOVE01 MVC   INSHOLD(6),IOCODE   * MOVE\n         MVC   INSHOLD+8(4),IOCODE1  *  CODE\n         MVC   INSHOLD+16(6),IOCODE2  * TO BE\n         MVC   INSHOLD+24(4),IOCODE3 *     PRINTED\n         MVC   INSHOLD+32(8),IOCODE4 *       AND\n         MVC   INSHOLD+40(8),IOCODE5 *        INSERTED IN LINE\n         B     PARPRT    GO PRINT + INSERT CODE\nRDERR    MVI   ADRERR,C'E'        FLAG AS ADDRESS ERROR\n         MVI   NOGOSW,C'1'       SET NO GO SWITCH\n         B     PARPRT\nACONCARD DC    S(CARD)\nCDCNT    DC    S(CRDCNT)\nRDCDADR  DC    S(RDCDMOD)\nINP1CT   DC    S(IN1CNT)\nINP1ADR  DC    S(IN1MOD)\nINP2CT   DC    S(IN2CNT)\nINP2ADR  DC    S(IN2MOD)\nINP3CT   DC    S(IN3CNT)\nINP3ADR  DC    S(IN3MOD)\nRDINP1   NOP   RDINP101             ONE TIME SWITCH\n         LOAD  EPLOC=MODNAME1\n         ST    R0,IN1MOD            SAVE ADR OF MOD\n         MVI   RDINP1+1,X'F0'       SET TO BYPASS LOADING OF MOD AGAIN\nRDINP101 MVC   IOADD+2(2),INP1CT    PUT ADR OF COUNT IN - INLINE CODE\n         MVC   IOCODE+4(2),INP1ADR  PUT ADR OF LOAD MOD ADR IN  CODE\n         MVC   IOREC,ADRA      PUT REC AREA ADR INLINE\n         B     RDMOVE01          GO GET EOF ADR & MOVE INST INLINE\nRDINP2   NOP   RDINP201            ONE TIME SW\n         LOAD  EPLOC=MODNAME2\n         ST    R0,IN2MOD           SAVE ADR OF MOD\n         MVI   RDINP2+1,X'F0'      SET TO BYPASS LOADING OF MOD AGAIN\nRDINP201 MVC   IOADD+2(2),INP2CT   PUT ADR OF COUNT IN INLINE CODE\n         MVC   IOCODE+4(2),INP2ADR PUT ADR OF LOAD  MOD ADR IN CODE\n         MVC   IOREC,ADRB      PUT ADR OF REC AREA INLINE\n         B     RDMOVE01            GO GET EOF ADR & MOVE INST INLINE\nRDINP3   NOP   RDINP301            ONE TIME SW\n         LOAD  EPLOC=MODNAME3\n         ST    R0,IN3MOD           SAVE ADR OF MOD\n         MVI   RDINP3+1,X'F0'      SET TO BYPASS LOADING OF MOD AGAIN\nRDINP301 MVC   IOADD+2(2),INP3CT   PUT ADR OF COUNT IN INLINE CODE\n         MVC   IOCODE+4(2),INP3ADR PUT ADR OF LOAD MOD ADR IN CODE\n         MVC   IOREC,ADRC      PUT REC AREA ADR INLINE\n         B     RDMOVE01            GO GET EOF ADR & MOVE INST INLINE\nRDISR01  EQU   *  THIS RTN HANDLES RANDOM READS TO AN ISAM DATA SET\n*                 BY CONV OF KEY ADR (COL 24)\n         ST    R14,RD14HOLD     SAVE RETURN ADR\n         MVC   ADR2,RDISR1AC        PUT RETURN ADR IN ADR RTN\n         MVC   CARD+60(4),CARD+19   SAVE A ADR\n         MVC   CARD+19(4),CARD+24   MOVE KEY ADR TO A-ADR\n         B     AADRRTN              CONV KEY ADR\nRDISR01A MVC   IOCODE4+2(2),B2D2    MOVE ADR OF KEY TO INLINE CODE\n         MVC   CARD+19(4),CARD+60   PUT A-ADR BACK\n         L     R14,RD14HOLD         RETURN\n         BR    R14\nRD14HOLD DC    1F'0'                HOLD AREA FOR RETURN ADR\nRDISR1AC DC    S(RDISR01A)\nAMSW     DC    CL1'0'    ACCESS METHOD SW 0=PS 1=IS 2=ISR\nDICON    DC    CL2'DICON'                                             *\nDKCON    DC    CL2'DKCON'                                             *\n         EJECT\n         DS    0F\nCALL1    EQU   *\n* THIS RTN GENERATES THE CODE TO CALL LOAD MODULES\n*   THIS RTN IS RESPONSIBLE FOR LOADING THE MODULE & MAKING SURE THE\n*     MODULE IS ONLY LOADED ONE TIME.\n* FORMAT OF LIST STORED AT END OF USERCODE\n*         0000-0031 = PARM LIST ADRS (8)\n*         0032-0035 = ACT LIST ADR\n*         0036-0039 = ACT EPLOC\n*         0040-0047 = MOD NAME\n*         0048-0049 = BASE/DISP OF LIST STORED AT END OF USERCODE\n*\n         MVI   CALL02A+1,X'00'   * RESETS SWS THAT MAY HAVE BEEN SET\n         MVI   CALL02AA+1,X'00'   * BY SORT OR BINARY BUT NOT RESET\nCALLSR01 CLC   RRGENSRT,CARD+19   Q. CALL OF RRGEN SORT\n         BE    CALLSR10              YES\n         CLC   RELEASE,CARD+19    Q. CALL OF RELEASE FOR SORT\n         BE    CALLSR20              YES\n         CLC   RETURNC,CARD+19    Q. CALL OF RETURN FOR SORT\n         BE    CALLSR30              YES\n         CLC   RRBINARY,CARD+19    Q. CALL OF RRBINARY\n         BNE   CALL01                 NO\n         MVC   BINPARMS,CARD+44   YES-STORE PARMS PASSED        C9 (-)\n         MVI   CALL02AA+1,X'F0'      SET SW FOR RRBINARY\n         MVI   CARD+43,X'40'      ONLY LET IT CK FOR 2 PARMS\nCALL01   MVC   MODULENA,CARD+19  MOVE IN MODULE NAME FOR LOAD INST\n         CLI   CARD+27,X'40'   Q.ARE THE ANY PARAMETERS TO PASS\n         BE    CALL01AA          NO-BYPASS CREATING PARAM LIST\n         CLC   CARD+27(7),USINGCON    Q. IS ',USING,' IN CARD\n         BNE   RDERR                     NO- GO TO FLAG AS ERROR\nCALL01AA CLC   ENDUSER,CENDUSER    Q. FIRST MODULE TO BE CALLED\n         BE    CALL01B                YES\n         L     R4,ENDUSER\nCALL01A  CLC   40(8,R4),CARD+19   Q.  MODULE CALLED BEFORE\n         BE    CALL0105               YES\n         LA    R4,52(R4)       NO - BUMP TO LOOK AT NEXT ENTRY\n         C     R4,CENDUSER          Q. HAVE WE LOOKED AT ALL MOD CALLED\n         BNE   CALL01A                NO-TRY AGAIN\n         B     CALL01B                NEVER USED BEFORE\nCALL0105 MVI   CALL05+1,X'F0'         BRANCH AROUND LOAD OF MOD\n         MVC   CARD(4),36(R4)    SAVE EPLOC FOR MODILE\nCALL01B  LH    R4,BDLIST      * KEEP BASE/DISP\n         LA    R5,52(0)      * ADR POINT TO LIST\n         SR    R4,R5          *  BEING CREATED\n         STH   R4,BDLIST      *\n         L     R4,ENDUSER      *PARMS LIST ARE STORE AT END\n         LA    R5,52(0)        * OF USERCODE\n         SR    R4,R5           * FORMAT             32POS/PARM-ADR\n         ST    R4,ENDUSER      *  4POS/EPLOC 4POS/LIST ADR  8POS-MODID\n         LA    R5,CARD+33       *    2POS/BD-OF-LIST-ADR  2POS FILLER\n         LA    R9,8(0)          *TALLY CT 8 PARMS MAX\nCALL02   CLI   0(R5),C','       * Q. LAST PARM\n         BE    CALL03           *    NO\nCALL02A  NOP   CALLSR12   THIS BR IS EXEC WHEN CALL OF RRGEN SORT MOD\nCALL02AA NOP   CALLBIN1   THIS BR EXEC WHEN CALL OF RRBINARY\n         LA    R3,4(0)       ***POINT R4\n         SR    R4,R3         ***BACK TO LAST PARM IN LIST\nCALL02B  MVI   0(R4),X'80'    * YES FLAG AS LAST ONE\n         L     R4,ENDUSER\n         B     CALL04\nCALL03   MVC   CARD+19(4),1(R5)   MOVE IN NEXT PARM\n         BAL   R14,CALLST01         GO CONVERT IT TO ACTUAL\n         ST    R3,0(R4)             STORE ACTUAL ADR IN LIST\n         LA    R4,4(R4)         POINT R4 TO ADR TO STORE NEXT PARM ADR\n         LA    R5,5(R5)             BUMP 5 TO POINT TO NEXT PARM IN CD\n         BCT   R9,CALL02          Q. END OF PARM (MAX 8)\n         B     CALL02A            A-YES\nCALL04   MVC   40(8,R4),MODULENA     YES-PUT MOD NAME AT END\n         LH    R5,BDLIST     * BUMP BASE/DISP OF LIST BY 1\n         LA    R5,1(R5)      *  TO ADJUST FOR IT BEING OFF\n         STH   R5,48(R4)     *    STORE RESULT\n         CLI   CARD+27,X'40'  Q. WERE ANY PARMS PASSED\n         BE    CALL09A            NO - GO PUT ZEROS IN ACTUAL LIST ADR\n         ST    R4,32(R4)         PUT ACTUAL LIST ADR IN\nCALL04A  ST    R4,BINLISTA   STORE ACTUAL LIST ADR FOR BINARY SCH RTN\nCALL05   NOP   CALL07              SW TO BYPASS CALLING MOD AGAIN\nCALL06   LOAD  EPLOC=MODULENA       LOAD MODULE\n         ST    R0,36(R4)  STORE ENTRY POINT LOC\n         CLC   MODULENA,RRGENSRT  Q. IS IT CALL OF RRGEN SORT\n         BNE   CALL08                NO\n         L     R5,ADRUBASE  MUST BE LOADED, SRT4,8,12 IN COMM AREA\n         L     R3,36(R4)             YES-GET ACT ADR\n         LA    R3,10(R3)             BUMP ACT BY 10\n         ST    R3,SRT4               STORE FOR RELEASE ADR\n         LA    R3,14(R3)           BUMP ACT BY 14\n         ST    R3,SRT8               STORE FOR  SORT ADR\n         LA    R3,14(R3)           BUMP ACT BY 14\n         ST    R3,SRT12              STORE FOR RETURN ADR\nCALL08   CLC   MODULENA,TAPECLAS       Q. TAPECLASS\n         BNE   CALL08A                     NO\n         MVI   TAPECLSW+1,X'00'  TURN ON SW TO TAKE ABEND IF PARMS BAD\n         L     R1,32(R4)                   YES - LOAD LIST ADR\n         L     R15,36(R4)                      LOAD EPLOC\n         BALR  R14,R15                   GO TO TAPECLASS\n         LA    R14,0(0,0)\n         CR    R14,R15                 Q. GOOD RETURN\n         BNE   RDERR                       NO - GO FLAG AS ERROR\n         B     PARPRT                      YES - GO PRINT\nCALL08A  CLC   MODULENA,RRBINARY       Q. IS IT THE BINARY SEARCH\n         BNE   CALL09                    NO\n         MVC   BINADR,36(R4)    YES MOVE IN EPA OF RRBINARY MODULE\nCALL09   MVC   CALLINST+2(2),48(R4)      BASE/DISP ADR TO GEN CODE\n         MVI   CALL05+1,X'00'        NOP BYPASSING LOAD INST\n         MVC   INSHOLD(6),CALLGEN1    * MOVE\n         MVC   INSHOLD+8(6),CALLGEN2  *  GENERATED\n         MVC   INSHOLD+16(6),CALLGEN3 *   CODE\n         MVC   INSHOLD+24(4),CALLGEN4  *    IN-LINE\n         MVC   INSHOLD+32(6),CALLGEN5\n         MVC   INSHOLD+40(8),CALLGEN6\n         MVC   INSHOLD+48(6),CALLGEN7\n         CLC   MODULENA,RRBINARY   Q. IS THIS RRBINARY SEARCH\n         BNE   PARPRT                 NO-GO PRT & INSERT CODE\n         L     R1,BINLISTA     ACTUAL LIST ADR\n         L     R15,BINADR      EPA OF BINARY SEARCH\n         BALR  R14,R15         GO LET HIM DO HSKING\n         LA    R14,0(0,0)      SET 14 TO ZEROS\n         CR    R14,R15      Q. WAS PARMS VALID\n         BNE   RDERR           NO-GO TO FLAG AS ERROR\n         B     PARPRT         YES- GO PRT & INSERT CODE\nCALL09A  MVC   32(4,R4),CHEXZERO    R1 WILL EQ ZEROS IF NO PARMS\n         B     CALL04A                WERE PASSED\nCHEXZERO DC    XL4'00'\nCALL07   MVC   36(4,R4),CARD   PUT EPLOC IN FOR PREVIOUSLY LOADED\n         MVI   CALL05+1,X'00'    NOP BYPASSING LOAD INST\n         B      CALL08\n* GEN CODE FOR CALL MACRO\nCALLGEN1 DC    XL2'03'\nCALLINST LA    R2,0(0)            LOAD ADR OF INFO ABOUT MOD\nCALLGEN2 DC    XL2'03'\n         L     R1,32(R2)      LOAD ACTUAL LIST ADR\nCALLGEN3 DC    XL2'03'\n         L     R15,36(R2)     LOAD ACTUAL EPLOC\nCALLGEN4 DC    XL2'01'\n         BALR  R14,R15            GO TO MOD\nCALLGEN5 DC    XL2'03'\n         CVD   R15,RTCD       CONVERT RETURN CODE TO DEC\nCALLGEN6 DC    XL2'05'\n         UNPK  RTCD(4),RTCD+4(4)      CONVERT RETURN CODE TO ZONED\nCALLGEN7 DC    XL2'03'\n         OI    RTCD+3,X'F0'  ELIM C ON LAST POS\n* THIS RTN CONVERTS LIST ADR  WHICH SHOULD BE IN CARD+19 TO:1ST\n*  BASE/DISP AND THEN TO ACTUAL\nCALLST01 ST    R14,CALLHOLD  SAVE RETURN ADR\n         CLC   CARD+19(4),C0000    Q. IS ADR > OR = 0000\n         BL    RDERR                  NO . ERROR\n         CLC   CARD+19(4),C5999    Q. IS ADR < 5999\n         BH    RDERR                  YES - ERROR\n         MVC   ADR2,CALST03A         *PUT RTN ADR IN ADRRTN AND GO LET\n         ST    R4,CALLWK       SAVE 4\n         B     AADRRTN               *ADRRTN CONV IT TO BASE/DISP\nCALLST03 L     R4,CALLWK          RELOAD 4 AFTER ADR RTN\n         ST    R10,CALLWK\n         LA    R10,OURCODE   CHG 10 TO WHAT IT WILL BE AT USER TIME\n         MVC   CALLST04+2(2),B2D2    /CHG BASE/DISP\nCALLST04 LA    R3,*+0                /  TO ACTUAL\n         L     R10,CALLWK           RELOAD REG 10\n         L     R14,CALLHOLD         (RETURN\n         BR    R14                    TO USER)\nCALLHOLD DC    1F'0'       HOLD AREA FOR RETURN ADR\nCALLWK   DC    1F'0'\nCALST03A DC    S(CALLST03)    THE ADR WHERE WE WANT THE ADRRTN TO RETN\nUSINGCON DC    CL7',USING,'\n         DS    0F\nC0000    DC    CL4'0000'\nC5999    DC    CL4'5999'\nMODULENA DC    CL8' '\nTAPECLAS DC    CL8'TAPECLAS'\nCALLSR10 NOP   RDERR            *CAN ONLY CALL RRGENSRT\n         MVI   CALLSR10+1,X'F0'   * ONE TIME\n         MVC   SORTTAGS,CARD+44    SAVE TGS FOR END OF PARS LOGIC\n*  VALID AT TAGS FOR IN + OUT PROCEDURES\n         CLC   CARD+44(2),=C'TG'       Q. VALID TAG , IN ADR\n         BNE   RDERR                      NO\n         CLC   CARD+49(2),=C'TG'       Q. VALID TAG , OUTPUT PROC ADR\n         BNE   RDERR                      NO\n         MVC   SIZEWK+2(2),CARD+46\n         BAL   R14,CNVRTN                 *CONVERT TG # TO BINARY\n         C     R3,FFCON                Q.          WAS IT VALID\n         BE    RDERR                      NO\n         C     R3,ZERO                 Q  TAG # ZERO\n         BE    RDERR                         YES-INVALID\n         MVI   SORTSW+1,X'00'  SET SORT SW IN PAREND LOGIC\n         MVC   SIZEWK+2(2),CARD+51\n         BAL   R14,CNVRTN\n         C     R3,FFCON                Q. VALID TG #\n         BE    RDERR                             NO-INVALID\n         C     R3,ZERO                 Q. TAG # ZERO\n         BE    RDERR                         YES-INVALID\n         MVI   CARD+43,C' '        CLEAR COMMA BEFORE TAGS IN CARD\n*  ELIMINATES CALL RTN LOOKING AT 2 TG ADR IN CALL OF RRGEN SRT CARD '\n         MVI   CALL02A+1,X'F0'  THIS WILL SET A SWITCH TO BRANCH BACK\n*                               TO CALLSR12 BEFORE CALL RTN FLAGS\n*                               LAST PARM IN LIST. WE MUST ADD TWO ADRS\n*                               TO LIST(INPUT + OUTPUT PROCEDURE ADRS)\n*                NOTE: REG 4 WILL POINT TO WHERE NEXT PARM ADR IS TO\n*                      BE STORED\n         B     CALL01           GO BACK TO NORMAL CALL LOGIC\nCALLSR12 MVC   0(4,R4),INADR    MOVE ACT ADR OF INPUT PROC TO LIST\n         LA    R4,4(R4)         BUMP BY 4\n         MVC   0(4,R4),OUTADR   MOVE ACT ADR OF OUTPUT PROC TO LIST\n         LA    R4,4(R4)     BUMP BY 4\n         MVC   0(4,R4),SORTREC   MOVE SORT REC ACT ADR INTO LIST\n         B     CALL02B          GO BACK TO NORMAL LOGIC\nCALLSR20 MVC   SORTRI1+2(2),BDSRT4  MOVE BD ADR OF EPA OF RELEASE\n         B     CALLSR32\nCALLSR30 MVC   SORTRI1+2(2),BDSRT12 MOVE BD ADR OF EPA OF RETURN\nCALLSR32 MVC   INSHOLD(6),SORTRS1   *MOVE GEN CODE\n         MVC   INSHOLD+8(4),SORTRS2    IN-LINE\n         B     PARPRT               GO PRINT AND INSERT CODE\nCALLBIN1 L     R5,ADRUBASE   MUST BE LOADED\n         MVC   0(4,R4),INX1ADRB     MOVE ACT ADR OF INX1 TO LIST\n         LA    R4,4(R4)             BUMP 4 BY 4\n         MVC   0(4,R4),BINPMADR   MOVE ADR OF PARMS IN       PARENDS\n         B     CALL02B            GO BACK TO NORMAL       LOGIC\nINADR    DC    A(INPROC)\nOUTADR   DC    A(OUTPROC)\nSORTREC  DC    A(OURCODE+3000)     SORT RECORD AREA 5000\nRRBINARY DC    CL8'RRBINARY'\nBINADR   DC    1F'0'       ENTRY POINT ADR OF RRBINARY STORED HERE\nBINPARMS DC    CL20'0'\nBINPMADR DC    A(BINPARMS)\nBINLISTA DC    1F'0'\nINX1ADRB DC    A(INX1)\nSORTRS1  DC    XL2'03'\nSORTRI1  L     R15,HEXWORK LOAD ADR OF ENTRY POINT\nSORTRS2  DC    XL2'01'\n         BALR  R14,R15     BR TO IT\nBDSRT4   DC    S(SRT4)\nBDSRT12  DC    S(SRT12)\nRRGENSRT DC    CL8'RRGENSRT'\nRELEASE  DC    CL8'RELEASE '\nRETURNC  DC    CL8'RETURN  '\n         EJECT\nXCONS1   EQU   *\n* THIS RTN CONVERTS HEX DIGITS TO BYTES  EG C1 ON CARD = A IN STORAGE\n*   AFTER  CONVERSION TO BYTES CONTROL IS PASSED TO CONSRTN TO PLACE\n*    CONSTANT IN MEMORY\n         L     R3,SIZEHLD    *LOAD BINARY SIZE\n         AR    R3,R3         *ADD IT TO ITSELF\n         LA    R3,1(R3)      *ADD 1 TO IT = # OF HEX DIGITS\n         ST    R3,HEXWORK     STORE IT\n         MVC   XCONS02+1(1),HEXWORK+3  MOVE COMPUTED SIZE TO TRANSLATE\n         MVC   XCONS03+1(1),HEXWORK+3\n         MVC   HEXTR(40),HEXTR+50    CLEAR FIRST 40 POSITIONS\nXCONS02  TR    CARD+33(40),HEXTR     TRANSLATE  F0=00 F9=09 C1=0A C6=0F\nXCONS03  NC    HEXTR(40),CARD+33    Q.  ALL TOP BITS OFF\n         BM    ML04A                    NO-BAD HEX DIGIT - GO FLAG ERR\n         MVC   HEXTR(40),CARD+33     MOVE CARD FOR PACKING\n         PACK  CARD+33(8),HEXTR(15)    * CONVERT\n         PACK  CARD+40(8),HEXTR+14(15) *  DIGITS TO\n         PACK  CARD+47(7),HEXTR+28(13) *   CHARACTERS\n         B     CONSRTN         GO LET CONSTANT RTN STORE IT\nHEXWORK  DC    1F'0'\nHEXTR    DC    CL193' '\n         DC    XL6'0A0B0C0D0E0F'\n         DC    CL41' '\n         DC    XL10'00010203040506070809'\n         DC    CL6' '\n         EJECT\nDEBUGRTN EQU   *\n         L     R5,UBASE      SET 5 TO USER BASE\n         ST    R5,HEXHLD               STORE ADR\n         BAL   R14,HEXRTN              CONVERT TO HEX  A=C1\n         MVC   RECCTCON+30(6),CONVHEX+2\n         LA    R5,4(R5)                POINT 5 TO INP1 REC COUNT\n         ST    R5,HEXHLD\n         BAL   R14,HEXRTN\n         MVC   RECCTCON+42(6),CONVHEX+2\n         LA    R5,4(R5)                5=INP2\n         ST    R5,HEXHLD\n         BAL   R14,HEXRTN\n         MVC   RECCTCON+54(6),CONVHEX+2\n         LA    R5,4(R5)                INP3\n         ST    R5,HEXHLD\n         BAL   R14,HEXRTN\n         MVC   RECCTCON+66(6),CONVHEX+2\n         LA    R5,4(R5)                OUT1\n         ST    R5,HEXHLD\n         BAL   R14,HEXRTN\n         MVC   RECCTCON+78(6),CONVHEX+2\n         LA    R5,4(R5)                OUT2\n         ST    R5,HEXHLD\n         BAL   R14,HEXRTN\n         MVC   RECCTCON+90(6),CONVHEX+2\n         LA    R5,4(R5)                OUT3\n         ST    R5,HEXHLD\n         BAL   R14,HEXRTN\n         MVC   RECCTCON+102(6),CONVHEX+2\n      LA       R5,4(R5)                CARD\n         ST    R5,HEXHLD\n         BAL   R14,HEXRTN\n         MVC   RECCTCON+114(6),CONVHEX+2\n         MVC   HEXHLD(4),P000           CONVERT\n         BAL   R14,HEXRTN                  ACTUAL PRT ADR\n         MVC   AREALCON+30(6),CONVHEX+2\n         MVC   HEXHLD(4),CD00\n         BAL   R14,HEXRTN               CARD ADR\n         MVC   AREALCON+114(6),CONVHEX+2\n         MVC   HEXHLD(4),CONSACT\n         BAL   R14,HEXRTN              CONS ADR\n         MVC   AREALCO2+52(6),CONVHEX+2\n         LA    R10,OURCODE+4096         R10=LHE OUT 1\n         ST    R10,HEXHLD\n         BAL   R14,HEXRTN\n         MVC   AREALCON+78(6),CONVHEX+2\n         LA    R10,900(R10)             OUT I\n         ST    R10,HEXHLD\n         BAL   R14,HEXRTN\n         MVC   AREALCON+90(6),CONVHEX+2\n         LA    R10,900(R10)            OUT 3\n         ST    R10,HEXHLD\n         BAL   R14,HEXRTN\n         MVC   AREALCON+102(6),CONVHEX+2\n         MVC   HEXHLD(4),INX1ACON\n         BAL   R14,HEXRTN\n         MVC   AREALCO2+10(6),CONVHEX+2\n         MVC   HEXHLD(4),INX2ACON\n         BAL   R14,HEXRTN\n         MVC   AREALCO2+24(6),CONVHEX+2\n         MVC   HEXHLD(4),RESULTAC\n         BAL   R14,HEXRTN\n         MVC   AREALCO2+38(6),CONVHEX+2\n         MVC   PRTAREA(133),PRTAREA-1\n         PUT   PRINTER,PRTAREA+1\n         MVC   PRTAREA+50(14),DEBUGCON   MOVE IN DEBUG HDR\n         PUT   PRINTER,PRTAREA+1\n         MVC   PRTAREA+1(120),RECCTCON  RECORD COUNT LOC\n         PUT   PRINTER,PRTAREA+1\n         MVC   PRTAREA+1(120),AREALCON   AREA LOCATIONS\n         PUT   PRINTER,PRTAREA+1\n         MVC   PRTAREA(133),PRTAREA-1\n         MVC   PRTAREA+16(58),AREALCO2\n         PUT   PRINTER,PRTAREA+1\n         L     R5,UBASE      SET 5 TO USER BASE\n         MVC   PRTAREA(133),PRTAREA-1\n         PUT   PRINTER,PRTAREA+1    SPACE 1 LINE\n         B     CLEAR01\nUBASE    DC    A(USERBASE)\nP000     DC    A(PRTAREA+1)\nCD00     DC    A(CARD)\nCONSACT  DC    A(CONS)\nINX1ACON DC    A(INX1)\nINX2ACON DC    A(INX2)\nRESULTAC DC    A(RESULT)\nDEBUGCON DC    CL14'DEBUGGING AIDS'\nRECCTCON DC    CL49'RECORD COUNT LOCATIONS  PRINT=XXXXXX INP1=XXXXXX '\n         DC    CL48'INP2=XXXXXX INP3=XXXXXX OUT1=XXXXXX OUT2=XXXXXX '\n         DC    CL23'OUT3=XXXXXX CARD=XXXXXX'\nAREALCON DC    CL50'AREA LOCATIONS          P000 =XXXXXX A000=REG7   B'\nARE      DC    CL50'000=REG8   C000=REG9   J000=XXXXXX K000=XXXXXX L00'\n         DC    CL20'0=XXXXXX CD00=XXXXXX'\nAREALCO2 DC    CL47'     INX1=XXXXXX   INX2=XXXXXX   RS00=XXXXXX   '\n         DC    CL11'0000=XXXXXX'\n         EJECT\nREGS     DSECT\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END   OURCODE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RRGENSRT": {"ttr": 2561, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Q\\x00\\x890o\\x01\\x10\"\\x9f\\x10D\\x00\\xc2\\x00\\x00\\x00\\x00\\xe2\\xd7\\xc5\\xd5\\xc3\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-02T00:00:00", "modifydate": "2010-08-17T10:44:51", "lines": 194, "newlines": 0, "modlines": 0, "user": "SPENCER"}, "text": "*PROCESS SUPRWARN(303)\nRRSORT   START\n         USING *,15\n         MVC   SAVEX+2(2),FTADR        * SET SAVE EXIT TO FTRTN.\n         B     SAVEM                   * GO SAVE REGISTERS.\n         L     15,42(15)               * EP FROM RELEASE.\n         MVC   SAVEX+2(2),RLSEADR      * SET SAVE EXIT TO RLSERTN.\n         B     SAVEM                   * GO SAVE REGISTERS.\n         L     15,28(15)               * EP FROM IN PROC EXIT.\n         MVC   SAVEX+2(2),ISTXADR      * SET SAVE EXIT TO ISTXRTN.\n         B     SAVEM                   * GO SAVE REGISTERS.\n         L     15,14(15)               * EP FROM RETURN.\n         MVC   SAVEX+2(2),OSTXADR      * SET SAVE EXIT TO OSTXRTN.\n         B     SAVEM                   * GO SAVE REGISTERS.\nEPADR    DC    A(RRSORT)\nFTADR    DC    S(FTRTN)\nRLSEADR  DC    S(RELEASE)\nISTXADR  DC    S(SORTEM)\nOSTXADR  DC    S(RETURN)\nSAVEM    SAVE  (14,12)                 * SAVE RRGEN REGS\n         BALR  12,0                    *\n         USING *,12                    *\nSTART    LA    11,MYSAVE               *\n         ST    11,8(13)                *\n         ST    13,4(11)                *\n         LR    13,11                   *\nSAVEX    B     FTRTN\n* THIS ROUTINE CALLS THE SORT AND PASSES THE PARAMETER ADDRESS. THIS\n*  ROUTINE IS ENTERED WHEN THE SORT MACRO IS EXECUTED IN THE COMPILED\n*  RRGEN PROGRAM. THE SORT RETURNS TO THIS MODULE AT END OF SORT.\n*  THIS ROUTINE THEN RETURNS TO THE RRGEN PROGRAM AT TGEF.\nFTRTN    MVC   LHESCD(4),0(1)          * MOVE LHE SORT STAT TO PARM.\n         MVC   LHERECD(4),4(1)         * MOVE LHE REC STAT TO PARM.\n         MVC   ADRIN(4),8(1)           * RRGEN INPUT PROC ADDR TO HOLD.\n         MVC   ADROUT(4),12(1)         * RRGEN OUT PROC ADDR TO HOLD.\n         MVC   RECAR(4),16(1)          * RECAR ADDR TO HOLD.\n         ST    14,ADREOF               * STORE RETURN ADDR.\n* FIND RHE OF SORT STATEMENT .\n         L     5,LHESCD                * 5 POINT TO LHE OF SORT STAT.\n         LA    6,45(5)                 * SET SEARCH LIMIT.\nFT01     CLC   0(6,5),=C'FIELDS'       * START OF FIELD PARAMETER?\n         BE    FT02                    * YES\n         LA    5,1(5)                  * NO, 5 UP BY 1.\n         CR    5,6                     * END OF SEARCH?\n         BL    FT01                    * NO.\n         ST    6,RHESCD                * YES, BAD SORT STATEMENT.\n         B     FT04\n         LA    5,6(5)\nFT02     CLI   0(5),C' '               * END OF SORT STATEMENT?\n         BE    FT03                    * YES\n         LA    5,1(5)                  * NO, 5 UP BY 1\n         B     FT02                    *  GO LOOK AT NEXT POS.\nFT03     ST    5,RHESCD                * RHE SORT STAT TO HOLD.\n* FIND RECORD  SIZE FOR MOVE OF RECORD AND RHE OF RECORD STATEMENT.\nFT04     L     5,LHERECD               * 5 TO LHE RECORD STATEMENT.\n         LA    6,45(5)                 * SET SEARCH LIMIT.\nFT05     CLC   0(6,5),=C'LENGTH'       * LENGTH PARM?\n         BE    FT06                    * YES\n         LA    5,1(5)                  * 5 UP BY 1.\n         CR    5,6                     * SEARCH LIMIT REACHED?\n         BL    FT05                    * NO, GO CHECK NEXT POS.\n         ST    6,RHERECD               * BAD RECORD STATEMENT\n         B     FT13\nFT06     TRT   7(5,5),NUMTAB           * 5 POS SIZE.\n         BNZ   FT06A                   * NO, CHECK 4.\n         MVC   SIZWK+3(5),7(5)         * YES, MOVE TO WORK.\n         B     FT08\nFT06A    TRT   7(4,5),NUMTAB           * 4 POS SIZE.\n         BNZ   FT06B                   * NO, CHECK 3.\n         MVC   SIZWK+4(4),7(5)         * YES, MOVE TO WORK.\n         B     FT08\nFT06B    TRT   7(3,5),NUMTAB           * 3 POS SIZE?\n         BNZ   FT07\n         MVC   SIZWK+5(3),7(5)         * RECORD SIZE TO HOLD AREA.\n         B     FT08\nFT07     TRT   7(2,5),NUMTAB           * SIZE 2 POS ?\n         BNZ   FT08                    * NO - BUT LET SORT BRING DOWN.\n         MVC   SIZWK+6(2),7(5)         * MOVE 2 POS SIZE TO HOLD AREA.\nFT08     CLI   0(5),C' '               * END OF RECORD STATEMENT.\n         BE    FT09                    * YES\n         LA    5,1(5)                  * NO, 5 UP BY 1.\n         B     FT08                    * GO LOOK AT NEXT POS.\nFT09     ST 5,RHERECD                  * RHE RECORD STATEMENT TO HOLD.\n         CLC   SIZWK+3(5),=C'00900'    * RECORD GREATER THAN 900 POS.\n         BH    FT13\n         PACK  SIZWK(8),SIZWK(8)       * PACK RECORD SIZE.\n         CVB   7,SIZWK                 * RECORD SIZE TO BINARY.\n         LTR   7,7                     * RECORD SIZE ZERO.\n         BZ    FT13                    * YES. ERROR.\n         LH    5,=H'256'               * 5 = MAX MOVE CNT.\n         LA    6,MOVE1                 * 6 TO 1ST MOVE INS\n         BCTR  7,0                     * REC SIZE DOWN BY 1.\nFT10     CR    5,7                     * REC SIZE LESS THAN 256?\n         BH    FT11                    * YES.\n         MVI   7(6),X'00'              * NO,SET MOVE SWITCH.\n         SR    7,5                     * REC SIZE DOWN BY 256.\n         LA    6,10(6)                 * 6 TO NEXT MOVE INS\n         B     FT10                    *\nFT11     STC   7,1(6)                  * REMAINDER TO MOVE INS.\n         LA    1,SORTPARM\n         LINK  EP=SORT,MF=(E,(1))      * GO SORT.\nFT12     L     14,ADREOF\n         L     13,MYSAVE+4\n         LM    0,12,20(13)\n         BR    14\nFT13     LA    15,11(0)                * SET RETURN CODE.\n         B     FT12\nAPROCOUT DC    A(PROCOUT)\n* THIS ROUTINE PASSES A RECORD FROM RRGEN INPUT PROCEDURE TO THE SORT.\n*  RETURN FROM SORT IS TO PROCIN.\nRELEASE  ST    14,ADRIN                * SET RRGEN RETURN ADDR.\n         L     13,SRTSAVE              * GET SORT SAVE AREA ADDR.\n         L     1,RECAR                 * R1 POINTS TO RECORD.\n         LM    14,0,12(13)\n         LM    2,12,28(13)\n         LA    15,12(0)                * R15 = RETURN CODE\n         BR    14                      * RETURN TO SORT.\n* THIS ROUTINE GOES TO THE SORT AT END OF INPUT PROCEDURE.\n*  RETURN FROM SORT IS TO PROCOUT.\nSORTEM   L     13,SRTSAVE              * GET SORT SAVE AREA ADDR.\n         RETURN (14,12),,RC=8          * RETURN TO SORT.\n* THIS ROUTINE GOES TO THE SORT TO GET ANOTHER RECORD.\n*  RETURN FROM SORT IS AT PROCOUT\nRETURN   ST    14,ADROUT               * SET RRGEN RETURN ADDR.\n         L     13,SRTSAVE              * GET SORT SAVE AREA ADDR.\nFTSW1    BC    0,RETURN01              * ONE TIME SWITCH.\n         MVI   FTSW1+1,X'F0'           * RESET ONE TIME SWITCH.\n         MVI   FTSW2+1,X'00'           * RESET OUT PROC ONE TIME SW.\n         L     5,24(13)                * GET SORT RECAR ADDR.\n         L     5,0(5)\n         L     15,APROCOUT\n         B     MOVEREC                 * GO GET FIRST RECORD.\nRETURN01 RETURN (14,12),,RC=4          * RETURN TO SORT.\n         DS    0F\n         DC    X'0000'\nSRTPARM  DC    XL2'001C'\nLHESCD   DC    A(0)\nRHESCD   DC    A(0)\nLHERECD  DC    A(0)\nRHERECD  DC    A(0)\nINPROC   DC    A(PROCIN)\nOUTPROC  DC    A(PROCOUT)\n         DC    XL4'FF00C1D7'\nADRIN    DC    A(0)\nADROUT   DC    A(0)\nADREOF   DC    A(0)\nRECAR    DC    A(0)\nSORTPARM DC    X'80'\n         DC    AL3(SRTPARM)\nSRTSAVE  DC    A(0)\nMYSAVE   DC    18F'0'\n* THIS ROUTINE IS THE INPUT PROCEDURE FOR THE SORT. THE SORT LINKS TO\n*  THIS ROUTINE AND THIS ROUTINE BRANCHES TO RRGEN AT TGSI.\n         USING *,15\nPROCIN   SAVE  (14,12)                 * SAVE SORT REGS.\n         L     12,IBASE                * ESTABLISH MYBASE.\n         ST    13,SRTSAVE              * SAVE SORT SAVE AREA ADR.\n         L     13,MYSAVE+4             * GET RRGEN SAVE AREA.\n         L     14,ADRIN                * POINT 14 TO TGSI.\n         LM    15,12,16(13)            * RESTORE RRGEN REGS.\n         BR    14                      * BRANCH TO TGSI\nIBASE    DC    A(START)\n** THIS ROUTINE IS THE OUTPUT PROCEDURE FOR THE SORT. THE SORT LINK\n**  TO THIS ROUTINE WHEN IT IS THROUGH SORTING. THIS ROUTINE MOVE A\n*   RECORD TO RECAR AND BRANCHES TO RRGEN AT TGSO. AT END OF FILE\n*   THIS ROUTINE BRANCHES BACK TO THE SORT.\n         USING *,15\nPROCOUT  SAVE  (14,12)                 * SAVE SORT REGS.\n         L     12,OBASE                * ESTABLISH MY BASE.\n         ST    13,SRTSAVE              * SAVE SORT SAVE AREA ADR.\n         L     5,0(1)                  * 5=RECAR FROM SORT\n         LTR   5,5                     * EOF ?\n         BZ    SRTEOF                  * YES\nFTSW2    BC    15,PROCX                * FIRST TIME FROM SORT SWITCH.\nMOVEREC  L     6,RECAR                 * GET RRGEN RECAR ADDR.\nMOVE1    MVC   0(256,6),0(5)           * MOVE 1ST PART OF RECORD.\nSW1      BC    15,PROCX                * BRANCH IF NO MORE RECORD.\nMOVE2    MVC   256(256,6),256(5)       * MOVE 2ND PART OF REC.\nSW2      BC    15,PROCX                * BRANCH IF NO MORE.\nMOVE3    MVC   512(256,6),512(5)       * MOVE 3RD PART OF RECORD.\nSW3      BC    15,PROCX                * BRANCH IF NO MORE.\nMOVE4    MVC   768(132,6),768(5)       * MOVE REST OF REC (MAX 900)\nPROCX    L     13,MYSAVE+4             * GET RRGEN SAVE AREA ADDR.\n         L     14,ADROUT               * GET TGSO ADDR.\n         LM    15,12,16(13)            * RESTORE RRGEN REGS.\n         BR    14                      * GO TO TGSO.\nSRTEOF   RETURN (14,12),,RC=8          * GO TO SORT.\nOBASE    DC    A(START)\n         DS    0D\nSIZWK    DC    CL8'00000000'\nNUMTAB   DC    CL240' '\n         DC    XL10'00'\n         DC    CL6' '\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RRINP1DI": {"ttr": 1028, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00C\\x00\\x890o\\x00\\x890o\\x14\\x18\\x00\"\\x00\"\\x00\\x00\\xe2\\xd7\\xc5\\xd5\\xc3\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-02T00:00:00", "modifydate": "1989-11-02T14:18:43", "lines": 34, "newlines": 34, "modlines": 0, "user": "SPENCER"}, "text": "RRIN1DIN  CSECT\n*  THIS MODULE IS CALLED BY GEN PROGRAM\n*   TO READ DA DATA SETS / TYPE = DI  (DATA AND KEY)\n         SAVE  (2,12),T,*\n         BALR  11,0\n         USING *,11\n         ST    13,SAVEAREA+4\n         LR    4,13\n         LA    13,SAVEAREA\n         ST         13,8(4)\nML01     B     ML03         1ST TIME SWITCH\n         MVC   DECBIN+29(1),4(14)   PUT APPRO REG FOR BLK ADR\nML02     READ  DECBIN,DI,DCBIN,*+12,'S','S',(7)\n         WAIT  ECB=DECBIN\n         TM    DECBIN+1,X'04'    Q. EOD\n         BNZ   ML05                  YES\n         CHECK DECBIN                NO\nML02A    L     13,SAVEAREA+4   *RESTORE\n         LM    14,12,12(13)    * HIS REGISTERS\n         LA    14,12(0,14)     * BUMP 14 TO BYPASS PARMS\n         BR    14             *       USER\nML03     MVC   DECBIN+12,0(14)     MOVE IN AREA ADR\n         OPEN  (DCBIN)\n         MVI   ML01+1,X'00'      NOP  1ST TIME SWITCH\n         B     ML02A\n* EOF EXIT\nML05     L     13,SAVEAREA+4\n         LM    14,12,12(13)\n         LA    15,0(0,0)\n         BR    14\nSAVEAREA DC    18F'0'\nRECAREA  DS    CL900\nDCBIN    DCB   DDNAME=INP1,DSORG=DA,MACRF=RCI,RECFM=F\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RRINP1DK": {"ttr": 1030, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00C\\x00\\x890o\\x00\\x890o\\x14\\x18\\x00/\\x00/\\x00\\x00\\xe2\\xd7\\xc5\\xd5\\xc3\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-02T00:00:00", "modifydate": "1989-11-02T14:18:43", "lines": 47, "newlines": 47, "modlines": 0, "user": "SPENCER"}, "text": "RRIN1DKN  CSECT\n*  THIS MODULE IS CALLED BY GEN PROGRAM\n*   TO READ DA DATA SETS / TYPE = DI  (DATA AND KEY)\n         SAVE  (2,12),T,*\n         BALR  11,0\n         USING *,11\n         ST    13,SAVEAREA+4\n         LR    4,13\n         LA    13,SAVEAREA\n         ST         13,8(4)\nML01     B     ML03         1ST TIME SWITCH\n         MVC   DECBIN+29(1),4(14)   PUT APPRO REG FOR BLK ADR\n         MVC   ML03A+2(2),6(14)  * MOVE KEY ADR TO NEXT INST\nML03A    LA    14,*+0            * CONV BASE/DISP TO ACTUAL ADR\n         ST    14,DECBIN+20   * STORE ACTUAL ADR IN READ MACRO\n         LA    13,SAVEAREA       * POINT 13 BACK TO MY SAVEAREA\nML02     READ  DECBIN,DK,DCBIN,*+12,'S',*+20,(7)\n         WAIT  ECB=DECBIN\n         TM    DECBIN+1,X'80'   Q.  RECORD NOT FOUND\n         BZ    CHECK                NO\n         L     6,HOLD\n         MVC   0(6,6),NOHIT         MOVE 'NOHIT' TO AREA\n         B     ML02A                GO BACK\nCHECK    CHECK DECBIN                NO\nML02A    L     13,SAVEAREA+4  * RELOAD\n         LM    14,12,12(13)     *  AND\n         LA    15,0(0,0)      *     RETURN\n         LA    14,12(0,14)    *      TO\n         BR    14             *       USER\nML03     MVC   DECBIN+12(4),0(14)  MOVE AREA ADR TO READ INST\n         MVC   ML04+2(2),4(14)   MOVE REC AREA ADR TO LOAD ADR INST.\n         MVC   HOLD,DECBIN+12\nML04     LA    2,*+0             CONVERT TO ACT ADR.\n         ST    2,DECBIN+24     STORE BLK ADR FOR READ\n         OPEN  (DCBIN)\n         MVI   ML01+1,X'00'      NOP  1ST TIME SWITCH\n         B     ML02A\n* EOF EXIT\nML05     L     13,SAVEAREA+4\n         LM    14,12,12(13)\n         LA    15,0(0,0)\n         BR    14\nSAVEAREA DC    18F'0'\nHOLD     DS    CL4\nNOHIT    DC    CL8'NOHIT '\nDCBIN    DCB   DDNAME=INP1,DSORG=DA,MACRF=RCK,RECFM=F\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RRINP1IS": {"ttr": 1281, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00C\\x00\\x890o\\x00\\x890o\\x14\\x18\\x00\\x1f\\x00\\x1f\\x00\\x00\\xe2\\xd7\\xc5\\xd5\\xc3\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-02T00:00:00", "modifydate": "1989-11-02T14:18:43", "lines": 31, "newlines": 31, "modlines": 0, "user": "SPENCER"}, "text": "RRINP1IS  CSECT\n*  THIS  MODULE  IS CALLED BY THE GENERATOR PROGRAM\n*         TO HANDLE READ INP1  / ONLY DIFF BETWEEN INP1 2 & 3 ARE\n*          REG USED FOR REC AREA AND DDNAME IN DCB\n         SAVE  (2,12),T,*\n         BALR  12,0\n         USING *,12\n         ST    13,SAVEAREA+4\n         LR    4,13\n         LA    13,SAVEAREA\n         ST    13,8(4)\nML01     B     ML03             1ST SWITCH\nML02     GET   DCBIN,RECAREA\n         LA    7,RECAREA      LOAD 7 WITH REC AREA ADR                *\nML02A    L     13,SAVEAREA+4  RELOAD HIS REGS\n         LM    14,6,12(13)    BYPASS LOADING 7  SINCE IT IS\n         LM    8,12,52(13)     ASSIGN TO HIS INP1 REC AREA\n         LA    15,0(0,0)      SET RETURN CODE TO 0\n         LA    14,12(0,14)    BUMP 14 BY 12 TO RETURN TO ADD TO REC CT\n         BR    14\nML03     OPEN  (DCBIN)\n         MVI   ML01+1,X'00'   NOP 1ST TIME SWITCH\n         B     ML02A\nML04     L     13,SAVEAREA+4\n         LM    14,12,12(13)\n         LA    15,0(0,0)\n         BR    14\nSAVEAREA DC    18F'0'\nRECAREA  DS    CL900\nDCBIN    DCB   DDNAME=INP1,DSORG=IS,MACRF=GM,EODAD=ML04\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RRINP2DI": {"ttr": 1283, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00C\\x00\\x890o\\x00\\x890o\\x14\\x18\\x00\"\\x00\"\\x00\\x00\\xe2\\xd7\\xc5\\xd5\\xc3\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-02T00:00:00", "modifydate": "1989-11-02T14:18:43", "lines": 34, "newlines": 34, "modlines": 0, "user": "SPENCER"}, "text": "RRIN1DIN  CSECT\n*  THIS MODULE IS CALLED BY GEN PROGRAM\n*   TO READ DA DATA SETS / TYPE = DI  (DATA AND KEY)\n         SAVE  (2,12),T,*\n         BALR  11,0\n         USING *,11\n         ST    13,SAVEAREA+4\n         LR    4,13\n         LA    13,SAVEAREA\n         ST         13,8(4)\nML01     B     ML03         1ST TIME SWITCH\n         MVC   DECBIN+29(1),4(14)   PUT APPRO REG FOR BLK ADR\nML02     READ  DECBIN,DI,DCBIN,*+12,'S','S',(7)\n         WAIT  ECB=DECBIN\n         TM    DECBIN+1,X'04'    Q. EOD\n         BNZ   ML05                  YES\n         CHECK DECBIN                NO\nML02A    L     13,SAVEAREA+4   *RESTORE\n         LM    14,12,12(13)    * HIS REGISTERS\n         LA    14,12(0,14)     * BUMP 14 TO BYPASS PARMS\n         BR    14             *       USER\nML03     MVC   DECBIN+12,0(14)     MOVE IN AREA ADR\n         OPEN  (DCBIN)\n         MVI   ML01+1,X'00'      NOP  1ST TIME SWITCH\n         B     ML02A\n* EOF EXIT\nML05     L     13,SAVEAREA+4\n         LM    14,12,12(13)\n         LA    15,0(0,0)\n         BR    14\nSAVEAREA DC    18F'0'\nRECAREA  DS    CL900\nDCBIN    DCB   DDNAME=INP2,DSORG=DA,MACRF=RCI,RECFM=F\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RRINP2DK": {"ttr": 1285, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00C\\x00\\x890o\\x00\\x890o\\x14\\x18\\x00/\\x00/\\x00\\x00\\xe2\\xd7\\xc5\\xd5\\xc3\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-02T00:00:00", "modifydate": "1989-11-02T14:18:43", "lines": 47, "newlines": 47, "modlines": 0, "user": "SPENCER"}, "text": "RRIN1DKN  CSECT\n*  THIS MODULE IS CALLED BY GEN PROGRAM\n*   TO READ DA DATA SETS / TYPE = DI  (DATA AND KEY)\n         SAVE  (2,12),T,*\n         BALR  11,0\n         USING *,11\n         ST    13,SAVEAREA+4\n         LR    4,13\n         LA    13,SAVEAREA\n         ST         13,8(4)\nML01     B     ML03         1ST TIME SWITCH\n         MVC   DECBIN+29(1),4(14)   PUT APPRO REG FOR BLK ADR\n         MVC   ML03A+2(2),6(14)  * MOVE KEY ADR TO NEXT INST\nML03A    LA    14,*+0            * CONV BASE/DISP TO ACTUAL ADR\n         ST    14,DECBIN+20   * STORE ACTUAL ADR IN READ MACRO\n         LA    13,SAVEAREA       * POINT 13 BACK TO MY SAVEAREA\nML02     READ  DECBIN,DK,DCBIN,*+12,'S',*+20,(7)\n         WAIT  ECB=DECBIN\n         TM    DECBIN+1,X'80'   Q.  RECORD NOT FOUND\n         BZ    CHECK                NO\n         L     6,HOLD\n         MVC   0(6,6),NOHIT         MOVE 'NOHIT' TO AREA\n         B     ML02A                GO BACK\nCHECK    CHECK DECBIN                NO\nML02A    L     13,SAVEAREA+4  * RELOAD\n         LM    14,12,12(13)     *  AND\n         LA    15,0(0,0)      *     RETURN\n         LA    14,12(0,14)    *      TO\n         BR    14             *       USER\nML03     MVC   DECBIN+12(4),0(14)  MOVE AREA ADR TO READ INST\n         MVC   ML04+2(2),4(14)   MOVE REC AREA ADR TO LOAD ADR INST.\n         MVC   HOLD,DECBIN+12\nML04     LA    2,*+0             CONVERT TO ACT ADR.\n         ST    2,DECBIN+24     STORE BLK ADR FOR READ\n         OPEN  (DCBIN)\n         MVI   ML01+1,X'00'      NOP  1ST TIME SWITCH\n         B     ML02A\n* EOF EXIT\nML05     L     13,SAVEAREA+4\n         LM    14,12,12(13)\n         LA    15,0(0,0)\n         BR    14\nSAVEAREA DC    18F'0'\nHOLD     DS    CL4\nNOHIT    DC    CL8'NOHIT '\nDCBIN    DCB   DDNAME=INP2,DSORG=DA,MACRF=RCK,RECFM=F\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RRINP2IS": {"ttr": 1287, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x00\\x890o\\x00\\x890o\\x14\\x18\\x00\\x1f\\x00\\x1f\\x00\\x00\\xe2\\xd7\\xc5\\xd5\\xc3\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-02T00:00:00", "modifydate": "1989-11-02T14:18:44", "lines": 31, "newlines": 31, "modlines": 0, "user": "SPENCER"}, "text": "RRINP2IS  CSECT\n*  THIS  MODULE  IS CALLED BY THE GENERATOR PROGRAM\n*         TO HANDLE READ INP1  / ONLY DIFF BETWEEN INP1 2 & 3 ARE\n*          REG USED FOR REC AREA AND DDNAME IN DCB\n         SAVE  (2,12),T,*\n         BALR  12,0\n         USING *,12\n         ST    13,SAVEAREA+4\n         LR    4,13\n         LA    13,SAVEAREA\n         ST    13,8(4)\nML01     B     ML03             1ST SWITCH\nML02     GET   DCBIN,RECAREA\n         LA    8,RECAREA      LOAD 7 WITH REC AREA ADR\nML02A    L     13,SAVEAREA+4  RELOAD HIS REGS\n         LM    14,7,12(13)    BYPASS LOADING 8  SINCE IT IS\n         LM    9,12,56(13)     ASSIGN TO HIS INP1 REC AREA\n         LA    15,0(0,0)      SET RETURN CODE TO 0\n         LA    14,12(0,14)    BUMP 14 BY 12 TO RETURN TO ADD TO REC CT\n         BR    14\nML03     OPEN  (DCBIN)\n         MVI   ML01+1,X'00'   NOP 1ST TIME SWITCH\n         B     ML02A\nML04     L     13,SAVEAREA+4\n         LM    14,12,12(13)\n         LA    15,0(0,0)\n         BR    14\nSAVEAREA DC    18F'0'\nRECAREA  DS    CL900\nDCBIN    DCB   DDNAME=INP2,DSORG=IS,MACRF=GM,EODAD=ML04\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RRINP3DI": {"ttr": 1289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x00\\x890o\\x00\\x890o\\x14\\x18\\x00\"\\x00\"\\x00\\x00\\xe2\\xd7\\xc5\\xd5\\xc3\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-02T00:00:00", "modifydate": "1989-11-02T14:18:44", "lines": 34, "newlines": 34, "modlines": 0, "user": "SPENCER"}, "text": "RRIN1DIN  CSECT\n*  THIS MODULE IS CALLED BY GEN PROGRAM\n*   TO READ DA DATA SETS / TYPE = DI  (DATA AND KEY)\n         SAVE  (2,12),T,*\n         BALR  11,0\n         USING *,11\n         ST    13,SAVEAREA+4\n         LR    4,13\n         LA    13,SAVEAREA\n         ST         13,8(4)\nML01     B     ML03         1ST TIME SWITCH\n         MVC   DECBIN+29(1),4(14)   PUT APPRO REG FOR BLK ADR\nML02     READ  DECBIN,DI,DCBIN,*+12,'S','S',(7)\n         WAIT  ECB=DECBIN\n         TM    DECBIN+1,X'04'    Q. EOD\n         BNZ   ML05                  YES\n         CHECK DECBIN                NO\nML02A    L     13,SAVEAREA+4   *RESTORE\n         LM    14,12,12(13)    * HIS REGISTERS\n         LA    14,12(0,14)     * BUMP 14 TO BYPASS PARMS\n         BR    14             *       USER\nML03     MVC   DECBIN+12,0(14)     MOVE IN AREA ADR\n         OPEN  (DCBIN)\n         MVI   ML01+1,X'00'      NOP  1ST TIME SWITCH\n         B     ML02A\n* EOF EXIT\nML05     L     13,SAVEAREA+4\n         LM    14,12,12(13)\n         LA    15,0(0,0)\n         BR    14\nSAVEAREA DC    18F'0'\nRECAREA  DS    CL900\nDCBIN    DCB   DDNAME=INP3,DSORG=DA,MACRF=RCI,RECFM=F\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RRINP3DK": {"ttr": 1291, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x00\\x890o\\x00\\x890o\\x14\\x18\\x00/\\x00/\\x00\\x00\\xe2\\xd7\\xc5\\xd5\\xc3\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-02T00:00:00", "modifydate": "1989-11-02T14:18:44", "lines": 47, "newlines": 47, "modlines": 0, "user": "SPENCER"}, "text": "RRIN1DKN  CSECT\n*  THIS MODULE IS CALLED BY GEN PROGRAM\n*   TO READ DA DATA SETS / TYPE = DI  (DATA AND KEY)\n         SAVE  (2,12),T,*\n         BALR  11,0\n         USING *,11\n         ST    13,SAVEAREA+4\n         LR    4,13\n         LA    13,SAVEAREA\n         ST         13,8(4)\nML01     B     ML03         1ST TIME SWITCH\n         MVC   DECBIN+29(1),4(14)   PUT APPRO REG FOR BLK ADR\n         MVC   ML03A+2(2),6(14)  * MOVE KEY ADR TO NEXT INST\nML03A    LA    14,*+0            * CONV BASE/DISP TO ACTUAL ADR\n         ST    14,DECBIN+20   * STORE ACTUAL ADR IN READ MACRO\n         LA    13,SAVEAREA       * POINT 13 BACK TO MY SAVEAREA\nML02     READ  DECBIN,DK,DCBIN,*+12,'S',*+20,(7)\n         WAIT  ECB=DECBIN\n         TM    DECBIN+1,X'80'   Q.  RECORD NOT FOUND\n         BZ    CHECK                NO\n         L     6,HOLD\n         MVC   0(6,6),NOHIT         MOVE 'NOHIT' TO AREA\n         B     ML02A                GO BACK\nCHECK    CHECK DECBIN                NO\nML02A    L     13,SAVEAREA+4  * RELOAD\n         LM    14,12,12(13)     *  AND\n         LA    15,0(0,0)      *     RETURN\n         LA    14,12(0,14)    *      TO\n         BR    14             *       USER\nML03     MVC   DECBIN+12(4),0(14)  MOVE AREA ADR TO READ INST\n         MVC   ML04+2(2),4(14)   MOVE REC AREA ADR TO LOAD ADR INST.\n         MVC   HOLD,DECBIN+12\nML04     LA    2,*+0             CONVERT TO ACT ADR.\n         ST    2,DECBIN+24     STORE BLK ADR FOR READ\n         OPEN  (DCBIN)\n         MVI   ML01+1,X'00'      NOP  1ST TIME SWITCH\n         B     ML02A\n* EOF EXIT\nML05     L     13,SAVEAREA+4\n         LM    14,12,12(13)\n         LA    15,0(0,0)\n         BR    14\nSAVEAREA DC    18F'0'\nHOLD     DS    CL4\nNOHIT    DC    CL8'NOHIT '\nDCBIN    DCB   DDNAME=INP3,DSORG=DA,MACRF=RCK,RECFM=F\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RRINP3IS": {"ttr": 1293, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x00\\x890o\\x00\\x890o\\x14\\x18\\x00\\x1f\\x00\\x1f\\x00\\x00\\xe2\\xd7\\xc5\\xd5\\xc3\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-02T00:00:00", "modifydate": "1989-11-02T14:18:44", "lines": 31, "newlines": 31, "modlines": 0, "user": "SPENCER"}, "text": "RRINP3IS  CSECT\n*  THIS  MODULE  IS CALLED BY THE GENERATOR PROGRAM\n*         TO HANDLE READ INP1  / ONLY DIFF BETWEEN INP1 2 & 3 ARE\n*          REG USED FOR REC AREA AND DDNAME IN DCB\n         SAVE  (2,12),T,*\n         BALR  12,0\n         USING *,12\n         ST    13,SAVEAREA+4\n         LR    4,13\n         LA    13,SAVEAREA\n         ST    13,8(4)\nML01     B     ML03             1ST SWITCH\nML02     GET   DCBIN,RECAREA\n         LA    9,RECAREA      LOAD 7 WITH REC AREA ADR\nML02A    L     13,SAVEAREA+4  RELOAD HIS REGS\n         LM    14,8,12(13)    BYPASS LOADING 9  SINCE IT IS\n         LM    10,12,60(13)    ASSIGN TO HIS INP1 REC AREA\n         LA    15,0(0,0)      SET RETURN CODE TO 0\n         LA    14,12(0,14)    BUMP 14 BY 12 TO RETURN TO ADD TO REC CT\n         BR    14\nML03     OPEN  (DCBIN)\n         MVI   ML01+1,X'00'   NOP 1ST TIME SWITCH\n         B     ML02A\nML04     L     13,SAVEAREA+4\n         LM    14,12,12(13)\n         LA    15,0(0,0)\n         BR    14\nSAVEAREA DC    18F'0'\nRECAREA  DS    CL900\nDCBIN    DCB   DDNAME=INP3,DSORG=IS,MACRF=GM,EODAD=ML04\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RRIN1ISR": {"ttr": 1295, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x00\\x890o\\x00\\x890o\\x14\\x18\\x00+\\x00+\\x00\\x00\\xe2\\xd7\\xc5\\xd5\\xc3\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-02T00:00:00", "modifydate": "1989-11-02T14:18:44", "lines": 43, "newlines": 43, "modlines": 0, "user": "SPENCER"}, "text": "RRIN1ISR  CSECT\n*  THIS  MODULE  IS CALLED BY THE GENERATOR PROGRAM\n*                TO HANDLE READ OF ISAM DATA SETS  (BISAM)\n         SAVE  (2,12),T,*\n         BALR  11,0\n         USING *,11\n         ST    13,SAVEAREA+4\n         LR    4,13\n         LA    13,SAVEAREA\n         ST    13,8(4)\nML01     B     ML03             1ST SWITCH\n         L     13,SAVEAREA+4      *\n         L     14,12(13)          *\n         LA    14,6(0,14)         * POINT 14 TO KEY ADR (BASE DISP)\n         MVC   ML03A+2(2),0(14)   * MOVE KEY ADR TO NEXT INST\nML03A    LA    14,*+0             * CONV BASE DISP TO ACTUAL\n         ST    14,ML02+24         * STORE ACTUAL KEY ADR IN READ MACRO\n         LA    13,SAVEAREA        * POIMT 13 BACK TO MY SAVEAREA\nML02     READ  DECBIN,K,DCBIN,'S','S',*+0\n         WAIT  ECB=DECBIN\n         TM    DECBIN+24,X'80'     Q.  REC NOT FOUND\n         BZ    CHECK                  NO - ISSUE CHECK\n         LA    7,NOHIT                LOAD 7 WITH ADR OF NO HIT MSG\n         B     ML02A                  RETURN TO PROG\nCHECK    CHECK DECBIN,DSORG=IS\n         L     7,DECBIN+16         POINT REG 7 TO RECORD\nML02A    L     13,SAVEAREA+4  RELOAD HIS REGS\n         LM    14,6,12(13)    BYPASS LOADING 7  SINCE IT IS\n         LM    8,12,52(13)     ASSIGN TO HIS INP1 REC AREA\n         LA    15,0(0,0)      SET RETURN CODE TO 0\n         LA    14,12(0,14)    BUMP 14 BY 12 TO RETURN TO ADD TO REC CT\n         BR    14\nML03     OPEN  (DCBIN)\n         MVI   ML01+1,X'00'   NOP 1ST TIME SWITCH\n         B     ML02A\nML04     L     13,SAVEAREA+4\n         LM    14,12,12(13)\n         LA    15,0(0,0)\n         BR    14\nSAVEAREA DC    18F'0'\nDCBIN    DCB   DDNAME=INP1,DSORG=IS,MACRF=RSC,EODAD=ML04\nNOHIT    DC    CL6'NOHIT '\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RRIN2ISR": {"ttr": 1297, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x00\\x890o\\x00\\x890o\\x14\\x18\\x00+\\x00+\\x00\\x00\\xe2\\xd7\\xc5\\xd5\\xc3\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-02T00:00:00", "modifydate": "1989-11-02T14:18:44", "lines": 43, "newlines": 43, "modlines": 0, "user": "SPENCER"}, "text": "RRIN2ISR  CSECT\n*  THIS  MODULE  IS CALLED BY THE GENERATOR PROGRAM\n*                TO HANDLE READ OF ISAM DATA SETS  (BISAM)\n         SAVE  (2,12),T,*\n         BALR  11,0\n         USING *,11\n         ST    13,SAVEAREA+4\n         LR    4,13\n         LA    13,SAVEAREA\n         ST    13,8(4)\nML01     B     ML03             1ST SWITCH\n         L     13,SAVEAREA+4      *\n         L     14,12(13)          *\n         LA    14,6(0,14)         * POINT 14 TO KEY ADR (BASE DISP)\n         MVC   ML03A+2(2),0(14)   * MOVE KEY ADR TO NEXT INST\nML03A    LA    14,*+0             * CONV BASE DISP TO ACTUAL\n         ST    14,ML02+24         * STORE ACTUAL KEY ADR IN READ MACRO\n         LA    13,SAVEAREA        * POIMT 13 BACK TO MY SAVEAREA\nML02     READ  DECBIN,K,DCBIN,'S','S',*+0\n         WAIT  ECB=DECBIN\n         TM    DECBIN+24,X'80'     Q.  REC NOT FOUND\n         BZ    CHECK                  NO - ISSUE CHECK\n         LA    8,NOHIT                LOAD 7 WITH ADR OF NO HIT MSG\n         B     ML02A                  RETURN TO PROG\nCHECK    CHECK DECBIN,DSORG=IS\n         L     8,DECBIN+16         POINT REG 8 TO RECORD\nML02A    L     13,SAVEAREA+4  RELOAD HIS REGS\n         LM    14,7,12(13)    BYPASS LOADING 7  SINCE IT IS\n         LM    9,12,56(13)     ASSIGN TO HIS INP1 REC AREA\n         LA    15,0(0,0)      SET RETURN CODE TO 0\n         LA    14,12(0,14)    BUMP 14 BY 12 TO RETURN TO ADD TO REC CT\n         BR    14\nML03     OPEN  (DCBIN)\n         MVI   ML01+1,X'00'   NOP 1ST TIME SWITCH\n         B     ML02A\nML04     L     13,SAVEAREA+4\n         LM    14,12,12(13)\n         LA    15,0(0,0)\n         BR    14\nSAVEAREA DC    18F'0'\nDCBIN    DCB   DDNAME=INP2,DSORG=IS,MACRF=RSC,EODAD=ML04\nNOHIT    DC    CL6'NOHIT '\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RRIN3ISR": {"ttr": 1299, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x00\\x890o\\x00\\x890o\\x14\\x18\\x00+\\x00+\\x00\\x00\\xe2\\xd7\\xc5\\xd5\\xc3\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-02T00:00:00", "modifydate": "1989-11-02T14:18:44", "lines": 43, "newlines": 43, "modlines": 0, "user": "SPENCER"}, "text": "RRIN3ISR  CSECT\n*  THIS  MODULE  IS CALLED BY THE GENERATOR PROGRAM\n*                TO HANDLE READ OF ISAM DATA SETS  (BISAM)\n         SAVE  (2,12),T,*\n         BALR  11,0\n         USING *,11\n         ST    13,SAVEAREA+4\n         LR    4,13\n         LA    13,SAVEAREA\n         ST    13,8(4)\nML01     B     ML03             1ST SWITCH\n         L     13,SAVEAREA+4      *\n         L     14,12(13)          *\n         LA    14,6(0,14)         * POINT 14 TO KEY ADR (BASE DISP)\n         MVC   ML03A+2(2),0(14)   * MOVE KEY ADR TO NEXT INST\nML03A    LA    14,*+0             * CONV BASE DISP TO ACTUAL\n         ST    14,ML02+24         * STORE ACTUAL KEY ADR IN READ MACRO\n         LA    13,SAVEAREA        * POIMT 13 BACK TO MY SAVEAREA\nML02     READ  DECBIN,K,DCBIN,'S','S',*+0\n         WAIT  ECB=DECBIN\n         TM    DECBIN+24,X'80'     Q.  REC NOT FOUND\n         BZ    CHECK                  NO - ISSUE CHECK\n         LA    9,NOHIT                LOAD 7 WITH ADR OF NO HIT MSG\n         B     ML02A                  RETURN TO PROG\nCHECK    CHECK DECBIN,DSORG=IS\n         L     9,DECBIN+16         POINT REG 9 TO RECORD\nML02A    L     13,SAVEAREA+4  RELOAD HIS REGS\n         LM    14,8,12(13)    BYPASS LOADING 8  SINCE IT IS\n         LM    10,12,60(13)    ASSIGN TO HIS INP1 REC AREA\n         LA    15,0(0,0)      SET RETURN CODE TO 0\n         LA    14,12(0,14)    BUMP 14 BY 12 TO RETURN TO ADD TO REC CT\n         BR    14\nML03     OPEN  (DCBIN)\n         MVI   ML01+1,X'00'   NOP 1ST TIME SWITCH\n         B     ML02A\nML04     L     13,SAVEAREA+4\n         LM    14,12,12(13)\n         LA    15,0(0,0)\n         BR    14\nSAVEAREA DC    18F'0'\nDCBIN    DCB   DDNAME=INP3,DSORG=IS,MACRF=RSC,EODAD=ML04\nNOHIT    DC    CL6'NOHIT '\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RROT1ISM": {"ttr": 1301, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x00\\x890o\\x00\\x890o\\x14\\x18\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xd7\\xc5\\xd5\\xc3\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-02T00:00:00", "modifydate": "1989-11-02T14:18:44", "lines": 26, "newlines": 26, "modlines": 0, "user": "SPENCER"}, "text": "OUT1IS    CSECT\n*  THIS IS A MOD THAT IS LOADED BY THE PROGRAM GENERATOR\n*   TO HANDLE  THE WRITES TO OUT1  REC AREA = REG 10\n*\n         SAVE  (2,12),T,*\n         BALR  12,0\n         USING *,12\n         ST    13,SAVEAREA+4\n         LA    13,SAVEAREA\nML01     B     ML03               SW TO BRANCH TO OPEN FIRST TIME\nML02     PUT   DCBOT,*+0         WRITE\nML02A    L     13,SAVEAREA+4      RELOAD HIS\n         LM    14,12,12(13)             REGS\n         LA    15,0(0,0)          SET RETURN CODE TO 0\n         LA    14,12(0,14)        BUMP 14 BY 12 TO RETURN TO ADD\n         BR    14\nML03     OPEN  (DCBOT,(OUTPUT))\n         MVI   ML01+1,X'00'       NOP ML01\n         LA    11,4(0,14)        14+4 POINTS TO ADR OF RECORD AREA\n         MVC   ML02+6(2),0(11)   PUT REC AREA ADR IN PUT MACRO\n         B     ML02A\nSAVEAREA DC    18F'0'\n         DC    CL2'  '\nRECAREA  DS    CL900\nDCBOT    DCB   DDNAME=OUT1,DSORG=IS,MACRF=PM\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RROT2ISM": {"ttr": 1303, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x00\\x890o\\x00\\x890o\\x14\\x18\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xd7\\xc5\\xd5\\xc3\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-02T00:00:00", "modifydate": "1989-11-02T14:18:44", "lines": 26, "newlines": 26, "modlines": 0, "user": "SPENCER"}, "text": "OUT1IS    CSECT\n*  THIS IS A MOD THAT IS LOADED BY THE PROGRAM GENERATOR\n*   TO HANDLE  THE WRITES TO OUT1  REC AREA = REG 10\n*\n         SAVE  (2,12),T,*\n         BALR  12,0\n         USING *,12\n         ST    13,SAVEAREA+4\n         LA    13,SAVEAREA\nML01     B     ML03               SW TO BRANCH TO OPEN FIRST TIME\nML02     PUT   DCBOT,*+0         WRITE\nML02A    L     13,SAVEAREA+4      RELOAD HIS\n         LM    14,12,12(13)             REGS\n         LA    15,0(0,0)          SET RETURN CODE TO 0\n         LA    14,12(0,14)        BUMP 14 BY 12 TO RETURN TO ADD\n         BR    14\nML03     OPEN  (DCBOT,(OUTPUT))\n         MVI   ML01+1,X'00'       NOP ML01\n         LA    11,4(0,14)        14+4 POINTS TO ADR OF RECORD AREA\n         MVC   ML02+6(2),0(11)   PUT REC AREA ADR IN PUT MACRO\n         B     ML02A\nSAVEAREA DC    18F'0'\n         DC    CL2'  '\nRECAREA  DS    CL900\nDCBOT    DCB   DDNAME=OUT2,DSORG=IS,MACRF=PM\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RROT3ISM": {"ttr": 1305, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x00\\x890o\\x00\\x890o\\x14\\x18\\x00\\x19\\x00\\x19\\x00\\x00\\xe2\\xd7\\xc5\\xd5\\xc3\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-02T00:00:00", "modifydate": "1989-11-02T14:18:44", "lines": 25, "newlines": 25, "modlines": 0, "user": "SPENCER"}, "text": "OUT1MOD   CSECT\n*  THIS IS A MOD THAT IS LOADED BY THE PROGRAM GENERATOR\n*   TO HANDLE  THE WRITES TO OUT1  REC AREA = REG 10\n*\n         SAVE  (2,12),T,*\n         BALR  12,0\n         USING *,12\n         ST    13,SAVEAREA+4\n         LA    13,SAVEAREA\nML01     B     ML03               SW TO BRANCH TO OPEN FIRST TIME\nML02     PUT   DCBOT,*+0         WRITE\nML02A    L     13,SAVEAREA+4      RELOAD HIS\n         LM    14,12,12(13)             REGS\n         LA    15,0(0,0)          SET RETURN CODE TO 0\n         LA    14,12(0,14)        BUMP 14 BY 12 TO RETURN TO ADD\n         BR    14\nML03     OPEN  (DCBOT,(OUTPUT))\n         MVI   ML01+1,X'00'       NOP ML01\n         LA    11,4(0,14)        14+4 POINTS TO ADR OF RECORD AREA\n         MVC   ML02+6(2),0(11)   PUT REC AREA ADR IN PUT MACRO\n         B     ML02A\nSAVEAREA DC    18F'0'\n         DC    CL2'  '\nDCBOT    DCB   DDNAME=OUT3,DSORG=IS,MACRF=PM\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RROUT1DA": {"ttr": 1307, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x00\\x890o\\x00\\x890o\\x14\\x18\\x00\\x19\\x00\\x19\\x00\\x00\\xe2\\xd7\\xc5\\xd5\\xc3\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-02T00:00:00", "modifydate": "1989-11-02T14:18:44", "lines": 25, "newlines": 25, "modlines": 0, "user": "SPENCER"}, "text": "OUT1DA    CSECT\n*  THIS IS A MOD THAT IS LOADED BY THE PROGRAM GENERATOR\n*   TO HANDLE  THE WRITES TO OUT1  REC AREA = REG 10\n*\n         SAVE  (2,12),T,*\n         BALR  11,0\n         USING *,11\n         ST    13,SAVEAREA+4\n         LA    13,SAVEAREA\nML01     B     ML03               SW TO BRANCH TO OPEN FIRST TIME\nML02     WRITE DECBOUT,SF,DCBOUT,*+0,'S'\n         CHECK DECBOUT\nML02A    L     13,SAVEAREA+4      RELOAD HIS\n         LM    14,12,12(13)             REGS\n         LA    15,0(0,0)          SET RETURN CODE TO 0\n         LA    14,12(0,14)        BUMP 14 BY 12 TO RETURN TO ADD\n         BR    14\nML03     OPEN  (DCBOUT,(OUTPUT))\n         MVI   ML01+1,X'00'       NOP ML01\n         MVC   ML02+16(4),0(14)  PUT AREA ARD IN WRITEH MACRO\n         B     ML02A\nSAVEAREA DC    18F'0'\nDCBOUT   DCB   DDNAME=OUT1,DSORG=PS,MACRF=(WL),DEVD=DA\n         DC    CL2'  '\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RROUT1MD": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x00\\x890o\\x00\\x890o\\x14\\x18\\x00\\x19\\x00\\x19\\x00\\x00\\xe2\\xd7\\xc5\\xd5\\xc3\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-02T00:00:00", "modifydate": "1989-11-02T14:18:44", "lines": 25, "newlines": 25, "modlines": 0, "user": "SPENCER"}, "text": "OUT1MOD   CSECT\n*  THIS IS A MOD THAT IS LOADED BY THE PROGRAM GENERATOR\n*   TO HANDLE  THE WRITES TO OUT1  REC AREA = REG 10\n*\n         SAVE  (2,12),T,*\n         BALR  12,0\n         USING *,12\n         ST    13,SAVEAREA+4\n         LA    13,SAVEAREA\nML01     B     ML03               SW TO BRANCH TO OPEN FIRST TIME\nML02     PUT   DCBOT,*+0         WRITE\nML02A    L     13,SAVEAREA+4      RELOAD HIS\n         LM    14,12,12(13)             REGS\n         LA    15,0(0,0)          SET RETURN CODE TO 0\n         LA    14,12(0,14)        BUMP 14 BY 12 TO RETURN TO ADD\n         BR    14\nML03     OPEN  (DCBOT,(OUTPUT))\n         MVI   ML01+1,X'00'       NOP ML01\n         LA    11,4(0,14)        14+4 POINTS TO ADR OF RECORD AREA\n         MVC   ML02+6(2),0(11)   PUT REC AREA ADR IN PUT MACRO\n         B     ML02A\nSAVEAREA DC    18F'0'\n         DC    CL2'  '\nDCBOT    DCB   DDNAME=OUT1,DSORG=PS,MACRF=PM\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RROUT2DA": {"ttr": 1539, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x00\\x890o\\x00\\x890o\\x14\\x18\\x00\\x19\\x00\\x19\\x00\\x00\\xe2\\xd7\\xc5\\xd5\\xc3\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-02T00:00:00", "modifydate": "1989-11-02T14:18:44", "lines": 25, "newlines": 25, "modlines": 0, "user": "SPENCER"}, "text": "OUT1DA    CSECT\n*  THIS IS A MOD THAT IS LOADED BY THE PROGRAM GENERATOR\n*   TO HANDLE  THE WRITES TO OUT1  REC AREA = REG 10\n*\n         SAVE  (2,12),T,*\n         BALR  11,0\n         USING *,11\n         ST    13,SAVEAREA+4\n         LA    13,SAVEAREA\nML01     B     ML03               SW TO BRANCH TO OPEN FIRST TIME\nML02     WRITE DECBOUT,SF,DCBOUT,*+0,'S'\n         CHECK DECBOUT\nML02A    L     13,SAVEAREA+4      RELOAD HIS\n         LM    14,12,12(13)             REGS\n         LA    15,0(0,0)          SET RETURN CODE TO 0\n         LA    14,12(0,14)        BUMP 14 BY 12 TO RETURN TO ADD\n         BR    14\nML03     OPEN  (DCBOUT,(OUTPUT))\n         MVI   ML01+1,X'00'       NOP ML01\n         MVC   ML02+16(4),0(14)  PUT AREA ARD IN WRITEH MACRO\n         B     ML02A\nSAVEAREA DC    18F'0'\nDCBOUT   DCB   DDNAME=OUT2,DSORG=PS,MACRF=(WL),DEVD=DA\n         DC    CL2'  '\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RROUT2MD": {"ttr": 1541, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x00\\x890o\\x00\\x890o\\x14\\x18\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xd7\\xc5\\xd5\\xc3\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-02T00:00:00", "modifydate": "1989-11-02T14:18:44", "lines": 26, "newlines": 26, "modlines": 0, "user": "SPENCER"}, "text": "OUT1IS    CSECT\n*  THIS IS A MOD THAT IS LOADED BY THE PROGRAM GENERATOR\n*   TO HANDLE  THE WRITES TO OUT1  REC AREA = REG 10\n*\n         SAVE  (2,12),T,*\n         BALR  12,0\n         USING *,12\n         ST    13,SAVEAREA+4\n         LA    13,SAVEAREA\nML01     B     ML03               SW TO BRANCH TO OPEN FIRST TIME\nML02     PUT   DCBOT,*+0         WRITE\nML02A    L     13,SAVEAREA+4      RELOAD HIS\n         LM    14,12,12(13)             REGS\n         LA    15,0(0,0)          SET RETURN CODE TO 0\n         LA    14,12(0,14)        BUMP 14 BY 12 TO RETURN TO ADD\n         BR    14\nML03     OPEN  (DCBOT,(OUTPUT))\n         MVI   ML01+1,X'00'       NOP ML01\n         LA    11,4(0,14)        14+4 POINTS TO ADR OF RECORD AREA\n         MVC   ML02+6(2),0(11)   PUT REC AREA ADR IN PUT MACRO\n         B     ML02A\nSAVEAREA DC    18F'0'\n         DC    CL2'  '\nRECAREA  DS    CL900\nDCBOT    DCB   DDNAME=OUT2,DSORG=PS,MACRF=PM\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RROUT3DA": {"ttr": 1543, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x00\\x890o\\x00\\x890o\\x14\\x18\\x00\\x19\\x00\\x19\\x00\\x00\\xe2\\xd7\\xc5\\xd5\\xc3\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-02T00:00:00", "modifydate": "1989-11-02T14:18:44", "lines": 25, "newlines": 25, "modlines": 0, "user": "SPENCER"}, "text": "OUT1DA    CSECT\n*  THIS IS A MOD THAT IS LOADED BY THE PROGRAM GENERATOR\n*   TO HANDLE  THE WRITES TO OUT1  REC AREA = REG 10\n*\n         SAVE  (2,12),T,*\n         BALR  11,0\n         USING *,11\n         ST    13,SAVEAREA+4\n         LA    13,SAVEAREA\nML01     B     ML03               SW TO BRANCH TO OPEN FIRST TIME\nML02     WRITE DECBOUT,SF,DCBOUT,*+0,'S'\n         CHECK DECBOUT\nML02A    L     13,SAVEAREA+4      RELOAD HIS\n         LM    14,12,12(13)             REGS\n         LA    15,0(0,0)          SET RETURN CODE TO 0\n         LA    14,12(0,14)        BUMP 14 BY 12 TO RETURN TO ADD\n         BR    14\nML03     OPEN  (DCBOUT,(OUTPUT))\n         MVI   ML01+1,X'00'       NOP ML01\n         MVC   ML02+16(4),0(14)  PUT AREA ARD IN WRITEH MACRO\n         B     ML02A\nSAVEAREA DC    18F'0'\nDCBOUT   DCB   DDNAME=OUT3,DSORG=PS,MACRF=(WL),DEVD=DA\n         DC    CL2'  '\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RROUT3MD": {"ttr": 1545, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x00\\x890o\\x00\\x890o\\x14\\x18\\x00\\x19\\x00\\x19\\x00\\x00\\xe2\\xd7\\xc5\\xd5\\xc3\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-02T00:00:00", "modifydate": "1989-11-02T14:18:44", "lines": 25, "newlines": 25, "modlines": 0, "user": "SPENCER"}, "text": "OUT1MOD   CSECT\n*  THIS IS A MOD THAT IS LOADED BY THE PROGRAM GENERATOR\n*   TO HANDLE  THE WRITES TO OUT1  REC AREA = REG 10\n*\n         SAVE  (2,12),T,*\n         BALR  12,0\n         USING *,12\n         ST    13,SAVEAREA+4\n         LA    13,SAVEAREA\nML01     B     ML03               SW TO BRANCH TO OPEN FIRST TIME\nML02     PUT   DCBOT,*+0         WRITE\nML02A    L     13,SAVEAREA+4      RELOAD HIS\n         LM    14,12,12(13)             REGS\n         LA    15,0(0,0)          SET RETURN CODE TO 0\n         LA    14,12(0,14)        BUMP 14 BY 12 TO RETURN TO ADD\n         BR    14\nML03     OPEN  (DCBOT,(OUTPUT))\n         MVI   ML01+1,X'00'       NOP ML01\n         LA    11,4(0,14)        14+4 POINTS TO ADR OF RECORD AREA\n         MVC   ML02+6(2),0(11)   PUT REC AREA ADR IN PUT MACRO\n         B     ML02A\nSAVEAREA DC    18F'0'\n         DC    CL2'  '\nDCBOT    DCB   DDNAME=OUT3,DSORG=PS,MACRF=PM\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RRPRTMOT": {"ttr": 1547, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x00\\x890o\\x00\\x890o\\x14\\x18\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xd7\\xc5\\xd5\\xc3\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-02T00:00:00", "modifydate": "1989-11-02T14:18:44", "lines": 26, "newlines": 26, "modlines": 0, "user": "SPENCER"}, "text": "RRPRTMOD  CSECT\n* THIS MOD IS USED FOR PRINTING WHEN THE PRINT INST\n*    IS USED IN THE PROGRAM GENERATOR\n*\n         SAVE  (2,12),T,*\n         BALR  11,0\n         USING *,11\n         ST    13,SAVEAREA+4\n         LA    13,SAVEAREA\nML01     B     ML03           SWITCH TO OPEN 1 TIME\nML02     PUT   DCBPRT,*+0    B-ADR DUMMY/FILLED IN BEFORE OPEN\n         L     13,SAVEAREA+4\n         LM    14,12,12(13)    RELOAD HIS REGS\n         LA    15,0(0,0)       SET RETURN CODE TO 0\n         LA    14,2(0,14)      BUMP 14 BY 2 TO RETURN TO ADD INST\n         BR    14\nML03     MVC   ML02+6(2),0(14) R14 POINT TO PRT AREA ADR IN-LINE\n         OPEN  (DCBPRT,(OUTPUT))\n         MVI   ML01+1,X'00'      NOP BRANCH TO OPEN\n         MVC   ML04+2(2),0(14)      PUT PRT REC ADR IN NEXT INST\nML04     MVI   *+0,X'89'      SET TO DO HSK PAGE CHG\n         B     ML02\nDCBPRT   DCB   DDNAME=PRINT,DSORG=PS,MACRF=PM,RECFM=FM,                C\n               LRECL=133,BLKSIZE=133\nSAVEAREA DC    18F'0'\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT182/CBT.V500.FILE182.PDS/RRGEN.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT182/CBT.V500.FILE182.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}