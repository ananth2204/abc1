{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011252000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 7877324, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 46, "INMDSNAM": "CBT.V500.FILE120.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 7877324, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 7877324, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE120.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00~\\x04'", "DS1TRBAL": "b'\\xac\\x86'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x00\\xbf\\x00\\x07\\x00\\xc7\\x00\\r\\x00\\x7f'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04c\\x00(\\x01 \\x06o\\x01 \\x06o\\x10C\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf9@@@'", "ispf": {"version": "04.99", "flags": 0, "createdate": "2020-03-06T00:00:00", "modifydate": "2020-03-06T10:43:28", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-499"}, "text": "REGULAR CBT TAPE - VERSION 499    FILE:  120\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT499.FILE120\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 241 MEMBERS COUNTED; CUMULATIVE SIZE IS 72,933 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   03/06/20    10:43:27    UTC-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$CPYRT": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\t\\x00\\x93!\\x0f\\x01\\x19\\x14O\\x14B\\x00\\t\\x00\\x05\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "2019-05-24T14:42:09", "lines": 9, "newlines": 5, "modlines": 0, "user": "SBGOLOB"}, "text": " COPYRIGHT (C) 1993 BY TEI INCORPORATED.\n\n THIS NOTICE APPLIES TO ALL PUBLISHED MATERIAL IN THIS FILE EXCEPT THE\nCONTENTS OF THE MEMBER $$INTRO, INDEXES, AND ANY MEMBER EXPLICITLY\nSPECIFIED THAT IT DOES NOT BELONG TO NASPA.  PERMISSION IS GRANTED TO\nMAKE ANY NUMBER OF MACHINE-READABLE COPIES OF THIS MATERIAL.\n\n Members whose names begin with \"BM\" do not belong to NaSPA or TEI Inc.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$$INDEX": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00H\\x00\\x93!\\x1f\\x01\\x19\\x14O\\x14@\\x00 \\x00\\x0c\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1993-07-30T00:00:00", "modifydate": "2019-05-24T14:40:48", "lines": 32, "newlines": 12, "modlines": 0, "user": "SBGOLOB"}, "text": "The numbering scheme of the members of this file is very simple.\n\n  All articles originally started with the letters:   CL\n   (which stands for \"column\")\n\n  The year of publication is:  89, 90, and the like.\n  The sequence of publication is numeric, for sorting purposes,\n   and then alphabetic, for easier identification.\n\n  After the year 2000, the articles begin with CM, so they will sort\n   later than the year 19nn articles.\n\n  Thus, CL8901JA is from the January 1989 issue of \"Technical Support\".\n\n  And, CM0001JA is from the January 2000 issue of \"Technical Support\".\n\n  One article I wrote was rejected by the magazine, and it belongs\n   to me.  It is included as member BM0009SE.  If you'll look in\n   your September 2000 issue of Technical Support, I don't have a\n   column there.  The reason was that (at the time), NaSPA was\n   supporting other technical conferences besides SHARE, and they felt\n   that if they published this article about SHARE, the other\n   conferences would demand equal time.  (I respect their decision.)\n\n  After this period, I wrote a few other articles that were not printed\n   by \"Technical Support\" magazine.  These are copyrighted by me (feel\n   free to use them), and the member names are also prefixed with \"BM\".\n\n  ENJOY THEM ALL.....!!!!!!\n\n  Hope this helps.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$$PERMT": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x93!\\x0f\\x00\\x93!\\x1f\\t\\x15\\x00\\x02\\x00\\x02\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "1993-07-30T09:15:00", "lines": 2, "newlines": 2, "modlines": 0, "user": "SBGCSC"}, "text": "PERMISSION HAS BEEN GRANTED BY TEI INC. TO INCLUDE THIS MATERIAL ON\nTHE CBT MVS UTILITIES TAPE.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$ABOUT": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x01\\x00'\\x8f\\x01\\x19\\x14O\\x143\\x00\\x0b\\x00\\x0b\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-10-04T00:00:00", "modifydate": "2019-05-24T14:33:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "SBGOLOB"}, "text": "MVS Tools and Tricks of the Trade\n\n     The focus of this column is to provide MVS practitioners with\nuseful tools and ideas, to expand their horizons within this trade.\nThe column emphasizes \"a different view\" of MVS System Programming.\nOften, \"IBM says you can't\" do something, and you really can, using\navailable tools, which are often free for the downloading and\ninstallation.  Each month's column provides information that is\nuseful to both newbies and very experienced hands with decades of\nexperience.  Of course, everyone in-between is also included.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$DIRECT": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00\\x16\\x00\\x93!\\x8f\\x01 \\x06O\\x150\\x00\\xf5\\x00=\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "1993-08-06T00:00:00", "modifydate": "2020-03-04T15:30:16", "lines": 245, "newlines": 61, "modlines": 0, "user": "SBGOLOB"}, "text": "            ONE-LINE SUBJECT MATTER INDEX TO THE COLUMNS\n                    (Topics That Were Covered)\n\n     $$$CPYRT  :  COPYRIGHT NOTICE\n     $$$INDEX  :  MEMBER NAMING SCHEME FOR THIS FILE\n     $$$PERMT  :  PERMISSION TO DISTRIBUTE THIS MATERIAL\n     $$DIRECT  :  ONE-LINE SUBJECT MATTER INDEX TO THE COLUMNS\n     $$INTRO   :  AUTHOR'S PREFACE AND \"QUICK INTRO\"\n     -------------------------------------------------------------------\n     BM0009SE  :  The Joy of \"SHARE\" (separate article - not published)\n     BM0806JN  :  TSO/E Control Blocks, and more\n     BM0901JA  :  TSO Authorization Tables\n     BM0902FE  :  TSO Authorization Tables - Part 2\n     BM1005MY  :  APF-Authorized TSO Commands\n     BM1006JN  :  Sharing the Load\n     BM1911NV  :  The Value of Tools, new and old - Part 1\n     BM1912DE  :  The Value of Tools, new and old - Part 2\n                  (Some newer tools you may not know about)\n     BM2001JA  :  8-character TSO userids in z/OS 2.3\n     BM2001JB  :  Saving and reloading IPL text-a new technique\n     BM2001JC  :  CNCLPG - Altering an address space - for free\n     BM2002FE  :  ONLCLIP - Changing the VOLSER of a disk pack\n                  (while the pack remains online)\n     BM2003MA  :  Using z/OS System Services Macros, or not\n     -------------------------------------------------------------------\n     CL8901JA  :  Intro to the column, miscellaneous tools, the CBT tape\n     CL8902FE  :  Various dataset and DASD management tricks\n     CL8903MA  :  ISPF command table, LPA loading at IPL, the ABE editor\n     CL8904AP  :  Enlarging the VTOC of an active disk pack\n     CL8905MY  :  DELINK and RELINK of Load Modules\n     CL8905X1  :  Further notes on ISPF command table additions\n     CL8906JN  :  Retrieving material from IBM's Source Tapes\n     CL8907JL  :  The Amazing EXCP-count Zap\n     CL8909SE  :  The SLAC Mods to Assembler H\n     CL8910OC  :  View Jobs and Output directly from Spool--QUEUE & SDF\n     CL8911NV  :  No-Cost Subsystems:  TSSO, ETPS, and CMD1\n     CL8912DE  :  Convert CLIST libraries from VB to FB and vice-versa\n     CL9001JA  :  Tape mapping, tape looking, and tape copying\n     CL9002FE  :  Some changing tools on the CBT Tape; SLAC ASMBR Part 2\n     CL9004AP  :  The PDS Program Product, Part 1\n     CL9005MY  :  The PDS Program Product, Part 2\n     CL9006JN  :  The effect of changing some of the fields in the VTOC\n     CL9007JL  :  Pre-processing SMPPTFIN data (not dependent on SMP/E)\n     CL9008AU  :  SMP/E Hacking Example - Regressing VTAM, Part 1\n     CL9009SE  :  SMP/E Hacking Example - Regressing VTAM, Part 2\n     CL9010OC  :  MAPXA and BLKDISK: two useful TSO commands\n     CL9011NV  :  Bill Godfrey's contributions; The new REVIEW command\n     CL9012DE  :  The ARCHIVER - Part 1 - A new product and concept\n     CL9101JA  :  The ARCHIVER - Part 2 - More about this new product\n     CL9102FE  :  Conversion between CLIST formats: VB-FB, FB-VB\n     CL9103MA  :  Public software tapes revisited\n     CL9104AP  :  Browsing Virtual Storage: the \"LOOK\" TSO command\n     CL9105MY  :  Member group selection in Partitioned Datasets\n     CL9106JN  :  DYNAMASK - Changing device names on a live system\n     CL9107JL  :  Making your own PTFs, a valuable technique - Part 1\n     CL9108AU  :  Making your own PTFs, a valuable technique - Part 2\n     CL9109SE  :  Exploiting PDS directory fields - Part 1\n     CL9110OC  :  Exploiting PDS directory fields - Part 2\n     CL9111NV  :  Exploiting PDS directory fields - Part 3\n     CL9112DE  :  About Dataset Block Sizes and I/O Efficiency - Part 1\n     CL9201JA  :  About Dataset Block Sizes and I/O Efficiency - Part 2\n     CL9202FE  :  About Dataset Block Sizes and I/O Efficiency - Part 3\n     CL9203MA  :  A Tour of the World through Fullscreen ZAP - Part 1\n     CL9204AP  :  A Tour of the World through Fullscreen ZAP - Part 2\n     CL9205MY  :  Making the Most of your Tools\n     CL9206JN  :  Public software tapes revisited\n     CL9207JL  :  Some ASSEMBLER thoughts - The New H-L Asmblr - Part 1\n     CL9208AU  :  Some ASSEMBLER thoughts - The New H-L Asmblr - Part 2\n     CL9209SE  :  SMP/E Tools you should have - Part 1\n     CL9210OC  :  SMP/E Tools you should have - Part 2\n     CL9211NV  :  Following my own advice: how NOT to upgrade JES2 Exits\n     CL9212DE  :  Putting your Tools together - Part 1 - ISPF Cmd Tables\n     CL9301JA  :  Putting your Tools together - Part 2 - Tool Packages\n     CL9302FE  :  Putting your Tools together - Part 3 - Miscellaneous\n     CL9303MA  :  \"Show Me MVS\" in one place - The SHOWMVS command\n     CL9304AP  :  Copying tapes correctly\n     CL9305JL  :  Making sequential files out of PDS'es, and vice-versa\n     CL9306SE  :  TSO help, without the drawbacks (the HEL command)\n     CL9307NV  :  IEHMAP, and Other Stories\n     CL9401JA  :  The Fascination of the Disassembler - Part 1\n     CL9402MA  :  The Fascination of the Disassembler - Part 2\n     CL9403MY  :  Assembling Program Patches - The ASMTOZAP Program\n     CL9404JL  :  2 Topics: Rebirth of IEHMOVE, Loading JES2 Exits\n     CL9405OC  :  The REVIEW command revisited\n     CL9406NV  :  Your TSO Session - Using the PSCB\n     CL9407DE  :  Your TSO Session - Using the TSO Session Manager\n     CL9501JA  :  On Finding Programs - BLDL and LLA\n     CL9502FE  :  On Dataset Recovery - Introduction\n     CL9503MA  :  Dataset Recovery Methodology - Part 2\n     CL9504AP  :  VTOC Tidbits - Part 1\n     CL9505MY  :  VTOC Tidbits - Part 2\n     CL9506JN  :  A VTOC Adventure - Part 3\n     CL9507JL  :  Exploring SYS1.BRODCAST\n     CL9508AU  :  A Novice's Guide to Assembler Programming - Part 1\n     CL9509SE  :  A Novice's Guide to Assembler Programming - Part 2\n     CL9510OC  :  Working With TSO - Part 1\n     CL9511NV  :  Working With TSO - Part 2\n     CL9512DE  :  Keeping up with the Unit Control Block - Part 1\n     CL9601JA  :  Keeping up with the Unit Control Block - Part 2\n     CL9602FE  :  Edit and System Recovery\n     CL9603MA  :  Your Own World of Edit Macros\n     CL9604AP  :  The Place of Free Software in Today's MVS Shop\n     CL9605MY  :  Eyes - Part 1\n     CL9606JN  :  Eyes - Part 2\n     CL9607JL  :  Eyes - Part 3 - Using SMP/E\n     CL9608AU  :  Personal Tools For Your SMP Work\n     CL9609SE  :  Tidbits\n     CL9610OC  :  Getting Started with Public MVS Software\n     CL9611NV  :  Alternatives and Dataset Recovery\n     CL9612DE  :  On Finding Things\n     CL9702FE  :  Creative Enqueuing\n     CL9703MA  :  Harnessing Macro Power - Part 1\n     CL9704AP  :  Harnessing Macro Power - Part 2\n     CL9705MY  :  It's a Bird, It's a Plane, It's SUPRNAME\n     CL9706JN  :  Timing Out\n     CL9707JL  :  Old Code--Old Gold\n     CL9708AU  :  Profiles in Creativity\n     CL9709SE  :  System Programmer Creativity\n     CL9710OC  :  Why Not Run a Batch Job?\n     CL9711NV  :  Help in Keeping Your System Up\n     CL9712DE  :  Remembering TSSO\n     CL9801JA  :  Looking at Virtual Storage\n     CL9802FE  :  Assorted Utilities - Part 1\n     CL9803MA  :  Assorted Utilities - Part 2\n     CL9804AP  :  Other People's Problems\n     CL9805MY  :  Undeleting Data - Part 1\n     CL9806JN  :  Undeleting Data - Part 2\n     CL9807JL  :  When IBM Says You Can't... Sometimes You Can\n     CL9808SE  :  When IBM Says You Can't... Sometimes You Can - Part 2\n     CL9809OC  :  An Important Y2K Technique\n     CL9810NV  :  Expanding Your Horizons\n     CL9811DE  :  Setting Yourself Up\n     CL9901JA  :  CBT Tape Support Online\n     CL9902FE  :  Resource Affinity Implementation Efforts\n     CL9903MA  :  SMP/E Preprocessing\n     CL9904AP  :  Awareness\n     CL9905MY  :  Highlights of CBT Tape Version 420\n     CL9906JN  :  Selections from CBT Tape Version 420 (and 421)\n     CL9907JL  :  Writing Your Own TSO Command Processor - Part 1\n     CL9908AU  :  Writing Your Own TSO Command Processor - Part 2\n     CL9909SE  :  PC's, C, and Assembler\n     CL9910OC  :  Zapping, Disassembling, Delinking, AND Re-linkediting\n     CL9911NV  :  Learning Our Trade\n     CL9912DE  :  Using XMIT to Package MVS Files\n     CM0001JA  :  Recent CBT Tape News\n     CM0002FE  :  Assembler MACRO Collections - Part 1\n     CM0003MA  :  Assembler MACRO Collections - Part 2\n     CM0004AP  :  Learning About Your MVS System\n     CM0005MY  :  Accumulating Assembler Techniques\n     CM0006JN  :  Copying Tapes\n     CM0007JL  :  Scanning for Parms in a Batch Program\n     CM0008AU  :  The CVT - The Backbone of MVS\n     CM0010OC  :  Running MVS on a PC\n     CM0011NV  :  Designing Software:  What's in it for Us?\n     CM0012DE  :  Keeping Your Finger on the Pulse\n     CM0101JA  :  Tapes and Their Labels\n     CM0102FE  :  Defining Dataset Characteristics\n     CM0103MA  :  ISPF Interfaces for MVS Programs\n     CM0104AP  :  The Art of the Zap\n     CM0105MY  :  Using Sysprog Tools With App-Prog Authority\n     CM0106JN  :  Figuring Out That Module\n     CM0107JL  :  EBCDIC to ASCII - YES or NO?\n     CM0108AU  :  Assembler Programming Revisited\n     CM0109SE  :  Navigating the CBT Tape Collection\n     CM0110OC  :  Learning About MVS from the SMF Book\n     CM0111NV  :  TSO Basics, Revisited\n     CM0112DE  :  Virtual Tapes\n     CM0201JA  :  Does Software Use depend on Software Cost?\n     CM0202FE  :  The New \"REVIEW\"\n     CM0203MA  :  Glossaries\n     CM0204AP  :  CBT Tape Software Packaging\n     CM0205MY  :  Driven By Necessity\n     CM0206JL  :  Retro MVS Computing\n     CM0207AU  :  Positions, and the Division of Labor\n     CM0208SE  :  Recovery Tools\n     CM0209OC  :  Developments in Free MVS Software\n     CM0210NV  :  Thoughts About Assembler Macros\n     CM0211DE  :  Tricks with Tapes - Part 1 - Tape Concepts\n     CM0301JA  :  Tricks with Tapes - PART 2 - Tape Copying Tricks\n     CM0302FE  :  Tricks with Tapes - PART 3 - Using EXCP\n     CM0303MA  :  A Replacement for MCNVTCAT\n     CM0304AP  :  TSSO Revisited\n     CM0305MX  :  Sharing Tape Drives\n     CM0305MY  :  The CBT Overflow Tape\n     CM0306JN  :  Exploring MVS SAMPLIBs\n     CM0307JL  :  Athleticism in Systems Programming\n     CM0308AU  :  Novel Ideas\n     CM0309SE  :  A Fresh Look at the PDS Command Package\n     CM0310OC  :  A Philosophy of MVS Utility Design - Power vs Safety\n     CM0311NV  :  Making Life Complicated\n     CM0312DE  :  Everybody's Different\n     CM0401JA  :  Playing\n     CM0402FE  :  Modularizing an MVS System - Part 1\n     CM0403MA  :  Modularizing an MVS System - Part 2\n     CM0404AP  :  Modularizing an MVS System - Part 3\n     CM0405MY  :  What's Foremost in your Mind\n     CM0406JN  :  CBT Tape New Contributions\n     CM0407JL  :  Measuring and Accessing Tape Data\n     CM0408AU  :  Anatomy of an MVS Battlewagon\n     CM0409SE  :  Administering SYS1.BRODCAST\n     CM0410OC  :  Work and Play\n     CM0411NV  :  PDS and PDSE\n     CM0412DE  :  Ideas\n     CM0501JA  :  My Point of View\n     CM0502FE  :  Emulation and MVS\n     CM0503MA  :  Creativity\n     CM0504AP  :  MVS System Levels\n     CM0505MY  :  Accumulating Knowledge in Assembler\n     CM0506JN  :  Figuring Stuff Out\n     CM0507JL  :  MVS is its History\n     CM0508AU  :  How To Do Stuff Right\n     CM0509SE  :  Power Versus Safety\n     CM0510OC  :  The 30th Anniversary of the CBT Tape\n     CM0511NV  :  Making Your Work Shorter with Tools\n     CM0512DE  :  All Beginnings are Difficult\n     CM0601JA  :  Working With What You Have, and Enjoying It\n     CM0602FE  :  TSO/E Control Blocks - Part 1\n     CM0603MA  :  TSO/E Control Blocks - Part 2\n     CM0604AP  :  Internationalization\n     CM0605MY  :  Why Control Blocks?\n     CM0606JN  :  The World Should be Full of Collectors\n     CM0607JL  :  The World Should be Full of Collectors - 2\n     CM0608AU  :  CBT Tape Packaging\n     CM0609SE  :  Find and Replace in Place\n     CM0610OC  :  MVS Knowledge\n     CM0611NV  :  System Recovery Tools - Part 1\n     CM0612DE  :  System Recovery Tools - Part 2\n     CM0701JA  :  A Little Bit at a Time\n     CM0702FE  :  Technology Breeds Technology\n     CM0703MA  :  Sanity Checks and Programming Enhancements\n     CM0704AP  :  MVS Experience\n     CM0705MY  :  If It Ain't Broke, Don't Fix It\n     CM0706JN  :  The Structure of the Broadcast Dataset - Part 1\n     CM0707JL  :  The Structure of the Broadcast Dataset - Part 2\n     CM0708AU  :  The Structure of the Broadcast Dataset - Part 3\n     CM0709SE  :  System Software \"Quality\"\n     CM0710OC  :  Exploring \"Live\" Storage with the \"LOOK\" TSO Command\n     CM0711NV  :  Displaying MVS System Values - Part 1\n     CM0712DE  :  Displaying MVS System Values - Part 2\n     CM0801JA  :  Protecting Our Code From System Errors\n     CM0802FE  :  CBT Tape Recent Developments - Part 1\n     CM0803MA  :  CBT Tape Recent Developments - Part 2\n     CM0804AP  :  Tape Mapping, Tape Measuring, Tape Copying\n     CM0805MY  :  Preserving Your Tapes For Posterity\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$INTRO": {"ttr": 531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x00\"\\x00\\x93!\\x0f\\x01\\x19\\x14O\\x14E\\x004\\x00*\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "2019-05-24T14:45:22", "lines": 52, "newlines": 42, "modlines": 0, "user": "SBGOLOB"}, "text": "                        INTRODUCTION\n\n     This file contains (roughly) the original drafts of my column:\n\"MVS Tools and Tricks of the Trade\" since its inception until any\nsuch time as I am able to update this file.  There are now approxi-\nmately twelve years' worth of articles here.\n\n     Please bear several factors in mind.  The early articles, which\nwere written several years ago, may contain somewhat obsolete infor-\nmation at times, and certainly they contain some obsolete phone\nnumbers.  I have tried a bit to go in and fix a few phone numbers,\nbut there are many that are old.  There are a few \"dated\" things;\nplease read past them.\n\n     You have the \"advantage\", reading articles from this file (as\nopposed to reading the articles directly from the magazine) of\nseeing these articles before our esteemed editors have gotten their\n(sweet but grubby) hands on them.\n\n     This material was built from the files that I submitted to\n\"Technical Support\" right when I wrote the articles.  They were the\noriginal material.  As such, they included my editorial notes and my\npersonal comments to the editors.  I have tried to expunge all of\nthose marginal notes, but I may have failed to do this completely.\n\n     I am especially sensitive about my editorial notes, because the\neditorial staff of \"Technical Support\" are a group of hard-working and\ndedicated professionals, and they have, by and large, done an\nexcellent job on my writing.  But here, you ain't gonna see any of\ntheir work, I hope.  Editors write things, and the reader thinks the\nauthor wrote them.  What power!  THIS IS MY STUFF.  If you want to see\nTHEIR stuff, take out your old copies of the magazine.\n\n     The editors, because of space considerations, have often made\nme shorten my articles after I had submitted them.  Often, especially\nin the last two years, I have had to shorten the content \"on the fly\".\nBut here, you have most of the articles as I actually submitted them,\nwith the full collection of illustrations, and such.\n\n     My earnest hope is that you'll all be able to derive SOME\nbenefit from this file.  Use it all well.\n\n     Good luck.  (See you next month. (heh heh))\n\n                      Very sincerely yours,\n                      Sam Golob\n\n P.S.  Please feel free to contact me.  I am at:\n\n          sbgolob@cbttape.org\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE120": {"ttr": 533, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04c\\x00!\\x01 \\x06o\\x01 \\x06o\\x10C\\x01]\\x01]\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf9@@@'", "ispf": {"version": "04.99", "flags": 0, "createdate": "2020-03-06T00:00:00", "modifydate": "2020-03-06T10:43:21", "lines": 349, "newlines": 349, "modlines": 0, "user": "CBT-499"}, "text": "//***FILE 120 is from Sam Golob and contains his columns from       *   FILE 120\n//*           \"Technical Support\" magazine entitled \"MVS Tools      *   FILE 120\n//*           and Tricks of the Trade\".  There are now over 19      *   FILE 120\n//*           years' worth of articles, which are included here     *   FILE 120\n//*           by consent from the publisher of the mazagine.        *   FILE 120\n//*           (For Sam's old articles, see File 014.)               *   FILE 120\n//*                                                                 *   FILE 120\n//*           email: sbgolob@cbttape.org  (current contact address) *   FILE 120\n//*                                                                 *   FILE 120\n//*           This file also contains articles written for the      *   FILE 120\n//*           public that DO NOT belong to NaSPA and were never     *   FILE 120\n//*           published by NaSPA.  These articles are members       *   FILE 120\n//*           with prefixes of BM****** and you are welcome to      *   FILE 120\n//*           read them.                                            *   FILE 120\n//*                                                                 *   FILE 120\n//*           This file contains the original versions of Sam's     *   FILE 120\n//*           columns before they were edited, or shortened by      *   FILE 120\n//*           the magazine because of space limitations.            *   FILE 120\n//*                                                                 *   FILE 120\n//*           At the time many of these articles were written,      *   FILE 120\n//*           you needed to purchase a CBT Tape from NaSPA in       *   FILE 120\n//*           order to obtain these materials.  Now, please just    *   FILE 120\n//*           go to www.cbttape.org and download the files that     *   FILE 120\n//*           you want, completely free of charge.  Try going       *   FILE 120\n//*           to the \"Updates Page\" of www.cbttape.org first, to    *   FILE 120\n//*           get the latest versions of the files, if they had     *   FILE 120\n//*           been recently updated.                                *   FILE 120\n//*                                                                 *   FILE 120\n//*           It is perhaps convenient to include these articles    *   FILE 120\n//*           on the CBT Tape itself, because many of them talk     *   FILE 120\n//*           about how to make best use of software offerings      *   FILE 120\n//*           which are distributed with this tape.                 *   FILE 120\n//*                                                                 *   FILE 120\n//*           After 19 plus years, NaSPA has (possibly temporarily) *   FILE 120\n//*           stopped publishing \"Technical Support\" magazine.      *   FILE 120\n//*           Meanwhile, I am writing some articles anyway, for the *   FILE 120\n//*           betterment of the people (hopefully), and for myself. *   FILE 120\n//*           Stuff that doesn't belong to NaSPA is prefixed by     *   FILE 120\n//*           member name \"BM\".  Even though a copyright notice     *   FILE 120\n//*           appears in these articles, I give my permission for   *   FILE 120\n//*           people to copy them and spread them around.  It's     *   FILE 120\n//*           only republication without permission, that I am      *   FILE 120\n//*           restricting.  If you want to re-publish anything      *   FILE 120\n//*           that belongs to me, please ask me.                    *   FILE 120\n//*                                                                 *   FILE 120\n//*   >>>>  Members starting with BM****** belong to Sam Golob,     *   FILE 120\n//*   >>>>  and not to NaSPA or any other magazine or organization. *   FILE 120\n//*   >>>>  BM1005MY is allowed to be used by SHARE, INC. without   *   FILE 120\n//*   >>>>  restriction.                                            *   FILE 120\n//*                                                                 *   FILE 120\n//*              SUBJECT MATTER INDEX TO THE COLUMNS                *   FILE 120\n//*                  (TOPICS THAT WERE COVERED)                     *   FILE 120\n//*                                                                 *   FILE 120\n//*     PDS MEMBER    SUBJECT MATTER OR TITLE                       *   FILE 120\n//*     ----------    -----------------------                       *   FILE 120\n//*                                                                 *   FILE 120\n//*     $$$CPYRT  :  COPYRIGHT NOTICE                               *   FILE 120\n//*     $$$INDEX  :  MEMBER NAMING SCHEME FOR THIS FILE             *   FILE 120\n//*     $$$PERMT  :  PERMISSION TO DISTRIBUTE THIS MATERIAL         *   FILE 120\n//*     $$DIRECT  :  ONE-LINE SUBJECT MATTER INDEX TO THE COLUMNS   *   FILE 120\n//*     @FILE120  :  THIS FILE - CONTAINS AN INDEX TO THE COLUMNS   *   FILE 120\n//*     $$INTRO   :  AUTHOR'S PREFACE AND \"QUICK INTRO\"             *   FILE 120\n//*     ----------------------------------------------------------- *   FILE 120\n//*     BM0009SE  :  THE JOY OF \"SHARE\" (SEPARATE ARTICLE - NOT     *   FILE 120\n//*                  PUBLISHED - DOES NOT BELONG TO NASPA)          *   FILE 120\n//*     BM0806JN  :  TSO/E CONTROL BLOCKS, AND MORE                 *   FILE 120\n//*     BM0901JA  :  TSO AUTHORIZATION TABLES                       *   FILE 120\n//*     BM0902FE  :  TSO AUTHORIZATION TABLES - PART 2              *   FILE 120\n//*     BM1005MY  :  APF-AUTHORIZED TSO COMMANDS                    *   FILE 120\n//*     BM1006JN  :  SHARING THE LOAD                               *   FILE 120\n//*     BM1911NV  :  THE VALUE OF TOOLS, NEW AND OLD - PART 1       *   FILE 120\n//*     BM1912DE  :  THE VALUE OF TOOLS, NEW AND OLD - PART 2       *   FILE 120\n//*                  SOME NEWER TOOLS YOU MAY NOT KNOW ABOUT        *   FILE 120\n//*     BM2001JA  :  8-CHARACTER TSO USERIDS IN Z/OS 2.3            *   FILE 120\n//*     BM2001JB  :  SAVING AND RELOADING IPL TEXT-A NEW TECHNIQUE  *   FILE 120\n//*     BM2001JC  :  CNCLPG - ALTERING AN ADDRESS SPACE - FOR FREE  *   FILE 120\n//*     BM2002FE  :  ONLCLIP - CHANGING THE VOLSER OF A DISK PACK   *   FILE 120\n//*                  (WHILE THE PACK REMAINS ONLINE)                *   FILE 120\n//*     BM2003MA  :  USING Z/OS SYSTEM SERVICES MACROS, OR NOT      *   FILE 120\n//*     ----------------------------------------------------------- *   FILE 120\n//*     CL8901JA  :  INTRO TO THE COLUMN, MISCELLANEOUS TOOLS,      *   FILE 120\n//*                  THE CBT TAPE                                   *   FILE 120\n//*     CL8902FE  :  VARIOUS DATASET AND DASD MANAGEMENT TRICKS     *   FILE 120\n//*     CL8903MA  :  ISPF COMMAND TABLE, LPA LOADING AT IPL, THE    *   FILE 120\n//*                  ABE EDITOR  (SEE INCLUDED CORRECTIONS FOR LPA) *   FILE 120\n//*     CL8904AP  :  ENLARGING THE VTOC OF AN ACTIVE DISK PACK      *   FILE 120\n//*     CL8905MY  :  DELINK AND RELINK OF LOAD MODULES              *   FILE 120\n//*     CL8905X1  :  FURTHER NOTES ON ISPF COMMAND TABLE ADDITIONS  *   FILE 120\n//*     CL8906JN  :  RETRIEVING MATERIAL FROM IBM'S SOURCE TAPES    *   FILE 120\n//*     CL8907JL  :  THE AMAZING EXCP-COUNT ZAP                     *   FILE 120\n//*     CL8909SE  :  THE SLAC MODS TO ASSEMBLER H                   *   FILE 120\n//*     CL8910OC  :  VIEW JOBS AND OUTPUT DIRECTLY FROM             *   FILE 120\n//*                  SPOOL--QUEUE & SDF                             *   FILE 120\n//*     CL8911NV  :  NO-COST SUBSYSTEMS:  TSSO, ETPS, AND CMD1      *   FILE 120\n//*     CL8912DE  :  CONVERT CLIST LIBRARIES FROM VB TO FB AND      *   FILE 120\n//*                  VICE-VERSA                                     *   FILE 120\n//*     CL9001JA  :  TAPE MAPPING, TAPE LOOKING, AND TAPE COPYING   *   FILE 120\n//*     CL9002FE  :  SOME CHANGING TOOLS ON THE CBT TAPE;           *   FILE 120\n//*                  THE SLAC ASSEMBLER, UPDATE 2                   *   FILE 120\n//*     CL9004AP  :  THE PDS PROGRAM PRODUCT, PART 1                *   FILE 120\n//*     CL9005MY  :  THE PDS PROGRAM PRODUCT, PART 2                *   FILE 120\n//*     CL9006JN  :  THE EFFECT OF CHANGING SOME OF THE FIELDS IN   *   FILE 120\n//*                  THE VTOC                                       *   FILE 120\n//*     CL9007JL  :  PRE-PROCESSING SMPPTFIN DATA (NOT DEPENDENT ON *   FILE 120\n//*                  SMP/E)                                         *   FILE 120\n//*     CL9008AU  :  SMP/E HACKING EXAMPLE - REGRESSING VTAM,       *   FILE 120\n//*                  PART 1                                         *   FILE 120\n//*     CL9009SE  :  SMP/E HACKING EXAMPLE - REGRESSING VTAM,       *   FILE 120\n//*                  PART 2                                         *   FILE 120\n//*     CL9010OC  :  MAPXA AND BLKDISK: TWO USEFUL TSO COMMANDS     *   FILE 120\n//*     CL9011NV  :  BILL GODFREY'S CONTRIBUTIONS; THE NEW          *   FILE 120\n//*                  REVIEW COMMAND                                 *   FILE 120\n//*     CL9012DE  :  THE ARCHIVER - PART 1 -                        *   FILE 120\n//*                  A NEW PRODUCT AND CONCEPT                      *   FILE 120\n//*     CL9101JA  :  THE ARCHIVER - PART 2 -                        *   FILE 120\n//*                  MORE ABOUT THIS NEW PRODUCT                    *   FILE 120\n//*     CL9102FE  :  CONVERSION BETWEEN CLIST FORMATS:              *   FILE 120\n//*                  VB-FB, FB-VB                                   *   FILE 120\n//*     CL9103MA  :  PUBLIC SOFTWARE TAPES REVISITED                *   FILE 120\n//*     CL9104AP  :  BROWSING VIRTUAL STORAGE:                      *   FILE 120\n//*                  THE \"LOOK\" TSO COMMAND                         *   FILE 120\n//*     CL9105MY  :  MEMBER GROUP SELECTION IN PARTITIONED DATASETS *   FILE 120\n//*     CL9106JN  :  DYNAMASK - CHANGING DEVICE NAMES ON A LIVE     *   FILE 120\n//*                  SYSTEM                                         *   FILE 120\n//*     CL9107JL  :  MAKING YOUR OWN PTFS, A VALUABLE TECHNIQUE     *   FILE 120\n//*                  - PART 1                                       *   FILE 120\n//*     CL9108AU  :  MAKING YOUR OWN PTFS, A VALUABLE TECHNIQUE     *   FILE 120\n//*                  - PART 2                                       *   FILE 120\n//*     CL9109SE  :  EXPLOITING PDS DIRECTORY FIELDS - PART 1       *   FILE 120\n//*     CL9110OC  :  EXPLOITING PDS DIRECTORY FIELDS - PART 2       *   FILE 120\n//*     CL9111NV  :  EXPLOITING PDS DIRECTORY FIELDS - PART 3       *   FILE 120\n//*     CL9112DE  :  ABOUT DATASET BLOCK SIZES AND I/O              *   FILE 120\n//*                  EFFICIENCY - PART 1                            *   FILE 120\n//*     CL9201JA  :  ABOUT DATASET BLOCK SIZES AND I/O              *   FILE 120\n//*                  EFFICIENCY - PART 2                            *   FILE 120\n//*     CL9202FE  :  ABOUT DATASET BLOCK SIZES AND I/O              *   FILE 120\n//*                  EFFICIENCY - PART 3                            *   FILE 120\n//*     CL9203MA  :  A TOUR OF THE WORLD THROUGH                    *   FILE 120\n//*                  FULLSCREEN ZAP - PART 1                        *   FILE 120\n//*     CL9204AP  :  A TOUR OF THE WORLD THROUGH                    *   FILE 120\n//*                  FULLSCREEN ZAP - PART 2                        *   FILE 120\n//*     CL9205MY  :  MAKING THE MOST OF YOUR TOOLS                  *   FILE 120\n//*     CL9206JN  :  PUBLIC SOFTWARE TAPES REVISITED                *   FILE 120\n//*     CL9207JL  :  SOME ASSEMBLER THOUGHTS:                       *   FILE 120\n//*                  THE NEW HIGH-LEVEL ASSEMBLER - PART 1          *   FILE 120\n//*     CL9208AU  :  SOME ASSEMBLER THOUGHTS:                       *   FILE 120\n//*                  THE NEW HIGH-LEVEL ASSEMBLER - PART 2          *   FILE 120\n//*     CL9209SE  :  SMP/E TOOLS YOU SHOULD HAVE - PART 1           *   FILE 120\n//*     CL9210OC  :  SMP/E TOOLS YOU SHOULD HAVE - PART 2           *   FILE 120\n//*     CL9211NV  :  HOW I FOLLOWED MY OWN ADVICE, AND              *   FILE 120\n//*                  HOW NOT TO UPGRADE JES2 EXITS                  *   FILE 120\n//*     CL9212DE  :  PUTTING YOUR TOOLS TOGETHER - PART 1           *   FILE 120\n//*                  - ISPF COMMAND TABLES                          *   FILE 120\n//*     CL9301JA  :  PUTTING YOUR TOOLS TOGETHER - PART 2           *   FILE 120\n//*                  - TOOL PACKAGES                                *   FILE 120\n//*     CL9302FE  :  PUTTING YOUR TOOLS TOGETHER - PART 3 -         *   FILE 120\n//*                  EDIT MACROS, TSO COMMANDS, AND                 *   FILE 120\n//*                  MISCELLANEOUS TECHNIQUES                       *   FILE 120\n//*     CL9303MA  :  \"SHOW ME MVS\" IN ONE PLACE -                   *   FILE 120\n//*                  THE SHOWMVS COMMAND                            *   FILE 120\n//*     CL9304AP  :  COPYING TAPES CORRECTLY                        *   FILE 120\n//*     CL9305JL  :  MAKING SEQUENTIAL FILES OUT OF PDS'ES,         *   FILE 120\n//*                  AND VICE-VERSA                                 *   FILE 120\n//*     CL9306SE  :  TSO HELP, WITHOUT THE DRAWBACKS:               *   FILE 120\n//*                  THE HEL COMMAND                                *   FILE 120\n//*     CL9307NV  :  IEHMAP, AND OTHER STORIES.                     *   FILE 120\n//*     CL9401JA  :  THE FASCINATION OF THE DISASSEMBLER - PART 1   *   FILE 120\n//*     CL9402MA  :  THE FASCINATION OF THE DISASSEMBLER - PART 2   *   FILE 120\n//*     CL9403MY  :  ASSEMBLING PROGRAM PATCHES - THE ASMTOZAP      *   FILE 120\n//*                  PROGRAM                                        *   FILE 120\n//*     CL9404JL  :  2 TOPICS: REBIRTH OF IEHMOVE, LOADING JES2     *   FILE 120\n//*                  EXITS DYNAMICALLY                              *   FILE 120\n//*     CL9405OC  :  THE \"REVIEW\" COMMAND REVISITED                 *   FILE 120\n//*     CL9406NV  :  YOUR TSO SESSION - USING THE PSCB              *   FILE 120\n//*     CL9407DE  :  YOUR TSO SESSION - USING THE TSO               *   FILE 120\n//*                  SESSION MANAGER                                *   FILE 120\n//*     CL9501JA  :  ON FINDING PROGRAMS - BLDL AND LLA             *   FILE 120\n//*     CL9502FE  :  ON DATASET RECOVERY - INTRODUCTION             *   FILE 120\n//*     CL9503MA  :  DATASET RECOVERY METHODOLOGY - PART 2          *   FILE 120\n//*     CL9504AP  :  VTOC TIDBITS - PART 1                          *   FILE 120\n//*     CL9505MY  :  VTOC TIDBITS - PART 2                          *   FILE 120\n//*     CL9506JN  :  A VTOC ADVENTURE - PART 3                      *   FILE 120\n//*     CL9507JL  :  EXPLORING SYS1.BRODCAST                        *   FILE 120\n//*     CL9508AU  :  A NOVICE'S GUIDE TO ASSEMBLER                  *   FILE 120\n//*                  PROGRAMMING - PART 1                           *   FILE 120\n//*     CL9509SE  :  A NOVICE'S GUIDE TO ASSEMBLER                  *   FILE 120\n//*                  PROGRAMMING - PART 2                           *   FILE 120\n//*     CL9510OC  :  WORKING WITH TSO - PART 1                      *   FILE 120\n//*     CL9511NV  :  WORKING WITH TSO - PART 2                      *   FILE 120\n//*     CL9512DE  :  KEEPING UP WITH THE UNIT CONTROL               *   FILE 120\n//*                  BLOCK - PART 1                                 *   FILE 120\n//*     CL9601JA  :  KEEPING UP WITH THE UNIT CONTROL               *   FILE 120\n//*                  BLOCK - PART 2                                 *   FILE 120\n//*     CL9602FE  :  EDIT AND SYSTEM RECOVERY                       *   FILE 120\n//*     CL9603MA  :  YOUR OWN WORLD OF EDIT MACROS                  *   FILE 120\n//*     CL9604AP  :  THE PLACE OF FREE SOFTWARE IN TODAY'S          *   FILE 120\n//*                  MVS SHOP                                       *   FILE 120\n//*     CL9605MY  :  EYES - PART 1                                  *   FILE 120\n//*     CL9606JN  :  EYES - PART 2                                  *   FILE 120\n//*     CL9607JL  :  EYES - PART 3 - USING SMP/E                    *   FILE 120\n//*     CL9608AU  :  PERSONAL TOOLS FOR YOUR SMP WORK               *   FILE 120\n//*     CL9609SE  :  TIDBITS                                        *   FILE 120\n//*     CL9610OC  :  GETTING STARTED WITH PUBLIC MVS SOFTWARE       *   FILE 120\n//*     CL9611NV  :  ALTERNATIVES AND DATASET RECOVERY              *   FILE 120\n//*     CL9612DE  :  ON FINDING THINGS                              *   FILE 120\n//*     CL9702FE  :  CREATIVE ENQUEUING                             *   FILE 120\n//*     CL9703MA  :  HARNESSING MACRO POWER - PART 1                *   FILE 120\n//*     CL9704AP  :  HARNESSING MACRO POWER - PART 2                *   FILE 120\n//*     CL9705MY  :  IT'S A BIRD, IT'S A PLANE, IT'S SUPRNAME       *   FILE 120\n//*     CL9706JN  :  TIMING OUT                                     *   FILE 120\n//*     CL9707JL  :  OLD CODE--OLD GOLD                             *   FILE 120\n//*     CL9708AU  :  PROFILES IN CREATIVITY                         *   FILE 120\n//*     CL9709SE  :  SYSTEM PROGRAMMER CREATIVITY                   *   FILE 120\n//*     CL9710OC  :  WHY NOT RUN A BATCH JOB?                       *   FILE 120\n//*     CL9711NV  :  HELP IN KEEPING YOUR SYSTEM UP                 *   FILE 120\n//*     CL9712DE  :  REMEMBERING TSSO                               *   FILE 120\n//*     CL9801JA  :  LOOKING AT VIRTUAL STORAGE                     *   FILE 120\n//*     CL9802FE  :  ASSORTED UTILITIES - PART 1                    *   FILE 120\n//*     CL9803MA  :  ASSORTED UTILITIES - PART 2                    *   FILE 120\n//*     CL9804AP  :  OTHER PEOPLE'S PROBLEMS                        *   FILE 120\n//*     CL9805MY  :  UNDELETING DATA - PART 1                       *   FILE 120\n//*     CL9806JN  :  UNDELETING DATA - PART 2                       *   FILE 120\n//*     CL9807JL  :  WHEN IBM SAYS YOU CAN'T... SOMETIMES YOU CAN   *   FILE 120\n//*     CL9808SE  :  WHEN IBM SAYS YOU CAN'T... SOMETIMES YOU CAN   *   FILE 120\n//*                  - PART 2                                       *   FILE 120\n//*     CL9809OC  :  AN IMPORTANT Y2K TECHNIQUE                     *   FILE 120\n//*     CL9810NV  :  EXPANDING YOUR HORIZONS                        *   FILE 120\n//*     CL9811DE  :  SETTING YOURSELF UP                            *   FILE 120\n//*     CL9901JA  :  CBT TAPE SUPPORT ONLINE                        *   FILE 120\n//*     CL9902FE  :  RESOURCE AFFINITY IMPLEMENTATION EFFORTS       *   FILE 120\n//*     CL9903MA  :  SMP/E PREPROCESSING                            *   FILE 120\n//*     CL9904AP  :  AWARENESS                                      *   FILE 120\n//*     CL9905MY  :  HIGHLIGHTS OF CBT TAPE VERSION 420             *   FILE 120\n//*     CL9906JN  :  SELECTIONS FROM CBT TAPE VERSION 420 (AND 421) *   FILE 120\n//*     CL9907JL  :  WRITING YOUR OWN TSO COMMAND PROCESSOR         *   FILE 120\n//*                  - PART 1                                       *   FILE 120\n//*     CL9908AU  :  WRITING YOUR OWN TSO COMMAND PROCESSOR         *   FILE 120\n//*                  - PART 2                                       *   FILE 120\n//*     CL9908SE  :  PC'S, C, AND ASSEMBLER                         *   FILE 120\n//*     CL9910OC  :  ZAPPING, DISASSEMBLING, DELINKING, AND         *   FILE 120\n//*                  RE-LINKEDITING                                 *   FILE 120\n//*     CL9911NV  :  LEARNING OUR TRADE                             *   FILE 120\n//*     CL9912DE  :  USING XMIT TO PACKAGE MVS FILES                *   FILE 120\n//*     CM0001JA  :  RECENT CBT TAPE NEWS                           *   FILE 120\n//*     CM0002FE  :  ASSEMBLER MACRO COLLECTIONS - PART 1           *   FILE 120\n//*     CM0003MA  :  ASSEMBLER MACRO COLLECTIONS - PART 2           *   FILE 120\n//*     CM0004AP  :  LEARNING ABOUT YOUR MVS SYSTEM                 *   FILE 120\n//*     CM0005MY  :  ACCUMULATING ASSEMBLER TECHNIQUES              *   FILE 120\n//*     CM0006JN  :  COPYING TAPES                                  *   FILE 120\n//*     CM0007JL  :  SCANNING FOR PARMS IN A BATCH PROGRAM          *   FILE 120\n//*     CM0008AU  :  THE CVT - THE BACKBONE OF MVS                  *   FILE 120\n//*     CM0010OC  :  RUNNING MVS ON A PC                            *   FILE 120\n//*     CM0011NV  :  DESIGNING SOFTWARE:  WHAT'S IN IT FOR US?      *   FILE 120\n//*     CM0012DE  :  KEEPING YOUR FINGER ON THE PULSE               *   FILE 120\n//*     CM0101JA  :  TAPES AND THEIR LABELS                         *   FILE 120\n//*     CM0102FE  :  DEFINING DATASET CHARACTERISTICS               *   FILE 120\n//*     CM0103MA  :  ISPF INTERFACES FOR MVS PROGRAMS               *   FILE 120\n//*     CM0104AP  :  THE ART OF THE ZAP                             *   FILE 120\n//*     CM0105MY  :  USING SYSPROG TOOLS WITH APP-PROG AUTHORITY    *   FILE 120\n//*     CM0106JN  :  FIGURING OUT THAT MODULE                       *   FILE 120\n//*     CM0107JL  :  EBCDIC TO ASCII - YES OR NO?                   *   FILE 120\n//*     CM0108AU  :  ASSEMBLER PROGRAMMING REVISITED                *   FILE 120\n//*     CM0109SE  :  NAVIGATING THE CBT TAPE COLLECTION             *   FILE 120\n//*     CM0110OC  :  LEARNING ABOUT MVS FROM THE SMF BOOK           *   FILE 120\n//*     CM0111NV  :  TSO BASICS, REVISITED                          *   FILE 120\n//*     CM0112DE  :  VIRTUAL TAPES                                  *   FILE 120\n//*     CM0201JA  :  DOES SOFTWARE USE DEPEND ON SOFTWARE COST?     *   FILE 120\n//*     CM0202FE  :  THE NEW \"REVIEW\"                               *   FILE 120\n//*     CM0203MA  :  GLOSSARIES                                     *   FILE 120\n//*     CM0204AP  :  CBT TAPE SOFTWARE PACKAGING                    *   FILE 120\n//*     CM0205MY  :  DRIVEN BY NECESSITY                            *   FILE 120\n//*     CM0206JL  :  RETRO MVS COMPUTING                            *   FILE 120\n//*     CM0207AU  :  POSITIONS, AND THE DIVISION OF LABOR           *   FILE 120\n//*     CM0208SE  :  RECOVERY TOOLS                                 *   FILE 120\n//*     CM0209OC  :  DEVELOPMENTS IN FREE MVS SOFTWARE              *   FILE 120\n//*     CM0210NV  :  THOUGHTS ABOUT ASSEMBLER MACROS                *   FILE 120\n//*     CM0211DE  :  TRICKS WITH TAPES - PART 1 - TAPE CONCEPTS     *   FILE 120\n//*     CM0301JA  :  TRICKS WITH TAPES - PART 2-TAPE COPYING TRICKS *   FILE 120\n//*     CM0302FE  :  TRICKS WITH TAPES - PART 3 - USING EXCP        *   FILE 120\n//*     CM0303MA  :  A REPLACEMENT FOR MCNVTCAT                     *   FILE 120\n//*     CM0304AP  :  TSSO REVISITED                                 *   FILE 120\n//*     CM0305MX  :  SHARING TAPE DRIVES                            *   FILE 120\n//*     CM0305MY  :  THE CBT OVERFLOW TAPE                          *   FILE 120\n//*     CM0306JN  :  EXPLORING MVS SAMPLIBS                         *   FILE 120\n//*     CM0307JL  :  ATHLETICISM IN SYSTEMS PROGRAMMING             *   FILE 120\n//*     CM0308AU  :  NOVEL IDEAS                                    *   FILE 120\n//*     CM0309SE  :  A FRESH LOOK AT THE PDS COMMAND PACKAGE        *   FILE 120\n//*     CM0310OC  :  A PHILOSOPHY OF MVS UTILITY DESIGN             *   FILE 120\n//*                  - POWER VS SAFETY                              *   FILE 120\n//*     CM0311NV  :  MAKING LIFE COMPLICATED                        *   FILE 120\n//*     CM0312DE  :  EVERYBODY'S DIFFERENT                          *   FILE 120\n//*     CM0401JA  :  PLAYING                                        *   FILE 120\n//*     CM0402FE  :  MODULARIZING AN MVS SYSTEM - PART 1            *   FILE 120\n//*     CM0403MA  :  MODULARIZING AN MVS SYSTEM - PART 2            *   FILE 120\n//*     CM0404AP  :  MODULARIZING AN MVS SYSTEM - PART 3            *   FILE 120\n//*     CM0405MY  :  WHAT'S FOREMOST IN YOUR MIND                   *   FILE 120\n//*     CM0406JN  :  CBT TAPE NEW CONTRIBUTIONS                     *   FILE 120\n//*     CM0407JL  :  MEASURING AND ACCESSING TAPE DATA              *   FILE 120\n//*     CM0408AU  :  ANATOMY OF AN MVS BATTLEWAGON                  *   FILE 120\n//*     CM0409SE  :  ADMINISTERING SYS1.BRODCAST                    *   FILE 120\n//*     CM0410OC  :  WORK AND PLAY                                  *   FILE 120\n//*     CM0411NV  :  PDS AND PDSE                                   *   FILE 120\n//*     CM0412DE  :  IDEAS                                          *   FILE 120\n//*     CM0501JA  :  MY POINT OF VIEW                               *   FILE 120\n//*     CM0502FE  :  EMULATION AND MVS                              *   FILE 120\n//*     CM0503MA  :  CREATIVITY                                     *   FILE 120\n//*     CM0504AP  :  MVS SYSTEM LEVELS                              *   FILE 120\n//*     CM0505MY  :  ACCUMULATING KNOWLEDGE IN ASSEMBLER            *   FILE 120\n//*     CM0506JN  :  FIGURING STUFF OUT                             *   FILE 120\n//*     CM0507JL  :  MVS IS ITS HISTORY                             *   FILE 120\n//*     CM0508AU  :  HOW TO DO STUFF RIGHT                          *   FILE 120\n//*     CM0509SE  :  POWER VERSUS SAFETY                            *   FILE 120\n//*     CM0510OC  :  THE 30TH ANNIVERSARY OF THE CBT TAPE           *   FILE 120\n//*     CM0511NV  :  MAKING YOUR WORK SHORTER WITH TOOLS            *   FILE 120\n//*     CM0512DE  :  ALL BEGINNINGS ARE DIFFICULT                   *   FILE 120\n//*     CM0601JA  :  WORKING WITH WHAT YOU HAVE, AND ENJOYING IT    *   FILE 120\n//*     CM0602FE  :  TSO/E CONTROL BLOCKS - PART 1                  *   FILE 120\n//*     CM0603MA  :  TSO/E CONTROL BLOCKS - PART 2                  *   FILE 120\n//*     CM0604AP  :  INTERNATIONALIZATION                           *   FILE 120\n//*     CM0605MY  :  WHY CONTROL BLOCKS?                            *   FILE 120\n//*     CM0606JN  :  THE WORLD SHOULD BE FULL OF COLLECTORS         *   FILE 120\n//*     CM0607JL  :  THE WORLD SHOULD BE FULL OF COLLECTORS - 2     *   FILE 120\n//*     CM0608AU  :  CBT TAPE PACKAGING                             *   FILE 120\n//*     CM0609SE  :  FIND AND REPLACE IN PLACE                      *   FILE 120\n//*     CM0610OC  :  MVS KNOWLEDGE                                  *   FILE 120\n//*     CM0611NV  :  SYSTEM RECOVERY TOOLS - PART 1                 *   FILE 120\n//*     CM0612DE  :  SYSTEM RECOVERY TOOLS - PART 2                 *   FILE 120\n//*     CM0701JA  :  A LITTLE BIT AT A TIME                         *   FILE 120\n//*     CM0702FE  :  TECHNOLOGY BREEDS TECHNOLOGY                   *   FILE 120\n//*     CM0703MA  :  SANITY CHECKS AND PROGRAMMING ENHANCEMENTS     *   FILE 120\n//*     CM0704AP  :  MVS EXPERIENCE                                 *   FILE 120\n//*     CM0705MY  :  IF IT AIN'T BROKE, DON'T FIX IT                *   FILE 120\n//*     CM0706JN  :  THE STRUCTURE OF THE BROADCAST DATASET         *   FILE 120\n//*                  - PART 1                                       *   FILE 120\n//*     CM0707JL  :  THE STRUCTURE OF THE BROADCAST DATASET         *   FILE 120\n//*                  - PART 2                                       *   FILE 120\n//*     CM0708AU  :  THE STRUCTURE OF THE BROADCAST DATASET         *   FILE 120\n//*                  - PART 3                                       *   FILE 120\n//*     CM0709SE  :  SYSTEM SOFTWARE \"QUALITY\"                      *   FILE 120\n//*     CM0710OC  :  EXPLORING \"LIVE\" STORAGE WITH THE \"LOOK\"       *   FILE 120\n//*                  TSO COMMAND                                    *   FILE 120\n//*     CM0711NV  :  DISPLAYING MVS SYSTEM VALUES - PART 1          *   FILE 120\n//*     CM0712DE  :  DISPLAYING MVS SYSTEM VALUES - PART 2          *   FILE 120\n//*     CM0801JA  :  PROTECTING OUR CODE FROM SYSTEM ERRORS         *   FILE 120\n//*     CM0802FE  :  CBT TAPE RECENT DEVELOPMENTS - PART 1          *   FILE 120\n//*     CM0803MA  :  CBT TAPE RECENT DEVELOPMENTS - PART 2          *   FILE 120\n//*     CM0804AP  :  TAPE MAPPING, TAPE MEASURING, TAPE COPYING     *   FILE 120\n//*     CM0805MY  :  PRESERVING YOUR TAPES FOR POSTERITY            *   FILE 120\n//*                                                                 *   FILE 120\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BM0009SE": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x01\\x00!?\\x01\\x00)\\x9f\\x11G\\x00\\xe7\\x00\\xe4\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2000-07-31T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 231, "newlines": 228, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         SEPTEMBER 2000\n\nThis article was never published, and therefore does not belong to\nNaSPA.\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@attglobal.net and/or sbgolob@aol.com.\nThe Online CBT Tape web site has its own URL.  However, it can also\nbe reached from the \"Members Only\" section of www.naspa.net .\n\n\nTHE JOY OF \"SHARE\"\n\n      Much of my \"edge\" as an MVS Systems Programmer comes from\nnetworking with other professionals in my field.  Why, and how, does\nthat give me an advantage?  Today, I'll tell you about it.\n\n      Just like the rest of the computing world, MVS (aka OS/390) is\nconstantly changing and developing too.  MVS is a large part of a\nlarger world.  Everyone has to exert some effort to keep up with\n\"developments\".  It's almost a requirement for us to find out about\nthe changes, or we'll quickly get left behind.\n\n      So we can talk about approaches to deal with the problem.  We\nhave a finite amount of time.  Most of our time is spent on our normal\nworkload.  Perhaps we have a fraction of our time which we can devote\nto reading periodicals, IBM announcements, and the like.  We can also\nsubscribe to the IBM-MAIN newsgroup or other news groups to see what\nother people's problems are (see my April 1998 column).  However,\npractically speaking, there's the question:  \"How can I find out enough\ninformation about new developments that affect my own position, without\nlosing too much time from the rest of my life?\"\n\n      I have a solution to that.  Many systems programmers know about\nthis solution, and have taken full advantage of it.  On the other hand,\na surprisingly large number do not realize the extent to which they,\nand their shops, can benefit.  My answer is to take advantage of the\nconcentrated, one-week exposure to the enormous quantity of raw knowledge\nthat the semi-annual SHARE conferences offer.\n\n\nWhat is SHARE?\n\n      SHARE is an organization which was started well over 40 years ago\nas an IBM user group, and a forum for users to suggest improvements to\nIBM products.  Many of the components of MVS or OS/390 that we've come\nto \"know and love\", such as SMF among many others, came about through\nthe efforts of IBM customers such as you and me, submitting\n\"requirements\" for product improvements to IBM through the SHARE\nmeetings.  Sometimes submitting user requirements wasn't enough, to\nget IBM moving on improving its products.  Often we had to organize\nSHARE committees to campaign to IBM, and to work with IBM's product\ndevelopers on a personal basis.\n\n      Here's an example that's close to my own heart, and in which I\nparticipated personally.  Working through SHARE, I myself was\ninstrumental in getting IBM to create the High Level Assembler, which\nincorporates over 50 improvements to Assembler H that were written by a\nprivate individual, Greg Mushial.  For many years, IBM rejected nearly\nall the requirements we submitted for improving the Assembler.  We\ncouldn't get them to budge, even through the \"requirements\" route.  We\nformed the SHARE Assembler Committee, with the express purpose of\ngetting IBM to incorporate Greg Mushial's modifications into their\nAssembler H program.\n\n      We negotiated with IBM for several years on this matter, using\nthe SHARE Assembler Committee as our forum.  Finally, through the great\nefforts of several individuals--one inside IBM (John Ehrman), and about\na dozen outside of IBM (notably Bill Winters), IBM relented, and the\nworld is now enjoying the pleasure of using the High Level Assembler.\nThis improvement makes Assembler coding easier and more error-free, and\nevery time I write an Assembler program (quite often nowadays), I'm\nvery thankful to all the individuals who contributed.  It was\naccomplished through SHARE.\n\n      SHARE doesn't just deal with MVS or OS/390.  There's a large UNIX\ncontingent; RS/6000 and PC practitioners are well represented.  VM,\nOperations Management, and Technical Support Management also have a\npresence at SHARE.  Networking, TCP/IP (nowadays an essential part of\nOS/390), MQ Series, DB2 and various database groups, running on all\nkinds of platforms, and many other parts of the modern computing world\nare active at SHARE.  If you are working in one field, such as MVS, and\nyou need information about any other computing area that could touch on\nyour work, you'll almost surely find knowledgeable people at a SHARE\nconference, who can answer any of your questions.  I once brought about\n40 questions from people in my shop, to SHARE, and by the end of the\nweek (after much digging), I had answers to all of them.\n\n      Another under-publicized feature of SHARE is the accessibility\nto IBM personnel that it provides.  Normally, IBM guards customer\naccessibility to its developers and Level 2 people.  At SHARE, all these\ngroups are represented (in human form), and IBM's own SHARE attendees\nare given permission to hand out their business cards to anyone who asks\nfor them.  It makes sense why IBM does this.  SHARE is the place where\nIBM looks for direct customer input, so their people have to be able to\ntalk to the customers.  I've formed many contacts and friendships with\nIBM personnel, through this means.  I've also solved many difficult\nsystem problems, with speed and dispatch, by knowing whom to call.\n\n      I recently started working with someone I had known from seeing\nfrequently at SHARE meetings.  She told me she used to work for a large\ncompany.  That company wanted IBM to make certain improvements in CICS\nand in other components.  So they sent a sizable contingent of people to\nSHARE, and asked them to sit on certain committees, to influence IBM to\nmake the changes they wanted.  Needless to say, this was effective; IBM\nmade many improvements because of them.  And all the other IBM\ninstallations are benefiting from that company's policy as well.\n\n      In recent years, the whole gamut of the non-IBM computing world\nhas also gained a presence at SHARE.  SHARE is no longer a \"purely IBM\"\norganization.  Through the SHARE Exhibition Area, vendors from all walks\nof computing fill the SHARE exhibition hall with useful information\nabout computing tools to solve your shop's problems.  (Even NaSPA has\na booth--shhhhh!)\n\n\nSHARE Membership\n\n      SHARE Membership is different now, than it was in former times\n(10 or more years ago).  There are no longer any hardware requirements\nnecessary for an organization to join SHARE.  (In former days, you had\nto be running a big-enough mainframe.)  There's also a very relaxed\nrequirement for sending a representative to the SHARE meetings.  A\nmember orgainization used to have to send at least one representative\nto a SHARE conference, once a year, or the membership would be revoked.\nNowadays, this requirement is much relaxed.  SHARE management is very\naware that many companies have limited conference budgets nowadays.\n\n      For a company (or an individual) to become a member of SHARE, all\nyou have to do is fill out an application, and plunk down a one-time\ncost of $250.  This can even be done online, through SHARE's web site\nat www.share.org .  Since there's no longer any hardware requirement, an\nindividual with a one-person company can also become a member.  I'm a\nmember of SHARE, myself.  As a SHARE member, even if you can't attend a\nSHARE meeting (i.e. conference), you get all the SHARE conference\nproceedings on cd-rom, and you get all the SHARE notices and\nannouncements.  You also get access to the \"Members Only\" portion of the\nSHARE web site.  (With the latest SHARE conference, individuals can now\nget their own \"members only\" userids.  If you attend a conference, you\nget your own userid and password emailed to you.)\n\n\nAttending the SHARE Conferences\n\n      The SHARE conferences are now held twice a year, once in the\nwinter, and once in the summer.  The two spring and fall \"minor\nconferences\", which were largely for organizational purposes, have now\nbeen eliminated, since SHARE's member organizational work can now be\ndone electronically, through email communication.  There's a conference\nfee, and unless you live in the same city where the conference is being\nheld, you have to pay a hotel bill and transportation expense.  However,\nthe cost for a company to send somebody to SHARE is often less that that\nof a class, or a different conference.  Usually, the benefits are\ngreater.\n\n      This SHARE conference in Boston was my thirteenth SHARE.  The\nfirst four were paid for by my employer, and I've footed the bill for\nthe last nine, myself.  I think it's worth that much sacrifice!\n\n      Prior planning is absolutely essential to get the most out of a\nSHARE conference.  Since so many computing disciplines and areas are\nrepresented, each time slot has from 20 or 50 different sessions you\ncan choose from.  A company can benefit by sending several different\npeople from several different areas, to cover the ground.  For each\nindividual, planning pays.  You should download the SHARE conference\nscheduler program from the www.share.org , and spend a good few hours\nworking out your schedule, before you even get there.  There are about\nsix normal session slots scheduled each day, for the entire week, until\nFriday noon.\n\n      Evenings can be spent enjoyably working, too.  It used to be every\nnight, but now, three nights a week are given to SCIDS, which is some\nacronym indicating Social Contact time.  Everybody can go to a big\nballroom, which is open for 5 hours, and mix with anybody else, from\nperhaps a different discipline, or perhaps from the same one.  If you\ndidn't get a chance to meet somebody, because you were each going to\ndifferent sessions all day, you can make up to meet and talk at SCIDS.\n\n      In the early evenings, people organize what are called BOF (Birds\nof a Feather) sessions informally.  At the beginning of the SHARE week,\nanyone wishing to organize a BOF session will post a request on the\nSHARE bulletin board, and if there are enough signers to the request, a\nroom and a time will be assigned for the session.\n\n      Through all these means, a company can send its people to SHARE\nand get all their questions answered, even the cross-discipline ones.\nAnd the answers will probably come from an authority in the field.  I\nthink that most veteran SHARE attendees will agree that SHARE is not a\nholiday, but a treasure-trove of computing knowledge and knowledeable\npeople, to be drawn upon for months and years to come.\n\n\nBenefits for the Employer.\n\n      To me, it seems very common for most employers to miss the point\nof SHARE.  They might send people to IBM conferences, but they forget\nthat the information presented, though plentiful, is also sanitized.\nYou don't get the \"gotchas\" from users with experience.  And you don't\nalways speak to the developers.  Information that IBM doesn't want\nmentioned, is not imparted.  At SHARE, you get it all!  People\ngenerally aren't inhibited at SHARE.  Even the IBM'ers will tend to be\nmuch more \"personal\", relaxed, and frank than they usually are, to us\ncustomers.\n\n      The enormous cross-discipline presence at SHARE is also largely\nunderestimated.  At a SHARE conference, there is an tremendous\naccumulation of raw knowledge in one place.  In past years, I've been\nsent to SHARE as an \"MVS person\", and I've brought back VM and PC\nknowledge as well.  Nowadays, with all the other computing systems, and\nwith everybody doing UNIX and complex networking, there are plenty of\nanswers at any SHARE meeting.  A company can never bring an employee to\nany other conference or class, and give that employee the same exposure\nto information and clear answers, as there is at any one full week of\nSHARE meetings.  It's next to impossible.  I'll challenge anyone to\ntell me where you can spend one week and get more exposure to the\nanswers you need, than at one SHARE week!\n\n      I hope this month's column whets your interest.  Even if you\ncan't go to the next conference, you can start finding out what SHARE\nis about by looking at www.share.org .  But the raw excitement of a\nSHARE meeting is inimitable and irreplaceable.  To me, it's a \"must\"\nfor every MVS practitioner to get to a SHARE conference at least once.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BM0806JN": {"ttr": 778, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x002\\x01\\x08&_\\x01\\x08&_\\x11\\x03\\x01\\xcb\\x01\\xc2\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2008-09-21T00:00:00", "modifydate": "2008-09-21T11:03:32", "lines": 459, "newlines": 450, "modlines": 0, "user": "SBGOLOB"}, "text": "                    TSO/E CONTROL BLOCKS, AND MORE\n\nBy Sam Golob and Courtney Taylor\n-- --- ----- --- -------- ------\n(c) 2008 by Sam Golob\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also\nparticipates in library tours and book signings with his\nwife, author Courtney Taylor. Sam can be contacted at\nsbgolob@cbttape.org and/or sbgolob@attglobal.net.\n\n  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n      IBM owns the z/OS operating system.  Therefore, IBM can take\nliberties in the way they design and write programs for z/OS (and MVS in\ngeneral) which we, as outsiders, can't get away with.  In a way, this is\ngood for us as MVS administrators.  We'll explain.\n\n      We often see the word \"control blocks\" mentioned, when it comes to\nMVS system coding.  What IBM does, to create control blocks, is that at\nsystem initialization time, MVS obtains lots of pieces of common storage\n(accessible by all address spaces) which it loads with values that are\nused and modified by the system programs.  Rather than keeping constants\nthat are used by the system programs within the programs themselves (the\nway WE do when WE code), MVS's programs are usually made to reference\nconstants, values, and bit settings that are EXTERNAL TO THEMSELVES.\nThese values reside instead, in certain blocks of common storage that\nremain accessible at all times, through paths that are documented and\nwell known.  These related areas of storage containing the quantities\nneeded by the system, are thus called \"control blocks\".  Control blocks\nare related blocks of storage containing quantities that are used to\ncontrol the system and the system's programs.  Again, the reason why we\nneed control blocks, is to contain common values and bit settings that\nare EXTERNAL TO THE SYSTEM PROGRAMS but which control and manipulate\nthem.\n\n      The layouts of most control blocks in MVS (read z/OS or whatever\nyour flavor of MVS is) are described by pieces of source code called\nMACROS, and you can see what's in the publicly known IBM macros by\nlooking at the \"System Data Areas\" books for your release of MVS.  Or\nyou can find most of the macros, in machine-readable form, in either of\nthe SYS1.MACLIB or SYS1.MODGEN pds'es that reside on your system.  But\nthe important facts for us to know, regarding any control block, are two\nthings.  One, is the path through system storage on which to go, in\norder to reach that particular contol block itself.  And two, is the\nlayout of the data in that control block.  In other words, we first have\nto GET THERE, and then once we're there, we have to know WHAT DATA IS\nTHERE.\n\n      Knowing all this, we can now get around to saying why it's an\nadvantage for us, as MVS administrators, to have the significant\nMVS-controlled values BEING EXTERNAL to the programs which control them.\nThe reason is that most often, THE ACTUAL VALUES are the most important\nthings for us to know, rather than the details of the programming which\nmanipulates them.  Practically speaking, we find that we don't really\ncare too much how the programs manipulate the values.  We just care WHAT\nTHE VALUES ARE.  So IBM can change the programming in a specific system\nprogram, but if it doesn't affect how a control block value is used, we\ndon't really care.  Therefore, this takes the worry of the system's\nprogramming code away from us.  We just want to follow the significant\nsystem VALUES.  The way they are used and controlled by the programs,\ndoesn't usually affect us too much.\n\n\nA REAL-WORLD EXAMPLE\n\n      Let us show you a good example about how this works.  The TSO/E\nTRANSMIT (or XMIT) command converts a complex dataset such as a pds (a\npartitioned dataset) into a simple FB (fixed blocked) sequential dataset\nwith LRECL (record length) equal to 80.  The reason for the conversion\nis so the dataset may be transmitted over NJE lines to another system,\nand once there, it is reconverted back to its original form by a TSO/E\nRECEIVE command running on the destination system.  When IBM designed\nthis method of data transmission, they wanted the installation to\ncontrol the size of datasets which could be so transmitted over their\nexisting lines.  If one dataset was too large, the line would be tied\nup while that dataset was going through, and no other transmissions\nwould be able to take place for a while.  Anyone who has ever\nadministered a set of transmission lines, is very familiar with this\nscenario.\n\n      So IBM has provided a place in PARMLIB, in the IKJTSOxx member,\nwhere the maximum number of output lines from an XMIT command can be\ncontrolled.  This is a \"system-wide\", global value.  This value is\nplaced into the system in any of three ways:  At IPL time, the system\ninitialization processes read the IKJTSOxx member and create a control\nblock (called the INMXPARM control block) that contains this limiting\nvalue in one of its fields.  Or, after IPL time, either a PARMLIB\nUPDATE(xx) TSO command is issued to re-create the INMXPARM control block\nin common storage from the new values in the (same or a different)\nPARMLIB member.  Or, a SET IKJTSO=xx operator command gets issued by an\noperator, which has that same effect.  The net result is that the\noutlimit value in the INMXPARM control block will cut off the creation\nof the FB-80 sequential dataset in the middle, if its length exceeds\nthat cutoff value.  Originally, there were no exceptions.\n\n      But there is a problem with this setup.  The XMIT command has an\noptional parameter called OUTDSN(your.dataset.name) that causes the\nreformatting of the initial dataset into the new sequential dataset\ncalled 'your.dataset.name', which is in FB-80 sequential format, but it\ndoesn't actually transmit that reformatted data anywhere.  It just\nplaces the reformatted data into dataset 'your.dataset.name' on the same\nMVS system.  Thus, if the OUTDSN keyword is used in an XMIT command, NO\nTRANSMISSION OVER DATA LINES ACTUALLY OCCURS.  Therefore we might ask\nthe question:  Why should we impose an artificial limit on that data, if\nit isn't going to clog any transmission lines?  Until z/OS 1.9 where it\nseems this problem was addressed by IBM, we either had to increase the\noutlimit value by doing a PARMLIB UPDATE(xx) TSO command or a SET\nIKJTSO=xx operator command.  After z/OS 1.9, it seems that when\nOUTDSN(your.dataset.name) is coded in an XMIT command, and the output\ndataset is larger than the limit, that XMIT command is nevertheless\nallowed to continue past the limit, to its completion.\n\n      By the way, I myself have addressed this problem to deal with that\nsituation in an unobtrusive way.  I wrote two TSO commands, which can be\nfound on either the CBT page or the Updates page of www.cbttape.org as\nFile 731.  The first command, called INMXD, will display the current\nsettings in the INMXPARM control block that is on your system.  The\nsecond command, called CINMX, which has to run APF-authorized, can\nchange three of the quantities in the INMXPARM control block.  CINMX\nnnnnn will reset the outlimit value for the XMIT command.  CINMX W nnnnn\nwill reset the Warn Threshold value for the XMIT command.  And CINMX I\nnnnnn will reset the Warn Interval value for the XMIT command.  Thus, if\nyou have authority to run the CINMX command (and of course, if you have\ninstalled it on the system), you can adjust these values in the existing\nactive INMXPARM control block, without having to make any PARMLIB\nchanges.  But after z/OS 1.9, if all you want to do is to reformat your\ndataset with the OUTDSN( ) keyword of the XMIT command, you probably\nwon't need these commands to perform any circumventions of the existing\nvalues.\n\n      Anyway, the net result of all this, is that we've shown you one\nthing:  We don't care how the XMIT command is really programmed.  We\njust care about what its limiting value is set to.  And this shows us,\nin one easy lesson, how important the \"control block\" design is for MVS.\nThe control block design simplifies MVS administration for us, by\nlessening the requirement for us to know about the details of MVS\ninternal code.\n\n\nMORE ABOUT TSO CONTROL BLOCKS\n\n      Now we'd like to talk about how to get to TSO/E control blocks\nin general.  There is a lot of history involved here, but we can get a\nquick start by first talking about modern MVS systems (recent z/OS\nreleases), and how things with TSO work there.\n\n      The starting point for MVS control block searches is almost always\nthe CVT (Communication Vector Table) that is described by the CVT macro\nin SYS1.MACLIB on your system.  All programs can get to the CVT by\npointing at the address location at virtual address X'10' or decimal 16\nfrom the beginning of low storage.  An alternative pointer to the CVT,\nnot known by many people, is located at virtual address X'4C'.  At X'9C'\noff the beginning of the CVT is a pointer to the TSVT or TSO Vector\nTable.  That's where we start to look for TSO information.\n\n      Because we want to limit our discussion of TSO control blocks to\nthose created by the IKJTSOxx PARMLIB member, we have to say that most\nof those control blocks are pointed to by the TPVT (TSO Parmlib Vector\nTable) control block whose address is at X'4C' off the beginning of the\nTSVT.  The TPVT control block is not documented officially by IBM, so we\nhave to construct our own map of it.  Please see Figure 1, which\ncontains our map of the TPVT.\n\n      If you'll take a look at the z/OS Initialization and Tuning\nReference (SA22-7592) and look at the IKJTSOxx member documentation,\nyou'll see various settings.  Each of these settings determines a\ncontrol block location in Common Storage (mostly above the 16M line).\nThe various settings are:  ALLOCATE, AUTHCMD, AUTHPGM, AUTHTSF, HELP,\nNOTBKGND, CONSOLE, PLATCMD, PLATPGM, TEST, TRANSREC, and SEND.  See\nFigure 2, which will show you the locations of these control blocks,\nstarting off the beginning of the TPVT, which are created from these\nrespective IKJTSOxx settings.\n\n\nUSING THE \"LOOK\" FREE TSO COMMAND AS AN AID TO EXPLORE\n\n      Because of lack of space here, we are going to leave it to your\nown initiative, to explore your own system.  But before doing so, we'll\ngive you a good tool to do that with.  The tool is called LOOK, and it\nis a full screen TSO command.  LOOK is absolutely free, and it is found\non File 264 of the CBT Tape collection of free MVS programs and tools\n(www.cbttape.org).  Instead of first looking at the CBT section of\nwww.cbttape.org, I'd suggest that you try the Updates section of\nwww.cbttape.org first, to see if there's a newer version of File 264\nthere.\n\n      The LOOK program is a full screen core browser that contains tools\nto make it easy to follow a chain of control blocks.  Now we'll show you\nhow.  The subcommand of LOOK which does that, is called \"J\".  If you say\nJnnnnnnnn, where nnnnnnnn is an address in 32-bit virtual storage, LOOK\nwill display the storage pointed to in that address, and all addresses\nfor 256 bytes further, on a full screen.  If you are at a certain\nstorage location, and you say J+xx where xx is a Hex number, LOOK will\ndisplay the storage pointed to by the location at xx OFF OF the current\nlocation.  This is the equivalent of a LOAD instruction in Assembler\nLanguage.  If you want to go further in storage (the equivalent of a\nLOAD ADDRESS instruction roughly), just use a \"+\".  Thus, to display\nX'432' bytes in storage further, you just say +432 in the LOOK\nsubcommand area at the top of the screen.  And you can use a minus or\n\"-\" to similarly go backward in storage from the current location.\n\n      We can illustrate how LOOK works by referencing Figure 2.  Suppose\nwe want to look at the AUTHCMD table IKJEFTE2 in storage.  First we get\nto the CVT by saying J10.  Remember that virtual X'10' contains the\naddress of the location of the CVT.  Then we say J+9C to point to the\nTSVT (TSO Vector Table).  Then we say J+14 to point to the CTLT table.\nThen we say J+8 to point to the IKJEFTE2 table.  That's ALMOST all that\nthere is.  To go back to the previous screen, we say PF9.  One more\nthing.  LOOK also has a built-in HELP facility which you can access by\npressing PF1 and you exit by pressing PF9.  Knowing this much, you can\nalready invoke LOOK and start searching through control blocks by\nyourself.\n\n      But not so fast.  There is at least one more thing to explain, and\nwe'll tell you what it is.  Besides displaying the raw data in control\nblocks, LOOK can also FORMAT control blocks as it displays them.  See\nFigure 3 for an example of a formatted control block, and see Figure 4\nfor how LOOK displays the same data, unformatted.\n\n      How does the formatting work?  Actually it works quite cleverly.\nAnd the formatted layout, set up according to the fields described by\neach control block's own mapping macro, is created directly from the\nmacro itself.  A separate CSECT called CBMACS is assembled using all the\nreal macro layouts, and CBMACS is linkedited together with the LOOK load\nmodule.  If the control block exhibits a telltale sign that CBMACS\n\"knows about\", a formatted pattern will appear on the full LOOK screen\nautomatically instead of just a raw storage dump.  Again, see Figure 3\nto see a formatted control block, and Figure 4, to see the same data,\nunformatted.\n\n      If you use LOOK to navigate through a formatted control block\ndisplay, then you use a command called \"L\" instead of the command called\n\"J\".  I'll show you an easy example.  When you say J10 to point LOOK to\nthe CVT, LOOK will automatically format the CVT.  In a formatted version\nof the CVT, the pointer to the TSVT is called \"TVT\".  So, from the\nformatted CVT screen, you can get to the TSO Vector Table by saying the\nsubcommand LTVT.  The TSVT control block, in turn, is also formatted.\nSo you can get to the TPVT control block from there, by simply saying\nLTPVT.  This is simple, once you get the hang of it.\n\n      There is one more caveat to using LOOK, this one being of very\nrecent origin.  This situation came up with z/OS 1.8 originally, and it\nis critical to know about when you are running MVS at the z/OS 1.9\nlevel.  It just so happens that LOOK will allocate common storage in Key\n8, which is a user storage key.  Starting from z/OS 1.8 and onward, an\ninstallation can prohibit common storage allocation in a User Key by\ncoding VSM ALLOWUSERKEYCSA(NO) in the active DIAGxx member of PARMLIB,\nand by issuing a SET DIAG=xx operator command for a DIAGxx member where\nVSM ALLOWUSERKEYCSA(NO) is coded.  At the z/OS 1.9 level, VSM\nALLOWUSERKEYCSA(NO) is the default setting.  But for LOOK to work on\nz/OS 1.9, that has to be reversed by coding a (YES) setting of the same\nparameter.  Doing that isn't exactly the safest thing to do, especially\nin a commercially active installation, since Key 8 storage can be\nchanged by anyone.  We DO have a solution to this situation.  I have\ncoded an APF-authorized TSO command which turns this \"allow Key 8\nstorage in CSA\" setting ON, or OFF, and you can change the setting for a\nshort time.  My program is called UKEYCSA, and it can also be found on a\n(recent) copy of CBT Tape File 264 (see the Updates page at\nwww.cbttape.org).\n\n      So, if you are using LOOK to view storage in a \"sandbox MVS\nenvironment\" such as a test system, where it is safe to code VSM\nALLOWUSERKEYCSA(YES) in the DIAGxx member of PARMLIB, all is well and\ngood, and you can use LOOK as is.  But if you have to code (NO), or when\nyou're using the z/OS 1.9 default, and then you try to use LOOK, you'll\nget a SB0A, reason code 5C abend.  So to remedy the situation on the\nfly, we have written an APF-authorized TSO command, found in CBT Tape\nFile 264 together with LOOK, called UKEYCSA, which can turn the\nallowance of User Key allocation in CSA on or off on the fly.  UKEYCSA Y\nallows User Key allocation in CSA, and UKEYCSA N turns it off.  This\nway, you can use LOOK for a few minutes, even if VSM ALLOWUSERKEYCSA(NO)\nis the default in your installation.  But you need to have the authority\nto run the APF-authorized TSO command UKEYCSA, in order to do this for\nyourself.  And you're exposing the installation to a remote possibility\nof risk for short intervals at a time, when you do this.  But it's\ncertainly much safer to use the UKEYCSA program for a short interval of\ntime, rather than allowing User Key allocation of common storage ALL of\nthe time.\n\n      Caveats aside, LOOK is a marvelous tool to look at (and trace)\ncommon storage control blocks in (nearly) real time.  And you can learn\na ton of system information if you use the LOOK command often.  This\nincludes learning about all of the TSO-related control blocks mentioned\nhere.\n\n\nSUMMARY\n\n      We hope that this article will open your eyes to exploring your\nMVS (read z/OS or OS/390 etc.) system further.  It's true that whenever\na system control block can be changed by a PARMLIB setting and a SET\ncommand, all of its controlling values are present in common storage\nsomewhere.  These values are always accessed by following a documented\npath, as you step through control block pointers, usually starting from\nthe CVT.  TSO/E control blocks that were created by the IKJTSOxx PARMLIB\nmember, are no exception, as we have shown here in Figure 2.  Figure 2\ncompletely documents the control block pointers whose origin comes from\nthe IKJTSOxx PARMLIB member.\n\n      To graphically illustrate the specific principles outlined here,\nwe've provided you with a free \"core browsing\" tool called \"LOOK\", which\nis obtained from the CBT Tape collection (www.cbttape.org - Updates page\nor CBT page), File 264.  LOOK will graphically show you in fullscreen,\nthe contents of much of the control block information in your system.\nSo besides the specific knowledge we've conveyed about the TSO-specific\ncontrol blocks on your system, we've also opened the way for you to\ndiscover much more.\n\n      We wish all of you the best of everything personally, and we hope\nthat you will gain a lot of knowledge and \"MVS street smarts\", as you\ncontinue to safely explore your MVS system, well into the future.\n\n\n  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\nFigure 1.   Layout of the TPVT control block, figured out by\n            experiment.\n\n         MACRO\n         IKJTPVT\nTPVT     DSECT                         TSO PARMLIB vector table\nTPVT_ID  DS    C'TPVT'                 BLOCK ID\nTPVT_LEN DS    H'72'                   LENGTH OF TPVT (OLD TPVT FORMAT)\n****     DS    H'220'                  LENGTH OF TPVT          HTE26E2\nTPVT_VERS DS   FL1'2'                  VERSION\nTPVT_MEM1 DS  0C'IKJTSO00'          07 (OLD TPVT FORMAT)       HTE25E2\n         DS    X                                               HTE26E2\nTPVT_MEM DS    C'IKJTSO00'          08 ACTIVE PARMLIB MEMBER   HTE26E2\nTPVT_GEN DS    F                       PARMLIB generation count\nTPVTCTLT DS    A(CTLT)              14 IKJCTLT (Auth tables)\nTPVTCTLT_LEN DS F'60'                  length of CTLT\n         DS    4X\nTPVTSEND DS    V(SCB)               20 IKJEESCB   (SYS1.BRODCAST)\nTPVTALPL DS    V(ALPL)              24 ALPL       (ALLOCATE defaults)\nTPVTTEST DS    V(TPT)               28 TPT        (TEST)\nTPVTXPRMD DS   V(XPRM)              2C INMXPARM   (XMIT)\nTPVTCONSOLE DS V(CNPRM)             30 IKJCNPRM   (CONSOLE)\nTPVTFCVEC DS   A,F                  34 FCVE       (Platform commands)\nTPVTHELP  DS   V(HCB)               3C IKJEFHCB   (HELP)\nTPVTPPVEC DS   A,F                  40 PPVE       (Platform programs)\n           ORG  TPVT+X'50'\nTPVTDSNAM  DS  CL44'SYS1.PARMLIB'   50 dsname                  HTE26E2\nTPVTVOLSER DS  C'SYSCAT'            7C volser                  HTE26E2\n           DS  2X                                              HTE26E2\nTPVTSNAME  DS  CL8'P390'            84 from system             HTE26E2\nTPVTUSERID DS  CL8'**IPL**'         8C by userid               HTE26E2\nTPVTHHMMSS DS  CL8'16:59:56'        94 at hh:mm:ss             HTE26E2\nTPVTYYMMDD DS  C'1998-10-29'        9C on yyyy-mm-dd           HTE26E2\n           DS  X'0600,00000001,7490,16595156,19981029'         HTE26E2\n         ORG   TPVT+X'DC'              end of TPVT             HTE26E2\n         MEND\n\n\n  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\nFigure 2.   Locations of the Control Blocks created by the\n            IKJTSOxx PARMLIB member.  Starting reference is the\n            TPVT control block, pointed to at +X'4C' off the\n            beginning of the IKJTSVT (TSO Vector Table) control\n            block.  The location of the TSVT control block is\n            at +X'9C' off the beginning of the CVT.  The CVT is\n            pointed to, at virtual location X'10' or decimal 16.\n\n\nALLOCATE -  X'24' points to ALPL control block.\nAUTHCMD  -  X'14' goes to CTLT.  X'8'  off CTLT gets IKJEFTE2 table.\nAUTHPGM  -  X'14' goes to CTLT.  X'14' off CTLT gets IKJEFTE8 table.\nAUTHTSF  -  X'14' goes to CTLT.  X'2C' off CTLT gets IKJEFTAP table.\nHELP     -  X'3C' points to IKJEFHCB control block.\nNOTBKGND -  X'14' goes to CTLT.  X'20' off CTLT gets IKJEFTNS table.\nCONSOLE  -  X'30' points to IKJCNPRM control block.\nPLATCMD  -  X'34' points to FCVE if it exists, if not, X'00000000'.\nPLATPGM  -  X'40' points to PPVE if it exists, if not, X'00000000'.\nTEST     -  X'28' points to TPT.\nTRANSREC -  X'2C' points to INMXPARM control block.\nSEND     -  X'20' points to IKJEESCB control block.\n\n\n  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\nFigure 3.   A formatted LOOK screen with the fields and their\n            contents laid out.  The IKJTSVT (TSO Vector Table)\n            control block is laid out, according to the fields\n            in the mapping macro IKJTSVT.\n\n\nLOOK COMMAND - DISPLAY VIRTUAL MEMORY      DISPLAY ASID= 004C\nENTER CMD -\nLAST CMD  - J+4C\n                          00CB0140  TSVT\n TSVT    TSVT      LEV     .   FLG1   NCT     11779158 VACC    00CE0A4E\n ASF     00CCD1E0  LTBL    00D95B30  FLA1    83E19000  CTIO    80D9A000\n CTAB    83E15030  T440    83EA16AE  T441    83EBB910  PUTL    83EB2028\n PTGT    83EB2F18  GETL    83EB651E  STCK    83EAD220  TSL     80CD0990\n SCAN    83EC1000  PARS    83E80000  EF02    83E72000  TPVT    117A16D0\n RCVY    84A829B0  TRAN    83EC3000  BCMT    ...B....\n CAF     83E463D8  LVER    3   LREL    08    LMOD    0 CTDB    83273B88\n RIF     83269370  RAF     83E3C000  RTRP    83EBE000  TBLS    00CE0A30\n ADTB    83680EB8  TBLR    83EDED20  ESTK    84074E98  TVAR    840C55E8\n INIT    84090910  OLAR    80D7E000  TO00    840C0000  T44X    83EA0CC8\n FTS2    83E41000  EXE     8408D4E8  INOU    8408F8D8  LOA     8408FCB0\n TER     840BB7B0  SUBC    8408DE28  MSGI    840A81D0  EXCO    8408E1F8\n TERM    840A5B90  ETVP    00C9BAD0  TSFI    83E3F000  TSFT    82B0A868\n PCN1    00001A00  SNTA    1197A490  SVTA    1197AE48  SYML    00000B70\n XCFU    00000000  MSTR    00FDC400  BECB    808E8068  APPC    82886A40\n URPS    83EC5000  PCN2    00001A01  MSR0    83E74000  MDT@    8319F718\n\n\n1= HELP      2=           3= END        4=           5= REPEAT  6=\n7= BACKWARD  8= FORWARD   9= HIST BWD  10= HIST FWD 11=        12=\n\n\n  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n\nFigure 4.   The unformatted data on a LOOK screen, which is the\n            same data as on the formatted screen shown in\n            Figure 3.  This is the very same IKJTSVT control block\n            data.  To turn off formatting, we enter the command\n            ONULL.  To turn on formatting according to a particular\n            control block, we enter the command \"O\" joined to the\n            name of the control block, such as OTSVT.\n\n\nLOOK COMMAND - DISPLAY VIRTUAL MEMORY      DISPLAY ASID= 004C\nENTER CMD -\nLAST CMD  - ONULL\n\n00CB0140   >E3E2E5E3  07400000  11779158  00CE0A4E *>TSVT. ....j....+*\n00CB0150    00CCD1E0  00D95B30  83E19000  80D9A000  *..J..R$.c....R..*\n00CB0160    83E15030  83EA16AE  83EBB910  83EB2028  *c.&.c...c...c...*\n00CB0170    83EB2F18  83EB651E  83EAD220  80CD0990  *c...c...c.K.....*\n00CB0180    83EC1000  83E80000  83E72000  117A16D0  *c...cY..cX...:..*\n00CB0190    84A829B0  83EC3000  010000C2  00070001  *dy..c......B....*\n00CB01A0    83E463D8  F3F0F8F0  83273B88  83269370  *cU.Q3080c..hc.l.*\n00CB01B0    83E3C000  83EBE000  00CE0A30  83680EB8  *cT..c.......c...*\n00CB01C0    83EDED20  84074E98  840C55E8  84090910  *c...d.+qd..Yd...*\n00CB01D0    80D7E000  840C0000  83EA0CC8  83E41000  *.P..d...c..HcU..*\n00CB01E0    8408D4E8  8408F8D8  8408FCB0  840BB7B0  *d.MYd.8Qd...d...*\n00CB01F0    8408DE28  840A81D0  8408E1F8  840A5B90  *d...d.a.d..8d.$.*\n00CB0200    00C9BAD0  83E3F000  82B0A868  00001A00  *.I..cT0.b.y.....*\n00CB0210    1197A490  1197AE48  00000B70  00000000  *.pu..p..........*\n00CB0220    00FDC400  808E8068  82886A40  83EC5000  *..D.....bh. c.&.*\n00CB0230    00001A01  83E74000  8319F718  40000000  *....cX .c.7. ...*\n\n\n1= HELP      2=           3= END        4=           5= REPEAT  6=\n7= BACKWARD  8= FORWARD   9= HIST BWD  10= HIST FWD 11=        12=\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BM0901JA": {"ttr": 1031, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\t\\x00\\x7f\\x01\\t\\x00\\x7f\\x14\\x12\\x01\\x99\\x01\\x99\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2009-01-07T00:00:00", "modifydate": "2009-01-07T14:12:59", "lines": 409, "newlines": 409, "modlines": 0, "user": "SBGOLOB"}, "text": "                    TSO AUTHORIZATION TABLES\n\n(c) Copyright 2009 by Sam Golob.  All rights reserved.\n\n     TSO sessions rely on a set of tables containing program names, when\nthey test a TSO user's ability to run an APF-authorized program, or an\nAPF-authorized TSO command, or when they test if a TSO command can be\nexecuted under TSO-in-batch.  People outside of IBM do not generally\npossess definitive information about where these tables actually are,\nalthough they have general knowledge about how to change them.  In this\narticle, I hope to put most doubts to rest, and after reading this\narticle, you should have a very good idea about your TSO session's\nauthorization tables, where they are, and how they got there.\n\n\nHISTORY OF THE AUTH TABLES\n\n     In the \"ancient\" days, before TSO/E, which many of us still\nremember, the four CSECTs:  IKJEFTE2 (AUTHCMD), IKJEFTE8 (AUTHPGM),\nIKJEFTAP (AUTHTSF - which didn't exist then), and IKJEFTNS (NOTBKGND),\nwere linkedited into the IKJEFT02 load module (mainline TSO).  So I\nlearned a trick about what you should do, if you want to expand which\nprograms you would like authorized in your own TSO session.  The trick\nwas to make your own copy of the IKJEFT02 load module, stick it in an\nAPF-authorized STEPLIB that was in your TSO LOGON PROC, and linkedit\nyour own copies of the IKJTFTE2 and IKJEFTE8 CSECTs, in particular, into\nthat copy of IKJEFT02.  This worked fine and did the job.  You had your\nown personal command and program authorizations, which the other TSO\nusers did not have.  And that is what you, as the \"system doctor\",\nneeded to have, as opposed to what the \"ordinary users\" needed.\n\n     However, there was one problem.  When normal maintenance came in\nfrom the monthly PUT tapes, and hit the other CSECTs in IKJEFT02, or\nelse if a new version of TSO came out, either your own individual copy\nof IKJEFT02 didn't get the maintenance, or else you'd have to copy it\nover again, and re-linkedit the IKJEFTE2 and IKJEFTE8 CSECTs back again.\nIf you didn't do that, the result would be that your own TSO session\nwould become backleveled, often to the point where you'd get some abends\nthat you didn't really want.\n\n     Arrive TSO/E, with one improvement (among many other non-related\nones).  The four CSECTs:  IKJEFTE2, IKJEFTE8, IKJEFTNS, and IKJEFTAP\nwere taken out of IKJEFT02 and inserted into their own load module,\nwhich was called IKJTABLS.  IKJTABLS didn't contain any executable\ncode--it just contained program list tables.  The trick for the special\nuse of your own IKJTABLS was similar to that for IKJEFT02.  If the\nIKJTABLS load module was present in an APF-authorized STEPLIB in your\nTSO session, it would override the same-named CSECTs that were in LPALIB\nor wherever (which the public would use), and you yourself could get\nyour own personal special TSO command authorization.  But this time, the\nauthorization tables, being in a completely separate load module, were\nindependent of which TSO/E release level and maintenance level you were\nrunning.  The \"auth CSECTs\" were no longer connected to \"mainline TSO\",\nand when changing them, you would not interfere with applying normal TSO\nmaintenance.  So TSO itself was now in sync with current maintenance,\nand you had your own personal \"auth tables\" too.  This was a much better\nsituation than before.\n\n     The next improvement in TSO/E came because of the push within IBM,\nspurred on by banks and other institutions which had to remain up for 24\nX 7, to eliminate IPLs.  In the late 80's and early 90's, IBM made a big\neffort to convert hard-coded tables that were created at IPL time, to\ndynamically created tables in common storage, that could be re-created\nat any time after IPL, usually via an operator command.\n\n     Around this time, the IKJTSOxx PARMLIB member was created.  It was\ngiven the capability of renewing a copy of the TSO auth tables in common\nstorage, at any time, via the PARMLIB UPDATE(xx) TSO command.  The\nadvantage of this was obvious, making it possible for installations to\nauthorize commands and programs to TSO, whenever they wanted to do so,\neven in-between IPLs.  Later on, with TSO/E Release 3 (corresponding to\nz/OS 1.3), the SET IKJTSO=xx operator command was also introduced, and\nwas given the same power and action as the PARMLIB UPDATE(xx) TSO\ncommand.  The PARMLIB UPDATE(xx) facility was created first.  I think\nthat's because IBM wanted to give this \"dynamic auth\" capability to\nsystems programmers only, but later they relented, and realized that you\nneed an operator command too, sometimes.  Again, the advantage of the\noperator SET command, is that you don't need to have a TSO session up\nwhen you need to change something.\n\n     In modern z/OS systems, the default auth tables in the system are\ncreated from the default PARMLIB member IKJTSO00, or whatever IKJTSOxx\nmember is pointed to, by the active IEASYSxx member.  So at this point,\nwe have to realize that \"everybody else's\" TSO/E authorizations come\nfrom the PARMLIB member IKJTSOxx that is currently active.\n\n     Nevertheless, if your session's TSO/E authorizations come from a\ncopy of the IKJTABLS load module that is in an APF-authorized STEPLIB,\nthey will STILL COMPLETELY OVERRIDE the default tables.  That is because\nyour TSO session's LWA pointed-to tables were copied from your STEPLIB\nload library at LOGON time, instead of being copied from the\nPARMLIB-created copies of the tables in common storage.  We'll see how\nthis works, a bit later on.\n\n     However, if the PARMLIB member IKJTSOxx does NOT contain one of the\nkeywords:  AUTHCMD, AUTHPGM, AUTHTSF, or NOTBKGND, then that respective\ntable is defaulted from its copy in IKJTABLS that is in LPALIB.  Again,\nif your session has an authorized STEPLIB with IKJTABLS, then your\nSTEPLIB's IKJTABLS will override any other default table that is in the\nenvironment.  We'll discuss all these facts in much greater detail\nlater.\n\n\nTABLE LENGTHS AND TABLE DELIMITERS\n\n     At this point, I just want to interrupt the discussion to talk\nabout the lengths of the tables that were created by the PARMLIB TSO\ncommand (or by the SET IKJTSO=xx operator command).\n\n     When the PARMLIB processing creates one of its incore tables in\ncommon storage, the length of the created table is measured, and it is\nrecorded in the CTLT control block (some details to be discussed later).\nWhen the auth tables are created (for a user's TSO session) via their\nbeing copied from an IKJTABLS load module in STEPLIB, no lengths of\ntables are recorded in the system.  This is a big difference.\n\n     So the question is, if no table lengths are recorded, how does the\nsystem \"know\" where the table ends?  Answer is, that all the TSO auth\ntables are delimited by a blank table entry.  In other words, if the\nprogram name is 8 blanks, then all table entries after that point, are\nignored, and the table is deemed to end at the blank entry.  This is a\nVERY important fact for us to know.\n\n     Since we have the possibility of an \"auth table\" coming from any of\nseveral origins, there have to be \"flags\" in the system, telling you how\nto deal with that particular copy of that particular table.  The Logon\nWork Area (LWA), which we'll talk about later, contains such flags to\ndeal with a TSO session's auth tables that come from various origins.\nBut in any case, the bottom line is that A BLANK TABLE ENTRY WILL ALWAYS\nDELIMIT THE TABLE, no matter what its origin was.\n\n\nYOUR OWN COPY OF THE AUTH TABLES\n\n     Consider this.  It is almost universally true that when you set up\nan entry in a PARMLIB member (that is actively being used by the\nsystem), this entry gets translated into some information that is in an\nMVS control block in storage somewhere, usually in common storage.  And\nthe system itself \"knows\" how to get to that information, through an\nestablished path.  To summarize:  Information in a PARMLIB member will\n(almost) always translate into information in common storage, which the\nsystem can get to, via a known path.\n\n     There's a problem with information in common storage, especially\nwhen it comes to TSO.  The TSO developers always have to consider a case\nwhere a thousand TSO users are trying to LOGON to their TSO sessions at\nthe same time.  In a very large installation, it might happen, and the\nTSO developers have to consider this \"boundary condition\" (so to speak)\nas being one of their developmental constraints.  What happens when a\nthousand users (or any other large number) are trying to get to common\nresources?  There will be contention somewhere, and there will be a\nbackup in trying to get to some of the (common) resources that are shared\nby all (or many) of these TSO sessions.\n\n     One solution to this general problem, is to give each TSO user his\nor her own copy of a resource, rather than for the user to continually\ntry and access the common resource.  Then, contention (by many users)\nfor the common resource is minimized or eliminated.  This happened with\nthe TSO authorization tables:  IKJEFTE2, IKJEFTE8, IKJEFTAP, and\nIKJEFTNS (AUTHCMD, AUTHPGM, AUTHTSF, and NOTBKGND respectively).  At one\npoint in time, the TSO developers decided to GIVE EACH TSO SESSION its\nOWN COPY of these authorization tables.  The \"individual copy\" of these\nauthorization tables is created within the userid's address space at\nLOGON time, in Key 0, Subpool 252 storage, and they are pointed to by\naddress fields in the Logon Work Area (LWA) which is also created for\neach TSO userid at LOGON time.  Each TSO userid has its own unique Logon\nWork Area that was created for it.  And the LWA-pointed-to copies of the\nauthorization tables are the ones which your TSO session actually refers\nto!  Most people don't know this.  I ran a survey test question among\nold MVS veterans with 25 years of experience or more.  Most of them did\nnot know where the \"real\" TSO authorization tables were!\n\n     Getting back to the subject, how do the individual copies of the\nTSO \"auth tables\" get there?  At LOGON time, they are copied into\nGETMAINed storage in Key 0, Subpool 252 from any of several sources.  As\nfar as I can determine, the IKJEFTP1 TSO initialization module (executed\nat LOGON time) performs this construction process.\n\n     Where are the tables copied from?  Under usual circumstances, they\nare copied from either of two places.  One place, is from the \"common\nstorage\" tables that are created from the active IKJTSOxx PARMLIB\nmember.  If the keywords AUTHCMD, AUTHPGM, AUTHTSF, and NOTBKGND were\ncoded in the IKJTSOxx PARMLIB member, together with an appropriate list\nof program names, then \"TSO system initialization\" at IPL time will\ncreate several areas in common storage which contain these tables.\nThese areas can be \"renewed\" or \"re-created\" whenever you do a PARMLIB\nUPDATE(xx) TSO command, or a SET IKJTSO=xx operator command, provided\nthat you have changed the list of names in the IKJTSOxx member.  If you\ndo not issue a(nother) PARMLIB UPDATE(xx) command or a(nother) SET\nIKJTSO=xx command, then these tables remain in place, in common storage,\nfor the duration of the IPL.  When a TSO user does its LOGON, the \"auth\ntables\" are usually copied from the \"common storage\" version of these\ntables, which are intended for \"most TSO users\".  I'll talk about the\n\"second possible place\" soon, where it's possible for your TSO session\nto get its \"auth tables\".\n\n     For the record, if you really want to know where the \"common\nstorage\" versions of the \"auth tables\" are, you do as follows:  The CVT\nhas an address pointer to the TSVT (TSO Vector Table) at +X'9C' from the\nCVT.  The TSVT points to the TPVT (TSO Parmlib Vector Table) at +X'4C'\nfrom the TSVT.  The TPVT points to the CTLT control block at +X'14'.\nAnd the CTLT points to the rest of the table addresses.  The TPVT and\nCTLT are not documented by IBM for public use, and IBM doesn't give out\nmacros in the macro libraries which describe them.  However, approximate\ndescriptions of these control blocks, which were figured out by users,\ncan be found on CBT Tape File 731 in the MODGEN member, or in CBT File\n492 in the SHOWMACS member.  So the macros IKJTPVT and IKJCTLT in CBT\nTape File 731 or File 492 will do the job very well, for us.  I have\nwritten several commands:  ADIS, ASUB, and LSLT, which can be found as\nload modules in the LOADLIB member of CBT File 185, that can display\nand/or directly manipulate the \"common storage\" version of the \"auth\ntables\".\n\n     The second possible place for your TSO session to get its tables\ncopied from, will happen if two circumstances are true.  First, the TSO\nsession's LOGON PROC (i.e. it's JCL) has to contain a STEPLIB DD to an\nAPF-authorized load library.  Second, a properly linkedited copy of the\nIKJTABLS load module must be present in the STEPLIB library, with one,\nseveral, or all, of the CSECTs IKJEFTE2, IKJEFTE8, IKJEFTAP, and\nIKJEFTNS present.  In that case, TSO LOGON (the IKJEFTP1 program which\ncreates your session) will copy the \"auth tables\" individually from the\nappropriate CSECT in the IKJTABLS load module that's in your authorized\nSTEPLIB library, and put that table into Key 0, Subpool 252 storage,\npointed to by the Logon Work Area.\n\n     Remember now, that the LWA version of the \"auth tables\" are the\nones which your TSO session actually uses.  So if your TSO session has\nan APF-authorized load library as a STEPLIB in its LOGON PROC, with an\nIKJTABLS load module in it, then LOGON DOES NOT GET THAT TABLE from the\n\"common storage\" copy.  Therefore the STEPLIB version of the table will\nCOMPLETELY OVERRIDE the version of that table in common storage, which\nwas created by the (active) PARMLIB member IKJTSOxx.  Thus we see that\nyour \"auth tables\" for your TSO session can come from one of two places,\nEITHER, OR, BUT NOT BOTH!\n\n     What if AUTHCMD, AUTHPGM, AUTHTSF, or NOTBKGND are NOT coded in the\nIKJTSOxx PARMLIB member?  And additionally, there is no authorized\nSTEPLIB library, or it doesn't contain an IKJTABLS load module?  Then\nwhat happens?\n\n     In THAT case, the LWA will NOT point to the appropriate table in\nKey 0, Subpool 252 storage.  But it will merely point to the appropriate\ndefault CSECT:  IKJEFTE2, IKJEFTE8, IKJEFTAP, or IKJEFTNS that is in the\ncopy of IKJTABLS that is in LPALIB.  In that case, the LPALIB version of\nthe table will be the one which your session uses.\n\n\nNEW WAYS OF LOADING TSO AUTH TABLES\n\n     Dan Dalby has written a marvelous \"dynamic\" STEPLIB command (found\nin CBT Tape File 452) which can perform the creation of a STEPLIB in a\nTSO session, exactly the way IBM does it with JCL.  This STEPLIB command\nhas to be APF-authorized, but once it is, and you've used it, you've\ngiven your TSO session access to programs that it wouldn't otherwise\nhave had access to.\n\n     If Dan's STEPLIB command is executed against an APF-authorized load\nlibrary, the effect is exactly as if you have an APF-authorized STEPLIB\nin the JCL, but there is one great big difference when it comes to\nloading the auth tables into your TSO session.  Dan's STEPLIB command\nwas not in effect at your session's LOGON time.  If you have an\nauthorized STEPLIB, statically coded in the LOGON PROC, it WAS there at\nLOGON time.  Therefore, if the authorized STEPLIB was there at LOGON\ntime, and it has an IKJTABLS load module in it, the auth tables come\nfrom IKJTABLS.  But if the STEPLIB was NOT there at LOGON time, then the\ntables still come from the \"common storage\" tables that were created\nfrom the active IKJTSOxx PARMLIB member.  Therefore, even though you\nhave executed Dan's STEPLIB command against an APF-authorized load\nlibrary that contains a big IKJTABLS member, you don't have all the\npower you need to execute all the programs, because you are still using\nthe \"common storage auth tables\" and not the (presumably bigger) tables\nthat were coded in the STEPLIB.\n\n     How can we \"dynamically load\" the STEPLIB, and then \"dynamically\nload\" the tables after that?\n\n     Dan and I have independently written two programs which will do\nthis.  Dan's program is called LWATMGR (LWA Table Manager).  My program\nis called LLWA, or (re)Load the LWA.  These two programs can load a\nfresh set of auth tables, from any of 3 different sources, into Key 0\nSubpool 252 storage in your TSO session's address space, and then\nre-point the LWA pointers and flags to properly point to the new tables.\nYour TSO session will then honor the new tables, and not the old ones.\n\n     In addition to my LLWA program, I have written another program\ncalled TSUB, which manipulates pre-existing auth tables that are\npointed to by the LWA.  In functionality, LWATMGR will approximately\nequal the combined capabilities of LLWA and TSUB.  But they do have\nnon-overlapping capabilities too, so it would pay for you to learn about\nall three programs.  These programs are found in the CBT Tape collection\n(at www.cbttape.org on the Updates Page) in File 797.\n\n     In order to get full capability with your \"auth tables\" later, you\nwill have to pre-authorize just two programs in the AUTHCMD table.\nThese would be either STEPLIB and LWATMGR, or STEPLIB and LLWA.\nActually, if you have LLWA or LWATMGR loaded into an authorized load\nlibrary already, that your TSO session has access to, you just have to\npre-authorize either one of these, and you can include STEPLIB in the\nAUTHCMD (IKJEFTE2) list in your new freshly loaded tables.\n\n     So what we do, is to use LLWA or LWATMGR to load a fresh set of\nauth tables for your own TSO session.  And then, it doesn't matter what\nauth tables your TSO session used before.  The combined action of the\nSTEPLIB program and either LLWA or LWATMGR will then exactly duplicate\nthe effect of an authorized STEPLIB in your LOGON PROC, without your\nactually needing to have a special LOGON PROC for yourself.\n\n\nSOURCES OF AUTH TABLES FOR RELOADING\n\n     Both the LLWA and LWATMGR programs can load a new set of auth\ntables from either of 3 sources:  An IKJTABLS-like load module, an\nIKJTSOxx-like LRECL=80 PARMLIB-like dataset (sequential or a pds\nmember), or a raw list of program names, with LRECL=8.  This list of\nnames is as \"bare-bones\" a piece of input as you'll ever need, and it\ntakes very little disk space to store it.  In addition, the LLWA program\ncan convert either load library input, or PARMLIB-like input into the\nLRECL=8 list input, so you can conveniently store the lists away.\n\n     The LRECL=8 list input is most fascinating, in my view.  You\nspecify which table is being loaded, with a special 8-byte header.  For\nthe IKJEFTE2 table, the header in the list, is ---E2---.  For the\nIKJEFTE8 table, the header entry is ---E8---.  And similarly, ---AP---\nand ---NS--- will cause the reloading of those respective tables, with\nall the program name entries that follow that header (until encountering\neither the next header, or the end-of-file).  Again, the LLWA program can\nconvert either load-module input or PARMLIB-like input into LRECL=8\n\"name list\" input.\n\n     For details as to how to run the LWATMGR, LLWA, and TSUB programs,\nplease see CBT Tape File 797, which has source code for all of them, as\nwell as HELP members for them.\n\n     My recommendation would be to store all of your auth tables as\nLRECL=8 lists, as members of a pds.  The pds will take up very little\nroom.  For example if the blocksize of the pds is 6000, then 750 table\nentries will fit in just one block.  Therefore, the data to rebuild all\nof your auth tables will probably fit into just one block of data.  Now\nthat's compact!  If you want to hide your lists and store them offsite,\njust put the pds into TSO XMIT format and download it in BINARY to a PC,\ngiving the XMIT-format dataset any name you want.\n\n     You can sort-merge all of your auth tables to get one big list.  Or\nelse, you can just load \"specialty tables\" as the need arises.  You've\ngot a lot of power here.\n\n\nTHE EFFECT OF PARMLIB UPDATE(xx)\n\n     There's one more fact here, which you should know about.  There are\nflags in the LWA for each of the four tables, saying whether they were\nloaded into your TSO session (presumably at LOGON time) from PARMLIB or\nfrom a STEPLIB.  If the flag bit is 0, that table was presumed to be\nloaded from PARMLIB.  If that flag bit is 1, then the table is presumed\nto have been loaded from STEPLIB.  What happens to the tables for your\nTSO session, when a PARMLIB UPDATE(xx) is done, to change one or more of\nthe tables?\n\n     Well, IBM would like that every active TSO session should use the\nnew tables.  So the PARMLIB command goes around, across address spaces,\nvisits each active TSO session, and looks at each of its auth tables.\nIf the LWA flag for that table says that it came from PARMLIB, then the\nPARMLIB command replaces the given table with a new one, dynamically.\nSo the effect is that if OUR new tables were marked as if they came from\nPARMLIB, then a PARMLIB UPDATE(xx) command would overlay our work with\nthe common tables again.  Therefore, both the LLWA and LWATMGR commands\nwill mark their newly created tables as if they came from STEPLIB rather\nthan PARMLIB, so a PARMLIB UPDATE(xx) command would not re-overlay them.\n\n     An additional consequence comes out from this.  PARMLIB UPDATE(xx)\nhas the effect of making a global change to the auth tables.  Suppose we\nonly want to test a new set of auth tables on one session!  Then we use\neither the LWATMGR or LLWA commands to limit the effect of the new auth\ntable(s) to just the session that invoked them.  This way, we have a\nLOCAL change and not a GLOBAL change.  Thus we can use the new LLWA\nand/or LWATMGR commands to test a new auth table on only one TSO userid,\nwithout consequences for the rest of the TSO sessions in the LPAR.\n\n\nSUMMARY\n\n     The TSO authorization tables (AUTHCMD, AUTHPGM, AUTHTSF and\nNOTBKGND) which your TSO session uses, are local tables in your own\naddress space, that were either copied from the \"common storage\" tables,\ncreated from the IKJTSOxx PARMLIB member, or were copied from an\nIKJTABLS load module in a STEPLIB that is APF-authorized to your TSO\nsession.  The active tables are pointed to, and described, by addresses\nand flags in the LWA (Logon Work Area) which is unique to your TSO\nsession.  Your TSO session's auth tables are created during LOGON\nprocessing, at LOGON time, by the IKJEFTP1 program.  These can be\nreplaced later, by either of the authorized TSO commands, LLWA or\nLWATMGR, which can be found on the CBT collection (www.cbttape.org)\non the Updates page, in File 797.\n\n     The LLWA and LWATMGR programs can take new table input in three\nformats:  load module input, PARMLIB member type input, or LRECL=8 name\nlist input.  See File 797 for the details.  It is my experience that\nyour auth tables are most conveniently stored in LRECL=8 input, as\nmembers of a pds.  The LLWA program can convert auth table input from\neither load module format or PARMLIB-like format into LRECL=8 list\nformat, for convenient storage and later use.\n\n     I hope that this article will open your minds to being able to\ncustomize your TSO environment better, and with more flexibility.  Your\nrole as \"system doctors\" will be greatly enhanced by this knowledge and\nby these new capabilities.\n\n     Best of luck to all of you.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BM0902FE": {"ttr": 1284, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x19\\x01\\t\\x03\\x7f\\x01\\t\\x03\\x7f\\x13!\\x01@\\x01@\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2009-02-06T00:00:00", "modifydate": "2009-02-06T13:21:19", "lines": 320, "newlines": 320, "modlines": 0, "user": "SBGOLOB"}, "text": "               TSO AUTHORIZATION TABLES - Part 2\n\n(c) Copyright 2009 by Sam Golob.  All rights reserved.\n\nTOOLS TO MANIPULATE OR REBUILD THE AUTH TABLES:\nASUB, TSUB, LLWA, and LWATMGR\n\n      In our last article, we discussed the TSO authorization tables in\ngeneral, the fact that they consist of lists of program names, and we\nsaid something about what each of the lists accomplishes.  There are\nfour main lists:  These are AUTHCMD (module IKJEFTE2), AUTHPGM (module\nIKJEFTE8), AUTHTSF (module IKJEFTAP), and NOTBKGND (module IKJEFTNS).\nAUTHCMD lists all TSO commands that are allowed to run APF authorized\nunder your TSO session.  AUTHPGM lists all programs that can run APF\nauthorized when called by your TSO session.  AUTHTSF lists all programs\nthat can get authorized using the TSO Service Facility.  And NOTBKGND\nlists all TSO commands that cannot be run under TSO-in-batch.\n\n      As systems programmers, we all know how to set the lists of\nprogram names in each of these categories, by creating or modifying an\nIKJTSOxx PARMLIB member.  Then, once the member is created, we issue a\nPARMLIB UPDATE(xx) TSO command or a SET IKJTSO=xx operator command to\nput that member into effect.  What happens to the system as a result of\nthese commands, is what most people don't know about.  This is part of\nwhat we're going to talk about.  What comes next, though, will be some\ninstructions about how we can directly manipulate the in-core program\ntables that are constructed from the PARMLIB IKJTSOxx member.\n\n      When a PARMLIB UPDATE(xx) command, or an IPL, or a SET IKJTSO=xx\noperator command is issued, in-core tables:  IKJEFTE2, IKJEFTE8,\nIKJEFTAP, and IKJEFTNS are created in common storage.  These become\ntemplates for the corresponding tables that will belong to (almost)\nevery TSO session that will LOGON afterwards.  These common storage\ntables are pointed to by the CVT, the TSO Vector Table, the TSO PARMLIB\nVector Table, and the IKJCTLT control block.  Once you get to the\nIKJCTLT control block, you have the pointers to all of the in-core TSO\nauthorization tables.   The exact addresses are:  TSO Vector Table is\nX'9C' off the CVT.  The TSO PARMLIB Vector Table is X'4C' off the TSVT.\nAnd the CTLT is X'14' off the TPVT.  A map of the TPVT and the CTLT\ncan be obtained from the SHOWMACS member of CBT File 492 or the MODGEN\nmember of CBT File 731.  Maps of these last two control blocks are not\ndistributed by IBM.  We had to figure them out.\n\n\nMANIPULATING THE IN-CORE COPIES OF THE AUTH TABLES - THE ASUB COMMAND\n\n      I wrote an authorized TSO command called ASUB, which goes directly\ninto the in-core TSO auth tables created from the IKJTSOxx PARMLIB\nmember, and manipulates its table entries, which are program names.  The\nASUB program can be found on CBT Tape File 185, where the TSUB program\ncan also be found.\n\n      The ASUB program works as follows:  ASUB has three functions:\nDISPLAY an entry, or the entire table.  REPLACE a numbered entry in the\ntable, and BLANK the last entry in the table.  The syntax of the ASUB\ncommand is:\n\n      ASUB tta nnn pgmname\n\nwhere tt is the table name:  E2, E8, AP, or NS.\na is the action code, D for display, R for replace, B for blank.\nnnn is the specific numbered table entry you want to display or change.\npgmname is the new program name you want to Replace, for the\n   existing name that is in that table slot now\n\n      For example, ASUB E2D   will display the entire IKJEFTE2 table and\nlist all its entries.\n\n      ASUB E2D 55    will list only one entry in the IKJEFTE2 table, the\n55th one.\n\n      ASUB E2R 55 CQX  will replace whatever name was in the 55th entry\nof the IKJEFTE2 table, with the program name of CQX.\n\n      ASUB E2B   will erase whatever program name was in the last entry\nof the IKJEFTE2 table, and will replace it with a blank entry consisting\nof all spaces.\n\n      A blank entry always delimits the entire table, causing any\nentries after the blank entry, to be ignored.  For that reason, I did\nnot allow the B function of ASUB, to blank any entry in the middle of\nthe table, but if I had filled in the last entry of the table with a\nnon-blank program name, using the ASUB Replace function, the B function\nwill blank out this non-blank entry that I had put at the end of the\ntable.  This concept is very important for us, because when I discuss\nthe similar TSUB program later, I'll show you how TSUB can blank out any\ntable entry even in the middle of the table, and not just the last\nentry.  This is a VERY significant concept for us to grasp.\n\n      Since the ASUB program has to run as an APF authorized TSO\ncommand, its name has to be entered in the IKJEFTE2 (AUTHCMD) table list\nof program names, and its load module has to reside in an APF authorized\nload library.  Again, I must emphasize that ASUB does not modify a copy\nof the tables that is used directly by your TSO session.  The copy of\nthe tables that ASUB modifies, is the \"common storage\" copy of the table\nthat TSO LOGON uses to create your session's tables at LOGON time.  So\nif your TSO session was logged on, and you used ASUB to change one or\nmore table entries, the changes will only affect your TSO session after\nyou re-LOGON.  The effect of ASUB in manipulating the TSO auth tables\nis GLOBAL, and it affects the entire LPAR until another PARMLIB UPDATE\ncommand, or SET IKJTSO= command is issued, or until you IPL.  Every NEW\nTSO session to LOGON, will copy the table version which ASUB has\nmodified.\n\n\nGETTING YOUR TSO SESSION'S TABLES FROM STEPLIB\n\n      The TSO designers have created another way to build your TSO\nsession's \"auth\" tables at LOGON time.  If you are a sysprog or another\n\"special-type\" user, who was allowed by management to have a LOGON PROC\nin your TSO session with a STEPLIB DD to an APF-authorized load library,\nthen this is a special case, different from ordinary TSO users.\n\n      One other condition must be satisfied to create the special case.\nThe APF-authorized STEPLIB must contain a linkedited copy of a load\nmodule called IKJTABLS, that contains CSECTs IKJEFTE2, IKJEFTE8,\nIKJEFTAP, and IKJEFTNS, or some of these.  In this special case, at\nLOGON time, the LOGON processing will not copy your session's auth\ntables from the PARMLIB-created copies in common storage.  But it will\ndo a BLDL for the CSECTs from the STEPLIB, and if the CSECTs are there,\nLOGON will copy them from the authorized STEPLIB instead of from the\n\"common storage\" PARMLIB-created copies.  In this way, a \"special\" user\ncan have different \"auth tables\" than everybody else.\n\n      At LOGON time, there are differences to how the STEPLIB-created\ntables look, as opposed to the PARMLIB-created tables.  In the LWA, the\nSTEPLIB-created tables are marked as having zero length.  This has the\neffect of forcing the only delimiter to the tables, to be the first\nblank entry.  The system (in that case) has no other way of knowing how\nlong each table is.  On the other hand, when the tables are copied from\nthe PARMLIB-created \"common storage\" copy, the length of each table is\nfilled in, in an appropriate field in the LWA (Logon Work Area) for that\nparticular table and that TSO session.\n\n      One other difference exists between STEPLIB-created auth tables\nand PARMLIB-created auth tables for your TSO session.  This is, that the\nLWA for your TSO session contains a flag bit for each of the four\ntables, which is 1 if the table came from STEPLIB, and it is 0 if the\ntable came from PARMLIB.  The effect of this bit is as follows:  If the\nbit for that table is 0, then when some TSO session does a PARMLIB\nUPDATE(xx) command, or the operator issues a SET IKJTSO=xx command, all\nTSO sessions which have their tables marked as coming from PARMLIB, will\nget their tables overlaid and re-created, according to the new IKJTSOxx\nmember that is in effect.  If a table is marked as coming from STEPLIB,\nwith the bit set to 1, then overlay from a PARMLIB UPDATE(xx) or SET\nIKJTSO=xx command DOES NOT OCCUR.  This is understandable.  If a\n\"special user\" has special authorization permissions, he/she does not\nwant them overlaid by a global change for the rest of the TSO users.  So\nthat's why IBM designers put the STEPLIB bit there, in the LWA.\n\n\nMANIPULATING YOUR TSO SESSION'S OWN TABLES - THE TSUB COMMAND\n\n      To manipulate YOUR TSO SESSION's auth tables, or to change the\ncharacteristics of your TSO session's existing tables, I have written\nthe authorized TSO command called TSUB.  Except for its Display\nfunction, TSUB has to be APF-authorized, so its name has to be entered\nin your session's IKJEFTE2 (AUTHCMD) table.\n\n      The TSUB command is like the ASUB command, but with more added\ncapability, owing to the difference in the nature of the \"common\nstorage\" copy of the tables (created by PARMLIB) and the individual\nusers' copy of the tables, pointed to by the LWA.  ASUB works on the\n\"common storage\" copy of the TSO auth tables.  TSUB works locally, on\nYOUR OWN SESSION's copy of the TSO auth tables, pointed to by the LWA.\n\n      As a consequence, other differences between TSUB and ASUB are:\n\n1.  If you make a change to a table with ASUB, your TSO session will\n    only get the changes if you re-LOGON.  When you make table changes\n    with TSUB, the effect (to your TSO session) is immediate.  If you\n    re-LOGON after TSUB has made changes, all changes will be lost.\n\n2.  ASUB only deals with tables that were created from PARMLIB members,\n    and which therefore are marked with a length.  TSUB can get its\n    tables either from PARMLIB or from STEPLIB.  If your session's\n    tables came from STEPLIB, they do not have length values (in the\n    LWA) attached to them.  Therefore, TSUB can not easily \"blank\" a\n    \"last member\" of a table, because we don't really know where the\n    \"last member\" is.  So I allow TSUB to blank ANY member of a table.\n    This is potentially dangerous, but also potentially useful and\n    creative.  It depends on how much knowledge you have, and on how\n    responsible you are.  Fortunately, if you mess up with TSUB, you\n    can re-LOGON and set things back to the beginning state.  Not so\n    with ASUB.  With ASUB you have to re-issue PARMLIB UPDATE(xx) or\n    SET IKJTSO=xx to set things straight again.\n\n3.  ASUB only manipulates tables in common storage.  TSUB can ALSO\n    manipulate LWA fields that are connected to each of the tables.\n    The effect of a TSUB change is IMMEDIATE, but it only affects\n    your own TSO session.  Therefore, TSUB has extra action codes\n    possible.\n\n    Extra action codes associated with TSUB, which you don't have with\n    ASUB, are:\n\n    H - Alter the header of the table to make it look like it came\n        from PARMLIB.\n\n    L - Measure the table, to put a \"length\" field for it, in the LWA.\n\n    Z - Zero out the length field for the table in the LWA.  Force it\n        to be delimited only by the first blank entry.\n\n    S - Turn on the STEPLIB bit for the table in the LWA.  This has the\n        effect that a PARMLIB UPDATE(xx) or SET IKJTSO=xx command will\n        not overlay your session's table.\n\n    P - Turn off the STEPLIB bit for the table in the LWA.  Then a\n        PARMLIB UPDATE(xx) or SET IKJTSO=xx command will overwrite the\n        existing table when those commands are issued.\n\n    B - Blank any table entry.  With ASUB, you say E2B and you can only\n        blank out the \"last table entry\".  With TSUB, the B action must\n        be followed by a \"slot number\" to blank out, and it can be ANY\n        SLOT, even one in the middle of the table.  The effect of this\n        blanking, is to nullify ALL SUBSEQUENT NON-BLANK entries in the\n        table, and to stop reading the table at the blank entry.  That\n        is dangerous if you don't know what you're doing, but I can\n        think of some very creative ways of using this capability.\n\n\nMAKING COMPLETELY NEW TABLES WITH LLWA, LWATMGR, AND LWATEDIT\n\n      TSUB (and ASUB) deal with MODIFYING ALREADY EXISTING tables.  What\nif you wanted to forget about the existing table and load a completely\nnew one, with a whole set of new and/or different and extra entries?  If\nyou're dealing with your own TSO session's LLWA-pointed auth tables,\nthis is entirely possible, using a set of TSO commands:  LLWA and/or\nLWATMGR from CBT Tape File 797.  LLWA was written by me.  LWATMGR and\nits ISPF interface program, LWATEDIT were written by Dan Dalby.\n\n      To replace an existing table with a new table, a program has to\nGETMAIN some Key 0, Subpool 252 storage (for that, it has to be APF\nauthorized), the new table has to be constructed in storage and copied\ninto the GETMAINed area, and the field in the Logon Work Area, which\npoints to the requisite table, has to be re-pointed to the new table.\n\n      To modify the LWA, you also have to be APF authorized.  And before\na new table location is finalized, there are two more modifications that\nhave to be made.  If the table has a length value associated with it,\nthat length has to be plugged into the proper field in the LWA, and also\nthere is a bit in the LWA which states that this table came from STEPLIB\nand not from PARMLIB.  Our programs LLWA and LWATMGR set this bit on,\nbecause if it is not on, a future PARMLIB UPDATE(xx) or SET IKJTSO=xx\ncommand would overlay our new table in our address space, erasing our\nchanges.\n\n      The LLWA program, written by me, will replace one table, or all\nfour tables, from either of three sources.  The LWATMGR program, written\nby Dan Dalby, will deal with one table at a time only, but LWATMGR can\nalso create an entirely new table from the same three sources.  These\nsources are:  An IKJTABLS load module, similar to the one that you put\nin an APF authorized STEPLIB, or, an FB-80 IKJTSOxx PARMLIB-like member,\nor, an FB-8 (that is, LRECL=8) list of program names.  The FB-8 list of\nprogram names is headed by a \"header record\" that looks like \"---E2---\",\nor \"---E8---\" or \"---AP---\" or \"---NS---\", which tells you which table\nto build from the names that follow the header.\n\n      LLWA will create a new table with 30 blank entries at the end,\nwhich is my preference.  The extra blank entries allow you to add more\nnames with the TSUB program, one at a time.  Dan Dalby's LWATMGR program\nadds only one blank entry at the end, because his program can repeatedly\nFREEMAIN and GETMAIN storage for new tables as needed.  And LWATMGR has\nfacility to add or delete one program name at a time also.\n\n      Dan's LWATEDIT facility for creating a new table is quite amazing.\nYou execute the TSO command LWATEDIT under ISPF, and a panel comes up,\nasking you which table you want to update.  When you pick a table, you\nget the list of program names which that current table contains.  You\nthen can edit the list as you wish, copy names in and out, and then you\nSAVE it.  After you SAVE the list and when you exit it, LWATEDIT calls\nLWATMGR to automatically build a new table with just those entries.  So\nyou can actually EDIT your auth tables and customize them as your\ncurrent needs dictate.\n\n      LWATEDIT makes its table updates by calling LWATMGR, which must be\nAPF authorized.  Since LWATEDIT operates under ISPF, and ISPF does NOT\n\"like\" to be authorized, LWATEDIT must authorize LWATMGR using the\nAUTHTSF facility.  So when you use LWATEDIT, the name LWATMGR must reside\nin BOTH the AUTHCMD and the AUTHTSF tables.  When you use LWATMGR as a\nTSO command only, it need only reside in the AUTHCMD table.\n\n      Either LLWA or LWATMGR, whichever one you use, will have to be in\nthe AUTHCMD list, from the beginning.  Or else, TSUB has to be in the\nAUTHCMD list from the beginning.  Then TSUB can be used to put LLWA or\nLWATMGR in the AUTHCMD list, and after that, LLWA or LWATMGR will be\nused, to build a completely new list, with everything you want in it.\nThis is how you escalate your ability to do useful work for your\ninstallation.  Once you authorize TSUB as a TSO command, you can get all\nthe other commands and programs authorized.\n\n\nSUMMARY\n\n      The four TSO authorization tables, AUTHCMD (IKJEFTE2), AUTHPGM\n(IKJEFTE8), AUTHTSF (IKJEFTAP), and NOTBKGND (IKJEFTNS) that your TSO\nsession uses, are pointed to by fields in the LOGON WORK AREA (LWA)\nwhich is unique to your TSO session.  The LWA is created at LOGON time.\nOnce we authorize one program, for example the TSUB program, to modify\nan existing table, we can get all our other programs authorized, to our\nheart's desire.  This is done either by modifying one of the auth tables\nwith either TSUB or LWATMGR, or by building completely new tables using\neither the programs LLWA or LWATMGR.\n\n      The TSUB program can also modify any of the existing tables'\ncharacteristics, as reflected by fields in the LWA which refer to that\ntable.  These may be either the table's length (whether it has a length\nor not, and if it has, what the length is).  Or, it may be whether the\ntable is marked as coming from STEPLIB or not.  If the table is not\nmarked as coming from STEPLIB, then it is at risk of being overlaid by\na future PARMLIB UPDATE(xx) command or a SET IKJTSO=xx operator\ncommand.\n\n      The LLWA and LWATMGR programs can be used to create a completely\nnew auth table.  The LWATEDIT ISPF interface to the LWATMGR program\nallows you to ISPF EDIT your existing table entries, SAVE the EDIT, and\nbuild a completely new table from the EDIT.  This is an extremely\namazing capability, which I believe, never existed before.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BM1005MY": {"ttr": 1290, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Q\\x01\\x10\\x14\\x0f\\x01\\x10\\x14\\x0f#G\\x03\\x10\\x03\\x10\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-05-20T00:00:00", "modifydate": "2010-05-20T23:47:51", "lines": 784, "newlines": 784, "modlines": 0, "user": "SBGOLOB"}, "text": "                APF Authorized TSO Commands\n\n     What we're about - Ethics\n\nAn employee must make more money for his/her employer, than\nhe/she receives in salary.  Otherwise, hiring him or her, doesn't\npay.  (Think about it.)\n\nWe are the \"system doctors\" of the MVS (z/OS) operating system.\nWe have been hired to help the installation to function properly,\nand to stay up as much as possible.  We are there to ensure that\nthe installation receives as large a return on its investment, as\npossible.  As such, we must be TRUSTED to have the tools of our\ntrade, and to be trusted to use them properly.  Since we may be\ncalled upon to have to \"repair anything\", we need to have access\nto an APF-authorized load library for our own use.\n\nThis presentation will show us how to make fuller use of these\ncapabilities, to help your installation, and to help ourselves,\ntoo.\n\n      My 50-50, 100-100 rule\n\nWhen I started my first job, I realized two things:\n\nThe benefit is split between me (the worker) and the employer\n(the installation).\n\nI get 50 percent, and the employer gets 50 percent.  The employer\ngets 50 percent, which is the labor.  I get 50 percent, which is\nthe EXPERIENCE.\n\nBut the real truth is: That the employer gets 100 percent of the\nlabor, and I get 100 percent of the experience.\n\nThis is a win-win situation.  I have ALWAYS had this foremost in\nmy mind, at every job I ever worked at.\n\n     Invest some of your time in learning new things\n\nEverybody has busy times and \"less busy\" times.  My teacher Jeff\nBroido always encouraged me to invest a half hour a day to learn\nsomething new.  By doing this, you expand your knowledge, and the\ninstallation will eventually reap the \"interest benefit\" that\ncomes from your increased capability and knowledge.\n\nThis learning (in my case) never impacted the timeliness with\nwhich I got my assigned tasks done.  I always invoked the \"50-50,\n100-100 rule\" when I was working at a job.\n\nThe MVS (nowadays aka z/OS) operating system has many components\nthat require knowledge and understanding, both about how each one\nworks, but more importantly, about how they hang together.  Of\nutmost importance in this job, is the need to form mental\npictures about how the various and many components of the z/OS\noperating system fit together and work with each other.  This\nknowledge is not easy in coming.  It takes time and effort to\nlearn about each of the MVS (z/OS) system components and about\ntheir relationships, both on a superficial level, and on deeper\nlevels.\n\n     It pays to learn Assembler Language\n\nAssembler language for the IBM mainframe, is the closest language\nto the action of the machine.  Programming in Assembler language,\nyou can control anything that the machine does.\n\nIf you don't know Assembler language (yet), you can achieve good\nresults using REXX, but you can't get the benefit and control\nthat Assembler language gives you in dealing with all aspects of\nmachine operation.\n\nIBM helps you by providing system macros, and very considerable\nknowledge and tools, for an Assembler programmer to delve into\ncontrolling the system.  In my years of experience, I have to\npraise IBM very much for always providing a lot of tools to\naccess most of the internal components of the operating system.\nHowever, IBM has not been as good in providing actual system\ntools that do a job; in that department, they usually fall\nsomewhat short.  There is a good reason for this.\n\nIBM (internally) has to use their programmer resources to develop\nthe system itself.  Anybody who ever worked there, will realize\nthat they could not use their valuable (and \"well-paid\")\nprogramming staff to flesh out all the tools that us \"system\ndoctors\" need in our everyday work.  True, they give us some good\ntools themselves, but we ourselves have had to flesh out our own\ntool collections from either of three sources.\n\nEither: We buy vendor-supported tools (expensive and licensed for\nthis installation only)\n\nOr: We write our own tools (OK for a few tools, but time\nconsuming and you need the skill)\n\nOr: We use free tools that other people have written.  This saves\ntime, and has the advantage that each person who wrote a tool has\ntaken the time to learn the requisite skills and do the requisite\nresearch.  Why \"re-invent the wheel\" when good tools exist\naplenty.  And they are free.  Where are they?  They are in many\nplaces, but you can start with the CBT Tape collection\n(www.cbttape.org).\n\n      What is the CBT Tape collection?\n\nThe CBT Tape collection is a free collection of user-written MVS\ntools which has existed since 1975.\n\nThe CBT Tape collection was started by Arnold Casinghino, who\nmanaged it until September 1990.  Afterward, the management was\ndone by me.\n\nIn October 1998, we started a web site:  www.cbttape.org\n\nWe have taken over the MVS SHARE Tape (which is now part of the\n\"CBT Overflow Tape\".  We have taken over support for many Xephon\nmaterials now, so they are more easily accessible to everyone.\n\nThe CBT Tape still exists as two tapes: The \"regular CBT Tape\"\nand the \"CBT Overflow Tape\".  If you wanted to write out these\ntape materials, you would need a 3490E at least, because of the\nlength of the tapes.  But the individual files from these tapes\nare all downloadable (in TSO XMIT format mostly, and zipped) from\nthe www.cbttape.org web site.\n\nYou do not need to be a \"member of anything\" and you do not need\na \"password\" to use the www.cbttape.org web site.  It is up 24x7\nalmost always, so when you are doing your weekend upgrades, you\ncan access the materials, almost always.\n\nEverything on the www.cbttape.org web site is subject to a\nDisclaimer, whose text is addressable from the home page.  You\nuse it at your own risk, but practically speaking, the whole\nworld has tested much of this stuff, and you can too.  It is\nusually VERY reliable, but the disclaimer still is there, and\nneeds to be.\n\n    TSO commands in general, and APF-authorized TSO commands\n\nMVS is very helpful for programmers, in that its interactive\nportion, called TSO, can perform just as much work, in much the\nsame way, as \"batch processing\".\n\nA TSO command differs from a program, in that upon entry,\nRegister 1 points to a CPPL (Command Processor Parameter List)\ninstead of to a standard program's PARM list.\n\nMost TSO work, and most batch jobs, cannot interfere with the\n\"guts\" of the system that is necessary for it to run.\n\nBut APF-authorized TSO commands (as well as APF-authorized\nprograms) can do just about anything to the system, either\npreserving it, or destroying it.  We are here to preserve the\nsystem, and as \"system doctors\" we need APF-authorized programs\nand APF-authorized TSO commands as our tools.\n\nIn order for a program to run as APF-authorized, it needs two\nthings, and to run authorized under TSO, it needs three things.\nFirst, the load module has to be link-edited as SETCODE AC(1).\nThis is a setting in the pds directory entry of the load module.\nSecond, the load library has to be in the APF-authorized library\nlist.  This (nowadays) is determined by a listing in the PROGxx\nPARMLIB member.\n\nFor TSO programs and TSO commands, there is a third requirement\nfor a program or command to run APF-authorized.  This is going to\nbe the main topic of our discussion today.  There are four tables\nthat are accessed by your TSO session: They are named after their\nold CSECT names, from TSO of bygone years.  They are also named\nafter their settings in the IKJTSOxx PARMLIB member.\n\nThe four tables are: (IKJEFTE2 - AUTHCMD), (IKJEFTE8 - AUTHPGM),\n(IKJEFTAP - AUTHTSF), and (IKJEFTNS - NOTBKGND).  For a TSO\ncommand to run authorized, its name (up to 8 characters) must be\nin the AUTHCMD list (or the E2 list, as we will call it).  For a\ncalled program to run authorized under this TSO session, its name\nmust be in the AUTHPGM (or the E8) list.  For a program to be\nauthorizable by the TSO Service Facility, its name must reside in\nthe AUTHTSF (or AP) table of program names.  Finally, if you want\nto specify that a TSO command can't be run under TSO-in-Batch, as\na batch program, you specify its name in the NOTBKGND (NS) table.\n\n      Where to the four Auth Tables reside?\n\nWe can set the contents of the four TSO authorization tables in\neither of two places normally.  Today, we'll show you how to do\nit for your own session only, in a third place.\n\nThe first place is to code the program names in the IKJTSOxx\nPARMLIB member, under AUTHCMD (NAMES( _ )), AUTHPGM(NAMES(_)),\nand so forth.  These settings go into effect either at IPL time,\nor after a PARMLIB UPDATE(xx) TSO command is issued by an\nadministrator, or after an operator command SET IKJTSO=xx.\n\nThe second place is to assemble a load module called IKJTABLS,\nwith CSECTs IKJEFTE2, IKJEFTE8, IKJEFTAP, and IKJEFTNS, and place\nit in an APF-authorized library, that your TSO session will\nSTEPLIB to, in its LOGON procedure.  You can see a sample\nassembly of the auth tables in CBT Tape File 185.\n\nUpon LOGON to your TSO session, one set of these tables will be\ncopied to your TSO's address space, and pointed to by the LWA\n(Logon Work Area) which is a control block created especially for\nyour TSO session.  We shall refer to the \"LWA-pointed-to\" copy of\nthese tables, as the Local Copy of these tables.  Your TSO\nsession, when trying to determine if a program or command should\nexecute as APF authorized, refers ONLY to the local copy of the\n\"auth tables\".  This is an important and very crucial fact in our\nentire discussion.  Note this fact VERY carefully.\n\nAt LOGON time, the TSO initialization routine called IKJEFTP1\nwill create the LWA and local copies of the auth tables and the\nTSO exit tables.  These are in your TSO address space, in Key 0,\nSubpool 252 storage.  Fields in the LWA will point to the\naddresses of the local copies of these tables that were created\nat LOGON time.  If an APF-authorized STEPLIB with an IKJTABLS\nload module and the proper CSECTs (IKJEFTE2, etc.) were present\nat LOGON time, then the local copy of the tables is copied from\nthem.  If there isn't an authorized STEPLIB, or the CSECTs were\nmissing from there, then the tables are copied from the\ncommon-storage copies which were created at IPL time (or PARMLIB\nUPDATE(xx)) time.  Finally, if no AUTHCMD or AUTHPGM or AUTHTSF\nlist was coded in the active IKJTSOxx member of PARMLIB, then the\nlocal tables don't exist, but the addresses pointed to, are those\nin the default IKJTABLS load module in LPA.  (The IBM-supplied\nones don't contain much.)\n\n       How can we replace our own Tables?\n\nNow that we know that our TSO session's auth tables, which are\nactually used to make the judgments, are in our own Local Copy in\nour own TSO address space's storage (albeit Key 0 storage), we\ncan go ahead and create new tables of our own choosing, if our\nprogram is APF-authorized in the first place.  A non-authorized\nprogram can't change Key 0 storage.\n\nWhat do we do?  As a proof-of-concept, we should GETMAIN some Key\n0, Subpool 252 storage, copy a bunch of program names into the\narea, in the format of each of the auth tables, and re-point the\nappropriate LWA field to the new storage block.  Does the system\nhonor the new set of program names and ignore the old set?  You\nbetcha.  It certainly works that way.  Now, the question is\nmerely how to do this reliably, using a tested program or TSO\ncommand, copying the list from your own desired list of programs.\n\nDan Dalby and I worked on this project last summer.  I wrote two\nprograms, called TSUB and LLWA, and Dan wrote two different\nprograms, called LWATMGR and LWATEDIT.  These programs can be\nfound on CBT Tape File 797.  Dan's programs, and my programs, do\nslightly different things, and of course, they are written very\ndifferently from each other since we two have different\nprogramming backgrounds.  But they can reload these tables from\neach of 3 different sources: First, the source can be an\nIKJTABLS-like load module, second, an IKJTSOxx-like FB-80\nParmlib-like file, and third, from an LRECL=8 list of program\nnames.  In the third way, how do these programs (LLWA or LWATMGR)\n\"know\" which table to load?  From the headers.  You put a header\n\"---E2---\" at the top of a list of program names, and every\nprogram below, will be loaded into the E2 or Authcmd table.\nSimilarly, an \"---E8---\" entry will cause all the names below to\nbe loaded into the E8 or Authpgm table.  And so forth.  I think\nthe LRECL=8 way is the best.  If the LRECL=8 list is blocked\n8000, you can fit 6000 table entries into one 3390 track!  Very\ncompact!\n\nWhat do our programs do?  My TSUB program can substitute any\nprogram name for any other program name in any one of the \"Local\nCopy\" auth tables.  In addition, TSUB can change the properties\nof the existing tables.  (Dan's programs don't do that.) More\nabout this later.  LLWA can load new copies of the tables from\nany of the 3 sources.  So can LWATMGR, but with LWATMGR, the load\nlibrary \"origin\" library does not have to be APF-authorized,\nbecause he does a \"directed LOAD\".  Dan's LWATEDIT program will\nEDIF (ISPF EDIT) any of the existing tables, and when you SAVE\nthe EDIT, LWATEDIT will create a new table for you by CALL-ing\nLWATMGR under the covers.  Therefore, if you use LWATEDIT, you\nhave to put LWATMGR in BOTH the E2 and E8 tables.\n\n       Practical Implications of This\n\nSince we can now load our own authorization tables, and if we\nhave been granted an APF-authorized load library (by management)\nfor our own use, then we can deploy HUNDREDS of single-purpose\nuser-written APF-authorized TSO commands or programs to do our\neveryday work with.  We don't have to depend on the\ninstallation-supported authorization tables.  We can make our own\ntables, for our own TSO session only, and we will not impact the\nrest of the TSO sessions in the installation, at all.\n\nOne further note.  What if someone does a PARMLIB UPDATE(xx)\nafter we made our own tables.  The PARMLIB UPDATE(xx) will undo\nour tables, unless we do one additional thing (LLWA and LWATMGR\nboth do this automatically.  And TSUB will do it manually if you\nask it to).\n\nThere is a flag bit in the LWA for each of the four tables, to\ntell you if that table was loaded from the PARMLIB-created table\nin common storage, or from a copy of the table in an authorized\nSTEPLIB.  If the STEPLIB bit was on for that table in the LWA,\nthen a PARMLIB UPDATE(xx) command does NOT replace that table,\nbut leaves it alone.  Therefore, both the LLWA and the LWATMGR\ncommands reset the STEPLIB bit ON for each table that they\nreplace.  BTW, the TSUB command also has the power to set the\nSTEPLIB bit in the LWA for any table, either ON or OFF.  The TSUB\ncommand has other LWA value-setting powers as well, such as\nadjusting the marked lengths of the tables, or marking the\nlengths as zero for each table individually.\n\nLength values are assigned to the PARMLIB-created tables in\ncommon storage.  Length values are NOT assigned to the tables\nthat were copied from an IKJTABLS load module in an authorized\nSTEPLIB.  How do the length values, if they exist, affect how the\ntable is read by the TSO control programs?\n\nThis is how it works.  All of the tables are delimited by a blank\nentry.  However, if a table has some blank entries at the end,\nand the next one gets filled in (say by the TSUB program), then\nthe new program name at the end will be honored.  Now when an IPL\nor a PARMLIB UPDATE(xx) or a SET IKJTSO=xx operator command is\nexecuted, the table created will have ONE blank entry at the end,\nbut a LENGTH value will also be there, that includes the blank\nentry.  So if you fill up the blank entry with another program\nname, since the length value will include that last slot, the\nlast program name will be honored, even though the adjacent\nstorage might not have any blanks to delimit the table.  In other\nwords, if a table length exists and no blanks delimit, then it is\nthe TABLE LENGTH that is honored.  TSUB can adjust all the table\nlengths in several ways, which we shall not discuss here.\n\n       Dan Dalby's STEPLIB Command\n\nDan Dalby (CBT Tape File 452) has written a dynamic STEPLIB TSO\ncommand which dynamically adds a STEPLIB, exactly in the same way\nthat IBM's JCL STEPLIB would be put into effect.  But Dan's\ncommand does it dynamically, on the fly, and even if ISPF is up.\nThis can be very useful.  If Dan's STEPLIB is invoked to add an\nAPF-authorized load library to the STEPLIB concatenation, and all\nthe STEPLIB libraries are APF-authorized, then the AC(1) programs\ninvoked from that STEPLIB concatenation will run authorized.\nThis is a way to deploy your own APF-authorized library of tools.\nSTEPLIB hooks them up to your TSO session.\n\nIBM's TSOLIB command, which is more shaky in the way it operates,\nand which has to be invoked from TSO READY mode, will also honor\nAPF authorized libraries that are TSOLIB-ed to.  So if STEPLIB is\nunavailable to get your authorized programs to execute from your\nTSO session, you might try and use TSOLIB to see if it will do\nwhat you need.  But Dan Dalby's STEPLIB command will do it\nbetter.\n\nDan Dalby's STEPLIB command has to be itself authorized, so the\ncode has to be in an authorized library (perhaps yours, perhaps a\nsystem library) and the STEPLIB name has to be in the IKJEFTE2\n(Authcmd) table.  You can put TSUB alone in the system's Authcmd\ntable, use it to substitute STEPLIB for an existing entry, or to\nfill in the first blank entry at the end.  Then you can use\nSTEPLIB to add your APF-authorized tool library; afterwards you\ncan run LWATMGR or LLWA, and you're on your way.\n\nIf a program that should have been linkedited as AC(1) was not,\nyou can reset the appropriate bit in the pds load module\ndirectory entry, using the PDS (8.6) command from CBT Tape File\n182.  Just point the PDS command to your load library, and issue\n\"ATTRIB module AUTH\" against that load module name.  The module\nwill be marked AC(1) henceforth, with not much effort on your\npart.\n\nAll of this will help you, if the installation does not allow you\nto use a LOGON PROC of your own, with an authorized STEPLIB (your\nown authorized library).  In that case, you just have to put the\nTSUB and STEPLIB code into a different authorized library,\navailable to your TSO session, and put TSUB into your PARMLIB\nAuthcmd name list.  That's all.  Then use TSUB to put STEPLIB\ninto your E2 table, STEPLIB to add your authorized library and\nmake its programs reachable from your TSO session, then authorize\nLLWA or LWATMGR (already in your load library) into the E2 table,\nload your own auth tables, and your're in business.\n\n       Why Accumulate APF-authorized Programs?\n\nEvery setting in a PARMLIB member will eventually be activated,\nto put corresponding settings in common system storage.  These\nsettings are accessed (by the system programs) using\nwell-documented paths-paths that you can follow, too, using your\nown programs.  If your programs are APF-authorized, you most\nlikely will be able to adjust these PARMLIB-set values to your\nown liking, and hopefully, in a way that will help the\ninstallation achieve its objectives.\n\nI have heard of some corporate managements, which restrict even a\nsysprog's access to PARMLIB.  This will hamper your ability to do\nyour work sometimes.  In such a case, or if you are a consultant\nwho comes in and is asked to do a job, you sometimes must get\naround artificial limitations which corporate management (right\nor wrong) might put on you.  But they asked you to do your job,\nand you have to do it.  That comes first.  You have to do your\nassigned job.\n\nSo what do you do?  You NEED an APF-authorized library that you\nwill have access to.  They have to grant that.  Otherwise, your\nhands are completely tied.  Then you do what I've said before, to\nput your tool kit into place.  But what tools do you put in the\nkit?  It's a long story, but I have some suggestions.  Before I\nmake the suggestions, we'll show an example or three.  These\nexamples will illustrate what can be done with tools like this,\nand how handy they are when we have them.  After that, we'll\nsuggest more general tools for the tool kit.\n\n        The XMIT command's problem\n\nThis problem no longer exists from z/OS 1.9 and further on.  But\nit was exasperating while it existed, and something had to be\ndone about getting around it.  The problem, and its solutions,\nwill illustrate what we can do.\n\nBackground: IBM's TSO XMIT command was designed to send data in\nvarious formats, across communication lines, from one MVS system\nto another.  In order not to clog the communication lines of the\nnetwork, a global limit was placed on how many 80-byte records\nwill be sent across.  After the limit is reached, the command\noutput is abruptly cut off.  For example, if the installation\nchose to set the limit at 50000 lines (a low value), then any\nXMIT command transmissions will be cut off after 50000 80-byte\nrecords have been sent.  If you want to transmit a large file\nwhich will be reformatted into more than 50000 80-byte records,\nyou simply can't.  The reformatting process will be cut off at\n50000 lines.  Tough.\n\nThis limiting number is set in a PARMLIB member.  It is also the\nIKJTSOxx PARMLIB member.  But that number is part of the TRANSREC\nkeyword, under the OUTLIM subkeyword.\n\nYou will ask a question.  Data is not always in the form of\n80-byte records.\n\nAnswer: True, but the XMIT command converts all the transmitted\ndata first, into 80-byte records.  Then it transmits it.  Then it\nis converted back, on the target MVS system, using the TSO\nRECEIVE command, which undoes the initial formatting into 80-byte\nrecords, and restores the data into its original format on the\ntarget system.\n\nByproduct of this: Using the optional OUTDSN(dataset.name)\nparameter of the XMIT command, the data does not actually have to\nbe transmitted, but it is only reformatted into an 80-byte LRECL\nsequential file.  The RECEIVE INDSN(dataset.name) TSO command\nwill restore the transmitted (read reformatted) data into its\noriginal format.\n\nProblem.  If you are just reformatting a large file, and not\n          transmitting it, you are not clogging up transmission\n          lines.  But you are just storing the data in\n          reformatted form on the same system.  So why do you\n          still have the same limitations and cutoff as though\n          you were actually transmitting the data across\n          communication lines?\n\nIBM's solution.  After z/OS 1.9, the OUTLIM number is ignored\nwhen only reformatting data without transmitting it, and in the\ncase of reformatting only, no cutoffs are performed.\n\nOur solution before z/OS 1.9.  I wrote an APF-authorized TSO\ncommand to dynamically change the OUTLIM number in common\nstorage.  Then I did my XMIT reformatting.  Then I invoked my\nprogram to change the number back to what it was.  I use the TSO\nXMIT command for this purpose so often, that it justifies my\nmaking the effort to write this command.  But once I wrote the\ncommand (it is the CINMX command on CBT File 731), it can\n\n         The LOOK command's problem\n\nWhen writing Assembler programs that peek and poke about system\nstorage and follow control blocks, I always use the free \"LOOK\"\nTSO command from CBT Tape File 264.  The LOOK command will show\nyou 256 bytes at a time, of any system storage in your own\naddress space, or (if authorized) it will issue an SRB (it is an\nold program) to access storage in any other address space.  LOOK\nalso makes it easy to follow control block chains.  I'm not going\nto tell you more about LOOK here, but suffice it to say that it\nis extremely useful if you write system programs, so you can see\nthe data that you're programming about.\n\nIn z/OS 1.9, LOOK just stopped working.  It started to produce\nvery weird system abends such as a SB0A-5C and others.  What went\nwrong?\n\nI called my friend Sam Knutson and complained.  Sam told me that\nIBM fixed an issue that he was campaigning about for years.  It\nis a security vulnerability when someone can allocate Key 8\nstorage in CSA, so IBM did something about it.  They made a\nPARMLIB setting in the DIAGxx member to forbid user key\nallocation of CSA.  The setting of VSM ALLOWUSERKEYCSA(NO) was\npresent in z/OS 1.8, but it became the default in z/OS 1.9.  The\nLOOK command allocates CSA storage in Key 8.  Hence these weird\nabends for violating the new DIAGxx setting.\n\nSo what to do about it?  Of course I could have rewritten LOOK so\nit doesn't allocate CSA in a user key.  But I attacked the\nproblem the other way.  A very nice IBM'er, who knows who he is,\ntold me where the bit was, that the DIAGxx setting of VSM\nALLOWUSERKEYCSA(NO) sets.  Then I wrote an APF-authorized TSO\ncommand, called UKEYCSA, which temporarily turns the setting off.\nI use LOOK for the 5 minutes I need it for, and then turn the\nsetting back on.  The vulnerability is only for 5 minutes, and\nnot for the whole time, so the risk is minimal.  Meanwhile, I\ncould use the LOOK command to find out about the pieces of\nstorage I needed information about.\n\n    PARMLIB settings all cause in-core settings in CSA\n\nIsn't it obvious?  A setting in PARMLIB has to be system-wide.\nOr at least LPAR-wide.  This means that something\nmachine-readable has to be affected, in commonly accessed machine\nstorage.  True?  Of course it is!\n\nSo the question is: For every PARMLIB setting, where is the\nin-core consequence of it?  And what is the path of control\nblocks that you have to take, in order to get to the value which\nthis PARMLIB setting has set?\n\nIt follows, that if you don't want to change PARMLIB, but if you\nwant to achieve the EFFECT of changing something in PARMLIB, you\nmerely have to find the in-core consequence of the setting, and\nwrite an APF-authorized program, or better, an APF-authorized TSO\ncommand, to achieve that same change which the PARMLIB setting\nwould have achieved.\n\nTherefore, a further consequence of this, would be that if\ncertain PARMLIB settings are important enough to change on a\nregular basis, it would pay to have a collection of\nAPF-authorized programs to do that.  So it happens that one can\nproperly and justifiably accumulate a large collection of\nsingle-purpose APF-authorized TSO commands, and if he/she knows\nhow to use them, they would come in very handy, very often.\nWe've made the effort in that direction.\n\nTherefore, it is not at all far-fetched, to have to authorize 200\nor 300 new TSO commands for yourself, to be able to conveniently\ndo your work.  And TSUB, LLWA, LWATMGR, and LWATEDIT are now\nthere, to help you do that for yourself alone, without affecting\nany of the other TSO users in the shop.\n\n    Another Example - Adjusting the Number of Notices\n          Records Produced by ACCOUNT/SYNC\n\nBecause I have written both a free package and a commercial\npackage to manipulate all records in SYS1.BRODCAST, I am\npersonally very close to this example, and I want to submit a\nrequest to IBM to change the situation.  But meanwhile, I did not\nwait for IBM.  I wrote my own APF-authorized TSO command to solve\nthe problem myself.  When IBM solves the problem THEIR way, I'll\nbe happy too, but I did not wait for them to do it.\n\nIn order to format a new SYS1.BRODCAST dataset, you use the\nACCOUNT TSO command, followed by the SYNC command.  This (by\ndefault) produces 100 global notices records.  These are lines of\nmessages that the administrator can send to ALL TSO users.  These\nare the messages like: \"SYSTEM B will be down on Tuesday from 9\nPM to 12 Midnight for maintenance.  Please use SYSTEM A at that\ntime.\" Suppose, when you are doing an ACCOUNT and SYNC to format\na new Broadcast Dataset, and you don't want just 100 Global\nNotices records.  You want 150 or 200.  How do you change the\ndefault number of Global Notices records produced?\n\nIBM says you are supposed to zap a load module, and re-IPL.\nThat's the only way.  This is a very weird thing for IBM to\nrecommend.  I thought they were trying to save you from IPL-ing.\n\nAnswer is, that the number of Global Notices records that ACCOUNT\nand SYNC \"listens to\" is a fullword quantity in the CVT.  So in\norder to reload that, from a user's point of view, you have to\nzap a load module and re-IPL, because the CVT gets initialized\n(mostly) at IPL time.  I wrote an APF-authorized TSO command to\njust plug in another number here, and ACCOUNT and SYNC are happy.\nI named my program BDMNNOTC (sorry), and it can be found together\nwith my free Broadcast Dataset package on CBT File 247.  If I say\nBDMNNOTC 200, the ACCOUNT/SYNC will produce 200 Notices records.\nSimple as that.\n\nHow would IBM solve this problem?  Simplest way is to create a\nnew keyword in the IKJTSOxx PARMLIB member, such as\nNUMNOTICES(200).  When you do a PARMLIB UPDATE(xx) TSO command,\nor a SET IKJTSO=xx operator command, the new number would be\nplugged into the CVT.  Simple as that.  We have to submit a SHARE\nrequirement.  Maybe IBM will get this done.  I think that there\njust wasn't any demand, so IBM just overlooked the obvious thing\nto do.\n\nAt this point, I HOPE THAT YOU SEE THE GENERAL USEFULNESS OF\nHAVING SINGLE PURPOSE APF-AUTHORIZED TSO COMMANDS.  You may have\n200 or 300 of these, but we now have a way to quickly authorize\nthem\n\n     Writing Your Own Code - 1\n\nBack in the \"golden age\" of Assembler programming, which was in\nthe 1960s and 1970s, there were people who didn't care to look at\npublicly distributed free programs.  I talked to them.  They\nwould tell me: \"If I need to have a tool, I'll write it for\nmyself!\" For some people, this might have been good enough, but\nfor most of us, especially nowadays, this approach can have major\nflaws (even when the person DOES have the skills).\n\nFirst off, such a person would only write a program if he or she\nhad a problem, and NEEDED a program to fix it, or to address the\nsituation.  No situation, no program written!  Their \"gem\" is not\neven in the world!\n\nSecond, what if they DID write a program?  I've seen many of\nthem.  Usually such programs were written for the programmer\nhimself (or herself).  They weren't intended for more widespread\nuse.  So (for example) the program definitely might flip the bit\nthat was intended to be flipped.  But how would it behave if you\nentered the wrong parameter?  The programmer would tell you that\nhe/she always entered the right parameter.  (I've heard this\ntoo.) We know better.  If we want to use this tool, or this idea,\nwe'd better make it safer FOR OTHER PEOPLE to use.\n\nThird, what if this (skilled Assembler programmer) person\nsuddenly found him/herself in a pinch and a time constraint?\nThere's no TIME to prepare the defense!  If it isn't ALREADY in\nyour pocket, it won't be there if you need it all of a sudden.\n\nFourth, such a person has not learned to use OTHER PEOPLE'S\nSKILLS.  Fact is, (argue as you might like to) \"the whole is\ngreater than the sum of its parts.  A person who is an\nindividual, but yet recognizes the contribution of other\nindividuals, will profit from both his/her own efforts and from\ntheirs too.  If someone honors the contribution of others, the\n\"honor\" has a way of chasing him/her and catching up.\n\nLast summer I embarked on a project with another programmer (Dan\nDalby) whose skills are very different from mine.  And I can\ntestify that the parallel products from both our individual\nefforts, are better than if we had worked separately.\n\n     Writing Your Own Code - 2\n\nIf you write your own programs, they will definitely reflect your\npersonality, and the skills you have acquired thus far.  Don't\nEVER say to yourself that you aren't as good a programmer as the\nnext guy.  Go for THE RESULT, ask for help if you need it, and\ntry to GET THERE.  As you program, you'll acquire more skills to\nget past the problems that come up.  This should be WELCOMED,\nbecause it is part of the 50-50, 100-100 rule.  You are acquiring\nmore skills and experience (which you get to keep).\n\nI make it a practice to use the instructions that I have already\nlearned how to use.  And I pick up how to use new instructions,\none at a time.  If you are programming for the newer machines,\nand the program(s) might get big, it might pay to use the new\n\"jump\" instructions instead of \"branch\" instructions because you\ncan get more addressability.\n\nThe goal is to GET THE JOB DONE.  Then fix the code to make it\nmore foolproof.  You don't want someone ruining a system and\ncausing downtime, just because you were careless.  But at the\nbeginning, make your that you've achieved the proper result first\n(i.e.  flipped the proper bit(s), etc.) and the system \"respects\"\nthe changes that you have made.  THEN, clean up the code to make\nsure no unwanted \"bad\" things can happen with it.  \"Proof of\nConcept\" is a very important thing to establish first, before you\nput a great effort into programming something (only to see later\nthat the system doesn't \"care\" anyway, after you've made the\nchanges).\n\nUse diagnostic tools that you are comfortable with.  If you have\nsomething sophisticated and expensive, such as a commercial\n\"debugger\" program, then fine.  If you like to program by putting\n\"display\" code into your program for diagnostic purposes, then\nfine.  I like to look at core with the LOOK TSO command from CBT\nFile 264, which allows you to follow control block chains and see\nwhat's actually there in the live system.  That is how I have\nbeen able to document some \"undocumented\" IBM control blocks.\nYou can see what is in them (at least if the fields have been\nfilled).  And you can see what data any addresses point to.\n\n     Writing Your Own Code - 3\n\nThere is one rule I have:  \"ANY tool is useful\".\n\nI have a CLIST which contains one line of code.  (Eli Duttman is\nthe author.)  I use it all the time.  The CLIST is named \"X\", and\nthe line of code reads: LOGOFF.  Have you ever had to leave your\ndesk and you are in a hurry?  You make three or four \"finger\nchecks\" typing the word LOGOFF and the system doesn't \"understand\nyou\".  Finally you get disgusted and walk away.  If you typed X,\nthere's no problem at all!\n\nSo it doesn't matter if a tool is \"trivial\", \"elementary\",\n\"mindless\", \"brainless\", \"elegant\", \"not elegant\" or whatever.\nThe question to ask is: \"Is it USEFUL?\"\n\nNext, you should weigh the idea of whether you should take the\ntime to write something.  Of course, your \"work tasks\" are what\nyou were hired for, and they take precedence.  But what if you\nhave some \"slack time\"?  Then, if you think the installation\nwould benefit (THEY are paying you, not the other people, so you\nhave to THINK OF THEM FIRST), then you can make a decision.  I'm\nnot going to tell you whether to ask your boss first.  I'm also\nnot going to tell you how to drive your car.\n\nTry and use one of the more modern languages, with Assembler\npreferred.  Not everybody has a PL/I compiler any more.  And\nCOBOL changes every five years or so (I am deliberately being\ncynical - no offense to the COBOL people).  But don't shy away\nfrom these languages if they are the only ones you know how to\nuse.  Make tools!  That comes first.\n\n     More About the CBT Tape collection\n\nI'm a little biased, being the proprietor of this magnificent\ncollection of free tools, which owes its existence to thousands\nof contributors, and to the supreme dedication of Arnie\nCasinghino.  Arnie's enormous selflessness and dedication to\ndetail, over a span of so many years, has brought forth something\nunique in \"MVS-dom\".\n\nThe CBT Tape collection has been existence for just about 35\nyears!  It has been successful because people like you have sent\nin contributions to it.\n\n Updated \"tapes\" are produced whenever we feel we need to.  In\n former times, when the collection was strictly on tapes, updates\n needed to be distributed to the people in a timely matter.\n Arnie sometimes made 20 or 30 updates per year.  Nowadays, when\n the stuff is on our website, www.cbttape.org, the updates, even\n between tape versions, are readily available to everyone on the\n \"Updates\" page of the website.  My recommendation is that when\n you need a file, see if a new version of it is available on the\n Updates page.  Then go and check the \"CBT\" page.  So nowadays,\n we make only 2 or 3 updates to the tape versions, per year.\n\nI have just a few rules for contributions.  They are as follows:\n\n1-  All disclaimers in the CBT tape documentation always apply,\n    and they override all other statements both in the CBT Tape\n    documentation and elsewhere, regarding the fitness and\n    merchantability, etc. of the materials in each file in the\n    collection.\n\n2-  There should be no \"time-outs\".  Somebody using the tape ten\n    or more years from now should be able to run the materials\n    then too.  (Of course if the MVS Operating System changes, we\n    have no control over  that, and all disclaimers apply.  But\n    there must be no artificial time-outs or expirations built\n    into the software.)\n\n3-  There should be no restrictions about who can copy the\n    materials.  No contributor will be able to stop anybody from\n    copying the entire CBT tape for themselves.\n\n4-  The contributor may (if he/she wants) retain ownership of the\n    materials, using copyright notices  to indicate that fact.\n    However, the owner may not restrict others from copying or\n    using the file.  If  the owner wishes to prohibit commercial\n    use, he/she may do so.\n\n      Good Luck!  A few (parting) thoughts\n\nWe hope that your working life will be improved by this session.\nMaybe even your \"outside life\" might benefit too.\n\nAlways use good sense.  Going through life is like driving a car.\nYou never know what will come up, and you always have to keep\nmaking judgments.  If you are the driver, nobody, and that means\nNOBODY, can make the judgments for you.  You have to steer your\nown life.  You can ask advice (and you should) when there's slack\ntime, but in a crunch, you always have to make the decisions\nyourself.  Accepting responsibility is part of life.\n\nThe aim of this session is to make YOUR job easier.  The doctor\ndoesn't let \"non-doctors\" use his prescription pad and his\ndiagnosis tools (or his operation tools, scalpel, etc.).  These\nmust be used only by qualified personnel.  Our \"personalization\nof TSO authorization\" which we have shown you about, will benefit\nyou as system doctor, and will tend to be inaccessible to\nunqualified users, if you make it that way.  Do your best!  You\nmight try and invent some RACF safeguards, or ACF2, or whatever\nyou need.  If they work, please send them in to me.  (Thanks in\nadvance.)\n\nAgain, best of luck.  Use these things wisely.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BM1006JN": {"ttr": 1795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x10\\x15\\x8f\\x01\\x10\\x15\\x8f\"Y\\x01\\x16\\x01\\x16\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-06-07T00:00:00", "modifydate": "2010-06-07T22:59:20", "lines": 278, "newlines": 278, "modlines": 0, "user": "SBGOLOB"}, "text": "                        SHARING THE LOAD\n\n(c) Copyright 2010 by Sam Golob.  All rights reserved.\n\n\nINTRODUCTION - COLLECTING YOUR OWN FREE SOFTWARE TOOLS\n\n      Many years ago, when I broke into this field, there existed a\nconsiderable number of (then) grizzled (read \"40-year-old\") veterans who\nhad broken in 10 or more years earlier, during or before the mid-60's.\nThese folks were very schooled in Assembler language, because (number\none) they had gone to school for it, and (number two) not many shops\nwere then programming in higher level languages, even in COBOL.  So you\nhad to be fluent in Assembler if you would be doing any programming at\nall, even applications programming.\n\n      The \"systems types\" among these people were still around in\nrelatively large numbers when I broke in.  After I found out about the\nCBT Tape and other free software collections (belatedly in 1985), I\nasked some of these people if they would like to have copies of the\ntapes for themselves.  Many of them answered (to me they seemed rather\ncocky) that if they needed any tools, they could write their own\nwhenever they needed them, so they did not have to acquire someone\nelse's free tools.\n\n      I do not like to disparage any opinions, because I generally have\na lot of respect for people, especially knowledgeable people.  But upon\nhearing these statements, I did smell a rat.  Were these people really\nthat good?  Did they really know that much?  Would the tools they came\nup with (assuming that they actually did write them) be good tools for\nEVERYONE to use?  Right now, I'm here to express my doubts, and to add\nmy own opinions on that subject (25 years later).\n\n      I also might add another thing.  The MVS (aka z/OS or whatever)\nsystem nowadays is more complicated than it used to be.  I have a copy\nof an OS/360 Principles of Operation manual, and it is barely more\nthan 1/2 inch thick.  That's a laugh nowadays.  But IBM has always\nbeen very good about upward compatibility, and some 40-year-old\nAssembler programs written for those systems, still work today.\nNevertheless, IBM has been adding on more and more components to z/OS.\nDoing the requisite research to write a tool, while still being quite\nstraightforward in many cases, can often be more time-consuming than it\nused to be.  Therefore, it isn't easy to be a jack-of-all-trades (i.e.\n\"I'll write anything I want\") person today.\n\n      Truth be told, I think there really existed a VERY small group of\npeople who could live up to these claims.  I heard of one man who was\ncontracted to produce a shared SPOOL package (before one was available\nfrom IBM), and he produced 7000 lines of error-free code in one weekend\n(which ran smoothly for 12 years at that installation).  This is a truly\nphenomenal feat, and he really did it (in the one weekend).  But most\npeople (even very very good ones) are more ordinary.  Especially\nnowadays, when most of us are not so well-trained in Assembler, and the\nsystem is much more complicated, this is very much the exception, and\nnot at all, the rule.\n\n      So I think that if most people would try and write a tool,\nquickly, at the time they needed it, most of these tools would probably\nhave several shortcomings.\n\n\nWHAT CAN GO WRONG WHILE WHIPPING UP A TOOL FOR YOURSELF?\n\n      It's easy to throw a bit, but are you throwing the RIGHT bit,\nALL the time?\n\n      If you write a tool for yourself, and you assume you are going to\nbe the only user of it, then (usually) you ALSO assume that the tool is\nnot going to be used incorrectly.  For example, if the program needs a\nPARM, you might assume that the parm is going to be the correct one, the\none you planned on using.  You sometimes don't program for the person\nwho will make a mistake with the PARM field, for example, making it\nnon-numeric when it is supposed to be numeric, or making the number too\nlarge or too small.  So if you write for yourself only, you might leave\nout checks for the following things, and many more.\n\n1.  You might let the system ABEND if there is a mistake, instead of\n    trapping the mistakes and putting out an error message that advises\n    the user how to correct the mistakes.\n\n2.  You might not test to see if the user is APF-authorized where the\n    tool requires it.  It is better to test for authorization with the\n    TESTAUTH macro and intercept the errors.\n\n3.  If the tool affects system storage, it might not ABEND, but it could\n    possibly alter the wrong storage and damage the system dangerously,\n    when it is not used properly, the way it was planned by the writer.\n\n4.  You might not test for incorrect data.\n\n5.  You might not see that your code is accessing incorrect data.\n\n6.  And so forth......\n\n      When you're writing a tool for others, especially for others who\nmight bumble, you must add safeguards to your tools, and safeguards mean\nthat your tools will get more complicated, harder to test, and you can't\njust whip one up in five minutes when you feel you need it.  You might\nneed to spend considerable time testing the tool, to make sure it does\nnot damage anything.  After all, IT IS YOUR JOB to keep the installation\nrunning safely, and staying up.  Sometimes a bad tool is way worse than\nhaving no tool at all.\n\n      The bottom line is that when you are writing a tool that affects\nthe system, you must do it CAREFULLY, just like when you are driving a\ncar.  You don't want to kill or hurt, anything or anybody.  This takes\ntime, patience, and a lot of testing.  It usually cannot be done in five\nminutes, in an emergency, only at the time you need it.\n\n\nSHARING THE LOAD\n\n      I think I've come up with a better plan.\n\n      So now it makes sense that if someone already wrote a tool,\ncarefully, lovingly, and with a lot of testing and trial, it just might\npay FOR OTHER PEOPLE to use that tool profitably as well.\n\n      Therefore, IF A LOT OF PEOPLE will EACH write a FEW tools, but\nthey do a good job at them, and they SHARE their work with other people,\nand each one profits from the careful work of the others, then a lot of\nground can be covered.\n\n      That is what we are about.\n\n\nOPEN-SOURCE PRODUCTS VERSUS COMMERCIAL PRODUCTS\n\n      I have been convinced that open-source products are often (but not\nalways) better than commercial products that do the same thing.  As usual,\nthe answer to that question is:  \"It depends.\"\n\n      If the commercial software house is big, generous-minded, and they\nafford ample resources for their developers, and they aren't\nrestrictive, money-wise or policy wise, and they practice firm but\npleasant quality control, then it is possible that they can produce a\ntop-notch product.  (Not so many of them are that good.  Some are.)\nBut if the commercial software house has constraints in money, time, or\nmind-set of management, there can be an inflexibility in that place,\nwhich effectively paralyzes development and progress.  For example, I've\nseen an open-source project whose product surpassed and exceeded its\ncommercial counterpart in just a few years' time, overcoming the\ncommercial product's ten-year head start in just 3 or 4 years.  It's\nquite true.  I've used both of these myself.  The free product wins the\ncontest, hands down!\n\n      If you've ever worked for IBM, \"at IBM\", or at a commercial\nsoftware house, you'll know something about why this can be so.  Being\n\"inside\" is far different than \"looking in from the outside\".  As with\nmost things in life, there are many sides to the matter, and (depending\non the circumstances) the quality issues can go either way.  Either the\nopen-source product is better, or the commercial product is better.\nSometimes they both can be equally good.\n\n      Now let's look at some of the factors which affect the quality of\ncommercial products vis-a-vis the quality of open source products.\n\n\n\"PROFESSIONAL\" VS \"DOING IT FOR LOVE\"\n\n      A professional person, in whatever field, has to develop a pride\nand expertise and self-respect.  After all, he or she has to warrant the\nsalary and professional respect which is given to them, in exchange for\nthe quality of their work.  A professional cannot be slipshod.  A\nprofessional person must produce a quality product.  A professional\nperson's work must warrant the the salary and benefits that are paid to\nhim or her.  But in any company, money (or the lack of it) talks, and\nmoney matters dictate much of the eventual result.  The professional\nprogrammer is often tied down by management, and can't bring to fruition\nall of the creativity that is in his our her soul.\n\n      On the other hand, open source projects are made by people with\n\"a passion for the project\".  They don't get paid.  But they are driven\nby a passion for the result, and sometimes, by the pride of being\nmembers of the team that produces the result.  If someone is\nenthusiastic to make an enhancement, no one stops him or her because of\nmonetary or time constraints.  The person writes the implementation, with\nall the bells or whistles desired.  Other people in the group make\nsuggestions, the component is tested, and it is integrated into the\nwhole product.  Nothing is left out because some manager thinks so, or\nbecause of a monetary or time constraint.  The resulting product is much\nricher and more robust because of that.  And it gets done sooner.\n\n      I have produced both free products and commercial products.  If\nyou haven't produced a commercial product, you won't realize how much\ntesting has to be done.  The product has to be foolproof, as much as\npossible, because it is guaranteed in writing, and money is being paid\nfor it.  IT HAD BETTER BE CORRECT and function properly.  There are\nlegal matters involved.\n\n      Nevertheless, I've still seen open-source products that are\nbetter, by far, than their commercial counterparts.  The reason is\nbecause of the lack of restriction due to monetary constraints, or the\nmanager's ego, or legal factors, or for reasons like the company doesn't\nwant to conflict with something that another of its acquired products\ndoes, and so forth.\n\n      As always, \"it depends\".\n\n\nSO WHAT'S IN IT FOR US?\n\n      Finally, we are coming to the point of this article.  It is now\npossible for everyone to accumulate large collections of free tools and\nto learn how to deploy them and use them.  You don't have to write them\nall, yourself.  You can take full advantage of other people's knowledge,\nyou have their blessing and encouragement, and you can use their tools,\ntoo.\n\n      So if you have happened to have a particular expertise or need,\nand you have written your own tools to cope with that need, then you can\ncontribute to the public good and share all the tools, yours and the\nothers', for your own use and for everyone else's.  That's how we all\nbenefit.  No ONE of us has time to do EVERYTHING, but ALL of us TOGETHER\nhave had time to do A LOT.  And that is how it all gets done.\n\n      For example, my particular expertise, where I had to spend a lot\nof time, is with magnetic tapes and their AWS and FLEX tape images, the\nSYS1.BRODCAST dataset, and TSO control blocks (many of them undocumented\noutside of IBM) having to do with the authorization of commands and\nprograms under TSO.  When I was doing my \"TSO Authorization Table\" work,\nI noticed that in the SHOWzOS monitor (CBT Tape File 492), the coverage\nfor the TSO control blocks was not adequate.  So since that was my\nspecialty, I beefed up the TSO Auth Table coverage there, and I added\nthe coverage for the number of Global Notices that are made, when you do\nan ACCOUNT/SYNC to format a new Broadcast Dataset.  When I was doing my\nmagnetic tape work, I converted all of the tape mapping and tape copying\nprograms on the CBT Tape, to look at 64K blocks instead of 32K blocks,\nwhenever I could.  (There was one exception - in that case, I couldn't\npenetrate the complexities of his BSAM code.)  Therefore as a result,\neveryone else could benefit from what I was spending MY time on.\n\n      One major vehicle for sharing is the free \"CBT Tape\" collection of\ntools which you can access (no userid or password needed) at\nwww.cbttape.org.  You can use the \"already developed and tested\" tools\nthat are there, as well as contributing your own.  I have found that\nmany of our system programming jobs are done more easily using these\ntools, which were made \"for the sysprogs, by the sysprogs\".  Everyone\nhas their own style and expertise, making for a large diversity of\nsubjects and MVS components covered.  www.cbttape.org now has support\nrights for most of the Xephon code from the Xephon magazines, as well.\nNow you can use, and get ideas from, Xephon magazine code, without\nfeeling as if you've violated a whole bunch of copyrights.  BTW, please\nread the Disclaimer at the www.cbttape.org web site.  But\nnotwithstanding the disclaimer, most of the code has been tested a lot.\n\n      I myself have bounced around to a bunch of shops, and I can\ntestify that having my own set of tools, ready to go, and not needing\nANY licensing, really enhances my ability to get real work done on a\nmoment's notice, without elaborate setting up.  For a lot of my work,\nI don't have to rely on any vendor's tools at all, except for IBM's.\nI can mostly make up for IBM's inadequacies with my collection of FREE\ntools.\n\n      And as for most of my tools, I didn't write them myself (though I\nHAVE written SOME of them).  The ones I have written, I've tried to take\nmy time with, and do a thorough job of testing.  I didn't write them in\nfive minutes.\n\n      My own feeling is that I am very happy to get help wherever I can\nfind it.  And I try to lend a hand to others, whenever they need it.\nCollecting free software encourages cooperation among folks.  It makes\nme happy, and it makes many other people happy too.  Feelings count for\na lot in life!\n\n      I just have to note here, that most of my professional friends\ndid not work in the same shop with me.  Therefore, there was no chance\nof rivalry for the boss' attention, backbiting, or petty jealously.\nEverybody was out for the other guy's good, and the other guy's good\nONLY!  That's the way it SHOULD be, and that's the way it is.\n\n      So to conclude, I think that in today's climate, it's best to pool\nour knowledge and our research and development skills to create a few\ngood MVS tools and share them with a lot of other people.  We can't, and\nshouldn't, try and write everything ourselves.  We should use other\npeople's work too.  That's the best way to get all our own work done,\nquickly, efficiently, and effectively.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BM1911NV": {"ttr": 1800, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x03\\x01\\x10\\x15\\x8f\\x01\\x194o\\x01Y\\x01\\x1a\\x01\\x16\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2010-06-07T00:00:00", "modifydate": "2019-12-12T01:59:03", "lines": 282, "newlines": 278, "modlines": 0, "user": "SBGOLOB"}, "text": "              THE VALUE OF TOOLS, NEW AND OLD - PART 1\n\n(c) Copyright 2019 by Sam Golob.  All rights reserved.\n\n\nINTRODUCTION - GETTING THE JOB DONE\n\n      Our job involves keeping a z/OS installation running well.\nUsually we do this for a large business or institution or government\nagency which depends on this computer system to run the company's\noperation.  Downtime means a disaster to some degree, small or large.\nDowntime almost always involves a considerable loss of money for the\ninstallation.  The computer system is the pulse of the business, and\nits \"money maker\".\n\n      Therefore, we have a big responsibility.  If there is a problem,\nwe have to get it fixed.  If there is a system upgrade, we have to do it\nflawlessly.  Glitches happen, but we are required to be the \"geniuses\"\nthat \"head them off at the pass\".  In other words, if there are\nproblems, we have to get to the bottom of the situation as fast as\npossible, and FIX THEM.\n\n      IBM gives us a lot of tools, but they are limited.  At bottom,\nIBM (as big as they are) is a software house.  Their programmers have to\nbe paid, and therefore scheduled, and the work planned out.  They can't\ncode anything they want, or take as much time as they want.  As a\nresult, IBM tools will often \"cover the ground\", but frequntly not quite\nas well as we'd like.  Therefore, systems programmers have written their\nown tools for as long as we can remember.  Let's explore a few of these\ntools, that may be new to you, and maybe not.\n\n\nTYPES OR CLASSES OF TOOLS, AND WHERE DO WE GET THEM?\n\n      Many of the tools that we need in our work, have to do with\nfinding out what is happening in the operating system, as it is in the\nmidst of working.  A good example of such a tool is the SHOWzOS TSO\ncommand, (in CBT File 492.  See later in this article about the CBT\ncollection of tools.)  Another class of tools, has to do with finding\nout what kind of data we are looking at, whether it be (1) system data,\nor (2) application data, or (3) data in computer storage.  We then get\nto the difference between \"looking at data\", and \"changing data\".\n\n      Some of our tools will first look at the data, and then, when we\nsee the data, we may decide to change some of it.  When a tool can\nchange data, it might need more authority.  We'll discuss this later in\nthe article, where we explain what the concept of \"APF-authorized\"\nmeans.  Certain tools have been designed only to look at the data, but\nonce we find out what's there, we can start doing something appropriate,\nbecause we now have a better idea what is really going on.  We may not\nneed to change the data.  In that case we only need to find out what\ndata is there.\n\n      I'll digress a bit about where to get tools.\n\n      When there is a need, we try to either find a tool, or write a\ntool.  It is easier (usually) to find a ready-made tool, which already\ndoes the job we want to do, than to write the appropriate tool yourself.\nBut we try and do both, and we let the other people (in the case of a\nfree tool) use the tool for themselves as well.  This makes everybody's\njob easier.\n\n      Some shops, which are more \"wealthy\", will buy vendor-supplied\ntools besides those written or supplied by IBM.  Other shops, which\ndon't have as much money to invest, have to scrounge for tools, and they\nhave to try to find them or write them for themselves.  Whatever the\nshop, if they have access to \"free tools\" that don't require licensing,\nthen they can ALWAYS run the free tools, as well as the vendor-supplied\ntools or IBM's tools.  But \"rich shop\" or \"poor shop\", the free tools\nwill work there.  So if you know how to use free tools, you will have a\nconsiderable skill advantage wherever you work.\n\n      So where do we find free tools?  A great repository of free tools\ncan be found in the CBT Tools collection at www.cbttape.org.  There are\nthousands of tools there, all written by people with specific needs,\nwhich have solved the problems for them.  With proper application, they\ncan solve the problems for you too.  And you can download anything there\nfor free.  (There is a \"Disclaimer Section\" on the web site.)\n\n      My teacher Jeff Broido taught me many years ago, to try and take a\nhalf hour each working day, to learn something new.  The knowledge thus\nacquired over time, will help your both shop, and you yourself, to\nhandle future problem situations that will come up later.  I've done it,\nand it is good advice.  Often, I use that \"learning time\" to search\naround the CBT tool collection to try and find tools which I can use to\nmake my life easier later.\n\n\n\"LOOKING\" TOOLS OR \"CHANGING\" TOOLS\n\n      I'll give you a few examples of tools that either look at data, or\nthey can change data.  Some tools can do both.  Others can only \"look\",\nbut not \"change\".  The borderlines between these two classes are fuzzy.\nI'll show you how and why.\n\n      First (for simplicity), consider a program that can read magnetic\ntapes.  Magnetic tapes are \"linear\" in nature, or one-dimensional. To\nput it differently, all their data lies in a straight line.  There is a\nbeginning of a tape, an end of a tape, and everything in between.  You\nread the data either \"forward\" (normally) or \"backward\", but there is no\nsuch thing as sideways.  All of the tape data can be pictured as lying\non one line.  We will now shou you what it means to \"read a tape\".\n\n      To illustrate the point better, let's assume that we are giving\nthe program the power to read tape labels as well as tape data, so we\nwill invoke the program with DD tape JCL as LABEL=(,BLP) (which means\n\"Bypass Label Processing\").  This makes the program able to consider the\ntape labels as purely data, and then we can get a truer picture of what\nis really on the tape.\n\n      Now to start.  The program will OPEN the tape file, and start to\nread the blocks of data, usually into a buffer in storage, one block at\nat time.  So when that block of data is in storage, you have access to\nit, and you can do anything you want to do, with it.  You have a choice\nas to what you will want to do next.  To merely COPY the tape, all you\nhave to do is to write the contents of that buffer to another tape, and\nthen re-do the process of reading a block of data and copying it, one\nblock at a time, until you get to the end of the volume.  When you\nencounter a \"tape mark\", which constitutes a boundary betwen tape files,\nyou write a tape mark to the copied tape at that point.  You continue\nthis cycle until you encounter the end of the input tape, or possibly\nyou can also stop this process at some time in the middle, perhaps after\nreading a certain number of tape files.  Or you can skip some files\nafter reading them, and copy some of the following files from the middle\nof the tape, leaving out the ones at the beginning.\n\n      To MAP the contents of the tape, you can report on the data that\nis in the buffer.  If it is a label, you can report on the contents of\nthe label.  If it is a data block, then you can measure the data, or\nprint it out, or even change it in place.  With tapes, if you want to\nchange any data, it is probably best to make a duplicate copy of the\ntape with the changed data, rather than to alter the original tape\nitself, which usually isn't too safe.\n\n      So you see the flexibility.  With tape programs, you can either\nMAP the tape, to see what is on it, or COPY the tape to make a\nduplicate, or alter the contents of the tape in some other way, doing\nthe alteration in the process of making a copy, so that only the copied\ntape is altered.  You can also collect statistics about the tape files,\nor do something else.  You are only limited by your imagination.  You\ncan either make one program to do it all, or you can make several\nprograms, each one of which performs part of the process.\n\n      There are at least eight different tape copying or tape mapping\nprograms on the CBT Tape.  Examples are:  TAPEMAP from File 299,\nCOPYMODS from File 229, or the COPYFILE family of programs from File\n316, including COPYSLNL and COPYNLNL.\n\n      So much for tapes.  Now let's consider looking at disk data.\n\n      Disk data is specialized.  It can be of many formats.  For\nexample, if you have a load library, that, of course, is on disk.  But\nthe layout of the data, being executable programs, has a specialized\nstructure.  What I am considering now, is to just look at RAW disk data.\nAnd to do so, we have an excellent tool, the source code of which is on\nFile 134 of the CBT Tape, and which is called \"Fullscreen ZAP\".\nIncidentally, Fullscreen ZAP is also an excellent tool for looking at\nload modules, but right now I want to emphasize its ability to look at\nraw disk data as well.\n\n      Fullscreen ZAP is a TSO command which shows a full screen (208\nbytes) of data at a time, anywhere on a disk.  Under many circumstances,\nFullscreen ZAP does not even need to be run APF-authorized, but to see\nANY data, ANYWHERE on a disk pack, it needs to be authorized.\n\n      Fullscreen ZAP can also CHANGE any data on a disk, (doing it in\nplace, up to 8 characters at a time).  The advantage of Fullscreen ZAP\nover an IBM program like MVS DITTO (great to have if you are licensed\nfor it), is that with Fullscreen ZAP, you can look at a large bunch of\nsurrounding data, next to the data you want to see, or change.  And you\ncan do it in real time.  It's nice to have Fullscreen ZAP in your\npocket, and to know how to use it.  Fullscreen ZAP has a complete\ntutorial, accessible through PF1, which tells you how to use all of its\nsubcommands.  It pays to take the time to learn it well.  You can even\ndisassemble small parts of load modules with it, in the vicinity where\nyou are looking.\n\n      What about data in virtual storage?\n\n      We have a marvelous command, named LOOK (CBT File 264), to look\nat virtual storage in any address space (LOOK goes cross-memory by\nscheduling an SRB).  LOOK was recently enhanced to be able to see\n64-bit storage as well.\n\n      LOOK can \"look at storage\" but cannot change it.  I use LOOK when\nI am programming, to actually \"see\" the data that is in the system.\nI can also use LOOK when I am debugging a program with TEST, to go\ncross memory into the address space running TEST, and to survey storage\nthat is in that address space.  (TEST and TESTAUTH stop the action in\nthat address space, at a breakpoint, and then I can leisurely use LOOK\nto peek and search around over there).\n\n      LOOK is an amazing tool.  Besides being able to see raw storage\nwith it, you can easily format the data you are looking at, if it is\nwithin a known control block.  And when you assemble LOOK, you can even\ncustomize which control blocks you want LOOK to be able to format.\nSince this article is only an overview, and I don't have time here to\ntalk about LOOK in depth, I would recommend that you go to CBT File 264\nor CBT File 035 (to get a load module for LOOK, to try out) and\nexperiment with it yourself.  You'll be super-glad that you did.\n\n\nAUTHORIZING YOUR TOOLS, IF AUTHORIZATION IS NEEDED\n\n      Here's a situation where you should check with your management.\nOnce you authorize a tool with APF-authorization, it can potentially \"do\nanything\" on the system, although there may be some other safeguards\nthere.  Nevertheless, APF-authorization is not generally something that\napplication programmers should have, and if you are a systems\nprogrammer, you need to be \"responsible\" and you need to know what you\nare doing.  Don't risk any \"production data\" unless you are absolutely\nsure, and if you're a \"junior person\", you should have a \"senior person\"\nwatching you.  The company's money (read \"big bucks\") is at stake, and\nyou don't want them to lose any of it.  They pay your salary to keep the\nsystem up and running \"healthy\".\n\n      Now that this disclaimer is over with (and you'd better take it\nseriously), we can get down to the nitty-gritty.  I'm assuming you're\ndoing this on a \"test system\".\n\n      In order for a program (or TSO command) to run with\nAPF-authorization, it needs several prerequisites.  First, it needs to be\nlinkedited with the option:  SETCODE AC(1).  This is actually a setting\nin the pds directory entry for the load module, at X'27' (field\nPDSAPFAC), and the value has to be X'01'.  If the program was not\nlinkedited this way, you can always throw the bit on, using the PDS\ncommand (CBT File 182), using subcommand:  ATTRIB modname AUTH.\n\n      Next, the program (or TSO command), has to be executed (fetched)\nfrom an APF-authorized library, or an APF-authorized concatenation of\nlibraries.  If one library in a concatenation (say a STEPLIB\nconcatenation or a TSOLIB) is not authorized, then the entire\nconcatenation is not authorized, even if ALL the OTHER libraries there\nARE authorized.  For a load library or a PDSE containing program objects\nto be APF-authorized, it must either be in the LINKLIST, when\nLNKAUTH=LNKLST is set in the IEASYSxx member of PARMLIB.  Or it must be\nin the system authorization table of libraries (called the APF list),\nwhich is created from the APF ADD portion of the PROGxx PARMLIB member.\nEach entry of APF ADD, which adds a library into the APF list, and makes\nits programs eligible to be run APF-authorized, must specify two things:\nthe library name, and the volser of the disk pack that the library is\non.  It does not matter that the library is cataloged to its pack.  For\nthe APF list to be in effect for the library, its volser must be\nexplicitly stated.\n\n      If you want to add a library to the APF list dynamically, you can\nenter a console command:  SETPROG APF,ADD,DSN=dataset.name,VOLSER=volser\n\n      There is one more prerequisite for APF-authorization if you are\neither executing the program or TSO command under TSO (including\nTSO-in-batch) and not in a batch job.  In the case of running authorized\nprograms (e.g. via CALL) under TSO, or running a TSO command processor,\nwhich is intended to be APF authorized, you must include the program\nname (exactly) in the proper special name table.  To be straightforward,\nthere are three separate tables which are defined in a the PARMLIB\nmember called IKJTSOxx.\n\n      Three possible name lists can be used to authorize load modules\nin the IKJTSOxx PARMLIB member.  The first category is the AUTHCMD\nentry, which specifies all of the TSO command names which are allowed\nto run APF-authorized in your session.  The second category is the\nAUTHPGM entry, which contains the names of all programs called from\nTSO, which are to be run APF-authorized.  Finally there is the AUTHTSF\nlist, which contains the names of a few programs that need the TSO/E\nservice facility (TSF) to gain authorization, because they may need\n(for example) too many parameters for a normal CALL to handle.  IBM\nsays that you should not put program names in the AUTHTSF list unless\nthey absolutely need to be there.\n\n      The IKJTSOxx PARMLIB member can be updated in your LPAR, by the\nconsole commeand:  SET IKJTSO=xx\n\n      The APF list can be dynamically updated by entering the console\ncommand:  SET PROG=(xx,yy,zz,...)\n\n      With that done, we can now refer you to CBT File 185 for more\nfine points about getting APF-authorization under TSO for your lists\nof programs and TSO commands.  And with that, we bid you adieu,\ngoodbye, and auf wiedersehen, etc. till next time.\n\n      Best of everything to all of you...........\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BM1912DE": {"ttr": 2049, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x16\\x01\\x10\\x15\\x8f\\x01\\x195o\\x14 \\x02f\\x01\\x16\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2010-06-07T00:00:00", "modifydate": "2019-12-22T14:20:16", "lines": 614, "newlines": 278, "modlines": 0, "user": "SBGOLOB"}, "text": "              THE VALUE OF TOOLS, NEW AND OLD - PART 2\n\n(c) Copyright 2019 by Sam Golob.  All rights reserved.\n\n\nSOME NEWER TOOLS YOU MAY NOT KNOW ABOUT\n\n      Our last article was a general introduction to user-written tools\nfor the z/OS or MVS-related operating systems.  Today I'd like to bring\nup some newer tools that are not likely to be well-known as yet.  The\nusefulness of knowing about these newer tools depends on how badly you\nneed them.  But it shouldn't hurt to mention some of them, so people can\nsee for themselves.\n\n      Some of these tools may be found in the very interesting CBT File\n731.  File 731 was created to showcase TSO commands, usually of the APF-\nauthorized variety (but not always), to let you know the innards of some\ncontrol blocks related to the IKJTSOxx member of PARMLIB.  Recently, a\nset of commands was added to cover the area of the TSOKEYxx member of\nPARMLIB, as well.  If you want to be able to know about many of the\nworkings of TSO in your system, it would pay to get familiar with the\nTSO commands and other programs in this file.  How many of you have\nheard about the TSO RELOGON Buffer, for example, not to mention having\nsome tools to manipulate it?\n\n\nTHE PARMLIB DILEMMA\n\n      To really treat this area properly, I feel we have to backtrack,\nand I'll tell you a story.  In the early 1980's (around the time of MVS\nSP 1.3.3 and before), many (SYS1.PARMLIB-determined) MVS control blocks\nwere \"static\", and it required an IPL to change them.  Pressures from\nbanks and brokerage houses, and other institutions which had to minimize\n\"down time\", forced IBM to create a new design pattern, so as to\nminimize the number of IPL's necessary.  Gradually, one control block at\na time, IBM made many control blocks renewable and modifiable without\nthe necessity of an IPL.\n\n      The design, in general, was as follows:  The particular control\nblock occupied some common storage, in a certain subpool, and was\naddressable from the CVT (Communications Vector Table) through a chain\nof addresses.  So the plan would be, to GETMAIN some similar common\nstorage, make a new copy of that control block in that storage, and\nre-point the chain of addresses to the new storage instead of the old\nstorage.  A program would be written to do this, and that program would\nbe triggered by issuing a \"SET\" console command of some sort.  Voila.\nThe control block was changed, and we don't need to IPL.\n\n      How would we instruct the system which way to change the control\nblock?  It would depend on a PARMLIB member.  Initially, the control\nblock was created at IPL time by setting up a PARMLIB member.  Now, the\ndynamic change would be instituted by copying that PARMLIB member to a\ndifferent one, and making the necessary changes to it. Then we'd issue a\nSET command to force the system to point to the new PARMLIB member\ninstead of the old one.  Easy?  Yes.  Nice design?  Yes.  It certainly\nseems to solve the problem of reducing the number of IPL's.  And it did.\nBut.....\n\n      Now comes the dilemma.  In earlier times, before this business of\n\"renewable control blocks\" was designed by IBM, many shops felt that to\nimplement \"security\", they needed to restrict the personnel who were\nallowed to change members of PARMLIB.  Some shops actually required up\nto ten signatures from company officers, before a PARMLIB change would\nbe allowed to happen.  Of course, this (almost) completely defeats IBM's\nplan, outlined above, to reduce IPL's.  In order to change a control\nblock and avoid an IPL, you'd have to create a new PARMLIB member, or at\nleast modify an existing one, and management wouldn't allow that.\nSystems programmers had to get their work done, and keep the system\nrunning.  To avoid an IPL, they'd sometimes have to change a PARMLIB\nmember on short notice, and management policies were blocking this.\nWhat to do?  The obvious solution would be to wrestle with management.\nSometimes, though, they'd give you a deadline, and you just couldn't\ndeal with the red tape at all, because the required officers were not\navailable to sign off on the change.  There wasn't time, and the job had\nto get done.\n\n      So we worked on the problem, for at least those few PARMLIB\nmembers where we needed a solution.  And for these PARMLIB members, we\nmade a solution available.  What did we do?\n\n\nDYNAMICALLY CHANGING SYSTEM VALUES\n\n      If you have an APF-authorized TSO command, it can be made to do\njust about anything that one of IBM's \"SET\" commands can do.  We can\nimitate IBM's \"dynamic control block replacement\" process ourselves.\nIf we're APF-authorized, and systems programmers (who are the \"system\ndoctors\") should responsibly have that privilege, then we can write our\nown programs to make necessary control block changes, when we're in a\npinch.  Management is forcing us to perform a change, and they are not\ngiving us the time to do it \"their way\", which is a contradiction.  So\nwe can quietly get the job done our way (but only when it is really\nnecessary to do it like that--I have been in that position myself, and\nI know what it feels like.  I quietly, accurately, and safely got the\njob done, and nobody complained, because the system was running\nproperly and there was no outage and there were no delays.)\n\n      So to see some of the work that we've already done in this vein,\nlook at the appropriate programs in CBT File 731.  For example, if you\nwant to find out about the parameters related to the SEND or LISTBC TSO\ncommands, you should run our TSO command called EESCB, which shows their\nvalues in detail.  If you want to look at the \"PUBLIC\" TSO authorization\ntables, then you should invoke the (authorized) TSO command called ASUB.\nIf you want to look at your own TSO session's \"PRIVATE\" authorization\ntables, then you should invoke the (authorized) TSO command called TSUB\n(in CBT File 797).  If you want to dynamically change your own session's\nauth tables, then these tools, and others, are in CBT File 797, and you\ncan do that.  ASUB ? and TSUB ? will get you online help.\n\n      To display the XMIT-RECEIVE parameters in the IKJTSOxx PARMLIB\nmember which is active, you can use the INMXD command, and if you want\nto dynamically change the OUTLIM value or the \"warning\" values there,\nyou have the CINMX command.  So you see there is a lot to study in Files\n731 and 797.  Files 731 and 797 have pretty good coverage, when you need\nto poke into TSO Parmlib-related values, and more recently, to look into\nTCAS-related values, such as USERMAX.  Our USERMAX (authorized) TSO\ncommand can dynamically change the maxusers value, for example.  And we\nhave other (appropriately named) commands in File 731 to display or\nchange any of the other TCAS-related values, such as HIBFREXT or\nLOBFREXT.\n\n      We also have some coverage of the VATLSTxx PARMLIB member, with\nour DVAT TSO command.  VATLSTxx is different, however, in that all the\nIPL-related stuff is used once, at IPL time, and then that storage is\noverlaid.  DVAT shows VATLSTxx values that are still left in storage\nafter IPL, but the command does not reflect the results of individual\nMOUNT console commands, which temporarily change the status of\nindividual disk packs between IPL's.  So far, the VATLSTxx coverage\nwill only display values, but will not change them.  The capability is\nstill informative, however.\n\n      And don't forget our general commands:  SHOWTPVT and SHOWTCAS.\nThese commands show all the general values and addresses in your system\nwhich are related to the TPVT (TSO Parmlib Vector Table) and TCAS\n(general TSO values mapped by the IKTTCAST macro) respectively.\n\n      There is a lot more to look at in CBT Files 731 and 797.  If you\nwant to know more about authorizing your TSO commands, look in CBT File\n185, because you'll have to do a lot of that.\n\n      For those of you who use TEST and TESTAUTH to debug your programs,\nthe DTEST TSO command will show you which TSO commands that TEST can\nexecute and which \"extra subcommands\" can be run under TEST.  Using the\nDTEST command, you can display the current configuration of TEST\nprograms and TEST subcommands which are extra.\n\n      However, if you want to change these values dynamically, without\ntouching the IKJTSOxx PARMLIB member, we have a batch program called\nLOADTEST in CBT File 731, which will do that.\n\n      For example, if you want TEST to be able to display 64-bit\naddresses, this can be set up.  First you need a TEST subcommand to do\nit.  There is a command on CBT File 300 called IKJT9LGZ, which can be\ninvoked as the \"LG\" TEST subcommand.  And IKJT9LGZ can display 64-bit\naddresses.\n\n      The normal way that \"extra programs\" and \"extra subcommands\" for\nTEST (or TESTAUTH) can be deployed, is to enter them in the IKJTSOxx\nPARMLIB member under the category TEST, as TSOCMD and SUBCMD entries,\nand then issue a SET IKJTSO=xx console command, or a PARMLIB UPDATE(xx)\nTSO command.\n\n      But using our LOADTEST batch program from CBT File 731, you can\nload these values dynamically using control cards, and you don't have to\nchange anything in PARMLIB to do it.  Invoking LOADTEST once, will\ngenerate the correct control cards controlling your current TEST PARMLIB\nconfiguration.  And then you can modify these cards and reload them into\nstorage using the LOADTEST batch program again, so TEST (or TESTAUTH)\nwill then have the extra capability that you formerly could only get\nusing the IKJTSOxx PARMLIB member.\n\n      This is just a sample of what the TSO commands and programs in CBT\nFile 731 can do.  You see that many of them can dynamically change\nTSO-related values without your having to touch PARMLIB.\n\n\nLOOKING AT LOAD MODULES\n\n      I don't know how you feel about it, but to me, there was always a\nkind of mystery around load modules.  I had some trouble looking at them\nand understanding them, even though I could BROWSE them in hex, using\nISPF.  It was a matter of not seeing clearly what was going on.\n\n      Of course, you can disassemble a load module to get a semblance of\nsource code.  IBM \"frowns\" on users doing that, but to solve a problem,\nyou sometimes have to disassemble the code.  There are some disassembler\nprograms on the CBT Tape.  One of the newest ones is on File 885, from\nAlbert Cheng.  IBM themselves supply a disassembler (called ASMDASM) in\ntheir optional HLASM toolkit package.  That's what I use, but you have\nto be licensed for it.  ASMDASM is located in library HLA.SASMMOD2.\nAn advantage to using IBM's disassembler is that it is updated whenever\nIBM adds new instructions to the instruction set.\n\n      A new development has made looking at load modules a bit easier,\nwithout actually doing any disassembling.  That's what I'm going to talk\nabout now.  It's a way to look at the contents of a load module in a\nmore meaningful way, and to see its raw contents, but clearly, and with\nall the hex displacements made obvious.  The program is called LISTMOD,\nand it can be found on CBT File 994.\n\n      LISTMOD is a TSO command, and in its present form, all you have\nto do is to point it at a load module name, and LISTMOD will display\nit.  In other words, you can say:  LISTMOD IEFBR14, and you'll get an\nISPF-like 3-line hex display (with ruler) of that program's 8 bytes,\ntogether with a bunch of header information, and all displacements\nshown clearly.  The interesting thing is, that you can display a load\nmodule with several million bytes just as easily.  LISTMOD has one\npossible subparameter, \"ENTRY\".\n\n      When do you use the ENTRY parameter of LISTMOD?  Sometimes it is\nmore convenient to do so.  You do it when the entry point of a module is\nfar from the beginning, and if you are mainly interested in seeing the\ncode near the entry point.  Sometimes the entry point is \"too far\" from\nthe beginning of the load module, to easily scroll there.\n\n      If the entry point of the load module is somewhere in the middle,\nand you don't want to start the display from the beginning of the\nmodule, you can use the ENTRY parameter to start the display from the\nmiddle of the module, at the entry point, and go on to the end, rather\nthan starting at the very beginning of the module, and going to the very\nend.  There are times when you will just want to use the ENTRY\nparameter, and after doing that, you might then want to look at the\nbeginning of the module as well, so you'll then invoke LISTMOD without\nthe ENTRY parameter, to see what's at the beginning.\n\n      At this point, I have to interrupt in order to explain how to\ncapture the LISTMOD output, and how to scroll up and down.  LISTMOD, for\na large load module, might have hundreds of thousands of lines of\noutput, so you really need a way to capture it.  The nice thing is that\nLISTMOD puts out its output to the terminal using PUTLINE, so the output\ncan be displayed by TSO-in-batch, or it can be captured by OUTTRAP (in\nREXX) or SYSOUTTRAP (in CLIST).\n\n      On CBT File 994, I have included the four \"outtrapping tools\" from\nMark Zelden, called TSOE, TSOV, TSOB, and TSOR.  These tools allow you\nto trap the LISTMOD output, even if it is many thousands of lines long.\nAnd then you can see all parts of a load module, scrolling up and down\nwherever you want.  You can go top to bottom and back, or to anywhere in\nthe middle.  To use these viewing tools, for example TSOV, you just have\nto say:  TSO TSOV LISTMOD modname  and you'll get a fullscreen display\n(in this case, with ISPF VIEW).  TSOE uses ISPF EDIT, TSOB uses ISPF\nBROWSE, and TSOR uses the REVIEW command from CBT File 134, which can\nalso be run without ISPF, in TSO READY mode on the screen.  In this way,\nyou get a nearly instant view of entire load modules, scrollable.\n\n      There is one drawback to the way LISTMOD works, which at the time\nof this writing has not been remedied yet.  There is both an advantage\nand a disadvantage to the way LISTMOD works.  The advantage is\nsimplicity.  You just name the name of the load module, and LISTMOD\ndisplays it.  The disadvatage is twofold:  First, you have to have the\nmodule in some place which is allocated to your TSO session, so LISTMOD\ncan LOAD it.  For example, you may have to first TSOLIB to the load\nlibrary which contains the module, before running LISTMOD.  And second,\nyou don't know which copy of the load module you are looking at.  You\nget the copy that the system \"finds\" for you.\n\n      This is because LISTMOD works by doing a LOAD of the module into\nyour session's storage, unless it is an LPA module, in which case it\ngets the address of the module from the LPDE (Link Pack Directory\nEntry).  The way LISTMOD is currently coded, the LOAD is not a \"directed\nLOAD\", but it is an \"ordinary\" LOAD, which uses the system search path\nto find where the module is.  In order to look at the copy of the module\nthat you may really want to look at (if it isn't the standard copy),\nthen you have to go through a few hoops to get that library allocated to\nyour TSO session, so that the search for it is first.  TSOLIB is helpful\nin this regard.\n\n      So, other than showing you illustrations of some of the programs\nand TSO commands mentioned here, we have come to the end of the\ndiscussion for now.  Since this is not being published in a magazine,\nas most of my other articles were, we don't have a space limitation\nconcerning illustrations, so I can now show you quite a few outputs\nthat are produced by the commands and programs mentioned here.\n\n      For now, we wish all of you the best of everything, and we hope to\nsee you again in this space, the next time.\n\n                         ILLUSTRATIONS\n\nFigure 1.  Output of LISTMOD for the LISTMOD load module (abbreviated).\n           Please note the contents of the header.\n           Afterward is shown a LISTMOD of IEFBR14, which is in LPA.\n\nTSOV LISTMOD LISTMOD\n\nLoaded Program Name:  LISTMOD\n-----------------------------------------------------------------\nModule has been LOADED. CDE Address: 009AC600\nLength of loaded module Hex:  00001530    Decimal:        5424\nLength after entry address :  00001530    Decimal:        5424\nDisplacement of entry point:  00000000    Decimal:           0\n-----------------------------------------------------------------\n\n 00  LISTMOD - 09/19/19 - 11.54     }    &   &&    }  &\\  &}\\ k    00000000\n4FF21DCEEDDC464FF6FF6FF464FF4FF4409ED01C45CF45501E4DC05EC05DE094\n7002C39234640000911911900011B540000C0C8F10FF10018D10B800BC000820\n---+---+---+---1---+---+---+---2---+---+---+---3---+---+---+---4\n\n DKG E Dk  .K  < .K  0 <  K  U <K     K     K         P      0     00000040\nCCDCCCCC94C4D4C4C4D0CFC41AD0CEC4D0C5A0D0C5A0D0C6A041C5D0C7C75F01\nF427F5F420CB20CCCB27E0CC8127B4CC23F40423F80C23F80010F473F4F48000\n---+---+---+---1---+---+---+---2---+---+---+---3---+---+---+---4\n\n  2   {k 02    0{    0{y        IKJPARS       H            0       00000080\nBEF048C95FF00E4FCA004FCA03F70000CDDDCDE4001F47C059C74190015F9041\nFF2C7002802C5F700A7050080BB0000092171920A62F708680F0800C60800840\n---+---+---+---1---+---+---+---2---+---+---+---3---+---+---+---4\n\n  K     K     K  @  k   K  % Q    i   h       A  \\            i\\   000000C0\nC3D0C791D0C791D0C79190CED0C6CD51C7810081001148C05E1050104110008E\nCA23B00023B40223BC0420BC23BCD880F09008800821701C800080041000AA90\n---+---+---+---1---+---+---+---2---+---+---+---3---+---+---+---4\n\n  h\\      {0KG E DK  E 0K    0   E     0    KG E DK  E 8   E       00000100\n008E001147CFDCCCCCD1CCCFD0CDCF41CC40025FCD0EDCCCCCD4CCCF41CC4004\n0880082E700027F5F425F5D027FBE010F5100880DC5F27F5F420F5B810F51001\n---+---+---+---1---+---+---+---2---+---+---+---3---+---+---+---4\n\n          * * * * * * * * * * * *\n\n(last 2 lines of the output)\n\n} & \\  0  j 1  \\{D 01    0{  0{Q        IKJPUTL        }}    0{0   000014C0\nD650E05F0198FB4ECC5FFB0E4FCD4FCD03BB0000CDDDEED40012135DD0004FCF\n0800048000101C7004801C5F700A50080CF8000092174330A68D8F8004707000\n---+---+---+---1---+---+---+---2---+---+---+---3---+---+---+---4\n\n          {Y   0{    3 \\} q }   K }%                               00001500\n0007000050CE115FCE071F5ED090D10FD0D64000000F0000\n00100003800882800CA883800C8C047E200C0000000F0000\n---+---+---+---1---+---+---+---2---+---+---+---3\n\nTSOV LISTMOD IEFBR14\n\nLoaded Program Name:  IEFBR14\n-----------------------------------------------------------------\nModule is from LPA.  LPDE Address: 80C88E50\nLength of loaded module Hex:  00000008    Decimal:           8\nLength after entry address :  00000008    Decimal:           8\nDisplacement of entry point:  00000000    Decimal:           0\n-----------------------------------------------------------------\n\n                                                                   00000000\n1F0F0000\nBF7E0000\n---+---+\n\nTSOV LISTMOD IEFW21SD ENTRY  (a huge load module with entry point\n                              far from the beginning)\n\n     Note that the byte count starts from the entry point, and\n     not from the beginning of the load module.\n\nLoaded Program Name:  IEFW21SD\n-----------------------------------------------------------------\nModule is from LPA.  LPDE Address: 80C86D80\nLength of loaded module Hex:  000DD450    Decimal:      906320\nLength after entry address :  000B63A8    Decimal:      746408\nDisplacement of entry point:  000270A8    Decimal:      159912\n-----------------------------------------------------------------\n\nx4   IEFBB401 17038 HBB77B0   } {{                             ;   00000000\nAF001CCCCCFFF4FFFFF4CCCFFCF09ED0CC00110AE0020013E1020014EE020015\n740E6956224010170380822772000C0C000000D0B0000C80B1000C81BE000C8E\n---+---+---+---1---+---+---+---2---+---+---+---3---+---+---+---4\n\n       ? 0 W  {         xY m  x     {0     00   x4  x4  x4  {      00000040\nEF0200164F0E50C2B000B001AE3910A20211CF000E5FF00EAF02AF00AF01C100\nBF000C8F100680042B002A0078F49E74008D0000FE80085F740A740474050000\n---+---+---+---1---+---+---+---2---+---+---+---3---+---+---+---4\n\n Si0            {0   Q 00 x    \\  {     i0            {0   E 00    00000080\n0E8F00BF11110710CF000D5FF0A7FE4E00C1000C8F00BF11110710CF000C5FF1\nF29008FD08B1A82E0000F8800C74FA10000000FF9008FD0BB1A82E0000F58000\n---+---+---+---1---+---+---+---2---+---+---+---3---+---+---+---4\n\n          * * * * * * * * * * * *   (58300 lines later)\n\n\nASCH            IEFW21SDIFAJAC00ESTAERTNSC100   5752OSMFRL01d      000B6340\nCECC444444444444CCCEFFECCCCDCCFFCEECCDEDECFFF000FFFFDEDCDDFF870D\n123800000000000095662124961113005231593523100000575262469301452C\n---+---+---+---1---+---+---+---2---+---+---+---3---+---+---+---4\n\n        W                                                          000B6380\n00210000E0001000000000002000000000000100\n0070000060406000000000000100000000000800\n---+---+---+---1---+---+---+---2---+---+\n\n\n\nFigure 2.  Output of the USERMAX command, when we aren't changing\n           its value.\n\nUSERMAX - VER. 1.2 - 07/16/19 - 15.30\n--------------------------------------\n Change the MAXUSERS number in the IKTTCAST\n control block.\nCurrent number of TSO Users:  1\nCurrent value of MAXUSERS  :  40\nTo change MAXUSERS, enter a numeric parameter.\nNothing was changed.\n\n\nFigure 2A.  Output of the USERMAX command, when we are changing\n            its value.\n\nUSERMAX - VER. 1.2 - 07/16/19 - 15.30\n--------------------------------------\n Change the MAXUSERS number in the IKTTCAST\n control block.\nCurrent number of TSO Users:  1\nPrevious value of MAXUSERS :  40\nValue of MAXUSERS reset to :  100\n\n\n\nFigure 3.  Output of the SHOWTPVT TSO command.  I figure you won't\n           find anything like this, anywhere else.  This is running\n           on z/OS 2.3, where 8-character TSO ids can be defined.\n\n      SHOW TPVT - TSO PARMLIB VECTOR TABLE - FIELDS\n      ---- ----   --- ------- ------ -----   ------\n        Display of Common Storage Deriving from\n              the IKJTSOxx PARMLIB member\n           8-CHARACTER USERID SUPPORT IS: ON\n               TPVT ADDRESS:   0C574968\naddr  field        value            explanation\n----  -----        -----            -----------\n  +0  TPVT_ID      TPVT             Control block identifier\n  +4  TPVT_LEN     00DC             TPVT length in hex\n  +6  TPVT_VERS    03               TPVT version level\n  +7  TPVT_FILLER1 00\n  +8  TPVT_MEM     IKJTSO00         PARMLIB member filling this TPVT\n +10  TPVT_GEN     00000000         TPVT generation number, fullword\n +14  TPVTCTLT     0C598008         CTLT addr, points to auth tables\n +18  TPVTCTLTLEN  0000003C         CTLT control block length\n +1C  RESERVED 1   00000000\n +20  TPVTSEND     0C5744C0         IKJEESCB-SEND PARMLIB contr block\n +24  TPVTALPL     0C5C0210         ALPL addr, default allocation OLD\n +28  TPVTTEST     0C5B7010         TPT addr, TEST cmd control block\n +2C  TPVTXPRMD    0C5743C0         INMXPARM address-SEND parameters\n +30  TPVTCONSOLE  0C574050         TSO CONSOLE command parameters\n +34  TPVTFCVEC    0C5740A0         Address-PLATFORM commands table\n +3C  TPVTHELP     0C574000         Address-HELP datasets list\n +40  TPVTPPVEC    0C574078         Address-PLATFORM programs table\n +44  RESERVED 2   0000000000000000\n +4C  TPVTLOGON    02               LOGON option fields - bits:\n                                    Password Phrase Support     08\n                                    Applid Verification         04\n                                    LOGONHERE Support           02\n                                    Password Preprompt Support  01\n +4D  TPVTUMXL     08               8-char userid status indicator\n +4E  RESERVED 3   0000\n +50  TPVTDSNAM    SYS1.PARMLIB                         PARMLIB dsname\n +7C  TPVTVOLSER   ZOSRES                               and its volser\n +82  RESERVED 4   0000\n +84  TPVTSYSNAM   SYSA             ID of this system or LPAR\n +8C  TPVTUSERID   **IPL**          Who did the last PARMLIB update?\n +94  TPVTHHMMSS   20:51:45         Time HH:MM:SS when it was done\n +9C  TPVTYYMMDD   2019-12-21       Date YYYY-MM-DD when it was done\n +A6  TPVTCPUIDP   0080             CPUID prefix\n +A8  TPVTCPUID    00011DF7         CPUID of this machine\n +AC  TPVTMODEL    3906             CPU model number\n +AE  TPVTUPDTIM   20514535         Hexadecimal TIME when updated.\n +B2  TPVTUPDDAT   20191221         Hexadecimal DATE when updated.\n +B6  TPVTFEATURE  80               Feature codes\n +B7  TPVTFEATVER  02               Feature version\n +B8  RESERVED 5   000000000000000000000000000000000000\n +CA  RESERVED 5A  000000000000000000000000000000000000\n\n\nFigure 4.  Display of the SHOWTCAS output (partial).  The entire\n           TCAS control block (mapped by macro IKTTCAST) can be\n           displayed using SHOWTCAS ALL.\n\n      SHOWTCAS - TERMINAL CONTROL ADDRESS SPACE - FIELDS\n      --------   -------- ------- ------- -----   ------\n          Display of Settings and Addresses having\n           to do with the TSOKEYxx PARMLIB member\n           at the beginning of the IKTTCAST macro\n             8-CHARACTER USERID SUPPORT IS: ON\n               TCAS ADDRESS:   00C2EDC8\n\naddr  field        value            explanation\n----  -----        -----            -----------\n  +0  TCASID       TCAS             Control block identifier\n  +4  TCASUSEC     0001             Number of active users - HEX\n                       1            Number of active users - DEC\n  +6  TCASUMAX     0028             TSO Maxusers number - HEX\n                      40            TSO Maxusers number - DEC\n  +8  TCASACBP                      ACB Password\n +10  TCASRCON     0003             Reconnect time in minutes - HEX\n                       3            Reconnect time in minutes - DEC\n +12  TCASCLSZ     0084             Buffer Size - HEX\n                     132            Buffer Size - DEC\n +14  TCASHBUF     0000BB80         High Buffer Threshold - HEX\n                       48000        High Buffer Threshold - DEC\n +18  TCASLBUF     00005DC0         Low Buffer Threshold - HEX\n                       24000        Low Buffer Threshold - DEC\n +1C  TCASCRSZ     01E0             Screen Size - HEX\n                     480            Screen Size - DEC\n +1E  TCASCHNL     04               Maximum Chain Length - HEX\n                       4            Maximum Chain Length - DEC\n +1F  TCASENGT     00               ENGTRANS Value 0-Base,1-Ext,2-None\n\n\nFigure 5.  Display of DTEST command output.  Shows optional loaded\n           TEST command programs and subcommands.\n\nIn-Storage PARMLIB IKJTSOxx TEST Parameter Values\n---------- ------- -------- ---- --------- ------\nTPT ADDRESS     0C5B7010\nTPT SIZE        0028\nTPT VERSION     01\nTCT ADDRESS     0C581000\nTCT SIZE        002C\nTCT ENTRIES     0004\nSCT ADDRESS     0C5741D0\nSCT SIZE        0054\nSCT ENTRIES     0004\n\n---- TSOCMD PROGRAMS ----\n      Program Name\n        TSOEXEC\n        SDSF\n        PDS\n        PDS86\n\n----   SUBCOMMANDS   ----\n Subcommand     Module\n  F            IKJT9FIZ\n  FIND         IKJT9FIZ\n  LB           IKJT9LBZ\n  LG           IKJT9LGZ\n\n\nFigure 6.  Sample LOADTEST parms to duplicate the above TEST\n           optional parameters from IKJTSOxx.\n\n* LOADTEST PARMS\n*---+----1----+-\n--TCT--\nTSOEXEC\nSDSF\nPDS\nPDS86\n--SCT--\nF       IKJT9FIZ\nFIND    IKJT9FIZ\nLB      IKJT9LBZ\nLG      IKJT9LGZ\n\n\nFigure 7.  General JCL to run LOADTEST.\n\nJCL:\n\n//LOADTEST JOB ,'MY JOBCARD',CLASS=A,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//LOADTEST EXEC PGM=LOADTEST PARM=R    (See Note)\n//STEPLIB  DD  DISP=SHR,DSN=MY.LOAD.LIBRARY\n//SYSPRINT DD  SYSOUT=*\n//SYSPRNT2 DD  SYSOUT=*\n//TESTOUT  DD  SYSOUT=*      (LRECL=80 DATASET OR SYSOUT)\n//TESTOUT2 DD  SYSOUT=*      (LRECL=80 DATASET OR SYSOUT)\n//TESTIN   DD  *\n* LOADTEST PARMS\n*---+----1----+-\n--TCT--\nTSOEXEC\nSDSF\nPDS\nPDS86\n--SCT--\nF       IKJT9FIZ\nFIND    IKJT9FIZ\nLB      IKJT9LBZ\nLG      IKJT9LGZ\n/*\n\nNote:  PARM=R on the EXEC card will REGRESS the TPT (and its\n       associated TCT and SCT tables) to the previous value,\n       if it exists.\n       When PARM=R, the TESTIN DD name is required, but its\n       contents is ignored.  Best to code: //TESTIN DD DUMMY\n       when PARM=R.\n\n\nFigure 8.  Output of the DVAT command.\n\n            DISPLAY INCORE VATLST SETTINGS\n            ------------------------------\nVATDUSE ADDRESS:  0C5C0150\nDEFAULT SYSUSE :  PRIVATE\nVATLST FROM IPA:  (00,04)\n---------------------------- (*PARMLIB  VATLST VOLUME SETTINGS*)\n                                ----------------------------\n                             ( MAY BE OVERRIDDEN BY MOUNT CMDS )\n                             ( NOT CHECKED AGAINST ONLINE UCBS )\n  VOLMASK   ATTRIB    DEVTYP\n----------------------------\n  ZOSRES    PRIVATE   3390\n  ZOSRS1    PRIVATE   3390\n  ZOSRS2    PRIVATE   3390\n  WORKA*    STORAGE   3390\n  WORKE1    STORAGE   3390\n  WORK0*    STORAGE   3390\n  PUB001    PUBLIC    3390\n  WORK80    PRIVATE   3380\n----------------------------\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BM2001JA": {"ttr": 2305, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x18\\x00)\\x01\\x10\\x15\\x8f\\x01 \\x00\\x1f\\x139\\x01\\x97\\x01\\x16\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.24", "flags": 0, "createdate": "2010-06-07T00:00:00", "modifydate": "2020-01-01T13:39:29", "lines": 407, "newlines": 278, "modlines": 0, "user": "SBGOLOB"}, "text": "              8-CHARACTER TSO USERIDS IN Z/OS 2.3\n\n(c) Copyright 2019 by Sam Golob.  All rights reserved.\n\n\nTHE SOURCE OF THE PROBLEM\n\n      TSO userids, since \"time immemorial\", have been limited to 7\ncharacters in length.  In z/OS 2.3, IBM made (quite drastic) changes to\nTSO, to allow the use of 8-character TSO userids.  Today we're going to\ntalk about why, and how, this change was made.  First, of course, we\nhave to talk about some history.  It seems odd that a userid should have\nbeen limited to 7 characters, when the lengths of most dataset name\nsegments are 8 characters, and the names of pds members are also 8\ncharacters long.  It looks weird on the surface.  So how did this\nhappen?\n\n      TSO (Time Sharing Option) in MVS, OS/390, and z/OS is quite\nancient, having (I think) gotten its start in the late 1960's in MVT, or\nat the very latest, in the early 1970's.  For all this time, the userids\nfor users to LOGON to TSO have been restricted to 7 characters long.\nThe reason for this is because the definition of a user account to TSO\nwas traditionally done by means of the SYS1.UADS (User Attribute Data\nSet) partitioned dataset.  And the programming around the UADS members\nis weird, and very \"direct access like\".\n\n      Each TSO user LOGON (before definition of users by RACF, ACF2, or\nTop Secret, etc.) had to be defined by a member, or multiple members, of\nthe SYS1.UADS pds.  Creation of a TSO userid (and its maintenance), when\nbased on SYS1.UADS, is done by the TSO ACCOUNT command.  You can still\nlook up how the ACCOUNT command works, because it has a HELP member in\nSYS1.HELP, and it is still supported by IBM.\n\n      Sometimes, to define one TSO userid, you had to create more than\none member of the SYS1.UADS pds.  The reason for this (which shows how\nreally ancient TSO is) is that each pds member in UADS needed to be\nEXACTLY ONE FULL BLOCK of SYS1.UADS, and it could not contain a partial\nblock, or more than one block.  So the definition of a TSO userid\ndepended on the block size of the SYS1.UADS dataset.  If the block size\nof SYS1.UADS was 800 bytes, or 10 80-byte card images, then the pds\nmember(s) defining a TSO user were fixed in size to 800 bytes.  But if\nmore information was necessary in defining the user (for example if the\nuser had 10 possible LOGON PROCs or multiple account numbers or multiple\npasswords), and the information overflowed 800 bytes, then to define the\nuser, you would have to create more than one pds member.  Therefore (for\nexample) in defining userid USERXX, you might have pds members USERXX0,\nUSERXX1, and USERXX2, which were necessary to hold the required\ninformation about the user.  Since IBM was requiring an extra character\nin a SYS1.UADS pds member name, and member names in the SYS1.UADS pds\nwere limited to 8 characters, as they always are, the actual id had to\nbe limited to one character less, or to 7 characters.\n\n      That's the history, folks, in a nutshell.  Ever since then, TSO\nuserids have been limited to 7 characters maximum, until now (maybe 50\nyears after TSO was created).  Amazing.  But true.  And it was a thorn\nin IBM's side.\n\n\nTHE CHANGE IS QUITE DRASTIC\n\n      The developer who made most of these new changes to TSO for\n8-character TSO ids, told me that this was one of the largest single\nchanges that ever had to be made to the MVS (z/OS etc.) operating\nsystems.  We can understand this on the surface, because there was a lot\nof IBM code to change.  You can comprehend the situation, because from\ntime immemorial (from the beginning of TSO), it was assumed by IBM\ndevelopers that the way to determine a TSO user's id, was to look at the\nPSCBUSER field, which just happens to be 7 characters long, and not\nexpandable.  This occurrence must have happened hundreds of times within\nIBM internal code.  And every single instance of this practice, now had\nto be modified and fixed.  (Same with the UPTPREFX field, which is also\n7 characters, and not expandable.  All IBM code which fills in the prefix\nin a dataset name, has to be fixed as well.)\n\n      This was so great a change that it could not go in transparently,\nbut it needed a switch, to tell the system whether it was in, or not in.\nThis switch is located at +6 into the TSVT (TSO Vector Table) control\nblock that is described by macro IKJTSVT.  In pre-2.3 systems, the\nswitch was a reserved field, and it had a value of X'00'.  In a 2.3 or\nlater system, the value of the switch would depend.  If 8-character\nuserid support was turned on, the value of the switch would be X'08'.\nAnd if 8-character userid support is turned off, then the value of the\nswitch would be X'07'.  In any case, X'00' says that the support is off.\nThere is a mirror field in the TPVT at X'4D' into the TPVT control\nblock, but I don't think that that is the actual switch.  It is just an\nindicator to show how the real switch (TSVT+6) is set.\n\n      How is this relevant to us, as systems programmers and (sometime)\nsoftware developers?  The point is that some of the places where your\nTSO userid shows up in the system, are 7-byte fields, and the way a\nprogram will find out what your userid is, will have to change.  Some of\nthe classic methods of programmatic discovery of userids have gone out\nthe window, and they absolutely must to be modified.\n\n      Of course, if you're running z/OS 2.3 (or later) and you don't\nturn the switch (for 8-character id support) on, then you're pretty safe\nwith the old programs (for now).  But one never knows whether IBM, a few\nreleases later, will \"turn on the switch permanently\" (like they've done\njust now in 2.4 with userkey common storage--there's no switch anymore\nfor that).  And the bottom line points very strongly to the fact that\neverybody will eventually have to change and adjust to the presence of\n8-character TSO userids.  I don't foresee any escape from that.\n\n      So our user-written programs will have to change.\n\nCONTROL BLOCKS THAT HAD TO BE CHANGED\n\n      As proprietor of the CBT Tape collection of utilities\n(www.cbttape.org), I knew that many TSO commands find out the userid of\nthe invoker, using the 7-byte PSCBUSER field, and other TSO commands\nfind out the dataset prefix under TSO, using the 7-byte UPTPREFX field.\nEvery one of these programs needs to be adapted to the 8-character id\nchange.  Besides that, my \"commercial\" product dealing with the\nBroadcast Dataset (aka SYS1.BRODCAST) also might be impacted by the\n8-character id changeover.  Therefore I was extremely interested in\nwhat was happening.  I had to find out the details.  I had some help\nfrom IBM, using my \"developer\" status with them, and having signed a\nnon-disclosure agreement.\n\n      One of the first things that I did, when I found out about this\nchange, was to try and find out where in a modern z/OS system, your TSO\nuserid is represented--in what control blocks.  I came up (so far) with\n15 different control blocks where your TSO userid shows up.  To actually\nshow them, I wrote a TSO command called ALLIDS, which displays all of\nthese control block locations containing your userid.  Output from the\nALLIDS display is shown in Figures 1 and 2.  You can obtain the source\ncode for ALLIDS from CBT Tape File 731.\n\n      The most important places where a program is looking for a TSO id,\nand which must change, are the PSCBUSER field (which many programs use\nto identify a userid), the UPTPREFX field (which determines the TSO\nprefix), and the userid field at +X'49' in the LWA (Logon Work Area).\nThese fields have always been 7 characters long, and they are very\nheavily used by programs.  New fields have had to be created for these\nareas, when the userid is 8 characters long.  The contents of the old\nfields (if the userid is 8-characters) varies by which control block,\nbut in the 8-character case, the contents of the 7-character field is\nalways invalid, and is therefore useless for its original purpose.\n\n      For example (see Figure 2), if the TSO userid has 8-characters,\nthen the old PSCBUSER and UPTPREFX fields are artificially set to the\nstring '>7BYTES', and the old length fields are set to X'07' (bytes).\nMeanwhile, the new userid field contains the full 8-byte userid, and\nthere is a new length field, which contains the quantity X'08'.  In\ncontrast, in the LWA, the old userid field at X'49' is set to 7 blanks,\nand the old length field at X'48' is set to X'08'.  There is no \"new\nlength\" field in the LWA, but there is a new 8-byte userid field at\nX'1DC' which contains the full-length userid.  All of this means that\nmany programs have to be changed.\n\n      Many of the other places where your userid is found in the system\nhave already been set to 8 bytes in length.  For example, RACF has\nalways kept the userid (in the ACEEUSRI field) as 8 bytes, so there was\nno need to fix anything up, programmatically, there.\n\n\nTRYING TO PROGRAM THESE CHANGES IN A Z/OS 2.2 SYSTEM\n\n      I had somewhat of a head start in trying to fix any programs that\nwere under my control.  Since I now have the status of a \"developer\",\nand I signed a non-disclosure agreement with IBM, I was able to find out\nSOME of the specifications of the 8-character userid change before\nGeneral Availability of z/OS 2.3, and I was able to talk to the\ndeveloper.  Nevertheless, there were several obstacles.  First, before\nGeneral Availability, the system is still \"plastic\", and even the\ndevelopers aren't sure which new fields and old fields should contain\nwhat.  I had that problem with the old LWA userid field, because I\ndidn't know what IBM would put there when the old field wasn't being\nused.  The second problem (much bigger) was that even though I knew the\nspecs, I didn't have a z/OS 2.3 system to work on.  All my 8-character\nuserid changes wouldn't have any real effect.\n\n      So what did I do?  I had to write some programs.  These programs\nconstituted what I called \"my 8-character conversion toolkit\".\n\n      The first program I wrote was the program to throw the switch, and\nI called it TSVT8.  TSVT8 is a TSO command that has a choice of three\nparameters, 0, 7, or 8.  This sets the TSVT+6 field to either X'00',\nX'07', or X'08'.  We have to have this program available first, because\nif the switch can't be turned on, you can't get anywhere else.  I found\nout later, that the value in TSVT+6 is mirrored in TPVT+X'4D', but\nTSVT+6 is the real switch and the other field is just there as an\nindicator to show how the TSVT+6 switch is set.  When I found out about\nTPVT+X'4D', I fixed the TSVT8 program to correspondingly change that\nfield as well.\n\n      Even after 8-character support in z/OS 2.3 is in effect, the TSVT8\ncommand is still useful, because now you can feel its real effect when\nit works.  So the programming was not in vain.  I have a lasting tool\nwhich I can use for testing.  TSVT8 source can be found on CBT File 731.\n\n      Then, I had to write a program to make an 8-character TSO prefix.\nWhy?  In z/OS 2.2, or in a 2.3 system with the 8-character support\nturned off, the TSO PROFILE command will not create an 8-character TSO\nprefix.  Since I had the specs, I wrote the CPFX program to modify the\nproper fields in the UPT control block and to correctly create an\n8-character prefix, at least in the UPT control block itself.  On a 2.2\nsystem it wouldn't actually work, but at least the control block\nstructure was there.  Even now, with 8-character support fully in\nplace, the CPFX program is also useful.  And it can be used instead of\nthe PROFILE PREFIX command whenever I want to use it.  The source code\nfor CPFX can also be found on CBT File 731.\n\n      To see what I was doing, I needed to modify the LPSCB program\nfrom CBT File 300, which shows all the fields in the PSCB, UPT, and ECT\nTSO control blocks.  I had to make LPSCB show the new PSCBUID8 and\nPSCBU8L (userid and length) fields, as well as the UPTPREF8 (prefix) and\nUPTPRF8L (prefix length) fields.  See Figure 3 for sample LPSCB output.\nTo show all of the three control blocks, you have to invoke LPSCB ALL.\n\n      I followed this up with programs to change the userid in various\nplaces according to the new rules, and I tested those programs using the\nALLIDS TSO command which displayed the results.  These programs enabled\nme to simulate the effect of the 8-character userids, even on a 2.2\nsystem where they weren't applicable.  Then I was able to modify\nexisting programs which depended on the old fields, so they would\ncorrectly respond to 8-character ids which filled the new control block\nfields, as well.  I'm happy to report that the effort was successful.\nOf course, once z/OS 2.3 came out, I tested all these programs there as\nwell, as well as all of the TSO commands and utility programs which\nneeded to be modified to accommodate 8-character TSO ids.\n\n      For illustrative purposes, to see how a program was converted from\ngetting your userid from just the PSCBUSER field, to accommodating an\n8-character userid, I've included a very short Assembler program which\nshows you the point.  See Figure 4, and you should get the idea.\n\n      So, other than bringing you illustrations of some of the programs\nand TSO command outputs mentioned here, we have come to the end of the\ndiscussion for now.\n\n      We wish all of you the best of everything, and we hope to see you\nagain in this space, the next time.\n\n\n                         ILLUSTRATIONS\n\n\nFigure 1.   Output of the ALLIDS command for a TSO userid\n            of 7 characters or less.  This was run on a\n            z/OS 2.3 system where the new fields are filled\n            in.  On an older system, the new fields are zeros.\n\n\nALLIDS - SHOW TSO USERID OCCURRENCES - V1.3\n------   ---- --- ------ -----------   ----\n   cntl            old    len   new   len\n  block           field   gth  field  gth\n   ----           -----    --  -----   --\nMy PSCB Userid is IBMUSER  07 IBMUSER  07\nMy UPT  Prefix is IBMUSER  07 IBMUSER  07\nMy JCT  Userid is IBMUSER\nMy JMR  Userid is IBMUSER\nMy TIOT Userid is IBMUSER\nMy ASCB Userid is IBMUSER\nMy ASXB Userid is IBMUSER\nMy ACEE Userid is IBMUSER  07\nMy LWA  Userid is IBMUSER  07 IBMUSER\nMy TSBX Userid is IBMUSER\nMy CSCB Userid is IBMUSER\nMy CSCX Userid is IBMUSER\nMy OUCB Userid is IBMUSER\nMy JSAB Userid is IBMUSER  Jobname IBMUSER\nMy CAUB Userid is IBMUSER\n8-CHARACTER USERID SUPPORT IS: ON\n\n\nFigure 2.   Output of the ALLIDS command for a TSO userid\n            of 8 characters.  PSCB, UPT, and LWA needed\n            new fields for the userid (and length).  Note\n            the values that are placed in the old fields.\n\n\nALLIDS - SHOW TSO USERID OCCURRENCES - V1.3\n------   ---- --- ------ -----------   ----\n   cntl            old    len   new   len\n  block           field   gth  field  gth\n   ----           -----    --  -----   --\nMy PSCB Userid is >7BYTES  07 IBMUSERC 08\nMy UPT  Prefix is >7BYTES  07 IBMUSERC 08\nMy JCT  Userid is IBMUSERC\nMy JMR  Userid is IBMUSERC\nMy TIOT Userid is IBMUSERC\nMy ASCB Userid is IBMUSERC\nMy ASXB Userid is IBMUSERC\nMy ACEE Userid is IBMUSERC 08\nMy LWA  Userid is          08 IBMUSERC\nMy TSBX Userid is IBMUSERC\nMy CSCB Userid is IBMUSERC\nMy CSCX Userid is IBMUSERC\nMy OUCB Userid is IBMUSERC\nMy JSAB Userid is IBMUSERC Jobname IBMUSERC\nMy CAUB Userid is IBMUSERC\n8-CHARACTER USERID SUPPORT IS: ON\n\n\nFigure 3.   Full output of the LPSCB TSO command, using its \"ALL\"\n            parameter, and showing 8-character userid support.\n\n8-character Userid Support is: ON\n00006F80 PSCB Address\n    +0  PSCBUSER C9C2D4E4E2C5D9   IBMUSER\n    +7  PSCBUSRL 07\n    +8  PSCBGPNM E2E8E2C1D3D3C4C1 SYSALLDA\n   +10  PSCBATR1 E100             OPER ACCT JCL CONS\n   +12  PSCBATR2 0000\n   +14  PSCBLTIM D73AD3E63A5CF843 2019.360  10:23.29.588687\n   +1C  PSCBSUBH 00\n   +1D  PSCBSUBC 00\n   +1E  PSCBSUBM 00\n   +1F  PSCBSOUT 00\n   +20  PSCBU8L  07\n   +21  PSCBDRBA 00006C\n   +24  RESERVED 00000000\n   +28  PSCBDEST 0000000000000000\n   +30  PSCBRLGB 00007EF8\n   +34  PSCBUPT  00008FC8\n   +38  PSCBUPTL 0038\n   +3A  PSCBCHAR 00\n   +3B  PSCBLINE 00\n   +3C  PSCBRSZ  000F4240\n   +40  PSCBU    0000000000000000\n   +48  PSCBEXWD\n   +48  PSCBEXK  00000000\n   +4C  PSCBEXL  00000004\n   +50  PSCBEXD  00000000\n   +54  PSCBUID8 C9C2D4E4E2C5D940 IBMUSER\n   +5C  RESERVED 00000000000000000000000000000000\n   +6C  End-PSCB\n00008FC8 UPT from PSCB\n00008FC8 UPT from CPPL\n    +0  UPTLEN   0038\n    +2  UPTUSER  C5E2C4C1E84040000000\n    +C  UPTSWS   21\n    +D  UPTCDEL  00\n    +E  UPTLDEL  00\n    +F  UPTVERS  01\n   +10  UPTPREFX C9C2D4E4E2C5D9   IBMUSER\n   +17  UPTPREFL 07\n   +18  UPTPLANG C5D5E4           ENU\n   +1B  UPTSLANG C5D5E4           ENU\n   +1E  UPTLNGFL 0000\n   +20  UPTSWS2  00\n   +21  UPTPREF8 C9C2D4E4E2C5D940 IBMUSER\n   +29  UPTPRF8L 07\n   +2A  RESERVED 0000000000000000000000000000\n   +38  End-UPT\n0000BB88 ECT Address\n    +0  ECTRCDF  00\n    +1  ECTRTCD  000000\n    +4  ECTIOWA  009A4F10\n    +8  ECTMSGF  80\n    +9  ECTSMSG  000000\n    +C  ECTPCMD  D3D7E2C3C2404040 LPSCB\n   +14  ECTSCMD  4040404040404040\n   +1C  ECTSWS   00\n   +1D  ECTDDNUM 000000\n   +20  ECTUSER  00000000\n   +24  ECTBKPB  00000000\n   +28  ECTSWS2  8C\n   +29  ECTSWS22 00\n   +2A  RESERVED 0000\n   +2C  ECTHELP  009BDD6C\n   +30  ECTENVBK 0C883C90\n   +34  ECTEXTPR 0C71CF80\n   +38  End-ECT\n\n\nFigure 4.   An assembler program that used to display your own\n            userid with PSCBUSER.  Now it takes the 8-character\n            fields into account.  The reason that the displacements\n            were used instead of macro fields from the IKJPSCB\n            macro, was because the 2.3 macros weren't yet available,\n            and this had to be assembled on a 2.2 system.\n\n\n*      TSO COMMAND PROCESSOR TO DISPLAY THE USERID OF THE INVOKER.\n         YREGS\nMYID     CSECT\n         STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS\n         LR    R12,R15             LOAD ENTRY POINT INTO BASE REGISTER\n         USING MYID,R12            TELL THE ASSEMBLER R12 IS BASE\n         LR    R15,R13             SAVE CALLER'S SAVE ADDRESS\n         LA    R13,SAVE            GET OUR SAVEAREA ADDRESS\n         ST    R15,SAVE+4          STORE HIS SAVEAREA INTO MINE + 4\n         ST    R13,8(,R15)         STORE MINE INTO HIS SAVEAREA + 8\nRUNCHAIN L     R3,16               POINT TO CVT.\n         L     R3,0(,R3)           POINT TO TCB/ASCB WORDS\n         L     R3,4(,R3)           POINT TO TCB.\n         L     R3,X'B4'(,R3)       POINT TO JSCB.\n         L     R3,X'108'(,R3)      POINT TO PSCB.\n         MVC   MSGLINE+13(7),0(R3)    MOVE USERID IN FROM PSCBUSER\n         CLC   MSGLINE+13(7),=C'>7BYTES'  IS THE NEW FIELD NECESSARY?\n         BNE   SEVENCHR                   NOT 8 CHARS, USE PSCBUSER\n         MVC   MSGLINE+13(8),X'54'(R3)    MOVE USERID FROM PSCBUID8\nSEVENCHR DS    0H\n         TPUT  MSGLINE,L'MSGLINE      DISPLAY THE MESSAGE ON THE TUBE\nRETURN   DS    0H                  RETURN TO CALLER\n         L     R13,SAVE+4          RELOAD CALLER'S SAVEAREA POINTER\n         LM    R14,R12,12(R13)     RELOAD REGISTERS\n         BR    R14                 RETURN TO CALLER\nSAVE     DC    18F'0'              MY SAVE AREA\nMSGLINE  DC    C'MY USERID IS         '      LINE FOR MESSAGE\n         LTORG\n         END\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BM2001JB": {"ttr": 2312, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1b\\x00\\x19\\x01\\x10\\x15\\x8f\\x01 \\x00?\\x10\\x19\\x01\\xe6\\x01\\x16\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.27", "flags": 0, "createdate": "2010-06-07T00:00:00", "modifydate": "2020-01-03T10:19:19", "lines": 486, "newlines": 278, "modlines": 0, "user": "SBGOLOB"}, "text": "          SAVING AND RELOADING IPL TEXT - A NEW TECHNIQUE\n\n(c) Copyright 2020 by Sam Golob.  All rights reserved.\n\n      IPL text is a somewhat mysterious item to most of us.  When\nsetting up a new system, you load it onto (Track 0 of) the system\nresidence pack using the ICKDSF program from IBM, and then you forget\nabout it.  The IPL text to boot the current level of the system is\nlocated in two members of SYS1.SAMPLIB, and you run the job to load it.\nPlease see Figure 1 for a sample job which will be similar to the actual\njob that is run.\n\n      If you loaded the IPL text for the wrong z/OS release, you will\nget a wait state 075, reason code 6 when you try to IPL.  Everybody\nknows that the IPL text is what boots up the operating system.  Very few\nof us know how it is coded.  And not many of us know how to jockey it\nfrom pack to pack, or save it and restore it.  This third thing is what\nwe'll teach you about today.\n\n      Today we're going to talk a lot about this subject of IPL text.\nAnd we have to start somewhere.  I guess that the first thing we should\nmention is how to find out which disk packs on your system already have\nIPL text loaded on them.  There has to be at least one disk pack on the\nsystem which is loaded with IPL text, or your system would not be able\nto boot.  So such a search of all your packs will definitely have to\nyield at least one positive result.  You'll have to find some IPL text\nsomewhere on the installation's volumes.  How is it done?\n\n      Lionel Dyck made this task easy, with his IPLTCHK exec that can be\nfound on CBT Tape File 312.  IPLTCHK depends on the TSO command DUDASD,\nwhich can be found on CBT File 612.  The DUDASD command displays a list\nof all the disk volumes on your system, and then the IPLTCHK exec reads\nthe list and generates multiple ADRDSSU job steps to print out Track 0\nfrom all of them.  When you look at the resulting report, it then\nbecomes obvious, not only which packs have IPL text, but you can also\nsee exactly what the IPL text is.  It's quick and fantastic.  Try it.\nSee Figure 2 for an illustration of the generated JCL from the IPLTCHK\nexec.  You can copy this JCL to print out Track 0 from any ONE disk pack\nas well.  And by the way, you can filter the list of disk volumes which\nIPLTCHK will list.  See the comments in the IPLTCHK exec.  This is based\non the fact that DUDASD has a filter to limit the number of volumes that\nit displays.\n\n      At this point, if you've performed the exercise of printing all\nthe track 0 contents from your system, and you're looking at the report,\nyou might want to try saving the IPL text from one or more of the packs\nwhich have IPL text.  Not everybody knows how to do this.  Actually,\nthis is something that very few people know how to do (until now).\n\n\nSAVING YOUR IPL TEXTS TO A PDS\n\n      Once you know which disk packs contain IPL text, you might want to\ndo one of our favorite types of system programmer tasks.  You might want\nto back up all the IPL texts on your system for safekeeping.\n\n      Most people don't know how to do that.  And not long ago, we\ndidn't know how to do that either.  But now I'll show you how, using a\ngreat set of tools, originally written by our friend somitcw and which\ncan be found on CBT File 846.  These tools allow you to back up IPL text\nand restore it to the same volume, or to a different volume.\n\n      The names of the 3 main programs on CBT Tape File 846 are:\nTRK0SAVE to back up the IPL text from a pack, TRK0UPD to reload the\nsaved IPL text in TRK0SAVE format, and TR02ABS to convert the saved IPL\ntext from TRK0SAVE format, to IBM's ICKDSF ABSFORMAT format.\n\n      There is also a program called TRK0INIT on File 846, which can\nREMOVE IPL text from a volume, but it is not recommended to use it.  The\nfirst reason not to use TRK0INIT to remove IPL text, is because of the\ndanger.  You don't want to remove IPL text from a pack that needs it,\nespecially from the system res pack.  That's disastrous because you\nwon't be able to IPL.  The second reason happens when you only want to\nput different IPL text on a volume which already has IPL text, using the\nTRK0UPD program.  When using TRK0UPD to put new IPL text on a volume, it\nwill overlay any old IPL text that was there before, and wipe it out.\nTherefore it is not necessary to wipe off the old IPL text that was on\nthe pack, before putting new IPL text on the same pack.  The only reason\nwhy TRK0INIT was created, was for completeness.  What if you put IPL\ntext on a pack by mistake, and you want to clean it off.  We need to\nhave a way to do that.  This is why we wrote TRK0INIT.\n\n      As we inferred, the format of these TRK0SAVE backups is different\nfrom the format that ICKDSF ABSFORMAT needs to reload them, but CBT File\n846 now contains a program called TR02ABS which converts our TRK0SAVE\nformat backup into the ICKDSF ABSFORMAT format.  (See the comments in\nthe TR02ABS code, which explain the difference in the formats.)  So\nonce you've converted your backups, they can always be reloaded by\nICKDSF.  If you have a pds of IPL text backups in TRK0SAVE format, I'd\nrecommend that you also keep a corresponding pds of IPL text backups in\nABSFORMAT as well.  Besides the redundancy, someone later might not have\na copy of TRK0UPD which is needed to reload the backups in the TRK0SAVE\nformat.  Safety first.  The IBM program ICKDSF is in every z/OS system.\n\n      What kind of pds can we save our IPL texts to?  What DCB\nproperties should it have?  To answer this, we'd say that IPL text is\nsimilar to a load module, and it can contain any length records, only\nbeing limited by the length of Track 0 on that disk device.  So it is\nclear that the DCB of our backup pds will have to be RECFM=U, and\nLRECL=32760.  By the way, you can also save your IPL text to a\nsequential dataset with these attributes, but in my opinion, a pds is\nbetter, because with a pds, you can store backups of many different IPL\ntexts in one convenient place.  And since IPL text cannot be any longer\nthan one track in size, each IPL text does not take up much room.\nTherefore a pds is a really convenient way to store your backups of IPL\ntexts.\n\n      So how do we do it?  Look at Figure 3 to see sample backup JCL of\nIPL text.  Look at Figure 4 to see a sample reload of the same IPL text.\nUsing the TRK0SAVE program to back up the IPL text, the DISKIN DD name\npoints to the pack whose Track 0 you want to back up.  And the OUTPUT\nDD name points to the RECFM=U, LRECL=0, BLKSIZE=32760 output dataset,\nwhether it be sequential, or a member of a pds.\n\n      To restore the backed up IPL text you run the TRK0UPD program, and\nuse its DD names to do the opposite.  The DISKIN DD name is the same as\nfor TRK0SAVE, except that in TRK0UPD it is the input file.  The output\ndisk is pointed to by the DISKUPD DD name.  Figure 4 illustrates this\nwell enough.  These processes run very quickly, because they don't have\nto process much data.\n\n\nCHECKING UP ON YOUR WORK\n\n      Since the TRK0SAVE and TRK0UPD programs (as well as the other\nprograms) were not meant to be used often, and were meant to be used by\nrelatively experienced personnel, they were not written to produce any\noutput messages.  (This may change in the future.)  So for now, we need\na way to check if such crucial work, which has to be 100 percent\naccurate, was done correctly.  The tool of choice here, is called\nFullscreen ZAP.  If you don't want to run Fullscreen ZAP, then you can\nrun the ADRDSSU job shown in Figure 2, against the pack you're working\non.  This will print out the contents of Track 0 on your pack, and you\ncan keep track of everything you have done, to make sure it is accurate.\n\n      To look at the backup dataset, whether it be a pds member or a\nsequential dataset, you can ISPF Browse it, or use the wonderful REVIEW\nprogram (source on CBT File 134, load modules on CBT File 135) to see\nwhat is there.  But if you want to update anything on the backup file,\nor even if you just want to see it more clearly, you will probably be\nbest off using the TSO Fullscreen ZAP command.  Fullscreen ZAP is also\npractical for just viewing the backup dataset.  In addition, Fullscreen\nZAP can directly view Track 0 records in Hex, and you can get a graphic\npicture of everything there, up to 208 bytes at a time, on the screen.\n\n      I'll tell you how to start using Fullscreen ZAP.  ZAP is a TSO\ncommand, which is invoked (under ISPF) by saying: TSO ZAP dataset.name\nIf you want to see track zero of a pack whose volume serial is MYPACK,\nthen you say:  TSO ZAP 'FORMAT4.DSCB' VOL(MYPACK) FULLVOL\nFULLVOL support requires that ZAP be invoked APF-authorized.  When you\nget into ZAP in FULLVOL mode, the program thinks that the extents it\nis looking for, encompass the entire volume, so the \"dataset\" you're\nopening consists of the entire volume.  That's why the display starts\nat Track 0, Record 1 of the track.  And therefore you can get a good\nlook at Track 0.\n\n      To look at a sequential dataset using ZAP, and if it is cataloged,\nthen you just say:  ZAP dataset.name .  If it is not cataloged, you say:\nZAP dataset.name VOL(volser) .  To look at a pds with ZAP, you do the\nsame thing, but once you're in, you're looking at the directory.  If you\nwant to look at a member of the pds, you say:  Mmember.  Don't put any\nspaces between the \"M\" (which is the command) and the member name.  If\nyou're looking at a load library, which we aren't doing now, you say\nMmember and then you say Eentrypt .  When you're within ZAP, help is\nalways at hand, by typing in a question mark.\n\n      Source code for ZAP is on CBT File 134 (member ZAP) and the load\nmodule is on CBT File 135.  For some of its functions, the ZAP module\nhas to be authorized, so it is advisable to linkedit it with SETCODE\nAC(1) and put it into the IKJEFTE2 TSO Table (AUTHCMD NAMES in the\nIKJTSOxx PARMLIB member).  Once you've started executing ZAP, and you\nare in one of its screens, full HELP is accessible by entering the\ncommand \"?\" (without the quotes) at any time.  PF3 gets you back to what\nyou were doing.  Pressing ENTER while you're in help mode, gets you to\nthe next help screen, and there are 13 of them.  A little bit of\npractice with the help for ZAP, goes a long way.  Everything is really\nthere, and you can learn to use ZAP well, all on your own.\n\n\nA FEW EXAMPLES OF BACKING UP IPL TEXT AND RESTORING IT\n\n      Let's say that we're building a clone of our z/OS 2.4 system, and\nwe already have a running system residence pack.  Instead of re-running\nthe IBM job to load the IPL text from SYS1.SAMPLIB (see Figure 1), we\nare going to run two jobs (see Figures 3 and 4).  The first job (Fig. 3)\nbacks up the existing IPL text from pack ZOSRES into a backup dataset\nwhich is a member of the pds:  IBMUSER.IPLTEXT.PDS.  The second job\n(Fig. 4) reloads the backup of the z/OS 2.4 IPL text, on to the new res\npack called ZNWRES.  This performs the same work as the running the IBM\njob (from Figure 1) twice, but it also provides a backup of the IPL text\nwhich we can save for future use.\n\n      This technique is much more useful when we have to deal with IPL\ntexts that don't come from IBM.  Suppose we have a disk pack which has\nIPL text from a vendor who went out of business, and we need to run the\nproduct, but we don't have the original install materials.  Then this\ntechnique will save the day.  Just back up the (obscure) IPL text to a\ndataset, and restore it to any pack that you want, which needs it.  No\nfuss, no muss.  It takes less than a minute.\n\n      Next, I'll illustrate another technique.  Suppose we have a saved\ncopy of the IPL text for ZZSA (CBT Files 437 and 538), which is a system\nrecovery tool.  ZZSA is a multi-utility package which is installed as\nIPL text on (for example) a disk volume.  When you IPL ZZSA, you have\naccess to a primitive editor, disk browser, and other tools.  You can\nuse these tools when the system won't come up because of an IPL problem,\nand you can fix your system res pack or any other data that needs\nfixing, so you can IPL normally afterward.\n\n      Let's say that our only copy of ZZSA IPL text which we have, is a\nbackup in TRK0SAVE format.  We can convert this backup into ICKDSF\nABSFORMAT format, using a job like in Figure 5, and then you can run the\nIBM job (using ICKDSF) such as in Figure 6, to load this same IPL text\non to any pack you want.\n\n      I'll conclude this article with an observation.  When a disk pack\ndoes not contain IPL text, the IPL2 record (Record 2 on Track 0) has a\nstandard format for a pack with no IPL record.  I've displayed this\nrecord (Figure 8), using the Fullscreen ZAP TSO command.  As we said\nbefore, to get into ZAP and to look at Track 0, we have to type:\nTSO ZAP 'FORMAT4.DSCB' VOL(ourpak) FULLVOL.  To get to Record 2, we just\ntype R to get to the next record.  Notice, in Figure 8, that the TTR of\nthe displayed record is 000002.  (The TTR of the first record in Track 1\nwould be 000101.)\n\n      Now look at Figure 7.  By contrast, you can see that there are\nother fields which are filled in, when IPL text exists on Record 4 of\nTrack 0, or (in other words) more records exist on Track 0.  The disk\npack illustrated by Figure 7 has IBM IPL text on it for z/OS 2.3.  This\nIPL text adds only one additional record (Record 4) to Track 0.\n\n      By contrast again, look at Figure 9.  Figure 9 shows the IPL2\nrecord (Track 0 Record 2) for a pack with ZZSA IPL text on it.  ZZSA\nIPL text contains 11 records, from 4 thru 14 (or Record E in hex).\nYou can see that this Record 2 is very different from the other two.\n\n      We have to break now, till next time.  I hope that this topic is\ninstructive and enlightening, and it helps you in your work.  This idea\nof backing up and restoring IPL text is not well-known among z/OS\nsystems practitioners at this time.  But it is not hard to grasp, once\nyou look at it carefully, and it can potentially be a life-saver in many\nsituations.\n\n      All the best of everything to all of you.\n\n\n                      ILLUSTRATIONS\n\nFigure 1.  The normal job that is run when you want to load\n           z/OS IPL text onto Track 0 of the system residence\n           pack.  The system level of SYS1.SAMPLIB must match\n           the system level of z/OS that you want to run.\n           If the levels do not match, you might get a wait state\n           075 with reason code 6, when you try to IPL.\n\n\n//IBMUSERP JOB ,'LOAD IPL TEXT',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//*****************************************************************\n//* PUT IPL TEXT ON IPL VOLUME USING ICKDSF\n//*****************************************************************\n//IPLTEXTL EXEC PGM=ICKDSF,PARM=NOREPLYU,REGION=4M,COND=(0,NE)\n//SYSPRINT DD  SYSOUT=*\n//IPLTEXT  DD  DISP=SHR,DSN=SYS1.SAMPLIB(IPLRECS)\n//         DD  DISP=SHR,DSN=SYS1.SAMPLIB(IEAIPL00)\n//SYSIN    DD  *\n   REFORMAT  DDNAME(IPLTEXT)                                     -\n             IPLDD(IPLTEXT)                                      -\n             NOVERIFY                                            -\n             BOOTSTRAP   /* IPLRECS OF IPLTEXT DD WILL SUPPLY IT */\n/*\n\n\nFigure 2.  Partial output of Lionel Dyck's IPLTCHK REXX exec.\n           The exec runs the DUDASD TSO command to list all\n           active DASD on the system, and then it parses the\n           list, to generate a printout of Track 0 for each\n           DASD volume.  It then becomes obvious, not only\n           which volumes CONTAIN IPL text on them, but also,\n           you can see exactly what the IPL text consists of.\n           This is a great report.  You can also run the JCL\n           against any single pack to see its IPL text.\n\n\n//DUMP01   EXEC PGM=ADRDSSU,REGION=4096K\n//SYSPRINT DD   SYSOUT=*\n//OUTPUT   DD   SYSOUT=*\n//SYSIN     DD *\n  PRINT TRACKS(0,0,0,0) -\n     INDYNAM(ZOSRES) -\n     ADMIN -\n     OUTDDNAME(OUTPUT)\n  PRINT TRACKS(0,0,0,0) -\n     INDYNAM(ZOSRS1) -\n     ADMIN -\n     OUTDDNAME(OUTPUT)\n  PRINT TRACKS(0,0,0,0) -\n     INDYNAM(ZOSRS2) -\n     ADMIN -\n     OUTDDNAME(OUTPUT)\n  PRINT TRACKS(0,0,0,0) -\n     INDYNAM(ZOSRS3) -\n     ADMIN -\n     OUTDDNAME(OUTPUT)\n  PRINT TRACKS(0,0,0,0) -\n     INDYNAM(ZOSRS4) -\n     ADMIN -\n     OUTDDNAME(OUTPUT)\n  PRINT TRACKS(0,0,0,0) -\n     INDYNAM(ZOSRS5) -\n     ADMIN -\n     OUTDDNAME(OUTPUT)\n  PRINT TRACKS(0,0,0,0) -\n     INDYNAM(ZOSRS6) -\n     ADMIN -\n     OUTDDNAME(OUTPUT)\n\n    * * * * * * * * (etc. etc. etc.)\n\n\nFigure 3.  Job to back up the IPL text of a disk pack, to a\n           pds member.\n\n\n//IBMUSERS JOB ,'SAVE IPL TEXT',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//* If you change output to go to SYS1. or SYS2. data sets, then\n//* reply the master catalog password on the console. Twice.\n//*\n//TRK0SAV1 EXEC PGM=TRK0SAVE\n//STEPLIB  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB  (APF-authorized)\n//SYSUDUMP DD  SYSOUT=*\n//DISKIN   DD  UNIT=3390,SPACE=(TRK,1),VOL=SER=ZOSRES\n//OUTPUT   DD  DISP=SHR,DSN=IBMUSER.IPLTEXT.PDS(Z24IPLT)\n//*\n\n\n\nFigure 4.  Job to load the IPL text of a disk pack, from a backup\n           which is a pds member.\n\n\n//IBMUSERI JOB ,'LOAD IPL TEXT',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//TRK0UPD EXEC PGM=TRK0UPD\n//STEPLIB  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB  (APF-authorized)\n//SYSUDUMP DD  SYSOUT=*\n//DISKUPD  DD  UNIT=SYSDA,SPACE=(TRK,1),VOL=SER=ZNWRES\n//DISKIN   DD  DISP=SHR,DSN=IBMUSER.IPLTEXT.PDS(Z24IPLT)\n//*\n\n\n\nFigure 5.  Job to convert an IPL text backup in TRK0SAVE format\n           to IPL text source in ICKDSF ABSFORMAT format.\n\n\n//IBMUSERC JOB ,'CONVERT IPLTEXT BACKUP',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//CNVIPLT PROC MEMB=XXXX\n//CONVERT EXEC PGM=TR02ABS\n//STEPLIB  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSUT1   DD  DISP=SHR,DSN=IBMUSER.IPLTEXT.PDS(&MEMB)\n//SYSUT2   DD  DISP=SHR,DSN=IBMUSER.IPLTEXT.ABS(&MEMB)\n//        PEND\n//C001    EXEC CNVIPLT,MEMB=Z21IPLT\n//C002    EXEC CNVIPLT,MEMB=Z23IPLT\n//*\n\n\n\nFigure 6.  Job to use ICKDSF to load converted IPL text in\n           ICKDSF ABSFORMAT format, to a disk pack.\n\n\n//IBMUSERP  JOB (ACCT#),S-GOLOB,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X\n//*****************************************************************\n//* PUT IPL TEXT ON IPL VOLUME USING ICKDSF\n//*****************************************************************\n//*\n//STP1   EXEC PGM=ICKDSF,REGION=0M\n//SYSPRINT DD SYSOUT=*\n//IVOL DD VOL=SER=ZZSAVL,UNIT=SYSALLDA,DISP=SHR\n//SAMPLIB DD DISP=SHR,DSN=IBMUSER.IPLTEXT.ABS(ZZSATEXT)\n//SYSIN DD *\n  REFORMAT DDNAME(IVOL) VERIFY(ZZSAVL) IPLDD(SAMPLIB,ABS) BOOTSTRAP\n/*\n//\n\n\n\nFigure 7.  Record 2 (IPL2) of Track 0, for a volume which\n           contains IPL text in Record 4.  Shown using the\n           Fullscreen ZAP TSO command.  The IPL text is for\n           z/OS 2.3 in this case, which adds just one extra\n           Track 0 record:  Record 4.\n\n\n                                 Z  A  P\n\nENTER VALID COMMAND ABOVE OR ? FOR HELP         VERSION=3.3Z 02MAY13\nR\n\n00000  >C9D7 D3F2  0700 4AB8   4000 0006  3100 4ABE   |IPL2..\u00a2. .....\u00a2.|\n00010   4000 0005  0800 4AA0   0000 0000  0600 0000   | .....\u00a2.........|\n00020   2000 2F55  0000 0000   0000 0000  0000 0400   |................|\n00030   0000 0000  0000 0000   0000 0000  0000 0000   |................|\n00040   0000 0000  0000 0000   4040 4040  4040 4040   |........        |\n00050   4040 4040  4040 4040   4040 4040  4040 4040   |                |\n00060   4040 4040  4040 4040   4040 4040  4040 4040   |                |\n00070   4040 4040  4040 4040   4040 4040  4040 4040   |                |\n00080   4040 4040  4040 4040   4040 4040  0000 0000   |            ....|\n00090   0000 0000                                     |....            |\n\n\n\n\nOFF: 0000 (     0) ADDR: 00000 (       0) DSN:   VOLUME Z23RES\nLEN: 0094 (   148) BASE: 00000 (       0) CCHHR: 0000000002 TTR:  000002\n\n\n\nFigure 8.  Record 2 (IPL2) of Track 0, for a volume which\n           does not contain IPL text, and there is no Record 4\n           on Track 0.\n\n\n                                 Z  A  P\n\nENTER VALID COMMAND ABOVE OR ? FOR HELP         VERSION=3.3Z 02MAY13\nR\n\n00000  >C9D7 D3F2  0700 3AB8   4000 0006  3100 3ABE   |IPL2.... .......|\n00010   4000 0005  0800 3AA0   0000 0000  0600 0000   | ...............|\n00020   2000 0000  0000 0000   0000 0000  0000 0400   |................|\n00030   0000 0000  0000 0000   0000 0000  0000 0000   |................|\n00040   0000 0000  0000 0000   0000 0000  0000 0000   |................|\n00050   0000 0000  0000 0000   0000 0000  0000 0000   |................|\n00060   0000 0000  0000 0000   0000 0000  0000 0000   |................|\n00070   0000 0000  0000 0000   0000 0000  0000 0000   |................|\n00080   0000 0000  0000 0000   0000 0000  0000 0000   |................|\n00090   0000 0000                                     |....            |\n\n\n\n\nOFF: 0000 (     0) ADDR: 00000 (       0) DSN:   VOLUME Z23RS1\nLEN: 0094 (   148) BASE: 00000 (       0) CCHHR: 0000000002 TTR:  000002\n\n\nFigure 9.  Record 2 (IPL2) of Track 0, for a volume which contains\n           IPL text for the ZZSA recovery tool from Jan Jaeger.\n           ZZSA IPL text adds many records to Track 0, going from\n           Record 4 to Record E (decimal 14).  This is somehow\n           reflected in the IPL2 record (Record 2) which we see here.\n\n\n                                 Z  A  P\n\nENTER VALID COMMAND ABOVE OR ? FOR HELP         VERSION=3.3Z 02MAY13\nR\n\n00000  >C9D7 D3F2  0600 6238   4000 0A44  0600 6E30   |IPL2.... .....>.|\n00010   4000 0832  0600 7818   0000 0607  0000 0000   | ...............|\n00020   0000 0000  0000 0000   0000 0000  0000 0400   |................|\n00030   0000 0000  0700 7E40   4000 0006  3100 7E46   |......=  .....=.|\n00040   4000 0005  0800 7E58   0000 0000  0600 0000   | .....=.........|\n00050   4000 0008  0600 0058   4000 0028  0600 0200   | ....... .......|\n00060   4000 0028  0600 02E8   4000 1B48  0600 1EE8   | ......Y ......Y|\n00070   4000 0100  0600 2768   4000 0D98  0600 35A0   | ....... ..q....|\n00080   4000 1725  0600 55C6   4000 0ACC  0800 7E20   | ......F .....=.|\n00090   0000 0000                                     |....            |\n\n\n\n\nOFF: 0000 (     0) ADDR: 00000 (       0) DSN:   VOLUME ZZSA01\nLEN: 0094 (   148) BASE: 00000 (       0) CCHHR: 0000000002 TTR:  000002\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BM2001JC": {"ttr": 2566, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x08\\x01 \\x01\\x7f\\x01 \\x01\\x9f\\x14@\\x02\\x15\\x00\\x04\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2020-01-17T00:00:00", "modifydate": "2020-01-19T14:40:08", "lines": 533, "newlines": 4, "modlines": 0, "user": "SBGOLOB"}, "text": "          CNCLPG - ALTERING AN ADDRESS SPACE - FOR FREE\n\n(c) Copyright 2020 by Sam Golob.  All rights reserved.\n\n      I am very much in favor of our companies making money.  We help\nthem run their computers, and their computers, in turn, help them make\nmoney.  That's the name of the game.  So \"up-time\" is very important,\nespecially in the middle of the day, at peak production hours.\n\n      This entire story was motivated by the failure to be able to set\none bit, in common storage, and the result was that a company's computer\nneeded an IPL in the middle of a working day, with a loss of many tens\nof thousands of dollars.  An expensive OEM software package would have\nsolved the problem, but this company couldn't afford that.\n\n      I never forgot the incident.  Twenty years later, I set about\nto write a free program to do this same job, so that no company in the\nfuture, would ever need to fall prey to the same problem.  And every\ncompany would be able to \"afford\" the tool that provided the solution.\nThe name of the new program (which is a TSO command) is CNCLPG.  Of\ncourse, CNCLPG has to run APF-authorized.  See CBT Files 185, 797, and\n731 for more hints about how to achieve that in your environment.\n\n\nTHE PROBLEM\n\n      The problem was our inability to make JES2 \"cancelable\".  JES2 is\nmarked non-cancelable in the PPT, and at our level (in 1986), which was\nJES2 1.3.6, you simply could not cleanly get rid of JES2.  And you\ncouldn't FORCE it.  The JES2 command $PJES2,ABEND which was the only way\nthat JES2 was able to \"get rid of itself\", left enough old junk in the\nsystem, so that the very bizarre problem we were having with JES2 was\nnot solved.  I finally had no choice but to IPL MVS in the middle of the\nday, causing the company a great loss.\n\n      The company where I had previously worked, a large bank, had\nbought one of the multi-utility OEM add-on products for MVS, which could\nmake a \"non-cancelable\" job \"cancelable\".  My (then) current company\ndidn't have such a product.  Twenty years later, I set about researching\nand writing the CNCLPG multi-utility, to do this (necessary job) for\nfree.\n\n      If I had had this problem with JES2 today, with the latest version\nof the CNCLPG program now available, I probably would have used its BURN\nor KILL option against the JES2 address space, instead of making it\ncancelable using the CNCL option, and then CANCEL-ing it.  Then I'd\nstart JES2 again with the command:  S JES2,PARM='WARM,NOREQ' which would\nforce a JES2 hot start, and restore its former status.  But more on\nthis, later.\n\n\nTHE CSCB CHAIN AND ITS MAPPING MACRO IEECHAIN\n\n      The bit we had to set, belonged in the CSCB entry for our job,\nwhich in our old case was JES2, and which in our current case could be\nany job or STC.  All active jobs, STC's etc. have an entry in the CSCB\nchain of control blocks (Command Scheduling Control Block), and the\njob's CSCB entry has a lot of the \"scheduling info\" for the job,\nincluding the information as to whether or not it is \"cancelable\".\n(See Figure 6.)\n\n      You can get to the job's CSCB entry, either directly from its ASCB\n(ASCBCSCB address pointer), or you can run the entire CSCB chain from\nthe beginning, and you can look for a match on both the jobname and asid\ntogether.  This helps you to close in on the proper entry for the job\nyou want to change.  On all recent systems (XA and above), the CSCB\nchain resides above the 16M line, so you need AMODE 31 in your program\nto address it.  In writing my program, I chose to run the entire CSCB\nchain and look for a \"match\" to determine the job I wanted to change.\nThe reason for that, is that I could access the CSCB entry for any job\nthat way, without knowing its ASCB first.\n\n      I don't always use (IBM's) IKJPARSE, so in this case, I wrote my\nown command parser.  The syntax required either the jobname (right after\nthe CNCLPG command) and/or the keyword ASID(hhhh) with the hhhh being\nthe hex value of the ASID.  In the CSCB chain, you can have multiple\nentries with the same jobname, and multiple entries with the same ASID.\nSo when you use BOTH keywords TOGETHER if you want to change something,\nyou're pretty safe.  But I also coded a DISPlay, keyword, which will\nshow all matches for all combinations, and using DISP will allow you to\nfind and select the exact CSCB entry that you want to alter.  You\nusually have to use DISP together with BOTH the jobname and the\nASID(hhhh) keyword, to make sure that the entry you want to change is\nunique.  See Figure 1, Figure 2, and Figure 3 for an illustration of\nthis process.  First we use the jobname alone with DISP to find ALL\nhits, then we use BOTH the jobname and the ASID(hhhh) together, to get\nto the unique and exact entry which we want to change.\n\n\nTHINGS GET COMPLICATED\n\n      If all I wanted to do, was to write a program to make a job\ncancelable or non-cancelable, it would have been an easy task.  The CSCB\nis accessible in common storage (above the 16M line), and you could do\nall of your business from your own address space, just flipping the\ncancelable/non-cancelable bit CHCL for the appropriate CSCB entry.  (See\nFigure 6 below.)  However, there is some more control to be had here in\nthe CSCB.  And we also have to note that these types of programs can\noften be made to change jobs to be \"swappable\" and \"non-swappable.\nThat's not so easy to do.\n\n      Before attacking \"swappable\" and \"non-swappable\", there was one\nother change that I could easily make.  There is a bit CHAFORCE, which,\nwhen it is on, does not require you to attempt to CANCEL a job, before\nyou try and FORCE it.  So I coded the FORC and NFRC functions in CNCLPG\nto turn this bit on or off.  CNCL and NCNC turn the \"cancelable\" bit on\nor off.  So now I had two functions available in CNCLPG.\n\n      SWAP and NSWP (\"swappable\" and \"non-swappable\") properties of an\naddress space (determined in the PPT), are not easily switched \"on\" or\n\"off\".  Several operations have to be done on the system, and these are\nexecuted using a SYSEVENT macro, which performs all of these multiple\noperations which are necessary.  When some task requests that a JOB or\nSTC should become non-swappable, there is also a \"count\" field in the\nOUCB for the address space (pointed to by ASCBOUCB in the ASCB), telling\nthe address space how many times it was requested to be non-swappable.\nYou can't make an address space swappable unless this count field is\nequal to 1.  Whenever a request for that address space to be\nnon-swappable is removed, then the \"count\" field in the OUCB for that\njob (or STC) is reduced by one.\n\n      This makes sense, because if a task wants a certain address space\nto remain in memory, and not be swapped out, and another task no longer\nneeds that JOB or STC to remain in memory, we still have to honor the\nrequest of the first task.  So there has to be a COUNT field.  CNCLPG\nwill report on the status of this COUNT field, if SWAP, NSWP, TSWP, or\nFSWP functions are involved, and you want to inquire about the job's\nSWAP status first.  Just execute CNCLPG against the CSCB entry using the\nCOUNT function.  See Figures 7 and 8.\n\n      Let's get back to SWAP and NSWP (swappable or non-swappable) status\nof a JOB or STC, and what's involved in changing it.\n\n      I mentioned previously, that you need to execute a SYSEVENT macro,\nbut what I didn't mention, is that the SYSEVENT macro has to execute in\nthe target address space--the address space whose status you want to\nchange.  To do that, you (usually) have to SCHEDULE (or IEAMSCHD) some\nSRB code (which runs the SYSEVENT macro) to run in the target address\nspace, and then you need to report the result of that execution.  In\nother words, you use the SRB to go across address spaces to the target\naddress space whose status has to be changed, and then you report the\nresult of the change in your own program's address space.  Again, see\nFigure 7 for an illustration of this.\n\n      To see further details about this process, you have to look at the\nCNCLPG source code in CBT File 826.  See label SWAPXMEM, and then look\nat the code to set up the SRB, which comes just before it, in the source\ncode for CNCLPG.  The SYSEVENT macro can be run with DONTSWAP, OKSWAP,\nor TRANSWAP keywords.\n\n\nBURN AND KILL\n\n      IBM provides a way to forcibly terminate an address space, using\nits FORCE console command.  The \"business end\" or mechanism of the FORCE\ncommand is the CALLRTM macro with TYPE=MEMTERM.  However, IBM does not\nwant people to terminate address spaces arbitrarily or erroneously, so\nthey make it hard to use FORCE directly.  One way of doing that, is to\nrequire an attempt to CANCEL the JOB or STC before executing a FORCE.\nCANCEL removes a job from the system more cleanly (and with better\ncleanup) than FORCE.  Once you have tried CANCEl, and it does not work,\nthen the system will throw the CHAFORCE bit in the CSCB (see Figure 6),\nand you'll be able to issue the FORCE.  CNCLPG using the FORC function,\nwill throw this bit, without your having to execute the CANCEL first.\nSince the information is out there, I coded for it.\n\n      Some address spaces, such as JES2, contain internal code which\nresists an effort to do a FORCE on the address space.  And finally,\nthere are the \"non-memtermable\" bits in the ASCB for the address space:\nASCBNOMT and less importantly, ASCBNOMD.  If the first of these is on,\nthen the address space can not be FORCE'd using a FORCE console command.\n\n      Sometimes, you just have to get around this.  We are the \"system\ndoctors\", and we are obligated to \"fix whatever ails the system\".  We\nneed to pull any trick in our power (sometimes) to get this done.  So\ntherefore, I coded the BURN keyword to immediately do a CALLRTM with\nTYPE=MEMTERM against the address space.  And if the address space was\n\"stubborn\", with the \"non-memtermable\" bit(s) turned on, so that CALLRTM\nwith TYPE=MEMTERM won't work, I coded the KILL keyword to first turn\nthese bits off, and then issue the CALLRTM TYPE=MEMTERM.  That should\nALWAYS work.!!!!  We've got to have some big guns at our disposal.\n\n      There are some safeguards built into CNCLPG so that an arbitrary\nprogrammer can't execute it.  If you want, you can build more\nsafegurards into it, yourself.  However, you should keep this program\nisolated from the general public.  It is there for your use, as the\n\"doctor for the system\".  A doctor doesn't let a layman use his/her\nprescription pad.  You shouldn't, either.\n\n\nTRANSWAP\n\n      Usually, when the system is starting an address space, it will\ntry and load its code neatly, in contiguous storage.  However, if you\nrun a SYSEVENT macro with the NOSWAP option, to make the address space\nnon-swappable, the system just fixes its pages where they are.  This\nworks, but it is not a neat way to do things.  The OTHER way to do this\nis to run the SYSEVENT macro with the TRANSWAP option.  This will\n(logically) rearrange the storage of the address space neatly, before\npage-fixing it.\n\n      However, you see that this can be dangerous, and although I coded\nthe TSWP function into CNCLPG, you shouldn't use it unless you need to.\nTSWP can move code from one storage location to another, and if one\nprogram needs it in the earlier place where the storage was, there might\nbe problems created by TSWP.  So it's there, but use it carefully.\n\n\nUSING CNCLPG AS A WAY OF EXPLORING THE CSCB\n\n      You can run the entire CSCB chain by executing CNCLPG with a dash\n\"-\" after it.  Like this:  CNCLPG - .  By doing that, and by capturing\nthe (long) output, you can get a very good idea about what is running\nin the system.  You can also see the current settings (for each CSCB\nentry) of the CHACT and CHSTS flags.  Such information can be useful, if\nyou want to explore or monitor the status of the various system address\nspaces.\n\n      Again, you can restrict this display by using the jobname and/or\nASID(hhhh) parameters with the DISP function.  The dash was coded as an\neasy way to run DISP for the entire CSCB chain.\n\n\nACKNOWLEDGEMENTS\n\n      I have to give a big \"shout out\" to my friend and colleague Joe\nReichman, who wrote all the SRB code.  Once Joe got the code to work\ninitially, I was able to enhance it to put in extra features.  But Joe\ndid the hard work, and he deserves great credit for it.\n\n\n                        ILLUSTRATIONS\n\n\nFigure 1.   CNCLPG JES2 DISP\n\n            Run of CNCLPG to find the correct entry for the JES2\n            address space.  Note that any CSCB entry starting with\n            the letters \"JES2\" will cause a match.  This is the way\n            that the DISP(lay) subcommand is coded.  However, if you\n            would issue an \"action\" command against the entry, such\n            as CNCL, you would affect the FIRST entry in the chain.\n            Therefore you should be careful, when changing any entry,\n            to use BOTH the jobname and the ASID keyword, and MAKE\n            SURE YOU HAVE ONLY ONE HIT, WHEN YOU USE THE DISP\n            FUNCTION.  The following DISPLAY run has 3 hits.\n\n\nCNCLPG 1.2.10F - Alter Characteristics of a Running Address Space\n------ ------- - ----- --------------- -- - ------- ------- -----\nSearch Jobname:  JES2\n----------------------------\nAction code   :  CSCB  (DISPlay)\nThis is a run of the CSCB Chain only ...\n----------------------------\nJob  ID :  JES2AUX\nProc ID :  JES2AUX\nASID    :  0021\nCurrent  CHSTS Flags:  40\nCurrent  CHACT Flags:  00\nJob Status:  Non-Cancelable\nJob Status:  Cancel + Force\nJob Status:  Non-Swappable\nJob Status:  Non-Memtermable\n----------------------------\nJob  ID :  JES2MON\nProc ID :  JES2MON\nASID    :  0025\nCurrent  CHSTS Flags:  00\nCurrent  CHACT Flags:  08\nJob Status:  Cancelable\nJob Status:  Cancel + Force\nJob Status:  Non-Swappable\nJob Status:  Memtermable\n----------------------------\nJob  ID :  JES2\nProc ID :  JES2\nASID    :  0020\nCurrent  CHSTS Flags:  00\nCurrent  CHACT Flags:  00\nJob Status:  Non-Cancelable\nJob Status:  Cancel + Force\nJob Status:  Non-Swappable\nJob Status:  Memtermable\n----------------------------\nReturn code is 0\n\n\n\nFigure 2.   CNCLPG JES2 ASID(20) DISP\n\n            Here we use both the jobname and the ASID(hhhh) keyword\n            in the DISP(lay), to make sure that we have only one\n            unique CSCB entry here.  This is because we next want to\n            issue a command to change this (unique) combination of\n            jobname and ASID to make it cancelable.  We do not want\n            to make a mistake and change a different address space.\n\n\nCNCLPG 1.2.10F - Alter Characteristics of a Running Address Space\n------ ------- - ----- --------------- -- - ------- ------- -----\nSearch Jobname:  JES2\n----------------------------\nASID parm entered  :   20\nSearch ASID   :      0020\n----------------------------\nAction code   :  CSCB  (DISPlay)\nThis is a run of the CSCB Chain only ...\n----------------------------\nJob  ID :  JES2\nProc ID :  JES2\nASID    :  0020\nCurrent  CHSTS Flags:  00\nCurrent  CHACT Flags:  00\nJob Status:  Non-Cancelable\nJob Status:  Cancel + Force\nJob Status:  Non-Swappable\nJob Status:  Memtermable\n----------------------------\nReturn code is 0\n\n\n\nFigure 3.   CNCLPG JES2 ASID(20) CNCL\n\n            Command to make the JES2 address space (and ONLY the\n            JES2 address space) \"cancelable\".  After doing this,\n            you can CANCEL JES2 \"more cleanly\".  (You still have\n            to enter \"END\" to the JES2 termination request.)\n\n\nCNCLPG 1.2.10F - Alter Characteristics of a Running Address Space\n------ ------- - ----- --------------- -- - ------- ------- -----\nSearch Jobname:  JES2\n----------------------------\nASID parm entered  :   20\nSearch ASID   :      0020\n----------------------------\nJob  ID :  JES2\nProc ID :  JES2\nASID    :  0020\nPrevious CHACT Flags:  00\nJob Status:  Non-Cancelable\nJob Status:  Cancel + Force\nJob Status:  Non-Swappable\nJob Status:  Memtermable\n----------------------------\nJob  ID :  JES2\nProc ID :  JES2\nASID    :  0020\nModified CHACT Flags:  08\n----------------------------\nAction code   :  CNCL\nCancel Indicator Flag :  08\nCurrent  CHSTS Flags:  00\nCurrent  CHACT Flags:  08\nJob Status:  Cancelable\nJob Status:  Cancel + Force\nJob Status:  Non-Swappable\nJob Status:  Memtermable\nReturn code is 0\n\n\nFigure 4.   Full syntax of the CNCLPG TSO command\n\n\nSyntax:     TSO Command:  APF-authorized.\n\n CNCLPG |jobid \u00ddASID(hhhh)\u00a8 |CNCL|NCNC (cancelable, non-canc)\n        |ASID(hhhh)         |FORC    (force w/o cancel first)\n        |                   |NFRC    (force needs cancel first)\n        |                   |NSWP|SWAP (non-swap, swappable)\n        |                   |TSWP (transwap)\n        |                   |FSWP (force swappable immediately)\n        |                   |CSCB or DISP (display CSCB blks)\n        |                   |BURN (memterm the address space)\n        |                   |KILL (memterm after turning off\n        |                   |      the non-memtermable bits)\n        |                   |NMEM|MEMT  (turn on/off\n        |                   |        non-memtermable bits)\n        |                   |COUNT  (display DONTSWAP count)\n        |-  (displays the entire CSCB chain)\n        |?  (displays help)\n\n\nFigure 5.   CNCLPG internal HELP prompt, issued when you enter\n            an invalid function code, like \"?\".\n\n\nCNCLPG 1.2.10F - Alter Characteristics of a Running Address Space\n------ ------- - ----- --------------- -- - ------- ------- -----\n  * -----  ALWAYS DO A DISPLAY FIRST  ----- *\nSyntax:  CNCLPG jobname ASID(hhhh) FUNCtion\n   Function is:  CNCL, NCNC, FORC, NFRC, NSWP,\n   SWAP, MEMT, NMEM, TSWP, or COUNT.\n FSWP, BURN, or KILL are dangerous.\n   TSWP will do a TRANSWAP.\nOr code CSCB or DISP to just display CSCB entries.\n   DISPlay or CSCB will display CSCB chain entries,\n   without changing them.\n-----------------------------------------------\n When affecting a job, we must affect the CORRECT job,\n  therefore you should use the DISPlay option first.\n-----------------------------------------------\n To display the whole CSCB, code - (dash) for JOBNAME.\n To see this help message, code ? for JOBNAME.\n-----------------------------------------------\n** NOTES (IMPORTANT) :  ** BE SURE TO READ THIS **\n-----------------------------------------------\n CSCB (DISP) display for an ASID shows ALL occurrences\n  for that ASID, regardless of JOBNAME.\n CSCB (DISP) display for a JOBNAME shows ALL occurrences\n  for those JOBNAME characters, regardless of ASID.\n CNCL, NCNC, FORC, NFRC, NSWP, SWAP changes the FIRST\n  entry in the CSCB chain that matches, if multiple\n  entries exist. But DISP will display ALL applicable\n  matching entries in the CSCB chain, so you can see\n  which one you want to change specifically.\n When you code BOTH jobname AND asid, to CHANGE it,\n  then ONLY that specific job and asid gets changed.\n-----------------------------------------------\n  * -----  ALWAYS DO A DISPLAY FIRST  ----- *\nReturn code is 0\n\n\nFigure 6.   Description of the CHACT flags and CHSTS flags of\n            the CSCB, in its mapping macro, IEECHAIN.\n\n            Setting CHCL on, will MAKE the job cancelable, but\n            CHSWAP is just an \"indicator\" as to whether the job\n            is swappable.  To MAKE a job swappable or non-swappable,\n            you need to execute a SYSEVENT macro in the address\n            space that you want to affect.  This would usually\n            require scheduling an SRB in that address space, if\n            it is different from yours.  Of course you can make\n            your own TSO session non-swappable by running a\n            SYSEVENT macro in your own address space without\n            needing to schedule an SRB.  (You're already there, and\n            you don't need to go cross-memory.)\n\n\nCHSTS    DS    B -       STATUS FLAGS\nCHAP     EQU   X'80' -   ASSIGNMENT PENDING\nCHINFMT  EQU   X'40' -   CSCB IN PRE-INTERPRETATION (INPUT) FORMAT     *\n                                                               @ZMB0266\nCHSOUT   EQU   X'20' -   CANCEL ALL SYSOUT\nCHQSPC   EQU   X'10' -   INSUFFICIENT QSPACE CAUSING ABEND 422\nCHAD     EQU   X'08' -   ADD THIS CSCB TO CHAIN\nCHDL     EQU   X'04' -   DELETE THIS CSCB FROM CHAIN\nCHFC     EQU   X'02' -   FREE THIS CSCB'S CORE\nCHABTERM EQU   X'01' -   EXECUTE BRANCH ENTRY TO ABTERM\n*\nCHACT    DS    B -       FLAGS INDICATING ACTIVITY INVOLVED\nCHSWAP   EQU   X'80' -   SWAPPABLE JOB\nCHTERM   EQU   X'40' -   TERMINAL JOB\nCHDISC   EQU   X'20' -   CANCEL IMPLIES DISCONNECT\nCHDSI    EQU   X'10' -   ON MEANS NO DATA SET INTEGRITY (OS/VS1) MDC045\nCHCL     EQU   X'08' -   CANCELABLE JOB STEP\nCHCLD    EQU   X'04' -   CANCEL COMMUNICATION SWITCH\nCHAIFX   EQU   X'02' -   CANCELABLE (OS/VS1)\nCHPOSTSS EQU   X'02' -   POST EARLY ADDRESS SPACE    (MDC313)  @G38EP2L\nCHIFY    EQU   X'01' -   SYSTEM ASSIGNED PROCEDURE (OS/VS1)\nCHAFORCE EQU   X'01' -   CANCEL ISSUED FOR THIS CSCB (FORCE COMMAND    *\n                         CAN BE ACCEPTED) (OS/VS2)  (MDC301)   @G17FP9A\n\n\nFigure 7.   CNCLPG IBMUSER ASID(51) NSWP\n\n            We request that my TSO address space be made\n            non-swappable.  Please note from the COUNT field\n            \"Outstanding DONTSWAP requests\" that this address\n            space had been made non-swappable once before.\n            Therefore, to make it swappable again, we would\n            have to issue a SWAP function against it, twice,\n            or issue FSWP (careful..!!) to set the count to\n            1, and then to issue the SWAP.\n\n\nCNCLPG 1.2.10F - Alter Characteristics of a Running Address Space\n------ ------- - ----- --------------- -- - ------- ------- -----\nSearch Jobname:  IBMUSER\n----------------------------\nASID parm entered  :   51\nSearch ASID   :      0051\n----------------------------\nFunction NSWP was called for.\nJob  ID :  IBMUSER\nProc ID :  SPFPROCE\nASID    :  0051\nPrevious CHACT Flags:  48\nJob Status:  Cancelable\nJob Status:  Cancel + Force\nJob Status:  Non-Swappable\nJob Status:  Memtermable\n----------------------------\n  Outstanding DONTSWAP requests:   0002\nJob IBMUSER  for ASID 0051 already non-swappable.\nCurrent  CHSTS Flags:  00\nCurrent  CHACT Flags:  48\nJob Status:  Cancelable\nJob Status:  Cancel + Force\nJob Status:  Non-Swappable\nJob Status:  Memtermable\nReturn code is 0\n\n\nFigure 8.   CNCLPG IBMUSER ASID(51) COUNT\n\n\nCNCLPG 1.2.10F - Alter Characteristics of a Running Address Space\n------ ------- - ----- --------------- -- - ------- ------- -----\nSearch Jobname:  IBMUSER\n----------------------------\nASID parm entered  :   51\nSearch ASID   :      0051\n----------------------------\nFunction COUNT was called for.\nJob  ID :  IBMUSER\nProc ID :  SPFPROCE\nASID    :  0051\n  Outstanding DONTSWAP requests:   0002\n----------------------------\nFinal Job Status Report.\nCurrent  CHSTS Flags:  00\nCurrent  CHACT Flags:  48\nJob Status:  Cancelable\nJob Status:  Cancel + Force\nJob Status:  Non-Swappable\nJob Status:  Memtermable\nReturn code is 0\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BM2002FE": {"ttr": 2821, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x10\\x00\\x14\\x01 \\x01\\x7f\\x01 \\x05o\\x11!\\x01A\\x00\\x04\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.16", "flags": 0, "createdate": "2020-01-17T00:00:00", "modifydate": "2020-02-25T11:21:14", "lines": 321, "newlines": 4, "modlines": 0, "user": "SBGOLOB"}, "text": "   ONLCLIP - CHANGING THE VOLSER OF A DISK PACK WHILE IT IS ONLINE\n\n(c) Copyright 2020 by Sam Golob.  All rights reserved.\n\n      Today we are going to talk about changing the identity of a disk\npack.  The identity, or \"volume serial\", of a disk pack in a z/OS\nsystem, is located in Record 3 of Track 0 of the pack, 6 bytes long,\nafter 8 bytes from the beginning of the record.  The first 8 bytes\ncontain 'VOL1VOL1', and the nest 6 bytes contain the volume serial id.\nAfter that, for 4 bytes, is the CCHHR location of the VTOC for the\npack.  The normal way to establish, or change the identity of, a disk\npack, is to initialize it using IBM's program ICKDSF.  ICKDSF is a\nmulti-purpose utility, but for some of its purposes, including the\ninitialization of the disk pack, you have to take the disk pack\noffline first, before invoking ICKDSF.\n\n      There is a reason for this.  Merely changing the disk id on\nRecord 3 of Track 0, does not tell the z/OS operating system that the\ndisk id of this pack at this unit address has changed.  The system uses\nthe disk id that is in the UCB for the device, to figure out what the\nvolume serial of the device is.  In order to put the both disk id's in\nsync:  the id on the pack, and the id in the UCB, you have to vary the\npack offline, and then vary the pack online again.  So this will explain\nwhy IBM requires that in order to change a disk id, THEIR WAY, you have\nto take the pack offline first.  So when the pack comes online again,\nthe disk id on the pack, and the disk id in the UCB, will now always be\nin synchronization.  There will never be a mismatch, and IBM will not\nhave to worry.\n\n      However, sometimes it becomes necessary in our systems programming\nwork, to be able to change the disk id on Record 3 of Track 0 of a pack,\nwhile it is still online.  We'll talk about the circumstances when we\nmight need to do this.  If doing this becomes necessary, we need to have\nsome tools to get the job done.  I know of two tools.  I wrote one, and\nI have been using the other one for quite a few years.  Both of these\ntools do not come from IBM.\n\n      Why would one need to change the id of a pack, while it remains\nonline?  Sometimes, you simply can't get the pack offline, for instance,\nif there is some data on that pack that is constantly being used.  If\nsuch a pack goes bad, and you restore it from a good backup onto a\ndifferent unit at a different address, you now have both packs online\nwith the same volume id, although the restored pack has a different UCB\nvolser id now, since it is on a different disk device.\n\n      To set things right, you will need to IPL.  And after the IPL, you\nwill want the bad pack to be inactive.  How can you ensure that this\nwill happen correctly?  You can accomplish this by renaming the bad pack\nwhile it is still online, and after the IPL, the good pack will be the\nonly one functioning online with the correct volume id.\n\n\nTHE TOOLS\n\n     I have two tools which will help us to change the volume id of a\ndisk pack while it is online.  The first one (which I have been using\nfor many years) is the TSO command \"Fullscreen ZAP\", from CBT File 134\nor CBT File 300.  Fullscreen ZAP has been (very) recently modified to\naccept the UNIT keyword parameter when the VOLUME keyword parameter is\npresent.  This modification is very important for us, so it will be good\nif you upgrade your copy of Fullscreen ZAP to the latest version.\nPlease remember that recent updates to the CBT collection go first to\nthe Updates page of www.cbttape.org, and only later, when a full CBT\nVersion is cut, do these updates reach the CBT page of www.cbttape.org.\nAlways try the Updates page first, to get the latest software.\n\n     The second tool is a batch program, called ONLCLIP (or \"Online\nCLIP\").  Systems programmers refer to \"changing the volume id of a pack\"\nas \"clipping the pack\".  The reason for that, is that one of the first\nIBM tools for changing the id of a pack (I think it doesn't work\nanymore) was a standalone program (which you would have to IPL) called:\n\"Change Label Information Program\" or \"CLIP\" for short.  Our program is\na batch program, which changes only the volume serial of the pack, and\nnothing else.  ONLCLIP can be found on CBT File 846, and JCL to run it,\nis shown in Figure 1, below.  An output report from the ONLCLIP program\nis shown in Figure 2.  ONLCLIP reports on all relevant status, and\nit produces an audit trail, through WTO messages.\n\n     Of course, IBM's ICKDSF program is also always available, but we\nare trying to get around its limitations.\n\n\nUSING THE ONLCLIP BATCH PROGRAM\n\n     See Figure 1 again, to see JCL to run the ONLCLIP batch program.\nThe UCB volser, and the UCB unit address should be coded in the DISKUPD\nDD statement.  The new disk id desired, should be coded in the PARM\nfield, which will always be uppercased inside the ONLCLIP program.\n\n      Why must the UCB volser be coded in the JCL?  The reason is that\nthe system JCL can only read information from the UCB control block, and\nit does not read the volume serial id that is on Record 3 of Track 0.\n\n      What comes next?  Internally, the ONLCLIP program temporarily\nadjusts the data extent on the disk pack, in the DEB (Data Extent\nBlock), so that the program thinks that the dataset extents are only one\ntrack, Track 0.  Therefore, since the program has to temporarily adjust\nthe DEB, it has to run APF-authorized.  Before the program finishes, it\nsets the DEB back to what it was previously.\n\n      After having made sure that the extents that the program is\n\"looking for\", consist of only Track 0 of the pack, the program then\nproceeds to copy the entire contents of Track 0 to a buffer which has\nbeen GETMAINed by the program.  In that buffer, the program finds Record\n3, and changes ONLY the volser that was found there, inserting the\nvolser from the PARM field instead.  This is the only change that the\nprogram makes to Record 3.  Then the program \"rewrites in place\" the\nentire Record 3, because a \"rewrite in place\", CCW opcode X'85', does\nnot wipe out the IPL records (if they exist) on Track 0 that are after\nRecord 3.\n\n      In the process of doing all of this, the ONLCLIP program keeps\ntrack of everything important.  Its SYSPRINT report shows the time and\ndate of execution, the UCB unit address and UCB volser of the pack, the\n\"old\" Record 3 volume id, and the \"new\" Record 3 volume id.  The\nSYSPRINT output even advises you that no changes will occur in the UCB\nfor the unit, unless the pack is varied, first offline, and then online\nagain.  In addition, a WTO is issued with the same information, but\nwithout the date and time, because the date and time are included in the\nJES execution reports already.  Thus the ONLCLIP program produces an\naudit trail of what it did, and when it did it.\n\n\nSECURITY FOR ONLCLIP, AND CHECKING THE RESULTS\n\n      ONLCLIP requires RACF authorization in the following way.  We need\nto define a FACILITY class profile called TBCXTUL, and ONLCLIP needs to\nhave READ access to that profile.  (TBC is CBT backwards, X, TUL stands\nfor tools.)  If ONLCLIP does not have READ access to this profile, then\nthe program is aborted with an appropriate message.\n\n      ONLCLIP also needs APF-authorization.  That is, it needs to be\nlinkedited with SETCODE AC(1), and it needs to be run from an\nAPF-authorized library.  Since it is really a system programmer tool,\nand it is not run often, I figured that while it is run under system\nprogrammer supervision, the system programmer would either:  1-  Know\nhow to be careful with it.  2- Keep it away from other people and\noperators, except under controlled conditions.  And 3- If the systems\nprogrammers would set up a procedure for the operators to use it on a\none-time basis, there is enough of an audit trail to determine that the\njob was done successfully and correctly.\n\n      After the ONLCLIP job is run, the systems programmer can\nphysically check on the results using several methods.\n\n      The first method is to print out the entire Track 0 of each pack,\nusing the JCL in Figure 4, which runs the ADRDSSU program, pointing to\nthe UCB unit address, as well as to the UCB volser.  It is not generally\nknown (but it is in the book) that you can specify the unit address, as\nwell as the volser, in the INDYNAM statement under ADRDSSU.\n\n      The second method is to use Fullscreen ZAP with the FULLVOL\noperand, as a checking tool to verify how ONLCLIP worked, even though\nyou can (now) do the entire job (of both zapping and checking) using\nFullscreesn ZAP as well.  We have very recently (Feb 2020) modified\nFullscreen Zap (CBT Files 134 or 300) so that it can take a UNIT( )\nparameter as well as a VOL( ) parameter.  So if there are two packs\nonline with the same volser (which can happen when you restore a pack\nfrom a backup), you can specify the unit address as well, to Fullscreen\nZAP, and it can direct the search to the pack you want to look at, or\nchange.  Without the modification to recognize the UNIT parameter,\nFullscreen ZAP was restricted to accessing only the volume whose unit\naddress came earlier in the UCB lookup table (usually the pack with the\nunit address lower in the EBCDIC collating sequence.\n\n      I have found that if you are running z/OS under VM, and the pack\nyou are looking at is \"read only\" under VM, then ONLCLIP, or Fullscreen\nZAP, will not be able to change the volume id.  Besides being obvious,\nthis is probably what you would want anyway.  If the VM systems people\nwould be willing to allow write access to the pack in question, then you\ncan do what you want.  But that security is there, if you're running\nunder VM.  By experimentation, I have seen that it works as I haave\ndescribed.\n\n\nUSING FULLSCREEN ZAP TO CHECK OR CHANGE THE VOLUME ID\n\n      The TSO Fullscreen ZAP program can both look at, and change,\nstorage.  With its FULLVOL operand, that has to be run APF-authorized,\nthe DEB of the volume is \"fooled\" to \"think\" that the extents of the\ndataset being zapped or looked at, IS THE ENTIRE VOLUME.  So therefore,\nwhen you invoke ZAP in FULLVOL mode, the first thing you get to see is\nthe Track 0 data for the pack.\n\n      The command is:  TSO ZAP 'FORMAT4.DSCB' VOL(volser) UNIT(/uuuu)\nfor 4-character units.\n\nOr for 3-character units:\n\n      TSO ZAP 'FORMAT4.DSCB' VOL(volser) UNIT(uuu)\n\n      (The UNIT parameter will only work if you have the latest version\nof Fullscreen ZAP, now available on the Updates page of www.cbttape.org)\n\n      The first record you'll see is Record 1 of Track 0.  You then\nenter the R command (to get to the next record) twice, to get to see\nRecord 3.\n\n      Now you have a choice, since ZAP can change the record as well:\n\n      Either you have first used the ONLCLIP program to change the\nvolume id, so that you'll have an audit trail, and you're just using\nZAP to check on the results, or you can use ZAP to do the whole job,\nusing its \"S\" subcommand to change the volser in Record 3, after having\npositioned ZAP to point to the correct location.\n\n      If you're just checking on the results, just do a \"Print Screen\"\nand get out, but if you're doing the whole job, ZAP can offer something\nof an audit trail, as well, if you save its log.  The choice is yours.\n\n      So we'll say good-bye for now, and we hope to see you in this\nspace, the next time.\n\n\n                       ILLUSTRATIONS\n\n\nFigure 1.   JCL to run the ONLCLIP batch program.  The new volume id\n            is fed into the program in the PARM field, and the input\n            data is uppercased.  The current UCB volume id has to be\n            entered in the VOL=SER= parameter of the DISKUPD DD name.\n\n\n//IBMUSERS JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//* Purpose of this program is to change the VOLSER of a volume,\n//*  while it is online.  The PARM field contains the new volume id.\n//*\n//* If two disks are online with identical UCB volsers and identical\n//*  volume labels, then specify the specific unit address in the JCL,\n//*  as per the DISKUPD DD name below.\n//*\n//TRK0SAV1 EXEC PGM=ONLCLIP,PARM='VTMVSH'       <= New Volume ID\n//STEPLIB  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSPRINT DD  SYSOUT=*\n//SYSUDUMP DD  SYSOUT=*\n//DISKUPD  DD  UNIT=1005,SPACE=(TRK,1),VOL=SER=VTMVSG <= Device Address\n//\n\n\nFigure 2.   Output of the ONLCLIP batch program.\n\n\nSYSPRINT DD name messages produced by ONLCLIP....\n\n  ONLCLIP - Version 1.5 - 02/18/23\n  ------- - ------- --- - --------\n           \"ONLINE CLIP\"\n\n     Time and Date of Execution:\n Date:   02/20/2020     Time:   11:06:19\n\n UCB Unit:   1005    UCB Volser:  VTMVSG\n\n Old VOLSER was:  VTMVSG\n New VOLSER is :  VTMVSH\n\n To make the change permanent, you have\n  to VARY the pack OFFLINE and then\n  VARY the pack ONLINE again.\n\n\nWTO messages produced by ONLCLIP....\n\nONLC000 Original (UCB) volume serial is: VTMVSG.\nONLC001 Volume Serial for Unit: 1005 changed from VTMVSG to VTMVSH.\n\n\n\nFigure 3.   Sample view of Track 0, Record 3, after the change.\n            Note that the DSN: VOLUME is still the original\n            volume serial, as reflected in the UCB.\n\n\n                                 Z  A  P\n\nENTER VALID COMMAND ABOVE OR ? FOR HELP         VERSION=3.3Z 19FEB20\n\n\n00000  >E5D6 D3F1  E5D6 D3F1   E5E3 D4E5  E2C8 4000   |VOL1VOL1VTMVSH .|\n00010   0000 0101  0000 0004   0000 001E  0000 001E   |................|\n00020   0000 1518  0000 0006   0000 0040  0000 0040   |........... ... |\n00030   9704 0110  4704 0000   0000 0000  0000 0001   |p...............|\n00040   0000 000B  0000 000B   0000 0000  0000 0000   |................|\n00050   0000 0000                                     |....            |\n\n\n\n\n\n\n\n\nOFF: 0000 (     0) ADDR: 00000 (       0) DSN:   VOLUME VTMVSG\nLEN: 0054 (    84) BASE: 00000 (       0) CCHHR: 0000000003 TTR:  000003\n\n\n\nFigure 4.   Sample JCL to look at Track 0 on several disk packs,\n            each having the same UCB volser (TEST02), but having\n            different unit addresses (A42 and A43).\n\n\n//   JOBCARD\n//DUMP01   EXEC PGM=ADRDSSU,REGION=4096K\n//SYSPRINT DD   SYSOUT=*\n//OUTPUT   DD   SYSOUT=*\n//SYSIN     DD *\n  PRINT TRACKS(0,0,0,0) -\n     INDYNAM(TEST02,A42) -\n     ADMIN -\n     OUTDDNAME(OUTPUT)\n  PRINT TRACKS(0,0,0,0) -\n     INDYNAM(TEST02,A43) -\n     ADMIN -\n     OUTDDNAME(OUTPUT)\n/*\n//\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BM2003MA": {"ttr": 2827, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00I\\x01 \\x06?\\x01 \\x06O\\x15&\\x01\\xd0\\x00\\x04\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2020-03-03T00:00:00", "modifydate": "2020-03-04T15:26:49", "lines": 464, "newlines": 4, "modlines": 0, "user": "SBGOLOB"}, "text": "           USING Z/OS SYSTEM SERVICES MACROS, OR NOT\n\n(c) Copyright 2020 by Sam Golob.  All rights reserved.\n\n      Today we'll talk about a situation which occurs frequently in\nsystem Assembler coding work, but which is seldom talked about\nexplicitly.  IBM helps the programmer in many instances by supplying\nwhat is termed \"system services\".  System services make Assembler\nprogramming much easier, but they also serve other purposes.  They also\nhide the truth of where necessary pieces of information occur in the\nsystem.  How does a system services macro work?  I'll show you the way\nIBM \"talks\":\n\n      You want to know how to find some information?  Then execute this\nmacro, and we'll hand the information to you.  The macro will dig the\ninformation out and hand it to you on a silver platter.  But what does\nthe macro itself do?  Why do we need a macro?  Can't we just nose into\nthe system and get the same information for ourselves?\n\n      The answer is, \"not always\".\n\n      There are several reasons why system macros are provided by IBM,\nand that's what we're going to talk about now.  But I'll summarize a few\nof them, so you see where we're going.\n\n1.  It's much easier to code a system service macro, and have the\n    information served up to you \"on a silver platter\".\n\n2.  IBM wants to hide where in the system, that the information\n    really is located.\n\n3.  A \"normal user\" wants to access some information, that IBM knows\n    is located in a protected control block, and which you need\n    APF-authorization to access.  So IBM gives you a \"service\" so\n    you can get it.\n\n4.  A \"normal user\" wants to do a normal service.  However the service\n    requires APF-authorization internally, and IBM wants to give the\n    capability to ordinary users:  Example:  The TSO SEND command.\n\n5.  IBM is worried about something that ordinary users don't usually\n    care about.  For example, if you try and run a UCBSCAN to find\n    out about DASD devices, and someone is in the middle of running\n    a dynamic I/O reconfiguration.  IBM has to worry about that, but\n    we usually don't care.  A dynamic I/O reconfiguration is a very\n    rare occurrence, and you are usually informed when one is being\n    run.\n\n6.  There's always the downward compatibility issue.  IBM doesn't\n    want you to have to change your programs, every time they make\n    a change in the operating system.  So they adjust the system\n    service to the change, upward or downward.\n\n\nA SYSTEM SERVICES MACRO EXAMPLE\n\n      IBM provides many assembler macros in SYS1.MACLIB and SYS1.MODGEN\nwhich \"perform services\".  For example, the GTSIZE macro tells you how\nbig your terminal is.  When you issue a GTSIZE macro in an assembler\nprogram, Register 0 returns the number of rows in the terminal, and\nRegister 1 returns the number of columns.  To display these values, you\njust have to convert them to decimal, and EDit them into a report.  The\nprogram is very simple.  See Figure 1 for the entire program code.\n\n      But the catch is this.  The information about the number of rows\nand the number of columns that your terminal has, is kept in a protected\ncontrol block, the TSB (Terminal Status Block) which occupies Fetch\nProtected storage (subpool 231).  This storage can only be viewed by an\nAPF-authorized program.  The reason for that, is not the column size or\nthe row size, but because of other information which is stored in the\nTSB control block, and security is required for that other information.\nYou don't want one user nosing into private information about another\nuser's terminal.\n\n      So what did IBM do?  They provided a service, which gets the\nrequired authorization via an SVC, and which pulls out this\n\"non-classified\" part of the \"classified\" TSB, for us to see.  The\n\"user-type\" people can access the information without being authorized\n(because the SVC does the real work), and even though they don't tell\nyou WHERE in the system the information was kept, they DO get you what\nyou need.  To see the content of the GTSIZE macro code, see Figure 2.\nIts generated code is very simple.  It just loads in the required\nparameters and executes the SVC.\n\n      I decided to dig out that exact information directly from the TSB\ncontrol block itself.  The code for that, is in Figure 3.  Of course, my\nprogram has to be APF-authorized, but it produces the same result as\nthe code in Figure 1.  See Figures 4 for the outputs of both programs.\nThe two outputs are identical, except for the titles, where I wanted to\npoint out where the information came from.\n\n\nANOTHER EXAMPLE OF SYSTEM SERVICES MACROS\n\n      I wrote some code to handle \"SYS1.BRODCAST full\" conditions, and\nto do other functions concerning the SYS1.BRDDCAST dataset.  The\nSYS1.BRODCAST dataset, or (since z/OS 1.3) the \"Active Broadcast\nDataset\" holds \"job completion messages\" and other user messages to\ndisplay to TSO users.  My \"free\" code which I wrote for this, is on CBT\nFile 247.\n\n      Among the programs I wrote for File 247, are two programs called\nBCMUSADD and BCMUSDEL.  I also wrote two other programs for a\n\"commercial product\" (\"owned\" by me), that perform the same function.\nThese are called BDMUSADD and BDMUSDEL.  Their purpose is to ADD, or\nDELETE, userid record slots from the SYS1.BRODCAST dataset.  In other\nwords, BCMUSADD or BDMUSADD can add a userid so SYS1.BRODCAST can keep\ntrack of its messages.  And BCMUSDEL or BDMUSDEL can delete any userid\nrecord slot from the SYS1.BRODCAST dataset, and get rid of all the user\nmessages attached to that userid.  Usually these functions are performed\nby the IBM SYNC command, which you issue as a subcommand of the IBM\nACCOUNT command.  But if you want to add an extra userid, or delete one,\nyou can use these programs that I wrote.  The IBM SYNC command has the\ndisadvantage that it deletes ALL user messages from SYS1.BRODCAST, while\nin the process of initializing all of the userid slots, to synchronize\nthem either with UADS or RACF or both.\n\n      What is the difference between the \"BCM\" and \"BDM\" programs?  The\n\"free\" programs BCMUSADD and BCMUSDEL use an IBM system service macro\ncalled IKJIFRIF to perform their functions.  The BDMUSADD and BDMUSDEL\nperform these functions directly, using direct I/O to the Broadcast\nDataset, without the intervention of the IBM system service macro.\n\n      Why change?  Answer is, that IBM makes assumptions, which aren't\nnecessarily true in a user environment.  IBM assumes that you only want\nto change the userid configuration in the \"active Broadcast Dataset\".\nIn my package, I make backup copies of the Broadcast Dataset, (which IBM\nassumes that you won't normally do), and I assume that I may want to\nmanipulate the userids in the backup copy, rather than in the active\ndataset.  That's why I \"do it directly\", with I/O to the Broadcast\nDataset, and I don't use the system service macro from IBM.\n\n      For the purpose of this article, I've copied my BDMUSADD and\nBDMUSDEL programs to CBT File 247, so you can see the differences in\nthe coding.  Also, see Figure 5 to compare the outputs of these two\nprograms.\n\n      In this case, doing direct I/O to the Broadcast Dataset has\nallowed me to manipulate any formatted Broadcast Dataset, new or old,\noriginal or backup copy.  IBM's system service macro IKJIFRIF does not\nallow me to do this.  IKJIFRIF can only manipulate the active Broadcast\nDataset, and cannot reach a copy of it.\n\n\nOTHER USE OF IBM SYSTEM SERVICE MACROS\n\n      If you look into the code of the SHOWzOS program from CBT File\n492, you'll probably see one of the most extensive uses of IBM system\nservices macros available anywhere in the public domain.  SHOWzOS\ndisplays a tremendous number of \"system quantities\" and \"system\nstatus indicators\".  SHOWzOS is a colossal program, originally written\nby the late Gilbert Saint-flour, and currently maintained by Roland\nSchiradin.  SHOWzOS gets its results, almost entirely, from IBM system\nservices macros.  It is one of the wonders of the \"public domain code\"\nworld.  Have a peek.\n\n      I have written my own code to display \"small bits and pieces\" of\nthis stuff directly.  My code works, but SHOWzOS does a monumental job\nusing (if you really look into it) a minimum of coding.  Just about\nall of its work is done through IBM system services macros.  They\nshorten things, a lot.\n\n      So you see that IBM system services macros are useful, most of\nthe time.  If you want to get into the nitty-gritty though, you have\ndig deeper, and do it yourself.\n\n      I hope this has been an instructive session, and I'm looking\nforward to seeing you here next time.\n\n\n\n                       ILLUSTRATIONS\n\n\nFigure 1.   This is the complete code of the TERMSIZE program\n            which displays the size of your TSO terminal.  The\n            TERMSIZE program takes advantage of the IBM GTSIZE\n            system service macro, which uses an SVC to obtain\n            the correct quantities.  See Figure 2 for the very\n            simple GTSIZE code (the SVC does all the work).\n\n\nSP000    EQU   0\n*\nTERMSIZE CSECT\nTERMSIZE AMODE 31\nTERMSIZE RMODE 24\n         YREGS                      NOW IBM HAS DONE IT\n         STM   R14,R12,12(R13)      SAVE REGISTERS\n         USING TERMSIZE,R12\n         LR    R12,R15              BASE REGISTER\n         L     R0,WORKDL\n         GETMAIN RU,LV=WORKDL,SP=SP000,LOC=BELOW\n         LR    R9,R1\n         USING WORKD,R9\n         ST    R9,GOTADDR\n         LA    R2,SAVE              NEW SAVE AREA\n         ST    R2,8(,R13)           PUT IT AWAY\n         ST    R13,SAVE+4           OLD SAVE AREA\n         LR    R13,R2               POINT R13 TO NEW SAVE AREA\n*                          GET TERMINAL SIZE\n         GTSIZE\n*\n         ST    R0,ROWS                 STORE NUMBER OF ROWS\n         ST    R1,COLS                 STORE NUMBER OF COLUMNS\n         LR    R6,R0                   GET NUMBER OF ROWS\n         CVD   R6,DWORK                CONVERT TO PACKED\n         MVC   MESROWS,LITROWS         MOVE LITERAL PART\n         MVC   MESCOLS,LITCOLS           OF MESSAGES\n         MVC   NUMROWS,MASK7A          EDIT MASK\n         ED    NUMROWS,DWORK+5         DISPLAY NUMBER IN MESSAGE\n         MVI   NUMROWS+6,C' '\n         MVC   MESROWS+18(7),NUMROWS\n         LR    R6,R1                   GET NUMBER OF COLUMNS\n         CVD   R6,DWORK                CONVERT TO PACKED\n         MVC   NUMCOLS,MASK7A          EDIT MASK\n         ED    NUMCOLS,DWORK+5         DISPLAY NUMBER IN MESSAGE\n         MVI   NUMCOLS+6,C' '\n         MVC   MESCOLS+18(7),NUMCOLS\n         TPUT  TITLEA,L'TITLEA         PUT OUT THE ENTIRE DISPLAY\n         TPUT  TITLEU,L'TITLEU\n         TPUT  MESROWS,L'MESROWS\n         TPUT  MESCOLS,L'MESCOLS\n*\n         L     R13,SAVE+4           LOAD OLD SAVE AREA\n         L     R9,GOTADDR           POINT TO ADDRESS TO FREEMAIN\n         FREEMAIN RU,LV=WORKDL,A=(R9),SP=SP000\n         DROP  R9\n         LM    R14,R12,12(R13)      PUT REGISTERS BACK\n         BR    R14                  RETURN TO CALLER\n*\nTITLEA   DC    C'* GTSIZE-BASED TERMINAL DISPLAY *'\nTITLEU   DC    C'  ------------ -------- -------  '\nMASK7A   DC    XL7'40202020212020'\nLITROWS  DC    C'THIS TERMINAL HAS         ROWS'\nLITCOLS  DC    C'THIS TERMINAL HAS         COLUMNS'\n         LTORG\n*\nWORKD    DSECT\n         DS    0D\nSAVE     DS    18F                  SAVE AREA\nGOTADDR  DS    F\nROWS     DS    F\nCOLS     DS    F\nNUMROWS  DS    CL7\nNUMCOLS  DS    CL7\nMESROWS  DC    C'THIS TERMINAL HAS         ROWS'\nMESCOLS  DC    C'THIS TERMINAL HAS         COLUMNS'\nDWORK    DS    D\nWORKDL   EQU   *-WORKD\n         END\n\n\n\nFigure 2.   The GTSIZE macro code.  After getting rid of the\n            conditional assembly, etc., here is what remains.\n            All the work is done inside the SVC, which also\n            obtains the APF-authorization necessary to extract\n            the information from the protected TSB control\n            block.\n\n\n         SR    R1,R1                    PREPARE PARM\n         LA    R0,11                    LOAD ENTRY CODE\n         SLL   R0,24                    PUT ENTRY CODE IN LEFT MOST\n         SVC   94                       ISSUE SVC\n\n\n\nFigure 3.   The Assembler code for the TERMSZ program, which\n            does not use the GTSIZE system service but which\n            obtains all the same information \"by hand\", directly\n            from the place in the system where it resides.\n            The TERMSZ program needs to be APF-authorized, because\n            the required information is in fetch protected storage.\n            See the inside of the code for details.\n\n\nTERMSZ   CSECT\nTERMSZ   AMODE 31\nTERMSZ   RMODE 24\n         YREGS                      NOW IBM HAS DONE IT\n         STM   R14,R12,12(R13)      SAVE REGISTERS\n         USING TERMSZ,R12\n         LR    R12,R15              BASE REGISTER\n         L     R0,WORKDL\n         GETMAIN RU,LV=WORKDL,SP=SP000,LOC=BELOW\n         LR    R9,R1\n         USING WORKD,R9\n         ST    R9,GOTADDR\n         LA    R2,SAVE              NEW SAVE AREA\n         ST    R2,8(,R13)           PUT IT AWAY\n         ST    R13,SAVE+4           OLD SAVE AREA\n         LR    R13,R2               POINT R13 TO NEW SAVE AREA\n* ------------------------------------------------------------------- *\n*                          GET TERMINAL SIZE\n*        GTSIZE\n*                        SEE EXPLANATION BELOW\n* ------------------------------------------------------------------- *\n*        PERFORM THE FUNCTION OF THE GTSIZE MACRO, BUT GET THE        *\n*        INFORMATION DIRECTLY FROM THE TSB.  UNFORTUNATELY, THE       *\n*        TSB IS IN PROTECTED STORAGE, KEY 6, SP 231. AND WE HAVE      *\n*        TO BE APF-AUTHORIZED AND GET INTO KEY 0 TO ACCESS IT.        *\n* ------------------------------------------------------------------- *\n*        SINCE THE GTSIZE MACRO CALLS AN SVC (94), IT CAN GET         *\n*        INTO SUPERVISOR STATE AND DO THE STORAGE FETCH, RETURNING    *\n*        TO PROBLEM STATE.  SO THE \"GTSIZE\" VERSION OF THIS PROGRAM   *\n*        DOES NOT HAVE TO BE APF-AUTHORIZED, WHILE THIS PROGRAM HAS   *\n*        TO BE APF-AUTHORIZED.                                        *\n* ------------------------------------------------------------------- *\n*        TO CONVERT THIS PROGRAM TO THE NON-AUTHORIZED FORM, JUST     *\n*        UNCOMMENT THE GTSIZE MACRO, AND COMMENT OUT ALL THE LINES    *\n*        BELOW, IN-BETWEEN THE ARROW COMMENTS (BELOW AND ABOVE).      *\n* ------------------------------------------------------------------- *\n*                PERFORM THE GTSIZE MACRO FUNCTIONALITY               *\n* ------------------------------------------------------------------- *\n* ----------------------------------- >>>>>   BELOW   <<<<< --------- *\n         TESTAUTH FCTN=1           Are we authorized?\n         LTR   R15,R15             Test the return code.\n         BNZ   NOTAUTH             Not zero, tell not authorized.\n         L     R5,X'224'               POINT TO ASCB\n         L     R5,X'3C'(,R5)           POINT TO TSB\n         XR    R0,R0                   CLEAR R0 AND R1 AS\n         XR    R1,R1                     WORK REGISTERS\n         STM   R0,R1,SAVER01           PRESERVE R0 AND R1\n         MODESET KEY=ZERO\n         LM    R0,R1,SAVER01           RESTORE  R0 AND R1\n         IC    R0,X'66'(,R5)           RETRIEVE NUMBER OF ROWS\n         IC    R1,X'67'(,R5)           RETRIEVE NUMBER OF COLUMNS\n         STM   R0,R1,SAVER01           PRESERVE R0 AND R1\n         MODESET KEY=NZERO\n         LM    R0,R1,SAVER01           RESTORE  R0 AND R1\n* ----------------------------------- >>>>>   ABOVE   <<<<< --------- *\n         ST    R0,ROWS                 STORE NUMBER OF ROWS\n         ST    R1,COLS                 STORE NUMBER OF COLUMNS\n         LR    R6,R0                   GET NUMBER OF ROWS\n         CVD   R6,DWORK                CONVERT TO PACKED\n         MVC   MESROWS,LITROWS         MOVE LITERAL PART\n         MVC   MESCOLS,LITCOLS           OF MESSAGES\n         MVC   NUMROWS,MASK7A          EDIT MASK\n         ED    NUMROWS,DWORK+5         DISPLAY NUMBER IN MESSAGE\n         MVI   NUMROWS+6,C' '\n         MVC   MESROWS+18(7),NUMROWS\n         LR    R6,R1                   GET NUMBER OF COLUMNS\n         CVD   R6,DWORK                CONVERT TO PACKED\n         MVC   NUMCOLS,MASK7A          EDIT MASK\n         ED    NUMCOLS,DWORK+5         DISPLAY NUMBER IN MESSAGE\n         MVI   NUMCOLS+6,C' '\n         MVC   MESCOLS+18(7),NUMCOLS\n         TPUT  TITLEA,L'TITLEA         PUT OUT THE ENTIRE DISPLAY\n         TPUT  TITLEU,L'TITLEU\n         TPUT  MESROWS,L'MESROWS\n         TPUT  MESCOLS,L'MESCOLS\n*\nRETURN   DS    0H\n         L     R13,SAVE+4           LOAD OLD SAVE AREA\n         L     R9,GOTADDR           POINT TO ADDRESS TO FREEMAIN\n         FREEMAIN RU,LV=WORKDL,A=(R9),SP=SP000\n         DROP  R9\n         LM    R14,R12,12(R13)      PUT REGISTERS BACK\n         BR    R14                  RETURN TO CALLER\n*\nNOTAUTH  DS    0H\n         TPUT  AUTHMSG,L'AUTHMSG\n         B     RETURN\nTITLEA   DC    C'* TERMINAL SIZE DIRECTLY FROM TSB *'\nTITLEU   DC    C'  -------- ---- -------- ---- ---  '\n*TITLEA  DC    C'* GTSIZE-BASED TERMINAL DISPLAY *'\n*TITLEU  DC    C'  ------------ -------- -------  '\nMASK7A   DC    XL7'40202020212020'\nLITROWS  DC    C'THIS TERMINAL HAS         ROWS'\nLITCOLS  DC    C'THIS TERMINAL HAS         COLUMNS'\nAUTHMSG  DC    C'THIS COMMAND MUST BE APF-AUTHORIZED.'\n         LTORG\n*\nWORKD    DSECT\n         DS    0D\nSAVE     DS    18F                  SAVE AREA\nSAVER01  DS    2F\nGOTADDR  DS    F\nROWS     DS    F\nCOLS     DS    F\nNUMROWS  DS    CL7\nNUMCOLS  DS    CL7\nMESROWS  DC    C'THIS TERMINAL HAS         ROWS'\nMESCOLS  DC    C'THIS TERMINAL HAS         COLUMNS'\nDWORK    DS    D\nWORKDL   EQU   *-WORKD\n         END\n\n\n\nFigure 4.   Here we display the outputs of (first) the GTSIZE\n            based program TERMSIZE, which uses the system service\n            macro GTSIZE.\n\n\n       * GTSIZE-BASED TERMINAL DISPLAY *\n         ------------ -------- -------\n       THIS TERMINAL HAS     43  ROWS\n       THIS TERMINAL HAS    132  COLUMNS\n\n\n            And here we display the output of the TERMSZ program\n            which obtains the information directly from the TSB\n            control block.  You see that the outputs are identical,\n            except that the titles are different, so you can tell\n            the outputs apart from each other.\n\n\n       * TERMINAL SIZE DIRECTLY FROM TSB *\n         -------- ---- -------- ---- ---\n       THIS TERMINAL HAS     43  ROWS\n       THIS TERMINAL HAS    132  COLUMNS\n\n\n\nFigure 5.   Outputs of the BCMUSADD and BCMUSDEL programs, which\n            use the IBM service macro IKJIFRIF to do the work of\n            adding or deleting userid slots in SYS1.BRODCAST.\n            By comparing to the later display, you see that IBM\n            does not report the location of the userid record in\n            the Broadcast Dataset.  You don't know what is really\n            going on--just if the record was \"added\" or \"deleted\".\n\n            The executed commands were:  BCMUSADD XXXX\n\nBCMUSADD - VER. 1.5 - 01/15/06 - 14.45\nUSERID XXXX    ADDED TO BRODCAST DATASET\n\n            And BCMUSDEL XXXX  , executed after BCMUSADD.\n\nBCMUSDEL - VER. 1.5 - 01/15/06 - 14.45\nUSERID XXXX    AND ITS MESSAGES DELETED FROM BRODCAST DATASET\n\n\n            Next, we display the output of commands,\n            BDMUSADD and BDMUSDEL, which do direct I/O\n            to the dataset allocated with DD name of\n            BRODCAST.  This can be ANY dataset that is\n            formatted like a SYS1.BRODCAST dataset.\n            With the direct I/O coding, we are not\n            restricted to doing this against IBM's\n            \"Active\" Broadcast Dataset in the system.\n\n\nBDMUSADD PROGRAM  -  Broadcast Master  Version   1.4.0A\nCopyright (c) 1995-2009 Sam Golob Systems Programming LLC - All Rights Reserved\n\n       USERID XXXX    WAS ADDED IN RECORD 00006B  SLOT 06\n\n\nBDMUSDEL PROGRAM  -  Broadcast Master  Version   1.4.0B\nCopyright (c) 1995-2016 Sam Golob Systems Programming LLC - All Rights Reserved\n\n\n  -->  MESSAGES DELETED FOR THE FORMER USERID XXXX   .\n\n       USER XXXX    HAD       0   DEFERRED TSO MESSAGES\n       * - - - - END OF MESSAGES FOR THIS USER - - - - *\n\n  -->  USERID XXXX    HAS BEEN DELETED FROM THE BROADCAST DATASET.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL8901JA": {"ttr": 3080, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93!\\x0f\\x00\\x93!\\x0f\\x12\\x01\\x00\\xb6\\x00\\xb6\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "1993-07-29T12:01:00", "lines": 182, "newlines": 182, "modlines": 0, "user": "SBGCSC"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          January 1989\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n\n\n      This new column will appear monthly in \"Technical Support\".\nWe are confident that most of our readers will increase their power,\nand the ability to do their jobs, through the practical tools and\ntips mentioned here.\n\n      This forum will concentrate on tools available to all readers.\nThe public domain literature for IBM mainframe operating systems is\nimmensely large.  Occasionally a reference may be made to a vendor\nproduct that will do the same job as one of these tools.  However, I\nfeel very strongly that EVERY MVS PERSON CAN GREATLY EXPAND THE RANGE\nAND SCOPE OF HIS WORK.  ONE DEFINITELY DOES NOT HAVE TO BE LIMITED\nby the amount of money his company is willing to spend.\n\n      Readers are encouraged to contribute techniques and advice to\nthis column by writing to me care of the Editor.  The contributor's\nname will be mentioned if his item is printed.\n\n      Let me begin by mentioning some of the common PUBLIC TAPES\nwhich are available for what is essentially a handling charge.  In\nmy opinion, the most important is the CBT MVS Mods Tape from the\nConnecticut Bank and Trust Company.  This tape, which is updated\napproximately once a month, has over 400 files on it, some of which\ncontain major software packages and products.  The SPLA MVS tape,\nthe JES2 and JES3 tapes, and NaSPA's very own VIP tapes are also\ngood sources of excellent things to help you.  (Addresses and phone\nnumbers for public tapes are available elsewhere in this issue.)\nOur initial concentration will be on the CBT tape, because of its\nvastness, and the breadth of its offerings.\n\n      Two small things before we get down to some nitty gritty.\nFirst.  THE FACT IS THAT TSO IS AN INTEGRAL PIECE OF THE MVS\nOPERATING SYSTEM.  EVERYONE WHO HAS MVS, ALSO HAS TSO.  Programs\nthat are known as \"TSO Commands\" or \"TSO Command Processors\" can\noften do their good work, running in BATCH MODE, without using a TSO\naccount.  Another way they can be run, is from a SYSTEM CONSOLE\nusing the TSSO product, available from the CBT tape or as a vendor\nproduct from BELLCORE.  TSO Commands that require FULL-SCREEN MODE\ncannot be run in these alternate modes, however.  I would therefore\nrecommend even for \"non-TSO\" installations, that at least two or\nthree TSO accounts be set up in the shop.\n\n      This is not a \"TSO prejudice\" on my part.  It is a means to\nimmense power.\n\n      Second.  Let me say a word about assembler MACRO LIBRARIES.\nMost of the tools we are going to talk about are written in BAL\nassembler language and are supplied in the form of source code.\nBesides the usual macro libraries SYS1.MACLIB and SYS1.AMODGEN that\nare normally referred to, SYS1.ATSOMAC (or whatever prefix your shop\nhas for it) may often be required in assemblies.  Specialty macros\nused by each product are usually supplied with the product, or\nindications are given where the macros can be found.  SYS1.AGENLIB,\nwhich has sysgen macros for MVS, will rarely be needed.\n\n      A general related principle is that one should not use a tool\nunless the assembly was clean (return code 0), or he can account\nfor every single line of code that gives condition code 4.  If the\nassembly condition code was 8, the load module should not be used.\nMuch care should also be paid to the linkedit step(s).  Haste makes\nfor unnecessary problems.\n\n      Now to start.  People often mention to me that the CBT tape is\nso vast, that they don't know where to begin looking.  This then, is\nmy first tip.  Print out file 1 (the catalog) and look through it\noften.  My favorite first files are from Jim Marshall of the US Air\nForce, files 300 (TSO commands) and 316 (batch utilities).  This is\nan excellect collection of close to 200 programs, and is a good place\nto begin exploring.\n\n      The very first thing I recommend installing is the UCLA\nfullscreen ZAP program from file 300.  It is a straight assembly and\nlinkedit of a load module, and it can be placed in any load library\nthat the TSO account has access to.  It not only replaces the batch\nAMASPZAP for 95 percent of applications, its \"find\" facility for hex\nand EBCDIC strings of data will make previously tedious \"zapping\"\nchores trivial.\n\n      ZAP need only be authorized to zap a VTOC.  In that capacity,\nit is an essential ingredient of my procedure (CBT tape file 29)\nto enlarge the VTOC of a disk pack \"on the fly\" without disturbing\nthe users of the pack, or the datasets on it.\n\n      A second useful tool to install right away from file 300 is\n\"CDSCB\" (\"change the DSCB\"), an authorized TSO command which changes\nany field of the VTOC entry (format 1 DSCB) of a disk dataset through\nthe use of commands.  This procedure is safer than zapping a VTOC\nentry directly, because you are assured that the correct fields are\nchanged, and you're not \"off by a byte or two\", which might spell\ndisaster.\n\n      After looking at Jim Marshall's files a bit, I'd then recommend\ninstalling the fantastic PDS program package on CBT tape files 182,\nalong with related utilities on files 296 and 112.  The PDS package\n(at version 8.2 as of this writing) literally rolls HUNDREDS OF\nUTILITIES into one unified whole.  My course of study on how to use\nthe product, printed in the January, February and March 1988 issues\nof \"Techical Support\", is now included in the distribution dataset\nfor PDS on file 182.\n\n      File 270, from Kermit Kiser and the Washington State DP Service\nCenter, is a large source of utilities, many of them original with\nthat installation.  File 149 from UCLA, and file 119 from Howard Dean,\nare some smaller collections that are good to look at.\n\n      A short word about large packages on the CBT tape (as opposed to\ncollections of utilities).  TSSO on file 401 is a multipurpose software\npackage that does TSO-like interactions with the MVS system\nconsoles.  Version 4.3 on the CBT tape is the last public-domain\nlevel of the product--it has since been \"taken private\" and its later\nversions are being sold by BELLCORE, Bell Communications Research, in\nPiscataway, New Jersey.  TSSO lets you:  execute TSO commands from\na system console (as long as they are not \"full screen\" commands),\nsuppress or highlight messages, enter MVS or VM commands automatically\nunder CLIST control, or driven by an initial console message.  It\ncan do much more than that, and is worth installing.  Some ideas of\nhow TSSO has been put to use, are on the CBT tape file 399.\n\n      DYNAMASK (file 400) from Steve Smith, allows an \"instant EDTGEN\"\nto define new generic unit names (e.g. SYSTSO, SYSWRK, etc.) without\nnecessitating an IOGEN, or even an IPL.\n\n      The CMD1 subsystem (file 261) is a multipurpose installation\nmonitor and IPL-saver.  I call it \"the poor man's RESOLVE\" (referring\nto the Boole and Babbage product).  CMD1 is a true SUBSYSTEM and does\nnot need JES2 or JES3.  There are several hundred things it can do\nfrom the system console, including \"displaying and zapping core\", and\nit has a TSO interface.  Pretty good, for something that's free.\n\n      How about looking at JES2 Spool?  The QUEUE program, available\non the CBT tape (file 394 for JES2 1.3.6 or 2.1.5, file 393 for 2.2.0)\nand on the JES2 Mods tape, allows a TSO user to view any dataset on\nspool, including output that belongs to a running job.  SYSLOG on\nspool, pending printout, held printout, and many other things can be\nshown, including JES2 control blocks which belong to a job.  For JES3\nusers, there is a comparable program on the JES3 tools tape.\n\n      Last but not least, are programs which make your TSO tube look\nlike a SYSTEM CONSOLE, and allow authorized personnel to enter any\nconsole commands from TSO, as if they were at one of the operators'\nconsoles.  File 25 of the CBT tape from Texas Power and Light has the\nnicest programs for this purpose that I've seen.  They have XA and\nnon-XA versions.  This package has some super options, such as\nautomatic renewal of the console screen, display of last IPL, and\ndisplay of past console commands from the in-core Master Trace Table.\n\n      I want to conclude this month's column with one specific tip.\nThat is so you don't leave with the impression that \"he just told\nus to install a bunch of stuff from the CBT tape\".\n\n      This trick (from Jeff Broido of Broido Computer Consulting\nin New Jersey) concerns VSAM files, and is not to be done casually.\nIn the proper context, it can be a life saver.  It is based on\nthe fact that VSAM datasets are protected from outside poking by\ntwo things:  The PASSWORD bit in the format 1 DSCB (VTOC entry)\nis set on for READ-WRITE protection.  (IDCAMS can get around it.)\nYou can find out about the password bits by looking in the MVS\nDebugging Guide under control block DSCB1.  There may be an expiration\ndate in the DSCB also.  This too, will block access by ordinary\nmortals (other than IDCAMS).\n\n      What do you do if a couple of bytes have to be adjusted in a\nVSAM file or catalog, and IDCAMS won't let you get to the thing?\nSimply get into the VTOC with full screen ZAP (mentioned above) and\nturn off the password bit of the DSCB for the dataset.  ZAP's \"find\"\ncommand makes it easy to get to the proper VTOC entry.  Then if\nthere's an expiration date (when you look around with ZAP you can see\nit), you can either zap it off, or use CDSCB to be more sure of\nyourself.  Now, the protection is off, and the VSAM file can be poked\naround with fullscreen ZAP or another utility, as if it were any other\ndataset.  When you've finished, reverse the steps, and turn the\nprotection back on.\n\n      That's it for now, we've run out of space.  See you next month\nfor more.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL8902FE": {"ttr": 3329, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93!\\x0f\\x00\\x93!\\x0f\\x12\\x01\\x00\\xd7\\x00\\xd7\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "1993-07-29T12:01:00", "lines": 215, "newlines": 215, "modlines": 0, "user": "SBGCSC"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         February 1989\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n\n\n      This monthly column is for sharing practical advice and\ntechniques which you can employ in your shop. I hope that every reader\nwill come away with something practical that can be immediately used.\nMost of the material in this column will take the form of short hints\nand tips.  We shall try to mention as many of them as can possibly fit\ninto the allotted space each month.\n\n      Readers are welcome to share their own nice techniques, and can\nwrite to me care of the editor.  The author's name will be included\ntogether with those contributions that are printed.\n\n      We would like to help as many people and as many shops as\npossible.  Therefore, most of the techniques mentioned in this forum\ncan be carried out using the enormous literature of publicly available\nMVS tools.\n\n      The vast CBT tape, available from Arnold Casinghino at the\nConnecticut Bank and Trust Company in East Hartford, Connecticut, is\na treasure trove of hundreds of large and small tools.  I believe it\nis the best source of public MVS material in one place, and that no\nshop should be without it.  It is updated frequently, about once a\nmonth.  Since the tape is almost full, deletions occur from time to\ntime, and you should hold on to your old tapes.  Much of my technique\ndepends on programs and other material from the CBT tape.\n\n      The NaSPA VIP tapes have many helpful programs, which we shall\ndraw from.  The MVS SHARE tape from SPLA, the MVS JES2 and JES3 SHARE\ntapes, and the SHARE PL1 tape, are other good sources of time and\nlabor savings.  A list of public tapes for MVS was printed in the\nJanuary issue of \"Technical Support\".\n\n      This month's column, in keeping with the February theme of\nDASD management, will be devoted to five topics.  These are:\n\n        1)  Restoring deleted PDS members.\n        2)  Extending the VTOC of a disk pack (while\n              it is active).\n        3)  Deletion and renaming of disk datasets\n              that are enqueued upon.\n        4)  Moving many datasets from one disk pack\n              to another.\n        5)  QUICKLY setting up tape backups of MANY\n              partitioned and sequential disk datasets.\n\n      Sound enticing?  Read on.  We'll deliver!\n\n      Deleted PDS entries may be restored, with the proper knowledge\nand a few good tools.  We're going to touch on the knowledge, and\nrefer you to the tools.\n\n      A PDS, or partitioned dataset, is MVS's version of a LIBRARY.\nIt is basically a sequential dataset, but is divided into parts.  The\nphysical beginning of the PDS is called the DIRECTORY, which is in\nthe form of 256-byte blocks.  The directory has pointers to the\nlocation of MEMBERS, which are SEQUENTIAL FILES THAT PHYSICALLY BEGIN\nAFTER THE END OF THE FORMATTED DIRECTORY BLOCKS.  The members are\nstrung out one after the other in the dataset.  The members are\nphysically separated from each other (and from the directory) by EOF\n(end-of-file) markers on the disk.\n\n      Our concern here is about what happens to a MEMBER when it is\ndeleted or modified.  Deleting a member just involves WIPING OUT ITS\nDIRECTORY ENTRY and rewriting the directory.  THE DATA REMAINS IN\nPLACE ON THE DISK, but no directory entry points to it.  Modifying\na member (not in place) is done by rewriting the modified data after\nthe end of the last member, and re-pointing the directory entry to\nthe new location.  Again, the original data stays in place on the\ndisk, until the PDS is reorganized by being COMPRESSED.\n\n      How should we restore a deleted PDS member in principle?\nA program which can MAKE A DIRECTORY ENTRY THAT POINTS TO THE OLD\nDATA, CAN EFFECTIVELY UN-DELETE THE MEMBER.\n\n      There are three such programs that I'll mention.  The simplest\none is a batch program called \"PDSGAS\", which can be found on the\nCBT tape, file 316.  One simply runs the program against the PDS,\nand it will find all physical member files that have no directory\nentries.  New entries are made for them, which are given the names,\n$GAS0001, $GAS0002, etc.  This treatment will suffice in most cases.\nAt the very least, it will preserve the deleted data across subsequent\ndataset compresses.  One can rename any of the restored members later.\n\n      A better tool is the fantastic and versatile \"PDS program\nproduct\", an extremely valuable public domain tool, the likes of\nwhich can be found nowhere else.  The \"PDS program\" is currently\nat version 8.2, and can be obtained from CBT tape file 182, with\nutilities on files 296 and 112.  \"PDS\" (the program) has a RESTORE\nfunction that has much versatility in resurrecting deleted members.\nIt can also reconstruct the more complicated directory entries\nassociated with load modules.  The PDS PROGRAM can \"fix\" directory\nentries with its ATTRIBUTE subcommand.  In addition, you can learn a\nlot about PDS directory entries by using the DIRENTRY subcommand of\nthe PDS PROGRAM.  DIRENTRY will display (and explain) the directory\nfields of any member of any PDS.\n\n      The third tool to UNDELETE PDS MEMBERS works under ISPF, and\nis called \"FIXPDS\".  It was written by Bob Weinstein, and can be found\non CBT tape file 36.  It works on a different principle than the\nother programs.  FIXPDS physically finds the LAST EOF MARKER in the\nextents of the dataset, and ISPF BROWSEs the LAST PHYSICAL MEMBER\nfor your perusal.  It then asks you if you want to make (or \"STOW\")\na new directory entry for this member (even if it already has one).\nFIXPDS then GOES BACKWARDS and gives you the opportunity to stow a\nnew directory entry for EVERY SINGLE PHYSICAL \"MEMBER\" that is there,\nall the way back to the beginning of the dataset.\n\n      The next topic, EXTENDING THE VTOC (volume table of contents)\nof a disk volume, is of value because the normal procedure is hard\nto do, and is very disruptive to the users of the pack.  I have a\nprocedure (suggested by Jeff Broido of Broido Computer Consulting in\nNew Jersey) which is quite easy to do, and which can be done while\nall the users are active.  It is so non-disruptive that none of the\nusers need be aware that it is being done at all!\n\n      The exact procedure (down to the last detail) can be found\non CBT tape file 29, and may soon be distributed with a NaSPA VIP\ntape.  All ingredients necessary to do the work can be found on the\nCBT tape.  The last step in the procedure is the most important\n(asking your boss for a raise after you've accomplished this miracle).\n\n      The procedure depends on placing a file that is FORMATTED LIKE\nAN EMPTY VTOC just after the end of the existing VTOC.  The existing\nVTOC also has to be converted to \"nonindexed\" format temporarily.\n(This is not hard.)  The \"FORMAT4.DSCB\" (VTOC header record) is\nthen fooled to think that the VTOC ends after the new file.  The\nFORMAT1 (dataset) VTOC entry for the extra file is zeroed out, and\nthe \"DIRF BIT\" in the VTOC header (reflecting the condition that the\nVTOC needs fixing) is zapped on.  With this done, we then try to\nallocate a new file on the volume.  The MVS operating system, seeing\nthe DIRF bit on, enters the VTOC CONVERT ROUTINE that is built into\nMVS, which cleans everything up, and makes the extended VTOC usable.\nNobody else realizes that this is going on.  Wow!\n\n      Our third topic is how to deal with datasets on disk, whose\nNAMES ARE ENQUEUED UPON by long-running jobs in the system.  A typical\nexample is if you have a scrap (say uncataloged) copy of SYS1.VTAMLIB\non a disk pack, and VTAM is up.  VTAM is likely to stay up all the\ntime, and you definitely wouldn't want to bring down CICS and half\nthe network, just to get rid of this junk dataset.  What to do?\n\n      This is a job for SUPRNAME !!!!!\n\n      SUPRNAME comes straight from the Metropolis of Olympia,\nWashington.  It is part of the magnificent collection of programs\nfrom the Washington State DP Service Center, file 270 of the CBT\ntape.  SUPRNAME does the rename and delete of datasets by directly\nzapping the VTOC entries themselves without the programmer having to\nknow where they are on the disk.  Its control cards simply ask for\nthe name of the dataset(s) to rename or delete, and the new name in\nthe case of a rename.  The action is done without actually accessing\nthe datasets in question, and so it bypasses the enqueue mechanism\ncompletely.  The junk copy of SYS1.VTAMLIB will soon be history.\n\n      One small detail is left.  If our VTOC happens to be indexed,\nthis action will not be completely accurate, so the sample SUPRNAME\nJCL comes conveniently sandwiched between ICKDSF steps to \"unindex\"\nand \"re-index\" the VTOC if it is necessary.  So, for systems\nprogrammers in distress anywhere from Metropolis to Smallville,\nSUPRNAME should come to the rescue.\n\n      Topic number four is \"moving many datasets from one disk pack\nto another\".  Normal vendor-supported vehicles for this service\nare DFDSS version 2 from IBM, and FDRDSF from Innovation Data\nProcessing, among other products.  These products are good, and\nI'm not going to disparage any of their considerable capabilities.\n\n      There is at least one good free alternative (for non-VSAM)\nwhich is called COPYPACK from file 32 of the CBT tape, soon to\nmake its way to a NaSPA VIP tape.  COPYPACK does a bulk move of\ndatasets from one disk pack to another, with optional dataset name\nfiltering and recataloging of the datasets, if you so specify.  It is\nalso very good for moving MODEL DSCBs from one pack to another\n(without cataloging them).  COPYPACK is not as fast as DFDSS version\n2 (in speed), and does not delete the datasets from the \"from\" pack,\nbut it offers different types of control that may make it more useful\nin many circumstances.  It is also cheaper.\n\n      Our final topic this month is a solution to a nagging bit\nof distress that even old (system programming) hands may not publicly\nadmit to.  This is the problem of doing IEBCOPY backup to tape, of\nlarge (or small) numbers of datasets.  One usually has to code a proc\nand keep track of the file numbers (on the tape) of all the backed-up\ndatasets.  Type a wrong file number, and you abend in the middle of a\nlong job.  This is a pain for the experienced, and a terror for the\nnovice.\n\n      NO MORE.  Just make a list of dataset names, and run a CLIST.\nThe CLIST will generate all of the backup JCL, which will even\ndo a TAPEMAP (CBT tape file 299) at the end of the backup.\n\n      Where are these magic CLISTs?  On CBT tape file 28, and soon on\na VIP tape.  There are quite a few of them.  Some will generate JCL\nto INIT the tape first.  Some will back up sequential datasets\nas well as partitioned datasets.  Just code all the partitioned\ndataset names first, followed by a control card, and then list all\nthe sequential dataset names.  CLISTs are provided to do this\nprocessing for cataloged datasets, OR for datasets on a particular\nsingle volume.\n\n      The general principle of the CLISTS is to read (&READDVAL) all\nthe input dataset names into a single long string (&SYSDVAL) in\n44-byte segments.  Then, to generate the JCL, the segments are shoved\nback as output dataset names into pre-formatted pieces of JCL, one\nsegment at a time.  (This idea also came from Jeff Broido.)\n\n      Good luck to you all, and please tune in again next month for\nmore.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL8903MA": {"ttr": 3334, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93!\\x0f\\x00\\x93!\\x0f\\x12\\x01\\x02B\\x02B\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "1993-07-29T12:01:00", "lines": 578, "newlines": 578, "modlines": 0, "user": "SBGCSC"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           March 1989\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n\n\n      This monthly column is for sharing practical advice and\ntechniques which can be employed in your shop.  I hope that every\nreader will come away with something practical that can be immediately\nused.  Our aim is to help MVS shops implement time-saving techniques\nthat are not hard to do, but which not everybody knows about.\n\n      Readers are encouraged to contribute to this column.  We depend\non you for its continued success!  Contributions can be sent through\nNASCOM, or you can write to me care of the Editor.  The contributor's\nname will be mentioned when his technique is printed in this column.\n\n      When software tools are required for any of the techniques, we\nwill try to use tools that are available to the public.  Of course,\nif a vendor product suffices for a particular user, that is fine,\ntoo.  There is a tremendous public domain literature of MVS tools.\nMany useful tools can be found on NaSPA's own V.I.P. tapes, and we\nwill draw heavily from the Connecticut Bank and Trust MVS Mods tape,\nknown as the CBT tape.  A list of sources for MVS tools can be found\nin the January issue of \"Technical Support\".\n\n      This month, our first technique will concern ISPF COMMAND TABLE\nADDITIONS.  These simple-to-make upgrades will greatly improve the\nefficiency of ISPF sessions.  With ISPF version 2, it is possible to\ndo five, ten, or more separate functions in the two ISPF splits, or\neven in one split.  You don't have to lose a screen split just to\nallocate a file or do a dataset list.  The technique is primarily for\nreleases of ISPF version 2, because these releases of ISPF will\nsupport RECURSIVE EDITs and RECURSIVE BROWSEs.\n\n      The concept of recursive edits is very simple.  Suppose you are\nin the middle of editing a file.  From the command line, you execute a\nCLIST or a command that calls another ISPF function to run inside the\nsame split of the screen.  If the called command or CLIST invokes the\nISPF EDIT function to do its work, it is clear that the EDIT function\nwas called TWICE FOR THE SAME SPLIT.  In ISPF version 2, this will\nwork, because multiple EDIT control blocks are created for each split.\nIn ISPF version 1, an abend will result.  A similar principle applies\nfor a call of the ISPF BROWSE function in the same split as a BROWSE\nwhich is already being done.  Version 2 can handle it.  Version 1\ncan't.\n\n      It is possible to RUN MANY ISPF FUNCTIONS AT THE SAME TIME by\ntaking advantage of the recursive ISPF invocations.  The question is\nnow, how can we recursively invoke a new ISPF function?\n\n      One answer is in using the ISPF COMMAND TABLE.  The command\ntables are part of your ISPF session.  Commands in the command table\nare executed when they are entered from the command line of an ISPF\nsession.  COMMANDS CAN DUPLICATE ANY FUNCTION WHICH IS SELECTABLE FROM\nA PANEL.  Our technique, then, is TO MAKE COMMANDS to invoke frequently\nused PANELS directly, on top of the current screen.  This has the\nadvantage that upon END from the invoked panel, you're still in the\nscreen that was being used before.\n\n      How do we do this?  A command table is a pds member allocated\nto the ddname ISPTLIB or the ddname ISPTABL.  ISPTLIB is used for\noutput, and ISPTABL is used for input, so if you plan to update a\ntable, it must be in a library allocated to ISPTABL.  Command table\nnames adhere to the convention \"applid\"+CMDS.  In other words, the\nname of the command table member is the name of the applid suffixed\nby the string \"CMDS\".  ISPF option 3.9 is used for editing command\ntables.  It assumes that your desired table is in a PDS allocated to\nddname ISPTABL, and that it IS NOT CURRENTLY BEING USED by any\nsession.  Therefore, you must update a COPY of the real table, and\nnot one that is in use.\n\n      The ISPF 3.9 entry panel asks for the name of the command table\nmember, minus the \"CMDS\" suffix.  The normal default ISPF command\ntable members are called ISPCMDS and ISRCMDS, which we cannot edit\ndirectly, so let's assume we have made copies of them in an ISPTABL\nlibrary, called XSPCMDS and XSRCMDS.  To edit XSPCMDS, we enter XSP\non the ISPF 3.9 entry panel screen, and we proceed to add or change\nentries to the table.  After the table is saved by using the END key,\nwe can replace the ISPCMDS member by the XSPCMDS member, get out of\nISPF entirely, and then back into ISPF.  The new entries should now\nbe effective on our ISPF session.\n\n      A lot of people know about ISPF command tables, so why are we\nwriting about them here?  The suggestion is as follows:  Take ALL\nTHE ISPF 3.x UTILITY FUNCTIONS and make COMMANDS to execute them\nON TOP OF WHAT WE'RE DOING NOW.  Then you can do a dataset allocation\nor a dataset list or a SUPERC, or even a command table edit, and not\nlose your current screen which contains the work you're doing.\n\n      For example, I'm doing an EDIT now, and I want to allocate a\nnew file.  I simply go to the command line and type DAT (for DATaset),\na command that I've set up.  Instantly the ISPF 3.2 prompt screen\ncomes up.  After I've allocated (or deleted) the dataset, I get out\nof that function, and I'm back in my original EDIT, on the same\nsplit of the screen.\n\n      Here are some hints on how to make the table entries.\n\n      Use the SELECT statements in the PROC section of your ISRUTIL\n(ISPF 3) panel, to determine the correct statements to put into the\ncommand table for the 3.x functions.  Panels are allocated to the\nddname ISPPLIB in your session.  This info should be of help in\nlocating your current panel whose name is ISRUTIL.  Just write the word\nSELECT, and copy the select statements exactly, without the quotes,\njust as they appear in the ISRUTIL panel.  You can alternatively copy\nthe entries from my sample table additions (which are for ISPF v2.3).\nPlease be aware that the utility invocations for ISPF v2.2 may be\nslightly different from mine.\n\n      Here's another hint in the process of exploring for commands:\nThe name of the panel currently being used can be displayed by\nentering the command PANELID on the command line.  The actual name of\nthe panel will be displayed in the upper left corner of the screen.\nPANELID OFF turns the panel name display off.\n\n      COMMANDS CAN BE MADE TO SELECT ANY SCREEN.  I've included a\nsample of some command table additions I've made.  Anyone can get\nvery creative with this, and really ease the burdens in his everyday\nwork.  Further assistance can be obtained from the IBM ISPF manuals.\n\n      One should create a TSO HELP member called \"CMDTABLE\", which\nkeeps the names of the extra commands handy in case you forget them.\nTo get really fancy, the help can be in the form of a new panel that\nis selected by a new command in the command table.\n\n      Good luck with your own command table additions.  Because of\nlack of space in this column, I have to eliminate extra detail, but\nthe included sample has extra hints and tips embedded right within\nit.  Please examine it carefully.\n\n (Please note the corrections to the following material, which are\n  appended to the end of this member.  Do not read the next few\n  paragraphs without referring to the correction. )\n\n      Now we go to topic number two, which was suggested by Bruce\nLeland of Hitachi in California.  This concerns the peculiarities\nof the Link Pack Area loading process, which loads system programs\nand routines into the Link Pack Area (or LPA) at IPL time.  Knowing\none detail about this process can save much grief.\n\n  (Please look at the postscript for correct answers in this topic.\n   Do not look in the following paragraphs.  Thank you.)\n\n      The detail concerns load modules which have alias entries\nin the SYS1.LPALIB pds directory, and there are many such load modules\nfor any level of the MVS operating system.  An alias directory entry\nin a pds LOAD MODULE directory will contain a field that has the name\nof its MAIN MEMBER, and another field which has the displacement of\nthe alias' entry point from the beginning of the listed main member.\n\n      Suppose we had a situation where load module MAINMEMB had\naliases ALIASA and ALIASB in SYS1.LPALIB.  Normally, all three\ndirectory entries IN THE DISK PDS DIRECTORY for these three names\nwould point to the same actual disk location, which is ONE disk copy\nof the module.  The LPA loader respects this condition also, and\nloads ONE COPY of the module into virtual storage, with three entry\npoints pointing to it IN THE LPA DIRECTORY IN VIRTUAL STORAGE.\n\n      Our USUAL perception of alias handling comes from how the\nIEBCOPY DISK COPYING PROGRAM handles them.  In a normal case situation,\nlet us say we are installing MAINMEMB and its aliases ALIASA and\nALIASB into SYS1.LPALIB from another library.  We select members\nMAINMEMB, ALIASA, and ALIASB in ONE IEBCOPY operation, and they get\ncopied together.  That is, ONE COPY of the load module and three\ndirectory entries pointing to it, are created.\n\n      If LATER, however, we do a SECOND IEBCOPY RUN to SYS1.LPALIB,\nselecting ONLY MAINMEMB and not the aliases, a SECOND COPY of the\nmain member will be copied to SYS1.LPALIB.  The alias directory\nentries will STILL POINT TO THE ORIGINAL DISK COPY, whereas the new\nMAINMEMB entry will point to the new copy.\n\n      What does the LPA Loader do when it sees this situation at\nIPL time?  It figures as follows:  THE ALIASES ARE PROBABLY RIGHT.\nThe new main member is probably a different version of the program.\nSince we want to have complete consistency in SYSTEM OPERATION, and\nsince a failure can only be corrected by a new IPL, which means a\nsystem outage, the LPA Loader uses only the disk copy pointed to by\nthe ALIAS members, and CONSTRUCTS A MAIN MEMBER ENTRY in the LPA\ndirectory in virtual storage that is consistent with THE COPY POINTED\nTO BY THE ALIASES.  THE ISOLATED MAIN MEMBER IS THROWN OUT, and a\nmessage is issued to the operator console (often missed by the\noperators) that this has been done.\n\n      It doesn't take much imagination to realize that problems\ncan occur if we try to INCORE ZAP this module in LPA.  The standard\nincore zap program looks at the disk copy of the module to determine\nits structure, and then goes to the core copy to make the changes.\nIf they are in fact different versions, we can get very confused.\n\n      A good preventive solution would be an overall diagnosis of\nSYS1.LPALIB to find these inconsistencies BEFORE IPL TIME.  Fortuately,\na good tool is available for this in the PDS PROGRAM PRODUCT on the\nCBT tape, file 182.  The PDS subcommand called \"VERIFY\" will check\nfor all inconsistencies connected with load modules and their aliases.\nIf one points the PDS program to the currently used SYS1.LPALIB and\nissues a VERIFY command for all members, the abnormalities displayed\nmay be quite shocking.  I know.  I've tried it.  This small step\ncan cure multiple mysterious system problems in advance.  You must,\nof course, use your head, and your understanding of MVS, in dealing\nwith what you find.  That's what System Programmers get paid their\nhigh salaries for.  However, the fact of discovery is a good eye\nopener.\n\n      Time has grown short for this month.  In ending our current\nsession, I'd like to inform our readership of the existence of an\nexcellent, though complicated FULL SCREEN EDITOR PRODUCT.  It is\ncalled ABE, for \"A Better Editor\".  ABE is written in PL1.  It\nrequires the Transient Library of the PL1 Optimizing Compiler in\norder to run.  It has enormous capability.  It is therefore not easy\nto learn, but it has two advantages.  First, it is free.  Second,\nit does very complicated functions, and it runs in batch also, although\nits normal functioning is under TSO.\n\n      The ABE editor is not for everyone.  MVS installations which\ndo not have ISPF may be interested in looking at it.  People who use\neditors in complicated ways may also be interested.  For those who\nwant a look, ABE may be found on a V.I.P tape in the near future,\nor it can be obtained from Tom G. Smith at Kimberly-Clark in Neenah,\nWisconsin.\n\n     *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFIGURE 1.          SAMPLE EXTENSIONS TO THE ISPF COMMAND TABLE\n\n\nCOMMAND TABLE - XSRCMDS --------------------------------------  ROW 1 OF 52\nCOMMAND ===>                                               SCROLL ===> CSR\n\nINSERT, DELETE, AND CHANGE COMMAND ENTRIES. UNDERSCORES NEED NOT BE BLANKED.\nENTER END COMMAND TO SAVE CHANGES OR CANCEL TO END WITHOUT SAVING.\n\n(Author's note. T stands for command truncation, number of chars valid)\n                0 means that the command cannot be shortened.\n\n     VERB      T  ACTION\n                     DESCRIPTION\n\n'''' ISPPREP   0  SELECT PGM(ISPPREP) NEWAPPL\n                     INVOKING PREPROCESSED PANEL UTILITY IN INTERACTIVE MODE\n'''' PDF       0  SELECT PANEL(ISR@PRIM)\n                     NEW PRIMARY LAYER OF ISPF\n'''' LIBRARY   3  SELECT PGM(ISRUDA) PARM(ISRUDA1)\n                     ISPF 3.1  LIBRARY UTILITY\n'''' DATASET   3  SELECT PGM(ISRUDA) PARM(ISRUDA2)\n                     ISPF 3.2  DATASET UTILITY\n'''' CPYLIBS   3  SELECT PGM(ISRUMC)\n                     ISPF 3.3  COPY UTILITY\n'''' DSLIST    3  SELECT PGM(ISRUDL) PARM(ISRUDLP)\n                     ISPF 3.4  DATASET LIST UTILITY\n'''' SPFSTATS  4  SELECT PGM(ISRURS)\n                     ISPF 3.5  ISPF STATS PANEL\n'''' HRDCOPY   3  SELECT PGM(ISRUHC)\n                     ISPF 3.6  HARDCOPY OUTPUT PANEL\n'''' OUTLIST   4  SELECT PGM(ISRUOLP)\n                     ISPF 3.8  OUTPUT LIST PANEL\n'''' CMEDIT    3  SELECT PANEL(ISPUCMA)\n                     ISPF 3.9  COMMAND TABLE EDIT FACILITY\n'''' CNVERT    3  SELECT PGM(ISRQCM) PARM(ISRQCMP)\n                     ISPF 3.10  CONVERT OLD FORMAT MENUS AND PANELS\n'''' FRMATDEF  3  SELECT PGM(ISRFMT)\n                     ISPF 3.11  FORMAT DEFN FOR FORMATTED DATA ED/BRWSE\n'''' SUPERC    4  SELECT PGM(ISRSSM)\n                     ISPF 3.12  SUPERC COMPARE UTILITY\n'''' SUPDETAL  4  SELECT PGM(ISRSEPRM) NOCHECK\n                     ISPF 3.13  DETAILED SUPERC COMPARE\n'''' SRCHFOR   4  SELECT PGM(ISRSFM)\n                     ISPF 3.14  SEARCH FOR - ISPF UTILITY\n'''' TSOP      0  SELECT PGM(ISRPTC)\n                     ISPF 6     INVOKE TSO OPTION 6 PANEL RECURSIVELY\n'''' CN        0  SELECT CMD(CN)\n                     INVOKE CONSOLE SIMULATOR FROM FILE 25 - CBT TAPE\n'''' PDSD      0  SELECT PGM(PDS83) PARM(PDS83 &ZPARM ISPMODE)\n                     INVOKE PDS VERSION 8.3 RECURSIVELY - CBT FILE 182\n'''' SECURE    3  SELECT PGM(SECURE)\n                     TSO COMMAND TO PREVENT ACCESS TO THIS TERMINAL\n'''' Z1        0  SELECT PGM(ZAP)\n                     FULL SCREEN ZAP PROGRAM FROM FILE 300 - CBT TAPE\n'''' TMSINQ    3  SELECT CMD(%TMSALOC) NEWAPPL(U01)\n                     TMS (CA-1) TAPE MGMT SYSTEM - ISPF INQUIRY/UPDATE\n'''' ASIDSE2   3  SELECT PGM(ASIDSE2)\n                     DISPLAY ADDRESS SPACE DATA FOR ACTIVE ADDR SPACES\n'''' COMPAR    0  SELECT PANEL(COMPR#P)\n                     COMPARE WITH YALE COMPARE PGM - EXTENDED\n'''' SYNCSORT  4  SELECT PANEL(OLSPOLS) NEWAPPL(OLSD)\n                     SYNCSORT RELEASE 3.2 ONLINE INTERFACE\n'''' PANVALET  3  SELECT PGM(PLF3)\n                     PANVALET ISPF FULL-SCREEN INTERFACE - CBT FILE 353\n\n             May 1989 MVS Tools and Tricks of the Trade\n\nPOSTSCRIPT:\n\n      I have to report a subsequent development and a retraction.\nThe retraction is about a mistake I made in my March column.  The\nsubsequent development concerns our current article.  I will describe\nwhat happened when IBM fixed the \"ACCEPTED\" PTF in error which I had\n\"backed off\".\n\n      This month's subject first.\n\n      IBM's bad PTF which I had ACCEPTED, number UY31933, had\naffected module APSQDEQ, which I had replaced with the base level of\nthat module, calling the fix by the APAR sysmod number of AZ19870.\nMy APAR \"fixing sysmod\" AZ19870 was given a PRE of the bad sysmod,\nUY31933.\n\n      At the time, I had figured that IBM WOULD REPLACE THE BAD\nMODULE APSQDEQ when it would come out with a fixing PTF to supersede\nmy APAR fix called AZ19870.\n\n      IBM crossed me up.  When they corrected the problem described\nby APAR AZ19870, they fixed a completely different module to solve the\nproblem.  The new PTF from IBM ASSUMED THAT MODULE APSQDEQ WOULD\nREMAIN AT RMID LEVEL UY31933.  If I would have APPLYed IBM's NEW PTF,\nthen the module APSQDEQ WOULD STILL BE AT BASE LEVEL, and WOULD BE\nINCOMPATIBLE with THE OTHER MODULE THAT GOT FIXED.\n\n      My solution was simple, but it shows that any tampering with\nIBM's scheme of fixes must be done very carefully.  All that needed to\nbe done was to RESTORE MY APAR SYSMOD AZ19870 (which unAPPLYs it).\nThis action would return module APSQDEQ back to its original RMID level\nthat would be compatible with THE OTHER MODULE WHICH IBM ACTUALLY\nREPLACED.  We back out our fix FIRST, and this accomplishes what IBM\nintended.  Our tampering is removed, and IBM's fix is properly put in\nits place.\n\n      The danger lies in APPLYing IBM's fixing PTF blindly, before\nundoing our own tampering.  IBM's PTF would have superseded our APAR\nnumber, making it impossible for us to RESTORE it afterwards, and the\ntwo modules in the system would remain at incompatible levels.  In\nretrospect, it may have been better NOT TO ASSIGN IBM's APAR NUMBER to\nour tampering SYSMOD; we would later be able to RESTORE it off.\nBut the problem would still be that we would never have gotten an ID\nCHECK to alert us when we tried to put on IBM's fix, no matter what\nnumber we had assigned.  That is because IBM ACTUALLY FIXED A\nDIFFERENT MODULE THAN THE ONE IN ERROR.  THE RMID OF IBM's FIXED\nMODULE WOULD NOT INTERACT, UNDER SMP, WITH THE RMID OF OUR BACKED-OFF\nMODULE.  Because we had no way of knowing what IBM would do, we could\nnever have second-guessed that occurrence in advance.\n\n      The moral of the story is:  YOU MUST ALWAYS BE CAREFUL\nWHEN IT COMES TO SMP.\n\n      Now to my mistake in the March column.\n\n      This concerns what I had said regarding how MVS System\nInitialization loads the Pageable Link Pack Area, or PLPA, at IPL\ntime, when a load module in SYS1.LPALIB does not correspond to its\naliases.\n\n      Please be assured that it is still very important to check\nSYS1.LPALIB to make sure that all main modules correspond to their\naliases.  \"Orphaned aliases\" or \"apparent aliases\" may still cause\nproblems, and these problems should be eliminated in advance.  As\nI said in the original March column, a \"VERIFY\" run on SYS1.LPALIB\nusing the public-domain PDS command processor (CBT Mods Tape file\n182) before IPL of the system, is probably the best preventive of\nany trouble.  The PDS VERIFY will flag all \"bad situations\" so\nthey can be fixed.  See POSTSCRIPT FIGURE ONE for an illustration\nof a VERIFY run.\n\n      My mistake was in my explanation of what MVS system\ninitialization does if there is a lack of correspondence between a\nmodule in SYS1.LPALIB and its aliases.  The correct scenario follows,\nand I thank Bruce Leland for helping me here.\n\n      At this point, I urge you to refer to POSTSCRIPT FIGURE TWO,\nwhich displays a load module alias directory entry.  This will\ncrystallize the situations in your mind.\n\n      THE CORRECTED PRINCIPLE IS:  THE PLPA LOADING ONLY LOADS MAIN\nMEMBERS, AND ALIASES ARE ONLY REFERRED TO BY THE DISPLACEMENT FROM THE\nENTRY LOAD POINT LOCATION OF THE MAIN MEMBER.  THE ALIAS ENTRY POINT\nIS DERIVED BY ADDING THE DISPLACEMENT AMOUNT (FROM FIELD PDS2EPA) TO\nTHE LOAD POINT OF THE MAIN MEMBER.  Now to describe some cases.\n\nCASE   1A.\n\n      Module A1 is an alias.  Its real member, indicated in the\n     PDS2MNM field of the directory, does not exist in SYS1.LPALIB.\n\n     System Action:  The alias is not loaded into PLPA, and its\n            name is discarded.  Messages are issued (IEA301I and\n            IEA356I on my system) that the alias will be discarded.\n\n\nCASE   1B.\n\n      Module A1 is an alias.  Its real member, indicated in the\n     PDS2MNM field of the directory, exists, but is marked as\n     an alias in SYS1.LPALIB.\n\n     System Action:  The alias is not loaded into PLPA, and its\n            name is discarded.  Messages are issued (IEA301I and\n            IEA356I on my system) that the alias will be discarded.\n\n\nCASE   2A.\n\n      A1 is a real member of SYS1.LPALIB.  A2 thru A9 are its aliases.\n\n      If A1 is renamed using TSO RENAME or ISPF 3.1 RENAME, the\n     main member fields in the directory entries of A2 thru A9 are\n     unchanged by the rename of their main member.  Thus it appears\n     that A2 thru A9 do not have a main member.  (The RENAME function\n     that comes with the \"PDS\" product, will not fall into this pitfall\n     and will adjust the PDS2MNM fields of all aliases when the main\n     member is renamed.)\n\n     System Action:  These aliases are not loaded into PLPA, and the\n            names A2 thru A9 are discarded.  Messages are issued\n            (IEA301I and IEA356I on my system) that these aliases\n            will be discarded.  This situation is pretty pernicious,\n            because probably nobody will notice the messages at IPL\n            time.\n\n\nCASE   2B.\n\n      A1 is a real member of SYS1.LPALIB.  A2 thru A9 are its aliases.\n\n      If A2 thru A9 are renamed using TSO RENAME or ISPF 3.1 RENAME,\n     the main member field of each of them is unchanged.\n\n     System Action:  Since the main member A1 still exists,\n            LPDE (Link Pack Directory Entry) entries will be\n            created for the renamed aliases under their new\n            names.  This may or may not be what you want.\n\n\nCASE   3.\n\n      A1 is a real member of SYS1.LPALIB.  A2 thru A9 are its aliases.\n\n      A1 is recompiled from different source and relinked into\n     SYS1.LPALIB, but without ALIAS control cards for the eight\n     aliases A2 thru A9.\n\n     System Action:  THIS IS THE MOST PERNICIOUS CASE OF ALL.\n            Since the main member exists for all of the aliases,\n            NO WARNING MESSAGES ARE ISSUED.  However, since the\n            main member was compiled from different source, the\n            ACTUAL ALIAS ENTRY POINTS MAY BE AT DIFFERENT\n            DISPLACEMENTS THAN THOSE INDICATED BY THE PDS2EPA\n            FIELDS OF EACH ALIAS.  When an attempt is made to\n            access the module through an alias name, the point\n            of attempted entry may actually not be an entry\n            point, and a \"mysterious abend\" or other mishap\n            will result.\n\n\n      I hope this sets the record straight.  The reader is referred\nto the \"MVS System Initialization Logic\" manual for his system, and\nalso to the fiche for module IEAVNP05, which does the PLPA loading.\n\n      *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nPOSTSCRIPT FIGURE ONE:\n\n\n     THIS IS AN ILLUSTRATION OF A PDS (version 8.2) VERIFY RUN.\n\n     The actual output is shown.\n\n- DSN=SYS1.LPALIB,VOL=SER=MVSRES  MEM=:\n>c 'sys1.lpalib'\nDISP UNIT     RECFM LRECL BLKSIZE   ALLOCTRK FREETRK SECONDARY FREEDIR\nSHR  3380     U         0   19069   1X   300      91   120 TRK     353\n\nENTER OPTION -- DSN=SYS1.LPALIB,VOL=SER=MVSRES  MEM=\n>ver :\n\n** VERIFY   IGC0107B\nMEMBER IS AN ALIAS BUT NO MAIN MEMBER EXISTS\nTHE ALIAS DIRECTORY ENTRY NOTES THE MAIN ENTRY NAME AS IGC0007B\n\n** VERIFY   IFG0193C\nMEMBER IS AN ALIAS BUT NO MAIN MEMBER EXISTS\nTHE ALIAS DIRECTORY ENTRY NOTES THE MAIN ENTRY NAME AS OMODVOL1\n\n** VERIFY   IFG0553C\nMEMBER IS AN ALIAS BUT NO MAIN MEMBER EXISTS\nTHE ALIAS DIRECTORY ENTRY NOTES THE MAIN ENTRY NAME AS EMODVOL1\n\n** VERIFY   $EFACTRT\nMEMBER IS AN ALIAS BUT NO MAIN MEMBER EXISTS\nTHE ALIAS DIRECTORY ENTRY NOTES THE MAIN ENTRY NAME AS IEFACTRT\n\n** VERIFY   IGE0001H\nTHE DIRECTORY RLD/CONTROL COUNT DOES NOT MATCH THE FIRST RLD ENTRY\n\n** VERIFY   IGG019OA\nTHE DIRECTORY RLD/CONTROL COUNT DOES NOT MATCH THE FIRST RLD ENTRY\n\n** VERIFY   ICBVIN02\nTHE DIRECTORY RLD/CONTROL COUNT DOES NOT MATCH THE FIRST RLD ENTRY\n\n** VERIFY   IGC0008B\nTHE DIRECTORY RLD/CONTROL COUNT DOES NOT MATCH THE FIRST RLD ENTRY\n\n** VERIFY   IGC0108B\nTHE DIRECTORY RLD/CONTROL COUNT DOES NOT MATCH THE FIRST RLD ENTRY\n\n** VERIFY   IGC0508B\nTHE DIRECTORY RLD/CONTROL COUNT DOES NOT MATCH THE FIRST RLD ENTRY\n\n** VERIFY   IGG0197N\nTHE DIRECTORY RLD/CONTROL COUNT DOES NOT MATCH THE FIRST RLD ENTRY\n\n** VERIFY   IGCT005G\nTHE DIRECTORY RLD/CONTROL COUNT DOES NOT MATCH THE FIRST RLD ENTRY\n\nEND OF DATA SET\n\n    7,069 PHYSICAL BLOCKS WERE INPUT\n   18,432 CHARACTERS IN THE LARGEST PHYSICAL BLOCK\n      658 CHARACTERS PER AVERAGE PHYSICAL BLOCK\n        1 TRACKS COULD BE REGAINED BY COMPRESSING THIS DATA SET\n    1,351 MEMBERS WERE CHECKED\n\n\n854 MEMBERS RMODE24; SIZE IS 4,075K\n5 MEMBERS RMODEANY; SIZE IS 6K\n\n\n      *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nPOSTSCRIPT FIGURE TWO.\n\n\n    This is an actual PDS (version 8.2) \"DIRENTRY\" display of\n     an ALIAS entry of a load module.  Fields of the directory\n     entry are described below the hexadecimal display.\n\n    The fields PDS2MNM (at +24 in this example) and\n     PDS2EPA (at +1B in this case) concern us the most.\n\n\n\n- DSN=TSTBSSG.LOAD,VOL=SER=TSO001  MEM=\n>DIRENTRY ASMBLR\nASMBLR DIRECTORY ENTRY, LENGTH=50\n         0000  C1E2D4C2 D3D94040  006E23B3 006E2800  *ASMBLR  .>...>..*\n         0010  00000000 C2E20017  50175000 00009800  *....BS..&.&...q.*\n         0020  01000000 C9C5E5F9  F0404040 00877048  *....IEV90   .g..*\n         0030  0100                                  *..*\n\nLOC NAME     VALUE     DESCRIPTION\n--- ----     -----     -----------\n00  PDS2NAME ASMBLR    MEMBER NAME\n08  PDS2TTRP 006E23    TTR OF FIRST BLOCK OF DATA\n0B  PDS2INDC B3        ALIAS; 1 TTRS FOLLOW; 19 HALFWORDS OF DATA\n0C  PDS2TTRT 006E28,00 TTR OF FIRST TEXT BLOCK\n10  PDS2TTRN 000000,00 (NOT USED FOR THIS MEMBER)\n14  PDS2ATR1 C2        REENTRANT; REUS; NOT OVERLAY; NOT TEST\n                       NOT ONLY LOAD; NOT SCATTER; EXEC; NOT 1 TEXT\n15  PDS2ATR2 E2        NOT DC; TEXT ORG=0; EP=0; HAS RLDS\n                       EDIT; NOT TEST; LKED F; NOT REFRESHABLE\n16  PDS2STOR 5,968.    TOTAL CONTIGUOUS MAIN STORAGE REQUIRED\n19  PDS2FTBL 5,968.    LENGTH OF FIRST BLOCK OF TEXT\n1B  PDS2EPA  000000    ENTRY POINT ADDRESS\n1E  PDS2FTB1 98        PROCESSED BY OS/VS LINKAGE EDITOR\n                       SSI INFORMATION IS PRESENT\n                       APF INFORMATION IS VALID\n1F  PDS2FTB2 00        RMODE 24;  ALIAS AMODE 24;  MAIN AMODE 24\n20  PDS2FTB3 01        RLD/CONTROL RECORDS AFTER FIRST TEXT BLOCK\n21  PDS2EPM  000000    ENTRY POINT OF MAIN MEMBER\n24  PDS2MNM  IEV90     MEMBER NAME OF MAIN MEMBER\n2C  PDSSSIWD 00877048  SSI INFORMATION\n30  PDSAPFCT 01        LENGTH OF PROGRAM AUTHORIZATION CODE\n31  PDSAPFAC 00        PROGRAM AUTHORIZATION CODE\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL8904AP": {"ttr": 3590, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93!\\x0f\\x00\\x93!\\x0f\\x12\\x01\\x01~\\x01~\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "1993-07-29T12:01:00", "lines": 382, "newlines": 382, "modlines": 0, "user": "SBGCSC"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           April 1989\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n\n\n      This monthly column is for sharing practical advice and\ntechniques which can be employed in your shop.  In this issue, we\nwill provide a means for enlarging the VTOC, or \"Volume Table\nof Contents\", of an active disk pack.  The NASCOM HIGHLIGHTS of\nDecember '88 have emphasized the enormity of the need for that\ninformation.\n\n      We encourage readers to contribute to this column.  We depend\non you for its continued success!  Contributions can be sent through\nNASCOM, or you can write to me care of the Editor.  The contributor's\nname will be mentioned when his technique is printed in this column.\n\n      If software tools are required for any of the techniques, we\nwill mention tools that are available to the public.  Of course,\nif a vendor product suffices for a particular user, that is fine,\ntoo.  There is a tremendous public domain literature of MVS tools.\nMany useful tools can be found on NaSPA's own V.I.P. tapes, and we\nwill draw heavily from the Connecticut Bank and Trust MVS Mods tape,\nknown as the CBT tape.  A list of sources for MVS tools can be found\nin the January issue of \"Technical Support\".\n\n      Our technique for dynamically enlarging the VTOC of an active\npack can also be found on file 29 of the CBT MVS Mods tape.  I have\npreferred to use a \"cookbook approach\" in the explanation, because\nof the delicacy and care with which the job has to be done.  So\nwithout further ado......\n\n\nRECIPE TITLE:  Enlarging the VTOC of an active disk pack, without\n        impact on the users of the pack.\n\nINGREDIENTS.  Our most helpful tool is the UCLA Full Screen ZAP\n        program that can be found on the CBT tape, File 300.  You\n        can use other zapping tools, but this one enables you to\n        really see what is going on, and it's fast.  To use Full\n        Screen ZAP to update a VTOC, it'll have to run authorized.\n        Zap your module IKJEFTE2 (in load module IKJEFT02) with the\n        name \"ZAP\", put the program in an authorized library, and\n        make sure it's linkedited with SETCODE AC(1).  Authorize it\n        another way if you're sophisticated.  (Hint:  to save an IPL\n        (since IKJEFT02 is usually in LPALIB), make a copy of load\n        module IKJEFT02 with all its aliases, in an authorized\n        steplib or in a linklist library, and zap that copy.  Make\n        sure to get rid of it later, or it may cause confusion.)\n\n        You'll need an MVS SPL DEBUGGING GUIDE to show you the format\n        of the different DSCB's (VTOC entries).  I shall assume that\n        you have a Debugging Guide.  If you are really stuck without a\n        Debugging Guide, you can expand the macro IECSDSL1, which maps\n        all the VTOC entry formats.  The macro is in SYS1.AMODGEN.\n        You can assemble the coding example I have given for this\n        macro, and you'll get a description of all the format types.\n\n        I'll also assume you have ISPF.  I certainly hope that you do!\n        The ABE Editor from Tom Smith at Kimberly-Clark in Neenah,\n        Wisconsin, will also be OK.  This fine editor, written in PL/I,\n        is a public-domain product.\n\n        I'm including 2 job streams.  The one called OSVTOC converts a\n        pack with an indexed VTOC into an old-style OS VTOC, which\n        we'll need to do, if the VTOC is indexed.  The job IXVTOC\n        converts the OSVTOC back to indexed format.  You'll do this\n        after you've enlarged the VTOC, if it was originally indexed.\n\n        One more tool is necessary.  You'll have to obtain a track map\n        of the pack.  That is, you'll need to find out where your VTOC\n        is on the pack, and what datasets are just below it.  (This\n        makes sense, because you have to expand the VTOC to the space\n        just beyond it.)  I use the UCLA VTOCLIST program on File 149\n        of the CBT tape.  Execute it with PARM=MAP (which gives the\n        track map).  IEHMAP (CBT tape File 083) will do it too.  If\n        you insist on using IBM utilities, use IEHLIST.  A job to run\n        the VTOCLIST program is included.\n\nPROCEDURE.   Assuming you now have all the ingredients available, here\n        is what you do.\n\n        1.  Make sure you have at least 5 or 6 free DSCBs (VTOC entries)\n              on the pack.  This is especially critical if the VTOC is\n              currently in INDEXED format.  If the VTOC is not indexed,\n              then one or two free entries will suffice.  Move datasets\n              off the pack, or delete some, to get the necessary free\n              DSCBs.  (If you don't know if a pack is currently indexed,\n              there must be 2 conditions for it.  The DS4VTOCI bit in\n              the FORMAT4 DSCB (volume header DSCB) must be on, and\n              also, that there is an INDEX dataset, with name of the\n              type SYS1.VTOCIX.VOLSER on the pack.)\n\n        2.  If the pack is indexed, run the job OSVTOC to convert the\n              VTOC to non-indexed format.  This will require a few\n              free DSCBs to be available (for new FORMAT5 DSCBs to\n              describe free space on the pack).  The job will require\n              an operator reply of \"U\".  The job does not delete the\n              dataset SYS1.VTOCIX.VOLSER on the pack.  In fact, you\n              will need to have this dataset later, when you convert\n              back to indexed format, so just leave it alone.\n\n        3.  Get a TRACK MAP of the pack.  Determine how many new VTOC\n              entries you want.  On a 3380 there are 53 entries per\n              track.  This number, in binary, is in field DS4DEVDT\n              of the FORMAT4 DSCB.  Once you've decided how many new\n              entries you want, clear the appropriate number of tracks\n              just after the extent where the VTOC currently is.  Do\n              this by moving any datasets that are there off the pack\n              (or to any other place of your preference).\n\n        4.  Using the job VTEXALLC (modify it for your needs and use\n              the MVS JCL manual for reference), allocate a new\n              dataset, with DCB attributes LRECL=96,KEYLEN=44,\n              DSORG=PS,RECFM=F.  At this point, run another track map\n              to make sure your new dataset is right after the VTOC.\n              Delete and reallocate if necessary, until you've\n              gotten it right.  Make sure the dataset has enough\n              tracks.  BE CAREFUL WITH THIS.\n\n        5.  Now edit the dataset with ISPF.  There should be no lines\n              in the dataset.  Insert a line and save it.  Make sure\n              you are NOT IN NUMBER MODE.  To do this, issue the ISPF\n              edit command \"NUMBER OFF\".  The two commands in\n              succession \"RENUM\" then \"UNNUM\" will also do it.  Get\n              into hex mode (ISPF command \"HEX\").  Convert every blank\n              to x'00'.  Make sure you've done it for ALL 140\n              CHARACTERS.  Be very careful.  Then save the line again.\n              Repeat the line of hex zeros many times. (Do it more than\n              the 795 entries per 3380- cylinder.)  Now attempt to\n              save the edit.  If you don't go down with a D37 abend,\n              you probably didn't repeat the line enough times to fill\n              all the tracks of the dataset.  Make sure you get ABEND\n              D37 on the save.  If not, repeat the line (each line\n              becomes a new FORMAT0 VTOC entry) more times, and save\n              again, until you get an ABEND D37. The attempted \"SAVE\"\n              has now formatted the dataset to look something like a\n              blank VTOC.\n\n        6.  Now you have to use Full Screen ZAP.  If you're using\n              another zapping tool, you can accomplish the same things\n              with it, but probably not as easily.  To get the FORMAT4\n              VTOC entry on the TSO screen, you have to have a cataloged\n              dataset on the pack.  If there are none, catalog a NONVSAM\n              dataset on the pack (with ISPF 3.2) using some garbage\n              name.  (This is what you need another free DSCB for.)\n              See the instructions later in this article for how to\n              look at and modify VTOC entries with the UCLA Full Screen\n              ZAP program.  (I'll assume henceforth that you know how\n              to do this.)  You should keep a track map of the pack\n              in front of you.\n\n              You must now change two things on the FORMAT4.  Number\n              one, you must modify the SECOND EXTENT DESCRIPTOR\n              (giving the high track address - the upper limit of the\n              VTOC) so it points to the end of your new extension\n              dataset that you put after the VTOC.  The layout of the\n              extent descriptors is described in detail under FORMAT3\n              (detailed in the SPL Debugging Guide under control block\n              DSCB3).  They are 10 bytes in length and give the\n              cylinder and track numbers in binary.  If you used\n              VTOCLIST to get the track map, and Full Screen ZAP to\n              see the FORMAT4 DSCB, it should be quite clear where the\n              descriptors are.  Use the Debugging Guide (DSCB4) or the\n              assembly of the mapping macro (described above) and be\n              careful.\n\n              When you are satisfied you've done everything right\n              (you can ruin access to the pack if you didn't), make\n              the change permanent.  Now you must turn the DIRF bit\n              on:  this is DS4DIRF on the FORMAT4.  Make the change\n              permanent.  Finally, you must delete the VTOC entry for\n              the new dataset which is right after the VTOC.  This is\n              so that the VTOC \"thinks\" that there is no dataset\n              there.  You do this by setting the entire entry to hex\n              zeros.  In Full Screen ZAP, the \"F\" command F/dsname/\n              can be used to find the correct FORMAT1 DSCB.  The\n              command \"SET00\" sets the entire record to hex zeros,\n              and the command \"ZAP\" makes the change permanent.\n\n              These 3 items:  a) Changing the second extent descriptor.\n              b) Turning on the DIRF bit in the FORMAT4.  c) Zeroing\n              out the FORMAT1 VTOC entry of your new formatted VTOC\n              extension dataset, complete the VTOC zaps that must be\n              done.\n\n        7.  Now get out of ZAP, get a ZAP log, and get into ISPF 3.2.\n              Try to allocate another dataset on the pack.  If you\n              have access to an operator console, you should see a\n              message to the effect: \"VTOC CONVERT ROUTINE ENTERED -\n              REASON DIRF\".  This should probably be the only console\n              message you get.  You may get a message that the routine\n              was successful, but you may not.  In any case, if you\n              get any message that the routine was unsuccessful, you\n              should immediately set the FORMAT4 DSCB back to what it\n              was (so you don't kill access to the pack), scratch your\n              head, and try again.  I'll assume you were successful so\n              we'll look at the next step.\n\n        8.  You now should have an extended VTOC.  Run VTOCLIST again\n              to verify the number of free DSCBs on the pack, or use\n              ISPF 3.4 (in ISPF release 2.3) or ISPF 3.7 (for previous\n              releases) or any other method of checking the number\n              of free DSCBs.  If your VTOC was originally not indexed,\n              you're home free.  Otherwise,\n\n        9.  Run the job IXVTOC to reconvert the VTOC back to indexed\n              format.  Remember that the operator will have to reply\n              \"U\".\n\n       10.  Now your boss should applaud you, and put you\n              in for a raise or a bonus.\n\n\n  If you have any questions or problems in doing this, I hope I'll be\navailable (during the day, please:  unless your shop is about to die).\nMy phone number is on the CBT tape, File 029, or call the editor\nof \"Technical Support\" or (201) information if you need to contact me.\n\n       * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nAPPENDIX A.\n\n             ZAPPING A VTOC ENTRY WITH UCLA FULL SCREEN ZAP\n             ----------------------------------------------\n\n ******      IT IS ADVISABLE TO ZAP SOME LESS-MEANINGFUL DATASETS\n ******      BEFORE TACKLING A VTOC.\n\n\n I am referring to the ZAP program available on File 300 of the CBT\n    MVS mods tape.  This is Jim Marshall's library of TSO commands.\n\n I assume you have the ZAP program properly installed.  It is a TSO\n    command, and it must be executed authorized in order to zap a VTOC\n    entry.  If you can't do this, please consult your local TSO guru\n    until you've gotten it right.  (For most other uses, ZAP doesn't\n    have to be authorized).\n\n To get to the VTOC on a given pack do the following: (I am assuming\n    that the pack name is PACK01, and there is a cataloged dataset\n    on PACK01 called SYS2.DATASET).\n\n      a.  Invoke the ZAP program authorized:\n                   ( Enter the command:  ZAP  )\n                   (  In my shop, there's a \"magic\" SVC, so I\n                        enter either \"OP Z\" or \"$$ ZAP\" )\n\n      b.  The system comes back with:  \"ENTER DATA SET NAME\"\n                 Enter:   'FORMAT4.DSCB' ALLOCD('SYS2.DATASET')\n\n                     If 'SYS2.DATASET' is cataloged to PACK01,\n                     you'll get the FORMAT4 DSCB of PACK01.\n                     All the other DSCB's come afterwards.\n\n           *  Note.  If you're zapping another dataset, just enter\n                       its TSO-qualified name.\n\n      c.  The system will now display the FORMAT4 (header) DSCB.\n              The ZAP program has a built-in tutorial that can\n              be entered by putting \"?\" on the command line.\n              To get out of the tutorial, put \"U\" on the command\n              line.  Changes are made permanent with the command\n              \"ZAP\".\n\n      d.  Advice:  Learn the tutorial first.  You can always get\n              into it by entering \"?\" on the command line, and back to\n              where you were by entering \"U\" on the command line.\n              The tutorial has 13 screens.  At least glance at them all.\n              You don't put spaces between the command and the operand.\n              The command \"END\" quits you out of ZAP at any time.\n              The command \"P\" gets you to the beginning of the FORMAT4.\n              There is a little arrow \"<\" or \">\" that points to\n              the current byte.  Go forward and backward by entering\n              plus or minus the number of bytes in hex.  For example:\n              +3 (3 bytes forward), -c (x'c' bytes backward), etc.\n              To substitute up to 8 bytes starting from the current\n              byte, enter \"S\" followed by a hex value--no spaces in\n              between.  To make changes permanent, enter \"ZAP\".\n              Always get a ZAP log if you've changed something, until\n              you're completely familiar with the program.\n\n\nAPPENDIX B.   JOBSTREAMS.\n\n//*              * * *     O S V T O C     * * *\n//TSTBSP2N JOB ,'TECH.SUPPORT',CLASS=M,NOTIFY=TSTBSSG,TIME=1440,\n//        MSGLEVEL=(1,1),MSGCLASS=T\n//*******************************************************************//\n//*  NOTE..... THIS WILL ASK OPERS FOR A REPLY - YOU NEED A \"U\" IF OK.\n//*******************************************************************//\n//* ------------------------------------------- *//\n//* INVOKE THE DEVICE SUPPORT FACILITY PROGRAM\n//* ------------------------------------------- *//\n//****************************************//\n//*      CONVERT IXVTOC TO OSVTOC:\n//****************************************//\n//S1    EXEC PGM=ICKDSF,TIME=1439\n//SYSPRINT  DD SYSOUT=*\n//VPDNV01 DD VOL=SER=PDNV01,UNIT=SYSDA,DISP=SHR, <=== CHANGE ALL\n//   DSN=SYS1.VTOCIX.VPDNV01        <=== OCCURRENCES OF VOLSER NAME.\n   BUILDIX DDNAME(VPDNV01) OSVTOC\n/*\n\n\n//*              * * *     I X V T O C     * * *\n//TSTBSP2N JOB ,'TECH.SUPPORT',CLASS=M,NOTIFY=TSTBSSG,TIME=1440,\n//        MSGLEVEL=(1,1),MSGCLASS=T\n//*******************************************************************//\n//*    NOTE..... THIS WILL ASK OPERS FOR A REPLY.  \"U\" IF OK. ****\n//*******************************************************************//\n//* ------------------------------------------- *//\n//* INVOKE THE DEVICE SUPPORT FACILITY PROGRAM\n//* ------------------------------------------- *//\n//****************************************//\n//*        REBUILD INDEXED VTOC:\n//****************************************//\n//START EXEC PGM=ICKDSF,TIME=1439\n//SYSPRINT  DD SYSOUT=*\n//VPDNV01 DD VOL=SER=PDNV01,UNIT=SYSDA,DISP=SHR, <=== CHANGE ALL\n//   DSN=SYS1.VTOCIX.VPDNV01  <=== OCCURRENCES OF VOLSER NAME TO YOURS\n   BUILDIX DDNAME(VPDNV01) IXVTOC\n/*\n\n\n//*              * * *   V T E X A L L C   * * *\n//TSTBALLV JOB ,'TECH.SUPP-SAM.GOLOB',CLASS=M,NOTIFY=TSTBSSG,\n//        MSGLEVEL=(1,1),MSGCLASS=T TYPRUN=HOLD\n//***************************************************************//\n//* ALLOCATE MODEL DATASET THAT LOOKS LIKE DCB OF A BLANK VTOC  *//\n//***************************************************************//\n//ALLOCDX  EXEC PGM=IEFBR14\n//SYS00058 DD DSN=TSP.VTOC,DISP=(OLD,DELETE),UNIT=3380,\n//  VOL=SER=PDNV01\n//ALLOCIX  EXEC PGM=IEFBR14\n//SYS00058 DD DSN=TSP.VTOC,DISP=(NEW,KEEP,DELETE),UNIT=3380,\n//  DCB=(RECFM=F,BLKSIZE=96,DSORG=PS,KEYLEN=44),VOL=SER=PDNV01,\n//  SPACE=(ABSTR,(15,6615))   <=== ABSOLUTE TRACK ALLOCATION.\n//*                           <=== YOU'LL HAVE TO CHANGE IT.\n//*                           <=== SEE THE MVS JCL MANUAL.\n\n\n*       * * *   V T O C   D E S C R I P T I O N   * * *\n*  ASSEMBLING THIS GIVES VTOC FORMATS FOR ALL TYPES OF\n*    VTOC ENTRIES.   (SYS1.AMODGEN)\n         IECSDSL1  1      , FORMAT 1 DSCB\n         IECSDSL1  2      , FORMAT 2 DSCB\n         IECSDSL1  3      , FORMAT 3 DSCB\n         IECSDSL1  4      , FORMAT 4 DSCB\n         IECSDSL1  5      , FORMAT 5 DSCB\n         IECSDSL1  6      , FORMAT 6 DSCB\n         END              ,\n\n\n//*              * * *   V T O C L I S T   * * *\n//TSTBSP2M JOB ,'TECH.SUPPORT',CLASS=M,NOTIFY=TSTBSSG,\n//        MSGLEVEL=(1,1),MSGCLASS=T TYPRUN=HOLD\n//*\n//*  THE VTOCLIST PROGRAM IS OBTAINABLE FROM FILE 149 OF THE CBT TAPE.\n//*\n//VTOCLIST PROC SOUT='SYSOUT=*',\n//             U=DISK,\n//             VOLID='INVALID'\n//*********************************************************************\n//*  ***** M A P D I S K - V T O C / D I R E C T O R Y   D U M P      *\n//*****************************************************************RHD*\n//VTOCLIST EXEC PGM=VTOCLIST,PARM='MAP'\n//STEPLIB  DD  DISP=SHR,DSN=TST.TSO.CMDLIB\n//VOL1     DD  UNIT=&U,VOL=SER=&VOLID,DISP=SHR\n//SYSPRINT DD  &SOUT,\n//             SPACE=(CYL,(1,2)),\n//             DCB=BLKSIZE=990\n//SYSUDUMP DD  &SOUT\n//  PEND\n//*\n//PDNV01  EXEC VTOCLIST,PARM='MAP',\n//         SOUT='SYSOUT=*',      /*** DEF = SYSOUT=A ****/\n//         U=3380,              /*** DEF = DISK     ****/\n//         VOLID=PDNV01\n//*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL8905MY": {"ttr": 3841, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93!\\x0f\\x00\\x93!\\x0f\\x12\\x01\\x01\\x9b\\x01\\x9b\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "1993-07-29T12:01:00", "lines": 411, "newlines": 411, "modlines": 0, "user": "SBGCSC"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                            May 1989\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n\n\n      This monthly column is for sharing practical advice and\ntechniques which can be employed in your shop.  Our current article\nlends itself to the rare attribute of having a title.  It is called\n\"DELINK AND RELINK\".  We shall discuss some aspects of the fine art\nof manipulating load modules and their CSECTs.\n\n      The two software tools needed for the discussion can be found\non the Connecticut Bank and Trust Company MVS Tape that is obtainable\nfrom Arnold Casinghino, phone (203) 244-5495.  The required tools are\nthe DELINK0 program, on file 316 of the \"CBT\" tape, and the \"PDS\"\nprogram, on file 182 of that tape, with needed utilities on files 296\nand 112.\n\n      The PDS program is an enormously useful multipurpose utility\nworkbench.  We will basically consider only one feature of it here.\nA full course on the uses of PDS was printed in \"Technical Support\"\nin a series of three articles from the JANUARY thru MARCH issues in\n1988.  That course material is also distributed in the PDS install\nlibrary on the CBT tape, file 182, so it is not hard to get.\n\n      Let us begin our discussion with the DELINK0 program, an old\nIBM field service utility in the public domain.  DELINK0 is a program\nthat converts a LOAD MODULE CSECT into an OBJECT DECK, doing the\nOPPOSITE OF THE LINKAGE EDITOR.  DELINK0 was originally available\nonly in object code from IBM, but accurate disassembled assembly\nlanguage source is found on the CBT tape file 316, courtesy of the\nefforts of Bill Godfrey of Plannning Research Corporation in\nMaryland.\n\n      With credits now given, we ask:  what useful purpose can\nobject code have, that is better than load module format for\nexecutable code?  I have found several wonderful purposes for\nhaving object code.  They are:\n\n      A.  Isolating and re-installing \"nucleus-type SVC programs\" from\n           a copy of your nucleus.  Source for these currently running\n           SVCs may be long gone to the trash can, and the only way of\n           keeping these SVCs around, is on copies of your nucleus.\n           If you're doing a CBIPO, reinstalling these SVC's may be a\n           problem.  Also, having such critical programs buried inside\n           a big old nucleus doesn't give you too comfortable a\n           feeling about the stability of your shop.\n\n      B.  Backing out PTF maintenance that was ACCEPTed already with\n           SMP.  RESTOREing the PTF is not possible.  But creating an\n           APAR or USERMOD having good, but BACK-LEVEL object code to\n           APPLY in place of the ACCEPTED code, may be just what is\n           needed to keep your shop going, while keeping SMP happy.\n\n      C.  Just plain old packaging.  Object code fits neatly on a\n           source code PDS, while load modules have a \"funny format\".\n           Good old LRECL 80 may just suit your purposes better.\n\n      We shall talk about these nice roles for object code, and\nhow the DELINK0 program does the job of generating the object deck(s)\nyou need.  Somewhere down the line, these techniques could save your\nshop and your neck.\n\n      Obtaining a back-level CSECT (Case B above) is easier than\nisolating an SVC from the nucleus (Case A), so we'll talk about Case B\nfirst, while giving a true-to-life example.\n\n      Recently, I installed PSF release 1.2.1 (fmid HAF1220) software,\nto drive our 3800 model 3 printers.  Ultimately, I RECEIVEd, APPLYed,\nand ACCEPTed the base function, the cum tape PTFs, and all the HIPER\nPTFs mentioned in the PSP bucket at install time.  Good sound procedure?\nIt seemed OK.  IBM said all the PTFs were clean.\n\n      Well, not quite.  It turned out that one of the PTFs was PE (in\nerror) and it caused a critical problem with our print jobs.  Since\nthe module that had the error had been ACCEPTed, I couldn't RESTORE\nits PTF off my system using SMP.\n\n      I was undaunted.  Even though IBM hadn't come up with a fix as\nyet, I asked LEVEL 2 for the highest HEALTHY level of the offending\nmodule.  I figured that if ITS object code could be found inside of\na PTF, I could make my own USERMOD, TO LOOK LIKE A PTF and APPLY\nthat code to replace the bad module on my system.  IBM came back\nwith the answer that the BASE LEVEL OF THE MODULE was the highest\n(reasonably) healthy level.\n\n      NOW I had a problem.  The BASE LEVEL CODE is found only in LOAD\nMODULE FORMAT on the RELFILEs that came with the original shipment of\nthe product.  Luckily, they were still on my disk pack (although I\ncould easily load them up from the RELFILE tape if they had been gone\nfrom disk by now.  (You SMP-knowledgeable people, please note that I\nwas averse to making a separate TXLIB just to linkedit this piece of\ncode from LOAD MODULE format.)\n\n      So what are we leading up to?  USE DELINK0 to CONVERT THE LOAD\nMODULE on the RELFILE to OBJECT FORMAT.  Dump the resulting OBJECT\nDECK into a USERMOD.  Give the USERMOD a SYSMOD ID equal to the\nAPAR number of the problem, and PRE the PTF that was in error.  APPLY\nthe USERMOD, which fixes the system problem.  When IBM comes up with\nthe PTF to replace this module's code, THAT PTF should SUP our USERMOD's\nAPAR id number, and we'll be in the clear.  HO HO.  We've backed out\nan ACCEPTed sysmod (which IBM says you can't do).  See Example 1\nfor concreteness.  Needless to say, in our case, the technique worked\nout fine, and the printer purred along without coughing any more,\nhappily ever after (up to this writing).\n\n      Story number two.\n\n      This is a tale of \"saving the SVC code for re-install in a\nnew NUCLEUS\".  I might think that we should use DELINK0 as in the\nprevious case.  The problem is that DELINK0 doesn't have the capacity\nto take input from a load module as large (or anywhere nearly as large)\nas the nucleus module, IEANUC01, which is huge.  (A copy of) IEANUC01\nmust be cut down to size (very much) before DELINK0 will handle it.\n\n      What do we do?  We re-linkedit the COPY of IEANUC01 with many\nREPLACE linkedit control cards, to dummy out the unwanted CSECTs of\nthe NUCLEUS, which means most of them.  This will take a lot of\nREPLACE cards, and several linkedit runs, because the linkage editor\ncannot handle so many REPLACE cards at one time.  Eventually, we are\nleft with a piece of IEANUC01 that is a shadow of its former self, and\nwhich contains, basically only SVCs or any other CSECTs we would like\nto isolate.\n\n      THEN we use DELINK0, and lo and behold, it works.  (It really\nshould...)\n\n      NOW we have made object decks for each SVC, and we can\nconstruct USERMODs to re-install each one (Example 2).  The IPO\nand CBIPO literature have helpful material in their DOCLIB to show\nhow to install a user SVC in the nucleus.  After all the user SVCs in\nthe nucleus have been re-installed with SMP, the resulting NEW\nNUCLEUS is IPLed, and it should work as before.  At least in my case\nit did.  Just save the old nucleus in SYS1.NUCLEUS as an alternate;\nperhaps call it IEANUC02.  It could then be IPLed as alternate\nnucleus 2 in case of a problem.\n\n      So much for DELINK.  I promised you RELINK, and I'm obligated\nto deliver.\n\n      RELINK depends on a feature of the public-domain \"PDS\" product,\nwhich I urge everyone to acquire.  PDS is assembled from SOURCE.  Just\nsend Arnold Casinghino thirty dollars and a cartridge or 2400 foot\nreel, and you'll get the entire CBT tape.  PDS is on file 182, and\nnecessary utilities are on files 296 and 112.\n\n      Our concentration will be on the MAP subcommand of PDS.  MAP\noperates on LOAD MODULES ONLY.  The MAP subcommand WITHOUT OPERANDS,\nwill produce an AMBLIST-type CSECT MAP of a load module or GROUP OF\nLOAD MODULES.  This is very helpful in doing a DELINK of the module by\nshowing us the names of the component CSECTs to delink.\n\n      For the RELINK function, the amazing, unique MAP with RELINK\noperand is required.  A picture of an execution of PDS will illustrate\nthis best (see Example 4).  MAP with RELINK instantly GENERATES\nCOMPLETE, ACCURATE EXECUTABLE RELINKEIT JCL FOR ANY LOAD MODULE, or\nGROUP OF LOAD MODULES IN A LOAD LIBRARY, INCLUDING ALL ALIAS NAMES AND\nLOAD MODULE ATTRIBUTES.\n\n      I have used MAP with RELINK in several amazing ways:\n\n      A.  To reblock entire load libraries in a short time,\n            using the Linkage Editor itself.\n\n      B.  To relinkedit a load module from the separate CSECT\n            object modules created by DELINK0.\n\n      C.  To upgrade the linkage editing of old products.  For\n            example, I re-linkedited the 779 modules of the old\n            PL1 F compiler and library with the DFP linkage editor,\n            in less than an hour, on my first try.\n\n      Let's do another real-life example to illustrate Case A.\nA software vendor sent its load library to me blocked 6144, which\nI found inconvenient, because the short blocks made it difficult\nto apply many (necessary) zaps using \"Full Screen Zap\" (CBT tape\nfile 300).  I wanted nice large blocks of 18432 bytes.\n\n      First I tried the \"easy\" way of reblocking, with the DFP\nIEBCOPY's \"COPYMOD\" feature, using a MAXBLK of 18432.  A \"VERIFY\"\nrun under the PDS program, which gives a statistical breakdown of\nactual load module blocksizes, showed the maximum block length in the\nresulting new library as being less than 6900.  Apparently, COPYMOD\ndidn't really do the job.\n\n      The MAP subcommand of the PDS program solved the problem\nexcellently.  I ran the following sequence of PDS commands:\n\n        1.  VERIFY :      (colon means \"all members\".  This\n                           command makes sure there are no\n                           apparent aliases or orphaned members.\n                           It also produces the report on\n                           block sizes.)\n\n        2.  IF : NOALIAS THEN(SUBLIST)\n                          (This picks the \"current subgroup of\n                           members\" to be ONLY those load modules\n                           that are not ALIASES.)\n\n        3.  MAP * RELINK\n                          (asterisk means \"the current subgroup\n                           of members\".  At this point it has only\n                           main members.  This command generates\n                           re-linkedit JCL for the entire library.\n                           The ALIAS members will be re-generated\n                           because all of the proper ALIAS linkedit\n                           statements are included in the JCL.\n\n      I ran this sequence of commands in PDS's \"ISPMODE\" so the\noutput was written to the \"ISPMODE LOG\" that PDS has.  The log can\nbe written out to a dataset with one ISPF prompt (Option 7), and the\ndataset, when it is edited to remove the re-statement of the PDS\nsubcommands, is EXECUTABLE JCL.  Just adding a JOB card is enough to\nrun it.  It might also be necessary to change the name of the load\nlibrary pointed to by the SYSLMOD DD statements.\n\n      After I did this, the PDS VERIFY command showed a maximum\nblocksize of 18432, and an average blocksize of very close to that.\n\n      (Note that if you don't have ISPF but if you have the TSO\nSession Manager, the results of the commands will be in the OUTPUT\nSTREAM and will be accessible from there using SMCOPY to print to\na dataset.  \"PDS\" uses the TSO PUTLINE interface, so it can be run\nunder \"TSO IN BATCH\", with the output sent directly to a dataset.)\n\n      Case B.  This one is easy.  If you have a load module that has\nseveral CSECTS, use \"MAP modulname RELINK\" with \"PDS\" pointing to\nthe original load library.  This will generate the relinkedit JCL.\nSave the resulting JCL on a dataset (as above).  Then DELINK each\nCSECT using the DELINK0 program.  Put the resulting OBJECT DECKS in\na PDS using member names equal to each CSECT's name.  Then run the\nrelinkedit JCL, pointing the SYSLIB DD statement to that object\nlibrary.  Whew...  It didn't take long to knock that one off.\nSee Example 3 for an illustration.\n\n      Case C.  IBM used to give out its software for free (in the\nold MVT days).  The PL1 F Compiler and Library is now a public-domain\nproduct which can be found on older CBT tapes and on the SPLA MVS\ntape (Share Program Library Agency, TUCC, Research Triangle Park,\nNC 27709, or from DAN SQUILLACE of the SAS Institute, Cary, NC).\nThe load modules were all linkedited \"downward compatible\" or \"DC\",\nwhich places a restriction on their block sizes.  I wanted to do\ntwo things:  First, to add a unique SSI (System Status Indicator)\nto all of these load modules, for identification.  Second, to remove\nthe \"DC\" attribute so the relinkedited modules could have a larger\nblock size.\n\n      To do these two things, I used the \"PDS\" program and entered\nthe following commands:\n\n        1.  ATTRIB : NODC    (this removed the \"DC\" attribute\n                              from all 779 load modules.  The\n                              computer cranked for about a minute.)\n\n        2.  ATTRIB : SSI(CB272454)\n                             (give an SSI of CB272454 to all 779\n                              load modules.  This tells me that they\n                              came from the CBT tape version 272,\n                              file 454.  The computer cranked for\n                              a bit over two minutes.)\n\n      Then I did the three steps above and relinkedited all the\nmodules.  Including the editing of the job stream and computer\nexecution time, the whole thing took less than an hour, start to\nfinish.  This is pretty heady stuff, and it shows some of the\nenormous power of the \"PDS\" product, as well as of DELINK0.\n\n      It's time for me to sign off now, and leave it to you clever\npeople to get creative.  Good luck.\n\n\n       *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nEXAMPLE  1.        BACKING OFF AN \"ACCEPTED\" PTF.\n\n\n++APAR (AY19870)        /*    5665-27501-HAF1220-\n//AY19870  JOB 5665-31933-0,27501,MSGLEVEL=(1,1),CLASS=A     */  .\n++ VER (Z038)\n   FMID(HAF1220)\n   PRE  (UY31933)\n /*\n   PROBLEM DESCRIPTION(S):\n     OY19870 -\n       ****************************************************************\n       * USERS AFFECTED: NEWSWEEK, INCORPORATED. Mtn. Lakes, N.J.     *\n       ****************************************************************\n       * PROBLEM DESCRIPTION: This is a backoff of UY31933 back to    *\n       *                      HAF1220 base level of mod APSQDEQ.      *\n       ****************************************************************\n   COMMENTS:\n     NEWSWEEK FIX AS PER SUPPORT CENTER - PROBLEM #2X903 - 01/13/89.\n */.\n++ MOD   (APSQDEQ ) DISTLIB(AAPSMOD0)\n LEPARM (LET,LIST,NCAL,RENT,XREF) .\n\n        (Object deck goes here)\n\n  IDENTIFY APSQDEQ('HAF1220 AY19870')\n  SETSSI FAA19870\n\n\n       *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nEXAMPLE  2.          REINSTALLING AN SVC WITH SMP.\n\n\n++ USERMOD (NSVC243) .\n++ VER(Z038) FMID(NWUSER1)\n /*  DOCUMENTATION.  THIS USERMOD PUTS SVC 243, WHICH IS USED BY\n       JES2 EXIT1, INTO THE NUCLEUS.  THIS SVC ENABLES THE CLOSE OF\n       THE VIRTUAL PRINTER.\n\n       THIS IS A REINSTALL OF AN SVC THAT IS ALREADY ON THE SYSTEM.\n     INSTALLED:  S.GOLOB\n                 11/26/85  84.330\n                 NEWSWEEK, INC.\n */ .\n++MOD(IGC243) DISTLIB(NWDLIB01) LMOD(IEANUC01) .\n\n        (Object deck goes here.)\n\n   SETSSI   E2D70132\n   IDENTIFY IGC243('NSVC243 11/26/85')\n\n\n       *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nEXAMPLE  3.      DELINK OF A LOAD MODULE AND ITS RE-LINKEDIT.\n\n\n//TST2PP2T JOB (TS,2322),'TECH.SUPPORT',CLASS=M,NOTIFY=TSTBSSG,\n//        MSGLEVEL=(1,1),MSGCLASS=T TYPRUN=HOLD\n//*\n//DELINK  EXEC PGM=DELINK,REGION=2000K\n//STEPLIB  DD DISP=SHR,DSN=TST.TSO.CMDLIB\n//SYSPRINT DD SYSOUT=*\n//SYSLIB DD DISP=SHR,DSN=TSTBSSG.LOAD\n//SYSPUNCH DD DISP=SHR,DSN=TSTBSSG.A.OBJ(EXTRACT)\n//SYSIN   DD *\n EXTRACT EXTRACT\n//*\n//DELINK  EXEC PGM=DELINK,REGION=2000K\n//STEPLIB  DD DISP=SHR,DSN=TST.TSO.CMDLIB\n//SYSPRINT DD SYSOUT=*\n//SYSLIB DD DISP=SHR,DSN=TSTBSSG.LOAD\n//SYSPUNCH DD DISP=SHR,DSN=TSTBSSG.A.OBJ(RCON)\n//SYSIN   DD *\n EXTRACT RCON\n//*\n//DELINK  EXEC PGM=DELINK,REGION=2000K\n//STEPLIB  DD DISP=SHR,DSN=TST.TSO.CMDLIB\n//SYSPRINT DD SYSOUT=*\n//SYSLIB DD DISP=SHR,DSN=TSTBSSG.LOAD\n//SYSPUNCH DD DISP=SHR,DSN=TSTBSSG.A.OBJ(CONVRT)\n//SYSIN   DD *\n EXTRACT CONVRT\n//*\n//DELINK  EXEC PGM=DELINK,REGION=2000K\n//STEPLIB  DD DISP=SHR,DSN=TST.TSO.CMDLIB\n//SYSPRINT DD SYSOUT=*\n//SYSLIB DD DISP=SHR,DSN=TSTBSSG.LOAD\n//SYSPUNCH DD DISP=SHR,DSN=TSTBSSG.A.OBJ(SYNTAX)\n//SYSIN   DD *\n EXTRACT SYNTAX\n//*\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(1024,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=TSTBSSG.A.OBJ\n//SYSLMOD  DD  DISP=SHR,DSN=TSTBSSG.LOAD\n//SYSLIN   DD  *\n INCLUDE SYSLIB(EXTRACT)\n INCLUDE SYSLIB(RCON)\n INCLUDE SYSLIB(CONVRT)\n INCLUDE SYSLIB(SYNTAX)\n ORDER   EXTRACT,RCON,CONVRT,SYNTAX\n SETSSI  ABB88308\n ENTRY   EXTRACT\n NAME    EXTRACTZ(R)\n\n\n       *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nEXAMPLE  4.      ILLUSTRATION OF \"PDS\" MAP WITH RELINK.\n\n\n*** LOG TABLE OUTPUT ***     12.17.18 PM    FRIDAY    FEB  3, 1989\n\n- DSN=TSTBSSG.LOAD,VOL=SER=TSO001  MEM=UPPER\n>map upper relink\n\n** MAP      UPPER\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(1024,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=TSTBSSG.LOAD\n//SYSLMOD  DD  DISP=SHR,DSN=TSTBSSG.LOAD\n//SYSLIN   DD  *\n INCLUDE SYSLIB(UPPER)\n ORDER   UPPER\n ENTRY   UPPER\n NAME    UPPER(R)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL8905X1": {"ttr": 3848, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93!\\x0f\\x00\\x93!\\x0f\\x12\\x01\\x00\\xa8\\x00\\xa8\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "1993-07-29T12:01:00", "lines": 168, "newlines": 168, "modlines": 0, "user": "SBGCSC"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                      Extra Issue 1989 - A\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n\n\n      This small note is being presented as restitution for our\nreaders.  Our sample ISPF command table was missing from my March\narticle.  Much of the usefulness of that article was tied to the\nsample table, whose purpose was to make your ISPF session into a\nbetter workbench.\n\n      By the use of RECURSIVE INVOCATIONS OF ISPF FUNCTIONS ON THE\nSAME SCREEN (a feature which is practical with ISPF Version 2), you\nneed not disturb an ongoing edit in order to allocate a file you\nneed.  If a command (for example, DATaset) has been included in the\nactive command table for your session, all that has to be done is to\ninvoke the \"DAT\" command from your command line, and press ENTER.\nThis calls the ISPF 3.2 (dataset allocation, rename, and delete)\npanel ON TOP OF YOUR EDIT PANEL.  When the allocation is done,\nending that panel gets you back into the edit, where you were.  The\nsame is true for other ISPF functions that are INVOKED BY COMMANDS\nIN THE ISPF COMMAND TABLE.\n\n      Recursive invocations of ANY ISPF FUNCTIONS can be set up by\nentries in the ISPF command tables.  Our March article showed how\nthese entries are created.  If you follow our sample table and expand\non it, you will add much power to your ISPF session.\n\n      It is possible to RUN MANY ISPF FUNCTIONS AT THE SAME TIME by\ntaking advantage of the recursive ISPF invocations.  COMMANDS CAN\nDUPLICATE ANY FUNCTION WHICH IS SELECTABLE FROM A PANEL.  Our\ntechnique is TO MAKE COMMANDS to invoke frequently used PANELS\ndirectly, on top of the current screen.  This has the advantage that\nupon END from the invoked panel, you're still in the screen that was\nbeing used before.\n\n      How do we do this?  A command table is a PDS member allocated\nto the ddname ISPTLIB or the ddname ISPTABL.  ISPTLIB is used for\noutput, and ISPTABL is used for input, so if you plan to update a\ntable, it must be in a library allocated to ISPTABL.  Command table\nnames adhere to the convention \"applid\"+CMDS.  In other words, the\nname of the command table member is the name of the applid suffixed\nby the string \"CMDS\".  ISPF option 3.9 is used for editing command\ntables.  It assumes that your desired table is in a PDS allocated to\nddname ISPTABL, and that it IS NOT CURRENTLY BEING USED by any\nsession.  Therefore, you must update a COPY of the real table, and\nnot one that is in use.\n\n      The ISPF 3.9 entry panel asks for the name of the command table\nmember, minus the \"CMDS\" suffix.  The normal default ISPF command\ntable members are called ISPCMDS and ISRCMDS, which we cannot edit\ndirectly, so let's assume we have made copies of them in an ISPTABL\nlibrary, called XSPCMDS and XSRCMDS.  To edit XSPCMDS, we enter XSP\non the ISPF 3.9 entry panel screen, and we proceed to add or change\nentries to the table.  After the table is saved by using the END key,\nwe can replace the ISPCMDS member by the XSPCMDS member, get out of\nISPF entirely, and then back into ISPF.  The new entries should now\nbe effective on our ISPF session.\n\n      A lot of people know about ISPF command tables, so why are we\nwriting about them here?  The suggestion is as follows:  Take ALL\nTHE ISPF 3.x UTILITY FUNCTIONS and make COMMANDS to execute them\nON TOP OF WHAT WE'RE DOING NOW.  Then you can do a dataset allocation\nor a dataset list or a SUPERC, or even a command table edit, and not\nlose your current screen which contains the work you're doing.\n\n      Here are more hints on how to make the table entries.\n\n      Use the SELECT statements in the PROC section of your ISRUTIL\n(ISPF 3) panel, to determine the correct statements to put into the\ncommand table for the 3.x functions.  Panels are allocated to the\nddname ISPPLIB in your session.  This info should be of help in\nlocating your current panel whose name is ISRUTIL.  Just write the word\nSELECT, and copy the select statements exactly, without the quotes,\njust as they appear in the ISRUTIL panel.  You can alternatively copy\nthe entries from my sample table additions (which are for ISPF v2.3).\nPlease be aware that the utility invocations for ISPF v2.2 may be\nslightly different from mine.\n\n      Here's another hint in the process of exploring for commands:\nThe name of the panel currently being used can be displayed by\nentering the command PANELID on the command line.  The actual name of\nthe panel will be displayed in the upper left corner of the screen.\nPANELID OFF turns the panel name display off.\n\n      COMMANDS CAN BE MADE TO SELECT ANY SCREEN.  I've included our\nsample of some command table additions I've made.  Anyone can get\nvery creative with this, and really ease the burdens in his everyday\nwork.  Further assistance can be obtained from the IBM ISPF manuals.\n\n      One should create a TSO HELP member called \"CMDTABLE\", which\nkeeps the names of the extra commands handy in case you forget them.\nTo get really fancy, the help can be in the form of a new panel that\nis selected by a new command in the command table.\n\n      Good luck with your own command table additions, and we hope you\ncan make use of our sample table.  The included sample has extra hints\nand tips embedded right within it.  Please examine it carefully.\n\n     *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFIGURE 1.          SAMPLE EXTENSIONS TO THE ISPF COMMAND TABLE\n\n\nCOMMAND TABLE - XSRCMDS --------------------------------------  ROW 1 OF 52\nCOMMAND ===>                                               SCROLL ===> CSR\n\nINSERT, DELETE, AND CHANGE COMMAND ENTRIES. UNDERSCORES NEED NOT BE BLANKED.\nENTER END COMMAND TO SAVE CHANGES OR CANCEL TO END WITHOUT SAVING.\n\n(Author's note. T stands for command truncation, number of chars valid)\n                0 means that the command cannot be shortened.\n\n     VERB      T  ACTION\n                     DESCRIPTION\n\n'''' ISPPREP   0  SELECT PGM(ISPPREP) NEWAPPL\n                     INVOKING PREPROCESSED PANEL UTILITY IN INTERACTIVE\n'''' PDF       0  SELECT PANEL(ISR@PRIM)\n                     NEW PRIMARY LAYER OF ISPF\n'''' LIBRARY   3  SELECT PGM(ISRUDA) PARM(ISRUDA1)\n                     ISPF 3.1  LIBRARY UTILITY\n'''' DATASET   3  SELECT PGM(ISRUDA) PARM(ISRUDA2)\n                     ISPF 3.2  DATASET UTILITY\n'''' CPYLIBS   3  SELECT PGM(ISRUMC)\n                     ISPF 3.3  COPY UTILITY\n'''' DSLIST    3  SELECT PGM(ISRUDL) PARM(ISRUDLP)\n                     ISPF 3.4  DATASET LIST UTILITY\n'''' SPFSTATS  4  SELECT PGM(ISRURS)\n                     ISPF 3.5  ISPF STATS PANEL\n'''' HRDCOPY   3  SELECT PGM(ISRUHC)\n                     ISPF 3.6  HARDCOPY OUTPUT PANEL\n'''' OUTLIST   4  SELECT PGM(ISRUOLP)\n                     ISPF 3.8  OUTPUT LIST PANEL\n'''' CMEDIT    3  SELECT PANEL(ISPUCMA)\n                     ISPF 3.9  COMMAND TABLE EDIT FACILITY\n'''' CNVERT    3  SELECT PGM(ISRQCM) PARM(ISRQCMP)\n                     ISPF 3.10  CONVERT OLD FORMAT MENUS AND PANELS\n'''' FRMATDEF  3  SELECT PGM(ISRFMT)\n                     ISPF 3.11  FORMAT DEFN FOR FORMATTED DATA ED/BRWSE\n'''' SUPERC    4  SELECT PGM(ISRSSM)\n                     ISPF 3.12  SUPERC COMPARE UTILITY\n'''' SUPDETAL  4  SELECT PGM(ISRSEPRM) NOCHECK\n                     ISPF 3.13  DETAILED SUPERC COMPARE\n'''' SRCHFOR   4  SELECT PGM(ISRSFM)\n                     ISPF 3.14  SEARCH FOR - ISPF UTILITY\n'''' TSOP      0  SELECT PGM(ISRPTC)\n                     ISPF 6     INVOKE TSO OPTION 6 PANEL RECURSIVELY\n'''' CN        0  SELECT CMD(CN)\n                     INVOKE CONSOLE SIMULATOR FROM FILE 25 - CBT TAPE\n'''' PDSD      0  SELECT PGM(PDS83) PARM(PDS83 &ZPARM ISPMODE)\n                     INVOKE PDS VERSION 8.3 RECURSIVELY - CBT FILE 182\n'''' SECURE    3  SELECT PGM(SECURE)\n                     TSO COMMAND TO PREVENT ACCESS TO THIS TERMINAL\n'''' Z1        0  SELECT PGM(ZAP)\n                     FULL SCREEN ZAP PROGRAM FROM FILE 300 - CBT TAPE\n'''' TMSINQ    3  SELECT CMD(%TMSALOC) NEWAPPL(U01)\n                     TMS (CA-1) TAPE MGMT SYSTEM - ISPF INQUIRY/UPDATE\n'''' ASIDSE2   3  SELECT PGM(ASIDSE2)\n                     DISPLAY ADDRESS SPACE DATA FOR ACTIVE ADDR SPACES\n'''' COMPAR    0  SELECT PANEL(COMPR#P)\n                     COMPARE WITH YALE COMPARE PGM - EXTENDED\n'''' SYNCSORT  4  SELECT PANEL(OLSPOLS) NEWAPPL(OLSD)\n                     SYNCSORT RELEASE 3.2 ONLINE INTERFACE\n'''' PANVALET  3  SELECT PGM(PLF3)\n                     PANVALET ISPF FULL-SCREEN INTERFACE - CBT FILE 353\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL8906JN": {"ttr": 4097, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93!\\x0f\\x00\\x93!\\x0f\\x12\\x01\\x02\\x12\\x02\\x12\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "1993-07-29T12:01:00", "lines": 530, "newlines": 530, "modlines": 0, "user": "SBGCSC"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           June 1989\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n\n\n            RETRIEVING MATERIAL FROM IBM'S SOURCE TAPES\n\n\n      This monthly column is for sharing practical advice and\ntechniques which can be employed in your shop.  We hope to provide\nstimulating discussion and help to as large a group of MVS systems\nprogrammers as possible.\n\n      As many of you already know, this column depends largely on\nyou, the reading public, for contributions and ideas.  We greatly\nappreciate calls and messages from interested readers who will ask\nme to write about some favorite trick or method of theirs.  Just\nsend a message on NASCOM to Shari Matzner (id SUPERZAP), or write a\nnote to me care of the magazine.  Please include your phone number.\n\n      A quick word about software tools.  This column is task oriented.\nIn other words, the idea is to learn how to get a job done.  Whatever\nsoftware tool will work, is fine.  We have tried, however, to make\nall of the techniques as accessible to as many people as possible,\nREGARDLESS OF BUDGET.  For this reason, we refer to the many quality\npublic-domain offerings available on the Connecticut Bank and Trust\nMVS Tape (known as the CBT Tape) and the NaSPA V.I.P. MVS tapes.\n\n      To obtain a CBT tape (which contains HUNDREDS of software\npackages), call Arnold Casinghino, (203) 244-5495.\n\n      Our topic this month concerns an uncommon MVS skill, a method\nof EASILY RETRIEVING MATERIAL FROM IBM's \"SYMBOLIC\" OPTIONAL MATERIAL\nSOURCE TAPES.\n\n      Many shops keep these tapes in boxes, stuffed into some\nout-of-the-way corner.  It may surprise you, that you can actually\nASSEMBLE AND LINKEDIT BASE VERSIONS OF IBM CODE on five or ten\nminutes' notice, if these tapes have been set up properly.  I know.\nI do it all the time.  The paper copies or on-line material provided\nby these assemblies or source listings are much easier to follow than\nfiche (and paper can be taken to places where you don't have a fiche\nreader).  They can often provide research information that is much\nmore detailed than what can be found in any manual.  Of course, source\nis usually only provided at THE BASE LEVEL OF A SOFTWARE RELEASE.  For\nthe higher levels, you have to refer to fiche, but often the logic is\ncompletely apparent from the provided machine-readable source.\n\n      So how can we get started?\n\n      Our first objective is to find out WHERE THE SOURCE CODE FOR\nA GIVEN MODULE IS.  A secondary related question is:  if there are\nseveral levels of a product, are we pulling the source FROM THE BEST\nLEVEL FOR OUR SYSTEM?\n\n      After we get the source at the proper level, the second\nquestion is:  CAN WE ACTUALLY ASSEMBLE THIS SOURCE TO OBTAIN A\nLISTING OR A LOAD MODULE?\n\n      The rest of the way, we shall show how to prepare your source\ntapes for easy retrievability.  Documentation for the entire system\ncan be found on files 188 and 189 of the CBT tape.\n\n      FACT.  IBM source tapes are NON-LABELED tapes, whose\ncard-image files are unloaded in IEBUPDTE SYSIN FORMAT on one or\nmany tape files.  The tape files usually have a block size of 12000.\n\n      Since the tapes are non-labeled, IT IS POSSIBLE TO ASSIGN AN\nARBITRARY 6-CHARACTER VOLSER TO EACH TAPE.  This can be done (in good\nconscience) with paper labels, once you've decided on a labeling\nscheme that suits you.  IT IS NOT NECESSARY TO HAVE \"GOOD NAMES\".\nANY UNIQUE NAME ON EACH TAPE WILL BE FINE.\n\n      We now need two software tools from the CBT tape.  The first\nand most important is the TAPEMAP program on file 299.  The second\n(believe it or not) is the CBT tape's own compress-decompress program\ncalled \"CBT973\" whose source is on file 2.  You should assemble and\nlinkedit these programs in your shop.\n\n      It is very preferable (though not entirely necessary) to use\na version of TAPEMAP from a very recent CBT tape (version 299 or\nhigher), because that version can read a CBT-compressed file in\nIEBUPDTE SYSIN format directly, and REPORT ALL THE MEMBER NAMES of\nthe unloaded AND COMPRESSED members.\n\n      TAPEMAP reads a tape and produces two reports.  The first\nreport does what most tape mapping utilities do, and a little more.\nIt shows block sizes and block counts from scanning (and optionally\nfrom tape labels).  It has very accurate footage counts for all the\nfiles, if it obtained them from scanning.  In addition, TAPEMAP\nrecognizes tape files IN ABOUT TEN STANDARD UNLOAD FORMATS, and\nIT REPORTS ANY FORMAT IT RECOGNIZES (e.g. IEBCOPY, IEBUPDTE,\nSMPPTFIN, or even CBT973 in the most recent incarnation).  This\nspecial unload format information appears in report one, on the left\nside next to the name and description of the file.\n\n      TAPEMAP's REPORT TWO is special.  If TAPEMAP recognized a\nspecial-format file, such as IEBUPDTE or IEBCOPY, the NAMES OF ALL\nITS MEMBERS ARE SHOWN IN THIS REPORT.  Remember that IBM's source\ntape files are all in IEBUPDTE unload format, so that TAPEMAP's\nREPORT TWO WILL LIST ALL THE NAMES OF THE UNLOADED MEMBERS.  This\nwill be the key to finding WHICH FILE(S) ON WHICH TAPE(S) CONTAIN\nTHE SOURCE MEMBERS YOU ARE LOOKING FOR.\n\n      It only remains to find a way of placing the TAPEMAP reports\nfrom each source tape in a file or a PDS so that access to member\nnames and file numbers will be easy and convenient.  Once the location\nof your source is determined, a standard tape-load job will load\na partitioned dataset with your source from the appropriate tape file.\nHow should we proceed?\n\n      A bing-bang-boom quick solution is provided by the extremely\nversatile \"PDS Program Product, version 8.x\" that is on file 182\nof the CBT tape.  Once \"PDS\" is available, with its global (over\nan entire partitioned dataset) FIND capability for search strings,\ninstant access to member names becomes a reality.\n\n      I do as follows.  I label all my source tapes.  Then I use\ncanned JCL in the form of repeated executions of a PROC (see figure\none) to TAPEMAP each tape.  I run the two outputs into two members of\na \"tapemap PDS\", LRECL 133, that contains only TAPEMAP reports.  I\nthen execute the \"PDS\" program product against the library of TAPEMAP\nreports, and use the FIND command to get all occurrences of the module\nname I want to find.  If there is more than one occurrence, I need\nmerely decide which tape better reflects my current level of the\nmodule.  Then, knowing the location of the module, I load it from\nthe correct tape, down to disk.\n\n      You can go this far, and get a big improvement over the previous\nsituation (of not using the source at all).  This much organization is\nadequate for most people, if the source tapes can be strategically\nplaced somewhere near the computer room, where you or the operators\ncan get to them.  In my shop, I had to go one step further.\n\n      Our problem was limited shelf space in the computer room.\nBoxes of sixty-or-so various-sized out-of-house tapes was far too\nconfusing for our operators to handle.  The fact that the tapes were\nnon-labeled made the situation completely impossible to manage\nwithout my personal intervention.  I wanted to be able to load\nsource down when I was dialed in from home.\n\n      Here was my big idea.  Wait.  The IBM tapes are in IEBUPDTE\nSYSIN format.  The CBT tape is in IEBUPDTE SYSIN format too, but is\nfurther compressed by the CBT973 program.  Why not carefully compress\nmany source tapes onto a few large super-reels to keep in the\ncomputer room.  Let them be standard-labeled with revealing file\nnames.  Then a slightly more complicated disk-load job would perform\nthe function that I desire, and the operators would be able to handle\nit for me at a distance.\n\n      Careful planning would be necessary.  The first step, as before,\nwas to assign volume serial designations and put paper labels on all\nthe tapes, then TAPEMAP them all.  The process stows the two reports\nas two members of the \"map partitioned dataset\" for each tape read.\nThen we use the footage counts from all the \"report one\" listings to\nplan which tapes can fit on the larger tapes to fill them up.  My\nrough experience was that the compressed files occupied about 60\npercent of the footage that the uncompressed ones did.  Then, the\nindividual compress-combine jobs had to be laid out for each big\ntape.  This was tedious.  See figure two for an example.  The planned\nlarger tapes were INITted, and the \"combine\" jobs were run carefully,\nunder my supervision.  Since the original IBM tapes are unlabelled,\nmounting the wrong source tape at this stage would mess the process\nup.\n\n      Once the large tapes have been created, the new version of\nTAPEMAP, which can read CBT973-compressed IEBUPDTE files and report\nmember names, is used to map the larger tapes and add their reports\nto the \"map partitioned dataset\".  Then, once a member is found on\na large tape, a reload job (figure three) is run to load the correct\nfile to disk.\n\n      This is my system.  At this point, we are capable of loading\nany of our source to disk in a short time.\n\n      But I promised you ASSEMBLIES.\n\n      For that, you have to know where to get the IBM Internal\nASSEMBLER MACROS.\n\n      IBM code often uses the normal system macros in SYS1.MACLIB\nand SYS1.AMODGEN.  However, each of their program products may have\nits own \"pet collection\" of macros to make coding easier for the\ndevelopers.  IBM source-maintained program products such as JES2,\nJES3, and CICS have their own macros in distribution libraries, such\nas SYS1.HASPSRC, SYS1.JES3MAC, and CICS.MACLIB.  Other object-oriented\nprogram products have what is called \"private macro libraries\" or\nPVTMACS, that are contained in the symbolic machine-readable optional\nmaterial source tapes we are talking about.\n\n      Usually the private macros from one program product are found\non a single separate file of the optional materials tape for that\nproduct.  You can sometimes spot the PVTMACS file from a TAPEMAP\n\"report two\" listing by the diversity of member names in the one\nfile.  Source modules in one file usually have names that are similar\nto each other.  Macros in one file usually don't.\n\n      If you have access to any of IBM's printed material describing\nthe contents of their \"optional materials\" tapes (this is usually in\nthe program directory), the component designation \"AAPVT\" denotes\na \"private macro\" library for a product.\n\n      Look at the TAPEMAP \"report two\" listings for all your tapes\nand see if you can spot all the private macro libraries.  You can\nthen combine them all (if there are no common members) into a large\nmacro library you can call SYS1.PVTMACS.  You may need more than one\nsuch library because of source material at various product levels,\nsuch as VTAM 2.1 and VTAM 2.2.  Just make sure the concatenation\nsequence during assembly is \"latest level first\", or whatever is\nappropriate for the circumstances.\n\n      By saving the \"private macro\" libraries online, and by loading\nindividual source modules to disk as needed, the objective of doing\nquick assemblies of IBM source code can often be achieved.  See\nfigure four for an example of such an assembly.\n\n      I would like to close by mentioning the existence of a fine\nproduct which is very interesting to use.  This is the SLAC (Stanford\nLinear ACcelerator) version of Assembler H version 2.  Of course,\nyour site must be licensed for Assembler H version 2 to run the\nSLAC assembler.  The SLAC assembler is about a one-fifth rewrite\nof IBM's assembler H version 2, and is functionally stabilized at\nabout a 1984 or 1985 PUT Level.  It has many additional features\nwhich are fun to use, among which is a complete report of WHERE\nEVERY MACRO CAME FROM, or EVEN IF IT IS MISSING.  There are many\nmany other helpful features.  I feel bad that IBM did not adopt\nmost of them (yet).  I run the SLAC assembler in my shop, calling\nit by the program name AEV90.\n\n      It is not too easy to obtain the SLAC assembler, but anyone\nwho is really interested can contact me through the magazine, and\nif you're persistent, I'll try to direct you so you can get a copy.\n\n      Good luck with all of this.  See you next month.\n\n\n\n    *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n  FIGURE ONE.\n\n\n\n//TSTBFP2M JOB (TS,2322),'TECH.SUPP-SAM.GOLOB',CLASS=M,NOTIFY=TSTBSSG,\n//        MSGLEVEL=(1,1),MSGCLASS=T TYPRUN=HOLD\n//*\n//****************************************************************\n//*                                                              *\n//*      OUTPUT OF TAPEMAP PROGRAM SENT TO TST.SYMTAPE.MAPS      *\n//*                                                              *\n//****************************************************************\n//TAPEMAP PROC VOL=XXXXXX,M='M',DRIVE=TAPE\n//TAKEMAP EXEC PGM=TAPEMAP\n//STEPLIB  DD  DSN=TST.TSO.CMDLIB,DISP=SHR\n//SYSPRINT DD  DSN=&&TMP,DISP=(NEW,PASS,DELETE),UNIT=SYSDA,\n//         SPACE=(CYL,(3,3)),DCB=(RECFM=FBA,LRECL=133,BLKSIZE=3059)\n//SYSPRNT2 DD  DSN=&&TMP1,DISP=(NEW,PASS,DELETE),UNIT=SYSDA,\n//         SPACE=(CYL,(3,3)),DCB=(RECFM=FBA,LRECL=133,BLKSIZE=3059)\n//SYSUT1   DD  UNIT=&DRIVE,VOL=(PRIVATE,,,,SER=(&VOL)),\n//             DISP=SHR,LABEL=(,BLP,EXPDT=98000)\n//COPYMAP EXEC PGM=DSCOPY\n//SYSPRINT DD  SYSOUT=*\n//IN1      DD  DISP=(OLD,DELETE),DSN=&&TMP\n//IN2      DD  DISP=(OLD,DELETE),DSN=&&TMP1\n//OUT1     DD  DISP=SHR,DSN=TST.SYMTAPE.MAPS(&VOL)\n//OUT2     DD  DISP=SHR,DSN=TST.SYMTAPE.MAPS(&VOL&M)\n//  PEND\n//MAP001  EXEC TAPEMAP,VOL=DFP110\n//MAP002  EXEC TAPEMAP,VOL=DFP111\n//MAP003  EXEC TAPEMAP,VOL=DFP112\n//MAP004  EXEC TAPEMAP,VOL=DFP210\n\n\n    *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n  FIGURE TWO.\n\n\n\n//TSTBCP2S JOB (TS,2322),'TECH.SUPP-SAM.GOLOB',CLASS=M,NOTIFY=TSTBSSG,\n//        MSGLEVEL=(1,1),MSGCLASS=T TYPRUN=HOLD\n//*\n//******************************************************************//\n//*   COMPRESS IBM SYMLIB - SOURCE TAPES - USING THE CBT973\n//*     DATA COMPRESSION PROGRAM, AFTER THE MANNER OF THE\n//*     CBT MVS MODS TAPES.\n//******************************************************************//\n//*\n//* CBTSYM1              JOB  DESIGNED TO OUTPUT TO 2400 FT REEL.\n//* CBTSYM2 THRU CBTSYM6 JOBS DESIGNED TO OUTPUT TO 3600 FT REEL.\n//*\n//*\n//CONDENSE PROC LI=01,VI=SYM,LO=01,VO=NSY001,TAP=011,SRC=MVSIPO,\n//     T01=482,T02=483\n//COPYIN  EXEC PGM=DSCOPY\n//SYSPRINT DD  SYSOUT=*\n//IN       DD  DSN=SYMLIB.FIL,DISP=(SHR,PASS),UNIT=&T01,\n//    LABEL=(&LI,NL,EXPDT=98000),VOL=(,RETAIN,,,SER=&VI&TAP),\n//    DCB=(RECFM=FB,LRECL=80,BLKSIZE=12000)\n//OUT      DD  DSN=&TMP&LO,DISP=(NEW,KEEP,DELETE),UNIT=3380,\n//      VOL=SER=WORK02,DCB=*.IN,SPACE=(TRK,(90,90),RLSE)\n//*\n//COMPRES EXEC PGM=CBT973,PARM=COMPRESS\n//INPUT   DD  DSN=&TMP&LO,DISP=(OLD,DELETE)\n//OUTPUT  DD  DSN=&SRC..&VI&TAP..F&LI,DISP=(NEW,KEEP,DELETE),\n//     UNIT=&T02,LABEL=(&LO,SL,EXPDT=98000),\n//     VOL=(,RETAIN,SER=&VO),\n//     DCB=(DEN=4,RECFM=VB,LRECL=94,BLKSIZE=32716)\n//   PEND\n//*\n//ALLOC1  EXEC PGM=IEFBR14\n//DD3     DD  DSN=TST.MAP1.TEMP,DISP=(NEW,KEEP,DELETE),UNIT=3380,\n//   VOL=SER=WORK02,DCB=(RECFM=FBA,LRECL=133,BLKSIZE=3059,DSORG=PS),\n//   SPACE=(TRK,(30,30))\n//*\n//*\n//MERGE1 EXEC PGM=DSCOPY\n//SYSPRINT DD SYSOUT=*\n//IN01   DD DISP=SHR,DSN=TST.SYMTAPE.MAPS(SYM011)\n//       DD DISP=SHR,DSN=TST.SYMTAPE.MAPS(SYM012)\n//       DD DISP=SHR,DSN=TST.SYMTAPE.MAPS(SYM013)\n//       DD DISP=SHR,DSN=TST.SYMTAPE.MAPS(SYM014)\n//       DD DISP=SHR,DSN=TST.SYMTAPE.MAPS(SYM011M)\n//       DD DISP=SHR,DSN=TST.SYMTAPE.MAPS(SYM012M)\n//       DD DISP=SHR,DSN=TST.SYMTAPE.MAPS(SYM013M)\n//       DD DISP=SHR,DSN=TST.SYMTAPE.MAPS(SYM014M)\n//OUT01  DD DISP=OLD,DSN=TST.MAP1.TEMP,UNIT=3380,VOL=SER=WORK02\n//*\n//TAPEC1 EXEC PGM=DSCOPY\n//SYSPRINT DD SYSOUT=*\n//IN02   DD DISP=OLD,DSN=TST.MAP1.TEMP,UNIT=3380,VOL=SER=WORK02\n//OUT02  DD DSN=B.INFO.ABOUT.TAPE,DISP=(NEW,KEEP,DELETE),UNIT=483,\n//    DCB=(RECFM=VBA,LRECL=137,BLKSIZE=32747),\n//    VOL=(PRIVATE,RETAIN,SER=NSY001),LABEL=(01,SL,EXPDT=98000)\n//*\n//ALLOC2  EXEC PGM=IEFBR14\n//DD3     DD  DSN=TST.MAP1.TEMP,DISP=(OLD,DELETE),UNIT=3380,\n//   VOL=SER=WORK02\n//*\n//*\n//C001  EXEC CONDENSE,TAP=011,VO=NSY001,LI=01,LO=02\n//C002  EXEC CONDENSE,TAP=011,VO=NSY001,LI=02,LO=03\n//C003  EXEC CONDENSE,TAP=011,VO=NSY001,LI=03,LO=04\n//C004  EXEC CONDENSE,TAP=011,VO=NSY001,LI=04,LO=05\n//C005  EXEC CONDENSE,TAP=011,VO=NSY001,LI=05,LO=06\n//C006  EXEC CONDENSE,TAP=011,VO=NSY001,LI=06,LO=07\n//C007  EXEC CONDENSE,TAP=011,VO=NSY001,LI=07,LO=08\n//C008  EXEC CONDENSE,TAP=011,VO=NSY001,LI=08,LO=09\n//C009  EXEC CONDENSE,TAP=011,VO=NSY001,LI=09,LO=10\n//C010  EXEC CONDENSE,TAP=011,VO=NSY001,LI=10,LO=11\n//C011  EXEC CONDENSE,TAP=011,VO=NSY001,LI=11,LO=12\n//C012  EXEC CONDENSE,TAP=011,VO=NSY001,LI=12,LO=13\n//C013  EXEC CONDENSE,TAP=011,VO=NSY001,LI=13,LO=14\n//C014  EXEC CONDENSE,TAP=011,VO=NSY001,LI=14,LO=15\n//C015  EXEC CONDENSE,TAP=011,VO=NSY001,LI=15,LO=16\n//C016  EXEC CONDENSE,TAP=011,VO=NSY001,LI=16,LO=17\n//C017  EXEC CONDENSE,TAP=011,VO=NSY001,LI=17,LO=18\n//C018  EXEC CONDENSE,TAP=011,VO=NSY001,LI=18,LO=19\n//C019  EXEC CONDENSE,TAP=011,VO=NSY001,LI=19,LO=20\n//C020  EXEC CONDENSE,TAP=011,VO=NSY001,LI=20,LO=21\n//C021  EXEC CONDENSE,TAP=012,VO=NSY001,LI=01,LO=22\n//C022  EXEC CONDENSE,TAP=012,VO=NSY001,LI=02,LO=23\n//C023  EXEC CONDENSE,TAP=012,VO=NSY001,LI=03,LO=24\n//C024  EXEC CONDENSE,TAP=012,VO=NSY001,LI=04,LO=25\n//C025  EXEC CONDENSE,TAP=012,VO=NSY001,LI=05,LO=26\n//C026  EXEC CONDENSE,TAP=012,VO=NSY001,LI=06,LO=27\n//C027  EXEC CONDENSE,TAP=012,VO=NSY001,LI=07,LO=28\n//C028  EXEC CONDENSE,TAP=012,VO=NSY001,LI=08,LO=29\n//C029  EXEC CONDENSE,TAP=012,VO=NSY001,LI=09,LO=30\n//C030  EXEC CONDENSE,TAP=012,VO=NSY001,LI=10,LO=31\n//C031  EXEC CONDENSE,TAP=012,VO=NSY001,LI=11,LO=32\n//C032  EXEC CONDENSE,TAP=012,VO=NSY001,LI=12,LO=33\n//C033  EXEC CONDENSE,TAP=012,VO=NSY001,LI=13,LO=34\n//C034  EXEC CONDENSE,TAP=012,VO=NSY001,LI=14,LO=35\n//C035  EXEC CONDENSE,TAP=012,VO=NSY001,LI=15,LO=36\n//C036  EXEC CONDENSE,TAP=012,VO=NSY001,LI=16,LO=37\n//C037  EXEC CONDENSE,TAP=012,VO=NSY001,LI=17,LO=38\n//C038  EXEC CONDENSE,TAP=012,VO=NSY001,LI=18,LO=39\n//C039  EXEC CONDENSE,TAP=012,VO=NSY001,LI=19,LO=40\n//C040  EXEC CONDENSE,TAP=013,VO=NSY001,LI=01,LO=41\n//C041  EXEC CONDENSE,TAP=013,VO=NSY001,LI=02,LO=42\n//C042  EXEC CONDENSE,TAP=013,VO=NSY001,LI=03,LO=43\n//C043  EXEC CONDENSE,TAP=013,VO=NSY001,LI=04,LO=44\n//C044  EXEC CONDENSE,TAP=013,VO=NSY001,LI=05,LO=45\n//C045  EXEC CONDENSE,TAP=013,VO=NSY001,LI=06,LO=46\n//C046  EXEC CONDENSE,TAP=013,VO=NSY001,LI=07,LO=47\n//C047  EXEC CONDENSE,TAP=013,VO=NSY001,LI=08,LO=48\n//C048  EXEC CONDENSE,TAP=013,VO=NSY001,LI=09,LO=49\n//C049  EXEC CONDENSE,TAP=013,VO=NSY001,LI=10,LO=50\n//C050  EXEC CONDENSE,TAP=013,VO=NSY001,LI=11,LO=51\n//C051  EXEC CONDENSE,TAP=013,VO=NSY001,LI=12,LO=52\n//C052  EXEC CONDENSE,TAP=013,VO=NSY001,LI=13,LO=53\n//C053  EXEC CONDENSE,TAP=013,VO=NSY001,LI=14,LO=54\n//C054  EXEC CONDENSE,TAP=013,VO=NSY001,LI=15,LO=55\n//C055  EXEC CONDENSE,TAP=013,VO=NSY001,LI=16,LO=56\n//C056  EXEC CONDENSE,TAP=013,VO=NSY001,LI=17,LO=57\n//C057  EXEC CONDENSE,TAP=013,VO=NSY001,LI=18,LO=58\n//C058  EXEC CONDENSE,TAP=013,VO=NSY001,LI=19,LO=59\n//C059  EXEC CONDENSE,TAP=013,VO=NSY001,LI=20,LO=60\n//C060  EXEC CONDENSE,TAP=014,VO=NSY001,LI=01,LO=61\n//C061  EXEC CONDENSE,TAP=014,VO=NSY001,LI=02,LO=62\n//C062  EXEC CONDENSE,TAP=014,VO=NSY001,LI=03,LO=63\n//C063  EXEC CONDENSE,TAP=014,VO=NSY001,LI=04,LO=64\n//C064  EXEC CONDENSE,TAP=014,VO=NSY001,LI=05,LO=65\n//C065  EXEC CONDENSE,TAP=014,VO=NSY001,LI=06,LO=66\n//C066  EXEC CONDENSE,TAP=014,VO=NSY001,LI=07,LO=67\n//C067  EXEC CONDENSE,TAP=014,VO=NSY001,LI=08,LO=68\n//C068  EXEC CONDENSE,TAP=014,VO=NSY001,LI=09,LO=69\n//*\n//TESTA   EXEC PGM=TAPEMAP\n//SYSPRINT DD  SYSOUT=*\n//SYSPRNT2 DD  SYSOUT=*\n//SYSUT1   DD  UNIT=483,VOL=(PRIVATE,RETAIN,,,SER=(NSY001)),\n//             DISP=SHR,LABEL=(,BLP,EXPDT=98000)\n//*\n\n\n    *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n  FIGURE THREE.\n\n\n\n//TSTBSP2U JOB (TS,2322),'TECH.SUPP-SAM.GOLOB',CLASS=M,NOTIFY=TSTBSSG,\n//        MSGLEVEL=(1,1),MSGCLASS=T TYPRUN=HOLD\n//*\n//******************************************************************//\n//*  UNLOAD SYMLIB FILE FROM CBT973-COMPRESSED SL SYMLIB TAPES     *//\n//*          SAM GOLOB  -  NEWSWEEK INCORPORATED                   *//\n//******************************************************************//\n//*\n//UPDATEO PROC V1=NSY001,          INPUT TAPE VOLUME\n//             P=CBT973,           DECOMPRESSION PROGRAM\n//             P1=IEBUPDTE,   PROGRAM TO PROCESS IEBUPDTE SYSIN\n//*                           STREAM.\n//             VO=WORK02,          OUTPUT DASD VOLUME\n//             LAB=,               INPUT TAPE LABEL NUMBER\n//             WORK1=SYSDA,        TEMP DATASET UNIT TYPE\n//             WORK2=3380,         DASD OUTPUT TYPE FOR OUTPUT PDS\n//             PFX=TSTBSSG,        FIRST LEVEL INDEX FOR OUTPUT DS\n//             INDEX=MVSIPO,       FIRST LEVEL INDEX FOR INPUT DS\n//             DSP='CATLG',        OUTPUT DATASET DISPOSITION\n//             UNT=481,            TYPE UNIT NAME\n//             TY=SL,              TAPE FILE LABEL\n//             PRI=60,             PRIMARY ALLOCATION\n//             SEC=60,             SECONDARY ALLOCATION\n//             DIR=91,             NUMBER OF DIRECTORY BLOCKS\n//             ALLOC=TRK,          ALLOC INCREMENT\n//             LR=80,              LRECL\n//             BKI=32716,          INPUT BLOCKSIZE\n//             BKO=6160,           OUTPUT BLOCKSIZE\n//             FM=FB               RECFM\n//UPDATE1  EXEC  PGM=&P,REGION=512K,COND=EVEN\n//INPUT    DD  UNIT=&UNT,VOL=(,RETAIN,SER=&V1),DISP=(OLD,PASS),\n//             DCB=(RECFM=VB,LRECL=94,BLKSIZE=&BKI.),\n//             DSN=&INDEX..&DS,\n//             LABEL=(&LAB,&TY.,EXPDT=98000)\n//OUTPUT   DD  DSN=&&TEMP,DISP=(NEW,PASS),\n//             UNIT=&WORK1.,\n//             DCB=(RECFM=&FM.,LRECL=&LR.,BLKSIZE=&BKO.),\n//             SPACE=(&ALLOC.,(&PRI.,&SEC.),RLSE) VOL=SER=&VO\n//UPDATE2  EXEC  PGM=&P1,PARM=NEW,REGION=256K,COND=EVEN\n//SYSPRINT DD  DUMMY                SUPPRESS PRINTOUT\n//SYSIN    DD  DSN=&&TEMP,DISP=(OLD,DELETE)\n//SYSUT2   DD  DSN=&PFX..&DS,DISP=(NEW,&DSP.),\n//             UNIT=&WORK2.,FREE=CLOSE,\n//             DCB=(RECFM=&FM.,LRECL=&LR.,BLKSIZE=&BKO.),\n//             SPACE=(&ALLOC.,(&PRI.,&SEC.,&DIR.),RLSE),VOL=SER=&VO\n//       PEND\n//SYM01 EXEC UPDATEO,LAB=02,V1=NSY001,DS='SYM011.F01'\n//SYM02 EXEC UPDATEO,LAB=02,V1=NSY002,DS='SYM021.F01'\n//SYM03 EXEC UPDATEO,LAB=05,V1=NSY002,DS='SYM021.F04'\n//SYM04 EXEC UPDATEO,LAB=70,V1=NSY002,DS='SYM031.F02'\n//SYM05 EXEC UPDATEO,LAB=74,V1=NSY002,DS='SYM041.F02'\n//SYM06 EXEC UPDATEO,LAB=02,V1=NSY003,DS='SYM051.F01'\n//SYM07 EXEC UPDATEO,LAB=12,V1=NSY003,DS='SYM061.F01'\n//SYM08 EXEC UPDATEO,LAB=41,V1=NSY003,DS='SYM071.F01'\n\n\n    *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n  FIGURE FOUR.\n\n\n\n//TSTBLSG$ JOB (TS,2322),'TECH-S.GOLOB',CLASS=M,NOTIFY=TSTBSSG,\n//        MSGLEVEL=(1,1),MSGCLASS=T TYPRUN=HOLD\n//********************************************************//\n//*    ASSEMBLER H VERSION 2 - ASSEMBLE AND LINKEDIT     *//\n//********************************************************//\n//ASMHCL PROC\n//C      EXEC  PGM=AEV90,REGION=5000K,    <=== SLAC ASSEMBLER H\n// PARM='OBJECT,OPCXA,NRLIST,OPCNTS,ALIGN,XREF(FULL)'\n//*TEPLIB  DD  DSN=TSY2.LINKLIB,DISP=SHR\n//SYSLIB   DD  DSN=TSY2.MACLIB,DISP=SHR\n//SYSUT1   DD  UNIT=(SYSDA,SEP=SYSLIB),SPACE=(CYL,(10,5)),DSN=&SYSUT1\n//SYSPUNCH DD  SYSOUT=B,DCB=(BLKSIZE=800),SPACE=(CYL,(5,5,0))\n//SYSPRINT DD SYSOUT=*,DCB=(BLKSIZE=3509),UNIT=(,SEP=(SYSUT1,SYSPUNCH))\n//SYSLIN   DD  DISP=(,PASS),UNIT=SYSDA,SPACE=(CYL,(5,5,0)),            *\n//             DCB=(BLKSIZE=400),DSN=&&LOADSET\n//L  EXEC  PGM=IEWL,PARM='MAP,LET,LIST,NCAL',REGION=1960K,COND=(8,LT,C)\n//SYSLIN   DD  DSN=&&LOADSET,DISP=(OLD,DELETE)\n//         DD  DDNAME=SYSIN\n//SYSLMOD DD DISP=(,PASS),UNIT=SYSDA,SPACE=(CYL,(2,1,2)),DSN=&GOSET(GO)\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(CYL,(3,2)),DSN=&SYSUT1\n//SYSPRINT DD  SYSOUT=*,DCB=(RECFM=FB,BLKSIZE=3509)\n//  PEND\n//S02ASM  EXEC ASMHCL,\n//        PARM.L='LIST,LET,XREF,NCAL'\n//C.SYSLIB DD DISP=SHR,DSN=TSY2.MACLIB,DCB=BLKSIZE=32760\n//       DD DSN=TSY2.ATSOMAC,DISP=SHR\n//       DD DSN=TSY2.AMODGEN,DISP=SHR\n//       DD DISP=SHR,DSN=TSY2.PVTMAC1\n//       DD DISP=SHR,DSN=TSY2.PVTMAC2\n//       DD DISP=SHR,DSN=TSY2.PVTMAC3\n//       DD DISP=SHR,DSN=TSY2.PVTMAC4\n//*      DD DISP=SHR,DSN=TSTBSSG.VTAMR22.PVTMACS\n//C.SYSIN DD DSN=TSTBSSG.JB3513.F21(IEAVNP05),DISP=SHR\n//L.SYSLMOD DD DSN=TST.TSO.CMDLIB,DISP=SHR\n//L.SYSIN DD *\n SETCODE AC(1)\n SETSSI AA999999\n NAME IEAVNP05(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL8907JL": {"ttr": 4106, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93!\\x0f\\x00\\x93!\\x0f\\x12\\x01\\x01\\xe4\\x01\\xe4\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "1993-07-29T12:01:00", "lines": 484, "newlines": 484, "modlines": 0, "user": "SBGCSC"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           July 1989\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n\n\n                   THE AMAZING EXCP-COUNT ZAP\n\n\n      This monthly column is for sharing practical advice and\ntechniques which can be employed in your shop.  We hope to provide\nstimulating discussion and help to as large a group of MVS systems\nprogrammers as possible.\n\n      As many of you already know, this column depends largely on\nyou, the reading public, for contributions and ideas.  We greatly\nappreciate calls and messages from interested readers who will ask\nme to write about some favorite trick or method of theirs.  Just\nsend a message on NASCOM to Shari Matzner (id SUPERZAP), or write a\nnote to me care of the magazine.  Please include your phone number.\n\n      A word about software tools.  This column is task oriented.\nIn other words, the idea is to learn how to get a job done.  Whatever\nsoftware tool will work, is fine.  We have tried, however, to make\nall of the techniques as accessible to as many people as possible,\nREGARDLESS OF BUDGET.  For that reason, we refer to the many quality\npublic-domain offerings available on the Connecticut Bank and Trust\nMVS Tape (known as the CBT Tape) and the NaSPA V.I.P. MVS tapes.\n\n      To obtain a CBT tape (which contains HUNDREDS of software\npackages), call Arnold Casinghino, (203) 244-5495.\n\n      Our topic this month concerns an amazing addition to the MVS\noperating system.  Read on, and find out about some wonderful records\nthat are kept by the system.  We need only encourage MVS to give these\nfigures out and show them to us onlookers.\n\n     *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n       Nearly every computer user who runs a job wants to know what\nhis job DID.  If it read files and produced reports, and everything\nlooks good, it probably did what it was supposed to.  But you can't\nsay much more than that.  Very often you don't KNOW more than that.\n\n       Trust the machine?  We all have to, but it would be better\nif the machine would tell us more.\n\n       There is one way to get the machine to tell you quite a bit\nmore.  We'll show how to make it tell you about its file I/O activity.\nFor FREE.\n\n       File I/O in IBM/370 architecture is done by \"executing channel\nprograms\" (EXCP for short).  This means that the \"channels\", which\ncan be viewed as connectors between the CPU and peripheral devices,\nare instructed (or programmed) how to transmit data between the\ncomputer itself and the connected device.  With each execution of a\nchannel program, a burst of data is read from or written to a file.\n\n       EXCP is the \"rock bottom\" of File I/O, in the same sense as\nMACHINE INSTRUCTIONS are the \"rock bottom\" of program execution in a\nCPU.  You can write a program in a higher-level language, such as\nCOBOL or PL/1, but before it can be run, it must be converted (or\n\"compiled\") into machine instructions.  It is the machine instructions\nwhich actually RUN.\n\n       Same with File I/O.  You can tell the machine using ACCESS\nMETHODS such as QSAM, BSAM, or VSAM, what you want it to do with\nfiles, such as reading or writing data in a certain format.  But the\n\"access method source\" instructions cannot do any transfer of the\ndata itself, just as COBOL SOURCE statements cannot tell a CPU what\nto do.  The \"access methods\" must first convert your I/O orders into\nEXCP before any data transfers can be done.  The data transfer\nmachinery only understands EXCP; it does not understand \"access\nmethod source\" instructions directly.\n\n       Counting the NUMBER OF TIMES a channel program was executed\nto a particular file gives some indication of how much file I/O\nactivity there was.  This measure of file activity is called EXCP\nCOUNTS.  EXCP counts may not express exact quantification of data\ntransfer, because the data may be transferred in many little bursts,\nresulting in a high count, or in a few large bursts, resulting in\na low count.  Very good indications can be supplied to the programmer\nwho knows how his program works.  The counts can give him, and others,\na very good feel for what is happening during the execution of the\nprogram.  Sometimes it is sufficient to know if there was any I/O\nactivity at all.\n\n       A number of vendor products are available to supply this\nkind of information for your jobs.  I personally haven't done a\nsurvey of them because I have a FREE means of providing the data,\nwhich is probably better than all of these products.  We can\nactually CAUSE THE MVS OPERATING SYSTEM ITSELF to supply us with\nEXCP counts for EACH ALLOCATED DD NAME, right in the JCL allocation\nmessages themselves!\n\n       How can we accomplish this wonderful thing?\n\n       First let me tell you what you'll get.  If you're running MVS,\nyou've all seen JCL allocation messages for files on your job printouts.\nThey look like:\n\n  IEF285I   SYS1.LINKLIB        KEPT\n  IEF285I   VOL SER NOS= MVSRES.\n\nAfter you've done our magic, you get:\n\n  IEF285I   SYS1.LINKLIB        KEPT         *----1,294\n  IEF285I   VOL SER NOS= MVSRES.\n\nYou get this for all allocated ddnames.  On my system, I've even\nseen the counts on the SYSLOG from the very beginning of system\ninitialization.  MVS itself is made to provide them.  You don't\nhave to rely on SMF records, as many of the vendor packages do.\n\n       I'll tell you how it's done.  The system module which produces\nthe IEF285I messages is called IEFAB4B0.  On MVS/370, the module has\nnot changed since base version 3.8.  On MVS/XA, it has also not\nchanged since the base level.  This is how the counts are obtained.\nIEFAB4B0 is expanded to add a patch area at the end.  Code is inserted\ninto the patch area which obtains the counts and puts them into the\nIEF285I message.  The code works as follows:  It goes back into the\nmodule which CALLS IEFAB4B0 (its name is IEFAB4A2) by accessing the\nsaved registers from the calling program.  It is this calling program,\nIEFAB4A2, which has access to the DSAB control block that contains the\nEXCP-count information.  The patched code in IEFAB4B0 uses ITS\nCALLER's REGISTERS and acts for a while as if it were really executing\nin the caller, IEFAB4A2.  After the information is obtained, it is\nformatted and inserted into the IEF285I message.\n\n       Cool!  This is the concept.  Now how can you install it?\n\n       The code is on the Connecticut Bank and Trust MVS Mods Tape,\n(the CBT tape) FILE 369, and it was donated by Dick Sziede and his\nstaff of the Planning Research Corporation at Dulles Airport in\nVirginia.  Dick is running MVS/XA 2.2 in his shop.  His old MVS/370\nversion is maintained by me, and that code is in file 369 also.\n(There are two XA versions.  On recent CBT tapes is the one called\nLM01603, which works for XA through 2.2.  The older XA version,\ncalled LM01602, was good through XA 2.1.7.) The zap is applied to\nmodule IEFAB4B0 (from load module IEFW21SD) in the form of an SMP\nUSERMOD, but the USERMOD is generated in a very novel manner.\n\n       Howard Gilbert of Yale University Computer Center, one of the\ngeniuses of user-written MVS software, has a PL/1 program called\nASMTOZAP, whose SOURCE is on file 369 of the CBT tape.  (The LOAD\nMODULE is on FILE 035 of more recent versions of the CBT tape.)\nASMTOZAP allows you to code SYSTEM ZAPS as if they were ASSEMBLER\nPROGRAMS.\n\n       This is how ASMTOZAP works.  Certain control statements\nare coded as comments in your assembler source code telling ASMTOZAP\nwhere to start the VER statements and where to start the REP\nstatements.  (You don't have to do this in the EXCP-count mod,\nbecause it is already done.)  You assemble the source code (NO\nLINKEDIT please) and create a LISTING on a disk file.  You then run\nthe PL/1 program ASMTOZAP against the LISTING.  In our case, it\nproduces an already-coded SMP USERMOD, which has the zap in it.\n\n       Now.  After editing the generated USERMOD to your\ninstallation's taste, and APPLYing it, the LMOD, which is called\nIEFW21SD, is changed in LPALIB, and an IPL with CLPA will allow you\nto test the mod.\n\n       ONE WARNING is in order.  The calling mod IEFAB4A2 is\nsensitive to IBM maintenance.  Whenever IEFAB4A2 is changed, you must\nlook into the FICHE of the new PTF level for the field called\nDSABPTR.  In my current version on MVS/370, this is at displacement\n+138 hex, into IEFAB4A2.  This displacement must be hard-coded into\nyour USERMOD.  Notes in the assembler source will tell you where to\ncode it.  The displacement of the DSABPTR has been known to change\nwith fairly recent modifications of IEFAB4A2, and you must check it\nwith every change to that module.  I safeguard myself by doing a\nUCLIN of my USERMOD NUMBER as a UMID to IEFAB4A2, even though\nIEFAB4A2 is not itself affected by applying the USERMOD.  This gives\nme an ID check in SMP whenever maintenance hits this module.  The\nother module IEFAB4B0 which has the zap in it, never has gotten\nmaintenance to it.\n\n       There are 3 versions of the mod, one for MVS/370, an early\nversion for XA, and a later modification that covers all XA levels\nthrough XA 2.2.  As for the XA versions, the one called LM01603 is\nthe preferred one, and is necessary for 2.2.  LM01603 can be found\non file 369 of very recent versions of the CBT tape.  LM01602 will\nwork for those versions of XA previous to 2.2.  The latest version\nfor XA has been worked over at Planning Research Corp. to handle\nI/O counts to multi-volume disk datasets, whereas the MVS/370 one\nhas not been so reworked.  It is on my wish list to rework it. (The\n370 version shows the I/O's to the last volume only.)  The mod is\nstill great, however.\n\n       Just a final note.  The USERMOD as supplied by file 369 has\na linkedit EXPAND statement in it, which creates the patch area at\nthe end of module IEFAB4B0.  This EXPAND only has to be done once.\nIn my shop, I separated the EXPAND into a separate USERMOD that PREs\nthe actual zap.  That way, if I have to repeat the APPLYing of the\nUSERMOD, it won't keep expanding the size of the IEFAB4B0 module.\n\n       You are referred to the figures which will show what this\nmodification looks like, both in original assembler source and in\ngenerated zap form as it exists at my shop (for MVS/370.  The MVS/XA\nlevel of the zap can be found on file 369 of the CBT tape.)  Also\nincluded here is ASMTOZAP execution JCL.\n\n       Good luck.  Everyone in your shop will enjoy this mod!\n\n\n     *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n  FIGURE ONE:    EXCP-COUNT SOURCE IN \"ASMTOZAP\" FORMAT.\n\n\n*------- TITLE LM02301...I/O COUNT  IN MSG IEF285I\n*-------\n*------- AUTHOR LARRY KRAUSE...LITTON COMPUTER SERVICES 1978\n*-------        DICK SZIEDE....GENERAL ELECTRIC 1983\n*-------\n*------- BACKGROUND AS FAR AS I KNOW,LARRY IS THE ONLY ONE TO\n*-------       WRITE A MVS VERSION  OF THIS MOD,  ALTHOUGH IT\n*-------       COMMON IN MVT (RICK  DUVALL...CSC) AND SVS (AUTHOR\n*-------       UNKNOWN).  THIS VERSION HAS BEEN RECODED IN ASMTOZAP\n*-------       FORMAT FOR MVS SP1.3, WITH SOME COSMETIC CHANGES.\n*-------       ...DICK SZIEDE...CSC 1982.\n*-------       MAKE WORK UNDER VS ASSEMBLER INSTEAD OF ASMH, AND\n*-------       MORE COSMETIC CHANGES...DICK SZIEDE, GE 1983.\n*-------\n*ZAP     CARD ++ USERMOD(LM02301) /* I.O COUNTS IN IEF285I */.\n*ZAP     CARD ++ VER(Z038) FMID(EBB1102) PRE(JBB1326).\n*ZAP     CARD ++ ZAP (IEFAB4B0).\n*ZAP     CARD  NAME IEFAB4B0\n*ZAP     CARD  EXPAND IEFAB4B0(128)\nLM02301A CSECT\nIEFAB4B0 DS    0H\n         PRINT ON,GEN,DATA\n         ORG   @PSTART\n         USING *,@12\n         USING @DATD,@11\n*ZAP     START VER\n         ORG   CLRKEY\n         STC   @02,@OLDKEY\n         ORG   CLRTXT\n         MVC   MSGBUFFR+1(73),MSGBUFFR  BLANK ENTIRE BUFFER\n         ORG   STEAL\n         MVI   MSGDISP+1,C' '      DISPLACED INSTRUCTION\n         ORG   @EL00001\n         IC    @02,@OLDKEY\n         ORG   @SIZDATD\n         DC    AL1(230),AL3(@ENDATD-@DATD)\n         ORG   PATCH\n         DC    4F'0'\n*ZAP     START REP\n         ORG   CLRKEY\n         STC   @02,@NEWKEY\n         ORG   CLRTXT\n         MVC   MSGBUFFR+1(78),MSGBUFFR  BLANK ENTIRE BUFFER\n         ORG   STEAL\n         B     PATCH\nMAINLINE EQU   *\n         ORG   @EL00001\n         IC    @02,@NEWKEY\n         ORG   @SIZDATD\n         DC    AL1(230),AL3(@NEWDATD-@DATD)\n         ORG   PATCH\nPATCHOUT MVI   MSGLNGTH+3,79       SET MSGLNGTH TO 79\n         L     @10,@PC00001        ADDR OF MSGID\n         TM    0(@10),X'01'        MSGID=1 ?\n         BNO   PATEXIT                 NO ==> WE EXIT.\n         L     @10,4(,@13)         ADDR OF IEFAB4A2'S SAVE AREA\n         L     @10,X'3C'(,@10)     IEFAB4A2'S R10\n*        ICM   @10,15,X'13C'(@10)  ADDR OF DSAB (IEFAB4A2 DSABPTR\n*                                       LEVEL JBB1326)\n         ICM   @10,15,X'138'(@10)  ADDR OF DSAB (IEFAB4A2 DSABPTR\n*                                   LEVELS UZ75725 AND UZ84610)\n         BZ    PATEXIT             EXIT IF NO DSAB\n         L     @10,DSABTIOT(,@10)  ADDR OF TIOT ENTRY\n         SLR   @06,@06             CLEAR WORK REG\n         CH    @06,TIOPSTTB(,@10)  IS THERE A UCB ENTRY IN TIOT?\n         BZ    PATEXIT                NO ==> WE QUIT.\n         L     @01,@PC00001+16     ADDR OF JSCB PTR\n         L     @01,0(,@01)         ADDR OF JSCB\n         L     @04,JSCBTCBP(,@01)  ADDR OF INIT'S TCB\n         L     @01,JSCTMCOR(,@01)  ADDR OF TIOT MGMT AREA\n         S     @10,X'18'(,@01)     CALC TIOT ENTRY OFFSET\n         ICM   @04,15,TCBTCT(@04)  ADDR OF TIMING CONTROL TABLE\n         BZ    PATEXIT             EXIT IF NONE\n         L     @04,TCTIOTBL(,@04)  ADDR OF TCT I/O TABLE\n         LA    @05,TCTDCBTD(,@04)  ADDR OF 1ST DD LOOKUP TABLE ENTRY\nPATDDLOP CH    @06,0(,@05)         LAST ENTRY IS ZERO\n         BZ    PATEXIT                  EXIT IF ZERO.\n         CH    @10,0(,@05)         DO THE TIOT DISPLACEMENTS MATCH?\n         BE    PATPRINT                 YES ==> PRINT I/O COUNT.\n         LA    @05,4(,@05)         BUMP TO NEXT DD TABLE ENTRY\n         B     PATDDLOP\n         SPACE\nPATPRINT AH    @04,TCTIOTSD(,@05)  OFFSET TO THE DEVICE ENTRY\n*                                  (TCTDDENT OR TCBUCBP)\n         L     @06,TCTDCTR(,@04)   GET THE I/O COUNT\n         CVD   @06,MSGDISP+1       INTO PACKED FORMAT\n         MVC   MSGCOUNT(L'EDMSK1),EDMSK1 PREPARE TO EDIT\n         ED    MSGCOUNT(L'EDMSK1),MSGDISP+5 STICK IN SOME COMMAS\n         MVI   MSGCOUNT,C'*'       MARK WITH A SPLAT\nPATEXIT  MVI   MSGDISP+1,C' '      DISPLACED INSTRUCTION\n         B     MAINLINE\n*\nEDMSK1   DC    X'60206B2020206B202120'\n*ZAP     END\n@DATD    DSECT\n         ORG   @DATD+X'48'\n@PC00001 DS    5F\n         ORG   @DATD+X'B4'\nMSGLNGTH DS    F\n         DS    2F\nMSGBUFFR DS    C\n         ORG   @DATD+X'F7'\nMSGDISP  DS    X\n         ORG   @DATD+X'105'\nMSGCOUNT DS    CL6\n@OLDKEY  DS    AL1\n@ENDATD  EQU   *\n         ORG   @DATD+X'120'\n@NEWKEY  DS    AL1\n         DS    D                   ALIGN TO DUBBLEWORD FOR GETMAIN\n@NEWDATD EQU   *\n         SPACE\nLM02301A CSECT\n*        ***** EQUATES FOR DSECTS  I'M TOO LAZY TO DO THE DROPS\n*        ***** 'N USINGS FOR.\nDSABTIOT EQU   X'10'\nTIOPSTTB EQU   X'12'\nJSCBTCBP EQU   X'D0'                   '\nJSCTMCOR EQU   X'14C'                  '\nTCBTCT   EQU   X'A4'\nTCTIOTBL EQU   X'C'\nTCTDCBTD EQU   X'8'\nTCTIOTSD EQU   X'2'\nTCTDCTR  EQU   X'4'\n*\n*        ***** EQUATES FOR LOCATIONS WITHIN IEFAB4B0\n@PSTART  EQU   IEFAB4B0+X'1C'\nCLRKEY   EQU   IEFAB4B0+X'52'\nCLRTXT   EQU   IEFAB4B0+X'76'\nSTEAL    EQU   IEFAB4B0+X'156'\n@EL00001 EQU   IEFAB4B0+X'2EE'\n@SIZDATD EQU   IEFAB4B0+X'3E8'\nPATCH    EQU   IEFAB4B0+X'45C'\n*        ***** AND OF COURSE, THE REGISTERS\n@01      EQU   01\n@02      EQU   02\n@04      EQU   04\n@05      EQU   05\n@06      EQU   06\n@10      EQU   10\n@11      EQU   11\n@12      EQU   12\n@13      EQU   13\n         END\n\n\n     *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n  FIGURE TWO:    \"ASMTOZAP\" PROGRAM  -  EXECUTION JCL.\n\n\n//TSTBDP2S JOB ,'TECH.SUPP-SAM.GOLOB',CLASS=M,NOTIFY=TSTBSSG,\n//        MSGLEVEL=(1,1),MSGCLASS=T TYPRUN=HOLD\n//******************************************************************//\n//*   ASMTOZAP EXECUTION - FILE 317 OF CBT254 TAPE                 *//\n//*                        FILE 044 OF CBT299 TAPE                 *//\n//*                        FILE 035  -  LOAD MODULE                *//\n//******************************************************************//\n//*\n//ASMTOZAP EXEC PGM=ASMTOZAP\n//SYSPRINT DD  SYSOUT=*\n//PL1DUMP  DD  SYSOUT=*\n//IN       DD  DISP=SHR,DSN=TSTBSSG.NZPIO.ASM    <=== ASSEMBLY LISTING\n//OUT      DD  DISP=SHR,DSN=TSTBSSG.NZPIO.ZAP,   <=== ZAP FMT OUTPUT\n//      DCB=(RECFM=FB,LRECL=80,BLKSIZE=800)\n//*\n\n\n     *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n  FIGURE THREE:  EXCP-COUNT ZAP AS FOUND AT NEWSWEEK, INC.\n\n\n++ USERMOD(NZPIO06) /* I.O COUNTS IN IEF285I */  .\n++ VER(Z038) FMID(EBB1102)\n             PRE(JBB1329 UZ84610 NZPIO05)\n             SUP(NZPIO01 NZPIO02 NZPIO03 NZPIO04)\n /*\n DOCUMENTATION:        S. GOLOB - NEWSWEEK INCORPORATED - 01/21/87\n   THIS USERMOD WAS INSTALLED FROM FILE 369 OF THE CBT254 MODS\n   TAPE FOR MVS.  IT WAS NOT CORRECT AS FOUND THERE BECAUSE OF AN\n   INCORRECT DSAB POINTER (DSABPTR) IN MODULE IEFAB4A2, WHICH BELONGS\n   TO FMID JBB1329 (MVS SP 1.3.3) AND IS ON OUR SYSTEM AT RMID UZ75725\n   (PUT TAPE 8409).  THE OLD POINTER OF 013C NOW POINTS TO A DIFFERENT\n   CONTROL BLOCK AND THE MOD WILL NOT WORK IF YOU HAVE THE WRONG\n   OFFSET.\n\n   NOTE:  YOU MUST DO THE FOLLOWING UCLIN TO DISABLE IBM MAINTENANCE\n            ON MODULE IEFAB4A2.  THIS WILL FORCE AN ID CHECK.\n\n     UCLIN CDS.\n     REP MOD(IEFAB4A2) RMID(NZPIO06).\n     ENDUCL.\n\n   */  .\n++ ZAP (IEFAB4B0).\n NAME IEFAB4B0\n*                            ORG   CLRKEY\nVER 0052 4220,B10B           STC   @02,@OLDKEY\n*                            ORG   CLRTXT\nVER 0076 D248,B0C1,B0C0      MVC   MSGBUFFR+1(73),MSGBUFFR  BLANK ENTIRE BUFFER\n*                            ORG   STEAL\nVER 0156 9240,B0F8           MVI   MSGDISP+1,C' '      DISPLACED INSTRUCTION\n*                            ORG   @EL00001\nVER 02EE 4320,B10B           IC    @02,@OLDKEY\n*                            ORG   @SIZDATD\nVER 03E8 E600,010C           DC    AL1(230),AL3(@ENDATD-@DATD)\n*                            ORG   PATCH\nVER 045C 0000,0000,0000,0000 DC    4F'0'\nVER 0464 0000,0000,0000,0000\n*                            ORG   CLRKEY\nREP 0052 4220,B120           STC   @02,@NEWKEY\n*                            ORG   CLRTXT\nREP 0076 D24D,B0C1,B0C0      MVC   MSGBUFFR+1(78),MSGBUFFR  BLANK ENTIRE BUFFER\n*                            ORG   STEAL\nREP 0156 47F0,C440           B     PATCH\n*                   MAINLINE EQU   *\n*                            ORG   @EL00001\nREP 02EE 4320,B120           IC    @02,@NEWKEY\n*                            ORG   @SIZDATD\nREP 03E8 E600,0130           DC    AL1(230),AL3(@NEWDATD-@DATD)\n*                            ORG   PATCH\n*                   PATCHOUT EQU   *\nREP 045C 924F,B0B7           MVI   MSGLNGTH+3,79       SET MSGLNGTH TO 79\nREP 0460 58A0,B048           L     @10,@PC00001        ADDR OF MSGID\nREP 0464 9101,A000           TM    0(@10),X'01'        MSGID=1 ?\nREP 0468 47E0,C4C6           BNO   PATEXIT                 NO ==> WE EXIT.\nREP 046C 58A0,D004           L     @10,4(,@13)         ADDR OF IEFAB4A2'S SAVE A\nREP 0470 58A0,A03C           L     @10,X'3C'(,@10)     IEFAB4A2'S R10\nREP 0474 BFAF,A138           ICM   @10,15,X'138'(@10)  ADDR OF DSAB (IEFAB4A2 DS\n*                                       LEVEL JBB1329 RMID UZ75725)\nREP 0478 4780,C4C6           BZ    PATEXIT             EXIT IF NO DSAB\nREP 047C 58A0,A010           L     @10,DSABTIOT(,@10)  ADDR OF TIOT ENTRY\nREP 0480 1F66                SLR   @06,@06             CLEAR WORK REG\nREP 0482 4960,A012           CH    @06,TIOPSTTB(,@10)  IS THERE A UCB ENTRY IN T\nREP 0486 4780,C4C6           BZ    PATEXIT                NO ==> WE QUIT.\nREP 048A 5810,B058           L     @01,@PC00001+16     ADDR OF JSCB PTR\nREP 048E 5810,1000           L     @01,0(,@01)         ADDR OF JSCB\nREP 0492 5840,10D0           L     @04,JSCBTCBP(,@01)  ADDR OF INIT'S TCB\nREP 0496 5810,114C           L     @01,JSCTMCOR(,@01)  ADDR OF TIOT MGMT AREA\nREP 049A 5BA0,1018           S     @10,X'18'(,@01)     CALC TIOT ENTRY OFFSET\nREP 049E BF4F,40A4           ICM   @04,15,TCBTCT(@04)  ADDR OF TIMING CONTROL TA\nREP 04A2 4780,C4C6           BZ    PATEXIT             EXIT IF NONE\nREP 04A6 5840,400C           L     @04,TCTIOTBL(,@04)  ADDR OF TCT I/O TABLE\nREP 04AA 4150,4008           LA    @05,TCTDCBTD(,@04)  ADDR OF 1ST DD LOOKUP TAB\n*                   PATDDLOP EQU   *\nREP 04AE 4960,5000           CH    @06,0(,@05)         LAST ENTRY IS ZERO\n*\nREP 04B2 4780,C4C6           BZ    PATEXIT                  EXIT IF ZERO.\nREP 04B6 49A0,5000           CH    @10,0(,@05)         DO THE TIOT DISPLACEMENTS\nREP 04BA 4780,C4AA           BE    PATPRINT                 YES ==> PRINT I/O CO\nREP 04BE 4150,5004           LA    @05,4(,@05)         BUMP TO NEXT DD TABLE ENT\nREP 04C2 47F0,C492           B     PATDDLOP\n*                   PATPRINT EQU   *\nREP 04C6 4A40,5002           AH    @04,TCTIOTSD(,@05)  OFFSET TO THE DEVICE ENTR\n*                                  (TCTDDENT OR TCBUCBP)\nREP 04CA 5860,4004           L     @06,TCTDCTR(,@04)   GET THE I/O COUNT\nREP 04CE 4E60,B0F8           CVD   @06,MSGDISP+1       INTO PACKED FORMAT\nREP 04D2 D209,B105,C4CE      MVC   MSGCOUNT(L'EDMSK1),EDMSK1 PREPARE TO EDIT\nREP 04D8 DE09,B105,B0FC      ED    MSGCOUNT(L'EDMSK1),MSGDISP+5 STICK IN SOME CO\nREP 04DE 925C,B105           MVI   MSGCOUNT,C'*'       MARK WITH A SPLAT\n*                   PATEXIT  EQU   *\nREP 04E2 9240,B0F8           MVI   MSGDISP+1,C' '      DISPLACED INSTRUCTION\nREP 04E6 47F0,C13E           B     MAINLINE\n*\n*                   EDMSK1   EQU   *\nREP 04EA 6020,6B20,2020,6B20 DC    X'60206B2020206B202120'\nREP 04F2 2120\n* DECK PRODUCED BY THE ASMTOZAP UTILITY 85/12/16 165820\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL8909SE": {"ttr": 4360, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93!\\x0f\\x00\\x93!\\x0f\\x12\\x01\\x01Q\\x01Q\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "1993-07-29T12:01:00", "lines": 337, "newlines": 337, "modlines": 0, "user": "SBGCSC"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         September 1989\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n\n\n\n      You may be surprised to hear that I do not consider myself a\nmore knowledgeable MVS Systems Programmer than most of our esteemed\nreaders out there.  THAT MEANS YOU.  ALL OF YOU have your \"pet\ntricks\" and neat ways of doing things.  ALL OF YOU HAVE EXPERIENCE\nTHAT I DON'T HAVE.  We all tend to take \"our own stuff\" for granted,\nand we think that everyone else does things pretty much the same\nway.\n\n      WELL IT JUST AIN'T SO.\n\n      I get a big charge out of going to someone else's data center\n\"just to see how they do things over there\".  I happen to have a very\nlong commute to work (approximately 80 miles), and just about every\nMVS shop that is located between Central New Jersey and Northern\nNew Jersey is \"on my way to work\", if I choose to go by that way.\nMy boss (bless his heart) is very understanding about my flexible\nhours, as long as I put in the proper amount of time at the job.\nTherefore, I visit friends at other data centers quite often.\n\n      They do things very differently.  First, everyone has a\ndifferent hardware configuration than everyone else.  Often, they\nhave different levels of the operating system software.  The varied\nscattering of vendor products in each place, makes for different\nworking methods by each individual.\n\n      Every person's working history has given him a different \"View\nof Life\".  One person has had to write a lot of JES2 exits.  The next\nperson runs JES3.  Another person has to contend with all kinds of\nDASD management rules in his shop, so he has been busy enforcing all\nsorts of restrictions as to \"WHO is permitted to allocate a dataset\nWHERE\".  One person has to administer RACF and interface between RACF\nand different devices; another shop has ACF2; still others have no\nsecurity at all, or they still use MVS passwords.  THESE DIFFERENCES\nIN ENVIRONMENT FORCE EVERY INDIVIDUAL TO HAVE HIS OWN UNIQUE TOOLS,\nAND WAYS OF DOING THINGS.\n\n      People in our profession are starting to recognize that \"we\ncan't do it all alone\".  THERE IS POWER IN NUMBERS, AND IN MUTUAL\nHELP.  Anyone who belongs to a local user group, or who has gone to\nSHARE or GUIDE (and now NaSTEC) can testify that his \"modus operandi\"\nor \"what he does every day\" has been improved in some way - a lot of\ntimes IN MANY WAYS, at the conferences.  WHY IN HECK DO YOU READ THIS\nMAGAZINE, if not to expand your knowledge and profit from what\nsomeone else has done?\n\n      What am I getting at?\n\n      Simply this.  YOU DON'T HAVE TO THINK THAT YOU'RE AN EXPERT,\nIN ORDER TO HELP SOMEBODY ELSE.\n\n      Each one of us comes up with something pretty slick.  It comes\nwith the territory.  That's part of what we get paid for, because if\na robot or an untrained person could do our jobs, it would be a simple\nmatter of economics that we'd all be out of work.  They simply get\npaid less money than we do.\n\n      DON'T THINK FOR A MOMENT THAT THE OTHER GUY CAME UP WITH THE\nSAME SLICK THING YOU DID.  HE HAD DIFFERENT PROBLEMS.  HE IS WORKING\nIN A DIFFERENT SHOP.  HE has NO WAY OF PROFITING from YOUR work,\nunless YOU DO ONE OF SEVERAL SIMPLE THINGS:\n\n   o    Tell your friends.\n\n   o    Bring the matter up at a user group meeting.\n\n   o    Write something up and upload it on NaSCOM.\n\n   o    Submit your thing to one of the MVS public-domain tapes.\n\n   o    Write a note to this magazine, or write an article.\n\n\n      My friends, I AM NO DIFFERENT FROM ANY OF YOU.  THIS IS ALL\nI EVER DID.  If you profit from anything I am saying, I assure you\nthat many other people in the profession CAN PROFIT JUST AS MUCH\nFROM WHAT YOU WILL SAY.\n\n      JUST CARE A LITTLE BIT ABOUT THE OTHER GUY....\n\n      IT COMES BACK.\n\n      Just take the plunge and do it.  (Its no big plunge anyway,\njust a plop.)\n\n      YOU WON'T LOSE.\n\n      Oops, I forgot.  I also did another thing.  I got into the\nhabit of calling the author of a public domain offering that I was\ninstalling, to thank him (or her) for the work.  As a result, I\nmade a lot of good friends in the field, and we've often been able\nto subsequently accomplish a lot of NEW good work together.\n\n    *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n      This month I would like to write about a marvelous product\nextension that, unfortunately, not too many people know about.  It\nis a series of improvements and enhancements to IBM's Assembler H\nVersion 2, called the \"SLAC Mods\" for Assembler H.\n\n      The SLAC Mods were written by Gregory J. Mushial of the\nStanford Linear Accelerator Center in California.  They are one neat\npiece of work.  People who know about them are hoping that the SLAC\nAssembler H will provide IBM with future direction in REMEDYING SOME\nOF THE GLARING DEFICIENCIES IN THE MVS (and VM) ASSEMBLER H VERSION\n2.  (Be it known that the mods were originally developed under VM.)\n\n      This is not to knock IBM completely.  Assembler H is a very good\nproduct that we all depend upon.  Its main problem is that IT \"KNOWS\"\nMORE THAN IT TELLS YOU.\n\n      One of the biggest problems with all the MVS (or for that\nmatter OS) assemblers, is that they don't tell you, conveniently in\none place, WHICH MACROS WERE USED BY YOUR ASSEMBLY.  The assembler\nhas to \"know\" the information, because it must pull the text of\nthe macros out of a library, and process the material in enormous\ndetail.  THAT THE ASSEMBLER SHOULD LEAVE YOU IGNORANT OF THE FULL\nNAMES OF THE MACROS IT FOUND, AND THAT IT WILL NOT PROVIDE YOU WITH\nEVEN A SUMMARY REPORT ABOUT THEM IS ABSURD BEYOND BELIEF, when you\nthink about it.\n\n      All the DOS and VSE assemblers give you a list of macro names\nhit by the assembly, and they have done so since the beginning of\ntime.  Is MVS worse than VSE?  (Don't get me wrong.  I LIKE VSE.)\n\n      The old IFOX00 assembler has some mods on the CBT and SPLA\ntapes (CBT file 300, called $$MACROX), which show you which macros\nwere found by an assembly.  I am grateful to Bill Godfrey for writing\nthem, and I used them extensively for a time, but you can go only so\nfar in today's world with IFOX00.  You need assembler H.  I was so\ninterested such a mod for assembler H, that I wanted to write it\nmyself.  But being one who does not want to reinvent the wheel, I\nnosed around to see if the work was already done.  That's how I found\nthe SLAC Mods from Greg Mushial.\n\n      The SLAC Mods have a beautiful MACRO REFERENCE at the beginning\nof the assembly (which will even tell you which macros are MISSING,\nand which ones are INLINE), but they have much more.  I'll sketch\nin some detail, some of the wonderful things that they have.\n\n      The enhancements are of four types.  These are:\n\n      o   Improvements to the assembler reports.\n\n      o   Extensions to the Macro Language.\n\n      o   Extensions to \"Open Code\" Assembler Language.\n\n      o   \"Run time\" improvements.\n\nI don't think I'll have space to describe ALL of the SLAC assembler's\nimprovements, but I'll try to give you a taste by mentioning a good\nnumber of them.\n\n      The two most immediately useful modifications are the MACRO\nLISTING, mentioned earlier, which points out the LIBRARY NAME and\nVOLUME SERIAL where each macro was found, and the USING LISTING,\nwhich SHOWS ALL CURRENT, ACTIVE USINGS, at the top of each page.  The\nmacro listing comes in very handy when packaging code to be sent out\nsomewhere.  You want to make sure you've included all the necessary\nmacros, in the right versions, with the code you ship.  Also, for\nyour own information when you assemble a software product, it's very\nuseful to know what macros are involved with the code, and where they\ncame from.  The macro reference is turned on by the assembler option\n\"MSRC\".  Sources for \"COPY CODE\" are also shown, together with the\nMACRO origins that are displayed.\n\n      The SLAC Assembler has a listing of ALL ACTIVE \"USINGs\" at the\ntop of each page.  The listing of all \"USING\" assembler statements,\nmakes it much easier to fix code.  For one thing, since the tied-up\nregisters are conveniently and currently displayed at the top of\neach page, the programmer will not be tempted to reuse them to hold\nsome data, and thus introduce bugs into his program.  Instead of\nconducting a lengthy search through pages and pages of code, with a\nlarge possibility of missing a USING statement somewhere, all the\nUSINGs are visibly clear at the top of the page, with no more\nguesswork.  The \"UMAP\" assembler option turns this feature on.\n\n      Another annoying assembler inconvenience concerns the location\ncounter.  The programmer goes searching through the code, looking\nfor some particular displacement, and all of a sudden, the numbers\nare not right.  This is often due to having a DSECT stuck in the\nmiddle of the main code.  The location counter is showing the DSECT\ndisplacements, and it is hard to immediately tell where you are.\n\n      Two improvements address this.  The first one is a change in\nthe header display for the location counter.  At the top of a page\nthat has begun in the middle of a DSECT, the header says \"D-LOC\"\ninstead of the usual \"LOC\".  The regular location counter header\n\"LOC\" is what is shown when the page header falls in the middle of a\nCSECT.  Thus, a quick glance at the top of the page will inform you\nwhat part of the code you're looking at.\n\n      The second improvement is the DSECT CROSS REFERENCE at the\nbeginning of the assembler listing, if the option \"DXREF\" is turned\non.  This lists ALL DSECTS ASSEMBLED WITH THE PROGRAM, the LINE\nNUMBER of the listing at which each begins, and the LENGTH IN HEX\nof each DSECT.  Using the DSECT CROSS REFERENCE, you can \"map out\nthe parts of the listing in your mind\" in advance, to \"scope out\"\nwhere the DSECTs are, so you'll be aware of them when you study the\nlisting in more depth later.\n\n      It is possible to get \"OPCODE COUNTS\", which includes counts\nof how many times a MACRO was hit, as well as how many times an opcode\nwas hit.  This is turned on by the option \"OPCNTS\".\n\n      A \"NON-REFERENCED SYMBOL LIST\" can be printed at the end of\nthe assembler listing, if you turn on the option \"NRLIST\".  You get\nto see a list of all LABELS THAT HAVE NOT BEEN REFERENCED BY CODE\nin the assembly.  It may not be desirable to eliminate these labels;\nthey may be important markers to help follow the coding logic.  But\nbeing able to see all of them together, can give a programmer an edge\nin improving his coding design.\n\n      The old IFOX00 option \"LIBMAC\" was put back in an improved\nfashion.  This option had been dropped altogether from Assembler H.\nProgrammers seldom use this option, which PRINTS THE FULL SOURCE OF\nALL FOUND MACROS right in the listing.  IFOX00 printed all of the\nmacro source after the \"END\" statement.  Assembler H, which can have\nmultiple \"END\" statements if you use its \"BATCH\" option, evidently\ncaused a confusion to the designers as to where the expanded macro\nsource should fit in the listing.  The SLAC ASSEMBLER H puts them in\nthe listing, right before the expansion of the macro is printed.  A\ncomparison of SOURCE with EXPANSION can thus conveniently be done,\nand we have not lost the possibility of using the facility, in the\nrare instances when it is needed.\n\n      One other change is apparent in the assembly listing.  When\nlooking at a LABEL CROSS REFERENCE or \"XREF\" listing, you'll notice\nthat some of the statement numbers are UNDERLINED.  This occurs when\nthe assembler determines that the operation being performed WAS\nTRYING TO CHANGE THE VALUE OF THE REFERENCED FIELD.  This is an\nattempt to show the difference between INQUIRY and UPDATE with\nreference to statement labels.  At a glance, the reader can tell if\nthe location is being UPDATED, or merely referenced.  Again, the\nprogrammer is being helped to zero in quickly on a reference he is\nlooking for.\n\n      An EXCP count of READS and WRITES to the SYSUT1 work file of\nthe assembler is provided at the end of the listing.  It is also\npossible to FORCE AN INCORE ASSEMBLY, using the \"NODISK\" option.\nSince no I/O is done to the work file when \"NODISK\" is set on, the\nassembly is significantly more efficient than if \"DISK\" is on.  The\nSLAC Assembler always shows how much main storage would be necessary,\nif the user wished to force the assembler to avoid using the work\nfile.  Problem with this is that if you run out of core when \"NODISK\"\nis on, the assembler aborts. To avoid the abort, just keep \"DISK\" on.\nThe report at the end will show you if an incore assembly of this\nparticular code would have been safe, considering the amount of\nREGION that you are running with.\n\n      These constitute most of the REPORTING CHANGES in the full\nassembly listing itself.  The SYSTERM file was also changed around\nconsiderably, to enhance its usefulness to the programmer.\n\n      The SYSTERM file is intended to provide a summary of the\nsuccess or failure of the assembly to the programmer.  As its name\ndescribes, the output of necessity has to be SHORT, so a programmer\nat a \"limited view\" terminal can check the assembly quickly.\n\n      Most of the SYSTERM changes in the SLAC Assembler were designed\nto remove the clutter, from what should be a simple listing.  I'll\njust mention a few of the changes.\n\n      The DECKID (name field of the first TITLE card) is printed\non each SYSTERM summary, to help avoid confusion when doing multiple\nassemblies in one run with the BATCH assembler option.\n\n      A \"clean\" SYSTERM listing now contains only the statements,\n\"ASSEMBLER DONE\" and \"NO STATEMENTS FLAGGED\".  The rest is suppressed\nfor the sake of clarity.\n\n      For errors in macro calls, the SYSTERM is simplified and made\nto look more like the assembler listing.  Only essential material to\ndiagnose problems is printed.\n\n      Up till here, we have described enhancements to the REPORTS\nof the assembler, but not to the LANGUAGE ITSELF.  The SLAC Mods\nhave introduced new freedom in the macro language and in conditional\nassembly.  In open code, there is a completely new concept of\n\"LABELED USINGS\" and \"QUALIFIED USING REFERENCES\" which force an\naddress to be resolved by a PARTICULAR active USING, when several\nare active at the same time.  This construct prevents unnecessary\nextra tying-up of registers to resolve addresses.  More details\non these LANGUAGE CHANGES can be found with the SLAC Assembler\ndocumentation.\n\n      Run-time changes, besides the possibility of forcing in-core\nassemblies, include the possibility of using an ASSEMBLER SYSPRINT\nEXIT.  Also, it is no longer necessary to have the macro library\nwith the LONGEST LRECL FIRST in the SYSLIB CONCATENATION.  The new\nassembler is smart enough to find the library with the longest record\nlength in the concatenation, and to allocate the size of its buffers\naccordingly.\n\n      Now comes an attitude question, which probably all of you are\nhaving in one way or another.  Frankly, I am happy to use the SLAC\nAssembler FOR THE REPORT CHANGES, but I AM AFRAID TO USE THE NEW\nLANGUAGE IMPROVEMENTS, for fear that IBM will not pick up on these\nenhancements, and I WILL NOT BE ABLE TO TRANSPORT ANY EXTENDED CODE\nto a place that has the \"ordinary\" assembler only.  What can we do\nabout this situation?\n\n      I am therefore urging you to do two things, if you wish to help\nyourself.  Number one, if you are licensed for Assembler H Version 2\nfrom IBM, make an effort to acquire the SLAC Assembler too.  The\nreporting enhancements will quickly make your programming jobs easier\nand more enjoyable, WITH THE EXISTING ASSEMBLER LANGUAGE.\n\n      Second, please urge your IBM \"Systems Engineer\" to file a\n\"PASR\" ENHANCEMENT REQUEST with the Assembler H development group,\nto absorb the SLAC enhancements for Assembler H Version 2 into the\nmain IBM product.  THEN, EVERYONE WILL GET THE BENEFIT, and the\nburden of supporting the mods for new assembler changes will be\nlifted from non-IBM responsibility.  We'll also be able to use the\nnew language extensions and the efficient register usage, without\nfear of portability problems.  IBM has a good record of responding\nto A MASS of PASR REQUESTS.  If you take the time to cast your vote,\nIBM will surely feel the pressure and the need for the changes.\n\n      Meanwhile, there exists a version of source updates, now in\nbeta-test, that combines the unchanged SLAC Mods with the new ESA\nopcodes.  This has been coordinated with further updates that\ncorrespond to Assembler H source changes through PUT Level 8902.\nSeveral obstacles must be cleared before I can inform licensees of\nAssembler H Version 2 how to get this new set of updates.  I hope to\nbe able to get more info to you soon, hopefully by next month.\n\n      Good luck in all your endeavors.  See you next month.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL8910OC": {"ttr": 4612, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93!\\x0f\\x00\\x93!\\x0f\\x12\\x01\\x02\\xd0\\x02\\xd0\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "1993-07-29T12:01:00", "lines": 720, "newlines": 720, "modlines": 0, "user": "SBGCSC"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          October 1989\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n\n\n\n      This month, I am very pleased to talk about one of my favorite\ntopics.  Our subject concerns how nearly every MVS shop can be\nequipped to VIEW JOBS AND PRINTOUT DIRECTLY FROM SPOOL.  It does not\nmatter whether your shop has JES2 or JES3.  The equipment is there,\nand SOME VERY GOOD SOFTWARE IS FREE, TOO!  I'll hopefully show you\nwhat the appropriate software products are, how to get them, and\nsome of the things they can do.\n\n      The time-honored means of viewing job output from a TSO\nsession is the use of the TSO \"OUTPUT\" command, which can be used\nfor looking ONLY at completed jobs, and ONLY output which has been\nqueued to special \"TSO-held\" output classes.  The \"ISPF 3.8 option\"\nis merely a formalization and packaging of the results of the OUTPUT\ncommand, with the printout being written to an allocated file, and\nthe file ISPF-browsed.  Running jobs cannot be viewed at all.\nNeither can jobs whose output was not initially queued to a \"held\"\noutput class.  In all cases using this method, \"REAL SYSOUT\" sitting\non the spool is not seen; only COPIED IMAGES WRITTEN FROM SPOOL to\neither an allocated file, or to the terminal, are what can be\naccessed by the user.  Fortunately for us in a more \"modern\" era,\nthere are better ways of looking at your jobs.\n\n      IBM's contribution to \"spool-viewing\" and \"spool-handling\" is\ncalled SDSF, which (depending on release) stands for \"Spool Display\nand Search Facility\", or \"System Display and Search Facility\".  SDSF\nworks only for JES2, and is supported for all of the recent JES2\nrelease levels.  It affords a great deal of control and usability in\nlooking at spool files, and it offers very considerable power for\nrerouting output, changing classes and altering other parameters of\noutput jobs.  SDSF can also be used for VIEWING RECENT CONSOLE\nMESSAGE OUTPUT of the hardcopy syslog.  It offers the nice feature\nof splicing buffered SYSLOG material WHICH HAS NOT YET BEEN WRITTEN\nTO SPOOL to the end of the actual files on spool, SO THAT\nUP-TO-DATE, SEAMLESS AND CURRENT CONSOLE IMAGES ARE ALWAYS AVAILABLE\nTO THE VIEWER.  The TSO user can thus view the current console\nscreens and enter MVS and JES2 commands.\n\n      SDSF is not cheap, however, so that many shops have either\ngotten another vendor product called \"IOF\" (Interactive Output\nFacility from Triangle Systems Inc. in Research Triangle Park, NC)\nwhich is somewhat less expensive, or have chosen the course of\n\"doing without\".  Since IBM and (to my knowledge) other vendors have\npretty much neglected to supply similar equipment for JES3, we have\nthe lower-budget JES2 shops and most JES3 shops doing nothing at all\nto further assist their programmers.\n\n      THIS LATTER COURSE OF NON-ACTION IS COMPLETELY UNNECESSARY,\nas we shall show, and I'm fairly sure that just about every MVS\nshop can help itself to \"view spool from spool\", even for JES3.\n\n      The JES2 \"freebie\" programs for viewing spool are varieties\nof a program called \"QUEUE\".  Several flavors and variations of\nQUEUE exist, and are readily available to the public.  As for all\nprograms of this type, a different version of the program must be\ninstalled depending on the release level of JES2 which you have.\nThat's because internal format of SPOOL and checkpoint files varies\nconsiderably from release to release.  As of the present writing,\nversions of QUEUE for supported, old, and new levels of JES2\n(including the ESA version 3.1) can be found on either the JES2\nSHARE Mods Tape (Skip Robinson - (818) 507-3358) or on the CBT MVS\nMods Tape (Arnold Casinghino - (203) 244-5495).  There is even a\nJES2 tape (that was obtainable from the now defunct \"SPLA\") which has\nmods for \"ancient\" (non-SP) JES2 releases.\n\n      The JES3 product, called \"SDF\" or Spool Display Facility,\nruns under ISPF.  It is a very sophisticated product with large\ncapabilities, and IT IS FREE SOFTWARE.  SDF is supported by\nBruce Engle in the San Francisco area of California, and it can\nbe found (two versions) on the JES3 SHARE Mods tape (Alan Field -\n(314) 839-9440).  YOU DO NOT HAVE TO BE A \"SHARE\" OR \"GUIDE\"\nMEMBER to obtain any of these tapes.  FILE15 of that tape has\nan older, non-XA version of SDF, while FILE21 contains the fully\nsupported, modern XA version that has gone through nine release\nlevels in the past two and a half years.\n\n      QUEUE, for JES2, was largely originated by Robert Jinkins,\nformerly of the Oak Ridge National Laboratory, and now of IBM.  Its\nversions have had many contributors and modifiers (including me).\nIn our discussion, we shall use people's names to refer to the\ndifferent versions, even though this is somewhat unusual.  However,\nthis is actually the way that many people think of the product.\n\n      Plain \"garden variety\" QUEUE is known as \"Jack Schudel QUEUE\",\nafter good old (not so old) Jack Schudel of the University of Florida,\nwho is one of the premier knowledgeable non-IBM JES2 people.  It is\nlargely this version that I'll talk about here.  There is a somewhat\nextra-featured variety known as \"Leonard Woren QUEUE\" (or USC QUEUE,\nbecause Leonard Woren is at USC in California).  Leonard Woren's\nQUEUE is a transformation of the older program, made to look and act\nmore ISPF-like in its appearance and help features.  Guy Albertelli\nof B.F. Goodrich in Akron, Ohio has made ISPF-ized versions of both\n\"Jack Schudel QUEUE\" and \"Leonard Woren QUEUE\".  Albertelli's\nversions use ISPF browse facilities to display output, and can be run\nin one split-screen of an ISPF session.  The other varieties send\ntheir displays directly to the full terminal, and are completely\nindependent of ISPF.\n\n      QUEUE is designed to be cognizant of different levels of\nuser authorization.  Most users can only view their own output\n(jobname = userid + one character).  More privileged users can\nget access to other jobs (started tasks and TSO users included)\nand their associated spool files.  Installers can readily customize\nauthorization levels, whose programming is quite obvious in the\nsource code of all varieties.  If QUEUE is run as an APF authorized\nprogram, it has more power (to requeue, cancel, and delete jobs)\nthan if it is running non-authorized (purely \"looking\" functions\nonly).\n\n      Now let's look and get an overview of how these programs\nwork.  JES output (for both JES2 and JES3) is broken up into units\ncalled \"datasets\".  Each \"dataset\" corresponds roughly to one DDNAME\ndirected to SYSOUT, or to an output produced by the operating system\nfor JES itself.  QUEUE and SDF both, concentrate on displaying\nindividual JES datasets, one at a time, rather than concatenating\nthem together, as do paper printouts and ISPF option 3.8.  This is\nabout the only flaw in QUEUE, that it cannot display all the JES2\ndatasets for a job, concatenated together.  BUT IT CAN ALLOW THE\nVIEWING OF JUST ABOUT ANY PART OF A JOB THAT IS SITTING ON A SPOOL\nFILE, EVEN IF THE JOB IS NOT COMPLETE, AND IT DOES NOT MATTER\nWHETHER OR NOT THE SYSOUT IS IN A \"HELD\" CLASS.  ANYTHING ON SPOOL\nCAN BE VIEWED (even JES2 control blocks) if it is there.  That is\nthe advantage of the programs of this type.\n\n      We shall first discuss the JES2 products called QUEUE, and\nthen we'll mention some features and capabilites of the JES3 product,\nSDF.  I myself run a JES2 shop, so that the JES3 readers should\nendeavor to fill in more of the details about SDF for themselves.\n\n      The standard QUEUE TSO-command has four HELP screens, which\nhave been presented in Figure 3.  The word HELP, or ANY INVALID\nCOMMAND, will invoke the first HELP screen.  Successive ENTER\ncommands will step the user through the rest of the screens in a\ncycle.  These screens contain the commands to exploit the\nconsiderable capabilities of the program.  My aim here is to lead\nthe user through some of the everyday commands for normal use, just\nso you see some of what QUEUE will let you do.  The finer details\ncan largely be discovered from the commands in the help figures.\n\n      The \"starter\" commands, from the first help screen, are STAT\n(or ST), LIST (or L), and PDDB.  With these three commands, you can\nbegin looking at jobs.\n\n      STAT lists all jobs, TSO users, and started tasks beginning\nwith the letters you supply.  For example, \"ST TS\" would show all\njobs, STCs and TSO users whose names begin with the letters \"TS\".\nFrom this list, JOB NUMBERS are displayed, and if you are interested\nin looking at a certain job (if the name is not unique), the job\nnumber can be used.\n\n      PDDB displays ALL JES2 DATASETS CONNECTED WITH A GIVEN JOB.\nFor example, the command \"PDDB 3438\" would yield a list of output\ndatasets connected with JOB 3438 (or TSO 3438, or STC 3438) if such\na job, STC, or TSO user exists in that JES2 system.  Figure 1 will\nillustrate the result of a PDDB command.  From the figure, it is\nclear that dataset id (or DSID) 102 contains the main output of the\nprogram that has run.  To see this output, we enter \"LIST 3438 102\",\nor \"L * 102\", where \"*\" means 'the current job'.  Since we had\npreviously entered the \"PDDB 3438\" command, QUEUE 'knows' that 3438\nis the current job.\n\n      Now suppose we wanted to check the condition code of the job\nsteps.  We enter a LIST command for DSID 4, the \"substitution JCL\nand run messages\" dataset id.  The command would be:  \"L 3438 4\".\nHaving obtained this dataset id, we could issue a FIND command for\nthe word \"CODE\", which will usually show a line containing a step\ncondition code.  An even better means of using QUEUE to display all\nthe step condition codes is with the 'find all' command called \"FALL\".\nIf we issue \"FALL CODE\", we obtain ONLY THE OUTPUT LINES CONTAINING\nTHE STRING \"CODE\".  See Figure 2 for an example illustrating a\nmulti-step job.\n\n      QUEUE can display all non-held OUTPUT with the command \"DO\",\nwhich means 'display output'.  HELD OUTPUT is displayed with the\ncommand \"HO\".  Current jobs running in initiators are shown with\nthe command \"XI\".  Jobs either running, or awaiting an initiator,\nare shown by the command \"DI\" (or 'display input').  Any dataset id\ncurrently being displayed by QUEUE can be hardcopy printed with the\ncommand \"SPIN\" (to spin off output to a local printer).  The\ncurrently displayed dataset id can be written to a disk dataset with\nthe \"SAVE\" command.  The SAVE command needs operands.  For example,\n\"SAVE AB CD\" would write the DSID being displayed to a new dataset\n(on a STORAGE volume) called 'userid.AB.CD'.  If only one operand is\nsupplied to the SAVE command, the second operand is assumed to be\n'DATA'.  Therefore, \"SAVE AB\" would save the DSID to the new\ndataset:  'userid.AB.DATA'.  If that dataset name is already\ncataloged, or exists on the storage volume, the message:\n        \" *** UNABLE TO ALLOCATE DATASET ***\nwill appear.  The user need only to enter another SAVE command, this\ntime specifying a completely new dataset name, and that DSID will be\nsaved to the new name.\n\n      (In Leonard Woren QUEUE and in the JES3 product SDF, \"COPY\"\nis the command equivalent to \"SAVE\".)\n\n      Besides doing ordinary displays, QUEUE can do other things.\nThe recent system console messages residing on JES2 spool can be\nshown using the command:  \"SLOG\".  This command will display the\ncontents of the current DSID for the SYSLOG task.  Most recent\nmessages from the console, which are still in buffers in memory, and\nwhich have not yet \"made it\" to the spool, will not be shown by the\nQUEUE program; QUEUE can list only data on the JES2 spool.  IBM's\nSDSF WILL show that data, as I mentioned before.\n\n      More esoteric things that QUEUE will show are JES2 control\nblocks, for example:  the JQEs, IOT, JCT, JOEs, and HCT save area\nfor a job.  Any block from SYS1.HASPACE can be displayed in hex and\nEBCDIC, with the command \"XB\", if you know its location.  Some of\nthese locations are shown in the PDDB display (Figure 1).  Thus, the\ncommand, \"XB 02052305\" will display the block on spool, containing\nthe original JCL of the job 3438 shown in the figure.\n\n      QUEUE can be invoked to look at spool belonging to a different\nactive JES2 system or belonging to a system that is down.  We have an\nMVS TEST system that runs VIRTUAL=VIRTUAL under VM.  Most of the\ntime, that system is down.  Even when it is up, I often don't even\nhave to bring up TSO under that Test System.  What I do is, I edit\nthe jobs I want to submit using my regular MVS system's TSO, and save\nthose jobs to disk.  Then I submit the jobs from the Test System by\nusing TSSO (Time Sharing Subsystem Option - Version 4.3 from the CBT\nMVS Mods tape - file 401) using the Test System OPERATOR CONSOLE.  To\nlook at the jobs, I run QUEUE from MY NORMAL TSO, but POINTED TO THE\nCHECKPOINT FROM THE TEST VOLUME SPOOL.  It works fine.  I can't\nrequeue or delete any jobs from there, but then, I have the Test\nSystem Console to do that from.\n\n      I once solved a tough JES2 routing problem by using QUEUE to\ndisplay a job's JCT.  Since the routing information for the job is\ncontained in that JES2 control block (not to be confused with MVS's\nJCT control block), I could figure out the ultimate destination of\nthe output without actually letting it fly over the network.\n\n      People trying to write a JES2 EXIT 6 routine (internal text\nscan) will gain invaluable help from QUEUE, which displays internal\ntext for a job (it is DSID number 5 for every job).  This internal\ntext can be written to a disk dataset with the SAVE command, and\nstudied, for the purpose of writing the exit.\n\n      I have to conclude my treatment of QUEUE here, because of space\nconsiderations.  The version we have described is Jack Schudel's\nQUEUE, which is available for many different releases of JES2, and\nwhich is probably the most clean and standard version.  In Jack\nSchudel QUEUE, you can literally \"go from anywhere to anywhere\" with\none command, since there is no hierarchy structure defined.  Leonard\nWoren tried to introduce an ISPF-like appearance to QUEUE, and he\noptionally preserves quite a bit of what you are currently doing, so\nthat the user can explore the structure of a job by stages, first\nlooking at the DSIDs (Leonard changed the PDDB command to just \"DD\")\nand then LISTing them directly with LINE COMMANDS from the \"DD\"\nscreen.  Leonard also changed the HELP structure to consist of a full\nscreen of tutorial for each separate command. I really don't have more\nspace to devote to QUEUE here.  I can only implore our esteemed\nreadership to obtain the tapes, install the QUEUEs, and explore. It\nwill be rewarding.\n\n      Now for the JES3 people.  SDF is a marvelous product that does\nfor JES3 users, something equivalent to what SDSF and QUEUE combined,\ndo for JES2 users.  For the XA version (the really sophisticated one),\nBruce Engle has gone through nine releases in the past two and a half\nyears!  I am including (Figure 5) a list of some of his upgrades\nthroughout the nine releases.  This will give the JES3 people some\nmaterial to look at, that will show them what SDF can do.  I must\napologize again that I cannot run SDF at my (JES2) shop, but I'll\nmake an attempt to mention some of its capabilities.\n\n      SDF is a TSO command processor which runs as an ISPF dialog.\nAs its primary dialog menu (Figure 4) shows, SDF contains complete\nqueue search, job display, and output display facilities.  It has the\nability to display a copy of the JES3/MVS consoles and enter console\ncommands, and it has an interface to the TSO/E TRANSMIT/RECEIVE\nfunctions.  In addition, it has access to the JES3 Job Zero output,\nwhich is produced by internal JES3 functions, and which is unique to\nJES3.\n\n      ISPF browse facilities are used throughout SDF operation.\nOutput requeue, cancel, transmit, and copy (or save to disk or\nsysout) are conveniently done, and are easily available.  The\nfacilities are very extensive, and users have told me that SDF is\nvery easy to use, besides having such full function.\n\n      Space is limited for me here to further enumerate details of\nSDF operation.  I will include a list of some of the recent\nenhancements to the product, so that a JES3 user, who is involved\nin the details, can get an idea of what has been added, and can\nlearn more particulars of what the product can do.  This material is\nshown in Figure 5.\n\n      Good luck with trying these helpful products.  If you don't\nhave some \"spool-browse\" software of this type installed, I'm\nabsolutely certain that an investigation of these products will yield\nmuch reward for your shop, and the gratitude of many users.\n\n\n    *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFigure  1.          DISPLAYING THE JES2 DATASETS FOR A JOB\n\n\nQUEUE COMMAND - PDDB 3438\n    DSID F1  RECORDS C    MTTR    PROCNAME STEPNAME DDNAME\n       1 6A       20 T 02052305                     $JCL      (Original JCL)\n       2 23       17 T 02052407            JES2     $JES2LOG  (JES2 Log    )\n       3 03       20 T 02052304            JES2     $JCLIMG   (Expanded JCL)\n       4 03       43 T 02052401            JES2     $SYSMSGS  (Run Messages)\n       5 08        0 A 02052404            JES2     $INTTEXT  (Internal Text)\n       6 08        0 A 02052408                     $JOURNAL  (Internal Jrnl)\n     101 08        4 T 02052307            STEP1    SYSIN     (SYSIN dataset)\n     102 03      658 T 02052501            STEP1    SYSPRINT  (SYSPRINT  DD)\n     103 00        0 A 00000000                     SYSUDUMP  (SYSUDUMP  DD\n                                                                  (unopened))\n\n\n\n\n\n\n\n\nREPLY -\n\n    *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFigure  2.      DISPLAYING CONDITION CODES FOR A MULTI-STEP JOB\n\n\nQUEUE COMMAND - FALL CODE\nJOB 2029    , DSID        4, REC #     369, END OF DATA. LAST REC #     382\nIEF142I TSTBMP2S CLEARSYS - STEP WAS EXECUTED - COND CODE 0000\nIEF142I TSTBMP2S S01COPY CNTL - STEP WAS EXECUTED - COND CODE 0000\nIEF142I TSTBMP2S S01CMPRS CNTL - STEP WAS EXECUTED - COND CODE 0000\nIEF142I TSTBMP2S S01COPY DATA - STEP WAS EXECUTED - COND CODE 0000\nIEF142I TSTBMP2S S01CMPRS DATA - STEP WAS EXECUTED - COND CODE 0000\nIEF142I TSTBMP2S S01COPY PROFILE - STEP WAS EXECUTED - COND CODE 0000\nIEF142I TSTBMP2S S01CMPRS PROFILE - STEP WAS EXECUTED - COND CODE 0000\nIEF142I TSTBMP2S S01COPY COBOL - STEP WAS EXECUTED - COND CODE 0000\nIEF142I TSTBMP2S S01CMPRS COBOL - STEP WAS EXECUTED - COND CODE 0000\nIEF142I TSTBMP2S S01COPY ASM - STEP WAS EXECUTED - COND CODE 0000\nIEF142I TSTBMP2S S01CMPRS ASM - STEP WAS EXECUTED - COND CODE 0000\nIEF142I TSTBMP2S S01COPY BCOBOL - STEP WAS EXECUTED - COND CODE 0000\nIEF142I TSTBMP2S S01CMPRS BCOBOL - STEP WAS EXECUTED - COND CODE 0000\nIEF142I TSTBMP2S S01COPY NSRSCNTL - STEP WAS EXECUTED - COND CODE 0000\nIEF142I TSTBMP2S S01CMPRS NSRSCNTL - STEP WAS EXECUTED - COND CODE 0000\nIEF142I TSTBMP2S S01COPY PUTPDS - STEP WAS EXECUTED - COND CODE 0000\nIEF142I TSTBMP2S S01CMPRS PUTPDS - STEP WAS EXECUTED - COND CODE 0000\n\n\n\n\nREPLY -\n\n\n    *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFigure  3.\n\n\n                 STANDARD QUEUE PROGRAM CAPABILITIES\n\n                           (from Albertelli version of Schudel QUEUE)\n\nQUEUE HELP - Screen 1:\n\n\nQUEUE COMMAND - HELP                                             C= 078 D= 007\nTHE FOLLOWING SUBCOMMANDS ARE SUPPORTED:\n    END               - EXIT QUEUE COMMAND\n    STAT LEVEL        - DISPLAY ALL JOBS BEGINNING WITH LEVEL\n    DJ   JOBNAME      - DISPLAY JOB BY JOBNAME\n    JCL  JOBNAME      - LIST JCL FOR A JOB\n    JLOG JOBNAME      - LIST JOBLOG FOR A JOB\n    JMSG JOBNAME      - LIST SYSTEM MESSAGES FOR A JOB\n    JHIS JOBNAME      - LIST JOB HISTORY INFORMATION\n    DD   JOBNAME      - LIST SYSIN/SYSOUT DATASETS FOR A JOB\n    PDDB JOBNAME      - LIST PDDB'S FOR A JOB\n    LIST JOBNAME DSID - LIST A SYSIN OR SYSOUT DATASET\n    LIST * +/-N       - LIST NEXT OR PREVIOUS N'TH DATASET\n    SAVE DSN <DSTYPE> <VOSLER>  - COPY CURRENT DATASET TO DISK\n    SPIN CLASS        - SEND COPY OF CURRENT DATASET TO SYSOUT\n    PRINT ON CLASS DEST  - OPEN SCREEN LOG\n    PRINT             - PRINT CURRENT SCREEN\n    PRINT OFF         - CLOSE SCREEN LOG\n    MODEL #           - SET 3270 MODEL 2, 3, 4, OR 5\nNOTES:  (1) DEFAULT FOR LEVEL IS LOGON ID\n        (2) JOBNAME CAN BE JOBNAME, NUMBER, OR \"*\" FOR CURRENT JOB\n        (3) DSID CAN BE DETERMINED BY USING SUBCOMMAND DD OR PDDB\n        (4) DSN WILL BE EXPANDED TO PREFIX.DSNAME.DATA\nREPLY -\n\n    -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -\n\n\nQUEUE HELP - Screen 2:\n\n\nQUEUE COMMAND - HELP                                             C= 078 D= 007\nTHE FOLLOWING SUBCOMMANDS ARE SUPPORTED:\n    PFK               - LIST PROGRAM FUNCTION KEYS\n    PFK  NN  TEXT     - REDEFINE PROGRAM FUNCTION KEYS\n    SBSY TEXT    - SWITCH TO SUBSYSTEM NAMED 'TEXT'\n    FIND 'STRING' COL(SS,EE)  - FIND CHARACTER STRING\n    FALL 'STRING' COL(SS,EE)  - FIND ALL OCCURRENCES OF\n                                  STRING (COL DEFAULTS TO ALL)\n    COL  #       - REPOSITION HORIZONTALLY TO COLUMN NUMBER\n    @/MD #       - REPOSITION TO SPECIFIC RECORD NUMBER\n    +/D  #       - REPOSITION FORWARD IN DATASET # RECORDS\n    -/UP #       - REPOSITION BACKWARD IN DATASET # RECORDS\n    T/TOP        - REPOSITION TO TOP OF DATASET\n    B/BOTTOM     - REPOSITION TO BOTTOM OF DATASET\n    HF/HB #      - FORWARD/BACKWARD # HALF PAGES\n    PF/PB #      - FORWARD/BACKWARD # PAGES\n\nNOTES:  (1) STRING SPECIFICATION FOR FIND MAY BE DELIMITED\n            WITH BLANKS, SINGLE QUOTES, OR DOUBLE QUOTES.\n\n\n\n\nREPLY -\n\n    -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -\n\n\nQUEUE HELP - Screen 3:\n\n\nQUEUE COMMAND - HELP                                             C= 078 D= 007\nTHE FOLLOWING SUBCOMMANDS ARE SUPPORTED:\n    DA           - DISPLAY ALL JOBS IN EXECUTION\n    DT           - DISPLAY TSO USERS\n    DS           - DISPLAY SYSTEM TASKS\n    DC TYPE      - DISPLAY CPU BATCH/STC/TSO  (BLANK,B/J/S/T)\n    DQ           - DISPLAY INPUT QUEUES\n    DI CLASS     - DISPLAY ALL JOBS IN INPUT CLASS\n    AI CLASS     - DISPLAY JOBS AVAILABLE FOR PROCESSING\n    HI CLASS     - DISPLAY HELD JOBS IN INPUT CLASS\n    DF           - DISPLAY OUTPUT QUEUES\n    DO CLASS     - DISPLAY ALL JOBS IN OUTPUT CLASS\n    WO           - DISPLAY ONLY OUTPUT JOBS WITH WRITER NAME SPECIFIED\n    AO CLASS     - DISPLAY AVAILABLE OUTPUT\n    HO CLASS     - DISPLAY HELD OUTPUT\n    NJ           - DISPLAY NJE INPUT AND OUTPUT QUEUES\n\n        DEFAULT FOR CLASS IS ALL CLASSES\n\n    CAN JOBNAME <P>        - CANCEL JOB (\"P\" OPTION FOR PURGE)\n    DEL JOBNAME            - DELETE JOB\n    REQ JOBNAME <NEWCLASS> - RELEASE JOB'S HELD OUTPUT\n\nREPLY -\n\n    -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -\n\n\nQUEUE HELP - Screen 4:\n\n\n\nQUEUE COMMAND - HELP                                             C= 078 D= 007\nTHE FOLLOWING SUBCOMMANDS ARE SUPPORTED:\n    SLOG  ID  <SEQ>   - LIST THE SYSTEM LOG DATASET\n    FTIME HH.MM.SS    - REPOSITION SYSTEM LOG TO GIVEN TIME\n        ID MAY BE A JOB# DETERMINED BY STATUS SYSLOG,\n          OR IT MAY SPECIFY THE SYSTEM ID OF THE DESIRED SYSTEM\n          (A NULL FIELD WILL LIST THE ACTIVE SYSTEM'S LOG)\n        DEFAULT FOR SEQ IS 0 (THE CURRENT SYSLOG DATASET)\n          (USE A VALUE OF 1, 2, ... TO OBTAIN PREVIOUS DATASETS)\n\n    TSO CMD PRMS      - ISSUE ANY TSO COMMAND W/OPTIONAL PARMS\n    XB  MTTR          - DISPLAY BLOCK FROM SYS1.HASPACE\n                          USE \"*\" TO RE-SHOW AND \"+\" TO CHAIN\n    XC                - DISPLAY MASTER CONSOLE AND WEQS\n    XD  JOBNAME DSID  - UNRESTRICTED DISPLAY OF DATASETS\n    XI                - DISPLAY ACTIVE INITIATORS\n    XJ  JOBNAME       - DISPLAY UNINTERPRETED JQES AND JOES\n    JQE JOBNAME       - DISPLAY JQE IN HEX/EBCDIC\n    JCT JOBNAME <OFFSET>  - DISPLAY JCT IN HEX/EBCDIC\n    IOT JOBNAME       - DISPLAY IOTS IN HEX/EBCDIC\n    JOE JOBNAME       - DISPLAY JOES IN HEX/EBCDIC\n    HCT               - DISPLAY HCT $SAVE AREA\n    TGPS              - LIST HIGH TRACK GROUP USERS\n\nREPLY -\n\n\n    -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -\n\nFigure  4.  SDF PRIMARY OPTION PANEL\n\n\n------------ SPOOL DISPLAY FACILITY 2.8 - PRIMARY OPTION MENU ------------------\nOPTION ===>\n\n   J  JOBS     - Job queue search\n   O  OUTPUT   - Output queue search\n   N  NUMBER   - Search by job number\n   L  LOG      - System Log display (also LB for browse or LL for list)\n   R  RECEIVE  - Receive data sets\n   Z  ZERO     - Display JES3 job zero\n   B  BROWSE   - Browse hexadecimal spool data\n   C  CONSOLE  - Console display\n   P  PARMS    - Set SDF parameter defaults\n   K  KEYS     - Set PF key definitions for SDF\n   T  TUTORIAL - Display information about Spool Display Facility\n   U  UPDATES  - Summary of changes to Spool Display Facility\n\n\n\nEnter the END command to return to the previous panel\n\n\n    -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -\n\n\nFigure  5.       SOME SDF RELEASE ENHANCEMENTS  (a partial list)\n\n\nVERSION 2.8 - 04/89\n\no   TRANSMIT option enhanced to support Interactive Data Transmission\n    Format (IDTF).\n\no   SDF now supports spanned records on spool (PSF data sets).\n\no   Reprint (copy to SYSOUT) option now allows user to specify an\n    OUTPUT statement reference and character set.\n\no   COPY (to data set) option now allows user to specify \"ANY\" for\n    data set disposition. This will replace a data set if it exists\n    or automatically create one if it does not exist.\n\no   New option on RECEIVE function which allows user to copy a data set\n    waiting to be received into a DASD data set.\n\nVERSION 2.7 - 12/88\n\no   New function (primary option O) for searching JES3 output queue.\n\no   New function (primary option Z) to display JES3 job zero.\n\no   New options which allow user to bypass SYSLOG selection list and\n    browse active SYSLOG data set directly.\n\no   Changed to support 5-digit job numbers.\n\nVERSION 2.6 - 07/88\n\no   New RECEIVE function to search, browse, receive, and delete data\n    sets waiting to be received.\n\no   Support added for copying data into partitioned data sets.\n\no   User may now copy into existing data sets with either fixed or\n    variable length records and can have any record length and block\n    size.\n\no   New \"confirm delete\" field in the SDF parameter options panel will\n    allow the user to optionally prompted with a confirmation panel\n    whenever a request is issued to delete all output or cancel a job.\n\no   User may now specify 'STC' in userid field to search for started\n    tasks or 'JES3' in userid field to search for JES3 DSP jobs.\n\no   New MAP parameter and MAP command to display a storage map of SDF\n    entry points and data areas. Enables SDF execution to be traced\n    under VM using CP TRACE command.\n\no   SDF now supports record lengths greater than 255.\n\no   Performance and buffer handling improvements.  QSAM I/O has been\n    converted to BSAM.\n\no   Support included for JES3 2.2.1.\n\nVERSION 2.5 - 01/88\n\no   New option 'L' to list all step completion codes and summary\n    messages for job from the job selection list.\n\no   User may now specify a print class for the 'P' print option on the\n    job selection list by entering 'Pc' where 'c' is the output class.\n\no   New SKIP command which allows the user to skip between data sets\n    from within ISPF browse.\n\no   New FORMAT field on job selection list and data set selection list\n    panels to specify display format.\n\no   Data set selection list now has three formats: SHORT/LONG/XLONG.\n    SHORT form includes SYSOUT data sets only.\n\no   SORT command now allows specification of either ascending or\n    descending sequence.\n\nVERSION 2.4 - 10/87\n\no   New UPDATE command to update status of all jobs on the current job\n    selection list without rereading the entire JCT.\n\no   Changed to retain purged jobs on job selection list (in *PURGED\n    status) until UPDATE or REFRESH command is issued.\n\no   New SNAP command to take a snap dump for diagnostic purposes from\n    any panel while in SDF.\n\no   New TUTORIAL command to access the SDF tutorial from any panel while\n    in SDF.\n\no   Copy, transmit, and reprint functions now allow the user to copy\n    selected portions of a data set by line number.\n\no   Copy, transmit, and reprint functions now allow the user to copy\n    data from one job to multiple locations. It is no longer necessary\n    to exit from the data set selection list and enter it again.\n\no   RACF and ACF2 versions of user exits combined into common source\n    members.\n\no   New expanded parameter lists passed to security exits.\n\no   SDF now checks the security user id for a job as well as the\n    submitting TSO user id for access authorization.\n\no   SDF now requires a Type 3 SVC (SDFSVC).\n\nVERSION 2.3 - 07/87\n\no   Added ISPF REFRESH command to refresh data set contents from within\n    ISPF browse.\n\no   Esoteric unit name for temporary browse data set may be specified by\n    the user on the SDF Parms panel.\n\no   Improved formatting of JCT in control blocks display.\n\no   Added FRP, JVT, DJST, and dynamic allocation JST to control blocks\n    display.\n\no   SDF may now be called recursively from within SDF.\n\nVERSION 2.2 - 04/87\n\no   Added new console display function which dynamically displays SYSLOG\n    messages in a scrollable area and allows authorized users to enter\n    JES3 commands.\n\no   New RETRIEVE function for recalling up to 8 previous JES3 commands\n    to the command line as in VM.\n\no   New AUTO command to set automatic scrolling on console display.\n\no   New FIND command which allows user to search for character strings\n    in the console display buffer.\n\no   New LOCATE command which allows user to scroll to a specified time\n    location within the console display buffer.\n\no   Added new options to place jobs on hold and to release jobs from\n    hold.\n\no   Improved format for control blocks display.  Each control block\n    section is now displayed separately.\n\no   Modified the spool I/O interface to operate in key 1 to prevent\n    conflicts with writer FSS address spaces.\n\no   SDF now validates all spool data being read to ensure that it still\n    belongs to the job being accessed.\n\nVERSION 2.1 - 03/87\n\no   New option which allows the user to cancel jobs in DJC net hold.\n\no   New option to browse SRF/MRF spool files from main selection panel.\n\no   Allow specification of default destinations for PRINT and FICHE\n    requeue options.\n\no   Changed to use subtask for all requeue/delete/cancel/purge functions\n    instead of generating TSO commands.\n\nVERSION 2.0 - 01/87\n\no   SDF now disallows some options/commands when accessing spool from\n    another JES3 complex.\n\no   Output processing options are now available directly from the job\n    selection list (options O, DH, DW, MH, and MW).\n\no   The SDF main selection panel is now displayed from within the SDF\n    program. This allows access to all SDF functions by issuing the TSO\n    SDF command.\n\no   All load modules are now reentrant and are linked as REFR,RENT,REUS.\n\no   All load modules can now reside above the 16mb line and are linked\n    as AMODE=31,RMODE=ANY.\n\no   SDF now correctly handles spool volumes that have been removed\n    without a JES3 cold start, both when accessing the user's JES3\n    complex and when accessing another JES3 complex.\n\no   When accessing spool on the user's system, I/O is performed by the\n    subtask using the JES3 block I/O service. The I/O subtask performs\n    an asynchronous read-ahead of spool data sets into chained buffers.\n    This results in a marked speed improvement.\n\no   SDFCOPY now calculates BLKSIZE and BUFNO values for the temporary\n    data set.  For devices with track sizes less than 32K, full-track\n    blocking is used. Half-track blocking is used for other devices.\n\no   New internal trace table for debugging purposes.  Trace table is\n    activated by the TRACE parameter.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL8911NV": {"ttr": 4870, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93!\\x0f\\x00\\x93!\\x0f\\x12\\x01\\x01i\\x01i\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "1993-07-29T12:01:00", "lines": 361, "newlines": 361, "modlines": 0, "user": "SBGCSC"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          November 1989\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n\n\n      This month, I would like to begin with an endorsement for a\nunique book, which has helped me for years in my own career.  It has\nrecently come out in a second edition, and is available at a discount\nto NaSPA members.  The book is entitled, \"The Systems Programmer's\nProblem Solver\", by Bill Mosteller, who worked as an MVS Systems\nProgrammer for many years, with a good reputation.  Now, Bill has\ngone into VM, and he works for Systems Center in Virginia.  (I think\nhe still has a good reputation.)  \"Systems Programmer's Problem\nSolver\" is published by QED Information Sciences in Wellesley,\nMass., and NaSPA has an agreement with them for a 15% discount\nto members.  They have an 800 number, 1-800-343-4848.\n\n      The book is composed of tidbits of good advice to people in\nour field.  You do not have to work in MVS to benefit.  As a matter\nof fact, when I first saw a copy, I was a DOS applications programmer.\nBut its down-to-earth approach to the everyday realities of the\nprogramming life, hits home in many ways.  Of course, the MVS SysProg\nwill be in tune with the book on all cylinders, and will benefit\ndirectly from every page.  IT'S MADE FOR US.  But ALL programming\npersonnel will empathize with the points Bill makes, and the stories\nhe tells will strike a receptive chord in the heart of anyone in\nthis profession.\n\n      So I am going to (uncharacteristically) urge you to go out\nand spend a few bucks, and buy the book!  It's practically guaranteed\nto multiply a return on your investment, if you count money saved for\nyour company, \"Brownie points\" for you with your management, and\na general increase in your satisfaction, that you're more competent\nand confident to do your job.  HOLD ME TO IT.  I don't expect (m)any\ncomplaints.\n\n      *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n      Please note an important announcement as part of our topics for\nthis month.  It concerns the Connecticut Bank and Trust (CBT) MVS\nMods tapes, which have saved my company hundreds of thousands of\ndollars over the past few years, and which should be a mainstay of\nevery MVS System Programmer's arsenal.  The hundreds of programs and\nsoftware packages on these tapes, ALL PUBLIC DOMAIN, have provided\ntools to implement many of the suggestions in this column.  Many of\nthese packages provide equivalent or near-equivalent function to\nexpensive vendor packages.  In a few cases, I think that a facility\nprovided on this tape may be EVEN BETTER than anything that is on the\nmarket.\n\n      There has been some uncertainty at CBT, due to a drastic\nreorganization, concerning their ability to reproduce the tapes\nin the quantity necessary to supply our needs.  In response to the\nsituation, Arnold Casinghino (our benefactor, who produces the tapes)\nhas agreed to keep NaSPA supplied with the current versions, so that\nanyone may order them from NaSPA.\n\n      Please get into the habit of ordering the CBT tape from NaSPA,\nif you can.  To offset the slightly increased cost, due to handling\noverhead, we suggest that several installations can pool, to share a\nsingle tape.  The \"Air Force\" TAPE COPYING PROGRAM, on file 229 of\nthe CBT tape, will make up to ten copies of a single tape at the same\ntime--as many copies as you have drives.  Arnie Casinghino himself,\nhas used this program to cut the copies of the tapes that he sends\nout.  OUR AIM IS TO MAKE THE TAPE GENERALLY AVAILABLE, IN ITS CURRENT\nVERSIONS.  There are no restrictions on copying, and we would like to\nsee that the tape be spread around as much as possible, for every\nshop's benefit.\n\n      As far as making new versions of the tape, with changes, Arnie\nwill try to continue doing that as long as he can.  If for some\nreason, Arnie has trouble getting a system on which to do the updates,\nI will endeavor to keep them going myself, as long as necessary.\nNaSPA might then become the main distribution point.  In any case, I\nhope that we can continue to keep the tape current, as a vibrant and\nresponsive vehicle to supply the needs of this profession.\n\n      It is important to make the point that packages on the CBT\ntape have often been kept close to sync with new levels of system\nsoftware.  Original contributors, and others, have bent to the\neffort, and kept many of these programs in touch with modern times.\n(The support, of course, is voluntary, and it varies from package to\npackage.)  Usually, if hundreds of companies use a package, SOMEONE\nis going to fix it for a new level.  (And I'VE BEEN THE ONE, more\nthan once.)  Another consideration:  because the CBT tape has often\nbeen in danger of becoming full, Arnie has gone through a series of\nmass deletions of old files.  THEREFORE, MOST MATERIAL ON THE CBT\nTAPE IS FAIRLY NEW, and there is not much \"dead wood\" on it nowadays.\n\n      So please keep in touch with notices in this column, and we'll\ntry to bring you the latest news concerning the CBT Mods Tape.\n\n      *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n      Now to the month's topic.  First, I sincerely feel that we\nshould publicly appreciate the efforts of Arnold Casinghino, who has\nexerted himself mightily for almost fifteen years to bring us the\nunbelievably rich CBT tape.  This tape has gone through 310 release\nlevels, STARTING FROM VERSION ONE.  I always say that Arnie has to be\na very fine person, because someone who isn't willing to help people,\nwould have weaseled himself away from such a task long ago.\n\n      I personally think (and would welcome correction from our\nreadership), that perhaps 95 percent of MVS installations in this\ncountry possess, in house, programs that are either directly from\nArnie's tape, or which were transported indirectly after originating\nfrom there.  I suspect that the figure is actually higher.  It is a\ngood example for us to ponder, that one person, who sits in one\nchair, could do so much to help so many people and installations,\nsimply by continuing to be \"the swap shop\" for such a length of\ntime.  One man's quiet dedication pays dividends for many.  Thanks,\nArnie.  We wish you well, and hope you can continue to help.\n\n      So in keeping with this, we'll talk about some more software\nitems from the CBT tape that we haven't elaborated on previously in\nthis column.\n\n      Three unbelievably handy software packages to have at your\nside, are TSSO (Time Sharing Subsystem Option), ETPS (Emergency\nTele-Processing System), and CMD1 (Command Subsystem).  I have\nsingled them out, because they are not only convenient tools, but\nthey are of valuable aid in automating operations (in the case of\nTSSO), in monitoring the operation of the system (CMD1), and in\nbailing out the installation in cases of system emergency (all three\npackages).  These three packages HAVE BEEN WRITTEN AS SUBSYSTEMS\nunder MVS, and as such, THEY CAN FUNCTION WITHOUT JES2 OR JES3 BEING\nUP.  Their utility value under circumstances of system distress, as\nwell as under normal conditions, makes for the avoidance of\nstandalone restores and other time-consuming and painful recovery\npractices.\n\n      The function in these packages together, in my estimation, have\nwhat I'd call a \"vendor package replacement value\" of forty to eighty\nthousand dollars to a company.  They are public-domain (not guaranteed\nin writing, etc.), but to obtain equivalent value from vendor\nproducts, an installation might have to spend the aforementioned sum,\nor more.  In addition, most vendor products are not subsystems, and\ncannot be used to fix the system software if there is a problem with\nthe primary subsystem (JES2 or JES3).\n\n      TSSO is found on CBT tape file 401.  A version of CMD1 which\nworks under XA can be found on file 261, and ETPS is a part of file\n353.  The original version of TSSO is distributed on file 306,\nalthough it can be completely replaced by the version on file 401.\nA series of examples in the use of TSSO for automating operations,\ncan be found on file 399.\n\n      TSSO was originally written by Bill Godfrey (his version is on\nfile 306 of the CBT tape) for the purpose of executing TSO commands\nfrom a system operator console.  TSSO in its original form emulates\na TSO environment (with CPPL and other control blocks), so a TSO\ncommand will execute under it.  Responses from TSO commands executed\nunder TSSO will appear on the system console, but only if the\nparticular TSO command does its terminal I/O using the PUTLINE\nterminal interface, and not the TPUT interface.  In either case, the\ncommand would be executed.  However, it is obvious that one should\nchoose TSO commands that use PUTLINE I/O to execute under TSSO, so\nthat the response is reported to the issuer.  One should also note\nthat FULLSCREEN terminal I/O will cause TSSO to abend.  (The system\noperator console is a TTY-type line-oriented environment).  It\nfollows that any TSO command doing fullscreen I/O must not be\nexecuted under TSSO.\n\n      The version of TSSO on file 401 of the CBT tape (the public\nBellcore version 4.3) completely supersedes Bill Godfrey's version.\nThat version of TSSO (which carries a Bellcore copyright notice, but\nwhich is their last release as public-domain software) adds two\nadditional functions.  The main one is AUTOMATION OF CONSOLE\nOPERATIONS, and the second one is CONSOLE SECURITY.  This is in\naddition to the ability to execute TSO commands from the system\nconsole, as mentioned before.\n\n      I recently attended a fascinating session at a large IBM user\ngroup meeting.  The speaker, who was from IBM, did an in-depth study\nof different types of console messages, for the purpose of learning\nhow to use the messages to automatically drive system responses.  The\nvehicle she used for doing the automatic replies (etc.) was IBM's\nNETVIEW(TM), which isn't cheap.  Besides what I learned from her\nincisive and deep observations, I was struck by a big point.  I COULD\nDO EVERYTHING WITH TSSO IN THE WAY OF CONSOLE AUTOMATION, THAT SHE\nSAID SHE HAD DONE WITH NETVIEW!  I know that TSSO cannot do everything\nNetview can.  But I found I COULD do with my TSSO, everything that\nthis speaker mentioned, in the way of using messages to initiate new\nsystem actions.  TSSO has the \"console automation scene\" pretty well\ncovered.\n\n      From the user's point of view, TSSO accomplishes console\nautomation tasks through an assembled and linkedited module, called\nthe AOF (Automated Operations Facility) Table.  The active table can\nbe instantly replaced with a new version or another module, through\nan operator \".RELOAD\" command.  Various types of actions can be\nspecified in the table.  Selected messages can be highlighted,\nlowlighted, or suppressed from the console (but not from the system\nlog).  Also, a message can be used to drive an operating system\naction, such as the execution of a system command.  It is easy, for\nexample, to simulate new system commands.  One merely intercepts the\n\"IEE305I syscmnd COMMAND INVALID\" message from a particular invalid\ncommand, (one can specify the contents of the second word in the\nmessage to key on), and then an \"OSCMD\" reply can be issued to\nperform any action desired.  Then, one merely suppresses the original\n\"COMMAND INVALID\" message from appearing on the console.  Our shop\nuses one such \"invalid command\" to start JES2 with all the required\nparameters.  The operators simply enter one command, and are relieved\nof the responsibility of getting all the JES2 start parameters right.\n\n      Because a TSO-like environment is present in TSSO, IT IS\nPOSSIBLE TO EXECUTE OPERATING SYSTEM COMMANDS OUT OF A CLIST, AND\nRETURN THE RESPONSES BACK TO CLIST CONTROL.  The entire power of the\nCLIST environment can thus be brought to bear on the task of\nautomating console activity.  If you think about it, THIS IS BIG\nSTUFF.  Some examples of what people have done, appear in file 399\nof the CBT tape, but they do not come close to exploiting TSSO's\nfull capability.  As far as we're concerned, the sky's the limit.\nWe're free to use our own inventiveness to the fullest, in this\narena.\n\n      If you're running MVS under VM, a \"CPCMD\" command processor is\nsupplied, to issue VM commands from MVS, that are executed by the\nunderlying virtual machine.  One can inquire about attached devices,\npaths, other VM users, and such.  It is easy to attach or detach\ndevices to MVS and to other machines as needed, too.  VM users can\nfigure the rest out for themselves.\n\n      Just to entice the imagination, I'll cite a few examples of\nwhat people have done:  Vary tape drives online or offline in\nselected bunches, trigger a response or a warning when spool space\ngets too full, reply to WTORs or to sequences of WTORs.  One can\nstart up everything after a new IPL; one can shut down the entire\nsystem in preparation for a new IPL, just with a single CLIST\nexecution.  This is with a single command to initiate each\n\"intelligent\" sequence of actions.  One can set up all the operator\nconsoles to proper (rollable) status at any time.  (At IPL time this\nmay be done in the PARMLIB COMMNDxx member.)  Much manipulation can\nbe accomplished with remotes.  All the initiators can be set up to\ndifferent configurations at different times of the day.  Date\nconversions may be displayed on the console, using the power of CLIST\nstring manipulations.  I must emphasize that these are but a very few\nexamples of what is possible.\n\n      Space prohibits further elaboration of TSSO's console\nautomation capabilities.  The CONSOLE SECURITY feature must get some\nmention, although few installations use it.\n\n      Console security requires that TSSO work together with a data\nsecurity system, such as RACF, ACF2, or Top Secret.  The result of\nconsole security is that OPERATORS HAVE TO LOG ON TO THE CONSOLE\nWITH A PASSWORD, BEFORE BEING ABLE TO ENTER COMMANDS.  This has the\neffect of allowing the installation to track WHICH operators entered\nWHICH commands.  Console security may also be of help for large\ninstallations that have many secondary operator consoles, some of\nthem lying around in user areas.  The feature may do something\nsignificant, in preventing unauthorized persons from entering commands\nat these consoles to manipulate the system.\n\n      Now we'll talk about ETPS, and we'll finish up with CMD1.\n\n      ETPS (or Emergency Tele-Processing System) comes from Brian\nCook of Morton-Thiokol in the Chicago area.  ETPS is a system to do\nNATIVE TERMINAL I/O in the event that important parts of an MVS\ninstallation, such as the primary JES, VTAM, or TSO, will not\nstart.  ETPS supports an ISPF-like BROWSE and EDIT, and allows the\nentry of IDCAMS commands to perform VSAM functions when \"nothing\nelse is up\".\n\n      The idea of ETPS is excellent, and the system really works\nin an emergency, \"grabbing a terminal\" without VTAM or BTAM and\nallowing you to fix the system.  One must watch out, however, because\nnative terminal I/O is not easy to write correctly, and the system has\nsome bugs, especially in the editor.  However, IT CAN BE A LIFE-SAVER,\nand it sure is a handy tool to have around for when you need it.\n\n      In the more recent release of ETPS, the author has front-ended\nit with a TSO command, called ETPSTSO.  This command allows a user to\nuse the ETPS facilities under TSO, so as to gain practice with it\nunder more normal conditions.  If one already is familiar with using\nthe ETPS facilities, one is all the better prepared in the event of an\nemergency.  In short, ETPS is a good thing to have.  The non-price is\nright, and it is one more nice safeguard between us and disaster.\n\n      I might add at this point that one can get around some of the\nnecessity for ETPS, by using a combination of TSSO and the PDS\ncommand (file 182, 296, and 112 of the CBT tape).  If one brings up\nTSSO without JES, (this can be accomplished by \"START TSSO,SUB=MSTR\"),\nTSSO can still run any TSO line command which uses the PUTLINE terminal\ninterface.  That includes TSO EDIT and also the PDS package.  PDS in\nparticular, has a scan/replace that works by update-in-place, and\nwhich can be used to look at JES parms or PARMLIB members, to fix an\nailing system.  PDS will compress libraries that are full, add\ndirectory space to a library \"on the fly\", copy members from one\nlibrary to another, and help in many other ways.  My own emergency\nrequirements have usually been satisfied with just this combination of\ntools.\n\n      I cannot do proper justice to CMD1 (the Command Subsystem)\nhere.  CMD1 has many, many display and monitor functions, operated\nboth from the system console and from a TSO userid.  The closest\nthing I can compare it to, in a vendor package, is the \"RESOLVE\"\npackage from Boole and Babbage, with its many \"authorized\" utility\nand monitor functions.  I privately refer to CMD1 as \"the poor man's\nRESOLVE\".  At this juncture I must point out that CMD1 is written\nas a subsystem, and it can do most of its functions \"without\nanything else up\" on the system.  That can be helpful also.\n\n      The greatest necessity for CMD1 at an MVS installation, is in\nits \"authorized function\" capability.  One sometimes needs to make\nan address space NONSWAPPABLE, or CANCELABLE, or the like.  Sometimes\none needs to display and zap memory, to save the system at a crucial\ntime.  CMD1 has large capability in this area.  Without some vendor\npackage to fill that bill (usually costing in the neighborhood of\nforty thou), an installation can find itself helpless sometimes.  Once\n(many moons ago, I must say) our own installation had to IPL when JES2\ngot into serious trouble, and even a \"$pjes2,abend\" command didn't\nwork.  With CMD1, I simply made it cancellable and cancelled it, or\nterminated its address space.  DONE--no fuss.\n\n      CMD1 has many display facilities too, to the point that one\nmay get quite overwhelmed with them.  For example, #J is a useful\ndisplay of jobs and started tasks, etc. in the system.  The various\ntypes of #I command show different types of SRM values, paging, swap\nactivity, and other statistics.  #V tells you all kinds of things\nabout the mounted disk volumes.  #FC displays CSA and SQA usage.\nAnd so on.  There is a user guide, and you have to look for what\nyou need to measure.\n\n      A large part of CMD1 has been adapted for use under XA.  This\nopens up a different area in our discussion of CMD1.  Such a product\nis bound to change greatly, because of variations and enhancements in\nthe underlying operating system.  Traditionally in the history of CMD1,\nlarge numbers of modules had to be changed because of a new operating\nsystem release.  In fact, the installation procedure of CMD1 reflects\nthis greatly.  You start with a set of modules for a lower system\nrelease than yours.  Then you execute a CLIST against the install\nlibrary, which renames a whole bunch of modules so that the next\nlevel of operating system becomes the currently installable level.\nThis keeps going on, until you reach the level of operating system\nthat you're at.  Then you install the thing.  This is really how\nit works, no joke!\n\n      Anyway, this incredibly rich package is yours for the looking\nand taking.  I must say that it takes up some LPA space.  But you can\noften save that space in other ways, such as removing ISAM from LPA,\nif no one in your shop uses ISAM, for example.  If you're really\ninterested in tuning LPA, IBM has a Dallas Systems Center book that's\ngood: \"MVS Virtual Storage Tuning Cookbook\", G320-0597.  There's a\nchapter in there that says what you can remove from LPALIB to a link\nlist library, so that the system will still work.\n\n      Getting back to CMD1, it's very good, but not 100% guaranteed,\nbecause it's not formally supported.  It does have a built-in\nsafeguard to stop a command that doesn't work properly from damaging\nthe system.  I still think that the advantages of CMD1 far outweigh\nthe deficiencies, and if your shop won't spend the money for the\nexpensive utility and monitoring packages (probably not so good an\nidea), CMD1 will fill a lot of the void for you.\n\n      Between all three of these packages, you and your shop can be\na lot better off.  Good luck.  See you next month.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL8912DE": {"ttr": 5121, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x93!\\x0f\\x01\\x00)\\x9f\\x11G\\x03\\x05\\x03\\x08\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 773, "newlines": 776, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          December 1989\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n\n\n      I must begin this month's column with an announcement that\nI did not want to make.  As of this writing, it appears that the\nConnecticut Bank and Trust Company data center, where Arnold Casinghino\nhas produced his famous MVS Mods tapes, is about to close, due to a\nmerger.  Arnie has, of course, expressed his desire to continue making\nthe tapes from a new position.  However in the interim, because of\nthe unbelievable usefulness of these tapes to the systems programming\nfield, I will accept new contributions to the tape at NEWSWEEK until\nArnie gets resettled.\n\n      I am not in a position to distribute large quantities of\ntapes.  However, all new versions of the tapes will be obtainable\nfrom Mike Loos (of Deluxe Check Printers in Minnesota) under the\nauspices of NaSPA.  Since the tapes contain public-domain material,\ninstallations are encouraged to make copies of the tapes for\nthemselves and others.  A program that is convenient for this\npurpose, can be found on the CBT tape, file 229.\n\n      New contributors (or file updaters), please inquire from me at\n              sbgolob@attglobal.net\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n      This month, I want to discuss an issue that our honored\nmain supplier has largely ignored for twenty years.  It concerns\nthe two permissible formats for TSO clists, and how to convert clist\nlibraries conveniently from one format into the other.  The conversion\nshould be done in such a way, that the execution of the individual\nclists in the libraries remains undamaged and unchanged.\n\n      We have included the entire source for a program, CVTCLIST, in\nthis article.  CVTCLIST converts ENTIRE CLIST LIBRARIES from one\nformat into the other, either way.  This CVTCLIST program is very old.\nA version of it has resided on file 187 of the CBT Mods tape for many\nyears.  The old program has been useful for conversions (especially\nin the FB-to-VB direction) but it contained many bugs.  I have\nfinally sat down, at the request of my friend Lovell Ramsden of\nMontefiore Hospital in New York, and made a serious attempt to fix\nall the bugs.\n\n      The topic itself is not hard to explain.  IBM has made it\npossible to have command lists under TSO that are in either of\ntwo data formats:\n\n      One format is the \"short\" record form of fixed blocked 80-byte\ncard-image records, with sequence numbers in columns 73-80.  These\nrecords have the same overall layout as assembler source statements,\nwith the exception that column 72 is perfectly acceptable to contain\nany valid clist data.  The other format is the \"long\" record form of\nvariable-blocked records.  There are a few necessary considerations\nto understand these.\n\n      Maximum LRECL is equal to 255.  Not all of this is for data.\nWe must subtract four bytes for the four-byte \"Record Descriptor Word\",\nthe \"RDW\", at the beginning.  The RDW tells us how long our current\nrecord (which is variable) is.  The first halfword of the RDW\ncontains the length of the current record in binary, and the second\nhalfword normally contains hexzeros.\n\n      We must also subtract eight more bytes from the 251 that are\nleft, to account for the sequence numbers in columns 1-8.  That\nleaves 243 bytes for valid clist data, in a single line.  Thus the\nVB-type clists can have LONG LINES.  Of course, it makes sense that\nthe VB records must have the sequence numbers at the beginning.  If\nthose were in any other place in the record, they would force every\nrecord to be LONG.  That would defeat the purpose of having\nvariable-length records in the first place, which is to keep the\nindividual records as short as possible to save space.  Blanks\nshould always be truncated from the end of a variable length record,\n(but in practice, this does not always occur).\n\n      That's almost all the info we have to know.  There's just a\nlittle bit more, to complete our picture of the issue we're dealing\nwith.  We must discuss the details of what is involved in converting\na clist that is in one form, to be in the other form.\n\n      Let's first consider an FB (fixed-blocked 80-byte records)\nclist.  What must we do, to convert it to VB (variable blocked,\nLRECL=255) format?\n\n      The first 72 bytes of each FB-80 clist record must be examined.\nA variable length record must be formatted to contain its data.  First,\nan RDW of four bytes is reserved in the output buffer.  Then,\nthe eight-byte sequence number is plugged into the beginning of the\ndata portion of the VB record.  Finally, the data bytes of the FB\nclist record are copied to the VB buffer, starting in the ninth\ncolumn, after the sequence number.  The record will end when the\nlast non-blank character of the line is found.  Then, since the\nlength is now known, that value in binary, is placed in the first\nhalfword of the RDW.\n\n      So much for an individual record.  We keep writing out\nvariable records like these, until a complete block of data is\naccumulated in the buffer.  We forgot to mention (in keeping it\nsimple) that a four-byte \"Block Descriptor Word\", or \"BDW\" must\nprecede the entire variable block.  The four-byte space for the BDW\nhad to be reserved at the beginning of the output buffer.  When a\nblock has been filled, and the total length of all data in the block\nis now known, that value, in binary, is stored in the first halfword\nof the BDW.  (For non-spanned VB records, the second halfword\ncontains hexzeros.)  Then the block is written out to disk.\n\n      Thus, FB to VB conversion consists merely of writing all the\nnonblank clist data of ONE card-image, into ONE variable-length\nrecord, formatted correctly in a VB block.  That's a rather simple\nand mechanical process.\n\n      Reformatting the long VB records into several \"continued\" FB\nrecords is even simpler.  The general idea is to split a long record\nat 71 characters, put a dash (a continuation character) in column 72,\nand continue the record at the beginning of the next line.  However,\nif the data in a record is exactly 72 characters long, that line\nshould not be split.  This is because in an FB-format clist, all of\nthe first 72 characters in the record are valid to contain executable\ndata.  Sequence numbers are plugged into columns 73-80 of each\nnewly-created card-image, and the conversion is complete.\n\n      To my knowledge, IBM has never supplied a fast-acting convenient\nmethod of converting entire CLIST libraries both ways.  In response to\nnecessity, THEY HAVE supplied a conversion clist called ICQSMC00 with\nTSO/E, which converts entire libraries.  But ICQSMC00 has two big\ndrawbacks.  Number one, it is slow, and its action is very\ncomplicated, especially when dealing with big libraries.  Number two,\nit only converts clists from 80-byte fixed format to the variable\nformat, but it does not go the other way.\n\n      The reason why IBM provided the ICQSMC00 clist is that none of\nthe releases of SMP before SMP/E Release 5, could be used to distribute\nvariable-blocked libraries.  In order for IBM to distribute clists,\nthe company had to package them in card-image fixed blocked format,\nand it was up to the customer to convert the individual clists to\nvariable.\n\n      Without a conversion aid such as our program, or IBM's clist\nICQSMC00, the programmer had to use the ISPF 3.3 copy utility, or\nsome other copy utility that would convert data from fixed to\nvariable form.  After fixed-to-variable record format conversion of\neach member, there remained the problem of having the sequence\nnumbers in the wrong place.  The programmer had to edit each member\nindividually, shift all the data to the right by eight bytes, get rid\nof old sequence numbers (now in columns 81-88), and renumber the\nmember.  This is a very tedious process for large numbers of large\nlibraries.\n\n      As far as the advantages of going the other way, VB-to-FB,\nan installation that had been using ALL VB-FORMAT libraries, found\nitself locked into that format, with almost no possibility of escape.\nAny possible conversion to the short-record fixed format, would have\nto be accompanied by extensive testing of each individual clist, to\nmake sure that it still would execute correctly.  It was highly\npossible that the folding of long records would introduce numerous\nexecution errors into the clists.\n\n      Now that we've fixed the CVTCLIST conversion program, these\nproblems (hopefully) should become a thing of the past.\n\n      I'm including the entire text of the corrected CVTCLIST program\nin this article, and I'm contributing it to the NaSPA V.I.P. tape and\nto the CBT Mods tape.  Installations can also download it from NASCOM\nwhen they download this article.\n\n      Hope we've done something useful this month.  Good luck in\nall your work and efforts.\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFIGURE ONE.   The CVTCLIST Conversion Program.\n\n\nCNVT     TITLE 'CLIST LIBRARY CONVERSION PROGRAM: FB-VB, VB-FB'    *SBG\n****************************************************************** *SBG\n*                                                                * *SBG\n*     THIS IS AN ASSEMBLER PROGRAM TO CONVERT ENTIRE CLIST       * *SBG\n*     LIBRARIES FROM THE 80 BYTE - FIXED BLOCKED FORMAT, WITH    * *SBG\n*     SEQUENCE NUMBERS IN COLUMNS 73-80, TO THE OTHER CLIST      * *SBG\n*     FORMAT:  255-BYTE - VARIABLE BLOCKED RECORDS, WITH THE     * *SBG\n*     SEQUENCE NUMBERS IN COLUMNS 1-8 OF THE DATA PORTION OF     * *SBG\n*     EACH RECORD, AND VICE-VERSA.  THE PROGRAM GOES BOTH WAYS.  * *SBG\n*                                                                * *SBG\n*     THE SYSUT1 DATASET IS INPUT, AND THE SYSUT2 DATASET IS     * *SBG\n*     OUTPUT.  THE PROGRAM EXAMINES THE DCB INFORMATION FROM     * *SBG\n*     EACH DDNAME, AND FIGURES OUT WHICH WAY THE CONVERSION      * *SBG\n*     SHOULD PROCEED.  ALL MEMBERS ARE CONVERTED IN ONE RUN      * *SBG\n*     OF THE PROGRAM.  RESULTS ARE REPORTED IN THE SYSPRINT DD.  * *SBG\n*                                                                * *SBG\n*     THE PROGRAM WAS DESIGNED FOR THE CASE IN WHICH THE SYSUT2  * *SBG\n*     (OR TARGET) LIBRARY DOES NOT HAVE ANY MEMBERS TO BEGIN     * *SBG\n*     WITH.                                                      * *SBG\n*                                                                * *SBG\n*     THIS PROGRAM WAS SUBMITTED TO THE CBT MVS MODS TAPE,       * *SBG\n*     FILE 187, BY BOB COLLINS OF THE FIRST NATIONAL BANK OF     * *SBG\n*     CHICAGO.  HE OBTAINED IT FROM ANTIQUITY, AND GOT IT TO     * *SBG\n*     WORK UNDER MVS.                                            * *SBG\n*                                                                * *SBG\n*     THE VB TO FB FUNCTION OF THE PROGRAM (SYSUT1 DD DATASET    * *SBG\n*     IS OF THE VB TYPE AND THE SYSUT2 DD DATASET IS FB) HAD     * *SBG\n*     MANY BUGS, IN SPLITTING OF THE LONG RECORDS.  SOME NEWLY   * *SBG\n*     CREATED FB CLISTS DID NOT BEHAVE EXACTLY AS DID THE OLD    * *SBG\n*     VB VERSION FROM WHICH THEY WERE MADE.  ALSO, THERE WAS A   * *SBG\n*     RUNAWAY CONDITION WHICH COULD RESULT FROM HAVING LONG      * *SBG\n*     STRINGS IN THE VB FORMAT THAT HAD NO IMBEDDED BLANKS.      * *SBG\n*                                                                * *SBG\n*     I HAVE ATTEMPTED TO FIX THESE BUGS.  I CANNOT GUARANTEE    * *SBG\n*     THAT EVERY CLIST IN THE WORLD WILL CONVERT FLAWLESSLY      * *SBG\n*     UNDER THIS PROGRAM, BUT ITS OPERATION HAS BEEN IMPROVED    * *SBG\n*     BY ORDERS OF MAGNITUDE THROUGH THESE FIXES, HOPEFULLY.     * *SBG\n*                                                                * *SBG\n*     I TRIED TO AVOID MAKING ASSUMPTIONS ABOUT CONTINUATION     * *SBG\n*     CHARACTERS, IN ANY WAY.  THIS GOT THE ORIGINAL AUTHOR      * *SBG\n*     INTO HIS ORIGINAL TROUBLE.                                 * *SBG\n*                                                                * *SBG\n*     THERE IS ONE PERVERSE CASE THAT I KNOW ABOUT.  IF A VB     * *SBG\n*     CLIST HAS RECORDS WITH TRAILING BLANKS AFTER THE LAST      * *SBG\n*     NON-BLANK CHARACTER, AND THE TRAILING BLANKS EXTEND PAST   * *SBG\n*     DATA COLUMN 72 (REALLY COLUMN 80), THEN THE PROGRAM WILL   * *SBG\n*     SPLIT THE RECORD ERRONEOUSLY.                              * *SBG\n*                                                                * *SBG\n*     THE BEST WAY TO TEST THIS PROGRAM IS TO CONVERT A LIBRARY  * *SBG\n*     FB-TO-VB-TO-FB, (OR VB-TO-FB-TO-VB), AND ENSURE THAT THE   * *SBG\n*     FINAL LIBRARY COMPARES IDENTICAL TO THE STARTING LIBRARY.  * *SBG\n*                                                                * *SBG\n*     MY HOPE IS THAT THIS PROGRAM WILL ELIMINATE THE GREAT      * *SBG\n*     LABOR AND UNCERTAINTY THAT IS INVOLVED IN ANY CLIST        * *SBG\n*     FORMAT CONVERSIONS, NO MATTER WHICH KIND THEY ARE.         * *SBG\n*                                                                * *SBG\n*                                                                * *SBG\n*                       S.GOLOB -                  10/07/89      * *SBG\n*                                 P.O. Box 423                   * *SBG\n*                                 Howell, NJ 07731-0423          * *SBG\n*                                                                * *SBG\n*                                                                * *SBG\n****************************************************************** *SBG\n*          DATA SET CBT1018    AT LEVEL 001 AS OF 11/19/79\n         EJECT      ,                                              *SBG\n*FUNCTION      CONVERT  CLISTS FROM 255 LRECL VB TO 80 LRECL FB\n*              OR VICE-VERSA\n*I/O           SYSUT1  INPUT CLIST\n*              SYSUT2  OUTPUT CLIST\n*              SYSPRINT LISTING\n*NOTE          VB CLISTS HAVE SEQUENCE NUMBERS IN POS 1-8\n*              FB IN 73-80\n*              RETURN CODE\n*              8 JOB TERMINATED BEFORE START OF COPY\n*              12 JOB TERMINATED AFTER START OF COPY\n*\n         EJECT                                                     *SBG\n         MACRO\n         SYMBR\n**                           EQUATES FOR SYMBOLIC REG USAGE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nRA       EQU   10\nRB       EQU   11\nRD       EQU   13\nRE       EQU   14\nRF       EQU   15\n         MEND\n         MACRO\n&NAME    SAVEX &AREA,&BASE,&VERSION,&INIT,&TESTRAN\n.* DPHQ SYSTEM/360 - OPERATING SYSTEM SSS\n.* V4M0 DECEMBER 2, 1966 F. W. VOSS\n         LCLA  &A1\n         LCLC  &TEST\n&TEST    SETC  '&AREA'(1,5)\n         AIF   ('&AREA' NE '').GD1\n         MNOTE 12,'SAVE AREA NAME MISSING - NO GEN'\n         MEXIT\n.GD1     ANOP\n&A1      SETA  &BASE\n         USING *,15\n&NAME    B     22(0,15)            BRANCH AROUND ID\n         DC    FL1'18'\n         AIF   ('&NAME' NE '').GD2\n         DC    CL9'&SYSECT'        IDENTIFIER\n         AGO   .CT1\n.GD2     DC    CL9'&NAME'          IDENTIFIER\n.CT1     DC    CL8'&VERSION'       VERSION\n         STM   14,12,12(13)        SAVE REGISTERS\n         ST    13,&AREA+4               CHAIN FORWARD\n         CNOP  0,4\n         AIF   (&A1 GT 2).MV2\n         AIF   (&A1 EQ 2).GD3\n         AGO   .CT5\n.MV2     MNOTE 'INVALID BASE REQUEST - USING 2'\n         AGO   .GD3\n.CT5     ANOP\n         BAL   13,&AREA+72    SETUP SAVE AREA POINTER AND BASE\n         DROP  15\n         USING *,13                     ESTABLISH ADDRESSABILITY\n&AREA    DC    18F'0'              SAVE AREA\n         L     15,&AREA+4\n         ST    13,8(0,15)               CHAIN BACK\n         AGO   .CT7\n.GD3     ANOP\n         BAL   13,&AREA+76    SETUP SAVE AREA POINTER AND BASE\n         DROP  15\n         USING *,13,12                  ESTABLISH ADDRESSABILITY\n&AREA    DC    18F'0'              SAVE AREA\n         DC    AL4(&AREA+4096)\n         L     15,&AREA+4\n         ST    13,8(0,15)               CHAIN BACK\n         L     12,&AREA+72              ESTABLISH 2ND BASE\n.CT7     ANOP\n         AIF   ('&INIT' EQ '').CT9\n.CT9     ANOP\n         AIF   ('&TESTRAN' EQ '').CT6\n         AIF   ('&TESTRAN' EQ 'TEST').CT8\n         MNOTE 'INVALID TESTRAN EDIT REQUEST'\n         AGO   .CT6\n.CT8     ANOP\n*                            TESTRAN SPIE MACRO\n         SPIE  &TEST.EXT,((1,15))\n         B     &TEST.ABE     BRANCH AROUND TESTRAN DUMP\n         SPACE 2\n&TEST.EXT BALR 15,0          ESTABLISH ADDRESSABILITY FOR TESTRAN ABEND\n         DROP  13\n         USING *,15\n         MVC   &TEST.PSW,4(1) MOVE OLD PSW FROM PIE\n*                            TESTRAN ABEND MACRO\n&TEST.ERR ABEND 4444,DUMP\n&TEST.PSW DC   XL8'0'        OLD PROGRAM PSW ON PROGRAM INTERRUPT\n         DROP  15\n         USING &AREA,13      REESTABLISH CSECT ADDRESSABILITY\n&TEST.ABE EQU  *\n.CT6     ANOP\n         SPACE 2\n         MEND\n*FUNCTION      CONVERT  CLISTS FROM 255 LRECL VB TO 80 LRECL FB\n*              OR VICE-VERSA\n*I/O           SYSUT1  INPUT CLIST\n*              SYSUT2  OUTPUT CLIST\n*              SYSPRINT LISTING\n*NOTE          VB CLISTS HAVE SEQUENCE NUMBERS IN POS 1-8\n*              FB IN 73-80\n*              RETURN CODE\n*              8 JOB TERMINATED BEFORE START OF COPY\n*              12 JOB TERMINATED AFTER START OF COPY\n*\n*        R11   RETURN\n*        R10   DCB TEMPLATE\n*        R7    OUTPUT POINTER\n*        R6    INPUT POINTER\n*        R5    LENGTH CODE\n*        R4    INPUT START OF BLOCK\n*        R3    OUTPUT START OF BLOCK\n         SYMBR\nTEST20   EQU   X'20'\n         EJECT\nCNVCLIST CSECT\n         SAVEX SAVEAREA,1,COPYCLST\n         SPACE\n         OPEN  (CLISTIN,(INPUT))\n         SPACE\n         OPEN  (CLISTOUT,(OUTPUT))\n         SPACE\n         USING IHADCB,R10\n         LA    R10,CLISTIN              USE DCB NAMES FOR INPUT DCB\n         BAL   R11,TESTVORF\n         BAL   R11,GETMAIN              GET CORE FOR INPUT BLOCK\n         LR    R4,R1                    SAVE INPUT BLOCK ADDRESS\n         LA    R10,CLISTOUT             USE DCB NAMESFOR  OUTPUT DCB\n         BAL   R11,TESTVORF\n         BAL   R11,GETMAIN              GETMAIN FOR OUTPUT BLOCK\n         LR    R3,R1                    SAVE OUTPUT BLOCK ADDRESS\n         TM    SWITCH,X'80'             IF 1 FILE IS F AND 1 V\n         BO    SAVEOUT                    CONTINUE\n         MVC   ERRORMSG,MSG3\n         MVC   RC,=H'8'\n         B     WRITERR\n         SPACE 2\nTESTVORF EQU   *\n         TM    DCBRECFM,X'C0'           CHECK FOR V OR F\n         BM    CONTVF                   IF NOT V OR F ERROR\n         MVC   ERRORMSG,MSG1\n         MVC   RC,=H'08'\n         B     WRITERR\nCONTVF   TM    DCBRECFM,X'80'           IF V\n         BZ    EXITVORF                   EXIT\n         XI    SWITCH,X'80'             FIRST F TURNS ON-SECOND OFF\n         CLC   DCBLRECL,=H'80'          IF F AND LRECL NOT = 80\n         BE    EXITVORF                   THEN ERROR\n         MVC   ERRORMSG,MSG2\n         MVC   RC,=H'8'\n         B     WRITERR\nEXITVORF BR    R11                      RETURN\n         SPACE 2\nGETMAIN  EQU   *\n         LH    R0,DCBBLKSI              GET CORE F0R PROCESSING AN\n         GETMAIN R,LV=(0)                 INPUT BL0CK\n         SPACE\n         BR    R11\n         SPACE 2\nSAVEOUT  EQU   *                       SAVE DATA FOR MAINLINE\n         MVC   OUTBLKSI,DCBBLKSI\n         LR    R7,R3                   INITIALIZE OUTPUT POINTER\n         TM    DCBRECFM,X'80'          IF OUTPUT IS V\n         BZ    SAVEIN                    SAVE INPUT END OF BLOCK\n         OI    SWITCH,TEST20           ELSE SET INPUT SWITCH TO V\n         LH    R12,DCBBLKSI\n         LA    R12,0(R12,R3)           SAVE OUTPUT END OF FIXED BLOCK\n         ST    R12,ENDF\n         LA    R10,CLISTIN\n         B     INITREAD\n         SPACE\nSAVEIN   LA    R10,CLISTIN\n         LH    R12,DCBBLKSI            SAVE INPUT END OF FIXED BLOCK\n         LA    R12,0(R12,R4)\n         ST    R12,ENDF\n         LH    R12,OUTBLKSI            SAVE MAXIMUM END OF OUTPUT\n         LA    R12,0(R12,R3)             VARIABLE BLOCK\n         ST    R12,ENDV\n         LA    R7,4(R7)                POINT PAST BLK COUNT FOR V\n         SPACE 2\nINITREAD EQU   *\n         CLOSE (CLISTIN)\n         MVI   DCBRECFM,X'C0'          SET INPUT RECFM TO U\n         MVI   CLISTOUT+36,X'C0'       SET OUTPUT RECFM TO U\n         OPEN  (CLISTIN,(INPUT))\nREADDIR  EQU   *\n         OI    SWITCH,X'40'             SET DIRECTORY READ ON\n         READ  DECB1,SF,CLISTIN,DIRIN,256\n         CHECK DECB1\n         NOTE CLISTIN\n         XI    DIRSW,X'FF'             SINCE SAVETTR POINTS TO\n         CLI   DIRSW,X'00'             BEGINNING OF DIRECTORY, READ\n         BE    READDIR                 TWICE AFTER FIRST READ.\n         SPACE\n         ST    R1,SAVETTR              SAVE POINTER TO DIRECTORY\n         LH    R9,DIRIN\n         STH   R9,DIRLEFT               SAVE DIRECTORY LENGTH\n         LA    R9,DIRIN+2\n         ST    R9,NEXTMEM\n         SPACE 2\nGETMEM   EQU   *                        GET BLOCK OF DATA\n         ZAP   SEQCOUNT,=P'0'           ZERO OUT SEQUENCE COUNT FOR MEM\n         L     R8,NEXTMEM               LOAD ADDRESS OF MEMBER NAME\n         CLC   HIVALUE,0(R8)            IF MEMBER NAM = HIVALUES\n         BE    EOJ                        GO TO END OF JOB\n         NI    11(R8),X'1F'\n         MVC   DIRLIST+11(63),11(R8)    MOVE USER DATA TO DIRLIST\n         MVC   NAME,0(R8)               PUT NAME IN OUTPUT DIRECT LIST\n         SR    R12,R12                  CLEAR REGISTER\n         IC    R12,11(R8)               LOAD # OF HALFWORDS OF USERDATA\n         LA    R12,12(R12,R12)          DOUBLE AND ADD 12\n         LA    R9,0(R12,R8)             COMPUTENEXT MEMBER DIR ADDA\n         ST    R9,NEXTMEM               SAVE ADDRESS OF NEXT MEMBER\n         LH    R9,DIRLEFT               COMPUTE BYTES LEFT IN\n         SR    R9,R12                     DIRECTORY\n         STH   R9,DIRLEFT\n         NI    11(R8),X'00'             CLEAR C  OF TTRC\n         LA    R8,8(R8)                 LOAD ADDRESS OF TTR\n         NI    SWITCH,X'BF'             TURN DIRECTORY READ SW  OFF\n         POINT CLISTIN,(8)\n         SPACE\n       LH    R8,DCBBLKSI                LOAD INPUT BLKSIZE\nREADBLK  READ  DECB2,SF,CLISTIN,(4),(8)\n         SPACE\n         CHECK DECB2\n         SPACE\n         TM    SWITCH,TEST20           IF INPUT IS F\n         BZ    FTOV                      CONVERT FIXED TO VARIABLE\n         SPACE 2\nVTOF     EQU   *\n         LH    R12,0(R4)               ADD BLKSIZE AND STARTING\n         AR    R12,R4                    ADDRESS\n         ST    R12,ENDV                  GIVING  ENDING ADDRESS\n         LR    R6,R4                   LOAD POINTER TO V INPUT\n         LA    R6,4(R6)                POINT TO FIRST LRECL\n         SPACE\nGETREC   MVC   HALFWORD,0(R6)\n         LH    R5,HALFWORD\n         CH    R5,=H'255'              IF LRECL IS GREATER THAN 256\n         BL    PASTRDW                   ERROR                     *SBG\n         MVC   ERRORMSG,MSG4             MESSAGE\n         MVC   RC,=H'12'                 RETURN CODE\n         B     WRITERR\nPASTRDW  SH    R5,=H'12'               POINT PAST 4 BYTE LRECL AND *SBG\n         LA    R6,12(R6)                 8 BYTE LINE SEQUENCE FIELD\n         SPACE\nLOOPREC  STH   R5,LRECL                SAVE LRECL\n         LA    R12,0(R5,R6)            POINT TO LAST BYTE OF REC   *SBG\n         ST    R12,SAVEWREG            SAVE END OF RECORD          *SBG\n         ST    R5,SAVECREG             SAVE BYTES TO BE MOVED.     *SBG\n         ST    R4,SAVE4REG             SAVE REG 4 CONTENTS. WKREG. *SBG\n         LA    R4,0                    COUNTER FOR MOVE            *SBG\nBACKLOOP CR    R4,R5                   LIMITED SEARCH FOR TRL BLNKS*SBG\n         BNL   FOUNDTE                 YES. NO NON-BLANKS IN RECD  *SBG\n         CH    R4,=H'70'               LIMITED SEARCH FOR TRL BLNKS*SBG\n         BH    FOUNDTE                 YES. NO NON-BLANKS IN RECD  *SBG\n         CLI   0(R12),C' '             IS LAST BYTE A BLANK?       *SBG\n         BNE   FOUNDTE                 NO. FOUND TRUE END FOR CLIST*SBG\n         LA    R4,1(,R4)               BUMP COUNTER                *SBG\n         B     BACKLOOP                KEEP TRYING                 *SBG\nFOUNDTE  SR    R5,R4                                               *SBG\n         L     R4,SAVE4REG             RESTORE REGISTER 4.         *SBG\n         CH    R5,=H'72'         IF LRECL 71 NOT COUNTING TR BLNKS *SBG\n         BH    SPLITREC                THEN SPLIT RECORD           *SBG\n         BE    EXACT72           EXACTLY 72 CHARS-SPECIAL TREATMENT*SBG\n         L     R5,SAVECREG             RESTORE R5, AND THEN        *SBG\n         BCTR  R5,0                    MAKE LENGTH CODE ADJUSTMENT\nSKIPLOOP L     R12,SAVECREG            RESTORE REGISTER 12.        *SBG\n         MVC   REC80,REC80-1           CLEAR RECORD AREA           *SBG\n         EX    R5,MOVE80               MOVE RECORD                 *SBG\n         BAL   R11,WRITEF\n         LA    R5,1(R5)\n         LA    R6,0(R5,R6)             INCREMENT CURRET POINTER BY LENG\nNOTSPLIT C     R6,ENDV         *SBG    IF ADDRESS POINTER IS LESS THAN\n         BL    GETREC                    END ADDRESS GO TO GETREC\n         B     READBLK                 ELSE READ A BLOCK\n         SPACE 2\nEXACT72  LH    R5,=H'71'               DON'T DROP LAST CHARACTER   *SBG\n         LA    R12,0(R5,R6)       ADDRESS OF END OF REC TO BE MOVE *SBG\n         MVC   REC80,REC80-1           CLEAR OUTPUT RECORD         *SBG\n         B     MOVEMOUT                NO CONTINUATION CHARACTER   *SBG\nSPLITREC EQU   *\n         LH    R5,=H'70'                                           *SBG\nSPLTLOOP LA    R12,0(R5,R6)       ADDRESS OF END OF REC TO BE MOVE\n         MVC   REC80,REC80-1           CLEAR OUTPUT RECORD\n         MVI   REC80+71,C'-'           MOVE IN CONTUATION CHARACTER SBG\nMOVEMOUT EX    R5,MOVE80               MOVE TO WRITE AREA          *SBG\n         BAL   R11,WRITEF\n         LA    R12,1(R5)               ADD 1 REC LENGTH OF RECORD  *SBG\n         LH    R5,LRECL                  WRITEN\n         SR    R5,R12                  SUBTRACT FROM LRECL\n         LA    R6,0(R12,R6)            INCREMENT IPOINTER BY LENGTH\n* IF LRECL IS EXACTLY 72, WE CAN COME HERE. NOW WE TEST FOR THAT.  *SBG\n         LTR   R5,R5          ARE WE ACTUALLY AT THE END OF A RECD?*SBG\n         BZ    NOTSPLIT       YES. DON'T ACT TO SPLIT THE RECORD.  *SBG\n         B     LOOPREC                 FINISH RECORD\n         SPACE\nWRITEF   EQU   *\n         AP    SEQCOUNT,=P'10'         PLACE SEQUENCE NUMBER IN\n         UNPK  REC80+72(8),SEQCOUNT      POSITIONS 73-80\n         MVI   REC80+79,C'0'           MAKE LAST POS CHAR ZERO\n         MVC   0(80,R7),REC80          MOVE RECORD TO OUTPUT\n         LA    R7,80(R7)               INCREMENT POINTER\n         C     R7,ENDF                 IF POINTER IS LESS THAN ENDOFBLK\n         BCR   4,R11                     RETURN\n         SR    R7,R3                   LOAD BLKSIZE\n         B     WRITEOUT                ELSE WRITEOUT BLOCK\n         SPACE 2\nFTOV     EQU   *\n         LA    R12,0(R8,R4)            FIND END OF BLOCK ADRESS\n         L     R9,DECB2+16             LOAD IOB ADDRESS\n         LH    R9,14(R9)               LOAD LENGTH BLOCK IS SHORT\n         SR    R12,R9                  SUBTRACT FROM END OF FULL BLK\n         ST    R12,ENDF                  GIVING REAL END OF BLOCK\n         LR    R6,R4                   POINT TO START OF INPUT BLOCK\nNEXTFREC EQU   *\n         LA    R5,71(R6)               POINT TO LAST CHAR          *SBG\nLOOPFV   EQU   *\n         CLI   0(R5),C' '              FIND LAST NON BLANK CHARACTER\n         BNE   FOUNDATA\n         BCTR  R5,0\n         B     LOOPFV\n         SPACE\nFOUNDATA EQU   *\n         SR    R5,R6                   SUBTRACT START FROM END GIV LENG\n         CH    R5,=H'1'\n         BH    WRITEV              IF LENGTH CODE IS LESS THAN 1   *SBG\n         LA    R5,1                      USE 1\nWRITEV   EQU   *            DO NOT PLAY GAMES WITH CONTIN CHARACTRS*SBG\n         LA    R12,13(R5,R7)           LOAD ADDRESS END OF OUTPUT REC\n         C     R12,ENDV                IF ENDOFREC IS LESS THAN ENDOFBL\n         BNH   EXMOVEV                   MOVE DATA\n         SR    R7,R3                   ELSE FIND BLK LENGTH\n         STH   R7,0(R3)                  STORE IN OUTPUT BLOCK\n         BAL   R11,WRITEOUT              WRITE BLOCK\n         LA    R7,4(R7)                  POINT PAST OUTPUT BLK COUNT\n         SPACE\nEXMOVEV  EQU   *\n         EX    R5,MOVEV                MOVE DATA TO OUTPUT BLOCK\n         AP    SEQCOUNT,=P'10'         PUT SEQUENCE NUMBER\n         UNPK  4(8,R7),SEQCOUNT          IN OUTPUT DATA SET\n         MVI   11(R7),C'0'             MAKE LAST DIGIT CHARACTER 0\n         LA    R5,13(R5)               ADD 13 TO LEN CNT GIVING LRECL\n         STH   R5,HALFWORD\n         MVC   0(4,R7),HALFWORD        STORE LRECL IN OUTPUT BLOCK\n         LA    R7,0(R5,R7)             INCREMENT OUTPUT POINTER\n         LA    R6,80(R6)               INCREMENT  INPUT POINTER\n         C     R6,ENDF                 IF LESS THAN END OF BLOCK\n         BL    NEXTFREC                  GET NEXT RECORD\n         B     READBLK                 ELSE GET NEXT BLOCK\n         SPACE 2\nWRITEOUT EQU   *\n         WRITE DECBA,SF,CLISTOUT,(R3),(R7)    WRITE OUT BLOCK\n         SPACE\n         CHECK DECBA\n         SPACE\n         LR    R7,R3                   SET POINTER TO START OF BLOCK\n         BR    R11\nSTOWOUT  EQU   *\n         TM    SWITCH,TEST20           IF V TO F\n         BO    STOWVTOF                  CHECK FOR SHORT BLOCK\n         SR    R7,R3                   FIND BLOCK LENGTH\n         STH   R7,0(R3)                STORE IN BDW\n         MVC   2(2,R3),=H'0'           ZERO OUT REST OF BDW\n         B     SHORTBLK                WRITE OUT BLOCK\nSTOWVTOF CR    R3,R7                   IF OUTPUT BLOCK IS EMPTY\n         BE    *+10                      SKIP WRITING SHORT BLOCK\n         SR    R7,R3                   LOAD BLOCK LENGTH\nSHORTBLK BAL   R11,WRITEOUT            WRITE SHORT BLOCK\n         TM    SWITCH,X'40'            IF DIRECTORY READ\n         BO    EOJ                       GO TO  EOJ\n         STOW  CLISTOUT,DIRLIST,A\n         SPACE\n         B     STOWEND(R15)\nSTOWEND  B     CHECKEND                 GOOD STOW\n         B     ERRA\n         NOP   ERRA\n         B     ERRB\n         B     ERRC\n         NOP   ERRA\nERRD     MVC   ERRORMSG,MSGD\n         B     ERR\nERRC     MVC   ERRORMSG,MSGC\n         B     ERR\nERRB     MVC   ERRORMSG,MSGB\n         B     ERR\nERRA     MVC   ERRORMSG,MSGA\nERR      MVC   RC,=H'12'\n         B     WRITERR\n         SPACE\nCHECKEND EQU   *\n         AP    OUTCOUNT,=P'1'          COUNT MEMBERS MOVED\n         TM    SWITCH,TEST20           IF V TO F\n         BO    *+8                        CHECK DIRECTORY\n         LA    R7,4(R7)                ELSE ADD 4 BYTES FOR OUTPUT BDW\n         LA    R12,2\n         CH    R12,DIRLEFT             IF DIRECTORY BLOCK IS NOT EMPTY\n         BL    GETMEM                     GET NEXT MEMBER\n         POINT CLISTIN,SAVETTR          ELSE READ NEW DIRECTORY\n         SPACE\n         B     READDIR\n         SPACE 2\nWRITERR  EQU   *\n         BAL   R11,WRITETIT\n         MVC   PRTLINE,ERRLINE\n         BAL   R11,PUTPRINT\n         CLC   RC,=H'12'               IF COPY STARTED\n         BNE   EXIT                      PRINT TOTALS\n         BAL   R11,COUNTP\n         B     EXIT\n         SPACE 2\nEOJ      BAL   R11,WRITETIT\n         MVC   ERRORMSG(14),=C' COPY COMPLETE'\n         MVC   PRTLINE,ERRLINE\n         BAL   R11,PUTPRINT\n         BAL   R11,COUNTP\n         SPACE 2\nEXIT     EQU   *\n         CLOSE (CLISTIN,,CLISTOUT,,PRINT)\n         LH    R15,RC                  LOAD RETURN CODE\n         L     R13,SAVEAREA+4\n         LM    R0,R12,20(R13)          RESTORE REGS 0-12\n         L     R14,12(R13)             RESTORE REG 14\n         BR    R14\n         SPACE 2\nWRITETIT EQU   *\n         OPEN  (PRINT,(OUTPUT))\n         MVC   PRTLINE,TITLE\n         LH    R12,RC\n         CVD   R12,WORK\n         UNPK  RCP,WORK\n         OI    RCP+1,X'F0'\n         B     PUTPRINT\nCOUNTP   UNPK  OUTP,OUTCOUNT           MOVE NO OF MEMBERS MOVED\n         OI    OUTP+4,X'F0'              TO PRINTLINE\n         MVC   PRTLINE,COUNTLN\n         SPACE\nPUTPRINT PUT   PRINT,PRTLINE\n         SPACE\n         BR    R11\n         SPACE 2\n*EXECUTED INSTRUCTIONS\nMOVEV    MVC   12(1,R7),0(R6)\nMOVE80   MVC   REC80(1),0(R6)\n         EJECT\nCLISTIN  DCB   DSORG=PO,MACRF=R,DDNAME=SYSUT1,EODAD=STOWOUT\n         SPACE 2\nCLISTOUT DCB   DSORG=PO,MACRF=W,DDNAME=SYSUT2\n         SPACE 2\nPRINT    DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,RECFM=FBA,            X\n               LRECL=121,BLKSIZE=605\n         EJECT\n*WORK FIELDS\n         SPACE\nWORK     DC    D'0'\nFULLWORD DS    0F\nHALFWORD DC    H'0'\n         DC    H'0'\nSAVETTR  DC    F'0'\nREADADD  DC    F'0'\nENDV     DC    F'0'\nENDF     DC    F'0'\nSAVERTN  DC    F'0'\nNEXTMEM  DC    F'0'\nSAVECREG DC    F'0'                                                *SBG\nSAVEWREG DC    F'0'                                                *SBG\nSAVE4REG DC    F'0'                                                *SBG\nSAVEHALF DC    H'0'                                                *SBG\nOUTBLKSI DC    H'0'\nDIRLEFT  DC    H'0'\nBLKIN    DC    H'0'\nRECIN    DC    H'0'\nRC       DC    H'0'\nLRECL    DC    H'0'\nOUTCOUNT DC    PL4'0'\nDIRSW    DC    X'00'\nSWITCH   DC    XL1'00'\nHIVALUE  DC    XL8'FFFFFFFFFFFFFFFF'\nSEQCOUNT DC    PL4'0'\n         SPACE\n         DS    0F\nDIRIN    DS    CL256                   DIRECTORY BLOCK\n         SPACE\n         DS    0F\nDIRLIST  DS    0CL74                   DIRECTORY RECORD\nNAME     DC    CL8' '\nTTR      DS    CL3\nC        DS    CL1\nUSEADATA DS    CL62\n         DC    CL1' '\n         SPACE\nREC80    DS    CL80\n         SPACE 2\n*PRINT DATA\n         SPACE\nTITLE    DC    CL121'1        CLIST CONVERSION'\nERRLINE  DS    0CL121\n         DC    CL7'0   RC='\nRCP      DC    CL2'  '\n         DC    CL5' '\nERRORMSG DC    CL37' '\n         DC    CL70' '\nCOUNTLN  DS    0CL121\n         DC    CL29'0'\nOUTP     DC    CL5'0'\n         DC    CL87' MEMBERS COPIED'\nPRTLINE  DS    CL121\n         SPACE\nMSG1     DC    CL37'FILE NOT V OR F'\nMSG2     DC    CL37'F FORMAT MUST BE LRECL 80'\nMSG3     DC    CL37'INPUT AND OUTPUT CANNOT BE SAME RECFM'\nMSG4     DC    CL37'V RECORD WITH LRECL OVER 256'\nMSGA     DC    CL37'DUPLICATE NAME ON DIRECTORY-SYSUT2'\nMSGB     DC    CL37'DIRECTORY OUT OF SPACE'\nMSGC     DC    CL37'I/O ERROR ON SYSUT2 DIRECTORY'\nMSGD     DC    CL37'PROGRAM REGION TOO SMALL'\n         LTORG\nDCBDUM   DCBD  DSORG=PO,DEVD=DA\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9001JA": {"ttr": 5381, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93!\\x0f\\x00\\x93!\\x0f\\x145\\x01\\x8a\\x01\\x8a\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "1993-07-29T14:35:00", "lines": 394, "newlines": 394, "modlines": 0, "user": "SBGCSC"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          January 1990\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n\n\n      I am pleased to announce that the unbelievably useful \"CBT\" MVS\nMods tapes, which have been available from the Connecticut Bank and\nTrust Company for many years, will still continue to be available from\nNaSPA.  In spite of the imminent closing of the CBT data center,\nprovision is being made to continue the updating of these valuable\ntapes.  NaSPA, and SPLA at the University of Miami will become the\nprimary distributors of the tapes for the public during the time that\nArnold Casinghino is being resettled.  I am hoping that both the\nfunctions of editing and distribution of the tapes can be returned\nback to Arnie when his situation gets stabilized.\n\n      I have received several panicky calls from programmers who have\nfixed their code from the CBT tape, and who want to know where to\nsend the updates.  If Arnie's phone (203) 244-5495 is still working at\nthe time of print, please find out the details from him.  Otherwise,\ncontact me at Newsweek in Mountain Lakes, New Jersey for current\ninformation and status on the tapes, or contact NaSPA in Milwaukee.\n\n      Again, please order the \"CBT\" tape (now renamed the \"Former\nConnecticut Bank Tape\" of MVS Mods, for want of a better way to keep\nthe acronym) from NaSPA, (414) 423-2420.  For your information, there\nis a good tape copy program called COPYMODS on file 229 of the CBT\ntape, which you may use for creating additional copies.  That may\nhelp to split the higher tape handling cost of 50 dollars from NaSPA.\n(Since this month's article concerns tape manipulation, I'd suggest\nthat you read on for details on how to use the COPYMODS program.)\n\n    *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n      Now to this month's topic, which concerns available tools for\ndealing with tapes and cartridges.  I am of the opinion that handling\ntapes is a lost art.  Many people think that nowadays, since disk\nstorage space is so abundant, one need not concern oneself on a major\nbasis with tapes.  They tend to regard tapes as antiquated--a\nthrowback to a bygone era.\n\n      How wrong they are.  There is a great difference between the\nneeds of a Technical Support Department and those of a production\napplication environment.  We \"techies\" tend to squirrel away a lot of\nour software resources for future retrieval when they might be\nneeded.  Many companies, even nowadays, are hurting for disk space.\nUnless the disk space is really abundant, shops may be reluctant to\ncommit large enough quantities of it, toward what can be regarded as\n\"dead storage\" for those \"inscrutable genius types\" in the corner\nsection of the floor.\n\n      It is easy to forget how large a quantity of data can be stored\non one small tape--even more so, on a cartridge.  We shall discover\nthat a relatively small amount of disk space can be exploited, to\naccomplish quick retrieval of data from a huge private Technical\nSupport tape library.  One need only know how to use the available\ntape-handling tools.  The entire Tech Support department can be the\ngrateful beneficiary of the easy access to large quantities of\nsoftware materials, which formerly stood unnoticed, unused, and\nstuffed into cardboard boxes in the back closet.\n\n      Tape mapping programs, tape copying programs, and tape \"splicing\"\nprograms are the keys to better utilization of the tape medium.  In\naddition, my handy \"finding\" system for tape data, which is easily\nimplemented, can make the location and retrieval of data on tape far\neasier.  I shall review the essentials of my tape data finding system\nafter our discussion of the TAPEMAP program.\n\n      One of the aims of this column is to bring new techniques\nwithin the reach of every MVS shop, regardless of budget.  I will\ntherefore concentrate on implementing my techniques using FREE\nSOFTWARE, although vendor products may further enhance these processes\nand might even make possible other and better methods.  We're merely\ntrying to induce people to utilize their noggins, and we'd like to\nstart our readers thinking of new ways to get their jobs done.\n\n      Let's start with tape mapping programs, in particular, the\nprogram found on File 299 of the CBT tape, known as TAPEMAP.\n\n      There are many \"tape mapping\" programs floating around.  The\nminimal job of a tape mapping program is the display of information\nin tape labels (for standard-labeled tapes) and the reporting of\nblock size and block count information for all tapes, by means of\nsome scanning method.  There are tape mapping programs which will\nattempt to calculate and display footage counts, to give the user an\nindication of how full the tape is.  Many such programs also include\nCOPYING functions for tapes, although strictly speaking, the MAPPING\nfunction is one of summarization, and reporting of record totals and\nother statistics.\n\n      I am not including in this classification, programs such as\nOSDITTO (from IBM) or MVS DITTO (the cleaned-up newer version of\nOSDITTO), which actually PRINT OR COPY THE DATA on the tape.  My idea\nof a MAPPING PROGRAM is that it perform the function of SUMMARIZING\nTHE CONTENTS OF AN ENTIRE TAPE.  Data printing and copying of tape\ndata is a different classification.\n\n      The best example of a tape mapping program in this category is\nTAPEMAP (CBT tape file 299).  TAPEMAP produces two reports (see\nfigure one), which superlatively cover the ground of what is good in\na tape mapping program.  The first report (which has some variations,\ncontrolled by parms) displays the label fields (for standard-labeled\ntapes), data summary information obtained from BLOCK SCANS, and\nfootage counts.  The footage counts are obtained by estimate, either\nfrom the labels, or from the actual data scan.  If obtained from a\nscan, these footages are usually very accurate.  The record format of\neach file is also indicated, if found in the labels; the program\nitself can only scan data blocks, but not individual records.\n\n      So far, this does not sound unusual.  However, in addition to\nthese things, TAPEMAP recognizes at least ten standard MVS file\nformats, such as IEBCOPY, IEBUPDTE, FDR, FDRDSF, SMPPTFIN, and\nIEHMOVE.  When reporting on each file in its first report, TAPEMAP\nwill indicate the presence of one of these file formats if it\nrecognizes it from reading the tape.\n\n      TAPEMAP's real distinction comes from its second report.  The\nsecond TAPEMAP report concerns the special file formats that are\nrecognized by the program.  On that report, MEMBER NAMES from the\nunloaded pds library are displayed.  In the special case of an FDR\ntape dump, the dataset names of files that were dumped by the backup\nare listed, along with the \"vital statistics\" from the original\ndisk files that were backed up.\n\n      For the IEBCOPY format, all members in the library that was\nunloaded, are listed.  For IEBUPDTE, not only is the member name\ninformation present, but also whether the update is an ADD, a CHANGE,\nor a REPL.  For SMPPTFIN, the SYSMOD NUMBER is listed, together with\ninformation on whether the sysmod was a PTF, an APAR, a USERMOD, or a\nFUNCTION.\n\n      I have recently modified the TAPEMAP program to list INTERNAL\nMEMBERS WITHIN MEMBERS, for IEBUPDTE-unloaded tape files.  Such a\nsituation might occur in a package of programs that has its own\nmacro library.  Rather than mix the macros as members of the source\npds, together with the source programs, the author would rather\nPACKAGE ONE PDS MEMBER OF ALL THE MACROS TOGETHER, in IEBUPDTE-unload\nformat.  This member would later be converted into a separate macro\nlibrary at product install time.\n\n      In order to insure that the IEBUPDTE program will continue to\ntreat an entire macro library \"member\" always as only one member, the\n'./' strings denoting member manipulations within the macro library\nare all altered to another string, such as '><' after the creation of\nthe unloaded library \"member\".  IEBUPDTE will then ignore those\ninternal manipulations for the time being.  TAPEMAP as now modified,\nwill read an IEBUPDTE-unloaded pds file as before, but it will also\nreport the names of all the macros in these \"imbedded\" macro\nlibraries, in addition to showing all the regular member names.\n\n      My modification of TAPEMAP also allows it to read the compressed\nfiles on the CBT Tape directly, and to report the names of all members\nof the dumped and compressed libraries on that tape.  It therefore\nprovides us with a vehicle to \"scope out\" the contents of a CBT tape,\nmember names and all.  That helps us get more easily to the files\non the CBT tape which we want to look at.\n\n      One of the most useful applications of TAPEMAP, in my opinion,\nis that of FINDING MEMBERS, LOAD MODULES, OR PTFS, ON A TAPE.  This\nis a usefulness that was not anticipated, or possible, with the\nordinary run of tape mapping programs, because they do not provide\nthe ability of DISPLAYING THE NAMES OF INDIVIDUAL ELEMENTS LOADED on\nthe tape.  With TAPEMAP's report two, and the reporting of individual\nmember names, updates, or PTFs, the ability of looking these up\nbecomes a conceivable goal.  Only one obstacle remains to having a\nviable tape search system--that of being able to do a quick search\nfor a particular element name string.\n\n      The free PDS program on the CBT Mods Tape (or its vendor product\nsuccessor, PDS/E) provides the missing part to an efficient tape\nlibrary search system.  The PDS programs have a \"global string search\"\nfacility (their \"FIND\" subcommand), which allows a quick search for a\ncharacter string across many members of a partitioned dataset at once.\nTherein lies the final key to the tape search system.  One need only\nmove the two TAPEMAP reports for a tape, INTO TWO SEPARATE MEMBERS OF\nA PARTITIONED DATASET WHICH HAS LRECL=133.  Every tape in our collection\ncan be so mapped.  Then a SEARCH FOR A MEMBER OR PTF will merely\nconsist of executing a PDS \"FIND\" COMMAND for the desired string,\nagainst groups of members (or all members) of the \"map pds\".\n\n      For example, we have a collection of PUT tapes from 8701 thru\n8906, and we want to find one PTF, say UY26372.  Assume that we have\nrun all these tapes thru the TAPEMAP program by having executed a\nPROC (see figure two) that created two pds members for each tape read\nin.  Again, say PUT tape 8709 is assigned VOL=SER=TM8709, and the two\nmembers created in the pds called 'TST.PTFTAPE.MAPS' are called:\nTM8709 for report one, and TM8709M for report two.  Since this\nmapping has been done for all our tapes, 'TST.PTFTAPE.MAPS' has a\ncollection of members which range from TM8701 and TM8701M, to TM8906\nand TM8906M.\n\n      With this having been set up, we need merely invoke the PDS\nprogram against the current dataset of 'TST.PTFTAPE.MAPS'.  We then\nissue a FIND command:  FIND : /UY26372/    (where the colon stands\nfor \"all members of the current pds\").  The PDS program will yield a\nresult (see figure three) showing that UY26372 is found on tape\nTM8807.\n\n      This same technique can be used for IEBCOPY-unloaded files,\nif one is searching for a source or load module member.  It can\neven be used to search for a member name on the CBT Mods tape\nitself.  IN THIS WAY, A RELATIVELY SMALL AMOUNT OF DISK SPACE (THE\nTAPE MAPPING PDS) CAN BE USED TO \"INDEX\" A LARGE NUMBER OF TAPES,\nQUICKLY AND EASILY.  Our \"easy finding system\" for tape data has\nbecome a practical reality.\n\n      TAPEMAP has other uses.  For example, it can be used to\nmonitor when a tape is becoming full, or if there still is a lot of\nroom left on it, to store more data.  We can get a good idea if we\nare getting efficient use of our tape storage space.\n\n      TAPEMAP can report defects on a tape.  It is rather detailed\nin specifying I/O errors that were encountered.  Because of the\nwealth of material in its reports, other clever uses can be found\nfor the TAPEMAP program.  In short, TAPEMAP is a handy tool that\nmerits study, because it can be used for many purposes that we have\nnot anticipated.  We have too many preconceived ideas about what such\na program can or cannot do.\n\n      The next program on our agenda is called \"TAPESCAN\".  TAPESCAN\nversions have been around for many years.  A version of TAPESCAN that\nis able to read cartridges, can be found on a newer CBT tape, on File\n102.  This is the particular version we will talk about.\n\n      TAPESCAN does functions in two categories.  It MAPS, or\nSUMMARIZES the contents of a tape.  It also can be used to COPY DATA\nFILES from one tape to another.  It is superior to TAPEMAP in that\nit can be told to skip a given number of tape marks, and it can deal\nwith \"weird\" tapes.  TAPEMAP is more suited for \"normal\" MVS tapes.\n\n      TAPESCAN's mapping report does not look much like TAPEMAP's\nreports, although there is some overlapping of the information\nconveyed.  By and large, TAPESCAN has a different purpose:  it can\nactually summarize the contents of the tape's DATA FILES (see figure\nfour), and IT SHOWS ACTUAL DATA, DUMPED IN HEXADECIMAL.\n\n      TAPESCAN, in its MAP operation, does three things.  First,\nit dumps the contents of the tape labels (for labeled tapes).\nSecond, it dumps the first hundred bytes of each record of a tape\nfile (in hex) for \"n\" records at the beginning of EACH file--default\nfor \"n\" is four records.  This constitutes what may be called \"a\nsummary of the data\".  Finally, at the end, it does a short version\nof what TAPEMAP's file one does, showing statistical counts for each\ntape file, and issuing summary total statistics for the entire tape.\n\n      In addition to its mapping function, TAPESCAN is a good utility\nfor copying tapes.  it issues its mapping report at the same time\nit is copying the data from one tape to the other.\n\n      This version of TAPESCAN (from file 102 of a recent CBT tape)\ncan deal with cartridges as well as reels.  This makes it \"special\".\nIt was contributed by Frank Pajerski of Syntelligence in California.\nMost other versions of TAPESCAN that are to be found, only can deal\nwith tape reels and do not work for cartridges.\n\n      Now, we'll ease away from the programs which are primarily\nmapping programs, toward the ones which are principally COPYING\nprograms.\n\n      Among these is IBM's field-developed program OSDITTO, a card\nand tape copy-dump-print utility that is the OS version of the\nubiquitous DOS and VSE DITTO programs.  OSDITTO can be used to dump\nthe contents of a tape file, or copy any part of it, record by\nrecord.  It respects only the physical data contents of a tape, and\nhas absolutely no respect for logical structures recognized by an\noperating system, such as an OS or DOS Standard Label.  With OSDITTO,\nyou can ABSOLUTELY DISPLAY what is on any part of a tape, with the\nexception of what a tape mark really is.  (You do see the EXISTENCE\nof tape marks, and OSDITTO can write them at any point on a tape,\nas desired.)\n\n       With OSDITTO, one can copy any parts of a tape file to disk,\nto another tape, or to cards.  OSDITTO is decidedly NOT A MAPPING\nPROGRAM by our definition, because IT DOES NOT SUMMARIZE OR MAKE\nSTATISTICAL TOTALS from a tape.  It merely dumps or copies tape\ndata as it is.\n\n      OSDITTO, for the record, can be run either from an MVS\nOperator Console, or from a batch run.  When it is run in batch, the\nEXEC card has to say 'PARM=JOBSTREAM'.  A help sheet, produced by\nOSDITTO function \"XXX\", gives complete syntax of all functions, for\neither console or batch operation.  As DOS or VSE users know, DITTO\noffers exquisite control from a console, although it is a bit\nawkward to use.  If you are trying to extract bits and pieces of many\nfiles from a tape, and you want to watch what you're doing, OSDITTO\nis probably one of the best utilities available.  If you want to \"fix\"\na tape, OSDITTO is also very good, provided you are willing to make\nall the adjustments by hand.  In short, OSDITTO gives a user great\nflexibility in tape copying, dumping, and altering of specific records.\nThis flexibility is probably its greatest asset.\n\n      MVS DITTO is an improved variant of OSDITTO, which may be run\nout of ISPF.  Being newer and better, it inevitably costs more money.\n\n      Now we come to some \"pure copy\" programs:  COPYMODS, COPYFILE,\nand TAPECOPY.  With the exception of TAPECOPY, these can also be found\non the CBT Mods Tape.  COPYMODS is on File 229; COPYFILE is on File\n316.  TAPECOPY was written by Aron Eisenpress of the City University\nof New York, and is obtainable from him at the CUNY Computing Center,\n555 West 57th Street - 16th Floor, New York, NY 10019.\n\n      The purpose of COPYMODS is to make a \"Xerox\" copy of a tape,\nlabels and all, if the tape has them.  COPYMODS has the additional\nability of making AS MANY AS TEN COPIES OF ONE TAPE IN ONE RUN,\nprovided the tape drives are available.  COPYMODS works well with\ncartridges, and one can mix-and-match tapes or cartridges in any\nCOPYMODS run.  Sample JCL for a COPYMODS run is shown in figure five.\nCOPYMODS has been used by Arnie Casinghino to make copies of the CBT\nTape itself, and I use it for that purpose.\n\n      COPYMODS is normally very reliable.  I know of only one case\nin which COPYMODS is fooled into ending its copy operation before the\nend of the input tape.  That case is when an \"empty\" SL file\n(standard-labeled file) is present on the input tape.  This can occur\nif you IEBCOPY-unloaded a PDS that has no members, which is a common\ncause of the condition.  Somehow, COPYMODS \"thinks\" that this set of\nheader-trailer records constitutes a double tapemark, and it stops\ncopying, even though there are other legitimate files beyond that\npoint.\n\n      One solution for getting around the empty file is to use OSDITTO\nor TAPESCAN, to bypass the \"trouble area\".  Another, smoother solution\nis to use the program especially written to copy standard-labeled\ntapes:  COPYFILE.\n\n      COPYFILE can copy all or part of a Standard-Labeled tape\nto another SL tape.  It is very powerful, in that it can literally\nCUT AND PASTE WHOLE FILES from one tape to another.  For example,\nif you want to copy files 1, 7, 8, and 13 from Tape A, and files\n23, 57, and 68 from Tape B, to files 1 thru 7 of Tape C, this is\neasily coded with COPYFILE control cards.  Partial \"HELP\" for\nCOPYFILE is included in figure six.  COPYFILE is not fooled by any\nstandard labels on a tape, and it can faithfully copy an SL tape\ncontaining null SL files within it.  The only condition is that\nthe output volume serial must be different than the input volume\nserial, because COPYMODS actually refers the tape to the operating\nsystem as SL, and not as BLP.\n\n      COPYFILE is a very very powerful utility, and the implications\nof having it are really much farther-reaching and warrant a larger\ndiscussion than I can give here.  Suffice it to say that COPYFILE\nallows you to custom-build special output file collections on one\ntape, made from several of the tapes in your library, without the\nintervention of any intermediate disk files.  Tape-to-tape\ncustomization is definitely in your power, if you know how to use\nCOPYFILE.\n\n      Finally, we shall discuss TAPECOPY.  TAPECOPY is an older\nprogram, but it has been made to work for cartridges, since the CUNY\nComputer Center is dominated by cartridges, and there are very few\nold 3420 tape drives left there.  TAPECOPY is similar in function to\nTAPESCAN, but with more emphasis on copying than on scanning for data.\nOne noteworthy thing that TAPECOPY will do, is to manufacture standard\nlabels, so as to make a standard-labeled tape out of a non-labeled\ntape.  The DCB information that would be written on the labels for all\nthe files is entered as a PARM on the EXEC card, and has to be the same\nfor all the created file labels.  This is a drawback, but it is better\nthan having no such utility at all.\n\n      Using the SL-creating ability of TAPECOPY, I have figured out\nhow to edit the 472-file non-labeled CBT tape without using much disk\nspace, but by doing mostly tape-to-tape copy processes.\n\n      First, I create a standard-labeled master version of the current\nCBT tape on a 3600-foot super reel, using TAPECOPY to manufacture the\nstandard labels.  Under ordinary circumstances in my shop, the CA-1\ntape management system would necessitate 1419 console replies in order\nto do this to completion.  (At first, I automated the replies with a\nTSSO AOF table - see last month's column - but the flood of CA-1 reply\nrecords blew the TMS.AUDIT file, so this was unsatisfactory.)  A\nUSERMOD from CA-1 support, reducing the number of required replies to\nONE, provided a better long-term solution, and a big standard-labeled\nmaster CBT tape was created.  See figure seven for the JCL.\n\n      Now that the Old Master tape is standard-labeled, I can employ\nthe services of the COPYFILE program.  Changed files, or new files,\ncan be placed on another SL \"transaction tape\".  Using the COPYFILE\ntape-file splicing capability, a \"New Master\" SL tape can be created\nby merging the transaction tape files into their proper places on the\nbig tape.  Once the CBT New Master SL tape has been finalized, all\nthe labels can be stripped off by a big OSDITTO batch job (see figure\neight), to create an updated, non-labeled new CBT tape to distribute.\nThis is a good example of how several of our tape tools can be\ncombined to complete a desired task.\n\n      I hope that this article will stimulate our readers into\ncreative thinking.  There are enormous opportunities in innovative\ntape manipulations.  Possibly, some of you will send in your ideas\nas letters to the editor, or even as articles, so we all can benefit.\n\n      Good luck, and good thinking!  See you next month.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9002FE": {"ttr": 5388, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93!\\x0f\\x00\\x93!\\x0f\\x145\\x01'\\x01'\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "1993-07-29T14:35:00", "lines": 295, "newlines": 295, "modlines": 0, "user": "SBGCSC"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          February 1990\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n\n\n      This month's column is divided into two parts with one\nconnection:  that it pays for all of us, when each one of us makes\na small contribution for the \"public good\".  Yes, Virginia, there\nreally is some hope in the world, and there are \"little\" ways in\nwhich we can all do some small thing which will benefit OURSELVES\nTOGETHER WITH OTHERS.  The trick is to do a little at a time, and\nthe accumulated effect adds up.  Have you ever seen a tug of war?\n\n      One of the two parts concerns the oft-mentioned CBT MVS Mods\ntapes, now distributed by NaSPA.  Please remember that the CBT tapes\nhelp the entire MVS world by providing software and other assistance\nin the running of an installation.  The demise of these tapes had\nbeen threatened by possible closing of a large data center where they\nhad been put together.  Not only will the CBT tapes survive, but a\nfew glimpses of the ongoing \"modification process\" which keeps this\ntape so timely, will show how the willingness of one person (at a\ntime) to enhance or fix a public program helps the entire public.\n\n      The other piece of this month's story is an update to our\nongoing narrative about the amazingly useful SLAC (Stanford Linear\nAccelerator Center) Modifications to Assembler H version 2.  It also\nconcerns efforts from the public.  These are our efforts to convince\nIBM that it will be good for all (including IBM itself MOST of all)\nif the \"SLAC Mods\" would be incorporated into the Assembler H product\n\"officially\".\n\n      PART ONE.  The Ongoing Process of Updating a MODS Tape.\n\n      I have often stated that the CBT MVS Mods Tape, which contains\npublic-domain MVS software, is a vibrant, growing source of help to\nMVS installations.  Continuing updates to the tape keep many of the\nincluded products compatible with the latest levels of the operating\nsystem.  Handy software tools, previously found on the tape, become\nhandier as interested programmers take the initiative to improve them\nfurther and further.\n\n      The new versions 310 and 311 of the CBT tape that appear at\nthis writing, contain a considerable number of new and improved\nfiles.  For example File 187, a program to convert CLIST libraries\nfrom FB-80 format to VB-255 format and vice-versa, has been very\nuseful, but the program had had some prominent bugs, especially in\nconverting from VB-255 to FB-80 format.  It has now been greatly\ndebugged, and the current version works very well going in either\ndirection.  This development should aid any installations desiring\nto change their CLIST formats.  The program on File 187 as debugged,\nshould now make any such conversion completely effortless, because\nall CLIST libraries can now be quickly converted IN EITHER DIRECTION\nwithout fear (hopefully) of broken execution of some of the CLISTS.\n\n      Another small example concerns the extremely helpful TAPEMAP\nprogram from File 299 of the CBT tape.  About a year ago, I added\nCBT-tape support to the program, so that it could read member names\nfrom the compressed files of the CBT tape.  That support somehow\ninterfered with the proper page-ejection in the second TAPEMAP\nreport, the one that shows the member names in the files.  The\nproblem of the page ejects baffled me greatly, and I had given up on\nit.  Recently an interested programmer called Arnold Casinghino, the\nproprietor of the CBT tape, with a one-line fix to this page eject\nproblem, so that the bug seems now to have been solved.  I was of\ncourse relieved, and the public has been helped.  I took the\nopportunity (once he was changing the file already) to supply Arnie\nwith my version of TAPEMAP (page-eject fix merged in) that includes\n3480 cartridge support in compatibility mode, so the public has been\nserved more.  This illustrates the process, and we can see a bit\nbetter how one contribution at a time, helps.\n\n      One of the most significant additions to the newest versions\nof the CBT tape is File 134 from Greg Price of the State Electricity\nCommission of Victoria Province in Melbourne, Australia.  These guys,\nbless their hearts, are on the other side of the world.  I would\ndefinitely think twice before trying to phone them up (although I\nhave phoned ONCE).  However, no matter where they are physically,\ntheir work can been very helpful for all of US, and that is my\npoint.  The process can go on across the world and back.\n\n      These fellows from Australia have worked over some of our most\nbeloved programs from older CBT tapes, and have created super new\nversions of them.  Those have been combined with some of their\noriginal creations, to produce this new File 134.  We have public\nparticipation at its best here, and we all stand to benefit.  Some of\nthe objects of their \"renovation\" work are:\n\n      UCLA Full Screen Zap.  This incredibly handy disk zapping\nutility, most recently found on File 300 of the CBT tape, has several\nimprovements in the File 134 version.  First, it is now possible to\nzap ANY ITEM ON AN ENTIRE VOLUME, using the newly supported \"FULLVOL\"\nkeyword.  This keyword will cause fullscreen ZAP to access any track\non the volume containing the dataset named at ZAP invocation.  For\nexample:\n\n       ZAP  dataset.name   FULLVOL\n\nwill cause ZAP to access track 0 of the volume containing the\ndataset.  One can afterwards position to any track on the volume,\nusing the \"T\" subcommand.  In addition, the new subcommand VTOCDS4\ncan be used, to immediately position us to the Format4 DSCB or VTOC\nheader, so we may quickly look at the VTOC or ZAP it.  We can use the\n\"full volume facility\" to search an entire volume for any single\ncharacter string, using the \"F\" or \"find a string\" subcommand.  It's\nconceivable that we could test an entire disk volume for the presence\nof a virus, if we knew, for example, that the virus contained a\nparticular string.  This is a capability we did not have before.  We\nshould, of course, keep AUTHORITY for this out of the hands of most\npeople, but for sysprogs it can be most helpful.  It can SAVE IPLs\n(rather than cause them) if it is used with care and system\nknowledge.\n\n      Some further examples of the use of these ZAP enhancements\nare:  \"clip\" of an online pack (change of its volume serial).\nNormally, this is done with the pack offline using the ICKDSF \"device\nsupport\" program from IBM.  In a real emergency, record 3 of track 0\ncan be accessed and the volume name changed with the pack online, if\nnecessary.\n\n      Back to File 134 and the work of those marvelous Australians.\nMany of you are undoubtedly familiar with the \"REVIEW\" TSO command\nfrom File 296 of the CBT tape.  That command is a full-screen file\nbrowser, which is not dependent on ISPF at all.  It can therefore be\ninvoked from a TSO clist at any time TSO is up.  For example, I have\na CLIST that REVIEWs members of my SMPPTS library, so that I can\nbrowse my RECEIVED PTFs.  The File 296 version, while being handy and\na big improvement over TSO \"LIST\" or no tool at all, has several\nshortcomings.  The most notable of these is its 1024-byte width\nlimit.  Even when REVIEW-ing a \"wide\" load module, only the first\n1024 bytes of the record can be looked at.  The Australian version\ncan show even 32760 bytes of a single data record.  It will also\nREVIEW entire PDS'es, supplying a really nice ISPF-like sortable\nmember list in the process.\n\n      That new version of REVIEW has other extended use as well.\nSince the wide record-browse capability is available, it is now\npossible to BROWSE TAPE FILES ON TSO using REVIEW.  A CLIST called\nREVTAPE is provided, which shows you how to do this.\n\n      One shortcoming that the \"new\" REVIEW has over the \"old\" one\nis the lack of some PF1 \"HELP\" support.  Although the PF keys\nsupported (except for PF1) are the same in both versions, the\nfull-screen help prompts that are displayed in the File 296 version\nare missing from the File 134 version.  Perhaps one of our readers\nwill merge that code into the Australian code and send it back to the\ntape, or perhaps the Australians themselves may do so at a later\ndate.  In any case, you see the mutual help process that is going on\nhere, which makes the public tapes so useful for us all.\n\n      A file which is not a program, but which is nevertheless\nof great use, is the \"ABEND\" file.  This is a TSO \"help\" member that\ntells us the meaning of the system abend codes.  We thus can get\nthe explanation of system failures online, so that we don't need to\ngo to the message book so often.  Greg Price extended the old file\n(in File 300 of the CBT tape) to include more recently introduced\nMVS abends, and also some vendor product user-abends.  Thanks again,\nGreg.  We COULD HAVE done it, BUT YOU DID IT, in the course of your\nregular work.\n\n      We can see how the \"we'll help each other\" spirit of the\npublic-domain utility tapes benefits us all, and depends on our\ncontributions.  People who send something in tend to think that they\ndidn't do much, but that's not true.  WHAT YOU DID, THE OTHER GUY\nDOESN'T HAVE TO DO.  IT SAVES LARGE NUMBERS OF PEOPLE THE NEED TO DO\nTHE SAME JOB OVER.  When you add up the \"small pieces\" that each\nperson or group contributed, you'll get a very large collection of\ntools and useful materials in total.  But that is not all.\n\n      Even \"using the stuff alone\", WITHOUT trying to send a fix in,\nalso contributes to the public good.  More exposure for the software\ntools encourages more debugging of defects.  Your shop will benefit\nfrom the immediate use of the tools, and some benefit outside the\nshop will eventually accrue.  One of the other staff members may fix\nsomething.  Somebody at your shop could carry the program to another\nshop, and somebody there will send in a fix.  ANY PARTICIPATION HELPS.\n\n      NaSPA Headquarters at (414) 423-2420 distributes the CBT tape.\nPlease call them and order it.  Information on its current editors\nwill be inside in File 1.\n\n      PART TWO.   The SLAC MODS to ASSEMBLER H  -  An Update\n\n      In last September's \"MVS Tools\" column, I described some\nmarvelous improvements to ASSEMBLER H version 2 that were\naccomplished through the \"SLAC MODS\", which are modifications to\nthe IBM H-assembler.  These covered the areas of reporting,\nlanguage, and performance.\n\n      Among the reporting modifications mentioned, were:  full\nreporting of the NAMES and ORIGIN of any MACROS called, reporting\nof all active USINGs at each page break, and a level 4 error\nmessage to signal if any USING was coded that \"broke the rules\" for\nconflicting USING statements.  The SLAC MODS offer many other\nreporting improvements, as well as performance enhancements and\nextensions to the assembler language rules.\n\n      There exists a level of the SLAC MODS that has been applied\nto Assembler H at the 8906 PUT level, with full MVS instruction\ncapability through ESA, and incorporating the DBCS support.  This\nis supported outside of IBM.  It is currently being beta tested on\nboth MVS and VM, and it works very well.  Negotiations are currently\nbeing conducted with IBM concerning the incorporation of the SLAC\nMODS into the IBM-distributed Assembler H.\n\n      What my previous article lacked was illustrations.  This\nsupplement is intended to remedy that deficiency somewhat.  Please\nnote the several examples.  However, they show only a few of the\nmany extra capabilites.  The SLAC MODS are actually very powerful and\nconstitute a big improvement to the assembler.\n\n      There is a problem concerning the distribution of our version\nof the mods.  ASSEMBLER H Version 2 is a licensed program product of\nIBM, and our source updates include PTF code.  As of this writing,\nnegotiations are getting under way between IBM and the Stanford\nLinear Accelerator Center (SLAC) concerning legalities.  We are hoping\nsoon to get some clarity on these issues.  (Perhaps by the time this\narticle appears, the matter will have progressed further.)\n\n      The ideal solution, of course, would be for IBM to absorb the\nmods, language enhancements included, and then everyone in the MVS\nand VM worlds could benefit.  In order for them to do that, THEY HAVE\nTO FEEL THE NEED.  CUSTOMER PRESSURE WILL BE THE ONLY WAY TO GET THEM\nTO ACT.  I know, because I am speaking with the IBM management\ncontinually.\n\n      PEOPLE MUST BECOME DISSATISFIED WITH THE ASSEMBLER.  It is a\ngood program, but it has glaring deficiencies.  It doesn't tell you\nwho and where your macros are.  In a long program, you are NEVER sure\nwhich USING statements are active.  DSECTs scattered throughout a\nprogram are very confusing--the SLAC enhancements help the programmer\nmap them out.  Non-referenced labels are reported by the modified\nassembler.  One can find out if there are branches to a label or not.\nOne can even request OPCODE and MACRO occurrence counts.  There is a\nlot about IBM's assembler to be dissatisfied with.  IT DOES NONE OF\nTHESE THINGS.\n\n      Regarding the language enhancements, for example:  \"labeled\"\nand \"associated\" USING statements to conserve addressing registers,\nrelaxation of the rules for defining global variables, and many\nothers, we are in a \"Catch-22\" situation.  Users of the SLAC Mods are\nhesitant to use the language enhancements in their code, because\nIBM's \"vanilla\" assembler currently won't handle them.  On the other\nhand, the result is that not much experience has been gained with the\nlanguage enhancements by users, so the advantages of having them are\nnot widely known.  Therefore it is hard to put pressure on IBM.  I\nhope that in a future supplement, we can address the issue of these\nlanguage enhancements to the assembler, and I can tell the people\nwhat the enhancements are.\n\n      For now, look at the accompanying illustrations.  If you want\nto have this capability, you can campaign for it with IBM.  PLEASE\nRAISE A RUCKUS with your SE, with the support center, at IBM user\ngroup meetings, ANY WAY you are able to, and PLEASE WRITE A LETTER TO\nME.  I am very surprised by how people can put up with many\ninconveniences while they are programming in assembler or fixing\nassembler code, and not complain to IBM.  They probably feel that IBM\nwon't make a big coding effort.  Well, folks, the coding effort\nhas largely been made.\n\n      Don't take the status quo for granted.  You really CAN\ncontribute to changing it, especially since the necessary code\nchange already exists, and is operational.\n\n      Finally, if you are currently NOT A LICENSEE of Assembler H\nand you see our illustrations, PLEASE LISTEN CAREFULLY.  YOU CAN\nHELP THIS CAUSE MORE THAN ANYBODY ELSE!  This may sound irrelevant\nto current ASM H users looking for an improvement, but IBM's main\napproach during our negotiations with them was:  \"Will these changes\nsell more Assembler H licenses?\"  This is the principal way that IBM\nupper management measures customer demand (silly as that may seem to\nus in this situation, with the Assembler being so pervasive in MVS\nand VM shops, and within IBM itself).  NON-LICENSEES, PLEASE MAKE\nYOURSELVES HEARD!  If IBM management senses that they will increase\ntheir licensee base by incorporating significant modifications to\nASSEMBLER H, they will undoubtedly put much more effort into\nAssembler language development.\n\n      What can you do?  Please send a letter to me directly.  My\naddress is listed in this magazine in the PF1 column.  Please make\nsure that my name appears on the envelope.  I will try to directly\nforward all letters received to IBM management, and they will surely\nhave effect.  Second best, send a message to my NASCOM id, GOLOSHMA.\nAsk your SE or the support center how you can communicate with IBM\ndirectly or indirectly.  Call the magazine and ask what else you can\ndo to help, leaving your name and phone number.  PLEASE DO SOMETHING.\n\n      Such activity will wake IBM up from their deep sleep in the\nassembler language area.  There is a very good chance that we can get\nsome results, because IBM is largely driven by customer pressure.\n\n      Thanks and good luck.  See you next month.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9004AP": {"ttr": 5638, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x93!\\x0f\\x01\\x00)\\x9f\\x11G\\x01\\xfd\\x01\\xfd\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 509, "newlines": 509, "modlines": 0, "user": "WSBG"}, "text": "\n                MVS TOOLS AND TRICKS OF THE TRADE\n                          April 1990\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n\n\n      This month, I'd like to begin a mini-series to feature a\ndeserving product that is found on the CBT Mods Tape.  Anyone who\nhas extensively used this product will immediately understand why\nwe should devote some major attention to it.  I'm definitely not\nrepeating myself in talking about this product more than I have\nalready.  Using this package will earn you some enormous savings\nof time and effort!\n\n      I have been asked (even by my boss) how it is possible for me\nto do all of my company work, and still have time to write articles\nand do many \"side projects\" in the systems programming field.  My\nreply is invariably that I use many tools to shorten the work.  The\ntime invested in installing and learning the tools, is quickly made\nback from the shortcuts made possible by using them.  My second\nreply, is that \"I use PDS\".\n\n      I have written quite a lot about \"PDS\" (the PDS Program\nProduct).  Those of you who are immersed with using PDS, will readily\nagree that I have not come near to saying enough about its enormous\npower to help a systems programmer.  To answer the skeptics, let me\njust tell you how my own involvement with this marvelous product\ngrew.\n\n      A good friend was kind enough to give me my first CBT\ntape \"n\" years ago.  After looking at a printout of File 1 (the\ndocumentation), which describes its enormous number and variety of\nfree offerings, I felt like a kid in a toy store who could take\nhome any toy he wanted for nothing.  For close to half a year, I\ncollected and tried tools by the dozens, expanding my powers and\nenjoying every minute of it.  I remember installing eight programs\none day, six the next, another four or five afterward, and so on\nfor a good while.\n\n      Then my friend took me aside.  He told me to look inward\ninstead of outward.  \"Look inside PDS alone for a while.  You'll\nsee almost all of what you need in there, usually done even better\nthan with the 'individual' tools.\"  Having been awakened to notice\nthe PDS product, I surprised even myself by being absorbed for the\nnext half year in exploring the tools that were embedded in it\nalone.\n\n      This is a true story.  Hear me out, and see some of the things\nthat PDS can do, easily and with small effort, for you.\n\nGETTING THE TOOL (if you don't already have it).\n\n      First you have to GET PDS.  It is found (version 8.3) on File\n182 of a recent CBT tape, with necessary auxiliary programs on Files\n296 and 112 of that tape.  The install is the assembly-link of a load\nmodule, and the copying of ISPF panels and a message member into the\nappropriate libraries for your ISPF session to use.  Assembly and\nlinkedit of the auxiliary load modules from files 296 and 112\ncompletes the installation.  Options for tailoring the main load\nmodule can be adjusted using conditional assembly globals that are\nlocated in members #PDSGEN and #PDSGENB of file 182.  That's it.\n\n      PDS is executed as a TSO command, or as a dialog manager\noption under ISPF.  If ISPF is present in the TSO session, the two\nmodes may be toggled back and forth.  PDS may also be executed\nrecursively under ISPF if a command table entry is set up to invoke\nit (see my May 1989 column).\n\n      PDS comes with loads of documentation and a TSO help member\nfor all its subcommands.  PDS is free for all to use.\n\n      For your extra information, a vendor-supported outgrowth of PDS\nwith additional capability (called PDS/E) has been released by Serena\nConsulting of Burlingame, California and is being supported by the\nprincipal authors of the free PDS product.  PDS/E, although currently\na released product, is being intensively enhanced further by its\ndevelopers, and I can assure you that its maintenance agreement will\nbe well worth the money.\n\n      However, the public product's great capabilities even without\nthe vendor enhancements are extremely beneficial to its users, and\nso, we will concentrate on the public PDS product in this column.\nPeople in installations that \"do not like public software\" may\ninquire from Serena about PDS/E.  Also, you may want some of the\nextra capability of PDS/E later on, once you have a good idea of what\nthe \"free\" PDS can do.  But \"public PDS\" offers enough to swamp a\nuser's curiosities for a good while, as it did to my own.\n\nONCE YOU'VE GOT IT, WHAT CAN YOU DO ?\n\n      What are some sticky everyday system programming situations\nthat can be easily solved with PDS?  We will consider one particular\nproblem for this month's instalment.\n\n      The problem is:  How can you keep track of vendor load modules\nin a big program product library, where lots of modules from many\ndifferent packages have been mixed together?  There is a familiar\ndifficulty that occurs when you have reinstalled later releases of\nsome of the products.  How do you make sure all of the modules in\nthe library are from the new release and that you've deleted the\nmodules from the older releases?  How can you ensure the \"purity\" of\neach product whose modules are in that library?\n\n      This is really not a hard problem to solve, when PDS is\navailable.  (It is as close as the nearest NEW CBT tape.)  One\nneed only implement a few product installation standards made\npractical by certain of the PDS capabilities.\n\n      The solution boils down to MARKING the load modules, to show\nthem as belonging to a certain product and a certain release at\ninstall time.  Then, to isolate all the modules from one product,\nonce they've been mixed together with the others, you merely have to\npick these modules out by use of the \"markings\" you've given them.\n\n      The modules from an older release of one product will then\nbe shown as belonging to that product, but to a previous release of\nit.  Modules from a completely different product will have completely\ndifferent markings, so they will be readily distinguishable from all\nmodules belonging to the other products.\n\n      How does PDS make it possible to implement this scheme?  PDS\nhas the capability of SUPPLYING SUCH MARKINGS.  It can also POSITIVELY\nSELECT ONLY THOSE MODULES having certain given markings or partial\nmarkings.  Thus, it can choose with complete certainty, all modules\nbelonging to a given product, or to a known release of that given\nproduct, provided that the modules have been marked.  It will exclude\nall other modules in the library from the selection.  In this way, we\nhave achieved positive recognition of all modules belonging to a\ngiven product and a given version of that product.\n\nHOW DO YOU USE PDS TO MARK LOAD MODULES ?\n\n      So what are the markings?  And how does PDS supply them and\nuse them for group selection?\n\n      For a load module, the user-supplied \"marking\" is the \"SSI\" or\n\"System Status Indicator\".  The SSI is a four-byte hex number (eight\nhex digits) that can be placed in a module's load library directory\nentry by the linkage editor.  During linkedit, the SSI is supplied\nusing the control statement, SETSSI, followed by the eight hexadecimal\ndigits which will constitute that module's SSI.\n\n      PDS can change any module's SSI \"on the fly\" without another\nlinkedit, or it can supply a new SSI where none existed before.  PDS\ncan not only do this for one load module at a time, but it can do it\nfor any preselected group of modules in a library or for all members\nof the library, all at once.\n\n      PDS can also look at any load library and select only those\nmodules having a given SSI, partial SSI, or consecutive string pattern\nin an SSI to be in its current member subgroup.  Membership in PDS's\ncurrent member subgroup means that subsequent PDS operations can be\nperformed on ALL MEMBERS IN THE ENTIRE SUBGROUP AT ONCE.  PDS can\nthen delete or copy out to another library, all the modules belonging\nto one subgroup of members.  We see that we can isolate and/or operate\non one product's modules from within a large library through using\nPDS.\n\n      Which PDS commands can change a module's SSI, and what commands\nwill select all modules in a library having a certain given SSI?\n\n      To supply an SSI to a load module, or to change an existing\nSSI, we use the ATTRIB subcommand of PDS.  If we wish to mark all\nmodules in an install library with the same SSI, the commands would\nbe:\n\n       PDS  install.library.name\n                       Assuming PDS is the PDS load module's name,\n                       this command points PDS to the desired library.\n\n       ATTRIB  :  SSI(hhhhhhhh)\n                       where the colon in the member name field\n                       signifies \"all members\" and hhhhhhhh is\n                       the eight-digit SSI hex number that we\n                       want to assign to all the modules.\n\n      If we've already selected a subset of members to be included in\nPDS's \"current member subgroup\", we can supply the SSI to all of\nthese members at once, by substituting an asterisk \"*\" for the colon.\nAn asterisk in the member name field of a PDS subcommand always\ndenotes \"all members belonging to the currently selected member\nsubgroup\".\n\n      At install time for a product, we can easily supply a telltale\nSSI to all its modules by using the ATTRIB subcommand of PDS.  Then\nwhen we copy the modules into the program product library for public\nuse, they will already have been distinctly and properly marked.\n\n      How can we use PDS to select a member subgroup consisting of\nonly those modules having a certain given SSI?  We can do so, using\nthe \"IF\" subcommand of PDS.  The actual command would be:\n\n       IF  :  SSI(hhhhhhhh) THEN(SUBLIST)\n\n\"SUBLIST\" is a PDS command that creates the \"current member subgroup\"\nas a list of member names.  Thus, the result of the subcommand is,\nthat the new \"current member subgroup\" defined by PDS, now consists\nof a list of only of those members having the SSI equal to \"hhhhhhhh\".\nThe currently selected subgroup can now be referred to by putting the\nasterisk \"*\" in place of the member name field in any PDS subcommand\nexecuted subsequently.\n\n      Thus,\n\n       COPY  *  'ANOTHER.LIBRARY'\n\nwill copy all of the selected members over to 'ANOTHER.LIBRARY'.\n\n       DELETE  *\n\nwill delete all the members of the subgroup from the current library.\nAnd so forth using other PDS commands.\n\n      In our installation, we use the following SSI naming convention\nto mark vendor load modules.  The first four hex digits will denote\nthe product identifier (made to be consistent by arbitrary\nconvention).  The last four digits will be a designation of the\nrelease and modification levels.  Therefore modules from CA-11\nRelease 1.4 newsletter 2 will be marked with an SSI of CA111402.  To\npick out ALL CA-11 modules in a given library, we need only ask for:\n\n       IF  :  SSI(CA11) THEN(SUBLIST)\n\nand we will get ALL modules of ALL releases of CA-11 that we have\npreviously marked and installed.  This is because any SSI that we\nassign to a CA-11 load module always begins with the four hex digits:\nCA11.  To obtain CA-11 modules belonging only to release 1.4, we will\ninstruct PDS as follows:\n\n       IF  :  SSI(CA1114) THEN(SUBLIST)\n\nThis command will pick all of the CA-11 release 1.4 modules, regardless\nof \"newsletter\" modification level.  Finally, to pick the CA-11\nrelease 1.4 modules that have been upgraded by the Newsletter 2\nmodification level, we merely ask PDS:\n\n       IF  :  SSI(CA111402) THEN(SUBLIST)\n\nand all modules affected by the Newsletter 2 upgrades, will be selected\nfor membership in the current member subgroup.  This whole scheme is\nneat and simple.\n\nEnter SYS1.VENDOR for Forensics.\n\n      In addition to marking all of our program product modules to\nbe selectable by partial SSI, we maintain another card-image type\nlibrary that we call SYS1.VENDOR.  In SYS1.VENDOR, we keep some\n\"fingerprints\" of each module that was installed with a new release\nof a product.  These \"fingerprints\" are generated by some other\nfacilities in PDS, and they can readily be compared with similar\nfingerprints generated from the currently running modules that are in\nthe system.  Having the fingerprints available from install time will\noften enable us to determine if a module has been changed since then.\n\n      What kind of fingerprints do we take?  Actually, PDS gives us\na considerable choice.  Our own choice was affected by the\nconsideration that we did not want the records to be too bulky.  In\npractice, we take four or five pictures of the modules in our shop.\nWe take a short ATTRIB listing, a long MEMLIST listing, a MEMBERS\nlisting, and a linkedit HISTORY listing.  If there are not too many\nmodules, we may also keep CSECT MAPS of them, obtainable with the PDS\n\"MAP\" command.\n\n      With these listings on record, it is possible in most cases to\npositively identify the particular level of any vendor-supported load\nmodule that we have in one of our production libraries.\n\n      I have supplied illustrations (Figures 1 thru 6) to show the\nkinds of \"module fingerprints\" that we keep.  Seeing these should be\nmost instructive in illustrating the power of our techniques.  Please\nbear in mind that corresponding records can always be obtained by PDS\nfrom existing load libraries, so that we can graphically compare our\narchived snapshots with current ones obtained from modules we are now\nusing.\n\n      In conclusion, we have shown how a very small subset of PDS\ncapabilities will support an important function that every\ndata processing shop has to cope with--making sure that you're\nexecuting the correct version of your programs.  Application groups\ncan benefit from these techniques also, and can just as easily use\nthem as we systems programmers can.\n\n      I hope that next time, I can present another, equally useful\nshop technique that exploits the powerful PDS utility functions.\nIf you (our readership) keep your enthusiasm, we can keep doing this\nfrom time to time, and add to the mini-series every couple of months.\n\n      I have considered the idea (energy permitting) of producing\na periodical PDS(/E) Newsletter containing techniques such as this.\nGiven the versatility of PDS and PDS/E, such a newsletter can go on\nfor years and years and years.  Anyone who has ideas or suggestions\nabout such a project and its benefits may call me directly or write\nto me about it.\n\nWHO YOU GONNA CALL ?\n\n      The CBT MODS TAPE can be obtained from NaSPA at (414) 423-2420.\nThis tape contains \"public PDS\" and many other fine products.\n\n      SERENA Consulting distributes PDS/E and is located in Burlingame,\nCalifornia.  They usually have an ad in this magazine that includes\ntheir phone number.\n\n      My phone number is              .  Any PDS(/E) Newsletter\nideas regarding distribution, contributions, or material are most\nwelcome and appreciated.\n\n      Good luck in all your endeavors.  Hope to see you next month.\n\n\n    *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n Figure 1.   \"Fingerprint\" Members for a Product Install\n               in the SYS1.VENDOR Library.\n\n\n\n ------------------------- MEMLIST Source Member List 1 -----------  ROW 1 OF 5\n COMMAND ===>                                                  SCROLL ===> CSR\nEnter an ISPF command, a PDS/E subcommand or a special control code:\n FUNCTION FEATURES CODES    NAVIGATE DSNCMDS  MEMCMDS  DEFAULTS OTHER\n - DSN=SYS1.VENDOR,VOL=SER=MVSRES  MEM=(CA11  ----------------------------------\n CMD  NAME     DATA     VER.MOD    CREATED   LAST MODIFIED  SIZE  INIT    ID\n      CA11               01.00    88/10/20  88/10/20 14:22   344   344   CA11-14\n      CA11A              01.00    88/10/20  88/10/20 14:22   120   120   CA11-14\n      CA11E              01.00    88/10/20  88/10/20 14:22    23    23   CA11-14\n      CA11H              01.00    88/10/20  88/10/20 14:22   375   375   CA11-14\n      CA11M              01.00    88/10/20  88/10/20 14:22   835   835   CA11-14\n ****************************** BOTTOM OF DATA  ********************************\n\n\n    *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n\nFigure 2.   Output of \"Long\" PDS MEMLIST Listing for Load Modules.\n\n\n\n*** MEMLIST TABLE OUTPUT ***           2.06.28 PM      THURSDAY    OCT 20, 1988\n\n- DSN=TST.CA11.LOADLIB,VOL=SER=VEND01  MEM=(CACTPROD\nCMD  NAME     DATA     ALIASOF  LEN/LKED --  ATTRIBUTES   -- APF  MODE  MAIN\n                       MATCH    LENGTH   TTR       ENTRY     SSI\n     CACTPROD                   88/07/21 REUS\n                                0015C0   001204    000000    CA111400\n\n     C11ICNQ0                   88/07/14                     AC=1\n                                000D70   000128    000000    CA111400\n\n     C11ICUP0                   88/07/14                     AC=1\n                                000EA8   000219    000000    CA111400\n\n     C11IDIS0                   88/07/14                     AC=1\n                                000DC8   000205    000000    CA111400\n\n\n    *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 3.   Output of \"Short\" PDS ATTRIB Listing for Load Modules.\n\n\n\n\n*** LOG TABLE OUTPUT ***               2.07.38 PM      THURSDAY    OCT 20, 1988\n\n- DSN=TST.CA11.LOADLIB,VOL=SER=VEND01  MEM=(CACTPROD\n>at * short\nNAME     ALIASOF   CREATED  SIZE SSI      ATTRIBUTES\nCACTPROD          88/07/21  5568 CA111400 REUS\nC11ICNQ0          88/07/14  3440 CA111400 APF=1\nC11ICUP0          88/07/14  3752 CA111400 APF=1\nC11IDIS0          88/07/14  3528 CA111400 APF=1\nC11IJNQ0          88/07/14  3552 CA111400 APF=1\nC11IJUP0          88/07/14  4344 CA111400 APF=1\nC11ILJO0          88/07/14  3400 CA111400 APF=1\nC11ILRE0          88/07/14  3176 CA111400 APF=1\nC11ILST0          88/07/14  3464 CA111400 APF=1\nC11IONQ0          88/07/14  3176 CA111400 APF=1\nC11IPRE0          88/07/14  4096 CA111400 APF=1\nC11IPUL0          88/07/14  3352 CA111400 APF=1\nC11IRST0          88/07/14  3624 CA111400 APF=1\nC11IRUP0          88/07/14  3576 CA111400 APF=1\nC11ISIM0          88/07/14  4096 CA111400 APF=1\nC11ISTA0          88/07/14  3584 CA111400 APF=1\nIEFACTRT          88/10/20 18424 CA111400 RENT, REUS\nL7CNTL            88/06/16   224 CA111400 REUS\nL7CNTL14          88/06/16   224 CA111400 REUS\n\n\n    *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 4.   Output of PDS \"MEMBERS\" Subcommand.\n\n\n\n\n*** LOG TABLE OUTPUT ***               2.09.29 PM      THURSDAY    OCT 20, 1988\n\n- DSN=TST.CA11.LOADLIB,VOL=SER=VEND01  MEM=:\n>mem *\nMEMBERS ARE: CACTPROD, C11ICNQ0, C11ICUP0, C11IDIS0, C11IJNQ0,\n         C11IJUP0, C11ILJO0, C11ILRE0, C11ILST0, C11IONQ0, C11IPRE0, C11IPUL0,\n         C11IRST0, C11IRUP0, C11ISIM0, C11ISTA0, IEFACTRT, L7CNTL, L7CNTL14,\n         L714CNTL, L714INIT, L714PTF, NW1ACTRT, UCCACTRT, UCCEFUJV, UCC11BLD,\n         UCC11BNQ, UCC11CIE, UCC11CII, UCC11CRD, UCC11DAT, UCC11DYN, UCC11GRP,\n         UCC11HEX, UCC11INT, UCC11JQM, UCC11MGR, UCC11MSG, UCC11MS0, UCC11MS2,\n         UCC11MS3, UCC11MS6, UCC11MS8, UCC11OBD, UCC11OCD, UCC11OCF, UCC11OCI,\n         UCC11OCP, UCC11OCR, UCC11OCU, UCC11ODC, UCC11ODS, UCC11OHL, UCC11OJB,\n         UCC11OJD, UCC11OJF, UCC11OJI, UCC11OJK, UCC11OJS, UCC11OJU, UCC11OOI,\n         UCC11OPI, UCC11OPL, UCC11OPR, UCC11OPT, UCC11ORR, UCC11ORU, UCC11OSM,\n         UCC11OSP, UCC11OSR, UCC11OST, UCC11OTD, UCC11PDS, UCC11PJQ, UCC11PRE,\n         UCC11PRT, UCC11PSU, UCC11RCP, UCC11REA, UCC11RES, UCC11RMS, UCC11R21,\n         UCC11R22, UCC11R23, UCC11R24, UCC11R25, UCC11R26, UCC11R27, UCC11R28,\n         UCC11R31, UCC11R41, UCC11R42, UCC11R43, UCC11R44, UCC11R81, UCC11SUP,\n         UCC11SVC, UCC11TRT, UCC11TR1, UCC11TR2, UCC11TR3, UCC11T30, UCC11T45,\n         UCC11UCS, UCC11UPD, UCC11UPF, UCC11UTI, UCC11VSM, UCC11WRK, U11JCC,\n         U11JCR, U11RDSEX, U11SRUEX\n\nTHIS GROUP CONTAINS 113 MEMBERS\n\n\n    *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 5.   Output of PDS Linkedit HISTORY Listing.\n\n\n\n\n*** LOG TABLE OUTPUT ***               2.10.44 PM      THURSDAY    OCT 20, 1988\n\n- DSN=TST.CA11.LOADLIB,VOL=SER=VEND01  MEM=:\n>hi *\n\n** HISTORY  CACTPROD\nLAST LINK-EDITED ON  7/21/88  BY LKED 566528408  V71 M00\n\n** HISTORY  C11ICNQ0\nUSER-SUPPLIED UPDATE HISTORY BY CSECT -\nISPLINK       4/01/85    RSI50860044\nLAST LINK-EDITED ON  7/14/88  BY LKED 566528408  V01 M00\n\n** HISTORY  C11ICUP0\nUSER-SUPPLIED UPDATE HISTORY BY CSECT -\nISPLINK       4/01/85    RSI50860044\nLAST LINK-EDITED ON  7/14/88  BY LKED 566528408  V01 M00\n\n** HISTORY  C11IDIS0\nUSER-SUPPLIED UPDATE HISTORY BY CSECT -\nISPLINK       4/01/85    RSI50860044\nLAST LINK-EDITED ON  7/14/88  BY LKED 566528408  V01 M00\n\n** HISTORY  C11IJNQ0\nUSER-SUPPLIED UPDATE HISTORY BY CSECT -\nISPLINK       4/01/85    RSI50860044\nLAST LINK-EDITED ON  7/14/88  BY LKED 566528408  V01 M00\n\n** HISTORY  C11IJUP0\nUSER-SUPPLIED UPDATE HISTORY BY CSECT -\nISPLINK       4/01/85    RSI50860044\nLAST LINK-EDITED ON  7/14/88  BY LKED 566528408  V01 M00\n\n\n    *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 6.   Output of PDS \"MAP\" Subcommand.\n\n\n\n\n\n*** LOG TABLE OUTPUT ***               2.11.45 PM      THURSDAY    OCT 20, 1988\n\n- DSN=TST.CA11.LOADLIB,VOL=SER=VEND01  MEM=:\n>map *\n\n** MAP      CACTPROD\nCACTPROD  000000  0015BA\n\nENTRY POINT AT 000000  --  CACTPROD\nMODULE LENGTH  0015C0  --      6K\n\n** MAP      C11ICNQ0\nC11ICNQ0  000000  000C4F\nISPLINK   000C50  000120  RMODE 24  AMODE ANY\n                                                    ISPLNK    000C68\n                                                    ISPEXEC   000C6E\n                                                    ISPEX     000C74\n\nENTRY POINT AT 000000  --  C11ICNQ0\nMODULE LENGTH  000D70  --      4K\n\n** MAP      C11ICUP0\nC11ICUP0  000000  000D87\nISPLINK   000D88  000120  RMODE 24  AMODE ANY\n                                                    ISPLNK    000DA0\n                                                    ISPEXEC   000DA6\n                                                    ISPEX     000DAC\n\nENTRY POINT AT 000000  --  C11ICUP0\nMODULE LENGTH  000EA8  --      4K\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9005MY": {"ttr": 5893, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x93!\\x0f\\x01\\x00)\\x9f\\x11G\\x02!\\x02$\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 545, "newlines": 548, "modlines": 0, "user": "WSBG"}, "text": "\n                MVS TOOLS AND TRICKS OF THE TRADE\n                           May 1990\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n\n\n      This month, I'd like to continue our mini-series featuring the\nmarvelous \"PDS\" product that is found on the CBT Mods Tape.  All of\nthese discussions also pertain to PDS's vendor-supported successor,\nPDS/E (if you happen to have it).  In this column, my emphasis is\nmostly on products that are free, first.  The object is for ALL\nMVS shops to benefit, regardless of budget.\n\n      Anyone who has extensively used PDS or PDS/E will immediately\nunderstand why we should devote a lot of attention to it.  It is a\nmulti-purpose time saver and life saver in our business.  PDS is\nfound on the CBT MVS Mods tape that is obtainable from NaSPA (414)\n423-2420, or from SPLA at the University of Miami in Florida\n(305) 284-6257.  The PDS/E people usually have an ad in this magazine.\n\n      PDS is easy to get, and is not hard to install.  (One has to\nuse 3 files on the CBT tape.)  A small effort to obtain PDS and\ninstall PDS, will pay big dividends almost immediately.  I have used\nPDS for quite a few years, and PDS/E since before it's been out.  (I\nwas chief alpha- and beta-tester for PDS/E.)  In spite of my long\nexposure to both products, I can practically testify that I learn\nsome new way to use them, for shop-required purposes, just about\nevery single working day.\n\n      To get PDS, version 8.3 (or 8.4, which may be available by the\ntime you read this), you have to obtain a RECENT CBT Tape from\nNaSPA, from SPLA, or you may make a copy if one of your friends has\none.  (Remember, this stuff has no restrictions.)  The PDS product\nlives on File 182.  Necessary utilities that work together with PDS,\nlive on Files 296 and 112.\n\n      PDS install is the assembly-link of a load module, and the\ncopying of ISPF panels and a message member into the appropriate\nlibraries for your ISPF session to use.  Assembly and linkedit of\nthe auxiliary load modules from files 296 and 112 completes the\ninstallation.  Options for tailoring the main load module can be\nadjusted by using conditional assembly globals that are located in\nmembers #PDSGEN and #PDSGENB of file 182.  That's it.\n\n      After the PDS version 8.3 or 8.4 install, to check which\noptions you have installed, type the commands:  CONTROL GLOBAL, or\nCONTROL ALLGLOBAL.  The first command will display which of your\n\"gen\" options differ from the defaults.  The second command will\ndisplay all options that have been set (this is a long list).  With\nPDS/E, the equivalent command is:  CONTROL DEFAULTS.\n\n      PDS is executed as a TSO command, or as a dialog manager\noption under ISPF.  If ISPF is present in the TSO session, the two\nmodes may be toggled back and forth.  PDS may also be executed\nrecursively under ISPF if a command table entry is set up to invoke\nit (see my May 1989 column).\n\n      PDS comes with loads of documentation and a TSO help member.\nThe documentation distributed with \"public PDS\" is extensive, but\nsince the product has so many features, you usually have to dig to\ndiscover an EXISTING FACILITY that you didn't know you actually had.\nPDS/E has a completely organized user manual (which took enormous\neffort to create, as you may well imagine).\n\nTODAY'S TOPIC.\n\n      One purpose of this mini-series is to point out features of\nPDS that most users haven't noticed.  This month, we will talk mainly\nabout its LIST function, which is for looking at all kinds of data\nobjects.  LIST under PDS, can do much, much more than that name\nimplies.  Personally, it took me a long time to \"discover\" the LIST\nsubcommand, because I did not realize that it provides a good look at\nLOAD MODULES and other \"strange\" objects on disk files.  I had fooled\nmyself into thinking that it was something like the old TSO LIST\ncommand.  PDS's LIST can show MUCH more.  I've learned over and over\nagain that one can NEVER assume that \"simple\" PDS functions are\nlimited.\n\n      While studying the features of PDS \"LIST\", one should also bear\nin mind that the extremely useful \"FIND\" and \"REPLACE\" subcommands\nare related to LIST.  A user who has full command and possession of\nthese three subcommands has enormous power at his disposal.  Some of\nthis power may not easily be had with any existing utility that I\nknow of.  Under PDS/E, the DISASSEMBLE and DELINK functions are also\nrelated to the LISTing of load modules.\n\n      The PDS \"LIST\" subcommand has a number of options, which are\nshown in Figure One.  These are divided into two categories, which\nwe can call \"formatting options\" and \"selection options\".  Formatting\noptions of LIST will change the format of the command's output.  When\none of these LIST formatting options is used during a PDS session,\nthat option remains in place for the remainder of the session, until\nit is changed by another LIST command with a different formatting\noption.  We should also know that any FIND or REPLACE commands executed\nsubsequently, will display their output in the format of the latest\nLIST execution.  This is a useful fact, that we will later discover\nto be a powerful tool.\n\n      The LIST selection options will limit the extent of the\ndisplay or search to selected parts of the data object to be viewed.\nLIST selection options will help the user to \"zero in\" on just what\nhe wants to look at.  PDS provides a healthy variety of these.\n\n      The rest of the way, we shall try to explain both types of LIST\noptions, and we hope to show how they can be real power tools in your\nhands.  A full explanation of LIST options can be found in Figure Two,\n(which is a reprint from the TSO HELP member for PDS).\n\n      Let's start with the formatting options, which are the foundation\nfor any discussion of LIST under PDS.\n\nLIST Formatting Operands:\n\n       BLOCK / DUMP / LBLOCK / LDUMP / NUM / SNUM / NONUM\n\n      We shall summarize these options in a nutshell.  Then we shall\nshow how they can be employed by us, to do powerful jobs.  This then,\nis a quick description of the LIST formats:\n\n      BLOCK displays EBCDIC.  DUMP displays HEX.  LBLOCK and LDUMP\ndisplay LOGICAL structures, while BLOCK and DUMP display PHYSICAL\nblocks.  A \"power thought\" at this point is that if BLOCK or DUMP is\nin effect, a FIND command (which locates strings of data) or a\nREPLACE command (which does string replacements in place) on a load\nmodule will also discover data in the ESD and IDR parts of the load\nmodule.  If LBLOCK or LDUMP is in effect currently, only the \"text\"\npart of the load module will be searched or changed by the FIND and\nREPLACE subcommands.\n\n      NUM, SNUM, and NONUM are for source-type files, FB or VB.\nThe purpose of the NUM option is to re-show any line numberings at\nthe beginning of the data to make these more visible, if that is what\nis desired by the user.  NONUM does not reformat the display.  SNUM\ndiscards record sequence numbering when the data is displayed.\n\n      So let's look at some pictures.\n\n      Figure Three shows a list of a load module in straight \"DUMP\"\nformat.  All data blocks of the entire load module are shown,\nincluding the blocks containing the ESD and IDR records.  Notice that\nthere are two sets of displacement numbers.  The leftmost set of\ndisplacements starts from the beginning of the data display and\ncontinues across block boundaries.  The set of numbers further to the\nright, chronicles displacements into each data block, and is reset\nat block boundaries.  I must emphasize that in the straight DUMP\nformat, you do not get accurate displacements from the beginning of\nthe executable code--these are PHYSICAL BLOCK DISPLAYS ONLY.  What\nhappens, is that the displacements of the load module's initial blocks\nare added in.  This format is most useful when you want to examine the\n\"control\" parts of the load module data.\n\n      The LDUMP format covers the more usual situation that we have.\nAn illustration of the LDUMP format in the case of a load module is\nshown in Figure Four.  Notice that the bottom of the display indicates\nthat the load module pds member contains 6 data blocks.  However, only\none block is shown by the display.  That block is the executable code.\nDisplacements into the data blocks shown by the LDUMP format are the\nones we are familiar with.  They start at the load point of the load\nmodule and continue from there.  If the format of the data is VB\n(variable blocked), the LDUMP format will show only the \"logical\"\ndata portion, and not the \"control\" portion (the BDWs and the RDWs)\nof each records.  The LDUMP format is the format to be used when you\nare not examining the raw physical data, but when you are more\noriented to discovering HOW THE DATA WORKS.\n\n      Figure Five shows the same load module in LBLOCK format.  It is\nobvious that since the display of the data is in EBCDIC, this format\nis not so well suited for displaying load modules, but is more suited\nfor written text type data.  It may be useful for load modules and\nother \"hex\" type data when you want to search for embedded messages,\nand you don't want to look at the large volume of pure hex data that\nyou'd see with the LDUMP format.  BLOCK format is similar, but it\nshows the \"control\" parts of the data also.  BLOCK format is useful\nif you want to LOOK FOR CHARACTER STRINGS in the \"control portion\" of\na data object.\n\n      LIST, of course, is also very handy for displaying character-type\ndata, and for source files and documents.  These are its more obvious\nuses, and all the LIST options are applicable to this data also.  For\nour article, I merely wish to emphasize the more unusual applications\nof LIST, so our readers become aware of more of its power.\n\n      Now, we'll say a few words about the LIST selection options, and\nthen I'll let you go on and read another article.  For load modules,\nthe MODULE and OFFSET keyword options are most valuable to know about.\nIf one has a large load module (IEANUC01 comes to mind) it is not\nnormally desired to LIST the whole thing.  The MODULE keyword parameter\n(see Figure Two for details) allows you to list only one CSECT of the\nhuge monster, or several CSECTs that you may desire to look at.\n\n      One might add the OFFSET keyword to start a LIST display at\na location in the data that is not at the beginning of what would\nnormally be displayed.  A display that is started at an OFFSET, will\ncontinue from there, to the end of the data selected for display.\n\n      One uses the SKIPREC and MAXIN keyword parameters of LIST to\ndisplay some of the data from the middle of a file, if it is known\nhow far into the file that the desired data is.  SKIPREC causes you\nto skip nnnnnn records (logical or physical, depending on display\nformat) before you start the display.  MAXIN causes LIST to display\nonly the number of further records specified in its operand.\n\n      One employs the MAXOUT keyword to start at the beginning of\nthe desired data, and go only a limited distance into it.  The\noperand of the MAXOUT keyword will specify a number of records (or\nblocks in the case of a physical record display format).  This\nkeyword will limit the display, starting from the beginning of what\nwould normally be shown if MAXOUT had not been specified.\n\n      SKIPCOL and MAXLEN are keywords that force the display to\nstart after the beginning of a record, and end before its end.  It\nis recommended that you play with these keywords after PDS or PDS/E\nis installed at your shop.\n\n      Please bear in mind that the \"selection\" operands of LIST\napply to the \"FIND\" and \"REPLACE\" subcommands of PDS and PDS/E also.\n\n      And that's it.  Be creative.  See you next month.\n\n      Please let me know of any \"PDS(/E)\" Newsletter ideas that you\nhave.  My phone number is              .  Thanks.\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE ONE.  LIST Syntax.  This panel shows the LIST syntax,\n               which is applicable to SOURCE-type files, fixed or\n               variable blocked, and to LOAD MODULES and RECFM=U\n               files.  This syntax applies equally to PDS 8.3 and\n               to PDS/E, but the panel comes from the PDS/E syntax\n               error prompter.  Both PDS 8.x and PDS/E have more\n               detailed information in the TSO HELP member.  PDS/E\n               has a complete user manual describing all of its\n               subcommands in detail.\n\n\n\n------------------------------ List Syntax Error ------------------------------\nOPTION  ===>\nPDS844E Syntax error: INVALID KEYWORD\nIncorrect command syntax; please correct and reenter after LIST C1LG10\n===>\n\n\n\nOperands:  NUM / SNUM / NONUM / LBLOCK / LDUMP / BLOCK / DUMP\n           MAXIN(num)     MAXLEN(num)      MAXOUT(num)\n           SKIPCOL(num)   SKIPREC(num)\n\n\nDefaults:  NUM or the previous LIST/FIND/REPLACE format\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE TWO.   This is the complete LIST portion of the TSO HELP\n               member for PDS and PDS/E.\n\n\n\n=LIST=L=LI=LIS\n)F  Example -     LIST mema:memb\n\n  The LIST subcommand displays data from a member.\n\n  Unprintable characters for 3270-type devices are translated to\n  periods before they are displayed.\n\n  The LIST formats are NUM, SNUM, NONUM, LBLOCK, LDUMP, BLOCK and DUMP;\n  for load modules, the NUM, SNUM and NONUM formats are equivalent\n  to the LDUMP format.\n\n  The default format is initially NUM; however, each time a format\n  operand is entered on a LIST, FIND or REPLACE subcommand, the value\n  entered is used as the output format for subsequent LIST, FIND and\n  REPLACE subcommands.  Also, note the following:\n    A. Formats NUM, SNUM and NONUM limit the display length for logical\n       records to 256 characters.\n    B. Formats BLOCK and DUMP apply to physical records; the other\n       formats apply to logical records; and for load modules, LBLOCK\n       and LDUMP formats apply to CSECT data.\n)X SYNTAX -\n     LIST  member NUM/SNUM/NONUM/LBLOCK/LDUMP/BLOCK/DUMP\n                  OFFSET(Hx) MODULE(Partm)\n                  SKIPREC(n) MAXIN(n) MAXOUT(n)\n                  SKIPCOL(n) MAXLEN(n)\n\n ALIASES  - L, LI, LIS, LIST\n DEFAULTS - member, NUM or previous LIST/FIND/REPLACE format\n REQUIRED - none.\n)O OPERANDS -\n  member     -  optional, specifies the name of the member(s) to be\n                listed.\n\n                Default member names, member lists, member name\n                ranges and member name patterns are allowed; for\n                more information, enter HELP GROUP.\n\n  LIST format keywords are as follows:\n))NUM        -  The line number field (the last 8 bytes of a fixed-\n                format record or the first 8 bytes otherwise) of\n                each logical record is examined; if the field is not\n                numeric, formatting is switched to NONUM mode for the\n                remainder of the member.\n\n                For SPF-saved members, the high-order six digits of\n                the line number field is formatted; otherwise, the\n                low-order six digits of the line number field is\n                formatted by suppressing leading zeroes.  The line\n                number segment is followed by a blank and up to 249\n                characters of data from a logical record.\n))SNUM       -  The line number field (the last 8 bytes for a fixed-\n                format record or the first 8 otherwise) is discarded.\n                Up to 256 bytes from a logical record are displayed.\n))NONUM      -  Up to 256 bytes from a logical record are displayed.\n))LBLOCK     -  Logical records are formatted with two hexadecimal\n                offsets (displacement in the member and displacement\n                in the logical record) and segments of 64 characters\n                surrounded by asterisks.\n\n                Note: for load modules, only CSECT data will be\n                displayed and if the partial name Partm is entered\n                in a MODULE operand, only those CSECT or ENTRY names\n                matching Partm will be displayed.  CSECT records\n                are formatted with two hexadecimal offsets (a module\n                offset and a CSECT offset) and segments of 64\n                characters surrounded by asterisks.\n))LDUMP      -  Logical records are formatted with two hexadecimal\n                offsets (displacement in the member and displacement\n                in the logical record), segments of up to 32\n                characters of hexadecimal data and up to 16 bytes of\n                equivalent characters surrounded by asterisks.\n\n                Note: for load modules, only CSECT data will be\n                displayed and if the partial name Partm is entered in\n                a MODULE operand, only those CSECT or ENTRY names\n                matching Partm will be displayed.  CSECT records are\n                formatted with two hexadecimal offsets (a module offset\n                and a CSECT offset), segments of up to 32 characters of\n                hexadecimal data and up to 16 bytes of characters\n                surrounded by asterisks.\n))BLOCK      -  Physical records are formatted with two hexadecimal\n                offsets (displacement in the member and displacement\n                in the physical record) and segments of 64 characters\n                surrounded by asterisks.\n))DUMP       -  Physical records are formatted with two hexadecimal\n                offsets (displacement in the member and displacement\n                in the physical record), segments of up to 32\n                characters of hexadecimal data and up to 16 bytes of\n                equivalent characters surrounded by asterisks.\n  LIST control keywords are as follows:\n))OFFSET(Hx)  - for LBLOCK and LDUMP formats only; Hx may be entered\n                as a 1 to six digit hexadecimal number to specify\n                the module offset at which the display is to begin.\n\n                If both MODULE AND OFFSET keywords are entered, the\n                offset applies to each module selected.\n))MODULE(Partm)-for LBLOCK or LDUMP formats only; Partm may be entered\n                as a 1 to 8 byte partial external name to limit the\n                CSECT or ENTRY names to be displayed to those matching\n                the partial name Partm.\n\n                If the form MODULE(*) is used, the previous partial\n                name entered on any MODULE keyword will be used.\n\n                If both MODULE AND OFFSET keywords are entered, the\n                offset applies to each module selected.\n))SKIPREC(n)  - n is coded as 0 through 9999999 to specify the number\n                of logical records (physical records for BLOCK or\n                DUMP formats) to ignore at the beginning of a member.\n))MAXIN(n)    - n is coded as 0 through 9999999 to specify the maximum\n                number of logical records (physical records for BLOCK\n                or DUMP formats) to input for a member after\n                satisfying any SKIPREC operand.\n))MAXOUT(n)   - n is coded as 0 through 9999999 to specify the maximum\n                number of logical records (physical records for BLOCK\n                or DUMP formats) to output for a member.\n))SKIPCOL(n)  - n is coded as 0 through 99999 to specify the number\n                of columns to ignore at the beginning of each logical\n                record (physical record for BLOCK or DUMP formats).\n\n                Note:  for NUM or SNUM output format with record\n                format V, SKIPCOL(0) refers to the first data position\n                after the line number field.\n))MAXLEN(n)   - n is coded as 0 through 99999 to specify the maximum\n                length of a logical record (physical record for BLOCK\n                or DUMP formats) to display.\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE THREE.   This is a LIST of a LOAD MODULE in DUMP FORMAT.\n                 Notice that the displacements in the entire module\n                 are measured from the beginning of the first data\n                 block, and NOT from the beginning of the executable\n                 code.  This represents display of the PHYSICAL data.\n                 We would have needed the LDUMP format of Figure Four\n                 to display logical displacement values in the way we\n                 are used to seeing and using these values.  FIND and\n                 REPLACE commands which will follow this LIST, can\n                 affect ALL of the data, because the scan is PHYSICAL,\n                 and not logical.  Even the IDR and ESD data can be\n                 scanned and replaced using this format.  If the\n                 data being listed were in VB format instead of in\n                 RECFM=U, physical blocks, including block\n                 descriptor words (BDWs) and record descriptor\n                 words (RDWs) would have been displayed by LIST.\n\n\n\n\n- DSN=TST2SSG.LOAD,VOL=SER=TSO001  MEM=APSUX01\n>list apsux01 dump\nDUMP RECORD        1   LENGTH     24   TTR 00D809\n  000000 0000  20800000 00010010  C1D7E2E4 E7F0F140  *........APSUX01 *\n  000010 0010  00000000 00000536                     *........*\n\nDUMP RECORD        2   LENGTH    251   TTR 00D80A\n  000018 0000  80FA0100 00000000  00000000 00000000  *................*\n  000028 0010  00000000 00000000  00000000 00000000  *................*\n  000038 0020  00000000 00000000  00000000 00000000  *................*\n  000048 0030  00000000 00000000  00000000 00000000  *................*\n  000058 0040  00000000 00000000  00000000 00000000  *................*\n  000068 0050  00000000 00000000  00000000 00000000  *................*\n  000078 0060  00000000 00000000  00000000 00000000  *................*\n  000088 0070  00000000 00000000  00000000 00000000  *................*\n  000098 0080  00000000 00000000  00000000 00000000  *................*\n  0000A8 0090  00000000 00000000  00000000 00000000  *................*\n  0000B8 00A0  00000000 00000000  00000000 00000000  *................*\n  0000C8 00B0  00000000 00000000  00000000 00000000  *................*\n  0000D8 00C0  00000000 00000000  00000000 00000000  *................*\n  0000E8 00D0  00000000 00000000  00000000 00000000  *................*\n  0000F8 00E0  00000000 00000000  00000000 00000000  *................*\n  000108 00F0  00000000 00000000  000000             *...........*\n\nDUMP RECORD        3   LENGTH     18   TTR 00D80B\n  000113 0000  801102F5 F6F6F5F2  F9F5F0F8 40010090  *...566529508 ...*\n  000123 0010  042F                                  *..*\n\nDUMP RECORD        4   LENGTH     21   TTR 00D80C\n  000125 0000  80148480 0100F5F6  F6F8F9F6 F2F0F140  *..d...566896201 *\n  000135 0010  02019004 2F                           *.....*\n\nDUMP RECORD        5   LENGTH     20   TTR 00D80D\n  00013A 0000  0D000000 00040000  06000000 40000538  *............ ...*\n  00014A 0010  00010538                              *....*\n\nDUMP RECORD        6   LENGTH  1,336   TTR 00D80E\n  00014E 0000  47F0F06A 10C1D7E2  E4E7F0F1 404040F8  *.00\u00a6.APSUX01   8*\n  00015E 0010  F84BF0F5 F3F5F6F6  F560F2F7 F5404040  *8.0535665-275   *\n\n        - - - - -  D A T A   M I S S I N G  - - - - -\n\n  0005CE 0480  504640E0 504659E0  C50847D0 C4701FFF  *&. \\&..\\E..}D...*\n  0005DE 0490  58D0D004 58E0D00C  980CD014 07FED7C1  *.}}..\\}.q.}...PA*\n  0005EE 04A0  E3C3C840 C1D9C5C1  406040C1 D7E2E4E7  *TCH AREA - APSUX*\n  0005FE 04B0  F0F14040 F8F84BE7  E7E7C4BA C4BCC4BE  *01  88.XXXD.D.D.*\n  00060E 04C0  C4C0C4C2 C4C4C4C6  C4C8C4CA C4CCC4CE  *D{DBDDDFDHD.D.D.*\n  00061E 04D0  C4D0C4D2 C4D4C4D6  C4D8C4DA C4DCC4DE  *D}DKDMDODQD.D.D.*\n  00062E 04E0  C4E0C4E2 C4E4C4E6  C4E8C4EA C4ECC4EE  *D\\DSDUDWDYD.D.D.*\n  00063E 04F0  C4F0C4F2 C4F40000  00000001 00000002  *D0D2D4..........*\n  00064E 0500  00000003 0000000C  00000010 0000007F  *...............\"*\n  00065E 0510  00000000 000040E2  E3C1D9E3 C3D6D5E3  *...... STARTCONT*\n  00066E 0520  40D3D6C3 C1D3D9D6  D6D4C1D4 00000000  * LOCALROOMAM....*\n  00067E 0530  12000000 21200000                     *........*\n\n        6 blocks in this member\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE FOUR.   This is a DUMP OF LOGICAL DATA in a LOAD MODULE,\n                using the LDUMP FORMAT of LIST.  Notice that even\n                though the module contains 6 records, only the\n                executable code is shown.  The ESD and IDR records\n                at the beginning of the load module are not considered.\n                Displacement OFFSETS are measured from the beginning\n                of the executable code, in the \"normal\" way that we\n                are used to.  A FIND or REPLACE command which would\n                follow this LIST command, will affect only the\n                executable portion of the load module.  If the\n                data being listed were in VB format instead of\n                RECFM=U, LOGICAL RECORDS would be displayed in HEX\n                by this format of the LIST command.  BDWs and RDWs\n                would not be shown.\n\n\n\n>list apsux01 ldump\nAT 000000  CSECT APSUX01   LENGTH 000536\n  000000 0000  47F0F06A 10C1D7E2  E4E7F0F1 404040F8  *.00\u00a6.APSUX01   8*\n  000010 0010  F84BF0F5 F3F5F6F6  F560F2F7 F5404040  *8.0535665-275   *\n\n        - - - - -  D A T A   M I S S I N G  - - - - -\n\n  000480 0480  504640E0 504659E0  C50847D0 C4701FFF  *&. \\&..\\E..}D...*\n  000490 0490  58D0D004 58E0D00C  980CD014 07FED7C1  *.}}..\\}.q.}...PA*\n  0004A0 04A0  E3C3C840 C1D9C5C1  406040C1 D7E2E4E7  *TCH AREA - APSUX*\n  0004B0 04B0  F0F14040 F8F84BE7  E7E7C4BA C4BCC4BE  *01  88.XXXD.D.D.*\n  0004C0 04C0  C4C0C4C2 C4C4C4C6  C4C8C4CA C4CCC4CE  *D{DBDDDFDHD.D.D.*\n  0004D0 04D0  C4D0C4D2 C4D4C4D6  C4D8C4DA C4DCC4DE  *D}DKDMDODQD.D.D.*\n  0004E0 04E0  C4E0C4E2 C4E4C4E6  C4E8C4EA C4ECC4EE  *D\\DSDUDWDYD.D.D.*\n  0004F0 04F0  C4F0C4F2 C4F40000  00000001 00000002  *D0D2D4..........*\n  000500 0500  00000003 0000000C  00000010 0000007F  *...............\"*\n  000510 0510  00000000 000040E2  E3C1D9E3 C3D6D5E3  *...... STARTCONT*\n  000520 0520  40D3D6C3 C1D3D9D6  D6D4C1D4 00000000  * LOCALROOMAM....*\n  000530 0530  12000000 2120                         *......*\n\n        6 blocks in this member\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE FIVE.   LBLOCK FORMAT for a LOAD MODULE only shows data in\n                EBCDIC form.  \"Unprintable\" data which might cause\n                trouble when a display is attempted to a terminal,\n                is converted into periods.  This form of display may\n                be of limited usefulness for load modules, and might\n                only serve to highlight character strings in them.\n                For RECFM=VB source-type data, this format would be\n                extremely useful.\n\n\n\n>list apsux01 lblock\nAT 000000  CSECT APSUX01   LENGTH 000536\n000000 0000  *.00\u00a6.APSUX01   88.0535665-275    ...............................*\n\n        - - - - -  D A T A   M I S S I N G  - - - - -\n\n000440 0440  *K.....K.....K..'.%k*.=k...K.&.E..\\..&\\&..\\.. \\&.....D......\\..\u00a0\\*\n000480 0480  *&. \\&..\\E..}D....}}..\\}.q.}...PATCH AREA - APSUX01  88.XXXD.D.D.*\n0004C0 04C0  *D{DBDDDFDHD.D.D.D}DKDMDODQD.D.D.D\\DSDUDWDYD.D.D.D0D2D4..........*\n000500 0500  *...............\"...... STARTCONT LOCALROOMAM..........*\n\n        6 blocks in this member\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9006JN": {"ttr": 6148, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x93!\\x0f\\x01\\x00)\\x9f\\x11G\\x02;\\x02;\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 571, "newlines": 571, "modlines": 0, "user": "WSBG"}, "text": "\n                MVS TOOLS AND TRICKS OF THE TRADE\n                          June 1990\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Installation in Northern N.J.\n                                      Mountain Lakes, New Jersey 07046\n\n\n\n      This month, I'd like to talk about an important area of\nsystem knowledge.  Some familiarity in this area is necessary for\nevery practitioner of our trade to have.  We shall discuss a few\naspects of the Format 1 DSCB, otherwise known as the VTOC Entry for\na dataset.  It is extremely important for a systems programmer to\nunderstand the effects of the VTOC Entry fields on how a dataset is\ngoing to behave.\n\n      We shall not give an elaborate treatise on the subject of VTOC\nfields, but I want to introduce some tools for changing these fields,\nand to give reasons why we would find it necessary to change them\nunder certain circumstances.\n\n      Changes to VTOC fields may be made by ordinary jobs which are\nrun.  These changes occur during the \"opening\" and \"closing\"\nprocesses on a dataset.  For our purposes, it may not be desirable to\nopen the dataset and make a VTOC change, and under some circumstances\nthe cleanest effect will be obtained by directly changing a VTOC\nfield in the VTOC, using a specialized tool.\n\n      In order to make direct changes to a VTOC, without opening or\nclosing the dataset, it is necessary to have APF program\nauthorization for the program which does the work.  IBM created the\nAuthorized Program Facility (APF) to prevent user programs from\ncausing system damage.  As most of you probably know, a program can\nrun APF authorized if:  it resides in a load library authorized by\nthe system APF table (defined by an IEAAPFxx member in SYS1.PARMLIB)\nor it is in the system linklist concatenation (if those libraries\nare authorized by default), AND if it has been linkedited with the\nparameters SETCODE AC(1).  In addition, if the program is a TSO\ncommand, its name must be authorized to TSO.  Our specialized tools,\nusually TSO commands, must be so authorized in order to do their\nwork.  Many of you know of special tricks which we use to obtain APF\nauthorization for our tools.  These tricks do help, but I don't have\nspace to discuss them here.\n\n      The two software tools we shall use are readily available on\nthe CBT MVS Tape which can be ordered from NaSPA.  These are:\nthe CDSCB (Change the DSCB) TSO command from File 300, and the PDS\nprogram product (Versions 8.3 or 8.4) from Files 182, 296, and 112.\nCDSCB will be the principal tool whose actions we shall illustrate.\nCDSCB must run authorized.\n\n      The multipurpose \"PDS\" command will be our other tool.  \"PDS\"\nby its design, does NOT run authorized.  PDS can indeed change\ncertain VTOC fields, such as record format (RECFM), record length\n(LRECL), or block size (BLKSIZE), but it does this by quickly\nopening and closing the dataset while writing a dummy output record\nto it.  Although in practice, PDS is very handy for a \"quick fix\"\nto a dataset through this function of its \"FIXPDS\" subcommand, our\nuse of it here will be primarily for demonstration and illustration\npurposes, employing its \"USAGE\" subcommand.\n\n      The \"USAGE\" subcommand of the PDS program product (or its\nvendor-supported descendant, PDS/E) provides the best display of\nFormat 1 VTOC fields that I know of.  (You can make your own choice\nafter seeing the illustrations.)  We shall use the PDS USAGE display\nto keep track of the VTOC fields and changes to them.\n\n      Let's start by examining Figures One and Two.  These figures\ngraphically show VTOC fields for real datasets.  Figure One comes\nfrom a source-type dataset.  Figure Two comes from a load library.\n\n      Please notice that at the top of each USAGE report, dataset\nstatistics are reported, similarly to the ISPF 3.2 display, but in\nmore detail.  Below that display is a TTR and CCHHR report of each\ndataset extent.  Further below is a HEX display of the entire\nFormat 1 VTOC entry for the dataset.  And finally at the bottom,\nis formatted interpretation of all of the VTOC fields, as displayed\nin the hex display.  Some of these fields are reformatted in the\nfield display for clearer interpretation, being translated from hex\nto decimal numbers.  It is clear that most of the numbers in an ISPF\n3.2 display of a dataset come from values stored in the Format 1 VTOC\nentry for the dataset.\n\n      Let's try to make our picture more specific with a case.\nLet's say that the library from Figure One, TSTBSSG.A.CNTL, which\ncontains card-image source, is blocked at 3120 bytes per block, as is\nevident from the figure.  Someone wants to write a new member to the\nlibrary, using the following JCL:\n\n//OUTWRITE DD DISP=SHR,DSN=TSTBSSG.A.CNTL(NEWMEMBR),\n//    DCB=(RECFM=FB,LRECL=80,BLKSIZE=80)\n\nWhat will happen as a result of running this JCL, is that the library\nTSTBSSG.A.CNTL will be opened for output with the DCB blocksize of\n80 instead of 3120, and the effect will be permanent.  If we try now\nto read the member NEWMEMBR with an editor, the default blocksize\nthat the editor assumes, will be 80 bytes per block.  NEWMEMBR can\nbe read by the editor, because it was written out with a blocksize\nof 80.  But what if the user wants to edit another member?  He'll\nget an ABEND S001 for \"wrong length record\", which will come from\nthe BSAM or QSAM access method, because the other library members\nwill have longer physical block sizes than 80 bytes.  Running that\nJCL has in effect rendered the old members of TSTBSSG.A.CNTL\ninaccessible.\n\n      How can we fix this?  One way is to run another job with the\nopposite JCL, that will write out a dummy member to the library\nas follows:\n\n//OUTWRITE DD DISP=SHR,DSN=TSTBSSG.A.CNTL(DUMMEMBR),\n//    DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)\n\n      After this job is run, the VTOC blocksize of the dataset is\nreset back to 3120 bytes per block, and an edit program that is trying\nto read a member, will now expect that member to be blocked at 3120\nbytes per block.  Shorter-blocked members will be accessible also,\nsince the record format was specified as FB, and not as FBS (which\nprohibits short blocks).  Thus, by restoring the VTOC blocksize of\nthe library, we have rendered all the members accessible once again.\n\n      We could have done the same action in other ways.  The PDS\nprogram, with its \"FIXPDS\" subcommand, accomplishes the above task\nwithout our having to bother to code JCL and run a job.  We could\nhave entered under TSO:\n\n      PDS  'TSTBSSG.A.CNTL'\n\nfollowed by:\n\n      FIXPDS BLKSIZE(3120)\n\nfollowed by:\n\n      YES  .\n\nAt this point, the PDS command will have opened the dataset for\noutput, written a tiny dummy member out to the library TSTBSSG.A.CNTL,\nand then erased it, effecting our permanent VTOC change.\n\n      There is a third way of accomplishing this same task that is\nfundamentally different in concept.  Under TSO, one could have\nentered (if the command CDSCB were properly installed, authorized\nand available):\n\n      CDSCB  'TSTBSSG.A.CNTL'  BLKSIZE(3120) SHR\n\n      The CDSCB command, which has to run authorized, would not open\nthe dataset at all--not for input and not for output.  Instead, it\nwould go directly to the DS1BLKL field of the VTOC entry for\nTSTBSSG.A.CNTL.  As shown in the display, DS1BLKL is at displacement\n+56 from the beginning of the VTOC Format 1 entry.  CDSCB would then\nchange the halfword of HEX 0050 at +56, equal to decimal 80, to the\nhalfword quantity of HEX 0C30, which translates to decimal 3120.  The\nSHR keyword assures that the change will be made, even if another\nuser has shared access to this dataset.  Thus, CDSCB accomplishes\nthe tricky task cleanly and directly, translating \"our numbers\" into\n\"the VTOC's numbers\" and back again, and assuring that the correct\ndisplacement values in the VTOC are zapped by its action.\n\n      CDSCB effectively \"zaps\" the VTOC, but does it cleanly and\naccurately under our control.\n\n      Please refer to Figure Three for the TSO HELP member showing\nthe particulars of the CDSCB command.  For a full description of all\nFormat 1 VTOC fields, see the IBM manual:  \"MVS Debugging Guide\" that\ncomes in several volumes.  Look up the control block DSCB1 for the\nfull explanation of fields in the Format 1 VTOC entry.\n\n      This brings us to the main point that I want to make.  Zapping\nthe Format 1 VTOC entry is familiar practice for \"old-timers\" in our\nprofession.  It is obvious that many errors could have been made in\nthe process, rendering the dataset temporarily unusable (until the\nVTOC fields were zapped properly back).  Programs such as CDSCB, which\nwill hit the proper fields when triggered by our keyword values, make\nthe VTOC-zapping process more foolproof and error-free.  The \"USAGE\nALL\" display of the PDS program shows us all the VTOC fields for our\nown dataset at the current time, formatted out, and further reduces\nthe chance of error in this process.  Thus, a tricky and error-prone\nsystem programmer activity has been reduced to a routine and\nrelatively error-free job.\n\n      We shall finish out this month's column with several case\nhistories showing the usefulness of VTOC-zapping to simplify the\nunraveling of difficulties with datasets.\n\n      The case of \"lost VSAM Catalog passwords\" is one famous case\nwhere VTOC zapping comes in handy for the authorized systems person.\nI once had a situation in which I had to delete an old VSAM\nusercatalog whose entries had been moved into a new ICF catalog.\nThe current installation standard did not require any passwords\nfor usercatalogs, but this old catalog, the first usercatalog defined\nat the installation in ancient days of system creation, was mistakenly\ngiven a master password that was forgotten with the passage of time.\nAll of the old system programmers were long gone.  I wanted to delete\nthe catalog cleanly.  What was I to do?\n\n      For sure, I did not want to change the dataset at all.  I am\nno expert on old VSAM catalogs, and I certainly did not want to break\nthis one in the process of trying to look at it.  I did want to browse\nit, however.\n\n      VSAM prevents \"outsiders\" (programs other than IDCAMS) from\nnosing around in KSDS clusters and usercatalogs through a standard\nMVS mechanism.  IDCAMS turns on the \"password read-write bit\" which\nis X'10' of +5D (the DS1DSIND field) of the VTOC entry for the VSAM\ndataset.  With this bit on, MVS only allows access to the dataset if\na password entry in the \"MVS PASSWORD\" dataset exists and matches.\nSince, for the VSAM dataset, no password was entered into the PASSWORD\ndataset--VSAM can exist even if there isn't a PASSWORD dataset defined.\nSo in effect, ALL ACCESS IS DENIED to the dataset, except of course\nto IDCAMS, which is authorized, and which gets into the VTOC to turn\nthe password bit off when it wants to do its stuff.\n\n      The password read-write bit is what stops me from browsing\nthe VSAM catalog.  Therefore, I can use CDSCB to get in and turn it\noff.  I have not attempted to open the dataset nor access it for\noutput.  Therefore, I have not done any harm.  I can then browse the\ncatalog as a dataset, using its full VTOC name.  After having nosed\naround, discovering what I need to discover, I merely use CDSCB\nagain and turn the password bit back on, to restore protection.\nWith master password in hand, I then delete the usercatalog with\nIDCAMS in the ordinary way.  For the systems programmer, this is\nneat, clean, and within bounds.  Other attempts at access would have\npossibly done irreparable harm, or have been futile.  End case one.\n\n      Case two is even stranger than case one, but I'm including it\nto show the power of the method.  I don't suspect that a sysprog will\nencounter this exact case very often, if even once in a career.\n\n      What has happened is that an important old load library has\nbeen deleted by mistake, with no backup of the most recently linkedited\nmodules that were in it.  (Such an event is highly unlikely in a normal\nshop that does adequate backups.)  A new source library has been\nallocated in its place, and overlays the extents of the old library.\nThe new source library has only a few members in it, so that most\nof the data in its allocated extents has not been touched.  Therefore,\nthe data of most of the old modules is still intact from the\nencroaching source library.  Problem is, how do we recover as many of\nthe old modules as possible, or how do we recover one important module\nthat we no longer have the source for?\n\n      This is not so hard, with our equipment (CDSCB and the PDS\nproduct).  There are three problems to be overcome.  Number one, is\nthat a load module is relatively useless, without a directory entry\nthat properly describes its attributes.  Number two, is that the\nnew source-type library that has been allocated, marks its \"high-water\npoint\" of valid data at a very low TTR location within its allocated\nextents.  If any \"member restore\" activity is to occur, this must\nhappen for TTR locations that are much higher than the currently\nregistered \"high-water line\".  Problem number three is that the\ncurrently defined dataset is a source-type library, with record\nformat, record length, and block size reflecting this usage.  If\nload modules are to be restored on the existing dataset directory,\nthe record format must equal \"U\", the block size must be large enough,\nand the logical record length should be zero.\n\n      No problem for us.  First, we must attempt to allocate a ddname\non our TSO session to this dataset with DISP=OLD, to prevent other\njobs and users from trying to write new source members while we are\nworking.  After this has been done, we use CDSCB to change the\ndataset attributes of the existing library to RECFM=U, LRECL=0,\nand BLKSIZE equal to some large number, greater than the physical\nblocksize of any of the old modules.  We must first have noted the\noriginal dataset attribute values, so they could be restored later.\nThe PDS \"USAGE ALL\" command is super, for preserving records of the\nold values.\n\n      Next comes the raising of the \"high-water line\" in the VTOC.\nThe old high-water line should be carefully noted.  CDSCB can be used\nto boost the DS1LSTAR field of the VTOC entry (three bytes at +62\nin the Format 1 DSCB) to a high value.  An alternative method is\nthe \"FIXPDS MAXSPACE\" subcommand of the PDS product, to set the high\nwater mark for valid data, to its maximum possible value within the\ndataset's current allocated extents.\n\n      That having been done, we then proceed to the member restore\nprocess.  The PDS product comes in very handy here, because it\ncontains a flexible mechanism for restoring deleted library members.\nThis is the \"RESTORE\" subcommand of PDS.  Please bear in mind at this\npoint that the dataset attributes of the currently allocated\npartitioned dataset are those of a load library.  To a newly created\nmember, the library would no longer appear as a source library.  The\nold source or JCL members still have their old directory entries, and\nwill not be altered by the creation of many new load members.  Later,\nthe new members will be copied off and deleted, and the current\nlibrary will be restored to its old dataset characteristics and\nhigh-water mark for good data.\n\n      At this time, we use the PDS \"RESTORE\" subcommand to create\nnew load modules corresponding to all intact physical load module\nmembers that haven't been overlaid.  These members will be\nsequentially named.  For example, the commands:\n\n      PDS  'current.dataset.name'\n\nfollowed by:\n\n      RESTORE $ABC REPEAT NOPROMPT\n\nwill restore all deleted members, in TTR order, with the member\nnames:  $ABC0001, $ABC0002, $ABC0003, and so forth.  Load module\nattributes such as module authorization can be re-created at restore\ntime if deemed appropriate, or they can be supplied by the ATTRIB\ncommand of PDS later, after the modules have been copied away to\na legitimate new load library.\n\n      At RESTORE time, PDS logs the CSECT structure of the deleted\nCSECT being restored.  This will help in the renaming process later,\nand will also aid in the process of trying to figure out what the\nre-entrancy properties and other special characteristics of the\noriginal modules were.\n\n      The PDS \"COPY\" subcommand, or the IEBCOPY program, can now be\nused to move the restored modules to another load library for further\nmanipulation with the PDS \"ATTRIB\" subcommand, or with other utilities,\nif needed.\n\n      After the restored modules have been copied, the extra member\nnames should be deleted from the current library.  CDSCB or the PDS\n\"FIXPDS\" capability should be used to bring back the source-library\ndataset characteristics that the library originally had.  Finally,\na dataset compress should be done, to bring the high-water mark back\nto its original value.  Case number two is now ended, with everything\nhaving been set back to its original condition, and the load modules\nhaving been saved.  YEEHAAA.\n\n      Hope this month's trip has been useful to you.  Good luck.\nSee you next month.\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFIGURE ONE.   VTOC-Oriented description of a Source-type partitioned\n               dataset.  This display is from the USAGE subcommand\n               of the PDS program product, describing the dataset\n               characteristics.  It will be noticed that the numbers\n               at the top are mostly obtained from the format-1 DSCB\n               fields that are on display below.\n\n\n\nENTER OPTION -- DSN=TSTBSSG.A.CNTL,VOL=SER=TSO001  MEM=MOVSYSTM\n>usage all\nDISP UNIT OPT RECFM LRECL BLKSIZE   ALLOCTRK FREETRK SECONDARY FREEDIR\nSHR  3380 W   FB       80    3120   1X   394       3    75 TRK      64\n\nData set: CREATED  EXPIRES  LAST USE  UPDATED  SECURITY\n          3/16/87  0/00/00   3/30/90  YES      NONE\n\nExtents in tracks: 394\n\nTracks: ALLOCATED    USED    FREE  EXTENTS\n              394     391       3        1\n\nDirectory: BLOCKS    USED    FREE   TRACKS  MEMBERS  ALIASES\n              413     349      64        9     2098        1\n\nEXTENT  UCB  LO TT-HI TT  TRACKS     LOW CCHH-HIGH CCHH    BOUNDARY\n------  ---  ----- -----  ------  ----------- -----------  --------\n     0  9B7  00.00 01.89     394  03.19.00.03 03.33.00.06  TRK\n\n\nFormat 1 DSCB:\n0   4   8   C  10  14  18  1C  20  24  28  2C  30  34  38  3C  40  44\nTSTBSSG.A.CNTL                              1TSO001...........IBMOSVS2\nEEECEEC4C4CDED444444444444444444444444444444FEEDFFF00504000000CCDDEEEF\n3232227B1B353300000000000000000000000000000013260010170B00010092462522\n\n 48  4C  50  54  58  5C  60  64  68  6C  70  74  78  7C  80  84  88\n     !.............&...b.....f........................................\n4444450500000098030500088004081180000010003000000000000000000000000000\n00000A0900002000C0000002000B16FB00010390333060000000000000000000000000\n\n\nLOC NAME     VALUE        DESCRIPTION\n--- ----     -----        -----------\n00  DS1DSNAM TSTBSSG.A.CNTL\n2C  DS1FMTID F1           FORMAT IDENTIFIER\n2D  DS1DSSN  TSO001       DATA SET SERIAL NUMBER\n33  DS1VOLSQ 1.           VOLUME SEQUENCE NUMBER\n35  DS1CREDT 57004B       CREATION DATE\n38  DS1EXPDT 000000       EXPIRATION DATE\n3B  DS1NOEPV 1.           NUMBER OF EXTENTS ON VOLUME\n3C  DS1NOBDB 0.           NUMBER OF BYTES USED IN LAST DIRECTORY BLOCK\n3D           00           RESERVED (ONE BYTE)\n3E  DS1SYSCD C9C2D4D6E2E5E2F24040404040\n4B  DS1REFD  5A0059       DATE LAST REFERENCED\n4E           00000000     RESERVED (FOUR BYTES)\n52  DS1DSORG 0200         DATA SET ORGANIZATION\n54  DS1RECFM 90           RECORD FORMAT\n55  DS1OPTCD 80           OPTION CODE\n56  DS1BLKL  3,120.       BLOCK LENGTH\n58  DS1LRECL 80.          LOGICAL RECORD LENGTH\n5A  DS1KEYL  0.           KEY LENGTH\n5B  DS1RKP   0.           RELATIVE KEY POSITION\n5D  DS1DSIND 82           DATA SET INDICATORS\n5E  DS1SCALO 8000004B     SECONDARY ALLOCATION\n62  DS1LSTAR 01861F       TTR OF LAST USED TRACK AND BLOCK ON TRACK\n65  DS1TRBAL 7,040.       BYTES REMAINING ON LAST TRACK USED\n67           0000         RESERVED (TWO BYTES)\n69  DS1EXT1  0100.03190003.03330006  FIRST EXTENT DESCRIPTION\n73  DS1EXT2  0000.00000000.00000000  SECOND EXTENT DESCRIPTION\n7D  DS1EXT3  0000.00000000.00000000  THIRD EXTENT DESCRIPTION\n87  DS1PTRDS 0000000000   CCHHR OF ANY ASSOCIATED FORMAT 2 OR 3 DSCB\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE TWO.   VTOC-oriented description of a Load Library.\n               Again please note the close relationship between\n               the dataset description numbers in the upper part\n               of the display, and the obvious relationship of most\n               of them to the VTOC fields at the bottom of the\n               picture.\n\n\nENTER OPTION -- DSN=TSTBSSG.LOAD,VOL=SER=TSO001  MEM=MOVSYSTM\n>usage all\nDISP UNIT     RECFM LRECL BLKSIZE   ALLOCTRK FREETRK SECONDARY FREEDIR\nSHR  3380     U         0   19069   3X   240      19    60 TRK     113\n\nData set: CREATED  EXPIRES  LAST USE  UPDATED  SECURITY\n          2/03/87  0/00/00   3/29/90  YES      NONE\n\nExtents in tracks: 180, 34, 26\n\nTracks: ALLOCATED    USED    FREE  EXTENTS\n              240     221      19        3\n\nDirectory: BLOCKS    USED    FREE   TRACKS  MEMBERS  ALIASES\n              137      24     113        3      144        5\n\nEXTENT  UCB  LO TT-HI TT  TRACKS     LOW CCHH-HIGH CCHH    BOUNDARY\n------  ---  ----- -----  ------  ----------- -----------  --------\n     0  9B7  00.00 00.B3     180  02.C9.00.01 02.D5.00.00  TRK\n     1  9B7  00.B4 00.D5      34  01.20.00.02 01.22.00.05  TRK\n     2  9B7  00.D6 00.EF      26  02.F0.00.01 02.F1.00.0B  TRK\n\n\nFormat 1 DSCB:\n0   4   8   C  10  14  18  1C  20  24  28  2C  30  34  38  3C  40  44\nTSTBSSG.LOAD                                1TSO001...........IBMOSVS2\nEEECEEC4DDCC44444444444444444444444444444444FEEDFFF00502000000CCDDEEEF\n3232227B36140000000000000000000000000000000013260010170200030092462522\n\n 48  4C  50  54  58  5C  60  64  68  6C  70  74  78  7C  80  84  88\n     !........{.\u00a0'.....b..............I...N...............0...1.......\n44444505000000C04700000880030D05000000C000D000002000200000F000F0000000\n00000A0800002001AD000002000C0CF400010290125001110021205122001210B00000\n\n\nLOC NAME     VALUE        DESCRIPTION\n--- ----     -----        -----------\n00  DS1DSNAM TSTBSSG.LOAD\n2C  DS1FMTID F1           FORMAT IDENTIFIER\n2D  DS1DSSN  TSO001       DATA SET SERIAL NUMBER\n33  DS1VOLSQ 1.           VOLUME SEQUENCE NUMBER\n35  DS1CREDT 570022       CREATION DATE\n38  DS1EXPDT 000000       EXPIRATION DATE\n3B  DS1NOEPV 3.           NUMBER OF EXTENTS ON VOLUME\n3C  DS1NOBDB 0.           NUMBER OF BYTES USED IN LAST DIRECTORY BLOCK\n3D           00           RESERVED (ONE BYTE)\n3E  DS1SYSCD C9C2D4D6E2E5E2F24040404040\n4B  DS1REFD  5A0058       DATE LAST REFERENCED\n4E           00000000     RESERVED (FOUR BYTES)\n52  DS1DSORG 0200         DATA SET ORGANIZATION\n54  DS1RECFM C0           RECORD FORMAT\n55  DS1OPTCD 01           OPTION CODE\n56  DS1BLKL  19,069.      BLOCK LENGTH\n58  DS1LRECL 0.           LOGICAL RECORD LENGTH\n5A  DS1KEYL  0.           KEY LENGTH\n5B  DS1RKP   0.           RELATIVE KEY POSITION\n5D  DS1DSIND 82           DATA SET INDICATORS\n5E  DS1SCALO 8000003C     SECONDARY ALLOCATION\n62  DS1LSTAR 00DC0F       TTR OF LAST USED TRACK AND BLOCK ON TRACK\n65  DS1TRBAL 21,504.      BYTES REMAINING ON LAST TRACK USED\n67           0000         RESERVED (TWO BYTES)\n69  DS1EXT1  0100.02C90001.02D50000  FIRST EXTENT DESCRIPTION\n73  DS1EXT2  0101.01200002.01220005  SECOND EXTENT DESCRIPTION\n7D  DS1EXT3  0102.02F00001.02F1000B  THIRD EXTENT DESCRIPTION\n87  DS1PTRDS 0000000000   CCHHR OF ANY ASSOCIATED FORMAT 2 OR 3 DSCB\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE THREE.   This is the Help member for the CDSCB\n                 TSO command, that can change any field\n                 in a dataset's Format 1 DSCB.  CDSCB must\n                 run authorized, because any program which\n                 directly changes VTOC fields must have\n                 APF authorization under the MVS operating\n                 system.\n\n\n)F FUNCTION -\n  THE CDSCB (CHANGE DSCB) COMMAND MODIFIES A DATA SET'S\n  FORMAT-1 DSCB IN A VTOC.\n\n  SINCE THE FORMAT-1 DSCB CONTAINS INFORMATION CRUCIAL TO\n  A DATA SETS' SECURITY AND INTEGRITY, (AND IN FACT TO THE\n  WHOLE SYSTEM'S SECURITY AND INTEGRITY), THIS COMMAND\n  MUST BE RESTRICTED TO SYSTEMS SUPPORT PERSONNEL.\n\n  NOTE: THIS IS AN APF-AUTHORIZED COMMAND, AND THEREFORE\n  WILL NOT RUN PROPERLY UNDER SPF.  YOU MUST EXIT SPF TO\n  'READY' MODE BEFORE USING THIS COMMAND.\n\n  (Author's note.  There are ways of authorizing TSO commands\n   that are run out of an ISPF screen.  I actually use this\n   command while working under ISPF, but it takes a trick.\n   Consult your local TSO guru.)\n\n)X SYNTAX  -\n         CDSCB  'DSNAME'   EXPDT('YYDDD')  SHR  VOL(VOLUME) UNIT(UNIT)\n                           CREATE('YYDDD') REFDT('YYDDD')\n                           DSORG(XX) RECFM(XX) LRECL(XX) BLKSIZE(XX)\n                           ALLOC(TR/CYL/BL)  SPACE(SECONDARY-AMOUNT)\n                           PWR/PWW/NOP/RACF/NORACF\n                           ZAP(OFFSET VERDATA REPDATA)\n  REQUIRED - 'DSNAME'\n  DEFAULTS - NOTHING WILL HAPPEN IF NO CHANGES ARE SPECIFIED.\n  ALIAS    - NONE\n\n)O OPERANDS -\n  'DSNAME'  -  THE NAME OF THE DATA SET WHOSE FORMAT-1 DSCB\n             IS TO BE MODIFIED.\n))UNIT(UNIT) - FOR UNCATALOGED DATA SETS, THE UNIT TYPE OF THE\n             VOLUME WHERE THE DATA SET RESIDES.\n))VOL(VOLUME) - FOR UNCATALOGED DATA SETS, THE VOLUME SERIAL\n             OF THE DATA SET.\n))SHR      - THIS KEYWORD INDICATES THAT THE DSCB IS TO BE\n             MODIFIED EVEN IF ANOTHER JOB OR TSO SESSION\n             IS USING THE DATA SET.\n))EXPDT('YYDDD') - THE EXPIRATION DATE IS TO BE SET TO THE SPECIFIED\n             JULIAN DATE.  (FOR JULIAN DATE CONVERSION, SEE HELP FOR\n             THE 'JULIAN' COMMAND).  'YYDDD' MUST BE EITHER A FIVE\n             DIGIT JULIAN DATE OR A ZERO.\n))CREATE('YYDDD') - THE CREATION DATE IS TO BE SET TO THE SPECIFIED\n             JULIAN DATE.  (FOR JULIAN DATE CONVERSION, SEE HELP FOR\n             THE 'JULIAN' COMMAND).  'YYDDD' MUST BE EITHER A FIVE\n             DIGIT JULIAN DATE, A ZERO, OR AN ASTERISK (TODAY'S DATE).\n))REFDT('YYDDD') - THE REFERENCE DATE IS TO BE SET TO THE SPECIFIED\n             JULIAN DATE.  (FOR JULIAN DATE CONVERSION, SEE HELP FOR\n             THE 'JULIAN' COMMAND).  'YYDDD' MUST BE EITHER A FIVE\n             DIGIT JULIAN DATE, A ZERO, OR AN ASTERISK (TODAY'S DATE).\n))DSORG(DSORG) - THE DSORG IS TO BE CHANGED TO THE SPECIFIED TYPE.\n))RECFM(RECFM) - THE RECFM IS TO BE CHANGED TO THE SPECIFIED TYPE.\n))LRECL(LRECL) - THE LRECL IS TO BE CHANGED TO THE SPECIFIED VALUE.\n))BLKSIZE(VALUE) - THE BLKSIZE IS TO BE CHANGED TO THE SPECIFIED VALUE.\n))PWR      - THE PROTECTION FLAGS ARE TO BE SET FOR PWREAD, MEANING\n             A PASSWORD IS REQUIRED TO READ OR WRITE.\n))PWW      - THE PROTECTION FLAGS ARE TO BE SET FOR PWWRITE, MEANING\n             A PASSWORD IS REQUIRED TO WRITE BUT NOT TO READ.\n))NOP      - THE PROTECTION FLAGS ARE TO BE SET OFF, MEANING\n             A PASSWORD IS NEVER REQUIRED.\n))RACF     - THE DATA SET IS TO BE MARKED RACF PROTECTED.\n))NORACF   - THE DATA SET IS TO BE MARKED NOT RACF PROTECTED.\n))ZAP(OFFSET VERDATA REPDATA) - THIS KEYWORD MAY BE USED TO MODIFY\n             FIELDS WITHIN THE DSCB BY SPECIFYING (IN HEX) THE\n             FIELD OFFSET, THE FIELD'S CURRENT VALUE (IN HEX), AND\n             THE REPLACEMENT VALUE (IN HEX).  IF THE CURRENT VALUE\n             DOES NOT VERIFY CORRECTLY, THE DATA IS NOT REPLACED.\n             THE REPDATA MAY BE OMITTED IF YOU JUST WANT TO VERIFY.\n\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9007JL": {"ttr": 6404, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93!\\x0f\\x00\\x93!\\x0f\\x145\\x02|\\x02|\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "1993-07-29T14:35:00", "lines": 636, "newlines": 636, "modlines": 0, "user": "SBGCSC"}, "text": "\n                MVS TOOLS AND TRICKS OF THE TRADE\n                          July 1990\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n\n\n      This month, I'd like to deal with an area in which many people\nthink there is not much room for improvement.  I sharply disagree, and\nI hope that we can stimulate some activity and inventiveness in this\narea among our readership.\n\n      The topic of discussion comes in two parts.  The first part\ndeals with massaging SMP inputs (SMPPTFIN-format files) and reporting\non their contents, independent of real SMP/E processing.  The second\npart deals with notions of feeding the outputs of SMP/E runs back\ninto subsequent SMP/E runs.  I have done some work in both of these\ncategories, but I feel there is much more to be done of value to\nbenefit all of us.\n\n      I wish to begin the discussion with a focus on a CBT-tape file,\nFile 118, which contains several programs:  an assembler program\ncalled PUTXREF from Jerry Lawson of the Hartford Insurance Group, and\nseveral COBOL programs written by me.  There are several types of\nSMPPTFIN processing that can be done with these programs.  I'll try,\nwithin the scope of this month's writing, to cover some different\nthings that can be done.\n\n      The purpose of Jerry Lawson's PUTXREF program is to take\nany SMPPTFIN file, containing PTFs, APARs, USERMODs, or FUNCTIONs,\nand produce a report sorting all of these SYSMODS by their owning\nFMID (a product ownership designation which is used by SMP/E\nprocessing).  See Figure One for a sample of what this report looks\nlike.  Thus, given a collection of maintenance SYSMODs in SMP format,\nit is easily and practially possible to determine which products this\nmaintenance is for, without involving any real SMP processing at all.\n\n      Practically speaking, you can run the PUTXREF report against a\nPUT tape file, or a CBIPO or CBPDO SMPMCS file, to determine if the\nproper profile of maintenance for program products was shipped to your\ninstallation by IBM.  It is useful to have this FMID report BEFORE\nRECEIVEing the maintenance on your system, because it would be nice to\nknow that the product mix was correctly shipped to you.  Often,\nprofile errors occur in such shipments, and the right maintenance PTFs\ndon't get to you.  Early notification of this would certainly be\nuseful for the timely correction of IBM's mistakes, BEFORE your system\nis affected.\n\n      I haven't stopped at Jerry's implementation of pre-SMP FORFMID\nprocessing.  I have written a COBOL post-processor to the PUTXREF\noutput report called SMPFMUPV, which converts the FMID-sorted report\nof SYSMODs into an actual CARD-IMAGE FILE of SYSMOD numbers sorted by\nowning FMID, with all duplicate SYSMOD numbers removed.  This makes\nthe list of SYSMODs suitable for input into a subsequent SMP job.  See\nFigure Two for an sample illustration of what this file looks like.\nSee Figure Three for sample JCL that will run the entire processing in\none stream.\n\n      There are obviously many uses for such information.  Large\nPTF files can be analyzed for their content, BEFORE they are used.\nYour installation does not have to make a commitment to installing a\ncollection of system maintenance until a pre-analysis of the\nmaintenance has been performed, and the scope of the contents\ndetermined to the satisfaction of the systems staff.  Several kinds of\nIBM shipping errors can be immediately spotted, and corrections\nordered without unnecessary delay.\n\n      We can suggest a few miscellaneous applications at this point.\nFor one example:  PTF tape shipments can be routinely pre-analyzed\nfor FMID mix at the time they arrive.  Older product releases that are\nbeing gradually \"stabilized\" can be pointed out and noted, through the\nnow \"obvious\" reduction in the number of PTF fixes belonging to their\nFMIDs.  Another example:  Better control in single-product maintenance\nupgrades can be attained, if pre-knowledge of all maintenance PTF\nnumbers belonging to that product has been gathered in advance of any\nSMP run.  A third example:  Entire PTS datasets can be analyzed for\nFMID consideration of their contents, to determine if REJECT processing\nfor components of obsolete products should be carried out (see Figure\nFour for an illustration of JCL to do this).\n\n      Given the type of information that we're gathering, you, our\nesteemed readers, can figure out other handy uses for such data, and\nneater ways to deal with it.\n\n      I'll go just another step, to show you how I currently use\nthese programs in my own shop.\n\n      When a PUT tape comes in, I run four jobs.  The first job\ncopies the first ten files of the tape to disk.  The second job does\na TAPEMAP (CBT tape File 299) of the PUT tape, followed by a PUTXREF\nrun to produce a FORFMID report for the PTFs on the tape.  The two\nTAPEMAP reports and the PUTXREF report are copied to three members of\na partitioned dataset having LRECL=133.  The names of these members\ncontain the PUT level within them for later reference.  The third job\nis essentially a SMPFMUPV run that converts the PUTXREF report for\nthe PUT tape into a card-image \"FORFMID\" file.  Figure Three\nillustrates a combination of my second and third jobs against a PUT\ntape.  Finally, the fourth job converts the entire input SMPPTFIN\nfile into a partitioned dataset with each PTF separated as a separate\nmember for easy browsing.  This last job will be the final subject of\nour article, but I want to first explain the practical usefulness of\nthe first three jobs to me.\n\n      By collecting the TAPEMAP and PUTXREF reports into one PDS,\nI can make use of the fabulous \"PDS program product\" (CBT tape files\n182, 296, and 112) or its vendor-supported extension called PDS/E.\nThe \"PDS\" program products have a \"global string find\" capability\nover an entire partitioned dataset, or over any subcollection of its\nmembers.  By looking for all occurrences of an FMID name, or of a\ngiven PTF number, I can quickly do all the necessary research that\nI need, before actually attempting to put the maintenance on my\nsystem.  See Figure Five for a small illustration.\n\n      Our final topic for discussion this month will be several\nmethods for the convenient browsing of individual PTFs and their\ncover letters.  Our methods will cover both PTFs that have already\nbeen RECEIVED by SMP, and also PTFs that have not yet been RECEIVED.\n\n      To browse PTFs and other SYSMODs that have been RECEIVED by\nSMP, one need merely refer to the SMPPTS dataset, either for an SMP/E\nsystem, or even for an old SMP4 system.  There is a handy TSO \"browser\"\ncommand called \"REVIEW\", which does not need ISPF in order to work.\nTwo versions of REVIEW are found on the CBT tape.  The earlier version\nis on File 296, and a later, improved version is on File 134 of any\nrecent level of that tape.  Either version can be employed in a simple\nCLIST (Figure Six) that will accomplish the convenient \"browse\" of\na RECEIVED SYSMOD.\n\n      Looking at a not-yet-RECEIVED SYSMOD is much trickier, because\nsuch a SYSMOD is usually embedded in a large SMPPTFIN-format\nsequential file that can contain several hundred thousand card-images\nand hundreds of separate SYSMODs.  Anyone familiar with the usual\ntools will know that such a file is hard or impossible to negotiate\nwith a \"browsing\" or \"editing\" tool.\n\n      To chop this file into easy-to-find pieces, I have written\na quick-and-dirty COBOL program that works well.  The name of this\nprogram is SMPUPD, and it can also be found on File 118 of the CBT\ntape.\n\n      The SMPUPD program essentially makes a duplicate temporary copy\nof an SMPPTFIN-format file, but with two subtle changes.  First,\nbefore any card-image beginning with ++PTF, ++APAR, ++USERMOD, or\n++FUNCTION, a new IEBUPDTE-format card is inserted.  This card has the\nformat:\n\n./  ADD NAME=sysmdnm       (sysmdnm is the number of the SYSMOD)\n\n      The second change done to the copy of the original file, is\nthat any \"./\" string found in columns 1-2 of the original file, is\nchanged to a different string, \"><\".  The PDSLOAD program (CBT tape\nFile 316) or the IEBUPDTE program is then run against the new copy\nof the original file, to break it up into partitioned dataset members.\nAn advantage of PDSLOAD over IEBUPDTE is that in the reloading\nprocess, the embedded \"><\" strings can be reconverted back to the\noriginal \"./\" strings, without having to run an additional utility\nstep.  See Figure Seven for a JCL example to illustrate how this\nprocessing works in practice.  Partitioned dataset members consisting\nof individual PTFs are much easier to browse (or edit) than large\nsequential SMPPTFIN files.\n\n      A final twist in the \"partitioning\" of an SMPPTFIN file is\nprovided by the \"PDS program product\" again (if it is at version 8.0\nor higher, or if it is \"PDS/E\").  This is that product's ability to\nadd ISPF statistics to partitioned dataset members THROUGH A BATCH\nJOB, and also ITS ABILITY TO RESTORE DELETED MEMBERS IN THAT SAME JOB\nSTEP.  See the bottom of Figure Seven.  Sometimes, duplicate PTFs can\nbe shipped by IBM in the same file.  This will cause one member to be\ncreated by IEBUPDTE or PDSLOAD in the output partitioned dataset,\nwhich will be deleted later when the second member of the same name\nis stowed.  To remedy the loss caused by such deletion, the PDS(/E)\nsubcommand:\n\n   RESTORE $PTF REPEAT NOPROMPT\n\nwill automatically resuscitate all deleted members, and supply these\nwith names $PTF0001, $PTF0002, etc. that will place them at the\nbeginning of a directory sort.\n\n      See Figure Ten for a partial member list from such a\n\"partitionized\" PTF file that was created from a PUT tape file.\nIt will quickly become clear how useful this sort of processing\nis.\n\n      Well that's it for now.  I hope this discussion will improve\nthe state of system maintenance in your shop in some way.  Actually,\nI haven't spoken of all my ideas on this subject yet.  Maybe we can\ndeal with it some more next month.  Good luck.  See you again soon.\n\n\n    *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure Two.   Output of the SMPFMUPV Program, operating on the\n               Report in Figure One.\n\n\n./  ADD  NAME=EBB1102\n      UY43678  /*  FMID - EBB1102 - FROM PUT TAPE - DONE 03/13/90    */\n      UY43689  /*  FMID - EBB1102 - FROM PUT TAPE - DONE 03/13/90    */\n./  ADD  NAME=EER3300\n      UR28142  /*  FMID - EER3300 - FROM PUT TAPE - DONE 03/13/90    */\n      UR28329  /*  FMID - EER3300 - FROM PUT TAPE - DONE 03/13/90    */\n./  ADD  NAME=FDZ1B02\n      UL59377  /*  FMID - FDZ1B02 - FROM PUT TAPE - DONE 03/13/90    */\n      UL61567  /*  FMID - FDZ1B02 - FROM PUT TAPE - DONE 03/13/90    */\n      UL61573  /*  FMID - FDZ1B02 - FROM PUT TAPE - DONE 03/13/90    */\n      UL61579  /*  FMID - FDZ1B02 - FROM PUT TAPE - DONE 03/13/90    */\n      UL64863  /*  FMID - FDZ1B02 - FROM PUT TAPE - DONE 03/13/90    */\n./  ADD  NAME=FDZ1192\n      UL58610  /*  FMID - FDZ1192 - FROM PUT TAPE - DONE 03/13/90    */\n      UL61179  /*  FMID - FDZ1192 - FROM PUT TAPE - DONE 03/13/90    */\n./  ADD  NAME=FER3320\n      UR28188  /*  FMID - FER3320 - FROM PUT TAPE - DONE 03/13/90    */\n./  ADD  NAME=HAF1220\n      UY45100  /*  FMID - HAF1220 - FROM PUT TAPE - DONE 03/13/90    */\n      UY90513  /*  FMID - HAF1220 - FROM PUT TAPE - DONE 03/13/90    */\n./  ADD  NAME=HAF1228\n      UY44632  /*  FMID - HAF1228 - FROM PUT TAPE - DONE 03/13/90    */\n      UY44633  /*  FMID - HAF1228 - FROM PUT TAPE - DONE 03/13/90    */\n      UY44634  /*  FMID - HAF1228 - FROM PUT TAPE - DONE 03/13/90    */\n      UY44650  /*  FMID - HAF1228 - FROM PUT TAPE - DONE 03/13/90    */\n      UY44651  /*  FMID - HAF1228 - FROM PUT TAPE - DONE 03/13/90    */\n      UY44747  /*  FMID - HAF1228 - FROM PUT TAPE - DONE 03/13/90    */\n      UY44879  /*  FMID - HAF1228 - FROM PUT TAPE - DONE 03/13/90    */\n      UY44948  /*  FMID - HAF1228 - FROM PUT TAPE - DONE 03/13/90    */\n./  ADD  NAME=HCI1702\n      UL56230  /*  FMID - HCI1702 - FROM PUT TAPE - DONE 03/13/90    */\n      UL59252  /*  FMID - HCI1702 - FROM PUT TAPE - DONE 03/13/90    */\n\n    -  -  -  -  -  -    continued    -  -  -  -  -  -  -  -\n\n\n\n    *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure Three.   A sample jobstream to do SMP pre-processing of\n                 PUT tape 9001.\n\n\n//TSTBFP2M JOB (TS,2322),'TECH.SUPP-SAM.GOLOB',CLASS=M,NOTIFY=TSTBSSG,\n//        MSGLEVEL=(1,1),MSGCLASS=T TYPRUN=HOLD\n//*\n//****************************************************************\n//*      OUTPUT OF TAPEMAP PROGRAM SENT TO TST.PTFTAPE.MAPS      *\n//****************************************************************\n//***********************************************************\n//*      THIS JOBSTREAM MAPS PUT TAPES OR PTF TAPES         *\n//*       AND ALSO CROSS-REFERENCES THEM BY FMID.  THREE    *\n//*       OUTPUTS ARE WRITTEN TO THE PARTITIONED DATASET    *\n//*       'TST.PTFTAPE.MAPS'.  YOU CAN FIND OUT WHAT'S      *\n//*       ON ANY PUT TAPE BY INQUIRING ON THIS PDS.         *\n//*                                                         *\n//*      THE GLOBAL FIND CAPABILITY OF PDS VERSION 8.x      *\n//*       IS EXTREMELY HELPFUL TO LOCATE INDIVIDUAL PTFS,   *\n//*       AND ALSO, ALL OCCURRENCES OF MAINTENANCE FOR      *\n//*       PTFS BELONGING TO A GIVEN FMID.                   *\n//***********************************************************\n//TAPEMAP PROC VOL=XXXXXX,M='M',DRIVE=TAPE,INBLK=7200,LA=01,X='X'\n//TAKEMAP EXEC PGM=TAPEMAP\n//STEPLIB  DD  DSN=TST.TSO.CMDLIB,DISP=SHR\n//SYSPRINT DD  DSN=&&TMP,DISP=(NEW,PASS,DELETE),UNIT=SYSDA,\n//         SPACE=(CYL,(3,3)),DCB=(RECFM=FBA,LRECL=133,BLKSIZE=3059)\n//SYSPRNT2 DD  DSN=&&TMP1,DISP=(NEW,PASS,DELETE),UNIT=SYSDA,\n//         SPACE=(CYL,(3,3)),DCB=(RECFM=FBA,LRECL=133,BLKSIZE=3059)\n//SYSUT1   DD  UNIT=&DRIVE,VOL=(PRIVATE,,,,SER=(&VOL)),\n//             DISP=SHR,LABEL=(,BLP,EXPDT=98000)\n//*\n//RESET    EXEC PGM=IEFBR14,REGION=4096K\n//*\n//XREF2    EXEC PGM=PUTXREF,REGION=4096K\n//STEPLIB  DD  DSN=TST.TSO.CMDLIB,DISP=SHR\n//INPUT    DD  UNIT=&DRIVE,VOL=(PRIVATE,RETAIN,,,SER=(&VOL)),\n//             DISP=SHR,LABEL=(&LA,NL,EXPDT=98000),DSN=PTFS,\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=&INBLK),FREE=CLOSE\n//SORTIN   DD  DSN=&&S&VOL,DISP=(NEW,PASS),UNIT=3380,\n//             DCB=(RECFM=FB,LRECL=15,BLKSIZE=4095),\n//             SPACE=(CYL,(25,20)),VOL=SER=WORK02\n//SORTOUT  DD  DSN=&&S&VOL,DISP=(SHR,PASS),VOL=REF=*.SORTIN\n//TITLES   DD  DISP=SHR,DSN=TSTBSSG.A.CNTL(FMIDTBL)\n//SYSUDUMP DD  SYSOUT=*\n//SYSOUT   DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=*\n//PRINTER  DD  DSN=&&TMP2,DISP=(NEW,PASS,DELETE),UNIT=SYSDA,\n//         SPACE=(CYL,(3,3)),DCB=(RECFM=FBA,LRECL=133,BLKSIZE=3059)\n//SYSIN    DD  DISP=SHR,DSN=TSTBSSG.A.CNTL(PUTXSORT)\n//*\n//COPYMAP EXEC PGM=DSCOPY\n//SYSPRINT DD  SYSOUT=*\n//IN1      DD  DISP=(OLD,DELETE),DSN=&&TMP\n//IN2      DD  DISP=(OLD,DELETE),DSN=&&TMP1\n//IN3      DD  DISP=(OLD,DELETE),DSN=&&TMP2\n//OUT1     DD  DISP=SHR,DSN=TST.PTFTAPE.MAPS(&VOL)\n//OUT2     DD  DISP=SHR,DSN=TST.PTFTAPE.MAPS(&VOL&M)\n//OUT3     DD  DISP=SHR,DSN=TST.PTFTAPE.MAPS(&VOL&X)\n//*\n//  PEND\n//*\n//FMIDFILE PROC VL=XXXXXX,SUFF='X'\n//******************************************************************//\n//*    PUTXREF PROGRAM FROM CONNECTICUT BANK AND TRUST COMPANY     *//\n//*           MVS TAPE  --  FILE  118                              *//\n//******************************************************************//\n//S01FMUPD EXEC PGM=SMPFMUPD      <===  FB-133 version of SMPFMUPV\n//STEPLIB DD DISP=SHR,DSN=TSTBSSG.LOAD\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD DISP=SHR,DSN=TST.PTFTAPE.MAPS(&VL&SUFF)\n//SYSUT2   DD DISP=SHR,DSN=TST.PTFTAPE.FORFMID(&VL)\n//SYSABEND DD SYSOUT=A,HOLD=YES\n//  PEND\n//*\n//MAP001  EXEC TAPEMAP,VOL=TM9001\n//XREF001 EXEC FMIDFILE,VL=TM9001\n\n\n    *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure Four.   Jobstream that \"sequentializes\" an entire PTS partitioned\n                dataset and runs the SMPPTFIN-format output through our\n                FMID processing.  This is done without the use of SMP.\n                It completely organizes all owned SYSMODS by owning\n                FMID.\n\n\n//TSTBHMOO JOB (TS,2322),'TECH.SUPP-SAM.GOLOB',CLASS=T,NOTIFY=TSTBSSG,\n//        MSGLEVEL=(1,1),MSGCLASS=T TYPRUN=HOLD\n//*\n//******************************************************************//\n//*    PTFS BY FMID -  This is a run against an entire SMPPTS,     *//\n//*        to produce a card file of PTFs sorted by FMID.          *//\n//******************************************************************//\n//*\n//* -------    Filter out Control Members of SMP4 SMPPTS    ------ *\n//* -------   This step is not necessary for SMP/E SMPPTS   ------ *\n//COPYPTS EXEC PGM=IKJEFT01,REGION=4096K,DYNAMNBR=50\n//STEPLIB  DD DISP=SHR,DSN=TST.TSO.CMDLIB\n//         DD DISP=SHR,DSN=IPO1.LINKLIB\n//         DD DISP=SHR,DSN=TSP.TSO.CMDLIB\n//SYSPRINT DD SYSOUT=*\n//SYSTSPRT DD SYSOUT=*\n//SYSTERM  DD SYSOUT=*\n//SYSTSIN  DD *\n PDSE 'TSY2.SMPPTS' XISPMODE\n COPY A:Z 'TSTBSSG.SMALL.SMPPTS' NEW VOL(WORK01)\n C 'TSTBSSG.SMALL.SMPPTS'\n FIXPDS RELEASE\n END\n/*\n//*\n//* -------   Use OFFLOAD Program to create a sequential    ------ *\n//* -------   file in SMPPTFIN format from the PDS members. ------ *\n//DSPEQMOD EXEC PGM=OFFLOAD,REGION=5000K\n//STEPLIB  DD DISP=SHR,DSN=TST.TSO.CMDLIB\n//SYSPRINT DD SYSOUT=*\n//IN    DD  DISP=SHR,DSN=TSTBSSG.SMALL.SMPPTS\n//OUT   DD  DSN=TSTBSSG.SEQ.SMPPTS,DISP=(NEW,CATLG,DELETE),\n// UNIT=3380,VOL=SER=WORK02,SPACE=(TRK,(3900,300),RLSE),\n// DCB=(RECFM=FB,DSORG=PS,LRECL=80,BLKSIZE=3120)\n//SYSIN  DD *\n O I=IN,O=OUT\n//*\n//* -------   Run the PUTXREF program to make XREF report.  ------ *\n//S01XREF  EXEC PGM=PUTXREF,REGION=4096K\n//STEPLIB  DD  DSN=TST.TSO.CMDLIB,DISP=SHR\n//INPUT    DD  DISP=SHR,DSN=TSTBSSG.SEQ.SMPPTS\n//SORTIN   DD  DSN=&&SORT,DISP=(NEW,PASS),UNIT=3380,\n//             DCB=(RECFM=FB,LRECL=15,BLKSIZE=4095),\n//             SPACE=(CYL,(35,50))\n//SORTOUT  DD  DSN=&&SORT,DISP=(SHR,PASS),VOL=REF=*.SORTIN\n//SORTWK01 DD  UNIT=SYSDA,SPACE=(CYL,(10,10))\n//SORTWK02 DD  UNIT=SYSDA,SPACE=(CYL,(10,10))\n//SORTWK03 DD  UNIT=SYSDA,SPACE=(CYL,(10,10))\n//SORTWK04 DD  UNIT=SYSDA,SPACE=(CYL,(10,10))\n//TITLES   DD  DISP=SHR,DSN=TSTBSSG.A.CNTL(FMIDTBL)\n//PRINTER  DD  DSN=&TEMP1,DISP=(NEW,PASS),UNIT=3380,\n//         DCB=(RECFM=VBA,LRECL=137,BLKSIZE=141),\n//         SPACE=(TRK,(90,90))\n//SYSUDUMP DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=*\n//SYSOUT   DD  SYSOUT=*\n//SYSIN    DD  *\n SORT FIELDS=(9,7,CH,A,1,7,CH,A)\n/*\n//*****************************************************************//\n//* -------   Run the SMPFMUPV program to create card file  ------ *\n//* -------   of all of the SYSMODS in the PTS, sorted by   ------ *\n//* -------   FMID.  Identify the file by the date run.     ------ *\n//S02FMUPD EXEC PGM=SMPFMUPV\n//STEPLIB DD DISP=SHR,DSN=TSTBSSG.LOAD\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD DSN=&TEMP1,DISP=(OLD,PASS)\n//SYSUT2   DD DISP=SHR,DSN=TST.VSGEN.T8907.PUTPDS(PTS89312)\n//SYSABEND DD SYSOUT=A,HOLD=YES\n\n\n\n    *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure Five.   A search through past PUT tapes for all recent PTFs\n                affecting the Assembler H version 2 product.\n                This product has an FMID designation of HAH2100.\n\n\n\n- DSN=TST.PTFTAPE.FORFMID,VOL=SER=PAGE01  MEM=:\n>fi : /hah2100/\n\n** FIND     TM8703\n./  ADD  NAME=HAH2100\n      UL07954  /*  FMID - HAH2100 - FROM PUT TAPE - DONE 05/12/87    */\n      UL08162  /*  FMID - HAH2100 - FROM PUT TAPE - DONE 05/12/87    */\n      UL08349  /*  FMID - HAH2100 - FROM PUT TAPE - DONE 05/12/87    */\n      281  lines in this member\n\n** FIND     TM8705\n./  ADD  NAME=HAH2100\n      UL08161  /*  FMID - HAH2100 - FROM PUT TAPE - DONE 08/06/87    */\n      UL11177  /*  FMID - HAH2100 - FROM PUT TAPE - DONE 08/06/87    */\n      UL11296  /*  FMID - HAH2100 - FROM PUT TAPE - DONE 08/06/87    */\n      UL11345  /*  FMID - HAH2100 - FROM PUT TAPE - DONE 08/06/87    */\n      UL11737  /*  FMID - HAH2100 - FROM PUT TAPE - DONE 08/06/87    */\n      UL11985  /*  FMID - HAH2100 - FROM PUT TAPE - DONE 08/06/87    */\n      263  lines in this member\n\n** FIND     TM8709\n./  ADD  NAME=HAH2100\n      UL17396  /*  FMID - HAH2100 - FROM PUT TAPE - DONE 01/12/88    */\n      UL19910  /*  FMID - HAH2100 - FROM PUT TAPE - DONE 01/12/88    */\n      UL90092  /*  FMID - HAH2100 - FROM PUT TAPE - DONE 01/12/88    */\n      201  lines in this member\n\n** FIND     TM8803\n./  ADD  NAME=HAH2100\n      UL25203  /*  FMID - HAH2100 - FROM PUT TAPE - DONE 05/16/88    */\n      263  lines in this member\n\n** FIND     TM8806\n./  ADD  NAME=HAH2100\n      UL31583  /*  FMID - HAH2100 - FROM PUT TAPE - DONE 10/24/88    */\n      UL33954  /*  FMID - HAH2100 - FROM PUT TAPE - DONE 10/24/88    */\n      UL90149  /*  FMID - HAH2100 - FROM PUT TAPE - DONE 10/24/88    */\n      269  lines in this member\n\n** FIND     TM8808\n./  ADD  NAME=HAH2100\n      UL38085  /*  FMID - HAH2100 - FROM PUT TAPE - DONE 01/26/89    */\n      256  lines in this member\n\n** FIND     TM8901\n./  ADD  NAME=HAH2100\n      UL41857  /*  FMID - HAH2100 - FROM PUT TAPE - DONE 03/13/89    */\n      289  lines in this member\n\n** FIND     TM8902\n./  ADD  NAME=HAH2100\n      UL41964  /*  FMID - HAH2100 - FROM PUT TAPE - DONE 05/01/89    */\n      225  lines in this member\n\n** FIND     TM8906\n./  ADD  NAME=HAH2100\n      UL54652  /*  FMID - HAH2100 - FROM PUT TAPE - DONE 10/30/89    */\n      217  lines in this member\n\n** FIND     TM8907\n./  ADD  NAME=HAH2100\n      UL55737  /*  FMID - HAH2100 - FROM PUT TAPE - DONE 12/07/89    */\n      159  lines in this member\n\n** FIND     TM8908\n./  ADD  NAME=HAH2100\n      UL59647  /*  FMID - HAH2100 - FROM PUT TAPE - DONE 01/10/90    */\n       79  lines in this member\n\n\n\n    *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure Six.   A simple CLIST that allows a convenient browse of\n               RECEIVED SYSMODs through the use of the REVIEW\n               TSO command and the PDS command processor.\n               Individual PTFs may be browsed, or a range of\n               PTF numbers can be explored or examined.\n\n\n\nPROC 1 MEM\nCLEAR\nNOD: -\n DO\n IF &STR(&MEM) = R   THEN GOTO CSYSR\n IF &STR(&MEM) = RR  THEN GOTO CSYSRR\n REVIEW 'TSY2.SMPPTS(&MEM)'\n EXIT\n END\nCSYSR: -\n DO\n WRITE REPLY WITH RANGE OF MEMBER SEARCH\n READ DD\n PDSE 'TSY2.SMPPTS' XISPMODE\n DISPL &STR(&DD)\n EN\n END\n EXIT\nCSYSRR: -\n DO\n WRITE REPLY WITH RANGE OF MEMBER SEARCH - WE LOOK AT EACH MEMBER.\n WRITE   FOR THIS PROCESS USE A COLON TO SEPARATE RANGE DELIMITERS.\n READ DD\n PDSE 'TSY2.SMPPTS' XISPMODE\n MEM &STR(&DD)\n REVIEW *\n EN\n END\n\n\n\n\n    *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure Seven.   SMPUPD Jobstream which breaks a PUT tape file into\n                 a convenient-to-browse PDS.  Please note the step\n                 at the end which runs the \"PDS\" command processor\n                 under TSO-in-Batch.  The result achieved is that\n                 the final partitioned dataset has ISPF statistics\n                 and shows all duplicated PTFs from the input file.\n                 All members are available for the user to look\n                 at, or edit.\n\n\n\n//TSTBHMOO JOB (TS,2322),'TECH.SUPP-SAM.GOLOB',CLASS=M,NOTIFY=TSTBSSG,\n//        MSGLEVEL=(1,1),MSGCLASS=T TYPRUN=HOLD\n//******************************************************************//\n//*   SMP   -  PRODUCTION PUT MAINTENANCE  -  PUT 9001             *//\n//*       SMPPTFIN CONVERSION TO PDS FOR REFERENCING.              *//\n//******************************************************************//\n//S1PTFADD EXEC PGM=SMPUPD\n//STEPLIB DD DISP=SHR,DSN=TSTBSSG.LOAD\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD DISP=SHR,DSN=TST.VSGEN.PUT9001.PTFS\n//SYSUT2   DD DISP=(,PASS),DSN=&&TEMP,UNIT=SYSDA,\n//    DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),SPACE=(TRK,(300,120))\n//SYSABEND DD SYSOUT=A,HOLD=YES\n//*\n//S2UPDTE EXEC PGM=PDSLOAD,PARM='UPDTE(><)'\n//STEPLIB   DD  DISP=SHR,DSN=TST.TSO.CMDLIB\n//SYSPRINT  DD  SYSOUT=*\n//SYSUT1    DD  DSN=&&TEMP,DISP=(OLD,PASS)\n//SYSUT2    DD  DSN=TST.VSGEN.PUT9001.PTFPDS,DISP=(NEW,CATLG,DELETE),\n//     UNIT=3380,VOL=SER=WORK02,SPACE=(TRK,(300,120,137)),\n//     DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)\n//*\n//S3LISTV EXEC PGM=IKJEFT01,REGION=4096K,DYNAMNBR=50\n//STEPLIB  DD DISP=SHR,DSN=TST.TSO.CMDLIB\n//         DD DISP=SHR,DSN=IPO1.LINKLIB\n//         DD DISP=SHR,DSN=TSP.TSO.CMDLIB\n//SYSPRINT DD SYSOUT=*\n//SYSTSPRT DD SYSOUT=*\n//SYSTERM  DD SYSOUT=*\n//SYSTSIN  DD *\n PDS   'TST.VSGEN.PUT9001.PTFPDS'\n AT : ADDSTATS USERID(PUT9001) VER(01)\n RESTORE $PTF REPEAT NOPROMPT\n AT $PTF: ADDSTATS USERID(REP9001) VER(01)\n FIXPDS RELEASE\n END\n/*\n//\n\n\n    *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure Eight.   Member list of PTFs which have been separated out of\n                 a large SMPPTFIN file (of over 156,000 card-images).\n                 The result was achieved using my SMPUPD program.\n                 This display happens to be a PDS/E member list\n                 display.  The \"public\" PDS product has a similar\n                 facility.\n\n\n\n ------------------------- MEMLIST Source Member List 1 ---------  ROW 1 OF 186\n COMMAND ===>                                                  SCROLL ===> CSR\nEnter an ISPF command, a PDS/E subcommand or a special control code:\n FUNCTION FEATURES CODES    NAVIGATE DSNCMDS  MEMCMDS  DEFAULTS OTHER\n - DSN=TST.VSGEN.PUT9001.PTFPDS,VOL=SER=WORK02  MEM=:  -------------------------\n CMD  NAME     DATA     VER.MOD    CREATED   LAST MODIFIED  SIZE  INIT    ID\n      $PTF0001           01.00    90/04/19  90/04/19 18:43  1533  1533   REP9001\n      UL56230            01.00    90/04/19  90/04/19 18:41   243   243   PUT9001\n      UL58610            01.00    90/04/19  90/04/19 18:41  6226  6226   PUT9001\n      UL59252            01.00    90/04/19  90/04/19 18:41   181   181   PUT9001\n      UL59295            01.00    90/04/19  90/04/19 18:41   117   117   PUT9001\n      UL59377            01.00    90/04/19  90/04/19 18:41   854   854   PUT9001\n      UL59673            01.00    90/04/19  90/04/19 18:41    54    54   PUT9001\n      UL59677            01.00    90/04/19  90/04/19 18:41   520   520   PUT9001\n      UL59957            01.00    90/04/19  90/04/19 18:41   531   531   PUT9001\n      UL60112            01.00    90/04/19  90/04/19 18:41   144   144   PUT9001\n      UL60747            01.00    90/04/19  90/04/19 18:41   204   204   PUT9001\n      UL61061            01.00    90/04/19  90/04/19 18:41 52351 52351   PUT9001\n      UL61179            01.00    90/04/19  90/04/19 18:41  6229  6229   PUT9001\n      UL61567            01.00    90/04/19  90/04/19 18:42   205   205   PUT9001\n      UL61573            01.00    90/04/19  90/04/19 18:42   213   213   PUT9001\n      UL61579            01.00    90/04/19  90/04/19 18:42   121   121   PUT9001\n      UL61889            01.00    90/04/19  90/04/19 18:42   211   211   PUT9001\n      UL61897            01.00    90/04/19  90/04/19 18:42   428   428   PUT9001\n      UL61915            01.00    90/04/19  90/04/19 18:42   205   205   PUT9001\n      UL61917            01.00    90/04/19  90/04/19 18:42   249   249   PUT9001\n      UL61919            01.00    90/04/19  90/04/19 18:42  1665  1665   PUT9001\n      UL61922            01.00    90/04/19  90/04/19 18:42   193   193   PUT9001\n      UL62039            01.00    90/04/19  90/04/19 18:42   223   223   PUT9001\n      UL62051            01.00    90/04/19  90/04/19 18:42  1533  1533   PUT9001\n      UL62061            01.00    90/04/19  90/04/19 18:42  1094  1094   PUT9001\n      UL62099            01.00    90/04/19  90/04/19 18:42    85    85   PUT9001\n      UL62127            01.00    90/04/19  90/04/19 18:42   539   539   PUT9001\n      UL62248            01.00    90/04/19  90/04/19 18:42   150   150   PUT9001\n      UL62254            01.00    90/04/19  90/04/19 18:42  2458  2458   PUT9001\n      UL62285            01.00    90/04/19  90/04/19 18:42  4375  4375   PUT9001\n      UL62288            01.00    90/04/19  90/04/19 18:42    76    76   PUT9001\n      UL62466            01.00    90/04/19  90/04/19 18:42   180   180   PUT9001\n      UL62482            01.00    90/04/19  90/04/19 18:42   301   301   PUT9001\n      UL63138            01.00    90/04/19  90/04/19 18:42  1524  1524   PUT9001\n      UL63147            01.00    90/04/19  90/04/19 18:42  2593  2593   PUT9001\n      UL63161            01.00    90/04/19  90/04/19 18:42   588   588   PUT9001\n      UL63187            01.00    90/04/19  90/04/19 18:42    57    57   PUT9001\n      UL63197            01.00    90/04/19  90/04/19 18:42   255   255   PUT9001\n\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9008AU": {"ttr": 6661, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93!\\x0f\\x00\\x93!\\x0f\\x145\\x01\\xe6\\x01\\xe6\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "1993-07-29T14:35:00", "lines": 486, "newlines": 486, "modlines": 0, "user": "SBGCSC"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          August 1990\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n\n\n      Last month, we discussed the usefulness of SMPPTFIN\npre-processing outside of SMP or SMP/E.  I hope to continue on the\nsubject of \"SMP additions\" in more depth in a future installment.  I\nfeel that SMP/E facilities are not complete for all our needs.  They\ncan use quite a bit of user supplementation.  However this month, a\nvery interesting SMP situation had arisen in our shop.  I'll describe\nwhat we did in the hope that you may compare notes, and add this\ntechnique to your repertoire of knowledge.\n\n      Because of space constraints, this topic will be divided\nbetween two issues, and the figure numbering will span both issues.\nHowever, THE SIDEBAR SUMMARIZES THE COMPLETE PROCEDURE THAT WAS\nFOLLOWED.  Anyone needing hands-on help on this topic can consult\nthe sidebar.  Next month's discussion will merely add further\ndetail.\n\n\nTHE PROBLEM.\n\n      Our shop had the following problem.  We are happy users of VTAM\nrelease 2.2 (HVT2202).  We were running MVS/370 (SP 1.3.5) and were\ntrying to go to MVS/XA 2.2.3 with a CBIPO.  IBM was pleased to inform us\nthat while they still support VTAM 2.2, they no longer ship that release\nto new customers, and it is unavailable in a CBIPO.  My boss (who does\nthe ordering) asked them to ship the CBIPO without VTAM.  This, IBM\nrefused to do, because they obviously do not want to ship a system\nthat \"does not work\".\n\n      We finally settled on the compromise of ordering VTAM 3.2\n(HVT3205 and JVT3215) on free trial so we could get the CBIPO.  VTAM\n3.2 costs considerably more than 2.2, and we don't need the extra\nfunction.  I assured my boss that once the IPO was up and running\nsomewhat, I would find a way to regress VTAM 3.2 out, and plug VTAM\n2.2 back in its place so he could cancel the VTAM 3.2 trial.  I had\nto \"put my money where my mouth was\", and actually accomplish the\ndeed.  This was the problem we had.\n\n      Well we're proud to say that we've overcome it successfully.\nI'll try to tell you how it was done.\n\n      The main difficulty is that VTAM is not a standalone product--it\ninterfaces with other components of the operating system.  We were\nattempting to transplant an installed VTAM \"imbedded\" in an MVS/370\nsystem over to an new MVS/XA system that was considerably different\nfrom the old system.  We had to faithfully implant the older VTAM into\nnew surroundings, in the way that the fit was intended by IBM\noriginally.\n\n      One thing that helped us was having SMP/E Release 5.  (SMP/E\nRelease 4 will do the job too.)  Shortly before the CBIPO had been\nordered, we converted our old SMP4 (non SMP/E) maintenance system to\nIBM's newest.  Even though I probably could have done this stuff on\nthe old system, I was quick to take advantage of the new facilities of\nSMP/E, particularly the GENERATE function, which can be pictured as\nthe reverse of JCLIN.\n\n      Hang in there and let me explain the SMP/E things, so we all\nclearly understand the concepts behind what we're trying to do.\n\n\nSOME \"FOUNDATION\" SMP/E KNOWLEDGE:  What is JCLIN?\n\n      JCLIN contains the \"smarts\" of how your operating system is\nbuilt.  It consists of IEBCOPY, ASSEMBLY, and LINKEDIT JCL that builds\nthe working components of your operating system from its physical\n\"building blocks\".  The physical pieces of the product, or ELEMENTS,\nare shipped to you in the DLIBs--the \"distribution libraries\" of\nmacros and modules.  IBM sends DLIBs directly to customers of a\nnewly-shipped system.  After installation, the DLIBs are updated\nthrough the SMP ACCEPT processing.\n\n      When the JCL for construction of a software product is fed into\nSMP/E, patterns for building that product's executable pieces are now\nmade known to SMP/E as internal entries.  SMP/E can follow these\npatterns later, so that subsequent product fixes are inserted into\ntheir proper places and they will operate properly.\n\n      Building blocks alone \"do not a house make\".  As we have stated,\nCOPY, ASSEMBLY, and LINKEDIT JCL may be necessary for building the\ntarget structure (\"operating system\") from the blocks.  The JCL\nthat properly puts the pieces together has to undergo two processes.\nProcess number one:  it must ACTUALLY BE RUN against the building\nblocks to build the executable TARGET LIBRARIES initially.  Process\nnumber two:  its pattern must be fed into SMP via the process of\n\"JCLIN\", so that SMP will \"know\" the system architecture for its later\nuse in applying system fixes.\n\n      I think that it is not adequate to describe JCLIN as \"JCL that\ngoes into SMP\", as some IBM books do.  JCLIN CONTAINS THE CONSTRUCTION\nBLUEPRINTS that describe the \"walls, rooms, and hallways of the\nbuilding\".  Just as a building cannot be properly built without PLANS,\nan operating system component cannot be properly built without its\nJCLIN.\n\n      Where did the JCLIN for your \"building\" (\"operating system\ncomponent\") originally come from?  It may have come from your \"SYSGEN\nSTAGE TWO\" deck, which in turn came from your installation's \"SYSGEN\nSTAGE ONE\" system configuration deck THAT YOUR INSTALLATION CODED.\nYour SYSGEN STAGE ONE gets assembled against the current set of SYSGEN\nMACROS that have been shipped with the distribution libraries by IBM.\nAnd it is these SYSGEN MACROS which contain the \"brains\" and the\nblueprint of how to \"build the building\".\n\n      That's the case where the JCLIN came from products that have\n\"SYSGEN support\" from IBM.  If a product does not have SYSGEN support,\nthe JCLIN was shipped within the initial FUNCTION SYSMOD when the\nproduct was first ordered.\n\n      If you have my \"Technical Support\" article:  \"SMP Demystified\"\nfrom December 1988, now would be a good time to take it out for\nanother look.  I have written a clear treatment of this material\nthere.\n\n      To go on, the JCLIN that builds your system, once fed into SMP,\nis not easily retrieved from SMP.  Before the introduction of the\nGENERATE facility to SMP/E, the only way that retrieval could have\nbeen done is through \"LIST of the LMOD, ASSEM, and DLIB entries\" for\nthe FMIDs that you wanted to study.  The resultant long listing would\nhave to be carefully edited and tediously converted back into JCL\nformat \"by hand\".\n\n      IBM developers added the GENERATE facility to SMP/E (in release\n3 I believe) to solve that problem for the user.  Running a GENERATE\njob against an SMP/E TARGET ZONE translates the LMOD, ASSEM, and DLIB\nentries back into a JCL stream that would have originally created\nthose entries.  Thus, GENERATE can be viewed as a reverse process to\nJCLIN.  JCLIN feeds the building pattern of the operating system\nworking components into SMP/E.  GENERATE retrieves this JCLIN back out\nfrom SMP/E, and displays it as JCL.\n\n\nRECONSTRUCTING THE PRODUCT WITH JCLIN AND ITS \"ELEMENTS\".\n\n      Now, armed with these foundation materials, we shall angle toward\nour current concern.\n\n      A software product installed with SMP can be completely\ncharacterized by two components:  its ELEMENTS (building blocks, if\nyou will), and its JCLIN, which tells SMP how to construct the building\nfrom the blocks.\n\n      The physical elements are stored in partitioned datasets called\ndistribution libraries or DLIBs.  The SMP/E records of all elements\nbelonging to a product are stored in VSAM datasets called ZONEs.\nDistribution libraries (\"DLIBs\") are tracked by a DLIB ZONE of SMP/E.\nWorking system libraries are tracked by a TARGET ZONE of SMP/E that\nis PAIRED with the DLIB ZONE.  The JCLIN for building a product is\nalso stored in the TARGET ZONE for that product.\n\n      SMP/E (as did old SMP) provides a mechanism to directly alter\nits control entries.  This mechanism is called \"UCLIN\".  Through\nUCLIN, adjustments can be made by the programmer as necessary to\nmanually control SMP processes.  Under SMP/E, A \"SET BDY\" (set boundary)\ncommand directs the action of the UCLIN to the one particular ZONE\nwhose entries are to be adjusted.\n\n      It follows that WE CAN COMPLETELY BUILD A PRODUCT from the\nfollowing ingredients:  First, we need a complete collection of the\nphysical elements.  These are stored in the appropriate DLIBs for the\nproduct.  We need records of these elements for our FMID(s) out of\nSMP/E.  Those can be obtained through the \"UNLOAD\" facility of SMP/E,\nwhich can dump all element records in UCLIN format out of either the\nDLIB ZONE or the TARGET ZONE.  UCLIN format is directly used as input\nto SMP/E, to construct corresponding new element entries in a new\nZONE.  Second, we need the source of JCLIN--the JCL stream needed to\nconstruct the working parts out of the distributed software pieces.\nThat JCLIN source is supplied by running an SMP/E GENERATE job against\nan installed TARGET ZONE for the FMID(s) of our product(s).  The\nequivalent of the originating JCL input stream is then created.\n\n      It is these ingredients that we will use to construct a VTAM\n2.2 installation in the SMP/E setting of our new XA 2.2.3 system.\nThe parts for the new installation will come from the VTAM 2.2\nproduct that we already have, which was installed by SMP/E on the\nMVS/370 system.\n\n\nWHAT TO DO.\n\n      See the SIDEBAR for an outline of the steps that should be\nfollowed.  An elaboration on the details, the \"extra care\" items, and\none or two \"gotchas\" will follow in next month's issue.  Meanwhile,\nsomeone wishing to actually DO this kind of stuff, can get it done\nfrom the SIDEBAR outline.  If you need more help, the magazine editors\nwill gladly supply you with my phone number.\n\n      Good luck.  See you next month.\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nSIDEBAR.      Procedure steps to accomplish the replacement of VTAM 3.2\n               on an MVS/XA system with VTAM 2.2 transplanted from our\n               previous MVS/370 system.\n\n\n      1.  Do ACCEPT processing on the 370 system for all HVT2202 PTFs\n            that have been APPLYed.  This will load the DLIBs with the\n            VTAM 2.2 elements at the highest \"clean\" levels.\n\n      2.  Back up all disk packs involved.  (This goes without saying.)\n\n      3.  UNLOAD from the old system:  the DLIB zone FORFMID(HVT2202)\n            and the TARGET zone FORFMID(HVT2202).  See Figure One.\n\n      3A. Optionally do the same FORFMID(HVT3205,JVT3125) off the\n            new system, just to have the decks for reference.  In\n            our case these decks will not be used.\n\n      4.  Run GENERATE FORFMID(HVT2202) from the MVS/370 system.\n            See Figure Two for an example.\n\n      5.  Run GENERATE FORFMID(HVT3205,JVT3215) from the XA system.\n            See Figure Three.\n\n      6.  Create a dummy FUNCTION to run on the XA system, that will\n            DELETE(HVT3205,JVT3215).  Call this FUNCTION DELVT32.\n            This FUNCTION will actually be APPLYed and ACCEPTed.\n            Figure Four will show an example.\n\n      7.  Create a dummy FUNCTION to run on the 370 system, that will\n            DELETE(HVT2202).  Call this FUNCTION DELVT22.  This\n            FUNCTION will only be APPLY CHECKed.  DON'T APPLY IT--\n            PLEASE!!  REJECT it as soon as you've finished with it,\n            just to be safe.  The ELEMENT report from the APPLY\n            CHECK listing for this FUNCTION will be used to create\n            a COPY JOB to copy all DLIB elements from the old\n            system's DLIBs to the new system's DLIBs.\n\n      8.  Create the COPY JOB for the DLIB elements by either editing\n            the APPLY CHECK report for DELVT22, or by using my COBOL\n            program GIMELMNQ as a service aid.  GIMELMNQ is not publicly\n            distributed yet.  Figure Five shows the output it produces.\n\n      9.  APPLY and ACCEPT the delete FUNCTION DELVT32 on the new XA\n            system.  SAVE THE REPORTS.  The utility report for the\n            APPLY will contain crucial linkedits.\n\n     10.  Use UCLIN to delete the SYSMOD entry for HVT2202 in both the\n            TARGET and DLIB zones of the new system.  This entry had\n            been marked as deleted by HVT3205, and it must be gotten\n            rid of in both zones of the XA SMP/E system.\n\n            DEL SYSMOD(HVT2202) .\n\n            is the UCLIN statement required in both zones.\n\n *** 11.  Edit the GENERATE jobs for both VTAMs to produce one correct\n            hybrid deck that we will actually use.  Details will follow\n            on how to do this.  This step is the heart of the matter.\n            See Figures Six and Seven.\n          The general rule is:  Self-contained VTAM modules follow\n            the OLD (2.2) pattern.  Modules interfacing with other\n            components follow the NEW (3.2) pattern.\n\n     12.  Copy all HVT2202 ELEMENTs (and their aliases, if any) from\n            the \"370\" DLIBs to the XA DLIBs.  The XA DLIBs have now\n            been stripped of VTAM elements by the ACCEPT of DELVT32.\n            Figure Eight shows a part of my copy job created for this\n            step.\n\n     13.  Actually run the hybrid GENERATE copy job and linkedit jobs\n            that you had created in Step 11.  This will load the\n            TARGET libraries with the correct load modules.\n\n     14.  Now bring SMP/E into sync.  UCLIN the DLIB UNLOAD of HVT2202\n            into the DLIB ZONE of the XA system.  UCLIN the TARGET LIB\n            UNLOAD of HVT2202 into the TARGET ZONE of the XA system.\n            Then JCLIN the hybrid GENERATE deck into the XA system.\n            Figures Nine and Ten illustrate these processes.\n\n     15.  Check all jobs for clean return codes, and fix all errors,\n            if any.  Move the modules to an IPL-able pack, and IPL.\n            We should have a \"runnable\" installed product at this\n            stage.  Voila.\n\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n\nFIGURE ONE.   SMP/E UNLOAD of VTAM Release 2.2 DLIB Zone Entries and\n               TARGET Zone Entries, to be transported to XA DLIB\n               Zone and XA TARGET Zone, respectively.\n\n\n//TSTB#SG$ JOB (TS,2322),'TECH.SUPP-SAM.GOLOB',CLASS=M,NOTIFY=TSTBSSG,\n//        MSGLEVEL=(1,1),MSGCLASS=T\n//******************************************************************//\n//*   SMP/E  -  UNLOAD JOB  -  HVT2202 DLIB Zone and TARGET Zone   *//\n//******************************************************************//\n//*\n//UNLOADDL EXEC SMPEMVS1,AC=        <===  MVS/370 SMP/E Procedure\n//SMPCNTL  DD  *\n      SET BDY(MVSDLB).\n      UNLOAD FORFMID(HVT2202).\n/*\n//SMPPUNCH DD DISP=(NEW,CATLG,DELETE),UNIT=3380,VOL=SER=WORK02,\n//         SPACE=(TRK,(120,300),RLSE),DSN=TST.DLIB.UNLOAD.HVT2202,\n//         DCB=(RECFM=FB,DSORG=PS,LRECL=80,BLKSIZE=11440)\n//*\n//* ------------------------------------------------------------ *//\n//*\n//UNLOADTG EXEC SMPEMVS1,AC=        <===  MVS/370 SMP/E Procedure\n//SMPCNTL  DD  *\n      SET BDY(MVSTGT).\n      UNLOAD FORFMID(HVT2202).\n/*\n//SMPPUNCH DD DISP=(NEW,CATLG,DELETE),UNIT=3380,VOL=SER=WORK02,\n//         SPACE=(TRK,(120,300),RLSE),DSN=TST.TARGET.UNLOAD.HVT2202,\n//         DCB=(RECFM=FB,DSORG=PS,LRECL=80,BLKSIZE=11440)\n\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n\nFIGURE TWO.   SMP/E GENERATE Command execution to reconstruct the\n              JCLIN that is needed to build the VTAM 2.2 TARGET\n              Libraries in an MVS/370 setting.\n\n\n//TSTB$MO$ JOB (TS,2322),'TECH.SUPP-MARIANNE',CLASS=M,NOTIFY=TSTBSSG,\n//        MSGLEVEL=(1,1),MSGCLASS=T TYPRUN=HOLD\n//*\n//* LIB: TSX1.INSTLIB(MVSGEN)\n//* GDE: CBIPO MVS INSTALLATION\n//* DOC: THIS JOB EXECUTES THE GENERATE COMMAND OF SMP/E TO CREATE\n//*      THE JOBS THAT CONSTRUCT THE TARGET SYSTEM LIBRARIES.  THE\n//*      GENERATE COMMAND CREATES THE JOB STREAM TO THE SMPPUNCH\n//*      FILE.  IN OUR CASE THIS IS DONE ONLY FOR FMID HVT2202.\n//*\n//*      THE JOBSTREAM PRODUCED BY THE GENERATE COMMAND IS\n//*      SEPARATED INTO TWO PARTS: THE FIRST, V22GEN1, IS A JOB\n//*      TO PERFORM IEBCOPY OF DLIB MEMBERS.  IT MUST COMPLETE\n//*      BEFORE THE SECOND HALF, V22GEN2, IS RUN.\n//*\n//GENERA1 EXEC SMPEMVS1,REGION=6144K,AC=   <=== MVS/370 SMP/E Procedure\n//SMPCNTL  DD  *\n  SET BOUNDARY(MVSTGT) .\n  GENERATE FORFMID(HVT2202)\n  JOBCARD(SMPGENL,JOBCARD) .\n/*\n//SMPPUNCH DD  DSN=&&JOBS,DISP=(NEW,PASS),\n//             SPACE=(6160,(300,200)),UNIT=SYSALLDA,\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160,DSORG=PS)\n//SMPGENL  DD  DSN=TSX1.GENLIB,DISP=SHR,\n//             UNIT=3380,VOL=SER=VEND02\n//*\n//SPLIT3  EXEC PGM=IEBGENER,                <=== Split Output into\n//             REGION=512K                  <=== COPY and LNKEDIT\n//SYSPRINT DD  SYSOUT=*                     <=== Parts.\n//SYSUT1   DD  DSN=&&JOBS,DISP=(OLD,PASS)\n//SYSUT2   DD  DSN=TSX1.INSTLIB,DISP=SHR,\n//             UNIT=3380,VOL=SER=VEND02\n//SYSIN    DD  *\n  GENERATE MAXNAME=2,MAXGPS=1\n  MEMBER   NAME=V22GEN1\n  RECORD   IDENT=(8,'//******',1)\n  MEMBER   NAME=V22GEN2\n/*\n//\n\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n\nFIGURE THREE.  SMP/E GENERATE Command execution to reconstruct the\n               JCLIN that is needed to build the VTAM 3.2 TARGET\n               Libraries in an MVS/XA 2.2.3 setting.\n\n\n//TSTB$MO$ JOB (TS,2322),'TECH.SUPP-MARIANNE',CLASS=M,NOTIFY=TSTBSSG,\n//        MSGLEVEL=(1,1),MSGCLASS=T TYPRUN=HOLD\n//*\n//* LIB: TSX1.INSTLIB(MVSGEN)\n//* GDE: CBIPO MVS INSTALLATION\n//* DOC: Generate Job for VTAM 3.2 on the MVS/XA SMP/E system.\n//*\n//GENERA1 EXEC SMPEMXA,REGION=6144K,AC=    <=== MVS/XA SMP/E Procedure\n//SMPCNTL  DD  *\n  SET BOUNDARY(M22TGT) .\n  GENERATE FORFMID(HVT3205,JVT3215)\n  JOBCARD(SMPGENL,JOBCARD) .\n/*\n//SMPPUNCH DD  DSN=&&JOBS,DISP=(NEW,PASS),\n//             SPACE=(6160,(300,200)),UNIT=3380,\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160,DSORG=PS)\n//SMPGENL  DD  DSN=TSX1.GENLIB,DISP=SHR\n//*\n//SPLIT3  EXEC PGM=IEBGENER,               <=== Split output into\n//             REGION=512K                 <=== COPY and LINKEDIT\n//SYSPRINT DD  SYSOUT=*                    <=== Parts.\n//SYSUT1   DD  DSN=&&JOBS,DISP=(OLD,PASS)\n//SYSUT2   DD  DSN=TSX1.INSTLIB,DISP=SHR\n//SYSIN    DD  *\n  GENERATE MAXNAME=2,MAXGPS=1\n  MEMBER   NAME=V32GEN1\n  RECORD   IDENT=(8,'//******',1)\n  MEMBER   NAME=V32GEN2\n/*\n//\n\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n\nFIGURE FOUR.   Illustration of DUMMY FMID DELVT32 which is used to\n               delete VTAM 3.2 from the MVS/XA SMP/E system.\n\n\n++FUNCTION (DELVT32).\n++VER(Z038)\n /*\n     DELETES VTAM 3.2 FUNCTIONS  WHICH  CAME  WITH THE  CBIPO  FOR\n     MVS/XA 2.2.3, BUT WHICH WE DO NOT INTEND TO RUN IN PRODUCTION.\n\n     S. GOLOB - 04/03/90\n */\n    DELETE(\n      HVT3205\n      JVT3215\n      ).\n\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n\nFIGURE FIVE.   Illustration of output from my GIMELMNQ Service Aid\n               which produces the following ELEMENT listing from an\n               SMP/E APPLY CHECK of the DELVT22 FUNCTION.  This listing\n               is sorted by the DLIB name in columns 44-51 and edited\n               to produce IEBCOPY SELECT MEMBER statements.  After\n               I have made sure that these members have no ALIASES,\n               this IEBCOPY job is used to accurately move all DLIB\n               members from the MVS/370 DLIBs to the MVS/XA DLIBs.\n\n\n AMDUSRFD /*MOD   DELETED                  AOS24                     */\n CHANGE   /*MAC   DELETED                  AMACLIB                   */\n CLSDST   /*MAC   DELETED                  AMACLIB                   */\n COS      /*MAC   DELETED                  AMACLIB                   */\n       ------------    DATA  MISSING  FOR  BREVITY    -----------\n GTDEVSIZ /*MAC   DELETED                  ATSOMAC                   */\n IHASU1   /*MAC   DELETED                  AMODGEN                   */\n IHASU34  /*MAC   DELETED                  AMODGEN                   */\n IHASU35  /*MAC   DELETED                  AMODGEN                   */\n IHASU40  /*MAC   DELETED                  AMODGEN                   */\n IHASU54  /*MAC   DELETED                  AMODGEN                   */\n IHBRDWRA /*MAC   DELETED                  AMACLIB                   */\n IKTASCII /*MOD   DELETED                  AOST3                     */\n IKTASTPT /*MOD   DELETED                  AOST3                     */\n       ------------    DATA  MISSING  FOR  BREVITY    -----------\n IKT3270O /*MOD   DELETED                  AOST3                     */\n IKT3767I /*MOD   DELETED                  AOST3                     */\n IKT3767O /*MOD   DELETED                  AOST3                     */\n IKT93EST /*MOD   DELETED                  AOST3                     */\n INQUIRE  /*MAC   DELETED                  AMACLIB                   */\n INTAB    /*MAC   DELETED                  AMACLIB                   */\n INTRPRET /*MAC   DELETED                  AMACLIB                   */\n ISTACBEX /*MAC   DELETED                  AMACLIB                   */\n ISTACB1  /*MAC   DELETED                  AMACLIB                   */\n ISTACCAN /*MOD   DELETED                  AOS26                     */\n ISTACCAP /*MOD   DELETED                  AOS26                     */\n       ------------    DATA  MISSING  FOR  BREVITY    -----------\n\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9009SE": {"ttr": 6915, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x93!\\x0f\\x00\\x950_\\x17#\\x02\\xe8\\x02\\xe8\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "1995-11-01T17:23:00", "lines": 744, "newlines": 744, "modlines": 0, "user": "SBGCSC"}, "text": "\n                MVS TOOLS AND TRICKS OF THE TRADE\n                         September 1990\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n\n\n      This month, I'd like to continue with last month's topic that\nwe had to split between two issues.  I personally do not like to split\na topic.  Our column has two specific goals at all times.  I feel that\na division of one topic into two pieces must not interfere with these\ntwo central goals that we have set.\n\n      First goal:  this column is here to provide self-contained\nsolutions to specific problems.  If a reader picks up an issue of the\nmagazine that has the second installment of a split, there is the\ndanger that he or she might be missing essential information that was\nin the first installment.  Thus, our objective of providing \"the\npractical and whole solution\" would not be achieved properly.  I\nbelieve that in our specific case, we have minimized this problem.\n\n      The second goal of the column is:  THAT ANY SYSTEMS PROGRAMMER\nFROM ANY MVS SHOP SHOULD BE ABLE TO GAIN SOMETHING FROM LOOKING AT THIS\n\"MVS TOOLS\" COLUMN, ANY MONTH.  To illustrate, this goal made a\ndifference during the month we talked about spool browsing tools.  I\nmentioned SDSF and the QUEUE and IOF products for JES2, but our goal\nrequired that we shouldn't exclude programmers from the JES3 shops.\nTherefore I was forced to write about the magnificent JES3 \"Spool\nDisplay Facility\" product, which is available for FREE on the JES3\nSHARE Tape (from Alan Field, (612) 828-4979.)  Sticking to this\nrequirement as much as possible, is part of our public service.\n\n      Now, let's return to the topic at hand.  We began last month,\nto explain how to regress a \"too high\" version of VTAM from our new\nCBIPO-generated MVS/XA 2.2.3 system.  Our shop needed to use the\nversion of VTAM that we had on our old MVS/370 1.3.5 system.  We knew,\nby asking IBM, that the older version would also run under XA 2.2.3.\nWe were not willing to pay the extra money for a newer version of\nVTAM.  IBM refused to ship us the older VTAM with the CBIPO.  The\nolder VTAM was still supported, however.\n\n      Our problem was to first install the CBIPO with a newer VTAM\non free trial, and then remove the new VTAM to replace it with the\nVTAM version from our old MVS/370 system.\n\n      Why would a programmer at a \"richer\" shop want to know this\nstuff?  I've chosen to write about such SMP activity, because I feel\nthat the skills required in performing this action are a necessary\npart of the MVS system programmer's repertoire.  One has to know how\ndifferent components interface with the operating system as a whole.\nThe activity of \"regressing releases\" of a component such as VTAM\nlends invaluable insight into its interfacing structure.  Regressing\nis a better learning experience than merely installing, SIMPLY BECAUSE\nIT IS NOT AUTOMATIC, the way a straight install would be.  One learns\na lot more through the manual intervention.\n\n      At this point we should state that a knowledgeable reader of\nEITHER last month's or this month's issue can actually accomplish the\nentire procedure by himself.  A reader of last month's installment\ncould see THE ENTIRE PROCEDURE IN OUTLINE FORM, BY LOOKING AT THE\nSIDEBAR ILLUSTRATION.  The text of last month's column served to\nprovide an explanation of the underlying fundamental principles.  THE\nSAME SIDEBAR ILLUSTRATION IS ALSO PRINTED THIS MONTH, but the\naccompanying text and further figures will explain specific details of\nthe procedure, plus the few \"gotchas\" to watch for in carrying it out.\nThe complete story is told in both issues taken together, but a full\noutline of steps has been included in either issue separately.\n\n      So, we can resume our discussion where we left it last time.\n\n\nWHAT HAD TO BE DONE?\n\n      We start our scene with two sets of SMP/E zones and the libraries\nthey control.  One set is our old MVS/370 system, and the other set is\nour new MVS/XA CBIPO-installed system.  VTAM 2.2 (fmid HVT2202) is\ninstalled on the MVS/370 system.  VTAM 3.2 (fmids HVT3205 and JVT3215)\nis installed on the MVS/XA system.  Our job is to transplant VTAM 2.2\nfrom the MVS/370 system to the MVS/XA system after having gotten rid\nof VTAM 3.2 first.\n\n      We stated last time that there are physical modules belonging\nto each VTAM version.  These are stored in libraries.  There are\ncorresponding SMP/E control entries in the SMP/E VSAM \"zones\".  Their\npurpose is to account for each piece, or element, of the VTAM\ncomponent in each SMP environment.  Both the physical VTAM modules and\ntheir SMP/E control counterparts must be faithfully transplanted from\nthe 370 environment to the XA environment.  We must make sure that\nVTAM 2.2 will work as IBM designed it to work under XA, and its SMP/E\ncontrol entries appear as though they were installed together with XA.\n\n      The process is complicated by the fact that VTAM is not a\nstand-alone product; it interfaces with other components of the\noperating system.  Those components, and the way they fit together,\nare different in MVS/370 and in MVS/XA.\n\n      We must therefore decide how the old VTAM 2.2 should interact\nwith the new MVS/XA components.\n\n      Our method of action may be summarized by the following\nprinciple:  Any stand-alone \"pure VTAM\" load module will have the same\nstructure under XA as it had under 370.  This is because that piece\nDOES NOT INTERACT with non-VTAM components which have changed.  On\nthe other hand, any part of VTAM which is linkedited together with\nnon-VTAM components THAT MAY HAVE CHANGED FROM MVS/370 TO XA, should\nhave its corresponding pieces from VTAM 2.2 FITTED INTO THE NEW\nLINKEDIT PATTERN.  This is so that the rest of the operating system\ncomponents, exclusive of the VTAM part, may behave exactly as they had\nbehaved before the transplant.\n\n\nHOW DID WE ACTUALLY DO IT?\n\n      The key to our actions is in the SIDEBAR outline.  There are\nfifteen general steps to the procedure.  These steps can be followed\nas stated.  The rest of this article will merely supply \"fill-in\"\ndetails and comments, as we feel they are needed for clarity.\n\n      Step 1, ACCEPT processing on the old system, may have to be\ndone.  The transplanted VTAM component will be constructed from\nelements in the distribution libraries, so these must be at\nmaintenance levels consistent with the level of the target libraries.\nIf necessary, we must run an ACCEPT job on the old system.  This will\nmake sure that the distribution libraries have their building blocks\nat a level consistent with the level of the working target library\nsystem.\n\n      Step 2, creating pack backups and/or dataset backups, is always\nsound policy when dealing with SMP-controlled systems.  One should\nback up both the 370 and the XA SMP environments.  Probably, full pack\nbackups are the easiest to restore if needed.\n\n      Steps 3 and 3A, SMP/E \"UNLOAD\" processing, put the SMP/E element\nstructure of the respective VTAM versions into transportable form.\nThe actual zone entries are reduced to UCLIN statements that can be\nreloaded into another SMP/E zone later.  All this is accomplished by\nthe SMP/E UNLOAD process, as directed to the entries in each zone, for\nthe respective VTAM fmids.  Please note that since we are moving the\nVTAM 2.2 entries, we do not really need the VTAM 3.2 entries.  But it\nis best to have them for safety, since after VTAM 3.2 is deleted,\ntheir source will be gone.\n\n      Steps 4 and 5 need to be detailed more.  The output of the\nSMP/E GENERATE in the case of VTAM consists of two parts:  a COPY\npart and a LINKEDIT part.  Further, the LINKEDIT part is broken into\nseveral JOBS, each of which updates ONE LIBRARY only, such as LINKLIB,\nLPALIB, NUCLEUS, and VTAMLIB.  There's a small \"gotcha\" here.  In\norder for the GENERATE job to produce proper DDNAMES for its output\njobstream, all DDNAMES have to have been defined to each zone by means\nof DDDEFs.  Defining the DDNAMES in a hard-coded JCL \"SMP procedure\"\nwill not work.  GENERATE can only formulate DD statements out of the\nDDDEF entries in the ZONE.  Fortunately, it is quick and easy to\nconstruct a batch job that will accurately define necessary DDDEF\nentries in each ZONE (via UCLIN).\n\n      After the GENERATE jobs in Steps 4 and 5 have been run, two\nsets of two decks should be available:  a COPY stream and a LINKEDIT\nstream from the old VTAM (HVT2202), and a COPY stream and LINKEDIT\nstream from the new VTAM (HVT3205 and JVT3215).  In step 11, which\nis the crucial step, we shall produce a combined COPY deck merged from\nBOTH COPY DECKS.  We shall also produce a combined LINKEDIT deck made\nout of pieces of both LINKEDIT decks.\n\n      Now look at Figure Four which shows the dummy FUNCTION DELVT32\nthat will delete both FMIDs for VTAM 3.2.  This FUNCTION, when APPLYed,\nwill delete all VTAM-based elements (modules) from the entire operating\nsystem, wherever they reside in the TARGET libraries.  In the APPLY\nutility report for DELVT32, LINKEDIT output showing REPLACE cards for\nthe VTAM modules in IEANUC01, SVCs 34, 93, and 94, and other mixed-FMID\nload modules will appear.  Examination of equivalent VTAM 2.2 modules\nwill show that identical module names from the earlier VTAM release\ncould slip into all of the old VTAM module slots in the mixed-FMID load\nmodules.  (It helps to have this information for the crucial Step 11\nlater.)\n\n      ACCEPT processing for DELVT32 will wipe the XA DLIBs completely\nbare of all VTAM modules.  These VTAM modules will be the release 3.2\nversions.  Keep this ACCEPT report around, but it is not needed\nas much as the APPLY report for our purposes.\n\n      I did Step 7 to guarantee that I'd copy ALL the necessary DLIB\nmembers for VTAM 2.2 from the 370 system DLIBs to the XA DLIBs.  My\nmethod for accomplishing this has its dangerous aspects, and there\nis probably a better way.  I'd appreciate if a reader would inform\nme of an better method of determining exactly the correct DLIB elements,\ndiscovering possible ALIAS conditions, and accomplishing the physical\ntransfer exactly.  I'm about to submit a SHARE requirement to SMP/E\ndevelopment so that SMP/E itself might be made to produce its own\n\"FORFMID library reports\" in the future.\n\n      Step 7 involves doing an APPLY CHECK of a dummy FUNCTION\nDELVT22.  This FUNCTION is RECEIVEd in the 370 SMP GLOBAL ZONE.  It\naims to delete VTAM 2.2 (HVT2202) and is therefore dangerous.  It\nmust not be run for real.  Its purpose is to obtain a list of all\nelement names in HVT2202, together with the name of the DLIB that\neach element resides in.\n\n      This is of course, a fake delete.  A real delete of VTAM 2.2\nwould be disastrous.  Figure Six shows part of a copy job which I\nderived from this report.  This job copies exactly the correct\nelements from the 370 DLIBs to the XA DLIBs.  Remember though, that\nSMP ELEMENT listings do not show any aliases, and the presence of\naliases must be determined by other methods.  I used the \"PDS\" product\nto make sure that none of the DLIBs had alias members that belonged to\nVTAM 2.2.  I did this by making a member list under ISPMODE consisting\nof the VTAM 2.2 modules for each DLIB, and then entering option \"5\"\nfrom the PDS(/E) memlist.  This picks up all aliases of members in the\ngroup, if any.  In our case there were none.  Look also at Figure\nFive.\n\n      Step 9 actually deletes VTAM 3.2 from the XA system.  As I stated,\nthe most important report produced is the utility report from the APPLY\njob, which has the linkedits of the load modules with \"mixed FMID\".\n\n      Step 10 has to be done so the UNLOAD UCLIN from the 370 DLIB\nand TARGET ZONES will slip smoothly into the XA DLIB and TARGET ZONES.\nIn the XA system, there is a SYSMOD entry for HVT2202 in both the\nTARGET ZONE and the DLIB ZONE showing HVT2202 as having been deleted\nby HVT3205.  These \"bad\" SYSMOD entries must be deleted with UCLIN, so\nthat the real SYSMOD entries for the actual FUNCTION HVT2202 can be\ninserted later.\n\n      Step 11 is the most crucial step.  The problem is to determine\nhow a VTAM 2.2 install would have fitted into the XA system.  The main\nprinciple to follow is this:  VTAM 2.2 load modules which stand alone,\nand are not mixed with modules from any other FMID, will go into the\nnew system as they went into the old one.  Therefore \"pure\" VTAM 2.2\nJCLIN comes only from the 2.2 GENERATE output.  The \"mixed FMID\" JCLIN\nhas to look like the 3.2 GENERATE output, because that output will\nreflect both the MVS/XA system load modules and the higher version of\nTSO/E in the XA system.  Therefore, I spliced the two sets of decks\ntogether cautiously and carefully according to this principle.  Again,\nsee Figures Six and Seven.  The pieces of linkedit GENERATE coming\nfrom the NEW system should correspond exactly with the APPLY utility\nreport that deleted VTAM 3.2 from the NEW system.  The rest should\ncome from the OLD system.\n\n      In Step 12 I physically copied the VTAM 2.2 elements from 370\nDLIBs to the now stripped XA DLIBs.  In Step 13 I ran the actual hybrid\nCOPY and LINKEDIT decks to create the TARGET modules out of the DLIB\nmodules.  This created the physical modules for VTAM 2.2 within the XA\nsystem, and the XA libraries would actually be usable in an IPL at\nthis stage.  But SMP in the XA system would not yet know about VTAM\n2.2.\n\n      Step 14 would now have to be carried out to load SMP with VTAM\n2.2 information.  The UCLIN-format module information from the DLIB\nZONE UNLOAD from 370, is now UCLINed into the DLIB ZONE of the XA SMP\nsystem.  Similarly, the UNLOAD deck from the old TARGET system is\nUCLINed into the XA TARGET ZONE to inform it about all of its VTAM 2.2\nelements.  Finally our composite hybrid GENERATE deck reflecting how\nthe VTAM 2.2 load modules will fit into XA, is JCLINed into the XA\nTARGET ZONE.  The JCLIN processing will inform SMP about the linkedit\nstructure of all load modules involving VTAM-owned parts.  At this\npoint, SMP in the XA system now \"knows\" about VTAM 2.2 at its present\nmaintenance level.\n\n      You must check carefully for errors at each step and fix them\nas they occur.  I had to revise some of my original methods because\nof errors that occurred while those things were being done.\n\n      Well that's about it for now.  Ponder these items carefully.\nThey take a good deal of thought to understand properly.\n\n      Good luck.  See you next month.\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nSIDEBAR.      Procedure steps to accomplish the replacement of VTAM 3.2\n               on an MVS/XA system with VTAM 2.2 transplanted from our\n               previous MVS/370 system.\n\n\n      1.  Do ACCEPT processing on the 370 system for all HVT2202 PTFs\n            that have been APPLYed.  This will load the DLIBs with the\n            VTAM 2.2 elements at the highest \"clean\" levels.\n\n      2.  Back up all disk packs involved.  (This goes without saying.)\n\n      3.  UNLOAD from the old system:  the DLIB zone FORFMID(HVT2202)\n            and the TARGET zone FORFMID(HVT2202).  See Figure One.\n\n      3A. Optionally do the same FORFMID(HVT3205,JVT3125) off the\n            new system, just to have the decks for reference.  In\n            our case these decks will not be used.\n\n      4.  Run GENERATE FORFMID(HVT2202) from the MVS/370 system.\n            See Figure Two for an example.\n\n      5.  Run GENERATE FORFMID(HVT3205,JVT3215) from the XA system.\n            See Figure Three.\n\n      6.  Create a dummy FUNCTION to run on the XA system, that will\n            DELETE(HVT3205,JVT3215).  Call this FUNCTION DELVT32.\n            This FUNCTION will actually be APPLYed and ACCEPTed.\n            Figure Four will show an example.\n\n      7.  Create a dummy FUNCTION to run on the 370 system, that will\n            DELETE(HVT2202).  Call this FUNCTION DELVT22.  This\n            FUNCTION will only be APPLY CHECKed.  DON'T APPLY IT--\n            PLEASE!!  REJECT it as soon as you've finished with it,\n            just to be safe.  The ELEMENT report from the APPLY\n            CHECK listing for this FUNCTION will be used to create\n            a COPY JOB to copy all DLIB elements from the old\n            system's DLIBs to the new system's DLIBs.\n\n      8.  Create the COPY JOB for the DLIB elements by either editing\n            the APPLY CHECK report for DELVT22, or by using my COBOL\n            program GIMELMNQ as a service aid.  GIMELMNQ is not publicly\n            distributed yet.  Figure Five shows the output it produces.\n\n      9.  APPLY and ACCEPT the delete FUNCTION DELVT32 on the new XA\n            system.  SAVE THE REPORTS.  The utility report for the\n            APPLY will contain crucial linkedits.\n\n     10.  Use UCLIN to delete the SYSMOD entry for HVT2202 in both the\n            TARGET and DLIB zones of the new system.  This entry had\n            been marked as deleted by HVT3205, and it must be gotten\n            rid of in both zones of the XA SMP/E system.\n\n            DEL SYSMOD(HVT2202) .\n\n            is the UCLIN statement required in both zones.\n\n *** 11.  Edit the GENERATE jobs for both VTAMs to produce one correct\n            hybrid deck that we will actually use.  Details will follow\n            on how to do this.  This step is the heart of the matter.\n            See Figures Six and Seven.\n          The GENERAL RULE:  Self-contained VTAM modules follow the\n            old (2.2) pattern while modules interfacing with other\n            components follow the new (3.2) pattern.\n\n     12.  Copy all HVT2202 ELEMENTs (and their aliases, if any) from\n            the \"370\" DLIBs to the XA DLIBs.  The XA DLIBs have now\n            been stripped of VTAM elements by the ACCEPT of DELVT32.\n            Figure Eight shows a part of my copy job created for this\n            step.\n\n     13.  Actually run the hybrid GENERATE copy job and linkedit jobs\n            that you had created in Step 11.  This will load the\n            TARGET libraries with the correct load modules.\n\n     14.  Now bring SMP/E into sync.  UCLIN the DLIB UNLOAD of HVT2202\n            into the DLIB ZONE of the XA system.  UCLIN the TARGET LIB\n            UNLOAD of HVT2202 into the TARGET ZONE of the XA system.\n            Then JCLIN the hybrid GENERATE deck into the XA system.\n            Figures Nine and Ten illustrate these processes.\n\n     15.  Check all jobs for clean return codes, and fix all errors,\n            if any.  Move the modules to an IPL-able pack, and IPL.\n            We should have a \"runnable\" installed product at this\n            stage.  Voila.\n\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n\nFIGURE FOUR.   Illustration of DUMMY FMID DELVT32 which is used to\n               delete VTAM 3.2 from the MVS/XA SMP/E system.\n\n\n++FUNCTION (DELVT32).\n++VER(Z038)\n /*\n     DELETES VTAM 3.2 FUNCTIONS  WHICH  CAME  WITH THE  CBIPO  FOR\n     MVS/XA 2.2.3, BUT WHICH WE DO NOT INTEND TO RUN IN PRODUCTION.\n\n     S. GOLOB - 04/03/90\n */\n    DELETE(\n      HVT3205\n      JVT3215\n      ).\n\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n\nFIGURE FIVE.   Illustration of output from my GIMELMNQ Service Aid\n               which produces the following ELEMENT listing from an\n               SMP/E APPLY CHECK of the DELVT22 FUNCTION.  This listing\n               is sorted by the DLIB name in columns 44-51 and edited\n               to produce IEBCOPY SELECT MEMBER statements.  After\n               I have made sure that these members have no ALIASES,\n               this IEBCOPY job is used to accurately move all DLIB\n               members from the MVS/370 DLIBs to the MVS/XA DLIBs.\n\n\n AMDUSRFD /*MOD   DELETED                  AOS24                     */\n CHANGE   /*MAC   DELETED                  AMACLIB                   */\n CLSDST   /*MAC   DELETED                  AMACLIB                   */\n COS      /*MAC   DELETED                  AMACLIB                   */\n       ------------    DATA  MISSING  FOR  BREVITY    -----------\n GTDEVSIZ /*MAC   DELETED                  ATSOMAC                   */\n IHASU1   /*MAC   DELETED                  AMODGEN                   */\n IHASU34  /*MAC   DELETED                  AMODGEN                   */\n IHASU35  /*MAC   DELETED                  AMODGEN                   */\n IHASU40  /*MAC   DELETED                  AMODGEN                   */\n IHASU54  /*MAC   DELETED                  AMODGEN                   */\n IHBRDWRA /*MAC   DELETED                  AMACLIB                   */\n IKTASCII /*MOD   DELETED                  AOST3                     */\n IKTASTPT /*MOD   DELETED                  AOST3                     */\n       ------------    DATA  MISSING  FOR  BREVITY    -----------\n IKT3270O /*MOD   DELETED                  AOST3                     */\n IKT3767I /*MOD   DELETED                  AOST3                     */\n IKT3767O /*MOD   DELETED                  AOST3                     */\n IKT93EST /*MOD   DELETED                  AOST3                     */\n INQUIRE  /*MAC   DELETED                  AMACLIB                   */\n INTAB    /*MAC   DELETED                  AMACLIB                   */\n INTRPRET /*MAC   DELETED                  AMACLIB                   */\n ISTACBEX /*MAC   DELETED                  AMACLIB                   */\n ISTACB1  /*MAC   DELETED                  AMACLIB                   */\n ISTACCAN /*MOD   DELETED                  AOS26                     */\n ISTACCAP /*MOD   DELETED                  AOS26                     */\n       ------------    DATA  MISSING  FOR  BREVITY    -----------\n\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n\nFIGURE SIX.   Hybrid IEBCOPY Job that was created out of the GENERATE\n              against VTAM 2.2 and the GENERATE against VTAM 3.2.\n              VTAM 2.2 was used for most of the \"combined\" job, except\n              for copies from AMODGEN to the new TARGET macro library,\n              MODGEN.\n\n\n//TSTBCOPY JOB (TS,2322),'MARIANNE',\n//             NOTIFY=TSTBSSG,\n//             CLASS=M,MSGCLASS=T,MSGLEVEL=(1,1)               /*LREG*/\n//*\n//JOBLIB   DD  DSN=TSX1.LINKLIB,DISP=SHR,\n//             UNIT=3380,VOL=SER=VEND02\n//COPYSTEP EXEC PGM=IEBCOPY                                              EXECCPY\n//SYSUT3   DD UNIT=SYSDA,                                               SYSUT3\n//            SPACE=(6160,(230,760))                                    SYSUT3\n//SYSUT4   DD UNIT=SYSDA,                                               SYSUT4\n//            SPACE=(6160,(230,760))                                    SYSUT4\n//SYSPRINT DD SYSOUT=*                                                  DEFAULT\n//AMACLIB  DD DSN=TSX1.AMACLIB,                                         AMACLIB\n//            DISP=(SHR)                                                AMACLIB\n//AMODGEN  DD DSN=TSX1.AMODGEN,                                         AMODGEN\n//            DISP=(SHR)                                                AMODGEN\n//ASAMPLIB DD DSN=TSX1.ASAMPLIB,                                        ASAMPLIB\n//            DISP=(SHR)                                                ASAMPLIB\n//ATSOMAC  DD DSN=TSX1.ATSOMAC,                                         ATSOMAC\n//            DISP=(SHR)                                                ATSOMAC\n//VTAMLIB  DD DSN=TSX1.VTAMLIB,                                         ATSOMAC\n//            DISP=(SHR)                                                ATSOMAC\n//LPALIB   DD DSN=TSX1.LPALIB,                                          MACLIB\n//            DISP=(SHR)                                                MACLIB\n//MACLIB   DD DSN=TSX1.MACLIB,                                          MACLIB\n//            DISP=(SHR)                                                MACLIB\n//MODGEN   DD DSN=TSX1.MODGEN,                                          MODGEN\n//            DISP=(SHR)                                                MODGEN\n//SAMPLIB  DD DSN=TSX1.SAMPLIB,                                         SAMPLIB\n//            DISP=(SHR)                                                SAMPLIB\n//AOS24    DD DSN=TSX1.AOS24,                                           SAMPLIB\n//            DISP=(SHR)                                                SAMPLIB\n//AOS26    DD DSN=TSX1.AOS26,                                           SAMPLIB\n//            DISP=(SHR)                                                SAMPLIB\n//SYSIN    DD *                                                         DEFAULT\n  COPY OUTDD=MACLIB,INDD=AMACLIB        TYPE=MAC\n     S M=CHANGE                    FMID=HVT2202\n     S M=CLSDST                    FMID=HVT2202\n     S M=COS                       FMID=HVT2202\n     S M=COSEND                    FMID=HVT2202\n       ------------    DATA  MISSING  FOR  BREVITY    -----------\n     S M=SENDCMD                   FMID=HVT2202\n     S M=SESSIONC                  FMID=HVT2202\n     S M=SETLOGON                  FMID=HVT2202\n     S M=SIMLOGON                  FMID=HVT2202\n     S M=SOLICIT                   FMID=HVT2202\n     S M=STRTMODE                  FMID=HVT2202\n     S M=TERMSESS                  FMID=HVT2202\n     S M=USSCMD                    FMID=HVT2202\n     S M=USSEND                    FMID=HVT2202\n     S M=USSMSG                    FMID=HVT2202\n     S M=USSPARM                   FMID=HVT2202\n     S M=USSTAB                    FMID=HVT2202\n  COPY OUTDD=MACLIB,INDD=ATSOMAC        TYPE=MAC\n     S M=GTDEVSIZ                  FMID=HVT2202\n     S M=IKTTCAST                  FMID=HVT2202\n     S M=IKTTSBX                   FMID=HVT2202\n     S M=IKTTVWA                   FMID=HVT2202\n     S M=STFSMODE                  FMID=HVT2202\n     S M=STLINENO                  FMID=HVT2202\n     S M=STTRAN                    FMID=HVT2202\n  COPY OUTDD=SAMPLIB,INDD=ASAMPLIB      TYPE=SRC\n     S M=ISTINCNO                  FMID=HVT2202\n  COPY OUTDD=LPALIB,INDD=AOS24          TYPE=MOD\n     S M=AMDUSRFD                  FMID=HVT2202\n     S M=ISTORMAF                  FMID=HVT2202\n  COPY OUTDD=VTAMLIB,INDD=AOS26         TYPE=MOD\n     S M=ISTDVCRC                  FMID=HVT2202\n     S M=ISTINCDT                  FMID=HVT2202\n     S M=ISTORFPO                  FMID=HVT2202\n     S M=ISTRACCR                  FMID=HVT2202\n     S M=ISTINCTS                  FMID=HVT2202\n     S M=ISTORFPX                  FMID=HVT2202\n     S M=ISTRACTI                  FMID=HVT2202\n  COPY OUTDD=MODGEN,INDD=AMODGEN        TYPE=MAC   (MODGEN is a new\n     S M=IHASU1                    FMID=HVT3205     library in the\n     S M=IHASU34                   FMID=HVT3205     MVS/XA System.)\n     S M=IHASU35                   FMID=HVT3205\n     S M=IHASU40                   FMID=HVT3205\n     S M=IHASU54                   FMID=HVT3205\n/*\n//******** GENERATE END OF JOB                                          DEFAULT\n\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n\nFIGURE SEVEN.   Part of the \"Hybrid LINKEDIT Job\" constructed from\n                the GENERATE of VTAM 2.2 combined with the GENERATE\n                of VTAM 3.2.  Notice that \"mixed FMID\" linkedits\n                were created from the VTAM 3.2 JCL, whereas all other\n                linkedits were created from VTAM 2.2 JCL.  I was\n                careful to check for the existence in release 2.2\n                of all VTAM module names used in the \"mixed FMID\"\n                linkedit JCL.\n\n\n\n//TSTBLPA  JOB (TS,2322),'MARIANNE',NOTIFY=TSTBSSG,\n//             CLASS=M,MSGCLASS=T,MSGLEVEL=(1,1)               /*LREG*/\n//*\n//JOBLIB   DD  DSN=TSX1.LINKLIB,DISP=SHR,\n//             UNIT=3380,VOL=SER=VEND02\n//LINK0001 EXEC PGM=IEWL,                                                EXECLNK\n//         PARM=('RENT',\n//         'SIZE=(1024K,128K),NCAL,LIST,LET,XREF')\n//SYSPRINT DD SYSOUT=*                                                  DEFAULT\n//SYSLMOD  DD DSN=TSX1.LPALIB,                                          AOS26\n//            DISP=(SHR)                                                AOS26\n//SYSUT1   DD UNIT=SYSDA,                                               SYSUT1\n//            SPACE=(6160,(230,760))                                    SYSUT1\n//AOSB3    DD DSN=TSX1.AOSB3,                                           AOSB3\n//            DISP=(SHR)                                                AOSB3\n//AOST3    DD DSN=TSX1.AOST3,                                           AOST3\n//            DISP=(SHR)                                                AOST3\n//AOS24    DD DSN=TSX1.AOS24,                                           AOS24\n//            DISP=(SHR)                                                AOS24\n//AOS26    DD DSN=TSX1.AOS26,                                           AOS26\n//            DISP=(SHR)                                                AOS26\n//SYSLIN   DD *                                                         DEFAULT\n       ------------    DATA  MISSING  FOR  BREVITY    -----------\n ALIAS IEAVTABG,IEAVTABQ,IEAVTABR\n ALIAS IEAVTRG2,IEAVTRGB,IEDAY802\n ENTRY IEAVTRG2\n  INCLUDE AOST3(IKTAY8)               FMID=HVT3205\n  INCLUDE SYSLMOD(IGC0001C)\n  NAME IGC0001C(R)     <=== This module is mixed FMID!  Notice the (R).\n ORDER IEE0003D\n ORDER IEE0303D\n ORDER IEE5403D\n ORDER IEE0403D\n ORDER IEE7503D\n ORDER IEE5603D\n ORDER IEE5903D\n ORDER IEE6703D\n ORDER IEE7703D\n ORDER IEE6803D\n ORDER IEE6903D\n ORDER IEE6303D\n ORDER IEE6403D\n ALIAS IGG2103D,IGC0503D,IEE2103D,IEE0503D\n ALIAS IEE7603D\n ALIAS IEAVEMRQ\n ENTRY IEE0003D\n  INCLUDE AOSB3(ISTCFF3D)             FMID=HVT3205\n  INCLUDE SYSLMOD(IGC0003D)\n  NAME IGC0003D(R)     <=== This module is mixed FMID!  Notice the (R).\n  INCLUDE AOS26(ISTZBM0K)             FMID=HVT2202\n  NAME IGE0004{\n ALIAS ISTZBM0J\n  INCLUDE AOS26(ISTZBM0J)             FMID=HVT2202\n  NAME IGE0010F\n       ------------    DATA  MISSING  FOR  BREVITY    -----------\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n\nFIGURE EIGHT.   ELEMENT COPY Job to move all DLIB Elements from\n                the MVS/370 DLIBs to the corresponding MVS/XA DLIBs.\n                This job was created by editing the GIMELMNQ output\n                from Figure Five.\n\n\n//TSTB$MO$ JOB (TS,2322),'TECH.SUPP-MARIANNE',CLASS=M,NOTIFY=TSTBSSG,\n//        MSGLEVEL=(1,1),MSGCLASS=T TYPRUN=HOLD\n//*\n//COPYSTEP EXEC PGM=IEBCOPY,REGION=5500K\n//SYSUT3   DD UNIT=SYSDA,SPACE=(6160,(230,760))\n//SYSUT4   DD UNIT=SYSDA,SPACE=(6160,(230,760))\n//SYSPRINT DD SYSOUT=*\n//AGENLIBI DD DSN=TSY2.AGENLIB,DISP=SHR\n//AGENLIBO DD DSN=TSX1.AGENLIB,DISP=SHR\n//AMACLIBI DD DSN=TSY2.AMACLIB,DISP=SHR\n//AMACLIBO DD DSN=TSX1.AMACLIB,DISP=SHR\n//AMODGENI DD DSN=TSY2.AMODGEN,DISP=SHR\n//AMODGENO DD DSN=TSX1.AMODGEN,DISP=SHR\n//ASAMPLII DD DSN=TSY2.ASAMPLIB,DISP=SHR\n//ASAMPLIO DD DSN=TSX1.ASAMPLIB,DISP=SHR\n//ATSOMACI DD DSN=TSY2.ATSOMAC,DISP=SHR\n//ATSOMACO DD DSN=TSX1.ATSOMAC,DISP=SHR\n//AOSB3I   DD DSN=TSY2.AOSB3,DISP=SHR\n//AOSB3O   DD DSN=TSX1.AOSB3,DISP=SHR\n//AOST3I   DD DSN=TSY2.AOST3,DISP=SHR\n//AOST3O   DD DSN=TSX1.AOST3,DISP=SHR\n//AOST4I   DD DSN=TSY2.AOST4,DISP=SHR\n//AOST4O   DD DSN=TSX1.AOST4,DISP=SHR\n//AOS24I   DD DSN=TSY2.AOS24,DISP=SHR\n//AOS24O   DD DSN=TSX1.AOS24,DISP=SHR\n//AOS26I   DD DSN=TSY2.AOS26,DISP=SHR\n//AOS26O   DD DSN=TSX1.AOS26,DISP=SHR\n//SYSIN    DD *\n  COPY OUTDD=AGENLIBO,INDD=AGENLIBI\n SELECT MEMBER=SGIKT400                     AGENLIB\n SELECT MEMBER=SGIKT410                     AGENLIB\n       ------------    DATA  MISSING  FOR  BREVITY    -----------\n SELECT MEMBER=SGIST511                     AGENLIB\n SELECT MEMBER=SGIST513                     AGENLIB\n  COPY OUTDD=AMACLIBO,INDD=AMACLIBI\n SELECT MEMBER=CHANGE                       AMACLIB\n SELECT MEMBER=CLSDST                       AMACLIB\n SELECT MEMBER=COS                          AMACLIB\n SELECT MEMBER=COSEND                       AMACLIB\n       ------------    DATA  MISSING  FOR  BREVITY    -----------\n SELECT MEMBER=USSCMD                       AMACLIB\n SELECT MEMBER=USSEND                       AMACLIB\n SELECT MEMBER=USSMSG                       AMACLIB\n SELECT MEMBER=USSPARM                      AMACLIB\n SELECT MEMBER=USSTAB                       AMACLIB\n       ------------    DATA  MISSING  FOR  BREVITY    -----------\n  COPY OUTDD=AOST4O,INDD=AOST4I\n SELECT MEMBER=IKTIIOM                      AOST4\n SELECT MEMBER=IKTLOGFF                     AOST4\n SELECT MEMBER=IKTLOGR                      AOST4\n SELECT MEMBER=IKTRPLXT                     AOST4\n SELECT MEMBER=IKTXINIT                     AOST4\n SELECT MEMBER=IKTXLOG                      AOST4\n  COPY OUTDD=AOS24O,INDD=AOS24I\n SELECT MEMBER=AMDUSRFD                     AOS24\n SELECT MEMBER=ISTAICPT                     AOS24\n SELECT MEMBER=ISTAPC33                     AOS24\n       ------------    DATA  MISSING  FOR  BREVITY    -----------\n SELECT MEMBER=ISTSDCND                     AOS24\n SELECT MEMBER=ISTSDCNF                     AOS24\n SELECT MEMBER=ISTSDCOD                     AOS24\n SELECT MEMBER=ISTZRM01                     AOS24\n  COPY OUTDD=AOS26O,INDD=AOS26I\n SELECT MEMBER=ISTACCAN                     AOS26\n SELECT MEMBER=ISTACCAP                     AOS26\n SELECT MEMBER=ISTACCAQ                     AOS26\n       ------------    DATA  MISSING  FOR  BREVITY    -----------\n SELECT MEMBER=ISTTSC3R                     AOS26\n SELECT MEMBER=ISTTSC3S                     AOS26\n SELECT MEMBER=ISTVTLOD                     AOS26\n SELECT MEMBER=ISTZBM0J                     AOS26\n SELECT MEMBER=ISTZBM0K                     AOS26\n       ------------    DATA  MISSING  FOR  BREVITY    -----------\n/*\n//\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n\nFIGURE NINE.   UCLIN Job to load VTAM 2.2 entries into the XA DLIB\n               ZONE and the XA TARGET ZONE.  These entries had been\n               UNLOADed from respective ZONEs of the MVS/370 SMP/E\n               system.\n\n\n//TSTB$MO$ JOB (TS,2322),'TECH.SUPP-MARIANNE',CLASS=M,NOTIFY=TSTBSSG,\n//        MSGLEVEL=(1,1),MSGCLASS=T TYPRUN=HOLD\n//*\n//BLDDEFD EXEC SMPEMXA,REGION=4096K,AC=,  <=== MVS/XA SMP/E Procedure\n//             COND=(0,NE)\n//SMPCNTL  DD  *\n SET BOUNDARY(M22DLB).\n    (Insert MVS/370 DLIB UNLOAD deck for HVT2202 here)\n/*\n//BLDDEFT EXEC SMPEMXA,REGION=4096K,AC=,  <=== MVS/XA SMP/E Procedure\n//             COND=(0,NE)\n//SMPCNTL  DD  *\n SET BOUNDARY(M22TGT).\n    (Insert MVS/370 TARGET UNLOAD deck for HVT2202 here)\n/*\n//\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n\nFIGURE TEN.   JCLIN of the Hybrid COPY Deck and the Hybrid\n              LINKEDIT Deck into the SMP/E system for MVS/XA.\n\n\n\n//TSTBJCLN JOB ,'TECH.SUPP-SAM.GOLOB',CLASS=M,NOTIFY=TSTBSSG,\n//        MSGLEVEL=(1,1),MSGCLASS=T TYPRUN=HOLD\n//******************************************************************//\n//*   SMP/E  - JCLIN OF HYBRID \"GENERATED\" JCL  -  COPY            *//\n//******************************************************************//\n//JCLINC EXEC SMPEMXA,AC=      <=== MVS/XA SMP/E Procedure\n//SMPCNTL DD *\n   SET BDY(M22TGT) .\n   JCLIN.\n/*\n//SMPJCLIN DD DISP=SHR,DSN=TSX1.INSTLIB(VTM22CPY),\n//   UNIT=3380,VOL=SER=VEND02\n//******************************************************************//\n//*   SMP/E  - JCLIN OF HYBRID \"GENERATED\" JCL  -  LINKEDIT        *//\n//******************************************************************//\n//*\n//JCLINL EXEC SMPEMXA,AC=      <=== MVS/XA SMP/E Procedure\n//SMPCNTL DD *\n   SET BDY(M22TGT) .\n   JCLIN.\n/*\n//SMPJCLIN DD DISP=SHR,DSN=TSX1.INSTLIB(VTM22LNK),\n//   UNIT=3380,VOL=SER=VEND02\n//\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9010OC": {"ttr": 7173, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93!\\x0f\\x00\\x93!\\x0f\\x145\\x02\\xcd\\x02\\xcd\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "1993-07-29T14:35:00", "lines": 717, "newlines": 717, "modlines": 0, "user": "SBGCSC"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         October 1990\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n\n\n      This month, I'd like to start with a quote from one of the MVS\n\"heavies\" of all time (until the present).  Howard Gilbert, who usually\nworks at Yale University, also gives an excellent week-long course on\nMVS internals.  Anyone who has the remotest chance of being able to\ntake Howard's course (which is managed by CSR of Avon, CT) should\njump at it.  He's tremendously knowledgeable, and he's a good speaker\nbesides.\n\n      Howard starts his course with an \"inspired\" statement.  Anyone\nwith any experience will not doubt how amazingly true this statement\nis.  It's so true, that people in our business forget that it's probably\nthe single most important statement to know, for anyone dealing with\nthe MVS Operating System (and perhaps other IBM operating systems).\n\n      Howard's statement is the following:  \"It is impossible to\nunderstand the MVS Operating System through logic.  IBM started with\nthe designing of the OS/360 Operating Systems, and proceeded with the\nmaxim of:  'If it ain't broke, don't fix it.'  IBM people would only\nrewrite code that it was deemed necessary to rewrite.  Thus, the\ndevelopment of MVS has been an EVOLUTIONARY PROCESS, and the only way\none can really understand MVS is through a knowledge of its HISTORY.\nSo why is IBM is driven to change things?  MAINLY BY THE NEEDS OF ITS\nBIGGEST CUSTOMERS.\"\n\n      See why Howard's course is so good?  Just try and find an IBMer\nwho'll come out and say that!  IBM people seem usually constrained to\nbe talking about ONLY WHAT THE COMPANY IS SELLING NOW.  The problem\nis that \"an adequate understanding of what's now\" only comes from \"an\nunderstanding of what was\".  That's why I feel that \"the fifteen year\nplus\" people have an extra jump on everyone else in this business,\nand everybody else had better make it their business to have long\nconversations with those folks.  (Also, SAVE OLD MANUALS!)\n\n      Our current topic will thus be more personal in format than\nmost.  It will deal with two useful TSO commands that were written by\ntwo \"old timers\" who are my close friends.  I have gained a tremendous\namount of \"MVS facts and lore\" from both of these people, much of which\ncomes out to all of you when it's appropriate for the current topic.\n\n      Jeff Broido's \"MAPXA\" and \"MAPSP\" commands map the overall\nlayout of virtual storage in XA and non-XA MVS systems, respectively.\nBruce Leland's \"BLKDISK\" program, which is also known by its aliases,\n\"BLK3350\", \"BLK3380\", \"BLK3375\", and now \"BLK3390\", helps the user\neffortlessly calculate efficient blocking factors for disk space\nutilization.  I'll explain and illustrate these programs as this\nmonth's topic.\n\n\nMAPXA.\n\n      I well remember when MAPXA was written.  Jeff and I were working\nas systems programmers for a big bank in New York.  When XA first came\nout, our shop (a large one) was one of the earlier shops to convert to\nit.  We had three 3081's then, and XA was brought up on one machine on\nDecember 31, 1983 (to save on taxes.  Sound familiar?)  Production was\nfirst run on that machine about two weeks later.  The XA machine ran\nin a JES3 complex as a local, together with the other two machines\nwhich ran MVS/370 in parallel for several more months, until all the\nuser software could be cut over.\n\n      We were having some mysterious problems with VSAM GETMAINs\n(minus corresponding FREEMAINs) filling up CSA at that time.  Sometimes\nwe had to IPL twice a day because of the condition.  Jeff, consulting\nas a \"resident expert\", had to diagnose the cause of this problem as\none of his duties.  Jeff was brand new to XA then, but he is \"long in\nhis knowledge of history\", and he is an extremely fast and avid\nlearner.  Jeff said that he \"picked up XA coding differences from the\nconversion notebook in an hour on the train\", going home from work one\nday.\n\n      In the process of charting what was happening in CSA, Jeff\ndecided that it'd be fun and useful to map all of XA virtual storage\nout.  He wrote his MAPXA program completely from scratch, helped only\nby the IBM manuals on XA coding and structure, and by his previous\nsystem 370 and 360 coding experience.  Within a week after the one XA\nmachine was in production, on January 24, 1984, Jeff had MAPXA up and\nworking.  I have heard from many friends and acquaintances that they\nare grateful to be able to use MAPXA on their current systems till\ntoday.  MAPXA (and MAPSP) can be found with a collection of Jeff's\nother programs, on File 423 of the CBT MVS Tape.  It has been on the\nCBT tape since version 249, dated July 5, 1985, with no subsequent\nrevisions.\n\n      After having successfully written MAPXA, Jeff wrote a non-XA\nmapping command called \"MAPSP\", so that we could have a corresponding\nlook at the virtual storage configuration in our two non-XA machines.\n\n      Now please look at Figure One to see the output of the MAPXA\nTSO command.  Notice first that virtual storage under XA is divided\ninto two areas which generally \"mirror\" each other.  The \"reflection\npoint\" is the 16-megabyte address location which is denoted by HEX\n'00FFFFFF', the upper limit of 24-bit addressing.  Jeff has cutely\nreferred to this important point of demarcation as \"THE LINE\".\n(This is familiar to most of us, but I'm including some talk about\nit for completeness.  I'll go on a little more about the topic, so\neveryone can be involved in the discussions that follow.)\n\n      We must discuss \"extended byte addressing\" itself, and also\nidea of \"which system areas occupy which addresses\"--both under XA,\nand under old MVS/370 non-XA systems.\n\n      First, we shall cover the concept of:  \"What is extended byte\naddressing?\"  \"Addressing\" refers to virtual storage byte locations\nwithin computer storage.  There are virtual \"byte addresses\" that are\nnumbered (in hexadecimal) from zero upward.  Before the \"extended\naddressing\" made possible by XA (extended architecture), the upper\nlimit of addressable virtual storage was 16 megabytes, since the\n370-type hardware was incapable of using address locations larger than\nthis.\n\n      At the time that OS/360 architecture was new, the quantity of 16\nmegabytes of processor storage was deemed impossibly large.  Even though\nthe general purpose registers (which held the address quantities) were\nfour bytes (or 32 bits) in length, and capable of holding many more\naddressing locations, the low order three bytes were then deemed to\nhave enough addressing room for anyone's programs and data.  The\nhigh-order byte of the general purpose registers was used by programs\nfor storage of flags, and for other things besides virtual storage\naddressing locations.  Three bytes of hexadecimal numbers contain 24\nbits, which in turn can represent 16 megabytes of different address\nnumbers.\n\n      Under pressure from its largest users (remember Howard Gilbert's\nmaxim), IBM was forced around 1980, to start redesigning its 370 system\nhardware to use 31 bits of the registers as byte addresses.  This would\nthen allow addressing locations of greater than 16 megabytes in the\nregisters.  Problem was, that many programs then (and still) running,\ndepended on using the high-order byte of general purpose registers for\nflag bits and for other types of data.  IBM, following the other part\nof \"Howard's rule\" (not rewriting old code unless necessary) was forced\nto design a \"dual mode of execution\".  This would allow old programs to\nrun \"the old way\", treating addresses as being 24-bits long.  It would\nalso allow new programs to run \"the new way\", treating addresses as\nbeing 31-bits long, as defined by its new \"extended\" architecture.\n\n      So, according to this evolutionary principle, we were stuck with\ntwo ways of running programs on IBM hardware.  These are AMODE 24\n(24-bit addressing), AMODE 31 (31-bit addressing) and also AMODE ANY\n(the program does its own switching of modes, so it doesn't matter how\nit started executing).\n\n      Programs and data using storage addresses of less than 16\nmegabytes ONLY, are said to RUN BELOW THE LINE.  Programs which are\nwritten to use larger addresses also, are said to RUN ABOVE THE LINE.\nSYSTEM ROUTINES as well as USER ROUTINES can be written to run either\nway.\n\n      Please just notice, that STORAGE BELOW THE LINE IS PRECIOUS.\nThere isn't that much of it.  We need this storage to run old-style\nprograms, and also CCWs (channel command words) that are used to do\nI/O to peripheral devices.\n\n      IBM has been writing much of its system code to run above the\nline lately.  This frees up storage that is below the line for private\nuse by user programs.  Storage that is available BELOW THE LINE for\nprivate programs to use, is said to be \"THE PRIVATE REGION\".  Storage\nABOVE THE LINE for private programs to use, is said to be \"EXTENDED\nPRIVATE\" storage.\n\n      Virtual storage areas where system programs reside, are forbidden\nfor unrestricted private use.  They are considered common storage\nregions which can serve all users, but which can not \"easily\" be\nmodified by them.  The different common regions are NUCLEUS, which\ncontains the \"guts\" of MVS, PSA (protected low-storage addresses),\nthe various \"LPA\" regions which contain single copies of commonly\nused programs, CSA (usable common storage), and SQA (system queue area,\nwhich is a special type of common storage across address spaces).\n\n      Now look at the Figure Two (MAPSP) display.  In non-XA systems,\nthere is only one copy of each type of address region.  But the XA\nsystems (see Figure One) have TWO copies of each type of region--one\nbelow the line, and one above the line (called \"extended\" or \"E\").\nIn XA, the NUCLEUS region straddles the line, and all other regions\nhave a part \"above\", separated from a corresponding part \"below\".\n\n      I have several more things to say before we leave the topic\nof storage region maps.  Note that in MAPXA, Jeff calculates the\npercent of CSA storage now being used.  This is because he needed\nthe program originally to diagnose a condition of CSA becoming filled\nunnecessarily.  Note also that MAPSP calculates the percent of storage\ncurrently being used in the SQA region.  That was also necessary for\nthe diagnosis of some problem conditions.\n\n      Often, we can merely use the MAPSP or MAPXA programs just to\ngive us an idea of how much private region size we can safely run below\nthe line.  They are also extremely important in diagnosis, enabling us\nto determine what type of storage is represented IN OUR SYSTEM by any\ngiven storage address.  I used MAPSP once to determine that we were\ndefining too much CSA in our IEASYS00 member of SYS1.PARMLIB.  I cut\nthe CSA amount down, and was easily able to obtain another \"meg\" of\nprivate region below the line.  I'm sure that you can also find new\nways for these programs to help you at your own shop.\n\n\nTHE BLKDISK PROGRAM (BLK3350, BLK3380, BLK3390, etc.).\n\n      Calculating disk space allocations is one of the \"necessary\ninconveniences\" of MVS.  IBM came up with the idea of System Managed\nStorage, much in response to the known difficulty of allocating\nproper amounts of disk space on the various disk devices.  However,\neven if your shop uses System Managed Storage, a system programmer\nmust still be knowledgeable about how disk space allocations are\ndependent upon disk device geometry.  First, not all space is managed\nby SMS.  Second, SMS must be carefully PLANNED for.\n\n      Let's discuss the problems.  We all know, for example, that a\n3350 disk device has a maximum blocksize of 19,069 bytes per track,\nand that there are 30 tracks per cylinder.  We also know that a 3380\ndisk device has a maximum blocksize of 47,476 bytes per track and\nthere are 15 tracks per cylinder.  Most of us have had experience\nwith these disk drives.  It is still difficult to remember these\nnumbers.  Worse, when trying to calculate the number of blocks per\ntrack on any device, one must also know the number of \"bytes\" occupied\nby an INTERBLOCK GAP (the space in-between two data blocks on a\ntrack).  Records that have KEYS separate from their DATA, create even\nmore complication in the matter.  Most people \"solve\" the problems\nby just experimenting with test files, to see \"what fits\".\n\n      We see that this stuff is not fun, but it is very necessary to\ndo in an MVS environment.  Efficient use of disk space is a part of\nany programmer's capacity planning.  However, under the usual\nconditions, actual disk space optimization is very difficult for a\nnormal programmer to achieve.\n\n      There have been a number of proposed solutions that I know of\npersonally.  One of my former colleagues devised a SAS program hooked\nto a CLIST, that calculated disk capacities for the various disk\ndevices.  The setup was helpful to him, but it was not for everyone.\nFirst, the prompts were cumbersome to learn.  Second, that setup was\nuseless to me because our shop doesn't have the SAS product.  Finally,\nthe program ran rather slowly.  Probably most of you know of such\nhome-grown solutions for disk calculation, and most of them probably\nexhibit similar disadvantages.\n\n      So now, I'll tell you of a fully-implemented ASSEMBLER program\ncalled \"BLKDISK\" that runs at \"assembler\" speed.  It does all kinds of\ndisk calculations in useful ways that we'll describe.  If you are a\nuser of the fabulous \"PDS\" product (CBT tape files 182, 296 and 112),\nor a user of its vendor-supported extension \"PDS/E\", BLKDISK will\nreturn its output to a PDS(/E) View Log, where it is available to be\nprinted out or written to a dataset for further manipulation.  BLKDISK\nis found on File 296 of the CBT MVS Tape.\n\n      Since BLKDISK was written by my friend Bruce Leland, I'd like to\ninclude some personal trivia about it.  Bruce wrote BLKDISK to solve\nthe same problems we all have to solve about disk space.  People in\nhis shop were using (in his words) \"really lousy blocksizes\", and he\nwanted to clean up the situation.  Bruce wrote the original version\n(which has the same output) in PL/I at the very beginning of 1978, just\nfor 3330 disks.  In August 1982, he converted the program to assembler\nlanguage, because \"it ran very slow\" in PL/I.  Bruce provided device\nsupport for most of the \"old\" devices, and he added support for the new\nones as they went on the market.  The very latest version on the newest\nCBT tapes has 3390 support, as well as support for all the other\ndevices.  BLKDISK is a public-domain TSO command, and has been\navailable on the CBT tape since Version 204 (November 14, 1982).\n\n      How does BLKDISK work?  BLKDISK provides device support through\nits ALIASES.  The BLKDISK program, after it is assembled, can be\nlinkedited with aliases:  BLK23051, BLK23052, BLK2314, BLK3330,\nBLK33301, BLK3340, BLK3350, BLK3375, BLK3380 and BLK3390.  The alias\nunder which BLKDISK is invoked, determines which device size numbers\nare used.  These are taken from a device parameter table that is coded\nin the program.\n\n      To use BLKDISK, we invoke one of the aliases as a TSO command.\nFor example:\n\n      BLK3380 80 NUMBER(5000) BLKSIZE(3120)\n\nThe output will appear similar to the upper table in Figure Four.\nHowever the allocation instructions for 5000 80-byte records with a\nblock size of 3120 will read:\n\n   FOR BLKSIZE  3,120  AND    5,000 RECORDS, ALLOCATE:\n          129 BLOCKS,       10 TRACKS, OR         1 CYLINDERS\n\nThis is simple to use, neat, quick, and handy.  Note that half-track\nblocking is \"RECOMMENDED\" by Bruce, for reasons enumerated in the\ntutorial included with the program.\n\n      I've shown a full tutorial on how to use the BLKDISK aliases in\nFigure Three.  Figure Three is the TSO HELP member for BLK3380, and\nsimilar syntax is used for all the other device types.\n\n      I have included three extra figures to illustrate BLKDISK\noperation.  These are Figures Five, Six and Seven, in addition to\nFigure Four.  The reason for that is the useful reference information\ndisplayed by the TRACKCAP parameter.\n\n      For each device, the TRACKCAP parameter displays a table showing\nthe LARGEST NUMBER OF BYTES IN A BLOCK, THAT WILL FIT \"n\" BLOCKS TO\nA TRACK.  For example, on a 3380 device, 23476 bytes in a block is the\nlargest block that will fit 2 blocks to a track.  Similarly on a 3350\ndevice, the largest block that will fit 5 blocks to a track, is 3665\nbytes.  These tables are so handy, that I've included them for you to\nkeep for your reference later.  You may find it useful to have a copy\nof them posted at your desk.\n\n      Please read the BLKDISK tutorial and spend time looking at the\nillustrations.  Having this program installed and running, will help\nyour shop greatly.  At the very least, you can substantiate your own\nrecommendations for block sizes, and all the other programmers can\nbenefit too.\n\n      Hope these programs help you.  See you next month.\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE ONE.   Illustration of the MAPXA TSO Command from Jeff Broido.\n               (Written January 1984.)  Note his \"cute\" characterization\n               of the \"16-meg\" address.\n\n\nAREA            START        END          LEN. (K)       %FULL\n--------------  ----------   ----------   -----------    -----\nE-PRIVATE       02100000     7FFFFFFF      2,063,360     --\nE-CSA           01D58000     020FFFFF          3,744     --\nE-MLPA          01D4B000     01D57FFF             52     --\nE-FLPA          01D47000     01D4AFFF             16     --\nE-PLPA          01A22000     01D46FFF          3,220     --\nE-SQA           011D2000     01A21FFF          8,512     --\nE-NUC (R/W)     01164000     011D1FFF            440     --\nE-NUC (R/O)     01000000     01163FFF          1,424     --\n-------------------------------------------------------------- THE LINE.\nNUC (R/O)       00FE3000     00FFFFFF            116     --\nNUC (R/W)       00FC1000     00FE2FFF            136     --\nSQA             00F21000     00FC0FFF            640     --\nPLPA            00D83000     00F20FFF          1,656     --\nFLPA            00D81000     00D82FFF              8     --\nMLPA            00D72000     00D80FFF             60     --\nCSA             00B00000     00D71FFF          2,504     24\nPRIVATE         00001000     00AFFFFF         11,260     --\nPSA             00000000     00000FFF              4     --\n\n\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE TWO.   Illustration of the MAPSP TSO Command from Jeff Broido.\n               (Written January 1984.)\n\n\nAREA          START    END      LENGTH (K)  %FULL\n------------  ------   ------   ----------  -----\nSQA           F90000   FFFFFF          448     71\nPLPA          B1F000   F8FFFF        4,548     --\nMLPA/BLDL     AC8000   B1EFFF          348     --\nSYSGEN PSA    AC7000   AC7FFF            4     --\nCSA           910000   AC6FFF        1,756     --\nV=R (IF ANY)  114000   153FFF          256     --\nPRIVATE       110000   90FFFF        8,192     --\nNUCLEUS       001000   10FFFF        1,084     --\nPSA           000000   000FFF            4     --\n\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE THREE.   TSO HELP Member for the BLK3380 call to the BLKDISK\n                 command.  This member illustrates how to use\n                 BLKDISK to find out disk allocation information\n                 on a 3380 disk device.  Similar syntax is used\n                 to call BLKxxxx, where xxxx denotes another model of\n                 disk device.  xxxx may be a 3330, 3340, 3350, 3375,\n                 3380, or 3390 device.\n\n\n)F FUNCTION -\n  THE BLK3380 COMMAND COMPUTES AN OPTIMAL BLOCKSIZE FOR A DATA SET\n  TO BE PLACED ON A 3380 DISK PACK.  THE PROGRAM OUTPUT INCLUDES\n  THE FOLLOWING REPORTS:\n     1.  A SUMMARY BLOCKSIZE REPORT FOR THE GIVEN LRECL AND KEY\n         LENGTH WHICH INCLUDES THE RECOMMENDED BLOCKSIZE TO USE.\n     2.  A RECOMMENDED DATA SET SPACE ALLOCATION.\n     3.  A OPTIONAL TRACK CAPACITY REPORT FOR THE PROVIDED KEY LENGTH.\n\n  THE RECOMMENDED BLOCKSIZE VALUE IS FOR DATA SETS IN WHICH THE\n  PREDOMINANT ACCESS IS SEQUENTIAL; FOR DATA SETS WHERE RANDOM\n  ACCESS TIME IS CRITICAL OR THE USUAL ACCESS IS RANDOM, A SMALL\n  BLOCKSIZE (500-2000 BYTES) SHOULD PROBABLY BE USED.\n\n  THE RECOMMENDED BLOCKSIZE WILL USUALLY TEND TO BE NEAR A HALF-TRACK\n  FIGURE AS THIS IS CONSIDERED TO BE THE MOST EFFICIENT IN TERMS OF\n  THE TRADE-OFFS AMONG BUFFER SIZE, SECONDARY STORAGE REQUIREMENTS,\n  CHANNEL USE, NUMBER OF INPUT/OUTPUTS AND OVERALL PROCESSING TIME.\n  THIS FIGURE IS ONLY A GENERAL GUIDE; FOR MAXIMAL EFFICIENCY\n  CONSIDERING OTHER FACTORS, STUDY THE GENERATED BLOCKSIZE SUMMARY\n  REPORT OR A TRACK CAPACITY REPORT.\n\n  THE PROGRAM'S RECOMMENDATIONS ASSUME A FAIRLY LARGE AMOUNT OF DATA\n  IS TO BE STORED; DATA SETS WHICH OCCUPY ONLY A FEW TRACKS SHOULD\n  PROBABLY BE PLACED IN PARTITIONED DATA SETS.  IN CASES WHERE THIS\n  IS NOT FEASIBLE, THE USE OF A SMALL BLOCKSIZE (2400 - 4000 BYTES)\n  MAY BE A GOOD ALTERNATIVE PRACTICE.\n\n)X SYNTAX  -\n         BLK3380  'LRECL'  KEYLENGTH('INTEGER')\n                           TRACKCAP / NOTRACKCAP\n                           BLKSIZE('INTEGER')\n                           NUMBER('INTEGER') / RECORDS('INTEGER')\n                           VERIFY\n  REQUIRED - LRECL\n  DEFAULTS - KEYLENGTH(0),\n             NOTRACKCAP,\n             BLKSIZE(RECOMMENDED VALUE),\n             NUMBER(100000)\n\n)O OPERANDS -\n 'LRECL'  - THE LOGICAL RECORD LENGTH OF THE DATA WHICH IS TO BE\n            PLACED IN THE DATA SET.\n))KEYLENGTH('INTEGER')\n          - THE KEY LENGTH, IN BYTES, OF THE KEYS TO BE USED IN THE\n            DATA SET.  THE MAXIMUM LEGAL KEY LENGTH IS 255.\n))TRACKCAP\n          - SPECIFIES THAT A TRACK CAPACITY REPORT IS TO BE PROVIDED\n            FOR THE DEVICE USING THE SPECIFIED (OR DEFAULT) KEY LENGTH.\n\n            NOTE THAT A TRACK CAPACITY REPORT IS ALSO PROVIDED IF\n            NOTRACKCAP IS NOT SPECIFIED AND LRECL EXCEEDS THE MAXIMUM\n            BLOCKSIZE FOR A TRACK OR BLKSIZE EXCEEDS THE MAXIMUM\n            BLOCKSIZE FOR A TRACK.\n))NOTRACKCAP\n          - SPECIFIES THAT A TRACK CAPACITY REPORT IS NOT DESIRED.\n))BLKSIZE('INTEGER')\n          - THE BLOCKSIZE TO USE FOR THE ALLOCATION COMPUTATION; IF\n            BLKSIZE IS NOT ENTERED (OR ZERO IS ENTERED), THE PROGRAM'S\n            RECOMMENDED BLOCKSIZE WILL BE USED.\n))NUMBER('INTEGER')\n          - THE NUMBER OF LOGICAL RECORDS THAT WILL BE IN THE DATA SET.\n))RECORDS('INTEGER')\n          - THE NUMBER OF LOGICAL RECORDS THAT WILL BE IN THE DATA SET.\n))VERIFY  - SPECIFIES THAT THE MVS \"TRKCALC\" ROUTINE IS TO BE USED TO\n            VERIFY TRACK CAPACITY CALCULATIONS.  IF VERIFY IS USED,\n            THE NUMBER OF CALLS TO \"TRKCALC\" TO DETERMINE A TRACK\n            CAPACITY TABLE IS OUTPUT AT THE END OF THE OUTPUT.\n\n            NOTE: WITH VERIFY ON, A MINIMUM OF 34 CALLS IS REQUIRED TO\n            DETERMINE A TRACK CAPACITY TABLE; OTHERWISE A MINIMUM OF\n            17 CALLS IS REQUIRED TO DETERMINE THE TRACK CAPACITY TABLE.\n\n            ** N O T E **  - VERIFY NOT CURRENTLY SUPPORTED FOR 3390.\n\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE FOUR.   Illustration of the BLK3380 TSO Command, invoked to\n                show disk space usage on a 3380 device.  Various\n                block size scenarios are displayed in the upper\n                table, enabling the user to graphically see the\n                disk space utilization by the different block sizes.\n                The Track Capacity Table for 3380 devices is shown\n                as the lower table of the illustration.\n\n\nblk3380 80 trackcap\n\n  3380 BLOCKSIZE SUMMARY;    LRECL=80        KEY LENGTH=0\n            BLOCKSIZE    BLOCKS/TRACK    LRECLS/TRACK    UTILIZATION\n            ---------    ------------    ------------    -----------\n                   80              83              83          14.0%\n                2,480              16             496          83.6%\n                2,640              15             495          83.4%\n                2,880              14             504          84.9%\n                3,120              13             507          85.4%\n                3,440              12             516          86.9%\n                3,840              11             528          89.0%\n                4,240              10             530          89.3%\n                4,800               9             540          91.0%\n                5,440               8             544          91.7%\n                6,320               7             553          93.2%\n                7,440               6             558          94.0%\n                9,040               5             565          95.2%\n               11,440               4             572          96.4%\n               15,440               3             579          97.6%\n RECOMMENDED-->23,440               2             586          98.7%\n               32,720               1             409          68.9%\n\nFOR BLKSIZE 23,440  AND   100,000 RECORDS, ALLOCATE:\n       342 BLOCKS,       171 TRACKS, OR        12 CYLINDERS\n\n\n\n  3380 TRACK CAPACITY;    KEY LENGTH=0\n       BLOCKS/TRACK     BLKSIZE     BYTES/TRACK     UTILIZATION\n       ------------     -------     -----------     -----------\n                  1      47,476          47,476          100.0%\n                  2      23,476          46,952           98.9%\n                  3      15,476          46,428           97.8%\n                  4      11,476          45,904           96.7%\n                  5       9,076          45,380           95.6%\n                  6       7,476          44,856           94.5%\n                  7       6,356          44,492           93.7%\n                  8       5,492          43,936           92.5%\n                  9       4,820          43,380           91.4%\n                 10       4,276          42,760           90.1%\n                 11       3,860          42,460           89.4%\n                 12       3,476          41,712           87.9%\n                 13       3,188          41,444           87.3%\n                 14       2,932          41,048           86.5%\n                 15       2,676          40,140           84.5%\n                 16       2,484          39,744           83.7%\n\nDEVICE SUMMARY: MAX BLOCKSIZE=47,476   TRACKS=13,275   BYTES=630,243,900\nNOCYLS=885   TRKS/CYL=15   TRKSIZE=47,968   DSCB/TRK=53   PDS/TRK=46\n\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE FIVE.   Illustration of the BLK3390 TSO Command, invoked to\n                show disk space usage on a 3390 device.  Various\n                block size scenarios are displayed in the upper\n                table, enabling the user to graphically see the\n                disk space utilization by the different block sizes.\n                The Track Capacity Table for 3390 devices is shown\n                as the lower table of the illustration.\n\n\nblk3390 80 trackcap\n\n  3390 BLOCKSIZE SUMMARY;    LRECL=80        KEY LENGTH=0\n            BLOCKSIZE    BLOCKS/TRACK    LRECLS/TRACK    UTILIZATION\n            ---------    ------------    ------------    -----------\n                   80              78              78          11.0%\n                2,880              16             576          81.3%\n                3,120              15             585          82.6%\n                3,440              14             602          85.0%\n                3,760              13             611          86.3%\n                4,080              12             612          86.4%\n                4,560              11             627          88.5%\n                5,040              10             630          88.9%\n                5,680               9             639          90.2%\n                6,480               8             648          91.5%\n                7,520               7             658          92.9%\n                8,880               6             666          94.0%\n               10,720               5             670          94.6%\n               13,680               4             684          96.6%\n               18,400               3             690          97.4%\n RECOMMENDED-->27,920               2             698          98.5%\n               32,720               1             409          57.7%\n\nFOR BLKSIZE 27,920  AND   100,000 RECORDS, ALLOCATE:\n       287 BLOCKS,       144 TRACKS, OR        10 CYLINDERS\n\n  3390 TRACK CAPACITY;    KEY LENGTH=0\n       BLOCKS/TRACK     BLKSIZE     BYTES/TRACK     UTILIZATION\n       ------------     -------     -----------     -----------\n                  1      56,664          56,664          100.0%\n                  2      27,998          55,996           98.8%\n                  3      18,452          55,356           97.7%\n                  4      13,682          54,728           96.6%\n                  5      10,796          53,980           95.3%\n                  6       8,906          53,436           94.3%\n                  7       7,548          52,836           93.2%\n                  8       6,518          52,144           92.0%\n                  9       5,726          51,534           90.9%\n                 10       5,064          50,640           89.4%\n                 11       4,566          50,226           88.6%\n                 12       4,136          49,632           87.6%\n                 13       3,768          48,984           86.4%\n                 14       3,440          48,160           85.0%\n                 15       3,174          47,610           84.0%\n                 16       2,942          47,072           83.1%\n\nDEVICE SUMMARY: MAX BLOCKSIZE=56,664   TRACKS=16,695   BYTES=946,005,480\nNOCYLS=1,113   TRKS/CYL=15   TRKSIZE=58,786   DSCB/TRK=50   PDS/TRK=45\n\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE SIX.    Illustration of the BLK3350 TSO Command, invoked to\n                show disk space usage on a 3350 device.  Various\n                block size scenarios are displayed in the upper\n                table, enabling the user to graphically see the\n                disk space utilization by the different block sizes.\n                The Track Capacity Table for 3350 devices is shown\n                as the lower table of the illustration.\n\n\n\nblk3350 80 trackcap\n\n  3350 BLOCKSIZE SUMMARY;    LRECL=80        KEY LENGTH=0\n            BLOCKSIZE    BLOCKS/TRACK    LRECLS/TRACK    UTILIZATION\n            ---------    ------------    ------------    -----------\n                   80              72              72          30.2%\n                  960              16             192          80.5%\n                1,040              15             195          81.8%\n                1,120              14             196          82.2%\n                1,280              13             208          87.3%\n                1,360              12             204          85.6%\n                1,520              11             209          87.7%\n                1,680              10             210          88.1%\n                1,920               9             216          90.6%\n                2,160               8             216          90.6%\n                2,560               7             224          94.0%\n                2,960               6             222          93.1%\n                3,600               5             225          94.4%\n                4,560               4             228          95.7%\n                6,160               3             231          96.9%\n RECOMMENDED--> 9,440               2             236          99.0%\n               19,040               1             238          99.8%\n\nFOR BLKSIZE  9,440  AND   100,000 RECORDS, ALLOCATE:\n       848 BLOCKS,       424 TRACKS, OR        15 CYLINDERS\n\n\n\n  3350 TRACK CAPACITY;    KEY LENGTH=0\n       BLOCKS/TRACK     BLKSIZE     BYTES/TRACK     UTILIZATION\n       ------------     -------     -----------     -----------\n                  1      19,069          19,069          100.0%\n                  2       9,442          18,884           99.0%\n                  3       6,233          18,699           98.1%\n                  4       4,628          18,512           97.1%\n                  5       3,665          18,325           96.1%\n                  6       3,024          18,144           95.1%\n                  7       2,565          17,955           94.2%\n                  8       2,221          17,768           93.2%\n                  9       1,954          17,586           92.2%\n                 10       1,740          17,400           91.2%\n                 11       1,565          17,215           90.3%\n                 12       1,419          17,028           89.3%\n                 13       1,296          16,848           88.4%\n                 14       1,190          16,660           87.4%\n                 15       1,098          16,470           86.4%\n                 16       1,018          16,288           85.4%\n\nDEVICE SUMMARY: MAX BLOCKSIZE=19,069   TRACKS=16,650   BYTES=317,498,850\nNOCYLS=555   TRKS/CYL=30   TRKSIZE=19,254   DSCB/TRK=47   PDS/TRK=36\n\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE SEVEN.  Illustration of the BLK3375 TSO Command, invoked to\n                show disk space usage on a 3375 device.  Various\n                block size scenarios are displayed in the upper\n                table, enabling the user to graphically see the\n                disk space utilization by the different block sizes.\n                The Track Capacity Table for 3375 devices is shown\n                as the lower table of the illustration.\n\n\n\nblk3375 80 trackcap\n\n  3375 BLOCKSIZE SUMMARY;    LRECL=80        KEY LENGTH=0\n            BLOCKSIZE    BLOCKS/TRACK    LRECLS/TRACK    UTILIZATION\n            ---------    ------------    ------------    -----------\n                   80              75              75          16.8%\n                1,840              16             368          82.7%\n                2,000              15             375          84.2%\n                2,160              14             378          84.9%\n                2,320              13             377          84.7%\n                2,560              12             384          86.3%\n                2,880              11             396          88.9%\n                3,200              10             400          89.8%\n                3,600               9             405          91.0%\n                4,080               8             408          91.6%\n                4,720               7             413          92.8%\n                5,600               6             420          94.3%\n                6,800               5             425          95.5%\n                8,560               4             428          96.1%\n               11,600               3             435          97.7%\n RECOMMENDED-->17,600               2             440          98.8%\n               32,720               1             409          91.9%\n\nFOR BLKSIZE 17,600  AND   100,000 RECORDS, ALLOCATE:\n       455 BLOCKS,       228 TRACKS, OR        19 CYLINDERS\n\n\n\n  3375 TRACK CAPACITY;    KEY LENGTH=0\n       BLOCKS/TRACK     BLKSIZE     BYTES/TRACK     UTILIZATION\n       ------------     -------     -----------     -----------\n                  1      35,616          35,616          100.0%\n                  2      17,600          35,200           98.8%\n                  3      11,616          34,848           97.8%\n                  4       8,608          34,432           96.7%\n                  5       6,816          34,080           95.7%\n                  6       5,600          33,600           94.3%\n                  7       4,736          33,152           93.1%\n                  8       4,096          32,768           92.0%\n                  9       3,616          32,544           91.4%\n                 10       3,200          32,000           89.8%\n                 11       2,880          31,680           88.9%\n                 12       2,592          31,104           87.3%\n                 13       2,368          30,784           86.4%\n                 14       2,176          30,464           85.5%\n                 15       2,016          30,240           84.9%\n                 16       1,856          29,696           83.4%\n\nDEVICE SUMMARY: MAX BLOCKSIZE=35,616   TRACKS=11,508   BYTES=409,868,928\nNOCYLS=959   TRKS/CYL=12   TRKSIZE=36,000   DSCB/TRK=51   PDS/TRK=43\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9011NV": {"ttr": 7431, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93!\\x0f\\x00\\x93!\\x0f\\x145\\x02\\x02\\x02\\x02\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "1993-07-29T14:35:00", "lines": 514, "newlines": 514, "modlines": 0, "user": "SBGCSC"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         November 1990\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n\n\n      This month, before our regular business, I'd like to thank a\nbig contributor to public software in the MVS world.  Bill Godfrey,\nwho works for Planning Research Corp. near Washington D.C., has\nwritten many programs and TSO commands in current use by programmers\nall over the world.  Bill has also extended the life of some older\nIBM-distributed tools which would have gone by the wayside with the\narrival of XA and ESA.  Many of us probably do not realize that we\nare using some of Bill's programs ourselves.\n\n      Much of Bill's work was sent into the CBT MVS Tape while he was\nworking together with Jim Marshall of the Air Force.  Bill wrote the\nstuff, and Jim would send it into Arnie Casinghino, who administers\nthe CBT tape.  A lot of Bill's pioneering work was done in the late\n70's and early 80's.\n\n      Just SOME examples of Bill Godfrey's work are:  the CDSCB program\nfor changing Format 1 VTOC entries (CDSCB was featured in my JULY 1990\ncolumn).  The $$MACROX modifications are source patches to the IFOX00\nassembler, which allow all macro names and their originating libraries\nto be reported in an assembly listing.  (The SLAC Mods to Assembler H\nsupply a similar report for the IEV90 assembler.)  Other TSO tools are\nhis LPSCB and CPSCB programs (for listing and modifying TSO session\nattributes) and his many extensions to TSO EDIT and TSO TEST (some of\nthese were described in \"TSO TEST Enhancements\" by Alan Field - August\n1990).\n\n      Bill Godfrey has also contributed important disassemblies of the\nIBM utilities INCORZAP and DELINK0 from the object code only versions,\nmaking these programs available in readable assembler source.\n\n      Bill's disassembly of INCORZAP into assembler source code is\nespecially noteworthy.  INCORZAP is a program which zaps IN-STORAGE\ncopies of NUCLEUS or LPALIB modules.  It was originally written in the\nPL/S language by Robert Budge when he worked for IBM.  Later, after\nBudge had left IBM and didn't have access to PL/S, he saw a copy of\nBill Godfrey's assembler source on a CBT tape.  The assembler language\nversion of INCORZAP allowed Budge to fix the code so that it could\nmodify protected storage under XA.\n\n      Here's how INCORZAP works.  INCORZAP can look at the CSECT\nstructure of a module in SYS1.LPALIB or in the disk copy of the\nNUCLEUS.  It then goes to the module's load point in core, doing\nAMASPZAP-type VER and REP zaps on the IN-STORAGE versions of these\nmodules (plus a page fix).  Under old MVS/370, the PLPA and NUCLEUS\nin-core storage had been accessible.  Under XA, some of that storage\nis \"protected\".  Robert Budge's new version, called XACORZAP, can turn\noff the protection, and change the storage anyway.\n\n      Bill Godfrey is also the ORIGINAL author of \"TSSO\" (Time Sharing\nSubsystem Option) which allows the execution of TSO commands on an MVS\nsystem console.  Bill's original version of TSSO is on CBT Tape File\n306.  Although the preferred version of TSSO is Version 4.3 from Marc\nSchare (File 401), Bill Godfrey started bringing the TSO environment\nto the domain of the operator console, paving the way for what\nfollowed.\n\n      Much of Bill Godfrey's code can still be found in Jim Marshall's\ntwo large collections of tools.  TSO tools are on File 300 of the CBT\ntape.  Batch programs are on File 316.  These collections are very\nmuch worth exploring.  Robert Budge's XACORZAP code is found on\nFile 421, with full documentation included.\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nTHE WONDERS OF THE NEW \"REVIEW\" COMMAND.\n\n      Our regular topic concerns a neglected but useful GENERAL\nBROWSING TOOL, the REVIEW command, which works under TSO.  REVIEW\nwas originally written by Bruce Leland.  Bruce's version appears\non the CBT Tape, File 296.  The extension of REVIEW which sparks our\ncurrent interest was written by Greg Price of Melbourne, Australia.\nThere is about DOUBLE the amount of code in Greg's version of REVIEW.\nGreg's code appears in source on File 134 of the CBT tape, and in load\nmodule form on File 135.\n\n      Greg Price jokes about his version of REVIEW that \"it is a case\nof creeping featurism\".  I myself feel that featurism is generally\nuseful for us sysprogs, who are always scrapping to acquire any power\nor utility services that might be available.  Greg's REVIEW is FULL\nof powers that await to be tapped.\n\n      Greg Price's REVIEW contains an awful lot of function.  Greg\nclaims that his REVIEW will allow browsing of most files that have a\nVTOC entry, including VSAM files; REVIEW will format individual\nrecords within control intervals.  REVIEW will also allow browsing of\nTAPE files, as well as disk files of up to 32760 bytes record length.\nYou can browse the active VSAM SMF file, as well as SMF history files\nthat have been written to tape.  REVIEW (in \"SMF mode\") will format\nthe SMF records by type, and will interpret much of the recorded data\non the TSO screen.  REVIEW will often allow you to look at files that\nare currently OPEN.  REVIEW can also be told to bypass I/O error spots\nand EOF markers, both on disk and on tape.  Many extremely large files\ncan be quickly REVIEWed FROM THE BOTTOM.  That's a feature which even\nISPF BROWSE doesn't have!\n\n      Greg's REVIEW (unlike Bruce's earlier version) can handle an\nentire partitioned dataset.  REVIEW has some special features that are\ntailored for pds'es, notably its OFFLOAD of selected (or all) members\nto a sequential dataset in IEBUPDTE format (preserving ISPF stats\nif they are present).\n\n             If you REVIEW a dataset name that is a pds, you are\npresented with a sortable and flexible member list display (see Figure\nOne).  Much useful work can be done from this display.  This member\nlist also makes possible the OFFLOAD feature of REVIEW.\n\n      The rest of our column will detail some of REVIEW's special\ncapabilities, so you can imagine some of the mileage that you might\nget from it.\n\n\nREVIEW AS A TSO COMMAND.\n\n      Using REVIEW is very simple.  At a TSO terminal, one merely\ntypes:\n\n           REVIEW   dataset.name      (where the dataset.name refers\n                                       to either a sequential dataset,\n                                       a pds, or the VTOC name of a\n                                       VSAM file.  It may also be a\n                                       cataloged tape file.)\n\n    or     REVIEW   filename  FILE    (where the filename is a ddname\n                                       allocated to the TSO session.)\n\nIf dataset.name is a partitioned dataset, a complete member list\nappears (see Figure One).  In the member list, one may enter a LINE\nCOMMAND of \"S\" (for REVIEW), \"B\" (for ISPF BROWSE if available) or \"E\"\n(for ISPF EDIT if available).  An eight-byte \"locate\" field for\npositioning to a given member, is the only input field on the member\nlist, besides the one-byte code input field on each line next to the\nmember name.  PFKEYS can be used as input to member list mode.  Their\nmeanings are listed in the prompt area at the top of the member list.\nSome PFKEYS are devoted to sorting the member list in different ways.\nFigure One shows various member list sorts, and gives other\ninformation on using the member lists.\n\n      If a sequential file or a VSAM file is being REVIEWed, the data\nappears immediately.  See Figure Two for the sample REVIEWing of some\ndata.  When actually looking at data, we say we are in \"REVIEW-data\nmode\".  All command descriptions which follow (except for the case\nof member offloading) apply to being in REVIEW-data mode.\n\n      When REVIEWing a member or a single dataset, the user has a lot\nof flexibility.  PF1 is the HELP key.  A question mark \"?\" on the\ncommand line or the \"KEYS\" command will have the same effect as PF1.\nThis will cause a second panel to be shown, which displays the current\nuse of the other PFKEYS.  See Figure Three.\n\n      It pays to install Bruce Leland's fullscreen TSO help program\nthat is called \"HEL\".  HEL is found on CBT tape File 296 or on File\n134.  The HEL load module is on File 135.  If the REVIEW \"TSO help\"\nmember has been put into the TSO SYSHELP concatenation, then a second\nhit of PF1 will make detailed help available in fullscreen mode.\n\n      Some general commands are available from the REVIEW-data mode\ncommand line.  From the data mode command line, the \"TSO\" subcommand\nwill allow us to execute any TSO command from within REVIEW.  If we\nare looking at a pds member, the \"DIR\" command, entered on the command\nline, will get us into the member list mode.  From within any member,\nthe \"MEM newmembr\" command will switch us to REVIEWing another\nmember.\n\n      ASCII data may be displayed on an EBCDIC terminal with the\n\"ASCII\" command, which toggles ASCII mode on and off.  If SMF data\n(\"live\" from the VSAM file, or from a backup tape) is being displayed,\nthe \"SMF\" command toggles SMF record interpretation on and off.\nAlmost all types of SMF records are partially or completely\ninterpreted by the \"SMF mode\" of REVIEW.\n\n      HEX data is displayed by the \"HEX\" command, which toggles\n\"HEX mode\" on and off.  Newer color terminals may benefit from\n\"COLOR mode\", which may be toggled on or off using the \"COLOR\"\ncommand.\n\n      Let's talk about actually looking at a dataset.  There are\nvarious \"FIND\" commands which can help you.  \"FIND\" is an ordinary\nstring find command, but with the argument translated to uppercase.\nThis is similar to the action of the \"FIND\" subcommand in ISPF edit or\nbrowse.  To achieve an \"asis\" effect, the \"FINDCHR\" command is used.\nUnder \"FINDCHR\", no uppercase translation is done.  \"FINDHEX\" helps\nlocate hex strings.  If SMF data is being looked at in SMF mode, the\n\"FINDSMF\" command will locate the next occurrence of a given SMF\nrecord type.\n\n      The \"LIST\" command will position you to a particular logical\nrecord number.  For example, \"LIST 340\" will position you to the\n340th record of the file.  The usual \"UP nnn\" and \"DOWN nnn\",\n\"RIGHT nnn\" and \"LEFT nnn\" commands are available.  \"+\" and \"-\"\nare aliases for DOWN and UP.  \"<\" and \">\" are aliases for LEFT and\nRIGHT.  TOP and BOTTOM have their usual meanings.\n\n      REVIEW has some conveniences built in, for looking at large\nfiles.  Suppose we're trying to look at the BOTTOM of a file that has\n200,000 records.  Let's say we've entered the \"BOTTOM\" command.  If\nthe records are FIXED BLOCKED, and REVIEW can calculate TTR data for\nthe bottom of the file, then REVIEW positions itself at the bottom\nimmediately.  No time-consuming block scanning has to be done.  For\nvariable-blocked data or for \"find\" searches where this technique\ncannot be used, REVIEW has another feature that is good for the user.\nSuppose you have entered the BOTTOM command on a large\nvariable-blocked file and the computer is cranking away.  A press of\n\"attention\" will stop REVIEW in its tracks at the point where it\ncurrently is.  You will see the point that it has gotten to thus far.\nThat relieves the suspense of waiting--you can follow REVIEW's\nprogress as it is moving along.  At any point, you may resume the\nprogress, by reentering BOTTOM or the particular \"FIND\" commmand you\nwere using.\n\n      One of the neat features of REVIEW is the \"NEWTOP\" command that\ncan be used in REVIEW-data mode.  NEWTOP is issued with an operand of\na relative-TTR address to the beginning of the dataset, as in:\n\n           NEWTOP  0010A\n\n      When this is entered, REVIEW assumes that relative-TTR location\n0010A within the dataset is the real top-of-data.  NEWTOP can thus be\nused to position past I/O error spots and end-of-file markers in the\ndataset.  Deleted PDS members and data past the \"DS1LSTAR\" high-water\nmark of \"valid data\" can be browsed using this tool.  For tape files,\nthe operand of NEWTOP is interpreted as a relative block number.  One\ncan look at \"inaccessible data\" on tapes, too.  To reset REVIEW so that\nit will again look at the real top of the data, simply enter \"NEWTOP\"\nwithout any operands, or \"NEWTOP 0\".\n\n\nOFFLOADING MEMBERS TO SEQUENTIAL DATASETS.\n\n      REVIEW has the capability of \"sequentializing\" selected members\nof partitioned datasets and preserving their ISPF statistics in that\nprocess.  This facility depends on two things:  the REVIEW member list\nfor partitioned datasets, and pre-allocation of a SYSUT2 ddname to\na sequential output dataset that will receive the offloaded members.\n\n      To use the OFFLOAD capability of REVIEW, simply REVIEW a pds\nand get into member-list mode.  You should have previously allocated\na sequential dataset with compatible DCB attributes to the current\ndataset, using the file name of SYSUT2.\n\n      Then you do the following:  If you want to OFFLOAD all of the\nmembers, sort the member list (using PFKEYS) into a desired order.\nThen in the 8-byte \"LOCATE\" field of the member list, type the word\n\"=OFFLOAD\".  REVIEW will signal when it has finished the offloading\nprocess and has closed the SYSUT2 output dataset.\n\n      If you want to offload only SOME of the members, do the\nfollowing:  Sort the member list in the most convenient way, or in\nany desired order.  Then type \"O\" as a line command next to some of\nthe names you want to offload.  Press enter.  Doing this will\nhighlight the desired members in the member list.  Go down the member\nlist and choose all the members you want by typing \"O\" next to them\nand pressing enter.  When you've finished, type \"=OFFLOAD\" in the\nlocate field as before.  REVIEW will offload the selected members in\nthe member list order, and will announce when it has closed the SYSUT2\ndataset.\n\n      The command \"=REFRESH\" in the locate field of the member list\nwill clear all members previously selected for offloading.  A line\ncommand of \"R\" (which stands for REFRESH) next to a member chosen for\noffload will cancel its selection.\n\n      You can see that OFFLOAD is a useful facility.  You'll realize\nthis even more when you've used it yourself.\n\n\nREVIEWING TAPES.\n\n      Any cataloged tape file may be REVIEWed by entering its name\nas the operand of the REVIEW command under TSO.  The tape file might\nbe described either as a dataset name or as a ddname (TSO file name).\nIf you are pointing to a ddname, the keyword \"FILE\" must follow the\nname.\n\n      A mount message will be issued to the MVS system console, and\nthe operators will be instructed to mount the tape.  Once mounted, the\ntape is positioned to the beginning of the data in the cataloged file.\n\n      Entering successive REVIEW subcommands will cause the tape to be\nappropriately positioned, and REVIEW behaves similarly to the way it\ndid for a disk file.\n\n      Uncataloged standard-labeled tape files can be REVIEWed by a TSO\nuser who has the MOUNT attribute, if the UNIT and VOLUME parameters are\nused in the ALLOCATE command for the tape file.  This is OK as long as\nthe file sequence number is 1.  Greg Price supplies a CLIST for the\npurpose of REVIEWing tape files whose file sequence number is not 1.\nThis CLIST comes on Greg's CBT Tape File 134 under the name REVTAPE.\nThe idea of the CLIST is to exploit the POSITION parameter of the\nALLOCATE TSO command for tape files.  Please see Figure Four for a\ncopy of Greg's REVTAPE CLIST, and notice his comments there.\n\n      Greg Price's REVIEW has more power than we have described, and\nit is very much worth a good look from every MVS sysprog.  I hope that\nour introduction will stimulate your creativity, and that this useful\nprogram will help your shop.  Good luck.  See you next month.\n\n\n\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n\nFIGURE ONE.  MECHANICS OF THE REVIEW MEMBER LIST.\n\n              Illustration of REVIEW partitioned dataset member list,\n              sorted in various ways.  Note that the \"LOCATE\" field\n              has 8 characters for positioning the list, and for\n              command input.  Command input in the LOCATE field\n              must be preceded by an equal sign.  Only currently\n              supported commands from the LOCATE field are\n              =OFFLOAD and =REFRESH.  An \"S\" LINE COMMAND next\n              to a member name will REVIEW the member.  If ISPF\n              is active, then \"B\" will BROWSE the member, and\n              \"E\" will EDIT it.  \"O\" next to a member will flag it\n              after enter is pressed, for offloading using =OFFLOAD.\n              Member list PFKEY instructions are shown on the\n              second line.\n\n\nTSTBSSG.A.DATA ------------------------------------------ 818 MEMBERS ON TSO001\nLOCATE ===>          1-TOP 2-BOT 3-END 4-SD 6-SN 7-UP 8-DN 9-SSZ 10-STTR 11-SID\n   NAME        TTR     VV.MM  CREATED  LAST MODIFIED  SIZE  INIT   MOD   ID\n  A           008F08   01.00 88/10/27 88/10/27 09:00   347   347     0 TSTBSSG\n  AA          008E0F   01.13 89/02/30 89/05/08 10:57   363   363    15 TSTBSSG\ns ABEDOC      009E03   01.00 89/06/12 89/06/12 16:46    20    20     0 TSTBSSG\n  ABENDAI1    005912   01.02 90/01/07 90/02/03 13:32    44    44     3 TSTBSSG\n  ACNTLPW     001B09   01.01 87/02/04 89/07/16 19:08    61    60     1 TSTBSSG\n  ACTRT       008B17   01.00 90/03/05 90/03/05 11:26   721   721     0 TSTBSSG\n  ADSOXREF    008B01   01.00 89/11/03 89/11/03 07:43   265   265     0 TSTBSSG\n      - - - - - - - - - - - - - -  CONTINUED  - - - - - - - - - - - - - - - -\n  ZFMANUAL    001708   01.01 88/01/24 88/01/24 11:40  2933  2925     0 TSTBSSG\n  **END** MOD 019505       1990/02/06-TSO001        185460 IBMOSVS2\n\n\n\n\nSORTED BY MODIFICATION DATE/TIME ------------------------ 818 MEMBERS ON TSO001\nLOCATE ===>          1-TOP 2-BOT 3-END 4-SD 6-SN 7-UP 8-DN 9-SSZ 10-STTR 11-SID\n   NAME        TTR     VV.MM  CREATED  LAST MODIFIED  SIZE  INIT   MOD   ID\n  DLOG        01940A   01.99 89/12/01 90/08/01 22:23   320   194     0 TSTBSSG\nb SHB         01910B   01.99 88/08/22 90/08/01 22:08  1471    41     0 TSTBSSG\n  PDSJUST     01900D   01.01 90/07/25 90/07/26 00:54   451   436     0 TSTBSSG\n  TSOFILES    01900A   01.00 90/07/25 90/07/25 12:47    63    63     0 TSTBSSG\n  PDS84F      018F0A   01.01 90/07/23 90/07/23 18:14   495   495     0 TSTBSSG\n      - - - - - - - - - - - - - -  CONTINUED  - - - - - - - - - - - - - - - -\n\n\n\n\nSORTED BY TTR ------------------------------------------- 818 MEMBERS ON TSO001\nLOCATE ===> =offload 1-TOP 2-BOT 3-END 4-SD 6-SN 7-UP 8-DN 9-SSZ 10-STTR 11-SID\n   NAME        TTR     VV.MM  CREATED  LAST MODIFIED  SIZE  INIT   MOD   ID\n  XYZZ        00050F   01.03 85/07/18 85/07/23 11:37     8     1     0 TSTBSSG\n  CP248INV    000511   01.00 88/10/27 88/10/27 09:00     1     1     0 TSTBSSG\ne DLOG8507    000513   01.00 85/08/09 85/08/09 17:46   217   217     0 TSTBSSG\n  USREXT2     00051A   01.00 87/08/17 87/08/17 18:10    28    28     0 TSTBSSG\n  USREXT2N    00060C   01.00 87/08/17 87/08/17 18:10    29    29     0 TSTBSSG\n      - - - - - - - - - - - - - -  CONTINUED  - - - - - - - - - - - - - - - -\n  SHB         01910B   01.99 88/08/22 90/08/01 22:08  1471    41     0 TSTBSSG\n  DLOG        01940A   01.99 89/12/01 90/08/01 22:23   320   194     0 TSTBSSG\n  **END** MOD 019505       1990/02/06-TSO001        185460 IBMOSVS2\n  (Note:    DS1LSTAR.   Create date.  Vol.  Total of size. )\n\n\n\n\nSORTED BY SIZE ------------------------------------------ 818 MEMBERS ON TSO001\nLOCATE ===>          1-TOP 2-BOT 3-END 4-SD 6-SN 7-UP 8-DN 9-SSZ 10-STTR 11-SID\n   NAME        TTR     VV.MM  CREATED  LAST MODIFIED  SIZE  INIT   MOD   ID\n  NAS         00E10A   01.00 89/05/23 89/05/23 08:27 23682 23682     0 NASPA\n  NASMSGA     00AA02   01.00 89/01/10 89/01/10 14:21 12665 12665     0 NASPA\n  PROCOMM1    005B03   01.00 87/12/20 87/12/20 12:07  6825  6825     0 TSTBSSG\n  PZAPPIT     01400C   01.00 89/10/13 89/10/13 08:56  4047  4047     0 TSTBSSG\n  CT515       008203   01.00 88/10/27 88/10/27 09:06  4017  4017     0 TSTBSSG\n      - - - - - - - - - - - - - -  CONTINUED  - - - - - - - - - - - - - - - -\n\n\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE TWO.  ILLUSTRATION OF REVIEW-DATA MODE.\n\n              This shows the REVIEW of some data.  The actual data\n              is unrelated to REVIEW (but it may be instructive to\n              veteran PDS users).  Our purpose is to show the\n              REVIEW HEADER.  Note the COMMAND area where most\n              subcommands will be entered.  Also notice the SCROLL\n              amount.\n\n\n\n\nTSTBSSG.A.DATA(OLDPTFS) - 01.00 ----------------------- LINE 000001 COL 001 080\nCOMMAND ===>                                                     SCROLL ===> CS\n1       10        20        30        40        50        60        70        80\n+---+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+\n\n     ISPMODE table follows:\nPDS -- VERSION 8.4\n\nDISP UNIT     RECFM LRECL BLKSIZE   ALLOCTRK FREETRK SECONDARY FREEDIR\nSHR  3380     FB       80    3120   3X  4200      89   300 TRK    1224\n\nENTER OPTION -- DSN=TSY2.SMPPTS,VOL=SER=SMP001  MEM=UZ60:UZ69999\n>outcopy\n          COPY OUTDD=OUTPUT,INDD=SMPPTS\n          S M=UZ65005, UZ65005))\n          S M=UZ65007, UZ65007))\n          S M=UZ65008, UZ65008))\n          S M=UZ65034, UZ65034))\n          S M=UZ65039, UZ65039))\n  - - - - - - - - - - - -  DATA  CONTINUED  - - - - - - - - - - - -\n\n\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE THREE.   REVIEW HELP SCREEN FOR PFKEYS.\n\n                 This screen may be entered any time the user is\n                 looking at a dataset.  The \"KEYS\" command or a\n                 question mark \"?\" will invoke this panel.  An\n                 invalid command, such as \"U\", will return the\n                 user to REVIEWing the dataset.\n\n\n\nTSTBSSG.A.DATA(OLDPTFS) - 01.00 ----------------------- LINE 000001 COL 001 080\nCOMMAND ===>                                                     SCROLL ===> CS\n1       10        20        30        40        50        60        70        80\n+---+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+\n\n                             CURRENT PF KEY VALUES\n                             ---------------------\n         PFK01   HEL\n         PFK02   ASCII\n         PFK03   END\n         PFK04   SMF\n         PFK05   FIND\n         PFK06   FULL\n         PFK07   UP\n         PFK08   DOWN\n         PFK09   HEX\n         PFK10   LEFT\n         PFK11   RIGHT\n         PFK12   RECALL\n\n                 USE 'HEL' COMMAND OR PF-KEY FOR FULL-SCREEN TSO HELP\n\n\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE FOUR.   GREG PRICE'S CLIST FOR REVIEWING DATA ON TAPES.\n\n                This CLIST is needed for looking at tape files that\n                do not have a file sequence number of 1.  One can\n                see from Greg's comments that the REVIEW command can\n                open new horizons to the programmer.\n\n\n\nPROC 1 DSN VOLSER(REVIEW) UNIT(TAPE) LBL(BLP) FSN(1) PTF\nCONTROL NOFLUSH\n/*\n/*  CLIST TO SEE WHAT IS ON A TAPE VOLUME.\n/*\n/*  UNLESS AUTOMATIC VOLUME RECOGNITION IS EXPLOITED, USERS WITHOUT THE\n/*  MOUNT ATTRIBUTE WILL NOT GET VERY FAR.  CATALOGUED TAPE DATA SETS\n/*  CAN BE REVIEWED DIRECTLY WITHOUT THIS CLIST.  UNCATALOGUED\n/*  STANDARD LABELLED DATA SETS CAN ALSO BE REVIEWED DIRECTLY WITHOUT\n/*  THIS CLIST BY SPECIFYING UNIT AND VOLUME ON THE COMMAND, ONLY AS\n/*  LONG AS THE FILE SEQUENCE NUMBER IS ONE (1).  THIS CLIST CAN BE\n/*  USED TO REVIEW TAPE LABELS AS WELL AS TAPE DATA FILES.\n/*\n/*  IN THE EVENT OF ANY ABNORMAL TERMINATION WHICH FLUSHES THE CLIST,\n/*  REVFILE WILL NOT BE FREED, SO PLEASE ENSURE THAT YOU DO NOT\n/*  UNNECESSARILY HOG A TAPE DRIVE.\n/*\nIF '&LBL' = 'SL' OR '&LBL' = 'AL' THEN GOTO NOATTR\nIF &PTF =   THEN ATTR REVATTR DSORG(PS) BLKSIZE(32760) RECFM(U)\n   ELSE ATTR REVATTR DSORG(PS) BLKSIZE(7200) RECFM(F B) LRECL(80)\nALLOC FILE(REVFILE) DA(&DSN) USING(REVATTR) UNIT(&UNIT) LABEL(&LBL)  -\n      VOLUME(&VOLSER) POSITION(&FSN) SHR REUSE\nFREE ATTR(REVATTR)\nGOTO REVIT\n                           /* USE DCB INFORMATION FROM TAPE LABELS. */\nNOATTR:  -\nALLOC FILE(REVFILE) DA(&DSN) UNIT(&UNIT) LABEL(&LBL)  -\n      VOLUME(&VOLSER) POSITION(&FSN) SHR REUSE\nREVIT: REVIEW REVFILE FILE\nFREE FILE(REVFILE)\nEND\n\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9012DE": {"ttr": 7686, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93!\\x0f\\x00\\x93!\\x0f\\x145\\x01o\\x01o\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "1993-07-29T14:35:00", "lines": 367, "newlines": 367, "modlines": 0, "user": "SBGCSC"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         December 1990\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n\n\n\"THE ARCHIVER\" PART I - A NEW PRODUCT AND CONCEPT.\n\n      Hold onto your hats, folks.  This month, we've got something\nnew and amazing for systems programmers to talk about.  It's a\nsoftware package called, \"The ARCHIVER\".\n\n      \"The ARCHIVER\" has a \"new idea\", or perhaps we can call it \"an\nold idea done in a novel way\".  The new technique that \"The ARCHIVER\"\nmakes possible for us, will have far-reaching consequences for the\nway we sysprogs do our jobs.  A whole new opportunity will be opened\nup.\n\n      People who follow this column regularly should pay close\nattention this month.  It is probable that in the near future, the CBT\nMods Tape will be converted to and distributed in \"ARCHIVER\" format.\nA current-sized CBT tape will then fit into less than half of a\ncartridge.\n\n      \"The ARCHIVER\" was written, and is being constantly improved\nupon, by Rick Fochtman, who lives in the Chicago area.  \"The ARCHIVER\"\ncan dump ALL of a system programmer's software tools (source, load\nmodules, CLISTs, etc.) INTO ONE VSAM FILE, in a very compressed form.\nThat file can then be offloaded to a tape, VERY COMPACTLY.  Individual\nitems or groups of items can be flexibly selected from either the VSAM\n\"ARCHIVE\" cluster or the \"ARCHIVE\" tape and loaded directly into a\nstandard partitioned dataset or sequential file.\n\n      The level of \"The ARCHIVER\" about which I am writing is Version\n4.0 or higher.  \"The ARCHIVER\" was heavily reworked at the 4.0 level.\nEarlier versions of \"The ARCHIVER\" do not have the Huffman data\ncompression feature and the current easy-to-use control card format.\nIf you are using an earlier version of \"The ARCHIVER\", the old files\nare easily convertible to 4.0 format.  \"The ARCHIVER\" has a \"CONVERT\"\ncontrol statement, and is intended to remain upwardly compatible.\n\n      By the time you are reading this, \"The ARCHIVER\" Version 4.0\nor higher will be available on the current CBT tape, starting at\nCBT Tape version 321.  Watch out for it!\n\n\nTHE ARCHIVER'S ORIGINAL REQUIREMENTS.\n\n      Rick Fochtman is a systems programmer who wanted to put ALL his\nsoftware tools into ONE place.  A programmer's tools can be in the\nform of source code, object code, load modules, or data.  These\ndifferent data types cannot normally be stored in one single dataset.\nRick wanted to invent ONE DATASET that would contain any or all of\nthis data, stored together.\n\n      Another problem.  Several versions of the same program might be\nkept around because of some need.  You might be enhancing the program\nand you have \"the old reliable version\" plus \"several new versions\nunder test\".  How does one supply \"version number support\" for each\ncopy?\n\n      One might want to include comment data and \"crib notes\" in one's\nsoftware collection.  We use that info to jog the memory.\n\n      It sounds tough to satisfy all these requirements with a single\nproduct solution.  Rick has succeeded.  Rick chose to use VSAM for his\nproduct's data storage vehicle, because he felt that VSAM was IBM's\ndata management direction for the future.  Rick's product can store\nvarious kinds of data IN ONE SINGLE VSAM CLUSTER.\n\n\nA QUICK OVERVIEW OF ARCHIVER FUNCTIONING.\n\n\n       Rick chose a five-leveled name key that would solve several\nproblems.  First, one could distinguish a source program from a load\nmodule having the same name.  Also, one could keep various\nmodification levels of same-named source or load modules completely\nseparate from one another.  With this scheme, it is trivial to\nseparate same-named items that come from completely different\noriginating sources.  Everything is stored together in the same\n\"ARCHIVE\" dataset.\n\n      Here's a short description of how the keys work.  The first four\nkeys can each contain a 10-byte name, with the first key being\nspecial.  It corresponds to the original item's \"member\" name.  The\nother three keys are used to further qualify the data by type, or by\ntelltale descriptors of the user's choosing.  The second, third, and\nfourth keys are officially called:  \"group\", \"subgroup\", and \"type\"\nrespectively.  The fifth key is a numeric version number that can go\nfrom 1 to a large number (16 Meg).  All of these key components are\nhandled by the service functions of the \"ARCHIVER\" program.\n\n      Now how about the data that corresponds to each key?  There\nare two components to the data.  There is the actual data, and there\nare optional user comment records to describe the nature and origins\nof the data.\n\n      How are all of these various data records stored?  The data that\ncorresponds to each key is stored across control intervals of the VSAM\ncluster, no matter what the data type.  Directory information that\nwould be necessary to reconstitute the item as a pds member, is\ngathered before the data is stored.  The directory information is\nstored together with the data.  For example, load module structure,\nalias information, and overlay note lists are preserved and stored\nbefore a load module is \"archived\".  ISPF statistics and other\ndirectory user information are preserved for source-type data and\nstored together with that data.  The \"archive process\" also keeps\ntrack of DCB attributes in the original dataset.  All this information\nis later used to restore \"archived\" data to its original condition.\n\n      The ordinary IDCAMS EXPORT function will make an \"ARCHIVE\"\nVSAM cluster transportable to another system or to another disk pack.\nIDCAMS EXPORT will back up THE ENTIRE ARCHIVE VSAM FILE as one entity.\nHowever, Rick also has provided his own \"item-by-item EXPORT\"\nfunction.\n\n      Rick's \"ARCHIVER EXPORT\" function is part of The ARCHIVE\nproduct, and is different from IDCAMS EXPORT.  A tape created by\nRick's ARCHIVER EXPORT function, is also organized by key, but items\nare directly selectable from the tape.  You can pick a part of your\ncollection to be restored, a piece at a time.  With Rick's ARCHIVER\nEXPORT to tape, you will not need the VSAM cluster any more.\n\n      Rick added data compression algorithms that compressed the data\nas it was being stored.  His latest version deletes repeated\ncharacters, and then uses the \"Huffman Tree\" algorithm, which attains\na large compression ratio.  Rick's \"EXPORT\" function, which copies an\n\"ARCHIVE\" cluster to tape, preserves the data on tape as compressed in\nthe cluster.  The storage efficiency achieved, borders on the\nenormous.\n\n      An immediate \"vast improvement\" possibility is to put IBM\n\"Optional Materials\" program source on ARCHIVER tapes.  Not only will\nindividual programs be selectable by NAME and by PRODUCT LEVEL, but\nthe whole collection will take up far less tape and will be much more\ncompact and usable.\n\n\n\"ARCHIVER\" FUNCTIONS.\n\n      How do \"The ARCHIVER\" service functions work?  If you have\nsoftware items to archive, you must allocate a suitable VSAM \"archive\"\ncluster on disk first.  (See Figure One for sample IDCAMS statements\nto do so.)  Then you \"UNLOAD\" items into the cluster as you want to\narchive them.  You do not have to care about data type.  The ARCHIVER\ntakes care of almost all data types.  The ARCHIVER dynamically\nallocates all the files, too.  The only restriction (currently) is\nthat all dynamically allocated files have to be cataloged.  The \"SET\"\ncontrol statement is used to bring about the dynamic allocation of a\nfile.\n\n      When you want to get your software or data back, you merely\npoint to the \"archive cluster\" with a \"SET\" control statement, point\nto a target pds or sequential dataset with another \"SET\" statement,\nand \"LOAD\" selected items into the target dataset or library.  \"The\nARCHIVER\" dynamically allocates all the files.  This is simple, neat,\nand easy.\n\n      An \"ARCHIVER\" item-selectable tape is not just a tape backup for\nthe VSAM cluster.  The tape can be used to restore data directly to a\nnon-VSAM dataset, without need of the original VSAM archive.  You can\ncreate an item-selectable ARCHIVER tape using the \"EXPORT\" function of\n\"The ARCHIVER\".  Merely use the proper \"SET\" statements, and \"EXPORT\"\nthe items you want to select.  The \"IMPORT\" control statement performs\nan opposite function to \"EXPORT\", loading items from the item-selectable\nARCHIVE tape back into an ARCHIVE cluster.  Figure Two will give some\nexamples for doing these functions.\n\n      To get your non-VSAM data back from an ARCHIVER item-selectable\ntape, just use the \"LOADT\" control statement with the proper \"SET\"\nstatements to point to the files.  Merely select the items you want to\nget back.  See Figure Three for an example.\n\n      You can find out what items are on a VSAM ARCHIVE cluster using\nthe \"LIST\" control statement.  Again, files are pointed to, using the\nproper \"SET\" statements, and The ARCHIVER dynamically allocates them.\nThe \"LISTT\" control statement will perform the same function for\nan item-selectable ARCHIVE tape.  An example is shown in Figure Four.\n\n      Selected items can be deleted from an ARCHIVE VSAM cluster using\nthe \"DELETE\" control statement, pointing to the selected items.  Item\nkey entries can be changed within an ARCHIVE VSAM cluster by means of\nthe \"ALTER\" control statement.\n\n      Items can not be deleted from a tape file, but they may be\nselected from the \"archive\" tape for reload to the VSAM cluster\n(\"IMPORT\" control statement) or to a dataset (\"LOADT\" control\nstatement).\n\n      A simplified format of ARCHIVER control statements is:\n\n      statemnt  ITEM=(member,group,subgroup,type,version)\n                                        ,DSN=dataset.name\n                                        ,DDN=ddname\n\nThe version parameter is usually left out.  If a same-named member\nalready exists on the VSAM archive cluster, The ARCHIVER merely saves\nthe new copy and increases the version number of the second copy by\none automatically.  The thinking is, that it's easier to delete a\nmember later, than to try and recover a lost or overlaid member.  If\nthe version number is specifically stated in the \"ITEM\" keyword, then\nthe default is to overlay an existing member on the ARCHIVE cluster\nthat has the exact same five keys.\n\n      Member, group, subgroup, and type may contain the wildcard\nindicator, asterisk (*) or the wildcard placeholder, percent sign (%).\nThese have their usual meanings.  The statement:\n\n         ITEM=(*,*,*,*)\n\nmeans that all items are selected.\n\n      Comment material can be associated with any item or group of\nitems using the \"ADDNOTE\" control statement.  The general format of\nall the control statements (except for \"SET\") follows the pattern\nstated above.\n\n\nTO BE CONTINUED.\n\n      We've seen the basic externals of what \"The ARCHIVER\" is set up\nto do.  We've seen how we can get it to hold our data and move it to\nan archive tape.  Next month, I'd like to follow up with some more\npractical details, and I'll describe some real examples and evidence\nof how all of us can employ and exploit this new tool.\n\n      Hope you found all of this interesting.  Good luck.  See you\nnext month.\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure One.\n\n\n//TSTBARCH JOB (TS,2322),'TECH.SUPP-SAM.GOLOB',CLASS=M,NOTIFY=TSTBSSG,\n//        MSGLEVEL=(1,1),MSGCLASS=T TYPRUN=HOLD\n//******************************************************************//\n//*   JOB TO DEFINE AN ARCHIVE VSAM CLUSTER - SAMPLE PARAMETERS    *//\n//******************************************************************//\n//IDC      EXEC  PGM=IDCAMS,REGION=4096K\n//SYSPRINT DD    SYSOUT=*\n//SYSIN    DD    *\n  /*-----------------------------------------------------------*/\n  /* CHANGE THE VALUES FOR THE VARIOUS NAMES AND THE VOLSER    */\n  /* TO FIT YOUR INSTALLATION BEFORE TRYING TO RUN THIS JOB    */\n  /*-----------------------------------------------------------*/\n         DEFINE CLUSTER(NAME(TST.SYS22305.ARCHIVE) -\n                RECORDSIZE(200 32000)              -\n                VOL( WORK02    )                   -\n                BUFFERSPACE(262144)                -\n                KEYS(49 0))                        -\n          DATA(NAME(TST.SYS22305.ARCHIVE.DATA)     -\n                CONTROLINTERVALSIZE(24576)         -\n                CYLINDERS( 100 100 ))              -\n          INDEX(NAME(TST.SYS22305.ARCHIVE.INDEX)   -\n                CONTROLINTERVALSIZE(8192)          -\n                CYLINDERS( 10 10 ))\n/*\n//\n\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure Two.    \"ARCHIVER EXPORT\" and \"ARCHIVER IMPORT\" Jobs to move\n               \"archived\" data between the VSAM archive cluster and\n               the item-selectable EXPORT tape.\n\n\n//TSTBARCV JOB (TS,2322),'TECH.SUPPORT',CLASS=M,NOTIFY=TSTBSSG,\n//        MSGLEVEL=(1,1),MSGCLASS=T TYPRUN=HOLD\n//******************************************************************//\n//*    Archiver EXPORT Job  -  VSAM Cluster to Tape                *//\n//******************************************************************//\n//COPYSTEP EXEC PGM=ARCHIVER,REGION=5900K\n//STEPLIB  DD  DISP=SHR,DSN=TSTBSSG.ARCHV40.LOAD\n//SYSPRINT DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n//TAPE     DD DISP=(,CATLG),DSN=TST.SYS22305.ARCT,UNIT=CART,\n//    LABEL=(1,SL,EXPDT=99000)\n//SYSIN DD *\n SET VSAM1DSN=TST.SYS22305.ARCHIVE\n SET DDN=TAPE\n LIST    ITEM=(*,*,*,*)\n EXPORT  ITEM=(*,*,*,*)\n/*\n//\n\n\n//TST2ARCV JOB (TS,2322),'TECH.SUPPORT',CLASS=M,NOTIFY=TST2SSG,\n//        MSGLEVEL=(1,1),MSGCLASS=T TYPRUN=HOLD\n//******************************************************************//\n//*    Archiver IMPORT Job  -  Tape to VSAM Cluster                *//\n//******************************************************************//\n//COPYSTEP EXEC PGM=ARCHIVER,REGION=5900K\n//STEPLIB  DD  DSN=TST2SSG.ARCHV40.LOAD,\n//             DISP=SHR\n//SYSPRINT DD  SYSOUT=*\n//SYSUDUMP DD  SYSOUT=*\n//TAPE     DD  DSN=TST.PRIV001.ARCT,     <=== Item-selectable\n//             DISP=SHR                  <=== ARCHIVE EXPORT tape\n//SYSIN    DD   *\n*    Allocate VSAM \"archive\" cluster   (this is a comment)\n SET VSAM1DSN=TST.PRIVX01.ARCHIVE\n*    Allocate EXPORT tape\n SET DDN=TAPE\n*    Put all the items that were on the tape into the cluster.\n IMPORT  ITEM=(*,*,*,*)\n/*\n//\n\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFigure Three.  ARCHIVER Restore of a Library from an Item-selectable\n               \"ARCHIVE EXPORT\" tape.\n\n\n//TSTBARCV JOB (TS,2322),'TECH.SUPPORT',CLASS=M,NOTIFY=TSTBSSG,\n//        MSGLEVEL=(1,1),MSGCLASS=T TYPRUN=HOLD\n//******************************************************************//\n//*    Restore of SYS1.MACLIB from an Item-selectable Tape         *//\n//******************************************************************//\n//COPYSTEP EXEC PGM=ARCHIVER,REGION=5900K\n//STEPLIB  DD  DISP=SHR,DSN=TSTBSSG.ARCHV40.LOAD\n//SYSPRINT DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n//TAPE     DD DISP=SHR,DSN=TST.SYS22305.ARCT  <== Item-selectable tape\n//SYSIN DD *\n*    Allocate the EXPORT tape. It's non-VSAM but its allocate is\n*     syntaxed parallel to the way LOAD would be, from a VSAM archive.\n SET VSAM1DD=TAPE\n*    Allocate a PDS similar to SYS1.MACLIB and fill it from the tape.\n LOADT   ITEM=(*,MACLIB,*,*),DSN=TSTBSSG.SYS1.MACLIB\n/*\n//\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFigure Four.  Illustration of Listing ITEMS from an Item-selectable\n              ARCHIVE EXPORT Tape.\n\n\n//TSTBARCV JOB (TS,2322),'TECH.SUPPORT',CLASS=M,NOTIFY=TSTBSSG,\n//        MSGLEVEL=(1,1),MSGCLASS=T TYPRUN=HOLD\n//******************************************************************//\n//*    LISTT - Listing ITEMS from an Item-selectable Tape          *//\n//******************************************************************//\n//COPYSTEP EXEC PGM=ARCHIVER,REGION=5900K\n//STEPLIB  DD  DISP=SHR,DSN=TSTBSSG.ARCHV40.LOAD\n//SYSPRINT DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n//SYSIN DD *\n*   Dynamically allocate the \"ARCHIVE EXPORT tape\". Note it's Non-VSAM.\n SET DSN=TST.SYS22305.ARCT\n*   List all the ITEMS on the tape.\n LISTT   ITEM=(*,*,*,*)\n/*\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9101JA": {"ttr": 7937, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x93!\\x0f\\x01\\x00)\\x9f\\x11G\\x01\\x85\\x01\\x87\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 389, "newlines": 391, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          January 1991\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n\n\n\n\"THE ARCHIVER\" PART II - MORE ABOUT AN INTRIGUING NEW PRODUCT.\n\n      Last month, we introduced the new free product called \"The\nARCHIVER\".  The ARCHIVER stores and compresses non-VSAM data of almost\nany type, into one single VSAM cluster.  This compressed data is\nitem-by-item exportable, still compressed, onto a tape file.  All the\ndata can be faithfully reconstituted to its original form from either\nthe \"archive\" VSAM cluster or from the \"archive export\" tape.\n\n      \"The ARCHIVER\", originally designed as a vehicle for sysprogs to\nstore \"all their stuff in one place\", has the potential to eventually\nrevolutionize small-scale in-house backups, and to allow far more\nefficient packaging of software collections and products.\n\n      As a personal example, I have stored the contents of 274\nSMP-related pds libraries, and 15 large sequential datasets, in one\nVSAM \"archive\" cluster.  After reorganization, the VSAM cluster\noccupied around 10000 tracks of 3380 disk space.  The \"archive export\"\ntape, which contained all this data, occupied barely more than one and\na half 3480 cartridges.  My previous, less efficient IEBCOPY backups\ntook about eight cartridges on average.\n\n      \"The ARCHIVER\" Version 4.0 or above, can be obtained on a NEW\nCBT MVS Tape at version level 321 or higher.  The ARCHIVER is on\nFile 147.\n\n      Please use Version 4.0 or higher of The ARCHIVER, because The\nARCHIVER was extensively reworked at that level.  Previous versions\ndon't have the great data compression.  VSAM files created with\nprevious \"ARCHIVER\" versions are upwardly convertible using the\nCONVERT command of the current \"ARCHIVER\" version.\n\n      This month, I'll explain some further details of ARCHIVER\nworkings to add to what we said last month, and I'll show some more\nexamples.  I hope that you can exploit The ARCHIVER creatively for\nyour advantage, and to the advantage of your shop.\n\n\nA QUICK REVIEW.\n\n      The ARCHIVER is written by Rick Fochtman from Chicago.  It\nstores almost any kind of data in a VSAM cluster.   A stored data\nitem has 5 keys--the first four, member name, group, subgroup, and\ntype--have 10 characters apiece.  The last key, the version number,\nis a binary integer that ranges from 1 to a large value (16 Meg).\nKeyword parameters are used in almost all the control statements.\nIndividual entries are referred to as \"items\".\n\n      Storing an item in a VSAM Archive cluster is called UNLOADing.\nComments in a control statement start with an asterisk in column 1.\nDynamic allocation of required files is done either by a SET control\nstatement or a DSN or DDN keyword parameter.  We'll give an example.\nTo UNLOAD all members of a PDS into an archive, we may use control\nstatements such as:\n\n  SET VSAM1DSN=TST.SAMPLE.ARCHIVE\n  SET DSN=TST.OUR.SAMPLE.PDS\n  UNLOAD ITEM=(*,SAMPLEPDS,11/09/90,PRODUCTION)\n\nor more easily:\n\n  SET VSAM1DSN=TST.SAMPLE.ARCHIVE\n  UNLOAD ITEM=(*,SAMPLEPDS,11/09/90,PRODUCTION),DSN=TST.OUR.SAMPLE.PDS\n\nThese statements will cause all members of the dataset:\nTST.OUR.SAMPLE.PDS to be unloaded (and compressed) into the previously\ndefined VSAM cluster:  TST.SAMPLE.ARCHIVE .  See Figure One for a\ncomplete example.  See Figure Two for a list of ARCHIVER control\nstatements and what they do.  This material was discussed in detail\nlast month.  Now, we'll pick up where we left off, and we'll talk\nabout how The ARCHIVER dynamically allocates most of the files that it\nneeds.\n\n\nTHE ARCHIVER'S DYNAMIC FILE ALLOCATION.\n\n      File allocation when using The ARCHIVER is regulated by the\n\"SET\" control statement.  There are three forms of SET.  These are:\n\n      SET VSAM2DDN=ddname    or  SET VSAM2DSN=cluster name\n      SET VSAM1DDN=ddname    or  SET VSAM1DSN=cluster name\n      SET DDN=ddname         or  SET DSN=non-VSAM dsname\n\nVSAM2DDN or VSAM2DSN is used only in a situation when there are two\nclusters involved in the operation.  In that case, VSAM2D-N would\nrefer to the \"from\" cluster and VSAM1D-N would refer to the \"to\"\ncluster.  Examples are the \"COPY\" or \"CONVERT\" control statements.\n(\"CONVERT\" moves items from an old-format ARCHIVE cluster to a\ncurrent-format cluster.)  These operations copy or convert items from\none ARCHIVE cluster to a second.\n\n      During most other ARCHIVER operations, when only one VSAM\ncluster is involved, VSAM1DDN or VSAM1DSN is used to point to the\ncluster.\n\n      Non-VSAM datasets are always pointed to by SET DDN or SET DSN\nstatements.  Of course, a SET DDN statement must refer to a ddname\nspecified in your JCL.  A SET DSN statement will automatically invoke\ndynamic allocation to get to a cataloged non-VSAM dataset.  Currently,\nSET DDN statements pointing to ddnames, are the only way for The\nARCHIVER to get to non-cataloged non-VSAM datasets.\n\n      VSAM cluster values or non-VSAM dataset names that are specified\nby SET operands will remain in effect until overridden by another SET\noperand.  In addition, the VSAM2DDN, VSAM1DDN, DSN etc. statements can\nbe appended to the operands of any other ARCHIVER command.  For\nexample:\n\n       UNLOAD ITEM=(*,*,LINKLIB,*),DSN=TSTBSSG.TEST.LINKLIB\n\nwould be the equivalent of:\n\n       SET    DSN=TSTBSSG.TEST.LINKLIB\n       UNLOAD ITEM=(*,*,LINKLIB,*)                   .\n\nThat's pretty much the story when it comes to The ARCHIVER's dynamic\nallocation.  It's quite straightforward and simple.\n\n      Currently, there's one \"gotcha\" in the matter.  \"LOADT\", which\ncopies items from an item-selectable ARCHIVE tape dataset to a pds or\nsequential dataset, performs a similar function to \"LOAD\", which goes\nfrom a VSAM archive dataset to the non-VSAM dataset.  In other words,\n\"LOAD\" and \"LOADT\" are parallel functions.  Currently, the input to\n\"LOADT\" is the same as the input to \"LOAD\", namely VSAM1DDN or\nVSAM1DSN, even though the item-selectable tape dataset is not a VSAM\ndataset.  Normally, a VSAM1DSN statement would be inappropriate to\npoint to a non-VSAM dataset, and would cause an error.\n\n      If you would run a \"LISTT\" against the item-selectable tape\ndataset, VSAM1DSN or VSAM1DDN wouldn't work.  Since the dataset is\nreally non-VSAM, you need to use DSN or DDN to do the dynamic\nallocation for \"LISTT\".  This matter is somewhat confusing, but I\nthink it is the only significant \"SET\" control statement problem.\nRick may correct this situation in the future.  If he does, he will\ninform you.  This slight problem in use, is greatly outweighed by The\nARCHIVER's enormous data storage advantages.\n\n\nCHANGING EXISTING ENTRIES IN THE VSAM CLUSTER.\n\n      The ARCHIVER service functions can control entries in a VSAM\narchive dataset very closely.  The \"ALTER\" control statement, also\ntermed \"RESPECIFY\" in older ARCHIVER versions, accomplishes a renaming\nand re-keying service for archived items.\n\n      Syntax for ALTER is:\n\n   ALTER ITEM=(.......),NEW=(.......)\n\nwhere the NEW operand has the same syntax as the ITEM operand with an\nimportant exception.  In the NEW operand, generic characters such as\n\"*\" and \"%\" are treated as ordinary characters, and can be a part of\nthe key names.  Only the \"*\" character alone will be treated in the\nNEW operand as a generic, to signify that the corresponding old value\nwill remain unchanged.  \"RESPECIFY\" still remains a valid alias for\nthe ALTER control statement.\n\n      Let's give an example of how ALTER might be used.\n\n      Suppose two pds'es have been unloaded into an archive.  One of\nthem is SYS1.LINKLIB and the other is PPS.LINKLIB, a program product\nlibrary.  The UNLOAD statements might read:\n\n   UNLOAD ITEM=(*,SYS1LINKLB,11/15/90,MVSRES),DSN=SYS1.LINKLIB\n   UNLOAD ITEM=(*,PPSLINKLIB,11/15/90,VEND01),DSN=PPS.LINKLIB\n\n      You might want to change the some of the modules in PPS.LINKLIB\nto have a special designation.  Suppose all modules beginning with the\ndesignation \"ISR\" are to be singled out into a category called ISPF/PDF.\nOur ALTER statement might then read:\n\n   ALTER ITEM=(ISR*,PPSLINKLIB,*,*),NEW=(*,ISPF/PDF,*,*)\n\n      It is clear that a lot of item rearranging may be accomplished\nfrom within the VSAM archive, after many items have already been\nunloaded into it.\n\n      Because of key arrangement, however, CA and CI splits and\nspace expansion may occur through extensive use of ALTER.  If you are\nconstantly manipulating a VSAM archive file, it is wise to reorganize\nthe file frequently.  Normal IDCAMS EXPORT-IMPORT or REPRO functions\nmay be used to reorganize and compactify an actively used VSAM archive\ncluster.\n\n      Reorganization may also be necessary several times during many\nlarge UNLOADs into a VSAM archive.  You'll usually find that reorgs\nwill save you a lot of disk space, and will be helpful, especially if\nyou want a VSAM archive to stay around on disk for some time.\n\n\nADDING NOTES.  SPECIAL DOCUMENTATION THAT IS VERY CONVENIENT.\n\n      Any archived item is capable of having NOTEDATA attached to it.\nNotes can be added to individual items separately, or they can be\nadded generically.  Notes may be used to further qualify or clarify\nthe nature of the items being archived, and they can be of great\nconvenience to their creator, or to any user of the archive.\n\n      Notes in an archive can be shown with a LIST command, if the\nkeyword NOTE=YES is used.  NOTE=YES is not the default.\n\n      There is a small amount of learning necessary to use the NOTE\nfacility, and this concerns the input dataset, where the notes are\nfed into The ARCHIVER.\n\n      The note input dataset is an 80-byte card-image dataset, in\nwhich columns 73-80 contain key data for the notes.  Text data\nis in columns 1-72.  The key data is used to determine which note\nimages are appended to which items.  The data for many notes may be\nmixed up on one input file, but all is dependent on key values in\ncolumns 73-80.  Blanks in columns 73-80 constitute comments in the\nnote input data file.\n\n      Let's consider an example.  Suppose the ARCHIVER source pds\nhas been unloaded on the archive cluster TST.TEST001.ARCHIVE with\nthe statement:\n\n   UNLOAD ITEM=(*,ARCHIVE,UTILITY,SOURCE),DSN=TSTBSSG.ARCHV402.SOURCE\n\nWe want to mark all the resultant items in the archive with copyright\ninformation from the author.  This might be done with the statement:\n\n   ADDNOTE ITEM=(*,ARCHIVE,UTILITY,SOURCE),KEY=ARCHIVER\n\nAt this point, we don't know how KEY=ARCHIVER is fed in.  This comes\nfrom the note input file, which is allocated by a ddname, and a\ncontrol statement like:\n\n   SET DDN=NOTEFILE\n\nThe note file will have the word \"ARCHIVER\" in columns 73-80, opposite\nthe statements:\n\n----------------------------------------------------------------------  ARCHIVER\nTHIS IS A PART OF THE VSAM ARCHIVER PROGRAM, WRITTEN BY RICHARD         ARCHIVER\nA. FOCHTMAN, JR. AND COPYRIGHTED 1990.  EXCEPT WHERE NOTED, ALL         ARCHIVER\nPARTS OF THE ARCHIVER ARE REENTRANT, REUSABLE, AND REFRESHABLE.         ARCHIVER\n----------------------------------------------------------------------  ARCHIVER\n\nAll items in the archive which satisfy the addnote item qualifications,\nwill get the keyed remarks appended to them as notes.  These notes can\nbe listed by a statement:\n\n   LIST ITEM=(*,ARCHIVE,UTILITY,SOURCE),NOTE=YES\n\nNow the DYNAM program in the ARCHIVER source pds is public domain,\nand is therefore not copyrightable.  We can add an additional note\nto the DYNAM item, to say that DYNAM is public domain.  Please notice\nthat adding the additional note does not erase any old notes.  Old\nnotes must be completely deleted and then replaced.  Let's add the\nspecial note for the public-domain module with the keyword of \"DYNAM\"\nin columns 73-80 of the note input file, so that:\n\n******************************************************************      DYNAM\n* THIS PARTICULAR SUBROUTINE WAS OBTAINED FROM THE CBT MODS TAPE *      DYNAM\n* AND IS PUBLIC DOMAIN SOFTWARE, NOT SUBJECT TO COPYRIGHT.       *      DYNAM\n******************************************************************      DYNAM\n\nThis note might be added with the control statement:\n\n   ADDNOTE ITEM=(DYNAM,ARCHIVE,UTILITY,SOURCE),KEY=DYNAM\n\nso that the DYNAM item will have a note that reads:\n\n----------------------------------------------------------------------\nTHIS IS A PART OF THE VSAM ARCHIVER PROGRAM, WRITTEN BY RICHARD\nA. FOCHTMAN, JR. AND COPYRIGHTED 1990.  EXCEPT WHERE NOTED, ALL\nPARTS OF THE ARCHIVER ARE REENTRANT, REUSABLE, AND REFRESHABLE.\n----------------------------------------------------------------------\n******************************************************************\n* THIS PARTICULAR SUBROUTINE WAS OBTAINED FROM THE CBT MODS TAPE *\n* AND IS PUBLIC DOMAIN SOFTWARE, NOT SUBJECT TO COPYRIGHT.       *\n******************************************************************\n\n      You get the picture.\n\n\nA FEW \"UNOFFICIAL BENCHMARKS\".\n\n      I personally spent some hours testing \"The ARCHIVER\" before\nthe time of this writing.  I did an \"UNLOAD\" of 63 system libraries\ninto a VSAM archive on a work pack.  These included SYS1.LINKLIB on\nan XA 2.2.3 system, SYS1.LPALIB, SYS1.NUCLEUS, our company's program\nproduct library, SYS1.MACLIB, AMODGEN, panel libraries, PSF libraries,\nand so forth.  There were a total of over 15,000 non-alias items\nloaded.  Wall clock time for the whole thing on a heavily loaded 3090\nmodel 180 was about 2 hours and 44 minutes.\n\n      The VSAM ARCHIVE occupied 400 cylinders on a 3380 disk before\nit was reorganized, and 200 cylinders after it was reorganized.\n\n      The \"LIST\" function for all the items in this ARCHIVE was\nnear-instantaneous, taking 14 wall-clock seconds to list 15,938 items.\n\"LIST\" only has to read the VSAM header records for each item.\nThere are not too many EXCP's.\n\n      Creating an item-selectable \"ARCHIVE EXPORT\" tape from this\nARCHIVE took 47 minutes of wall clock time, to 3480 cartridge.  A\nTAPEMAP run (File 299 of CBT tape version 321) showed that the\ncartridge was almost exactly half full--253 feet was used for the\nbackup of all these libraries!  A full cartridge has about 500 feet,\nas measured by the TAPEMAP program.\n\n      A \"LISTT\" run to list the contents of the item-selectable\nARCHIVE tape, took about two minutes of wall clock time after the\ntape was mounted.  This was a cartridge.\n\n      A \"LOADT\" was done to restore all LINKLIB load modules from the\nitem-selectable ARCHIVE tape to a junk load library on a work pack.\nThis load library restore was followed by a csect compare to the\noriginal SYS1.LINKLIB.  It showed exact comparison and no loss of\nmembers or aliases except for two things which were normal:\ndifferent note-list ttrs in the overlay modules, and the restore of\norphaned aliases to non-alias status.  To me, that restore sounds\nlike a success.\n\n      I restored the archived members of SYS1.FONTLIB (PSF fonts)\nfrom the archive tape to a junk disk copy of the library.  I got\nan exact match, and no loss of members.\n\n      Restore of SYS1.MACLIB produced an exact compare.\n\n      This isn't bad.\n\n\nFUTURES.\n\n      Rick Fochtman is planning a whole series of enhancements for\nThe ARCHIVER product.  To be fully informed, order new CBT tapes,\nlook at File 147, and keep in touch with Rick or with me.  We hope\nthat soon, the CBT Tape itself will be converted to ARCHIVER\nitem-by-item EXPORT format on tape, because of the great compression\nfactor, and the uniformity in storing items from diverse sources.\n\n      I hope you found this interesting and useful.  If you use the\nCBT tapes, it will definitely be useful.\n\n      Good luck.  See you next month.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFIGURE ONE.   Sample ARCHIVER Job to UNLOAD all members of partitioned\n              dataset TSTBSSG.ARCHV402.SOURCE into VSAM archive\n              dataset TST.TEST001.ARCHIVE .\n\n\n//TST2ARCV JOB (TS,2322),'TECH.SUPPORT',CLASS=M,NOTIFY=TSTBSSG,\n//        MSGLEVEL=(1,1),MSGCLASS=T TYPRUN=HOLD\n//*\n//COPYSTEP EXEC PGM=ARCHIVER,REGION=5900K\n//STEPLIB  DD  DISP=SHR,DSN=TSTBSSG.ARCHV40.LOAD\n//SYSPRINT DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n//DISKA    DD DISP=SHR,DSN=TST.TEST001.ARCHIVE\n//SYSIN DD *\n SET VSAM1DD=DISKA\n UNLOAD ITEM=(*,ARCHIVER,UTILITY,SOURCE),DSN=TSTBSSG.ARCHV402.SOURCE\n/*\n//\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFIGURE TWO.  ARCHIVER Control Statements and their Function.\n\n  ADDNOTE   -   Append comment notes to an item from a note file.\n  ALTER     -   Change item key entries for data in a VSAM archive.\n  CONVERT   -   Convert entries from an old-format archive to current.\n  COPY      -   Copy items from the VSAM2 Cluster to the VSAM1 Cluster.\n  DELETE    -   Delete items from a VSAM archive cluster.\n  EXPORT    -   Item-by-item export from VSAM cluster to sequential ds.\n  IMPORT    -   Reverse of EXPORT.  Sequential export ds to cluster.\n  LIST      -   Show items on a VSAM archive cluster.\n  LISTT     -   Show items on an ARCHIVER item-by-item EXPORT seq. ds.\n  LOAD      -   Reconstitute a pds or sequential dataset from archive.\n  LOADT     -   Reconstitute same, from the EXPORT tape or seq. ds.\n  SET       -   Point to ddname or dsname for dynamic allocation.\n  UNLOAD    -   Archive an item from a non-VSAM dataset to VSAM archive.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9102FE": {"ttr": 7944, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x93!\\x0f\\x00\\x94#\\x1f\\x079\\x00\\xdd\\x00\\xe0\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "1994-08-19T07:39:00", "lines": 221, "newlines": 224, "modlines": 0, "user": "SBGCSC"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          February 1991\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n\n\n      As of this writing, I've now spent several months editing the\nCBT MVS Tape.  I can begin to appreciate the great job that Arnie\nCasinghino has done managing that tape over the last fifteen years,\nand his long-term dedication to us all.  Thanks again, Arnie.  We owe\nyou something we can never fully repay.\n\n      This month, we'll describe a CLIST format conversion program\ncalled CVTCLIST, which is found in its latest incarnation on the CBT\nMVS Tape, File 187.  When you need it, CVTCLIST saves you enormous\namounts of labor, and it gives your shop a freedom you've never\nthought possible.\n\n      CVTCLIST is an ancient program.  Bob Collins of Chicago got it\nto work under MVS in the mid-70s, and put it on the CBT tape then.\nCVTCLIST had some famous bugs when converting CLIST libraries from VB\nto FB format.  I made a big effort to fix those bugs about a year ago,\nand have now improved the program more, calling the current version\n(as of this writing) Version 2.1.\n\n      The CVTCLIST program converts entire libraries of CLISTs from\n80-byte fixed blocked format to 255-byte variable blocked format.\nMore importantly, it can convert the other way too.  The current\nversion of CVTCLIST accurately folds long lines of executable data\nwhen converting from VB-255 format to FB-80.  Therefore, CVTCLIST\naffords a data center freedom from being tied down permanently to any\none of these formats.\n\n      Version 2.1 of CVTCLIST can be found on File 187 of Version 322\nor higher of the CBT Tape.  The CBT Tape can be obtained either from\nNaSPA (414) 423-2420, or from Fred Robinson of the Share Program\nLibrary Agency (305) 284-6257.\n\n\nA QUICK OVERVIEW OF THE TWO CLIST FORMATS.\n\n      CLISTs are programs which run under TSO.  CLISTs can execute\nTSO commands or other programs in the foreground.  CLIST programs are\nreally files that are interpreted by the CLIST language processor\nduring a TSO session.  The CLIST file is executed as a program either\nexplicitly using the \"EXEC\" TSO command, or implicitly if the file is\na member of a PDS, allocated to the \"SYSPROC\" ddname in your TSO\nsession.\n\n      Most installations provide public CLIST libraries for their\nTSO users.  These libraries are concatenated to the SYSPROC ddname\nby the installation, usually.  Sometimes, an installation's SYSPROC\nconcatenation will contain many hundreds of CLISTs, possibly thousands,\nin several different libraries.\n\n      IBM allows the CLIST language processor to accept as input,\nfiles in either 80-byte fixed blocked card-image format, or in\nvariable blocked format with record length equal to 255.  CLIST files\nin fixed blocked format can have sequence numbers in columns 73-80.\nData is ignored in those columns, when the record format is FB.  When\na CLIST is in variable blocked (or VB) format, columns 1-8 are ignored\nas data, and are used for sequence numbers.  You see that the two\nformats have incompatible sequence numbering.  The CLIST processor is\naware of the record format of its input file, and treats the sequence\nnumber columns accordingly.\n\n      We must say a word about the SYSPROC ddname concatenation of\nlibraries.  Libraries of CLIST files in this concatenation must be\neither ALL FB or ALL VB.  That is an MVS restriction.  MVS data\nmanagement looks at any concatenation of libraries and builds its one\ndata control block from the information in the first, or highest\nlibrary.  If that library is FB, MVS regards the whole collection as\nFB.  If it's VB, MVS looks at all the libraries as though they are VB.\n\n      Now we stated above that CLIST sequence numbering for FB CLISTs\nis incompatible with the numbering for VB clists.  It's obvious that\nmixed FB and VB libraries in one concatenation will cause serious\nCLIST execution problems.  Therefore, any installation which maintains\npublic SYSPROC concatenations must commit to either ALL FB or ALL VB,\nfor the record format.\n\n\nCONVERSION PROCEDURES - WHAT'S INVOLVED?\n\n      Until recently (even now) IBM has been restricted to distributing\nits own CLISTs in 80-byte FB format.  IBM's System Maintenance Programs\nSMP4 and SMP/E (before Release 5) could not accept variable blocked\nfiles for their automated installation processing.  Therefore, any shop\nwhose CLISTs were VB format had to convert IBM's FB CLISTs to VB before\nthey could be used.  I shall describe this quite laborious process.\nEven worse is the predicament of a shop that has VB CLISTs and which\nwants to back out.  I'll describe what's involved in that, too.  Then\nwe'll show how the CVTCLIST program will accomplish all these things\nautomatically, without any effort on the part of the programmer.\n\n      FB to VB conversion involves three things:  First, removal of\nall sequence numbering from columns 73-80 of each record in the file.\nSecond, conversion of the file from FB to VB format.  This means\nappending 4-byte record descriptor words or RDW's and block descriptor\nwords or BDW's to the logical records and physical blocks of data.\nThis also involves stripping trailing blanks off the ends of the\nvariable records.  Third, all meaningful data in each record must be\nshifted 8 bytes to the right.  Columns 1-72 now become columns 9-80.\nThis is to make sure that the data will be executable in the new\nformat, and also to make room for new sequence numbers in columns 1-8.\n\n      ISPF can be used to do the FB-VB conversion, and has been the\ntraditional method employed.  Actual FB-VB data conversion can be\ndone by the copy option 3.3.  The ISPF copy program does the proper\nprefixing of BDW's and RDW's and stripping of trailing blanks.  That's\nthe easy part.  The hard part is that each CLIST must then be edited\nindividually.  All numerics in columns 73-80 must be converted to\nblanks.  Then all lines must be shifted 8 columns to the right.\nFinally, each CLIST should be renumbered and the edit saved.  Some\nof this work might be automated through the use of ISPF edit macros.\n\n      A frequent problem in this method is that the person doing it,\nmight forget to remove the old sequence numbers from columns 73-80.\nAfter shifting to the right, these will appear in columns 81-88.  Upon\nexecution of the converted CLIST, the CLIST processor will mistake\nthese old sequence numbers for data, since they are not in columns\n1-8.  Serious execution errors will result.  It would be nice to\neliminate such spurious sequence numbers after the fact.  I call the\nprocess of eliminating numerics in columns 81-88 \"STRIPPING\".\n\n      IBM has provided a cumbersome CLIST called ICQSMC00 that does\nFB-VB conversion of a CLIST library.  When first distributed five\nyears ago, ICQSMC00 was full of bugs and it didn't even run.  People\ntell me that now it works.  It takes many minutes to execute,\nhowever.  ICQSMC00 only does FB-VB conversions, not VB-FB.  For\nVB-FB conversions, to my knowledge, IBM leaves you high and dry.\n\n      So now let us look at VB-FB.\n\n      What's involved?  There are again several steps.  Here, there\nis a judgment factor concerning how to fold a long data line into\nseveral short ones so it'll execute the same.  I had to make these\ndecisions when I was fixing the VB-FB algorithm in CVTCLIST, so I'll\ntell you how I decided to do it.  Please argue with me if you want to.\n\n      The steps are as follows:  Ignore BDW's and RDW's and the first\n8 columns of data.  Look at the length of the data that comes\nafterward.  If that data is 72 lines or less, write it as a fixed\nrecord starting in column 1, and pad to 72 columns with blanks.  If\nthe data line is longer than 72 bytes, split the data after column 71,\nplace a dash (continuation character) in column 72, and make a new\nrecord to continue spilling over the data, starting in column 1 of the\nnew record.  Continue this process until the data in the long line is\nexhausted.  Pad to column 72 of the last new record with blanks.\nOptionally supply sequence numbers in columns 73-80 of the new fixed\nrecords.\n\n      This is hard to do accurately with ISPF edit.  It may possibly\nbe done more conveniently using an edit macro.  Most shops with VB\nCLISTS will feel trapped if they have lots of CLISTs to convert.  So\nnow we're ready to show how the conversion program CVTCLIST comes to\nthe rescue.\n\n\nUSING THE CVTCLIST PROGRAM.\n\n      The CVTCLIST conversion program is extremely easy to use.\nThere is a SYSPRINT ddname for messages.  Input is to the SYSUT1\nddname.  Output is to the SYSUT2 ddname.  That's all.\n\n      When the program starts executing, it makes sure that the SYSUT1\nand SYSUT2 DCBs have different record formats.  If SYSUT1 is FB and\nSYSUT2 is VB, then the conversion goes FB-VB.  Similarly, if SYSUT1 is\nVB and SYSUT2 is FB, then the conversion goes VB-FB.  The conversion\nalgorithms in CVTCLIST are as described above, but in addition,\nsequence renumbering of the converted members is done.\n\n      A wrinkle was introduced with CVTCLIST Version 2.1.  Formerly,\nthe library that was the target of a conversion had to be empty.  Now,\nthe target conversion library can have members already there.  You\nhave control with parms in the execute statement.  No parm defaults\nto replace of existing member names.  A parm of \"NOREPLACE\" will\npreserve previously existing members in the target library, while\nadding all newly converted members that have new names.  CVTCLIST\nVersion 2.1 has full member-name level reporting, as well as a summary\nreport of totals.  See Figures One, Two, and Three for these reports.\n\n\n\"LITTLE THINGS\" TO CONSIDER.\n\n      The CVTCLIST program preserves the old directory entry of\nconverted members.  For example, if the original member had ISPF\nstatistics, they are copied over to the new member's directory entry.\nSometimes this can be awkward.  For example, if you're doing line\nsplits in a VB-FB conversion, the converted member will have more\nlogical records than the original member.  This increase of record\ncount would not be reflected in the new copied directory entry.\n\n      Therefore, CVTCLIST counts and reports the number of splits in a\nmember.  Then it tests the directory entry to see if it is in ISPF\nformat.  If it is, CVTCLIST adds the number of splits to the old\nrecord count, giving the true record count in the directory.  This is\na neat touch.\n\n      CVTCLIST Version 2.1 now supplies new sequence numbers\nincremented by 10000, which are \"agreeable\" with ISPF numbering\nconventions.\n\n      CVTCLIST Version 2.1 does not optionally do \"stripping\" of\nnumerics from VB CLISTS in columns 81-88 when converting them back to\nFB.  Nor does it report the possible need for \"bad sequence number\"\nstripping in existing CLISTs.  I'm considering implementation of\nthis feature in the future Version 2.2.  The feature might come in\nhandy for some shops (including mine).\n\n      Well anyway, I hope this discussion has provided some food for\nthought in the way CLISTs have been set up at your shop.  It'll\ncertainly help you in converting IBM's CLISTs if yours are VB.  If\nyour shop has had reservations about converting to VB (or even back to\nFB), knowledge and use of the CVTCLIST program will help in the\ndecision.\n\n      See you again next month.  Good luck.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9103MA": {"ttr": 8193, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93!\\x0f\\x00\\x93!\\x0f\\x17G\\x00\\xff\\x00\\xff\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "1993-07-29T17:47:00", "lines": 255, "newlines": 255, "modlines": 0, "user": "SBGCSC"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                            March 1991\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n\n\nPUBLIC SOFTWARE TAPES REVISITED.\n\n      It is important to recognize the need for \"eyes and ears\" in\nassessing the workings of a computer system.  The three major IBM\nmainframe operating systems, especially MVS, have great complexity far\nbeyond the ability of most persons to grasp.  Working systems support\nprofessionals are normally put in the position of having to anticipate\nand diagnose problems from a vantage point of partial understanding.\nThe more one works in this field, the more apparent is the need of\nhaving many and varied good tools at one's disposal.\n\n      Many helpful tools come with hefty price tags.  A smaller shop\nsometimes feels forced to run \"partially blind\", because it cannot\nafford some of the expensive \"extra\" software utilities.  Even large\nshops can't buy tools that will cover every eventuality.  MVS in\nparticular, is too complicated to be completely covered, even by many\nexpensive vendor-supplied tools.  It seems that whatever you can get\nis not nearly enough.  There is always room for that one tool more.\n\n      Fortunately, the situation is not bleak.  Through the pooling\nof many people's efforts, and through a unique logistic situation:\nthe practical difficulty of marketing software for large mainframe\nmachines, much valuable effective software is available at a price\naffordable by any shop.  That price is less than one day's pay for a\nsingle programmer, plus a smidgen of programmer \"elbow grease\".\n\n      Let's explain the logistics first.  Suppose an installation has\nan operational problem for which it needs an immediate solution.  If\ncapable systems programmers are in their employ, management will most\nlikely allow time to develop a program or package that solves the\nproblem.  Once the package is up and running, company operations will\nbe happy, but the benefit will stop at the end of the company walls.\nHow can that installation derive further benefit from their\nprogrammers' efforts?\n\n      Most companies have their own businesses to run--they can't\nspend any time and effort selling and supporting their programmers'\nbrain-child.  Therefore, they'll gladly donate the package to others,\nin the hope of benefiting from other people's work similarly done to\nsolve other problems elsewhere.  This reality has given rise to an\nimmense pool of effective MVS-based software that is available to all\nfor the picking.\n\n      Where can these potential treasures be found?  There is an\nincreasing number of public tapes that are growing, not only in\nnumber, but in the effectiveness of their offerings.\n\n\nWHERE ARE SOME OF THE TAPES?\n\n      First in the general MVS operating system field is the\nimmense \"CBT MVS Tape\", run for 15 years by Arnold Casinghino of the\nConnecticut Bank and Trust Company in Hartford.  I am the CBT Tape's\ntemporary proprietor.  My brief experience at the helm, being forced\nto fathom the size of Arnie's work and the awesome contents of this\ntape, has inspired this month's column.  I hope to publicize these\ntapes' ability to help many shops.  The CBT MVS Tape may be ordered\nthrough NaSPA at (414) 423-2420, or from the Share Program Library\nAgency (SPLA) in Miami, Florida, at (305) 284-6257.  The \"secret of\ngreatness\" in the CBT Tape is that it is updated very frequently.\nThe CBT Tape contains many hundreds of software packages and programs.\nDepending on how it is used, and for which installation, I think that\nthe CBT Tape can be worth as much as a quarter of a million dollars in\nsoftware that doesn't have to be bought.\n\n      Next in consideration are the various tapes produced by several\nSHARE Committees.  These tapes are (to my knowledge) all publicly\ndistributable.  Most of them are not restricted to SHARE members.\n\n      Probably the most useful of the \"SHARE\" tapes is the JES2 tape,\ndistributed by Skip Robinson at (818) 507-3358.  The SHARE JES2 tape\ncovers all \"post-HASP\" JES2 releases, and contains a variety of tools\nand programming examples that will make any JES2 programmer drool.\nThe JES2 tape currently has at least 131 files containing software\npackages, and is worth a thorough look.\n\n      JES3 shops shouldn't feel completely left out.  A JES3 tape,\nproduced jointly by SHARE and GUIDE, is distributed by Alan Field,\nat (314) 839-7040.  One of the highlights of the JES3 Tape is the\nSpool Display Facility, an extremely complete package for browsing\nand managing the contents of JES3 Spool datasets.  Both the JES2\nand JES3 tapes abound with exits and coding examples.\n\n      SPLA also distributes a large variety of other tapes.  The\nSHARE PL/I committee has a PL/I SHARE Tape that is quite useful,\nwhich can be ordered from SPLA.  The SHARE CICS committee has\nprivately maintained a tape, which is currently being considered for\ngeneral distribution by SPLA (please inquire from SPLA).  The \"biggie\"\nfrom SPLA is their MVS tape, which is the official \"SHARE MVS Tape\".\nThe SHARE MVS Tape is very different from the CBT Tape.  It is much\nworth exploring on its own.  It generally has older material than\nthe CBT Tape has.\n\n      SPLA also houses a large variety of individual programs on\ntapes.  They publish a general catalog of their inventory.\n\n      NaSPA (the institution that supports this magazine) maintains\nits own public-domain tapes, the MVS VIP Tape and the VM/VSE VIP Tape.\nAsk the NaSPA Office (414) 423-2420 about ordering these.\n\n      The Los Angeles Users Group, a longtime MVS support group in\nSouthern California, produces its own rather large tape.  Inquire from\nTom Beuthin (310) 812-4421.\n\n      All of these tapes are updated more or less frequently with\nadditions and program fixes.  The CBT Tape is updated every three\nweeks or so, as contributions arrive.  The NaSPA tapes are updated\nthree times a year.  You should not feel that you have all the\nknowledge a tape can offer, if you don't renew it once in a while.\n\n\nA FEW EXAMPLES.\n\n      Let's see some example free offerings that cover areas of\n\"system doctor\" interest.  The \"LOOK\" TSO command, from File 264 of\nthe CBT Tape, allows a programmer to see almost any area of virtual\nstorage in any address space that is running in the system.  LOOK is\ncustomizable (through DSECT assemblies) so it can format any control\nblock that you'd like formatted.  It'll show you a real control block\nin actual storage, formatted field by field.  LOOK supports indirect\naddressing and memory of previous screens.  You can use LOOK to see\nunformatted virtual storage as well, and you can trace actual control\nblock chains on a running system.  I hope to devote next month's\ncolumn to a full treatment of LOOK.\n\n      We've looked at virtual storage.  What about looking at disk\nstorage?\n\n      Greg Price's version of the UCLA fullscreen ZAP TSO command\nallows you to look at any place on a disk pack, including Track 0\nand any IPL text.  All you need is to have one dataset on the pack.\nYou simply enter ZAP for a dataset on the pack.  (It doesn't have\nto be cataloged--there's a VOL keyword.)  After the dataset name (and\noptionally its VOLUME), you simply add the keyword, FULLVOL.  ZAP fools\nthe Data Extent Block that belongs to the dataset, so that it thinks\nthe whole pack encompasses the extents of the dataset.  You get into\nZAP at Track 0, Record 1, with a full screen looking at hundreds of\nbytes.\n\n      ZAP has 13 help screens at the touch of a \"?\" command.  Once\ninto ZAP in FULLVOL mode, you can get to any track by number, and to\nany record by number.  You can get to the VTOC with the command:\nVTOCDS4.  ZAP has a hex string search and and EBCDIC string search.\nWith the FULLVOL access, you haven't opened any dataset except for the\noriginal one, so that you can access any data on disk without the\nproblems of enqueue or any other burdens of \"open processing\".\nObviously, you don't want this program in the wrong hands, but in the\nhands of a systems surgeon, ZAP is a life-saver many times over.  This\nversion of ZAP can still be used for single dataset adjustments as\ncould previous versions.  Just leave the FULLVOL keyword out.  ZAP is\nobviously not read-only, so be extra careful.  This version of\nfullscreen ZAP is on File 134 of the CBT Tape.\n\n      We've looked at virtual storage and disk storage.  What about\ndatasets?  The all-time favorite non-VSAM dataset package still\nin the public domain is the \"PDS\" TSO and ISPF product.  \"PDS\" has\na vendor-supported successor (called PDS/E Sysprog Utilities) that's\nbetter, but \"Public PDS\" Version 8.4 is a thing of much beauty.  \"PDS\"\nhas over 1000 separate utility functions in one place.  \"PDS\" is found\non the CBT Tape, Files 182, 296, and 112, or on the L.A. Users Group\nTape.\n\n      With PDS Version 8.4, you can effortlessly do things like:\nexpanding or reducing partitioned dataset directory space without\nreallocation.  You have complete control over this.  You can also\ntailor overall dataset space--releasing or adding to it at will.  So,\nboth directory space and allocated extent space may be easily\nmanaged.  On the member level, partitioned dataset members can be\nadjusted as completely and as conveniently as the dataset itself.  For\nexample, load module attributes can be changed, either for single\nmembers or for large groups of members at once, without linkedit.  If\nyou do need to relinkedit a load module, the MAP command of PDS with\nthe RELINK keyword, will generate full relinkedit JCL for the load\nmodule, so you won't make any mistake with linkedit control cards.\n\n      PDS does many more things than this.  It is your handy workbench\nfor all sorts of dataset manipulation.  PDS is most usefully run as\na dialog under ISPF.  You can arrange your ISPF session so that no\nother ISPF function is lost, and the PDS \"ISPMODE\" function is gained.\n\n      As I stated, you can get a vendor-supported extension of PDS,\nbut I believe that the public version provides a solid utility base\nthat's within the reach of all shops.  The extension of power that\nPDS allows the system programmer, should change the standard of\ncapability that is expected from any working programmer.  He or she\ncan simply do more thorough work, faster.  There are tasks easily\ndone with PDS, that are next to impossible without it.\n\n      I wrote a course in the detailed use of the PDS product\n(Technical Support, Jan thru Mar 1988).   That course is distributed\non File 182 of the CBT Tape together with the product (members are\n$PDSART-).  My course is even delivered with the vendor product,\nbecause the commands and methods are still quite applicable there.\n\n      Large and small collections of utilities abound on the public\ntapes.  A glance at the documentation file of a new CBT Tape will\nguide you to some extent.  I liken these tapes to a large Toy Store.\nImagine you can tell your kids that they can take anything home they\nwant--and mean it!  Everything is free.  So browse and delight in the\nofferings.  Occasionally, you may have to fix one of them, but mostly,\nyou're in \"use it and enjoy it\" mode.\n\n      Some notable large collections on the CBT Tape are from Jim\nMarshall (Files 300 and 316), Kermit Kiser and the Washington State\nData Processing Facility (File 270), Lionel Dyck of Rockwell\nInternational (Files 431 thru 452), Intel (File 352) and Morton\nThiokol (File 353).\n\n\nDON'T NEGLECT THE JES2 TAPE.\n\n      For JES2 coding examples and packages, I think that the JES2\nSHARE Tape is somewhat better than the CBT Tape.  Many exit examples\nand JES2-related products abound on that tape, such as various\nversions of QUEUE, the spool-browsing tool.\n\n      More daring souls can explore the more sizable JES2 Mods.\nExtensive job-dependency and CPU-dependency logic can be added to JES2\nJECL coding through the Mellon Mods, created at Mellon Bank for many\nJES2 release levels.  If your shop is not willing to plunge into the\nworld of the Mellon Mods, you can at least look at what they are, and\ndiscover how they accomplish their \"tricks\".\n\n      The JES2 SHARE Tape is probably the first place to look for\nJES2 exit coding examples.  I have the impression that many JES2-\nrelated examples on the JES2 tape are probably more up-to-date than\ntheir equivalents (if they even exist) on the CBT Tape.  Of course,\nit's best to look at both tapes, but for JES2 matters, the specialty\nresource is probably preferred.\n\n\nCONCLUSION.\n\n      For now, it's time to go.  But I feel the time has arrived to\n\"legitimize\" in the minds of many managers the reliability and quality\nof much available public software.  Offerings on the public tapes\nare improving quality-wise.  They are arriving in greater variety\nand with a more mature utility value.  One finds more multi-utility\nsoftware packages that have been thoroughly debugged, as opposed to a\nhastily thrown together handy dandy one-shot deal.  Since these\npackages are being tested by more and more users, change-sensitive\ncode is being tolerated less and less.  The public wants the good\nstuff.\n\n      One might say that the public tapes are coming of age.\n\n      Happy exploring.  See you next month.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9104AP": {"ttr": 8198, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x93!\\x0f\\x00\\x93!\\x1f\\x07W\\x01\\xc0\\x01\\xc0\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "1993-07-30T07:57:00", "lines": 448, "newlines": 448, "modlines": 0, "user": "SBGCSC"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                            April 1991\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n\n\nTHE \"LOOK\" TSO COMMAND - AN EYE INTO THE OPERATING SYSTEM:\n\n      This month, I'd like to feature a program that has far more\nvalue than it seems to show initially.  The \"LOOK\" program allows a\nTSO user to display virtual storage in any address space, and to\nformat any of that space according to the macro DSECT description of\nany desired control block.  This amazing result is achieved in a\nsurprisingly simple manner, and source code is available for all to\nexamine.\n\n      The \"LOOK\" TSO command is found on File 264 of the CBT MVS Tape,\nwhich can be obtained through NaSPA in Milwaukee, (414) 423-2420, or\nthrough SPLA at the University of Miami in Florida, (305) 284-6257.\n\n      The \"LOOK\" command provides a fullscreen display of virtual\nstorage, or \"live machine core\", to put it more excitingly.  If it is\nrun authorized, \"LOOK\" allows cross-memory examination of most virtual\nstorage locations for any active address space.  A few special commands\nmake \"control block hopping\" very easy, with the actual core contents\nvisible.  The current version of LOOK is read-only (despite its screen\nheading), making it relatively safe to use.\n\n      LOOK can be assembled either for XA and ESA, or for MVS/370\nuse.  LOOK completely supports 31-bit addressing mode.\n\n      The current version of LOOK is supported by Guy Albertelli of\nB.F. Goodrich, near Akron Ohio.  Our current program is a distant\ndescendant of the \"LOOK\" program in the old \"DCMS\" monitor system that\nused to reside on the public MVS tapes.\n\n      I'll try to describe the structure and use of \"LOOK\", and to\nshow some of its enormous value, in several example scenarios.\n\n\nBASIC USE OF THE \"LOOK\" COMMAND.\n\n      Please refer to Figure Two, where a sample LOOK screen is\ndisplayed.  In the input field that states:  \"ENTER CMD\", the easiest\nthing to do is to enter an absolute address.  The initial virtual\naddress displayed by default upon entry to LOOK is address 00000000.\nThis of course, is the Prefixed Save Area or PSA.  The most recent\nversion of LOOK will force a formatted version of the PSA, according\nto the macro IHAPSA.  But through the use of the command, \"ONULL\",\nany macro formatting is suppressed.  The virtual locations starting\nat 00000000 will then be displayed in Hex, similar to the format of\nFigure Two.  If LOOK was assembled for XA, then any number from\n00000000 to 7FFFFFFF will yield a displayable result, provided the\nvirtual storage can actually be paged into real storage.\n\n      Entering an absolute hex address number as input to LOOK, is\nequivalent to direct addressing of a virtual storage location.\nEntering \"+\" or \"-\", followed by a numeric hex value, will place the\ndisplay forward, or backward, by the entered amount.  PF7 will move\nthe display backward to a screen-full of previous storage.  PF8 will\nmove the screen forward to the next contiguous following storage.\n\n      The second skill in using LOOK is to try indirect addressing\nof a virtual storage location.  Indirect addressing can be done in\n24-bit mode or in 31-bit mode.  To do indirect addressing in 24-bit\nmode, prefix an \"I\" to an absolute hex address such as \"10\", or to a\nrelative address, such as \"+58\".  The commands would be \"I10\", or\n\"I+58\".  For 31-bit mode, use a \"J\" instead of the \"I\".\n\n      Indirect addressing is like the \"LOAD ADDRESS\" or \"LA\" assembler\ninstruction.  Entering \"I10\" or \"J10\" will display the ADDRESS that's\nin storage at location \"absolute hex 10\".  \"I+58\" or \"J+58\" will\ndisplay the address contained in storage at \"hex 58\" off the current\nlocation.  Indirect addressing allows for easy control block hopping.\n\n      Of course, the address stored in \"absolute location hex 10\" is\nknown to point to the CVT area in an MVS system, or the \"Communication\nVector Table\".  Both Figures Two and Three point to the beginning of\nthe CVT.  The CVT is the main control block from where most other\ncontrol block pointers ultimately start.\n\n      Note the great differences between Figure Two and Figure Three,\neven though they point to the same area of storage.  Figure Two shows\nunformatted storage of the CVT area.  Figure Three displays the same\nstorage, but formatted according to the CVT mapping DSECT, described\nby the macro called \"CVT\" in the AMODGEN macro library.\n\n      The formatted screen illustrated by Figure Three teaches us\nabout another indirect addressing capability of LOOK.  We can display\nfurther storage by going to the contents of a formatted field that\ncontains an address.  The letter \"L\" prefixed to a field name,\nallows us to do this.  For example, in Figure Three, suppose we want\nto get to the ASCB or Address Space Control Block for the current\naddress space.  In the CVT, we must go the the TCB pointer field first.\nFrom the formatted screen, we can enter, \"LTCBP\" which will point us\nto location 00000218.  At +8 from this location is the address of the\nASCB, so we can then enter, \"J+8\", or \"I+8\", which will point us to\nthe ASCB.  This is very simple.  If you have access to a working copy\nof LOOK, try it.\n\n      PF9 and PF10, \"history backward\" and \"history forward\", allow\nus to review several previous screens and to step forward again to\nwhere we were.  This facility makes us capable of retracing our\nsteps in using LOOK.  If you were following the previous exercise on\na screen, press PF9 a couple of times and then PF10 a couple of times.\nYou'll see how the old screens are brought back again.  Starting from\none of the restored screens, you can proceed forward in a different\ndirection than before, if you wish.\n\n\nCHANGING ADDRESS SPACES.\n\n      The LOOK load module should be linkedited with SETCODE AC(1).\nLOOK can be run either authorized or non-authorized.  If LOOK is run\nnon-authorized, it can only display virtual storage in your own TSO\naddress space.  However, if LOOK is running authorized, it is extremely\nsimple to display the current virtual storage location in any active\naddress space.\n\n      Simply type the Hex value of the address space id over the\ncurrent ASID value that comes after \"DISPLAY ASID= \" on the LOOK\nscreen.  (See Figures Two or Three.)  For example, if you want to\ndisplay the current virtual storage location, but in the MASTER\naddress space, simply type the hex number \"0001\" over the current\nnumber, \"003E\", which is the ASID for our TSO address space.  A\ncross-memory SRB is dispatched immediately to obtain the storage in\naddress space 0001, corresponding to the storage location we're\ncurrently displaying.  You see that we can attempt to display ANY\nstorage location in any address space, and much of the time, we will\nbe successful.  I don't have to over-emphasize the power that is\nimplicit in this facility.\n\n\nUSING LOOK TO DIAGNOSE A SYSTEM DUMP.\n\n      When I was a fledgling systems programmer, I was intimidated\nby the prospect of solving a system dump.  Once I learned how to use\nLOOK, I realized that these dumps can be far simpler to solve than\napplication program dumps.\n\n      Let me explain.  Problems in an application program are\ntransient in nature.  The application program is loaded into the\naddress space's private area of virtual storage, and executes at\n\"computer speed\" there.  If there is a malfunction or a bug, the\nstorage involved will disappear soon after the abnormal end occurs,\nand the address space is cleared out of the system.  That's why you\nneed a dump, to preserve the contents of private areas (usually) and\nsome system areas, before the whole scene goes away and you won't be\nable to see it again.\n\n      Not so, for a problem occurring in a system area of storage.\nSystem modules are usually loaded into common areas of storage at\nIPL time.  They occupy the same virtual storage locations, no matter\nwhat address space they are viewed from.  Even if storage is overlaid,\nthe \"problem evidence\" might remain in the system long after the\nsystem problem occurred.  You may therefore use a core-browsing program\nsuch as \"LOOK\" to return to the problem areas much later, as long as\nthere wasn't an intervening IPL (and often, even if there was one).\n\n      One can even search the problem areas from one's own TSO\naddress space (since they are common to all address spaces) to achieve\nthe diagnosis.  One does not usually need to go into the address space\nthat was having the problem.\n\n      How can we start?   It is usually best to try and obtain a\ngood set of registers and a PSW (which contains the instruction to\nbe executed next).  One of the best places to obtain a good set of\nregisters and a PSW is in the RTM2 Work Areas of the dump, if they\nexist.  Once we have a set of registers, we can use the MAPXA or\nMAPSP command, or some similar tool (see this column in the OCTOBER\n1990 issue) to check which registers point to addresses in the system\nareas, such as CSA, PLPA, MLPA, and SQA.\n\n      One can then use LOOK to browse the vicinity of each of these\nregister contents (using absolute addressing).  Often, the registers\nare pointing to the middle of a system module.  You need only browse\nthe eyecatcher of the module (or use SMP inquiry) to determine its PTF\nlevel.  Then you can search IBM Link or call the IBM support center to\nsee if a problem has been reported with that level of the module.\nAlso, since you have access to all of this storage area, you can\nattempt to pinpoint a possible cause of the problem yourself.  Your\nprevious system knowledge and skill can then be put to good use.\n\n      The main idea is that in a problem with system modules, the\nevidence usually remains around for a long time.\n\n\nUSING LOOK TO FOLLOW A CONTROL BLOCK CHAIN ON A REAL SYSTEM.\n\n      The LOOK program is of enormous help to programmers.  When\nwriting a system utility, or when asking your program to access\nsystem-level information, you'd like to know if the information is\nreally there.\n\n      Most control block contents in MVS are accessible through a\nsequence of address pointers, usually starting from the CVT (or\nCommunication Vector Table) control block.  For example, if your\nprogram is supposed to read a system date, and your code points to\na certain displacement from the beginning of the CVT, you can get into\nLOOK, follow your code instructions, and see if the date is really\nthere.  This can be done for any simple, or complicated sequence of\ninstructions that appear in a program.\n\n      Let's say a program wants to find the current system date in\npacked decimal.  The system maintains this information at displacement,\nX'38' from the beginning of the CVT.  Some assembler instructions to\naccess the system date would be as follows:\n\n         LA    R5,16             POINT TO CVT\n         L     R6,X'38'(,R5)     PUT DATE INTO REGISTER\n         ST    R6,PACKDATE       SAVE PACKED DATE\n           . . . . . .\nPACKDATE DC    F'0'              STORAGE FOR DATE\n\nTo verify if the current date is there, get into LOOK.  To point to\nthe CVT, enter \"I10\", or (in XA and ESA) \"J10\".  To suppress the\nCVT control block formatting, enter \"ONULL\".  Then enter \"+38\" on\nthe command line.  One can infer from Figure Two that a packed date\nindeed occupies this field.\n\n      One might use another set of instructions to access the system\ndate, this time using the DSECT mapping of the CVT control block.\nThe instructions would read as follows:\n\n         LA    R5,16             POINT TO CVT\n         USING CVT,R5            USE DSECT NAMES\n         L     R6,CVTDATE        PUT DATE INTO REGISTER\n         ST    R6,PACKDATE       SAVE PACKED DATE\n           . . . . . .\nPACKDATE DC    F'0'              STORAGE FOR DATE\n           . . . . . .\n         CVT   DSECT=YES\n\nThis time, to verify if the current date is there, get into LOOK.\nPoint to the CVT by entering \"I10\" or \"J10\".  The CVT should be\nautomatically formatted.  If it isn't formatted, enter the command\n\"OCVT\", which will format the current storage as the CVT control\nblock.  Then browse the formatted control block display, and look for\nthe field labelled \"DATE\".  This is the CVT field called \"CVTDATE\"\n(prefixes are dropped in the fullscreen display).  In Figure Three,\nyou'll see the \"DATE\" field in the fifth line of the display.  It\nis trivial to verify that the field contains the current date in\npacked format.\n\n\nTAGGING POINTS OF STORAGE, AND RERESHING A DISPLAY.\n\n      It is easy to see that LOOK can be used in far more complicated\nstorage and control block tracking.  A further help in this regard\nis the tagging of storage labels.\n\n      At any current point of storage, one can create a TAG.  Simply\nenter an equal sign, followed by a name.  This name will tag the\ncurrently displayed storage.  The tagged storage can be redisplayed\nlater by entering a comma, followed by the tagged name.\n\n      For example, suppose we have pointed to the system date, at\n+38 hexadecimal from the beginning of the CVT.  We can tag this point\nin storage by entering the command, \"=DATE\".  Later, if we'd want to\nreturn to this storage place at any time, we need merely enter the\ncommand, \",DATE\".  This will immediately return us to the location\ntagged by the command of \"=DATE\".\n\n      It is necessary to explain one more command, and then I'll send\nyou on your way.  This is the \"R\" command, which refreshes storage at\nyour current location with a new copy from the system.\n\n      If you have displayed storage at one location, and you try and\nredisplay the same location, you will not have obtained a new copy of\nthe system's storage at that location.  Your display will still show\nthe storage from the first fetch.  The \"R\" command, entered at this\npoint, will initiate a new storage fetch from the system at the\ncurrent location.  Each time you want to re-access the system's\nstorage at the current location, you have to enter \"R\".\n\n      So if you're trying to track changes in storage at a single\nlocation, you have to repeatedly issue \"R\" commands, to keep getting\nnew copies of the system's storage from that place.  This is something\nthat's necessary to know when using LOOK.\n\n\nCONCLUSION.\n\n      It's not hard to see that LOOK, a simple-to-use TSO command,\nprovides a powerful tool to see what's running in the system, especially\nin the common storage areas.  Many problems that were baffling, will\neasily fall, when put under LOOK's scrutiny.  LOOK will help the\nprogrammer also, to verify that the data being programmed for, is\nreally there.  One can now see virtual storage in any address space,\nand navigate through it.\n\n      Good luck searching and LOOKing.  See you next month.\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE ONE.   Online HELP for the LOOK Command.\n\n              LOOK is a TSO command which will display virtual\n              storage in the current address space if it is not run\n              authorized, or IN ANY ADDRESS SPACE if it is being\n              run authorized.  To switch address spaces, merely\n              type over the hex address space id field after\n              \"DISPLAY ASID=\" in the screen header.  LOOK is\n              currently \"read only\", and does not change storage.\n\n\n\n\n\nLOOK COMMAND - DISPLAY VIRTUAL MEMORY      DISPLAY ASID= 002A\nENTER CMD -\nLAST CMD  -\n\nLOOK is a real time core display and formatting program. It also has the\ncapability of displaying memory in any address space (if authorized).\n\nThe valid commands are:\nIexp  24 bit indirect                 \u00a6 Jexp  31 bit indirect\n>     Forward                         \u00a6 <     Backward\n=sym  Define current address as 'sym' \u00a6 ,sym  Redisplay core at 'sym'\nM0/M1 Flip between top and center     \u00a6 Lname Indirect thru control block field\nOcb   Format as 'cb' control block    \u00a6 R     Refresh displayed storage\n\nwhere 'exp' is of the form:\n    <+/->hhhh<+/-hhhh<+/-hhhh...>>\nand 'hhhh' is a 1 to 8 digit hex number.\n\n\n\n\n\n1= HELP      2=           3= END        4=           5= REPEAT  6=\n7= BACKWARD  8= FORWARD   9= HIST BWD  10= HIST FWD 11=        12=\n\n\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE TWO.   The \"LOOK\" Hex Display.\n\n              This is the normal Hex Display that appears when a\n              numeric hex address is entered next to the prompt:\n              ENTER CMD- \".  If no control block that is \"known to\n              LOOK\" begins at a current address, then this Hex\n              Display of storage is shown.  One may also use\n              indirect addressing to point to any memory location.\n              For example:  \"I10\" will point the display to the\n              address that is contained in the location X'10'\n              bytes virtual.  \"I+10\" will point to the address\n              in location hex 10 bytes OFF the CURRENT virtual\n              location.  This figure points to the beginning of\n              the CVT on my system.  See Figure Three for the\n              formatted version of the same data.  The command\n              \"ONULL\" cancels automatic control block formatting,\n              and forces the hex display.  The command \"Oblkname\"\n              forces formatting at the current address, according\n              to the DSECT description of the control block \"blkname\".\n\n\n\n\nLOOK COMMAND - DISPLAY VIRTUAL MEMORY      DISPLAY ASID= 003E\nENTER CMD - OCVT\nLAST CMD  - ONULL\n\n00FDB1C0   >00000218  00FEF210  00FDB13C  00FDB790 *>......2.........*\n00FDB1D0    00000000  00FFA0A8  00FF6C6E  00FEFC3E  *..........%.....*\n00FDB1E0    00FEFBAA  01175180  81063F50  00FF1320  *...........&....*\n00FDB1F0    00FD14D8  00FEF3C0  0091027F  00FDB7B8  *...Q..3.........*\n00FDB200    00FC0C28  00FFC368  00000000  00000000  *......C.........*\n00FDB210    0A0307FE  00FDB144  00FDAF90  00000000  *................*\n00FDB220    00000000  00FDD690  00FE68A2  00FE68C2  *......O........B*\n00FDB230    00F80000  93FE09A8  00620001  00FFC858  *.8............H.*\n00FDB240    00000000  81031330  00FF20EC  00000000  *................*\n00FDB250    81B3A000  00FDB7B8  00FF3AE0  00D05F48  *..............\u00ac.*\n00FDB260    00000000  7FFFFFFF  00000000  00000000  *....\"...........*\n00FDB270    00FDB890  000BA320  00FED318  00FDB178  *..........L.....*\n00FDB280    00FDB8C8  80F825E0  00FD36E8  00000000  *...H.8.....Y....*\n00FDB290    00000000  0A0D0A06  00000000  00FDAB48  *................*\n00FDB2A0    010C6288  7F746F18  00FEF560  00FD9190  *....\".?...5-....*\n00FDB2B0    00000000  00000000  00F82D28  00FDB700  *.........8......*\n\n\n1= HELP      2=           3= END        4=           5= REPEAT  6=\n7= BACKWARD  8= FORWARD   9= HIST BWD  10= HIST FWD 11=        12=\n\n\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE THREE.   A Formatted Control Block Under LOOK.\n\n              This shows the beginning of the CVT control block\n              on an MVS/XA system, as formatted by \"LOOK\".  LOOK\n              uses an actual assembly macro expansion to produce\n              this formatted picture.  One can point to any address\n              from a formatted control block picture by typing\n              \"L\" followed by the name of any field, with no\n              blanks.  For example, to get to the TCB pointer,\n              one enters:  \"LTCBP\".  Control block formatting is\n              done automatically by \"LOOK\" when it recognizes a\n              predetermined indicator at an address, indicating\n              that it is the location of a certain control block.\n              Intentional formatting for an address location to\n              the map of a particular control block is done by\n              the command letter \"O\" followed by the name of the\n              control block.  For example:  \"OCVT\" will format\n              the current address as the CVT control block.  The\n              command \"ONULL\" will force this formatting off\n              unconditionally.\n\n\n\nLOOK COMMAND - DISPLAY VIRTUAL MEMORY      DISPLAY ASID= 003E\nENTER CMD -\nLAST CMD  - j10\n                          00FDB1C0  CVT\n TCBP    00000218  0EF00   00FEF210  LINK    00FDB13C  AUSCB   00FDB790\n BUF     00000000  XAPG    00FFA0A8  0VL00   00FF6C6E  PCNVT   00FEFC3E\n PRLTV   00FEFBAA  LLCB    01175180  LLTRM   81063F50  XTLER   00FF1320\n SYSAD   00FD14D8  BTERM   00FEF3C0  DATE    0091027F  MSLT    00FDB7B8\n ZDTAB   00FC0C28  XITP    00FFC368  RS048   00000000  VSS     0000\n VPSM    0000  SVDCB   00FDB144  TPC     00FDAF90  RS05C   0000  ICPID   0000\n RS060   00000000  CUCB    00FDD690  QTE00   00FE68A2  QTD00   00FE68C2\n STB     00F80000  DCB     93  DCBA    FE09A8  SV76M   00620001\n IXAVL   00FFC858  NUCB    00000000  FBOSV   81031330  0DS     00FF20EC\n RS08C   00000000  DAIRX   81B3A000  MSER    00FDB7B8  0PT01   00FF3AE0\n TVT     00D05F48  SV76C   00000000  MZ00    7F  1EF00   00000000\n QOCR    00000000  QMWR    00FDB890  SNCTR   000B  OPTA    A3  OPTB    20\n QCDSR   00FED318  QLPAQ   00FDB178  ENFCT   00FDB8C8  SMCA    80F825E0\n ABEND   00FD36E8  USER    00000000  MDLDS   00000000  TSCE    00000000\n PATCH   00FDAB48  RMS     010C6288  SPDME   7F746F18  0SCR1   00FEF560\n GTFST   00  GTFA    FD9190  TCMFG   00  AQAVB   000000  RS0F4   00000000\n\n\n1= HELP      2=           3= END        4=           5= REPEAT  6=\n7= BACKWARD  8= FORWARD   9= HIST BWD  10= HIST FWD 11=        12=\n\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9105MY": {"ttr": 8452, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x93!\\x0f\\x01\\x00)\\x9f\\x11G\\x01\\xb6\\x01\\xb6\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 438, "newlines": 438, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                             May 1991\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\n\nMEMBER GROUP SELECTION IN PARTITIONED DATASETS.\n\n      It's well known that I'm a big fan of the \"PDS\" program product\nthat's on File 182 of the CBT MVS Public Tape. (The CBT tape can be\nordered through NaSPA).  I use \"PDS\" (or its vendor-supported\nsuccessor called \"PDS/E Sysprog Utilities\") 95 percent of the time in\nmy work.  Some people (who evidently haven't exploited these products)\nhad suggested that I've \"overemphasized PDS\" in my writings.  Well,\nthe fact is that I haven't written about \"PDS\" here for close to a\nyear, in deference to those people.  But any product that has 1000\nseparate utility functions (more in the case of PDS/E), and integrates\nthe functioning of your ISPF sessions, deserves more press and not\nless, in my opinion.\n\n      This month, I'll show you one of the most powerful tools you can\nuse to manipulate partitioned datasets and their members.  It happens\nto be a little-known part of both \"PDS\" products.\n\n      Since the free \"PDS\" product and the vendor-supported \"PDS/E\"\nproduct have much of this material in common, we'll often refer to\nboth products collectively as PDS(/E).\n\n      We'll start off discussing an annoying problem that surfaced at\nmy last shop.  The situation is typical of an exposure which can\nhappen in all production environments.  Similar things also cropped up\nyears ago, when I was a DOS applications programmer.  There is\nsomething here for everyone to learn about.  What's not so obvious, is\nthat you can do an action to SOLVE such a problem conclusively in very\nshort order.\n\n      Our company had a \"bad subroutine\" linked into dozens of\nproduction load modules.  We'll call the routine TIMDATE for the\ndiscussion here (the real routine is proprietary).  There were so many\noccurrences of this routine buried in our production libraries that we\nthought it impossible to root them out immediately.  But until they\nwere all replaced with good versions in all load modules, we'd be in\nconstant danger of middle-of-the-night phone calls, and of production\nCICS regions crashing \"at random\" in the middle of the day.\n\n      This situation actually happened last January 1st.  TIMDATE,\nthis in-house \"time-date routine\", was coded to take a user abend when\nthe year was incorrect.  The TIMDATE module was a part of some CICS\ntransactions and was also a part of many batch load modules.  In a\nCICS transaction, its user abend would crash the entire CICS region,\nbecause CICS operates under one TCB.  In a batch job, its user abend\nwould force a night call from operations to the duty programmer, who'd\nhave to re-linkedit the offending load module.  That was a rather\nunpleasant occurrence for all involved, since very often, the duty\nprogrammer did not have a \"dial-up\" at home.  To re-linkedit the\nmodule, that programmer would have to drive to work in the wee hours\nof the morning.\n\n      Using two features of the \"PDS\" product, I cured the entire\nproblem in two hours flat, before any lasting damage could be done\nto corporate production.\n\n      This technique is little-known, even among many seasoned systems\npeople.  I myself didn't know about that particular feature of \"PDS(/E)\"\nbefore we had the problem.  Hence I was moved to write something about\nit, to help everybody benefit in the future.\n\n\nHOW TO CURE THE CASE OF A \"BAD\" SUBROUTINE.\n\n      My \"magic tools\" to cure the problem of the bad subroutine were:\nthe under-utilized \"IF\" subcommand of the \"PDS\" program product, and\nthe little-known \"RELINK\" operand of the PDS \"MAP\" subcommand.\n\n      Let's look at \"IF\" first.  I think that a great part of IF's\nlack of exploitation is caused by the fact that it's hard to figure\nout what a command called \"IF\" is supposed to do.  \"If\" is a rather\nnondescript word in the English language.  As a command, the word \"if\"\nis completely meaningless.  \"If\" does suggest something that's\nconditional.  But what?  What would a vague conditional command in a\nproduct that manipulates datasets be useful for?\n\n      I'll tell you what \"IF\" really does.  The IF subcommand of PDS\nactually grabs members of a library according to some criterion, so\nthey can belong to a \"member group\".  Any subsequent \"PDS\" utility\noperation could be made to operate on ALL the members in that group,\nand on no other members of the library.  People just aren't used to\nhaving a utility that will CONDITIONALLY form groups of pds members\nwhich you want to manipulate together.  Other products don't generally\ndo that sort of thing.  That's why I think this powerful \"IF\" facility\nis not widely understood.\n\n      This \"IF\" feature of PDS(/E) is what saved our skins.  \"IF\" can\npick out members of a library according to more than fifty separate\nselection conditions.  Here's how IF works. You start with a large\nmember group, perhaps ALL MEMBERS (denoted by the colon \":\")  Then\nyou use one of the fifty-odd criteria to cut the size of the group\ndown, allowing in the new group, only those members of the starting\ngroup that fit the condition specified.\n\n      What criteria can you choose from?  See Figure One for a list of\nwhat's available in the \"PDS\" products.  One of these criteria is\ncalled MODULE (modname).  When applied to a library of load modules,\nMODULE (modname) will pick load module members according to whether\nthe csect called \"modname\" was linkedited into that load module.\n\n      Voila.  We have what we need.  With this command, we can quickly\nlocate all load modules in our production load libraries (and only\nthose modules), that contain the subroutine called TIMDATE.  We just\nhave to point the \"PDS\" program to our load library, enter the command:\n\"IF : MODULE(TIMDATE) THEN (SUBLIST)\" to ask for a correct list of\nmembers, and let the computer crank away.  When the computer's done,\nwe have our member list.\n\n      Finding the bad load modules is two-thirds of the problem.  The\nrest?  How do we fix the problem for each load module we've found?\n\n      That's where the RELINK operand in the \"MAP\" subcommand of PDS\nenters.  Given a load module or a group of load modules, the MAP\ncommand with the RELINK keyword will generate complete JCL and linkage\neditor control statements to correctly re-linkedit the load module.\nSee Figure Two.  Doing that for one load module is an amazing feat.\nBut with PDS(/E), a product that supports operations on groups of\nmembers, this \"linkedit JCL generation\" can be done for all load\nmodules in the group using one command.\n\n      Fact.  In the \"PDS\" product, we do an operation to a group of\nmembers by substituting an asterisk \"*\" instead of the member name, in\nany PDS subcommand.  For example, suppose we've adjusted our load\nlibrary member group with \"IF : MODULE(TIMDATE)\", to contain only load\nmodules having the csect called TIMDATE linkedited in them.  Then we\ncan generate complete re-linkedit JCL for all of these modules at\nonce.  We simply issue the one command:  \"MAP * RELINK\".  Again, see\nFigure Two, which shows a result of these actions.\n\n      The JCL and linkage editor control statements generated by\n\"MAP * RELINK\" can be put out to a dataset and then edited.  We can\nsave these generated control statements by issuing the command,\n\"CONTROL DSN(dataset.name)\", where \"dataset.name\" is the name of an\navailable dataset which will be written to.  After the \"CONTROL DSN\"\ncommand has been issued, all PDS commands and outputs are written out\nto that dataset as a file.  To close the file, the \"CONTROL NODSN\"\ncommand must be issued, and the output file will be closed by the PDS\nprogram.\n\n      A quick editing job on the dataset, will create a job to replace\nthe bad subroutine with a good one of the same name.  Slap a job card\non top of the stream, and submit the linkedit job.  This will\ncompletely cure our dangerous situation.  See Figure Three.\n\n      So, to solve the case of the bad subroutine, the necessary\nsequence of PDS(/E) commands reads as follows.\n\n   PDS  load.library\n       (points \"PDS\" to a library)\n   IF : MODULE(TIMDATE) THEN(SUBLIST)\n       (creates a member subgroup of all modules containing TIMDATE)\n   CONTROL DSN(output.dataset.name)\n       (opens an output dataset to be written to)\n   MAP * RELINK\n       (generates re-linkedit JCL and writes it to the output dataset)\n   CONTROL NODSN\n       (closes the output dataset)\n\n      The dataset 'output.dataset.name' is then edited to create a\nworking linkedit job.  After manually inserting some linkedit INCLUDE\nstatements to replace module TIMDATE with a \"good\" version, and after\nchanging SYSLMOD to point to a new output load library, the job is\nready to run.  When the job has finished, that library has been\ncompletely \"cured\" from containing the bad subroutine.  We repeat this\nprocedure for all load libraries suspected of containing load modules\nwith the bad subroutine, and our problem is solved.\n\n\nSOME OTHER USES OF THE \"IF\" SUBCOMMAND OF \"PDS(/E)\"\n\n      Figure One, which lists criteria by which the \"IF\" subcommand\nchooses members, is worth study.  Space has unfortunately prevented\nthe inclusion of the rest of this HELP text for \"IF\", which explains\nthe significance of each criterion in detail.  If you have access to a\nCBT Tape, or you have installed PDS or PDS/E, stydy these detailed\nexplanations in the \"PDSHELP\" member of File 182, for ideas about this\nsubcommand's power.  For now, we'll say a few more general things\nthat'll give you an glimpse.\n\n      \"IF\" criteria can be broken into several categories.  For source\nmodules, ISPF stat criteria are major factors.  Picking by userids or\nby dates are examples.  To use \"IF\" to pick members by record count,\nISPF statistics are NOT used.  Actual record counts are.  The ABOVE\nand BELOW keywords would do that picking job.\n\n      I find that in a source-type dataset, date-picking is helpful.\nI can pick a group of all members I've used in the past two weeks\nonly.  These will help me look at work that I've done most recently,\nwithout interference from the older members.  You get the idea.  The\nprocess is aided by the fact that the MEMLIST (or \"ML\") subcommand,\nwhich picks members for inclusion in PDS's ISPF member list, shares\nmost of the criteria of \"member picking\" with the \"IF\" subcommand.  I\nget into a PDS \"ISPMODE\" session.  I enter, \"ML : BIWEEK\", and I'm in\nbusiness.\n\n      For load modules, there is far more choice.  Every load module\nattribute that appears in the partitioned dataset directory can be\nused as a criterion.  Also, alias criteria, loadability, and blocksize\n(largest block) are criteria that are available when needed.  Even TTR\nrange within a library is in bounds for picking groups of members.  If\nyou think about all this, there is an enormous range of system\nproblems that can be solved, using this facility.\n\n      The \"THEN\" and \"ELSE\" keywords, which determine the consequences\nof an \"IF\" member search, should be explained.  One can use \"THEN\" to\nspecify a PDS(/E) subcommand which will operate on the member group\nproduced from the IF member search.  One can use \"ELSE\" to force that\nmember group to include only members NOT satisfying the criteria of\nthe search.  It is recommended to use \"SUBLIST\" as the resulting\noperand of the THEN (or ELSE) keywords most of the time.  That's\nbecause non-default cases of the other subcommands cannot be specified\nwhen they are operands of \"THEN\".  If \"SUBLIST\" is used, the result\nof the member search is merely a member group consisting of a list of\nspecific members.  Referring to this list later as the member group,\nusing asterisk \"*\", you can afterward let any subcommand operate on\nthis member group, allowing all options that are available for the\nsubcommand.\n\n      A concluding example should drive this concept home.  Suppose we\nhave a library of load modules, some of which have blocks bigger than\nthe DCB blocksize of the load library, and we want to fix the problem\nof the large-block members.  The following sequence of commands will\ndo the trick.  First, we get into the load library with the command,\n\"PDS 'our.load.library'\".  Then we use \"IF\" to nail the correct member\nsubgroup.  We say, \"IF : BLOCKERR THEN (SUBLIST)\".  This will make a\nmember group consisting of all members having blocks bigger than the\nDCB blocksize.  Then we allocate a new load library that has a\nblocksize large enough to accommodate these members.  The PDS \"VERIFY\n*\" command will provide us with an allowable blocksize.  We then say,\n\"COPY * new.library\", which copies all the \"large-block\" members to\nthe new library, that has room to accommodate the large blocks.\nThen we say \"DELETE *\" to delete these members from the current\nlibrary.  After that, we can compress the library with the PDS\n\"COMPRESS\" subcommand.  COMPRESS preserves the current member group as\na list of member names.  Finally, we can \"CHANGE 'new.library'\" which\nmakes the current dataset that PDS is using, the new library.  The\n\"CHANGE\" subcommand does not alter the current PDS member subgroup.\nFinally, a command of \"COPY * 'old.load.library' will cause PDS to\ncreate an IEBCOPY \"COPYMOD\" command, to reblock the \"big\" members, as\nthey are being copied back to the old load library.  This solves our\nproblem.\n\n      Note that the \"IF\" subcommand with the \"THEN(SUBLIST)\" keyword,\ndetermined the default member group that was used throughout all our\nother maneuvers.  The \"IF\" subcommand, you see, was the heart of the\nmatter.  \"IF\" picked the appropriate group of library members for us\nto operate on.\n\n      Space is short here.  This subject is far deeper than I have\nindicated.  I hope these remarks inspire you to take another look at\nsome of the power that is buried in the PDS(/E) member selection\nsubcommands, such as \"IF\" and \"MEMLIST\".  A little time so invested,\nis guaranteed to yield surprising and pleasing results for you and\nyour shop.\n\n      Good luck.  See you next month.\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE ONE.  Part of the TSO HELP member for the \"IF\" subcommand of PDS.\n             This illustration hints at many of the techniques\n             made possible through having so many member choice\n             criteria.  Detailed explanations for each criterion\n             are part of the actual TSO HELP member as shipped\n             from CBT Tape File 182 (member PDSHELP).  Space\n             constraints have made it impossible to show all of\n             those explanations here.\n\n\n=IF=I\n)F  EXAMPLE -     IF MEMA:MEMB CHANGED(11/24/90:11/30/90) THEN(EDIT)\n\n  THE IF SUBCOMMAND SEARCHES FOR MEMBERS MEETING DEFINED CONDITIONS.\n  THE ACTION TO BE TAKEN IS SPECIFIED BY THE THEN AND ELSE KEYWORDS.\n  EITHER THE THEN OR ELSE KEYWORD MAY BE OMITTED; IF BOTH THEN AND ELSE\n  ARE OMITTED, A DEFAULT OF THEN(ATTRIB) IS PROVIDED.\n\n  IF ALL CONDITIONS ARE MET FOR A GIVEN MEMBER, ANY \"THEN\" ACTION IS\n  TAKEN FOR THAT MEMBER; OTHERWISE, ANY \"ELSE\" ACTION IS TAKEN.\n\n ALIASES  - I, IF\n DEFAULTS - MEMBER, THEN(ATTRIB) IF NEITHER THEN NOR ELSE IS ENTERED\n REQUIRED - NONE\n\n)X SYNTAX -\n     IF MEMBER   SINCE/BEFORE\n                 TODAY/YESTERDAY/WEEK/CURRENT/BIWEEK/\n                       MONTH/QUARTER/HALFYEAR/YEAR/BIYEAR/\n                       LAST(NUMDAYS)/DATE(MM/DD/YY)\n                 CHANGED(YYDDD:YYDDD) / CHANGED(MM/DD/YY:MM/DD/YY)\n                 CREATED(YYDDD:YYDDD) / CREATED(MM/DD/YY:MM/DD/YY)\n                 ABOVE(COUNT1)            (refers to record count)\n                 ALIAS/NOALIAS            (is the member an alias?)\n                 AMODE24/AMODE31/AMODEANY/NOAMODE24/\n                         NOAMODE31/NOAMODEANY  (LOAD MODULES ONLY)\n                 APFERR/NOAPFERR               (LOAD MODULES ONLY)\n                 APPARENTALIAS/NOAPPARENTALIAS\n                 AUTH/NOAUTH                   (LOAD MODULES ONLY)\n                 BELOW(COUNT2)            (refers to record count)\n                 BLOCKERR/NOBLOCKERR        (LRECL too long for DCB?)\n                 DC/NODC                       (LOAD MODULES ONLY)\n                 EDIT/NOEDIT                   (LOAD MODULES ONLY)\n                 EXEC/NOEXEC                   (LOAD MODULES ONLY)\n                 EXTERN/WKEXTERN               (LOAD MODULES ONLY)\n                 FLEVEL/NOFLEVEL               (LOAD MODULES ONLY)\n                 HASALIAS/NOHASALIAS      (are there alias members?)\n                 ID(PUID)/NOID/NOTID(PUID)  (choose by ISPF userids)\n                 IOERR/NOIOERR\n                 LKED(PARTL)                   (LOAD MODULES ONLY)\n                 LKEDERR/NOLKEDERR             (LOAD MODULES ONLY)\n                 LOADERR/NOLOADERR             (LOAD MODULES ONLY)\n                 LOADONLY/NOLOADONLY           (LOAD MODULES ONLY)\n                 LRECLERR/NOLRECLERR        (LRECL and BLKSIZE wrong)\n                 MAXBLK(SIZE)         (pick members having big blocks)\n                 MODULE(PARTM)                 (LOAD MODULES ONLY)\n                 NAMEERR/NONAMEERR    (members with invalid/valid names)\n                 NULL/NONULL          (null/non-null members)\n                 ORPHAN/NOORPHAN\n                 OVERLAY/NOOVERLAY             (LOAD MODULES ONLY)\n                 PAGE/NOPAGE                   (LOAD MODULES ONLY)\n                 REFR/NOREFR                   (LOAD MODULES ONLY)\n                 RENT/NORENT                   (LOAD MODULES ONLY)\n                 REUS/NOREUS                   (LOAD MODULES ONLY)\n                 RLDERR/NORLDERR               (LOAD MODULES ONLY)\n                 RLDZERO/NORLDZERO             (LOAD MODULES ONLY)\n                 RMODE24/RMODEANY/\n                         NORMODE24/NORMODEANY  (LOAD MODULES ONLY)\n                 SCTR/NOSCTR                   (LOAD MODULES ONLY)\n                 SPFEDIT/NOSPFEDIT    (is somebody else editing member?)\n                 SSI(HEXDATA)/SSI/NOSSI/PARTSSI(HEXDATA)\n                 SYSMOD(PARTU) / USERDATA(PARTU) (LOAD MODULES ONLY)\n                 TEST/NOTEST                   (LOAD MODULES ONLY)\n                 TRANS(PARTT)                  (LOAD MODULES ONLY)\n                 TTR(LTTR:HTTR)      (where in the dataset is the data?)\n                 USERDATA(PARTU) / SYSMOD(PARTU) (LOAD MODULES ONLY)\n                 USERID(PUID)/NOUSERID/NOTUSERID(PUID)  (ISPF userid?)\n                 VSLKED/NOVSLKED               (LOAD MODULES ONLY)\n                 ZAP(PARTZ)    (exist zaps?)   (LOAD MODULES ONLY)\n                 THEN(ATTRIB/ BROWSE/ DIRENTRY/ DELETE/ EDIT/\n                      END/ FIND/ FSE/ HISTORY/ LIST/ MAP/ MEMBERS/\n                      MEMLIST/ OUTCOPY/ PRINTOFF/ REVIEW/ SUBMIT/\n                      SUBLIST/ TSOEDIT/ TSOLIST/ VERIFY)\n                 ELSE(ATTRIB/ BROWSE/ DIRENTRY/ DELETE/ EDIT/\n                      END/ FIND/ FSE/ HISTORY/ LIST/ MAP/ MEMBERS/\n                      MEMLIST/ OUTCOPY/ PRINTOFF/ REVIEW/ SUBMIT/\n                      SUBLIST/ TSOEDIT/ TSOLIST/ VERIFY)\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE TWO.  Here is an illustration of the power of the PDS(/E) \"MAP\"\n             command with RELINK option, pointed at a load module\n             called \"LOOK\".  This is the output of the MAP with RELINK\n             in its raw form (as it comes directly from PDS or PDS/E).\n\n\n\n*** LOG TABLE OUTPUT ***      3.50.27 PM      TUESDAY     MAR 12, 1991\n\n- DSN=JRC1.JRCSBG.LOAD,VOL=SER=JRCV02  MEM=LOOK\n>map  look relink\n\n** MAP      LOOK\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=JRC1.JRCSBG.LOAD\n//SYSLMOD  DD  DISP=SHR,DSN=JRC1.JRCSBG.LOAD\n//SYSLIN   DD  *\n INCLUDE SYSLIB(LOOK)\n ORDER   LOOK,CBMACS,CBBKLS,DUMMY\n SETSSI  CB325264\n MODE    RMODE(ANY),AMODE(31)\n SETCODE AC(1)\n ENTRY   LOOK\n NAME    LOOK(R)\n\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE THREE.  Output of a \"MAP  *  RELINK\"  PDS(/E) Command, after\n               a JOB card has been added, and extraneous message\n               information has been removed.  This job is ready\n               to run.  In fact, it is part of the actual job I\n               ran, that inspired this article (although the names\n               have been changed to protect the innocent).\n\n\n\n\n//TSTBRLNK JOB (TS,2322),'TECH.SUPP-SAM.GOLOB',CLASS=M,NOTIFY=TSTBSSG,\n//        MSGLEVEL=(1,1),MSGCLASS=T TYPRUN=HOLD\n//*\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.ONL.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=TSTBSSG.CICLINK.LOAD\n//SYSLIN   DD  *\n INCLUDE SYSLIB(TIMDATE)\n INCLUDE SYSLIB(AJ0004)\n ORDER   AJ0004,TIMDATE,PICALLPM,ILBOABN,ILBODSP,ILBODTE,ILBOEXT\n ORDER   ILBOQIO,ILBOSRV,ILBOSYN,ILBOVOC,ILBOBEG,ILBOCHN,ILBOCKP\n ORDER   ILBOCMM,ILBOCOM0,ILBOINT,ILBOMSG,ILBOVIO\n ENTRY   AJ0004\n NAME    AJ0004(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.ONL.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=TSTBSSG.CICLINK.LOAD\n//SYSLIN   DD  *\n INCLUDE SYSLIB(TIMDATE)\n INCLUDE SYSLIB(AJ0016)\n ORDER   AJ0016,TIMDATE,ILBODSP,ILBODTE,ILBOEXT,ILBOQIO,ILBOSRV\n ORDER   ILBOVOC,ILBOABN,ILBOBEG,ILBOCHN,ILBOCKP,ILBOCMM,ILBOCOM0\n ORDER   ILBOINT,ILBOMSG,ILBOVIO,ILBOWTB\n ENTRY   AJ0016\n NAME    AJ0016(R)\n/*\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9106JN": {"ttr": 8460, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x93!\\x0f\\x01\\x00)\\x9f\\x11G\\x01D\\x01D\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 324, "newlines": 324, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                            June 1991\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\n\nDYNAMASK - CHANGING DEVICE NAMES ON A LIVE SYSTEM IN SECONDS.\n\n     Have you ever had to add new disk volumes or switch some volumes\naround on short notice?  Did you ever convert a disk volume from another\napplication to TSO use, and be forced to remove it from SYSDA, so the\nprogrammers wouldn't clog the volume up with their test files?  Were\nyou ever forced to divide your cartridge drives into separate esoteric\ncategories during production hours, to keep some of the devices clear\nfor high priority work?\n\n     How many times have you told your management that these maneuvers\nwould require an IOGEN, or an MVSCP and an IPL?\n\n     If you used DYNAMASK, you'd never have to give them such an\nanswer.  You'd simply tell them:  \"Give me a minute and I'll fix it up\nfor you.\n\n     DYNAMASK is found on File 400 of the CBT MVS Tape, distributed\nby NaSPA (414) 423-2420, and by the Share Program Library Agency at\nthe University of Miami in Florida, (305) 284-6257.  DYNAMASK is also\navailable on the L.A. MVS Users Group Tape.  Merv Hemp (818) 841-9470\nis in charge of that tape.\n\n\nWHAT IS DYNAMASK?\n\n     DYNAMASK is a program which rebuilds the \"Eligible Device Table\"\nof MVS, using control card input to change the original table.  You\nset things up in a general way, with the MVSCP.  Then you can adjust\nthe device name setup on the fly, more finely, with DYNAMASK.\nDYNAMASK, at this writing, is completely supported through MVS/ESA\n4.2.  Steve Smith of Security Pacific Automation Company, does the\nsupport work.  (Now at SERENA International in Burlingame, CA.)\n\n     What is the Eligible Device Table (or the EDT) in MVS.  The EDT\nis an incore table that has all your general unit names.  You code the\nunit names in the \"UNIT=\" parameter of the DD card in your JCL.  Each\nunit name is associated in the EDT with a list of device addresses\nwhich are eligible to be used with that particular unit name.  When\nyou ask for the unit name in your JCL, MVS uses the Eligible Device\nTable to find a particular device, such as a tape drive, that fits the\nrequirements for the unit type you specified.\n\n     As we said before, The EDT is generated, for pre-SP2.2 systems,\nby the IOGEN process, which consists of coding assembler SYSGEN macros\nto fit your unit and address configuration, and assembling them with\n\"GENTYPE=(IO,x)\", or \"GENTYPE=EDT\" as a parameter in the GENERATE\nmacro.  For SP2.2 and later systems, the MVSCP process was created\nfor the purpose of separating IO-related system setup from the process\nof nucleus creation.  IO-related information after SP2.2 is not in\nIEANUC01, the system nucleus.  In vanilla (IBM-shipped) MVS, once the\nEDT information was put out, you can't change it without an IPL. There\nare lots of shops where it's hard to IPL very often.  These shops\ndon't have much flexibility in swapping devices around, even at\nSP 2.2 or above.\n\n     DYNAMASK can be executed, almost at any time, by starting a PROC.\nDYNAMASK can create new general unit names for you, at will.  DYNAMASK\ncan also adjust existing unit names to include or exclude more devices\nfrom each name.\n\n     I'd like to mention another fact before going into the\nparticulars of how DYNAMASK works.  In the \"UNIT=\" parameter of a DD\ncard, one may actually hard-code a specific device unit address\nnumber.  You can specify a particular tape drive to use, such as\n\"UNIT=48C\".  When there are a lot of tape drives, you may not wish to\nbe so specific.  You may want to specify a general unit name, such as\n\"UNIT=TAPE\" if you don't care which drive you'll get.  When an eligible\ntape drive becomes available, you'll get that drive.\n\n      There are two types of general unit names.  These are:  generic\nunit names, and esoteric unit names.\n\n      Generic unit names are device class numbers, for example:\n\"UNIT=3480\" or \"UNIT=3400-6\".  Esoteric unit names are words that have\nto start with alpha characters the way pds member names do.  Esoteric\nnames are usually created to be descriptive of the devices to which\nthey refer.  Some examples are:  \"UNIT=CART\", \"UNIT=DISK3350\", or\n\"UNIT=SYSTSO\".  DYNAMASK can create new generic and esoteric unit\nnames, and can assign devices to them.  Your installation's unit name\nstructure can be made creatively interesting in short order, or\notherwise adjusted to the shop's needs.\n\n      One more thing.  Because of release dependencies, there are two\ndifferent versions of DYNAMASK that are distributed on the CBT Tape\nFile 400.  The Pre-SP 2.2 version of DYNAMASK is called DYNAMSK7.  The\nSP2.2 thru ESA 3.1.3 version is called DYNAMSK2.  Support for SP4.1 is\nhopefully forthcoming, and is being developed at the time of this\nwriting.  It remains to be seen whether IBM's work on dynamic device\nreconfiguration in SP4.2 will obsolete DYNAMASK, or whether DYNAMASK,\nafter being fitted for that SP4.2, will do the job better than IBM's\neffort.\n\n\nHOW IS DYNAMASK USED?\n\n      The DYNAMASK program has to be authorized, and must be executed\nfrom an authorized library.  DYNAMASK is generally invoked as a\nstarted task, which accesses a card-image dataset that has its\nexecution parameters.  These parameters tell DYNAMASK which addresses\nto move among which unitnames.  The DYNAMASK data is in the form of\ncommands which specify an add or delete indicator, a partial or\ncomplete unitname, followed by (partial) addresses or volume serial\nnames to include or exclude.  See Figure One for a sample DYNAMASK\nPROC, and Figure Two for sample data commands.\n\n      DYNAMASK takes only a few seconds to execute.  Steve Smith\nrecommends (in writing) that the system should not have much activity\nwhile DYNAMASK is running.  One day, I asked him how great that risk\nwas (because I needed to run DYNAMASK in the middle of the day).  He\nsaid that during a small window, while bit masks were being moved\naround, some job might try to allocate a dataset on one of the\ndevices being affected.  This could cause the job to have an error.\nBut he said the risk was not too great, and he knew of one shop that\ntriggered off DYNAMASK executions automatically, several times during\nthe day, without apparent harm.  Most usually, shops will run a\nDYNAMASK procedure started by a COMMNDxx or IEACMDxx member of\nSYS1.PARMLIB shortly after IPL.\n\n      Generally, DYNAMASK is run when you have to move devices\naround, where it's inconvenient to prepare different MVSCP's and\nIPL.  Most shops are constrained concerning IPL's.  One bank has\nan automatic teller system that has only one hour of downtime allowed\nover several months.  DYNAMASK helps that system over and over again.\nMost shops are not so constrained, but they find waiting for an IPL\nto be constrictive, and they would rather have an alternative if one\nwere available.\n\n      How do you set the DYNAMASK control cards up?  I've decided to\npresent the rules for DYNAMASK execution in Steve Smith's words.  See\nFigure Three for DYNAMASK help information, which comes from Steve's\ncomments in the assembler source code.\n\n\nOTHER PROGRAMS THAT ARE DISTRIBUTED WITH DYNAMASK.\n\n      File 400 of the CBT Tape, which contains DYNAMASK, and the\ncorresponding file on the L.A. MVS Users Group Tape, have other\nrelated programs included besides the two DYNAMASK versions.\nI'll quickly describe them.\n\n      DYNASWAP provides the ability to swap all unitname EDT\naffiliations of two offline devices.  Suppose one disk drive goes bad,\nand you move its data to another drive.  You'd like the new drive to\nbehave exactly as the old one did, as programmers execute jobs against\nthe new pack's data.  Problem is that the new drive is at a different\naddress, and the unitname designations in the EDT are keyed to\naddresses, not to volume serial names.  If you have a pack called\nTSO001 at address 2C9, it might behave differently than a renamed pack\nTSO001 at address 9A5.  DYNASWAP will flip the EDT-defined properties\nof address 2C9 with those of address 9A5, if you ask it to.  Then,\nthe new TSO001 at 9A5 will behave in allocations, exactly as the old\none at address 2C9 did.\n\n      UCBMASK is a program which will perform the function of the\nVATLSTxx member in SYS1.PARMLIB, but that function can be done at any\ntime, not just at IPL time.  UCBMASK will change the mount attributes\nof many disk devices at once, according to the contents of control\ncards.  The control cards for UCBMASK do not follow the format of the\nVATLSTxx cards.  Look in the source code documentation for UCBMASK to\nlearn the format of the control cards and the layout of the JCL to run\nthe program.\n\n      VATUCB will read the cards in an old-style (through SP2.2.0)\nVATLSTxx member and adjust the mount attributes of all those disk\nvolumes accordingly.  It will do the function of UCBMASK, but the\ncontrol card format is exactly that of a VATLSTxx SYS1.PARMLIB\nmember.  It may be possible, if an old-style VATLSTxx member is coded\nfor an SP2.2.3 system or higher, to execute the VATUCB program\nsuccessfully.\n\n      SYSUNITS is a program that will report unit addresses associated\nwith a list of unitnames.  The SYSUNITS program can be used to verify\nif the changes done by DYNAMASK are in effect.  SYSUNITS performs a\nvery useful reporting function in the \"EDTGEN\" area.\n\n\nIN SUMMARY.\n\n      The subject of the \"Instant EDTGEN\" is dear to the administrators\nof installations who don't IPL frequently, and who move devices around\noften.  The DYNAMASK program makes trivial work of an awkward MVS\nconstruction that device ADDRESSES, and not device volume serial names,\ndetermine membership in the community of devices defined by any\nunitname.  DYNAMASK performs instant changes of unitname membership,\neither by address, or by volume serial name.  No IPL is required to\nexecute any of these changes on an MVS system.\n\n      The convenience of DYNAMASK, together with related programs\nthat are delivered with it, saves MVS installations much time, and\neliminates grief among operations and systems people alike.  DYNAMASK\nis currently supported through MVS/ESA 4.2.\n\n      I hope this knowledge will help many of you run your shops\nbetter.  In any case, we hope to see you again next month.  Good\nluck.\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE ONE.   This is a sample procedure to execute DYNAMASK as\n              a started task.  Note that the control cards can\n              be found in member DYNAMCTL of SYS1.PARMLIB.\n\n\n\n\n//DYNAMASK PROC M=DYNAMCTL,P='START IPL POSTPROCESS'\n//DYNAMSK2 EXEC PGM=DYNAMSK2,PARM=&P\n//SYSIN DD DISP=SHR,DSN=SYS1.PARMLIB(&M.)\n\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE TWO.    This is a sample deck of DYNAMASK control cards,\n               laced with many comments in an attempt to describe\n               what is going on.\n\n\n\n\n*   Comment card, add all volumes with volser starting with SYSDA\n*    to the SYSDA group of devices.\nSYSDA SYSDA*\n*   Add volumes SYSDA1, SYSDA2, SYSDA3, SYSDA4 to unitname SORT.\nSORT  SYSDA1,SYSDA2,\n*   Comment card, the next card is continuation of the previous one.\n SYSDA3,SYSDA4\n*   Remove devices 48E and 48F from the generic unitname 2400-3.\n-2400-3 /48E,/48F\n*   Add some devices to the category of units called TAPE1.\nTAPE1  /42*,/5*,/440-45F\n*   Create a unit name called SYSVIO.  Include volser SYSDA1 under\n*    this unitname.  Designate SYSVIO to handle VIO.\n+SYSVIO SYSDA1\n\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE THREE.   Steve Smith's help notes to describe the rules for\n                coding DYNAMASK control cards.\n\n\n\n\n                   DYNAMSK2 CONTROL CARD FORMAT\n\n      STARTING IN COLUMN 1, PUT THE UNIT NAME TO BE CHANGED OR ADDED\n      FOLLOWED BY A BLANK.\n\n      THIS IS FOLLOWED BY VOLUME(S) AND/OR UNIT ADDRESS(ES) TO BE\n      ASSIGNED TO THIS UNIT NAME.  VOLUMES CAN BE SPECIFIED ONLY FOR\n      DISK DEVICES FOR UNIT NAMES OF DASD ONLY.\n\n      VOLUMES ARE OF THE FORM:  ONE TO SIX CHARACTER VOLUME IDS.\n      LIKEWISE, A MODEL VOLUME OF ONE TO FIVE CHARACTERS PLUS\n      AN ASTERISK WILL SELECT ALL VOLUMES THAT MATCH THE MODEL.\n\n      UNIT ADDRESS ARE OF THE FORM: SLASH (/) AS FIRST CHARACTER,\n      FOLLOWED BY THE 3 DIGIT HEXIDECIMAL UNIT ADDRESS.\n      LIKEWISE A MODEL 1 OR 2 DIGIT HEXIDECIMAL ADDRESS PLUS\n      AN ASTERISK WILL SELECT ALL UNITS THAT MATCH THE FIRST GIVEN\n      DIGITS. A RANGE OF UNITS MAY BE SPECIFIED AS FOLLOWS /CUU-CUU\n\n\n      IF MORE THAN ONE VOLUME OR UNIT ADDRESS IS NEEDED, EACH IS\n      SEPARATED BY A COMMA.  IF MORE ENTRIES ARE REQUIRED THAN\n      CAN BE CONTAINED ON ONE CARD, THE CARD CAN BE CONTINUED BY\n      PLACING A COMMA AFTER THE LAST ENTRY.  THE NEXT CARD MUST\n      BE CONTINUED ON OR AFTER COLUMN 2.\n\n      THE SPECIFIED UNIT NAME ASSIGNMENTS NORMALLY REPLACE ALL\n      PREVIOUS ASSIGNMENTS.  HOWEVER, IF A MINUS (-) PRECEDES\n      THE UNIT NAME, THE SPECIFIED UNIT...VOLUME ENTRIES WILL BE\n      EXCLUDED FROM THE EXISTING ASSIGNMENTS DERIVED FROM SYSGEN.\n\n      IF A PLUS (+) PRECEDES A UNIT NAME, THAT UNIT NAME IS\n      MARKED FOR VIO.\n\n      AN ASTERISK (*) IN COLUMN 1 INDICATES A COMMENT CARD.\n      A COMMENT CARD CAN BE PLACED ANYWHERE.\n\n      SAMPLES:\n\n           SYSDA SYSDA*\n\n           SORT  SYSDA1,SYSDA2,\n           * COMMENT CARD, THE NEXT CARD IS CONTINUATION OF PREVIOUS\n            SYSDA3,SYSDA4\n\n           -2400-3 /48E,/48F\n\n           TAPE1  /42*,/5*,/440-45F\n\n           +SYSVIO SYSDA1\n\n      IF THE SAME UNIT NAME IS SPECIFED MORE THAN ONCE, ONLY\n      THE FIRST IS USED.\n\n      ANY ERROR OR INVALID SPECIFICATION IN A UNIT NAME CAUSES\n      THAT UNIT NAME NOT TO BE UPDATED.\n\n      ANY ERROR OR INVALID SPECIFICATION IN A UNIT ADDRESS OR\n      VOLUME WILL BE IGNORED AND THE UNIT NAME WILL BE UPDATED\n      WITH ANY CORRECT UNIT ADDRESSES AND/OR VOLUMES. MISSING\n      VOLUMES ARE IGNORED.\n\n      ALL UNCHANGED UNIT NAMES FROM THE SYSGEN ARE RETAINED.\n      ONLY UNIT NAMES TO BE CHANGED NEED BE SPECIFIED.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9107JL": {"ttr": 8710, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x93!\\x0f\\x01\\x00)\\x9f\\x11G\\x02\\x05\\x02\\x05\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 517, "newlines": 517, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                            July 1991\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\n\nMAKING YOUR OWN PTFS--A VALUABLE TECHNIQUE.\n\n\nINTRODUCTION.\n\n      One of my ongoing campaigns in this column is to advocate doing\nuseful things, even if at first glance they seem unusual, offbeat, or\neven shocking.  You have to be resourceful oftentimes and look at the\noperating system from a different angle.  In the process of doing\nthat, problems will be solved and new horizons will open up where\nthere seemed to be nothing before.\n\n      A central theme in my system programming endeavors is the\nfollowing principle:  \"One must be able to discover as much about the\noperation of a system from the system itself, as from its documentation\nor from any other external description.\"  The machine is reading the\ncode and 'looking at' the system structure.  Therefore the code itself\nand the system structure must be harnessed to tell us as much as\npossible about how they themselves actually work.\n\n\nAN EXAMPLE OF THE PRINCIPLE.\n\n      An illustration of this principle is the problem of creating an\nSMP sysmod to install software, starting from the actual software\nitself.  Let's illustrate the situation further.  Starting from a load\nmodule, you want to construct an SMP sysmod--a PTF, a FUNCTION, or a\nUSERMOD, to install that load module on a new system or to reinstall\nit on your current system.  What about \"non load module\" software?  If\nyou have panels, macros, or source code, you want to make sysmods to\nre-install those things as SMP elements, on any SMP system.\n\n      Can this be done?  If it can, then how is it done?  WHY and WHEN\nshould it be done?\n\n      To tell you the truth, when I first considered this subject for\nstudy, I didn't really care why such \"SMP sysmod creation\" should be\ndone.  I really just had a big desire \"to pretend that I was IBM\", and\nto dissect the structure behind IBM's maintenance packaging procedures.\nLater, I came across situations in my work, where doing these\nprocedures myself was of great practical value.  I also came across\nother system programmers trying this same kind of activity.  That is\nwhy I want to show you these techniques now.  I want to point out\nsituations where they will save you grief, and teach you much.\n\n\nMAKING YOUR OWN PTFS FROM INSTALLED SOFTWARE.\n\n      It's best to teach programming principles from practical\nexamples.  Here's one case to show how we profited from packaging\nour own PTF.\n\n      A lot of installations \"frontend\" IEBCOPY.  This involves\nlinkediting some non-IBM CSECT into the IEBCOPY load module.  After\ngaining control and doing some processing, the \"frontend\" module might\nthen link to the normal IBM-supplied IEBCOPY software afterwards.\nOften, frontending is used in IEBCOPY for the purpose of throwing out\nenqueues.  The \"frontend\" module will enqueue on the dataset(s) being\n\"copied to\" or \"compressed\".  Then IEBCOPY is called upon to do its\nnormal work.  At the end, control is returned to the \"frontend\", which\nreleases its enqueues to the dataset name(s).\n\n      I recently had some trouble installing a usermod that hooked a\nfrontend CSECT into the load module IEBCOPY.  We were running DFP\nRelease 2.4.  During the SMP processing, I messed up the load module\nIEBCOPY on my SMP library very badly.  The only obvious recovery was\nto reinstall all of DFP Release 2.4 data management, because that was\nthe \"product\" to which IEBCOPY belonged.\n\n      It strikes me as overkill to reinstall all of data management,\nrather than to reinstall one load module.  Fortunately, there was a\nway out which worked well for us.  IEBCOPY was the only load module\naffected.  Since our problem was with this one load module only, I\ndecided to look at \"how IBM does things\", when they want to completely\nreplace one load module in the operating system.\n\n      IBM recently shipped PTF UY50707, for DFP Release 3.2, as a\ncomplete reinstall and repackaging of the entire load module IEBCOPY.\nIBM had needed to rewrite much of IEBCOPY, because IEBCOPY needed the\ncapability of copying their new \"PDSE\" library structures.  PTF\nUY50707 employs many SMP packaging features, so we shall use PTF\nUY50707 as our model.  See Figure Two, showing the structure of PTF\nUY50707, and a description of its essential parts.\n\n      You can probably order PTF UY50707 from IBM if you want a better\nlook at it.  Just order that PTF number specifically, no matter what\nlevel of the operating system you are running.\n\n      Following the principle we outlined above, we will construct our\nown PTF from the system itself.  Our only starting point will be the\ngood IEBCOPY load module from a running SYS1.LINKLIB library.  The\nSMP-maintained IEBCOPY load module from the most recent backup taken\nbefore the mishap, should be exactly right for our needs.\n\n\nGETTING STARTED.\n\n      How can we start?  To correct any SMP errors, we shall have to\nparallel IBM's original install of IEBCOPY by SMP, which was built a\nCSECT at a time.  A mere SMP copy of the entire IEBCOPY load module\nfrom another library to LINKLIB will not correct the SMP errors on a\nmodule level.  To do that, we need to build a CSECT-by-CSECT\nreconstruction of our IEBCOPY load module from individual object\ndecks, following the way that PTF UY50707 does it.\n\n      Where can we get the required object decks?  Further, how can we\nobtain linkedit JCL to feed into SMP via JCLIN (following PTF UY50707)\nso that our IEBCOPY load module will be correctly rebuilt by SMP from\nour object decks?\n\n      The answers come from TOOLS WHICH LEARN ABOUT IEBCOPY FROM\nIEBCOPY.  There are enough of these tools in the public domain to do\nthe job we require.  Two functions need to be done that require\ntools:  creating JCLIN, which instructs SMP how to properly linkedit\nIEBCOPY, and creating object decks for each CSECT in IEBCOPY.\n\n      The \"PDS\" product from either the CBT MVS Tape or the L.A. MVS\nUsers Group Tape, can generate JCLIN, or something close to it.  \"PDS\"\nhas an amazing function which is done by its \"MAP\" subcommand with the\noptional \"RELINK\" keyword.  This \"MAP-RELINK\" function of \"PDS\" will\ngenerate accurate re-linkedit JCL for a load module, starting only\nfrom the load module itself.  See Figure One to show the output of the\n\"PDS\" command:  \"MAP IEBCOPY RELINK\".\n\n      If your shop is licensed for the vendor product, PDS/E Sysprog\nUtilities, PDS/E can perform the \"MAP-RELINK\" function too, although\nPDS/E does more, as we'll mention below.  I want to concentrate on the\nmore accessible \"public domain\" tools here.  I'm only mentioning the\nvendor product, for the benefit of those of you who already have it.\n\n      The PDS(/E) \"MAP IEBCOPY RELINK\" output can easily be adapted as\nJCLIN.  See the \"++JCLIN\" part of Figure Four to see how we've done it.\n\n      Now what about creating object decks for the IEBCOPY CSECTs?\n\n      Object decks for the IEBCOPY CSECTs can be created from the\nIEBCOPY load module, one CSECT at a time, using the DELINK0 utility\nthat is on the CBT MVS Tape.  The DELINK0 utility creates object decks\nfrom a load module.  This is the reverse process to linkage editing.\nTo determine the names of the IEBCOPY CSECTs to delink, use the \"PDS\"\nMAP subcommand (without any extra keywords), or IBM's AMBLIST service\naid against your IEBCOPY load module.  See Figure Three for JCL to run\nthe DELINK0 utility.  If you are licensed for PDS/E, that product has\nits own DELINK subcommand, so you won't need DELINK0.\n\n      The \"PDS\" product can be found on File 182 of the CBT Tape.\nDELINK0 can be found on File 316.  The CBT Tape is obtainable from\nNaSPA in Milwaukee, (414) 423-2420, or from SPLA at the University of\nMiami in Florida, (305) 284-6257.  The L.A. MVS Users Group Tape is\nadministered by Merv Hemp, (818) 841-9470.\n\n\nPUTTING THE PIECES TOGETHER.\n\n      Our aim is to make a PTF that is patterned after IBM's UY50707,\nbut which re-installs our own release of IEBCOPY exactly.  When our\nPTF is APPLYed and ACCEPTed on our SMP system, all of the IEBCOPY\nCSECTs will be renewed on the DISTLIB, and the load module IEBCOPY\non LINKLIB will be completely replaced and cleaned up.\n\n      See Figure Two for our starting point, and Figure Four for our\napproximate ending point.  The following paragraphs will describe some\nof the intervening details.  We shall follow Figure Two's description\nof the various segments comprising PTF UY50707.  Some of UY50707's\nparts are essential to our work.  Other parts are unnecessary for us\nto be concerned about.  Let's start.\n\n      Every PTF needs a \"++PTF\" and a \"++VER\" statement.  It is\nsufficient to pattern these from an existing IBM PTF.  The PRE and\nSUP statements are crucial.  You should be scrupulous not to SUP any\nIBM sysmods in your user-written sysmod.  Keep the PRE's to an\nabsolute minimum, too.  You may write your documentation in comments,\nthe way IBM does.  IBM usually uses the ++VER statement as a place\nto insert its descriptions.\n\n      You may wish to write a ++HOLD statement for later reference\nby your installation.  However, you'll have to BYPASS it during the\nAPPLY.  Probably enough adequate documentation can be put into normal\ncomments.  Make your own decision on a ++HOLD statement.\n\n      I'd shy away from including the ++DELETE for the LMOD of IEBCOPY.\nAs long as you're replacing all of the CSECTS and you're supplying\ncomplete new JCLIN, the entire load module will probably be replaced\nanyway.  In UY50707, IBM was radically changing the structure of the\nIEBCOPY load module, and they wanted to be sure that the unnecessary\npieces from the old version were blown away.\n\n      Inline JCLIN must be carefully done.  The MAP-RELINK output\ngenerated by the \"PDS\" command is a good and accurate starting point.\nJust make sure that your JCLIN is similar in format to the JCLIN in\nUY50707.  There is one difference to be noted.  SMP recognizes the\n\"SYSGEN-type\" linkage editing procedure called \"LINKS\", which is\nsupplied by IBM for IOGEN or SYSGEN purposes.  A perfectly good\nalternative to using the \"LINKS\" procedure in JCLIN is to put an EXEC\ncard for the program \"IEWL\" directly in the JCLIN.  Look at Figure\nFour again, to see how we did it.\n\n      We are not changing the form of our IEBCOPY load module, so\nthe SYSGEN macros relating to IEBCOPY linkedit JCL generation need\nnot be modified.  We are also not deleting any of the individual\nMOD entries for CSECTs within IEBCOPY, so the second set of ++DELETE\nstatements in UY50707 (referring to the MOD entries) are not relevant\nto us, unless we want to get rid of an extra \"frontend\" CSECT.  In\nthat case, we should code a ++DELETE card to get rid of the frontend's\nMOD entry.\n\n      The final part of the PTF consists of ++MOD SMP statements,\neach followed by an object deck.  If your SMP records aren't badly\nmessed up, you may inquire on the RMIDs (i.e. PTF levels) of all your\nMOD entries belonging to IEBCOPY CSECTs.  If the old PTFs are still\naround, you can possibly obtain non-base-level object decks by lifting\nthem from the original PTFs.  For CSECTs at base level, or in all\nother cases, the object decks will have to be obtained by the process\nof \"delinking\".\n\n      See Figure Three for JCL to run the DELINK0 program.  DELINK0\nonly produces a CSECT at a time, so the process will have to be\nrepeated for all CSECTs in IEBCOPY for which you don't have an\nobject deck.  One thing needs to be noted here.  DELINK0 in its\ncurrent form produces object decks with ESD's that are AMODE 24\nand RMODE 24 only.  This \"mode\" problem (for the public domain\ndelinker) is being worked on.  PDS/E has its own delinker which does\nnot have this problem.  But PDS/E can do our entire process\n\"automagically\" anyway, using its \"SMPGEN\" subcommand with the\nappropriate keywords.  We'll briefly mention this \"PDS/E\" feature\nat the end.\n\n      After the ++MOD cards pointing to DISTLIB(AOSU0) have been\ncreated, and the appropriate object decks have been placed carefully\nbelow each of these, the PTF has been constructed.  It must be slowly\nand scrupulously checked over.  If you are only overlaying existing\nSMP MOD entries, and are not deleting any MODs, an APPLY run with REDO\nshould write over any mistakes you make on the first try.  Because of\nthe \"REDO\" keyword, your APPLY can be done over and over again.  You\nshould not need to try a RESTORE.  But remember to always be very\ncareful.\n\n      Always do an APPLY CHECK before a real APPLY of your own PTF.\nAn APPLY CHECK will often uncover silly sysmod construction mistakes.\nAfter the APPLY of your PTF, look at the resulting IEBCOPY load module\nwith AMBLIST or with the \"PDS\" MAP subcommand, and compare its CSECT\nstructure to that of the original \"good\" IEBCOPY load module.  They\nshould be exactly the same.  If you have a byte-by-byte or\nCSECT-by-CSECT comparison utility, now is the time to use it.\nTry to test the new load module any other way you can.\n\n      I'll conclude by mentioning the facilities in the vendor product\n\"PDS/E\" that automate most of this PTF-creation process.  The PDS/E\n\"DELINK\" facility and its \"MAP-RELINK\" capability can be combined,\nwhen its \"SMPGEN\" subcommand is invoked with the proper keywords.\nUsers of the PDS/E product are suggested to try the following\nsubcommand, while PDS/E is pointed at SYS1.LINKLIB.  The command is:\n\n \"SMPGEN IEBCOPY MOD DISTLIB(AOSU0) SYSLMOD(LINKLIB) INLINE CSECT\"\n\nYou'll be amazed at what is produced.  It looks a lot like Figure Four.\n\n\nCONCLUSION.\n\n      SMP \"disasters\" do not have to result in laborious restores\nfrom backups.  If the problem is localized, such as being restricted\nto one load module, it may be easier to fix by making a complete\nreplacement for the load module.  It helps to know how to construct\nyour own PTF, to accurately do the replacement.\n\n      Minimal software resources are required for this procedure.\nThat's because we're using available tools to find out \"about the\nsoftware, from the software itself\".\n\n      Good luck in these endeavors, and in all your other ones.\nSee you next month.\n\n\n\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n\nFIGURE ONE.   Sample output of the PDS product's \"MAP\" subcommand\n              with \"RELINK\" option.  Input to the command is the load\n              module IEBCOPY from our DFP Release 2.4 system.  There\n              are no other inputs.  This is a good illustration of a\n              tool that helps you \"learn about the system, from the\n              system itself\".\n\n\n\n>map iebcopy relink\n\n//LKED   EXEC  PGM=IEWL\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(1024,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.LINKLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IEBCOPY)\n ORDER   IEBDSMCA(P),IEBDSCPY,IEBVTM,IEBWSAM,IEBBAM,IEBCNVT,IEBCPMOD\n ORDER   IEBDRB,IEBDRD,IEBDSCP2,IEBDSU,IEBDV1,IEBDV1MG,IEBDWR\n ORDER   IEBIOE,IEBIOEMG,IEBLDUL,IEBMCM,IEBRSAM,IEBSCN,IEBVCT\n ORDER   IEBVDM,IEBVMS,IEBVMTXT,IEBVTT,IEBWSU,IEBWSUMG\n SETCODE AC(1)\n ENTRY   IEBDSCPY\n NAME    IEBCOPY(R)\n/*\n\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE TWO.   This shows the structure of PTF UY50707 which re-ships\n              the entire IEBCOPY load module.  This PTF adds function\n              to IEBCOPY so that it will copy the new PDSE libraries.\n              Our reason for using this PTF is to illustrate how\n              IBM will package a complete reshipment of an existing\n              load module.  We wish to distill the elements of IBM's\n              packaging, so that we can re-install our own IEBCOPY\n              load module with SMP at our own currently installed level.\n\n              Parts of the PTF are:\n               (1)  The ++PTF and ++VER statements with the PTF\n                    documentation.\n               (2)  ++HOLD statement and ++DELETE statement for the\n                    IEBCOPY LMOD entry (unnecessary for our purposes).\n               (3)  ++JCLIN  (crucial for us).\n               (4)  ++DELETE statements for MODs being eliminated in\n                    the rewrite (unnecessary for us unless we're\n                    deleting the MOD entry for a frontend module).\n               (5)  ++MAC statement to revise the SYSGEN macro for\n                    IEBCOPY (unnecessary if you don't change the\n                    linkedit structure of IEBCOPY).\n               (6)  ++MOD statements for each CSECT in IEBCOPY\n                    followed by the object deck for each CSECT\n                    (crucial to replace the working software properly).\n\n\n++ PTF (UY50707)        /*    5665-28445-HDP3320-\n//UY50707  JOB 5665-50707-0,28445,MSGLEVEL=(1,1),CLASS=A      */   .\n++ VER (Z038)\n   FMID(HDP3320)\n   PRE  (UY44382)\n   SUP  (UY43696,AY27240,AY27237,AY24733)\n /*\n     ( DOCUMENTATION FOR THE PTF IS INSERTED HERE. )\n */.\n++ HOLD(UY50707) SYS FMID(HDP3320) REASON(DELETE) DATE(90146)\n   COMMENT\n    (THIS PTF CONTAINS A ++DELETE MCS FOR THE FOLLOWING LMOD: IEBCOPY\n     SMP/E WILL NOT RESTORE THIS PTF.).\n++DELETE IEBCOPY\n  SYSLIB(LINKLIB).\n++ JCLIN .\n//SYSGEN0 JOB 1,'SYSTEM GENERATION',\n//      MSGLEVEL=1,MSGCLASS=A,\n//      CLASS=A\n//SG22 EXEC LINKS,\n// PARM='NCAL,LIST,XREF',\n//    UNIT='3380',SER=SYSRES,N=SYSX,NAME=LINKLIB,P1=' ',\n//    MOD=,P2=' ',OBJ=MACLIB,CLASS=A\n//AOSU0 DD DISP=SHR,VOLUME=(,RETAIN),DSNAME=SYS1.AOSU0\n//SYSLIN DD *\n INCLUDE AOSU0(IEBCFAMS)\n INCLUDE AOSU0(IEBCMSG)\n INCLUDE AOSU0(IEBCNVT)\n INCLUDE AOSU0(IEBCOMCA)\n INCLUDE AOSU0(IEBCPMOD)\n INCLUDE AOSU0(IEBCRDC)\n INCLUDE AOSU0(IEBDRB)\n INCLUDE AOSU0(IEBDRD)\n INCLUDE AOSU0(IEBDSCPY)\n INCLUDE AOSU0(IEBDSU)\n INCLUDE AOSU0(IEBDV0)\n INCLUDE AOSU0(IEBDWR)\n INCLUDE AOSU0(IEBIOE)\n INCLUDE AOSU0(IEBMCM)\n INCLUDE AOSU0(IEBPRINT)\n INCLUDE AOSU0(IEBRSAM)\n INCLUDE AOSU0(IEBSCM)\n INCLUDE AOSU0(IEBVCT)\n INCLUDE AOSU0(IEBVDM)\n INCLUDE AOSU0(IEBVTM)\n INCLUDE AOSU0(IEBVTT)\n INCLUDE AOSU0(IEBWSAM)\n INCLUDE AOSU0(IEBWSU)\n ORDER   IEBCOMCA(P),IEBCOMCB(P)\n SETCODE AC(1)\n MODE    AMODE(24),RMODE(24)\n ENTRY   IEBDSCPY\n NAME    IEBCOPY(R)\n/*\n++ MOD(IEBDV1) DISTLIB(AOSU0  ) DELETE .\n++ MOD(IEBBAM) DISTLIB(AOSU0  ) DELETE .\n++ MOD(IEBLDUL) DISTLIB(AOSU0  ) DELETE .\n++ MOD(IEBVMS) DISTLIB(AOSU0  ) DELETE .\n++ MAC      (SGIEH402) DISTLIB(AGENLIB ).\n     (CONTENTS OF MACRO FOR SYSGEN SUPPORT OF IEBCOPY.)\n++ MOD(IEBCFAMS) DISTLIB(AOSU0) .\n - - -  Object deck for module IEBCFAMS   - - -\n++ MOD(IEBCMSG ) DISTLIB(AOSU0) .\n - - -  Object deck for module IEBCMSG    - - -\n++ MOD(IEBCNVT ) DISTLIB(AOSU0) .\n - - -  Object deck for module IEBCNVT    - - -\n++ MOD(IEBCOMCA) DISTLIB(AOSU0) .\n - - -  Object deck for module IEBCOMCA   - - -\n++ MOD STATEMENTS FOR EACH OF THE CSECTS, FOLLOWED BY OBJECT DECKS\n - - -  Data abbreviated for brevity      - - -\n\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n\nFIGURE THREE.  JCL to execute the DELINK0 program.  DELINK0 starts\n               with a load module and creates an object deck for one\n               CSECT at a time.  The process is the reverse of linkage\n               editing.  Source code for DELINK0 in assembler language\n               may be found on File 316 of the CBT MVS Tape.  The JCL\n               below will \"delink\" one CSECT from load module IEBCOPY.\n               For our purposes, the process has to be repeated for\n               all of the CSECTs in IEBCOPY.  You can use the AMBLIST\n               service aid distributed by IBM, or the \"PDS\" package's\n               \"MAP\" subcommand, to determine the names of all the\n               CSECTs in a load module.\n\n\n\n//TSTXDLNK JOB ,'TECH.SUPP-SAM.GOLOB',CLASS=M,NOTIFY=TSTBSSG,\n//        MSGLEVEL=(1,1),MSGCLASS=T TYPRUN=HOLD\n//*\n//DELINK  EXEC PGM=DELINK0,REGION=2000K\n//STEPLIB  DD DISP=SHR,DSN=TST.TSO.CMDLIB\n//SYSPRINT DD SYSOUT=*\n//SYSLIB DD DISP=SHR,DSN=SYS1.LINKLIB                 <=== load library\n//SYSPUNCH DD DISP=(NEW,PASS),DSN=&&TEMP,UNIT=SYSDA,\n//       DCB=(RECFM=F,LRECL=80,BUFNO=255),SPACE=(TRK,(5,20))\n//SYSIN   DD *\n IEBCOPY IEBVMTXT\n//*\n//GENER   EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD DUMMY\n//SYSUT1   DD DSN=&&TEMP,DISP=(OLD,PASS)\n//SYSUT2   DD DISP=SHR,DSN=TST.DELINK.PUNCH(IEBVMTXT)  <== object deck\n\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n\nFIGURE FOUR.   Our PTF to reinstall IEBCOPY at the DFP Release 2.4\n               level.  The \"++PTF\" and \"++VER\" part has been patterned\n               after an IBM PTF.  The JCLIN can be generated by the\n               \"PDS\" subcommand, \"MAP IEBCOPY RELINK\", and edited a\n               bit to add the ddname for the distribution library,\n               AOSU0.  The \"PDS\" subcommand, \"MAP IEBCOPY\" will supply\n               the names of the CSECTs in IEBCOPY to delink.  The\n               DELINK0 program can be used to create object decks\n               for these CSECTs to be placed below the \"++MOD\" cards.\n               If you are licensed for the PDS/E product which has its\n               own \"delink\" capability, all of the data from the ++JCLIN\n               and below, can be created with the one PDS/E subcommand:\n               \"SMPGEN  IEBCOPY  MOD  DISTLIB(AOSU0)  SYSLMOD(LINKLIB)\n               INLINE  CSECT\".  The only input for the entire procedure\n               is the good load module, SYS1.LINKLIB(IEBCOPY).\n\n\n\n++ PTF (UY24CPY)        /*    5665-28445-HDP2240-DP9\n//UY24CPY  JOB 5665-44388-0,28445,MSGLEVEL=(1,1),CLASS=A     */  .\n++ VER (Z038)\n   FMID(HDP2240)      /*\n       (You can write your own PTF documentation here. )\n */.\n++JCLIN  .\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//AOSU0    DD  DISP=SHR,DSN=SYS1.AOSU0\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.LINKLIB\n//SYSLIN   DD  *\n INCLUDE AOSU0(IEBDSMCA)\n INCLUDE AOSU0(IEBDSCPY)\n INCLUDE AOSU0(IEBVTM)\n - - -  INCLUDE statements for the other IEBCOPY CSECTs  - - -\n ORDER IEBDSMCA(P)\n ORDER IEBDSCPY\n ORDER IEBVTM\n - - -  ORDER statements for the other IEBCOPY CSECTs  - - -\n SETSSI  01113798\n SETCODE AC(1)\n ENTRY   IEBDSCPY\n NAME    IEBCOPY(R)\n++MOD(IEBDSMCA) DISTLIB(AOSU0)  .\n - - -  Object deck for module IEBDSMCA   - - -\n++MOD(IEBDSCPY) DISTLIB(AOSU0)  .\n - - -  Object deck for module IEBDSCPY   - - -\n++MOD(IEBVTM  ) DISTLIB(AOSU0)  .\n - - -  Object deck for module IEBVTM     - - -\n++MOD statements for the other IEBCOPY CSECTs  . . . . .\n - - -  Each ++MOD is followed by an object deck.  - - -\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9108AU": {"ttr": 8965, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x93!\\x0f\\x00\\x93\"?\\x11\\x02\\x02D\\x02D\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "1993-08-11T11:02:00", "lines": 580, "newlines": 580, "modlines": 0, "user": "SBGCSC"}, "text": " (This column is the same as the previous one, but it had to be\n  broken into two parts.  The previous version was the one I wrote\n  originally.   SG)\n\nMVS TOOLS AND TRICKS OF THE TRADE\nby Sam Golob\n\nMaking Your Own PTFs: A Valuable Technique\n\n      This is part one of a two-part series that focuses on PTFs and\nhow you can create your own.  This article examines the techniques\nnecessary to create an SMP sysmod to install load modules to your\nsystem.  Part two will focus on the actual creation of PTFs.\n\n      A central theme in my system programming endeavors is the\nfollowing principle:  \"One must be able to discover as much about the\noperation of a system from the system itself, as from its documentation\nor from any other external description.\" The machine is reading the\ncode and 'looking at' the system structure.  Therefore the code itself\nand the system structure must be harnessed to tell us as much as\npossible about how they actually work.\n\n\nAn Example of the Principle\n\n      An illustration of this principle is the challenge of creating\nan SMP sysmod to install software, starting from the actual software\nitself.  Let's illustrate the situation further.  Starting from a load\nmodule, you want to construct an SMP sysmod -- a PTF, a FUNCTION or a\nUSERMOD -- to install that load module on a new system or to reinstall\nit on your current system.  What about non-load module software?  If\nyou have panels, macros or source code you want to make sysmods to\nre-install those things as SMP elements on any SMP system.  Can this\nbe done?  If it can, then how is it done?  Why and when should it be\ndone?\n\n      To tell you the truth, when I first considered this subject for\nstudy, I didn't really care why such SMP sysmod creation should be\ndone.  I really just had a big desire to pretend that I was IBM and to\ndissect the structure behind IBM's maintenance packaging procedures.\nLater, I came across situations in my work, where doing these\nprocedures myself was of great practical value.  I also came across\nother system programmers trying this same kind of activity.  That is\nwhy I want to show you these techniques now.  I want to point out\nsituations where they will save you grief and teach you a lot.\n\n\nMaking Your Own PTFs From Installed Software\n\n      It's best to teach programming principles from practical\nexamples.  Here's one case to show how we profitted from packaging our\nown PTF.\n\n      A lot of installations \"frontend\" IEBCOPY.  This involves\nlinkediting some non-IBM CSECT into the IEBCOPY load module.  After\ngaining control and doing some processing, the \"frontend\" module might\nthen link to the normal IBM-supplied IEBCOPY software afterwards.\nOften, frontending is used in IEBCOPY for the purpose of throwing out\nenqueues.  The \"frontend\" module will enqueue on the dataset(s) being\n\"copied to\" or \"compressed\".  Then IEBCOPY is called upon to do its\nnormal work.  At the end, control is returned to the \"frontend\", which\nreleases its enqueues to the dataset name(s).\n\n      I recently had some trouble installing a usermod that hooked a\nfrontend CSECT into the load module IEBCOPY.  We were running DFP\nRelease 2.4.  During the SMP processing, I messed up the load module\nIEBCOPY on my SMP library very badly.  The only obvious recovery was\nto reinstall all of DFP Release 2.4 data management, because that was\nthe \"product\" to which IEBCOPY belonged.\n\n      It strikes me as overkill to reinstall all of data management,\nrather than to reinstall one load module.  Fortunately, there was a\nway out which worked well for us.  IEBCOPY was the only load module\naffected.  Since our problem was with this one load module only, I\ndecided to look at \"how IBM does things\", when they want to completely\nreplace one load module in the operating system.  IBM recently shipped\nPTF UY50707, for DFP Release 3.2, as a complete reinstall and\nrepackaging of the entire load module IEBCOPY. IBM had needed to\nrewrite much of IEBCOPY, because IEBCOPY needed the capability of\ncopying their new \"PDSE\" library structures.  PTF UY50707 employs many\nSMP packaging features, so we shall use PTF UY50707 as our model.\n\n      You can probably order PTF UY50707 from IBM if you want a better\nlook at it.  Just order that PTF number specifically, no matter what\nlevel of the operating system you are running.\n\n      Following the principle we outlined above, we will construct our\nown PTF from the system itself.  Our only starting point will be the\ngood IEBCOPY load module from a running SYS1.LINKLIB library.  The\nSMP-maintained IEBCOPY load module from the most recent backup taken\nbefore the mishap, should be exactly right for our needs.\n\n\nGetting Started\n\n      How can we start?  To correct any SMP errors, we have to parallel\nIBM's original install of IEBCOPY by SMP, which was built a CSECT at a\ntime.  A mere SMP copy of the entire IEBCOPY load module from another\nlibrary to LINKLIB will not correct the SMP errors on a module level.\nTo do that, we need to build a CSECT-by-CSECT reconstruction of our\nIEBCOPY load module from individual object decks, following the way\nthat PTF UY50707 does it.\n\n      Where can we get the required object decks?  Further, how can we\nobtain linkedit JCL to feed into SMP via JCLIN (following PTF UY50707)\nso that our IEBCOPY load module will be correctly rebuilt by SMP from\nour object decks?\n\n      The answers come from tools that learn about IEBCOPY from\nIEBCOPY.  There are enough of these tools in the public domain to do\nthe job we require.  Two functions need to be done that require tools:\ncreating JCLIN, which instructs SMP how to properly linkedit IEBCOPY,\nand creating object decks for each CSECT in IEBCOPY.\n\n      The PDS product from either the CBT MVS Tape or the L.A. MVS\nUsers Group Tape, can generate JCLIN, or something close to it.  \"PDS\"\nhas an amazing function which is done by its \"MAP\" subcommand with the\noptional \"RELINK\" keyword.  This \"MAP-RELINK\" function of \"PDS\" will\ngenerate accurate re-linkedit JCL for a load module, starting only\nfrom the load module itself.  Figure 1 shows the output of the PDS\ncommand:  \"MAP IEBCOPY RELINK\".\n\n      Now what about creating object decks for the IEBCOPY CSECTs?\nObject decks for the IEBCOPY CSECTs can be created from the IEBCOPY\nload module, one CSECT at a time, using the DELINK0 utility that is on\nthe CBT MVS Tape.  The DELINK0 utility creates object decks from a\nload module.  This is the reverse process to linkage editing.\n\n      To determine the names of the IEBCOPY CSECTs to delink, use the\nPDS MAP subcommand (without any extra keywords), or IBM's AMBLIST\nservice aid against your IEBCOPY load module.  See Figure 2 for JCL to\nrun the DELINK0 utility.\n\n      The PDS product can be found on File 182 of the CBT Tape.\nDELINK0 can be found on File 316.  The CBT Tape is obtainable from\nNaSPA in Milwaukee, (414) 423-2420, or from SPLA at the University of\nMiami in Florida, (305) 284-6257.  The L.A. MVS Users Group Tape is\nadministered by Tom Beuthin at (310) 812-4421.\n\n      Next month, I will focus on the actual PTF creation.\n\n\n\n\n\n\n\nFigure 1:   Sample output of the PDS product's \"MAP\"\n            subcommand with RELINK option.  Input to the command is\n            the load module IEBCOPY from our DFP Release 2.4 system.\n            There are no other inputs.  This is a good illustration\n            of a tool that helps you learn about the system, from\n            the system itself.\n\n>map iebcopy relink\n\n//LKED   EXEC  PGM=IEWL\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(1024,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.LINKLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IEBCOPY)\n ORDER   IEBDSMCA(P),IEBDSCPY,IEBVTM,IEBWSAM,IEBBAM,IEBCNVT,IEBCPMOD\n ORDER   IEBDRB,IEBDRD,IEBDSCP2,IEBDSU,IEBDV1,IEBDV1MG,IEBDWR\n ORDER   IEBIOE,IEBIOEMG,IEBLDUL,IEBMCM,IEBRSAM,IEBSCN,IEBVCT\n ORDER   IEBVDM,IEBVMS,IEBVMTXT,IEBVTT,IEBWSU,IEBWSUMG\n SETCODE AC(1)\n ENTRY   IEBDSCPY\n NAME    IEBCOPY(R)\n/*\n\n\nFigure 2:   JCL to execute the DELINK0 program.  DELINK0\n            starts with a load module and creates an object deck for\n            one CSECT at a time.  The process is the reverse of\n            linkage editing.  Source code for DELINK0 in assembler\n            language may be found on File 316 of the CBT MVS Tape.\n            The JCL below will \"delink\" one CSECT from load module\n            IEBCOPY. For our purposes, the process has to be repeated\n            for all of the CSECTs in IEBCOPY.  You can use the\n            AMBLIST service aid distributed by IBM, or the \"PDS\"\n            package's \"MAP\" subcommand, to determine the names of all\n            the CSECTs in a load module.\n\n\n\n//TSTXDLNK JOB ,'TECH.SUPP-SAM.GOLOB',CLASS=M,NOTIFY=TSTBSSG,\n//        MSGLEVEL=(1,1),MSGCLASS=T TYPRUN=HOLD\n//*\n//DELINK  EXEC PGM=DELINK0,REGION=2000K\n//STEPLIB  DD DISP=SHR,DSN=TST.TSO.CMDLIB\n//SYSPRINT DD SYSOUT=*\n//SYSLIB DD DISP=SHR,DSN=SYS1.LINKLIB                 <=== load library\n//SYSPUNCH DD DISP=(NEW,PASS),DSN=&&TEMP,UNIT=SYSDA,\n//       DCB=(RECFM=F,LRECL=80,BUFNO=255),SPACE=(TRK,(5,20))\n//SYSIN   DD *\n IEBCOPY IEBVMTXT\n//*\n//GENER   EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD DUMMY\n//SYSUT1   DD DSN=&&TEMP,DISP=(OLD,PASS)\n//SYSUT2   DD DISP=SHR,DSN=TST.DELINK.PUNCH(IEBVMTXT)  <== object deck\n\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n\nMVS Tools & Tricks\nAugust\n\n\nMaking Your Own PTFs: A Valuable Technique.  Part II.\n\nReview of Part I.\n\n      Last month, we introduced discussion on the topic of creating\nyour own PTF, if and when such action would help your installation.\nIf you acquire understanding of how IBM constructs their maintenance\nfixes, your own ability to keep the shop's maintenance structure in\norder, will grow.  Our present discussion will be limited to\nconstructing a complete SMP/E install of a system load module.  This\nexample will provide a rich model on which to build more SMP\nknowledge.\n\n      A central skill for all system programmers to acquire, is the\nability to learn about operating system structure, from the system\nitself.  This skill is directly applicable to our current task.  We\nwill show how to repair a load module IEBCOPY whose SMP installation\nwas \"irreparably damaged\" by the faulty install of a usermod.  Load\nmodule IEBCOPY will be completely reinstalled using SMP and our own\nPTF that we'll make ourselves.\n\n      The materials needed for this work are minimal.  All we shall\nneed, is the good load module IEBCOPY (from before the usermod was\ninstalled), a tool to generate its linkedit structure (to be able to\nbuild JCLIN) and a \"delinking tool\" to construct object decks for the\nseparate CSECTs of IEBCOPY, directly from the load module itself.\nThese tools are readily available in the public domain (from the CBT\nMVS Utilities Tape) or in the vendor product PDS/E Sysprog Utilities,\nif you happen to have that product already.\n\n      IBM has helped us by providing an example to follow.  The IBM\nPTF UY50707 is a complete reinstall of the load module IEBCOPY, which\nalso contains much SMP packaging knowledge.  No matter what level of\nMVS you are running, you can probably order PTF UY50707 from IBM by\nits number.  The tool we shall use to generate JCLIN is the \"MAP\"\nsubcommand of the \"PDS\" program product, with its \"RELINK\" keyword.\nThe tool to generate object decks for the individual modules of IEBCOPY\nis the DELINK0 program, originally from IBM, which is public, and also\non the CBT MVS Tape.\n\n      The CBT Tape itself can be ordered either from NaSPA (414)\n423-2420, or from SPLA at the University of Miami in Florida,\n(305) 284-6257.  The PDS product is on File 182 of the CBT Tape,\nand DELINK0 may be found on File 316.  PDS/E Sysprog Utilities\n(if you have it) has its own delinker and it contains all the\nfunctions we will need.\n\n\nPutting the Pieces Together\n\n      Our aim is to make a PTF that is patterned after IBM's UY50707,\nbut which re-installs our own release of IEBCOPY exactly.  When our\nPTF is APPLYed and ACCEPTed on our SMP system, all of the IEBCOPY\nCSECTs will be renewed on the DISTLIB, and the load module IEBCOPY on\nLINKLIB will be completely replaced and cleaned up.\n\n      See Figure 1 for our starting point, and Figure 2 for our\napproximate ending point.  The following paragraphs will describe some\nof the intervening details.\n\n      We will follow Figure 1's description of the various segments\ncomprising PTF UY50707.  Some of UY50707's parts are essential to our\nwork.  Other parts are unnecessary for us to be concerned about.\nLet's start.\n\n      Every PTF needs a \"++PTF\" and a \"++VER\" statement.  It is\nsufficient to pattern these from an existing IBM PTF.  The PRE and SUP\nstatements are crucial.  You should be scrupulous not to SUP any IBM\nsysmods in your user-written sysmod.  Keep the PRE's to an absolute\nminimum, too.  You may write your documentation in comments, the way\nIBM does.  IBM usually uses the ++VER statement as a place to insert\nits descriptions.\n\n      You may wish to write a ++HOLD statement for later reference\nby your installation.  However, you'll have to BYPASS it during the\nAPPLY.  Probably enough adequate documentation can be put into\nnormal comments.  Make your own decision on a ++HOLD statement.\n\n      I'd shy away from including the ++DELETE for the LMOD of\nIEBCOPY. As long as you're replacing all of the CSECTS and you're\nsupplying complete new JCLIN, the entire load module will probably be\nreplaced anyway.  In UY50707, IBM was radically changing the structure\nof the IEBCOPY load module, and they wanted to be sure that the\nunnecessary pieces from the old version were blown away.\n\n      Inline JCLIN must be carefully done.  The MAP-RELINK output\ngenerated by the \"PDS\" command is a good and accurate starting point.\nJust make sure that your JCLIN is similar in format to the JCLIN in\nUY50707.  There is one difference to be noted.  SMP recognizes the\n\"SYSGEN-type\" linkage editing procedure called \"LINKS\", which is\nsupplied by IBM for IOGEN or SYSGEN purposes.  A perfectly good\nalternative to using the \"LINKS\" procedure in JCLIN is to put an EXEC\ncard for the program \"IEWL\" directly in the JCLIN.  Look at Figure 2\nagain, to see how we did it.\n\n      We are not changing the form of our IEBCOPY load module, so the\nSYSGEN macros relating to IEBCOPY linkedit JCL generation need not be\nmodified.  We are also not deleting any of the individual MOD entries\nfor CSECTs within IEBCOPY, so the second set of ++DELETE statements in\nUY50707 (referring to the MOD entries) are not relevant to us, unless\nwe want to get rid of an extra \"frontend\" CSECT.  In that case, we\nshould code a ++DELETE card to get rid of the frontend's MOD entry.\n\n      The final part of the PTF consists of ++MOD SMP statements, each\nfollowed by an object deck.  If your SMP records aren't badly messed\nup, you may inquire on the RMIDs (i.e. PTF levels) of all your MOD\nentries belonging to IEBCOPY CSECTs.  If the old PTFs are still around,\nyou can possibly obtain non-base-level object decks by lifting them\nfrom the original PTFs.  For CSECTs at base level, or in all other\ncases, the object decks will have to be obtained by the process of\n\"delinking\".\n\n      See Figure 3 for JCL to run the DELINK0 program.  DELINK0 only\nproduces a CSECT at a time, so the process will have to be repeated\nfor all CSECTs in IEBCOPY for which you don't have an object deck.\nOne thing needs to be noted here.  DELINK0 in its current form\nproduces object decks with ESD's that are AMODE 24 and RMODE 24 only.\nThis \"mode\" problem (for the public domain delinker) is being worked\non.  PDS/E has its own delinker which does not have this problem.  But\nPDS/E can do our entire process \"automagically\" anyway, using its\n\"SMPGEN\" subcommand with the appropriate keywords.  We'll briefly\nmention this \"PDS/E\" feature at the end.\n\n      After the ++MOD cards pointing to DISTLIB(AOSU0) have been\ncreated, and the appropriate object decks have been placed carefully\nbelow each of these, the PTF has been constructed.  It must be slowly\nand scrupulously checked over.  If you are only overlaying existing\nSMP MOD entries, and are not deleting any MODs, an APPLY run with REDO\nshould write over any mistakes you make on the first try.\n\n      Because of the \"REDO\" keyword, your APPLY can be done over and\nover again.  You should not need to try a RESTORE.  But remember to\nalways be very careful.\n\n      Always do an APPLY CHECK before a real APPLY of your own PTF. An\nAPPLY CHECK will often uncover silly sysmod construction mistakes.\nAfter the APPLY of your PTF, look at the resulting IEBCOPY load module\nwith AMBLIST or with the \"PDS\" MAP subcommand, and compare its CSECT\nstructure to that of the original \"good\" IEBCOPY load module.  They\nshould be exactly the same.  If you have a byte-by-byte or\nCSECT-by-CSECT comparison utility, now is the time to use it.\n\n      Try to test the new load module any other way you can.\n\n      For shops that have the vendor product, PDS/E Sysprog Utilities,\nmuch of the above process is automated by its subcommand:\n\n  SMPGEN IEBCOPY MOD DISTLIB(AOSU0) SYSLMOD(LINKLIB) INLINE CSECT\n\n\nConclusion\n\n      SMP \"disasters\" do not have to result in laborious restores\nfrom backups.  If the problem is localized, such as being restricted\nto one load module, it may be easier to fix by making a complete\nreplacement for the load module.  It helps to know how to construct\nyour own PTF, to accurately do the replacement.\n\n      Minimal software resources are required for this procedure.\nThat's because we're using available tools to find out \"about the\nsoftware, from the software itself\".\n\n      Good luck in these endeavors, and in all your other ones.  See\nyou next month.\n\n\n\n\n\nFigure 1:     This shows the structure of PTF UY50707 which re-ships\n              the entire IEBCOPY load module.  This PTF adds function\n              to IEBCOPY so that it will copy the new PDSE libraries.\n              Our reason for using this PTF is to illustrate how\n              IBM will package a complete reshipment of an existing\n              load module.  We wish to distill the elements of IBM's\n              packaging, so that we can re-install our own IEBCOPY\n              load module with SMP at our own currently installed level.\n\n              Parts of the PTF are:\n               (1)  The ++PTF and ++VER statements with the PTF\n                    documentation.\n               (2)  ++HOLD statement and ++DELETE statement for the\n                    IEBCOPY LMOD entry (unnecessary for our purposes).\n               (3)  ++JCLIN  (crucial for us).\n               (4)  ++DELETE statements for MODs being eliminated in\n                    the rewrite (unnecessary for us unless we're\n                    deleting the MOD entry for a frontend module).\n               (5)  ++MAC statement to revise the SYSGEN macro for\n                    IEBCOPY (unnecessary if you don't change the\n                    linkedit structure of IEBCOPY).\n               (6)  ++MOD statements for each CSECT in IEBCOPY\n                    followed by the object deck for each CSECT\n                    (crucial to replace the working software properly).\n\n\n++ PTF (UY50707)        /*    5665-28445-HDP3320-\n//UY50707  JOB 5665-50707-0,28445,MSGLEVEL=(1,1),CLASS=A      */   .\n++ VER (Z038)\n   FMID(HDP3320)\n   PRE  (UY44382)\n   SUP  (UY43696,AY27240,AY27237,AY24733)\n /*\n     ( DOCUMENTATION FOR THE PTF IS INSERTED HERE. )\n */.\n++ HOLD(UY50707) SYS FMID(HDP3320) REASON(DELETE) DATE(90146)\n   COMMENT\n    (THIS PTF CONTAINS A ++DELETE MCS FOR THE FOLLOWING LMOD: IEBCOPY\n     SMP/E WILL NOT RESTORE THIS PTF.).\n++DELETE IEBCOPY\n  SYSLIB(LINKLIB).\n++ JCLIN .\n//SYSGEN0 JOB 1,'SYSTEM GENERATION',\n//      MSGLEVEL=1,MSGCLASS=A,\n//      CLASS=A\n//SG22 EXEC LINKS,\n// PARM='NCAL,LIST,XREF',\n//    UNIT='3380',SER=SYSRES,N=SYSX,NAME=LINKLIB,P1=' ',\n//    MOD=,P2=' ',OBJ=MACLIB,CLASS=A\n//AOSU0 DD DISP=SHR,VOLUME=(,RETAIN),DSNAME=SYS1.AOSU0\n//SYSLIN DD *\n INCLUDE AOSU0(IEBCFAMS)\n INCLUDE AOSU0(IEBCMSG)\n INCLUDE AOSU0(IEBCNVT)\n INCLUDE AOSU0(IEBCOMCA)\n INCLUDE AOSU0(IEBCPMOD)\n INCLUDE AOSU0(IEBCRDC)\n INCLUDE AOSU0(IEBDRB)\n INCLUDE AOSU0(IEBDRD)\n INCLUDE AOSU0(IEBDSCPY)\n INCLUDE AOSU0(IEBDSU)\n INCLUDE AOSU0(IEBDV0)\n INCLUDE AOSU0(IEBDWR)\n INCLUDE AOSU0(IEBIOE)\n INCLUDE AOSU0(IEBMCM)\n INCLUDE AOSU0(IEBPRINT)\n INCLUDE AOSU0(IEBRSAM)\n INCLUDE AOSU0(IEBSCM)\n INCLUDE AOSU0(IEBVCT)\n INCLUDE AOSU0(IEBVDM)\n INCLUDE AOSU0(IEBVTM)\n INCLUDE AOSU0(IEBVTT)\n INCLUDE AOSU0(IEBWSAM)\n INCLUDE AOSU0(IEBWSU)\n ORDER   IEBCOMCA(P),IEBCOMCB(P)\n SETCODE AC(1)\n MODE    AMODE(24),RMODE(24)\n ENTRY   IEBDSCPY\n NAME    IEBCOPY(R)\n/*\n++ MOD(IEBDV1) DISTLIB(AOSU0  ) DELETE .\n++ MOD(IEBBAM) DISTLIB(AOSU0  ) DELETE .\n++ MOD(IEBLDUL) DISTLIB(AOSU0  ) DELETE .\n++ MOD(IEBVMS) DISTLIB(AOSU0  ) DELETE .\n++ MAC      (SGIEH402) DISTLIB(AGENLIB ).\n     (CONTENTS OF MACRO FOR SYSGEN SUPPORT OF IEBCOPY.)\n++ MOD(IEBCFAMS) DISTLIB(AOSU0) .\n - - -  Object deck for module IEBCFAMS   - - -\n++ MOD(IEBCMSG ) DISTLIB(AOSU0) .\n - - -  Object deck for module IEBCMSG    - - -\n++ MOD(IEBCNVT ) DISTLIB(AOSU0) .\n - - -  Object deck for module IEBCNVT    - - -\n++ MOD(IEBCOMCA) DISTLIB(AOSU0) .\n - - -  Object deck for module IEBCOMCA   - - -\n++ MOD STATEMENTS FOR EACH OF THE CSECTS, FOLLOWED BY OBJECT DECKS\n - - -  Data abbreviated for brevity      - - -\n\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFIGURE 2:      Our PTF to reinstall IEBCOPY at the DFP Release 2.4\n               level.  The \"++PTF\" and \"++VER\" part has been patterned\n               after an IBM PTF.  The JCLIN can be generated by the\n               \"PDS\" subcommand, \"MAP IEBCOPY RELINK\", and edited a\n               bit to add the ddname for the distribution library,\n               AOSU0.  The \"PDS\" subcommand, \"MAP IEBCOPY\" will supply\n               the names of the CSECTs in IEBCOPY to delink.  The\n               DELINK0 program can be used to create object decks\n               for these CSECTs to be placed below the \"++MOD\" cards.\n               If you are licensed for the PDS/E product which has its\n               own \"delink\" capability, all of the data from the ++JCLIN\n               and below, can be created with the one PDS/E subcommand:\n               \"SMPGEN  IEBCOPY  MOD  DISTLIB(AOSU0)  SYSLMOD(LINKLIB)\n               INLINE  CSECT\".  The only input for the entire procedure\n               is the good load module, SYS1.LINKLIB(IEBCOPY).\n\n\n\n++ PTF (UY24CPY)        /*    5665-28445-HDP2240-DP9\n//UY24CPY  JOB 5665-44388-0,28445,MSGLEVEL=(1,1),CLASS=A     */  .\n++ VER (Z038)\n   FMID(HDP2240)      /*\n       (You can write your own PTF documentation here. )\n */.\n++JCLIN  .\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//AOSU0    DD  DISP=SHR,DSN=SYS1.AOSU0\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.LINKLIB\n//SYSLIN   DD  *\n INCLUDE AOSU0(IEBDSMCA)\n INCLUDE AOSU0(IEBDSCPY)\n INCLUDE AOSU0(IEBVTM)\n - - -  INCLUDE statements for the other IEBCOPY CSECTs  - - -\n ORDER IEBDSMCA(P)\n ORDER IEBDSCPY\n ORDER IEBVTM\n - - -  ORDER statements for the other IEBCOPY CSECTs  - - -\n SETSSI  01113798\n SETCODE AC(1)\n ENTRY   IEBDSCPY\n NAME    IEBCOPY(R)\n++MOD(IEBDSMCA) DISTLIB(AOSU0)  .\n - - -  Object deck for module IEBDSMCA   - - -\n++MOD(IEBDSCPY) DISTLIB(AOSU0)  .\n - - -  Object deck for module IEBDSCPY   - - -\n++MOD(IEBVTM  ) DISTLIB(AOSU0)  .\n - - -  Object deck for module IEBVTM     - - -\n++MOD statements for the other IEBCOPY CSECTs  . . . . .\n - - -  Each ++MOD is followed by an object deck.  - - -\n\n\n\n\n\nFIGURE 3:      JCL to execute the DELINK0 program.  DELINK0 starts\n               with a load module and creates an object deck for one\n               CSECT at a time.  The process is the reverse of linkage\n               editing.  Source code for DELINK0 in assembler language\n               may be found on File 316 of the CBT MVS Tape.  The JCL\n               below will \"delink\" one CSECT from load module IEBCOPY.\n               For our purposes, the process has to be repeated for\n               all of the CSECTs in IEBCOPY.  You can use the AMBLIST\n               service aid distributed by IBM, or the \"PDS\" package's\n               \"MAP\" subcommand, to determine the names of all the\n               CSECTs in a load module.\n\n\n\n//TSTXDLNK JOB ,'TECH.SUPP-SAM.GOLOB',CLASS=M,NOTIFY=TSTBSSG,\n//        MSGLEVEL=(1,1),MSGCLASS=T TYPRUN=HOLD\n//*\n//DELINK  EXEC PGM=DELINK0,REGION=2000K\n//STEPLIB  DD DISP=SHR,DSN=TST.TSO.CMDLIB\n//SYSPRINT DD SYSOUT=*\n//SYSLIB DD DISP=SHR,DSN=SYS1.LINKLIB                 <=== load library\n//SYSPUNCH DD DISP=(NEW,PASS),DSN=&&TEMP,UNIT=SYSDA,\n//       DCB=(RECFM=F,LRECL=80,BUFNO=255),SPACE=(TRK,(5,20))\n//SYSIN   DD *\n IEBCOPY IEBVMTXT\n//*\n//GENER   EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD DUMMY\n//SYSUT1   DD DSN=&&TEMP,DISP=(OLD,PASS)\n//SYSUT2   DD DISP=SHR,DSN=TST.DELINK.PUNCH(IEBVMTXT)  <== object deck\n\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9109SE": {"ttr": 9221, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x93!\\x0f\\x01\\x00)\\x9f\\x11G\\x01\\x81\\x01\\x81\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 385, "newlines": 385, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         September 1991\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\n\nEXPLOITING PARTITIONED DATASET DIRECTORY FIELDS - PART I.\n\n      This month, I'd like to talk about utilizing information\ncontained in partitioned dataset directory entries.  The fields and\nbits in the directory, especially in the directory entries of a load\nmodule library, contain crucial information that is used by the MVS\noperating system.\n\n      Knowing about these fields can help you in some startling ways.\nIt may not have occurred to you to look in such a place for help in\nproblem situations.  That's why I thought it appropriate to mention\nthe subject here in the \"tools and tricks\" column, rather than in a\nseparate tutorial article.  We shall try to point out some cases where\ninformation from directory entry fields will make a great impact on\nour effective work as systems programmers.\n\n      As is well known, \"source-type\" partitioned datasets have very\ndifferent directory entries than do \"load libraries\" which contain\nexecutable load modules as their members.  We therefore shall discuss\nthese different types of partitioned datasets separately,\nconcentrating in areas where the most \"gain by manipulation\" is to be\nhad.  We shall discuss \"source-type\" pds members that have \"ISPF\nstatistics\" in their directory entries as opposed to members that\ndon't have stats.  This subject will be continued next month.\n\n\nFUNDAMENTALS - THE STRUCTURE OF PARTITIONED DATASET DIRECTORIES.\n\n      The partitioned dataset directory is located at the beginning\nof the first disk extent for a partitioned dataset.  Although the DCB\nattributes of the DATA in a partitioned dataset will vary, the external\nphysical structure of the DIRECTORY does not vary.\n\n      The directory of a pds consists of \"directory blocks\" and\n\"directory entries\".  The directory blocks of a pds may be\nconceptualized as the \"physical\" part of the pds directory.  Considered\nas raw data, each directory block is of fixed length, and is 255 bytes\nlong with a 9-byte key--264 bytes in all.  The size of a directory\nblock is fixed by the architecture of partitioned datasets, and is not\nsubject to user software control, for all practical purposes.\n\n      Each directory block contains a number of directory entries of\nvariable length.  The directory entries, in contrast to the directory\nblocks, may be pictured conceptually as the \"logical\" part of the\ndirectory data.  We say \"logical\", because the contents of the\ndirectory entries is variable, and is subject to much more software\ncontrol.  Our discussion will be concerned with directory entries,\nwhich contain information that is useful for our needs as programmers.\n\n      There is exactly one directory entry for each member of a\npds.  Each directory entry defines an area of data in the physical\npds data extents, as belonging to one member.  A pointer field in the\npds directory entry points to the start of each member, while an EOF\n(end-of-file) marker in the data itself, defines the end of that\nmember.\n\n      Some fields of each directory entry are required by pds design.\nThese fields constitute the first 12 bytes of any directory entry.  An\nexample of a required field is the TTR pointer in the directory entry\nwhich points to the start of that member's data.  The 'TTR' is the\n\"relative track and record number for a data record, starting from the\nbeginning of the dataset\".\n\n      Another required field is the 8-byte member name in the\ndirectory entry.  Every pds directory has to contain a member name and\na TTR pointer to the beginning of that member's data.  The last\nrequired field in a directory entry is a flag byte.  Descriptions of\nthe required flag byte will be found in the Figures.  The required\nfields may, or may not, be followed by user-defined directory entry\nfields of variable length, to a maximum of 62 bytes.\n\n      User fields, while not required by general pds structure, are\ncreated by an MVS component which uses the pds structure as a base for\nits own requirements.  The most notable example of MVS component\nuse of user fields, is the load library, whose \"data\" consists of\nexecutable programs, or \"load modules\".\n\n      PDS directory entries for load library members contain far more\n'required' user fields than do most other pds directory entries.  The\nMVS component called \"program fetch\" utilizes those extra load library\ndirectory entry fields to affect program execution of the load module.\n\n      In this article we will learn how to take advantage of the\naccessibility of these directory entry fields to us.  We may be able\nto fix load modules, for example, without having to re-linkedit them.\nMerely flipping one or more directory entry bits could accomplish the\nfix that we need.\n\n\nSOME QUICK EXAMPLES.\n\n      Let's whet your appetite by showing a few examples.  Load module\nlinkedit attributes are all reflected in the directory entry user\nfields.  If you were linkediting a module, and you forgot to mention\n'RENT' in the linkedit parms, you need only go to the 'reentrancy' and\n'reusability' bits of the module's directory entry and turn those bits\non.  That will have the same effect as if the linkage editor turned\nthem on when it was creating the member.  Similarly, if a module had\nto be authorized, and you forgot to say \"SETCODE AC(1)\" in the linkage\neditor control statements, you need only go to the directory entry of\nthe module and turn the proper \"auth\" bit on.  In all of these cases,\nyou do not have to re-linkedit the module.  Similar considerations\napply if those attributes needed to be turned off.  Knowing these\nfacts can save you a lot of work.\n\n\nHOW TO START LEARNING ABOUT DIRECTORY ENTRY FIELDS.\n\n      The macro IHAPDS (in SYS1.AMODGEN) describes many (but not all)\ntypes of pds directory entry fields.  You can find a description of\nmany directory entry fields in the IBM manual, \"SPL Debugging\nHandbook\" under entries:  \"PDS\" and \"PDS2\".  In MVS/ESA, the\nequivalent manuals are:  \"MVS/ESA Diagnosis: Data Areas\".  Because in\nmany cases, directory entry fields are user-defined or\napplication-defined, a single IBM descriptive macro cannot cover all\nthe ground.  In particular, ISPF directory entry field descriptions\nare not too readily available (see Figure Three).\n\n      I am providing some descriptions of directory entry fields here.\n(See Figures One thru Three).  These descriptions were taken from the\nsource member @DIALOG of the PDS product Version 8.4, on the CBT MVS\nUtilities Tape, File 182.  It is hoped that these descriptions will be\nsufficient to help the reader learn this material.\n\n      Let's begin by learning about the required directory entry\nfields.  These comprise 12 bytes.  In other words, a single directory\nentry has to be at least 12 bytes long.  The first eight bytes of a\ndirectory entry consist of the member name, left justified.  It is\nnecessary that all directory entries be sorted ascendingly in member\nname order.  Therefore, some directory entries need to be rearranged\neach time a new member is added.  This is an overhead-consuming\nprocess.  The next 3-byte field is a relative TTR pointer to the\nbeginning of that member's data.  Finally, there is a 1-byte field,\n\"officially\" consisting of binary flags.  This flag byte is crucial to\nthe rest of the directory entry, so we shall study this byte in more\ndetail.\n\n      Look at Figure Two.  The high-order bit, X'10000000' of the flag\nbyte, is turned on to mark the member as an alias member.  Strictly\nspeaking, although the purpose of an alias member is to provide an\nalternate name for a main member, any pds member can theoretically be\nflagged as an \"alias\" if this bit is on.  For load modules, the alias\nbit on will be accompanied by a user field (the \"real member name\"\nfield) containing the name of a \"main member\", filled in by the\nlinkage editor at the time of alias creation.\n\n      The next two bits, X'01100000', are relevant to load module\ndirectory entries.  All load modules contain one extra TTR location,\nwhich is the TTR of the first TEXT record, needed by MVS program\nfetch.  For certain load modules such as OVERLAY modules and SCATTER\nLOADED modules, extra control records must be available to ensure their\nproper functioning.  Notelist tables (for OVERLAY) and scatter tables\n(for SCATTER) may be imbedded amongst the load module text data.  In\norder to be found, these tables need an extra TTR pointer in user\nfields of the module's directory entry.  The second bit of the flag\nbyte, turned on, denotes that two extra TTR pointers need to be\nconstantly updated for the load module member.  The third bit on,\ndenotes that only one extra TTR pointer needs to be continually kept\ntrack of for that member.\n\n      The last five bits in the flag byte denote a binary quantity\nthat varies from 0 thru 31.  That denotes the number of halfwords of\nuser data which will be appended to the required 12 bytes of the\ndirectory entry.  This is clear enough.  As many as 62 bytes of user\ndata may be added to the minimum 12 bytes.\n\n\nISPF STATISTICS IN A SOURCE-TYPE MEMBER.\n\n      A pds member that was edited by the ISPF editor, receives\n\"ISPF statistics\" in its directory entry when the member is saved.\nThe statistics consist of 28 extra bytes of user data appended to\nthe first 12 bytes.  When ISPF statistics are present, required flag\nbits X'00001111' might be turned on; also bits X'01110000' should be\nturned off.  This should be a fairly accurate test for the presence\nof ISPF statistics.  (Hint is courtesy of Steve Smith).\n\n      These statistics (or most of them) are displayed during an\nISPF member listing for non-load type members, and are familiar to\nmany of us.  A DSECT-type description of the \"ISPF\" user directory\nfields is at the bottom of Figure Three.  During study of Figure\nThree, it will become apparent how to change any of the statistics in\nthe directory.   We must somehow be able to display them in their\nnative format, and then zap the changes in.   ISPF Option 3.5, which\nchanges the contents of some of these directory fields, actually does\nthis zapping for us.\n\n      Source-type pds members that don't have ISPF stats, usually\nhave just 12-byte directory entries, with the lower five bits of the\nrequired flag byte set to zeros.  It is apparent that the process of\nadding ISPF statistics to a member that didn't have them, is not\ntrivial.  A re-creation of the directory entry, possibly through the\nuse of the STOW macro, becomes necessary.  Directory space consumed,\nfor the same number of members, will have to increase noticeably.\n\n      We've come to the end of our time for this month.  Next month,\nI'll go into more detail about the STOW macro, ISPF statistics\nalteration, and load module directory user fields.  Good luck.\n\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n\nFIGURE ONE.   DSECT Descriptions of Partitioned Dataset Directory\n              Entries.  The required portion of the directory entry\n              (first 12 bytes) is shown here.\n\n              This description was mostly taken from source code\n              for the \"PDS Program Product, Version 8.4\", which\n              can be found on File 182 of the CBT MVS Utilities\n              Tape, member @DIALOG.  You can refer to the macro\n              IHAPDS in SYS1.AMODGEN for \"IBM Official\" field\n              names.\n\n\n\nDIRLINK  DS    0F            ***   DIRECTORY AREA MAPPING   ***\n*\nDIRNAME  DS    CL8           Member Name\nDIRTTR   DS    XL3           TTR of beginning of the Member\nDIRFLAG  DS    X             Contains 3 flags in high-order bits.\n*                            Low-order 5 bits contain number of\n*                            halfwords in user-defined fields to\n*                            follow this point (62 bytes maximum).\n*\nDIRALIAS EQU   X'80'         This member is an alias.\nDIR2TTR  EQU   X'40'         Two TTR's to update\nDIR1TTR  EQU   X'20'         One TTR to update\n*\nDIRUSER  DS    XL62          Maximum length of directory entry\n*                            user fields.  Actual length depends on\n*                            the number of halfwords indicated by\n*                            the 5 low-order bits of DIRFLAG\n*                            (the 12th byte of the directory entry).\n\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n\nFIGURE TWO.   A DSECT Description of Partitioned Dataset Directory\n              Entries for Load Modules.  Load modules use the User\n              Fields of the directory entry in a special way, that\n              is defined by the Linkage Editor and the MVS Program\n              Fetch component.  Labels in this illustration are from\n              source code in the PDS V8.4 product, module @DIALOG.\n              This source code is on the CBT Tape, File 182.  For\n              more standard names, see macro IHAPDS on SYS1.AMODGEN.\n\n\n\nDIRLINK  DS    0F            ***   DIRECTORY AREA MAPPING   ***\n*\nDIRNAME  DS    CL8           Member Name\nDIRTTR   DS    XL3           TTR of beginning of the Member\nDIRFLAG  DS    X             Flags for required direntry fields.\n*\nDIRCALIS EQU   B'10000000'   This member is an alias.\nDIRCTTRN EQU   B'01100000'   There is more than 1 TTR to update\nDIRCUDHW EQU   B'00011111'   Halfword count bits. Size of user bytes.\n*\nDIRUSER  DS    XL62          Directory USER Fields\n*\n         ORG   DIRUSER    FOLLOWING FOR LOAD MODULES\nDIRSTART DS    XL4           TTR of first Text block\nDIRNOTE  DS    XL3           TTR of Notelist\nDIRNOTE# DS    X             Number of Notelist entries\nDIRATTR  DS    XL2           Member Attributes\n*                         EQUATES for First Byte\n         ORG   DIRATTR\nDIRAT1ST DS    X\nDIRRENT  EQU   B'10000000'      Reentrant\nDIRREUS  EQU   B'01000000'      Reusable\nDIROVLY  EQU   B'00100000'      Overlay Module\nDIRTEST  EQU   B'00010000'      Test\nDIRLOAD  EQU   B'00001000'      Only Loadable\nDIRSCTR  EQU   B'00000100'      Scatter Load\nDIREXEC  EQU   B'00000010'      Executable\nDIRF1    EQU   B'00000001'\n*                         EQUATES for Second Byte\n         ORG   DIRATTR+1\nDIRAT2ND DS    X\nDIRNODC  EQU   B'10000000'      Not DC (Downward Compatible)\nDIRF2    EQU   B'01000000'\nDIRF3    EQU   B'00100000'\nDIRF4    EQU   B'00010000'\nDIRNOED  EQU   B'00001000'      Not Editable\nDIRF5    EQU   B'00000100'\nDIRLKEDF EQU   B'00000010'      F Level Linkage Editor\nDIRREFR  EQU   B'00000001'      Refreshable\n*\nDIRSTORE DS    XL3           Size of Load Module\nDIRTEXTL DS    XL2           Length of 1st Text Record\nDIREPA   DS    XL3           Entry Point Address\n*\nDIRATTR2 DS    X           ADDITIONAL ATTRIBUTE BYTES:\nDIRAOSLE EQU   B'10000000'   VS Linkage Editor created this module\nDIR2PAGA EQU   B'00100000'   Page Alignment is required\nDIR2SSI  EQU   B'00010000'   SSI Information present for module\nDIRAPFLG EQU   B'00001000'   APF Information for this module is valid\n*\nDIRATTR3 DS    X           ADDITIONAL ATTRIBUTE BYTES:\nDIRRMANY EQU   B'00010000'   RMODE=ANY\nDIRAA31  EQU   B'00001000'   AMODE=31  (Alias entry)\nDIRAA24  EQU   B'00000100'   AMODE=24  (Alias entry)\nDIRAM31  EQU   B'00000010'   AMODE=31  (Main entry)\nDIRAM24  EQU   B'00000001'   AMODE=24  (Main entry)\n*\nDIRATTR4 DS    X             Count of RLD Entries after first Text\n*\nDIRAPF   DS    0XL2          APF (If not SCATTER, SSI or ALIAS)\nDIREP    DS    XL3           Entry Point of Main Member\nDIRREAL  DS    CL8           Real Name of Member\nDIRAPF2  DS    XL2           APF Information (ALIAS, no SCAT or SSI)\nDIREND2  EQU   *             End of ALIAS Section\n*\n         ORG   DIRAPF     FOLLOWING IS FOR SCATTER LOADED MODULES.\nDIRSCLL  DS    XL2           Length of Scatter List\nDIRSCTL  DS    XL2           Length of Translate Table\nDIRSCET  DS    XL2           ESDID of First Text Record\nDIRSCEP  DS    XL2           ESDID of Entry Point\nDIRAPF3  DS    0XL2          APF Info (If SCATTER, no SSI and no ALIAS)\nDIREPSC  DS    XL3           Entry Point (Main Membewr)\nDIRREALS DS    CL8           Real Name of Member\nDIRAPF4  DS    XL2           APF Info (SCATTER, no SSI and ALIAS)\nDIREND3  EQU   *             End of SCATTER, ALIAS Section\n\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n\nFIGURE THREE.   DSECT Description of Partitioned Dataset Directory\n                Entries for Source-type members which have \"ISPF\n                Statistics\".  ISPF Statistics are merely a special\n                use of partitioned dataset directory user fields.\n\n\n\n\nDIRLINK  DS    0F            ***   DIRECTORY AREA MAPPING   ***\n*\nDIRNAME  DS    CL8           Member Name\nDIRTTR   DS    XL3           TTR of beginning of the Member\nDIRFLAG  DS    X             Contains 3 flags in high-order bits.\n*                            Low-order 5 bits contain number of\n*                            halfwords in user-defined fields to\n*                            follow this point (62 bytes maximum).\n*\nDIRALIAS EQU   X'80'         This member is an alias.\nDIR2TTR  EQU   X'40'         Two TTR's to update\nDIR1TTR  EQU   X'20'         One TTR to update\nDIRSPFOF EQU   B'01110000'   BITS ARE OFF IN ISPF STATS.\nDIRSPFON EQU   B'00001111'   BITS ARE ON IN ISPF STATS.\n*\nDIRUSER  DS    XL62          Directory Entry User Fields. 62 bytes max.\n                             (28 Bytes are used by ISPF Stats)\n*\n         ORG   DIRUSER    FOLLOWING FOR MODULES SAVED BY ISPF EDIT.\nDIRSPFV  DS    XL1           Version Number in Binary\nDIRSPFR  DS    XL1           Revision Number in Binary\nDIRSPFZ  DS    XL2           Not currently used\nDIRSPFCR DS    XL4           Creation Date in format 00YYDDDF\nDIRSPFCD DS    XL4           Last Change Date in format 00YYDDDF\nDIRSPFCT DS    XL2           Last Change Time in format HHMM\nDIRSPFSI DS    XL2           Current Size in Binary (max 65535)\nDIRSPFIN DS    XL2           Initial Size in Binary\nDIRSPFMD DS    XL2           Modified Lines in Binary\nDIRSPFID DS    CL8           ID of Last Person to Update\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9110OC": {"ttr": 9228, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x93!\\x0f\\x01\\x00)\\x9f\\x11G\\x01_\\x01_\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 351, "newlines": 351, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          October 1991\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\n\nEXPLOITING PARTITIONED DATASET DIRECTORY FIELDS:  PART II.\n\n\nSUMMARY OF PART I.\n\n      This month, we shall continue on the subject of exploiting\nvarious fields in the partitioned dataset directories.  Last month we\ndiscussed the structure of directory entries, and how each entry is\nvariable in length, containing 12 bytes of required fields, and up to\n62 bytes of user fields.  To refresh your memory, see the DSECT\ndescription in Figure One.\n\n      Load library directories are a specialized example of \"official\nIBM use\" of the \"user fields\" in the pds directory entry.  Directory\nentry fields that are critical in the execution of load modules, are\nreally \"optional user fields\" in the native pds architecture.  IBM\nhas merely adapted the directory architecture to support necessary\nfunctions in the linkage editing and program fetch components of MVS.\n\n      ISPF statistics are another example of IBM's utilization of\nthese \"user\" fields.  Under the ISPF editor, fixed blocked or variable\nblocked pds members have statistics stored in each member's directory\nentry user fields.  These stats help track things like creation and\nlast-update dates, member size, and the last userid to update the\nmember.  See Figure Two for a DSECT description of \"ISPF stats\".\n\n      Other IBM and vendor program products also make specialized\nusage of \"optional\" pds directory entry fields.  SMP/E and IMS are\nIBM products which will utilize pds directory entry user fields for\nspecial purposes.\n\n      Our aim here, is to try and notice points where a change in a\ndirectory entry field performs a useful or a critical function.  For\nexample, rather than re-linkediting a load module, flipping the proper\ndirectory entry bit(s) may accomplish the same purpose in less time.\nKnowing about such facts can save us much grief, and can help us in\nmany other ways during our daily work.\n\n\nTHE \"STOW\" MACRO.\n\n      The principal data management macro dealing with pds directory\nentries is the STOW macro.  \"STOW\" is usually involved when you want\nto add a pds member, delete a member, rename a member, or replace an\nexisting member with a another one of the same name.\n\n      It isn't too hard to use STOW in a program.  I've included a\ncoding example here (see Figure Three).  However, the purpose of\nmentioning the STOW macro here, is not to teach you how to code it.\nRather, my aim is to provide some insight into how a pds directory\nentry is created or changed.  With that knowledge behind us, it'll be\na lot easier to understand the directory entry manipulations that\nwe'll talk about later.\n\n      STOW needs three parts.  Its first operand points to the DCB\naddress of the partitioned dataset to be operated on.  The second\noperand is the address of a data area.  Finally the third operand is\none of four function codes:  \"A\" for adding a member, \"R\" for replacing\nan existing member, \"C\" for changing a member name (renaming), and \"D\"\nfor deleting a member.  In the case of adding (\"A\") or replacing\n(\"R\"), the data area will be an image of the directory entry itself.\nIn the case of member deletion (\"D\"), the data area contains an 8-byte\nmember name field.  Finally, in the case of renaming a member or\nchanging it (\"C\"), the data area is a 16-byte area containing the old\nname in the first 8 bytes, and the new name in the second 8 bytes.\n\n      Each different function of STOW (A, R, C, or D) has its own\nset of return codes.  These are explained in the Data Management Macro\nInstructions manual in detail.  However, the ADD function will return\na code of 0 if the member didn't previously exist and was successfully\nadded.  The ADD function will return a code of 4 if the name previously\nexisted in that directory.  The REPLACE function on the other hand,\nreturns a code of 0 if a member replace was done successfully, and it\nreturns a code of 8 if that member name was not previously there.  You\ncan see by looking at the coding example, that the results of the STOW\nmacro can be neatly handled using a branch table.\n\n      Our coding example involves either the ADD or REPLACE functions\nof STOW.  Therefore, our data area is an image of the actual directory\nentry in both of these cases.\n\n      Our example program does a CLIST format conversion, which is\nessentially a copy operation from an input dataset to an output\ndataset.  If ISPF statistics existed for an input dataset member, they\nare copied into the STOW data area for the output dataset member.\nHowever it is possible, because of line splits occurring during the\nreformatting process, that the output record count will increase by\nthe number of line splits.  Our example shows how we discover the\npresence of ISPF statistics in a member, and how we increase an\nexisting ISPF record count by the number of line splits, right before\nthe STOW is done.\n\n\nRELATING THE STOW MACRO TO ISPF STATS.\n\n      Most of us are familiar with the ISPF option 3.5, which can\nadd ISPF statistics to \"source-type\" pds members if there weren't any.\nOption 3.5 can also be used to change the USERID field in the ISPF\nstats, or the version and modification number fields.  It should now\nbe obvious that this is done using the STOW macro with the REPLACE\noption.  Record counts are taken by the appropriate ISPF service\nprogram.  These are fed into a formatted data area in the program\nbefore the STOW REPLACE is done.  The STOW re-creates the directory\nentry for the affected member, adding new ISPF stats in the user\nfields for the new entry, or changing pre-existing ones.\n\n      As an exercise, you can write an assembler program to manipulate\nsome ISPF stats (or any other directory entry format, for that\nmatter).  You'll first need a method of feeding parms or input control\ncards to your program.  Then, you can access any member of your target\ndataset using BPAM (see the CVTCLIST program on the CBT Tape File 187\nfor a relevant coding example).  You can then copy the directory\ninformation for each affected dataset member into a data area that's\nformatted for ISPF stats.  Finally, you can do your directory entry\nfield manipulations and do a STOW for the member, using the REPLACE\noption, and keeping the TTR the same.\n\n      Although there are easier ways to change ISPF stats, this method\nactually works, and it can be generalized greatly to deal with other\ntypes and formats of directory entry user fields.\n\n\nWHAT'S LEFT?\n\n      Next month, we'll continue with the large subject of load module\ndirectory entries, an \"official IBM use\" of pds directory entry user\nfields.  These \"user\" fields contain essential load module information\nthat can be useful to manipulate.  Meanwhile, I hope that our current\nmaterial is enough to chew on for now.  Good luck.  See you next\nmonth.\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE ONE:    DSECT Descriptions of Partitioned Data Set Directory\n               Entries.  The required portion of the directory entry\n               (first 12 bytes) is shown here. This description was\n               mostly taken from source code for the PDS Program\n               Product, Version 8.4, which can be found on File 182 of\n               the CBT MVS Utilities Tape, member @DIALOG.  You can\n               refer to the macro IHAPDS in SYS1.AMODGEN for IBM\n               official field names.\n\n\nDIRLINK  DS    0F            ***   DIRECTORY AREA MAPPING   ***\n*\nDIRNAME  DS    CL8           Member Name\nDIRTTR   DS    XL3           TTR of beginning of the Member\nDIRFLAG  DS    X             Contains 3 flags in high-order bits.\n*                            Low-order 5 bits contain number of\n*                            halfwords in user-defined fields to\n*                            follow this point (62 bytes maximum).\n*\nDIRALIAS EQU   X'80'         This member is an alias.\nDIR2TTR  EQU   X'40'         Two TTR's to update\nDIR1TTR  EQU   X'20'         One TTR to update\n*\nDIRUSER  DS    XL62          Maximum length of directory entry\n*                            user fields.  Actual length depends on\n*                            the number of halfwords indicated by\n*                            the 5 low-order bits of DIRFLAG\n*                            (the 12th byte of the directory entry).\n\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n\nFIGURE TWO:     DSECT Description of Partitioned Data Set Directory\n                Entries.  These are for source-type members that have\n                ISPF statistics. ISPF statistics are merely a special\n                use of partitioned data set directory user fields.\n\n\n\nDIRLINK  DS    0F            ***   DIRECTORY AREA MAPPING   ***\n*\nDIRNAME  DS    CL8           Member Name\nDIRTTR   DS    XL3           TTR of beginning of the Member\nDIRFLAG  DS    X             Contains 3 flags in high-order bits.\n*                            Low-order 5 bits contain number of\n*                            halfwords in user-defined fields to\n*                            follow this point (62 bytes maximum).\n*\nDIRALIAS EQU   X'80'         This member is an alias.\nDIR2TTR  EQU   X'40'         Two TTR's to update\nDIR1TTR  EQU   X'20'         One TTR to update\n*\nDIRSPFOF EQU   B'01110000'   BITS ARE OFF IN ISPF STATS.\nDIRSPFON EQU   B'00001111'   BITS ARE ON IN ISPF STATS.\n*\nDIRUSER  DS    XL62          Directory Entry User Fields. 62 bytes max.\n                             (28 Bytes are used by ISPF Stats)\n*\n         ORG   DIRUSER    FOLLOWING FOR MODULES SAVED BY ISPF EDIT.\nDIRSPFV  DS    XL1           Version Number in Binary\nDIRSPFR  DS    XL1           Revision Number in Binary\nDIRSPFZ  DS    XL2           Not currently used\nDIRSPFCR DS    XL4           Creation Date in format 00YYDDDF\nDIRSPFCD DS    XL4           Last Change Date in format 00YYDDDF\nDIRSPFCT DS    XL2           Last Change Time in format HHMM\nDIRSPFSI DS    XL2           Current Size in Binary (max 65535)\nDIRSPFIN DS    XL2           Initial Size in Binary\nDIRSPFMD DS    XL2           Modified Lines in Binary\nDIRSPFID DS    CL8           ID of Last Person to Update\n\n\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n\nFIGURE THREE.   Code (taken from CLIST Conversion program on File 187\n                of the CBT MVS Utilities Tape) which illustrates the\n                testing for ISPF statistics, and for alias members.\n\n                This code will increment the ISPF \"size\" statistics.\n                When a CLIST is converted from VB-255 byte format to\n                FB-80 byte format and line splits are performed, the\n                new CLIST in FB-80 byte format has a record count\n                equal to the old record count, plus the count of\n                \"line splits\" done.  The code below is used to\n                increase the record count from the old ISPF stats,\n                if they exist, by the count of line splits.\n\n                This code also illustrates STOW ADD and STOW REPLACE\n                with their varying return codes.  For more information\n                see the DFP Data Management Macro Instructions manual.\n\n\n\nBUMPSTTS DS    0H                 BUMP ISPF STATS IF WE SPLIT LINES.\n*\n         ST    R8,SAVE8REG             SAVE R8 FOR WORK\n         LA    R8,DIRLIST              LOAD R8 FOR MAPPING\n         USING DIRSECT,R8              MAP DIRECTORY WKAREA\n*\n*   DO WE HAVE SPF STATS LEGITIMATELY?  THEN BUMP LINE COUNT.\n*      (See Figure Two for the meanings of Field Labels.)\n*\n         TM    DIRFLAG,DIRSPFOF        CK FOR BITS THAT SHOULD BE OFF\n         BNZ   ALISTEST                THEY'RE NOT: NO SPF STATS\n         TM    DIRFLAG,DIRSPFON        CK FOR BITS THAT SHOULD BE ON\n         BNO   ALISTEST                THEY'RE NOT: NO SPF STATS\n         CLI   DIRSPFCR,0              00 OF 00YYDDDF ZEROS?\n         BNZ   ALISTEST                NO, BRANCH\n         CLI   DIRSPFCD,0              00 OF OTHER 00YYDDDF ZERO?\n         BNZ   ALISTEST                NO, BRANCH\n*\n*   ALL TESTS PASSED:  ASSUME WE HAVE SPF STATS\n         ST    R7,SAVE7REG             SAVE R7 FOR WORK\n         CP    MEMSPLTS,ALWZERO        WERE THERE ANY SPLITS?\n         BNH   BYPASADD                NO. DON'T INCREMENT STATS.\n*\n*   NUMBER OF SPLIT LINES MUST BE ADDED TO RECORD COUNT IN THE STATS\n         ZAP   PACKWORK,MEMSPLTS       GET COUNT OF LINE SPLITS READY\n         CVB   R7,PACKWORK             CONVERT NO OF SPLITS TO BINARY\n         AH    R7,DIRSPFSI             ADD ORIGINAL NO OF RECORDS\n         STH   R7,DIRSPFSI             STORE UPDATED COUNT IN DIRECTORY\nBYPASADD L     R7,SAVE7REG             RESTORE R7\n         DROP  R8\n*\n*           COUNT THE NUMBER OF ALIAS MEMBERS BEING CONVERTED\nALISTEST L     R8,SAVE8REG             RESTORE R8\n         NI    FLAGG,255-ALIASED       RESET ALIAS FLAG\n         TM    DIRLIST+11,X'80'        IS MEMBER AN ALIAS?\n         BNO   GOSTOW                  NO, DON'T COUNT IT\n         OI    FLAGG,ALIASED           FLAG AS ALIAS\n         NI    DIRLIST+11,X'7F'        TURN OFF ALIAS BEFORE STOW\nGOSTOW   DS    0H\n         TM    FLAGG,STOWADD    THIS A NOREPLACE RUN? (set by a parm)\n         BO    STOWAD                  YES -- STOW ADD ONLY\n         B     STOWREP                 NO  -- STOW REPLACE\n         EJECT\n*  - - - - - - -   ILLUSTRATIONS OF THE \"STOW\" MACRO. - - - - - - -  *\n*\nSTOWREP  STOW  CLISTOUT,DIRLIST,R       STOW WITH REPLACE\n         SPACE 2\n*                                  Branch on return codes\n         B     STOWEND(R15)\nSTOWEND  B     CHEKREPL                 GOOD REPLACE      RC = 0\n         NOP   ERRA\n         B     CHEKCOPY                 GOOD MEMBER ADD   RC = 8\n         B     ERRB\n         B     ERRC\n         NOP   ERRA\nERRD     MVC   ERRORMSG,MSGD\n         B     ERR\nERRC     MVC   ERRORMSG,MSGC\n         B     ERR\nERRB     MVC   ERRORMSG,MSGB\n         B     ERR\nERRA     MVC   ERRORMSG,MSGA\n         B     ERR\nINERROR  MVC   ERRORMSG,MSGRJI\n         MVC   RC,=H'04'\n         B     WRITERR\nOUTERROR MVC   ERRORMSG,MSGRJO\n         MVC   RC,=H'04'\n         B     WRITERR\nERR      MVC   RC,=H'12'\n         B     WRITERR\n         EJECT\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*\nSTOWAD   STOW  CLISTOUT,DIRLIST,A       STOW WITH ADD\n         SPACE 2\n*                                  Branch on return codes\n         B     STOWENDA(R15)\nSTOWENDA B     CHEKCOPY                 GOOD REPLACE   RC = 0\n         B     CHEKNORE                 NO REPLACE     RC = 4\n         NOP   ERRBA\n         B     ERRBA\n         B     ERRCA\n         NOP   ERRAA\nERRDA    MVC   ERRORMSG,MSGD\n         B     ERA\nERRCA    MVC   ERRORMSG,MSGC\n         B     ERA\nERRBA    MVC   ERRORMSG,MSGB\n         B     ERA\nERRAA    MVC   ERRORMSG,MSGA\n         B     ERA\nERA      MVC   RC,=H'12'\n         B     WRITERR\n         EJECT\n\n  -  -  -  -  -  DATA MISSING  -  -  -  -  -  -  -\n\n         DS    0F\nDIRLIST  DS    0CL74           DIRECTORY RECORD\nNAME     DC    CL8' '             Member name\nTTR      DS    CL3                Start TTR of member\nC        DS    CL1                Required Flag byte. X'80' is Alias.\nUSERDATA DS    CL62\n         SPACE\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9111NV": {"ttr": 9479, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x93!\\x0f\\x01\\x00)\\x9f\\x11G\\x01?\\x01?\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 319, "newlines": 319, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          November 1991\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\n\nEXPLOITING PARTITIONED DATASET DIRECTORY FIELDS:  PART III.\n\n\nINTRODUCTION TO PART III.\n\n      Much dataset activity related to MVS computing deals with the\npartitioned dataset structure.  The partitioned dataset, which can\nbe pictured as the \"generalized library\" construct under MVS, consists\nof a directory with \"member names\", followed by the member data\nitself.\n\n      The partitioned dataset directory entries can play a large part\nin MVS program execution when the partitioned dataset is a \"load\nlibrary\".  Members of a \"load library\" pds are the disk storage copies\nof executable programs, known as \"load modules\".\n\n      The information necessary to execute a load module under MVS is\nnot all contained in the data portion itself.  Essential program\nloading information used by the MVS \"program fetch\" component, is\nstored in pds directory \"user fields\" that we talked about in the first\ntwo parts of this series.  Today we shall conclude our pds directory\ndiscussion with a look at load module directory \"user\" fields that can\ncrucially affect program execution.\n\n\nA STRUCTURAL SUMMARY.\n\n      We stated in the previous installments that a pds directory\nentry has 12 required bytes, and up to 62 optional \"user\" bytes.\nThe required bytes are:  8 bytes - member name, 3 bytes - start\nTTR location of member data, and 1 byte - 3 bits of flags, and 5 bits\nstating the number of halfwords of user bytes (from 0 to 31 halfwords)\nin this directory entry.  See Figure One for details.\n\n      Before getting to look at a load module, I'd just like to\nsummarize the \"physical\" and \"logical\" structures of partitioned\ndataset directories.  These are the \"directory block\" (physical) and\n\"directory entry\" (logical) structures respectively.\n\n      Directory blocks have a FIXED DCB structure of RECFM (F),\nKEYLEN (8) and BLKSIZE (256), regardless of the DCB structure of the\ndata portion (the pds MEMBERS).  This makes each directory block 264\ncharacters in length, which is inflexible.  Within a directory block,\nhowever, there might be several \"directory entries\" that can vary\nconsiderably in structure.  A single directory block can contain as\nmany complete directory entries as will fit into the block.  Overflow\ncannot be tolerated; a directory entry cannot span two blocks.\n\n      Since individual directory entries may vary in size, there is\nno fast rule as to how many entries will fit into a directory block.\n\n      All member names in a pds directory are sorted in ascending\ncollating sequence.  The 8-byte KEY of each directory block contains\nthe member name of the highest member whose entry is in that block.\nThe first DATA byte of any directory block is a binary one-byte value\nthat indicates the length of meaningful directory entry data in each\nblock (not counting itself).  The value in this byte may go from X'00'\n(decimal 0) to X'FF' (decimal 255).\n\n      One practical result of this information:  It might pay NOT to\nkeep ISPF statistics for the members of your ISPF panel libraries.\nWithout statistics (which make each directory entry bigger), more\ndirectory entries can be packed into each directory block.  ISPF\nresponse time may be noticeably decreased for large panel libraries,\nbecause fewer physical blocks have to be searched to find a given\nmember, and ISPF dialogues involve a lot of panel searches.\n\n      When you allocate a partitioned dataset it is important to allow\nenough directory blocks to hold your member data.  Rather than\nreallocating a new dataset with more directory blocks when the\ndirectory is full, tools exist which allow expansion of pds directories\nto create more directory blocks \"on the fly\".\n\n      One of the best tools is the PDS Program Product (Version 8.4)\non File 182 of the CBT MVS Tape (obtainable from NaSPA (414) 423-2420\nor SPLA (305) 284-6257 for a handling charge).  The \"PDS Product\" has\na subcommand (\"FIXPDS EXPANDDIR (nnn)\" ) that will accomplish dynamic\ndirectory block expansion or reduction in a pds rather effortlessly,\nwith almost no environmental impact.  This tool and its vendor-supported\nsuccessor, PDS/E Sysprog Utilities (if you already have it), can\nsimplify and automate any of the directory entry manipulations we\nwill talk about here, accurately making these changes for single or\nmultiple members at a time.  Both products have a command called\n\"DIRENTRY\" which displays and formats directory entries.  See Figure\nTwo for a DIRENTRY display.\n\n\nMANIPULATION OF A LOAD MODULE DIRECTORY ENTRY.\n\n      At this point we can show how to flip some bits in a load module\ndirectory entry and get some results.\n\n      You'll need a tool to do the bit flipping.  Take your choice.\nYou can use IBM's superzap (AMASPZAP) from SYS1.LINKLIB if you know how\nto display the location of the directory blocks before making changes\nto them.  My favorite tool for bit flipping is the UCLA fullscreen ZAP\nprogram from the CBT MVS Utilities Tape:  Files 134, 135, or 300,\nwhich has a string \"find\" facility.  The PDS Program Product\n\"ATTRIBUTE\" subcommand, with keywords, will accomplish the desired\neffect more accurately without direct zapping.  I don't care how you\nflip the bits.  I'll just show you what bits to flip.\n\n      Look at the load module in Figure Two, named CNMCNETV.  This\nload module is reentrant, reusable, and authorized.  For argument's\nsake, suppose that reentrancy were not desired (perhaps we made a\nmistake in the linkedit parms).  Let's look at Figure One to see where\n\"reentrancy\" is shown.  We could turn off the \"reentrant\" attribute by\ngoing into the first attribute byte at +14 into the directory entry,\nturning off the B'10000000' bit.  The value X'C3' at +14 would be\nchanged to X'43'.  The load module would then be \"reusable\" and\n\"authorized\" only.\n\n      Often, \"reusability\" is on when \"reentrancy\" is turned on during\nlinkage editing.  Possibly reusability is also not desired for our\nmodule.  By referring to the DSECT description in Figure One, we see\nthat the reusability attribute for the load module is indicated by the\nB'01000000' bit at +14 into the directory entry.  We'll turn off the\nreusability bit, now changing the contents of the first attribute byte\nfrom X'43' to X'03'.  You get the idea.\n\n      Authorization of a load module results from using the linkage\neditor control card \"SETCODE AC(1)\" during linkage editing.  (For the\nmodule to actually execute authorized, its load library must be an\nauthorized library.  The library must be in an authorized LINKLIST\nconcatenation, or it must appear in the APF authorization table of\nSYS1.PARMLIB at IPL time, or be SYS1.LINKLIB or SYS1.SVCLIB on the\nactive res pack.)\n\n      As you can see from Figure One, the location of the\nauthorization byte (ON is X'01' and OFF is X'00') may vary sharply\ndepending on some other factors.  If the module is an ALIAS, is\n\"scatter loaded\", or if it contains a \"System Status Indicator\" (an\n\"SSI\"), the displacement of the authorization byte into the directory\nentry will be different.  For a given load module, you have to\nexamine the DSECT in Figure One carefully to determine where the\nauthorization byte is, before attempting to turn it on or off.\n\n      All this knowledge is useful, and it can be extremely helpful in\nsome emergency situations, but doing such bit flipping accurately can\nbe cumbersome and somewhat error prone.  Practically speaking, you can\nuse the \"PDS Program Product\" from the CBT Utilities Tape, or the\n\"PDS/E\" product if you have it.  You can point \"PDS\" to the load\nlibrary containing your modules, and issue its \"DIRENTRY\" and\n\"ATTRIBUTE\" subcommands.\n\n      For example (using load module CNMCNETV), to turn off reentrancy,\nenter:  \"ATTRIB CNMCNETV NORENT\".  To turn off reusability, enter:\n\"ATTRIB CNMCNETV NOREUS\".  And to turn off authorization, just enter:\n\"ATTRIB CNMCNETV NOAUTH\".  These parameters may be combined:  \"ATTRIB\nCNMCNETV NORENT NOREUS NOAUTH\" will turn all those attributes off at\nonce.  The ATTRIBUTE subcommand of \"PDS\" can turn ON linkedit\nattributes as well:  \"ATTRIB CNMCNETV RENT REUS AUTH\" will turn all of\nthese attributes on, accurately.\n\n      Please study the two illustrations thoroughly, because much\ninformation is contained in them.\n\n      Good luck in all your work.  I hope to be seeing you next\nmonth.\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n\nFIGURE ONE.   A DSECT Description of Partitioned Dataset Directory\n              Entries for Load Modules.  Load modules use the User\n              Fields of the directory entry in a special way that\n              is defined by the Linkage Editor and the MVS Program\n              Fetch component.  Labels in this illustration are from\n              source code in the PDS V8.4 product, module @DIALOG.\n              This source code is on the CBT Tape, File 182.  For\n              more standard names, see macro IHAPDS on SYS1.AMODGEN.\n\n\n\nDIRLINK  DS    0F            ***   DIRECTORY AREA MAPPING   ***\n*\nDIRNAME  DS    CL8           Member Name\nDIRTTR   DS    XL3           TTR of beginning of the Member\nDIRFLAG  DS    X             Flags for required direntry fields.\n*\nDIRCALIS EQU   B'10000000'   This member is an alias.\nDIRCTTRN EQU   B'01100000'   There is more than 1 TTR to update\nDIRCUDHW EQU   B'00011111'   Halfword count bits. Size of user bytes.\n*\nDIRUSER  DS    XL62          Directory USER Fields (62 Bytes Maximum)\n*\n         ORG   DIRUSER    FOLLOWING FOR LOAD MODULES\nDIRSTART DS    XL4           TTR of first Text block\nDIRNOTE  DS    XL3           TTR of Notelist\nDIRNOTE# DS    X             Number of Notelist entries\nDIRATTR  DS    XL2           Member Attributes\n*                         EQUATES for First Byte\n         ORG   DIRATTR\nDIRAT1ST DS    X\nDIRRENT  EQU   B'10000000'      Reentrant (RENT)\nDIRREUS  EQU   B'01000000'      Reusable  (REUS)\nDIROVLY  EQU   B'00100000'      Overlay Module  (OVLY)\nDIRBADO  EQU   B'11001100'      OVERLAY CONFLICTS - Not RENT, REUS,\n*                                    Only Loadable, or SCTR.\nDIRTEST  EQU   B'00010000'      TEST\nDIRLOAD  EQU   B'00001000'      Only Loadable  (OL)\nDIRBADL  EQU   B'00000100'      ONLY LOADABLE CONFLICTS - Not SCTR.\nDIRSCTR  EQU   B'00000100'      Scatter Load  (SCTR)\nDIRBADS  EQU   B'10101000'      SCATTER LOAD CONFLICTS - Not RENT, OVLY\n*                                    or Only Loadable.\nDIREXEC  EQU   B'00000010'      Executable\nDIRF1    EQU   B'00000001'\n*                         EQUATES for Second Byte\n         ORG   DIRATTR+1\nDIRAT2ND DS    X\nDIRNODC  EQU   B'10000000'      NODC (Not Downward Compatible)\nDIRF2    EQU   B'01000000'\nDIRF3    EQU   B'00100000'\nDIRF4    EQU   B'00010000'\nDIRNOED  EQU   B'00001000'      Not Editable (NE)\nDIRF5    EQU   B'00000100'\nDIRLKEDF EQU   B'00000010'      F Level Linkage Editor\nDIRREFR  EQU   B'00000001'      Refreshable (REFR)\n*\nDIRSTORE DS    XL3           Size of Load Module\nDIRTEXTL DS    XL2           Length of 1st Text Record\nDIREPA   DS    XL3           Entry Point Address\n*\nDIRATTR2 DS    X           ADDITIONAL ATTRIBUTE BYTES:\nDIRAOSLE EQU   B'10000000'   VS Linkage Editor created this module\nDIR2PAGA EQU   B'00100000'   Page Alignment is required\nDIR2SSI  EQU   B'00010000'   SSI Information present for module\nDIRAPFLG EQU   B'00001000'   APF Information for this module is valid\n*\nDIRATTR3 DS    X           ADDITIONAL ATTRIBUTE BYTES:\nDIRRMANY EQU   B'00010000'   RMODE=ANY\nDIRAA31  EQU   B'00001000'   AMODE=31  (Alias entry)\nDIRAA24  EQU   B'00000100'   AMODE=24  (Alias entry)\nDIRAM31  EQU   B'00000010'   AMODE=31  (Main entry)\nDIRAM24  EQU   B'00000001'   AMODE=24  (Main entry)\n*\nDIRATTR4 DS    X             Count of RLD Entries after first Text\n*\nDIRAPF   DS    0XL2          APF (If not SCATTER, SSI or ALIAS)\nDIREP    DS    XL3           Entry Point of Main Member\nDIRREAL  DS    CL8           Real Name of Member\nDIRAPF2  DS    XL2           APF Information (ALIAS, no SCAT or SSI)\nDIREND2  EQU   *             End of ALIAS Section\n*\n         ORG   DIRAPF     FOLLOWING IS FOR SCATTER LOADED MODULES.\nDIRSCLL  DS    XL2           Length of Scatter List\nDIRSCTL  DS    XL2           Length of Translate Table\nDIRSCET  DS    XL2           ESDID of First Text Record\nDIRSCEP  DS    XL2           ESDID of Entry Point\nDIRAPF3  DS    0XL2          APF Info (If SCATTER, no SSI and no ALIAS)\nDIREPSC  DS    XL3           Entry Point (Main Member)\nDIRREALS DS    CL8           Real Name of Member\nDIRAPF4  DS    XL2           APF Info (SCATTER, no SSI and ALIAS)\nDIREND3  EQU   *             End of SCATTER, ALIAS Section\n\n\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n\nFIGURE TWO.   This illustration shows a Load Library directory\n              entry, containing some honest, real-life information\n              about a load module.  The display was obtained by the\n              vendor product, PDS/E Sysprog Utilities.  You should\n              mentally fit this information together with the DSECT\n              description of Figure One.\n\n              Load module illustrated is:\n\n              SYS1.LPALIB(CNMCNETV)          rent, reus, ac=1\n\n\n\nPDS300A ENTER OPTION -- DSN=SYS1.LPALIB,VOL=SER=S1RES1  MEM=\n>direntry cnmcnetv\nPDS143I CNMCNETV Directory entry, length=40\n         0000  C3D5D4C3 D5C5E3E5  00DF242E 00DF2A00  *CNMCNETV........*\n         0010  00000000 C3F20002  10021000 00009812  *....C2........q.*\n         0020  00000111 05300101                     *........*\n\nPDS262I LOC NAME     VALUE     DESCRIPTION\nPDS262I --- ----     -----     -----------\nPDS262I 00  PDS2NAME CNMCNETV  MEMBER NAME\nPDS262I 08  PDS2TTRP 00DF24    TTR OF FIRST BLOCK OF DATA\nPDS262I 0B  PDS2INDC 2E        1 TTRS FOLLOW; 14 HALFWORDS OF DATA\nPDS262I 0C  PDS2TTRT 00DF2A,00 TTR OF FIRST TEXT BLOCK\nPDS262I 10  PDS2TTRN 000000,00 (NOT USED FOR THIS MEMBER)\nPDS262I 14  PDS2ATR1 C3        REENTRANT; REUS; NOT OVERLAY; NOT TEST\nPDS262I                        NOT ONLY LOAD; NOT SCATTER; EXEC; 1 TEXT\nPDS262I 15  PDS2ATR2 F2        NOT DC; TEXT ORG=0; EP=0; NOT HAS RLDS\nPDS262I                        EDIT; NOT TEST; LKED F; NOT REFRESHABLE\nPDS262I 16  PDS2STOR 528.      TOTAL CONTIGUOUS MAIN STORAGE REQUIRED\nPDS262I 19  PDS2FTBL 528.      LENGTH OF FIRST BLOCK OF TEXT\nPDS262I 1B  PDS2EPA  000000    ENTRY POINT ADDRESS\nPDS262I 1E  PDS2FTB1 98        PROCESSED BY OS/VS LINKAGE EDITOR\nPDS262I                        SSI INFORMATION IS PRESENT\nPDS262I                        APF INFORMATION IS VALID\nPDS262I 1F  PDS2FTB2 12        RMODE ANY; ALIAS AMODE 24;  MAIN AMODE 31\nPDS262I 20  PDS2FTB3 00        RLD/CONTROL RECORDS AFTER FIRST TEXT BLOCK\nPDS262I 22  PDSSSIWD 01110530  SSI INFORMATION\nPDS262I 26  PDSAPFCT 01        LENGTH OF PROGRAM AUTHORIZATION CODE\nPDS262I 27  PDSAPFAC 01        PROGRAM AUTHORIZATION CODE\n\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9112DE": {"ttr": 9729, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x93!\\x0f\\x01\\x00)\\x9f\\x11G\\x01\\x06\\x01\\x06\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 262, "newlines": 262, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          December 1991\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\n\nABOUT DATASET BLOCK SIZES AND I/O EFFICIENCY - PART I.\n\n      I am sure all of you realize that most MVS shops are both the\nsame and different.  They are the same, in that our skills, developed\nat one site, can be largely used at another site without much\nmodification--the type of work is similar at all sites.  They are\ndifferent, in that the actual hardware configurations and workload\npatterns can vary widely.  IBM and \"third party\" software that exists\nin one place can be absent at another.  Performance situations that\nare everyday occurrences in one shop, might never have happened in\nthe entire history of a second shop.\n\n      So, in talking about block sizes of datasets, one can only make\nrather general remarks, leaving it to the individual system programmers\nto see what applies in their own situations.\n\n\nA BIT OF BACKGROUND.\n\n      Dataset management concerns data on disks, but the overriding\nconcern about datasets is usually the efficiency of I/O operations to\nand from the data.  The speed at which the day's work is done, is most\noften more important than squeezing the last free byte out of available\ndisk storage.\n\n      System programmers need to know how to plan the use of disk\nstorage for I/O efficiency.  Even a \"system managed\" storage\nenvironment can be mis-managed, causing needless expense and work\ndelays.  Since we system programmers still set up all disk-space\nenvironments, even today, we must become more familiar with the\nfactors affecting their performance.  We must also be very aware of\nthings which can go wrong.\n\n      Block sizing has traditionally been a balancing act.  Small\nblocks waste a lot of disk space.  Large blocks can often be used\nefficiently once they are read into central storage, but waste-causing\nfactors might also make a large blocksize into a poor choice as well.\n\n      From the point of view of pure disk pack utilization (percent of\navailable track space used by a given block size), a tool such as the\nBLKDISK utility (also called BLK3350, BLK3380, and BLK3390), can\nquickly show you a panorama of alternatives.  See Figure 1 for an\nillustration of what BLKDISK will show.  Using such a tool, you can\nquickly weigh the space usage of any block size on a given disk pack\ntype, without having to do laborious calculations.  BLKDISK is a\npublic domain tool available on File 296 of the CBT MVS Utilities Tape\ndistributed by NaSPA (414-423-2420) or by SPLA (305-284-6257).\n\n      We shall go a bit deeper here.  My friend Rick Fochtman has\ndone some studies about I/O efficiency that I've found to be both\ninteresting and helpful.  I'll attempt to convey some of his\nfindings to you.  Please be aware that any errors in \"transmission\"\nare mine, and not his.\n\n      Rick Fochtman's contention is that for any type of sequential\ndataset access nowadays (since SAM-E), especially when allocating by\nTRACKS, the most efficient I/O should be attained by blocking 5 blocks\nto a track.  I'll try to explain some of the concepts behind his\nreasoning.\n\n\nSOME \"MAGIC NUMBERS\".\n\n      The Input-Output Subsystem (or \"IOS\") is a part of the MVS base\nproduct which handles the nitty-gritty or \"low-level\" disk access\noperations.  The higher levels, \"READs and WRITEs\" which are\nunderstandable to most programmers, are the domain of the \"access\nmethods\" in \"DFP\" (Data Facility Product), which is the\ndata-management add-on to base MVS.  For maximum efficiency of\ninput-output operations to disk files, the designers of the access\nmethods decided some years ago, that every disk-file \"read\" should\nbest default to five buffers.  In JCL, this would be specified by\nsaying \"BUFNO=5\" in each disk DD card.  The higher-level access\nmethods in DFP specify \"BUFNO=5\" as the default for sequential disk\naccess.\n\n      That's very important.  Simply, it means that every time you\ndo a disk read, the system tries to fill five buffers.\n\n      It's becoming clear now, why 5 blocks to a track might be\nespecially good.  The reason is that when you ask for a logical\nrecord, SAM (sequential access) decides when to go out and ask for\nmore buffers of data.  SAM buffer management, by default, works\nin groups of 5 buffers.  Everything SAM does is in groups of five,\nwith the exception of BSAM (where the programmer has complete control,\nbut where one could lose much efficiency).  You can fill all these 5\nbuffers in one sweep of a track, without having to skip tracks.\nSkipping tracks is wasteful.  We hope to explain why, further on.\n\n      You can argue (rightly) that skipping tracks is inefficient\nonly if you allocate your datasets on a TRACK boundary.  What if you\nallocate them on a CYLINDER boundary?\n\n      The problem with cylinder allocation is that for small datasets,\nit's wasteful of disk space.  Rick's studies and experience have told\nhim that cylinder allocation is usually helpful for datasets of 3\ncylinders and larger.  Besides, he has found through detailed tracing\nthat dataset access efficiency for track-allocated datasets blocked\n5 blocks to a track, is nearly identical to efficiency for datasets\nallocated on cylinder boundaries.\n\n      So this \"5 blocks to a track\" blocking seems to be a good\n\"magic number\" because of the design of IOS and the access methods.\nIf you do some calculations of disk-space usage, (or you look at the\nBLKDISK output in Figure 1) you'll see that five blocks to a track\non a 3380 device isn't significantly more wasteful than 2 blocks to\na track.  That's because modern disk devices have big tracks.\n\n\nTO GO ON.\n\n      I'll have to continue this discussion next month, but we have\nsome big plans.  I want to talk more about access methods, and about\nhow sizable performance gains can be obtained through maximizing\nchannel usage.  (If you still use ISAM, get rid of it and use VSAM.)\nI'll try to really get into I/O issues.\n\n      Meanwhile, I hope this has been helpful.  Good luck.  See you\nnext month.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n\nFIGURE 1.      Illustration of the BLK3380 TSO Command, invoked to\n                show disk space usage on a 3380 device.  Various\n                block size scenarios are displayed in the upper\n                table, enabling the user to graphically see the\n                disk space utilization by the different block sizes.\n                The Track Capacity Table for 3380 devices is shown\n                as the lower table of the illustration.  Please note\n                that we do not \"recommend\" half-track blocking here.\n                The \"RECOMMENDED\" remark is part of the program's\n                normal output.\n\n\nblk3380 80 trackcap\n\n  3380 BLOCKSIZE SUMMARY;    LRECL=80        KEY LENGTH=0\n            BLOCKSIZE    BLOCKS/TRACK    LRECLS/TRACK    UTILIZATION\n            ---------    ------------    ------------    -----------\n                   80              83              83          14.0%\n                2,480              16             496          83.6%\n                2,640              15             495          83.4%\n                2,880              14             504          84.9%\n                3,120              13             507          85.4%\n                3,440              12             516          86.9%\n                3,840              11             528          89.0%\n                4,240              10             530          89.3%\n                4,800               9             540          91.0%\n                5,440               8             544          91.7%\n                6,320               7             553          93.2%\n                7,440               6             558          94.0%\n 5 BLOCKS/TRK   9,040               5             565   --->   95.2%\n               11,440               4             572          96.4%\n               15,440               3             579          97.6%\n RECOMMENDED-->23,440               2             586   --->   98.7%\n               32,720               1             409          68.9%\n\nFOR BLKSIZE 23,440  AND   100,000 RECORDS, ALLOCATE:\n       342 BLOCKS,       171 TRACKS, OR        12 CYLINDERS\n\n\n\n  3380 TRACK CAPACITY;    KEY LENGTH=0\n       BLOCKS/TRACK     BLKSIZE     BYTES/TRACK     UTILIZATION\n       ------------     -------     -----------     -----------\n                  1      47,476          47,476          100.0%\n      ----->      2      23,476          46,952    --->   98.9%\n                  3      15,476          46,428           97.8%\n                  4      11,476          45,904           96.7%\n      ----->      5       9,076          45,380    --->   95.6%\n                  6       7,476          44,856           94.5%\n                  7       6,356          44,492           93.7%\n                  8       5,492          43,936           92.5%\n                  9       4,820          43,380           91.4%\n                 10       4,276          42,760           90.1%\n                 11       3,860          42,460           89.4%\n                 12       3,476          41,712           87.9%\n                 13       3,188          41,444           87.3%\n                 14       2,932          41,048           86.5%\n                 15       2,676          40,140           84.5%\n                 16       2,484          39,744           83.7%\n\nDEVICE SUMMARY: MAX BLOCKSIZE=47,476   TRACKS=13,275   BYTES=630,243,900\nNOCYLS=885   TRKS/CYL=15   TRKSIZE=47,968   DSCB/TRK=53   PDS/TRK=46\n\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE 1A.     Illustration of the BLK3390 TSO Command, invoked to\n                show disk space usage on a 3390 device.  Various\n                block size scenarios are displayed in the upper\n                table, enabling the user to graphically see the\n                disk space utilization by the different block sizes.\n                The Track Capacity Table for 3390 devices is shown\n                as the lower table of the illustration.\n\n\nblk3390 80 trackcap\n\n  3390 BLOCKSIZE SUMMARY;    LRECL=80        KEY LENGTH=0\n            BLOCKSIZE    BLOCKS/TRACK    LRECLS/TRACK    UTILIZATION\n            ---------    ------------    ------------    -----------\n                   80              78              78          11.0%\n                2,880              16             576          81.3%\n                3,120              15             585          82.6%\n                3,440              14             602          85.0%\n                3,760              13             611          86.3%\n                4,080              12             612          86.4%\n                4,560              11             627          88.5%\n                5,040              10             630          88.9%\n                5,680               9             639          90.2%\n                6,480               8             648          91.5%\n                7,520               7             658          92.9%\n                8,880               6             666          94.0%\n 5 BLOCKS/TRK  10,720               5             670   --->   94.6%\n               13,680               4             684          96.6%\n               18,400               3             690          97.4%\n RECOMMENDED-->27,920               2             698   --->   98.5%\n               32,720               1             409          57.7%\n\nFOR BLKSIZE 27,920  AND   100,000 RECORDS, ALLOCATE:\n       287 BLOCKS,       144 TRACKS, OR        10 CYLINDERS\n\n  3390 TRACK CAPACITY;    KEY LENGTH=0\n       BLOCKS/TRACK     BLKSIZE     BYTES/TRACK     UTILIZATION\n       ------------     -------     -----------     -----------\n                  1      56,664          56,664          100.0%\n      ----->      2      27,998          55,996    --->   98.8%\n                  3      18,452          55,356           97.7%\n                  4      13,682          54,728           96.6%\n      ----->      5      10,796          53,980    --->   95.3%\n                  6       8,906          53,436           94.3%\n                  7       7,548          52,836           93.2%\n                  8       6,518          52,144           92.0%\n                  9       5,726          51,534           90.9%\n                 10       5,064          50,640           89.4%\n                 11       4,566          50,226           88.6%\n                 12       4,136          49,632           87.6%\n                 13       3,768          48,984           86.4%\n                 14       3,440          48,160           85.0%\n                 15       3,174          47,610           84.0%\n                 16       2,942          47,072           83.1%\n\nDEVICE SUMMARY: MAX BLOCKSIZE=56,664   TRACKS=16,695   BYTES=946,005,480\nNOCYLS=1,113   TRKS/CYL=15   TRKSIZE=58,786   DSCB/TRK=50   PDS/TRK=45\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9201JA": {"ttr": 9734, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x93!\\x0f\\x01\\x00)\\x9f\\x11G\\x00\\xff\\x00\\xff\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 255, "newlines": 255, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          January 1992\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\n\nABOUT DATASET BLOCK SIZES AND I/O EFFICIENCY - PART II.\n\n      This issue marks the beginning of this column's fourth year.\nTime flies, when you enjoy your work!\n\n      Last month, we began to speak about the need for I/O efficiency\nto and from disk storage.  Although it is important to pack as much\ndata as possible into a track of disk space, it is probably a good\ndeal more important to write and retrieve that data quickly.  An\nanalysis of the workload at most shops will probably show that\nthroughput--getting the jobs done quickly--is the highest priority\naim.\n\n      My friend Rick Fochtman has done a lot of study directed at\nincreasing job throughput.  Rick contends that I/O bottlenecks are a\ngreat part of the performance problems in most places.  One outgrowth\nof Rick's studies, is the rather startling result that certain\nprevalent block sizing practices can significantly hurt I/O rates\nto and from disk storage.\n\n      I hope to explain some of Rick's contentions as we go on.\nWe'll talk about the channel programs associated with disk I/O,\nand how to reduce various sources of wasted time.\n\n      Rick has stated, that on a very busy system, datasets with\none-fifth track blocking (five blocks per track) could have I/O\nrates 2 1/2 or 3 times more efficient than with half-track blocking.\nAs we showed last month (see Figure 1), track utilization at 5 blocks\nper track on 3380's and 3390's is just a bit less than space usage at\n2 blocks per track.  That slight space loss will be greatly offset by\nthe increased I/O speed to and from the data.\n\n      Rick adds the caveat that he has not studied DASD with cache\ncontrollers, but there is still a lot of DASD without cache\ncontrollers out there.  For the latter, Rick feels he can vouch for\nthese results.\n\n\nCHANNEL PROGRAMS IN DATA MANAGEMENT AND IN IOS.\n\n      IOS, the \"Input-Output Subsystem\", is a part of the base MVS\nproduct.  IOS does device-specific handling of I/O requests.  IOS can\nbe pictured as as the \"lowest level\" of I/O software in MVS.\n\n      The more familiar \"READS\" and \"WRITES\" to disk that are done by\nmost programmers, are part of the \"data management\" packages (nowadays\ncalled \"DFP\" or \"Data Facility Product\"), which are an add-on to the\nbase MVS product.  The data management \"access methods\", which handle\nthe \"reads and writes\", are a higher-level and more device-independent\nprogrammer interface.  \"Access Methods\" are part of DFP.\n\n      What happens when you do a sequential READ or a WRITE, using\nan access method (except for BSAM, where the programmer has complete\ncontrol)?  Almost always, the system tries to fill 5 buffers at once.\nThis number 5 was decided upon by the data management architects some\nyears ago as optimal for internal design reasons.  When the BUFNO\nparameter is not stated on a DD card, \"BUFNO=5\" is usually the\ndefault.\n\n      In order to fill these buffers, the system must get the data.\nIt does so using \"channel programs\", which instruct those I/O\nhardware devices loosely known as \"channels\".  The \"channels\" do\nthe actual I/O to and from the devices, independently of the CPU.\n\n      Instructions in channel programs are called \"CCWs\", or\n\"Channel Command Words\".  We shall assume (for those who are\nfamiliar) that our discussion will concern only \"Format-0 CCWs\",\nthat are essentially unchanged for 25 years.  There are various types\nof these CCWs.  We shall discuss what happens when we want to read\nsome records on disk storage using \"QSAM\" (Queued Sequential Access\nMethod).\n\n      When we issue a GET for the data, QSAM constructs a channel\nprogram consisting of 3 instructions.  These are:\n\n      \"Search ID=\" (a search for particular CCHHR disk data within\nboundaries), TIC (an unconditional \"goto\") back to the \"search id=\"\ninstruction and finally (if the search was successful) the next\nsequential CCW (the TIC) is bypassed.  This results in the execution\nof the third instruction, a \"Read CKD\" (or \"Read Count-Key-Data\")\nwhich gets the data.\n\n      If both BUFNO greater than 1, and NCP greater than 1 are\nspecified, then the channel program is extended to read that number\nof records (the minimum of these two numbers) without additional\nseek overhead.  However, this is limited by space allocation unit\n(TRK or CYL) boundaries.  (BLKs are rounded to tracks.)\n\n      The access method (QSAM) passes this channel program down to\nIOS, which adds two instructions to the front of it, and sometimes\na third.  These are:\n\n      A \"standalone SEEK\" for the desired CCHHR, to get the heads\nmoving to the right cylinder.  This is followed by a \"CCW Set File\nMask\", which sets limits on allowing a change of track or cylinder.\nYou want to remain in the bounds of your dataset allocation during the\nsubsequent reading of the data.  The hardware helps you do this.\n\n      So the program which goes to the device actually consists of\nfive instructions:  standalone seek, CCW set file mask, search id=,\nTIC back to the search, and finally Read CKD.\n\n      A significant time-consumer here is the standalone seek.\nAny means of decreasing the number of seeks is probably good for\nthroughput.  A second potential time-waster has to do with disk\nrotation delays.  We'll talk about that shortly.  Our third time-\ngobbler is eliminated by 5-block per track blocking.  Simply put,\nit's THE PREVENTION OF BREAKS IN THE CHANNEL PROGRAM.\n\n      Remember that the access methods will try to fill five buffers\nat one time.  They do this for their own internal efficiency (so it\ndoesn't pay to set BUFNO=2 for every DD card in your shop.  The\n\"access method\" people have thought of that already.)  The five\nbuffers will get filled smoothly, provided that the CCW \"set file\nmask\" instruction doesn't detect a bad data boundary, such as the\nend of a track or the end of a cylinder.  If track or cylinder\nboundary does get hit, IOS will construct a new channel program and\nstart it automatically, but with the penalty of a big time delay and\nmany extra \"searches\".\n\n      Now just think.  Under half-track blocking, reading 5 blocks\ncrosses two track boundaries.  This results in two channel program\nbreaks and restarts, forcing lots of extra \"searches\".  Under\n\"5-blocks per track\" blocking, reading 5 blocks results in no\nchannel program break at all.  The channel program just starts at\nthe beginning of the track, reads the entire track and fills the\nbuffers.  There are no channel program break delays introduced.\nThat's where you get the huge savings, especially while using TRK\nallocation that forces an program break at every track boundary.\n\n      This idea is worth investigation and implementation.\n\n      With that explained, let's conclude this month's installment\nwith a discussion of disk rotation delays.\n\n\nDEVICES EQUIPPED WITH ROTATIONAL POSITION SENSING (RPS).\n\n      Our discussion of \"disk rotation delays\" is really a misnomer.\nThe major concern here is the prevention of \"channel-busy\" tie-ups\nduring disk rotation.\n\n      If a disk device has to interrupt an I/O because it is waiting\nfor a particular record to rotate under its heads, the least it can\ndo is free the connecting channel to do other work during the\nrotational delay.  Devices having the \"RPS\" feature do just this.\nThey free the connecting channel while they are rotating toward\na record.  Both 3380 and 3390 disk devices have the RPS feature.\n\n      From our point of reference, how does this feature work?\n\n      If the access method (DFP) knows that it's going to an\nRPS-equipped device, it issues a \"set sector\" CCW instruction\nbefore the \"search id=\" CCW instruction.  This \"set sector\"\ninstruction operates in the hardware, between the channel and\nthe device.  The idea is that the hardware will determine when\nthe required record is underneath its heads, and only then will\nit try to connect the channel to the device.  If the channel is\nbusy, the device will have to do one more rotation.  Otherwise,\na free channel will be connected to the device and will retrieve\nthe record.\n\n      There are many implications to this.  A full disk rotation\nis on the order of 14-17 milliseconds.  That's a long time to\ntie up a channel connected to half a dozen devices, all trying\nto do their own I/O's.\n\n      Speaking about channel tie-ups, we'll talk about key searches\nnext month, when we conclude this series.  Key searches tie up the\nchannel while they're occurring.  ISAM does a lot of key searches.\nBLDL does a lot of key searches.  Program operations that involve\nkey searches can cause I/O bottlenecks, principally because of\nchannel tie-ups.  We'll see how, next time.\n\n      Meanwhile, we've got plenty to chew on.  Good luck in all\nyour work.  See you next month.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE 1.      This is a display of track capacities for 3380 and\n                3390 disk devices.  The display was produced by\n                the BLKDISK command from File 296 of the CBT MVS\n                Utilities Tape.  The numbers shown are the largest\n                blocksizes possible, to be able to fit \"N\" blocks\n                into a track.  A 3380 device can hold 47476 bytes\n                in one track, but two blocks on the same track\n                would require an \"inter-block spacing\".  Three\n                blocks would require two spacings, and so on.\n                This chart shows the extent of \"spacing losses\"\n                for each device.  For both devices, 5 blocks/track\n                is not very much worse than 2 blocks/track.  An\n                additional 3 spacings on a large track isn't too\n                much, percentage wise.\n\n\n  3380 TRACK CAPACITY;    KEY LENGTH=0\n       BLOCKS/TRACK     BLKSIZE     BYTES/TRACK     UTILIZATION\n       ------------     -------     -----------     -----------\n                  1      47,476          47,476          100.0%\n   (2 blks/trk)   2      23,476          46,952    --->   98.9%\n                  3      15,476          46,428           97.8%\n                  4      11,476          45,904           96.7%\n   (5 blks/trk)   5       9,076          45,380    --->   95.6%\n                  6       7,476          44,856           94.5%\n                  7       6,356          44,492           93.7%\n                  8       5,492          43,936           92.5%\n                  9       4,820          43,380           91.4%\n                 10       4,276          42,760           90.1%\n                 11       3,860          42,460           89.4%\n                 12       3,476          41,712           87.9%\n                 13       3,188          41,444           87.3%\n                 14       2,932          41,048           86.5%\n                 15       2,676          40,140           84.5%\n                 16       2,484          39,744           83.7%\n\nDEVICE SUMMARY: MAX BLOCKSIZE=47,476   TRACKS=13,275   BYTES=630,243,900\nNOCYLS=885   TRKS/CYL=15   TRKSIZE=47,968   DSCB/TRK=53   PDS/TRK=46\n\n\n  3390 TRACK CAPACITY;    KEY LENGTH=0\n       BLOCKS/TRACK     BLKSIZE     BYTES/TRACK     UTILIZATION\n       ------------     -------     -----------     -----------\n                  1      56,664          56,664          100.0%\n   (2 blks/trk)   2      27,998          55,996    --->   98.8%\n                  3      18,452          55,356           97.7%\n                  4      13,682          54,728           96.6%\n   (5 blks/trk)   5      10,796          53,980    --->   95.3%\n                  6       8,906          53,436           94.3%\n                  7       7,548          52,836           93.2%\n                  8       6,518          52,144           92.0%\n                  9       5,726          51,534           90.9%\n                 10       5,064          50,640           89.4%\n                 11       4,566          50,226           88.6%\n                 12       4,136          49,632           87.6%\n                 13       3,768          48,984           86.4%\n                 14       3,440          48,160           85.0%\n                 15       3,174          47,610           84.0%\n                 16       2,942          47,072           83.1%\n\nDEVICE SUMMARY: MAX BLOCKSIZE=56,664   TRACKS=16,695   BYTES=946,005,480\nNOCYLS=1,113   TRKS/CYL=15   TRKSIZE=58,786   DSCB/TRK=50   PDS/TRK=45\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9202FE": {"ttr": 9739, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x93!\\x0f\\x01\\x00)\\x9f\\x11G\\x01\\r\\x01\\r\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 269, "newlines": 269, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         February 1992\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\n\nABOUT DATASET BLOCK SIZES AND I/O EFFICIENCY - PART III.\n\n      This is the final part of our three-part discussion about I/O\nefficiency considerations.  I want to thank my friend Rick Fochtman\nfor his help in producing this series.  This month, I'd like to talk\nabout recognizing and avoiding extra CCW key searches in production\nprocessing.  Key searches are wasteful in that they require the\nchannel to be connected for the entire time the search is occurring.\nAny process that does repeated key searches will tie up a channel and\npossibly cause an I/O bottleneck.\n\n      Certain \"normal\" computing processes do repeated key searches.\nThey are wasteful almost by definition, and therefore they should\nbe minimized (or at least studied) in a production environment to\nimprove the throughput of work.\n\n      Three of these processes are:  1) BLDL processing, which does PDS\ndirectory member name searches on disk, 2) ISAM data organization, which\nis not used much nowadays, but which should be eliminated if it is\nstill used, and 3) creation and deletion of datasets on volumes with\nnon-indexed VTOCs.\n\n\nA BIT OF PRACTICAL HELP FOR BLDL INEFFICIENCIES.\n\n      BLDL is by far the most prevalent of these three processes.\nBecause of that, I'll digress on the subject of BLDL processing.\n\n      When a member is to be fetched from a library on disk, BLDL is\nused to find the member's CCHHR track location.  The BLDL process\noccurs whenever a partitioned dataset member is accessed through the\nPDS directory.  For example, if you are executing a program from a\ndisk library, or if you are looking for an assembler macro, BLDL is\ncalled.  BLDL processing, and its improvements, are centered in SVC\n18, or module IGC018.\n\n      \"Unimproved\" BLDL uses key-based searches which are very slow\nand I/O-bound.  We'll talk later about how these searches work.\nBLDL-caused bottlenecks are an old problem in MVS.  Practically\nspeaking, however, you can do a lot by eliminating repeated BLDL\nsearches when finding PDS member locations on disk more than once.\n\n      If you have an XA or an ESA system, it is highly recommended to\nuse LLA (Linklist Lookaside) to avoid repeated BLDL directory searches\nfor linklist programs.  LLA does BLDL processing once, upon its\ninitialization, and creates a hashed table of all linklist directory\nentries, in the LLA address space.  An SVC 18 hook sends linklist BLDL\nrequests to LLA, if the LLA address space is running.\n\n      If you have an ESA system, the Virtual Lookaside Facility (VLF)\nwill greatly speed program access and CLIST execution, partially by\navoiding key-search I/Os to disk, and also by taking advantage of\nexpanded storage if it is available.\n\n      On an ESA system, its Library Lookaside Facility can be used to\neliminate traditional BLDL searches on non-linklist program libraries\nas well as on linklist libraries.\n\n      Even for MVS/370 there is help.  The Dynamic BLDL program called\n\"DYNABLDL\", which is on File 407 of the CBT MVS Utilities Tape, can\ngreatly boost throughput on an MVS/370 system or on an XA system, by\neliminating repeated BLDL searches.  DYNABLDL does only one real BLDL\nfor each found module name.  A dynamic table is built in core that is\nused by each subsequent request for the same module.  The most\nrecently and frequently used linklist programs are put into the\ndynamic table.  DYNABLDL offers a nice report concerning its own\nefficiency, the names of all modules hit, and when they were hit.\nWith DYNABLDL, you can also \"purposely miss\" certain linklist\nlibraries if you want to, through a conditional assembly option.\n\n      You can obtain the CBT Utilities Tape from NaSPA (414) 423-2420\nor from SPLA (305) 284-6257.  If you use DYNABLDL, you should nullify\nthe IEABLD-- member of SYS1.PARMLIB, and let DYNABLDL handle all of\nthe linklist BLDL requests.  I have found that LLA is somewhat more\nefficient on an XA system than DYNABLDL is, but you may want to use\nDYNABLDL on XA as a research tool, for the benefit of its reports.\nDYNABLDL hooks into SVC 18 later than LLA does, so LLA must be down\nin order for DYNABLDL to function on an XA system.\n\n\nWHY \"SEARCH KEY\" CCW'S ARE INEFFICIENT.\n\n      Now, let's get back to the main topic of our discussion,\nwhich is to explain why \"Search Key\" CCW's are inefficient.\n\n      We explained some basics of \"channel programs\" in the last two\ninstallments of this column.  In System 370 architecture, I/O to\nperipheral devices is not done by the CPU, but by hardware devices\nloosely known as \"channels\".  Channels can be pictured as being an\n\"intelligent cable\" to bring data between the CPU and the outside\ndevice.  Channels can function independently of the CPU.  One\nchannel is usually connected to a string of several disk or tape\ndevices.  Channels can be programmed.  The \"instructions\" in a\nchannel program are called CCW's, or \"Channel Command Words\".\n\n      \"Search Key High or Equal\" and \"Search Key Equal\" are types of\nchannel \"op codes\".  A \"Search Key\" CCW looks for the \"key\" of \"keyed\ndata\" in a keyed data file.\n\n      Keyed data is a type of disk data in a dataset, with up to 255\nbytes of \"key\", followed by possibly many thousand bytes of \"data\".\nThe key precedes the data, followed by another key and more data.  The\npurpose of the key is to aid in \"directly\" locating the data.  If the\nkey is searched for and found, the data immediately following the key\nmay be retrieved relatively quickly thereafter.  A \"Search Key\" CCW\nis a hardware mechanism of comparing for and finding a certain key\nin a keyed data file.\n\n      Usually, \"Search Key\" CCW's are coded in loops.  There is a\n\"Search Key\", followed by a TIC (Transfer in Channel) which is an\nunconditional branch back to the \"Search Key\".  The next instruction\nafter the TIC is usually a \"Read Data\" CCW.\n\n      This is how the loop is executed.  Our channel is connected to\nthe disk media which is rotating under the read heads.  When a \"Search\nKey\" CCW is executed, the channel pulls in the next key area that\npasses under the read heads.  (Remember that on a CKD disk device, all\ndisk data is recorded as either \"count\" areas, \"key\" areas, or \"data\"\nareas, and the hardware knows how to tell the difference.)  The channel\nworks very quickly.  During the time when the gap is rotating between\nkey and data, the channel grabs the compare value from main computer\nstorage, and compares it to the key value drawn in from the disk key.\nIf the compare is satisfied, the channel sets the status modifier in\nthe \"Search Key\" CCW to skip the next instruction, and go on to the\nfollowing \"Read Data\" CCW in the channel program.  The \"Read Data\" CCW\nwill pull in the data corresponding to the key.  If the compare was\nnot satisfied, the TIC is executed to branch back to the \"Search Key\",\nand the channel program waits for the next \"key\" area to rotate\nunder its heads.\n\n      The crucial point is that during this \"Search Key\" loop, THE\nCHANNEL REMAINS TIED TO THE DISK DEVICE.  The reason is quite logical.\nThe channel cannot disconnect from the disk device during an\nunsuccessful search loop, while the keys are being read again and\nagain.  The problem is, that while successive keys are being read, the\nchannel program must wait for the next key to pass under the read\nheads.  However, since the data area after each key area is of\nunpredictable size, there is no way of knowing in advance when the\nnext key area will arrive under the heads.  Therefore the channel must\nalways remain connected to the rotating device during the \"Search Key\"\nloop.\n\n      Most key searches are unsuccessful for a long while, before the\ncorrect key is found.  Getting the data, once you're there, is not\nthe problem.  That's the same no matter what disk I/O method you use.\nIt's GETTING TO THE DATA that's the problem, and the channel has to\nbe tied up while you're doing that.\n\n      Any I/O operation that ties up a channel for a long time, is\na potential bottleneck.  As anyone in the tuning game knows, the main\nidea is to eliminate bottlenecks.\n\n\nWHY BLDL IS \"BAD\".\n\n      A PDS directory consists of 256-byte blocks of directory\nentries, each preceded by an 8-byte key.  Each directory entry is\nheaded by its PDS member name, and all directory entries in the\ndirectory are sorted in member name order.  The 8-byte key of each\ndirectory block contains the highest member name in the block.  This\nwould be the name of the last directory entry in the block, because of\nthe member sort order.\n\n      When normal BLDL processing tries to locate a member name within\na PDS directory, it executes a loop of \"Search Key High or Equal\" CCW\ninstructions.  Many linklist libraries contain hundreds of directory\nblocks.  And linklist libraries are concatenated.  That means that if a\nmember is not found, all of the directory blocks in the library must be\nsearched, each with its own \"Search Key\" cycle.  Then the next library\nin the concatenation has to be searched.  Typical \"simple\" directory\nsearches might involve thousands of \"Search Key\" CCW instructions,\ntying up the channels to the libraries' disk devices for a long time.\n\n      These channels could be better used for other I/O purposes in\nthe meantime.  That's why \"BLDL is bad\".\n\n\nWHY ISAM IS \"BAD\".\n\n      ISAM dataset organization consists of Index and Data\ncomponents.  The Index component consists of keys, which tell you how\nto get to the corresponding Data component records on disk, so their\ndata can be retrieved or written.\n\n      One problem with ISAM is that all of the keys in an ISAM Index\ncomponent are accessed using \"Search Key Equal\" CCW loops.  We've\nalready shown that these are tremendous channel hogs.\n\n      VSAM, which is much improved over ISAM, also has Index and Data\ncomponents.  However, VSAM doesn't access its keys with the inefficient\n\"Search Key Equal\" loops, but it uses a method that is far more\nefficient, and far less wasteful of channel time.  VSAM uses a tree\nstructure index.\n\n      Another problem with ISAM is that inserted records are often\nwritten to \"overflow extents\", which can be distant on the disk from\nthe original Index records (or on another disk volume).  There will be\na lot of seek delays.  VSAM doesn't usually have this problem because\nits control intervals are usually split in the middle, and the\ninserted data is near to the old data.\n\n      The moral of the story:  Ditch ISAM and convert to VSAM.\n\n\nWHY LARGE NON-INDEXED VTOCS ARE BAD.\n\n      Non-indexed VTOCs rely heavily on hardware key searches, whether\nyou are trying to obtain an existing dataset, or whether you are trying\nto allocate a new dataset.\n\n      To obtain an existing dataset, the channel program is as\nfollows (and please remember that the search starts from the beginning\nof the VTOC, proceeding sequentially record by record):\n\"Read Count\" CCW (which gets the CCHHR of the next data area), then\n\"Search Key Equals\" on the dataset name, then a TIC back to the\n\"Read Count\", and finally a \"Read Data\".\n\n      Once the data is found, it can be re-accessed easily because\nthe actual CCHHR has been gotten by the last \"Read Count\" instruction.\nGETTING to the data is obviously wasteful.\n\n      The situation is a lot worse if you are allocating a new dataset.\nThe channel program for doing that is very complicated, but here are\na few essential parts of it.\n\n      This channel program has to do two things at once.  First, it\nmust search for the first available Format 0 entry.  For that, it has\nto do a \"Search Key Equal\" on a key of 44 hexzeros.  The search must\nbegin at the beginning of the VTOC and it can't stop at the previous\nhigh water mark for non-trivial data.  Second, the same channel program\nhas to search for the existence of a duplicate dataset name (or a\nduplicate key).  One problem here is that for both searches to be\naccomplished, two turns on the same track are required.  You can't\ndo two different key searches on the same record in one turn.  This\nis very wasteful of channel connect time.\n\n      Finally, if the search for the nonzero key succeeds and there is\na duplicate dataset name, DADSM has to be informed.  But an awful lot\nof time was taken getting to this point.\n\n      Indexed VTOCs don't have these inefficiencies.  The VTOC indexes\nhave tree-structured keys accessible by software, and they heavily\nutilize key compression.  Duplicate dataset conditions are discovered\nfar more efficiently, as are available Format 0 records.\n\n\nCONCLUSION.\n\n      Hardware key searches at the channel program level are very\ninefficient and you should avoid them at all costs.  The job of the\nsystems programmer here, is to recognize which \"normal processes\nof the system\" use these wasteful means to accomplish their ends.\n\n      If there is an alternative, use the alternative.\n\n      I hope this knowledge benefits your shop, and enhances your\npersonal understanding of system processes.  Good luck in everything.\nSee you next month.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9203MA": {"ttr": 9989, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x93!\\x0f\\x01\\x00)\\x9f\\x11G\\x01\\x86\\x01\\x86\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 390, "newlines": 390, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          March 1992\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\n\nA TOUR OF THE WORLD THROUGH FULLSCREEN ZAP - PART I.\n\n      One of the most useful single tools in the public domain, for an\nMVS systems programmer, is the Fullscreen ZAP program, originally from\nUCLA in California.  I have mentioned fullscreen ZAP numerous times in\nthe history of this column, but from my many \"straw polls\" of working\nsystems programmers over the years, I don't think the message has taken\nhold as much as it should.  That's the reason for running this series\nof at least two parts, to explain the uses of this beautiful program\nin some detail.\n\n      Fullscreen ZAP is a nearly complete replacement for IBM's\nutility to change data on disk files, known as AMASPZAP or \"superzap\".\nThe advantage of Fullscreen ZAP is that it can be used for disk\nexploration far more conveniently, allowing you to take a \"Tour of\nyour DASD World\".\n\n      Fullscreen ZAP in its current incarnations, allows a system\nprogrammer, with authorization, to easily view and change any record\non a disk pack.  Without authorization, one can do the same thing for\nmost individual datasets.  In FULLVOL (full volume) mode, ZAP can be\nused to CLIP a pack (change its volume id) while it is online, and to\nview and zap IPL text or any other \"track zero\" data.  VTOC access is\nalso easy and sure.  Unlike its IBM equivalent AMASPZAP or HMASPZAP,\nFullscreen ZAP allows you to see what you're doing every step of the\nway and to find what you're looking for, even if you originally\ndidn't know where it was.\n\n      Fullscreen ZAP has an almost complete tutorial self-contained\nin its one load module, consisting of thirteen help screens.  Any time\nyou need help, you type a question mark \"?\" or \"HELP\".  This will\ninitiate a rotating sequence of displays for all these help screens.\nWhen you've seen what you need, typing a \"U\" will return you to your\nprevious work place.\n\n      Our current series on Fullscreen ZAP will consist of at least\ntwo parts, explaining how to use the program.  We shall include some\n\"war stories\" to show you the kind of tight situations this program\ncould save you from.  Of course, any short series such as ours can't\nteach you everything about a powerful multi-use product.  Our aim is\nsimply to get more people to use Fullscreen ZAP so its benefit for\nthemselves and their installations can be spread around.\n\n\nINSTALLATION AND BEGINNINGS.\n\n      Fullscreen ZAP is a single load module.  It is in the public\ndomain, and its source is readily available on the CBT MVS\nUtilities Tape, available from either NaSPA (414) 423-2420, or SPLA\n(305) 284-6257.  Versions of Fullscreen ZAP source code can be found\non Files 186 or 134 on the CBT Tape (File 186 preferred), and a load\nmodule created from the source of File 134 can be found on File 135.\n\n      Installation consists of one assembly and linkedit of the load\nmodule.  You can even IEBCOPY the load module from File 135 and use\nit immediately.  The source code requires some UCLA macros to assemble\nproperly.  These are contained on the previously mentioned files, or\non the UCLA file, File 149.  The ZAP load module is a TSO command, and\nit is invoked from any library accessible to your TSO session.  See\nFigure 1 for a good overview of ZAP command invocation options.\n\n      Let's see how to begin using the ZAP command.  ZAP can be used to\nexamine, dump, and update in place, any type of sequential, partitioned,\nor direct access dataset.  If the user is authorized, ZAP can similarly\nmanipulate VTOCs, catalogs, VVDSs and components of VSAM datasets.\nZAP is not restricted to load modules only.  But since the updating\nof load modules is probably the most frequent use of IBM's AMASPZAP,\nwe shall begin by showing this use of Fullscreen ZAP, to keep things\nfamiliar.\n\n      In our example, we will look at csect IEBDSCPY of load module\nIEBCOPY which is a member of the cataloged copy of SYS1.LINKLIB on\nour system.  From TSO Ready, we enter:  \"ZAP SYS1.LINKLIB\" .  There\nwill appear a fullscreen display, with the cursor pointing to a command\narea.  From the command area, we enter two commands.  The first is:\n\"MIEBCOPY\" (or \"member IEBCOPY\").  The second is:  \"EIEBDSCPY\"\n(or \"entry point IEBDSCPY\").  The screen resulting from these commands\nis shown in Figure 2.  Decimal 224 bytes in the vicinity of our data\nare displayed in hex and in EBCDIC.\n\n      A wedge-shaped character among the hex data, points to our\ncurrent location.  This is at the beginning of the csect IEBDSCPY,\nor at location +0 within the csect.  We enter the command:  \"+212\"\nin the command area, to relocate us hex 212 further into the data\nrecord of the csect.  This is obviously in the middle of some code.\nWe may disassemble the code by typing the command:  \"DISASM\" in the\ncommand area.  The result is now shown in Figure 3.\n\n      At this point, we may choose to change the data or to leave\nit alone.  To change the data, we have the subcommand \"S\" followed\nby up to eight hex bytes of new data (without an intervening space).\nWe can also \"OR\" the original data data with this new data by using\n\"O\" instead of \"S\".  We can \"AND\" that data using \"A\" instead.  Or we\ncan \"XOR\" the data with our hex operand, by using \"X\" instead.\n\n      If we have decided to keep our changes, we enter the command\n\"ZAP\" in the command area to write our changes in place, back to the\noriginal data block.  We can invoke the \"LOG\" subcommand, to make a\nrecord of what we've done.  To end the ZAP session, we simply type\nthe command \"END\" in the command area.  We may receive a message if\nwe want to keep the log.  If we say YES, the log is written to\nSYSOUT(A).  Otherwise, the log is deleted.  To write the log to a\ndataset, that dataset must be pre-allocated to the ddname ZAPLOG.\nWhen we ZAP a load module, the program writes an IDR zap record to\nthe load module, using our TSO id name to identify the maker of the\nchange.\n\n\nUSING ZAP FOR ANY ARBITRARY DATASET ON A DISK VOLUME.\n\n      To zap a non-cataloged dataset on a disk volume, enter the ZAP\ncommand with the VTOC dataset name, followed by the keyword:  \"VOL()\".\nSee Figure 1 for the format.  For example, if we wanted to look at\nthe copy of SYS1.LINKLIB on the alternate residence volume called\nALTRES, we need merely enter:  \"ZAP SYS1.LINKLIB VOL(ALTRES)\".  Then\nwe proceed as before.\n\n      For non-partitioned datasets, the result of the primary command\nwill get us directly into the first disk record of the dataset.  That\nis also true for partitioned datasets, but the first disk record of a\npartitioned dataset is the first block of the directory, and we need\nthe \"M\" (and possibly \"E\") commands to reach what we want subsequently.\nIn any case, we may position ourselves forward or backward, starting\ninitially from the beginning of the file.  Please bear in mind that our\nuse of the term \"disk record\" or \"record\" really refers to physical\ndata blocks on the disk.  ZAP does not do any logical deblocking.\n\n      Two useful commands to know at this point are \"L\" and \"F\" which\nare \"find\" commands.  These can be used to search forward from the\ncurrent point to find either hex or EBCDIC strings.  The difference\nbetween \"L\" and \"F\" is that \"L\" will not proceed to look past zero\nlength records or \"EOFs\", but \"F\" will look past EOFs.  Both of them\nwill stop at the end of the dataset extents.  To search for a hex\nstring, merely enter the string immediately after L or F with no\nintervening space.  To look for an EBCDIC string, enclose the string\nbetween slashes after the L or F, with no intervening space.  A \"repeat\nfind\" is executed merely by entering the letter \"L\" or \"F\" again, by\nitself.\n\n      Some uses for \"L\" or \"F\":  One obvious one is when you're pointed\nto a Format 4 record which is a VTOC header, and you want to find the\nsubsequent Format 1 record belonging to a dataset on the pack.  Simply\nenter \"F/dataset.name/\" in the command area, and ZAP will get you to\nto proper Format 1 record promptly.  This record can then be changed\nor even zeroed out, if you want.  A second use is if you want to do\na scan-replace for a string, somewhere within the dataset.  Merely\npoint to the beginning of the dataset with the \"P\" command, and then\nuse the \"L\" or \"F\" commands to determine the first location of the\ndesired string to replace.  Enter an \"S\" command to replace the string\nwhen you're there.  Then do a repeat find by executing \"F\" again, and\nso on.\n\n      ZAP does not have to be used to make changes, but since it shows\nyou up to 224 bytes at a time, ZAP is a useful tool for browsing on\ndisk.  Its many commands for finding strings and moving back and forth\nwithin a dataset, can be employed for the purpose of exploration, as\nwell as for changing data.  PF8 is like a \"Page Down\" and PF7 is like a\n\"Page Up\" command within a data block on disk.  \"R\" will advance one\nrecord; \"R+n\" will advance n records from the current record.  \"B\" will\npoint one record back.  And so on.  The tutorial is very helpful to\nshow the power of these commands.\n\n\nFULLVOL .....\n\n      Greg Price of Melbourne, Australia has made ZAP into the Mario\nPerillo of the disk pack, by introducing the FULLVOL parameter at ZAP\ninvocation time.  With the FULLVOL parameter, Fullscreen ZAP allows\nyou to make a \"global tour\" of an entire disk pack, as though the whole\npack were one dataset.\n\n      FULLVOL works as follows.  The user simply enters the name\nof a dataset on a disk pack, possibly with the VOL() keyword parameter\njust to make sure he or she has the volume right.  The ZAP invocation\nis followed by the word, \"FULLVOL\".  For example, to look at the volume\nALTRES, you might enter:  \"ZAP SYS1.LINKLIB VOL(ALTRES) FULLVOL\".\nZAP then alters the DEB of the dataset SYS1.LINKLIB to pretend that\nits extents started at the very beginning of the disk pack and ended\nat the very end of the pack.  Actually, ZAP knows that it is in FULLVOL\nmode.  When in FULLVOL mode, ZAP shows a volume name at the bottom\nof the display, instead of a dataset name that it usually shows there.\n\n      FULLVOL mode has immediate uses.  Record 3 of Track zero of\nCylinder zero is the Disk Id of the volume.  In FULLVOL mode, simply\nenter the subcommand, \"R+2\" and you're there.  See Figure 4 which\ndisplays the disk id of a volume in this way.  The volume id field\nof this physical record can be changed in the usual way, to \"CLIP\"\nthe pack while it is still online.  You can see everything you're doing.\nThen you need merely re-mount the pack, using the new volume id.  It\nmay be necessary to bring the pack offline and then online before\nre-mounting it.\n\n      Another use of FULLVOL mode is to examine IPL text on a volume.\nUsually this text begins in Record 5 of Track zero, if it is present\non a volume.  Often, an IPL failure on a new RES pack is caused by\nlack of replacement of the old IPL text with new IPL text for the\nnew operating system release.  With Fullscreen ZAP in FULLVOL mode\nthere's no guesswork anymore.  Just proceed two records past the\nvolume id, and see what's there.  The eyecatchers for any IPL text\nwill stare you right in the face.\n\n      Another exploitation of FULLVOL mode is to scan-replace strings\nin a dataset that is enqueued DISP=OLD by a long-running job, but\nwhich is not really active.  Merely determine the CCHHR disk location\nof the dataset by using a VTOC map or some other tool, or by exploring\nwith Fullscreen ZAP itself.  Then get into FULLVOL mode on that pack.\nPosition yourself to the Cylinder and Track location of the beginning\nof the dataset (from your exploration knowledge), and then use the\n\"F\" (or \"find\") subcommand over and over, as described above.  This\nworks because you are not really accessing the dataset by its own name.\nYou are accessing it through the name of another dataset on the pack\nthat is not currently being enqueued upon, and which allows you to\nexplore the entire pack at will.  This is slick stuff to know about.\n\n\nTO BE CONTINUED.\n\n      I hope this is enough to whet your appetite and get you started\nexploring the newer versions of Fullscreen ZAP from the CBT Tape.  Next\nmonth, I'll show you some more useful tricks that this tool makes\npossible.  Good Luck.  See you soon.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE 1.  The following is a portion of TSO help for the ZAP command\n           written and elucidated by Jeff Broido.  The portion shown\n           here illustrates how to invoke ZAP from a TSO session and\n           most of the options that can be used at invocation time.\n\n\nFunction\n\n   The ZAP command is used to examine, dump, and update in place any\n   type of sequential, partitioned, or direct access dataset.  If the\n   user is authorized, ZAP can also similarly manipulate VTOCs,\n   catalogs, VVDSs and components of VSAM datasets.\n\n   Any record format is accepted.  This command is the TSO interactive\n   equivalent of IBM's service aid AMASPZAP (otherwise known as\n   IMASPZAP, HMASPZAP or \"Superzap\").\n\nSyntax\n\n     ZAP  'DSNAME'  VOLUME('SERIAL')  CRT  NOT3270  TERSE/VERBOSE\n           BLKSIZE('BLKSIZE')  NOLOG/LOG  ALLOCDSN('DSNTOALLOC')\n           FULLVOL\n\n   Required: 'DSNAME'\n   Defaults:  TERSE, NOLOG\n              No volume implies a cataloged dataset.\n              If you invoke ZAP at a terminal in the 3270 family,\n                 CRT is the default.\n              BLKSIZE defaults to the blocksize of the dataset.\n\n   Note:  Usage of the ALLOCDSN keyword is required only for the\n          'DSNAME' of FORMAT4.DSCB\n\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE 2.  This is a Fullscreen ZAP screen after two subcommands have\n           been entered.  ZAP was originally invoked to get into\n           SYS1.LINKLIB to look at csect IEBDSCPY from load module\n           IEBCOPY.  \"ZAP SYS1.LINKLIB\" was entered from TSO Ready\n           mode.  Then, the subcommand MIEBCOPY (or \"member IEBCOPY\")\n           was entered from the command area of the ZAP screen.\n           Finally, EIEBDSCPY (or \"entry point IEBDSCPY\") was entered\n           in the command area.  The resulting screen is shown below.\n           Note two things.  First, the most recently entered command\n           is re-shown in the open space two lines below the command\n           area.  This command is modifiable and usable if the primary\n           command area is left blank.  Second, notice the wedge that\n           points to the data at offset +0 of the entry point.  This\n           wedge shows the current modifiable area of the data.  A\n           command to the command area can modify up to eight bytes\n           from the location of the wedge, forward.\n\n\n\n                                 Z  A  P\n<command area>\nENTER VALID COMMAND ABOVE OR ? FOR HELP         VERSION=2.3G 25JUL89\nEIEBDSCPY\n\n00000  >90EC D00C  05B0 47F0   B07A C9C5  C2C4 E2C3   \u00a6..}....0.:IEBDSC\u00a6\n00010   D7E8 F1F0  61F1 F361   F8F6 D6E9  F9F8 F0F0   \u00a6PY10/13/86OZ9800\u00a6\n00020   F640 D1C4  D8F1 F1F1   F040 F5F6  F6F5 60F2   \u00a66 JDQ1110 5665-2\u00a6\n00030   F9F5 404D  C35D 40C3   D6D7 E8D9  C9C7 C8E3   \u00a695 (C) COPYRIGHT\u00a6\n00040   40C9 C2D4  40C3 D6D9   D740 F1F9  F8F1 6B40   \u00a6 IBM CORP 1981, \u00a6\n00050   F1F9 F8F3  40D3 C9C3   C5D5 E2C5  C440 D4C1   \u00a61983 LICENSED MA\u00a6\n00060   E3C5 D9C9  C1D3 4060   40D7 D9D6  C7D9 C1D4   \u00a6TERIAL - PROGRAM\u00a6\n00070   40D7 D9D6  D7C5 D9E3   E840 D6C6  40C9 C2D4   \u00a6 PROPERTY OF IBM\u00a6\n00080   5840 B2DA  50D0 418C   41A0 4188  50AD 0008   \u00a6. ..&}.....h&...\u00a6\n00090   18DA 4120  0008 1B77   1B88 1B99  9180 1000   \u00a6.........h.rj...\u00a6\n000A0   4710 B0FE  5851 0004   4865 0000  4155 0002   \u00a6................\u00a6\n000B0   1266 47D0  B0DC 4199   0001 4998  B2EC 4770   \u00a6...}...r...q....\u00a6\n000C0   B0D4 9500  5000 4780   B0CE 41E7  4528 D207   \u00a6.Mn.&......X..K.\u00a6\n\nOFF: 0000 (     0) ADDR: 00000 (       0) DSN: SYS1.LINKLIB\nLEN: 4128 ( 16680) BASE: 00000 (       0) CCHHR: 000E000001 TTR:  007801\n\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE 3.   We are now pointing to location +212 hex, in csect\n            IEBDSCPY of load module IEBCOPY.  Note the location of the\n            wedge, amidst the data area.  We have disassembled\n            the instruction located there.  The result of this\n            disassembly is shown immediately below the hex display.\n            From what we see, we may decide whether to change the data\n            at this location or to merely learn about it.  Also note\n            the \"WHERE\" information at the very bottom of the display,\n            showing in which record within the dataset, we are\n            currently located.\n\n\n\n                                 Z  A  P\n\nENTER VALID COMMAND ABOVE OR ? FOR HELP         VERSION=2.3G 25JUL89\nDISASM\n\n001B0   0001 8970  001E 5070   402C 4111  0001 4118   \u00a6..i...&. .......\u00a6\n001C0   1004 47F0  B106 4111   0001 4660  B106 4160   \u00a6...0.......-...-\u00a6\n001D0   4590 D207  6028 4528   4160 45F0  D207 6028   \u00a6..K.-....-.0K.-.\u00a6\n001E0   4530 4160  4650 D207   6028 4538  4160 4698   \u00a6...-.&K.-....-.q\u00a6\n001F0   D207 6028  4540 4160   4790 D207  6028 4548   \u00a6K.-.. .-..K.-...\u00a6\n00200   4160 47C8  D207 6028   4550 41E0  B29E 90BE   \u00a6.-.HK.-..&.\\....\u00a6\n00210   4178>9220  4B38 9220   4B3A 58F0  43A0 05EF   \u00a6..k...k....0....\u00a6\n00220   9410 4B3A  9601 4B30   5870 B306  4100 00FD   \u00a6m...o...........\u00a6\n00230   8900 0018  1607 4510   B234 0A0A  5010 4D18   \u00a6i...........&.(.\u00a6\n00240   4510 B248  0000 0050   0000 0058  E000 0A04   \u00a6.......&....\\...\u00a6\n00250   12FF 4770  B6B2 9200   4B38 9878  4058 1A87   \u00a6......k...q. ..g\u00a6\n00260   5800 4060  1B80 1818   5080 409C  5080 40A0   \u00a6.. -....&. .&. .\u00a6\n00270   5080 4028  4177 0014   5070 4070  4177 0514   \u00a6&. .....&. .....\u00a6\n                 INSTR: MVI    2872(4),X'20'\nOFF: 0212 (   530) ADDR: 00212 (     530) DSN: SYS1.LINKLIB\nLEN: 4128 ( 16680) BASE: 00000 (       0) CCHHR: 000E000001 TTR:  007801\n\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE 4.  This illustrates a use of Fullscreen ZAP in FULLVOL mode.\n           The record being pointed to is Record 3 of Track 0 which\n           is the Disk Volume Id Standard Label.  Notice that in\n           FULLVOL mode on pack MVS001, the \"dataset name\" is always:\n           VOLUME MVS001, in the \"where\" information at the bottom\n           of the display.\n\n\n\n                                 Z  A  P\n\nENTER VALID COMMAND ABOVE OR ? FOR HELP         VERSION=2.3G 25JUL89\nR+2\n\n00000  >E5D6 D3F1  E5D6 D3F1   D4E5 E2F0  F0F1 4000   \u00a6VOL1VOL1MVS001 .\u00a6\n00010   0000 0401  4040 4040   4040 4040  4040 4040   \u00a6....            \u00a6\n00020   4040 4040  4040 4040   40C3 C2C9  D7D6 4040   \u00a6         CBIPO  \u00a6\n00030   4040 4040  4040 4040   4040 4040  4040 4040   \u00a6                \u00a6\n00040   4040 4040  4040 4040   4040 4040  4040 4040   \u00a6                \u00a6\n00050   4040 4040                                     \u00a6                \u00a6\n\n\n\n\n\nOFF: 0000 (     0) ADDR: 00000 (       0) DSN:   VOLUME MVS001\nLEN: 0054 (    84) BASE: 00000 (       0) CCHHR: 0000000003 TTR:  000003\n\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9204AP": {"ttr": 10241, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x93!\\x0f\\x01\\x00)\\x9f\\x11G\\x01e\\x01e\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 357, "newlines": 357, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          April 1992\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\n\nA TOUR OF THE WORLD THROUGH FULLSCREEN ZAP - PART II.\n\n      Last month, we began to look at a magnificent tool that has been\nunused or under-used by too many systems programmers.  Fullscreen ZAP,\noriginally from UCLA in California, provides a window to actually see\nwhat is on your disk packs.  It is easy to use, and not cumbersome as\nare other such tools.  Fullscreen ZAP is actually something like a\nviewing screen for exploring and examining all disk records.  We can\npicture Fullscreen ZAP as a vehicle to help you on a guided tour of\nyour disk packs.\n\n      Fullscreen ZAP is not restricted to a particular type of\ndataset, but can be used to view all disk data.  VVDS'es, VSAM\ndatasets, VTOCs and other unusual dataset types are all within\nbounds for exploration with Fullscreen ZAP.\n\n      In the previous installment, we explained the fundamentals of\nusing this valuable tool.  Now, we'll try and concentrate on a few\n\"war story\" scenarios, to show how Fullscreen ZAP has saved system\nprogrammers from troublesome situations.\n\n      Fullscreen ZAP is easily obtainable and consists of only one\nload module.  The load module contains its own help screens.  Both\nsource code and a load module for Fullscreen ZAP are found on the CBT\nUtilities Tape, Files 134 or 186 (source) and File 135 (load module).\nThe CBT MVS Utilities Tape can either be obtained from NaSPA (414)\n423-2420, or from SPLA (305) 284-6257, for a handling fee.\n\n      I have supplied Figure 1 to review of some of the workings of\nFullscreen ZAP as a TSO command.  If you have not read last month's\narticle, Figure 1 will serve as a summary for you, describing how\nFullscreen ZAP works in general, and helping you to understand the\n\"war stories\" which follow.\n\n\nCLIPPING A PACK WHILE IT'S ONLINE.\n\n      This story happened to me.  Those of you who ran MVS under VM a\nfew years ago may have remembered the problem.  It seems that ICKDSF,\nIBM's program that is usually used for initializing a disk pack, had a\ndefect when it was run on MVS under VM, or under VM.  Not only would\nICKDSF function improperly and abend while it was running, but it\nwould also overlay the disk id of the volume to be initialized.  The\npack would afterwards be completely unusable.\n\n      This defect was later fixed by a PTF to VM, but when we had the\nproblem, our situation was considerably more urgent.  We were \"going\nlive\" with an XA 2.2.3 system that was replacing MVS/370 at our site.\nIt was 6:30 AM and our deadline was 7 o'clock to come up with XA.\nThe changes were being done using an alternate MVS residence pack\nwhich was running a limited-scope XA with small spool and small page\ndatasets.  The task at hand was to re-use our old paging disk pack,\nto allocate new page datasets on it for XA use.  We tried to initialize\nthe PAGE01 pack, and ran into the problem described above.  We had\nalready passed a \"point of no return\" to MVS/370.  We didn't really\nhave another pack available for production page datasets.  Does this\nsituation sound urgent enough?\n\n      Actually, we were able to come up on time, and with the proper\nconfiguration of disk packs.  I'd like to leave you in suspense as to\nhow we \"initted\" PAGE01, but I won't.  Perhaps it would be a good\nexercise for you to stop here, and try to figure out what you would\nhave done in that situation.\n\n      We proceeded as follows--remember that we were running under VM.\nWe wound up using DDR under VM to copy Cylinder 0 and the VTOC\nCylinder from a work pack, WORK02, to the former \"PAGE01\" pack.  We\ncould have used DFDSS for this too, but we weren't licensed for DFDSS\nat that location.  FDRCOPY hadn't come out as yet, so we didn't have\na quick tool to use under MVS.  We then took the original work pack\noffline and mounted the PAGE01 pack as WORK02.  We allocated one\ndataset on WORK02 and uncataloged it.  Then, under TSO, we got into\nFullscreen ZAP, pointed at the allocated dataset.  We used the new\nFULLVOL parameter, to fool the DEB of the dataset into thinking that\nthe dataset extent covered the entire pack.\n\n      The command we used was:  \"ZAP dataset.name VOL(WORK02)\nFULLVOL\".  This brought us to Track Zero, Record 1 of the pack.  We\nbumped the ZAP program's pointer two records up, using the subcommand\n\"R+2\".  Then we bumped the ZAP pointer eight bytes with the \"+8\"\ncommand, past the \"VOL1VOL1\" string to get to the Volume ID name.\nOur result can be seen in Figure 2.  I changed the disk id volume\nlabel to be \"PAGE01\" with the command, \"SD7C1C7C5F0F1\" to replace the\nWORK02 value with \"PAGE01\" in hex.  Then we took the pack offline\nagain, and brought it back online, mounting it as PAGE01.  In effect,\nwe had \"initted\" the pack from another pack, and gotten the thing to\nwork.\n\n      I left out the fact that our pack had a VTOC index, named\nSYS1.VTOCIX.WORK02.  A few commands under Fullscreen ZAP, and this\ndataset name was changed to SYS1.VTOCIX.PAGE01.  Simple?  Not quite.\nBut here's how.\n\n      You get to the VTOC header (the Format 4 DSCB) by entering the\ncommand VTOCDS4, while in FULLVOL mode.  Then, you find the appropriate\nFormat 1 DSCB with a \"find\" on the dataset name.  In this case,\n\"F/SYS1.VTOCIX.W/\" would be sufficient.  A \"+C\" command to advance\nthe current pointer 12 bytes forward, would get us to the data needing\nchange.  Then a hex replace, SD7C1C7C5F0F1, as before, would change\nthe VTOC name for the dataset name to SYS1.VTOCIX.PAGE01.\n\n      Our VTOC was not really indexed, but if it were, you'd have to\nzap the Format 4 DSCB in the correct byte to make the VTOC\nnon-indexed.  Or, you could go directly into the index dataset itself\n(its Format 1 record would tell you its CCHHR, and a ZAP command could\ngo right to it.)  Then you could replace the SYS1.VTOCIX.WORK02 name\nas before, using the \"F\" command to find, and the \"S\" command to\nreplace.  This would still leave the pack with an indexed VTOC.\n\n      If you wouldn't mind making your pack non-indexed temporarily,\nyou could make the VTOC non-indexed by zapping the Format 4, and you\nwon't really have a freespace problem if there's only one dataset on\nthe pack (you can delete it later under ISPF or with IEHPROGM).  But\nif you did have a freespace problem, you could recover all the\nfreespace by turning on the DIRF bit in the Format 4 DSCB and\nallocating a new dataset on the pack.  The VTOC convert routine,\ntriggered by MVS allocation because the DIRF bit was on, would clean\nup all freespace problems.  To find out all the correct displacements\nin the Format 4 DSCB for these maneuvers, look in the MVS Debugging\nGuide (the \"Control Block Book\") under DSCB4, for the correct\ndisplacements from +2C after the beginning of the record.\n\n      With some practice using Fullscreen ZAP, especially in FULLVOL\nmode, this stuff will become very easy after a while, generally in\nthe category of \"no sweat\"!  You just have to be very careful that\nyou did it right, and you should recheck yourself several times.\n\n\nMOVING BDAM DATASETS FROM 3380 TO 3390 DISK PACKS.\n\n      BDAM dataset organization under MVS is basically the\nconstruction of \"pigeonhole records\" to store data.  It is important\nin BDAM (or direct access organization, DSORG=DA) to determine where\neach pigeonhole record is.  There are two common methods used by BDAM\napplication programs to locate a specific record.  One way is to use a\nrecord's \"relative block\", or its block count relative to the\nbeginning of the dataset.  The other way is to use the \"relative TTR\",\nwhich locates the record by determining the relative track\ndisplacement from the beginning of the dataset, and the relative\nrecord count from the beginning of that track.\n\n      If you think about it, the \"relative TTR\" method has a greater\ndependency on the geometry of the disk tracks.  Relative TTR always\nassumes that there is a certain number of records on each relative\ntrack.  If the dataset is moved to another disk device, the number\nof records on each track must remain the same on the new device as on\nthe old one.\n\n      This may cause a problem if you are moving the dataset from 3380\ndevices to 3390's.  3390 devices have a larger track capacity, and\nusually, more records from a file can fit on a 3390 track than on a\n3380 track.  A problem can arise when moving a BDAM dataset, if you\ndon't know how the application program handles it.  If the application\nprogram uses the relative block method, the maximum number of records\nper track has to be packed on each track of the new device.  That will\nbe the only way that the \"relative block\" location method can find the\ncorrect record.  On the other hand, if the application program uses\nthe relative TTR algorithm in BDAM, exactly the same number of records\nmust be present on each 3390 track as on the 3380 track, and not more.\nIf there is extra room on the 3390 track, the extra room must not be\nused.\n\n      DFDSS is \"intelligent\" enough to know that if it is moving a\nBDAM dataset (DSORG=DA), it will assume the \"relative TTR\" algorithm\nand will preserve the number of records per track on the new device,\neven if there is extra room on the new track.  You must give DFDSS a\nparameter of \"RELBLOCK\" for it to assume the other, \"relative block\"\nalgorithm.\n\n      Now suppose you are a system programmer and you are not sure\nwhat you did after a dataset move to 3390.  You can calculate the\nmaximum number of those blocks which should fit into the 3390 track.\nBut with Fullscreen ZAP, you can look at each track directly.  The\nCCHHR field at the bottom of the screen will indicate precisely when\nyou have switched to the next track, after advancing a record at a\ntime (using the \"R\" command).  An even simpler method involves the\n\"T\" command (to advance to the next track) and the \"B\" command (to\ngo back one record).  Simply start somewhere within the dataset and\nissue a \"T\" command to go to the next track.  Then issue a \"B\" command\nto go back one record.  The record count part of the CCHHR number will\nshow you how many records were in the track before.  This is simple,\nand it will show you how to get around your problem, if the application\nprogram didn't work the first time after the dataset move.  If you\nwere wrong the first time, you can move the dataset again, using the\nother parameter in DFDSS.  But the main point is that Fullscreen ZAP\nshows you exactly where you stand, and you can see what DFDSS did.\n\n\nTO CONCLUDE.\n\n      I hope I have whetted your appetite to use Fullscreen ZAP for\nyourself, and maybe you've learned a few other things from this\nmonth's discussion.  Before closing, I want to mention that there\nis space for installation-specific authorization code to be inserted\nin the Fullscreen ZAP source code.  Also, FULLVOL will not work if\nthe ZAP command is not running authorized.  (You have to be authorized\nto play with the DEB.)  This may help you to use Fullscreen ZAP, as\nthe \"certified system doctor\" in your installation, and you can\nproperly withhold its use from other people.\n\n      As you use Fullscreen ZAP more for disk exploration, you will\nrapidly gain a greater appreciation of the workings of MVS at your\ninstallation, and of its controls.  Good luck in all your endeavors.\nSee you next month.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.  This is part of an elucidation of Fullscreen ZAP that was\n           written by my friend Jeff Broido.  I am including as much\n           of it as there is room for.  Fullscreen ZAP is a TSO\n           command.\n\n\nFunction\n\n   The ZAP command is used to examine, dump, and update in place any\n   type of sequential, partitioned, or direct access dataset.  If the\n   user is authorized, ZAP can also similarly manipulate VTOCs,\n   catalogs, VVDSs and components of VSAM datasets.\n\n   Any record format is accepted.  This command is the TSO interactive\n   equivalent of IBM's service aid AMASPZAP (otherwise known as\n   IMASPZAP, HMASPZAP or \"Superzap\").\n\nSyntax\n\n     ZAP  'DSNAME'  VOLUME('SERIAL')  CRT  NOT3270  TERSE/VERBOSE\n           BLKSIZE('BLKSIZE')  NOLOG/LOG  ALLOCDSN('DSNTOALLOC')\n           FULLVOL\n\n   Required: 'DSNAME'\n   Defaults:  TERSE, NOLOG\n              No volume implies a cataloged dataset.\n              If you invoke ZAP at a terminal in the 3270 family,\n                 CRT is the default.\n              BLKSIZE defaults to the blocksize of the dataset.\n\n   Note:  Usage of the ALLOCDSN keyword is required only for the\n          'DSNAME' of FORMAT4.DSCB, which you use to get to a VTOC.\n\nOperands\n\n  'DSNAME' - The name of the dataset to be \"zapped\".  Use the\n             pseudo-dataset name of FORMAT4.DSCB to ZAP a VTOC.\n\n  VOLUME   - The volume serial on which the dataset resides.  The volume\n             must be online and mounted.\n\n  BLKSIZE  - If the dataset to be \"zapped\" has blocks larger than the\n             blocksize value in the VTOC, use this parameter to specify\n             an overriding value.\n\n  CRT      - Tells ZAP to display four lines on either side of the\n             current position in the file.\n\n  NOT3270  - Inhibits use of full screen display mode on a 3270-type\n             terminal and implies line by line display mode.\n\n  LOG      - Tells ZAP to log to SYSOUT all changes that ZAP makes to\n             the file being updated.  Note that ZAP may be put in the\n             logging state after it has been entered by use of the LOG\n             command, and that use of any of the dump commands causes\n             ZAP to automatically enter the logging state.  The log goes\n             to SYSOUT(A) unless DDNAME 'ZAPLOG' is pre-allocated to\n             wherever you want it to go.\n\n  NOLOG    - Suppress the hardcopy log.\n\n  ALLOCDSN - Specifies the name of a cataloged dataset on the same\n             volume as the one to be \"zapped\".  ZAP will allocate this\n             dataset, but open the one given in the first operand.\n             Usage of this keyword is required for the privileged\n             operation of \"zapping\" the VTOC, in which case specify the\n             pseudo-dataset name of FORMAT4.DSCB as the first operand.\n\n  TERSE    - Tells ZAP to omit the positional 'WHERE' information when\n             displaying a portion of the file unless you are in 3270\n             mode, in which case it is always displayed.  The opposite\n             of TERSE is VERBOSE.\n\n  VERBOSE  - Tells ZAP to give the positional 'WHERE' information when\n             displaying a portion of the file.  The opposite of VERBOSE\n             is TERSE.\n\n  FULLVOL  - Tells ZAP not to look at the specific dataset, but to\n             look at the entire volume that dataset is on.  ZAP will\n             initially show you Track 0, Record 1 of the volume your\n             dataset is on.\n\nSubcommands\n\n     VERBOSE, NOT3270, YES3270, WHATMEM, LASTDS1, EBCDIC, ITRACE,\n     DISASM, LINE80, LINE40, NODEF, ASCII, FLOAT, ZCODE, WHERE, TERSE,\n     EJECT, DUMPF, DUMPT, DISPC, DISPK, DISPD, BASE, DUMP, NOTE LAST,\n     HELP, NAME, IDEF, SAVE, ZSYM, ASM, CRT, LOG, ZAP, END, SET, ABS,\n     DO, L, S, O, X, N, F, >, <, M, E, B, D, V, T, R, P, U, =, ?, H, #,\n     W, %, VTOCDS4\n\n     When in ZAP, enter HELP for more details on subcommand syntax.\n\n\nHere's how to get internal help for ZAP.  To get it online, type ?\nor HELP when you enter ZAP.  To go back to where you were, type U.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE 2.  This illustrates a use of Fullscreen ZAP in FULLVOL mode.\n           The record being pointed to is Record 3 of Track 0 which\n           is the Disk Volume Id Standard Label.  Notice that in\n           FULLVOL mode on pack WORK02, the \"dataset name\" is always:\n           VOLUME WORK02, in the \"where\" information at the bottom\n           of the display.  The command in the command area, will\n           change the volume id WORK02 to the volume id PAGE01.\n           Note the wedge-shaped character which is the current\n           byte pointer, and which indicates the starting byte to\n           be changed.\n\n\n\n                                 Z  A  P\nSD7C1C7C5F0F1\nENTER VALID COMMAND ABOVE OR ? FOR HELP         VERSION=2.3G 25JUL89\n\n\n00000   E5D6 D3F1  E5D6 D3F1  >E6D6 D9D2  F0F2 4000   \u00a6VOL1VOL1WORK02 .\u00a6\n00010   0000 0401  4040 4040   4040 4040  4040 4040   \u00a6....            \u00a6\n00020   4040 4040  4040 4040   40C3 C2C9  D7D6 4040   \u00a6         CBIPO  \u00a6\n00030   4040 4040  4040 4040   4040 4040  4040 4040   \u00a6                \u00a6\n00040   4040 4040  4040 4040   4040 4040  4040 4040   \u00a6                \u00a6\n00050   4040 4040                                     \u00a6                \u00a6\n\n\n\n\n\n\n\n\nOFF: 0000 (     0) ADDR: 00000 (       0) DSN:   VOLUME WORK02\nLEN: 0054 (    84) BASE: 00000 (       0) CCHHR: 0000000003 TTR:  000003\n\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9205MY": {"ttr": 10248, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x93!\\x0f\\x01\\x00)\\x9f\\x11G\\x00\\xd7\\x00\\xd7\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 215, "newlines": 215, "modlines": 0, "user": "WSBG"}, "text": "\n                MVS TOOLS AND TRICKS OF THE TRADE\n                           May 1992\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\n\nMAKING THE MOST OF YOUR TOOLS.\n\n      I think it's about time that I do one of those \"philosophical\"\npieces again.  I just came back from SHARE, and Dr. Robert Rannie of\nNorthern Illinois University, one of the true \"old timers\" in this\nfield, gave a gem of a talk on how he trains student systems\nprogrammers in the art of debugging.  That's not what I'm going to\nspeak about here, but there was a thread of horse sense through his\nmarvelous session, that I feel obligated to borrow from, heavily.\n\n      Professor Rannie emphasized what all good teachers do:\nfundamentals, fundamentals, and more fundamentals.  \"For debugging,\nlook at the evidence of the problem, not in your source, but in the\nDUMP!  YOU think you wrote perfect source code, but the machine didn't\nthink so.\"  \"Memorize the most common op codes, so you can follow the\nprogram execution in the dump.\"  \"Use PRINT GEN, not NOGEN, so you can\nsee what the macro expansions did.\"  \"Don't ask for help unless you've\ndone a preliminary analysis, which you'd better learn how to do!\"\n\"Ask questions.  There's no such thing as a dumb question.  If you ask\nquestions, you'll get to think of answers.\"\n\n      I need this stuff myself, and I've been around for a while.\nOne can never get enough of this kind of prodding.  That's what makes\ngood people out of ordinary people, and masters out of good people.\n\n      Our current subject will be on fundamentals, too.  Repetition\nis the mother of skill, and we can never have enough.  Our subject\nis:  \"How can we use our existing tools better\".\n\n      Who am I to talk?  Am I perfect?  Most definitely not!  But I\nlike to observe people and to visit many other shops.  Maybe some of\nthe things I've noticed in my travels, could help ME to be a better\nsystems programmer if I wrote them down.  You can decide if they just\npossibly might help you too.\n\n\nPATTERNS AND WORKING HABITS.\n\n      When I watch somebody else work, I'm struck by one observation\nmore than anything else.  There are some actions he or she can do much\nbetter than I can.  Those skills make me feel utterly inferior to\nthe person I'm watching.  And there are other things that I can do far\nbetter than they can.  I feel like the genius, when it comes to these\nskills.  This has been my observation with almost any other person of\nsome experience level.  I have never found a practicing systems\nprogrammer who can't overwhelm me in some skill, nor I them, in some\nother skill.\n\n      It just goes to show you that there's a lot to learn out there.\nThe trick is to find out how each of us can do a bit better in learning\nmore.  I think it has to do with our states of mind.\n\n      First, let each of us remember how it was when we started in\nthis field.  We all felt overwhelmed and uncomfortable.  We started\nlearning one thing and then another, hoping our status toward this\nwork would somehow stabilize.  When things finally did calm down, and\nwe felt we had a handle on some part of the work, what happened?\nThat's a crucial point in time.\n\n      Just then, there's a tendency to fall into a pattern and\ncomfortably do our everyday work.  I call it a rut, but it's not all\nnegative.  We have to drive our newly learned skills into ourselves\nthrough repetition.  The question is, how long should this \"comfort\nzone\" last?  Sometimes that's not our choice.  There's a new project to\ndo, and we have to learn some new skills.  Again we feel uncomfortable\nuntil we adjust to the new load, and learn enough to get by and to feel\ncomfortable again.\n\n      After a while for many of us, things stabilize to the point that\nwe're not forced to do anything fundamentally new for quite a long\ninterval.  This is the time that makes a difference.  We can either\nstagnate, or keep stretching ourselves and growing further.  I know\nthat most people, including myself, do varying amounts of both.\n\n\nCATALYSTS FOR GROWTH.\n\n      It often takes a shock to get us moving in the direction of\nself-growth.  Various things have pushed me in my career.  Oftentimes\nI saw someone else ahead of me in a new skill, so I felt obligated\nto learn that skill.  Sometimes I felt myself inadequate in an area of\nthe work, such as debugging, so I forced myself to learn that area\nbetter.  There were times when I was afraid for the future, so I felt\nthe need to re-train in an area which was indicated by new trends.\nFinally, there was exposure to a lot of new code, such as when I found\nout about public domain software contributions, or about some new\nsoftware tool that our installation bought.  I wanted to expand into\nthe new area, and I did.\n\n      Everybody has experienced these forces at one time or another.\nWhat I want to expose here is a new thing altogether, something that\nvery few people take action upon.  It is different than all the other\nfactors we mentioned before.  But with this, we will be able to attain\nlevels of mastery that are impossible if we just let things float and\nlet circumstances carry us along.  If this is made a habit, it will\ncarry us very far.\n\n      What I want to talk about is \"thoroughness of mastery\", or\nmaking the most of tools we already have.  How long has it been since\nyou studied the ENTIRE help member of some TSO command, or an entire\nsection of a manual to master ALL the capabilities of one software\ntool?  Do you know EVERYTHING that can be done with IEBGENER, or\nIEBUPDTE, or IEHPROGM?  Do you know ALL of their control cards?  Have\nyou tried experiments with some of their more uncommonly used\ncapabilities?  If you haven't, you'd be surprised what lies next to\nyour own front door.  If you have, and the possibilities have started\nto excite you, there's the potential never to be bored again, and to\nbe able to accomplish a lot more than you've ever dreamed possible!\n\n\nEXAMPLES, CON AND PRO.\n\n      Most professionals use quality equipment.  But what distinguishes\na master, is mastery over his own equipment.  It helps if the equipment\nis good, but it helps more, the better the user is able to use it.\n\n      I once was riding on the New York subway, when I saw an unassuming\nfellow holding a black Nikon camera with a motor drive.  Immediately, I\nwent over to him and said, \"you're a professional\".  He was very\nembarrassed, but he admitted to it.  Professional \"candid\" photographers\ndon't like to be noticed.  But the equipment he was using, and the way\nhe was using it, gave him away to me.\n\n      Some of the great masters of photography have used very simple\nequipment, such as a Rolleiflex camera with a fixed lens.  Many of\nthe most famous photographs of all time were taken with simple cameras\nand lenses.  At the other extreme, I know of a man who had a whole\ncloset-full of the best Nikon cameras and lenses, and who hardly ever\ntook a picture.\n\n      Some of us complain that \"our shops are cheap.  They never buy\ntools for us.\"  Others, who work for big shops with lots of tools,\ndon't make the effort to conquer parts of their abundance.  Most of us\nare at some middle ground, in between.  That means there's room for\nall of us to improve, a lot more than we think!\n\n\nSOME EXAMPLES OF DIFFERENT SHOPS.\n\n      I've worked at some MVS shops that had VM established there\npreviously, and whose MVS systems were maintained by slightly\nretrained VM systems programmers.  The most striking thing about the\nworking methods of these people, was that they used vanilla IBM tools\nalmost exclusively.  They never heard of a CBT Utilities Tape, or a\nJES2 Mods Tape.  Before making fun of them however, I was quick to\nnotice that they knew much more about those IBM tools than I did.  It\nusually turned out that they spent much more time looking at the\nutility manual than I did.  I was embarrassed, and I learned\nsomething.  For me, it was an improvement, and a lesson in general.\n\n      You see, these people were forced by lack of MVS exposure, to\ntry and make do with what IBM gave them.  And they did remarkably well.\n\n      Then there's the shop which purchased an expensive monitor for\nits systems, and all kinds of add-ons to MVS.  They have 15 systems\nprogrammers.  If you'd do a survey of their people to find out how\nmany of them knew ten percent of the commands in OMEGAMON, or whatever\nmonitor they had, it'd be surprising if three out of the fifteen could\npass that test.  With their monitors and all, could they actually shoot\na tough system problem?  Maybe one or two of them could.  Other big\nshops do better than this.  They really focus on in-house training\nand give incentives for knowledge among their people.  These shops\nhave a higher percentage of their staff who know what's going on,\nand can help the shop in a tight spot.\n\n      The true measure of the programmers in all of these situations\nis:  How well can they handle the tools they currently have?\n\n\nHOW ABOUT YOU?\n\n      Where do you stand?  Wherever it is, you can do something about\nyour own situation.  There is always the opportunity to learn\nsomething new in your own environment.  When you ask a question, your\nmind starts to focus on looking for an answer.  If you ask the\nquestion, \"how much can I do with IEBGENER?\" you'll soon find yourself\nlooking at IEBGENER, trying to discover all you can about it.\nEveryone has IEBGENER.  Everyone has TSO.  Everyone has SMP.  And so\nyou never have to be bored.\n\n      I have always pushed the idea that people should get some of the\nfree tools.  Some cynicism at many people's response to this has\ncaused me to alter my plea to:  \"Whatever tools you have, learn to\nuse them.  Over and over.  Better and better.  You'll surprise yourself\nif you are patient, stick to an organized schedule, and keep working\nat it.\"\n\n      Turn introspective.  Discover the wealth that you already have.\nThen branch out later, once you have gotten mastery in an area.  This\nis a good exercise, even to do it for only one tool, for one month.\n\n      Anyone who takes this seriously, will discover a lot more joy\nin this work.  It's nice to get up in the morning, all juiced up,\nwith the prospect of discovering something new for yourself at work\ntoday.  No one is so busy, all the time, that he (or she) can't do\nthis for five or ten minutes on some days.  Even if you're a strict\nnine-to-fiver (and there are some of those in our field who are very\ngood), there is still ten minutes of your time to fit in for this,\nif you look for it.\n\n      So think about it.  No \"Tools and Tricks\" column is worth much,\nto a person who won't use the tools.  I think I owe you at least one\ncolumn to devote to this \"digression\".  Good luck.  Use your tools\nwell.  I'll see you next month.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9206JN": {"ttr": 10497, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x93!\\x0f\\x01\\x00)\\x9f\\x11G\\x01\\x17\\x01\\x17\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 279, "newlines": 279, "modlines": 0, "user": "WSBG"}, "text": "\n                MVS TOOLS AND TRICKS OF THE TRADE\n                           June 1992\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\n\nPUBLIC SOFTWARE TAPES REVISITED.\n\n      It has been a long time since we did an overview of public\ndomain software tapes and stressed their immense value to a practicing\nMVS systems programmer.  Some of these tapes have been improved\nthrough significant new contributions in the past year or two.  I can\npersonally testify that the CBT MVS Utilities Tape has come a great\ndistance in the past two years.\n\n      Deemphasizing the multiple ways in which the public tapes can\nhelp your shop, I'd like to concentrate this month on the many more\nways they can help you personally, in your growth of understanding\nand breadth of system knowledge.  I'd like to say a few words on how\nit's possible to use these marvelous materials to your own best\npersonal advantage.  Of course, your shop will undoubtedly benefit,\nbut let's concentrate on you first, for now.\n\n\nLEARNING BY CONNECTING TO OTHERS.\n\n      A new user of a public tape such as the CBT MVS Tape, is first\nimpressed by its size.  The current CBT Tape, Version 329 as of this\nwriting, almost fills a 2400 foot tape reel.  The next thing one\nnotices is the fact that nearly every software contribution is\naccompanied by a name and an address.  Inside each individual\ncontribution file, there is usually also a phone number.  In my\nexperience, contributors to these tapes are gratified that their\nefforts are being noticed by others.  Having called hundreds of\ncontributors over many years, I can accurately say that none of them\nwas ever impolite to me in any way.  I have made many friends among\nthem.  This can happen to you too.\n\n      Then there's the knowledge.  That's really the bottom line.\nYou can find all sorts of programs that do wonders to utilize various\nfacilities of the MVS operating system and data management.  Nearly\nall of them have source code.  You are free to study them, try them,\nand fix them.  It's like bringing a ten-year-old kid into \"Toys R Us\"\nand telling him or her:  \"It's all for nothing.  Just take anything\nyou want off the shelf and put it together.  Then you can keep it and\nit's yours!\"\n\n      A lot of system programmers have done a lot of work for their\nown installations.  However, people employed by large companies which\nare not in the software business, can't enjoy having feedback from\na group of users outside their company walls.  But with a contribution\nto a large tape, they can get such satisfaction and conversely, they\ncan also gain access to work from hundreds of other people.\n\n      If your shop doesn't want to buy software tools for you, you\nneedn't despair and make a fuss about it.  Access to these tapes will\ngive you an enormous pool of software tools of every description.  AND\nyou can usually see their source code, to learn how the work is done.\nIn some areas, certain utilities on these tapes are better than any\nvendor software that is currently available.\n\n\nWHAT TAPES ARE THERE?\n\n      I don't know about all the tapes out there, but I know about\nquite a few.  In Figure 1, there's a pretty good collection of names,\naddresses and phone numbers to start with.  These tapes will keep you\nbusy for quite some time.\n\n      The \"granddaddy\" of MVS software tapes is the CBT MVS Tape,\nstarted by Arnold Casinghino and built by him for 15 years.  I am the\ncurrent editor of the CBT Tape, having taken it over from Arnie.  I\n\"inherited\" quite a bundle of material from him.  In terms of general\ncoverage of MVS needs, the CBT MVS Tape is by far the most\ncomprehensive single source.  The CBT Tape has 472 files, many of\nwhich have large collections of tools within them.  Getting a current\nCBT Tape should be the highest priority for every MVS systems\nprogrammer.\n\n      I don't have space in this article to detail the relative merits\nof all the tapes mentioned in Figure 1.  The list is there for you to\nexplore.  Of special note are the JES2 Share Tape and the NASPA VIP\nMVS Tape.\n\n      I have heard of some tapes from \"abroad\", such as the UK GUIDE\nTape, which aren't readily available in the United States.  I would\nlike to hear from any readers outside the United States who have such\na user-contributed MVS software collection available to them.  Some of\nthe most useful programs I know, have originated from countries other\nthan the United States.  I once was the beneficiary, through a NasTEC\nconference, of a user exit commented in Spanish!  Thanks, Jhony.  Many\nof my good tools come from Australia.  Thanks, Greg and friends.\nLet's do some more of this!  Thanks to all of you.\n\n\nUSING THE TAPES TO IMPROVE YOUR KNOWLEDGE.\n\n      There are several ways to \"break into\" the tapes for your own\nknowledge.  One way is to print out the tape documentation, put it into\na binder, and leaf through it, looking for things to install that seem\ninteresting to you.  This is good general practice.  On the CBT Tape\n(where I'm the editor) I purposely added a section describing what to\ndo first.  That section is part of the CBT Tape documentation.\n\n      I remember taking the documentation file from my first CBT Tape,\nin a binder, to the beach.  Among our \"social friends\", upon seeing\nthe binder, the nearly universal comment was:  \"Computers.  Yecch.\nWhy don't you read a good novel, or at least a newspaper.\"  (That was\nbefore PC's became really popular.)  I have courage in my convictions.\nI told them the \"Toys R Us\" story.  Then I ignored them.  I figured I\nprobably got more benefit from my reading than they did from theirs\nthat day.\n\n      Another way of getting started is to have a problem at work.\nSometimes your boss will come and tell you to write a program or an\nexit to solve the problem.  If you have a CBT Tape or a JES2 Tape\naround, you may not have to write the program from scratch, but you\ncan save a lot of time by lifting someone else's code.  There are some\n\"purists\" out there who might think it's more \"honorable\" to write all\nyour own code.  But practically speaking, that's not what your\ncompanies pay you for, unless there's no other way.  Using (and\nimproving) someone else's wheel takes less time, gets the solution to\nthe users more quickly, and costs the company less pay.  It's also a\ngood way to become more familiar with the tape.  That happens by\nitself once you're looking in it for something that might help with\nyour problem.  You just happen to notice other stuff too.\n\n       There are some side rewards to all this exploring.  Very\nimportant, is the personal experience you acquire as a software\nevaluator.  It is possible to become a valued beta tester for one or\nmore software houses, especially when you develop sharpness at the\nprocess from long practice with free materials.  This gives you\nexposure to more vendor software than you or your company can normally\nafford.  You might also get the opportunity to make some extra money\nin a side job, doing this.  A little extra work often yields a lot of\nextra dividends.\n\n      Then finally, there is benefit to be gained from the pure study\nof code.  Hard work yields knowledge, experience, and ultimate results.\nMost of the good MVS people whom I know have studied other people's\ncode a lot, besides writing their own.  Haven't you ever wondered how\na certain program could achieve some marvelous result?  Haven't you\never asked, \"I wish I could see the see the source code\"?  Well, now\nyou can.  On the public software tapes, almost all of the source code\nis available.\n\n\nSPREADING THE WORD.\n\n      There are two schools of thought to this.  I've seen some\n\"system doctors\" who look at a problem, \"do some magic\", and keep\nthe solution to themselves.  I myself do not subscribe to that\napproach.  Early in my career, I was blessed with an especially fine\nfriend and mentor.  I'd call him every day for several years after\nI was working on my own, and I'd run all my problems of the day\npast him.  It paid off.  Even if I'd solved a problem satisfactorily\nwithout his help, he would invariably add a lot of extra insight into\nthe issue.  My knowledge became much more rounded because of his\ninput.\n\n      Later, when my circle of knowledgeable friends became wider, I\ndiscovered that each of them was able to provide a unique \"new view\"\nto any situation.  Different people would look at an issue from\ndifferent angles.  Each person's opinion would complement the other\nperson's view, and would shed new light for me, the onlooker.  I don't\nknow where I would have been today, without years of these\nconversations behind me.\n\n      Consequently, I try and help other people by applying some of my\nown experiences to their circumstances.  Hearing other people's\nproblems gives you broader insight into your own, while it is also\nhelping them.  You earn yourself new friends, and lay a foundation of\nhelpers for your own future.  Every person in this world is valuable in\nsome way.  You never know when the help you gave them, will come back\nto you later at some unexpected time.  I'm always going to be better\nand more experienced in some way, by helping someone else.\n\n      The public domain tapes are an extension to this latter\napproach.  And they work especially well if you take the time to\ncall the contributor of the tape file you're using.  Most contributors\nfeel flattered and are very helpful when they're called.  You'll learn\na lot and make new friends among them for the future.\n\n\nIN SUMMARY.\n\n      Finishing this discussion is for each of you to do on your own.\nI'd say, the first step is to order one or more of the tapes.  The\naddresses for inquiry are in Figure 1.  Follow the \"yellow brick\nroad\" we've laid out here, and you'll know more about the benefits of\nthis process than I could ever tell you.\n\n      Good luck in all your endeavors.  See you next month.\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFIGURE 1.   This is a list of addresses and phone numbers you can call\n            to acquire some of the available public tapes.  Most of\n            the tapes have no restrictions as to who can get them.\n            Once you've acquired some of these tapes, you can make\n            copies and distribute them to your friends.  That divides\n            the handling costs.  Remember that many of the tapes are\n            updated often.  You can split the ordering among several\n            installations.  When a new version comes out, you can all\n            obtain copies.  Several NaSPA Chapters maintain tape\n            collections and distribute tapes at their meetings.  It\n            pays to go to the chapter meetings, or to send someone\n            there.\n\n\n\n  1.  THE CBT MVS UTILITIES TAPE - This tape is updated often.  Try\n            to make sure you have the latest one.  And save the older\n            ones too, so you're sure you have source for everything\n            you've installed.  You can order the CBT Tape from:\n\n                  NaSPA\n                  4811 S. 76th Street\n                  Suite 210\n                  Milwaukee, WI 53220-4362\n                  (414) 423-2420\n\n            Or from:\n\n                  Fred Robinson\n                  Share Program Library Agency  (S.P.L.A)\n                  University of Miami\n                  146 Unger Building\n                  1365 Memorial Drive\n                  Coral Gables, FL  33124\n                  (305) 284-6257\n\n            This address is very important.  You can order most\n            of the SHARE-affiliated tapes from S.P.L.A.\n\n  2.  THE JES2 SHARE TAPE  -  Order the JES2 Share Tape from:\n\n                  Jack Schudel\n                  Northeast Regional Data Center (NERDC)\n                  Room 233 Space Sciences Research Building\n                  University of Florida\n                  Gainesville, FL 32611\n                  (904) 392-4601\n\n  3.  THE JES3 SHARE/GUIDE TAPE  -  Order the JES3 Tape from:\n\n                  Alan Field\n                  Wetterau Inc.\n                  345 Dunn Road\n                  Florissant, MO 63031-7995\n                  (314) 839-7040\n\n  4.  THE NASPA VIP TAPES  -  Order NaSPA's tapes from NaSPA\n            (address above).\n\n  5.  THE SHARE MVS TAPE  -  You can order the MVS SHARE Tape from:\n\n                  Fred Robinson\n                  SPLA - University of Miami\n                  Unger Building\n                  1365 Memorial Drive\n                  Coral Gables, FL 33124\n                  (305) 284-6257\n\n  6.  THE L.A. MVS USERS GROUP TAPE  -  The administrator of the\n            L.A. MVS Users Group tape is:\n\n                  Tom Beuthin\n                  (310) 812-4421\n\n  7.  THE CICS SHARE TAPE and the PL/I SHARE TAPE - These can be\n            obtained from S.P.L.A.  (address above).\n\nBe ambitious.  Good luck in your efforts.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9207JL": {"ttr": 10502, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x93!\\x0f\\x01\\x00)\\x9f\\x11G\\x00\\xd3\\x00\\xd3\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 211, "newlines": 211, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           July 1992\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\n\nSOME ASSEMBLER THOUGHTS - THE NEW HIGH LEVEL ASSEMBLER - PART I.\n\n      Sometimes you really can change the world.  It's important not\nto be cynical about this.  Or even if you are cynical, don't let that\nstop you from taking action and doing something about a problem.\n\n      Last week, I was pleasantly shocked by IBM's announcement number\n292-244 for their new High Level Assembler, dubbed \"HLASM\" for short.\nI had nearly given up hope.  This new assembler, which is implemented\nfor MVS, VM, and VSE, claims to incorporate most features of the SLAC\nMods to Assembler H and other enhancements suggested by users (see this\ncolumn from the February 1990 issue).  It seems that my 250 phone calls\nand many other people's efforts:  those of the SHARE Assembler\nCommittee, the SHARE Languages Project, the \"Assembler Indignation\nProject\" at GUIDE, SHARE Europe, G.U.I.D.E. Europe and the IBM\nrepresentatives to these organizations, were not in vain after all.\nIBM's announcement 292-244 acknowledges all of these contributors as\nbeing input to its decision to open up Assembler enhancement.\n\n      John Ehrman, an IBM'er who was pivotal in this effort, has told\nme that the keywords most responsible for achieving this change, from\nIBM inertia to IBM progress, could be summarized as \"diligence\" and\n\"persistence\" on the part of the IBM user groups, especially SHARE.\nI feel it is only proper that the beneficiaries of the new assembler\n(all of you out there) should know a few of the names of people whose\ncontributions were significant.\n\n      Above all, we must acknowledge Gregory J. Mushial, whose\ndissatisfaction with the assembler as it was, led him to write the\n\"SLAC Mods\", a package of about 50 enhancements to the existing\nAssembler H.  We must emphasize that Greg could only have done this\njob because Assembler H was available in source code, without the\nodious OCO restrictions.  For years, IBM rejected user requirements to\nabsorb the SLAC Mods because it was stated that they were \"technically\nimpossible\".  Greg's work openly contradicted that.  These things had\nalready been achieved, and they could even be benchmarked.\n\n      Next, it is necessary to recognize the monumental work of\nBill Winters, who typed in all the IBM PTF code to Assembler H from\nmicrofiche, and who fitted Greg Mushial's SLAC updates on top of the\n\"PTF\" updated source code.  If it weren't for Bill Winters' work, the\nuser efforts to influence IBM might have died, because people would\nhave thought the technical achievements of the SLAC mods were\nantiquated.  Bill's work proved that they could be as up-to-date as\nIBM's latest production assembler itself.\n\n      Finally, I have to mention a list of names.  Some key helpers\nwill undoubtedly be left out, and I must apologize for that.  But I\nfeel obligated to make known some names of people to whom the entire\nIBM mainframe community is indebted.  We are equally indebted to many\nother people whose names are not mentioned here.\n\n      They are:  John Ehrman, Nancy Wheeler, Gil Lee, Cindy Craine,\nand Al Hsia from IBM, whom we dealt with through SHARE.  David Andrews,\nJerry Callen, David Weintraub, Bill Johnson, Ted Johnston, John Grady\nSullivan, Walter Horowitz, Michael Stack, Lloyd Fuller, Michael Lewis,\nRoger Fajman, Melinda Varian, Gerhard Postpischil, the late Ben\nSchwarz, and many others gave very significant contributions and help\nthrough the SHARE committee.  John Melcher is the chairman of the\nGUIDE committee.  There were over 60 people at the GUIDE meetings, as\nI understand.  G.U.I.D.E. Europe and SHARE Europe also helped.  Thank\nyou all for your diligence and persistence.\n\n      Now that we've thanked some people, let's take a preliminary\nlook at what IBM says they've built into the new Assembler.  As of\nthis writing, I have access to the IBM announcement and a preliminary\ncopy of the General Information Manual for HLASM.  Please see Figure 1\nfor a summary of user requirements satisfied, taken from the IBM\nannouncement.\n\n\nA SUMMARY OF WHAT YOU'LL GET.\n\n      IBM has planned the new High Level Assembler, product number\n5696-234, to span their mainframe environments:  MVS, VM, and VSE.\nThe enhancements are many, and can be divided into several different\ncategories.  These are:  Language Extensions, Assembly Listing\nEnhancements, Usability Enhancements, Input-Output Enhancements, and\nPerformance Enhancements.  Most of these improvements were inspired\nby, or were taken from, Greg Mushial's SLAC Mods.  Almost all of them\nwere brought to IBM's attention by user group requirements.\n\n      The I/O extensions are perhaps simplest to explain, so I'll\nstart with them.  Greg Mushial had introduced an exit point for\nintercepting the printout of the assembler listing.  IBM developers\nextended the concept to include exit points for intercepting output\nor input to all of the High Level Assembler's ddnames.  All input or\noutput files to the Assembler can now be accessed by user-written\ncustomizations.\n\n      Speaking of ddnames, IBM has introduced a new one to HLASM,\ncalled SYSADATA, which was not in the SLAC Mods.  SYSADATA is a\nVariable Blocked file containing many kinds of assembler data records\nuseful in debugging.  In summary, the SYSADATA file will contain\nvarious record types, corresponding to:  the JOB and assembly\nenvironment, the Assembly Options, the ESD records describing all\nCSECTS and DSECTS, each source line, all source errors, all DC or DS\ninstructions, each machine instruction generated, each RLD record, each\nSymbol record, each symbol's Cross Reference record, each Macro Cross\nReference record, the USING map, and all the Assembly Statistics.  Give\na round of applause to the IBM developers.\n\n      Next, Assembly Listing enhancements include:  a USING map\nshowing all USING and DROP, PUSH and POP statements, the option of\nshowing all active USING statements at each page break, a MACRO cross\nreference showing the source of all macros, a DSECT cross reference\nmapping all DSECTs in the program, an improved symbol cross reference\nshowing changed fields and labels which are targets of a branch.\nThere is also a vastly improved assembler summary showing the source\ndataset(s) and operating system level as well as performance\nstatistics.  You can globally turn off PRINT NOGEN with an option\nsetting.  And there is much more than that, to help in following\nprogram logic and in debugging.  I haven't mentioned half of what's\nthere.\n\n      Language extensions are too numerous to mention in this small\nspace.  I'll talk more about them next month.  In my opinion, the most\nimportant extensions are the \"Labeled USINGs\" and \"Dependent USINGs\",\nwhich allow the programmer to establish base-displacement\naddressability without tying up an excessive number of registers.\nThese features had been a part of the SLAC Mods and were absorbed into\nHLASM.  People who had the SLAC Mods and were afraid to use these\nfeatures because of portability doubts, will now be able to take\nadvantage of them with a clearer conscience.  Symbol names which are\nnot referenced externally, can be up to 63 characters long.  The\nunderscore is now accepted as an alphabetic character, to make the\nassembler more compatible with higher level languages.\n\n      Performance enhancements from the SLAC Mods, and perhaps others,\nhave been introduced into HLASM.  The assembler will report if there is\nenough region space to support an in-core assembly, with no writing to\nthe SYSUT1 spill file.  Statistics to count reads and writes to the\nSYSUT1 file are shown in the assembler summary report.  Some algorithms\nfor sequencing macro expansions have been reworked.  From what I can\nsurmise, it seems fair to say that HLASM performance is not usually\nworse than that of its predecessor Assembler H Version 2, when\ncomparable options are run.\n\n      I'll have to continue this discussion next time.  It is exciting\nto finally see some IBM recognition that system-level coders should\nget a hint of the service that high-level language coders are\nreceiving.  Now all they have to do is recognize that it's to their\nadvantage to cut down on OCO or eliminate it.  That'll be the day!\nBut a day has already come.  This is exactly what we said when we were\ntalking about IBM absorbing the SLAC Mods into the assembler.\n\n      Keep the faith and keep up the pressure.  Try to make it to\nSHARE, GUIDE, or your local user group, and good luck.  See you next\nmonth.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE 1.  REQUIREMENTS FROM VARIOUS USER GROUPS THAT WERE ACCEPTED\n           FOR INCLUSION IN THE HIGH LEVEL ASSEMBLER.  (Quoted from\n           IBM Announcement Number 292-244, dated May 5, 1992.)\n\n\n\n  The following requirements from SHARE are:\n\n o    Incorporate the SLAC Mods into the assembler\n o    Memory management\n o    In-storage assembly\n o    CSECT/DSECT indicators for the location counter\n o    Active USINGs list\n o    Read and Write references in the symbol XREF\n o    Produce XREF of macros and copy code in assembly\n o    Produce XREF of DSECTS\n o    Terminal output enhancements\n o    Addressability of multiple instances of data area\n o    Multiple DSECTS mapped via one base register\n o    Provide SIZE option\n o    Flag duplicate and overlapping USING ranges\n o    Option to override PRINT NOGEN\n o    Treat underscore as alphabetic in symbols\n o    Allow lower case alphabetics in symbols\n o    Treat blank record as SPACE 1\n o    Provide user exit to control assembly listing\n o    Document AREAD parameters CLOCKB and CLOCKD\n o    Allow literals within EQU and expressions\n o    Allow EQUated symbols in SETA and SETB\n o    Implement \"Line Counter\" system variable symbol\n o    Relate symbols to owning DSECT/CSECT\n o    Implement \"Current Sequence Field\" system variable symbol.\n\n\n  The following requirements from SHARE Europe are:\n\n o    Mixed case symbol namess\n o    Improve diagnostics for macro writers\n o    Control-block mapping.\n\n\n  The following requirements from GUIDE are:\n\n o    Date and time of object modules\n o    Produce XREF of macros\n o    Support section type in system variables.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9208AU": {"ttr": 10507, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x93!\\x0f\\x01\\x00)\\x9f\\x11G\\x015\\x018\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 309, "newlines": 312, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          August 1992\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\n\nSOME ASSEMBLER THOUGHTS - THE NEW HIGH LEVEL ASSEMBLER - PART II.\n\n      This month, I'd like to continue talking about IBM's new \"High\nLevel Assembler\", product number 5696-234.  This new assembler, which\nis designed to replace Assembler H Version 2 and the DOS/VSE Assembler,\nhas largely arisen from user protests and prodding of IBM, mainly\nthrough SHARE and the other IBM user groups.  Most of that fuss was\nraised because of the existence of the magnificent \"SLAC modifications\"\nto Assembler H, a package of about 50 enhancements written by Gregory\nJ. Mushial.  These mods made the reading of assembly listings and the\ndebugging of assembler code far easier.  People wanted to know why IBM\nwouldn't incorporate the SLAC mods into their own product and bring\ntheir benefits to everybody.\n\n      Well now they have.  In this month's column, I'd like to\nsummarize more of the new assembler's features, so you can see the\nclear advantages to all assembler programmers now available in this\nnew assembler product.\n\n      As an aside, I must also state unequivocally that IBM's \"OCO\"\npolicy would have made the development of the SLAC mods impossible,\nhad it been in effect ten years earlier.  Greg Mushial could only have\nwritten the SLAC mods from the source code to Assembler H.  It is\nprobable that IBM would still be sleeping on the issue of Assembler\nenhancements, had source code not been available for skilled users\nlike Greg Mushial to \"play with\".  It is unfortunate that the new\nHigh Level Assembler, or HLASM for short, is distributed as \"Object\nCode Only\".  This stifles further change.  You users out there....\nKeep protesting to IBM to lessen its OCO policy!\n\n\nHLASM EXTENSIONS.  LET'S START.\n\n      There's too much that's new in HLASM to mention in this small\nspace.  We'll try to list the various kinds of extension to the\nassembler's features.  We systems programmers will find that coding and\nfixing code is going to be a lot more exciting soon.  HLASM will give\nus lots more help than we've been used to getting.\n\n      John Ehrman, in IBM's HLASM Presentation Guide for speakers,\nmentions the following nine categories of assembler improvement in\nHLASM.  These are:  development support functions, tool and environment\nsupport, new and extended language, new system variable symbols,\nusability-accuracy-readability, documentation enhancements, interfaces\nto languages and systems, new and extended options, other enhancements.\nWe'll try to briefly summarize what's involved in some of these areas,\nas the space permits.\n\n      Development support functions are many.  The idea is to show the\nprogrammer more ways of seeing if the program is correct.  Internally,\nthe assembler \"knows\" about these facts.  Previously, it just didn't\ntell us.  Now, we can make the assembler talk.  Most of the features\nin this category came from the SLAC mods.  That just goes to indicate\nhow good the SLAC mods are (and why we pressured IBM so much).\n\n      In this category:  There is the Macro and Copy Code Source\nCatalog, which tells you the dataset and volume that every macro and\ncopy member came from.  Previously, there was no simple way to know\nwhich macros were called during an assembly.  Now we know what their\nnames are, and which libraries they came from.  There's a DSECT cross\nreference showing every DSECT definition, its relocation id and its\ntotal length.  The DSECT cross reference helps us track the intermix\nof CSECT code and DSECT code in an assembly listing.  Another feature\nis a modification to the symbol cross reference.  The symbol cross\nreference now flags which line numbers are branch targets, and which\nlabels have been directly modified by the code.  We can thus follow\nthe program flow better.  For better tracking of addressability, there\nis a complete USING Map, which gives the history, length, and\nplacement of all USING and DROP statements.  We'll talk more about\naddressability help later.\n\n      The RSECT statement, to control re-entrancy checking on a CSECT\nby CSECT basis, has been documented and cleaned up.  With the new\nPCONTROL option, you can now override PRINT NOGEN and other print\nsuppression code statements without changing the source code.  Now,\nyou'll be able to see all the macro expansions with a minimum of effort\nif you want them.  End-of-assembly summary has been enhanced to show\nyou a lot of information about performance and the system on which the\nassembly ran.  Finally, the old LIBMAC option has been reinstated.\nLIBMAC prints the actual macro source code at the first point of each\nmacro's expansion in the listing.  Sometimes in debugging, you'd like\nto have that information handy.\n\n      The idea behind \"tool and environment support\" is be to able to\ninterface the assembler with other tools.  With HLASM, there are lots\nof new ways for other programs to get to the assembler's data.\n\n      HLASM's principal interface tool is the optional SYSADATA data\nfile.  This file contains many types of records concerning the\nassembly.  We mentioned their particulars last month.  The idea of\nSYSADATA is similar to SMF.  The SMF dataset contains various types of\nrecords, which are raw data pertaining to many aspects of operating\nsystem and program execution.  Similarly, the SYSADATA file retains\nmany types of raw data from an assembly run, in the form of records of\ndifferent types.  These records may be input to post-processing\nprograms of the user's design, just like SMF records are.  With the\nSYSADATA file as the assembler's \"official\" external interface,\nassembly listing \"scanner programs\" shouldn't be needed anymore.\n\n      Other new interface tools are the exit points.  Each ddname\nconnected with an assembly can now be controlled by a user exit.  IBM\nhas provided a new EXITCTL assembler option to be a central control\npoint for user exits to ddnames.  You can optionally regulate all I/O\nflow to and from the assembler.  Thus, you can now control the\nassembler in ways that were impossible before.  The assembler, instead\nof doing only what \"it wants\", can now do much more of what \"you\nwant\".\n\n      Last but not least in the \"tools interface\" category is the new\nASA option.  The ASA option causes the assembler to print its listings\nusing ASA print control characters instead of \"machine\" print control\ncharacters.  For example, such control would be useful for integrating\nassembler listings with report distribution packages that expect ASA\nprint control.\n\n\nEXTENDED LANGUAGE AND NEW SYSTEM VARIABLE SYMBOLS.\n\n      In this category, I'm leaving the best for last.  But we'll also\nget a lot of help from what's first.\n\n      HLASM supports some nice cosmetic changes to the assembler that\nshould have happened years ago.  You can now put blank lines into\nassembly source, and they get treated as \"SPACE 1\" the way they should\nbe.  Lower and mixed case input is now possible under option control.\nThere seems to be more to this than meets the eye.  When you get a\nworking copy of HLASM for yourself, look into the issue of mixed case\nassembler input in more detail.\n\n      We'll mention some more \"little things\".  There are lots of\nextensions to the use of literals now.  Literals can now be used as\nrelocatable terms in expressions.  There is a lot of relaxation in\nSETA, SETB, and SETC.  SETA, SETB, and SETC will now take previously\nEQUated values as operands, and there's much more extension in that\narea.\n\n      A general tendency in HLASM (taken from the SLAC mods) is that a\nlot of things which had only been permissible in macro coding, can now\nalso be done in open code.  References to T', L', S', and I' are\nallowed in ordinary symbols, SETC symbols, and literals.  All may\nappear in conditional assembly statements, both in macros and in open\ncode.  Another improvement is that the SYSPARM operand can now be 255\ncharacters in length instead of being limited to eight characters.\nThere are lots more of these \"little language extensions\", and they\ncan all help us in some way.\n\n      There are many new system variable symbols to help the\nprogrammer control what can be placed in the object code of a program.\nIn order to fit this discussion into its allotted space, I've listed\nmany of those in Figure 1, and we won't mention them here.\n\n\n\"USING\" EXTENSIONS AND HELP WITH ADDRESSABILITY CONCERNS.\n\n      In the category of assembly language extensions, I've left the\n\"biggie\" for last.  The enhanced control to USING and DROP that was\nfeatured in the SLAC mods, was the highest priority assembler\nrequirement presented to IBM by the SHARE Assembler committee.  Any\nexperienced assembler programmer knows the frustration inherent in\n\"addressability problems\".  The help offered in that area by the SLAC\nmods, and now by HLASM, is legendary.\n\n      Let's mention two new addressability diagnostic tools that are\nnow provided.  First, there is a global \"USING Map\" that can be\nproduced in an assembly listing.  This USING Map details all the USING,\nDROP, \"PUSH USING\" and \"POP USING\" statements in the whole program.\nThe USING Map is produced under control of the \"USING\" assembler\noptions.  Second:  on each page of the program listing, all current\nactive USINGs are printed below the page header.  You don't have to\nsearch for active USINGs any more.  They're at the top of every page.\nThis feature is under control of the PRINT(UHEAD) assembler option.\nIn addition to these two listing tools, new error messages have been\nintroduced to flag programmer errors having to do with USING\nstatements.  You now have a far better chance of catching obscure\nprogram bugs having to do with the active addressing registers.\n\n      All those new tools help us with addressability diagnosis, but\nthey are not language extensions.  The constructs of \"Labeled USINGs\"\nand \"Dependent USINGs\" provide new assembler language relief for\nproblems of addressability.  Labeled USINGs and Dependent USINGs\ncan also help greatly to reduce the number of registers being tied up\nfor addressing purposes.\n\n      What are Labeled USINGs?  Superficially, these are USING\ninstructions that have an expression in the name field, but otherwise\nthey look like ordinary USINGs.  See Figure 2 for a quick look at the\nnew USING types.\n\n      Labeled USINGs are independent of ordinary USINGs and can\ncoexist with them, even though they both employ the same base\nregister(s).  When an ordinary USING is DROPped, a coexisting Labeled\nUSING remains in force.  One idea behind Labeled USINGs is that the\nsame data area can be addressed by different registers at the same\ntime.  A reference to a symbol in the USING range is then \"qualified\"\nto associate the symbol with the appropriate label.  See Figure 2 for\nan example of this new stuff.\n\n      Dependent USINGs allow the second operand of a USING statement\nto be a relocatable expression instead of a register.  As long as the\nexpression is resolved by a prior ordinary USING, the dependent USING\nis resolved too.  Dependent USINGs help you very much when you have a\nlong string of different data areas that are all within one base USING\nrange.  You don't have to tie up any additional registers to map all\nthe areas.\n\n      These two constructs can be used together, and you can have\nLabeled Dependent USINGs.  The DROP instruction has been enhanced\ncorrespondingly, to undo all of the addressing relationships created\nby the new USING structures.  When you get your copy of HLASM, you'll\nsee that this is neat stuff, and it will greatly assist in your\nprogramming efforts.\n\n\nCONCLUSION.\n\n      IBM sometimes will actually act when prodded enough.  HLASM is\na good product.  You should go out and get it, or at least know about\nits existence.  I believe HLASM is only an upgrade charge from\nAssembler H Version 2, even though it has a new product number.  Good\nluck in all your work.  See you next month.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.  NEW SYSTEM VARIABLE SYMBOLS IN HLASM.\n\n           The High Level Assembler has been enhanced to include many\n           more system variable symbols.  Some of these are listed\n           below.\n\n\n  &SYSASM          -   The name of the assembler\n  &SYSDATC         -   Current date with century included\n  &SYSIN_DSN       -   Input dataset name\n  &SYSIN_MEMBER    -   Input member name\n  &SYSIN_VOLUME    -   Input volume serial\n  &SYSJOB          -   Assembly job name\n  &SYSSTEP         -   Assembly job step name\n  &SYSLIB_DSN      -   Name of library dsn for this macro or copy member\n  &SYSLIB_MEMBER   -   Member name for this macro or copy member\n  &SYSLIB_VOLUME   -   Volume serial for this macro or copy member\n  &SYSNEST         -   Nesting level of invocation for current macro\n  &SYSOPT_DBCS     -   Setting of the DBCS option\n  &SYSOPT_OPTABLE  -   Name of current opcode table used for this run\n  &SYSOPT_RENT     -   Setting of the RENT option\n  &SYSSEQF         -   Contents of the sequence field in this statement\n  &SYSSTMT         -   The number of the next statement to be processed\n  &SYSSTYP         -   Type of the current control section\n  &SYSTEM_ID       -   Identification of the operating system\n  &SYSVER          -   Assembler's release, version and mod level\n\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.  CODING EXAMPLES USING LABELED AND DEPENDENT USINGS.\n\n\n      Example of Labeled USINGs.\n\n\nPRIOR    USING  IHADCB,R10                      First DCB\nNEXT     USING  IHADCB,R2                       Second DCB\n         MVC    PRIOR.DCBLRECL,NEXT.DCBLRECL    Move LRECL over\n         DROP   PRIOR\n         DROP   NEXT\n\n\n      Example of Dependent USING (unlabeled).\n\n\nEXAMPLE  CSECT\n         USING  EXAMPLE,R10,R11              Ordinary USING\n          .\n          .\n         USING  IHADCB,DCBUT2                Unlabeled Dependent USING\n         LH     R2,DCBBLKSI                  Uses R10 or R11 for base\n          .\n          .\nDCBUT2   DCB    DDNAME=SYSUT2,...\n\n\n      Example of two Labeled Dependent USINGs.\n\n\nEXAMPLE  CSECT\n         USING  EXAMPLE,R10,R11              Ordinary USING\n          .\n          .\nDCB1     USING  IHADCB,DCBUT1                Labeled Dependent USING\nDCB2     USING  IHADCB,DCBUT2                Labeled Dependent USING\n         MVC    DCB2.DCBBLKSI,DCB1.DCBBLKSI  Uses R10 or R11 for base\n          .\n          .\nDCBUT1   DCB    DDNAME=SYSUT1,...\nDCBUT2   DCB    DDNAME=SYSUT2,...\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9209SE": {"ttr": 10758, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x93!\\x0f\\x01\\x00)\\x9f\\x11G\\x01(\\x01(\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 296, "newlines": 296, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         September 1992\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\nSOME SMP TOOLS YOU SHOULD HAVE.\n\n      I'm surprised at how a few incredibly simple tools can go a\nlong way.  Today, I'd like to talk about two very basic tricks in the\nSMP/E area and their simple implementations.  These will make life\nmuch easier for you when you do system maintenance or investigate\nproblems.\n\n      Idea number one:  Wouldn't it be nice to always have any PTF\nor usermod instantly available for inquiry?  This is not far from\nyour reach.  It's as close as one dataset, your SMPPTS.\n\n      If you have the disk space, it may not be a bad idea to let\nyour PTS dataset grow to 4000 or 5000 tracks or more.  (The only\ndisadvantage is that APPLY GROUP or GROUPEXTEND runs take considerably\nmore time.)  The PTS, in SMP/E, contains the actual text of received\nsysmods as members of a partitioned dataset.  This includes the text\nof all cover letters, as well as all modification control statements.\nThe PTS dataset is a gold mine to you, as a database for inquiry.  If\nyou have some simple way of browsing a member of this pds, you can\ninstantly investigate the mechanism of how any sysmod works, as well\nas all of the extra documentation that IBM wants you to know about.\nYou will be looking at the actual sysmod itself.\n\n      There's a simple-to-use and powerful browsing tool called REVIEW\non the CBT MVS Utilities Tape.  REVIEW is a TSO command that doesn't\ndepend on ISPF.  REVIEW can be called from a clist or a REXX exec.\nREVIEW, which is found in source code on File 134, and in load module\nform on File 135 of the CBT Tape, gives you instant ability to look at\nPTFs, and has multiple advantages over \"ISPF BROWSE\".  See Figure 1\nfor a simple clist called \"PTF\".  This clist can do wonders for you if\nyou'll try it and use it.\n\n      Why is REVIEW better than ISPF browse?  First, it's much faster.\nFor fixed blocked data, if you have a large dataset, it's possible to\ngo down to the bottom or \"DOWN 100000\" lines by figuring out the\ndestination TTR instead of by feeling your way down record by record.\nREVIEW is smart enough to do the math.  ISPF browse isn't.  If you say\n\"BOTTOM\" or \"DOWN M\" when REVIEWing a 400000 line fixed blocked\ndataset, you're there almost instantly.  Try doing that with BROWSE,\nthe first time you're looking at the dataset, and see how long you\nhave to wait.\n\n      Even in cases when it's impossible to do the math, and REVIEW\n\"knows\" it, REVIEW is better than BROWSE.  This can happen when you're\nREVIEWing a variable blocked dataset or doing a FIND command for a\nstring of data.  REVIEW can't get there instantly by doing calculations,\nbecause it has no way of knowing how big the blocks are, or in a string\nFIND, it can't skip over any of the data.  In that case, REVIEW will\ntell you how far it's gotten if you're tired of waiting.  BROWSE won't.\nHow?  When REVIEW is searching through many blocks of data and hasn't\nupdated the screen for you yet, all you have to do is press ATTENTION\n(or PA1) once.  REVIEW will stop in its tracks, displaying exactly how\nfar it has gotten.  Re-issue the same \"find\" command (there's a\nRETRIEVE pfkey) and REVIEW will continue looking from there.  There's\nno hint of such a facility in ISPF BROWSE.\n\n      So I recommend a CLIST with two lines:  \"PROC 1 SYSM\" is the\nfirst line, and \"REVIEW 'SMPE.SMPPTS(&SYSM)'\" is the second line.\n(Make sure you're pointing to your active PTS where the sysmods are.)\nIf you name the clist \"PTF\" and put it in a clist library that's part\nof your TSO SYSPROC ddname concatenation, all you have to do to\ninquire on PTF UY78912 is to type:  \"TSO %PTF UY78912\" under ISPF and\nyou've got it.  When you finish looking at the PTF and press PF3,\nyou're back in ISPF where you were before.  This will also work in\nnative TSO, because REVIEW doesn't need ISPF.  I recommend creating a\npfkey in ISPF called \"TSO\".  Then, to inquire on the PTF, you just\ntype:  \"%PTF UY78912\" and press the \"TSO\" pfkey.  There isn't anything\nmuch more simple or easy to set up, and this is very handy.\n\n      One more thing.  Please make sure you've installed the newer\nversion of REVIEW from Greg Price that's on File 134 of the CBT tape,\nrather than an older version.  The older version will suffice for\nthe PTF inquiry purpose, but it doesn't have the \"speed functions\"\nwe mentioned above.  Also, suppose you missed on the PTF number and\ntyped one that you don't have.  REVIEW will display it's \"null member\"\nscreen.  With Greg's version of REVIEW, you needn't worry.  Just type\nthe command:  \"DIR\" on the command line, and you get a full directory\nlist of the PTFs in your SMPPTS dataset.  There's an 8-byte command\nfield at the top of this member list which serves a \"locate\" function\nfor the member list.  Just type \"approximately\" the PTF number in\nthis field, and the list will be positioned close to where you want\nto go.  Type an \"S\" next to any member name, and you REVIEW it.\nIf you're running REVIEW under ISPF and the ISPF environment is there,\na \"B\" (instead of an \"S\") next to the member name will ISPF BROWSE the\nmember.  An \"E\" will ISPF EDIT it.  Of course, you don't want to\nedit IBM's PTFs, but you can use \"CREATE\" under EDIT to extract parts\nof the PTF or to copy its cover letter to another dataset.\n\n\nA SECOND TOOL - A CLIST TO RUN SMP/E IN THE FOREGROUND.\n\n      See Figure 2 for a clist that runs SMP/E in the foreground\nat your TSO terminal under native TSO.  This is \"idea number two\".\nWhich this clist, you can make many \"little inquiries\" and SMP\nadjustments with much more ease than with SMP/E's ISPF inquiry\nsystem.  You can carefully do small UCLIN adjustments (if you know\nwhat you're doing), and you can immediately look at the results by\ndoing the corresponding \"LIST\" commands, before and after the UCLIN.\nThis clist allocates the SMP/E log, so that your activities are\nchronicled there.\n\n      When you use this clist, which we can call \"SMPETSO\" for this\ndiscussion, you are actually running the SMP/E program GIMSMP as\nthough it were a batch job.  The difference is that you have to enter\nall of the commands (normally in SMPCNTL) at your terminal.  For\nexample, after the clist starts running, you must type in a \"SET BDY\"\ncommand in order to start your work.  The clist display's GIMSMP's\nnormal response.  Then you type your commands.  For example, you\nmight type:  \"LIST MOD (IFG0194K) .\"  You have to use strict SMP\nsyntax, with periods and all.  The result is displayed on your terminal.\nWhen you've finished, you type \"/*\" in column 1, and the GIMSMP program\nends.\n\n      Once you've used the SMPETSO clist for a while, you'll be\namazed at how handy it is to have.  I'd recommend using it for very\nsimple things most of the time.  It is intended for inquiries primarily,\nnot for MASS APPLY!  The capabilities of this CLIST are very much\nenhanced if you use the TSO session manager which comes with TSO/E.\nThe TSO session manager gives you up-down-right-left scrollability\nunder native TSO, and it preserves several thousand lines of TSO\noutput in your running session.  You aren't limited to just a screen\nfull of data that you can't recover.  In my travels, I've been extremely\nsurprised about people's ignorance of the session manager, even among\nIBM'ers.  See Figure 3 for simple information on invoking the TSO/E\nsession manager in your logon procedure.\n\n      The TSO session manager is extremely easy to set up.  You just\nhave to change the EXEC card in your TSO logon proc.  Figure 3 is\nprovided as a helpful hint.  You can make the whole change in two or\nthree minutes.\n\n      If you are in TSO in session manager mode, and you want to\nchange to the other mode, there is an authorized command called \"SM\"\non the CBT Tape (File 119) that can be used to toggle back and forth\nbetween modes.  If you have the SM command set up, you can instantly\nhave TSO the way you like it.  You can change modes with the flick\nof a finger.\n\n      I am sure these tools will help you in your work, especially\nthe simple PTF inquiry clist.  It's great for looking at APAR letters\nwhile you're doing PE research, or when you're on the phone with IBM.\nThe SMP/E execution clist allows you to do much more than the SMP ISPF\ninquiry, such as looking at the state of three or four entries at\nonce.  The SMP ISPF inquiry only allows you to see one entry at a\ntime, and it's a lot of trouble to switch and look at 3 or 4 other\nones.  Not so with the SMPETSO clist.  You can list as many entries\nin one inquiry as you feel like, just as in a batch job.  But you\ndon't have to wait as long for the answer.\n\n      These two tools have stood me in good stead over many years.\nIf you take an hour to set them up, they can do the same for you.\nGood luck.  I'll see you next month.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   THE \"PTF\" INQUIRY CLIST.\n\n            This clist, which takes advantage of the capabilities of\n            the \"REVIEW\" TSO command on the CMT MVS Tape (File 134\n            for source and File 135 for load), is extremely simple,\n            but extremely useful.  Assemble REVIEW from File 134 or\n            copy the load module from File 135 and have fun.\n\n\n\n PROC 1 SYSM\n REVIEW 'SMPE.SMPPTS(&SYSM)'\n /*\n /*  This assumes that your PTS dataset is called SMPE.SMPPTS.\n /*\n /*  Assuming the member name of this clist is PTF, and it resides\n /*   in a library in the SYSPROC ddname concatenation of your TSO\n /*   session, you merely execute  %PTF UY78912 to look at ptf UY78912.\n /*   It's that simple.  PF3 to end.  You're back where you were.\n /*\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE 2.   THE SMP/E INQUIRY CLIST.  WE'LL CALL THIS CLIST \"SMPETSO\".\n\n       This clist invokes SMP/E in the foreground under TSO in exactly\n       the same way as it would run in the background in batch.  Input\n       of commands and output of results go to the terminal.  Since\n       there might be quite a few lines of output, it is preferred\n       to run this clist in TSO \"session manager mode\", which can\n       preserve and print up to several thousand lines of TSO output.\n       See Figure 3 on how to set up session manager mode for your\n       TSO session.\n\n\n PROC  0  VOLID  CSI('SMPE.GLOBAL.CSI')  UNIT(DISK)  TYPE(SYS1)  NOLOG -\n          SYSOUT  LOGDISP(MOD)  NOPTS  LIST()  /**  YES OR NO  **/\n\n   SET VOLID = XRS003       /*  SMP-CONTROLLED PACK  */\n   IF LIST = YES  THEN  CONTROL LIST\n   ELSE  IF LIST = NO  THEN  CONTROL NOLIST\n\n   CONTROL PROMPT\n\n   WRITE ***********************************************************\n   WRITE *                                                         *\n   WRITE *     WELCOME TO THE SMP INQUIRY SYSTEM.  THIS MEANS      *\n   WRITE *          MAKE INQUIRIES ONLY  ........                  *\n   WRITE *                                                         *\n   WRITE ***********************************************************\n   WRITE\n   WRITE                  T Y P E  =   &TYPE\n   WRITE\n   WRITE             FOREGROUND EXECUTION OF SMP/E\n   WRITE\n   WRITE              SYSTEM DEFAULT  ====>  &TYPE\n   WRITE\n   WRITE            TYPE  =  &TYPE  MVS SP 4.1.0  DFP/ESA\n   WRITENR              ENTER DESIRED TYPE ====>\n   READ ANS\n\n   IF &LENGTH(&STR(&ANS)) \u00ac= 0  THEN SET TYPE=&STR(&ANS)\n   IF &TYPE = SYS1    THEN SET VOLID = XRS003   /*  TARGET PACK  */\n   IF &TYPE = SYS1    THEN SET DIST  = SMPDL1   /*   DLIB  PACK  */\n\n   WRITE\n   WRITE   YOU HAVE SPECIFIED  &TYPE AS THE SYSTEM.\n   WRITE   TARGET = &VOLID   ----  DISTRIBUTION = &DIST\n   WRITE\n\n   ERROR GO TO ENDALL\n   ATTN  GO TO ENDALL\n\n   ALLOC FI(SMPLIST) DA(*)\n   ALLOC FI(SMPCNTL) DA(*)\n   ALLOC FI(SMPRPT)  DUMMY\n\n   IF &NOLOG = NOLOG THEN ALLOC FILE(SMPLOG) DUMMY   /* NO SMP LOG */\n     ELSE ALLOC FI(SMPLOG) &LOGDISP KEEP DA('SMPE.GLOBAL.SMPLOG')\n\n   IF &NOPTS \u00ac= NOPTS  AND  TYPE = SYS1    +\n     THEN ALLOC FI(SMPPTS) SH REUSE DA('SMPE.GLOBAL.SMPPTS')\n\n   IF &SYSOUT = SYSOUT THEN ALLOC FI(SMPOUT) SYS(T)  /* HELD CLASS */\n     ELSE ALLOC FI(SMPOUT)  DA(*)\n\n   CALL  'SYS1.LINKLIB(GIMSMP)' 'CSI=&CSI'\n\n  ENDALL:  ERROR OFF\n           ATTN  OFF\n           FREE FI(SMPLIST SMPRPT SMPCNTL SMPLOG SMPOUT SMPPTS)\n\n  END\n\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n\nFigure 3.   SETTING UP TSO SESSION MANAGER IN YOUR TSO LOGON PROC.\n\n            By changing the coding of the EXEC card slightly in\n            your TSO logon procedure, you can invoke TSO in session\n            manager mode.  Session manager mode preserves several\n            thousand lines of TSO output, which is scrollable.\n            The output is also 255 characters wide, and may be\n            printed using the \"SMCOPY\" TSO command.  Every TSO/E\n            system is equipped for session manager mode, and help\n            for SMCOPY is shipped by TSO/E in SYS1.HELP.\n\n\n To use the TSO session manager, code the EXEC card of your TSO logon\n procedure as follows:    (Refer to the \"TSO/E Customization\" manual.)\n\n\n //PROCNAME  EXEC  PGM=ADFMDF03,PARM='SM(IKJEFT01,Y),%LOGCLST',\n //          DYNAMNBR=100\n\n\n instead of:\n\n\n //PROCNAME  EXEC  PGM=IKJEFT01,PARM='%LOGCLST',DYNAMNBR=100\n\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9210OC": {"ttr": 10764, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x93!\\x0f\\x01\\x00)\\x9f\\x11G\\x00\\xf1\\x00\\xf3\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 241, "newlines": 243, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         October 1992\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\nSMP TOOLS YOU SHOULD HAVE:  PART II - A CLIST to run SMP/E in the\n      Foreground.\n\n      Sometimes you can get a lot of work done by taking advantage of\na few simple ideas.  It is possible to save yourself a lot of time\nwith some very simple mechanisms that take just a few minutes to\ninstall.  Last month, we talked about one such idea--a simple CLIST\nthat is very helpful for SMP/E PTF inquiry.  This month, we'll\nintroduce another CLIST.\n\n      This second CLIST invokes SMP/E in the foreground and is useful\nfor CSI inquiries and quick changes.  We shall call this CLIST,\nSMPETSO.  Since SMPETSO works better when your TSO session is running\nin \"session manager mode\" under TSO/E, we'll show you how to set up\nthe TSO session manager, with about three minutes of work.\n\n      See Figure 1 for an coded example of the SMPETSO CLIST.  Using\nSMPETSO, you can make \"little inquiries\" and SMP adjustments with much\nmore ease than with SMP/E's ISPF inquiry system.  You can also do\nsmall UCLIN changes (if you know what you're doing).  You can\nimmediately see the results by doing the corresponding \"LIST\"\ncommands before and after each UCLIN.  SMPETSO allocates the SMP/E\nlog, so that all activities are chronicled there.\n\n      SMPETSO actually runs the SMP/E program GIMSMP as though it were\na batch job.  The difference is that you have to enter all of the SMP/E\ncommands (normally in SMPCNTL) at your terminal.  For example, after\nthe CLIST starts running, you must type in a \"SET BDY\" command in\norder to start your work.  SMPETSO displays GIMSMP's normal response.\nThen you type other commands.  For example, you might type:  \"LIST MOD\n(IFG0194K) .\"  You have to use strict SMP syntax, with periods and\nall.  The result is displayed at the terminal.  When you've finished,\ntype \"/*\" in column 1, and the GIMSMP program ends.\n\n      Once you've used the SMPETSO CLIST for a while, you'll be amazed\nat how handy it is to have.  I'd recommend using it for very simple\nthings most of the time.  It is intended for inquiries primarily, not\nfor MASS APPLY!  The capabilities of this CLIST are very much enhanced\nif you use the TSO session manager which comes with TSO/E.  The TSO\nsession manager gives you up-down-right-left scrollability under native\nTSO, and it preserves several thousand lines of TSO output in your\nrunning session.  You aren't limited to just a screen full of data that\nyou can't recover.  From my travels, I've been extremely surprised\nabout people's ignorance of the session manager, even among IBM'ers.\nSee Figure 2 for simple information on invoking the TSO/E session\nmanager in your logon procedure.  You can make the whole change in two\nor three minutes.\n\n      If you are in TSO in session manager mode and you want to change\nto the \"ordinary\" mode, there is an authorized command called \"SM\" on\nthe CBT Tape (File 119) that can be used to toggle back and forth\nbetween modes.  If you have the SM command set up, you can instantly\nhave TSO the way you like it.  You can change modes with the flick of a\nfinger.\n\n      Our SMPETSO CLIST frequently allows you to do much more than the\nIBM-supplied SMP/E ISPF inquiry.  For example, we can look at three or\nfour SMP entries at once, such as MOD, MAC or SYSMOD entries.  The\nSMP/E ISPF cross-zone query only allows you to see one entry at a\ntime, and it's a lot of trouble to switch and look at 3 or 4 other\nentries.  Using the SMPETSO CLIST, you can list as many entries with\none inquiry as you feel like, just as in a batch job.\n\n      For example, try doing the equivalent of the command:\n        \"LIST MOD(IFG0194A IFG0194F).\"\nusing the SMP/E ISPF cross zone inquiry.  If you're only looking in\none zone, you'll have to admit that the SMPETSO CLIST is better.\nSee Figure 3 for sample output of this command.\n\n      This SMPETSO CLIST has been very helpful to me over the years.\nTake a few minutes to set it up and use it, and it can be just as\nuseful to you.  Good luck.  I'll see you next month.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE 1.   THE SMP/E INQUIRY CLIST.  WE'LL CALL THIS CLIST \"SMPETSO\".\n\n       This CLIST invokes SMP/E in the foreground under TSO exactly\n       the same way as it would run in the background in batch.  Input\n       of commands and output of results go to the terminal.  Since\n       there might be quite a few lines of output, it is preferred\n       to run this CLIST in TSO \"Session Manager mode\", which can\n       preserve and print up to several thousand lines of TSO output.\n       See Figure 2 on how to set up Session Manager mode for your\n       TSO session.\n\n\n PROC  0  VOLID  CSI('SMPE.GLOBAL.CSI')  UNIT(DISK)  TYPE(SYS1)  NOLOG -\n          SYSOUT  LOGDISP(MOD)  NOPTS  LIST()  /**  YES OR NO  **/\n\n   SET VOLID = XRS003       /*  SMP-CONTROLLED PACK  */\n   IF LIST = YES  THEN  CONTROL LIST\n   ELSE  IF LIST = NO  THEN  CONTROL NOLIST\n\n   CONTROL PROMPT\n\n   WRITE ***********************************************************\n   WRITE *                                                         *\n   WRITE *     WELCOME TO THE SMP INQUIRY SYSTEM.  THIS MEANS      *\n   WRITE *          MAKE INQUIRIES ONLY  ........                  *\n   WRITE *                                                         *\n   WRITE ***********************************************************\n   WRITE\n   WRITE                  T Y P E  =   &TYPE\n   WRITE\n   WRITE             FOREGROUND EXECUTION OF SMP/E\n   WRITE\n   WRITE              SYSTEM DEFAULT  ====>  &TYPE\n   WRITE\n   WRITE            TYPE  =  &TYPE  MVS SP 4.1.0  DFP/ESA\n   WRITENR              ENTER DESIRED TYPE ====>\n   READ ANS\n\n   IF &LENGTH(&STR(&ANS)) \u00ac= 0  THEN SET TYPE=&STR(&ANS)\n   IF &TYPE = SYS1    THEN SET VOLID = XRS003   /*  TARGET PACK  */\n   IF &TYPE = SYS1    THEN SET DIST  = SMPDL1   /*   DLIB  PACK  */\n\n   WRITE\n   WRITE   YOU HAVE SPECIFIED  &TYPE AS THE SYSTEM.\n   WRITE   TARGET = &VOLID   ----  DISTRIBUTION = &DIST\n   WRITE\n\n   ERROR GO TO ENDALL\n   ATTN  GO TO ENDALL\n\n   ALLOC FI(SMPLIST) DA(*)\n   ALLOC FI(SMPCNTL) DA(*)\n   ALLOC FI(SMPRPT)  DUMMY\n\n   IF &NOLOG = NOLOG THEN ALLOC FILE(SMPLOG) DUMMY   /* NO SMP LOG */\n     ELSE ALLOC FI(SMPLOG) &LOGDISP KEEP DA('SMPE.GLOBAL.SMPLOG')\n\n   IF &NOPTS \u00ac= NOPTS  AND  TYPE = SYS1    +\n     THEN ALLOC FI(SMPPTS) SH REUSE DA('SMPE.GLOBAL.SMPPTS')\n\n   IF &SYSOUT = SYSOUT THEN ALLOC FI(SMPOUT) SYS(T)  /* HELD CLASS */\n     ELSE ALLOC FI(SMPOUT)  DA(*)\n\n   CALL  'SYS1.LINKLIB(GIMSMP)' 'CSI=&CSI'\n\n  ENDALL:  ERROR OFF\n           ATTN  OFF\n           FREE FI(SMPLIST SMPRPT SMPCNTL SMPLOG SMPOUT SMPPTS)\n\n  END\n\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n\nFigure 2.   SETTING UP TSO SESSION MANAGER IN YOUR TSO LOGON PROC.\n\n            By changing the coding of the EXEC card slightly in\n            your TSO logon procedure, you can invoke TSO in session\n            manager mode.  Session manager mode preserves several\n            thousand lines of TSO output, which can be viewed by\n            either scrolling, or printing with the SMCOPY TSO command.\n            TSO Session Manager output is 255 characters wide.\n            Every TSO/E release includes software for session manager\n            mode, and help to use SMCOPY is shipped by TSO/E in\n            SYS1.HELP.\n\n\n To use the TSO session manager, code the EXEC card of your TSO logon\n procedure as follows:    (Refer to the \"TSO/E Customization\" manual\n for further details.)\n\n\n //PROCNAME  EXEC  PGM=ADFMDF03,PARM='SM(IKJEFT01,Y),%LOGCLST',\n //          DYNAMNBR=100\n\n\n instead of:\n\n\n //PROCNAME  EXEC  PGM=IKJEFT01,PARM='%LOGCLST',DYNAMNBR=100\n\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 3.   SAMPLE OUTPUT OF AN SMP/E COMMAND USING SMPETSO.\n            The \"SET BDY(XRS003).\" command to look at target zone XRS003\n            has been omitted for the sake of brevity.\n\n\nlist mod(ifg0194a ifg0194f).\nLIST MOD(IFG0194A IFG0194F).\n\nDATE 92.236  TIME 15:21:09  GIMSMP LVL 15.1.19 SMPLIST OUTPUT - NOW SET\n  TO TARGET ZONE XRS003                      PAGE 0001\n\nLIST MOD(IFG0194A IFG0194F).\n\nDATE 92.236  TIME 15:21:09  GIMSMP LVL 15.1.19 SMPLIST OUTPUT - NOW SET\n  TO TARGET ZONE XRS003                      PAGE 0002\n\nXRS003  MODULE  ENTRIES\n\n  NAME\n\nIFG0194A  LASTUPD           = HDP3320  TYPE=ADD\n          LIBRARIES         = DISTLIB=AOSD0\n          FMID              = HDP3320\n          RMID              = UY69467\n          TALIAS            = IFG0204A  IFG0554A\n          LMOD              = IFG0194A\n\nIFG0194F  LASTUPD           = HDP3320  TYPE=ADD\n          LIBRARIES         = DISTLIB=AOSD0\n          FMID              = HDP3320\n          RMID              = UY79106\n          TALIAS            = IFG0554F\n          LMOD              = IFG0194A\n\nDATE 92.236  TIME 15:21:09  GIMSMP LVL 15.1.19 SMPLIST OUTPUT - NOW SET\n  TO TARGET ZONE XRS003                      PAGE 0003\n\nLIST     SUMMARY REPORT FOR XRS003\n\nENTRY-TYPE   ENTRY-NAME   STATUS\n\nMODULE       IFG0194A     STARTS ON PAGE 0002\nMODULE       IFG0194F     STARTS ON PAGE 0002\nGIM20501I    LIST PROCESSING IS COMPLETE. THE HIGHEST RETURN CODE WAS 00.\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9211NV": {"ttr": 11013, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x93!\\x0f\\x01\\x00)\\x9f\\x11G\\x01\\x13\\x01\\x13\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 275, "newlines": 275, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         November 1992\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\n Sam Golob is a Senior Systems Programmer living\n in New Jersey.\n\nHOW I FOLLOWED MY OWN ADVICE, AND, HOW NOT TO UPGRADE JES2 EXITS.\n\n      In our last two columns, we discussed two clists that are very\nuseful in SMP/E related areas.  The first clist called PTF, uses the\nTSO command called REVIEW from the CBT Tape to look at all your\nreceived ptfs.  The idea is to use your SMPPTS dataset as a data\nrepository to keep accurate information about recent system fixes.\nThe second clist, called SMPETSO, runs SMP/E in the foreground for the\npurpose of doing quick CSI inquiries and UCLIN adjustments.  These\nclists are illustrated in the two figures.  This month, I'd like to\ntell a true-to-life story about how I used my own tools.\n\n      The installation I'm now at, runs MVS/ESA 4.1 with JES2 4.1.0.\nThey have a JES2 Exit 1 routine which produces customized separator\npages for all non-FSSMODE printouts.  I've been told that this routine\nstopped working properly at the ESA 3.1.1 level.  At the 4.1 level, it\nstarted getting 0C4 abends at random intervals.  Clearly, something had\nto be done about the coding of this exit.\n\n\nTHE PROBLEM WITH JES EXIT UPGRADES.\n\n      I have to preface this discussion with the usual \"method\" of\nquickly upgrading JES2 exits from one JES2 release to another.  This\nmethod has been used since JES2 exits have been available, and we're\nprobably all \"guilty\" of exploiting it most of the time.  The idea is\nto obtain IBM's \"conversion notebook\" or whatever documentation they've\ndistributed to outline the changes (and pitfalls) of the new JES2\nrelease.  Then you assemble your old JES2 exit using the new JES2\nmacros you've just installed.  Finally, you fix any assembly errors\nthat happen, following the hints and instructions in the conversion\ndocument.  Then you \"run the sucker\" and if it doesn't bomb, you put it\ninto production.\n\n      I'm exaggerating just a wee bit, but you can probably see what\nis wrong with this picture.  In this process, there's no study as to\njust how the exit works.  It's all \"external\" and mechanical, and it\nassumes that IBM hasn't changed any of the logic interfacing with what\nthe exit does.  That's a very false assumption, since an installation's\ncustomized exit can do almost anything, and ultimately, it seems prudent\nfor the systems programmers to understand what mechanisms and processes\ntheir JES exits are actually using.\n\n      Our case seemed typical of the above mismanagement.  Tracing the\nimmediate cause of the 0C4 abends was the first problem.  I got help\nfrom several sources worth mentioning, one of whom was our esteemed\nfellow NaSPA member Tom Bryant, but I'll leave that discussion for\nanother time.  For now, I'll tell you what caused the abends, and how I\nfollowed my own advice to go about fixing them.  My particular case was\nrather specific, but my methods are so general, that you'll undoubtedly\nderive considerable benefit by looking over my shoulder.\n\n\nRDT ENTRIES, AND HOW THEY'RE SEARCHED.\n\n      Our abends were caused by a change in the construction of JES2's\nRDT or Remote Destination Table entries.  The RDT defines remote\nprinter addresses to JES2.  Our exit needed to read the RDT so the\nseparator page could display the remote node and destid of the printer\nbeing used to print the job.\n\n      Our exit was trying to read the RDT the \"old way\", across a\ncontiguous block of storage.  But IBM had actually changed the RDT's\nconstruction so it needed to be read another way, through entry\nchaining across non-contiguous pages.  IBM made that change, to allow\nfor dynamic adding of new remote destids through $ADD operator\ncommands.  Our installation services 2200 remote printers, with the RDT\ntable covering 14 scattered pages in storage.  The disparity between\ncontiguous reading, and non-contiguous construction of the RDT table\ncaused our exit to occasionally cross the page boundaries and try to\nlook at storage that JES2 hadn't GETMAIN'ed, resulting in the abend\n0C4's.\n\n      What does this have to do with our two clists?  Once the problem\nwas diagnosed, I had to determine the correct method of actually\nreading the RDT so I could fix our exit.  From looking at the dump, the\nRDT was a hodgepodge.  Whole pages were being GETMAIN'ed for RDT use.\nEach page had a heading marker.  It was not clear if the heading marker\nwas used to read the RDT entries, or just to tag pages earmarked for\nRDT use.  Entries were scattered across pages, usually crowded toward\nthe end of the page, and often an entry would point to the next entry\nseveral pages away.  I had to discover what IBM really wanted here.  To\nsolve my own problem with the user code, I wanted to imitate IBM's code\nexactly, or else we'd continue to get errors.\n\n      So in order to discover IBM's ways, I had to look at IBM's code.\nBut how do I find examples of IBM's code, at the correct maintenence\nlevel?  Each RDT entry is described by the JES2 macro called $RDT.  I\nused the SMPETSO clist to quickly find the UMID (update level) of this\nmacro.  It was at PTF level UY76237.  The $RDT macro in our exit's\nassembly listing had been marked at OY47804.  A LIST SYSMOD inquiry to\nSMPETSO revealed that apar BY47804 was indeed superseded by ptf\nUY76237, so we were looking at the current level of the $RDT macro.\n\n      My next deduction was that if IBM was indeed introducing a new\nconstruction of an RDT entry with ptf UY76237, they also would have to\nchange their own code to read the RDT the new way.  I'd bet that good\nold ptf UY76237 probably ALSO changed any JES2 code which had to read\nthe RDT.  That would be a good place for me to learn how to do the same\nthing for my exit's code.\n\n      I don't have to mention that my next step was to use the PTF\nclist to look at the actual text of ptf UY76237.  To find IBM code that\nhad been changed, I scanned the ptf for ++SRCUPD (source update) SMP\nstatements to look for likely examples.  A promising update was to\nthe module HASPIRRE that is a component of HASPINIT.  Another quick\nuse of the SMPETSO clist showed me that the HASPIRRE module was at\nRMID (replacement level) UY76237, and that the HASPIRRE source had\nUY76237 as its highest numbered UMID.  This indicated that an assembly\nlisting of HASPIRRE would probably produce a coding example that I\ncould copy for our exit's use.\n\n      Since UY76237 hadn't been ACCEPTed yet, I went to the SMPSTS\nto get the source code.  I assembled the code, using the SMPMTS as\nthe highest concatenated macro library, and was soon in possession\nof an assembly listing.  This listing quickly revealed that the RDT\nwas correctly searched by a 3-instruction loop, which ended in a\nzero pointer to the next RDT entry.  Case closed and problem solved.\nWe have another happy ending to a perplexing system problem.\n\n\nSO WHAT DO WE LEARN?\n\n      IBM introduces a lot of code rewrites and SPE's (Small\nProgramming Enhancements) in ptfs.  If you'll look at the actual text\nof a such a ptf, you'll have the basis of learning everything that IBM\nneeded to do with its own code, to make any necessary changes.  There\ncouldn't be a better learning example than that.  Of course, we were\nhelped immensely by the fact that JES2 is (still) distributed in\nsource code.  We can fully exploit these techniques while looking at\nJES2 or JES3 problems.  What could we gain from this method if the\nchanges were in object module form only and the ptf contains only\nobject modules?\n\n      In this forum, I can't recommend disassembling IBM's object\ndecks.  But I can recommend learning how to READ object decks, or I\ncan recommend linkediting them and use zapping tools to discover their\ncontents.  That is the subject of another session.  See Fred Schuff's\narticle in the May 1992 issue of \"Technical Support\" on the linkage\neditor.  Fred also talks there about some of the structure of object\ndecks.\n\n      More practically, we can point out that a ptf can always be\nexamined for the EXACT NAMES of all the components it affects.  If you\nexamine the actual ptf closely, you can learn a lot about what really\nwas changed, and how it was changed.  You are in possession of the\nactual changes, the \"genuine article\".  This is much better than only\nlooking at the cover letter.  Any changes to macros, which are in\nsource update form, or to source, if present, can shed additional\nlight on a problem resulting from IBM maintenance.\n\n      So to summarize:  Examining a ptf directly (through the PTF\nclist) and examining SMP/E entries directly (through the SMPETSO\nclist) are essential techniques for good system detective work.  I am\na great believer in not getting my information secondhand (from ISPF\nSMP/E inquiries) if it is available firsthand, from the ptfs and SMP/E\nentries themselves.  Learn ABOUT your system FROM your system!\n\n      Good luck in these and all future endeavors.  I'll see you next\nmonth.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   THE \"PTF\" INQUIRY CLIST.\n\n            This clist, which takes advantage of the capabilities of\n            the \"REVIEW\" TSO command on the CBT MVS Tape (File 134\n            for source and File 135 for load), is extremely simple,\n            but extremely useful.  Assemble REVIEW from File 134 or\n            copy the load module from File 135 and have fun.\n\n\n\n PROC 1 SYSM\n REVIEW 'SMPE.SMPPTS(&SYSM)'\n /*\n /*  This assumes that your PTS dataset is called SMPE.SMPPTS.\n /*\n /*  Assuming the member name of this clist is PTF, and it resides\n /*   in a library in the SYSPROC ddname concatenation of your TSO\n /*   session, you merely execute  %PTF UY78914 to look at ptf UY78914.\n /*   It's that simple.  PF3 to end.  You're back where you were.\n /*\n\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n\nFIGURE 2.   THE SMP/E INQUIRY CLIST.  WE'LL CALL THIS CLIST \"SMPETSO\".\n\n       This CLIST invokes SMP/E in the foreground under TSO exactly\n       the same way as it would run in the background in batch.  Input\n       of commands and output of results go to the terminal.  Since\n       there might be quite a few lines of output, it is preferred\n       to run this CLIST in TSO \"Session Manager mode\", which can\n       preserve and print up to several thousand lines of TSO output.\n       See your TSO/E Customization Guide or this column in last\n       month's issue on how to set up your TSO session to run in\n       Session Manager mode.\n\n\n PROC  0  VOLID  CSI('SMPE.GLOBAL.CSI')  UNIT(DISK)  TYPE(SYS1)  NOLOG -\n          SYSOUT  LOGDISP(MOD)  NOPTS  LIST()  /**  YES OR NO  **/\n\n   SET VOLID = XRS003       /*  SMP-CONTROLLED PACK  */\n   IF LIST = YES  THEN  CONTROL LIST\n   ELSE  IF LIST = NO  THEN  CONTROL NOLIST\n\n   CONTROL PROMPT\n\n   WRITE ***********************************************************\n   WRITE *                                                         *\n   WRITE *     WELCOME TO THE SMP INQUIRY SYSTEM.  THIS MEANS      *\n   WRITE *          MAKE INQUIRIES ONLY  ........                  *\n   WRITE *                                                         *\n   WRITE ***********************************************************\n   WRITE\n   WRITE                  T Y P E  =   &TYPE\n   WRITE\n   WRITE             FOREGROUND EXECUTION OF SMP/E\n   WRITE\n   WRITE              SYSTEM DEFAULT  ====>  &TYPE\n   WRITE\n   WRITE            TYPE  =  &TYPE  MVS SP 4.1.0  DFP/ESA\n   WRITENR              ENTER DESIRED TYPE ====>\n   READ ANS\n\n   IF &LENGTH(&STR(&ANS)) \u00ac= 0  THEN SET TYPE=&STR(&ANS)\n   IF &TYPE = SYS1    THEN SET VOLID = XRS003   /*  TARGET PACK  */\n   IF &TYPE = SYS1    THEN SET DIST  = SMPDL1   /*   DLIB  PACK  */\n\n   WRITE\n   WRITE   YOU HAVE SPECIFIED  &TYPE AS THE SYSTEM.\n   WRITE   TARGET = &VOLID   ----  DISTRIBUTION = &DIST\n   WRITE\n\n   ERROR GO TO ENDALL\n   ATTN  GO TO ENDALL\n\n   ALLOC FI(SMPLIST) DA(*)\n   ALLOC FI(SMPCNTL) DA(*)\n   ALLOC FI(SMPRPT)  DUMMY\n\n   IF &NOLOG = NOLOG THEN ALLOC FILE(SMPLOG) DUMMY   /* NO SMP LOG */\n     ELSE ALLOC FI(SMPLOG) &LOGDISP KEEP DA('SMPE.GLOBAL.SMPLOG')\n\n   IF &NOPTS \u00ac= NOPTS  AND  TYPE = SYS1    +\n     THEN ALLOC FI(SMPPTS) SH REUSE DA('SMPE.GLOBAL.SMPPTS')\n\n   IF &SYSOUT = SYSOUT THEN ALLOC FI(SMPOUT) SYS(T)  /* HELD CLASS */\n     ELSE ALLOC FI(SMPOUT)  DA(*)\n\n   CALL  'SYS1.LINKLIB(GIMSMP)' 'CSI=&CSI'\n\n  ENDALL:  ERROR OFF\n           ATTN  OFF\n           FREE FI(SMPLIST SMPRPT SMPCNTL SMPLOG SMPOUT SMPPTS)\n\n  END\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9212DE": {"ttr": 11018, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x93!\\x0f\\x01\\x00)\\x9f\\x11G\\x01X\\x01X\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 344, "newlines": 344, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         December 1992\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\n Sam Golob is a Senior Systems Programmer living\n in New Jersey.\n\nPUTTING YOUR TOOLS TOGETHER - PART I.\n\n      In practical work, we have problems to solve and tasks to do.\nEach one of us must marshal the tools we have available to attack the\ntask at hand.  For the past four years, much of this column was\ndevoted to adding \"another tool\" to your collection of \"weapons\".\nNow, I'd like to change focus a bit.\n\n      Consideraions that affect the speed of our work are the main\ntopic we shall deal with in these next few issues.  How can you\narrange your tools so they are all at hand and ready quickly?  How can\nyou bring all your firepower to bear on your current problem, now!\n\n      Just as important as having a tool installed, is being able to\ndeploy it quickly when it is needed.  We want to find ways of getting\nthe immediate use of a tool right now, to be able to throw the tool at\nthe problem right in front of us.  For example, if you have to look at\nsome output, you wouldn't want to interrupt your current work.  If you\nneed to allocate a new dataset, you'd like to do it without\ninterrupting what you're currently in the middle of.  In this month's\narticle, I'll show you how to get this accomplished, and do much more.\n\n      Learning how to quickly use your tools is as much a part or our\ntrade as owning the tools.  We continually work to refine \"technique\"\nskills as we progress in our careers.  Every software product we use\ncontains special command sequences or fine points, to help us do our\njobs better.  Knowledge of these commands is sometimes crucial to\nperforming quick and accurate work.  When it is relevant, I'll bring\nsuch commands into our discussion.\n\n      What shall we talk about?  We will have to split this subject\ninto several installments because there are different topics that must\nbe mentioned.  Probably the most important one is ISPF command table\nentry customization.  Using ISPF command tables cleverly is probably\nthe easiest way to obtain speed at your work.  We'll discuss ISPF\ncommand tables today.  Next time, I'd like to mention the big software\ntoolsets which integrate multiple function.  The one I am most\nfamiliar with is the vendor product PDSTOOLS and its far more\nprimitive predecessor the PDS TSO command.  This tool alone allows you\nto throw hundreds of utility operations at one problem in a minimum\namount of time.  Then I'd like to discuss native TSO, both with and\nwithout ISPF.  TSO itself was invented to quickly accomplish work on\nthe system.  I want to talk about TSO Command tools in general, both\nIBM-supplied, and tools written by users outside of IBM.  We shall\nalso talk about ISPF edit macro power, and we'll bring in other\nintegration hints.\n\n      The emphasis in this series will be on integrating multiple\nfunction.  We want to make different software operations available\n\"close together\" to quickly deploy the maximum firepower we need to\nget a job done.  It all means increased productivity, and saved\nhours.\n\n\nWHY ISPF COMMAND TABLE ENTRIES ARE THE BEST WAY TO START.\n\n      Wouldn't it be nice, when you need something on the computer,\nto say to the computer (StarTrek style):  \"Computer.  Get this for me.\"\nAnd the computer will go ahead and get it.\n\n      In my opinion, the most important step you can take to integrate\nyour tools, is learning how to customize ISPF command tables.  When\nyou enter a command on the command line in an ISPF screen, the command\ntable entries are scanned first.  The computer \"goes ahead and gets\nit\" without further ado.  It's quick and direct.\n\n      These command table entries have a lot of power.  They have full\naccess to the ISPF \"SELECT\" service.  This means that any ISPF action\nwhich is accessible by a panel, is also just as accessible through\na direct command.  You tell the computer:  \"Computer, get me this!\"\nAnd the computer does it, as long as you're under ISPF, and the command\nis entered in the command table.\n\n      Frequently accessed ISPF functions should be put in the command\ntables.  This will be to your tremendous advantage for the following\nreason:  In ISPF Versions 2 and 3, there is capability to perform\nfunctions recursively, one function on top of another.  The first\nfunction that you started with, isn't disturbed while a second\nfunction is invoked that overlays the screen temporarily.  When you\nexit from the second function, you're back in the first function\nexactly where you left off.  This can all be done on one \"split\" of\nthe screen.  It doesn't affect the second split, which is available\nat the same time for other maneuvers.\n\n      This means that if you are in the middle of editing a member of\nsome dataset, you can invoke ISPF 3.2 (or any other function) \"on top\"\nof the edit, without disturbing the edit.  Then you can allocate,\ndelete or inquire about the other dataset you need, press the END key\n(PF3), and you're still in the edit where you were before.  You don't\nhave to be in the EDIT function to use command table entries.  You can\nbe in any ISPF function.  That's why good command table entries can be\nmore basic to your productivity than a collection of edit macros.\n\n      I'm not telling you not to use edit macros.  In fact, we'll\ndiscuss the great power of edit macros in a later issue.  I am asking\nyou to marshal your forces and use EVERYTHING you have.  Our emphasis\nis to INTEGRATE YOUR POWER and have all functions available at your\nfingertips.  ISPF commands are the quickest start to achieve this.\nThat's why command table entries are the best things to begin with.\nThey're instant, they are always available, and they don't disturb\nyour current work.\n\n\nADDING AND CHANGING ISPF COMMAND TABLE ENTRIES.\n\n      ISPF tables, of which command tables are a subset, belong to\npartitioned datasets that are accessed by two ddnames.  The input ddname\nfor tables is called ISPTLIB.  ISPTLIB is usually a concatenation of\ndatasets containing already prepared tables.  The output ddname for\ntables is called ISPTABL.  When you change a table, it must be pointed\nto by the ddname ISPTABL.  Most often, the ISPTABL ddname will point\nto only one partitioned dataset.\n\n      Command tables are certain members of an ISPF table dataset.\nCommand table members have a very specific naming convention.  In order\nfor a member to be a command table the last four letters of its name\nmust be \"CMDS\".  The APPLID of the ISPF application must be the\nbeginning of the member name.  For example, if the applid of the\ncurrent application is \"ISR\", then the command table entry governing\nthat application has to be named \"ISRCMDS\".  If the application name is\n\"GIM\", then the governing command table must be called \"GIMCMDS\".\n\n      There is an ISPF function whose specific purpose is to change\ncommand table entries.  In most installations, this function is 3.9\nfrom the standard PDF menu.  Upon entry, you'll see a screen that\nasks you for the applid you want to look at.  You just enter the\napplid name alone (for example:  ISR).  The function then looks for a\nmember in your ISPTABL ddname concatenation that is called ISRCMDS.\nThen it will display a list of the current table entries for that\napplication.\n\n      There is one catch.  A command table that is currently being\nused by your ISPF/PDF session is enqueued upon; it may be browsed (in\nISPF version 3.2 or later), but it cannot be changed.  I have a\ncertain trick to get around this problem.  Suppose I want to change\nthe ISRCMDS table.  Under ISPF 3.9, this table (and ISPCMDS too) are\nbeing enqueued upon by ISPF and cannot be changed by ISPF 3.9.  I\ncreate an exact copy of the ISRCMDS member (using ISPF 3.3 member\ncopy) and call it XSRCMDS.  When the ISPF 3.9 entry screen asks me for\nthe applid, I enter \"XSR\".  See Figure 1.  This gives me the first\nXSRCMDS member in the ISPTABL ddname concatenation.  Since XSR is not\na currently used ISPF application, I can change the XSRCMDS member by\nadding and deleting table entries as I please.  Then I rename ISRCMDS\nto another name, make a copy of XSRCMDS called ISRCMDS, and I make\nsure the dataset is at the top of my ISPTLIB ddname concatenation.\nFor the new table to become active I just get all the way out of ISPF,\nand go back into ISPF again.  If I want to make more changes to the\ntable, my XSRCMDS member is still an exact copy of ISRCMDS, so I am\nstill properly positioned to make further changes.  See Figures 2 and\n3.\n\n      Our initial goal in speeding up our work is not to require\npanel entry to get to a function.  Figure 2 illustrates some SELECT\nstatements that may be found in the ISPF main menu panel called\nISR@PRIM.  Figure 3 shows how these same SELECT statements can be\nconverted into direct commands, so you can quickly access each\nfunction without having to go through panels first and interrupting\nyour work.\n\n      Now that we have an idea of how to change table members and\ntable entries, we'll discuss the kinds of changes we might make.  Our\naim is to enhance our ISPF sessions under TSO, so that access to our\ntools becomes more quick.\n\n      See Figure 3 for an illustration of what I've done to immediately\nadd power to my own ISPF sessions.\n\n      My own scheme for adding commands is to prefix an \"I\" to a\nnormal ISPF function.  For example, if I want to create a command\nto duplicate ISPF 3.2 dataset manipulation and inquiry, I name the\ncommand \"I32\".  That makes the command easy to remember, and it does\nnot usually conflict with other ISPF and TSO commands.  Please see\nFigure 3 for more specific details of what I've done.  Remember that\nI've copied IBM's SELECT statements from IBM's panels, and the exact\nwording of the statements might depend on which release of ISPF you\nare running.  When you change releases, you have to review your\nexisting command tables to make them correspond to IBM's new panels.\nI always make my changes to a copy of the IBM-supplied command table\nfrom the current release of ISPF.\n\n      Space is short and I have to end now.  Please use the figures\nand do what you can to improve the state of life at your place.  Best\nof luck.  See you next month.\n\n\n    *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE 1.   Command table edit entry panel from ISPF.  This panel\n            is accessed from the PDF main menu by entering, \"3.9\".\n            The bottom of the panel contains explanatory instruction\n            written by IBM, as is illustrated.\n\n\n\n------------------------ COMMAND TABLE UTILITY -------------------------\nCOMMAND ===>\n\nENTER/VERIFY APPLICATION ID BELOW:\n  APPLICATION ID ===> XSR\n\n\nThe name of the command table to be processed is formed by prefixing\nthe application id to the string 'CMDS'.  For example:\n  APPLICATION ID ===> TST\nresults in a command table name of 'TSTCMDS'.\n\n\n\n\n\n\n\n    *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE 2.   This is the SELECT service portion of the main ISPF/PDF\n            menu panel named ISR@PRIM.  This part of the ISR@PRIM\n            panel defines options or services that may be selected\n            from the command line of the panel.  You are able to get\n            into the different options allowed, because these\n            invocation definitions are present in the \"selection\"\n            part of the ISR@PRIM panel.  Please note that you can\n            only get to these options from within the ISR@PRIM panel,\n            but from nowhere else within ISPF or PDF.\n\n            See Figure 3, which shows how these entries may be\n            transformed into direct commands that may be executed\n            from any ISPF command line while in application \"ISR\".\n\n\n\n   &ZSEL = TRANS( &ZQ\n                 0,'PANEL(ISPOPTA)'\n                 1,'PGM(ISRBRO) PARM(ISRBRO01)'\n                 2,'PGM(ISREDIT) PARM(P,ISREDM01)'\n                 3,'PANEL(ISRUTIL)'\n                 4,'PANEL(ISRFBA)'\n                 5,'PGM(ISRJB1) PARM(ISRJPA) NOCHECK'\n                 6,'PGM(ISRPTC)'\n                 7,'PGM(ISPYXDR) PARM(ISR) NOCHECK'\n                 8,'PANEL(ISRLPRIM)'\n                 9,'PANEL(ISRDIIS)'\n                10,'PGM(ISRSCLM) NOCHECK'\n                 F,'PANEL(IFAMU01) NEWAPPL(FAXE)'\n                 O,'PANEL(NEWPNL) NEWAPPL(NONI)'\n                 P,'PANEL(PDS@PRIM)'\n                 C,'PGM(ISPTUTOR) PARM(ISR00005)'\n                 T,'PGM(ISPTUTOR) PARM(ISR00000)'\n               ' ',' '\n                 X,'EXIT\n                 *,'?' )\n\n\n\n\n    *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE 3.   This is a sample of a modified ISPF command table XSRCMDS\n            which is copied to the member ISRCMDS of the table library\n            pointed to by the ISPTABL ddname in ISPF under TSO.  Notice\n            how SELECT statements in this table were copied from\n            SELECT definitions that came from ISPF panels.  See Figure 2\n            for comparison.  The commands in this table are much more\n            easily accessible to an ISPF user.  You don't have to start\n            from the ISR@PRIM panel to use these commands.  You can\n            enter them from any ISPF command line.\n\n\n\nCOMMAND TABLE - XSRCMDS ----------------------------------- ROW 36 TO 42 OF 79\nCOMMAND ===>                                                  SCROLL ===> CSR\n\nINSERT, DELETE, AND CHANGE COMMAND ENTRIES.  UNDERSCORES NEED NOT BE BLANKED.\nENTER END COMMAND TO SAVE CHANGES OR CANCEL TO END WITHOUT SAVING.\n\n\n     VERB      T  ACTION\n                     DESCRIPTION\n\n'''' SDSF      0  SELECT PGM(ISFISP) NEWAPPL(ISF)\n                     INVOKE SDSF DIRECTLY FROM ANY ISPF COMMAND LINE.\n'''' SMPE      0  SELECT PGM(GIMSTART) PARM(&ZCMD) NOCHECK NEWAPPL(GIM)\n                     INVOKE SMP/E ISPF INQUIRY DIRECTLY FROM CMD LINE.\n'''' PDE       0  SELECT PGM(PDSE) PARM(PDSE &ZPARM ISPMODE)\n                     RECURSIVE EXECUTION OF PDSTOOLS (SYSPROG UTILITIES)\n'''' P84       0  SELECT PGM(PDS84) PARM(PDS84 &ZPARM ISPMODE)\n                     RECURSIVE 'ON-TOP' EXECUTION OF PDS VERSION 8.4\n'''' BOTTOM    3  ALIAS DOWN MAX\n                     ALLOW SCROLL TO BOTTOM TO BE ABBREVIATED, \"BOT\".\n'''' RIGHT     2  SETVERB\n                     SCROLL RIGHT - ALLOW ABBREV TO 2 CHARACTERS, \"RI\".\n'''' LEFT      2  SETVERB\n                     SCROLL LEFT - ALLOW ABBREV TO 2 CHARACTERS, \"LE\".\n'''' I0        0  SELECT PANEL(ISPOPTA)\n                     RECURSIVE 'ON-TOP' EXECUTION OF ISPF 0\n'''' I1        0  SELECT PGM(ISRBRO) PARM(ISRBRO01)\n                     RECURSIVE 'ON-TOP' EXECUTION OF ISPF 1\n'''' I2        0  SELECT PGM(ISREDIT) PARM(P,ISREDM01)\n                     RECURSIVE 'ON-TOP' EXECUTION OF ISPF 2\n'''' I3        0  SELECT PANEL(ISRUTIL)\n                     RECURSIVE 'ON-TOP' EXECUTION OF ISPF 3\n'''' I31       0  SELECT PGM(ISRUDA) PARM(ISRUDA1)\n                     RECURSIVE 'ON-TOP' EXECUTION OF ISPF 3.1\n'''' LIBRARY   3  SELECT PGM(ISRUDA) PARM(ISRUDA1)\n                     RECURSIVE 'ON-TOP' EXECUTION OF ISPF 3.1 - INVOKE AS \"LIB\"\n'''' I32       0  SELECT PGM(ISRUDA) PARM(ISRUDA2)\n                     RECURSIVE 'ON-TOP' EXECUTION OF ISPF 3.2\n'''' DATASET   3  SELECT PGM(ISRUDA) PARM(ISRUDA2)\n                     RECURSIVE 'ON-TOP' EXECUTION OF ISPF 3.2 - INVOKE AS \"DAT\"\n'''' I33       0  SELECT PGM(ISRUMC)\n                     RECURSIVE 'ON-TOP' EXECUTION OF ISPF 3.3\n'''' I34       0  SELECT PGM(ISRUDL) PARM(ISRUDLP)\n                     RECURSIVE 'ON-TOP' EXECUTION OF ISPF 3.4\n\n           .  .  .  .  .  data omitted for brevity  .  .  .  .  .\n\n'''' I314      0  SELECT PGM(ISRSFM)\n                     RECURSIVE 'ON-TOP' EXECUTION OF ISPF 3.14\n'''' I4        0  SELECT PANEL(ISRFPA)\n                     RECURSIVE 'ON-TOP' EXECUTION OF ISPF 4\n'''' I5        0  SELECT PGM(ISRJB1) PARM(ISRJPA) NOCHECK\n                     RECURSIVE 'ON-TOP' EXECUTION OF ISPF 5\n\n           .  .  .  .  .  data omitted for brevity  .  .  .  .  .\n\n'''' I10       0  SELECT PGM(ISRSCLM) NOCHECK\n                     RECURSIVE 'ON-TOP' EXECUTION OF ISPF 10\n'''' TUTORIAL  2  SELECT PGM(ISPTUTOR) PARM(ISR00000)\n                     RECURSIVE 'ON-TOP' EXECUTION OF ISPF TUTORIAL - AS \"TU\".\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9301JA": {"ttr": 11269, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x93!\\x0f\\x01\\x00)\\x9f\\x11G\\x01\\x9f\\x01\\x9f\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 415, "newlines": 415, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          January 1993\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\n Sam Golob is a Senior Systems Programmer living\n in New Jersey.\n\nPUTTING YOUR TOOLS TOGETHER - PART II.\n\n      Last month, we began a \"miniseries\" with the emphasis upon\nconsolidating your tools.  It's important to possess tools.  It's\njust as important to mobilize those tools quickly when you have a\nproblem to solve.\n\n      Much of a system programmer's wasted time comes from the\nfollowing scenario:  You are solving half a problem with one tool.\nIn order to go further, you have to use another tool that has its\nown different environment.  Possibly the first tool is online, a TSO\ncommand.  The second tool can only be run easily via a batch job.\nThere are setup delays, possibly of several minutes, in between.  It\nwould certainly be better if the two parts of the solution were\nbrought closer together.\n\n      As we detailed last month, a powerful way to bring tools\ncloser to the programmer is ISPF command table customization.  If an\napplication can be invoked instantly through the execution of a single\ncommand, much of a user's time is saved by eliminating complicated\nsetups.  This month, we'll go to the second stage and talk about some\nexperiences using a \"tool package\".  In a tool package, a large number\nof utility functions are available within a single environment, to\nthrow a great variety of fixup and diagnosis aids at one problem.\n\n      Most tool packages are vendor products.  The format of this\ncolumn dictates that I not get \"political\".  I want the largest group\nof readers possible to get a large amount of information they can use\nright now, through the material they read here.  I don't want to push\none vendor's product over another, because many MVS sites aren't\nlicensed for a particular vendor's product.  We would like all MVS\nsites to gain good benefit from what is written here, not only those\nlicensed for a particular product.\n\n      On the other hand, leaving out any mention of tool packages\nwould be too great a loss.  With the tool packages I use, I am\nprobably four times more efficient time-wise than the average systems\nprogrammer.  My personal experience in this area is just too important\nto skip over.  But my own favorite tool package has two versions--a\nfree public version that any shop can install, and a vendor version\nthat is more than twice as powerful.  By using this pair of tool\npackages as an illustration, we can show the benefits to be gained,\nand at the same time make it possible for any shop to put much of this\nknowledge into actual practice.\n\n      I am using PDSTOOLS (formerly PDS/E Sysprog Utilites) from Serena\nInternational as my tool package example here.  The reason is twofold.\nFirst, I have extensive experience over a period of seven years in\nusing that product.  PDSTOOLS is the cornerstone of my own efficiency\nas an MVS systems programmer.  I use PDSTOOLS during 95 percent of my\nworking day.  Second, there exists a more primitive free version\ncalled PDS version 8.4 that is on the CBT MVS Tape (File 182)\nobtainable from Naspa (414-423-2420) or from SPLA (305-284-6257).  We\nthus have an opportunity for everyone in any MVS shop to try what\nwe're talking about for themselves.\n\n      There's one more thing I have to say before we go to specific\ndetails.  Having more than one tool package is not always redundant.\nIn fact it can be very effective for systems programmers, because\nseveral different tool packages can often be made to work efficiently\ntogether.  This is in line with our thinking here.  Please refer to a\nrelevant article in the March 1992 issue of \"Technical Support\" called\n\"Software Integration Improves Productivity and Performance\" by Jeff\nFurman.  That entire article shows how various combinations of vendor\ntool packages add up to a greater whole than the sum of their separate\nparts.\n\n\nWHERE A TOOL PACKAGE SPEEDS THINGS.\n\n      A tool package like PDSTOOLS saves time in two ways.  First, it\nduplicates functions available more awkwardly elsewhere.  For example,\nwith PDSTOOLS it is trivial to create any number of aliases for a pds\nmember (source or load module).  If it is necessary to create an alias\nfor a load module, the last thing you want to do is to fool with the\nlinkage editor.  Just enter a command and you're done.  PDSTOOLS gives\nthat to you.  There's no anguish--just a very simple operation:\n\"ALIAS memname aliasnme\".\n\n      The second thing that a package like PDSTOOLS will do is to supply\nfunction that is not available elsewhere.  Suppose that you really have\nto use the linkage editor in adding an alias name to an existing load\nmodule.  PDSTOOLS will effortlessly generate accurate re-linkedit JCL\nfrom an existing load module in a library.  That functionality is not\nreadily available elsewhere.  PDSTOOLS will effortlessly write the\ngenerated JCL to a dataset, where you can edit it and add control cards\nto your heart's content.  You don't have to use the linkage editor\nmanual to reconstruct your original module.  It's easy with PDSTOOLS\nto obtain linkage editor control cards that preserve your module in a\nnew pass through the linkage editor.\n\n      In a day's work, the result of using PDSTOOLS is the saving of\nlarge amounts of time and anguish while doing simple repetitive\nprocesses.  PDSTOOLS even eliminates the repetition entirely\nsometimes.  Through the concept of \"member groups\" in place of single\nmembers, PDSTOOLS allows one command to operate the same way at\nassembler speed, over a carefully selected group of many pds members.\nThe result is often twenty- or thirty-fold time savings!  You see that\na package like this pays for itself very quickly.\n\n      As impressive as these illustrations are, they truly do not even\nbegin to show the main advantage of PDSTOOLS in time saving.  The tool\npackage PDSTOOLS enables a system programmer to literally throw\nhundreds of tools at one problem in one place, dealing with many\ndatasets.  Judicious entries to your ISPF command tables, as illustrated\nlast month, allow even more tools to be brought into juxtaposition with\nthe many integrated activities going on in PDSTOOLS alone.  When you\nget good at this stuff, you'll be a wonder of wonders in your shop\nmuch of the time.\n\n      We'll present a large example to give a hint at this.  I must\nemphasize that you're only getting a small taste.  I can easily talk\nfor two weeks of eight-hour days on this subject without much\nrepetition.  A tool package like PDSTOOLS is really essential.  It\nopens up a new world for you.\n\n\nPUTTING THE TOOL PACKAGE TO USE.\n\n      Let's say we've got some trouble with our working copy of\nSYS1.LINKLIB which, of course, is in the system linklist.  We're\ngetting S806 abends for some of the modules on our XA or ESA system.\nWe're pretty sure that the members are there, even though the S806\nabend seems to tell us that they're not there.  The first thing to\ntry, of course, is the operator command:  \"F LLA,REFRESH\".  If the\nreason for not finding the modules is that LLA doesn't know about\nthem, this will cure the problem.\n\n      Suppose that doesn't work.  Trying to execute the programs still\nresults in the S806 abend.  If you have PDSTOOLS, there are some obvious\npaths to follow.\n\n      The first thing to try is to get into the dataset by entering\nthe TSO command:  \"PDSTOOLS SYS1.LINKLIB\".  If you have the free PDS\npackage, you enter:  \"PDS SYS1.LINKLIB\".  From now on, I'll assume\nyou have the vendor package.  If our actions can't be done with the\nfree package, I'll tell you so.  Once you're in PDSTOOLS pointing to\nthe dataset, enter the subcommand:  \"USAGE ALL \" or \"U A\".  You'll see\na detailed display of the characteristics of your copy of SYS1.LINKLIB,\nincluding the number of its extents.  If the secondary extent size is\nnonzero and there are secondary extents present, there is a possibility\nthat an extent was added after IPL.  Since the extents of the linklist\ndatasets are made known to the system only at IPL time, the system will\nnot know about any modules found in a new secondary extent of\nSYS1.LINKLIB and you'll get a S806 abend if you try to execute them.\n\n      See Figure 1 which shows the output of \"USAGE ALL\".  Among the\nmany things you'll see, there is a CCHHR and TTR description of the\ndataset's extents.  Then type \"MEMLIST : \" which means, \"take a member\nlist of all the dataset's members.  Type \"RIGHT\" or PF11 to get the\nalternate display which lists all the member TTR starting locations.\nFinally type:  \"SORT TTR\" which will sort the full member list in TTR\norder.  Type \"U A\" again to redisplay the TTRs of the newest extents.\nWrite them down.  Then type MEMLIST again to redisplay the sorted\nlist of members.  By going down toward the bottom of the sorted member\nlist, you can easily spot which members are in the second, third, or\nfourth extents.  If the members in the last extent are the same ones\ngetting the S806 abends, we're getting warm.  Confirmation can be done\nas follows:  Run the failing job with a STEPLIB DD card pointing to\nSYS1.LINKLIB.  STEPLIB does a directory search for the module, and\nbypasses the linklist search.  If the STEPLIB search works, circumvent\nthe problem using the STEPLIB DD card, until you do an IPL to inform\nthe system of the new linklist extents.\n\n      Suppose we still have trouble.  With the PDSTOOLS product at the\nRelease 3.1.0 level or higher, we can issue:  \"FINDMOD modulnam\" from\nthe command line, and PDSTOOLS will issue its own module searches and\ndisplay the results.  The FINDMOD command of PDSTOOLS will display all\nplaces on the working system where the module is found, or it will tell\nus that it is not found.  If we want to look at all the found versions\nof the module, we issue:  \"FINDMOD modulnam CHANGE LIB(1)\" to go to the\nlibrary of first occurrence, or LIB(2) to go to the library of second\noccurrence, and so on.  A MEMLIST display on the module name in the new\nlibrary will show the linkedit date and some other telltale\ncharacteristics of that version of the module.  An ATTRIBute display on\nthe module will show linkedit attributes RENT or REUS and so forth,\ndisplaying the size and entry point  of the module also.  Entering\n\"HISTORY modulnam\" will display the linkedit IDR records of all the\nCSECTs and optionally, will display the assembler or compiler IDR\nrecords.  The DISASM command will disassemble the module quickly.  The\n\"DISASM modulnam REASM\" command will disassemble the module in\nre-assemblable format, wrapping correct assembly and linkedit JCL\naround the disassembled source code.\n\n      Getting back to our problem, the VERIFY command against our\nmodule will show us any abnormalities or errors in the structure of the\nmodule, or in its ability to be fetched.  A VERIFY command against all\nmembers of the load library will reveal overall weaknesses in the\nlibrary.  This \"VERIFY : \" command against the whole library will\nshow all the modules having bad internal structure.  After running all\nthese tests, we can usually zero in on the source of the difficulty.\n\n      You can now see how PDSTOOLS can throw dozens of different\nactions, tools and tests against a single library, or a single module\nname.  These things can all be done in a very few minutes.  Hundreds\nof other dataset-related problems can be similarly dispatched in very\nshort order.  This is what I'm trying to show; this is the advantage\nof having and using a top-notch tool package.\n\n      In truth, PDSTOOLS possesses more than 1500 individual utility\nfunctions that can be applied to a great variety of common and uncommon\nproblems.  The clarity of proof that a problem situation exists is often\nunparalleled.  PDSTOOLS will often demonstrate the existence and cause\nof a bad situation beyond all doubt.  PDSTOOLS can often fix the\nproblem also.\n\n      A simple case of this is when a load module which is not\nre-entrant was linkedited by mistake with the RENT attribute.  As a\nresult, it does not function properly when it is executed.  The\nATTRIB command of PDSTOOLS will reveal the existence of the problem\nwith its display.  But the \"ATTRIB modulnam NORENT NOREUS\" command\nwill actually remove the re-entrancy and reusability attributes from\nthe directory entry of the load module, thereby curing the problem in\nan instant by fixing the linkedit mistake.\n\n      I don't have space to say any more now, but I hope that I've\nshown a tiny bit of the usefulness of a tool package.  If you're\nstimulated to try PDS 8.4, PDSTOOLS, or any other tool package, I've\naccomplished my purpose here.  Good luck and much success.  I'll be\nseeing you next month.\n\n\n    *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE 1.   PDSTOOLS \"USAGE ALL\" display, to show the structure and\n            characteristics of a dataset, based on the contents of its\n            VTOC entry, or FORMAT 1 DSCB.  Please note the wealth of\n            detail.  This command can be shortened if \"USAGE\" is\n            entered without any parameters.  In that case the 'extent'\n            detail, starting with the PDS184I messages, is left out.\n            Note that in the case of a dataset having more than 3\n            extents, when it is necessary to have a FORMAT 3 DSCB to\n            describe the additional extents, PDSTOOLS will format this\n            FORMAT 3 DSCB for you also.  All this material can be\n            written out from the PDSTOOLS log, to a disk file or a\n            SYSOUT class of your choice.\n\n\n\nPDS300A ENTER OPTION -- DSN=SYS1.LINKLIB,VOL=SER=MRS002  MEM=\n>u all\nPDS200I DISP UNIT     RECFM LRECL BLKSIZE   ALLOCTRK FREETRK SECONDARY FREEDIR\nPDS200I SHR  3390     U         0   32760   4X  1688     638   112 TRK     327\n\nPDS223I This is a linklist dataset\n\nPDS224I This data set is APF authorized\n\nPDS180I Data set: CREATED    EXPIRES    LAST USE     UPDATED  LASTUSE  FIRSTUSE\nPDS180I        1991/06/17   **NONE**  1992/11/19  1991/07/10  DMV0016  DMV0003B\n\nPDS181I Extents in tracks: 1352, 112, 112, 112\n\nPDS182I Tracks: ALLOCATED    USED    FREE  EXTENTS\nPDS182I              1688    1050     638        4\n\nPDS183I Directory: BLOCKS    USED    FREE   TRACKS  MEMBERS  ALIASES\nPDS183I               840     513     327       19     3043      559\n\nPDS184I EXTENT  UCB  LO TT-HI TT  TRACKS     LOW CCHH-HIGH CCHH    BOUNDARY\nPDS184I ------  ---  ----- -----  ------  ----------- -----------  --------\nPDS184I      0  868  00.00 05.47    1352  05.F3.00.00 06.4D.00.01  TRK\nPDS184I      1  868  05.48 05.B7     112  00.1A.00.03 00.21.00.09  TRK\nPDS184I      2  868  05.B8 06.27     112  00.21.00.0A 00.29.00.01  TRK\nPDS184I      3  868  06.28 06.97     112  00.36.00.08 00.3D.00.0E  TRK\n\n\nPDS185I Format 1 DSCB at 0456000128\nPDS185I 0   4   8   C  10  14  18  1C  20  24  28  2C  30  34  38  3C  40  44\nPDS185I SYS1.LINKLIB                                103B$....$.y......DMV0016\nPDS185I EEEF4DCDDDCC44444444444444444444444444444444FFFC50B0050A000000CDEFFFF4\nPDS185I 2821B3952392000000000000000000000000000000001032B0F01B0800040044500160\n\nPDS185I  48  4C  50  54  58  5C  60  64  68  6C  70  74  78  7C  80  84  88\nPDS185I DMV00*........{.\"8.....bh.......y1....3...(...........................\nPDS185I CDEFF504000000C07F00000880070124AF0000F0004000001000200000200020005002\nPDS185I 44500C1400002001F8000002800049468101053006D01110A03010912010A09014605D\n\n\nPDS186D LOC NAME     VALUE        DESCRIPTION\nPDS186I --- ----     -----        -----------\nPDS186I 00  DS1DSNAM SYS1.LINKLIB\nPDS186I 2C  DS1FMTID F1           FORMAT IDENTIFIER\nPDS186I 2D  DS1DSSN  F0F3C25B00BF DATA SET SERIAL NUMBER\nPDS186I 33  DS1VOLSQ 1.           VOLUME SEQUENCE NUMBER\nPDS186I 35  DS1CREDT 5B00A8       CREATION DATE\nPDS186I 38  DS1EXPDT 000000       EXPIRATION DATE\nPDS186I 3B  DS1NOEPV 4.           NUMBER OF EXTENTS ON VOLUME\nPDS186I 3C  DS1NOBDB 0.           NUMBER OF BYTES USED IN LAST DIRECTORY BLOCK\nPDS186I 3D           00           RESERVED (ONE BYTE)\nPDS186I 3E  DS1SYSCD C4D4E5F0F0F1F640C4D4E5F0F0\nPDS186I 4B  DS1REFD  5C0144       DATE LAST REFERENCED\nPDS186I 4E  DS1SMSFG 00           SYSTEM MANAGED STORAGE FLAGS\nPDS186I 4F  DS1SCXTF 00           SECONDARY SPACE EXTENSION FLAG\nPDS186I 50  DS1SCXTV 0.           SECONDARY SPACE EXTENSION VALUE\nPDS186I 52  DS1DSORG 0200         DATA SET ORGANIZATION\nPDS186I 54  DS1RECFM C0           RECORD FORMAT\nPDS186I 55  DS1OPTCD 01           OPTION CODE\nPDS186I 56  DS1BLKL  32,760.      BLOCK LENGTH\nPDS186I 58  DS1LRECL 0.           LOGICAL RECORD LENGTH\nPDS186I 5A  DS1KEYL  0.           KEY LENGTH\nPDS186I 5B  DS1RKP   0.           RELATIVE KEY POSITION\nPDS186I 5D  DS1DSIND 82           DATA SET INDICATORS\nPDS186I 5E  DS1SCALO 88000070     SECONDARY ALLOCATION\nPDS186I 5E           112.         TRK SECONDARY EXTENTS\nPDS186I 62  DS1LSTAR 041924       TTR OF LAST USED TRACK AND BLOCK ON TRACK\nPDS186I 62           1,049.       TRACKS INTO THIS DATA SET\nPDS186I 65  DS1TRBAL 18,088.      BYTES REMAINING ON LAST TRACK USED\nPDS186I 67           F100         RESERVED (TWO BYTES)\nPDS186I 69  DS1EXT1  0100.05F30000.064D0001  EXTENT 1  1352 TRACKS\nPDS186I 73  DS1EXT2  0101.001A0003.00210009  EXTENT 2  112 TRACKS\nPDS186I 7D  DS1EXT3  0102.0021000A.00290001  EXTENT 3  112 TRACKS\nPDS186I 87  DS1PTRDS 045600052D   CCHHR OF ANY ASSOCIATED FORMAT 2 OR 3 DSCB\n\n  * - - - - -  ABBREVIATED BECAUSE OF LACK OF SPACE  - - - - - *\n\n         (SIMILAR INFORMATION ON THE FORMAT 3 DSCB'S FOLLOWS,\n          BECAUSE THIS DATASET HAS MORE THAN 3 EXTENTS.  )\n\n\n\n\n    *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE 2.   PDSTOOLS display of several commands that can be brought\n            to bear on one load module, or one library.  The point is\n            that a tool package such as PDSTOOLS can integrate dozens\n            of functions, and focus them on one problem area.  Thus it\n            is an excellent means of \"putting your tools together\".\n\n            Illustrated is the load module ACCOUNT from SYS1.LINKLIB.\n            The PDSTOOLS subcommands ATTRIB, HISTORY, and VERIFY are\n            shown, as well as a VERIFY run on the entire SYS1.LINKLIB\n            load library.  There are literally dozens of other functions\n            within PDSTOOLS which can be used to investigate a single\n            load module, or the entire library.\n\n\n\n- DSN=SYS1.LINKLIB,VOL=SER=MRS002  MEM=ACCOUNT\n>attrib account\nPDS020I ACCOUNT Attributes are: RENT, REUS\nPDS103I Entry point at 000000  --  IKJEFA00\nPDS104I Module length  001450  --      6K\nPDS064I Last link-edited on 91/03/20  by LKED 566528408  V03 M01\n\n>history account\n\n** HISTORY  ACCOUNT\nPDS062I User-supplied update history by CSECT -\nIKJEFA00     90/06/29    RSI93482483\nIKJEFA01     90/06/29    RSI90760150\nPDS064I Last link-edited on 91/03/20  by LKED 566528408  V03 M01\n\n>verify account\n\n** VERIFY   ACCOUNT\nPDS111I        8 physical blocks were input\nPDS112I    5,200 characters in the largest physical block\nPDS113I      741 characters per average physical block\n\n>verify :              (run against the entire SYS1.LINKLIB)\n\nPDS006I End of data set\nPDS111I    25,336 physical blocks were input\nPDS112I    32,760 characters in the largest physical block\nPDS113I     1,333 characters in the average physical block\nPDS114I        28 tracks could be regained by compressing this data set\nPDS115I     3,043 members were checked\n\nPDS130I The following is a track usage map of the data set\nPDS130I DDDDDDDDDDDDDDDDDDDXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nPDS130I XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nPDS130I XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nPDS130I XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nPDS130I XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nPDS130I XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nPDS130I XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nPDS130I XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nPDS130I XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nPDS130I XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nPDS130I XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nPDS130I XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nPDS130I XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nPDS130I XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nPDS130I XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nPDS130I XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nPDS130I XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX...........\nPDS130I X...........XXXXXXXXXXXXXXXXXL..............................\nPDS130I ............................................................\nPDS130I ............................................................\nPDS130I ............................................................\nPDS130I ............................................................\nPDS130I ............................................................\nPDS130I ............................................................\nPDS130I ............................................................\nPDS130I ............................................................\nPDS130I ............................................................\nPDS130I ............................................................\nPDS130I ........\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9302FE": {"ttr": 11521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x93!\\x0f\\x01\\x00)\\x9f\\x11G\\x01\\x9b\\x01\\x9b\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 411, "newlines": 411, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         February 1993\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\n Sam Golob is a Senior Systems Programmer living\n in New Jersey.\n\nPUTTING YOUR TOOLS TOGETHER - PART III.\n\n      This month we are concluding a series that I hope is helpful to\nall of you.  The idea is to present ways of getting more of your tools\ninto easier reach.\n\n      The first part of this series dealt with customizing your ISPF\ncommand tables, which has the effect of making numerous applications\ninstantly and recursively available for your use.  I think that the\nISPF command table presents the greatest single opportunity for\nbringing tools closer together.  Last month we presented the second\ninstallment, which dealt with tool packages.  These are integrated\ntool kit software packages that combine a large number of utility\nfunctions in one place.  With the use of one or more tool packages, a\ngreat number of your tools are already consolidated, making it easy to\nbring many different utility functions to bear on your current single\nproblem.\n\n      This month, in concluding the series, we'll briefly talk about\nthree areas:  ISPF edit macros, handy TSO commands, and obtaining\n\"private\" APF authorization for your TSO commands.  Being able to run\ncertain commands \"authorized\" can often be a big time saver.  Your own\n\"personal\" APF authorization will definitely be useful if you are the\nsystem doctor in your shop.\n\n\nISPF EDIT MACROS.\n\n      Most of us spent much of our day using the ISPF/PDF editor.\nWe edit JCL, data files, and program source.  The editor as supplied\nby IBM contains numerous primary commands as well as line commands.\nBecause most of us have spent a lot of time with the editor, we have\nbecome familiar with a large number of its commands and we use them\noften.\n\n      Starting with ISPF Version 2 and continuing with Version 3,\nIBM has supplied an add-on to the editor which assists the user\nenormously.  This is the edit macro feature.  Edit macros are a\nprogrammable interface to the commands of the ISPF editor.  By invoking\nan edit macro with one command (or a pfkey), complicated and repeatable\nmanipulations can be instantly accomplished.  You just have to take the\ntime to write the macro, or to learn to use somebody else's macro.\n\n      Edit macros can be either clists, REXX execs, or programs.  Most\nof the edit macros you'll come across are clists or REXX execs.\nProgram macros can be written in any of several languages; assembler,\nCOBOL, and PL/I are among them.  Edit macros that are clists or REXX\nexecs are invoked the same way that clists are, except that they only\nwork while you're editing a file or a pds member.  Program macros\naren't invoked that way.  If you want to run a program macro, you have\nto precede its name with an exclamation point.\n\n      For example, if you have a program macro called JCLFLOW, which\nmakes the ddnames in your JCL more orderly, you invoke the macro by\ntyping the command !JCLFLOW while editing your JCL.  JCLFLOW, which\nI've aliased as JF, can be found on the CBT MVS Tape on File 047.  It\ncomes from Jim Lane, a system programmer from Toronto.  See Figure 1\nfor \"before\" and \"after\" pictures of JCLFLOW invocation.  I use\nJCLFLOW to assist me while I'm writing or fixing JCL for jobs or procs.\nIt's quick and very helpful to create room when I'm adding new DD card\nparameters.\n\n      A nice collection of clist edit macros comes from Paul Davis,\nformerly of Houston, Texas, who now lives in Colorado.  This collection\nis found on File 095 of the CBT MVS Tape.  You can order the CBT Tape\neither from NaSPA (414-423-2420) or from SPLA (305-284-6257) at the\nUniversity of Miami in Florida.  Many of the NaSPA chapters give tapes\nout for free at their meetings (mine does).  It pays to go to chapter\nmeetings if you're fortunate enough to have a chapter nearby.\n\n      There isn't enough space to show in detail how these edit macros\ncan help you, but I've included Paul's table of contents in Figure 2.\nFrom Figure 2, you can get a good idea of the kind of jobs edit macros\nwill do, and how powerful they can be.  Of course, the possibilites\ninherent in the edit macro facility are almost limitless, and they offer\nan excellent opportunity for study and exploitation.  The rest is up to\nyou.  IBM's edit macro manual is called \"ISPF/PDF Edit and Edit Macros\",\nnumber SC34-4138 in ISPF Version 3.\n\n\nTSO COMMANDS.\n\n      TSO commands are your one-stroke servants.  If you've made a\ncollection of good commands accessible to your TSO session, you've\nshortened your daily work considerably.  Many files on the CBT Tape\ncontain big collections of useful TSO commands.  You might start\nwith Files 300, 270, and 134.\n\n      I recommend allocating one pfkey in ISPF for the name \"TSO\".\nThis may be done in ISPF option 0.3.  The reason is that TSO commands\nmay be executed from the ISPF command line by prefixing them with the\nword, TSO.  When you type a TSO command on an ISPF command line and\nyou have a \"TSO\" pfkey, pressing that key will prefix the typed\ncommand with the name \"TSO\" and will execute it as though you typed\nthe word \"TSO\" before it.  If you execute TSO commands often while in\nISPF, it saves a lot of time to have such a designated pfkey.\n\n\nAUTHORIZING TSO COMMANDS FOR YOUR PERSONAL USE.\n\n      Some of the TSO commands which you, as a system specialist, may\nneed to use, have to run APF authorized under TSO.  It will save you\nmuch time and grief to use commands such as CDSCB (change the DSCB) in\ndoing dataset management, for example.  CDSCB was written by Bill\nGodfrey, and is found on File 300 of the CBT Tape along with hundreds\nof other useful TSO commands that you can learn.  As the system doctor\nof your installation, you will want to authorize some commands for\nyour own use, without granting that ability to the general public.\n\n      There are three requisites for APF authorization of a program\nunder TSO.  These are:  The program has to reside in an APF authorized\nload library.  Load library authorization is controlled by a table\nwhose virtual address is found in the CVT at label CVTAUTHL.  This\ntable is loaded at IPL time from an IEAAPFnn member of SYS1.PARMLIB.\nNext, the program itself has to be linkedited with the authorization\nattribute set on in its directory entry.  That is done by the linkage\neditor if the control statement \"SETCODE AC(1)\" was coded at linkedit\ntime.  Finally, if the program is to be run from TSO, its name must\nappear in one of several tables designated for permitting authorized\nprograms to be run under TSO.\n\n      Older versions of TSO and TSO/E contained these tables in one of\nthe terminal monitor load modules, IKJEFT02.  The CSECT containing the\nlist of authorized TSO commands is called IKJEFTE2, and the CSECT of\nauthorized called programs is called IKJEFTE8.  IKJEFT02 and its\nnumerous aliases reside normally in SYS1.LPALIB.  The later versions\nof TSO/E have split these tables off into a separate module called\nIKJTABLS.  IKJTABLS is still in SYS1.LPALIB.  At those levels of\nTSO/E, IKJEFTE2 and IKJEFTE8 are not a part of IKJEFT02 any more,\nbut are part of IKJTABLS.  IKJTABLS at these levels does not contain\nany executable code, it only contains four different tables of program\nnames under four separate CSECTS.  Each table of names serves a\ndifferent purpose.  See IBM's \"TSO/E Customization\" manual for more\ndetails.  See Figure 3 for a CSECT map of IKJTABLS.\n\n      Most installations now put their authorized TSO commands and\nprograms called from TSO into a SYS1.PARMLIB member called IKJTSOnn.\nThese entries in the PARMLIB member allow authorization of programs\nand commands under TSO for the entire installation.  Most installations\ndo not bother using IKJTABLS any more.  However, the designers of TSO/E\nhave kept the module IKJTABLS available and usable.  For our purposes,\nwe can take great advantage of this fact.\n\n      An authorized library run as a STEPLIB in the TSO logon procedure\nwill allow the system doctor to get all the power he or she needs.  The\nparticular installation will not want to allow this for ordinary TSO\nusers.  Our trick is to make a copy of the IKJTABLS module with all its\naliases, expand the number of its entries greatly through reassembly\nand re-linkediting, copy all the entries found in IKJTSOnn to these\ntables, add all the additional program names you want, and put the\nresulting IKJTABLS load module and aliases into your authorized STEPLIB.\nThat will override the installation's PARMLIB member IKJTSOnn, just\nfor you.  This works because the STEPLIB programs are executed ahead\nof programs in the LPA list, and ahead of the incore tables created\nfrom IKJTSOnn.\n\n      If you set this up, you'll never again complain of not being\nable to run a program authorized under TSO.  Of course, having a general\nTSO user doing that is not to be taken lightly.  Your installation's\nsecurity procedures will probably want to disallow it for most people.\nBut the facility is there if you yourself, and the MVS group, need it.\n\n      I have left out much detail from this installment because of\nspace requirements.  But there is gold and riches in what I have\nsaid.  The jewels have to be mined.  That must be done through your\nown personal effort.  Good luck and much success.  See you next month.\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   Illustration of the workings of the JCLFLOW program\n            edit macro.  Source for the program can be found on\n            File 047 of the CBT MVS Tape.  Notice that the macro\n            reads the JCL above and only affects DD cards.  The\n            result of the macro is the JCL below.  Execution time\n            of JCLFLOW is \"almost instantaneous\", even for big JCL.\n\n\n -- JCL BEFORE USING THE JCLFLOW PROGRAM EDIT MACRO.\n\n//SBGCTCZ JOB (A006,SYTM,99,99),'SAM-GOLOB',CLASS=S,MSGCLASS=K,\n//        NOTIFY=&SYSUID\n//*\n//COMPRESS EXEC PGM=IEBCOPY\n//SYSPRINT DD SYSOUT=*\n//I    DD  DSN=SBGCTC.A.DATA,DISP=SHR,UNIT=SYSDA,VOL=SER=ESAPAK\n//SYSUT3   DD UNIT=SYSDA,SPACE=(CYL,10)\n//SYSUT4   DD UNIT=SYSDA,SPACE=(CYL,10)\n//SYSABEND DD SYSOUT=*\n//SYSIN DD *\n COPY O=I,I=I\n/*\n\n -- JCL AFTER USING THE JCLFLOW PROGRAM EDIT MACRO.\n\n//SBGCTCZ JOB (A006,SYTM,99,99),'SAM-GOLOB',CLASS=S,MSGCLASS=K,\n//        NOTIFY=&SYSUID\n//*\n//COMPRESS EXEC PGM=IEBCOPY\n//SYSPRINT DD  SYSOUT=*\n//I        DD  DSN=SBGCTC.A.DATA,\n               DISP=SHR,\n               UNIT=SYSDA,\n               VOL=SER=ESAPAK\n//SYSUT3   DD  UNIT=SYSDA,\n               SPACE=(CYL,10)\n//SYSUT4   DD  UNIT=SYSDA,\n               SPACE=(CYL,10)\n//SYSABEND DD  SYSOUT=*\n//SYSIN    DD   *\n COPY O=I,I=I\n/*\n\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE 2.   Contents of a collection of edit macros from Paul Davis.\n            This collection is found on File 095 of the CBT MVS Tape.\n            You can get a good idea of the power of edit macros in\n            shortening your work, by looking through this list.\n\n        This is a collection of various edit macros that may be\n        somewhat useful at your installation.  Some of them are my\n        original, and others are from other SHARE users.  All of them\n        work at this site.  Some may need to be modified to work at\n        your site.  To use them you will need to have ISPF 2.2 or\n        later and TSO/E Rel 3 or later.\n\n        THIS FILE CONTAINS THE FOLLOWING:\n\n        COBLCAS       COBOL SOURCE FOR LCASE (LOWER CASE)\n                      EDIT MACRO\n        COBSEPL       COBOL SOURCE FOR SEPLINE EDIT MACRO\n        COBUCAS       COBOL SOURCE FOR UCASE (UPPER CASE)\n                      EDIT MACRO\n\n                   $MACROS\n\n        ADDCMDS   CLIST TO ADD ASSIST IN ADDING COMMANDS TO\n                  ISPF COMMAND TABLE\n        ASMBOX    DRAW A BOX AROUND ASSEMBLY CODE LINES\n                  (COMMENT THEM OUT)\n        B         BROWSE A MEMBER IN SAME PDS WHEN IN EDIT\n        BIG       CREATE BIG LETTERS IN YOUR TEXT\n        BIGS      CREATE BIG SLANTED LETTERS IN YOUR TEXT\n        BLDCOPY   BUILD IEBCOPY SYSIN STATEMENTS TO COPY\n                  MEMBER OF A PDS\n        BRODUPDT  NEATLY UPDATE SYS1.BRODCAST MESSAGES\n        CENTER    CENTER TEXT IN YOUR TEXT\n        CHGALL    QUICK CHANGE ALL COMMAND\n        CLISTBOX  DRAW A BOX AROUND CLIST LINES (COMMENT THEM\n                  OUT)\n        CLONE     CLIST TO INVOKE CLONES AND CLONEP FROM ISPF\n                  (3.4 ALSO)\n        CLONEP    BUILD JCL TO CLONE A PDS\n        CLONES    BUILD JCL TO CLONE A SEQUENTIAL FILE\n        CMDS      DISPLAY COMMAND TABLE ENTRIES\n        CMDUPDT1  EDIT MACRO CALLED BY ADDCMDS CLIST\n        COBBOX    DRAW A BOX AROUND COBOL CODE LINES (COMMENT\n                  THEM OUT)\n        COMMENTS  FIND ALL THE COMMENTS IN YOUR DATASET\n        COMPRESS  COMPRESS CURRENT PDS IN PLACE\n        CONLY     CHANGE \"ONLY\" COMMAND WITH SUB PARAMETERS\n        CONT      PUT CONTINUATION CHARACTER IN COL 72\n        CUSTBOX   DRAW A CUSTOM BOX TO SPECIFICATION LENGTH X\n                  WIDTH IN YOUR CODE\n        CUT       CUT TEXT LINES FROM DATASET TO BE PASTED\n                  LATER\n        CUTTO     CUT TEXT LINES FROM DATASET TO ANOTHER\n                  DATASET\n        D         DELETE A MEMBER OF THE CURRENT PDS\n        DELCUT    REMOVE A LEVEL OF CUT FROM PROFILE\n        DSIGENP   CREATE IEBCOPY JCL FOR A PDS\n        DSIGENS   CREATE IEBGENER JCL FOR A SEQUENTIAL\n                  DATASET\n        E         EDIT ANOTHER MEMBER OF THE CURRENT PDS\n        EDITPDS   CLIST: PERFORM A COMMAND ON ALL MEMBERS OF\n                  A CLIST\n        EMACS     LIST TABLE SHOWING EDIT MACRO DESCRIPTIONS\n        FC        FIND PENDING LINE COMMANDS\n        FIXJCL    TIDY UP YOUR JCL\n        INIT      INITIAL MACRO FOR EDIT MACRO PURPOSES\n        INITIAL   INITIALIZE DATASET HEADERS FILL IN THE\n                  BLANK INFO\n        JC        CREATE A JOBCARD\n        JCLBOX    DRAW A BOX AROUND JCL LINES (COMMENT THEM\n                  OUT)\n        JC2       CREATE A SPECIALIZED JOBCARD\n        JC3       CREATE A JOBCARD WITH REFER INFO\n        JOBCARD   CREATE A JOBCARD\n        LCASE     CHANGE ENTIRE DATASET TO LOWER CASE\n        LCASEC    CLIST MACRO TO CONVERT A DATASET TO LOWER\n                  CASE\n        LJUST     CHANGE AN ENTIRE DATASET TO UPPER CASE\n        MACHELP   GET HELP FOR INDIVIDUAL MACROS\n        MACLIST   DISPLAY A TABLE OF CURRENT ISPF EDIT MACROS\n        MEMLIST   SHOW THE MEMBERS IN THE CURRENT PDS\n        MOVECOLS  MOVE COLUMS OF DATA WITHIN DATASET\n        MRCLEAN   WIPE THE DATA OUT OF MEMBER BUT PRESERVE\n                  THE BLANK LINES\n        MSTATS    PROVIDE ISPF STATS ON MEMBER WITHOUT\n                  LEAVING EDIT\n        ONLY      FIND ONLY THE DATA WANTED\n        OTHER     SAMPLE MACRO TO USE WITH PFSET (CHANGE TO\n                  SUIT NEEDS)\n        PARA      WORD PROCESSING POWER FOR ISPF EDIT\n        PARADOC   DOCUMENTATION FOR PARA MACRO\n        PASTE     PASTE DATASET LINE THAT WERE CUT EARLIER\n        PBOX      DRAW A FLOWCHART BOX\n        PFCAN     RESET PFKEYS BACK TO NORMAL\n        PFSET     SET PFKEYS TO SPECIAL PURPOSE\n        PRTIT     VPSPRINT CURRENT DATASET\n        QCREATE   QUICK CREATE TO CURRENT DATASET\n        QREP      QUICK REPLACE TO CURRENT DATASET\n        RCOLDEL   DEL RULE LINES\n        RCOLS     FANCY RULE\n        REPOTHER  QUICK REPLACE TO OTHER DATASET\n        RJUST     RIGHT JUSTIFY TEXT\n        RNAME     RENAME A MEMBER WHILE IN EDIT\n        S         EDIT A MEMBER OF CURRENT PDS\n        SEPLINE   ADD SEPARATION LINES IN YOUR TEXT\n        SHOWCUT   SHOW TEXT PREVIOUSLY CUT\n        SHOWCUT2  SHOW ONE LINE OF EACH CUT LEVEL\n        SHOWDCB   SHOW CURRENT DATSET DCB\n        SHOWFLOW  SHOW THE LOGIC FLOW OF CLIST OR PL/1\n                  PROGRAM\n        SHOWMACS  SEE HELP FOR ALL EDITMACS ONE AT A TIME\n        SLINE     PLACE A SINGLE SEPARATION LINE WHERE NEEDED\n                  IN TEXT\n        SORTDUPS  SORT CURRENT EDIT DATASET AND FIND DUPES\n        ST        SUPERTYPE, TYPE A STRING OF BLOCK LETTERS\n                  NICE....\n        STAMP     STAMP DATA INTO YOUR TEXT\n        STEDITY   EDIT MACRO CALLED BY WHERMEM2\n        STEDIT2   EDIT MACRO CALLED BY WHEREMEM\n        SUM       SUM COLUMNS OF NUMBERS\n        T         WHAT TIME IS IT\n        TABLBLD   CLIST: CREATE ISPF TABLE FROM $DESCRPT\n                  MEMBER USED BY EMACS\n        TYPE      TYPE BLOCK CHARACTERS WITH EASE AND AUTO\n                  SPACING\n        TYPESET   EDIT MACRO TO USE WITH PFSET TO SET UP FOR\n                  \"TYPE\"\n        UCASE     CHANGE ENTIRE TEXT TO UPPER CASE\n        UCASEC    CLIST MACRO TO CONVERT A DATASET TO UPPER\n                  CASE\n        UNSEP     REMOVE SEPARATION LINES CREATED BY SEPLINE\n        WHEREMEM  CLIST: SHOW OCCURENCE OF MEMBER IN DD\n                  CONCATENATION -- USEFUL\n        WHERMEM2  CLIST: SAME AS WHEREMEM MORE COMMANDS AND\n                  INFO          -- USEFUL\n        WIPEIT    ERASE ALL LINES IN DATASET BUT MAINTAIN\n                  BLANK LINES\n        XCOPY     COPY A DATASET OTHER THAN THE PDS YOU ARE\n                  WORKING IN\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 3:   Here's the structure of the IKJTABLS load module.  This\n            module controls which programs can be executed authorized\n            under TSO.  The outputs shown are courtesy of the MAP and\n            ATTRIB subcommands of the PDSTOOLS product from Serena.\n            PDSTOOLS was convenient for me to use.  You can get\n            comparable information from running IBM's AMBLIST program.\n            See the MVS Service Aids manual for information about\n            AMBLIST.  Please note that my copy of IKJTABLS is probably\n            much larger than yours.  I've expanded mine a lot.  That's\n            the point.\n\n\n- DSN=SYS1.USERAUTH,VOL=SER=MVSCAP  MEM=IKJTABLS\n\n** MAP      IKJTABLS\nIKJEFTE2 00000000 000480\n                                               APFCTABL 00000010\nIKJEFTE8 00000000 000130\n                                               APFPTABL 00000490\nIKJEFTNS 00000000 00009E\n                                               NSCPTABL 000005C0\nIKJEFTAP 00000000 0000E8\n                                               APFTTABL 00000660\n\n\nPDS103I Entry point at 00000000  --  IKJEFTE2\nPDS104I Module length  000738  --      2K\n\n>attrib ikjtabls\nPDS020I IKJTABLS Attributes are: RENT, REUS\nPDS024I Page alignment is required\nPDS103I Entry point at 000000  --  IKJEFTE2\nPDS104I Module length  000738  --      2K\nPDS064I Last link-edited on 92/11/24 by LKED 566528408  V03 M02\nPDS160I Aliases for this member are: IKJEFTAP, IKJEFTE2, IKJEFTE8, IKJEFTNS\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9303MA": {"ttr": 11528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x93!\\x0f\\x01\\x00)\\x9f\\x11G\\x019\\x01=\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 313, "newlines": 317, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          March 1993\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\n Sam Golob is a Senior Systems Programmer living\n in New Jersey.\n\n\"SHOW ME MVS\" IN ONE PLACE.\n\n      Before speaking about our main topic, I'd like to start this\nmonth's article by recommending two books.  It is our purpose here, to\nadvance the skill levels of all practitioners of our trade.  Until\nrecently, assembler coding and knowledge of the innards of MVS were\nsolely the hard-won fruits of our efforts on the job.  In most parts\nof the country, there wasn't a school to go to, to learn the nitty\ngritty of this work.  However, there has existed a school for many\nyears, the Information Technology Institute of the New York University\nSchool for Continuing Education, which has taught many courses\ncatering to our knowledge needs.  Many highly successful systems\nprogrammers and software developers in the New York area and elsewhere\nhave profited through this school's offerings.\n\n      There have now arisen some fruits of this school which can\ngreatly benefit all systems programmers everywhere.  These are in the\nform of two books, which originally were outgrowths of NYU Information\nTechnology Institute courses.  These books are so valuable and so\nconcentrated, that they knock my socks off.  One of my own primary\nwishes is to know and be able to use all the material in both of them.\n\n      The books are:  \"Advanced Assembler Language and MVS Interfaces\"\nby Carmine Cannatello, published by John Wiley, and \"MVS Power\nProgramming\" by Mitchell Marx and Penelope Davis, published by McGraw\nHill.  Let me briefly give you my impressions of both books before\ndealing with the topic at hand for this month.\n\n      Carmine's book is a wealth.  Splendidly organized and enormously\nrich in facts, it must be characterized as a primary source for a\nsystem programmer's apprenticeship and continuing growth over the years.\nCoding examples abound, and the author systematically explains methods\nof reaching many parts of the MVS operating system.  This knowledge is\nnormally acquired in a more haphazard manner by most of us, and many\nof these techniques, though essential to our trade, are never acquired.\nNobody ever wrote about them before for the public, outside of manuals.\nIf you want one place to systematically march through the maze of MVS\ntechniques, and you're willing to put in the work, this is the place.\n\n      Mitch and Penelope's book complements Carmine's.  More\nrecently written, \"MVS Power Programming\" is thoroughly pervaded by\nESA coding techniques.  In this book, the MVS Operating System is\nexplained completely from the ESA point of view, taking advantage of\nall the new features.  The new assembler instructions and hardware\nconcepts are completely integrated into this thorough and systematic\nwalkthrough of deep MVS concepts.  Even seasoned old pros can\ngreatly profit from \"MVS Power Programming\", together with all of us\nbeginner and intermediate people.\n\n      Both books have optional diskettes available, containing\nmachine readable copies of all the coding examples.  Now that you've\nfound out about these marvelous sources of our basic knowledge, you\ncan't afford, for your own professional standing, to do without them.\nFor those of you within reach of New York, the Information Technology\nInstitute of the NYU School of Continuing Education can be contacted\nat 212-998-7190.\n\n\nSHOW ME MVS.\n\n      Our current topic is based on a fascinatingly simple concept.\nSuppose I want to see everything about my MVS system and TSO session\nin one place.  Can I?\n\n      The answer is, that it's getting pretty nearly possible.  A\nvery clever offering in the form of a TSO command, has appeared on\nthe CBT Tape File 183.  This command is called \"SHOWMVS\".\n\n      Its contributor is a good friend of mine, who is a consultant\nspecializing in VSE to MVS conversions.  My friend tells me that he\nwants everything to be in one place.  He can't stand hunting around\nwith many commands for a half hour to find out what he wants to know.\nSHOWMVS doesn't have any parameters; it always shows everything.  And\nthere are only two ways to invoke it.  Entering \"TSO SHOWMVS\" from an\nISPF session will produce (on my system) about 1400 lines of BROWSEd\noutput.  Pre-allocating a file using a ddname of SHOWMVS with a record\nformat of FBA and an LRECL of at least 101 will cause the output of\nthis TSO command to be written to that external file.\n\n      What does SHOWMVS produce?  A lot.  For starters, see Figure 1,\nwhich shows the first page of its output.  There are tons of essential\nfacts about your system shown just in the first page.  I'll detail\nthese a bit later.  After the first page, in addition, you get a\nVirtual Storage Map, SRM Data, display of open catalogs, all your page\ndatasets and dump datasets, the full subsystem vector table with all\nused program numbers, the linklist, the LPA list, the APF list, the\nactive LPA queue (ALPA), the SVC table with all its extended routers,\nand a display of all online devices with SMS data if applicable.\nThat's the system-wide stuff.  For your own TSO session, there's\nthe TIOT (all your allocated ddnames), your TCB tree and RB chains,\nthe job pack queue (JPAQ), and the Load List off of each of your\nTCB's.  This is quite a mouthful.  My friend told me that he's added a\nfew more things for his next release.  I just got it yesterday.  He's\nput in extent information on all the linklist libraries, and he's\nlisted all the esoteric and generic names of the units on your system,\ntogether with unit counts.  The entire report has been tastefully\nlower-cased.\n\n      The response for SHOWMVS seems very fast, considering that a lot\nof catalog lookups have to be done.  APF libraries are marked if they\nare not cataloged, and there is other similar information elsewhere in\nthe output that would seem to take more time.  This result is achieved\nthrough a trick.  The top of the output is produced right away, while\na subtask is created to complete the gaps in the report while you're\nbrowsing the first page.  Clever.\n\n      For the rest of this article, I want to slow down and explain\nthe significance of what we've got here.  If you want to maximize your\nprofit from this product, you'll use SHOWMVS at your work every day,\nearly and often.\n\n\nWHY WE CAN PROFIT BY RUNNING SHOWMVS FREQUENTLY.\n\n      SHOWMVS tells you, right up front, many kinds of things we\nusually ask about anyone's system.  SHOWMVS also appears to run very\nfast, as I've mentioned.  If you are using its ISPF BROWSE display,\nthe top information will all appear probably in a second or two.\nWriting the output to a pre-allocated dataset is slower because the\nsubtask needs time to complete, but it is still very quick for the\nresults you get.  Even though the output is many hundreds of lines,\nthe information that's up front, shown in Figure 1, is the type of\ninformation you might want to see several times in the course of a\nday's work.\n\n      Most of the first page is system-level stuff, but there's a lot\nof it.  It's too much to absorb all at once, so you might want to repeat\nrunning SHOWMVS, so you can focus on different parts of its output at\ndifferent times.\n\n      I'll list most of the items in the first page of the SHOWMVS\ndisplay, so you can get an idea of its richness.  At the beginning,\nyou get the operating system level, the DFP level, the JES2 level if\nyou have JES2, and the name of your NJE node.  Then you get a lot of\ninformation about your last IPL.  Added to that knowledge is a\ndisplay of your CVTUSER field, to see if CVTUSER was used by some\nproduct or add-on to your system.  It is important to be careful that\nyou not try to use CVTUSER twice, without planning for a\ncircumvention of the conflict.\n\n      Added to this initial system display is a software display\nthat shows the TSO/E level, the ISPF level, the level of DFDSS if\nyou're running that product, the DFHSM level if you've got that, the\nRACF level if you're running RACF, the VTAM level, and the DB2 level\nif your site is running DB2.  Different sites may use different SORT\nproducts.  SHOWMVS displays the eyecatchers of your SORT load module\nso you know beyond any doubt, which brand of SORT your machine is\nrunning.\n\n      There follows a complete display of your SMF datasets and their\ncurrent state of use.  Along with that is your SMF system id, plus the\ncurrently active setting of your system's SMF job wait time (JWT).\nThe SMF record types you choose not to record, round out the SMF\ndisplay.  This stuff is great.  It's all real time, and it reflects\nwhat your system is actually using.  It beats guessing and getting\nfooled by looking at the wrong PARMLIB member.\n\n      The first sixty lines of output are completed by all your CPU\nids and serial numbers, followed by estimated processor speed, the\nquantity of real storage available, and the expanded storage installed.\nNow you can understand why it might be desirable to refer to this much\ndata several times during various moments of a day's activity.  You'll\nneed to examine different parts at different times.\n\n\nMORE PRACTICAL RECOMMENDATIONS.\n\n      There's another reason to get into the habit of running SHOWMVS\nseveral times a day even if you think you don't need to.  This is for\nthe repeated learning experience.  As the wealth of information\nimpresses itself upon your brain, you'll accumulate a greater\nunderstanding of your system's activity.  Your mind will acquire an\ninstinctive feel for what your system and your session are doing, much\nmore so than before.  This is especially true with regard to the\nprogram load displays occurring later in the SHOWMVS output.\n\n      The program loading information, which comprises much of the\nremainder of SHOWMVS output, is fit for longer study.  Many of us,\nincluding myself, haven't been sufficiently aware that copies of load\nmodules are loaded into address spaces and used over and over.\nAwareness of loaded modules, their responsibility counts, and related\nmatters, can often shed light into why a new version of a program isn't\ntaking effect.  An old version of a load module might currently be in\nuse by your session.  You may have to logoff and logon again to put the\nnew version of that program into actual use.  SHOWMVS reports all of\nthis clearly, in its later displays.  Studying the SHOWMVS output in\ndetail, will clear up much of your confusion as to what is actually\nhappening regarding program execution.  I found it to be a real\neye-opener.  SHOWMVS output complements Carmine Cannatello's and Mitch\nMarx's explanations of program execution mechanisms in MVS.  SHOWMVS\nsheds a lot of light in understanding these matters.\n\n      It also won't hurt to refer to SHOWMVS's unit and device\ndisplays frequently.  SHOWMVS will show all the units and devices\nonline to your system.  You get full detail of your online devices\nand their device types.  I've often wanted to see if a particular disk\npack or tape drive was online to one of my systems.  This is\nespecially true in our large shop with many LPARs.  A quick SHOWMVS\nISPF run, and a \"FIND\" command in the ensuing BROWSE, settles my\nquestion immediately.  UCB device type numbers are also shown.  On\noccasion it's helpful to find out what they are, without trying to\nbrowse the UCB's themselves in virtual storage.\n\n\nIN CONCLUSION.\n\n      As usual, space restrictions preclude any further explanations\nof SHOWMVS here.  I have left a lot out.  I have to leave the rest of\nthe exploring to you.  However, suffice it to say, that nothing shown\nby the enormous SHOWMVS output is useless.  The very reason why its\nauthor chose to include something in his program, is because he needed\nto know about it for some reason.\n\n      After all, MVS is a big subject.  Any tool that will help\nsummarize MVS or give a general picture of it, is of great help to us.\nI trust that SHOWMVS will be a great help to all of you.  Good luck in\nyour searches.  See you next month.\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE 1.   This is the top of the output of the SHOWMVS TSO\n            command.  The wealth of information given here is\n            obvious.  On my system, the output of SHOWMVS goes on\n            for some 1300 lines in addition to what is included in\n            this picture.  As you see, this is quite a big computer.\n            It's a 600J.  The serial number has been changed for\n            purposes of anonymity.\n\n\n\nBROWSE -- TCN/AMS UTILITIES - SHOWMVS V3R7M0 ------- LINE 00000000 COL 001 080\nCOMMAND ===>\n********************************* TOP OF DATA *********************************\n\nOPERATING SYSTEM:\n\n  CVTPRODI: HBB4410   CVTPRODN: SP4.1.0   DFP LEVEL: 3.2.0\n    CVTDCB: 9B   CVTOSLVL: BE 00 00 00 00 00 00 00\n    JES2 LEVEL:  410    NJE NODE: MSQBATCH\n\nLAST IPL:\n\n  DATE:  SUNDAY 93/01/03 (12 DAYS AGO)     TIME:  05:59     JULIAN:  93.003\n  FROM:  MRS001/840     NUC ID:  1     CLPA:  YES     CVTUSER:  00000000\n\nSYSTEM SOFTWARE:\n\n  TSO/E LEVEL:   2.2.0    ISPF 3.3\n\n  DF/DSS LEVEL:  2.5.0\n\n  DF/HSM LEVEL:  2.6.0\n\n  RACF LEVEL:    1.9\n\n  VTAM LEVEL:    VX33        00B824F0\n\n  DB2 LEVEL:     5740XYR01\n\n  SORT'S TRUE NAME IS ICEMAN     (FIRST 100 BYTES FOLLOW)\n\n    D3C9C3C5 D5E2C5C4 40D4C1E3 C5D9C9C1 D3E24060   LICENSED MATERIALS -\n    40D7D9D6 D7C5D9E3 E840D6C6 40C9C2D4 40F5F7F4    PROPERTY OF IBM 574\n    F060E2D4 F1404DC3 5D40C3D6 D7E8D9C9 C7C8E340   0-SM1 (C) COPYRIGHT\n    C9C2D440 C3D6D9D7 4B40F1F9 F7F36B40 F1F9F9F1   IBM CORP. 1973, 1991\n    404DC35D 40C3D6D7 E8D9C9C7 C8E340E6 C1E3E2D6    (C) COPYRIGHT WATSO\n\nSMF DATA:\n\n  SID: MVSP  JWT: 0030   CVTSNAME: MVSP\n\n  SYS1.MAN1                     ACTIVE           ESACAP              0%\n  SYS1.MAN2                     DUMP REQUIRED    ESACAP            100%\n  SYS1.MAN3                                      ESACAP              0%\n  SYS1.MAN4                                      SMF001              0%\n  SYS1.MAN5                                      SMF001              0%\n\n  SYS   NOTYPE(16,62)\n\nHARDWARE CONFIGURATION:\n\n  CPU 0  SERIAL: 63098765  MODEL: 3090\n  CPU 1  SERIAL: 63198765  MODEL: 3090\n  CPU 2  SERIAL: 63298765  MODEL: 3090\n  CPU 3  SERIAL: 63398765  MODEL: 3090\n  CPU 4  SERIAL: 63498765  MODEL: 3090\n  CPU 5  SERIAL: 63598765  MODEL: 3090\n\n       PROCESSOR SPEED: 137.4 MIPS\n\n  ON-LINE REAL STORAGE: 452608K   HIGHEST REAL STORAGE ADDRESS: 452608K\n\n      EXTENDED STORAGE: 851968K\n\n           .   .   .   .   .   .   .   .   .   .   .\n           .   .   .   .   .   .   .   .   .   .   .\n           .   .   .   .   .   .   .   .   .   .   .\n\n   (The rest of the output continues for many more lines, below.)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9304AP": {"ttr": 11780, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x93!\\x0f\\x01\\x00)\\x9f\\x11G\\x00\\xf0\\x00\\xf4\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 240, "newlines": 244, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          April 1993\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\n Sam Golob is a Senior Systems Programmer living\n in New Jersey.\n\nCOPYING TAPES CORRECTLY.\n\n\nA WORD ON \"BLINDNESS\".\n\n      There is one big goal in our side of the computer business, that\nis, not to \"fly blind\".  Phrased more exactly, this means:  \"It is best\nnot to perform an operation without being able to see exactly what you\nare doing.\"  That's certainly true in medicine.  But in systems\nprogramming, it's not always done.  There are many operations that,\nunfortunately, we perform blind.\n\n      A very typical example of this blindness is the case of checking\na disk pack to see if IPLTEXT was loaded properly on it.  If you loaded\nthe IPLTEXT yourself, you usually trust the zero return code from the\nICKDSF utility.  If someone else loaded the IPLTEXT, and it was done\nsome time ago, most of us don't make it a general practice to go to\ntrack zero of the pack and take a look ourselves.  Most of us don't\nbother to dump track zero with AMASPZAP to see what's there.  We just\ntry to IPL the pack, and we scratch our heads only if it doesn't work.\n\n      To me this is badness.  It usually works out, but it has the\nshortcoming that you are leaving yourself open to possible error.\nMost people also don't bother to survey all of their packs to see\nwhat IPLTEXT, if any, is loaded on all of them.  You might find that\nsome of your packs might have standalone FDR or standalone DFDSS or\nstandalone ICKDSF loaded on them, and you didn't know it.  Maybe these\nstandalone products are out of date, too.  You'd never know that if\nyou remained \"blind\" and didn't take a look.\n\n      Today we're going to talk about techniques in copying and\nconstructing tapes.  Tapes are another area in which programmers are\ntempted to \"fly blind\".  This doesn't have to be the case.  To remedy\nthat situation, I'll try to offer some suggestions on accomplishing\ntasks in the area of tape manipulation.  Using the available tools we\nrecommend, you'll soon be able to perform tape tasks with less effort\nand without \"blindness\".\n\n\nTAPE VIEWING, AND TAPE COPYING.\n\n      We'll start our talk with some mention of bypassing label\nprocessing, otherwise known as \"BLP privilege\".  If you are going to\ndo what we would like to do, it sure helps to have BLP privilege!  I'd\nbet that at least 97 percent of MVS systems programmers can get BLP\nprivilege for themselves if they asked for it.  After reading this\narticle, if you're tactful, you'll probably be able to demonstrate\nthat it's to the installation's advantage to grant BLP to you.  I\npersonally have had to ask for BLP privilege several times, and in\neach case, I've received it.\n\n      If you can't get BLP privilege after having tried, I know of\none set of tools you might be able to use.  On File 171 of the CBT\nMVS Utilities Tape (distributed by NaSPA 414-423-2420 or by SPLA\n305-284-6257) there is a TAPEMAP program and an MVS DITTO-type program\nthat were contributed semi-anonymously.  The person who contributed\nthese programs does not have access to BLP privilege, and he got\naround that problem.  You are free to look at his code and see what he\ndid.  Of course, you can certainly make direct use of those very good\nprograms without knowing how he coded them.  It's nice to know that\neven without BLP, a lot of tape investigation can be done.\n\n      Back to the rest of us in BLP-land.  We are going to talk about\nsix relevant programs, all of which are on the above-mentioned CBT\nMVS Tape.  They are:  TAPESCAN (File 102), TAPECOPY (File 174),\nCOPYFILE (File 316), TAPEMAP (versions on File 299 and File 181 for\nnow), COPYMODS (File 229), and CT (File 316).  Each of these programs\nserves a somewhat different purpose.  It pays to know how to use all\nof them, and to understand their differences.\n\n      I'll summarize their features.  TAPESCAN dumps all tape labels\nin their entirety, and dumps in HEX, the first 100 bytes of the first\nnn blocks of each file.  (nn defaults to 6 blocks.)  TAPESCAN also\ncan copy tapes, and it has parameters for skipping some leading tape\nmarks or trailing tape marks.  This makes TAPESCAN a good tool for\ncopying DOS tapes or other tapes having a structure \"unfriendly\" to\nnormal MVS tape handling.  I used TAPESCAN as a debugging tool while\nI was making enhancements to TAPEMAP several years ago.  TAPESCAN\nshows you the relevant \"byte-content\" of a tape at the beginning of\neach file.\n\n      TAPECOPY from Aron Eisenpress of CUNY has more of an emphasis\non copying tapes than on mapping them.  TAPECOPY is similar to TAPESCAN\nin that it can skip tape marks.  But TAPECOPY is programmed also, to\nknow about various error conditions that might occur while reading an\ninput tape.  TAPECOPY has provisions to ignore or retry a number of\ndifferent error conditions.  TAPECOPY can do one additional thing\nwhich none of these other programs can do.  It can create a standard\nlabeled tape out of a non-labeled tape.  TAPECOPY manufactures the\ntape labels from parameters which you supply in a parm field, and it\nsandwiches the output tape's data files in between these newly created\nlabels.\n\n      COPYFILE is designed to copy standard labeled (SL) tapes only.\nCOPYFILE will copy (in one job step) selected files from an input\ntape, to successive files on an output tape.  See Figure 1, which\nshows you some of the nice things that COPYFILE can do.  I personally\nuse COPYFILE often in my own work.  Very recently, I enhanced the\nCOPYFILE control cards to copy a range of successive files from the\ninput tape, but not to the end of the tape.  You can obtain that\nenhancement to COPYFILE if you get Version 339 of the CBT Tape or\nhigher.\n\n      TAPEMAP will not copy a tape, but will display its contents.\nTAPEMAP's displays are not on a byte level, as are TAPESCAN's displays.\nThey are rather, detailed descriptions of the contents of all files.\nTAPEMAP has two reports.  The first report is a summary of the block\nstructure and size of each file on the tape, both from LABEL information\nand from SCAN information.  The second report of TAPEMAP displays the\ndetailed contents of each file, usually from a \"member\" point of view.\nTAPEMAP recognizes many common MVS tape formats.  For example, if a\ntape file was created by IEBCOPY, TAPEMAP's second report will show\nall of the member names unloaded from the original pds.  TAPEMAP will\ndo similar revelations for IEBUPDTE format files, and will show PTF\nor APAR numbers for SMPPTFIN format files, such as PTF files on a\nPUT tape or CBPDO tape.  TAPEMAP recognizes about ten file formats\non a tape.  TAPEMAP will display the detailed contents of nearly all\nof the compressed files on the CBT Tape itself.\n\n      COPYMODS will copy an entire tape regardless of labels or not,\nfrom end to end, until the first double tapemark.  In addition,\nCOPYMODS has the ability to create up to ten exact output copies of\none original input tape, if you have enough drives available.  I use\nCOPYMODS to duplicate all of my public domain tapes.  COPYMODS is\nquick and automatic to use, and is almost foolproof, except for one\nsituation (which COPYFILE can be used to remedy).  That unlikely case\noccurs when an empty pds is backed up using IEBCOPY to a standard\nlabeled (SL) tape.  This creates a header label followed immediately\nby a trailer label, with no data file in-between.  COPYMODS thinks\nthat this is a double tape mark and erroneously stops at that point,\neven though there are more files on the input tape.  Maybe one of you\nout there can fix COPYMODS to correctly handle this situation.  Please\nsend your fix back to the contribution address on the CBT Tape, so we\ncan all benefit from your work.\n\n      Finally, CT is a tape copying program that will recognize\nmulti-volume input tapes or single volume input tapes.  If the copying\nwas done from a single volume to a single volume, CT has the additional\noption of verifying, byte for byte, if the copied tape was an accurate\nreproduction of the original.  Thus, CT has some features that none of\nthe other programs has.\n\n\nCOPYING TAPES CORRECTLY.\n\n      This collection of tools, as described above, gives you ample\nmeans of correctly copying one tape to another.  Once you've done so,\nyou can accurately check if the new tape contains exactly what you\nwant it to have.  You can do away with \"flying blind\" entirely.\n\n      One major reason for my saying all of this, is my peeve with\nthe common practice of using IEBGENER to copy tapes that have multiple\nfiles on them.  IEBGENER copies only one file per job step.  You might\nmiss some, or all, of the later files on the input tape.  If a tape\nhas, say 50 files on it, using IEBGENER is extremely unwieldy.  You\nwould rather not code a 50-step job, when you can do it all in one\nstep, using the tools mentioned above.\n\n      If you want to closely monitor what's been happening, you can\nuse the mapping properties of the programs mentioned above, especially\nTAPEMAP and TAPESCAN.  Those programs take the guesswork completely out\nof discovering the contents of almost any tape.  Especially using\nTAPESCAN, MVS DITTO, or the DITTO-like program from File 171 of the\nCBT Tape, you can \"rescue\" large parts of even badly damaged tapes,\nand can save the undamaged files from them.\n\n\nCONCLUSION.\n\n      Tape work is a necessary part of our jobs.  Tape work can be\nfun, and accurate, if you use the proper tools.  Multi-file tapes and\nmildly damaged tapes do not have to be as much of a headache to copy\nas they formerly were.  This collection of tools I've mentioned will\ngo a long way, even in the most \"impoverished\" of MVS shops, toward\nimproving the quality of your life as far as tape work is concerned.\nYou will not \"fly blind\" any more.\n\n      In any case, I wish you good luck in all aspects of maintaining\nyour installations.  See you next month.\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE 1.   ILLUSTRATION OF THE COPYFILE PROGRAM.\n\n\n            The COPYFILE program allows the copying of selected files\n            from a standard labeled (SL) input tape to a standard\n            labeled output tape.  If some files already exist on the\n            output tape, you can code control cards to preserve them,\n            and you can write the new files immediately after the\n            files you want to preserve.  COPYFILE does an OPEN TYPE=J\n            to both tapes, and will only listen to the instructions\n            you tell it, not to expiration information from the tape\n            itself, or from a tape management system.  Therefore,\n            COPYFILE is best used for your own personal tapes, or\n            for special situations, not for normal production runs.\n            Be aware that the ddname for the input file is called IN,\n            but the ddname for the output file is called TAPELIN.\n            Otherwise, the use of COPYFILE is very straightforward.\n\n\n    COPYFILE Control Cards:\n\n    1.  Copy files 3, 7, and 22 from the input tape to files 8, 9,\n        and 10 of the output tape.\n\n          3/8  7  22               (copy 3 to 8, 7 to 9, 22 to 10.)\n\n    2.  Copy files 3, 7, and 22 to 8, 9, and 10 as before, but copy\n        files 23 and all the rest of the input files to the output\n        tape.  (23 to 11, 24 to 12, etc.)\n\n          3/8  7  22  ALL\n\n    3.  Copy files 3, 7, and 22 to 8, 9, and 10 as before, and copy\n        all the rest of the input files, but only through file 50.\n        (This is a new feature.  You need COPYFILE from CBT Tape\n        Version 339 or later.  In the older version, you had to code\n        all the specific file numbers between 23 and 50. )\n\n          3/8  7  22  -50          (new COPYFILE version )\n\n             or\n\n          3/8  7  22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38\n          39 40 41 42 43 44 45 46 47 48 49 50\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9305JL": {"ttr": 11785, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x93!\\x0f\\x01\\x00)\\x9f\\x11G\\x01.\\x01.\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 302, "newlines": 302, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           July 1993\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\n Sam Golob is a Senior Systems Programmer living\n in New Jersey.\n\nMAKING SEQUENTIAL FILES OUT OF PDS'ES - AND VICE-VERSA.\n\n      It's good to be back by popular demand.  Thank you all very much\nfor making yourselves heard.  My hope is to be able to continue\nsharing, helping, and being helped by all of you out there.\n\n      Today's column is about fixed and variable blocked pds'es.\nSometimes it isn't efficient or easy to process them member by member.\nThere are times when it is better to deal with a single sequential\nfile constructed from a partitioned dataset, rather than with\nthe partitioned dataset as it is, member by member.  We shall talk\nabout creating sequential files from partitioned datasets, and about\nreconstructing the partitioned datasets from these sequential files.\n\n      Why should we want to do this?  One obvious purpose is to\ndownload a pds to a PC file.  It's a lot easier to download one file\nto one PC file, than to download hundreds of members of a pds, member\nby member, into separate PC files in a subdirectory.  The individual\nmembers can later be separated on the PC side by using a file editor\nsuch as SPFPC, KEDIT or DOS EDIT.  Some of you out there might have\nbetter methods of separating the members on the PC.  If so, I'd like\nto hear about them.  Please contact me via Naspa headquarters.\n\n      I'll give you another example.  Arnold Casinghino (the founder\nand longtime proprietor of the CBT MVS tape) once called me with the\nfollowing problem.  He was the ACF2 administrator at his shop, and he\nhad to deal with a 2000 member pds, LRECL 130.  This was some kind of\nACF2 database, consisting of access rules.  Arnie had to run some CLIST\nprocessing globally against all the members, and it took about an hour\nto run because each member had to be accessed separately.  Arnie felt\nthat if he could convert this pds into a sequential dataset, IEBUPDTE\nstyle with \"./ ADD NAME=memname\" cards as member headers, his CLIST\nwould run in a much shorter time.\n\n      The problem was that IEBUPDTE doesn't work for datasets with\nLRECL 130, only with record lengths of 80.  Two programs on the\nCBT tape that did this processing, OFFLOAD and PDSLOAD, also (at that\ntime) only handled datasets with an LRECL of 80.  What could Arnie do?\n\n      I set out to solve Arnie's problem.  I didn't want to work\ndirectly with IEBUBDTE because it was IBM's program, but I looked at\nthe source code to the OFFLOAD and PDSLOAD programs, which are public\ndomain and which we had available from the CBT tape.  After searching\nfor all references to the DCB LRECL in the source, I found that I\ncould convert the LRECL from a hard-coded value of 80 to a global\nconditional assembly variable, at all occurrences in both programs.\nThen I could assemble both programs for any LRECL that I needed at the\ntime.  This jury-rigged solution worked well for Arnie's problem, and\nhis CLIST took only two minutes to run against the sequential file he\ncreated from his ACF2 pds.  The two changed programs, PDSLOAD and\nOFFLOAD, were then placed on File 93 of the CBT tape so they could be\nused by the public.  Greg Price of Melbourne, Australia has since\nfixed PDSLOAD so it doesn't need conditional assembly, but will\nautomatically handle record lengths for fixed blocked datasets with any\nLRECL from 1 to 256.  Greg's version of PDSLOAD is the one on File\n93 of the CBT tape currently.\n\n      This process has since gone much farther.  File 93 now contains\nmore software than those two original programs.  At one point in\ntime, I discovered the existence of the SHARE PL/I tape, which is\nnow distributed by SPLA at the University of Miami in Florida\n(telephone 305-284-6257).  It's nice to have this tape, especially if\nyou're a PL/I buff.  Since interest in PL/I is not necessarily limited\nto MVS only, the format of that tape's files had to be made available\nto the other operating systems.  The format therefore had to be as\nclose to a flat file as possible.  IEBCOPY-unloaded pds'es are mostly\nunacceptable on the SHARE PL/I tape.\n\n      The PL/I tape solution is related to our concerns here.  That\ntape supplies two programs, called UNUPDTE and UPDTE, which convert\nboth fixed blocked and variable blocked pds'es to sequential datasets\nusing \"./ ADD NAME=memname\" headers.  UNUPDTE converts a pds to a\nsequential dataset, and UPDTE reloads the pds from the sequential\ndataset.  Most files on the SHARE PL/I tape are pds'es converted into\nsequential files by UNUPDTE.  The advantages of UPDTE and UNUPDTE over\nPDSLOAD and OFFLOAD are that UPDTE and UNUPDTE can handle variable\nblocked files also.  PDSLOAD and OFFLOAD will only handle fixed blocked\nfiles.  UPDTE and UNUPDTE will deal with record lengths of up to 32760.\nI'm not sure if PDSLOAD and OFFLOAD are safe above record lengths of\n255.\n\n      Anyway, when I saw the UPDTE and UNUPDTE programs, I called Bob\nStyma, proprietor of the SHARE PL/I tape, to ask his permission to\nadd them to File 93 of the CBT tape.  They are now included there.\nBoth UPDTE and UNUPDTE use JCL that resembles the corresponding\nJCL which IEBUPDTE would use in a similar situation.  See Figure 1 for\nan illustration of their JCL.  UNUPDTE and UPDTE are extremely flexible\nin the types of datasets they will process.  But they do have one\ndisadvantage in an MVS environment, which we'll now discuss.\n\n\nISPF STATISTICS.\n\n      When IEBUPDTE unloads a pds to a sequential file, the ISPF\nstatistics for the individual members are lost.  That is because the\n(./ ADD NAME= ) IEBUPDTE member headers, as defined by IBM, do not\ncontain control parameters to preserve ISPF statistics for each\nmember.  However, this problem has been solved in a standard way by a\nnumber of programs which are on the CBT MVS tape, and by the vendor\nproduct called PDSTOOLS (from Serena International) which handles all\nthis processing with its COMBINE and SEPARATE subcommands.  These\nprograms modify the standard IEBUPDTE member header to include the\nvalues of the ISPF statistics for each pds member.  This is done in a\nstandard format.  See Figure 2.  The modified member headers can\neither be processed by IEBUPDTE, with the statistics lost, or by\nPDSLOAD and other programs, with the statistics preserved in the new\nloaded members.\n\n      Two free programs which preserve ISPF statistics in IEBUPDTE-\nformat member headers are:  LISTPDS from File 316 of the CBT MVS Tape\n(see Figure 2 for its JCL), and Greg Price's version of REVIEW from\nFile 134 of the CBT Tape.  LISTPDS is a batch program, very nicely\nwritten, but it only handles pds'es with 80-byte record length.\nREVIEW will only work interactively as a TSO command.  REVIEW is\nnormally a browsing program for partitioned datasets, members, and\nVSAM files.  But if you REVIEW a pds, you will get a member list with\nan 8-byte command area at the top (see Figure 3).  If you had\npreviously allocated a suitable sequential output dataset under ddname\nSYSUT2, you can enter the expression \"=OFFLOAD\" in the command area of\nthe REVIEW member list screen.  REVIEW will then dump the contents of\nthe pds into the SYSUT2 dataset in IEBUPDTE format, preserving any\nISPF statistics present.  This works for FB and VB datasets, and for\nany LRECL up to 32760.  Quite nice.  REVIEW will also selectively dump\nsome members, but not all.  To do that, you must have previously\nselected those members from the member list by placing an \"O\" next to\neach of them, before issuing your final =OFFLOAD command.\n\n      If your installation is lucky enough to have the product\nPDSTOOLS (formerly PDS/E SysProg Utilities), that product will do all\nthis work with just two of its many subcommands.  The COMBINE\nsubcommand of PDSTOOLS will string together any desired group of pds\nmembers into a single file.  You may optionally including IEBUPDTE-type\nheaders in between, having LISTPDS-format ISPF stats.  The SEPARATE\nsubcommand of PDSTOOLS will separate a COMBINEd file into individual\nmembers again, stowing ISPF stats back if they were there before.\nPDSTOOLS will work with any FB or VB pds, up to LRECL 32760 (VB to\n32756).  This product does our job best of all.\n\n      One final note.  Sometimes the data in a pds contains control\ncards that are already in IEBUPDTE format.  For example, the data might\ncontain \"./ CHANGE\" cards.  In that case, the LISTPDS, OFFLOAD, UNUPDTE\nand REVIEW programs change the \"./\" string to another string, usually\n\"><\", so that an IEBUPDTE reload of the pds would not get confused.\nIf PDSLOAD reloads the pds, it will automatically restore the \"><\"\nstring to \"./\" when each member is reconstructed.  That process is\ncontrolled by a parm, so that you can substitute an arbitrary\ntwo-character string instead of \"><\".\n\n\nSUMMARY.\n\n      I have found many occasions in the course of my career, when\nit was inconvenient to deal with a partitioned dataset as a library.\nIt would have been far more convienient to treat the data as a\nsingle sequential file.  All of you have undoubtedly encountered\nnumerous times when you wished you could conveniently turn a pds\ninto a sequential file, do some processing, and turn the sequential\nfile back into a pds with no loss.  Now you have some tools for this.\n\n      My aim here has been to show you the existence of the technique\nand the means to accomplish the result.  Get a CBT Tape (NaSPA\ndistributes it) and explore the programs we've described here.  You'll\nhave a few more tools in your box.  Good luck in everything you do.\nSee you next time.\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   JCL to execute the UNUPDTE and UPDTE programs from the\n            SHARE PL/I tape, and from File 93 of the CBT MVS Tape.\n            Notice how this JCL corresponds closely to IEBUPDTE JCL\n            which does the equivalent function.  The difference\n            is that UPDTE and UNUPDTE will handle FB and VB datasets\n            of any LRECL, as opposed to IEBUPDTE, which only handles\n            FB datasets with record length equal to 80.\n\n\n//UNUPDTE  JOB (TS,8400),'TECH SUPP-SAM GOLOB',CLASS=M,NOTIFY=&SYSUID,\n//        MSGLEVEL=(1,1),MSGCLASS=V\n//*\n//***************************************************************//\n//*   UNUPDTE EXECUTION.  CREATE A SEQUENTIAL FILE FROM A PDS   *//\n//***************************************************************//\n//UNUPDTE  EXEC PGM=UNUPDTE,REGION=1000K\n//STEPLIB   DD  DISP=SHR,DSN=MY.USER.LOADLIB\n//SYSPRINT  DD  SYSOUT=*\n//SYSUT1    DD  DISP=SHR,DSN=ABE.DOCSUB        <=== partitioned dataset\n//SYSUT2    DD  DISP=SHR,DSN=PL1MOD.FILE18     <=== sequential file\n                                                  (already allocated)\n\n\n\n//UPDTE    JOB (TS,8400),'TECH SUPP-SAM GOLOB',CLASS=M,NOTIFY=&SYSUID,\n//        MSGLEVEL=(1,1),MSGCLASS=V\n//*\n//***************************************************************//\n//*     UPDTE EXECUTION.  LOAD A PDS FROM THE SEQUENTIAL FILE   *//\n//***************************************************************//\n//DOUPDTE  EXEC PGM=UPDTE,REGION=1000K\n//STEPLIB   DD  DISP=SHR,DSN=MY.USER.LOADLIB\n//SYSPRINT  DD  SYSOUT=*\n//SYSIN     DD  DISP=SHR,DSN=PL1MOD.FILE18     <=== sequential file\n//SYSUT2    DD  DISP=SHR,DSN=ABE.DOCSUB        <=== partitioned dataset\n                                                  (already allocated)\n\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.  JCL to run the LISTPDS program from File 316 of the CBT MVS\n           Utilities Tape.  This program preserves ISPF statistics in a\n           standard form that can be processed by the PDSLOAD program\n           to reload the statistics into a new pds.  The LISTPDS\n           program will only sequentialize pds'es with LRECL 80.  Greg\n           Price's version of the REVIEW program (File 134 of the CBT\n           tape) will perform this \"unload\" service from TSO\n           interactively for FB and VB datasets of any LRECL.  See\n           Figure 3.\n\n\n//SEQUNLD  EXEC PGM=LISTPDS,REGION=2000K,    <=== from File 316 of CBT\n//     PARM='UPDTE(><),SPF,NOLIST,DECK,NOSEL'\n//STEPLIB  DD DISP=SHR,DSN=SYS1.USER.LOADLIB\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DISP=SHR,DSN=THE.SOURCE.PDS\n//SYSPUNCH DD DISP=(NEW,CATLG,DELETE),UNIT=SYSDA,\n              SPACE=(TRK,(15,15),RLSE),\n              DSN=THE.OUTPUT.SEQNTIAL.FILE,\n              DCB=(RECFM=FB,LRECL=80,BLKSIZE=23440)\n\n\n     Format of the IEBUPDTE-type header created by the LISTPDS\n     program or by =OFFLOAD processing of Greg Price's version of\n     REVIEW.  This header may be processed by IEBUPDTE or by\n     PDSLOAD.  If processed by PDSLOAD, the ISPF statistics are\n     stowed for the new member created.\n\n----+----1----+----2----+----3----+----4----+----5----+----6----+----7--\n\n./ ADD NAME=SAMPMEMB 0100-92332-92335-2005-00034-00023-00001-MYUSRID\n\n  (field format):    vvmm-crdat-modat-hhmm-size -init - mod -userid\n\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 3.  Illustration of sequentialization of a pds, using Greg\n           Price's verion of the REVIEW command from CBT Tape File\n           134.  The REVIEW command has been issued against the pds\n           SYS1.PARMLIB.  An output dataset has been previously\n           allocated to ddname SYSUT2, and the \"=OFFLOAD\" command\n           has been issued in the REVIEW command area next to the\n           word, \"LOCATE\".\n\n           The bottom part of this figure shows the top of the screen\n           when the offloading operation has been completed.\n\n\nSYS1.PARMLIB -------------------------------------------- 177 MEMBERS ON ESACAP\nLOCATE ===> =offload 1-TOP 2-BOT 3-END 4-SD 6-SN 7-UP 8-DN 9-SSZ 10-STTR 11-SID\n   NAME        TTR     VV.MM  CREATED  LAST MODIFIED  SIZE  INIT   MOD   ID\n  ACCMDTT     001407   01.62 91/09/19 92/01/26 08:46   311   288     0 TIMMY\n  ADYSET00    00002A   01.01 90/05/21 90/07/15 17:11    15    15     0 IBM\n  ADYSET01    00002C   01.01 91/09/19 92/01/26 15:23    11    11     0 IBM\n  ALLOC00     000401   01.01 91/07/22 91/07/26 11:03    99    99     0 IBM\n  ARCCMD00    006808   01.18 93/03/19 93/04/30 09:53   372   366     0 CAROL\n  BLSCECT     00050B\n  CLOCK00     001912   01.02 93/01/15 93/01/17 08:11     4     5     0 JOEY\n  CNLENU00    000405   01.00 91/07/26 92/07/26 12:46    55    55     0 IBM\n  COFDLF00    000408   01.00 91/07/26 92/07/26 13:23    26    26     0 IBM\n  COFIPCSP    00040A   01.00 91/07/26 92/07/26 12:39    73    73     1 BORIS\n  COFVLF00    002706   01.01 92/12/22 93/03/03 13:08    55    56     0 BORIS\n  COMMND00    00110B   01.03 92/07/31 92/08/23 06:09    30    46     0 BORIS\n  COMMND01    001106   01.01 92/08/19 92/08/19 15:24    17    38     0 BORIS\n\n\n\n\nOFFLOAD COMPLETE - SYSUT2 CLOSED ------------------------ 177 MEMBERS ON ESACAP\nLOCATE ===> =offload 1-TOP 2-BOT 3-END 4-SD 6-SN 7-UP 8-DN 9-SSZ 10-STTR 11-SID\n   NAME        TTR     VV.MM  CREATED  LAST MODIFIED  SIZE  INIT   MOD   ID\n  ACCMDTT     001407   01.62 91/09/19 92/01/26 08:46   311   288     0 TIMMY\n    .  .  .\n    .  .  .\n    .  .  .  etc.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9306SE": {"ttr": 12036, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x93!\\x0f\\x01\\x00)\\x9f\\x11G\\x01/\\x01/\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1993-07-29T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 303, "newlines": 303, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         September 1993\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\nSam Golob is a Senior Systems Programmer living\nin New Jersey.\n\n\nTSO HELP - WITHOUT THE DRAWBACKS.\n\n      When was the last time you used TSO HELP?  Probably five years\nago if you're normal.  IBM's TSO HELP facility is so ornery and\ndifficult to manage, especially for large help members, that people\noften give up and don't use it at all.\n\n      The purpose of TSO HELP is to provide help in using TSO\ncommands.  The help is packaged as an individual member of a\ncard-image pds.  All the \"help\" libraries are then concatenated in a\nddname called SYSHELP allocated to your TSO session.  IBM's HELP\nprogram accesses this SYSHELP ddname and displays the text on your\nscreen, awkwardly.  For example, once you've passed a screen full of\nhelp text, you can't go back and redisplay it.  Further, IBM's HELP\nprogram hasn't been significantly enhanced in twenty years.  Even ten\nyears ago, IBM's HELP was a full-fledged dinosaur.\n\n      Using TSO HELP is very frustrating, encouraging programmers to\ngive up and try to do without it.  When programmers try to escape\nusing TSO HELP, there isn't much of an alternative supplied by IBM.\nMost people look for a manual to explain a command they don't know.\nIf a manual doesn't exist, they just play with the command and use\n\"programmer's instinct\".  This is not adequate or satisfying, because\none gets a feeling that program documentation should be provided\nmore conveniently, and on line.\n\n      What's wrong with TSO HELP?  I'll mention a few considerations.\nFor one thing, you can't jump around in the help text--you have to\nlook at it sequentially.  You can jump to a subcommand sometimes, but\nonly if the help member is so formatted (with equal signs marking the\nsubcommands).  For another thing, once you've passed a given point in\nsome help text, you can't scroll back up to see it a second time.  To\nlook at text you've passed, you can only interrupt the display with\nATTENTION, or go all the way to the end, and then you have to issue\nthe command over again.  People tend to lose patience with the whole\nfacility.  There is a way, through keywords, to see part of a help\nmember without viewing the whole thing.  But this presupposes that the\nhelp member is formatted according to IBM's special HELP format.\nPlain text isn't good enough.\n\n      All this trouble with TSO HELP isn't necessary.  Using a readily\navailable public-domain command called HEL, you can now get effortless\nfull screen scrollable TSO help.  HEL is a free program which is\nyours for the installing.  Many of you already have HEL \"in house\"\nwhether or not you know about it, because HEL, in one version or other,\nhas resided on the CBT MVS Tape for a long time--since 1984.\n\n\nWHAT IS HEL, AND WHERE DID IT COME FROM?\n\n      What is this wonderful and pleasant HEL?  HEL is a TSO command\nfrom the CBT MVS Tape (obtainable through NaSPA), which can be found\nin source code on File 134 (or on File 296 in most older tapes).  The\nHEL load module can be copied from File 135 of the CBT Tape, directly\nonto your ISPLLIB or some other load library accessible to TSO.  Of\ncourse, ISPLLIB is only accessible when you're in ISPF, so from TSO\nREADY, you have to use either a STEPLIB, a linklist library, or\nsomething similar.  In any case, the installation of HEL is an easy\njob.\n\n      To use HEL, type:  \"TSO HEL helpmmbr\" from an ISPF command line,\nor \"HEL helpmmbr\" from TSO READY.  You are instantly treated to a\nbeautiful fullscreen scrollable display that has many useful\ncontrols.  PF1 will display those controls that have been assigned\npfkeys.  See Figure 1 for a sample of what you get.  HEL has its own\nHELP member, which can be found on the same file as the source code.\nIf this help member is installed in your SYSHELP ddname concatenation\nunder TSO, you can type:  \"TSO HEL HEL\" and get all the details about\nhow to use HEL.\n\n      We will soon elaborate further, but let me first tell you where\nthe HEL command came from originally.  HEL is a derivative program\nthat was adapted from the REVIEW program, which is a TSO fullscreen\nbrowse command that doesn't need ISPF.  REVIEW was originally written\nby Bill Godfrey, who did a great deal of pioneering programming work\nfor the systems programming community.  Many of Bill Godfrey's other\nworks can also be found in various places on the CBT MVS Tape.  In\n1984, Bruce Leland, the \"great enhancer\" of the famous \"PDS\" program\nand a developer of its successor vendor product \"PDSTOOLS\", adapted\nthe code from REVIEW especially for the purpose of looking at HELP\nmembers in a scrollable, positionable way.  Bruce's program, called\nHEL to distinguish it from IBM's program called HELP, solved the\nnagging problem of not being able to scroll upward when looking at a\nhelp member.  HEL is fullscreen--you can scroll all ways.\n\n      HEL was always a companion program to REVIEW, since it was\noriginally derived from REVIEW.  (We've discussed REVIEW as part of my\nSeptember 1992 column in \"Technical Support\".)  These two programs are\nparallel programs.  From the year 1986 and onward, the REVIEW program\nhas been greatly enhanced by Greg Price of Melbourne, Australia\n(this year's \"NaSPA Member of the Year\").  Greg felt an obligation,\nat the same time he was inventing new features for REVIEW, to put\nparallel enhancements into the HEL program.  Finally, growing tired\nof updating two programs all the time, Greg merged the \"code from HEL\"\n(to coin a phrase) into REVIEW so that they both would be one program.\nIn the latest CBT Tapes, HEL is an alias for REVIEW, with a different\nentry point.\n\n\nHOW TO USE HEL.\n\n      Enough history.  Now let's say a few things about how HEL\nworks.  HEL will pull a member out of the libraries concatenated to\nthe SYSHELP ddname.  All versions of HEL will create a fullscreen\ndisplay of the top of the member, when HEL is first invoked.  See\nFigure 1 again.\n\n      At the top of the screen, you have four input fields.  The\nfield marked \"HELP MEMBER\" can be overtyped to look for a different\nhelp member (without leaving the HEL program).  The field marked\n\"SUBCOMMAND\" can be used to position the help member to a subcommand\npiece of the help member, marked by an equal sign in the help member\nsource.  If there is no such marking in the help member, the viewing\nposition will be unchanged.  The \"RANGE\" field contains a number, or a\ncommand of PAGE, HALF, CS or (cursor), to indicate a scroll amount.\nAnd finally, the \"INPUT\" field is the place to type an arbitrary\nsubcommand of the HEL program, such as FIND, TOP, BOTTOM, UP 67, or\nthe like.\n\n      At this point, most people wishing to view TSO help members\nwould be completely satisfied.  (You can scroll up.)  However, some\nnewer features of Greg Price's version of HEL are worthy of note.\nGreg already had these features in the REVIEW command, and they were\navailable to HEL once the two programs REVIEW and HEL were merged.\n\n      One of these nice features is the subcommand \"DIR\", which\ndisplays a full member list of the SYSHELP ddname concatenation.  The\nDIR subcommand of HEL lists all member names of all pds'es currently\nin the SYSHELP concatenation.  This subcommand was originally written\nfor REVIEW, so that its availability to HEL did not constitute a large\ncoding effort.  From the DIR directory list, you can select any member\nto be viewed.  An unexpected advantage of this feature is that if two\nSYSHELP libraries contain like-named members, you can view either one\nfrom the directory list.  You aren't forced to look at only the first\noccurrence of that name in the SYSHELP concatenation.\n\n      Another dividend of HEL's merging with REVIEW is its pfkey\ndisplay when PF1 is pressed.  REVIEW's enhanced color displays have\nalso been made available to HEL, in the new version.  If you're\nrunning HEL under ISPF, you can save new pfkey settings in your ISPF\nprofile.  For example, to permanently change PF18 to LOCATE (another\nnew command), just type:  \"PFK18 LOCATE\", and the new setting will be\nsaved across HEL invocations, using your ISPF profile dataset.\nThere's lots more that came along from the merger, such as the FINDHEX\nor FH subcommand to find hex strings.  That stuff had been available\nin REVIEW, and now exists in HEL as well.  See HEL's help member when\nyou get a new CBT MVS Tape.\n\n\nPLAIN TEXT.\n\n      A great advantage of HEL over other TSO help programs is that\nit can show you SYSHELP members that are plain text.  Normally, TSO\nHELP will only display members which have the special formatted\nheadings:  FUNCTION, SYNTAX, OPERANDS.  Members without these special\nheadings will not be displayed by TSO HELP.  HELP will only generate\nerror messages if you attempt to look at such a member.\n\n      However, HEL will clearly display all plain-text members of\nhelp libraries.  Thus, if you are sure your programmers will always\nuse HEL instead of HELP, your documentation problems can be reduced.\nExisting plain-text descriptions and documentation can merely be\ncopied into the help libraries.  They don't have to be reformatted so\nthat TSO HELP will display their contents.  Using HEL, an individual\ncan read existing documents which the systems staff has made\navailable to them in the help libraries.  Thus, the help libraries\ncan be employed as \"teachers for the staff\" in a much bigger way.\n\n      HEL has the great advantage over TSO HELP, because its users\noften search around the help text using FIND commands.  HEL's FIND\ncommands can be issued anytime after the text has been displayed.\nThis is a total advantage over TSO HELP.  With TSO HELP, once some\ntext has been displayed, you cannot reposition except sequentially\nforward.\n\n      FIND commands work as well for plain text as for formatted TSO\nhelp members.  HEL also has enhanced FINDing tools, such as FINDHEX\n(FH) and FINDCHR (or FC, a sort of \"find asis\" that is case sensitive)\nas well as a the normal FIND command.  Thus HEL can become a\ntremendous time-saver.  The staff will be able to find only the\ninformation they need, and they can easily skip the rest.\n\n\nSUMMARY.\n\n      The main result, when a programming staff switches from TSO\nHELP to the HEL command, is a greater willingness to use the help\nmembers in the SYSHELP concatenation.  HEL is a pleasure to use.\nTSO HELP is extremely frustrating.  In addition, the systems staff\ncan include plain-text documentation in SYSHELP, which they couldn't\ndo before.  Thus, SYSHELP can become a repository of shop wisdom,\nwhich will be accessed by the staff frequently.\n\n      It just goes to show you that the users can often beat IBM\nby a mile.  Now wouldn't it be nice if some of you readers would\ngo to SHARE or GUIDE and make a requirement to the TSO developers\nfor a full-screen HELP program.  Let's see if IBM can beat the\nfeatures of Bill Godfrey, Bruce Leland, and Greg Price.\n\n      Good luck in all your efforts to improve things.  See you\nnext time.\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   This is an illustration of a full screen of data from\n            HEL.  It just so happens that we're showing help information\n            for the REVIEW command.  Notice that in this version of\n            HEL (from Greg Price) there are four input fields.\n            You can overtype the \"HELP MEMBER\" field to look at a\n            different member.  The \"INPUT\" field allows the typing\n            of an arbitrary command.  If you overtype the \"SCROLL\n            AMOUNT\" field, you can change its default value, and the\n            \"SUBCOMMAND\" field will position you to a subcommand's\n            position in the help text, if it has been properly marked\n            out with equal signs, according to TSO HELP member\n            formatting rules.\n\n\n\n HELP MEMBER==> REVIEW   SUBCOMMAND==>                           LINE 1 COL 1 80\n      INPUT===>                                                  SCROLL ===> CS\n1       10        20        30        40        50        60        70        80\n+---+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+\n)F Function -\n  The REVIEW command allows a data set to be examined at a 3270 TSO\n  terminal in full screen mode.  Both disk and tape files may be\n  REVIEWed.  If a PDS without a member is specified then a member\n  selection list is displayed.  Load module members with a residence\n  mode of ANY are shown in high intensity or red.  SCLM-managed\n  members are flagged with an equals ('=') sign.  A 'K' may be shown\n  in the \"ruler\" heading line to denote the first and last, or only,\n  column(s) of record keys.  On colour terminals the portion of the\n  \"ruler\" line corrsponding to records keys is shown in red.  If the\n  record format indicates printer carriage control characters then an\n  'A' or an 'M' as appropriate may be shown in column 1 of the\n  \"ruler\" heading line.  It is intended that the installation\n  authorize 'REVVSAM' to allow the REVIEWing of VSAM components for\n  problem diagnosis by programming support staff.  Normally, VSAM\n  KSDS, ESDS and RRDS clusters can be REVIEWed without this\n  authorization by specifying the cluster name as the data set name.\n)X Syntax -\n         REVIEW  'dsname'  UNIT('unit')  VOLUME('volume')  QUICK  DATA\n                        TOP('rel-addr')  SUBSYS('subsys')\n\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.   Some of the controls of the HEL command are displayed here.\n            These will show the basic richness of HEL's capabilities.\n            Greg Price's latest version has even more snazziness.\n\n\n\n         SYNTAX -   HEL COMMAND\n\n         THE SCREEN WILL NORMALLY CONTAIN 20 RECORDS, ONE PER LINE,\n         80 CHARACTERS PER LINE.\n\n      SUBCOMMANDS :\n         ASIS     - LEAVE LOWER CASE LETTERS IN LOWER CASE\n         BOTTOM   - DISPLAY THE LAST RECORDS\n         CAPS     - TRANSLATE LOWER CASE LETTERS TO CAPS\n         COMMAND  - DISPLAY A DIFFERENT HELP COMMAND\n         DOWN     - DISPLAY RECORDS BELOW THOSE ON THE SCREEN\n         END      - END THE COMMAND\n         FIND     - DISPLAY A RECORD CONTAINING A SPECIFIED STRING\n         HELP     - DISPLAY HELP INFORMATION\n         HEX      - SWITCH HEXADECIMAL FORMATTING ON/OFF.\n         LEFT     - DISPLAY DATA TO THE LEFT\n         LIST     - DISPLAY A SPECIFIED RECORD NUMBER\n         MEMBER   - DISPLAY A DIFFERENT HELP COMMAND\n         PFKNN    - CHANGE DEFINITION OF PF KEY NN.\n         RIGHT    - DISPLAY DATA TO THE RIGHT\n         SUBCOM   - DISPLAY A SUBCOMMAND OF THE CURRENT MEMBER\n         TOP      - DISPLAY THE FIRST RECORDS\n         TSO      - ISSUE A TSO COMMAND\n         UP       - DISPLAY RECORDS ABOVE THOSE ON THE SCREEN\n\n         WHEN 'UP' OR 'DOWN' DOES NOT SPECIFY HOW FAR UP OR DOWN,\n         THE 'RANGE' VALUE IS USED.  THIS VALUE IS ALWAYS DISPLAYED\n         NEAR THE TOP OF THE SCREEN AND CAN BE CHANGED BY MOVING\n         THE CURSOR OVER THE VALUE AND TYPING IN A NEW VALUE.\n         THE NEW VALUE WILL REMAIN IN EFFECT UNTIL THE COMMAND\n         ENDS OR UNTIL YOU CHANGE IT AGAIN.\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9307NV": {"ttr": 12042, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x93&o\\x01\\x00)\\x9f\\x11G\\x00\\xeb\\x00\\xeb\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1993-09-23T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 235, "newlines": 235, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         November 1993\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\nSam Golob is a Senior Systems Programmer living\nin New Jersey.\n\n\nIEHMAP, AND OTHER STORIES.\n\n      I have a bunch of things to say today.  I hope they'll be\nhelpful to you, or at least they should set you thinking.  We\nsystems programmers are living in a changing world, and probably many\nof us are rethinking where we'll fit--where our niche will be in the\nfuture.  Repositioning is probably on the minds of most of us, either\nin the back of our mind, or in the front.\n\n      To my thinking, MVS isn't going away at this point.  It's just\ntoo high-powered and does too much to be replaced by anything else.\nAlthough other systems are chipping away at its low end, MVS, on the\nlarge IBM mainframes, is extremely powerful and getting more so.  IBM\nis a huge company even after its own \"downsizing\" process.  The\ncomputing requirements of large installations are still best met by\nMVS, which is quite economical when it's called upon to do a lot of\nwork.\n\n      So in the forseeable future, MVS will have to be supported.\nPerhaps not by so many people, but there'll still be a job market for\nmany of us.  Nevertheless, while we are personally rethinking our\nfuture directions, we have to keep in mind the possibility of growing\ninto some new skills.\n\n      One possible direction is in software development.  In many shops,\nthe writing of code is being lifted away from the responsibilities of\nthe average MVS systems programmer, who is spending more time installing\nsomeone else's code.  Nevertheless, if a person manages to accumulate\nskills in manipulating components of the operating system through\nassembler language, there are jobs available to write \"code for the\nmasses\" at many software houses.\n\n      Again, this is not for everyone.  Many people, justifiably,\nmight want to learn a completely different and marketable skill.  This\nsuggestion is only for someone who wants to make a commitment in the\ndirection of writing MVS software, or for someone who wants to stay in\nthe systems programming field at an installation to become more\nskilled.  However, the ironic question arises:  In our new world of\nmostly OCO packaged software, how is it possible to develop your\nassembler programming skills from the MVS system programmer's job\nplatform?\n\n      I'll answer this as follows:  It's a multi-pronged effort.\nFirst, you might try to study your installation's system and JES exits,\nfor the purpose of understanding exactly what they do and how they do\nit.  Second and far more important, there are tremendous storehouses of\nMVS coding examples, free for the looking.  These begin with the CBT\nMVS Utilities Tape, which can be ordered through NaSPA.  The CBT Tape\nnot only contains a huge number of working programs to use and study,\nbut it contains a pointer to other sources of such code through file\n071, which shows you what's contained on many other public tapes.\n\n      Third, there is a marvelous book which is far too under-used for\nits immense value.  This book literally takes us to school.  It\ndirectly and simply teaches us most of the advanced skills we have to\nknow in assembler programming for the operating system.  Among many\nother topics, this book explains:  macro writing, channel programming,\ndynamic allocation in assembler programs, many ways of accessing a\npds, issuing operator commands from a program, abend recovery using\nSPIE, ESPIE, STAE and ESTAE methods, writing SVC routines, and almost\nany other programming principle you'd like to know.  It's a big book.\nIt's title is: \"Advanced Assembler Language and MVS Interfaces\" by\nCarmine Cannatello, and it's published by John Wiley and Sons in New\nYork City.  You can call Diane Cerra at 212-850-6660, to order.\n\n      Carmine Cannatello's book is an unbeatable combination with\nthe CBT Tape, when both are taken together.  In fact, the CBT Tape\nnow contains all the coding examples from Carmine's book in machine-\nreadable form, on file 069.  How can you use this combination?  You can\nlook at any program on the CBT tape that you want to study.  Then you\ncan study the relevant parts of Carmine's book, where he teaches you\nthe coding principles involved.  Fantastic.  Too bad nobody knows\nabout this.  You can be the first on your block to get on the\nbandwagon.\n\n      After you're really skilled, you can try disassembling and\nstudying pieces of system code.  I'm not telling anyone to violate\nlicensing agreements.  I'm just suggesting that there is a large\nopportunity for permissibly and legitimately obtaining great skill\nand benefit through the use of disassemblers.  We'll leave that\nstudy for a future column.  But we are about to reap enormous reward\nfrom someone else's expert use of disassembly.  The next story\nfollows.\n\n\nIEHMAP.\n\n      IEHMAP is mostly a VTOC and catalog listing tool, with many\noptions and facets.  To anyone who's an oldtimer in this field, IEHMAP\nis an old program.  In fact, its 50-page user manual bears the date,\nOctober 1975.  This belies the truth.  IEHMAP has been thoroughly\nmodernized and revamped by Guy Albertelli, who works for B.F.\nGoodrich in Brecksville, Ohio.  The modernization process was not\nso simple.  IEHMAP was only available in object code.  Guy Albertelli\ndisassembled some of its modules, and worked from there.\n\n      IEHMAP had been available (on the older CBT Tapes) in object\ndecks only, but it was free public code.  After his disassembly\nprocess, Guy Albertelli made some massive updates at the source level.\nAs a result, IEHMAP is now a very speedy program, using CVAF access to\nVTOCs.  I can testify that I was able to map 250 volumes, mostly 3390\nmodels 2 and 3 and some 3380K's, using the new IEHMAP, in eight minutes\nand change, on our large ES/9000 processor.  The most complicated\nlisting of a single volume takes a small fraction of one minute.\nThat's pretty darn fast.  This new version of IEHMAP is available on\nCBT Tape Version 337 or later, file 083.  If you have an older CBT\nTape, you should order a new one.\n\n      To run IEHMAP, there's only one piece of basic JCL, which is\nillustrated in Figure 1.  The important part of running IEHMAP is in\nthe control cards.  This is true because in Guy Albertelli's version,\nyou do not have to specify a special DDNAME for each volume allocated.\nGuy's version of IEHMAP will dynamically allocate a DDNAME pointing to\neach volume that is accessed.\n\n      To learn about IEHMAP's control cards, you should print out its\nmanual, called $MAPDOC.  You should also print Guy Albertelli's update\nnotes, called $DOC390.  Both of these are members of the pds which\ncomes from CBT Tape File 083.  The control cards I want to discuss\nare:  NAME, MAP, CATLG and ATTRIB.  Other related control cards are\ndescribed in the $MAPDOC document.  I would strongly advise reading\nGuy Albertelli's detailed caveats in the $DOC390 document.  Do not try\nand use some of the more tricky functions of IEHMAP unless you have a\nspare scrap volume to play with.  It's best to stick to the simpler\nfunctions that we'll describe now.\n\n      One more item before we start.  Guy Albertelli introduced the\nVSAM and ICF Catalog support to IEHMAP.  Reading an ICF/VSAM catalog\nrequires APF authorization for IEHMAP, which wasn't required before.\nThat's because the reading of an ICF or VSAM catalog requires either\nentry of a password by the operator (each time), or JFCB password\nbypass, which allows a straightforward reading of the catalog without\nentering any passwords.  The setting of the JFCB password bypass bit\nduring catalog OPEN, is what requires running in KEY 0, and hence the\nauthorization.  Functions of IEHMAP which don't require the catalog\nread, will probably work if the program is not being run authorized.\nPlease be aware of this consideration.\n\n      Now to the meat.  Running IEHMAP with the simple control card of\n\"NAME VOL=volser\" will produce an alphabetical listing of all datasets\non the disk pack.  If \"MAP\" is used as a control card instead of\n\"NAME\", then a track map of all datasets and extents sorted by CCHHR,\nis produced in addition to the alphabetical listing of datasets.  MAP\nis probably the most common keyword that you'll use.  Individual free\nextents are shown in the track map as \"AVAILABLE\".  The \"CATLG\nVOL=catvol,CNAME=catalog.name\" control card will list the entire\ncontents of a catalog, which could be VSAM or ICF.  Finally, the\n\"ATTRIB VOL=volser\" will list all members of partitioned datasets on a\nvolume, including their linkedit attributes (if load modules) and/or\nSSI values.  See Figure 2 for exact coding of some of these control\ncards.  IEHMAP also provides extensive filtering capability to limit\nthese listings.  These capabilities are described in detail in the\n$MAPDOC document.\n\n      At the very least, you should use IEHMAP to map disk volumes,\nusing the \"MAP VOL=volser\" control cards.  This JCL should become a\npart of every systems programmer's stock in trade.  And IEHMAP is\nvery, very fast.  See Figures 3, 4, and 5 for an illustration of\nthese most commonly used IEHMAP functions.\n\n      Space is running out now, and I'll have to postpone telling\nmore \"stories\" until next time.  Please play with this new version\nof IEHMAP.  You'll be pleasantly surprised at its speed and the\ndetail in its reports.  Most people will probably scratch their\nheads and ask how IEHMAP can do so much, so fast.\n\n      Good luck and much success in all your endeavors.  See you\nnext time.\n\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   Basic JCL to run IEHMAP.  Once this JCL is in place,\n            the significant variations are in the choice of control\n            cards.\n\n\n//IEHMAPA JOB (,SYSTM,99,99),S-GOLOB,CLASS=Q,MSGCLASS=V,NOTIFY=&SYSUID\n//*\n//SEQUNLD  EXEC PGM=IEHMAP                  <=== from File 083 of CBT\n//STEPLIB  DD DISP=SHR,DSN=SYS2.TECH.USER.LOADLIB    <=== authorized\n//*                      because of VSAM/ICF catalog password bypass\n//SYSPRINT DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n//SYSIN    DD *\n     control cards\n/*\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.   A few of the control cards available in IEHMAP.\n\n            NAME    - Produces an alphabetical dataset listing for\n                      a disk pack.\n\n            MAP     - Produces an alphabetical dataset listing for\n                      a disk pack, plus an extent list for the pack,\n                      sorted by CCHHR and showing free space extents.\n\n            CATLG   - Lists the entries of a CVOL, a VSAM catalog,\n                      or an ICF catalog.  For VSAM or ICF catalogs,\n                      the CNAME keyword must name the catalog, and\n                      the VOL keyword must name the volume containing\n                      the catalog.\n\n            ATTRIB  - Lists the members of partitioned datasets on\n                      the given volume, showing directory entry\n                      information for the members.\n\n            IEHMAP is very fast, and these results are obtained\n            extremely quickly.\n\n\n//SYSIN DD *\n  NAME VOL=SMB021\n  MAP  VOL=SMB021\n  CATLG VOL=SMB021,CNAME=STAFF.CATLG\n  ATTRIB VOL=ESACAP\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9401JA": {"ttr": 12291, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x933?\\x01\\x00)\\x9f\\x11G\\x01w\\x01{\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1993-11-29T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 375, "newlines": 379, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         January 1994\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\nSam Golob is a Senior Systems Programmer living\nin New Jersey.\n\n\nTHE FASCINATION OF THE DISASSEMBLER - Part One.\n\n      It's amazing that a computer works.  Even those of us who are\nprogrammers sometimes can't believe what we are seeing, when the\ncomputer is \"strutting its stuff\" while running some neat program.\nDid a person really program this?  Or is there some \"hidden spirit\"\nthat looks at what we've programmed, and then does wonders with it?\nActually, the truth is that the computer really is only a machine.\nBut the fascination produced by this machine never ceases.\n\n      I find this fact itself to be worthy of study.  Why are we so\nemotionally taken by the workings of a computer?  This topic would\nreally deserve expert treatment by someone as insightful as Rod\nSerling.  What inner yearning of the human spirit is stirred, when one\nsees the outward workings of a computer?  What do we feel?  What does\nthe computer awaken within us?\n\n      I think that a small part of the answer lies in our conceptual\ninability to relate programming languages (which we think in) to the\nexecutable load modules that control the actions of the machine.  We\ndo our programming with something that is language-like, whereas the\nmachine obeys a strange combination of binary bytes that constitute\nthe load module's machine instructions.\n\n      Today, we'll spend some time thinking about the connection between\nour language-like programs and the machine's binary instructions which\nresult from \"compiling\" our programs.  More specifically, we shall\ndiscuss the reverse of the normal process.  We shall try to understand\nthe machine's mysterious code by attempting to convert it back to our\nown assembly language, which we have a better shot at understanding.  If\nwe see assembly language code produced from what the machine is doing,\nour fascination and pure wonder might be converted to a measure of\nunderstanding.  This reverse process is called disassembly, and\nprograms which \"de-compile\" machine code, are called disassemblers.\n\n\nThe Compilation Process.\n\n      In order to understand the de-compilation process, which is our\nsubject today, I have to say a few words about the compilation\nprocess.  I'm speaking philosophically here.  Probably ninety percent\nof our readership actually understands this mechanism in much more\ndetail, so please don't feel that your intelligence is being insulted.\nPlease let me go on.  The compilation process is the bridge between\nour language-like computer instructions and the binary codes that make\nthe computer jump through its hoops.\n\n      On an IBM mainframe system, the initial translator from our\nprogramming language is called the compiler.  The compiler looks at\ninput source code, turning it into a card-image ordered collection of\nmachine instructions and external references called an \"object deck\".\nWhile an object deck already contains actual machine instructions, it\ncannot itself run on a machine.  (Let's forget about the LOADER\nprogram for now.)  Another program called the linkage editor is\nnecessary to \"digest\" this set of instructions further, in order to\nmake it easier for the machine to \"fetch\" the program and run it.  The\noutput of the linkage editor, which takes input from one or more\nobject decks, is called a load module.  When we look at a load module\nwith an unpracticed eye, it looks like a bunch of gibberish to us.\n\n      Now to the meat.  We systems programmers delve into a machine's\ninternal workings, software-wise.  When a problem occurs, the only\nevidence we usually have is a core dump that points to load modules\nand data areas.  Our problem is to look at the machine's \"gibberish\"\nand to figure out what the machine was trying to do.  It would of very\nmuch help to look at language instructions instead of binary machine\ncode.  Thus we have the need to reverse the compilation process and to\ngenerate a source code listing, arising from machine code.  Obviously,\nit's easier to automate that job, rather than to do it by hand.\nTherefore, people have written \"disassembler\" programs.\n\n      Our aim now is to concretely illustrate the usefulness of the\ndisassembly process in a practical way.  What's in it for us?  I'll\nshow you two \"free\" disassembler programs and one vendor product.\nDuring part one, we'll speak more generally.  Subsequently, we'll\nbring in more detail.  At the end of this, we should all have a much\nbetter feel for the joy and practicality of frequent \"disassembling\".\nAlso, we'll forge a much better bond in our minds between the wondrous\nactions of the machine, and the practical desires of its programmers.\n\n\nThe Aims of Disassembling.\n\n      There are several clear purposes for disassembling machine\ncode.  These are:  comparing load modules, fitting zaps to existing\ncode, trying to see how code works, and changing how the code works\nwhen you don't have the source to work from.  A fifth purpose is to\nsatisfy auditors.  For some reason (unknown to me) auditors who\ncomplain that an installation doesn't have source for some essential\nprogram, will be satisfied if they produce disassembled source.  For\na sixth application, one can employ disassembling to understand code\nfrom object decks that are shipped with PTFs.  I'll give a few\npractical examples from my own work.  But first, let me introduce you\nto the disassembler programs.\n\n      To my knowledge, two disassembler programs are found on the CBT\nMVS Utilities Tape, which is distributed (but not created) by NaSPA.\nThese programs can be found on Files 217 and 171 of the CBT tape.  The\nvendor product disassembler is part of the extremely versatile (and\ncomparatively inexpensive) PDSTOOLS product from SERENA in Burlingame,\nCalifornia.  PDSTOOLS has an \"object deck decoder\" as well as a load\nmodule decoder.  We'll see all of this next time.  Meanwhile, look at\nFigure 1 which is an ISPF panel that was created by a member of my\nNaSPA chapter.  That panel is part of a convenient interface to both\ndisassemblers that will hopefully be on the CBT MVS Tape soon.\n\n      Before we go on, I have to say that you shouldn't use a\ndisassembler to violate software license agreements.  However, many\ncircumstances arise in a systems programmer's work, in which the\nunderstanding of the structure of some load module makes a world of\ndifference in one's ability to solve the current problem.  Therefore\nyou need to have these tools in your arsenal, at the ready, just in\ncase.\n\n\nPractical Examples.\n\n      Now for a quick disassembler application to start with.  Let's\nsay we have two copies of a load module having different linkedit\ndates, from a software vendor.  The question arises whether these two\nmodules are really the same, or whether there are some different bytes\nin their code.  My quick way to tell, is to disassemble both modules\nto two source files, and then to run a compare against these source\nfiles.  This is an elegant, simple technique and it works very well.\nAfter verifying that the code is the same, all you have to do is to\nmake sure that the two sets of load module attributes (reentrancy,\nreusability, etc.) match each other.  The disassembler print files\nwill display all the load module attributes.  Or if you have PDSTOOLS,\nyou can use its ATTRIB and MAP subcommands against each load module.\nJob finished.  You can also use this technique to discover where a zap\nwas done, by disassembling the zapped module and the unzapped one.  A\ncomparison of the two source decks will quickly reveal the location of\nthe zap.\n\n      An extension of this technique can often be used to figure out\nthe logic behind a \"late-model\" load module.  I have saved my old XA\noptional materials tapes (which contain non-OCO IBM source code for\nthe operating system.  These tapes contain base-level source for many\nsystem modules.  No PTFs have modified them yet.  By assembling this\ncode for a given module, you'll get an idea of the logic behind how\nthe module works.  You have an honest assembly listing, on your own\nprinter's paper, complete with comments.  You are probably not running\nthat code on your system, however.  If the running code is not OCO,\nbut it is at a later maintenance level, a comparison between a\ndisassembly of the running code, with the assembly listing of the base\ncode, will usually give you a nice idea about what is really going on\nwith your running code.  You can get to the bottom of many software\nproblems in this way.\n\n      Fitting zaps to a new version of a load module can become very\neasy through disassembly.  It depends upon the circumstances, but I'll\ngive you an example to show how it might be done.  This example follows\nFile 236, on CBT Tape version 354 or higher, so you can see some machine\nreadable illustrations if you have a new CBT Tape.\n\n      A friend of mine, who works as an SE for a hardware vendor, had\na customer who modified the module IDCLC01, which produces TSO \"LISTC\nLEVEL\" displays on the tube.  The purpose of the zap was to produce a\nshorter LISTC listing.  This customer's zapping point was located in\nthe first branch of nine similar compares and branches.  IBM changed\nthe logic of the compares and branches in a later release, and it\nbecame difficult to find the proper zapping location.\n\n      See Figure 2, which shows the original DFP release 2.4 base\ncode, followed by the later code, to which a similar zap was fitted,\ndespite the logic change to the module.  Again, the zap was a NOP\nto the first branch of nine similar branches that followed each other.\nDecoding of the later module with a disassembler, made it possible to\neasily discover the place to put the proper zap.  And subsequent\ntesting showed the zap to function correctly on the later module\nrelease.\n\n      In our next installment, we'll continue our exposition of\ndisassembly examples.  However, for this time, I'd like to conclude\nwith some talk about of how to run the public disassemblers.\n\n\nRunning the Disassemblers.\n\n      See Figure 3 for an illustration of the JCL to run both public\ndisassemblers.  You'll see that the JCL to run the File 217 disassembler\nis much different than the JCL to run the disassembler from File 171.\nThe reason is that the disassembler from File 171 can use real macros\nto supply assembly labels, and it must call the assembler to assemble\nthese macros.  A good look at Figure 3 will make this obvious to you.\n\n      Each disassembler also comes with a detailed set of\ninstructions to show you how to make multiple passes and supply\nlabels to the disassembled code.  The File 171 disassembler can do it\nfrom real assembler macros, as we mentioned.  However, we do not have\nspace to discuss the topic of multiple passes in this installment,\nand we encourage you to explore that area yourselves, for now.\n\n      Again, we hope to make the ISPF interface shown in Figure 1\navailable shortly.  I hope this introduction gives you a push to start\nworking with these disassemblers, and that this preparation will get\nyou ready for our next installment.  Good luck.  See you next time.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE 1.   This panel was developed by a member of our New Jersey\n            NaSPA Chapter which is called SPONJ (Systems Programmers\n            of New Jersey).  It is a part of his ISPF interface to\n            both public domain Disassemblers.  Either Disassembler\n            can be chosen from this panel.  Printout from the\n            Disassemblers is browsed as a result of this invocation.\n\n            This interface will soon appear on the CBT MVS Tape, and\n            thus will be available for public use, probably by the\n            time you are reading this.\n\n\n\n\n----------------------------- CBT  DisAssemblers -------------------------------\nCOMMAND ===>\n\n\nEnter/Verify Parameters below:\n\nChoose your    ===> 1   1       (File 171)  - Nicest output, some bugs, but it\nDisAssembler                                  looks the most like real Assembler\n                        2       (File 217)  - Updated version of the DISASM\n                                              used by other dialog panel (D5)\n\nData Set Name  ---> 'SYS1.MODTEST'\nMember Name    ===> SHOWMVS\nCSECT Name     ===> SHOWMVS     (Optional)  - Defaults to member name.\n\n\n*---------------------------------------------------------------------------*\n*--  Warning!   Do not Disassemble IBM Licensed Software!     Warning!  ----*\n*---------------------------------------------------------------------------*\n\nLines per Page ===> 55\nRedisplay Last ===> NO                      - YES  to reshow previous listing\n\n\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE 2.   Illustration of fitting a zap to higher level code.\n\n\n\n\n  Original zap, from DFP Release 2.4 base code assembly.\n\n         C     @02,FDTPTR+80(,@15)\n         BNE   @RF01262               <----  change branch to nop\n         C     @02,FDTPTR+8(,@15)                  4770 to 4700\n         BNE   @RF01262\n         C     @02,FDTPTR+96(,@15)\n         BNE   @RF01262\n         C     @02,FDTPTR+100(,@15)\n         BNE   @RF01262\n         C     @02,FDTPTR+104(,@15)\n         BNE   @RF01262\n   -  -  -  -  nine occurrences of similar code  -  -  -  -\n\n\n\n  DFP 3.3.1 level.  Note the logic change, but the similar pattern.\n\n\n         L     R14,88(,R2)               58E0 2058\n         LTR   R14,R14                   12EE\n         BNZ   3731(,R9)  (Zap to 4700)  4770 9E93    <--- zap location\n         L     R15,16(,R2)               58F0 2010\n         LTR   R15,R15                   12FF\n         BNZ   3731(,R9)                 4770 9E93\n         L     R0,104(,R2)               5800 2068\n         LTR   R0,R0                     1200\n         BNZ   3731(,R9)                 4770 9E93\n         L     R1,108(,R2)               5810 206C\n         LTR   R1,R1                     1211\n         BNZ   3731(,R9)                 4770 9E93\n         L     R14,112(,R2)              58E0 2070\n         LTR   R14,R14                   12EE\n         BNZ   3731(,R9)                 4770 9E93\n   -  -  -  -  nine occurrences of similar code  -  -  -  -\n\n\nThe new zap was discovered through disassembly and a search for nine\nsimilar instruction patterns containing a branch.  This zap was\ntested.  It works just like the original zap did.\n\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE 3.   JCL to run the disassemblers from the CBT MVS Tape.\n\n\n\n    JCL for the disassembler on File 217.\n\n\n//SKJCSCD JOB (A006,SYTM,99,99),S-GOLOB,TIME=1440,\n//        CLASS=Q,MSGCLASS=V,NOTIFY=&SYSUID\n//*\n//DISASM  EXEC PGM=DISASM,REGION=0K           <--- FILE 217 DISASMBLR\n//STEPLIB  DD DISP=SHR,DSN=SYS2.SBG.USRLLIB\n//SYSPRINT DD SYSOUT=*\n//SYSABEND DD SYSOUT=*\n//SYSLIB   DD DISP=SHR,DSN=SKJCSC.A.LOAD\n//SYSPUNCH DD DISP=SHR,DSN=SKJCSC.DISASM.PUNCH(LAA001)\n//SYSIN    DD *\nLAA   LAA\n/*\n\n\n\n    JCL for the disassembler on File 217.  Note the changes needed\n    because this program must call the assembler to obtain labels\n    from actual system macros.\n\n\n//SKJCSCR JOB (A006,SYTM,99,99),S-GOLOB,TIME=1440,\n//        CLASS=Q,MSGCLASS=V,NOTIFY=&SYSUID\n//*\n//DISASM  EXEC PGM=DISASMR,REGION=0K          <--- FILE 171 DISASMBLR\n//STEPLIB  DD DISP=SHR,DSN=SYS2.SBG.USRLLIB\n//*----------------------------------------------*//\n//*--   UNNECESSARY  DD'S                      --*//\n//*----------------------------------------------*//\n//ABNLIGNR DD DUMMY\n//SYSABEND DD SYSOUT=*\n//*----------------------------------------------*//\n//*--   ASSEMBLER    DD'S                      --*//\n//*----------------------------------------------*//\n//SYSPRINT DD DSN=&&PRT,DISP=(NEW,PASS),UNIT=SYSDA,SPACE=(TRK,(15,15)),\n//            DCB=(RECFM=FBM,LRECL=121,BLKSIZE=12100)\n//SYSIN    DD DSN=&&IN,DISP=(NEW,PASS),UNIT=SYSDA,SPACE=(TRK,(15,15)),\n//            DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SYS1.AMODGEN\n//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,(1,1))\n//SYSPUNCH DD DUMMY\n//*----------------------------------------------*//\n//*--   DIS-ASSEMBLER DD'S                     --*//\n//*----------------------------------------------*//\n//DISDEBUG DD SYSOUT=*\n//DISPRINT DD SYSOUT=*\n//DISPUNCH DD DISP=SHR,DSN=SKJCSC.DISASM.PUNCH(LAA002)\n//DISMOD   DD DISP=SHR,DSN=SKJCSC.A.LOAD\n//*      1    1    2    2    3    3    4    4    5    5    6    6    7\n//* +....0....5....0....5....0....5....0....5....0....5....0....5....0..\n//DISIN    DD *\nLINES    55\nMODULE   LAA\nCSECT    LAA\n/*\n//\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9402MA": {"ttr": 12298, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x94\\x04o\\x01\\x00)\\x9f\\x11G\\x01w\\x01%\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1994-02-15T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 375, "newlines": 293, "modlines": 0, "user": "WSBG"}, "text": "  (My apologies to our readership.  This article has been edited.)\n\n                MVS TOOLS AND TRICKS OF THE TRADE\n                          March 1994\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\nSam Golob is a Senior Systems Programmer living\nin New Jersey.\n\n\nTHE FASCINATION OF THE DISASSEMBLER - Part Two.\n\n     In Part I (January 1994), we began studying the usefulness of\ndisassembling machine code.  As you may recall, this is the process\nof converting load module CSECTs into assembler source code using\na utility program called a disassembler.\n\n     Two public domain disassemblers can be found on the CBT MVS\nUtilities Tape.  The CBT Tape is obtainable through NaSPA.  These\ndisassemblers are on Files 217 and 171 of the tape.  These two\nprograms are somewhat similar to each other, but they are also\nsignificantly different.  You can decide which one you like better.\n\n     Let's take a quick look at both of them.  First,\nwe'll look at their similarities.  Both disassemblers produce very\ndetailed print output including instruction displacements, a hex\ndump of the load module and all the load module attributes.\nAdditionally, both disassemblers also produce a much plainer punch\noutput, which is reassembleable.  As for differences, the\ndisassembler on File 171 allows labels to be fitted from actual\nassembly of real macros, whereas the File 217 disassembler has its\nown special \"label coding\" that is required.  As of Version 363\nof the CBT Tape, the File 171 disassembler has been improved much.\n\n     The vendor product PDSTOOLS from SERENA International in\nBurlingame, Calif., contains both a load module disassembler and an\nobject deck disassembler (besides the zillion other things it\ndoes).  Reassembleable source code produced by the PDSTOOLS\ndisassembler has displacement information on each line, making it\na handy tool for fitting zaps into the original load module.  The\nPDSTOOLS disassembler does not produce separate print and punch\noutput.  One output is produced, complete with the displacement\ninformation.  Depending upon a keyword, The PDSTOOLS disassembler\noutput can be made instantly reassembleable, sandwiched between\nappropriate reassembly JCL.  Otherwise, its output is displayed in\na more \"diagnostic\" format, resembling an assembler listing.\n\n     The PDSTOOLS disassembler also has another feature the other\ndisassemblers do not:  It can decode entire load modules and it is\nnot restricted to doing just a CSECT at a time.  I once used the\nPDSTOOLS disassembler to disassemble IEANUC01 (for MVS/370 a while\nback) and I quickly reassembled it so it actually worked and could\nbe used for production.  (Note: Don't do this unless you perform\nmany checks and verifications against the original nucleus to\nensure \"sameness.\")  You can see that the PDSTOOLS disassembler is\nvery powerful and quick to use.\n\n     In Part I, we discussed a few applications of disassembling\nload modules.  In this month's column, we'll go into more detail.\nRight now, I'll summarize some useful techniques involving\ndisassembly we discussed previously.\n\nFirst problem: How do we determine if two different load modules\nactually have the same code?\n\nAnswer: Disassemble them both with the same disassembler and compare\nthe two source decks line by line with a compare utility.  If the\ndecks are the same, the code is the same.  Only the load module\nattributes and the CSECT structure (the load module maps) will then\nneed to be compared.  This will prove \"sameness\" of the modules, even\nif the link-edit dates are different.\n\nNext situation:  Suppose we have two load modules, one zapped and\nthe other not.  How do we determine where the zap is?\n\nAnswer: Simply disassemble both of them and again compare the\nsource decks line by line.  The location of the zap(s) will appear\nimmediately upon comparison.\n\n     Finally, suppose we have to upgrade a USERMOD zap from a lower\nmaintenance level of (non-OCO) IBM code to a more recent level of the\nsame module.  Disassembling both modules will usually reveal the\nappropriate location of the corresponding zap in the higher\nmaintenance level code.  The technique may even work if some of the\nactual assembler instructions which are to be zapped became different\ninstructions in the later level of the module.  For example, suppose\nthe newer module was created by IBM using a different PL/S compiler\nthan the old one.  It is possible that the same PL/S logic may\ntranslate into completely different assembler code.  Nevertheless,\nyou can sometimes find the appropriate zapping point with the aid of\ndisassembled source code because you understand the overall logic\nbetter when you see the assembler instructions before you.\n\n\nTrying To Learn How Code Works\n\n     Usually, when you disassemble a load module, you have far less\ninformation about how it works than if you had a commented source\ndeck.  With disassembled source, you have the instructions but must\ndo considerable detective work to learn the logic.  It pays to use\nwhatever extra clues you can find.  However, let's start with the\nbasics.\n\n     Learning the details of how a program works from a\ndisassembled source deck usually takes a lot of patience.  However,\na quick glance at a disassembled source deck will reveal some\nsignificant information.  For instance, you can usually spot patch\nareas quickly.  DCB control blocks are easily recognizable\nonce you've seen them.  It is usually possible to see the DDNAME in\nthe DCB.  You can tell if it's hard coded in the DCB or if a\nsubstitute DDNAME is being dropped in.  SVC instructions are\ndecoded by all these disassemblers.  You can get a general idea what\nthe program is doing by looking at which SVC instructions have been\ncoded.\n\n     One of the more subtle details you can get from a disassembled\nmodule is the structure of a work area or a control block created\nby that module.  You may notice a section of code that has a series\nof STore instructions to different displacements off the same\nregister, with other instructions including a Load or Load Address\ninstruction, placed before each STore.  This may indicate that the\nprogram is obtaining information and placing it in the various\npigeon holes of a work area or control block.  With some patience,\nyou can then map the layout of that control block or work area.\n\n     I once used this observation profitably.  I had to refit a zap\nto some IBM code which got a new internal work area after a certain\nPTF level.  I was worried that the newly added module structure\nmight interfere with the workings of my zap.  From the cover letter\nof the PTF I got some idea of the new work area's purpose.  I didn't\nhave source at the higher PTF level because the microfiche\n(remember microfiche?) for that PUT level wasn't obtainable yet.\n\n     Our PTF had been an advance shipment obtained from a CBPDO.\nNevertheless, with disassembled source I was able to figure out what\nkind of data went into that work area and at which point in the code\nexecution it happened.  It turned out that my zap code could safely\nuse the new work area before the IBM code used it.  The zap\ncode \"did its thing\" before the IBM code initialized that new piece\nof storage for the first time.  So I successfully fitted and tested\nmy zap.\n\n     Deciphering uncommented disassembled code is much easier if\nyou have clues.  Often, a lower level of the same module can be\nfound in base level machine readable source (the Optional Materials\ntapes) or on microfiche.  Even though some of the code will change\nat the higher maintenance or release levels much of that module's\nstructure and logic will also be found at the lower level.\nAdditionally, you have commented assembler source at the lower\nlevel.  Exploit this hint as much as possible.  It really pays to\nsave your old Optional Materials tapes.\n\n     I have a scheme to get at these source materials quickly,\nwhich you can see on Files 188 and 189 of the CBT Utilities Tape.\nUnfortunately, I do not have the space to describe its details\nhere.  Once I have my scheme in place, I can find and assemble any\nsource module in five minutes.  Why is this so good?  Because IBM\nsource code is heavily commented.  Even at base level code,\nthese materials will aid immeasurably in trying to negotiate a\ndisassembly deck of the code you are actually running.  Together with\ncare, patience and intelligence, these hints will definitely assist\nyou in this work.\n\n\nDisassembling Object Decks\n\n     The public disassembler programs we've mentioned take load\nmodules as input, as opposed to object decks.  Object decks are\nRECFM=FB card-image decks that are output from the assembler and\nfrom language compilers.  Load modules are RECFM=U and are output\nfrom the linkage editor, or now, from the binder.  Even though\nobject decks are not directly executable on the computer, they do\ncontain machine instructions identical to those in load modules.  As\nsuch they could be candidates for disassembling.  However, with the\nfree disassemblers from the CBT Tape Files 217 and 171 the object\ndecks will have to be link-edited into load modules first, before\ntheir code can be disassembled by these programs.\n\n     A shortcut to this process would be a disassembler program\nthat could take object decks as input instead of load modules.  As\nof this writing, I don't know of any free program that does this.\nHowever, the PDSTOOLS vendor product, besides its DISASM subcommand\nto disassemble load modules, has a READOBJ subcommand to\ndisassemble object decks directly without having to link-edit them\nfirst.\n\n     For example, you can point the READOBJ subcommand directly at\na PTF and obtain instant disassemblies of all the object decks in\nthe PTF.  Whatever tools you have, disassembling an object deck\ndirectly from the PTF can pay big dividends.  Since all the\ndisassemblers generate instruction displacements within some of\ntheir outputs, it is possible to fit a zap directly onto the PTF\nwithout having to APPLY it first.  It doesn't even have to be on your\nsystem and you can already figure out the proper hooks into it.  You\ndon't have to wait until the full-sized load module is actually\nsitting on a system library.\n\n     I'll show you a startling example of something I was able to\naccomplish with PDSTOOLS.  But the same kind of thing can be done,\nalbeit much more awkwardly, with public tools.  My friend, Merv Hemp,\nrecently asked me to refit an old modification to module IDCLC01,\nwhich performs LISTC processing and displays catalog entries.  A\n1-byte zap to this module could greatly shorten the \"LISTC LEVEL\"\noutput by eliminating the repetition of the catalog name after\ndisplaying every catalog entry (See Figure 1).  With the zap on, the\nLISTC display is much shorter and runs much quicker than with the\nzap off.  I mentioned this case in passing, last time.\n\n     This zap had been fitted at DFP Version 2.4 base level.  Merv\nwanted me to fit the same zap to a DFP Version 3.3.1 level of\nIDCLC01 at PTF level UY83416.  I actually later fitted this zap to\n17 different maintenance levels of IDCLC01, doing the whole job\nwith PDSTOOLS in less than two hours.  A full machine-readable\nexhibition of this work can be found on a new CBT Tape, File 236.\n\n     How did I go about this?  First, I had to find every IBM SMPPTS\ndata set in my data center complex.  In PDSTOOLS, I did a global\nLISTFILE command against all of our 400 mounted volumes, looking for\nall data sets containing the string \"PTS\" within their names.  When I\nfound these, I narrowed the list down (by eyeball) to just the SMPPTS\ndata sets for IBM modules.  There were six of them, which referred to\nfive different levels of the MVS operating system.  As you know,\nthese PTS data sets contain the actual text of IBM PTF fixes.\n\n     Next, I scanned each PTS data set for the string, \"IDCLC01\",\ngetting a small list of members in each PTS.  The PDSTOOLS command\nwhich does this is:  \"FIND : /IDCLC01/ THEN(MEMLIST),\" which says:\nFind every member containing the string \"IDCLC01\" and display a\nmember list consisting of only those members.  Once I had this list\nin each PTS data set, I ran the READOBJ command against every PTF to\ndisassemble all the object decks in it (and use the ISPF EDIF service\nto display the result).  Going up and down each disassembly of an\nIDCLC01 module, I found the proper place to fit the zap for that\nlevel.\n\n     Fitting this zap to the 17 different levels of IDCLC01 I found\nat our data center, took two hours with PDSTOOLS.  The same job\nwould have taken perhaps 10 to 25 hours without PDSTOOLS, but it\ncould have been done using public materials too.  Here's how.  After\nfinding which PTFs contained the string \"IDCLC01,\" you could edit a\ncopy of that PTF to extract its object deck for IDCLC01.  Then you\nwould link-edit that object deck and run it through one of the\ndisassembler programs.  At this point, the zap could be fitted by\nlooking through the disassembler print output.\n\n\nConclusion\n\n     I hope this month's column opens your mind in a new direction.\nDisassembling should no longer be a \"dirty word\" or label you as\n\"dangerous.\"  On the contrary, it is just another essential\ntechnique for a systems programmer to use in solving many of the\nproblems that come up at most shops.  Good luck.\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.    Illustration of the MOD to LISTC in module IDCLC01.\n                     (THIS IS THE ACTION OF THE MOD)\n\n\n\n*  ----   LISTC LISTING WITH THE MOD IN PLACE   ----  *\n          (THE RESPONSE IS ALSO MUCH FASTER.)\n\n    LISTC LEV(TIMMY)\n IN CATALOG:STAFF.CATLG\n TIMMY.ACS.CNTL\n TIMMY.ASM2\n TIMMY.DATA\n TIMMY.DCOLL.DATA\n READY\n END\n\n\n*  ----  LISTC LISTING WITHOUT THE MOD IN PLACE  ---- *\n\n    LISTC LEV(TIMMY)\n NONVSAM ------- TIMMY.ACS.CNTL\n      IN-CAT --- STAFF.CATLG\n NONVSAM ------- TIMMY.ASM2\n      IN-CAT --- STAFF.CATLG\n NONVSAM ------- TIMMY.DATA\n      IN-CAT --- STAFF.CATLG\n NONVSAM ------- TIMMY.DCOLL.DATA\n      IN-CAT --- STAFF.CATLG\n READY\n END\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n     (This figure was cut, in the published article.)\n\n\nFigure 2.   Illustration of how the Assembler Instructions in an\n            IBM module can change when different releases of PL/S\n            are used, or when the PL/S logic may have changed\n            slightly.  The top set of instructions comes from the\n            DFP Release 2.4 machine-readable source at base level.\n            The bottom set of instructions is from a PDSTOOLS\n            object module disassembly obtained from PTF UY83416\n            itself, using the PDSTOOLS \"READOBJ\" subcommand.\n            Included here are instructions on how to fit this zap,\n            in general.\n\n\n     The zap is fitted on various levels of the module IDCLC01, which\nbelongs to load module IDCLC01.  In XA DFP 2.4 base level, the mod is\ndone to the first branch of nine similar compares and branches that\noccur one after the other as follows:\n                          (This is from a source code assembly.)\n\n         C     @02,FDTPTR+80(,@15)\n         BNE   @RF01262           <-----   (Zap 4770 to 4700 here)\n         C     @02,FDTPTR+8(,@15)\n         BNE   @RF01262\n         C     @02,FDTPTR+96(,@15)\n         BNE   @RF01262\n         C     @02,FDTPTR+100(,@15)\n         BNE   @RF01262\n         C     @02,FDTPTR+104(,@15)\n         BNE   @RF01262\n         C     @02,FDTPTR+92(,@15)\n         BNE   @RF01262\n         C     @02,FDTPTR+56(,@15)\n         BNE   @RF01262\n         C     @02,FDTPTR+64(,@15)\n         BNE   @RF01262\n         C     @02,FDTPTR+60(,@15)\n         BNE   @RF01263\n\n      Because of changes in the PL/AS compiler (whichever one is being\nused now--it doesn't matter to us) this logic is done differently in\nMVS/ESA 4:\n\nThe idea is that you have to find a similar pattern of nine sets of\ninstructions in module IDCLC01 and zap the branch of the first set\nto a noop (4770 to 4700).\n\n                    (This is from READOBJ output of PDSTOOLS.)\n*     This module is at PTF level UY83416    (MVS/ESA 4.2 - DFP 3.3.1)\n                                                            Displacement\n         L     R14,88(,R2)             58E0 2058        *.\\..*     1E26  001E26\n         LTR   R14,R14                 12EE             *..*       1E2A  001E2A\n ---->   BNZ   3731(,R9) (Zap to 4700) 4770 9E93        *...l*     1E2C  001E2C\n         L     R15,16(,R2)             58F0 2010        *.0..*     1E30  001E30\n         LTR   R15,R15                 12FF             *..*       1E34  001E34\n         BNZ   3731(,R9)               4770 9E93        *...l*     1E36  001E36\n         L     R0,104(,R2)             5800 2068        *....*     1E3A  001E3A\n         LTR   R0,R0                   1200             *..*       1E3E  001E3E\n         BNZ   3731(,R9)               4770 9E93        *...l*     1E40  001E40\n         L     R1,108(,R2)             5810 206C        *...%*     1E44  001E44\n         LTR   R1,R1                   1211             *..*       1E48  001E48\n         BNZ   3731(,R9)               4770 9E93        *...l*     1E4A  001E4A\n         L     R14,112(,R2)            58E0 2070        *.\\..*     1E4E  001E4E\n         LTR   R14,R14                 12EE             *..*       1E52  001E52\n         BNZ   3731(,R9)               4770 9E93        *...l*     1E54  001E54\n         L     R15,100(,R2)            58F0 2064        *.0..*     1E58  001E58\n         LTR   R15,R15                 12FF             *..*       1E5C  001E5C\n         BNZ   3731(,R9)               4770 9E93        *...l*     1E5E  001E5E\n         L     R0,64(,R2)              5800 2040        *... *     1E62  001E62\n         LTR   R0,R0                   1200             *..*       1E66  001E66\n         BNZ   3731(,R9)               4770 9E93        *...l*     1E68  001E68\n         L     R1,72(,R2)              5810 2048        *....*     1E6C  001E6C\n         LTR   R1,R1                   1211             *..*       1E70  001E70\n         BNZ   3731(,R9)               4770 9E93        *...l*     1E72  001E72\n         L     R2,68(,R2)              5820 2044        *....*     1E76  001E76\n         LTR   R2,R2                   1222             *..*       1E7A  001E7A\n         BNZ   3727(,R9)               4770 9E8F        *....*     1E7C  001E7C\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9403MY": {"ttr": 12549, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x94\\x08\\x1f\\x01\\x00)\\x9f\\x11G\\x01u\\x01u\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1994-03-22T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 373, "newlines": 373, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           May 1994\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\nSam Golob is a Senior Systems Programmer living\nin New Jersey.\n\n\nASSEMBLING PROGRAM PATCHES - The ASMTOZAP Program\n\n      I'm appalled by the fact that we Systems Programmers don't get\nenough of a chance to strut our skills, nowadays.  I admit that in\ntoday's world of \"vendor products for everything\", a lot of our work\nis done by installing software through \"slapping it in\", and in a sense,\nit's probably better.  At least, the site has an out-of-house fall guy\nto blame a failure on.  However, from our point of view, it's still\ndisappointing that we don't get many of the customization opportunities\nwe had in previous times.\n\n      So, FWIW (for what it's worth), I'm going to present a technique\nin this issue which many people might say is outdated.  However, I\ndon't think so.  I am a firm believer that in the systems programming\nbusiness, any procedure you know will eventually find its place.  There\nwill be a certain need, or a certain emergency, in which you can save\nyour installation \"n times ten thousand dollars\", just because you know\nsomething.  This technique is no exception.\n\n      Our subject deals with non-trivial patches to existing load\nmodules.  We may legitimately ask ourselves why such an action might\nbe necessary in today's day and age.  One answer is that we may want\nto add new function to a supported module that comes from an established\nvendor such as IBM.  IBM may not want to support this extra function,\nbut in reality, it is easy to add.  When IBM changes its supported\nmodule, we would like to correspondingly change our extra piece of code,\nwithout having to laboriously fit a patch in machine language.  We would\nrather want our shop to be able to make a quick change, and slip it in.\nThe ASMTOZAP program from Howard Gilbert (of Yale University) usually\nallows us to do this.  ASMTOZAP is an amazing piece of work.  Even\nthough there are other programs which claim to do the same thing, I\nadvise you to accept no substitutes, and to use only Howard's program.\n\n      ASMTOZAP allows us to write patch code in good old assembler\nlanguage, using all the IBM macros.  We start with assembler code,\nand end up with a zap input deck.  Here's how it works.\n\n      We code our patch instructions, to eventually be placed in the\ninside of a target module, in assembler language.  However, ASMTOZAP\ncontrol cards are coded in the assembler source as comments.  These\ncontrol cards tell the ASMTOZAP program how to construct its output\ndeck.  They tell ASMTOZAP where the VER cards of the zap code will\nstart, where the VER will stop, where the REP cards will start and\nstop, and they can cause ASMTOZAP to punch any arbitrary output cards\nyou want.  ORG and EQU statements are used to control where in the\nload module the zap will fit.\n\n      Here's what you do.  You code your source deck and assemble it.\nThen you run the assembler SYSPRINT listing as input into the ASMTOZAP\nprogram.  ASMTOZAP output is a superzap (AMASPZAP) input deck or an\nSMP/E usermod that will apply the patch.  All this will become clear\nfrom looking at the figures.  See Figures 1 and 2 for ASMTOZAP\nassembly source and the zap patch resulting from it.  See Figures 3\nand 4 for sample JCL that executes the process.\n\n\nInstalling and Using the ASMTOZAP program.\n\n      The ASMTOZAP program is written in PL/1.  There is a load module\non File 035 of the CBT MVS Utilities Tape (available from NaSPA) which\ncan be used immediately, provided you have the Transient Library for\nthe PL/1 Optimizing Compiler.  PL/1 source code is on File 044 of the\nCBT Tape, and also on File 369.  Howard Gilbert told me that his\nintent was to write for the Optimizing Compiler.  However, with\nHoward's help, I have done some experimentation with the free PL1/F\nCompiler and Library on File 092 of the CBT Tape, using procedure\nPL1LFCL taken from File 091.  With the removal of a few lines of code\nfrom the PL/1 source, it is possible to compile cleanly using free\nPL1/F, and the resulting load module works logically the same as the\nOptimizing load module, except for return codes.\n\n      As of this writing, I am preparing the PL1/F version of the\nASMTOZAP program for inclusion on the CBT Tape.  It should get onto\nVersion 367.  For PL1/F, the code to remove is:  The %PAGE statement,\nthe environment material on the DCL OUT definition, and the calls to\nPLIRETC (return code processing).  Using PL1/F compilation, ASMTOZAP\nis within reach of all MVS shops.  Your installation does not have to\nbuy any part of PL/1 from IBM.\n\n      ASMTOZAP input is assembly SYSPRINT output resulting from the\nassembly of your mod.  Figure 3 gives some JCL to run the assembly.\nFigure 4 shows sample JCL that can be used when actually running the\nASMTOZAP program to produce the zap.\n\n      Now, we're going to talk about the ASMTOZAP control cards.\nI'm going to paraphrase Howard Gilbert's own words from the remarks in\nhis source code, because he himself documents the working of this code\nvery clearly:\n\n      The purpose of this utility is to convert an assembler listing\ndataset into a formatted IMASPZAP input deck or SMP PTF.  It is useful\nin preparing, maintaining, and documenting those installation\nmodifications which cannot be installed except by modifying IBM code.\nOne can make free use of macros, literals, and other convenience\nfeatures in preparing the deck.  Control cards in special assembler\ncomment form provide flexibility in modification design, and control\nover output.\n\n      Control cards included in the assembler deck all begin with\nthe characters *ZAP.  The purpose of the control cards is to interrupt\nand resume generation of zap output.  Statements which do not generate\nobject code (comments, ORG, DS, EQU, etc.) are transferred to the\noutput as zap comment cards, unless output generation is currently\npaused.  Other statements (instructions, DC, CCW, etc.) are transferred\nto the output as VER or REP cards if output generation has been\n(re)started in either VER mode or REP mode.  The cards governing this\nare:  '*ZAP START VER', '*ZAP START REP', and '*ZAP PAUSE'.\n\n      Zap generation is initally paused.  A '*ZAP START' card is valid,\nand (re)starts generation in REP or VER mode, whichever was last active.\nWhen the zap is done, a '*ZAP END' card will terminate a scan of the\nlisting and close the output file.  This stops the generation of the\nzap, so that comments describing later support code (register equates,\na description of the CVT DSECT, etc.) do not clutter up the zap\nstatements which will be produced.\n\n      The '*ZAP CARD' control card allows arbitrary text to be\nreproduced in the output.  The characters up to the space after\n\"CARD\" are stripped off and the remainder of the card up to column 72\nis reproduced in the output deck.  This is primarily for NAME, DUMP,\nand SMP/E control cards.  Figures 1 and 2 show how *ZAP CARD statements\nare used to produce \"SMP-ready\" usermod input, directly from the\nassembly source code.  A handy feat indeed.\n\n\nTo Conclude ...\n\n      Set up ASMTOZAP on your system and play with it.  Sample source\ndecks for ASMTOZAP can be found on File 369 of the CBT tape, because\nPlanning Research Corporation (the submittors of File 369) packaged\nmany of their mods in ASMTOZAP format.  You can assemble these and\ngenerate the zaps for practice, although they will probably not fit on\nyour system (nor would you likely want them there).\n\n      Once you are familiar with how ASMTOZAP works, the possibilities\nfor finding occasion to use it will open up.  It'll begin to dawn on\nyou that ASMTOZAP can be a really helpful tool.  Good luck and happy\nexploring.  See you next time.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   Illustration of ASMTOZAP assembler source code.  Please\n            excuse the age of this code.  However, this source had\n            easily been adapted for later versions of the underlying\n            IBM code, by changing a few ORG's or EQU's usually.  In\n            the case of this particular zap, IBM made the underlying\n            code OCO, and drastically modified some of the logic.\n            But various versions of this zap have been operational\n            at some sites for over fifteen years.\n\n\n\n*------- MVS/370 VERSION OF I/O COUNT ZAP.  FROM FILE 369 OF CBT TAPE.\n*-------\n*------- TITLE LM02301...I/O COUNT  IN MSG IEF285I\n*-------\n*ZAP     CARD ++ USERMOD(LM02301) /* I.O COUNTS IN IEF285I */.\n*ZAP     CARD ++ VER(Z038) FMID(EBB1102) PRE(JBB1326).\n*ZAP     CARD ++ ZAP (IEFAB4B0).\n*ZAP     CARD  NAME IEFAB4B0\n*ZAP     CARD  EXPAND IEFAB4B0(128)\nLM02301A CSECT\nIEFAB4B0 DS    0H\n         PRINT ON,GEN,DATA\n         ORG   @PSTART\n         USING *,@12\n         USING @DATD,@11\n*ZAP     START VER\n         ORG   CLRKEY\n         STC   @02,@OLDKEY\n         ORG   CLRTXT\n         MVC   MSGBUFFR+1(73),MSGBUFFR  BLANK ENTIRE BUFFER\n         ORG   STEAL\n         MVI   MSGDISP+1,C' '      DISPLACED INSTRUCTION\n         ORG   @EL00001\n         IC    @02,@OLDKEY\n         ORG   @SIZDATD\n         DC    AL1(230),AL3(@ENDATD-@DATD)\n         ORG   PATCH\n         DC    4F'0'\n*ZAP     START REP\n         ORG   CLRKEY\n         STC   @02,@NEWKEY\n         ORG   CLRTXT\n         MVC   MSGBUFFR+1(78),MSGBUFFR  BLANK ENTIRE BUFFER\n         ORG   STEAL\n         B     PATCH\n* - - - - - - - - - LINES ELIMINATED FOR BREVITY - - - - - - - - - - *\nPATEXIT  MVI   MSGDISP+1,C' '      DISPLACED INSTRUCTION\n         B     MAINLINE\n*\nEDMSK1   DC    X'60206B2020206B202120'\n*ZAP     END\n@DATD    DSECT\n         ORG   @DATD+X'48'\n@PC00001 DS    5F\n         ORG   @DATD+X'B4'\nMSGLNGTH DS    F\n         DS    2F\nMSGBUFFR DS    C\n         ORG   @DATD+X'F7'\nMSGDISP  DS    X\n         ORG   @DATD+X'105'\nMSGCOUNT DS    CL6\n@OLDKEY  DS    AL1\n@ENDATD  EQU   *\n         ORG   @DATD+X'120'\n@NEWKEY  DS    AL1\n         DS    D                   ALIGN TO DUBBLEWORD FOR GETMAIN\n@NEWDATD EQU   *\n         SPACE\nLM02301A CSECT\n*        ***** EQUATES FOR DSECTS  I'M TOO LAZY TO DO THE DROPS\n*        ***** 'N USINGS FOR.\nDSABTIOT EQU   X'10'\nTIOPSTTB EQU   X'12'\nJSCBTCBP EQU   X'D0'                   '\nJSCTMCOR EQU   X'14C'                  '\nTCBTCT   EQU   X'A4'\nTCTIOTBL EQU   X'C'\nTCTDCBTD EQU   X'8'\nTCTIOTSD EQU   X'2'\nTCTDCTR  EQU   X'4'\n*\n*        ***** EQUATES FOR LOCATIONS WITHIN IEFAB4B0\n@PSTART  EQU   IEFAB4B0+X'1C'\nCLRKEY   EQU   IEFAB4B0+X'52'\nCLRTXT   EQU   IEFAB4B0+X'76'\nSTEAL    EQU   IEFAB4B0+X'156'\n@EL00001 EQU   IEFAB4B0+X'2EE'\n@SIZDATD EQU   IEFAB4B0+X'3E8'\nPATCH    EQU   IEFAB4B0+X'45C'\n*        ***** AND OF COURSE, THE REGISTERS\n@01      EQU   01\n@02      EQU   02\n@04      EQU   04\n@05      EQU   05\n@06      EQU   06\n@10      EQU   10\n@11      EQU   11\n@12      EQU   12\n@13      EQU   13\n         END\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.   Illustration of the AMASPZAP input produced by the\n            ASMTOZAP program from the source in Figure 1.  Of\n            course, this output was formatted as SMP/E ++ZAP\n            input instead, by using the *ZAP CARD control cards.\n            Notice the one-to-one correspondence between the\n            assembler source lines and these output lines.  Also\n            please notice how the ZAP CARD, START VER, and START\n            REP control cards determine the appearance of the\n            output deck.\n\n\n++ USERMOD(LM02301) /* I.O COUNTS IN IEF285I */.\n++ VER(Z038) FMID(EBB1102) PRE(JBB1326).\n++ ZAP (IEFAB4B0).\n NAME IEFAB4B0\n EXPAND IEFAB4B0(128)\n*                            ORG   CLRKEY\nVER 0052 4220,B10B           STC   @02,@OLDKEY\n*                            ORG   CLRTXT\nVER 0076 D248,B0C1,B0C0      MVC   MSGBUFFR+1(73),MSGBUFFR  BLANK ENTIRE BUFFER\n*                            ORG   STEAL\nVER 0156 9240,B0F8           MVI   MSGDISP+1,C' '      DISPLACED INSTRUCTION\n*                            ORG   @EL00001\nVER 02EE 4320,B10B           IC    @02,@OLDKEY\n*                            ORG   @SIZDATD\nVER 03E8 E600,010C           DC    AL1(230),AL3(@ENDATD-@DATD)\n*                            ORG   PATCH\nVER 045C 0000,0000,0000,0000 DC    4F'0'\nVER 0464 0000,0000,0000,0000\n*                            ORG   CLRKEY\nREP 0052 4220,B120           STC   @02,@NEWKEY\n*                            ORG   CLRTXT\nREP 0076 D24D,B0C1,B0C0      MVC   MSGBUFFR+1(78),MSGBUFFR  BLANK ENTIRE BUFFER\n*                            ORG   STEAL\nREP 0156 47F0,C440           B     PATCH\n* - - - - - - - - - LINES ELIMINATED FOR BREVITY - - - - - - - - - - *\n*                   PATEXIT  EQU   *\nREP 04E2 9240,B0F8           MVI   MSGDISP+1,C' '      DISPLACED INSTRUCTION\nREP 04E6 47F0,C13E           B     MAINLINE\n*\n*                   EDMSK1   EQU   *\nREP 04EA 6020,6B20,2020,6B20 DC    X'60206B2020206B202120'\nREP 04F2 2120\n* DECK PRODUCED BY THE ASMTOZAP UTILITY 85/12/16 165820\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 3.   Illustration of Assembly JCL that produces a machine\n            readable listing.  This SYSPRINT listing is input to\n            the ASMTOZAP step in Figure 4.\n\n\n//SBHCSCH JOB (A006,SYTM,99,99),S-GOLOB,\n//        CLASS=Q,MSGCLASS=V,NOTIFY=&SYSUID\n/*DIST ROOM-25\n//ASMHC    PROC  MAC='SYS1.MODGEN',\n//         MAC1='SYS1.MACLIB',\n//         MAC2='SYS1.AMODGEN',\n//         MAC3='SYS1.ATSOMAC',\n//         OUT='*',\n//         REG=4M\n//* -------------------------------------------------- *//\n//*     ASSEMBLER H PROC - ASSEMBLE (COMPILE) ONLY\n//* -------------------------------------------------- *//\n//ASM      EXEC  PGM=IEV90,\n//*        PARM='OBJECT,NODECK',\n//         REGION=&REG\n//SYSLIB   DD  DSN=&MAC,DISP=SHR\n//         DD  DSN=&MAC1,DISP=SHR\n//         DD  DSN=&MAC2,DISP=SHR\n//         DD  DSN=&MAC3,DISP=SHR\n//SYSPUNCH DD  DUMMY\n//SYSUT1   DD  DSN=&&SYSUT1,\n//             UNIT=VIO,\n//             SPACE=(CYL,(05,01))\n//SYSPRINT DD  SYSOUT=&OUT\n//   PEND\n//*\n//S01ASM EXEC ASMHC\n//SYSIN  DD DISP=SHR,DSN=SBHCSC.FILE369.PDS(LM01603)\n//SYSPRINT DD DISP=SHR,DSN=SBHCSC.ASMOUT(ZAPINO)   <== FB,LRECL=121\n\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 4.   JCL to run ASMTOZAP.  Input is a machine readable copy\n            of the assembler listing of the ASMTOZAP source deck.\n            Output is a generated zap.\n\n\n//SBHCSCZ JOB (A006,SYTM,99,99),S-GOLOB,REGION=8M,\n//        CLASS=S,MSGCLASS=V,NOTIFY=&SYSUID\n/*DIST ROOM-25\n//******************************************************************//\n//*   ASMTOZAP EXECUTION - FILE 044 OF CBT367 TAPE                 *//\n//******************************************************************//\n//*\n//COPY1   EXEC PGM=ASMTOZAP\n//STEPLIB  DD  DISP=SHR,DSN=SBHCSC.A.LOAD\n//*        DD  DISP=SHR,DSN=SBHCSC.PPILIB    <== PL1 LIBRARY IF NEEDED\n//SYSPRINT DD  SYSOUT=*\n//PL1DUMP  DD  SYSOUT=*\n//IN       DD  DISP=SHR,DSN=SBHCSC.ASMOUT(ZAPINO)     <== LRECL=121\n//OUT      DD  DISP=SHR,DSN=SBHCSC.ZAPOUT(ZAPOUTF)    <== LRECL=80\n//*\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9404JL": {"ttr": 12556, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x94\\x13\\x1f\\x01\\x00)\\x9f\\x11G\\x012\\x012\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1994-05-11T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 306, "newlines": 306, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           July 1994\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\nSam Golob is a Senior Systems Programmer living\nin New Jersey.\n\n\nTWO TOPICS:  THE REBIRTH OF IEHMOVE, AND USING A JES2 EXIT LOADER.\n\n      Sometimes IBM gives up on one of its old tools.  It's a \"pig\",\nthey say.  (Its performance is not very good.)  It is hard to use; it\nhas very awkward control cards.  We sell something better to perform\nthe intended purpose of this original tool (and so does somebody else).\nTherefore, perhaps we should give up, and drop support for this old\npiece of junk.\n\n      All of this is true, concerning the old IBM utility called\nIEHMOVE.  It is very slow and consumptive of CPU and I/O resources.\nIts control cards are next to impossible to tame.  IBM sells something\nmuch better for the intended purpose of moving multiple datasets from\none pack to another (DFDSS copy).  And a competitor also sells something\nmuch better for carrying out IEHMOVE's original purpose (FDRCOPY).\nSo should IBM trash it's old piece of junk?  We will answer with a\nresounding \"NO\".\n\n      IEHMOVE has a reason to live.  We have fully entered the PC age.\nThe topic of saving mainframe-type datasets to diskette, is often\nbrought up.  All kinds of schemes for diskette downloading of mainframe\nfiles have been brought forward.  And IEHMOVE has turned out to be an\nexcellent tool to accomplish this modern-day task.\n\n      The saving feature which IEHMOVE has, turns out to be its\namazing ability to convert many MVS-supported dataset types into\nsequential card-image format.  Sequential fixed block 80-byte card\nimage files are ideally suited for downloading to a PC file.  And if\nthe IEHMOVE-converted card file is downloaded without translation\n(leaving out the ASCII and CRLF keywords), it can be PKZIP-ed and\nstored in a relatively small PC file.  For reloading to mainframe, the\nfile need only be PKUNZIP-ed on the PC, uploaded without translation\nto a (FB-80, blocksize 800) mainframe file, and good old IEHMOVE will\nre-convert this file into exactly its original format, without any\ndistortion, and doing all the dynamic allocations necessary.  What an\nidea!  It works very nicely.\n\n      See Figures 1 and 2 for sample JCL to use IEHMOVE for this\npurpose.  Figure 1 shows how to convert a PDS to IEHMOVE sequential\nfixed block format.  Please be reminded that IEHMOVE control cards and\nddnames are very strange, but this JCL has been tested to work.  Also\nremember that the blocksize of the sequential dataset always has to be\nthe antiquated value of 800 bytes per block.  There is an additional\nrestriction that the target sequential file cannot reside on an\nSMS-managed volume, although the original file or pds can be managed\nby SMS.  Figure 2 shows how to use IEHMOVE to load the sequential\ncard-image dataset back into its original form.  The original pds can\neven contain load modules or variable blocked data, and IEHMOVE does\nthe format conversion and dataset allocation automatically.\n\n      I am very impressed with this technique.  My initial exposure\nto it was when someone made a contribution to the CBT Tape on a diskette\nthat was in this format.  Load and source libraries were faithfully\nreproduced from the diskette which I received.  Downloading and\nuploading distortion was nonexistent, because there was no character\ntranslation, and the 80-byte card images are downloaded and uploaded\nnicely by most PC-to-mainframe connections.  IEHMOVE is far more\nreliable than IEBCOPY for this purpose, because the variable blocked\nIEBCOPY unload records do not download and upload reliably to the PC.\nIt looks as though IEHMOVE has found its niche in this modern age.\nWe should all try and lean heavily on IBM not to drop support for\nIEHMOVE, our new-found friend.\n\n      And now to the next subject.\n\n\nUSING A JES2 EXIT LOADER.\n\n      Many shops run JES2 with user exits.  In fact, JES2 exits are\nthe \"official\" IBM way of getting around the headaches caused by\ninstallations creating their own mods to JES2 main code.  IBM's\npractice of providing exit points in many strategic places during\nJES2 processing, has made life relatively easier for systems\nprogrammers working in this general area.  For one thing, you don't\nhave to refit your mods whenever IBM changes their large main\nroutines.  Usually, your exit programs are smaller, and they are\nself-contained.  Although some of the user exits might be dependent\non other exits at your installation, all of the \"user-stuff\" is found\ntogether.  It can therefore be modified in a concentrated effort when\nchanging JES2 releases.\n\n      That doesn't mean that life is peaches and cream during JES2\nrelease conversions.  JES2 exit coding techniques are far from being\nrelease-independent.  For example, when IBM changed the format of the\nJES2 Load Module Table, any exits which looked at the LMT during their\nprocessing, had to change their mode of access.  Similar considerations\nwould apply for any other JES2 control blocks that might change (and\nmany of them do change).  Two notable recent examples are the Network\nJob Header (NJH) and the Remote Destination Table (RDT).  The systems\nprogrammer who writes or modifies JES2 exits must be aware of many\nissues involving JES2 internal functioning, and must be awake to all\nmajor re-architecting that was done for a new JES2 release.  That is\nwhy IBM emphasizes that novices in JES2 should not be coding JES2\nexits unless they proceed very carefully, and with the advice of more\nadvanced personnel.\n\n      One major fact about JES2 that systems programmers should know,\nis that different parts of JES2 function in different arenas.  Much\nJES2 code operates in the JES2 address space.  Some JES2 code runs in\ncommon storage, such as the Link Pack Area.  Still other JES2 code\nruns in the user's address space.  There is communication between\nthese parts by various mechanisms.  However, the relevant point is\nthat when one codes a JES2 exit, one must be extremely aware of the\nsurroundings and environment in which this particular exit operates.\nEach environment has its own rules.  The JES2 Customization manual\nis the place to look for such information.\n\n      Nowadays, in the later JES2 releases, this is taken a bit\nfurther.  You can specify in JES2 startup parms, whether a particular\nexit module is to be loaded in the JES2 address space, or in LPA, or\nin CSA.  This gives the user an added piece of control.\n\n      We now come to our main question.  What happens when a JES2 exit\ndoesn't work properly?  Ideally, we would like to plug in a new version\nwithout disturbing any other JES2 operations.  We don't have that from\nIBM, at present.  The current IBM mechanism allows for enabling or\ndisabling of any exit routines.  For example, if you have an Exit 5\nRoutine (which does JES2 command modification) installed, you have the\nchoice of keeping it in (enabling) or taking it out (disabling).  If\nyou have two Exit 5 routines, you must either enable them both, or\ndisable them both.  You don't have the ability to disable or modify one\nroutine.  To actually change the version of one Exit 5 routine, you\nhave to stop the JES2 address space, change the routine in the Link\nList, refresh LLA, and then Hot-Start JES2.  This can be very upsetting\nto a shop's operation, and it is usually done only in a crippling\nemergency situation.  The situation is even worse for LPA- or\nCSA-loaded exits.  These exits need a complete IPL to make changes.\n\n      There is currently a SHARE requirement for IBM to create an\n\"exit loader\" command, whereby one can refresh a single JES2 exit\nmodule with a new copy.  IBM now has no such thing.  However, the\nuser community has a partial solution which works very well.  For\nuser exits that operate in the JES2 address space or in the converter\nsubtask, there is a program which supports dynamic exit refreshes.\nThis program itself is a JES2 exit.  (It happens to be an Exit 5\nroutine.)  And it can piggyback nicely with any other JES2 Exit 5\nroutines you happen to be running.\n\n      When this program is operational, the operator (or preferably\nthe systems programmer) enters a $LOAD command, followed by a fill\ncharacter and the load module name of your exit routine.  If the JES2\nLoad Module Table \"knows\" about the module name you entered, the\ncurrent Link List will be searched for a fresh copy, and that version\nwill be plugged in and used instead of the previous copy.  If the\nmodule name is not in the JES2 LMT, you get a console error message,\nand no action is taken.  This is the result that we want.  The new\nversion of the module becomes usable immediately.\n\n\nINSTALLING THE EXIT LOADER.\n\n      Where can this program (the Exit Loader) be found, and how is\nit installed?  The answer is that it depends on the version of JES2\nyou are running.  Various versions of the JES2 Exit Loader can be\nfound on several files in the CBT MVS Utilities Tape.  You can obtain\na copy of the CBT Tape from NaSPA.\n\n      For JES2 Version 4, there is a suitable version of the Exit\nLoader on File 196 of the CBT Tape.  A JES2 Version 2.2.0 level of\nthe Exit Loader is on File 381 of the CBT Tape.  The Exit Loader,\nbeing a JES2 exit itself, must be assembled against your current level\nof the SMPMTS and SYS1.HASPSRC, as well as against the current\nSYS1.MACLIB and SYS1.MODGEN.  After it is placed into a Link List\nlibrary (preferably as an SMP usermod), the JES2PARM JES2\ninitialization deck has to be modified with LOADMOD and EXIT(5)\nstatements, as in Figure 3.  When JES2 is then brought up after an\nIPL, you can issue a $DEXIT5 command to display if the proper exit\nroutines are being used.  In JES2 Version 4, you can also use a\ncommand $DMODULE(J005LOAD) to see if your preferred level of the Exit\nLoader (or any other JES2 module) is currently being used.\n\n\nLIMITATIONS OF THE EXIT LOADER.\n\n      The JES2 Version 4 levels of the Exit Loader are not intended to\nload CSA- or LPA-resident JES2 exits.  Coding for that type of exit\nloading is considerably trickier than what we have here.  Of course,\nwe would prefer if IBM completely supported the process of dynamic\nexit loading.  The SHARE requirement for this has high priority,\nbecause for 24-hour operation of a data center, it would be very\nhelpful to have complete dynamic replaceability of JES2 exit code.\nBut it isn't here yet, folks.  We have to do what we can now, using\nour own Exit 5 routine.  And we have to keep up our pressure on IBM,\nespecially through the SHARE organization.  The SHARE JES2 requirements\ncoordinator is David Dyche, 713-596-2466, and his Internet address\nis dd@chevron.com .\n\n\nCONCLUSION.\n\n      IBM, as a software service organization, gets considerable\ninput from innovative users of their software offerings.  Today, we\nhave seen two examples showing why it is up to us, as users, to\nprevail upon IBM's thinking.  In the first case, who knows whether\nIBM would ever tout IEHMOVE as an aid to diskette preservation of\nmainframe data (and fix some of its inefficiencies).  In the second\ncase, a glaring omission in JES2 exit functionality for the current\nday and age, has clearly shown itself.  Let's raise our glasses\n(after we write our letters to the SHARE JES2 Requirements\ncoordinator) in the hope that IBM wakes up to these valid customer\nneeds.\n\n      Meanwhile without IBM's further help, we've got a bunch of new\nideas to think about and add to.  Good luck in the thinking and adding\nactivities.  See you next time.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n Figure 1.  This is IEHMOVE JCL to unload a cataloged partitioned\n            dataset into IEHMOVE format, ready for downloading to\n            PC.  For an uncataloged pds, you have to consult your\n            DFP Utilities manual.  I've tried this JCL, and\n            miraculously, it works.  To put a sequential dataset\n            into FB-80 format, use the keyword \"COPY DSNAME\"\n            instead of \"COPY PDS\".\n\n\n//SBGCSCR JOB (A006,SYTM,99,99),S-GOLOB,REGION=8M,\n//        CLASS=S,MSGCLASS=V,NOTIFY=&SYSUID\n/*DIST ROOM-25\n//* --------------------------------------------------------------- *//\n//* --    JCL TO UNLOAD A PARTITIONED DATASET TO AN IEHMOVE      -- *//\n//* --         FORMAT SEQUENTIAL DATASET THAT IS FIT TO          -- *//\n//* --         BE DOWNLOADED TO A PC HARD DISK OR FLOPPY.        -- *//\n//* --------------------------------------------------------------- *//\n//MOVE    EXEC PGM=IEHMOVE,PARM='POWER=4'\n//SYSPRINT   DD  SYSOUT=*\n//*\n//DD1        DD  DISP=SHR,DSN=SBGCSC.A.LOAD\n//*   DD1 is \"FROM\" PDS and can even be on an SMS-MANAGED volume.\n//*\n//DD2        DD  DISP=SHR,DSN=SBGCSC.A.DATA\n//*   DD2 is cataloged dataset on a NON-SMS-MANAGED volume,\n//*    where the TARGET DATASET is to reside.\n//*\n//SYSUT1     DD  DISP=SHR,DSN=SBGCSC.A.DATA\n//*   SYSUT1 is a cataloged dataset which determines a volume\n//*    where the WORK DATASET resides.\n//*\n//SYSIN      DD  *\n  COPY PDS=SBGCSC.A.LOAD,UNLOAD,                                       X\n               TO=3390=ACS001,RENAME=SBGCSC.A.LOAD.IEHMOVE,CATLG\n/*\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.   This is IEHMOVE JCL that takes an unloaded dataset in\n            IEHMOVE format, and converts it into an exact copy of\n            the original dataset or pds, blocksize and all.\n\n\n//SBGCSCR JOB (A006,SYTM,99,99),S-GOLOB,REGION=8M,\n//        CLASS=S,MSGCLASS=V,NOTIFY=&SYSUID\n/*DIST ROOM-25\n//MOVE    EXEC PGM=IEHMOVE\n//SYSPRINT   DD  SYSOUT=*\n//SYSUT1     DD  DISP=SHR,UNIT=SYSDA,VOL=SER=ACS001\n//FROMDD     DD  DISP=SHR,DSN=SBGCSC.FILE183.IEHMOVE\n//TODD       DD  UNIT=SYSDA,VOL=SER=ACS001,DISP=SHR\n//SYSIN      DD  *\n  COPY DSNAME=SBGCSC.FILE183.IEHMOVE,FROMDD=FROMDD,TO=3390=ACS001,     X\n               RENAME=SBGCSC.FILE183.PDSIN\n/*\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 3.   These are sample user exit statements that must be added\n            to the JES2 startup parm deck.  The LOADMOD statements\n            instruct JES2 to look in a link list library to find load\n            modules having the given names.  The EXIT(nn) statements\n            tell JES2 to look in the loaded modules and find entry\n            points matching the stated names.  In a JES2 module, an\n            entry point is coded as a label to a $ENTRY macro.  For\n            instance, the load module J005LOAD has a $ENTRY macro\n            coded, whose label name is E005LOAD.\n\n\n     LOADMOD(JES2X04)              /* Exit 4 - JCL and JECL scan */\n     LOADMOD(JES2X05)              /* Exit 5 - JES2 command mods */\n     LOADMOD(J005LOAD)             /* Exit 5 - Jes2 Exit Loader  */\n\n     EXIT(4)  ROUTINE=EXIT4,\n              STATUS=ENABLED,\n              TRACE=NO\n     EXIT(5)  ROUTINES=(EXIT5,E005LOAD),\n              STATUS=ENABLED,\n              TRACE=NO\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9405OC": {"ttr": 12806, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x10\\x00\\x94\"o\\x01\\x19\\x14O\\x14%\\x00\\xf3\\x00\\xf4\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1994-08-14T00:00:00", "modifydate": "2019-05-24T14:25:10", "lines": 243, "newlines": 244, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          October 1994\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\nSam Golob is a Senior Systems Programmer living\nin New Jersey.\n\nTHE \"REVIEW\" COMMAND REVISITED\n\n      Several weeks ago, our operations manager Roman Panczyszyn asked\nme to install the QUEUE program, which is a \"free\" JES2 spool browser.\nWhen I asked him why he specifically wanted QUEUE, even though we also\nown SDSF, he replied that QUEUE has a \"find all\" command (called FALL)\nthat only displays \"found\" lines without showing the others.  When\nyou're searching for the history of one specific job while looking\nthrough the whole SYSLOG, this is a useful thing to have.\n\n      After I installed QUEUE for him, he asked me another thing.\nThat's fine for the current SYSLOG, but what about our old SYSLOGs\nthat are archived on datasets and on tape.  Can't I have a facility to\njust display \"found\" lines for them too?  I thought for a moment, and\nasked: \"How do I look at old SYSLOGs on disk and on tape?  I use the\nREVIEW command, a generalized file browsing program that is ideally\nsuited for the task.  REVIEW is privately maintained by Greg Price in\nAustralia.  I wouldn't have to call IBM and try to get them to change\nany of their programs.  Let me call Greg and see what he has to say.\"\n\n      That day, I called Greg in Melbourne.  I asked him to try and\ninstall a \"FIND ALL\" facility in REVIEW that is akin to the FALL command\nin QUEUE.  Greg rang me back a week later, telling me that the coding\nwas installed in REVIEW and he would be sending me a tape immediately.\nIn two and a half weeks, the updated REVIEW command was placed on the\nCBT MVS Tape (Version 379, File 134) and was ready to be distributed\nto the public.  It was also installed at my site, and given to the\noperations department.  Roman has expressed his happiness.  As for me,\nI'd challenge any software vendor to add a new feature with this kind\nof speed.  Incidentally, if you want a new CBT Tape to see all this\nsoftware, you can order one from NaSPA.  (Now you can just download\nFile 134 (REVIEW source) and File 135 (the load modules) from the web\nsite, www.cbttape.org.)\n\n\nA REVIEW OF \"REVIEW\".\n\n      What is this REVIEW program, and why is it special?  REVIEW is\na full-screen TSO command to browse data files.  You might ask, \"I\nthought we had ISPF BROWSE for that.  Why do we need something else?\nCan't we get everything we need from IBM?\"  The answer is that REVIEW\ndoesn't need ISPF services (although it can use them if they're\navailable).  Also, REVIEW can do a zillion more things than ISPF\nBROWSE.  It can often do them a lot faster, especially if you're\nlooking at big files.\n\n      For example:  REVIEW can format SMF records and LOGREC\nrecords.  It can look at VSAM files and at files with I/O errors.\nREVIEW can now even write some of the records it's looking at, to an\noutput file.  REVIEW handles PDS'es nicely.  It is capable of\n\"sequentializing\" a PDS using all or some of its members, into\nIEBUPDTE unload format.  REVIEW can show you tape files as well as\ndisk files.  You can even look at a DB2 tablespace, row by row.\n\n      Why should we talk about REVIEW now?  I've already written\nabout it before.  The answer is that REVIEW is evolving, and Greg\nPrice keeps putting more features into it.  (It is \"a terminal case\nof creeping featurism\", in Greg's words.)  The REVIEW command of\ntoday is not the REVIEW command of yesterday.  There's more to write\nabout, because there's more that you can use.  For the rest of this\narticle, we'll mention a few of the lesser known features in REVIEW\nand show you how to use them.\n\n      REVIEW comes with good documentation.  Its HELP member, plus\nthe comments at the beginning of the source code on CBT Tape File\n134, and the document on \"undocumented\" commands, will guide you\nthrough REVIEW's powerful capabilities very completely.\n\n\nA FEW INTERESTING THINGS FOR STARTERS.\n\n      Let's start with some simple things.  Nowadays, there's a lot of\nfile transfer going on between the mainframe and other systems.  On\nIBM systems, the usual means of representing data is EBCDIC.  On many\nother systems, the data representation method is ASCII.  If you look\nat an ASCII file on an EBCDIC system it is complete gibberish.  IBM in\nits \"ultimate foresight\" has not provided a way to look at ASCII files\nin ISPF/PDF.  However, if you REVIEW an ASCII file on disk or on tape,\nlook at the initial gibberish, and type the command, ASCII, all of a\nsudden, the file has been translated into ASCII and it makes sense.\nType the word ASCII on the command line again, and the representation\ntoggles back to EBCDIC.  This also works for tape files.\n\n      Speaking about tape files, REVIEW makes them almost as\naccessible as disk files.  It helps to have TSO \"MOUNT\" attribute\nturned on for this.  If the \"MOUNT\" attribute is turned on, and your\nTSO session requests allocation of a tape, then the system will prompt\nthe operator to mount the tape.  Otherwise, the mount request will\nusually be blocked.\n\n      A systems programmer is not helpless regarding the TSO MOUNT\nattribute.  There is an authorized command on the CBT MVS Utilities\nTape (File 300) called CPSCB (change the PSCB), which can toggle the\nMOUNT attribute on and off.  Another command (not authorized) called\nLPSCB (list the PSCB) shows you the state of the PSCB (protected\nstep control block) for your TSO session.  Using LPSCB, you can see if\nMOUNT is off or on for your session.  It is my experience that bit\nsettings in the PSCB will take precedence over RACF settings for\nwhether \"MOUNT\" is turned on or off, because RACF just helps to\ninitialize the PSCB when your TSO session is being started.  However,\nwhile the session is running, the system seems to refer just to the\nPSCB, so that altering the PSCB is quite effective in giving you the\ncontrol you want.  In most shops, temporarily acquiring the \"MOUNT\"\nattribute should be no problem.  See my thoughts on personally\nauthorizing your TSO commands, which are in CBT Tape Files 185 and\n186.\n\n      Once \"MOUNT\" is turned on, if you REVIEW a cataloged file that\nis 'File 1' on a standard-labeled tape, then your console operator will\nimmediately get a mount message for that particular volume.  When the\ntape is mounted, REVIEW proceeds to show you the file, almost the\nsame as if it were a disk file.  To REVIEW a non-cataloged file on\na standard-labeled tape, you use the VOL parameter, as for a\nnon-cataloged disk file.  To REVIEW a file which is not 'File 1',\nplease refer to the REVTAPE clist, which is printed in Figure 1.\n\n\nCOPYING PARTS OF A FILE.\n\n      Two new commands were recently added to REVIEW, to relieve some\nof the frustration that accompanies the use of any browsing program.\nThe problem is that you can see, but you can't touch.  The two new\ncommands, CUT and ADD, allow you to touch what you're browsing as well\nas just to look at it.  CUT copies a certain number of lines, via QSAM,\nto the REVIEW output dataset.  ADD does the same as CUT, except that\nthe copied lines are appended to the end of the output dataset.  These\ntwo commands allow for a considerable amount of flexibility.  The\ncopied lines begin from the top of the screen you're positioned to.\n\n      As currently implemented in REVIEW, any output file that REVIEW\nsends data to, has to have the ddname of SYSUT2.  You can use the\n\"TSO\" subcommand of REVIEW while REVIEWing any dataset, to invoke this\nallocation.  For example, you can say:  TSO ALLOC FI(SYSUT2)\nDA(OUTP.SEQ.FILE)) SH REUSE while you're REVIEWING a large dataset.\nThen you position to the place where you want to start copying lines.\nTo copy 836 lines starting from the current place, just type: \"CUT\n836\" on the command line, and REVIEW will copy that number of lines.\nIf you want to start at a different place in your file, and you want\nto add 87 more lines to the output dataset, just position yourself\nthere, and type: \"ADD 87\".  Thus, you have \"touch and feel\" access to\nthe data you're looking at.  This works for VSAM browsing also.  Just\ndon't give the output dataset SYSUT2 any DCB attributes when you're\nallocating it as NEW under TSO.  Let REVIEW supply the DCB attributes\nif you're looking at a VSAM file.  REVIEW will give the output dataset\nRECFM(U) when you're copying VSAM records.\n\n\nLOOKING AT DISK AND TAPE LOCATIONS.\n\n      REVIEW lets you go directly to a relative TTR disk location, or\nto a relative block tape location.  When REVIEWing a dataset, simply\nenter the command:  NEWTOP ttr-value.  The ttr-value is usually a 5 or\n6-digit number.  If you're looking at a tape file, the number will be\nthe relative block of the tape file you're looking at.\n\n      NEWTOP pretends that the top-of-data is the relative TTR or\nblock address you've specified.  For example, \"NEWTOP 00001\" points to\nthe real top-of-data for a sequential file.  \"NEWTOP 00101\" points to\nthe first record in the second relative track of the file.  \"NEWTOP\n00302\" points to the second record in the fourth relative track of the\nfile.  If you go to the bottom of a file or pds member you're\nREVIEWing, REVIEW will display the end-of-file TTR, so you can get\nsome orientation as to what values to use.  The abundant REVIEW\ndocumentation will help you very much.\n\n      How can NEWTOP help you recover a file that has I/O errors when\nyou try to access it?  You may not be able to recover all of the\nfile, but you'll probably recover most of it.  Suppose for simplicity\nthat the bad file is physical sequential.  Allocate SYSUT2 to a new\nfile with the same DCB attributes.  Then REVIEW the file from the\ntop.  Do a FIND on some non-existent string, to force REVIEW to look\nat every record of the file.  When the I/O error hits, go to the\npreceding TTR and note its last line number.  Go back to the top and\nenter the CUT command with the proper number of lines to copy.  Then\nstep through successive TTR locations.  Keep entering \"NEWTOP ttr\"\nfor the next TTR, until you get real data again.  Repeat this\nprocess for the later data, except that you use the ADD command to\nappend the new data, instead of the CUT command.  In this way, you'll\nrecover all of the good data in the file.\n\n\nIN SUM.\n\n      There's very much more practical everyday utility to be found in\nthe REVIEW command.  Look at its HELP member and the other descriptions\nto be found on the CBT Tape File 134.  REVIEW can assist you in many\nways you've never previously dreamed of.  Spend some time with REVIEW,\nand I assure you that REVIEW will repay your time, with interest.\n\n      Good luck.  We're monthly again.  See you next month.\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.  This is the REVTAPE CLIST which is shipped together with\n           the REVIEW command in File 134 of the CBT MVS Tape.  This\n           CLIST makes it possible to look at tape files which are\n           not the first file on a tape.\n\n\nPROC 1 DSN VOLSER(REVIEW) UNIT(TAPE) LBL(BLP) FSN(1) PTF\nCONTROL NOFLUSH\n/*\n/*  CLIST TO SEE WHAT IS ON A TAPE VOLUME.\n/*\n/*  UNLESS AUTOMATIC VOLUME RECOGNITION IS EXPLOITED, USERS WITHOUT THE\n/*  MOUNT ATTRIBUTE WILL NOT GET VERY FAR.  CATALOGUED TAPE DATA SETS\n/*  CAN BE REVIEWED DIRECTLY WITHOUT THIS CLIST.  UNCATALOGUED\n/*  STANDARD LABELLED DATA SETS CAN ALSO BE REVIEWED DIRECTLY WITHOUT\n/*  THIS CLIST BY SPECIFYING UNIT AND VOLUME ON THE COMMAND, ONLY AS\n/*  LONG AS THE FILE SEQUENCE NUMBER IS ONE (1).  THIS CLIST CAN BE\n/*  USED TO REVIEW TAPE LABELS AS WELL AS TAPE DATA FILES.\n/*\n/*  IN THE EVENT OF ANY ABNORMAL TERMINATION WHICH FLUSHES THE CLIST,\n/*  REVFILE WILL NOT BE FREED, SO PLEASE ENSURE THAT YOU DO NOT\n/*  UNNECESSARILY HOG A TAPE DRIVE.\n/*\nIF '&LBL' = 'SL' OR '&LBL' = 'AL' THEN GOTO NOATTR\nIF &PTF =   THEN ATTR REVATTR DSORG(PS) BLKSIZE(32760) RECFM(U)\n   ELSE ATTR REVATTR DSORG(PS) BLKSIZE(7200) RECFM(F B) LRECL(80)\nALLOC FILE(REVFILE) DA(&DSN) USING(REVATTR) UNIT(&UNIT) LABEL(&LBL)  -\n      VOLUME(&VOLSER) POSITION(&FSN) SHR REUSE\nFREE ATTR(REVATTR)\nGOTO REVIT\n                           /* USE DCB INFORMATION FROM TAPE LABELS. */\nNOATTR:  -\nALLOC FILE(REVFILE) DA(&DSN) UNIT(&UNIT) LABEL(&LBL)  -\n      VOLUME(&VOLSER) POSITION(&FSN) SHR REUSE\nREVIT: REVIEW REVFILE FILE\nFREE FILE(REVFILE)\nEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9406NV": {"ttr": 12811, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x94%\\x7f\\x01\\x00)\\x9f\\x11G\\x00\\xfa\\x00\\xfa\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1994-09-14T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 250, "newlines": 250, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          November 1994\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\nSam Golob is a Senior Systems Programmer living\nin New Jersey.\n\n\nYOUR TSO SESSION - USING THE PSCB\n\n      Oftentimes a simple control block exerts a very powerful\ninfluence on how a program runs.  In the case of your TSO session,\nsome of the PSCB (Protected Step Control Block) fields will have a\nvery crucial effect on what the session can do.  It is my feeling that\na systems programmer, who works under TSO all day, will profit greatly\nfrom having an enhanced understanding of what the PSCB controls.\nControl of the OPER, MOUNT, JCL, and ACCOUNT attributes of your TSO\nsession will help you accomplish many system tasks better.\n\n      The macro IKJPSCB in SYS1.MACLIB, which maps the PSCB,\ndescribes the PSCB as a control block used to maintain user\nattributes and accounting data on a userid basis.  The PSCB is\nestablished at LOGON time, it is unique for each TSO session, and it\nis userid oriented.  Obviously, this control block plays a big part\nin determining the kind of power your TSO session will have.\n\n      Bill Godfrey, a pioneer system software writer, wrote two TSO\ncommands which allow a systems programmer to make best use of practical\nPSCB knowledge.  These commands are LPSCB (list the PSCB) and CPSCB\n(change the PSCB).  Obviously LPSCB, which does not do any\nalterations, can be made available to more users than CPSCB, which\nmust run authorized, and which should be restricted to systems\npersonnel only.  Today, we will learn to use both of these commands\nprofitably, to help us exploit the power of the PSCB control block.\n\n      Of course, if you want to try this software yourself, you have\nto know where to obtain it.  Both the LPSCB and CPSCB TSO commands can\nbe found in source form on File 300 of the CBT MVS Utilities tape.\nThe CBT Tape contains a world of useful software for MVS, and can be\nordered through NaSPA.\n\n\nSOME PSCB EXAMPLES.\n\n      Last month, we talked about using the REVIEW command to look at\ntape files, the same way you can use it to look at disk files.  This\npower is greatly facilitated if your TSO session possesses the MOUNT\nattribute.  Many people are of the opinion that the MOUNT attribute\nshould not be on by default, even for systems programmers, because you\nmay inadvertently interfere with tape operation from your TSO session.\nThe most desirable scenario would be to turn MOUNT on only when you\nneed it, keeping it off the rest of the time.\n\n      Now, since the presence or absence of the MOUNT attribute is\ndetermined by the PSCB, you can therefore turn MOUNT on or off if you\ncan change the appropriate bit in the PSCB for your session.  At this\npoint, one might ask the question:  \"Doesn't the security system (e.g.\nRACF) set this attribute?\"  The answer seems to be that RACF plays a\npart in initializing the PSCB with its session attributes during TSO\nLOGON processsing.  However, once the session is active, TSO looks\nonly at the PSCB to determine these session attributes.  RACF is\ninvolved only at the beginning.  Therefore, RACF will not interfere\nwith what we want to do.\n\n      So practically, if it is possible for you to install and\nauthorize Bill Godfrey's CPSCB command for yourself, you can now enter\na TSO command, \"CPSCB MOUNT\" or \"CPSCB NOMOUNT\" to toggle the MOUNT\nattribute on and off when you need it.  To check on the current state\nof your session, you can use Bill Godfrey's \"LPSCB\" command to display\nwhether the MOUNT attribute is currently on or off.\n\n      Thus, if you'd want to use the REVIEW command (CBT MVS Tape -\nFile 134) to browse a cataloged tape file and the MOUNT attribute is\non, the TSO command \"REVIEW tape.dsname\" will cause a console tape\nmount message to be issued for operator response.  The console\nmessage will ask the operator to mount the appropriate tape.  If the\nMOUNT attribute is off, the TSO user will get an error message and no\ntape action will occur.\n\n      Here's another example (for strict systems use only).  Suppose\nyour TSO broadcast dataset is full and the \"BRODSCAN\" batch program\n(CBT Tape Files 136, 437, 453) has been used to determine what filled\nit up.  Your decision is that you want to clear the SYS1.BRODCAST\ndataset.  However, there is the slight drawback that your TSO session\ndoes not have the ACCOUNT attribute.  This can be discovered by using\nLPSCB, or by trying to execute IBM's \"ACCOUNT\" command and finding\nthat it doesn't work.  If CPSCB is installed and authorized, the\ncommand \"CPSCB ACCOUNT\" will remedy that situation.  The command\n\"CPSCB NOACCOUNT\" could be used later to turn the ACCOUNT attribute\nback off.  You can use LPSCB to check if CPSCB worked.  Once the\nACCOUNT attribute is on for your TSO session, you can use the\n\"ACCOUNT\" TSO command from IBM, and issue its SYNC subcommand to clear\nthe SYS1.BRODCAST dataset of extraneous messages.\n\n      Obviously, you'll want to be very careful to restrict these\nfacilities to the smallest group possible.  But as \"system doctors\",\nyou'll find them to be extremely handy in your own work.\n\n\nADDITIONAL INFORMATION.\n\n      Figures 1 through 4 will help round out your practical knowledge\non this subject, and will help show you where to look further.  Figure\n1 displays the output of the LPSCB command in its detail.  The session\nshown has a lot of power, since most of the available attributes are\nturned on.  It is instructive to compare the output of LPSCB with the\nIKJPSCB macro from SYS1.MACLIB, part of which is shown in Figure 3.\nYou can, of course, see the full macro IKJPSCB by looking at it in\nSYS1.MACLIB on your own system.  Figure 2 shows the TSO HELP member\nfor LPSCB, and Figure 4 shows how to use the CPSCB command.\n\n      I mentioned the subject of \"personal\" TSO authorization in a\nprevious column (February 1993).  All of my previous columns can be\nfound on File 120 of the CBT Tape, so if you have a fairly new tape,\nyou don't have to download the column from NasCOM.  If you have access\nto the abovementioned \"fairly new\" CBT Tape, Files 185 and 186 will be\nespecially helpful on this subject, and they will save you a lot of\nwork.\n\n      A useful manual describing TSO control blocks is:  \"A Guide to\nWriting a TMP or Command Processor\" for older versions of TSO, or its\nsuccessor, \"TSO/E Version 2 Programming Services\".  Also, \"TSO/E\nVersion 2 Customization\" will be helpful.  \"TSO Command Processor\"\nprogramming examples abound all over the CBT Tape.  Notable files to\nscan are:  File 423 from my own TSO teacher, Jeff Broido, and the huge\ncollection, File 300 from Jim Marshall.\n\n      All this should serve as a haphazard introduction to the\nworld of TSO in general, and as a practical aid to getting past\nsome obstacles in your systems programming work.  In any case, the\npath for learning is now open.  You can walk on it if you wish.\n\n      Good luck.  See you next month.\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   Output of the LPSCB TSO command.  Notice that most fields\n            of the PSCB are displayed, and many of them are interpreted.\n            In my opinion, the most frequently used part of this\n            display is PSCBATR1, whose flags control much of the TSO\n            session's power.\n\n\n005F80 PSCB ADDRESS\n    +0  PSCBUSER E2C2C8C3E2C340   SBHCSC\n    +7  PSCBUSRL 06\n    +8  PSCBGPNM 4040404040404040\n   +10  PSCBATR1 F500             OPER ACCT JCL MOUNT  RECOVER\n   +12  PSCBATR2 0000\n   +14  PSCBLTIM A9DE65FA3B399344\n   +1C  PSCBSUB  00000000\n   +20  RESERVED 0000009A00000000\n   +28  PSCBDEST 0000000000000000\n   +30  PSCBRLGB 00006EC0\n   +34  PSCBUPT  00006FC8\n   +38  PSCBUPTL 0038\n   +3A  PSCBCHAR 00\n   +3B  PSCBLINE 00\n   +3C  PSCBRSZ  00000FA0\n   +40  PSCBU    0000000000000000\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.   This is the TSO HELP member for the LPSCB command.  It\n            is self-explanatory.\n\n\n)F FUNCTION -\n  THE LPSCB (LIST PSCB) COMMAND LISTS THE PROTECTED STEP\n  CONTROL BLOCK (PSCB) IN A TSO USER'S REGION.\n  IT OPTIONALLY LISTS THE USER PROFILE TABLE (UPT).\n\n)X SYNTAX  -\n         LPSCB  CPPL/REAL UPT\n  REQUIRED - NONE\n  DEFAULTS - CPPL\n  ALIAS    - NONE\n)O OPERANDS -\n))CPPL      -  THE PSCB ADDRESS IN THE CPPL WILL BE USED.\n))REAL      -  THE PSCB ADDRESS IN THE JSCB WILL BE USED.\n))UPT       -  LIST THE USER PROFILE TABLE TOO.\n\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 3.   This is the beginning of the PSCB mapping macro IKJPSCB.\n            Fields up to the two attribute bytes are shown.  It is\n            instructive to compare these fields with the LPSCB display\n            shown in Figure 1.\n\n\nPSCB     DSECT\n         DS    0F\nPSCBUSER DS    CL7      USERID PADDED RIGHT WITH BLANKS\nPSCBUSRL DS    CL1      LENGTH OF USERID\nPSCBGPNM DS    CL8      ESOTERIC GROUP NAME INIT BY LOGON      @PD70423\n*                       USED BY DYN ALLOC WHEN UNITNAME NOT SPECIFIED\n*                       BUT IS REQUIRED\nPSCBATR1 DS    X        A 16 BIT STRING OF USER ATTRIBUTES     @YA43565\nPSCBCTRL EQU   X'80'    OPERATOR COMMAND USER\nPSCBACCT EQU   X'40'    ACCOUNT  COMMAND USER\nPSCBJCL  EQU   X'20'    SUBMIT   COMMAND USER\nPSCBVMNT EQU   X'10'    CNTL VOL MOUNT AUTH                      Y02669\nPSCBATTN EQU   X'08'    LINE DELETE CHAR IS ATTENTION            Y02669\nPSCBRCVR EQU   X'04'      0 -- EDIT RECOVER CAPABILTY          @YA22385\n**                        1 -- NORECOVER CAPIBILTY             @YA22385\n**     NOTE--  BIT PSCBRCVR IS USED DIFFERENTLY                @YA22385\n**             1 MEANS NO EDIT RECOVERY CAPABILTY FOR THE USER @YA22385\nPSCBRRBA EQU   X'02'    USER RBA CONTAINS INCORRECT ADDRESS OF @PD70423\n*                       USER MAIL DIRECTORY, REPLACE WITH      @E1113KS\n*                       PSCBDRBA AT LOGOFF                     @E1113KS\nPSCBCNAU EQU   X'01'    CONSOLE authority                      @E22D2D3\n* BITS 8 - 15           RESERVED FOR IBM USE                   @E22D2D3\n         DS    X        RESERVED\nPSCBATR2 DS    X        A 16 BIT STRING CONTAINING THE USERDATA FIELD\n*                                                              @YA43565\n         DS    X\n*\n*. . .  The remainder of the DSECT has been deleted for brevity  . . .\n*\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 4.   Syntax of the CPSCB TSO command.\n\n\n      Once the CPSCB command is installed and authorized, it refers\n      to the TSO session attributes as shown by the LPSCB command\n      in Figure 1.  Thus, to turn on/off attributes, you do the\n      following:\n\n\n            CPSCB   (OPER|NOOPER)\n                    (ACCOUNT|NOACCOUNT)\n                    (JCL|NOJCL)\n                    (MOUNT|NOMOUNT)\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9407DE": {"ttr": 13061, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x94)\\x1f\\x01\\x00)\\x9f\\x11G\\x01\\x1c\\x00\\xbc\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1994-10-18T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 284, "newlines": 188, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          December 1994\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\nSam Golob is a Senior Systems Programmer working\nin New York City.\n\n\nYOUR TSO SESSION - USING THE TSO SESSION MANAGER\n\n      Nowadays, we're often surprised that \"ancient\" software can be\njust as useful today as it once was.  We have many examples of this.\nA few months ago (in the July 1994 issue) I wrote about the IEHMOVE\nprogram and how it can be useful in these times, to prepare mainframe\nsequential files and PDS'es for download to PC disks.  Another example\nconcerns the use of a CLIST to invoke batch SMP/E under TSO, which I\nwrote about some time ago (October 1992).  This kind of CLIST had been\ncommon during SMP4 days, when there was no ISPF interface for SMP.\nNow that there is an ISPF interface, the SMP CLIST is still just as\nuseful as it was in times past.\n\n      Our example for today is the ancient TSO Session Manager, now a\npart of TSO/E.  The Session Manager carries an initial copyright date\nof 1977, which indicates how old it is.  The Session Manager was\ndesigned to overcome a serious problem with TSO.  TSO, in its native\nmode, can only show one screen of output at a time.  After the output\nleaves the screen, you can't get it back again.  In other words, you\ncan't scroll backwards or forwards, and you can't save the data.  That\ncan be very inconvenient sometimes.\n\n      The Session Manager's main function is to preserve your TSO\ncommands beyond one screen's worth of output.  Further, you can scroll\nback many lines to an old command, and re-enter it by typing over part\nof it.  An entire record of your TSO session can be printed out or\ncopied to a dataset.  This is a big improvement.  There is also a\n\"string find\" capability.  These features make the Session Manager far\nmore useful, in most situations, than the normal TSO viewing mode.\n\n      How do you invoke the Session Manager?  All you have to do is to\nchange the program that is executed by your TSO Logon Procedure.  Just\nchange the program name from IKJEFT01 to ADFMDF03, and you'll get the\nSession Manager.  It's that simple.  Actually, there are some finer\npoints (see Figure 1).  Anybody with TSO/E can use the Session\nManager.  Even shops without TSO/E probably can get to it also.\n\n\nHOW DOES THE SESSION MANAGER WORK?\n\n      When you invoke the Session Manager main task, ADFMDF03, two\nparallel subtasks are then attached:  the original TMP (IKJEFT01),\nand the Session Manager subtask.  Terminal I/O that is normally\nhandled by the TMP (TGET's and TPUT's) gets automatically intercepted\nand re-directed into one or more of the Session Manager data areas\nknown as \"streams\".  Meanwhile, the Session Manager has physically\ndivided your terminal display into separate areas known as \"windows\".\nData from the various \"streams\" is selectively (and intelligently)\nmapped to the various \"windows\" for the user to view.  See Figure\n2 for an approximation of a default Session Manager screen.\n\n      The Session Manager has input data streams and output data\nstreams, which are mapped to various windows on your terminal display.\nUsually (in the default screen setup), the input stream corresponding\nto TSO input, is mapped to a window at the bottom of your display\ntube.  TSO commands typed into this area are sent to the input stream\nknown as the TSOIN stream, from where they are directed to the TSO\nterminal monitor subtask and executed.\n\n      At the top of the default display, there is a large window which\nreceives output from the TSO commands.  This \"Main Window\" displays\ndata from the TSOOUT stream, which has received all the TPUT output\nthat the Session Manager intercepted from TSO.  Since the TSOOUT\nstream is a large data area (whose size is controllable by the\ninstallation and the user), many lines of output can be stored and\nviewed.  In addition, all the TSO input from the TSOIN stream gets\ncopied to the TSOOUT stream and is displayable there.  The TSOOUT\nstream therefore becomes an effective log of everything done by the\nTSO session.\n\n      Of course, there are limits to the amounts of data which can be\nstored in a Session Manager stream.  When a stream becomes full, it\nwraps around to the beginning.  This is true for all of the various\nkinds of streams that have been initialized for your session.  Some\nof the other streams are:  SMIN (which holds Session Manager input\ncommands), SMOUT (which contains the results from Session Manager\ncommands), and MESSAGE (which contains the message outputs).  The\nmessage outputs are usually also copied into the TSOOUT stream.\n\n\nNAVIGATING THE TSOOUT STREAM.\n\n      The TSOOUT stream is effectively a session log for your session.\nAs such, you'll often want to look at, or type over, various parts of\nthe TSOOUT stream data.  In the default Session Manager screen layout,\ndata from the TSOOUT stream is displayed in the large window, called\nthe \"Main Window\", that is located at the top of your video screen\ndisplay.  If you look at Figure 2, you'll notice that in the lower\nright corner there's a display that says, \"MAIN ==> UNLOCKED\".  When\nthe Main Window is in \"unlocked mode\", every time you press enter,\nyou'll go down half a screen.  If you press PF12, you'll go to the\nbottom of the TSOOUT data and stay in unlocked mode.\n\n      Any other forcible positioning in the TSOOUT data will put the\nMain Window into \"locked mode\".  In locked mode, pressing ENTER will\nnot reposition the Main Window.  PF7, PF8, PF9, PF10, and PF11 will\nforcibly reposition the Main Window in different ways.  Refer again to\nFigure 2.  PF7 moves the Main Window up by the Scroll Amount.  PF8\nmoves the Main Window down by the Scroll Amount.  PF11 moves the Main\nWindow to the right (it is 255 characters wide), and PF12 moves the\nMain Window to the left.  PF9 positions the Main Window to the top of\nthe TSOOUT data.  PF12 positions the Main Window to the bottom of the\nTSOOUT data, and unlocks the Main Window.\n\n      You have capability of finding a string of data in the TSOOUT\nstream, so that the Main Window will display the next occurrence of\nthat string, upwards.  To do a \"find\", you must enter a case-sensitive\nstring on the command line at the bottom.  Then press PF5.  The search\nwill go from the current part of the TSOOUT stream, up toward the top.\nPF5 functions repeatedly, so that you may press it over and over again\nto find more occurrences farther up in the TSOOUT stream.\n\n\nFURTHER THOUGHTS.\n\n      Much of the power of the Session Manager lies in the fact\nthat TSO data can be saved, preserved, and manipulated.  In TSO\nnative mode, the data goes onto the screen, precious little at a\ntime.  And once it leaves the screen, it's gone forever.  Not so in\nSession Manager mode.  The TSO data may be saved, moved, copied,\nand printed.  The IBM program which performs this function is\ncalled SMCOPY.\n\n      SMCOPY is not hard to use.  It is a TSO command which is entered\nfrom Session Manager mode.  There is a lot of flexibility built into\nSMCOPY, as is shown by Figure 3, which is part of the SMCOPY HELP\nmember.  On your system's SYS1.HELP dataset, you can browse the\nentire SMCOPY HELP member for further information.\n\n      Next comes the question of switching modes \"on the fly\".  For\nmost TSO commands, Session Manager mode improves usability.  However,\nthere are some commands where you'd rather have TSO in native mode.\nFor example, commands which repeatedly clear the screen and then\nsupply a new screen's worth of data after you press ENTER, were\nusually designed for native mode operation.  This type of command does\nnot execute well under the Session Manager.  Under the Session\nManager, you constantly have to press PF12 to go to the bottom and\nview the new data.  Also, under Session Manager, when you just want to\npress ENTER, you have to enter a blank first.  Repeatedly entering a\nblank before pressing ENTER is very tedious if you're constantly doing\nso.  Therefore, it would be nice to switch to native mode while using\ncommands designed for native mode, and then toggle back to your\nexisting Session Manager environment for the other commands.\n\n      There are (at least) two ways in which this can be done.  First,\nIBM provides two different ISRTSO panels in its \"ISR\" panel library.\nThe alternate one, ISRTSOA, may be renamed to ISRTSO so it will be used\nwhenever you are in ISPF Option 6.  This alternate ISRTSO panel has an\noption to switch your session into and out of Session Manager mode.\nThe other way to do it is with a TSO command from CBT Tape File 119\ncalled \"SM\".  SM is an authorized command which toggles your session\nfrom native mode to Session Manager mode and back.  Both ways work\nwith limited success.  You'll have to experiment to see which way is\nbest for your environment.\n\n      Finally, we have to tell you how to go further.  Session Manager\nsessions can be altered.  Defaults can be changed.  If you investigate\nthe Session Manager, there is a lot of power to be taken advantage of.\nTherefore, I must mention the manuals.  In the TSO/E User's Guide,\nthere is a chapter on the Session Manager that used to be in a separate\nthin manual called \"A Guide to Using the TSO Session Manager\".  The\nTSO/E Customization manual contains useful information, and if you can\nget a copy of \"TSO Extensions Version 2 - Session Manager Logic\", a\nlot of understanding can be acquired from that.\n\n      Anyway, good luck.  It's very stimulating and exciting when\nwe're constantly trying to expand our horizons.  It also helps us get\nour work done faster in the long run.\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   How to set up a LOGON PROCEDURE to invoke the\n            TSO Session Manager.\n\n\n\n   A.  A simple LOGON PROC where PGM=IKJEFT01 was merely replaced\n         by PGM=ADFMDF03 to invoke the Session Manager.\n\n\n//LOGSAMG   EXEC PGM=ADFMDF03,DYNAMNBR=150,TIME=NOLIMIT,\n//    PARM='%LOGPRSG'\n//*\n//SYSPROC   DD   DSN=CLIST.LIB.WITH.LOGCLST,DISP=SHR\n//SYSPRINT  DD   TERM=TS,SYSOUT=A\n//SYSTERM   DD   TERM=TS,SYSOUT=A\n//SYSIN     DD   TERM=TS\n\n\n   B.  A more complicated LOGON PROC which explicitly turns on\n         Session Manager mode, and which invokes a different set\n         of Session Manager defaults determined by the ADFMDFL1\n         load module.  On your system, see SYS1.SAMPLIB(ADFDFLTX)\n         which contains the source code from which ADFMDFL1 was\n         modeled.\n\n\n//LOGTECH  EXEC  PGM=ADFMDF03,TIME=1440,DYNAMNBR=100,\n//         PARM='SM(IKJEFT01,Y,ADFMDFL1),%ISPFPROF'\n//     DD statements\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.   An approximation of the default TSO Session Manager\n            display.  The wide area at the top is the Main Window,\n            which displays the TSOOUT data stream.  Commands are\n            entered next to the arrow at the bottom left.  The\n            last 2 lines of latest TSOOUT output are displayed\n            immediately above where the commands are entered.\n            Scroll amount and \"LOCKED\" or \"UNLOCKED\" status of\n            the Main Window are at the bottom right.  A new TSO\n            command, \"lista\", has been entered in the command\n            area, but the ENTER key has not yet been pressed.\n\n\n\n  ----------------------------------------------------------------\n |READY                                                           |\n |listc lev(sys9.csc)                                             |\n |IDC3012I ENTRY SYS9.CSC. NOT FOUND+                             |\n |IDC1566I **SYS9.CSC NOT LISTED                                  |\n |IDC0014I LASTCC=4                                               |\n |READY                                                           |\n |                                                                |\n |                                                                |\n |                                                                |\n |                                                                |\n |                                                                |\n |                                                                |\n |                                                                |\n |                                                                |\n |---+---1---+---2---+---3---+---4---+---5---+---6---+---7---+---8|\n |IDC0014I LASTCC=4                             SCROLL ===> HALF  |\n |READY                                         MAIN ==> UNLOCKED |\n |===> lista status hist sysnames                                 |\n |                                |                               |\n  ----------------------------------------------------------------\n\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 3.  TSO HELP member for the SMCOPY command.  Although\n           abridged, these instructions show you a lot of SMCOPY's\n           power.  See member SMCOPY on your system's SYS1.HELP\n           dataset for all the details.\n\n\n)F FUNCTION -\n  THIS COMMAND COPIES ALL OR PART OF A STREAM OR DATA SET TO ANOTHER\n  STREAM OR DATA SET. THE RECEIVING DATA SET MAY BE A SYSOUT DATA SET.\n)X SYNTAX  -\n         SMCOPY  FROMDATASET('DSNAME')\n                       OR\n                 FROMSTREAM('STREAM-NAME')\n                 TODATASET('DSNAME')\n                       OR\n                 TOSTREAM('STREAM-NAME')\n                       OR\n                 PRINT('SYSOUT-CLASS')\n                 ASIS/CAPS/NOTRANS\n                 FORMAT/NOFORMAT/PREFORMAT\n                 LINE('START-LINE' : 'STOP-LINE')\n  REQUIRED - NONE\n  DEFAULT  - FROMSTREAM(TSOOUT) PRINT(A) CAPS NOFORMAT\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9501JA": {"ttr": 13067, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x942\\x1f\\x01\\x00)\\x9f\\x11G\\x01\\x04\\x01\\x04\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1994-11-17T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 260, "newlines": 260, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          January 1995\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\nSam Golob is a Senior Systems Programmer working\nin New York City.\n\n\nON FINDING PROGRAMS - BLDL and LLA.\n\n      One of the known inefficiencies in MVS processing has always\nbeen the disk file lookup.  Even more clumsy disk-wise, is the\nprocess of finding a member of a partitioned dataset on disk.  Add\nto that, a PDS directory search of a library with several thousand\nmembers.  Finally, concatenate a good number of these libraries, and\ntry to find a random member from the concatenation.  The result is an\nextremely inefficient process, to say the least.\n\n      Yet, this process is not only an everyday occurrence on MVS\nsystems, it is repeated thousands upon thousands of times during a\nday's work.  Without extra assistance, this very same action would\noccur every single time the system fetches a program from a linklist\nlibrary on disk.  That is because the system link list is usually a\nbig concatenation of many sizable partitioned datasets.  The first\nmember of the concatenation, by definition SYS1.LINKLIB, normally\ncontains several thousand programs as shipped by IBM.\n\n      At the old MVS/370 level, IBM itself provided very little\nassistance in the quickening of program searches.  Substantial help\nfrom IBM, which was its first version of LLA (then called Linklist\nLookaside), only started with MVS/XA, as we shall describe.  Nowadays\non MVS/ESA systems, the component called the Contents Supervisor,\nrunning LLA (Library Lookaside), improves this situation very much.\nProgram searches have become far more efficient than previously, if\nLLA is running.  But even on an MVS/ESA system, if you issue the\nsystem command \"P LLA\" or \"STOP LLA\", you're back at square one, as\nwe mentioned above.\n\n      Some of this month's talk will be about LLA.  However, before\ntalking about LLA, I'd like to look at this general problem in a\nhistorical context.  I definitely know that even now, there are shops\nstill running MVS/370 and MVS/XA in daily production.  And even for\nMVS/370 shops, there is good help available to speed up program\nsearches, as we shall see.  I don't think it's fair not to show these\n\"older shops\" what they can do too.\n\n\nA SHORT HISTORY OF THE \"PROGRAM FETCH\" PROBLEM.\n\n      On the old MVS/370 systems, before the 31-bit addressing days,\nthe only help in this area was a fixed list of link-listed programs in\nSYS1.PARMLIB (member IEABLDxx) called the \"BLDL List\".  The BLDL list\ncaused an in-storage table to be built at IPL time, with exact disk\nlocations of the specific listed programs, so that a direct disk\nlookup could fetch these programs immediately.  Thus, our long process\nof PDS directory searching in the link list libraries would be avoided\nfor those programs.\n\n      Problems with the BLDL List were:  It would only perform its\n\"efficiencies\" for a fixed list of programs.  That list was\nunalterable until the next IPL; you couldn't add other programs to it.\nYou also couldn't use a new version of any program on the BLDL List,\nunless you would STEPLIB to the library containing the program.  The\nonly other alternative would be to ZAP the program in its place, which\nisn't always practical or possible.  If a link-listed library\ncontaining these programs accidentally got compressed or moved, the\nsystem couldn't find the programs whose location had moved.  There was\nno recourse or recovery except to IPL.  If those lost programs were\nimportant enough, the system would slowly die.  I know.  I've caused\nit to happen once (many years ago), and one lesson like that is a\nlesson for a lifetime.\n\n      For MVS/370, and even for MVS/XA, the users created a better\nsolution called \"Dynamic BLDL\".  Dynamic BLDL worked by hooking into\nSVC 18 (IGC018) which is the SVC that does program location lookups.\nInstead of using the system's fixed BLDL table, Dynamic BLDL would\nbuild a dynamically maintained in-storage table of link list programs\nthat were most recently used, with their exact disk locations.  The\nfirst time a program was fetched, Dynamic BLDL would add its location\ninformation to the dynamic table.  Subsequent fetches would use the\ntable instead of doing a long directory search.  Since the table was\ndynamically created and was refreshable, you didn't have to IPL when a\nprogram's disk location moved.  You just had to recycle Dynamic BLDL,\nand a new table-build would then be started.\n\n      The most \"modern\" version of Dynamic BLDL was created by Dave\nCole, with XA extensions by John Williams and Jeff Broido.  This\nversion of Dynamic BLDL can be found on the CBT MVS Tape, File 407.\nThe CBT Tape may be ordered through NaSPA.\n\n      If you're still running MVS/370 or even MVS/XA, Dynamic BLDL\nwill definitely be useful to you.  One of the advantages of Dynamic\nBLDL, which has not been addressed by IBM in its own later\ndevelopments, is in the area of reporting.  Dynamic BLDL will report\non every program in the link list that was used most recently by the\nsystem.  The report shows the number of times the program was fetched,\nwhat library in the link list the program came from, and how recently\nthe program was used last.  It is really three reports in one, with\nthe program names sorted three different ways.\n\n      Dynamic BLDL is useful even nowadays, under the following\nconditions:  If you are still running MVS/370, Dynamic BLDL will very\nnoticeably increase program fetch efficiency.  Remember to remove all\nprogram names from the BLDL list (IEABLDxx) in SYS1.PARMLIB, and IPL\nbefore starting Dynamic BLDL for the first time.  If you are running\nMVS/XA, you may find Dynamic BLDL useful for its report.  LLA will\ninterfere with Dynamic BLDL on MVS/XA, so you must stop LLA in order\nfor Dynamic BLDL to be effective.  After Dynamic BLDL has run for a\nwhile, run Dynamic BLDL's report, and then turn LLA back on.  You may\nwant to do this during different times of the day, or for one 24-hour\nperiod.  The result will be a thorough survey of which programs the\nsystem has used most frequently (including \"called\" programs).\n\n\nWHAT'S DOING ON MORE \"MODERN\" SYSTEMS?\n\n      Nowadays, first on MVS/XA and then further on MVS/ESA, IBM has\ncreated a far better method of fetching programs from disk.  There\nactually is a system component, called the Contents Supervisor, that\nhandles this task.  There is a separate address space in which the\nContents Supervisor does much of its work, and that address space is\ncalled \"LLA\".\n\n      LLA means different things for different system levels.  In\nMVS/XA, LLA stood for \"Linklist Lookaside\".  On MVS/ESA, its function\nhas been very widely extended, so the name now stands for \"Library\nLookaside\".  The idea of LLA is that a big table of program directory\nentries is put into a separate address space, and when a program is\nneeded from disk, this table is efficiently consulted to find the\nexact location of that program on disk.  Then the program \"fetch\"\nservice goes to that location, gets the program, and loads it into\nstorage.  All PDS directory searching is avoided.  This service has\nbeen extended to ALL programs residing on the link list, and not to\njust a subset of them.  In MVS/ESA, the service can also include load\nlibraries other than those on the system link list.\n\n      LLA works well, compared to previous systems.  I once benchmarked\nLLA on an MVS/XA system against Dynamic BLDL on XA, and it worked\nsomewhat faster than Dynamic BLDL for a sample set of program lookups.\nIn any case, the rest of this discussion will concern the practical\ntreatment of programs residing in libraries that are under LLA control.\n\n\nSUBSTITUTING PROGRAMS UNDER LLA.\n\n      When you change a program under LLA control, you have to know\nwhat is happening, to accurately predict the results.  LLA tells you\nwhere the program resides on disk.  If you load a new copy into the\nPDS on disk, the new copy will go to a different place on the disk (a\ndifferent TTR location into the dataset).  LLA knows about the\noriginal disk location only, so it will obviously not find the changed\nmember.  LLA will continue to use the old version of that program.\n\n      However, suppose you ZAP (or change some of the contents of)\nthe program at its existing disk location.  The next time the system\n\"fetches\" the program from that location, you'll obviously get the\nchanged version, because the starting disk location of the program\nhasn't been altered.  If the old version of the program has been\nloaded into an address space's Job Pack Area, the old version is in\nstorage, and it might be used a while longer.  But the next time a\nfetch is done from disk, the zapped version will be executed.\n\n      Now all this discussion has only considered changes to the\nprograms on disk themselves.  We have not yet talked about how to\nalter the LLA tables which reference these disk locations.  How can\nthe LLA tables themselves be changed?\n\n      The brute force method is to issue the operator command:\n\"F LLA,REFRESH\", which completely re-initializes all LLA tables for\nall programs in all disk libraries that are under LLA control.  This\nmay take from 20 seconds to a minute on most systems.  One might think\nit's a good thing to do this whenever some program on the link list is\nchanged.  In fact, \"refreshing LLA\" was a normal practice on MVS/XA.\nHowever on MVS/ESA, if you are using VLF (Virtual Lookaside Facility)\nto \"stage\" CLISTs and other structures in expanded storage, all of\nthese CLISTs are de-staged when LLA is REFRESHed by operator command.\nConsiderable system efficiency is lost for a long while.  Therefore,\nit would seem advisable to more selectively refresh individual members\nor libraries on LLA, rather than to redo the whole thing every time.\n\n      As far as refreshing individual libraries is concerned, what you\ndo is to create a SYS1.PARMLIB member called CSVLLAxx, specifying the\nFREEZE and UNFREEZE of whatever libraries you want to control or\nde-control.  Then you issue a system command:  \"F LLA,UPDATE=xx\" to\nactivate the PARMLIB member.  All this is described in the MVS/ESA\nInitialization and Tuning Reference manual, and I will not talk about\nit any more here, because you can look it up.  The rest of our\ndiscussion will concern the substitution of a new version of one\nindividual program into the LLA tables.  IBM's current official\nmechanism for this is called the LLACOPY service.  LLACOPY is invoked\nvia an assembler macro.\n\n\nTHE LLACOPY SERVICE.\n\n      The LLACOPY macro (in SYS1.MACLIB) is intended to substitute\nnew versions of a list of programs into the LLA tables.  The list is\nspecified in a similar manner to the way a list of programs is\npresented to the BLDL macro.  See Figure 1 for the format of the\nLLACOPY macro.  Once the LLACOPY macro is coded into a program, this\nis how it works:\n\n      First, the macro checks for the system level.  If the system\nlevel is less than MVS/ESA 3.1, the program just issues a straight\nBLDL, and nothing is refreshed in LLA.  This could present a problem,\nbecause the macro does not report such a condition to the program\ncalling it.  Nevertheless, if the system level is high enough, the\nmacro formats its parameters, and then issues a PC call to the\nCSVLLCPY routine, which performs the LLA table substitution that\nis required.\n\n      You may want to see a coding example.  A practical example can\nbe found on the CBT MVS Tape File 166 from my friend Vinh Vu.  The\nmember name on his file is called $LLACOPY, and his program's name is\ncalled LLACOPY.  Vinh's program runs in batch, uses a PARM, and\nrefreshes one program in the LLA tables from a disk library.  The\ncoding is relatively simple and easy to follow.  I'd suggest that you\nget a CBT Tape and look at the code yourself.  I've illustrated how to\nuse Vinh's program in the JCL in Figure 2, and that figure is quite\ndescriptive of what happens.\n\n      It's time to say, \"so long for now\".  Efficiency in program\nlookups has long been a sore point in MVS processing, so I felt that\na discussion of what you can do, whatever your system level, might be\nin place.  I hope it helps.  See you next month.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   Format of the LLACOPY macro.  The LLACOPY macro may be\n            found in SYS1.MACLIB on an MVS/ESA system.\n\n\n\n&XLABEL  LLACOPY &DCB=,&BLDLLIST=,&RETCODE=,&RSNCODE=,&MF=\n\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.   The following is JCL to run Vinh Vu's LLACOPY program.\n            The JCL is quite descriptive of what the program is\n            supposed to do.\n\n\n//$VNV3  JOB  (acctg-params),VINH,MSGCLASS=Q,CLASS=B,NOTIFY=&SYSUID\n//*\n//STEP0    EXEC PGM=LLACOPY,PARM='ASREXIT'    <=== PARM=\"module name\"\n//STEPLIB  DD DSN=$VNV.LOAD,DISP=SHR          <=== Your APF loadlib\n//LLAPDS   DD DSN=SYS1.LINKLIB,DISP=SHR,UNIT=SYSDA,VOL=SER=SYSPAK\n//SYSUDUMP DD SYSOUT=*\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9502FE": {"ttr": 13316, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x945o\\x01\\x00)\\x9f\\x11G\\x01D\\x01D\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1994-12-22T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 324, "newlines": 324, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          February 1995\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\nSam Golob is a Senior Systems Programmer working\nin New York City.\n\n\nON DATASET RECOVERY  -  INTRODUCTION\n\n      We systems programmers are sometimes confronted with a situation\nwhere a previously good dataset has gotten broken.  It becomes our job\nto create some sort of recovery.  Either the objective is to restore\nfrom a backup copy, fix the dataset, or short of that, we'd like to\nrecover as much useful data as possible.\n\n      Of course, every situation is different, but the cases do fall\ninto certain known categories much of the time.  This month, our\nconcentration will be on introducing the tools needed to fix non-VSAM\ndatasets.  As we shall eventually see, there are enough of those types\nof problems to keep us quite busy studying.\n\n      Next time, we'll talk specifically about broken PDS'es\n(partitioned datasets) and broken sequential datasets.  And we'll try\nto develop an organized approach to fixing them.  Today, we'll\nintroduce the basis for that discussion.\n\n\nGETTING STARTED WITH BROKEN DATASETS\n\n      When a dataset has something wrong with it, where do you start?\nAlthough I have my own experience, I often ask for a second opinion, and\nI asked my friend Rick Fochtman what he thought on this subject.  He\ntold me three questions he always asks.  They are:  \"What does it look\nlike?\"  \"How bad is it?\"  \"What can we do?\"  There is a lot of depth to\nRick's approach, which seems more simple than it actually is.  Let's\nlook at these three questions in the context of a real problem.\n\n      \"What does it look like?\"  The first aspect of diagnosing a\nbroken dataset is to form a picture in your mind of the \"shape\" of the\ndataset and the place where it seems to be broken.  For example, if a\ndisk sequential dataset has an I/O error somewhere in the middle, you\ncan picture a long row of data blocks containing records.  Each data\nblock has its own TTR (relative location from the beginning of the\ndataset by Track and Record Count).  Then you can superimpose some\ndamaged TTR locations into that picture.  This will give you a mental\nimage of the problem situation to start with.  There are \"good\" TTR\nlocations before the damaged place, and there are good records\nafterwards.  In this simple situation, we have answered the first\nquestion by creating an initial mental picture.  In a real problem, we\nwould probably have to continually refine this picture as new evidence\naccumulates.\n\n      \"How bad is it?\"  Let's go back to our simple example.  We can\nask:  Is there only one I/O error, or are there several?  Does the\ndataset have a proper EOF marker?  Do we have a backup from before?\nHow current is the backup--will several days' work be lost if we\nrestore from the backup?  Is the disk location of the error in a place\nwhere there is old data, or is the error in a place containing new data\nfrom after the backup was taken?  All these questions and more, have to\nbe asked before we go the the third step, which is deciding what we can\ndo toward a remedy.\n\n      \"What can we do?\"  Here, we have to make some decisions, use\nsome ingenuity, and marshal whatever tools are needed.  The safest\nalternative is usually to try and restore the dataset from a backup\ncopy.  If that option is not open, either because no backup exists, or\nthe data has changed too much since the backup was taken, then we\nmight try to create another disk copy of the bad dataset which\ncontains as much \"good data\" as we can recover.  Finally, if this is\npossible, we have to find a way of getting the good data copied into\nthe new dataset, in such a way as to allow the data to be usable.  For\nall that, we need one or more tools.  Sometimes, especially when there\nis corrupted data, there is a DCB blocksize problem.  Such \"details\"\nmust also be handled.\n\n (Editors:  Please keep the quotation marks in the above section,\n  as they have technical connotations.  Thanks. )\n\n\nTOOLS TO USE\n\n      I am an advocate of the \"whatever works\" approach.  When dealing\nwith bad non-VSAM datasets, we will need a means of changing VTOC\nentries, especially FORMAT 1 entries.  We will need a means of dumping\nor looking at bad data and good data.  Finally, we will have to be\nable to copy good records from a damaged dataset to the \"recovery\"\ndataset.  When dealing with partitioned datasets, we will need a means\nof restoring directory entries for \"deleted\" members.  This is even\nmore necessary when a PDS directory has been ruined, or it has been\noverlaid by sequential data.  In that case, all of the old directory\nentries may have to be reconstructed.\n\n      IBM has given us many of these tools.  However, some of my\nfavorite ones are not from IBM.  That is because these non-IBM tools\nare often easier to use, leave less room for user error, and you can\nsee what you're doing better.  I will not write here about any tools\nthat your shop has to buy.  The non-IBM tools mentioned here are all\nobtainable from the CBT MVS Utilities tape that can be ordered from\nNaSPA.  The CBT Tape may be freely copied, but it is frequently\nupdated, so it pays to get a new one every so often.\n\n      What are some IBM tools available?  There is one that we'll\nalways have to use.  That one is ICKDSF, which we'll need to convert\nindexed VTOCs to OSVTOC format, so we can zap the VTOCs effectively.\nAfter our manipulations to the VTOC in OSVTOC format, ICKDSF is used\nagain to convert the volume back to using the VTOC index.  A bit more\ncleverness may be required if the volume is SMS managed and can't be\neasily un-indexed.  See Figure 2 for JCL to un-index and re-index a\ndisk volume.\n\n      For looking at VTOCs, you can use IEHLIST with LISTVTOC DUMP.\nThis will produce a CCHHR dump of all VTOC records.  Then, to change\nthem, you can use AMASPZAP (IBM's superzap) with its CCHHR control\ncards to do the VER's and the REP's.  The dataset name will be\n\"FORMAT4.DSCB\", pointing to the unit and the volume serial.  As\nawkward as this is, this technique with IBM utilities is very powerful\nand far reaching.  A variation of it can even be used to make small\nadjustments to PDS directory entries, using different control cards\nfor IEHLIST.  However, user-friendliness is non-existent with this\nmethod.  You have to thoroughly know what you are doing.  To find out\nmore about these IBM tools, look in the \"Service Aids\" manual and the\n\"DFP Utilities\" manual for almost any level of the MVS operating\nsystem.\n\n      The \"IBM approach\" cannot be used without further knowledge of\nthe layout of FORMAT 1 VTOC entries, and possibly, the knowledge of PDS\ndirectory entries.  I am a strong advocate of using system macros from\nSYS1.MODGEN (or AMODGEN) and SYS1.MACLIB, along with the \"Data Areas\"\nmanuals.  The system macro IECSDSL1 from SYS1.AMODGEN will show the\nlayout of all VTOC formats.  See Figure 1 for how to use this macro.\nThe IBM macro IHAPDS, also in SYS1.AMODGEN, will help you to recognize\nPDS directory entry fields.  The layouts of PDS directory entries have\nbeen discussed in previous columns of mine (September thru November\n1991).  All of my previous columns are found on File 120 of the CBT\nMVS Tape, so you don't need back copies of this magazine.\n\n      Non-IBM tools from the CBT MVS Tape are:  (fullscreen) ZAP and\nREVIEW TSO commands from File 134, the CDSCB (change the DSCB) TSO\ncommand from File 300, and the \"PDS\" TSO command Version 8.4 from File\n182.  We'll elaborate on these four TSO commands shortly.  The IEHMAP\nbatch program on File 083 of the CBT Tape will produce a track map of\nan entire volume.  IEHMAP conveniently supplies CCHHR values for the\nbeginning and end of all dataset extents on a disk pack, which will\ngreatly aid us in the VTOC zapping we'll have to do.  These five\nnon-IBM tools should cover us for the rest of this month's talk.\n\n (Editors:  Please respect the selection of caps in the above\n  paragraph.  Thanks. )\n\n      The ZAP command, with keywords 'FORMAT4.DSCB' and VOL(volser) will\nallow you to look at and change VTOC entries on the screen.  ZAP should\nbe carefully restricted to systems personnel only, but we're fixing\nbroken datasets here, and we'll need it.  REVIEW is a full screen browse\nprogram with enormous power.  Using REVIEW's NEWTOP subcommand, you can\nposition the logical \"top of data\" just previous to an I/O error, or\njust subsequent to one.  The newest versions of REVIEW (after version\n379 of the CBT Tape) have CUT and ADD subcommands to copy records from\ndata being looked at, to another dataset.  This allows for recovery of\nsequential data records before and after an I/O error.\n\n      The CDSCB command, which has to run authorized, allows the user\nto change DCB attributes of a dataset without having to know the exact\nlayout of the FORMAT 1 VTOC entry.  See Figure 3 for more information.\nFinally, the PDS command (Version 8.4) is a multi-purpose dataset\nutility that can be used to easily dump the FORMAT 1 DSCB layout of a\ndataset (using its \"USAGE ALL\" subcommand).  \"PDS\" (with its RESTORE\nsubcommand) can be used to \"undelete\" pds members, while with its\nDIRENTRY and ATTRIB subcommands, \"PDS\" can be used to view and change\ndirectory entry fields.  I do not recommend using PDS's FIXPDS\nsubcommand to change the DCB attributes of a broken dataset.  This is\nbecause the FIXPDS DCB manipulations open the dataset for output, and\nthey could ruin the setting of DS1LSTAR (the dataset high-water mark\nin the FORMAT 1 DSCB).  Rather use CDSCB, which only opens and changes\nthe FORMAT 1 VTOC entry itself.  With CDSCB, the data in the dataset\nis not altered at all; only the VTOC entry for the dataset is altered.\n\n\nEXAMPLES.\n\n      We've used most of our space for this month, and I'll have to\nbe brief here.  We'll continue and elaborate on this phase next time.\n\n      Let's see what to do about the sequential dataset with one I/O\nerror in the middle, assuming we can't use a tape backup of the volume.\nOne way to recover is to REVIEW the dataset from the top, and find the\nlocation of the I/O error by issuing a FIND subcommand in REVIEW for a\nnon-existent string.  This will force REVIEW to search through all the\ndata until it hits the I/O error.  When you hit the I/O error, back up\n20 records or so, and go DOWN one record at a time.  The exact record\ncount until the error position will be apparent.  Mark this count down.\nThen allocate a duplicate copy of the dataset to ddname SYSUT2.  Go to\nthe top of the data, and CUT the required number of records.  This will\ncopy those records to the beginning of the SYSUT2 dataset.\n\n      Then NEWTOP to a CCHHR considerably past the I/O error where you\nalready have good data again.  Slowly NEWTOP back, one block at a time,\nuntil you hit bad data.  NEWTOP to the first block of good data, and\nADD a large number of records, so that you copy the rest of the records,\nwith DISP=MOD effectively, to the end of the SYSUT2 dataset.  That's\nit folks.  You've recovered most, or all, of the good records.\n\n      Another approach would be to allocate a new dataset with the same\nDCB attributes as the old dataset.  Then, with the VTOC un-indexed,\nZAP the two FORMAT 1 DSCB entries so that the CCHHR extents of the\noriginal dataset only go up to the I/O error, and the other dataset\ncontinues from after the end of the I/O error to the end of the original\ndataset's extents.  Thus we have two datasets, which together, contain\nrecoverable data.\n\n      You get the general idea.  Next time, we'll talk about specific\ncases more.  This kind of work helps you \"feel like you are earning\nyour pay as a systems programmer\".  Good luck and good zapping (only\nif necessary).  See you next month.\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   How to obtain the layout of all VTOC record formats.  Each\n            entry in a VTOC is called a DSCB (Dataset Control Block).\n            The Format 1 DSCB provides most (or all) of the information\n            connected with individual datasets.  If the dataset has more\n            than 3 extents, you will also need a Format 3 DSCB entry.\n\n\n*       * * *   V T O C   D E S C R I P T I O N   * * *\n*  ASSEMBLING THIS GIVES VTOC FORMATS FOR ALL TYPES OF\n*    VTOC ENTRIES.   (SYS1.AMODGEN)\n         IECSDSL1  1      , FORMAT 1 DSCB\n         IECSDSL1  2      , FORMAT 2 DSCB\n         IECSDSL1  3      , FORMAT 3 DSCB\n         IECSDSL1  4      , FORMAT 4 DSCB\n         IECSDSL1  5      , FORMAT 5 DSCB\n         IECSDSL1  6      , FORMAT 6 DSCB\n         END              ,\n\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.   Jobs to un-index the VTOC and re-index the VTOC of a pack.\n            It is assumed that the pack was originally indexed, and we\n            do not want to use the index dataset while zapping VTOC\n            entries.  When the VTOC is un-indexed, only the VTOC itself\n            has meaningful information about the datasets on a pack.\n            The index is then not used.  Re-indexing the pack will have\n            the effect of reorganizing the VTOC index and recalculating\n            the pack's free space.  To recalculate the free space of\n            an OSVTOC volume, you have to turn on the \"DIRF\" bit of the\n            FORMAT 4 DSCB, allocate a dummy dataset on the volume, and\n            later delete the dummy dataset to clean up.\n\n\n\n//*              * * *     O S V T O C     * * *\n//TSTBSP2N JOB   (rest of job card)\n//*******************************************************************//\n//*  NOTE..... THIS WILL ASK OPERS FOR A REPLY - YOU NEED A \"U\" IF OK.\n//*******************************************************************//\n//*      CONVERT IXVTOC TO OSVTOC:\n//****************************************//\n//S1    EXEC PGM=ICKDSF,TIME=1439\n//SYSPRINT  DD SYSOUT=*\n//VPDKZ01 DD VOL=SER=PDKZ01,UNIT=SYSDA,DISP=SHR, <=== CHANGE ALL\n//   DSN=SYS1.VTOCIX.VPDKZ01        <=== OCCURRENCES OF VOLSER NAME.\n   BUILDIX DDNAME(VPDKZ01) OSVTOC\n/*\n//\n\n//*              * * *     I X V T O C     * * *\n//*******************************************************************//\n//*    NOTE..... THIS WILL ASK OPERS FOR A REPLY.  \"U\" IF OK. ****\n//*******************************************************************//\n//*        REBUILD INDEXED VTOC:\n//****************************************//\n//START EXEC PGM=ICKDSF,TIME=1439\n//SYSPRINT  DD SYSOUT=*\n//VPDKZ01 DD VOL=SER=PDKZ01,UNIT=SYSDA,DISP=SHR, <=== CHANGE ALL\n//   DSN=SYS1.VTOCIX.VPDKZ01  <=== OCCURRENCES OF VOLSER NAME TO YOURS\n   BUILDIX DDNAME(VPDKZ01) IXVTOC\n/*\n//\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 3.   This is the Help member for the CDSCB TSO command,\n            that can change any field in a dataset's Format 1\n            DSCB.  CDSCB must run authorized, because any program\n            which directly changes VTOC fields must have APF\n            authorization under the MVS operating system.\n\n\n)F FUNCTION -\n  THE CDSCB (CHANGE DSCB) COMMAND MODIFIES A DATA SET'S\n  FORMAT-1 DSCB IN A VTOC.\n\n  SINCE THE FORMAT-1 DSCB CONTAINS INFORMATION CRUCIAL TO\n  A DATA SETS' SECURITY AND INTEGRITY, (AND IN FACT TO THE\n  WHOLE SYSTEM'S SECURITY AND INTEGRITY), THIS COMMAND\n  MUST BE RESTRICTED TO SYSTEMS SUPPORT PERSONNEL.\n\n  NOTE: THIS IS AN APF-AUTHORIZED COMMAND, AND THEREFORE\n  WILL NOT RUN PROPERLY UNDER SPF.  YOU MUST EXIT SPF TO\n  'READY' MODE BEFORE USING THIS COMMAND.\n\n)X SYNTAX  -\n         CDSCB  'DSNAME'   EXPDT('YYDDD')  SHR  VOL(VOLUME) UNIT(UNIT)\n                           CREATE('YYDDD') REFDT('YYDDD')\n                           DSORG(XX) RECFM(XX) LRECL(XX) BLKSIZE(XX)\n                           ALLOC(TR/CYL/BL)  SPACE(SECONDARY-AMOUNT)\n                           PWR/PWW/NOP/RACF/NORACF\n                           ZAP(OFFSET VERDATA REPDATA)\n  REQUIRED - 'DSNAME'\n  DEFAULTS - NOTHING WILL HAPPEN IF NO CHANGES ARE SPECIFIED.\n  ALIAS    - NONE\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9503MA": {"ttr": 13322, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x006\\x00\\x95\\x03\\x9f\\x01\\x19\\x14O\\x14\\x19\\x00\\xfd\\x00\\xfd\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1995-02-08T00:00:00", "modifydate": "2019-05-24T14:19:36", "lines": 253, "newlines": 253, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           March 1995\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\nSam Golob is a Senior Systems Programmer working\nin New York City.\n\n\nDATASET RECOVERY METHODOLOGY - PART TWO\n\n      Last month, we started looking at a methodology for fixing broken\ndatasets.  My friend Rick Fochtman, who has a lot of experience, has\nthree simple-sounding rules on this subject.  When confronted with a\ndataset problem, Rick asks:  \"What does it look like?\"  \"How bad is it?\"\n\"What can we do?\"  These questions penetrate far deeper than they appear\nto, and we talked last time at some length about them.\n\n      This month, we'll confront another real damage situation, and\nwe'll apply these methods toward fixing the problems.  First, I'd like\nto say a few words about the arsenal of tools we'll need to use.  We\nmentioned last time that there are both IBM and non-IBM utilities\nthat can help.  My practical philosophy is to use whatever works,\nwhatever you have, whatever you can get, or a combination thereof.\nHowever, I feel strongly that you must understand the problem first.\nYou must also understand how your tools work, and what they do.  If\nyou've proceeded in this order, that is, if you've answered the first\ntwo questions about what the problem looks like, and about how bad it\nis, then you're well on the way to properly marshal whatever tools\nyou're likely to need in fixing it.  Today we are going to examine\nanother case to illustrate this method.\n\n      At this point, I'd like to say more about tools, specifically\nIBM ones versus non-IBM ones.  IBM supplies some good tools that we\nall use to some degree.  For zapping disk datasets, VTOC entries\n(FORMAT 1 DSCB's) and the like, there is superzap, whose program name\nis AMASPZAP.  To use AMASPZAP, you can look in IBM's Service Aids\nmanual for almost any level of DFP or MVS.  This manual contains\nan entire section on AMASPZAP.\n\n      Our old familiar ISPF/PDF from IBM can also be a helpful tool in\ncertain ways, mostly to check the work you've done through other\nmeans.  For example, ISPF/PDF 3.2  (dataset allocation, attribute\ndisplay, and catalog/uncataloging), and ISPF 3.4 (dataset listing with\nattributes, etc.) can be used for displaying the DCB attributes of a\ngiven dataset after you've altered them.\n\n      But the few standard IBM tools have disadvantages.  ISPF/PDF can\nbe rather limited in its ability to change the things we need to\nchange.  On the other hand, AMASPZAP, which is IBM's tool for changing\ndisk data, is very general in its application rules, and therefore,\nfor changing things like VTOC fields and pds directory fields,\nAMASPZAP is extremely user unfriendly.  You must know the exact data\nrepresentation, and the exact physical location of the field you want\nto change.\n\n      Non-IBM tools that are more user friendly, would be more\nconvenient to use for much of this work.  Many of these tools can be\nobtained from the CBT MVS Utilities Tape, which you can get from\nwww.cbttape.org, at no cost.  I have mentioned several of these tools\nin last month's column, and we'll show you, as we go along, how they\ncome into play.\n\n      Let's give an example.  Suppose you have somehow copied a load\nmodule with some large data blocks into a load library which has a DCB\nblocksize that is smaller.  And suppose also, that you've managed to\ndelete all other remaining copies of this load module (quite a feat).\nTo rescue the situation, and to be able to view and use that load\nmodule, you'll need to increase the DCB blocksize of the load library\nwithout reallocating it.  In other words, you'll have to somehow ZAP\n(change) the \"blocksize\" field in the VTOC entry for the load library,\nso it's at least as big as the largest data block in the load module.\n\n      Let's say for definiteness that the DCB blocksize of your load\nlibrary is 6144.  But the largest block in the load module you've\ncopied in, is 19069.  Let me ask you, is it less error-prone to use\nIBM's IEHLIST LISTVTOC command in batch to get the CCHHR location of\nthe load library's FORMAT 1 DSCB (VTOC entry), and then zap its\nblocksize field in hex with AMASPZAP, or is it safer to use a non-IBM\ncommand like CDSCB (from File 300 on the CBT MVS Tape) and type:\n\"CDSCB load.library BLKSIZE(19069)\" ?  Both methods have accomplished\nthe same purpose of making that load module usable, using the same\nmechanics.  But from the user's point of view, one method is more\nfoolproof than the other.\n\n      The old-time systems programmers (I guess I'm one of them) had\nto put up with zapping VTOCs the hard way.  Now, with the free user\ntools such as fullscreen ZAP (CBT Tape file 134) and CDSCB, the job\nis much easier, quicker, and cleaner.\n\n\nTHE OVERLAID PDS DIRECTORY\n\n      One dataset recovery case is that of the \"blown\" pds directory.\nThis could happen (only try it on a \"junk pds\", or don't try it at\nall) when one tries to copy a sequential dataset into a pds without\nmentioning the member name of the pds.  From an application\nprogrammer's point of view, the whole pds gets ruined.  A pds consists\nof a directory at the beginning, whose DCB attributes are LRECL(256)\nKEYLEN(8).  The directory has entries which point to data locations\nfurther along in the extents of the dataset, where the members reside.\nThe DCB attributes of the data in the members can, of course, vary.\nYou have, for most practical purposes, as much choice in DCB\nattributes of pds members, as you have for sequential datasets\nthemselves.  These \"data\" DCB attributes reside in the VTOC entry\nfor the pds on the disk pack.\n\n      When a sequential dataset is copied to a pds without mentioning\nthe member name, part or all of the pds directory is overlaid by the\ncopy of the sequential dataset, ruining \"normal\" access to the rest of\nthe data, which resides further along in the member locations.  At this\npoint, we've answered the question:  \"What does it look like?\"\n\n      Now we ask:  \"How bad is it?\"  In our case, since we have an\nidea what the data looks like, the question is:  How much of the pds\ndirectory area, and how much of the member area afterward, did the\ncopy of the sequential dataset overlay?  This will determine how much\nof the remaining non-overlaid data, we will later be able to recover.\n\n      Now we can start the question:  \"What can we do?\"  The answer\nwill boil down to two parts:  \"What can we do to determine the extent\nof the damage\", and then, \"what can we do to recover the undamaged\ndata?\"  To answer these questions, we have to start gathering tools.\nInitially, we'll need tools to determine the extent of the damage.  An\nIBM way, would be to use IEHLIST to determine the CCHHR disk locations\nof the beginning of what used to be our pds.  Then we could use the\nCCHHR options of AMASPZAP to print a hex dump of these beginning\nlocations.  The extent of the overlay should then be apparent, if\nyou've printed out enough CCHHRs.\n\n      One non-IBM way to do the same thing, would be to use the REVIEW\nTSO command from CBT Tape file 134.  REVIEW is a full screen TSO\nbrowser of enormous power.  The normal way to browse a dataset with\nREVIEW is to say (from an ISPF command line):  \"TSO REVIEW\ndataset.name\" .  However, REVIEW has some specialized subcommands\nwhich we may need.  In this case, we'll need to know the block size of\nthe data which got copied into the beginning of the pds, in order to\nsee that data.  Therefore the BLKSIZE sub-parameter of REVIEW can be\nused to make the overlaying data visible.  Thus we type:  \"TSO REVIEW\ndataset.name BLKSIZE(32760)\" or some other big-enough number that will\nenable the data to be seen.  We go to the bottom of the data, using\nthe BOTTOM subcommand, and an ending TTR will be displayed.  Copy this\nTTR down.\n\n      The next step is to get past the overlaying data to the old\ndata.  REVIEW has the power to \"fake\" the top of the dataset with its\nNEWTOP subcommand.  Simply step past the EOF mark, which occupes one\nTTR location, and type NEWTOP(ttr) for the following TTR to get to the\nlocation after this.  The TTR is usually a five or six-digit numeric.\nThe first non-overlaid data should now become visible.  My guess is\nthat you'll probably have to play around with this for a while, but\nyou might be pleasantly surprised when the data appears on your\nscreen.\n\n      Using REVIEW in this way has helped us to see the extent of the\ndamage.  We have thus answered the question:  \"How bad is it?\"  ISPF\n3.2 might give you the same information, less precisely.  But the\naccuracy of ISPF 3.2 depends on how the overlaying data was copied.\nIf the \"pds\" was sequentially opened for output, and then closed,\nthen the DCB information in the VTOC entry was updated by the sequential\ncopy.  But if the VTOC was not updated, then the \"easy\" methods will\nnot work.  You'll have to use tools which look at the data itself, such\nas the ones we have just mentioned.\n\n      Now we ask the second sub-question of \"What can we do?\", namely,\n\"How do we fix the damage?\"  There may not be only one type of \"fix\".\nWhat particular action you want to take, must now be decided upon.\nIn our case, the answer will depend on the extent of the damage, the\nimportance of the data, and the availability of a possible backup\ncopy.\n\n      On a production dataset, I would not suggest using our methods\nexcept as a last alternative.  The most reasonable first thought,\nwould be to do a dataset restore from a backup copy.  This is what\nmost people do, in practice.  After that, the remaining problem would\nbe to update the restored copy of the dataset with the data that was\nadded or removed since the time the backup was taken.  Our methods\nare a second-line and third-line defense, to be used in the event that\nno reasonable backup copy is available.  However, we can also use our\ntechniques to alter a similar, but not identical dataset that was\nrestored, so it matches the dataset that was lost.\n\n      In the case of an overlaid pds directory, the first part of the\nsolution might be to format a back-leveled or a blank directory of\nproper size.  Then, new directory entries have to be made, to point\nproperly to the lost members which have not physically been overlaid.\n\n      Again, tools must be chosen.  One tried-and-true method is to\ntake an FDR or DFDSS backup (or equivalent) of some similar pds, and\nrestore just the directory tracks over the location of the lost pds\ndirectory.  Then you have a model pds directory to work with, which\ncan later be added to or altered.  You can \"clear out\" a directory\nto make it appear empty, by zapping eight bytes of hex 'FF' in the\nfirst eight bytes of the directory data (the key).  After that, we\nmust consider how to re-create accurate directory data for the\n\"members\" that are still physically there.  In my opinion, it is\nnot easy to directly \"zap in\" directory members to a blank pds\ndirectory because of the internal structures involved.  You rather\nneed a specialized tool for STOWing member entries into the directory.\n\n      The best public tool I know of, is the \"PDS\" TSO command from\nFile 182 of the CBT Tape.  Normally, \"PDS\" requires a small\ninstallation effort, with an ISPF panel library and an ISPF message\nlibrary.  However, a load module for the PDS command exists on file\n035 of the CBT Tape, and if you invoke \"PDS\" not in ISPF mode (called\nISPMODE), you won't need the panels and you can use it right away.\nJust suffix the word XISPMODE to the initial invoking command.\n\n      You point the PDS command to a dataset when you invoke it\ninitially.  Then, once you have the \"ENTER OPTION\" prompt, you can\nenter subcommands.  The RESTORE subcommand of PDS is the one we'll\nuse now.  To restore all deleted members at once, you pick a prefix\nfor the restored members.  For example, you may pick the prefix \"$$\"\nto place the restored members at the beginning of a directory list.\nThen you enter the subcommand:  \"RESTORE $$ REPEAT NOPROMPT\".  The\nPDS command does the rest.  In TTR order, pds directory entries for\nmembers called $$000001, $$000002, and so forth, will be created.\nThese members may be renamed by more conventional means later.\n\n      Another tool for creating pds members is the PDSGAS batch\nprogram from CBT Tape file 316.  PDSGAS is fine for FB or VB pds\nmembers, but it will not do a good job on restoring load module\ndirectory members.  The FIXPDS program from File 036 of the CBT Tape\nruns under ISPF, and allows you to ISPF browse all physical (deleted\nor not deleted) pds members backwards from the dataset high-water\nmark, giving you the option of STOWing new member names for each one\nafter you browse it.  If you look around the CBT Tape documentation,\nyou will doubtless find other good programs that can do a similar\njob.\n\n      We've probably answered 70 to 100 percent of the question:\n\"What can we do?\", depending on the case.  However, if the overlaid\npds was a load library, there is more work to be done, because load\nmodule attributes are found in pds directory user fields, and they may\nnot be restored adequately from many of the \"member creating\"\nprograms.  The \"PDS\" TSO command comes to the rescue with its \"ATTRIB\"\nsubcommand.  ATTRIB can be used on a pds member or a group of members\nto change most of the load module attributes to the way you want them.\nWe don't have space to discuss the details here.  Look in the PDSHELP\nmember on CBT Tape File 182, under the ATTRIB subcommand, for the\ndetails and possibilities.\n\n      To summarize, our aim this month was not to write an exhaustive\ntreatise on dataset restoration.  Rather, it has been to illustrate a\nmethod of approach that can really be used on a wide variety of\ndataset problems.  The questions:  \"What does it look like?\", \"how bad\nis it?\", and \"what can we do?\" will support us well, when tackling\ndataset problems throughout our careers.  Good luck.  See you next\nmonth.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9504AP": {"ttr": 13572, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x95\\x05/\\x01\\x00)\\x9f\\x11G\\x01<\\x01C\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1995-02-21T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 316, "newlines": 323, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           April 1995\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\nSam Golob is a Senior Systems Programmer working\nin New York City.\n\n\nVTOC TIDBITS - Part I\n\n      Sometimes, even we systems programmers get a bit depressed,\nand we need to do something exciting to get us out of it.  Once, I\nwas assigned a long series of humdrum problems to work on, one after\nanother.  I was starting to forget that I have a set of skills.\nThen one evening, one of my colleagues came into my room all in a\npanic.  She had deleted a dataset on a new MVS res pack, and she had\nno backup.  Could I please help her get the dataset back?\n\n      I sat down for about an hour, and constructed a brand-new Format\n1 VTOC entry for the dataset, completely zapping it out of a Format 0\n(blank VTOC entry) by hand.  And I got it to work perfectly.  That\nwas the boost I needed to climb out of my depression and prove to\nmyself that I was worth my pay.\n\n      This month, I don't have space to tell you how I did that.\nBut I'd like to spend some time talking about fundamentals related\nto this.  We will discuss some of the structure of the DASD table of\ncontents, known as the \"VTOC\" for a disk pack.  There are some\ninteresting fields buried in some of the VTOC records, and one can\nonly gain by knowing about them.\n\n      When a disk pack is initialized by the ICKDSF program, the\nsystem programmer specifies the size (in tracks) and location of the\nVTOC on the disk pack.  Sometimes the VTOC is placed at the beginning\nof the pack; sometimes it is placed in the middle.  If a VTOC index is\nspecified, its placement is also determined at initialization time.\n\n      At this point, I'd just like to mention that if I'm\ninitializing a pack, my personal preference is to place the index\n(if it exists) just behind the actual VTOC, as opposed to just after\nit.  That is because the VTOC index dataset is hard to move.  If\nyou'd later need to enlarge the VTOC, the space just after the end\nof the VTOC should be easily available to expand into, and with the\nindex there, matters become much tougher.\n\n\nVTOC STRUCTURE.\n\n      Getting back to basics, Track 0, Record 3 of an initialized\ndisk pack contains the volume serial name of the pack.  This record\nalso contains a pointer to the CCHHR location of the VTOC as referenced\nfrom the beginning of the pack.  That is how the VTOC, and ultimately\nthe datasets on the pack, can be located by the operating system.\n\n      The VTOC itself is a direct access, fixed-length unblocked\ndataset consisting of the same size records in as many as six, seven\nor eight different formats.  There is a 44-byte key at the beginning\nof each record, and there are 96 bytes of data which follow the key.\nThat makes 140 bytes in all.  The VTOC itself originally contained all\nor most of the information necessary to describe dataset extents on a\ndisk pack.\n\n      A \"VTOC Index\" dataset is an optional and relatively new\ndevelopment.  It is a separate dataset which keeps track of free\nspace on the disk.  If the disk pack is not SMS-managed, the VTOC\nIndex is not absolutely necessary, and if one exists for a non-SMS\npack, we can enable or disable it as we need to.  This month, we\nwill not discuss any details about the VTOC Index itself.\n\n\nVTOC RECORD FORMATS.\n\n      There are six (and now possibly seven) non-zero formats among\nVTOC records, known more technically as DSCB's or \"Data Set Control\nBlocks\".  The formats are named by number.  We refer to a \"Format 1\nDSCB\" or a \"Format 5 DSCB\".  Each one of these formats serves a\nspecialized purpose.  In addition, there are blank VTOC records\nconsisting of 140 bytes of all hex zeros.  These \"empty slots\" in a\nVTOC are called \"Format 0 DSCBs\".  Please see Figure 1 for a summary\nof all the VTOC record formats.\n\n      Six VTOC formats are mapped by a macro in SYS1.MODGEN (or\nSYS1.AMODGEN) called IECSDSL1.  See Figure 2 for an example of how\nto code this macro to display these six VTOC formats.  There is now\na seventh VTOC format (called a Format 7 DSCB) that was created to\ntrack the free space on the new 3390 model 9 disk packs.  The model\n9's have three times the number of cylinders that a 3390 model 3 has.\nAnd they are so large, that normal Format 5 DSCB's cannot describe\ntheir free space.  Therefore, the Format 7 DSCB was created.  The\nFormat 7 DSCB is described by a macro called IGGDADS7, which I was\nunable to find on my MVS/ESA 4.3 system with DFSMS 1.0.  Maybe\nyou'll have better luck looking for it on your system.\n\n\nTOOLS TO USE.\n\n      My philosophy (at least for systems programming), is that it is\nbetter to see than to be blind.  That's what we collect tools for.\nI'll show you some IBM tools first.  To print out a VTOC of a disk\npack, you can use the IBM tool IEHLIST with its LISTVTOC DUMP control\ncard.  The DFP Utilities manual will tell you all the details.\nIEHLIST is a fine tool for this purpose.  After you've used IEHLIST to\ndisplay all the VTOC records, you can then use the IBM superzap\nprogram called AMASPZAP with its CCHHR control cards, if you need to\nchange any VTOC fields.  AMASPZAP is documented in IBM's Service Aids\nmanual.  There are versions of the Service Aids manual that have been\npublished for all releases of MVS.  Any of them can help you.\n\n      However, I myself don't use the IBM tools.  Instead, I use the\nFullscreen ZAP TSO command from the CBT MVS Utilities Tape.  Program\nsource for Fullscreen ZAP is on File 134 of that tape, and a load\nmodule is on File 135.  You can order the CBT MVS TAPE through the\nNaSPA office.  Fullscreen ZAP will accomplish both the function of\nIEHLIST, and the function of AMASPZAP.  Moreover, ZAP operates\ninteractively on the screen, very quickly.  Since Fullscreen ZAP has a\nlot of power, it should of course be restricted to qualified systems\npersonnel only.  But used properly, ZAP shows you a lot about the VTOC\nfields in real time, right on your screen.  See Figures 3 and 4 for\nsample ZAP screen images.\n\n      To use the ZAP command to display the start of the VTOC for\npack AKD001, simply enter (from the ISPF command line):  TSO ZAP\n'FORMAT4.DSCB' VOL(AKD001).  ZAP contains a full system of help\nscreens, which you can use by typing a question mark on its command\nline.  You also have a detailed report of what record you are in,\nwhat volume you're looking at, and a HEX and EBCDIC character display\nof the current record.  ZAP can easily change the record you're\nlooking at.  If you're altering fields in a VTOC, the index must be\ndisabled, and you had better be very, very careful and know exactly\nthe effect of what you're doing.  Nevertheless, ZAP keeps track of\nwhat it changed, and you can print its log out.\n\n\nSOME FACTS ABOUT THE VTOC HEADER RECORD.\n\n      Our discussion of specific VTOC formats will begin with the\n\"Format 4 DSCB\".  The Format 4 is the first record of the VTOC for a\ndisk pack, and it can be correctly referred to as the VTOC Header\nrecord.  There is exactly one Format 4 DSCB for each pack.  The\nFormat 4 DSCB defines and reflects many of the logical and physical\ncharacteristics of the pack, and we will see some very interesting\nthings in it.\n\n      The 44-byte key of the VTOC Header consists of 44-bytes (2C in\nhex) of hex '04'.  The later fields, with specific information, follow\nthe key.  It seems that because of this, the Format 4 DSCB differs from\nall other VTOC formats.  For other formats, +0 displacement into the\nVTOC entry begins at the beginning of the key, or in other words, at\nthe beginning of the record.  For the Format 4 DSCB, displacement +0\nbegins at +2C from the beginning, or at the beginning of the data.\nIn other words, +0 into a Format 4 DSCB starts at the 45th byte from\nthe beginning.  I'm not sure why IBM made that decision, but it seems\nfrom the externals that since there is no real information in the key\nof a Format 4 DSCB, we might as well start looking from where the\nactual information is.  All other VTOC formats have real information\nin the first 44 bytes, and some of them (Formats 2, 3, 5, and 6) use\nabbreviated keys and not full keys.\n\n      I'll show you some interesting things in the Format 4.  The\nFormat 4 describes the entire pack.  At +1E into the Format 4 (which\nis really +4A from the beginning of the record) there is a one byte\nfield which tells how many DSCB's will fit on one track of this pack.\nThe next byte, +1F, tells you how many PDS directory blocks will fit\non one track of this pack.  For a 3380, the numbers are:  53 VTOC\nrecords (hex 35) and 46 directory blocks (hex 2E) per track.  For a\n3390, the numbers are smaller:  50 VTOC entries (hex 32) and 45\ndirectory blocks (hex 2D).  Evidently, the inter-block gaps on a 3390\nare bigger than the ones on a 3380.\n\n       At +10 in the Format 4, if bits X'C0' are turned on, the pack\nis SMS-managed.  If they are turned off, the pack is not SMS-managed.\nThe two bytes at +12 tell you how many logical cylinders there are\non the pack.  For example (see Figure 3), on a 3390 model 3, there\nare X'D0C' or decimal 3340 logical cylinders on the pack.  The\ncorresponding numbers for a 3380K are X'A60', or decimal 2656 logical\ncylinders.\n\n      At +14, there is a two-byte field which tells you how many\ntracks there are in a cylinder.  For both the 3380 and the 3390\ndevices, this number is X'000F', or 15 tracks per cylinder.  At\n+16, the device track length in bytes (hex) is displayed.  For a\n3380, the track length is X'BB60' or 47968 bytes.  For a 3390, the\ntrack length is X'E5A2', or 58786 bytes.\n\n      I don't have space this month to go into some of the VTOC\nindicator flags that are located at +C into the Format 4.  If you\nprint out all the VTOC formats for yourself, using the IECSDSL1\nmacro as in Figure 2, you will acquire a lot more information than\nI can mention now.  Especially with an IEHLIST \"LISTVTOC DUMP\" in\nfront of you, a bit of study will send you on your way to becoming\nan expert in this area.  We'll continue on this topic next time.\nMeanwhile, good luck and good hunting!\n\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.  A Quick Summary of the VTOC formats.\n\n\n       FORMAT 0 DSCB  -  Blank entry\n       FORMAT 1 DSCB  -  Dataset descriptor\n       FORMAT 2 DSCB  -  ISAM dataset information\n       FORMAT 3 DSCB  -  Location of extra extents\n       FORMAT 4 DSCB  -  VTOC Header Record\n       FORMAT 5 DSCB  -  Chained Free Space Descriptors\n                           (if VTOC index is disabled or is not there)\n       FORMAT 6 DSCB  -  Cylinder sharing\n       FORMAT 7 DSCB  -  Free Space Descriptors for 3390 model 9\n                           (or future large-capacity disk packs)\n\n  Every VTOC begins with a Format 4 DSCB.  It is always followed\n  by one Format 5 DSCB.  This Format 5 DSCB will begin a chain of\n  other Format 5's to describe the free space on the volume if\n  there is no VTOC Index, or if the VTOC Index is disabled.\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.  This is how to code the IECSDSL1 macro from SYS1.AMODGEN\n           or SYS1.MODGEN, to display DSECT descriptions of all six\n           (older) VTOC formats.\n\n\n*       * * *   V T O C   D E S C R I P T I O N   * * *\n*  ASSEMBLING THIS GIVES VTOC FORMATS FOR ALL TYPES OF\n*    VTOC ENTRIES.   (SYS1.AMODGEN)\n         IECSDSL1  1      , FORMAT 1 DSCB\n         IECSDSL1  2      , FORMAT 2 DSCB\n         IECSDSL1  3      , FORMAT 3 DSCB\n         IECSDSL1  4      , FORMAT 4 DSCB\n         IECSDSL1  5      , FORMAT 5 DSCB\n         IECSDSL1  6      , FORMAT 6 DSCB\n         END              ,\n\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n\nFigure 3.   This is a Format 4 DSCB as pictured by the Fullscreen ZAP\n            program from the CBT MVS Utilities Tape, File 134.  That\n            program is a TSO command.  To obtain the result pictured\n            here, you enter TSO ZAP 'FORMAT4.DSCB' VOL(AKD001) .\n            This gets you to the VTOC Header for the pack AKD001.\n            Fullscreen ZAP has a complete HELP sequence, which you\n            can enter by typing a question mark on the command line.\n            From the help sequence, if you type a U, you get back to\n            where you were.  This volume is a non-SMS 3390 model 3.\n\n\n                                 Z  A  P\n_\nENTER VALID COMMAND ABOVE OR ? FOR HELP         VERSION=2.3G 17AUG92\n\n\n00000  >0404 0404  0404 0404   0404 0404  0404 0404   *................*\n00010   0404 0404  0404 0404   0404 0404  0404 0404   *................*\n00020   0404 0404  0404 0404   0404 0404  F400 0200   *............4...*\n00030   0E32 07A1  0D0B 0000   000F 8B01  0000 0D0C   *...~............*\n00040   000F E5A2  0000 0020   0000 322D  0000 0000   *..Vs............*\n00050   0000 0000  0000 0000   0000 0000  0000 0000   *................*\n00060   0000 0000  0000 0000   0001 0000  0000 0100   *................*\n00070   0200 0E00  0000 0000   0000 0000  0000 0000   *................*\n00080   0000 0000  0000 0000   0000 0000              *............    *\n\n\n\n\n\nOFF: 0000 (     0) ADDR: 00000 (       0) DSN: VTOC FOR AKD001\nLEN: 008C (   140) BASE: 00000 (       0) CCHHR: 0000000101 TTR:  000001\n\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 4.   This is a Format 1 DSCB as pictured by the Fullscreen ZAP\n            program from the CBT MVS Utilities Tape, File 134.  From\n            here you can see some of the advantages of using this TSO\n            command for viewing VTOC records.  Everything can be seen\n            very clearly.  The dataset name is SBHCIT.GARBAGE.DATASET.\n            The dataset resides on an SMS-managed pack called SMQ001.\n\n\n                                 Z  A  P\n_\nENTER VALID COMMAND ABOVE OR ? FOR HELP         VERSION=2.3G 17AUG92\n\n\n00000  >E2C2 C8C3  C9E3 4BC7   C1D9 C2C1  C7C5 4BC4   *SBHCIT.GARBAGE.D*\n00010   C1E3 C1E2  C5E3 4040   4040 4040  4040 4040   *ATASET          *\n00020   4040 4040  4040 4040   4040 4040  F1E2 D4D8   *            1SMQ*\n00030   F0F0 F100  0158 0019   0000 0001  0000 C9C2   *001...........IB*\n00040   D4D6 E2E5  E2F2 4040   4040 405F  002E 8020   *MOSVS2     \u00eb....*\n00050   0296 4000  9000 235C   0092 0000  0080 C000   *.o ....*.k....{.*\n00060   0001 0000  02AB 1000   0081 0000  9300 0000   *.........a..l...*\n00070   9300 0E00  0000 0000   0000 0000  0000 0000   *l...............*\n00080   0000 0000  0000 0000   0000 0000              *............    *\n\n\n\n\n\nOFF: 0000 (     0) ADDR: 00000 (       0) DSN: VTOC FOR SMQ001\nLEN: 008C (   140) BASE: 00000 (       0) CCHHR: 0000000105 TTR:  000005\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9505MY": {"ttr": 13578, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x95\\x08\\x0f\\x01\\x00)\\x9f\\x11G\\x01A\\x01A\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1995-03-21T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 321, "newlines": 321, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                            May 1995\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\nSam Golob is a Senior Systems Programmer working\nin New York City.\n\n\nVTOC TIDBITS - Part II\n\nGood News You Can Use.\n\n      I'd like to begin this month's column with some updates to\nwhat we've written in the past.  There are two items from previous\ncolumns.  First, I'm happy to inform you that a JES2 Exit Loader\n(see the September 1994 issue) has been developed by Terry Martin of\nBaltimore, which dynamically loads all three varieties of JES2\nexits:  exits resident in the JES2 address space, in CSA, and in\nLPA.  I am hoping that by the time you read this, Terry's code will\nhave been added to the CBT Tape, so you can get a look at it.  Now\nwe should be able to dynamically load and test a fresh version of\nany JES2 exit we are working on, regardless of type.  And we won't\nabsolutely require IBM to add such a feature to JES2, at least for\nnow.\n\n      Our second piece of news refers to a previous three-part series\nof columns (December 1991 thru February 1992) concerning dataset block\nsizes and I/O efficiency.  Those columns were based on Rick Fochtman's\nresearch analyzing channel commands to DASD, which were generated by\nstandard access methods (mainly QSAM).\n\n      Rick's work was done on an XA 2.2.3 system.  He found that when\na dataset is allocated in tracks, the seek commands generated by QSAM\nare limited by the track boundary, and must be clumsily restarted for\nthe next track.  Therefore, since QSAM normally attempts to fill up\nfive buffers to receive the data it reads, it would be most efficient\nto block track-allocated data at five blocks per track.  That would\nallow each read to cover a complete track without restarting, because\nit would fill up all five buffers completely in the one read.\nCylinder-allocated datasets would not have such a problem, because for\nthem, the seeks go past the track boundary to the cylinder boundary,\nand half-track blocking would still fill all five buffers in one read.\nTherefore, Rick recommended allocating larger datasets only in\ncylinders, and smaller ones in tracks, blocked 5 blocks per track.\n\n      Now, somewhere between XA 2.2.3 and ESA 4.3, IBM seems to have\ncorrected this problem.  Rick's current research on his MVS/ESA 4.3\nsystem now shows that DASD seeks generated by QSAM only stop at extent\nboundaries, even for track allocations, so the previous efficiency\nproblems are now removed.  Therefore if you are on a newer ESA system,\nthe best advice for data access efficiency with QSAM is to allocate in\ntracks, and block two blocks per track, period.  Maybe some IBM'ers\nhave been reading this column.  Who knows!\n\n\nGeneral VTOC Facts.\n\n      We resume our discussion of the DASD Volume Table of Contents,\nknown to the world as the VTOC of a disk pack.  As we mentioned last\nmonth, the VTOC is a fixed, unblocked, keyed file on the disk pack,\nwhose record length is 140, of which the first 44 bytes constitute\nthe key (and the other 96 bytes, the data).\n\n      How does the operating system find the VTOC of a pack?  The\nfirst record in the VTOC is pointed to by the VOLVTOC field (5 bytes\nat hex +B into the data area) of the disk label of the pack.  That is\nwhat the system uses to find where the pack's VTOC is.  The disk\nlabel is on Track 0, Record 3 of every pack initialized under MVS.\nIts fields are described after the DXLBL or VOLAREA labels in the\nIECDSECT macro which is in SYS1.MODGEN.  The disk label is 84 bytes\nlong, of which the first four bytes are a separate key, not described\nby the IECDSECT macro.  See Figure 1 for a picture of the Disk Volume\nLabel record, as shown by the \"Fullscreen ZAP\" TSO command in FULLVOL\nmode.  This command comes from File 134 of the CBT MVS Tape, which\ncan be ordered from NaSPA.\n\n      A record in the VTOC is commonly and officially referred to as a\n\"Data Set Control Block\" or DSCB.  Although most control blocks are in\ncentral storage, the DSCB is one of the comparatively few, which are\nentirely on disk storage.  There are currently eight supported formats\nof VTOC records, colorfully described by IBM as \"Format 0\" through\n\"Format 7\".  Figure 2 briefly describes the purpose of each type of\nVTOC record.\n\n      DSCB formats 1 through 6 are mapped by a macro in SYS1.AMODGEN\nor SYS1.MODGEN, called IECSDSL1.  Figure 3 shows how to code this\nmacro in order to obtain a map of these six VTOC formats.  You can\nalso get a lot of help from an IBM manual, the MVS/DFP System\nProgramming Reference, SC26-4567.  Chapters 2 and 3 of this manual\nprovide an excellent discussion and overview of VTOC facts and\ninformation.  There is probably an equivalent manual in the DFSMS\nliterature.\n\n      Last time, we looked at the \"Format 4 DSCB\", which is the VTOC\nHeader Record.  Every MVS VTOC has exactly one Format 4 record, and\nit has to come first.  The Format 4 record describes the general\ngeometry of the disk pack, even down to the surprising detail of how\nmany VTOC records will fit on one track of this DASD device, and how\nmany PDS directory blocks will fit on that same track size.\n\n      Every MVS VTOC has to have one \"Format 5 DSCB\" following the\n\"Format 4 DSCB\" header record.  Format 5 DSCB's on a VTOC are chained\ntogether to describe the free space, or unallocated extents, of a disk\nvolume.  This is true unless the volume has an active \"VTOC Index\".\n\n      A VTOC Index is an optional separate file on a disk pack which,\nif activated, will take over the free-space describing function of the\nchain of Format 5's.  A field in the VTOC Header (Format 4) tells the\nsystem if a VTOC Index is present and active on this disk pack.  Even\nif the VTOC Index is active, the first Format 5 record which follows\nthe Format 4 Header record, must always be present.  Because even if\nthat Format 5 record isn't being used now, it may be required later, if\nwe'd ever want to forcibly deactivate the VTOC Index (as sometimes we\nwill).  This first Format 5 record will then form the beginning of a\nnew chain of Format 5 records describing the un-indexed pack's free\nspace.  SMS-mananged packs are somewhat different.  SMS-managed packs\nmust always have an activated VTOC Index.  For SMS packs, the VTOC\nIndex is required, and not optional.\n\n\nVTOC Dataset Descriptor Records:  Format 1 DSCB's.\n\n      Nearly every dataset on a disk pack is described, at least\npartially, by a VTOC record known as a \"Format 1 DSCB\".  Today, we'll\nsee just a few of the many properties of our datasets which originate\nfrom fields in this powerful data area.  For further information and\nexploration, you should see the \"DSCB1\" entry in the IBM System Data\nAreas manual, LY28-1044, or in the DFP System Programming Reference\nmentioned above.\n\n      For instance:  the DSORG of a dataset is determined by the\nDS1DSORG field, which consists of 2 bytes of flags at location +52 hex\ninto the Format 1 DSCB.  Whether the dataset is PS, DA, PO, VSAM, or\nUnmovable, is determined by separate flags in this field.  Let's see\nan example of how to exploit this kind of knowledge.\n\n      I've found one neat way to delete the junk data and index\ncomponents of an uncataloged VSAM cluster from the VTOC.  They are\nhard to get rid of.  The technique involves changing the following\nfields in the Format 1 DSCB for each component:  First turn its DSORG\nfrom VS into PS, then zap off the password bits X'14' in the DS1DSIND\nfield at +5D hex, and finally zero out the three-byte expiration date\nfield at +38 hex.  Then you can delete the junked data and index\ncomponents using ordinary means, such as ISPF 3.2 or 3.4.  This trick\nwas courtesy of Rick Fochtman, and I can testify that it works fine.\n\n      A little-known flag is the DS1IND02 bit X'02' in the DS1DSIND\nbyte at +5D hex into the Format 1 DSCB.  This flag is used by DASD\nmanagement packages which do incremental dataset backups.  Whenever a\ndataset is opened for other than input, this flag gets turned on.\nOpening a dataset for other than input is usually a fair indicator\nthat the dataset was changed.  If this flag is on for a dataset, an\nincremental backup package such as HSM or FDRABR will back up the\ndataset and then turn the flag off.  Thus, you've backed up only\ndatasets which could have changed since the last backup.  Of course,\nthe DASD management package must keep a history of when all the\nbackups were done, and be able to synchronize all the data on the pack\nproperly, but this VTOC flag is crucial to making that whole process\nwork.\n\n      Secondary allocation is another useful thing to know about.\nWhen a dataset overflows its extents, in other words: if you want to\nadd more data to a dataset than its disk allocation can currently hold,\nallocation adds another extent according to the specifications in the\nFormat 1 DSCB for the dataset.  The fields affecting us are:  DS1SCAL1,\na one-byte field of flags at +5E hex, and DS1SCAL3, a three-byte binary\nnumber which tells you the size of the extent.  DS1SCAL1 is very\nimportant, in that it tells you if the secondary quantity is in Tracks,\nCylinders, or Blocks.  DS1SCAL3 then indicates the quantity of the units\nspecified by DS1SCAL1.\n\n      Speaking practically, we can show a common case.  Suppose a\ncertain dataset has a very small secondary space specified, such as\none track.  There is a limit of 16 extents on a single volume that can\nbe allocated for a non-VSAM dataset.  When that limit is reached, you\ncan't expand that dataset on that volume any more.  Let us say that\nour dataset has overflowed, and has already created 13 extents, 12 of\nwhich are one track only (according to the DSCB specifications).  We\nexpect the dataset to overflow further, but it is hard to reallocate\n(like SYS1.VTAMLST, for example).  A way to fix this situation would\nbe to zap the Format 1 DSCB of the dataset to specify a much larger\nsecondary extent value, such as 30 tracks.  This way, the next time\nthe dataset overflows, a single 30-track extent will be created, and\nwe will have only 14 extents instead of 15 or 16.  By doing this, we\ncan head off the trouble before it becomes unmanageable.\n\n      Last for today, we'll talk about the DS1LSTAR or \"high water\nmark\" field of a dataset.  DS1LSTAR is a three-byte field located at\n+62 hex into the Format 1 DSCB for a dataset.  DS1LSTAR contains the\nTTR of the last used track and last used record on the track.  If this\nvalue lies below the end of the dataset extents, we may find it useful\nto raise it a bit, so that we can look past the previous end of data\nlocation.  This is a tricky business, because you have to know that\nthe data which was past what was used, has proper attributes (blocksize,\netc.) so as not to cause an I/O error when you try to look at it.\n\n      Rather than zap DS1LSTAR so you can look past it, it is probably\nsafer to use the REVIEW TSO command from File 134 of the CBT MVS Tape.\nREVIEW is a powerful fullscreen browsing program which can override\nsuch obstacles as DS1LSTAR, and blocksizes of data which are bigger\nthan the block size values in the DS1BLKL field (at +56 hex for two\nbytes).  To use REVIEW to override DS1LSTAR, first REVIEW the dataset\nnormally, and go to the BOTTOM.  REVIEW will display the highest TTR\nvalue for normal data in the dataset.  This is the DS1LSTAR value.\nREVIEW can override this value with its NEWTOP ttr subcommand.  NEWTOP\nacts as if the new top-of-data is the TTR that you specify after it.\nIf you give NEWTOP a TTR that is past the DS1LSTAR value, REVIEW will\nattempt to read such data and display it.  However, because of block\nsize problems or other I/O errors, this may not work, and REVIEW will\ntell you so.\n\n      You may then try to re-invoke REVIEW with its BLKSIZE keyword,\nwhich can be used to open the dataset with a bigger blocksize than the\nDS1BLKL value.  Thus, if the data past DS1LSTAR is fairly well behaved,\nit may very well be possible to view it, and optionally \"rescue\" it.\n\n      I'd like to add one more thought before wrapping this discussion\nup.  Nowadays, the Format 1 DSCB for a dataset does not always tell us\nthe whole story.  For disk packs with indexed VTOCs, the VTOC Index\ndataset contains some additional information.  Further, if the dataset\nis cataloged in an ICF catalog, the disk pack's VVDS dataset will also\ncontain information that can affect how the system treats your\ndataset.  The IBM DFP manual called \"Managing Catalogs\", SC26-4555,\ncovers the VVDS angle quite thoroughly, while the System Programming\nReference manual mentioned above, covers the VTOC Index information.\n\n      This month's discussion has shown that you can gain a lot of\nknowledge about disk datasets by doing some digging and exploring.\nGood luck with it.  We'll see you next month.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   This is a Volume Label of disk pack AKD001, as pictured\n            by the Fullscreen ZAP program from the CBT MVS Utilities\n            Tape, File 134.  That program is a TSO command.  To\n            obtain the result pictured here, you enter TSO ZAP\n            'FORMAT4.DSCB' VOL(AKD001) FULLVOL\".  Then you advance 2\n            records by typing command \"R\" once, and again.\n            Fullscreen ZAP shows the Volume Label record to have 84\n            bytes decimal (54 bytes hex).  However, the first four\n            bytes constitute a separate key, not described by the\n            macro IECDSECT in SYS1.MODGEN.  The location arrow <\n            is pointed to the 5-byte location describing the CCHHR\n            of the pack's VTOC Header Record, which is 0000000101.\n\n\n                                 Z  A  P\n_\nENTER VALID COMMAND ABOVE OR ? FOR HELP         VERSION=2.3G 17AUG92\n\n\n00000   E5D6 D3F1  E5D6 D3F1   C1D2 C4F0  F0F1 4000<  *VOL1VOL1AKD001 .*\n00010   0000 0101  4040 4040   4040 4040  4040 4040   *....            *\n00020   4040 4040  4040 4040   4040 4040  40C9 D4E3   *             IMT*\n00030   C8C5 D6E6  D5C5 D940   4040 4040  4040 4040   *HEOWNER         *\n00040   4040 4040  4040 4040   4040 4040  4040 4040   *                *\n00050   4040 4040                                     *\n\n\n\n\n\n\n\n\nOFF: 0000 (     0) ADDR: 00000 (       0) DSN: VOLUME AKD001\nLEN: 0054 (    84) BASE: 00000 (       0) CCHHR: 0000000003 TTR:  000003\n\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n\nFigure 2.   A Quick Summary of the VTOC formats.\n\n\n       FORMAT 0 DSCB  -  Blank entry (all hex zeros)\n       FORMAT 1 DSCB  -  Dataset descriptor\n       FORMAT 2 DSCB  -  ISAM dataset information\n       FORMAT 3 DSCB  -  Location of extra extents\n       FORMAT 4 DSCB  -  VTOC Header Record\n       FORMAT 5 DSCB  -  Chained Free Space Descriptors\n                           (if VTOC index is disabled or is not there)\n       FORMAT 6 DSCB  -  Cylinder sharing\n       FORMAT 7 DSCB  -  Free Space Descriptors for 3390 model 9\n                           (or future large-capacity disk packs)\n\n  Every VTOC begins with a Format 4 DSCB.  It is always followed\n  by one Format 5 DSCB.  This Format 5 DSCB will begin a chain of\n  other Format 5's to describe the free space on the volume if\n  there is no VTOC Index, or if the VTOC Index is disabled.\n\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 3.   This is how to code the IECSDSL1 macro from SYS1.AMODGEN\n            or SYS1.MODGEN, to display DSECT descriptions of all six\n            (older) VTOC formats.\n\n\n*       * * *   V T O C   D E S C R I P T I O N   * * *\n*  ASSEMBLING THIS GIVES VTOC FORMATS FOR SIX TYPES OF\n*    VTOC ENTRIES.   (SYS1.AMODGEN)\n         IECSDSL1  1      , FORMAT 1 DSCB\n         IECSDSL1  2      , FORMAT 2 DSCB\n         IECSDSL1  3      , FORMAT 3 DSCB\n         IECSDSL1  4      , FORMAT 4 DSCB\n         IECSDSL1  5      , FORMAT 5 DSCB\n         IECSDSL1  6      , FORMAT 6 DSCB\n         END              ,\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9506JN": {"ttr": 13829, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x95\\x10\\x7f\\x01\\x00)\\x9f\\x11G\\x01E\\x01E\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1995-04-17T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 325, "newlines": 325, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           June 1995\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\nSam Golob is a Senior Systems Programmer working\nin New York City.\n\n\nA VTOC ADVENTURE - Part III\n\n      I mentioned in a previous column that a colleague of mine had\naccidentally deleted a partitioned dataset on a new MVS res pack, and\nthere was no reasonable backup.  Much SMP had been done to that\nlibrary since any previous backup had been made.  All that work would\nhave to be done over, and many other libraries would have been\ninvolved unnecessarily.  Anyone who has had this experience knows,\nthat starting again from a backup and doing the SMP over is not so\neasy.  Ah, if somehow, we could \"undelete\" that dataset....\n\n      Well, folks, sometimes it can be done.  And I can proudly say\nthat at least once in my life, I did it.  Here's how.\n\n\nA SUMMARY OF WHAT'S INVOLVED.\n\n      Basically, to \"undelete\" a dataset on DASD, you have to re-create\nits Format 1 VTOC entry, provided that the dataset has three extents or\nfewer.  If there are more than three extents, you'd also have to\nre-create a Format 3 VTOC entry, which gives the CCHHR's of the fourth\nthrough sixteenth extents.\n\n      Remember from our two past columns, that the Volume Table of\nContents or \"VTOC\" of a disk pack, is a dataset which is the pack's\ndirectory of datasets.  \"Physically\" speaking, the VTOC is a keyed\nBDAM unblocked dataset having fixed length records, which can also be\nread sequentially.  The overall record length is 140, of which the\nfirst 44 bytes constitute the key.  There are currently eight\ndifferent formats of VTOC records, picturesquely defined by IBM\nas \"Format 0\" thru \"Format 7\".  Each VTOC record is alternatively\ncalled a DSCB or Data Set Control Block.  Unlike most other control\nblocks, which reside in computer memory, the DSCB resides on disk.\nSee Figure 1 for a summary of what each of the VTOC formats is for.\n\n      Today we will concentrate on the Format 1 VTOC entry, which\ndescribes the basic properties of a dataset on a disk pack.  My\nspecific problem involved the deletion of a dataset having only one\nextent.  Therefore, we now have the job of constructing one Format 1\nDSCB for it.  Figuring out what to do for this case, probably would be\nenough work for today.  However, if you really wanted to get\nexperienced, you could probably un-delete a dataset with more extents.\nAfter practicing, you could track down the other extents and even\nrebuild a Format 3, if you really had to.  Actually, the extra extents\naren't that much harder.  Once the dataset's characteristics are\ndefined for the first extent, finding new extents is just a matter of\nadding CCHHR disk locations, either to the Format 1 or to the Format 3.\n\n\nOUR GAME PLAN.\n\n      How do we approach this task?  Before doing anything else, we\nhave to find where the old data was on the disk.  Without doing that,\nit is fruitless to try and make a directory entry, because the entry\nhas to have a place to point to.  Next, when we're sure where the old\ndata was, by CCHHR, it would be helpful to find another dataset which\nis somewhat similar, and to look at its Format 1 DSCB as a model.\nEspecially the first time out, it helps to have a model to follow.\nLater, as we've done this more times, the field names and locations in\nthe Format 1 DSCB will become more recognizable.  Then, we will be able\nto fill them in more directly from specific knowledge of where they are\nand what their values should be.  So with experience, we won't need\na model any more.\n\n      Next, we have to un-index the disk pack if it was indexed, and\nwe have to locate a suitable Format 0 DSCB to start converting into a\nFormat 1.  After that, we'll start filling in the VTOC record fields\nfor a Format 1 DSCB, one at a time.  Once all the principal fields are\nfilled in, we'll then adjust the DS1LSTAR or \"high water mark\" field,\nto correctly mark the true upper limit of the real data, within the\nextents where the dataset was defined.  Finally, we have to fix the\nun-indexed VTOC to correctly know that the deleted space is no longer\nfree.  Last, we re-index the VTOC if it had been indexed before.  If\nthe old dataset was cataloged, we'll have to recatalog the new one too.\n\n      Since the space in this column is limited, I'll have to assume\na bit more knowledge from the reader than I usually do.  In this way,\nwe'll be able to shorten the explanations to fit into the space we\nhave available.\n\n\nTOOLS.\n\n      In order to do this work, we have to have tools.  First, we\nneed a program to produce a CCHHR dataset map of a disk pack, sorted\nby tracks.  See Figure 2 for a picture of the type of output produced\nby IEHMAP, or by the many \"MAPDISK\" programs that are available.\nThen, we need a tool to find, display, and change individual VTOC\nrecords.  If you want to stick strictly to IBM-supplied tools, you\ncan use a combination of IEHLIST and AMASPZAP, but I highly prefer a\npublic domain program called \"Fullscreen ZAP\" for this purpose.\nFullscreen ZAP is much quicker.  Finally, we'll need to check our\nwork.  ISPF 3.2 or the IBM TSO command called LISTD can be used to\ncheck the dataset attributes in the VTOC entry that we've built.\n\n      The non-IBM tools we talk about, may all be obtained from a\npublic domain software tape called the CBT MVS Utilities Tape, which\ncan be ordered from the NaSPA office for a handling charge.\nFullscreen ZAP is on File 134 of the CBT Tape, IEHMAP is on File 083,\nthe PDS command is on File 182, and the REVIEW TSO command is also on\nFile 134.  Readers of our previous columns have some prior knowledge\nof all these tools.\n\n\nDOING THE WORK.\n\n      In my specific case, I was helped by the fact that I knew the\ndeleted dataset was 150 tracks in size, and that it was part of a new\nMVS res pack.  Therefore, I ran IEHMAP against the pack, and looked\nfor a gap of 150 free tracks.  IEHMAP gave me a CCHHR range to look\nat, and I then used Fullscreen ZAP in FULLVOL mode to examine the\ndeleted data.  In my case, there were two gaps of 150 tracks, but\nFullscreen ZAP showed that the data in the first gap was a PDS\ndirectory with the properly named members.  See Figure 3.  Thus, I\nwas able to correctly figure out the CCHHR range where the deleted\ndataset had been.\n\n      We have to supply a bit more detail about this.  See Figure 2\nto see the type of information that IEHMAP shows--specifically the\nCCHHR range of the 150-track free space.  You clearly see the gap\nstarting at CCHHR 0277.0000, going up to CCHHR 0280.000E.  In order\nto look at this data with Fullscreen ZAP, we have to run ZAP authorized\nin FULLVOL mode.  The TSO command to do this is:  \"ZAP 'FORMAT4.DSCB'\nVOL(volser) FULLVOL\".  This allows us to see all the data on the disk\npack, from the beginning to the end.  The initial command positions\nus at Track 0, Record 1.  Then we enter the ABS subcommand, to see\ndata at an absolute CCHHR location on disk.  We enter: ABS0277000001\nto look at the first record after the beginning of the extent.  This\nshows a PDS directory with the names we expect.  See Figure 3.\n\n      Now that we know the place where the data is, we have to go\nabout constructing the Format 1 VTOC record from a Format 0 record.\nFirst, we un-index the disk pack if it was indexed.  This is done\nwith an ICKDSF job that includes among its control statements:\n\"BUILDIX DDNAME(ptstovol) OSVTOC\".  Next, we have to find a Format 0\nrecord to work with.  We do that by getting into Fullscreen ZAP with\nthe command:  TSO ZAP 'FORMAT4.DSCB' VOL(volser).  This will get us to\nthe Format 4 DSCB (the VTOC header).  We can step forward record by\nrecord with repeated \"R\" commands until we find a record with all hex\nzeros.  If that is too tedious, we can enter the subcommand LASTDS1\nto find the last Format 1 DSCB in the VTOC, and then we can bop forward\na few records with \"R\" commands, until we find a Format 0 record at the\nend.  Anyway, Fullscreen ZAP has its own internal help screens, which\nyou can enter with a \"?\" command and exit with a \"U\" command.\n\n      Once we're at the Format 0 record that we want to work with,\nit would help if we had a printout of a model Format 1 from another\npack.  In our case, since we have multiple res packs with other copies\nof this dataset, we could enter Fullscreen ZAP on the other pack's\nVTOC, and print screen or \"DUMPF\" the Format 1 DSCB for the\ncorresponding dataset on the other pack.  Then we could take that\nprintout and start constructing our own Format 1, replacing four or\neight bytes at a time on the former Format 0.\n\n      Of course, our Format 1 will differ from the other dataset's\nFormat 1.  To get the dsect layout of a Format 1 DSCB, assemble the\nmacro IECSDSL1 from SYS1.MODGEN or AMODGEN, using the operand \"1\".\nIn other words, you would assemble the macro instruction:  \"IECSDSL1 1\".\nThen you will have a road map of the Format 1 DSCB, to see where you\nare.\n\n      Fields that are likely to differ are:  the Dataset Name (perhaps),\nthe Create Date, the Date Last Referenced, the DS1LSTAR (high water\nmark), the Extent Lower Limit, the Extent Upper Limit, and perhaps\nother extent information.  The rest of the Format 1 will probably be\nsimilar.  When you have filled in the entire Format 1 DSCB, remember\nto test the supposed attributes of the dataset by using ISPF 3.2 or\nISPF 3.4.  You might have to play around a little.\n\n      To set DS1LSTAR, use the TSO REVIEW command on the pds (with the\nVOL keyword, since the dataset is still uncataloged), and sort the\ndirectory by TTR.  This will give a good indicator of where you should\nstart setting DS1LSTAR, by going a bit past the highest TTR in the\ndirectory.  Make sure you recover all of the data in the last member.\n\n      After you've finished, you should have something that looks like\nFigure 4.  Use ISPF 3.2 over and over again until you know that the\ndataset is good, and all the old members are available for use.  You\nmust now reclaim the free space.  Using Fullscreen ZAP, go to the\nFormat 4 DSCB (enter \"P\" to go to the beginning of the VTOC).  Then\nturn on the DIRF bit (X'04' at +E past +2C from the beginning of the\nrecord).  Then go into ISPF 3.2 and try to allocate a new dataset on\nthe pack.  The console will show a message that the VTOC Convert\nroutine has been entered for reason, DIRF.  This will fix up the free\nspace for the pack.  If the pack has to be indexed, run ICKDSF with\nstatement:  \"BUILDIX DDNAME(ptstovol) IXVTOC\".  The dataset should now\nbe usable.\n\n      If you're a born system programmer, this should be the utmost\nfun, when you see that you've gotten the dataset back.  In any case,\nyou've at least helped your shop, and you've learned quite a bit in\nthe process.  Good luck.  See you next month.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   A Quick Summary of the VTOC formats.\n\n\n       FORMAT 0 DSCB  -  Blank entry (all hex zeros)\n       FORMAT 1 DSCB  -  Dataset descriptor\n       FORMAT 2 DSCB  -  ISAM dataset information\n       FORMAT 3 DSCB  -  Location of extra extents\n       FORMAT 4 DSCB  -  VTOC Header Record\n       FORMAT 5 DSCB  -  Chained Free Space Descriptors\n                           (if VTOC index is disabled or is not there)\n       FORMAT 6 DSCB  -  Cylinder sharing\n       FORMAT 7 DSCB  -  Free Space Descriptors for 3390 model 9\n                           (or future large-capacity disk packs)\n\n  Every VTOC begins with a Format 4 DSCB.  It is always followed\n  by one Format 5 DSCB.  This Format 5 DSCB will begin a chain of\n  other Format 5's to describe the free space on the volume if\n  there is no VTOC Index, or if the VTOC Index is disabled.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.   Illustration of IEHMAP track map output, showing the\n            150-track gap where our deleted dataset had been.  The\n            name of the deleted dataset was SYS1.AOC.SAOFNCLS.\n\n\n           -  -  -  -   more  data  -  -  -  -  -\n       0263.0000  0264.000E     30   1   NFTP210.SDVGMAC0\n       0265.0000  0265.000E     15   1   NFTP210.SDVGMOD2\n       0266.0000  0266.000E     15   1   NFTP210.SDVGMSG0\n       0267.0000  0272.000E    180   1   NFTP210.SDVGPNL0\n       0273.0000  0273.000E     15   1   NFTP210.SDVGSAC0\n       0274.0000  0275.000E     30   1   NFTP210.SDVGSAM0\n       0276.0000  0276.000E     15   1   NFTP210.SDVGSAR0\n       0277.0000  0280.000E    150        **********AVAILABLE**********\n       0281.0000  0286.000E     90   1   SYS1.AOC.SAOFNPNL\n       0287.0000  0287.000E     15   1   SYS1.HLASMBLR.SASMMAC1\n       0288.0000  0288.000E     15   1   SYS1.HLASMBLR.SASMSAM1\n       0289.0000  028B.000E     45   1   PLI.V2R3M0.PLIBASE\n       028C.0000  028C.000E     15   1   PLI.V2R3M0.PLICMD\n       028D.0000  0292.000E     90   1   PLI.V2R3M0.PLICOMP\n       0293.0000  0293.000E     15   1   PLI.V2R3M0.PLIHELP\n           -  -  -  -   more  data  -  -  -  -  -\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 3.   This is the beginning of the raw data at the absolute CCHHR\n            disk location where we think we deleted a PDS.  You will\n            notice that the format of the data is that of a PDS\n            directory, and the member names look like they would come\n            from an AOC CLIST library, which is what we want to restore.\n\n\n                                 Z  A  P\n_\nENTER VALID COMMAND ABOVE OR ? FOR HELP         VERSION=2.3G 17AUG92\n\n\n00000  >C1D6 C6C5  C9C3 C7E5   00F8 C1D6  C6C5 C1C3   *AOFEIGCV.8AOFEAC*\n00010   C1C6 0002  0C00 C1D6   C6C5 C1C9  D5E3 007B   *AF....AOFEAINT.#*\n00020   030F 0104  0015 0094   186F 0094  320F 1126   *.......m.?.m....*\n00030   012D 012D  0000 C9E2   D7C6 C9C4  4040 4040   *......ISPFID    *\n00040   C1D6 C6C5  C1C9 E2D4   0003 0500  C1D6 C6C5   *AOFEAISM....AOFE*\n00050   C1D5 E3D3  0004 0200   C1D6 C6C5  C1E2 C1C6   *ANTL....AOFEASAF*\n00060   0004 0400  C1D6 C6C5   C1E2 D3C1  0004 0700   *....AOFEASLA....*\n00070   C1D6 C6C5  C1E2 D3C7   0005 0100  C1D6 C6C5   *AOFEASLG....AOFE*\n00080   C1E2 E5C1  0005 0300   C1D6 C6C5  C3C1 E2C6   *ASVA....AOFECASF*\n00090   0005 0500  C1D6 C6C5   C3C6 C7C1  0005 0700   *....AOFECFGA....*\n000A0   C1D6 C6C5  C3C6 C7C2   0005 0900  C1D6 C6C5   *AOFECFGB....AOFE*\n000B0   C3C6 C7C3  0006 0100   C1D6 C6C5  C3C6 C7C4   *CFGC....AOFECFGD*\n000C0   0007 0300  C1D6 C6C5   C3C6 C7F1  0007 0500   *....AOFECFG1....*\n\nOFF: 0000 (     0) ADDR: 00000 (       0) DSN: VOLUME MRS003\nLEN: 0108 (   264) BASE: 00000 (       0) CCHHR: 0277000001 TTR:  24F901\n\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n\nFigure 4.   This is a Format 1 DSCB as pictured by the Fullscreen ZAP\n            program from the CBT MVS Utilities Tape, File 134.  From\n            here you can see some of the advantages of using this TSO\n            command for viewing VTOC records.  Everything can be seen\n            very clearly.  This is our finished VTOC record for the\n            dataset SYS1.AOC.SAOFNCLS, which resides on pack MRS003.\n\n\n                                 Z  A  P\n_\nENTER VALID COMMAND ABOVE OR ? FOR HELP         VERSION=2.3G 17AUG92\n\n\n00000  >E2E8 E2F1  4BC1 D6C3   4BE2 C1D6  C6D5 C3D3   *SYS1.AOC.SAOFNCL*\n00010   E240 4040  4040 4040   4040 4040  4040 4040   *S               *\n00020   4040 4040  4040 4040   4040 4040  F1D4 D9E2   *            1MRS*\n00030   F0F0 F300  015F 001A   0000 0001  0000 C9C2   *003...........IB*\n00040   D4D6 E2E5  E2F2 4040   4040 405F  0063 0000   *MOSVS2     \u00eb....*\n00050   0000 0200  9000 6D10   0050 0000  0082 C000   *......_..&...b{.*\n00060   0000 007B  041A 2A00   0081 0002  7700 0002   *...#.....a......*\n00070   8600 0E00  0000 0000   0000 0000  0000 0000   *................*\n00080   0000 0000  0000 0000   0000 0000              *............    *\n\n\n\n\n\nOFF: 0000 (     0) ADDR: 00000 (       0) DSN: VTOC FOR MRS003\nLEN: 008C (   140) BASE: 00000 (       0) CCHHR: 000000031F TTR:  00021F\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9507JL": {"ttr": 13835, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x95\\x14/\\x01\\x00)\\x9f\\x11G\\x01D\\x01@\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1995-05-22T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 324, "newlines": 320, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           July 1995\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\nSam Golob is a Senior Systems Programmer working\nin New York City.\n\n\nEXPLORING SYS1.BRODCAST\n\n      This month, we shall begin a tour of an \"ancient\" IBM data\nstructure, the SYS1.BRODCAST dataset which is part of TSO.  The TSO\nbroadcast dataset has to do with holding messages for TSO users.\nBesides providing messaging service for active users, TSO also\nsupplies the capability of preserving messages to inactive users\nuntil those users will logon to the system later.  In the meantime,\ntheir yet undelivered messages have to be kept someplace.  That place\nis the SYS1.BRODCAST dataset.\n\n      In later versions of TSO/E, there is an option of allocating\nindividualized user logs for holding the TSO user messages which have\nbeen deferred.  However, even when user logging is active, the\nSYS1.BRODCAST dataset is still needed for public notices and for\nmessages to users who haven't allocated their own logs yet.  In our\ndiscussion, we won't dwell on the user logs, since the central issue\nof deferred TSO messaging is still primarily the structure of the\nSYS1.BRODCAST dataset.\n\n      The SYS1.BRODCAST dataset also contains non-deletable messages\nthat are sent to all TSO users when they either logon, or issue the\nLISTBC command.  These global messages, which are more accurately\ncalled \"notices\", are displayed to all TSO users unless they set a\nspecial flag at logon time, not to receive them.  The global notices\nare kept in different types of records in SYS1.BRODCAST than the\nuser-directed messages.   We shall talk about this in more detail\nlater.\n\n      To my knowledge, TSO messages have their origin either in\nthe TSO SEND command, or from the SEND subcommand of the OPERATOR TSO\ncommand.  Even when you put NOTIFY messages in your JCL, a TSO SEND\ncommand is generated.  This will be readily apparent if you look at\nyour system's SYSLOG and watch what happens when jobs end.  SEND tries\nto route each message directly to the TSO userid, and will fail if the\nuser is not logged on.  However if you use the extra \"LOGON\"\nsubparameter of SEND, a logged on recipient will get the message\nimmediately as before, while all other recipient id's have their\nmessages stored in the broadcast dataset, waiting until they logon to\nTSO later.\n\n      Three principal programs open the SYS1.BRODCAST dataset.  They\nare:  SEND, LISTBC, and SYNC.  I'll quickly explain the functions of\nthese three programs:  SEND originates messages, between either TSO\nusers or consoles.  LISTBC displays and deletes all messages in the\nbroadcast dataset that are addressed to a particular user.  LISTBC is\nalso called during TSO logon processing, to display and delete all of\nthat user's saved-up messages at logon time.  SYNC clears all user\nmessages out of the broadcast dataset.  In addition, SYNC creates and\ninitializes all TSO userid entries in the broadcast dataset from the\nuserids defined to either SYS1.UADS or the RACF database.  The rest of\nour talk will describe the functions of these three programs, as they\nrelate to the internal structure of the broadcast dataset.\n\n\nBROADCAST DATASET INTERNALS.\n\n      Let's give a quick overview of the SYS1.BRODCAST dataset's\ninternal structure.  The broadcast dataset is a fixed unblocked keyed\ndataset with a one byte key, and 129 bytes of data in each record.\nThere are seven types of records, indicated by the value in the key.\nThey are termed types 0 thru 5 (Hex '00' thru '05') plus the X'FF'\nrecords for messages that have been deleted.  See Figure 1 for an\noverview of the purpose of each record type.  It is difficult to ISPF\nbrowse the complete SYS1.BRODCAST dataset, because the last character\nof each record gets left out.  To accurately look at the SYS1.BRODCAST\ndataset, I use the REVIEW TSO command, a very powerful public-domain\nfull screen browser.  REVIEW can be obtained from File 134 of the CBT\nMVS Utilities Tape, which can be ordered through the NaSPA office.\nThe Fullscreen ZAP program from the same file, is also useful for\nexamining each broadcast record in detail.\n\n      You can picture the structure of the broadcast dataset (odd as\nit is) in such a way that it makes logical sense.  See Figure 2 for an\noverview.  There is a general header record, called a type 4.  Next,\nbear in mind that SYS1.BRODCAST keeps two kinds of messages:  the\nglobal notices for all userids, and the individual messages intended\nfor single TSO userids.  Each type has a different part of the\nbroadcast dataset set aside for its use.  The global non-deletable\nnotices have a section reserved near the beginning, with a sub-section\nfor directory records (type 0) and another sub-section for the notice\nrecords (type 2) themselves.  Then the user message section follows.\nThis also has two parts:  the userid sub-section containing entries\nfor all TSO userids eligible to receive deferred messages, and the\nmessage sub-section, containing lists of messages chained from each\nuserid record that has messages pending.\n\n      This classification of \"sections\" is not anything official.  In\nfact, different types of broadcast records can be in mixed-up order as\nlong as all the pointers point correctly.  However, thinking of\nSYS1.BRODCAST as divided into sections rather than into record types\nmakes your picture of its overall structure easier to grasp.\n\n      It pays to say a few words about the chaining mechanism.  The\nbroadcast dataset is unblocked.  Therefore logical records are also\nphysical.  All physical broadcast records can be found by a relative\nrecord method of direct access, starting from the top of the dataset.\nIn other words, one can directly refer to the 1362nd record off the\nbeginning of the dataset, for example.  This would be record 552 in\nhex.  In this system, we are counting the first record (the header) as\nrecord zero, and record X'552' would be the 1362nd record after the\nheader, or the 1363rd record from the top.\n\n      The header record (type 4) contains a relative record pointer\nto the first userid record (type 1).  And all subsequent userid\nrecords are then chained off each other until they end.  Every userid\nrecord has room for nine userid entries.  Each userid entry consists\nof 13 bytes:  a 7-byte userid field followed by followed by two\nthree-byte binary numeric fields.  If there are no messages pending\nfor that user, both numeric fields are set to binary zeros.  If there\nare messages pending, the first three-byte field contains the\nhexadecimal relative record address of the first message (type 3),\nwhile the second field contains the relative record address of the\nlast message in the message chain for that user.  Thus, if there is\nonly one message for that user, both numbers are equal and non-zero.\n\n      The last three bytes in each message record contain a relative\nrecord pointer to the next message record in the chain.  If we are at\nthe last message for this user, the last three bytes in the message\nrecord will contain hex zeros.  Deleted messages have a key of X'FF',\nand must contain the Record Number of that record, the \"R\" from the\nTTR value, in the first data byte.  This system is not too\ncomplicated, once you get used to it.  Take a good look at Figure 2,\nwhich should help you to grasp what is going on.\n\n\nMANAGING SYS1.BRODCAST.\n\n      As we mentioned before, the three IBM commands:  SEND, LISTBC,\nand SYNC affect the SYS1.BRODCAST dataset.  However, for our practical\npurposes as system doctors, we have to treat the subject of how to\nsolve messaging problems, and we have to know what tools we can use.\nThe most common problem occurs when SYS1.BRODCAST fills up with\nundelivered messages.  No new messages can be deferred for logged off\nusers.  What can we do?\n\n      IBM says we can't do much, and they provide one tool:  the SYNC\ncommand, or the SYNC subcommand of the ACCOUNT command.  SYNC takes the\nbig bludgeon and says:  \"Your broadcast dataset is full, initialize\nthe entire user message section!\"  Even if only one dead user is\naccumulating 4000 messages, you have to clean the whole thing out,\naccording to IBM.  With our methods, we will be able to stave off this\noccurrence.  However, the SYNC command performs another useful function,\nand there are occasions when we need to use it.\n\n      When we define a new TSO userid, that id cannot receive\ndeferred messages until a userid entry is defined in SYS1.BRODCAST.\nThis is because all deferred messages are chained off the userid\nentry, and when there is no entry, there can be no messages stored.\nSYNC initializes the entire user record section of SYS1.BRODCAST,\neither from all userids defined in SYS1.UADS, or from those in the\nRACF (or other security system) database, or from both of these.\nThus, if you've added any new userids, you could use SYNC to let\nSYS1.BRODCAST know about them.  However, if you have RACF and you've\ndefined a new userid with a TSO segment, you'll get a userid entry\ncreated in SYS1.BRODCAST the first time you try to send a deferred\nmessage to the new id.  RACF seems to take care of it.\n\n      IBM has now provided an official interface for managing new\nuserid entries.  This interface is through a macro, IKJIFRIF, which\naccesses the SYS1.BRODCAST interface routine IKJIFR00.  Details about\nusing IKJIFRIF are described in the TSO/E Customization manual.\n\n      Through IKJIFRIF, we can write a TSO command processor to add,\ndelete, or rename userid entries in SYS1.BRODCAST.  To my knowledge,\nsample code is not provided by IBM but I myself hope to write such a\ncommand processor soon.  It looks to be quite easy, and I hope some\nof our readers will try it.\n\n      Getting back to our problem of draining unwanted messages that\nhave accumulated for users who will never logon, one answer lies in\ncleverly harnessing the power of the LISTBC command.  LISTBC is an\nauthorized command which (by default) lists broadcast notices, followed\nby all the deferred messages which have accumulated for a single userid.\nLISTBC is usually invoked by TSO logon processing, which is why you get\nall of your old messages when you logon.  After LISTBC has displayed\nan id's deferred messages, it deletes them all.  You can (normally)\nonly do this for your own id, and not for other ids.\n\n      However, we system doctors have to try and \"tickle\" LISTBC to\nwork on other people's messages.  My friend Bob Campanella came up\nwith a clever idea that works.  We can write a program that will do\nthe following:  First it links to LISTBC to clean out your own\nmessages.  This will zero the message pointers of your own id's\nSYS1.BRODCAST userid entry.  Then your program copies the pointers\nfrom the other id's userid entry into yours, and zeroes his pointers\nout.  Now, your userid entry has the pointers to his messages.\nFinally your program links to LISTBC again.  This will display and\nclean out the other id's messages.  Quite neat.\n\n      Another approach would be to point LISTBC to think that the\nother id is your id.  This also works, and I have written code to\nprove it.  A third approach is to write a program that will avoid\nLISTBC altogether, and deal directly with the internals of\nSYS1.BRODCAST.  This third strategy has the disadvantage that it\ndepends on your current knowledge of the broadcast dataset internals,\nwhereas LISTBC is an officially maintained IBM program that may be\nadjusted by IBM for future changes.\n\n      I must also mention that there are programs on the CBT MVS Tape\nwhich will display which userids have messages waiting.  The BRODSCAN\nprogram from File 136 of the CBT Tape will show you all this\ninformation.  And the BRDANL program from Tim Vanderwall, on File\n141, will actually display pending messages without deleting them\nafterwards.  I hope I have gotten your thinking juices started.  Good\nluck to all of you.  We'll see you next month.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFigure 1.   OVERVIEW OF SYS1.BRODCAST RECORD TYPES.\n\n            The following is a summary of the record types in the\n            SYS1.BRODCAST dataset.  The five macros mentioned below\n            can also be found on File 179 of the CBT MVS Tape.\n\n\n       Type 0:   Contains relative record index pointers to\n                 NOTICE records (type 2).  25 pointers per record.\n                 Mapped by IKJZT302 from PVTMACS (TSO optional\n                 materials).\n\n       Type 1:   Contains TSO userid entries (9 per record) which\n                 point to relative record numbers of the starting\n                 and ending messages in that userid's chain.  Both\n                 pointers are zero if there are no messages for that\n                 userid.  Each userid entry (13 bytes) is mapped by\n                 macro IKJZT304 from PVTMACS.\n\n       Type 2:   Broadcast NOTICES record for permanent notices to\n                 all TSO users.   Mapped by macro IKJZT303.\n\n       Type 3:   User message record for individual user mail\n                 messages to a particular TSO user.  Mapped by\n                 macro IKJZT305.\n\n       Type 4:   SYS1.BRODCAST header record.  Mapped by macro\n                 IKJZT301.\n\n       Type 5:   Pointer to current first re-usable deleted record\n                 (type FF).  This is probably for SEND to know where\n                 it can start writing the next user mail message.\n                 No mapping macro.  First data byte:  hex zeros,\n                 reserved.  Next three bytes: a binary relative\n                 record number pointing to a type FF record.  The\n                 rest of the record contains binary zeros.\n\n       Type FF:  Contains a deleted user message record.  In a\n                 type FF record the first data byte must contain\n                 the Record Number in Hex of that record on the\n                 track.  This is the \"R\" from the TTR of the\n                 record.  If that byte of the type FF record does\n                 not contain this value, the SEND program will\n                 have trouble, and SYS1.BRODCAST may appear full\n                 when it really isn't.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.   Below is a pictorial view of the broadcast which should\n            help one to be able to navigate it successfully.  (This\n            diagram is courtesy of Jim Marshall.)\n\n\n                        S Y S 1 . B R O D C A S T\n      ===============================================================\n      =                                                             =\n      =   *--*--------*---------*----------------------------*---*  =\n      =   *04*        * R1USPTR *  'SYS1.BRODCAST DATA SET'  *   *  =\n      =   *--*--------*-----+---*----------------------------*---*  =\n      =                     +                                       =\n      =    ++++++++++++++++++                                       =\n      =    +     1ST USER MAIL DIRECTORY RECORD  (EACH USERID       =\n      =    +       ENTRY CONSISTS OF A 13 BYTE AREA; THE USERID,    =\n      =    +       NEXT RBA POINTER AND ENDING RBA POINTER.         =\n      =    +                                                        =\n      =   *--*-------*---*----* /// *------*---*----*--*-----*      =\n      =   *01* USERID*RBA*ERBA* /// *USERID*RBA*ERBA*7F* RBA *      =\n      =   *--*-------*---*----* /// *------*---*----*--*--+--*      =\n      =                                                   +         =\n      =    +++++++++++++++++++++++++++++++ //// +++++++++++         =\n      =    +                                                        =\n      =    +    LAST USER MAIL DIRECTORY RECORD                     =\n      =    +                                                        =\n      =    +    NOTE: '000' ENDS THE CHAIN OF X'01' RECORDS.        =\n      =   *--*-------*---*----* /// *------*---*----*--*-----*      =\n      =   *01* USERID*RBA*ERBA* /// *USERID*RBA*ERBA*7F* 000 *      =\n      =   *--*-------*---*----* /// *------*-+-*-+--*--*--+--*      =\n      =                                      +   +                  =\n      =    +++++++++++++++++++++++++++++++++++   +++++++++++++++++  =\n      =    +                                                     +  =\n      =    +     1ST MESSAGE RECORD FOR USER                     +  =\n      =   *--*-----------------------------------------*-----*   +  =\n      =   *03*                                         * RBA *   +  =\n      =   *--*-----------------------------------------*--+--*   +  =\n      =                                                   +      +  =\n      =    ++++++++++++++++++++++++++ //// ++++++++++++++++      +  =\n      =    +                                                     +  =\n      =    +++++++++++++++++++++++++++++++++++++++++++++++++++++++  =\n      =    ++    LAST MESSAGE RECORD FOR USER                       =\n      =    ++   NOTE: '000' ENDS THE CHAIN OF X'03' RECORDS.        =\n      =   *--*-----------------------------------------*-----*      =\n      =   *03*                                         * 000 *      =\n      =   *--*-----------------------------------------*-----*      =\n      =                                                             =\n      =             FREE  SPACE                                     =\n      =   *--*-----------------------------------------------*      =\n      =   *FF*                                               *      =\n      =   *--*-----------------------------------------------*      =\n      =                                                             =\n      ===============================================================\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9508AU": {"ttr": 14086, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x95\\x17?\\x01\\x00)\\x9f\\x11G\\x01D\\x01Q\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1995-06-22T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 324, "newlines": 337, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          August 1995\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\nSam Golob is a Senior Systems Programmer working\nin New York City.\n\n\nA NOVICE'S GUIDE TO ASSEMBLER PROGRAMMING - PART I\n\n      I hear that the trend today among new systems programmers, is\nthat you don't really have to know Assembler language coding.  It is\ntrue that one can get by with a minimal knowledge of Assembler.\nNormally, to install some product, you just have to \"slap it in\" and\ncustomize it a bit.  To install the operating system, you just have to\n\"follow the CBIPO yellow brick road\" and adjust a lot of PARMLIB\nmembers.  Assembler coding doesn't often enter into the procedures.\nAnd it seems that many of the newer people have been managing to do\nwithout it.\n\n      But the truth is that if you don't know Assembler, you're\nmissing a lot of the picture and a lot of the joy.  The operating\nsystem, whether it be written in PL/AS or Assembler, is still\nwritten in Assembler from our point of view.  When some instruction\ncauses a problem, it's nice to be able to look at a dump of the\nmodule, and be able to talk intelligently.  Most of all, there will\nalways exist a lot of user written interfaces to operating system\nservices.  IBM and the software vendors will not always fill every\nneed.  It provides much personal satisfaction to dig into one of\nthese utilities and see for yourself, how it does its \"magic\".  Then\nyou can enhance it, so it can do even more.\n\n      In this piece, I'm not going to cover any intricacies.  This\nmight be the first Assembler article you've seen which is really\nsimple.  If you know a few facts about how an Assembler program works,\nand you \"break the ice\", your usefulness to the shop will increase\nmeasurably.  Furthermore, you'll begin to experience some of the real\njoy that our systems programming craft has to offer.\n\n      I've coded a sample program called MYID, with all the frills\nleft out.  But the program works and it proves my point.  This is a\nTSO command that has no parameters.  You just type in the command MYID\nfrom a TSO session, and the command returns a message:  MY USERID IS\nyourid, with the correct id filled in.  This program will show you how\neasy it really is to follow a chain of address pointers in control\nblocks.  If you learn to understand this simple logic, you will soon be\nable to extract very serious information from the MVS operating\nsystem.  Now we'll talk about basics.\n\n\nREGISTERS.\n\n      An IBM 370/390/9000 type computer has sixteen four-byte (fullword)\ncompartments in its mechanism, called registers.  These sixteen \"guys\"\nare available to hold quantities which are necessary for every program's\nexecution.  I'm not going to talk about \"control registers\" or \"access\nregisters\" or any of the complicated stuff here, just the plain old\n\"general purpose registers\" that every program uses.  You can consider\nthe 16 registers as a part of the computer hardware which all programs\nhave access to.  A program can put any quantity into any register.\nHowever, for the program to do what you want, you have to control the\nquantities put into the registers very carefully.\n\n      The sixteen general purpose registers are called \"Register 0\"\nthru \"Register 15\".  The contents of each register are treated as a\nbinary or hexadecimal number, which can go from zero to 4 gigabytes.\nIn some instructions, the high order bit X'80000000' might signify a\nsign, but not always.  Oftentimes an instruction treats a register as\na 32-bit unsigned binary number, and this is frequently the case.  For\naccuracy, please refer to the IBM Principles of Operation manual\nregarding each instruction you want to use.\n\n      These 16 registers are used by Instructions.  A list of all the\nMachine Instructions is found in the IBM manual called Principles of\nOperation.  I'm sure that most of you have been intimidated by this\nmanual.  I can surely say that I have.  Now, after all my years in\nthis field, I am able to make some sense out of the Principles of\nOperation.  I hope to provide a few hints, so that your trips through\nthis useful manual will often yield some tasty fruit, instead of\nconstant frustration.\n\n\nBASE AND DISPLACEMENT.\n\n      A program consists of instructions in sequence, one after\nanother.  However, sometimes the instructions should not be executed\nin the direct linear sequence, but the logic calls for jumping, or\n\"branching\" to a new place within the program.  Other parts of the\nprogram logic may require reference to data or instructions that are\nlocated elsewhere in the program.  Therefore, each program must keep\nsome mechanism for determining the exact location of any of its parts.\nThis location tracking mechanism is called \"base and displacement\".\n\n      The way it works is as follows:  One or more registers are chosen\nas \"base registers\".  Each base register has the capacity to track 4096\nbytes (the size of zero thru X'FFF' bytes) in the program, further than\nwhere it starts.  If more bytes need to be tracked (e.g. the program is\nlarger than 4096 bytes), then more base registers may need to be used.\nThe ASSEMBLER (the Compiler for Assembler language is called the\nAssembler) has an instruction called USING.  This USING instruction\ntakes as operands, a starting location and one or more registers.  The\nUSING instruction says that from the designated starting location in\nthe program, use each of the designated register(s) for counting all\nlocations up to 4096 bytes further on.  If there is more than one\nregister being defined in one USING statement, they are strung out one\nafter the other, in their order of mention.\n\n      The USING instruction is not enough.  All base registers need to\nbe loaded with the actual address in virtual storage which corresponds\nto the location in the program which the USING instruction designates\nas its starting point.  If the base registers don't get properly\nloaded, the program won't run.  We will now explain how this loading\nis accomplished.  It is usually done with LOAD, LOAD ADDRESS, or LOAD\nREGISTER instructions.\n\n\nLOAD AND LOAD ADDRESS.\n\n      The USING instruction we just mentioned, is not a machine\ninstruction.  It is just a directive to the Assembler how to calculate\ndisplacements from a base location.  Now we will introduce four actual\nmachine instructions which can be executed by the computer hardware.\nThese instructions are LOAD (designated by the symbol \"L\"), LOAD ADDRESS\n(designated by \"LA\"), LOAD REGISTER (designated by \"LR\") and STORE\n(designated by \"ST\").  It is well worth remembering that LOAD and STORE\nare a pair which do the exact opposites.  All of these instructions\nare used in the sample program shown in Figure 1.\n\n      LOAD takes the contents of a fullword (four bytes in storage\naligned on a boundary location which is divisible by four) and dumps\nit into a register, unchanged.  Remember that LOAD does not change\nanything.  It just takes the four bytes from storage and dumps it into\nthe four bytes of the register, where the computer can work on it.\nSTORE does exactly the opposite.  STORE takes the 4-byte content of a\nregister, and dumps it unchanged into a fullword storage location.\nThis may seem utterly simple, but you should go over it about twenty\ntimes in your mind.  I have a reason for saying so.  It is very easy\nto confuse the roles of the LOAD and LOAD ADDRESS instructions.  After\nall these years, I still have to be careful myself.  Once you realize\nthat LOAD does the exact opposite of STORE, you'll be much more able\nto tell LOAD and LOAD ADDRESS apart.\n\n      LOAD REGISTER just dumps the contents of one register into\nanother, completely erasing the previous contents of the target\nregister.  If you need to save the contents of one register to a\ndifferent register, you use LR.  All these instructions have two\noperands.  In the Principles of Operation manual, the operands of\neach instruction are always clearly described as the first or second\n(or third) operand.  Usually, data movement goes from the second\noperand to the first.  However, with the STORE instructions, the\nopposite happens, and the movement goes from the first operand to the\nsecond.  Therefore, even though LOAD and STORE do the opposite thing,\nthe corresponding instructions look identical, except for the\ninstruction itself.  Now we have to talk about the LOAD ADDRESS\ninstruction.\n\n      LOAD ADDRESS puts a numeric quantity into a register.  This\nquantity is added up from three sources.  These are: another register\ncalled the base, a numeric quantity from 0 to 4095 (X'000' thru\nX'FFF') called the displacement, and a second register called the\nindex register.  Much of the time, the index register is zero, so the\nquantity calculated is the sum of the base register quantity, and the\ndisplacement.  LOAD ADDRESS is most often used to calculate a new\naddress from an old address, or it can be used as a binary summation\ntool.  It should be noted that the highest order bit (in 31-bit mode)\nor the highest-order byte (in 24-bit mode) is zeroed by the LOAD\nADDRESS instruction.\n\n      Why do people confuse the LOAD and LOAD ADDRESS instructions?\nBecause they look the same.  But the difference is that LOAD references\na storage location, and LOAD ADDRESS doesn't, it only calculates a new\nnumber from old ones.  LOAD ADDRESS does not have anything to do with\nstorage at all.\n\n      Now how are these instructions actually used to put the proper\nvirtual storage address in a USING register?  There are several ways.\nBut to understand things properly, we must first consider how almost\nany program executes in an MVS system.\n\n      If you'll take an actual look at how a program runs in MVS, it\nwill open your eyes.  Most programs run as called programs of called\nprograms, nested many times, program under program.  If you'd look at\na list of these programs, your own program might be the ninth or tenth\none.  All these programs must properly communicate their linkage to\neach other, or great confusion would result.  Because of this, there\nis what is called a STANDARD OS LINKAGE CONVENTION, which is almost\nalways followed when programs are run under MVS.\n\n\nMVS PROGRAM LINKAGE CONVENTIONS.\n\n      The standard linkage convention confuses most novices for a long\ntime.  However, if you look at it in the right way, it is not hard to\ngrasp.  It is like this.  Every program has to establish an\n18-fullword (72-byte) save area.  This is for saving 15 of the\nprevious program's 16 registers in the last 15 of the 18 fullwords.\nWe save the previous program's registers 14 and 15, and 0 thru 12, in\nthat order.  Register 13 is special.  Register 13 must always point to\na save area, either our program's save area or the save area of the\nprevious program.\n\n      One other fact has to be mentioned.  When our program receives\ncontrol from the previous program, Register 15 contains the entry\npoint address of our program.  That is why the initial base register\nto our program can be loaded with a LOAD REGISTER instruction, dumping\nthe contents of Register 15 into the register which our program will\nuse as its initial base register.  For example, in our sample program,\nwe use Register 12 as our one base register.  Therefore, to set up\nRegister 12 properly, we do a LR R12,R15 to dump the contents of\nRegister 15, which has the entry point address, into Register 12, which\nwill track subsequent program locations from there on.\n\n      Getting back to the linkage conventions, Register 13 comes in\ncontaining the address of the previous program's save area.  When we\nestablish our new save area, we preserve the previous contents of\nRegister 13, point Register 13 to our new save area, and store the\naddress of the previous save area in the second fullword (4 off the\nbeginning) of our new save area.  Thus, Register 13 is adjusted to\npoint to our new save area, and the old one's address is preserved\nat 4 off the new area.\n\n      We also have to inform the old program, which isn't actually\nrunning now, about where our own new save area is.  We do this by\nstoring the value of our current Register 13 (pointing to our own\nsave area) into the third fullword (8 off the beginning) of his save\narea.  Look at the sample program to see how this is done.\n\n      When our program has finished executing, and we have to return\ncontrol to the previous program, we do as follows.  First we point\nRegister 13 to the old program's save area.  Then we restore the old\nprogram's registers from the last 15 fullwords of our save area.\nFinally, we give control to whatever program is located at the address\nof the old program's Register 14.  This Register 14 should contain the\nentry point where the old program wants to get control back.\n\n      Please study the sample program in Figure 1.  Type it into your\nsystem.  Assemble and linkedit it, and try to run it as a TSO command.\nIf you haven't been too familiar with Assembler language until now,\nyou should get a big boost by doing this.  Good luck.  We'll see you\nnext month.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFigure 1.  MYID is a simple Assembler program which is meant to\n           run under TSO.  You assemble and linkedit this program\n           and put it into a load library that is defined to your\n           TSO session, perhaps one of the ISPLLIB libraries.  The\n           program is called MYID.  Under your TSO session, this\n           TSO command MYID will return the phrase MY USERID IS\n           yourid, with your correct userid plugged in.  I didn't\n           make MYID re-entrant, so don't put MYID into LPALIB.\n\n           We illustrate how to run a chain of control blocks here.\n           Register 3 is loaded with the address of the CVT.  Then\n           Register 3 is made to point to the address of the TCB\n           words; then it is made to point to the current TCB, then\n           to the JSCB, and finally to the PSCB.  All this is done\n           with LOADs of address pointers that are in these control\n           blocks.  The beginning of the PSCB contains your TSO\n           session's userid.  A MOVE CHARACTER instruction moves 7\n           bytes from the PSCB control block containing the userid\n           into a blank space of the message area that we've\n           defined.  The blanks begin 13 bytes off the beginning of\n           the message area.  Finally, the TPUT macro is run against\n           the modified message area, to write the entire message to\n           your screen.  You can verify the displacements I've coded\n           by looking into the MVS Data Areas manuals under CVT,\n           IKJTCB, IEZJSCB, and IKJPSCB.\n\n           The first parameter of the TPUT macro is the address\n           of the beginning of the message.  The second parameter\n           is the length of the message.  I have purposely not used\n           DSECTs or mapping macros, because I did not want to\n           unnecessarily complicate matters for this illustration.\n\n\n*      M Y I D   P R O G R A M    -    A   T S O   C O M M A N D\n*\n*      TSO COMMAND PROCESSOR TO DISPLAY THE USERID OF THE INVOKER.\n*        REGISTER EQUATES\nR0       EQU   0             R\nR1       EQU   1               E\nR2       EQU   2                 G\nR3       EQU   3                   I\nR4       EQU   4                     S\nR5       EQU   5                       T\nR6       EQU   6                         E\nR7       EQU   7                           R\nR8       EQU   8\nR9       EQU   9             E\nR10      EQU   10              Q\nR11      EQU   11                U\nR12      EQU   12                  A\nR13      EQU   13                    T\nR14      EQU   14                      E\nR15      EQU   15                        S\nMYID     CSECT\n         STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS R14 THRU R12\n         LR    R12,R15             LOAD ENTRY POINT INTO BASE REGISTER\n         USING MYID,R12            TELL THE ASSEMBLER, R12 IS THE BASE\n         LR    R15,R13             SAVE CALLER'S SAVEAREA ADDRESS\n         LA    R13,SAVE            POINT R13 TO OUR SAVEAREA ADDRESS\n         ST    R15,SAVE+4          STORE HIS SAVEAREA INTO MINE + 4\n         ST    R13,8(,R15)         STORE MINE INTO HIS SAVEAREA + 8\nRUNCHAIN L     R3,16               POINT TO CVT. ADDR IS IN LOW STORAGE\n         L     R3,0(,R3)           POINT TO TCB/ASCB WORDS, \"0\" OFF CVT\n         L     R3,4(,R3)           POINT TO TCB, \"4\" OFF TCB/ASCB WORDS\n         L     R3,X'B4'(,R3)       POINT TO JSCB. X'B4' OFF CURRENT TCB\n         L     R3,X'108'(,R3)      POINT TO PSCB. X'108' OFF THE JSCB\n         MVC   MSGLINE+13(7),0(R3)   MOVE USERID IN FROM 0 OFF THE PSCB\n         TPUT  MSGLINE,L'MSGLINE   DISPLAY THE WHOLE MESSAGE ON THE TUBE\nRETURN   DS    0H\n         L     R13,SAVE+4          RELOAD CALLER'S SAVEAREA POINTER\n         LM    R14,R12,12(R13)     RELOAD THE CALLER'S REGISTERS\n         BR    R14                 RETURN TO CALLER\nSAVE     DC    18F'0'              DEFINE MY SAVEAREA - 18 FULLWORDS\nMSGLINE  DC    CL20'MY USERID IS        '      DEFINE LINE FOR MESSAGE\n         END\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9509SE": {"ttr": 14337, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x95\\x19\\x9f\\x01\\x00)\\x9f\\x11G\\x01K\\x01K\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1995-07-18T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 331, "newlines": 331, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                        September 1995\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\nSam Golob is a Senior Systems Programmer working\nin New York City.\n\n\nA NOVICE'S GUIDE TO ASSEMBLER PROGRAMMING - PART II\n\n      Last month, we lamented the fact that many new systems\nprogrammers do not know assembler language.  In my opinion, this\nsituation is being made worse by the fact that so much system code\ngets distributed in OCO (Object Code Only) form, without access to\nsource code or logic manuals.  Now it is well known that our job as\nsystems programmers involves not only installing packages of code,\nbut diagnosing their problems as well.  It is in that area, that\na lack of assembler knowledge causes a large handicap.\n\n      How does a knowledge of assembler language help?  A person who\nknows assembler can look at a load module in a dump, or on screen, and\nrecognize patterns.  It is usually easy to spot a DCB (Data Control\nBlock) and its associated DDNAME, if the DDNAME is hard coded or even\nif it is not.  A glance at the beginning of the program will show which\nregisters are the base registers, and how they are loaded.  You can\nwatch the STOREs and MOVE CHARACTERs into displacements off Register\n13, and see how the work areas are loaded.  If you can spot a BALR\n14,15 instruction X'05EF', this is an indicator that another program is\nbeing called.  You can actually look at the code previous to this\ninstruction, and see how the parameter list (if it exists) is being\nloaded.  The parameters are pointed to by Register 1, and the branch\nentry point is pointed to by Register 15.  All of this \"action\" can be\nviewed if you know assembler language and you have developed a\npracticed eye.\n\n      Such activity is aided by access to a disassembler program,\nwhich looks at a load module and decodes its machine instructions\ninto assembler language source instructions.  Our aim in using a\ndisassembler is to help in diagnosing problems, not to \"spy\" on some\nvendor's coding techniques.  If we are investigating a bug, and we know\nassembler language, we can actually help the vendor solve the problem\nmore easily, as any veteran in this field knows.  You can find several\ndisassemblers on the CBT MVS Utilities Tape, an independently produced\ntape which can be ordered through the NaSPA office.  The CBT Tape is a\nhuge collection of free MVS software.  Disassembler programs are found\non Files 171, 217, 220, 238 thru 242, and 458 of the CBT Tape.  You\ncan take your choice of what disassembler to use.  I have written\nseveral previous columns about disassemblers (January and March 1994).\nThese columns are also in the CBT Tape, on File 120.\n\n      This month, we will continue to explain more assembler concepts.\nAlthough the level will be a bit higher than in our last column, the\ntext should be quite understandable, and it will still be fairly simple.\nAt the end, we will show a revised version of last month's program\ncalled MYID, which reflects the additional concepts of reentrancy and\nmapping macros that we'll talk about today.\n\n\nREENTRANCY.\n\n      Assembler programs running under MVS utilize MVS system services.\nThis is something we cannot get away from.  Therefore, depending on the\ntask the program was designed for, some system services will usually\nhave to be used.  For example, suppose you want to write a program which\ncan be run by many users at the same time from the same copy.  A program\nthat is in the LPA list (in common storage) is in this category.  You\nhave to construct it so it does not change itself.  This is so that all\nthe users of that program will get the same results from its execution.\n\n      Most programs have data areas that are changed during the\nprogram's execution.  Obviously this could pose a problem if there are\nmultiple users of that code.  There is a coding technique which gets\naround this problem.  An \"unchangeable\" program can acquire dynamically\nobtained storage, just for this run, which will contain all of the\nchangeable data.  The rest of the program will remain completely\nunaltered throughout the run.  Writing a program in such a way, is\ncalled \"making the program reentrant\".\n\n      Making a program reentrant requires the use of system services\nto acquire the dynamic storage needed to contain the changeable data.\nIn an MVS system, the service of obtaining storage is called GETMAIN.\nOppositely, the service of freeing acquired main storage is called\nFREEMAIN.  The GETMAIN and FREEMAIN services are invoked by system\nassembler macros.  These macros, in their expansion, generate SVC\n(Supervisor Call) instructions.  There are several different SVC's\nthat a GETMAIN or FREEMAIN macro can generate.  Which SVC is called,\ndepends on what parameters are coded in the GETMAIN or FREEMAIN macro.\nIn higher level MVS systems (ESA), there is also a STORAGE macro that\ncan be used by a program to dynamically obtain additional storage\nareas for the program's use.\n\n      There is one more thing we have to say about reentrancy.\nSuppose a program is indeed written so it does not modify itself.\nThe system, however, will not force the use of a single copy of this\nprogram, unless the program also has the RENT (reentrant) linkage\neditor attribute turned on.  That attribute is a bit setting in the\npds directory entry for the load module, which was set by the linkage\neditor at the time the program was linkedited.  This is done by\ncoding a parm of RENT in the linkage editor JCL.  The RENT linkage\neditor attribute tells the program fetch service to set things up, so\nthat many callers of this program will use only one actual copy.\n\n      How do we write a re-entrant program?  Remember from last month,\nthat when a normal application program is run under MVS, it is called\nby a chain of perhaps eight or nine other programs.  Register 13 comes\nin, pointing to the previous program's register save area.  In any\nprogram, the register save area will contain variable data.  So before\nestablishing a new save area for our program, we GETMAIN enough\nadditional storage to contain the 72 bytes of the register save area,\nfollowed by all the storage needed to contain all the variable data\nwhich the program will have.  If the save area is placed at the\nbeginning of this dynamic storage, we can point Register 13 there, and\ndo a USING on Register 13 to be able to find all of the fields in the\ndynamic area.  Just before our program's execution is about to end,\nafter Register 13 is restored to point to the calling program's save\narea, our program does a FREEMAIN of the dynamic storage, to give it\nback to the operating system.  You can see a coded example in Figure 1.\n\n\nASSEMBLER MACROS AND DSECTS.\n\n      The Assembler (which is a compiler for assembler language code)\nnormally generates only one machine instruction for each instruction\nthat was coded by the programmer.  So why do we need a compiler if we\nare really coding in machine language, one generated instruction per\ncoded instruction?\n\n      There are several reasons for this.  First, the Assembler\ninstructions are pseudo-English, whereas the machine instructions are\nmerely hexadecimal numbers.  It is a lot easier to remember something\nthat looks like a language.  Second, the Assembler does the arithmetic\nfor us.  If we tell the program to branch (jump) to a certain location,\nwe can code the target location as a label, and the Assembler will\ncalculate the location to which the program has to go.  This is just\none of many examples in which the Assembler makes our coding easier by\ndoing a calculation.  Third, the Assembler contains a Macro Facility,\nwhich allows the generation of a complicated result from the coding of\njust one \"macro\" instruction that can have options and switches built\ninto it.  The GETMAIN and FREEMAIN macro instructions, which obtain and\nfree storage for a program's use, are examples of macro instructions.\nSee Figure 2 for a sample of the kind of code these macros generate.\n\n      Macro instructions can be pictured as coded mini-programs which\nperform a specific function.  The source code for each macro starts\nwith a MACRO statement and ends with a MEND statement; almost any kind\nof assembler statements may be coded in between, including other macro\nstatements.  In an assembler program, a macro is as though it were an\ninstruction.  When the program is assembled, the Assembler will realize\nthat the macro is not part of the regular instruction set, and it will\ntry to find the macro source code, either inline together with the\nprogram source, or externally in a macro library.  The macro libraries\nare pointed to by the SYSLIB ddname in the assembly JCL.  IBM supplies\nlarge collections of macros for its own use and for programmer use.\nMany of the IBM macros are shipped in two libraries:  SYS1.MACLIB and\nSYS1.MODGEN.\n\n      Informally, one might say there are various categories of macros.\nSome, like GETMAIN and FREEMAIN, are designed to invoke a system\nservice.  Others, which can be termed \"mapping macros\", contain data\npatterns which subdivide data areas into individual fields.  A third\ntype of macro is similar to a subroutine.  You can input some keywords\ninto the macro, and it will return a result.  Actually, one can code\nalmost anything in between the MACRO and MEND statements, so macros\nhave an enormous amount of flexibility, by definition.  Macro coding\noften makes extensive use of what is called \"conditional assembly\".\nAssembly-time branches, switches, and changes of variable may be built\ninto the structure of the macro source.  This allows macros to have\nenormous power and flexibility.  Conditional assembly is discussed in\ndetail in the Assembler Language manuals for the various IBM assemblers.\n\n      In our treatment today, we only have time to discuss the mapping\nmacros, so we will introduce the concept of the DSECT, or Dummy Section\nof a program.  DSECTs map out patterns of storage, without actually\ndefining a piece of the executable section of the program.  For example,\nsuppose we are dealing with a 20-byte record, which is divided into\nfields of various sizes and kinds.  We can code a DSECT which will map\nthe record layout of our record.  Then we can load a register with the\nactual address of where the record is.  A USING statement containing the\nlabel of the beginning of the DSECT, and the register in which the\nbeginning of the data is loaded, will allow the program to subsequently\naddress any of the individual fields in the data record.\n\n      Storage in an assembler program is defined either with the DS\n(Define Storage) instruction or the DC (Define Constant) instruction.\nDS will define a certain amount of storage, with a certain length\nattribute, but will not specify the actual data values which are\nloaded into that place.  DC, in addition to that, defines the initial\nvalue of the data occupying the storage which has been defined.  There\nare many details concerning the kinds of storage which one can define.\nThis matter is explained in the IBM Assembler Language manuals.  For\nnow, we can explain that hexadecimally expressed storage is indicated\nby the letter X, EBCDIC character form is indicated by the letter C,\nand binary bit form is indicated by the letter B.  See Figure 2, which\nshows some storage definitions.\n\n      Control blocks defined in the MVS operating system, are usually\nmapped by IBM-supplied macros which define DSECTs.  A USING statement\nreferring to a specific area (often the beginning) of the control\nblock, and connecting to a register, which has been loaded with the\naddress of that area in virtual storage, will allow a program to\nspecifically refer to all the fields of the control block, by label.\nSpace is short here, but we have re-coded last month's program, called\nMYID, to make it reentrant, and to use mapping macros to follow the\naddress pointers in the control block chains.  MYID, as you recall,\nis a TSO command that obtains your own userid, and displays it in a\nmessage to the terminal.  The revised version of MYID is displayed in\nFigure 1.\n\n      Please study the illustrations, and compare this version of the\nMYID program to last month's version.  I hope you'll come away with a\nbit more knowledge of what makes an assembler program tick.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   The MYID program revisited.  This is the same program as\n            we displayed last month, except that we have made it\n            reentrant, we use IBM's register equate macro YREGS, we\n            run the control block chain using IBM mapping macros for\n            the CVT, TCB, and JSCB control blocks, and we moved the\n            message area to GETMAINed storage.\n\n\n\n*      M Y I D   P R O G R A M    -    A   T S O   C O M M A N D\n*\n*      TSO COMMAND PROCESSOR TO DISPLAY THE USERID OF THE INVOKER.\n*\n*        REGISTER EQUATES\n         YREGS                ,    IBM'S REGISTER EQUATE MACRO\nSP000    EQU   0                   DEFINE SUBPOOL TO BE 0\n*\nMYID     CSECT\n         STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS R14 THRU R12\n         LR    R12,R15             LOAD ENTRY POINT INTO BASE REGISTER\n         USING MYID,R12            TELL THE ASSEMBLER, R12 IS THE BASE\n         GETMAIN RU,LV=DATALEN,SP=SP000,LOC=BELOW\n*  The address of the obtained storage is placed into Register 1.\n         ST    R13,4(,R1)          SAVE CALLER'S SAVEAREA ADDRESS\n         ST    R1,8(,R13)          STORE OUR SAVEAREA ADDRESS IN HIS\n         LR    R13,R1              POINT REGISTER 13 TO OUR SAVE AREA\n         USING SAVEAREA,R13        TELL ASSEMBLER\nRUNCHAIN L     R3,16               POINT TO CVT. ADDR IS IN LOW STORAGE\n         USING CVT,R3\n         L     R3,CVTTCBP          POINT TO TCB/ASCB WORDS, \"0\" OFF CVT\n         L     R3,4(,R3)           POINT TO TCB, \"4\" OFF TCB/ASCB WORDS\n         DROP  R3\n         USING TCB,R3\n         L     R3,TCBJSCB          POINT TO JSCB. X'B4' OFF CURRENT TCB\n         DROP  R3\n         USING IEZJSCB,R3\n         L     R3,JSCBPSCB         POINT TO PSCB. X'108' OFF THE JSCB\n         DROP  R3\n         USING PSCB,R3\n         MVC   MESSAGE(20),MSGLINE        MOVE TEXT TO VARIABLE AREA\n         MVC   MESSAGE+13(7),PSCBUSER     MOVE MY USERID INTO MESSAGE\n         DROP  R3\n         TPUT  MESSAGE,L'MESSAGE   DISPLAY THE WHOLE MESSAGE ON THE TUBE\nRETURN   DS    0H\n         LR    R1,R13              SET UP FOR SAVEAREA FREEMAIN\n         L     R13,4(,R13)         POINT TO CALLER'S SAVEAREA\n         FREEMAIN RU,LV=DATALEN,A=(R1),SP=SP000\n         LM    R14,R12,12(R13)     RELOAD THE CALLER'S REGISTERS\n         BR    R14                 RETURN TO CALLER\nMSGLINE  DC    CL20'MY USERID IS        '      CONSTANT PART OF MESSAGE\n*\nSAVEAREA DSECT\n         DS    18F                 DEFINE MY SAVEAREA - 18 FULLWORDS\nMESSAGE  DS    CL20                VARIABLE MESSAGE AREA\n         DS    0D                  ALIGN ON DOUBLEWORD\nDATALEN  EQU   *-SAVEAREA          DEFINE LENGTH OF VARIABLE STORAGE\n*\n         CVT   DSECT=YES           CVT mapping macro\n         IKJTCB                    TCB mapping macro\n         IEZJSCB                   JSCB mapping macro\n         IKJPSCB                   PSCB mapping macro\n         END\n\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.   One instance of the expansion of the GETMAIN macro.  In\n            this example, we are requesting that the system acquire\n            unconditionally, an amount of storage represented by the\n            numerical value in the variable DATALEN.  We also ask that\n            the location of this virtual storage be at addresses below\n            the 16 megabyte storage line, i.e. that its numeric\n            addresses be less than the hex quantity X'00FFFFFF'.\n            This is followed by an expansion of the corresponding\n            FREEMAIN macro.  The variable SP000 has been equated to\n            zero, so the obtained storage will come from Subpool 0.\n            The plus signs to the left, show the lines of code that\n            are generated when the Assembler expands the macro code.\n\n\n\n          GETMAIN RU,LV=DATALEN,SP=SP000,LOC=BELOW\n+         CNOP  0,4\n+         B     *+12-4*0-2*0       BRANCH AROUND DATA\n+         DC    A(DATALEN)         LENGTH\n+IHB0001F DC    BL1'00000000'           Flags\n+         DC    AL1(0)             RESERVED\n+         DC    AL1(SP000)         SUBPOOL\n+         DC    BL1'00010010'                 MODE BYTE\n+         L     0,*-8+2*0          LOAD LENGTH\n+         L     15,IHB0001F                       LOAD GETMAIN PARMS\n+         SR    1,1                     ZERO RESERVED REG 1\n+         SVC   120                     ISSUE GETMAIN SVC\n\n\n          FREEMAIN RU,LV=DATALEN,A=(R1),SP=SP000\n+         CNOP  0,4\n+         B     *+12-4*0-2*0       BRANCH AROUND DATA\n+         DC    A(DATALEN)         LENGTH\n+IHB0013F DC    BL1'00000000'           Flags\n+         DC    AL1(0)             RESERVED\n+         DC    AL1(SP000)         SUBPOOL NUMBER\n+         DC    BL1'00000011'                 MODE BYTE\n+         L     0,*-8+2*0          LOAD LENGTH\n+         LR    1,R1               LOAD AREA ADDRESS\n+         L     15,IHB0013F        LOAD PARAMETERS\n+         SVC   120                     ISSUE FREEMAIN SVC\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9510OC": {"ttr": 14343, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x95$\\x1f\\x01\\x00)\\x9f\\x11G\\x00\\xfe\\x00\\xfe\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1995-08-29T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 254, "newlines": 254, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         October 1995\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\nSam Golob is a Senior Systems Programmer working\nin New York City.\n\n\nWORKING WITH TSO - PART I\n\n      Most of us systems programmers do our work in interactive\nterminal sessions.  I have yet to find any one of us in this age, who\nstill operates by running a succession of batch programs only.  If we\nindeed worked without a terminal, we'd need to have a means of setting\nup our JCL, and none of us seems to punch cards any more.  Thus, to my\nknowledge, all of us MVS systems programmers have to work with TSO.\nThere are some shops who don't use ISPF under TSO, but use Wylbur or\nRoscoe (or maybe even FSE) instead.  However, I feel fairly safe in\nsaying that for almost all cases, TSO, which is a part of the\noperating system, is also a part of our working lives.\n\n      For this discussion, I want to separate those parts of our\nTSO work which specifically belong to TSO, from those other parts\nwhich more rightfully belong to ISPF/PDF.  More specifically, I'd\nlike to begin with a talk about TSO command processors, and then\nbranch out from there.\n\n      I find it hard to believe that there are MVS systems programmers\nwho don't know the difference between a TSO command processor, a CLIST,\na REXX exec, an ISPF dialog that is run from panels, and an ISPF dialog\nthat is driven by a program.  But I do get the feeling that the working\ndetails and scope of each type of TSO utility are not sufficiently well\nknown by most people.  And I am certain that we all have plenty to\nlearn, concerning the awesome power available through utilities\nbelonging in each of these five categories.\n\n\nSOME MISCELLANY.\n\n      It is worth spending a short time discussing the distinction\nbetween TSO and TSO/E.  TSO is the terminal monitor interface which\ncomes with the MVS operating system.  Base TSO has not been enhanced\nmuch in many years, but has been brought to compatibility with the\nrest of MVS, at least to the ESA Release 3 level.  Almost all real\nenhancements to TSO have been added to the separately billed\nreplacement known as TSO/E.  The TSO-VTAM interface has been vastly\nimproved in TSO/E, as have many of the basically supplied TSO\ncommands, such as the ALLOCATE command.  I believe that from the ESA\nRelease 4 level, TSO/E is mandatory, and you can't order free base TSO\nany more.  Our convention for the rest of this series, will be to use\nthe term TSO to refer to both base TSO and TSO/E, unless we need to\nclearly make a distinction.\n\n      Next, we'll make mention of TSO-in-Batch.  It is possible to\ncreate a TSO-like environment in a background job by executing the\nterminal monitor program IKJEFT01 in a batch job.  TSO commands are\nentered through the SYSTSIN ddname, and output is obtained through\nthe SYSTSPRT ddname.  See Figure 1 for an example of a TSO-in-Batch\njob which executes a TSO command.  We must carefully note at this\npoint, that in a batch job, a TSO command can only create printed\noutput if the PUTLINE output interface is used by the command, and\nnot if the simpler TPUT interface was used.  I've had the jolting\nexperience early in my career, that a TSO command did not print any\noutput at all when I ran it under TSO-in-Batch.  That command had\nonly used the TPUT macro for its output, and not PUTLINE.\n\n      It is also appropriate to mention the free Automated Operations\npackage from File 403 of the CBT MVS Utilities Tape which is called\nTSSO.  As part of its design, the MVS subsystem TSSO creates a TSO-like\nenvironment, and it runs with almost the same JCL as a TSO-in-Batch\njob.  The only difference is in the program being executed, and the\nexecution parms.  TSSO is a very interesting product and is worth your\ntime to study and learn from.  The purpose of TSSO, as conceived in the\noriginal package by its author Bill Godfrey, was to enable an MVS\nconsole operator to enter TSO commands at the console.  Bill's version\nof TSSO is still available unchanged on the CBT Tape, on File 306.\nTSSO was later expanded by Bellcore to include both Automated\nOperations and Console Security capabilities, long before these\nfeatures became a part of the MVS scene.  As for the CBT MVS Tape, it\nis free software, independently produced, and copies are orderable\nfrom the NaSPA office.\n\n\nTSO COMMAND PROCESSORS.\n\n      A TSO Command Processor is a program which accepts input and\nparameters from a terminal, and which performs actions.  When ENTER\nis pressed and a command is executed at the terminal, its associated\nTSO Command Processor program is attached by the Terminal Monitor\nProgram (TMP) that manages the TSO session.  Although a TSO command\nwhich executes a TSO Command Processor looks different from a batch\nprogram, it is in fact not much different at all.\n\n      The range of power in a TSO command is enormous.  All of the\ncapability of an enabled system-level program can potentially be\nbrought to bear in a TSO Command Processor program.  Many \"famous\"\nproducts that run under TSO are in fact TSO Command Processors, or are\nstarted by Command Processors.  For example, ISPF itself is started as\na TSO Command Processor.  The enormously powerful PdsTools vendor\nproduct, as well as its distant ancestor the PDS command from File 182\nof the CBT MVS Tape are TSO Command Processors.  Each of these TSO\nCommand Processors can perform hundreds, if not thousands, of separate\nfunctions.  IBM-supplied commands in SYS1.CMDLIB, such as TEST, LISTC,\nLISTD, or the RACF commands, are all TSO Command Processors.  Simple\nand complicated, TSO Command Processors are used by all of us, very\nfrequently during a day's work.\n\n      At this point, I'd like to say a word about the special\nexecution of some of the programs designed to run under TSO.  From XA\n2.2.0 onward, you can create a list of special programs in the\nSYS1.PARMLIB member IKJTSOxx.  This list of programs has actually been\npart of TSO from time immemorial, but it was formerly kept in a\ndifferent place.  There are four categories of such programs.  One is\na list of all APF Authorized TSO Command Processors which can be run.\nAnother is a list of all called programs (not TSO Command Processors)\nwhich can be run APF Authorized under your TSO session.  A third list\ncontains authorized commands that can be run from non-authorized\nprograms under TSO.  And finally the fourth list contains TSO Command\nProcessors which cannot be run in the background, that is, they will\nnot be allowed to work under the TSO-in-Batch facility.\n\n      In former releases of TSO, these lists were kept as tables in\nfour separate CSECTs.  The APF Authorized TSO commands were listed in\nCSECT IKJEFTE2.  The called programs which could be run APF Authorized\nunder TSO were listed in CSECT IKJEFTE8.  The list of authorized\ncommands that could be run by non-authorized commands is in CSECT\nIKJEFTAP.  And finally, the list of TSO Command Processors not allowed\nto run in the background, is in CSECT IKJEFTNS.  Under very old\nreleases of TSO, these CSECTs were part of the main terminal monitor\nprogram IKJEFT02.  Later (and currently) these CSECTs have been\nseparated out into their own load module called IKJTABLS.\n\n      Normally, the active SYS1.PARMLIB member IKJTSOxx overrides the\nload module IKJTABLS.  But if IKJTABLS is in an authorized STEPLIB in\nyour TSO session, IKJTABLS overrides the active PARMLIB member\nIKJTSOxx.  This is a very useful fact for systems programmers who can\nuse their own LOGON procedures.  They can set up a private environment\ncompletely separate from the public one.  For more help in this area,\nsee Files 185 and 186 of the CBT MVS Tape if you have a fairly recent\nversion.  Initialization of the effective set of program tables\nnormally takes place at LOGON time, but with the newest releases of\nTSO/E, the globally effective IKJTSOxx PARMLIB member can be changed\nusing the TSO PARMLIB command.\n\n\nSTRUCTURE OF A TSO COMMAND PROCESSOR.\n\n      Now we will talk about how a TSO Command Processor is\nstructured, at least in Assembler Language.  For detailed information,\nthe \"TSO/E Customization\" and \"TSO/E Programming\" manuals are very\nhelpful.  When a TSO command is entered at the terminal, the TSO\nTerminal Monitor Program (or TMP) attaches the appropriate TSO command\nprocessor program, whose load module has the same name as the command.\nAt this point, Register 1 is made to point to a control block called\nthe CPPL or Command Processor Parameter List.  The CPPL contains four\nfullwords, each containing an address pointing to somewhere else.  In\norder, the four addresses point to:  the Command Buffer, the UPT (User\nProfile Table), the PSCB (Protected Step Control Block) and the ECT\n(Environment Control Table).  These control blocks contain user-specific\ninformation necessary for the Terminal Monitor Program to authorize\nand process your request for action.\n\n      Immediately after your TSO command processor gets control, it\nmust save the address of the CPPL, since Register 1 gets reused by\nmany system macros.  You usually save the pointer in another register\n(using the LR - Load Register instruction) or in a fullword of storage\n(using the ST - Store instruction) at the beginning of the program.\nFor a reentrant program, the \"LR\" method must be used initially,\nbecause the GETMAIN macro which obtains dynamic storage needed by the\nreentrant program reuses Register 1.\n\n      Now we'll conclude with some information about the Command\nBuffer and the other three TSO control blocks.  The Command Buffer\ncontains command input which was entered at the terminal, or in\nthe SYSTSIN ddname file if the command was run with TSO-in-Batch.\nThis input can be interrogated by the program.  To make life easier,\nthe actual buffer content is prefixed by two halfword binary\nquantities.  The first quantity contains the total length of the data\nin the buffer, including the 4 bytes of the prefixes.  The second\nquantity is called the offset.  This is the displacement from the\nbeginning text byte of the buffer, to where the first parameter of\nthe command begins.  With such information, our program can contain\nappropriate logic to evaluate the command entered.\n\n      TSO also has a specially designed facility whose use is optional,\ncalled the \"TSO Parser\" or IKJPARS.  Properly set up, IKJPARS can check\nthe syntax of any parameters in the command.  Setting up IKJPARS is a\nbit involved, but once you've done it, you can usually copy much\n\"standard code\" from one program to another.  Detailed information\nabout IKJPARS is found in the \"TSO Programming\" manual from IBM.\n\n      I think the most important of the other three control blocks is\nthe PSCB, or Protected Step Control Block.  Settings in the PSCB\nheavily determine how much power your session has.  One of our\nprevious columns (October 1994) was devoted to a detailed treatment of\nthe PSCB's power.  The PSCB contains the USERID and its length, the\nsession \"attribute\" flags, the logon time for the session in TOD Clock\nformat, and some pointers to other control blocks.  The PSCB is mapped\nby macro IKJPSCB in SYS1.MACLIB, where you can read about what else it\ncontains.\n\n      The UPT (User Profile Table) largely contains the information\nwhich is controlled by the TSO PROFILE command.  The user's dataset\nprefix, if it has been defined, is contained in the UPT, as well as\nother user-specific and user-settable information.  The UPT is mapped\nby macro IKJUPT from SYS1.MACLIB.\n\n      The ECT (Environment Control Table) contains information that\nmostly is related to what this TSO user is doing now.  One of the ECT\nfields is the name of the last command entered.  The ECT has three\nbytes of binary switches that tell you a lot about the current command\nenvironment.  Among these are flags to indicate whether operands\n(other than the command itself) exist in the command buffer, whether\nvarious abnormal conditions have occurred, or whether this command is\nrunning from a terminal or in the background (TSO-in-Batch).  The ECT\nis mapped by macro IKJECT in SYS1.MACLIB, and from the macro, you can\nread all about it.\n\n      We have come to the end of our time for this issue, and we\nhope to continue further on this same topic next time.  I trust that\nthis basic information will enhance your knowledge in dealing with\nTSO.  Good luck.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   Layout of a TSO-in-Batch Job.  Note that the actual TSO\n            commands to be executed, are placed in a list in the\n            SYSTSIN ddname.  Only TSO commands which write their\n            output using the PUTLINE interface (and not the TPUT\n            interface) will show output under TSO-in-Batch.  Standard\n            IBM-supplied commands, such as the one shown, usually\n            use the PUTLINE interface.\n\n\n\n\n//TSOBATJB JOB (insert your job card information here)\n//*  - - - -  Job to execute TSO-in-Batch (background)  - - - -  *//\n//STEP01  EXEC PGM=IKJEFT01,REGION=4096K,DYNAMNBR=50\n//STEPLIB  DD DISP=SHR,DSN=your.steplib.name\n//SYSPRINT DD SYSOUT=*\n//SYSTSPRT DD SYSOUT=*\n//SYSTERM  DD SYSOUT=*\n//SYSTSIN  DD *\n LISTC LEV(SYS1) ALL\n LISTC LEV(SYS2) ALL\n/*\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9511NV": {"ttr": 14593, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x00\\x95'\\x0f\\x01\\x00)\\x9f\\x11G\\x01;\\x01;\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "1995-09-27T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 315, "newlines": 315, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         November 1995\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\nSam Golob is a Senior Systems Programmer working\nin New York City.\n\n\nWORKING WITH TSO - PART II\n\n      Last time, we said a few things about TSO in general, and spoke\nabout TSO Command Processors in particular.  When most people talk of\nTSO, they really have ISPF/PDF in mind.  While ISPF contains many\nwonderful programmer productivity tools which are worth quite a few\nseparate studies in themselves, TSO-specific facilities and tools tend\nto be neglected by the world at large.  Not enough attention is given\nto your potentially powerful allies in native TSO.\n\n      TSO Command Processors were treated briefly last time.  A TSO\nCommand Processor is a program (usually written in Assembler), which\nis invoked from a TSO session by typing the name of its load module.\nIn order for the Command Processor to be executed, of course its load\nlibrary has to be accessible to your TSO session.  This usually means\nthat the program has to be in a TASKLIB, or in STEPLIB, or in ISPLLIB\n(if you're running TSO commands from an ISPF screen), in the link\nlist, or in the LPA list.\n\n      Most TSO commands accept parameters at initial execution time,\nand additional \"subcommands\" later, during their execution.  Many TSO\nCommand Processors, such as IBM's ACCOUNT and TEST commands, do most\nof their work long after the initial invocation, through the use of\ntheir many subcommands.\n\n      TSO Command Processors have enormous potential power, because\nthey can have access to as many system services as batch programs can.\nIBM-distributed commands make only partial use of this power.  All of\nthe TSO commands distributed by IBM in SYS1.CMDLIB, such as ALLOCATE,\nLISTC, SEND, LISTD, and the RACF commands, are really TSO Command\nProcessors.  TSO Command Processors are an integral part of all TSO\nsessions.  Even ISPF itself is a huge TSO Command Processor.\n\n      It is possible for users to write TSO Command Processors that\nare as powerful or more powerful than IBM's distributed ones.  The\nfree software tape called the CBT MVS Utilities Tape, which can be\nobtained through NaSPA, contains a vast collection of MVS software,\nmuch in the form of user-written TSO commands.  A few of the many\nuseful TSO Command Processors on the CBT Tape are:  Fullscreen ZAP\nand the REVIEW programs from File 134 (each of which was the subject\nof a previous article in this column), the BLKDISK (disk space\ncalculator) command from File 296, the VTOC command from File 112,\nand the various flavors of QUEUE commands which are JES2 spool\nbrowsers, on Files 391 through 396.  The VSAMANAL command to analyze\nVSAM space allocations automatically, is found in source code on\nFile 294, and is highly handy.\n\n      The PDS command from File 182, which has hundreds of useful\nsystem functions, was a precursor of the highly successful PdsTools\nvendor product from Serena, that has thousands of functions.  Both of\nthese products are TSO Command Processors.  File 300 of the CBT Tape\nis a collection of several hundred TSO Command Processors.  Many more\nuser-written TSO Command Processors are scattered throughout the rest\nof the CBT Tape.  Free TSO commands give you the great advantage of\nseeing their source code, so you can find out how they do their\n\"magic\".\n\n\nTSO-in-BATCH and TSSO.\n\n      Let's spend a bit of time discussing TSO-in-Batch.  By\nmy observation, TSO-in-Batch is highly under-used by MVS systems\nprogrammers.  Just because a program was especially written to run\nunder TSO, doesn't mean that it can't be extremely useful in the\nbatch environment as well.  For example, in recovery situations\nwhen TSO (i.e. TCAS) itself might be down, but JES (2 or 3) is up, a\nTSO-in-Batch job will still work, and will execute almost all of the\nnon-fullscreen TSO commands.  See Figure 1 for an example of\nTSO-in-Batch invocation JCL.\n\n      As one illustration, you might use a TSO-in-Batch job to execute\nthe TSO RENAME command, which doesn't produce any output.  But RENAME\nwill do its work--the dataset or pds members will be renamed.  Your\nwork can be checked by running the TSO LISTD command afterward.  LISTD\nwill produce printable output under TSO-in-Batch.  This technique might\njust be what you need in order to save your system someday.  For some\nother examples:  TSO LISTC, DEFINE, and DELETE will also run\nbeautifully under TSO-in-Batch, as though they were under TSO, and they\nwill produce printable output.  These three commands interface with\nIDCAMS and VSAM.\n\n      We mentioned last time that in order for a TSO command executed\nunder TSO-in-Batch to produce printed output, it has to perform its\nterminal I/O through the TSO PUTLINE interface, rather than through\nthe simpler TPUT interface.  Most of the IBM-supplied TSO commands\nuse the PUTLINE, possibly with the associated GETLINE and PUTGET,\nterminal I/O interfaces.\n\n      Speaking of recovery situations, I can show you how to execute\nTSO commands even when JES and TCAS are both down, and you can't\nsubmit a batch job.  This idea is closely related to TSO-in-Batch.\nThere are products (even free ones) that create a TSO-like\nenvironment, running as an MVS subsystem.  Subsystems can be invoked\nindependently of JES, if they are started from a proc using the\nparameter SUB=MSTR.  While such a subsystem is running, you can\nexecute most TSO commands from an operator console, so you can perform\na large variety of recovery operations on a crippled system without\nrequiring a full IPL, and without requiring interactive TSO.\n\n      The free subsystems which will accomplish this are various\nversions of the product TSSO (Time Sharing Subsystem Option), that can\nbe found on several files in the CBT MVS Utilities Tape.  The original\nversion, by Bill Godfrey, is on File 306 of the CBT Tape.  A vastly\nimproved version that comes from Marc Schare and Bellcore, is on File\n401.  Updates to File 401 by David Cartwright are found on File 402.\nThese were merged into File 401 by Guy Albertelli, and the final\nproduct is on File 403.  If you plan on installing TSSO for recovery\nor console automation purposes, it is probably best on newer systems,\nto use the latest version from File 403.\n\n      With TSSO installed and started, TSO commands can be executed\nfrom the operator's console by prefixing them with the subsystem's\ndefined special character.  If TSSO was started with the parameter\nSUB=MSTR, then all non-fullscreen TSO commands should work except those\nwhich depend on JES, for example, SUBMIT, STATUS, or OUTPUT.  When TSSO\nis started with SUB=JES2 so it runs under JES2, then even those three\ncommands will work perfectly well.  Now if the vendor product PdsTools\nfrom Serena, or the PDS command from File 182 of the CBT Tape is\naccessible to the TSSO task via its JCL, one can even expand the number\nof directory blocks in a PDS without recreating it.  Or one can run\nIEBCOPY (without JES or TCAS up), to compress a system library, or to\ncopy some JCL members from some other dataset to SYS1.PROCLIB, for\nexample.  You can begin to envision many possibilities for quicker\nsystem recovery.\n\n      All recovery procedures that will work under TSSO, will also\nwork under TSO-in-Batch, provided that JES is up, and the environment\nwill allow a batch job to run.  You might even try and set up a\nstarted task to run TSO-in-Batch, rather than depending upon an\ninitiator.\n\n      JCL for starting TSSO comes with the various TSSO packages, as\ndistributed on the CBT Tape.  Figure 2 contains some sample TSSO JCL.\nYou may be very surprised to notice its similarity to TSO-in-Batch\nJCL.  This similarity is not coincidental, because TSSO was designed\nto interface enough with \"real TSO\", so that a TSO Command processor\nwill \"feel comfortable\" executing in either environment.\n\n\nSOME PRACTICAL APPLICATIONS.\n\n      Now we'll quickly mention a few simple and practical applications\nof this knowledge.  I recently had to delete a long list of datasets\nwith the same dataset prefix.  Having this list in a pds member, I\nedited the member to enclose each dataset name in quotes.  Then I\nshifted it to the right by a few bytes, to prefix each line with the\nDELETE TSO command.  Thus, I had a long list of successive TSO commands:\nDELETE 'dataset.name'.\n\n      It is possible to execute this pds member as a CLIST, and it would\naccomplish its job.  However, your terminal would be busy for a long\ntime, and if you weren't using the TSO Session Manager (see this column\nin the December 1994 issue) you'd have to be pressing ENTER each time\nthe screen filled up.  An easier way would be to precede this dataset\nwith TSO-in-Batch JCL (see Figure 1) and submit the commands as a batch\njob.  The commands will run much more quickly, and they won't tie up\nyour terminal.  Try it--you'll like it!\n\n      I had a second practical application when I was trying to do a\nmass ACCEPT of MVS maintenance.  This place had almost 500 Distribution\nLibraries at the time.  Many of them had been allocated using IBM's\nhorrendous \"device independent\" block allocation that often comes as\nthe product's default.  Oftentimes, there aren't enough directory blocks\nfor expansion, and there are tiny secondary extents, so the 16-extent\nlimit runs out easily.  No one in the place was able to successfully\nrun a mass ACCEPT, because the job kept bombing either on a \"directory\nfull\" condition, or on a B37 abend when a few libraries ran to 16\nextents, even with the compression turned on.\n\n      Clearly, I had to fix a lot of datasets, without taking ten days\nto do it.  TSO-in-Batch helped me again, but this time there was an\nextra twist.  To change the secondary extent size, I had to use the\nCDSCB TSO command from File 300 of the CBT Tape.  (See my February 1995\ncolumn for a description of CDSCB.  All my old columns are in File 120\nof the CBT Tape.)  CDSCB has to run authorized, and I had an additional\nrestriction that I couldn't change the IKJTSOxx member on the fly.  No\nproblem.  I set up \"private authorization\" (see last month's column) in\nan authorized STEPLIB, and put the CDSCB command in there too.\nTSO-in-Batch will honor that, just as interactive TSO will.\n\n      To add more directory blocks, I used the PDS TSO command from\nFile 182 of the CBT Tape.  PDS has a subcommand which refomats data\nspace at the beginning of a partitioned dataset's data area, as\nadditional directory blocks.  You just point PDS to the dataset and\nenter the subcommand:  FIXPDS EXPANDDIR(nn), where nn is the number\nof additional directory blocks you want to add.\n\n      I had to do all of this to about 300 or 400 datasets.  So I\nwrote the list of dataset names to a couple of files, and started\nediting them.  The format of the CDSCB command I used was approximately:\nCDSCB 'dataset.name' SHR SPACE(30) ALLOC(TR).  This assured that each\ndataset would have a secondary extent size of at least 30 tracks per\nextent.  I tried to leave the larger datasets off this list, or else\nI tried to give them bigger secondary allocations than that, by\nhand-editing the file.  Remember that I had a list which I could edit.\n\n      Once this list was prepared, I headed it with TSO-in-Batch JCL,\nusing the authorized STEPLIB, and ran it as a batch job.  It worked\nlike a charm.  The other problem was a little different.  This was the\nadding of more directory blocks.\n\n      Since there were so many datasets, I had to use a bit of a brute\nforce approach.  I decided to add 8 directory blocks to all the datasets\non the DLIB pack, so at least there would be some breathing room.  This\nhad to be done with the PDS command.  I don't know of any other tool,\nexcept for a specialized program that once was on the CBT Tape, which\ndoes this.  The only commercial products I know of that have this\nfeature, are PdsTools of course, and DP Technician.  The PDS command has\nto be set up in two lines.  First, you say:  PDS 'dataset.name', to\nchange the dataset which the PDS command is pointing to.  Then on the\nnext line, you have to say: FIXPDS EXPANDDIR(8).  You have to repeat\nthis for the 400-or-so datasets that you have.  Then you throw the\nTSO-in-Batch JCL in front, and submit the batch job.\n\n      All of this worked.  The ACCEPT job ran uneventfully, and\neverything was fine.  Now you can do it too.\n\n      In summary, I have to say that TSO-in-Batch really helps for\nlong jobs, and in a recovery situation.  TSSO helps for short jobs,\nand in an even worse recovery situation, but TSSO will be very useful\nunder normal circumstances too.  For example, you may need to display\nsomething at a system console, and a TSO command will do it.  Just\nrun the command from the console under TSSO.  The name of the game\nis to learn how to use either IBM-supplied or user-written TSO\ncommands to do as many jobs as possible.  Then these techniques will\nmultiply your power, and help extricate your shop from some annoying\nsituations.  Good luck.  See you next month.\n\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   Layout of a TSO-in-Batch Job.  Note that the actual TSO\n            commands to be executed, are placed in a list in the\n            SYSTSIN ddname.  Only TSO commands which write their\n            output using the PUTLINE interface (and not the TPUT\n            interface) will show output under TSO-in-Batch.  The TSO\n            RENAME command does not produce any printed output, but\n            we are using LISTD to show the results of the renaming\n            operation.\n\n\n\n//TSOBATJB JOB (insert your job card information here)\n//*  - - - -  Job to execute TSO-in-Batch (background)  - - - -  *//\n//STEP01  EXEC PGM=IKJEFT01,REGION=4096K,DYNAMNBR=50\n//STEPLIB  DD DISP=SHR,DSN=your.steplib.name\n//SYSPROC  DD DISP=SHR,DSN=your.clist.library\n//         DD DISP=SHR,DSN=another.clist.library\n//SYSPRINT DD SYSOUT=*\n//SYSTSPRT DD SYSOUT=*\n//SYSTERM  DD SYSOUT=*\n//SYSTSIN  DD *\n PROFILE NOPREFIX\n RENAME SYS1.PROCLIB(TSSO) SYS1.PROCLIB(TSSOOLD)\n RENAME SYS1.PROCLIB(TSSONEW) SYS1.PROCLIB(TSSO)\n LISTD SYS1.PROCLIB MEMBERS\n/*\n//\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.   Invocation of TSSO through its Started Procedure.\n\n            TSSO is started by a proc that looks very much like a\n            TSO-in-Batch job.  This example came from the CBT tape\n            File 401, and was somewhat abridged because of space\n            requirements.\n\n\n//TSSO PROC\n//*********************************************************************\n//* A SUBSYSTEM STARTED TASK IS JUST LIKE ANY OTHER STARTED TASK, WITH*\n//* TWO EXCEPTIONS. THEY ARE:                                         *\n//*                                                                   *\n//* 1) ALL DATASET NAMES MUST BE CATALOGUED IN THE MASTER CATALOG.    *\n//*                                                                   *\n//* 2) THE PROC MUST BE LOCATED IN SYS1.PROCLIB. THIS IS TRUE IF YOU  *\n//*    DO NOT SPECIFY THE SUB= PARAMETER ON THE START COMMAND.  THE   *\n//*    DEFAULT IS TO LET JES START TSSO.                              *\n//*********************************************************************\n//TSSO EXEC PGM=TSSO,REGION=3000K,DYNAMNBR=20\n//STEPLIB  DD  DSN=SYS1.TSSOLOAD,DISP=SHR\n//SYSPROC  DD  DSN=SYS1.TSSOPROC,DISP=SHR\n//SYSUADS  DD  DSN=SYS1.UADS,DISP=SHR\n//SYSTSIN  DD  DUMMY,DCB=(RECFM=FB,LRECL=80,BLKSIZE=80)\n//*********************************************************************\n//* TSSO DOES NOT USE THE SYSTSIN DATASET, BUT TSO WILL TRY TO GET    *\n//* COMMANDS FROM HERE. TSSO PASSES COMMANDS TO TSO AND DOESNT REQUIRE*\n//* SYSTSIN.\n//*********************************************************************\n//SYSTSPRT DD  UNIT=VIO,SPACE=(CYL,2),\n//         DCB=(RECFM=VBA,LRECL=137,BLKSIZE=1370,DSORG=PS)\n//*********************************************************************\n//* W A R N I N G          W A R N I N G        W A R N I N G         *\n//*\n//* DO NOT CHANGE THE LRECL AND BLOCKSIZE OF THE SYSTSPRT DATASET.    *\n//*\n//* W A R N I N G          W A R N I N G        W A R N I N G         *\n//*********************************************************************\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9512DE": {"ttr": 14599, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x95)o\\x01\\x00)\\x9f\\x11G\\x00\\xff\\x00\\xff\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1995-10-23T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 255, "newlines": 255, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         December 1995\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\nSam Golob is a Senior Systems Programmer working\nin New York City.\n\n\nKEEPING UP WITH THE UNIT CONTROL BLOCK - PART 1\n\n      What do most of us work on?  Often the answer is: \"what needs\nfixing\".  I once opened a service call to IBM Level 2.  We were having\ntrouble with a certain module.  The problem was a known problem, and\nthe technician gave me a clear answer to it.  Then I mentioned the\nname of another module to her.  She had never heard of that one, even\nthough it was closely related to the one which needed fixing.  I think\nthe reason why she had never heard of it, was because it hadn't been\nchanged in ten years.  I had heard of it, because I had fitted an\nenhancement zap to it.  There was no way an IBM technician could have\nknown about that zap.\n\n      The moral of the story is:  System components that don't have\nproblems, usually don't get people's attention.  This is why we have\nconversion notebooks.  When a new version of the operating system comes\nout, people want to know what has changed.  What still works, is often\nof no concern to them.  I really don't blame anyone for that attitude.\nThe operating system is so big, that most of us don't have time to care\nabout what is working properly.  Our job is to keep the computer center\nrunning.  The problems and changes alone will normally keep us busy\nenough.\n\n      This month, I'd like to focus on an operating system area which\nhas recently changed quite a bit, and therefore we have to adjust to\nthe consequences.  This is the topic of the UCB, or Unit Control Block.\nThe Unit Control Block describes a physical peripheral device, and\ncontains all the necessary information for the device to be used in\nperforming I/O requests.  On old systems, the UCB's used to be\nstatically generated during system generation, and the collection of\nUCB's, representing all peripheral devices known to the MVS system,\nwas a fixed block of storage in the Nucleus area.  With the recent\nintroduction of Dynamic I/O reconfigurations, Dynamic UCB's and\nfour-digit unit addresses (instead of three digits), some user\nprograms and tools which used to work, have stopped doing their job.\nTherefore they have to be fixed.  The question is, by whom?\n\n      We, who have maintained user-written code for years, have an\nanswer.  If a program was not written by IBM or by some other vendor,\nthere is no one \"official\" to call.  If the original source was on a\npublic tape, such as the CBT MVS Utilities Tape, or the NaSPA VIP\ntape, one can try and call the original author, or the proprietor of\nthe tape.  If possible, a user who considers this program important,\nshould fix it.  Then, that person can send the updated program to the\nproprietor of the public tape where the source is kept.  After the\ntape gets updated with the new source, everyone else will benefit from\nhaving a version of the program which now works.  In such a way, the\njob of fixing all the affected programs gets divided among a number of\npeople.\n\n      Today, I'd like to talk about what's involved in handling the\nDynamic UCB situation.  There are quite a few new topics, and it will\ntake two installments.  Also, several different types of code changes\nwill have to be discussed.  By the end, I hope you'll have a good feel\nfor what needs to be done, and we'll all have a better handle on\ngetting some of our old tools to work in this \"era of Dynamic UCBs\".\n\n\nFUNDAMENTALS.\n\n      IBM, in response to many customer suggestions, is trying to make\nmore system resources dynamically modifiable.  In our day and age,\nwhen numerous computer operations have to be up 24 hours a day, 7 days\na week, system \"down\" time for IPL's is very scarce.  For as many\nsystem parameters as possible, we'd like to employ an operator command\nto change them \"on the fly\", instead of requiring an IPL.\n\n      Internally, coding-wise, what is involved in such a change?  To\nexplain matters, I want to use a relatively simple example I happen to\nknow about.\n\n      The JES2 Remote Destination Table (or RDT) is a list of remote\nconnections in JES2, and it also includes destination addresses which\ncan be referred to by the DEST JCL parameter or a DEST keyword in a\nTSO command.  The RDT used to be modifiable only by a JES2 WARM start,\nwhich meant an IPL.  In JES2 version 4.1, the ability to add and\ndelete connection and destination addresses (with $ADD and $DELETE\ncommands) was introduced.  This involved the complete restructuring of\nthe physical layout of RDT table entries.\n\n      Formerly, the destination table entries were created in one big\nblock of storage at JES2 startup time.  The table was searched by\nstarting at the beginning of its storage, and bumping through it\nsequentially, entry by entry.  This can't work in a dynamic situation\nwhere you could add or delete new entries at will.  Where would there\nbe space to put an \"unlimited\" quantity of new table entries?\n\n      Now that the RDT was made dynamic, this is how it has been\nrestructured.  When a new RDT is built, a 4K block of storage is\nGETMAINed and marked with a header saying that this will be storage\nfor RDT table entries.  Header fields are created to show how full the\nblock of storage is.  Then the new table entries are built in this\nblock of storage and are all logically chained to each other,\nbeginning from the first entry.  To locate the beginning of the table,\nthe address of the first entry is put into a known JES2 control block\nwhen the table was initially created, usually at startup time.  Every\ntime we run out of storage for RDT entries, a new 4K block of storage\nis GETMAINed, headed, and filled with new entries chained from the\nprevious ones.\n\n      Since the $DELETE command is also supported, we sometimes have\na need to \"zero out\" some entries, re-chain the remaining ones to each\nother, and reuse the newly freed space.  In a large JES2 network, it\nmay come out that RDT table entries in a chain might jump from one 4K\nblock to another 4K block and back again, many times.  Clearly, a\nsequential search will not do the job any more, and old programs or\nJES2 exits which search the RDT that way, will no longer work.  The\nsearch algorithm must be rewritten to start at the first record, and\nthen follow the chain of record addresses until you find the entry\nthat you want.\n\n      I've used the RDT illustration to make things easier to see.  The\nUCB situation is more complicated and hidden, but most of its principles\nare similar.  JES2, which owns the RDT, has much of its source code\naccessible to us.  The base operating system code and IOS, which deal\nwith the UCB, have mostly OCO (Object Code Only) modules, and we can't\neasily observe what those components are actually doing.  To deal with\nUCB issues, IBM has provided us with Macro access to most of the\nservices.  Since these services have been changing between MVS\nreleases recently, the MVS Conversion Notebook manuals are an\nexcellent source for finding out what to do.\n\n\nUCB STRUCTURE CONSIDERATIONS.\n\n      There are two issues with which we have to deal here.  One is\nthe actual structure of the UCB, and how it is changing.  The other is\nhow to search for and obtain information from the particular UCB's\nwhich represent physical devices that we are interested in.\n\n      The mapping macro for a UCB is called IEFUCBOB, which is found\nin SYS1.MACLIB.  This macro will describe the structure of every type\nof UCB in detail.  Optionally, IEFUCBOB can limit itself to describing\nonly UCBs of a certain device type.  The allowable device types are:\nDASD (disk) devices, magnetic tape devices, unit record devices,\ncommunications equipment, CTC's, and graphics devices.\n\n      Serious UCB restructuring began at the MVS/ESA 4.1.0 level.  A\nprevious drastic change also occurred at the time MVS/XA was first\nintroduced.  Therefore, it is worth discussing how an assembler\nprogram can determine the system level it is operating under.  The CVT\n(Communications Vector Table) which is the backbone of MVS control\nblocks, contains an old field, CVTDCB, which is used to determine the\nlevel of OS that is running.  In addition, at the ESA levels and (in\nfuture) above, there is another field called CVTOSLVL, which reserves\nno less than 16 bytes of bit flags, so that IBM will \"never in the\nfuture\" have any trouble telling you which level of the operating\nsystem is currently operating.\n\n      For an MVS/XA system, the CVTDCB field is set to X'93'.  For an\nMVS/ESA system, CVTDCB is set to X'9B'.  The extra bit X'08' indicates\nthat the CVTOSLVL area is present and may be referenced.  See the CVT\nmapping macro in SYS1.MACLIB at your system's level for further details.\nIf you are on an MVS/ESA system, the X'08' bit called CVTUCBSV in flag\nCVTOSLV0, indicating system level HBB4410 or above, will show that the\nnew UCB macro services are now available and ready for use.\n\n      The actual structure of the UCB storage area(s) is determined by\nwhether MVSCP is used to create the I/O configuration of the system,\nor HCD and IODF are.  MVSCP is the old way.  HCD, the Hardware\nConfiguration Dialog, which is used to build an I/O Definition File\nor IODF, is the new way.  At the MVS/ESA Version 5 level, you don't\nhave a choice any more.  MVSCP no longer works, and you have to use HCD.\n\n      If MVSCP is used to define the I/O configuration, then the UCB's\nreside in member IOSUCBxx of SYS1.NUCLEUS, where xx is the identifier\nof the designated I/O configuration.  The UCB's are created and\ninitialized by the MVSCP and are loaded into the Nucleus region\n(below the 16 Meg line) during IPL.  If HCD is used to build an IODF to\nrepresent the I/O configuration, then the UCB's are built in SQA during\nthe IPL.  In this latter case, they do not have to be contiguous, and\neverything we said before about dynamically modifiable control block\nchains, can now apply.\n\n      The UCB itself consists of a prefix, a Common Segment, and\nvarious device-dependent segments.  There are also various extensions\nnowadays.  In the older systems, the UCB segments were physically\ncontiguous, but IBM no longer guarantees that.  It is for such\nreasons, that the only recommended way of searching and scanning UCB's\nis through the IBM-supplied macro services.\n\n\nUCB SEARCHING AND SCANNING.\n\n      We'll conclude this installment with an overview of some new UCB\nsearching and scanning services.  This will deal with the issue of how\nto find the UCB's you want, even in this new environment, when some or\nall of the UCB's may be dynamic.  Next time, we hope to show more of\nthe details of how to convert existing programs to use the new scanning\nand searching methods.\n\n      Two principal macros which concern us are UCBLOOK and UCBSCAN,\nboth of which may be found in SYS1.MACLIB.  UCBLOOK is used to obtain\nthe UCB common segment address of a given device number or a given\nvolume serial.  UCBSCAN is used to scan UCB's.  The following types\nof scans are supported:  All UCB's, or all UCB's within a particular\ndevice class.  Remember that we spoke about device classes before.\nThey may be, for example, DASD devices, tape devices, unit record\ndevices, and the like.  In a given UCB scan, we may restrict the scan\nfurther.  Permissible restrictions are:  Only report static\n(non-dynamic) UCB's, only report 3-digit device addresses (excluding\nthe new 4-digit addresses), specify the device number from which\nthe scan should begin.\n\n      In the dynamic UCB environment, there are several more concepts\nwhich need mentioning.  If we're looking at a UCB, what can we do to\nprevent it from disappearing during an I/O configuration change?\nSecondly, if we are in the middle of conducting a UCB scan operation,\nhow can we detect that an I/O configuration change has been started,\npotentially upsetting and invalidating much of what we're looking at?\n\n      In answer to the first question, the concept of fixing or\n\"pinning\" the UCB was invented.  The UCBLOOK macro has the capability\nof optionally pinning the UCB, or preventing its deletion if we're\nlooking at it during a configuration change.  There is another macro\nwhich is specific to this purpose, called UCBPIN.  The UCBPIN macro,\nalso in SYS1.MACLIB, can be used either to pin or \"unpin\" a UCB when\nit needs to be fixed or freed.  Any system component can pin a UCB.\nIn order for a pinned UCB to be freed, it must be specifically\nunpinned, using the UCBPIN macro.\n\n      In answer to the second question, the concept of an IOC Token\nwas invented.  This token seems to be essentially a \"configuration\nchange identification number\".  The current I/O configuration's token\nmay be discovered through the IOCINFO service, which is invoked by the\nIOCINFO macro.\n\n      Both the UCBLOOK and UCBSCAN macros may be invoked using the\nIOCTOKEN keyword.  This allows the UCB lookup or scan to verify that\na configuration change has not occurred recently.  We first obtain the\ncurrent I/O configuration's token using the IOCINFO macro, which returns\nthe token value into a 48-byte storage field, obtained for our program's\nuse.  Then, the UCBLOOK or UCBSCAN IOCTOKEN keyword is pointed to this\ntoken field.  If UCBSCAN gets a return code of 12 in Register 15, this\nis an indicator that a configuration change has occurred.\n\n      So far, we have discussed many of the new concepts involved in\nthe recent UCB changes.  The picture is by no means complete as yet,\nbut this much is probably enough for one sitting.  Next time, I hope\nto continue this topic with more practical application.  Good luck.\nWe'll see you then.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9601JA": {"ttr": 14849, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x953\\x1f\\x01\\x00)\\x9f\\x11G\\x01_\\x01_\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1995-11-27T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 351, "newlines": 351, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          January 1996\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\nSam Golob is a Senior Systems Programmer working\nin New York City.\n\n\nKEEPING UP WITH THE UNIT CONTROL BLOCK - PART 2\n\n      It's hard to believe that this column is entering its eighth\nyear.  Time flies when you're having fun!\n\n      This month, we'll continue last month's topic, which is an\nattempt to keep up with IBM's changes concering the UCB, or Unit\nControl Block.  As we recall from last month, the UCB is the control\nblock required to define an I/O device to the MVS system.  The UCB\ncontains almost all the information necessary for the device to be\nused in performing I/O requests.  (A few device characteristics are\nstored elsewhere, but they are of minimal value.)  It also records the\nstatus of a physical I/O device as represented by a subchannel.  With\nthe advent of dynamic device reconfiguration, internals of the UCB\narrangement in storage have had to change, and UCB searching methods\nhave had to be modified.  Therefore, user programs and exits which\naccess UCB's need to get their act together in order to keep up with\nthis restructuring.  Many of these programs have stopped functioning\nproperly in the new environment, and they have to be fixed.\n\n      One good place to find information from IBM manuals, especially\nconcerning matters that we dealt with last time, is Chapter 23 of the\n\"MVS Authorized Assembler Programming Guide\", which talks about\n\"Accessing UCB's\".  Another manual is the \"Planning, Installation,\nand Migration\" manual for MVS Version 5.  Our purpose today is not to\nrehash the information in these manuals, but rather to provide an\nincreased understanding of some of the internal processes involved.\nBy so doing, the ultimate result will be that you'll be better able\nto fix your own programs, and you'll surely get a deeper view of the\nwhole situation.\n\n      IBM software planners have given us macro interfacing methods to\nuse in this new UCB environment.  We now have to invoke certain IBM\nAssembler macros such as UCBLOOK, UCBSCAN, IOCINFO, and EDTINFO.  No\nlonger can we start at the beginning of the big block of UCB's in the\nnucleus area and chain through them in order.  Instead, we have to use\nthis collection of macro interfaces.  The reason is because the system\ncan now add and subtract UCB's dynamically.  A valid UCB can actually\ndisappear.  Yet, all the currently valid UCB's must still be\nsearchable somehow.  These macros are now the only supported IBM\nsearch method.\n\n      There is one other fact to note.  UCB's have \"segments\" and\n\"extensions\" of various types.  The main part of the UCB is called the\n\"UCB Common Segment\".  The other segments and \"UCB extensions\" can be\nreached in various ways, once we have access to the UCB Common\nSegment.  Looking at the macro IEFUCBOB from SYS1.MACLIB, will give\nyou a lot of specific help.  Our discussion will only concern how to\naccess the UCB Common Segment.  In the old days, other segments that\nexisted used to mostly be contiguous in storage with the UCB Common\nSegment.  Nowadays, the other segments and extensions usually are\nnowhere near the location of the Common Segment.  This is another\nreason why our search methods have to be different.\n\n      With the help of my friend Gilbert Saint-flour, I have discovered\na few of the undocumented internals of how UCB searches now work.  I\ncannot recommend their direct use, because IBM reserves the right to\nchange the interface.  Nevertheless I feel that a knowledge of these\nmechanisms is instructive and illuminating, and we can profit greatly\nfrom seeing more of how the UCB searches are actually happening.\n\n\nTHE UCB LOOKUP TABLE (OR ULUT)\n\n      Back in the MVS/370 days, UCB's were scanned using a \"lookup\ntable\".  This was a sequentially read table which (eventually) pointed\nto all the UCB's in the system, as you went through it.  When MVS/XA\ncame around, completely changing the \"channel, path, device\" scheme of\ndevice addressing, the proper UCB scanning method became a call to a\nroutine, pointed to by an address in the CVT, CVTUCBSC.  This method\nmight still work for \"static\" UCB's, but its effectiveness is no longer\nto be relied on.  Now, to implement dynamic UCB's, IBM has again\nreverted to a modified version of the \"lookup table\" arrangement.  IBM\nhas hidden this arrangement from public view, calling it through the\nuse of the UCBSCAN macro, but the guts of a UCB lookup is built on\nthis table.  Every time a dynamic device reconfiguation is done, the\nUCB Lookup Table (or ULUT) gets rebuilt.\n\n      On MVS/ESA systems from release 4.1 through at least release\n5.2, the UCB Lookup Table or ULUT can be found in the following way.\nFrom the CVT (Communications Vector Table), which is the anchor for\nMVS control blocks, one looks at the contents of field CVTIXAVL at\nX'7C' from the beginning of the CVT.  This field points to the address\nof the the IO Supervisor's Communication Area (IOCOM).  The address at\ndisplacement X'D0' from the beginning of the IOCOM points to the IOS\nVector Table, or IOVT.  Finally, the address at 8 bytes from the\nbeginning of the IOVT points to the ULUT.  You can use a core-browsing\nprogram such as LOOK, from File 261 of the public domain CBT MVS\nUtilities Tape, to actually see what all this storage looks like.  The\nCBT Tape, with all its many tools, can be obtained through the NaSPA\noffice.  See Figure 1 for a \"LOOK\" at the beginning of the ULUT.\n\n      The actual ULUT has two parts: its header section, and the\nactual UCB lookup table entries.  See Figure 2 for an attempt at a\nDSECT description of the ULUT.  Remember that this is an undocumented\ninterface.\n\n      Gilbert Saint-flour, who wrote the encyclopedic SHOWMVS TSO\ncommand which is on File 183 of the CBT MVS Tape, uncovered many\ndetails of the ULUT's structure.  Gilbert has written actual code to\nuse this interface, in his SHOWMVS command.  Part of the \"UCB\" output\nfrom Gilbert's code is shown in Figure 3.\n\n      SHOWMVS was designed to display, under ISPF or in batch, as much\ninformation about your MVS system as possible.  As such, SHOWMVS is an\nexcellent Auditor or System Programmer tool.  Besides its 30-or-so\nother displays, its UCB display shows all online devices in each device\nclass, who has a dataset most recently allocated on the device, and SMS\ninformation, if the device is SMS-managed.  SHOWMVS, while running under\nISPF, will initiate a subtask that constantly tries to keep all the\ndisplays up-to-date.  Because of this, for the UCB display, actual UCB\naddresses are needed to obtain current information--UCB copies will not\ndo.  Therefore, Gilbert could not employ the standard UCBSCAN interface,\nwhich for un-authorized programs, will only return a copy of the UCB\nand not the real one.  Gilbert needed to supply the address of the real\nUCB, in an un-authorized environment.\n\n      The ULUT 12-byte table entries may be read sequentially by any\nprogram.  They consist of a halfword hex device address, a halfword of\nflags, where the X'4000' bit (indicating a dynamic UCB) is the only\none currently used, a halfword sequence number, and an unused halfword.\nThen follows the real UCB common segment address.  The last entry of\nthe table is marked by zeros in the sequence number field.  Or it can\nbe calculated by \"length\" information that is found in the ULUT header.\nGilbert employs the latter method in SHOWMVS.\n\n      I hope that this technical glimpse will enlighten you and arouse\nyour curiosity.  SHOWMVS source code, including all the methods it uses\nto obtain system information, is public-domain and one can learn much\nfrom it.  This code, among Gilbert's other good things, may be found on\nFile 183 of the CBT MVS Tape, as we said before.  Now we'll finish our\ndiscussion with some program conversion hints.\n\n\nFIXING EXISTING USER PROGRAMS.\n\n      IBM has classified UCB search methods into two classes:  limited\nmethods and general methods.  The idea is that the \"limited\" methods\ncannot be used to find dynamic UCB's, but only statically defined\nUCB's.  The \"general\" methods, which are the newer ones, supposedly\ncan be used to find all defined UCB's, optionally including 4-byte\nunit addresses and dynamically defined UCB's.  I might add to this\nclassificaton, that I think there are some older UCB finding methods\nwhich no longer work at all.\n\n      In Chapter 23 of the \"Authorized Assembler Programming Guide\"\nmanual, the limited methods mentioned are the IOSLOOK macro for\nfinding a single UCB, and the UCB scan SERVICE for scanning multiple\nUCB's.  The UCB scan SERVICE is reached from the CVT at displacement\nX'434'.  This points to the entry point address of the routine\nIOSVSUCB.  Programs using these methods (you can see what they're\ndoing by looking at their source code) should be converted to use the\nUCBLOOK macro to find single UCB's, and the UCBSCAN MACRO to do a\ncomprehensive search.  As we said before, the UCBSCAN MACRO has a\nlimitation for non-authorized programs, that it will only return a copy\nof the UCB, and not the address of the actual UCB.\n\n      For programs which find units by generic or esoteric unit names\n(see MVS/SP System Modifications, Chapter 6), the old way (XA and\nabove) was to use the Unit Verification Service, module IEFEB4UV,\nwhich has 11 different function calls.  IBM has provided the macro\nEDTINFO to supposedly replace this service, but the function calls in\nthe EDTINFO macro do not match exactly the old calls that were\npossible with the IEFEB4UV routine.  For some of the calls, a certain\namount of ingenuity will be necessary if EDTINFO is to obtain the\nsame effect.\n\n      An example of a program needing this kind of conversion is the\nUNITS command from File 360 of the CBT MVS Tape.  UNITS is a TSO\ncommand which will either return all defined generic and esoteric unit\nnames alone (this part still works), or it will also return all the\nunit addresses together with each generic name.  This latter part\ndoesn't work properly any more, because IEFEB4UV can't find any dynamic\nUCB's.  IEFEB4UV comes up empty when asked to display a list of unit\naddresses for a given unit name, if they were all defined as dynamic.\n\n      I haven't fixed the UNITS command as yet.  When it gets fixed,\nI'll try and share it with you.  If you fix something, please send it\nin to the CBT Tape submission address, so you can share it with\neveryone too.  That's how this work gets divided, and everybody\nbenefits because no one individual alone has to do too much of the\ntotal job.\n\n      I'd like to close with a general comment about IBM publications.\nYou'll need them to get more help, on this and other topics.  IBM,\nbeing one of the largest publishers in the world, would much rather\nsell you manuals on CD ROM than on paper.  If you have to research a\ncertain topic, such as our topic of UCB lookups, it is much easier to\ndo so when you have all the manuals at hand on your PC.  The MVS\nOmnibus Collection, available through your IBM representative, has all\nthe MVS manuals you'll ever need.  And the Rainbow Collection has all\nthe \"Red Books\" and \"Yellow Books\" etcetera, from all the Systems\nCenters.  Get set up with them, and you'll be much more able to deal\nwith any problem.\n\n      We've got to go now.  I hope this has been enlightening in some\nuseful way.  We'll see you next month.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   This is a glimpse at the beginning of the UCB Lookup\n            Table in storage, using the LOOK TSO command, which is\n            a core browser.  The LOOK command can be found on the\n            CBT MVS Utilities Tape, in File 261.  This picture\n            shows the ULUT header, as well as the beginning of the\n            table, which is located at address 0204541C.  The table\n            itself consists of 12-byte entries, the last fullword\n            of which is the actual UCB address.  For clarity I have\n            marked the beginning of each table entry with a comma.\n            This table is accessible to non-authorized programs,\n            and can be used to scan UCB's, obtaining the actual UCB\n            Common Segment address, and not a copy of the UCB.\n            This is better than the UCBSCAN service, but it is not\n            a documented interface.  The last entry in the table is\n            marked by a halfword of zeros in the sequence number\n            field.  For a description of record layouts in this\n            picture, see Figure 2.  To ensure validity, you have to\n            make sure that the IO Configuration has not changed.\n            For this you may use the IOCINFO macro from\n            SYS1.MACLIB, with the IOCTOKEN keyword.\n\n\n\nLOOK COMMAND - DISPLAY VIRTUAL MEMORY      DISPLAY ASID= 00BC\nENTER CMD -\nLAST CMD  - J+8\n\n02045398   >E4D3E4E3  01F50000  00000000  0204541C *>ULUT.5..........*\n020453A8    000009F1  000000B8  0000002C  000004D0  *...1............*\n020453B8    00000280  0000000D  00000000  000001B0  *................*\n020453C8    02190007  04F200E7  00010000  00270000  *.....2.X........*\n020453D8    00003BA0  00001DD0  00000EE8  00000774  *...........Y....*\n020453E8    000003C0  000001E0  000000F0  00000078  *...........0....*\n020453F8    0000003C  00000018  0000000C  0000000C  *................*\n02045408    00000000  00000000  00000000  00000000  *................*\n02045418    00000000 ,00014000  00020000  00EF2168  *...... .........*\n02045428   ,00024000  00030000  00EF21D8 ,00034000  *.. ........Q.. .*\n02045438    00040000  00EF2248 ,00044000  00050000  *.......... .....*\n02045448    00EF22B8 ,00054000  00060000  00EF2328  *...... .........*\n02045458   ,00064000  02120000  00EF2398 ,00104000  *.. ........... .*\n02045468    00080000  00EF2408 ,00114000  00090000  *.......... .....*\n02045478    00EF2478 ,00124000  000A0000  00EF24E8  *...... ........Y*\n02045488   ,00134000  000B0000  00EF2558 ,00144000  *.. ........... .*\n\n\n1= HELP      2=           3= END        4=           5= REPEAT  6=\n7= BACKWARD  8= FORWARD   9= HIST BWD  10= HIST FWD 11=        12=\n\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.   This figure shows you how to access the UCB Lookup\n            Table in storage, and it describes the ULUT header\n            and the table entries.  This description is courtesy\n            of Gilbert Saint-flour, and comes from the source\n            code of his SHOWMVS TSO command.\n\n\n\n* - -   Pointer from IOCOM to IOVT  - - - - - - - - - - - - - -\nIOCIOVTP EQU   IOCOM+X'0D0',4,C'A'     V(IOVT)\n*\n* - -   Description of the relevant parts of the IOVT   - - - -\nIOVT     DSECT                         IOS VECTOR TABLE          ESA41\n         DS    C'IOVT'\n         DS    H'384'                  LENGTH OF IOVT\n         DS    XL2\nIOVTULUT DS    V(ULUT)                 UCB LOOK-UP TABLE\n         DS    3F\nIOVTCDA  DS    V(CDA)                  CONFIG DATA AREA\n*\n* - -   X'84' Bytes  - - - - - Description of ULUT Header - - -\nULUT     DSECT                         UCB LOOK-UP TABLE         ESA41\n         DS    C'ULUT'\n         DS    X'01F5'                 ?\n         DS    XL2,XL4                 UNUSED\nULUTENTP DS    A(ULUENTRY)             FIRST LOOK-UP ENTRY\nULUTENTN DS    F                       TOTAL NUMBER OF LOOK-UP ENTRIES\nULUTTAPE DS    F                       NUMBER OF TAPE LOOK-UP ENTRIES\nULUTCOMM DS    F                       NUMBER OF COMM LOOK-UP ENTRIES\nULUTDASD DS    F                       NUMBER OF DASD LOOK-UP ENTRIES\nULUTDISP DS    F                       NUMBER OF DISP LOOK-UP ENTRIES\nULUTUREC DS    F                       NUMBER OF UREC LOOK-UP ENTRIES\nULUTCHAR DS    F                       NUMBER OF CHAR LOOK-UP ENTRIES\nULUTCTCA DS    F                       NUMBER OF CTCA LOOK-UP ENTRIES\n         ORG   ULUT+132\n* - -   12  Bytes  per entry - Description of ULUT Entries - - -\nULUENTRY DSECT                         UCB LOOK-UP ENTRY\nULUEDEVN DS    H                       DEVICE NUMBER\nULUEFLGS DS    X'4000'                 FLAGS\nULUEDYN   EQU  X'40'                   DYNAMIC UCB\nULUESEQN DS    X'0001',XL2             SEQNO\nULUEUCBP DS    V(UCBOB)                UCB ADDRESS\nULUELEN  EQU   *-ULUENTRY\n*\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 3.   This is a sample display of the UCB output from\n            the SHOWMVS TSO command.  The SHOWMVS command can\n            display its output using the ISPF BRIF (browse)\n            service, or it can go to a file.  SHOWMVS under ISPF\n            uses an ongoing subtask to update the screen with\n            current values every time ENTER is pressed.  The UCB\n            part of its display is designed to run un-authorized.\n\n\n\n DEVICE CLASS: TAPE\n\n   UNIT NAMES:      3490      3480      3400-5    CART      TAPE\n\n   UCBS:     32 (DEFINED)      2 (ON-LINE)\n\n     CUA  UCBTYP    UNITNAME  VOLSER  STATUS\n\n     391  78008080  3480       123456 PRIVATE J=NBQ0001B NOT-READY\n     480  78048081  3490              NOT-READY\n\n DEVICE CLASS: DASD\n\n   UNIT NAMES:      3390      3380      DISK      SYSDA      3350\n                    VIO       SYSALLDA\n\n   UCBS:    416 (DEFINED)     65 (ON-LINE)\n\n     CUA  UCBTYP    UNITNAME  VOLSER  STATUS\n\n     140  3050200B  3350      SYRESB  Resident Private\n     2C4  3030200E  3380K     STD008  SMS SG=STD3380  Enabled       85%\n     265  3030200F  3390-3    SYS430  Resident Private Allocated J=MYJOB\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9602FE": {"ttr": 14856, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x96\\x00O\\x01\\x00)\\x9f\\x11G\\x01W\\x01W\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1996-01-04T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 343, "newlines": 343, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         February 1996\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\nSam Golob is a Senior Systems Programmer working\nin New York City.\n\n\nEDIT AND SYSTEM RECOVERY.\n\n      My systems programming teacher Jeff Broido used to emphasize a\nfew principles.  A very important one was to invest a little bit of\ntime every day to learn new tools.  Jeff used to say that the time\nspent playing with the new stuff, will definitely be saved later.  You\nwill get paid back.  In my years of experience, I've found this to be\nvery true.  Most of us have a tendency to succumb to inertia at work.\nAfter a period of initial growth, we get to a point where we feel that\nif we got by yesterday, we can get by the same way today.  Jeff's\nfirst principle, if followed as a habit, will help overcome this\ninertia and force us to have a more sustained professional growth.\n\n      A second principle I learned from him, was always to have more\nthan one way to do any job.  In fact, the more ways you have, the\nbetter.  On the systems level, anything can break, and one needs to\nhave a way to recover from or circumvent such an occurrence.\n\n      My favorite war story about this second principle concerns\nICKDSF, the IBM utility which is used to initialize a disk pack.  One\nmight imagine that IBM would never allow an essential utility like\nICKDSF to break.  There are perhaps a few people in administrative\npositions who have a tendency to think like that.  I once found a way\nto \"clip\" a disk pack (i.e. change its volume serial name) without\nusing ICKDSF.  I used the public domain Fullscreen ZAP program with\nits FULLVOL keyword to do the rename directly to the disk id record\n(track 0 record 3).  A few months later, at a very critical time for\nus, ICKDSF did break, while MVS was running under VM.  There was\nnothing IBM could do for us on short notice.  ICKDSF under that\ncircumstance was completely unusable.  My little technique saved our\nwhole project, without causing any noticeable impact to the users.  It\nwas like having a second key to your car, after you'd locked the first\none inside.\n\n      Today's topic will lean heavily on these two principles.  Our\ncurrent subject is about how to edit crucial datasets under emergency\nconditions, helping you to recover your system.  This will prove to be\nvery useful knowledge in itself.  However, the mental approach which\ngave rise to this knowledge, comes directly from Jeff Broido's teaching:\nInvest some time every day to learn new tools.  And always look for more\nthan one way to do any job.  These general principles have wider\napplication than our specific \"tips and tricks for the day\".  In the\nlong run, it could be that you'll have even greater benefit from this\nmental approach than from the knowledge itself.  With that said, let's\ntalk about emergency editing and system recovery.\n\n\nEMERGENCY EDITING.  WHY?\n\n      Nowadays, I'd bet that most of us would think of the ISPF Editor\nwhen we think of editing a file.  It wasn't always so, as old-timers\nwill testify.  Once upon a time, all that was available under OS was\nthe line editor, called EDIT.  Amazingly, EDIT is still around, and it\nis still effectively supported by IBM.  From the MVT days, I remember\nthat we had an editing product which allowed us to type over anything\non a full screen.  It was called FSE or Full Screen Edit.  The version\nwe had then was a vendor product, but there is a similar version of FSE\nwhich runs on MVS and is free.  This version of FSE can be found on\nFile 207 of the CBT MVS Utilities Tape, an independently produced tape\nthat can be ordered through the NaSPA office.  From now on in this\ncolumn, when we talk about FSE, we'll mean the free MVS version from\nthe CBT Tape.\n\n      Following Jeff Broido's second principle, it pays to set up and\nlearn to use FSE for emergency purposes.  FSE consists of only eight\nsmall load modules, which you can assemble from source code.  I'm sure\nthat most shops can find a linklist library where these can be easily\nstowed away, to be ready if needed in an emergency.\n\n      A logical question is:  \"Why should we need to go to this\ntrouble?\"  Our practical answer:  Sometimes ISPF, and the ISPF editor,\ncan't be run.  We could then certainly use a substitute file editor.\n\n      Let's explain.  ISPF needs a whole bunch of datasets allocated\nto your TSO session in order to run.  DDNAMES required are:  ISPLLIB\nfor ISPF load libraries, ISPPLIB for panel libraries, ISPMLIB for\nmessage libraries, ISPSLIB for skeleton libraries, ISPTLIB for table\nlibraries, ISPPROF for the ISPF profile dataset, SYSPROC for CLISTs and\nREXX execs, and possibly others.  For most of these DDNAMES, if the\nconcatenation of datasets belonging to that DDNAME cannot be allocated,\nISPF won't work at all.  The ISPF editor will therefore be unusable.\n\n      Most of the time, these DDNAMES get allocated to your TSO\nsession either through JCL in your logon procedure, or with dynamic\nallocation under your logon CLIST or REXX exec.  If one dataset is\nmissing somewhere, and a DDNAME isn't allocated because of it, what\nhappens depends on the allocation method used.  If the allocation\nis in the JCL for the logon proc, the entire TSO session is dead.  If\nthe allocation was done dynamically through the logon CLIST or REXX\nafter the TSO session was started, only ISPF is dead.  Either way,\nyou still don't have the use of the ISPF editor.\n\n      Clearly, one can see from here, that your session is safer if\nmost of the datasets are allocated through a CLIST or REXX and not in\nthe logon proc JCL.  If you leave most of the allocations out of the\nJCL, doing them later through a CLIST or REXX exec, at least you'll\nstill have a TSO session to work with, after any of these allocations\nfail.  When the allocations from the logon proc fail, you don't even\nget in.  Your TSO session goes down with a JCL error, the same as a\nbatch job with a JCL error would.  It's far better to have a less\npowerful TSO session, than to have no session at all to work with.\n\n      Once you've taken the measures to start your TSO sessions using\na \"bare bones\" logon procedure with later CLIST or REXX dataset\nallocations, we can talk about exploiting FSE.  FSE will edit a\ndataset or a pds member with almost nothing being actually allocated\nto your TSO session.  FSE is SMALL and consists of a few load modules\nonly.  FSE doesn't need the numerous dataset allocations that ISPF\nneeds.  Therefore you'll be able to fix PARMLIB members, PROCs in\nSYS1.PROCLIB and other crucial system elements if you get a minimal\nTSO session going, having FSE available from a linklist library.\n\n      Everything we're saying about using FSE for emergency file\nediting also applies to using the IBM TSO line editor called EDIT.\nEDIT is a TSO command found in SYS1.CMDLIB, which is usually in the\nlink list.  Therefore, EDIT requires no additional dataset allocations.\nAlso, EDIT is available on almost every MVS system, and normally needs\nno additional setting up.  EDIT is just a bit tricky to use, and\nrequires some prior practice (maybe about an hour or two) in order\nfor the user to feel comfortable with it.\n\n      So one might ask the question:  Why do most of us feel helpless\nwhen ISPF isn't there?  The answer is simply that we have not invested\nsome time in preparing ourselves to use these other editing tools.\n\n\nGETTING STARTED WITH FSE.\n\n      FSE consists of eight load modules which can be assembled from\nsource code and link-edited to one of your linklist libraries.  To\ninvoke FSE from your TSO session, one need only enter the command:\nFSE 'dataset.name'  plus perhaps an optional keyword.  Full editing\nof a dataset or pds member can only be done if the dataset or member\nhas sequence numbers, although browsing (invoked by the LIST option)\ncan be done without any sequence numbers in the data.  During an\nemergency, this limitation is usually minor.  You're usually happy to\nbe able to fix the SYS1.PARMLIB or SYS1.PROCLIB member that is wrong.\nHowever, the TSO EDIT command, which is somewhat less convenient to\nuse than FSE, does not require sequence numbers in the data, although\nsequence numbers make the editing much easier.  We will talk about the\nEDIT command soon.\n\n      FSE is relatively simple to use, and its HELP member, which is\npartly shown in Figure 2, is quite short.  You can effectively exploit\nFSE with about 15 minutes of practice.  Although FSE is not crammed with\nsophisticated features, it gets the job done in a pinch, and is very\neasy to use and to learn.  With FSE, you'll be fixing broken data in\nminutes.\n\n\nTHE TSO EDIT COMMAND.\n\n      Once, (not so) many years ago, the TSO EDIT command was the only\navailable effective way for manipulating JCL, program source code, and\nCLISTs under TSO.  Jeff Broido, in a recent conversation, told me that\nwhen the SPF editor (the precursor to the ISPF editor) first came out,\npeople didn't want to use it.  They were familiar with the EDIT\ncommand, and they resisted learning something new.  What a reversal of\nroles to think that the former shop standard now has to be taught to\nprogrammers as an emergency editing tool!\n\n      Let's get started.  EDIT is easy to invoke, but once there, it's\na bit tricky to use correctly.  I'll try to mention some helpful hints\nto guide you on your way.  SYS1.HELP on every system, contains a HELP\nmember for the EDIT command.  If you print this member off, and have\nthe printed copy handy, you'll have a reference available for command\nsyntax.  That is very important in the absence of manuals.  If you can\nget access to them, the TSO/E Command Reference and the TSO/E User's\nGuide are the good manuals.  But the most important way to learn the\nEDIT command is to practice editing junk datasets and pds members.\n\n      EDIT is invoked as a TSO command in the form:\n\n        EDIT 'dataset.name' dataset-type process-type\n\nwhere \"dataset-type\" is a keyword expressing the data format of the\ndataset or member.  Examples of dataset type can be CNTL, COBOL, ASM,\nCLIST, DATA, GOFORT, PLI, TEXT, and some others.  \"Process-type\" tells\nEDIT the processing facts it needs to know.  Examples of process-type\nare NEW, OLD, NONUM (to edit a non-numbered dataset).  NEW tells EDIT\nto allocate a brand-new dataset; OLD tells EDIT to look for a dataset\nthat already exists.\n\n      Once you've invoked EDIT, you have to watch carefully for two\ndifferent things at all times.  First, you must always know where\nthe current line pointer is.  Second, you must always be aware of\nwhether you are in the INPUT mode or EDIT mode of operation.  INPUT\nmode treats everything typed in (including commands) as new file data.\nYou have to be especially watchful about this because it is easy to\ncorrupt your files by mistakenly INPUTting images of EDIT commands,\nwhich you'll have to delete later.\n\n      EDIT mode allows you to enter subcommands to correct or change\ndata that was already in the file.  When you are in EDIT mode, you\ncannot add additional data records, unless you COPY or MOVE existing\nrecords to another place.\n\n      Additionally, you must be aware if the dataset is numbered or\nnon-numbered (NONUM).  EDITing lines without sequence numbers is\nharder.  It is best to start practicing with a numbered dataset.\n\n      If you're editing a NEW dataset, you'll always enter in INPUT\nmode.  If you edit an existing dataset, you enter in EDIT mode.  The\ninitial prompt that you're in INPUT mode is the word, \"INPUT\".  The\ninitial prompt that you're in EDIT mode is the word, \"EDIT\".  INPUT\nmode treats everything you type, as data being inserted into a new\ndata record.  When ENTER is pressed in INPUT mode, and there is\nnon-null data on the line, that line becomes a record, and everything\ntyped afterward, goes onto a new line.  In this context, it's a bit\ndifficult to keep track of column alignment, unless you're used to it.\n\n      All these data records will be inserted after the record being\npointed to by the current line pointer.  EDIT, especially if you\ndon't have sequence numbers, will not automatically tell you where\nyour current line pointer is.  This is a tricky thing which confuses\nmost people who are new to EDIT.\n\n      You stay in INPUT mode until you enter a null line by pressing\nENTER on a new line without entering any data.  At this point, you'll\nbe prompted with the word, \"EDIT\", which tells you that you are now in\nEDIT mode and you can start entering subcommands.  Pressing ENTER in\nEDIT mode with no subcommand, will switch you to INPUT mode.  Pressing\nENTER in INPUT mode with no data, will switch you to EDIT mode.  Each\ntime you switch, you get the appropriate prompt.\n\n      The first subcommand you should learn is LIST.  LIST without any\noperands, will display the entire dataset or member on your tube, one\nscreen at a time.  At the completion of the display, the line pointer\nwill point to the last line of the dataset.  The next command is TOP,\nwhich points the line pointer to the top line of the dataset.  BOTTOM\npoints the line pointer to the bottom line of the dataset.  DOWN nn\nmoves the line pointer nn lines toward the bottom.  UP mm moves the\nline pointer mm lines toward the top.  LIST * , with no other operands,\nwill display the current line, and leave the line pointer where it is.\nLIST * 2 , will display 2 lines at the current line pointer, and will\nthen move the line pointer one line down.  LIST * 3, will show 3 lines\nand move the line pointer 2 lines down.  You have to play with this to\nget a feel for it.\n\n      Jeff Broido recommends that the very first time you go into EDIT\nmode, you should enter the subcommand, VERIFY ON or V ON.  VERIFY ON\nwill prompt you each time a CHANGE command has successfully substituted\none string for another.  Otherwise, you don't get notified, though you\nneed to do a LIST command anyway, to see what was done.\n\n      I don't have space to teach you how to use EDIT here and now.\nThe HELP members and manuals will assist you, but you have to practice\nadding and deleting lines, aligning each line to the proper column,\nchanging strings of data, and so forth.  Once you've done that, you\nshould feel quite confident about (carefully) fixing PARMLIB and PROCLIB\nmembers.  After having practiced with EDIT, you'll probably agree that\nFSE is much easier.\n\n      I hope you've had fun listening to me, and I hope you have more\nfun practicing with these editing tools.  Someday, this practice will\npay you back.  See you next month.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   A sample FSE (Full Screen Edit) screen, in the process\n            of editing a JCL member in a partitioned dataset.  This\n            editor falls far short of having the power of the ISPF\n            editor, but when ISPF will not come up, there is plenty\n            of power to fix what needs fixing.  This editor is free,\n            and it comes from File 207 of the CBT MVS Utilities Tape.\n\n\n\n==> PF                   ==>TOP OF DATA SET\n170131 //IEHINIT JOB (rest of JOB card goes here)\n170300 //*\n170400 //****************************************************//\n170500 //*   INITIALIZE STANDARD LABEL ON A TAPE            *//\n170600 //****************************************************//\n170700 //*\n170800 //LABEL1  EXEC PGM=IEHINITT\n170900 //SYSPRINT DD  SYSOUT=*\n171100 //T       DD UNIT=(CART,,DEFER),DCB=TRTCH=NOCOMP,DSN=SBGHIT.INITT\n171235 //SYSIN    DD  *\n171335 T INITT SER=ABCDEF,OWNER='SAMGOLOB',DISP=UNLOAD\n173000 /*\n174000 //\n\n\n\n\n\n\n\nCOL 1  \u00a6---\u00a6----\u00a6----\u00a6----\u00a6----\u00a6----\u00a6----\u00a6----\u00a6----\u00a6----\u00a6----\u00a6----\u00a6----\u00a6----\u00a6--\n\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.   Abridged HELP for the FSE (Full Screen Editor) native TSO\n            command.  This is a simple but capable file editor that\n            doesn't take up much room or resources.  FSE is not related\n            to ISPF and doesn't need ISPF at all.  In an emergency when\n            ISPF does not come up and the ISPF editor is not usable,\n            editing a dataset from SYS1.PARMLIB or SYS1.PROCLIB with\n            FSE can save the day.\n\n\n\n)S SUBCOMMANDS -\n  TOP,BOTTOM,PF,PB,HF,HB,FIND,DSN,AUTOSAVE,DELETE,UP,DOWN,INSERT,\n  COLUMN,CHANGE,COPY,MOVE,SAVE,SAVEEND,END,RENUM,DONE,SUBMIT,PFK\n\n)F FUNCTION -\n  THE FSE COMMAND IS USED TO CREATE OR MODIFY SEQUENTIAL DATA SETS,\n  MEMBERS OF PARTITIONED DATA SETS OR THE BROWSING BACK AND FORTH\n  OF UN-NUMBERED DATA SETS (DUMPS ETC..). IT ALLOWS THE SIMULTANEOUS\n  UPDATE OF UP TO 21 LINES ON A CRT TERMINAL AND THE EXECUTION\n  OF AN FSE SUBCOMMAND OR TSO COMMAND AT THE SAME TIME.\n\n)X SYNTAX -\n         FSE    'DSNAME'  NEW/OLD  LIST/NOLIST\n                CLIST/DATA/CNTL/ASM/PLI/COBOL\n  REQUIRED - 'DSNAME' & BLANKS SEPARATING KEYWORDS\n  DEFAULTS - OLD,NOLIST\n  ALIAS    - NONE\n  NOTE     - THE DATA SET MUST HAVE VALID LINE NUMBERS IN ASCENDING\n             ORDER NOT EXCEEDING 999999, ELSE USER WILL BE ASKED TO\n             EITHER RENUMBER IT OR END FSE SESSION.\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9603MA": {"ttr": 15108, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x96\\x03\\x0f\\x01\\x00)\\x9f\\x11G\\x00\\xc2\\x00\\xc2\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1996-01-30T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 194, "newlines": 194, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          March 1996\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\nSam Golob is a Senior Systems Programmer working\nin New York City.\n\n\nYOUR OWN WORLD OF EDIT MACROS.\n\n      Today's discussion is like last month's, but with an opposite\ntwist.  Last time, we talked about resurrecting ancient MVS editors to\nhelp us in times of emergency, when the ISPF editor won't work.  Now,\nwe're going to talk about boosting the power of the ISPF editor\nitself.  What is the connection between these apparently opposite\ntopics?  True, both topics deal with the process of editing files.\nBut in the first case, we appear to be going back in time.  In the\nsecond, our \"equipment\" is very modern and up-to-date.  Actually, the\ntrue parallel between these topics is inside of you, in how your own\nmental processes work.\n\n      In our field (as in life), the name of the game is to grow.  In\nhis Foreword to Bill Mosteller's wonderful book, \"Systems Programmmer's\nProblem Solver\" (from QED Information Sciences, Wellesley, Mass.), the\nseries editor Gerald Weinberg has likened a systems programmer's job\ndescription to that of a goalie in soccer.  Most of the time, the\ngoalie is watching the ebb and flow of the game, hoping that the action\ndoesn't come too nearby.  On the other hand, the goalie is constantly\nworrying about contingencies.  Can the ball take a tricky bounce into\nthe goal under some strange conditions?  We sysprogs are also busy\nworrying about possible system bugs and loopholes.  When we are setting\nup new systems, as well as while we maintain older ones, we are always\ntrying to anticipate and circumvent possible sources of trouble.  The\nmore experience we have, the more educated are our guesses, and the\nbetter we are able do this.\n\n      This process of growth extends to accumulating more tools and\ntechniques.  My own systems programming teacher, Jeff Broido, always\nused to hammer away with the two pieces of advice I mentioned last\nmonth:  Number one, invest some time every day to learn something\nnew--it will pay you back later in saved time when you're short of\ntime.  Number two, always try to find more than one way to do any\njob.  If the usual way won't work, one of the others might work.  My\nexperience has shown that these two principles are worth their weight\nin solid gold.\n\n      Our current topic, ISPF Edit Macros, provides an opportunity\nfor almost unlimited personal growth in technique.  The ISPF edit\nmacro facilities are so extensive that a person's expertise in this\narea might almost constitute a sub-specialty.  Today, I'd like to\nmention the work of one such expert, my friend Paul Davis, who has\nchosen to share many of his clever and useful Edit Macros with the\npublic.  Some of Paul Davis' work can be found on Files 095 and 251 of\nthe CBT MVS Utilities Tape, an independently produced MVS software\ncollection that can be ordered through the NaSPA office.  Before\nlooking at specific examples of Paul's work, I'd like to talk about\nISPF Edit Macros in general.\n\n\nA SHORT GUIDE TO EDIT MACROS.\n\n      The Edit Macro facility was introduced into ISPF rather recently,\nwith ISPF Version 2.  Another IBM product, the CMS editor XEDIT which\nruns under VM, was equipped with a similar facility already.  I think\nthat IBM has a tendency once in a while, to pick up the good features\nof one product, and implement them also in other products, often in the\npresence of some customer demand.\n\n      The idea of an Edit Macro is similar to that of a CLIST, which\nreally stands for \"Command List\".  In other words, an Edit Macro is a\nlist of commands.  The difference is that a general CLIST is intended\nto run under native TSO, whereas an Edit Macro is designed to \"do its\nthing\" specifically when you are in an ISPF EDIT session.  However,\nEdit Macros are similar to CLISTs in that they are stored together with\nthe CLISTs in the SYSPROC or SYSEXEC library concatenations, nearly\nalways.  To complete our picture, we must add that there are also Edit\nMacros which can be written in programming languages such as Assembler\nor PL/I.  Those Edit Macros are more specifically called \"Program\nMacros\", and they are stored in your ISPLLIB concatenation of load\nmodules, or in STEPLIB or in the link list.\n\n      Before talking about more specifics, I want to mention that a\ngood place to learn about Edit Macros is from the IBM manual:\n\"ISPF/PDF Edit and Edit Macros\", which is quite thorough and helpful.\nYou'll find a lot of instruction and specific details there.  I would\ndefinitely say that this manual will help you learn to write Edit\nMacros.  Paul Davis told me that he uses this manual a lot for reference\npurposes, but he also has looked for suggestions and examples in other\npeople's files throughout the CBT MVS Tape.  If somebody has one bright\nidea, it is possible that it can be innovatively reused in some new\nproductive way.\n\n      Our present discussion, for the sake of simplicity, will talk\nmostly about Edit Macros that are in the form of CLISTs, as opposed to\nREXX execs or program macros.  Most of Paul Davis' Edit Macros are\nwritten as CLISTs, and we will want to spend some time describing his\nwork.  So let's get started.  An Edit Macro is distinguished from an\nordinary CLIST by the fact that its first statement is \"ISREDIT MACRO\".\nAfter this initial statement, we often see other ISREDIT statements and\nISPEXEC statements in Edit Macros.  ISREDIT statements interface with\nthe ISPF Editor to do editing operations, whereas ISPEXEC statements\ninterface with ISPF services in general.  Furthermore, all of the\nCLIST logic services are also available for use.\n\n      Since an Edit Macro is invoked while we are editing a dataset,\nits action often works on that same dataset, but not always.  ISPF\nlibrary management services are available, and can be called through\n\"ISPEXEC LMINIT\" and similar statements.  These services can access any\nmember in the current pds or another dataset, and various actions may\nbe performed on that other dataset.  It is actually possible, through\nthe use of Edit Macros, to use an ISPF edit session as a \"window\" in\nobtaining some very far-reaching results.  However, many of the things\nwe will want to do are ordinary manipulations with the current dataset\nthat is being edited, and their primary purpose is to save us time.\n\n      For example, suppose you need to convert the entire dataset\nyou're editing, to lowercase.  Paul Davis has an Edit Macro (from CBT\nTape File 095) called LCASEC to do this in one fell swoop, and the\nlogic is quite straightforward.  First he executes ISREDIT CAPS OFF\nto allow lowercase editing of lines.  Then he issues ISREDIT HEX ON\nVERT to put the edit session into HEX mode.  Then he issues a series\nof ISREDIT CHANGE ALL commands to change (in Hex) all occurrences of\neach letter to its lowercase equivalent.  Now he has to clean up.  He\nissues an ISREDIT HEX OFF to convert the session back to EBCDIC mode,\nhe sets the strings in his \"completion messages\" and displays them to\nthe edit session, issues an ISREDIT RESET CHG to clear out the \"CHG\"\nmessages, and positions back to the top of the dataset.\n\n      This is all quite easy and you can do it too, without very much\npractice.  Something that's harder, is a macro called FIXJCL.  The\npurpose of this macro is to tidy up and align the JCL dataset that\nyou're currently editing.  All you have to do is to type the command\n\"FIXJCL\" on the command line and press ENTER.  The command does the\nrest.  All the complicated editing rearrangements are pre-programmed\ninto the command, and you have almost no work to do yourself.  Your JCL\nmember gets neatly rearranged almost instantly, and all that is left,\nis to eyeball the result to check that no JCL mistakes were introduced\nby the macro's programming.  On the other hand, if you want to learn,\nyou can study this edit macro yourself and understand how the work gets\ndone.  Step-by-step, this macro processes your JCL member with various\nediting techniques, until the ultimate result is produced.\n\n\nA FEW MORE OF PAUL DAVIS' CREATIONS.\n\n      I recently asked Paul Davis which were some of his own favorite\nEdit Macros from his collections.  I'll mention a few of them now.\nOne handy macro is called BUPMEM (from File 251).  BUPMEM is used\nwhile editing a SYS1.PARMLIB member.  BUPMEM has no parameters, but it\ninstantly makes two backup copies of the member to be changed.  If\nXXXXXXXX is the member that is being edited, then BUPMEM's two copies\nare called XXXXXXB1 and XXXXXXB2.  If XXXXXXB1 already exists, it is\nrenamed to XXXXXXB2 (replacing any old member by that name) and the\noriginal member is copied to XXXXXXB1.  All ISPF statistics are\npreserved by BUPMEM.  You can see that BUPMEM is a very quick and handy\nspecialized tool for this work.\n\n      A simple and very useful macro is called FC (Find Line Command)\nwhich is on File 095.  \"FC N\" positions you to the next pending edit\nline command.  \"FC P\" positions you to the previous such command.  FC\nis very nice to have when you can't find where you entered your last\nunpaired \"CC\" or \"MM\" command, if it is a few hundred lines away.\n\n      The newer WCUT and WPASTE macros from File 251 are an extension\nof the frequently-used CUT and PASTE edit macros which are now in common\nuse.  The difference is that WCUT does not just cut complete lines, to\nbe \"pasted\" into another dataset.  WCUT can cut a small box (rows and\ncolumns) of data from one dataset, and WPASTE will paste that box into\nanother dataset somewhere else.  This is a true \"window cut\" and\n\"window paste\" facility for ISPF.\n\n      A sophisticated macro in Paul's collection (File 095) was written\nto reformat paragraphs in a dataset.  It is called PARA.  PARA was\nwritten by Marvin Greg Berryhill, and it is a very involved and clever\npiece of work.  PARA can take a number of lines of raggedly arranged\ntext, and create a neatly formatted paragraph.  Under your direction,\nthe paragraphs can be long and skinny, short and fat, or any shape in\nbetween.  PARA can even create diamond-shaped paragraphs for unusual\neffect in a document.  All this is done with hardly any work on your\npart.  Without such help, you would be painstakingly arranging each\ntyped line on the page, to create the shape you wanted.  PARA also\neliminates the need to retype words you have already typed in.\n\n      I've run out of space for this month, but I hope this will get\nyou to add to your current collection of Edit Macros, and to write some\nof your own.  Edit Macros are wonderful time savers, especially when\nyou have enough of them.  Good luck in all of your work.  See you next\nmonth.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9604AP": {"ttr": 15112, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x96\\x06\\x0f\\x01\\x00)\\x9f\\x11G\\x01\\x19\\x01\\x19\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1996-02-29T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 281, "newlines": 281, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          April 1996\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\nSam Golob is a Senior Systems Programmer working\nin New York City.\n\n\nTHE PLACE OF FREE SOFTWARE IN TODAY'S MVS SHOP.\n\n      We've probably noticed that our profession is changing, and it's\ndebatable whether the change is for better or for worse.  Seemingly\ngone are the days when a systems programmer actually made modifications\nto the operating system, and coded in assembler language on a regular\nbasis.  The truth of the matter is that I know some systems programmers\nwho still code extensively in assembler, and who know very much about\nhow the MVS operating system works.  But by and large, on the strictly\nMVS side and excluding some of the newer specialties, such as LAN and\nclient server work, there is a tendency toward hiring less skilled\nsystems programmers who could more be termed \"installers\".  As part of\nthis trend, the responsibility for debugging is being thrown more to\nthe shoulders of the vendors, and less trouble shooting responsibility\nis being given to the systems programming staff.\n\n      Many myths accompany this trend, and today we're here to discuss\nsayings and thoughts which are true and false.  Or more accurately, they\nare more true in one environment and less true in another.  My hope is\nthat this debate will focus our thoughts more clearly on activities\nwhich will be beneficial both to our shops and ourselves.  We should\nproactively watch and shape the trends that are happening in our work\nplaces, rather than passively allow them to erode and degrade the\nenvironment we work in.\n\n      Our first task in this matter is to try and discern the overall\nforces at work which are affecting us.  Then, we can attempt to find\nideas and policies that can help us to adjust, while maintaining our\nconsiderable skills and our usefulness to the installation at the same\ntime.  Newer people who are more highly affected by these changes can\nuse this knowledge to plan their careers and get better experience.\n\n      I guess we can call the first force, the \"vendorization of\nsoftware\".  We can call the second force, \"reduction and reshaping of\nour employment slots\".  In this discussion, I think that the first force\nweighs more heavily, so we will talk about that.  Let's take a look now\nat what \"vendorization of software\" means.\n\n      It used to be that when a shop needed some functionality, their\nsystem programmers would write it themselves.  The OS and MVS\noperating systems in the past were not so well developed and \"feature\npacked\" as they are now.  Also, there was not so much vendor activity\nwhich filled our needs.  Therefore, we had to do much of the work\nourselves, and IBM (to their credit) gave us the leeway to do it.  We\nhad microfiche listings of operating system modules and logic manuals\nto show us how the different functional parts worked.  Many user\ngroups in addition to SHARE and GUIDE helped us to spread \"user\nknowledge\" of the system and make it more commonly known.\n\n      This has changed with greater \"programming perfection\" in the\nMVS operating system and the incorporation of many more features into\nthe MVS system itself (data management being included).  Parallel to\nthat, there has also been an enormous proliferation of vendor software\nwriting activity.  Functionality that formerly had to be \"custom built\"\ncan now be \"bought off the shelf\".  Although there are advantages to\nthis change:  new releases of software can be more easily migrated\nto, and the compatibility problems between products have been shifted\nto the vendors, there is considerable fallout regarding personnel, and\nthe structure and morale of systems programming staffs.\n\n      \"Vendorization\" has tempted the management of some companies\nto scuttle the skill functions of their systems programming staffs\nentirely.  \"Installers\" get paid less than seasoned systems\nprogrammers who know how to code, diagnose, and fix software.  And as\ntheir older staff leaves, some installations feel they can get away\nwith hiring far less skilled \"replacements\" for them.\n\n      While there is some validity to this argument, there are also\nseveral flaws in it.  First, some really hard problems can occur once\nin a while, which could badly cripple a shop.  Often, this might happen\nwhen one vendor's product tramples part of another vendor's product.\nYou can't rely on the vendors in such a case, because each one will\npoint a finger at the other products, and neglect to face the part of\nthe problem which is truly theirs.  In such a situation, your highly\nskilled people will invariably grasp more of the picture, to \"cut\nthrough the fog\" in a small fraction of the time that the less skilled\npeople would take.  The money earned by the shop's production and\nreliability, will then easily outweigh the difference in the salaries.\n\n      Second and not so easily noticeable, are the morale problems in\nthe personnel.  The job isn't so interesting anymore.  And the new\npeople have far less opportunity and incentive to learn.  The vendors\n(including IBM) are covering up the guts of their products, and are\ngiving us \"black boxes\" to shuffle around.  Again, the more skilled\nprofessionals among us, who know how to code, can often read between\nthe lines, when a vendor changes a product.  They can figure out the\nkind of coding which the vendor had to do, to come up with such a\nresult.  On the other hand, the less experienced people have far less\nof an opportunity to learn, because they don't have the background to\nunderstand the internals from looking at the externals.  These people\ngenerally don't have a clue to how the internals work, at all.  For the\ninstallation, the result is less support, and less control.  For the\nemployees, there is far less stimulation and growth in knowledge.\nSystems programmers have historically been highly creative individuals,\nbut \"vendorization\" is causing this creativity to decline.\n\n\nHOW ACCESSIBLE SOFTWARE CAN COUNTERACT THIS TREND.\n\n      I call free (public domain) MVS software by a different name:\n\"accessible software\".  It is possible to contend that accessible\nsoftware has benefits and drawbacks, and we will try to make both of\nthese 2ore clear.  The idea is to help every shop and its employees to\nbenefit from a compromise.  People's attitudes can then be adjusted,\nand the place of accessible software in today's MVS shop will be better\nunderstood.\n\n      How can you get accessible software?  The \"granddaddy\" of free\nsoftware tapes is the CBT MVS Utilities Tape, which can be obtained\nthrough the NaSPA office.  The CBT Tape is a vast repository of a lot\nof other people's work.  There are highly complex utility packages on\nit, along with many systems programmer helpers of every description.\nNaSPA itself puts out its own public domain MVS VIP software tape,\nwhich has other goodies.  SHARE puts out a cumulative software CD ROM\nafter every SHARE meeting, twice a year.  On the CBT tape, there is a\ndescription of other tapes on File 001, and there is an index to the\ncontents of the other tapes on File 071.  This will give you a good\nstart in finding accessible software.\n\n      I myself can do all sorts of jobs with accessible software,\nwhich would be difficult even with vendor software.  For example,\nusing the Fullscreen Zap program from File 134 of the CBT MVS Tape, I\ncan look at a disk pack and examine the IPL text online, to see which\npacks have IPL text, and if it is the correct version.  With the free\n\"PDS\" product from File 182, I can expand the number of directory\nblocks in a pds in place, without reallocating the pds and copying the\nmembers.  \"PDS\" now has a successor vendor product called \"PdsTools\"\nfrom Serena International (Burlingame, California) which is much\nbetter, but either package can do some jobs that almost no other\nutility can do.  Changing the DCB attributes of an existing dataset (on\nthe fly) accurately, without opening and closing the dataset, is a\npiece of cake with the CDSCB TSO command from File 300 of the CBT Tape.\nAnd so on, almost forever.  By looking at the source code, you can\nlearn how all this is done.  Once you have the CBT Tape, you'll never\nbe able to complain that there was no place to learn how to write\nassembler code.\n\n      Accessible software has several obvious advantages.  First, your\nshop doesn't have to go through an elaborate and expensive acquisition\nprocess.  The stuff just has to be assembled, installed, and possibly\ncustomized a bit.  Then, it's there to be used.  Another advantage is\nthat the source code is available to learn from.  The code can be\nstudied as it is, but it is often accompanied by the phone number of\none or more authors, who can be called for help, although this service\nis not guaranteed, of course.  I personally have never gotten a\ndiscourteous response from any software author I have ever called for\nhelp.\n\n      The learning experience from accessible software is very very\nvaluable.  If you want to know how something was done, you can just\nlook at the code.  On many occasions, if I needed to access a control\nblock while I was writing an exit or another program, I would look at\na program from the CBT Tape which does a similar job, and obtain\nworking code.  The proximity to assembler source code which you get\nas an installer of these tools, affords an opportunity that is almost\nunparalleled nowadays, to hone your assembler language skills and\nadd to your knowledge of the MVS system.\n\n      What are the objections to accessible software?  One of them is\nthe supportability.  The argument is that you have to support the code\nforever, in your own shop.  I have several answers for this.  My friend\nBruce Bordonaro, who is a Systems Software Manager, told me that he\nadvocates a sort of compromise, as follows:  You can use the programs in\nyour own group.  Since it's internal, it is understood what the status\nof these tools is.  As far as giving them out to the public, it\ndepends.  If your shop has the technical expertise and management\ncommitment to continue support for a tool, then fine, give it out.\nOtherwise, it's probably best not to.\n\n      Another answer applies to a product like QUEUE, which is a JES2\nspool browsing program akin to SDSF.  Versions of QUEUE, a free\nproduct which is user-supported, are available on the CBT Tape for\nall versions of JES2 from 1.3.6 to 5.2.0.  JES3 users need not worry.\nThe free JES3 spool browsing program called SDF can be obtained for all\nrecent versions of JES3 through 5.2.  SDF is distributed on the JES3\nSHARE-GUIDE tape which can be obtained from Alan Field, 612-828-4979.\nThese products are needed by many shops.  Therefore the job of\nupgrading them from release to release is undertaken by knowledgeable\npeople who feel the need, and who do it for the public and for\nthemselves.  Although technically true, it's hard to make a statement\nthat such products are \"not supported\".  Practically speaking, they are\nsupported.\n\n      This process is aided by the proprietors of the various free\ntapes, who try and accumulate the updates as users fix things.  If your\nshop has upgraded some free tool to fit a later release of the\noperating system or some component, please send it in to the proprietor\nof a public tape, so the tape can be updated, and everyone will\nbenefit.  You can contact me through the NaSPA office for more\ninformation.\n\n\nSMALL SHOPS, LARGE SHOPS, AND INCENTIVES.\n\n      I once worked for a shop that had to resist something like eight\noutsourcing attempts in eight years.  In order to run our place on a\nlower budget than the vendors wanted to charge, we made enormous use of\naccessible software, which has the advantage that it is free.  We used\nTSSO (CBT Tape file 403) for console automation, and several other tools\nsuch as Dave Cole's automatic job scheduler (File 388) to assist in the\nprocess.  Many other tools were available for diagnosis purposes, such\nas the CMD1 subsystem (File 261) which provides multiple system-level\nservices, such as making non-cancelable started tasks cancelable, etc.\nAlthough we also bought vendor products, we only bought what we really\nneeded, with the extra peripheral functions being provided by free\nsoftware tools.  Because we were able to resist the outsourcing, all\nour jobs were saved, literally.\n\n      That was a relatively small shop.  Large shops have to buy more\nvendor software to help them with their larger workload.  But this does\nnot mean that systems programmers can't have handy tools which do\nnecessary jobs quickly, sometimes a lot quicker than the vendor\nproducts can.  Since many of these tools are used in a great number of\nshops, any problems generally get reported to the proprietors of the\nfree tapes where the tools are distributed, after they've been fixed by\na user.  Many \"standard\" tools from the CBT Tape are very reliable\nindeed, because a large number of people actually use them.  In the\ncase of larger shops, Bruce Bordonaro's advice is very much in order:\nFor internal Systems Support, use and learn from all the tools you need.\nIf there is management commitment and technical expertise in the shop\nto continue the support of a product, it is OK to give it out to the\nuser community.  If the commitment and expertise aren't there, it's\nprobably best not to.  The case of each tool should be considered on\nan individual basis.\n\n      This minimizes the risk involved.  A decently skilled systems\nprogrammer (armed with source code) generally can estimate how safe a\nproduct is.  For example, TAPEMAP (File 299 of the CBT Tape) tells\nyou what's on a tape, and it cannot do any damage, because all it does\nis read tapes and it cannot write.  Therefore, my friend Rick Fochtman,\nwho is very careful, gives TAPEMAP out to his user community on a\nnon-supported basis, and he gets a lot of \"thank you's\" from them.\n\n      Before closing, I have a few more thoughts.  One argument against\naccessible software, is that if you don't pay for something, you don't\nhave a contract, and therefore you don't have anyone to sue if something\nisn't right.  To this I answer:  Don't sue, fix the darn thing and avoid\nthe hassles.  Another answer, from Rick Fochtman, is that if you find,\nfor example, a copy program to substitute for IEBGENER which is better\nin some way, perhaps it produces record counts and runs faster, and the\nprogram doesn't work right, you can always go back to IEBGENER.\nLooking for a second way to do something better, when IBM provides a\n\"first\" way, always leaves you the guaranteed fall back to the old\nprogram.\n\n      One final thought is about systems programmer pride.  Systems\nprogrammers thrive on the thought that they've done something to save\nthe company money.  There is always the hope of a bonus or some direct\nreward.  But even if that isn't forthcoming, one realizes that when you\nhave the skills to save one company money, these skills will carry over\nto another company too, and they will make you more marketable.\nSomehow, accomplishment will pay you back.  One of the thrills of this\njob is the opportunity to find new ways to \"establish your worth\" to\nthe operation.  Companies should realize that systems programmers can\nimprove their computing efficiency, and this will reflect in the bottom\nline.  If you give your systems programmers the incentive to learn and\ngrow in the job, they will certainly save your company money in the\nlong run, because they are motivated to.\n\n      I know I haven't mentioned all the arguments on all sides of\nthese matters.  But in this attempt to lay out the substance of these\nissues which are on our minds, I hope to stimulate your thoughts and\nhelp you establish a better relationship between management and staff\non the subject of incentive to learn, personal growth, bottom-line\ncomputing efficiency, and staff morale.  Good luck.  See you next\nmonth.\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9605MY": {"ttr": 15361, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x96\\x08\\x9f\\x01\\x00)\\x9f\\x11G\\x00\\xdb\\x00\\xdb\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1996-03-29T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 219, "newlines": 219, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           May 1996\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\nSam Golob is a Senior Systems Programmer working\nin New York City.\n\n\nEYES - PART 1\n\n      I am of the opinion that Systems Programmers should learn about\nthe system from the system itself.  Documentation can be extremely\nhelpful for general knowledge and diagnosis, but the bottom line is\nalways to find out which bytes the system is \"looking at\".  In my old\ndays as an application programmer, I always wanted to look at the\nexact image of the actual data that my program was looking at.  With\nan application program, you can't accurately diagnose a problem unless\nyou see the data that the program was trying to read.  I think the\nprinciple is the same with the system itself, even though the\noperating system is far more complicated.\n\n      In dealing with the operating system, why don't people think this\nway?   Because they don't have the \"eyes\", or tools to see what is\nactually going on, and therefore they have to resort to guessing and\ndocumentation.  You may ask, what would most people do if they got the\neyes?  Probably, the smarter ones would learn to use them sooner, while\nothers would take longer in doing so.  Some might never learn.\n\n      It helps if the eyes, or tools, are manufactured by IBM.  Often,\nwhen an improvement is made to ISPF, many people eventually learn to\nuse it.  I've noticed this from looking over other people's shoulders\nwhile they were working.  Vendor tools, which are less standard, will\nacquire their following.  However, it might take longer for a high\npercentage of the programmers to start using their features heavily.\nIf an installation acquires a diagnosis tool, often they will send its\npotential users to a class.  Nowadays, with tight budgets, classes are\ngetting rarer, and the exploitation of a vendor's tool might take a\nlong time, or might never occur.\n\n      What if the eyes are free?  Last time, we discussed some of the\nmanagement aspects of this.  However, each systems programmer can\nacquire and learn to use such available tools.  It just takes ambition.\n\n      Today, we will look at examples of some free tools we can use as\neyes to see the operating system.  These tools can be used separately,\nin conjunction with each other, or together with vendor tools you have.\nOur aim is to encourage you in developing a growth to your \"visual\ntechnique\" so you can see what is going on, instead of having to guess.\n\n\nTYPES OF EYES.\n\n      We might say generally that any tool which displays some function\nof the operating system to us, might properly be called an \"eye\" to the\nsystem.  However, we need many types of \"eyes\".  A performance monitor,\nwhich exhibits many system functions, and the current status of jobs or\ntasks, is one type of eye.  A \"core browser\" or storage browser, is\nanother type of eye.  A JES2 or JES3 spool browser is a third type.\nA program such as \"Fullscreen ZAP\", which can examine the entire content\nof a disk pack, is a fourth type.  A multi-purpose tool-box to examine\nfiles or data, is a fifth type.  An EDP Auditor's tool is a sixth type.\nAnd there are other types of eyes in addition to these.\n\n      The usual work we need to do, in diagnosing some problem or in\nevaluating performance, generally involves the skilful use of several\ntypes of eyes in succession.  My friend Rick Fochtman phrased it very\nwell.  He told me:  \"The problem is knowing which eyes to select.\"\nWe'll start addressing this issue right now.\n\n      To begin, I do not wish to restrict our discussion to free tools,\nvendor tools, or IBM tools only.  Any tool you have, if you learn how\nto use its features, will help you see better.  I often write about\nfree tools, because they are available to everyone who tries to get\nthem, and one need not worry about such \"trivialities\" as budgets.  I\nwant everyone who reads this column to benefit from it, so it is\nnecessary to use examples from tools which everybody can potentially\nobtain for themselves.  However, everything we say applies equally to\nvendor or IBM tools of equivalent function.  Most of the free tools are\nfound on the CBT MVS Utilities Tape, which can be ordered through NaSPA,\nand to which I will often refer.\n\n      A good pair of eyes for beginning our discussion, is the SHOWMVS\nTSO command from Gilbert Saint-flour, which can be found on File 183 of\nthe CBT MVS Tape.  SHOWMVS has many of the features of a performance\nmonitor, in that it will display dozens of aspects of the current state\nof your system.  Last IPL date and time, your SYSRES and installed\nsoftware release levels, CPUs and available storage, your IODF and\nSMS setups, all online peripheral devices, your available and active\nSMF datasets, and many many other things, are quickly available to be\nviewed.  SHOWMVS gives you a very quick and comprehensive overview of\nmany aspects of your system.  Commercial performance monitors will show\nyou many of the same types of things that SHOWMVS will, and it is not\nour place here to evaluate which is better.  I only want to say that if\nyou need an overview of how your system is set up, and what it is doing,\nsomething like SHOWMVS is a good place to start.\n\n      If you want to browse things to look at them, the REVIEW command\nfrom File 134 of the CBT Tape is very helpful.  REVIEW uses BSAM, so it\ncan be used to look at keyed files, such as SYS1.BRODCAST.  Among many\nother capabilities, REVIEW can browse VSAM files, very large sequential\nfiles, and it can interpret the records in SMF and LOGREC datasets.\nREVIEW is currently maintained by Greg Price of Melbourne, Australia.\nAnother good browsing tool is the BR command (also from Gilbert\nSaint-flour), which extends the capabilities of ISPF Browse to be able\nto look at VSAM files and other weirder types of datasets.  I think\nthat REVIEW can do more than BR, but in many cases, the familiarity of\nthe ISPF BRIF (Browse) service used by the BR command, such as its\nvertical HEX display, will come in handy.  I use both of them.\n\n      Now let's put the two types of eyes, SHOWMVS and REVIEW, together\nto solve a relatively simple problem (that for most people is rather\ndifficult).  Somebody deleted a dataset in the last hour, and we want\nto find out who did it.\n\n      How do we start?  First, we can understand that this type of\ninformation is kept in SMF records, and SMF records are located either\nin the SYS1.MANx datasets, or on backup tapes.  To tell if the needed\nSMF records are still in an active SYS1.MANx dataset, we issue TSO\nSHOWMVS from any ISPF command line, and we are treated to an ISPF\nbrowse of much system information.  After scrolling down about 40 lines\nor so, there is the SMF information, and the active and not-yet backed\nup SYS1.MANx datasets will be very obviously displayed.\n\n      The REVIEW command can look at all of this information, either\non disk or on tape, but to keep things simple, lets say that SHOWMVS\ntells us that SYS1.MAN2 is the active SMF dataset right now, and that\nit contains quite a bit of data.  We can now issue the command TSO\nREVIEW 'SYS1.MAN2', and we will be given a glance at the raw SMF data\nin SYS1.MAN2.  To format the data, we need only enter a REVIEW\nsubcommand, SMF, which will interpret all of the SMF records and their\ntimestamps.  Repeated invocation of the SMF subcommand toggles the\ninterpretation of the SMF records on and off.  Now, we have several\nFIND commands at our disposal.  If we enter, FIND our.dataset.name ALL,\nwe'll get a display of all the SMF records in the dataset that contain\nour dataset's name.  We then have to only look for the last Type 15\nrecord for that dataset, together with the userid and the timestamp, to\nfigure out who deleted the dataset, and when it was done.\n\n\nMORE EXAMPLES.\n\n      We just saw how the careful use of several types of eyes, can\nneatly solve a somewhat tricky problem in a routine way.  If you set\nyour system of eyes up properly, you can tackle many difficult system\nproblems equally well, and very routinely.\n\n      Now let's look at another problem which is very different.\nA user can't get job output back.  The job has completed, and has flown\nthrough the network to \"we know not where\".  The user's JCL has an\ninteresting mixture of /*ROUTE PRINT and OUTPUT cards specifying\ndestinations.  The whole picture is very confusing to us, and it is our\njob to untangle it.  We want to make sure that this user, and all the\nother users connected with the job, get their proper job output.\n\n      Our problem is made difficult by the fact that as soon as the\nuser's job completes, it starts flying through the network nodes, and\nit is gone from our spool before we can get a proper look at it.  The\npain-in-the-neck solution is to start looking at SYSLOGs from the\nvarious systems, and tracing the job as it has flown.  This is a very\ndifficult and time-consuming task at its best.  However, there is a\nbetter way, which involves a certain kind of eye.\n\n      I strongly recommend that every systems programmer in a JES2 shop\ninstall the appropriate version of the QUEUE command.  QUEUE is a TSO\ncommand which displays JES2 spool data of many kinds.  Even though your\nshop may have commercial spool browsing products such as SDSF or IOF,\nI think you would profit by having an available copy of QUEUE, in\naddition to these.  Versions of QUEUE are available on the CBT Tape for\nJES2 versions 1.3.6 through Version 5.2.  These, and even earlier\nversions, can also be found on the JES2 SHARE Tape obtainable from Jack\nSchudel at 904-392-4601.  A parallel product called SDF for all recent\nversions of JES3, can be found on the JES3 SHARE/GUIDE Tape, obtainable\nfrom Alan Field at 612-828-4979.\n\n      QUEUE can be used to solve our job-in-the-network problem.\nGet a copy of the user's JCL and add TYPRUN=HOLD to the JOB card.\nOne might question the use of TYPRUN=HOLD, because it will keep the\njob, unexecuted, in our own spool.  But this is what we want.  With\nthe user's job HELD, but ready to go, we can use QUEUE to display the\nJES2 JCT control block for this job, while it is being held in our\nsystem.  The JCT will show all the routing destinations in various\nfields, and will enable us to leisurely figure out where the job's\noutput will eventually wind up.  SDSF doesn't display JES2 control\nblocks.  IOF does.  It doesn't really matter which eyes you use.  I\njust wrote about QUEUE because it is free and available to everyone.\n\n      Let's conclude this month's discussion with one more example.  I\nrecently obtained a new copy of SHOWMVS from Gilbert Saint-flour and\nassembled it (with old JCL).  The resulting load module, before\ndisplaying anything, went down with various system abends, such as\nS0C1, S0C2, and S0C4.  My instinct pointed to an unresolved external\nreference, which was confirmed by mapping the SHOWMVS load module with\na mapping tool.  This is another kind of eye.  IBM's AMBLIST could have\ndone the job, but I used the PDSTOOLS vendor product (from Serena in\nBurlingame, California) with its MAP subcommand, directed at the\nmodule.  A more primitive version of this product, called PDS, which is\non the CBT Tape (File 182), could also have done this particular job,\nand revealed the unresolved external reference to the missing\nsub-program.  Once I saw that the sub-program was missing, I\nre-examined Gilbert's source code.  It turned out that he had added\nanother CSECT, and there was an END card between the first CSECT and\nthe second.  In my assembly JCL, the BATCH option had been turned off,\nso that the assembly ended after the first END card, not including the\nnew CSECT.  I turned the BATCH option on in the assembly, assembled\nboth CSECTs, included the sub-program, and resolved the external\nreference.  The resulting load module has given me no problems.\n\n      Space has come to an end, and today's session must close, but\nI hope to continue on this subject of eyes, next time.  My personal\nsystems programming motto is to learn as much about the system, from\nthe system itself.  To do so, you need to look, and to look, you must\nlearn to use your eyes.  Good luck and good searching.\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9606JN": {"ttr": 15366, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x96\\x12\\x7f\\x01\\x00)\\x9f\\x11G\\x00\\xe6\\x00\\xe6\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1996-05-06T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 230, "newlines": 230, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          June 1996\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\nSam Golob is a Senior Systems Programmer working\nin New York City.\n\n\nEYES - PART 2\n\n      Last time, we talked about some different ways of seeing what\nthe various parts of your MVS operating system and DASD are doing.  My\napproach in looking at a system is to find out as much as possible from\nthe system itself.  Today we will look at a few hints in taking over an\nMVS system from somebody else's care.  Often, when a systems programmer\nleaves a shop, the remaining people have a hard time discovering some\nof the quirks in the way the shop was run.  Documentation, if it\nexists, always helps (unless it is wrong), and I use it if I have it.\nTurnover information from the previous keepers of the system can be\nhelpful, but in most cases such information is only partial.  The old\npeople, even if they are still around for a while, usually say to the\nnew ones:  \"Take it, it's your baby now.\"  And they make a quick exit.\n\n      Today, we'll pretend that we're the new people.  In a system\nprogrammer's career, such periods can either be nerve-wracking or fun,\ndepending on your approach and level of experience.  The kind of tools\nyou have at your disposal, and how you use them, will make a lot of\ndifference.  Last time, we coined the term \"eyes\" to refer to any tools\nthat will show you what the operating system is currently doing.  What\nkind of \"eyes\" you have, and how you \"look\" with them, will tell you a\nlot about how your new system is structured.  They will make it much\neasier for you to take care of things in the future.\n\n      As we said last time, there are many types of \"eyes\", and much of\na systems programmer's experience consists of learning how to use them.\nSome \"eyes\" are of a more special nature, doing one type of job, or just\na few types.  Others are truly multi-purpose tools which are capable of\nhandling hundreds of different types of jobs.  The phenomenon we called\n\"the vendorization of software\", that we talked about two months ago,\nhas one very positive aspect.  Many vendors have really \"jazzed up\"\ntheir tools in an effort to beat the competition, loading them with a\nlarge variety of features.  Systems programmers having access to such\nproducts have a big opportunity to increase their \"visual acuity\" by\nlearning how to use these \"multi-purpose eyes\" in watching their\nsystem.\n\n      We're democratic here.  A lot of you are working in shops that\nare smaller, which can't afford to buy some of the more sophisticated\nand expensive tools.  Other shops will buy one tool, and therefore\ndon't have the budget or the authorization to buy a different one whose\nfunctions partially overlap the functions of the first one.  I have (as\nregular readers of this column know) always shied away from writing\nmuch about vendor products that you have to buy, because one shop may\nhave it, and many others don't.  I want the things I write about to be\naccessible to all.\n\n      We fortunately have the alternative of being able to get what\nwe have termed \"Accessible Software\", which is free to everyone.\nAccessible Software consists of free software tools, that usually come\nwith source code.  These tools can be found in such large collections\nas the CBT MVS Tape (obtainable through NaSPA), the NaSPA VIP tapes,\nthe JES2 SHARE Tape (from Jack Schudel 904-392-4601), and the JES3\nSHARE-GUIDE Tape (from Alan Field 612-828-4979).\n\n      After this introduction, we'll now begin to use our available\n\"eyes\" to start \"staking out\" a new system that we're just taking over.\n\n\nWHERE TO LOOK FIRST.\n\n      We've just gotten a TSO id on the new system which we've never\nseen before.  What do we do?  First thing, get into ISPF EDIT or BROWSE\nand look at SYS1.PARMLIB, wherever it's cataloged.  (Write down the\nvolume name.)  Check out which IEASYSxx members are there, with a good\nlook at IEASYS00 first.  Remember that NIP (the Nucleus Initialization\nProgram) always looks at IEASYS00, even if there are other IEASYSxx\nmembers present in SYS1.PARMLIB.  The other members are merely\noverrides to IEASYS00.  This little fact is not intuitively obvious\nfrom the way the rest of SYS1.PARMLIB is laid out, but it is mentioned\nin the IEASYS section of the MVS System Initialization Reference.  You\ncan probably guess by looking, if the other IEASYSxx members should be\ntaken seriously.  If you can look at SYSLOG since the last IPL, check\nthe first console reply from startup, to see if SYSP is coded, or if it\nis anything besides SYSP=00.\n\n      The purpose behind this is to see if the \"real\" LNKLST or other\nmembers is \"00\", or if any of them are something else?  What are the\nactual startup conditions of our system?  They are all in SYS1.PARMLIB\nsomewhere, but you have to be sure as to what they really are.  A\nreally good example is the Master JCL.  I once saw a system in which\nthe main PROCLIB was SYS1.PROCLIB.NEW, and not SYS1.PROCLIB, as it\nusually is.  The IEASYS member was pointing to MSTJCL=41, and when I\nsaw that and checked out the load module MSTJCL41 (by browsing and/or\ndisassembly), the pointer to the non-standard PROCLIB was discovered.\n\n      I asked the previous keepers of that system why they had set\nthings up with suffixes of \"23\", \"41\", and \"50\", besides having \"00\".\nThey replied that this was a standalone system, not connected to any\nothers.  If they made one mistake with a PARMLIB member, they still\nneeded some other ways to IPL so they could fix things.  This also\nexplains why they had set up a one- or two-pack \"Rescue System\",\nwhich is a completely self-contained IPL-able MVS.  They needed to\nhave several emergency routes to fix things under their circumstances.\nFiles 164 and 022 of the CBT MVS Tape contain materials that can help\nyou set up your own self-contained MVS Rescue System.\n\n      After SYS1.PARMLIB, you go to the JES2 or JES3 proc in what\nthe Master JCL says is your main PROCLIB.  Usually it is SYS1.PROCLIB.\nThe JES2 proc will tell you where all the other valid PROCLIBs are,\nand where the valid JES2PARM JES2 initialization statements are.  The\nequivalent (I think) for JES3 is the JES3 Inish Deck.  This will help\nyou check out where the SPOOL packs are, and where the JES2 Checkpoint\ndataset is, plus all the JES2 network node names, job classes, output\nclasses, and such.  Or their approximate equivalents in JES3.  After\nthat, you have to find out about your I/O configuration, so you look at\nyour last MVSCP, or HCD output, and try to make sense of it.  This is\nthe classic, basic, \"stake-out\" approach.\n\n\nPERFORMANCE MONITOR INFORMATION, A VERY BIG SET OF EYES.\n\n      At this point, having as many extra \"eyes\" as possible, will\nenhance your effectiveness a dozen-fold.  Again, if you have a\nvendor-supplied performance management product such as Candle's\n\"Omegamon\" or Boole and Babbage's \"Resolve\", you can very effectively\nuse what you have.  In my writing (for ALL of the public), I can't\nassume that you have any of these.  Also, on a new system you're\ndiscovering for the first time, you can't expect these tools to be\nalready installed.  Therefore I'll use examples from what's free, and\nwe'll go on from here.\n\n      At this writing, I have to say that one of the best \"free\" sets\nof eyes for looking at a system, is the SHOWMVS program from Gilbert\nSaint-flour which can be found on File 183 of the CBT MVS Tape.\nSHOWMVS is simple to install, being a single load module, which is\nexecuted as a TSO command.  The version of SHOWMVS which is on the\ncurrent CBT tape (level 404 as of this writing) is version 5.14, which\nworks for all MVS levels from 2.2.0 through 5.2.2.  SHOWMVS shows you\na lot.  The output on one of my systems is over 2800 lines.  SHOWMVS\nputs its output into the ISPF BRIF (browse) service, but if you\nallocate a file with LRECL greater than 101 to the ddname SHOWMVS,\nthen SHOWMVS will write its output to that file when it is invoked.\n\n      The SHOWMVS ISPF browse function takes effect almost immediately,\nwhile the file output takes a while, perhaps two or three minutes\nsometimes.  The reason for this is that initial functions of SHOWMVS,\nsuch as showing the IPL date and system software levels, are done\nquickly and appear at the top of the ISPF display, while catalog, UCB,\nand VTOC lookups take much longer.  SHOWMVS does the quick things with\nits main task, while it attaches a subtask to do the longer running\nthings.  The main task fills in a skeleton ISPF browse right away,\nwhile the subtask plugs in its newly found information as it is\nobtained.  In ISPF, the result is interesting to watch, being dynamic,\nbut the file-written output is not finished until the subtask completes\nfilling in all the longer running information.\n\n      For looking at a new system, the information displayed by\nSHOWMVS is unbelievably comprehensive, and for a first look at your\nnew system, it's probably best to obtain a printout.  Some of the\ninitial things displayed are:  MVS operating system level, DFP level,\nthe first eight CVTOSLVL bytes (which show details of the ESA system\nlevel), JES2 level, the NJE node name of your system, detailed last\nIPL information, TSO/E level, ISPF level, RACF level, VTAM level,\na dump of the first 100 bytes of your SORT program, SMF data, your\nSMS configuration if you have one, hardware configuration (CPUs and\nserial numbers, etc.), IODF data, LPAR data, a Virtual Storage map,\nand SRM data.  These are just the initial things.\n\n      After that, the following things are displayed:  all the open\ncatalogs (the CAX work area), the Page Datasets, the dump datasets and\nall dump options, a JCL listing of the MSTJCL00 load module, the entire\nSubsystem Vector Table (including active and inactive subsystems and\nall the function numbers of the active subsystems), the current TCAS\nparameters and all the program names in SYS1.PARMLIB(IKJTSO00), RACF\ndatasets and some of the global RACF options in effect, the entire RACF\nstarted task table ICHRIN03, address space usage from the Address Space\nVector Table (ASVT), and all active JOBS, Started Tasks, and TSO users.\n\n      This is nowhere near the end.  Then there follows a detailed\ndisplay of all the datasets in the Link List, a similar display for\nthe LPA List, and the APF list (whether the APF list is in the old or\nnew format).  Then the Active LPA queue (ALPA) is displayed, so you\nsee the LPA program overrides.  Then you get a complete listing of the\nSVC table, which is followed by all the Extended SVC Router numbers\nwhich are occupied and not occupied.  If you're running authorized,\nyou then get a complete display of the PPT (Program Properties Table)\nwhich shows you what privileged programs are running.  This whole\nthing is followed by a complete display of all online units (UCBs)\nof all device classes, constantly updated with attributes, allocating\njobs, and SMS information (if that is applicable).  In our January\n1996 column, we discussed how this current actual UCB information is\nobtained, even when SHOWMVS is running unauthorized.  After that,\nall defined consoles are displayed.\n\n      So much for system-wide information.  The rest of the SHOWMVS\ndisplay (if you can believe that there is more) concerns your own TSO\nsession attributes.  There is detail concerning your TSO session that\nis beyond belief.  Some of the things shown are:  your current JCL\nfor your TSO job step, session startup and performance group\ninformation, your address space virtual storage map, RACF profile,\nTSO profile, your REXX environment, your ISPF environment, your\nwhole TIOT (allocated datasets) with EXCP counts for each dataset,\nyour Job Pack Queue and your entire Load List.\n\n      When I started to write this column, I called Rick Fochtman and\nasked his opinion on how to stake out a new system.  He agreed with me\non all the preliminaries, adding the importance of seeing the I/O\nconfiguration.  Then, I said to him that to be fair to everyone, I\nwanted to only write about free tools, for inspecting the system\nfurther.  He answered very simply:  \"Then I guess you have to tell them\nabout SHOWMVS.\"  So I did.\n\n      Of course, a picture is worth a thousand words, and I'd advise\nyou to get a new CBT Tape (or a new Naspa CD-Rom) and fire up SHOWMVS\nfor yourself.  I'd like to apologize that so much of this article is\na list of what SHOWMVS does.  But if you'd look carefully at the\nitems in this list, one by one, you'll see that most of the things you\nhave to know when you stake out a new system, are mentioned here.  So\nfor people who need this information, I've mentioned what I could in\nthe space provided.\n\n      Believe it or not, SHOWMVS doesn't show you EVERYTHING you need\nto know, or should know about a system.  Next time, we'll continue\nfurther, using different eyes.  Good luck.  See you soon.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9607JL": {"ttr": 15371, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x96\\x16\\x1f\\x01\\x00)\\x9f\\x11G\\x01,\\x01,\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1996-06-09T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 300, "newlines": 300, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          July 1996\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\nSam Golob is a Senior Systems Programmer working\nin New York City.\n\n\nEYES - PART 3 - Using SMP/E\n\n      Our previous two columns have dealt with the subject of \"eyes\".\nWe use the term \"eyes\" to describe tools that give you a look at some\naspect of what your system is doing.  Our first installment was a\ngeneral introduction to the subject of looking at your system from the\nsystem itself.  Last month's column was concerned with the idea of how\nto start looking at the working innards of a previously unknown MVS\nsystem.  Our emphasis in each case, was on the proper \"eyes\", or\ntools, which you can use in exploring each situation.\n\n      This month's piece will be about how to discover the module\ncontent of your system's software, using as your \"eyes\", the SMP\nsuper-structure through which that system was originally built.\nSMP/E, today's form of IBM's System Maintenance Program for MVS, is an\nextraordinarily helpful kind of \"eye\" in the hand of a knowledgeable\nsystems programmer.  You can use SMP/E as an \"eye\" in many ways you\nnever previously thought of, because SMP/E contains very detailed\nrecords about much of your operating system's software structure.\n\n      Generally speaking, SMP/E's job is to load software into\npartitioned dataset libraries.  To simplify this article, it will be\nassumed here, that the contents of all libraries loaded by SMP/E on\nyour system correspond exactly with the SMP/E records.  On sloppily\nmaintained systems, it could be that a systems programmer has done\nlinkedit, copying, or zapping operations to the system libraries\noutside of SMP/E, so that the actual libraries, and the \"corresponding\"\nSMP/E files, are not in sync.  Fixing such a situation is beyond the\nscope of our discussion.  We will assume a well-maintained system,\nand we'll try to \"see what we can see\", from the SMP/E records.\n\n      Because of space considerations in this column, I have to assume\nthat you have some previous knowledge of SMP/E.  For an old, but very\nthorough treatment of the basis and purpose of SMP, you can refer to my\nseries of two articles that were published in \"Technical Support\" back\nin 1988, and which may be found on File 014 of the CBT MVS Utilities\nTape.  The CBT MVS Tape is included on the NaSPA CD-Rom, or it can be\nordered separately through NaSPA.  At this point, I'll give a very\nbrief overview of SMP/E, and we'll go on from there.\n\n\nSMP/E OVERVIEW.\n\n      SMP/E was designed to be an automatic way of installing system\nsoftware and software changes, while keeping a thorough accounting\nof what it has done.  While SMP/E's predecessor, SMP, kept its records\nin partitioned dataset members, the newer SMP/E keeps the corresponding\nrecords in special VSAM files called ZONEs.  Physically, these VSAM\nfiles are called CSI's or Consolidated Software Inventories.  Every\nsuch VSAM file has to have a dataset name that ends in \".CSI\".\nLogically however, each CSI might be broken up into one or more ZONEs,\neach of which represents a sort of domain of operation to SMP/E.\n\n      Units of work in SMP/E are called SYSMODS.  SYSMODs are named\nwith names that have up to (usually exactly) seven characters.  There\nare four kinds of SYSMOD.  A FUNCTION sysmod represents an entire\nproduct installation.  PTF sysmods (once called Program Temporary\nFixes) represent permanent incremental changes to a product.  APAR\nsysmods represent temporary incremental system changes, a kind of\ntrial fix to circumvent a problem.  Finally, USERMODS are a type of\nsysmod which was designed and packaged by an individual installation,\nnot usually by a software manufacturer.  USERMODS are usually employed\nto install your own shop's software customizations.\n\n      What do you do with a SYSMOD?  You usually run an SMP/E\nprocedure in the background, using JCL.  I'll assume that you are\nfamiliar with your installation's SMP/E procedure(s), and how to use\nthem.  Whenever I do SMP/E work, I always try and keep the \"SMP/E\nReference\" (SC28-1107) and \"SMP/E Messages\" (SC28-1108) handy.  These\nmanuals contain all the information you'd ever need, somewhere within\nthem.\n\n      There are three basic processes called:  RECEIVE, APPLY, and\nACCEPT.  RECEIVE processing brings a brand new sysmod into your SMP/E\nsystem.  APPLY processing installs the software represented by the\nsysmod into a real operating environment, known as a TARGET system.\nACCEPT processing, usually done after the product has been tested,\nmakes the installation permanent, and installs the software components\nof the product into special libraries known as distribution libraries,\nor DLIBs.\n\n      Records are kept for the software installation in logical\nVSAM files known as ZONEs.  Each zone has up to a seven-character\nZONE NAME.  As we mentioned, one or more ZONEs are stored in the\nphysical VSAM files called CSI's.  How you physically arrange the\nzones in your CSI's is up to your design.\n\n      Each separate SMP/E environment has one ZONE for RECEIVE\nprocessing.  This ZONE is known as the GLOBAL zone.  Records for APPLY\nprocessing are kept in one or more TARGET zones.  Each TARGET zone\ncontains the records of a separate operating environment for the\nsoftware.  Finally, the records for ACCEPT processing are kept in one\nor more zones called DLIB zones.  TARGET and DLIB zones come in pairs,\nbut it is possible to change these pair associations.  For example, in\nour shop, which is a large service bureau, we have multiple TARGET\nzones, but only one DLIB zone.  Whenever we have to do ACCEPT\nprocessing, we simply go into the SMP/E zone administration ISPF panels\nand associate the DLIB zone with the particular TARGET zone we want to\nACCEPT from.  In regular SMP/E batch processing, how do you tell SMP/E\nwhich zone you want to look at?  You use the \"SET BOUNDARY\" or \"SET\nBDY\" command, pointing to the name of that zone, in parentheses.\n\n      Individual pieces of software in SMP/E are known as ELEMENTs.\nDifferent kinds of elements have different designations.  The original\ndesignations were SRC for source modules, MAC for macros (which\nincluded all 80-byte non-source modules before Release 1.5 of SMP/E),\nMOD for one or more load module CSECTs taken as a unit, and LMOD for\nload modules which are linked together from one or more MODs.  After\nSMP/E Release 1.5, there were many other types of element designations\ndefined, such as PNL for ISPF panels, DATA, for not-necessarily-80-byte\ndata, and so forth.  As we said, the job of a SYSMOD is to install\nand/or modify ELEMENTS in pds libraries.\n\n      There is one more aspect of SMP/E that is not sufficiently\nwell-understood by the public.  That is the idea of JCLIN.  JCLIN is\na kind of skeleton JCL which is fed into SMP/E target and dlib zones.\nJCLIN tells SMP/E \"how to build the house from the individual bricks\".\nJCLIN loads all kinds of patterns into SMP/E.  This is for the purpose\nof telling SMP/E how to build the load modules from the individual\nCSECTs, and what libraries to put individual elements and load modules\ninto.  An example of JCLIN would be some linkedit JCL to access some\nmodules in DLIBs, with the SYSLMOD statement pointing to SYS1.LINKLIB.\nThe linkedit control cards would tell SMP/E how to linkedit the load\nmodule, and the JCLIN SYSLMOD statement would indicate that the target\nlibrary for the load module should be SYS1.LINKLIB, or rather, its\nddname of LINKLIB.\n\n      One final note.  SMP/E is ddname oriented and not dsname\noriented.  In other words, you specify ddnames to SMP/E and not dataset\nnames.  How does SMP/E know, when you give it a ddname, what dataset to\nuse?  This is done by SMP/E objects called DDDEFs (or DD definitions)\nwhich are stored in each zone.  Each DDDEF takes one ddname and\nspecifies the dataset name associated to it, in that zone.  The\noriginal installer's job is to initially specify a set of all the\nDDDEFs needed for a product, in each zone.  Then the APPLY or ACCEPT\nprocessing for that product will \"know\" which datasets to deal with.\nSMP/E will dynamically allocate the proper datasets as they are\nneeded.  If you are looking at an installed system, all the DDDEFs\nneeded are probably already there.  Checking the DDDEFs will be part\nof using your \"eyes\".\n\n\nFOUR SMP/E INQUIRY METHODS - USING THE \"EYES\" OF SMP/E.\n\n      In my repertoire, there are four basic types of inquiry to SMP/E:\nbatch, PTF, CLIST, and ISPF.  Batch inquiry is very powerful, and in\nmy estimation, it is probably not used enough.  Batch inquiry consists\nof running your SMP/E proc using the LIST command in the SMPCNTL DD\nstatement.  Output of the LIST command goes to the SMPLIST ddname.\nDetailed instructions on all aspects of the LIST command are contained\nin the SMP/E Reference manual, but you must play with it to see the\nformat of the outputs.  That's where you'll gain the most knowledge of\nits power.  Utilizing the outputs of the LIST commands will provide\nyou with a most powerful set of eyes into the structure of your system\nsoftware.\n\n      PTF inquiry is a bit of my own invention.  But it is logical\nenough for you to find many methods of doing it.  PTF inquiry is based\non the fact that SMP/E keeps all RECEIVEd and not-yet-ACCEPTed sysmods\nin one partitioned dataset library, the SMPPTS library.  If you do a\nLIST DDDEFS batch inquiry against your GLOBAL zone, you'll see where\nthe SMPPTS library is.  Then you can make a simple CLIST to conveniently\nbrowse the members of this library.  My favorite browsing tool for this\npurpose is the versatile (and free) REVIEW TSO command, from File 134\nof the CBT MVS Tape.  REVIEW does not need ISPF, but it can use ISPF\nif it is available.  My simple PTF inquiry CLIST, whose name is \"PTF\",\nconsists of 2 statements:  The first is:  PROC 1 PTFNAM.  The second\nis:  REVIEW 'smppts.dsname(&PTFNAM)' .  That's all.  To invoke the\nfull-screen inquiry of looking at a PTF, all you have to enter is \"TSO\nPTF ptfname\" from anywhere in ISPF, or \"PTF ptfname\" in TSO READY mode.\n\n      The REVIEW command is versatile enough to give a lot of power\nto this CLIST.  For example, suppose you want to look at a PTF called\nUW11111, and it isn't there.  When you get REVIEW's \"member not found\"\nscreen, you can enter the DIR subcommand of REVIEW, and you get a\ncomplete member list of the entire SMPPTS dataset, to search in.\nSpace precludes a further discussion of PTF inquiry here, but I\nguarantee that if you play with it, you'll use it often.\n\n      CLIST SMP/E inquiry is the same as what you did before SMP/E\ncame along with its ISPF panels.  An SMP/E CLIST simply invokes\nbatch-mode SMP/E interactively under your TSO session.  You enter\nall the batch-mode SMPCNTL commands on your TSO screen, and the\nreplies from SMP/E appear below.  To finish your session, you simply\nenter /* in column 1, just as you'd do for a batch job.  For a sample\nCLIST, see Figure 1.\n\n      This CLIST method looks outdated; why should we have it?  First,\nyou can inquire on several elements at once.  For example, you can\nsay:  LIST MOD(IEFAB4A0 IEFAB4A2 IEFAB4B0) to look at 3 modules\nat once.  Second, if you know what you're doing, you can do limited\nUCLIN updates, checking yourself with LIST commands whose results you\nsee on the screen immediately.  Third, it's a quick method, not\nrequiring one panel after another.  Try this one too.  I think you'll\nlike it after you practice.\n\n      Finally, the fourth method is the ISPF panel method supplied\nwith SMP/E.  For single-element inquiries and cross-zone inquiries,\nthe ISPF panels are wonderful.  They are also very good when you have\nto do SMP/E administrative touch-ups, adding a DDDEF or something\nsimilar here and there.  The use of the SMP/E ISPF panels is well\ndocumented by IBM, but because of the space, I can't talk further\nabout them here.\n\n      In summary, I hope this series of installments has opened\nyour eyes to the idea of \"looking at the system from the system\".\nAlthough documentation helps also, this slogan is my systems\nprogramming watchword.  The only data I really trust is the data I\n\"see\", and to see, I have to constantly depend on my \"eyes\".  Good\nluck and good vision.  See you next month.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFIGURE 1.   THE SMP/E INQUIRY CLIST.  WE'LL CALL THIS CLIST \"SMPETSO\".\n\n       This CLIST invokes SMP/E in the foreground under TSO exactly\n       the same way as it would run in the background in batch.  Input\n       of commands and output of results go to the terminal.  Since\n       there might be quite a few lines of output, it is preferred\n       to run this CLIST in TSO \"Session Manager mode\", which can\n       preserve and print up to several thousand lines of TSO output.\n       To set up Session Manager mode, simply replace PGM=IKJEFT01\n       by PGM=ADFMDF03 in your TSO logon proc.\n\n\n PROC  0  VOLID  CSI('SMPE.GLOBAL.CSI')  UNIT(DISK)  TYPE(SYS1)  NOLOG -\n          SYSOUT  LOGDISP(MOD)  NOPTS  LIST()  /**  YES OR NO  **/\n\n   SET VOLID = ZRS001       /*  SMP-CONTROLLED PACK  */\n   IF LIST = YES  THEN  CONTROL LIST\n   ELSE  IF LIST = NO  THEN  CONTROL NOLIST\n\n   CONTROL PROMPT\n\n   WRITE ***********************************************************\n   WRITE *                                                         *\n   WRITE *     WELCOME TO THE SMP INQUIRY SYSTEM.  THIS MEANS      *\n   WRITE *          MAKE INQUIRIES ONLY  ........                  *\n   WRITE *                                                         *\n   WRITE ***********************************************************\n   WRITE\n   WRITE                  T Y P E  =   &TYPE\n   WRITE\n   WRITE             FOREGROUND EXECUTION OF SMP/E\n   WRITE\n   WRITE              SYSTEM DEFAULT  ====>  &TYPE\n   WRITE\n   WRITE            TYPE  =  &TYPE  MVS SP 5.2.2  DFSMS/ESA\n   WRITENR              ENTER DESIRED TYPE ====>\n   READ ANS\n\n   IF &LENGTH(&STR(&ANS)) \u00ac= 0  THEN SET TYPE=&STR(&ANS)\n   IF &TYPE = SYS1    THEN SET VOLID = ZRS001   /*  TARGET PACK  */\n   IF &TYPE = SYS1    THEN SET DIST  = SMPDL1   /*   DLIB  PACK  */\n\n   WRITE\n   WRITE   YOU HAVE SPECIFIED  &TYPE AS THE SYSTEM.\n   WRITE   TARGET = &VOLID   ----  DISTRIBUTION = &DIST\n   WRITE\n\n   ERROR GO TO ENDALL\n   ATTN  GO TO ENDALL\n\n   ALLOC FI(SMPLIST) DA(*)\n   ALLOC FI(SMPCNTL) DA(*)\n   ALLOC FI(SMPRPT)  DUMMY\n\n   IF &NOLOG = NOLOG THEN ALLOC FILE(SMPLOG) DUMMY   /* NO SMP LOG */\n     ELSE ALLOC FI(SMPLOG) &LOGDISP KEEP DA('SMPE.GLOBAL.SMPLOG')\n\n   IF &NOPTS \u00ac= NOPTS  AND  TYPE = SYS1    +\n     THEN ALLOC FI(SMPPTS) SH REUSE DA('SMPE.GLOBAL.SMPPTS')\n\n   IF &SYSOUT = SYSOUT THEN ALLOC FI(SMPOUT) SYS(T)  /* HELD CLASS */\n     ELSE ALLOC FI(SMPOUT)  DA(*)\n\n   CALL  'SYS1.LINKLIB(GIMSMP)' 'CSI=&CSI'\n\n  ENDALL:  ERROR OFF\n           ATTN  OFF\n           FREE FI(SMPLIST SMPRPT SMPCNTL SMPLOG SMPOUT SMPPTS)\n\n  END\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9608AU": {"ttr": 15621, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x96\\x19?\\x01\\x00)\\x9f\\x11G\\x00\\xc7\\x00\\xc7\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1996-07-11T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 199, "newlines": 199, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         August 1996\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\nSam Golob is a Senior Systems Programmer working\nin New York City.\n\n\nPERSONAL TOOLS FOR YOUR SMP WORK\n\n      One of my senior managers used to write a lot of code in the\n\"good old days\".  He's been showing quite a bit of it to me lately.\nOne of the programs he wrote was a \"quick and dirty\" COBOL program to\nread an SMPPTFIN file (PTF input to SMP/E) and produce a report which\nshows the products that the PTFs belong to, and what APARs they fix.\nThis is very useful information that IBM does not always supply\nconcisely.  One normally needs to second-guess IBM and verify that\nthey sent you the right maintenance.  For my own use, I had been\nrunning some similar user code that I had borrowed and improved upon.\n\n      This class of programs tells you what products you're getting\nPTFs for, even before SMP/E takes its own look.  The processing is\nquick, and in many ways, it's a lot better than what IBM offers.  Look\nat Figure 1 to see a sample output from this code.\n\n      For a long time, I've been \"helping SMP\" with user-developed\nprograms and techniques.  Nowadays, SMP/E has a fairly robust, although\nby no means complete, collection of reports.  But it used to be a lot\nworse.  Especially with SMP4, but even now with SMP/E, I've found it\nvery helpful to add some of my own programs and post-processing to SMP,\nand I've profited greatly by doing that.\n\n      Today, we'll ramble on this subject together for a while.  I\nhope we'll all gain a bit of knowledge and a few ideas.  Hopefully,\nthis will lead to implementing some kind of helpful SMP/E\nsupplementation in your shop.  Once that is in place, and you know how\nto use it, I know I'll get some quiet \"thank you's\" without having to\nhear them explicitly.\n\n\nHOW I GOT STARTED\n\n      Back in the days of SMP4, before there was HOLDDATA, there had\nto be a way to exclude APPLYing PTFs that were in error.  The answer\nwas that you had to explicitly EXCLUDE them in the APPLY job.  IBM\nwould ship a list of PTFs in error together with the monthly PUT tape\nof maintenance, and you would copy this list into the APPLY job as an\nEXCLUDE list.  Problem was that when one PTF was in error, it would\nhold other PTFs off also, if they depended on the PTF in error.  It\nwas difficult to obtain a clean APPLY because of all the induced\nerrors.\n\n      That release of SMP could not analyze an error further than one\nlevel.  In other words, if PTF A was bad, and it was a prerequisite\nfor PTF B which was good, and PTF B was a prerequisite for PTF C which\nwas also good, you usually didn't want to APPLY any of them.  However,\nthe only PTF which was on the original exclude list was A, and the\nAPPLY CHECK report would mention that B wouldn't go on.  There was no\nmention of C at all.  This was because C had B as a prerequisite, but\nthere was no direct connection between C and A.  C was two levels\nremoved from A.\n\n      In order to avoid APPLYing C, you had to add B to the exclude\nlist of EXCLUDEd PTFs, and then run another APPLY CHECK.  This second\nrun would now show that C should also be excluded.  Then you would add\nC to the exclude list, and run a third APPLY CHECK.  You'd keep doing\nthese iterations until the APPLY CHECK was clean, or was otherwise\nacceptable.  In a mass APPLY of hundreds or thousands of PTFs, adding\nPTFs to the exclude list by hand was an extremely tedious chore.\nTypically during a maintenance cycle for APPLYing multiple monthly PUT\ntapes, you'd run an APPLY CHECK for an hour or two, and spend the\nentire next hour or two adding PTFs to the exclude list by hand.  Then\nyou'd wait still another hour or two for the next APPLY CHECK run to\nfinish.  The typical six or seven iterations needed for a mass APPLY,\nwas easily a whole day's effort on your part, if not more than that.\n\n      Enter my invention.  I wrote a COBOL program to read the\nprintout of an APPLY CHECK run and generate a list of possible further\nexcluded PTFs.  These consisted of all PTFs which got held off because\nof errors, plus the other PTFs which held them off.  I generated the\nPTF id numbers by copying the \"held off\" PTFs plus the other PTFs which\noccurred in the report with an asterisk behind them.  This list might\ncontain duplicates, and APPLY processing doesn't tolerate duplicate\nexcluded PTFs.  So I SORT MERGEd my list into the original exclude\nlist and deleted the duplicates with a program.  This automated process\ntook all of two minutes.  Between APPLY CHECK runs, the rest of my day\nwas free.\n\n      Following this act, I wrote other programs to list all the\nELEMENTs that appeared in an APPLY CHECK run or an ACCEPT run.  This\nreport would allow me to study which programs were affected by an\nAPPLY, and to figure out which libraries were modified.  I achieved\nfar better control of my environment as a result of these tools I\nwrote.\n\n      Then I wrote a program to turn a sequential SMPPTFIN file into\na partitioned dataset, with each PTF as a separate member.  This\nprogram can still be found on File 118 of the CBT MVS Utilities Tape\n(orderable throough NaSPA).  CBT Tape Version 404 is also on the NaSPA\nCD-Rom.  By separating each PTF in the (sometimes enormous) IBM tape\nfile, I could better examine a piece of maintenance I was getting, if\nI needed to.  I didn't have to ISPF browse a file that could possibly\ncontain over a million lines.\n\n      Although I don't like to write about vendor products, I have to\nmention at this point that the product PDSTOOLS (from Serena\nInternational, Burlingame, California) can be used to fit zaps to\nmodules before the maintenance gets APPLYed.  This pertains to TMS or\nTLMS hook fitting, etc. if the IBM modules that get hooked into, are\nvery new.  Sometimes the vendor didn't have a chance to fit the proper\nhook in yet.  The vendor usually asks you to fax them an AMBLIST dump\nof the module at the new PTF level.  I just use the SMP/E APPLY or\nAPPLY CHECK report to find out which PTF modified the module, and run\nthe PDSTOOLS object deck disassembler against that PTF.  To do the\nsame job without PDSTOOLS, you'd have to isolate the new object deck\nand linkedit it.  Then you run a regular disassembler (For example,\nthe ones on CBT Tape Files 217 or 171) against the one-CSECT load\nmodule, and report the needed locations to the vendor.  This activity\nadds to the fun of applying system maintenance.  I enjoy having this\ndegree of precision when I need it.\n\n      All of these tools aided me in controlling the maintenance of\nmy system.  In addition, I made my own processing to do FORFMID work\n(separating PTFs by which product or FMID they belonged to).  That\nstuff still is valid today, because it reads the sequential PTF file\ndirectly and is independent of SMP/E.  This material is on File 118 of\nthe CBT Tape also.  My boss Walter Shelley's program, mentioned at the\nstart of this column, which does the same kind of thing, is being\nplaced on File 262 of Version 407 of the CBT Tape, so you can see what\nhe does, and how simple it is to do something similar yourself.  I'll\ntry and get my old SMP4 code placed on Version 407V of the new CBT\nOverflow Tape, which contains a lot of older code.  You can also\nobtain the CBT Overflow Tape through NaSPA.  My ancient SMP code used\nto appear on the CBT MVS Tape, in File 428, between Versions 250 and\n316, so if you have an old CBT tape, you can see these software ideas\nfor yourself.\n\n\nOTHER TOOLS AND IDEAS\n\n      The SMP/E ISPF inquiry and administration facilities are very\nhelpful in many ways, but they do not fully replace our old ways of\ndoing things.  For example, using the SMP/E ISPF inquiry, you can\nquery on a single element or sysmod, but you cannot ask about two,\nthree, or five of them at the same time.  With the old way, you could.\nWith SMP/E ISPF inquiry you cannot make small UCLIN adjustments to a\nMAC, a MOD, or a SYSMOD entry, whereas with the old way, you could.\n\n      What was the old way?  It was a CLIST which runs the SMP/E\nGIMSMP background program in the foreground.  You simulate a batch\nSMP/E run in the foreground under native TSO, and enter the SMPCNTL\ncommands at the terminal, receiving the replies one by one, at the\nterminal also.  The first thing you do is to enter a SET BOUNDARY\ncommand and point to a ZONE.  Then you can enter LIST commands to\npoint to multiple elements, or UCLIN commands or RESETRC, and the\nlike.  When you have finished, you enter slash-asterisk /* in column\n1, as you would in batch, and the CLIST then ends.  You can find a\nsample copy of this CLIST on CBT Tape File 120, where my old columns\nare kept, and it was also printed in last month's column.  Just\nsearch the File 120 PDS for the string SMPETSO.\n\n      How do you look at the actual text of a PTF?  You can take\nadvantage of the fact that the SMPPTS dataset contains actual text of\nPTFs that have been RECEIVEd.  So you can either ISPF BROWSE the\nmembers of this dataset, or simplify the \"looking\" process with a\nCLIST.  I personally use the free REVIEW TSO command from File 134 of\nthe CBT Tape for looking, which I find more convenient than ISPF Browse\nfor many purposes.  My two-line CLIST named \"PTF\" reads as follows:\nPROC 1 &PTFNUM is the first line.  REVIEW 'smppts.dataset(&PTFNUM)'\nis the second line.  To invoke, you just enter TSO %PTF ptfnumb on an\nISPF command line, or PTF ptfnumb in READY mode.  With these two CLISTs\nin place, your life in system maintenance will be a lot easier.\n\n      Under ISPF, I assign a PFKEY to the command TSO.  My personal\npreference is PF4, because I do not use the RETURN command much,\npreferring to use multiple END commands.  Having done this for all\nmy APPL ids, I don't always have to type the word \"TSO\" when I want\nto invoke a TSO command under ISPF.  I just type the command or CLIST\nI want to invoke, and press the designated PFKEY.  This saves a lot\nof mental effort during a day's work.  It also helps when I run my\nSMP-type CLISTs that we just talked about.  I can get into them more\nquickly.\n\n      I hope that some of these ideas help you.  If you consider\nyour own work, you'll probably realize that you too, can profit by\nwriting a few programs, CLISTs, edit macros, or REXX execs to process\nthe SMP-generated data or SMPPTFIN files.  The idea is to get your own\nmind working in that direction.  Once you've done something useful for\nyourself, you can then acquire that very special feeling which only\ncomes when you've shared your work with others and helped them too.\nYou can do this by sending some of your things to a public software\ntape so others can benefit from your good ideas, and you can benefit\nfrom their feedback.  Good luck.  See you next month.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9609SE": {"ttr": 15625, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x96\"_\\x01\\x00)\\x9f\\x11G\\x01\"\\x01\"\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1996-08-12T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 290, "newlines": 290, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                        September 1996\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\nSam Golob is a Senior Systems Programmer working\nin New York City.\n\n\nTIDBITS\n\n      It's good to have friends.  I find that I have more friends\nwhen I try to be a friend, but in any case, we try to help each other,\nand we exchange tidbits of system information.  This month, we'll talk\nabout a few of these tidbits.\n\n\nCHECKSUMS\n\n      Recently, my friend Bruce Leland called me to say that he found\nout how the AMASPZAP (IBM Superzap) CHECKSUM numbers work.  To refresh\nyour memory (if you ever heard of these things), the IBM superzap\nprogram gives you a way of checking that you didn't make a mistake in\ntyping your ZAP control cards.  So after you type in your VER and REP\nstatements, you can write the word CHECKSUM on the next line\nafterwards.  The AMASPZAP run will send you an AMA132I message that\nthe CHECKSUM was some four-byte hex number, and it's now 0.  The\nactual ZAP will also complete.  If you now want to do another run of\nthis identical zap on another copy of the unzapped module, and you now\ncode the CHECKSUM keyword with this exact four-byte hex number\nafterwards, you still get a good ZAP run.  But if the four-byte number\nwas different, the NO-GO switch will be set and the ZAP won't work.\nHere is a good safeguard that all the VER and REP numbers were right.\n\n      How these numbers are calculated is a mystery to most of the\npeople who ever heard of them in the first place.  Bruce found out\nhow it's done, and I think it should be a useful fact for you to\nknow.\n\n      Figure 1 shows a typical AMASPZAP job, to change one byte in\nload module PROGRAMA at displacement +1C0 into csect CSECTA from its\noriginal value of hex 1D to hex 2D.  As the figure shows, you VERify\nat displacement 01C0 in CSECTA of PROGRAMA, that its original value is\nhex 1D.  If that is true, then you REPlace the value at that location\nwith the value of hex 2D.  For the purposes of accomplishing the ZAP,\nit doesn't really matter if you express the displacement into CSECTA\nas 01C0 or 0001C0.  However, for the purposes of calculating the\nfour-byte CHECKSUM value, we'll see that it makes a huge difference.\n\n      To calculate this CHECKSUM value, we string out all of the\nnumbers, displacement and hex value, into four-byte chunks, padded\nat the end with zeros.  Then we add all these four-byte numbers\ntogether in hexadecimal to produce a four-byte sum, ignoring the\noverflow.  The resulting sum is the CHECKSUM value.  Figure 2 shows\ngraphically how this is done.  As you can see there, if the second\nbyte at displacement +1C0 is hex F1, and this value will not be\nchanged by the zap, but we code the VERify and REPlace statements a\nbit differently to reflect this, the CHECKSUM calculation comes out\ncompletely different.  Everything depends on all the exact numbers in\nthe VER and REP statements.\n\n      Now comes the 64 dollar question:  Why would it be helpful\nfor people like us to know this information?  The truth is that many\nsystems programmers have never seen a CHECKSUM statement in an\nAMASPZAP job during their entire careers.  I still think that the\nfact is useful to know.  One often knows how super-critical the\naccuracy of a superzap has to be.  One \"typo\", and the system can\neasily crash because of it.  How can one guarantee that all of\nthe many VER and REP statements in a complicated, but crucial ZAP\njob, have been coded correctly, without a mistake?  This CHECKSUM\nmechanism of IBM's can create that guarantee.  But it's helpful for\nyou to know how this works, because if you want to employ this\ntechnique for ensuring the accuracy of your system zaps, you have\nto know that zeros make a big difference, even though the actual\nzapping effect might be the same.\n\n      When you're the systems programmer assigned to create this\nsafeguard in your shop, it helps to know that the algorithm which\ncreates the CHECKSUM is not some magic mumbo-jumbo, but that you can\ncalculate it yourself to make sure it's right.  Now that all of you\npossess this information, I'm sure that some shop somewhere will be\nable to have enhanced \"Reliability, Availability, and Serviceability\"\nbecause of it.\n\n\nFIXING THE OLD LINKAGE EDITOR.\n\n      Sometimes it makes you mad to see how some old \"design\ncriterion\" perpetuates itself to the point of silliness.  Everyone\nknows that when you \"Compile and Linkedit\" or \"Assemble and Linkedit\"\na program, the 80-byte card-image object deck cannot be blocked bigger\nthan 3200 bytes, otherwise the Linkage Editor can't accept it as its\ninput.  This restriction existed from time immemorial, from the\ninfant beginnings of System/360, when central storage was at a\npremium, and you had to fight for every byte of it.  Apparently, the\nIBM software engineers didn't want a Linkage Editor run to consume\nmany central storage bytes, so they restricted the size of the chunks\nof data input to be fed into it.  3200 bytes was to be the biggest\nchunk.\n\n      Nowadays, this restriction goes counter to the current IBM\npolicy.  Modern machines possess relatively huge quantities of central\nstorage, to the point where operations that were formerly performed by\ndoing I/O to disk, are now done in central storage.  IBM is touting\nthis change in its software very obviously and loudly.  So what\nhappened with the Linkage Editor?\n\n      The answer is, absolutely nothing.  The linkage editor is\nmaintained by a different group, and they didn't, for some reason,\nwant to mess with it.  Today, we will show you the kind of change\nwhich will fix the Linkage Editor, so that the object decks can be\nblocked as big as 32720 bytes.  The change is extremely simple, and\nyou'll have a good laugh.  IBM, to be sure, has actually addressed\nthis problem in its software.  The new Binder, which replaces the old\nLinkage Editor in the newest MVS and OS/390 systems, has had the\n\"3200-byte input\" restriction removed.  However, IBM continues to\nsupply a copy of the old Linkage Editor with DFSMS, under the program\nname of HEWLKED.  Even though you get the new Binder if you execute\nPGM=HEWL, you can still get the old Linkage Editor if you execute\nPGM=HEWLKED.\n\n      I recently examined this DFSMS version of HEWLKED, and lo and\nbehold, the \"3200-byte input\" restriction is very much alive and well.\n(Perhaps this month, this column should be printed on the humor page.)\nLook at Figure 3 for some AMASPZAP input that will get rid of this\nrestriction, once and for all, in the DFSMS copy of the Linkage\nEditor.  I have placed several versions of this simple modification,\nadjusted to various maintenance levels of the Linkage Editor, in the\nCBT MVS Utilities Tape, on File 257.  You can order copies of this\nencyclopedic and very useful tape through the NaSPA office.  See\nFigure 3 for a copy of this modification.\n\n      As you see, the 3200-byte limit is actually hard-coded, and\nin reality it could have been adjusted to any value which is a\nmultiple of 80.  Our zap can be easily fitted to any extant version\nof the Linkage Editor by finding the appropriate displacements into\nmodules HEWLFINT and HEWLFAPT.  Just look for the appropriate binary\nvalues, aligned on halfwords, at approximately the displacements\nlisted.  For help in doing this, I use the free FULLSCREEN ZAP program\nfrom File 134 of the CBT MVS Tape, which has a \"find\" function, and\nwhich can effortlessly spot the halfwords X'0C80' which is 3200 in\ndecimal, and the X'0028' which is 40 in decimal (the count of 80-byte\nrecords in a 3200-byte block).\n\n      Again, I don't know how useful you'll find this information.\nWhat I can tell you, is that it seems that IBM is not changing the\nprogram HEWLKED at all, so these displacements to fix your DFSMS copy\nof the old Linkage Editor, should probably be quite stable.  If you\nget used to using the Binder, without the blocking restriction, and\nthen you use the Linkage Editor and get burned, you might think of\ntrying out this fix.  In any case, it is a nice illustration of\n\"vendor old fogeyness\" that all of us will enjoy.\n\n\nENJOYING OLD CODE.\n\n      I'd like to conclude this month's installment with the\nannouncement of a new public tape.  The CBT MVS Utilities Tape got\nto a point where it filled up, so some of the software had to be\ndeleted.  It's proprietor didn't want to render the deleted code\n\"permanently unavailable\" to the public, so it was decided to create a\nnew CBT Overflow Tape, which would be distributed by the same people\nwho distribute the regular CBT Tape.  The new CBT Overflow Tape has\n\"slots\" for 472 files, just like the regular CBT Tape, and is in the\nsame format.\n\n      It didn't seem to pay to make an entire tape with just a little\nbit of code, so more \"unavailable code\" was added, and the new tape,\nin its Version 406V, now contains a lot of other code.  The German,\nSwiss, English, and Australian G.U.I.D.E. tapes are there, as well\nas a fine ISPF collection that was going to be distributed by the\nSHARE organization, but which never was.  This collection was to be\ncalled the \"SHARE ISPF Smoke and Mirrors Tape\".  In addition, in\nVersion 406V, the contents of the entire SHARE MVS MODS TAPE, all\n131 files, is included.  This will allow users of the old SHARE code\nto have a place to submit fixes.  Also, that code will continue to\nremain available and useful to the public.\n\n      In summary, I think that although much of this information is\n\"on the lighter side\" and kind of peripheral, there is still quite a\nbit to be learned from it.  I always feel that no matter what you\nlearn, there will eventually be a place for it to be used and useful.\nGood luck.  See you next month.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFigure 1.   A Sample AMASPZAP Job including the correct CHECKSUM.\n\n            In load module PROGRAMA, in CSECT CSECTA, you want to\n            go to displacement +1C0 in CSECTA.  You want to verify\n            that one byte at this location contains the value X'1D'.\n            If that's true, then you want to change this value to\n            X'2D'.\n\n\n//JOBNAME JOB your jobcard goes here\n//*\n//S1 EXEC PGM=AMASPZAP\n//SYSPRINT   DD SYSOUT=*\n//SYSLIB     DD DSN=YOUR.LOADLIB,DISP=SHR      <== LOAD LIBRARY PDS\n//SYSIN DD *\n*\n* A SAMPLE ZAP TO ILLUSTRATE HOW CHECKSUMS ARE USED.\n*\n NAME PROGRAMA CSECTA\n VER  01C0 1D\n REP  01C0 2D\n CHECKSUM C1ED1D01\n/*\n//\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFigure 2.   How to calculate the CHECKSUM from your VER and REP\n            statements.  You see that zeros in the expression of\n            the module displacements, make a big difference in the\n            CHECKSUM calculation, because everything depends on\n            lining up all the numbers on a four-byte boundary.\n            Let's use, for example, the numbers from Figure 1.\n\n\n VER  01C0 1D\n REP  01C0 2D\n\n All of these numbers are strung onto a four-byte boundary and\n padded with zeros as follows:\n\n           01C01D01\n           C02D0000\n\n Then the numbers are all added together in hexadecimal arithmetic,\n to produce the CHECKSUM number.\n\n           C1ED1D01\n\n And that's all there is to it.  You see that zeros make a big\n difference.  For example, suppose the VER and REP statements were:\n\n VER  0001C0 1DF1\n REP  0001C0 2DF1\n\n which would produce the same effect in the zapped module, however\n the CHECKSUM would be calculated:\n\n           0001C01D\n           F10001C0\n           2DF10000\n\n And these three hex numbers would be added together, producing\n a CHECKSUM of:\n\n           1EF2C1DD\n\n with the overflow being ignored.  (Quite simple, really.)\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFigure 3.   This is an illustration of the modifications necessary\n            to fix the old Linkage Editor, so that the object deck\n            input can be blocked up to 32720 bytes instead of 3200.\n            Note that these restrictions are hard-coded.\n\n\n++ USERMOD(MDZ110A)  /* ALLOW LKED TO READ OBJ BLKSIZE UP TO 32720) */.\n++ VER(Z038) FMID(JDZ1110) PRE(UY93979).\n++ ZAP(HEWLFINT) DISTLIB(AOS04).\n  NAME HEWLFINT\n*                       DC    H'3200'\nVER 000AE0 0C80\n*                       DC    H'40'  ( = 3200/80 = NO OF RECDS/BLK)\nVER 000F42 0028\n*                       DC    H'32720'\nREP 000AE0 7FD0\n*                       DC    H'409' ( = 32720/80 = NO OF RECDS/BLK)\nREP 000F42 0199\n  IDRDATA MDZ110A\n++ USERMOD(MDZ110B)  /* ALLOW LKED TO READ OBJ BLKSIZE UP TO 32720) */.\n++ VER(Z038) FMID(JDZ1110).\n++ ZAP(HEWLFAPT) DISTLIB(AOS04).\n  NAME HEWLFAPT\n*                       DC    H'40'  ( = 3200/80 = NO OF RECDS/BLK)\nVER 000216 0028\n*                       DC    H'409' ( = 32720/80 = NO OF RECDS/BLK)\nREP 000216 0199\n  IDRDATA MDZ110B\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9610OC": {"ttr": 15876, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x96$\\x7f\\x01\\x00)\\x9f\\x11G\\x01\\x07\\x01\\x07\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1996-09-03T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 263, "newlines": 263, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          October 1996\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\nSam Golob is a Senior Systems Programmer working\nin New York City.\n\n\nGETTING STARTED WITH PUBLIC MVS SOFTWARE\n\n      I have a lasting debt of gratitude to Arnold Casinghino, and to\nall the other people who have contributed to the world of free MVS\nsoftware.  These folks have greatly boosted thousands of people's\ncareers by making handy tools and extensive software knowledge\navailable to them.  In more indirect ways, they have helped all the\nusers, and just about everyone else in MVS Systems Programming.\nIndirectly, public programs distributed on the public software tapes\nhave indicated new directions for IBM software developers to follow.\nMany \"new\" features of the MVS operating system have actually resulted\nfrom public software modifications and enhancements to MVS, which\nusers later demanded from IBM.  People using the \"public improvements\"\nto the system would pressure IBM through SHARE and GUIDE to include\nthese features into MVS itself.\n\n      This month, I'd like to encourage more MVS systems programmers\nto be helped directly rather than indirectly, by making their own use\nof the many tools and learning aids which are available through free\nMVS software.  Notwithstanding great pressure from the outside, IBM\n\"has its own mind\", and they often will not incorporate features\ngathered from public sources.  For example, IBM still does not plan to\nincorporate a \"dynamic exit loader\" into JES2, to my knowledge.\nHaving such a tool is a great help to anyone who writes JES2 user\nexits.  You don't have to recycle JES2 every time you want to change\nor modify one of the exits.\n\n      So, notwithstanding the improvements that IBM has incorporated,\nthe fact remains that the world of \"MVS plus public software\" still\nlooks a lot different than the world of \"MVS without public software\".\nYou, and your installation, have much to gain if you explore the world\nof public software for yourselves.\n\n      My own career boost started many years ago, when my MVS teacher\nJeff Broido flabbergasted me with a \"super demonstration\" of free\ntools that he had installed.  Today, I hope we can open these doors\nwider for many more of you, including those of you who are already\nenjoying some of the great benefits of this beautiful world.\n\n\nTHE CBT MVS UTILITIES TAPE\n\n      Where do you get started?  A logical place is the CBT MVS\nUtilities Tape, a huge public collection of MVS software and materials\nwhich is independently produced, and which can be ordered through\nNaSPA.  Additionally, Version 404 of the CBT Tape has been included in\nthe third NaSPA CD-Rom.  I have always compared this tape to a huge toy\nstore.  Any \"kid\" can take any toy off the shelf.  The toy can be kept\nand used, for no cost, provided that you make the effort to put it\ntogether.  And that's all there is to it.\n\n      Arnold Casinghino established the CBT (then called Connecticut\nBank and Trust) Tape back in 1975, when MVS was young.  At that time,\nstill in the MVT days, there were many \"user forums\" for public\ndiscussion of software improvements.  However Arnie, with enormous\ndedication, received contributions and took this tape through three\nhundred and twenty-one versions over fifteen years, until changes at\nhis installation forced him to hand the reins over to someone else.\nThe impact of Arnie's efforts has been felt worldwide, and the MVS\noperating system itself has been enormously improved through countless\nsuggestions that were born in the public forum that is this wonderful\ntape.\n\n      The present time is a \"different era\" from when the CBT Tape\nwas started.  However, even now, in an atmosphere which is being\npervaded by the extensive \"vendorization and OCO-ization of MVS\nsoftware\", a stultifying influence to the individual's creativity,\nthe CBT Tape stands as a bastion and a pillar to preserve and\ndisseminate MVS system knowledge.\n\n      As of this writing, the CBT Tape is at approximately Version\n408.  Once you obtain a copy of this tape, you are literally in a\n\"Toy Department Store\".  It will be the function of the rest of this\narticle to show you how to browse through the store, and to pick out\nall the toys that you want.\n\n\nWHAT KIND OF TOYS YOU CAN HAVE\n\n      Almost anyone who writes an improvement to the system, a tool\nto look at or manipulate a system component, or anything that helps in\ndoing the daily system work, can contribute to the CBT Tape.  And they\nhave done so.  I will list some categories of items--by no means a\ncomplete list, and you will have a better idea of what can be found.\n\n      For example, you can find:  ISPF enhancements and edit macros,\nuseful CLISTs and REXX execs, system exit examples, tape tools (tape\ncopying programs and tape mapping programs), RACF utilities (see File\n106 for an example), SMP tools (pre- and post-processors), core\nbrowsers, disk browsers, disassemblers, system status reporting tools,\nautomated operations drivers, powerful dataset and load module\nmanipulation utilities, JES2 spool browsers (JES3 tools can be found on\nthe JES3 Share-Guide Tape from Alan Field 612-828-4979), and old\nlanguage compilers which still work on today's systems.  There are huge\ncollections of TSO commands and batch utilities.  There is also a\nunique software ARCHIVER, which can store both your software source and\nexecutable code on one disk or tape file.  There are utilities to\nmanage SYS1.BRODCAST on a user level, and much more.\n\n      This list of goodies only scratches the surface.  There is a\nspecial file on the CBT Tape, File 071, which contains documentation\nfiles for many other tapes too, so you can figure out which other\npublic tapes you'd like to order.\n\n      If you yourself have done some useful work, you too can\ncontribute.  File 001 (the documentation) of the CBT Tape contains\nthe address of the tape's editor, and contributions are always\nwelcome.\n\n\nHOW DO YOU START EXPLORING THE CBT TAPE.\n\n      File 001 of the CBT Tape now is over 30000 lines long.  Although\nArnie Casinghino no longer edits the tape, his influence in helping its\nusers still pervades the documentation.  There are many \"sections\" in\nthe documentation.  You should look at the ones which are most relevant\nto you.  The beginning of File 001 now has a section called \"What to do\nwith this tape first\", which is specifically for new users of the tape.\nThis is a listing of some tape files which have wide application and\nusefulness to the public.  If you are new to the tape, and you're just\nexploring, you should begin here.\n\n      Sometimes, you want to find coding examples of a particular\nsystem exit, or you want to find the current source for a particular\nprogram whose name you know.  There is a tape mapping program on File\n299 of the CBT Tape (load module is on File 035) which will show every\nPDS member name for every file on the tape.  If you run this program,\nand copy the output to a disk dataset, you can look at the output and\nscan for any particular member name you want to find.  You can also\ncopy the documentation file (File 001) to disk, and search it too,\nin the same way.\n\n      The CBT Tape is updated frequently, and you will profit\nconsiderably by obtaining a new one every so often.  One of the sections\nin the documentation is called the \"Change Section\".  Here, changes to\neach new version of the tape are documented in detail.  You can check\nthe version number of your new tape, and you can follow all the changes\nmade since the previous tape you already had.  For example, suppose\nyour new tape is Version 408 and your previous tape was Version 397.\nIn the Change Section, all revisions and additions to files that have\nbeen made, are summarized version by version, and you can check if\nthere is something new you'd like to see.  Change entries for all\nversions from 398 to 408 can be read.  This amounts to about 280 lines\nof reading material.\n\n      The File Status Section of the documentation follows soon after\nthe Change Section.  In the File Status Section, a one-line summary for\neach of the 472 files on the CBT Tape is given.  Each line contains a\nshort title describing the file's contents, the number of records in\nthe file (number of tape blocks for load libraries), the date the file\nwas last revised (this is accurate), the tape footage occupied by that\ntape file (as though it were on a 6250 bpi reel), and the file format\n(compressed, uncompressed, or IEBCOPY).\n\n      Most of the source files are in a compressed IEBUPDTE-type\nformat, but the program which sequentializes the source PDS members\nbefore compression is not actually IEBUPDTE, but LISTPDS (from File\n316).  The LISTPDS program preserves ISPF statistics for the\nindividual members.  These are lost if IBM's IEBUPDTE program is used\nto stow the members upon reloading from the tape.  However, the\nprogram PDSLOAD (from File 093, load module on File 035), will restore\nthese ISPF statistics.  File 003 (JCL to load CBT Tape files to disk)\ncan be customized to either use IEBUPDTE or PDSLOAD.  IEBUPDTE is the\ndefault, but it is recommended that users install and use PDSLOAD, to\nkeep the ISPF statistics for the file members.  Any tape file which\ncontains ISPF statistics in this format, is marked in the File Status\nSection with an \"S\" next to the record count.\n\n      The general layout of the CBT Tape is as follows:  Files 001 thru\n005 are in fixed blocked 80-byte uncompressed format with blocksize of\n32720.  My practice is to copy these to PDS members with IEBGENER.\nFile 001 is detailed documentation.  File 002 is assembler source for\nthe Compression-Decompression program called CBT973 which is used to\ndecompress most of the tape files.  File 003 is model JCL to load the\nindividual tape files to disk.  File 004 will probably not be used.\nIt is JCL if the tape had to be broken into two, in a special format\nthat nobody uses now.  File 005 is new.  This is from George Shedlock\nand is a VM REXX exec to load the CBT Tape files onto a VM system.  It\nseems that VM'ers also can use quite a bit of the material from the CBT\nTape.  The rest of the files are the data files, described in the\n\"Documentation Section\" which details the contents of all these tape\nfiles individually.\n\n\nSUGGESTIONS\n\n      Approaching the CBT Tape all depends on what you want to do.  If\nyou have a specific thing you're looking for, you might try searching\nthe documentation for name strings, or searching the TAPEMAP of the\ntape as I mentioned before.  If you're new, look at the beginning of\nthe tape documentation, and savor slowly what you are reading.  If you\nare getting a new tape after having used an older one, go to the\nChange Section to see files which have changed since your last version,\nand go to the File Section to look at the latest dates, for accurate\ninformation about which files were changed recently.\n\n      I have an allocated PDS to which I copy the new documentation\nand the sample JCL for unloading files.  I personally make a copy of\nthis JCL and edit it to conform to my installation standards.  I also\ncustomize it for loading a few selected files at a time.  The supplied\nJCL is designed for loading all the files from the tape onto disk--\nseveral hundred files in several more hundred execution steps.  There\nare too many EXEC cards generated in the JCL for the system to handle,\nso the total JCL deck has been broken into five jobs.  Various files\nare in different formats, so there are different PROCs, one each for\nevery file format on the tape.  All of these procs are repeated five\ntimes in the supplied JCL stream.  When customizing, you need only\nmake one job with one copy of these PROCs.  When loading a particular\nfile to disk, you then need only copy the appropriate PROC execution\nstep from the sample JCL to your customized JCL.\n\n      For example, UPDATEO is one of the more frequently used PROCs.\nAfter customizing your JCL, if you want to load only FIle 316 to disk,\nyou need only copy the one line of JCL from the supplied deck, namely:\n\n//STEP316  EXEC UPDATEO,LAB=316\n\nand this will correctly load the file that you want.\n\n(Editor, the // must be at the beginning of a column.)\n\n      Another suggestion:  You know how some people read mail order\ncatalogs for fun.  Print a full copy of the CBT Documentation File\nand put it into a binder.  If you're fortunate enough to have a\nprinter which will rotate the print 90 degrees so it looks like a\nbook, that's even better.  Now you have a \"CBT Tape\" toy store\ncatalog all your own, and you can study it even more than the people\nwho read the Sears Catalog, or any other catalog they like.  This is\nthe best way to explore the real world of wonderful free MVS software,\nand to gather tons of information about various system components.  I\nhave done so, and I can talk from experience.  You can do the same.\n\n      Finally, that's not the end of CBT Tape \"madness for personal\ngain\".  There is now a \"CBT Overflow Tape\" in the same format as the\nregular CBT Tape, which contains a lot of older code from various\nsources that were not easily accessible.  The CBT Overflow Tape can be\nordered from the NaSPA office also, although it too is independently\nproduced.\n\n      At this point, when we're about to end, I must be apologetic\nfor not mentioning many \"real hints and specific tips for problems\"\nthis month.  However, if you obtain the CBT Tape materials (tape or\nCD-Rom) and do some exploring, you'll come across more hints and\ntips than you know what to do with.  And it is highly possible that\nsome old utility which your company has been using for years, can be\nupgraded to a modern and enhanced version.  At least, you can find\nsource code for it.  Public tape exploration in general, and CBT\nTape exploration in particular, is a profitable business.  Try it.\nYou'll like it.  See you next month.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9611NV": {"ttr": 15881, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x96(?\\x01\\x00)\\x9f\\x11G\\x00\\xda\\x00\\xda\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1996-10-09T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 218, "newlines": 218, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         November 1996\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\nSam Golob is a Senior Systems Programmer working\nin New York City.\n\n\nALTERNATIVES AND DATASET RECOVERY\n\n      Once upon a time in my career, I used to sell shoes.  Back then,\namong my clientele, it was common to hear the expression:  \"Sometimes\nthe shoemaker goes barefoot.\"  Recently, a similar thing happened at\nmy shop.\n\n      In our place, we have a person who is an expert at DASD and SMS\nadministration.  This person was in the middle of setting up SMS on\none of our LPARs which didn't use SMS, and he put in many hours of\nwork figuring out all the rules that would be needed.  These were all\nplaced in a partitioned dataset he had, on his own disk pack.  One\nday, he came to me very disturbed; he had accidentally deleted this\npds.  I asked him if there was any full-pack backup, and he said\nno--his private pack was not in the shop's backup schedule.  I asked\nhim if he HBACKed the pds, and he told me that most of his work was\ndone from the side of the shop that is not running HSM.  In short, he\nwas stuck.  Our expert shoemaker was indeed, temporarily barefoot.\n\n      What did he come to me for?  He wanted to see if I could\n\"un-delete\" his PDS.  I told him I would try.\n\n      As you undoubtedly know, un-deleting a PDS is highly non-trivial\nin the MVS system.  The VTOC and index entries get deleted, although\n(usually) the data is still there.  Un-deleting a dataset involves\ncreating a new VTOC entry, with the correct dataset attributes, that\npoints to the correct data, including all its previous extents.  I have\nsome personal experience doing this, and have written about the subject\nbefore.  (\"A VTOC Adventure - Part 3\" in this column, June 1995.)  But\nthe MVS operating system and DASD structures have changed subtly since\nthen, as we shall see.  This process is not as straightforward as it\nonce was.\n\n      What I had to do, was to un-index the disk pack using ICKDSF\nwith its OSVTOC command.  Then I had to find the data on the disk\npack.  I looked for available extents with a track mapping tool\n(any \"MAPDISK\" type utility will do - I used IEHMAP from File 083\nof the CBT MVS Utilities Tape, which can be ordered through NaSPA).\nThen I had to verify that the deleted data was what I wanted to\nrestore, so I had to look at it, using the Fullscreen Zap TSO command\nfrom File 134 of the CBT Tape, in FULLVOL mode, using ZAP's absolute\nCCHHR display, and looking at record 1 from the available extents\nshown by IEHMAP.  I had to make sure I had the correct deleted data.\n\n      Then I used the free Fullscreen ZAP command again to look at the\nVTOC.  First, I had to find an unused (Format 0) VTOC entry, and then\nI had to create from it, a Format 1 VTOC entry which pointed to the\ncorrect data, with dataset attributes that were like the ones the\noriginal dataset had.  This was by means of direct zapping of the\nblank VTOC entry, to create a Format 1 entry to point to the deleted\ndata.  I have written this up in my June 1995 column (all of my\nprevious columns can be found on File 120 of the CBT Tape), but the\nprocedure is quite delicate, because all of the VTOC fields have to be\nright.  After I got done with the VTOC entry, all the member data was\nstill there, since the directory was still in place.  I thought I was\njust about finished.  All that needed to be done at this point, was to\ncopy all the members from this reconstructed pds into a \"healthier\"\npds which was created the regular way.  It looked as if we were home\nfree.\n\n      That's where we were in for a shock.  It seemed that with our\nsystem configuration, IEBCOPY had some kind of bug, and it deleted all\nthe pds members before they could be copied out.  I now had to restore\nall the deleted pds members, by recreating directory entries for them.\n\n      There are several ways to restore deleted pds members without a\ntremendous amount of effort.  See the PDSGAS program from File 316 of\nthe CBT Tape, or the RESTORE subcommand of the PDS command processor\nfrom File 182 of the CBT Tape, or the FIXPDS utility from File 036 of\nthe CBT Tape.  I went and restored all the pds members, using names\n$$000001, $$000002, etc. with this sort of tool.  After that was all\ndone, I turned the restored pds back over to my colleague, so he could\ncopy the members to another pds.\n\n      Again IEBCOPY failed.  Both my colleague and I tried it several\ntimes, and IEBCOPY wiped out all the members, so I had to keep\nrestoring them again.  I needed another way to save the members and\ncopy them out, so my colleague's work didn't have to be duplicated.\n\n      Fortunately, we have alternatives.  It seems that IEBCOPY opens\nits input dataset for INOUT, and therein lies the problem.  If we could\nfind a copying utility which just opens the input dataset for INPUT\nand straightforwardly copies the members, we would be home free.  There\nare actually many alternatives we could try.  First, we might try to\noffload the members of the pds, in IEBUPDTE format, to a sequential\ndataset, and then reload them into a new partitioned dataset.  If IBM's\nIEBUPDTE would'nt work, we could try the LISTPDS program (from File 316\nof the CBT Tape) which does a similar job.  Or we could try the OFFLOAD\nprogram from File 093 of the CBT Tape.  Or we could use the REVIEW TSO\ncommand from File 134 of the CBT Tape.  With REVIEW, you allocate a\nsequential output dataset to the SYSUT2 ddname.  Then you REVIEW the\npartitioned dataset and get a directory listing for it.  Finally, in\nthe eight-byte input field at the top of REVIEW's directory screen, you\nenter the command, \"=OFFLOAD\", and REVIEW will write all the members in\nIEBUPDTE format, to the sequential dataset.  Still another alternative\nwould be to use the new COPY facility in later versions of the REVIEW\ncommand.  That facility allows you to COPY anything you are browsing on\na REVIEW screen, into another dataset that has been previously\nallocated to the SYSUT2 ddname.\n\n      What I actually did, was to use an alternative member-copying\nutility in a vendor product, which EXCP'ed the input member data on\nthe read, and BSAM'ed it out to an output pds as a new member.  This\nworked fine, because only the member data was read, and the input\ndataset as a whole was not mucked with.  The actual tool was the DUP\nsubcommand of the PDSTOOLS (now called STARTOOL) product from Serena\nin Burlingame, California.  Other alternatives could surely work also.\nYou just have to think, using your system knowledge, your tool\nrepertoire, and your creativity.  But my main point with this story,\nis that you should acquire a large collection of alternatives.  As a\nresult of all my experiences, I never say that if there is one tool to\ndo a job, I don't need another.  I always look for alternative tools\nto do the same job.  When one tool doesn't work, another tool just\nmight.\n\n\nRECOVERING DATA FROM DAMAGED DATASETS.\n\n      Sometimes, hopefully rarely, one comes across a situation where\na disk dataset is damaged in one or several places, but you need the\ndata.  It would be extremely helpful in such a case, to save whatever\ngood data you can.  Again, my approach to the subject is:  one tool is\ngood to have, two tools are better to have, and the more tools, the\nmerrier.  Many MVS shops have bought IBM's MVS DITTO product, which is\nquite good in such a case.  You can use DITTO to copy off a bunch of\nrecords until just before the I/O error in the file.  Then you can use\nDITTO to skip the bad area, and copy off more good records.  And so on,\nuntil you have saved as many good data records as you could.\n\n      There is another way, however, which is a batch program that is\nmuch quicker.  This is a program called RECOVER.  RECOVER originally\ncame from the University of Waterloo in Canada.  Currently, RECOVER is\non the CBT Tape in File 455, as part of Paul Moinil's excellent and\nlarge collection of system programmer tools, taken from \"everywhere\".\nPaul Moinil is a highly skilled systems programmer who works in Ispra,\nItaly, and who has compiled a large collection of extremely useful\ntools, many of which he has modified.  RECOVER's function is to\nautomate the process of sequential dataset recovery, which we briefly\ndescribed above.  RECOVER works by copying the damaged dataset, but\nwhen it comes to an I/O error, it skips to a pre-specified good area\nwhich follows, and then copies further.\n\n      RECOVER works something like IEBGENER, but for damaged datasets.\nThe SYSUT1 ddname points to the input, the damaged dataset.  SYSUT2\npoints to an output dataset, to which RECOVER will copy records from\nthe input dataset, according to instructions specified by the PARM\nfield.  DCB information from the input dataset is always copied to\nthe output dataset, so as to avoid additional problems.\n\n      The parms work as follows:  There are four keywords, COUNT,\nSTART, POINT, and WRITE.  These can optionally be abbreviated to C, S,\nP, and W respectively.  COUNT=N specifies the number of I/O errors or\nend-of-files the program is to accept (default=1).  START=XXXXXXXX\nspecifies the relative track and record beyond the start of the\ndataset where the recovery is to start.  The value given is in TTRZ\nformat in hex (default=00000000, which is the very beginning of the\ndataset).  If the input dataset is a pds, START=00000000 will copy the\ndirectory as part of the output dataset with DCB attributes of the\ndata.  Of course, the directory will be useless as a directory, but\nyou can edit it out later.  POINT specifies the type of skipping that\nis to be done if the program encounters bad data.  Valid values are T,\nR, or Z, corresponding with TTRZ format.  In other words, do you want\nto skip to the next track (POINT=T) or the next block on that track,\n(POINT=R) or the next block in the dataset, in whatever track or\nextent it falls (POINT=Z)?  Default is POINT=Z.  My opinion is that\nPOINT=Z is probably safest.  Finally, the WRITE keyword specifies\nwhether you want to write a partially filled input buffer out to the\noutput dataset.  The idea is:  You never know when you'll encounter an\nI/O error.  At the time, you'll probably have a partially filled input\nbuffer.  Do you want to write these records to the output dataset, or\ndo you want to discard them?  WRITE=Y tells RECOVER to write out\npartially filled buffers at the time of I/O errors.  WRITE=N tells the\nprogram to discard the records in the partially filled buffer\n(default=N).\n\n      So now you see that RECOVER, if you make the effort to set it up,\ncan save you oodles of time, on occasion.  Instead of playing games\nwith DITTO for an hour or more, you can set up this batch job, and see\nwhat sort of recovery data it gives you.  If the recovery data is\nsufficient, then fine.  Otherwise, you can play with RECOVER's parms,\nand see if another run will give you more satisfactory results.\n\n      There is one more alternative I'd like to suggest, as space will\nallow.  This our old favorite browsing tool, the TSO command called\nREVIEW from File 134 of the CBT Tape.  More recent versions of REVIEW\nhave the capability of copying the data that you are browsing.  The\noutput dataset is pointed to by previously allocating the SYSUT2 ddname\nto it, under your TSO session.  COPY and ADD subcommands of REVIEW\nwill copy data to the output dataset or append additional data to it.\nYou can control how much data you want to COPY or ADD with additional\nkeywords.  At this point, it is apparent that REVIEW can be used for\ndata recovery purposes, in much the same way as we described for DITTO,\nexcept that with REVIEW, you see the data in a more natural format.\n\n      This month, I've made several points:  First, the more ways you\ncan do a job, the safer you are, in case one of them won't work.\nSecond, some tools are quicker than others which do the same job.  A\nquicker utility will save you valuable time in a pinch.  Third, the CBT\nMVS Utilities Tape contains many collections of such tools to explore.\nMaking an investment in time, with the CBT Tape and other software tool\nsources, including your shop's vendor products, will expand your skill\nrepertoire, and you'll gain the time back in the long run.\n\n      Good luck in all your endeavors, and I hope to see you again\nnext month.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9612DE": {"ttr": 16129, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x961/\\x01\\x00)\\x9f\\x11G\\x01\\r\\x01\\r\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1996-11-07T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 269, "newlines": 269, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         December 1996\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\nSam Golob is a Senior Systems Programmer working\nin New York City.\n\n\nON FINDING THINGS\n\n      This month, I'd like to discuss some novel approaches to solving\nsystem programming problems, all of which have to do with finding\nthings.  Once you see some examples and you understand what we're\ndoing, you'll be able to come up with your own extensions to these\ntechniques, or you can use them as is.  I can testify that many\nproblems which seemed difficult to approach with other methods, have\nfallen rather quickly when they were looked at from this angle.\n\n      There are several different categories of \"finding\" which will\nconcern us.  Each category is a different type.  The overall watchword\nfor all of them is \"speed\".  Also, the reason I am mentioning these\nparticular categories here, is that standard IBM MVS techniques leave\nlarge gaps in all of the areas we will talk about today.  I'd bet that\nmany sysprogs, hearing what we're doing, will say:  \"I really didn't\nknow there was a way to do that!\"\n\n      Let's start our discussion with an overview of the different\ncategories of \"finding\" that we will talk about.  First, is the\nproblem of finding all occurrences of a particular member name in a\nconcatenated list of partitioned datasets.  This category lies at the\nroot of many common system problems.  For example, suppose you have\nseveral versions of the same program name in various libraries of the\nlinklist concatenation, and you've encountered an error in this\nprogram's execution.  Are you executing the right version of the\nprogram?  This situation has to be diagnosed correctly.  Another\nexample:  Suppose you have a jobstream which executes cataloged\nprocedures.  Is the job executing the correct version of your PROC?\nMaybe there are multiple versions in different libraries, and the\ncorrect PROC wasn't in a library that's higher in the list than an\nincorrect PROC.  In modern versions of JES, the name of the procedure\nlibrary containing the PROC is reported.  That's good once the job was\nrun.  But to diagnose the situation beforehand, or to obtain other proc\nlibraries containing a PROC with this name, do you have a good\ntechnique?\n\n      The next category involves finding all occurrences of a data\nstring which occur in multiple pds members, or in an entire library.\nIf this can be done quickly, there are myriads of system problems which\ncan be diagnosed using such an approach.  In former times, I would use\nthis method to discover the causing component of IBM system problems.\nThis is an example of the way it worked.  Suppose I had a system problem\nthat produced an unusual IBM message.  I would search SYS1.LPALIB for\nall occurrences of the message string (or part of it).  This would show\nme some module names, and the message string within the load module.\nThen I would look in the Logic Manual (remember those?) to see how the\nmodule worked, and I would look in IBMlink or call the Support Center\nto see if any APARs were reported for these modules.  Of course,\nnowadays the message manual often reports which module produced each\nmessage, but even so, this information isn't always mentioned for some\ncomponents.  Our technique is still very handy nowadays as a backup\nsource of information.\n\n      A third category involves creating a list of all member names\nin a pds which contain a specific data string.  This can be used in\nconjunction with \"find-replace\" maintenance.  For example, suppose a\ndataset is renamed, and you want to find all JCL streams or PROCs\nwhich reference the dataset.  Then you can edit each member\ncontaining the dataset name, and fix it properly.  Another example:\nSuppose you are searching in your own large JCL library, or in\nsomeone else's JCL library, and you want to find an example of an\nIEBCOPY or an IEHINITT job.  If you have an appropriate searching\ntool, you can come up with a list of members containing PGM=IEBCOPY\nor PGM=IEHINITT, or whatever string which would be indicative of the\ntype of job you are looking for.\n\n      All of these three \"finding categories\", if they can be\nimplemented with speed, can greatly help any system programmer in many\nareas of our everyday work.  In the rest of this column, I'll try and\nsuggest possible tools, among free products or vendor products, which\nwill help achieve these results.  Many free tools can be obtained from\nthe CBT MVS Utilities Tape, an independently produced huge software\ncollection, which can be ordered through the NaSPA office.  In this\ncolumn, I often refer to tools in various files of the CBT Tape, because\nthose materials can be obtained by any MVS shop, without requiring a big\nbudget.\n\n\nFINDING MEMBERS IN A DATASET CONCATENATION\n\n      The principal MVS service which detects the presence or absence\nof a member in a partitioned dataset is the BLDL service which is\nimplemented in SVC 18 (module IGC018).  BLDL can either be run against\nan individual dataset or a concatenation.  There is one hitch.  If a\nutility runs BLDL against a dataset concatenation, only the first\noccurrence of the member is reported.  Other occurrences afterward can\nonly be shown if the utility opens the datasets following as individual\ndatasets.\n\n      REXX also has an implicit BLDL service built into it,\nimplemented by the SYSDSN keyword.  My late colleague, Tony Forte,\nwrote some nice REXX execs which take advantage of this service.\nTony's REXX execs may be found on the CBT MVS Utilities Tape, File\n219.  Tony's LNKLOOK exec searches all of the Link List libraries for\noccurrences of a load module name.  One enters LNKLOOK followed by a\nmodule name, for example:  LNKLOOK IEFACTRT.  Tony's JESLOOK exec finds\nall occurrences of a PROC name in all the libraries of the JES2 proc\nPROC00 concatenation.  For example, one enters:  JESLOOK CAS9 to find\nall occurrences of the PROC CAS9 in all PROC00 proclib libraries.\nSample results from these two REXX execs are shown in Figure 1.\n\n      A brand new tool in this category has been introduced with\nISPF Release 4.2.  It is a TSO command whose name is ISRDDN.  If you\ntype the command TSO ISRDDN on an ISPF command line, a panel displaying\nall the dataset allocations in your TSO session will be shown.  Line\ncommands and primary commands may be entered on this panel.  If you\nenter the primary command MEMBER followed by a member name, all datasets\nallocated to your TSO session which contain that member name will be\nmarked.  It is easy to see how you can use this tool.  Simply run a\nCLIST that allocates a dataset concatenation you want to look at, and\nthen, in ISRDDN, enter its MEMBER primary command using the name you\nwant to search for.  ISRDDN has many other functions also.  It is worth\nyour while to invest some time learning how to use it.\n\n      A third type of tool that is in this category is a free TSO\ncommand called LOCATE, which works for load modules.  One place where\nyou can find source code for this type of program is on File 270 of\nthe CBT Tape.  LOCATE will show occurrences of any program name, if it\nexists on your system.  The program version on File 270 will (by\ndefault) show the first occurrence of the program and (optionally)\nshow all occurrences of the program.  I have seen other versions of\nLOCATE which behave a bit differently, but they are all useful.  One\ngood use of LOCATE, since it shows TTR disk locations of the program\nname, is to verify if an LLA refresh of the program was done.  LOCATE\ndoes a BLDL for the program name, and BLDL uses the LLA service.  If\nno refresh for a new program version has been done, LOCATE will show\nLLA's TTR location for the program, while a purely disk-based\nbrowser, such as REVIEW (CBT Tape File 134) will show the new TTR\nlocation.  If they differ, you know that the LLA refresh was not yet\ndone.\n\n\nFINDING STRINGS IN PDS MEMBERS\n\n      The \"champion tool\" that I've found in my work, which finds\nstrings in partitioned dataset members (source or load), is the PDS\nTSO command that can be found on File 182 of the CBT MVS Tape.  There\nis a stabilized free version of \"PDS\", Version 8.4, on the CBT tape,\nwhich is available to all.  The currently supported version of PDS is\na vendor product called STARTOOL (formerly PDSTOOLS) that is\ndistributed by Serena International of Burlingame, California.  I do\nnot like to write about vendor products in this column.  But I am\nmentioning both products here, because for this purpose, although the\nvendor product is much better and has PDSE support, the free version\nis good enough.  \"Free PDS\" will be very helpful to shops that don't\nhave STARTOOL.\n\n      The PDS command can be used in either of two modes:  line mode\nor ISPF mode.  Internally to the product, the ISPF mode is referred to\nas ISPMODE.  ISPMODE operation of PDS is generally the better way to\ngo, but most of our techniques will operate in either mode.  Line mode\noperation of PDS will also work under TSO-in-batch.\n\n      The PDS command must point to a dataset.  We will give an\nexample.  Suppose we want to find all occurrences of a message string\nin SYS1.LPALIB.  If PDS is installed, we issue the command:  PDS\n'SYS1.LPALIB'.  Once we enter PDS, either in line mode or ISPMODE,\nwe enter a subcommand, FIND.  Our purpose is to find all occurrences\nof a message string in all members of SYS1.LPALIB, or in a subgroup\nof members.  PDS keeps track of subgroups of members in many ways,\nbut once a subgroup is established, the user can reference the current\nmember subgroup with an asterisk, '*'.  If the user wants to reference\nall members of a pds, a colon ':' is used.\n\n      To accomplish our immediate purpose of finding all occurrences\nof a data string in SYS1.LPALIB, we enter the subcommand:\n        FIND : /string/\nThe result of this command is a quick summary of all occurrences of\nthe data string in the entire SYS1.LPALIB.  This will accomplish the\naim of the second category of \"finding\" which we mentioned above.\nHowever, the usefulness of the PDS command does not stop there.\nWe can easily accomplish the aim of the third category of \"finding\",\ntoo.\n\n      The FIND subcommand of PDS has THEN and ELSE logic attached to\nit.  You can create a member subgroup which consists of all members\nin which the data string has been found.  This can be done in several\nways, but the most general is to enter the subcommand under PDS:\n        FIND : /string/ THEN(SUBLIST)\nThe result of this command is that a member subgroup is created, which\nconsists of a list of only those member names which contain the\nspecified data string.  As we mentioned before, this subgroup of\nmembers can be referred to, in subsequent PDS subcommands, by using an\nasterisk '*' instead of the colon ':'.\n\n      Let's finish by showing how PDS can easily accomplish the third\ntype of \"finding\".  Suppose we have changed a dataset name, mentioned\nfrequently in SYS1.PROCLIB, from SYS1.USER.LOADLIB to SYS1.USERLIB.\nTo fix all JCL in SYS1.PROCLIB, simply point PDS to SYS1.PROCLIB using\nthe initial command:  PDS 'SYS1.PROCLIB', or if PDS is already running\nand is pointing to a different dataset, enter the subcommand:\nCHANGE 'SYS1.PROCLIB'.  To establish a member group containing the\nstring, SYS1.USER.LOADLIB, enter the subcommand:\n        FIND : /SYS1.USER.LOADLIB/ THEN(SUBLIST)\nThen, we can do either of two things.  In ISPMODE, we can create a\nmember sublist consisting of only members containing the string\nSYS1.USER.LOADLIB.  This will enable us to conveniently edit only\nthose members, using the ISPF editor.  The PDS ISPMODE command which\ndoes this is:  MEMLIST * RESET .  PDS also has an additional \"string\nreplacement\" feature which does an in-place rewrite of the records.\nThe string replacement is invoked using the PDS \"REPLACE\" subcommand.\nOne invokes the command:\n        REPLACE * /SYS1.USER.LOADLIB/SYS1.USERLIB/\nto do a dry run and display the results of the string replacement.\nThis may be done with PDS running in line mode or TSO-in-batch.\nTo make the changes final, enter:\n        REPLACE * /SYS1.USER.LOADLIB/SYS1.USERLIB/ WRITE\nThat's all there is to it, folks.  Mission accomplished.  If you try\nthe PDS command for yourself, you'll also see that it works very fast.\n\n      I trust that the techniques we've mentioned this month will\nbe helpful to you.  In the past, I've been able to make short work\nof some humongous tasks, using them.  At the very least, they are\ntime-saving and very convenient.  Good luck and \"happy finding\".\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   Outputs of Tony Forte's LNKLOOK and JESLOOK REXX EXECs.\n\n\n            This is an abbreviated sample output to the command:\n\n              LNKLOOK IEFACTRT               (for example)\n\n\nLINKLIST SEARCH ROUTINE\n-----------------------\nSYS1.LINKLIB                             OK\nSYS1.MIGLIB                              MEMBER NOT FOUND\nSYS1.CSSLIB                              MEMBER NOT FOUND\nSYS1.USER.LINKLIB                        OK\nSYS1.ANO.USERLNK                         MEMBER NOT FOUND\nISP.ISPLOAD                              MEMBER NOT FOUND\nISR.ISRLOAD                              MEMBER NOT FOUND\n\n  - - - - - -  DATA ABBREVIATED FOR BREVITY  - - - - - -\n\n\n\n            This is an abbreviated sample output to the command:\n\n              JESLOOK CAS9\n\nJES2 SEARCH ROUTINE\n-----------------------\nSYS1.PROCLIB                                 MVSCAT OK\nSYS1.USER.PROCLIB                            MVSUSR MEMBER NOT FOUND\nSYS2.CICS.PROCLIB                            MVSSYS MEMBER NOT FOUND\nSYS1.ONLINES.PROCLIB                         MVSSYS MEMBER NOT FOUND\nCAI.CAIPROC                                  MVSUTL OK\nCANDLE.PROCLIB                               MVSUTL MEMBER NOT FOUND\n\n  - - - - - -  DATA ABBREVIATED FOR BREVITY  - - - - - -\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9702FE": {"ttr": 16134, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x965\\x8f\\x01\\x00)\\x9f\\x11G\\x014\\x014\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1996-12-23T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 308, "newlines": 308, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         February 1997\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\nSam Golob is a Senior Systems Programmer working\nin New York City.\n\n\nCREATIVE ENQUEUING.\n\n      This month, I'd like to talk about two ways how I used ENQUEUE\nprocessing, which arose in my work.  These specific cases may seem to\nbe a bit far-fetched when looked at in an isolated way.  But they\nillustrate the way enqueues, deques, and reserves are actually used by\nthe operating system, to protect the use of system resources.  If you\nfollow what I'm going to be talking about, you yourselves will be able\nto use these same principles creatively, in your own work, to solve\nyour own problems.\n\n      What is enqueuing?  IBM created this process to deal with a\nsituation when two different tasks want to access the same data, or\nto use some system facility.  This data or system facility might be\nsensitive to the fact that it shouldn't be accessed or updated by two\nindependent jobs at the same time.  We want to make one of the jobs\nwait until the other is finished accessing the data, or using the\nfacility.  Then the other job will be able to go in and \"do its thing\",\nseparately from the first job.  In this way, the data's integrity will\nbe preserved, or the system facility will be able to work in the way\nit was designed.\n\n      What is the mechanism of this process?  How is it done?  What\nhappens is that each job that wants to use a resource, creates an\nobject called an ENQUEUE.  This enqueue can be either EXCLUSIVE or\nSHARED.  Jobs or tasks which possess a shared enqueue can all use the\nresource concurrently.  A job or task which possesses an exclusive\nenqueue is the only one which can use the resource at this time.  Other\njobs or tasks possessing the same enqueue, either shared, or exclusive,\nare put into a wait state by the operating system, until the possessor\nof the exclusive enqueue releases (or \"dequeues\") its enqueue.\n\n      What is this object called an enqueue, and how is it created?\nAn enqueue is created inside a running program, by the use of the ENQ\nor RESERVE macros, and it is released by the DEQ macro.  The process\nis a bit more complicated, because an enqueue consists of three\nseparate parts, and they all must match exactly, in order for the\nenqueue to be effective.\n\n      What are the three parts of an enqueue?  These are, the QNAME,\nthe RNAME, and the SCOPE.  The holder of an exclusive enqueue cannot\nstop another job or task, causing it to wait, unless the other task\nis also holding an enqueue with the exact same QNAME, RNAME, and SCOPE.\nIf the other job has an enqueue which differs, however slightly, in\neither QNAME, or RNAME, or SCOPE, it will not be stopped, and the whole\nmechanism will be ineffective.  You see, that the programming to protect\na resource using enqueues, has to be very well coordinated among all\nthe resource's potential users.\n\n      IBM, from within its own programming of the MVS operating system,\nhas created its own enqueues consistently.  If any of IBM's own enqueues\nwill be found to be defective, this is a bug, and it must be reported\nas a programming error to IBM.  Users who create their own application\nprogramming systems, can also use the enqueue-dequeue mechanism to\nprotect the resources which they create themselves, provided that they\nare internally consistent in creating and releasing the enqueues.  There\nare several helpful IBM manuals, both for users, and for system\nprogrammers.  Among these, are:  \"Application Development Guide:\nAssembler Language Programs\" (GC28-1644), and \"Application Development\nReference:  Services for Assembler Language Programs\" (GC28-1642).\nFor authorized programs there is the multi-volume:  \"Application\nDevelopment Reference Services for Authorized Assembler Language\nPrograms\".  All these manuals are available on IBM's CD-rom online\nlibrary \"MVS Collection\" of manuals.\n\n      Today, in our role as system programmers, we will try and break\nin to a few of IBM's enqueues.  In the process, we will learn very\nmuch, about how exact this system is.  Once we see what is going on,\nand we gain familiarity with the enqueue process, we will be able to\nwrite more of our own similar programs, and we will be better able to\ndiagnose system problems in the enqueue area, that will arise in our\ndaily work from time to time.\n\n(Editor:  Please keep the \"we\" in the previous paragraph.  The reason\n is that \"I\" know how to do this stuff, but if \"we\" go through it\n together, then the readers will pay attention, because they are\n part of the process.  Thanks. )\n\n\nTRACKING AND DISPLAYING ENQUEUES\n\n      How can we look at an enqueue in all its detail?  Actually, we\ncan start with a console display that is quite effective.  This is the\n\"DISPLAY GRS\" command with the \"RES=\" keyword.  The relevant syntax of\nthis command is:\n\n       DISPLAY GRS,RES=(qname,rname) ,HEX\n\nwhere HEX is optional.  The HEX operand is useful because qnames and\nrnames can be quite arbitrary.  The qnames can be up to 8 characters\nlong, and the rnames much longer--at least up to 60 characters and\nprobably more.  In the \"D GRS\" command, you can use the asterisk '*'\nas a wild-card indicator in either the qname or rname fields.  This\nwildcard capability can be used to discover the qnames or rnames in\nyour enqueue if you are not completely sure of them, or if you only\nknow part of the name.\n\n      The \"D GRS\" display will come back on the console with\nconsiderably detailed information about the structure of the enqueues.\nSee Figure 1.  You have to examine the SYSLOG with SDSF or whatever\nSYSLOG browsing tool you have, to see the details clearly.  Otherwise\nthey will roll off the screen, most likely.  Once you have examined\nthe \"D GRS\" display, you will know quite a lot about the enqueues you\nare concerned with.\n\n      The \"D GRS\" display has some limitations.  On a recent NVS/ESA\nsystem, the length of the RNAME display is limited to only 49\ncharacters.  Sometimes, the actual RNAME is bigger, as we shall soon\nsee.  Also, \"D GRS\" cannot limit the display by owning jobname,\nalthough it displays the jobname.  In all, though, \"D GRS\" is a very\nuseful display, and its CONTENTION keyword is quite useful for finding\nsystem bottlenecks caused by conflicting enqueues.  Full syntax of the\n\"D GRS\" command can be found in the \"MVS System Commands\" manual that\nis current for your version of MVS.\n\n      What other tools do I know about for displaying enqueues?  I once\ncalled GRS Level 2 support because I couldn't display an enqueue with a\nlong rname.  The technician told me that he wrote a program to display\nlong rnames, and he could send it to me.  This program, which you run\nfrom a cataloged procedure, can now be found on File 250 of the CBT\nMVS Utilities Tape, a huge free software collection that can be obtained\nthrough the NaSPA office.\n\n      Most vendor-written performance monitors have good enqueue\ndisplays.  I have access to OMEGAMON from Candle Corp. which has its\nWHO and XQCB commands.  The other big performance monitors are\nprobably just about as good.  I myself have used a very fine monitor\ncalled IMON that is written by Greg Price of Melbourne, Australia, and\nwhich is a vendor product.  IMON is a TSO command and is very compact,\nuser friendly and simple to run.  However IMON has a very large array\nof capabilities.  IMON is distributed in Sydney, Australia by the\n\"Press Enter Group\", email address:  www.pressenter.com.au .  See\nFigure 2 for a small sample of IMON's enqueue displays.\n\n\nTWO PROBLEMS INVOLVING ENQUEUES\n\n      I have had two recent problems which helped me to gain some\nexperience with enqueues, and I wish to share them with you.  The first\nproblem involved trying to temporarily and \"harmlessly\" stop JES2 on a\ntest system for a test.  The second involved my work with the\nSYS1.BRODCAST dataset.  See this column from July 1995.  (All my\nprevious columns may be found on File 120 of the CBT MVS Tape.)\n\n      Subsequent to writing that column, I wrote a package of\nutilities to manage all the user messages in SYS1.BRODCAST.  I wrote\nthree different programs for deleting all the broadcast messages to\nany particular TSO user.  These programs were each based on different\nmechanisms, but in the third program, called BCMDEL2, I went into the\nSYS1.BRODCAST dataset myself, and physically displayed and deleted all\nof the user's messages, instead of calling IBM's LISTBC program to do\nthe work.  Therefore, I had to imitate IBM's enqueues that are created\nby the SEND and LISTBC programs, to protect the integrity of the\nSYS1.BRODCAST dataset while my own program, BCMDEL2, was doing its\nstuff.  My SYS1.BRODCAST utilities may be found on File 247 of the CBT\nTape, but unfortunately the correct enqueue protection in BCMDEL2 only\nfound its way to the tape in Version 409.  The NaSPA CD-rom is more\nback-leveled and contains Version 404, so you need to get a new tape\nto see my correct code.\n\n      Now to the details of the first problem.  Why did we have to\nstop JES2?  One of our remote users claimed to have \"irrevocably\"\nlost data from one of its RJE transmissions, during a time when JES2\nwas hung with an enqueue lockout (\"a deadly embrace\").  JES2 obtains,\nat intervals, an exclusive RESERVE enqueue to its checkpoint dataset.\nA RESERVE enqueue ties up the disk pack, as well as locking out other\njobs from obtaining the same enqueue.  There happened to be another\njob which wanted an exclusive enqueue to a dataset on the\ncheckpoint's pack, in such a way that JES2 was hung until the other\njob was cancelled.  We had to duplicate this situation under test\nconditions, since we certainly would not want to stop JES2 on a\nproduction system.\n\n      I decided to write a program in the form of an authorized TSO\ncommand (since I was breaking into an IBM system enqueue) that would\nask for an exclusive RESERVE enqueue to the JES2 checkpoint dataset,\nand then WAIT indefinitely, without posting the WAIT ECB.  I could\nfree JES2 again by ATTENTION'ing my TSO command or cancelling my TSO\nsession.  This would be a wonderful way to control the test.  The\nremote users would start a transmission, and during the transmission,\nI would \"hang\" JES2 purposely.  Then we could see what would happen.\n\n      The problem was that I would have to exactly imitate JES2's\nenqueue to the checkpoint dataset.  I knew from looking at JES2's\nenqueues, that the QNAME is SYSZJES2, and the beginning of the RNAME\nconsists of the 6 character volume serial that the checkpoint dataset\nis on, followed immediately by the dataset name of the checkpoint\ndataset.  The enqueue was a RESERVE with a scope of SYSTEM.  I wrote\nthe program with this in mind, and found that it did not stop\nanything.  It was then that I tried the \"D GRS\" display in HEX, and\nfound that the RNAME of the enqueue was padded with blanks as far as\nthe display would go.  I couldn't actually know how long the RNAME\nreally was.  If you look at Figure 1, you'll see how the RNAME of\nJES2's RESERVE enqueue to the checkpoint dataset is padded with\nblanks.  The actual length of this RNAME, I think, is 50 or 51\ncharacters.  I tried lengthening my own enqueue's RNAME, one character\nat a time, until I got my TSO command to successfully stop JES2.\n\n      Stopping access to SYS1.BRODCAST by IBM's SEND and LISTBC commands\nwas a completely different problem.  From looking at SEND's enqueues\nwith IMON, I saw that the QNAME was SYSIKJBC, and the RNAME was usually\na three-byte hex number.  Sometimes the number was X'000000', and\nsometimes it was something else.  The enqueue was EXCLUSIVE, not a\nRESERVE, and it had a scope of SYSTEM.\n\n      From my knowledge of the structure of SYS1.BRODCAST (which is\na direct access dataset with relative record addressing from the\nbeginning), I saw that the RNAME of X'000000' was an enqueue on the\nheader record of SYS1.BRODCAST, and the nonzero RNAME was an enqueue\non the relative record address which contained that TSO user's userid\nrecord.  With this knowledge, and with my intention about what my\nprogram should do, I carefully was able to protect SYS1.BRODCAST\nwhile my program did its message deletions, and all was happy.\n\n      I have not treated the subject of enqueues here with any\nthoroughness, and there are many gaps in what I have said.\nNevertheless, I hope that this month's article will whet your appetite\nto explore this area.  If you have a performance monitor, it would be\nnice to watch its enqueue displays with variations, so you can see\nwhat enqueues the various system components throw out.  You might do\nsomething similar with the \"D GRS\" display, but try and do the display\nonce, or a few times, looking at SYSLOG afterwards, so you don't\nconfuse the operators with all the console messages.\n\n      Good luck and good hunting.  I hope to see you again next month.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.    Illustration of MVS's DISPLAY GRS command to display\n             the details of outstanding ENQUEUEs.  When datasets are\n             allocated, the system uses a qname of SYSDSN and an\n             RNAME of the dataset's name.  The RESERVE enqueue on the\n             JES2 checkpoint dataset is more complicated.  Its QNAME\n             is SYSZJES2, while its RNAME starts with the checkpoint\n             volume followed by the checkpoint dataset name.  The\n             RNAME is padded with blanks past the end of the display,\n             to 50 characters.\n\n\n\nD GRS,RES=(SYSDSN,SYS1.PARMLIB)\nISG020I 11.05.02 GRS STATUS 858\nS=SYSTEM  SYSDSN   SYS1.PARMLIB\nSYSNAME         JOBNAME          ASID      TCBADDR    EXC/SHR   OWN/WAIT\nMVS1      RACF                 0020        009FDE88    SHARE      OWN\nMVS1      BLXSHR               001E        009FDE88    SHARE      OWN\nMVS1      IHDMP                0117        009FDE88    SHARE      OWN\n\n\n\nD GRS,RES=(SYSZJES2.*),HEX\nISG020I 11.00.48 GRS STATUS 010\nS=SYSTEM  SYSZJES2 JESSP1SYS1.HASPCKPT                               T\n          EEEEDCEF DCEEDFEEEF4CCEDCDDE444444444444444444444444444444\n          28291522 1522712821B81273273000000000000000000000000000000\nSYSNAME         JOBNAME          ASID      TCBADDR    EXC/SHR   OWN/WAIT\nMVS1      JES2                 0014        009F7DC8  EXCLUSIVE    OWN\n\n\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.   IMON display of the JES2 checkpoint RESERVE enqueue.\n            You can tell that the enqueue is a successful RESERVE\n            enqueue by the color of the display line.  A tutorial\n            panel is provided (by pressing PF1) which explains the\n            many details described in the display line.\n\n\n\n     SYSTEM MVS1   96/12/20   10:14:29.33                     LINE 1 OF 2   75%\n ENQUEUE DISPLAY SELECTION CRITERIA:  Q=******** R=**************** J=JES2****\n Q-NAME E RESOURCE-NAME                                 (RSV-DEVICE) USER\nSYSZJES2*JESSP1SYS1.HASPCKPT                               9 JESSP1)JES2     <O\n           AFCA=01024  UICA=00254 CPUA=054%  ASMQA=00000  PGRT=00000\n\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\n  Address of the distributor of IMON.\n\n     PRESS ENTER GROUP\n     Suite 15\n     33 Ryde Road\n     Pymble, NSW  2073\n     Australia\n\n         email address:   www.pressenter.com.au\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9703MA": {"ttr": 16385, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x97&\\x8f\\x01\\x00)\\x9f\\x11G\\x01+\\x01+\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1997-09-25T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 299, "newlines": 299, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           March 1997\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      Lakewood, New Jersey 08701\n\n\nSam Golob is a Senior Systems Programmer.\n\n\nHARNESSING MACRO POWER - PART 1\n\n      Early in my career, before I felt comfortable programming in\nAssembler Language, I used to be very frustrated by some IBM\npronouncements, to the effect that they've provided a programming\ninterface to some system service, in the form of a macro.  \"You can't\nharness the macro unless you write a program\", I used to moan to\nmyself.  Since I was then uncomfortable writing my own program, I\nstarted looking around for someone else's program.  With access to the\nCBT MVS Utilities Tape, a large free software collection that is now\norderable through NaSPA, I usually could find someone else's code\nwhich took advantage of the service.  Then I could either use that\nprogram as is, or tailor it for my own needs.\n\n      This process is looked upon disdainfully by the old timers, who\nwould always try and write the complete code themselves.  I have a\ndifferent view, being of a little later vintage.  First, if you have\na working coded example, you don't have to repeat the little bugs\nand mistakes yourself.  (This has the disadvantage, that you often\nnever discover what they were in the first place.)  Second, by\ncarefully studying the other person's work, you can quickly find out\nhow that macro interface can be used in a program, so you can easily\nwrite your own similar programs later.  Third, you can save quite a\nbit of debugging time, and get the code into production quickly.\n\n      Today, we'll talk about a few useful examples of this process.\nHopefully, you'll get some good ideas, which you can then use in your\nwork.  A by-product of this study, is that you'll either find, or\ndevelop, some helpful utility programs that will benefit your shop\nand yourselves later.\n\n\nA RACF EXAMPLE\n\n      If your shop has a security package other than RACF, don't turn\nyourself off at this point.  You can probably write a similar program\nto fit the other security packages as well.  If you do write such a\nprogram, the \"whole world\" will benefit if you'll send the code to the\nproprietor of one of the free software collections, such as the CBT\nTape itself.  You may find out the address of the proprietor by calling\nthe NaSPA office.\n\n      The problem is as follows:  A Systems Programmer would like to\ninterrogate RACF (in batch or TSO) to find out if a specific user has\naccess to a specific resource, and what that access is.  Sometimes\nthis information is not easily obtainable from RACF's ISPF interface.\nFor example we have the following case:  Our specific user is\nconnected to several groups, and each group has some level of access\nto the resource.  It is not easy to know, from the RACF ISPF display\ndirectly, what our specific user's actual maximum access level is.\nEach of the groups might have a different access level to the\nresource.  We want to know positively, and right now, the highest\nlevel of access that our user has, to that resource.\n\n      A related problem is familiar to EDP Auditors, but a Systems\nProgrammer might want to know this information as well.  We want to\nknow if a specific user has UPDATE access or higher, to any system\nlinklist libraries, LPA list libraries, or APF authorized libraries.\nWe can list out all such libraries in our system, and we want to query\nthe security package if our specific user has the power to update any\nof them.  RACF's ISPF interface is almost helpless in this situation.\n\n      There is a system macro interface provided by IBM, which can\ngive this information.  This is the RACHECK macro.  However, the\nRACHECK macro is useless unless it is put into a program.  On the\nCBT MVS Tape, File 106, there is a program which harnesses the power\nof the RACHECK macro service, to easily give us the information we\nwant.\n\n      How does the program (called RACCESS) work?  The program takes\ncard-image input for each security interrogation request.  Output is\nsent to a normal print line.  Input is read and output is written via\nsimple QSAM GET and PUT.  In this simple application, the input cards\nare not parsed, but the input has to be in fixed columns, and is broken\ninto fields.  Userid, resource class, and profile name are in fixed\nfields, and once the input card is read, these fields are copied into\nthe appropriate input fields for the RACHECK macro.  See Figure 1 for\ndetails on how the RACHECK macro is set up.  The outputs from the\nRACHECK macro are formatted (eventually) into a print line.  There is\na little more to it.\n\n      RACHECK is quite inflexible, so our program has to invoke it\nrepeatedly in the following way:  There are various \"degrees of access\"\npossible within RACF.  No access to the resource is called \"NONE\".\nThen, in increasing order, are READ, UPDATE, CONTROL, and finally\nALTER, which is full access for creating and deleting the resource.\nAn invocation of RACHECK has to specify exactly which degree of access\nwe are querying for.  Thus, our program first must invoke RACHECK to\ncheck for ALTER access.  Then it must invoke RACHECK again (if ALTER\naccess is not granted), to see whether CONTROL access is granted.  If\nCONTROL hasn't been granted, then another invocation of RACHECK\nspecifically asks if UPDATE is granted.  If UPDATE isn't there, then\nanother RACHECK is done for READ.  Finally, if READ isn't granted, NONE\nis assumed and is reported.  With the first return of a \"YES\", an\nappropriate output line is formatted and written.  See Figure 2 for\na sample input to and output from the RACCESS program.\n\n      The main result we have here is a practical utility which takes\nnormal, easily controllable input, runs it into a macro service\nfacility, and formats convenient, readable output.  An assembler macro\nservice has thus been converted into a very usable tool.\n\n      Just to complete the picture, I'd like to show how this utility\ncan be used to solve the EDP Auditor problem mentioned above.  We\nwant to show if a particular userid has UPDATE or higher access to\nlinklist, LPA list, and APF authorized libraries.  We can copy the\nLNKLSTxx, LPALSTxx and PROGxx members of SYS1.PARMLIB to our own card\nimage dataset, and edit them to create a combined list of dataset names,\nstarting in column 17 of the cards.  Then, columns 1 to 8 can be filled\nin (left justified and padded with blanks) with the USERID name to be\ntested.  Columns 9 to 16 can be filled in with the resource class name\nof \"DATASET\".  Thus, the input deck of cards is complete.  This deck\nis run into our program, and a corresponding output list is produced,\nwhich gives the actual level of access that the user has, to each\nlibrary.  If any of these accesses are UPDATE, CONTROL, or ALTER,\nthese can be easily spotted in the program's print output.  To check a\ndifferent USERID, just do a global change for column 1 in the entire\ninput deck.  The problem has been solved.\n\n      File 106 from the CBT Tape includes a member which is a sample\nCLIST to invoke the RACCESS program in the foreground.  Output is\ndisplayed on the screen, from an input card-image deck in a dataset.\nSince the RACCESS program produces conventional QSAM SYSPRINT output,\nthere is no trouble displaying this when the program is invoked in the\nforeground under TSO.\n\n      One further note.  Under some conditions, for example if the RACF\nAudit option is turned on for datasets, running the RACCESS program\nwith its many invocations of the RACHECK macro, can produce unwanted\nRACF console messages and SMF Type 80 Records for each RACHECK\ninvocation.  This can be gotten around by coding the LOG=NONE parameter\nin the RACHECK macro, and running the program authorized.  To do so,\nthe RACCESS program has to be linkedited with SETCODE AC(1) and run out\nof an authorized library.  Most Systems Programmers have the facilities\nto run their own authorized programs.\n\n\nA TSO EXAMPLE\n\n      In the newer \"TSO/E Customization\" manuals, an IBM macro\nservice is described, which interfaces with the USERID records of\nthe SYS1.BRODCAST dataset.  The macro is called IKJIFRIF, and you\nhave to write a program in the form of a TSO Command Processor, to\nuse the service.  I'll show you what the service is for, and how I\neasily wrote a simple TSO Command program to interface to it.\n\n      The SYS1.BRODCAST dataset performs a service for TSO users at\nan installation.  This is to hold system messages that are destined to\nbe sent to a certain TSO user, so that the messages can be displayed\nwhen that user logs on to TSO later.  The TSO SEND or Operator SEND\ncommands are used to create the messages.  If the user is currently\nlogged on, then the message is sent directly to that user's terminal.\nIf the user is not logged on, then the message is written to a record\nin the SYS1.BRODCAST dataset, and chained to that user's string of\npending message records.  The beginning and end of this chain is\npointed to by a USERID record in the SYS1.BRODCAST dataset.  (We are\nassuming that individual TSO Userlogs are not being used.)  When the\nTSO user logs on, LOGON processing invokes the LISTBC program, which\ndisplays the user's messages at the terminal, and deletes all messages\non the user's chain.  If the user never logs on, all of the messages in\nthat user's chain are piled up, and the chain grows longer and longer\nas more messages are sent to that user.  Suppose a user leaves the\ncompany.  Then if production job messages continue to be sent to that\nuser, it is possible for the SYS1.BRODCAST dataset, being a direct\naccess, formatted dataset, to fill up.\n\n      IBM does not provide a means of displaying and deleting a\ndifferent user's SYS1.BRODCAST messages.  You can only delete your\nown.  However, IBM does provide the IKJIFRIF macro interface to delete\nthat user's USERID record and all the attached messages.  The IKJIFRIF\nmacro can also be used to add a new USERID record to the SYS1.BRODCAST\ndataset, so that after the particular userid and its messages have\nbeen deleted from SYS1.BRODCAST, the same userid can be reinstated\nlater, with none of the old messages attached to it.  This can be used\nas one means of clearing an arbitrary user's unwanted messages out of\nSYS1.BRODCAST.  The only obstacle is that a program must be written to\nharness the power of the IKJIFRIF macro.\n\n      In the TSO/E Customization manual, the usage of the IKJIFRIF\nmacro is explained.  You have to invoke the macro as part of a TSO\nCommand Processor program that has a parsing facility for a parameter.\nTSO Command Processors are programs that are designed to run under TSO\nas a command.  A TSO Command Processor program assumes that Register 1\npoints to a control block called the CPPL, or Command Processor\nParameter List.  The CPPL is filled in when the program is invoked\nunder TSO as a command.  Thus, the 4 fullwords of the CPPL, which point\nto the \"command buffer\" and 3 TSO control blocks, have to be accessible\nto our program.  In other words, a program which invokes IKJIFRIF has\nto start by copying all four data area pointers to program storage.\n\n      In order for IKJIFRIF to be invoked, you then have to tell\nIKJIFRIF where to find the 3 TSO control blocks, whose pointers you got\nfrom the CPPL.  Then you tell IKJIFRIF if you want to ADD or DELETE a\nuserid record in SYS1.BRODCAST.  Finally, the TSO command has to parse\nthe command buffer somehow, to retrieve the name of a userid to tell\nIKJIFRIF which name to work with.  I have coded such programs, which\nare part of my SYS1.BRODCAST handling package that is on File 247 of\nthe CBT Tape.  They are called BCMUSADD for adding a userid record, and\nBCMUSDEL for deleting a userid record.  All they do is take a TSO\nCommand Processor shell, and \"wrap it around\" an invocation of the\nIKJIFRIF macro, to ADD or DELETE the particular userid record which was\nspecified by the command parm.  IKJIFRIF does the rest.  It is really\nvery simple.  For an example of invoking IKJIFRIF, see Figure 3.\n\n      I hope that I have whetted your appetite to look for other\nmacros to make utilities out of.  Any macro which takes some input,\nand which invokes a service to return a result, is a candidate for\nsuch treatment.  Next time, I hope to elaborate on more details of\ncarrying out this process.  Meanwhile, good luck and good hunting.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   Invocation of the RACHECK macro from within the RACCESS\n            program.  If the CLASS is \"DATASET\", then this invocation\n            is done.  If not, then the VOLSER parameter is left out.\n            Please notice that the OUTDSN, VOLSER, RACCLASL, and\n            OUTUID are data names which contain information that came\n            either from the input cards or from the result (in the case\n            of the VOLSER name) of an invocation of the LOCATE macro\n            within the program.  ALTER is hard-coded.  With other\n            invocations of RACHECK in this program, CONTROL, UPDATE, or\n            READ are hard-coded instead of ALTER, in the ATTR keyword.\n\n\n         RACHECK ENTITY=(OUTDSN),ATTR=ALTER,LOG=NONE,                  X\n               VOLSER=VOLSER,CLASS=RACCLASL,                           X\n               RELEASE=1.8,USERID=OUTUID\n\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.   Input to the RACCESS program and output from the program.\n            Note that the System Programmer ID can alter SYS1.LINKLIB\n            and it can use the Logon Procedure called SYSTMPRC, whereas\n            the two user level ID's can only read the system libraries,\n            and they cannot use the System Programmer's Logon Procedure.\n\n\n Input (on 80-column card-image records)\n\nUSER01  DATASET SYS1.LINKLIB\nUSER01  DATASET SYS1.LPALIB\nUSER01  TSOPROC SYSTMPRC\nUSER02  DATASET SYS1.LINKLIB\nUSER02  DATASET SYS1.LPALIB\nUSER02  TSOPROC SYSTMPRC\nSYSPG1  DATASET SYS1.LINKLIB\nSYSPG1  TSOPROC SYSTMPRC\n\n\n Output (on a print line)\n\n USERID    CLASS                   RESOURCE NAME               ACCESS LEVEL\nUSER01    DATASET     SYS1.LINKLIB                              READ\nUSER01    DATASET     SYS1.LPALIB                               READ\nUSER01    TSOPROC     SYSTMPRC                                  NO ACCESS\nUSER02    DATASET     SYS1.LINKLIB                              READ\nUSER02    DATASET     SYS1.LPALIB                               READ\nUSER02    TSOPROC     SYSTMPRC                                  NO ACCESS\nSYSPG1    DATASET     SYS1.LINKLIB                              ALTER\nSYSPG1    TSOPROC     SYSTMPRC                                  READ\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 3.   Execution of the IKJIFRIF macro to either delete or add\n            a userid record in the SYS1.BRODCAST dataset.  The ECT,\n            PSCB, and UPT are TSO control blocks which are passed to\n            this program when it is executed as a TSO command.  For\n            full information on the IKJIFRIF macro, see the TSO/E\n            Customization manual.  This is the execute form of the\n            macro.  Label ADDIDL contains the list form.\n\nADDIDL   IKJIFRIF MF=L\n\nDODEL    IKJIFRIF ECT=SAVEECT,PSCB=SAVEPSCB,UPT=SAVEUPT,DEL=DELADR,    X\n               RETCODE=IKJIFRET,MF=(E,ADDIDL)\n\n\nDOADD    IKJIFRIF ECT=SAVEECT,PSCB=SAVEPSCB,UPT=SAVEUPT,ADD=ADDADR,    X\n               RETCODE=IKJIFRET,MF=(E,ADDIDL)\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9704AP": {"ttr": 16391, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x97&\\x8f\\x01\\x00)\\x9f\\x11G\\x00\\xfb\\x00\\xfb\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1997-09-25T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 251, "newlines": 251, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           April 1997\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.\n\n\nHARNESSING MACRO POWER - PART 2\n\n      Last month, we discussed the topic of turning system macros,\nwhich operate from within assembler programs, into utilites that we\ncan use.  This topic seems a bit daunting for many of us, and I must\nadmit that toward the beginning of my career, when I wasn't so good at\nprogramming in assembler language, I was at something of a loss when\nshown a macro facility.  I figured that I myself could never use the\nfacility, because I felt dependent on someone else to write the\nprograms for me.\n\n      Today, I'd like to show you that even if you're only fair at\nassembler, you can still harness system macro facilities for yourself.\nI'll go into a little more detail as to the kind of things you can do\nin a program, and I'll give you another example to study.\n\n\nTHE GBHABEND PROGRAM\n\n      We'll start our discussion with an example of what my friend\nGordon Hampton did with the ABEND macro.  The ABEND macro is a system\nfacility which ends a job and produces a system abend, killing all\nsubsequent steps in the job stream, so they are not executed.  Abends\ncan have several types of codes.  These are:  system codes, user\ncodes, and system code with reason code.  Optionally, if a SYSUDUMP,\nSYSABEND, or SYSMDUMP ddcard is included in the JCL, a virtual storage\ndump is produced in the step.  The value of the abend code is\ndisplayed in the JCL output for the job step.  System abend codes are\nhex values, and they range from X'000' to X'FFF'.  User abend codes\nhave the same range, but they are expressed in decimal values from 0\nto 4096.  Reason codes that accompany system codes, can have the same\nrange, expressed in decimal values from 0 to 4096.  The GBHABEND\nprogram can invoke the ABEND macro to reproduce any of these abend\ncodes, driven by a parm value.  See Figure 1.\n\n      An application program which ends abnormally or because of a\nprogramming error, in such a situation where the programmer did not\nprovide an error routine, will often cause a system abend.  Also,\nmany operating system programs which end abnormally, do so via either\nthe ABEND macro, or the service it invokes, SVC 13.  However, some\nsystem utilities will almost never produce an abend under normal\nconditions, even if there is a severe error.  The notable example of\nsuch a program is IDCAMS, the utility which handles VSAM files.\n\n      At this point, we can see one practical use for Gordon's\nprogram.  Suppose you have a multi-step job stream which involves the\ncreation or manipulation of VSAM files.  The success or failure of such\na \"VSAM\" job step will involve a return code, rather than a system\nabend.  If a certain job step is supposed to create an important VSAM\nfile, and it fails, then instead of an abend, a return code of 12 will\nbe issued by the job step.  If you'd want to kill the rest of the job\nstream because of the step failure, one way would be to code a COND\nparameter on all subsequent job steps.  Another way would be to code\njust one job step, invoking the GBHABEND program with a COND parameter\non it, that would abend the rest of the job then and there.  Figure 1\nshows how this is done.  Of course on newer systems, with IF-THEN-ELSE\ncoding in the JCL, the same thing could also be accomplished, but the\nGBHABEND method works on all systems, old and new.\n\n      Gordon had another use for his program.  Since he could induce\nthe ABEND macro to produce an abend with any code:  system, user, or\nsystem with reason code, he could do simulations.  For example, one\ncould study the effect of a system or a user abend with a certain code,\non a job stream, without having to actually execute the offending job\nstep.  One could merely execute the GBHABEND program with the proper\nparameters and reproduce the exact abend code in the job stream.\n\n      To complete the simulation picture, one would have to write a\nprogram which produces a given condition code depending on a parm.\nThis is extremely easy to write, and all of you can do so as an\nexercise.  Just be sure to test your program out in a job stream, to\nmake sure it works properly.  The program should do as follows:  Save\nthe registers, then read the parm, which is pointed to by Register 1\nplus 2.  The length of the parm field is a halfword pointed to by\nRegister 1 itself.  If there is no parm, the program should do nothing.\nIf there is a parm, once the EBCDIC value of the parm is extracted, you\ncan pack it, and convert it to binary in a fullword of storage.  Then\nreturn control to the caller, with all registers restored except for\nRegister 15, which has been loaded from the fullword containing the\nbinary value obtained from the parm.  That's all there is to it.\n\n      Source code for the GBHABEND program may be found on File 233 of\nthe CBT MVS Utilities Tape, a large collection of free software which\ncan be obtained through the NaSPA office.  Optionally, this program\ncan be downloaded from the Nascom bulletin board.  GBHABEND is a\npractical and useful program for any installation to have.\n\n\nDISPLAYING HEX VALUES\n\n      Nowadays, many system macros are designed to return binary\ntokens, codes, or similar types of values.  It makes sense, that if\nwe possessed a technique of displaying a binary value in a program,\nwe could look at the output of all these macros, and possibly learn\nsomething about what these token values are.\n\n      I have done this kind of work myself in a few programs that are\npublicly available.  An example of code which does such hex displays\nis on File 247 of the CBT MVS Tape, and is a program called BCMLISY.\nBCMLISY is a TSO command which displays any TSO user's SYS1.BRODCAST\nmessages.  However, besides displaying the text of the messages\nalone, it also displays, for each message, the relative record address,\nin hex, of that message within the SYS1.BRODCAST dataset.  I took the\ntechnique of displaying a hexadecimal value in readable numbers, from\nBill Godfrey.  Figure 2 displays the elements of the technique, and has\nsnippets of code from the BCMLISY program, which accomplish the display.\n\n      This display technique for hex values, is packaged as a macro.\nIn order for the macro to function, a few other ingredients need to be\ncoded into the program.  All of these ingredients are shown in Figure\n2.  The macro is called HEX, and its operands are three.  The first\noperand is the target area for the EBCDIC display bytes.  This is twice\nthe size of the hexadecimal original data.  The second operand is the\nnumber of hex bytes to be expanded.  The third operand is the hex\nsource data.  As Figure 2 shows, the HEX macro invokes the HEX\nsubroutine that uses Registers 15, 0, and 1 as work registers, to\nexpand one byte of hex into two bytes of display characters at a time.\nYou can see exactly how this code works by looking at Figure 2.\n\n      It remains for me to indicate, at this point, how the expanded\ndata is to be displayed to a user of the program.  If the program is\na batch program, you can use QSAM PUT to print an output line of\ndisplay.  If the program is a TSO command, the TPUT or PUTLINE macros\ncan be used to display the output at a terminal.  PUTLINE is harder\nto use than TPUT, but PUTLINE results can be printed to a hardcopy\ndevice, whereas TPUT results cannot; they can only be sent directly\nto a terminal.  A coding example of how to use PUTLINE can be found\nin the BCMLISY program from File 247 of the CBT Tape.  The code and\nactual technique is the work of Bill Godfrey.  The TSO/E Programming\nmanual, I believe, spells out the directions for doing TSO output\nusing PUTLINE, but you can also copy Bill Godfrey's code, which works\nfine.  Bill Godfrey already did the work, and you don't have to knock\nyour head against the manual to untangle what it says.\n\n      What is the point of all of this, for our subject?  You can now\ntake any system macro in the books which can be induced to return a\ntoken value.  Then you can write a simple program to invoke the macro\nunder control of parameters that were externally supplied, either by\na parm or by control cards.  After that, you can use the hex display\ntechnique to display or print the results.  This technique becomes a\ngreat diagnostic and learning tool.\n\n      I've had to be brief this month, but I hope these techniques\nwill prove of value in your work.  I think that this idea of displaying\nthe results of macro calls is a bit novel, and it can be very very\nuseful.  If you actually follow these ideas up, you can gain much\nsystem knowledge and you can profit very much.  Good luck with your\nefforts.  See you again next month.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   How to use Gordon Hampton's GBHABEND program to abend\n            a job step with any ABEND code you would like to specify.\n            The parms you specify are fed by the program into the\n            ABEND system macro, to produce the desired result.  This\n            is a clear example of a program which feeds the user's\n            parameters into a system macro.\n\n\n   Full format of the parms is as follows:\n      SNNN - GIVES SYSTEM ABEND NNN.\n      UNNNN - GIVES USER ABEND NNNN.\n      NNNN - GIVES USER ABEND NNNN.\n      RMMMNNN - GIVES SYSTEM ABEND MMM WITH REASON CODE NNN.\n   If you don't follow this format you may get strange results.\n\n    JCL to run is as follows:\n\n   //BOOMSTEP EXEC PGM=GBHABEND,PARM=U1288,COND=(8,GT,PREVSTEP)\n   //STEPLIB  DD DISP=SHR,DSN=MY.STEPLIB\n   //SYSABEND DD SYSOUT=*\n\n   This will cause a user abend of 1288 on BOOMSTEP\n     if PREVSTEP had a condition code of 8 or greater.\n\n   If you don't want a dump to be produced, leave out the\n     SYSABEND DD card.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.   Code to support the display of hexadecimal numbers in\n            EBCDIC.  This code was taken from the BCMLISY program\n            whose source code is on File 247 of the CBT MVS Utilities\n            Tape.  I think the original author of the code is Bill\n            Godfrey.  Inline code is the HEX macro, which takes an\n            n-byte hexadecimal field and expands it into a 2n-byte\n            EBCDIC display field.\n\n\n    Here are two separate invocations of the HEX macro, to expand\n    two 3-byte hex numbers into 6-byte display format.\n\n         HEX   LINE+10,3,USDRBA        Display 3-byte hex fields\n         HEX   LINE+18,3,USDEND           in 6-byte EBCDIC fields.\n\n\n    This is the supporting code for the HEX macro:  First is the\n    macro itself, followed by the byte-by-byte display expansion\n    routine.\n\n         MACRO\n&NAME    HEX   &TO,&LEN,&FROM\n&NAME    STM   15,1,HEXSAVE\n         LA    1,&FROM\n         LA    0,&LEN\n         LA    15,&TO\n         BAL   4,HEX\n         LM    15,1,HEXSAVE\n         MEND\n\n\n\nHEX      MVC   1(1,R15),0(R1)      MOVE BYTE\n         UNPK  0(3,R15),1(2,R15)   UNPACK\n         TR    0(2,R15),HEXTAB-240\n         LA    R15,2(,R15)         INCREMENT OUTPUT PTR\n         LA    R1,1(,R1)           INCREMENT INPUT PTR\n         BCT   R0,HEX              DECREMENT LENGTH, THEN LOOP\n         MVI   0(R15),C' '         BLANK THE TRAILING BYTE\n         BR    R4                  RETURN TO CALLER\nHEXTAB   DC    C'0123456789ABCDEF' TRANSLATE TABLE\n\n\n    These are the data areas referred to by the above code.\n\n\nHEXSAVE  DS    3F          Register save for HEX macro\n\n\nUSDRBA   DS    AL3 -          RELATIVE BLOCK ADDRESS (RBA) OF FIRST\n*                               MESSAGE FOR THIS USERID (ZERO IF NONE)\nUSDEND   DS    AL3 -          RBA OF LAST MESSAGE FOR THIS USERID\n*                               (ZERO IF NONE)\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9705MY": {"ttr": 16641, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x97&\\x8f\\x01\\x00)\\x9f\\x11G\\x01X\\x01X\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1997-09-25T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 344, "newlines": 344, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                            May 1997\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.\n\n\nIT'S A BIRD, IT'S A PLANE, IT'S SUPRNAME\n\n      This month, we're going to discuss a nagging problem that has\nto do with the way MVS is built.  The problem is simple, and has to\ndo with dataset protection.  To put it plainly, MVS will not let you\ndelete or rename any dataset that is being currently used.  That's a\nnormal and desirable situation.  However, if you have an uncataloged\ncopy of that dataset with the same name, which you want to get rid of,\nMVS will not let you do that either.\n\n      When does this kind of thing happen?  The classic case is with\nVTAM.  When VTAM is up (which is practically all of the time), it\nrequires the use of at least two datasets.  One is usually called\nSYS1.VTAMLIB.  This contains load modules that VTAM uses to run.  The\nother is called SYS1.VTAMLST, which contains startup parameters and the\nnetwork definition statements.  A normal MVS shop is set up with some\nredundancy built in.  For example, most shops except for the very\nsmallest, have several copies of the system residence disk pack.  It\nwould be stupid not to have them.  If something happened to the system\nres pack, there would be no system to recover with, because there would\nbe no pack to IPL from.  You'd be left having to do a standalone\nrestore from a full disk backup, if you ever took such a backup.  You\nget the idea.  Now, SYS1.VTAMLIB is usually on the system res pack.  If\nsomething was wrong with the copy of SYS1.VTAMLIB on your alternate res\npack, and you had to delete and reallocate it, MVS would not let you do\nthat until VTAM came down.  If VTAM is down, TSO is down.  This spells\n\"slight inconvenience\".  What would you do if you were time-constrained\nand couldn't wait?\n\n      Let's start studying, by trying to understand how the dataset\nprotection mechanism in MVS works.  Before allowing the deletion or\nrenaming of any dataset, the system checks if there is an outstanding\nenqueue on that dataset with a QNAME of SYSDSN and an RNAME equal to\nthe dataset's actual name.  This is done by asking for an exclusive\nenqueue with these names.  (See this column from Feb. 97, entitled\n\"Creative Enqueuing\", for further explanation.)  In the case of\nSYS1.VTAMLIB, the QNAME for the enqueue would be SYSDSN, and the RNAME\nwould be SYS1.VTAMLIB.  If the system's exclusive enqueue request is\nunsuccessful because the dataset was currently being used by some task,\nthe system gets a \"no can do\" condition code in response to its enqueue\nrequest, and you can't do the rename or deletion.  What if you have an\nunused copy of the dataset that you want to delete?  The system's\nexclusive enqueue request is exactly the same as if the \"real\" copy of\nthe dataset was to be deleted, and our deletion request fails.\n\n      How can we get around this problem?  The easiest way would be if\nwe could rename the uncataloged copy of the dataset to something else,\nwithout involving the system in doing any enqueues.  For example, if\nwe could somehow rename the uncataloged copy of SYS1.VTAMLIB to\nSYSQ.VTAMLIB, then we could make progress.  When the system makes a\nsubsequent deletion request for this dataset, its exclusive enqueue\nrequest would then have an RNAME of SYSQ.VTAMLIB, and its deletion\nrequest would not conflict with the existing enqueue for SYS1.VTAMLIB\nthat VTAM's task is holding.\n\n      Enter SUPRNAME.  SUPRNAME is a public-domain batch utility which\ngoes directly into the VTOC of a specified pack and renames or deletes\na dataset without doing any enqueue.  Instead, it does a direct zap to\nthe dataset's VTOC entry.  (This is being slightly simplified, so the\nprocess is easier to conceptualize.)  After this renaming is done, any\nsubsequent renaming or deletion will not conflict with enqueues on\n\"real\" datasets that running tasks are currently holding.  SUPRNAME is\nvery simple to use, because you don't have to know the exact CCHHR\nlocation of the Format 1 VTOC entry you are interested in changing.\nControl cards for SUPRNAME are described in Figure 2.  Alacazam, the\nproblem is circumvented, and you're in business.\n\n      There's a little more to it.  Direct zapping of a Format 1 VTOC\nentry for a dataset will only be completely effective if the disk pack\ndoes not have an operating VTOC INDEX dataset.  For non system-managed\nindexed packs, the VTOC index can be turned off using an ICKDSF batch\njob that is very simple to run, and only needs an operator reply.\nAfter the rename has been accomplished, the VTOC INDEX dataset can get\nturned on again by an equally simple ICKDSF job.  See Figure 1 for an\nexample of both jobs.  For system-managed datasets, which always have\nto be on a pack with an indexed VTOC operational, you don't usually run\ninto this problem, because all those datasets are cataloged and have\nunique names.  With cleverness and knowledge, you can probably get\naround that situation too.  However, system-managed datasets are not\nthe topic of our current problem.\n\n      How can you obtain a copy of the SUPRNAME utility?  The SUPRNAME\nprogram is part of a large collection of programs on File 270 of the\nCBT MVS Utilites Tape.  The CBT Tape is an enormous Free Software tape,\nindependently produced, that can be obtained through the NaSPA office.\nFile 270 was contributed by one of the Washington State data processing\norganizations in Olympia, Washington.  SUPRNAME was written by Kermit\nKiser.  (Thanks, Kermit.)  See Figure 2 for Kermit's instructions on how\nto run SUPRNAME with the proper JCL control cards.\n\n      Now let's get back to the VTAM situation.  We've un-indexed the\npack that our extra copy of SYS1.VTAMLIB is on.  Now we want to rename\nthat copy of SYS1.VTAMLIB to SYSQ.VTAMLIB while VTAM is still up.\nSuppose the \"extra\" copy of SYS1.VTAMLIB is on the ALTRES pack.  All we\nhave to do is to set up the JCL from Figure 2, so the VOL=SER keyword\nin the SYSLIB ddname points to ALTRES, and the SYSIN ddname has control\ncards of the form:\n\n       RENAME   DSNAME=SYS1.VTAMLIB\n                NEWNAME=SYSQ.VTAMLIB\n\nThe SUPRNAME program does the rest, and life is very simple for us,\nafter SUPRNAME has done its job.  Multiple control cards can be used\nin a SUPRNAME batch job; we could even rename or scratch every dataset\non the disk pack in one SUPRNAME batch run.  Scratching a dataset is\ndone with a DELETE control card instead of the RENAME card.  Getting\nback to our particular case, we can do anything we want with\nSYSQ.VTAMLIB on ALTRES now, and the system will not \"object\".  When\nwe've finished all our dataset manipulations, we can re-index the pack\nusing the IXVTOC job, and all should be well.\n\n\nMORE ON THIS SUBJECT.  USING THE FULLSCREEN ZAP PROGRAM.\n\n      It's nice to rename datasets using a batch job, and it's effective\ntoo, but perhaps you would like to actually see what you are doing on a\nscreen.  In that case, the Fullscreen ZAP program on File 134 of the\nCBT MVS Tape is the tool of choice.\n\n      Fullscreen ZAP originally came from UCLA, but it has been\nmodified by Greg Price of Melbourne, Australia to add enormous power\nwhen it runs as an authorized TSO command.  Fullscreen ZAP, being an\ninteractive program, will show you the VTOC entry for only one dataset\nat a time, so in a case where you're renaming many datasets, SUPRNAME\nis much faster.  However, as we shall see, Fullscreen ZAP can be used\nprofitably to check the results of a SUPRNAME run.\n\n      How does Fullscreen ZAP work?  Assume that the load module name\nfor your Fullscreen ZAP program is ZAP.  Then we enter (as a TSO\ncommand) the following:\n\n      ZAP dataset.name   VOL(volser)\n\nwhere the VOL keyword is only necessary if the dataset is not cataloged.\nTo look at the beginning of a VTOC on a disk pack, we enter, instead\nof a regular dataset name, the following:\n\n      ZAP 'FORMAT4.DSCB'  VOL(volser)\n\nwhere the VOL keyword is now necessary so we can specify the particular\ndisk pack name whose VTOC we want to examine.  The result of this\ncommand is to point us to the beginning of the VTOC of that pack.\nSpecifically, we are pointing to the FORMAT 4 DSCB record, which is the\nVTOC header.  All other VTOC records, including the FORMAT 1 dataset\nrecords, will follow this header record on the disk pack.\n\n      One of the great advantages of the Fullscreen ZAP program is its\nFIND subcommand, entered as \"F\".  To find a hex string, subsequent to\nthe current pointer, one enters F followed by the hex string, without\nan intervening space.  To find an EBCDIC string, one enters an F,\nimmediately followed by the string enclosed in slashes.  For example,\nto find the string, SYS1 in hex, which is X'E2E8E2F1', one enters the\ncommand, FE2E8E2F1.  Whereas to find the same string in EBCDIC, one\nenters the command, F/SYS1/ .  This is very easy to use.\n\n      So, to rename SYS1.VTAMLIB on ALTRES to SYSQ.VTAMLIB, using\nFullscreen ZAP, one does the following:\n\n      ZAP 'FORMAT4.DSCB' VOL(ALTRES)\n\nThis will point us to the beginning of the VTOC on the ALTRES pack.\nThen one enters the command:\n\n      F/SYS1.VTAMLIB/\n\nThis should point us to the proper FORMAT 1 VTOC entry for the dataset\nSYS1.VTAMLIB.  However, one must examine the screen carefully to make\nsure that we are not pointing to an entry for a dataset like\nSYS1.VTAMLIB.NEW, or SYS1.VTAMLIBN, or something similar.  A repeat\nof the F command, without any operands, will take us to the next\noccurrence of the same string.  When we are sure we are in the right\nplace, we wish to change the SYS1 to SYSQ.  This can be done, either\nby replacing the entire string SYS1 in hex, by SYSQ, or by pointing\n3 bytes later, and replacing the \"1\" by a \"Q\".\n\n      The command to replace a string is an \"S\", and its operand has\nto be entered in hex.  Thus, if we are pointing to the \"SYS1\", we\ncan enter the command:\n\n      SE2E8E2D8\n\nwhich will replace all four characters in the string SYS1 which is hex\nE2E8E2F1, by the four characters E2E8E2D8, which is EBCDIC SYSQ.  Or\nelse we can move the current pointer up 3 bytes with a command:\n\n      +3\n\nfollowed by the command to replace only the one current byte \"1\" by\na \"Q\".  This would be:\n\n      SD8\n\nand the result would be the same.  The changes are made permanent by\nthe command:\n\n      ZAP\n\nand the old disk values at the specified location are replaced by the\nnew values.  If the VTOC index of the ALTRES pack has been turned off\nby the OSVTOC job, then these renames are effective, and the result is\nthe same as if SUPRNAME had been used to do the rename.\n\n      Fullscreen ZAP can be used to check the results of a SUPRNAME\nrun, even if it is not being used to do the actual changes.  Suppose\nthat SYS1.LINKLIB is being changed to SYSR.LINKLIB and SYS1.LPALIB\nis being changed to SYSR.LPALIB on pack ALTRES, using SUPRNAME.  The\nSUPRNAME control cards would be:\n\n      RENAME  DSNAME=SYS1.LINKLIB\n              NEWNAME=SYSR.LINKLIB\n      RENAME  DSNAME=SYS1.LPALIB\n              NEWNAME=SYSR.LPALIB\n\n      To check this rename using Fullscreen ZAP, one would enter, under\nTSO, the commands:\n\n      ZAP 'FORMAT4.DSCB' VOL(ALTRES)\n      F/SYSR/\n      F\n      END\n\nThis should show clearly, on the screen, the renamed FORMAT 1 VTOC\nentries for the two datasets.  If the renames from SUPRNAME did not\nwork, then ZAP should return a message that we are at the end of the\nVTOC, and we have not found the string.  The string SYSR in any other\nVTOC records could be clearly seen to be different from the dataset\nnames that we expect to see.\n\n      In summary, I hope that this month's discussion will improve\nyour working techniques, or if you already know this stuff, it will\nget you thinking on the subject, and maybe you'll figure out ways to\nto this job even more effectively.  Good luck, and I hope to see you\nagain next month.\n\n\n *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   ICKDSF jobs to turn a VTOC INDEX off and on for a disk\n            pack.  It is assumed that the pack was originally INIT'ed\n            to be in indexed format.  In this example, the name of\n            the pack is PDNV01, and therefore, the name of the\n            index dataset that was originally defined in the pack\n            initialization process, is SYS1.VTOCIX.VPDNV01.\n\n            The OSVTOC job disables the index dataset, and the\n            IXVTOC job re-enables the index dataset.\n\n\n//*              * * *     O S V T O C     * * *\n//TSTBSP2N JOB ,'TECH.SUPPORT',CLASS=M,NOTIFY=&SYSUID,TIME=1440,\n//        MSGLEVEL=(1,1),MSGCLASS=T\n//*******************************************************************//\n//*  NOTE..... THIS WILL ASK OPERS FOR A REPLY - YOU NEED A \"U\" IF OK.\n//*******************************************************************//\n//* ------------------------------------------- *//\n//* INVOKE THE DEVICE SUPPORT FACILITY PROGRAM\n//* ------------------------------------------- *//\n//****************************************//\n//*      CONVERT IXVTOC TO OSVTOC:\n//****************************************//\n//S1    EXEC PGM=ICKDSF,TIME=1439\n//SYSPRINT  DD SYSOUT=*\n//VPDNV01 DD VOL=SER=PDNV01,UNIT=SYSDA,DISP=SHR, <=== CHANGE ALL\n//   DSN=SYS1.VTOCIX.VPDNV01        <=== OCCURRENCES OF VOLSER NAME.\n   BUILDIX DDNAME(VPDNV01) OSVTOC\n/*\n\n\n//*              * * *     I X V T O C     * * *\n//TSTBSP2N JOB ,'TECH.SUPPORT',CLASS=M,NOTIFY=&SYSUID,TIME=1440,\n//        MSGLEVEL=(1,1),MSGCLASS=T\n//*******************************************************************//\n//*    NOTE..... THIS WILL ASK OPERS FOR A REPLY.  \"U\" IF OK. ****\n//*******************************************************************//\n//* ------------------------------------------- *//\n//* INVOKE THE DEVICE SUPPORT FACILITY PROGRAM\n//* ------------------------------------------- *//\n//****************************************//\n//*        REBUILD INDEXED VTOC:\n//****************************************//\n//START EXEC PGM=ICKDSF,TIME=1439\n//SYSPRINT  DD SYSOUT=*\n//VPDNV01 DD VOL=SER=PDNV01,UNIT=SYSDA,DISP=SHR, <=== CHANGE ALL\n//   DSN=SYS1.VTOCIX.VPDNV01  <=== OCCURRENCES OF VOLSER NAME TO YOURS\n   BUILDIX DDNAME(VPDNV01) IXVTOC\n/*\n\n\n *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.   Sample JCL and control cards for SUPRNAME.\n\n\n\n //*\n //* update the volser on the SYSLIB card before submitting\n //*\n //S1  EXEC PGM=SUPRNAME\n //STEPLIB DD DISP=SHR,DSN=your.authrizd.steplib\n //SYSPRINT DD SYSOUT=*\n //SYSUDUMP DD SYSOUT=*\n //SYSUT1 DD DISP=(,DELETE),SPACE=(TRK,(1,1)),\n // DCB=(RECFM=FB,LRECL=80,BLKSIZE=80),UNIT=SYSSQ\n //SYSLIB DD DISP=SHR,DSN=FORMAT4.DSCB,DCB=KEYLEN=44,\n // UNIT=SYSALLDA,VOL=SER=PDNV01 <=== place correct volser here\n //SYSIN DD *\n\n  RENAME DSNAME=ANY.OLD.NAME\n         NEWNAME=ANY.NEW.NAME\n\n  DELETE DSNAME=ANY.OTHER.NAME\n         or\n  SCRATCH DSNAME=ANY.OTHER.NAME\n\n  ABSDUMP  DSNAME=ANY.NEW.NAME\n         or\n  ABSDUMPT DSNAME=ANY.NEW.NAME\n\n  CCHHR  DSNAME=ANY.NEW.NAME\n   VER 00 C1\n   REP 00 C2\n\n SAMPLE JCL and control cards for Indexed VTOC case:\n         (use if altering a dsname on an Indexed VTOC)\n\n //* Put the OSVTOC job step from Figure 1 first, then\n //* put the IXVTOC job step from Figure 1 last,\n //* with all SUPRNAME job steps in between.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9706JN": {"ttr": 16647, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x97&\\x8f\\x01\\x00)\\x9f\\x11G\\x00\\xca\\x00\\xca\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1997-09-25T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 202, "newlines": 202, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           June 1997\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.\n\n\nTIMING OUT\n\n      Probably, most of you have not always had the System Programmer's\n\"silver spoon\" in your mouths for your entire career in data\nprocessing.  In other words, you probably have not had \"PC Status\"\n(Privileged Character Status).  One of the features of PC Status is\nthat your own TSO Session does not \"time out\" and get logged off with a\nSystem 522 abend, after a designated number of minutes of inactivity.\nYou can leave the office and stay logged on, all day.\n\n      From the administrator's point of view, this privilege of \"not\ntiming out\" is undesirable for the \"average\" TSO user to have.\nTherefore, in most installations, such power is not given to them.\nWhy is it better that an average TSO user should not time out?  First,\nany logged-on TSO user allocates a certain number of datasets, and ties\nthem up with a shared enqueue, so no one else can get an exclusive\nenqueue to these datasets if that is needed.  Second, even a\nswapped-out TSO user is tying up an address space and some system\nresources; this user might even stop a new user from logging on, if the\nMAXUSERS number (of logged-on users) is being approached.  Third, if\nthat TSO session is being hung while no one skilled is around, it would\nbe very difficult to free the session.  An automatic session time-out\nwould be helpful.  There are probably several other reasons you can\nthink of.  For most TSO users, a forced time-out after a period of\ninactivity would be very desirable.\n\n      Of course for us PC's, none of these reasons apply, since all of\nus can fix any problem we might cause.  Yeah, right.  Anyway, for the\nrest of this article, I'd like to talk about this idea of timing out.\n\n\nX22-TYPE ABENDS.\n\n      Where does the subject start?  I'd say it starts with a talk\nabout purposely killing an address space.  IBM has graciously provided\nus with several means of \"chopping off\" jobs, started tasks, and TSO\nsessions in the middle of their activity.  We've all heard of cancelling\nor forcing jobs and TSO sessions.  When a job produces excessive output,\nwe might want to chop it off before it floods our printing resources or\nJES spool space.  CPU time excession abends have occasionally been part\nof our experience.  Sometimes, we run a big SMP job in the wrong class,\nand it exceeds that class' allowable CPU time, getting cut short in the\nmiddle.  All of these \"cutoffs\" are related by the fact that the system\nabends which result, nearly all end with the characters '22'.\n\n      What are some of these System X22-type abends.  A system abend\n122 occurs when the operator cancelled a job, requesting a dump.  A\nsystem 222 is an operator cancel, without a dump.  This is very\ncommon.  A system 322 is a CPU time excession cancel of a job.  A\nsystem 422 is new, and is similar to a 222, but it is done by an Open\nSystems MVS application.  A system 522 results from excession of the\nJob Wait Time (JWT) parameter in the SMF parms in SYS1.PARMLIB.  This\nis the \"timing out\" abend we are considering today.  A system 622 abend\nhappens when something goes wrong with TSO, or your session gets\ndisconnected from the terminal and the reconnect limit time passes.  A\nsystem 722 abend happens if the job puts out a lot of output, exceeding\nthe JES or JOB card output limits, and the OUTLIM parameter was not\ncoded in the job's JCL to override these limits.  A system 822 abend\nhappens when the region requsted for a job step cannot be obtained.  A\nsystem 922 abend occurs if the INITIATOR is now in control of a job,\nbefore or after the job step has taken place, and an ABEND or other\ninterruption occurs.  A system A22 abend occurs after a FORCE operator\ncommand was issued, and the address space was \"burned\", or chopped off\nforcibly, no matter what it had been doing before.\n\n      We have faced nearly all of these abends in our careers.\nSometimes we are happy when one occurs.  Other times, we can be very\ndisappointed.  Today we'll talk about some tricks we can do, to avoid\nthe situations in which we are disappointed.\n\n      Please remember that, by and large, we are PC's (Privileged\nCharacters) in our profession.  But sometimes, the management in a shop\nmight even think that we PC's have to be restricted.  Nevertheless, we\nstill are the system doctors, and we still need our tools to do the job\nthat this same management asks from us.  It's like what the parent\ndemanded of the school bus driver:  \"Be careful and drive slowly, but\nget my child to school quickly.\"  The bus driver still has to get that\nchild to school, safely, despite the parent's protests.  And we have to\ndo the job that our management requires of us, safely, but quickly too,\nwithout unnecessary hassles and interruptions.\n\n      So if management does not allow us to stop our sessions from\ntiming out with a S522 abend, and the job requires that we have to run\nseveral parallel sessions on one or more systems for an extended period\nof time, without their timing out, what advice do we have?  How can we\ncircumvent our management's restrictions and still do the job that they\nask of us?  This is today's subject.\n\n\nWAYS OF AVOIDING SYSTEM 522 ABENDS.\n\n      A system 522 abend is caused, often, by a TSO session's\ninactivity.  How long it takes to trigger the time-out depends on the\nsetting of the Job Wait Time (JWT) parameter in the SMFPRMxx member of\nSYS1.PARMLIB (in minutes).  All non-altered TSO sessions will time out\nin this number of minutes.  How can we override this time-out in our\nown TSO session, and not affect the average TSO user?\n\n      One way to avoid the time-out is to have your own TSO logon\nprocedure in a PROC library.  This would also require that SYS1.UADS\nor the security package (RACF, ACF2, Top Secret, etc.) be set up so\nthat the use of your own procedure would be allowed, when your id is\nused to logon to TSO.  Your own logon procedure, which in effect, is\nJCL, can be then coded with TIME=1440 or TIME=NOLIMIT in the EXEC card\nwhich invokes the terminal monitor program (usually IKJEFT01 or\nADFMDF03).  This will override a short JWT setting and will keep your\nown TSO session \"on the air\".\n\n      Some installations do not allow this, although nowadays it is\nunusual to find such \"backward\" places.  These installations, while\nrecognizing that systems programmers have different requirements in\ntheir TSO sessions than do application programmers, will allow one\nlogon PROC for application programmers and another one (or several)\nfor systems programmers.  They will not allow, however, a systems\nprogrammer to have a private logon PROC.  And they will also not allow\nTIME=1440 or TIME=NOLIMIT to be coded in any of these PROCs.  In many\nplaces, the systems programmers are not the security administrators.\nWhat can we do now?\n\n      A common solution is to have (or write) a program which runs\ncontinuously in a TSO session if nothing else is running, and which\nhas a timer built in.  For example, the timer will pop every five\nminutes.  When the timer pops, the program triggers some small TSO\nactivity, to fool the session into thinking that the session is not\ninactive.  Therefore, the session will never time out.\n\n      If your installation sufficiently recognizes the importance of\ncertain users not timing out, there is another possible approach.  This\nis via the SMF exit IEFUTL, which can be used to control the effect of\nJob Wait Time on jobs, started tasks, or TSO sessions.  An interesting\nand general solution that can be implemented with management approval,\noperates through RACF, or whatever security package you have.  I'll\nshow an example using RACF.  You define an entity to RACF in the\nFACILITY class called TSOWAIT.  Those users who will not time out, are\ngiven READ access to this entity.  Then an IEFUTL exit can be coded,\nwhich does a RACROUTE call for the TSO user, to ask if READ access is\ngranted to this entity, and if so, an infinite time extension is given\nto the TSO session.  Management administers this solution officially,\nthrough the security administrators, and everything is above board.\n\n      This IEFUTL exit can be quite easily coded.  An example can be\nfound on File 245 of the CBT MVS Utilities Tape, a huge, independently\nproduced tape of MVS goodies available through NaSPA.  The IEFUTL exit\nfound there, can be simplified even further.  Besides the RACROUTE call,\nthere is very little to it, just either a time extension or a bypass of\nthe time extension, based on the result of the RACROUTE call.  If you\nhave other IEFUTL exits in use at your installation, don't worry.  SMF\nexits can be very easily piggybacked, so they all run in succession.\n\n      Another solution which is very clever, can be found on File 183 of\nthe CBT MVS Tape.  This solution requires that ISPF be running in your\nTSO session.  To implement this solution judiciously, not including too\nmany people in the timeout exemption, you should have a restricted or a\nprivate load library to put into the ISPLLIB concatenation.  This can be\ndone dynamically in a CLIST using the ALLOCATE TSO command, even if your\nTSO session is using a public logon proc.  Just get out of ISPF, FREE\nFILE(ISPLLIB), and issue an ALLOCATE command with the proper ISPLLIB\nlibraries concatenated in the proper order.  That can all be done in one\nCLIST.  Finally, assemble and linkedit the source code for the ISPTASK\nmodule on File 183, non-reentrant and non-reusable, into this private\nlibrary.  With ISPF running, your TSO session will not time out during\nweekdays, until 7 PM on Friday evening.  Examine the source code of the\nISPTASK module on File 183 to see how this works.  You can alter the\nsource code if you have different timeout exemption requirements.\n\n      I'll explain it better.  The user version of the ISPTASK module\nfrom File 183, is designed to front-end IBM's ISPTASK module, which is\neither in the link list, or in LPA.  IBM's ISPTASK module is reentrant.\nThis user front-end is not.  The user ISPTASK, as coded, works as\nfollows:  First, upon getting control, it pre-loads a bunch of ISPF\nmodules into the Job Pack Queue for more efficient operation if these\nmodules were not put in LPALIB, but were running from the link list.\nThis is not important for our purpose, but I'm just mentioning it for\ncompleteness.  Afterwards, our user ISPTASK determines what day of the\nweek it is (Monday through Friday) and conditionally passes control\nto the STIMER routine that jogs the TSO session into \"activity\" every\n10 minutes.  It only does this from Monday at 12 midnight until Friday\nat 7 PM.  Finally, it does a lot of searching through TCB's, looking\nfor IBM's actual copy of ISPTASK, avoiding ISPLLIB and STEPLIB, looking\nfor a re-entrant module.  Upon finding the proper copy of ISPTASK, it\nXCTL's to it.  Meanwhile, the STIMER keeps popping itself every 10\nminutes, and the TSO session does not time out, because of this\n\"activity\".\n\n      I hope today's discussion has been interesting and helpful to\nyou.  Maybe you yourselves can find other ways to do this job.  I've\nalways thought that systems programmers were a clever bunch.  Good\nluck, and keep those timers popping.  See you next month.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9707JL": {"ttr": 16651, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x97&\\x8f\\x01\\x00)\\x9f\\x11G\\x01>\\x01>\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1997-09-25T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 318, "newlines": 318, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           July 1997\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.\n\n\nOLD CODE -- OLD GOLD\n\n      This month I'd like to provide some insight into what's been\nhappening to MVS (or OS/390 if you will), from a perspective that you\nmay not have seen elsewhere.  I know that there is an undercurrent of\nopinion among systems programmers, who will see the point of this.  I\nfeel extremely strongly that what I'm going to say, has to be said.\n\n      My teacher Howard Gilbert used to state that the development of\nMVS is not logical.  MVS can only be understood by studying its\nhistory.  The fact is that IBM developed OS/360 around 1964, and only\nkept changing it because of the requirements of its customers, usually\nthe largest ones.  Therefore, the structures and parts of (OS/)MVS\nhave progressed and grown from what has been there before.  A result\nof this fact is that those who understand MVS best, usually are\nexperienced systems programmers who have followed this operating\nsystem through many of its previous stages.\n\n      For example, you can only REALLY understand SMP/E if you know\nwhat the old System Generation (SYSGEN) process was.  On top of that,\nyou have to know how a PTF used to be applied to the system by using\na piece of the SYSGEN Stage 2 deck as a model.  Only then can you\nunderstand what SMP was created for.  (Its purpose was to automate\nthis process.)  And only then can you begin, with real understanding,\nto make sense of the strange and unique control commands that inhabit\nSMP/E today.  The same thinking applies to all components of MVS.\nYou only really get the idea of what's happening in them, if you knew\nwhat was there before.\n\n      This is not to say that components of MVS can't be rewritten.\nThey sometimes are.  It's just that because of its large customer\nbase, IBM has made it a policy to usually make a new version largely\ncompatible with what was there before.  MVS also contains millions of\nlines of highly debugged code, and it is hard to justify spending many\nprogrammer hours to rewrite what already works.  Therefore, if it\n\"ain't broke\", IBM doesn't bother to fix it, unless there's a need.\nWhat's been \"fixed\" or changed, is usually mentioned in the MVS\nConversion Notebooks for each new release.\n\n      Therefore, unless we're dealing with components of MVS that have\n(necessarily) changed, old system code should still largely work, even\ntoday.  It comes out as a conclusion, that we can profit by studying\nold code.  In many cases, we can still use the code, as is, (perhaps\nwith reassembly to account for changes in system macros), or with some\nmodification, if it hits system components that were changed, such as\nUCB lookups, for example.\n\n      Another conclusion is that old system code can still tell us\nhow many parts of MVS work.  The actual fact is that the old programs\nwill tell us how a component used to work, but a lot of times, it\nstill works the same way.  If you study the MVS Conversion Notebooks\nfor the various system release levels, you'll see what doesn't work\nthe same way.  Probably (much of) the rest of it, does.\n\n      I'd like to say one more thing before we get to today's topic.\nIt seems to me that many installations today do not see the need for\neducating their system programming staffs, as much as used to be.\nSHARE and GUIDE attendance has dropped off.  And even if attendance\nto these marvelous system programming \"schools\" (which is what SHARE\nand GUIDE are) has risen a bit, very recently, it isn't near the levels\nof six or seven years ago.  To me, this reflects apathy on the part of\ncomputer installations, that staff creativity and knowledge will not\nshow up on the bottom line.  My experience is that I was always able\nto save my installation a lot of money after each of the ten or so\nSHARE conferences I attended.\n\n\nWHERE DOES OLD CODE COME FROM?\n\n      The OS, MVT, and MVS worlds have benefited incomparably from\na proliferation of free software that is available, in source form.\nI think that a comparison to the IBM PC software situation will\nshed light as to why this is so.  To develop PC software, all you\nneed is your own PC, which usually sits in your own house or\napartment.  If you develop software on your PC, it's yours to sell\nor give away, as you please.  No one can stop you from doing what\nyou want with your own software.  To do comparable work on an MVS\nsystem, you've (historically) had to work at a multi-million dollar\ncomputer installation belonging to a large company or government\ndepartment.  This installation is not yours.  Any person who owned\nan MVS site was usually not the systems programmer there.\n\n      It follows that if some useful software was developed by a\nsystems programmer at the Continental Widget Corporation, that\ncompany, which was more interested in selling Widgets than software,\ncouldn't really care less about what that software could do, except\nas it affects its Widget production or sales.  The programmer would\nseldom get any personal recognition from the company for skill in\nprogramming.  The programmer usually could not market the software,\nif, for example, it was created for a company project on the company\ncomputer system.  On the other hand, the company would not care about\nthe programmer giving away the software, as long as a competitive\nWidget company couldn't use it directly to compete.  An incentive for\ngiving away the software for public use, would be that you could get\nsomebody else's software for your use.  You could also have the\nbenefit of using someone else's skill, or different configuration,\nin debugging your code.  Thus, the development of collections of high\nquality free software flourished in the MVS world.\n\n      One of the premier collections of free MVS system software is\nthe CBT MVS Utilities Tape that was started by Arnold Casinghino at\nthe Connecticut Bank and Trust Company in 1975.  Arnie maintained the\ncollection through fifteen years and 321 version levels, until 1990,\nwhen it had to be given to someone else's care.  As of this writing,\nthe current level of the CBT MVS Tape is 414, and the tape continues\nto be updated with new code.  The CBT MVS Tape is independently\nproduced and is available from several sources, one of which is NaSPA.\n\n      When the CBT Tape overflowed an uncompressed cartridge after\nlevel 404 (3158 feet at 6250 bpi), its proprietor started an overflow\ntape, so that any deleted code would continue to be available to the\npublic.  It seemed unproductive to distribute 370 feet of software as\na separate tape, so more old code was added to what became the CBT\nOverflow Tape.  The CBT Overflow Tape (now at level 413 to parallel\nthe regular CBT Tape as much as possible) additionally contains\nthe German, Swiss, UK, and Australian G.U.I.D.E. tapes, the entire\nSHARE MVS Tape (which was discontinued by the SHARE MVS committee),\nand all the material from the SHARE \"ISPF Smoke and Mirrors Tape\",\nwhich never got off the ground at SHARE.  Other old code was also\nput on the CBT Overflow Tape.  The CBT Overflow Tape may be obtained\nthrough the NaSPA office.\n\n      After CBT MVS Mods Tape (as it was then called) level 249,\ndated July 1985, Arnie Casinghino performed a series of deletions\nbecause the tape was getting filled up.  In order to ensure the\ncontinued availability of this material, Arnie deposited a copy of\nlevel 249 with the Share Program Library Agency (SPLA), now at the\nUniversity of Miami in Florida.  CBT Tape level 249 is a classic\nsource of old code, and I always keep a copy of its documentation\navailable to read.  You can get a copy of CBT Tape level 249 by\ncalling Fred Robinson at SPLA, 305-284-6257.  This tape is not\ncurrently available through NaSPA.\n\n      And what about IBM's old code?  There are the IBM source\ntapes, known as Optional Materials for MVS components.  I'd like to\nsay a word about these.  In the old days (i.e. MVS/XA and before),\nalmost all of the base-level source code, in assembler language or\ncompiled PL/S code whose output was assembler code, was available on\ntape.  The installation only needed to order a set of optional\nmaterials tapes to get a complete set of source code.  In addition,\nthere was microfiche to show the PTF-fixed assembly listings.  You\ncould see how a module worked by looking at the code.  For OCO\n(object code only) modules after 1986 or so, this service was no\nlonger available.  Now, only non-OCO modules are distributed by IBM\nin this way, with source available.  For the rest of them, you\ncouldn't see source code.\n\n      There is now a facility on IBMlink to view source listings for\nproducts you have a license for.  This helps, even though it's online\nand it's slow.  The advantage is that quite a bit of source for OCO\nmodules is now available to licensed installations.\n\n      I personally have my way of dealing with IBM source code on tape.\nThe source listings come in IEBUPDTE-unloaded files, component by\ncomponent.  Internal macros which were used by the component's\ndevelopers, but which haven't found their way to a system macro library\nsuch as SYS1.MACLIB, are also included in this source, usually in a\nseparate file.  You can usually spot such a macro file by the fact that\nits members have widely different names, instead of IEFAB4A0, IEFAB4A2,\nIEFAB4B0, etc, whose names are similar to each other.  These internal\nmacros are referred to as IBM Private Macros.  For each release of MVS,\nI try to make a library of all of the private macros I can accumulate\nfrom their Optional tape files.  Then, I can assemble any module I want\nfrom the source, by concatenating the private macro libraries with the\nsystem macro libraries to obtain a clean assembly.  When I have a\ndocumented, clean assembly listing, understanding how a module works\nis much easier.\n\n      However, you can't do this with OCO modules.  But you can take\nan older version of the module (from XA or MVS/ESA Release 3) which\nwasn't OCO, and assemble it.  Then you can compare the assembly\nlisting, and its documentation, with the existing module, and track\nthe differences.  How to do this is not in the scope of the present\ndiscussion, but if you have a little experience, you'll see that this\nidea is useful.\n\n      Although there are other sources of old code, the ones\nmentioned here are vast enough to whet the curiosity of the most\nambitious reader.  The CBT Tape documentation (File 001) and CBT\nTape File 071 list documentation for some other tapes and sources of\ncode as well.  You've got a lot of old code to look at.\n\n\nSOME EXAMPLES - OLD COMPILERS\n\n      By now, you're probably anxious to see some useful things which\ncan be done with old code.  I'll show you a few examples.  One of the\nfirst pieces of old code which comes to mind, are IBM's old language\ncompilers.\n\n      Once upon a time, all of IBM's OS software was free.  This\nincludes all of the language compilers which were available at that\ntime:  PL/I, FORTRAN, RPG, and ALGOL, among them.  Just before OS/MVT\nwas being replaced at his site, Jim Marshall (then of the U.S. Air\nForce) saved as many of the compilers and libraries as he could.  These\nwere donated to the SHARE MVS Tape (now contained in the CBT Overflow\nTape) and the CBT MVS Tape.  I was once doing some contracting work on\na very old system, and I found a copy of the old OS/360 ALGOL compiler\nand library there.  I donated those to the CBT MVS Tape as well.\n\n      It turns out that all of these compilers, with one glitch that\nwas fixed, run quite well on MVS/XA and MVS/ESA systems.  Therefore,\nif your shop happens not to have any RPG, or FORTRAN, or PL/I, you\nstill have the option of installing old versions of these, and trying\nto compile your progam source to run under them.  Some of the manuals\nmay still be available from IBM, although I can't guarantee anything.\nIBM's publications phone number is:  1-800-879-2755.\n\n      Let me tell you about these compilers.  PL/I F load modules\nare on File 092 of the CBT Tape and on File 119 of the SHARE MVS Tape\n(which is File 219 of the CBT Overflow Tape).  It was reported at the\noutset, that the compiler and library had an occasional abend on XA\n(same for ESA), which resulted from a fetch error, because the linkage\neditor for those modules was so old that XA program fetch had some\ntrouble loading a few modules into storage properly.  The problem was\nsolved by Larry Williams, who re-linkedited each load module, expanding\nevery CSECT by 8 bytes.  This forced the new linkage editor to\n\"re-think\" the entire linkedit process, adjusting the RLD counts, etc.,\nso that the XA or ESA program fetch component would no longer have\ntrouble loading these modules into main storage.  The problem was\nsolved, and the PL/I F compiler and library works perfectly now.\nThe updated load modules are on the CBT Tape (File 092), while the\nnon-updated modules are on the CBT Overflow Tape, File 219, if you\nneed reference to them.\n\n      Let me tell you how this process was done, just to show you the\nadvantage of knowing how to use public tools.  You can take any load\nmodule, and instantly generate the JCL to re-linkedit it, using the\nPDS TSO command from File 182 of the CBT MVS Tape.  The PDS command\nhas been further developed as a vendor product (called STARTOOL, from\nSerena International in Burlingame, California), but for this purpose,\nthe free version will do the job, as long as the load library is not\na PDSE.  The PDS subcommand which generates the JCL is:  MAP modname\nRELINK.  However, you don't have to restrict the module name to one\nmodule.  You can describe a \"member subgroup\" of modules in a zillion\ndifferent ways, referring to the defined subgroup with an asterisk in\nplace of the member name, or you can refer to all modules in the\nlibrary, by using a colon in place of the member name.  Thus, if you\npoint the PDS command to the PL/I compiler and library pds, you can\ngenerate a complete re-linkedit JCL stream with the simple command:\nMAP : RELINK.  Larry did this, painstakingly adding \"EXPAND csectnam(8)\"\ncards for all the CSECTS and running the resulting linkedit JCL job\nstream.  Neat, eh?\n\n      The copies of all the other compilers and libraries on the CBT\nTape, which never showed problems on XA or ESA, were all re-linkedited\nwith the DFSMS linkage editor.  The compilers in their original form\ncan be found on the SHARE MVS Tape, and therefore also on the CBT\nOverflow Tape.  Thus you have the original and modified modules to\nwork with yourselves, as you see fit.  FORTRAN G and H is found on\nFile 326 of the CBT MVS Tape, re-linkedited by Rick Fochtman.  The\noriginal version of FORTRAN G and H is on File 218 of the CBT Overflow\nTape.  Vanilla OS/360 FORTRAN H is on File 232 of the CBT Overflow\nTape.  OS/360 RPG, relinkedited by me, is on File 327 of the CBT MVS\nTape, and the original version is on File 231 of the CBT Overflow Tape.\nOS/360 ALGOL is on File 176 of the CBT MVS Tape.\n\n\nOTHER EXAMPLES.\n\n      I'll give a few other examples of old code that's useful.  All\nof us old-timers probably remember IBM's core-zapping tool called\nINCORZAP.  INCORZAP will zap the virtual storage copy of any Nucleus\nor LPA module.  It takes AMASPZAP-like control cards, looks into the\ndisk copy of the module to find the correct CSECT structure, and then\ngoes to the in-core copy to do the VERify and REPlacement operations.\nIn OS/MVT or MVS/370, this worked fine.  However, in MVS/XA or ESA,\nwhere there is fetch-protected storage and read-only NUCLEUS, INCORZAP\nwill not work to modify those areas of main storage.\n\n      It turns out that there's a charming story here.  INCORZAP,\noriginally written in PL/S at IBM around 1972, was disassembled into\nassembler code by Bill Godfrey around 1980 and put on the CBT Tape\nby Jim Marshall.  The original author of INCORZAP, Robert Budge, who\nno longer worked for IBM, and no longer had access to the PL/S compiler,\nwas looking through the CBT Tape around 1983, and saw Bill Godfrey's\nsource for his program, now in Assembler source code.  Budge, who wrote\nthe original program, and who knew all the logic, was able to modify\nthe assembler source to turn off page protection in the affected\nread-only and fetch protected storage.  The resulting product, called\nXACORZAP, can now be found on File 421 of the CBT Tape, along with a\nuser manual, written by Robert Budge.\n\n      Now what does this mean for us?  If you have to fix some old\ncode, to turn off page protection, you can take an example from the\nsource code of XACORZAP.  Original INCORZAP is on File 316 of the\nCBT Tape, and you can track the source changes that were necessary.\nAn example of such code borrowing, is the XA version of DYNABLDL,\nwhich had to modify the copy of module IGC018 in read-only nucleus, as\ncompared to the original version for MVS/370 and before, which didn't\nhave the problem.  Both versions of DYNABLDL code can be found on File\n407 of the CBT Tape.  This is a good study example for you.\n\n      A third example would be a program which accesses the APF list of\nauthorized load libraries.  The format of the APF list was changed in\nMVS/ESA Version 4, to be dynamically modifiable without an IPL.  Code\nto access the APF list in the new format can be found in SHOWMVS by\nGilbert Saint-flour, in File 183 of the CBT Tape.  Thus, if you have to\nmodify code that currently accesses the APF list in its old format, you\ncan use SHOWMVS as an example to follow.\n\n      I hope that this month's talk has proven stimulating and\ninformative for you.  If you have a systems programming job to do, it\nmay pay to explore old code.  You may find it to be Old Gold.  See you\nnext month.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9708AU": {"ttr": 16902, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x97&\\x8f\\x01\\x00)\\x9f\\x11G\\x01\\x04\\x01\\x04\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1997-09-25T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 260, "newlines": 260, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          August 1997\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.\n\n\nProfiles in Creativity\n\n      This month, we'll begin to feature the work of a few of your\ncolleagues, who have made sizable contributions to the welfare of MVS\n(or OS/390) systems programming.  These people are just like you and\nme.  They are systems programmers who maintain MVS at one or more\ninstalled sites.  In the process of doing their jobs, they have come\nup with some clever innovations, tools, and methods, to make the work\neasier.  However, they have done one more thing.  They have shared\nthe results of their work with the rest of the systems programming\ncommunity.  We can all benefit from their contributions, and therefore\nwe owe them a hearty: \"Thank You!\"\n\n      It pays to look at some of these people, and at what they've\ndone.  We might find that we could do it too.  There are some old\nadages which apply: \"The way to have friends is to be a friend.\" \"The\nway to be happy is to make other people happy.\"  \"The way to be\nsuccessful is to sometimes assist other people to also be successful.\"\n\"The way to learn is to help other people learn.\" I might also say:\n\"The way to be a better systems programmer is to help other systems\nprogrammers.\"\n\n      This process can work on several levels:  Talking shop with\nother systems programmers is one way.  Looking at other people's code\nis a second.  Using other people's public domain tools is a third way.\nWriting your own tools, and calling another systems programmer for a\ndiscussion of the work, is a fourth.  Contributing software to a\npublic tape is a fifth way.  And with each of these, if there is an\ninteraction with between you and another systems programmer, both of\nyou stand to gain in a big way.\n\n      Before elaborating on the details of this, I might add another\nthought.  I have found that often, the most fruitful of these\ninteractions occur at user groups (such as the SHARE and GUIDE\nconferences or a local user group meeting), where the participants are\nnot from the same shop.  Each person involved in the discussion is in\ncharge of a different hardware and software configuration, and has a\nsomewhat different point of view from the next person.  This diversity\nprovides a fertile ground for learning, on both sides.  Also, since\nmost of the people who are interacting are not from the same shop,\nthere is no temptation to have any petty rivalries and such, since\nnobody thinks they have anything to gain from these \"games\".  They are\nfrom different shops, and therefore they will sincerely help one\nanother.  After a user group meeting is over, the people can phone\nor E-mail each other, to continue their discussions and benefit further.\n\n      Let's get down to some examples of how you can learn, and help\nothers to learn.  I often have telephone conversations with people from\nother shops.  Sometimes, I ask them to tell me what problem they are\nworking on currently.  When they start talking, I often find that I\ndon't know about either the hardware or the software that is currently\nconcerning them.  (MVS is quite vast.)  But I ask them to tell me about\nit anyway.  In the ensuing process, both of us gain.  I gain, because I\nfind out about some new stuff I didn't know about before.  They gain,\nbecause they are talking out the problem to a \"disinterested\" other\nparty.  They gain clarity of thought, and in the process of discussion,\nnew ideas and solutions might present themselves out of nowhere.  On\nthe other hand, if I know something about their problem, I might\ndirectly help them.  On many occasions, I have made short work of\nsomeone else's tough problem, and they have done the same for me.  Both\nof us will eventually look good to our respective managements, and will\nhelp our shops in a sizable way.\n\n      Sometimes, the process of interaction occurs when I look at other\npeople's code.  Where can you find other people's code?  A lot of it is\navailable on the CBT MVS Utilities Tape, an independently produced\ncollection of goodies, which can be obtained through the NaSPA office.\nThere are more collections available through NaSPA, SHARE, and other\ngroups, as well as online from MVS discussion groups on the Internet.\nFile 001 (the documentation file) of the CBT MVS Tape, contains\npointers to many other sources of other people's code.  File 071 of the\nCBT Tape has the actual documentation files from these other tapes and\nsources.  A lot of this material is obtainable on the NaSPA CD-roms.\n\n      When I look at some code from these places, the author's name and\naddress is usually found there too.  A lot of times, if the author\nhasn't moved, I can call that person directly and have a discussion.\nI can personally testify that you don't have to be shy about calling\nanyone up.  In my entire career, I have called hundreds of these\npeople, and not one of them has been impolite to me in any way.  They\nare more than anxious to discuss their work with any person interested\nin it.  And I have formed many telephone and E-mail friendships with\nknowledgeable people.  There is no reason to be bashful.  These are\nthe people I will call, when I have a problem.  They have all been\nvery courteous and helpful to me.  I try to be the same way with them.\nThe way to have a friend is to be a friend.  And both of you gain from\nit.\n\n      Using a public domain tool, without actually looking at the code,\nis another way to learn by finding other people.  I'll often assemble\nsomeone's utility from the CBT Tape and install it.  Then, I'd try to\nlearn as much as possible about using the tool from the documentation.\nDuring this process, sometimes I can get to talk to the author and\nlearn more.  Other times, I'll ask if anyone else has experience with\nthis tool, at a user group meeting.  Or, I'll ask one of my telephone\nfriends.  In the process, I'll often gain a ton of system knowledge,\nand I'll also learn how to deploy the tool in crucial system\nsituations.\n\n      Finally, sometimes I am writing a program to address a system\nproblem, or to access a certain system resource, and the IBM\ndocumentation isn't especially clear.  I'd like to see a coding example.\nPlenty of examples can often be found on the CBT Tape, or in one of the\nother sources.  I can call up the author, or one of my telephone\nfriends mentioned above, to discuss how best to approach my particular\nimplementation of the system facility.  This personal interaction\nprocess speeds up the coding, and I usually produce a better utility\nprogram than I would otherwise have done.\n\n      Now that we've talked about the first four aspects of this\nprocess, let's meet some people who have made contributions to public\ntapes, and see what they've done to help us.\n\n\nA PUBLIC TAPE AND ITS CONTRIBUTORS\n\n      One public tape that I am familiar with, is the CBT MVS Tape.\nContributions, \"large\" and \"small\", come from all sorts of people in\nour business.  No contribution is too small.  If an idea will help\nsomebody to save time or money, it is useful, and is worth contributing.\nMy friend Eli Duttman (File 195 from the CBT Tape) has contributed some\nvery simple, but surprisingly useful CLISTs, which help him every day\nin his work.  Consider, for example, a CLIST that contains one line\nand one command:  LOGOFF.  You can name this CLIST anything you want,\nso it won't confict with another command.  In my last shop, we called\nit X.  Thus, if you're in TSO READY mode and you want to LOGOFF quickly,\nyou just type X and press ENTER.  You might also alias the name of this\nCLIST as LOG, LOGO, and LOGOF, etc. (the possibilities are endless),\nand you don't have to put it into a public CLIST library, so it won't\ninterfere with the general public.  It's a very simple idea, but it's\ndarn useful and it saves time when you have to get out quickly.\n\n      There are a huge number of other people who have made all sorts\nof contributions to the CBT tape.  I'd like to mention a few of the\nnames in particular, just to show something about the kind of work they\nhave done, and how diverse their backgrounds are.\n\n      Let's consider David Cartwright from England (CBT Tape File 172),\nVinh Vu (originally from Vietnam) who lives in Texas (File 166), Paul\nMoinil from Italy (Files 453 thru 459), Gilbert Saint-flour (originally\nfrom France) who has contributed File 183, Greg Price from Australia\n(Files 134 and 135), and Jim Marshall (formerly of the U.S. Air Force),\nwho is responsible for Files 300, 316, and 161, among others.\n\n      Dave Cartwright is an original thinker, and he has worked in\nmainland Europe as well as in England.  Since Dave speaks and reads\nGerman, he could easily profit from the German and Swiss G.U.I.D.E.\ntapes.  In fact, he is responsible for making them available in the\nUnited States (Dave sent them to me, and I contributed them to the\nCBT Overflow Tape--also obtainable through NaSPA).  Dave's software\ncollection encompasses some novel ideas, a few of which I'll mention\nhere.\n\n      Consider CAVEAT (Cartwright's Amazing VSAM Entity Automatic\nTuning).  This is a program which takes as input, the mere dataset name\nof any VSAM dataset on your system.  The CAVEAT program looks into the\nsystem (particularly the VVDS) to find out how the dataset is defined,\nand outputs IDCAMS ALTER cards to optimize the number of index buffers,\nso the entire INDEX set is always in main storage.  Until recently,\nthis worked \"amazingly\" well.  It could be driven off any list of VSAM\ndatasets, to optimize access time to the data, by adjusting the number\nof index (or even data) buffers for all of these datasets.\nUnfortunately in the latest versions of DFP, IBM has taken away the\nBUFNI and BUFND parameters from the ALTER command of IDCAMS, but you\nhave to admit that the ideas behind CAVEAT are dynamite.  It may be\npossible to fix CAVEAT to output VSAM JCL, where the buffer parameters\nmay still be found.  Any person's work to fix CAVEAT for the latest DFP\nwill be greatly appreciated.  You can get the address of the proprietor\nof the CBT Tape through the NaSPA office, and contribute your work\nthere.\n\n      Dave Cartwright has a lot of other good things on his CBT Tape\nfile.  Among these are an external writer to archive SYSOUT to tape or\nSMS datasets.  This is called CHEW (Cartwright's Housekeeping External\nWriter).  Once your SYSOUT is on SMS, HSM can manage it.  This might\nbe a good idea for your shop.  Among Dave's SMF reporting programs is\nCRAP (Cartwright's RACF Accounting Program) which reads SMF Type 80\nRACF records and produces reports.  If you have documents in old\nWaterloo Script format (see the CBT Overflow Tape for that), and you\nnow have DCF/GML, Dave has an edit macro to convert the document.  And\nthere's much more on his file for you to profit from.  Dave told me\nthat when he has to write a new program, he himself profits from File\n172 by borrowing \"already tested\" segments of code from there.  Dave's\nE-mail address is:  dcuk@dcuk.demon.co.uk\n\n      Vinh Vu (CBT Tape File 166) is equally creative, although his\nstuff deals with different things.  Vinh has a program to display Job\nactivity, a REXX exec to display MVS control blocks, linklist, APFLIST\netc., a program to refresh any single module in LLA (or VLF), and he\nhas much more than that.  His file is very much worth exploring.\n\n      Paul Moinil is one amazing person.  At last report, he has been\nworking in Ispra, Italy, at a shop which was discontinuing its use of\nMVS.  Paul's AMDAHL representative in Italy, Antonio Colombo, sent this\nenormous collection of over 300,000 lines of code, to the proprietor of\nthe CBT Tape.  Much of what Paul did, was to make modifications, large\nand small, to improve a very large number of public domain programs.\nThis is in addition to Paul's original work.  The files (453 through\n459) are so large, that I can't single out a few things which are\nespecially noteworthy.  But I will say this:  If you have some favorite\nprogram from the CBT Tape, such as Fullscreen ZAP for example (see File\n134), I'll advise you to also look at Paul's version of it to see what\nhe's done, and how he's modified it.  Also, if you want to find many\nconvenient ways to shorten your system work, you would do well to search\nthrough Paul's files and see what he has there.\n\n      My good friend Gilbert Saint-flour has contributed File 183 to\nthe CBT Tape.  I have written in the past about his amazing SHOWMVS\nprogram, which in its latest version that I have used, produced over\n4000 lines of output, reporting all kinds of status about our large\nMVS system and my own TSO session.  File 183 is a large collection of\nuseful and varied tools, such as the LOADMLPA program to refresh MLPA\non the fly, or an SVCUPDTE program to do the same for a Type 3 SVC.\nThere is a program to prevent timeouts of your TSO session, a\ngeneralized extension of the ISPF BROWSE facility, and there is much\nother miscellaneous software to help you.  Gilbert has done a lot for\nus.\n\n      Greg Price in Melbourne Australia, cut a lot of his System\nProgrammer teeth writing and modifying MVS software for Fujitsu systems.\nSince Fujitsu hardware and software (to my knowledge) is not sold in\nthe U.S., Greg's experience cannot be recreated easily here.  His\ncollection of his own, and his friends' software from Australia, is\nvery extensive.  Many of his programs, such as his vast extension to\nBill Godfrey's REVIEW \"file browsing\" program, reflect enormous system\nand control block knowledge.  I know this from my many long\nconversations with Greg.  Much of his knowledge specifically comes\nfrom the differences between Fujitsu software and MVS.  We can all\nprofit from it, by looking at Greg's files (134 and 135) on the CBT\nTape.\n\n      Jim Marshall was in the U.S. Air Force as a Systems Programmer\nfor many years, during which time he had the privilege of working\ntogether with many skilled coders.  Jim sent the other people's stuff\nto the CBT Tape and the MVS SHARE Tape (now part of the CBT Overflow\nTape).  Bill Godfrey, who was a pioneer in MVS system coding, told me\nthat his code would never have been known (and improved) by the\npublic, had it not been for Jim Marshall.  Jim contributes a very\nlarge file of TSO programs and commands (File 300) and a large file of\nbatch utilities (File 316).  My own career has been greatly shaped by\nthe fact that Jim Marshall took the time and made the effort to send\nother people's code in.  You owe what you're reading to Jim Marshall,\nmy teacher Jeff Broido, and to all the others who took some time to\nhelp someone else.\n\n      That's it for now.  Help yourself by helping and contacting\nothers.  Good luck.  See you next month.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9709SE": {"ttr": 16907, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x97&\\x8f\\x01\\x00)\\x9f\\x11G\\x00\\xe6\\x00\\xe6\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1997-09-25T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 230, "newlines": 230, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         September 1997\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.\n\n\nSYSTEM PROGRAMMER CREATIVITY\n\n      Oftentimes, there's a way to do one of our jobs, but it's\ncumbersome and time consuming.  I've had to do things this way, as\nhave all of us, every once in a while.  Have you ever had to copy a\nlong list of PTF numbers to put into an SMP/E job?  I'm sure you've\nall had to do that more than once.  Haven't you ever wished you could\njust have the computer read an SMP/E APPLY CHECK report and generate\nyour list of PTFs automatically?  Here's another case.  I know of one\nsoftware vendor that makes it very hard to read its distribution tape\nand load the programs onto disk.  You have to write three lines of\ncontrol information for each individual program you want loaded into\nits disk source library.  This involves a lot of file editing.  Don't\nyou wish that such a job would have been made easier and more\nautomatic?\n\n      To these questions, many of us simply shrug our shoulders and\nsay that this is a part of our life.  Sometimes you just have to do the\ncumbersome hard work, to achieve the proper result and set up the\nsystem or the component properly.  However, very often, if you'll be a\nbit inventive one time, you can save the repetition of some jobs, many\ntimes.  That's the subject we're talking about today.\n\n      For instance, in the case of the product that requires 3 lines of\ncontrol cards for every program name you want to unload from the product\ntape, I wrote a CLIST which reads in the list of program names, and\ncreates the required 3 lines of output for each name.  To write a simple\nlist of 100 program names and to run a CLIST, is a lot easier than\nto edit a list three times as long, in a fiendish format.\n\n\nUSING AN INVENTION TO SAVE WORK\n\n      I'm going to start with an example that doesn't directly apply to\ntoday's MVS system programming, but which illustrates a few valuable\npoints that we can employ in our current work.  Those of us who were\naround in the days of SMP4 or before, will really appreciate what I have\nto say here, while I hope to explain the concepts clearly enough, so\nthat everyone else will get the points, too.\n\n      IBM used to send all the system's fixes in a monthly tape, called\na PUT tape.  Each installation would keep up-to-date by APPLYing (with\nSMP - the System Maintenance Program) as many PUT tapes as they desired,\nto keep as current as they felt they needed to be.  Later, the same sort\nof maintenance could be done with CBPDO tapes, but since CBPDO tapes\nare designed to be used with SMP/E, and my work was done with SMP4, I'll\nrestrict this example to refer to PUT tapes.  PUT tape maintenance was\ndesigned so that you would generate a partitioned dataset called the\nPUTPDS.  Part of the PUT processing was to fill the PUTPDS with members\ncontaining all the information needed to install the PTF fixes properly.\n\n      What if a PTF was found to be in error (or PE'd) after it was\ninserted into a PUT tape and distributed?  Nowadays, with SMP/E, the\nPTF is placed into HELD status by RECEIVEing a ++HOLD statement into\nSMP/E's HOLDDATA in the GLOBAL zone.  But SMP4 had no such thing as a\nHELD PTF.  With SMP4, all PTFs had the same status.  They were all\neligible to be APPLYed to the system, unless they were specifically\nEXCLUDEd in the APPLY control cards to SMP.  Thus, in order not to\nAPPLY a bad PTF, you had to include it in what was called the \"EXCLUDE\nlist\" in all mass APPLY and ACCEPT runs.\n\n      Therefore, if IBM found that a PTF was in error, it would mention\nin the PUT tape, or in a PSP bucket, that the PTF was to be included in\nthe EXCLUDE list.  The PUT tape processing itself would generate a list\nof known PTFs from the current or previous PUT tapes, to be excluded.\nYou then would add more bad PTFs to the list, from the PSP buckets, or\nfrom other information gotten from the IBM Support Center.\n\n      Now let's ask ourselves, what happens when a PTF is EXCLUDEd,\neven with SMP/E, and it is a prerequisite for other PTFs to be APPLYed?\nThe answer is, that the other PTFs also can't be put on, for the reason\nof a missing PRErequisite or coREQuisite PTF, and an error message is\ngenerated.  In the SMP4 days, when many PTFs were specifically excluded,\nand you ran an APPLY CHECK job, this error list was often very long.\nSuppose now, that you were putting on six PUT tapes, and you got an\nerror list (of missing prereqs) a mile long.  You'd scan the error list,\ncopy (by hand) more PTF names to the EXCLUDE list, and rerun the APPLY\nCHECK job a second time.  Then you'd get more error messages, if the\nnewly excluded PTFs were also prereqs to other PTFs you were trying to\nAPPLY.  But the error list would become gradually shorter, because it\nonly referred to PTFs that weren't yet on your system.  After the second\nAPPLY CHECK run, you'd look at the error messages still outstanding,\ncopy more PTF names to the EXCLUDE list, and run the APPLY CHECK for a\nthird time.  You'd repeat this process until the APPLY CHECK run was\nclean.  Often it could take six, seven, or eight iterations.\n\n      Now please bear in mind that in those days, a mass APPLY CHECK\nrun on a large system might take close to an hour.  Copying the newly\nexcluded names from the previous APPLY CHECK run might also take an\nhour.  Thus, the process of putting on 6 PUT tapes worth of maintenance\nmight consume the system programmer's full time for a day or two.\nThere would be no time to do anything else, on those days.\n\n      I solved those problems by writing a program to read a disk copy\nof an SMP4 APPLY CHECK report, and to create a list of new PTF numbers\nto be added to the EXCLUDE list.  The new numbers were then sort-merged\ninto the old EXCLUDE list, duplicate numbers were removed with a program\n(SMP wouldn't tolerate them), and a new APPLY CHECK job was generated.\nThe whole recycling time took two or three minutes.  While these APPLY\nCHECKs were running, my time was free for other things.  Mass PTF\nmaintenance was no longer an all-consuming chore.  As a by-product, my\ninstallation was far less hesitant to keep the system current, because\nit took less work.  Therefore, the whole site benefited, because it was\nrunning a more current, and error-clean, system.\n\n      Most of my SMP system is old now, but it can be found on File 058\nof the CBT Overflow tape, an independently produced software tape with\nolder, but useful code, that can be ordered through the NaSPA office.\nThe part of this system which is still useful nowadays, can be found on\nthe CBT MVS Utilities Tape (also obtainable through NaSPA), on File 118.\nMy point in showing this, is that the time spent writing one or two\nprograms (a day or two) can often save many days of your work, far into\nthe future.  I used this package of programs in my work for six years\nafterward.  Furthermore, the idea of what was done, is not dead.  The\nsame idea can (and has) been used over and over by me, for other\nwork-saving projects.\n\n\nAVOIDING REPETITIVE WORK\n\n      Any time you have to do a tedious job which is repetitive, you\nhave a good candidate for a small programming project, to let the\ncomputer do most of the work for you.  One of my previous sites had\nmultiple LPARs which ran copies of a standard system residence pack.\nContained on the res pack was also an SMP/E target zone with all the\nsoftware installation information.  We would develop every new res pack\non a test system, and then it had to be cloned to all the production\nsystems.  Our site developed a CLIST which made most of this cloning\nprocess completely automatic.  You just would enter the source pack\nwhich was the model for the clone, and the target pack which would be\noverlaid by a \"near copy\" of the source pack.  Then you would enter a\nlevel number from 01-99 (the installation assigned maintenance level of\nthe source res pack) and you would enter today's date.  The CLIST would\ngenerate a complete multi-step batch job to properly create a new res\npack with all the library information and SMP zone information (with the\nzone renamed) copied from the old one.\n\n      This CLIST method had a tremendous advantage over hand methods of\ndoing the same thing.  Suppose you had some JCL which did this job, and\nevery time you wanted to do a clone, you would modify this JCL.  There\nwould be a lot of margin for error.  First, you might not do a global\nchange for everything that is different.  The new pack might have some\nincorrect pack names embedded in some of its components, such as the SMP\ntarget zone.  Second, a typographic error might slip in unnoticed, and\ncause damage.  A subtle malfunction in an operating system res pack can\nbe very dangerous to the installation, later.  Third, adequate records\nof the changes would probably not be made; the CLIST takes care of this\nautomatically.  Finally, each LPAR that is running, is properly labelled\nwith its correct maintenance level, so the central administration of the\nsite can easily oversee which division is running which software level.\n\n      You can find a sample of this system on Files 204 and 205 of the\nCBT MVS Tape.  Similar systems for CICS and DB2 can be found there also\non Files 210 thru 213.  You can use these as starting points, and\ndevelop customized automated procedures appropriate for your shop.  If\nyour shop needs these things, a few hours or days spent setting these\nup, will pay for themselves for years afterward.\n\n\nCHOICE OF LANGUAGE\n\n      If you are developing an automated procedure for yourself or your\nsite, I'd recommend picking a progamming or interactive language that\nis easy for you to use.  If you're familiar with CLISTs, I'd suggest\nyou start there.  If you know REXX better, then use REXX.  For some\nprojects, speed of execution makes a difference.  Compiling a REXX exec\ncan speed it up.  Assembler programming is good for speed of execution\nand for availability of system facilities to help you.  That'll only\nwork if you're familiar with programming in assembler.  I wrote most of\nthe SMP system mentioned above, in COBOL, because I had been an\napplication programmer before, and at that time, I was more fluent in\nCOBOL than in assembler.  The rule is, don't make the job unnecessarily\nhard for yourself.  Use the language that is easy for you.\n\n      That's all true if you're writing the tool for yourself.  What\nabout the case where most of it's been done by somebody else?  The\nanswer is, that you'll have an easier job, and a harder job.  It's\neasier, because someone else has done most of the work.  It's harder,\nbecause you may have to understand a program written in a language\nyou're not so familiar with.  My experience is mostly drawn from\nlooking at other people's work that I found on the CBT Tape.  When I\nfirst started doing this, I'd print out the other person's program, and\nI'd only look for the parts I had to change.  Usually, a small change\nwas adequate to customize that program for my needs.  Later, I built on\nmy previous knowledge, and was consistently able to see more.  My\ngeneral take on this matter, is that if you know how the program works\nexternally, you'll be able to learn to pick out the parts of the\nprogram source that you need to change, despite the language barriers.\n\n      I'd like to conclude by saying something I heard many times from\nmy teacher, Jeff Broido, and which I found from my travels, that people\nneed to hear.  Jeff always told me to invest a half hour a day in\nexploring, and expanding my horizons.  Invest some time in learning\nsomething new, and it will pay itself back many times over, for many\nyears to come.  This applies to writing a new tool, as well as learning\nabout some existing tool.  It can be fulfilled by exploring the software\ngoodies on the CBT Tape or in some other public forum.  Or it can even\nbe satisfied by spending some time in learning the ISPF Tutorials.  By\ndoing this, you'll certainly come across new techniques which will save\nyou work later.\n\n      As trivial as it may sound, learning the commands of ISPF EDIT\nfrom the Tutorials, will help you to write EDIT macros, which are a\nvery significant work shortener.  Any new fact you can pick up, is a\npotential time saver.  Once you've seen the Tutorials for ISPF EDIT,\nyou might explore two EDIT macro collections on the CBT Tape by Paul\nDavis, on Files 095 and 251, for examples of what can be done.  After\nthat, you'll be in a position to apply these techniques to shorten your\nown everyday work.\n\n      I hope that this month's talk will be of help to you.  Mental\ninertia is a hidden enemy of all programmers.  After an initial burst\nof learning, there often is a lot of time spent resting on one's laurels\nuntil the next shock comes.  Investing a half an hour every day for\nsome type of exploring, is a trick that can guarantee your continued\nmental growth.  Shortening the time needed to be spent on each task,\nwill then come naturally.  Good luck.  See you next month.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9710OC": {"ttr": 17157, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x97&\\x8f\\x01\\x00)\\x9f\\x11G\\x01\\x1d\\x01\\x1d\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1997-09-25T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 285, "newlines": 285, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          October 1997\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.\n\n\nWHY NOT RUN A BATCH JOB?\n\n      Often, we forget our roots.  While we're caught up in the\nlatest developments in our industry, we forget that our field has had\na rich past.  We're not exactly punching cards any more, but the vast\npotential of running system utilities via a batch job, has yet to be\nfully tapped and exploited.  Today, I'd like to open your eyes to\nworlds of opportunity, in our current environment, that lay yet unused\nby most of us.  After you've finished reading this article, the concept\nof running a batch job will have a lot of new meaning.\n\n      While it seems that most of us have our JCL handy, to run batch\njobs for our work, I am under the impression that we don't usually\nthink of this JCL when we are trying to fix something.  For example, we\nhave JCL to back up a disk pack with FDR or DFDSS (or whatever utility\nyou use to back up a pack).  We use JCL when we want to initialize a\npack (because that's how ICKDSF is usually run on an MVS system).\nAllocating a complicated VSAM file is another case when we run (and\nsave) the JCL.  However, if a large collection of datasets (such as\nDLIBs) has the wrong allocation parameters, such as too few directory\nblocks, or too small a secondary space allocation, we don't think of\nrunning a batch job to fix that situation.  I'll talk more about this,\nlater.\n\n      I always save my old JCL.  I worked at one shop for almost seven\nyears, and the JCL collection from there consisted of almost 2300 pds\nmembers.  My collection from another shop, where I was working for\nalmost five years, amounted to well over 1000 new members.  While I was\nworking at the later shop, my collection of JCL from the earlier shop\nwas always online and handy.  I also save different copies of the JCL\nfrom different runs, and I don't often retype over old JCL if the job is\na bit complicated, or a particular case is unique.  I make another copy.\nWhy do I do this?  And how do I manage to quickly find the exact JCL\nmodel that I need?\n\n      My own JCL philosophy is based on the premise that I am the\n\"doctor\", responsible for the \"health\" and smooth running of the\ninstallation's operating systems at all times.  If there is a system\nemergency that requires running a batch job to fix, I do not want to\nspend a lot of time customizing my \"one copy\" of ICKDSF or IEBCOPY JCL\nto adapt to that particular emergency.  I'd rather have a copy of JCL\nhandy, which is very close to what I need.  Maybe a dataset name is\ndifferent, and that's all.  Then, I'll solve the problem much quicker,\nand be less prone to making a typing error that could spoil more than\nit fixes.  This accounts for why I prefer to have many IEBCOPY or\nICKDSF jobs around, for example.  How do I find the right JCL quickly?\nThat's another question.\n\n      I have two basic techniques for quickly finding the right JCL.\nThe first is my naming system for jobs.  I always assume that I'll keep\nmore than one copy of any kind of job.  I'll start by naming one\nprototype JCL member with a normal name, such as IEBCOPY.  Afterwards,\nall the subsequent copies, which are variations of the first copy, will\nhave ordered suffixes, so the next IEBCOPY job will be called IEBCOP01,\nand the next, IEBCOP02, and so on.  Or I might use IEBCOPYA, IEBCOPYB,\netc.  Then, I use the ISPF technique of pulling partial member lists,\nto keep things relatively simple and easy to find.  However, I have\nanother tool, which is my ace in the hole.\n\n      For many years, I have used the multi-talented free utility\ncalled \"PDS\", from the CBT MVS Utilities Tape (File 182) or its\nvendor-supported successor called \"STARTOOL\" (from Serena in\nBurlingame, California).  The PDS utility supported its own member list\nsystem, which allowed for partial ISPF member listing, years before\nISPF itself did.  In addition, PDS can build its partial member list on\nthe basis of whether a certain data string is found, or not found, in\nthat member.  This allows me to find all of the IEBCOPY JCL easily, for\nexample.  Suppose I have a large partitioned dataset of JCL, not\nnecessarily my own (so it's not organized with my nice member name\nconvention), and I want to find all of the IEBCOPY jobs and make a\npartial member list of them only.  I simply point PDS to the dataset\nwhere I have the JCL, and enter the command:\n\n        FIND : /PGM=IEBCOPY/ THEN(MEMLIST)\n\nThis means that PDS should look at all dataset members (the colon \":\"\nmeans \"all members of the dataset\"), and choose only members containing\nthe data string \"PGM=IEBCOPY\".  Then it should construct a partial ISPF\nmember list containing only those members in which it found the string.\nFrom that PDS member list, I can BROWSE, EDIT, RENAME, or SUBMIT any\nmember.  So you see that with this tool, I have no trouble at all,\nhandling a huge JCL dataset with ease.  It doesn't even have to be my\nown JCL.  It can be anybody's.\n\n      That's how I handle batch JCL in general.  Now we'll talk about\nsome batch job techniques you may not have heard of.  But even if you've\nheard of them, you probably haven't fully exploited them.\n\n\nSOME BATCH JOB INNOVATIONS - TSO-IN-BATCH\n\n      Batch jobs have the advantage that they don't tie up your\nterminal.  A batch job runs in its own address space that was started\nby an initiator, while your TSO terminal session runs in a different\naddress space at the same time.  Suppose a TSO task is tedious, and\ntakes a lot of time at the terminal.  Often, you can set this task up\nto run as a batch job instead, and when it's finished, you can examine\nthe result.\n\n      A batch job which executes TSO commands, uses a technique called\n\"TSO-in-batch\".  To set up a TSO-in-batch job, you execute PGM=IKJEFT01,\nwhich is the normal IBM TSO terminal monitor program.  Required DD names\nare SYSTSPRT (instead of SYSPRINT), SYSTERM, and SYSTSIN (in place of\nSYSIN).  TSO commands are entered as data in the SYSTSIN DD name, or in\nthe PARM field.  A sample TSO-in-batch job is shown in Figure 1.\n\n      Output from a TSO command, which normally goes to a terminal,\ncan go to the SYSTSPRT DD name under certain conditions.  There are\ntwo main techniques for producing terminal output in a TSO command.\nThese are either from the IBM services TPUT and TGET, or from a\ndifferent set of services called PUTLINE, GETLINE, and PUTGET.  The\nTPUT service is easier to use in a program, but it has the disadvantage\nthat its terminal output cannot be sent to the SYSTSPRT DD name when\nthe command is run under TSO-in-batch.  The PUTLINE service is harder\nto program, but all the terminal output will appear in the SYSTSPRT\nDD name under TSO-in-batch, and it can be sent to a dataset for further\nprocessing, or to keep for a later time.\n\n      Now we'll get to the nitty-gritty of this article--the\ninnovations.  All of the following examples are planned as prototypes,\nto get you to start thinking of new things you can do.  Given these\nexamples, and some cleverness, you'll expand your techniques to cover\nlots of new situations in which you can get a job done.\n\n      Let's start with something relatively simple.  Almost any TSO\ncommand can be run under TSO-in-batch.  If you don't care about the\noutput, even a program that uses the TPUT interface, can be run\nusefully.  I'll give an example.  Most IBM-supplied TSO commands have\nbeen programmed using the PUTLINE service.  However a notorious\nexception is IBM's TSO RENAME command, which uses the TPUT interface.\nNevertheless, if you have a large number of datasets to rename, you\ncan create a card-image dataset with the general format:\n\n   RENAME dataset.name.a1  dataset.name.b1\n   RENAME dataset.name.a2  dataset.name.b2\n   RENAME dataset.name.a3  dataset.name.b3\n\nand point the SYSTSIN DD name in a TSO-in-batch job to this dataset.\nThe TSO command RENAME will do its work, but the SYSTSPRT DD name will\nnot show any output from the command executions.  It doesn't matter.\nMost probably, the datasets will be properly renamed, unless there is\nan outstanding enqueue on one of the names.  You can use ISPF 3.4 or a\nVTOC listing utility to find out how well the renames worked.  This\ntechnique is especially good, if you have to rename hundreds, or\nthousands of datasets at a time, and the datasets are cataloged.\n\n      Another direction in which TSO-in-batch is supremely useful, is\nwhen we're trying to see a display or a report from a TSO command or a\nCLIST, and the TSO command or CLIST is long-running.  To execute the TSO\ncommand or CLIST from a terminal, would tie up the terminal for an\nexcessively long time, and would interfere with our other work.  Of\ncourse, this technique would only be useful for those TSO commands which\nare programmed using the PUTLINE terminal interface.  For example, a\nsystem TSO administrator would like to synchronize userids in the\nSYS1.BRODCAST dataset with the current collection of TSO userids.\nIssuing the ACCOUNT and SYNC TSO commands from the terminal might take a\nlong time.  Instead, this administrator might run a TSO-in-batch job\nunder the (privileged) administrator userid.  A lot of terminal time\nwould be saved, and the job's report, with its time and date records,\ncould be archived as proof that the job was done properly.  Reports\nproduced by other TSO commands, with longer outputs, can be similarly\ngenerated and archived for your records.\n\n      A third direction in which we can go, is to use non-IBM commands\nand batch programs.  The CBT MVS Tape, an independently produced\ncollection of free software (which can be ordered through NaSPA),\ncontains a huge collection of such TSO commands and batch programs.\nWe shall use some examples from the CBT Tape as starters, to get you\nto look further at the possibilities in this direction.\n\n      For example, let's consider Bill Godfrey's CDSCB (change the\nDSCB) TSO command from File 300 of the CBT Tape.  CDSCB is an\nauthorized TSO command, which changes the dataset allocation attributes\nof a dataset, such as BLKSIZE, LRECL, RECFM, and secondary SPACE.  This\nis done by changing the VTOC entry directly.  However, it is safer to\nuse CDSCB than to directly zap the VTOC, because you know that the\ncorrect VTOC fields will be changed.  CDSCB also has a tremendous\nadvantage because it can be used in batch.  Hundreds of datasets can be\nfixed at the same time.  How is this useful in a practical situation?\n\n      Everyone knows that the dataset allocations of IBM's distributed\nsystem datasets, leave much to be desired, especially if the datasets\nare to be reused later.  Often, when IBM distributes a set of DLIBs or\nTARGET libraries, the secondary space will be 1 track for a small\ndataset, and if that library is reused, it can quickly run out of\nextents.  A mass APPLY or ACCEPT job can easily fail.  Another source\nof dataset failure is when there aren't enough directory blocks.  I'll\ndeal with that later.  I can solve the secondary allocation problem\nfor all your DLIBs, in one fell swoop, using CDSCB.\n\n     You can run a TSO-in-batch job, using CDSCB, by creating a\ndataset consisting of your list of DLIBs.  You might even create this\nlist, using ISPF 3.4 run in batch.  (ISPF can be run in batch.  So can\nSDSF.  See the appropriate IBM manuals, because I don't have space to\ndiscuss that topic here.)  The list of DLIB names should be edited and\nconverted into a format similar to the following:\n\n   CDSCB  dlib.name.a   ALLOC(TR) SPACE(15)\n   CDSCB  dlib.name.b   ALLOC(TR) SPACE(15)\n\nand so on.  This will make sure that secondary space allocation will\nbe in tracks, for each named dataset, and that each secondary extent\nallocation will be 15 tracks, instead of perhaps, 1 track.  For larger\ndatasets, you can set the secondary allocation to be appropriately\nlarger.  Running this job, will reset all of the secondary allocations.\n\n      There is a catch here.  CDSCB has to be run authorized.  I'll\nnow tell you a fact.  Load module IKJTABLS, which contains CSECT\nIKJEFTE2 that contains the names of authorized TSO commands allowed,\nwill override the global TSO Parmlib settings, provided that it is run\nfrom an authorized library as an authorized STEPLIB.  You can therefore\ncreate your own copy of IKJTABLS, with CDSCB zapped into IKJEFTE2, and\nput it in your own authorized STEPLIB.  If you use that library as a\nSTEPLIB in a TSO-in-batch job, CDSCB will work.  See Files 185 and 186\non the CBT Tape for help.\n\n      This solves the secondary SPACE problem for your set of DLIBs.\nHow about the small directory block allocation problem?  Answer:  The\nfree PDS command (or the vendor product STARTOOL) contains a subcommand\nto expand the number of directory blocks in a partitioned dataset,\nwithout reallocating the dataset.  The format of this PDS subcommand is:\n\n   FIXPDS EXPANDDIR(nn)\n\nwhere nn is the number of additional directory blocks desired.  The\ncommand works by figuring out if there are any members located at the\nbeginning data area of the dataset, past the directory area.  Then a\nquestion is asked:  If the dataset would contain nn additional\ndirectory blocks, which members' data would get overlaid?  These\nmembers are then moved to the end of the dataset.  Finally, this area\nat the beginning of the data area, is reformatted as the additional\ndirectory blocks.  Neat.  Additionally, the PDS command does not have\nto be run authorized.  Thus, you can run a TSO-in-batch job to invoke\nthe PDS command as follows:\n\n    PDS 'dataset.name1'\n    FIXPDS EXPANDDIR(mm)\n    CHANGE 'dataset.name2'\n    FIXPDS EXPANDDIR(nn)\n\nand so on for all your DLIBs will small directory allocations.\n\n      We've run out of space here.  But I hope I've stimulated your\ningenuity to create some innovative batch jobs.  If your installation\nwill run smoother, and your work will take less time, we've accomplished\nsomething.  Good luck.  See you next month.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   Layout of a TSO-in-Batch Job.  Note that the actual TSO\n            commands to be executed, are placed in a list in the\n            SYSTSIN ddname.  Only TSO commands which put out their\n            output using the PUTLINE interface (and not the TPUT\n            interface) will show output under TSO-in-Batch.  Standard\n            IBM-supplied commands usually use the PUTLINE interface,\n            but not always.\n\n\n\n//TBATJOB JOB (insert your job card information here)\n//STEP01  EXEC PGM=IKJEFT01,REGION=4096K,DYNAMNBR=50\n//STEPLIB  DD DISP=SHR,DSN=your.steplib.name    (authorized if needed)\n//SYSPRINT DD SYSOUT=*\n//SYSTSPRT DD SYSOUT=*\n//SYSTERM  DD SYSOUT=*\n//SYSTSIN  DD *\n LISTC LEV(SYS1) ALL\n LISTC LEV(SYS2) ALL\n/*\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9711NV": {"ttr": 17163, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x97)\\x9f\\x01\\x00)\\x9f\\x11G\\x00\\xfb\\x00\\xfb\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1997-10-26T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 251, "newlines": 251, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         November 1997\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.\n\n\nHELP IN KEEPING YOUR SYSTEM UP\n\n      Twenty-four by seven operation, or having your MVS system\n(almost) always up, is a requirement in more and more places\nnowadays.  Even if your shop isn't handicapped by the necessity of\nsuch a requirement, the amount of \"scheduled down time\" for your\nsystem, is usually minimal.  In the heat of the day's production\nwork, you certainly don't want the system down because of a small\nproblem, and you'd rather have a way to fix the problem while the\nsystem is running.\n\n      Today, we'll have a discussion of a few things you can do,\nto make dynamic changes to your system.  IBM has also gone this route\nduring the last few years.  Dynamic APF list changes, dynamic Link List\nchanges, dynamic LPA list changes, dynamic UCB changes, and other ways\nof reconfiguring your system while it is running, have either already\nbeen made a part of MVS (OS/390), or soon will be.  The reason for\nthis is obvious, and has been expressly stated by IBM.  With more of\na requirement, in many shops, for continuous operation of the system,\nthere has to be a way of making sizable changes without an IPL.\n\n      The general principle of a dynamic change is quite easy to\nunderstand.  It used to be, in older versions of MVS, that certain\nsystem resources, lists of resources, or pointers to resources, would\nbe created at IPL time.  These would occupy a fixed place in the\nnucleus area or another common area of machine storage, where their\ninformation would be accessible to all jobs and tasks running in the\nsystem.\n\n      A typical example of such an arrangement, is the configuration\nof peripheral devices available to the MVS system.  It used to be,\nthat you'd have to statically define a list of all devices that your\nsystem would conceivably have access to.  Then you'd have to run a\nprocess (now obsolete) called IOGEN which is a subset of SYSGEN or\nSystem Generation, where all of these devices would be represented by\na fixed area of Unit Control Blocks (or UCB's), built into the system\nNucleus.  There would be (as there still is) one UCB for each device.\nThese could not be changed, except by a complete rebuilding of the\nsystem Nucleus through another SYSGEN process.  And it was then\ninconceivable to add new devices to the system, except with\nconsiderable difficulty, and with much prior planning.\n\n      IBM worked to make the arrangement and creation of UCB's more\nflexible.  First, the large, contiguous fixed block of UCB's was moved\nout of the Nucleus itself.  (This was at the MVS/XA 2.2.0 level.)\nThus, you could replace a Nucleus without altering the I/O\nconfiguration.  Then, at the MVS/ESA 4.2 level (approximately), the\nlarge, contiguous block of UCB's was replaced by a flexible definition\nof UCB's in common storage, where the UCB's were not necessarily\ncontiguous to each other, but were pointed to by a much smaller,\ncontiguous set of pointers--a UCB lookup table.  By the MVS/ESA 5.1\nlevel for sure, the original UCB lookup table could be dynamically\nreplaced by another one, allowing for the addition of new devices \"on\nthe fly\", without an IPL of the system.\n\n      All of this allowed for the avoidance of a system IPL, when a\nsystem configuration needed change.  There is a general principle\nbehind this.  Old systems were storage-constrained, and there wasn't\nmuch room to put system resources that were required by everyone.\nTherefore these resources were put into fixed blocks of storage in\nsome common area at IPL time.  With the advent of XA (a 2-gigabyte\npotential region) and ESA (easy cross-access to more than one of these\nregions), together with bigger real storage facilities to support\nthese virtual storage potentialities, it became possible to think of\ncreating multiple copies of a system configuration, that could be\nchanged.  There was now enough \"room\" in the computer.\n\n      It also helps if the contiguous block of resource information\ncan be broken up into many single pieces that are chained together, so\nthat if you add one new piece, you don't have to replace the entire\ncollection of information.  You just chain the new piece in with the\nothers.  For example, if you add one new resource, you can add it into\nthe existing chain of resources, without having to create an entire\nnew chain.  IBM has been gradually restructuring its various system\nresources in this way, so that formerly unchangeable resources, could\nbe altered \"on the fly\", without an IPL.  The system could then be\naltered, but it would remain up continuously.\n\n\nWHAT CAN WE DO?\n\n      We ourselves are running various levels of MVS, or OS/390.  Some\nof us, who are running the newer systems, can take more advantage of\nIBM's improvements.  There are more dynamic facilities available on\nthe newer systems.  However, I wish to discuss some tools today, which\nare available for many of the older systems, as well as the newer\nones.  By knowing about these tools, and the techniques and principles\nthey are based on, you can improve your \"up time\" in any MVS shop, and\noften avoid IPL's when you don't want to have them.\n\n      In this column, I always advocate that you should do any job by\nwhatever means you have.  If your installation has purchased a vendor\nproduct, then by all means, you should use it.  However, I make it a\npractice not to write about a vendor product, when a free one will\nalso do a similar job, even if the vendor product is better.\n(Sometimes the free one happens to be better.)  The reason for this is\nthat the shops with low budgets, or without that particular product,\nshould also be able to benefit from the information presented here.\nAn enormous collection of free system tools is available on the CBT\nMVS Utilites Tape, which is independently produced, and is available\nthrough the NaSPA office.  The CBT Tape is updated quite often.  A\nrecent version of the CBT Tape is included on the NaSPA CD-rom disk,\ntogether with other collections.  There are quite a few tools,\npackages, and facilities available on the CBT Tape, which can be used\nto fix a system problem \"on the fly\", and to avoid an IPL.\n\n      The facilities we'll talk about today are:  XACORZAP, LOADMLPA,\nSVCUPDTE, and Fullscreen ZAP.\n\n      XACORZAP has an interesting story.  Old-timers among us will\nremember IBM's INCORZAP program, that was distributed as object code\nby the Field Service Representatives.  INCORZAP will zap the in-storage\ncopy of a Nucleus or LPA module, if the exact same program exists also\non disk, in SYS1.NUCLEUS or SYS1.LPALIB.  INCORZAP takes AMASPZAP-type\ncontrol cards; the only difference is that you execute PGM=INCORZAP\ninstead of PGM=AMASPZAP in the batch job.  INCORZAP will check the load\nmodule structure of the copy on DASD, and then find the entry point of\nthe in-storage copy.  INCORZAP then goes to the proper displacements\nin the in-storage copy, and does the VERifies and REPlacements in\nmachine storage.\n\n      With XA and later systems, INCORZAP will not always work.  This\nis because MVS/XA has some parts of storage which are \"page protected\",\nso that you cannot alter any of that storage.  Since earlier OS and MVS\nsystems did not have this facility, INCORZAP did not have any code to\nget around it.  The INCORZAP object code was disassembled by Bill\nGodfrey around 1980, and the assembler source was sent to the CBT Tape\naround then (by Jim Marshall).  A few years later, the original author\nof INCORZAP, Robert Budge, was looking through a CBT Tape and saw his\nown program, written in assembler source, instead of the original PL/S.\nBudge, who no longer worked for IBM, and who no longer had access to\nthe PL/S compiler, took the assembler source for his program, and fixed\nit to get around the XA (and ESA) page protection.  The result was\nXACORZAP, which can be found on File 421 of the CBT Tape.  Budge even\nwrote a new user manual for XACORZAP.\n\n      XACORZAP can be used to keep your system up in an emergency, if\nthere is a serious problem, which depends on a zap fix to correct.\nEven though an IPL would normally be recommended, the zap could be\ndirectly applied to the working code in storage.  Since XACORZAP is\nrun as a batch job, I'd recommend saving the exact JCL from all runs\nof this program in a special library, for reference in your shop.\nAlso, I would recommend making corresponding changes to the DASD copy\nwith SMP/E as soon as possible afterwards.  Anyway, in an emergency,\nthis technique might save your system.  XACORZAP page-fixes all the\nin-storage code that it alters, so the change will not disappear with\na page-out and re-load from PLPA.  Of course, XACORZAP has to be run\nfrom an APF authorized library.\n\n      LOADMLPA and SVCUPDTE are two programs that are available on\nFile 183 of the CBT Tape.  That file is from Gilbert Saint-flour.\nThese programs are modernizations of the old MODREP program (still on\nthe CBT Tape) that worked for MVS/370 and older systems.  The idea is\nto replace the working copy of an LPA module (in the case of LOADMLPA)\nor an SVC (in the case of SVCUPDTE) from a fresh version on DASD.  The\nprinciple involved is the following:  Some common storage, in the\nproper subpool, is obtained by these programs.  Then, the new copy of\nthe program is loaded into this storage.  Finally, the system pointers\nto these modules are altered to point to the new code, instead of the\nold code.  In the case of LOADMLPA, it doesn't quite work that way,\nbut after the common storage is obtained and loaded with the new\nprogram, LOADMLPA adds an entry (a CDE) to the Active LPA queue, which\noverrides the LPDE (Link Pack Directory Entry) in the PLPA Directory.\nIn the case of SVCUPDTE, the SVC Table pointer to the module entry\npoint is altered.  In either case, the new copy of the program starts\nworking with every new invocation.\n\n      What problems can occur with this procedure?  In the case of\nloading a new copy of an LPA module, there is sometimes a problem with\naliases.  Suppose an LPA module has several aliases, and when the main\nmodule is replaced, the alias may not be replaced.  LOADMLPA correctly\nprocesses just one alias.  That's it.  With most other of these types\nof programs, each alias name has to be re-loaded separately from the\nnew copy, in order for that alias name to be used.  IBM's new LPA\nloading scheme (in OS/390 Release 4) also has that drawback.  However,\nOMEGAMON (from Candle Corporation), which is a vendor product, has a\nsimilar LPA and SVC loading facility called LPAM, which substitutes a\nnew copy of an LPA or SVC module, and which also loads all the alias\nnames at once.  With OMEGAMON's LPAM command, you don't have to worry\nabout reloading all the alias names individually.\n\n      There is another possible drawback to this procedure, which\ndoes not occur often.  Sometimes, an LPA module, as it is being\ninitialized, checks to see if it has been loaded into the PLPA region\nof storage.  The common storage which a program like LOADMLPA\nobtains, is out of this storage range, and the module's operation\nwill fail when it detects this condition.  Most LPA modules don't\nexecute such storage range determinations, so there's no problem.\nYou just have to be aware that rarely, this problem might happen.\nOccasionally an SVC might do this also.  Statically loaded SVC's are\nusually put into SYS1.LPALIB or an LPALIST library.  Modern,\ndynamically-loaded SVC's are usually not, and therefore will not\ncontain such coding.  Coding to determine whether the module is loaded\ninto the PLPA region of storage, is generally done as a security\nmeasure, to stop someone from dynamically replacing an existing SVC.\n\n      We'll conclude with a discussion of another program that can\nsometimes help to keep your system running.  This is the Fullscreen ZAP\nprogram, from File 134 of the CBT Tape, as enhanced by Greg Price.\nFullscreen ZAP is a program which allows you to look at a dataset on\nDASD, and change anything.  If your security program is in place\nproperly, the security may allow looking, but no changing of data.\nFullscreen ZAP contains an enhancement which is invoked with the FULLVOL\nkeyword, that allows you to look at the entire disk pack, instead of\njust at the one individual dataset.  When you invoke Fullscreen ZAP with\nthe FULLVOL keyword, the program points you initially to Track 0, Record\n1 of the Disk Volume that the dataset is on.  This allows you to easily\n\"clip\" the pack, or change its volume id, while the pack is still\nonline.  IBM's program for this, ICKDSF, requires that the pack be\noffline while the \"clipping\" is taking place.  Sometimes, you can't get\nthe pack offline, and you still need to clip it.\n\n      With Fullscreen ZAP, you can invoke the program by pretending to\nzap dataset 'FORMAT4.DSCB', or the VTOC, pointing to VOL(volser), and\nusing the keyword FULLVOL in addition.  You then get to Track 0, Record\n1, of the pack you want to clip.  The Disk Id record is Record 3, so\nyou invoke ZAP's \"R\" command twice, to advance to the third record of\ntrack 0.  The volume id starts at +8 from there, for six bytes, so you\ncan then alter it to another name.  When you later bring the pack\noffline and then online, it will come online with the new volser name.\nOn older systems (XA and below), after you bring it online again, you\nhave to issue a MOUNT operator command, mentioning the new volser name.\nThis technique adds a lot of flexibility, in situations when ICKDSF\nwill not work properly, or can't be used for some reason.\n\n      Fullscreen ZAP is a program that every \"system doctor\" ought to\nbe familiar with, because it easily allows DASD manipulations that are\nmuch harder, using conventional IBM means.  Also, it works on many\nof the \"system\" parts of a DASD volume, and on deleted data, which are\nnot easy to reach by other means.  Fullscreen ZAP has a string search\ncapability, through its FIND keyword, that will save you a lot of work\nif something needs to be found and fixed on a disk volume.\n\n      I hope that this month's discussion will expand your mind and\nhelp you to deal with a greater range of emergency situations.  I\nreally hope you won't have too much occasion to use these techniques,\nbut they're definitely life-savers when you do need them.  Good luck.\nSee you next month.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9712DE": {"ttr": 17412, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x971\\x8f\\x01\\x00)\\x9f\\x11G\\x00\\xe0\\x00\\xe0\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1997-11-14T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 224, "newlines": 224, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         December 1997\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.\n\n\nREMEMBERING TSSO\n\n      Systems programming professionals have long been known for\ncreating clever tools and programs.  Historically, this was encouraged\nby our environment, as manufactured and developed by IBM.  MVS has\nalways been an extremely robust operating system, with many parts and\nfacilities.  However, IBM seems to concentrate its programming efforts\nmostly on developing the system facilities themselves, leaving the\nutilities and fine touches mostly to others, and to later development.\n\n      I'll explain.  When IBM would release a level of the operating\nsystem, they would ship some raw tools for handling the system parts\nalong with it.  For example, to change an arbitrary disk file, IBM\ngave us the AMASPZAP (superzap) program, which works.  To create a\ntext file, IBM (in the past) shipped the EDIT TSO command, and later,\nthey created the easier-to-use SPF and ISPF packages.  No one of us\ncan argue that AMASPZAP, EDIT or the ISPF editor cannot do its basic\njob.  However, most of us, who are familiar with some of the non-IBM\npackages, will insist that the pure IBM-supplied tools do not provide\nthe best ways of doing the job.  IBM, it seems, concentrates its best\nefforts in providing the operating system and foundation structures.\nThe more specialized and user-friendly tools and utilities for\nmanipulating these structures are usually left for others to develop.\n\n      By saying this, I don't mean to slight the enormous recent\nefforts of some of the IBM programming groups, notably the ISPF\ndevelopment group, and others, in improving their tools to make our\nlives easier.  I just mean to point out the historical directions in\nour field.  IBM usually would concentrate on developing a robust\nsystem first, and they'd usually try to improve the utilities later,\nor leave their improvement to others.\n\n      My real point is, that anyone who is familiar with the free\nUCLA Fullscreen ZAP TSO command, as improved by Greg Price, will never\nwant to use AMASPZAP to change a disk file, except in certain cases,\nfor example, when TSO is down.  Fullscreen ZAP is much easier to use:\nYou see what you are doing on a full TSO screen.  There is a FIND\nsubcommand to locate data that needs changing.  There are all kinds of\n\"helpers\" such as AND, OR, XOR, and setting an entire record to a\ngiven value.  And you can always see the raw structure of the data\n(block size), and where the data is, on which cylinder and which\ntrack.  You can easily find deleted disk data, and even change that.\nAMASPZAP, although quite capable, is far harder and more unfriendly\nto use, as everyone knows.\n\n      Another thing to point out, is that IBM's later improvements\noften come because of suggestions from user groups, such as SHARE and\nGUIDE.  The people who go to SHARE and GUIDE often get the ideas to\ntell IBM, from the user-developed tools and utilities which have\nappeared on the CBT MVS Utilities Tape, and in other sources of free\ncode.  User-developed code is probably the greatest source of IBM\ndirection, for improvements to their utilities.  That also includes\nIBM internally developed user-written code, which IBM programmers\nwrite for their own use, and not for general release.\n\n      This takes us to our current topic, which covers several\nfields.  We are going to talk about a product called TSSO, which can\ndo several different things, depending on which version you are\nusing.  IBM has partially caught up with, or surpassed, some of TSSO's\nfunctionality.  But IBM, to my knowledge, has not even addressed\nTSSO's original function.  That's why I feel it's proper to talk about\nTSSO here.\n\n\nWHAT IS TSSO?\n\n      TSSO, short for Time Sharing Subsystem Option, is a package of\nprograms, several versions of which appear on the CBT MVS Utilities\nTape.  The primary function of TSSO is to allow the execution of TSO\ncommands at an MVS Operator console, through the creation of a\nTSO-like environment that is driven from console commands, and creates\nresponses as console messages.  The later versions of TSSO have other\nimportant functions in addition to this.  TSSO is also an MVS\nsubsystem, which can either operate under JES2 or JES3, or without\nJES.  TSSO operating without JES, is a powerful system recovery\ntool, because one can do dataset renames, string scans and replaces,\nand IEBCOPY executions, without JES2 (or JES3) being up.\n\n      As I've said many times in previous columns, the CBT Tape is an\nindependently produced huge collection of free System Programmer\ngoodies, that can be ordered through the NaSPA office.  All materials\non the CBT Tape can be freely copied and used by anyone, although a\nfew of them are \"owned\" and have copyright notices printed in them.\nThe original version of TSSO, written by Bill Godfrey, is on File 306\nof the CBT Tape.  Bill Godfrey's TSSO contains only the basic TSSO\nfunction of allowing TSO commands to be executed at an operator\nconsole.\n\n      TSSO takes the TSO terminal environment, and establishes an\nequivalent environment at the operator's console.  In other words,\nwith TSSO, the console operator has access to TSO commands and\nCLISTs.  Of course, there has to be one significant limitation.  TSO\nis a full screen environment.  That being the case, there are two\nalternatives in the way messages can be sent to the screen of the TSO\nuser.  Messages can be sent to the screen either one line at a time,\nor else they can be sent in one burst, filling the screen all at once.\nThe second way is called a full screen TPUT.  The operator console is\na line-mode environment, with console messages that come, one line at\na time.  One limitation of TSSO is now clear:  Any TSO commands which\nput out terminal output one line at a time, are OK.  TSO commands\nwhich issue a full screen TPUT, filling the screen all at once, are\nnot OK.  So you have to be intelligent under TSSO, deciding which TSO\ncommands you can issue at the console.\n\n      There is one further fact to note.  TSO has two methods of\nissuing line output to a screen.  One of these is via the TPUT TGET\ninterface, and the other is by the PUTLINE, GETLINE, PUTGET interface.\nTPUT is easier to code in a program, but the output cannot be sent\nto print under TSO-in-batch (see my October 1997 column).  PUTLINE\nis quite difficult to initially set up in a program, but the PUTLINE\nterminal output can be sent to print in a TSO-in-batch job.  This\nsame situation occurs in the TSSO console environment.  Messages\nfor a TSO user that were written using PUTLINE, appear at the console\nas replies to a command.  Messages written using TPUT, do not appear.\nHowever, this does not mean that a TSO command which uses TPUT\nmessaging, is ineffective.  It may still do its job.  For example,\nIBM's RENAME TSO command does not use PUTLINE replies.  However,\nunder TSSO, the RENAME command will definitely do its job, to rename a\ndataset or a pds member.\n\n      TSSO has one additional advantage--it is also an MVS subsystem.\nAs such, TSSO may be started using SUB=MSTR, and in that case, it will\ncome up without JES.  The TSO commands can then be executed without\nJES2 (or JES3) being up.  TSSO thus becomes a system recovery tool,\nof great usefulness.\n\n      TSSO can also be brought up under JES as well, and you can\nSTART TSSO,SUB=JES2 or JES3.  If TSSO is brought up under JES, then\nthe TSO SUBMIT and OUTPUT commands will work.  If TSSO is started\nwith SUB=MSTR, these commands, which need JES, will not work, but\nall the other line-mode TSO commands which don't need JES, will work\nquite well.  I have used TSSO together with the PDS command processor\n(CBT Tape File 182 or 295) which invokes IEBCOPY using its COPY\nsubcommand, and have copied entire datasets and members when JES2\nwas down.  TSSO, operating without JES2, can save your shop in a\nrough situation, by allowing you to correct errors in your system\ninitialization datasets.  Through the PDS command, you can even add\nmore directory blocks to the SYS1.PARMLIB or SYS1.PROCLIB datasets,\nwhen JES is down.  A sample PDS subcommand to do this would be:\nFIXPDS EXPANDDIR(nn), where nn is the number of directory blocks\nyou want to add, and PDS, through TSSO, is pointed to SYS1.PARMLIB\nor SYS1.PROCLIB.\n\n\nTSSO AS A TOOL FOR AUTOMATED OPERATIONS\n\n      Back in 1985 and 1986, Marc Schare at Bellcore, working with\na few other people there, extended the capabilies of TSSO into the\nrealm of what we now call Automated Operations.  Since TSSO creates\na TSO-like environment, and CLISTs can run under TSO, Marc's idea\nwas to use TSO CLISTs as a programming tool to respond and reply\nintelligently to console events, automatically.\n\n      Before explaining the automated operations aspects of TSSO,\nI have to add a little history of the product.\n\n      Bellcore's version of TSSO is on File 401 of the CBT Tape, and\nis called TSSO Version 4.3.  TSSO Version 4.3 carries a Bellcore\ncopyright notice, but permission was granted by them, for anyone to\nuse the package as public domain non-supported software.\nSubsequently, Bellcore came out with a vendor version of TSSO which\nthey called TSSO Version 4.4.  They removed their \"pay TSSO\" from\nmarketing, a year or two later.  What remained for us, was the Version\n4.3, which everyone could use for free.  Dave Cartwright came out with\nsome free enhancements to TSSO 4.3 a few years ago, and these were\nplaced on CBT Tape File 402, without being merged with File 401.  Guy\nAlbertelli merged Cartwright's improvements with TSSO 4.3, and these\nwere purposely kept separate on the CBT Tape, being placed in File\n403.  File 403, until recently, was the most advanced free version of\nTSSO.  Recently, an anonymous donor upgraded the File 403 TSSO to run\non OS/390.  This was placed on File 404, in version 415 of the CBT\nTape (not on the NaSPA cd-rom).\n\n      With that done, let me explain how TSSO does console automation.\nEach console action and message reply is coded as an assembler macro,\nwhich gets assembled and linkedited into an AOF (Automated Operator\nFacility) load module.  In TSSO terms, an AOF load module is called an\nAOF table.  You can have many of these AOF tables, each containing a\ndifferent collection of console actions.  Only one AOF table is active\nat any one time.  A single TSSO console command will activate or\ndeactivate a given AOF table.  This takes only a second or two.  If you\nhave to invent a new console action quickly, and all of your assembly\nsource and JCL is in place, it only takes about two minutes to\nassemble, linkedit, and run the TSSO console command to activate your\nnew AOF table which includes the new action.\n\n      As part of the working mechanism of AOF, TSSO supplies special\nTSO commands which perform specific functions.  Among these are the\ncommands:  OSCMD (to issue an MVS command and get a reply), OSASK\n(to ask the operator a question and get a reply), OSWAIT (to wait a\nspecific amount of time), OSWTO (send a message to the operator),\nREPLY (reply to a message that has a message id), MULT (issue multiple\ncommands on one line), CACHE (to control a cache controller), CPCMD\n(to issue a CP command if you're under VM, and get the reply in MVS),\nand others.  These commands can either be used directly in a CLIST,\nor their execution is part of the action initiated through the AOF\ntable entries.\n\n      When all this is taken together, you see that TSSO actually\nsupplies all the primitives to perform extensive automation of the\noperator console, and indeed, TSSO was one of the first console\nautomation packages to come out.  TSSO has the advantages that it\nis still available, and you can even use TSSO, while some other\nconsole automation package is also in place.  I don't think that most\nof the other automation packages are TSO-like.  If your shop has\nanother automation package, TSSO can still be used to enter TSO\ncommands at the console.\n\n      Anyhow, I hope this month's discussion will stimulate you to\ntake another look at TSSO, to use at your shop.  The time so spent,\nwill pay you back.  Good luck.  See you next month.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9801JA": {"ttr": 17417, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x973_\\x01\\x00)\\x9f\\x11G\\x01\\x8a\\x01\\x8a\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1997-12-01T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 394, "newlines": 394, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          January 1998\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.\n\n\nLOOKING AT VIRTUAL STORAGE\n\n      Many of us would write much more code if we could only see what\nwe were writing about.  I still remember when I was an application\nprogrammer.  If I ever had to write a program to manipulate a file, I\nalways had to get a sample production file, and copy it as a test file.\nThen I'd look at it very carefully before attempting to write my code.\nYou have to see the data you're programming about.  I also remember\nmuch later, as a systems programmer, when I was enhancing the TAPEMAP\nprogram (from File 299 of the CBT MVS Tape).  TAPEMAP is very careful\nto \"feel\" the data at the beginning of each tape file, in order to\nclassify it as IEBCOPY format, IEBUPDTE, SMPPTFIN, etc.  Therefore, I\nneeded the TAPESCAN program (from File 102 of the CBT tape) or the\nDITTO tape functions, to give me a byte-by-byte detailed description\nof all the tape files to be studied, in hex.  I had to look, in order\nto be able to program.\n\n      Now here's the 64 dollar question:  \"When you're a systems\nprogrammer writing code that accesses system control blocks in virtual\nstorage, how can you get a good look at the data you're writing\nabout?\"\n\n      Remember that you have to look at actual virtual storage which is\nrunning in your address space, or in another address space, and it\nhelps, if you can follow control block chains.  There are a few vendor\ntools to do this, such as the XDC Debugger from Cole Software, and\nthere's TSO TEST, but there's also a free tool that can be had and\nused, by anybody.  This is the extremely clever LOOK program from File\n264 of the CBT MVS Utilities Tape.  LOOK was enhanced by Guy Albertelli\nfrom the original program, which was once part of a free software\nproduct called DCMS.  This LOOK program or any similar product, is an\nabsolute must to use, if you're writing system level code, and you need\nto see the data in detail.\n\n      The CBT MVS Utilities Tape, if you don't already know, is an\nindependently produced tape which is distributed by several sources,\nincluding NaSPA.  The tape may be freely copied, and it is of immense\nvalue to MVS Systems Programmers.  When you need to do a job, and you\ndon't know how to do it, the CBT Tape is one of the first places to\nsearch, to find out if someone else has done a similar job already.\nMost of the software on the CBT Tape is in source form, and you can\nstudy it and modify it to your heart's content.  So you can get your\njob done, and you can learn to code in assembler or PL/I, or whatever\nlanguage the software is written in, better than you could before.\n\n      Now we'll begin to see how the LOOK program can show us\nin-storage data, and format it automatically as a system control block.\nThen we'll navigate through storage, from control block to control\nblock, from pointer to pointer, and from there to the data.\n\n      My friend and teacher Jeff Broido told me early in my training,\nthat whenever he wrote system code to access control blocks, he would\nalways see what he was doing by using the LOOK program.\n\n\nWHAT KIND OF PROGRAM IS \"LOOK\"?\n\n      LOOK is a TSO command, which is designed to run interactively,\nin full screen mode, under TSO.  LOOK will show you chunks of virtual\nstorage in your own address space, in HEX and EBCDIC.  This gives you\naccess to common storage as well.  If LOOK is running authorized, LOOK\nis capable of showing similar private storage in any other address\nspace.  It does this by issuing an SRB to go cross memory to retrieve\nthe block of storage from the other address space.  A user of LOOK goes\nfrom one full screen of data to another.  Two pfkeys enable the user to\ngo back to previous screens, or to go forward.  From any screen of data,\nyou can explore new storage as you like.  Once you learn the subcommands\nof LOOK, you'll come to appreciate its great flexibility.\n\n      Today we'll see how LOOK works, by actually doing something.  A\nsimple program I once wrote, a TSO command to display your own userid,\nfinds the userid by following pointers in control blocks, starting from\nthe CVT (Commuication Vector Table), which is the \"backbone\" of pointers\nto most locations on an MVS or OS/390 system.  Figure 1 shows the actual\nsimple code, and Figures 2 through 6 show LOOK screens which illustrate\nthe storage at each control block location, as we follow the chain to\nthe location of the PSCB, and the data we want.  Using LOOK, you can see\nwhat you're programming.  You're not working in the dark.\n\n      LOOK has quite a few useful commands.  You can enter a virtual\naddress, and LOOK will take you there, if the address is accessible.\nLOOK always has a current address pointer.  Its initial value is\n00000000, or low storage.  This is formatted as PSA, or Prefixed Save\nArea.  Indirect addressing is done with an I or a J.  I, which is a\ncarryover from the 24-bit only days, does indirect addressing in 24-bit\nmode.  J does indirect addressing in 31-bit mode.  Indirect addressing\nmeans the following:  If a fullword in virtual storage contains an\naddress of somewhere else in virtual storage, then a J command, on the\ncurrent fullword, will take you to the address that's in that fullword.\nThis corresponds to a LOAD instruction in assembler language.  The J\ninstruction therefore helps us follow control block chains.  The code\nin the assembler program of Figure 1, has a sequence of five LOAD\ninstructions.  The corresponding commands to LOOK, illustrated by\nFigures 2 thru 6, are a sequence of five J instructions.\n\n      Figure 7 shows the LOOK help screen.  LOOK doesn't have an\nenormous number of commands, but what it does have, allows for great\nflexibility to track locations in virtual machine storage.\n\n      One other noteworthy aspect of LOOK, is its ability to recognize\nand format system control blocks, and to run from one control block to\nanother, through indirect LINKs.  LOOK contains very clever code which\nallows you to format any control block fields, according to their macro\ndefinitions.  In other words, LOOK can format fields in the CVT through\nan assembly of the CVT macro.  The TCB can be formatted by invoking\nan assembly of the IKJTCB macro.  The ASCB is formatted by assembling\nthe IHAASCB macro, and so forth.  By coding a few lines in the CBMACS\nsource member, any control block that is described by a mapping macro,\ncan be formatted to the LOOK program.\n\n      If a control block is formatted on a LOOK screen, you can get to\nany address in a formatted field, by using a LINK or L command.  For\nexample, look at Figure 2, which is a formatted mapping of the CVT.  If\nyou want to display the location of the TCBP field from the CVT, you\ncan enter the command LTCBP (or Link to TCBP), and you'll display\nstorage starting at the location specified in the address, which is\n00000218.  So, starting from the CVT, you can get to the TCBP field by\neither entering J+0, or LTCBP, or 00000218 as commands.  They will all\nyield the same result.\n\n      Space is short this month, because of all the illustrations, but\nsince a picture is worth a thousand words, there should be a lot of\ncontent in what we've said today.  Whether you're writing code, or\nchecking up on how your system is working, or diagnosing a system\nproblem, or simply exploring, it pays to be able to see the storage\nthat's in the system.  Good luck, and good LOOKing.  See you next month.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   This is a simple TSO command called MYID, which finds\n            the userid of the invoker, and displays it on the tube.\n            This command gets the userid from the PSCBUSER field\n            of the TSO Protected Step Control Block (PSCB).\n            This field is obtained by running a control block chain\n            starting from the CVT, as illustrated by the code.\n            Then we're going to use the LOOK program to actually\n            see the storage at each stage.\n\n\n*      M Y I D   P R O G R A M    -    A   T S O   C O M M A N D\n*\n*      TSO COMMAND PROCESSOR TO DISPLAY THE USERID OF THE INVOKER.\n*\n*     ------  REGISTER EQUATES ELIMINATED FOR BREVITY  ------------\n*\nMYID     CSECT\n         STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS R14 THRU R12\n         LR    R12,R15             LOAD ENTRY POINT INTO BASE REGISTER\n         USING MYID,R12            TELL THE ASSEMBLER, R12 IS THE BASE\n         LR    R15,R13             SAVE CALLER'S SAVEAREA ADDRESS\n         LA    R13,SAVE            POINT R13 TO OUR SAVEAREA ADDRESS\n         ST    R15,SAVE+4          STORE HIS SAVEAREA INTO MINE + 4\n         ST    R13,8(,R15)         STORE MINE INTO HIS SAVEAREA + 8\nRUNCHAIN L     R3,16               POINT TO CVT. ADDR IS IN LOW STORAGE\n         L     R3,0(,R3)           POINT TO TCB/ASCB WORDS, \"0\" OFF CVT\n         L     R3,4(,R3)           POINT TO TCB, \"4\" OFF TCB/ASCB WORDS\n         L     R3,X'B4'(,R3)       POINT TO JSCB. X'B4' OFF CURRENT TCB\n         L     R3,X'108'(,R3)      POINT TO PSCB. X'108' OFF THE JSCB\n         MVC   MSGLINE+13(7),0(R3)   MOVE USERID IN FROM 0 OFF THE PSCB\n         TPUT  MSGLINE,L'MSGLINE   DISPLAY THE WHOLE MESSAGE ON THE TUBE\nRETURN   DS    0H\n         L     R13,SAVE+4          RELOAD CALLER'S SAVEAREA POINTER\n         LM    R14,R12,12(R13)     RELOAD THE CALLER'S REGISTERS\n         BR    R14                 RETURN TO CALLER\nSAVE     DC    18F'0'              DEFINE MY SAVEAREA - 18 FULLWORDS\nMSGLINE  DC    CL20'MY USERID IS        '      DEFINE LINE FOR MESSAGE\n         END\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.   This is the LOOK screen, with the first page of the CVT,\n            formatted out.  You get to the CVT from the pointer at\n            virtual location X'10' or Decimal 16.  In LOOK parlance,\n            the command is J10.  You see that LOOK uses the hex value.\n\n\nLOOK COMMAND - DISPLAY VIRTUAL MEMORY      DISPLAY ASID= 0029\nENTER CMD -\nLAST CMD  - J10\n                          00FDA068  CVT\n TCBP    00000218  0EF00   00FE5E90  LINK    00FD511C  AUSCB   00FD7D48\n BUF     00000000  XAPG    00FF80C4  0VL00   00FF2ECE  PCNVT   00FFC114\n PRLTV   00FFBF44  LLCB    0155ECD8  LLTRM   81162940  XTLER   00FEAEF8\n SYSAD   00F4A080  BTERM   00FF5030  DATE    0097334F  MSLT    00FD5908\n ZDTAB   00F41000  XITP    00FFA5E8  0EF01   00FE60B8  VSS     0000\n VPSM    0000  SVDCB   00FD5124  TPC     00FD3308  RS05C   0000  ICPID   0000\n RS060   40C3E5E3  CUCB    00FD5AA0  QTE00   00FDE90A  QTD00   00FDE92A\n STB     00F4C580  DCB     9B  DCBA    FD7E18  SV76M   00000000\n IXAVL   00FE1400  NUCB    00000000  FBOSV   8150A278  0DS     00FEB9B8\n ECVT    0155EE18  DAIRX   82F11000  MSER    00FD5908  0PT01   00FEEA18\n TVT     00CA6260  SV76C   00000000  MZ00    7F  1EF00   00000000\n QOCR    00000000  QMWR    00FD7D10  SNCTR   0000  OPTA    A3  OPTB    20\n QCDSR   00FE66E0  QLPAQ   00FD5158  ENFCT   00FDA650  SMCA    80FC2B20\n ABEND   00FD3210  USER    00000000  MDLDS   00000000  TSCE    00000000\n PATCH   00FD4978  RMS     0142E190  SPDME   01F93B6C  0SCR1   00FFB598\n GTFST   00  GTFA    FCEC20  TCMFG   00  AQAVB   000000  RS0F4   00000000\n\n\n1= HELP      2=           3= END        4=           5= REPEAT  6=\n7= BACKWARD  8= FORWARD   9= HIST BWD  10= HIST FWD 11=        12=\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 3.   This is storage (unformatted) at the location of the\n            TCB pointers for your address space.  If LOOK recognizes\n            a control block and formats it, you can turn off the\n            formatting with the command:  ONULL.  If you want to\n            purposely format some storage as if it were a CVT, you\n            would use the command:  OCVT .  You get the idea.\n\n\nLOOK COMMAND - DISPLAY VIRTUAL MEMORY      DISPLAY ASID= 0029\nENTER CMD -\nLAST CMD  - J+0\n\n00000218   >009B81F8  009B81F8  00FD3600  00FB6D00 *>...8...8......_.*\n00000228    00000000  00000000  00000000  00000000  *................*\n00000238    00000000  00000078  00000000  00000000  *................*\n00000248    00000000  7F748950  040C0000  00DF1DF2  *....\"..&.......2*\n00000258    040C0000  8003986C  AD000950  AD000950  *.......%...&...&*\n00000268    AD040950  AD000950  AD040950  00000000  *...&...&...&....*\n00000278    00000704  00000000  00FD13E8  00000000  *...........Y....*\n00000288    00FD13F0  00000000  00000000  00000000  *...0............*\n00000298    00000000  00000000  00000000  00000000  *................*\n000002A8    00FD13F8  00000000  00FD1430  00000000  *...8............*\n000002B8    00000000  00000000  00000000  00FD1440  *............... *\n000002C8    00000000  00000000  00FD1438  00FD1448  *................*\n000002D8    00FD1450  00000000  00000000  00000000  *...&............*\n000002E8    00000000  00000000  00000000  00000040  *............... *\n000002F8    00000000  00FEBAD0  00000000  00000000  *................*\n00000308    5FB1EE40  00040000  00000000  00000000  *\u00ac.. ............*\n\n\n1= HELP      2=           3= END        4=           5= REPEAT  6=\n7= BACKWARD  8= FORWARD   9= HIST BWD  10= HIST FWD 11=        12=\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 4.   Here you see a storage description of the first TCB,\n            formatted as a TCB by the LOOK program.\n\n\nLOOK COMMAND - DISPLAY VIRTUAL MEMORY      DISPLAY ASID= 0029\nENTER CMD -\nLAST CMD  - J+4\n                          009B81F8  TCB\n FRS0    0000000000000000  FRS2    0000000000000000  FRS4    0000000000000000\n FRS6    0000000000000000  RBP     009B8110  PMASK   00  PIEA    000000\n DEB     00000000  TIO     009C8000  CMPF    94  CMPC    0C4000  ABF     40\n TRNB    000000  MSSB    7547A8  PKF     80  FLGS1   00  FLGS2   00\n FLGS3   00  FLGS4   00  FLGS5   00  LMP     FF  DSP     FE  LLS     00000000\n JLB     0000BF14  PURGE   00  JPQB    000000  GRS0    00E23A78\n GRS1    00000009  GRS2    00000318  GRS3    00000003  GRS4    0007E9C0\n GRS5    00000000  GRS6    0007F100  GRS7    00023E90  GRS8    00081DE0\n GRS9    05A5F7D8  GRS10   0007E518  GRS11   85A5E7D8  GRS12   846C3D18\n GRS13   0007E518  GRS14   85A5EAA4  GRS15   00000000  FSAB    07DFB0\n TCB     00000000  TME     00000000  JSTCA   9FD178  NTC     00000000\n OTC     009D9298  LTC     00000000  IQE     00000000  ECB     0007312C\n TSFLG   00  STPCT   00  TSLP    00  TSDP    00  RD      7FF16EE4\n AE      00000000  NSTAE   00  STABB   9FF410  TCTGF   80  TCTB    9D9D58\n USER    00000000  NDSP0   00  NDSP1   00  NDSP2   00  NDSP3   00\n MDIDS   00000000  RECDE   00  JSCBB   9FD234  SSAT    00FD35B8\n\n\n1= HELP      2=           3= END        4=           5= REPEAT  6=\n7= BACKWARD  8= FORWARD   9= HIST BWD  10= HIST FWD 11=        12=\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 5.   This is the unformatted storage pointed to by the\n            address at X'B4' off the beginning of the previously\n            shown TCB.  This is the JSCB or Job Step Control Block.\n            From the formatted TCB display shown previously, we can\n            also get here with a label Link command:  LJSCBB.\n\n\nLOOK COMMAND - DISPLAY VIRTUAL MEMORY      DISPLAY ASID= 0029\nENTER CMD -\nLAST CMD  - J+B4\n\n009FD234   >00000000  00000000  00000000  00000000 *>................*\n009FD244    00000000  009FD2D0  00000000  7FFFED60  *......K.....\"..-*\n009FD254    009FDE88  00000000  00000000  00000000  *................*\n009FD264    00000000  00000040  7FFFC02C  7FFDDEB0  *....... \"...\"...*\n009FD274    00000000  E3C3C240  00000000  00000000  *....TCB ........*\n009FD284    7FFDD370  0000FFFF  00048000  00000000  *\".L.............*\n009FD294    00064E78  7FFD6DC0  00000000  7FF16EF4  *..+.\"._.....\"1.4*\n009FD2A4    7FFDD7F0  00000000  00000000  7FFF5138  *\".P0........\"...*\n009FD2B4    00000000  5A8DF658  00006E88  00000003  *....!.6.........*\n009FD2C4    00000000  00000000  00000000  00000000  *................*\n009FD2D4    00000000  00000000  0000000C  00000000  *................*\n009FD2E4    00000000  00000000  00000000  00000000  *................*\n009FD2F4    00000000  00000000  00000000  00000000  *................*\n009FD304    009FDE88  00000000  009D9528  00000000  *................*\n009FD314    00000000  01000000  00000000  00000000  *................*\n009FD324    00000000  009DE940  00000000  00000000  *......Z ........*\n\n\n1= HELP      2=           3= END        4=           5= REPEAT  6=\n7= BACKWARD  8= FORWARD   9= HIST BWD  10= HIST FWD 11=        12=\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 6.   The PSCB is X'108' off the previous location, which\n            is the JSCBPSCB field of the JSCB.  We could not get\n            to this location with a label Link command, because\n            the previous screen was not formatted as the JSCB\n            control block.  We are looking at the storage which is\n            pointed to by the address at that location.  Lo and\n            behold, the PSCB can be seen in storage.  The PSCBUSER\n            field of the PSCB is 7 bytes long, starting from the\n            beginning of the PSCB control block.  And it's got our\n            userid there.  In our program, we just have to move\n            these 7 bytes into the TPUT display to the terminal,\n            and we're done.  It pays to see what you are doing!\n\n\nLOOK COMMAND - DISPLAY VIRTUAL MEMORY      DISPLAY ASID= 0029\nENTER CMD -\nLAST CMD  - J+108\n\n00005F80   >E2C1C7D6  D3D6C207  E2E8E2C1  D3D3C4C1 *>SAGOLOB.SYSALLDA*\n00005F90    A2000000  AFA3EAB7  05B5FC00  00000000  *................*\n00005FA0    0000006F  00000000  00000000  00000000  *...?............*\n00005FB0    00006EC0  00006FC8  00380000  00000C00  *......?H........*\n00005FC0    00000000  00000000  00000000  00000004  *................*\n00005FD0    00000000  00000000  00000000  00000000  *................*\n00005FE0    00000000  00000000  00000000  00000000  *................*\n00005FF0    00005FF8  00000000  C9D2D1D3  D1F14040  *..\u00ac8....IKJLJ1  *\n00006000    00000000  00000000  00000000  00000000  *................*\n00006010    00000000  00000000  00000000  00000000  *................*\n00006020    00000000  00000000  00000000  00000000  *................*\n00006030    00000000  00000000  00000000  00000000  *................*\n00006040    00000000  00000000  00000000  00000000  *................*\n00006050    00000000  00000000  00000000  00000000  *................*\n00006060    00000000  00000000  00000000  00000000  *................*\n00006070    00000000  00000000  00000000  00000000  *................*\n\n\n1= HELP      2=           3= END        4=           5= REPEAT  6=\n7= BACKWARD  8= FORWARD   9= HIST BWD  10= HIST FWD 11=        12=\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 7.   HELP screen for the LOOK command.  This will remind the\n            user of LOOK what can be done.  There's really a lot\n            of flexibility, if you study this command set.\n\n\nLOOK COMMAND - DISPLAY VIRTUAL MEMORY      DISPLAY ASID= 0029\nENTER CMD -\nLAST CMD  - HELP\n\nLOOK is a real time core display and formatting program. It also has the\ncapability of displaying memory in any address space (if authorized).\n\nThe valid commands are:\nIexp  24 bit indirect                 | Jexp  31 bit indirect\n>     Forward                         | <     Backward\n=sym  Define current address as \"sym\" | ,sym  Redisplay core at \"sym\"\nM0/M1 Flip between top and center     | Lname Indirect thru control block field\nOcb   Format as \"cb\" control block    | R     Refresh displayed storage\n      \"cb\" may be NULL to show as hex |\n\nwhere 'exp' is of the form:\n    <+/->hhhh<+/-hhhh<+/-hhhh...>>\nand 'hhhh' is a 1 to 8 digit hex number.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9802FE": {"ttr": 17668, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x98\\x01O\\x01\\x00)\\x9f\\x11G\\x00\\xf7\\x00\\xf7\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1998-01-14T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 247, "newlines": 247, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         February 1998\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.  Sam can be reached at\nsbgolob@aol.com or sbgolob@attglobal.net.\n\n\nASSORTED UTILITIES - PART 1\n\n      In our field, there are several marks of a veteran.  The first\nis a general knowledge and conceptual picture of the different parts\nof the MVS (or OS/390) operating system.  Such knowledge usually takes\nyears to accumulate.  Second is an ability (acquired by experience) to\nquickly isolate the component that is causing a problem, and to know\nwhere to get help, or how to make an adjustment to fix the problem.\nThird, a veteran should know how to set up the MVS operating system\nfrom scratch, starting from the way IBM ships it.  Finally, the\nveteran is constantly gathering an ever-increasing arsenal of tools,\nalways learning how to use them better.  You don't measure a veteran's\nexperience in years, but rather in technical savvy.\n\n      Every MVS (or OS/390) installation is different, even though\nthey all have the operating system in common.  MVS shops are of\ndifferent sizes, and especially, different budgets.  It all depends\non what they are trying to accomplish from a business perspective.\nSome shops are what we'd call \"large\", which support huge businesses,\nand they buy a lot of vendor software and hardware products to satisfy\ntheir large needs.  Other shops can be very small--either medium-sized\nbusinesses or software development shops, with relatively low budgets.\nAnd there are the \"medium-sized\" shops in-between, supporting large\nbusinesses, who buy some vendor software to fit their needs, but they\naren't replete with a lot of \"system programmer fancy tools\", as the\nlarge shops may be.\n\n      This makes for differences in how the systems programmer, who\ntakes care of that installation's system, approaches the job.  In a\nlarge shop, the systems programming tasks are segmented, and divided\namong a considerable number of people.  It helps to have a few\nveterans there, who can cut through the occasional tough problems\nquickly, and generally guide the installation's progress in hardware\nand software.  The veterans can also bring the more junior personnel\nup to snuff, eventually making them veterans also.  A small shop is\nrun by one or two people possibly, and they have to be generalists.\nThe medium-sized shop, which is in-between, should always have at\nleast one veteran there, and if not, at least one systems programmer\nwho knows how to get access to lots of help.\n\n      Tool-wise, there are many differences between small and large\nshops.  Even with tiered pricing, the smaller and medium-sized shops\ncan only afford a limited number of vendor-supplied tools.  Thus, the\nsystems programmers there, have to \"make do with less\".  My\nrecommendation for this, which is being followed by more and more\npeople nowadays, is to learn how to use free software tools.\n\n      MVS systems programmers are fortunate to have access to many free\ntools and utilities, which are parts of huge software collections such\nas the CBT MVS Utilities Tape.  The CBT Tape, which is independently\nproduced, is distributed by several sources, including NaSPA.  Contents\nof the current version of the CBT Tape are now posted on the Internet,\nat location:  http://members.aol.com/cbttape .  A version of the CBT\nTape is also part of the NaSPA cd-rom, which has been updated\napproximately once a year.\n\n      The idea of the CBT Tape is that if one systems programmer solves\na problem, why should all the others have to re-invent the wheel?  Many\ninteresting software solutions to various problems can be found there.\nThe CBT Tape is literally an MVS systems programmer's encyclopedia.\nToday, we shall discuss one particular collection of assorted tools,\nwhich was put together by a clever man, John V. Hooper.  John's tools\ncan be found on File 019 of the CBT Tape, and I'm sure that at least one\nor more of John's dozen-or-so programs, can benefit any MVS shop.  This\ncollection was updated on Version 415 of the CBT Tape, and is running\non an OS/390 Version 1.2 system with JES2 at the appropriate level.\n\n\nWHAT'S IN THE COLLECTION\n\n      John Hooper's collection of programs covers various needs of his\nmedium-size shop.  From a glance at our descriptions, you'll quickly\nsee that a lot of key areas in the maintenance of an MVS environment\nare covered.\n\n      John has several programs which monitor the blocksize of datasets\nglobally, throughout the entire shop.  This has been done to improve I/O\nefficiency, and has helped to eliminate bottlenecks in the company's\nbatch window.  A second group of programs constitutes a general job\nperformance and throughput analysis package.  Other programs do dataset\nanalysis and monitor DASD volume contents, using the appropriate SMF\nrecords.  Of course, larger shops may accomplish this by buying SAS and\nBarry Merrill's SMF record analysis package, but John Hooper's place\ndoesn't have SAS.  Therefore, John wrote some assembler programs to\ncover this ground.  John has a console automation tool, which helps his\nshop to simplify system startup and shutdown, without using a formal\nautomations package.  These programs are all free, are publicly\navailable, and have been running on an OS/390 system.  Do they whet your\nappetite?  You can try them too.\n\n      There's more.  There's an operator command to simplify the\ncontrol of the 3990-3 Cache Subsystem, which normally requires IDCAMS\nsubcommands that are quite complicated.  There's a program to report\nPrivate Region size below the 16 meg line, right after IPL time, and\nto make sure it isn't below a critical threshold.  If the Private\nRegion is too small, an alarm is sounded, in the form of a\nnon-rollable message to the operator console, and you're not stuck in\nthe middle of a production day, with a job or CICS region that won't\nrun.  John has a general map of the main storage areas in an MVS\nsystem, and even though the large performance monitors also have such\na map, this one can also be run as a batch program to produce a\nhardcopy report.  Another of John's programs will track a load module\nin the link list or LPA libraries, displaying which library the\nprogram is found in, or where in storage (if LPA) the program is\nloaded.  This program also displays the beginning few bytes of each\nmodule it finds, so you can get an idea of which version it is.\nFinally, John can trace, through analyzing LISTCAT ALL outputs for all\ncatalogs, which DASD volume must contain which datasets.  This is\nuseful in an SMS environment where it's not clear on which exact\nvolume a dataset has been placed.  One can begin to recover, when a\nparticular DASD volume goes bad.  At least you know what datasets\nshould have been on it.\n\n      Some, or all of these tools, may help you.  Now I'll go into a\nbit more detail, so you can better judge for yourselves.  Please bear\nin mind that these descriptions are only a beginning.  John Hooper's\nutilities have much more depth than I can indicate here.\n\n\nHERE ARE THE UTILITIES\n\n      FLSMFDSN and BLKSCAN:  This combination of programs was designed\nto eliminate bad block sizes of datasets in the entire shop.  The\nFLSMFDSN program analyzes SMF type 14 and 15 records to cover non-VSAM\ndatasets, and type 64 records to cover VSAM datasets.  FLSMFDSN has a\nlarge collection of sort and selection parameters, making it extremely\nflexible.  FLSMFDSN can be used to flag all the datasets, in the entire\nshop, which have inefficient block sizes.  After these have been\npinpointed, the BLKSCAN program is used to scan all the production and\ntest JCL, showing the origin of the inefficient block sizes.  All bad\nJCL can be corrected, and those jobs will run more efficiently.\n\n      FLSMFJOB:  The FLSMFJOB program gets its information from SMF\ntype 30 job and step records, reporting on the resources used by a job\nstep or an entire job.  A tremendous variety of execution and sort\nparameters makes this program extremely useful in pinpointing jobs\nwhich are hogging CPU or I/O.  Once these jobs, or job steps, have been\nflagged, something can be done about the programming, to make them more\nefficient.  This program has made it possible to delay a processor\nupgrade in John's shop, saving a considerable amount of money.\n\n      COMMAND:  At the time this program was written, John's\ninstallation didn't have a formal automated operations package, but\nits operation is large enough (it's a big chain of supermarkets) so\nthat system IPL and system shutdown are nevertheless quite\ncomplicated.  Without the COMMAND program, complete IPL and system\nshutdown procedures might take close to half an hour apiece.  With\nthis program, each takes only a few minutes.  COMMAND accomplishes\nthis by not only allowing for automatic issuing of MVS and JES2\ncommands, but by including DELAY and message REPLY subcommands also,\nso that the proper components can come up (or down) in the proper\norder, at the proper time, and with console WTOR messages properly\nreplied to.  This capability allows any shop to recover from an\nemergency outage, with a very minimum of down time.  Business is\nsaved, and money is saved.\n\n      John told me that even with a console automation package,\nthe COMMAND program is useful for backups of an individual application.\nUsing the COMMAND program, a single procedure can be written, which can\nshut down the application, take the backup, and automatically restart\nthe application.  Auto ops packages aren't frequently used for that.\n\n      CHECKPVT:  The CHECKPVT program is designed to run immediately\nafter IPL, and to report the maximum private area available for started\ntasks, jobs, and TSO users.  After slight system maintenance, it is\npossible for CSA to be allocated on a different boundary, an entire meg\nlower, without you're even knowing it.  The private area can be cut by\nan entire meg of virtual storage, making some large jobs or CICS\nregions abend, when they are started later in the day.  This is not\nparticularly pleasant, and can necessitate an IPL for the backout of\nmaintenance in the middle of the day.  CHECKPVT will check the private\nregion size at IPL time, and will immediately write a non-rollable\nmessage to the operator's console if it is less than a pre-determined\nthreshold value.  The production disturbance will be nipped in the bud.\n\n      FLSMFCAT:  The FLSMFCAT program gets information from SMF records\nto show ICF catalog activity at the dataset level.  Sometimes, when a\ndataset is created or deleted, and the application fails, it is not\neasy to tell who created or deleted the dataset.  The SMF ICF catalog\ninformation is the best way to tell what happened.\n\n      FLSMFSRT:  The FLSMFSRT program flexibly produces reports from\nSYNCSORT SMF records.  This program allows John's installation to\nmonitor the larger sorts in production and test jobs.  Of course, the\nprogram is only useful if your shop uses SYNCSORT as its sorting\nutility product.\n\n      FLVOLLST:  The FLVOLLST program is designed to print a report\nlisting all of the datasets on a volume based upon information from\nthe system catalogs.  This list could be critical in case of a DASD\nfailure which destroys the VTOC on the volume.  With volume pooling\nnow available through the use of DFSMS and other program products,\nit is not always easy to determine the datasets which are on a\nspecific volume.\n\n      The input to this program must be the output from an IDCAMS\nLISTCAT command.  It is expected that an IDCAMS 'LISTCAT VOL\nCAT(user.catalog.name)' command will be executed for each catalog in\nthe system.  The contents of these reports can then be passed to this\nutility program to produce the report by volume and dataset name.\n\n      MODLOOK:  The MODLOOK program is designed to run as a TSO\ncommand, started task or a batch job to look up the selected module(s)\nin the system link list or link pack area.  If the module is in the\nlink list, the link list library name will be displayed.  If the\nmodule is in the link pack area, its address will be displayed along\nwith the name of the resident area in which it is located such as\nPLPA, FLPA, ECSA, etc.  The first part of each module is displayed\nalso, since it can contain date, time, or copyright information which\nmay be of interest.\n\n      With many libraries now in the system link list, it may not\nalways be apparent which dataset contains which program or even more\nimportantly, it may be difficult to determine which library contains a\nmodule if duplicate module names exist.\n\n      SMAP:  The SMAP program is designed to print the starting\naddress, ending address, and size of each of the main storage areas in\nthe MVS system.  This information can be displayed using most of the\npopular monitors currently available, but not everyone has one.  Also,\nthis program can run as a batch job producing a hardcopy report.\n\n      JES$LF:  The JES$LF program is a JES2 Exit 5 module, designed\nto process the $LF command when entered.  It will give detailed\ninformation at the output group level for jobs awaiting print.  This\nis, in effect, a detailed version of the $DF command.\n\n      In summary, you see that one person can come up with very\ninventive tools to help the shop, and if he is gracious enough to make\nthe tools generally available, we all can benefit.  The CBT Tape is an\nenormous collection of many such contributions.  I hope that the mention\nof these utilities will encourage you to look at them.  Good luck.\nWe'll have more of these tools to show you, next month.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9803MA": {"ttr": 17673, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x98\\x04_\\x01\\x00)\\x9f\\x11G\\x01\\x04\\x01\\x04\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1998-02-14T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 260, "newlines": 260, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          March 1998\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.  Sam can be reached at\nsbgolob@aol.com or sbgolob@attglobal.net.\n\n\nASSORTED UTILITIES - PART 2\n\n      Anyone who has been in the IBM mainframe Systems Programming\nfield for a long time, will have noticed some unmistakable trends\nthat are not very apparent to newer systems programmers.  First and\nforemost, is that great skill in assembler programming is apparently\n\"no longer required\".  This is not to say that skill in assembler\nprogramming is no longer valuable--there's nothing farther from the\ntruth than that.  An understanding of the inner workings of the\nsystem is worth it's weight in Platinum.  Rather, the situation\npresents itself to us in the form of a statement:  \"They don't grow\n'em nowadays like they used to!\"  In other words, newer systems\nprogrammers don't tend to be anywhere nearly as skilled in the\nnitty-gritty of assembler instructions and system control blocks, as\nthe old-timers were.\n\n      Having broken into the field a bit more recently, I asked my\nfriend Rick Fochtman why this was.  He told me that in the OS/360\ndays, in the late '60s and early '70s, there were few convenient exit\npoints and system facilities for getting performance information, or\nfor doing anything else you wanted.  These were also the days before\nPL/S coding.  The only way you could make the system do something it\ndidn't do, was to look into the system source code, or disassemble\nsystem object code, and code the modification yourself in assembler\nlanguage.  You literally had to have the same skills as the IBM code\ndevelopers.\n\n      Very often, in those times, the programmer didn't have access\nto the layout of the IBM control blocks.  In many cases, the control\nblock layouts were in the private macro libraries, and not everyone\ncould get to see them.  So a systems programmer making a modification\nto an IBM module, literally had to look in the module, figure out how\nthe control block got loaded or referenced, and deduce the layout\nwithout further help.  All the IBM coding was done in pure assembler\nlanguage then, and someone who coded a modification would acquire a\nvery large understanding of the workings of the original module(s),\nwithout outside help.  This was a \"very good school\" for learning.\nLater systems programmers, who didn't have the opportunity to go to\nthis \"school\", by-and-large didn't become as skilled as the \"older\"\npeople.\n\n      One step later, in my time, things were very different.  By then,\nIBM had provided some official \"exit points\", where you could put in\nuser code to modify parts of the system.  Also, large numbers of\npre-existing modifications to the system were, at that time, already\navailable, having been coded by the old-timers.  These could be merely\nre-fitted to the later versions of the operating system modules--they\ndidn't have to be researched and coded from scratch.  The MVS\noperating system was, by now, more mature.  A lot more frills and\ntools had already been added.  Large collections of user-written code,\nsuch as the CBT MVS Tape and other available sources of free code,\nwere now readily accessible to practitioners of the field.\nModification, as opposed to coding from scratch, became more the rule\nof the day.\n\n      This situation led to the newer systems programmers being less\nskilled in assembler programming than their earlier counterparts.\nThe \"school\" wasn't as good.  It's even worse nowadays, with the\n\"vendorization\" of a lot of system tools.  It might seem that today's\nsystems programmers don't have to code anything.  The vendors do it\nall for them.  There's hardly any \"school\" at all, at least for\ncoding's sake.  To that, I'll answer one statement:  We systems\nprogrammers each have to \"make our own school\".\n\n      We have help, if we know where to look for it.  One person,\nDave Alcock, who just submitted a 60000-line pds of his own code for\ninclusion into the CBT Tape, told me that he learned to program in\nassembler mostly from looking at other people's code on the CBT Tape.\nThe president of this organization, Scott Sherer, told me the exact\nsame thing.  And I myself can also say that I learned many of my\ncoding skills from looking at code on the CBT Tape.  We three are, of\ncourse, not the only ones.  Many of our contemporaries have learned\nenough to make substantial contributions to this field, just from\nstudying other people's earlier contributions.\n\n      Today, I'd like to collect a small sample of such code from\nvarious contributors to the CBT Tape.  Some of the things to be\nmentioned, are from the old-timers.  But many of them are from people\nlike you and me, who took it upon themselves to learn assembler coding\nskills by studying other people's clever creations.\n\n      By the way, the CBT MVS Utilities Tape is a huge independently\nproduced collection of system software tools, which was started in\n1975 by Arnold Casinghino, and which has been put through 417 versions\nsince then (Arnie did 321 of them).  There is also a CBT Overflow\nTape, that has much more software in addition.  These collections can\nbe freely duplicated, and can be obtained from various sources,\nincluding NaSPA.  If you already have a tape, you can produce copies\nof it for your system programmer friends.  There is a tape copying\nprogram called COPYMODS on File 229 of the CBT Tape, which allows you\nto make from 1 to 10 exact copies of a tape, end to end, in each\nrun.  A recent version of the CBT Tape is also a part of the NaSPA\ncd-rom disk, which can be obtained through the NaSPA office.\n\n\nAN EXAMPLE - SYS1.BRODCAST RESEARCH\n\n      Jim Marshall, who worked at various computer installations for\nthe U.S. Air Force, and who is now a civilian, has pioneered the\npopularization of user-written code among systems programmers.  Jim\nhad the opportunity of working with many genuine old-timers in this\nfield.  Even though Jim himself can be considered an old-timer like\nthe others, his contribution is far greater.  He took it upon himself\nto collect other people's software creations, and to send them to the\nCBT Tape, the SHARE MVS Tape (now part of the CBT Overflow Tape), and\nto other tape collections.  I got my own start by looking at Jim\nMarshall's software collections.  This brings us to the current topic.\n\n      At my previous site, we administered about 11 separate MVS\nsystems.  Two of the older ones displayed a \"SYS1.BRODCAST FULL\"\nmessage.  This was before we put in individual TSO userlog datasets,\nand I needed some tools to investigate.  I didn't want to risk doing\nan ACCOUNT SYNC, which would wipe out all of the messages--some of\nthem might be useful.  In a large service bureau, we couldn't afford\nto offend any users.  Starting from an updated program called BRODSCAN\non the CBT Tape (a copy is on File 234), that was sent by Jim\nMarshall, I was able to see which users had outstanding messages, but\nI wasn't able to display or delete the messages.  I then fired up some\ncode from Tim Vanderwall that was on File 141 of the CBT Tape, which\ndisplayed the messages for each user.  This was an improvement.  There\nstill remained the problem of deleting messages, so that space on the\nSYS1.BRODCAST dataset could be freed.  These messages belonged to\nusers who had left the installation, and I couldn't LOGON to their TSO\naccounts without their passwords, not being the RACF administrator.\n\n      Jim Marshall sent me a hint.  Jim told me that the LISTBC\nprogram from IBM, which displays and deletes mail messages to each\nuser when you LOGON to TSO, only finds out the userid by looking at\nthe PSCBUSER field in the PSCB control block.  My first try for\nrelieving the situation, was to zap core in my address space, alter\nmy PSCBUSER field to another id, run LISTBC to display and delete\nthe other user's messages, and zap core again to change the PSCBUSER\nfield back to my own id.  This worked, but of course, was awkward.\nThen I wrote an authorized TSO command to do the same thing.  So\nfar, so good.\n\n      Then, my boss got wind of the fact that my program dynamically\nalters a TSO user's id.  He didn't like the code for such a program to\nbe in an accessible place in the shop, so I had to rewrite the\nprogram.  Therefore, I had to learn more about the internals of the\nSYS1.BRODCAST dataset.  To make a long story short, I was able to\nwrite two other programs to display and delete someone else's BRODCAST\nmessages, using principles I learned from looking at the code in the\nBRODSCAN program, and from browsing the SYS1.BRODCAST dataset with the\nREVIEW program (from Bill Godfrey and Greg Price) that is on File 134\nof the CBT Tape.  I also wrote several programs to display, but not\ndelete, any user's messages.\n\n      Why use REVIEW, and not ISPF BROWSE to look at the SYS1.BRODCAST\ndataset?  It turns out that SYS1.BRODCAST is a keyed dataset with\nKEYLEN=1 and LRECL=129.  ISPF BROWSE uses QSAM, and cannot\ndifferentiate between the key and the data, so that it only shows the\nfirst 129 bytes, including the leading key, and it drops the last byte\nof the data.  REVIEW uses BSAM, and it shows all the key and data\nbytes.  You see why you need another tool?  It turns out that the last\nbyte in a SYS1.BRODCAST record is crucial to understanding the dataset\nstructure, because for a chained message record, the last 3 bytes\npoint to the location of the next record in the chain.  With ISPF\nBROWSE, you can't see the whole pointer.  How did I find this out in\nthe first place?  By looking at SYS1.BRODCAST with the UCLA Fullscreen\nZAP tool (also from File 134 of the CBT Tape).  Fullscreen ZAP showed\nthe whole physical record, and I saw that ISPF BROWSE was dropping the\nlast byte of it.  All these investigations resulted in a package of\nprograms that I wrote to handle SYS1.BRODCAST problems.  I resubmitted\nthem to the CBT Tape for everyone else's benefit, and they can be\nfound on File 247.  See how one contribution leads to another?\n\n\nSOME OTHER EXAMPLES\n\n      Another crucial contribution, which led to other contributions,\nis the dynamic allocation interface from Pat MacDonald of the\nUniversity of Manitoba.  Pat is an old-timer in the field, who has\nnow retired from the University.  Pat's contribution was to simplify\nprogramming for packages which do multiple dynamic allocations.\nDynamically allocating datasets in a program, using SVC 99, is not\nespecially difficult to code, but the setup is lengthy, and it would\nbe very helpful to simplify the process.  Pat MacDonald's package\nfor doing this, which can be found on Files 089 and 090 of the CBT\nTape, has been employed by many other programs on the tape, notably\nthe ARCHIVER package from Rick Fochtman, which is found on File 147.\n\n      Rick Fochtman's ARCHIVER package is unlike any that I have ever\nseen, or even heard of.  I don't even think there is a vendor product\nwhich does what the ARCHIVER does.  The ARCHIVER will take any normal\nnon-VSAM system programmer data:  source modules in pds or sequential\nform, load modules, PSF objects, or whatever, and load it into ONE\narchive, which is a VSAM dataset, in highly compressed form.  You can\nfully recover the data, or pds, member by member, from the VSAM\narchive.  Furthermore, the ARCHIVER has a facility to dump the\n\"members\" of the archive into a tape dataset, and you can recover all\nthe members from the tape as well.  The main difference between the\nVSAM archive and the tape archive, is that you can add or delete\nmembers with the VSAM archive, but you can't do that from the tape\narchive.\n\n      Compression in the ARCHIVER is enormous.  Version 5.0 of the\nARCHIVER uses a Huffman Tree algorithm for compression.  Using Version\n5.0 of the ARCHIVER, I once dumped approximately 178 sizable pds'es\nonto one 3480 non-compressed cartridge.  That tape was very useful for\nloading my tools down, at a later consulting job.  The ARCHIVER can be\nfound on File 147 of the CBT Tape, and Rick Fochtman has been working\non improvements for it.\n\n      ASMTOZAP was written by Howard Gilbert at Yale University,\nanother old-timer.  ASMTOZAP is a PL/I program which allows you to\ncode a system modification zap as assembler code.  You code the zap in\nassembler language using special control cards starting with the\nkeyword *ZAP.  Then you assemble the ASMTOZAP-format patch with your\nassembler.  The *ZAP keywords come out as assembler comments in the\nlisting.  Finally, you post-process the assembler listing which\ncontains machine instructions and location counter information, with\nthe ASMTOZAP program to generate a system zap to the original module.\nSome examples of ASMTOZAP patches can be found in File 369 of the CBT\nTape by looking at members starting with the letters \"LM\" (for Local\nMod).  My July 1989 column (which can be found on File 120 of the CBT\nTape) also illustrates the ASMTOZAP processing.\n\n      The ASMTOZAP program looks at the *ZAP keywords in your\nassembler listing, and performs actions to generate card-images.  If\nyou want to ASMTOZAP to punch a card, such as a ++USERMOD card, you\ncode a *ZAP CARD statement in your assembler code.  To make ASMTOZAP\nstart generating VER statements from the assembler code to follow, you\ncode *ZAP START VER.  ASMTOZAP will generate REP statements after *ZAP\nSTART REP has been coded.  Finally, *ZAP END tells ASMTOZAP to stop\ngenerating cards after that point in the assembly listing.\nDisplacements into system code are indicated by ORG statements in your\nassembler code.  The advantage of coding a complicated system patch in\nASMTOZAP format, is that by changing a few ORGs, you can usually refit\nthe patch to a later version of the IBM module.  All VER and REP\ndisplacements have been calculated by the assembler.\n\n      ASMTOZAP was written by Howard Gilbert in PL/I Optimizer.  Some\nshops aren't licensed for PL/I.  However, I modified a version of\nASMTOZAP so it would run under the free PL/I F compiler and library\nthat can be found on File 092 of the CBT Tape.  ASMTOZAP, and its\nPL/I F equivalent, called ASMTOZAF, can be found on File 044 of the\nCBT Tape.  Load modules can be found on File 035.  ASMTOZAP may now\nbe run by any MVS shop.  Take a look at ASMTOZAP.  It may make life\nmuch easier for you, if you have system mods.\n\n      We've discussed quite a number of tools this month, but it\ndoesn't even scratch the surface of what's available.  For more\ninformation on the CBT tapes, you can see the current documentation\nthat is posted at http://members.aol.com/cbttape.  Good luck.  See\nyou next month.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9804AP": {"ttr": 17923, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x98\\x06O\\x01\\x00)\\x9f\\x11G\\x00\\xd9\\x00\\xd9\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1998-03-05T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 217, "newlines": 217, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          April 1998\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.  Sam can be reached at\nsbgolob@aol.com or sbgolob@attglobal.net.\n\n\nOTHER PEOPLE'S PROBLEMS\n\n      Did you ever wonder how it's possible to keep up with the MVS\nfield, especially now that it's OS/390 too?  This problem is indeed\ncompounded if you happen to be a systems programmer in a backleveled\nshop--say a place that runs MVS/XA 2.2.3, or MVS/370, or some system\nlike that.  Do places like that still exist today?  You bet they do,\nalthough Y2K may do something to eliminate them soon.  Even if you\nwork at a very modern shop, on a very modern system, the field is\nmoving fast, making it a requirement for all of us to learn things\ncontinually.\n\n      Nobody knows everything, and everybody is limited by finite\nintelligence (even if they have a lot of it) and finite time.  Nobody\ncan get more done than they actually can.  It follows, first, that\npeople have to work together with each other, and second, that a smart\nperson should realize that it's good to take advantage of other\npeople's experience, because you don't have enough time to re-invent\nall the wheels in the world.  (It's also counter-productive.)  When\nsharing experiences with people, it's a good idea to have a balance\nbetween helping others and getting helped by them.  Everyone has a\npleasant experience when the sharing goes two ways.\n\n      Getting back to the problem of keeping up with MVS, I've\ndiscovered some helpful advice--find out about other people's problems!\nI know a fellow who worked for many years at a shop which had\nback-leveled system software.  Besides budgetary constraints and\nhaving to fend off numerous attempts to outsource the computer\noperation, this place had to run a computer that wasn't ESA-capable.\nThe systems programmers were faced with not being able to acquire\nexperience with modern equipment.  How can one lessen the isolation\nthat this causes?  This fellow did it by not being isolated.  Those\nwere the days before the Internet; he used to call other systems\nprogrammers in other shops constantly.  He used to try and attend\nSHARE and other user group meetings.  He constantly asked his friends\nabout the problems they were having, and he shared his problems with\nthem--often they were able to help him out of some sticky jams--those\nwere the days of the \"untrained IBM-SEs\", and before IBMlink.\n\n      It helped that this fellow was an extrovert, and he didn't have\nany trouble talking to people.  Nowadays, there's hope for everyone.\nWith the advent of a more electronic age, everyone can participate in\nthis process.\n\n\nPROBLEM EXCHANGING FOR INTROVERTS TOO\n\n      I'm quite new to the Internet.  My previous shops didn't give us\nInternet access, but nowadays you can also buy your own access for not\ntoo much money, or for none at all.  The Internet has Newsgroup lists,\nwhere you exchange your problems by writing, or just listening, and you\ndon't have to talk to anybody directly.  One of the principal lists is\ncalled IBM-MAIN, out of the University of Alabama.  IBM-MAIN is an\nideal vehicle for exchanging problems among MVS systems programmers,\nbut it has to be managed, in order to be fully useful.  There are many\nother lists too, which run the same way.  They're a lot of fun, once\nyou get into it.\n\n      IBM-MAIN is the largest list I know of.  It is a closed list,\nmeaning that you have to subscribe in order to send email messages to\nit.  Anyone who sends a message to the list, gets the message circulated\nto all the subscribers.  Once you subscribe to the IBM-MAIN list, your\nemail could be bombarded with about 40 to 60 messages a day.  How do\nyou handle that?  There's an option on LISTSERV, which is the software\nthat manages most of these lists, called DIGEST.  Instead of getting\nindividual messages, you get a DIGEST of all that day's messages, every\nmidnight.  This DIGEST is only one file, and it doesn't overwhelm your\nInternet email.  I save the digest as a file every day, and browse it\nat my leisure with SPF/PC.  With DIGEST, I can't answer all the messages\nfrom the list on a real-time basis, but I save my sanity.  I answer the\nmessages a day later.\n\n      IBM-MAIN is serviced by software called a LISTSERV server, and\nmany other newsgroup lists use this same software too.  Once you learn\nto use the LISTSERV software, you can comfortably manage many newsgroup\nlists, and correspond with the people who send email through them.  The\nvarious newsgroup lists keep tabs on other lists, using the LISTSERV\nsoftware capabilites.  For example, once you subscribe to IBM-MAIN, you\ncan ask its list server to send you a list of other newsgroup lists,\nand you can even ask it to attempt to subscribe to those lists for you.\n\n      We have to get started by subscribing to IBM-MAIN, for example.\nFrom your email address, you send a message to LISTSERV@BAMA.UA.EDU,\nwith message text: subscribe ibm-main (optionally followed by your\nactual name).  The message will be handled by computer.  \"Subscribe\"\nis a keyword that the LISTSERV software reads.  The computer will send\nyou back a message with a code.  You merely have to reply to the\ncomputer's message, with a message that says one word:  ok.  Or you\ncan say ok, followed by the code number they send you.  The list server\nwill then send you a message that you are subscribed to the list, and\nyour email id will start getting bombarded with the email messages\nthat everyone sends in.  Once you are subscribed, you can send mail\ninto the IBM-MAIN list yourself (and everyone will get a copy).  The\nemail address you use is IBM-MAIN@BAMA.UA.EDU.  This is different\nfrom the LISTSERV address.  When you want to broadcast mail, you must\nuse the IBM-MAIN address.  When you want to talk to the computer itself,\nyou use the LISTSERV address.\n\n      The IBM-MAIN list has lots of messages per day, usually.  Most\nother lists have less activity.  To stem the big tide of email messages,\nyou can talk to the list server to customize your subscription.  A big\nlist of commands to use, can be obtained by getting a LISTSERV reference\ncard.  Simply email the LISTSERV address of the list, with the message:\nLISTSERV REFCARD and the computer will email a reference card of\ncommands, back to you.  The next thing I do, to customize my session, is\nto send the list server a list of SET commands, to customize my session.\nThe ones I used for the ibm-main list are:\n\n      set ibm-main repro     (to get a copy of my own messages)\n      set ibm-main ack       (to get an acknowledgement that my own\n                               message was sent out)\n      set ibm-main digest    (to condense all the incoming messages\n                               for each day, into one email, instead\n                               of many emails)\n\nWith the LISTSERV reference card, and a little practice, you can get\nyour subscription parameters the way you want them.  A good piece of\nadvice is to save the email containing the reference card, as a file.\nThen you can print it out, and constantly refer back to it.\n\n\nNETIQUETTE AND BENEFITS\n\n      Once you have the privilege of being subscribed to a list, don't\nabuse it.  It's better to keep your messages useful to the public, and\nnot to waste their time.  Everyone else has to manage all the messages\nthat come in.  Ask yourself the question:  \"Am I contributing to the\ngeneral store of knowledge, or to the general garbage can?\"  I think\nthat if you look at the other people's messages for a while before you\nyourself send any, you'll get the general idea how it goes.  Try not\nto attach any big files to your messages--I made that mistake once, and\nonly once.  These files burden the list server (which has to duplicate\nthe file possibly 1100 times) and also fill the subscribers' mailboxes\nunnecessarily.  Don't use the list to advertise your own commercial\nservices or software, except to mention that it may solve a certain\nsubscriber's problem.  Solving people's problems is permitted;\ncommercial advertising for its own sake, isn't.\n\n      Now that we've talked about the preparations, let's start talking\nabout the results.  Once you've started looking at the other people's\nmessages, you'll start learning.  A good rule of thumb for me has always\nbeen to look carefully at the things I know about, and to also read the\nthings I don't know about.  Reading the things I don't know about is\nneeded for expanding my horizons.  If someone writes about a piece of\nequipment or software that my shop doesn't have, or that I don't have\nprevious experience with, here's a way to get some cheap experience.\nThen, if I see that equipment or software somewhere else, or my shop\nacquires it later, I already know something about it.  Some information\nabout this stuff is already in my general store of knowledge.\n\n      What if I myself have a problem?  I can send an email to the\npublic, and see if someone will send me a solution.  It's an effective\nway to go oftentimes.  Of course, the process depends on the willingness\nof the participants to take the time and help other people.  But that's\nthe joy of it--the give and take!  I get a tremendous amount of\nsatisfaction if I help someone else out of a jam.  And I in turn, have\nbeen similarly helped numerous times by others.  There's a big pool of\nknowledge out there!\n\n      Occasionally, the news group has helped me find out about a user\ngroup I'd lost track of.  I'm on the East Coast, and I wanted to know\nwhat how the Los Angeles MVS Users Group was doing?  After one or two\nrequest emails to the news group, I got several replies with phone\nnumbers and addresses of relevant people.  Anything related to improving\nour ability to do our jobs, is fair game for discussion.  The talk can\nget quite peripheral, but most often, it's very specific and to the\npoint.\n\n      Once in a while, we can also poke fun at a certain vendor's\nannoying practices.  Besides the laugh we get from the \"inside jokes\",\nwe can glean practical advice about how to circumvent that vendor's\nefforts, whatever they might be.\n\n\nGETTING ADDICTED\n\n      Once you've gotten yourself accustomed to listening to other\npeople's problems, the benefits will start accruing.  You'll be better\ninformed about the MVS (OS/390) field in general.  After all, you've\nbeen listening to the news!  When your own shop gets new equipment,\nyou'll have a \"leg up\" on how it works, and you can ask the group any\nquestions you have about it; they'll tell you their war stories.  You'll\nbe aware of what your peers are interested in, and concerned about.  You\nwon't remain isolated in your own shop any more.\n\n      Of course, your shop will benefit when you're better able to do\nyour job.  But you will benefit too.  I have my 50-50, 100-100 rule.\nIt goes like this:  \"When you do a task well, you split it 50-50 with\nyour employer--both of you get benefit.  They get the job done, and\nyou get the experience.  But it's really not a split, it's 100\npercent for both.  They get 100 percent of the job, and you get 100\npercent of the experience.  That's something that nobody can take\naway from you!\"  I like this rule, and I live by it.\n\n      Talking on the news groups gets to be so much fun after a while,\nthat I find I have to limit myself to a certain amount of time each\nday.  Like any addiction, even a \"good addiction\" needs a limit.  You\ntoo, can experience this fun, if you aren't doing it already.\n\n      However, after you're addicted, you'll know that life with\nothers is better than life by yourself.  And it's practical also.\nGood luck.  See you next month.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9805MY": {"ttr": 17928, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x98\\t\\x0f\\x01\\x00)\\x9f\\x11G\\x01\\x1a\\x01\\x1a\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1998-03-31T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 282, "newlines": 282, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          May 1998\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.  Sam can be reached at\nsbgolob@aol.com or sbgolob@attglobal.net.  Documentation about the CBT MVS\nTapes can be found on the web, at  http://members.aol.com/cbttape\n\n\nUNDELETING DATA - PART 1\n\n      Most of us have come across a situation in which we accidentally\ndeleted a pds member or a dataset.  What does an application programmer\ndo under the circumstance?  Call systems programming!  They're the\nexperts, and they'll restore the dataset from a backup (or they'll do\nsome \"magic\").  What do we do when it happens to us?  Usually, we can\ndo the same thing, except that we'll do it ourselves.  But what if there\naren't any backups for some reason?  Do we have any recourse then?\n\n      Of course, this supposedly should never happen.  We are the\nguardians of our installation's data.  And we should administer the\ninstallation in such a way that there are many barriers between normalcy\nand disaster.  If one thing goes wrong, then there is a contingency\nplan.  If that contingency plan fails, then there's a second plan\nright behind it.  And ideally, these contingency plans should be nested\nmany levels deep, so that except under the most dire of circumstances,\nour shop can always recover from a mistake.\n\n      However, we and our management are fully responsible for setting\nup these plans and procedures in the first place.  And it pays for us\nto become as knowledgeable as possible in recovery techniques.  You may\nnever know in advance when you'll need a technique, or when you have to\nhave some recovery tool in place, ready for action.\n\n      Today, we'll talk about some techniques that are usually in the\ncategory of \"last resorts\", but they don't have to be.  Let's consider\nthe idea of \"undeleting\", or restoring some data that was deleted by\nthe operating system.  Undeleting a pds member can often be done in a\njiffy, with the right tools.  Undeleting an entire dataset is a\ncompletely different matter.  It is usually very difficult to do, and\nto me it seems almost impossible to automate, because to undelete a\ndataset, you have to restore data that normally isn't saved.  We'll\ndiscuss the topic of undeleting datasets, mostly in the next column.\nThis month, we'll deal with general principles, and restoring deleted\npartitioned dataset members.\n\n\nSOME PRINCIPLES BEHIND UNDELETING\n\n      Once you've gotten rid of some disk data on your system, it's\ngone, right?  Not necessarily.  Sometimes the data itself still exists\non disk, but only the pointers to the data were deleted.  This happens\nwhen you delete a partitioned dataset member, or when you delete a disk\ndataset.  Under many circumstances, the data is still there.  Only the\npointers to the data have been wiped out.  Theoretically, if you can\nrestore the pointers to the data that is still there, you can restore\nactual access to the data.  This is the concept of undeleting data.\n\n      Let's go deeper into this, and ask the question:  \"How does the\nsystem find data on disk?\"  I'll answer this question in a general way.\nOnce the system knows that the data is on a certain volume, usually\nfrom looking at the catalog, or if the user has specified the\nparticular volume serial, then the system goes to the volume id record\non track 0, record 3 of that volume.  Record 3 contains the volume id,\nand the exact CCHHR (cylinder, head, and record) location of the header\nrecord (Format 4 DSCB) of the VTOC, or Volume Table of Contents for\nthat volume.  The VTOC contains records which point to the individual\ndatasets.  If the desired dataset happens to be a partitioned dataset,\nthen the beginning of its data consists of another set of pointers, the\npds directory.  The pds directory contains the names of all the dataset\nmembers.\n\n      Each pds directory entry minimally contains the member name and\nthe TTR location (relative track and record location from the beginning\nof the dataset) of the beginning of that member.  The directory entry\nmay contain more data:  SSI information, ISPF stats for source-type\nmembers, or load module attribute information.  In any case, a dataset,\nor a member of a partitioned dataset, can be exactly located on the\ndisk volume.  Practically speaking, it is far easier to restore a\ndeleted pds directory entry for a member, than to restore all of the\nVTOC records necessary to \"undelete\" an entire dataset.\n\n      Now let's talk about \"data integrity\".  What keeps the system\nfrom constantly overwriting valuable data that's on disk?  Once data\nis written on a disk volume, its space locations, which are the disk\nextents, are marked as occupied, or \"allocated\".  A new allocation of\nspace will not reuse any space that's occupied--only space that's\nmarked as \"free\".  For performance reasons, if you think about it,\nit's obvious that the dataset allocation component of the system\nshould only be required to search for free space, and not have to sift\nthrough all the space on the pack that's occupied, before deciding\nwhere to put the new dataset.  A new dataset should only go to free\nspace, obviously.  Therefore, the disk's VTOC system should have a\nquick way of finding its free space locations directly, without first\nsifting through the occupied space.\n\n     There's an old way and a new way of finding free space on a disk.\nThe old way was from VTOC records directly.  The new way uses another\nsystem dataset on the volume, known as the VTOC INDEX dataset.  When\nyou initialize a volume with IBM's utility ICKDSF, you optionally\nspecify if you want the volume to be \"indexed\", and to have, and use\na VTOC INDEX dataset.  Once the index dataset is created, it doesn't\nhave to be used.  Using the ICKDSF \"OSVTOC\" option, you can run a job\nto turn the use of the VTOC INDEX dataset off.  Using the ICKDSF\n\"IXVTOC\" option, you can run another job to toggle the use of the VTOC\nINDEX dataset back on again.  SMS-managed volumes are required to be\nindexed, while they are being managed.\n\n      If the VTOC INDEX is not being used for a volume, then free space\nis determined by a chain of Format 5 VTOC records, known as free space\nrecords on the VTOC.  If the VTOC INDEX is being used, then the index\ndataset maintains the current status of free disk extents on the pack.\nIt's now obvious that whenever a new dataset gets allocated, its disk\nextents have to be removed from the pool of free disk extents on the\nvolume.  Conversely, when a dataset gets deleted, the VTOC system\nreturns its extents back to the pool of free disk extents.  This fact\nis very important for us.  If you want to undelete a disk dataset, you\nhave to ensure that no one else will write over the data areas where\nthe dataset had been.\n\n      Before I drop this topic for now, and go to the easier task of\nrestoring deleted partitioned dataset members (as opposed to restoring\nentire datasets), I have to mention the topic of VTOC consistency.  It\nmakes sense not to mark a disk extent in the VTOC as both being occupied\nand being free at the same time.  But as we described, the VTOC system\nkeeps separate records of occupied space, and free space.  What if there\nis some kind of damage, caused by a system crash, when the allocated\nextents and the free extents have gone out of sync?  Where's the system\nsafety net to guard against this?\n\n      To keep matters simple, I'll discuss the OSVTOC case, in which\nthe VTOC INDEX dataset is not being used.  In that case, all free space\nrecords are kept in a chain of Format 5 DSCB records in the VTOC\nitself.  During any dataset allocation or deletion on the pack, there\nis a bit in the (Format 4) VTOC header, known as the DIRF bit, which is\nturned on.  During the time when the DIRF bit is turned on, the system\nassumes that there are inconsistencies among the VTOC records.  At the\nend of the allocation or deletion, after both \"occupied\" and \"free\"\nextent descriptions on the VTOC are adjusted to consistency, the DIRF\nbit in the VTOC header is turned off.  The VTOC records are now\nassumed to be consistent, between occupied space and free space.\n\n      Now what if a system crash occurs during a dataset allocation?\nWhen the system comes back up, and you try and allocate a new dataset\non the troubled volume, an allocation routine checks the DIRF bit\nfirst, and sees that it's on.  Allocation then calls a system program,\nknown as the VTOC CONVERT ROUTINE, which goes through the entire VTOC,\nand makes sure that the Format 5 free space records are properly\nconsistent with the extents already marked as allocated, before\nallowing any new allocations to take place.  During that time, you'll\nsee a console message:  \"VTOC CONVERT ROUTINE ENTERED, REASON DIRF\".\nThis safeguard ensures that new datasets will not be placed on top of\ncurrent data, after a crash.\n\n      We've now discussed how data is located on disk, and how disk\nspace is marked as either \"allocated\" or \"free\".  The rest of our\ndiscussion will consist of two parts:  undeleting pds members by\nrestoring deleted pds directory entries, and undeleting entire datasets\nby reconstructing deleted VTOC entries.  Since the latter topic is very\ndifficult, we'll leave most of it for next month.\n\n\nUNDELETING PDS MEMBERS\n\n      In truth, a partitioned dataset, or pds, is a sequential type\ndataset that has been modified to look like it is a collection of many\ndatasets.  Understanding that a partitioned dataset is \"sort of\nsequential\" is a key concept to know, when locating or restoring data\nin a pds.  A good way to get a picture of a pds, is to think that the\ndata is stored sequentially, but it is located and kept track of, by a\nkind of direct access.  The component of the pds which tracks the\nindividual files, or members, is known as the pds directory.  I have\nwritten a 3-part series about the details of pds directory structure\nin my September thru November 1991 columns of this magazine.  These\ncan be obtained from File 120 of the CBT MVS Tape, which is included\non the NaSPA cd-rom disk.\n\n      All new data written to a pds, is written after the end of the\nexisting data.  For example, if you are editing some source-type data\nsuch as JCL or program source code, and you save the data, the data\nfor the entire member is copied to a space after the end of all the\nother data in the dataset.  After the new data is written, a pds\ndirectory entry is either created, for a new member, or modified to\npoint to the new data, for a preexisting member.  In the case of an\nold pds member that was modified, after all of its data was copied to\nthe end of the pds, its old data remains in place, not pointed to by\nany directory entry.  Therefore the old data occupies \"dead space\" in\nthe pds.  The dead space is not recovered until a dataset \"compress\"\nis done, usually using the IEBCOPY program.  \"Undeleting\" a pds member\nconsists of re-creating a new pds directory entry to point to the\nprevious dead space, left by a deleted member.\n\n      The pds directory is physically located at the beginning of the\nfirst dataset extent, and it almost always has a different DCB\ndescription than the data itself.  Assembler programs which access a\npartitioned dataset's directory, as well as the data, have to have two\ndifferent DCB's defined--one for the directory, and one for the data\nthat is in the members.\n\n      In restoring deleted pds members, we'll bear in mind that there\nare enough automated or semi-automated tools for the job, so that we\nwon't have to directly zap a pds directory to do the restore.  Some\nknowledge of actual directory structure will only be required if ISPF\nstatistics, load module attributes, or SSI information will have to be\nadjusted in the restored member's directory entry, and we also have\ntools for that.  Available utilities which use the STOW macro to make\na new directory entry that points to the deleted data, are quite\nplentiful.  Our job will consist of learning how to use these tools.\nThis is the main reason why undeleting a pds member is so much more\nsimple than undeleting an entire dataset.  In undeleting an entire\ndataset, there are almost no available automated tools.\n\n      What are some pds member undeletion tools, and how can we get\nthem?  One of the most powerful tools is the free \"PDS\" TSO command\nprocessor, which can be found on File 182 of the CBT MVS Utilities\nTape, a huge independently produced collection of system programmer\nutilities that can be obtained (among other places) through the NaSPA\noffice.  Another, very different tool, is the FIXPDS program from\nFile 036 of the CBT Tape.  A third tool is the PDSGAS batch program\nfrom File 316 of the CBT Tape.  The CBT Tape also has other programs\nfor this purpose, scattered throughout its files.\n\n      The easiest tool to use, in my opinion, but not the best, is\nthe program called PDSGAS.  PDSGAS is a batch program.  All it does\nis to scan the data part of a partitioned dataset from the beginning.\nIf any data is found, that doesn't have a directory entry pointing to\nit, PDSGAS creates members named $$000001, $$000002, and so forth, to\npoint to the data in these \"dead spaces\".  If those names already\nexist, PDSGAS changes the new names slightly.  PDSGAS can do a\nminimal restore for source-type partitioned datasets only.  No ISPF\nstatistics or SSI values are created for the newly made members.\nPDSGAS also can't recreate the special directory entries necessary to\npoint to load module pds members.\n\n      The next tool to learn about is the free PDS command processor,\nnow at Version 8.5, from File 182 of the CBT Tape.  PDS is an extremely\nversatile program package.  There is a vendor-supported version of PDS\ncalled STARTOOL (from SERENA Inc.) that is far better than the free\nversion, but for this job, either product will do.  When restoring\ndeleted pds members, the PDS product is extremely smart.  PDS can tell\nthe difference between source-type members and load modules, and it can\nsupply ISPF statistics for the source-type members that it restores.\nFor load modules, once they are restored using PDS's \"RESTORE\"\nsubcommand, the load module attributes, such as reentrancy, APF\nauthorized, special entry points, etc. can be readjusted using PDS's\n\"ATTRIBUTE\" and \"ALIAS\" subcommands.  The PDS command statements\nnecessary to get a similar (but much more intelligent) result to PDSGAS,\nare:   RESTORE $$ REPEAT NOPROMPT     The PDS package has an extensive\nHELP member, and you can find out many more details there.\n\n      Finally, a completely different tool for pds member restoration\ncan be found on File 036 of the CBT Tape, and is known as FIXPDS.\nInstead of starting its scan for deleted member data at the beginning\nof the partitioned dataset, FIXPDS starts at the end of the extents\nfor the dataset, and goes backwards.  Each piece of \"dead space\" found\nby FIXPDS is ISPF-browsed for the user, and the user is given the\nopportunity to decide whether or not to stow a new member name for that\ndata.  FIXPDS ends, when it encounters the beginning of the pds.\n\n      Using FIXPDS can sometimes be a little tricky, especially if a\nsource-type pds was written over a previous load module library.\nSince FIXPDS does an ISPF browse, it uses the source dataset's DCB\ninformation such as its LRECL and BLKSIZE.  When it goes to the end of\nthe extents, and sees old load modules which are now dead space, it\nusually can't browse them, because their blocks are too big.\nTherefore, to use FIXPDS on a dataset like that, you sometimes have to\ntemporarily alter (with a tool like CDSCB from File 300 of the CBT\nTape) its DCB information to LRECL=0, BLKSIZE=32760, RECFM=U, look at\nthe \"far out\" data, stow what member names you want, and then change\nthe DCB information back to what it was.  This is tedious to do, and\nfor member restores in general, I'd say that the PDS package is the\nbest tool to use.\n\n      Well, I hope this session was instructive!  Next month, I'll\ntry and unravel the tricky concepts behind restoring entire deleted\ndatasets.  Good luck.  We'll see you then.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9806JN": {"ttr": 18177, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x98\\x11\\x0f\\x01\\x00)\\x9f\\x11G\\x01\\x8f\\x01\\x8f\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1998-04-20T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 399, "newlines": 399, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          June 1998\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.  Sam can be reached at\nsbgolob@aol.com or sbgolob@attglobal.net.  Documentation about the CBT MVS\nTapes can be found on the web, at  http://members.aol.com/cbttape\nSam also participates in library tours and book signings with his wife,\nauthor Courtney Taylor.\n\n\nUNDELETING DATA - PART 2\n\n      Last month, we began to consider the subject of how to\n\"undelete\" data that had been deleted from disk.  We asked the\nquestion:  \"If data is deleted from disk and isn't there any more,\nhow is it possible to get it back?\"  The answer is, that often, the\nprocess of deleting disk data only involves removing a pointer to the\ndata, as opposed to wiping the data off the disk entirely.  If one\ncan properly restore all the pointers to the data, then one can\nrecover the data.  The trick is, does one truly know the way the\nsystem is pointing to the data, across changes in the operating system\nand in data management from release to release, and from device to\ndevice?\n\n      Life has become more complicated.  System Managed Storage has\nintroduced additional intricacies into the way disk data is kept track\nof.  Several flavors of RAID devices have replaced conventional DASD\npartly or completely, in many installations.  These devices differ\ngreatly in the internals of their workings, and we have to know\nwhether they will logically behave like \"real DASD\" or not.  Our\napproach, when faced with a tough job of recovering irreplaceable data\nthat's \"still there\", is to be clever, to simplify the situation as\nmuch as possible, to keep a clear head that stays open to new evidence\nof the truth, and to stick to basics.\n\n      Today, the discussion will concentrate on how to recover data\nfrom a disk dataset which was \"deleted\" by the system.  Last month, we\ncovered many basic principles of how data is located on disk, and we\nalso looked at a few tools that are capable of restoring deleted pds\nmembers.  When restoring a pds member, we bear in mind that the dataset\nitself has not disappeared, just a directory entry that points to the\nformer location of a member, has been wiped out.  A pds directory entry\ncontains relatively little new data, minimally a member name, and a\nrelative TTR (track and record) location from the beginning of the\ndataset.  This can be automatically scanned for by a program, and\nfilled in.  Since a new pds member is always written at the end of the\nprevious data, there is no problem of keeping track of \"free space\" and\npreventing a new member from writing over it.  Now, we're facing what\nhappens when the entire dataset, pds or otherwise, is gone.  What can\nwe do to effectively get it back?  All the extent information is gone.\nAll the DCB information is gone.  We haven't saved the VTOC information\nabout what the data looks like.  In short, recovering a deleted dataset\nis a far tougher problem to tackle.\n\n\nTOOLS WE'LL NEED\n\n      In this column, I like to write about tools that are available\nfor everybody to use, no matter how \"low budget\" your shop is.  I'm\nvery glad that many such tools are available, and a big \"thank you\" is\nin order, for all the people who contributed to writing and fixing\nthem.  Most of these tools (at least the ones that don't come from IBM)\nmay be found on the CBT MVS Utilities Tape, a huge, free, independently\nproduced collection of \"system programmer stuff\" which can be obtained\n(among other places) from the NaSPA office.  The CBT Tape is updated\nquite frequently, and there is also a \"CBT Overflow Tape\" that contains\na lot of additional public software.  Fairly recent versions of the\nCBT MVS Tapes are included on the NaSPA cd-rom, but the tapes\nthemselves are usually updated quite a few times between editions of\nthe cd-rom.  Current info about the CBT Tapes is maintained at web\nsite:   http://members.aol.com/cbttape\n\n      We'll have to set up some tools (or others of equivalent\nfunctionality, if available) from the CBT Tape, in order to attempt an\nundelete of a disk dataset.  For relative simplicity, and because of\nspace considerations here, we'll limit ourselves to talking\nspecifically about attempting to undelete non-VSAM datasets.  Tools\nneeded are:  A disk mapping program which shows track extents.  One\nexample is the IEHMAP program from File 083 of the CBT Tape, or some\nof the similar programs which are called MAPDISK.  The Fullscreen ZAP\nTSO command (from File 134, load module on File 135) will have to be\nrun in authorized mode.  To learn how to do \"non-invasive private TSO\nauthorization for sysprogs\", see Files 185 and 186 of the CBT Tape.\nIf module IKJTABLS is run from an authorized STEPLIB, it overrides\n(the public) settings in IKJTSOnn of PARMLIB.\n\n      Other helpful tools are the PDS TSO command package from File\n182.  If you're licensed for PDS's successor, STARTOOL from Serena,\nit's all to the good, but for this job, STARTOOL is useful but not\nnecessary.  STARTOOL has a facility to format (and change) all the\nFormat 1 DSCB fields, once a working Format 1 DSCB has been created.\nOf course, we'll use ISPF.  And the REVIEW TSO browser from File 134\n(load module on File 135) will also be helpful.\n\n\nWORKING ON A PROBLEM\n\n      We all shudder to think about the scenario:  dataset deleted, no\nbackup.  It's a pds (source or load module).  For simplicity, it's on a\nseldom-used non-SMS pack.  To curtail usage of the pack, you might try\nvarying it offline to all systems except a test MVS system, or using\nsome other clever trick as necessary.  If the data was on an\nSMS-controlled pack, the pack has to be removed from SMS control.  See\nthe end of Figure 1 for sample JCL.\n\n      Now, the first thing you have to do is to disable the VTOC\nindex, if there is one.  For that, you'll have to run an ICKDSF OSVTOC\njob (also see Figure 1).  If the VTOC is nearly full, you'll have to\nmake sure there's room for a few extra Format 5 (free space) entries,\nby moving a few datasets to another pack.  Once the VTOC is non-indexed,\nwe can start work.\n\n      The idea is to take a blank VTOC entry that's all hex zeros\n(Format 0 entry), and create a Format 1 VTOC entry that points to the\ncorrect data extents, and behaves \"authentically\".  After this work is\ndone, the pack \"free space\" must be adjusted, so the new \"dataset\"\nwe've created will have extents that are marked as allocated.  Finally,\nwe'll use ISPF 3.2 and other ISPF functions, to look at the new\ndataset and see if it behaves as it should.  Then we'll make minor\nadjustments as necessary, and copy off the data to another pack, if\nwe can.\n\n      Our next task is to figure out where the data was.  Initially,\nwe have to find the first extent.  For a pds, this will be a directory,\nand if we see it, we should be able to identify the member names.  If\nthe member names look like those in the deleted dataset, we've made a\nlot of headway.  Deleted datasets leave unoccupied data extents on the\ndisk pack.  We next have to map the disk pack with a tool that has an\nabsolute track mapper (we'll use IEHMAP from File 083 of the CBT Tape),\nand we'll examine all of the empty extents that look like they are the\nproper size.  That is, if we happened to know that the deleted dataset\nhad a 300-track first extent, we'll look in the IEHMAP report for an\nunoccupied extent of 300 tracks, to search first.  Here's where you have\nto use your head!\n\n      After we've picked some likely extents where the data might have\nbeen, we need a tool to examine the data that's there.  It's not every\nsystems programmer who has a tool to look at unallocated data on a disk\npack!  But we have one--it's called UCLA Fullscreen ZAP, as enhanced by\nGreg Price, running authorized, in FULLVOL mode.  We can examine all the\ndata in the entire disk pack with Fullscreen ZAP, and we can go to\nabsolute cylinder, track, and record locations.\n\n      Here's what we do.  We invoke ZAP in FULLVOL mode by saying:  TSO\nZAP 'FORMAT4.DSCB' VOL(volser) FULLVOL.  This takes us to Track 0,\nRecord 1 at the very beginning of the pack.  Invoke the \"R\" subcommand\n(go to the next record) of ZAP twice, to bump up to Record 3.  This will\nshow the pack volser, so we're sure it's the right pack.  Actually, the\npack id shows at the bottom of the ZAP screen.  Then we use the ABS\n(go to absolute CCHHR location) subcommand of ZAP to get directly to the\nCCHHR location on the pack.  When using ABS, you may have to play with\nleading zeros as follows:  Suppose that IEHMAP shows a likely gap\nstarting at location 05E0.0007.  That's cylinder number X'05E0', track 7\n(really one more--numbering starts from zero).  To look there, we enter\nABS0005E00007, give or take a leading 0.  If the old data was there, we\nshould be looking at Record 1 on the track, an obvious pds directory, so\nthat we can read the names of the members.  Otherwise, if it's the wrong\nplace, we'll try the next likely gap (shown by IEHMAP) until we hit\npaydirt.  This could take a lot of patience.\n\n      Now that we know where the beginning of the data is, we have to\nbuild a VTOC pointer to it.  This is the tricky part.  We assume that\nthe VTOC index dataset has been disabled by job OSVTOC (Figure 1), and\ntherefore, all dataset information is in the VTOC itself.  In the ZAP\ncommand (invoked as before), enter the subcommand VTOCDS4.  This will\nget us to the first record (Format 4--VTOC header) in the VTOC.  We\nstart stepping forward, advancing one record at a time, using the \"R\"\nsubcommand repeatedly, until we come to a VTOC record that's all zeros.\nLook at the bottom of the screen and make a note of the TTR location of\nthis record.  We're going to use ZAP to turn this record into a Format 1\nVTOC record (DSCB) that points to our deleted data.\n\n      We have to be very careful, when creating a new Format 1 DSCB,\nthat the system should believe us--every field has to be correctly\nentered, with no mistakes.  You can find out the format of a Format 1\nDSCB by going to SYS1.MODGEN and assembling the macro IECSDSL1 with\nkeyword 1 following it.  Each VTOC entry is a keyed record--44 byte\nkey at the beginning, followed by a 96 byte data area--140 bytes in all.\nThe records in a VTOC are unblocked.  For some formats, the key is\nabbreviated--not all of it is used.  For the Format 1 DSCB, all of the\nkey, the first 44 bytes, is the dataset name, and blanks (X'40') have\nto pad to the end of the 44 bytes.\n\n      I have a limited space to describe a big job, so I've included\nFigures 2 and 3, detailing the layout of a Format 1 DSCB for an FB-80\npartitioned dataset, as a model.  Figure 2 was created by the FIXPDS\nsubcommand of the vendor product STARTOOL (from Serena Inc.), which\nformats the VTOC entry of the dataset that STARTOOL is pointing to.\nNot everybody has STARTOOL, so we'll use Fullscreen ZAP and the DSCB 1\nDSECT description as our guide.  Figure 3 shows how the same VTOC\nrecord appears to Fullscreen ZAP.\n\n      You should create your own model \"real\" VTOC entry as well.  For\nexample, if the deleted dataset was sequential, look at the VTOC entry\nfor a similar sequential dataset as your model.  If the deleted dataset\nwas a load library, look at the VTOC entry for a similar load library\nas your model.  You can do this with Fullscreen ZAP itself.  The\nFullscreen ZAP tutorial (subcommand \"?\") will show you how to print the\ncurrent record, or several records.  Point Fullscreen ZAP to the VTOC\nentry for your model dataset (one that's similar to the deleted one)\nand print its entire record out.\n\n      Now that we're \"ready\", we have to point to the beginning of the\nblank VTOC record (the Format 0) that we've chosen, and we start filling\nin the fields.  For this, we use the \"S\" subcommand of Fullscreen ZAP,\nto change the data bytes of the record, up to 8 bytes at a time.  Then\nwe (hold our breath and) make the changes permanent with ZAP subcommands\nas we go.  When all the fields are filled in, we try and access the data\nusing first, ISPF 3.2 with dataset and volume specification, to see if\nISPF can find the dataset at all.  After fixing any obvious errors by\nre-zapping VTOC fields, we can then try to ISPF BROWSE the dataset,\nto see if we have the data.  Finally, a good next step would be to try\nand copy the data to a new dataset on another pack.  Don't use IEBCOPY\nfor this, but rather try ISPF 3.3.  ISPF 3.3 will disturb the \"from\"\ndata less than IEBCOPY will.  I've had nightmares using IEBCOPY here.\n\n      The new dataset is, of course, uncataloged.  I'd try and copy the\ndata off and then re-delete the dataset.  This is probably the safest\npractice.  You may have to find additional extents for the dataset, and\nyou'll have to repeat the previous IEHMAP and Fullscreen ZAP \"ABS\"\nsearches patiently.  Then you have to fill in \"second extent\" and\n\"third extent\" fields in the Format 1 VTOC entry.  For more than 3\nextents, you'll have to find another blank entry to make a Format 3\nDSCB, point to the Format 3 from the Format 1 (the Fullscreen ZAP TTR\ndisplay may help you), and you have to correctly make a new Format 3\nentry as well.  A format 3 DSCB will hold up to 13 additional extent\ndescriptions, from the fourth extent, to the sixteenth.  Assemble\nIECSDSL1 3, look at a model, and keep on trying until all the missing\ndata has been recovered.  Then copy it off, to save it.  I talked\nlast month about how to re-adjust the pack's free space.\n\n      I hope this article will inform you about how tough it is to\nrecover a deleted dataset, and how important it is not to get to this\npoint.  If you can devise a way to keep records of all your VTOC\nentries for all your packs, the potential job of recovering will be\nmuch easier.  Even if you can IEHMAP all your packs once a week\n(IEHMAP is very quick), this will be of invaluable help.  Meanwhile,\nkeep your thinking caps on!  See you next month.\n\n *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFigure 1.   JOBS YOU'LL NEED  -  A quick reference\n\n         These are jobs to un-index the VTOC and re-index the VTOC of\n         a pack.  It is assumed that the pack was originally indexed,\n         and we do not want to use the index dataset while zapping\n         VTOC entries.  When the VTOC is un-indexed, only the VTOC\n         itself has meaningful information about the datasets on a\n         pack.  The index is then not used.  Re-indexing the pack\n         will have the effect of reorganizing the VTOC index and\n         recalculating the pack's free space.  At bottom is a DFDSS\n         job to remove an SMS volume from SMS control.  After the\n         DFDSS job is complete, you have to remove the volume from\n         the storage group.  Then you can access the datasets (and\n         curtail activity on that volume at the same time).\n\n\n//*              * * *     O S V T O C     * * *\n//SAGOLOBO JOB   (rest of job card)\n//*******************************************************************//\n//*  NOTE..... THIS WILL ASK OPERS FOR A REPLY - YOU NEED A \"U\" IF OK.\n//*******************************************************************//\n//*      CONVERT IXVTOC TO OSVTOC:\n//****************************************//\n//S1    EXEC PGM=ICKDSF,TIME=1439\n//SYSPRINT  DD SYSOUT=*\n//VPDKZ01 DD VOL=SER=PDKZ01,UNIT=SYSDA,DISP=SHR, <=== CHANGE ALL\n//   DSN=SYS1.VTOCIX.VPDKZ01        <=== OCCURRENCES OF VOLSER NAME.\n   BUILDIX DDNAME(VPDKZ01) OSVTOC\n/*\n//\n\n//*              * * *     I X V T O C     * * *\n//*******************************************************************//\n//*    NOTE..... THIS WILL ASK OPERS FOR A REPLY.  \"U\" IF OK. ****\n//*******************************************************************//\n//*        REBUILD INDEXED VTOC:\n//****************************************//\n//START EXEC PGM=ICKDSF,TIME=1439\n//SYSPRINT  DD SYSOUT=*\n//VPDKZ01 DD VOL=SER=PDKZ01,UNIT=SYSDA,DISP=SHR, <=== CHANGE ALL\n//   DSN=SYS1.VTOCIX.VPDKZ01  <=== OCCURRENCES OF VOLSER NAME TO YOURS\n   BUILDIX DDNAME(VPDKZ01) IXVTOC\n/*\n//\n\n//*************************************************************//\n//*    USING THE ADRDSSU CONVERTV COMMAND TO GO FROM SMS.     *//\n//*    THIS EXAMPLE CONVERTS A VOLUME TO NON-SMS-MANAGED.     *//\n//*      see DFDSSdss STORAGE ADMINISTRATION REFERENCE        *//\n//*************************************************************//\n//*\n//STEP1    EXEC  PGM=ADRDSSU\n//SYSPRINT DD    SYSOUT=*\n//SYSIN    DD    *\n         CONVERTV -\n            DYNAM(SMS034) -\n            NONSMS\n/*\n//\n\n\n *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.   STARTOOL'S LAYOUT OF A FORMAT 1 DSCB FOR A PDS\n\n            This figure will help us visualize the layout of a\n            140-byte VTOC Dataset Description entry (Format 1).\n\n            The data description can also be found by assembling\n            the macro IECSDSL1 1 from SYS1.MODGEN, but STARTOOL\n            shows, in addition, what the data actually looks like.\n            Figure 3 shows how Fullscreen ZAP views this same data.\n\n            The dataset is 80 byte, fixed blocked card-image format.\n\n\n ---------------------- FIXPDS: Format 1 DSCB Modification -------------------\n OPTION  ===>\n\n Current - DSN=SAGOLOB.CBT.EDIT,VOL=SER=PRIM12  MEM=A  -----------------------\n  DSCB1 at 0000000519\n\n  Caution: many of the fields of the Format 1 DSCB can not be changed without\n           compromising data set integrity.  For more information using field\n           level help, place the cursor on any of these items and press HELP\n\n OFF,LEN   LABEL      HEX VALUE       DESCRIPTION\n (0,44) DS1DSNAM ===> SAGOLOB.CBT.EDIT\n (2C,1) DS1FMTID ===> F1              Format identifier\n (2D,6) DS1DSSN  ===> D7D9C9D4F1F2    Data set serial name\n (33,2) DS1VOLSQ ===> 0001            Volume sequence number\n (35,3) DS1CREDT ===> 6100D1          Creation date\n (38,3) DS1EXPDT ===> 000000          Expiration date\n (3B,1) DS1NOEPV ===> 07              Number of extents on volume\n (3C,1) DS1NOBDB ===> 00              Number of bytes used in last directory\n (3D,1)          ===> 00              Reserved\n (3E,6) DS1SYSCD ===> C9C2D4D6E2E5    System code\n (44,7)          ===> E2F24040404040  System code (last 7 characters)\n (4B,3) DS1REFD  ===> 62006D          Date last referenced\n (4E,1) DS1SMSFG ===> A0              System managed storage indicators\n (4F,1) DS1SCXTF ===> 00              Secondary space extension flag\n (50,2) DS1SCXTV ===> 0000            Secondary space extension value\n (52,2) DS1DSORG ===> 0200            Data set organization\n (54,1) DS1RECFM ===> 90              Record format\n (55,1) DS1OPTCD ===> 00              Option code\n (56,2) DS1BLKL  ===> 6D10            Block length\n (58,2) DS1LRECL ===> 0050            Logical record length\n (5A,1) DS1KEYL  ===> 00              Key length\n (5B,2) DS1RKP   ===> 0000            Relative key position\n (5D,1) DS1DSIND ===> 82              Data set indicator flags\n (5E,4) DS1SCALO ===> 8000005B        Secondary allocation type and amount\n (62,3) DS1LSTAR ===> 019002          TTR of last used track and block of data\n (65,2) DS1TRBAL ===> CFFC            Bytes remaining on last track used\n (67,2)          ===> 0000            Reserved\n (69,10)DS1EXT1  ===> 010005E0000705F40004  Extent 1 in XX00CCCCHHHHCCCCHHHH\n (73,10)DS1EXT2  ===> 0101077C000E077D000E  Extent 2 in XX01CCCCHHHHCCCCHHHH\n (7D,10)DS1EXT3  ===> 0102025C000C025D000E  Extent 3 in XX02CCCCHHHHCCCCHHHH\n (87,6) DS1PTRDS ===> 0000000506      CCHHR of any associated Format 2 or 3 DSCB\n\n\n *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 3.  Fullscreen ZAP representation of a Format 1 DSCB record,\n           which might serve as a model for constructing a new\n           Format 1 DSCB to point to our deleted dataset.  This is\n           the same record that was formatted by STARTOOL in Figure 2.\n\n                                  Z  A  P\n\n ENTER VALID COMMAND ABOVE OR ? FOR HELP         VERSION=2.3G 17AUG92\n F'CBT.EDIT'\n\n 00000   E2C1 C7D6  D3D6 C24B  >C3C2 E34B  C5C4 C9E3   |SAGOLOB.CBT.EDIT|\n 00010   4040 4040  4040 4040   4040 4040  4040 4040   |                |\n 00020   4040 4040  4040 4040   4040 4040  F1D7 D9C9   |            1PRI|\n 00030   D4F1 F200  0161 00D1   0000 0007  0000 C9C2   |M12../.J......IB|\n 00040   D4D6 E2E5  E2F2 4040   4040 4062  006D A000   |MOSVS2     .._..|\n 00050   0000 0200  9000 6D10   0050 0000  0082 8000   |......_..&...b..|\n 00060   005B 0190  02CF FC00   0001 0005  E000 0705   |.$..........\\...|\n 00070   F400 0401  0107 7C00   0E07 7D00  0E01 0202   |4.....@...'.....|\n 00080   5C00 0C02  5D00 0E00   0000 0506              |*...).......    |\n\n\n\n\n                          *****  SCAN MATCH  *****\n OFF: 0008 (     8) ADDR: 00008 (       8) DSN: VTOC FOR PRIM12\n LEN: 008C (   140) BASE: 00000 (       0) CCHHR: 0000000519 TTR:  000419\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9807JL": {"ttr": 18184, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x98\\x16\\x1f\\x01\\x00)\\x9f\\x11G\\x01\\x08\\x01\\x08\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1998-06-10T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 264, "newlines": 264, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          July 1998\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.  Sam can be reached at\nsbgolob@aol.com or sbgolob@attglobal.net.  Documentation about the CBT MVS\nTapes can be found on the web, at  http://members.aol.com/cbttape\nSam also participates in library tours and book signings with his wife,\nauthor Courtney Taylor.\n\n\nWhen IBM Says You Can't... Sometimes You Can\n\n      Everyone in the computing field must live with limitations.  For\nexample, application programmers feel constantly hemmed in, because\ntheir authority to access the installation's data is always being\nlimited by the security system.  We systems programmers also experience\nthat feeling to a lesser extent.  But such a limitation, however\nirritating, is not necessarily bad.  It stops people from destroying or\naltering mission-critical data that they shouldn't have access to.\n\n      In contrast, here's a different kind of limitation, which in my\nopinion, is a very bad thing.  Sometimes you wish you had a utility to\nperform a certain function, but you're told that such a utility doesn't\nexist.  My answer is that it's not necessarily true.  In fact, it might\nbe amazingly easy to write an assembler program or a REXX exec to do\nexactly what you want to do.  Furthermore, someone else might have\nalready done the work.  When you experience this frustration, you can\noften do something about it, and it's legitimate for a systems\nprogrammer to refuse to permanently accept that kind of limitation.\n\n      In truth, many IBM \"no-no's\" are actually doable.  Often, if\nyou sit down to do the research concerning the internal structures\nthat you want to manipulate, you'll see that there's nothing to prevent\nyou from writing a program to do the job.\n\n      I have surprised myself by having done some fairly clever things\nwhich I never thought that I could do.  My SYS1.BRODCAST manipulation\npackage (CBT Tape - File 247) is an example.  IBM says you can't\ndisplay and clear other people's messages from the SYS1.BRODCAST\ndataset.  I wrote a bunch of utilities to do it easily and safely.  Of\ncourse, this took time.  It follows, that our problems could be solved\nif we could all divide the work, and share the results.\n\n      Well guess what?  There are already large collections of free\nutilities already available, and they are being added to.  One of the\nbiggest single collections is the CBT MVS Utilities tape, a huge\ncollection that's independently produced, and it's available from the\nNaSPA office and other sources.  Once you are in possession of a CBT\ntape of your own, you can make copies for all your friends (using a\nutility that's on the tape--the COPYMODS program on File 229).  There\nare many other such free collections.  A file on the CBT Tape itself\n(File 071) contains the documentation files for a large number of them.\n\n      Let's look at another specific example.  IBM says you can't add\ndirectory blocks to a partitioned dataset, without reallocating the\ndataset (with more directory blocks) and copying all the members from\nthe old partitioned dataset to the new one.  There is a RACF drawback\nto having to allocate a new pds and delete the old one.  You need ALTER\naccess to the dataset name.  Upon studying the situation, one can see\nthat it doesn't have to be that way.  If you could only be able to move\nsome members from the beginning of the pds to the end, and reformat\nthat space from the beginning into new directory blocks, you wouldn't\nhave to reallocate a new dataset; you could reuse the old one, and\nyou'd only need UPDATE access, not ALTER.  This could save a programmer\na lot of trouble.\n\n      Well, there exists a free utility which does this.  You point the\nutility to the pds, tell it how many more directory blocks you want, it\ntells you which members have to be moved to the end, and asks you if\nyou want to continue.  When you say yes, the members get moved, and the\ndirectory gets extended.  It's that simple, and the process works very\nreliably.  As I mentioned, the utility only requires UPDATE security\naccess to the dataset, you don't have an enqueue problem deleting the\ndataset, and this utility does not have to run APF authorized.\n\n      Where is this magic bullet?  It's actually something I've\nmentioned many times in this column.  It's the \"PDS\" program package\nthat can be found on File 182 of the CBT MVS Utilities Tape.  The PDS\npackage (and its vendor-supported successor called STARTOOL from Serena\nInternational) actually performs many more functions that IBM says are\nimpossible.  And the CBT Tape as a whole, has many more utilities than\njust the PDS program package.\n\n      Once the PDS program is set up (it runs as a TSO command), you\npoint it to the dataset you want to change.  Then you enter the\nsubcommand:  FIXPDS EXPANDDIR(nn), where nn is the number of directory\nblocks you want to add.  The PDS command then comes back with a prompt,\nlisting which members would have to be moved, and asks if you want to\ncontinue.  If you reply \"Y\" or \"YES\" to the prompt, PDS moves the\nmembers, reformats the additional directory blocks as you requested,\nand reports the new number of free directory blocks that the pds now\nhas.  So much for IBM's limitation.\n\n\nADDING A NEW DATASET EXTENT, AND OTHER JOBS\n\n      I mentioned that the \"PDS\" package will do other things that\nIBM says you can't.  One of them, is to add a new extent to a dataset,\nno matter what the FORMAT 1 DSCB (i.e. VTOC entry) says about how much\nthe secondary space of the dataset is set to.  Even if the dataset is\nmarked that the secondary space is zero tracks, you can add a new extent\nas big as you want.  You simply point the PDS command to the dataset as\nmentioned before, and enter the subcommand:  FIXPDS ADDTRK(nn) or\nFIXPDS ADDCYL(mm), and PDS will obediently add a new dataset extent of\nnn tracks or mm cylinders, as it was told.\n\n      PDS doesn't have to run authorized to do any of this.  It does\nsome other tricks, most of which you could probably also do, if you\n\"misuse\" JCL.  Suppose you've pointed the PDS command to a dataset.\nYou can enter FIXPDS RECFM(xx) or FIXPDS LRECL(rr) or FIXPDS\nBLKSIZE(bbbb), and the PDS command will listen to you, after you've\nanswered \"YES\" to its prompt.  These alterations to a dataset sometimes\nhave to be done, under some special circumstances, and I'll show you\none.\n\n      This modern example involves FTP.  I've discovered that I can\nFTP to an MVS computer site that has an Internet connection, from my\nhome pc.  I can often get to MVS by telling the pc FTP program my TSO\nuserid and password.  Suppose now, that someone has FTP'ed a\ndownloaded pds to me, that's in TSO XMIT format, which has to be LRECL\n80, and I want to upload that pds to this MVS system.  I simply FTP\nfrom my pc (through the pc's FTP program) to the MVS TSO account, and\nupload the file.\n\n      It's not so simple.  In order for the TSO RECEIVE command (the\nopposite of TRANSMIT, or XMIT) to reconvert the file into a pds that's\nthe image of the original pds from the sending system, the file has to\nbe LRECL 80.  RECEIVE only \"understands\" an XMIT file with LRECL 80.\nHowever, my pc FTP program only sends the file to TSO in blocks of 4160\nbytes, and the resulting file is marked on MVS as having LRECL 4160 and\nBLKSIZE 4160.  4160 is a multiple of 80, and actually, all the data is\nintact on MVS.  Only the \"official LRECL\" or \"marked record length\" of\nthe data is wrong.  As we said, RECEIVE can't restore this file as it's\nmarked.  However, we just point the PDS command at the file, and say:\nFIXPDS LRECL(80).  Voila, the data is marked LRECL 80, BLKSIZE 4160,\nand it's usable by the RECEIVE command.  Quick and straightforward.\nWow!\n\n\nMORE ON CHANGING DATASET ATTRIBUTES\n\n      There's another free utility that can change dataset attributes.\nThis one is called CDSCB (or \"Change the DSCB\"), and it is a TSO\ncommand that must run authorized.  CDSCB can be found on the CBT Tape\non File 300.  CDSCB has to run authorized, because it zaps VTOC\nentries directly, as opposed to the PDS command, which works by\nwriting a dummy addition to a dataset while forcing DCB attributes to\nthe dataset, like you can do using JCL.\n\n      CDSCB was written by Bill Godfrey, with the idea that if you're\nchanging a dataset's attributes by zapping the VTOC, you want to be\nsafe, and not change the wrong VTOC fields.  CDSCB makes the process\nmore foolproof.  CDSCB can also be run under TSO-in-BATCH.  You can\nget the APF authorization in batch, by running CDSCB from an authorized\nlibrary, and mentioning that library as a single STEPLIB dataset.\n\n      I've used CDSCB to add larger amounts of secondary space to a\nwhole volume full of IBM datasets.  As most of you probably know,\nIBM's shipped dataset allocations only contain barely enough space to\nhold their shipped data.  If you have a lot of maintenance to APPLY\nor ACCEPT, you can get many annoying utility failures due to inadequate\nsecondary space and inadequate allocation of directory blocks in the\nIBM datsets on the DLIB and TARGET packs.\n\n      Through using CDSCB and the PDS command under TSO-in-BATCH, I\ncan get a mass SMP/E APPLY or ACCEPT job to run, even though a lot of\nmaterial has to be added to the target libraries or the DLIBs.  Here's\nhow.  Obtain a list of all the datasets on the DLIB or TARGET pack.\nThen edit the list of names, to say the syntax:  CDSCB 'SYS1.whatever'\nSPACE(30) ALLOC(TR) VOL(volser) for each dataset name.  This will\nforce the \"official\" secondary space allocation to be 30 tracks for\nall the datasets.  If the dataset happens to be large, or to need much\nadditional space, you can edit the settings in CDSCB for that dataset\nto be larger.  If you want to force secondary allocation in cylinders,\njust substitute SPACE(2) ALLOC(CY) for SPACE(30) ALLOC(TR).  If CDSCB\nran successfully, it will display the message: \"CHANGED\" after each\ninvocation.  Otherwise it will say \"NOTHING CHANGED\".\n\n      To add more directory blocks to all the datasets on the pack,\nyou can run the PDS command under TSO-in-BATCH.  The proper commands\nwill take up at least 2 lines per dataset.  The first line will state:\nPDS 'SYS1.whatever' .  The second line could state:  FIXPDS\nEXPANDDIR(30) to add 30 directory blocks to each of the datasets.\nUnder TSO-in-BATCH, PDS answers the \"YES\" prompt automatically.  You\ncould add a third line for some of the datasets that don't have enough\nspace: FIXPDS ADDTRK(60) , which would physically create a new extent\nof 60 tracks for that dataset, and not just mark the potential size of\na future new extent, as the CDSCB \"SPACE\" keyword does.\n\n      At the end of this process, you should have a whole pack full\nof adequately allocated system datasets, and your mass APPLY and mass\nACCEPT troubles will be solved, or will be much more easily handled.\nOf course, make sure that there is enough actual free space on the\nwhole volume, so your system datasets have room to expand, if\nnecessary, during the SMP/E run.\n\n\nA JES2 EXIT LOADER\n\n      Anybody who writes JES2 exits, knows that IBM says you have to\nrecycle JES2, or IPL, in order to change which VERSION of a particular\nJES2 exit you are running.  IBM does supply a system command to ENABLE\nor DISABLE a particular JES2 exit.  But if you DISABLE and then\nre-ENABLE one particular exit, you always get the same version.  You\ncan't plug in a new version of a particular JES2 exit, unless you bring\nJES2 down and up again, or re-IPL.  As least IBM says you can't!\n\n      Who has a problem with this?  The system programmer who is testing\na new JES2 exit, or is modifying one.  To try out a new fix, you have to\ndisturb everyone on that particular system by recycling JES2 or IPLing.\nEven if you're testing your exit on a test system, there may be many\nother programmers testing their stuff at the same time, and you'll be\ndisturbing their work.\n\n      If you know JES2 internals to some extent, the situation is not\ninsurmountable at all.  The reason why you can't change versions of an\nexit, is that JES2 points to its load modules (including the modules\nbelonging to the various exits) with an address table, called the LMT,\nor Load Module Table.  The LMT contains address entries, which point\nto the entry points of all the JES2 modules.  IBM simply doesn't\nprovide a facility to re-point an LMT entry to a different module,\nwithout a restart of JES2.\n\n      If you could write a program to create a new copy of the JES2\nexit program in the proper environment:  the JES2 address space, or\nthe CSA or LPA areas of common storage, and re-point the LMT entry to\nthe new copy, you've basically solved the problem, minus a few\ndetails.  You could code your program as a JES2 Exit 5 routine (JES2\ncommand modification), so it could be invoked from the console as a\nnew JES2 command.\n\n      IBM has refused all suggestions to release a \"dynamic JES2 exit\nloader program\".  I'm not sure why.  One guess would be that IBM doesn't\nwant to take responsibility that someone might irresponsibly disturb\nproduction processing by altering the version of an exit that's running.\nThat doesn't seem to be so likely, because even today, an operator can\ndisable any JES2 exit with a command.  In any case, IBM has left the\npoor system programmers who code JES2 exits high and dry.\n\n      Not any more.  There's a partially effective JES2 exit loader\nprogram on File 196 of the CBT Tape.  That (File 196) exit loader will\nload a new version of any JES2 exit that runs in the JES2 address space\nenvironment (which includes many of them).  Until now, the public didn't\nhave an exit loader available, that would work for exits in all JES2\nenvironments--CSA and LPA included.  Now, an expert JES2 programmer,\nBob Break, has written a fully functional JES2 exit loader program,\nwhich is currently on the JES2 SHARE Tape (from Jack Schudel of the\nUniversity of Florida - schudel@ufl.edu) and which will shortly be on\nVersion 418 of the CBT Tape, soon to be released as of this writing.\nOur problems are solved!\n\n      At this point, before closing, I'd like to add that there are\nmany more things that IBM says you can't do, but which you can.  If\nyou have such a question, look at the CBT Tape documentation on the\nweb, or subscribe to the IBM-MAIN newsgroup (see this column, Apr 98),\nand ask your question.  With persistence, you'll find someone who can\npoint you in the right direction.  Good luck.  See you next month.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9808SE": {"ttr": 18435, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x98\\x19\\x0f\\x01\\x00)\\x9f\\x11G\\x01/\\x01/\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1998-07-09T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 303, "newlines": 303, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         September 1998\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@aol.com or sbgolob@attglobal.net.\nDocumentation about the CBT MVS Tapes can be found on the web, at\nhttp://members.aol.com/cbttape\n\n\nWhen IBM Says You Can't... Sometimes You Can - Part 2\n\n      I admit that I'm very spoiled by my system programmer tool\ncollection.  I can do stuff that other people \"can't do\".  But I'm\nwilling to share my \"secrets\".  That's what this column is all\nabout.  Any tool or trick that makes our working life easier, or\nthat reduces system down time, or which helps the system to run more\nefficiently, is fair game for discussion in this column.\n\n      IBM supplies many tools which come with an MVS or OS/390\noperating system.  Some of these are very basic, functional, and user\nunfriendly, such as AMASPZAP.  Others are very complicated, quite\nfriendly, and have lots of features, such as ISPF and PDF.  Still\nothers are very complicated, not too friendly, but do a good job, such\nas SMP/E.  Just about everything that IBM supplies, works.  (I've seen\none or two things that didn't.)  But no matter how much IBM specifically\nsupplies, there's always room for improvement.  That's because IBM\nnever made a goal for themselves, to supply every tool a user will\never need.  Rather, they deliver very functional basic tools, and leave\na lot of room for users (and vendors) to build further tools from the\nrobust processing structures which they supply.\n\n      I'd say that MVS and OS/390 are quite \"accessible systems\".\nThis is what I mean.  Users can write programs to run under MVS, which\nperform functions that IBM themselves never intended to write.  For\nexample:  I don't think IBM ever intended to release a program to\ndynamically load new versions of JES2 exits.  Another example:\nInitially, the SPF and ISPF designers never designed one\nmulti-function member list menu, under which you could BROWSE, EDIT,\nRENAME, DELETE, add or change ISPF statistics, or examine many\ninternal details of a pds member, all from the same member list.  A\nthird example:  IBM hasn't come out with an interactive disassembler\n(load module to assembler source code) until recently, or a convenient\ninteractive delinker (load module to 80-byte object decks) at all.\nIBM hadn't done any of these things.  But users have.  And their tools\nwere largely built on the building blocks which IBM itself has\nsupplied.\n\n      I think that IBM deserves praise for building products that have\nfoundations for adding more function.  But the function won't come,\nunless the users, or vendors, take it upon themselves to do the adding.\nFortunately, many users have already done a lot of work, and their\nproducts are available to the public.  The result is that there are\nlarge collections of free tools for MVS which everyone can use, if\nthey'd but take the time to obtain and install them.\n\n      One of the large collections of tools is the CBT MVS Utilities\nTape, and its companion, the CBT Overflow Tape.  These are independently\nproduced collections of machine-readable software and other goodies,\nmost of them in source code form.  The CBT Tapes contain documentation\nabout other collections as well.  Information about the CBT Tapes can\nbe obtained at a web site:  http://members.aol.com/cbttape  and the\ntapes themselves can also be obtained from the NaSPA office and other\nplaces.  If you have any one of these tapes, you can make many copies\nfor others, using a program on the tape called COPYMODS, from File\n229.\n\n      Now, we'll talk about a few things that IBM says you can't do,\nbecause they don't supply you with the tools.  And we'll see how you\ncan do them indeed, with tools you can get from the CBT MVS Tape.\nThese tools were built by users like you and me.\n\n\nCLIPPING A PACK WHILE IT'S ONLINE\n\n      \"Clipping\" a disk pack is another name for changing its volume\nserial name.  In other words, if the pack's id was PACK01, you might\nneed to change it to PACK02.  IBM's standard method for doing this is\nto take the pack offline, and to run its low-level disk pack support\nprogram, ICKDSF in a batch job, to change the id.  This works well, as\ndo almost all of the IBM-supplied utilities.  Only problem is, that you\nhave to take the pack offline first.\n\n      Normally, taking a disk pack offline is not a big problem.  You\ngo to the operator console and vary the unit offline.  If the unit is\ncurrently being used, it won't come offline right away, but it will\nremain \"pending offline\" until all of the active tasks using that pack\nhave terminated.  However, sometimes there's an emergency, and you\ncan't wait for the pack to go offline, or you can't get it to go\noffline at all.  Then, you need to have another technique up your\nsleeve.\n\n      Enter the UCLA Fullscreen ZAP program.  As designed originally\nby a group of systems programmers at UCLA, Fullscreen ZAP is made to\nchange bytes of data in any dataset, not just load modules.  The ZAP\nprogram is a TSO Command Processor, designed to work under TSO.  ZAP\nshows you a full screen of data in a record (really a block) from the\ndataset, and allows you to examine or change any byte.  I might add,\nthat Fullscreen ZAP has its own built-in \"help\" information, and it's\na lot more user-friendly than IBM's AMASPZAP program.  Fullscreen ZAP\nis powerful stuff, but it's not ready for our pack clipping needs,\njust yet.\n\n      Along came Greg Price, who added a super-powerful feature to the\nFullscreen ZAP program--the FULLVOL keyword.  If you're running ZAP as\nan authorized TSO command (normally it doesn't have to run authorized),\nand you add the FULLVOL keyword after the dataset name, some high power\n\"magic\" is then done.  Before opening the dataset, ZAP (under FULLVOL)\nmanipulates the DEB (Data Extent Block) for the dataset to say that the\nextents for the dataset encompass the entire pack.  So instead of\nshowing you the beginning of the dataset, ZAP, under FULLVOL, shows you\nthe beginning of the pack--cylinder 0, track 0, record 1!\n\n      Now, you can begin to see what we're getting at.  Where is a\ndisk pack's id record?  It's on cylinder 0, track 0, record 3.  After\nspecifying a dataset that's on the pack you want to clip (you can use\n'FORMAT4.DSCB' as a dataset name, with the VOL( ) keyword to specify\nthe particular pack), you add the FULLVOL keyword, and Fullscreen ZAP\nwill place you just two records before the record you want to see.\nYou advance two records by entering the \"R\" subcommand twice, and\nthere you are!  The volume id field can be reached at 8 bytes off the\nbeginning of the 3rd record, so you enter the subcommand \"+8\" to get\nthere.  The next 6 bytes are the volume id.  You can enter an \"S\"\nsubcommand to replace the id with another name, and you use the \"ZAP\"\nsubcommand of ZAP, to write the changes to disk.  The pack is now\nclipped.  On newer MVS systems, and on OS/390 systems, the new pack id\nwill go into effect when the pack goes offline and comes back online\nagain.  On older systems such as MVS/XA, you vary the pack offline,\nand you have to do a MOUNT command, specifying the new volume id,\nafter the pack is varied online again.\n\n      Here's one of my own war stories.  I once had a problem where\nthere were two identically-named packs on the same \"running MVS\nsystem\".  The first one, with the lower unit name, had incorrect data\non it.  The second one, which had been restored from a backup, had the\ncorrect data.  For a certain reason, we had much difficulty getting the\nfirst pack offline.  It was during production time, and we had to re-IPL\nvery soon.  You can tell me what would happen after the IPL.  The wrong\npack, which had the lower unit address, would come online again, unless\nyou entered the proper operator response to the \"duplicate id\" message.\nOur operators (on a different floor) weren't trained correctly for the\nreply.  I had the quick solution.  I placed a dummy \"unique\" dataset on\nthe \"wrong\" volume, and invoked ZAP for that dataset, using the FULLVOL\nkeyword.  Then I changed that pack's volume serial name as we've\ndescribed.  After the IPL, the correct pack came up under its own\nvolser name, and the old pack came up under its new name.  See how\nuseful such a technique is?\n\n\nPRESERVING ISPF STATS AFTER \"IEBUPDTE\" SEQUENTIALIZATION\n\n      I don't know how important ISPF statistics are to you.  But they\noften are very important to me.  ISPF statistics show how large a pds\nmember is.  They show who updated the member last, and when.  When\nyou're looking through a library of source code, the ISPF statistics\nwill show a lot of telltale information and necessary history for each\nmember.  If you're moving a \"source-type\" pds from one location to\nanother, I'd bet you'd really prefer to preserve the ISPF statistics\nof the members.\n\n      IEBUPDTE is an IBM utility that is most often used for updating a\ncard-image source code member with an incremental update, using its\n./ CHANGE NAME=memname  control cards.  IEBUPDTE can also be used to\n\"string out\" all (or several) members of a partitioned dataset into a\nsingle sequential dataset, with the member data strung out, one member\nafter another.  Data from one member is distinguished from data from\nthe next member by an IEBUPDTE header card in the form:\n      ./ ADD NAME=memname\nwhich separates each member from the next.  You can reconstitute the\npartitioned dataset from the sequentialized IEBUPDTE-format dataset,\nby another invocation of IEBUPDTE, with PARM=NEW.  Each sequentialized\nmember will be stowed as a separate new member by the IEBUPDTE\nprogram, which reads the ./ ADD cards, to act as separators.\n\n      IEBUPDTE has one disadvantage in this process.  IBM invented\nIEBUPDTE before they invented ISPF statistics.  The IEBUPDTE utility\nhas a provision to preserve SSI information, which was present in\n\"ancient times\", but it simply has no provision to include control\ninformation about ISPF statistics in its ./ ADD cards.  So the stowed\nmembers, after an IEBUPDTE sequentialization and reload of a pds, do\nnot have the ISPF statistics preserved.  They simply get lost.\n\n      Enter some clever users, who created and standardized their own\nsystem of preserving ISPF statistics in ./ ADD cards.  This system has\nbecome so popular, that we don't need IBM.  Several programs on the CBT\nTape will perform the sequentialization and create ./ ADD cards with\nthe ISPF stats in this format, and several other programs will\nreconstitute pds members from this format, with the ISPF statistics\npreserved.  See Figure 1 for the format of the ./ ADD cards that have\nthe ISPF stats.\n\n      Programs which sequentialize a pds and preserve ISPF stats are:\nLISTPDS from File 316 of the CBT Tape (using the following parms):\n\n//    PARM='UPDTE(><),SPF,NOLIST,DECK,NOSEL' ,\n\nOFFLOADW from File 093 of the CBT Tape, and REVIEW from File 134.  To\nuse REVIEW under TSO for this purpose, you allocate FILE(SYSUT2) to\nan already created sequential output dataset, REVIEW a pds member, use\nthe DIR subcommand while under REVIEW to get a directory listing, and\nfrom the directory listing, invoke the =OFFLOAD subcommand.  In\naddition, the vendor product STARTOOL (from Serena International) with\nits COMBINE subcommand, adheres to these same conventions.\n\n      Programs which reload a partitioned dataset from a sequential\nversion and preserve ISPF stats are:  PDSLOADW from File 093 of the\nCBT Tape, and the SEPARATE function of the vendor product, STARTOOL.\nIn addition, OFFLOADW and PDSLOADW aren't restricted to LRECL=80.  They\nboth can handle fixed blocked datasets with record lengths up to 256.\n\n\nOLD LINKAGE EDITOR RESTRICTIONS\n\n      You may not know it, but you can still execute the old linkage\neditor (as opposed to the DFSMS binder) by executing PGM=HEWLKED\ninstead of PGM=HEWL.  The old linkage editor, which is still\ndistributed with DFSMS on OS/390, currently has the restriction that\ncard-image object decks cannot be blocked with a factor of more than\n40, that is, the block size can't be bigger than 3200.  This is a silly\nrestriction from OS/MFT days, that was finally eliminated only with the\nintroduction of the binder.\n\n      This restriction of the old linkage editor was never removed by\nIBM for all these years.  What's so surprising, is that the restriction\nis artificial, and is hard-coded into the linkage editor code, even in\nthe DFSMS version of HEWLKED.  You can re-code the maximum block sizes\nfor object decks, to a block size of 32720, and a blocking factor of\n409, by zapping a few places in the linkage editor.  Sample zaps to do\nthis may be found on File 257 of the CBT Tape, and I've shown one of\nthem in Figure 2.  I'm mentioning this fact, just to illustrate how\neasily an age-old IBM restriction can sometimes be removed.\n\n      To sum up, every time IBM mentions a restriction which bothers\nyou, you should take it with a grain of salt.  Frequently, you can't\nget around it.  But sometimes, more often than not, you can.  If you\nhave a question about some IBM restriction, post a query on the\nIBM-MAIN Internet forum (see this column, April 1998).  Many of the\npeople who monitor that forum are knowledgeable in free system tools.\nThere may very well be a way around the restriction after all.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   Illustration of pds members with ISPF Statistics (listed\n            first) and the corresponding ./ ADD NAME=  cards which\n            preserve these ISPF statistics in the \"standard\" LISTPDS\n            format.\n\n\n NAME      TTR    VV.MM  CREATED  LAST MODIFIED  SIZE  INIT  MOD   ID\n$$$COPYF  013901  01.03 90/11/28 96/05/06 19:20    32    23    0 SBGCSC\n$$$SAM1   013903  01.00 95/03/16 95/03/16 10:52    48    48    0 SYSPAJA\n$$$SAM2   013905  01.00 95/10/26 95/10/26 12:10    31    31    0 SYSPAJA\n$$$SAM3   013907  01.00 96/03/15 96/03/15 11:45    30    30    0 SYSPAJA\n$$JCL003  019901  01.99 92/02/05 98/06/28 11:45  1614  1433    0 SAGOLOB\n\n1       10        20        30        40        50        60        70\n+---+----+----+----+----+----+----+----+----+----+----+----+----+----+--\n./ ADD NAME=$$$COPYF 0103-90332-96127-1920-00032-00023-00000-SBGCSC\n./ ADD NAME=$$$SAM1  0100-95075-95075-1052-00048-00048-00000-SYSPAJA\n./ ADD NAME=$$$SAM2  0100-95299-95299-1210-00031-00031-00000-SYSPAJA\n./ ADD NAME=$$$SAM3  0100-96075-96075-1145-00030-00030-00000-SYSPAJA\n./ ADD NAME=$$JCL003 0199-92036-98179-1145-01614-01433-00000-SAGOLOB\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.   Fix to the DFSMS version of the old linkage editor,\n            PGM=HEWLKED, that allows object decks to be blocked\n            in larger than 3200 byte blocks.  Notice how simple\n            this fix is.  It can be fitted to any version of the\n            linkage editor.\n\n\n++ USERMOD(MDZ11CA)  /* ALLOW LKED TO READ OBJ BLKSIZE UP TO 32720) */.\n++ VER(Z038) FMID(HDZ11C0).\n++ ZAP(HEWLFINT) DISTLIB(AOS04).\n  NAME HEWLFINT\n*                       DC    H'3200'\nVER 000AE0 0C80\n*                       DC    H'40'  ( = 3200/80 = NO OF RECDS/BLK)\nVER 000F42 0028\n*                       DC    H'32720'\nREP 000AE0 7FD0\n*                       DC    H'409' ( = 32720/80 = NO OF RECDS/BLK)\nREP 000F42 0199\n  IDRDATA MDZ11CA\n++ ZAP(HEWLFAPT) DISTLIB(AOS04).\n*                       DC    H'40'  ( = 3200/80 = NO OF RECDS/BLK)\nVER 000216 0028\n*                       DC    H'409' ( = 32720/80 = NO OF RECDS/BLK)\nREP 000216 0199\n  IDRDATA MDZ11CA\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9809OC": {"ttr": 18441, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x98%\\x1f\\x01\\x00)\\x9f\\x11G\\x01<\\x01=\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1998-09-08T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 316, "newlines": 317, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         October 1998\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@aol.com or sbgolob@attglobal.net.\nDocumentation about the CBT MVS Tapes can be found on the web, at\nhttp://members.aol.com/cbttape .  The free PDS package can be obtained\nonline, at http://members.aol.com/freepds .\n\n\nAN IMPORTANT Y2K TECHNIQUE\n\n\n      As the \"magic deadline\" of January 1, 2000 approaches, it may be\nnecessary for us systems programmers to make some sweeping program\nchanges, very quickly, on that morning.  There is one technique that\nonce literally \"saved my company\" in such a situation, and I feel\nmorally bound to teach it to every systems programmer in the world,\nif I can get to them, and if they'll listen.  It is absolutely\nessential that each and every one of you knows about this technique.\nIf you don't have it (or an equivalent) in place and ready to use, you\ncould be lucky, but you may be very sorry.  It could cost your company\nmany hours or days of production time, and possibly, for some people,\ntheir jobs.  This is serious business, and it's our business!\n\n      As far as I know, IBM doesn't have an easy way to do this job\neither, so I don't think you'll get much help from them, unless they\nchange things very much between now and that big January 1st.  I do have\nan easy and quite painless way to do this almost impossible-looking task\nin a very short time.  Here it is.  Please listen well, for your own\ngood.\n\n\nTHE SUBROUTINE REPLACEMENT PROBLEM.\n\n      I faced this problem on January 1, 1991.  A time-dependent\nsubroutine which did date conversion for our company's production\nprocessing, failed on that January 1st.  The consequences of the\nfailure were catastrophic--a user abend was produced by the\nsubroutine when it didn't work.  Batch programs which used this\nsubroutine, failed with the user abend.  CICS and other online\ntransactions which used this subroutine, did worse.  At that time,\neach CICS region used only a single TCB--remember?  In other words, a\nfailure of the subroutine in any transaction, would bring the entire\nCICS region down.  Moreover (and this is the kicker), this subroutine\nwas directly linkedited into many of the company's batch and online\nproduction programs.  We didn't know which programs contained it.\nThere were upwards of 3300 load modules in the batch load library.\nAnd there were more than 1100 load modules in the online load library.\nUsing \"standard IBM methods\", this problem would take months to fix!\nCan you imagine the production impact?\n\n      It didn't take long for a programmer to fix the actual\nsubroutine, which was a small assembler program, and relatively\nsimple.  The big question was, how could we find and replace the bad\nversion of that subroutine in all the load modules which contained it?\n\n      IBM doesn't help.  Load module names don't indicate any of the\nsubroutine names, and ISPF member lists only list load module names,\nnot any subroutine names.  The standard \"brute force\" IBM solution\nwould be to take an AMBLIST listing of all the load modules to find\nthe presence of the bad subroutine.  (4500 load modules?)  Then you'd\nhave to write re-linkedit JCL to include the new subroutine that would\nreplace the bad one--by hand!  How could you make sure the linkedit\nJCL was right?  You could cause far worse production problems, if it\nwas wrong.  You'd have to carefully examine the linkage editor report\nfor each reworked load module.  This sticky situation would take a\nlong time to fix, and you'd never be sure you didn't miss a load\nmodule somewhere.\n\n      I fixed the problem, with complete accuracy, in two hours flat,\non January 2, 1991.  And I didn't miss one load module.  Do you want\nto read on, to see how to do it?\n\n\nSOLVING THE PROBLEM.\n\n      My quick solution to replacing a bad subroutine in many places,\nrequires the installation of a product.  The up-side, though, is that\nthe product is free.  Many of you have this product already installed\nat your shops, however.  I've also posted the latest source code for\nit on a web site, so you can download and install a new version for\nyourselves.  With this product in place, you can solve the \"global\nsubroutine replacement problem\", and many others as well.\n\n      The product we need, is the PDS program package, currently at\nversion 8.5, which resides on File 182 of the CBT MVS Utilities Tape,\nor which can be downloaded from a web site at:\n\n         http://members.aol.com/freepds\n\nThe CBT Tape may be obtained from the NaSPA office, and a (somewhat\nbackleveled) version of it can be found on the NaSPA cd-rom.  The\nCBT Tape is a huge conglomeration of system programmer goodies, which\nno MVS or OS/390 systems programmer should be without.  There is a\nvendor-supported version of PDS, called STARTOOL, from Serena\nInternational in Burlingame, California.  STARTOOL contains all the\nfunctionality of \"free PDS\", and much more, so if your installation is\nlicensed for STARTOOL, you don't have to install anything else.\n\n      The PDS package works as follows:  PDS is a TSO command, that\ncan be used with ISPF or without ISPF.  You point PDS at a dataset,\nand then you have a very large number of choices what to do afterward.\nPDS, even the free version, has perhaps 50 separate subcommands, that\nallow more than 1000 separate utility functions to be done to the pds,\nor to some of its members.  PDS automatically treats \"load module\"\ndatasets (RECFM=U) differently from \"source type\" datasets (RECFM=FB\nor VB).\n\n      The PDS package (and of course, STARTOOL) has a powerful\nfacility for keeping track of \"member subgroups\" of the current\npartitioned dataset it is pointing at.  One of the main purposes of\nhaving member subgroups, is to be able to do an operation to all the\nmembers of the subgroup, as if they were one member.  In other words,\nPDS has the capability of dealing with all the members from the\ncurrent subgroup as one unit.  You just refer to an asterisk '*'\ninstead of the member name, and a selected operation will be performed\non ALL members of the current \"member subgroup\", instead of on one\nindividual member.  This capability will help us very much.\n\n      Choosing the proper member subgroup in each load library, is an\nimportant key to solving our sticky problem.  To be specific, we'd\nlike to isolate a subgroup of load module members which all contain a\nCSECT having a given name (the name of our subroutine).  Then we can\nre-linkedit all those load modules, and those only, to fix them.  In\nother words, we've got to find them, then fix them.\n\n      Sometimes even that is not enough.  Suppose there are two\ndifferent versions of the subroutine floating around in our libraries,\nwith the same CSECT name.  Or perhaps (in a tougher case) there are\ntwo entirely different programs with the same CSECT name.  We might\nwant to further refine our member subgroup to contain only one of\nthose versions or programs, but not both.  Using the PDS package, that\ncan be done also, without much additional effort.  We're getting an\nindication at this point, that with the PDS command, we have a lot of\npower.\n\n      It remains, once we have a proper and complete list of load\nmodules to rework, that we need to re-linkedit them and replace the\nversion of the subroutine which is wrong.\n\n      The PDS package comes up strong in that department also.  PDS\nhas a facility, where it can look at a load module, and generate\naccurate JCL and linkage editor control statements, to re-linkedit the\nload module exactly as it was before.  All the proper attributes are\ngenerated, such as reentrancy, refreshability, APF authorization, and\nso forth.  Also, ORDER statements are generated by PDS in the linkage\neditor control statements, so that the re-linkedited module has all\nits CSECTs in the same order that the original module had them.\n\n      It is now obvious that we have all the ingredients in place, to\nsolve our problem.  Besides that, there are a few other considerations.\nIf your load library is a PDSE, copy it with IEBCOPY to a pds, and\nthen you can use the free PDS package on it.  Free PDS doesn't have\nPDSE support, but STARTOOL does.  If you're using STARTOOL for this,\nit doesn't matter if the library is a pds or a PDSE.  The PDS package\nis written in assembler language.  It runs at assembler speed (i.e.\n\"quick\"), and has optimized I/O routines to fetch the members of any\npartitioned dataset with the greatest speed.\n\n      For most of this, we have to thank Bruce Leland and Steve Smith.\nThey are the principal \"enhancers\" and builders of this product, and\nthey maintain the vendor version, STARTOOL.  John Kalinich is\nmaintaining the free version of PDS at this time, and he's doing a\ngreat job, too.  So far, you've seen that PDS can do this formerly\ntedious job very quickly, and now we'll look at the specifics.\n\n\nCORRECTLY FIXING ONLY THE BROKEN LOAD MODULES\n\n      In fixing our \"globally scattered subroutine\" problem, we must\nfirst determine which libraries are affected.  These, most likely, will\nbe application load module libraries.  First, you must determine the\nproduction libraries involved, and then, you should probably make the\nsame changes to the programmer libraries and development libraries, so\nthat the old error will never work its way back into production again.\nIf you have a change control system, you'll have to work within its\nrestrictions and parameters.  In any case, if you've anticipated the\nproblem, you'll be able to be orderly.  If not, you'll have to be just\nas orderly, but also fast.\n\n      Once you've got the list of libraries, you'll deal with them\none at a time.  For simplicity from now on, we'll pretend that only\none load library is affected.  But it usually isn't the actual case,\nand you'll just repeat the same procedure for all the libraries that\nyou have to rework.\n\n      The first task is to determine all the load modules which\ncontain the affected CSECT name.  This will probably be the name of\nthe subroutine you want to replace.  PDS and STARTOOL both have a\npowerful method of finding only those load modules which contain a\nCSECT with a certain name.  This is the \"IF\" subcommand of PDS, a\nlittle-known but powerful tool.  The purpose of the IF subcommand is\nto create a subgroup of members, based on a certain criterion.  The IF\nsubcommand will select a subgroup of members, starting from all\nmembers, or it will further refine a subgroup that was previously\nselected.  Let's invoke PDS, and point it to the proper library.\nUnder TSO, you'd say:    PDS 'library.name'    to invoke the PDS\ncommand, and at the same time, to point it to the proper library.\nThen you deploy the IF subcommand, and say:\n\nIF : MODULE(csectnam) THEN(SUBLIST)\n\nThe IF subcommand will now look at the starting member group, which\nis the colon \":\".  The colon means \"all members\".  From this starting\nmember group, IF examines the structure of every load module, and if\nit finds a CSECT matching the given (partial or complete) name you\nsaid in the MODULE() keyword, it selects that load module for inclusion\nin the new \"member subgroup\".  Otherwise IF excludes the load module\nfrom the subgroup.  So we now know, that after this operation, every\nmember of the current member subgroup contains a CSECT with the given\nmodule name.  We've done the \"find\" part, of the \"find and fix\" process.\n\n      Well, not always.  Sometimes, there might be two or more\nversions of that CSECT floating around in our libraries.  To further\nselect one of the two, we could do any of a number of things.  One\nthing we could do, is to find a character or hex string which exists\nin one of the versions, but not in the other.  This string should be\nso unique, that it's not likely to be found in a different CSECT than\nthe one you're dealing with.  Under the PDS package, the FIND\nsubcommand not only finds strings, but it can select members for\ninclusion into a member subgroup, based on whether a certain string is\nfound in the member.  FIND, when used in this way, works like IF.\nRemember that the asterisk \"*\" refers to all members of the current\nmember subgroup.  Then, you can say:\n\n       FIND * /charstring/ MODULE(csectnam)  THEN(SUBLIST)  or\n       FIND * xhexstringx  MODULE(csectnam)  THEN(SUBLIST)\n\nThis operation will further refine the member subgroup, picking only\nfrom members of the former member subgroup, which contain the string\nsomewhere within the named CSECT.  There are other ways you can pick\nand choose members.  The ultimate aim is to make sure that you have a\nmember subgroup which contains every member you want, and no others.\n\n      Now the re-linkedit part gets deployed.  The PDS subcommand\nwhich looks at a load module and generates re-linkedit JCL\nautomatically is the \"MAP\" subcommand with its RELINK keyword.  So,\nonce you've determined a proper member subgroup, you use the MAP\nsubcommand as follows:\n\n         MAP * RELINK\n\nThis produces an output listing to the PDS LOG (under ISPF mode) or to\nthe terminal (under line mode).  That output may be written to a file,\nusing one of the keywords of the CONTROL subcommand, so it can be\nedited.  This brings us to the last step.\n\n      The re-linkedit JCL produced by the PDS program, assumes that\nthe SYSLMOD library and the original library are the same partitioned\ndataset--the load library that PDS was pointing at.  After PDS\ngenerates re-linkedit JCL for all the load modules in the member\nsubgroup, you must edit each SYSLMOD DD statement to point to a\ndifferent, newly allocated output library, so that the re-linkedited\nload modules do not replace the original members immediately, during\nthis re-linkedit operation.  Only when these new load modules are\ntested and checked out, can you copy them over the old members in the\noriginal library, or you should use whatever \"safe\" production control\nprocedures you have.\n\n      The resulting JCL usually needs only a JOB card to run it,\nonce the SYSLMOD DD cards are fixed.  But in our case, where we need\nto replace the bad CSECT, we need two more things.  A repaired\nversion of the subroutine, as a load module or as an object deck,\nmust be placed in a library, and a DD card must be inserted into\neach step of the re-linkedit JCL, to point to that library where the\nrepaired module resides.  Then, an INCLUDE linkage editor control\ncard, pointing to the name of the module, and the DDNAME referring\nto its library, must be inserted before the main INCLUDE cards, so\nthe new CSECT will replace the old one having the same name.  This\nmust be done for each module you want to re-linkedit.\n\n      That being done for all the generated JCL, for all the load\nmodules in the member subgroup, the JCL is run, and all the necessary\nload modules will have been found and fixed.  It only remains to test\nthe new load modules, and (once tested), to copy them back to the\noriginal libraries.  Or you can run production from new libraries\ncontaining the newly fixed modules, in addition to all the other ones.\n\n\nDETERMINING YOUR VULNERABILITY IN ADVANCE\n\n      It is important to look at all your production programs, and to\ndetermine if any subroutines are used often, during the processing.\nOnce it is found that there are frequently used subroutines in\nproduction processing, you can do all of the IF processing in advance,\nto determine where these subroutines are.  Then, you can generate\nthe re-linkedit JCL in advance, so that it will be ready in case of\nemergency, on January 1, 2000.  As you become more familiar with the\nprocess, it should be redone whenever there are significant changes to\nthe production load libraries.  In case any of these subroutines has\nto be fixed, you've got the mechanisms already there, so the fixed\nversions can be put into place quickly and accurately, wherever they\nbelong.\n\n      Just for reference, the SMP/E language for this situation, in a\nsystem module context, is having multiple LMOD entries for a single\nMOD.  But we're dealing with application load modules here, and we have\nto do this job without the help of SMP/E and its record-keeping.\n\n      I sincerely hope that every one of you learns this technique.\nWith the Y2K situation looming over us, this technique is so\nimportant, that I cannot, in good conscience, neglect to teach it.\nYou might be able to easily fix a program, but replacing it wherever\nit is found in production processing, may be a far harder matter.\nNow, it doesn't have to be so hard.  You've just got to know how to do\nit right.  Good luck.  Please learn this technique well!  We'll see\nyou next month.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9810NV": {"ttr": 18692, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x98(\\x1f\\x01\\x00)\\x9f\\x11G\\x00\\xcb\\x00\\xcb\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1998-10-08T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 203, "newlines": 203, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         November 1998\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@aol.com or sbgolob@attglobal.net.\nDocumentation about the CBT MVS Tapes can be found on the web, at\nhttp://members.aol.com/cbttape .  The free PDS package can be obtained\nonline, at http://members.aol.com/freepds .\n\n\nEXPANDING YOUR HORIZONS\n\n      I think everybody in our business of systems programming will\nagree on one fact:  In order to do this job well, you have to know a\nlot!  How do you get to know a lot?  It doesn't just happen.  To know\nwhat we have to know, one has to make a concerted effort over a long\nperiod of time.  What I'm going to talk about today, is how to\nincrease the efficiency of making this effort, how to motivate yourself\nto continue, and how to have fun at the same time.\n\n      We systems programmers, like almost everyone else, learn things\non the job by being work-driven, rather than by being self-driven.  Of\ncourse, it's good to be learn everything you can from the tasks you've\nbeen assigned to do at work, but if it's supplemented by some of your\nown initiatives, it gives you a real edge.  You can get \"good\" much\nquicker.  It's also more fun, when you set your mind to learn something\nand then do it.\n\n      I'm very fortunate that at the beginning of my systems\nprogramming career, I had a teacher, and I'd like to spend the rest of\nthis column discussing his ideas.  His name is Jeff Broido, and his\noutstanding characteristic is that he is a very unselfish and\nconsiderate man, besides being excellent technically.  For three\nyears, even when we were working at different places, I'd call Jeff\nevery day and tell him what I did at the job.  Even when I felt I knew\nwhat I was doing, Jeff would tell me the history of the component, or\nsome background about the subject, that I hadn't known.  And if I\ndidn't know what to do, Jeff would, of course, enlighten me as far as\nhe could.  Having Jeff's influence early in my own career, inspired me\nto help other people also, as much as I could.  The fact that I write\nthis column, comes directly from Jeff's inspiration and consideration.\nIf you find this column useful, you all \"owe him one\".\n\n      Jeff had marvelous \"rules\" for a systems programmer to live\nby, and I'd like to share some of them with you.  His first and foremost\nrule, was that you should spend some time each day to learn something\nnew.  Usually, it was about a half hour.  We're all not kept \"103% busy\"\nevery day.  There's usually some \"lull time\", on many days.  That time\ncan be spent in the process of picking up some fact or technique.  For\nexample, Jeff himself once spent some of this time reading the ISPF\ntutorial panels, until he knew all of them.  Then, when he had a tricky\nediting job to do, he could do it in a short way, instead of taking all\nday to do it.  This gave him even more time to learn yet another thing.\n\n      The result of consistently applying Jeff's first rule is, that\ninstead of being \"103% busy\" all day, you get to average about\n\"50% busy\", most of the time.  Call it \"increased CPU capacity\", but\nwhatever it's called, it sure makes life easier.  After my first two\nor three years, I've spent most of my career being \"50% busy\" as a\nresult of this training.  All of my jobs got done on time, and\naccurately.  It pays to \"know stuff\".  But it pays more, to keep\n\"learning stuff\".\n\n      The thinking behind \"Jeff's first rule\" is to replace a pattern\nwith another, better pattern.  What's the first pattern, which\neverybody follows?  It's this:  \"Everyone has to learn just enough to\ndo the job that's expected.\"  So what do we all do?  (And I'm included\nin this.)  We're all panicky to learn just enough to get the job done,\nand then we relax and \"settle in\", which consolidates our newly-learned\nskills.  Then, when there's another job that again requires us to learn\nsomething new, we get panicky again, and then settle in again.  It's a\ncycle.\n\n      Jeff's first rule is to especially take time learning something\nnew each day.  This serves to break into our cycle during the \"settling\nin\" part, not letting it get too long.  The good part of the \"settling\nin\" process is that it strengthens our existing knowledge, but the bad\npart is, that if it gets too long, we aren't learning anything new,\nwhen we could have.  If we force ourselves, by creating the time to\nlearn something completely new every day, we become self-driven to\nexpand our horizons, rather than remaining purely work-driven.\n\n\nREADING MANUALS.\n\n      I have to admit that the process of reading manuals has changed\nsince the days when I learned this principle from Jeff.  In those years,\nall of the manuals were printed on paper.  Today, many of them are on\ncd-rom, and the information has to be read from a terminal screen.  In\nspite of these differences, however, much of Jeff's idea still remains\nlargely applicable today.  Jeff taught me how to absorb information from\nan entire manual, relatively quickly.\n\n      The process seems easy and innocent enough, yet there's a vast\ndifference between \"knowing about it\" and actually doing it.  In order\nto appreciate how really good this idea is, you have to actually do it\nseveral times.\n\n      When you have to learn a lot of things from a certain manual,\nhere's what you do.  Start at the beginning, and start turning the\npages, one at a time, spending about a second or two looking at each\npage, until you go all through the entire manual, from the beginning\nto the end.  For a 300 page manual, this should take about an hour.\nOnly afterward, do you start reading the things you're actually\ninterested in, in detail.  The difference that the \"initial hour\"\nmakes, is astounding.  A quick pre-knowledge of the material supplies\na perspective.  This includes a picture of how each topic relates to\nother topics, a glance at the technical terms and names used by the\nsoftware, and a general overview.  Presumably you've also spent a\nshort time looking at all the pictures.\n\n      After you've gotten the habit of doing this all the time, you'll\nfind that you can completely absorb new topics amazingly quickly.\nYou'll surprise your co-workers how much you know, without spending\nsignificantly more time reading, than anyone else does.\n\n\nUSE TSO.\n\n      I guess that this idea was more novel in the early days of MVS\nthan it is now, but it's surely just as applicable nowadays, maybe\neven more so.\n\n      In the earlier days of the OS operating system, batch jobs were\nthe \"way of doing most everything\".  To get the computer to do your\nbidding, you'd submit a job.  At one time, there was no choice.  Once\nTSO was invented though, its facilities eventually grew to the point\nwhere 90 percent of what we accomplish, can be done directly through\nour TSO terminal sessions, rather than by other means.\n\n      TSO has a few big advantages over batch jobs.  For one thing, you\ndon't have to grab a new initiator every time you want to do some task.\nYour TSO session has its own address space, and keeps holding on to it.\nFor a second thing, you don't have to wait for printing services.  The\nresult comes back right to your own screen, generally very quickly.\nThirdly, TSO greatly reduces the time that it takes to do short tasks,\nand you don't have to wait for the results.  It's true that for long\ntasks, batch operations are usually better, and they don't tie up your\nterminal.  But Jeff's point in this area is, that if you expand your\ncollection of TSO-based tools, and your skill with them, you'll soon be\noverjoyed how quickly you can get your work done, and how little batch\nwork you'll actually need.\n\n      In the late '70s, when handy TSO-based tools were not so\ngenerally available, Jeff taught himself how to write his own TSO\ncommand processors, which are what programs running under TSO are\ncalled.  By writing many assembler-based TSO programs to do his\ntasks, Jeff was able to make is working life far more efficient.\nNowadays, people would probably do most of this work in REXX, which\nof course, wasn't available then, although CLISTs were.  When one of\nus \"ordinary guys\" would watch Jeff work, it would \"blow our minds.\"\nHe had so many inventions, and he was so fast!\n\n      Some of Jeff's programs can be found on File 423 of the CBT\nMVS Tape, a huge collection of public MVS system programmer software\nthat's independently produced.  The NaSPA cd-rom contains a version of\nthe CBT Tape material that's updated once a year.  For the in-between\nstuff you can order a tape, or you look at my web site for information.\nWe're currently trying to find a web-based home for the intermediate\nupdates to the tape.  If you're a member of SHARE, you can go to the\nmembers-only section of www.share.org.\n\n      Nowadays, many of the tools that Jeff had to invent, are\nalready available on the CBT Tape, or in vendor-supported products, or\nthey can be downloaded from sites on the web.  There is a galaxy of\nTSO-based tools to make your work shorter.  I spend much of my time in\nthis column, describing some of them.\n\n      For example, if you learn to use the TSO-based UCLA Fullscreen\nZAP program (File 134 of the CBT Tape) instead of IBM's AMASPZAP\n(superzap) batch program, you'll see what you're doing much better,\nand you'll probably save a lot of time getting the work done, too.  If\nyou install and learn the TSO-based free PDS program package, on File\n182 of the CBT Tape and now on the web (http://members.aol.com/freepds),\nyou'll do lots of your jobs more quickly, saving perhaps 90 percent or\nmore, of the time you used to take.  (If your shop is licensed for the\nvendor product called STARTOOL from Serena in Burlingame, California,\nwhich is an outgrowth of free PDS, you just have to learn STARTOOL.)\nIf you've installed the single load module (from File 183 of the CBT\nTape) called SHOWMVS in your TSO/ISPF session, you'll be able to learn\nmore about your system in five minutes, than EDP auditors used to be\nable to find out in several hours of digging.  The \"unofficial\" IBM\nprogram called TASID, written by IBM'er Doug Nadel, which you can\ndownload from the web, will also supply much of this information.\n\n      Spending a half hour a day, just about every day, in learning\nsuch tools, will pay you back in much more available time, so you can\nlearn even more.  That can make a difference between being just\n\"good\", and being a real \"crackerjack\" at this trade.  The half hour\ncould be spent installing a new tool from the CBT Tape or elsewhere.\nIt could be spent reading a manual (in Jeff's \"efficient\" way).  Or if\nyou do something, anything, to expand your horizons, you've done a\nvery very positive thing.  You've helped yourself.\n\n      Good luck.  See you next month.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9811DE": {"ttr": 18696, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x986\\x1f\\x01\\x00)\\x9f\\x11G\\x00\\xf5\\x00\\xf5\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1998-12-27T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 245, "newlines": 245, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         December 1998\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@aol.com or sbgolob@attglobal.net.\nDocumentation about the CBT MVS Tapes can be found on the web, at\nhttp://members.aol.com/cbttape .  The free PDS package can be obtained\nonline, at http://members.aol.com/freepds .\n\n\nSETTING YOURSELF UP\n\n      Every experienced systems programmer wants to have as many tools\navailable as possible, ready to use.  If you've been at the same shop\nfor a long time, you've probably already set yourself up with special\nprograms and gadgets (the kind of things we talk about in this column)\nso you'll be able to do your work more quickly and easily.  The whole\n\"kit and caboodle\" of your favorite tools has been installed, tested,\nand is accessible to your userid, ready to be deployed at an instant's\nnotice.  However, if you're new to a shop, or you're a consultant who\nhas to travel often from one shop to another, setting yourself up with\nan appropriate set of tools can be a chore.  For a long while, you\nmight feel yourself handicapped because you can't use the wonderful\nwork-saving tools you're familiar with.\n\n      Today we'll say a few things about how to set yourself up\nquickly.  I have my own experiences in doing this, and I'd appreciate\nif the readers would email me and tell me some of their experiences\ntoo.  My teacher Jeff Broido has been a consultant ever since I've\nknown him, and his clever inventions enable him to set himself up\nanywhere, at any shop, within one to several days.\n\n      There are several considerations that come in.  You, as a\n\"system doctor\", need to do more privileged things than the average\nuser.  Most times, the shop will give you a \"system programmer's id\",\nwhich is a TSO userid that already has what they deem to be enough\nextra privileges built in, so you can do your special job.  Other\ntimes, a shop will not \"trust\" a consultant, and they might even\nhandicap him (or her) by giving out a userid that has little more than\nan application programmer's power.  Then they'll expect the consultant\nto do the \"system doctor's job\" just the same.  Consultants often have\nto deal with such politics, under such conditions, and sometimes it's\nbetter to be able to do your job, quietly and efficiently, without\nbutting heads with management more than necessary.\n\n      In doing the process of \"setting yourself up\", there are various\nthings in your TSO environment that you'll have to alter.  Since you're\nspecial, you'll want to change the average TSO user's parameters as\nlittle as possible--preferably not at all.  For example, you'll want to\navoid public PARMLIB changes if you can.  There are a few shops that\nrequire several \"manager signoffs\" to change just one PARMLIB member.\nOften, if you know some tricks, you can quietly achieve the same result\nfor yourself (on your own userid) as if you changed something in\nPARMLIB, but you don't have to do it \"for the public\".  To me, this way\nis greatly preferred.\n\n      So let's see what we need to do, under various degrees of\n\"management restraint\".  I can't say that I have the final word on the\nsubject.  I don't know everything--that's why I want your email input.\nBut we'll talk about the subject in general, and I'll discuss some\npointers here and there.  There are really really two divisions to this\nsubject.  Number one is:  \"How do you set up your own TSO environment\",\nand number two is:  \"What do you take with you and how do you package\nit?\"\n\n      Finally, no discussion of MVS tools is complete, without mention\nof the wonderful world of free MVS tools and utilities.  The granddaddy\nof free tool collections is the \"CBT MVS Utilities Tape\", together with\nthe \"CBT Overflow Tape\".  The CBT Tapes are independently produced, and\nare not subject to the restrictions of any organization.  Some of the\ntools found there have no equal, even among vendor products.  I write a\nlot about materials from the CBT Tapes in this column, because they are\nfree, and any shop can use the tools.\n\n      Where can you get the CBT Tape materials?  NaSPA incorporates a\nversion of both CBT Tapes into its cd-rom collection, which is\ndistributed annually.  The CBT tape itself is updated more frequently,\nnowadays it's every few months, but it can be more often.  For a long\ntime, NaSPA has played a giant role in the distribution of the CBT Tape\nmaterials on tape and cd-rom.  Now, NaSPA is also sponsoring a web site\nwhich has all the latest CBT materials downloadable, ready to be\nsupplied when needed, on instant notice.  I prefer to have all sources\navailable.  I can take a cd-rom or a tape wherever I go.  They're\nportable.  I don't need Internet access to use them.  The cd-rom and\ntapes don't require lengthy downloads.  The cd-rom source files are\nreadable in ASCII, on a pc.  The tapes and the web site materials are\nin EBCDIC.  On the web site, the files are pkzip'ed and in TSO XMIT\nformat.  You upload a file to the MVS system after unzipping it, and\nyou do a TSO RECEIVE on it, so it's completely MVS-ready.  Each medium\nhas its own advantages, and it's nice to have them all.  The\nNaSPA-sponsored web site is at http://www.cbttape.org .\n\n\nMODIFYING YOUR TSO ENVIRONMENT.\n\n      Now we'll get started on the subject.  I'd say that one\nthing you should ask for, when going to a new shop, is the ability\nto use your own logon procedure in a system PROCLIB.  If you can do\nthat, and you have update access to an authorized load library, you're\nin full business.  Copy the normal systems programmer logon procedure\nto your own named one.  Check carefully what's already in the\nauthorized library, and if you don't see anything there that might\ninterfere with your TSO session, add it as a STEPLIB ddname, with\nDISP=SHR of course, to your own logon procedure.  You've got to be\nvery careful who else uses the authorized library.  You shouldn't put\nanything else in there that would mess someone's work up.  It's best\nif you have your own systems programmer authorized library, so you\nstay out of everyone's way.\n\n      The IKJTABLS load module will completely override the IKJTSOxx\nparameters in PARMLIB if its load library is known to a TSO session as\nan authorized STEPLIB.  Remember that even if this authorized library\nis used as an ISPLLIB by other people, the overriding of IKJTSOxx in\nPARMLIB will not occur for them.  Authorization under STEPLIB will be\nruined if there is a non-authorized library in the STEPLIB\nconcatenation, so be careful that all the libraries in the STEPLIB of\nyour logon proc, are authorized, and omit the ones that aren't.  If\nISPF is involved in your work, consider whether the deleted libraries\ncould be included in your ISPLLIB concatenation.\n\n      I'm a big believer in removing as much JCL (that is, DDNAMEs)\nfrom the logon proc as possible, and instead, allocate your files\nvia the initial logon CLIST or REXX exec.  If one of the datasets is\ngone from the system, if it's inaccessible or it was renamed, you can\nstill have a TSO session, and you can make a different CLIST to\nrecover and get to work.  If the dataset that disappeared was part of\nyour logon proc JCL, your TSO session will fail on a JCL error, and\nyou won't have a session at all.  It's much safer to get your files\nvia the TSO ALLOC command rather than with logon proc JCL.  So get a\nsample logon CLIST ready for insertion into your SYSPROC concatenation\nunder TSO.  When you go to a new shop, just change the dataset names.\n\n      My teacher Jeff Broido carries a tape with him, containing all\nthe personal libraries with his own stuff.  After he loads these\ndown to pds'es on a new system, he customizes his TSO allocation\nCLIST to put them into his TSO session in the right places:  ISPPLIB,\nSYSPROC, ISPLLIB, ISPMLIB, and so forth.  It doesn't take too long.\n\n      Jeff doesn't like to use his personal programs if he hasn't\nassembled them at the new shop.  For this purpose, he wrote a CLIST he\ncalls %A, which assembles a program from one of his source libraries in\nthe foreground, under TSO.  If the program isn't extremely long, the\nSYSTERM result comes back to his terminal in a relatively short time.\nIn a couple of minutes, Jeff can reassemble and re-linkedit quite a few\nof the programs he relies upon for his daily work.  This procedure\nsaves a lot of time when he's setting up.\n\n\nSETTING UP YOUR OWN ISPF COMMAND TABLE ENTRIES\n\n      Your own personal ISPF command table entries can make life much\neasier.  If you make a personal version of the system ISPF command\ntables, especially the ISPTABL, or ISRTABL members, depending on how\nyour shop is set up already, you can save yourself a lot of work\nlater.  Among other additions to the normally supplied table entries,\nI like to set up a way to instantly get any standard IBM ISPF panel\nwhenever I want it.  For example, I'll pick a little-used command\nprefix, say SP.  Then, if I want an instant ISPF 3.1 screen, on top of\nanything I'm doing--say I'm in the middle of editing a file--I just\nenter SP31 on the command line, and the ISPF 3.1 screen pops up on top\nof my edit.  I'll use the ISPF 3.1 screen to do what I want, and then\nI'll end it, and go back to editing my file.  I like to set these up\nfor all of the standard ISPF functions.  How can we go about doing\nthat?\n\n      There are two table library DDNAMEs in your ISPF dataset\nconcatenation.  The ISPTLIB concatenation contains ISPF tables which\nare read-only.  Your ISPF session will recognize these and use them.\nThe updates to tables are done in a pds which is in the ISPTABL DDNAME\nconcatenation.  If you want to update a table, using ISPF 3.9, your\ntable must be a member in a library that is allocated to the DDNAME\nof ISPTABL.  Suppose you want to update the system member ISPTABL\nwhich everyone uses.  You want to add command table entries to it,\nthat only you want to have.  What do you do?  You shouldn't or\n(depending on the version of ISPF you have) can't edit the system\nISPTABL or ISRTABL member directly.  You can make a copy of the\nsystem ISPTABL member, for example, into your own table library pds,\nand call it some non-system name, ending in ..TABL, such as XSPTABL.\nThen you do ALLOC FILE(ISPTABL) DA(your.table.dataset) SH REUSE, and\nafterwards get into ISPF 3.9.  When the screen asks you which table you\nwant to edit, you say XSP.  The system will supply the suffix of ..TABL\nfor you, and you'll be able to see the system table entries, one by\none.\n\n      Now we want to be able to specify special commands to invoke\nstandard IBM ISPF screens, as we said before.  With ISPF 3.9, editing\nXSP on one split, invoke the main menu on the other split, and enter\nthe PANELID command on the command line of the second split.  You'll\ninstantly see the member name of the displayed ISPF panel at the upper\nleft corner of the second split screen.  Go browse the panel library\nwhere this member is contained, and look at the member.  You'll see,\ntoward the bottom of the member, all of the SELECT statements which\ninvoke the different ISPF functions.  Then you copy them as additional\nentries to the XSPTABL command table, on the ISPF 3.9 screen that's\nin the first split of your session.  For example, to add a command\ncalled SP0, which invokes the ISPF 0 screen, look at the select\nstatement of the ISR@PRIM panel (or whatever the name of the main\npanel is at your site), which specifies the command \"0\".  Copy the\nname SP0 into a new line of your ISPF 3.9 split, specify 0 characters\nso the command can't be abbreviated, and then copy the SELECT\nparameters exactly from the ISR@PRIM panel into the ISPF 3.9 screen,\nexcept for the enclosing quotes.  Do the same for all the other\nISR@PRIM screen options.  For 3.1, 3.2, etc., go look at the ISRUTIL\npanel (or whatever name that PANELID specifies for ISPF 3) and get\nthe select statements from there, to make commands SP31, SP32, and\nso forth, all the way up to SP314.\n\n      When all the additional entries are complete, get out of ISPF 3.9\nwith PF3 (which automatically updates and saves the member XSPTABL).\nCopy XSPTABL to your own partitioned dataset, as ISPTABL.  Then\nallocate this personal table library dataset to the top of your ISPTLIB\nDDNAME concatenation.  Get out of ISPF and back into ISPF.  Lo and\nbehold, all of your new table entries will be usable.\n\n      If you don't want to go to all of this trouble every time you\nchange shops, Gilbert Saint-flour might have just the solution for you,\non File 183 of the CBT MVS Tape, which contains a lot of his programs.\nThe program we can use is called FASTPATH.  Gilbert made the FASTPATH\nprogram, which need not be authorized, to do all of the setups\nnecessary to customize most of his own ISPF session to his own taste.\nYour requirements may be different, so you can go into the source code\nfor FASTPATH, customize it to your own needs, and behold!  You'll have\nyour own customized ISPF session initializer.\n\n      Before ending, I'd like to mention one of Gilbert's other\nprograms from File 183 of the CBT Tape.  This program is called\nSHOWMVS, and it's a system programmer's (and EDP auditor's) dream.\nWith just one invocation of the SHOWMVS load module as a TSO command,\nyou'll get so much information about your system and your own TSO\nsession, that you probably won't need much more.  There's a load\nmodule for SHOWMVS on File 135 of the CBT Tape, and you can pop it\ninto one of your ISPLLIB libraries and try it.  If you haven't seen\nit yet (or even if you have), you'll be amazed at how it's been\nimproved.  SHOWMVS will be able to show you so much about your\nsystem and your TSO session, as it currently is, that when you walk\ninto a new shop, it'll be just that much easier to further customize\nyour session and set yourself up.  Good luck.  See you next month.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9901JA": {"ttr": 18945, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x986\\x1f\\x01\\x00)\\x9f\\x11G\\x00\\xf6\\x00\\xf6\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1998-12-27T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 246, "newlines": 246, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          January 1999\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@aol.com or sbgolob@attglobal.net.\nInformation about the CBT MVS Tapes can be found on the web, at\nhttp://www.cbttape.org   \"Sponsored by NaSPA\", and at\nhttp://members.aol.com/cbttape .\n\n\nCBT Tape Support Online\n\n      Today I'd like to introduce you to an important new facility\nand to place it in perspective, in relation to existing facilities.\nThis facility is the new online \"home\" of the CBT MVS Tape files:\nhttp://www.cbttape.org \"Sponsored by NaSPA\".  While www.cbttape.org is\nintended to serve MVS systems programmers all over the world, it is\nnot intended to supersede the CBT Tapes (as tapes) or the NaSPA cd-rom\ndisks.  Each of these has its own proper place, not interfering with\nthe usefulness of the others.  In this month's column, I hope to\nexplain how to make good use of all of them.\n\n      Let's start with a little history.  Since the beginning days of\nthe MVS Operating System, and throughout the heyday of its predecessor\nMVT, collections of \"system mods and utilities\" were prevalent, useful,\nand necessary.  IBM's system design and programming efforts, while\nenormous, could never be so thorough and pervasive, as to satisfy every\ninstallaton's needs.  IBM operating system designers were the first to\nrecognize that fact.  Furthermore, if they themselves didn't recognize\nsome need, it was usually pointed out to them by members of user groups\nlike SHARE, GUIDE, and others.  IBM therefore deliberately left many\nMVS system interfaces open for user development and customization.  In\nearlier times, IBM also made most of the operating system source code\npublicly available.  Thus, if IBM themselves didn't \"get around to\nfilling some need\", often the users themselves wrote their own code,\nand solved the problems.\n\n      We now come to the question of how \"user-written code\" would be\nspread to systems programmers at other installations.  Back in the MVT\ndays, there were lots of \"system mods tapes\" that served as forums for\nexchanging user-written code.  One of these forums was the famous\n\"Michigan Mods Tape\" for the MVT operating system.  Shortly after MVS\nwas released in 1975, Arnold Casinghino, who worked at the Connecticut\nBank and Trust Company in Hartford, CT, started a similar tape, to\ncollect and distribute newly-written user modifications for the MVS\noperating system, and to carry over many of the MVT modifications so\nthey'd work on MVS also.  Arnie pursued this project for many years,\nwith enormous dedication and attention to detail.  His collection became\nknown as the \"Connecticut Bank and Trust Mods Tape\", or \"CBT Tape\" for\nshort.  The CBT Tape has become the original source for many utilities\nthat are \"floating around\" in many MVS and OS/390 installations\nthroughout the world.  Probably most of the system programmers who've\nused and modified those utilities, don't have a clue as to where they\noriginally came from.\n\n      What can happen with user-written programs?  When IBM changes\nthe level of the MVS operating system, sometimes a user-written program\nwill continue to work, and sometimes it will have to be changed a bit,\nto function as before.  When a user-written program is changed to adapt\nto the newer MVS environment, the source code is almost always fixed\ntoo.  Most user-programs on the CBT Tape come with complete source\ncode.  Often, the person who fixes some user code for a later version\nof the MVS system, will send the fixes back to the proprietor of the\nCBT Tape or whatever other collection it came from.  In that way, the\npublic has a chance to get access to the new code, and they also can\nadd their own improvements.\n\n      There's also another side to this process.  From looking at\nuser-code, people can get to learn assembler language.  There's a\ntrend nowadays in systems programming which I call the \"vendorization\nof system utilities\", or to put it more bluntly, \"the unintentional\nencouragement of system programmer ignorance\".  While software vendors\nare constantly churning out helpful program packages which we take\nadvantage of, they tend to hide their source code, so we can't use it\nto learn how the system works.  Also IBM, with their \"object code\nonly\" or \"OCO\" policy that restricts access to much of their own\nsystem code, systems programmers are getting blocked from access to\nknowledge of system internals.  To top that off, there's a general\ntendency in the MVS world, to go away from system customization.  It\nmakes system upgrades easier if there aren't so many \"user mods\", as\nthe saying goes, and this is true.  All of these trends are working\ntoward making systems programmers into mere \"installers\" who don't\nknow how to program, and who don't really know how most of the\ncomponents of the system work.\n\n      Having access to source code for system utilities, is a great\nforce to counter this trend toward \"system programmer ignorance\".  It\nalso serves to make system upgrades easier, and not harder.  I'll\nexplain how.\n\n      During a system upgrade, \"tech support management\" is sometimes\nput under great pressure from a group of users, to upgrade a certain\nuser-written program that the users \"can't do without\".  I've seen\nsituations where the tech support management wants to cook up an\nanswer that \"the utility isn't available any more\", but the users won't\nhear of it.  They send management the ultimatum that \"if we can't have\nthat utility, we're not going to let you upgrade!\"\n\n      I don't wish to discuss politics, but sometimes there is an\nanswer that'll solve everything, and help our management to save face\nunder the user pressure.  Often, the original source of the utility in\nquestion was the CBT Tape, or one of the other collections.  There were\nother shops which had faced a similar situation in the recent past.\nThe utility had also stopped working for them.  Someone at that shop\nwent through the trouble to fix the utility, and they were considerate\nenough of others, to send the fixes back to the proprietor of the\n\"software collection of origin\".  If an installation that's trying to\nupgrade, has a way of easily knowing about fixes to user-written\nutilites, it solves many of their system upgrade problems.  All they\nneed do, is to install a later version of the utility in place of the\nold version that no longer works.\n\n      That's where newer versions of the CBT Tape come in, and that's\none of the main purposes of www.cbttape.org.  The CBT Tape (and the CBT\nOverflow Tape for that matter) are upgraded quite often.  New versions\ncome out several times a year.  If you're busy upgrading a system, and\nyou're looking for the latest \"fixes\" to one of your favorite user\nprograms, you can now search for, and find these materials online,\nwithout having to wait for a new CBT Tape to be shipped to you.\nwww.cbttape.org is connected to an ftp site that has all of the newest\nCBT Tape files online and ready to be downloaded.  These files do not\nrequire ASCII <---> EBCDIC translation.  They're in EBCDIC already.\nAll the files from the latest \"CBT Overflow Tape\" are there too.  The\nwww.cbttape.org site additionally gives you access to CBT Tape version\n249, from 1985, which contains source for many user programs that can't\nbe found nowadays.  If the installation has lost the original source\nfor one of their programs, the CBT249 \"ancient source code\" files will\nhelp them find them the original code that they can start fixing for\nthemselves and for others.\n\n\nHOW DOES www.cbttape.org COMPARE WITH \"REAL TAPES\" AND THE NASPA CD-ROM?\n\n      I'm still a big advocate of having a physical CBT Tape in your\npossession.  It's nice to have it \"all there\", and not to have to\nspend time downloading files over the Internet.  However, the CBT\nTape is updated quite often.  This year alone, there were over 100\nsignificant changes.  Practically speaking, you can't order a new tape\nevery time one comes out.  You can try to get a recent one, but it's\nnice to be able to get to the updated files if you need them.  Therefore\nif you've got a recent tape, supplemented by access to www.cbttape.org,\nyou're well covered.\n\n      Enter the NaSPA cd-rom.  The cd-rom files are IBM PC-oriented,\nand most of them are meant to be loaded to a pc hard drive, unzipped,\nand then uploaded to the mainframe using ASCII to EBCDIC translation.\nThis cd-rom is big in capacity.  It contains more material than just\nthe CBT Tape and the CBT Overflow Tape files.  There's the NaSPA VIP\ntape materials and lots of other stuff too.  And it's all in one very\nsmall package, available to be carried around on trips, or wherever\nyou're going.  The fact that the source code on the cd-rom is\nrepresented in ASCII helps you read it on a pc.  You don't need a\nmainframe to use the materials.\n\n      Here are some disadvantages of the cd-rom.  Some special\ncharacters are distorted during ASCII to EBCDIC translation, and when\ncertain source files, especially REXX execs, are uploaded to the\nmainframe, they may not be accurate.  The cd-rom is only updated once a\nyear, whereas the tapes and the web site are kept up-to-date.  Thus,\nwithout the web site, you might lose some of the latest utility support\nfor the newest systems.  A physical tape doesn't need ASCII to EBCDIC\ntranslation, whereas the materials on the cd-rom usually do.\n\n      Then again, the physical tapes, even the newest ones, have\ndisadvantages too.  One physical tape doesn't contain all the materials\nin the CBT Tape, the CBT Overflow Tape, the NaSPA VIP tapes, and the\nrest, which the NaSPA cd-rom contains in one small self-contained unit.\nIt comes out that both the physical tapes, and the cd-roms are\nnecessary, but they both have disadvantages that www.cbttape.org is\ndesigned to alleviate.  I'd say that www.cbttape.org should best be\nused as a supplement to the other two mediums, to make up for the\ndisadvantages of both of them.  Furthermore, www.cbttape.org provides\ncrucial program support whenever you need it, during odd hours when\nyou're upgrading or fixing your system.\n\nWHAT MATERIALS ARE AVAILABLE?\n\n      Regular readers of this column will have a very good idea of\nhow much your \"system programming lifestyle\" can be enhanced from\nusing tools and materials from the CBT Tapes.  I write about this stuff\nhere, every month.  But the free materials in the tapes are so vast,\nthat I can't even scratch the surface of what's available, in what I\nwrite.  You have to search the tapes for yourselves.  For this reason,\nI'd like to say a few words about how to search.\n\n      The TAPEMAP program from File 299 of the CBT Tape, when run\nagainst a CBT Tape itself, will report all member names of all pds'es\nin all the files, in its second report, using its SYSPRNT2 ddname.\nYou can write this report to a disk file.  I usually designate a pds\nthat has LRECL=133, RECFM=FB or FBA, for the purpose, and copy TAPEMAP\nreports to members of this pds.  Then I search the reports for a given\nmember name, and find all occurrences of the name, in all files on the\ntape.  I can then load those files to disk, and see if they have what\nI want.\n\n      Another piece of advice is to write the 32000-odd lines of CBT\nTape documentation which is on File 001 of the tape, to disk, and\nsearch that documentation for whatever type of material you're looking\nfor.  Sometimes that search will lead to paydirt, too.  Experience\ntells me that both methods are sometimes needed, and they aren't 100\npercent sure-fire.\n\n      For example, suppose you want a coding example for an IBM open\nexit, IFG0EX0B.  A search through the second TAPEMAP report will yield\nall occurrences of pds member names which match IFG0EX0B.  However, if a\ncoding example for this exit routine is not called IFG0EX0B in the tape\nfile, you won't find it.  Using the other method, looking at the tape\ndocumentation file, File 001, you're depending on the thoroughness of\nthe documentation.  Sometimes, a contributor of a file will have a code\nexample of this exit in his collection on that file, but whoever wrote\nthe description in File 001, neglected to mention that an IFG0EX0B\ncoding example is included there.  Either way, the search can fall\nthrough the cracks and not find something, even if it is there.\nHowever, you still have to try, and often you'll find what you want.\n\n      Sam Knutson, the webmaster of www.cbttape.org, is now working on\na writing a search engine to help you find materials which are archived\nat the ftp site.  As the facilities at the web site are improved, you\nshould find the site more and more useful.\n\n      Currently, the contents of the files at the ftp site are\nvery complete, and if, for example, you need to download a copy of\nthe latest version of free PDS 8.5 (from File 182), or some of its\nsupplementary utilities (from Files 296 and 112), or of SHOWMVS from\nFile 183, very recent versions of these files are always kept posted.\nThese are just a few examples of many.  You can use www.cbttape.org to\nkeep your installed free utilities always up to date.\n\n      The site at which all of these materials are archived, is, to\nmy knowledge, \"guarateed to be up\" 24 hours a day, 7 days a week.\nAt least it's supposed to be very reliable, and very available.\nThere's also supposed to be quite a bit of redundancy there, so you're\nvery well supported, even at odd times, when you need the support the\nmost.\n\n      Good luck in all your endeavors.  Technology is getting better,\nand user-code support is getting better and better too.  I'm sure\nthis new facility will help you.  See you next month.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9902FE": {"ttr": 18950, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x986\\x1f\\x01\\x00)\\x9f\\x11G\\x00\\xed\\x00\\xed\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1998-12-27T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 237, "newlines": 237, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         February 1999\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@aol.com or sbgolob@attglobal.net.\nInformation about the CBT MVS Tapes can be found on the web, at\nhttp://www.cbttape.org   \"Sponsored by NaSPA\", and at\nhttp://members.aol.com/cbttape .\n\n\nResource Affinity Implementation Efforts\n\n      Nowadays, as before, MVS shops come in all sizes.  But it's\neven more common nowadays than before, with parallel processing\nand sysplexes, to have multiple MVS images working together at one\ninstallation.  Where it would formerly suffice to have one big MVS\nmachine, nowadays it's more likely that there are two or more MVS\nimages running as a sysplex.  As we all know, there are advantages\nin reliability and scalability when we have more than one machine\nrunning.  But there could also be management and licensing\nheadaches, and those have to be handled too.\n\n      Under these conditons, it sometimes happens that a certain\nresource, for example a database, is attached to one MVS image in\na sysplex, but not to another.  Any job that uses this resource\nmust run on the MVS image that the resource is attached to.  If it\nruns on another MVS by mistake, it will have to fail.  Since the\napplication programmers aren't normally responsible for the\nhardware and software setup at an installation, the principal task\nfalls on systems programming and operations to make sure that each\njob will run on the correct machine.\n\n      The traditional and ancient method of controlling the\naffinity of a batch job to a given machine, relies on the Job Entry\nSubsystem (JES2 or JES3).  In the JCL on the JOB card, the user can\nspecify initiator types, say CLASS=I initiators, which have been\nstarted on System A, but which haven't been started on System B.\nAs long as there are no CLASS I initiators started on System B,\nCLASS I work will not run there.  The method is simple and it\nusually works, but it's static.  In a more complicated resource\nscenario, we'd want to have a better way.\n\n      There are other ways of controlling which machine a job will\nexecute on, such as a JES \"/*ROUTE XEQ\" card in the JCL, that goes\nbelow the JOB card.  The \"native JES2\" ROUTE XEQ card (as opposed\nto the ROUTE XEQ card when the \"Mellon Mods\" or other user\nmodifications have been applied to JES2) is quite limited, and is\nnot granular.  It just specifies a JES2 node the job should run on.\nBut that method of control helps too.  Every additional mechanism\nwill help in some way.\n\n      But what if tech support management has determined that a\nresource must be moved from System A to System B?  All of the\nprogrammer JCL will have to be changed, on the \"big day\" when the\nmove will take place.  A commotion will take place among the\nprogrammers.  It's generally quite painful to force programmers to\nglobally change a lot of JCL.  Changing \"application programmer JCL\"\nis a practice which has to be avoided, if possible.\n\n      What would be a more ideal situation?  It would be nice if\nprogrammers would be given a name of an \"environment\" that's\n\"healthy\" for a job to run in.  They'd code this environment name in\ntheir JCL.  Then it would be transparent to them, on which system\nthese jobs actually ran.  The programmers wouldn't have to think\nabout it any more.  JCL would never have to be changed.  Tech support\nwould get this responsibility, which is really in their domain anyway.\nTech support would set up the \"scheduling environments\" properly.\nAnd each job that needed special resources, would run correctly in\nthe proper place and the proper time, with each resource being \"up\"\nor \"down\", as determined by the scheduling environment.  If a\nresource were moved from System A to System B, the programmers would\nnever hear about it.  Only the scheduling environment definitions,\nwhich are done by tech support, would have to be altered.\n\n      This may sound like a more ideal world, but IBM has actually\nbegun implementing it through the workload manager component, WLM.\nA new keyword, SCHENV=, which supports a \"scheduling environment\nname\" in the JOB card, has been added, provided that the\ninstallation will implement the new system.  Support for the SCHENV=\nkeyword has been introduced into JES2, JES3, and the MVS converter,\nto consider this keyword as valid parameter.\n\n      However, at this point in time, supporting WLM Resource\nAffinity Scheduling is not simple.  It's IBM's \"first cut\" in\ndeveloping the facility.  The individual installation has to do a\nlot of work to get the WLM resource scheduling mechanisms to\nfunction as they want.  It is necessary to have an automated\noperations package running, as well as having a WLM policy in effect\n(not necessarily in goal mode).  And all MVS images in a sysplex\nwhere WLM Resource Affinity Scheduling is to be implemented, have to\nbe running OS/390 Release 2.4 or higher.\n\n      Nevertheless, many of us feel that we are moving in the right\ndirection.  Most shops which need such services, are running\nhome-grown packages, or are doing makeshift procedures to work around\nthe fact that a supported Resource Affinity controlling mechanism for\njobs, started tasks, and CICS transactions hasn't been there.  The\nMellon Mods to JES2, which are available on the JES2 SHARE Tape, have\nalso provided a lot of flexibility in this direction for those shops\nwhich run them.  But the Mellon Mods highly modify JES2, and as of\nthis writing, they are only supported up until OS/390 Release 1.3.\nIt is a great relief that IBM itself is finally addressing the\nproblem of Resource Affinity control, and that there finally exists\nan IBM-supported mechanism which we can convert to.\n\n\nCONVERSION TO WLM RESOURCE AFFINITY SCHEDULING\n\n      My friend Bob Break, of St. Louis, Missouri, is highly\ninvolved in Resource Affinity Scheduling issues.  Bob works for a\nvery large shop, and he is an expert in JES2 internals.  (Several\nmonths ago, we mentioned in this column that Bob wrote a dynamic\nJES2 exit loader program which can be obtained online at\nhttp://members.aol.com/cbttape, and which can be found on File 198\nof the newer CBT Tapes - Version 418 or later.)  Bob's shop is so\nlarge, that resource affinity (which job will run on which machine)\nhas to be automated.  To accomplish this, Bob wrote a home-grown\npackage, called PRO.  PRO allows the detailed specification of each\njob's resource requirements in the JOB card, through the use of\n\"symbolic job classes\", which Bob invented.  Bob's \"PRO\" package is\ncomplicated, and it only runs at his shop--nowhere else.\nNevertheless, I'll describe the externals of PRO here, so we can\nbetter understand the problem of conversion to WLM Resource Affinity\nScheduling.\n\n      The main feature of PRO is support of \"symbolic job classes\".\nThe user at Bob's shop will code CLASS=xxxxxxxx (from 2 to 8 letters)\nin the JOB card, if the job has special execution requirements.\nThat's different from the normal job classes, which are limited to\nonly one character.  The ordinary jobs, which can run anywhere, are\nsubmitted with a normal, one-character job class coded.\n\n      This is what PRO does:  PRO includes a JES2 job card exit\n(Exit 2), which does two things.  First, the exit parses the CLASS=\nkeyword parameter to see if it has more than one character.  If the\nuser has coded one character, that's regarded as a normal job class.\nIf the CLASS keyword has 2 or more characters, the exit validates it\nagainst an installation-defined table, and converts it to a\none-character job class under the covers, so the MVS converter is\nsatisfied.  Also, the exit saves the symbolic jobclass name, which\nreally signifies an execution environment, in a job-related JES2\ncontrol block for later retrieval (I think it gets saved in the JQE).\n\n      All initiators at Bob's shop are drained by default.  The\nshop's automation package (OPS/MVS) is signalled by PRO that the job\nwants to execute.  OPS/MVS sets up the proper execution environment\nfor the particular job, using the requirements specified by the\nsymbolic jobclass name, which PRO has retrieved from the JES2 control\nblock.  Then, OPS/MVS makes sure the proper resources are available,\nand starts up an appropriate initiator on the proper system.  When\nthe job has finished running, its initiator is drained again.  All\nof this is done automatically, and transparently to the user.\nThat's roughly how the system works.\n\n      To convert this system to WLM Resource Affinity Scheduling,\nBob's shop set up WLM scheduling environment names, to match the\nexisting symbolic jobclass names.  The WLM scheduling environment\nwas installed in parallel to the existing scheduling environment.\nSince WLM knows nothing about PRO's symbolic job classes, the WLM\nsetup had to be done from scratch.  OPS/MVS had to be programmed\nto handle the WLM information, as well as PRO's information.  The\ntwo systems were thus set up to run in parallel.\n\n      In other words, once WLM Resource Affinity Scheduling was\nset up, the SCHENV= keywords, using the same names as the CLASS=\nkeywords (if they are symbolic jobclasses), should have the same\neffect.  Bob wrote a JES2 converter exit (Exit 6), which\nautomatically converts a symbolic job class name, if one exists,\nto a WLM scheduling environment name.  Exit 6 fills in the value\nin the SCHENV= keyword, turns off the PRO controls, and sends the\njob on.  With this in place, the old JCL will still work.  But\nWLM Resource Affinity Scheduling will now supervise where and how\nthe job will run, instead of PRO.\n\n\nCONVERSION FROM THE MELLON MODS\n\n      Shops that run the Mellon Mods to JES2 will use extensions\nof the normal /*ROUTE XEQ card to support (it's brand of) resource\naffinity scheduling.  The Mellon Mods allow the shop to specify an\nexecution environment name in the ROUTE XEQ card, instead of merely\na node name.  These special execution environment names are stored\nin an internal table, and are used to set up the job properly, to\nrun on the appropriate MVS image where the resources are.  In other\nwords, the Mellon Mods allow the coding of installation-specified\nnames similar to PRO's symbolic jobclass names.  So the conversion\nto WLM management should be similar in method, but different in\ndetail.\n\n      If a shop running the Mellon Mods is to be converted to WLM\nResource Affinity Scheduling, an automated operations package has\nto be in place, and the WLM scheduling environment names have to be\nset up, so they match the Mellon execution environment names.  The\nWLM Resource Affinity Scheduling environment has to be set up in\nparallel to the old environment.  Finally, JES2 exits have to be\nwritten to transparently convert the /*ROUTE XEQ environment names\nto SCHENV= keywords.  Bob Break has done this JES2 exit writing for\nyou.  Bob has coded a JES2 JECL exit (Exit 4) and a JES2 converter\nexit (Exit 6), to transparently convert ROUTE XEQ names to SCHENV=\nkeywords.  Bob's exits will soon be available on the CBT Tape\n(Version 420), but if you can't wait that long, they'll be posted\non http://members.aol.com/cbttape, so you can download them.\n\n\nWHAT'S IN IT FOR THE REST OF US?\n\n      To those of you who aren't running the Mellon mods (which is\nnearly all of us), what is the value of this discussion?  First,\nit informs us that IBM is actually starting to develop a supported\nway of controlling when and where a job will run, so it gets the\nrequired resources it needs, in the proper state (up or down), at\nthe proper time.  Second, if your shop already has such a system,\nalbeit home-grown, we've discussed possible conversion paths.  If\nyour own resource affinity job scheduling system is driven by\ninstallation-defined names, JES exits can be written to transparently\nchange these names to SCHENV= keywords, so the global JCL change\nimpact will be softened.  Your old JCL will actually feed the work to\nthe new WLM controls.\n\n      Third, the new WLM-controlled system promises to allow resource\nscheduling of CICS transactions and other system work, as well as\nbatch jobs.  If you're interested in finding out more, you should\ncontact your IBM representatives for the latest available literature,\nas WLM Resource Affinity Scheduling is improved and developed further.\nBob Break can be reached at bbreak@swbell.net .\n\n      I hope this discussion has opened your eyes to a new IBM\ndirection that'll help your shop somewhere down the road.  Good\nluck.  See you next month.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9903MA": {"ttr": 18955, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x99\\x03O\\x01\\x00)\\x9f\\x11G\\x01\\xa1\\x01\\xa0\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1999-02-03T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 417, "newlines": 416, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           March 1999\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@aol.com or sbgolob@attglobal.net.\nInformation about the CBT MVS Tapes can be found on the web, at\nhttp://www.cbttape.org   \"Sponsored by NaSPA\", and at\nhttp://members.aol.com/cbttape .\n\n\nSMP/E Preprocessing\n\n      This month we'll be talking about SMP/E Preprocessing, which I\nhelped develop about fifteen years ago, and which is still useful\ntoday.  SMP/E Preprocessing has to do with keeping track of your\noperating system maintenance PTFs.  With the techniques we'll discuss\ntoday, you can have a great measure of power and control over the\nfixes that will go on to your system, even before SMP/E has ever\n\"seen\" them.\n\n      The idea of SMP/E Preprocessing is to look at a tape file of\nmaintenance PTFs or any SMPPTFIN file, before it goes on to your\nsystem.  I've found it wise never to completely trust IBM's software\npackaging, and I always try and study how it is put together.\nOn occasion, IBM will claim to have sent a certain PTF on a tape, and\nit really isn't there.  You only find out about the error after you've\nattempted to RECEIVE the PTF from the tape, and SMP/E tells you there\nare no PTFs eligible to be RECEIVEd.  SMP/E does not give you any\nactual knowledge or information about the contents of the SMPPTFIN\ntape file.  All SMP/E tells you, is whether the desired PTF is there,\nor not.  No other information is forthcoming, unless you're willing\nto risk RECEIVEing many other PTFs that you may not want.\n\n      How, then, can you pre-screen an SMPPTFIN file?  You can copy\nit to disk and attempt to BROWSE it with ISPF.  Then you can do\nrepeated FIND commands for the \"++ PTF\" keyword, starting in column\n1, that indicates the presence of a new PTF.  Having found a PTF, you\ncan next look for the FMID keyword which denotes the system component\nthat the PTF belongs to.  However, since IBM-shipped PTF files can be\nvery large, sometimes containing 20 million lines or more, this is not\nusually a practical way of finding out what is going on.  However, I\nmust say that the REVIEW program from File 134 of the CBT MVS Tape is\nconsiderably better than ISPF Browse for this purpose.\n\n      We have a far better way to pre-examine PTF files.  Almost 20\nyears ago, Jerry Lawson of the Hartford Insurance Group wrote an\nassembler program which reads an SMPPTFIN file, and which sorts all\nthe PTFs on it, by the product id (FMID) to which they belong.  The\noutput of Jerry's program is a report.  With this program, we can read\na PTF tape and find out what products and PTF numbers are represented\nin it.  Even a very large SMPPTFIN file can be processed very quickly\nby Jerry's program.  At least this is a step in the right direction.\nWe can pre-screen a PTF tape to find out what's on it.  The only\ndrawback is that we can't directly use the report data, as it stands,\nto feed input to an SMP/E job.\n\n      For this reason, I was not fully satisfied with Jerry's report\nas it was.  I wrote a COBOL post-processing program to read the\nreport, and to format the PTF numbers, arranged by FMID, so they could\nbe directly fed into a new SMP/E RECEIVE, APPLY, or ACCEPT job.  This\ngave me full FORFMID control of the SMPPTFIN tape, before SMP/E ever\n\"got its grubby paws\" on it.\n\n      Another problem we have with looking at an SMPPTFIN file, is\nthat it's often very large.  Wouldn't it be nice to break it up into\na pds, with each PTF as a separate member?  Then, you could BROWSE,\nEDIT, or otherwise pre-process each PTF as a separate entity, instead\nof being forced to look at it as a small part of a huge file.  I\nsolved this problem by writing another COBOL program to help me\nbreak up any SMPPTFIN file by PTFs, APARs, USERMODs, or FUNCTIONs.\n(Sorry to have used COBOL, but it was quick and dirty, and\nit worked.)  By breaking up the original huge file into its component\nPTFs, seen separately, we can have access to much more initial\ninformation about a PTF if we want it.  We'll see more about this,\nlater on.\n\n      Now, we'll look into some of the details of each of these\ntechniques, so that you'll be able to add these \"weapons\" to your\narsenal of system control tools.  I'll show you a lot of the control\nover PTFs that you can gain, and you can use your own inventiveness\nand creativity to further exploit this additional knowledge.\n\n\nWHERE YOU CAN FIND THE SOFTWARE\n\n      Jerry Lawson's report program, and my supporting programs, can\nbe found on File 118 of the CBT MVS Utilities Tape, which is a huge\ncollection of free MVS software that is independently produced.  You\ncan order physical tapes throgh NaSPA, or you can duplicate a tape if\nsomebody else has one (a good tape duplication program can be found\non File 229 of the CBT Tape).  Most of the CBT Tape materials can be\nfound on the NaSPA cd-rom.  However, the best place to get to specific\nCBT Tape files is to download them from www.naspa.net, which points to\nthe NaSPA-sponsored site at www.cbttape.org.  Simply go to www.naspa.net\nand click on \"Online CBT Tape\".  Then click on \"Download CBT\".  When\nyou go to the online home of the CBT Tape, you're assured of getting\nthe latest versions of the files.\n\n      On CBT Tape File 118, Jerry Lawson's program is called PUTXREF,\nand my post-processing program is called SMPFMUPV.  A sample execution\njobstream is included as member JCL2.  I wrote my original COBOL\nprograms in VS/COBOL, but I've included COBOL II versions of the\nsource, and there are 3 compile and linkedit jobs, IGYWCL1, IGYWCL2,\nIGYWCL3, which compile the COBOL II source programs under LE/370.  In\nmy tests, these programs worked correctly.  The latest software is\nscheduled to be loaded on Version 420 of the CBT Tape, File 118, but\nmeanwhile, it can be found on the net at:\nftp://ftp.cbttape.org/pub/cbttape/adhoc/file118.zip .  When this file\nis downloaded to the pc, you can unzip it and then upload it in binary\n(i.e. no translation or crlf) to the MVS system.  The dataset will be\nin TSO XMIT format, and to make it usable, you do a TSO RECEIVE\nINDATASET('yourid.FILE118.XMI').  You'll get a partitioned dataset\nthat contains all the good stuff.  In case you can't get the newest\nversion of File 118, the source programs SMPFMU2V and SMPUPD2 are\ncorrect, except for one data name in SMPUPD2 called FUNCTION, which\nbecame a COBOL reserved word, and which has to be changed to FUNCTON.\n\nHOW TO USE THE SOFTWARE\n\n      In Figure 1, I've included a sample of execution JCL for a\njobstream to look at an SMPPTFIN file, which could be on tape or on\ndisk, and to produce Jerry Lawson's PUTXREF report.  This is followed\nby my post-processing, which produces a file like the one shown in\nFigure 2.  You'll see that every SYSMOD on the SMPPTFIN file is\nreported according to its FMID, and you can feed the output into\nSELECT statements on an SMP/E RECEIVE, APPLY, or ACCEPT job.\n\n      In practice, I maintain a partitioned dataset which records\nthe contents of every input SMPPTFIN tape I have.  I run each of\nthem through this processing, and I write a new pds member\ncorresponding to each tape.  I call the partitioned dataset\nuserid.PTFPDS or some similar name, and I keep it around\npermanently.  If I need to find on which tape a particular PTF is, I\ndo a dataset search with the FIND subcommand of the PDS program\n(from File 182 of the CBT Tape).  If you're licensed for STARTOOL\n(from Serena Inc. in Burlingame, California), it performs the same\nfunction.  The FIND subcommand can be used to globally scan across\nall members of the pds, and it will show every tape I have, which\ncontains that particular PTF.  With the PDS command pointed at my\nPTFPDS dataset, a sample search command might be:  FIND : /ptfname/\nwhere the colon (:) denotes a command to search all members of the\nPTFPDS partitioned dataset.\n\n      In addition, I can do a FIND on a particular FMID, and the\nPDS program will show me every PTF I have in house on a tape, which\nbelongs to that FMID.  If you examine Figure 2, you'll see that the\ncomment field next to each PTF number, contains the FMID that the\nPTF belongs to, and you can search on that FMID name.  You can use\nwhatever global search utility you have, against all or some of the\nmembers of this pds, and you can instantly see how useful this kind\nof processing can be.\n\n\nBREAKING A BIG SMPPTFIN FILE INTO SEPARATE PTFS\n\n      My SMPUPD program from File 118 of the CBT Tape can be used\nto break up an SMPPTFIN file into a pds containing each PTF as a\nseparate member.  The COBOL II version of the SMPUPD source is called\nSMPUPD2.  All that SMPUPD does is to make a copy of the SMPPTFIN file\nwith a few subtle changes.  Before each ++ PTF keyword (or ++ APAR\nor ++ USERMOD or ++ FUNCTION), SMPUPD inserts an IEBUPDTE-type\n./ ADD NAME=ptfname card, containing the name of the PTF or other\nSYSMOD that's there.  This serves to separate each SYSMOD in the\nSMPPTFIN file from its neighbor.  SMPUPD also does one more thing.\nIt changes any ./ string starting in column 1, which would denote an\ninternal IEBUPDTE control card in the PTF, to a different string:\n./.  This allows for the correct IEBUPDTE or PDSLOAD post-processing\nof the copied (and changed) SMPUPD output file.\n\n      I have to talk about our IEBUPDTE substitute program called\nPDSLOAD.  PDSLOAD can be found on File 093 of the CBT Tape.  Besides\nperforming a member load of a partitioned dataset from an IEBUPDTE\nformat sequential dataset (the equivalent of IEBUPDTE, PARM=NEW),\nPDSLOAD can be set up to automatically convert all of the imbedded\n./ strings within each member, back to the original ./ strings they\nonce were.  Thus, if you use PDSLOAD instead of IEBUPDTE to load the\nSMPUPD-modified copy of the original SMPPTFIN dataset into a pds,\nyou won't have to convert imbedded >< strings globally back to ./ as\nthey originally were.  If you use PDSLOAD to create your pds, the\noriginal PTFs will be separated and correct as they were shipped.\nLook at sample JCL member SMPUPDJ, in File 118 of the CBT Tape, or\nlook at Figure 3, to see how to load a partitioned dataset with the\nseparated PTFs.\n\n      The value of being able to look at separate PTFs from a big\nSMPPTFIN file is obvious to most people.  If you only care about one\nPTF, you don't have to look at other PTFs that you don't want to see.\nYou might also want to RECEIVE the single PTF directly, and not as a\npart of a big file.  But there's another, more subtle advantage, if\nyou know how to read the object decks that are on each PTF.\n\n      Sometimes you need to fit a system modification, such as a\nload module zap, to a new version of an IBM module.  If IBM doesn't\nprovide source code for the new version, or if you can't get to the\nsource code display from IBMLINK, you've got another alternative.\nYou can disassemble the code from the object deck that's shipped\nwith the latest PTF.  Normally, disassemblers don't read 80-byte\nformat object decks directly.  So you can use the ISPF editor to\ncopy the object deck to a separate file, linkedit it, and then\ndisassemble the resulting load module, so you can fit your mod.\nFree disassemblers can be found on Files 171, 217, 238-242, and\n354 of the CBT Tape.\n\n      However, if you're lucky enough to have the STARTOOL vendor\nproduct from Serena (mentioned above), STARTOOL has a disassembler\nthat will directly disassemble code from an 80-byte object deck.\nThe STARTOOL object code disassembler is invoked with the READOBJ\nsubcommand.  Using STARTOOL, you can point to the pds that contains\nthe PTFs separated from the SMPPTFIN file, or an SMPPTS dataset for\nthat matter.  Get a member list under STARTOOL (ML subcommand), and\nthen invoke the line command of READ against any PTF in the dataset.\nThis will instantly disassemble all the object decks in the PTF.\nYou can now look at the assembler code in the PTFs, to help in\nfitting your mods.\n\n      I hope this month's talk was instructive.  The techniques\ncertainly are different than what you normally see as an MVS systems\nprogrammer.  But their utility value is obvious, and in the long run\nyou'll save a lot of maintenance time, if you make a regular practice\nof incorporating these methods in your everyday work.  Good luck.\nSee you next month.\n\n\n *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   JOBSTREAM TO RUN BASIC SMP/E PREPROCESSING\n\n            This jobstream takes an SMPPTFIN file (a PTF file on\n            disk or on tape) and first runs Jerry Lawson's PUTXREF\n            report against it.  Then, the job runs postprocessing\n            program SMPFMUPV against the report, to produce an\n            80-byte PTF list sorted by FMID, as shown in Figure 2.\n\n\n//SAGOLOBX  JOB (ACCT#),S-GOLOB,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X\n//******************************************************************//\n//*\n//*    PUTXREF PROGRAM FROM HARTFORD INSURANCE GROUP               *//\n//*      WITH MY EXTENSIONS - S.GOLOB                              *//\n//*                                                                *//\n//*    THIS JOB                                                    *//\n//*       Separates PTF numbers by FMID.                           *//\n//*                                                                *//\n//*         INPUT is an SMPPTFIN file.                            *//\n//*                                                                *//\n//*         OUTPUTS are:   1.  A PDS member with ./ ADD NAME=FMID  *//\n//*                             and all PTFS belonging to that     *//\n//*                             FMID, listed underneath.           *//\n//*                                                                *//\n//*                        2.  A step to load the members into     *//\n//*                             a PDS.  For example, if you        *//\n//*                             look at member JBB1214, you'll     *//\n//*                             find a list of all PTFs belonging  *//\n//*                             to FMID JBB1214, in a format so    *//\n//*                             they can be input into an SMP job. *//\n//*                                                                *//\n//******************************************************************//\n//*\n//STEP1    EXEC PGM=PUTXREF\n//STEPLIB  DD  DSN=SAGOLOB.LOAD,DISP=SHR\n//INPUT    DD  DISP=SHR,DSN=SAGOLOB.TEST.SEQ.PTS\n//SORTIN   DD  DSN=&&SORT,DISP=(NEW,PASS),UNIT=3380,\n//             DCB=(RECFM=FB,LRECL=15,BLKSIZE=4095),\n//             SPACE=(CYL,(25,20))\n//SORTOUT  DD  DSN=&&SORT,DISP=(SHR,PASS),VOL=REF=*.SORTIN\n//TITLES   DD  DISP=SHR,DSN=SAGOLOB.FILE118.PDS(TITLES)\n//PRINTER  DD  DSN=&TEMP1,DISP=(NEW,PASS),UNIT=3380,\n//         DCB=(RECFM=VBA,LRECL=137,BLKSIZE=141),\n//         SPACE=(TRK,(15,15))\n//SYSUDUMP DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=*\n//SYSOUT   DD  SYSOUT=*\n//SYSIN    DD  *\n SORT FIELDS=(9,7,CH,A,1,7,CH,A)\n/*\n//COPY    EXEC PGM=IEBGENER\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  DSN=&TEMP1,DISP=(OLD,PASS,KEEP)\n//SYSUT2   DD  SYSOUT=*\n//SYSIN    DD  DUMMY\n//*\n//CLEAN  EXEC PGM=IEFBR14\n//IN       DD  DSN=&TEMP1,DISP=(OLD,PASS)\n//*\n//SMPFMUPD EXEC PGM=SMPFMUPV\n//STEPLIB DD DISP=SHR,DSN=SAGOLOB.LOAD\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD DSN=&TEMP1,DISP=(OLD,DELETE,KEEP)\n//*YSUT2   DD  DSN=&TEMP3,DISP=(NEW,PASS),UNIT=SYSDA,\n//*        DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120),\n//*        SPACE=(TRK,(15,30))\n//SYSUT2   DD DISP=SHR,DSN=SAGOLOB.PTFPDS(TESTSEQ1)\n//SYSABEND DD SYSOUT=L,HOLD=YES\n//*\n//*     The following step is optional, and may be commented out.\n//*     You'll determine if you want it or not.\n//*\n//S03UPDTE EXEC PGM=PDSLOAD,PARM='UPDTE(./)'  /* CBT TAPE--FILE 093 */\n//*03UPDTE EXEC PGM=IEBUPDTE,PARM=NEW         /* not as good  */\n//STEPLIB   DD  DISP=SHR,DSN=SAGOLOB.LOAD\n//SYSPRINT  DD  SYSOUT=*\n//SYSUT1    DD  DSN=SAGOLOB.PTFPDS(TESTSEQ1),DISP=SHR   /* LRECL=80 */\n//*YSUT1    DD  DSN=&TEMP3,DISP=(OLD,DELETE)\n//SYSUT2    DD  DSN=SAGOLOB.PTSXREF,DISP=SHR    /* a PDS.  LRECL=80 */\n\n\n *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.   SAMPLE OUTPUT OF SMP/E PREPROCESSING.\n\n            This is sample output from the jobstream shown in\n            Figure 1.  Notice the comments which program\n            SMPFMUPV inserts next to each PTF number.  This makes\n            it easier to do global searches either by PTF number\n            or by FMID number.\n\n./  ADD  NAME=EDU1G01\n      UN90869  /*  FMID - EDU1G01 - FROM PUT TAPE - DONE 02/01/99    */\n./  ADD  NAME=H0G2110\n      UN79279  /*  FMID - H0G2110 - FROM PUT TAPE - DONE 02/01/99    */\n      UN87460  /*  FMID - H0G2110 - FROM PUT TAPE - DONE 02/01/99    */\n      UN87499  /*  FMID - H0G2110 - FROM PUT TAPE - DONE 02/01/99    */\n      UN99450  /*  FMID - H0G2110 - FROM PUT TAPE - DONE 02/01/99    */\n./  ADD  NAME=JBB66N1\n      UW25288  /*  FMID - JBB66N1 - FROM PUT TAPE - DONE 02/01/99    */\n./  ADD  NAME=JIF4210\n      UW27032  /*  FMID - JIF4210 - FROM PUT TAPE - DONE 02/01/99    */\n      UW27036  /*  FMID - JIF4210 - FROM PUT TAPE - DONE 02/01/99    */\n./  ADD  NAME=JIF4230\n      UW26914  /*  FMID - JIF4230 - FROM PUT TAPE - DONE 02/01/99    */\n      UW27404  /*  FMID - JIF4230 - FROM PUT TAPE - DONE 02/01/99    */\n      UW27480  /*  FMID - JIF4230 - FROM PUT TAPE - DONE 02/01/99    */\n      UW27514  /*  FMID - JIF4230 - FROM PUT TAPE - DONE 02/01/99    */\n      UW27518  /*  FMID - JIF4230 - FROM PUT TAPE - DONE 02/01/99    */\n      UW27846  /*  FMID - JIF4230 - FROM PUT TAPE - DONE 02/01/99    */\n./  ADD  NAME=JIF4270\n      UW27665  /*  FMID - JIF4270 - FROM PUT TAPE - DONE 02/01/99    */\n./  ADD  NAME=JPZ8136\n      UW35675  /*  FMID - JPZ8136 - FROM PUT TAPE - DONE 02/01/99    */\n\n\n *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 3:   Processing to break an SMPPTFIN file into its\n            separate SYSMODS (usually PTFs).  Each SYSMOD\n            will be a different member of the pds.\n\n\n//SAGOLOBO  JOB (ACCT#),S-GOLOB,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X\n//******************************************************************//\n//**     JCL TO MAKE A PDS OUT OF AN SMPPTFIN SEQ INPUT FILE      **//\n//******************************************************************//\n//*       STEP 1 - CREATION OF TEMPORARY COPY OF SMPPTFIN FILE\n//*                   WHICH HAS ./ ADD CARDS INSERTED,\n//*                   AND WHICH CONVERTS OTHER \"./\" STRINGS\n//*                   IN COLUMNS 1-2 TO \"><\".\n//******************************************************************//\n//S1PTFADD EXEC PGM=SMPUPD\n//STEPLIB DD DISP=SHR,DSN=SAGOLOB.LOAD\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD DISP=SHR,DSN=SAGOLOB.TEST.SEQ.PTS\n//SYSUT2   DD DISP=(,PASS),DSN=&&TEMP,UNIT=SYSDA,\n//    DCB=(RECFM=FB,LRECL=80,BLKSIZE=6160),SPACE=(TRK,(300,120))\n//SYSABEND DD SYSOUT=A,HOLD=YES\n//******************************************************************//\n//*       STEP 2 - RELOAD OF ALL SYSMODS INTO A NEW OUTPUT PDS.\n//******************************************************************//\n//S2UPDTE EXEC PGM=PDSLOAD,PARM='UPDTE(><)'\n//STEPLIB   DD  DISP=SHR,DSN=SAGOLOB.LOAD\n//SYSPRINT  DD  SYSOUT=*\n//SYSUT1    DD  DSN=&&TEMP,DISP=(OLD,PASS)\n//SYSUT2    DD  DSN=SAGOLOB.TEST.PDS.PTS,DISP=SHR\n//*YSUT2    DD  DSN=SAGOLOB.TEST.PDS.PTS,DISP=(NEW,CATLG,DELETE),\n//*    UNIT=SYSDA,VOL=SER=PRIM10,SPACE=(TRK,(300,120,137)),\n//*    DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)\n//******************************************************************//\n//*       STEP 3 - CREATION OF ISPF STATISTICS AND RESTORE OF\n//*                  DUPLICATELY-NAMED SYSMODS SO THEY CAN\n//*                  BE EXAMINED.\n//*                COMPARE TOTAL NUMBER OF RECORDS IN THE PDS\n//*                  USING THE   AT : SHORT   COMMAND\n//*                  WITH THE NUMBER OF RECORDS IN THE ORIGINAL\n//*                  FILE, TO MAKE SURE NO RECORDS GOT LOST IN\n//*                  THIS PROCESS.\n//******************************************************************//\n//S3STATS EXEC PGM=IKJEFT01,REGION=4096K,DYNAMNBR=50\n//STEPLIB  DD DISP=SHR,DSN=IBMUSER.PDSE530.LOAD  /* PDS or STARTOOL */\n//SYSPRINT DD SYSOUT=*\n//SYSTSPRT DD SYSOUT=*\n//SYSTERM  DD SYSOUT=*\n//* ----- THIS SHOULD WORK WITH FREE PDS AS WELL AS STARTOOL ----- *//\n//SYSTSIN  DD *\n PDS   'SAGOLOB.TEST.PDS.PTS'\n AT : ADDSTATS USERID(PTF9901) VER(01)\n RESTORE $PTF REPEAT NOPROMPT\n AT $PTF* ADDSTATS USERID(REP9901) VER(01)\n FIXPDS RELEASE\n AT : SHORT\n CHANGE 'SAGOLOB.TEST.SEQ.PTS'\n VER\n END\n/*\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9904AP": {"ttr": 19207, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x99\\x06O\\x01\\x00)\\x9f\\x11G\\x00\\xf5\\x00\\xf5\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1999-03-05T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 245, "newlines": 245, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           April 1999\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@aol.com or sbgolob@attglobal.net.\nInformation about the CBT MVS Tapes can be found on the web, at\nhttp://www.cbttape.org   \"Sponsored by NaSPA\", and at\nhttp://members.aol.com/cbttape .\n\n\nAWARENESS\n\n      Today I'm going to speak about how \"aware\" we have to be, while\nwe're doing our jobs.  To my knowledge, nobody talks about this topic\ndirectly.  But everybody has great respect for an MVS Systems\nProgrammer (or for anyone else) who is \"aware\".  And by exposing this\nsubject to discussion, I hope to bring information to light, that\nwill help all of us (including myself) become more useful to our\nemployers and clients.\n\n      Awareness begins with one's job description, and goes on from\nthere.  Of course, if you're doing any job, you have to know what your\nmanagement, or customers, expect from you.  This is the minimum job\nawareness that is expected of anybody.  Satisfying the (reasonable)\nexpectations of those who require your services, is the minimum\nobligation everyone has to fulfill.  Those who hire you, have to \"get\nwhat they pay for\".  However, one's job description doesn't always\naccurately say what you REALLY have to do.  At many shops, no one will\nexpressly tell you what you really have to do, although they might\nhint at it.  The problem partially comes from \"management's\" lack of\nability to phrase the requirements correctly and put them down on\npaper.  And it partially comes from the fact that you, the technician,\nhave to be aware of more things than anyone else thinks you have to be\naware of.\n\n      For example, many years ago, I worked for an extremely \"budget\nconscious\" shop.  Our management was under constant, unspoken pressure\nto run the operation for less money, out of fear of being outsourced.\nNobody ever told me specifically that this was supposed to affect what\nI had to do.  We did hear constantly, that there was a threat of our\nbeing outsourced.  My boss often told me (this was in the mid-80's)\nthat he'd always ask a software salesman the (then) unpopular question\nof:  \"How much does this product cost?\"\n\n      I figured out several things from this, without expressly being\ntold:  First, I wouldn't ever get any utilities I wanted, unless they\nwere for free.  Second, if management could get their hands on a free\ntool instead of having to buy one, they probably wouldn't mind it.  Of\ncourse, with a free tool, there's always a \"support\" question.  But\nthe balance would be, that for a utility that wasn't totally\nessential to the running of the shop, they'd probably rather rely on\nmy support skills, than have to pay any more money.\n\n      From this situation, I learned that I'd be wise to familiarize\nmyself with the world of free MVS tools, and also to make myself aware\nof the trends of new MVS system changes within IBM.  After all, IBM\nmight put a new feature into MVS, that would spoil the operation of\none of our free utilities.  I had to know enough, in advance, to\nanticipate any problems, and get a handle on solving them when they'd\ncome up later.  In addition to that, I knew I needed to establish a\nnetwork of friends, who might be able to \"bail us out\" when we needed\nhelp.  We couldn't pay for such help.  I knew that \"to have a friend,\nyou have to be a friend\".  So I also prepared myself to help anyone\nelse, from a different shop, who might need my expertise and\nexperience.\n\n      Besides all of that, I needed, and got, my management's express\napproval.  My boss came to realize that the survival of his shop\ndepended, in part, on the success of my efforts, and he supported me.\nHe let me call systems programmers from other shops during work hours,\nbecause he knew that my efforts would eventually decrease our shop's\n\"down time\", and it'd enhance his image with upper management when our\nshop ran well.  Vendor products were not left out of my program.  I\nmade friends with a lot of third-party software support people, so that\nif we needed help later from them, it would be quickly forthcoming.  My\nboss let me do many favors for them, such as making tapes of free\nsoftware for them.  Later, I had friends in many places, when I needed\nthem for the \"health\" of our own shop.\n\n      None of this was written in my job description.  Being \"aware\"\nhelped to inform me, as to what I had to do.  I personally was\nresponsible for our not having to buy several hundred thousand dollars\nworth of third-party vendor software.  During my tenure at that shop,\nwe resisted approximately six outsourcing attemps.  Every single time,\nour management was able to demonstrate that we could run the shop more\nefficiently, and for less money, than the outsourcing company could.\n\n      In the process of doing this, I accumulated a lot of experience\nfor myself, which stood me in good stead when I changed companies\nlater, and when I worked as a consultant.  Most of my \"support\nfriends\" from those days, have remained friends of mine to this day.\nI'm trying to say that you can gain large benefits from being \"aware\",\nwhich will help you personally, as well as helping your current\nemployer or clients.\n\n\nHOW TO BE AWARE\n\n      Being aware often involves \"using your head\", \"listening to\nthe news\", and talking with other people.  I've found that you need\nto be aware about new hardware and software that's not (yet) running\nat your shop.  Many of my friends regularly read the IBM Announcement\nLetters that are posted on IBMLink or on the Internet at IBM's web\nsite.  This keeps them abreast of trends at IBM.\n\n      A useful source of \"news\" is the IBM-MAIN newsgroup forum,\nwhere you can see people's problems with hardware and software that\nyou may, or may not, be using.  You can participate in the newsgroup\ndiscussions, or you can just watch what the other folks are saying.\nEither way, you're sharpening your skills up, and you're making\ncontact with other people.\n\n      In case you want to know about the IBM-MAIN newsgroup, or\nother newsgroups in our field, see my past column (April 98) called\n\"Other People's Problems\".  The network address of IBM-MAIN has\nchanged since then.  The list server is at LISTSERV@BAMA.UA.EDU ,\nand the forum itself is at IBM-MAIN@BAMA.UA.EDU .\n\n      The Internet has opened up many avenues to finding out more\nnews.  Several sites post links to S/390 information sites all over\nthe world.  A systems programmer in Belgium, Eric Loriaux, has\nestablished a marvelous site to gather all kinds of MVS information\nlinks in one place.  Eric's US mirror site is at www.loriaux.com ,\nand his main site is at http://www.ping.be/~ping1475 .  Our online\nCBT Tape site, which you can reach from www.naspa.net by clicking\non \"Online CBT Tape\", also has links to many other MVS-related\nweb sites.  By starting at these places, you probably can eventually\nreach almost everywhere else.\n\n      I've found that SHARE conferences are a marvelous, concentrated\n\"awareness centers\".  They occur twice a year.  Winter ones (usually\nin February) are in a Western city.  Summer ones (usually in August)\nare in an Eastern or Central city.  As of this writing, the SHARE\nconference in San Francisco has just ended, and just from talking to\nmy friends, I can feel the vibrancy and new zest for life, which that\nconference has generated in them.  The SHARE membership requirements\nhave changed, and you can now become a SHARE member by yourself,\nwithout relying on your company, and without requiring your running\nany IBM equipment.  (Of course you have to pay the money yourself,\ntoo.)  But now I am a SHARE member by myself, and I've gotten a lot\nof benefit from going to several of the conferences as a consultant,\nwithout having to rely on another company's SHARE membership.  Go to\nwww.share.org for information about SHARE.\n\n      SHARE conferences provide opportunities for the most concentrated\nsystems programming schooling I've ever seen.  It's not automatic.\nYou have to plan which sessions you'll attend, very carefully, and\nyou have to make sure you physically get yourself there.  But the\nopportunities for increasing your awareness can be unequalled.  I once\ntook about 40 \"random\" questions from everybody in my shop, to a SHARE\nconference.  I worked very hard, but I came back from SHARE with\nauthoritative answers (from experts) to every one of them.  If I didn't\nget the answers at a session, I got them from talking to people in the\nhallway between sessions, or at SCIDS.\n\n      SCIDS at SHARE is a five-hour evening open ballroom session,\nwhere anybody can sit at a table and talk to anybody else.  If you\nhave a special interest, some of the tables are marked as belonging\nto a special interest group.  When I had VM questions (as an MVS\nsystems programmer), I'd go to the VM table at SCIDS and ask them\nthere.  The same went for anything else.  Storage Management has\ntheir table at SCIDS.  Different databases have theirs, and so forth.\nSCIDS is an excellent opportunity to go \"across fields\" or to speak\nto other people in your own special area of expertise.  Besides going\nto SCIDS at SHARE, there's a \"vendor EXPO\", and you can talk to all\nthe vendors' representatives directly.\n\n      At SHARE, you can get \"real addresses\" and phone numbers of IBM\npeople and others.  I always collect everyone's business cards.  At\nSHARE, all the IBM people are allowed to give them out.  When you have\na difficulty, if you have a real IBM'er to call, or a real person from\nanother vendor, you sometimes can slice through a tough problem in a\nsmall fraction of the time it'd normally take to solve.  Even one-time\nSHARE attendance is valuable.  But regular attendance is extremely\nhelpful in increasing your awareness.\n\n      If you have a special concentrated interest, you might spend\nsome of your SHARE time with a committee.  SHARE committees are a\nmeans of enhancing your own knowledge.  But they are also the direct\nvehicle for affecting IBM.  I was once chairman of a committee which\nwe established, to get IBM to modernize Assembler H.  Greg Mushial\nof the Stanford Linear Accelerator Center (SLAC) had created many\nuser enhancements to IBM's Assembler H, from source code, and we\nwere trying to get IBM to adopt and support them.  At SHARE, in the\nAssembler Committee, we got together with many like-minded users,\nvendor developers, and IBM'ers.  It was a tough fight, getting IBM\nto move, but eventually our efforts paid off, and IBM came out with\nthe High Level Assembler for all its S/390 platforms.  The entire\nworld is benefiting, and we can really feel that we made the big\ndifference.\n\n\nWHEN TO GROW IN AWARENESS\n\n      There are many ways to grow in awareness, and you can grow all\nthe time.  It pays to be flexible in looking for opportunities.  It\nmay be hard for some of us to influence our employers to send us to a\nSHARE conference.  So meanwhile, we can look elsewhere.  Internet\naccess is easier, so we can spend time following the links at Eric\nLoriaux' site and other sites to discover places to explore.  Since\nall the CBT MVS Tape materials are now online, you can download all\nsorts of user-written code to study and MVS utilities to use.\nFollowing the IBM-MAIN discussions is an opportunity, too.  It all\ndepends on your taste, and your daily schedule.\n\n      Here's something that not so many people are aware of.\nYou can grow more aware, just by doing your job.  I'll show you\nwhy.  It's simple.  Your employer can't ever take your experience,\nwhich you've gained at the job, away from you.  Your experience\nremains yours.  Your labor, which they've paid for, is theirs.\n\n      I like to express this as my \"50-50, 100-100 Rule\".  When\nyou're doing your job at work, your employer and you yourself, split\nthe benefits 50-50.  But it's not really 50-50.  Your employer gets\n100 percent of your work, and you get 100 percent of your experience.\nSo the benefit is really split 100-100.\n\n      It makes a big difference to think this way.  Sometimes an\nemployee can be annoyed at the company, or the boss, for some reason.\nIs that a cause to stop working?  No!  If you stop working, you're\ncutting yourself off from the 100 percent of the new experience that\nyou'd gain simply by doing your job.  New experience brings new\nawareness, and it always makes you a more useful person, valuable\nto any employer or client, as well as your current one.\n\n      So, new awareness comes every moment of your working day.\nHowever, I, myself, advocate the \"looking outward for a fraction of\nthe time\" approach.  I feel you can't do this job really well, without\nlooking at the world outside.  My teacher Jeff Broido drove that idea\ninto me very strongly, during my early years in this trade.  And you\nhave to invest some time in it.  Your employer will eventually see the\nreturn on your personal investment.  But you don't have to rely only\non your employer seeing it.  You'll benefit directly, yourself, from\nyour own efforts, 100 percent of the time.\n\n      This month, I hope you've benefited from this column.  Good luck.\nWe'll see you next month.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9905MY": {"ttr": 19457, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x99\\x10\\x9f\\x01\\x00)\\x9f\\x11G\\x01\\x03\\x01\\x03\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1999-04-19T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 259, "newlines": 259, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                            MAY 1999\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@aol.com or sbgolob@attglobal.net.\nInformation about the CBT MVS Tapes can be found on the web, at\nhttp://www.cbttape.org   \"Sponsored by NaSPA\", and at\nhttp://members.aol.com/cbttape .\n\n\nHIGHLIGHTS OF CBT TAPE VERSION 420\n\n      Way back in time, when Arnie Casinghino edited the CBT MVS\nTape, I used to drool for a new version, more than a kid would look\nforward to a new bike.  What new goodies, tools, and thingies did it\nhave?  Did Bruce Leland and Steve Smith add more doo-dads to the PDS\ncommand?  (Nowadays, John Kalinich does that.)  Would I get some new\ninvention that would revolutionize my work?  There's no telling what\nI'd find.  Somebody should have taken a few pictures of the smile on\nmy face, at the very moment I opened any new CBT Tape package.\n\n      Nowadays, when the shoe's on the other foot, I always try and\nmultiply my own expression of happiness by several thousand, as I\npicture everybody else getting a package of new CBT Tape stuff.  I\nwant to make sure that every single person out there, is as happy\ngetting a new version, as I used to be.  I think, with this new CBT\nTape Version 420, not too many people will be disappointed.\n\n      Figure 1 contains a summary of all the file changes to Version\n420, and you can see at a glance that there's a lot to look at and\nexplore.  Today, we'll start a quick tour of some of the highlights\n(with more next month), and we'll see a lot of new ways to expand our\ntool collection and our skills.\n\n\nWHAT'S REALLY NEW?\n\n      Probably the first thing you'll notice as you look at File 001\n(the documentation) of Version 420, is that it's now in mixed case.\nNot only does lower case type make the documentation easier to read, it\nmakes it possible to accurately display Internet addresses, so that\neveryone will be able to find them.  The other piece of news about File\n001 (currently more than 33000 lines long) is that you can now make a\npds out of it.  On File 004, there is a new ISPF edit macro called\nCBTUPDTE, which inserts a whole bunch of IEBUPDTE \"./ ADD NAME=\" cards\ninto the CBT Tape Documentation, so you can create a partitioned\ndataset with small pieces of the text as separate members.  I hope this\nwill help more people profit from the wealth of documentation that's in\nthere.  There are a few more CBT doc manipulation tools on Files 006\nand 130.\n\n      As far as new utilities are concerned, it's tough to decide\nwhere to start.  I guess the best place is File 365, where we have a\nbeautiful new package from Ron MacRae of Amdahl UK, which helps us\nbetter to transmit MVS data over the Internet.\n\n      By now, many of us know that TSO XMIT will take almost any\nMVS-based disk data, and will re-package it into convenient 80-byte\nrecords for neat transmission to almost anywhere.  The format for\ndoing so is TSO XMIT node.userid DATASET(your.dataset)\nOUTDATASET(your.seq.FB80.XMIT.output) .  The trick to realize is, that\nonce you've coded the OUTDATASET parameter, it doesn't matter where\nthe destination \"node.userid\" is.  The XMIT command (in that case)\nwill only reformat the data, but it won't send it out.  You yourself\ncan now download the reformatted data to a pc, attach it to an\nInternet email or FTP it, so it eventually reaches another MVS system\nsomewhere in the world.  On the MVS receiving end, after they get the\nnew data, they do a TSO RECEIVE INDATASET(this.new.data) against it.\nProblem is, we're never 100 percent sure that not one single byte of\nthe RECEIVEd data was altered during the physical transmission.\n\n      Experienced users of this method (like me) will know that if\nthere was some alteration of the data file by the time it got to the\nreceiving MVS system, the TSO RECEIVE command might not work properly.\nBut that condition won't catch all the possible errors.  It's only an\nindication that there's some header or trailer information missing.\nThe alteration of a byte or two of the actual data, will give\nabsolutely no indication that anything's wrong.  You're never really\nsure you've gotten absolutely the same data that the sender sent.\n\n      A second problem, or more accurately, a \"difficulty\" in this\nmethod, is the complexity of coding the TSO XMIT command for many\nfiles, if a lot of them have to be sent.  On the MVS RECEIVEing end,\nhow do we know that if the sender sent 100-or-so files, one of them\nis not missing?  Besides the complexity of doing 100-or-so TSO RECEIVE\ncommands, one after the other, we're never sure we've actually gotten\nall the files across from the sender.\n\n      Ron MacRae's package solves all this.  Ron works for Amdahl UK,\nand his unit is responsible for supporting their product called\nObjectSTAR.  Ron's unit has to ship PTFs out over the Internet, and\nthey have to be accurate, byte-for-byte.  They also have to receive\nentire dumps and diagnostic data from customers, over the Internet.\nAll of it has to be right, with no data altered in the transmission,\notherwise the problem diagnosis might be wrong, and things could be\nbadly messed up.  Sometimes very large amounts of data have to be\n(accurately) sent.\n\n      Ron's solution to this problem is a package called OSTARXMT,\nwhich consists of two REXX execs and an optional assembler program.\nAmdahl UK has graciously consented to make this system public, with\nthe condition that it not be sold, and we owe them a big \"thank you\".\nA lot of people, in a lot of places, are going to get a lot of benefit\nfrom this system.  The two REXX execs, called OSTARXMT and OSTARREC\n(for \"transmit\" and \"receive\") are self-contained.  Here's how the\nsystem works.\n\n      OSTARXMT is run against one or more datasets that are to be\nsent out.  OSTARXMT invokes TSO XMIT \"under the covers\", for each\ndataset to be sent in the package, and bundles the XMIT-format data\nfor each dataset, so it goes together in one file, one dataset after\nanother.  Then, to each 80-byte record of the XMIT-format data, eight\nbytes of error-checking data are appended at the end, resulting in\nrecords that have 88 bytes of data.  In other words, the dataset made\nby OSTARXMT has LRECL 88.  Since this is a special format, a special\nMVS suffix is assigned:  \".XMT\".\n\n      The single \".XMT\" file, possibly containing many datasets, is\nnow sent out, anywhere in the world, eventually reaching another MVS\nsystem that has the OSTARREC exec installed.  The recipient executes\nOSTARREC against the XMT file, and (in the simplest case) gets a series\nof TSO RECEIVE INDATASET prompts for each file included in the bundle.\nOSTARREC will not work, unless every byte of data is accurate, as\nindicated by the 8 error-checking bytes in each record.  After each\nTSO RECEIVE command has executed, you are assured that you have,\nbyte-for-byte, the same data that the sender sent.  Furthermore,\nsince the data came in one package, none of the individual datasets\nis missing.\n\n      Sometimes all of this OSTARXMT activity will create a very large\nsingle package to be transmitted.  Some compression of the package is\nneeded.  For a first cut, Ron has incorporated the free IBM compression\nutility called TRSMAIN into his system.  TRSMAIN is a load module that\ncan be obtained from the following IBM site (as of this writing):\n\n     ftp://service.boulder.ibm.com/s390/mvs/tools/packlib\n\nWhen you put the TRSMAIN load module into one of the load libraries on\nyour system, you indicate its presence by editing the OSTARXMT and\nOSTARREC execs to show the library where TRSMAIN is located.   OSTARXMT\nwill then optionally use TRSMAIN to create a compressed version of the\npackage to be sent, suffixed by the special suffix:  \".XM1\".  When\nOSTARREC goes against a file with suffix \".XM1\", it will invoke TRSMAIN\n(which also has to be present on the receiving MVS system) automatically\nto decompress the file, before invoking the rest of the processing on\nthe resulting \".XMT\" file.  In practice, this is very automatic and\nconvenient, though it may take some time.  You might run it with\nTSO-in-batch, so it doesn't tie up your terminal.\n\n      For large files, the error-checking process, done by OSTARXMT\nand OSTARREC, might be slow, because of the slowness in REXX program\nexecution.  To solve that problem, Ron MacRae wrote an assembler\nprogram called OSTAREDC, which does the same error checking at\nassembler speed (usually over 95 percent faster).  You edit the two\nREXX execs to tell them where to look for the OSTAREDC load module,\nand all error checking is then automatically done at super-speed\ninstead of at REXX speed.  This package is \"very cool\".\n\n      There are at least two other new \"data packaging\" related systems\non CBT Tape Version 420.  One has been added to File 171, and is a\npackage called FX, a sort-of-substitute for IBM's old BDT (Bulk Data\nTransmission) package.  FX works on MVS systems that are connectible\nusing LU 6.2.  The other is the BACKDSNS program that's on Randy Hall's\nnew file, File 354.  BACKDSNS will look at a list of datasets and\ncreate backup JCL for them.  Randy's new file contains a bunch of other\nnew goodies too, that are very much worth looking at.\n\n\nSO WHAT ELSE IS NEW?\n\n      What else is new?  Much more than I can talk about in this\nsmall space, and I'll have to continue next time.  However, there are\nsome special items that I'd especially recommend trying.  One of them\nis a neat system of REXX execs by Willy Jensen of Harders Jensen in\nDenmark.  Willy's system can be found on File 349, and allows you to\nmodify your active ISPF command table entries \"on the fly\".  This lets\na systems programmer come into a new shop, or just tailor an ISPF\nsession's \"special commands\" according to preference, without\naffecting anyone else's sessions at all.  The package consists of two\nREXX execs, ISPCMDL to list your ISPF session's command table entries,\nand ISPCMDU, to update them on the fly.\n\n      Another little gimmick comes from Joerg Berning in Germany\nand consists of a REXX exec called LISTVTOC, to do a track extent map\nof a disk volume.  The result of the map is ISPF edited and displayed\non your screen, so you can do a CREATE to save it.  LISTVTOC is quick\nand neat, but you have to try it for yourself, to see if it is useful\nfor your own purposes.  Currently, the absolute track values are\ndisplayed in decimal.  I myself would alternatively like to also see\nCCHHR and TTR displays too.  Maybe Joerg will add these eventually,\nbut his program, as it stands, is quite unique, and very useful.\nLISTVTOC is on File 344 of the CBT Tape.\n\n      If your shop is small and you don't have a multi-session\nmanager package, or you want to set up a VTAM multi-session manager\nprogram for yourself, NETSOL is back, fixed to run on OS/390.  NETSOL\nused to be on the CBT Tape, many years back.  It was fixed and\nspruced up, and now it's available for your use again.  NETSOL is on\nFile 356 of the CBT Tape.\n\n      I'll continue this topic next time.  Meanwhile, look at Figure 1\nfor what's new, and go to the Online Home of the CBT Tape, to get what\nyou want.  The Online CBT Tape files can be accessed from\nwww.naspa.net, by clicking on \"Online CBT\".  Good luck and good\nhunting!  We'll see you next month.\n\n *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFigure 1.   Summary of File Changes in Version 420 of the CBT Tape.\n\n\n File Number         Quick Summary of Contents or Changes\n -----------         ------------------------------------\n\n  001           Documentation File is now in mixed case.\n  004           CBTUPDTE edit macro - IEBUPDTE separators in File 001.\n  006           Tools to manipulate File 001 and improve readability.\n  035           Load module library. Latest version of PDS 8.5 etc.\n  071           Updated documentation of other tapes. JES3 Tape.\n  118           SMP/E SMPPTFIN pre-processing.  Upgrade to COBOL/370.\n  120           More of these articles.  (MVS Tools and Tricks)\n  130           Former File 006. Loads File 001 into INFO/MVS database.\n  134           Greg Price source.  Latest version of REVIEW, etc.\n  135           Greg Price load modules.  SHOWMVS load module, etc.\n  166           Vinh Vu's collection, updated.\n  171           LU 6.2 Bulk Data transmitter. With DITTO, DISASM etc.\n  182           PDS package. Version 8.5, update 8, from John Kalinich.\n  183           Gilbert Saint-flour collection.  New SHOWMVS program.\n  296           Utilities that work with PDS 8.5, and standalone too.\n  300           Update to CDSCB for Y2K. With zillion other TSO pgms.\n  311           Refresh of Dave Alcock's large utility collection.\n  312           Lionel Dyck's ISPF FTP Batch interface, and XMITIP.\n  321           Roland Schiradin's COBOL load module analysis pgm.\n  338           Gilbert Saint-flour and Larry Williams - P390 tools.\n  344           REXX exec from Joerg Berning to do a VTOC track map.\n  347           Look at load library and list COBOL compile options.\n  348           Pgms to list pds members in alphabetical order.\n  349           Change your ISPF command table options on the fly.\n  350           JES2 exits. Convert JCL from Mellon Mods to SCHENV=.\n  351           Programs to list currently installed LE level.\n  354           Randy Hall collection of programs. New. BACKDSNS etc.\n  355           KONCAT (concatenation program) from Kaiser Permanente.\n  356           NETSOL (VTAM multi-session manager). Works for OS/390.\n  357           PDSGEN, PDSLIST programs from Carl Hafner of Steli.\n  358           SYSOUT writer from Eric Bielefeld.\n  361           Frank Johnston programs. Multi-string scanner, etc.\n  362           Frank Johnston load modules.\n  363           ISPF/PDF Data Set Name change exit. (ISPF exit 16)\n  364           Control Card Subsystem. Works for OS/390.\n  365           Error-check multiple-file TSO XMIT pkg from Ron MacRae.\n  369           Multiple changes to DSPACE program from Dale Vick.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9906JN": {"ttr": 19462, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x99\\x12\\x7f\\x01\\x00)\\x9f\\x11G\\x01u\\x01u\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1999-05-07T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 373, "newlines": 373, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                            JUNE 1999\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@attglobal.net or sbgolob@aol.com.\nInformation about the CBT MVS Tapes can be found on the web, at\nhttp://www.naspa.net , after clicking on \"Online CBT\".\n\n\nSELECTIONS FROM CBT TAPE VERSION 420 (and 421)\n\n      Last month, we began to look at a few of the new software\ngoodies that are on the new CBT MVS Utilities Tape, Version 420, which\nwas just released at the beginning of April.  Figure 1 summarizes all\nthe new and changed files in this latest CBT Tape version.  This month,\nwe'll continue by mentioning some more new products that I, personally,\nconsider very helpful in the daily life of an MVS systems programmer.\n\n      Since the CBT Tape is now available online, it is possible to\nalso mention some files that \"didn't quite make the deadline\", and\nwhich are slated to be included in the next release of the tape,\nVersion 421.  You can download these files also.  You can reach the\n\"Online Home of the CBT Tape\" by going to 'www.naspa.net' and clicking\non \"Online CBT\".  This will get to the Version 420 files.  The\nfiles slated for inclusion on Version 421 are available for the\ntime being, at:  ftp://ftp.cbttape.org/pub/cbttape/adhoc/CBTnnn.zip ,\nwhere nnn is the file number for the new file.  The characters in\nthis URL are case sensitive.\n\n      As most of you probably know, the CBT MVS Utilities Tape has\nlong been considered the \"systems programmer's best friend\".  This\nenormous, totally free collection of MVS system software and other\ngoodies, was started in 1975 by Arnold Casinghino at the Connecticut\nBank and Trust Company in Hartford, Connecticut.  Arnie was extremely\ndedicated to maintaining the collection, and it has grown enormously\nto now span two tapes:  the \"CBT MVS Utilities Tape\" and the \"CBT\nOverflow Tape\", both of whose files are available online.  When Arnie\nhad to stop maintaining the tape in 1990, I took over as its proprietor,\nand at the same time, NaSPA became a major force in distributing this\npublic collection.\n\n      The CBT Tapes don't have a monopoly on useful tools for sysprogs,\nbut they do provide a robust place to start looking for help.  File\n071, and the \"Modification Tapes Section\" in the File 001 documentation\nof the CBT Tape, attempt to point you to many other useful sources of\navailable free MVS materials.  With the CBT Tapes as a starting point,\nyou have access to lots of help.\n\n      Today, we'll cover a few more new tools that you can try out.\nThey're only a sample.  Check over Figure 1 again, to see the complete\nlist of new and changed files for CBT Tape Version 420.\n\n\nFILE 349 - UPDATING YOUR ISPF COMMAND TABLE.\n\n      I'm glad I'm writing about File 349 this month, because, as\nshipped on Version 420 of the CBT Tape, File 349 was missing a piece,\nand it wasn't ready last month.  However, I'm so happy with it, and so\nconvinced of its usefulness, that I'm going to start our discussion\nby talking about the \"repaired\" version of File 349 that you can\ndownload.  The URL is:\nftp://ftp.cbttape.org/pub/cbttape/adhoc/CBT349.zip .\n\n      File 349 gives you tools to update your own, personal, in-core\ncopy of the ISPF command table.  When you are in an ISPF session and\nyou enter a command on the command line, the ISPF command table is\none of the first places that ISPF tries to look, to interpret your\ncommand.  Since we're systems programmers, we sometimes update DASD\ncopies of the ISPF command table and put them in our own ISPTLIB\ndataset concatenations, but with this new technique, you can walk into\na shop, copy 3 REXX execs into a SYSPROC or SYSEXEC library and a\ncontrol member into your userid.ISPF.ISPPROF dataset.  Then you can\nupdate your own ISPF command set at will.  It's a very quick and easy\nsetup procedure.\n\n      The package was written by Willy Jensen of Harders-Jensen in\nDenmark.  It contains 3 execs called ISPCMDL (ISPF command lister),\nISPCMDU (ISPF command updater) and ISPMSG (a service exec to write\nmessages--this was the missing piece).  The control member, called\nISPCOMND, can be copied to your ISPF profile dataset, and edited to\nyour taste.  The ISPCMDU exec, as coded, should default to looking for\nits control statements at this location.\n\n      The control member ISPCOMND is coded as in Figure 2.  To add\nor update a command, you start with a slash and delimit the (usual)\nfour fields with slashes.  The first field is the command itself.  The\nsecond field is the abbreviation number.  If the abbreviation number\nis 0, then the command must be entered as stated, and cannot be\nabbreviated.  If the number is positive, from 1 to 8, then you only\nhave to enter that number of characters to issue the command.  For\nexample, a command called DOTHEJOB with an abbreviation number of 3,\ncan be entered as DOT, DOTH, DOTHE, and so forth, up to the full\nlength of its name.\n\n      The third field is the ISPF statement to be executed.  For\nexample, it might be a \"SELECT CMD\", a \"SELECT PANEL\", or a\n\"SELECT PGM\" statement, with the proper invocation parameters.\nThe fourth field is the text description, which serves as documentation\nfor what the command does.  Anyone who has ever added a command to the\nISPF command table, using ISPF option 3.9, knows about these fields.\nThe File 349 documentation member $$$DOC tells you how to delete an\nactive command, too, as well as how to add or update a command.\n\n      The neat thing about this package is its simplicity.  To begin\nusing the package, enter TSO ISPCMDL on the command line, which\ndisplays all of the current ISPF table entries.  Then (after\ncustomizing your ISPCOMND member of userid.ISPF.ISPPROF), you enter\nTSO ISPCMDU, and you receive a message stating how many commands were\nadded, deleted, or updated.  The first time you enter TSO ISPCMDU,\nyou'll probably see the message stating that a number of commands\nwere ADDED.  The next time you enter TSO ISPCMDU, these commands will\nbe shown as UPDATED, because they were already there, from the first\nISPCMDU invocation.  And that's it.  You can start using these new\ncommands immediately.  There's no need to recycle ISPF, because\nyou've updated the incore command table in your TSO address space.\nNow invoke TSO ISPCMDL again, and you'll see all your new commands,\nnicely displayed.\n\n      My sample command table updates, partially shown in Figure 2,\nare a copy of the options taken from the ISPF main menu, and the menu\nfor ISPF option 3.  The commands themselves are prefixed by the\nletters \"SP\".  It works like this.  For example, if I enter SP2, my\ncommand table entry will pop an ISPF option 2 panel on my screen, on\ntop of whatever else I was doing.  An SP314 command will pop an ISPF\noption 3.14 panel up.  You can nest panels.\n\n      This is very handy, because, in effect, it extends our\ncapability to do more things at once under ISPF.  You are not merely\nlimited to two single actions under the two screen splits.  Most of\nthe time we need this, we're in the middle of doing something, and we\nsay, \"Darn it, I have to create a new dataset.\"  With this system,\nyou just enter:  SP32, get a fresh ISPF 3.2 panel, allocate the new\ndataset, and when you end, you go back to whatever you were doing\nbefore.  Try it.  You'll like it.\n\n\nFILE 247 - SYS1.BRODCAST and TSO USERLOGS\n\n      Every MVS system has to have a SYS1.BRODCAST dataset.\nHowever, after you've set up TSO at your installation to use TSO\nUserlogs, SYS1.BRODCAST isn't so useful anymore, according to the\n\"street opinion\".  I say, \"not so\".\n\n      I'm prepared to put my money where my mouth is.  I admit that\nwith only IBM's minimal (i.e. \"next to nothing\") toolset for handling\nthe SYS1.BRODCAST dataset, one feels rather helpless.  But I've\nwritten a rather robust set of tools for managing and using\nSYS1.BRODCAST.  My tools have been around for a few years now, on CBT\nTape File 247.\n\n      Since last month, I've revisited this package to spruce it up\na bit.  The older version of the package, on File 247, works OK.\nYou can get this older version by going to www.naspa.net, clicking\non \"Online CBT\", clicking on \"Download CBT\", and going to\nCBT247.zip.  However, my (somewhat revised) newer version is\navailable at ftp://ftp.cbttape.org/pub/cbttape/adhoc/CBT247.zip ,\nand it's a good bit better.\n\n      Let's start talking about it.  You can display other users'\nTSO messages with the BCMLIST program, or its relatives that display\nmore info:  BCMLIS, BCMLISY, and BCMLISX.  In my newer version, anyone\ncan invoke these, with only READ access to SYS1.BRODCAST.  You issue\na TSO ALLOC command to allocate the ddname BRODCAST to SYS1.BRODCAST\n(with SHR, of course).  Then you issue \"TSO BCMLIST userid\", and the\nBCMLIST command displays that user's messages.  I think that when IBM\ntried (around 1970) to make it impossible to do this, they thought\nthat someone else's messages were private things.  That may have been\ntrue in the \"old days\", when SYS1.BRODCAST was probably the only TSO\nmessaging tool around.  Nowadays, it most likely doesn't matter much.\nIf someone else sees the notifications of your completed jobs, you\nprobably wouldn't holler about it.\n\n      This only works when the other user's messages are in\nSYS1.BRODCAST, not in a TSO Userlog dataset.  However, my package has\nmany other goodies in it.  First, the batch program BCSCAN (which is\nold, from Richard Nikula, but modernized), will give you a global view\nof SYS1.BRODCAST, and will tell you:  how full it is, which users have\nundelivered messages, and how many outstanding messages each user has.\nThis is handy when SYS1.BRODCAST fills up.\n\n      Suppose one user has over 1000 undelivered messages.  (He's a\nguy who left the company 8 months ago, and ten production jobs send\ntheir NOTIFY messages to his id every day.)  How can the administrator\ndelete them?  My package supplies four different ways.  Three\nprograms, BCMDEL, BCMDEL1, BCMDEL2, will display and then delete an\narbitrary user's messages.  Each of these programs works on a\ndifferent principle, and each one may work in a situation when the\nothers won't.  The fourth way is a program, BCMUSDEL, which deletes\nthe user's \"userid record\" in SYS1.BRODCAST itself.  BCMUSDEL uses\nIBM's official SYS1.BRODCAST programmable interface, and when you\ndelete a userid with this method, all its messages will be cleaned off\nnicely, too.\n\n      You can learn much more about this package by reading the\n$$$DOC member of File 247.  But before leaving this topic, I'll tell\nyou a novel idea about how you can use a nice big, empty SYS1.BRODCAST\ndataset, that stays nearly empty, because all the TSO users are getting\ntheir messages via their Userlogs.  You thought that this big, ugly,\nnearly empty SYS1.BRODCAST was useless, huh?\n\n      With my package, it isn't.  If you're careful not to fill it\nup, you can use that big, empty messaging space for production control\ntesting.  Suppose there's a daily production job that's been failing\nonce in a while, under mysterious circumstances.  To make matters\nmore interesting, suppose that the JCL in the production job run\ngets purged pretty quickly, or suppose, if there's an abend, it purges\nitself, leaving almost no trace in spool.  This is not too likely a\nsituation, but I'd bet it occurred at least once in nearly everybody's\ncareer.  How can we go about tracking the times when a bad run has\noccurred?\n\n      We can do it with a NOTIFY= parameter in the JOB card of the\nproduction job.  Upon job completion, NOTIFY causes MVS to issue an\noperator SEND command, which sends the job completion notification to\na TSO user.  What if there's no TSO user to send the notification to?\nIn that case, MVS purges the message, because, if the SYS1.BRODCAST\ndataset doesn't know about the userid, there's no place to store its\nmessages.  Now, using my BCMUSADD TSO command, we can create an\narbitrarily-named userid record in the SYS1.BRODCAST dataset, which\nexists nowhere else, and we can code NOTIFY=thatid on the production\nJCL jobcard, to point to the new userid.  Or we can create a new\nuserid name to match the RACF userid (even if that userid doesn't have\na TSO extension) that the production job gets submitted under.  In\neither case, the NOTIFY messages will start accumulating in\nSYS1.BRODCAST, under the newly \"created\" userid.  You can display and\nprint these messages with the BCMLIST program, and you can delete them\nwith one of the BCMDELx programs.  With these tools, you have the\nability to track the times of the production job runs, and no TSO user\ncan purge the information (in the ordinary way with LISTBC), because\nno one can logon to this specially created \"userid\".  It's a nifty\ntrick.  The method is available, if and when you need it.\n\n\nSOME OTHER NICE PACKAGES\n\n      Space is short, and I'd like to conclude by mentioning some\nother important packages briefly.  Lionel Dyck, in File 312, has\ncontributed two important tools, FTPBATCH and XMITIP.  FTPBATCH\nprovides an interface for setting up multiple file transfers in batch,\nusing FTP.  XMITIP allows you to send email messages across the\nInternet, directly from TSO on your MVS system.  Lionel keeps tweaking\nand improving these packages.  It pays to take a good look at File\n312, and keep following his updates.\n\n      Files 035 and 135, the load module libraries, have been much\nneglected in this column, so I'd like to say a word about them.\nMany sysprogs like to always \"assemble their own stuff\", because when\nyou assemble your tools, they're most likely to best match the level\nof the operating system that they're running on.  Nevertheless, the\n\"quick install\", that is, copying load modules into an executable\nlibrary, sometimes saves the day.  On Files 035 and 135, load modules\nof useful programs such as PDSLOAD (our IEBUPDTE substitute that\npreserves ISPF statistics) and CBT973 (the CBT Tape decompression\nutility) are instantly available.  If you want to try REVIEW or\nSHOWMVS, which are big programs, but easy to run under TSO, you have\nthe shortcut of copying them out of File 135 and running them.\n\n      Files 035 and 135 are updated to match the level of source code\nthat's on the source files they come from.  Since they're quite\ncurrent, it's usually a good bet that most of their files will run\nproperly on a modern MVS or OS/390 system.  When you get a new version\nof the CBT Tape and you're trying out an updated version of one of\nthese programs for the first time, a \"test in a hurry\" could consist\nof copying some load modules out of File 035 or File 135.\n\n      Well, I guess it's time to go.  I hope you've gained something\nfrom this month's \"sojourn into the unknown\".  There's a lot more\nmaterial awaiting you on Version 420 of the CBT Tape.  Please spend\nsome time looking at Figure 1.  See you next month.\n\n\n *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   Summary of File Changes in Version 420 of the CBT Tape.\n\n\n File Number         Quick Summary of Contents or Changes\n -----------         ------------------------------------\n\n  001           Documentation File is now in mixed case.\n  004           CBTUPDTE edit macro - IEBUPDTE separators in File 001\n  006           Tools to manipulate File 001 and improve readability.\n  035           Load module library. Latest version of PDS 8.5 etc.\n  071           Updated documentation of other tapes. JES3 Tape.\n  118           SMP/E SMPPTFIN pre-processing.  Upgrade to COBOL/370.\n  120           More of these articles.  (MVS Tools and Tricks)\n  130           Former File 006. Loads File 001 into INFO/MVS database.\n  134           Greg Price source.  Latest version of REVIEW, etc.\n  135           Greg Price load modules.  SHOWMVS load module, etc.\n  166           Vinh Vu's collection, updated.\n  171           LU 6.2 Bulk Data transmitter. With DITTO, DISASM etc.\n  182           PDS package. Version 8.5, update 8, from John Kalinich.\n  183           Gilbert Saint-flour collection.  New SHOWMVS program.\n  296           Utilities that work with PDS 8.5, and standalone too.\n  300           Update to CDSCB for Y2K. With zillion other TSO pgms.\n  311           Refresh of Dave Alcock's large utility collection.\n  312           Lionel Dyck's ISPF FTP Batch interface, and XMITIP.\n  321           Roland Schiradin's COBOL load module analysis pgm.\n  338           Gilbert Saint-flour and Larry Williams - P390 tools.\n  344           REXX exec from Joerg Berning to do a VTOC map.\n  347           Look at load library and list COBOL compile options.\n  348           Pgms to list pds members in alphabetical order.\n  349           Change your ISPF command table options on the fly.\n  350           JES2 exits. Convert JCL from Mellon Mods to SCHENV=.\n  351           Programs to list currently installed LE level.\n  354           Randy Hall collection of programs. New. BACKDSNS etc.\n  355           KONCAT (concatenation program) from Kaiser Permanente\n  356           NETSOL (VTAM multi-session manager). Works for OS/390.\n  357           PDSGEN, PDSLIST programs from Carl Hafner of Steli.\n  358           SYSOUT writer from Eric Bielefeld.\n  361           Frank Johnston programs. Multi-string scanner, etc.\n  362           Frank Johnston load modules.\n  363           ISPF/PDF Data Set Name change exit. (ISPF exit 16)\n  364           Control Card Subsystem. Works for OS/390.\n  365           Error-check multiple-file TSO XMIT pkg from Ron MacRae.\n  369           Multiple changes to DSPACE program from Dale Vick.\n\n\n\n *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.   Sample ISPCOMND member to update the incore copy\n            of your ISPF command table using the REXX exec\n            ISPCMDU from Willy Jensen (CBT Tape File 349).\n            You copy this member into your ISPF.ISPPROF dataset,\n            and edit it according to your taste.  Each line\n            adds a separate new ISPF command.  The new\n            commands are usable immediately after invocation\n            of the ISPCMDU exec.\n\n\n/*    MEMBER TO UPDATE THE ISPF COMMAND TABLE IN STORAGE  */\n/*  ------ you should enjoy using this immensely ------   */\n/*  ------     Invoke by issuing TSO ISPCMDU     ------   */\n/SHOWMVS/5/SELECT PGM(SHOWMVS)/INVOKE SHOWMVS COMMAND/\n/PDE/0/SELECT PANEL(PDS@PRIM)/STARTOOL OR PDS 8.5 MAIN ENTRY PANEL/\n/SX/0/ALIAS SAVE                    /SHORT FORM OF SAVE/\n/SP0 /0/SELECT PGM(ISPISM) SCRNAME(SETTINGS)/ISPF 0/\n/SP1 /0/SELECT PGM(ISRBRO) PARM(ISRBRO01) SCRNAME(VIEW)/ISPF 1/\n/SP2 /0/SELECT PGM(ISREDIT) PARM(P,ISREDM01) SCRNAME(EDIT)/ISPF 2/\n/SP3 /0/SELECT PANEL(ISRUTIL) SCRNAME(UTIL)/ISPF 3/\n/SP4 /0/SELECT PANEL(ISRFPA) SCRNAME(FOREGRND)/ISPF 4/\n/SP5 /0/SELECT PGM(ISRJB1) PARM(ISRJPA) SCRNAME(BATCH) NOCHECK/ISPF 5/\n/SP6 /0/SELECT PGM(ISRPTC) SCRNAME(CMD)/ISPF 6/\n/SP7 /0/SELECT PGM(ISPYXDR) PARM(&ZTAPPLID) SCRNAME(DTEST) NOCHECK/SP7/\n/SP8 /0/SELECT PANEL(ISRLPRIM) SCRNAME(LMF)/ISPF8/\n/SP9 /0/SELECT PANEL(ISRDIIS) ADDPOP/ISPF 9/\n/SP10 /0/SELECT PGM(ISRSCLM) SCRNAME(SCLM) NOCHECK/ISPF 10/\n/SP11 /0/SELECT PGM(ISRUDA) PARM(ISRWORK) SCRNAME(WORK)/ISPF 11/\n/SP31/0/SELECT PGM(ISRUDA) PARM(ISRUDA1) SCRNAME(LIBUTIL)/ISPF 3.1/\n/SP32/0/SELECT PGM(ISRUDA) PARM(ISRUDA2) SCRNAME(DSUTIL)/ISPF 3.2/\n/SP33/0/SELECT PGM(ISRUMC) SCRNAME(MCOPY)/ISPF 3.3/\n/SP34/0/SELECT PGM(ISRUDL) PARM(ISRUDLP) SCRNAME(DSLIST)/ISPF 3.4/\n/SP35/0/SELECT PGM(ISRURS) SCRNAME(RESET)/ISPF 3.5/\n/SP36/0/SELECT PGM(ISRUHC) SCRNAME(HARDCOPY)/ISPF 3.6/\n/SP37/0/SELECT PANEL(ISPUDL) SCRNAME(DOWNLOAD)/ISPF 3.7/\n/SP38/0/SELECT PGM(ISRUOLP) SCRNAME(OUTLIST)/ISPF 3.8/\n/SP39/0/SELECT PANEL(ISPUCMA) ADDPOP SCRNAME(CMDTABLE)/ISPF 3.9/\n/SP311/0/SELECT PGM(ISRFMT) SCRNAME(FORMAT)/ISPF 3.11/\n/SP312/0/SELECT PGM(ISRSSM) SCRNAME(SUPERC)/ISPF 3.12/\n/SP313/0/SELECT PGM(ISRSEPRM) SCRNAME(SUPERCE) NOCHECK/ISPF 3.13/\n/SP314/0/SELECT PGM(ISRSFM) SCRNAME(SRCHFOR)/ISPF 3.14/\n/SP315/0/SELECT PGM(ISRSEPRM) PARM(S4) SCRNAME(SRCHFORE) NOCHECK/3.15/\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9907JL": {"ttr": 19715, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x99\\x17_\\x01\\x00)\\x9f\\x11G\\x01b\\x01b\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1999-06-24T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 354, "newlines": 354, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                            JULY 1999\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@attglobal.net or sbgolob@aol.com.\nInformation about the CBT MVS Tapes can be found on the web, at\nhttp://www.naspa.net , after clicking on \"Online CBT\".\n\n\nWRITING YOUR OWN TSO COMMAND PROCESSOR - Part 1\n\n      Sometimes we surprise ourselves.  Lately, I've done it a lot.\nI'm finding that I know how to code in assembler language, far better\nthan I thought I could.  When I was first starting out in this business,\nI used to look at many amazing programs that other people wrote,\nespecially those of my teacher, Jeff Broido.  I wondered whether I would\never produce similar pieces of work, later on in my own career.\n\n      Even when I broke in (many years ago), MVS Systems Programming\nno longer required the writing of customized assembler code all day.\nIt was already a job that largely consisted of installing and tweaking\nthe operating system, to make sure everything was working properly.\nSure, I went to assembler school and managed to code a few exits here\nand there.  But writing major utilities that were hitherto\nunavailable, was no longer part of the job description.  So I didn't\nget extensive assembler coding practice on a regular basis.  If it\nweren't for my involvement in handling free code from the CBT MVS Tape,\nand looking at a lot of source code examples from there, I feel that\nI'd never achieve the satisfaction of building my assembler skills to\nthe point where I myself could do something major.\n\n      Today, we're going to talk about how to create an assembler\nprogram which does a useful task under TSO.  Nowadays, we have REXX\navailable, and most of us try to create our handy little personal tools\nin REXX.  But despite the large capabilities of the REXX language under\nTSO, I feel it is still a worthwhile skill to write assembler programs\ntoo.  Assembler programs can execute faster.  And assembler programs\nhave full access to all facilities of the operating system.  When you\ncode in assembler, you are not subject to any artificial restrictions\nas to what your programs can do.\n\n      When I first started, I thought that writing a \"TSO Program\",\nor more exactly, a \"TSO Command Processor\", was something that was\nquite difficult.  IBM's manual on the subject, which was called,\n\"Writing a TSO Command Processor or TMP\" (Terminal Monitor Program),\nlooked very difficult to get through.  Actually, I found later, that I\ncould write many working programs, without having deep knowledge.\nKnowing a few fundamental principles was enough.  Today, I want to\nhelp you \"cut through the ice\", so you too, can start doing this stuff\nyourself.  IBM's current manual on this subject, called TSO/E\nProgramming Guide, is much easier to read than the old IBM manual was.\n\n\nHow is a TSO Command Processor Different?\n\n      A TSO Command Processor, or (in other words) a program that is\ndesigned to be executed during a TSO session, is not much different\nfrom any program that's designed to run in batch.  When you enter the\nprogram, you have to save the registers using the normal conventions,\nand when you leave the program, you have to restore the registers in\nthe usual way.  Register 15 comes into the program, pointing to the\nentry point, and Register 14 contains the return address of the caller.\nThe main difference is Register 1, which points to a TSO control block\ncalled the CPPL, or Command Processor Parameter List.  We'll talk about\nthe CPPL in the next section.\n\n      But first, let's backtrack a bit.  Let's ask ourselves the\nquestion:  What exactly is a TSO command?  The answer is that a TSO\ncommand is a load module.  When you type a TSO command on the screen\nduring a TSO session, you're actually executing a load module, which\nhas that command name.  For example, if you execute a TSO SEND command,\nto send a message to another TSO user or to the console operator,\nyou're actually executing a load module whose name is \"SEND\".  The way\nIBM ships this command, SEND is a load module in SYS1.CMDLIB, a library\nthat is filled with many essential TSO commands, such as DELETE,\nALLOCATE, ACCOUNT, DEFINE, CALL, and so forth.  Each of those commands\nis a separate load module in SYS1.CMDLIB.  Your TSO session has access\nto these commands because SYS1.CMDLIB is in the system link list, and\nall programs executing under MVS, have access to programs in the system\nlink list.\n\n      Now suppose you had access to another program whose load module\nname was SEND, and you copied or linkedited its load module into\nanother load library that was pointed to as a STEPLIB in your TSO Logon\nProc.  Since the STEPLIB library is accessed in your TSO session before\nthe link list libraries are accessed, when you type a SEND command in\nTSO, you'll execute your own personal SEND program, and not IBM's SEND\nprogram.  If you wanted access to IBM's SEND program again, you'd have\nto either rename your own load module to another name, like SENDX, or\nyou'd have to delete it from your STEPLIB library.  The rename route is\nprobably the more useful one to take, because if you want your own\nprogram instead of IBM's, you can still issue the SENDX command under\nyour TSO session, whereas if you deleted your own version, you could no\nlonger execute it at all.\n\n      There's one last topic we have to cover, before we can go back\nto talking about actually writing the program.  That's the question of\nAPF authorization.  MVS provides a \"safety net\" for most programs, so\nthey don't change essential system control blocks in such a way that\nthey'd damage the system.  However, if a program, or in our case a TSO\ncommand, has to perform a system internals function that's normally\nprotected, we can \"authorize\" it to do so.\n\n      The program authorization facility in MVS is called \"APF\nAuthorization\" (for Authorized Program Facility).  IBM's SEND command\nis an example of an authorized program.  Why does SEND need to be\nauthorized?  Many installations allow the average TSO user only READ\naccess to SYS1.BRODCAST, a dataset which contains TSO user messages and\nsystem notifications to TSO users.  You certainly wouldn't want to give\nan average user RACF UPDATE access to SYS1.BRODCAST.  By mistake, the\nuser could then overwrite SYS1.BRODCAST with IEBGENER, or do some other\nstupid thing, and we want to protect against that.  But we also want\nall TSO users to be able to send messages to other TSO users, even if\nthe other users aren't logged on.  These messages would go to the\nSYS1.BRODCAST dataset, normally (if TSO Userlogs aren't invoked).\nTherefore, every TSO user has to be able to update the SYS1.BRODCAST\ndataset in this special way, by using the SEND command.\n\n      So the problem gets solved by \"authorizing\" the SEND command\nusing the APF facility, and when the SEND command is authorized, it\ncan circumvent the normal TSO user's \"read only\" restriction to\nSYS1.BRODCAST.  The newly empowered SEND command, can then do the\nwriting of the message to SYS1.BRODCAST, on behalf of the normally\nunempowered TSO user.\n\n      To authorize the SEND command, or any other TSO command, we have\nto mark its load module (in the pds directory of the load library) as\nAPF authorized, and the library itself has to be made known to the\nsystem, through the APF authorization table, as an APF authorized\nlibrary.  In former releases of MVS, all link list libraries would\nalways be APF authorized by default, but now, through the IEASYSnn\nparameter, LNKAUTH, this doesn't have to be the case.  The system\nauthorization table is defined (in modern MVS systems) by the PROGnn\nmember of PARMLIB.  There's one more catch though.  In the IKJTSOnn\nPARMLIB member, a TSO command has to be listed among the programs in\nthe AUTHCMD program list.  Otherwise TSO (and not the MVS system itself)\nwill block the APF authorization of the program execution.  So to\nauthorize a TSO command, we need all three conditions to be fulfilled:\nits load module has to be marked APF authorized through the SETCODE\nAC(1) linkedit statement, it has to reside in an APF authorized load\nlibrary, and it has to be listed in the AUTHCMD list of the IKJTSOnn\nmember of PARMLIB.\n\n      I'd like to relate a personal technique I've discovered, for\nobtaining what I call \"personal APF authorization\".  The AUTHCMD and\nAUTHPGM program lists, used to be made known to TSO in two csects,\ncalled IKJEFTE2 and IKJEFTE8 respectively.  Once upon a time, those\ncsects were part of the terminal monitor program IKJEFT02, but now\nthey still exist, in a separate small load module called IKJTABLS.  You\ncan find the default IKJTABLS in SYS1.LPALIB, and it doesn't have much\nin it.  My trick is that if you put your own (greatly expanded) version\nof IKJTABLS in an authorized STEPLIB library in your personal TSO Logon\nProc, it will completely override all the settings in the active\nIKJTSOnn member of PARMLIB.  This trick is intended for experienced\nsystems programmers only, but it's very useful when you're working on a\nlarge system, where you can't disturb the global PARMLIB settings that\neverybody else uses.\n\n\nWRITING YOUR OWN TSO PROGRAM\n\n      Now that we've gone through these preliminaries, we'll talk\nabout how to use the CPPL, how to use IBM's TSO facilities, and how to\nwrite handy TSO utilities that will enhance your working life for years\nto come.  We'll have to continue this topic next month too, because\nthere's a lot to say.\n\n      Take a look at Figure 1, which is the IKJCPPL macro that maps\nthe Command Processor Parameter List, that is passed to your program\nvia Register 1.  The CPPL contains four address pointers, and when\nyour program gains control, the first thing you should do, is to copy\nthese address pointers into program storage so you can refer to them\nlater.  At this point, we're most concerned with the contents of the\ncommand buffer.  But the other pointers, to the UPT, the PSCB, and\nthe ECT, will come into play later, when we might need to examine the\ncontents of these 3 important control blocks.\n\n      As its name implies, the Command Buffer contains everything\nyou entered into a TSO command when you invoked its command processor\nprogram under TSO.  In addition, the Command Buffer starts with a\n4-byte header that is divided into 2 halfwords.  The first halfword\ncontains the binary numeric length of the entire command buffer,\nincluding the header.  The second halfword contains a numeric value\nknown as the \"offset\".  This offset field conveniently points you to\nthe beginning of any command operands.  Or it contains the number of\ncharacters in the command itself, if there aren't any extra operands.\nI'll explain.\n\n      Suppose I entered a TSO command:  RENAME DATASET.A DATASET.B .\nThis command (RENAME), with its operands (the dataset names), contains\n26 characters in all.  If I entered more than one space between the\noperands, the command would be longer.  Now if I entered this command\nat the beginning of a line on my TSO terminal, the command buffer\nwould then be 30 bytes long--4 bytes for the header, and 26 bytes for\nthe command with all its text that follows.  In this scenario, the\noffset would contain the number 7, which is the number of text bytes\nbefore the first operand:  DATASET.A .  So to point to DATASET.A ,\nso I can parse it, I'd do the following:  Please refer to Figure 2\nfor details.\n\n      I'm assuming I've saved the pointer containing the address of\nthe command buffer, that was in Register 1.  I'll do a Load Register\ninstruction, LR  R11,R1 , to move the address of the command buffer\nfrom the (changeable) Register 1 to the less-used Register 11.\n\n      First, I point to the address of the command buffer, which is at\nan offset of 0 bytes past Register 1.  I pick up the number of bytes in\nthe command buffer by a Load Halfword instruction:  LH  R3,0(,R1) , to\nplace the total number of bytes in the command buffer in a register--in\nthis case, Register 3.  Then I do a Store Halfword instruction to save\nthis value in my program.  That is:  STH R3,CMBLENG , where CMBLENG is\na 2-byte field in my program.  In our case, CMBLENG will now contain\nthe binary value of 30, or hex 001E.  Before changing the value of\nRegister 3, it's advisable at this point, to check to see that its\nvalue is greater than 4, just to make sure that a command was entered.\nWe issue a Compare Halfword instruction:  CH  R3,=H'4' , and a BNH\n(Branch Not High) instruction afterwards, to point to an error-handling\nroutine, or to get out of the program with a warning message.  To pick\nup the value of the offset, which is a halfword, two bytes past\nRegister 1, we issue a LH  R3,2(,R1) , and then issue STH  R3,OFFSETT ,\nwhere OFFSETT is another 2-byte field in our program.  In our case,\nOFFSETT will now contain the hex value 0007.\n\n      Now, we can utilize the condition code capabilities of the\nSubtract instructions, to determine if we have any operands or not,\nand if we have them, we can take the appropriate action.\n\n      Load the length of the command buffer into work Register 5,\nusing LH  R5,CMBLENG .  Load the offset into Register 3 if it isn't\nalready there:  LH  R3,OFFSETT .  Issue the Subtract Register\ninstruction:  SR  R5,R3 , to subtract the offset value from the total\nlength of the command buffer.  Since the command buffer has a 4-byte\nheader, we can now issue a Subtract Halfword instruction:\nSH  R5,=H'4' , to subtract 4 more bytes from the offset difference,\nto account for the length of the header record.  If the resulting\nvalue is zero, there were no operands entered after the command.\nIf the resulting value is less than zero, there's an error condition,\nand if the resulting value is greater than zero, we've got operands\nto parse.  We can check all of this, using the return codes from the\nSubtract Halfword instruction.\n\n      By looking up the Subtract instructions in the Principles of\nOperation Manual, we see that a zero result gives a condition code of\n8 (byte 0 is one).  A negative result gives a condition code of 4\n(byte 1 is one), and an overflow result gives a condition code of 1\n(byte 3 is one).  Thus, to test for these conditions, we issue the\nBranch on Condition (BC) instruction as follows.  First to test for\nthe zero result (no command operands), we issue:  BC  8,ERRMSG1 ,\nto issue a message that the command should be entered with operands.\nThen, we test for the negative or overflow conditions with the\ninstruction:  BC  5,GETOUT1 , to handle that case, and get out of the\nprogram.\n\n      Now, we're ready to parse our operands.  Register 11 contains\nthe address of the command buffer, that was copied from Register 1\noriginally.  So we point to the contents of the command buffer in\nRegister 1 as follows:  LA  R1,0(,R11) ,  add the offset value to it:\nAR  R1,R3 , (possibly after LH  R3,OFFSETT), bump the value up by 4, to\ncompensate for the Command Buffer header:  LA  R1,4(,R1) , and now R1\nis pointing to the location in storage where the operands begin.\n\n      We now have a choice.  We can either examine our command's\noperands ourselves, by writing our own instructions, or we can use\nIBM's official TSO command parsing interface called IKJPARS.  I don't\nhave the space to continue the discussion past this point now, so\nwe'll pick it up here, next month.  See Figure 2 for the instructions\nwe've executed so far.\n\n      If you're fairly new to assembler, I hope you've gotten a\nrealization that \"I can really do this\".  You really can.  It's quite\neasy, once you've gotten the hang of it.  The CBT MVS Utilities Tape,\nwhich you can access online over the Internet, has very many coding\nexamples of TSO commands, which you can learn from.  I'd especially\nrecommend File 300 of the CBT Tape, which you can access directly\nat  ftp://ftp.cbttape.org/pub/cbttape/cbt/CBT300.zip  (case sensitive).\nTo see the CBT Tape offerings in general, go to www.naspa.net , and\nclick on \"Download CBT\".  You'll have a lot to look at.\n\n      Good luck.  I'm looking forward to seeing you next month.\n\n *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   Mapping macro for the CPPL (Command Processor Parameter\n            List).  At entry to any TSO command invoked by the TSO\n            Terminal Monitor Program, Register 1 points to the address\n            of the CPPL.  A principal part of writing a TSO command,\n            is to exploit this information to the extent that's\n            necessary.\n\n\n         MACRO\n         IKJCPPL\n******************************************************************\n*    THE COMMAND PROCESSOR PARAMETER LIST (CPPL) IS A LIST OF    *\n*    ADDRESSES PASSED FROM THE TMP TO THE CP VIA REGISTER 1      *\n******************************************************************\nCPPL     DSECT\nCPPLCBUF DS    A        PTR TO COMMAND BUFFER\nCPPLUPT  DS    A        PTR TO UPT\nCPPLPSCB DS    A        PTR TO PSCB\nCPPLECT  DS    A        PTR TO ECT\n         MEND\n\n\n *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.   Coding example to point to where the operands of your\n            TSO Command start, so you can parse them to determine\n            their values.\n\n            We assume you've established your base registers and\n            saved the caller's registers.\n\n\n         LR    R11,R1         Preserve the pointer to the CPPL\n         LTR   R11,R11        Any CPPL?  No. Not a TSO command.\n         BZ    ERRORA         Not TSO. Get out.\n         L     R1,0(,R11)     Point to the command buffer.\n         LTR   R1,R1          Any command buffer?\n         BZ    ERRORB         No. Handle the error.\n         LH    R3,0(,R1)      Load command buffer length\n         STH   CMBLENG        Save value in the program\n         CH    R3,=H'4'       Is there a command there?\n         BNH   ERROR1         No command or error, handle it.\n         LR    R5,R3          Length of command + 4 into R5\n         LH    R3,2(,R1)      Load value of offset into R3\n         STH   OFFSETT        Save offset value in the program\n         SR    R5.R3          Subtract offset from length + 4\n         SH    R5,=H'4'       Correct for length of CMDBUFR header\n         BC    8,MESSAGE1     Zero, send 'no operands' message\n         BC    5,ERROR2       Negative or overflow, get out.\n* ------------------------------------------------------------------\n         LA    R1,0(,R11)     Load address of command buffer\n         LA    R1,4(,R1)      Point past the header\n         LH    R3,OFFSETT     Reload offset quantity into R3\n         AR    R1,R3          Point to the first command operand\n* ------------------------------------------------------------------\n*    At this point, R1 is pointing to the address of the first\n*    operand of our command, so we can parse it for its values.\n* ------------------------------------------------------------------\n\nCMBLENG  DS    H              Store length of command buffer\nOFFSETT  DS    H              Store value of offset\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9908AU": {"ttr": 19722, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x99\\x18\\x9f\\x01\\x00)\\x9f\\x11G\\x01\\x8f\\x01\\x8f\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1999-07-08T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 399, "newlines": 399, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           AUGUST 1999\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@attglobal.net or sbgolob@aol.com.\nInformation about the CBT MVS Tapes can be found on the web, at\nhttp://www.naspa.net , after clicking on \"Online CBT\".\n\n\nWRITING YOUR OWN TSO COMMAND PROCESSOR - Part 2\n\n      This month, we'll continue to build on last month's topic, about\nhow you can write your own TSO command processor.  We mentioned that\nnowadays, with the great potential power of REXX execs under TSO, most\npeople might want to write their handy utilities in REXX.  However,\nthere is still much cause to write your own TSO command processors, or\neven to just understand how they work.\n\n      If you understand how TSO command processors work, you might be\nable to easily alter someone else's TSO command processor, so it'll do\nwhat you need.  You might not have to exert the effort of completely\nwriting your own program.  Where can you find samples of TSO command\nprocessor source code?  The free collection of MVS goodies, including\nthe CBT MVS Utilities Tape with the CBT Overflow Tape, contains large\nnumbers of working TSO programs which you can study and change.  You\ncan download files from the CBT Tape materials, by going to the NaSPA\nhome page, www.naspa.net, and clicking on \"Online CBT Tape\".\n\n      As we mentioned last month, a TSO command processor is a program\nthat was designed to run under TSO.  The load module name, or one of its\naliases, is what you execute.  To execute a TSO command, you type the\nload module name and its operands on the command line of an ISPF session\n(prefixed by \"TSO\").  Or under \"TSO ready mode\", you type the command's\nload module name, together with its operands.  A TSO command has\npotential access to all system functions, especially if it runs\nauthorized.  And it runs fast--usually far faster than an equivalent\nREXX exec.\n\n      A load module that's designed to run as a command under TSO, is\na bit different from other load modules in one respect.  Upon entry,\nRegister 1 is expected to point to a TSO control block (created by\nyour TSO session) called the CPPL, or Command Processor Parameter\nList.  The CPPL contains four address pointers:  The first pointer\npoints to a buffer which contains your command and its operands, known\nas the \"command buffer\", and the other three point to three TSO control\nblocks:  the UPT (the User Profile Table), the PSCB (Protected Step\nControl Block), and the ECT (Environment Control Table).  The command\nbuffer contains a four-byte prefix.  The first two bytes contain the\nlength of the entire command buffer, and the second two bytes contain\nthe offset from the beginning of the buffer where any operands start, if\nthere are any.\n\n      Last time, we showed how to use this command buffer prefix\ninformation to parse the operands ourselves.  This time, we'll show you\nhow to start looking into some of the \"official tools\" that IBM has\nprovided.  We'll look into the IBM parsing tool, IKJPARS, in some\ndetail, and that will indicate the kind of work necessary to set up some\nof the other \"official IBM tools\".  However, IBM manuals tend to\ncomplicate matters unnecessarily, and scare you into thinking you have\nto do too much preparation.  And there is also another big \"saving\nfactor\", in that once you've set up the IBM facilities in one program,\nyou can copy them over to any other program, almost without change.  Do\nit once, and that's enough!\n\n\nLet's Get Going with Examples.\n\n      I think that when you study TSO commands, you should have a coding\nexample, printed out in front of you, to look at.  If you see \"how the\nother guy did it\", it'll be much quicker to learn how to do it yourself.\nStart out by looking at Figure 3, which roughly shows the steps that\nare required to write a TSO program.  Then start looking for some code\nsamples to learn from.\n\n      Before talking about coding examples, I'd just like to mention the\nsimple fact, that using the IBM facilities like IKJPARS and PUTLINE and\nIKJDAIR (the TSO dynamic allocation interface) might appear to be\nfrightening and complicated at first.  But the truth is that once you've\ndone it once, you can copy almost the same code into all your other\nprograms.  You can even copy this code from a coding example, straight\ninto your program.  It helps, however, to have some understanding of\nwhat you're doing, so you don't get caught by some obscure bug.\n\n      A good IBM example that comes with source code, is the PRINTOFF\nprogram that used to be distributed with CBIPOs from IBM.  (I think the\nPRINTOFF source code was in IPO1.SAMPLIB.)  PRINTOFF is a TSO command\nthat will format a dataset for printing at a printer.  If you can't find\na copy of PRINTOFF to study, because (I think) it's no longer\ndistributed with the OS/390 installation materials, there are several\nexamples of PRINTOFF source code on the CBT Tape, that have been\nmodified from IBM's distributed version.  One example of PRINTOFF source\nis on CBT Tape File 300, and a better example is on File 325.\n\n      PRINTOFF, although it uses most of the IBM-supplied TSO functions,\nis a bit complicated for a beginner, so I'd suggest a program like LPSCB\n(List the PSCB) from CBT Tape File 300 to start studying.  LPSCB only\nuses the IBM Parser (IKJPARS) and the IBM Putline Service (IKJPUTL or\nits CVT pointer), so it's simpler than PRINTOFF, which also uses IBM's\nallocation service and error code handling.  PRINTOFF also has a far\nmore complicated operand structure than LPSCB, so we'll look at LPSCB as\nour introductory example.  However, if you don't like either PRINTOFF or\nLPSCB, or if you're having trouble understanding them, there are several\nhundred other TSO programs to look at, on CBT Tape File 300 alone.\n\n      What does LPSCB do?  LPSCB is a TSO command which displays the\ncontents of the three \"other CPPL control blocks\":  the PSCB (its\ndefault), and optionally, the UPT, and the ECT.  If you invoke the LPSCB\ncommand (as I've modified it) with the operand ALL, you get a formatted\ndisplay of all these three control blocks for your own TSO session.  If\nyou code the optional keyword ECT, you get the PSCB and ECT only.  If\nyou code the keyword UPT, you get the PSCB and UPT only.\n\n      Please look at Figure 1, to see the macros you have to code, to\ntell the TSO Parser program, IKJPARS, the structure of permissible\noperands for LPSCB.  These are only keyword parameters.  LPSCB has no\npositional parameters.  Now look at Figure 2, which shows the macros\nthat were coded to show the permissible operands for the PRINTOFF\ncommand.  See how much more complicated the PRINTOFF operands are, than\nthe LPSCB operands?\n\n      The key to using the IBM Parser, IKJPARS, is to decide\nbeforehand, what all the possible operands for your command processor\nprogram will be.  Then, you can figure out how to code all the macros\nbetween the IKJPARM macro and the IKJENDP macro, so you can easily\nparse for the operands that your command will need.  Before calling\nthe IKJPARS routine, your program will have to perform some routine\nsetup, which is similar for all TSO commands that use the IKJPARS\nservice.  Most TSO programs that use IKJPARS, perform this setup\nprocedure near the beginning, because one of the first things they have\nto do, is to examine what operands were coded in the command\ninvocation, and act accordingly.  Therefore, they set up for IKJPARS,\nand then invoke it with a LINK or CALLTSSR macro, not far from the\nprogram's entry point.  After return from IKJPARS, the program examines\nwhich operand fields were coded, and goes on intelligently with the\nrest of its processing.\n\n      To set up for using IKJPARS, you have to create an 8-fullword\narea, and fill at least 7 fullwords of it.  This is called the PPL,\nor Parse Parameter List.  The Parse Parameter List is mapped by the\nIKJPPL macro in SYS1.MACLIB.  Before you call IKJPARS, you have to\npoint Register 1 to the Parse Parameter List.\n\n      The seven addresses of the Parse Parameter List are (in order):\nThe address of the UPT, the address of the ECT, the address of an\nempty ECB (a fullword of hex zeros), the address of the PCL (the\nParameter Control List which is your IKJPARM thru IKJENDP macros), the\naddress of the \"Answer Place\"--a location to where IKJPARS will return\nits results, a pointer to the Command Buffer, and finally, a pointer to\nthe User Work Area, which could be the program save area pointed to by\nRegister 13.\n\n      IKJPARS returns the address of its results to the Answer Place,\nand you inquire whether a parameter is present or not, by examining\nkeyword flags.  Look at Figure 1, for example.  If you want to see if\nthe keyword CPPL was specified with an invocation of LPSCB, just code\nthe instruction CLI  REALKW+1,1 .  To see if REAL was invoked, since\nIKJNAME 'REAL' was coded after IKJNAME 'CPPL' under the same REALKW\nIKJKEYWD macro, you code the instruction CLI REALKW+1,2 .  A Branch on\nEqual (BE) indicates the presence of the keyword.  Obviously, if you\nhave two IKJNAME keywords coded under the same IKJKEYWD macro, it's\n\"either-or\".  Only one of the two Branch on Equal statements will be\ntrue.\n\nKeeping Things Simple.\n\n      I don't have space to discuss IKJPARS any further right now.\nThe other formal IBM constructs GETLINE, PUTLINE, and PUTGET are just\nas complicated to use.  To simplify matters, I'd suggest looking into\nthe LPSCB code (or some other sample code), and then looking at IBM's\nexplanations in the TSO Programming Guide manual, which are quite\nclear.  Practically speaking, once you've used these facilities one\ntime in a program, you can copy them over and over.  Just get them\nstraight once, and use them again and again.\n\n      In my opinion, the IBM manuals tend to frighten people by making\nthem think you have to use all of the IBM facilities.  Much of the time,\nyou can get away without using most of them.  I'll show you:\n\n      For a simple question that you want to ask a terminal user, it's\ncertainly easier to code a TPUT and a TGET macro rather than a PUTGET\nmacro.  For a simple informative message, you can code TPUT instead of\nPUTLINE.  The downside of using the simpler TPUT macro, is that it can't\nwrite output to a non-terminal, such as when you're running your program\nunder TSO-in-batch.  A lot of times, as I've indicated last month, you\ncan avoid using IKJPARS, if your requirements are very simple.  You can\nalso avoid using IKJDAIR or dynamic allocation, by putting out a\nmessage, when the file open fails, saying that you have to allocate the\nproper ddname to the program beforehand.  Error handling can also be\nmade very simple, with informative messages being sent to the terminal\nvia TPUT.  Really, in many cases, your TSO program can be made quite\nuncomplicated, and it'll still do its job.\n\n      So my job this month was to make you less scared to try writing\na TSO command for yourself.  My personal experience tells me that if\nyou try and fix another TSO command that has everything already coded,\nit's a far less daunting experience, and you can learn the structures\nmore gradually.  One thing I can assure you:  If you break through,\nand learn about TSO command processors, you'll get a very rewarding\nand satisfying feeling about the \"wonders\" you can do.  Good luck.\nSee you next month.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   IKJPARS macros that describe the permissible operands\n            in the LPSCB TSO command.  Note that LPSCB has only\n            keyword operands defined.  You can code either CPPL\n            or REAL as a keyword.  Other optional keywords are:\n            UPT, ECT, or ALL.  This defines a very simple operand\n            structure.\n\n\nMYPCL    IKJPARM\nREALKW   IKJKEYWD\n         IKJNAME 'CPPL'\n         IKJNAME 'REAL'\nUPTKW    IKJKEYWD\n         IKJNAME 'UPT'\nECTKW    IKJKEYWD\n         IKJNAME 'ECT'\nALLKW    IKJKEYWD\n         IKJNAME 'ALL'\n         IKJENDP\n         PRINT GEN\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.   IKJPARS macros coded in the PRINTOFF command, from\n            File 300 of the CBT Tape.  Note that there are both\n            positional and keyword operands defined, and some\n            of the keywords have possible subfields defined, to\n            be coded between parentheses after the keyword\n            statement.  For example, you can code COPIES(nnn),\n            where nnn can be a 1- to 3-digit number.  The\n            PRINTOFF command obviously needs a far more complex\n            operand structure than the LPSCB command does.\n            Note the optional HELP and PROMPT fields.  These tell\n            IKJPARS what to inform the invoker, if there's a\n            mistake in entering some of the operands.\n\n\nPARMTAB  IKJPARM  DSECT=IKJPARMD\nDSNAMES  IKJPOSIT  DSNAME,LIST,USID,                                   X\n               PROMPT='DSNAME',                                        X\n               HELP='DSNAME TO BE PRINTED'\nPCLASS   IKJKEYWD\n         IKJNAME 'CLASS',SUBFLD=CLASSUB\nPDEST    IKJKEYWD\n         IKJNAME 'DEST',SUBFLD=DESTSUB\nPHOLD    IKJKEYWD\n         IKJNAME 'HOLD'\n         IKJNAME 'NOHOLD'\nPCOPIES  IKJKEYWD\n         IKJNAME 'COPIES',SUBFLD=COPYSUB\nPPRINT   IKJKEYWD\n         IKJNAME 'PRINT'\n         IKJNAME 'NOPRINT'\nPLIST    IKJKEYWD\n         IKJNAME 'LIST'\n         IKJNAME 'NOLIST'\nPHEAD    IKJKEYWD\n         IKJNAME 'NOHEADING'                                      .GTE.\n         IKJNAME 'HEADING'                                        .GTE.\nPVOL     IKJKEYWD\n         IKJNAME 'VOLUME',SUBFLD=VOLSUB\nPFOLD    IKJKEYWD\n         IKJNAME 'FOLD',ALIAS=('CAPS')\n         IKJNAME 'NOFOLD',ALIAS=('ASIS')\nPFORMS   IKJKEYWD\n         IKJNAME  'FORMS',SUBFLD=SFORMS                          .GTE.\nPTRAIN   IKJKEYWD\n         IKJNAME  'TRAIN',SUBFLD=STRAIN,ALIAS=('UCS')            .GTE.\nPFCB     IKJKEYWD\n         IKJNAME    'FCB',SUBFLD=SFCB                            .GTE.\nPPROG    IKJKEYWD\n         IKJNAME    'PROG',SUBFLD=SPROG                          .GTE.\nPTEXT    IKJKEYWD\n         IKJNAME    'TEXT',INSERT='UCS(TN) ASIS'                 .GTE.\nASAKW    IKJKEYWD\n         IKJNAME 'ASA'                                           .PRC.\nSNUMKW   IKJKEYWD\n         IKJNAME 'SNUM'                                          .PRC.\nMSGKW    IKJKEYWD\n         IKJNAME 'NOMSG'                                         .PRC.\n*        B E G I N   S U B F I E L D S\nCLASSUB  IKJSUBF\nSCLASS   IKJIDENT 'CLASSNAME',LIST,FIRST=NONATNUM,MAXLNTH=1,           X\n               PROMPT='CLASS NAME'\nDESTSUB  IKJSUBF\n*-----------------------------------------------------------------.SAD.\n*      CHANGE THE DEST ID FROM YOUR TSO ID TO ANY VALUE. USERID   .SAD.\n*      IS A MAX OF 7 CHARACTERS AND DEST ID'S CAN BE 8 CHARACTERS .SAD.\n*-----------------------------------------------------------------.SAD.\nSDEST    IKJIDENT 'DESTINATION',MAXLNTH=8,                             X\n               FIRST=ALPHANUM,OTHER=ALPHANUM,                          X\n               PROMPT='REMOTE DESTINATION IDENTIFY FOR PRINTED FILE',  X\n               HELP=('DEST ID OF YOUR PRINTER ASSIGNED BY SADSC')\nCOPYSUB  IKJSUBF\nSCOPIES  IKJIDENT 'COPIES',MAXLNTH=3,                                  X\n               FIRST=NUMERIC,OTHER=NUMERIC,                            X\n               PROMPT='1-3 DIGITS - NUMBER OF COPIES OF OUTPUT',       X\n               HELP=('NUMBER OF COPIES OF PRINTOUT DESIRED')\nVOLSUB   IKJSUBF\nSVOL     IKJIDENT 'VOLUME',MAXLNTH=8,                                  X\n               FIRST=ALPHANUM,OTHER=ALPHANUM,                          X\n               PROMPT='VOLUME SERIAL FOR DATA SETS TO BE PRINTED',     X\n               HELP=('VOLUME SERIAL WILL BE ASSUMED FOR ALL DATA SETS')\nSFORMS   IKJSUBF\nRFORMS   IKJIDENT 'FORMS',MAXLNTH=4,FIRST=ALPHANUM,               .GTE.X\n               OTHER=ALPHANUM,                                    .GTE.X\n               PROMPT='FORMS DESIGNATION FOR PRINTED OUTPUT',     .GTE.X\n               HELP=('AN ALPANUMERIC STRING TO SPECIFY THE FORM') .GTE.\nSTRAIN   IKJSUBF\nRTRAIN   IKJIDENT   'UCS',MAXLNTH=4,FIRST=ALPHANUM,               .GTE.X\n               OTHER=ALPHANUM,                                    .GTE.X\n               PROMPT='UCS   DESIGNATION FOR PRINTED OUTPUT',     .GTE.X\n               HELP=('AN ALPANUMERIC STRING TO SPECIFY THE TRAIN') GTE.\nSFCB     IKJSUBF\nRFCB     IKJIDENT 'FCB',MAXLNTH=4,FIRST=ALPHANUM,                 .GTE.X\n               OTHER=ALPHANUM,                                    .GTE.X\n               PROMPT='FCB DESIGNATION FOR PRINTED OUTPUT',       .GTE.X\n               HELP=('AN ALPANUMERIC STRING TO SPECIFY THE FCB')  .GTE.\nSPROG    IKJSUBF\nRPROG    IKJIDENT 'PROG',MAXLNTH=8,FIRST=ALPHA,                   .GTE.X\n               OTHER=ALPHANUM,                                    .GTE.X\n               PROMPT='PROG DESIGNATION FOR PRINTED OUTPUT',      .GTE.X\n               HELP=('AN ALPANUMERIC STRING TO SPECIFY THE PROG') .GTE.\n         IKJENDP\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 3.   General steps to be taken in writing a TSO command\n            processor program.  In any particular program, not\n            all of these steps may be necessary.  This information\n            is roughly paraphrased from the TSO/E Programmer's\n            Guide.\n\n       1.  Access the command processor parameter list (CPPL).\n\n           Copy the four addresses, and the CPPL address, into\n           a save area in your program.\n\n       2.  Validate any operands entered with the command.\n\n           You can code this yourself, or you can use the IBM\n           Parser service, IKJPARS.\n\n       3.  Communicate with the user at the terminal.\n\n           You can use the TGET-TPUT combination of services,\n           or you can use GETLINE-PUTLINE-PUTGET.\n\n       4.  Perform the function of the command according\n           to any operands the user specified.\n\n           A TSO command is like any program.  It does\n           what you design it to do.  Now go do it!\n\n       5.  Recognize and pass control to any subcommands.\n\n           If your program's design requires subcommand\n           prompting, use PUTGET to issue a message and\n           return a line of input from the terminal.  You\n           get a buffer similar to the command buffer,\n           which you have to parse for valid operands.\n           Then you ATTACH a subprogram to complete the\n           subcommand's task.\n\n       6.  Intercept and process abnormal terminations.\n\n           You can use the STAE or ESTAE macros to intercept\n           abends and keep the program up.  But you don't\n           have to do this, in many cases.\n\n       7.  Respond to and process attention interruptions\n           entered from the terminal.\n\n           You can use the STAX macro instruction, to allow\n           the program to take a meaningful action when the\n           ATTENTION key is pressed by the user.\n\n       8.  Set the return code in Register 15 and\n           return control to the TMP, which called your\n           program.  This way, you'll be able to show, in\n           a general way, if your program worked properly\n           or not.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9909SE": {"ttr": 19973, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x99!o\\x01\\x00)\\x9f\\x11G\\x01\\x13\\x01\\x13\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1999-08-04T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 275, "newlines": 275, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         SEPTEMBER 1999\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@attglobal.net or sbgolob@aol.com.\nInformation about the CBT MVS Tapes can be found on the web, at\nhttp://www.naspa.net , after clicking on \"Online CBT Tape\".\n\n\nPC's, C, and ASSEMBLER\n\n      One thing that strikes me about this profession is how much time\nand effort we have to spend, learning about new things.  When I started\nin this business, a so-called \"intelligent terminal\" was just about\nunknown.  Everybody used \"dumb terminals\".  Nowadays, it is extremely\nuncommon for any MVS systems programmer to use a \"real 3278\" or its\nequivalent.  Practically all of us use pc's which emulate a color\nterminal that has graphics.\n\n      Most pc's that are being used by MVS sysprogs today, are running\nsome form of Windows, usually of the 9x or NT variety.  An MVS person\nabsolutely has to know, at minimum skill level, how to navigate in\nWindows.  Administering Windows is another matter.  If you work at a\nbig company, you generally leave that to the \"PC Department\" or the\n\"Network Administrators\".  If you run your own shop, like me, you have\nto learn about the Registry, how to back up essential system files, and\nmany other related things, so as to be able to recover from system\nerrors, burps, glitches, and having unwanted instances of the system\nmodifying itself.  When I installed Windows 98 second edition, I spent\n$130 on books:  \"Windows 98 Resource Kit\" and \"Running Windows 98\" from\nMicrosoft, and \"Windows 98 Registry for Dummies\", which is an oxymoron\nif I ever heard one.  You've got to be pretty smart to read that book,\nbut it's worth every penny!\n\n      I have one more observation which reflects the nature of these\ntimes.  Somebody sent me a request, via email of course, that he\nwanted a CBT Tape in tape form.  He explained that he was a consultant\nat a site which didn't have any way of loading a pc file up to the MVS\nmainframe.  Of course, you all know that the CBT MVS Tape materials are\non the Internet now (just go to www.naspa.net and click on \"Online CBT\nTape\").  However when you download the files, unless your mainframe has\na direct TCP/IP connection, you get the files on a pc and have to upload\nthem to MVS.  I wondered if his was still a common predicament, so I put\na notice out on the IBM-MAIN news forum, and asked if anyone else had\nthe same problem as this fellow.  I got nary an affirmative reply, and a\nbunch of snickers and laughs from \"the folks out there\".  Times surely\nhave changed.  The MVS sysprog world is definitely \"wired to the pc and\nthe Internet\" nowadays.\n\n      All of this stuff is seemingly unrelated to our actual business\nof MVS Systems Programming.  After all, it's our \"official business\" to\nset up the mainframe, so it works.  People who work with pc's at home,\nor for a living, might have to know such things, not us!  But the world\nis marching on, and it's different now.\n\n      Today I'm going to talk about some interesting new products that\nrelate to MVS Systems Programming directly, and which run on a pc, or\nthey're related to the pc world.  These products are there, to help us\nadjust to the new way of doing our business.  Once we see what these\nproducts are all about, we can be very glad that there's a bridge\nbetween the old \"way of the world\" and the new one.  Just to read about\nthe existence of such products, will enlarge our comfort zone with the\nway this world is now becoming.\n\n      In this column, I usually write about free tools that everyone\ncan obtain and use.  This month, I'm making an exception, because I\nfeel that we should know about some different concepts that will expand\nour horizons and our ways of looking at things.  In our day and age,\nthat's a direction in which we're being forced to grow.  PC programs\nusually aren't free, although their prices are normally far below the\nastronomical cost of most mainframe products.  I still think you'll get\na lot of use out of this information.\n\n\nThe Tachyon Assembler, Operating System, and File Tools\n\n      David Bond is a very skilled programmer, and a nice person also.\nDavid has written a super product, which I could not believe, until I\ntried it myself.\n\n      Imagine writing an MVS assembler program using SPF/PC or some\nother file editor, on your pc.  Then you assemble it on the pc, create\ndata files to try it out, and test it using an interactive debugger\nthat displays registers, an authentic PSW, and all kinds of program\ndata, as it runs.  You debug the program, reassemble it on the pc,\nupload the object decks to the mainframe, linkedit them, and run a\nclean, debugged program, the first time it runs under MVS.  Is this\nScience Fiction?  It definitely is not.  I did it myself.\n\n      We are talking about the Tachyon Cross Assembler and the Tachyon\nOperating System (TOS).  I'll talk about the new Tachyon File Tools\nlater.  These packages are super equipment for the modern sysprog and\nAssembler software developer.\n\n      David Bond has written these tools using standard ANSI C, and\nso they are portable across many platforms.  Imagine running an IBM-\ncompatible assembler and debugger on a UNIX machine or a pc!  This\nTachyon Cross Assembler is almost completely compatible with the High\nLevel Assembler, Version 3.\n\n\nTachyon Details.\n\n      The Tachyon suite of products currently has three separate parts,\nwhich are licensed separately:  the Tachyon Cross Assembler, the Tachyon\nOperating System (TOS), and the Tachyon File Tools.\n\n      The Tachyon Assembler (called X390) takes ASCII source code\ninput, translates it into EBCDIC in a standard way, and assembles it to\nproduce an MVS-compatible object deck (FB-80), which of course is\nEBCDIC also.  This object deck can be uploaded to the MVS machine, and\nlinkedited as is.  A listing is produced by the Tachyon Assembler,\nwhich looks very much like a comparable listing using IBM's High Level\nAssembler.  Just about all of the assembler error handling you're\naccustomed to with the High Level Assembler, can also be found on the\nTachyon Assembler as well.\n\n      Although X390 does take ASCII source, convert it to EBCDIC and\nassemble, there are times when you need to be able to give it EBCDIC\nsource (say, for a REPRO card).  X390 \"automagically\" recognizes the\ninput is already in EBCDIC and properly handles this situation.  So,\nyou can give X390 EBCDIC or ASCII source, and it will \"do the right\nthing.\"\n\n      The Tachyon Cross Assembler has a convenient GUI interface to\nWindows (9x or NT), which is called TIDE (Tachyon Integrated Development\nEnvironment).  Under Windows, you get into TIDE, pull up a source\nprogram into a window, assemble it interactively, and look at all the\nerror messages, if there are any.  You click on a given error message,\nand the assembler source is positioned to the appropriate line of code,\nso you can correct the error.  The file which will contain the assembler\nlisting can be determined by settings in the X390.INI file, which is\nwhere defaults for the assembler are set.  Defaults can also be changed\nvery conveniently, from within the TIDE GUI interface.  This facility is\nlike SYSTERM, except that you have another window for correcting the\nassembler source that's in error.\n\n      Under the Tachyon Cross Assembler, a listing is produced that is\njust as informative as the IBM High Level Assembler's listing.  In fact,\nthe two listings are very compatible with each other.  Under Windows,\nyou can get into SPF/PC in another window, and browse the assembly\nlisting, at the same time you're still looking at the assembler source\nand errors in TIDE.  Windows does make MVS assembler programming more\nconvenient than it was on the mainframe under TSO.  Also, response time\non the pc is much quicker.  When you've finished assembling, you have an\nobject deck, which you can upload to the mainframe for linkage editing.\n\n      That's as far as it goes if you have the Tachyon Cross Assembler\nonly, which, by the way, is covered by the same license no matter how\nmany computers the single user has.  For example, if a programmer has\nthe Tachyon Assembler licensed for the desktop at work, it could also be\nused on a laptop while traveling, so you can do assembly work on a train\nor in a hotel.  And the license also covers the home computer, so the\nprogrammer can be much more flexible and productive at all times.\n\n      The Tachyon Operating System is a separately licensed product\nthat works together with the Tachyon Cross Assembler.  Since the MVS\nlinkage editor needs to put its load modules into a partitioned dataset,\nand there aren't any pds'es on a pc, David Bond had to write a special\nbinder of his own, to create program objects that will run under his\nTachyon operating system on the pc.  This binder program, which is the\nTachyon equivalent of the MVS Linkage Editor, is called B390.  B390\nissues its own messages, not unlike those issued by the OS/390 binder.\n\n      Once the program object is created, you have to run it.  The\nTachyon Operating System has some remarkable JCL-like capability in\nrunning programs.  Using the Tachyon program J390, you execute JCL,\nwhich can either point to ASCII files or EBCDIC files.  And once all\nthe file locations have been set up and the JCL executes, MVS-like run\ntime messages are produced, and the output gets \"spooled\" (as a file on\na subdirectory) so you can look at it to see how everything ran.  The\nrun-time information looks like an MVS batch job, and it is remarkably\ndetailed, even including instruction and I/O counts.\n\n      Before leaving our discussion of the Tachyon Software product\nofferings, I'd like to say that the Tachyon File Tools, a useful\ncollection of utilities that will definitely grow in the future, help\ncomplete the convenience of moving an MVS environment over to one or\nmore pc's.  Tachyon offers a super-useful un-XMIT utility, and an\nIEBUPDTE utility:  TUX and TUU respectively.  I've used TUX extensively.\nIf you have an MVS macro library, and you put it into TSO XMIT format\nusing the OUTDSN keyword, you can download the entire maclib to a pc,\nand run TUX against it.  Almost instantly, the entire library is dumped\ninto a subdirectory and converted to ASCII member by member.  The macros\nare instantly available for use by the Tachyon Assembler.\n\n      What happens when a load module library is put into XMIT format,\ndownloaded to the pc, and given the TUX treatment, is even more\nremarkable.  The load modules are delinked, csect by csect, into object\ndecks, suitable for re-binding by the Tachyon binder, so they can be\nexecuted under the Tachyon Operating System.  You can even use TUX as a\nmainframe delinker, uploading the resulting object decks, unchanged,\nback to the mainframe.  These programs stand on their own merit, even\nindependently of the Tachyon Assembler and other Tachyon Software\nproducts.\n\n      David Bond tells me that TUX has been used by companies, in ways\ncompletely unrelated to the Assembler.  One company has customers who\nhave trouble downloading things, such as dumps.  That company tells\ntheir customers to put this data into TSO XMIT format and send it to\nthem via email or ftp.  Then, at the support site, the support people\nuse TUX on the pc to look at the data.\n\n      If you want to find out more about the Tachyon Cross Assembler,\nTOS, and the Tachyon File Tools, contact\nhttp://www.tachyonsoft.com/tachyon.\n\n\nThe Amazing Dignus Systems/C Compiler\n\n      Dave Rivers has been a compiler writer practically all of his\nworking life.  What he has produced, in my opinion, is second to none.\n\n      We systems programmers all know about IBM's PL/S, PL/AS, and PL/X\ncompilers, that IBM developed for their internal use only.  How do they\nwork?  Operating system code developers code a system-level program in a\nPL/I-like language that's quick, and their code compiles to assembler\nsource code.  The developer can even mix \"raw assembler\" code with the\nPL/I-like stuff, if assembler language will do the job better.  IBM has\nused this system for its own development for many years now.\n\n      Dave Rivers has come up with something even better than that.\nDave has written a C-language compiler which compiles to assembler\nlanguage source code, and which allows the programmer to mix in \"raw\nassembler\" code, whenever he feels it'll do the job better.  This is\nvery similar to PL/X, except that it's C, not PL/I.  And it's \"pure C\",\nnot \"PL/I-like\".  For this obvious reason, Dave calls his product\nSystems/C.\n\n      There's something very modern (and with the times) in this.  Most\npeople coming out of Computer Science school nowadays learn to program\nin C-language, which is a cross-platform standard, and which is very\npervasive in the industry nowadays.  If you're writing system-level\ncode, with the Dignus Systems/C compiler, you have a sort-of \"instant\nPL/X\" and a whole crop of trained programmers who are equipped to use\nit.  This is not only helpful to software developers, but it is an\nextremely useful product for normal MVS applications and system groups\nwho want to convert their coding to C.  Besides the C source itself,\nyou also get assembler source, which is far more finely customizable.\nThis product has tremendous win-win potential.\n\n      At Dave Rivers' web site:  http://www.dignus.com , you can\nactually put in a C-language program (up to 200 lines) and watch how\nthe Dignus Systems/C compiler converts it to assembly language.  And\nyou can see the compile listing and everything, online.  Dave has\nalso contributed a couple of files to the CBT MVS Utilities Tape (go\nto www.naspa.net and click on \"Online CBT Tape\").  File 419 consists of\nC-source, the equivalent assembler source, and user documentation for\nseveral popular C programs, so they can be run on MVS.  File 420 is a\nload library which contains the executables for these same programs.\n\n      I'd like to add that Dignus System/C can be made to dovetail\nvery nicely with the Tachyon Assembler and Operating System.  If you\nhave C-language source code, you can compile it into assembler source\nusing Systems/C, and then assemble the assembler source on a pc, using\nthe Tachyon Assembler.  You can then run the object code wherever you\nwant--either uploaded to the mainframe and linkedited, or under TOS on\nthe pc.  As I said before, it's a new world today.  The flexibility is\namazing.\n\n      As a final note, and to say something about MVS freebie tools,\nI'm happy to announce that Version 421 of the CBT MVS Tapes will be\navailable soon.  This new version of the CBT Tape alone, has\napproximately 45 additional and updated files.  It's a big change from\neven the last version.  There's a lot of interesting stuff out there\nfor everybody.  Good luck.  We hope to see you again next month.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9910OC": {"ttr": 19978, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x99$\\x9f\\x01\\x00)\\x9f\\x11G\\x01A\\x01A\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1999-09-06T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 321, "newlines": 321, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          OCTOBER 1999\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@attglobal.net or sbgolob@aol.com.\nInformation about the CBT MVS Tapes can be found on the web, at\nhttp://www.naspa.net , after clicking on \"Online CBT Tape\".\n\n\nZAPPING, DISASSEMBLING, DELINKING, AND RE-LINKEDITING\n\n      With Y2K really approaching, I feel that every systems programmer\nshould get \"the old emergency tool kit\" into working order, to be ready\nfor the big moment.  Today our subject will be about load module\nmanipulation tools that you might need.\n\n      For example, suppose it's right around that famous night that\nwe're all eagerly anticipating.  What if you've got a program that\ndoesn't work.  You don't have source--only a load module, and it\nrequires a little tweak, or the replacement of one csect by a repaired\nversion.  You've got 15 or 20 minutes to get your shop running.  What\nare you going to do?  Are you ready to handle that situation?  We're\ntalking about minor re-engineering of load modules here, which can be\neither difficult or easy, depending on how many tools you have\navailable, and how well you know how to use them.\n\n      The load module manipulation operations we'll learn about (or\nreview) here are zapping, disassembling, delinking, and re-linkediting.\nIf you can do these with a fair amount of sureness, I can grant you an\nunofficial programming degree--the MLM degree:  \"Master of Load\nModules\", and you can proudly write those letters after your name.\n\n      Let's define our terms here, so we'll all be on the same page.\nTo ZAP a load module is to change some bytes in it, so it'll probably\nrun differently.  No source is affected, no compiling is done--only a\ndirect change to the load module is made.  This is ZAPping.  We talk\nabout it by saying that we ZAP a load module.  We'll mention some names\nof tools for zapping load modules, or raw data, now.  IBM's zapping\ntool is called AMASPZAP, or \"Super Zap\".  AMASPZAP does \"everything\",\npretty much, but it's cumbersome to use.  My favorite zapping tool is\n\"UCLA Fullscreen ZAP\", as modified by Greg Price.  Both of those tools\ncan work on raw data, as well as on load modules.\n\n      DISASSEMBLING means to take a load module and convert it to\nassembler source code, instruction by instruction.  There are various\ntools to do this.  These tools are called \"disassemblers\".  Most\ndisassemblers start with an executable load module and directly produce\nassembler source code, as output.  However, to disassemble the code in\nan 80-byte card-image object deck, as opposed to a load module, you\nnormally have to linkedit the object deck into a load module, and then\ndisassemble the resulting load module.  A direct object-deck\ndisassembler program is rare, but the vendor product STARTOOL from\nSerena, Inc. of Burlingame, CA, does provide one, using STARTOOL's\nREADOBJ subcommand.  READOBJ allows you to directly disassemble object\ndecks.  I use an object code disassembler to disassemble the object\ndecks in ptf's, so I can refit old zaps to the new ptf module versions,\nwithout the aid of microfiche source listings (that often aren't\navailable anymore).\n\n      DELINKing means to convert a load module into 80-byte object\ndecks, similar to those produced by the assembler, or by compilers.\nUsually, this has to be done separately, csect by csect, but the\nSTARTOOL delinker will DELINK the entire load module, and automatically\ngenerate re-linkedit JCL to re-linkedit the stack of generated object\ndecks.\n\n      Finally, I have to define what I mean by \"re-linkediting\".  This\nterm might mean different things to different people, but I'd guess\nthat most people would think my definition is reasonable.  By\nre-linkediting a load module, you run an existing load module through\nthe linkage editor again, producing a new load module that should have\nidentical function to the old load module.  This sounds superfluous, so\nI have to give at least one reason why someone would need to do this.\n\n      One reason for re-linkediting an old load module is to satisfy the\nprogram fetch component of the MVS operating system.  Sometimes, a very\nold load module will have problems when the current MVS system tries to\nload it into storage.  The old PL1/F compiler and library load modules\nhad this problem, before Larry Williams cleverly re-linkedited them.\n(See File 092 of the CBT Tape, which contains the re-linkedited PL1/F\ncompiler and library.  You can now run PL1/F on an OS/390 system.)\n\n      Where do the program fetch problems come from?  More recently\nlinkedited programs have some internal quantities called RLD counts,\nthat help a modern MVS system load them efficiently.  Very old load\nmodules don't have them, and they have a few other structural\ndifferences as well.  The new versions of MVS program fetch, which\nperform the \"program loading\" function, are supposed to work, even with\nvery old load modules, but on rare occasions, they won't.  What if this\nhappens to you on the night of January 1, 2000, or on some other night\nwhen you have an emergency?  A lot of times, re-linkediting the load\nmodule will cure this problem, but you have to know how to re-linkedit a\nprogram properly, otherwise it still won't work, or it could have even a\nworse problem than before.\n\n      Now that we've outlined what these terms mean, and we've seen what\nthese various operations are, we'll start looking at a few tools which\ncan help us carry these \"load module manipulation operations\" out with\nknowledge and sureness.  Many of the tools are free, and can be found on\nthe huge tool collections called the CBT MVS Utilities Tape, and the CBT\nOverflow Tape.  The materials from both tapes are online.  You can get\nthere from www.naspa.net, and click on \"Online CBT Tape\" to get to the\nCBT Tape website.  The integrated vendor supported toolkit called\nSTARTOOL, from Serena, Inc., also has many of these functions\nincorporated within it.\n\n      Throughout the rest of this article, I'll try and emphasize the\nrelationship of these techniques to Y2K-type emergencies.  I want to\nmake sure that you have your equipment ready, whenever you might need\nit.  It would help a lot, if you could earn your MLM degree before\nJanuary, 2000.\n\n\nMY FAVORITE ZAPPING TOOL.\n\n      My favorite zapping tool is a TSO command called UCLA Fullscreen\nZAP, which is distributed on File 134 of the CBT MVS Utilities Tape, and\nwhich can be downloaded from the CBT Tape web site.\n\n      ZAP is a TSO command processor program that generates full screen\noutput under TSO, and will show you several hundred bytes of load module\ndata or raw data a time.  ZAP is a single load module, which includes\nits own self-contained HELP screens.  To get HELP, type HELP or ? on the\nZAP command line, and after you've gotten to the proper help screen, you\njust type the letter U on the command line, press ENTER, and you're back\nto where you were.  I don't have space now, to describe how Fullscreen\nZAP is used in detail.  Suffice it to say that it's very intuitive, once\nyou get used to it, and you actually \"see a clear picture of the load\nmodule or data\" that you're zapping.  Because of this clarity, I'll\nalways use Fullscreen ZAP instead of AMASPZAP when researching a load\nmodule problem in an emergency, and Y2K problems are no exception.\n\n      As modified by Greg Price, Fullscreen ZAP can actually be used to\nlook at, or change, any disk data, even deleted disk data that hasn't\nyet been overwritten.  Fullscreen ZAP is not just restricted to changing\ndata in load modules, but it can look at any disk data.  In addition to\nallowing data changes, Fullscreen ZAP is handy for simple data\nobservation, and will show you the physical characteristics of the data\nblocks you're looking at, using a display at the bottom of the screen.\nFor example, suppose you've moved a DSORG=DA dataset, and the copy is\nnot behaving properly.  Fullscreen ZAP will show you how the data blocks\nfit on each track, so you can see if the physical data organization has\nbeen disturbed by the move.  Not many other tools will show you such\ninformation about a data file.\n\n      I have written about Fullscreen ZAP in detail in previous columns,\nespecially in those from March and April 1992.  You can get these old\ncolumns from File 120 of the CBT MVS Tape, and Fullscreen ZAP hasn't\nchanged much since then.  Fullscreen ZAP can do just about everything\nthat IBM's AMASPZAP program can do, and it's much easier to use, with\nit's FIND capability for hex and EBCDIC strings within the data.  To\nearn your MLM degree, you owe it to yourself to get very familiar with\nTSO Fullscreen ZAP.\n\n      For completeness, I'd just like to mention that STARTOOL has an\nISPF-based load module zapper built within it.  With STARTOOL pointing\nat a load library, you issue the CSECT subcommand against any load\nmodule, which gives you a list of all csects within that load module.\nIf you issue the ZAP line command against any csect, you get a\nfull-screen display of the load module in hex and EBCDIC, and you can\nzap any bytes, in hex or EBCDIC, by simply typing over them.  STARTOOL\nwill generate AMASPZAP control statements to duplicate, or reverse,\neverything you did, and these generated statements serve as a log, for\nsafety, so you can duplicate or reverse any changes you've made, using\nan AMASPZAP batch job.  This STARTOOL facility is a load module zapper\nonly, and will not work on raw disk data, but it's very convenient to\nknow about in an emergency situation, if your shop is licensed for the\nSTARTOOL product.\n\n\nDISASSEMBLING LOAD MODULES.\n\n      There are several disassembler programs on the CBT MVS Tape which\nare free.  One disassembler is on File 217, and another improved one, is\non File 171.  These two programs are run in batch, and disassemble one\ncsect at a time.  A third batch disassembler is from Randy Hall; it is\non File 354 of the CBT Tape.  The CBT Tape also contains a very cleverly\ndesigned ISPF-based full-screen disassembler written in PL/I by Valentin\nChernyak, on Files 238 through 242.  Valentin's disassembler is run\nunder TSO, it is interactive, and I think it's a lot of fun to use.\n\n      The vendor product STARTOOL has a DISASM subcommand that is very\nfast, accurate, and handy, and which defaults to disassemble an entire\nload module all at once.  The STARTOOL DISASM subcommand has a REASM\noption, to perform the disassembly in such a way, that the generated\nsource code can be reassembled, and correctly linkedited, to exactly\nduplicate the original load module.  Back in the MVS/370 days, I used\nwhat is now the STARTOOL disassembler, to produce a working version of\nthe MVS nucleus, IEANUC01, which could actually be IPL'ed.  This copy of\nthe nucleus was produced by disassembling the production load module\nIEANUC01 with the REASM option, and assembling the disassembled source\ncode.  Of course, I checked the result for byte-for-byte and structural\nequality 12 times over.  I don't recommend doing this nowadays with an\nESA nucleus, (and MVS/370 wasn't OCO).  But I can say that using the\nSTARTOOL disassembler is a very fast way to recover source code when you\ndon't have any, and it duplicates the original load module(s) with a\nvery minimum of effort.  Of course, you have to test the duplication for\nbyte-by-byte accuracy, and identical functionality, just to be sure.\n\n\nDELINKING LOAD MODULES.\n\n      Way back in the OS/360 days, IBM came out with a free FE tool,\nthat you could get from IBM if you asked for it.  It was called DELINK0.\nDELINK0 is a program which runs in batch, and which will produce one\nobject deck at a time, to correspond to one csect from a load module.\nIf a load module has, for example, 9 csects, you have to run DELINK0\nnine times, to recover all of its object decks.  Nevertheless, DELINK0\nis a super-handy tool in certain Y2K recovery situations.  You can get\nsource code for DELINK0, that was disassembled and supplied with labels,\nfrom File 316 of the CBT Tape.\n\n      One recovery situation I recall, occurred when I was trying to\nre-install a non-IBM utility which called an IBM-supplied subroutine\nthat was linkedited with it.  IBM had modified this subroutine for its\nown programs, so that in a later MVS release, it was not the same as\nbefore, and the calling sequence of the parameters was different in the\nnew version.  If I'd try to linkedit the new version of IBM's subroutine\nwith a reassembled version of the non-IBM program, it would fail and\nabend.  I'd completely lost any IBM-supplied old version of the\nsubroutine.  The only copy I had, was the one that was linkedited into\nmy old non-IBM load module.\n\n      For me, it was no problem.  I just delinked the old version of the\nIBM subroutine from the old load module, and relinkedited the object\ndeck I obtained, back with the newly assembled version of the user\nprogram.  The combination worked fine.  It pays to have an MLM degree!\n\n      The vendor product STARTOOL also has a DELINK subcommand that you\ncan apply against an entire load module, or against any subcollection of\nits csects.  DELINK in STARTOOL is fast, and it beats DELINK0 by a mile!\nThe STARTOOL delinker is also a part of STARTOOL's SMPGEN facility,\nwhich can generate PTFs and many other SMP/E modification control\nstructures, to repackage any non-SMP/E-installed software for\ninstallation under SMP/E.\n\n      Now, there's a new free delinking tool on File 090 of the CBT\nTape.  This is DELINKI from David Noon.  DELINKI is a far more modern\ndelinker than DELINK0; it was written in PL/I, and it delinks an entire\nload module with all csects stacked up.  The REVIEW program (a TSO\nbrowsing program that is being maintained by Greg Price, and is on File\n134 of the CBT Tape) hooks into DELINKI when you're REVIEWing a load\nmodule library, and you can delink any load module on the spot, using a\ncombination of these two programs.  Here's how.\n\n      DELINKI and REVIEW should be in a load library accessible to your\nTSO session.  If you're running REVIEW 31.0, which is a recent version,\nthen ALLOCATE ddname SYSUT2 to an 80-byte output dataset, then REVIEW\nthe load library, get a member list, TAG (line command T) the members in\nthe load library you want to delink, and enter the =DELINK command in\nthe directory list command field of REVIEW.  REVIEW will call DELINKI to\ndelink all the chosen members, and the object decks will be written out,\none after the other, to the SYSUT2 output dataset.  The procedure works\nvery well, and very quickly.\n\n\nRE-LINKEDITING LOAD MODULES.\n\n      Y2K situations can provide ample opportunity for you to exercise\nyour re-linkediting skills.  Re-linkediting can be done to produce an\nidentically functional load module to the original, or the techniques\ncan be used to accurately replace a csect in a load module, with a\ndifferent, repaired version.  You should have both techniques ready and\navailable for fixing possible Y2K emergencies.\n\n      My favorite re-linkediting technique involves the use of the\nSTARTOOL package, or its free precursor from the CBT Tape, the PDS\ncommand from File 182, now at version level 8.5.\n\n      Given a load module in a load library, you can point the PDS\npackage, or STARTOOL, at that load library under TSO.  Then you issue a\ncertain subcommand against one load module, or a group of them.  This\nsubcommand is called MAP.  MAP normally produces an AMBLIST-like load\nmodule map.  But with an extra keyword called RELINK, the MAP subcommand\nwill generate perfectly accurate JCL and linkage editor control\nstatements, to correctly re-linkedit the load module, keeping all csects\nin their original, proper order.  All the linkage editor PARM options\nare generated properly too.  With PDS or STARTOOL, you'll never have to\nbeat your head over a linkage editor manual again!  Using PDS or\nSTARTOOL for re-linkediting certainly is a neat trick, and it's very\nhandy for us to know, and use often.\n\n      To re-linkedit a load module exactly, just use the MAP subcommand\nwith the RELINK keyword against it, and edit the generated SYSLMOD DD\nstatement, so it points to a different load library than the original\none.  We don't want the output of the re-linkediting job to overlay the\noriginal load module.  If we made a mistake, we want to have a backout.\nJust add a JOB card to this JCL, and run it.\n\n      To accurately replace a csect with a newer version, use the MAP\n(PDS or STARTOOL) subcommand with the RELINK keyword, against the\noriginal load module, to generate re-linkedit JCL as before.  Then,\nbesides changing the SYSLMOD library name, we add a ddname to the JCL,\npointing to the library containing the new version of the csect, and add\nan INCLUDE linkage editor control card to refer to it, just before the\nINCLUDE card for the original load module.  This will replace the old\ncsect by the new one.  Just make sure to look at the linkage editor\noutput messages carefully, and check that the csect replacement process\nwas carried out correctly.\n\n\nAN ADDITIONAL PREREQUISITE FOR YOUR MLM DEGREE.\n\n      If you've installed these programs (free or vendor), and you've\nlearned how to use them, you're well on your way to acquiring your MLM\ndegree.  However, there's an additional prerequisite of at least 24\nhours of \"lab time\".  This degree requirement is to be satisfied by\n\"playing\" with the above tools, until you can manipulate all of them\nfluently.\n\n      I hope to see you at the graduation exercises.  And I also hope\nyou'll come again and meet with me, here, next month.  I'm looking\nforward to seeing you.  Good luck!\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9911NV": {"ttr": 20229, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x99(_\\x01\\x00)\\x9f\\x11G\\x00\\xf7\\x00\\xf7\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1999-10-12T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 247, "newlines": 247, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         NOVEMBER 1999\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@attglobal.net or sbgolob@aol.com.\nInformation about the CBT MVS Tapes can be found on the web, at\nhttp://www.naspa.net , after clicking on \"Online CBT Tape\".\n\n\nLEARNING OUR TRADE\n\n      Mainframes aren't going away.  In particular, MVS aka OS/390,\nIBM's largest operating system, is very much here to stay.  A few\nyears ago, during the \"client-server craze\", there were rampant\nrumors that MVS was \"a dead dinosaur\", and a new phrase got coined:\n\"management by magazine\".  That was the result of very-high-level\nmanagers getting caught believing the falsehood, touted in magazine\narticles, that a large network of pc-based machines could \"always\"\noutperform a standard mainframe.  The subsequent results have proven\nthem wrong.  IBM responded too.  To keep MVS marketable in the current\nbusiness setting, IBM added UNIX to MVS and added parallel processing\nfor scalability.  The result was a success for MVS.  And so, MVS is\nhere to stay.\n\n      If that's the case, where are the MVS practitioners--the \"MVS\nsystem doctors\" coming from nowadays?  The schools don't seem to be\nproducing them (except for Northern Illinois University and very few\nothers).  The old-timers are still working, although some of them have\nretired.  Of necessity, companies are promoting operators as they did\nbefore, and many of them have become very good systems programmers.\nBut where is the \"formal MVS education\" coming from?  To all\nappearances, it's coming from nowhere.\n\n      I don't mean to refer to the \"education vendors\", who are doing a\ngood job.  I've taken a number of one-week courses myself, to my great\nbenefit.  Courses are very fine, but they're only a few days long, and\nthey're usually only on one particular topic.  Where is the\napprenticeship under a master?  Or short of that, where can a systems\nprogrammer build his or her skills on a regular basis, over an extended\nperiod of time?  Of course there's \"on the job training\", which is our\nmainstay.  But \"OJT\" is spotty, depending on what job the installation\nneeds done at the moment.  That's what you learn at OJT.  Is there an\norganized course somewhere?  One that lasts at least five or six\nmonths?\n\n      There used to be.  At one point in time, there was a thriving\nschool for practicing systems programmers:  the NYU Information\nTechnology Institute.  At this extension of New York University, some\nexpert systems programmers taught many aspects of the trade.  One of\nthose highly regarded teachers is Carmine Cannatello, whose Advanced\nAssembly Language course eventually led to his writing a book.  I have\nan opinion about this.  I think Carmine's book, \"Advanced Assembler\nLanguage and MVS Interfaces\", now in its long-awaited Second Edition,\nis the most relevant single organized source of MVS-related assembler\nknowledge that's publicly accessible, in existence.\n\n\nCome and Learn Assembler.\n\n      Let's start by mentioning the fact that even though one can be an\nMVS systems programmer without knowing much assembler, it's admittedly\nan enormous handicap.  Almost all of the IBM system routines are\nwritten in assembler language.  (I consider PL/S, PL/AS, or PL/X to\nactually be assembler language, from the MVS support point of view,\nbecause the result of a PL/* compile is really assembler code.)  If you\nhave to diagnose a problem in IBM code, you can't understand what's\nreally going on, if you don't know the machine instructions.  In\naddition, if you don't know assembler, the idea of coding your own\nsystem-level utility is almost an impossible dream.  A knowledge of\nREXX helps, but it's no real substitute.  If you're not (at least\nmoderately) skilled in assembler language coding, it's time to get with\nit!\n\n      I'd suggest, after having taken an introductory one-week assembler\ncourse or its equivalent, that everyone read and refer back to Carmine\nCannatello's new book.  The information found there, would take much\nlonger to acquire if you had to go elsewhere.  Carmine's book is\nextremely well organized, and it provides a world of deep information,\npresented simply.  The book starts by taking pains to get you into good\ncoding habits, and it then systematically takes you through a tour of\njust about all the elements which comprise system level assembler\ncoding.  I'd say that if a junior level systems programmer invests six\nmonths or so, going through Carmine's book thoroughly, he or she will no\nlonger be at a junior level, in any sense of the word.\n\n      Please refer to Figure 1, which lists a chapter outline of\nCarmine's \"Advanced Assembler\" book.  From a glance, it'll be clear that\nthe book covers a wealth of MVS system services, and how to use them in\nassembler programs.  The great majority of seasoned systems programmers\ndon't know ALL of these techniques, so the book provides good reference\nmaterial, even for very advanced MVS practitioners.\n\n      Before covering the contents of Carmine's book in more detail,\nI feel I also have to mention another enormous source of assembler\nknowledge, which will greatly strengthen what you learn from reading\nthis book.  That source is the CBT MVS Utilities Tape, and the CBT\nOverflow Tape, which are now online on the web.  (Just go to\nwww.naspa.net and click on \"Online CBT Tape\".)  These tapes comprise\nan enormous free collection of MVS utilities, most of which come with\nsource code that you can study.  Most of the code on the CBT Tapes is\nworking code (at least, it worked somewhere), and you can usually\ndemonstrate the results, while you study the code which produces\nthem.  Dave Alcock, who contributes a very large file (File 311, over\n50000 lines of code) to the CBT Tape, told me that he learned most of\nhis assembler coding from looking at examples in the CBT Tape.\nThat's quite an effective testimonial.  The CBT Tapes, started in\n1975 by Arnold Casinghino, and now up to Version 421, are updated\ncontinually, quite a few times a year.  If you want to contribute to\nthe CBT Tape collection, please contact me by email.\n\n\nSome Details from the Book.\n\n      Please refer to Figure 1, which is a chapter summary of Carmine's\nbook.  From the first glance, you'll notice the enormous breadth of the\ntopics covered.  I can say from my own experience, that the techniques\nthis book deals with, are extremely relevant to the understanding of\nthe workings of MVS system routines and MVS system tools, both user-\nand vendor-developed.  If you know these techniques, you're in a far\nbetter position to understand and maintain the MVS operating system.\n\n      Chapter 1 contains eighteen rules for good assembler coding.  In\nthe old days--the 60s and early 70s, when a system programmer had to\nliterally write extensions to the operating system, there was a lot of\ncode written which violated these rules.  Many systems have crashed,\nafter someone else later would try to understand and modify such unclear\ncode.  Carmine starts you off by showing you never to write assembler\ncode in unclear ways which are difficult to modify.  Such ideas as\nbranching to labels instead of to displacements, not altering\ninstructions, writing meaningful DS statements, writing meaningful and\ndescriptive comments, using simple instructions and easy-to-follow\nlogic, and so forth, sound like \"nice things to emphasize\".  But anyone\nfamiliar with very old code, can tell you the terrible things which can\nhappen if these rules are not followed.  Carmine is doing the world an\nenormous service with his first chapter.  This material should be well\nabsorbed, and not taken lightly.\n\n      Chapter 2 talks about how to set up your programs, so they're\neasy to follow, modify, and debug.  It pays to write your code in small\nsegments, so that if something is wrong, you can more easily pinpoint\nwhich segment is causing the problem.  A small straight piece of code\nis easier to fix than a big, spaghetti-like, tangled, branching piece\nof code that's many pages long.  A description of some testing and\ndiagnostic techniques finishes this chapter.\n\n      Chapter 3 is about writing macros.  As you know, macros are\npseudo-instructions which expand into chunks of assembler code at\nassembly time.  Not everybody writes their own macros, but it's\nessential that every decent assembler programmer know how a macro\nworks.  A necessary part of the workings of a macro, is the conditional\nassembler language, which will assemble some code, and skip assembling\nother code, depending on conditions at assembly time.  Conditional\nassembly enormously increases the effectiveness of the general-purpose\nassembler macros that can be written.\n\n      From Chapter 4 until the end of the book, Carmine systematically\nand clearly explains one advanced technique after another.  In my\nexperience, a lot of existing system code can be understood clearly, if\nyou've covered all of these techniques.  But there's one additional\nadvantage--you'll learn to write the stuff yourself!  I've constantly\namazed myself, in my own career, by writing system code, and\ndiscovering that it actually worked!  With the authoritative, clear and\nsimple explanations which Carmine gives, you'll experience that same\njoy, and you'll feel that same \"high\", over and over again.  Besides,\nyou'll actually help your installation a lot by writing effective\nsystem tools and by fixing tough system problems.\n\n      In the book's new Second Edition, a chapter on ESA coding has\nbeen added, and you can learn about basic AR-mode techniques.  ESA and\nOS/390 systems have many components which use the extended addressing\nfacilities.  You need to know how these are coded, in order to solve\nsystem problems, as well as to understand how those components work.\n\n      In summary, I'd say that it's impossible to be called a\nsenior-level MVS systems programmer in any sense, without at least a\nmoderate level of skill as an assembler language programmer.  Just\nabout every one of us sometimes has to write an exit, or fix an exit,\nor look at a system problem and figure out what instructions are\ncausing it.  Carmine Cannatello's marvelous book, \"Advanced Assembler\nLanguage and MVS Interfaces\", can take all of us to a far higher level\nof MVS system understanding, as well as to a high level in actual\nassembler coding skill.  Good luck to all of you.  I'm looking forward\nto seeing you again next month.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   Chapter Summary of \"Advanced Assembler Language and\n            MVS Interfaces\" (comments in parentheses are mine)\n\n\n   Chapter  1:  Assembler Language Programming Style and Content\n                (i.e. developing \"good programming habits\" from\n                the start)\n   Chapter  2:  Assembler Language Programming Development and\n                Structure (easy to follow program control and\n                commenting, plus much more basic technique)\n   Chapter  3:  The Macro Facility and Conditional Assembler\n                Language (how to understand and write macros)\n   Chapter  4:  Supervisor Services and Macro Instructions\n                (real goodies--EXTRACT, LOAD, LINK, XCTL, TIME,\n                STIMER, GETMAIN-FREEMAIN etc etc.)\n   Chapter  5:  Advanced Assembler Language Techniques\n                (essential things you gotta know, plus nice touches)\n   Chapter  6:  Programming ABEND recovery (SPIE, ESPIE, ESTAE, etc.)\n   Chapter  7:  Programming Dataset Allocation (RDJFCB and OPEN\n                TYPE=J.  SVC 99 programming.)\n   Chapter  8:  Processing a Partitioned Dataset (BPAM, QSAM, BSAM...)\n   Chapter  9:  Programming Paging Efficiency (rare knowledge)\n   Chapter 10:  Selected Advanced Supervisor Services Macros\n                (APF authorization, MODESET, TESTAUTH, RESERVE,\n                SETLOCK, SVCUPDTE, SYSEVENT, etc.)\n   Chapter 11:  Introduction to Channel Programming (EXCP--wow!)\n   Chapter 12:  Writing SVC Routines (and dynamically loading them)\n   Chapter 13:  Using the MVS Common Area (you gotta know about this)\n   Chapter 14:  Programming Using 31-bit Addressing\n   Chapter 15:  Inter-Address Space Communications (SRB, Cross\n                Memory Services - the old ways)\n   Chapter 16:  Extended Addressability (the new ways... AR mode,\n                Data Spaces, Hiperspaces, etc.)\n   Appendix A:  The Assembler\n   Appendix B:  The Linkage Editor\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.   Where to Get This Book\n\n        Title:      Advanced Assembler Language and MVS Interfaces\n                    Second Edition\n        Author:     Carmine A. Cannatello\n        Publisher:  John Wiley & Sons Inc.\n                    Professional, Reference and Trade Group\n                    650 Third Avenue\n                    New York, NY 10158-0012\n                    (800) 225-5945   x2497\n        ISBN:       0-471-36176-3\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CL9912DE": {"ttr": 20234, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x991?\\x01\\x00)\\x9f\\x11G\\x01\\n\\x01\\n\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1999-11-09T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 266, "newlines": 266, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         DECEMBER 1999\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@attglobal.net or sbgolob@aol.com.\nInformation about the CBT MVS Tapes can be found on the web, at\nhttp://www.naspa.net , after clicking on \"Online CBT Tape\".\n\n\nUSING XMIT TO PACKAGE MVS FILES\n\n      I remember years ago, how difficult it seemed to bridge the\ncommunication gap between different computer systems.  Companies used\nto pay small fortunes to consultants, to try and get two different\ncomputer systems to \"talk to each other\".  Nowadays, life is far\nsmoother, since almost all of those old problems now have solutions.\nThe standardizaton of protocols, and the introduction of the Internet,\nwith the global communication opportunities it offers, now makes it\npossible for users on enormously different hardware platforms to easily\ninteract with each other.\n\n      Today, I want to talk about transferring files from one MVS system\nto another MVS system, even though there may be many other different\ncomputers in between.  If you know how to do it, it's quite safe and\neasy.  If you don't, achieving sure-file error-free transmission might\nappear like an impossible dream.  I don't claim to have definitive,\nexhaustive knowledge on this subject.  I'm just coming to suggest some\neasy ways to do the job.\n\n      Who might need this knowledge?  The truth is that we all do, but\nI can state some specific examples.  For instance, you might receive PTF\nfixes from a vendor over the Internet, and they have to be correct,\n\"byte-for-byte\", obviously.  You might want to send a dump or some other\nproblem data, back to the vendor.  This data also has to be correctly\ntransmitted, otherwise the vendor's support personnel might mis-diagnose\nyour problem.  Programmers might want to send programs or data files to\neach other, and of course, they don't want any errors arising from the\ntransmission, either.  As the proprietor of the CBT MVS Utilities Tape,\nI confront this situation daily.  People send me files, as contributions\nfor the tape, and I send files back to the contributors, for their\nre-examination and approval.\n\n\nTSO XMIT AND RECEIVE COMMANDS\n\n      Any upload or download mechanism which handles file data, is\ngreatly aided in its accuracy, if the data is in a simple, standard\nform.  For example, 80-byte card-image data is simple, and it can be\nhandled by many computer systems.  Reducing more complicated data into\nthe 80-byte fixed blocked format, is of great help in ensuring accurate\ntransmission of the data.\n\n      A number of years ago (July 1994--in this column), I wrote about\nIBM's ancient IEHMOVE program, which has the capability of reducing very\ncomplicated data formats into 80-byte records.  At that time, I did some\nexperiments.  I found that IEHMOVE-formatted data would be transmitted\nfar more reliably, being FB-80-byte records, than other forms of\nsequentially unloaded data, such as IEBCOPY-format RECFM=VS files.  Of\ncourse, I wasn't Internet-ready at that time.  I was using protocols\nsuch as ZMODEM and XMODEM to transfer the files.  Nevertheless, the\nsimpler the file format, the more reliable the transmission, I found.\n\n      IEHMOVE is ancient and hard to use.  Since then, IBM has come up\nwith an easier solution for us, even though that probably wasn't their\nintent.  This newer solution is to put our data into TSO XMIT-format,\nusing the OUTDSN( ) keyword of the XMIT command.  This process gets the\ndata temporarily into FB-80-byte sequential file format, and then TSO\nRECEIVE, with the INDSN( ) keyword, can put it back into its original\nformat, after the sequential file has been transferred to a different\nmachine.\n\n      TSO XMIT (TRANSMIT) and RECEIVE were developed for a different\npurpose than IEHMOVE was, even though, for our uses, the results are\nsimilar.  While IBM was enhancing \"old TSO\" to bring out TSO/E, they\ndeveloped a method of having TSO users send data across NJE lines\nthrough JES.  JES2 and JES3 both, are highly compatible with 80-byte\nrecords, so it was natural to try and put other data formats into handy\n80-byte chunks.  This made it easy to send the data across JES-defined\ntransmission lines.  When the data would arrive at the destination MVS\nsystem, the TSO RECEIVE command was there, to convert the 80-byte data\nback to its original format.\n\n      The TSO XMIT command, in its normal use, transparently packages\nthe data into 80-byte records, sends it across the JES NJE lines to the\ndestination system, and waits for the TSO RECEIVE command to be deployed\nthere, to retrieve the transmitted data.  In the usual usage of TSO\nXMIT, you never see the re-formatted data.  However, TSO XMIT has an\nOUTDSN( ) keyword parameter, in which there is no data\ntransmission--just data reformatting.  The OUTDSN form of the TSO XMIT\nis the one we'll use for our purposes.\n\n      When the OUTDSN parameter is coded in XMIT, the total format is:\nTSO XMIT node.userid DSN(your.dataset) OUTDSN(your.fb80.data) .  When\nOUTDSN is coded in a XMIT command, the node.userid doesn't really matter\nbecause the data is not sent.  You could code A.A for node.userid just\nas well.  But since the command and data encoding formats for XMIT were\ndesigned for data transmission to another node, the node.userid\nparameters have to be there.  TSO XMIT sends you the misleading message\nthat so many blocks and so many records of data were sent to\nsuch-and-such node.  It really isn't so.  If OUTDSN was coded, that\namount of data was just reformatted, not actually sent.\n\n      What do you do with the reformatted data?  If it's on an MVS\nsystem, all you need do is to issue the TSO RECEIVE command with the\nINDSN( ) parameter as follows:  TSO RECEIVE INDSN(your.fb80.data) .\nRECEIVE will tell you the name of the dataset and ask you if you want\nto proceed.  At that point, you can enter a command \"DSN\" and tell\nRECEIVE to put your data in a dataset of your own naming.  Otherwise,\nif you just press enter, RECEIVE will create a dataset with the original\ndataset name, minus the sender's high-level qualifier, plus your own\nhigh-level qualifier.\n\n      That's the externals of how TSO XMIT works to reformat data into\nFB-80 pieces.  TSO XMIT can reformat sequential data of any record\nlength, or partitioned datasets--even pds'es containing load modules.\nOnce TSO XMIT (with OUTDSN) has done its initial job, what can be done\nfurther?  The answer is:  \"the sky's the limit\".\n\n      One usual path is to download the XMIT-format MVS data to a PC,\nin binary (i.e. with no ASCII translation or carriage control-line\nfeed), and then send it across the Internet to another PC, upload it\nin binary to another MVS system, and RECEIVE it there.  You don't need\nNJE connections at all.  If the dataset is large, you can zip it on the\nPC before sending it to another side of the world.  Then it can be\nunzip'ed at the destination, uploaded to MVS, and RECEIVE'd.  It all\nsounds great, and it is.  But how can you ensure error-free transmission\nof the data?  And if you want to read the data while it's on the PC,\ncan you?\n\n      Let's address the first question first, and the second question\nsecond.\n\n      First, how can you ensure error-free transmission of XMIT-format\ndata?  One way was developed by Ron MacRae of Amdahl UK.  Amdahl UK had\na support problem.  They wanted to distribute their PTF fixes across\nthe Internet in XMIT-format.  But if an error crept into the data, they\nhad no way of checking for it on the receiving end, at the user site.\nFurther, they wanted to stack multiple XMIT-format files into one\nbundle.  Sometimes they had a pack of several hundred PTFs, all in XMIT\nformat.  If they'd transmit them all separately, how could the user\nsite determine that all the PTFs in the package had reached them?  Maybe\nseveral were left out.  However, if all the PTF XMIT files would be put\ninto a single bundled file, and that single file sent, you could then\nunbundle the stack at the receiving end, and get the entire contents\nback out.\n\n      To solve both the error-checking and bundling problems, Ron MacRae\ndeveloped two REXX execs.  One exec, called OSTARXMT, would create a\nbundle of stacked XMIT-format datasets on the sending MVS system.  The\nother, called OSTARREC, would look at this bundle on the receiving MVS\nsystem, check each XMIT-format dataset in the bundle for errors, call\nTSO RECEIVE to reconstitute each error-free dataset, and do so for every\ndataset in the bundle.  The system works very well.  You can obtain the\nsoftware for Amdahl UK's system on File 365 of the CBT MVS Tape\ncollection, which is available online.  Just go to www.naspa.net, click\non \"Online CBT Tape\", click on \"Download CBT\", and download File 365.\n\n      Amdahl's OSTARXMT system works by adding 8 bytes of error checking\ninformation to each 80 byte line of XMIT-format data.  The LRECL of the\nresulting data is 88.  In transmitting this data across the Internet,\nyou have to be sure to set ftp (if you use ftp) so it knows the data\nrecords are 88 bytes long.  Or you can pre-allocate the destination\nfile on the receiving system with LRECL=88.  That caveat taken care of,\nAmdahl's system works great.  Check it out!\n\n      An alternative means of minimizing transmission errors is to zip\nthe XMIT-format files on the PC before transmission over the Internet.\nPKZIP has CRC error checking built in, so the integrity of the\ntransmission from PC to PC can be quite well assured.  But the problem\nwith this method is the link from PC to MVS system.  Usually, unless you\nknow you have a reliable unzipping tool that works on MVS, you have to\nunzip the data file on the receiving PC, so you're only uploading an\nunchecked data file from PC to MVS mainframe.  On the other hand,\nAmdahl's system checks for errors in the entire MVS-to-MVS transmission\nprocess, and in my opinion, it's better.\n\n      By the way, Amdahl's system incorporates IBM's free TRSMAIN data\ncompression product, optionally.  If the OSTARXMT and OSTARREC execs\n\"know\" where to find TRSMAIN (i.e. what library it's in), then they\nautomatically compress and decompress the files to be transmitted.\nYou can download the TRSMAIN load module from:\nftp://service.boulder.ibm.com/s390/mvs/tools/packlib\n\n\nLooking at XMIT-format FILES on the PC.\n\n      TSO XMIT-format files have become very popular as a way of\npackaging MVS files on the web.  The CBT Tape web site has adopted a\nstandard of storing the CBT Tape files (which are sequential or\npartitioned datasets) in pkzip'ed TSO XMIT-format.  Therefore, if you\ndownload one of these files to the PC and unzip it, usually with the\nintent of uploading it to the mainframe, you might be struck with the\nidea of looking at the data on the PC first.  Can this be done?\n\n      To accomplish this, you'd need a \"PC-based un-XMIT utility\".\nDave Alcock has dedicated a part of his web site:\n http://www.ticnet.com/davea/mvs\nto a study of possible un-XMIT utilities.  I've found it very\ninstructive to go there and look at what he's shown.  But in fact,\nthere's now an inexpensive commercial un-XMIT utility that's part of\nTachyon's File Tools, which works wonders on a PC in dealing with\nXMIT-format MVS files.\n\n      Tachyon's utility, called TUX (Tachyon un-XMIT), will unload\nan XMIT-format pds file into a subdirectory, with all the source\nmembers translated as ASCII text files automatically, so you can read\nthem on the PC.  Load module pds'es are de-linked by TUX into\nMVS-compatible object decks, with each load module de-linked into a\nseparate object file in the subdirectory.  The action of TUX is\namazingly quick, and TUX also has a nice GUI interface for Windows 9x\nincluded.\n\n      A neat application of the Tachyon un-XMIT utility is to view\nCBT Tape files on the PC, which you've downloaded from the CBT Tape\nweb site.  These files, when unzipped, are XMIT-format files.  Using\nTachyon's un-XMIT against them, will create a separate file for each\nsource member, translated into ASCII, which you can read or print on\nyour PC.  CBT Tape aficionados can use this utility a lot.  The Tachyon\nlicense will let you take the program home too, so you can look at CBT\nsource directly, from your home PC.  Therefore, if you're so inclined,\nyou can learn a lot at home, in your spare time.\n\n      I might as well mention that the Tachyon File Tools also include a\nPC-based un-IEBUPDTE utility to separate IEBUPDTE-format MVS files into\nseparate ASCII text files in a PC subdirectory.  This tool is called TUU\n(Tachyon un-UPDTE).  Tachyon File Tools can be obtained from Tachyon\nSoftware:  http://www.tachyonsoft.com/tachyon , phone 303-722-1341 .\nI highly recommend the use of the Tachyon File Tools, if you want to\nfrequently look at MVS files on a PC.\n\n\nA Few Words About XMIT.\n\n      In closing, I just want to mention that XMIT, although a utility\nto put data into FB-80 format, is really a packager for the output of\nother MVS utilities.  For instance, XMIT-format for a pds is really an\nIEBCOPY-unloaded file, broken up into 80-byte records in such a way that\nyou can put it back together again (with TSO RECEIVE, which re-invokes\nIEBCOPY).  TSO XMIT and RECEIVE can process sequential and partitioned\nnon-keyed datasets, with practically any RECFM.  They do not process\nISAM or VSAM datasets.\n\n      I hope you've found this month's discussion useful.  If you're\nsending files or programs far away, you can profit greatly from what\nwe've said.  Just for teasers, I'd like to mention that you can even\nsend a SYS1.BRODCAST dataset (which is keyed) to another site.  Using\nthe BCMDUMP program from File 247 of the CBT Tape, you can create a\nFB-130 sequential file containing the data from the keyed SYS1.BRODCAST\nfile.  Then you can use XMIT to make the file FB-80, download it to a\nPC, zip it, and send it anywhere.  At the other end, you reverse the\nsteps and use either the BCMREST or BCMEXPND programs from File 247 to\nre-create a keyed SYS1.BRODCAST format file from the FB-130 BCMDUMP\nfile, that is functionally equivalent to the original one.  Other tools\nfrom File 247 will allow you to read or write messages directly to and\nfrom the copy.\n\n      Best of luck to all of you.  We'll hopefully see you in one\npiece, after the beginning of Y2K.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0001JA": {"ttr": 20484, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x994\\x1f\\x01\\x00)\\x9f\\x11G\\x01&\\x01&\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1999-12-07T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 294, "newlines": 294, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          JANUARY 2000\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@attglobal.net and/or sbgolob@aol.com.\nInformation about the CBT MVS Tapes can be found on the web, at\nhttp://www.cbttape.org.    (The link from NaSPA is from the MEMBERS\nPage.)\n\n\nRECENT CBT TAPE NEWS.\n\n      I very well remember my first days and months as an MVS systems\nprogrammer--how I had to struggle with load module concepts, current\nsystem settings, browsing very large sequential PTF files, recovering\ndeleted pds members, and similar problems.  These are standard\nsituations that all of us encounter at our work.  I also remember my\nearly struggles to learn to code in assembler language.  My first\nsysprog job, at a very big shop, was made easier because the shop had\nbought a large number of optional vendor products for systems\nprogrammers.  But my second job, at a much smaller shop, was full of\nhandicaps because I didn't have any of those vendor tools any more.\n\n      So struggle I did, until a great event happened.  My teacher,\nJeff Broido, gave me my first CBT MVS Tape.  In my opinion, all MVS\nsystem programmers, veteran or new, ought to know as much as possible\nabout what the CBT Tape is.  In short, it's a HUGE collection of free\nsystem programmer software tools and other items that are useful in our\ntrade.  A few of these tools are so unique, they can't be bought.  No\nsoftware vendor makes anything like them.  Others of these tools have\ntheir vendor equivalents.  But if you have access to the CBT Tape, the\nprice is right, and the choice is very big.\n\n      Nowadays, the CBT Tape materials are online, at www.cbttape.org ,\nso that possession of a physical tape is no longer essential, to have\naccess to this amazing collection of tools.  The collection, consisting\nof the CBT MVS Utilities Tape and the CBT Overflow Tape, is getting\nupdated constantly with both new contributions, and updates of old\nprograms.  Its latest revision level, Version 422, has the largest\nnumber of changes, for one tape update, in the entire history of the CBT\nTape since its inception in 1975.  There are 54 file changes overall,\nfor V422.  This month, I'll try to tell you about some of them.  But\nequally as important, I'd like to mention some new techniques which will\nmake it easier to use the tape materials.  See Figure 1 for a complete\nlist of new and changed files for CBT Tape Version 422.\n\n\nDOCUMENTATION ENHANCEMENTS AND OTHER GENERAL CHANGES.\n\n      Full documentation of the CBT Tape, as always, is on File 001 of\nthe CBT Tape.  However, File 001 now contains over 36000 lines, and I've\nmade it a lot easier to handle and maintain.  File 001 can now be\nconverted into a partitioned dataset, with (as of V422) 934 convenient\nchunk-sized separate members.\n\n      Consider the File 001 documentation handling tools that are now\non File 006.  One of them is an assembler program called CBTUPD that I\nwrote, which introduces many IEBUPDTE-format ./ ADD NAME=  cards, in\nthe \"right places\" of the doc file, File 001, and with \"the right member\nnames\".  When you run IEBUPDTE (or PDSLOAD from CBT File 093) against\nthis updated copy of File 001, you load a partitioned dataset with these\n934 members, that are named in such a way that the collating sequence\nis maintained, and the entire sequential doc dataset can be put together\nagain in the right order.  As the tape's proprietor, when I maintain the\ntape's documentation, I do it as a pds, and I update the documentation\nfor each member separately.  You, as a user of the tape, can run the\nCBTUPD program, and create the exact same documentation pds, which I\nhave in my own possession.\n\n      Maintaining the CBT Tape documentation file in this way, has\nsome important advantages.  One of them is clarity and accuracy in\nthe description of the contents of each file.  It works as follows:\n\n      If you download some of the CBT Tape's files nowadays, especially\nthe newer ones, you'll often find a member in them, with a name of the\nform @FILEnnn.  For example, on File 365, you'll find a member named\n@FILE365.  This member (actually produced by the CBTUPD program), is the\nexact detailed file documentation for File 365, that's on File 001, in\nthe \"Documentation Section\".  Thus, the actual documentation that comes\nin a CBT Tape file, can be repeated over exactly, in File 001 itself.\nThis system makes it easy for me, as the proprietor, to synchronize the\nFile 001 documentation to the actual contents of a tape file.  It makes\nit easier for the file's users too, because the file's documentation is\nmore accurate and up-to-date.\n\n      The contributor of each file can also benefit from this new\ndocumentation system.  Instead of inventing his (or her) own\ndocumentation system for a file, the contributor can use this standard\none.  The contributor just has to download the version of the file which\nis already on the tape, and update the @FILEnnn member himself (or\nherself).  The contributor will thus make sure, personally, that his\ndescription of the material in the file is accurate and complete.\n\n      Of course, File 001, as it's shipped with the tape, looks the\nsame as it always did, only it's bigger.  This gets us to our second\ntopic.\n\n      The CBT Tape collections, online as they may be, are still based\non being physical tapes.  I, as proprietor, create physical tapes, and\nsend them to the webmaster, Sam Knutson.  Sam K, for his part, uploads\nall the tape files to the web site, so that the web site contains\nexactly the same materials that the physical tape did.  In the past,\nwhen most people got their CBT Tape materials from actual tapes, the\nquestion of tape capacity was a very large issue.  It still is an issue\nnow, but it's a smaller one.  Simply put, I wouldn't put more\ninformation on a CBT Tape release, than would fit on a single tape\nvolume.\n\n      In years past, Arnold Casinghino (the founder of the CBT Tape in\n1975 and its dedicated proprietor until 1990) sent out CBT Tapes on 2400\nfoot reels, at 6250 bpi.  The tapes grew and grew, from release to\nrelease.  There's actually a section of the documentation on File 001,\ncalled the \"Version Section\", which shows the capacity and footages for\npast versions of the CBT Tape, as measured with a program we have,\ncalled SS0104.  After a while, at Version 249 of the CBT Tape (July\n1985), Arnie measured that the tape was filling up (the materials\noccupied over 2000 feet of tape at 6250 bpi), and he started deleting\nstuff from it.  Version 249 itself was archived by Arnie, as the last\nversion before the deletions started, and you can find Version 249 now,\non the CBT Tape web site.  CBT Tape Version 249 contains source for a\nwealth of very old user-maintained programs, and is a valuable archive.\n\n      When I took over the reins of maintaining the CBT Tape in 1990,\nI didn't want to do wholesale deletions any more.  I let the tape fill\nup to about 2300 feet, and then I converted to 3480 (uncompressed)\ncartridge distributions and 3600 foot tape reels.  This allowed me to\nlet the tape grow in size to 3158 feet (Version 404) before something\nelse had to be done.  3100 feet (as though it were on 6250 bpi tape) is\napproximately the upper limit of uncompressed 3480 cartridge capacity.\n\n      At that point, at Version 405, I started a second tape, called\nthe CBT Overflow Tape, which was planned to contain deletions from the\nregular CBT Tape.  However, the first 370-foot deletion didn't really\nwarrant making a whole second tape, so I started using the CBT Overflow\ntape as a \"home\" for other free MVS-related materials, which had not had\na convenient distribution point before.\n\n      So it came about, that the European G.U.I.D.E. tapes, from the UK,\nGermany, Switzerland, and Australia, were placed on the CBT Overflow\nTape.  So was the \"ISPF Smoke and Mirrors Tape\", an aborted effort from\nthe SHARE ISPF committee to make their own tape.  When the SHARE MVS\ncommittee itself, decided not to maintain it's tape, I got permission\nfrom them to transplant all of those files to the CBT Overflow Tape,\nand to maintain them from there.  Later, OS/360 materials from IBM,\nwhich are public domain, became available to us, and I decided to put\nsome of them too, on the CBT Overflow Tape.  As we write, I'm preparing\nthe PL/1 SHARE Tape materials for inclusion on (Version 423V of) the\nCBT Overflow Tape.\n\n      In short, both tapes, as uncompressed 3480 cartridges, have now\nbeen filled up with materials.  To adjust to that, I've decided to go to\n3480 IDRC, which has over twice the capacity of an uncompressed 3480\ncartridge, rather than to start a third uncompressed 3480 tape (which\nwould have been called CBT Overflow 2, or CO2 for short).  For those\nshops that need physical tapes, and can't read 3480 IDRC, we can make a\nspecial accommodation, and split these longer tapes into two.  If you're\nin such a situation, please email Sam Knutson at dragon@his.com .\n\n      So the CBT Tapes are continuing to grow.  I'll now conclude this\nmonth's column with a few highlights from the new V422 tape updates.\n\n\nSOME USEFUL NEW FILES ON CBT422.\n\n      Files 050 and 051 are new and different files, which are helping\nusers of the CBT Tapes to adjust to the Internet era.  These are files\nwhich contain only URL's of sites on the Internet.  File 050 has some\nsites from which you can obtain free downloads.  File 051 has URL's of\na few vendor sites which may be of interest.\n\n      The reason why I started File 050 was because of some useful free\nMVS products like TASID from Doug Nadel.  TASID is a multi-purpose\nmulti-utility and monitor program that runs under ISPF.  As useful as\nTASID is, I can't put it on the CBT Tape.  That's because Doug Nadel is\nan ISPF developer who works for IBM, and all the free stuff he's written\non IBM equipment, still belongs to IBM and is subject to whatever\nownership and restrictions they have.  So I made a file with a bunch of\nURL's, and you can use those URL's to go and download TASID and the\nother useful programs for yourselves.  Some other useful things were not\nfree, but were vendor products.  So I split them off, and made File\n051 just for them.\n\n      Some other notable new files on CBT Tape V422 are as follows:\nFile 391 from Robert Ngan, which is TRACE390, is a program to trace the\nexecution of other programs.  File 382 is a large collection of\nutilities from Paul Gillis.  File 368 is similarly a big collection of\nutilities from James Williams of Atlanta.  KSDSPACE, on File 394, is a\nvery useful program from Jan Jakubek of Toronto.  FINDSTR on File 396\nfrom Scott Hawley, is a REXX exec that invokes ISRSUPC to find all\noccurrences of a string in a dataset, directly as a line command from\nISPF 3.4.  Rob Scott, the author of MXI, an ISPF-based monitor program,\nhas included MXI and many of his other programs, on Files 409 thru 412.\nAshley Street has contributed many programs from his FADH (\"Flogging a\nDead Horse\") collection.  Ashley's stuff is on File 413.  Thierry\nFalissard's large collection is on File 432.  Steve Bacher's utilities\nare on File 431.  Mark Zelden's collection is on File 434.  And Frank\nClarke's REXX execs are on Files 433 (VB-255) and 435 (FB-80, converted\nby David North).  If I left some other good new files out, it was\ncompletely unintentional.  There are a lot of them.\n\n      Sam Knutson deserves a big \"thank you\" for all his work in\ngetting the CBT Tape web site together.  You can email Sam K at\ndragon@his.com , to tell it to him personally.\n\n      I sincerely hope that you'll get very much benefit from the new\nfiles on the CBT Tape, as well as from the other files that are there.\nI can personally tell you that this collection is half my own career.\n(If you're a regular reader of this column, you already know that!)  In\nany case, I wish you all a Happy 2000, and I'm looking forward to seeing\nyou again next month.\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   List of files on the CBT MVS Tape that were changed\n            for Version 422.  Some of the files are completely new,\n            and others have had slight or moderate changes made to\n            them.  All in all, the changes have been very\n            substantial, and together, they constitute the largest\n            single positive increment between two consecutive tape\n            versions, in the entire history of the regular CBT Tape.\n\n\nFILE NO.    DESCRIPTION OF THE OVERALL CONTENTS OF THE FILE\n-------     -----------------------------------------------\n\nFile 006:   Collection of Utilities to manipulate File 001 doc\nFile 035:   LOAD MODULE file - Quick install of useful programs\nFile 039:   CITIBANK - SMF 14-15 pgm, and IPOUPDTE modification\nFile 050:*  Internet URLs for Free Downloads\nFile 051:*  Internet URLs for some Relevant Vendor Sites\nFile 094:   DAF from Mike Cleary - Dataset Audit Facility\nFile 102:   TAPESCAN program - Frank Pajerski version\nFile 120:   Sam Golob's \"MVS Tools & Tricks\" articles\nFile 129:   Shared DASD Checkpoint mod - XA and OS/390\nFile 134:   Greg Price Utility collection - REVIEW, etc.\nFile 135:   Greg Price Load Module library\nFile 147:   ARCHIVER  All your non-VSAM datasets to 1 VSAM file\nFile 155:*  Dave North's REXX execs - go VB-255 to FB-80 etc.\nFile 161:   Jim Marshall - ISPF interfaces to utilities\nFile 171:   DITTO, TAPEMAP, SMFUTIL, TPX, FX, SUTL (no BLP req)\nFile 172:   David Cartwright's collection of Utilities\nFile 182:   PDS Command Package - Version 8.5\nFile 183:   Gilbert Saint-flour's collection - SHOWMVS etc etc\nFile 244:   UK GUIDE Tape Supplement - 1993A\nFile 247:   Broadcast Manager Utilities to manage SYS1.BRODCAST\nFile 268:   REXX function package to access VSAM files\nFile 291:   CPU Instruction Speed monitor\nFile 299:   TAPEMAP program - Reads tape files in many formats\nFile 300:   Jim Marshall's enormous collection of TSO programs\nFile 312:   FTPBATCH, XMITIP - others from Lionel Dyck\nFile 321:   COBOL Analyzer from Roland Schiradin & post prcessor\nFile 322:   TSO SLEEP programs (like the VM ones)\nFile 343:   A VTOCLIST program - Peter Havercan & John Kalinich\nFile 348:   Programs to list a PDS directory in order\nFile 352:   INTEL large collection of utilities\nFile 361:   Frank Johnston Utilities - CXYPSCAN, ZZRELINK\nFile 362:   Frank Johnston Utilities - Load Library\nFile 368:   Utility collection from James Williams\nFile 372:*  DYNALLOC Program from Ken MacKenzie\nFile 382:   Paul Gillis utilities collection\nFile 391:*  TRACE390 Instruction Trace Program from Robert Ngan\nFile 393:*  RACFGRPS exec from Robert Lamerand\nFile 394:*  KSDSPACE program from Jan Jakubek\nFile 395:*  CATIND exec to do bulk cataloging for a new system\nFile 396:*  FINDSTR exec to invoke ISRSUPC automatically in 3.4\nFile 397:*  PACK and UNPK execs to do numeric conversions\nFile 398:*  Generate system macro invocations more simply\nFile 404:   TSSO for OS/390\nFile 409:*  Rob Scott's MXI monitor package - FB-80 members\nFile 410:*  Rob Scott's MXI monitor package - load modules\nFile 411:*  Rob Scott's utilities - source code and FB-80\nFile 412:*  Rob Scott's utilities - load modules\nFile 413:*  Ashley Street's FADH Utility collection\nFile 414:*  Convert printouts from machine control to ANSI\nFile 431:*  Steve Bacher's utilities, packages, and offerings\nFile 432:*  Thierry Falissard's selected programs and stuff\nFile 433:*  Frank Clarke's collection of REXX execs, etc.\nFile 434:*  Mark Zelden collection of Utilities and execs\nFile 435:*  Frank Clarke's stuff FB-80-ized by Dave North (F155)\n\n\nAn asterisk (*) next to the file number, denotes a completely\nnew file for CBT Tape Version 422.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0002FE": {"ttr": 20490, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x01\\x00\\x01\\x0f\\x01\\x00)\\x9f\\x11G\\x01\\x1e\\x01\\x1e\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2000-01-10T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 286, "newlines": 286, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         FEBRUARY 2000\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@attglobal.net and/or sbgolob@aol.com.\nInformation about the CBT MVS Tapes can be found on the web, at\nhttp://www.naspa.net.    (Go from the NaSPA Home Page to \"What's New\",\nfrom there to \"Member's Web Site\", and then to \"Online CBT\".)\n\n\nASSEMBLER MACRO COLLECTIONS - PART 1\n\n      As a longtime practitioner in this field, it is my opinion that\nSystems Programmers should know how to program.  Specifically, we\nshould know something about programming in the mainframe Assembler\nLanguage.  Assembler programming knowledge provides multiple benefits\nfor the technician and the shop.  It'll help you to better diagnose\nproblems--you can read and understand machine code in load modules.\n(I first learned what a spin loop was, by looking at the looping code\ninstructions in a system module.)  It'll also help you to write, or\nmodify, extra system utilities that are very necessary in doing our\njobs.  IBM doesn't provide us with quite enough tools to make us\ncompletely comfortable.  We all know that we need more tools to do our\nnormal work, than IBM provides us with.\n\n      There are various degrees of skill and involvement in assembler\nprogramming.  We systems programmers don't have to be the greatest\nprogramming experts, but we should be able to write a utility program,\nfix it, and write any system exits that are required or useful for the\nshop.  On the other hand, experienced developers of system programs, who\nspend their entire days developing code, have different requirements.\nThey need a more organized development environment, with their own\nappropriate tools in place.  The most frequently used tools in an\nassembler programming development environment are collections of macros.\n\n      Every assembler programmer, at any skill level, needs to know\nabout macro instructions.  Macros are pieces of user-written source code\nthat are invoked by the programmer as though they were single\ninstructions.  Prototype macro definitions, which contain the code to\naccomplish specific tasks, are pre-coded and placed in macro libraries,\nor lie \"internally\" in the program itself, between MACRO and MEND\ninstructions.  At assembly time, the assembler looks at any\n\"instruction\" in the source code that isn't an actual instruction, and\nchecks to see if it is a macro.  If the assembler can \"find\" a macro\ndefinition prototype, and indeed, the \"instruction\" is a macro, the\nassembler proceeds to look at the macro definition prototype and expands\nthe single macro instruction call into one, or many actual instructions.\nAll this is for the purpose of accomplishing a given action,\nrepetitively, in a simple way.\n\n      What can be done by coding a macro in an assembler program?\nFor example, you could code one macro, and print a message line.  Or\nyou could code a one-line macro to do all the preparation to start, or\nfinish, the execution of a program.  A macro can be used to accomplish\nany (simple or complicated) task in an easy way, as long as the macro\ndefinition prototype is pre-coded, in advance, and you've pointed your\nassembler JCL to the library containing this definition, using the\nSYSLIB DD statement.  Macros make the life of an assembler programmer\nmuch simpler, because by the skillful use of macros, you don't have to\nrepeatedly code all the instructions necessary to accomplish repetitive\ntasks.  You just code an execution of one macro, over and over.\n\n      In the MVS Operating System, macro invocations in assembler\nprograms are a way of life.  Access to MVS system facilities is often\nprovided by IBM through documented macro calls.  The macro definitions\nnecessary to support these system facilities, are provided by IBM in\npartitioned datasets known as macro libraries.  SYS1.MACLIB and\nSYS1.MODGEN are the most generally used macro libraries, but some\nspecialized IBM products have their own separate macro libraries as\nwell.  To use these IBM macros, their macro libraries have to be\nconcatenated into the SYSLIB DD statement of your assembly JCL.\n\n      Assembler programmers have also created many of their own user\nmacros, which perform repetitive functions that they don't want to code\nover and over again.  One such example is a pair of user macros which\ntakes care of the \"housekeeping\" involved in program entry and program\nexit.\n\n      IBM's SAVE and RETURN macros, which help us to simplify these\nfunctions, aren't specialized enough to automatically establish the\nprogram's base registers and load them properly.  Or, for writing a\nre-entrant program, we'd want such macros to GETMAIN a save area and\nFREEMAIN it afterwards.  (GETMAIN and FREEMAIN are macros themselves,\nprovided by IBM to obtain and free some main storage for a program's\nuse.)  Therefore many programmers have written their own macros to do\nthis housekeeping job the way they'd like.  I've seen pairs of\nuser-written macros called ENTERR and EXIT, or PROLOG and EPILOG, and\nother similar sets, which do this job nicely, better than the\nIBM-provided macros do.\n\n      I was once chairman of the SHARE Assembler committee.  This group\nhad the specific function of putting pressure on IBM to improve their\nAssembler H program, which at that time was IBM's standard Assembler\nfor MVS and VM.  Greg Mushial of the Stanford Linear Accelerator Center\n(called SLAC) had written about 50 enhancements to Assembler H.  We\n(the users) and SLAC itself, wanted IBM to take these improvements over\nand support them.  The eventual result was that IBM listened (after our\nlong campaign) and created the High Level Assembler (HLASM) which\nincorporated Greg's enhancements, and which is their standard assembler\ntoday.\n\n      In the course of those committee meetings, I had the occasion to\ntalk to some high-powered Assembler developers, from both IBM and other\ncommercial vendors.  After one meeting, I took a walk with two authors\nof very famous products.  The single topic of conversation which struck\nme the most, was that they talked about the absolute necessity of\ncreating a good set of macros for themselves, to use in their\ndevelopment efforts.\n\n      My own experience in programming, not as heavy as theirs, gave\nrise to a different view.  If I'm modifying some program, not writing\nmy own, I'm happy to work with the macros (if any) that the original\nauthor of the program used.  These macros are part of the backbone of\nthis author's code; I'm only modifying some particulars.  Therefore,\nI don't usually want to change any of the basic program structure, and\nI'll normally leave his macros the way they are.  I just might invoke\nthem a few more times, if that's necessary for the job I have to do.\n\n      The common thread in both these points of view, is that you have\nto know how to invoke macros, and you should have a good concept of how\nthey work.  If you're a developer, you might have to write a set of\nmacros for yourself.  If you work with someone else's code and use\nalready-written macros, you still have to understand what they're good\nfor, and how to properly invoke them.  Today, I'm not going to talk\nabout how to write macros, and how their internals work, using the\nconditional assembly.  Carmine Cannatello's new book, \"Advanced\nAssembler Language and MVS Interfaces\" (John Wiley - ISBN 0-471-36176-3)\nhas an excellent chapter on how to write macros.  Rather, I'll describe\nsome nice collections of user-written macros which people have written,\nand we'll get a better idea about what these collections can do for us.\n\n\nWHERE TO FIND MACROS\n\n      Most of the non-IBM macros you can find, are user-written.  An\nenormous collection of user-written MVS software can be found on the\nCBT MVS Utilities Tape and the CBT Overflow Tape, which have an online\nweb site available for downloads.  You can get to the \"Online CBT Tape\"\nweb site, by starting from the \"Members Area\" of the NaSPA home page:\nwww.naspa.net.  The CBT Tapes, as I'll refer to both of them, contain\nlarge amounts of assembler language source code, which in turn include\nmany assembler macros that you can look at, learn from, and use.\n\n      In addition, most IBM products have been written using some\nspecialized \"internal user macros\".  Although the typical IBM macros\nthat we normally use, are in SYS1.MACLIB and SYS1.MODGEN, some less\ncommon macros that were used for actual IBM product development, are\navailable to us as \"IBM Private Macros\".\n\n      Where are the IBM Private Macros?  If you obtain machine-readable\n\"Optional Materials\" from IBM for a product, which contain source code\nfor some of its programs, you'll find that one or more of the files on\nthese tapes contain macros which were used in the development of that\nparticular product.  To spot a file containing macros, look for one\nfile which contains a lot of wildly different member names, as opposed\nto files containing member names that are mostly very similar to each\nother.  Today, you can't obtain as many of these IBM Private Macros as\nin the past.  That's because many of IBM's products are now \"OCO\"\n(distributed to customers as \"Object Code Only\") and IBM doesn't let\nyou see the source code any more.  Nevertheless, quite a lot of the IBM\nPrivate Macros are still available today, especially for older\nproducts.\n\n      Between this month and next month, we'll examine some different\ntypes of user-written macros that are commonly available, and we'll\nshow you what they're for.  The types we'll mention are \"Structured\nMacros\", \"Internal Macros\", \"Entry and Exit Macros\", and some other\ntypes.  We'll also show you some miscellaneous collections of macros\nyou can use for various purposes.  Once you see a few examples of the\nenormous jobs that macros can do, you'll understand, by yourself, that\nthere are many more possibilities.\n\n\nSTRUCTURED MACROS\n\n      Dan Snyder has been developing assembler code for almost 30\nyears, and he's recently donated the entire collection of the assembler\nmacros he's written, to the CBT Tape.  Dan's collection will soon\nappear on the CBT Tape as File 438.  We'll end this month's column with\na short description of Dan's \"structured macros\", and we'll continue\nnext month with a description of some other macro types and macro\ncollections.\n\n      In addition to Dan Snyder's structured macros, there are other\ncollections of structured macros on the CBT Tapes.  The Clemson\nUniversity Structured Macros collection is on Files 107 and 108 of the\nCBT MVS Utilities Tape.  And the HAL collection of structured macros,\nfrom Yale University, is on File 188 of the CBT Overflow Tape.\n\n      All of us probably know what \"Structured Programming\" means for\nhigher level languages.  Structured Programming is a way of keeping\nyour code segmented and neat, often using some standard programming\nconstructs, such as IF-THEN-ELSE segments and DO loops.  In Structured\nProgramming, you never branch out of one segment of code, into the\nmiddle of another segment.  Writing programs in a structured manner\nmakes them easier to debug and test, because many bugs can be isolated\nto a small segment of a large program.\n\n      By it's normal nature, Assembler Language code is rather\nfree-form.  Practically speaking though, it's a good idea to code\nAssembler in segments, and not to branch the code out of the segments.\nBut you don't have to.  It's a completely different story to make an\nAssembler Language program look like a higher level language program,\nby coding IF-THEN-ELSE statements and DO loops, yet keeping the control\nof knowing what each instruction is doing.\n\n      Dan Snyder's structured macro system makes it possible for an\nAssembler Language program look like a high level language program,\nwhile retaining the fine-grained control that an Assembler programmer\nis used to.  Dan has written macros called IF, ENDIF, ELSE, ELSEIF,\nENDELSE, DO, ENDO, ELSEDO, THENDO, FIRST, ENDFIRST, AFTER, ENDAFTER,\nNEXT, EVERY, and EDIT.  These macros allow the coding of true\nStructured Programming constructs in Assembler programs, while retaining\nthe traditional Assembler control and efficiency.\n\n      A very simple example of the use of Dan Snyder's IF and ENDIF\nmacros can be seen in Figure 1.  You'll notice that the code generated\nby these macros is very efficient.  If you're used to coding in\nAssembler, and you also have familiarity with structured coding in\nhigher level languages, you'll definitely be interested in looking at\nthis set of macros.\n\n      In this same file, File 438, you can also find Dan Snyder's\ncollection of macros to allow you to code an assembler program and\nmake it look like a COBOL program.  This second macro collection will\nhelp former COBOL programmers migrate their skills to the Assembler\narena.  Very interesting, curious, and helpful stuff, indeed!\n\n      Before Version 423 of the CBT Tape will be released, you can\ndownload File 438 from:\n\n    ftp://ftp.cbttape.org/pub/cbttape/adhoc/CBT438.zip  .\n\nAfter the official release of Version 423 of the CBT Tape, File 438\nwill be available at:\n\n    ftp://ftp.cbttape.org/pub/cbttape/cbt/CBT438.zip  .\n\n      Next month, we'll continue our discussion of user-written\nassembler macro collections further.  I sincerely hope that this\nmaterial will broaden your horizons.  See you then!\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFigure 1.   A simple illustration of the effect of Dan Snyder's\n            IF and ENDIF macros.\n\n            Dan Snyder wanted to make his IF macro as simple to\n            use, but as general as possible.  Therefore, its four\n            operands are very close in format, to the assembler\n            code that they generate.  Its first operand is any\n            instruction that sets the condition code.  Its next\n            two operands are the first operand and second operand\n            of the instruction (as in the Principles of Operation\n            manual).  Finally, its fourth operand is whatever\n            letter(s) you'd add to the \"B\" to make a branch\n            mnemonic.  For example, you'd code an E for the\n            fourth operand, and the IF macro will generate a \"BE\"\n            mnemonic instruction, or its functional equivalent.\n            It works as follows:\n\n\nThis is an example of how you code Dan Snyder's IF macro:\n\n                PRINT GEN                DISPLAY MACRO EXPANSIONS\n                IF      (CLC,FIELDA,FIELDB,E),THENDO\nMVC     OUTPUT(20),FIELDA   DO IF FIELDA = FIELDB\n                ENDIF ,\n\nIn this example, the Assembler listing would look like:\n\n                PRINT GEN                DISPLAY MACRO EXPANSIONS\n                IF      (CLC,FIELDA,FIELDB,E),THENDO\n+               CLC     FIELDA,FIELDB\n+               BNE     $MDF0001\nMVC     OUTPUT(20),FIELDA  DO IF FIELDA = FIELDB\n                ENDIF ,\n+$MDF0001       DC      0H'0'\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0003MA": {"ttr": 20741, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x01\\x00\\x04/\\x01\\x00)\\x9f\\x11G\\x00\\xfd\\x00\\xfd\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2000-02-11T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 253, "newlines": 253, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           MARCH 2000\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@attglobal.net and/or sbgolob@aol.com.\nInformation about the CBT MVS Tapes can be found on the web, at\nhttp://www.naspa.net.    (Go from the NaSPA Home Page to \"What's New\",\nfrom there to \"Member's Web Site\", and then to \"Online CBT\".)\n\n\nASSEMBLER MACRO COLLECTIONS - PART 2\n\n      IBM has built an enormous amount of flexibility into the macro\nexpansion facility of its S390 Assembler Language, which is now embodied\nin the High Level Assembler (HLASM).  You can code an assembler macro to\ngenerate just about anything on an OS/390 system, after that macro has\nbeen assembled.  You can even code one macro to generate a complete\nassembler program, or to PUNCH a large JCL stream.\n\n      For example, you may remember the old SYSGEN process, which\ngenerated all the JCL necessary to put together the principal MVS\noperating system load libraries.  A SYSGEN was coded entirely from\nassembler macros.  You'd code the \"Stage 1\" SYSGEN entirely out of the\nIBM-supplied \"SYSGEN macros\" from SYS1.GENLIB or SYS1.AGENLIB.  These\nthen had to be assembled.  The output of the assembly would be a huge\nJCL stream.  This was the \"Stage 2\" of the SYSGEN, which was a complex\nassembly and linkedit jobstream, that was run against the IBM-supplied\nDLIBs (Distribution Libraries) of new modules, to create a newly\ntailored copy of the working operating system libraries.\n\n      The Assembler macro facility is so versatile, that even a roomful\nof books can't describe all the possibilities of structures you can\ncreate with it.  Today, we'll touch on several of the programming\nwonders, simple and complex, that have been created out of assembler\nmacros by users like you and me.\n\n      As we mentioned last month, a good source of user-written macro\nexamples is the CBT MVS Utilities Tape, which, along with the CBT\nOverflow Tape, is a vast conglomeration of MVS system programmer's\n\"goodies\".  This collection is now online.  Though the collection has\nits own URL, it can currently also be reached through the \"Members\nOnly\" section of www.naspa.net.  In this column, we'll refer to\nvarious \"files\" from the CBT MVS Tape collection, as sources for some\nof the macros.  These files (which are actually MVS pds'es) can be\nindividually downloaded from the CBT Tape web site.\n\n      A good book to learn macro coding from, and also to learn many\ntechniques of Assembler Language programming, is:  \"Advanced Assembler\nLanguage and MVS Interfaces\" by Carmine Cannatello (Second Edition -\n1999) from John Wiley and Sons, Inc. ISBN: 0-471-36176-3.  Carmine\nhas graciously donated his machine-readable coding examples to the\nCBT Tape collection (File 069), for the benefit of everyone.  Carmine's\n\"Second Edition\" coding examples may be found on Version 423 of the CBT\nTape, and higher.  Before Version 423 comes out, you can get them at:\nftp://ftp.cbttape.org/pub/cbttape/adhoc/CBT069.zip .\n\n\nMACRO EXAMPLES - MESSAGING MACROS\n\n      One of the more common uses of macros in assembler programs,\nis for writing messages.  I've often seen home-grown messaging macros\nwhich make the formatting of an informational message very easy.\nUsually, coding the message, and having it routed to the proper place,\nonly involves one line, or at most two, when a macro is being used for\nthe purpose.  On the other hand, to code all the logic necessary for\nall details of properly routing the message, without using a macro,\nmight require five, or even more than ten lines, of complicated coding\nand calculation.  If you have to repeat such message coding many times\nin a program, it obviously makes for much simplification to invoke one\nmacro repeatedly, rather than code each message in \"longhand\".\n\n      An IBM message invocation macro that is commonly used, is WTO,\nor \"Write to Operator\".  A user program can invoke WTO in a very\nsimple manner, coding:  WTO 'message text' .  When this macro is coded\nin a program, the program writes a message that is sent to the\noperator consoles.  It is usually quite simple to invoke the WTO macro\nin a program.  However, when expanded, this macro's \"generated code\"\nis not particularly simple at all.  But the macro has achieved its\npurpose by making the coding in the program very easy.  Use of the WTO\nmacro, or the WTOR macro (Write to Operator with Reply) is described\nin the manual:  OS/390 MVS Programming:  Assembler Services Reference\n(GC28-1910), or MVS/ESA Assembler Programming Reference (GC28-1642).\n\n      As an example of a program which uses a home-grown message\nmacro, I can cite the COPYFILE program from File 316 of the CBT Tape.\n\n      The purpose of the COPYFILE program is to copy selected standard\nlabeled files from one tape to another.  For example, using COPYFILE,\nyou can copy SL files 7, 8 and 22 from tape volume TAPEAA to files 5,\n6, and 7 of tape volume TAPEBB.  In Figure 1, we see a graphic\nillustration of COPYFILE's use of the MSG macro, which formats the\ntape file copy report, and which simplifies the assembler code in the\nCOPYFILE program very much.\n\n      Please note carefully, what the MSG macro is doing.  The MSG\nmacro takes, as input, program variables such as the tape file number\nand the tape volume serial name.  From these, the MSG macro constructs\na composite message, which it loads into the MSGWRITE subroutine.  The\nMSGWRITE subroutine, in turn, puts that message text out to the //MSG\nddname, so it can be displayed to the user of the program.\n\n      In my travels, I've found an even more sophisticated macro\nthan the MSG macro and the MSGWRITE subroutine of CBT Tape File 316.\nThis is Gilbert Saint-flour's STRING macro, which is used in many of\nhis programs on CBT Tape File 183.\n\n      Gilbert's STRING macro is functionally similar to the COBOL\nDISPLAY, or the PL/I PUT EDIT instructions.  Using STRING, you can\nconcatenate any number of fields, edit each of them if necessary, and\nget the result into the work area you specify.  Much of STRING's\nflexibility lies in the fact that it can reformat numeric and date\nfields in a great number of different ways, before creating message\ntext out of them.\n\n      How does STRING work?  STRING contains quite a few subprograms\nthat are coded within it.  Each of these subprograms performs a\nspecific type of numeric conversion.  You always code the STRING macro\nin two different ways.  First, you invoke the STRING macro to format\nmessages, perhaps many times within a program.  Then you invoke it\nagain at the end, using its GENERATE parameter.  The GENERATE\ninvocation of STRING looks at all the other invocations, and\ndetermines which kinds of numeric conversion need to be performed, and\ntherefore which subroutines need to be called.  GENERATE then calls up\nonly the subroutines specifically needed by the first invocations of\nSTRING, and puts only their code into the assembled program.  GENERATE\nalso constructs all the literals that are needed by the other\ninvocations of the STRING macro in that program.  You can easily see\nthat STRING is very sophisticated and versatile, while making\nassembler coding much easier.\n\n\nANOTHER MACRO USE - PROGRAM OPTION PACKAGING\n\n      Large program packages often have hundreds of default options,\nmany (or all) of which can be changed at installation time.  The\nvendors of these packages have noticed that customers can get very\nconfused, if they are forced to make hundreds of decisions, each time\nthey install the product.  The writers of these packages thus have the\nproblem of simplifying the decision making during their installation\nprocess.\n\n      Most customer installations will install a given software\npackage in a \"typical\" way.  That is, they'll keep most of the many\noptions in a default state, only changing very few of them.  Bruce\nLeland, one of the authors of the STARTOOL product, told me that he\nuses the assembler macro facility to simplify the customization of\nSTARTOOL, which has hundreds of defaults that can potentially be\nchanged by its customers.\n\n      STARTOOL determines most of its option choices by consulting a\ncertain load module, which contains all its defaults and their\nalternatives.  This load module is assembled at STARTOOL installation\ntime.  Its assembly code is generated by coding installation macros.\nIf a customer site decides to change options that are typically\nchanged, these (relatively few) common choices are shown in Bruce's\nsample installation invocation.  All the rest of the choices are taken\ncare of by the macro coding internally, and are generally not noticed\nby a typical customer.  However, if an installation wants to adjust\none of the uncommonly changed defaults, its macro adjustment is listed\nas a comment in the sample \"options gen\", below the main coding.  This\narrangement has been reported to be well-received by STARTOOL's\ncustomer base, and STARTOOL's installation process is quite simple.\n\n      I'd like to point out one of the very subtle things that's done\n\"under the covers\" by Bruce Leland's STARTOOL installation macros.\nEvery time an installation will change a STARTOOL default, the macro\nwill make a note of it, and will generate some message text.  Upon\ninvocation of the STARTOOL subcommand: 'CONTROL DEFAULTS', this text\nis displayed on the screen.  So an installation can instantly determine\nthe STARTOOL defaults that it has changed.  This \"magic\" was all done\nby the installation macros at option assembly time.  See how useful\nand clever, macro coding can be?\n\n      At this point, I wish to express the hope that all of you will\ntake some time to study a macro or two, to see how they are constructed.\nMacros generally make heavy use of the \"conditional assembly\" capability\nof the Assembler.  This means that a macro can make many \"decisions\",\ndepending on how it was initially coded, and also based on variable\nvalues within the invoking program.\n\n      For example, conditional assembly defines \"global\" or \"local\"\nvariables of three types:  arithmentic, binary, or character, with\nGLBA, GLBB, or GLBC, LCLA, LCLB, or LCLC statements.  The values of\nthese variables are set, using SETA, SETB, or SETC statements.\nConditional and unconditional branches, making judgments as to whether\ncertain sections of code will be assembled or not, are controlled by\nAIF and AGO statements.  String values, of precise lengths, can be\ncarefully set and tested within the internal coding of a macro.  The\nIBM manual:  High Level Assembler - Language Reference (SC26-4940) has\na wealth of information, in several chapters, about the details of\nmacro coding.\n\n      For now, I have to say goodbye until next month.  I hope this\nmonth's discussion was useful to you, and I'm looking forward to seeing\nall of you again.\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   Illustration of COPYFILE message formatting.  It uses\n            the MSG macro, which invokes the MSGWRITE sub-program,\n            that in turn, writes the formatted message to the //MSG\n            ddname.\n\n\n   The following is the //MSG file of a COPYFILE program invocation:\n\n ***SELECTED FILES ARE BEING COPIED FROM VOL=SER=TAPEAA TO VOL=SER=TAPEBB\nFILE   7 WAS COPIED TO FILE   5   DSN=TAPEAA.FILE0007\nFILE   8 WAS COPIED TO FILE   6   DSN=TAPEAA.FILE0008\nFILE  22 WAS COPIED TO FILE   7   DSN=TAPEAA.FILE0022\n\n\n   This message resulted from the following invocations of the\n   MSG macro in the COPYFILE program.  The MSG macro constructs\n   the text of the message from program variables, and invokes\n   the MSGWRITE subroutine that is linkedited into the COPYFILE\n   program load module.  MSGWRITE writes the formatted message,\n   constructed by the MSG macro, into the print file defined by\n   the //MSG DD card.\n\n   The following MSG macro invocation:\n\n    MSG '***SELECTED FILES ARE BEING COPIED FROM VOL=SER=',C'1',  X\n         (C,INVOL1,6,4),' TO VOL=SER=',(C,OUTVOL1,6,4)\n\n   formats the report header.  While the next invocation:\n\n    MSG 'FILE ',(D,INFILE,3),' WAS COPIED TO FILE ',(D,OUTFILE,3),X\n      '   DSN=',(C,DSN)\n\n   documents which file from the input SL tape was copied to which\n   file of the output SL tape, and what its dataset name was.\n\n   For the record, this output has resulted from the following\n   COPYFILE control cards:\n\n  //SYSIN    DD *\n   7/5  8  22\n  /*\n\n   whereby file 7 of volume TAPEAA is to be copied into file 5\n   of TAPEBB, file 8 of TAPEAA goes into the next file (file 6)\n   of TAPEBB and file 22 of TAPEAA goes into the next file\n   (file 7) of TAPEBB.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0004AP": {"ttr": 20746, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x01\\x00\\x06\\x1f\\x01\\x00)\\x9f\\x11G\\x01a\\x01a\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2000-03-01T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 353, "newlines": 353, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           APRIL 2000\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@attglobal.net and/or sbgolob@aol.com.\nThe Online CBT Tape web site has its own URL.  However, it can also\nbe reached from the \"Members Only\" section of www.naspa.net .\n\n\nLEARNING ABOUT YOUR MVS SYSTEM\n\n      MVS systems programmers have a lot in common with EDP auditors,\nexcept that we have a difference in emphasis.  EDP auditors have the\njob of finding out what's in an MVS system, without getting a lot of\noutside help.  We MVS systems programmers actually set up the system, so\nin that case, we know what's in it.  But sometimes, when taking a first\nlook at some installation's running system, we MVS sysprogs aren't in\nmuch of a different situation than the EDP auditors.  That can be true\nif we're just starting a new job, or if we're a consultant coming into\na shop for a relatively short time.  This actual skill subset of MVS\nsystem programming--learning about the \"guts\" of a running system\nwithout outside help--is actually almost identical to what EDP auditors\ndo every day.\n\n      Some years ago, a noted EDP auditor, Lee Conyers, contributed two\nfiles full of his tools, Files 220 and 221, to the CBT MVS Tape, a\nhuge collection of free software utilities that is publicly available.\nThe aim of most of Lee's tools was to get information about the running\nsystem's essential parts, from the system itself, without outside help.\nSome of the things that Lee's tools look for, are:  PARMLIB information,\nlists of APF libraries, defined SUBSYSTEMS, online TAPE, DISK, terminal,\nand communication devices, ENQUEUE displays, ENQUEUE contentions, and\nmuch more similar information.  In reality, the MVS system contains all\nthis information in control blocks--you just have to know where to look\nfor it, and how to format it.  Lee's tools date from XA 2.2.3 times.\nHowever, I've recently seen some modern, and free, packages, which work\nfor OS/390 systems and which display not only all the info that Lee was\nlooking for, but even more.  These are the tools that we're going to\ntalk about today.\n\n      These remarkable publicly available packages are:  MXI from Rob\nScott, TASID from Doug Nadel, and SHOWMVS from Gilbert Saint-flour and\nhis helpers.  All of these three packages work under ISPF.  Each works\nin a different way from the others, and all of them show a surprisingly\nlarge amount of information about what's going on in your MVS system,\neven when they're not running authorized.  Please refer to Figure 1,\nas a reference to where to download these and other tools.\n\n\nHOW TO GET GOING.\n\n      MXI is the only one of these three packages which requires a\nsignificant amount of setup.  You copy the MXI load modules into a load\nlibrary that is available to your TSO session, and you copy the MXI\npanels into a library that's in your ISPPLIB concatenation.  Then you\ncopy the MXI table members into a library in your ISPTLIB concatenation.\nIf you don't want to change any defaults, all you have to do now, is to\nexecute the MXI load module by saying:  TSO MXI from the ISPF command\nline.  The other two packages require just about no startup installation\nat all.  Just copy the SHOWMVS and TASID load modules into your ISPLLIB\nor TSO STEPLIB library and execute them from the ISPF command line.\nTASID has the ISPF panels built into its load module, and SHOWMVS\ndoesn't require any panels at all.\n\n      Then the fun begins.  All you have to do is to execute any of\nthe three programs by typing TSO followed by the program name (MXI,\nTASID, or SHOWMVS) on the ISPF command line.  With any of these three\nprograms, amazing things start to happen, and you get your \"EDP\nAuditor's information\", pretty much to your heart's content.  Let's\ntalk about MXI first, then TASID, then SHOWMVS.\n\n      When you first get into MXI, you get a screen like the one shown\nin Figure 2.  Most of the options are highlighted, and some might not\nbe.  If you're not running MXI (or one of the other two products) as an\n\"authorized\" TSO command, some of the options will not be available,\nbut they are very few in number.  In MXI's case those missing options\nwill show, but they'll be un-highlighted.  I'll talk later about how to\nrun a TSO command \"authorized\".  Once you're in MXI's main menu, all\nyou have to do is to move the cursor to one of the highlighted options,\nand press Enter.  You'll get a sub-display with much more detail.  In\nthe sub-display, the general rule is that if you move the cursor to a\nhighlighted field and press Enter, you'll be able to obtain another,\nmore specific, sub-display.\n\n      Both MXI and TASID have excellent storage browsing facilities\nwhich display main memory in the computer.  If an MXI display shows a\nmain storage address, you can usually move the cursor to it, press\nEnter, and obtain a nicely formatted display of the \"incore\" storage.\n\n      Take a good look at Figure 2.  At a glance, you'll see all kinds\nof categories of information about your running system, that would make\nan EDP auditor's mouth water.  If you want more detail, MXI seldom\ndisappoints you.  For example, if you want to know more information about\nwhat load libraries are APF authorized, just move the cursor to APF on\nthe main menu, and press Enter.  The full list of authorized libraries\nwill appear on the screen.  But there's a bonus, as there is with many\nof MXI's displays, and this is only a typical example.  As you know, an\nAPF authorized library is characterized by both a dataset name and a\nvolume serial of a DASD volume.  In the MXI APF display of datasets,\nyou can \"click\" (move the cursor and press Enter) on the volume serial.\nThen you'll immediately get a DASD detail display, with more fields\nin turn, on that display, that you can \"click\" on.\n\n      So you can see that MXI's displays are not strictly hierarchical\nor tree-like.  They also have a lot of internal relationships with\neach other.  This makes finding information very convenient, using MXI.\nMy experience with MXI tells me that you have to spend time with it,\nand explore your system.  There is so much information available, that\nI can't mention it all here.  You have to use the product yourself.  It\nis utterly fascinating.  Thanks, Rob!\n\n      Now, on to TASID.  TASID is written by Doug Nadel, an ISPF\ndeveloper who works for IBM.  Doug wrote TASID as a tool for himself,\nbut since it was written on IBM equipment, it carries an IBM copyright\nnotice.  That's why TASID can't be put on the CBT Tape, since it's the\nproperty of IBM.  Nevertheless, TASID is downloadable and available for\neveryone to use.  See Figure 1 for the URL to get TASID, and the URLs\nfor all the other tools we're going to mention.\n\n      Since Doug is an ISPF developer, you'd expect that TASID would be\ncoded very slickly.  It definitely is very smooth to use, and all the\npanels are built in to the load module.\n\n      Look at Figure 3, which shows the main menu of TASID.  Besides\nhaving a choice of options at the top, the TASID main menu immediately\ndisplays your system's IPL, configuration, and software level\ninformation.  Like MXI, TASID is panel oriented, but TASID is more\nhierarchical to operate, and doesn't cross-connect as much as MXI does.\nOne of the really nice features of TASID is its SNAPSHOT display, which\nhas the potential of showing information about many of the system's\ninternal characteristics and current states.  This is done via ISPF\nBROWSE.  In a sense, TASID's SNAPSHOT display is somewhat similar to\nwhat's done by Gilbert Saint-flour's SHOWMVS.  Again, TASID is a big\nproduct, and you have to spend time exploring TASID to properly\nappreciate it.\n\n      Now our quick tour goes to SHOWMVS.  You execute SHOWMVS as a\nTSO command, but SHOWMVS is different from the other two products.\nEven though SHOWMVS needs ISPF to operate, it has no panels at all.\n\n      The SHOWMVS display is presented to the terminal user through\nISPF BROWSE.  All of the information is displayed, seemingly at once,\nand the SHOWMVS display can be 4000 lines long or more, on a large\nsystem.  There is one amazing fact about the SHOWMVS display, which\nmakes it quite different from most datasets and objects that are ISPF\nBROWSE'd.  The difference is, that the SHOWMVS display is dynamically\nrefreshed.  I'll tell you how.\n\n      Some of the information presented by SHOWMVS, for example, the\ndynamically obtained UCB information, takes time to gather.  Initially,\nSHOWMVS presents IPL and system software level info at the top of the\ndisplay immediately, and keeps the UCB information, the Link List and\nLPA List and APF List library information further down, where you can't\nimmediately see it, without using an ISPF FIND command.  Initially,\nmuch of that latter information is displayed as a blank shell, and\nSHOWMVS attaches a subtask, to go look for this information and\ngradually refresh the BROWSE'd display.  Every time you press Enter\nafter SHOWMVS is running, the subtask is called, to further refresh\nthe screen.\n\n      I'll illustrate.  Suppose you invoke SHOWMVS with an immediate\nFIND command afterwards.  For example, invoke:\n\n            TSO SHOWMVS;FIND 'Link-List'\n\nThe Link List datasets will display as a shell, with no DASD\ninformataion available yet, from the UCB's.  Then press Enter a couple\nof times.  You'll see the DASD information magically appearing in the\ndisplay.  I'd bet you've never seen an ISPF BROWSE which acted like\nthat!\n\n      SHOWMVS gives an enormous amount of information about your\nrunning system and about your own TSO session.  All the information\nis displayed as though it were in one big \"file\".  If SHOWMVS has some\ndifficulty obtaining some of the information to you, that component\nsimply doesn't display, while all the rest of the information does.\nThat's how it works.  You usually have to use a FIND command to find\nwhat you're looking for.\n\n      If SHOWMVS is running as an authorized TSO command, it'll display\nmore info, such as the PPT (Program Properties Table) information,\nwhich you need APF authorization to get.  When SHOWMVS is not running\nauthorized, the PPT information simply isn't there.  It works the same\nway with the other authorized functions.  But SHOWMVS, even running\nnon-authorized, will get so much information for you, that it'll\nboggle your mind.  SHOWMVS uses some undocumented IBM functions to\nobtain info.  For example, SHOWMVS can do a UCB scan and get the real\nUCB's, not just a copy, even though it's running non-authorized.  In\nmy January 1996 column, I wrote about this interface, and how SHOWMVS\ndoes this.  SHOWMVS needs the real UCB, to be able to do its dynamic\nrefresh of information.\n\n      I'll conclude with a quick remark about TSO command authorization.\nA TSO command is a load module.  In order for it to run with APF\nauthorization, several conditions have to be satisfied.  First, the load\nmodule has to be APF authorized, having a bit set in its pds directory.\nAt linkedit time, you set this bit on, with the SETCODE AC(1) Linkage\nEditor statement.  The free PDS 8.5 program from File 182 of the CBT MVS\nTape, or the STARTOOL vendor product from Serena, can set this bit on\ndynamically, by its subcommand:  ATTRIB modname AUTH .  Next, the\nmodule must reside in an APF authorized library.  All of the products,\nMXI, TASID, and SHOWMVS, can tell you which libraries on your system\nare APF authorized.  Finally, TSO has to know about the module, and\nTSO has to give it authorized status.\n\n      How does TSO \"know\" about running a module as an authorized\ncommand?  TSO keeps a table in storage, that's initialized in a\nPARMLIB member IKJTSOnn.  You can see this member from MXI.  Just\n\"click\" on PARM, \"click\" on an active PARMLIB library, top first,\nand you'll see an ISPF BROWSE member list of all the members in the\nlibrary.  BROWSE the appropriate member, and you'll see an AUTHCMD\nNAMES list.  If a program is in this list, and the other two criteria\nmentioned above are also satisfied, then TSO treats the command as\nauthorized.  If you can get permission, it will help to put MXI,\nTASID, and SHOWMVS in this list.  If you can't get this permission,\nand you can run your TSO session with an authorized STEPLIB library,\nyou can obtain your own personal TSO authorization.  I've talked\nabout \"private TSO authorization\" in my October 1995 column, and\nyou can find further information by downloading Files 185 and 186\nfrom the CBT Tape web site.\n\n      I am sure you will profit greatly from the infromation in\nthis month's column.  I hope to see you again, happy and smiling,\nnext month.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   Some URL's you can use.\n\n            Here are some URL's which you can use, to obtain the\n            free, publicly available software materials mentioned\n            this month.\n\n  Rob Scott's home page:           http://www.secltd.co.uk/home.htm\n\n  Doug Nadel's home page:          http://www.mindspring.com/~somebody\n\n  Gilbert Saint-flour's home page:   http://members.home.net/gsf\n\n  Useful FTP for downloads:        ftp://ftp.cbttape.org/pub/cbttape\n\n           (See contents in subdirectories--you'll figure them out.)\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.   The main menu of MXI from Rob Scott.\n\n            You can see how numerous and abundant are the kinds of\n            MVS system information which MXI makes available.  What\n            doesn't show is the amount of detail available in the\n            sub-categories which lie underneath these main\n            categories, such as the \"main memory display\" for many\n            of the active system modules.\n\n\n MXI - P390 - MVS Extended Information Primary Option Menu --------- Row 1 of 33\n Command ===>                                                  Scroll ===> CSR\n\n APF  APF List Dataset Information       NTOK System Name/Token Information\n ASID Address Space Usage Information    NUC  Display System Nucleus Modules\n CAT  Catalog Information                PAGE Page Dataset Information\n CA1  CA-1 Configuration Information     PARM Active PARMLIB Information\n CF   Coupling Facility Information      PC   PC Routine Information\n CPU  CPU and LPAR Information           PLEX Display Sysplex Information\n CS   Common Storage Usage               PPT  Program Properties Information\n CSR  Common Storage Remaining           RS   Real Storage Usage Information\n DA   Active Address Space Information   SCLS SMS Storage Class Information\n DASD Online DASD Information            SGRP SMS Storage Group Information\n DCLS SMS Data Class Information         SMF  SMF General Information\n DDNS Allocated Dataset Information      SMFD SMF Dataset Information\n DYNX Dynamic Exit Information           SMS  SMS Configuration Information\n EDT  Display EDT Information            SMSM SMS Module Map\n ENQ  Display ENQ Information            SP   Common Storage Subpool Usage\n ENQC Display ENQ Contention             SPD  Subpool Definitions\n EXC  System Exceptions                  SSI  Subsystem Information\n GRS  GRS Resource Name Lists            STOR System Storage Information\n HSMQ HSM Request Queue Information      SVC  SVC Information\n IPL  IPL and Load Information           SYM  Static System Symbols\n LINK Linklist Dataset Information       SYSX System Exit Information\n LLS  Linklist Set Information           TAPE Online TAPE Information\n LLSU Linklist Set Usage Information     TCB  TCB and RB Information\n LPA  LPA List Dataset Information       UIC  UIC Information\n LPD  Link Pack Directory Entries        USP  User Subpool Information\n MCLS SMS Management Class Information   VMAP Display Virtual Storage Map\n MEM  Display Memory                     XCFM Display XCF Members\n MPF  MPF Information                    XCFS Display XCF Structures\n NET  VTAM Major Node Information\n\n                                         MXI Version 2.1d\n                                         (c) Scott Enterprise Consultancy Ltd\n                                         http://www.secltd.co.uk\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 3.   The Main Screen of TASID by Doug Nadel.  Even though this\n            product is free, it was written on IBM equipment, and it\n            carries an IBM copyright.\n\n\n   File  Navigate  Settings\n -------------------------------------------------------------------------------\n                                TASID option menu\n Option  ===>\n\n    Select one of the following options:                   Version 5.06c\n        1 - Address space list        5 - Miscellaneous displays\n        2 - System ENQ contention     6 - Current dataset allocations\n        3 - Total system ENQ status   7 - Storage View Facility\n        4 - Initiator Status List     8 - Snapshot\n                                                                    More:     +\n   +----------------------------------------+-----------------------------+\n   |   Current time  21:56 on 2000/02/28    |   TSO users            2    |\n   |   Last IPL time 14:38 on 2000/02/19    |   Started tasks       15    |\n   |   IPL Parameters 0130 06   1           |   Jobs                 2    |\n   |   OS/390   02.06.00 JES version JES2   |   System addrs        25    |\n   |   SMF ID   P390     JES level   2.5.0  |   Free initiators      6    |\n   |   User ID  SBGOLOB  RACF level  2.6.0  |-----------------------------|\n   |   Node     N1       TSO version 2.6.0  |   Total               50    |\n   |   VTAM Adr SC0TCP01 VTAM Level  4.5    |-----------------------------|\n   |   Proc     TSOPROC  DFSMS level 1.4.0  |   CPU utilization 56%       |\n   |   Region   6M       DSS Level   1.4.0  |   CPU 7490       (  1 CPU)) |\n   |   RACF Grp GUESTS   DSF  level  1.16.  |   ENQ Contention  None      |\n   |                     ISPF Level  4.5.0  |   Real Storage    130,944K  |\n   |                                        |   Expand Storage  0K        |\n   |----------------------------------------+-----------------------------|\n   |   MVS Information: OS/390 02.06.00                                   |\n   |   JES Information: JES2 / OS 2.5.0 / HJE6605                         |\n   |   Sysres: OS39R6     System: P390       PLEX: LOCAL                  |\n   |----------------------------------------------------------------------|\n   |   This system keeps a history of 0 passwords.                        |\n   |   Automatic revocation after 5 invalid logon attempts.               |\n   |   Password warning is 0 days before password expires.                |\n   |   User ids are revoked after 60 days of inactivity.                  |\n   |   RACF program control is not available.                             |\n   |----------------------------------------------------------------------|\n   |   SMS is available with PDSE support.                                |\n   |   TASID 5.06c - Compiled at 17.20 on 10/15/99                        |\n   +----------------------------------------------------------------------+\n (c) Copyright IBM Corp, 1993, 1998. All Rights Reserved.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0005MY": {"ttr": 20997, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x00\\x06o\\x01\\x00)\\x9f\\x11G\\x01=\\x01=\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-03-06T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 317, "newlines": 317, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                            MAY 2000\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@attglobal.net and/or sbgolob@aol.com.\nThe Online CBT Tape web site has its own URL.  However, it can also\nbe reached from the \"Members Only\" section of www.naspa.net .\n\n\nACCUMULATING ASSEMBLER TECHNIQUES\n\n      Newer MVS systems programmers are amazed at how much the\n\"old-timers\" know about the MVS operating system.  It is manifestly true\nthat the MVS (aka OS/390) operating system has a tremendous number of\nsoftware parts and components which work together.  And to a new person,\nthe older practitioners seem to be thoroughly knowledgeable in them,\nwhile most newer MVS people (there are a few exceptions) scratch their\nheads in amazement, and wonder how.\n\n      Today, I'd like to show the true reasons why the old-timers know\nso much about the \"current\" MVS systems.  I would have \"logically\"\nsurmised that the opposite should be the case, but that's not so at all.\nOld-timers have newer systems programmers (generally speaking) solidly\nbeaten, when it comes to thorough \"insider\" knowledge of MVS internals.\n\n      The main reason is that much of MVS is old code--25 or more years\nold.  The second reason is that the OS/360 systems, through MVT, VS2,\nMVS/370, MVS/XA, and MVS/ESA have always been upwardly compatible.  Most\nof the old programs will still run on the newer MVS systems.  Therefore,\nMVS knowledge that has been built over time, usually does not become\nobsolete.  The old facts continue to be true, for the most part.  So as\nthe systems get newer, the only things the older people have to learn,\nare the exceptions and the new features.  The rest of their knowledge\nremains solidly intact, and it's just as true as it was 30 years ago.\n\n      Newer people wonder if there's a way to catch up.  I think there\nis, but it takes a lot of work, and a plan.  Today, I'm here to provide\nthe plan.  You and I both, will have to do the work.\n\n\nTHE ASSEMBLER BASIS FOR MVS KNOWLEDGE\n\n      No matter what anybody says, the MVS operating system is written\nin Assembler Language.  Of course, there's IBM's internal PL/1-like\nlanguage, whether they call it PL/S, PL/AS, PL/X, or whatever.  But\neveryone will admit that these languages were only made to quicken the\ndevelopment of what is essentially Assembler code.  IBM needed an edge\non its competitors, to be able to develop system-level code faster than\nthe others could, so that's why they invented these proprietary\nlanguages.  But I'll prove that their purpose was only to develop\nAssembler code; the output of these PL/whatever compilers is not an\nobject deck--it's only Assembler source code!\n\n      Since the Operating System was constructed using Assembler, it\nfollows that utilities which manipulate Operating System constructs--\ncontrol blocks, system data, queues, or whatever--should also best be\nmade, using Assembler.  So where's the \"edge\" that old-time MVS system\nprogrammers have?  It's in their Assembler skill, and specifically, in\nthe fact that they know how to access the MVS components and data\nstructures in Assembler language programs.\n\n      Today is the \"age of OCO\".  Source code for the system components\nand for utilities which manipulate them, is being hidden away by IBM,\nand much more so by the other software vendors.  An up-and-coming\nsystems programmer today, is handicapped by this trend.  Where can you\nlearn about system coding, if you can't see any code?\n\n      Well, you can see SOME of the code.  The older programs in the\noperating system, which aren't (yet) OCO (Object Code Only), are still\navailable in the Optional Materials that you can order from IBM.  Also,\nIBMlink supports a facility to \"view system module\" source code, even if\nit's OCO, provided that your installation is licensed for that product.\nBut to a newer programmer, especially with today's emphasis on just\ninstalling products \"out of the box\", it's daunting to try and break in.\nYou don't have so much time.  And you just don't know where to start!\n\n\nTHE PLAN.\n\n      I have a plan how to break into learning about MVS system\ninternals.  Many have followed this plan, and succeeded to an amazing\ndegree.  In essence, this is really the same plan that the old-timers\nfollowed when they were breaking in--only at that time, it was the\n\"official\" way that systems programmers worked.  Nowadays, it's only\noptional, at best.  Today, you need to supply your own ambition.\nUnder present-day job conditions, this motivation to grow doesn't\nusually come from the job itself.\n\n      The idea of the plan is to write, or fix, your own system\nutilities, and thereby to accumulate knowledge about how to manipulate\nthe MVS system parts.  Each utility will access one, or several, MVS\nsystem components, and/or will manipulate some data.  By gathering\nexperience, first with one utility, then with another, then with\nstill another, you'll eventually accumulate a great store of knowledge\nabout many system components.  All of this knowledge will serve you in\ngood stead, for years to come.  IBM isn't about to ruin all the code\nrunning in all the MVS shops, by changing the system so much, that the\nold programs won't work any more.\n\n      Usually, it's easier to start by fixing a utility, than by writing\nit from scratch.  In the old days, people would usually write their own\nutilities from scratch, and obviously, that gave the better training.\nBut these days, with less job-induced motivation, and less time for the\nproject, it's probably better to start by looking at somebody else's\nprograms.  Fortunately, we have enormous repositories of old utilities\nthat are freely available for anybody to look at.\n\n      The first source for ready-made utilities that have source code,\nis the CBT MVS Utilities Tape web site that is accessible online through\nthe Internet.  If you want more info on CBT Tape materials, you can\nemail me.  The CBT Tape web site has its own URL, and is completely\npublicly accessible, but if you're a NaSPA member, you can also get to\nit from the members only section of the NaSPA web site:  www.naspa.net .\nBesides the CBT Tape web site, there are the older materials from the\nXephon archives (1997 and back) that are available to non-subscribers of\nthe Xephon journals.  If you want to explore further, you can follow the\nlinks to other MVS-related sites from the CBT Tape web site, NaSPA's web\nsite, or Eric Loriaux' web site at www.loriaux.com .  The CBT Tape\nmaterials are actually available as a tape, or on cd-rom.  For more\ninformation, email Sam Knutson at sknutson@cbttape.org, or contact the\nNaSPA office, or do both.\n\n      Now that we know where to start looking for old utilities, how\ndo we begin using the materials, and where do we break in?  The answer\nis:  look through the CBT Tape contents on File 001 of the CBT Tape,\nand pick something that seems interesting to you.  Then go download\nthe file(s) containing the source code, and start looking at it.  Try\nthe program, and see how it works externally.  Then look at the code,\nand try and see how it does it's \"magic\".  Gradually, the workings of\nthe system components, as they are accessed, will unfold to you--one\ncomponent at a time.\n\n      Let's start with an example.  Consider the COPYMODS program from\nFile 229 of the CBT Tape.  COPYMODS is a utility which allows you to\nmake from one to ten duplicate copies of all files in a magnetic tape,\nincluding the labels.  Obviously, in order to do this, the COPYMODS\nprogram requires that you have \"BLP privilege\" for your userid, in both\nthe JES class and in the security system, because the program ignores\nall the label information in the output tape(s), and most of the label\ninformation in the input tape.  The COPYMODS program requires the\nddname IN for the input tape, and OUT1, OUT2, ... thru OUT10 optionally,\nfor up to 10 output tapes.  See Figure 1 for sample COPYMODS JCL.\n\n      Why are we mentioning COPYMODS here?  Because we want to learn\nsome system internals information from the way COPYMODS works.  And\nit'll be the same idea, from any other utility program you study.\n\n      The COPYMODS program has to find out which ddnames you've coded in\nyour JCL, in order to figure out which output files to open.  You may\nwant to make only one output tape, in which case you'd only code one\noutput DD card, perhaps OUT1, or it could be OUT4 or OUT7.  Or possibly\nyou might want to make four tape copies, as illustrated in the sample\nJCL of Figure 1.  Then you'd code four output ddnames, perhaps OUT1 thru\nOUT4.  When the COPYMODS program starts executing, it has to determine\nwhich ddnames that look like OUT1 thru OUT10, are present in your JCL.\nOnce you see how COPYMODS does this, you'll learn about the TIOT control\nblock, and how to access ddnames in an Assembler program.  This will be\na piece of knowledge that you'll store up for the future.\n\n      Look at the code snippets in Figure 2.  You see how to access\nthe beginning of the TIOT (Task IO Table) control block from the CVT\n(Communication Vector Table) that is the starting point for getting\nto most MVS system information.  The beginning of the CVT is pointed\nto at virtual storage location X'10', or decimal 16.  This was true\nat the beginning of OS/360, with real storage location X'10', and it'll\nprobably always be true, as long as this operating system exists.  Once\nyou've got the TIOT and point to the first ddname, you can start\nchecking for the presence of the ddnames you're looking for.  If, in\nthe future, you ever have to check for the presence of a ddname in a\nprogram, you'll always know how to do it.\n\n\nBUILDING FOR FUTURE KNOWLEDGE\n\n      Now that you've seen a piece of this process, you can go about\nstarting to accumulate knowledge for yourself.  Pick a utility you like,\nand study its parts.  Try and change the program a bit, using some of\nthe other things you've already learned.  Test the changed program out,\nto see if you've actually accomplished the result that you'd wanted to\nachieve.  As you build success upon success, your knowledge will grow\naccordingly.  And over the years, your own knowledge can build, even to\nthe point of equalling that of the old-time experts.  It all depends on\nyour ambition.  Good luck.  I hope to see you again next month.\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   Sample JCL to run the COPYMODS program from File 229\n            of the CBT MVS Utilities Tape.\n\n            DD for the input tape is IN.  DD for one to ten output\n            tapes is OUTn, where n can be any number from 1 to 10.\n\n            The COPYMODS program has to find out which output DD\n            names are present.  For this purpose, it must search\n            the TIOT (Task IO Table) control block, and make a\n            determination which output files to open.\n\n            Note that the output VOLSER's are dummy names.  MVS JCL\n            requires that they be different from the input VOLSER.\n            But the output tapes will contain exactly the same data\n            as the input tape, including the labels, if any.\n\n\n//SBGCSCP JOB (A006,SYTM,99,99),S-GOLOB,\n//        CLASS=Q,MSGCLASS=V,NOTIFY=&SYSUID\n//*\n//**********************************************************\n//*     COPY 2 TAPES - EVERYTHING\n//**********************************************************\n//*\n//COPY   EXEC  PGM=COPYMODS,REGION=4096K\n//STEPLIB  DD  DISP=SHR,DSN=SYS2.MVSP.SDTS.USERLIB  (authorized)\n//SYSPRINT DD  SYSOUT=*\n//IN   DD VOL=SER=CBT406,DISP=OLD,UNIT=NOSILO,LABEL=(,BLP)\n//OUT1 DD VOL=SER=CBT40A,DISP=OLD,UNIT=EXPORT,LABEL=(,BLP),\n//    DCB=TRTCH=NOCOMP\n//OUT2 DD VOL=SER=CBT40B,DISP=OLD,UNIT=EXPORT,LABEL=(,BLP),\n//    DCB=TRTCH=NOCOMP\n//OUT3 DD VOL=SER=CBT40C,DISP=OLD,UNIT=EXPORT,LABEL=(,BLP),\n//    DCB=TRTCH=NOCOMP\n//OUT4 DD VOL=SER=CBT40C,DISP=OLD,UNIT=EXPORT,LABEL=(,BLP),\n//    DCB=TRTCH=NOCOMP\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.  Code from the COPYMODS program which checks if any\n           ddnames from OUT1 to OUT10 are present in the JCL.\n\n           DD names from the JCL, go into the TIOT (Task IO Table)\n           control block, which is accessible from the CVT\n           (Communication Vector Table) using the following code:\n\n           This code hasn't gone \"out of style\" in 25 years,\n           and it still works perfectly.  This shows you how\n           to access ddname information in an Assembler program.\n\n*\n*  DETERMINE WHICH OUTPUT DD'S ARE PRESENT\n*\n         L     R2,16          R2=CVT\n         L     R2,0(,R2)      R2=TCB WORDS\n         L     R2,4(,R2)      R2=MY TCB\n         L     R2,12(,R2)     R2=TIOT\n         LA    R2,24(,R2)     R2=FIRST DD ENTRY\nTIOTLOOP CLC   0(4,R2),=XL4'00' END OF TIOT?\n         BE    OPENS          YES\n         CLC   4(8,R2),OUT1+40  OUTPUT FILE NUMBER 1?\n*                             Test hard-coded ddname in DCB\n*                             against TIOT entry coming from JCL.\n         BNE   TIOT1          NO\n         OI    FLAG1,OP1      YES. MARK ITS PRESENCE\n         B     TIOTNEXT       CONTINUE LOOKING AT NEXT ENTRY\nTIOT1    CLC   4(8,R2),OUT2+40  OUTPUT FILE NUMBER 2?\n*                             Test hard-coded ddname in DCB\n*                             against TIOT entry coming from JCL.\n         BNE   TIOT2          NO\n         OI    FLAG1,OP2      YES. MARK ITS PRESENCE\n\n         ******   thru TIOT9, similar code checking the 10 names.\n\nTIOTNEXT SR    R3,R3\n         IC    R3,0(,R2)      R3=LENGTH OF DD ENTRY\n         AR    R2,R3          R2=NEXT DD ENTRY\n         B     TIOTLOOP       GO CHECK IT\n*\n*  OPEN ALL FILES\n*\nOPENS    OPEN  (IN,,SYSPRINT,OUTPUT)\n         MVC   FLAG3(2),FLAG1 SAVE INDICATION OF WHICH FILES ARE HERE\n         TM    FLAG1,OP1      OUTPUT 1 PRESENT?\n         BZ    OPEN1          NO\n         OPEN  (OUT1,OUTPUT)\nOPEN1    TM    FLAG1,OP2      OUTPUT 2 PRESENT?\n         BZ    OPEN2          NO\n         OPEN  (OUT2,OUTPUT)\n\n         ******      etc.  Test thru 10 ddanmes.\n\nIN       DCB   MACRF=(E),DDNAME=IN,DEVD=TA,DSORG=PS,RECFM=U\nOUT1     DCB   MACRF=(E),DDNAME=OUT1,DEVD=TA,DSORG=PS,RECFM=U\nOUT2     DCB   MACRF=(E),DDNAME=OUT2,DEVD=TA,DSORG=PS,RECFM=U\n\n         ******      etc.  Thru the 10 output DCB's.\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 3.   An excellent Assembler Language book for Systems\n            Programmers.\n\n            This book will teach you many techniques for\n            accessing MVS operating system services.  This\n            book is a \"must have\" for all MVS systems\n            programmers.\n\n        Title:      Advanced Assembler Language and MVS Interfaces\n                    Second Edition\n        Author:     Carmine A. Cannatello\n        Publisher:  John Wiley & Sons Inc.\n                    Professional, Reference and Trade Group\n                    650 Third Avenue\n                    New York, NY 10158-0012\n                    (800) 225-5945   x2497\n        ISBN:       0-471-36176-3\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0006JN": {"ttr": 21003, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x00\\x10\\x9f\\x01\\x00)\\x9f\\x11G\\x01r\\x01r\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-04-18T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 370, "newlines": 370, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           JUNE 2000\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@attglobal.net and/or sbgolob@aol.com.\nThe Online CBT Tape web site has its own URL.  However, it can also\nbe reached from the \"Members Only\" section of www.naspa.net .\n\n\nCOPYING TAPES\n\n      As a longtime systems programmer who has talked with many of my\npeers over the years, I am puzzled by some people's attitudes about the\ncopying of tapes.  I have heard many opinions about the subject--some\nof them very knowledgeable, and some of them surprisingly ignorant.\nWhen asked the question, \"how do you copy a tape?\" people have actually\nanswered:  \"You use IEBGENER.\"  I'd ask in reply: \"But what if the tape\nhas 500 files on it--what do you do then?\"  And I've gotten a blank look\nin return.  Fortunately, most of the people in our field do not answer\nthis question in this way.\n\n      Actually, before you can accurately copy a tape, you should know\nwhat is on it--how many files, standard labeled (SL) or non-labeled\n(NL).  Is it an MVS tape, or a DOS/VSE tape, or does it come from some\nother kind of computer system?  You should know how to use some tools\nwhich can tell you accurately and exactly what kind of files the tape\ncontains, and what they look like.  Today, we'll talk about some\nparticulars from the subject of accurately copying tapes, and we'll\nrecommend some tools for this purpose.  Of course, after the tape has\nbeen copied, you'd like to check and make sure of two things:  first,\nthat the copy was complete--all the files have been copied, and second,\nthat it was accurate--the copy is byte for byte identical with the\noriginal.\n\n\nSome Fundamentals\n\n      Tapes contain sequential blocks of data, one block after another.\nThese blocks are organized into logical files.  And the files are\nseparated one from another.  The separator string which separates one\nfile from another, is called a \"tape mark\".  A tape mark is generated\nby the tape hardware.  It makes a big difference if a tape is \"labeled\",\nor \"non-labeled\".  A labeled tape has each file of data surrounded by\nwhat can be termed \"label files\", or labels, for short.  A non-labeled\ntape has its files separated only by tape marks, with no label files at\nall.  The structure of data files on a tape is very simple, but it is\ncrucial that it be thoroughly and clearly understood.  See Figure 2 for\na simple diagram of how files are arranged on a tape.\n\n      To understand the structure of files on a tape, it is necessary to\nhave some tools, which can generally be termed \"tape mapping programs\".\nI can tell you about some free tape mapping programs, such as TAPESCAN\nand TAPEMAP, which I've found highly useful.  Also, some of the vendors,\nsuch as SAS, have tape mapping tools.  IBM's DITTO programs, both for\nMVS and VSE, can be used to map and copy tapes.  As frequent readers of\nthis column already know, I'd rather write about the free programs,\nwhich can be obtained and used by anyone without restriction.  If you\nknow how to use a free tool, you can use it anywhere, and you can always\ntake that skill with you to any shop.\n\n      Besides mentioning some specific tape mapping programs, such as\nTAPESCAN and the various TAPEMAP programs, I have to talk about the CBT\nMVS Utilities Tape, which contains the source code (and load modules)\nfor these programs.  The CBT Tape is a huge collection of system\nprogrammer \"goodies\" from all over the world.  Physically, the\ncollection is on several tapes.  The CBT MVS Utilities Tape, and the CBT\nOverflow Tape are the two current volumes.  There is also an old version\nof the CBT Tape (Version 249) from July 1985, which contains old\nprograms whose source code would otherwise be hard to find today.  All\nof the files on these tapes can now be downloaded from the CBT Tape web\nsite, which has its own URL, but which can be reached from the \"Members\"\nportion of the NaSPA web site as well.  After discussing the mechanics\nof tape file transfer, I'll look at the operation of one specific\nprogram which can copy tapes conveniently.  Please see Figure 1 for a\nlist of several free tape mapping and copying programs.\n\n\nHow Do Tape Copying Programs Work?\n\n      Tape copying consists of reading a block of input tape data into a\ndata buffer, and then writing the contents of the buffer out to an\noutput tape.  When writing a tape copying program, you must take care to\nposition both tapes appropriately, and to make sure to write the proper\ntape marks, (and labels, if the output tape is Standard Labeled).\n\n      Effective tape mapping and tape copying programs usually use the\nEXCP or BSAM access methods.  While it is perfectly OK to write a tape\ncopying program using QSAM, you get more generality to handle irregular\ntapes, using either EXCP or BSAM.  Furthermore, using both EXCP and\nBSAM, it's possible to copy up to 64K blocks of tape data in one CCW,\nbut with QSAM, you can't--32K is the QSAM limit.  EXCP is the more\nelementary and straightforward of the two methods.  In fact, at least\none of the free programs mentioned in Figure 1, TAPESCAN, which uses\nBSAM for reading tape input, in truth only employs the BSAM for some\nextra window dressing and control, but the actual input I/O is really\nbeing done by EXCP under the covers.  So it's important for us to learn\nsomething about how to do EXCP for tapes.\n\n      EXCP (Execute Channel Program) can be pictured as the \"assembler\nlanguage\" for I/O.  On the other hand, the IBM Access Methods, BSAM,\nQSAM, and the like, can be pictured as higher-level languages for I/O.\nTape files, being sequential files exclusively, are simpler to handle\nthan disk files, so the EXCP to handle tape files will also be quite\nsimple.  You only have to know a few pieces of information, and soon\nyou'll be able to study and write tape EXCP programs like a pro.\n\n      The EXCP process for tapes moves data to or from a tape, and/or\npositions a tape to wherever you want it.  Control of all this is done\nby \"channel programs\".  A channel program consists of a succession of\n\"channel command words\", or CCWs, that are chained to each other.  The\n\"chaining\" is done by turning on a \"chaining bit\" in the third operand\nof the channel command word.  Look at Figure 3 to see the structure of\nchannel command words.  To write a tape EXCP operation, you just have to\nspecify a succession of one or more appropriate channel command words,\nthen include these CCWs into a larger control block (that you construct)\ncalled an IOB, or Input Output Block, and then you EXCP the IOB.  That's\nall there is to it, except for a few details, which we'll now touch on\nbriefly.\n\n      To specify any I/O operation in an assembler program, you always\nneed a DCB macro, to define the ddname of the file you're looking at.\nTo set up EXCP access to the DCB for a file, all you really have to\nspecify is MACRF=E.  Besides that, you can just specify the DDNAME\nkeyword parameter.  With EXCP there are no RECFM or BLKSIZE parameters\nto worry about.  All of that information is specified in the CCWs that\nare executed, and in any deblocking that your program itself does.\n\n      In the generalized tape programs we're looking at, you might also\nwant to do some manipulation of JCL DD parameters inside the program,\nsuch as forcing the operating system to ignore Standard Labels, even if\nyou didn't specify BLP in the LABEL parameter of your JCL.  This type of\nmiracle is done by changing the Job File Control Block (JFCB), which\ncontains all your JCL DD information after your program starts\nexecuting.  To give your program access to this JCL information, you\nhave to set up an Exit List for your DCB, and point to it with the EXLST\nkeyword parameter of the DCB macro.  After you execute a RDJFCB macro,\nthis exit list will contain an accessible image of all your JCL in the\nDD card.\n\n      To make all this work, just set up an exit list address in your\nprogram, which consists of a fullword address in your program that\nstarts with an X'87' character, followed by a 24-byte (3 character)\naddress of a 176-byte area that you specify in you program, to hold all\nof the JFCB information.  To copy (for any use) all the DD information\ninto your 176-byte area, just execute a RDJFCB macro pointing to the\nDCB.  You can then change any DD information, and this is later honored\nif you don't do a regular OPEN of the file, but you do a special type of\nOPEN, called OPEN TYPE=J.\n\n      Now let's look at the EXCP again.  The EXCP operation reads or\nwrites data between the device and your computer storage.  Sometimes an\nEXCP operation will just position the tape, but in any case, this\noperation takes a long time, compared to the short time needed in\nexecuting computer instructions.  In order to stop execution of your\nprogram until the I/O operation completes, you have to issue a WAIT\nmacro after you issue the EXCP macro.  If an EXCP is followed by a WAIT\nmacro, the EXCP \"knows\" how to inform the WAIT macro that the I/O\noperation has successfully been completed.  This communication is done\nthrough a fullword area you specify in your program, called an ECB\n(Event Control Block).  Just specify an ECB as DC F'0', label it, make\nsure the IOB knows where it is, before you do the EXCP, and say WAIT\nECB=this label.  The next instruction in your program should be a TM of\nthe first byte of the ECB to equal X'7F'.  If all these bytes aren't on,\nin other words, if they're not all ONES, then you've got an error\nsituation.  Otherwise, all is well, and you can now go to the buffer and\nread the data (on a read) or you can know the data was written from the\nbuffer to the tape (on a write).  Cool.  It really works.\n\n      This all may seem complicated, but you can study some real code,\nand see this process in action.  Probably one of the simplest tape\ncopying programs I know of, is the COPYMODS program from File 229 of the\nCBT MVS Tape, which makes from one to 16 exact copies of an existing\ntape, end to end.  I'll conclude this article with at step-by-step look\nat the basic operations of the COPYMODS program.\n\n\nThe COPYMODS program.\n\n      The COPYMODS program makes a full copy of a tape, from one end\nto the other.  It doesn't matter if the tape is Standard Labeled (SL)\nor Non-Labeled (NL)--COPYMODS will copy the entire contents of the\ninput tape, to as many as 16 output tapes.  To simplify our explanation,\nlet's assume that there's only one output tape.  The input ddname is\ncalled IN, and the output ddname is called OUT1.  You can obtain the\nsource for the COPYMODS program from File 229 of the CBT MVS Tape, by\nlooking at location\n\nftp://ftp.cbttape.org/pub/cbttape/cbt/CBT229.zip .\n\n      To begin, COPYMODS opens the IN file and the OUT1 file.  Since\nCOPYMODS does not use OPEN TYPE=J, but a regular OPEN, it requires that\nyou specify LABEL=(,BLP) in the ddnames IN and OUT1.  Then the program\nbegins copying files.  It reads the first block of data into a 64K\nbuffer that's right inside the program, and it writes that data out to\nthe output tape, continuing until the first file has been completely\nread.  When the first tape mark is encountered on input, COPYMODS\nwrites a tape mark to the output tape.  All of this is done with EXCP\ninstructions, each pointing to an IOB that contains the correct CCW\nchains.  When two consecutive tape marks are encountered, COPYMODS\nwrites a second tape mark to the output tape, and closes both tape\nfiles.  It's a very simple operation.\n\n      I've recently \"taught\" COPYMODS not to stop at every double\ntape mark.  Sometimes, when copying an SL tape, there's a situation\nin which two consecutive tape marks is normal, and I detect that.\nThis arises when a file with no data, such as an IEBCOPY backup of a\npds with no members, is written to a Standard Labeled tape.  The data\npattern for an SL tape is normally:  HDR1 label, HDR2 label, TM, data,\nTM, EOF1 label, EOF2 label.  If there's no data in the SL file, the\ntwo TM's become consecutive.  So I programmed into COPYMODS, that if\nit \"sees\" a HDR1 and/or a HDR2 followed by 2 consecutive TM's, then\nit should not stop, but it should go on and look for EOF's or EOV's\nin the input tape.\n\n      I hope that you've gotten an appreciation of tape copying from\nthis month's column.  As one practical application, you can use my new\nversion of the COPYMODS program to make real copies of virtual tapes\nthat are in an IBM Virtual Tape box.  The Virtual Tape box has a\nprovision to do a logical \"eject\" of a tape that's inside it, but then\nthe \"tape\" that's inside the box gets deleted.  If you use COPYMODS to\nmake the copy of the \"inside tape\" to an outside tape, then you won't\nhave to actually delete the \"inside\" tape.  Here's a real, practical use\nfor the COPYMODS program in this modern day and age.  Good luck.  See\nyou next month!\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   A Selection of TAPE Copying and TAPE Mapping Programs\n            which are free.  Information on General Function is\n            according to the level of the program on Version 424\n            of the CBT MVS Utilities Tape.\n\n\n\n  Program Name      Where Obtained      General Function\n\n\n  COPYMODS          File 229 of CBT     Can make from 1 to 16\n                    Tape                exact copies of a tape,\n                                        in a single run.  Can now\n                                        copy DOS/VSE tapes and\n                                        tapes with leading tape\n                                        marks.  Can copy tapes\n                                        with blocks up to 64K.\n\n  COPYFILE          File 316 of CBT     Can select files from one\n                    Tape                standard labeled (SL) tape\n                                        and copy the selected files\n                                        to another SL tape.  Has\n                                        sophisticated control card\n                                        scheme to select the files\n                                        to be copied.  Can copy up\n                                        to 64K blocks of data.\n\n  COPYSLNL          File 316 of CBT     Can select files from one\n                    Tape                standard labeled (SL) tape\n                                        and copy them to a non-\n                                        labeled (NL) output tape,\n                                        using the same control cards\n                                        that COPYFILE uses.  Can\n                                        copy up to 64K blocks of\n                                        data.\n\n  COPYNLNL          File 316 of CBT     Can select files from one\n                    Tape                non-labeled (NL) tape to\n                                        another NL tape, using the\n                                        same control cards that\n                                        COPYFILE has.  Can copy up\n                                        to 64K blocks of data.\n\n  CT                File 316 of CBT     Can copy one complete tape\n                    Tape                to another, under operator\n                                        console control.  Can do\n                                        multi-volume copies.  Can\n                                        verify the copy, if it was\n                                        a single volume.  Recently\n                                        fixed to handle 64K blocks\n                                        of data.\n\n  TAPESCAN          File 102 of CBT     Shows details of what is on\n                    Tape                a tape.  Shows tape label\n                                        contents and first 100 bytes\n                                        in hex, of first blocks of a\n                                        tape record.  Maps SL files of\n                                        an SL tape.  Not fixed yet to\n                                        handle 64K byte blocks; only\n                                        good until 32K byte blocks.\n                                        Can be used to copy one tape\n                                        to another.  Handy for tape\n                                        diagnosis.\n\n  TAPEMAP           File 299 of CBT     Shows label information of\n                    Tape.  Another      MVS tapes.  Second report shows\n                    version is on       details of the contents of many\n                    Leonard Woren's     formats of unloaded files, such\n                    web site.           as IEBCOPY, IEBUPDTE, and the\n                                        CBT973-compressed CBT Tape files\n                                        themselves.\n\n  TAPECOPY          File 174 of CBT     This program can copy tapes and\n                    Tape.  This pgm     has many options to handle bad\n                    is from Aron        or damaged tapes.  A unique\n                    Eisenpress.         feature of this program is its\n                                        ability to create a SL tape\n                                        from an NL tape, supplying a\n                                        standard format for a label,\n                                        from parm information.  So\n                                        far, can only handle up to 32K\n                                        blocks.\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.   How files are arranged on IBM MVS Standard Labeled\n            (SL) and on Non-Labeled (NL) tapes.  Let's say each\n            tape contains two files, and they don't fill the\n            volume completely.\n\n\n   SL tape:  VOL1 label, HDR1 label, HDR2 label, TM, File 1 data, TM,\n             EOF1 label, EOF2 label, TM, HDR1, HDR2, TM, File 2 data,\n             TM, EOF1, EOF2, TM, TM.\n\n   NL tape:  File 1 data, TM, File 2 data, TM, TM.\n\n\n   IBM References:  DFSMS/MVS  Using Magnetic Tapes   (SC26-4923)\n                    DFSMS/MVS  Using Data Sets        (SC26-4922)\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 3.   Structure of a Channel Command Word (CCW).\n\n\n            A CCW is eight bytes in length, and the IBM assembler\n            \"understands\" the CCW instruction, with four operands,\n            without its being a macro.\n\n            A CCW, defined by a CCW instruction, looks like:\n\n label     CCW  one byte command code,\n                3-byte address of buffer,\n                flag bits for chaining, etc. (2 bytes)\n                length of data to be moved (up to 64K - 2 bytes)\n\n           Command codes can be found in the IBM \"yellow card\"\n           pocket reference.  Some command codes for tapes are:\n\n           X'02'   Read\n           X'01'   Write\n           X'07'   Rewind\n           X'1F'   Write Tape Mark\n           X'03'   No Operation\n           X'37'   Forward Space Block\n           X'3F'   Forward Space File\n           X'27'   Back Space Block\n           X'2F'   Back Space File\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0007JL": {"ttr": 21254, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x00\\x13o\\x01\\x00)\\x9f\\x11G\\x01\\x9c\\x01\\x9c\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-05-15T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 412, "newlines": 412, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           JULY 2000\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@attglobal.net and/or sbgolob@aol.com.\nThe Online CBT Tape web site has its own URL.  However, it can also\nbe reached from the \"Members Only\" section of www.naspa.net .\n\n\nSCANNING FOR PARMS IN A BATCH PROGRAM\n\n      As we all know, many programs, and especially utility programs,\nhave options.  These are switches that we can turn on or off.  Each\nswitch tells the program that it can run one way, or another way.  You\ncan invoke one feature, another feature, both, or neither of them.\n\n      There are various mechanisms of telling a program how to change\nits execution style.  We can write a program so the switch info is\ncontained in the execution PARM field in the JCL.  Or we can code the\nprogram so it reads SYSIN control statements that come from a\n(card-image) file.  Or, in the case of TSO commands, we can code\nsubcommands and operands, which are executed under the control of the\nmain TSO command.\n\n      Today, we'll discuss how to tell a batch program about its\nexecution options, using the JCL EXEC card PARM field.  The idea is to\narrange for one or more bytes in the program to be designated as flag\nbytes, with a bit set on, or off.  The program's code will interrogate\nthese bits as it executes, usually using a TM (Test Under Mask)\ninstruction, and this will tell the program how it should run.  There's\ngoing to be a relation between the PARM field in the JCL EXEC statement,\nand the flag bytes that get set on or off in the program.\n\n      Actually making this connection, in the program, is the trick.\nWe'll talk about various techniques of getting the EXEC PARM information\ninto the program, so that there is a proper relationship between what\nthe PARM says, and the option switches which the program sets.  These\nare the option switches that the program interrogates later on during\nits execution, to see which features it should run with.\n\n\nPARSING\n\n      MVS (as did MVT before it) allows the programmer an opportunity of\ncommunicating execution information to a program, through the PARM\nkeyword of the EXEC statement in the JCL.  The string that can be fed to\na program by means of the PARM can be up to 100 bytes long.  The idea is\nthat it's a raw string of arbitrary data.  The programmer, in planning a\nprogram's structure, has to figure out how to exploit this arrangement\nintelligently, so a user of this program will be able to figure out how\nto code the characters in the PARM field and to exercise effective\ncontrol of the program's execution modes.\n\n      Here is our general problem with MVS execution PARMs.  You have\na string of character bytes which the user will code, in the PARM field\nof the EXEC statement in the JCL.  This string must be searched,\ndivided into recognizable keywords, and those keywords must be\nconverted into switch settings that the program's code will later know\nhow to use.  In short, your program has to recognize user-coded\ncharacter strings and convert them into bit settings in flag bytes.\nMaking this conversion is probably the first thing that your program\nwill have to do, since it will later need to know what choices of\noperation it's going to have to make.\n\n      Programmers, in deciding what switches a program will need,\ntherefore have to design a scheme of converting PARM keywords into\nswitch settings.  There are several commonly-used methods of recognizing\ncoded keywords, an activity which is generally termed \"parsing\".  To\nparse a string for keywords, means to divide it into recognizable\nseparate fields, so that a program can read in these fields and process\nthem.\n\n      So, besides the other processing that a program will do, it\nmight also have to include a scheme of converting PARM keywords into\nexecution switches.  The program usually does this at the beginning\nof execution.  We'll discuss several such schemes.\n\n      I'll also show you a nice table-driven PARM parser that I've\njust written, which performs this task very efficiently and very nicely.\nWith my PARM parser in place in a program, it's very easy to add or\nchange the permissible keywords, and the execution flags they set or\nturn off.  It's also possible to set any of the keywords as defaults.\nThose defaults can be overridden by explicitly coding keywords in the\nPARM field.  Now let's talk about PARM coding specifics.\n\n\nWHERE THE PARMS ARE\n\n      When you run a batch program under MVS, the operating system\nmakes the execution PARM field available through Register 1.  Register\n1 points to an area containing a 2-byte length, followed by the actual\nPARM bytes that the user coded.  The 2-byte length is the number of\ncharacters that the user coded in the PARM field (including blanks) so\nit tells you that you should search this number of characters from the\nstarting point, and no farther.\n\n      It follows, that if you only want to code one PARM keyword and no\nmore, you only need two lines of program code to recognize the keyword.\nLet's say that the keyword will be called \"LTMSKIP\".  (This is a for a\ntape copying program, and I want to give the program the option of not\ncopying leading tapemarks from the input tape.)  The necessary lines of\ncode are:\n\n         L     R1,0(,R1)           GET PARM FROM JCL\n         CLC   =C'LTMSKIP',2(R1)   ARE WE SKIPPING LTM'S?\n\nThis will be followed by a BE (branch if equal) or BNE (branch if not\nequal) instruction.  One of the branch paths will set the switch flag\non, while the other will not.  This is very simple code, but the reason\nfor the simplicity is that there's only one PARM keyword acceptable.\n\n      Suppose we'd need two PARM keywords.  I'll code them as in my\nactual program.  They are:  LTMSKIP and LABELS.  I want my tape copying\nprogram to have the option of printing tape label information if it\nfinds any on the input tape, or not printing the label info.  I also\nwant my program to be able to skip leading tape marks when copying a\ntape, or to have the option of copying the leading tape marks.  These\nare clearly two separate choices, and they'll need two separate switches\n(bits in a flag byte) to be independently set.\n\n      I could force the user of my program to code LTMSKIP first, and\nthen LABELS afterwards.  Then I could simply look for LTMSKIP in the\nPARM field, and upon finding or not finding it, just look further for\nthe LABELS keyword.  This isn't realistic, and it may make my program\nhard to use.  A better design would be to have the same flag bits set,\nif keyword LABELS is coded first, then LTMSKIP.  The order shouldn't\nmatter.\n\n      So I have to start my search of the PARM string, looking either\nfor the word LTMSKIP or for the word LABELS.  Upon finding one of these,\nI have to search farther up in the PARM string, looking for the other\nkeyword.\n\n      To make the process easier, many programmers use the following\ndesign, and require the user to code a comma or a space in between any\ntwo keywords.  This is how such a design works:\n\n      First, the program looks for one keyword at the beginning of the\nPARM string, so it copies the first non-blank characters to a work area\nuntil it finds a comma or a space.  It interrogates the characters in\nthe work area, to see if they match a required keyword.  Then it\nsearches farther in the PARM field, until the next comma or space.  The\nsame process is continued until the length of the PARM field is\nexhausted.  This search method is very common, especially in older\nprograms.\n\n      I feel I have designed a better method.  It's a bit more\ncomplicated to set up, but once it's in place, it's far easier to change\nthe permissible PARM keywords, and it's a dream to maintain the program\nlater.  My method also has the advantage, that you don't need a comma or\na space to separate the PARM keywords, although you can separate the\nkeywords by a comma or a space for clarity.  And you can also code\nsynonyms for the same keyword.  These are two different keywords which\nset the same switch flags in the program.  Now I'll show you how my\nmethod works.\n\n\nA TABLE-DRIVEN PARM PARSER\n\n      When designing my PARM parser, these were the specifications I\nhad in mind.  It would be table driven, so in order to change a keyword,\nor the switch setting it would be associated with, all you'd have to do\nis to change a table entry.  All the other code would remain the same.\nMaintaining such a program, or changing the configuration of keyword and\nswitch settings, would be extremely easy.  This is how I did it.\n\n      I decided to code a fixed-length table, with the keywords eight\nbytes or less, in length.  Of course, this can be changed if you need\nlonger keywords.  I wanted flexibility to choose many execution options,\nso I allowed for three contiguous flag bytes, each containing eight\nbits, so there are 24 independent flag bit settings possible.  I also\nwanted the option of turning the flag bits off, so I needed an on-off\nswitch.  That occupies only one bit, but since I didn't want to use one\nof the flag bits, I allowed for an extra byte with option switches.  One\nbit of this byte is for turning flag bits off.  Another bit of this byte\nwould be used for specifying that a keyword will be set as a \"default\"\nwhen no PARM at all, is coded in the JCL EXEC card.\n\n      So in my current design (which you can adjust for your needs),\none table entry takes up 13 bytes.  There's one byte at the beginning,\nwhich specifies in hex, the length of the PARM keyword.  Then there's\nan option byte, where 2 bits are used.  One bit says whether to turn\nthe flag bit(s) on or off, as a result of coding this keyword.  The\nother bit says that this keyword will be set as a default for program\nexecution, when no PARM keywords are coded in the JCL.\n\n      Then there's 8 bytes for the keyword itself.  If the keyword is\nshorter than 8 bytes, as it usually is, it is left-justified in the\ntable entry.  Finally there are 3 model flag bytes, which will contain\nthe specific bit settings associated with this PARM keyword.  To see\na sample coded table, look at Figure 1.  To see the assembler code which\nprocesses this table, look at Figure 2.\n\n      In reading this table, I first make one pass through it, to see if\nan entry is a default, flagging its associated option bits accordingly,\non or off.  Then I search through the entire table again, looking also\nat the beginning of the PARM field.  If I find a keyword entry match, I\nflip the associated program flag bits, go farther into the PARM field,\nand search again through the entire table, looking for another match.\nIf I don't find a keyword match at this point in the PARM field, I go\nforward one byte, and repeat the table search again.  Eventually I find\nall valid PARM keywords that have been coded, and all the appropriate\noption flag bits have been correctly set.\n\n      I'll conclude with a word about setting program option bits from\nthe table entry.  Each coded PARM keyword is associated with one or more\noption bits in the 3 model flag bytes that are in each table entry.\nThese model bit settings will turn the corresponding program flag bits\neither on or off.  How is this on-off bit flipping done?\n\n      To set a bit on, you use the \"OR\" instruction.  If a bit is zero,\nand you OR it with a one, the resulting bit will be one.  If a bit is\none, and you OR it with a one, the resulting bit is still one.  You see\nthat an OR with a one will always turn a bit on, but an OR with a zero\nwill always leave it unchanged.  So if any \"model bits\" are on, and you\nwant to turn on the corresponding program flag bits, you just have to OR\nthe model bits into the program flag bits.  Since in our case, 3 bytes\nof flag bits are involved, we use the OC (OR CHARACTERS) instruction for\n3 bytes.\n\n      Setting a bit off, starting from an indicator bit that's on, is\nmore complicated.  I don't have space to work you through the thinking,\nbut this is what you do.  If a keyword option bit is set on, and you\nwant to turn the corresponding flag bit off, you move the option bit to\na work area, flip it over (if it was zero, make it a one, if it was one,\nmake it zero), and then you \"AND\" the result into the program flag bits.\nThis will have the result of turning that bit off, while leaving all the\nother bits unchanged.\n\n      Please study the code in the figures, and you'll see how clever\nand flexible this arrangement is.  With this gizmo, PARM coding is easy.\nI have to say that my PARM searching code uses four work registers, but\nthey are usually available, since this code is normally executed once,\nat the very beginning of the program, and the work registers could be\nreused later.\n\n      I hope you've gotten a lot of satisfaction from reading this\nmonth's column.  You can find the program that uses this code at\n\n    ftp://ftp.cbttape.org/pub/cbttape/cbt/CBT229.zip\n\nBest of luck to you in all your work.  I'm looking forward to seeing you\nagain, next month.\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   Format of the PARM Table which sets program\n            flag switches, based on the table entries.\n            This table is very easy to change, and you do\n            not have to change the code which drives it.\n            Some constants, which the driving code uses,\n            are included here, at the top.\n\n* --------------------------------------------------------- *\nPARMFLGS DS    0CL3     3 CONTIGUOUS BYTES OF PARM FLAGS\nPARMFLG1 DC    X'00'\nPARMFLG2 DC    X'00'\nPARMFLG3 DC    X'00'\n* --------------------------------------------------------- *\nPARMSLEN DC    F'0'                LENGTH OF PARMS\nPARMSTRT DC    F'0'                START ADDR OF JCL PARMS\nPRMCHRCT DC    F'0'                CHAR COUNT FOR PRM SEARCH\nPARMHITS DC    PL4'0'              NUMBER OF PARM HITS\nPARMLCNT DC    PL4'0'              NUMBER OF PARM LOOPS\nPARMTENT DC    CL13' '             PARM TABLE ENTRY DUMP\n         DC    CL7' '              FILLER\nPARMFWRK DC    XL3'00'             FOR TURNING OFF PARM BYTES\n* --------------------------------------------------------- *\n*           FORMAT OF PARM TABLE\n*           ONE ENTRY IS 13 BYTES (the way it's implemented here)\n*                1ST BYTE:      LENGTH OF THIS PARM IN HEX\n*                2ND BYTE:      OPTION BYTE\n*                               X'01' SAYS TURN FLAG OFF\n*                               X'00' SAYS TURN FLAG ON\n*                               X'10' SET ENTRY AS A DEFAULT\n*                NEXT 8 BYTES:  PARM NAME - LEFT JUSTIFIED\n*                NEXT 3 BYTES:  FLAG SETTINGS - 3 FLAGS,\n*                                WHICH ALLOWS FOR 24 PARMS\n*                                THAT DON'T HAVE TO BE\n*                                SEPARATED BY A COMMA.\nPBYTES   EQU   3                NUMBER OF PARM SWITCH BYTES\n* --------------------------------------------------------- *\nPARMTABL DC    X'07',X'00',C'LTMSKIP ',X'200000'  FIRST ENTRY\nPTELEN   EQU   *-PARMTABL\nPTEFLG   EQU   PTELEN-PBYTES\n         DC    X'07',X'00',C'SKIPLTM ',X'200000'  synonym for on\n         DC    X'07',X'11',C'COPYLTM ',X'200000'  off (default)\n         DC    X'07',X'01',C'LTMCOPY ',X'200000'  synonym for off\n         DC    X'07',X'00',C'LBLINFO ',X'DE0000'  all label info\n         DC    X'06',X'00',C'PRINTL  ',X'DE0000'  synonym\n         DC    X'06',X'00',C'LABELS  ',X'DE0000'  synonym\n         DC    X'06',X'01',C'NOLABL  ',X'DE0000'  synonym for off\n         DC    X'07',X'11',C'NOLABEL ',X'DE0000'  off (default)\n         DC    X'04',X'00',C'HDR1    ',X'020000'  print HDR1 info\n         DC    X'06',X'01',C'NOHDR1  ',X'020000'  no HDR1\n         DC    X'04',X'00',C'HDR2    ',X'040000'  print HDR2 info\n         DC    X'06',X'01',C'NOHDR2  ',X'040000'  no HDR2\n         DC    X'04',X'00',C'EOF1    ',X'080000'  print EOF1 info\n         DC    X'06',X'01',C'NOEOF1  ',X'080000'  no EOF1\n         DC    X'04',X'00',C'EOF2    ',X'100000'  print EOF2 info\n         DC    X'06',X'01',C'NOEOF2  ',X'100000'  no EOF2\n         DC    X'04',X'00',C'EOV1    ',X'400000'  print EOV1 info\n         DC    X'06',X'01',C'NOEOV1  ',X'400000'  no EOV1\n         DC    X'04',X'00',C'EOV2    ',X'800000'  print EOV2 info\n         DC    X'06',X'01',C'NOEOV2  ',X'800000'  no EOV2\n         DC    X'04',X'00',C'HDRS    ',X'060000'  HDR1 and HDR2\n         DC    X'06',X'01',C'NOHDRS  ',X'060000'  neither\n         DC    X'04',X'00',C'EOFS    ',X'180000'  EOF1 and EOF2\n         DC    X'06',X'01',C'NOEOFS  ',X'180000'  neither\n         DC    X'04',X'00',C'EOVS    ',X'C00000'  EOV1 and EOV2\n         DC    X'06',X'01',C'NOEOVS  ',X'C00000'  neither\n         DC    X'05',X'00',C'NINTH   ',X'000100'  NOT USED\n         DC    X'07',X'01',C'NONINTH ',X'000100'  NOT USED\n         DC    X'05',X'00',C'TENTH   ',X'000200'  NOT USED\n         DC    X'07',X'01',C'NOTENTH ',X'000200'  NOT USED\n         DC    X'07',X'01',C'NOEXTRA ',X'010300' ALL EXTRAS OFF\nEFFS     DC    X'FFFFFFFFFFFFFFFF'\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.   This is the code which looks at the PARM table in\n            Figure 1, and which sets the appropriate bits in the\n            PARMFLGS field that the program interrogates to\n            determine its operating options.  One initial pass is\n            made through the table, to set the program defaults,\n            and then the JCL PARM field is scanned for keywords to\n            override these defaults.\n\n\nPARMCHK  DS    0H         CHECK PARMS AND FLAG THEIR\n*                         PRESENCE OR ABSENCE.\n*            (PERMISSIBLE PARMS ARE CODED IN PARMTABL.)\nPARMINIT L     R1,0(,R1)      GET PARM FROM JCL\n         LH    R5,0(,R1)      SAVE PARM LENGTH\n         ST    R5,PARMSLEN    STORE FULLWORD VALUE\n         LA    R7,PARMTABL    LOAD START OF PARM TABLE\n         LA    R4,2(,R1)      POINT TO START OF JCL PARMS\n         ST    R4,PARMSTRT    PUT ADDRESS INTO PGM STORAGE\n         LA    R1,0           USE R1 TO MEASURE LENGTH READ\n* -----------------------------------------------------------\n*   ONE PASS THRU PARM TABLE TO SET DEFAULT ENTRIES BEFORE\n*   LOOKING AT JCL OVERRIDES TO THE PARMS.\n* -----------------------------------------------------------\nPARMDFLT DS    0H             SET DEFAULTS FROM PARM TABLE\n         CLI   0(R7),X'FF'    END OF PARM TABLE?\n         BE    PARMDEND       YES. DEFAULTS SET. CHECK PARMS.\n         TM    1(R7),X'10'    IS THIS ENTRY A DEFAULT?\n         BO    PARMDSET       YES, GO SET IT.\n         LA    R7,PTELEN(,R7)  NO. BOP TO TEST NEXT ENTRY,\n         B     PARMDFLT       AND LOOP UNTIL TABLE ENDS.\nPARMDSET TM    1(R7),X'01'    DO WE TURN THIS FLAG OFF?\n         BO    PARMDOFF       YES. FLAGS ARE TURNED OFF..\n         OC    PARMFLGS(3),PTEFLG(R7)  NO. FLAG IS TURNED ON.\n         LA    R7,PTELEN(,R7)  NO. BOP TO TEST NEXT ENTRY,\n         B     PARMDFLT       CHECK MORE TABLE ENTRIES.\nPARMDOFF MVC   PARMFWRK(3),PTEFLG(R7)  PARM BYTES TO WORKAREA\n         XC    PARMFWRK(3),EFFS      FLIP PARM BYTES OVER\n         NC    PARMFLGS(3),PARMFWRK    TURN PARM BYTE(S) OFF\n         LA    R7,PTELEN(,R7)      BOP TO TEST NEXT ENTRY,\n         B     PARMDFLT   LOOP BACK TILL ONE PASS THRU TABLE\nPARMDEND LA    R1,0           INITIALIZE COUNTING REGISTER\n         LA    R7,PARMTABL    RELOAD START OF PARM TABLE\n         L     R4,PARMSTRT    RELOAD JCL PARM ADDRESS\n* -----------------------------------------------------------\n*   NOW CHECK EACH CHARACTER IN JCL, TO SEE IF IT'S A PARM.\n* -----------------------------------------------------------\nPARMLOOP C     R1,PARMSLEN    PAST THE END OF PARMS?\n         BNL   PARMFIN        YES - GET OUT\n         LA    R7,PARMTABL   POINT BACK TO BEGINNING OF TABLE\n         AP    PARMLCNT,=P'1'  COUNT PARM LOOPS FOR DEBUGGING\nBOPPTBL  CLI   0(R7),X'FF'    END OF PARM TABLE?\n         BE    PRMNFND        YES. BUMP AND TRY AGAIN.\n         SR    R5,R5          CLEAR WORK REGISTER FOR REUSE\n         IC    R5,0(,R7)      LOAD LENGTH TO BE COMPARED\n         BCTR  R5,0           ONE LESS FOR EXECUTE\n         EX    R5,CMPPARM     COMPARE TABLE ENTRY TO PARM LOC\n         BE    PRMFOUND       PARM FOUND AT THIS LOCATION\n         LA    R7,PTELEN(,R7)  OTHERWISE, GO TO NEXT ENTRY\n         B     BOPPTBL        INNER LOOP THROUGH THE TABLE\nPRMNFND  LA    R4,1(,R4)      FORWARD IN JCL PARMS\n         LA    R1,1(,R1)      MEASURE DISTANCE TRAVELED\n         B     PARMLOOP       TRY SEARCHING THE TABLE AGAIN\nPRMFOUND MVC   PARMTENT(PTELEN),0(R7)  DUMP TABLE ENTRY FOUND\n         TM    1(R7),X'01'    TURN THIS SWITCH ON OR OFF?\n         BO    PARMOFF           IF OFF, TURN IT OFF, OTHERWISE,\n         OC    PARMFLGS(3),PTEFLG(R7)  TURN THE FLAG ON.\n         B     PARMGO              AND GO ON\nPARMOFF  MVC   PARMFWRK(3),PTEFLG(R7)  PARM BYTES TO WORK AREA\n         XC    PARMFWRK(3),EFFS      FLIP PARM BYTES OVER, THEN\n         NC    PARMFLGS(3),PARMFWRK    TURN PARM BYTE(S) OFF\nPARMGO   AP    PARMHITS,=P'1'    COUNT PARM HITS\n         IC    R5,0(,R7)      LENGTH OF PARM, FROM THE TABLE\n         LA    R1,0(R5,R1)    INCREMENT COUNT BY LENGTH\n         LA    R4,0(R5,R4)    SAME FOR SEARCH POSITION\n         B     PARMLOOP       LOOK FOR MORE PARMS\nPARMFIN  ST    R1,PRMCHRCT    HOW MANY CHARS WE SEARCHED --\n*          AT THE END, THIS COUNT SHOULD MATCH THE PARM LENGTH.\nPRMCHEND BR    R6\nCMPPARM  CLC   0(0,R4),2(R7)    ** EXECUTED **\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0008AU": {"ttr": 21507, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x01\\x00\\x18\\x7f\\x01\\x00)\\x9f\\x11G\\x01\\x06\\x01\\x06\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2000-07-05T00:00:00", "modifydate": "2000-10-25T11:47:00", "lines": 262, "newlines": 262, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          AUGUST 2000\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@attglobal.net and/or sbgolob@aol.com.\nThe Online CBT Tape web site has its own URL.  However, it can also\nbe reached from the \"Members Only\" section of www.naspa.net .\n\n\nTHE CVT - THE BACKBONE OF MVS\n\n      My approach to understanding computers might be termed\n\"outside-in\".  I'll explain it to you, and I'm sure most of you will\nagree why such an approach is needed and practical.  You can begin by\ntrying to remember what your feelings were, when you first started doing\nsystems programming work.  If your experience was like mine, it was\nsomething like this:  When we entered this field, we were suddenly\nimmersed into a complicated mess that already existed, and it was our\njob to learn as much as was necessary to survive.\n\n      The reason for that is very simple, when you think about it.\nComputer knowledge is a lot of other people's work, thinking, and\ndebugging.  All of this occurred in the past.  Once somebody built an\noperating system, or a utility, or any program written for any purpose,\nall subsequent people became users of that operating system, utility or\nprogram.  In other words, even though most of us are called\n\"programmers\", we're really the \"users\" of other people's programs,\nmost of the time.\n\n      There's nothing wrong with that.  So why are we called\n\"programmers\" and why are the other people (the \"real users\") called\n\"users\"?  The answer is because we ADD to the existing computing\nprogram base, and the \"users\" don't.  We write more programs, to build\non top of what's already there.  Or we install new packages, to create\na new, enhanced programming base on our computing system, for the other\npeople, the real users, to use.\n\n      At this point, I can explain what I mean by \"outside-in\".  It\nsimply means that when I'm trying to understand something in computing,\nfirst I try and see what it does.  I use it.  I get the feel of the\nscreens and the outputs.  I see what it does to the data files.  I give\nit one \"test drive\", and then another, and another, until I understand\nthe externals of what it does.  That's what the \"outside\" is.\n\n      What's the \"in\"?  It's this.  After I see how the program, or\npackage, or tool works, I try and find out what makes it tick--WHY it\nworks.  For that, I have to look into its internal structure, and as\nmuch as is possible in a semi-OCO world, into its programming.  I\nreason as follows:  \"It DOES work, so something it does, has to MAKE it\nwork.  It has to make the computer do this stuff in a step-by-step\nmanner, the same way a building is constructed out of its component\nparts.\"  Then, realizing that the entire picture may be very\ncomplicated, I start trying to find a way to begin.  In other words, I\nstart by looking for a small piece of the mechanism that I CAN\nunderstand.  It's like trying to break into a house that you're locked\nout of.  (In our case, as in the case of a locksmith, it's legal to do\nthis.)  You look for a loose door, or an open window, so you can get\ninside.  That's the \"in\".\n\n      What relevance does all this have to today's subject?  Today, I'm\ngoing to tell you how to start looking inside MVS.  I'm going to show\nyou a window that you can climb in, so you can start looking around.\nThis window is called the CVT, or Communication Vector Table.  Once you\nknow what the CVT is, and where it is, you're already looking at MVS\nfrom the inside, and not from the outside.\n\n\nWHAT IS THE CVT?\n\n      The Communication Vector Table (as its name actually tells you\nif you understand IBM-ese) is a huge collection of pointers to a lot of\nseemingly miscellaneous locations.  Its contents is described by a\nmacro called CVT, which is in SYS1.MACLIB.  At the beginning of the CVT\nmacro, IBM actually provides a short explanation as to what the CVT is\nfor.\n\n      This explanation says:  \"The CVT provides the means by which\nnon-nucleus-resident routines may refer to information in the nucleus\nof the control program.  It contains addresses of other control blocks\nand tables used by the control program routines.\"\n\n      Basically, this means that as far as any users of the MVS\noperating system are concerned, the CVT is the backbone and spinal cord\nof MVS.\n\n      How does a program get to the CVT?  There are two pointers to the\nCVT in low storage.  The primary pointer is at virtual location hex 10,\nor decimal 16.  The second pointer, far less well-known, is at virtual\nlocation hex 4C, or decimal 76.  Sometimes, if the system is crippled\nfor some reason, the second location to get to the CVT might be\navailable, even though the main location at x'10' is damaged.  It's an\nextra measure of system security, and it's nice to know about.\n\n      What's in the CVT?  You can find out, by reading the comments in\nthe CVT macro.  If you're like me, and you've tried doing that, you'll\nprobably have the same reaction that I did.  You'd be overwhelmed by\nthe fact that you don't understand very much.  Trust me, that reaction\nis natural and normal.  There's a simple reason for it.  In order to\nunderstand all the pointers in the CVT, you have to understand\npractically all of MVS, because that's what's being pointed to.\n\n      So instead of being disappointed, you should really be happy.\nWhy?  Because you've gotten in through the door, and you're now inside\nthis \"mansion of many rooms\", that is the MVS operating system.  You've\neven got a key to most of the rooms.  Now, you can start exploring the\ninside.\n\n\nUSING POINTERS TO GET ALMOST ANYWHERE IN MVS\n\n      The CVT, with its prefix and its extensions, can be likened to a\n\"room full of address pointers\".  Practically every 4 bytes of the CVT\nis a pointer to a different virtual storage address.  So, if you're\nsitting in a room full of address pointers, the next logical question\nis:  How do you use them?  The answer is:  Most of the time, you use\nthe LOAD instruction (abbreviated \"L\" in an assembler program).\n\n      The action of the LOAD instruction is very simple.  You point the\nLOAD instruction at a four-byte location in storage, and give LOAD the\nname of a general register (which holds 4 bytes).  LOAD then puts\nwhatever 4 bytes of hex values that are at the storage location, into\nthe general purpose register.  It's very simple.  Just for the record,\nI'll mention that the opposite of the LOAD instruction is the STORE\n(\"ST\") instruction, which puts the 4-byte contents of a general purpose\nregister into four bytes of storage.\n\n      Using LOAD, you don't just have to use the four bytes of storage\nthat it's directly pointing at.  You can also use any four bytes you\nchoose, at a displacement up to 4095 bytes forward from the location\nyou're pointing at.  (I'm keeping it elementary here, and I'm not\nmentioning how to use an index register in LOAD.)\n\n      Why is the LOAD instruction excellently suited for following\nchains of pointers?  Because it allows you to jump from one location\nin the computer to another, very simply.  It also accounts for small\ndisplacements off the storage location it is referring to.  I'll try\nand explain this a little better.\n\n      Most of the information that the MVS operating system uses, is\nstored in moderate-sized chunks of bytes that are together in one\nlocation.  These are termed \"control blocks\".  The main control block\nthat is used by any program which uses the MVS operating system, is the\nCVT.  An address in the CVT might point to the beginning of another\ncontrol block, which contains more address pointers to other control\nblocks.  Finally, after following a chain of pointers, you can arrive\nat the MVS information you are looking for.  It goes the other way,\ntoo.  Any information that the designers of MVS want you to use, is\nalmost always pointed to by chains of addresses in control blocks, and\nit is almost never referred to by a direct storage location.  Therefore,\nto get to any information you want in MVS, there exists some chain of\ncontrol block pointers which leads there.  And almost always, the place\nto start the search is the CVT.\n\n      So it comes out, that if you want most information in an MVS\nsystem, you have to ask about the chain of pointers, starting from the\nCVT, that has to be followed, in order to get there.  And in an\nassembler program, following a chain of pointers is done by the LOAD\ninstruction.\n\n      For example, if you're running a program from TSO, and you want\nthe program to find out your TSO userid, you ask where the TSO userid\nis, and then you ask how to get there.  I'll give you an answer.\n\n      One place the TSO userid is, is in a control block called the\nPSCB, in a field called PSCBUSER, that is 0 bytes off the beginning of\nthe PSCB control block, for 7 bytes.  Question now is, how do you get\nto the PSCB?  Answer is:  You start from the CVT, which is pointed to\nfrom virtual location x'10' in low core.  Then you point to the\nTSCB-ASCB words, which is at a location for 4 bytes at 0 bytes off the\nbeginning of the CVT.  At 4 bytes off that location, is a pointer to\nyour TCB (Task Control Block).  At x'B4' off the beginning of the TCB\nis a pointer to the JSCB (Job Step Control Block).  And at x'108' off\nthe beginning of the JSCB, is the pointer to the location of the PSCB.\n\n      This all looks very complicated, but it isn't really, because\nwhenever you want the PSCB, you always go there the same way.  And\nwhen you do it with a succession of LOAD instructions in an assembler\nprogram, it's only a succession of 5 instructions.  In a program,\nthat's very very simple.\n\n      So if you want to get to the PSCB, you always do it the same way,\nas follows:  Pick a work register you're not using right now, in\nthe program.  Say it's Register 3 (called R3).  To get the address of\nthe CVT, just LOAD R3 with the numeric value x'10'.  Then LOAD R3 with\nthe value in storage that is 0 bytes off R3 to get to the TCB-ASCB\nwords.  Then LOAD R3 again with 4 bytes off R3 to get to the TCB.  Then\nLOAD R3 again with x'B4' bytes off R3 to get to the JSCB.  And finally,\nyou LOAD R3 again with x'108' bytes off R3 to get the storage address\nof the beginning of the PSCB.  Finally, you can move the 7 bytes that\nare at the location R3 now points to (your TSO userid), to wherever you\nwant.\n\n      In a program, it's just LOAD, LOAD, LOAD, LOAD, LOAD.  Please see\nFigure 1 for what the actual instructions look like.\n\n      Each piece of MVS information has its own address.  A large\nnumber of the MVS quantities and values can be reached in this way.\nAnd once you, as a programmer, have gotten to the stage of understanding\nthis fact, you're now WAY inside MVS.  You're not outside it anymore.\n\n\nWHAT'S LEFT?\n\n      So what's left for you to do?  Accumulate information!  MVS is a\nvery large operating system, and it does thousands of different things\nin its normal operation.  If you want to write a program that interacts\nwith one of the things MVS does, you have to know where MVS keeps the\ninformation that particular function is dealing with.  You have to find\nout how to get there, and once there, you have to know what you're\nallowed to do.  If you're only doing inquiries, and you're not trying\nto change anything, you can go practically anywhere, and copy the\ninformation off.  If you're trying to change one of MVS's functions,\nyou have to be mighty careful.  But at least you can now start looking,\nand start doing things.\n\n      At this point (if you're fairly new to MVS internals), you're a\nlot farther along than you were, before you started reading this column.\nMany working MVS assembler utilities can be found in the enormous, free\nCBT Tape collection that is available online, at www.cbttape.org , and\nyou can examine the different coding examples, so you can see how they\nare able to access the system information they need.  I wish you the\nbest of luck in your endeavors, and I'm looking forward to seeing you\nagain next month.\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   Example of running a chain of address pointers from\n            the CVT.\n\n            We want our TSO program to find out the userid it is\n            running under.  That information is located in a control\n            block called the PSCB, and the PSCB is pointed to, by\n            a chain of 4-byte addresses which starts with the CVT.\n            Here's how our program gets there, using a succession\n            of LOAD instructions into general register 3.\n\n\n     ---   SNIP   ---\nRUNCHAIN L     R3,16               POINT TO CVT. ADDR IS IN LOW STORAGE\n         L     R3,0(,R3)           POINT TO TCB/ASCB WORDS, \"0\" OFF CVT\n         L     R3,4(,R3)           POINT TO TCB, \"4\" OFF TCB/ASCB WORDS\n         L     R3,X'B4'(,R3)       POINT TO JSCB. X'B4' OFF CURRENT TCB\n         L     R3,X'108'(,R3)      POINT TO PSCB. X'108' OFF THE JSCB\n*  -----     Now you're there.  R3 contains the address of the PSCB\n*  -----     control block.\n         MVC   MSGLINE+13(7),0(R3)   MOVE USERID IN FROM 0 OFF THE PSCB\n*                                    AND PLACE IT INTO THE MESSAGE.\n         TPUT  MSGLINE,L'MSGLINE   DISPLAY THE WHOLE MESSAGE ON THE TUBE\n     ---   SNIP   ---\nMSGLINE  DC    CL20'MY USERID IS        '      DEFINE LINE FOR MESSAGE\n     ---   SNIP   ---\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0010OC": {"ttr": 21512, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x00$\\x9f\\x01\\x00)\\x9f\\x11H\\x01\\x04\\x01\\x04\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-09-05T00:00:00", "modifydate": "2000-10-25T11:48:00", "lines": 260, "newlines": 260, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          OCTOBER 2000\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@attglobal.net and/or sbgolob@aol.com.\nThe Online CBT Tape web site has its own URL.  However, it can also\nbe reached from the \"Members Only\" section of www.naspa.net .\n\n\nThis column is dedicated to the memory of my dear friend Paul G. Davis,\nwho taught me how to write Edit Macros.\n\n\nRUNNING MVS ON A PC.\n\n      This month's topic is in a rapidly developing area, and I\ncannot consider myself as being thoroughly informed about what has\nbeen happening.  Nevetheless, the ideas of running a mainframe\noperating system and/or mainframe-like software on a PC are so\nintriguing, that they are well worth reporting on.  Developments have\nbeen springing up in several areas, and I'd like to provide at least\npart of a general overview.\n\n      I'll differ a bit this month from my usual format of describing\nspecific tools or tricks, with an emphasis on free software products\nthat you can install and use right away.  Although some of the products\nI'll describe are free, there simply isn't enough space to both give\nan overview of these exciting developments, and to mention a lot of\nspecifics, too.  Let's begin our discussion with some history.\n\n      The MVS Operating System (the major portion of OS/390) has\ntraditionally been run on multi-million-dollar \"giant\" computers, which\nare owned or leased by large companies.  The primary purpose of these\ncomputers has been to run the business end of a big company's operation.\nNot so many years ago, small companies developing software that runs\nunder MVS, whether it be system or application software, used to spend\nlarge monthly outlays renting computer time from one, or several, such\nbig companies.  Many of the smaller software development companies\nsimply couldn't afford to buy an MVS-capable computer on their own.\n\n      The situation changed drastically with the advent of the P/390\nMVS-capable personal computer from IBM.  Under very favorable terms\nfrom IBM, and using a table-top-sized P/390 setup that could approach\n10 mips in CPU-power, small software companies and even individuals,\ncould now keep an MVS machine in their offices, houses, or even\napartments.  IBM encouraged the efforts of these companies through\ntheir Software Developer Program.  And in my opinion, the public has\nbenefited enormously over the past few years, from MVS software that\nwas developed on these machines.\n\n      As of this writing, I'm a bit worried about the future.  Because\nof new hardware requirements for future versions of OS/390, starting\nwith Release 11, it's not clear at this time (at least to me) whether\nthose and later versions of OS/390 will run on P/390 type machines.  I\nhave heard that IBM is addressing the problem, and we're all anxiously\nawaiting the results of their decisions.\n\n      Meanwhile, efforts have led to progress in other directions,\nnotably the idea of running IBM \"big iron\" operating systems on a\npersonal computer which emulates the mainframe hardware using software.\nFast CPUs for the PC, and the availability of humongous amounts of DASD\n(disk drive) space very cheaply, have spurred these efforts on.  Today\nwe'll discuss these developments.  I think this situation will start a\ngroundswell of curiosity, which will lead to interest, and which will\nlead to a lot of action on the part of many people.  I certainly hope\nthat the current atmosphere will engender a big growth in the need for\npeople possessing MVS systems programming skills.\n\n\nFLEX-ES\n\n      The software vendor Fundamental Software Inc. has been, for the\npast 10 years, quietly working on an idea whose time is about to come.\nTheir product, called FLEX-ES, runs on a UNIX server and emulates an\nS/390 machine using software.  FLEX-ES supports multi-processing.\nUsing FLEX-ES, you can run the IBM large scale operating systems OS/390,\nVM/ESA, and VSE/ESA as though on a plug-compatible mainframe computer.\nBesides plug-compatibility with physical mainframes, the FLEX-ES\narrangement offers other advantages that are not as easily attainable\nwith \"real hardware\".\n\n      I once knew of a company which owned a computer that couldn't\nrun MVS/ESA.  The highest level operating system that this computer\ncould run, was MVS/XA.  While I was not privy to the financial reasons\nwhy this company could not upgrade its machine (and even if I were, I\nwouldn't write about them here), the fact remains that the company was\nfrozen into running MVS/XA for many years past its time, until Y2K\ndelivered the coup de grace.  This situation would not have occurred,\nif the hardware were emulated by software.  In order to run more new\nmachine instructions in a FLEX-ES environment, all you'd need is a\nsoftware upgrade on your existing UNIX server, not a hardware upgrade.\nThis would be far easier to accomplish and to budget, than to change\nthe entire machine.  It would also be easier on CPU-based software\nlicenses.\n\n      What about peripherals?  FLEX-ES supports emulated old and new CKD\nand FBA DASD types, emulated printers, emulated terminals, emulated\nTCP/IP network controllers, and emulated 3420 and 3480 tapes.  These\ntapes can actually be much longer than the traditional reel and\ncartridge tapes, because they are physically supported on devices with\nmuch higher data capacity than an ordinary tape had.  In addition,\nFLEX-ES offers its FLEX-ES parallel channel adapter which allows the\nattachment of traditional mainframe tape drives, printers, and\ncommunications controllers.  Since FLEX-ES runs on a UNIX server, you\nalso can create novel combinations and connections between the S/390\nactivities and native UNIX.\n\n      There remains the question of throughput, and for answers to this,\nI'd suggest that you consult Fundamental Software, through its website:\nwww.funsoft.com .  For costs and capacity questions, I also have to\nrefer you to them.  It's up to your installation to determine if this\napproach is financially feasible.  But the idea and flexibility of\nrunning MVS or OS/390 under hardware emulation, having full commercial\nvendor support, and especially for a shop that isn't a giant company, is\nso intriguing that it deserves a very thorough look.\n\n\nHERCULES\n\n      I've got hope for retired or not-currently-employed MVS sysprogs,\nfor MVS'ers who've been forcibly ported to supporting UNIX machines,\nand for others of us who, for some strange reason, want to do mainframe\ncomputing at home.  Now, there's actually a way.  It's a free product\ncalled Hercules, which was specifically designed for non-commercial\nuse, and which emulates S/390 hardware on a PC.\n\n      Hercules was invented by Roger Bowler, who has been nurturing a\ndecades-long passion for having a mainframe in his house.  Roger told\nme that implementing his wish had to wait, until PC CPUs became fast\nenough so that a C-language version of mainframe hardware emulation\nbecame practical.  Roger developed Hercules until it actually started\nworking well, and he's now turned the everyday proprietorship over to\nJay Maynard.  You can subscribe to the Hercules-390 mailing list (see\nFigure 1) to find out more about what's happening.\n\n      Hercules was written in C, to run under Linux.  This, and the fact\nthat C-language runs on multiple platforms, allows Hercules to be run on\nmost computers that can be found in a person's house.  Just a bit more\nthan a week before this writing, a Windows 95/98 port of Hercules was\nannounced, and the initial reports have indicated that Hercules'\nperformance under Windows is comparable to its performance under Linux.\nI'm starting to get goosebumps, imagining that soon I might be running a\nmainframe operating system in my house.\n\n      But there are licensing issues.  Although it is currently\ntechnically possible to run OS/390 Release 2.9 under Hercules, you have\nto have a license for OS/390 from IBM, and from my limited\nunderstanding, that isn't cheap at this time.  Many people are actually\nopting for running OS/360 (that's right - MVT)!  Yes, MVT (OS/360\nRelease 21.8) is free.  And people are \"hiking out\" their old OS/360\nsysgen manuals from moldy basements and sharing them with other people.\n\n      How is OS/360 publicly available?  We have to thank Rick Fochtman,\nwho asked me to announce five years ago, in the CBT Tape documentation,\nhis request for a copy of the old OS/360 source and sysgen tapes.  One\nday, on the IBM-MAIN mailing list, Glen Herrmansfeldt mentioned that he\nhad an OS/360 source tape, and the ball started rolling.  Jim Marshall\nhad saved a whole load of OS/360 materials on tape, together with a\nfull set of microfiche.  Jim sent copies of his OS/360 tapes to Rick\nFochtman, together with all of his microfiche, and Rick produced a\npractically complete set of source and machine-readable OS/360 code\non cd-rom.  The rest is history.\n\n      Under Hercules, DASD and tape are emulated by PC disk files, and\nit's also possible to attach SCSI peripherals.  Of course, it depends\non what operating system you're running.  Under OS/360, the most recent\nDASD type is a 3330.  On OS/390, you can emulate 3390's of all types.\nYou can run all kinds of standalone utilities under Hercules, even if\nyou're not running a complete operating system.  Jan Jaeger has written\na standalone editor, called ZZSA, which can be found on File 437 of the\nCBT MVS Utilities Tape collection.  ZZSA is very useful under Hercules,\nespecially when setting it up.  If you're running OS/390, you can run\nStandalone DF/DSS dump-restore, Standalone FDR dump-restore, and other\nsimilar software.  Your MVS systems programming skills will be highly\nexercised when you set up a Hercules system, because you're configuring\na complete MVS (or MVT) running system in a similar manner to the way\nyou set up a small \"Rescue System\".  It's fun.  I'm looking forward.\n\n\nTACHYON and DIGNUS.\n\n      Even without hardware emulation, there are two products that allow\nyou to develop mainframe Assembler and C-Language code on an ordinary\nPC.  The first is the Tachyon 390 Cross Assembler, which produces\nmainframe-executable code and Assembler listings fully compatible with\nthe IBM High Level Assembler, while running completely on the PC.  The\nsecond is the Dignus Systems/C compiler, which compiles C-language\nsource code, and which produces Assembler Language code as output.  If\nyou're restricted to the PC only, you can compile your C code on the\nDignus compiler, and assemble the output with the Tachyon 390 Cross\nAssembler.\n\n      David Bond, who produces the Tachyon 390 Cross Assembler, tries to\nkeep it as completely compatible with IBM's HLASM as possible.  In my\nown use of the Tachyon assembler, I've always gotten completely\ncompatible or exactly identical results, although I suppose it's\npossible that others may hit some more borderline cases.  The Tachyon\nUser Manual describes compatibilities in detail.  But the wonder is that\nit all happens on the PC, and that it's so very good!\n\n      David Bond also produces the Tachyon Operating System and the\nTachyon File Tools.  The Tachyon Operating System eliminates the need\nfor an OS/390 emulator altogether, as it allows you to run and debug\nS/390 programs directly on the PC, and it also simulates many OS/390\nsystem services and SVCs, besides simulating the OS/390 instructions.\nThe Tachyon File Tools are also of much interest, because they include\nfacilities to both interpret and produce TSO XMIT-format files on the\nPC.  The Tachyon File Tools can be licensed separately from the Tachyon\nAssembler, and when licensed by themselves, are quite inexpensive.\n\n      Dave Rivers, who produces the Systems/C C-language compiler, has\nwritten compilers practically all of his working life, besides having\nconsiderable mainframe and C-language experience.  Dave Rivers certainly\nknows what he's doing.  Both Dave Rivers and David Bond are supporters\nof each other's work.  Systems/C has versions which run both on the\nmainframe and on the PC.  So if you're coding for the mainframe, and\nworking on a PC, you can use these products very productively.  Both\nproducts are not free, and I'd recommend that you consult their\nrespective web sites for further information about them.  I do know that\nwe can expect a new version of the Tachyon 390 Cross Assembler, to\ncorrespond with HLASM Release 4 for OS/390 2.10.\n\n      So you've seen a glimpse of some very exciting developments in\nthis age of expanding computer hardware and software technology.  For\nmainframe systems programmers, we may be witness to the beginning of a\nnew Golden Age.  Imagine a time when an MVS-trained sysprog won't have\nto be tied to a multi-million-dollar company.  It amazes us to think of\nthe potential possibilities!  With that in mind, I wish you all the best\nof luck, and I hope to see you again next month.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   Some URL's for Relevant Internet Sites\n\n\n   Fundamental Software Inc.  - FLEX-ES  -  www.funsoft.com\n\n   Tachyon Software - Tachyon 390 Cross Assembler\n                      Tachyon Operating System\n                      Tachyon File Tools       -  www.tachyonsoft.com\n\n   Dignus Systems/C Compiler             -  www.dignus.com\n\n   Hercules-390 Mailing List -\n                   To post messages: hercules-390@onelist.com\n                   To subscribe:     hercules-390-subscribe@onelist.com\n\n   IBM-MAIN Mailing List -\n                   To post messages: IBM-MAIN@bama.ua.edu\n                   To subscribe:     listserv@bama.ua.edu\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0011NV": {"ttr": 21761, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x00(?\\x01\\x00)\\x9f\\x11I\\x00\\xd1\\x00\\xd1\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-10-09T00:00:00", "modifydate": "2000-10-25T11:49:00", "lines": 209, "newlines": 209, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         NOVEMBER 2000\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@attglobal.net and/or sbgolob@aol.com.\nThe Online CBT Tape web site has its own URL.  However, it can also\nbe reached from the \"Members Only\" section of www.naspa.net .\n\n\nDESIGNING SOFTWARE:  WHAT'S IN IT FOR US?\n\n      Our profession is many-faceted.  In order to do our jobs properly,\nwe need to be proficient in a variety of skills.  The main function of a\nsystems programmer is to keep track of the state and levels of system\nsoftware in the shop.  Along with that, comes installation skills, and\nthe ability to install an entire operating system from the materials\nthat IBM and the other vendors send us.  I hope to make that topic the\nsubject of another article in the near future.\n\n      However, today I'd like to talk about an aspect of our jobs that\nwe all deal with directly, but I'm sure that most of us, including me,\ndo not spend a lot of time thinking about it.  I was forced to face this\nsubject, because I have an ongoing side project designing a software\nutility, which happens to be a tape copying program.  In the past six\nmonths, I have added a lot of functionality to this program.  The\nproject has gotten big enough, that I have to think very carefully about\nhow to proceed in designing my program further.\n\n      Figuring out how to design my own rather complicated software\nutility, has gotten me thinking about how a user would attempt to\nlearn about its many capabilities.  We all have a lot to do.  Every so\noften, our jobs require us to learn about some new utility.  Once, I\nhad to learn how to use SDSF.  (I had used the QUEUE program before.)\nThen I had to re-learn most of this again, because I was forced to use\nIOF to do the same thing (browse job output).  All of us have had to\nlearn many aspects of ISPF/PDF in our everyday jobs.  And those of us\nwho are fortunate to use the free PDS 8.5 package (from File 182 of the\nCBT MVS Tape) or its vendor supported successor STARTOOL (from Serena\nInternational), know that it takes quite a lot of practice to\nfamiliarize oneself with that product's many capabilities.\n\n      The rewards justify the effort, though.  Once you've mastered\none of these capable \"multi-utility\" packages, it becomes an integral\npart of your working day.  Whenever you have to edit a file, your\nISPF skills are exercised.  Whenever you have to look at spooled job\noutput, your skills with SDSF, or IOF, or whatever other package you\nuse for that, are refreshed and renewed.  If you use the PDS or\nSTARTOOL packages, whenever you have to find complicated things out\nabout a dataset or its contents, your mind is exercised, to figure\nout how PDS or STARTOOL will help you get the job done.  To solve a\nperformance question, your skill with Omegamon(R) (from Candle Corp.) or\none of the BMC products, or whatever monitor your shop runs, will serve\nyou well.\n\n      I'm hoping that whenever you want to copy a tape, you'll turn to\nmy collection of tape copying programs (which are free) on File 229 of\nthe CBT MVS Utilities Tape.  Or if you want to deal with SYS1.BRODCAST\nmessages, or stop SYS1.BRODCAST from filling up, you'll learn to use\nmy utilities package for that, on File 247 of the CBT Tape collection.\nI hope you find enough completeness in these two packages, that they\nwill satisfy your needs in these areas, most of the time.  My stuff is\nfree.  The commercial software vendors have similar hopes that you'll\nbuy and use their stuff.\n\n      The bottom line is that there are many software manipulation\noperations we have to do every day.  And there are software tools and\npackages we have to learn how to use, so we can do these jobs.  Often,\nthere are several tools that can do the same job.  But it is our job to\nlearn to use at least one tool that can do each task which comes up.\nThere are a lot of different tasks, and a lot of different tools to\nlearn about.  Usually, we don't have an organized path to take, which\ntells us how to proceed, and what tools to learn.\n\n      So what do we do?  If we have a need (say, to restore a deleted\nmember of a partitioned dataset), we'll ask a more experienced colleague\nif there's a tool to do this.  If the shop has such a tool, we'll try\nand find some JCL that runs it, or an ISPF panel to get into, that'll\ninvoke it.  We play around with the tool until we get the job done,\nand at that point, the question comes up which \"separates the men from\nthe boys\":  Do we drop things there, now that we've gotten past our\nimmediate task?  Or do we try and find out more about that tool?  What\nOTHER things can this tool do?  It's always a good question to ask.\n\n      At this point, we'll shift gears, and look at these matters\n\"from the other person's point of view\".  What if we were the software\ndevelopers?  How do all of a tool's many options look--from the\ndeveloper's side of the fence?\n\n\nSOME INSIGHTS FROM MY EXPERIENCE\n\n      Now that I've taken a simple tape copying tool (called COPYMODS\nfrom the CBT Tape - File 229), and given it about 30 new options, it\ncomes to my mind to ask:  How should I document all these options?\nAnd to be realistic, will anyone actually need all these capabilities?\nWho is going to be the reader of the documentation I write?  What will\nthat reader be able to gain, from what I am saying?  In asking these\nquestions, I've had to re-think the entire software learning process\nfor myself.\n\n      I'll take you though a short tour of what I've had to think about.\nI feel that this exercise has given me a better insight into the nature\nof our jobs, and that is why I want to take the time to share the\nresults with you.  First, let's see what the COPYMODS program does.\n\n      As originally written, the COPYMODS program will make an exact\ncopy of an existing tape, end to end.  If the tape is Standard Labeled,\nCOPYMODS will copy all the labels and the data.  The copied tape will\nhave the same Volume Serial as the original tape.  If the original tape\nwas Non-Labeled, COPYMODS would copy all the data exactly, with all the\ntape marks.  Furthermore, COPYMODS could make multiple exact copies from\na single tape.  The original program could make 10 copies.  My enhanced\nversion can make 16 copies, if you have enough tape drives.\n\n      In enhancing the COPYMODS program, I've kept two things in mind.\nThe average user will want the original COPYMODS invocation JCL\n(COPYMODS is a batch program) to always still work.  On the other hand,\nwe will want to get rid of the program's shortcomings and limitations,\nwhile at the same time, we want to add new capability.  So in short, I\nhave several different users in mind:  A) the simple user who just wants\nto copy a tape, B) the user who has more complicated needs, and/or C)\nthe user who wants to delve deeper, and exploit the tool to its fullest\nextent.  As the developer, I've had to keep mental track of all three\ntypes of users.\n\n      Let me take you along the path I've taken, to make the\nenhancements and fix the bugs.  I started out simply enough.  COPYMODS\nhad a limitation that it could only copy 32K blocksize, maximum.  I knew\nthat the architectural limit for one EXCP was 64K, so I sought to remedy\nthat shortcoming.  It wasn't so hard to do.  The other limitation of\nCOPYMODS led me on my present long path.\n\n      COPYMODS was originally designed to copy NL tapes only, and\nwhenever it saw two tape marks in a row on a tape, it would assume an\nend-of-tape condition and would mindlessly stop copying.  When copying a\nStandard Labeled (SL) tape, where the tape data is surrounded by header\nlabels and trailer labels, this would sometimes be very annoying.  A SL\ntape file with no data in it, normally contains two tape marks in a row.\nThat's because the header labels are separated from the data by a tape\nmark, and the end-of-data is separated from the trailer labels by\nanother tape mark.  If there's no data in the file, which can occur,\nsay, when you're IEBCOPYing a pds with no members in it to a tape file,\nthe header labels are followed by their tape mark, there's no tape data,\nand then there's immediately another tape mark, which separates the end\nof the (nonexistent) data from the trailer labels.  When COPYMODS would\nsee a null SL tape file, it would copy the file's headers only, and then\nstop right there.\n\n      To remedy that shortcoming, I had to teach COPYMODS the difference\nbetween header labels (HDR1 and HDR2) and trailer labels (EOF1, EOF2,\nEOV1, and EOV2).  If two consecutive tape marks occurred after header\nlabels and before trailer labels, COPYMODS was instructed to continue\ncopying.  This solved the immediate problem.\n\n      However, once I taught COPYMODS a little bit about Standard\nLabels, I asked if I should possibly teach it a little more, and then a\nlittle more.  I taught COPYMODS to print a VOL1 label and show the\nvolume serial if it was there.  Then, I taught COPYMODS to print all the\nstandard label types it found.  Then, as I thought of more ideas, I\ninvented an EXEC PARM parser to make it easy to add new options to\nCOPYMODS (see this column from the July 2000 issue).\n\n      Enhancements went on and on, until COPYMODS can now be invoked\nREAD-only, making no copies.  It can dump all the Standard Labels found\non the input tape, to a disk file, and an NL version of the same tape\n(created by the COPYSLNL program, included in File 229), can be merged\nwith these dumped label sets, to create a new SL tape.  Meanwhile, you\ncan edit the labels in the disk file.  And all of the output tapes from\nCOPYMODS can be made with up to 16 copies at a time.  You see that\nCOPYMODS, in skilled hands, has become an incredible tool!  Yet, the\noriginal JCL to invoke COPYMODS to copy tapes, using no parms and no\nSYSIN cards, still works just about the same.  If I write good\ndocumenation for the \"advanced users\" of COPYMODS, you see that I can\nsatisfy the requirements of all three types of users I've mentioned\nabove.\n\n\nSO WHAT'S IN THIS FOR US?\n\n      So why do I feel that it's been worthwhile mentioning all this?\nBecause it'll make all of us \"tool users\" more aware of how we should\nlearn about new tools.  We have to prioritize our time at work.  But if\nwe have some free time, we can spend it by asking ourselves:  \"What was\na tool I've used recently in a simple way, that I might learn to use\nin a more advanced way?\"  An intrinsically complicated multi-use tool\nlike Candle's \"Omegamon(R)\" monitor, or BMC's \"RESOLVE(R) or\n\"MainView(R)\" might fall into this category.  Or, you might find that a\nrelatively simpler program you might use, such as the VTOC program from\nFile 112 of the CBT Tape, has many other options that might be worth\nlooking into for practical use.\n\n      I'm really coming to suggest a way of growing.  Just like the\ntool designers keep dreaming up more useful enhancements to their\nalready capable products, so the tool users (That's us!) can gain by\nspending more time learning about some of the neat things that the tool\ndesigners have created.  Our working lives, and our capabilities, can\nbe greatly enriched in this way.\n\n      I hope this month's column has gotten you thinking a little\ndifferently.  I wish you all the best of luck, and I hope to see you\nagain next month.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0012DE": {"ttr": 21765, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x001/\\x01\\x001_\\x14&\\x00\\xf7\\x00\\xf5\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-11-07T00:00:00", "modifydate": "2000-11-10T14:26:00", "lines": 247, "newlines": 245, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         DECEMBER 2000\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@attglobal.net and/or sbgolob@aol.com.\nThe Online CBT Tape web site has its own URL.  However, it can also\nbe reached from the \"Members Only\" section of www.naspa.net .\n\n\nKEEPING YOUR FINGER ON THE PULSE\n\n      When we think about the nature of our jobs, we can't forget one\nbasic fact:  It is our duty to know our shop's maintenance structure,\nand to keep our finger on the pulse of all system software changes.\nToday, I'm going to talk about this subject.  I'll start by mentioning\nthe obvious truth that although the operating system itself is common\nto all OS/390 and MVS shops, each individual shop is set up in a\ndifferent manner, and each is maintained, using different procedures.\nHow an MVS shop is maintained, depends both upon the people who had set\nup the MVS system initially, and also upon the people responsible for\nthe system now.\n\n      The way you deal with the maintenance of your shop, is intimately\ndependent on the tools you know how to use.  For example, if you know\nhow to use the free PDS product (on File 182 of the CBT MVS Utilities\nTape), it is obvious that you will maintain your software inventory\ndifferently than if you don't know how to use PDS (or its\nvendor-supported successor STARTOOL from Serena, Inc.).  This is because\nthe PDS product allows you to do manipulations that the IBM-supplied\ntools don't allow, such as expanding a partitioned dataset directory on\nthe fly, without your having to re-allocate the dataset.  The PDS\npackage also allows you to easily create and change ISPF statistics or\nload module attributes, without your having to re-create or re-linkedit\nthe member.  Those are just a few of the many relevant tricks that the\nPDS package allows you to do.  These manipulations are much harder to\naccomplish with native IBM-supplied software tools.\n\n      In the latter part of this column, I'll mention a couple of\nprocedures you can set up to better keep track of your shop's\nmaintenance, if you take advantage of the capabilities of some free\ntools.\n\n      IBM gives certain recommendations as to how to maintain an MVS\nsystem.  However, IBM is restricted to talking about its own tools that\nit ships, and usually will not recommend an independent vendor's tools,\nor free tools.  Therefore, IBM's recommendations are always taken \"with\na grain of salt\", in most shops.  That is, we read them and pay\nattention to them, but we always know (in the back of our minds) that\nsometimes there is a better way.\n\n      Now let's talk about record keeping.  System software changes must\nbe kept track of.  If you put in a new PTF level of your system\nsoftware, you must keep some record of it, so that somebody else, or\neven you yourself, can later follow what was done.  For example, if you\nhave a single system or a single LPAR, you might say that this is very\nsimple--just look at the SMP/E records and you'll know what's there.\nBut if you have several LPARs or many diverse MVS images, and the\nchanges are done to a single system and later propagated, then the task\nof keeping records about which system received the maintenance, rests\nsquarely on your own shoulders.  You have to keep some good records of\nthat.  It usually pays to set up a text pds, common to all the systems\nprogrammers in the group, where maintenance changes have to be recorded\nwhen they are made.\n\n      I'd say that in most shops, this task is complicated by the fact\nthat SMP/E work is never done to a running production system.  SMP/E is\nusually done to a test system, or to target libraries that are never\ndirectly used for execution.  Therefore, the propagation of software\nchanges to the running system is still done in an individually designed\nmanner, which is different for each particular shop.  Again, you have to\nkeep good records of what was done, otherwise the status of the shop\nwill degenerate to a state of confusion.  And with a software system as\ncomplicated as MVS is, confusion can't be tolerated.\n\n      At a previous shop where I worked, we had an excellent automated\nsystem to maintain given software levels for multiple LPARs.  We would\ndo all our SMP/E maintenance to a test res pack that was IPL'ed and was\nconnected to the production packs so it could run real work.  This res\npack could be cloned through an automated procedure that was executed by\nthe systems programmers.  The target SMP/E zone was cloned along with\nthe libraries, and ZONERENAMEd.  An image of this res pack would then\nbecome the production res packs for the various LPARs, and every time\nthe test res pack was cloned, a record would be written automatically to\na common file, so that every invocation of the cloning procedure was\nthoroughly documented.  At the time I worked there, I got permission to\nget this system (as it existed then) put on the CBT MVS Utilities Tape,\nand it is on Files 204 and 205.  Additionally, a similiar system to\nmaintain CICS is on Files 210 and 211, and the same sort of thing for\nDB2 maintenance, is on Files 212 and 213.\n\n\nWHAT MY APPROACH IS.\n\n      In my travels, I've seen many diversely set-up shops.  I have my\nown opinions as to what is \"better\".  But I always keep in mind that\nthe designer of a shop's setup may have had needs or requirements that\nI don't know about.  The world of MVS, 10 or 15 years ago, was far\ndifferent than it is today.  There may have been a \"service level\nrequirement\" in effect then, which isn't so relevant now, since today's\nmachines are faster, and the operating system is more efficient.  When\nI look at a shop's structure, I always assume that the person who\ndesigned it acted intelligently, to the best of his or her ability, at\nthe time the decisions were made.  However, I also assume that there\ncould be room for improvement, and that the system can somehow be made\nbetter, if I look carefully and analytically at it.\n\n      It is my opinion that \"simple is better\".  If the maintenence\nprocedures are simple--that's better.  If the record keeping is simple\nand easy to follow--that's better.  If any sysprog who comes in, can\neasily learn this \"software change and record keeping system\", that's\nbetter.  If PARMLIB setup is simple, and workload management is set up\nsimply and logically--that's better.  If straightforward and relatively\nsimple procedures have been built into the design of the shop, then you\ncan change systems more easily, and you can put in system software\nimprovements very quickly, and with far less hassle.  It's also a great\nhelp, when a shop is arranged so that all software change information\nis kept in one place.\n\n      When you work at a particular shop though, the reality isn't\nusually that way.  Let's look at a \"bad case\" scenario.  The shop\nmight have been heavily customized.  Some piece of system software\nmight use the \"user CVT\" area, in a way that's not easy for you to\ndiscover.  Information about various exits, usermods, and\ncustomizations, might be scattered among the old sysprogs' CNTL\ndatasets, and might not be kept in one central place.  The\nshop-developed tools for keeping track of the software inventory, might\nbe written in a language you may not understand when you come in, such\nas SAS.  To see what's going on, using such tools, you'd have to learn\nSAS.  Although I feel that it's intrinsically good to learn new things,\nmy opinion is also, that the maintenance of an MVS shop should be\nset up so it's doable by any \"standardly trained\" MVS sysprog.\n(However, performance tuning and capacity planning might require a\ngood knowledge of SAS.)\n\n      I'd say that once every 3 months, and more often if you're new,\nyou should ask yourself one question.  The exact text of this question\ndepends on how long you've been at your shop.\n\n      If you've been at your place for a long time, you should ask:\n\"Can I truthfully say to myself that I can explain this system to\nsomeone else?\"  However, if you're newer at the shop, or you're just\ncoming into this shop for the first time, you should ask:  \"How do I go\nabout making sense out of this situation without inadvertently\ndestroying or damaging some essential system function?  How do I go\nabout learning what's going on, and acquire a sense of completeness in\nmy knowledge?\"\n\n      My own approach to an answer is two-pronged.  If I'm new, I try to\nset up my own free diagnostic tools.  These tools can \"feel out the\nsystem\".  Tools which check \"what's in the system, from the system\nitself\", such as SHOWMVS, MXI, and TASID (see my April 2000 column),\nwill reveal the system parameters, and many details about how the system\nis running, without my having to ask anyone.  The other thing I do when\nI'm new, is to ask the other people at the shop, various questions about\nhow the system is set up and maintained.  My questions to them are made\nfar sharper and to-the-point, by the fact that I've used my own\ndiagnostic tools to already find out a lot of the particular information\nfor myself.  For example, I may already have found out where many of the\nuser exits are.  Asking the other people, is usually a matter of finding\nout where the source code for the exits is kept, and historical matters,\nsuch as why it was necessary for the shop to implement a particular\ncustomization procedure or exit.  Also, it can be a very good idea to\nfind out the names and (former) userids of all the system programmers\nwho have worked at the shop in recent years.  If some of their datasets\nare still around, I take a very careful look at their contents.\n\n      Now that we've talked about some general matters of how system\nmaintenance SHOULD be designed, I'd like to mention a few specialized\nSMP/E tools that I myself have found useful.  These are definitely\nthings that IBM can't recommend, and they can and do make our lives\nmuch easier.\n\n\nMY LPTF CLIST\n\n      What's in a PTF?  Want to find out quickly and effortlessly?\n\n      Using the free REVIEW dataset browsing program that you can\nobtain from File 134 (load modules are on File 135) of the CBT MVS\nUtilities Tape collection, you can make a simple CLIST, which I call\nLPTF, to browse any PTF you've RECIEVEd, and which is still on your\nSMPPTS dataset.  The LPTF CLIST reads as follows:\n\nPROC 1 &PTF\nCONTROL NOLIST\nREVIEW 'SYSSMPE.SMPPTS(&PTF)'\n\nwhere you can specifically code the name of your SMPPTS dataset in\nthe text of the CLIST, as I've done.\n\n      If you add an invocation of this CLIST to your ISPF command\ntable, using an invocation string of \"LPTF\", you won't even have to\nprecede this inquiry with the prefix of TSO.  You just say:\n\nLPTF ptfnumb\n\nand when you press ENTER, you can see the text of your PTF immediately,\non top of whatever else you were doing.  This tool comes in extremely\nhandy, once it's been set up in your shop.  Its value is enhanced\nadditionally, by the fact that the REVIEW command contains the DIR\nsubcommand, to list the entire directory of the current (SMPPTS)\npartitioned dataset.\n\n      What you do is as follows:  Suppose you want to see PTF UW12345.\nYou invoke LPTF UW12345 from the command line of your ISPF screen.\nSuppose you got the number wrong, and you get a blank REVIEW screen\ninstead.  You can then simply enter \"DIR\" (a REVIEW subcommand), which\nshows the entire pds directory, and scroll down to the area which has\nsimilar PTF numbers.  Then you can look at the text of other PTF numbers\nwhich were \"close\" to the one you originally wanted.  The LPTF CLIST\nthus becomes a handy tool indeed, and you can use it at any time.  The\nREVIEW program works under \"raw TSO\" too, so you can use this PTF\ninquiry method even without ISPF.\n\n\nOTHER SMP/E-RELATED TOOLS\n\n      Years ago, I worked out a method of determining the FMID of all\nthe SYSMODs in any SMPPTFIN-format file (usually a file of PTFs).  All\nof the software programs necessary to do this processing, can be found\non File 118 of the CBT MVS Tape.\n\n      This processing method utilizes a program originally written by\nJerry Lawson, and a post-processing program written by me.  It does not\ninvolve SMP/E at all, and using it, I can analyze PTF tapes for FMID\ninformation before the time of the RECEIVE.  Input to my procedure is\nany SMPPTFIN-format file.  Output is a file of SYSMOD or PTF numbers,\nordered by FMID, and with no repeats.\n\n      I don't have space to describe the details of this processing\nhere.  However, you can set it all up, using the materials provided\non File 118 from the CBT MVS Tape.  If you'll also look at File 215\nof the CBT Tape materials, you'll find my LPTF CLIST, and a mighty\nhandy CLIST to invoke SMP/E in the foreground.\n\n      The CBT Tape materials can be accessed through the Members Only\nportion of www.naspa.net , or through the new NaSPA cd-rom Version 1.5,\nor from an actual tape.  I hope you've found this month's thoughts to\nbe helpful, and I sincerely wish you all a Happy Year!\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0101JA": {"ttr": 21770, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x003O\\x01\\x003O\\x11\\x15\\x00\\xfb\\x00\\xfb\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-11-29T00:00:00", "modifydate": "2000-11-29T11:15:00", "lines": 251, "newlines": 251, "modlines": 0, "user": "WSBG"}, "text": "\n                MVS TOOLS AND TRICKS OF THE TRADE\n                         JANUARY 2001\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@attglobal.net and/or sbgolob@aol.com.\nThe Online CBT Tape web site has its own URL.  However, it can also\nbe reached from the \"Members Only\" section of www.naspa.net .\n\n\nTAPES AND THEIR LABELS\n\n      In doing the business of MVS (and OS/390) systems programming,\neverybody has tasks.  In a sense, your \"experience\" consists of the\nsum of all the tasks you've done, the knowledge about the system that\nyou've gathered, and your attitude.  Attitude is very important.  My\nfirst boss, many years ago, impressed on me that you have to face\nevery task and every problem with a \"can do\" attitude.  You go into\nthe problem with a mind set, that \"I can solve this!\"  With such an\napproach, and with persistence and creativity, you almost certainly\nwill solve your problems and accomplish your tasks.\n\n      Everybody's particular experience in the systems programming\nbusiness is somewhat different from everybody else's, but there is\noverlap.  The overlap, or \"common factors\" in MVS systems experience,\nmakes it possible for us to talk to each other, and to learn from the\nproblems that other people have had to solve.  Usually, a problem that\nwe're currently faced with, has been handled effectively by someone\nelse too.  An Internet forum such as the IBM-MAIN list (see my April\n1999 column) provides a place to trade experiences on a topic.  Also,\none can look in the large utility collections such as the CBT Tapes,\nwhich are available online as well.  There, you can see coding examples\nand tools that can also help you solve your work-related problems.\n\n      My own experience has forced me to often deal with tapes.  For\nsome of us, tape processing is peripheral, or even non-existent.  Most\nof us deal with tapes once in a while.  Some of us, especially if we've\nbeen setting up a tape management system, or a virtual tape system, or\na tape robot, have had to deal with tapes very often.  In my travels,\nI've had to make tapes and copy tapes.  I've had to convert Standard\nLabeled (SL) tapes to Non-Labeled (NL) tapes.  Going the other way,\nfrom NL to SL, is very difficult, but I've solved that too.  Today, I'd\nlike to share some of my very extensive experience with tapes, so that\nyou can add my experiences to your own store of knowledge.\n\n\nLABELED and NON-LABELED Tapes.\n\n      Tapes contain sequential files, and are sequential by their\nvery nature.  Practically the only \"direct\" thing about a tape is\nthe \"Locate Block\" channel command, which you can read about in the\ntape hardware book I'll mention later, and that's sequential too.\n\n      Tape files are broken into physical blocks.  The BLOCKS are\nseparated from each other by un-recorded spaces on the tape, called\n\"interrecord gaps\", and the FILES are separated from each other by\nspecial hardware-generated character sequences called \"tape marks\".\nSo, to summarize what a non-labeled tape looks like, there are blocks\nof data which comprise the first file, each separated from the next by\nan interrecord gap, and at the end of the file, there is a tape mark.\nThe blocks of the second file follow, followed by a tape mark.  Finally,\nafter the last file on the tape, there are two tape marks in a row.\nThis marks the end of data on the tape.\n\n      If that's what a non-labeled tape looks like, then what are\ntape labels, what do they do, and how do they make a tape into a\nStandard Labeled tape?\n\n      Tape labels are files too.  They are in a special format which\nthe MVS operating system recognizes, so that they are not treated as\ndata files.  Nevertheless, in reality, tape labels are also files, but\nwe have to understand the format they are in, and how they relate to\nthe \"real data\" that is on the tape.\n\n      On a \"Standard Labeled\" IBM tape, or SL tape for short, the\nlabel files consist of groups of 80-byte unblocked records, which\nsurround each data file.  The label file which precedes each data file,\nconsists of the \"header labels\", and the label file which follows each\ndata file, consists of the \"trailer labels\".  In front of the header\nlabel file group at the very beginning of a tape, there is a special\nrecord called a Volume Label, or VOL1 label, which defines the Volume\nSerial name of the tape, and the \"tape owner\".\n\n      So an SL tape file on a tape really consists of three files.  The\nfirst file is the VOL1 label followed by a set of header labels,\nfollowed by a tape mark, and this is followed by the data file.  After\nthe data file is a tape mark, followed by a set of trailer labels.  If\nthat file is the last file on the tape, the trailer labels are followed\nby two tape marks.  Otherwise if other files follow, there is one tape\nmark after the first file's trailer labels, and then comes another\nsimilar three-file \"sandwich\".  You see that an SL tape actually has\nthree times as many files, as an NL tape has.  That's because an SL\ntape has each data file sandwiched between two label files.\n\n      The MVS operating system tape I/O routines use some of the\ninformation that is in the tape labels, to tell the job about the nature\nof the tape files.  Tape label information, when you process a tape as\nStandard Labeled, gets merged into the DCB information and the JCL\ninformation to help fill in the fields of the JFCB (Job File Control\nBlock).\n\n      At this point, I should mention the two IBM books that are most\nvaluable in dealing with tapes.  One book is the obvious one--this is\nthe DFP book called \"DFSMS: Using Magnetic Tapes\".  The OS/390 2.10\nversion of this book has number SC26-7341.  The second book is harder\nto find, because it is a \"hardware book\", but it is invaluable\nnevertheless.  This is the \"IBM 3480 Magnetic Tape Subsystem Reference\"\nwhich has number GA32-0042.  There is an equivalent 3490 book which is\njust as useful.  These books show you the channel program commands you\ncan use to actually manipulate tapes on tape drives.  These books can\nbe thought of as the \"Principles of Operation\" books for tapes and tape\ndrives.  The \"System 390 'Green Card'\" also contains the Magnetic Tape\nEXCP instruction codes as well, but the \"card\" doesn't contain the\namount of detail and the programming hints that the hardware books do.\n\n\nCOPYING TAPES\n\n      Most JCL-centered methods for copying tapes, are oriented to\ncopying one tape file at a time.  They are not geared to taking an\nentire tape with all its files, and making a duplicate of it.\nFurthermore, if you want to copy some of the files from one tape to\nanother using \"conventional methods\", you usually have to resort to a\nmulti-step job.  If you happen to be dealing with a tape that has 500\nor more files, multi-step methods can get awkward.  However, we have\nbetter ways of copying tapes.\n\n      Let's examine the simple principles that go into copying a tape,\nand after you see them, you'll see how silly it is, to try and copy a\nmulti-file tape, one file at a time.\n\n      As one more preface, I have to mention BLP tape processing.\nUsually, the MVS operating system looks at a tape label as if it were\nsomething \"special\", and not just a tape data file.  If you specify\nLABEL=(n,SL) or LABEL=(n,NL) in your JCL, and the tape you mount is a\nStandard Labeled tape, the system will attempt to read the contents of\nthe VOL1 label and the first set of headers.  If you write your own\nprogram, you can't read the labels themselves as files, unless you\ntell the MVS operating system to ignore them.  You do that, by\nspecifying the parameter LABEL=(n,BLP).  BLP processing, to bypass\nlooking at tape labels, is a restricted function in most shops.  Its\nuse can be controlled either through JES JOBCLASSes, or through RACF,\nand the average programmer usually can't use BLP processing.  However,\nsince we're the system doctors, we sometimes need this tool, and you\nshould know how it can be invoked in your shop.  If you want to see a\ncoding example of how to get around BLP restrictions, see File 171 from\nthe CBT Tape collection.  The DITTO and TAPEMAP programs there, get\naround BLP restrictions.\n\n      Now, how do you copy an entire tape, in principle?  Using BLP,\nin order to regard any labels as files, you'd simply open the input\ntape, open the output tape, read the first file on the input tape, and\ncopy its blocks to the output tape.  When you come to the first tape\nmark, you'd write a tape mark on the output tape.  Then you'd go read\nthe next file on the input tape and copy the blocks.  At the end of\nthat file, when you encounter a tape mark on input, you write a tape\nmark on output.  You continue in the same manner, until you encounter\ntwo consecutive tape marks, and then you stop, confident that you've\ncopied the entire tape, end to end.  Is this true?  Almost, but not\nentirely.  When is it NOT true?\n\n      If you use two consecutive tape marks as a stopping point in\nreading and copying a tape, sometimes you'll stop too soon.  This\nhappens if you're copying a Standard Labeled tape using BLP processing,\nand one of the files contains no data.  Then, you'll have a set of\nheader labels followed by a tape mark separating the header labels from\nthe data file.  But in this case there is no data.  So there is another\ntape mark separating the (nonexistent) data from the trailer labels.\nSince there is no data separating those two tape marks, they are now\nconsecutive, and a dumb tape-copying program that stops whenever it\nsees two tape marks, will stop after having copied these header labels\nonly.  The rest of the tape files will be erroneously ignored.\n\n      You can see, and use, an actual program which operated this way.\nIt is the old COPYMODS program from File 229 of the CBT MVS Tape.  The\noriginal version of COPYMODS, which stopped blindly after two tape\nmarks, can now be found as member COPYMODO on File 229.  It is clear\nthat in order to solve this copying problem, you have to inform the\n(COPYMODS) program about the presence and format of standard IBM tape\nlabels.  I have done this, and have added many improvements to the\nCOPYMODS program.  COPYMODS is currently at Level 042, and you should\nspend some time looking at this code with its accompanying\ndocumentation.  There is now some advanced and sophisticated knowledge\nin the COPYMODS program, and you can get a lot of practical help in\nprocessing tapes, if you look there.\n\n      On File 229, I've also included a program, called COPYSLNL,\nwhich can strip the standard labels off a tape, and just create an\nNL version of the same tape.  Its action is very simple.  When COPYSLNL\nsees a 3-file SL sandwich, it skips the headers, copies the data file,\nskips the trailers, and writes a tape mark.  All of this action is very\nstraightforward, and these programs can handle a tape with few, or very\nmany files, in exactly the same way.  Tape handling, using such\nprograms, becomes a far simpler matter than it was previously.\n\n\nWhat's in a Tape Label?\n\n      You can see the full format of tape labels readable on an MVS\nsystem, by looking at the book:  \"DFSMS: Using Magnetic Tapes\", which\nI mentioned before.  We'll just talk about the standard EBCDIC MVS\nformats here.  In general, tape labels contain printable characters\nexclusively.\n\n      Header labels consist of two records:  the HDR1 label and the\nHDR2 label.  Trailer labels look like header labels for the most part,\nand they come in two flavors:  EOF1 and EOF2 (end-of-file), or EOV1\nand EOV2 (end-of-volume).  The only difference between a HDR1 label\nand an EOF1 or EOV1, is that the EOF1 and EOV1 labels have the \"block\ncount\" field filled in.  As the system wrote the tape file, it counted\nthe number of blocks written, and this number was inserted into the\nblock count field (at +54 bytes for 6 bytes) of the trailer labels.\nThe corresponding field in the HDR1 label is zeroes.  EOF2 and EOV2\nlabels are identical in content to the corresponding HDR2 labels.\n\n      I'd say that the difference between the information in the HDR1\nlabels and the HDR2 labels is generally that the HDR1 label data is\nindependent of dataset characteristics.  The information about what\nkind of data is in the file, is roughly speaking, contained in the\nHDR2.  For example, the DSNAME, original volser, dataset sequence\nnumber, volume sequence number, creation date, and expiration date,\nare among the fields included in the HDR1.  The HDR2 contains the\nrecord format, block length, record length, tape density, creating\njobname/stepname, and other dataset attributes.  You can easily see\nthe difference in the general nature of the information.\n\n      If MVS reads a tape file as Standard Labeled, then the label\ninformation is available to be merged with the JCL DD card information,\nand can be used to execute the job step.  Therefore it is important that\nthe information be correct.  I'm telling this to you for a good reason.\nThe more sophisticated functions of my version of the COPYMODS program\nallow the user to control all the information contained in the tape\nlabels of copied tapes, so I'm emphasizing that you should look in the\n\"Using Magnetic Tapes\" book to familiarize yourself with those fields in\nthe tape labels, that the MVS system processes.  These fields are called\n\"functional fields\" in that book.  If you take a few minutes to\nfamiliarize yourself with tape label fields that the system uses in\nprocessing a tape, you'll be at a big advantage when you execute tape\njobs.\n\n      I hope you've gained some valuable information by reading this\nmonth's column.  As this column goes into its thirteenth year, I wish\nyou all the best of luck and success.  See you again next month!\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0102FE": {"ttr": 22020, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x006o\\x01\\x006o#F\\x01B\\x01B\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-12-31T00:00:00", "modifydate": "2000-12-31T23:46:00", "lines": 322, "newlines": 322, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         FEBRUARY 2001\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@attglobal.net and/or sbgolob@aol.com.\nThe Online CBT Tape web site has its own URL.  However, it can also\nbe reached from the \"Members Only\" section of www.naspa.net .\n\n\nDEFINING DATASET CHARACTERISTICS\n\n      The MVS Operating System, unlike some other operating systems,\ndefines how to deal with datasets by classifying them into certain\nformats.  MVS has concepts of Fixed Blocked data, Variable Blocked data,\nUndefined record format data, among others.  When managing data in MVS,\nwe always have to reckon with such data descriptions.\n\n      How do we communicate such descriptions of data to MVS when we\nrun a job or an interactive task?  We describe a dataset to MVS in a\nproblem program using DCB information in the program code, and\nexternally from the program, using JCL information, label information,\nand catalog information.  In addition to those ways, tape management\nsystems and databases add extra descriptions.  But today, we're\nconsidering only \"pure MVS\" ways of describing dataset characteristics.\nThere's enough to know, just in terms of pure MVS externals, to keep us\nvery busy for a good while.\n\n      Every one of us knows that there is a lot of information and\ndetail in the OS/390 JCL manual.  None of that information is\nsuperfluous, and a considerable amount of it can be necessary for our\neveryday work.  After today's discussion, we'll hopefully have a better\nidea what all this detail is about, and why we might need it.\n\n      Practically speaking though, we don't have to know \"everything\nabout JCL.\"  One of the reasons for that, is because a lot of the\ndataset information is already contained in other places, and we don't\nhave to add any extra JCL to supply it.  Actually, many of the defining\ncharacteristics for datasets that we use, are contained in the DCB of\nthe program, in catalog information, and in dataset labels on both disk\nand tape.  The JCL that we actually code, is only necessary for filling\nin some of the information about the datasets, which the labels or\ncatalog entries (or the VVDS on the volume) do not contain.  System\nmanaged storage introduces a new dimension in the process of defining\ndatasets, but we'll stick to the basics here, because once you know the\nbasics of MVS datasets, you can understand later what System Managed\nStorage is defining, and managing.\n\n      Much information about MVS dataset management, in my opinion,\ncenters around the JFCB (Job File Control Block) control block.  The\nDCB (Data Control Block) is more familiar to most people, and the DCB\nis the control block that the OPEN processing deals with most directly,\nbut I think that a major key to understanding data management is in the\nJFCB also.\n\n      There is one JFCB created for each dataset in a job step.  Each\nJFCB is created by a DD card or a dynamic allocation request.  And this\nJFCB is one of the places where MVS looks first, when it actually wants\nto OPEN and use a dataset.  The OPEN processing actually \"opens\" the\nDCB (Data Control Block), and the \"ultimate\" processing of the dataset\ncenters around the DCB, but I think you can learn a lot by\nconcentrating on the potential information which can go into the JFCB.\nThe IBM macro which describes the possible contents of the JFCB, called\nIEFJFCBN, is very detailed in its description of fields that describe\ndataset characteristics.  Therefore I think that the IEFJFCBN macro is\nworth spending some time in studying.\n\n      As is well known, presenting dataset information to an MVS job\nstep is a merging process.  Roughly speaking, any dataset characteristic\nnot actually present in the DCB of the program, is filled in from the DD\ncard information, which has gone into the JFCB.  Dataset label\ninformation has also been merged into the JFCB, and when the dataset is\nactually opened, the OPEN process fills in any fields not yet completed\nin the DCB, from information contained in the JFCB.  IBM's \"Using Data\nSets\" manual describes this merging process in much more detail.\n\n      I have to praise IBM for the fact that they have improved the\norganization of MVS manuals.  Where once, there was more confusion, now\nthere is an inclusive manual called \"DFSMS: Using Data Sets\" SC26-7339,\nthat describes dataset management from the user's point of view, but\nwhich also provides a lot of information about dataset internals.\n\n\nLet's Look at a Program\n\n      Take a look at Figure 1, which shows the complete text of a simple\nand general program called CKIEBGEN from Baldomero Castilla.  This\nprogram copies one sequential dataset (pointed to by the SYSUT1 ddname)\nto another sequential dataset (pointed to by the SYSUT2 ddname).  I can\ntestify that the program works (and you can try it too).  Our point in\nshowing this particular program, is that it's very simple, and very\ngeneral, because most of the particulars of defining the dataset\ncharacteristics are missing from it.  Where must you supply that\ninformation from?  It has to come, either from JCL, or from label\ninformation, or from catalog information.\n\n      The CKIEBGEN program uses QSAM (Queued Sequential Access Method)\nto do I/O for its copy operations.  QSAM works with \"logical records\"\nand not with physical blocks, using the GET macro to read a record from\na file to a data buffer (MACRF=GM), and the PUT macro to write a record\nfrom that data buffer to another file (MACRF=PM).  The use of QSAM\nsimplifies a programmer's effort in coding I/O.  However, QSAM has to\n\"know\" which part of a physical block is a \"record\", and in order for\nQSAM to have that information, all the dataset attribute information has\nto be present in the DCB after the dataset is OPENed.  IBM has\nprogrammed the QSAM routines to use the dataset description information\nin the DCB, to construct proper channel programs to figure out how much\ndata from a block constitutes a \"record\", and to GET and PUT only that\nmuch data each time.\n\n      Now how does that work, inside our CKIEBGEN program?  For example,\nsuppose you have a cataloged partitioned dataset which is fixed blocked,\nLRECL=80, BLKSIZE=6000, and it has one member called MEMA.  Suppose you\nwant to use the CKIEBGEN program to copy MEMA into a new member of the\nsame dataset, called MEMB.  Our JCL to do so would be very simple.\nSYSUT1 would be specified as DISP=SHR,DSN=our.pds(MEMA) and SYSUT2 would\nbe specified as DISP=SHR,DSN=our.pds(MEMB) .  How can we get away with\nsupplying so little dataset information?\n\n      The answer is that the system can find out all the dataset\ncharacteristics from the label information (the Format 1 VTOC entry for\nthe dataset on disk), and the catalog information (the volume containing\nthe dataset).  By the time CKIEBGEN OPENs the two DCB's, the QSAM copy\noperation \"knows\" how to make the correct channel programs, so its GET\nand the PUT macros will perform the copy properly, logical record by\nlogical record.\n\n      This same program and the same JCL can be used to copy members in\na RECFM=VB, LRECL=255 partitioned dataset.  The dataset characteristics\nof that pds are different from those of the first pds, but the VTOC\nentry for that dataset (the disk \"label information\") reflects this.\nWhen the MVS system allocates the dataset, the VTOC label information\ngoes into the JFCB, and at OPEN time, QSAM constructs appropriate\nchannel programs to GET and PUT the individual records properly.  The\nchannel programs which QSAM now constructs, are going to be different\nthan the ones it constructed for the first dataset copy.  But because of\nwhat we now know about dataset characteristics, we see that it won't\nmatter to us.  The CKIEBGEN program will work anyway.\n\n      This will definitely NOT be the case if (for example) the input\ndataset is an unlabeled tape file, while the output dataset will be\nnewly allocated and cataloged on disk.  In such a case, in order to get\nthe CKIEBGEN program to work properly, we have to specify a lot more\ninformation about these datasets in the JCL.  Let's see how it works.\n\n      In order to specify the characteristics of the input tape file, we\nhave to specify the format of its data.  If we don't know that, we might\nuse a program which \"feels\" the data files on a tape, and reports what\nit has found about whether the data is fixed blocked, or variable\nblocked, or an unloaded partitioned dataset, and it might also tell us\nwhich program unloaded the pds (e.g. IEBCOPY or IEBUPDTE, or FDR).  Such\na program is the TAPEMAP program from File 299 of the CBT Tape\ncollection, or the TAPESCAN program from File 102 (which shows more\nlow-level information).  Leonard Woren, one of the original authors of\nTAPEMAP, has his own version of TAPEMAP at his web site:\nwww.best.com/~ldw/mvs .  After reading our tape with this type of tool,\nand deciding which file we'd like to copy, we'd have to code JCL to\ntell CKIEBGEN what its detailed characteristics are.  See Figure 2 for\nan example, to copy a fixed blocked tape file from an unlabeled tape.\n\n      The output file, which is new and MVS doesn't know about it yet,\nalso has to be characterized with \"dataset properties\".  Figure 2 will\ngive an example of the kind of additional information about the dataset\nthat will have to be specified.  So this example shows that even for\nrelatively simple dataset manipulations, such as a QSAM dataset copy,\nyou still have to know a lot about the dataset for the operation to\nbe successful.\n\n\nImproving the CKIEBGEN Program\n\n      I have found the CKIEBGEN program useful for my work, because\n\"it is not too smart\".  For example, when I upload a pkzip'ed file from\nthe pc to MVS, folding it into an FB-80 file on MVS, and I want to use\nIEBGENER to copy it, I find that IEBGENER \"doesn't like\" the zip file,\nthinking it's some (uncopyable) file in a special format.  CKIEBGEN is\nnot that \"smart\", and it obediently copies the FB-80 zip file.  To me,\nthis is usefulness.  I've gotten my work done.\n\n      I have improved the CKIEBGEN program somewhat, but not nearly as\nmuch as I want to.  I added a SYSPRINT output file to report some of the\nresults of its copy operation.  I added \"count\" fields, to show how many\nGETs and how many PUTs the program did.  At least, I know that the\nprogram wrote as many records as it read, and I have an idea how big the\ntwo files are.  But there is much further room for improvement in the\narea of reporting the dataset characteristics of the files that were\ncopied.  (My current version of CKIEBGEN is on CBT Tape File 229.)\n\n      Actually, I'd like the CKIEBGEN program to report all the input\nand output dataset characteristics as the program \"sees\" them.  This\nwould tell us information about the datasets that we did not code in the\nJCL.  The potentially improved program would tell us record format and\nDSORG for input and output datasets, as well as LRECL and BLKSIZE.  Then\nwe'd really know how well the CKIEBGEN program worked, and what it\nactually did.  Where should CKIEBGEN \"look\" for the information, so we\ncould improve it in this way?\n\n      We have a choice.  We can get the information from the two JFCB's\n(for SYSUT1 and SYSUT2) before or after OPEN time.  Or we can get the\ninformation from the filled-in DCB's after OPEN time.  In order to\nextract the JFCB information, we'd have to modify each DCB to include an\n\"exit list\" which points to a descriptor and a 176-byte data area in our\nprogram that would receive a copy of that DD name's JFCB.  An execution\nof the RDJFCB macro, even before OPEN time, would then copy all that\nJFCB inforamtion into our program.  We could then access this JCL data\nand catalog information, and format it for reporting in the SYSPRINT\noutput file.\n\n      Our second choice is to get the information from the filled-in\nDCBs after OPEN time.  To do this, we have to map the DCB control blocks\nusing the DCBD macro, and then we can copy the field information into\nour program and format it for display in SYSPRINT.  I can leave it as an\nexercise for some of you, to improve the CKIEBGEN program in this way,\nstarting from my version on CBT Tape File 229.  When you have tested\nyour results, you can email them to me, and I can try to put the nicest\nversion on the CBT Tape for everybody to use.\n\n      I hope this month's article has helped you to think more about\nMVS data, both on its own, and in relation to data imported from other\ncomputing systems.  Everything you learn, or figure out, will help you\nlater, somewhere along the road.  Best of luck to all of you!\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   Modified version of the CKIEBGEN program to show that if\n            the program doesn't specify most dataset characteristics,\n            then the JCL, or the catalog information, or the VTOC\n            information (label information) have to supply those\n            missing characteristics.  These include LRECL, BLKSIZE,\n            record format, DSORG, and others.\n\n            Without this information, the QSAM GET and PUT macros\n            in this program won't \"know\" how to construct the\n            proper channel programs to do the copy operation.\n\n*------------------------------------------------------------- *\n* Program to copy a sequential file to another sequential file *\n* using QSAM.  GET a record and write it to a buffer.  PUT the *\n* record from the buffer to an output file.  Loop until end of *\n* input.                                                       *\n*                                                              *\n* QSAM does the blocking.  This program is very general, and   *\n* you have to specify many of the dataset characteristics in   *\n* the JCL, unless the system has another way to find them out. *\n*                                                              *\n* Qriginal program was from Baldomero Castilla.                *\n* (Adapted to comment in English, and to use only IBM macros)  *\n*------------------------------------------------------------- *\nCKIEBGEN CSECT\n         YREGS\n         USING *,R15\n         B     EYECATCH\n         DC    C'CKIEBGEN'\nSAVEAREA DC    18F'0'\nEYECATCH DS    0H             ENSURE ALIGNMENT\n         SAVE  (14,12)\n         LR    R5,R1          SAVE PARM POINTER\n         LA    R1,SAVEAREA          NEW SAVE-AREA ADDR\n         ST    R1,8(,R13)           FORWARD SAVE-AREA CHAIN PTR\n         ST    R13,4(,R1)           BACKWARD SAVE-AREA CHAIN PTR\n         LR    R13,R1               NEW SAVE AREA ADDRESS\n         LR    R1,R5          RESTORE PARM POINTER\n         DROP  R15\n* -----                       SET UP ONE BASE REGISTER\n         USING CKIEBGEN,R12\n         LR    R12,R15\n* -----                       OPEN INPUT AND OUTPUT FILES\n         OPEN  (SYSUT1,(INPUT))\n         OPEN  (SYSUT2,(OUTPUT))\n* -----                       READ-WRITE AND LOOP UNTIL END\nLOOPIT   GET   SYSUT1,AREA\n         PUT   SYSUT2,AREA\n         B     LOOPIT\n* -----                       AT END OF INPUT, CLOSE FILES\nFIN      CLOSE SYSUT1\n         CLOSE SYSUT2\n* -----                       AND FINISH\nTHEEND   DS    0H\n         L     R13,4(,R13)\n         RETURN (14,12),RC=0\n* -----                       INPUT AND OUTPUT QSAM DCB'S\nSYSUT1   DCB   DDNAME=SYSUT1,MACRF=GM,EODAD=FIN,DSORG=PS\nSYSUT2   DCB   DDNAME=SYSUT2,MACRF=PM,DSORG=PS\n* -----\nAREA     DS    CL32768        THIS IS THE DATA BUFFER\n         END   CKIEBGEN\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.   JCL necessary to copy a non-labeled Fixed Block tape\n            file to a newly allocated disk dataset using CKIEBGEN.\n            Notice that the program, as coded, has no reporting\n            facility to show if the copy was successful.  You have\n            to look directly at the output dataset to determine\n            success.  We've assumed that we've already used the\n            TAPEMAP program or another similar tool, to \"feel\" for\n            the physical characteristics of the input tape file,\n            and we match our JCL for SYSUT1 to the information that\n            TAPEMAP has obtained for us.\n\n//JOBNAME JOB card\n//*\n//CKIEBGEN EXEC PGM=CKIEBGEN\n//STEPLIB   DD  DISP=SHR,DSN=your.loadlib\n//SYSUT1    DD  DISP=OLD,DSN=input.tape.file,\n//            UNIT=TAPE,VOL=(PRIVATE,RETAIN,SER=TAPEA1),\n//            LABEL=(3,NL,EXPDT=98000),\n//            DCB=(RECFM=FB,BLKSIZE=8880,LRECL=80)\n//SYSUT2    DD  DISP=(NEW,CATLG,DELETE),DSN=your.new.disk.file,\n//            VOL=SER=DISKV1,DCB=*.SYSUT1,SPACE=(TRK,(60,90),RLSE),\n//            UNIT=SYSDA\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0103MA": {"ttr": 22026, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x03\\x7f\\x01\\x01\\x03\\x7f\\x15\\x10\\x00\\xf7\\x00\\xf7\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-02-06T00:00:00", "modifydate": "2001-02-06T15:10:00", "lines": 247, "newlines": 247, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          MARCH 2001\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@attglobal.net and/or sbgolob@aol.com.\nThe Online CBT Tape web site has its own URL.  However, it can also\nbe reached from the \"Members Only\" section of www.naspa.net .\n\n\nISPF INTERFACES FOR MVS PROGRAMS\n\n      Deploying our utilities is one of the main tricks of our trade.\nA given software tool might be potentially available, but how can we\nmake it easily accessible to ourselves, should we ever need it?  It's\nobvious to any Systems Programmer, that convenient setup of our tools\nis critical to the efficiency with which we can do our jobs.\n\n      Sometimes we know that a certain tool exists which does a specific\njob.  That tool's setup process may consist of finding its source code,\nassembling it, setting up some ISPF panels or CLISTs or REXX execs, and\nthen figuring out what JCL, or TSO command, or ISPF panel entry, is\nneeded to run it.  Only after we've done the setup process properly,\nwill the tool be available for us to use.  Often, especially when we\nhave to set up our own working environment, a considerable amount of\ntime must be initially invested in setting up each tool that we're going\nto need later on.  As we all know, spending time in advance to prepare a\ntool, just in case you'll need it later, is always time well spent.\n\n      Once we have a tool set up, we can use it.  However, in our\nbusiness, we use a large variety of different tools, and our working\nefficiency, how usefully we'll be spending our time, will often depend\non how quickly any given tool can be deployed.  So we all try to\norganize our collection of tools, so we know how to find them.\n\n      There's another factor though, which can greatly affect our\nworking efficiency.  That factor is a native inefficiency in the way a\ntool executes.  For example, a raw TSO command displays its output to\nus, one screen at a time.  Under raw TSO, we can't scroll up and down\nto see more than a screen's worth of data.  Trying to sift through a\nlarge amount of TSO output that way, could cost us a lot of extra time.\n\n      Suppose, for example, that the output of some tool is written to\na native TSO screen (i.e. a screen in TSO READY mode).  A good example\nof this, is the TSO HELP processor.  When using TSO HELP, for example,\nthe fact remains that once a TSO screen fills up and you've gone to the\nnext screen, the first screen has disappeared.  On a normal native TSO\nscreen, you can't scroll back upward, to see data that has already\npassed by.  Therefore, if you want to see data on a screen that has\nalready passed, you have to interrupt the current execution of the TSO\nHELP command (using PA1 or the Attention key), and you have to\nre-execute HELP.  This is a major pain in the neck, and a cause for\ngreat inefficiency in using this tool.  Anyone who has used TSO HELP to\nlook at a large HELP member, knows exactly what I mean.\n\n      Today, our concentration will be in improving the efficiency of\ntools we already have, by trying to put their output into more\nconvenient form.  Most ISPF outputs, for example, are fullscreen\ndisplays which can be scrolled upward or downward, as you need.\nTherefore, we could make an immediate improvement in our working\nefficiency, if we would somehow convert our TSO output into ISPF\nBROWSE or VIEW form.  This would make the output far more convenient\nto use, than if it were merely displayed under TSO READY mode, the way\nthe tool was originally designed.  Imagine how much easier it would be,\nto view a (several hundred line) TSO HELP command, if the whole thing\ncould be BROWSEd, and you could scroll up and down to look at any of\nthe information you needed?  (Of course, you could use the HEL command\nprocessor, from File 134 of the CBT Tape collection, which is a full\nscreen TSO HELP browser.  I've personally used the HEL command for\nmany years.  But just now, we're emphasizing more IBM-style means of\ndoing this.)\n\n      In this discussion, we'll see many of the things we can do,\nto improve the output formats of our tools, so they'll be easier\nand quicker for us to use.\n\n\nTSO SESSION MANAGER MODE.\n\n      IBM's original solution to the problem of TSO output filling one\nscreen at a time, and then disappearing, is called the TSO Session\nManager.  The TSO Session Manager gets rid of the one-screen-at-a-time\nlimitation, by creating a large screen buffer area, 255 characters wide\nby several thousand lines long.  Instead of writing the TSO output\ndirectly to a screen, under TSO Session Manager, TSO writes its output\nto this large buffer.\n\n      TSO Session Manager mode has some primitive screen positioning and\nsplitting capability, which can be customized.  PF9 takes you to the top\nof the buffer.  PF12 takes you to the bottom.  PF7 scrolls half a screen\nup, and PF8 scrolls half a screen down.  PF10 and PF11 help you scroll\nsideways.  All of this is customizable by the user.  So with TSO Session\nManager mode, you can save a lot of TSO output at the same time, and you\ncan scroll up, down, and sideways to view it.  What about saving this\noutput and putting it someplace else?  It's easy, but also primitive.\nJust use the IBM-supplied command SMCOPY to copy the entire contents of\nthe Session Manager buffer to an output file or to SYSOUT.\n\n      Setting up TSO Session Manager Mode, in its default configuration,\nis a piece of cake.  All you have to do is to substitute the program\nname ADFMDF03 in your LOGON PROC, instead of the program name IKJEFT01.\nThere's more to it, of course, but that's the easy and painless way to\nget to TSO Session Manager without having to know much.  On File 136 of\nthe CBT MVS Utilities Collection, there is a command processor (that has\nto run authorized) called SM, which toggles you into and out of Session\nManager Mode.  In other words, if you are running TSO in Session Manager\nmode, having used program name ADFMDF03 in your LOGON PROC, you can just\nenter the command SM, and you'll be running in ordinary TSO mode.  Enter\ncommand SM again, and you'll be back in Session Manager mode.  Once that\nis set up, you have no trouble running native TSO either way.\n\n      IBM also supplies a way to toggle into and out of Session Manager\nmode, which uses ISPF, but in my opinion it's nowhere nearly as good as\nthe SM command processor that was contributed by Howard Dean.  You use\nthe IBM method by setting up an alternate panel for the ISPF Option 6\npanel, and that panel has a switch to toggle you into or out of Session\nManager mode.  Howard Dean's SM command is better, because (first), SM\nruns directly under TSO, and doesn't need ISPF.  And (second), the ISPF\nmethod sometimes simply doesn't work; it just doesn't switch your TSO\nexecution mode, which can be very frustrating.\n\n      You can execute a TSO command under Session Manager mode and\ncapture very long output.  It's unwieldy, but the capability is there.\nJust get into Session Manager mode, execute the command, go to the top\nof the buffer with PF9, and to the bottom with PF12, to make sure all of\nthe output is there, and just use the SMCOPY PRINT(to.dsn) option to\ncopy the entire buffer, from top to the end-of-output, to an external\nfile.  Then use ISPF EDIT to chop up the file the way you want it.\n\n      I like to run my TSO sessions in Session Manager mode nearly all\nthe time.  If I really need only one-screen output, I have the SM\ncommand ready and waiting.  The SM command does not destroy the Session\nManager buffer--it merely disables it temporarily.  When Session Manager\nmode is turned on again, the old buffer contents are there.  Session\nManager mode also has the advantage that if you're running something\nwhich fills up many TSO screens, it's not delayed after each screen\nfills up.  The command or program runs to its full execution without\ndelays.  For example, if you're copying a pds under TSO, using IEBCOPY,\nand the pds contains several hundred members, the copy runs to\ncompletion at once under Session Manger mode.  Under regular TSO\nexecution mode, you may have to press Enter several dozen times before\nIEBCOPY completes.  Nowadays, you'll see this advantage of Session\nManager mode when you invoke the TSO XMIT command against a pds, which\nruns IEBCOPY under the covers, and it might generate a long output.\n\n      What happens when the Session Manager buffer fills up?  The TSO\nprograms that are executing keep running.  There is a rather long period\nafter which there is a pause--it's something like one and a half\nminutes--and you have to press Enter again.  But by and large, under\nSession manager, the output keeps pouring out without much delay.  But\nwhen Session Manager overruns its buffer, it merely pushes off the top\nof its buffer space, and wipes out the first output that came out.  You\n(only) get the last several thousand lines of the command output.  In\nthat sense, Session Manager behaves like regular TSO, but instead of\nshowing 24, 27, or 43 lines, it shows several thousand lines before the\noutput rolls off.  Session Manager mode is, in many cases, a large\nimprovement over native TSO output.\n\n\nTRAPPING SYSOUT FROM TSO COMMANDS\n\n      At this point, I'd like to talk about one of today's main topics,\nwhich is how to trap some TSO output and BROWSE, VIEW, or EDIT it, so\nthat it can be handled as one entity.  Not all TSO output can be so\ntrapped.  Only TSO output that was produced by the TSO PUTLINE facility\ncan be trapped.  TSO output that was produced by the TSO TPUT facility\ncannot be trapped.  Fortunately, when a CLIST produces output by saying\nWRITE, or a REXX exec produces output by saying SAY, this output gets\ncreated by the TSO PUTLINE facility.  So most of the output of our TSO\nCLISTs and EXECs can be trapped, to be re-displayed under ISPF.\n\n      There's one new out-of-the-box way to perform this operation.\nIt's a REXX exec called DISP, by Robert Bridges.  You can find DISP on\nFile 487 of the CBT Tape collection.  Just install the DISP exec in your\nSYSPROC or SYSEXEC concatenation of libraries under ISPF, and execute\nthe TSO command whose display is to be captured, as follows:  TSO DISP\nfollowed by the command.  For example, you can say:  TSO DISP LISTC\nLEV(SYS1) .  DISP will capture the output of the LISTC command, allocate\na temporary work file, write the output to the work file, and ISPF VIEW\nthe command output.  You can scroll up and down, or copy off chunks of\nthe TSO output to another file.  It works like a charm.\n\n      You can look at the outputs of large TSO HELP members, by simply\nsaying something like TSO DISP HELP XMIT, and you'll VIEW the entire\nHELP member for the XMIT command, instead of having to painfully look\nat it one screen at a time, as before.  This DISP exec is a great thing.\n\n\nTABLE-izing THE OUTPUT OF PROGRAMS\n\n      I'll illustrate this concept with an example.  I'm the author of\na set of utilities which can do amazing things with SYS1.BRODCAST user\nmessages, (and also some pretty novel things with the entire\nSYS1.BRODCAST dataset).  This entire package of utilities is free, and\nit can be obtained from File 247 of the CBT MVS Tape collection.  One\nof these utilities is a TSO command program called BCMUSERS.  If you\nallocate the BRODCAST ddname to DATASET(SYS1.BRODCAST) and execute\nBCMUSERS under TSO, you get a list of all TSO userids with outstanding\nSYS1.BRODCAST messages, plus the number of messages waiting for each\nuser.  It's a cool program, and it's quick.  You can execute the\nBCMUSERS command on each LPAR or MVS system that you're running.\n\n      The problem is, once you've found out that a userid has 2000\noutstanding broadcast messages, and they're clogging up SYS1.BRODCAST,\nyou want to know if the messages are important, so you also want the\ncapability of displaying and/or deleting them.  My programs BCMLIST\n(to display a user's messages without deleting) and BCMDEL2 (to display\nand delete a user's messages) accomplish this purpose, but deploying\nBCMLIST and BCMDEL2 against a large group of users can be an unwieldy\nadministrative task.\n\n      I wanted to do the following:  If I could display a user list of\nall users with outstanding messages (produced by the BCMUSERS program)\nas an ISPF table, so I could execute line commands against each user\n(display from BCMLIST or display/delete from BCMDEL2), then\nadministering SYS1.BRODCAST for outstanding user messages could be a\nbreeze, and SYS1.BRODCAST would never be allowed to fill up!  You could\nset up one of these gizmos for each LPAR or MVS system that you run.\n\n      Not having time to develop this myself, I asked my friend Vinh Vu,\nwhose utility collection is on File 166 of the CBT Tape, and who is a\nwhiz at this kind of stuff, to develop an ISPF application which manages\nSYS1.BRODCAST user messages in this way.  Vinh whipped up a REXX exec\nwhich drives several ISPF panels.  You can find Vinh's package on File\n247 of the CBT Tape under member BCMISPF, and if you want, you can study\nhis code.\n\n      Or you can just use it.  Just install his BCMUTIL REXX in a\nSYSPROC or SYSEXEC library, copy his panels into an ISPPLIB library,\nexecute the BCMUTIL REXX, and you'll immediately get a display of all\nuserids with outstanding SYS1.BRODCAST messages on that system.  You\nhave the option to place an S next to a user to see that user's\nmessages, or a D next to the user name, to display and delete those\nmessages.  ISPF-izing these programs makes them very quick to use.\n\n      I hope you've enjoyed today's discussion, and I hope it has helped\neach of you, in some way.  Much of an MVS Sysprog's work is done under\nTSO, and the faster you can deploy your TSO tools, the quicker you can\nget your work done.  Best of luck to all of you, and I'm looking forward\nto talking with you again, next month.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0104AP": {"ttr": 22276, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x01\\x05o\\x01\\x01\\x05\\x8f\\x18\"\\x00\\xda\\x00\\xd6\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2001-02-25T00:00:00", "modifydate": "2001-02-27T18:22:00", "lines": 218, "newlines": 214, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          APRIL 2001\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@attglobal.net and/or sbgolob@aol.com.\nThe Online CBT Tape web site has its own URL.  However, it can also\nbe reached from the \"Members Only\" section of www.naspa.net .\n\n\nTHE ART OF THE ZAP\n\n      Every programmer knows that when you assemble or compile a\nprogram, and then linkedit it, you have converted programming language\ninstructions into machine instructions.  The computer can then execute\nthe program, which consists of one or more load modules, each of which\nis a conglomeration of successive machine instructions.  Every\nprogrammer knows that when you change a program in a programming\nlanguage, you change the source code, then reassemble or recompile,\nand then re-linkedit, to produce a new load module which behaves\ndifferently.\n\n      However, what do you do if you want to change a program, and you\ncan't recompile its source?  When can this happen?  Suppose you don't\nhave the source.  Why not?  One reason could be because it's an old\nprogram, and the source got lost.  A more common reason is because it's\na system module, and IBM or the vendor doesn't give out the source.  In\neither case, can you still change that program?\n\n      The answer, of course, is \"yes\".  It is very possible to change a\nprogram if you don't have the source code to recompile.  And how is this\naltering of load modules done?  By the process, known far and wide, as\n\"zapping\".  As we'll see, zapping techniques are not only necessary in\nour business, they also contribute to the beauty of it.  I personally\nthink it's possible to elevate the process of zapping to an art form, to\nthe point where we might call this column:  \"The Art of the Zap\".\n\n\nWHAT TOOLS DO YOU ZAP WITH?\n\n      I use two basic tools to perform zapping operations, which are\ndirect changes to programs or data on disk.  (I'm not going to discuss\nthe direct zapping of virtual storage, known as \"core zapping\", in this\narticle.)  The first program is:  IBM's official zapping tool, a program\ncalled Super Zap or \"SPZAP\", whose actual name includes a prefix AMA or\nIMA, so the full program name is AMASPZAP or IMASPZAP.  The second\nprogram is a free tool from the unbelievable CBT Tape collection (File\n134) called UCLA Fullscreen ZAP, which runs under TSO.  Its program name\nis simply ZAP.\n\n      Both of these tools offer large flexibility and capability, and\nboth allow the user great power.  In addition to these two tools, the\nvendor product from Serena Inc. called STARTOOL incorporates a type-over\ncsect zapping tool, which can come in very handy, if you are licensed to\nuse the STARTOOL product.  Here, we'll concentrate on the IBM tool,\nwhich is available with the system, and the free ZAP TSO command, which\nyou don't have to buy.\n\n      The documentation on the AMASPZAP program used to be found in the\nService Aids manual.  As of the later releases of OS/390, that manual\nhas been combined with information on diagnostic tools and component\ntraces.  The title of the manual is now:  \"MVS Diagnosis: Tools and\nService Aids\" (SY28-1085).  In this manual, detailed instructions and\nadvice on how to use AMASPZAP in various situations are presented.\nPractically speaking, I'd recommend reading the AMASPZAP (or SPZAP)\ndocumentation and practicing with the running of some batch jobs to\nchange and dump data, until you feel familiar with the basic use of the\nAMASPZAP program.\n\n      I have to confess that I do most of my own zapping with the TSO\nFullscreen ZAP command.  When using Fullscreen ZAP, you can see what\nyou're doing at all times.  And Fullscreen ZAP includes a complete\nonline help system, so if you don't know what to do, and you're familiar\nwith the ZAP help system, you can get the correct advice and syntax very\nquickly, before proceeding further with what you're trying to change.\n\n\nPRACTICAL ZAPPING\n\n      I always say that you can't zap a program, without knowing how a\nprogram works.  For that information, you have to be somewhat familiar\nwith Assembler Language, and it's also a good idea to play around with\ndisassemblers for a while.  You can find free disassembler programs on\nthe CBT Tape collection in Files 171, 217, and an interactive\ndisassembler system on Files 238 thru 243.  I personally use the vendor\nproduct STARTOOL's disassembler (from Serena in Burlingame, Ca.) because\nit is very fast, and I have access to it.  Disassembler programs convert\nmachine code into human-readable assembler code instructions.  Now I'll\nexplain how all the concepts fit together.\n\n      Zapping a program strikes me as being like reverse programming.\nIn normal programming, you write the program in source code, and you let\nthe compiler or assembler convert your code into machine code.  With the\nzapping process, you already have the machine code, so you have the\nresponsibility (at least partially) of figuring out and understanding\nthe mechanism and thinking behind that program's underlying source code.\nTherefore to be an \"effective code zapper\", you have to be able to\npicture the machine code as if it were source code.  A disassembler\nprogram, which actually converts the machine code into source code, does\nmuch of the picturing for you, and it saves you a lot of the labor.\n\n      But there's one glitch.  Source code, as presented by a\ndisassembler program, usually is not as understandable as the commented\nsource code produced by a programmer.  First, the original source code\nusually shows any branching, BAL'ing, or BAS'ing (execution of\nsubroutines), as going from one location to a label.  When code\nexecution continues at the label location, you can usually understand\nWHY the code went there, because the name of the label is usually\nindicative of the purpose of the code which begins there.  This helpful\ninformation does not show up in a disassembly of machine code.\n\n      In a disassembly, the code branch appears cryptically as a jump to\na displacement off a base register.  Unless you can find the target\nlocation of the branch, and you afterwards figure out the purpose of the\ncode that's there, you can't understand why the code went there.  This\nobstacle (of not having the labels in the assembly) will make it much\nharder to understand the logic of the program, even though you are in\npossession of a disassembly of the code.  Often, disassemblers will help\nyou, by providing a simulation of the location counter that you have in\nan assembly listing.  Using that location counter to figure out where\nthe base registers start counting, helps make it somewhat easier to find\nthe base-displacement location where a branch target actually is.\n\n      So what do I do when I have to zap a system module, especially a\nmodule whose source code is not given out by IBM or by the vendor?  Of\ncourse, I'm assuming that the fix I am making is with the vendor's\npermission (or perhaps the vendor is out of business, and there's no\nsupport at all).  One helpful trick with IBM modules, is to use old\nlevels of the source code, that came out before the module was put into\nOCO (Object Code Only) status by IBM.  At the MVS/XA levels of the\nsystem and before, machine-readable source code at the base levels, was\nroutinely obtainable from IBM as \"Optional Materials\" tapes, and\nassembly listings at the PTF levels were obtainable on microfiche.\nNowadays, the View Program Listings (VPL) service on IBMlink will\nsometimes be helpful.  But recently, as with the example I'm now going\nto show, the VPL search for the source code ended with the message\n\"Classified\", even though we were licensed for the product to be viewed.\n\n      How do we use this old source code?  We try and find the\nequivalent functionality in the old module, to the place where we want\nto zap the new module.  The commented assembler code in the old version,\nwill enable use to more easily figure out the logic of the new version.\nI always try to assemble base code of the old module, to obtain an\nassembly listing.\n\n\nAN EXAMPLE:  ZAPPING THE SPZAP PROGRAM ITSELF\n\n      A friend of mine, a Scotsman working in Germany, recently emailed\nme a request to help him tackle a problem that his shop had to overcome.\nA home-grown DASD-management application, which called the AMASPZAP\nprogram many times in its normal execution, was running afoul of the\nAMA117D messages produced by AMASPZAP:\n\n   AMA117D REPLY Y OR N TO UPDATE VTOC\n\nThe reply always had to be Y.  One would normally think that the\ncompany's Automated Operations system could be set to reply Y whenever\nthat message came up.  But this application had been calling AMASPZAP so\noften, and the AMA117D messages were appearing so frequently, that their\nAutomated Operations system was being overwhelmed.  My friend wanted to\ncreate a zapped copy of the AMASPZAP program, which would bypass the\ncreation of the AMA117D messages altogether.\n\n      What to do?  Two things were done.  First, we obtained a copy of\nAMASPZAP source code at the MVS 3.8 level, which was not a licensing\nproblem at either my friend's shop, or where I was working.  This code\nshowed clearly, that the AMA117D message is produced by a call to an\ninternal subroutine, using a BAL instruction.  Then, we looked at the\nnew AMASPZAP code at an OS/390 level.  It turned out that AMASPZAP is\nnow a stub, which calls either of two programs, one belonging to DFP,\nand the other belonging to BASE MVS.  The BASE MVS piece is roughly\nequivalent in function to the old MVS 3.8 code, and there we found the\nAMA117D subroutine, and the call to it, in a similar place to where it\nwas before.  To do the zap, and to solve the problem, all that was\nnecessary, was to convert the BAL instruction which called the\nsubroutine, to a branch past the area where the subroutine information\nwas handled.  All of the facts were obtainable from the old MVS 3.8\nsource.  The equivalent information for the OS/390 level, could be read\nfrom an AMBLIST listing of the new version.  Our problem was easily\nsolved, and the application at my friend's shop is happily humming,\nwithout spewing out the offending messages.\n\n\nPATCHING\n\n      I'm going to end this column with a word about patching.  The art\nof patching a zap is done when you want to add code to a module, but\nthere's no room in the original code, to substitute new instructions for\nthe old ones.  Often, a vendor who doesn't give out source code to its\ncustomers, has to use this patching technique to create zap fixes for\nits products.\n\n      Patching works as follows:  You add a blank area (binary zeros) to\nthe end of a csect.  If the csect doesn't have room at the end, you can\nuse the linkage editor EXPAND statement to add some space at the end of\nthat csect.  Then you pick the appropriate spot in the module where you\nwant to insert new code.  At that point, you insert one branch\ninstruction to go to the newly created space at the end of the csect.\nOnce there, you copy the original overlaid instruction, and then zap the\nnew code instructions which make the program do what you want.  When\nthat code has finished executing, you add one more instruction, to make\nthe code branch back to the next instruction after the original branch\ninstruction you zapped in.  Thus, you only need to insert 4 bytes for\nzapping, into the original code.  And all the extra code you're adding,\nis external to the original program code.  Very little original code\nneeds to be disturbed, when you perform patching of a zap.  It's like\na PERFORM operation in COBOL, or a BAL in Assembler language.\n\n      I hope you've enjoyed this month's article, and I hope you're not\nafraid to profit from this information when the need arises.  Best of\nluck to all of you.  I hope to see you back here again next month.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0105MY": {"ttr": 22281, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x10o\\x01\\x01\\x10o\\x074\\x01%\\x01%\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-04-16T00:00:00", "modifydate": "2001-04-16T07:34:00", "lines": 293, "newlines": 293, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           MAY 2001\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@attglobal.net and/or sbgolob@aol.com.\nThe Online CBT Tape web site has its own URL.  However, it can also\nbe reached from the \"Members Only\" section of www.naspa.net .\n\n\nUSING SYSPROG TOOLS WITH APP-PROG AUTHORITY\n\n      Recently, somebody wrote to me, saying that he is an application\nprogrammer, and he was having trouble setting up some programmer tools\nfrom the CBT Tape collection, because he didn't have enough \"authority\".\nMy contention is that there are a lot of tools he still can use, and\nthat he shouldn't give up from trying.  This month, we'll talk about how\nto set up many tools that can be useful for any programmer who works on\nan MVS system.\n\n      Most of the tools we use, run either under TSO, or under ISPF\nunder TSO, or they run as batch jobs.  Many of these tools are in\nthe form of load modules.  Load module tools that run under raw TSO\nusually must be in a link list library or a STEPLIB library that is\nmentioned in the JCL of your TSO LOGON proc.  We also run REXX- or\nCLIST-based tools.  REXX or CLIST based tools run out of the SYSPROC or\nSYSEXEC DD concatenation of your TSO session.  ISPF based tools, besides\nhaving CLISTs or REXX execs, may also have PANELS to be hooked into the\nISPPLIB ddname, message members to go into ISPMLIB, tables to go into\nISPTLIB or ISPTABL, skeletons to go into ISPSLIB, and possibly\nadditional load modules that can go into ISPLLIB.\n\n      My answer to the fellow who wrote me, is that in most shops, you\nhave full update and alter authority for your own datasets.  Therefore,\nif your tools don't have to run APF authorized, just put them into your\nown datasets, and include those datasets into the appropriate ddname\nconcatenations of your own TSO session.\n\n\nISPF DATASET CONCATENATIONS, REQUIRED AND OPTIONAL\n\n      It is easy for you to display which datasets are associated to\nwhich ddnames that are allocated to your TSO session.  The fastest way\nto do this, on any MVS system, is to use IBM's LISTA TSO command.  The\ntrick is to use LISTA with the proper sub-parameters.  If you don't do\nso, LISTA will indeed show the datasets allocated to your TSO session,\nbut it won't show which ddnames they are associated with.  Type in:\n\n      LISTA HISTORY STATUS SYSNAMES  or LISTA HI ST SYSN   for short.\n\nYou'll get a list of datasets currently allocated to your TSO session,\nordered properly, and under each ddname.\n\n      ISPF, under TSO, requires particular ddnames to be allocated, in\norder to run.  The capabilities and characteristics of your ISPF session\nwill depend greatly on which datasets are allocated to these required\nddnames.\n\n      To picture this, you know that systems programmers and application\nprogrammers both run ISPF.  But systems programmers usually can do far\ndifferent actions than application programmers normally can do.  That's\nlargely because the datasets allocated to their ISPF sessions are\ndifferent from those of the application programmers.  The rest of the\ndifference arises from security privileges and APF authorization, but\nyou'd be surprised, as an application programmer, to know how much TSO\nand ISPF power is NOT dependent on those two things, but just on the\ncontents of the allocated datasets.\n\n      Now let's talk further about the ddnames needed for ISPF.  Some\nof these ddnames are absolutely required; ISPF will not start if that\nddname is not there.  Others of the ddnames are optional.  ISPF will\nstart.  But if these ddnames are not present, ISPF will not be able to\nuse certain of its capabilities, which depend on thet particular\nddname.\n\n      Let's give examples of required, and optional, ddnames for ISPF.\nFor example, the ISPPROF ddname, pointing to the ISPF profile dataset\nfor your ISPF session, must be pre-allocated or ISPF will not start.\nOn the other hand, the SYSPROC ddname, which points to libraries\ncontaining CLISTs or REXX execs, does not have to be present for ISPF\nto start.  But there's one problem.  If the SYSPROC ddname is not\npresent, you won't be able to execute CLISTs or REXX execs from ISPF\nwith just one command name.  And the capabilities of your ISPF session\nwill be severely limited, because many ISPF dialogs and applications\nrequire CLISTs or REXX execs, in order to run.  Without accessibility\nto the SYSPROC libraries, you won't be able to do a lot of the things\nyou want to, but ISPF will still initialize.\n\n      Here's a list of required ddnames, which are necessary for ISPF\nto initialize.  They are:  ISPPROF (pointing to the profile dataset),\nISPPLIB (pointing to your ISPF panel libraries), ISPTLIB (pointing to\nyour ISPF table libraries - read only), ISPMLIB (pointing to your ISPF\nmessage libraries), and ISPSLIB (pointing to your ISPF skeleton\nlibraries).  I did an experiment, and found that the presence of all\nother ddnames, is optional for ISPF to initialize.\n\n      Here are some optional ISPF ddnames:  SYSPROC (to execute CLISTs\nor REXX execs), SYSEXEC (to execute REXX execs), ISPTABL (ISPF table\nlibraries you want to write to), ISPLLIB (load libraries, to execute\nprograms in non-authorized mode, from your ISPF session), SYSLBC, to\npoint to the SYS1.BRODCAST dataset, and there are some others.\n\n      Now let's get to the main point of this month's column:  If you\nwant to add new capabilities to your ISPF session, you must carefully\ncontrol the contents of the datasets allocated to your ISPF session.\nBut, if you complain that you are an application programmer, and your\nsystem administrators do not allow you to manipulate your session, we\nwill show you where your degrees of freedom are.  The truth is, that\nyou can add a lot to your working environment, even if you are \"just\"\nan application programmer.\n\n\nYOUR OWN DATASETS\n\n      Almost all shops will not restrict your access to your own\nlibraries.  This means that if you create a partitioned dataset with\nyour own TSO id as its high-level qualifier, the shop will not stop you\nfrom updating or otherwise accessing its contents.  There may be other\nrestrictions the shop will impose--it may not grant update access to\nsystem libraries or APF authorized libraries.  But these restrictions\nare OK.  They are necessary, so that the application programmers will\nnot (unknowingly or knowingly) update the system, and damage it.  Most\nshops will let the application programmers \"clobber\" their own\nlibraries, however, because application programmers are considered\nresponsible enough to administer their own programs and materials.\n\n      Therefore, you have freedom to get to work.  You can allocate a\nset of libraries such as:  yourid.ISPPLIB, yourid.ISPSLIB,\nyourid.SYSPROC, yourid.ISPLLIB, yourid.ISPTLIB, yourid.ISPMLIB, and\nperhaps a few others.  Most shops will not restrict your capability to\ndo that, except perhaps if you take too much disk space.  You should be\ncareful to take a little more than enough space, use sizable secondary\nextents, and to allocate enough directory blocks to allow for expansion.\n\n      Once you've allocated your datasets, and even before you've put\nanything into them, you have to hook them into your TSO session, making\nthem accessible to ISPF too.  There are several ways to do this--each\nhas advantages and disadvantages.  It's nice to know some of the tricks.\n\n      The straightforward way to hook your datasets into TSO and ISPF,\nis to re-do the exising dataset allocations, adding your own datasets\nto either the top, the middle, or the bottom of the concatenation for\neach ddname.  For example, if your TSO session has ISPPLIB allocated\nto two datasets:  SYS1.ISPPLIB and APPLIC.ISPPLIB, then you can hook\nyourid.ISPPLIB ahead of them, or behind them, using the TSO ALLOCATE\ncommand, as we'll describe.  Please notice that if you use the SHR and\nREUSE parameters of ALLOCATE (REUSE was introduced with TSO/E), then\nyou don't have to FREE the previous allocation for that ddname.\n\n      You just have to write a CLIST to do the allocations, and you\ncan execute the CLIST either invoking EXEC 'your.library(clisname)'\nunder TSO, or if you already have the library containing your CLIST in\nthe SYSPROC concatenation, you just have to enter %clisname\nas a TSO command.  The allocation, if you want to concatenate your\nlibrary ahead, is:\n\n      ALLOC FI(ISPPLIB) SHR REUSE DA('yourid.ISPPLIB'  +\n               'SYS1.ISPPLIB'  'APPLIC.ISPPLIB' )\n\nThis action can be done for all the libraries you need.  Just include\nyour own library or libraries, ahead or behind the rest.  Then invoke\nISPF, using its alias name ISPF, or its real name, ISRPCP.  That's all\nthere is to it.\n\n      There's one more catch.  This allocation must be done under raw\nTSO, before ISPF comes up.  Many shops force the application programmers\nwho logon to TSO, to go directly into ISPF, restricting their access to\nthe \"raw TSO\" that lies beneath.  ISPF will not allow you to reallocate\nits REQUIRED ddnames while it is running.  But it will allow you to\nreallocate its OPTIONAL ddnames.  And you can also invoke ISPF LIBDEFs\nunder ISPF, to do some \"temporary\" modifications to ISPF required\nddname allocations.\n\n      So if you're in a shop that doesn't let you get into raw TSO,\nyou can partially get around that restriction, by making a CLIST to\nreallocate the \"optional\" ddnames under ISPF, and to issue ISPEXEC\nLIBDEF commands to modify the \"required\" ddnames.\n\n      Another thing you can do:  Since ISPLLIB is not a required\nallocation for ISPF, you can reallocate ISPLLIB under ISPF to invoke any\nload modules you want to hook in to your session.  And since SYSPROC or\nSYSEXEC are not required ISPF allocations, you can reallocate them too.\nTherefore, you have the freedom to hook in many REXX execs or CLISTs,\nwhich can perform system level functions.  Or, from ISPLLIB, you can\nexecute non-authorized TSO commands, such as the PDS command package\nfrom File 182 of the CBT MVS Utilities Tape collection.  So despite a\nrestriction on getting into \"raw TSO\", you still have much freedom to\nadd a lot of new functionality to your session.\n\n\nMISCELLANEOUS TIPS\n\n      There exist several programs on the CBT MVS Utilities tape\ncollection, which allow you to automatically add or delete a library\nfrom a dataset concatenation under TSO.  This is done, keeping the other\nlibraries in the concatenation intact.  The dataset concatenation\nprogram I tested was the KONCAT program on File 355, which worked well\non my system.  Other CBT Tape files which claim to contain concatenation\nprograms or REXX execs, are files 134, 183, 270, 300, 357, 371, and\n454.  Please see Figure 1, for an example of a CLIST which invokes the\nKONCAT command and then invokes ISPF.  Look at Figure 2, to see some\nof the options of the KONCAT command.\n\n      Another tip:  If you have a CLIST library called yourid.CLIST,\nand your TSO profile (not the ISPF profile) has your userid as a prefix,\nthen you can invoke a CLIST out of this library, simply by enclosing its\nname in parentheses.  Thus, if your CLIST name is XYZ, and it is a\nmember of yourid.CLIST, you invoke it simply as (XYZ).  Figure 3 is a\nsimple CLIST which I've called IC, that invokes another CLIST in dataset\nyourid.CLIST, even if yourid.CLIST is not in your SYSPROC concatenation.\nJust say:  IC XYZ , if XYZ is the name of your CLIST.  You can put the\nIC clist in the SYSPROC concatenation, and use it to invoke other CLISTs\nthat aren't in the SYSPROC concatenation.\n\n      A third tip is to look at CBT Tape File 495, which comes from\nTom Conley.  Tom has a system to dynamically hook and unhook ISPF\napplications into your session.  There's a gotcha or two, but Tom's\nsystem deserves a good look.\n\n      I hope this month's topic was useful to all of you, and that it\nwill help both systems programmers and application programmers alike.\nYou should know that at one of the sites I access, I myself only have\napplication programmer privileges.  And I've even developed some system\nlevel tools there.  You can accomplish a lot, wherever you are.  Best\nof luck.  I'll see you again next month.\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFigure 1.   Invoking the KONCAT command to concatenate\n            your own libraries to existing ddnames, and\n            then start ISPF.  This is a CLIST, which\n            you can invoke from \"raw TSO\".\n\n\nKONCAT ISPPLIB 'MYUSRID.PANELS'\nKONCAT ISPMLIB 'MYUSRID.MSGS'\nKONCAT ISPSLIB 'MYUSRID.SKELS'\nKONCAT ISPLLIB 'MYUSRID.LOAD'\nKONCAT ISPTLIB 'MYUSRID.TABLES'\nKONCAT SYSPROC 'MYUSRID.CLIST'\nISRPCP\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFigure 2.   Part of the TSO HELP member for the KONCAT TSO\n            command from File 355 of the CBT MVS Tape.\n\n\nKONCAT will concatenate a specified data set either \"BEFORE\"\nor \"AFTER\" existing concatenations for the specified DD-name.\n\n)X SYNTAX:\n\n         KONCAT DDNAME DSN BEFORE  EVEN   MSG   NODEBUG\n                           AFTER   ONLY   NOMSG DEBUG\n                           REMOVE  VERIFY\n\n  Required     - DDNAME, DSNAME\n  Defaults     - BEFORE, ONLY, NOMSG, NODEBUG\n\n)O OPERANDS -\n\n))DDNAME   - Data Definition Name to use for the concatenation.\n))DSNAME   - Data Set Name to be (re)allocated to the DDNAME.\n))AFTER    - Optional; allocate DSNAME after other data sets.\n))BEFORE   - Optional; allocate DSNAME before other data sets.\n))EVEN     - Optional; reallocate DSNAME to DDNAME even if it is\n             already present.\n))ONLY     - Optional; allocate DSNAME to DDNAME only if it is not\n             already present.\n))MSG      - Display ALLOC diagnostic messages.  Default value.\n))NOMSG    - Disable \"MSG\" parameter.\n))DEBUG    - Show progress through KONCAT program.\n))NODEBUG  - Don't show progress through KONCAT program.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFigure 3.   A simple CLIST, which I call \"IC\" that you\n            can put in a library that is already in the\n            SYSPROC concatenation, so it will invoke\n            another CLIST in your yourid.CLIST library.\n\n\nPROC 1 NME\nEXEC (&NME)\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0106JN": {"ttr": 22531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x12\\x9f\\x01\\x01\\x12\\x9f\\tI\\x01<\\x01<\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-05-09T00:00:00", "modifydate": "2001-05-09T09:49:00", "lines": 316, "newlines": 316, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          JUNE 2001\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@attglobal.net and/or sbgolob@aol.com.\nThe Online CBT Tape web site has its own URL.  However, it can also\nbe reached from the \"Members Only\" section of www.naspa.net .\n\n\nFIGURING OUT THAT MODULE\n\n      Any practitioner in our field of MVS installation and support, has\na lot of experience in growing.  The maintenance of the MVS operating\nsystem requires of its practitioners, to be constantly learning new\nthings.  It's hard enough to learn the basics of how MVS works, and the\nfunctioning of its many components.  Add to that:  UNIX services, web\nenablement, connectivity to other systems, TCP/IP, and a dozen other new\nareas.  The result is a challenging mountain climbing experience in\nlearning, that we all have to face.\n\n      Today, I'd like to look at personal growth directions in\nsupporting MVS (i.e OS/390 or z/OS) that are more basic.  As a member of\nthe \"old school\" in this profession, I want to look at directions and\nmethodologies that bring out the hacker in us.  We're all driven by the\nquestions:  \"How does this work?  What makes it all work?\" Many of those\nquestions stay in our heads for years, before we begin to acquire tools\nthat will help us get answers to them.  My perspective tells me that the\nMVS operating system is so vast, that we'll never find out answers to\nmost of our questions of \"how does this work\"?  We are simply very happy\nthat it all does work.  (The rest is IBM's problem.)\n\n      Nevertheless, we can acquire a thinking methodology that will help\nus get these answers in a specific case, for one or more specific\nmodules, and to solve a specific problem.  If one system module doesn't\nwork, we will be able to find out why.  And furthermore, we will be able\nto get a better insight into the workings of that particular module,\nthan IBM would care to provide to us.\n\n\nRUSSIAN TRAINING\n\n      Political considerations aside, I would like to make a\nstatement whose implications can help all of us become better systems\nprogrammers.  I have endless admiration and respect for those Russian\nprogrammers who had to keep their OS/360 (and later) systems running,\nwith no outside support at all.  With the Cold War over, many of them\nnow live and work in the United States.  I have talked with quite a few\nof these people.  Their training conditions were extremely tough, and\nthese people successfully endured those conditions.  In my opinion, such\npeople can function as the backbone of any computer installation's\nsupport, anywhere.\n\n      I was talking to one such person yesterday.  I mentioned to him,\nthat another Russian friend of mine wrote a clever and useful MVS\ndisassembler program, because in Russia in the 1980's, \"we didn't\nexactly have access to the IBM Support Center\" (to quote his words).\nThis (second) person answered me, that he wrote many disassemblers in\nhis working life, for many different operating systems, and in his\ncurrent work, he \"can't live without them\".  That is just a glimpse of\nthe caliber of expertise and skill we are talking about.  It all comes\nfrom their old environment, the daunting conditions they had to face,\nand what they were forced to do, in order to cope and triumph.\n\n      We can all learn from the old Russian challenges.  This article\nis for us, not for them.  I am here to add my own experiences to theirs,\nand to outline some directions in thinking, which can eventually make\nall of us (also including me, perhaps) into powerhouses of MVS internals\nknowledge and diagnosis skill.\n\n\n\"RETRO COMPUTING\" WITH HERCULES.\n\n      Our field sometimes takes odd twists.  Many of us \"old timers\",\nincluding me, have saved copies of many versions of the OS/360 and MVS\noperating systems, over the years.  We didn't fully know what we'd do\nwith them, but the universal motivating factor for doing this, seems to\nbe, that we'd eventually need some of the knowledge.  The MVS system is\nbuilt on what was past.  Most MVS structures seldom become completely\nobsolete.  So therefore, we certainly have the instinct to feel that the\nknowledge we've acquired and saved from the old systems, will help us\nlater, to better understand what is new.\n\n      Now add to this scenario, that there is currently a burgeoning\nmovement to get old OS/360 and MVS 3.8J systems running.  That is truly\na surprise.  Five years ago, no one would have dreamed that such a thing\ncould happen at all.  The twist here, is that these old operating\nsystems can now be set up, for free, on your home Personal Computer.\nThere is a new, free System/390 hardware simulator named Hercules, which\nruns on your home PC, under Linux or under Windows.\n\n      Actually, Hercules has the \"smarts\" to run OS/390 Release 2.10 on\nyour personal computer at home.  Hercules is free.  However, OS/390 is\nnot, and its licensing costs have to be negotiated with IBM.  Therefore,\nmost \"home MVS systems programmers\" have to content themselves with\nrunning versions of MVS which don't cost money.  So we now are seeing a\nbig movement toward getting very old versions of MVS running sucessfully.\n\n      How does this development help us, to do our regular jobs?  One\nanswer is that old MVS 3.8J source code is now more widely accessible\nand available.  As I mentioned in this column a few months ago, we can\nlook at the commented old assembler code, compare it to newer versions,\nand better figure out how the newer code works, when it is giving us a\nproblem.  Also, by getting involved in running \"old MVS\" at home, we\ncan sharpen our skills immensely, in solving our problems at work with\nthe current MVS systems.\n\n      So if you want to learn more, and find out about Hercules\ndevelopments, there is a Hercules news group.  Its current relevant\nURL's are:\n\n  Subscribe:     hercules-390-subscribe@yahoogroups.com\n  Post message:  hercules-390@yahoogroups.com\n\n\nDIGGING INTO MODULES\n\n      Most of us investigate a system module on an \"as needed\" basis.\nAnd most of our system problems, at the module level, are taken care of\nby the respective vendors.  For example, tape management hooks into the\nMVS operating systems, are fitted into the IBM system modules by the\ntape management vendor.  We usually don't have to worry about fitting\nthem ourselves, or figuring out where they should be inserted into the\nIBM modules.  That's the vendor's job.\n\n      So when can we get such practice?  Usually that happens when we\nhave locally developed system modifications, and that depends on the\nshop.  However, sometimes you can second-guess the vendors, and do\nthings like figuring out why the tape management system hooks go where\nthey do.  If you understand that, you'll really gain some insight into\nhow tapes can be managed.  My main point is, that if you can do some\nmodule surfing, and you gain some knowledge of a small piece of the\nsystem, it'll give you a deeper and better \"general idea\" of how the\nwhole thing hangs together.  You will be a better systems programmer\nas a result.\n\n\nSOME ANCIENT EXPERIENCE\n\n      I think it is worth mentioning some of my past experience in\nfiguring out how a few system modules work.  The modules concerned, are\nallocation modules.  And in case you don't know, much of the allocation\ncode in MVS is lumped into a humongous load module, containing hundreds\nof csects, called IEFW21SD.  Load module IEFW21SD resides in LPALIB.\nThe modules I worked on, are called IEFAB4B0, and IEFAB4A2.  These, and\nrelated code, produce those nice IEF285I messages in the MVS Job Log,\ntelling you whether your dataset was KEPT, CATALOGED, or DELETED.\n\n      Our modification (largely developed by Charlie Pitts) to module\nIEFAB4B0 added some information to the IEF285I messages, namely, counts\nof the EXCPs that your job used, to write to, or read from, all the\ndatasets that it allocated.  The modification was so good, and it was so\n\"close to the system action\", that the EXCP counts even showed up for\nthe dynamically allocated datasets that were grabbed by your TSO\nsession.\n\n      All this was before SMS (System Managed Storage) stuck its ugly\nchanges into the allocation modules, and made it hard to keep up with\nwhat we had to modify.  After MVS/XA 2.2, we had to give up.  Nowadays\nyou have to use SMF exits to get the equivalent information into the Job\nLog, and they're ok, but they're not as good as our original mod.  IBM\nnever directly supported these changes that we made to the system.  But\nas long as we supported this mod, I was able to get a pretty good idea\ninto the workings of modules IEFAB4B0 and IEFAB4A2.  And seeing those\nEXCP counts in our jobs, sure was helpful and nice!\n\n      You can see these old modifications to the operating system on\nFile 369 of the CBT MVS Tape collection.  I had to refit the\nmodifications to several versions of the system, including one in which\nI had no access to the \"source code microfiche\" of IEFAB4A2 and IEFAB4B0\nthat IBM gave out.  I actually worked from a disassembly of these\nmodules, and I still successfully figured out how to make the changes.\nNow, I'll talk about a few of the details.  I hope that some of the\nspirit of what we were doing, will get across.\n\n\nASMTOZAP AND NITTY-GRITTY\n\n      Howard Gilbert (of Yale University) once wrote a marvelous PL/I\nprogram that converts specially constructed Assembler code, into module\nzaps in AMASPZAP input format.  Howard's program is called ASMTOZAP, and\nyou can find it on File 044 of the CBT Tape collection.  There is also a\nPL/I F version of ASMTOZAP, which you can run, for free, on any MVS\nsystem, even if it is not licensed for PL/I Optimizer.  Load modules for\nboth versions of ASMTOZAP are on File 035 of the CBT Tape collection.\n\n      The idea of ASMTOZAP is that you don't have to code the SPZAP VER\nand REP statements to make a system module modification.  You just code\nAssembler language code, assemble it, and get the listing.  The ASMTOZAP\nprogram reads that assembly listing file, and creates the SPZAP input\nfor you.  If you're doing a complicated modification, ASMTOZAP makes it\nmuch easier to code and maintain the source for the mod.\n\n      Please see Figure 1 for an abbreviated sample of ASMTOZAP source\ncode, with its *ZAP CARD ,  *ZAP START VER , *ZAP START REP , and *ZAP\nEND control cards.  When coding the ASMTOZAP Assembler source code, you\nORG to the places you want to start modifying.  Then you place the VER\ncode after the ORG, if you're after a \"START VER\" control card, or if\nyou're after a \"START REP\" control card, you place the new REP code\nafter the ORG.  A *ZAP END card stops the generation of SPZAP control\nstatements from the assembly listing.  Figure 1 gives you the idea.\n\n      Our allocation module modifications were in ASMTOZAP format.  I\ndon't have space to discuss ASMTOZAP further here, but again, you can\nget a considerable idea of how it works, by looking at Figure 1.  Now,\nI'd like to explain how I was able to refit our old zap, across a rather\nsizable change to the IEFAB4B0 module.\n\n      How does module IEFAB4B0 work?  IEFAB4B0 is called by IEFAB4A2,\nand, at the MVS/370 and MVS/XA system levels, it actually produced the\nlines of IEF285I messages for the Job Log.  Our modification to IEFAB4B0\nactually had to go back to its caller's registers, to point to the\ncontrol blocks where the I/O counts were being kept.  After having\nextracted those counts, our modification then stuck them into the\nIEF285I messages.\n\n      At some point, shortly before the onslaught of the SMS-based\nchanges to IEFAB4B0, IBM added a new workarea to the module, and without\nsource code, I didn't know if that workarea interfered with our zap\ncode.  Using a disassembly, I followed the workings of the module from\nthe beginning, and watched as the workarea got filled.  There were a lot\nof STore instructions to displacements off R9.  So I saw that R9 was\npointing to the new workarea and a lot of stuff was being put there.  I\ncould even map the layout of the information in the area.  But I also\nsaw that IEFAB4B0 didn't use the materials in this workarea, until after\nour zap code had finished doing its job.  So I was safely able to fit my\nzap, and our code continued working at that company for another eight\nyears.  (They never went to ESA.)\n\n      I hope these thoughts have provided some stimulation, and I'm sure\nthat we can all gain from these ideas.  Take care, and have the best of\neverything!  I hope to see you again next month.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   Abbreviated ASMTOZAP Source Code for a System Zap\n\n            This is a \"snipped\" example of some ASMTOZAP source\n            code, which is assembled.  The assembly listing gets\n            converted into SPZAP \"VER and REP\" input by Howard\n            Gilbert's ASMTOZAP program.  The full code can be\n            found on CBT Tape File 369, member LM02301A.\n\n                                 (Generate card images)\n*ZAP     CARD ++ USERMOD(LM02301) /* I.O COUNTS IN IEF285I */.\n*ZAP     CARD ++ VER(Z038) FMID(EBB1102) PRE(JBB1326).\n*ZAP     CARD ++ ZAP (IEFAB4B0).\n*ZAP     CARD  NAME IEFAB4B0\n*ZAP     CARD  EXPAND IEFAB4B0(128)\nLM02301A CSECT\nIEFAB4B0 DS    0H\n         PRINT ON,GEN,DATA\n         ORG   @PSTART\n         USING *,@12\n         USING @DATD,@11\n*ZAP     START VER               (Start to generate VER statements(\n         ORG   CLRKEY            (Go to location equated below)\n         STC   @02,@OLDKEY       (Verify the code that's there.)\n         ORG   CLRTXT            (Go to location equated below)\n         MVC   MSGBUFFR+1(73),MSGBUFFR  BLANK ENTIRE BUFFER\n         ORG   STEAL             (Go to location equated below)\n         MVI   MSGDISP+1,C' '      DISPLACED INSTRUCTION\n         ORG   @EL00001          (Go to location equated below)\n         IC    @02,@OLDKEY       (Verify the code that's there.)\n         ORG   @SIZDATD          (Go to location equated below)\n         DC    AL1(230),AL3(@ENDATD-@DATD)\n         ORG   PATCH             (Go to location equated below)\n         DC    4F'0'             (Verify the code that's there.)\n*ZAP     START REP               (Start to generate REP statements)\n         ORG   CLRKEY            (Go to location equated below)\n         STC   @02,@NEWKEY       (Modify the code that's there.)\n         ORG   CLRTXT            (Go to location equated below)\n         MVC   MSGBUFFR+1(78),MSGBUFFR  BLANK ENTIRE BUFFER\n\n  * * * *   LARGE SNIPPAGE    * * * *\n\n         B     PATCH\nMAINLINE EQU   *\n         ORG   @EL00001          (Go to location equated below)\n         IC    @02,@NEWKEY       (Modify the code that's there.)\nPATEXIT  MVI   MSGDISP+1,C' '      DISPLACED INSTRUCTION\n         B     MAINLINE\n*\nEDMSK1   DC    X'60206B2020206B202120'\n*ZAP     END                     (Stop generating REP statements)\n@DATD    DSECT\n         ORG   @DATD+X'48'\n@PC00001 DS    5F\n         ORG   @DATD+X'B4'\nMSGLNGTH DS    F\n         DS    2F\n\n  * * * *   LARGE SNIPPAGE    * * * *\n\n*        ***** EQUATES FOR LOCATIONS WITHIN IEFAB4B0\n*         (These depend on the PTF level of the module)\n@PSTART  EQU   IEFAB4B0+X'1C'\nCLRKEY   EQU   IEFAB4B0+X'52'\nCLRTXT   EQU   IEFAB4B0+X'76'\nSTEAL    EQU   IEFAB4B0+X'156'\n@EL00001 EQU   IEFAB4B0+X'2EE'\n@SIZDATD EQU   IEFAB4B0+X'3E8'\nPATCH    EQU   IEFAB4B0+X'45C'\n\n  * * * *   DATA     AREAS    * * * *\n\n         END\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0107JL": {"ttr": 22537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x01\\x15\\x8f\\x01\\x01\\x15\\x8f\\x08\\x02\\x00\\xeb\\x00\\xeb\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2001-06-07T00:00:00", "modifydate": "2001-06-07T08:02:00", "lines": 235, "newlines": 235, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          JULY 2001\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@attglobal.net and/or sbgolob@aol.com.\nThe Online CBT Tape web site has its own URL.  However, it can also\nbe reached from the \"Members Only\" section of www.naspa.net .\n\n\nEBCDIC to ASCII - YES or NO?\n\n      As we all know, data is represented on the computer as a\nsuccession of bit settings:  0 if the bit is off, 1 if the bit is on.\nTo represent data on most of the systems we work with, the bits are\ngathered in groups of eight.  A group of eight consecutive bits is\ncalled a byte.  The number of different possible combinations of the\neight bits in a byte, is 2 to the eighth power, which equals 256.  So it\nfollows that there are 256 different possible byte combinations of eight\nbits.\n\n      We use the common hexadecimal representation, to shorten how we\npicture eight-bit bytes.  Each hexadecimal number represents 4 bits.\nAnd a byte represents 8 bits.  Therefore, it takes two 4-bit hexadecimal\nnumbers to describe one 8-bit byte.  So, in the common hexadecimal\nrepresentation, the values of these 8-bit byte numbers, representing the\ndecimal numbers from 0 thru 255, ranges from hex 00 (or X'00') to hex FF\n(or X'FF').  This is true, since a hexadecimal number represents a\nfour-bit value from 0 to 15, denoted in increasing order, as 0, 1, 2, 3,\n4, 5, 6, 7, 8, 9, A, B, C, D, E, and F.  And two successive hexadecimal\n4-bit numbers are used to represent one eight-bit byte.  Thus, the\neight-bit byte whose value is 0001,1111 is represented by the\nhexadecimal value 1F, with the hex 1 being the four bytes of 0001, and\nthe hex F being the four bytes of 1111.\n\n      When we represent characters such as a \"small a\" or a \"capital\nA\" on the computer, we choose one of these eight-bit combinations to\nrepresent each character.  So now it is a question of deciding which\ncombination of eight bits should represent which character.  Obviously,\nin order for one computer system to communicate with another computer\nsystem, we must set a standard.  We must decide, which byte combination\nstands for A and which for B, which for 1 and which for 9.  Also, all of\nthe special characters such as the pound sign (#) and so forth, must\nlikewise be accounted for, in a standard manner, by eight-bit \"byte\"\nrepresentations.  And different characters present in different\nlanguages, such as the \"umlaut-ed\" vowels in German, and so forth, must\nlikewise be standardly represented.\n\n      Has this been done?  Of course it has.  What is the complication?\nIt has been done in two different, and completely incompatible ways.\nThere are currently two entirely different standards for character\nrepresentations of machine-readable data.\n\n      Of the two standards, one, which has been championed by IBM, is\ncalled EBCDIC.  The other, which has been adopted by practically\neverybody else, is called ASCII.  IBM is a powerful enough force, that\nits standard cannot be ignored.  MVS, for the most part, and VM, and\nVSE, and AS/400, largely use EBCDIC data representation for characters.\nAnd then, of course, there's the rest of the world....  They use ASCII.\n\n\nTRANSLATION BETWEEN THE TWO SYSTEMS.\n\n      In Assembler Language, it is not hard to convert, for example,\nan 80-byte card image full of characters, from EBCDIC to ASCII\nrepresentation, and vice-versa.  To do so, you use a translate table\ncontaining 256 characters, and a single TR (translate) instruction.\nOnce this is coded, the machine does the rest.  An example of a partial\ntranslation table from ASCII to EBCDIC representation, is shown in\nFigure 1.  This table come to us, courtesy of Tachyon Software, makers\nof the magnificent Tachyon 390 Cross Assembler for the PC.\n\n      The Tachyon 390 Cross Assembler, which can take source code input\neither in ASCII or EBCDIC representation, mimics almost the complete set\nof features of the MVS/VM/VSE High Level Assembler from IBM.  But it\ndoes it on a PC, with compatible output, and it can produce compatible\nADATA.  When the Tachyon Assembler \"sees\" a piece of source code, it\nlooks at the first few characters, and figures out if they look like\nASCII letters and numbers, or EBCDIC letters and numbers.  Then it\n\"gears itself\" to take the rest of the source input in the same way.  To\nfind out more about Tachyon products, go to www.tachyonsoft.com .\n\n      If you look closely at Figure 1, you'll notice some startling\ndifferences.  In ASCII, the lower case letters are represented by bigger\nhex numbers than the upper case letters.  But in EBCDIC, the opposite is\nthe case--upper case letters are larger numbers than lower case letters.\nAnother difference:  in EBCDIC, as is widely known among Assembler\nprogrammers, you convert a lower case letter to an upper case letter by\nOR'ing it with a blank (X'40' in EBCDIC).  But in ASCII, you convert an\nupper case letter to a lower case letter by OR'ing it with a blank\n(X'20' in ASCII).  In EBCDIC, numbers (X'F0' thru X'F9') are bigger hex\nnumbers than letters (either upper case or lower case).  But in ASCII,\nnumbers (X'30' thru x'39') are smaller hex numbers than either the upper\ncase or the lower case letters.\n\n      Whether one hex number representing a letter or a number is\nbigger, or smaller than another, makes a great difference to us.  We see\nthe difference when we do sorting.  Sorting usually goes completely\naccording to the numeric value of a character.  If the character is\nrepresented by a bigger number, that character sorts higher.  So we see\nthat if we'd sort a list of characters in ASCII, the numbers would sort\nlower than the letters.  But in EBCDIC, the numbers sort higher.  That's\nwhy, when we look in the index of a book, and we see the lower case\nwords coming after the upper case words, and the numbers coming before\nboth of them, we know that the book was composed on a computer system\nusing ASCII representation.  Whereas if the lower case words come first,\nand the numbers come last, we know the book was composed and indexed\nusing an EBCDIC-based machine.\n\n      Sometimes even IBM confuses us this way--we look at the index to\nan IBM MVS manual, and its index is sorted the ASCII way, although the\nsubject matter of the book is EBCDIC oriented.  The solution to this\nparadox is easy.  IBM simply used a PC to compose its MVS manuals.  If\nyou know these differences between EBCDIC and ASCII sorts, those\napparent anomalies are completely explained.\n\n\nMOVING DATA BETWEEN SYSTEMS\n\n      If you're moving text from a pc to an MVS machine, you would be\nwise to know, if the program that does the moving, also does a translate\noperation at the same time.  For example, if IND$FILE is the program\nwhich does the data moving, you instruct IND$FILE to translate from\nASCII to EBCDIC on an upload, or from EBCDIC to ASCII on a download,\nwith the \"ASCII\" keyword of the IND$FILE command.  Data delimiting is\nanother difference between the two systems.  MVS (fixed blocked) records\nare delimited by the record size, while ASCII text files on the PC, are\noften delimited either by a Carriage Return (CR) X'0D' character\nfollowed by a Line Feed (LF) X'0A' character, or by one of them without\nthe other (as is done by many UNIX machines).\n\n      All of this may be confusing to the beginner, but after one\nbecomes knowledgeable, one can become an accomplished \"data jockey\".\nFor example, I use SPF/PC (from Command Technology Corporation) on the\nPC, to look at data.  I most often use one of the early Windows versions\nof SPF/PC, which still looks very mainframe-ISPF-like.  SPF/PC allows\nyou to control the profile (keyed on the second name for the file, after\nthe dot), to describe the characteristics of the file you think you're\nlooking at.  Then, when you rename the second name of the file to match\nthe profile, you can either see the data properly, or it looks mangled.\nYou adjust the SPF/PC profile characteristics, using your ASCII-EBCDIC\nknowledge and your data delimiting smarts, until the data can be seen\nclearly.  Once that's done, SPF/PC offers data conversion facilities,\nto convert a text file from say, ASCII and CR-LF delimited, to EBCDIC,\nand 80-character delimited (padded with blanks).\n\n      I'll conclude this month's discussion with some words about the\nusefulness of the TSO XMIT command for moving data.  On MVS, the TSO\nXMIT command is used to convert pds'es and other format data files, to\nFB-80 byte, nice neat sequential files, which are very suitable for\ntransmission to other systems.  XMIT accomplishes this data reformatting\nwith its OUTDSN(re.formatted.dataset) keyword.  For the purposes of\ntoday's discussion, one must know that XMIT-format files are strictly\nEBCDIC.  Any attempt to perform ASCII translation on them, will mess\nthem up irreparably.  (You must do a re-transmission of the original\nfile, without any conversion.)  Therefore, all data transmission of\nXMIT-format MVS files must be BINARY, with no ASCII keyword, or CR or LF\n(if you're using IND$FILE).\n\n      As the proprietor of the CBT MVS Utilities Tape collection, I\nhave to be very familiar will all of this data-moving stuff.  Most of\nthe CBT contributions come in on the Internet, and although I prefer\ngetting XMIT-formatted pds'es, which were transmitted in BINARY, and\nwhich can be converted into an unchanged pds on my MVS system, I often\nhave to \"suffer\" and handle ASCII data, or something else.  I have\nlearned to become very skilled at this.\n\n      An often vexing problem for me, is to handle someone's REXX exec\nthat has been transmitted to me in ASCII, and which has to be converted\nto EBCDIC.  The vertical line in a REXX exec, when looked at in EBCDIC,\nshould be X'4F'.  But some of the ASCII-to-EBCDIC translate tables make\nit into X'6A', a broken vertical line, which does not function the same\nway in a REXX exec.  I've got to make sure that all X'6A' are converted\nto X'4F', and I'm never quite sure that the exec will really work right.\nOther problems are caused by the slanty quotes in ASCII, which may not\ntranslate correctly into EBCDIC, and there's always that stuff that\nbecomes C'3D' on the MVS system, but which was some box, or other, on\nthe ASCII system.  When I get a REXX contribution for the CBT MVS\ncollection, I always prefer that it has never undergone an ASCII\nconversion.  Therefore, I greatly prefer going with the XMIT route,\nwhich is pure EBCDIC.\n\n      I hope this month's talk has opened your eyes to a few of the\nproblems with data transmission between different machines, and that it\nhas better made you more aware of ASCII and EBCDIC issues.  I always\nwish you the best of everything, and I hope to see you again next\nmonth.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.       An ASCII To EBCDIC Translation Table\n\n            This table, with the first hex number as ASCII and\n            the second hex number as its EBCDIC equivalent,\n            comes to us, courtesy of Tachyon Software, makers\n            of the Tachyon Cross-Assembler, Tachyon Operating\n            System, and the Tachyon File Tools for the PC.\n            The Tachyon Assembler can accept Assembler Language\n            source input that is either in ASCII representation\n            or EBCDIC representation, and it uses (by default)\n            the following translation table to convert from one\n            data representation format, to the other.\n\n       blank    !      \"      #      $      %      &      '\n00=00  20=40  21=5A  22=7F  23=7B  24=5B  25=6C  26=50  27=7D\n  (      )      *      +      ,      -      .      /      0\n28=4D  29=5D  2A=5C  2B=4E  2C=6B  2D=60  2E=4B  2F=61  30=F0\n  1      2      3      4      5      6      7      8      9\n31=F1  32=F2  33=F3  34=F4  35=F5  36=F6  37=F7  38=F8  39=F9\n  :      ;      <      =      >      ?      @      A      B\n3A=7A  3B=5E  3C=4C  3D=7E  3E=6E  3F=6F  40=7C  41=C1  42=C2\n  C      D      E      F      G      H      I      J      K\n43=C3  44=C4  45=C5  46=C6  47=C7  48=C8  49=C9  4A=D1  4B=D2\n  L      M      N      O      P      Q      R      S      T\n4C=D3  4D=D4  4E=D5  4F=D6  50=D7  51=D8  52=D9  53=E2  54=E3\n  U      V      W      X      Y      Z      [      \\      ]\n55=E4  56=E5  57=E6  58=E7  59=E8  5A=E9  5B=BA  5C=E0  5D=BB\n  ^      _      `      a      b      c      d      e      f\n5E=B0  5F=6D  60=79  61=81  62=82  63=83  64=84  65=85  66=86\n  g      h      i      j      k      l      m      n      o\n67=87  68=88  69=89  6A=91  6B=92  6C=93  6D=94  6E=95  6F=96\n  p      q      r      s      t      u      v      w      x\n70=97  71=98  72=99  73=A2  74=A3  75=A4  76=A5  77=A6  78=A7\n  y      z      {      |      }      \u00b5      \u00a2      \u00ac      \u00bf\n79=A8  7A=A9  7B=C0  7C=4F  7D=D0  7E=A0  9B=4A  AA=5F  C0=AB\n  \u00d4      \u00d7      \u00d0\nC3=EB  C4=BF  DA=AC\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0108AU": {"ttr": 22785, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x17_\\x01\\x01\\x17_ \\x07\\x00\\xd1\\x00\\xd1\\x00\\x00\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-06-24T00:00:00", "modifydate": "2001-06-24T20:07:00", "lines": 209, "newlines": 209, "modlines": 0, "user": "WSBG"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          AUGUST 2001\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@attglobal.net and/or sbgolob@aol.com.\nThe Online CBT Tape web site has its own URL.  However, it can also\nbe reached from the \"Members Only\" section of www.naspa.net .\n\n\nASSEMBLER PROGRAMMING REVISITED\n\n      If we think about it, we can see that progress in Systems\nProgramming (and in related areas) is fed by technology improvements and\nnewly developed software tools.  And after the technology improvements\nand the better software tools feed further improvements in Systems\nProgramming techniques, it becomes easier as a result, to develop even\nmore technology improvements, and even better software tools.  So the\nprocess becomes a very productive cycle.\n\n      We must observe something about the nature of this cycle.  The\ntruth is, that such progress occurs in fits and starts.  It takes time,\nafter any new tool is developed, for people to learn to use the tool.\nSo after any new tool is released to the public, it will be a while\nbefore we can expect to see changes in people's techniques, which this\nnew tool has made possible.  But even though there are time delays in\nthe mechanism, this process inexorably goes on, and progress will occur.\nTherefore it pays to re-survey your own techniques every few years, to\nsee if any new facilities and services which have come out, can help\nimprove them.\n\n      For example, I remember when the Edit Macro Facility was\nintroduced into ISPF.  After the capability was introduced, people began\ndeveloping their own sets of edit macros, which in turn, made it easier\nfor them to write programs and to set up their MVS systems.  Now that\nthe edit macros made it easier for people to program, they in turn\ndeveloped more new tools, with new capabilities, which weren't there\nbefore.  And those new tools, in turn helped some of them to develop\nstill more facilities and tools for the public to use.  So the cycle of\nprogress goes on.  One new tool spawns dozens of new techniques, which\nin turn, encourage the development of more new tools.\n\n      The same thing has happened in Assembler Programming since the\nnew IBM High Level Assembler (HLASM) was introduced.  New features and\nfacilities introduced into that version of the Assembler, have made it\neasier to write and debug programs.  And in turn, using these new\nfacilities, people can write other new tools, which will again change\neverybody's techniques for the better.\n\n      A technology improvement in the High Level Assembler which has\nhelped me, has been the introduction of the General Register Cross\nReference, introduced with HLASM Release 3.  The General Register Cross\nReference looks at the source code being assembled, and figures out any\ninstructions which use registers, telling you ALL occurrences and uses\nof ALL general registers in the entire program, even if there were no\nregister equates defined, such as R0 EQU 0, and R1 EQU 1.  Therefore, if\nyou are modifying somebody's Assembler program, you don't have to worry\nif the programmer used Register Equate symbols, so they will occur in\nthe regular symbol cross reference.  Even if the program used no\nregister equates at all, you get to find out ALL of the registers that\nwere used, and in what lines of the listing, by looking at the new\nGeneral Register Cross Reference in the Assembly Listing.\n\n      So now, you can better modify Assembler programs, because you can\nfind out which registers have NOT been used.  If you need a new work\nregister, or a BAL register, or a BCT register, or a new base register,\nyou just have to look at the General Register Cross Reference, and you\ncan find out which registers haven't been used, or which registers have\nbeen used the least.\n\n      I recently used this facility to modify a big program that we\nneeded at work, where NO register equates had been used.  The programmer\nwould code an instruction such as LA 3,1(,3) , instead of being clearer,\nand saying LA R3,1(,R3).  With the General Register Cross Reference,\nmodifying this program proved to be no problem for me.  A few years\nearlier, without this Register Cross Reference facility, that job would\nhave been a true nightmare.\n\n\nRE-EVALUATING SOME ASSEMBLER TECHNIQUES\n\n      It has been a long time since many of us went to Assembler\nProgramming School, and the newer folks who are now learning Assembler,\nmight be learning it from people who had to work on the machines of\nthirty years ago.  I think that some techniques ought to be\nre-evaluated.\n\n      Of course, it depends on the kind of code you're writing.  Lately,\nI've been writing a lot of data manipulation utilities on the system\nlevel, but which use QSAM I/O to read records, massage the data, and put\nout output files and SYSPRINT.  They are much like application programs.\nThe \"efficiency stuff\" I learned years ago, doesn't apply to these\nprograms, in my opinion.  Today's machines are bigger and faster, and\nthey have much more \"working storage\".\n\n      For example, when I was younger, I was told \"rules\" such as: \"Real\nAssembler Programmers don't use more than one base register\".  In my\nopinion, that is malarkey (most of the time).  Nowadays, even if I'm\nwriting a \"small program\", I'll set up three base registers, right from\nthe beginning.  In my years of experience, I've seen too many \"small\nprograms\" that eventually became big programs, after more capabilities\nand features had been added to them.  I like to have \"breathing room\" in\nmy programs.  I've had too much trouble, once a program was written and\nhad to be modified, finding a free register for a new base.  Sorry.  I'm\ngoing to put a bunch of base registers out there, right from the\nbeginning!  (And I like eating quiche.)\n\n      My attitude is just the opposite concerning work registers.\nThese are registers which have to be used temporarily to point to some\nstorage, or to hold some data quantity for a while.  I am very stingy\nwith assigning work registers.  That's because if I have to modify the\nprogram later, and I'll really need another work register, one will be\navailable.  But all such \"rules\" have to be reasonable.  You don't want\none process, that needs one work register, to interfere with a\ncompletely different process, that also needs a work register.  THEN, I\nuse two different registers so the two processes won't \"step on each\nother\", and it doesn't bother by conscience at all.  The desire is to\nhave clean, bug-free programs, and that comes first!\n\n      How do I save on assigning work registers?  I use fullwords of\nstorage.  I only keep the info in a register while I need to.  I'm very\ngenerous with saving and restoring register contents to fullwords.\nWhy?  Main storage is cheap nowadays!  Registers are just as expensive\nas they always were!  Instructions are executed very quickly on modern\nmachines!  A sequence of STore or STM (store multiple) instructions\nfollowed by a corresponding Load or LM (load multiple) instruction,\ndon't add much overhead to a program, on today's computers.  You can\nreuse a lot of registers by saving their contents to (one or more)\nfullword(s), using them for processing, and restoring the old contents\nback, right afterwards.\n\n      What's the obvious advantage of doing this?  If I expand the\nprogram later, and I really do need a new work register for something,\none will be available.  The new General Register Cross Reference in\nthe HLASM Assembly Listing will show me the complete picture.\n\n\nSOME OTHER \"NEW\" TECHNIQUES\n\n      Have you ever seen reports with hex zeros (X'00') in them instead\nof blanks (X'40')?  This can come from another old Assembler technique,\nwhich needs revisiting.  When you're defining storage, the old tendency\nwas to use DS (Define Storage) instructions instead of DC (Define\nConstant) instructions, in the work areas.  DC instructions initialize\nthe work area the way you want it, and you have control over their\ninitial contents.  It's like initializing a COBOL or PL/I work area with\na PIC expression.  On the other hand, DS instructions don't initialize\nthe bytes of the area they define.  IBM, in a \"good move\", will force\nthe latest linkage editors to initialize DS-defined areas, but to hex\nzeros (their best guess as to what is right).  But the old 360-vintage\nlinkage editors did not initialize DS-defined areas at all, and whatever\njunk was in storage there, at the time of linkage edit, would be\npropagated right into the load modules.\n\n      So you see that it pays to keep control, with DC instructions,\nthat initialize program areas with constants.  If you are GETMAINing\nsome storage and using it for work areas, these constants will have\nto be copied there, because you have no initial control over what data\nwas previously in the storage you're GETMAINing.  But in the constants\nthat are defined in your program itself, you should retain full control,\nand use DC instructions to initialize the work areas with blanks, or\nwith whatever you want to put there.  I usually define a routine, which\nI BAL to, that initializes work areas the way I want them.  This way, I\ncan run the same routine more than once, during the execution of my\nprogram.\n\n      I have another related tip for safeguarding my report lines.\nMain storage is cheap nowadays.  Programs will run in bigger regions.\nTherefore, I \"pad\" many storage areas with blanks, or whatever is\nreasonable, before and after, particularly the print areas.\n\n      For example, suppose I want to define a report line area to have\na length attribute of 133 bytes, and I want to break it up into fields\nafterwards.  I'll define the initial area as DS 0CL133, to be able to\ndeal with one 133-byte field.  But the trick is that I have to be\ncareful to put 133 \"real bytes\" afterwards, with DC (or DS)\ninstructions defining the individual print line fields.  Suppose I\nhaven't added up the bytes correctly, and there are only 127 bytes\ndefined after the 0CL133 instruction.  Well, the program will just grab\nthe next 6 bytes after the 127 I defined, and include them them in the\nreport line.  If I initialize the 133-byte report line as a whole, say\nto blanks, the 6 data bytes that follow, will be overlaid too, and we'll\nhave a bug.\n\n      We can avoid this problem, if we put, say, a DC 30XL'40' or\nDC 30CL' ', after any print area, just to make sure that the total bytes\nof \"real data\", add up to at least as many bytes, as are supposed to be\nin the print line.  These \"padding bytes\" protect the data lying\nafterward.  And as another tip:  Before each print area, define a few\nblanks too, with DC's.  That will guarantee, if you are \"initializing\"\nthe print area with a MVC AREA,AREA-1 instruction, that AREA-1 will\ncontain a blank, and not something else.  You don't want junk in your\nprint lines, and with modern computer storage capacities and improved\ninstruction speeds, you don't have to worry about inefficiency.\n\n      In conclusion, I'm recommending the re-evaluation of your\nAssembler programming techniques, taking into account:  today's better\nAssembler, faster instruction speeds, and improved main storage\ncapacities.  Concentration should be on expandability, clean code, and\nsafeguarding from unnecessary bugs.  Re-using the same bytes for\nprogram instructions, a hundred times, is a concept that usually can be\nthrown out the window nowadays.  Best of luck and happy coding!  I hope\nto see you again next month.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0109SE": {"ttr": 22789, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x01!\\x9f\\x01\\x01!\\x9f\\x17\\x18\\x00\\xfb\\x00\\xfb\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-08-07T00:00:00", "modifydate": "2001-08-07T17:18:59", "lines": 251, "newlines": 251, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                        SEPTEMBER 2001\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@attglobal.net and/or sbgolob@aol.com.\nThe Online CBT Tape web site has its own URL.  However, it can also\nbe reached from the \"Members Only\" section of www.naspa.net .\n\n\nNAVIGATING THE CBT TAPE COLLECTION\n\n      Today, I've chosen a big topic.  The question here really is:\n\"I need a tool--I don't want to spend (the company's) money--so how\ndo I find it?\"\n\n      Believe it or not, even as the proprietor of the CBT MVS Utilities\nTape collection, I'm not the world greatest expert on finding free\ntools.  But being in the position of having to provide some of these\nservices for other people, I have to do my utmost, to help people find\nthe stuff they need.  Every so often, people write me, asking if there\nexists a tool to do a certain job.  Much of the time, I can help\nthem--sometimes I can't--and once in a while, I just don't know.  So\ntoday I'm going to talk about how I, myself, go about looking for a free\ntool, knowing what I do know.  Since I'm in the position of having\ncreated much of the CBT Tape documentation, and since people expect me\nto be able to help them, I figure that maybe a statement of my own\nmethods could be of some general assistance.\n\n\nWHAT IS THE CBT COLLECTION, and WHERE IS IT?\n\n      The CBT Tape collection is an entirely free and public collection\nof MVS software and helpful goodies for the MVS Systems Programmer.  It\nis not owned by anybody or by any organization--we just take care of it.\nThe collection was started by Arnold Casinghino at the Connecticut Bank\nand Trust Company in 1975 as a tape, and its original Version 1, had 7\nfiles on it (which Arnie told me just a few days ago).  Arnie put the\ncollection, over a span of 15 years, through 321 versions.  I have been\nworking on it for 11 years now, and I have now put it through an\nadditional 117 versions.  The current CBT Tape version, as of this\nwriting, is Version 438 so far.  The collection now spans two 3480 IDRC\ntapes, and contains about 800 separate files, many of which are large\npds'es.  In addition, an old version of the collection, Version 249 from\nJuly 1985, is also available, and it contains additional valuable\nmaterial, even though the material is old.\n\n      The entire CBT collection, plus a lot of other material, and MVS\nlinks, can be accessed from the CBT Tape web site.  One of the ways to\nget to the CBT Tape web site is through the www.naspa.com  Members Only\npage.  This Internet access is what's used by most people nowadays, but\nthe actual collection, as Sam Knutson (our webmaster) will tell you, is\nstill completely tape based.\n\n      Today's question is quite simple to ask, but is not always so\neasy to answer.  It is:  \"I need a tool to do such-and-such.  First of\nall, does a free one exist?   Second, how do I find it?  Third, how do I\nuse it?  Fourth, how do I start looking in the first place?\"  What I can\ndo (as this collection's proprietor), is to make mention of some of the\nsearching capabilities that we've put out there, in the hope that they\nwill help.  I'm also open to any new search suggestions, and if anybody\nhas ideas about new ways of finding free tools, you're certainly free to\nemail Sam Knutson or me about them, and we'll listen.\n\n\nFILE 001\n\n      The two tapes which contain most of the CBT Tape collection, are\ncalled the \"Regular CBT Tape\" and the \"CBT Overflow Tape\".  Each of\nthese tapes has an FB-80 documentation file as its first file.  Arnold\nCasinghino is the architect of most of the structure of this first file,\nand a \"good searcher\" nearly always begins, by looking at \"File 001\".\n\n      File 001 of the Regular CBT Tape now contains over 43000 lines,\nso you can either search it with a brute-force machine-readable method,\nsuch as ISPF EDIT FIND, or you can take some time to learn the structure\nof its many sections, which have been designed to assist your search in\nvarious ways.\n\n      I'd like to add that File 001 can be broken up into a pds,\ncontaining more bite-sized sections.  On File 004 (FB-80) and File 006,\n(a compressed pds) there is a program called CBTUPD which reads FILE 001\nand inserts IEBUPDTE-type ./ ADD NAME= cards in strategic places, so a\nsubsequent IEBUPDTE or PDSLOAD (from File 093) run, will stow the\nbite-sized pieces, in their proper order, as members of a partitioned\ndataset.  That makes the different sections of this documentation easier\nto look at, and print out.  The CBTUPD program will work properly, both\non the Regular CBT Tape's File 001, and on the CBT Overflow Tape's File\n001.\n\n\nTAPEMAP and CBT FILE COMPRESSION\n\n      Most of the files on the CBT Tapes, if they were initially FB-80\nsource-type files, are in a compressed format.  The compression program\nis called \"CBT973\", and its source code can be found as File 002 of\nboth tapes, in FB-80 format.  CBT973 compression works only on FB-80\nfiles, and basically removes blanks.  Most of the compressed files have\nfirst been turned from pds'es to sequential FB-80 files, by stringing\nthe members in order, with IEBUPDTE-type ./ ADD NAME= cards in-between.\nBut ISPF statistics have been optionally preserved on many of the files\nin \"LISTPDS format\" (from the LISTPDS program on File 316), and they\ncan be restored if you use the PDSLOAD program from File 093, instead of\nthe IBM IEBUPDTE program.  Experienced CBT Tape users are familiar with\nthe procedures for extracting files from the tape.  Beginners should\njust customize the JCL on File 003 of either tape, and plow forward.\n\n      If you get CBT Tape files from the Internet, you don't have to do\nany of this--on the web site, the files are stored in zipped XMIT\nformat, and a pkunzip, followed by an upload in BINARY to an MVS system,\nfollowed by a RECEIVE INDS(  ) command under TSO against the file, will\nrestore the original file on your MVS system, to all its former glory.\n\n      But how do you search the entire tape, for individual pds member\nnames?  We've solved that problem too, but you need to know a trick.\n\n      The trick is connected to a version of the UCLA Tapemap program\nthat can be found on File 299 of the Regular CBT Tape.  Only this\nversion of TAPEMAP has support, to recognize a CBT973-compressed tape\nfile, and tell you what all its pds member names are.  Sam Knutson has\nalready done the tape mapping for you.  On the CBT Tape web site, you\ncan point to TAPEMAP listings for the current tapes, and you can search\nthem to look for any member name, on any CBT Tape file, that you want to\nfind.  By using Sam Knutson's canned TAPEMAPs of the recent CBT Tapes,\nif you know a member name or a program name, or a macro name that you\nwant to look for, just search the TAPEMAP listing and get all the\noccurrences of that name.  The TAPEMAP will tell you what files they\nare contained in.  Then you download those files and look.  It's that\nsimple.\n\n\nPARTIAL NAME SEARCHES\n\n      One of my \"tips from experience\" in searching the CBT collection,\nis to search for partial names, rather than for complete names.  For\nexample, suppose you need a coding example for the system exit IFG0EX0B.\nI would definitely NOT search the TAPEMAP listings, or the File 001\ndocumentation, for the name IFG0EX0B.  I'd rather search it for some\ntell-tale string inside that name, such as EX0B.  The reason is because\nsome contributors, when constructing the member names in their files,\nmight not use the exact name of the system exit or program.  Instead,\nthey might hint at the name.  For instance, instead of calling their\nsource member IFG0EX0B, they might call it something like OUREX0B, or\nsomething similar, which hints at the real purpose, but which isn't the\nreal name.  Therefore, partial name searches might be valuable.\n\n      Other times, the contributors to the tape might not mention the\nprogram's exact name at all.  But in the descriptive blurb they write\nfor File 001, they might mention the purpose of the program, without\nmentioning its name.  Therefore, for IFG0EX0B, you might see a mention\nof \"allocation exits\", or some other descriptive phrase which tells\nyou the purpose of the program.  So you have to think of such phrases,\nand search for them too.\n\n      Finally, as a last resort, you can download certain files that you\nsuspect might contain a program you need, and actually do a detailed\nstring search of the contents.  A good string searching tool is the PDS\nprogram package from File 182 of the CBT Tape.  The PDS package contains\na FIND subcommand, which can be applied against all the members of the\ncurrent partitioned dataset, and it will show all occurrences of a\nstring or a program name, if they exist in members of that pds.  The PDS\nprogram has many other features besides \"pds-wide\" string searching, and\nPDS is a tool that it pays to learn to use.  If you are licensees of the\nSTARTOOL package from Serena, Inc., STARTOOL is the vendorized version\nof the PDS package, with a zillion improvements and \"extras\", and so you\ncan use STARTOOL for these searches, instead of \"free PDS\" from File\n182.\n\n\nTHE SECTIONS OF FILE 001\n\n      I'm going to conclude today's talk with a discussion of the\nvarious \"Sections\" which are contained in the general File 001 CBT\ndocumentation.  These 30-or-so sections of File 001 all give you some\nsearch help, each one in a different way.  Which section to look at\nfirst, is a personal matter, but I'll mention a few of the sections\nhere, and when you look at them, you'll be better able to decide how\nthey can help you.\n\n      The first, and probably the most natural section of File 001 to\ndiscuss, is probably the Documentation Section.  This section contains\na detailed description of the contents of each tape file.  The type of\ndescription which is found here for each file, may vary.  But sometimes\nthis section contains detailed program names, and descriptive phrases.\nA scan here, may be helpful, although it may not consistently yield the\nresults you want, since its purpose is to indicate whether you should\nlook at the file or not.  Often, the author of the file provides the\ntext that's found here, so you've got a built-in inconsistency from\nfile to file.\n\n      The File Description Section near the beginning of File 001 gives\na one-line blurb to describe the contents of each file.  I've got about\n60 characters, in which to tell you what's there.  I wrote this section,\nand I tried my best.  Of course, for some files, I might have written a\nmore picturesque description of the file contents.  But the section does\nat least lend a bit of help, in the \"searchability\" department.\n\n      The \"What To Do With This Tape First\" Section, right after the\nFile Description Section, is my opinion, mostly as of ten years ago, as\nto where you should start looking through this collection, provided you\ndidn't get any further guidance.  Even today, it does help.\n\n      The File Status Section is a one-line description of each file on\nthe tape, and it contains a surprisingly useful collection of facts\nabout the size and format of each file.  The date next to each file, in\nthis section, provides the most accurate description of when that file\nwas last updated.  Line counts for source files, and block counts for\nload library files, together with footage counts, are provided on the\nsame single line.  There's even an indicator as to whether the file\ncontains ISPF stats, when you un-compress it and use the PDSLOAD program\nto make a pds out of it.\n\n      For people who have used the CBT Tapes for a long time, and who\nget frequent updates, the Change Section is extremely valuable, and it's\nsearchable too.  In each piece of the Change Section, a short\ndescription of each changed file is provided, for every version change\nof the tape.  For instance, using the Change Section, you can find all\nthe files which were changed on the tape, since the last version of the\nCBT tape that you got.  It's true, that the File Status Section shows\nthis too, but the Change Section provides a verbal description of the\nnature of the change, not just the latest change date.\n\n      Finally, there are a whole bunch of other specialized sections,\nsuch as the one which describes which files of the tape are empty.  In\nsummary, I'd suggest giving the entire documentation a once-over, some\ntime when you have an hour free.\n\n\nOther Sources\n\n      The web provides a lot of other sources of help, to find programs.\nProbably the best other single source of help, is www.xephon.com , where\nyou can download any contributions to the Xephon collection, that are\nmore than 2 years old.  If you get on to the CBT Tape web site, or to\nEric Loriaux' site:  www.ping.be/~ping1475 , you will find links to many\nother sites, and you can keep busy for a long time.  If you are having a\nparticularly hard time finding something, you're welcome to write to me.\n\n      In summary, I hope this month's talk has given you some ideas as\nto how to start searching for free programs.  It is my experience, that\nthe search process is somewhat \"hit-and-miss\" in nature, and it is hard\nto get consistent results.  It very much depends on the particulars of\nwhat you're searching for.  But you don't get any results at all, unless\nyou start trying.  That's \"the nature of the beast\".  Good luck to all\nof you.  See you next month!\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0110OC": {"ttr": 22794, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00$\\x01\\x01%\\x0f\\x01\\x01%\\x0f\\x18\\x04\\x00\\xc7\\x00\\xc7\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-09-07T00:00:00", "modifydate": "2001-09-07T18:04:24", "lines": 199, "newlines": 199, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         OCTOBER 2001\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@attglobal.net and/or sbgolob@aol.com.\nThe Online CBT Tape web site has its own URL.  However, it can also\nbe reached from the \"Members Only\" section of www.naspa.net .\n\n\nLEARNING ABOUT MVS FROM THE SMF BOOK\n\n      Ask any of us the question:  \"Do you know ALL about MVS\"?  We'll\nall answer, \"no\".  Ask us again:  \"So what DO you do?\"  And most of us\nwill answer, in one way or another:  \"We keep on learning more about\nMVS, but it's 'way too big' for us to learn ALL about it.\"\n\n      That's what we're going to talk about today.  How does one \"keep\non learning more\" about MVS?  It's important to find some angles and\napproaches to MVS knowledge, that are useful and productive to follow.\nToday, I'll show you one unusual approach.  Some of us have doubtless\nalready thought about this idea, but I'm quite sure that not everybody\nhas followed through on such a method of learning MVS, in everyday\npractice.  So I think the method is worth talking about.  Also, it's\nsomewhat original, but it makes a lot of sense when you think about it.\n\n      The idea is, to learn as much as you can about MVS, by studying\nthe contents of the various types of SMF records, and by looking in the\ncurrent IBM SMF manual for the kinds of material that SMF tries to\ncollect.  Since the purpose of SMF is to collect the history of your\nMVS system, it will pay for you to know what type of information that\nthe MVS developers believe constitutes \"your system's history\".  And\nthus you can gather more \"know how\" about how your MVS system actually\ndoes work.\n\n      I'll explain further why this will help you learn about MVS.\nSMF, or the MVS \"System Management Facilities\", is a way of recording\nfor posterity, the many transitory phenomena which tell you how an MVS\nsystem is performing.  Most significant actions on an MVS system, will\ncause an \"SMF record\" to be written to the \"active SMF dataset\" (a\nspecial sequential VSAM file) every once in a while.  Each \"type of\naction\" will write a different \"type of SMF record\" to the active SMF\ndataset.  And the SMF dataset will accumulate many of these SMF records,\nof many different types, over the course of time.\n\n      Now if you want to know what your MVS system was doing, the\ninformation you save, has to be indicative of all the different kinds of\nactions which the various parts of the MVS are constantly performing.\nThe MVS developers, when designing the format of each type of SMF\nrecord, studied each part of MVS, trying to figure out what information\nwas worth saving.  It has to be facts and quantities that concern the\ninner workings of MVS.  So what easier way to learn the inner workings\nof MVS, than to look at which facts and measurements these developers\nhave decided to save, in each appropriate type of SMF record?\n\n      Right now, we won't concentrate on the usual job of how to SAVE\nthe physical SMF records for posterity.  That's what we often think\nabout, when it comes to SMF records.  But today, we'll rather concern\nourselves with trying to understand the content and format of each type\nof SMF record, so we can grasp the workings of the MVS component which\ncreated it.\n\n      I have used this approach, and have learned a lot from it.  Now\nI'll tell you some more specifics about this idea.\n\n\nSMF RECORD TYPES\n\n      There are 256 valid \"types of SMF record\", and the numbering\ngoes from 0 thru 255.  These correspond to the bit contents of one\nbyte.  IBM tries to assign low numbers (less than 120 or so) to SMF\nrecords that they produce themselves.  The other vendors generally\nassign high SMF record type numbers, or more usually, they ask the\ninstallation to choose their own number.  Most installations usually\nchoose high numbers--in the 200s, for user-written or vendor-written\nSMF records.\n\n      Additionally, an SMF Record Type may contain several subtypes.\nThe designation of the subtype also occupies one byte of the SMF record.\nHere's one illustration about how subtypes of SMF records are used.  For\nexample, job-related and jobstep-related accounting information is\ncontained in SMF Type 30 records.  But information gathered at job\ninitiation time, gets written to subtype 1.  Similar information\nconcerning job step termination gets written to subtype 4.  And\ninformation concerning job termination gets written to subtype 5.\nThat's just one case, illustrating how subtypes of SMF record types can\nbe used.\n\n      A list of the formats of the various \"IBM-assigned SMF Record\nTypes\" may be found in the current IBM SMF Manual, usually entitled:\n\"MVS System Management Facilities (SMF)\".  The manual number for the\nz/OS version of the SMF manual is SA22-7630.  The OS/390 manual\nnumber for this book is GC28-1783.  This list of formats of SMF\nrecords, is what I'm suggesting that you spend some time studying.\n\n\nGETTING A GRASP OF SMF RECORD TYPES\n\n      I'd suggest that the first thing to do, when it comes to studying\nSMF records, is to read the first couple of chapters in the SMF manual.\nThat'll give you an introduction to what SMF records are for.  After\nthat, I'd suggest that you go straight to the beginning of the chapter\nabout the individual SMF record formats, which is entitled, \"SMF\nRecords\".  Once there, take a slow look at the \"one-liners\" which say\nwhat each SMF record type is about.  You'll discover that there is a\npattern to the assignment of the SMF record numbers.  Each component of\nMVS is assigned a certain range of SMF Record Type numbers, or a certain\nsingle number which has several subtypes.\n\n      For example, SMF record types which report on VSAM-related topics,\nare all assigned SMF type numbers from 60 thru 69.  SMF record types\nthat reflect RMF statistics that were collected, all have numbers from\n70 thru 79.  RACF-related SMF records have type numbers from 80 thru 83.\nDB2-related SMF records are assigned Types 100 thru 102.  On the other\nhand, all CICS-related records are in Type 110 only.  If you're running\nCICS, you'll probably find a lot of these.  And DFSORT statistics are\nonly collected in Type 16 records.\n\n      While we're here, I'll give you a hint on how to look at the SMF\nrecords that are being collected on your own system.  The REVIEW TSO\ncommand from File 134 of the CBT MVS Utilities collection, can be\npointed at any SMF dataset, to browse its contents.  So why is REVIEW\nbetter than ISPF BROWSE?  Because REVIEW has an \"SMF\" subcommand that\nformats the timestamps and the type and subtype numbers of all the SMF\nrecords.  REVIEW also has a \"FINDSMF\" or \"FS\" subcommand, which will get\nyou the next SMF record of a certain type.  For instance, if you say,\n\"FS 14\", REVIEW will position your screen to the next \"Type 14\" SMF\nrecord, and will highlight it.  This facility of REVIEW is extremely\nhandy.\n\n      REVIEW can also look at SMF records on a tape, if you give your\nTSO session the MOUNT attribute, using the CPSCB command from CBT Tape\nFile 300 (or if your session has the MOUNT attribute already).  When\nlooking at an SMF dataset using REVIEW, one invocation of the SMF\nsubcommand will format the records, and a second invocation will toggle\nback to looking at the raw data.  REVIEW is an extremely handy tool for\nlooking at the real SMF records on your system, while you're reading\nabout the SMF record formats in the SMF book.\n\n      Now, let's get back to studying the SMF record formats.  After\nyou've done your overview of all the types, I'd suggest starting to\nstudy the RMF record types in detail:  Types 70 thru 79.  Since RMF\ncollects performance data from many MVS components, you'll gain a ton\nof knowledge from studying the fields of RMF-generated SMF records.\n\n      I'll answer another question before you ask it.  What if you have\nan RMF-substitute package, such as CMF from BMC software, and you don't\nrun RMF?  There's still a simple answer.  CMF does produce its own SMF\nrecords.  Perhaps your installation has assigned Type 240 for them.\nBut if you REVIEW the records in the SMF datasets, you'll still see\nTypes 7x being generated, and just afterwards, there'll be the Type 240\nrecords too.  CMF seems to try to achieve some compatibility with RMF,\nso if you're converting from RMF to CMF, I guess the reporting stats\nwon't be too different.  But CMF's own specific extra reporting will be\nin the Type 240 records that come afterwards.\n\n      Now here's an example of what you can learn:  If you have an SMF\nbook handy, turn to the format of Type 71 records.  There are fields in\nthat record type, which account for every different type of SWAP reason\ncode.  By looking in the book, you'll see that there are at least 17\ndifferent reasons, why an address space might be swapped out.  For\ninstance, a TSO address space might be waiting for a command from a\nterminal.  That's called a \"terminal input wait\".  You can look in the\nSMF book to see the names of the 16 other SWAP reasons, and to try to\nunderstand what they mean.  By doing this, you'll learn an awful lot\nabout address space swapping in MVS.\n\n      So the plan would be, to dip into the SMF book on a fairly\nregular basis, and try to understand the \"reasons behind the fields\".\nYou should especially concentrate on SMF record types which concern\nthe parts of MVS you're dealing with, in your regular MVS work.\n\n\nSUMMARY\n\n      Let's just sum up this approach to learning about MVS.  SMF\nrecords capture the history of what's going on in your MVS system.\nThe information gathered, will reflect the inner workings of many MVS\ncomponents.  Therefore, if you look in the IBM SMF manual, and vendor\nmanuals, which describe the fields of the SMF records being produced,\nyou will learn much more about the inner workings of that component.\nThe REVIEW command from File 134 of the CBT MVS Utilities Tape\ncollection, can view and format real SMF records on your system, and\non tape.  Using the REVIEW command, you can see, on your own system,\nthe information you're been learning about from the SMF book.\n\n      I only have space to give you a hint at this \"different\" approach\nto learning more about MVS.  The job of \"following through\" will have\nto be yours.  If you want to exploit this enormous opportunity to\nincrease your MVS knowledge, it lies before you.  Take a stroll on the\npath, and enjoy....\n\n      That's all for now.  I hope to see all of you, next month!\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0111NV": {"ttr": 23043, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00X\\x01\\x01(\\x0f\\x01\\x01(\\x0f\\x08R\\x00\\xfa\\x00\\xfa\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-10-07T00:00:00", "modifydate": "2001-10-07T08:52:58", "lines": 250, "newlines": 250, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         NOVEMBER 2001\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@attglobal.net and/or sbgolob@aol.com.\nThe Online CBT Tape web site has its own URL.  However, it can also\nbe reached from the \"Members Only\" section of www.naspa.net .\n\n\nTSO BASICS, REVISITED\n\n      Some of us go back to the days when system support consisted of\npunching cards, and running batch jobs.  Anybody who remembers that,\nwill appreciate how important it is, to have to ability to work\ninteractively from terminals, using IBM's TSO (Time Sharing Option).\nMost of us do have a very great appreciation of the value of TSO.  But\ntoday I'd like to underline and reemphasize some aspects of TSO that are\nnot so uppermost in our minds.\n\n      One should not picture TSO as merely a way to submit jobs using a\nterminal.  A TSO session actually has full access to the MVS Operating\nSystem, the same way a batch job, or a started task, has.  Let me\nelaborate a bit.  Years ago, I used to work on a DOS/VSE system part\ntime.  We had to punch cards and run batch jobs on that system, in order\nto do anything.  Then we got an early version of ICCF (Interactive\nControl and Computing Facility), which was IBM's DOS/VSE terminal\ninterface at that time.  To use ICCF was a vast improvement over\npunching cards and reading them.  But, to my knowledge, ICCF was only a\nbetter way of storing 80-byte card images, and in order to do any real\nwork in the operating system, you still had to submit a separate batch\njob.  True interactivity of the terminal interface, with the innards of\nthe operating system, was not there yet.\n\n      Not so TSO!  Each TSO session runs in an MVS address space, and\nhas full access to everything in the operating system, the same way a\nbatch job has.  The only restriction to that, is imposed by the security\nsystem (RACF, or whatever security package you have), and by TSO itself.\n\n      I'll tell you about TSO's main security mechanism.  Within TSO,\nthere is a control block that's established for each user, called the\nPSCB (Protected Step Control Block).  Within the PSCB are bit settings\nto establish the \"authority level\" of that TSO user.  Such properties as\nOPER authority (the ability to issue operator console commands from\nTSO), JCL authority (the ability to submit batch jobs), ACCOUNT\nauthority (the ability to create and alter other TSO userids), and MOUNT\nauthority (the ability to authorize a tape mount from the TSO session),\nare among those powers controlled by these PSCB bit settings.  These\ncontrols are TSO's way of saying whether one userid is more \"powerful\"\nthan another.  But my point is, that a \"fully empowered\" TSO userid can\n\"get anywhere\" in the system.  TSO does not merely store card images.\n\n      The PSCB control block is created for each TSO session at LOGON\ntime.  The initial bit settings in a particular TSO user's PSCB come\nfrom one of two places:  Either they are derived from settings in\nSYS1.UADS, or from the settings in the TSO segment of the security\nsystem's (RACF or equivalent) profile for that userid.  But once the TSO\nsession has been established and is running, the PSCB may be altered,\nusing an authorized command.  The truth is, that the PSCB settings are\nthe ones which are used by TSO, not the RACF or UADS settings.  TSO uses\nthe PSCB as the reference point for all subsequent \"TSO authority\"\nchecking, once the session has started, and does not re-refer to RACF or\nUADS later for the TSO-specific things.  TSO only refers to RACF later,\nin the same way as a batch job does, to do \"RACF-specific things\".  For\nexample, a TSO session would consult RACF to verify whether it should\nhave access to a dataset, and so forth.\n\n      There are two free tools, available in the CBT MVS Utilities Tape\ncollection on File 300, that give you, the system doctor, the ability to\ncontrol the PSCB settings.  These are called LPSCB (\"look at the PSCB\")\nand CPSCB (\"change the PSCB\").  Of course, CPSCB must run as an\n\"authorized command\".  But LPSCB can be run by anyone, because all LPSCB\ndoes, is to read and display the contents of the PSCB control block.\nThe IBM macro which describes the contents of the PSCB is called\nIKJPSCB, and on an OS/390 2.10 system, IKJPSCB can be found in\nSYS1.MACLIB.  It is a very profitable activity to take ten minutes to\nlook at the IKJPSCB macro, and to see the kind of things in TSO, which\nthe PSCB controls.\n\n\nWHAT CLISTS AND REXX EXECS DO\n\n      I mentioned before, that TSO sessions can interact with the MVS\nOperating System in the same way, and to the same extent, that a batch\njob can.  This means that potentially, using TSO alone, you shouldn't\nhave to run batch jobs.  Avoiding batch jobs isn't always practical, but\nI have to explain how it is possible to do the task of a batch job,\nusing only TSO.\n\n      What are the parts of a batch job, as defined by its JCL?  First,\nthere's the JOB card.  The TSO equivalent of the JOB card is the session\nitself.  All the activities of that TSO session are included under its\nauspices, as though they were running as part of one job, which is the\nTSO session.  Next comes the EXEC card, which denotes the execution of a\nparticular program, and which defines the \"JOB STEP\".  Under TSO, the\nuser issues a \"CALL\" TSO command to execute a batch program, or the user\nissues any other TSO command, which is a load module that was\nspecifically designed to run under TSO.  The execution of such programs\nor commands under TSO, defines the equivalent of a job step.  Finally,\njust as files are defined to a batch job through the use of DD cards in\nthe JCL, so files are made known to a TSO session through the use of\nALLOC and ATTRIB TSO commands, which dynamically allocate any files\nneeded by the program to be run under the TSO session.  When these files\nare no longer needed to do the task (job step) at hand, the FREE command\nis executed against them, to dynamically deallocate them from the TSO\nsession.\n\n      The truth is, that it's hard to enter all the ALLOC commands and\nCALL commands necessary, every time you want to run a program under TSO,\nthe same way you would run it in batch.  It would be as if you had to\nretype all the JCL by hand, every time you wanted to run a program in\nbatch.  Under TSO, IBM made it possible to collect the TSO commands and\ndata, necessary to run a task, the same way you keep the JCL to run a\njob, in a file, and submit it.  This \"bundle of TSO commands\" to perform\na certain purpose, is called a CLIST, or \"Command List\".  You can either\nexecute the CLIST as a single sequential file, or you can execute it as\na member of a partitioned dataset, using the EXEC TSO command.  A\ntypical CLIST that simulates a batch job, would contain ALLOC commands\nto allocate files, and then it would contain a CALL command, to execute\na program that runs against the allocated files.  The program would then\nrun in the region of the TSO address space.  Outputs would be directed\nto the files previously defined by the ALLOC commands in the CLIST.\nFinally, at the end of program execution, the CLIST would issue FREE\nTSO commands against the allocated files, to make them available for\nothers to use.\n\n      Actually, CLISTs have access to an interactive programming\nlanguage, besides their just being vehicles to execute programs and\npre-allocate the files.  Using the CLIST programming language, you can\nexecute programs conditionally under the CLIST's control, and you can\ninsert PARM data into the programs conditionally, as well.  The CLIST\nlanguage, besides being suited to executing batch-type programs, is also\ntailored for executing TSO-specific programs, called TSO Commands.  All\nin all, CLIST files, executing under TSO, allow for much more\nflexibility and conditional execution, than batch programs do, with\ntheir COND statements in the EXEC cards.\n\n      But it doesn't stop there.  As good as the CLIST language is, in\nproviding programming flexibility to complicated chains of TSO command\nexecutions, its successor, the REXX language, is far better.  REXX is a\nfull-blown programming language, which can access and manipulate MVS\nstorage, and follow control block chains, as well as conditionally\ncalling programs to execute against files.  TSO in MVS, equipped with\nthe CLIST and REXX languages as well, provides very full capability of\ndoing all kinds of system processing and system manipulations.\n\n      Now you can see that TSO under MVS, is far more advanced than\nbeing just a system to store a stack of cards for job submission.\n\n\nTSO COMMANDS\n\n      \"TSO Commands\" are programs which have been designed specifically\nto run in a TSO environment.  TSO Commands are load modules, and they\nare executed by typing their actual name, during a \"raw TSO session\".\nThat is, if a TSO session is in READY mode, you execute a TSO command by\njust typing its name, and pressing ENTER.\n\n      IBM's ISPF developers have added a facility to execute TSO\nCommands from an ISPF command line, during an ISPF session running under\nTSO.  Under ISPF, you type the word \"TSO\" on the command line, and then\ntype the name of the TSO command afterwards.  The TSO command program\nthen uses the region available to the TSO session, and executes.\n\n      The feature which distiguishes a \"TSO Command\" program from any\nother executable load module, is that it expects Register 1, upon entry,\nto point to a TSO control block (created by the control program of the\nTSO session) called the CPPL (or Command Processor Parameter List).  The\nCPPL contains four address pointers, the first one points to the buffer\ncontaining the command itself (and possible parameters), called the\nCommand Buffer, and the other three point to the 3 TSO control blocks,\nthe UPT, the PSCB, and the ECT.  The CPPL is mapped by the macro IKJCPPL\nin SYS1.MACLIB.\n\n      What's important to know here, is that a TSO command program can\ndo anything that a batch program can do, and additionally, it is more\nsuited to running applications that interact with the terminal.  A user\ncan write TSO commands to do highly sophisticated specialized tasks,\nsuch as zapping disk storage interactively, changing the attributes of\nload modules, and browsing the contents of datasets in full screen mode.\nIf you have a large collection of such specialized TSO command programs,\ncombined with the availability of CLISTs and REXX, with their\nprogramming features, then the TSO environment then becomes a super\nmega-powerhouse to control and fix computer processing on the MVS\nsystem.\n\n\nTSO-IN-BATCH\n\n      In this discussion, I have to mention why you might want to run\na batch job, instead of doing all your work under TSO.  The problem with\nrunning a program under TSO, is that it usually ties up your terminal\nwhile it is executing.  For this reason, you would rather run a batch\njob, which quietly runs in its own address space, using general system\nresources, but it keeps your terminal free to do other work.\n\n      Under certain circumstances, you can get the best of both worlds,\nby running TSO as a batch job, called \"TSO-in-Batch\".  TSO-in-Batch is\nvery suitable for running long-executing TSO commands, which don't\nrequire a lot of user interaction.  Or TSO-in-Batch would come in handy\nif you're running a long succession of TSO commands, say several hundred\nof them, one after the other.\n\n      You run TSO-in-Batch by setting up a pseudo-TSO environment in a\nbatch region, using JCL.  The EXEC card executes the program IKJEFT01,\nwhich is the TSO control program.  DD cards that are required, are\nSYSTSPRT, to print (what would be) the terminal output, and SYSTSIN, to\nenter the TSO commands and their parms, which you want to run in the\nbatch job.  Additionally, you could specify the TSO commands to be run,\nin the PARM field of the EXEC card, when you're executing PGM=IKJEFT01.\n\n      When running a TSO-in-Batch job, you may need to specify other\nDD names, such as SYSPROC, to specify a CLIST library, or SYSEXEC, to\nspecify a pds containing REXX execs.  Additionally, if the programs\nthat you're executing require files, you allocate them using suitable\nDD cards in the IKJEFT01 step.  To execute TSO commands out of a load\nlibrary that isn't in the Link List or LPA List, you might include a\nSTEPLIB DD card in the JCL, to point to the load library needed.\n\n\nFINDING OUT MORE\n\n      You might want to ask where to find out more information, so you\ncan begin to exploit the vast capabilities of TSO as a productive MVS\nenvironment.  First, you can refer to the IBM CLIST and REXX books that\nare in the TSO collection for your release of MVS, OS/390, or z/OS.\nSecond, you can look at the CBT MVS Utilities Tape collection, available\non the Internet at the CBT Tape web site, to find and install some of\nthe many specialized TSO commands that can be found there.  Files 300,\n134, 182, 183, and 296 of the CBT Tape collection are especially\nsuitable for beginners, although advanced practitioners will gain from\nthose files as well.  Don't ignore the TSO/E Users Guide, which will\ntell you about basic IBM-supplied TSO commands which supply necessary\nservices.  TSO/E Customization contains valuable knowledge about how\nyour TSO environment is set up.  And finally, if you want to learn how\nto write TSO commands yourself, the TSO/E Programming Guide is the\nmanual for you.\n\n      I sincerely hope that all of you have gained some knowledge from\nthis month's article, even though it looks like it's coming from a very\nbasic viewpoint.  Experienced MVS practitioners will see a lot of depth\nthat is implicit in the subjects I've mentioned.  TSO is a vast world.\nUse it well!\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0112DE": {"ttr": 23048, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x05\\x01\\x02'/\\x01\\x02'/!4\\x01\\x14\\x01\\x14\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-09-29T00:00:00", "modifydate": "2002-09-29T21:34:05", "lines": 276, "newlines": 276, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         DECEMBER 2001\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@attglobal.net and/or sbgolob@aol.com.\nThe Online CBT Tape web site has its own URL.  However, it can also\nbe reached from the \"Members Only\" section of www.naspa.net .\n\n\nVIRTUAL TAPES\n\n      Today I'm going to talk about a subject that many of us\ncurrently aren't closely connected to.  But I can almost guarantee\nthat in the foreseeable future, even those of us who never heard of\nthis subject, will have to deal with it on a daily basis.\n\n      One often does not foresee the future.  You never know when a\n\"minor development on the outskirts of computing\" will make a deep,\nlasting impression and will have a permanent effect.  One of these\n\"minor developments\" is the use of \"virtual peripheral devices\" that\nare emulated by disk storage.  For example, if you are running MVS on\na P390 or a system that is similar in concept (such as Hercules), you\nhave defined \"tape drives\" and \"3380 or 3390 disk packs\" that are\nreally PC or OS/2 disk files.  Someone who has, for years, run MVS on\nlarge mainframe machines, has no exposure to these virtual devices.\nHowever, tape files that have been created as \"emulated tapes\", and\nwhich are really disk files, will soon be sitting at your doorstep,\nknocking on your door.\n\n      Please allow me to mention something else which relates to this\nsubject.  For years, I have seen misconceptions which people have had\nabout copying tape data.  Many (otherwise knowledgeable) folks feel\nthat IEBGENER is about the only tool you need, to copy tape files.\nThis (in my opinion, erroneous) idea, is based on the concept of a\n\"tape file\" as the principal entity you're handling, and not on the\nmore realistic idea of handling \"the entire tape\" as the principal\nentity.  A program such as COPYMODS (from File 229 of the CBT Tape\ncollection of free MVS utilities) copies, and handles, an entire tape,\nas though it were ONE object.  It doesn't matter if there are many\nhundreds of separate files on that tape--COPYMODS will deal with the\nentire tape as a unit, even while copying each file of it.  The newer\nversions of COPYMODS (currently at Level 047) can CHANGE the copied\ntapes in various ways, such as altering the Volume Label, but in\nconcept, a program like COPYMODS will handle an entire tape as though\nit were one object, even with its new bells and whistles that can alter\nthe tape label contents.\n\n      Why am I bringing up this apparent digression?  Because it\npictures the idea of an entire tape, with all its files, as ONE object,\nand not merely as a COLLECTION of the possibly large number of FILES\nthat are contained in that tape.\n\n      The idea of a \"virtual tape\" as a disk file whose scope\nencompasses an entire tape from end to end, as ONE object, is about\nto burst on the MVS scene.\n\n\nCurrent Implementations of Tapes as Disk Files - the VTS\n\n      At this time, many installations are installing Virtual Tape\nSystems (VTS boxes).  These are really separate computers, to be\nattached to an MVS system, and they act as though they are large\nlibraries of tape volumes.  The devices employ large amounts of real\nmemory and disk storage, and they contain backup tape robots, to be used\nwhen the memory and disk storage overflow.  The very idea of a Virtual\nTape System is to simulate tape mounts with disk files.  If a Virtual\nTape System is hooked up to MVS, and a job calls for a tape mount on it,\nthe \"tape\" is really a disk file, unless it has been archived.\n\n      The way Virtual Tape Systems are constructed, we, as MVS users,\nhave no access to the actual file structure of the \"tape volume\" as a\ndisk file.  We only care about that VTS \"tape\" as though it were really\na tape.  However, the P390 \"emulated tapes\" are an entirely different\nstory.  It is possible, through an understanding of the file structure\nof the disk file which emulates the tape, to be able to transport that\nfile to other MVS systems, and even to create a \"real tape\" on a tape\ndrive, from it.\n\n      The rest of this column will describe the \"AWS\" disk file format\nwhich represents an entire tape on disk.\n\n\nThe AWS Disk Format of an Entire Tape\n\n      Tapes are by nature sequential.  They contain blocks of data,\nwhich are organized into files.  To represent a tape on disk, you must\nknow when a file begins, when each block of data begins and ends, and\nwhen each file ends.  Suppose you picture the disk representation of a\ntape.  It has to be a sequential file.  But the beginning and end of\nthe tape files, as well as the blocks of data which comprise them, must\nbe clearly marked.  In the AWS Tape format on disk, the marking is done\nby means of 6-byte headers, that are placed in between the blocks and\nfiles of \"tape\" data.\n\n      The concept of the AWS Tape header format on disk is very easy\nto grasp.  Every header contains the number of bytes in the data block\nto follow (it might be zero), the number of bytes in the previous\nblock (which also might be zero), and an indicator whether this header\nmarks the end of a file.  If that indicator is not on, then we are at\nthe beginning, or in the middle, of a file.  If it is on, then we are\nat the end of a file.  Tape Labels are themselves only files on a\ntape, which \"sandwich\" the data files.  Therefore, Standard-Labeled\ntapes, and Non-Labeled tapes can both be represented in this AWS format.\nConceptually, that's really all there is to it.\n\n      But there is one more small idea which contributes to the picture.\nOn a PC disk, or as an OS/2 file, the AWS-format \"tape\" is conceptually\none continuous stream of data, without blocks.  But on an MVS system,\nevery file has to be logically broken into blocks.  In normal MVS data\nmanagement, there's no such thing as a logically continuous stream of\ndata which is arbitrarily long.  But on a PC or OS/2 disk file, even\nthough the data is broken up into hardware sectors, the file is\nlogically one big continuous piece.\n\n      So a small barrier has to be crossed, when you are thinking of\n\"porting\" AWS Tape data on disk, from a PC or OS/2 file to an MVS\nsystem.  You have to arbitrarily break the data into blocks.\n\n      Actually, when you upload any PC data to an MVS system, you have\nthe same situation.  Usually, the FTP or TSO administrator (when\nsetting up default IND$FILE uploads) makes a decision as to whether the\ndefault MVS file after an upload, will be FB or VB, and how big the\nLRECL and BLKSIZE will be.  You can override their decisions, but some\nsuch decision will have to be made.  The \"blocked\" nature of MVS data,\nforces you to make some decision as to how to re-block any uploaded\ndata.\n\n      Therefore, an AWS \"tape\" file on disk, when uploaded to an MVS\nsystem, has to be artificially re-blocked.  Some people (like Brandon\nHill in his AWSUTIL program - File 477 of the CBT Tape) have decided\nto block the data with RECFM=VB.  I have decided, with my new set of\nAWS utilities (File 533 of the CBT Tape) to block the data as card-image\nfiles:  RECFM=FB and LRECL=80, with any convenient blocksize.  If you\nFTP the MVS data back down to a PC file, you again can get a usable\nand \"continuous\" PC file.  This MVS re-blocking only \"means something\"\nif the data is to be further manipulated on an MVS system.\n\n\nSpecifics of the AWS Tape format\n\n      Now we'll talk about the specific structure of the AWS headers,\nwhich delimit and describe the tape \"blocks\" and \"files\" in the AWS disk\nrepresentation of a tape.  Each six-byte AWS header is divided into 3\ntwo-byte sections.  And the first six-bytes of any AWS \"tape\" file, is\nalways the first header, which contains enough information to find all\nthe rest of the AWS headers in the file.\n\n      The first two-byte section of the AWS header contains the number\nof bytes to be found in the next block of tape data.  Since this is a\ntwo-byte field, the number contained in it, can be as large as 65535,\nor 64K bytes.  But there is one hitch.  The number is not a normal\nhalfword quantity.  Instead, it is backwards, in the famous \"Backwards\nIntel Format\" (or BIF).\n\n      I'll explain.  Suppose we want this field to represent the number\n32720, to tell us that the next block of \"tape data\" will contain 32720\nbytes.  The hexadecimal representation of 32720 is X'7FD0'.  But the\nfirst halfword in the AWS header will not contain X'7FD0'.  Instead, the\ntwo bytes will be backwards, and the field will contain X'D07F'.  This\nis confusing to us MVS'ers who have never dealt with Intel or Microsoft\nprogramming.  Therefore, any MVS-based program which deals with the\nnumeric quantity contained in this two-byte header field, must first\nreverse the two bytes.  BIF is ubiquitous here.\n\n      The second two-byte field in the AWS header, contains the number\nof bytes of tape data contained in the previous \"block\".  Of course, if\nour header is at the beginning of a file, there are no previous blocks\nin this file, and the second field will contain X'0000'.  Remember that\nthis second two-byte field is also in BIF format, and any MVS program\ndealing with the quantity, will have to reverse the two bytes.\n\n      The third two-byte field is the simplest of all, in the current\nimplementation of AWS tape format.  The last 3 hex numbers have to be\nzeros, and the first number is either a X'A' or a X'4'.  A X'A' means\nthat this header does not mark the end of a file.  A X'4' means that\nis does mark the end of a file.  Officially, in the description of the\nAWS tape format, there's a bit more detail, to cover data chunks that\nare smaller than the size of the tape blocks.  But practically, that's\nall there is to it!\n\n\nSo How Does It Work?\n\n      Let's look at the first few headers of a Standard-Labeled (SL) AWS\ntape.  We'll start with the representation of the first header labels at\nthe beginning of the tape, including the VOL1 label, the HDR1 label, and\nthe HDR2 label, each of which is an 80-byte record.  These three 80-byte\nrecords constitute the first actual \"file\" of an SL tape.\n\n      The sequence of AWS header records describing this first label\nfile is:\n\n      X'50000000A000' , then X'50005000A000' , then X'50005000A000' ,\nthen X'000050004000' .\n\n      Let's interpret:  The first field of the first header contains\nX'5000'.  This is BIF format, so the bytes have to be reversed, to make\nX'0050', which is decimal 80.  That tells us that the following block\n(really the VOL1 label) will contain 80 records.  The second field of\nthe first header contains X'0000', which reversed, is still X'0000', so\nwe know that no file data has preceded this header.  The third field is\nX'A000', so we know we're not at the end of the file yet.  After\nadvancing 80 bytes past the end of the first header, we come to the\nsecond header.\n\n      The second header (really before the HDR1 label) contains the\nquantity X'50005000A000'.  First field X'5000', when reversed, gives\nX'0050', telling us that another 80 byte block of data will follow this\nheader.  The second field X'5000', which when reversed is X'0050', lets\nus know that the previous block of data contained 80 bytes also.\nFinally, the X'A000' in the third field, tells us that we're not at\nend-of-file yet.   The first field has told us to advance 80 bytes past\nthe end of this header, to come to the next header.\n\n      The third header in our sequence of four, contains the same\nquantity as the second header, namely X'50005000A000'.  This tells us\nthat the block which follows (the HDR2 label) will contain 80 bytes,\nthe previous block (the HDR1 label) contained 80 bytes too, and the\nX'A000' in the third field tells us that we are still not at\nend-of-file.\n\n      Finally, after advancing another 80 bytes, which the first field\nin the third header has ordered us to do, we come to the fourth header.\nThis fourth header contains X'000050004000'.  Its first field, X'0000',\nwhen reversed, still X'0000', tells us that zero bytes of data will\nfollow this header.  The second field, X'5000', which reversed, is\nX'0050' or decimal 80, tells us that an 80-byte block has preceded this\nheader.  Finally, the X'4000' in the third field, informs us that we\nhave reached the end of this file.  Since the first field of this\nheader contained X'0000', we expect another header to immediately follow\nthis header, in the AWS tape file.\n\n\nSome Practical Correspondences\n\n      Now that we've seen an entire file in AWS format, we can figure\nout what the headers signify to us, in conventional tape terms.  Let's\nfirst consider that we're writing this tape, which the AWS headers are\ndescribing, to a real tape drive.\n\n      First, whenever there's a X'4000' in the third field of a header,\nthat means that we write out the last block of tape data (on a real\ntape) and then we write a tape mark.  If the third field is X'A000', but\nthe second field is not zeros, then we write out the number of bytes in\nthe second field, without writing a tape mark.  Finally, if the second\nfield is zeros, and the first field is not, we advance the tape by the\n(reversed) quantity in the first field, reading in that number of bytes\nof data.  No writing is done yet.\n\n      Now, let's imagine that we're reading this tape.  The first header\ntells us that we must look into the first field.  If that is not zero,\nthen we reverse the two bytes, and read forward, by the number of bytes\nthus described, coming to the second header.  If the third field in the\nsecond header is X'4000', we are at end-of-file.  Otherwise, we look at\nthe second field in the second header.  That should correspond with the\nnumber of bytes we just read.  Finally the first field in the second\nheader tells us, that we must advance that number of additional bytes of\ndata, to get to the third header, and so on.\n\n      I hope that this month's topic has opened your eyes to the\nbeginning of a new era in \"tape\" processing.  Files describing an\nentire tape, can now be put on disk.  On an MVS system, whether these\nfiles be \"folded over\" in FB-80 format (as in CBT File 533), or VB\nformat (as in CBT File 477), the data can still be dealt with, as\ntape data.  I have written a program to convert the FB-80 format data\ninto a real tape on an MVS system (see File 533 - program VTT2TAPE).\nI sincerely hope that you will all expand your minds to include these\nnew concepts in your thinking.  Best of everything!  See you next\nmonth.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM011201": {"ttr": 23297, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\t\\x01\\x11\\x14O\\x01\\x11\\x14O\\x08E\\x00\\xae\\x00\\xae\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-05-24T00:00:00", "modifydate": "2011-05-24T08:45:09", "lines": 174, "newlines": 174, "modlines": 0, "user": "SBGOLOB"}, "text": "\nThis is IBM doc for the AWSMOUNT command on the P/390 and containing\nthe specifications for the format of AWS virtual tapes.\n\n==================================\n\nAWSTAPE emulates a 3803/3420 & 3422 tapes using a OS/2 disk file.  The\nfile can reside on either disk or diskette, which can be formatted for\neither the HPFS or FAT file system.  Unlike P/390 DASD files, the\nconfigurator does not preallocate tape files.  The AWSTAPE device\nmanager automatically creates them when the S/390 operating system\nwrites data to the device.\n\nDEVICE TYPE:  3420 or 3422 (Control unit 3803)\n============\n\nCONFIGURING a 3420 or 3422\n==========================\n\nTo configure a 3420 or 3422 emulated tape, go to the Configurator F2\n\"UPDATE SYSTEM DEVICES\" menu and enter the real address of a 3420 or\n3422 tape device in the Addr field, the MGR code for AWSTAPE in the Mgr\nfield, and a fully qualified OS/2 filename in the FN/P field.\nFor example:\n\n      Addr  Device                         Mgr    FN/P\n      ------------------------------------------------------------------\n      >580   >3422                         >E   >C:\\TAPE\\IPLDDR.580\n\nNote: VM/ESA 2.1 or above requires the tape to be specified as 3422\n      in DEVMAP. Otherwise you must use the CP SET RDEV to change the\n      device characteristics to 3422 before varying the tape online.\n\nA maximum of 15 awstape devices can be define when they are in a\ncontiguous address range.  Fewer devices can be defined in discontigous\nranges.  The low order byte of the unit address of any tapes defined\nmust be unique:  You cannot have a 583 and 593 both as awstape devices.\n\nTHE OS/2 AWSMOUNT COMMAND\n=========================\n\nYou can use the OS/2 AWSMOUNT command to change the filename that is\nassociated with the emulated tape or to issue Rewind and Rewind Unload\ncommands. See AWSMOUNT.DOC or enter AWSMOUNT ? from an OS/2 prompt.\n\n\nTHE VM MOUNT COMMAND\n====================\n\nTo change the filename while VM is running, use the CMS MOUNT command.\nAttach the tape to your userid and issue the mount command:\n\n   MOUNT 181 (QUERY        to display the name of the current tape file\n   MOUNT 181 (STACK        to put the name of the current file on the stack\n   MOUNT 181 pcfilename    to change the name\nEnter HELP MOUNT from a P/390 CMS session for additional information.\n\n\nTHE VSE TMOUNT COMMAND\n======================\nThe TMOUNT command is a program that can be executed in a VSE/ESA batch\npartition to either query the existing filename or mount a new emulated\ntape or disk.\n\nThe TMOUNT program is supplied on the VSE/ESA Starter System CD-ROM. It\ncan be installed onto the VSE/ESA system by copying the member to the OS/2\ndirectory set up by you for the emulated 2540 card reader and starting\na VSE/POWER reader task to that device.\n\nThe JCL required to use the TMOUNT program to query the existing file is:\n\n    // ASSGN SYS004,581\n    // EXEC TMOUNT,SIZE=AUTO,PARM='581 (QUERY'\nThe above example assumes an emulated tape drive at address 581.\n\nThe JCL required to use the TMOUNT program to mount a new file is:\n\n    // ASSGN SYS004,581\n    // EXEC TMOUNT,SIZE=AUTO,PARM='581 D:\\VSE\\MYTAPE.581'\nThe above example assumes an emulated tape drive at address 581. The\nfilename parameter is limited to 17 characters maximum.\n\n\nSPECIAL EMULATION CONSIDERATIONS\n================================\n\nThe PC file is opened when data is read or written to the tape, or when tape\npositioning commands like FORWARD SPACE FILE or FORWARD SPACE RECORD are issued.\nThe PC file is closed when a REWIND or REWIND UNLOAD is issued.  If the PC file\nhas the read/only attribute set, it appears as read only (no ring) to the P/390.\n\nIf the file is on a diskette, be sure to rewind or DETACH the tape before\nremoving the diskette.  This insures that all the information has been written\nand the file is closed.\n\nRewind Unload\n-------------\nA REWIND UNLOAD command does not actually unload or demount the tape.  It sets\nthe sense bits so that a SENSE command reports 'intervention required', as do\nREAD or WRITE commands.  However, if you issue other tape commands such as\nREWIND or FSF, they succeed.  The tape status is reset, and subsequent WRITE or\nREAD commands proceed normally.  This difference from real 3420 operation means\nthat a tape can be detached from one userid and reattached for immediate reuse\nby another userid.\n\nRe-writing a tape\n-----------------\nWhen data is written to the middle of an emulated tape, any data following it is\nerased.  The PC file representing the tape is truncated.  This allows the file\nto grow and shrink as the 'tape' is reused.  Thus, programs that depend on the\nability to rewrite records or files on a tape will do not work with the P/390\n3420 tape emulator.\n\nRead Backwards\n--------------\nThe P/390 I/O subsystem does not support the READ BACKWARDS CCW unless\nthe SKIP bit is on.  This may affect certain tape utility programs.  It\napplies to all tapes, whether emulated, SCSI-attached, or Bus & Tag\nChannel-attached.\n\n\nERRORS\n======\n\nThe most common error is 'equipment check', which is set if the file mounted is\nnot in AWSTAPE format.  In other words, you probably mounted the wrong file.  If\nthat's not the case, then the file has been damaged and cannot be used with\nAWSTAPE.\n\nPC TAPE FILE FORMAT\n===================\n\nThis section defines the format of the PC file created by the 3420 emulator.\nYou do not need to read further unless you need to understand details about how\nthe file is structured.\n\nThe tape file consists of a series blocks.  Each block begins with a 6 byte\nheader followed by a (possibly null) data block.  The header block specifies the\nlength of the data block.  Currently, data blocks must not be longer than 4096\nbytes.  These data blocks are not the same as 'tape' records.\n\nThe header is defined as follows:\n\n     DCL 1 T_Header,\n           2 t_size  fixed(16),  /* Size of the following block */\n           2 t_psize fixed(16),  /* Size of the previous block  */\n           2 t_flags,            /* Control flags.              */\n             3 t_Newrec  bit,    /* start of new record         */\n             3 t_eof     bit,    /* end-of-file mark            */\n             3 t_Endrec  bit,    /* End of a record             */\n             3 *         bit,    /* Must be zero                */\n             3 *         bit,    /* Reserved                    */\n             3 reserved bit(11); /* Must be zero                */\n\nT_Size and T_PSize are two byte integers in PC format.  They currently must be\nless than or equal to 4096 bytes (this is the maximum size currently supported.\nDon't depend on it not getting larger).  Because tape records can be longer than\n4096, T_Newrec and T_Endrec define the mapping of these internal tape blocks to\nemulated tape records.\n\nIf both Newrec and Endrec are on, the record is entirely within one block -- it\nis t_size bytes long.  If a record is longer than one block but fits in two\nblocks, then the first has T_Newrec set, and the second has T_endrec set.  If\nthe record is three blocks or longer, the middle blocks have both newrec and\nendrec turned off.\n\nT_EOF is set for a filemark; if it is on, Newrec and Endrec should be off and\nT_size should be zero.  An EOF block should be followed by header block, or\nanother eof block, or it should be at the end of the file.\n\nT_size and T_Psize do not include the length of the header block.  Thus, the\nfirst block on the tape has T-Psize = 0.  An EOF block has T_size equal to zero,\nand the second of two EOF blocks in a row has both T_size and T_Psize = 0\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0201JA": {"ttr": 23301, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x19\\x01\\x013\\x7f\\x01\\x013\\x9f\\x116\\x00\\xdc\\x00\\xd6\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2001-12-03T00:00:00", "modifydate": "2001-12-05T11:36:19", "lines": 220, "newlines": 214, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          JANUARY 2002\n\nNote:  The section on \"MVS Zipping Tools\" is not copyrighted by\n       \"Technical Support\" magazine or by NaSPA, and does not\n       reflect their opinion in any way.  It is not to be published\n       in the magazine (but it does remain my personal, and very\n       strong, opinion).\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@attglobal.net and/or sbgolob@aol.com.\nThe Online CBT Tape web site has its own URL.  However, it can also\nbe reached from the \"Members Only\" section of www.naspa.net .\n\n\nDOES SOFTWARE USE DEPEND ON SOFTWARE COST?\n\n      Today I'm going to write about something that most people don't\ntalk about very much.  I'm not going attempt to say many \"authoritative\nthings\", but I do want to contribute some of my own thoughts.  These\nideas might serve to help people save their installations money, or at\nleast, they might get us thinking in different directions.  Maybe, in\nsome way, they'll help folks make better use of both the \"free software\"\nand the \"vendor software\" which has already been installed.\n\n      It's my point of view that software tools should be used, as much\nas possible, and as productively as possible.  As a longtime sysprog,\nI've been exposed to a lot of vendor software, and as the proprietor of\nthe CBT Tape collection of free software, I've been exposed to a lot of\nthat, too.  My main concern is helping the most people to get the most\nmileage out of their software tools.  That's why I've made these very\npersonal observations.  I always ask:  \"If a tool is installed, how much\nare the people using it?\"  Today, I'm also asking the question:  \"Is\nthere any correlation between the cost of MVS software, how many people\nare using it, and how often they are using it?\"  It's a hard question,\nand I just have some isolated thoughts.  But I think that after so many\nyears of thinking them, they are worth mentioning.\n\n      Just about all MVS installations, of course, buy system and\napplication software from either IBM or from other vendors.  It happens\nto be true that in many cases, the software is under-used.  That's why\nyou have \"software inventory packages\" which monitor the use of the\nother software packages, within an installation.  These software\ninventory products are used to help an installation's managers determine\nif a vendor software product should be continued, or whether it should\nbe dropped.\n\n      Even if a product is free, such as software products which come\nfrom the huge CBT Tape collection, it still helps to know if the product\nis being used.  While the free product is not being paid for, it still\nmight be \"cluttering up the software table\", and sometimes a decision\nhas to be made about it, whether to keep it in the main libraries, or to\nmove it off to the side.\n\n      There are considerations other than just the volume of software\nuse, that can relate to software cost.  I'll give one example.  IBM has\ncreated a set of \"structured macros\" for assembler language coding,\nwhich they have included in their optional HLASM Toolkit.  The HLASM\nToolkit is a separately paid-for add-on to the High Level Assembler.\nThese macros add an IF-THEN-ELSE capability to assembler language, and\nalso contribute DO WHILE structures and the like.  It is obvious that\nthe set of macros is potentially very useful.  However, I, for one,\nwould be afraid to write any code with them.  Why?\n\n      The answer is, that if a person codes Assembler with these macros,\nthe source code will not be portable.  Because of IBM's packaging\nstructure for the macros, including them in the optional Toolkit,\ninstead of keeping them with the base HLASM product which everybody has,\nany source code that uses this set of macros can only be assembled in an\ninstallation that has licensed the Toolkit.  You can't take the source\ncode with you, or send it out to assemble it at another installation,\nunless the HLASM Toolkit is there too.  Thus, IBM's packaging policy for\nthis useful set of macros has effectively curtailed their use, in a\nvery major way.\n\n      My suggestion to remedy that situation, and to make the people\nless afraid to use this tool, would be to include the \"structured macro\nset\" in the base HLASM product, and to spread its development cost among\nthe much larger base of purchasers of \"base HLASM\", which everyone needs\nto have.  Then, any code that uses these macros, will be truly portable\nin today's MVS environment.  And people would be far more inclined to\nstart using these IBM macros, in writing their code.  People really\nprefer to use software that is perceived as \"standard IBM\", and it's\nabout time that IBM started realizing that too!\n\n      Meanwhile, as an alternative to using IBM's macros, people could\ntry some of the free sets of structured macros, which appear in the CBT\nTape collection.  I've made a preliminary search of CBT Tape Files which\nmight contain similar structured macros that are free, and of course,\n\"portable\".  These are Files 024, 107, 119, 304, 316, 341, 352, 438, and\n471.  You're welcome to look at these sets of macros and evaluate if\nthey would be helpful for your coding efforts.\n\n\nSOFTWARE DEVELOPMENT COSTS\n\n      People have to pay bills.  Someone who develops software for a\nliving, has to cover expenses, so the software has to be charged for.\nIt would also be nice to make a profit.  The profit motive has driven\nmany businesses, all of the world, for as long as anyone remembers.\n\n      Now let's look at \"free software\", which is the other side of the\ncoin.  How does free software get developed?  That's a little different.\n\n      Usually, free software is developed by people whose primary job is\nnot to write code for a living.  They get their paycheck from somewhere\nelse, like doing MVS Systems Programming.  In their work, they'll need a\nsoftware tool, so they code something up, and usually their installation\nneeds it too.  So the installation doesn't care that the programmer\ngives away the tool to somebody else also, because that installation is\nnot in the software development business.  And this is the origin of\nmany of the free MVS software tools in the world.  People share their\nuseful software creations with others, provided they're not in the\nprimary business of writing the stuff to pay their own expenses.\n\n      With this in mind, I'm going to give another example about the\nusage of a tool depending on its cost.  This example is of a completely\ndifferent nature than anything we've mentioned before.\n\n\nMVS ZIPPING TOOLS\n\n      Practically everyone uses PKZIP or WinZIP or some other file\ncompression tool on the PC, on UNIX systems, or on OS/2.  On those\nsystems, the compression tool often is freeware, Shareware, or may cost\na maximum of perhaps 50 dollars.  Therefore, zipping and unzipping file\ncompression tools on the PC, are used almost universally, by literally\nbillions of computer users.\n\n      Now consider the \"zip\" situation on MVS.  At a few previous shops,\nI looked into it.  After inquiring at one software manufacturer, I found\nthat for a very moderate-sized shop, their cost for what we wanted to\ndo, amounted to almost forty thousand dollars!  I get to talking with\nMVS sysprogs in a lot of different places.  It's no wonder, that only a\nvery small percentage of MVS shops have a mainframe zipping package!\nIt's the cost.  And it's the fact that this manufacturer seems to create\nthe impression that if you want to get an MVS zipping tool, you have to\ncome to them.\n\n      I looked into alternatives, and found that it's not true.  Another\nsoftware manufacturer, in Australia, has a perfectly fine MVS zipping\ntool that (with a little bothering from me) they made completely\ncompatible with the first tool.  (I asked for FB-80 zipped files on MVS,\nand even though they had previously defaulted to VB, they whipped up the\nFB PTF over one weekend.)  The Australian manufacturer charged eight\nthousand dollars for our-sized installation, all extras included.  This\nwas affordable, and one more MVS installation had an MVS zipping tool in\nhouse!\n\n      My point is not to cause any manufacturer a loss of business.  I\nfeel that the more expensive manufacturer is not going to lose any of\nits customers, because they rely on its solid reputation, and if those\ncustomers bought the product in the first place, they are willing to pay\nfor the fine service which that company offers.  But my point is, that\nit would help if this kind of software, which is almost universally used\non other systems, were cheaper on MVS.  More shops would use it.\n\n      In this example, it could very well be cheaper.  For instance, if\na lot of the other shops (that don't have an MVS zipping tool) would\nlook into the Australian alternative (they also provide very decent\nservice, as I've mentioned), a far higher percentage of MVS shops would\nhave an MVS zipping tool in house!  This is another, completely\ndifferent way in which software usage levels can depend on cost.\nThere'd be more customers!\n\n      By the way, there's also a third MVS \"zipping\" alternative I know\nof, which is completely free, called InfoZIP, and while I haven't tried\nit myself, people tell me that it's also pretty good, though not at the\nlevel of the other two.\n\n\nMORE THOUGHTS ON THE USAGE OF SOFTWARE\n\n      I've subjectively observed, over the years, that if a computer\ninstallation has paid a lot of money for a software product, they\ngenerally will make sure to use it.  There's probably a good reason they\nordered it in the first place.  I've seen a few examples where this was\nnot true, and the company was wasting their money, but I don't think it\nhappens too often.  So I can generally say, that when a company spends a\nlot of money for software, they will use the software.\n\n      What about the other side of the coin--free software?  Then, it\nreally depends.  Many people will install some free software, just\nbecause they're curious.  The stuff is free and available, and after the\nperson has examined it and fulfilled his curiosity, he (or she) might\nnot feel there's a need to use it anymore.  On the other hand, some free\nsoftware offering might fill a real need, and it'll be used over and\nover again, as much as the \"pay software\" is.  And of course, there are\nall of the \"middle cases\", in which the free software will be used\neither very occasionally, or quite often.\n\n      I guess I have a comment about inexpensive vendor software too.\nSome of that stuff is very good.  My take on it, is that if the\ninstallation bought it for a need, and it fills the need, it'll\ngenerally be exercised quite a lot.  If it doesn't perform completely up\nto expectations, the site will tend to ignore it, or they may only use\nit occasionally.  Since they didn't spend a lot of money on it, they\ndon't care so much.  So with regard to \"inexpensive software\", I think\nthat the usage levels depend directly on the software's perfomance, and\nthe installation's real need for it.  This is a case where we really\nfind some genuine correlations.\n\n      I trust that this month's column, different from most of the\nothers, will still be helpful, because it will get us to think in new\ndirections.  In our working lives, we all have installed a lot of\nsoftware.  We're all kind of \"flooded\" with our installations' software\ninventory.  We all ask ourselves the questions:  \"Why do we spend time\nusing this package and not that one?  Why do we use this feature (of a\ncertain package) and not that one?\"  Once we start providing ourselves\nwith coherent answers to this category of question, we'll start making\nbetter use of our time.  Good luck to all of you, and I hope to be\nseeing you again next month!\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0202FE": {"ttr": 23306, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x19\\x01\\x02\\x01\\x0f\\x01\\x02\\x01\\x0f\\x15\\x08\\x00\\xe2\\x00\\xe2\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-01-10T00:00:00", "modifydate": "2002-01-10T15:08:19", "lines": 226, "newlines": 226, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         FEBRUARY 2002\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@attglobal.net and/or sbgolob@aol.com.\nThe Online CBT Tape web site has its own URL.  However, it can also\nbe reached from the \"Members Only\" section of www.naspa.net .\n\n\nTHE NEW \"REVIEW\"\n\n      Today I'm going to talk about a program that's been here for over\n20 years, but there's a good reason to deal with it now.  First, the\nprogram is constantly being improved upon by its current author.\nSecond, not everybody knows about it, as I discovered yesterday in a\ndiscussion with a fellow longtime systems programmer.\n\n      This program is a TSO command named REVIEW, and its primary use is\nfor browsing datasets.  REVIEW's original author is Bill Godfrey, who\nhas been a tremendous pioneer in developing software tools for MVS\nsystems programmers to use.  Bill prides himself on having started a lot\nof the development paths for important tools many of us now take for\ngranted, and he is happy when the programs he's developed, are improved\nupon by others.\n\n      Bill Godfrey's latest version of REVIEW was about 4000 lines, in\nsource code.  Greg Price (starting back in 1984) picked up the cudgel,\nand the source code for REVIEW, in Greg's capable hands, now is\napproximately 30000 lines long.  It's very obvious, to anyone who looks\nat the source code, that the REVIEW command, in its current incarnation,\ncan do an awful lot of things.  It would therefore be very profitable\nfor us, to get better acquainted with this extremely capable tool.\n\n      By the way, Greg Price is also the author of a fine MVS monitor\nproduct, which is a vendor product, called IMON, that runs under TSO,\nand which does not need ISPF.  I have profitably used Greg's clever and\noriginal IMON product for many years.  Although both REVIEW and IMON do\nnot need ISPF, REVIEW can take advantage of ISPF if it is present in the\nenvironment.  To find out more about IMON, and REVIEW, go to Greg's URL:\nhttp://www.prycroft6.com.au\n\n\nA FEW OF THE CAPABILITIES OF REVIEW\n\n      REVIEW is a TSO command which does not need ISPF, but if you are\ninvoking REVIEW under ISPF, REVIEW will use the ISPF EDIT and BROWSE\nfacilities if they are asked for.  The latest release of REVIEW as of\nthis writing (Release 35.4) will accept EDIT and BROWSE primary commands\nfrom the command line of a REVIEW screen, if REVIEW happens to have been\ninvoked in an ISPF environment.  This is a significant extra feature,\nrecently added to REVIEW, and it will prove to be very handy to have.\n\n      REVIEW now displays a member list, if pointed to a partitioned\ndataset (PDS) or a PDSE, and it can look at program objects stored in a\nPDSE.  REVIEW can look at, and DELINK ordinary load modules, with the\nhelp of David Noon's DELINKI program that it calls.  REVIEW can also be\nused to look at VSAM files, HFS files, DB2 tables, and it has IMS\nbrowsing capability.  REVIEW can sequentialize (=OFFLOAD) members of a\npds, and load modules, into a sequential output dataset.  And I haven't\neven scratched the surface of REVIEW's new powers.\n\n      REVIEW has its famous capability of browsing and formatting SMF\nrecords.  This capability enables the system programmer, or anyone else\nwith the appropriate authority, to look at SMF records on disk or tape,\nand pick out only the records of a certain type, or which have been\ngenerated by a certain userid.  In turn, it becomes very easy to find\nout who deleted a dataset and when, to pick one example of this powerful\nuse of the REVIEW command.\n\n      REVIEW can access files by way of their ddnames, if you invoke\nit by saying REVIEW ddname FILE, using the extra keyword of FILE.  When\nused this way, REVIEW will also access file concatenations, and will\ndisplay combined member names and their concatenation numbers.  You can\nuse this capability of REVIEW to explore the ISPF file concatenations\nallocated to your TSO session, and for other similar purposes.\n\n\n(NOT SO) BASICS OF \"REVIEW\"\n\n      As we said before, the simple way to invoke REVIEW is to say\n(under TSO) REVIEW dataset.name .  Once this is done, you get a full\nscreen view of the contents of the beginning of the dataset.  You can\nenter the HEX command at the command line on top of the fullscreen\ndisplay.  This will give a HEX display of the data, spread horizonatally\nand not vertically, making it different from the HEX display of ISPF\nBROWSE.  All this is simple enough.\n\n      REVIEW offers some basic advantages over ISPF BROWSE, for large\ndatasets.  If the file has record format FB, so that its end can be\ncomputed with some accuracy, REVIEW will advance the file to the BOTTOM\nor by a large number of lines, almost instantaneously.  It does this by\ncalculating the TTR of the dataset where, say the millionth line would\nbe (if that's where you told it to advance to), and it'll go there right\naway.  If the record format of the large dataset is variable (VB), so\nthat REVIEW can't calculate the destination easily, REVIEW will still\noffer an advantage over ISPF BROWSE.  REVIEW does the following:\nSuppose you're looking at a dataset, and you told REVIEW to go down\n100000 lines.  REVIEW is taking it's time, and you want to know how far\nit got.  Simply press RESET and PA1, and REVIEW will stop in its tracks,\ntelling you exactly how far it got.  This is also a tremendous advantage\nover ISPF BROWSE, when looking at large datasets, such as PTF files and\nSMF datasets.\n\n      REVIEW offers other advantages over ISPF BROWSE, as I've implied.\nFor example, you don't have the 9999 line restriction when you're going\nup or down.  You can tell REVIEW to go down 10 million lines (DOWN\n10000000) and it'll do it.  If you learn how to use TTRs of a dataset,\nto tell you a record's position in the dataset, you can use REVIEW's\nNEWTOP subcommand to start looking at the dataset from a certain TTR,\nrather than from the TOP.  That has an advantage when trying to browse\ndeleted members of a PDS, or when trying to pass an I/O error when\nrescuing data from a defective dataset.  I can't begin to describe the\nmany \"extra\" things you can do with REVIEW over ISPF BROWSE, but I can\nrefer you to REVIEW's HELP member, that comes with its \"install pds\".\n\n      By the way, while we're talking about REVIEW's TSO HELP member,\nI have to mention that REVIEW itself has a program alias called HEL,\nwhich is a fullscreen TSO SYSHELP browser.  HEL is a TSO command which\nsearches your TSO session's SYSHELP ddanme concatenation for the HELP\nmember that you're looking for.  And when you use the HEL command, you\nhave fullscreen FIND, UP, DOWN, and other capabilities, which will\nassist you in locating the information about the TSO command and its\nsubcommands which you'll need, especially in large HELP members.\n\n\nHOW CAN YOU GET \"REVIEW\"\n\n      You can download REVIEW directly from Greg Price's web site:\nhttp://www.prycroft6.com.au , or you can get it from the enormous CBT\nTape collection, where REVIEW is available as part of File 134.  Load\nmodules for REVIEW and its related programs, can be found in the CBT\nTape collection, on File 135.  The CBT Tape collection is entirely free\nand available to everyone.  One way you can get to the CBT Tape URL, is\nthrough NaSPA's web site, www.naspa.com .\n\n      I would suggest grabbing the REVIEW load modules from File 135,\nlooking at everything that starts with REV** and at HEL, and at DELINKI,\nand copying them all into a load library which is accessible to your TSO\nsession, either by way of ISPLLIB, or STEPLIB, or in the Link List.\nThen, I'd look at two documents to help get started.  The first is the\nHELP member for REVIEW in File 134, called REVIEW#.  If you copy this\nmember into one of the libraries in your SYSHELP concatenation, and\nrename it as REVIEW, you can then issue the TSO command:  HEL REVIEW\nto look at the contents of this member.\n\n      The next thing I'd recommend, is to look at the member called\nREVNOTES, which describes recent improvements made to the REVIEW command\nby Greg Price, and which will teach you a lot of the new things that\nGreg has recently put in.  If you want to learn the details about the\nfeatures of REVIEW which Greg mentions in his REVNOTES member, just look\nthem up in the REVIEW# member, or say HEL REVIEW, after you've installed\nthe REVIEW help member in a SYSHELP library of your TSO session.\n\n      A third place to look, for help in the more obscure features of\nthe REVIEW command, is in the source code itself, at the beginning.\nThere, Greg gives a summary of all the changes that were made to REVIEW,\nover its many releases, and this history is many pages long.  From\nlooking there, you can learn a lot about REVIEW's intricacies.  Once you\nlearn that a feature exists, you can again refer to the TSO help member\nfor REVIEW, to learn how to use it.\n\n\nFORMATTING AND COPYING RECORDS\n\n      The REVIEW command \"knows\" how to format a large variety of\nrecords.  REVIEW can format IDR records, when REVIEWing load modules,\nand it can format DSCB entries for a dataset (when REVIEWing a VTOC).\nREVIEW can format tape labels, and of course, SMF records.  By looking\nin the REVIEW documentation we've just mentioned, you can learn about\nmany of the different kinds of records which REVIEW is able to format.\nI believe that REVIEW has a general formatting capability too, if you\nfeed it a DSECT, but I have never used that capability myself.  The main\nidea here is that you should spend some time exploring this beautiful\ncommand that has some 30000 lines of source code, supporting many\nfeatures which can be very useful in your work.\n\n      You can browse ASCII data with REVIEW by issuing the ASCII\nsubcommand, which will convert the ASCII data to EBCDIC and display it\non your screen.  REVIEW commands toggle.  So if you issue ASCII once,\nyou'll get ASCII ON.  Issue the ASCII command again, and you'll get\nASCII OFF.  Examples of other REVIEW commands which toggle, are SMF\n(to format SMF records you're browsing) and HEX (to display your data\nin HEX or character format).\n\n      Several REVIEW subcommands facilitate the copying of data from\nfiles that you're REVIEWing.  These are the CUT and ADD subcommands.\nThey work as follows.  First, you allocate an appropriate output dataset\nto the SYSUT2 ddname.  This dataset is for receiving the copied files.\nThen you position the screen to the place where you want to start the\ncopy operation.  Then you issue a CUT or ADD subcommand, to copy either\na number of lines (which you specify), or to go to end-of-file, which\nis the default if you don't specify a number of lines.  The difference\nbetween the CUT and ADD subcommands of REVIEW is that ADD will append\nadditional data to the end of an already opened SYSUT2 file, whereas\nCUT will close the SYSUT2 file after the copy operation is complete.\n\n      You can do the allocation of the SYSUT2 file from within REVIEW\nby issuing a TSO subcommand, followed by the appropriate ALLOC command\nand its parameters.\n\n      A particularly useful application of the CUT and ADD subcommands\nof REVIEW is to look at a SYSLOG on disk, and do a FIND ALL for a job\nname or another character string.  After a FIND 'string' ALL command,\nREVIEW will only display the lines of data where the string is found.\nSo after a FIND ALL for a particular job number, if you issue a CUT or\nADD command, you'll copy the job history data for that particular job,\nout to a file, and you can print or save the file, to show the\n\"evidence\" to the Operations people or the Application programmers.\n\n      As I said before, I've only scratched the surface in mentioning\nthings which REVIEW can do.  If you invest some time exploring REVIEW's\nmany features, you will discover a multi-faceted tool for data\nexamination which will help you to debug your programs, look at all\nkinds of system data, and help the application programmers with their\nproblems also.  REVIEW can look at tape data and disk data, and once\nyou've gotten familiar with it, you'll see that REVIEW will function\nas \"a second pair of eyes\" to look at much of your computer data.\n\n      Best of luck to all of you.  I hope to see you again next month!\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0203MA": {"ttr": 23555, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x19\\x01\\x02\\x03/\\x01\\x02\\x03O\\x10)\\x01\\x0c\\x01\\x0c\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-02-01T00:00:00", "modifydate": "2002-02-03T10:29:19", "lines": 268, "newlines": 268, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           MARCH 2002\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@attglobal.net and/or sbgolob@aol.com.\nThe Online CBT Tape web site has its own URL.  However, it can also\nbe reached from the \"Members Only\" section of www.naspa.net .\n\n\nGLOSSARIES\n\n      I for one, have often gotten the sinking feeling nowadays, that\nthis field is running away from me.  I've been doing this stuff (MVS\nsysprogging) for many years.  I have much hard-won experience and\nknowledge.  I know loads of tricks.  And yet, when I see the new\ndevelopments sprouting up like mushrooms all over the place, I often\nwonder if I can even think of an approach, how to keep up with all of\nthem, even in a general way.\n\n      Today, I'm going to tell you about a method that I've recently\ndiscovered myself.  It's really simple and obvious.  However, there are\nseveral zillion reasons why people don't do it.  But I have resolved to\npersonally adopt this practice, and I will not keep it a secret (much\nlonger).\n\n      Just about every IBM manual contains a section at the end, known\nas the Glossary.  By definition, a Glossary is like a mini-dictionary.\nIt is a short definition of terms, which the author(s) of the manual\nassume, that every reader does not know.  So these special terms,\nacronyms, and technical expressions are defined, as they relate to the\ncontents and context of the material in that manual.\n\n      I've mentioned that there are several (zillion) reasons why people\ngenerally don't go about reading the Glossary of an IBM manual.  A few\nof them are:\n\n1.  When they were children, they were told:  \"Only weirdos read the\n    dictionary.\"\n\n2.  It's \"boring\".\n\n3.  If you are new to the field, you don't know hardly any of the terms,\n    and reading the Glossary feels like reading a bunch of nonsense.\n\n      These \"reasons\" may be countered by:\n\n1.  Think to yourself:  \"Who is forcing me now, to pay any regard to the\n    things that some child told me, when I was a child?  In fact, who\n    was forcing me even then, to listen to that idiot?\" (No one.)\n\n2.  Things you have a vested interest in learning about now, can't be\n    too \"boring\".\n\n3.  Our experience shows that reading glossaries is most effective, when\n    you already know the meaning of at least 60 percent of the terms.\n    The Glossary just fills you in, on the few terms you don't know,\n    and enlightens you better, on the ones you do know.\n\n\nA Few Obvious Things About What's in a Glossary\n\n      Each IBM manual containing a Glossary, will define all the terms,\nonly in the context as they relate to the material in that manual.  For\nexample, the acronym \"SCDS\" will be defined differently in an SMP/E\nmanual, or a DFSMS/MVS manual.  In each of these contexts, the term SCDS\nmeans a different thing, unrelated to what it means in one of the other\ncontexts.\n\n      Sometimes a Glossary contains misprints.  I've seen manuals which\nmistakenly combined two separate dictionary entries into one paragraph.\nThis is the fault of the print formatting software, or how the editor\nof the manual has used it.  You have to use your head, at all times,\nwhen reading glossaries.\n\n      You can't expect the Glossary to provide great detail.  Only a\nbare definition is usually provided there, but it can be enough to get\nyou enlightened on the subject.  A technique to find more information\nabout a word or expression, is to look it up in the Index of the same\nmanual, and the detailed textual information describing the term and\nits use, will often also be pointed to, by that manual's Index.\n\n\nWhat Do You Expect to Gain?\n\n      Have you ever felt really ignorant when talking to somebody about\none of the new areas of MVS?  If someone is talking TCP/IP to you, and\nyou haven't dealt with TCP/IP much, it can be very embarrassing to admit\nthat you don't know what they're talking about.  If you're familiar with\nTCP/IP, just substitute some other new area of MVS, OS/390, or z/OS that\nyou're not familiar with.  Imagine talking to somebody and being very\nembarrassed.\n\n      If you've gotten used to our \"Reading the Glossary\" technique,\nthis difficult situation will happen to you (at most) only once.  As\nsoon as the first person has embarrassed you by talking about some new\narea you're not familiar with, you'll go to the Internet or the IBM\ncd-rom manual collections, find a manual relevant to that subject, and\nyou'll read all the way through its Glossary, and maybe also the\nIntroduction and the first chapter.  That embarrassment will never\nhappen again.  It may take awhile for you to be able to be \"talkative\"\nabout that subject, but at least your face won't turn red.\n\n      This practice will be very useful when you attend SHARE or one of\nthe other conferences.  In such places, a lot of people can talk about\nmany areas you don't have experience in.  By reading the appropriate\nglossaries later, you can quickly broaden the areas of your exposure.\n\n\nA General Observation about \"New Developments\"\n\n      Anybody who has written a new program with new functionality,\nrealizes that to describe what's happening, new terms have to be\ninvented.  For example, I've been privileged to add about 30-odd new\noptions to a formerly simple tape copying program.  I'd bet that very\nfew of you, in the audience, know what a LABLDUMP or a LABADDIN, a\nCHGVOL, or a LBDQUICK operation is.  However, if I tell you in a few\nwords, what new function my utility was trying to accomplish, just about\nall of you would clearly understand all these terms, in two minutes'\ntime.\n\n      Let me explain.  The new terms I've mentioned above, pertain to a\ntape copying program called COPYMODS, which can be found on File 229 of\nthe CBT MVS Utilities Tape.  As COPYMODS was originally written, it was\n(and is) a tape copying program.  COPYMODS makes exact copies of\nexisting tapes.  Its operation is as follows:\n\n      The input tape (and up to 16 output tapes) are OPENed.  A block of\ndata is read from the input tape to a buffer area in the program.  Then\nthe same block of data is written out from the buffer, to each of the\noutput tapes.  The program (as it originally was written) stops, when it\nsees two consecutive tape marks in the input tape.  Initially, this\nprogram was very simplistic, and it worked wonderfully, but it had\nsome severe limitations.\n\n      The main problems with COPYMODS come, when dealing with Standard\nLabeled (SL) tapes.  COPYMODS runs using BLP (Bypass Label Processing),\nso it considers tape labels the same as any other data.  Therefore, if\nCOPYMODS would make copies of a SL tape, it would exactly copy the\nlabels too.  Therefore, the VOLSER of the output tapes would be exactly\nthe same as the VOLSER of the input tape.  This makes some difficulty on\nan MVS system, and it is inflexible, in a situation where you'd want to\ncopy the data from one tape to another, but you want the output volume\nserial to be different from the input tape's VOLSER.\n\n      So to solve this and other problems, I had to \"teach\" COPYMODS\nall kinds of things about Standard IBM Tape Labels.  I \"taught\" the\nprogram to detect VOL1 labels, and HDRn, EOFn, EOVn, UHLn, and UTLn\nlabels on the input tape.\n\n      Now I can start explaining all the new terms I invented.  They are\neasy to understand, once you get the idea what I was trying to do.  And\nthe same principles apply, when you're trying to understand some new\nfunctionality, program, or system, which IBM has written.  Once you get\nthe general idea about what IBM was trying to accomplish, you'll also\nget to easily understand the new terminology IBM has invented.  And you\ncan do the same thing backwards.  By understanding the basics of the new\nterminology, you can then \"read between the lines\" and figure out what\nkind of new functionality IBM has created.\n\n      So let's get back to COPYMODS, and I'll explain the CHGVOL term.\nSuppose you wanted to copy a tape, but you wanted the VOLSER of the\noutput tapes to be different from that of the input tape.  With the new\nCOPYMODS, you can code PARM=CHGVOL.  This will cause COPYMODS to write\nany new VOL1 label on the output tapes, to match the VOLSER that was\ncoded in the JCL to create that output tape, instead of taking the\nVOLSER \"mindlessly\" from the input tape.  By reading this definition,\nknowledgeable MVS people will also infer that I must have gotten the\nvolume name information from the JCL, by doing a RDJFCB on the output\ntape, before or after I OPENed it.  All this knowledge came from\nlearning the definition of the CHGVOL term.  See my sample Glossary\nin Figure 1.\n\n      Now let me explain LABLDUMP, LABADDIN, and LBDQUICK.  These terms\nwere invented, because I wanted COPYMODS to be able to copy a complete\nset of Standard Labels from the input tape, out to a file.  Then, after\nmaking an NL copy of the same tape (with my COPYSLNL program), I wanted\nto be able to resplice the set of labels in the file, back into the NL\ntape, to create an SL tape again.  Today, you probably can't find such\nfunctionality in any other product, for free or for pay.  That's why I\ninvented these new terms.\n\n      To copy all the labels from a Standard Labeled tape to a file,\nyou code PARM=LABLDUMP in the COPYMODS EXEC card, and include a\n//LABLDUMP DD card to define the output file that will contain the set\nof labels.  That's what LABLDUMP means.  Now, to explain LABADDIN, it\nis the opposite operation to LABLDUMP.  This happens when the input tape\nis Non-Labeled, and you want to splice a set of labels (previously\ncreated by a LABLDUMP operation) back in.  You code PARM=LABADDIN in the\nEXEC card of the COPYMODS JCL, include a //LABADDIN DD card to point to\nthe file of labels, submit the JCL, and you can create up to 16 output\ntapes, Standard Labeled, with your new labels spliced in.\n\n      Now let's explain LBDQUICK.  It's the same as LABLDUMP, and it\nrequires the presence of a //LABLDUMP DD card in the execution JCL,\nexcept for one thing.  You want to read an SL tape, and copy the\nStandard Labels out to a file, but you want to do it \"quickly\".  (Let me\ninterject that I've also put PARM=READ into the COPYMODS program, so it\nwould only read the input tape without making copies.)  So how is\nLBDQUICK different from LABLDUMP?\n\n      LABLDUMP reads the entire tape, including the data, because when\nyou're executing COPYMODS with LABLDUMP, you're usually in the process\nof making copies of the input tape, at the same time you're copying out\nthe tape labels to a file.  Suppose now that the tape contains a million\nshort blocks, and only one file.  (I have created such a tape.  The\nprogram to do so, is also on File 229 of the CBT Tape.)  If you only\nwant to extract the labels from such a tape, the MVS system has to do\nI/O's to read every data block, before it gets to the end of the tape.\nThis might take a long time.  So I invented the LBDQUICK process to be\nrun with COPYMODS when you also do PARM=READ, so it skips reading the\ndata file, and gets to the labels themselves, more quickly.\n\n      Now that we've explained these terms here, please look at Figure\n1, where I've created \"Glossary entries\" to define them.  You can judge\nfor yourselves, if my Glossary helps you understand what is going on.\n\n      I hope that this month, I've given you a little more insight, and\nanother \"angle\", to help you in keeping up with developments in the MVS\nfield.  Best of luck to all of you, and I hope to see you again, next\nmonth.\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.        A Sample Glossary for the COPYMODS Program\n\n\n CHGVOL   - A PARM or SYSIN option of COPYMODS, which causes COPYMODS\n            to take the Volume Serial of the output tapes from the\n            VOL=SER=volser name in the execution JCL.\n\n COPYMODS - A program, with many options, to copy tapes.  COPYMODS\n            can read an input tape and create as many as 16 output\n            tapes at the same time.\n\n LABADDIN - A PARM or SYSIN option of COPYMODS, which takes a Non-\n            Labeled tape as input, together with an external card-\n            image file of tape labels, such as those created by a\n            previous LABLDUMP operation of COPYMODS.  Output tapes\n            are Standard-Labeled, created by splicing each tape label\n            set from the external file, around its corresponding data\n            file of the Non-Labeled input tape.  This parm requires a\n            //LABADDIN DD card which points to a card-image (FB-80)\n            file containing a set of tape labels with control cards,\n            such as those created by the LABLDUMP process.\n\n LABLDUMP - A PARM or SYSIN option of COPYMODS, which copies all\n            Standard Labels from the input tape to an external file.\n            Extra control cards are created in the external file, to\n            delimit each set of individual file labels.  This parm\n            requires a //LABLDUMP DD card which points to a card-image\n            (FB-80) file.\n\n LBDQUICK - A PARM or SYSIN option of COPYMODS, intended for use\n            together with PARM=READ, which copies all Standard\n            Labels from the input tape to an external file, skipping\n            the read of the tape data in between the labels.  This\n            parm requires a //LABLDUMP DD card which points to a\n            card-image (FB-80) file.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0204AP": {"ttr": 23560, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x07\\x1f\\x01\\x02\\x07\\x1f\\t&\\x01\\x1c\\x01\\x1c\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-03-12T00:00:00", "modifydate": "2002-03-12T09:26:00", "lines": 284, "newlines": 284, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           APRIL 2002\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@attglobal.net and/or sbgolob@aol.com.\nThe Online CBT Tape web site has its own URL.  However, it can also\nbe reached from the \"Members Only\" section of www.naspa.net .\n\n\nCBT TAPE SOFTWARE PACKAGING\n\n      In this new world of the web, I find myself having to \"hold the\nfort\" regarding the \"old world\" of traditional \"mainframe\" operating\nsystem software.  But I find myself learning a lot, from watching how\nsome of the \"new world people\" operate, especially the open source\npeople.  I got the idea for this article, by looking at www.mozilla.org,\nand reading their mission statement.  Even though Mozilla operates in\nthe world of web browsers, and I operate in the \"free mainframe\nsoftware\" arena, there is a lot in common, and a lot that I can learn\nfrom them.\n\n      The world is constantly changing, and yet there are many things\nthat are the same.  You need constancy over time, and yet you also\nneed the flexibility to make improvements.\n\n      This applies to everybody.  It is very true with regard to your\nown working techniques.  Everybody who works, eventually settles into a\npattern of techniques used.  But not allowing for technical improvements\nin your techniques, will eventually lead to stagnation, and later, to\ninadequacy in doing your work.  You don't want the world to pass you by.\nOne must always try to incorporate changes and improvements, from within\nthe steadiness of one's previously established and proven work patterns.\n\n      And so it is with me too.  As the person who incorporates new\ncontributions into the public \"CBT MVS Utilities Tape\" collection, I\nfind that I also have to establish a pattern which the public can\nunderstand and relate to.  But I constantly have to try and absorb new\nimprovements into my methods.  In a sense, as expressed by Mozilla's\nmission statement, I often have to be a \"benevolent dictator\", to\nestablish packaging standards for tape contributions, making the stuff\neasier to install and understand.  The public will be the arbiter, if\nI've done my job well.  As long as people can find the material they\nwant, and install it easily, they won't complain.  But I have to stay\nahead of them.\n\n      Today I want to do some talking about how I create and package the\nCBT Tape's files.  In a sense, you'll all be looking over my shoulder,\nand watching me work.\n\n      So what will you gain from this?  I'd say you'll gain a lot.\nThat's why I feel this topic is worth writing about.  In my own working\nlife, much of my own technique improvements have resulted from looking\nover someone else's shoulder, and saying:  \"Ah--so THAT's how they do\nit!  Never thought of that way before!\"  Another thing you'll gain, is\nto learn some of my software packaging techniques, which might help you\nto efficiently and accurately transport software from one place to\nanother.  A third thing you'll gain, is better to UN-package this\nsoftware.  If you need some free software that is on the CBT Tape\ncollection, you'll better be able to obtain it, load it onto your\nsystem, and get it ready to use.  I don't underestimate this last\nbenefit.  A sizable fraction of emails to me, are from people who are\nhaving some trouble installing the \"CBT Tape\" software that they need.\n\n\nSTARTING FROM THE DOC\n\n      The CBT tape documentation file, affectionately called File 001,\nis an FB-80 EBCDIC text file, whose format was basically established\nby the CBT Tape's founder, Arnold Casinghino.  I currently maintain\nand edit the contents of File 001.\n\n      File 001, containing a great wealth of detail, advice, facts, and\nprogram description, was originally created by Arnie as a considerable\nnumber of separate sections.  The current File 001, now well over 45000\nlines long, used to be a nightmare to maintain.  Just consider a\n20000-line segment of File 001 which would need a one-line change.  The\nediting overhead used to be horrific, especially since I like to keep\nsaving my edits in the middle, for safety's sake.\n\n      I solved this problem by dealing with File 001 as a partitioned\ndataset.  This sounds simple, but it is not.  The idea is that File 001\nhas to be broken into rather small sections in a very standard and\nreproducible way.  Each of the sections can grow and change, but they\nall have to be put back together in their original order, to re-create\nthe eventual large sequential dataset, which constitutes File 001 as we\nall know it, and as it is distributed on the CBT Tape.\n\n      This has to go the other way, too.  If I am given the last tape's\nFile 001, I have to be able to create the pds that I use to maintain it.\nAnd I have to do it in the same standard way, so even if (God forbid) I\nlost my copy of my maintenance software, I could still recreate the CBT\ndocumentation pds, as I know it.\n\n      My design consideration was to insert IEBUPDTE-type ./ ADD NAME=\ncards into a copy of the File 001 doc, such that the member names, in\nEBCDIC, would all sort in ascending order.  I would run IEBUPDTE against\nthis, to break the big doc file into pds members.  Therefore, the member\nlist of the pds, would follow the actual order of the pieces of doc, as\nthey are put together in File 001.  Then, it would be easy to put the\npieces of doc, which are already arranged in the proper order as members\nof the pds, back into their proper place when the entire sequential doc\nfile is reconstructed.\n\n      To carry out the design and the creation of the pds, I wrote an\nAssembler language program called CBTUPD, whose source can be found on\nFile 004 and File 006 of the CBT Tape.  The CBTUPD program examines\nevery line in the large doc file, and compares it against a table of\ntell-tale text strings which delimit each section of the doc, as Arnie\nand I created it.  The table of strings is preceded (in the CBTUPD\nsource code) by either the number 1, 2, or 3.  This tells CBTUPD to\ninsert the appropriate ./ ADD NAME= card, with an appropriate\npredetermined member name that is also coded, in a corresponding table,\neither one, two, or three lines BEFORE the line containing that\nparticular tell-tale doc string.  With that capability, the CBTUPD\nprogram does a very neat job of dividing up File 001 into nice looking,\nstandardly-named pds members.\n\n      One thing further has to be said about the CBT doc file.  The last\nhalf of it consists of descriptions of the contents of each of the 600\nfiles on the CBT Tape, whether they be \"empty\" (i.e. contianing a place\nholder file), or whether they contain usable data.  The CBTUPD program\nconstructs appropriate pds member names in its doc pds, to label these\n\"file contents\" sections for each tape file.\n\n      For example, that section of File 001 describing the contents of\nFile 523, in the CBT doc pds, is given a member name of @FILE523.  As\npart of my current file packaging, besides using the @FILE523 member as\na part of File 001, I also copy it in, as a member of the File 523 pds\nitself.  This practice forces me to coordinate the internal\ndocumentation description of each CBT Tape software contribution file,\nwith the File 001 overview description of that same file.  I haven't\ndone this yet for every file on the CBT Tape, but I've done it for\nalmost all of the new contributions.\n\n\nMOST OF THE CBT TAPE FILES ARE FB-80 PDS'ES\n\n      I have tried to extend Arnie's effort to put each contribution\nfile on the CBT Tape into the most standard format possible.  Since much\nof the material and tools on the CBT Tape are distributed as Assembler\nlanguage source code, which comes in 80-byte card-image files whose data\nrepresentation is EBCDIC, the actual format of the files, as they exist\non the actual CBT TAPE, is greatly affected by this consideration.\n\n      There has been a big effort by Arnie and me, to get rid of as many\nsequential files on the tape as possible, and make them into pds'es.\nThe reason for this is that the TAPEMAP program, from File 299 of the\nCBT Tape, can display all the pds member names of tape files written in\ncertain formats.  The permissible formats include IEBCOPY and IEBUPDTE\nSYSIN format.  Further, a program to compress FB-80 sequential files was\nwritten at the Connecticut Bank and Trust Company in 1979, to save tape\nspace, and allow Arnie to squeeze more files onto the (then) standard\nsized tape reels.\n\n      Close to 15 years ago, I extended TAPEMAP's power, to display the\nmember names in these compressed files also.  The TAPEMAP program would\nnot show names for the sequential files on the CBT Tape, but it would\nshow member names in all the pds files there, which are either in\nIEBUPDTE format, in compressed IEBUPDTE format, or in IEBCOPY format.\nThus, if the CBT Tape files are pds'es, you can find all occurrences of\nmember names you want, by scanning a TAPEMAP //SYSPRNT2 listing for the\nmember name.  Thus you can determine which tape files a program would\nmost likely be found in, and that helps your search effort.\n\n\nTSO XMIT FORMAT MAKES FB-80 PACKAGING EASIER\n\n      With the advent of TSO/E, as opposed to the old MVS TSO of\npre-1985 vintage, IBM created a new TSO command for sending data from\none MVS system in an NJE complex, to another.  This command is called by\nits name, TRANSMIT, or by its alias, XMIT.  The corresponding command\nfor getting the data on the other end, was called RECEIVE.  The TSO\nRECEIVE command has no abbreviation or short form.\n\n      The plan for the XMIT command, was to send the MVS data across\nlines controlled by either JES2, JES3, VM, or VSE/POWER.  In turn, those\nsoftware systems are highly card-image (i.e. FB-80) oriented.  JES2,\nJES3, VM, and VSE/POWER \"like\" 80-byte card image records, and can\nhandle them well.\n\n      So to carry out the plan, a means was devised, to use the XMIT\ncommand to convert various types of mainframe data, especially entire\npartitioned datasets, to FB-80 card-image sequential files that could be\ntransmitted error-free over JES-controlled lines.  On the other end, the\nRECEIVE command would re-create the original pds or other data, on the\nreceiving MVS system, using the data's original DCB attributes.\n\n      Practically speaking, there's an important thing to know about\nthe XMIT-RECEIVE combination.  If you're sending the data across from\none MVS system to another, its format DURING TRANSMISSION is unknown to\nthe users on either end.  But in reality, the transmission format of the\ndata is FB-80 sequential.  It's just that neither user on either end\ngets to see the data in its intermediate form.  However, just in case\nthe data would NOT be directly and immediately sent across a line, the\nTSO designers created a way for us to get the data into its intermediate\nformat, and that is by using the OUTDSN( ) keyword of the XMIT command.\nWhen you code the XMIT command using the OUTDSN(intermed.dataset.name)\nkeyword, the data then is NOT transmitted across a line, but it is\nwritten in its intermediate format, to an FB-80 sequential file on the\ncreating MVS system.  That intermediate file can be Internet-ted or\notherwise shipped to any MVS system anywhere, and the RECEIVE command,\nusing the INDS(intermed.dataset.name) keyword on the destination system,\ncan then re-create the original dataset with its original DCB\nproperties.\n\n      This gimmick is what we use in our CBT Tape file packaging.  Load\nmodule pds'es, for example, can be converted to FB-80 sequential files,\nusing XMIT with the OUTDSN( ) keyword, and these can be included as\nmembers of source pds'es on the CBT Tape, since they are also FB-80\ncard-image files.  So instead of having to package two files for source\nand load, the source in compressed FB-80 IEBUPDTE SYSIN format, and the\nload in IEBCOPY format, you can put the load module library into an\nXMIT-format FB-80 file, and include it as a member of the source pds.\nThen the user of the file, can issue a RECEIVE INDS( ) command against\nthat pds member, to re-create the original load library.\n\n      The same technique can be used to package source type files that\nare VB, or are FB but not with LRECL=80.  Just put them into XMIT format\nusing the OUTDSN( ) keyword, make them a member of an FB-80 pds, and you\nhave a uniform way to package the varied types of files in one pds.\n\n\nTAPE FILES vs. WEB SITE FILES\n\n      Most of the files on the actual CBT TAPE, are either in IEBUPDTE\nSYSIN format FB-80 pds'es that have been compressed, or they are in\nIEBCOPY format on the tape.  On the CBT Tape web site though, these same\nfiles are distributed in pkzip'ed TSO XMIT format.  Pkzip'ed file format\ntakes much less room on the web server disks, and those files are also\nsmaller than the corresponding tape files, so they can be downloaded\nover the Internet more quickly.  In today's discussion, it doesn't pay\nto dwell on these differences, except to say that very few sites have\nan un-zip program on their MVS system, so we must use MVS-oriented\nmethods when real tapes are involved.  Suffice it to say, that packaged\neither way, the usual resulting file on the destination MVS system will\nprobably be a pds or an EBCDIC sequential file.\n\n\nVERSION-ING THE CBT TAPE FILES\n\n      I recently created a CLIST called GENDAT (found on File 006)\nwhich will create a \"time-stamp and stats\" member for each new CBT Tape\nfile.  This member is always named $$$#DATE, and a sample of it is\nshown in Figure 1.  In between release cuts of the CBT Tape versions,\nI post recently updated or added CBT Tape files to the \"Updates\" page\nof the CBT Tape web site.  One file might be updated over a dozen times,\nin between CBT Tape version cuts.  Therefore, if you've downloaded a\nfile from the www.cbttape.org Updates page, you want to know which\nversion you've got.  This $$$#DATE member tells you.  I now run the\nGENDAT CLIST against every new file version I distribute, on the web\nsite or on the actual CBT Tape.\n\n      I hope that by now, you understand a little more about the CBT\nTape file packaging, and I have to apologize that I don't have the space\nto describe more of my techniques now.  However, when you're downloading\na CBT Tape file and trying to install its contents, I trust that the\nfacts I've mentioned, will help you out.  The best of everything to you\nall, and I hope to see you next month.\n\n   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\nFigure 1.   A sample $$$#DATE member of a CBT Tape File.\n            This member was created by the GENDAT CLIST from File 006.\n\n\nREGULAR CBT TAPE - VERSION 443    FILE:  548\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT443.FILE548\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 8 MEMBERS COUNTED; CUMULATIVE SIZE IS 852 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   02/15/02    09:35:08    GMT-5:00\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0205MY": {"ttr": 23809, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00G\\x01\\x02\\t\\x7f\\x01\\x02\\t\\x7f\\x14\"\\x00\\xef\\x00\\xef\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-07T00:00:00", "modifydate": "2002-04-07T14:22:47", "lines": 239, "newlines": 239, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                            MAY 2002\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@attglobal.net and/or sbgolob@aol.com.\nThe Online CBT Tape web site has its own URL.  However, it can also\nbe reached from the \"Members Only\" section of www.naspa.net .\n\n\nDRIVEN BY NECESSITY\n\n      It's obvious to all of us, that most of the work we do, is driven\nby necessity.  We have to maintain our installation--a certain result\nneeds to be obtained--and our technical tasks are directed to achieve\nthis result.  I'd say that upwards of 95 percent of our \"experience\" is\ngained by doing technical tasks that our shop requires us to do.\n\n      I'd like to make a point.  Even though the MVS operating system\nwhich runs at different installations is essentially the same thing,\neach installation's current requirements and emphases may be widely\ndifferent.  Some shops have a need to run a web site from MVS.  Some\nshops are worried about CICS terminal response time (even today).  Some\nare concentrating on putting all their tape work on a Virtual Tape\nsystem.  There are hundreds, and possibly thousands, of different \"hot\nneeds\" at every installation, at any given time.  And who works at\nsatisfying them?  We do.\n\n      My point is, that most of us are only worrying about what is going\non at our own shops.  I have a different view, being the proprietor of a\nvery large free software collection (the CBT MVS Utilities Tapes).  In\nmy CBT Tape activity, I have to \"cater to the world\", so to speak.  I\nget to see the varied software contributions which are coming in from\nall over the world, dealing with many different aspects of MVS.  Most of\nthese software creations were driven by a requirement in \"that\nparticular shop\", at \"some particular time\".  What we often DON'T DO, is\nto realize that there is benefit to US, to see that some OTHER SHOP had\na certain particular need.  I want to point out that there is an\nadvantage to us, to think more globally, and to pay a certain percentage\nof our attention to being aware of other people's MVS problems and\nneeds, not just our own immediate assignments, that have been driven by\nour own shop's needs at this current moment.\n\n      By being aware of problems in other shops, we add another\ndimension to our outlook.  MVS, now encompassed in OS/390 and in z/OS,\nis vast.  We find that we can't learn ALL of it, but we can at least\ntry to learn a lot of it.  My experience tells me, that if you have a\nbroader view of MVS than just what your own shop needs, you can provide\na vision and a direction for your shop, on such occasions when that\nmight later be required.  This is because your outlook is now \"outside\"\nas well as \"inside\", and you will get to grow more aware of the many\nthings that MVS can be used for.\n\n\nNECESSITY AS A FORCE\n\n      I remember in the old days of MVS systems programming, when there\nwere a lot of Assembler \"hotshots\", who claimed they could code any tool\nor utility they might need in doing their work.  I watched some of these\npeople.  My take on their claim was:  Yes, they probably could code any\nutility they wanted to.  But practically speaking, their everyday work\ndid not allow them the time or concentration to do a proper job, in\nwriting every tool that might be needed.  They simply didn't have the\ntime, and never got around to it.\n\n      So we see that human limitations usually got the best of even\nthese people, who knew the system inside-out, and who could \"code\nanything\".  Today with the standards for a useful tool being higher,\nthe MVS system being more complicated, and with the Assembler skills,\non the average, being much lower, I don't think it is practical for most\npeople to go around, saying:  \"I can code up anything I want, whenever\nI'll need it.\"  You simply have to have the time to do it right, besides\nhaving the skill too.\n\n      So it becomes practical for all of us to rely, for at least our\nfree tools, on someone else, who at one time was driven by necessity, and\nwho had the time to do it right.  I might point out that the vendors are\nalso driven by necessity--to produce a product that they can sell to\nsatisfy the customer needs, and to keep their customers' satisfaction.\n\n      Let me supply an example.  I'll ask:  Which of you has ever had a\nneed to code a set of tools to manage SYS1.BRODCAST messages?  I'd bet\nthat very few of your shops ever paid someone to write a tool to print\nor delete a selected user's TSO Broadcast messages--it simply isn't\neconomically feasible at most shops, to spend programmer money on that\nkind of work--there isn't a need.  But I was paid for over two months\nonce, to do just this, because my shop had such a need.  I worked for a\nlarge service bureau, which managed a diverse set of LPARs for various\nseparate agencies, and we had political reasons to be careful with all\ntheir data.  We could not simply delete an agency's Broadcast or Notify\nmessages whenever we felt like it.  We had to have a measure of real\ncontrol and accountability to each agency.  So the need was there, in\nthat particular case, and I had to do the job.\n\n      As a result, I wrote a comprehensive set of tools to manage\nSYS1.BRODCAST messages, and I've improved on these tools since then.\nI've even gotten these tools to the point where I can display or delete\nany number of selected messages for any userid, at any point in the\nchain--I'm not restricted to deleting all of them.  My friend Vinh Vu\neven wrote an ISPF interface for using these tools easily and safely.\n\n      So here's one clear example, where you see that because one\nperson's shop had a rather unusual need, all of you can now enjoy the\nresults of the work, and use the tools that were created because of this\nneed.  You can find my set of SYS1.BRODCAST management tools by\nobtaining File 247 from the large CBT MVS Utilities Tape collection on\nthe web.  www.naspa.com has a link to the CBT Tape web site.\n\n      The entire CBT Tape collection of utilities is filled with such\ncreations, from people who, at a certain time and place, were driven by\nnecessity to create certain kinds of tools.  I always say that the world\nis usually better off, when \"one hand washes the other\", and people help\neach other to solve one another's problems.  If one person was driven by\nnecessity to do a certain job at a certain time, and the resulting tool\nwas contributed to a common pool (the CBT Tape collection is one of\nthe most well-known common pools of software and tools), then a lot of\nother people can also benefit.  One person's \"necessity\" has become\neveryone's profit.\n\n\nNECESSITY CREATES ACCURACY\n\n      This is an easy concept to understand.  When you have a need at\nthe job, and you have to write a program, or perform some maneuvers to\nget around the difficulties and solve the need, you had better be\naccurate.  Otherwise, you will not solve the problem or satisfy the\nneed.  The PROBLEM requires you to be accurate, in the process of\nsolving it.\n\n      To show how this works, I'll use my previous example.  When I was\nwriting my SYS1.BRODCAST utilities that I mentioned before, and I wanted\nto delete a particular userid's messages, I realized that I had to do it\ncorrectly.  Otherwise I would have corrupted the SYS1.BRODCAST dataset\nfor the entire system.  Therefore, I had to be careful to make sure that\nmy code didn't leave any \"orphaned\" message records (one userid's\nmessage records are all chained together), and I had to get the system\nenqueues correct.  I didn't want to be mucking with the userid message\nchains, while somebody else was trying to do a SEND or a LISTBC command\nunder the covers (such as processing a JCL NOTIFY=userid request).  I\nknew I couldn't attempt to do this kind of a programming job, unless it\nwas completely reliable, accurate, and dependable.  The fact that I was\nresponding to a necessity, required me to \"do the job right\".\n\n      Again, at this point, I'd like to emphasize that since I have\nalready tackled this job, and I've shared my code with the public, you\ndon't have to re-do that work all over again.  But I'm also saying that\nin my own personal experience, I realize very well, that necessity in\nsolving a problem, requires enough of a degree of accuracy in the\nsolution, that no further problems would be created by what you've done.\nNecessity has thus become a force, to ensure the accuracy of the solution.\nSo the necessity which gave rise to trying to solve the problem, also\nserves as a deterrent to making errors.\n\n\nTHE OPPOSITE OF \"NECESSITY\" - MAKING TIME TO LEARN\n\n      So at this point it might seem to you, that everything you do in\nyour MVS work is driven by the necessity created by the job, and that\nthere is nothing else which motivates you.  This doesn't have to be the\ncase.\n\n      My MVS teacher, Jeff Broido, always used to emphasize that an MVS\npractitioner should invest at least a half hour a day, to learn\nsomething new.  Jeff told me that long ago, when ISPF was first\nreleased, he took the time to learn all of the ISPF tutorials.  In this\nway, he was able to accumulate enough ISPF knowledge to do his job more\nefficiently, and he could save his company's time in the long run.  I\nthink that everyone should seriously consider the merit of what Jeff\nsuggested to me then.\n\n      Jeff used to spend a lot of his time writing specialized TSO\ncommands.  You can see the results of some of Jeff's work on CBT Tape\nFile 423.  Part of his motivation was to use this \"piece of the day\" to\nlearn new things.  But he frequently aimed his extra projects at\nsatisfying some actual need which the installation had, but which they\ndidn't specifically order him to work on.  It's true that most MVS\nsystems programmers are required, to a large extent, to use their own\nindividual initiative, usually within the range of working on the\ninstallation's current \"hot needs\".  But sometimes, an installation's\n\"lukewarm need\" might become a \"hot need\" later.  And you can spend your\nextra learning time working on that kind of stuff too, provided that\nyour management doesn't object.\n\n\nSUMMARY, AND A FEW SUGGESTIONS\n\n      The main thing I want to point out, is that I've noticed that many\nof us tend to get completely absorbed in only solving the \"hot needs\" of\nthe installation.  It's true, that we can grow a lot (professionally)\nthat way, but I think that only tending to the \"hot needs of the hour\"\nwill stunt the growth of our MVS vision in the long run.  You have to be\nable to \"look outside of yourself\" sometimes.  And the installation will\nprofit too, in the long run, from your developing some broad-mindedness.\n\n      You can develop some breadth of vision by looking at other\npeople's problems, preferably from other shops.  One way you can do\nthat, is to monitor some relevant news groups, such as the IBM-MAIN news\ngroup (see my April 1998 column for more details).  The current\nlistserver address for IBM-MAIN is listserv@bama.ua.edu .  And the\nmessage posting address for IBM-MAIN, once you've subscribed, is\nIBM-MAIN@bama.ua.edu .  I get a daily digest of the IBM-MAIN group, so I\ndon't get bombarded with the individual email messages, and I look\nthrough the digests whenever I have a free moment, or I feel that I need\na break.\n\n      Some of the other LISTSERV-based news groups are:  ISPF-L, RACF-L,\nASSEMBLER-LIST, MVS-OE, C370-L, PL1-L, JES2-L, JES3-L, and DB2-L.  The\nLISTSERV-based news groups are linked together.  Once you subscribe to\none of them such as IBM-MAIN, you can request an INFO REFCARD from its\nlistserver address, to tell you how to find, and subscribe, to the other\nlists that you're interested in.\n\n      Other news group lists are not LISTSERV-based.  A notable example\nis a whole bunch of them, that are maintained at www.yahoogroups.com .\nThe principal one of these that I subscribe to, is the Hercules-390\nlist.  To subscribe to that, the address is\nhercules-390-subscribe@yahoogroups.com .  And its message posting\naddress is hercules-390@yahoogroups.com .  Once you're into the\nwww.yahoogroups.com family of lists, you can find a whole bunch of\nthose, to interest you as well.\n\n      In my opinion, this extra stuff should not be done to extremes,\nbut it's only for \"broadening purposes\", and it should be done in\nmoderation.  Most of what we do at work, is driven by necessity, and it\nshould remain so.  Remember that Jeff Broido's guideline was to spend\nroughly a half hour each day, at generally broadening your knowledge.\nThe purposes of these extra activities, is just to put your overall\nvision into perspective, as it relates to what other people in other\nshops, do.  By maintaining a healthy balance, you will grow toward\nbecoming a more complete and valuable Systems Programmer.\n\n      I hope you all have a good month, and I'm looking forward to\nseeing you again, next month.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0206JL": {"ttr": 23814, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x004\\x01\\x02\\x12_\\x01\\x02\\x12_\\tF\\x00\\xf8\\x00\\xf8\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-05-05T00:00:00", "modifydate": "2002-05-05T09:46:34", "lines": 248, "newlines": 248, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           JULY 2002\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@attglobal.net and/or sbgolob@aol.com.\nThe Online CBT Tape web site has its own URL.  However, it can also\nbe reached from the \"Members Only\" section of www.naspa.net .\n\n\nRETRO MVS COMPUTING\n\n      I'd bet that five years ago, nobody could have predicted this\ndevelopment.  As most of the revolutionary ideas go, this one started\nas someone's dream.  It began, it was developed, and it actually became\nworkable.  It was developed further, to the extent that (even though\nnot many people might come out and say so) it is on the verge of making\na big impact in the lives of us MVS systems programmers.\n\n      This idea, which is not completely in isolation, is the FREE\nLinux-based S/390 instruction simulator called Hercules.  Hercules has\nnow been ported to Windows, and it can be run on your home PC.\n\n      What is Hercules?  Hercules is software, which simulates on a PC,\nS/390 instructions, MVS DASD, I/O, and Tape.  Hercules has been made for\nhobbyists, not for commercial use, and because of licensing issues, most\namateurs using Hercules, run the free, ancient MVS 3.8 operating system.\nHowever, it must be said that Hercules is capable of running all the MVS\noperating systems, up through z/OS.\n\n      I need to emphasize that people who want to set up small MVS\ninstallations commercially, should go to the one of the several vendors\nwho are \"IBM Partners\", and who sell and lease PC-type machines with the\nvendors' commercial S/390 instruction simulators, that are properly\nlicensed to run the latest IBM operating system offerings.  Hercules is\nintended for amateurs, but it is a force, and it is helping the entire\nMVS community, commercial or otherwise.\n\n      My point in this month's column, is to show how many people's\nextensive efforts to develop and run \"ancient MVS 3.8\" under Hercules,\nare beginning to become a big force in helping to support \"modern MVS\",\nwhich is OS/390 and z/OS.  We are all profiting from the Hercules\ndevelopment effort, as I hope I can show.\n\n      As an aside, I'd like to also point out that Hercules is a great\nboon for MVS retirees, and for MVS people who are currently out of work,\nor on disability.  It used to be impossible to work with MVS, unless you\nhad a mainframe or an expensive P/390 at your disposal, and as soon as\none would retire, or be laid off (hopefully temporarily), all\nsubstantial MVS work would have to stop.  Now, that isn't so.  Nearly\neverybody has a fairly modern PC at home.  As we shall see, it's\npossible to set up a complete \"turnkey MVS system\" on your PC at home,\nin about ten or fifteen minutes, under Windows, and get onto TSO.  Are\nyou fascinated?\n\n\nSOUPING UP MVS 3.8\n\n      When MVS 3.8 was new, thirty years ago, all the future development\nand enhancement directions for MVS could not have been anticipated.  But\nnow, that new hardware (such as 3380 and 3390 disk packs and such) has\nbeen developed, the Internet is a fact of life, and lots of user-written\nMVS programs are on the CBT Tape and in other places, the idea is to try\nand bring your MVS 3.8 system \"up to speed\" in today's world.  People\nare trying to make \"old MVS 3.8\" do as many of the \"new tricks\" as is\npossible.\n\n      This effort is being undertaken by a fairly large group of people.\nSomebody has added 3380, 3390, and I believe 3375 support to MVS 3.8.\nVery substantial tape support, networking support, and disk compression\nsupport have been added to Hercules itself (regardless of the operating\nsystem being run).  And already, sizable numbers of user-written MVS\nutilities have been retrofitted to work on MVS 3.8.  The PDS 8.5\ncommand has been given options so it can be retrofitted to work in line\nmode and without ISPF, at the MVS 3.8 level.  Also you can look at CBT\nTape Files 077, 547, and 574 for more collected utilities that work on\nMVS 3.8.\n\n      If you want to find out more about the Hercules and MVS 3.8\nimprovement effort for yourself, the first starting place should be the\nHercules-390 news group on www.yahoogroups.com .  After that, there's\nthe spin-off H390-MVS news group there, as well.  These groups have\ndownloadable files and programs connected to them.  All serious work\nin the Hercules arena, should begin there.\n\n      Some of the user-written MVS utilities written for MVS 3.8 are\nnew, and they will actually also work on OS/390 and z/OS systems, so we\ncan already see a tangible benefit from all this MVS retro-computing.\nHowever, there's another direct benefit too--it is bringing the entire\nMVS systems support community back to its roots.\n\n\nWHY STUDY MVS AS IT USED TO BE?\n\n      I contend that you can't know MVS today, unless you know MVS\nas it used to be.  This is not taught in schools--IBM doesn't seem to\ncare whether or not MVS support people know the roots of MVS.  But the\nfact remains that you can't know about today's MVS structures, unless\nyou also know a lot about where they came from.\n\n      I'll give you one small example, but there are many others too.\nOur example concerns SMP/E, the \"modern way\" that IBM uses to put\nchanges and fixes on to an MVS system.  SMP/E uses a strange mix of\ntechnical words, that are hard to learn, and which are found nowhere\nelse.  I contend that you can't know SMP/E, unless you are completely\nfamiliar with how the old MVS \"SYSGEN\" process used to work.  And the\nMVS SYSGEN process isn't done today anymore.  (But it IS necessary on\nMVS 3.8!)  If you want to see a detailed treatment of this same topic,\nplease get File 014 from the CBT MVS tape, and look at my old article\non the fundamental root principles of SMP and SMP/E.\n\n      In today's OS/390 and z/OS MVS world, you can ask:  \"How many of\nthe new support people know what a SYSGEN is?\"  Today, IBM has built the\nequivalent of the old SYSGEN process into HCD, and into the JCLIN that\nis shipped with the canned MVS zones which come with a Service Pack\ndelivery.  Essentially, the SYSGEN structure of MVS is completely hidden\nfrom MVS sysprogs nowadays.  So today's MVS system support people never\nget to see the system's load module structure in detail, at all.\nTherefore we might ask:  \"Without the MVS 3.8 retro-computing, would\nthere be any way for today's sysprogs to find out about the roots of MVS\nSMP/E structure?\"  The answer is:  \"Probably not!\"\n\n      Before proceeding further, I want to state a principle, which is\nvery important for us to understand.  The idea is that MVS as an\noperating system, is evolutionary, and not \"logical\".  In other words,\nyou can only understand \"today's MVS\" by understanding MVS as it used to\nbe.  This sounds shocking, but it's absolutely true, and I'll show you\nhow it works.\n\n      IBM designed OS/360, the precursor of MVS, back around 1964, as a\ncompletely new operating system to run on the (then) new IBM 360\nhardware.  The idea at that time, was that this operating system should\nbe highly configurable and it should serve as a \"be all and end all\" for\nlarge-scale industrial computing.  Following that design pattern, IBM\nthen kept developing OS/360 MVT, System/370 VS2, and MVS, using a\ncustomer-driven evolutionary process that remained largely upward\ncompatible, so that old MVS programs would usually continue to run on\nthe new MVS systems.\n\n      Structure-wise, the MVS operating system was developed using an\nevolutionary process as well.  Parts of the operating system would not\nbe rewritten, unless they had to be, to fulfill a customer-driven need.\nSome pieces of the MVS system actually remain essentially the same\ntoday, as they were 30 years ago.\n\n      Now let's get back to SMP/E.  SMP/E automates the process of\napplying changes to an MVS system.  A module is fixed, and has to be\nreplaced within the operating system structure.  How do you do it?\nNowadays, it's automatic.  You RECEIVE and APPLY the fix (called a PTF)\ninto SMP/E, and it automagically gets put into the right place, provided\nyou've used the right control cards.\n\n      Understanding how this really works, however, is virtually\nimpossible, unless you first understand how a fix used to be applied to\nMVS, in the \"ancient days\".  For example, applying a PTF (a program fix)\nto the MVS system used to consist of fitting an object module change\ninto a piece of the existing SYSGEN structure.  This had to be done by\nhand, and if you had a lot of PTF changes applied to your system, it was\ndifficult to keep track of them.  There was no automated method of\nfiguring out what modification level, your system was at.  So how did\nall this evolve into SMP/E, which is today's way of putting on PTFs?  To\nsee this, you have to know what a SYSGEN really is.\n\n      I'll explain it.  In former times, IBM would ship an entire\noperating system as a unit, but the customer had to configure the pieces\nof the operating system to the I/O, hardware and software structure,\naccording to the available hardware and software the installation had.\nSo the customer, in reality, had to build an individually customized\nversion of his own MVS operating system.  This is the SYSGEN process.\n\n      What did you do?  You'd code up a file of assembler macros\naccording to your installation's hardware and software configuration.\nThis was called the SYSGEN Stage 1 deck.  Then you'd assemble your\ncustomized Stage 1 deck against a set of SYSGEN macros that IBM shipped\nwith the system, and this would generate a complete \"build\" of your own\nsystem's load module and library structure.  This \"system build deck\"\nproduced by assembling the Stage 1 SYSGEN deck, was called a \"SYSGEN\nStage 2 deck\".  It consisted of a series of assembly, IEBCOPY, an\nlinkedit jobs, which had to be run on a \"driving MVS system\", and which\nwould fill up all the libraries necessary for building and running your\nnew MVS system.\n\n      Unless you actually have had experience assembling and running a\ncomplete SYSGEN, it is basically impossible to understand what happens\nwhen you APPLY a PTF fix to an MVS system, using SMP/E.  Yes, it is a\nre-assembly or a re-linkedit.  But what makes these new pieces go into\nthose old places?  How does SMP/E \"know\"?\n\n      The answer is that SMP/E uses a pattern that gets put into it,\nvia the JCLIN.  You can laboriously extract this JCLIN pattern from\nwithin the SMP/E zones, using the GENERATE process of SMP/E.  But the\nbottom line for understanding, is that really, the SMP/E JCLIN is a\nSYSGEN Stage 2 deck!\n\n      That's right.  In fact, building a new MVS system, even with\nSMP/E itself, used to consist of assembling a SYSGEN Stage 2 deck and\nfeeding that deck back into SMP/E as JCLIN.  So, even if you didn't know\nwhat JCLIN was before, you know it now.  However, this fact would not be\n\"graphic\" to you--you cannot understand it clearly--unless you have\nactually seen a real SYSGEN Stage 2 deck on your screen or on paper.\nNowadays, it's almost impossible to get that information, unless you've\nhad some experience with the SMP/E GENERATE process.  But I can tell\nyou, that everyone reading this, can now obtain their own MVS 3.8\nsystem, run a complete SYSGEN, and see the entire process graphically.\nIt all comes with retro-computing under Hercules, running MVS 3.8.\nThis is one way how retro-computing can be a great teacher to the\n\"modern generation\" of MVS sysprogs.\n\n\nIT'S REALLY EASIER THAN THAT\n\n      Perhaps I've discouraged you.  Remember?  I said before, that you\ncan load a complete \"already SYSGENed\" MVS 3.8 system on to your PC in\n10 or 15 minutes.  That's right too.  A man named Volker Bandke has\nhelped us to do that.\n\n      Volker has produced a cd-rom which contains his \"complete Turnkey\nMVS 3.8 system\".  You can order Volker's cd-rom from the CBT Tape web\nsite (reachable through the NaSPA web site, and also directly).\nVolker's cd-rom is automatically self-starting, and prompts you where to\nload your new MVS system on your Windows-based PC.  In 10 or 15 minutes\n(conservatively), you're ready to get into a DOS prompt screen, start\nHercules, and run MVS!  You'll even get some MVS disks with many of the\nCBT Tape files already loaded.  Volker's own web site is:\nhttp://www.bsp-gmbh.com .\n\n      Just one more thing--the only other missing ingredient is a\nWindows TN3270 terminal emulator package for the PC.  This will get\nyour MVS console and your TSO terminals.  Although there are many good\nWindows TN3270 packages, I would personally recommend Tom Brennan's\nVISTA package, which you can obtain online from\nwww.tombrennansoftware.com .\n\n      So I would say, that Hercules with MVS 3.8 retro-computing has\nopened up a completely new dimension in our field, and has made it\npossible for the new MVS sysprogs to learn many of the old tricks.\nAll of you can now have \"MVS at home\", if you want it.  Although it's\nnot the current OS/390 or z/OS, with all their bells and whistles, it IS\na complete MVS system, which in the long run, will greatly add to the\ndepth of your MVS knowledge, I guarantee!\n\n      Best of luck to all of you.  I hope to see you next month!\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0207AU": {"ttr": 23819, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00(\\x01\\x02\\x19\\x1f\\x01\\x02\\x19\\x1f#5\\x00\\xd5\\x00\\xd5\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-07-10T00:00:00", "modifydate": "2002-07-10T23:35:28", "lines": 213, "newlines": 213, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          AUGUST 2002\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@attglobal.net and/or sbgolob@aol.com.\nThe Online CBT Tape web site has its own URL.  However, it can also\nbe reached from the \"Members Only\" section of www.naspa.com .\n\n\nPOSITIONS, AND THE DIVISION OF LABOR\n\n      Today I'm going to talk about a general principle more than usual,\nwith some of its ramifications.  The reason is, that if we all review\nthese ideas and let them \"knock around inside our heads\" for a while,\nthey'll eventually cause a lot of improvement in our quality of life,\nboth as \"MVS System Doctors\", and in other ways.  We'll eventually stand\nto get a lot more satisfaction, on many fronts.  This idea revolves\naround the general concept of dividing big jobs into many little jobs,\nbut there's a lot more to it.\n\n      All of you know that MVS is a big operating system.  And just\nabout everyone in a corporate organization, or who has ever been a part\nof one, knows that big corporations do a big job.  And there is one\nbasic way that the big job gets done.  That is, the big job is broken up\ninto smaller pieces.  Each piece is broken into even smaller pieces, and\nfinally, there are bite-sized pieces that one person can handle.  When\neverybody covers his/her own piece, the corporation functions well.\nOtherwise, problems result.\n\n      Similarly, the MVS operating system does a big job.  And just like\nthe big corporation, this big operating system is broken into smaller\ncomponents, which handle smaller portions of the big job.  Finally, all\nof the components are broken into bite-sized pieces--executable modules,\nwhich form the individual units of execution, in this huge MVS system.\nFor the MVS system to function well, each module (i.e program) has to do\nit's own job, and all the programs have to work together.  If one\nprogram is remiss in its duties, problems result.\n\n      This is very obvious to most people in the modern world, and why\ndoes the world's big business, and the MVS operating system, work in\nthis way?  I'll give the obvious reason--it is due to physical\nlimitations.\n\n      This is easy to see.  Let's ask an appropriate question:  How high\ncan a person jump in one bound?  The world record at this time, is held\nby a man named Javier Sotomayor, who jumped eight feet high in a single\nbound, perhaps a handful of times.  Quite a few other people have jumped\nover seven feet, but nine feet--not one!  Yet, people walk up flights of\nstairs every day, and the total amount of height they have scaled, is\nmuch more than nine feet.  What's the difference?  They broke the big\n\"jumping job\" into bite-sized pieces--each piece, the height of a step\non a staircase!  And scaling each step, is a job that can be handled.\n\n\nLEARNING TO GENERALIZE THE PRINICPLE\n\n      I want to take a few moments to digress from MVS in particular,\nand talk about the ramifications of the idea of dividing big jobs into\nbite-size tasks.  It's not the \"division of the labor\" that's the most\nimportant thing.  It's the \"division of the people who do the labor\",\nso that the appropriate people do the appropriate jobs, and the jobs\nget done!\n\n      Many people know the joke:  \"How do you fit six elephants into\na Volkswagen?\"  Answer:  \"Three in the front, and three in the back!\"\nWhy is this a joke?  Because everybody knows it can't be done, unless\nyou have very miniature elephants.  So we see that \"dividing big jobs\ninto little ones\" is not the main trick.  The trick is \"finding the\nright people who can actually accomplish each small job\", after the\ntask list has been determined.\n\n      Everybody who works for an organization has (hopefully) learned\nthe lesson of \"teamwork\".  Each person inside the organization does a\njob, and all of the people, doing their jobs at least reasonably well,\nallow the corporation as a whole, to function and achieve its goals.\n\n      But there is a lot more potential in this principle.  It also\nworks in a direction that has become very obvious in today's\nInternet-connected world.  Cooperation and position-playing often cross\norganizational boundaries!\n\n\nOPEN-SOURCE EFFORTS vs. CORPORATIONS\n\n      Let's look across organizational boundaries.  For example, in an\n\"Open-Source\" software development effort, this principle is just as\ntrue.  A big goal is determined.  People want to develop a piece of\nsoftware that does a big job.  And then, the big job is divided into\nnecessary smaller jobs, and anybody who can do one of the smaller jobs,\ntakes a piece of the work.  Even though a person is not \"hired\" by an\nopen-source effort, each person who \"takes a piece of the job\" usually\ndoes the piece that he/she is good at, and is suited for.  When they all\nwork together, the result can be a very good one.\n\n      Why is this so?  It is because each person in life, is given a set\nof capabilities and abilities, different from everybody else's.  And the\ntendency of each person is (more or less) to gravitate to the things\nhe/she likes, and is good at doing.  At this point, you can notice a\nkey difference between commercial organizations and Open-Source\ndevelopment efforts:\n\n      Within a commercial organization, the abilities of the different\npeople dovetail.  Each one is hired for a job that he/she is good at.\nBut in commercial organizations, there is a \"Personnel Department\" that\noversees the picking of people for tasks.  The overall purpose of the\nPersonnel Department is to make sure that each task which the\norganization needs done, will be covered by the appropriately skilled\npeople.\n\n     But in an Open-Source development effort, the difference is that\nthere's no \"Personnel Department\" to hire, fire, and assign people to\ntheir tasks.  It seems to happen \"by itself\", but it happens\nnevertheless.\n\n     It's amazing how Open-Source development actually does work:\nPeople get the idea that it'd be a nice thing to get a big job done.\nThey get together and try--each one does a piece, the best he/she can.\nThere is a coordinator, who plans the tasks, and then they start\nworking.  A prototype product is created by the initial developers.\nOther people try to use the \"product\" that results.  It needs\nimprovement.  The appropriate people are notified through the \"news\ngroup\" that serves as a unifier and \"central nervous system\" for the\neffort.  And the effort goes on, each contributor adding his own\npersonal pieces.  New contributors come on board.  And the product\ndevelops and grows, until (hopefully) it becomes very good.\n\n\nIMPLICATIONS FOR US AS THE \"MVS DOCTORS\"\n\n     Now that I've spoken \"in general\", I'd like to talk about some\nimmediate implications as to how these concepts affect us.\n\n     Most of us occupy positions in servicing the MVS Operating System\n(OS/390, z/OS, or whichever version).  So every once in a while, we\nshould think about where our position is, in the larger scheme of\nthings, and whether we can do more.  Of course, in our own job and\norganization, we perform our required tasks, and keep the system\nrunning.  But while we have been doing this, usually for many years,\nwe're writing programs, REXX execs, CLISTs, and whatever tools we need,\nto get the job done.  We're accumulating techniques, and (some of us)\nwrite them down.  Hopefully we save all this stuff and keep it with us\nas we proceed in our careers.  (That's good advice.)  It can be safely\nstated that each of us has developed a niche (the kind of jobs we're\nskilled at doing) and also, a personal collection of techniques,\nprograms, and tools.\n\n     But each of us can become more aware of our position in the general\n\"world system programmer picture\".  One of the things we can do, is to\ncommunicate more with the other MVS (VTAM, CICS, TCPIP, etc.) systems\nprogrammers of the world.  An easy way to do this, is by using the\nInternet news groups.  There are now news groups which cover just about\nevery specialty.  (See my April 1998 column on the IBM-Main\nLISTSERV-based news group.)  And it's easier, by participating in a news\ngroup, to get all your (work) problems solved, and to get the enormous\nsatisfaction that comes with helping others, too.  This is actually a\ndirect benefit of the idea of looking at yourself as \"part of the whole\nworld\".\n\n     Another benefit of \"MVS Global Awareness\" comes from hooking into\nthe large free MVS software collections such as the CBT MVS Tape\ncollections, which are available on the Internet (www.naspa.com has a\nlink to the CBT Tape web site.)  Enormous numbers of MVS tools can be\nhad there, for free.  And by contacting the contributors of the\nindividual files personally, you can develop a friendship with many of\nthe other MVS practitioners, asking them for help, if you need some,\nand providing help to them, if you can.\n\n     Under many circumstances, there is a tremendous advantage to using\ntools from the CBT Tape collection when your shop needs a job done.  The\njob can usually get done without the shop having to buy anything.  And\nit'll save you personally, that you don't have to write the code\nyourself.  Other people have already invented the wheel!  You'll look\nvery good at work, when you can come up with a solution to a problem\nfast, especially if it doesn't cost the shop money or much coding time.\n\n     A new advantage from the CBT Tape collection is the swapping of\ntechniques.  There is a new file on the CBT Tape, File 570, which\ncontains people's tips on \"how to do things\".  The first contribution\nwas a piece of advice about where to look, when your JES2 spool fills\nup.  There have been quite a few more contributions, but in my opinion,\nthat file, while already very useful, should be bigger.  Please send me\nyour collections of pieces of \"how to do it\" advice (I'm in charge of\nupdating that), and I'll add them to File 570.\n\n     Another related idea, is that many of you will be able to get\nenormous personal satisfaction in life, if you'll contribute from your\nexperience (and tool and tip collections), to some piece of public work,\nsuch as a software development effort, or a public software collection\nlike the CBT Tape, yourselves.  Helping other people is a good thing.\nSome folks don't realize how much of a mistake it is for them, to hold\nback from helping other people.  I've seen how much a person\nshort-changes HIMSELF by being \"selfish\" and holding back from giving.\nThe best way to have friends is to \"be a friend\", and to \"not hold\nback\", but to give something of yourself to another person who needs it\nNOW.  Life has shown, over and over, that the benefit of giving\nsomething will eventually come back to you, in spades!  It's an\nunder-used principle in life.  More people should know it.\n\n     Sorry for the generalities this month.  But I've been an MVS\nsystems programmer for many years.  And these ideas have helped me more,\nto be a good MVS systems programmer, than many others.  I think that\nthey are relevant to our job, and they should be specifically expressed\nat least once.\n\n     Best of luck to all of you, and I hope to see you again, next\nmonth.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0208SE": {"ttr": 24069, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00W\\x01\\x02\"_\\x01\\x02\"_\\x18\\x13\\x00\\xe2\\x00\\xe3\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-08-13T00:00:00", "modifydate": "2002-08-13T18:13:57", "lines": 226, "newlines": 227, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                        SEPTEMBER 2002\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@attglobal.net and/or sbgolob@aol.com.\nThe Online CBT Tape web site has its own URL.  However, it can also\nbe reached from the \"Members Only\" section of www.naspa.com .\n\n\nRECOVERY TOOLS\n\n      Today I'd like to update some information on a favorite Sysprog\nsubject:  How do you fix your MVS system when it won't come completely\nup at IPL time?\n\n      Upon MVS initialization, what can go wrong?  I'll give some common\nexamples.  Sometimes a PARMLIB member is bad, so the system coughs when\ntrying to read it, and it won't come up past a certain point.  Sometimes\na PROCLIB member, which is needed for the system to come up, is bad or\nmissing.  Sometimes, it's JES parms, or some other initialization\nparameters.  Often, the error lies in such an essential component, that\nTSO will not be initialized.  Sometimes, you can get far enough to bring\nup TSO, but then you can't initialize ISPF.\n\n      Whenever such a situation happens, you would not want to have to\nback off all your changes, bring up the old system to do the fix, and\nthen have to bring up the new system all over again.  Wouldn't it be\nnicer to fix all the changes on the current (crippled) system, and then\nbring it up the rest of the way?  Or at least, it would take less time\nto fix the crippled system, bring it down (since it is only partially\nup), and then bring it back up, completely corrected.  When the IPL time\nwindow is limited, you can be a real hero if you have tools to fix the\nproblems, directly from the new system, in less time.\n\n      So I'm going to show you how, with a little forethought, you can\nput some good recovery tools (which are free) into your system.  Then,\nif a situation occurs during a partial IPL, you might quickly be able to\ncorrect the situation, directly on the system you're trying to bring up.\n\n\nHOW EARLY CAN YOU RUN A TSO COMMAND?\n\n      For recovery purposes, the usefulness of any tool depends on how\nmuch of the system it needs, in order to function.  For example,\nnormally a TSO command needs the fact that TSO has come up.  However, if\nthe particular TSO command is a line-mode command, meaning that it does\nnot issue FULLSCREEN TPUTs, then there is a way to run it, at a far\nearlier stage in the IPL process.  TSO does not have to be up at all.\nThis applies to TSO commands such as RENAME, PDS85 (the free PDS Utility\npackage), LISTD, LISTC, and many others.\n\n      But this needs prior preparation.  There is a free software\npackage called TSSO, which runs as a subsystem, and which can be started\nunder SUB=MSTR.  The TSSO package sets up a console-based TSO-like\nenvironment, capable of running TSO commands.  But the commands are\nentered on the system console, and their results are reported back on\nthe console, too.  Thus, we have a line-mode TSO-like environment, that\ncan run TSO commands without TSO.\n\n      The advantage of running TSSO, is that you can START TSSO,SUB=MSTR\nalmost as soon as the console itself comes up.  Then, you can do dataset\nrenames, catalog lists, and (when running PDS85 under TSSO) you can\neven do string searches and substitutions in datasets and pds members,\nand you can run IEBCOPY.  All this can be done right near the beginning\nof the IPL, as soon as you have a console.  So you can fix that bad\nPARMLIB member, or copy a good member from another library.  If you are\nvery skilled in using the PDS85 package's subcommands, you can do many\nmore things, with only a console available, that you never thought you\ncould, such as creating ALIASes to pds members.\n\n      How can you get TSSO?  There are two different versions of TSSO\non the CBT Tape collection of free MVS software.  The original TSSO\nversion, from Bill Godfrey, is on File 306, and the modified souped-up\nfree Bellcore version (which includes an auto-ops piece too) is on File\n404.  The CBT collection is available (for free) on the web.\nwww.naspa.com has a link to the CBT web site, and the site also has its\nown URL.\n\n      If you need to run an authorized TSO command under TSSO, you\nshould know that the TSSO started procedure looks very much like a TSO\nlogon proc, except that you EXEC PGM=TSSO, instead of executing program\nIKJEFT01.  So the TSO command authorization procedure that uses the\nIKJTABLS module in an authorized STEPLIB (see CBT Tape Files 185 and 186\nfor details) should apply to TSSO as well as to TSO.  You might have to\nexperiment a bit to get this to work, but once you have set up TSSO the\nway you want it, there's a lot less to worry about, in an IPL recovery\nsituation.\n\n      We have a late-breaking bulletin.  Rob Prins, the author of the\nRPF editor we shall mention shortly, has donated his TSTVS console-based\nline editor to the CBT Tape collection.  TSTVS can be run under SUB=MSTR\nand can be found on File 068 of the CBT Tape.  Try it--you'll like it!\n\n\nTOOLS FOR TSO WITHOUT ISPF\n\n      Once TSO can come up, you have a much larger selection of recovery\ntools available, because you now have the advantage of being able to do\nFULLSCREEN TPUTs, and you can execute the TSO commands normally, not\nbeing limited to looking at a line at a time.  The problem for many of\nus, under this situation, is that we have become accustomed to\naccomplishing most of our tasks, using the tools in ISPF, and many of us\nhaven't become sufficiently accustomed to accomplishing the same things\nusing native TSO commands.\n\n      Fortunately, the situation has been made easier with the\navailability of some good tools that run under \"raw TSO\" without needing\nthe presence of ISPF.  Three of these tools are RPF (\"Rob's Programming\nFacility\", which has a full screen editor that feels a lot like the ISPF\neditor), REVIEW, and Fullscreen ZAP.  RPF was originally written in the\nmid 1980s by Rob Prins, who used it for himself and for the programmers\nat his installation in the Netherlands.  With the emergence of the\nHercules emulator, and people running the vintage-1975 MVS 3.8 under it,\nRPF became the editor of choice for that environment.  Rob has allowed\nthe Hercules people to use RPF, but it runs under OS/390 too, and Rob\nhas donated RPF to the CBT Tape collection, in File 415.\n\n      RPF requires a small amount of setup.  RPF's profile file, which\nkeeps all of your operational defaults, is a VSAM file that should be\npre-prepared and already available, when you plan on using RPF.  But the\ntruth is that RPF will do quite a few of its functions, without the\nprofile file being there.  You just need a bigger REGION size.\n\n      RPF not only contains a good fullscreen editor--it has quite a\nfew utility functions, such as the ability to list VTOCs, grab members\nfrom Librarian or Panvalet libraries, and do other neat things to\ndatasets and pds members.  These other RPF functions are worth exploring\nand setting up, so that you get them to work properly.\n\n      RPF is one example of an older MVS tool which has emerged from the\n\"software closet\" because of the Hercules effort.  Since most people who\nrun Hercules, run MVS 3.8, and MVS 3.8 does not have ISPF, it comes out\nthat the very sophisticated RPF product, which Rob Prins is now\nconstantly improving, has come to the fore as quite an adequate ISPF\nsubstitute (if you can't have real ISPF).  But remember, when \"real\nISPF\" won't come up (under OS/390 or z/OS), you can also use RPF--it's\nthe same situation.  So for OS/390 recovery purposes, RPF is a\ntremendous new gift.  You should install RPF for yourself, and learn how\nto use it, before you have an emergency and really need it.\n\n\nREVIEW AND FULLSCREEN ZAP\n\n      I have written about Greg Price's souped up REVIEW command, which\nis basically an extremely capable Fullscreen Browser that works under\nnative TSO, but which could use ISPF if it is available.  (See the\nFebruary 2002 installment of this column.)  It is not commonly known\nthat REVIEW, besides being a browser (you can look at bad PARMLIB\nmembers with it), also allows you to copy pieces of files and/or pds\nmembers, to another dataset.  REVIEW can also look at VSAM files and\nother MVS objects that are hard to examine directly, without ISPF or MVS\nDITTO being available.  Using REVIEW's NEWTOP operand with a TTR, you\ncan even examine pieces of files that would have had I/O errors, if you\nhad tried to look at the whole file.  The NEWTOP operand starts REVIEW\nat a given TTR within the dataset--not necessarily from the beginning.\nThis technique can also be used to look at deleted members in a pds, if\nyou know the TTR that they start at.  And you can rescue them, using\nREVIEW's copy facility.  REVIEW can be obtained in File 134 of the CBT\ncollection, and the load modules for it, can be found on File 135.\n\n      It has been some time since I've devoted a column to discussing\nthe amazing Fullscreen ZAP TSO command.  The last time I wrote about it\nin detail, was in March and April 1992.  Fullscreen ZAP, originally\nwritten by systems programmers at UCLA, and souped up by Greg Price,\ngives you the ability to examine the block structure, and change any\nbyte, inside a dataset.  And with the FULLVOL operand of Fullscreen ZAP\nfrom Greg Price, which has to be run authorized, Fullscreen ZAP will\nallow you to search for strings and change any byte on an entire DASD\npack, whether that information was in a deleted dataset, or an active\ndataset.\n\n      You may not need Fullscreen ZAP in normal IPL recovery situations,\nwhere the problem is usually some bad PARMLIB or PROCLIB member that has\nto be edited or renamed.  But you should remember that Fullscreen ZAP is\none of those TSO commands that does not need ISPF to operate, and\ntherefore it is a candidate for use in IPL recovery situations, when TSO\nis up, and ISPF is not.  You can read what I've written about Fullscreen\nZAP in my old columns, by getting File 120 from the CBT Tape collection,\nwhich contains most of my old \"Technical Support\" columns.\n\n\nANOTHER RECOVERY TOOL\n\n      There is one other free IPL recovery tool worthy of mention, which\nadmittedly is old, but it does the trick sometimes.  This is the ETPS\n(Emergency TeleProcessing System) package by Brian Cook, that is in File\n353 of the CBT Tape collection.  ETPS functions by grabbing one 3270\nterminal, and doing \"native 3270 I/O\" to that terminal, without using\nVTAM.  So ETPS will help you early in the IPL, way before VTAM comes up.\n\n      ETPS contains a primitive editor, which works well enough in\nrecovery situations if you know how to use it, and it also includes some\nIDCAMS front-end utilities and a few other doo-dads.  There is also a\nTSO front-end, to run ETPS when your system is normal, so that you can\npractice using the ETPS editor under quiet non-emergency conditions, and\nthen you'll be prepared to face anything else.\n\n      My recollection of the ETPS editor is that is sometimes will put a\nspurious character into the new line of a file being edited, but you can\neasily spot the bad character and delete it out, before any harm is\ndone.  If you get familiar with the eccentricities of the ETPS editor\nbeforehand, it can be a remarkably effective recovery tool, later on\nwhen you (hopefully don't) need it.\n\n      There is at least one vendor product that does the job of ETPS\nmuch better (it's a standalone editor which works in a similar way as\nETPS, but the bugs were taken out and many new facilities added).  But\nthe price of ETPS is right (i.e. free), and ETPS can help you.\n\n\nPREPARATION\n\n      All of the tools that I've mentioned, require prior installation.\nAnd you have to practice using them, in order that they'll be effective\nrecovery tools for you in an IPL emergency.  But once you're good at\nusing these tools, you'll be able to solve a lot of other system\nproblems besides the IPL problems.  And in a pinch, you may be able to\nsave the day at IPL time.  Best of luck.  I hope to see you again next\nmonth.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0209OC": {"ttr": 24074, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02%?\\x01\\x02%?\"\\x06\\x00\\xf2\\x00\\xf2\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-09-10T00:00:00", "modifydate": "2002-09-10T22:06:00", "lines": 242, "newlines": 242, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         OCTOBER 2002\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@attglobal.net and/or sbgolob@aol.com.\nThe Online CBT Tape web site has its own URL.  However, it can also\nbe reached from the \"Members Only\" section of www.naspa.com .\n\n\nDEVELOPMENTS IN FREE MVS SOFTWARE\n\n      Everyone knows that it's a big chore to keep up with developments\nin MVS, and in the related fields.  Most of the time, you usually have\nenough trouble following all the changes which are directly related to\nyour own everyday work.  But since I'm the proprietor of the CBT Tape\nmaterials, and I get to see and process all the new contributions that\ncome into that collection, I feel obligated from time to time, to\ninform the general MVS public about many of the new useful tools which\npeople have created and donated for public use.  Some of them might be\nhelpful to you.  I sense that if I don't talk about them here, some of\nyou good folks might never get to properly profit from using these fine\ntools.\n\n      So this month, I'm going to write about a potpourri of different\nthings which have arrived in the CBT MVS Tape collection recently.  From\nMay 1, 2002 until September 9, 2002 alone, there have been 117 files on\nthe CBT Tape that have either changed or which have been added.  Many\npeople don't realize that there's so much good material to be had.  You\ncan also obtain the stuff very easily, and it's free.  The CBT MVS\ncollection is available on the Internet, with a link to its URL on\nwww.naspa.com.\n\n\nHOT DEVELOPMENTS\n\n      Whenever one has to talk about new developments, a decision has to\nbe made about \"what's hottest\".  I'll start by mentioning improvements\nto some tools that I know many of you use.\n\n      The free PDS package (CBT File 182) at the 8.5.22 level, has a new\ngimmick so that you can now deal with members of a PDSE.  Previously,\nthe free PDS command didn't have any PDSE support at all.  Now, it\nfinally has some.  The problem for the PDS command is that it does a lot\nof its member I/O using EXCP, and IBM doesn't officially support an EXCP\ninterface to PDSE members.  So John Kalinich, who currently supports the\nfree PDS package, wrote a REXX exec (called \"PDSE\") that does BLDLs\n(supported by IBM for PDSEs of course) to gather member information for\nthe PDSE members, and to feed the information into a member subgroup of\nthe current dataset that the PDS package is pointing to (if it is a PDSE\nor a PDS).  This is done with the PDS package temporarily switched to\n\"line mode\" (or XISPMODE) operation.  Then, when the REXX exec is done,\nyou switch the PDS command back to ISPMODE operation, and behold, you\ncan get a bona-fide (partial or complete) member list for your PDSE\ndataset.  Just follow the enclosed directions, to do it properly.\n\n      You can perform all operations on the PDSE members in that list,\nwhich don't require doing EXCP I/O.  Some of the operations to PDSE\nmembers which you can now do (after running the REXX and obtaining the\nmember list) are:  ALIAS, DELETE, DIRENTRY, EDIT, BROWSE, COPY, COMPARE,\nREVIEW, RENAME, and VIEW.  These operations can now be run as line\ncommands from the PDSE member list.  Remember that the PDS package has\nto be at least at the 8.5.22 level, distribution date (in the $$$#DATE\nmember) of at least 09/04/02, for this to work.\n\n      Next, I'll talk about SHOWMVS 7.05, which is its newest level as\nof the time of this writing.  SHOWMVS is a TSO command that displays an\nenormous amount of system information, which is buried in the real\nstorage control blocks of your MVS system.  The SHOWMVS display is (in\nthe usual mode of operation) ISPF BROWSEd to your terminal, using the\nISPF BRIF service, but every time you press ENTER, a subtask is\ntriggered, that updates the ISPF display in real time.  (This is\nsomething that many people don't know about SHOWMVS.)  The comments at\nthe beginning of the SHOWMVS source code (on CBT File 492) tell you the\ndetails, and a lot of related information.\n\n      SHOWMVS can now output its information to a TCPIP destination.\nInstructions for doing that, are also at the beginning of the SHOWMVS\nsource code.  There are actually six different output display modes for\nSHOWMVS output, and they are all described in the SHOWMVS source code\ncomments.  I'm sure that if you look these over, you'll find a lot of\nthe information enlightening and useful.  SHOWMVS is not on CBT File 183\nanymore, but it now resides on CBT File 492, because Gilbert Saint-flour\n(SHOWMVS' original author) is now not its main support programmer.  That\njob has now been taken over by Roland Schiradin, and others.\n\n      MXI is another ISPF-based program which shows a wealth of\nreal-time MVS system information, and its author, Rob Scott, has now\nupgraded it to Version 4.1, also sporting a TCPIP interface.  MXI can\nbe found on CBT Files 409 and 410, and Rob Scott's other utilities,\nnotably his VTOCUTIL program, can be found on Files 411 and/or 412.\nEven though I'm not spending much time here talking about MXI, it is\nreally just as useful as SHOWMVS, and since the two programs are very\ndifferent in look, feel, and some content, they complement each other.\nBoth programs are extremely useful (for us \"system doctors\").\n\n      I'll include one more item in this \"hot\" category, mainly because\na lot of people don't know that it exists, and also because there was a\nlot of discussion about the topic on the IBM-Main forum about a year\nago.\n\n      There used to be a program called MCNVTCAT, which was distributed\nby IBM with CBIPO and CBPDO orders.  That program would read a LISTCAT\nof your master catalog (or a usercatalog), and it generated IDCAMS\nDEFINE statements so you could re-create all the non-VSAM catalog\nentries in a newly-defined (master or user) catalog for a new MVS\nsystem.  Using the MCNVTCAT program would eliminate the need for catalog\nconversion (via EXPORT-IMPORT or REPRO) when you were building your new\nMVS system, so it was very useful, because it kept your new catalogs\n\"clean\".  You could control their content very carefully and\nspecifically.\n\n      Nowadays, the MCNVTCAT program is \"officially unavailable\" from\nIBM.  There's a reason for that, which makes perfect sense if you know\nIBM.  Since the MCNVTCAT program is copyrighted by IBM, we could not put\nit on the CBT Tape, and because of various other reasons, IBM groups\nwould not post the program on any of their web sites.  So you can't get\nMCNVTCAT today, unless you'd saved it for yourself, during one of your\nprevious MVS installations.\n\n      We now have an improved substitute for MCNVTCAT available, and\nit is in the form of a REXX exec called RCNVTCAT, which was written by\nAlastair Gray.  RCNVTCAT (together with many of Alastair's other nice\nutilities) can be found on CBT File 542, and it has received good\nrecommendations from its users.  We don't need the actual MCNVTCAT\nprogram anymore, and we can say our \"thank-yous\" to IBM, for originally\nhaving creating it, giving us the idea, what to do.\n\n      Before leaving the \"hot\" area, I have to mention Lionel Dyck's\nenormous collection of utility packages, which is now so big, that I had\nto spread it over two files (312 and 313) on the CBT MVS collection.\nWhile I'm not going to specifically enumerate all the wonderful tools\nthat Lionel has brought to us, I have to mention that one of them,\nXMITIP (which allows you to send email directly from an MVS system),\nhas already spawned its own news group (xmitip@yahoogroups.com).\n\n\nOTHER NEWLY-AVAILABLE UTILITIES\n\n      All MVS utility programs are useful when you need them.  Therefore\nI can't say that the following tools are \"less useful\" than the ones\nI've mentioned above.  However, they are probably less well known, and\ntherefore less widely used.  But by mentioning them here, we may remedy\nthat situation.\n\n      Several fine utilities are from Rob Prins.  Two of them, RPF, and\nRPF/E (CBT Files 415 and 417 respectively) are file editors, plus other\nutilities.  And both of them have both Panvalet and Librarian\ninterfaces.  RPF was written for the pre-XA world, while RPF/E was\nwritten to run above the 16M line, and therefore RPF/E can edit much\nlarger files.  Both of these editors have a look and feel that is very\nsimilar to ISPF, and once you've gotten used to them, it's just a slight\n\"shifting of gears\" between them, and ISPF EDIT.\n\n      Rob Prins has contributed another tool as well.  It is called\nTSTVS, and it is a console-based line editor, to be used for fixing\nPARMLIB and PROCLIB members when the system can't come completely up.\nI've personally used TSTVS, and I like it very much.  TSTVS is found\non File 068 of the CBT collection.\n\n      Several contributors have either recently sent, or recently added\nto, REXX functions and REXX function collections.  Robin Ryerse (CBT\nFile 520) has recently added to his already nice collection of REXX\nfunctions.  Sergey Makogonov (File 588) has contributed a REXX function\nwhich adds operator control functionality.  These are in addition to\nsome of the existing REXX function packages on the CBT Tape, by Gerard\nNicol (Files 323 and 324), Steve Bacher (File 431), and Jan Jaeger (File\n437).  And we mustn't forget to mention Mark Winges' REXX VSAM-handling\nfunctions (File 268) which have recently been upgraded.\n\n      The \"how to do this job\" file, File 570, is slowly growing also.\nRecently Dave Kulas has made a contribution, telling you how to set up\nyour own \"user SYS1.PARMLIB\" on an MVS system (member UPARMLIB).\n\n      The author of the CBT Tape's original disassembler (on File 217),\nDick Thornton, recently wrote a modern, 21st Century version of his old\ndisassembler (on File 234), and has contributed a very large collection\nof much of his life's work (Files 558 thru 565) for the public good.\n\n      Mark Zelden (File 434) has a truly marvelous collection of\nlargely REXX-based tools, and he updates it frequently.  One of them,\ncalled IPLINFO, is like a \"short SHOWMVS\", but instead of being\nassembler-based, it is REXX-based, and it is a tribute to the\nflexibility and great capability of the REXX language under MVS-TSO.\n\n      ISPF assistance is provided by Tom Conley's DYNISPF package (File\n495), for independently starting ISPF applications and freeing their\nresources when they have ended.  And recently a beautiful ISPF\napplication starter called SS has been contributed by Robin Murray (File\n586).  Fellow \"TS\" columnist Jim Moore, has contributed his PROFSET and\nEDPROF edit macros (File 583) for setting up your ISPF session edit\nparameters.  These edit macros are the basis for his \"Technical Support\"\narticles on the subject of ISPF EDIT profiles.  Roy Gardiner (File 578)\nhas contributed a tool to make it easy to write programs that do ISPF\ntable handling.  These are just some of the \"recently updated\" things.\nThe CBT collection actually contains a lot more ISPF helper tools.\n\n      While I'm on the subject of ISPF, there were recent contributions\nof ISPF \"frontend\" interfaces, one by Mick Sheehy (File 576) to make it\neasy to copy datasets, and one by Solomon Santos (File 555) to make it\neasy to run the TSO XMIT command.  Besides this ISPFXMI package from\nSolomon Santos, File 555 contains a nice collection of his other tools\nas well.\n\n\nHERCULES-BASED TOOLS\n\n      I don't have time to mention OS/VS2 (MVS 3.8) retro-computing\ntools here, and I've covered the topic fairly well in a previous column\n(July 2002).  But some of the more recent CBT contributions inspired by\nMVS retro-computing are worthy of mention.  On File 035 (source on File\n296), I've restored aliases of the BLKDISK TSO command, that makes it\neasy to calculate disk space capacity, so you can perform disk\ncalculation for older DASD devices.  For example, besides being able to\ncalculate space for the more recent devices, using BLK3380, BLK3390, and\nBLK9345 aliases of BLKDISK, you can now (courtesy of retro-computing\nneeds) calculate space for 2305-1, 2305-2, 2314, 3330, 3330-1, 3350, and\n3375 devices.  If you don't really need this for your own requirements\n(on OS/390 for example) you can at least try some of your space\ncalculations on, say, 2314's, and you can appreciate the recent\nimprovements in disk technology much more.\n\n      And Hercules tape and disk compression technology, (which in my\nopinion, is more advanced than some modern tape and disk technology),\nhas inspired the HETUTL program (from Leland Lucius) to create (on any\nMVS system) compressed tapes usable by Hercules.  And DASD-wise, an\nMVS-based version of the CCKD (Compressed-CKD) creation program from\nGreg Smith, can be found on File 541.  Using the MVS-based CCKD program,\nyou can create a compressed copy of any of your mainframe DASD disks,\nthat you can FTP to a PC and use as \"real DASD\" under Hercules.\n\n      So in summary, you see that there has been a lot going on, in the\n\"public sector\" of modern MVS computing.  And I hope this stimulates you\nto go to the CBT web site and investigate these new developments in more\ndetail.  I wish you all the best of everything, and I hope to see you\nhere again, next month.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0210NV": {"ttr": 24323, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02(?\\x01\\x02(?\\x07\\t\\x01:\\x01:\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-10-10T00:00:00", "modifydate": "2002-10-10T07:09:00", "lines": 314, "newlines": 314, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         NOVEMBER 2002\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.  The Online CBT Tape web site has its own URL.\nHowever, it can also be reached from the \"Members Only\" section of\nwww.naspa.com .\n\n\nTHOUGHTS ABOUT ASSEMBLER MACROS\n\n      Assembler macros are normally a good way to shorten your coding\nsteps.  You code one macro instruction instead of a bunch of normal\ninstructions.  And usually a macro is made to stand for a concept or a\ncomplete operation, where one normal instruction is not available to get\nthat particular job done.\n\n      When you code one macro instruction, the Assembler uses the macro\ndefinition (which is either inline in the source code, or it has been\nstored in a pds) to create a sequence of several (or many) instructions\nthat will execute the complete concept, or the complete operation.  But\nin your coding, it is only one \"instruction\".  Therefore, having a macro\ndefinition available makes the coding clearer, in a way that follows\nyour thought processes.  Instead of having to code a complicated\nsequence of instructions, whenever you want to get a certain single job\ndone, you just have to code one macro instruction, and possibly a few\nparameters along with it.\n\n      This is the CONCEPT of why you might want to have \"macro\ninstructions\" in the Assembler language.  But the actual implementation\nof how a macro instruction is interpreted, and how it is expanded by the\nAssembler, makes it possible for macro instructions to do far more than\njust this.  Today, we're going to talk about things like how macros can\nactually be used to simulate real Assembler language instructions, using\nother Assembler language instructions.  In other words, we'll talk about\nhow macros can be used to \"enlarge\" the Assembler's instruction set.\n\n      Why would one want to simulate an assembler instruction by using a\nmacro?  One reason, is that a person didn't get the newer version of the\nAssembler, which supports \"new instructions\".  This happened in the\nearly days of MVS/XA, when the old IFOX00 Assembler wouldn't assemble\nthe new \"XA instructions\".  Another place where this could happen, is\nwhen you're running ancient (circa 1975) MVS 3.8 on a Hercules emulator,\non your PC.  If you can't run a modern assembler (HLASM or ASMH, which\nhas to be licensed from IBM) and you're restricted to using IFOX00 (the\nold free XL assembler), and you want to assemble more recently written\ncode, you'd be stuck.  But if you use macros to simulate the more recent\nassembler instructions, then you can also assemble some more recent\ncode, using the old system as a base.\n\n      I knew of a software house which couldn't afford (for a while) to\nbuy Assembler H Version 2, which you needed to assemble code for XA (and\nthey supported code for XA).  What did they do?  They wrote a set of\nmacros, to run under the older IFOX00 Assembler, which produced the same\neffect as if the new instructions were assembled using IEV90.  IEV90 was\nAssembler H version 2, the precursor of HLASM, IBM's most current \"High\nLevel Assembler\" product.  You can see this company's macro collection\nin File 177 of the CBT Tape collection, as member OPCODES.\n\n      File 177 also contains a far larger collection of instruction\nsimulating macros, which comes from Jan Jaeger, and which is the result\nof the Hercules effort.  Jan Jaeger's macro collection, which expands\ninto a large macro library called SYS1.MNEMAC, allows the IFOX00\nassembler to correctly assemble very modern instructions, including most\n(or all) of the 64-bit instructions which are available as of the time\nof this writing.\n\n      IBM has always provided several large collections of macros, for\nthe purpose of allowing you (as a coder), and them (internally), to\naccess many system services in a relatively simple way.  IBM's two main\nmacro libraries are (nowadays) called SYS1.MACLIB and SYS1.MODGEN.  (In\nearlier systems, you sometimes had to use SYS1.AMODGEN instead of\nSYS1.MODGEN.)  You use SYS1.MACLIB and SYS1.MODGEN in a source code\nassembly by allocating them to the assembler, coding the SYSLIB DD card\nin the assembly JCL.  And of course, you can add your own macro\nlibraries to the assembly, by concatenating them with SYS1.MACLIB and\nSYS1.MODGEN in the SYSLIB DD statement of the assembly JCL.\n\n      I've observed one more thing about the use of macros, and you\nmight find it useful to make a mental note of this.  Vendors of\ncommercial software tend to use many more macros than other coders.  Of\ncourse, a programmer's use of a macro, instead of coding the\ninstructions in \"longhand\", is often a matter of personal preference and\ntaste.  But I've gotten a lot of exposure to seeing free code (largely\nfrom the CBT Tape software collection), and I've also worked as a coder\nfor software vendors.\n\n      My observation is that a software vendor, who doesn't let the user\nsee the source code of their product, has a great tendency to use a very\nlarge collection of their \"homegrown\" macros in their coding.  The folks\nwho write free code, tend not to bother coding too many macro\ndefinitions of their own, unless they really need them.  I think the\ndifference comes because the software vendor coders have created their\nown coding environment, which tends not to change too much, and which\nthey keep \"in-house\".  All of their assemblies include their own macro\nlibrary, as a matter of course.  And they don't show these macros, or\ntheir other source code, to outside people.  So the macros stay with the\nsoftware house--they aren't meant to be moved from place to place.\nTherefore there's no burden of having to carry a big macro library\naround, just in order to be able to assemble your software.  The big\nproprietary macro library stays put, and doesn't have to be moved.\n\n      The \"free coders\", on the contrary, tend to write programs in a\nmore isolated and \"ad hoc\" fashion, so they don't have so much of a\n\"proprietary environment\" of their own, and they also want to make their\nprograms more portable.  After all, if they move from shop to shop, they\nwant to take their programs with them.  So they don't want to burden\ntheir code with a huge set of macros that they'll have to take from\nplace to place.  Therefore they tend not to use anywhere nearly as many\n\"personal macros\" in their coding as the vendors will.\n\n\nBASICS\n\n      In order for an assembler macro, which isn't an assembler\ninstruction, to be available when assembling a source program, its code,\nwhich is called a \"macro definition\", must reside in either of two\nplaces.  One place is called a \"macro library\", a pds that is accessed\nvia the SYSLIB DD card in the assembler JCL.  The other place is for\nthe macro to be \"inline\" with the program source.  In that case, the\nmacro definition must be preceded by a MACRO assembler instruction, and\nended by a MEND assembler instruction.  (Macros included in a \"copy\nmember\" are, of course, copied inline into the source code, so they\nbecome inline macros, and they don't belong to a separate category.)\n\n      A very simple macro definition can be seen in Figure 1.  The name\nof the macro is REGS, and it can be stored in a macro library, as pds\nmember name REGS.  If this macro is made available to an assembly of\nsource code, and if you code REGS in the assembler source, then the\nassembler will generate the following 16 lines of code, starting with R0\nEQU 0, and so forth.  Therefore, if you code the REGS macro, your code\nhas been shortened by 15 lines.\n\n      Macros (of course) are not all this simple.  The assembler macro\nlanguage, which relies very heavily on \"conditional assembly language\",\nis an extremely rich and capable facility that allows macros to accept\nparms and defaults.  The \"official\" place to learn about all these\nmatters, is in IBM's HLASM Programmer's Guide (SC26-4941), and the HLASM\nLanguage Reference (SC26-4940), which are available from IBM on their\ncd-rom manual collections, either in Bookmanager or PDF format.\nHowever, just because macros CAN be complicated, they don't have to be.\nIf you want to code some simple macros for yourself, just to shorten\nyour coding work, that's not a bad idea, and it'll give you a good\nstart, so that you can get more ambitious later.\n\n\nUSING MACROS TO SIMULATE INSTRUCTIONS\n\n      An interesting application of the macro language, as we said\nbefore, is to simulate machine instructions that an older version of the\nAssembler doesn't know about yet.  One example where the Assembler now\nwould \"know\" about more instructions, is in the jump between HLASM\nRelease 3, and HLASM Release 4.  HLASM Release 3 was pre-OS390 2.10.\nHLASM Release 3 did not incorporate \"knowledge\" of the 64-bit machine\ninstruction subset.  But HLASM Release 4 \"knows\" about the many new\ninstructions, which are incorporated in the 64-bit instruction subset.\nAt the time of this writing, there are still many installations whose\ndefault Assembler is not yet HLASM Release 4.\n\n      Please look at Figure 2.  There, we see two ways to use a macro\nto generate the same result as is produced by the BASSM instruction.\nEven if an old Assembler was used for the assembly, the result produced\nis equivalent to what gets generated by a new version of the Assembler.\nAnd the assembled program can be run on a new machine, which is able\nto understand the new instruction set and execute it.\n\n      You'll notice the difference between the two macros illustrated\nin Figure 2.  Both of them generate the exact same machine code.  But\nthe first macro uses another instruction (BALR) as a model for getting\nthe BASSM machine code to be generated.  The second macro uses the\nAssembler's own ability to calculate different types of constants, to\ngenerate the exact same result, as if a newer Assembler were assembling\nthe BASSM instruction.\n\n      It's obvious that in order to assemble the first macro, the old\nAssembler program has to \"know\" how to assemble the BALR instruction.\nBut to assemble the second macro, the Assembler doesn't have to \"know\"\nabout the BALR instruction at all.  There is no dependency, in the\nsecond macro, on the Assembler \"knowing\" about any other instruction.\nAnother advantage of the second macro, is that in doing things the first\nmacro's way, you have to be absolutely sure that the \"model\" instruction\nworks exactly like the newly simulated instruction.  Of course, if the\n\"Principles of Operation\" manual says that the two instructions are\nphysically constructed the same way, that's pretty safe, but maybe there\nmight be some small, hidden margin for error.  But with the second\nmacro, you just have to be sure you know how the new instruction works.\nThere is no dependency at all, on how another, different instruction\nactually works.\n\n      These two examples came from File 177 of the CBT Tape.  The first\nexample was written by the software house (mentioned above) in the early\nMVS/XA days (circa 1983).  That's the example which was dependent on the\nAssembler knowing how another instruction works.  The first example can\nbe found as part of the OPCODES member in File 177 of the CBT Tape.\n\n      The second example was created by the Hercules effort.  Hercules\nis a program, written mostly in C, which simulates S/390 instructions on\na PC.  Users of Hercules usually run MVS 3.8 (OS/VS2), which only\ncontains the IFOX00 Assembler program.  So to give someone running\nOS/VS2 the ability to assemble \"new code\" using IFOX00, an entire macro\nlibrary that simulates new instructions, called SYS1.MNEMAC, was\ncreated.  SYS1.MNEMAC can be constructed from the MNEMAC member of the\nCBT Tape File 177 pds.\n\n\nFURTHER THOUGHTS\n\n      I don't have space in the remainder of this column, to delve\ndeeply into other aspects of the macro language, and to talk about the\nconditional assembly language, which is so important in the construction\nof most macro definitions.  For the details of that knowledge, you have\nto see IBM's HLASM manuals, which can be downloaded from IBM's web\nsites, reachable from www.ibm.com, and which are fairly easy to obtain\nnowadays.\n\n      My aim today was to show you something clever, and to stimulate\nyour ability to think.  Original thinking has always been part of the\nsystems programmer's job.  Systems programmers are continually called\nupon to overcome problems that they may have never seen before, and a\nbig part of a systems programmer's training consists of how to think\noriginally, and to invent new ways of doing something, using old tools.\nTo do that on a consistent basis, requires a constant stimulation of\n\"the creative juices\" of the mind.  In other words, it is helpful for us\nto gain exposure to other people's inventive and original ways of\nsolving tough problems.\n\n      I've always been fascinated by the ability to make macros\n\"pretend\" that they were simple machine instructions.  This is a\nmechanism which systems programmers have long used, to overcome the\nlimitations of an older Assembler.  Or, they have attempted to \"invent\"\ntheir own \"instruction set\" using macro definitions, and they have thus\nexpanded their ability to write code, not being restricted AT ALL by the\nlimitations of the instruction set IBM has provided them.  Their saying\nis:  \"If you want a new instruction, go invent your own!\"\n\n      So I hope that this has opened up a new direction for your\nthinking, and I wish you all the best of luck.  I'm personally looking\nforward to seeing you here again, next month.\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   The very simple REGS macro definition.  When you\n            code REGS in an assembler program, and this macro\n            definition is available, you will get all the\n            general register equates, so instead of having to\n            code 1 for Register 1, you can code R1, and so\n            forth.\n\n\n         MACRO\n         REGS\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         MEND\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.   Two ways of simulating a new instruction with a macro.\n            Suppose our Assembler does not \"know\" about the BASSM\n            instruction:\n\n\n  A.  Use another instruction which works the same way, and\n      substitute the generation of a different opcode.  In other\n      words, let the other instruction do the work, and then\n      overlay the operation code that is produced by the assembler.\n\n         MACRO\n&LABEL   BASSM &R1,&R2\n&LABEL   BALR  &R1,&R2            BRANCH AND SAVE AND SET MODE  (RR)\n         ORG   *-2\n         DC    X'0C'              REPLACE OPERATION CODE FIELD\n         ORG   *+1\n         MEXIT\n         MEND\n\n  B.  Use the macro to generate the entire machine instruction\n      from scratch, employing the Assembler's ability to calculate\n      the values of different types of constants.  In this case,\n      we use the Assembler's ability to calculate the value\n      of \"address constants\".\n\n         MACRO\n&LABEL   BASSM &R1,&R2\n         DS    0H\n&LABEL.  DC    0XL2'00',X'0C',AL.4(&R1.,&R2.)\n         MEND\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0211DE": {"ttr": 24329, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00W\\x01\\x020O\\x01\\x021/\\x128\\x01\\x00\\x00\\xff\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-10-31T00:00:00", "modifydate": "2002-11-08T12:38:57", "lines": 256, "newlines": 255, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         DECEMBER 2002\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.  The Online CBT Tape web site has its own URL.\nHowever, it can also be reached from the \"Members Only\" section of\nwww.naspa.com .\n\n\nTRICKS WITH TAPES - PART I - Tape Concepts\n\n      I feel it's unfortunate that Systems Programmers sometimes aren't\ntoo familiar with the internals of tape processing.  Tape processing is\none of the simpler parts of MVS to learn about.  Tape processing is, by\nits nature, sequential and one-dimensional.  Everything stretches out\nin a line.  This makes tape processing more easily understood than, say,\nDASD (direct access) processing, which, by its intrinsic nature, is\ntwo-dimensional.\n\n      For example, let's compare tape labels with direct access disk\n(DASD) labels.  The MVS tape volume label is an 80-byte unblocked\nrecord, and it is the first record on the tape.  The header records for\nthe first file on the tape immediately follow the tape volume record.\nIt's hard to find an arrangement which is simpler than that.\n\n      On the other hand, the DASD volume label is record 3 of track 0 of\nthe DASD volume.  And it is not completely simple to find out where the\nfiles are located on the disk pack.  The DASD volume record has to point\nto the beginning CCHHR location of the disk file directory, otherwise\nknown as the VTOC (Volume Table Of Contents).  The VTOC points to the\nstarting CCHHR location of each of the disk files.  And even that may\nnot be as simple as it could be, because in order to improve file search\nefficiency, IBM sometimes introduces an extra \"VTOC Index\" file into the\nmix.  The header record of the VTOC (also known as the Format 4 DSCB)\ntells you whether you need a VTOC index file to correctly find all the\ndisk files.  Or, if the header record says so, you may not need a VTOC\nIndex file, and the VTOC itself does it all.\n\n      So the question remains:  If tape processing is so simple, then\nwhy don't more people know about its innards?  I think the answer is,\nthat the MVS operating system hides the tape labels from general view.\nMost people, even systems types, don't get everyday glimpses at the\ninternal contents of the tape labels.  So, it's \"out of sight--out of\nmind\", and most people don't get to find out what's happening.\n\n\nTHE BEGINNINGS OF TAPE TRICKERY\n\n      Today we are going to talk about manipulations which you can do to\nindividual tapes.  We are not taking Tape Management Systems, such as\nCA-1 (TMS), CA-Dynam/TLMS, or RMM into account.  All of our maneuverings\nwill be done with one tape, or with a small number of tapes.  However, I\ncan recommend a wonderful tape-manipulation package that can be used to\nbulk-handle many tapes on a \"production level\".  The package is called\nTelTape, from Cartagena Software (www.cartagena.com).  TelTape can be\nused to simplify tape migration efforts, and it can copy, or otherwise\ndeal with, thousands of tape volumes at a time.  TelTape can run\ninquiries and updates to the Tape Management System, at the same time it\nis copying the tapes.  So if you need help in migrating most of your\ntape volumes to an automated tape library or if you're doing something\nsimilar, I'd suggest giving TelTape a try.  And TelTape is just a good\ngeneral \"tape utility\" to have.\n\n      I'll start uncovering the innards of tape files with a discussion\nof BLP (Bypass Label Processing).  Without talking about BLP, it's hard\nto uncover the information about tapes, which the MVS system hides.  BLP\nprocessing can be used to uncover whatever tape information the MVS\nsystem covers up.\n\n      BLP tape processing is the same thing conceptually, as NL (non\nlabel) tape processing, except that if you specify NL in the LABEL\nparameter of your tape DD JCL, and you mount a Standard Labeled tape,\nthe MVS system intercepts that situation, and asks you to mount a truly\nnon-labeled tape.  Using BLP, it isn't so.  MVS, operating the tape\nhandling under BLP, regards a tape label file the same as just any other\nfile.  Therefore, using BLP, you can dump the contents of the label\nfiles, and do just anything else you might want to do with them,\nincluding changing them while you're copying the tape.\n\n      Not everybody in an MVS shop has the power to do BLP processing.\nIn the JES2 initialization parms, you can specify whether a job,\nsubmitted under a particular job class, is allowed to use BLP\nprocessing.  And RACF (or another MVS security package) has the\ncapability of controlling which users, or which groups are eligible to\nrun BLP processing on tapes.  In RACF's case, you define a resource\ncalled ICHBLP under the FACILITY class, and grant at least READ access\nfor that resource.  Then, the user or group with READ access to that\nresource, can run a job using BLP access to tapes, again, provided\nthat the JES2 job class allows it too.\n\n      Once you can do BLP processing, and you can treat tape label files\nas though they were any other files, then you can understand the simple\nprocess of copying one tape to another, the way it should be.  Let me\nexplain:\n\n      A tape file consists of \"blocks\" which are grouped into \"files\",\nand the files are separated from each other by \"tape marks\".  Tape marks\nare special character sequences which the tape hardware recognizes, as\nseparators between the tape files.  Blocks of data within the same tape\nfile, are not separated by tape marks, but by gaps of tape which are\nunwritten upon.  These are known as \"interrecord gaps\".  Interrecord\ngaps separate tape BLOCKS.  Tape marks separate tape FILES.\n\n      Therefore, copying one tape to another tape, merely consists of\nreading the blocks on the input tape, writing them unchanged to the\noutput tape, and whenever you encounter a tape mark on the input tape,\njust write a tape mark on the output tape.\n\n      There are programs which do exactly this.  One program which is\nfamous for carrying out this task, is called COPYMODS, and you can find\nit on File 229 of the CBT Tape collection, a huge collection of free MVS\nsoftware which is accessible from the web.  The TelTape vendor package,\nmentioned above, has a tape copying utility which works this way too.\nOther vendors, such as Innovation Data Processing with their FATAR\nutility, have programs which do much the same thing.  There are 5 or 6\nother free programs on the CBT Tape collection which are also capable of\ncopying entire tapes in a similar way to this.\n\n      At this point, I'd like to mention why many programmers are\nconfused by such a process of copying one tape to another, which is so\nsimplistic that it is hard to imagine anyone having difficulty\nunderstanding it.  The reason for not understanding it, is because these\nprogrammers confuse the process of \"copying tape files\" with the process\nof \"copying entire tapes\".  Usually, the key to the misunderstanding is\nnot having BLP power.  If you don't have ready access to BLP power, it's\nhard to find a utility that'll copy all the tape blocks and their tape\nlabels for you.  Therefore, many programmers, when extracting the\ncontents of one tape, to put it on another tape, have to do it one file\nat a time.  So they'll copy one file to disk, then copy that disk file\nto an output tape, and then they'll do the same for the next file, and\nso forth.  If that is what they're doing, they might never be sure\nthey've gotten to all the files, and copied the entire tape.  Copying\none file of a tape at a time, is also a time consuming and exhausting\nprocess, whereas, making a \"Xerox Copy\" of a tape, by copying all its\nblocks and labels, is a very simple job, and it's usually quite fast.\n\n\nTAPE MAPPING AND TAPE COPYING TOOLS\n\n      A \"tape mapping\" tool is a worthy complement to a \"tape copying\"\ntool.  The two of them go together, sometimes even in the same program.\nThe idea of a tape mapping tool is to tell you what's on a tape, without\nany outside help.  A tape mapping tool reads the tape blocks and files,\nand reports whatever it's been programmed to \"find out\".  A tape mapping\ntool will tell you what needs to be copied from a tape, and after the\ntape has been copied, it will tell you whether you've gotten all the\noriginal tape's data files into the copy.\n\n      Some examples of free tape mapping tools are TAPEMAP from either\nFile 299 of the CBT Tape, or a different variation from Leonard Woren at\nhttp://ldworen.net .  Other such free tape mapping programs are\nTAPESCAN, from File 102 of the CBT Tape, or SS0104 from File 266 of the\nCBT Tape.  It is not so well known, but TAPESCAN can also be used to\ncopy tapes, as well as map them so you can determine their contents.\nThe COPYMODS program, although it is normally used to copy tapes, will\nalso do a fairly good job of mapping the contents of a tape, when it is\nrun with the proper options.  Vendor tools which can map tapes are\nsupplied with TelTape from Cartagena Software Ltd, with FATAR from\nInnovation Data Processing (the FDR people) and from other vendors too.\nAnd don't ignore MVSDITTO from IBM.\n\n      Among the free tape mapping programs, TAPEMAP and TAPESCAN are\nvery different from each other both in purpose, and in the appearance of\ntheir reports.  They'll nicely illustrate the great variations that are\npossible among tape mapping programs.  Both TAPEMAP and TAPESCAN operate\nby reading a tape, block by block and file by file.  Let's examine some\nof the differences between them.  First let's consider TAPESCAN.\n\n      The main purpose of TAPESCAN is to examine, in some detail, the\nDATA that is on a tape.  TAPESCAN was designed for techies.  Therefore,\nTAPESCAN is oriented to show much of the raw data on a tape, rather than\nto make an interpretation of the tape's contents for English-speaking\npeople.  So we find that the main TAPESCAN report consists of an\ninterpretation of the tape labels, if any exist, followed by a hex dump\nof the first 100 bytes of the first \"n\" blocks of each file.  By\ndefault, n=4.  That is, TAPESCAN, run without PARM alteration, will\ndisplay the first 100 bytes of the first 4 blocks of each tape file.\nEvery tape mark encountered on the tape is noted, and counted.  Also,\nthe end of the TAPESCAN report will format a lot of the tape label\ninformation for each file (if the tape is SL), so that you get a summary\nof the file contents on the tape, too.  For good measure, TAPESCAN gives\nyou a byte count for \"data plus label\" bytes on the entire tape.\n\n      So you see that TAPESCAN is very nitty-gritty down-to-bytes\ncentric in its approach.  I personally think that it was designed only\nto dump only the beginning bytes of each tape block, and only the\nbeginning tape blocks of each file, as a reaction to what the IBM DITTO\nprogram shows.  Using DITTO (the predecessor of MVSDITTO), if you want a\nhex dump of the contents of a tape, a tape file, or a tape block, you\nusually have to print the WHOLE block, or the WHOLE file, which is very\nbulky to print and to look at.  Usually, when examining a tape dump, you\nwant to scope out the forest, and not be stuck in the middle, examining\na few huge trees (and requiring an entire forest-full of paper, to print\nthe whole thing out).  TAPESCAN's report is a really good compromise, in\nshowing you as much of the byte content of the tape as you care to see,\nbut not obscuring the overall view as to what the entire tape contains.\n\n      TAPEMAP is not like this at all.  TAPEMAP is \"contents centric\",\nand not \"byte centric\" in it's approach.  When you map a tape with\nTAPEMAP, you want a summary and an accurate picture of what the entire\ntape contains.  You also want to make sure that the tape labels didn't\nfool you, so you want to be able to compare what the tape labels tell\nyou, with the result of an actual scan of the tape's files and their\nblocks.  There's one other important thing about TAPEMAP:  Last but not\nleast, if the tape contains files which were created in known formats,\nfor example, a file created by IEBCOPY, or by IEBUPDTE, or by FDR (and\nabout 8 others), you'd like to find out about the details of that, too.\nIf a partitioned dataset has been dumped to tape, it'd also be nice to\nknow what all its member names are.\n\n      TAPEMAP tells you all of these things.  TAPEMAP produces two\nreports when reading a tape.  One (which it always produces) gets\nwritten to the SYSPRINT ddname.  TAPEMAP's SYSPRINT report contains\ngeneral \"label and scan\" tape file information, interpreted for easy\nreading.  The other report, which displays special information about\nsome tape files--such as all the pds member names--which come from the\nspecial formats (such as IEBCOPY), gets written to the SYSPRNT2 ddname.\nIf no files from the input tape are in special formats, then the\nSYSPRNT2 ddname is not written to.\n\n      TAPEMAP is one of the few programs that probably tells you more,\nif you run it without PARMs, than if you run it with PARMs.  Without\nPARMs, TAPEMAP will produce both the SYSPRINT and SYSPRNT2 reports, and\nit will compare file information for each tape file, that was gotten\nfrom the labels, and from an actual scan of the data.  For instance,\nif a certain file's tape label says that its block size is 32760, but\nactually, the largest block on the file has only 21000 bytes, TAPEMAP\nwill reveal that situation to you, in a very clear way.  The PARMs in\nTAPEMAP operation tend to restrict the reports produced, more than\nexpand them, so it's probably best to always run TAPEMAP without any\nPARM at all, although File 299 of the CBT Tape will show you what\nPARMs are available for TAPEMAP.  You're welcome to experiment with\nthem.\n\n      My recommendation is, that if you really want to start getting a\nhandle on the contents of your tapes, you should become familiar with\nrunning the TAPEMAP and TAPESCAN programs.  I feel that the knowledge of\n\"what's on a tape\" is an essential requirement in a system programmer's\ngeneral knowledge.  As I said before, it's not that \"large\" a topic, and\nmost of the details can be easily grasped.  It's a question of merely\ntaking some time to investigate, and I hope I've given you a start.\n\n      I'm planning to have two more articles on tapes.  Next month, I'd\nlike to talk about some tape copying tricks that many of you might never\nhave heard about, or even thought of.  The following month, I'd like to\ndiscuss the topic of writing tape data, using EXCP (maybe with a little\nBSAM thrown in).  I wish all of you the best of everything, and I'm\nhoping to see you then.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0301JA": {"ttr": 24577, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x001\\x01\\x024\\x8f\\x01\\x024\\x8f \\x16\\x01=\\x01=\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-12-14T00:00:00", "modifydate": "2002-12-14T20:16:31", "lines": 317, "newlines": 317, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         JANUARY 2003\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.  The Online CBT Tape web site has its own URL,\nwww.cbttape.org .\n\n\nTRICKS WITH TAPES - PART II - Tape Copying Tricks\n\n      Last month, we introduced the concept of tape copying, as it ought\nto be.  As we mentioned last month, there is a general misconception in\nthe MVS computing world about what it means to copy an entire tape.  A\nstraightforward concept of copying all of a tape's data blocks, and the\ntape marks that separate the files, and which would create a \"facsimile\ncopy\" of the entire tape, has been hidden from the public's view, in the\nname of \"security\".  As a result, most public opinion about tape copying\nreally is a concept of \"tape file copying\".  And it completely obscures\nthe simple process of making a tape copy that is identical, or nearly\nidentical, to the content of the original tape.\n\n      Very often in my career, I've asked seasoned MVS computer\nprofessionals the question:  \"What tool do you use to copy a tape?\"  And\nthey've answered:  \"IEBGENER\".  I've never heard a sillier answer in my\nlife.  IEBGENER only copies one tape FILE.  What about all the rest of\nthe files?  How do you know how many files there are, on that tape?  And\nwhat about blocking considerations?  Come on, let's get real!  IEBGENER\nis at best, an awkward, inaccurate (because it now does automatic file\nreblocking without telling you), and incomplete tape copying tool at\nbest.  And we haven't even thought about the worst!\n\n      This month, I'll try to clear that up.  In addition, I'll present\nsome tricks to make partial tape copies, and to move tape files from\nsource tapes to target tapes, in whatever order you want them.  There\nare proper tools to do all of that.\n\n      You can have free tools to list the contents of a tape, or to make\ntape copies.  These can be found on the CBT Tape collection, at\nwww.cbttape.org .  Some of those tools are COPYMODS and COPYFILE (from\nFile 229 of the CBT Tape), TCOPY (from File 193), TAPESCAN (from File\n102), and TAPECOPY (from File 174).  Tools to strip labels from an SL\n(Standard Labeled) tape, to make a NL (non-Labeled) tape, are:  COPYSLNL\nand COPYMODS with its STRIP option.  (Both these programs are on File\n229.)  Partial tape copies can be made, using the COPYFILE, COPYSLNL,\nand COPYNLNL programs from File 229, and the COPYMODS program also has a\ncapability of limiting the number of files to be copied from the input\ntape.\n\n      If you're interested in a vendor-supported tape copying and tape\nlisting tool, one of the most excellent packages is TelTape from\nCartagena Software (www.cartagena.com).  TelTape has a full ISPF\ninterface to browse the contents of tapes and copy them--and TelTape\nallocates tape volumes dynamically.  Using TelTape, you can look at\nwhat's in a tape, or copy it interactively, as well as in a batch job.\nUnlike the free tape manipulation products, TelTape is designed to work\ntogether with your tape management system, and it can automatically\nupdate system catalogs if necessary.  TelTape, besides being an\nextremely versatile batch and interactive tape utility, also is a heavy\nduty tape migration tool, that can copy thousands of tapes.  TelTape\nwill update the system catalogs and tape management databases, while\nretaining the original tape creation dates, jobnames, and expiration\ndates.  TelTape is ATL (Automated Tape Library) aware.  For a general\nvendor tape utility, TelTape is definitely a package well worth looking\ninto.\n\n\nTAPE LABELS, EXPOSED\n\n      We mentioned last month, that the tape labels on a SL tape, are\nhidden by the operating system from general view.  For our purposes, it\nis very important that all of us should know what is in a tape label.\nOf course, I'm talking about the IBM-format EBCDIC tape labels that are\nin general use by the MVS operating system.  Our IBM reference books\nwill be the \"Using Magnetic Tapes\" manual, which for DFSMS on OS/390\nsystems has the designation SC26-4923, and for z/OS systems it has the\ndesignation SC26-7412.  The information we want, is in Chapter Two of\neither book.\n\n      In a Standard Labeled tape, each tape data file is sandwiched\nbetween two tape label files.  So each \"file\" on a SL tape is actually\nthree files:  the header label file, followed by the tape data file,\nfollowed by the trailer label file, with one tape mark in between each,\nto separate the files.  The label file records (also known as \"the\nlabels\") are always 80-bytes long and unblocked.  IBM convention\nspecifies that all the field contents of the labels be EBCDIC and\nprintable, so you won't find any packed or binary number fields in tape\nlabels.  This is an important fact to know, and it makes reading the\ntape labels much easier.\n\n      At the beginning of every tape label, for four characters, is an\nidentifier field indicating the type of label it is.  This will also\ntell the operating system what format to look for, in the rest of the\nlabel.  The typical label types are VOL1 (for a volume label), HDR1 (for\nthe first header label), HDR2 (for the second header label), EOF1 (for\nthe first trailer or end-of-file label), EOF2 (for the second trailer\nlabel) and so forth.  Additionally, if a SL tape is to be continued on\nanother volume, EOV1 (first end-of-volume) and EOV2 (second\nend-of-volume) labels are created by the operating system at the end of\nthe tape volume.  HDR1, EOF1, and EOV1 labels have the same format as\neach other.  HDR2, EOF2, and EOV2 also have a common format.\n\n      Generally speaking, one might characterize the HDR1 and EOF1\nlabels as containing external operating system and device-dependent data\nthat relates to the data set, such as its name, file sequence number,\ncreation and expiration dates, and (on the trailer labels) block count\nin the file.  The HDR2 and EOF2 labels contain more specific data set\ncharacteristics, such as the type of information contained in the DCB,\nJFCB, and UCB control blocks for the dataset, with the creating jobname\nand stepname.  Both types of labels are used to identify and describe\nthe data set and to protect it from unauthorized use.  RACF or whatever\nsecurity system you have, interacts with this information.  So does the\nMVS Operating System itself.\n\n      The format of the trailer labels is identical to the format of\nthe header labels, except for the fact that the EOF1 and EOV1 labels\ncontain actual block counts, as opposed to the HDR1 labels, which\ncontain zeroes in the low order block count field, and blanks in the\nhigh order block count field.  The reason for that, is that sometimes\na tape is read backwards, and this symmetry is built into the label\nformats so the operating system has no trouble reading a tape in\neither direction.  This concludes our general description of tape\nlabel contents.  For the details, see either of the \"Using Magnetic\nTape\" books mentioned above.\n\n\nCOPYING PARTS OF TAPES\n\n      For argument's sake, let's start our discussion with a feature of\nthe COPYMODS program (from File 229 of the CBT Tape), whose principal\nreason for being, is to make \"Xerox copies\" of entire tapes.  Suppose we\nhave a SL tape that contains 50 files, and we want to copy only its\nfirst 27 files.  We can create some COPYMODS JCL (illustrated in Figure\n1) and code FILELIMIT=27 in a SYSIN card.  What happens when we run the\njob?\n\n      From our discussion above, we know that a Standard Labeled tape\nreally contains three times as many files as its stated number, because\neach data file is sandwiched between two label files.  So on a SL tape,\nto copy 27 files, you really have to copy 27 times 3, or 81 files.\nHowever, on a NL tape, which does not contain any label files, you just\nhave to copy the stated number, or 27 files.  How does COPYMODS tell\nthe difference?\n\n      COPYMODS, when asked to do file limitation, does an initial OPEN,\nREWIND, and READ of the input tape.  Thus it determines if the first\nrecord on the tape is a VOL1 label.  If so, COPYMODS assumes that the\ntape is SL, and it internally multiplies the coded FILELIMIT number by\n3.  Otherwise, COPYMODS leaves the FILELIMIT number as stated, and\nassumes that the input tape is NL.  Whatever the final outcome of this\nprocess, COPYMODS copies the resulting number of files from the input\ntape, then CLOSEs the input tape and output tape(s).\n\n      So, on a basic level, you see the trickiness of having to copy\nparts of a tape.  On a labeled tape, one file is really three files,\nand a mindless program (such as COPYNLNL), which is told to copy file\nnumbers, will do what it was told.  The result you get, might not be the\nresult you want.  Therefore, some \"foolproof factors\" are built into\ntape copying programs which copy SL tapes.  For example, if you use the\nCOPYFILE program to copy some files from an SL tape to another SL tape,\nand the input tape you mount is NL, COPYFILE will kick it down.  That's\nbecause COPYFILE, which is designed only for SL tapes, when it copies a\n\"file\", really handles all three files that are in the sandwich.  With\nCOPYFILE, as with most programs that copy SL tapes, the needed safeguard\nhas been built in.\n\n\nHOW YOU CAN MAUL AN OUTPUT TAPE\n\n      In this section, we'll use the three related programs, COPYFILE,\nCOPYSLNL, and COPYNLNL, to illustrate the principles we want to show.\nAll three of these programs use the same JCL and control cards, except\nfor the program name.  COPYFILE (the original program of the three) can\ncopy selected files from an input SL tape, to another output SL tape.\nThe particular files copied, are determined by control cards, usually\ncontaining numbers, in the SYSIN DD card.  For example, if you want to\ncopy file 56 from an input tape, to file 7 of the output tape, you code\n56/7 in the SYSIN DD card.  COPYFILE has a help member in File 229,\nwhich explains the use of the control cards, so you can refer to that\nfor further reference.  You can see sample COPYFILE JCL, in Figure 2.\n\n      I adapted the other two programs, COPYSLNL and COPYNLNL, from the\nCOPYFILE program.  All three programs use the exact same control cards\nto determine which files you want the program to copy.  However,\nCOPYSLNL takes an input SL tape, and creates an output NL tape by\nonly copying the data file to the output tape, and skipping the copy of\nthe two label files that are before and after it.  COPYNLNL does\nanother thing entirely.  COPYNLNL makes no assumption whether a tape is\nSL or NL, assuming all tapes to be NL.  COPYNLNL \"mindlessly\" copies all\nthe files you told it to (whether they are label files or data files),\nonly stopping after two consecutive tape marks on the input tape.  Of\ncourse I intended COPYNLNL only to be used for NL tapes.  But I didn't\nput any of the usual safeguards into it.\n\n      All three of these programs have to run authorized, since they do\na RDJFCB and change the JFCB copy, before the OPEN TYPE=J, so that the\nBLP attribute is forced on, no matter what you coded in the JCL.  That\noperation needs APF authorization.  So you see that all these programs\ncan just copy tape files, no matter whether they are data files or label\nfiles.  Now, let's get to the \"mauling\" part.\n\n      The most extreme case of tape mauling that I can think of, is to\ntake a multi-file SL tape, and use COPYNLNL to create an output tape\nconsisting of a hodgepodge of tape labels and data files, out of the\ncorrect order.  You can even make an output tape consisting of only\nlabels.  For example, with COPYNLNL, copy files 1, 3, 4, 6, 7, 9, and so\nforth, from an SL tape.  By doing that, you've skipped over the data\nfiles, and only copied the label files.  Actually, that idea was the\ninspiration for inventing the LABLDUMP feature of COPYMODS, where you\ncan dump all the tape labels out to an external file, and the LABADDIN\nfeature of COPYMODS, where you splice these labels back into a NL\nversion of the same tape, re-creating the SL tape from the NL tape and\nthe set of labels.  By the way, the new STRIP option of COPYMODS will\nclean up a mauled tape like the first one above.  The STRIP option of\nCOPYMODS will read an input tape, detect which files are label files and\nwhich are not, wherever they are, and only copy the data files--not the\nlabel files.  So you're left with a clean NL tape that has only data\nfiles.\n\n      A more typical case of tape mauling, which usually happens by\naccident, is worthy of mention.  It occurs when you're writing a tape,\nand you close it in the wrong place.  I can create an example of this\npurposely, using COPYMODS.  And I can cure it too, using COPYMODS.\n\n      We mentioned the FILELIMIT=nnn SYSIN card in COPYMODS before.\nThis card limits how many files we copy, when we copy a tape.  There are\ntwo new option keywords in COPYMODS, to force this limit to be either SL\nor NL, no matter whether the input tape is really SL, or NL.  These are:\nNLLIM, which forces the FILELIMIT number to be regarded as NL, and\nSLLIM, which forces the FILELIMIT number to be regarded as SL, and\nmultiplied by 3.  So if you ran COPYMODS to copy an SL tape, and used\nthe NLLIM keyword, and made the FILELIMIT number a non-multiple of 3,\nyou've effectively mauled the end of the output tape, either by ending\nit just after writing the header labels, or by ending it after writing a\ndata file without writing the trailer labels that should follow.\n\n      We can usually detect conditions like this, by mapping the tape\nwith the TAPESCAN program from File 102 of the CBT Tape.  TAPESCAN will\nshow the last file, without the following tape labels, or it will show\nthe last header labels, without the following data file.  If you really\nwant to become an expert at tape copying tricks, I'll leave you with the\nexample of how to cure the problem, when you have a tape that doesn't\nhave the final trailer labels.  One way is to use COPYMODS to STRIP the\nlabels off and make a NL tape, while at the same time doing a LABLDUMP\nto dump all the labels to a file.  You can then either edit the label\nfile before you do LABADDIN processing with the CORRBLKS and BLKCNT\noptions on, and splice the final trailers back in, or you can use the\nLBLFIX parameter, that will reconstruct the last set of trailer labels\nout of the last header labels, plus the measured block count of the last\ndata file.\n\n      So now you've now seen some wonders that you can do to tapes.\nThese wonders have been largely made possible by the fact that you can\ncopy tape blocks, and generally control tape processing very closely, by\nusing the EXCP access method against tapes.  In the last part of this\n3-part series next month, I'll explain a lot of the nitty-gritty of how\nEXCP processing is done, and you'll see that it's a lot simpler than you\nmay have thought.  Good luck to you.  I'll see you then.\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   Sample JCL to run the COPYMODS program.  COPYMODS is\n            now at Level 052, and it is recommended to use version\n            Level 050 or higher.\n\n\n//*   insert JOB card here\n//******************************************************************//\n//*   COPYMODS FILE LIMITING RUN                                   *//\n//******************************************************************//\n//*\n//COPY    EXEC PGM=COPYMODS,REGION=4096K,PARM=SYSIN (Now not necessary)\n//STEPLIB  DD  DISP=SHR,DSN=your.steplib\n//LABLDUMP DD  DISP=SHR,DSN=userid.CBT.CNTL(C454LAB2)\n//SYSPRINT DD  SYSOUT=*\n//IN   DD VOL=SER=C454MU,DISP=OLD,UNIT=CART,LABEL=(,BLP,EXPDT=98000)\n//OUT1 DD VOL=SER=SML454,DISP=OLD,UNIT=CART,LABEL=(,BLP,EXPDT=98000)\n//SYSIN  DD *\nFILELIMIT=27\nCUMSEP\nLABLDUMP\nLABELS\n/*\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.   Sample COPYFILE JCL.  JCL and control cards to\n            run COPYSLNL and COPYNLNL are identical, except\n            for the program name in the EXEC card.  See CBT\n            Tape File 229, for a HELP member that explains\n            all the COPYFILE control cards.\n\n\n//*        insert JOB card here\n//COPYSTEP EXEC PGM=COPYFILE,REGION=4000K,PARM='TAPEL'\n//STEPLIB  DD DISP=SHR,DSN=your.steplib\n//MSG      DD SYSOUT=*\n//TAPELOUT DD SYSOUT=*\n//SYSABEND DD SYSOUT=*\n//IN       DD DSN=INPUT.FILE,UNIT=CART,DISP=SHR,LABEL=EXPDT=98000,\n//            VOL=SER=FROMVL\n//TAPELIN  DD DSN=OUTPUT.FILE,\n//            UNIT=(CART,,DEFER),VOL=(,RETAIN,SER=TOVOL1),\n//            DISP=(NEW,KEEP),LABEL=EXPDT=98000,DCB=TRTCH=COMP\n//SYSIN    DD *\n   1/1  -700\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0302FE": {"ttr": 24583, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00)\\x01\\x03\\x00?\\x01\\x03\\x00o\\x104\\x01\\x8e\\x01\\x8e\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-01-03T00:00:00", "modifydate": "2003-01-06T10:34:29", "lines": 398, "newlines": 398, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         FEBRUARY 2003\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.  The Online CBT Tape web site can be reached\nat www.cbttape.org .\n\n\nTRICKS WITH TAPES - PART III - USING EXCP\n\n      This month, I'll be able to show you something that will give you\ngreat joy to use.  We all know that much of the thrill we get from\nprogramming, is to be able to \"make the machine dance\", which means\nthat the computer will listen to what you tell it to do.  After we've\nfinished with today's subject, you'll be able to start making a tape\ndrive dance, and tell it what to do.  If you follow this lesson out, and\nlook at some of the coding examples we'll refer to, you too will begin\nto experience the same enormous pleasure that I've been able to get,\nfrom manipulating a tape on a tape drive, and making it do just about\nanything I want.\n\n      Most of the tape work I do personally, is the copying and\nmodification of tapes, so there aren't that many of the 3480 (or\n3490) opcodes which I personally use often.  But once the door has\nbeen opened, and you know the basic techniques, the sky is the limit,\nand you'll be able to exploit nearly the full capabilities of the tape\ndrive, if you want to do that.\n\n      The key to doing this, to manipulating a tape on a tape drive, is\nto learn to use the EXCP access method for tapes.  EXCP for tapes is\nreally quite simple to set up, and once you see how it's done, all the\nintimidating thoughts that you may have had in your own mind, that \"EXCP\nis hard\", will melt away, and you'll just start having fun.\n\n      Doing EXCP to tapes, is just a little bit different from \"regular\nprogramming\", in that you have to issue instructions to the hardware,\ndirectly.  Even though that may sound difficult, it isn't.  It's really\njust writing Assembler code.  If you're not frightened by writing\nAssembler code, you've got the \"battle with the phantom\" won already.\nBut if the thought of writing Assembler code scares you a bit, I can\nreassure you that this is really very easy Assembler coding.  And you\ncan also copy from the many available coding examples.\n\n      You can find several programs to copy code from, on File 229 of\nthe CBT Tape Collection of free software, whose URL is www.cbttape.org.\nPrograms to look at, are COPYMODS, COPYFILE, COPYSLNL, and COPYNLNL.\nYou can also find good code on File 193 (the TCOPY program).  When\nyou look at this code, don't confuse yourself will all the stuff that\nformats the information obtained from the tape.  Concentrate instead, on\nthe EXCP macro instructions themselves, and on what they refer to\ndirectly.\n\n      So let's get down to business, and start explaining what we have\nto do.\n\n\nSETTING UP EXCP TO TAPE\n\n      The EXCP macro executes an I/O operation, and this can be to any\ndevice:  a tape drive, or a disk drive, or a CTC, or even a card reader\nor card punch.  The Operation Codes for CCWs (Channel Command Words)\nwhich \"talk\" to each device, are described in the hardware manuals for\nthe device, and not in the MVS manuals that we're used to looking at.\nSo finding out about which Operation Codes to use, is a more difficult\ntask than most, because you have to obtain the IBM Hardware Manuals\ncd-rom to get them.  I referred to the old 3480 manual (GA32-0042), to\nkeep things simple, and I've supplied a list of Operation Codes for the\n3480 tape drives, in Figure 4, to make these codes more accessible.\n\n      The bottom line is, that you EXCP an IOB (an Input Output Block).\nThe IOB (illustrated in Figure 2) basically refers to a CCW or a chain\nof CCWs (to supply the list of operations to be done), the DCB of the\nfile to be referenced, and an eight-byte area to contain the CSW\n(Channel Status Word) that will display the results of the I/O\noperation.  The CCW itself contains the reference to the buffer area in\nyour computer storage, where the tape data is to be placed, or written\nfrom.  And the rest of the IOB basically contains a few bytes of flag\nbits.  You can see a bunch of CCWs in Figure 1, where I've collected all\nthe CCW chains that are used by the COPYMODS program from File 229 of\nthe CBT Tape collection of free software.\n\n      So again, you EXCP an IOB.  And all the stuff you want to do, has\nto be referenced by fields in the IOB and its CCWs.  That's half of the\nbasics.  The other half, is that you have to execute a WAIT macro after\nyou do the EXCP, to tell your program when the EXCP has finished doing\nits work, and not to proceed further until that I/O is complete.  The\nWAIT macro posts its results to a fullword of storage known as an ECB\n(or Event Control Block).  And when the ECB has a X'7F' in its first\nbyte, that's a signal to our program, that the I/O operation has\ncompleted successfully.\n\n      One more piece of information necessary in an I/O operation, is\nthe exception conditions, such as end-of-file or end-of-data on a READ,\nend-of-tape on a READ or a WRITE, or if a tape mark has been encountered\non a READ.  That information is reflected in status bits of the CSW, as\nreturned in the IOB.\n\n      Please look at Figure 3 to see a sample of Assembler code which\nexecutes a READ operation for a block of tape data, and copies up to 64K\nbytes into a 64K buffer area in storage referred to by location INAREA.\nThe actual number of bytes read by the operation, is calculated and\nmoved to a halfword location called BYTESCOP.  We'll now explain what\nhappens here, in more detail.\n\n\nHOW YOU READ AND WRITE DATA ON A TAPE\n\n      At this point, I'll try and step you through the process of\nreading a block of data from an input tape, and writing the same block\nof data to an output tape.  The DDNAMEs referring to both tapes are IN\nfor the input tape, and OUT1 for the output tape, as referred to in\nFigure 5.  We assume that both DCBs have already been OPENed in our\nprogram.  Please look at Figure 3, to see the block of code which does\nthe tape block READ.\n\n      The code does an EXCP on the INIOB, an IOB which was set up to\npoint to the input tape and the input buffer area and execute a READ\nCCW, with the opcode of X'02'.  This is immediately followed by a WAIT\nmacro, which refers to the same ECB that is mentioned inside the IOB\nthat was just EXCP'ed.  After the WAIT has completed (this is automatic\nin the program--you don't have to code anything there), you can then\ntest whether the I/O was good.\n\n      Before we do that, though, I have to answer the question of how\nmany bytes the READ operation will move.  This is normally coded\nexplicitly in the fourth field of the CCW, on a READ operation.  If\nyou look in Figure 1, at the INCCW, you'll see X'FFFF' or 65535 bytes\ncoded there.  When we're READing a block of data from a tape, we don't\nknow that there are exactly 65535 bytes in it.  Usually there are far\nless.  So what do we do?\n\n      Actually, the designers of the I/O subsystem in MVS have made\nprovision for that.  You code the maximum number of bytes you think you\nmay want to READ, but you also turn on the X'2000' bit in the third\nfield, which is known as the SILI bit.  When the SILI bit is on in a\nREAD CCW, the READ operation will read as many bytes as there are in the\ncurrent tape block, up to the maximum coded in the fourth field.  And if\nit encounters less than the maximum, it will tell you how many bytes\nless, in a halfword field in the CSW area of the IOB.  That field is\ncalled the \"residual count\".  The number of bytes actually moved, is the\nmaximum from the fourth field, minus the residual count.  If you look at\nthe code in Figure 3, you'll see that this is what the code actually\ndoes.\n\n      Almost everyone asks the question:  \"Why do you determine the\nnumber of bytes moved, in such a silly (no pun intended) way?  Why\ndoesn't the operating system return that number of bytes directly?\"  My\nguess would be, that the I/O subsystem plugs the maximum number of bytes\ninto the CSW before the move takes place, and as bytes are moved, the\nnumber in the CSW is subtracted from, until it gets to zero, and that's\nthe signal for the move to be finished.  With the SILI bit on, the move\ncan finish before the CSW residual byte count gets to zero, so wherever\nthe move stops, the number which is left in the CSW, has to be\nsubtracted from the maximum, to indicate the count of bytes actually\nmoved.  I guess that was the easiest way to program the I/O so you knew\nyou were done.  This was programmed in 1964, and we still have to live\nwith it.\n\n      Now let's get back to the rest of our code in Figure 3.  Just\nafter the WAIT, we test a bit INCSW+4,X'01', which would signal a UNIT\nEXCEPTION, if it was on.  That means (usually) that we've read a Tape\nMark.  So if we're copying a tape, we're at the end of a file, so we\nhave to count the file, and write a Tape Mark to the output tape.\nIf there's no unit exception, we check the first byte of the ECB for a\nX'7F', which signals correct completion of the I/O operation.  Once that\nis verified, we go look at the residual count in the CSW, and calculate\nthe number of bytes in the block that was just read.\n\n      To WRITE all this data out to an output tape, it's very simple.\nWe take the count of bytes moved from the BYTESCOP halfword, and put it\ninto the fourth field of the WRITE CCW.  For a WRITE CCW, this count has\nto be exact, even though the SILI bit is on.  Now, since the second\nfield of the WRITE CCW points to the same buffer area where the data was\njust put, so we just EXCP the OUTIOB, referring to the WRITE CCW, and\nupon correct completion, the data gets written out as a block, to the\noutput tape.  It's that simple, except for handling error conditions.\nSee the code in the COPYMODS program at labels INERR and OUTERR for\nfurther details about how to handle READ and WRITE errors.\n\n\nOTHER TAPE OPERATIONS USING EXCP\n\n      If you look at the list of opcodes I've mentioned in Figure 4,\nyou'll see that there's quite a world of things you can program with a\ntape on a tape drive.  And of course you want to see an explanation of\nhow to use all these opcodes.  If you can't get the 3480 manual I\nmentioned above, because it's too old, you can get the 3490E equivalent,\ncalled \"IBM 3490 Magnetic Tape Subsystem Hardware Reference\"\n(GA32-0127).  And that has pretty much the same explanations in it,\nas the older 3480 manual.\n\n      Programming techniques for the other opcodes follow the same sort\nof idea that we've shown for the READ and WRITE opcodes, except that\nsometimes you have to be careful with the quantity in the \"bytes moved\"\nhalfword (fourth field) of the CCW.  If you're writing a Tape Mark, it's\nadvisable to set that field to X'0000' or X'0001', although the \"real\ntape\" hardware doesn't strictly require that.  I found out that the OS/2\nvirtual tape emulator, and its equivalent for Hercules virtual tapes, is\nvery particular about the bytes moved field, when you're not actually\nexecuting opcodes that move bytes.\n\n      In any case, I've given you a start here.  And I hope many of you\nwill find a lot of fulfilment in learning how to manipulate tapes on\ntape drives.  If you follow these ideas out, I guarantee you'll get a\nlot of joy.  And even if not, this discussion has opened your eyes.\nBest of luck to all of you.  See you next month!\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFigure 1.  A group of CCWs Coded in an Assembler Program.\n           For good measure, I'm showing a Transfer in Channel\n           CCW (a CCW \"branch instruction\") too.\n\n           This group of CCWs runs all the operations used by the\n           COPYMODS program from File 229 of the CBT Tape.\n           These CCWs do not all execute as a chain.  The chaining\n           bit (X'4000' in the third field of each CCW shown) says\n           that after executing this CCW operation, the tape drive\n           should execute the next one too.  But if this bit is\n           turned off (when the third field reads X'2000' instead\n           of X'6000'), then the chain stops there.\n\n              Opcode  Buffer     Control  Bytes      Opcode\n              (Hex)   Address    Bits     Moved      Interpretation\n\nINCCW    DC    X'02',AL3(INAREA),X'2000',X'FFFF'     Read\n*                                                 end of chain\nOUTCCW   DC    X'01',AL3(INAREA),X'2000',X'FFFF'     Write\n*                                                 end of chain\nREWCCW   DC    X'07',AL3(INAREA),X'6000',X'FFFF'     Rewind\n         DC    X'03',AL3(INAREA),X'2000',X'FFFF'     No Operation\n*                                                 end of chain\nBACKCCW  DC    X'2F',AL3(INAREA),X'6000',X'FFFF'     Backspace 2 files\nBK1FCCW  DC    X'2F',AL3(INAREA),X'6000',X'FFFF'     Backspace one file\n         DC    X'03',AL3(INAREA),X'2000',X'FFFF'     No Operation\n*                                                 end of chain\nBK1BCCW  DC    X'27',AL3(INAREA),X'6000',X'FFFF'     Backspace block\n         DC    X'03',AL3(INAREA),X'2000',X'FFFF'     No Operation\n*                                                 end of chain\nBYPDCCW  DC    X'27',AL3(INAREA),X'6000',X'FFFF'     Backspace Block\n         DC    X'3F',AL3(INAREA),X'6000',X'FFFF'     Forward Space File\n         DC    X'2F',AL3(INAREA),X'6000',X'FFFF'     Backspace over T.M.\n         DC    X'03',AL3(INAREA),X'2000',X'FFFF'     No Operation\n*                                                 end of chain\n\n\n*    For Good Measure, here's how you do a branch with CCW chains.\nTIC      DC    X'08',AL3(TGTCCW),X'4000',X'0001'     Transfer in Channel\n*                                                 i.e. Branch to TGTCCW\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFigure 2.   The ECB and IOB, as they may appear in an Assembler\n            Program.  The IOB is what gets executed, and the ECB\n            tells you when the I/O execution has finished.  Here\n            there are two of these--one for the input tape READ,\n            and one for the output tape WRITE.\n\n\n* ----------------------------------------------------------------- *\nINECB    DC    F'0'                 ECB for Input Tape\n* ----------------------------------------------------------------- *\n*                                   IOB for Input Tape\nINIOB    DC    X'02000000'\n         DC    A(INECB)             Address of ECB that gets posted\nINCSW    DC    2F'0'                Status after IO operation (CSW)\nINCCWPT  DC    A(INCCW)             Address of CCW (possibly a chain)\n         DC    A(IN)                Address of DCB for File\n         DC    F'0'\n         DC    X'00010000'\n* ----------------------------------------------------------------- *\nOUTECB   DC    F'0'                 ECB for Output Tape\n* ----------------------------------------------------------------- *\n*                                   IOB for Output Tape\nOUTIOB   DC    X'02000000'\n         DC    A(OUTECB)            Address of ECB that gets posted\nOUTCSW   DC    2F'0'                Status after IO operation (CSW)\nOUTCCWPT DC    A(OUTCCW)            Address of CCW (possibly a chain)\nOUTDCBPT DC    A(OUT1)              Address of DCB for File\n         DC    F'0'\n         DC    X'00010000'\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFigure 3.   This is a block of code from the COPYMODS program,\n            which does a READ of a block of data from a tape,\n            and then tells you how many bytes were in the block\n            that we just read.  The buffer where the data is\n            copied, is referred to in the CCW (and is called\n            INAREA in this program).\n\n\n*     First, we're going to READ a block of data from the INPUT tape.\n         EXCP  INIOB          Do the READ (you EXCP an IOB)\n         WAIT  ECB=INECB      Wait for READ until ECB is posted\n         TM    INCSW+4,X'01'  Test the CSW if a T.M. was encountered\n         BO    READIN1        YES\n         CLI   INECB,X'7F'    Otherwise, did READ complete normally?\n         BNE   INERR          NO -- ERROR\n*     Now, we're going to WRITE this same data to the OUTPUT tape.\n         MVI   OUTCCW,X'01'   Set OUTPUT CCW to WRITE\n*     So we calculate the number of bytes in the block we just read.\n*        LH    R2,INCCW+6     R2=READ LENGTH - (works only up to 32K)\n*                             The following instructions work to 64K\n         XC    FULLWORK,FULLWORK     CLEAR AREA COMPLETELY\n         MVC   HALFWORK(2),INCCW+6   Maximum bytes to move from CCW.\n         L     R2,FULLWORK    LOAD R2 WITH FULL LOW ORDER\n*        LH    R3,INCSW+6     R3=RESIDUAL BYTE COUNT (works only up to 32K)\n*                             The following instructions work to 64K\n         MVC   HALFWORK(2),INCSW+6   Residual byte count - bytes not moved\n         L     R3,FULLWORK    LOAD R3 WITH FULL LOW ORDER\n         SR    R2,R3          Subtracting gives actual bytes moved\n         STH   R2,BYTESCOP    SAVE QUANTITY OF BYTES COPIED\n*\n*     . . . . .  etc.\n*\nFULLWORK DS    0F                  Upper halfword is zeroes.\n         DC    H'0'\nHALFWORK DC    H'0'                Lower halfword is work area.\n*\nBYTESMVD DS    0F             FULLWORD OF CURRENT BYTES MOVED\nBYTESCOH DC    H'0'           HI ORDER - SHOULD BE ALWAYS ZERO\nBYTESCOP DC    H'0'           CURRENT NUMBER OF BYTES COPIED FROM INPUT\n*\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFigure 4.   Operation Codes for a 3480 Tape Drive.\n\n            This information comes from IBM Manual GA32-0042,\n            IBM 3480 Magnetic Tape Subsystem Reference:\n            Channel Commands, Status and Sense Bytes, and\n            Error Recovery Procedures.\n\n            Operation Code          Meaning of the Operation\n            (one byte in Hex)\n\n            B7                      Assign\n            27                      Backspace Block\n            2F                      Backspace File\n            E3                      Control Access\n            97                      Data Security Erase\n            17                      Erase Gap\n            37                      Forward Space Block\n            3F                      Forward Space File\n            9F                      Load Display\n            4F                      Locate Block\n            DB                      Mode Set\n            03                      NOP (No Operation)\n            02                      Read\n            0C                      Read Backward\n            22                      Read Block ID\n            12                      Read Buffer\n            24                      Read Buffered Log\n            07                      Rewind\n            0F                      Rewind and Unload\n            04                      Sense\n            E4                      Sense ID\n            34                      Sense Path Group ID\n            AF                      Set Path Group ID\n            C3                      Set Tape-Write-Immediate\n            5B                      Suspend Multipath Reconnection\n            43                      Synchronize\n            C7                      Unassign\n            01                      Write\n            1F                      Write Tape Mark\n            00                      Test I/O\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFigure 5.   The DCB Macro as coded to refer to a TAPE device,\n            and to use EXCP as the access method.\n\n            We normally to not need an EXLST parameter in this\n            DCB, but I want to do a RDJFCB to find out information\n            about the file we're looking at, and the RDJFCB needs\n            an EXLST parameter to refer to an area where the JFCB\n            can be copied into our program.\n\n            You see that the same kind of DCB is coded for an\n            input tape or an output tape, with EXCP.  The opcode\n            in each CCW will determine what is actually done to\n            the file.  YOU have all of the control, depending on\n            what CCWs you code.\n\n\nIN       DCB   MACRF=(E),DDNAME=IN,DEVD=TA,DSORG=PS,RECFM=U,           X\n               EXLST=INEXLST\nOUT1     DCB   MACRF=(E),DDNAME=OUT1,DEVD=TA,DSORG=PS,RECFM=U,         X\n               EXLST=OUTEXLST\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0303MA": {"ttr": 24836, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x03\\x06_\\x01\\x03\\x06_\\x10\\x10\\x019\\x019\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-03-06T00:00:00", "modifydate": "2003-03-06T10:10:44", "lines": 313, "newlines": 313, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           MARCH 2003\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.  The Online CBT Tape web site can be reached\nat www.cbttape.org .\n\n\nA REPLACEMENT FOR MCNVTCAT\n\n      Those of us who are veteran MVS systems programmers remember a\nwonderful little tool that IBM's CBIPO packaging department had\ndeveloped.  It was a program called MCNVTCAT, and it helped set up your\nsystem catalog and usercatalogs when you were installing a new MVS\nversion.  The way the MCNVTCAT program worked was that it took a\n\"LISTCAT ALL\" listing of your catalog, and generated \"DEFINE NONVSAM\"\nstatements so you could recatalog all of your old non-VSAM catalog\nentries into a new system catalog or into new usercatalogs.\n\n      Indeed, the MCNVTCAT program was a handy tool, and those of us who\nused it in the past, remember it very fondly.  However, for all intents\nand purposes, MCNVTCAT has disappeared from the face of the earth.\n(Unless, of course, you've saved yourself a copy from the old days--a\npractice which I recommend highly.)\n\n      The reason for this (I think) is as follows:  The MCNVTCAT tool\nwas originally developed as an unsupported add-on by the MVS software\npackaging folks.  Customers (i.e. users) found it to be handy, and\nstarted asking for enhancements.  Since the people who developed that\nsoftware were not the usual IBM software developers, but their division\nis designated as a function to package what others have written, and\nsince MCNVTCAT is connected to CBIPO and is not distributed via SMP/E as\npart of an MVS release, two things happened.  First, the MCNVTCAT\nwriter(s) were not obligated to make any enhancements, since that\nprogram was like some field-developed tool.  And second, when the CBIPO\npackaging was replaced by ServerPac and other offerings, MCNVTCAT\ndisappeared with it.\n\n      Today, you can't get a copy of the MCNVTCAT program from IBM.  IBM\nwon't put it on one of their web sites, since it isn't supported, and if\nthey made it available, people would demand that they fix it (since it\nisn't perfect).  And as for replacing MCNVTCAT's functionality, IBM has\nbasically told the world that it's a tough situation--\"sorry 'bout\nthat\".  In addition, I can't put MCNVTCAT source code into the CBT Tape\ncollection, because it is owned by IBM, and I can only put freely\ndistributable stuff there.  So the bottom line is that today, MCNVTCAT\nis unavailable.\n\n\nRCNVTCAT TO THE RESCUE\n\n      About a year and a half ago, there was a big stir on the IBM-Main\nnewsgroup about how to replace MCNVTCAT's functionality.  After much\ndiscussion, the outcome was that Alastair Gray, an English sysprog\nwho works in Switzerland, wrote a replacement program (in REXX) that\ndoes the same thing as MCNVTCAT, only better.  This REXX is called\nRCNVTCAT, and it is much easier to use than MCNVTCAT ever was.  Since\nRCNVTCAT is a public program, it can be enhanced.  RCNVTCAT may be\nobtained on File 542 of the CBT Tape collection at www.cbttape.org .\n\n      Unlike MCNVTCAT, which requires complicated JCL to run, you just\nrun RCNVTCAT as a TSO command, and point it to a catalog name.  RCNVTCAT\nwill run the LISTCAT 'catalog.name' ALL command in the foreground, and\nwill execute its logic against the result, producing IDCAMS DEFINE\ncommands for each of several categories, for recataloging the objects\nfrom each class in a new catalog.  Currently, RCNVTCAT allocates its\nwork datasets as UNIX objects, but Alastair Gray is currently working on\na version to use standard MVS work datasets, if UNIX services are not\navailable.  The result of RCNVTCAT execution is a partitioned dataset\nwhose members each contain DEFINE statements in a different category,\njust like MCNVTCAT produced.  Please look at Figure 1, to see an example\nof pds members produced by a sample execution of RCNVTCAT.\n\n      A summary report for all the actions RCNVTCAT has taken, is\nillustrated in Figure 5.  This report is obviously modeled after the\nold MCNVTCAT summary report, with its reference to OS CVOLS.  But every\nentry in the summary report that is marked with an (M), describes the\ncontents of a corresponding member of the RCNVTCAT output pds.  And\nyou can see the result of RCNVTCAT's actions.  Detailed DEFINE\nstatements for recataloging non-VSAM, VSAM cluster, and usercatalog\nentries, can be seen in Figures 2, 3, and 4 respectively.  There is\nalso a separate member for recataloging datasets beginning with SYS1,\nwhich is similar to the NONVSAM member.  All of this will make your\nlife much easier, when trying to create a new system catalog or user\ncatalog.\n\n\nWHAT RCNVTCAT ACTUALLY DOES FOR YOU\n\n      At this point, I want to show a bit more detail about how handy\na program like RCNVTCAT is.  When you are building a new system, you\nwant to retain all the old entries in your system catalog, which refer\nto your installation's usercatalogs, GDG's, important datasets, and so\nforth.  But some extra datasets may have gotten cataloged in your old\nsystem catalog by mistake.  So you want to keep all the relevant catalog\nentries, but you want to clean up all the garbage.\n\n      RCNVTCAT will generate DEFINE statements or error statements for\nall of the entries in your old catalog, and you can browse or edit these\nat your leisure.  Therefore, when you create your new system catalog\nfrom scratch, you can edit out the \"garbage\" catalog entries from the\nDEFINE statements, and only run the DEFINEs for the desired entries.\nThus, you can create a new system catalog or usercatalog, with just the\nentries you want, and without the entries you don't want.\n\n      It is very hard to achieve a result like this, without a program\nlike RCNVTCAT.  True, you can run a LISTCAT ALL against the catalog and\ngo through it by hand, marking all the \"garbage\" entries that you don't\nwant.  Then you can REPRO all the entries from the old catalog into the\nnew catalog, and delete the irrelevant ones.  But that way is not as\nclean as creating a brand new catalog and only recataloging the entries\nyou want to keep.  All the space in the catalog is efficiently used, and\nno subsequent reorganization is necessary.  Having the source DEFINE\nstatements for all (or most of) the entries in your catalog, makes for\na better recovery situation too.\n\n      So now you see what all the fuss was about on the IBM-Main `\nnewsgroup, when people were looking for the old MCNVTCAT program.\nToday, we have also seen that it is better to have a public program\nwhich performs a function like this, rather than an unsupportable IBM\nprogram.  If some functionality in the program doesn't exist, a user\ncan put it in for everone else to use.  And if there are errors, a user\ncan fix them for everyone, without the problem that is involved, in\ntrying to get IBM to fix something they don't want to.\n\n      I'm sure that by now, you all have seen the wisdom of trying to\nreplace IBM field-written tools by user-written tools.  Thank goodness\nthat we still have enough skilled Assembler programmers and REXX\nprogrammers among us, to support such tools.  And one programmer who\ndoes a good job, will be able to make a reliable fix for everyone to\nuse, when some tool does need to be supported.\n\n      Best of luck to all of you, and I hope to see you again next\nmonth.\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   Member list listing of the partitioned dataset which\n            was produced by the RCNVTCAT exec, run against the\n            system master catalog.  I have added ISPF statistics,\n            using the free PDS 8.5 program package from CBT Tape\n            File 182.  The members may be copied to a permanent\n            pds for future reference.\n\n\n\n------------------------- MEMLIST Source Member List 1 ------- Row 1 to 9 of 9\nCOMMAND ===>                                                  SCROLL ===> CSR\nnter an ISPF command, a PDS subcommand or a special control code:\n  8 View log   1 Suspend ISPF    6 MEMLIST all    F Find      R Recall\n LA Lista      4 Sublist =       7 Output table   L Locate   SO Sort\n LV Listv      5 Check aliases   9 Swap panels    O Options   X Above/Below/All\n- DSN=SYS03033.T100041.RA000.SBGOLOB.R0100014,VOL=SER=DATA01  MEM=:  ----------\nCMD  NAME     DATA     VER.MOD    CREATED   LAST MODIFIED  SIZE  INIT    ID\n     ALIAS              01.00    03/02/02  03/02/02  1:51   211   211   OS390MC\n     GDG                01.00    03/02/02  03/02/02  1:51     2     2   OS390MC\n     IMPORT             01.00    03/02/02  03/02/02  1:51   238   238   OS390MC\n     MISC               01.00    03/02/02  03/02/02  1:51    27    27   OS390MC\n     NONVSAM            01.00    03/02/02  03/02/02  1:51   197   197   OS390MC\n     RECAT              01.00    03/02/02  03/02/02  1:51   123   123   OS390MC\n     REPORT             01.00    03/02/02  03/02/02  1:51    33    33   OS390MC\n     SYSCTLG            01.00    03/02/02  03/02/02  1:51     2     2   OS390MC\n     SYS1               01.00    03/02/02  03/02/02  1:51  1593  1593   OS390MC\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.   Part of the NONVSAM member, with DEFINE statements\n            produced by the RCNVTCAT REXX, to recatalog non-VSAM\n            entries in the OS390 Master Catalog.\n\n\n          DEF  NVSAM(NAME(AJV.AAJVSMP1                                ) -\n                 DEVT( 3390                                           ) -\n                 VOL(  OS3DAA                                         ) )-\n                 CAT(CATALOG.OS390.MASTER                                 )\n          DEF  NVSAM(NAME(AJV.AAJVS390                                ) -\n                 DEVT( 3390                                           ) -\n                 VOL(  OS3DAA                                         ) )-\n                 CAT(CATALOG.OS390.MASTER                                 )\n          DEF  NVSAM(NAME(AJV.SAJVSMP1                                ) -\n                 DEVT( 3390                                           ) -\n                 VOL(  OS39RA                                         ) )-\n                 CAT(CATALOG.OS390.MASTER                                 )\n\n             ...  and so forth  ...\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 3.   Beginning of the RECAT member of the partitioned\n            dataset produced by the RCNVTCAT exec.  This gives\n            DEFINE statements to recatalog VSAM structures.\n            This output is an improvement over the functionality\n            of the old MCNVTCAT program, which did not produce\n            statements to recatalog VSAM structures.\n\n\n        /* CLUSTER ------- 0000000000000000000000000000000000 CANNOT RECAT */\n        /* CLUSTER ------- IXGLOGR.ATR.ADCDPL.ARCHIVE.A000000 CANNOT RECAT */\n        /* CLUSTER ------- IXGLOGR.ATR.ADCDPL.DELAYED.UR.A000 CANNOT RECAT */\n        /* CLUSTER ------- IXGLOGR.ATR.ADCDPL.MAIN.UR.A000000 CANNOT RECAT */\n        /* CLUSTER ------- IXGLOGR.ATR.ADCDPL.RESTART.A000000 CANNOT RECAT */\n        /* CLUSTER ------- IXGLOGR.ATR.ADCDPL.RM.DATA.A000000 CANNOT RECAT */\n          DEF   CLUSTER(NAME(SYS1.ACDS                                   ) -\n                 VOL(  OS39M1                                            ) -\n                 LINEAR                                                    -\n                 RECATALOG                                               ) -\n                DATA(NAME(SYS1.ACDS.DATA                                 ) ) -\n                 CAT(CATALOG.OS390.MASTER                                )\n\n           ...  and so forth  ...\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 4.   DEFINE statements produced by the RCNVTCAT\n            exec, to recatalog the usercatalog entries\n            and their associated aliases, in the master\n            catalog.\n\n\n           IMPORT   OBJ( (CBTUSER.USERCAT                               -\n                 DEVT(270F2000) VOL(DATA02))) CONNECT                    -\n                 CAT(CATALOG.OS390.MASTER                                 )\n            DEF ALIAS(REL(CBTUSER.USERCAT                             ) -\n                 NAME(CBT                                         ))     -\n                 CAT(CATALOG.OS390.MASTER                                 )\n           IMPORT   OBJ( (COVUSER.USERCAT                               -\n                 DEVT(270F2000) VOL(DATA02))) CONNECT                    -\n                 CAT(CATALOG.OS390.MASTER                                 )\n            DEF ALIAS(REL(COVUSER.USERCAT                             ) -\n                 NAME(COV                                         ))     -\n                 CAT(CATALOG.OS390.MASTER                                 )\n\n              ...  and so forth  ...\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 5.   The RCNVTCAT Summary Report\n\n            This is an illustration of the RCNVTCAT summary\n            report, folded into 72 columns for easy reading.\n            From here, you can see a description of the type\n            of data in each member created.  This report is\n            obviously modeled after the MCNVTCAT summary\n            report.\n\n\nOS CVOL CATALOG NAMES TO BE CONVERTED\n*RCNVTCAT*  C O N V E R S I O N   R E P O R T\n\nALIAS   TOTAL .......(M)...  70 TOTAL NUMBER OF ALIAS STMTS IN CATALOG\n ALIAS  SYSCTLG ...........   0 ALIAS STMTS ASSOCIATED WITH OS CVOL\n                                CATALOGS\n ALIAS  VSAM UCAT .........   0 ALIAS STMTS ASSOCIATED WITH VSAM USER\n                                CATALOGS\n ALIAS  NONVSAM DS ........   0 ALIAS STMTS ASSOCIATED WITH NON VSAM\n                                DATA SETS\n\nIMPORT  VSAM UCATS ..(M)...   9 NUMBER OF VSAM USER CATALOGS\n\nNONVSAM DS TOTAL .......... 447 TOTAL NUMBER OF NON VSAM DATA SETS  IN\n                                CATALOG\n NON VSAM VOLUMES ......... 447 VOLUMES ASSOCIATED WITH NON VSAM DATA\n                                SETS. SEE NOTE 1\n OS CVOL SYSCTLG ....(M)...   0 OS CVOL CATALOGS WITH THE FOLLOWING\n                                NAMES:  SYSCTLG.VXXXXXX  -  XXXXXX =\n                                VOLUME\n SYSCTLG CONVERTED ........   0 OS CVOL CATALOG NAMES CONVERTED TO\n                                SYSCTLG.VXXXXXX . SEE NOTE 2 AND\n                                SYSPRINT OUTPUT LISTING\n NONVSAM SYS1. DS....(M)... 398 NON VSAM DATA SETS STARTING WITH\n                                SYS1.---\n NONVSAM OTHER DS....(M)...  49 ALL OTHER NON VSAM DATA SETS\n\nGDG     TOTAL .......(M)...   0 NUMBER OF GENERATION DATA GROUP STMTS\n\nMISC    TOTAL .......(M)...  26 NUMBER OF STATEMENTS WHICH COULD  N O T\n                                BE PROCESSED\n------------------------------------\nINVALID DEVICE TYPE .......        0 NUMBER OF STATEMENTS WHICH CONTAIN\n                                     AN INVALID DEVICE TYPE. SEE NOTE 3\nNO. OF STMTS PROC .........      622 TOTAL NUMBER OF STATEMENTS WHICH\n                                     WERE PROCESSED\nSUM OF A/I/N/G/M ..........      552 SUM OF STATEMENTS WHICH WERE\n                                     PROCESSED FOR\n                                     ALIAS/IMPORT/NONVSAM/GDG AND MISC.\n                                     SEE NOTE 4\n\n(M)    : A MEMBER WAS CREATED IN DATA SET  CONVERT.ENTRIES\nNOTE 1 : SOME DATA SETS NEED OF MORE THAN ONE VOLUME\nNOTE 2 : DATA SETS WHICH START WITH SYSCTLG WILL BE CONVERTED TO\n         SYSCTLG.VXXXXXX, XXXXXX = VOLUME\nNOTE 3 : DEVICE TYPE IS NOT RECOGNISED BY RCNVTCAT !!. BETTER CHECK THE\n         CODE !?!\nNOTE 4 : DIFFERENCE SHOULD BE THE NUMBER OF ALIAS TOTAL. THEY ARE\n         PROCESSED TWICE\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0304AP": {"ttr": 24842, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00%\\x01\\x03\\x06_\\x01\\x03\\x06_\\x10\\x11\\x00\\xe9\\x00\\xe9\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-03-06T00:00:00", "modifydate": "2003-03-06T10:11:25", "lines": 233, "newlines": 233, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           APRIL 2003\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.  The Online CBT Tape web site can be reached\nat www.cbttape.org .\n\n\nTSSO REVISITED\n\n      Free tools have their advantages and disadvantages.  Let's look at\nadvantages first.  Last month, we discussed what happened to IBM's\n\"unofficial\" MCNVTCAT tool for generating DEFINE NONVSAM statements from\nVSAM catalog entries.  We saw that a user-written replacement, Alastair\nGray's RCNVTCAT REXX exec, has distinct advantages over IBM's tool.\nFirst, RCNVTCAT works better than MCNVTCAT, and it's easier to use.\nSecond, IBM's MCNVTCAT was not written by IBM's programmers who write\nthe MVS operating system, but by the CBIPO software distribution folks.\nThat put MCNVTCAT into a category (like Field Developed programs) where\nIBM was not obligated to support it.  Third, when the CBIPO went away,\nso did MCNVTCAT.  But Alastair Gray, who wrote RCNVTCAT, can usually\nbe persuaded to improve his tool.  Alastair is not bound by IBM's\ninternal bureaucracy and contractual obligations.  So it's more likely\nthat you can get support service from this private author than from IBM,\nat least in such a case.  I recently asked Alastair myself for an\nimprovement, and he made the requested code change for me within a\ncouple of days.\n\n      The \"down side\" of using free tools, is that sometimes they stop\nworking when IBM comes out with a new release of the MVS operating\nsystem (OS/390, z/OS, etc.), and it's up to a knowledgeable user to fix\nthe tool for the later version of the system.  Sometimes a knowledgeable\n(and willing) programmer is available, and sometimes not.  So unless you\nyourself have the know-how to fix the tool, you can be stuck.\n\n      But often, the power of numbers comes to the rescue.  This is\nespecially true when the tool is in use by large numbers of people at\nmany installations.  In that case, more people have a vested interest in\nkeeping the tool working, so if one person (perhapes an original author)\ndoesn't fix it up, it's very likely that someone else will.  This\nhappens very frequently in the history of the more popular user-written\ntools.  So we've seen some pros and cons.\n\n      I think that an outweighing factor in favor of using user-written\ntools, is the presence of an active exchange forum where people send\nupdates, and where prospective and current users can look for them.\nA tool which is distributed on such a forum has a greater likelihood\nof being fixed or improved in a timely manner.  I'll explain with an\nexample.\n\n      A very good exchange forum for free MVS tools is the CBT MVS\nUtilities Tape and the CBT Overflow Tape, whose materials are (also)\navailable online at www.cbttape.org.  This forum allows the users of a\ntool to look online and see if an improved version has been made\navailable.  And if one of the users has made an improvement himself,\nhe/she has a place to send it in, so other people can use it, test it,\nand derive benefit from it.  Without having such a forum, the tendency\nis that one person makes an improvement to a tool, and that improvement\ndoes not easily find its way outside that programmer's own shop.  Even\na person's personal web site doesn't often enjoy widespread public\naccess, but the Internet has made an improvement in the distribution of\nan individual programmer's works.  Still, it is better to have a place\nwhere everyone knows they should look, like the CBT Tape web site.\n\n\nTHE PLACE OF TSSO\n\n      Today, I'm going to talk about a tool called TSSO (Time Sharing\nSubsystem Option).  TSSO has been used at many shops over the years,\nand it illustrates the ups and downs of running user-written software\nvery well.\n\n      The basic idea of TSSO is to create a console environment (which\nruns as an MVS subsystem) where TSO line-mode commands can be executed.\nThe TSO command (preceded by a subsystem character) is entered on an MVS\nconsole, similarly to when a TSO command is entered at the command line\nof a TSO session.  And the resulting displays from the command (if any),\nwhich have to be in the form of PUTLINE line-mode output (no Fullscreen\nTPUTs are allowed), get written back to the console via WTOs.  However,\nwhether display output is produced or not, the command will still\nperform its action.  For example, if you use IBM's TSO RENAME command to\nrename a dataset, no display output is produced, but the dataset is\nnevertheless renamed.\n\n      TSSO is the brain-child of Bill Godfrey, who wrote the first\nversion back around 1980, and Bill's version of TSSO, now on CBT Tape\nFile 306, still does exactly what I've described.\n\n      You can glimpse the enormous potential of having such a tool.\nFor example, you can use IBM's RENAME, DELETE, and LISTD TSO commands to\ndo dataset renames, deletes, and displays from an MVS console in a\npinch.  And with the free PDS 8.5 command package, you can compress a\ndataset, or copy dataset members to a different dataset, also from an\nMVS console.  That's because the COPY and COMPRESS subcommands of the\nPDS 8.5 package will invoke IEBCOPY in foreground TSO, and TSSO creates\na TSO-like environment at the console.  And these same operations which\nare normally done only under TSO, now can actually be carried out\nwithout TSO being \"up\".\n\n      An enormous improvement to Bill Godfrey's TSSO was made by Marc\nSchare in 1985-6 (Marc was then working at Bellcore) who took advantage\nof TSSO's TSO-like console environment so he could use CLISTs (now REXX\nexecs too) and intelligently reply to MVS commands with them.  Marc\ncreated a genuine \"automated operations\" environment built on top of the\nbasic TSSO structure.  Marc implemented sets of pre-assembled \"AOF\nTables\" in TSSO, to automatically and intelligently respond to certain\nconsole messages with given replies.  To protect the new power of this\nTSO-powered console environment against unauthorized use, Marc also\nimplemented the concept of \"console security\" inside TSSO, years before\nIBM itself did that in native MVS.  TSSO makes it possible to protect a\nconsole (using RACF, ACF2, or Top-Secret), so you have to logon to that\nconsole with a password, in order to enter commands.\n\n      As MVS changed, TSSO eventually needed fixing and improvements.\nGuy Albertelli and Dave Cartwright wrote many of the initial fixes, and\nrecently, for z/OS and the later OS/390 systems, Ed Jaffe wrote an\nextensive series of modifications to TSSO.  TSSO can now be implemented\nin all the modern MVS environments.   You can find the latest version of\nTSSO on File 404 of the CBT Tape collection, and the previous versions\nof TSSO (if you are still running an old version of MVS) may be found on\nthe CBT Overflow Tape.  So although TSSO came into some disuse for a\nwhile, Ed Jaffe's fixes have now made it possible for every MVS shop to\nrun it.\n\n\nINSTALLING TSSO\n\n      I recently installed TSSO on an OS/390 2.10 system, and found that\nit is not hard to implement.  I obtained the File 404 pds from the CBT\nTape collection, and made my own copy of it.  I allocated a load library\nand ran the assembly job which was supplied, to assemble and linkedit\nall the load modules.  One change had to be made to the source.  It\nseems that the pound sign (back in 1980-1986) used to be an unused\nsubsystem character, but now RACF uses it.  So I had to change that.\nNow, I use a question mark (X'6F') instead of the pound sign (X'7B').\nIt is a one-byte change in module TSSOINI2, at displacement +B3.  Once\nthe load modules were created, I moved them into a system library.  I\nmade a RACF change, to create a userid called TSSO (similar to userid\nJES2), and added the subsystem name TSSO to the IEFSSNxx PARMLIB member.\nThen I had to re-IPL, which TSSO requires when it is first installed.\nThe TSSO started PROC, which is distributed in File 404 as member\nTSSOPROC, has to be copied to SYS1.PROCLIB, renamed to TSSO and then\ncustomized.  After the IPL, you then issue START TSSO from the console,\nor S TSSO,SUB=MSTR.\n\n      At this point, I found that I could enter TSO commands from the\nconsole, when I preceded the command with a question mark (in my case).\nIf you leave the default subsystem character as the pound sign, it won't\nwork, because the system interprets the command intended for TSSO as a\nRACF command.  I found that I could do dataset renames and such, if the\nthe new TSSO RACF userid was given the proper access to them.  I found\nI could compress datasets from the console by doing the following type\nof console command, which invokes PDS 8.5:\n\n  ?PDS85 SBGOLOB.CBT.CNTL COMPRESS SHR\n\nand the command was carried out.  I could also invoke CLISTs from the\nconsole when the CLIST library was put into the TSSO PROC under the\nSYSPROC ddname, and RACF READ access was given to the TSSO userid, for\nthe CLIST library.\n\n      For basic TSSO use, it is important to note that the TSSO proc\nlooks exactly like a TSO logon proc, except that you EXEC PGM=TSSO\ninstead of EXEC PGM=IKJEFT01.  There are some extra ddnames at the\nbottom, for outputs (described in the supplied sample PROC).  All of\nthis is very simple to understand, and easy to get working.\n\n\nIMPLEMENTING AUTOMATED OPERATIONS\n\n      One must understand that the Automated Operations piece of TSSO\nwas written in 1986, at a time when the software vendors were only\nbeginning to create the sophisticated Auto Ops packages of today.  The\ntalk of the time, was to be able to establish \"operator-less machine\nrooms\" that would only need intervention in the case of an IPL.  So\nalthough the TSSO Auto Ops facilities (called the AOF component of TSSO)\nwere a great leap forward for their time, they may seem quite primitive\nby today's standards.\n\n      If your shop already has an Automated Operations package\ninstalled, TSSO AOF can still work side by side with it.  I'd say that\nyou should use the installed Automated Operations package for the\n\"production work\", and you can restrict the TSSO intervention into the\nconsole traffic to specialized \"sysprog matters\", so to speak.  In\nother words, if you want to play, and you don't want to interfere in\nthe normal Auto Ops functioning, you can use TSSO to do your own\nconsole replies and stuff, as long as it doesn't interfere with the\nnormal production work.\n\n      That said, I'll show you the externals of how TSSO AOF works.\nAOF console intervention is driven by an assembled load module, which\nis really a table.  You decide which messages are to be replied to.\nYou draw up a plan, and then you code (using the supplied macros) a\nsource table of messages and their replies, following your plan, and\nusing the TSSO macros.  You assemble your table, place it into a load\nlibrary that is referred to by the STEPLIB of the TSSO proc, and then\nyou issue a .RELOAD command under TSSO (in my case the full command\nwould be ?.RELOAD tablname) to load the table for use.\n\n      An installation can keep a load library containing many AOF\ntables, and you can issue .RELOAD commands at any time to load different\ntables.  So you can vary your control how TSSO will manage your console\ntraffic.  TSSO supplies a DISPAOF command to display all the commands\nand messages affected by the currently loaded AOF table.  The whole\nmaintenance and learning process is made easier by two sample members\nsupplied in the TSSO install pds.  Member ASMTAB is a CLIST which will\nautomatically assemble, linkedit, and optionally .RELOAD any assembler\nsource for a valid AOF table.  And member AOFIVP is a sample coded table\nthat is deliberately intended to show you as many possibilities of how\nto code a table entry, as possible.\n\n      I don't have space to show you more about the TSSO package right\nnow.  For further information about how to use TSSO, look at member\nRELGDE43.  But my point is to let you know that a modernized version of\nTSSO is now available, and it is free for the installing.  You have the\noption of only using the TSO-command execution part of TSSO, or you can\ndelve into using the Automated Operations facilities of TSSO as deeply\nas you prefer to.  Once TSSO is in place, the systems programmer has a\nlot of flexibility to do maintenance on the system, and on datasets,\nwhich was not possible before.  With TSSO in place, you can fix or\ncompress datasets while you're at the console in the computer room.  The\nproduct is now available and it runs on z/OS.  It's my job to let you\nknow.  The rest is up to you.\n\n      Best of luck to all of you.  I'll see you again next month.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0305MX": {"ttr": 25092, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00R\\x01\\x03\\tO\\x01\\x03\\tO\\x10\\x01\\x01\\x0f\\x01\\x0f\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-04-04T00:00:00", "modifydate": "2003-04-04T10:01:52", "lines": 271, "newlines": 271, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                            MAY 2003\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\n\n** This article was not published by Technical Support magazine **\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.  The Online CBT Tape web site can be reached\nat www.cbttape.org .\n\n\nSHARING TAPE DRIVES\n\n      This month, I'd like to talk about a remarkable product written by\na remarkable software writer.  This product is free for the installing,\nbut it is professional-grade work, written by a professional who began\nhis career writing parts of the MVS and CICS systems for IBM, and who\nhas been in the software writing business for many years since.  I am\nsure that this product will be useful for the requirements of many MVS\nshops today, which is why I'm writing about it.\n\n      Today's subject is about sharing a pool of tape drives among one\nor more MVS systems.  This has perennially been a sore spot in a data\ncenter ever since I can remember, and I've been in this field for a long\ntime too.  One problem with tape drives, is figuring out how many of\nthem your shop should have.  Tape drives are expensive to buy and\nmaintain, so you generally want as few of them as you can get away with\nhaving.  Their usage pattern in most shops is such, that often they are\nall idle, and then all of a sudden, you don't have enough of them to go\naround.  This problem is made worse when you have a requirement that\nmultiple MVS systems share the same pool of tape drives.  Ideally, you'd\nlike your tape workload to be planned so that some of your tape drives\nwill be busy most of the time, with enough extra drives in reserve to\naccommodate the heavy usage times.  And it shouldn't be a problem to\nshift this tape workload to another MVS system, any time the shop needs\nit.  But practically speaking, that is much easier said than done,\nunless you have extra software to serialize and manage the tape drive\nusage.\n\n      The advent of \"Automated Tape Libraries\" and \"Virtual Tape\nSubsystems\" has relieved this requirement somewhat, for shops that are\nbig enough to afford them.  Automated Tape Libraries are banks of \"real\ntape drives\" that are fitted out with elaborate robotic systems to mount\nthe tape cartridges automatically, under software control.  Virtual Tape\nSubsystems are like automated tape libraries, except that the tape\ndrives are not real, being simulated by disk files.  Using a Virtual\nTape Subsystem, if you need an actual tape to send out-of-house, there\nis provision to copy a \"virtual tape\" to a real cartridge.  And the\nentire inventory can be stacked and backed up on high-capacity tape\ncartridges, for disaster recovery purposes.  But even these automated\nsystems only lessen the tape sharing problems.  They do not eliminate\nthem.  And they too, are expensive.\n\n      The package I am writing about today, is called TapeMan, and it\nis written by Simon Spanchak.  Simon's web site is www.exspans.com.\nTapeMan is a sophisticated tape pooling and tape sharing software tool.\nIn the rest of this column, I'll explain how TapeMan works.  And you can\nalso use this knowledge to understand the principles behind those\nvendor-written software products which do approximately the same thing.\n\n\nSERIALIZING/SHARING A POOL OF TAPE DRIVES\n\n      Anybody who is familiar with MVS operations will tell you that\nwhen you have several jobs contending for a pool of existing tape\ndrives, you have to answer a bunch of operator messages.  See Figure 1\nfor a likely sequence of these messages.  It is true that you can have\nyour Automated Operations package answer those messages for you, but\nmost people would prefer to execute their tape jobs in a more orderly\nmanner.  For example, if a job that needs tapes can't get all the tapes\nit needs, many shops would prefer that the job wait until enough\ndrives are available.  Then the jobs can execute in an orderly fashion.\n\n      Now consider the complications involved when several MVS systems\nthat are not \"sysplexed\", are contending for the same pool of tapes.\nMany shops get around that, by not allocating the same tape drives to\nthe different MVS systems.  But often that practice will decrease the\npotential efficiency of the shop's tape drive usage.  One system's\nworkload at a given time might not require tapes at all, while the other\nsystem might demand use of the full tape drive pool for a single job.\nWhere you aren't sharing the entire pool of drives, queueing theory will\ntell you that a large bottleneck can result in your shop's batch window.\n\n      Another problem needs to be mentioned.  If two systems are\nsharing one tape drive, you need some form of serialization, because\njobs from both systems might try to write to the same tape at the\nsame time.  If you want to share a tape drive between two MVS systems,\nyou have to solve that problem too.\n\n      So this leads us to the idea that if you can share a pool of\ntape drives between several MVS systems, but you can also make sure\nthat there is no concurrent contention for any drive, across all of\nthe systems, you'll have accomplished quite an efficient use of the\ntape drive resource pool.  Simon Spanchak's TapeMan package does\nexactly that, so now I'm going to show you how it works.\n\n\nTAPEMAN BASIC OPERATION\n\n      TapeMan accomplishes its wizardry using four system exits, besides\nits own code.  These system exits extract all the tape unit related\ninformation from the system, and allow all the necessary automated and\nmanual system interventions for TapeMan to do its job.  The exits are:\nJES2 Exit 6, JES2 Exit 32, IEFUSI, and IEFACTRT.  I must also mention\nthat TapeMan, though it does not run as a subsystem itself, employs\nsubsystem interface calls 9 and 10, so it can intercept console traffic,\nsuch as VARY commands for tape drives.\n\n      Upon initialization, TapeMan finds out all the tape devices\nyou've got on your system, and checks its startup parameters, to decide\nwhich ones it's going to control.  Then it allocates all these devices\nto itself.  TapeMan serializes tape drive usage by controlling all the\ntape drives first.\n\n      When jobs come into the system, JES2 Exit 6 (the converter exit)\nis activated, and information about the JCL cards is passed to TapeMan.\nTapeMan looks at the JCL DD cards (including doing catalog lookups) and\nit also gets the device type information from the UNIT keyword values.\nOf course, TapeMan is trying to sniff out all possible ways that the\njob needs tape drives.  For each job submitted, TapeMan builds a table\nentry in its own table.\n\n      Eventually, the job is started, and Exit 32 (job selection time\nexit) kicks off.  Exit 32 gets control shortly before the $HASP373\njobname STARTED message gets displayed on the console.  Exit 32 allows\nTapeMan to do job-related I/O to its own control block(s), and to alter\nconsole messages related to the job.  Of course these messages will have\nto do with tape drives.  When each job starts, TapeMan marks the job in\nits own tables, that the job has started.\n\n      When each job step is started, the IEFUSI (step initialization)\nexit gets control.  TapeMan looks to see if it has all of the devices\nthe job step needs.  This has already been determined from TapeMan's\nprevious processing.  If it has the drives, TapeMan unallocates them\nfrom itself and lets the job start.\n\n      After the job step has been allowed to start, TapeMan itself (in\nits own code) checks the JES control block entries for the job, to see\nif the job has managed to grab all the tape devices it needs for that\nstep.  TapeMan then seizes back any other tape devices that the job step\ndid not need.  TapeMan is also capable of \"locking allocation\", to make\nsure some other job doesn't grab a tape device during the small window\nbefore TapeMan has grabbed all the unused tape drives back to itself.\nObviously, TapeMan has to be an authorized program.\n\n      Then the job runs with the tapes, until the step ends.\n\n      At step end, the IEFACTRT exit (step end, job end exit) receives\ncontrol and notifies TapeMan that the step has ended.  TapeMan grabs\nback all the tape devices that the job step was using.  So whenever a\njob is not using tapes, TapeMan owns those tape drives.\n\n\nSHARING TAPE DRIVES OVER MULTIPLE SYSTEMS\n\n      TapeMan does not require that multiple MVS systems be sysplexed.\nThis is a great advantage for shops with configurations that require\nseparate machines with completely unrelated workloads to share a pool of\ntape drives.  Such installations often do not want to go to the effort\nof creating a full-blown sysplex with the proper coupling device(s).\nAll they want to do is to save the expense of maintaining multiple pools\nof tape drives for all the different systems.  Here's where TapeMan\nhelps a lot.  TapeMan will control the one pool of drives over all these\nMVS systems.\n\n      GRS can also provide unified multi-system control over one pool\nof tape drives, but all those MVS systems have to be fully sysplexed\ntogether, in order for that to work.  TapeMan is much more forgiving.\n\n      Of course, there needs to be a common point of control, where all\nthe TapeMan images on the different MVS systems can communicate.  In\nTapeMan's case, this is simply a shared disk file on a shared disk pack.\nThat is TapeMan's only requirement for the cross-system communications.\nIt is self-evident that you need just one more thing.  All the tape\ndrives in the pool have to be capable of being brought simultaneously\nonline to all the systems.  So each MVS image has to have a\ncommunication path to each managed drive.\n\n      At this point, I must answer a question you probably have in your\nmind.  Suppose a given tape drive has a unit name of say 0596 on one MVS\nsystem, and it has unit name of 0A96 on another system, what do you do?\nThe answer is that any instance of TapeMan on one MVS system, has\nprovision in its initialization parameters to define each drive as it\nappears to all the other connected MVS systems.  So you set up all the\nTapeMan instances on each connected system, to know about each\ncontrolled tape drive as it appears to all the other systems too.\nThe easiest way this is accomplished, is to give an installation-defined\n\"share name\" to each controlled tape drive in the TapeMan parameters.\nThen, each instance of TapeMan will find the drive by its \"share name\",\nrather than by its actual unit address.\n\n      So to control one pool of tape drives over multiple MVS systems,\nyou need an instance of TapeMan to be running on each of these MVS\nsystems.\n\n      What does TapeMan do, when a job on another MVS system is using a\ntape drive?  It's quite simple.  Before releasing a tape drive, TapeMan\nchecks the shared file, to see if any other MVS system is currently\nusing that drive.  If the drive is in use by some other system, our\ninstance of TapeMan knows that the drive is unavailable to any of the\neligible jobs on its own system, so it won't release it.  Thus we have\neffectively and elegantly accomplished the serialization of tape drives\nbetween all of the MVS systems.\n\n\nABOUT THE AUTHOR\n\n      Simon Spanchak has been writing MVS system software for over 30\nyears.  His first job was with IBM itself, in Hursley, where he wrote\ncomponents of both MVS and CICS.  This provided Simon with an extremely\nsolid base of system knowledge, as well as igniting his lifelong passion\nfor writing system tools and system components.\n\n      During his long employment history, Simon has acquired vast system\nknowledge.  But he has especially gravitated to writing \"shared systems\"\nand packages that cooperate one with another.  As with many software\nauthors, Simon has developed a system of Assembler macros and common\ntools (called \"SS macros\" and \"SS server\") which allow him to create\n\"shared\" and \"cooperative\" applications with amazing rapidity.  In fact,\nthe entire TapeMan package is largely a front-end to Simon's SS Server\npackage of common routines.\n\n      Simon Spanchak lives in Canada and is available for consulting\nwork.  His web site is www.exspans.com .  I am very proud to know Simon\npersonally, and I keep in touch with him on a regular basis.\n\n      I hope that this month's column will provide you with some new\nknowledge, or at least some new directions to think about.  Best of luck\nto all of you.  I'll see you next month.\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFigure 1.   Two Tape Jobs Contend for the Same Tape Drive.\n            Here's the reaction of native MVS without TapeMan.\n\n            Job SBGOLOBM needs drive 0560.  Then Job SBGOLOBN is\n            submitted, and it also needs drive 0560.  Here is the\n            sequence of messages that MVS generates, which must\n            be replied to.   When Job SBGOLOBM ends or is\n            cancelled, Job SBGOLOBN then pops up and requests its\n            tape on drive 0560.\n\n\n      JOB00304 $HASP373 SBGOLOBM STARTED - INIT 2    - CLASS B - SYS SYS1\n      JOB00304 IEF403I SBGOLOBM - STARTED - TIME=18.10.09\n      JOB00304*IEF233A M 0560,EXS002,,SBGOLOBM,TAPEMAP,\n                       SYS03092.T181009.RA000.SBGOLOBM.R0100022\n      JOB00305 $HASP373 SBGOLOBN STARTED - INIT 3    - CLASS B - SYS SYS1\n      JOB00305 IEF403I SBGOLOBN - STARTED - TIME=18.10.23\n      JOB00305 IEF244I SBGOLOBN TAPEMAP - UNABLE TO ALLOCATE 1 UNIT(S)\n                       AT LEAST 1 ALLOCATED UNIT(S) NEEDED.\n      JOB00305 IEF488I SBGOLOBN - SYSUT1 MUST WAIT FOR UNIT 0560\n      JOB00305 *02 IEF238D SBGOLOBN - REPLY 'WAIT' OR 'CANCEL'.\n      2WAIT\n      JOB00305 *03 IEF433D SBGOLOBN - WAIT REQUESTED -- REPLY 'HOLD'\n     * OR 'NOHOLD'.\n      3NOHOLD\n      JOB00305  IEE600I REPLY TO 03 IS;NOHOLD\n               c sbgolobm\n               IEE301I SBGOLOBM          CANCEL COMMAND ACCEPTED\n     JOB00304  IEF234E K 0560,EXS002,PVT,SBGOLOBM,TAPEMAP\n     JOB00305 *IEF233A M 0560,EXS003,,SBGOLOBN,TAPEMAP,\n                       SYS03092.T181023.RA000.SBGOLOBN.R0100023\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0305MY": {"ttr": 25097, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x06\\x01\\x03\\x10\\x1f\\x01\\x03\\x10\\x1f\\x10\\x06\\x00\\xdc\\x00\\xdc\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-04-11T00:00:00", "modifydate": "2003-04-11T10:06:06", "lines": 220, "newlines": 220, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                            MAY 2003\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.  The Online CBT Tape web site can be reached\nat www.cbttape.org .\n\n\nTHE CBT OVERFLOW TAPE\n\n      Today I'd like to say a few words about a lesser-known part of\nthe CBT MVS collection of software, which I think people should notice.\nMost folks will look at the very large \"regular\" CBT Tape collection\nitself.  But quietly, there is another piece of the CBT Tape collection\nthat has been picking up more and more importance.  This is the \"CBT\nOverflow Tape\".  I'd like to start, by supplying some of its history and\ntrivia.\n\n      As is implied by its name, the CBT Overflow Tape was originally\ncreated in 1996 because the regular CBT Tape got too big.  Even today,\nthe CBT Tape collection is actually on tape.  It is on honest to\ngoodness tape.  Most people access the CBT collection from its web site,\nbut the individual \"CBT\" and \"Overflow\" subdirectories (and the CBT249\nsubdirectory) each actually contains the complete contents of one\nphysical tape.\n\n      So how big is a tape?  Originally it was a 2400 foot 6250 bpi\nreel.  Then, as more people were in possession of cartridge drives, it\nbecame an uncompressed 3480 tape cartridge, which contains more data\nthan a 2400 foot reel tape does (maybe the equivalent of about 3000 feet\nof tape at 6250 bpi).  Finally, as the contributions accumulated and the\nuncompressed cartridge threatened to overflow, we took an informal\nsurvey and decided that enough people had 3480 IDRC drives, so we could\ndistribute the CBT collection in that format.  That's the type of tape\nwhich we use today.  One 3480 IDRC cartridge can hold (depending on data\ntype) perhaps the equivalent of about 5000 feet of 6250 bpi tape.  As of\nright now, the regular CBT Tape has almost this amount of data, and the\nCBT Overflow Tape contains about 4200 feet of data.  So they're both\npretty robust.\n\n      By the way, if your shop didn't have an IDRC-capable tape drive,\nwe thought of that too.  We developed a variant of the COPYFILE program\nfrom CBT Tape File 316, called COPYNLNL, which can be used to copy, say,\nthe first 300 files from a big NL tape onto one reel, and the rest of\nits files onto a second reel.  Thus, for the shops that needed it, we\n(or you) could conveniently divide a CBT Tape into two or more\nconvenient parts, to either 2400 foot reels, or to 3480 uncompressed\ncartridges.\n\n      One might think that the CBT Overflow Tape largely contains old\ncode, so it should be largely ignored, especially since the \"regular CBT\nTape\" itself is so big and formidable-looking.  Well, times are\nchanging.  And there actually is a lot of new code on the Overflow Tape\ntoo, as the CBT Overflow Tape is beginning to assume a new role.\n\n      For example, we just received a very large contribution from Fritz\nAlber called HICS.  HICS is an HSM/SMS front-end and DCOLLECT tool,\nthat potentially has great value to assist storage administrators.\nHICS also happens to contain a very large amount of data, comprising\nover 535000 80-byte card images, making it the single largest file on\nall of the CBT Tape collections.  Administratively, we couldn't put one\n273-foot (at 6250 bpi) file on the regular CBT Tape.  So we put it on\nthe CBT Overflow Tape as File 300 there.  HICS is new code, and it stlll\nhas a place on the CBT \"Overflow\" Tape.  That should give you an idea of\nthe new role which the CBT Overflow Tape is beginning to play.\n\n\nACCESSIBILITY OF THE OVERFLOW TAPE MATERIALS\n\n      You can get to all the CBT Tape materials from its web site,\nwww.cbttape.org, which is also accessible from the www.naspa.com web\nsite.  As all the CBT Tape materials are publicly available, you do not\nneed to be a \"member of anything\" or to have a password, to access CBT\nTape materials.  That was the premise from the beginning of the\ncollection when it was a tape--it belongs to the public.  Once on the\nweb site home page, you can click on \"CBT\", which will get you to the\ncomplete \"regular CBT Tape\" collection, and you can click on \"Overflow\",\nwhich will give you access to the complete CBT Overflow Tape.\n\n      I'd like to say a word about Updates.  Many files on the CBT Tape\ncollection are updated quite frequently.  On the regular CBT Tape,\nwe've recently been processing file updates or additions at the rate of\nabout 20 files per month.  That's about the rate that updates have\nrecently been coming in.  The CBT Overflow Tape files are updated less\nfrequently, but because the regular CBT Tape is now almost full, and we\nare starting to shuffle big (but still current) files to the Overflow\nTape, the Overflow Tape is now being updated quite often as well.\n\n      Where do the most currently up-to-date files get stored?  They\nare accessible from the CBT Tape web site on the \"Updates\" page.  And\nthe updated files to the CBT Overflow Tape can now be found on the\nUpdates page too.  Just look immediately below the updates to the\nregular CBT Tape, and you'll see what's new on the Overflow Tape as\nwell.\n\n      To those of you who are not familiar, I'll explain why we have an\nUpdates page on the CBT Tape web site.  Whenever we feel it is\nnecessary, a new version of the regular CBT Tape, or the CBT Overflow\nTape, is cut.  This means that all the files on the tape which have not\nbeen changed, will be copied to the new version, while the new versions\nof the files that have been changed, will be substituted for the old\nversions of those file numbers, and merged into the new cut of the CBT\nTape.  In addition, a new version of the File 001 documentation of the\nentire tape contents, and a new version of the File 003 \"tape to disk\nJCL\" will always be supplied.\n\n      What about in-between the CBT (and Overflow) tape version cuts?\nSometimes, a useful program or software package has been contributed,\nand we want to make it available to the public right away.  So all the\nnewest stuff, in between the tape version cuts, goes on the web site's\nUpdates page, and it is immediately avalable to be downloaded.  That\nprocedure also takes the pressure off me, to be constantly making new\nversion cuts of the CBT Tapes.  Any updates are \"pretty instantly\"\navailable, and they don't have to be made a part of the current\n\"official tape\" in order for people to use them.\n\n\nWHAT'S ON THE CBT OVERFLOW TAPE?\n\n      Basically, there are three types of things there.  First, as the\nname implies, there are overflow materials that are either too big, or\nnot current enough, for the regular CBT Tape.  So those materials will\noccupy files on the CBT Overflow Tape.  I might add the observation\nthat files that are \"not current enough\" are now widely being used by\npeople who are running old free MVS 3.8 on their Hercules systems.\n\n      Second, there are large software collections--complete \"other\ntapes\" as well, which used to be available as MVS software tapes, but\nwhich now are either hard to obtain, or which are not available at all.\nIn this category are SHARE's old MVS tape (called the SPLA MVS Tape or\nthe SHARE MVS Tape), the SHARE PL/I Tape, European and Asian G.U.I.D.E.\ntapes, the last version of the Los Angeles MVS Users Group Tape, and\nothers.  There is even an ISPF Tape that was going to be distributed by\nthe SHARE ISPF group, but which never got off the ground because of the\n\"depression of 91\", when a lot of people lost their SHARE commitments\nfrom employers.  That collection is called the \"ISPF Smoke and Mirrors\nTape\".  I would like to add, that if you are using a program from one of\nthose old tape collections and you have updates to contribute, you\nshould email them to me, so I can update them on the CBT Overflow Tape\nand make them available.\n\n      Third, I like to save old versions of code on the Overflow Tape.\nFor example, Ed Jaffe just made some good updates to the TSSO package\n(regular CBT Tape File 404), so TSSO will run on z/OS and OS/390.  (See\nlast month's column for the details.)  For people who have older systems\nthough (and we have to worry about them too), we have to keep the\nprevious versions of TSSO.  For example, if you're running an MVS that's\nolder than ESA 4.2, you can't run Ed Jaffe's TSSO from File 404.  So you\nhave to go to the Overflow Tape File 250, where you'll find the previous\nTSSO version preserved intact.\n\n\nOVERFLOW TAPE VERSION NUMBERS\n\n      As most of you know, the regular CBT Tape has consecutive version\nnumbers.  For example, as of this writing, the current CBT Tape version\nis 458, and we're currently accumulating the updates for version 459.\nYou can find on these updates we're accumulating, on the Updates page of\nthe CBT web site.  However, we decided that since the updates to the CBT\nOverflow Tape are more sporadic, it would make sense to keep its version\nnumbers roughly the same as the then-current regular CBT Tape.  For\nexample, recent version numbers of CBT Overflow Tapes have been 421,\n422, 428, 447, 455, 458, and 459, with all the in-between numbers having\nbeen skipped.  I just want to clarify that situation so the skipped\nversion numbers will not confuse you.\n\n\nPLEASE EXPLORE\n\n      I'm writing this month, to make you more aware of the \"other\nparts\" of the CBT Tape collection, where it is very likely that you\nmight find MVS software programs useful to you.  In addition, there are\neven older versions of CBT Tapes available at the CBT web site, for\nexample, CBT249, which is 1985-vintage stuff that could be helpful,\nespecially for the growing number of people who are running old MVS\nsystems under Hercules.  If you want to look at really ancient MVS\nstuff, there are complete AWS-format versions of CBT versions 072, 103,\nand 129.  You can use the VTT2TAPE program from CBT File 533 to cut real\ntapes or cartridges from AWS-format tapes (see the instructions on File\n533 for how to do it).  Otherwise, if you have a P/390 or a Hercules\nsystem, you can read these files directly as though they were tapes.\n\n      It is not \"madness\" or \"packrat-ism\" that encourages us to keep\nold versions of the CBT Tapes.  Arnold Casinghino, who was the first\nproprietor of the CBT Tape collection (I am the second), used to delete\nfiles regularly from the tape.  When Arnie felt that the tape was\nfilling up, he'd delete a bunch of files, as he did immediately after\nversion 249.  The result of this, is that if some installation was using\none of the programs that got deleted, they then wouldn't have easy\naccess to the original version of the source code, unless they had saved\nit themselves.  Often, they would only have a load module, which might\nhave stopped working on a newer MVS version.  As proprietor of the CBT\ncollection since 1990, I have gotten numerous requests for source code\nto programs, only to have found them on very old CBT Tape versions.  So\nas a safeguard to archive the original versions of old programs, we make\nit a practice to keep as much of the old sources available as we can, by\narchiving these old CBT Tapes at the web site.\n\n      One final note.  What does \"CBT\" stand for?  It originally stood\nfor the Connecticut Bank and Trust Company, where Arnold Casinghino (the\ntape's proprietor) worked.  After that bank folded and I had to take\nover the collection, we were wondering whether to rename it.  Since\neverybody already knew the \"CBT\" name, we decided to keep it and tell\neveryone that it does not stand for anything in particular.  Privately,\nwe joked that it stands for \"Casinghino's Big Tape\".  It has absolutely\nnothing to do with \"computer based training\".\n\n      I hope that you have enjoyed this month's column, which is a\nkind of \"break in the action\".  But I'd make a good bet that there'll be\ndozens of shops around the world who will get very big mileage out of\nsome of the materials on the CBT Overflow Tape.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0306JN": {"ttr": 25345, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x006\\x01\\x03\\x12o\\x01\\x03\\x13\\x1f#C\\x00\\xe6\\x00\\xe6\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-05-06T00:00:00", "modifydate": "2003-05-11T23:43:36", "lines": 230, "newlines": 230, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                            JUNE 2003\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.  The Online CBT Tape web site can be reached\nat www.cbttape.org .\n\n\nEXPLORING MVS SAMPLIBS\n\n      Today's topic concerns IBM-supplied \"sample libraries\" for MVS.\nAs almost all of you know, a \"SAMPLIB\" is usually a semi-supported,\nrelease-dependent collection of sample programs and possibly data,\nusually written by IBM employees, which show you how to use certain IBM\nfacilities.  For example, the SYS1.SAMPLIB for a given MVS release might\ncontain sample SMF exits (currently in member SMFEXITS), that show you\nhow to write your own IEFACTRT (job termination), IEFUJV (job\nvalidation), IEFUJI (job initiation), and IEFUTL (time limit) exits.\nThe supplied programs actually work.  Your own installation might have\nmodified these samples at one time, or someone there might have written\ntheir own SMF exit from scratch.  But in either case, IBM will usually\nkeep their samples in shape to run on the distributed MVS release, and\nthese coding examples are almost always helpful to have, at least for\nreference.\n\n      In this article I can only give an overview.  My purpose for\nwriting, is to awaken your interest in looking at the IBM SAMPLIBs and\nin raising your consciousness concerning them.  Obviously, even one\nsample program, such as the TSO exits IKJEFF10 or IKJEFF53, could be\nthe subject for a complete article, and nowadays SYS1.SAMPLIB contains\nover 1000 members.  So our discussion will have to be very general, in\nthe direction of suggesting useful places in SAMPLIB to look.\n\n      I personally have access to SYS1.SAMPLIB libraries at several\nlevels, including one from the MVT days, circa 1974.  The MVT sample\nlibrary is public domain software, and it may be found on File 079 of\nthe CBT Overflow Tape, on the CBT Tape web site.  The latest copy of\nSYS1.SAMPLIB that I have seen is for z/OS 1.4, and I have saved some\nothers from in between.  Part of the purpose of this article is to point\nout a few ways in which SYS1.SAMPLIB has changed since the early days of\nMVS and before.\n\n      A fact to know:  SYS1.SAMPLIB is a dataset which is modified by\nSMP/E.  In other words, the members of SYS1.SAMPLIB, for the most part,\nare officially a part of the MVS operating system.  Therefore, when a\nsystem component is enhanced in such a way that it runs differently\nthan before, its accompanying sample program illustrations might have\nto change.  Therefore, SPE's (Small Programming Enhancements) from IBM\nmight also be accompanied by SMP/E modifications to SYS1.SAMPLIB\nmembers.  Please keep this fact under your hat.\n\n      Before we go on, I'd like to mention one more thing.  SYS1.SAMPLIB\nhas always been the home of the object deck for IEAIPL00.  This is the\nbootstrap program which is loaded (via ICKDSF) into Track 0 of the disk\npack that you IPL MVS (or MVT) from.  And this is the program which\nactually does the Initial Program Load.  Every SYS1.SAMPLIB library I\nhave seen, contains a level of the IEAIPL00 program which is appropriate\nfor the level of MVS with which it is distributed.  So besides all the\nsample programs, JCL, and the like, SYS1.SAMPLIB will always contain a\ncopy of the current system's bootstrap program.\n\n\nSYS1.SAMPLIB PROGRESS\n\n      The MVT (OS/360 Release 21.8) SYS1.SAMPLIB library in my\npossession contains just 42 members.  Some of them are sample programs\nfor testing the language compilers.  Of course there is the ubiquitous\nIEAIPL00, because that is its home.  There are a few sample exits for\nSMF (which was already in place at the end of the MVT days) and the SORT\nprogram.  There are object decks to do standalone dump/restore of disk\npacks--a necessary function.  There are some sample terminal handling\nprograms for the terminals which were available then.  And there are JCL\nsamples to uncatalog and recatalog the system datasets.  That's just\nabout it.  Maybe there are one or two other things I've overlooked.\n\n      On the other hand, the current versions of MVS are a wee bit more\ncomplicated, a fact reflected by the SYS1.SAMPLIB which comes with z/OS\nRelease 1.4.  The z/OS 1.4 version of SYS1.SAMPLIB which I have seen,\ncontains well over 1000 pds members.  What are they for?\n\n      This current version of SAMPLIB, as were all previous versions, is\nhelpful to the extreme.  Illustrations abound for addressing the setup\nof just about every MVS component, from the System Logger to UNIX\nServices.  One thing that strikes the eye, when looking over a current\nSYS1.SAMPLIB, is the abundance of REXX execs now to be found there.  If\nyou think about it, that comes as no surprise.\n\n      Part of IBM's plan for MVS which was stated in the late 1980s, was\nthat CLISTs would be replaced by the REXX Command Language in TSO.  IBM\nmade a promise to enhance REXX, originally a VM tool, for TSO.  Part of\nthe direction was to make TSO REXX much richer in capability, and to\ngive it \"programming language\" status.  REXX execs can now address\nsystem storage and control blocks.  They can also pretty much do all the\ncomplicated TSO manipulations which CLISTs have traditionally done.  Of\ncourse REXX execs can be run both in Batch, and under TSO.  So when it\ncomes to doing all the system setups, and exercising the capability of\nthe newer MVS components, IBM people are utilizing the REXX language\nvery much.  And this fact is reflected very abundantly in the members of\nSYS1.SAMPLIB.\n\n      But there are some more things we should notice as we tour the\nmembers of the latest versions of SYS1.SAMPLIB, and this is especially\ntrue if our installation's PARMLIB members were last tailored many MVS\nreleases ago.  Sometimes, you just haven't explicitly coded all the\noptions you can in some PARMLIB member, and the uncoded PARMLIB options\nwill revert to the defaults.  Many explicit samples of PARMLIB members,\nshowing all the new settings and options, can now be found in\nSYS1.SAMPLIB, so they will jog your mind in suggesting what to change.\n\n      You might say that is not important, because IBM tries to keep\nas many option settings as upwardly-compatible as possible.  But my\nexperience has shown that a sysprog's head should not be kept in the\nsand.  Periodically, you should review all your installation's PARMLIB\nmembers to see if some of the newer options might be valuable to code.\nOf course there is always the risk that you might \"spoil something\" in\nthe operation and efficiency of the system by experimenting.  But I am\nnot advocating experimenting--I am advocating investigating.  Don't\nchange a PARMLIB member, just because a new explicit option is now\navailable.  Rather, look in the current \"MVS Initialization and Tuning\nReference\" manual and learn what all the settings are supposed to do.\nIf you see a new setting that you think might help your installation\nrun better, investigate it carefully before trying it out.  Don't play\nwith it until you're pretty sure about it.  But you have to start the\nprogress somewhere, and glancing at the sample in SYS1.SAMPLIB might be\nvery helpful.\n\n      You might think of taking this a step further and forgetting about\nSYS1.SAMPLIB altogether, relying only on the MVS Initialization and\nTuning Reference when reviewing your PARMLIB members.  But I'm not\nadvocating that either.  Remember that SYS1.SAMPLIB is usually well\nsupported by IBM, and its members have usually been supplied by the MVS\nprogramming staffs, not the \"system packagers\".  So the suggested\ncodings in the SAMPLIB members have to be given some consideration and\nweight.  It is very possible that a PARMLIB option, in the sample\nPARMLIB member from SAMPLIB, was coded a certain way for a very good\nreason (which may or may not apply to your shop).  And because of this,\nit behooves a sysprog to check SAMPLIB to see if a sample member exists,\nwhenever there seems to be a reason to change a PARMLIB member.\n\n\nSAMPLE EXITS AND PROGRAMS\n\n      In my experience, many shops will tend to propagate their system\nexits from one MVS release to the next.  This makes perfect sense,\nbecause you want your shop to look and run the same way, when the new\nMVS release is deployed.  You don't want the Operations people and IT\nmanagement to shudder every time the system is changed.  Rather, you\nwant them not to notice any changes at all, except for advertised\nimprovements and perhaps, better efficiency.  To them, everything\nshould continue to look more or less the same.\n\n      So a crucial part of achieving this is accomplished by keeping\nall the system exits the same, or at least completely compatible.  And\ntherein lies a possible problem.  The MVS system will sometimes be\nchanged in critical areas.  And this is necessary.\n\n      Let me illustrate.  At one point in time--I think it was around\nthe beginning to middle 1990s, IBM had a big push to allow data centers\nto operate on a 24x7 basis.  In other words, IBM was under pressure from\ntheir big customers to keep IPLs to a minimum.  So they had to redesign\ncertain internal components of the MVS operating system.  Old MVS'ers\nknow that many critical control blocks used to require an IPL to change\nor renew them.  Nowadays, they don't need an IPL.  What was the\nchange required?\n\n      Internally, the difference was in the \"static-ness\" or\n\"dynamic-ness\" of a control block's (or table's) structure.  As\noriginally designed, if MVS needed some data in an area of storage,\nthat area would be GETMAINed at IPL time and filled during the IPL\nprocessing with the necessary control block information.  Often, your\nsettings in PARMLIB would determine how much area would be GETMAINed\n(i.e.  acquired).  If you later saw that the area was not big enough\nfor your needs, you'd have to change the PARMLIB setting, and re-IPL.\nThis is the kind of situation that IBM was under pressure to \"seek and\neliminate\".  After all, if you want to avoid IPLs, it is better to make\nthese control blocks adjustable \"on the fly\" with perhaps an operator\ncommand.\n\n      So IBM developers went about systematically looking for these\nkind of statically structured control blocks, and replacing them with\ndynamically maintained ones.  This would require restructuring of the\nsystem data.  For example, suppose you had a table of system nodes,\nthat is, destinations of other computer systems which this computer was\nconnected to.  And all of a sudden, your computer's network was to be\nmerged with another network, and 150 new destinations had to be added\nto all the connected MVS machines.  That would normally require an IPL\nof each machine to rebuild the static \"destination table\" that resided\nin a single block of data.  But no IPL would be required if the table\nwere redesigned, so the individual entries were chained to each other,\nand if more table space had to be acquired, the new table entries in\nthe new space would just be chained to the old entries in the original\nspace.  It would not matter then, that the new table entries would\nreside in a storage area non-contiguous with the original area.  That's\nthe idea.  This is the kind of redesign being done very often in MVS.\nIf you've been around MVS for the past eight or ten years, you're\nfamiliar with it.\n\n      Now what if one of your system exits read this table the old way,\nthat is, it would only look for one piece of storage, and it would\nassume that each table entry was next to the previous one?  This would\nclearly cause an error in the MVS system's operation.  Often, that kind\nof error is very difficult to diagnose and causes mysterious problems.\n\n      How do you fix it?  Often, the best way to fix it is to look in\nSYS1.SAMPLIB at a newer sample version of that same system exit.  There,\nyou would find a piece of code, written by some IBM-er who should know,\nthat accesses the redesigned control block or system table \"the new\nway\".  By looking in SYS1.SAMPLIB your work is minimized.  You don't\nhave to conduct an in-depth investigation of the new workings of that\nsystem table or control block.  You just have to copy or modify the\nIBM-er's new sample code that's waiting for you, right in SYS1.SAMPLIB.\nSystem maintenance across MVS releases is thereby made much simpler and\nmore accurate.  It's done in far less time, and with fewer complaints\nfrom management.\n\n      So I hope that I've opened your eyes to one other area of this\nvast MVS world which is our everyday domain.  A sysprog has to be ever\nvigilant for the cause of errors, even if they don't occur very often,\nand your system runs smoothly most of the time.  SYS1.SAMPLIB is another\nof the many resources that IBM has supplied to help you, and it is very\ngood to be aware of it.  I wish all of you the best of everything, and\nI'm looking forward to seeing you again next month.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0307JL": {"ttr": 25350, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x002\\x01\\x03\\x16/\\x01\\x03\\x16?#\\x13\\x00\\xdd\\x00\\xdd\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-06-11T00:00:00", "modifydate": "2003-06-12T23:13:32", "lines": 221, "newlines": 221, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                            JULY 2003\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.  The Online CBT Tape web site can be reached\nat www.cbttape.org .\n\n\nATHLETICISM IN SYSTEMS PROGRAMMING\n\n      In my opinion, musicians are athletes.  They don't lift heavy\nweights, throw baseballs at 98 miles per hour, or run 40 yards in 4.2\nseconds.  But in order to play the required number of notes with the\nrequired precision and tonality on their respective instruments, they\nhave to move their fingers, mouths, lungs, arms or feet with strength,\nenormous coordination and endurance.  This usually requires many years\nof physical and mental training.  So I think that anyone would be hard\nput to argue that a musician is not an athlete.  Just about every\nmusician, and for sure a professional one, is a prodigious athlete.\n\n      So what does this have to do with systems programming?  I learned\nearly in my career that it has a great relevance.  In truth, I think\nthat all of us will agree to this.  It's just that we don't think of the\nsituation in precisely a way which points out this association of some\nof our activities with athletic acts.\n\n      For example, when installing a new version of MVS, has any of us\nhad to build a new list of dataset names or the like, from another list,\nin a non-trivial way?  All of us have had to do that, one time or\nanother.  And we usually had to do it by hand, because a utility to do\nprecisely what was needed, was not available.  So we had to bite the\nbullet and sit at the terminal for several or many hours, until the new\nlist was in good shape, and the new system would be able to use it\nwithout an error on even one line out of many hundreds or thousands of\nlines.\n\n      Again, in my mind, that is a feat of athleticism.  Although we\nmay only have to do it once in a great while, this is still an act of\nathletics.  It requires a great concentration and a coordination of mind\nand body.  One mistake can lead to a disaster and a great loss of\nproductivity for the installation.  Every line of the resulting file has\nto be exactly correct, and often we don't have a utility program that\nlets the computer do the job for us.  So, at least occasionally, we are\nall required to be athletes.  And it is this athleticism that I am\naddressing today.\n\n\nIS OUR ATHLETICISM GOOD OR BAD?\n\n      My quick answer for this question is that we try to avoid it,\nbut that it sometimes is necessary.  My opinion is that a good systems\nprogrammer should avoid athletics and acquire a good command of\nutilities that will get a job done, using the computer to do the\nlabor.  In other words, a good systems programmer is not lazy to learn\nhow to use a new utility, because the utility will ultimately help\navoid a situation in which athleticism is currently the only answer.\n\n      On the other hand, we should not flinch from athleticism when it\nis necessary, but we should jump in, grit our teeth, do the big job, and\nthen it will be done.  That's part of a systems programmer's skill set\ntoo.  Sometimes a job needs to be done now.  Looking for a utility would\ntake too long, if you don't already have one.  So you just do it the\nlong way, get it done, and be proud of yourself.\n\n      So my take is that system programmer athletic feats should only be\nnecessary when they are unavoidable.  In other situaions, we should\nhave a command of utility tools that will let the computer do the labor\nfor the job we need done.  The computer is faster, and if the utility is\nappropriate for the job, it is more accurate.  I have seen systems\nprogrammers who perform athletics during much of their regular daily\nwork.  For them, I have the criticism that they did not take the time or\neffort to learn how to use the tools that are available.  In our job, I\nfeel that athleticism does not really have to be employed very often.\n\n      Telling you about tools which avoid \"sysprog athletics\" is one\nof the reasons why I write this column.\n\n\nSTEPS TO AVOID SYSPROG ATHLETICS\n\n      As I said before, I think it's better for the computer to do the\nwork than for you to have to do it.  So to that end, one should start to\nacquire, or continue to acquire, a repertoire of tools to help you do\nvarious kinds of jobs.  A good place to look for tools, is the huge free\ncollection of MVS sysprog goodies known as the CBT Tape collection.  You\ncan get to its web site through the NaSPA web site, or you can get to it\ndirectly through its own URL.  The CBT Tape collection actually is also\navailable on two tapes, and the various single contributions to the\ncollection are normally referred to by their tape file numbers.\n\n      I would say that the first tool to look for, if you don't already\nhave it, is the PDS multi-utility program on File 182 of the CBT Tape.\nOriginally written at the Firemen's Fund in San Francisco, and greatly\nexpanded by Bruce Leland and Steve Smith, the PDS command package is now\nmaintained by John Kalinich, who does his best to keep it as useful as\npossible.  The PDS program should rightfully be the subject of several\narticles, as it has been in the past.  See members $PDSART0 thru\n$PDSART3 in File 182, which is a course on how to use most of the many\nsubcommand utility tools in the PDS command package.\n\n      The PDS package is a TSO command containing approximately 50\nsubcommands, each of which invokes a separate utility function.  Within\neach subcommand, there are sometimes as many as 40 or 50 variations as\nto what can be done.  So I would safely say that the PDS command package\ncontains perhaps 1000 separate utility functions within itself.  PDS\nalso has an ISPF interface that invokes all the line-mode PDS commands\nand more.  If you are running the PDS command in an ISPF environment\nand you copy its panels and messages to the appropriate libraries for\nyour TSO session, you have a formidable arsenal of utility functions to\nhelp you avoid \"sysprog athletics\".  As are all of the contributions to\nthe CBT Tape collection, the PDS command package is perfectly free.\n\n\nHOW A TOOL LIKE THE PDS PROGRAM CAN HELP\n\n      When you get somewhat familiar with the capabilities of the PDS\nprogram, you'll start to realize that some jobs you've formerly pictured\nas arduous tasks, become ridiculously simple to do.  For example,\nsuppose you have a partitioned dataset with many members in it, and you\nwant to search the members for a string of characters.  With the PDS\nprogram it's no problem.  Just issue a FIND subcommand with the PDS\ncommand pointing at your partitioned dataset.  Give FIND the member\ngroup of members (or a colon : for all members) you want to search\nthrough, and put the string between two delimiters (like / or ?)\nafter the member group.  The whole command will look something like\n\n   FIND : /mystring/\n\nThe PDS command will go through the entire partitioned dataset, and\ndisplay all occurrences of the string.  It's that simple.  Once you know\nwhich members contain the string, you can deal with them any way you\nwant.\n\n      But it doesn't stop there.  You can grab the group of all members\nwhich contain the string, and deal with that group as one entity,\ndirecting subsequent PDS subcommands at just that subgroup of members.\nThis is done by referring to the current subgroup of members with an\nasterisk.  You can create this subgroup from the group of all members by\nissuing the PDS command:\n\n   FIND : /mystring/ THEN(SUBLIST)\n\nThis creates a group of members consisting of a list of member names,\nwhich all contain the requested character string.  A subsequent FIND\ncommand for a different string can now be directed at this subgroup of\nmembers only, like\n\n   FIND * /otherstring/ THEN(SUBLIST)\n\nThat subsequent FIND command in PDS will further reduce the current\nsubgroup of members to a list containing the first string, reduced to\nthose members which also contain the second string.\n\n      You are starting to get the idea that a tool this good can save\nyou quite a bit of raw gut work.  Multiply by the fact that there is a\nREPLACE command that works like the FIND command, and there are about\n50 other different types of subcommands as well, which can operate\nagainst all members in an entire subgroup of the pds members.\n\n      Once you're thoroughly familiar with the workings of the PDS\ncommand package, you'll find yourself doing a lot less \"athletic work\"\nand you'll be getting your jobs done far more accurately and in far less\ntime than ever before.\n\n\nREXX EXECS AND CLISTS CAN HELP\n\n      The PDS command package is written in Assembler, and even though\nit contains an enormous amount of built-in capability, you might find\nthat the quickest solution to a given problem is to make your own CLIST\nor REXX exec to handle the specialized situation.\n\n      For example, suppose you are comparing two files and picking out\ndifferences between them.  You might try to use a tool like SUPERC to\ndiscover all the file differences, but once having done that, you might\nwant to write a REXX exec to read the two files line by line, and then\nmanipulate their contents in some special way.  This might turn out to\nbe the quickest way to solve your particular problem.\n\n      If you don't know how to do this, the CBT Tape collection is full\nof CLIST and REXX collections that do particular jobs.  You can search\nthe CBT Tape collection for CLISTs and REXXs, until you find one that\ndoes almost what you need to do.  Then you can copy most of the code,\nwhich is free, and adapt that code so it gets your particular job done.\n\n      Files 95 and 251 contain many CLIST-based edit macros from the\nlate Paul Davis.  In the newer CBT Tape files, from the 400s up through\nthe 600s, there are many REXX-based tools, and there's a lot of code to\nlook through and copy from.  You can look at the 50000-plus lines of the\nCBT tape documentation (File 001 of the tape) using the PDS command, and\njust scanning that file for the word \"REXX\", you'll discover many\ncollections of REXX-based tools to look through.\n\n\nSUMMARY\n\n      So I've only scratched the surface, to indicate a direction to go.\nIf you want to avoid having to do huge feats of \"sysprog athletics\"\noften, you should start to acquire a collection of utility tools that\nmake long jobs easier, like the PDS command package from CBT Tape File\n182.  Once you've installed this package and become somewhat familiar\nwith it, then you've taken a big step toward avoiding \"athletic\nsolutions\" for your big jobs.  Learning to write REXX fluently will help\nyou a lot too.  And if you've solved a big problem by writing a\nspecialized REXX to do it, you might think of donating it to the CBT\nTape collection, so that other system programmers won't have to reinvent\nthat wheel.  Instructions at the CBT Tape web site will tell you how to\ndonate your work.  Or you can email it directly to me.\n\n      Devoting a half hour per work day to looking for and acquiring new\ntools from the CBT Tape collection, will save you many hours of athletic\nsystem programming in the future.  Best of luck to all of you.  I hope\nto see you here again next month.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0308AU": {"ttr": 25355, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00G\\x01\\x03\\x18\\x7f\\x01\\x03\\x18\\x7f\\x14R\\x01\\x0b\\x01\\x0b\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-07-06T00:00:00", "modifydate": "2003-07-06T14:52:47", "lines": 267, "newlines": 267, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           AUGUST 2003\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.  The Online CBT Tape web site can be reached\nat www.cbttape.org .\n\n\nNOVEL IDEAS\n\n      Sometimes a new concept is born, which will revolutionize our\ntechnique as MVS systems programmers.  Often, this new concept, when\ntaken out of context, does not appear to be overly revolutionary and\nearthshaking.  But it has that effect nevertheless.  It is the result\nof thinking simply, but out of the mold and away from the \"usual\".\n\n      For example, consider the idea of doing a TSO RENAME to a large\nnumber of datasets (which Steve Pryor talked about a couple of months\nago in his Technical Support column).  The TSO RENAME command does\ncontain a provision to do a \"generic rename\" with one execution, but our\nexperience shows that it often fails, claiming the lack of a sufficient\nworkarea.  And so, most of us do not often attempt to use the TSO RENAME\ncommand to rename more than one dataset at a time.  Then what are the\nalternatives?  They usually boil down to making a long list of TSO\nRENAME commands and executing them either under TSO-in-batch or as a\nCLIST.\n\n      So now, the \"revolutionary idea\" has to enter.  It is:  What if\nyou write a REXX exec in such a way, that the REXX exec generates the\nlong list of TSO RENAME commands automatically, and you don't have to.\nThat will save you time; it is almost as good as doing a generic rename\nwith the RENAME TSO command, but it doesn't have the downside of the\ngeneric rename's unreliability.  All the renames get done one dataset\nat a time.\n\n      Extend this idea one step further.  Why does the concept have to\nbe restricted to running just the TSO RENAME command?  Let it generate\na long list of arbitrary TSO command executions, against say, all the\ndatasets beginning with a given high level qualifier.  Somebody has\nimplemented this idea.  It does not seem like a difficult concept to\nunderstand.  But it does save a great deal of our precious time, and\nit certainly eliminates athleticism (see last month's column for an\nunderstanding of that term).\n\n      I wouldn't mention this idea if it hadn't already been implemented\nsomewhere, and been accessible to us.  We normally don't deal in\nvaporware here.  The \"mass renaming\" tool is on the CBT Tape collection,\nin File 635, and its generaliztion, to execute an arbitrary TSO command\nagainst all datasets in a LISTC LEV( ) list, is in File 636.  These may\nbe found on the Updates page of the CBT Tape web site (accessible with\nits own URL and also through www.naspa.com), or if a CBT Tape Version\nhas already been cut, with these files included, they will be on the\nregular CBT Tape page of the CBT web site.\n\n      The author of these REXX execs has made one additional comment.\nHe tells me that in his experience, these REXX execs not only saved him\ntime, as written, but they also serve as templates and models for\nwriting additional REXX execs to do other, similar jobs.  So the bottom\nline is that this pattern of novel thinking can grow to an abundance of\ntime saving ideas.  That's a pattern which is wise to cultivate, in our\nown thinking and our own approach to this job.\n\n\nWHEN IBM SAYS YOU CAN'T....\n\n      It is my experience that a lot of good ideas come when someone\nsays \"it can't be done\".  This stirs some creative juices within us, and\nwe answer:  \"It can be done, and I'll be the one to do it!\"\n\n      Of course, not everyone is the one to do everything.  But if you\npick one project that is particularly dear to you, and concentrate on\ndoing the research for it, you will get it done.  You will do the\n\"impossible\", and you'll do a good job of it, too!\n\n      Meanwhile, you might have to find someone else who has already\naccomplished a project that was a little lower on your own priority\nlist, since you probably don't have time to write everything yourself.\nA good place to look, is the CBT MVS collection that we mentioned above.\nThat is a place where a lot of people share the results of their pet\nprojects, and you can find many tools which do wonderful things that IBM\nsaid \"couldn't be done\".\n\n      For example, I've accomplished a few things that \"couldn't be\ndone\" with my own projects.  Since I'm the proprietor of the CBT Tape\ncollection, and the collection still does reside on tape, it is no\nsurprise that many of my own efforts have been concentrated around tape\nmanuipulation.  For instance, I have done extensive work on a formerly\nsimple (but very elegant) tape copying program called COPYMODS (see File\n229 of the CBT Tape collection).  COPYMODS was designed to make \"Xerox\ncopies\" of an entire tape--as many as 10 of them at a time--now I can\nmake 16.  Since COPYMODS had a few known limitations, I started by\ntrying to take care of them.  In the process, I wound up adding 60 or 70\nnew features to the program, enabling COPYMODS to do some hitherto\nimpossible things and \"go where no tape manipulator has ever gone\nbefore\".\n\n      A few things I can do with COPYMODS:  I can write out all the tape\nlabels from an SL tape, to an external file.  I can then copy the tape\nto an NL target tape (or as many as 16 of them, if I have enough\ndrives), stripping off any file that looks like a tape label.  Then, I\ncan splice all the labels back, sandwiching the NL tape's data files\nbetween the appropriate labels (which I may have edited meanwhile),\ncreating a perfectly valid SL tape (or up to 16 of them) as a result.  I\ncan also INIT tapes with COPYMODS; I can copy some files from the\nbeginning and stop where I want to.  And I can do many more tricks, most\nof which IBM says you can't do.\n\n      Another project:  I have also produced a full set of utilities,\nwith the help of my friend Vinh Vu, that can handle almost any need you\nhave regarding the user messages in SYS1.BRODCAST.  With these\nutilities, which are perfectly free, you can even back up SYS1.BRODCAST,\nsend it to another system, reload it there, and expand it, together with\nall the user messages that are in it.  IBM says that you can't delete a\nparticular user's messages--only that user can.  Our package can do it.\nNot only that, but you can also delete some of the user's messages and\nleave some.  That used to be \"impossible\".  We (this is in Vinh's part)\ncan also print any user's messages out.  We can do many more things too.\nAll of that SYS1.BRODCAST stuff is in File 247 of the CBT Tape\ncollection.\n\n      The bottom line to all of this is a wonderful fact.  IBM might say\nthat you can't do something in the MVS operating system.  But they\nusually provide tools for you to write a program, or a program package,\nthat allows you to do the very things they say you can't do.  It's a\nfact, Jack.  IBM gives you the building blocks to make all kinds of\nnovel tools for yourself.  And then you'll be able to do whatever they\nsaid you couldn't.\n\n      And an even nicer thing is, that you don't always need Assembler\nlanguage.  Sometimes REXX alone will do the trick very well.  The\nimportant thing is to know what you want to do, and to think outside the\nmold.  Look at it a bit differently than everybody else has.  Get to\nanalyze the essentials of the situation.  See what system structures are\ninvolved, and find out how to get to them properly and most efficiently.\n\n      I can show you hundreds of clever examples of what people have\nwritten--just look through the files of the CBT Tape to find many tools\nto do what IBM said \"couldn't be done\".  People suggested these ideas\nto IBM too, once the deeds were accomplished.  And later IBM added their\nown ways to do what they themselves had previously said \"couldn't be\ndone\".  Many \"SHARE Requirements\", which are requests to IBM to change,\nimplement, or fix some facility, have originated from user-written\nworks which did the same job first, on an informal basis.  Those tools\nwere on the CBT Tape for everyone to see, and then someone suggested\nthe same idea to IBM.\n\n\nGOOD THINGS COME IN BUNCHES\n\n      Recently I have been amazed by the fact that several people\ndeveloped similar ideas independently, within a short span of time, and\nsubmitted them for inclusion in the CBT Tape collection.  I am very\nhappy to see such things occur when they do, and I like to encourage\nthat.  We got two automated system shutdown packages at nearly the same\ntime, and we got several DASD space listing products, to mention a few\nof the things that have happened recently.  I always include all\nversions of all of these similar contributions on the tape (provided\nthat they work, of course), for the following reasons:\n\n      First, there is cross-fertilization of ideas.  Vendors who write\nsoftware for pay, have a hard time understanding this concept.  Vendors\ntend to hide their ideas from the other vendors, because they want to\nsell a product that is better than their competitors' products.  So the\nvendors tend to be secretive.  They hide their source code, and so\nforth.  But when you write software for free, you don't care that\nsomebody else knows about it.  So each author who writes something\nsimilar to what the other guy wrote, can look at the other guy's work\nand improve his own, without worrying that anything might be wrong with\nsuch a practice.  With free software, everybody can help everybody else,\nand it's all to the good.\n\n      Secondly, it's been my experience that two different products\nwhich \"do the same thing\" are both useful, because circumstances will\narise when one of them will stop working, while the other of them will\nstill keep working.  For example, in the arena of listing DASD space,\nMVS system changes have recently occurred that render programs which use\nthe IEFEB4UV service useless, while those which use other methods of\nlisting free DASD space will still work properly.  So if you have access\nto several tools to list DASD free space, you won't be completely stuck\nwhen one of them stops working on a new MVS release.\n\n      Therefore, I will put two different programs to do the \"same job\"\non the CBT Tape, and I am happy to do it.  I also encouraged the two\nauthors of the MVS shutdown packages to look at each others' work, and\nthey have both done so, enriching their own work in the process.  The\ntwo automated shutdown packages are on CBT Tape File 588, from Sergey\nMakogonov, and on File 623 of the CBT Tape, from Hunter Zhou.  Zhou\nalso has an AUTOIPL piece too.  The two authors use different methods\nto accomplish the \"same result\", but it gives us a comfortable feeling\nto have a choice as to which package to use.\n\n\nSOME ADDITIONAL THOUGHTS\n\n      In my many years of handling and packaging free MVS software, I\nhave seen a lot of people's opinions.  And I have heard lots of people's\nparticular needs for tools.  My point of view is different than that of\nmost MVS folks, because of this unique vantage point.  And I'm here to\nhelp and to share that viewpoint.\n\n      For instance, one thing I've seen is that there happen to be\nquite a few shops who are still running antiquated versions of the MVS\noperating system.  Y2K has lessened the frequency of this, but since\nOS/390 1.3 is probably the earliest Y2K-compliant MVS release, you can\nbet that there are still a few shops running OS/390 1.3, either for\nbudgetary reasons, or because somebody in management doesn't want to\nchange.  So the sysprogs who manage those systems have to adjust their\ntools accordingly, because they have no voice about upgrading--their\nhands are tied.  Thus, if someone writes a tool that starts working at\nsay, the OS/390 2.4 level--for instance, if it uses the Catalog Search\nFacility that was introduced at the 2.4 level--then the people at the\nOS/390 1.3 level can't use it.  So the search for a substitute tool that\nalso works for OS/390 1.3 often gets thrown into my lap.  Thus it pays\nfor me to know about several tools which do the \"same job\".\n\n      Here's another thing I've seen quite a bit of.  I've come across\npeople who have spent much of their lives working for software vendors.\nA few of these people tend to be more sensitive than necessary about\nlooking into other people's source code, or changing it.  When you deal\nwith free software, such concerns usually do not enter, but someone with\na vendor mentality who is not used to freely available source, may feel\nthat something is not proper, when it actually is proper.  Of course it\ndepends on the particular person, but this attitude can sometimes affect\nthe working of a particular tool, if somebody with the ability, is\nafraid to fix the tool for public use.  Free tools are accompanied by a\ndifferent mentality than vendor-supported tools.  Free tools are free to\nbe fixed, in most cases, and that's how they can remain useful to the\npublic over a long period of time.  You shouldn't be afraid to fix a\nfree tool, and to submit the fixed code for inclusion back into the CBT\nTape.  That's for everybody's benefit over the long run.\n\n      Finally, I'd like share another bit of my experience.  At first\nglance, you might think that I'm \"rehashing the obvious\", but I have\nobserved that from an MVS perspective, it yields big dividends to dwell\non this point.  The idea is, we should notice that each person's\nexperience and talents are different from everyone else's.  Of course,\nthat's obvious, but what's not obvious, is that a diversity of\nexperience among people is to everyone's benefit, especially when it\ncomes to sharing tools.  We should all be thankful that we're all\ndifferent from each other, rather than complaining that the other person\ndoesn't think like we do.  Because of the diversity of people and their\nexperience, each one acquires the expertise to handle a different area\nin developing tools and techniques.  I mentioned before that I was once\nasked to develop a set of utilities for manipulating SYS1.BRODCAST\nmessages.  And everyone else can benefit from that particular experience\nof mine.  Other folks have had other needs, and they have developed\ntools appropriate to cope with them.  To the extent that they have\nshared these tools, we have all of them available to us.  So we have to\nbe very thankful for those other people's different circumstances,\nbecause they constantly help us to solve our own problems.\n\n      So in summary, I hope that I'm encouraging all of you to have your\nown novel ideas, and to develop them to the best of your own ability.\nAnd you shouldn't hesitate to use and benefit from the novel ideas of\nother people too.  Please share some of your own ideas with us, and\ncontribute them to a public collection like the CBT Tape.  It's a good\nworld out there, when people help each other.  Have a good month, and I\nhope to see you here next time.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0309SE": {"ttr": 25604, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00D\\x01\\x03\"o\\x01\\x03%?\\t\\t\\x01&\\x01&\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-08-14T00:00:00", "modifydate": "2003-09-10T09:09:44", "lines": 294, "newlines": 294, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         SEPTEMBER 2003\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.  The Online CBT Tape web site can be reached\nat www.cbttape.org .\n\n\nA FRESH LOOK AT THE PDS COMMAND PACKAGE\n\n      I am happy to say that growing numbers of sysprogs are doing\nthings to improve your life.  How?  They are writing and enhancing\nutilities for their own use, but they are sharing them with the public.\nAnd there is a great difference between \"free software\", which anyone\ncan use, and \"free market software\", that is, vendor software, which for\nan MVS system, usually costs a big bundle.\n\n      So when I read the announcements about new vendor products on the\nmarket, I usually say \"whoopdie doo\", and I'm only interested if the new\nstuff has something to do with a need of ours.  But if I read about free\nsoftware that came out, I'm all ears.  And that's because I can use all\nof it, right away, myself, with no restrictions.\n\n      I'm writing this just before SHARE, and Sam Knutson is busy\nmaking duplicates of the CBT Tapes (the actual tape cartridges) and the\ncd-roms containing the CBT Tape materials.  Sam Knutson gives out\nmany hundreds of tapes and cd-roms at SHARE, on his own initiative, to\nbe able to help make our lives easier.  And I, for my part, being the\nproprietor of the CBT Tape collections, have just come out with new\nreleases of both the regular CBT Tape and the CBT Overflow Tape, for\nthe occasion.  This could only have been made possible by people's\ncontributions of software.\n\n      Over the last year or so, we've been fortunate to get\ncontributions for the CBT Tape collections at a rate averaging about 20\nor 25 per month.  So there's been a lot of activity and improvement.  My\nreaction at seeing so many new developments, is to try and resist being\noverwhelmed, but I still feel like a kid in a candy store.  I look\nthrough everything with a quick overview and pick what strikes my eye,\nfor trying out.  Some really nice packages and programs have passed\nthrough our portals recently, but I'd really like to present an \"oldie\nbut goodie\", because I feel it has been neglected by many people who\ncan really use it.\n\n\nTHE PDS TSO COMMAND PACKAGE\n\n      I have a good reason for mentioning the PDS command package here.\nThe PDS command (which is free software) is currently maintained and\nkept up-to-date by John Kalinich, and it resides on File 182 of the CBT\nTape collection.  Load modules for PDS are on both Files 035 and 135 of\nthe CBT Tape, but you should also use its ISPF panels and messages that\nare on File 182, although you don't have to run PDS in ISPF mode.  As\nof this writing, the current version of PDS is 8.5.24.\n\n      For clarity in this discussion, I'll refer to a partitioned\ndataset as a pds, in lower case, while I'll talk about the PDS command\npackage itself, as PDS, in upper case.\n\n      Now, for my reason:  It has been my observation that even though\nthe PDS TSO command package is quite old, and versions of it have been\naround for many years, (I remember using an ancient version of it on MVT\nwhen I first started in this business) some people use it, and some do\nnot.  I guess you can make that statement for any package--some people\nuse it and some don't.  But PDS is very different.   The PDS package, as\nit is today, has at least a thousand (I didn't say a hundred) different\nutility functions.  And something that versatile and useful shouldn't be\nignored by ANYONE, in my opinion.  So I think it's important for me to\nsay something about it.\n\n      How do you start talking about something so vast?  We are\nfortunate with PDS, because you really can begin at the beginning.  It's\nonly afterward that the sky's the limit.\n\n      You invoke PDS as a TSO command, and you point it at a dataset\nname.  That is, you invoke PDS from a TSO session by saying its name,\nas a TSO command, followed by an operand--a dataset name.  The dataset\nname is that dataset which you want the PDS command to manipulate.\n\n      And manipulate, it can!  Please see Figure 1 for a general summary\nof some of the PDS subcommand categories.   And see Figure 2 for an\noverview of more.  If you want to learn more about the PDS command\npackage in depth, I once wrote a course on it.  My course is distributed\nwith the PDS command package on CBT Tape File 182, as members $PDSART0\nthru $PDSART3.\n\n      What can PDS do in a dataset?  I can only begin the story here,\nbut I can't end it here.  If you're interested in becoming a \"true\ndataset jockey\", you'll investigate further than what I can mention now.\nAt least read my course!  At the time I wrote that material, I invested\nmany hundreds of hours in learning it.  And I still use the knowledge in\nmy everyday work today--even so many years afterwards.  It has not\nbecome obsolete.\n\n      I want to show you one more clever thing about the PDS command\npackage.  A function as simple as a pds member rename, has an added\ntwist when you're talking PDS language.  Of course, you can rename one\nmember to another name, possibly with a REPLACE operand if the new name\nexists and you want to replace it.  But PDS can do something that no one\nelse can.  You can use PDS to SWAP dataset names in one operation.  For\nexample, you can say, RENAME MEMBER1 MEMBER2 SWAP.  This will rename\nMEMBER1 to MEMBER2, and MEMBER2 to MEMBER1 in one operation, without\ninvolving a third name as an intermediate.  If you don't use PDS, you\ndon't know how to do that!\n\n      So PDS can do a lot of ordinary things to a dataset, and a lot of\nunusual things too, like expanding the number of directory blocks in a\npds, on the fly.  If you run out of directory space, there's no need to\nreallocate a bigger dataset, copy the data over, rename and delete the\nthe old dataset, and rename the new dataset to the old name.  Just say:\nFIXPDS EXPANDDIR(nn), where nn is the number of directory blocks you\nwant to add, and just answer YES to the prompt.  Even though you don't\nhave RACF ALTER access to the dataset, just UPDATE access, you should\nstill be able to do that.  Expanding the directory works by copying\na few of the beginning pds members to the end, and using the freed\nspace at the beginning, to reformat as new directory blocks.\n\n      There's so much more, that I can't begin to mention it.  One thing\nabout the PDS command package is so unique though, that I can't leave\nthis discussion without talking about it.  That is, the concept in PDS\nof \"member groups\", which actually means \"subgroups of the pds members\".\n\n      The PDS command package recognizes two distinct categories of\nmember subgroups.  The first is a member subgroup that is defined by\nRULES.  The second is a member subgroup that is a LIST of member names.\nYou use the MEMBERS subcommand of PDS to define a subgroup using rules.\nYou use the SUBLIST subcommand of PDS to define a subgroup as a list of\nmembers.  The current member group defined by PDS is always referred to\nby using a single asterisk (*) instead of a member name, in any PDS\nsubcommand that deals with a member.  Thus, by using the asterisk as a\nmember name in a PDS subcommand, you do the operation on all the members\nin the subgroup--possibly hundreds of them at one time!  And for the\nrecord, if you ever want to refer to ALL the members in a pds as one\ngroup, you use the colon (:) as a \"member name\" in a PDS subcommand,\nto designate \"the subgroup of all members in the pds\".  And the\noperation will be performed on all of the members in the target pds.\n\n      Defining a member subgroup by rules, consists of using the\nwildcard symbol (*) and the pattern symbol (/) in various combinations.\nFor example, if you want to define a group of members beginning with\nABC, you'd say:  MEMBERS ABC* , whereas if you want to define a group\nof all pds members with the string ABC included anywhere in the name,\nyou'd say:  MEMBERS ABC/ or MEMBERS /ABC .\n\n      Defining a member subgroup as a list of names, is very similar.\nYou just use the SUBLIST subcommand instead of the MEMBERS subcommand.\nBut the effect is very different.  When you use the SUBLIST command\nalong with a rule (wildcard or pattern or a combination), PDS does not\njust leave the rule intact, to define the group.  Instead, PDS goes\nthrough the entire pds directory, and picks out all of the actual member\nnames which satisfy the rule conditions, and then it defines the list of\nnames as the group (NOT the rule).\n\n      What difference does this make?  Plenty!  Much of the difference\ntakes effect when you issue a CHANGE PDS subcommand to change the target\npds that the PDS command is aimed at.  When you CHANGE the target\npartitioned dataset, PDS does not change the default subgroup.  If that\nsubgroup is defined as a rule, it will refer to a different subset of\nmembers in the new pds--those members in the new pds that satisfy the\nrule.  But if the member subgroup is defined as a list of member names,\nand you CHANGE the target pds that PDS is pointing to, there may be no\nmember names in the new pds, that are common with the member names in\nthe old pds.  So the default member subgroup in the new pds, may\nactually turn out to be null, but this will not be seen until you issue\na new PDS subcommand against the default group (*), and no member name\nmatches turn up against the old list.\n\n      You can always convert the default member group to a list of\nnames, by issuing the SUBLIST * command.  This will cause PDS to look\nat all the member names in the target pds which overlap with the\ncurrently defined member subgroup, and cause that list of names to be\nthe new \"currently defined member subgroup\".\n\n      There is another (and extremely powerful) way to define a member\nsubgroup, and that is with the IF and FIND PDS subcommands.  IF will\npick a subgroup of members based on about 60 possible different\ncriteria.  And FIND will pick a member subgroup of all members which\ncontain, or don't contain, a certain character string.\n\n      Thus, you can say:\n\nIF : CHANGED(mm/dd/yy:mm/dd/yy) THEN(SUBLIST)\n\nand this will mean, that all members with ISPF statistics showing that\nthey were changed between the two indicated dates, will be chosen for\ninclusion in the \"list\" member group.  Or you can say:\n\nFIND : /somestring/ THEN(SUBLIST)\n\nand this will mean that from all the members in the pds, you are\npicking only the members containing the indicated character string, to\nbe included in the member subgroup list.\n\n      Once you've picked your group, you can either refine it further\nby picking a smaller subgroup from it, containing a second string.  For\nexample:\n\nFIND * /secondstring/ THEN(SUBLIST)\n\nOr you can immediately issue a PDS subcommand to operate on all the\nmembers in your current subgroup now, such as:\n\nCOPY * second.pds  REPLACE\n\nwhich will set up an IEBCOPY job in the foreground, to just copy those\nselected members to the second pds.\n\n\nWHAT ABOUT FOR THE OLD PDS USERS?\n\n      So I hope I've whetted the appetite of those \"new people\", who\nhaven't used the powerful PDS command package before.  But for those\nthousands of \"old people\" who have used PDS for years, to their immense\nprofit, there is still something to add.  One of those things is PDS's\nimmense capabilities for manipulating, re-linkediting, and changing the\nattributes of load modules.  Using PDS subcommands, you can possibly\nchange the attributes or replace an equal-sized string in hundreds of\nload modules at one time.  So it pays, even for the old veterans, to\nstudy the PDSHELP member, the undocumented features (the $$$UNDOC\nmember) and my course (members $PDSART0 thru $$PDSART3) in CBT Tape File\n182.\n\n      In addition, John Kalinich is constantly adding enhancements,\nincluding some PDSE support, so it pays to keep up.\n\n      I trust that this month's topic will be of much help.  Best of\nluck to all of you, and I hope to see you again next month.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   General Overview of PDS Command Options\n\n\n\n-------------------------- PDS O Subcommand Selection -------------------------\nOPTION  ===>\n\nMember subcommands (or enter P for member group prompting):\n    A     - Attrib      DEL   - Delete     L     - List       REPRO - Repro\n    AL    - Alias       DSP   - Dsprint    M     - Map        RES   - Restore\n    B     - Browse      E     - Edit       MEML  - Memlist    REV   - Review\n    COM   - Compare     F     - Find       OUT   - Outcopy    SUB   - Submit\n    COP   - Copy        FSE   - Fse        PR    - Printoff   SUBL  - Sublist\n    DIR   - Direntry    HI    - History    REN   - Rename     V     - View\n    DCF   - Dcf Script  IF    - If         REP   - Replace    VE    - Verify\n                                                              VPS   - Vpsprint\nData set subcommands:\n    C     - Change      D     - Display    FIX   - Fixpds     PA    - Pattern\n    COMPR - Compress    DSN   - Dsname     MEM   - Members    U     - Usage\n\nMiscellaneous subcommands:\n    CON   - Control     H     - Help       ISPM  - Ispmode    T     - TSO\n    END   - End         ISPF  - Ispf       R     - Recall     UT    - Utility\n\nEnter O for subcommand selection menu (DIALOG and PDS commands)\n\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.   Overview of some Specific command categories for PDS 8.5\n\n\n\n---------------------- PDS O Subcommand Selection ---------------------\nOPTION  ===>\n\n\nChoose one of the following:\n\n      DIALOG commands (ISPF mode operation)\n    1  - Function selection list\n    2  - Display or Table processing options (SORT, F, X)\n    3  - Features and Short Hand commands\n    4  - Set default selection list\n    5  - Extended/User/Installation processing selection list\n\n      PDS commands\n    6  - Whole dataset related commands\n    7  - Miscellaneous commands\n    8  - Member related commands\n    9  - Member group prompting panel\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0310OC": {"ttr": 25610, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x06\\x01\\x03%/\\x01\\x03%/\\t1\\x00\\xf3\\x00\\xf3\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-09-09T00:00:00", "modifydate": "2003-09-09T09:31:06", "lines": 243, "newlines": 243, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          OCTOBER 2003\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.  The Online CBT Tape web site can be reached\nat www.cbttape.org .\n\n\nA PHILOSOPHY OF MVS UTILITY DESIGN - POWER VS SAFETY\n\n      To tell you the truth, I don't like the word \"philosophy\".  To\nme, the word conjures up images of non-practicality, of \"thinking in\nthe air\".  But the word also has another connotation, which boils down\nto the idea of approaching a subject from many directions, and coming\nto a consensus about what your general view is about that subject.  It\nis this usage of the word that I like.  And for the purposes of today's\nsubject, I don't think there's a better word that describes what we're\ngoing to talk about.\n\n      All of us, as MVS systems programmers, use program utilities.\nWe can't manipulate objects in the MVS operating system without the\ntools that do the manipulations.  It is patently obvious that computers\nare not the type of machinery that one can stick one's hand into, and\nturn a bolt with a wrench.  Our \"wrenches\" are the utility programs.\nWithout them, we would get nowhere.\n\n      So all of us start manipulating MVS with the basic utility\nprograms that IBM supplies to us.  But the peculiar nature of MVS is\nthat IBM will not, and cannot, complete the \"utility creation job\".  IBM\nsupplies you with many basic tools, and with the building blocks to add\nyour own tools.  Vendors spend their full time trying to fill the gap\nleft by IBM, by creating utilities to sell us, but our own fellow\nsystems programmers have also done their share in \"filling the tool\ncreation gap\" themselves.  Large collections of free tools, such as the\nCBT Utilities Tape collection, or the tools contributed to Xephon over\nthe years, have contributed to our \"good standard of living\" when doing\nour jobs.  Such extra \"wrenches\" and special-purpose utilities make it\npossible for most of us to bypass the built-in difficulties of living in\na \"pure-IBM\" environment.  In some areas of the MVS life, trying to make\ndo with only IBM-written utilities, is like trying to wash clothes\nwithout a washing machine.  You can do it, but it's tough.\n\n\nDESIGNING BETTER TOOLS\n\n      Let me start telling you what I'm talking about.  Take a look\nat IBM's AMASPZAP program, which allows you to change just about any\nbyte on a disk pack.  In my opinion, despite it's enormous generality,\nAMASPZAP is an extremely difficult tool to use for any job greater than\nzapping a few bytes somewhere.  Also, if you zap the wrong byte,\nAMASPZAP might potentially cause enormous problems in your MVS system.\nThere's not much of a built-in safeguard in AMASPZAP to tell you that\nyou could be making a mistake and changing the wrong bytes.\n\n      So we have already touched on two factors in utility design:\ncapability--power, versus foolproofing--safeguarding against mistakes.\nOf course, the ideal utility should have unlimited power, and it should\nnever let you make a mistake.  In former times, I would have said that\nanyone who could design such a utility would make millions of dollars,\nbut in today's economic climate, I'm not sure I'd say that.\n\n      All kidding aside, I'd like to get down to business and show you\nhow some users (your fellow sysprogs) have written more practical\nand helpful utilities than AMASPZAP.\n\n      AMASPZAP is most frequently used for changing a few bytes in load\nmodules, in zapping VTOC entries (DSCBs), and sometimes AMASPZAP is\nactually used to change arbitrary data bytes.  Users have written far\nbetter tools to do these tasks, with far less risk of making mistakes.\nFor example, the quintessential tool for zapping load modules and data\nbytes is the TSO-based Fullscreen ZAP program, which can be found on\nFile 134 of the CBT MVS Utilities Tape collection (the load module is on\nFile 135).  Using Fullscreen ZAP, especially in authorized mode with the\nFULLVOL option that was implemented by Greg Price, you can also change\nany byte on a disk pack, but with the following helpful additions:\n\n      First, you get to see what you're doing.  Fullscreen ZAP, as a TSO\ncommand, displays up to 300 bytes on your screen, in hex and in EBCDIC,\nwith the additional ability to disassemble the current assembler\ninstruction when that's the data being pointed to.  This helps you see\nwhat you're doing, and it makes the process of changing data far less\nprone to error.  On the other hand, IBM's AMASPZAP will not let you look\nat what you're changing unless you know (in advance) exactly where you\nwant to look.  You cannot easily use AMASPZAP to fish for, and find, the\ndata that you want to change.  Additionally, Fullscreen ZAP contains a\nFIND command, that allows you to look forward in the data and find any\nstring that is the likely candidate for a zap.  AMASPZAP doesn't have a\nFIND capability, to my knowledge.  Third, Fullscreen ZAP always displays\nthe actual physical format of the data block currently being looked at.\nYou can see that at the bottom of your screen.  So you have an\nadditional safeguard to know (or guess better) that you're changing the\ndata in the right place.\n\n      The next job that AMASPZAP is used for, is to change dataset\ncharacteristics by zapping (changing) bytes in the VTOC (Volume Table\nOf Contents) entry that describes the dataset on the disk pack.  When\nyou zap a VTOC entry with AMASPZAP, it's really easy to zap the wrong\nbyte.  Even using Fullscreen ZAP, where you see what you're doing and\nit's harder to make a mistake, you can still do unnecessary damage.  But\nusing another specialized tool called CDSCB (Change the DSCB), which is\na TSO-based tool that can be found on File 300 or File 301 of the CBT\nTape collection, making a mistake in zapping a VTOC entry for a dataset\nbecomes much harder.\n\n      That's because CDSCB has intuitively obvious parameters, such as\nCDSCB your.dataset BLKSIZE(32720) LRECL(80) RECFM(FB), and what isn't\nobvious can be explained by looking at the CDSCB HELP member (which of\ncourse, you have to install yourself by copying it from File 300 to your\nSYSHELP dataset).  You can use the CDSCB program to change almost any\ndataset characteristic that's described by a Format 1 DSCB (VTOC entry).\nAnd it'll be foolproof, unless you make a mistake typing in the\nparameters.\n\n      An additional advantage of using CDSCB is that you can change\nhundreds of datasets at a time with it, by executing CDSCB under TSO\nin Batch.  Just make sure you have the RACF permissions (if you use\nMike Cleary's version from File 301) or that you execute CDSCB as an\nauthorized TSO command from an authorized load library.  (See Files\n185 and 186 of the CBT Tape collection for additional help with that.)\nNow I'll show you when this technique comes in handy.\n\n      Everyone knows that IBM's allocations, especially the secondary\nallocations for SMP/E-controlled datasets, leave much to be desired.\nThey are usually way too small.  And this results in the failure of mass\nAPPLY jobs, and especially mass ACCEPT jobs.  You can safeguard against\nmany such failures before attempting a mass ACCEPT job.  Just make a\nlist of all your DLIB datasets, and run a TSO-in-batch job to execute\nCDSCB against all of them that have small secondary allocations.  For\nexample, you'd list all your DLIB datasets and execute:  CDSCB\nyour.dataset SPACE(30) ALLOC(TR)  against each of them.  This operation\nwould make the secondary space allocation for each dataset, 30 tracks.\nIf some of the DLIB datasets are larger and need bigger secondary\nallocations, you can specify those allocations differently for those\ndatasets, in your batch job.  Then, in one fell swoop, all the DLIB\ndatasets can be given adequate secondary allocations, and the mass\nACCEPT job won't fill them up.  Just try and think about how long that\nsame operation would take using AMASPZAP.  It would be supremely\nimpractical.\n\n      So you see that the raw power of AMASPZAP isn't the be-all and\nend-all.  To do practical jobs, you need better tools that are easier to\nuse and less error-prone.  In other words, you also want a tool that\nwill help guide you to do the correct thing, while you are using it.\n\n      As an aside, I'd recommend using the free PDS 8.5 utility program\nfrom File 182 of the CBT Tape, to add more directory blocks to all your\nDLIB datasets, as well.   Just run a TSO-in-Batch job executing the PDS\nutility (which doesn't have to be authorized) as follows:   PDS\nyour.dataset FIXPDS EXPANDDIR(20)   and do that for all the DLIB\ndatasets that you have, before you run the mass ACCEPT job.  This\noperation adds 20 more directory blocks to each DLIB dataset.  Then,\nit'll be far less likely that the pds directories for all your DLIBs\nwill fill up.\n\n\nDESIGNING \"FOOLPROOF\" VERSUS \"POWER\"\n\n      I recently had to make a \"design decision\" when I improved an\nexisting tape copying tool called COPYFILE.  COPYFILE can be found on\nFiles 229 and 316 of the CBT Tape collection.  I'll show you why my\nimprovement uncovered a potential problem, and how I needed to make a\nnon-trivial design decision to get around it.\n\n      The COPYFILE program can copy selected files from one Standard\nLabeled tape to another.  For example, you can copy files 7, 8, and 22\nfrom volume TAPE01 to files 5, 6, and 7 of volume TAPE02 using the\nCOPYFILE batch program.  The COPYFILE control cards to accomplish this\nare the following:   7/5  8  22   This means that you copy file 7 from\nthe input tape to file 5 of the output tape, and then file 8 from the\ninput tape to the next output file, and finally file 22 to the next\noutput file.  But before I made my improvement, you couldn't go\nbackwards.  In other words, you couldn't code:  7/5  2  22\nwhich would copy file 7 to file 5 as before, and then copy file 2 to\nfile 6 of the output tape.  The original coding of the COPYFILE program\nwould only allow you to go forward on a tape, not backward.\n\n      I introduced an improvement to COPYFILE, to be able to go\nbackward, for either the input tape, or the output tape.  It was easy\nto code the change, which was the same for either the input tape or\nthe output tape.  But the \"change in design architecture\" introduced\nby the ability to go backward, introduced a potential safely problem\nthat had to be accounted for.\n\n      Going backward made it possible, potentially, to write over the\nsame file number on the output tape twice.  In other words, if I coded:\n7/5  8  22  4/7   I would first be writing file 7 on the output tape\nusing file 22 from the input tape, but then afterward, I would write\nover file 7 a second time, using file 4 of the input tape.  The\nresulting output tape would have file 7 written from input tape file 4,\nnot from input tape file 22.  Is this a mistake?  In most practical\nsituations, it usually would be.  But my \"architecture\" or my \"coding\ndesign\" allows this situation to be permissible.  So what should I do,\nto safeguard against an unintentional mistaken result, or a mususe?\n\n      I had a heated discussion about it with several of my friends.\nFirst, I had to make a decision whom the utility was for.  If it would\nbe used by systems programmers, I could be more lenient with the power\nand less stringent with the safeguards.  If it would be used by other\ntypes of users, I'd have to clamp down hard with the safeguards.\n\n      My interim solution was to put out a loud warning message to the\nSYSPRINT file for the utility, if the double overwrite of an output file\nwas about to occur.  Then I would let it happen, but I would flag it\nwith a return code of 4 instead of 0.  This is obviously being very\nlenient with the safeguards.  I figured that the system programmer would\nsee the situation, decide if there was an error, and either let it go,\nbecause that was the desired result, or run the job over with corrected\ncontrol cards.\n\n      If the utility were to be designed for applications types, I'd\ndefinitely not let the second overwrite happen.  I'd make the return\ncode 8 or 12, and stop the tape copy then and there, making a clear\nannouncement about what the \"error\" was.  That's a decision about\n\"power\" versus \"safeguards\".  The utility writer tries his best.  But\nan ultimate decision probably has to come from the user feedback.\n\n\nSUMMARY\n\n      Today I've written about \"power\" versus \"safety\" in utility\ndesign, because that's not a frequently discussed topic among system\nprogrammer types, but the issue definitely affects our jobs.  I want to\nraise our awareness concerning this topic.  Since sysprogs usually\naren't in the business of writing utilities, but rather they are users,\nit is easy for vendors to brush the issue off, and say that this issue\nis not the sysprogs' business.  But sysprogs are not ordinary \"users\",\nthey are \"powerful users\".  The system programmer is the \"system doctor\"\nwho potentially has the power to change anything, in order to make the\nsystem run better.  And he or she is supposed to have the knowledge that\ngoes along with the responsibility.  So sometimes, a systems programmer\nhas to have a more powerful tool to do a job, rather than a safer one.\nAnd the systems programmer should have a say.  That's my opinion.\n\n      Best of luck to all of you.  I hope to see you here again next\nmonth.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0311NV": {"ttr": 25860, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00I\\x01\\x03&\\x0f\\x01\\x03&o\\x10G\\x00\\xde\\x00\\xde\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-09-17T00:00:00", "modifydate": "2003-09-23T10:47:49", "lines": 222, "newlines": 222, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         NOVEMBER 2003\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.  The Online CBT Tape web site can be reached\nat www.cbttape.org .\n\n\nMAKING LIFE COMPLICATED\n\n      One of the typical emotions that I feel in the MVS sysprogging\nbusiness is:  \"Aw nuts.  I have to learn a whole bunch of these new\nthings.\"  It's true.  Every new component or utility that I have to\nlearn to control, comes with its \"instruction book\" or as we say,\n\"documentation.\"  Each new piece of software has a vocabulary associated\nwith it.  There are keywords to learn.  A certain keyword controls each\npiece of functionality.  Sometimes these keywords are intuitively\nobvious, and the product is easy to master.  Other times, they are\nhorrendously new, as in the case of SMP/E, which contains controlling\nkeywords that seem unrelated to anything that you already know, unless\nyou're a real old-timer who remembers how to perform an MVS SYSGEN\nand apply PTFs the old way.\n\n      Now let's put the shoe on the other foot.  Imagine yourself as\nthe software writer.  You've written a piece of software to do a certain\njob, and you've written it to specifications.  The software has to be\nusable, so you have to put someone in the driver's seat, who's going to\nuse it.  You have to give him or her the controls.  What will they be?\nYou have to decide that.  In some cases, you have to invent them from\nscratch.  As a software writer, I have had to do that.\n\n      So therein lies the source of the \"complication\".  The software\nwriters have to create the controls to manage their software products'\noperations.  And the users (in this case, US) have to learn to manage\nthe beast, using whatever control mechanisms that the software writers\n(or their managers) have decided to invent.\n\n      And usually you can't change things to your liking.  All of the\nkeywords and their meanings are hard-coded into the programs.  You just\nhave to accept them and use them as-is, or you don't get to manage that\nsoftware product.  So in summary, our life consists of learning how to\nuse a lot of mechanisms and keywords that other people have invented.\nThis makes our lives complicated.\n\n\nAN EXAMPLE FROM THE WRITER'S POINT OF VIEW\n\n      I count myself fortunate to be on both sides of the fence.  I am\na software writer as well as an MVS sysprog.  I have had to \"create the\nbeast\" as well as having had to learn about beasts which others have\ncreated.\n\n      Let me show you some keywords which I have had to invent, and the\ndecision process which went into creating them.  I have had to make the\nnew words as intuitively understandable as I could.  But on the other\nhand, I couldn't make them exactly the same as the words which were in\nother products.  Perhaps I could have done a better job creating these\nwords, and my software product would be easier to learn.  I don't know,\nbut I tried my best.  It's really up to the users to make that judgment.\n\n      Although I have written other things, I'm choosing the COPYMODS\ntape copying program (from File 229 of the CBT Tape collection) to write\nabout.  The reason for choosing COPYMODS (besides beating a dead\nhorse--I've written about that program a lot in this column) is because\nI invented new functionality there, plus the ability to run the program\nin at least 30 different ways.  This versatility necessitated the\ninvention of new controls.  And new controls meant more new keywords for\nyou to have to learn.  Sorry, guys!\n\n      Anyway, look at the situation from my point of view.  I'm trying\nto do anything you'd ever want to do while you're copying a tape.  And\nI'm basking in the euphoria of BLP processing, where tape labels mean\nnothing special, and they're \"just files\" like any other tape files.  I\nasked myself a question (ridiculous to most people--but from my angle\nit made perfect sense--this is the design phase, where the imagination\ncan run rampant).  The question was:  \"Could I copy a tape, but only\ncopy the labels and not the data?\"  Of course I could.  BLP processing\nin MVS ignores the labels as being anything special.  If my program\ncould recognize a file as being part of a tape label set, as opposed to\nbeing other data, it could easily be made to copy only the labels.\n\n      Then the realists pipe in, and ask:  \"What kind of a tape would\nthat give you?  It'd be one with all labels, and no data.\"  Maybe it'd\nbe like a tape filled with null standard-labeled files, but the block\ncounts would be wrong in the EOF1 labels, and the tape mark pattern\nwould be wrong.  MVS wouldn't be able to read it as a normal tape.  So\nas the designer I ask myself another question:  \"As far-fetched as this\nscenario sounds, does it have a real and practical use?\"\n\n      I actually got a positive answer to this question, and it led to\nthe invention of some really useful functionality in the COPYMODS\nproduct.  The answer was:  \"Don't write the labels to an output tape,\nbut rather write them to an external FB-80 disk file.\"  That would\naccomplish two things.  First, it would enable you to see all the tape's\nlabels more easily.  Second, if you'd somehow be able to strip the\nlabels from the original tape in a copy operation, so you'd create a\nnon-labeled tape out of the original, but you still had possesion of the\nphysical labels separately, maybe you could splice them back after\nediting them, and create a new standard labeled tape.  This operation\nwould have a lot of potential practical use, such as being able to\nrename the tape datasets in a copied tape.\n\n      I actually did it and got it to work.  But I had to invent the\ncontrolling keywords.  What should I call a \"label dumping\" operation\nwhen copying or reading a tape?  I decided to invent the keyword\nLABLDUMP.  It describes the situation, and it intuitively makes sense.\nBut it's different from anything that's in any other product, and it\ngives you something else that you have to learn.  In the COPYMODS\nprogram, LABLDUMP is not only a PARM or SYSIN keyword.  It actually has\nto be a DD name also, to describe the FB-80 format file which will\nreceive the label images that were read from the tape.\n\n      Do you like my choice of the LABLDUMP keyword to control this\noperation?  I could take a poll and ask your opinion.  But the truth is\nthat I have already written the product and decided on the keyword.\nPeople already have \"production JCL\" that uses this keyword.  It can't\nbe changed.  Tough noogies.  You have no choice!  Sorry.\n\n      Actually, in COPYMODS, I can add a synonym, or another keyword\nthat means the same thing as LABLDUMP.  But that would give you two\nmore things to learn instead of one.  Life is still complicated.\n\n      What about the opposite operation of taking the external images of\nthe labels and splicing them back into a non-labeled (NL) version of the\nsame tape?  I had to decide on a different keyword to describe that.  I\ncalled it LABADDIN.  This keyword is not only a PARM or SYSIN keyword in\nthe COPYMODS program.  It is also the extra DD name where you have to\nput the set of labels that you want to splice into your non-labeled\ntape.\n\n      So if you want to use my product in this way, you have to learn\ntwo new words:  LABLDUMP and LABADDIN.  If you don't (or won't) learn\nto use them, you'll be deprived of using the label dumping and label\nadding functionality in the COPYMODS program.  Can you get around that?\nMaybe there's some other program which does the same operation.  But if\nit exists, and you can get (or buy) it, that program would also have its\nown special keywords that you'd have to learn.  You can't get around the\nbasic problem.  You simply have to learn new keywords, and that's that.\n\n\nWHAT'S BEHIND OTHER FUNCTIONALITY?\n\n\n      I was just looking at IBM's \"Using Magnetic Tapes\" manual on page\n6.  There, the manual describes the definition of attributes in a new\ndataset to be LIKE an old dataset, using the intuitively obvious LIKE\nkeyword to point to a model DSCB. (A model DSCB is a VTOC entry that\ndoesn't point to a real dataset but just contains dataset attributes.)\nWhat struck me was that the LIKE keyword doesn't copy ALL the attributes\nin the model DSCB but only some of them.  The manual describes which\nattributes are copied and which are not.  But the bottom line is that\nLIKE definitely does not mean \"exactly like\".\n\n      There's more to this than meets the eye.  What you see in the\nmanual, reveals what was programmed into the product by the programmer.\nAnd if you read the manual carefully, you can figure out why it was\ndone that way.  What is not so up-front, is HOW it was done.  But once\nyou get that, you will definitely have a completely revised insight into\nthe way MVS is constructed.\n\n      A model DSCB is simply a VTOC entry, a FORMAT 1 VTOC entry to be\nexact.  Fields in the VTOC entry describe the RECFM (record format) of\nthe dataset, the LRECL (maximum record length) of the dataset, BLKSIZE\n(maximum block size), and so forth.  It used to be that when you would\nrefer to a model DSCB to describe dataset attributes, the older MVS\nsystems would use more of them than nowadays.  For example, if the model\nDSCB contained a specific block size, then that block size would have\nbeen copied to the dataset currently being OPENed, if it were not\noverridden via JCL, or overridden by having been filled in previously.\nBut nowadays, with MVS functionality attempting to optimize disk\nutilization automatically, the manual says that the block size attribute\nis not copied from the model DSCB using the LIKE keyword.  Neither is\nthe expiration date copied, in most cases.  So again, LIKE isn't really\n\"exactly like\".\n\n      Programming-wise, what is happening is that the system program\npoints to the location of the model DSCB on disk, and pulls the contents\nof the various fields out, probably using MVC (move character)\ninstructions, moving them to fields in the DCB, and possibly the JFCB\ncontrol blocks.  When LIKE is invoked by the person running the JCL for\nthe job, MVC (or similarly effective) instructions are invoked for only\nthose fields of the model VTOC entry which are appropriate to the\nsituation, and are not invoked to copy the other fields in the model\nDSCB.  So when you code LIKE in some JCL, you are not specifying that\nevery field in the VTOC entry will be used--only some of them.\n\n      What you see here may be described as a kind of synergy between\nthe programming specifications, what is in the manual, and the\ninstructions that were actually coded in the system programs.  Which\ncame first?  Usually the specifications and requirements came first.\nThen the program(s) were coded appropriately.  And finally the manual\ndescribing how to use the program(s) was written or updated accordingly.\nBut my point is that from our point of view, we usually see the manual\nfirst.  Then we figure out what the programming specs probably were,\nand finally we get an insight into how the program was probably coded.\nThe programmers do it one way, and we, the users, have to figure it out\nin the opposite order.\n\n      So finally, I've made my point for the day.  I feel that it is up\nto us, as MVS systems programmers, who are really \"educated users\" of\nsystem programs, to get a feel for how it is on the other end.  What do\nthe programmers of the utilities we use, have to go through?  Then,\nwhen we've started to see our world through the programmers' eyes, we'll\nget to be more patient, and more tolerant of the learning process that\nwe have to go through almost every day, mastering the use of so many\nkeywords, instructions, and directions.\n\n      I hope that in today's article, I've made it easier (mentally) to\napproach our daily duties.  Much of what we do, is learning how to use\nnew tools, or learning new features of old tools.  So by placing\nourselves in the programmer's mind and thinking about it, we'll see that\nwe are really the ones who \"got away easy\".\n\n      Best of luck to all of you.  I'll see you here again next month.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0312DE": {"ttr": 25865, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00D\\x01\\x032_\\x01\\x032_\\x10B\\x00\\xc3\\x00\\xc3\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-11-21T00:00:00", "modifydate": "2003-11-21T10:42:44", "lines": 195, "newlines": 195, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         DECEMBER 2003\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.  The Online CBT Tape web site can be reached\nat www.cbttape.org .\n\n\nEVERYBODY'S DIFFERENT\n\n      Once upon a time, in the long distant pre-Internet past, I had a\nvery long daily commute to work--about 70 miles or more each way.  I did\nit for almost seven years.  My boss and I had an informal arrangement,\nthat I could come in late and work late, to avoid the rush hour and not\nmake a bad situation worse.  The place was also trying to stay on the\nlowest budget possible, because of frequent high-level outsourcing\nattempts on our data center.  Because of the company's needs, my boss\nalso allowed me to visit friends in other data centers that were on my\nway to work, to negotiate with them for free software tools that they\nmight have.  Of course I had to carry tapes then, and go by car.\nElectronic networking was nonexistent between different companies in\nthose years.\n\n      Since I would visit many different people, I would have a chance\nto sit behind them and watch them work for a while.  I noticed one\ncommon denominator.  Although MVS everywhere is approximately the same\noperating system, there were always some things that the other person\ncould do better than I could.  And there would be other things that I\ncould do better than he could.  I would try to learn from the things\nthat the other person could do better.  And I would also try to teach\nthe other person some of my own stronger points, in the limited time\nthat I had there.  It always seemed to me, that the differences were\nthe commonality.  The one constant condition between all the people, was\nthat everybody was different.\n\n      My point today is to show why this is good, and to teach us how to\ntake advantage of a good thing.\n\n\nWORKING PATTERNS\n\n      When somebody is new at a job, he or she wants to succeed, and is\nnervous to make sure the job will be done right.  Not sure in the\nposition, the person is anxious to learn everything possible.  Advice\nfrom more experienced people is eagerly accepted and absorbed.\n\n      As the person becomes more comfortable in the job, the patterns\nbecome more stable as he or she settles into the routine.  More of the\nsame things are done over and over.  Advice from others is not as easily\ntaken or absorbed.  Together with the establishment of working patterns,\nthere also tends to grow an attitude of:  \"I know how to do this.  You\ndon't have to tell me.\"  It's a rare person who is smart enough to keep\nan open mind once he is already settled.  But smart people tend to learn\nby experience.  And even though they know how to do their job, they also\nknow that it's a good practice to keep your mind open to new\npossibilities and creativity.\n\n      I've noticed that when it comes to using MVS tools, people's\npatterns tend to be very similar to that.  In order to do a certain job,\nyou may have to learn to use a certain tool.  Once you know how, there's\na tendency not to want to use another tool that does nearly the same\nthing, even though the second tool does it better.  Again, a smart\nperson will still keep his or her mind open, ready to learn more.  The\nsecond tool can get the job done twice (or fifty times) as fast.  The\nsmart person will change.  The others will not.\n\n      Of course, if you're very frustrated with the first tool, and you\nsee a second tool that is easier to use while doing more, then there's\na motivation to change.  You've come to appreciate what that second tool\ncan do, through your frustration with using the first tool.  And then\nyou switch.  That's why I nearly always use TSO Fullscreen ZAP from File\n134 of the CBT Tape collection, rather than AMASPZAP from IBM.\n\n      So the truth is that most of the time, once they're established in\ntheir patterns, people need to be kicked in the tail in order to change.\nMany people will wait for their bosses to do the kicking.  But smart\npeople will kick themselves in the tail, because they have a\nself-motivation to always improve and learn more.\n\n      I've noticed that many MVS systems programmers are smart in this\nway.  MVS systems programmers tend to be a clever sort, because in order\nto do this job, you have to constantly exercise creativity in some form\nor other, nearly every working day.  So I've seen a tad more willingness\nto change among systems programmers, than among most other people.\n\n\nDIFFERENT CIRCUMSTANCES\n\n      In little shops, the systems programmer tends to be a jack of all\ntrades, and a master of many (if he's been there for a long time).  In\nlarge shops, the labor is divided, and even very experienced systems\nprogrammers who work there, tend to be more restricted in the scope of\ntheir duties.  But in a big place, there are a lot of other experienced\npeople to talk to.  This pretty much sums up the circumstances.\nMid-size places are half-way in between.\n\n      Even though MVS is nearly the same everywhere, the tasks that we\ndo are often reflected by the equipment that the shop has.  For example,\nif the place has STK tape silos or other automated tape libraries, then\nat least some of the people are in charge of making sure they work\nright.  The same goes for any other equipment which affects the\ncomputing.  And the equipment dictates the specialized tasks that one\nperson has to master, while others have to master other things.  As a\nresult, it comes out that even two MVS sysprogs in the same place will\nget widely different experience.  And the experience of two sysprogs in\ndifferent places will most likely be even more different than that.\n\n      So in facing their circumstances, our clever and creative MVS\nsysprogs often have to adjust.  Different circumstances push people's\ncreative juices in different directions, to develop their own\ntechinques.  Not only that, but some of them actually write their own\nprogram tools so they can do their specialized jobs better.  It's\nusually nice not to have to re-invent the wheel.  So if you can use a\nfree tool that someone else created, that's a big plus.\n\n      Where can you get \"other people's free tools?\"  For one place, you\ncan go to the large CBT Tape collection of free tools and utilities,\nwhich dates back to 1975 and which is now accessible through the web.\nAnother place is the big Xephon collection of tools that are more than\ntwo years old, are which available for free.  (Many people don't know\nthat.)  Xephon's tool collection can be found on the web at\nwww.xephon.com .  I've downloaded some of these free tools from Xephon\nand found them very useful.\n\n      If you think about it, you'll realize that such a divergent\ncollection of utility programs could only have arisen from people having\nto do widely different tasks, even in the same MVS shop, and certainly\nwhen they worked in different shops.  Setting up MVS isn't like setting\nup a punch machine.  If you work the punch machine in one place, you can\nprobably work a similar machine anywhere, with little extra training.\nBut MVS is so large, and it has such flexibility, and it can be\nconnected to so many different types of equipment, that servicing all\nthese different phases of MVS really presents a different picture.\nThere's simply too much learning that has to be done, and too little\ntime.  So you have to rely on other people's work, and you are forced to\nkeep your own mind open.\n\n\nGETTING PRACTICAL\n\n      Andrew Armstrong is a systems programmer, but he does things that\nI never have.  Andrew has (thus far) contributed four separate packages\nthat he wrote, to the CBT Tape collection of free MVS software.  Two of\nthe packages deal with TCP/IP or networking.  (These are CBT Tape Files\n628 and 629.)  One of them is an add-on to Levi Ray and Shoup's VPS\nprinting package so you can \"produce spectacular full-color separator\npages\" and do several other extra things with VPS.  (This is on CBT Tape\nFile 640.)  And the fourth is an XML parser written in REXX (on File\n647).  I'll now ask you to please ask yourself this question:  \"Does my\nMVS experience closely match Andrew's?\"  I'd bet that in more than 98\nout of 100 cases, the answer is \"no\".\n\n      But I'll ask you another question.  \"Do you think that there are\nmore than 100 people out in the world who can benefit directly from\nAndrew's work?\"  And the truth be known, I'm sure that the answer would\nbe a resounding \"yes\".\n\n      So you can see it's good that everybody's different.\n\n      I'll bring this thought home a bit better.  Let's say that there\nwere fifty different people, somewhere in the world, who are doing\nalmost the same job that Andrew Armstrong does.  My question now is:\n\"Will the result of all these people having nearly the same experience\nas Andrew, be the same?\"  Again, the answer is a clear \"no\", and for\nseveral obvious reasons.\n\n      First, Andrew used his experience to write new tools that help him\ndo his job.  Not everybody (even doing the same job) has the same\nprogram writing skills that Andrew has.  And even if they had similar\nprogramming skills to Andrew, the programming design and their attention\nto detail would be different.  So the results, even if they wrote their\nown programs, would never be the same.\n\n      And there's another factor, even more important.  It's obvious to\nme that Andrew Armstrong is a public-minded person.  Out of a random\nfifty people that you know, how many of them are public-minded enough to\nshare their own work, so that other people can benefit from it?  Only\nyou alone can answer that one.  If the number is more than ten, you've\ngot some mighty good friends!\n\n      So you see very clearly that it's a wonderful thing in this world\nthat everybody's different.  Don't we all benefit?  Isn't it NICE, that\nnot everybody else thinks like we do?\n\n      Have a good month and a happy year.  Please come and visit\nagain in the next issue.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0401JA": {"ttr": 25869, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00G\\x01\\x033\\x7f\\x01\\x033\\x7f\\x18(\\x01\\x06\\x01\\x06\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-12-03T00:00:00", "modifydate": "2003-12-03T18:28:47", "lines": 262, "newlines": 262, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         JANUARY 2004\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.  The Online CBT Tape web site can be reached\nat www.cbttape.org .\n\n\nPLAYING\n\n      I recently saw a job posting for an S/390 system administrator.\nThe job description called for extensive experience in supervising and\nhands-on, covering almost all the areas of modern MVS work.  I would\nhave figured that the requirement would be for a 15 to 20-year person.\nInstead, at the top of the page, the posting said:  \"Candidates should\nhave 3-7 years of IT experience, and should have at least 3 years of\nMainframe Server Administration experience.\"  This was an enormous\nshock to me--it most certainly did not sound realistic to get such a\nperson with so few years, who would know so much.\n\n      Perhaps they expected a genius--a wunderkind!  I suspect that the\nposting was from a country that is halfway around the world from me, and\nI do know there are some pretty smart people there, but that requirement\nstill is an awful lot to expect of even a smart human being.  But they\nmight be able to get away with it.  Let me share my views with you.\n\n\nWHAT IS \"EXPERIENCE\"?\n\n      As one of my bosses once put it, MVS \"experience\" is partially the\nfollowing:  \"One needs to get a big general picture of all the\ncomponents of the MVS operating system, and about how they fit together\nand work together.\"  That's an \"essential\", but that's by no means all\nof it.  It usually takes at least a couple of years to get this far.  Of\ncourse, some coaching by a knowledgeable MVS \"old hand\" will help\nshorten this process.  But there are a few more things.\n\n      On my first day as an MVS systems programmer, I was told:  \"If\nthere's a problem, always read the messages first, and look them up.\"\nAlso, that's only part of it.  Eventually, you get to hook up the\nmessage types (in your mind) with the MVS components that they belong\nto, and you can begin to zero in on the problems instinctively, through\nfollowing that path.\n\n      Next, there's detailed knowledge of the MVS components themselves,\nand about how each of them works.  You get this knowledge by your work\nexperience.  The tasks each of us has to do, determines which areas of\nthe MVS system will be covered more strongly.  For example, if you have\nto code certain MVS exits, you'll acquire some knowledge about the\nsystem components that those exits add code to.  In this category also,\nare the ISV (Independent Software Vendor) components that your system\nhas.  If you administer some of them, you'll acquire knowledge about the\nsystem areas which those products touch.  Then, you always have to know\nabout PARMLIB member setups, for both MVS itself and for the vendor\nproducts also.\n\n      Besides all these things, there's SMP/E.  Quite a few MVS sysprogs\nknow the other categories pretty well.  But when it comes to putting\nmodifications by means of PTFs onto the system, they can run the jobs,\nbut they don't really know what the jobs do.  An essential piece of MVS\nexperience consists of getting a feel for how SMP/E will insert a\ncomponent into an existing system, and why SMP/E will put this piece\nhere, that piece there, and get everything to run properly.  To get\nSMP/E right, it either takes some good coaching from an expert, or\nseveral years of playing.\n\n      I didn't get good coaching in the area of SMP/E.  After four years\nof playing, I learned it well enough so I didn't want the next guy to\nhave to go through the same thing.  So I wrote a series of 3 articles\n(in 1988) about the concepts behind SMP/E, which were published in\n\"Techinical Support\" magazine.  These articles can also be found on File\n014 of the CBT Tape collection of MVS goodies.  My articles get to the\nessence--they tell you what SMP/E is all about.  But unfortunately,\nthere are 100 other areas of MVS to learn about, as well.  For all of\nthose, you either need to hit the books (i.e. the IBM manuals), or you\nneed \"playing time\" with each of them.\n\n\nWHAT IS \"PLAYING\"?\n\n      To my mind, \"playing\" means trying various commands, programs, or\nother things on a system, to see what works, how it works, when it\nworks, and when it doesn't work.  The first thing that comes to mind\nabout playing, is that it has to be done responsibly.  Our obligation,\nwhen we work as systems programmers at an installation, is to make sure\nthat the machine stays up and functioning properly, as long as our\nmanagement and the programmers want it to.  Our \"playing\", especially as\nsystems programmers with \"authority\", must never damage the system or\nhinder system operation.  So bearing in mind that we must never make a\nblunder while \"playing\", it is still my contention that a systems\nprogrammer must spend a good deal of time doing it.\n\n      It helps to have a test MVS system, nowadays nicknamed a \"sandbox\nsystem\", to play on, so that the production system is not put at any\nexcessive risk by your learning attempts.  If you really really have to\ntest something in a production environment (most of the time you never\nneed to), I'd recommend trying to go to a disaster recovery test.   You\ncan try some stuff toward the end of a disaster recovery test, because\neven though that system is simulating a production environment, you also\nknow that it will have disappeared tomorrow.  I've learned a lot of good\nthings by getting myself invited to disaster recovery tests.\n\n      Just to illustrate the difference between a systems programmer and\na computer operator in this regard, I remember a certain computer\noperator who was \"too smart for the position\", but the company wouldn't\npromote him.  So he looked in the MVS System Commands book to see what\nhe could learn.  Every once in a while, we (the sysprogs) would find\nsome setting on the system that was wrong, and when we traced it down,\nwe realized that this operator was just trying some command he had\nlearned in the book.  I understood his dilemma and sympathized with him.\nFortunately, I was the one elected to inform him of the consequences of\nhis learning attempts.  You can't do it when you're a computer operator,\nbecause you affect the entire MVS system.  He later changed companies\nand got himself placed in a much more responsible job.\n\n\nTWO ADVENTURES\n\n      I'll mention two of my big areas of discovery, which were largely\naccomplished through responsible playing.  Although the second of these\nwas the result of an initial blunder of mine, I have to say that I never\nonce afterward, caused another disturbance of my company's production\n(in more than five more years there).\n\n      My first adventure was about obtaining APF authorization for TSO.\nNowadays, that's done globally through settings in a PARMLIB member,\nIKJTSOxx.  But 20 or 25 years ago, it wasn't that easy.  And it took\nsome \"playing\" on my part, to discover a neat system programmer trick\nthat I like to call \"personal TSO APF authorization\".\n\n      Under TSO, there always have been several categories of program\nnames which were slated for special treatment.  One such category is:\nall TSO commands which are allowed to be run APF authorized under TSO.\nAnother category is all batch programs which can run APF authorized\nwhen CALLed under TSO.  A third is all TSO commands which are not to be\nallowed to run under TSO-in-Batch.  A fourth is all programs which can\nrun authorized when called through the TSO Service Facility.\n\n      Before the PARMLIB settings were invented (I think that was some\ntime during the ESA era), these four categories of program names were\nmaintained in load module tables that resided in four CSECTs.  APF\nauthorized TSO commands were listed in CSECT IKJEFTE2.  APF authorized\nprograms callable under TSO were listed in CSECT IKJEFTE8.  TSO commands\nthat you can't run in batch, were listed in CSECT IKJEFTNS, and programs\nwhich can be authorized when called from the TSO Service Facility were\nlisted in CSECT IKJEFTAP.  The tricky part of all this was the question:\n\"Where are these four CSECTs located?\"\n\n      In the old pre-TSO/E days, these CSECTs were part of the main TSO\ncontrol load module IKJEFT02.  If you wanted to zap new names into these\nCSECTs for your own use, you had to make another copy of the entire\nIKJEFT02 load module, put it into an authorized STEPLIB for your own TSO\nsession in your private LOGON PROC, and re-linkedit into it, one or more\nof the four CSECTs with a copy of your own choosing.  Problem was that\nif you did that, and later changed releases of TSO, you'd be running\nyour TSO with a back-leveled release of the TSO control program, unless\nyou remembered to do the whole process over for the IKJEFT02 load module\nin the new release.\n\n      With TSO/E, IBM got a little bit smarter, and separated these four\nCSECTs out away from the main TSO control program.  Instead, IBM created\na separate load module called IKJTABLS which would contain only these\nfour CSECTs of tables of program names.  Then, since the IKJTABLS load\nmodule would not contain any executable code, it would thus be release\nindependent, and you could carry a modified version of it over, from one\nTSO release to the next.\n\n      After that, IBM created the global PARMLIB settings, and used its\nname entries to construct the four dynamic global TSO tables of all\nthese lists of program names.  That's what's always used by all the TSO\nusers.  Right?  Not quite.\n\n      I asked the question whether the old IKJTABLS load module is still\nhonored in this \"modern\" environment.  It's a legitimate question.  I\ndid some playing to find out the answer.\n\n      First, I saw that there still exists a dummy copy of IKJTABLS in\nSYS1.LPALIB, even today.  This copy is obviously not honored, because it\nhas very few entries, way fewer than the PARMLIB member.  And the\nPARMLIB member is what works.  Then, I put a doctored-up copy of\nIKJTABLS into an ISPLLIB library, and I saw that it wasn't honored.\nAfter much playing, and having noted that I had to use an APF authorized\nSTEPLIB in my TSO LOGON PROC before (during the IKJEFT02 era), I tried\nputting my own copy of IKJTABLS into an authorized STEPLIB in my\npersonal TSO LOGON PROC, and I found that it worked.  Not only did it\nadd authorizations that weren't in PARMLIB, it lost authorizations that\nwere still in PARMLIB and which I forgot to copy to my own personal\nIKJTABLS.  I found that IKJTABLS in an authorized STEPLIB completely\noverrides the PARMLIB authorizations.  This is useful if I myself have\nto run certain commands authorized, and I don't want anyone else to.  I\ncan accomplish that without disturbing the entire TSO environment.\n\n      Score one discovery achieved by playing.\n\n      Discovery number two centers around something that used to exist\nin an MVS PARMLIB, a member called the BLDL list.  The BLDL list was\naddressed in a PARMLIB member called IEABLDxx.  This member no longer\nexists in PARMLIB.  Its functionality has been replaced, in MVS/XA\nsystems and later, by LLA, which used to be called Link List Lookaside,\nand now is called Library Lookaside.\n\n      The original problem that needed solving was the fact that if a\nsystem program was to be called many times over, the system would have\nto do a (very inefficient) search of pds directories, repeatedly, to\nfind its actual disk location so Program Fetch would load it for\nexecution.  As a first attempt to help matters, old non-XA MVS releases\nhad this PARMLIB member where you'd mention all the names of programs\nwhich you thought were to be called frequently.  At IPL time, MVS would\ncreate a table in common storage, called the BLDL table, which would\nlist the absolute actual disk locations of each load module, as it was\nat IPL time.  This table could not be refreshed without another IPL.\nNowadays, LLA maintains such a table in its own address space, and it\ncan be changed dynamically with an operator command, but in the old days\nyou were stuck.\n\n      One fine day (in the old days), I accidently wiped out a library\ncontaining some BLDL-table programs, and refreshed it with a new set of\nprograms, of course in different locations.  It was painful to see the\nproduction system die a slow death, as each necessary program was being\nfetched from its old disk place, in vain.\n\n      So afterwards I found a DYNAMIC BLDL program on the CBT tape\ninstead, and did a lot of playing around to make sure it worked.  This\nsolved all our subsequent problems in the pre-XA days.  The new program\nwhich was called DYNABLDL, interfaced with SVC 18 that does the program\nfetch.  Every system program that was called once, would have its disk\nlocation dynamically entered into a new table, and on subsequent\nfetches, the new table with the exact disk location, was the one used\nfor the fetch, and a second directory search was not necessary.  Of\ncourse in order for DYNABLDL to be completely effective, you had to\nremove all the program entries from your IEABLDxx PARMLIB member.\n\n      Somebody updated DYNABLDL for XA, which wasn't easy, because SVC\n18 was moved into read-only common storage in XA, and in order to zap it\ndynamically, which DYNABLDL did, you had to turn off page protection,\nwhich was a trick.  Once this was done, I benchmarked DYNABLDL under XA,\ncomparing it with the new LLA.  LLA was better, so DYNABLDL, despite\nits nice feature of allowing you to display the most-used programs, went\naway, unless I needed to fire it up to display the most-used programs.\n\n\nCONCLUSION\n\n      It is my contention that an ordinary smart person can't get this\nkind of MVS experience in 3 to 7 years.  We have to give the proper\ncredit to the old MVS hands who have learned their trade through much\ntrial and error, and through playing.  However, I do think that an \"MVS\ngeneralist\" with a good head for thinking, can manage a crew of more\nexperienced people, provided that he respects them, especially for their\nmany years of playing.\n\n      I wish all of you the best of everything, as this column goes into\nits sixteenth year.  Please visit here again, next month.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0402FE": {"ttr": 26117, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00(\\x01\\x04\\x00\\x9f\\x01\\x04\\x00\\x9f\\x11\\t\\x00\\xe9\\x00\\xe9\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-01-09T00:00:00", "modifydate": "2004-01-09T11:09:28", "lines": 233, "newlines": 233, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         FEBRUARY 2004\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.  The Online CBT Tape web site can be reached\nat www.cbttape.org .\n\n\nMODULARIZING AN MVS SYSTEM - PART 1\n\n      Today I want to start a subject that should be an essential part\nof the MVS systems programmer's knowledge.  The idea is to know which\nparts of an MVS system can be separated from the other parts on DASD,\nand which parts can't be.  Another way to put it, is to call it \"MVS\nDASD planning for the system components themselves\".  There are many\nsubtleties to this knowledge.  As soon as you think you \"know\nsomething\", you get caught by something else.  The proof of success is\nto remove the \"non-essential\" disk pack, IPL the system, and see that\nnothing breaks.  Most often, something does.\n\n      The idea of MVS system DASD planning is to make it possible to\ndivide the \"system\" disk packs of an MVS system so some disk packs can\nrun part of the system while the other disk packs are not present.\nAlthough you can run an MVS system in a mish-mash, with all the\ncomponents scattered on all the system disks, it is more prudent to set\nup MVS so that its different components and add-ons are physically\nseparated and the system disks are modularized as much as possible.\nThere are many reasons for that, but one reason is that when you have\nyour MVS system \"modularized\", it makes the shop's backup and recovery\nscenarios very much easier.  Another advantage is that migration to new\nreleases of MVS and its components is also very much simplified.\n\n      The capability and experience to set this up, while not being an\nabsolutely essential part of the new sysprog's duties, becomes extremely\nimportant as one's MVS responsibilities grow.  A senior MVS person must\nbe very knowledgeable in this area.  I feel that this ability is an\nabsolute requirement, to be considered a \"senior\" MVS practitioner.\n\n      This is not to say that a less experienced sysprog can't do a\nvery good job of organizing the DASD pack structure of an MVS system.\nIt'll just take a lot more effort, and it will involve making a lot more\nmistakes, but that learning process is extremely valuable.  And such\nexperience will make a junior person more \"senior\" in much less time.\n\n      Why is this subject so difficult?  (Try it and see!)  The reason\nis that in order to physically separate certain parts of MVS from other\nparts, you simply have to know the minimum of what is necessary to make\neach piece of MVS run, and sometimes you need considerably more than\nthat minimum to satisfy your shop's needs.  It is very helpful to know\nhow to set up each of the MVS system parts, and this knowledge only\ncomes from much exposure to MVS.  A senior-level person can make much\nshorter work of doing system DASD planning, because a senior person has\nalready acquired the knowledge of what each component needs, to be set\nup to run properly.\n\n      Many good MVS people do not have direct exposure to what I'll term\n\"the shop's DASD organization\", because they are working in an already\nestablished place, where somebody else did the initial planning.  But\nthe truth is that when a shop is older, and a lot of people have worked\nthere over the years, some sloppiness often tends to creep into the\ninstalling of new products.  You might find that many of the disk packs\nrunning the actual production MVS system are too dependent on each\nother.  Somebody installing a new software package may have scattered\nits various pieces among too many separate disk packs, and therefore\nthose packs are now hard to separate.  If you try to remove one pack\nfrom the configuration, you'll find that one or more products might\nsuddenly break.\n\n      I feel that this subject is too big to cover in one month's\ncolumn, so we'll start it here, and we'll continue speaking about it\nnext month as well.  Let's begin.\n\n      I believe that a very good shortcut to learning MVS DASD\norganization skills, is to learn about the handy disaster recovery\ntool that has come to be known as an \"MVS Rescue System\".\n\n\nTHE \"MVS RESCUE SYSTEM\"\n\n      Another term for an \"MVS Rescue System\" is a \"one-pack IPL-able\nMVS sysres\", although actually such a system could occupy more than one\nphysical or logical disk pack.  The idea of the one-pack system is to\nhave a compact, easily backed-up MVS system that can be used to rescue a\nbroken production MVS system easily.  Setting up a minimal MVS system\nyourself, is probably the easiest way to start getting a handle on\nunderstanding the complex structure of your big MVS production system.\n\n      How does the setting up of a one-pack rescue system help you to\nlearn DASD dataset organization?  It's simple.  If you have to set up\nall the ingredients of an MVS component on one disk pack, you'll be\nforced to learn about all the ingredients necessary for that component\nto work.  And once you've seen the ingredients of that component on the\nrescue pack, you'll be able to take a new look at the production system\nand recognize all those corresponding pieces of that component there,\ntoo.\n\n      Now let's talk about the rescue system itself.  First, we have to\nask the question about why we should have one in the first place.\nPutting it another way, we can ask:  \"Why it is handy, and sometimes\ndownright essential, to have an easily IPL-able skeleton MVS system\nalways available?\"  To grasp the answer, I have to talk about a\npeculiarity of MVS.  That is, you can't build a new MVS system without\nfirst having an old MVS system to start with.\n\n      Sorry about that.  The fact is that it takes an already running\nMVS system to fix or build another MVS system.  So if you can't IPL your\nproduction MVS system, you can't easily fix it.  You need to have\nanother MVS system available to access the datasets on the broken\nsystem's disk packs.  So if a shop has only one working MVS system\navailable, it is vulnerable to extreme disaster.  You need to have at\nleast two working MVS systems in your shop, to be reasonably safe, and\nit is far better to have several more than that.\n\n      So most shops run with at least an \"MVS Production system\" and an\n\"MVS Test system\" or \"the A-system\" and \"the B-system\" which they\nalternate.  But the extra one-pack system which can fix either of these,\nis an extra measure of protection, and it is even better if the one pack\nMVS sysres has been backed up several times with DFDSS or FDR, to tape.\nAfter the unthinkable, you might just have to make a standalone restore\nof your \"rescue system\", so you can start bootstrapping the rest of your\nMVS installation back up.  At least you'll have a good TSO to be working\nwith.\n\n      Therefore, if your shop doesn't already have one of these mini-MVS\nsystems, it would be prudent for you to make one.  Besides the obvious\nadvantage of having a shop that is better prepared to face emergencies,\nyou would also be getting some very essential experience while doing\nthis.  That's because the act of making a one-pack MVS system would give\nyou exactly the type of exercise necessary for doing MVS system \"DASD\nplanning\".  Putting all the essential parts of MVS in one place, will\nmake you become very aware of \"what belongs where\".  And in a larger\nsystem like the production system, which you'll work on later, you'll be\nable to physically separate your MVS system into several smaller pieces\nwithout any unwanted dependencies remaining.\n\n\nWHAT BELONGS ON A RESCUE SYSTEM?\n\n      When you build an MVS rescue system, you have a conflict.  Ideally\nyou'd like everything to be there that's in your production system, but\nit just doesn't fit, so you have to plan what to leave out, and what to\nmake smaller.  It essentially boils down to having enough of the system\navailable, so you can fix another system or run a piece of the\nproduction if really necessary.  Almost always, you don't use it for\nproduction.  You just use it to fix the actual production system, and\nthen you run your production jobs on the real production system.\n\n      As for my personal preference, I'd say that on my own rescue\nsystem, I want to have the full complement of my MVS system analysis and\ndata manipulation tools already installed.  In other words, I personally\nwould not be satisfied with only the vanilla IBM tools being installed\nthere.  I want my personal tools there too.\n\n      What are they?  For myself, I want Fullscreen ZAP and the PDS\ncommand package, and TAPEMAP, TAPESCAN, CDSCB, SHOWMVS, MXI, together\nwith a host of others, already installed.  These can fit on a couple of\nload libraries, and in a few panel, table and skeleton libraries.  All\ntogether, they do not take up a lot of DASD space, and they will all fit\non my rescue pack.  There should also be an available TSO logon proc\nthat will help me access all these tools easily.  I use a logon proc\nwith an authorized STEPLIB and a logon CLIST that gives me instant\naccess to all of my TSO tools, so I don't have to grope for them.\nUsually when I'm actually using my MVS rescue pack, I am in the middle\nof fixing some problem, so I need my tools.\n\n      But the main story is about how to copy or initialize the actual\nMVS components on this pack, so it will actually IPL all the way up.\nMany people have created jobstreams to do that work, but for\ndefiniteness, I'll refer you to the CBT Tape File 657, where Kevin Mitts\nhas a good set of jobstreams that have been tried on z/OS 1.4.  You can\naccess the pds containing these jobstreams at:\n\n  http://www.cbttape.org/ftp/cbt/CBT657.zip    or possibly\n  http://www.cbttape.org/ftp/updates/CBT657.zip\n\n      When MVS initializes, it has to refer to a bootstrap program, and\nthat is loaded into track 0 of the new one-pack MVS system residence\npack.  You need an ICKDSF job for that, and this job is Kevin's first,\nin member RESCUE01 of his pds.  IBM ships the object decks of the\ncurrent release of its bootstrap programs in SYS1.SAMPLIB of the MVS\nsystem.  Next, you need SYS1.IPLPARM with a LOADxx member initialized.\nOr alternatively, just having SYS1.PARMLIB with the LOADxx member will\ndo.  Kevin's second job in member RESCUE02 of his pds, allocates all the\nnon-VSAM system libraries, including SYS1.PARMLIB.  SYS1.PARMLIB will be\nloaded with the minimal essential materials in a later jobstream.  Then\nof course, the RESCUE pack will need an MVS master catalog.  This is\ncreated in member RESCUE03 as a usercatalog of the driving system, and\nit will be disconnected later.\n\n      Then you have to copy all the members of the MVS system libraries\nfrom your production system onto the corresponding system libraries on\nthe rescue pack.  This is in member RESCUE04.  The job uses ADRDSSU, and\nit is an efficient way to get all the copying done.   Next, you need to\ndefine the PLPA, COMMON, and LOCAL page spaces on the rescue pack.  This\nis done by the job in member RESCUE05.  Then you have to catalog all the\nnonVSAM system libraries you created earlier, into your new MVS master\ncatalog, so the IPL of the RESCUE system will later find them.  This is\ndone in member RESCUE06.\n\n      Next, an IEBUPDTE job is run on the driving system, to load the\nnew SYS1.PARMLIB of the rescue system with its necessary members.\nEssential PROCLIB members are loaded similarly into the new SYS1.PROCLIB\nby job RESCUE08.  To get TSO on the new system, you'll need VTAM, so the\nnew SYS1.VTAMLST library is loaded using IEBUPDTE by job RESCUE09.  Job\nRESCUE10 assembles a couple of necessary RACF customization modules,\nICHRDSNT and ICHRIN03, as well as creating the RACF database itself.\nJob RESCUE11 runs TSO ACCOUNT to create the IBMUSER TSO userid, and it\nalso initializes SYS1.LOGREC.  Job RESCUE12 copies over the old IODF\ndataset to the rescue pack, so you have an I/O device configuration\ndefined there.  RESCUE13 is a job to EXPORT DISCONNECT the new rescue\nMVS master catalog from the driving MVS system.  And finally RESCUE14\ncreates a tape, so you can do a standalone ICKDSF, a standalone DFDSS,\nand you have a DFDSS backup of the entire new RESCUE pack.\n\n      Obviously, you can modify all these jobs in any way you want, to\ncreate an MVS rescue system that is either bigger, or is more practical\nfor your own use.  But it's nice to have a starting set of jobs that\nwork, with parameters that have already been tested.  As we said before,\njust going through this exercise of customizing Kevin Mitts' jobs (or\nsomebody else's) to create a working MVS skeleton system, is of immense\nvalue for learning the MVS system DASD structure.  And as we will\ncontinue to explain next time, these skills will help you very much, in\nyour efforts to get your shop's MVS DASD organization under better\ncontrol.  Until then, I wish you much success and an excellent month.\nSee you soon!\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0403MA": {"ttr": 26122, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Q\\x01\\x04\\x04\\x0f\\x01\\x04\\x04\\x0f!\\x18\\x00\\xec\\x00\\xec\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-02-09T00:00:00", "modifydate": "2004-02-09T21:18:51", "lines": 236, "newlines": 236, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          MARCH 2004\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.  The Online CBT Tape web site can be reached\nat www.cbttape.org .\n\n\nMODULARIZING AN MVS SYSTEM - PART 2\n\n      Last month, we began to talk about an enormously important MVS\nsubject--the strategic placement of essential MVS datasets on the\n\"proper\" disk packs.  The aim of this exercise is to be able to\nmodularize your MVS system.  This means that if you remove some of the\ndisk packs, you can still run part of the system; different components\nare on different packs.  If you want to leave out a component, then you\ncan (so to speak) leave out its packs, and the rest of the system will\nstill run.\n\n      In practice, such a concept is easy to talk about, but highly\ndifficult and tricky to actually implement.  One reason for this, is\nthat some MVS components simply cannot be separated--they require each\nother.  For example, TSO or TCAS requires VTAM, and so do other\nessential MVS components.  So we might say that VTAM is more \"basic\"\nthan some other components, and therefore it should be placed on a more\nessential pack, such as the first MVS res pack.  The more \"dependent\"\ncomponents might be safely put on some other pack.  But even that is not\na good rule.  If you put TSO on a different pack than the \"lowest level\"\npack, and if for some reason you can't get access to TSO's pack, then\nyou can't fix the rest of the system.  So TSO, even though it is\ndependent on VTAM, is just as essential as VTAM, and practically\nspeaking, they can't be separated from each other.\n\n      On the other side, there are often reasons why we have to separate\ntwo MVS components and put them on different packs.  One such reason\nmight be because of system performance.  For instance, on a heavily\nloaded production MVS system, we might want to keep production datasets\nand often-used system datasets away from a pack which is subject to\nfrequent RESERVEs.  Or we might try to lessen channel usage to certain\nheavily used packs, and not put two heavily used datasets on the same\npack.  A second consideration would apply to packs containing paging\ndatasets.  If a non-paging dataset coexists with a paging dataset on a\npack, the system paging algorithms are less efficient, so in a heavily\nloaded situation, this could slow the system down.  By now you should\nbegin to see that efficient dataset placement boils down to \"knowing an\nawful lot of stuff\" about how MVS works.\n\n      These are the kind of complications that we commonly encounter in\nour efforts to modularize MVS.  There are complex reasons why one\ncomponent needs to be available together with another component, with\nthe reason not always being a \"logical dependency\", but a \"practical\ndependency\".  And there are just as many reasons sometimes, why it is\nbetter that one component should be kept separate from some other\ncomponent.  Modularizing MVS can be very tricky business--it is very\nsite-dependent, and sometimes it is actually better practice NOT TO DO\nIT AT ALL!  But the bottom line is that you have to have tried it.  You\nhave to make the effort.  And while you're making that effort, you have\nto find out about as many factors affecting how your installation\noperates, as possible.  In the end, you may make the decision that it\nis best NOT to modularize.  But your installation will be far better\noff, just because you tried.  You'll know a lot more about what makes\nyour installation run.  And the site will profit greatly because you\nhave acquired this extra knowledge.\n\n      So to begin to gain this very essential knowledge, I feel that the\nfirst step is to do the exercise of putting all the essential MVS\ncomponents on ONE single disk pack.  Nowadays, we call that process\n\"making an MVS Rescue pack\".  We talked about doing that last month.  In\nperforming this exercise, you'll see that the art, craft, and science of\nplacing MVS functionality all in ONE place, will help you later, so\nyou'll be able to divide your big system over three, four, or ten\nplaces, and as a result (if you've done it well), you'll have a better\nrunning MVS system.\n\n\nMY RESCUE PACK TIPS\n\n      Last month, we mentioned that several schemes and sets of JCL jobs\ncan be found in the CBT Tape collection, to help you set up your own\none-pack MVS system.  Several of the CBT Tape files which contain this\nkind of help are:  Files 022, 164, 434, 609, 613, and 657.  These can\nbe obtained at:\n\n      http://www.cbttape.org/ftp/cbt/CBT434.zip\n\nfor File 434 (for example).  Since the server is a UNIX system, this URL\nis case sensitive.  File 657 is still new, and its URL is still:\n\n      http://www.cbttape.org/ftp/updates/CBT657.zip\n\nas of the time of this writing.\n\n      The idea behind all of these schemes is to build all the\nstructures necessary to IPL MVS on one disk pack, using a \"driving MVS\nsystem\" to build the Rescue system.  Remember we said last time, that\nyou need an existing MVS system to create a new MVS system.  I know that\nany one of you can customize and follow any of these schemes for\nyourself.  But what I want to show you now, is how to make your new MVS\nRescue Pack look familiar, so that all of your own good tools are there.\nThe idea here is that logging on to the Rescue system's TSO should look\nand feel essentially like logging onto the production system's TSO.\n\n      I'll assume that you've already created a workable \"vanilla\"\nrescue pack, and you've copied your RACF database (or ACF2 or TSS\nequivalent) so that you have userids and passwords already defined\nfor it.  Now I'll show you how to import your tool collection to the\nRescue system.\n\n      The first thing you should do is to IPL your new Rescue pack\ntogether with all the packs where you keep your tools.  Logon with a\n\"bare-bones\" LOGON PROC, and with all the allocations done via CLIST.\nThat's always a better practice, because it is much harder to get a JCL\nerror in your TSO id, when you LOGON.  But even if your LOGON PROC\nspecifies all the allocations via JCL, and you have a fairly up-to-date\nISPF (I think 4.4 or later is enough), then you can convert your logon\nallocations from JCL to CLIST in about five minutes.\n\n      Just do the following:  Issue TSO ISRDDN from the ISPF command\nline, enter the keyword \"CLIST\" on the command line and press ENTER.\nA CLIST showing all the allocations (including the temporary ones) will\nappear.  CREATE a new member with this CLIST in a system CLIST library\nthat's already in the SYSPROC DD concatenation, EDIT that CLIST to\nremove the temporary allocations, and use the resulting CLIST in a\n\"bare-bones\" LOGON PROC, such as the one I've shown in Figure 1.  The\nSYSPROC DD name in the logon PROC only has to point to the one CLIST\nlibrary which contains your LOGON CLIST member.  When you now re-LOGON\nwith the new PROC, all the allocations should be exactly the same as\nbefore, but they'll be dynamic, and not static.  If a library is\nmissing, you'll still get into TSO and not get a JCL error.  If you have\nthe RPF (CBT Tape File 415) or RPF/E (File 417) editor installed, which\ndoesn't need ISPF, you can fix the logon CLIST after such an allocation\nfailure and get back into ISPF pronto.\n\n      Once you've converted your LOGON allocations to a CLIST, you can\nadd or change the concatenation of datasets with the greatest of ease.\nNow customize the allocation CLIST to look like your production\nallocation CLIST.  (To get that, just do ISRDDN for your production TSO\nuserid and enter the CLIST command.  Then print out that CLIST and use\nit as a pattern.)  Finally, once your Rescue TSO allocation CLIST looks\nlike your production one, re-logon to TSO, do another ISRDDN, and see\nhow many of the datasets are not on your Rescue res pack.  For each of\nthose datasets, copy the dataset to another one on the Rescue res pack,\nand re-point the Rescue logon CLIST to the corresponding new dataset on\nthe Rescue res pack.  Do this until an ISRDDN shows all the allocated\ndatasets to be on the Rescue res pack.  If you need an APF authorized\nSTEPLIB load library, don't forget to make a copy of your production one\non the Rescue res pack, and authorize it in the PROGxx PARMLIB member.\nIssue SET PROG=xx on the master console to get the authorization done\nright away.  After the next IPL, the authorization will stay there too.\n\n      Doing this exercise will show you where your own tools are\nlocated.  When you'll later possibly have to move them, as you begin to\nreorganize your production MVS system, you'll have a much better handle\non how to do it.  The same considerations also apply to the system\ndatasets that have been customized by your installation.\n\n      Now, with your tools in place on the Rescue res pack, logon to TSO\none more time, and play with all your tools for a while, until you're\ncompletely satisfied that they are working properly.  Run them in batch\njobs too, and try them under TSO-in-Batch, just to make sure that you\nhave re-created all the facilities you need.  This step cannot be left\nout.  Later, you'll have to test your re-organized production system in\nthe same way, but even more thoroughly.\n\n      Make sure that your Rescue res pack has enough JES spool.  If not,\ncreate an additional spool pack and do a JES cold start to let JES know\nabout the extra spool space.  Under JES2, the $DSPL,ALL console command\nwill tell you if the spool dataset(s) are filling up too quickly.\n\n\nVENDOR PRODUCT CONSIDERATIONS\n\n      You may not be able to create a working copy of all your system\nvendor products on your Rescue res pack.  These products may be too hard\nto re-install, or they may take up too much room.  An alternative might\nbe to include all the packs containing the relevant vendor software\nlibraries into your Rescue res pack IPL.  Then you can IMPORT CONNECT\nthe relevant user catalogs into the res pack's master catalog, and the\nRescue system will then \"know\" about the vendor product.  You might have\nto change the Rescue pack's linklist and LPA list accordingly, too.\nThis is a way to get your production vendor products to work, while\nbeing driven by the Rescue system MVS res pack instead of the\nproduction system MVS res pack.\n\n      This hybridization of your MVS system functions--driving them by\nusing a different MVS res pack--is actually step number two, after\nhaving constructed your Rescue MVS res pack and getting it to work the\nway you want it.  See how many of your installation's processes can be\ndriven, just from the (expanded) Rescue res pack.  Doing this second\nexercise is the bridge between working with the small self-contained\nRescue MVS system and your large full-size MVS production system.  As\nyou will undoubtedly find out, there is a lot of difference between the\nsmall sandbox system and the installation's full-size MVS.  But\nattempting to expand the small system until it can do a lot of work,\nwill be very eye-opening, and extremely helpful to you.\n\n      I think that we've actually covered a lot of ground this month,\noutlining a method of systematically getting a handle on how to separate\nyour MVS system functionality into different pieces.  In the concluding\narticle next month, I'll try and cover other miscellaneous related\ntopics.  Thanks for visiting.  I hope to see you here again next month.\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.             BARE-BONES TSO LOGON PROC\n\n            Note the APF-authorized STEPLIB DD and also\n            the SYSPROC DD pointing to the CLIST library\n            containing your logon allocation CLIST.\n\n\n//*--------------------------------------------------------------*//\n//*--  \"Bare-bones\" TSO LOGON Proc - PGM=ADFMDF03 gives the    --*//\n//*--                                TSO session manager.      --*//\n//*--                              - PGM=IKJEFT01 gives        --*//\n//*--                                regular TSO READY.        --*//\n//*--   Please note the APF-authorized STEPLIB.                --*//\n//*--------------------------------------------------------------*//\n//ISPFPROC EXEC PGM=ADFMDF03,REGION=0M,DYNAMNBR=175,\n//             PARM='%MYCLIST'\n//STEPLIB  DD  DISP=SHR,DSN=myusrid.APF.LINKLIB\n//SYSPROC  DD  DISP=SHR,DSN=MY.CLIST.LIBRARY  (contains member MYCLIST)\n//SYSPRINT DD  TERM=TS\n//SYSTSIN  DD  TERM=TS\n//SYSUDUMP DD  SYSOUT=Z\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0404AP": {"ttr": 26372, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00%\\x01\\x04\\x06\\x8f\\x01\\x04\\x06\\x8f\\x14\\x00\\x00\\xe9\\x00\\xe9\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-03-08T00:00:00", "modifydate": "2004-03-08T14:00:25", "lines": 233, "newlines": 233, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          APRIL 2004\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.  The Online CBT Tape web site can be reached\nat www.cbttape.org .\n\n\nMODULARIZING AN MVS SYSTEM - PART 3\n\n      For the last two issues, we've talked about the idea of separating\ndifferent MVS components by disk pack location.  This activity, while\nnot always \"the thing to do\" in your own data center, provides an\nincomparably valuable exercise in learning \"what makes MVS tick.\" Today,\nwe'll finish the series with some opposite thoughts and concepts which\nare related to that general idea.  In doing so, we'll touch on a number\nof valuable topics that every MVS sysprog ought to know about (or at\nleast have an educated opinion about).\n\n      One of my friends pointed out the obvious fact that if you\nseparate different MVS components on different disk packs, you may use\nmore disk packs than your shop wants to dedicate for system use.  So\nthat leads to the opposite plan, the idea of combining different\nproducts onto the same disk pack.  My idea is that you have to separate\nthe products first, then carefully put them back together, while\nconstantly being aware of their logical separateness.  So even if\nseveral products or components physically exist on the same volume, they\ncan still be isolated if you have a need to do so.  That's a practical\ncompromise.\n\n      Today, we'll look at this idea of \"how to combine\" on two\ndifferent levels.  The first is the idea of combining load modules from\nmany different products into one large load library.  This is a practice\nthat was commonly done in the past, due to MVS architecture\nrestrictions.  But nowadays, with changes in the MVS facilities, I feel\nthat the practice should be carefully eliminated.  The second is the\nidea of combining several separate products, with all their related\ndatasets, on the same physical disk volume.  I feel that such combining\nshould only be done after doing a lot of thinking, so the total contents\nof each disk pack makes some kind of logical sense.\n\n      The first topic we'll discuss is the \"combined load library\",\nbecause a proper treatment of that topic requires knowledge of some MVS\nhistory.  I want to give the idea of \"the mixed-up load library\"\nadequate treatment, so we'll talk about it first.  Then after that,\nwe'll say a few words about which different products to put on the same\ndisk volume, and why.\n\n      Your shop, especially if it has been in existence for a long time,\nhas inherited its dataset organization for definite historical reasons.\nBut MVS has changed over the years, and even though you may not want to\nrock the boat, it is very likely that your installation's system\ndatasets and their contents will benefit from some careful review.\n\n\nPROS AND CONS OF THE \"COMBINED LOAD LIBRARY\"\n\n      Many shops have combined all, or many, of their non-IBM load\nmodules, into one large load library, often called something like\nSYS2.LINKLIB.  Because of some MVS limitations in the past, this\npractice used to make sense.  But now things have changed.  Let's look\nat the situation.\n\n      In the old days of MVS, before LLA (Library Lookaside) was\ninvented, there was an efficiency question that had to do with fetching\na single load module which was needed by the MVS system.  System modules\nwere (and still are) placed in partitioned datasets, load libraries,\nwhich are in turn, reported to MVS by a list in PARMLIB called the link\nlist.  To find and load one particular load module from the link list,\nwould involve doing many (very inefficient) partitioned dataset\ndirectory searches, that had to be repeated each time a new copy of that\nmodule was needed by the system.  And you would also want to minimize\nthe number of libraries that had to be searched.  To add to this, IBM\n(in the old days) placed an upper limit (quite low) on the total number\nof dataset extents that could be found in the list of link list\ndatasets.  So all those forces pushed the MVS system programmers of that\ntime, to use as few link list libraries as possible.\n\n      Following later IBM improvements to the MVS system, notably the\nintroduction of LLA, that isn't the case anymore.  But many people's\nthinking processes have not changed to keep pace, despite IBM's repeated\nannouncements and encouragement to the contrary.  People tend to think\nthat it's easier not to rock the boat.  After all, the production system\nis still running, and that's what counts.  Of course, I have to explain\nwhy I think making these \"combined load libraries\" containing components\nof many products, is at least partially wrong for current MVS systems.\n\n      So how does LLA work?  How does LLA make a long list of many load\nlibraries in the link list just as efficient as a short list of few?  It\nworks this way, simply put.  LLA keeps an address space with information\nabout the absolute disk directory location of every load module in the\nlink list.  After LLA initialization, when this whole structure is\ncreated, LLA has its own very efficient means of searching its address\nspace to quickly find the disk location of any load module which is\nneeded right now.  So LLA avoids all the slow partitioned dataset\ndirectory searches, and it doesn't matter how many separate load\nlibraries are in the link list.  Besides that, IBM also removed the\n\"total number of extents\" restriction to the link list libraries quite a\nwhile ago.\n\n      If a module from a link listed load library is replaced by a new\ncopy in a different disk location, of course LLA will go and look at the\nold disk location in its address space.  So if you create a new copy of\na load module in the link list, there has to be a way of telling LLA\nabout it.  That's why IBM has supplied the ability to do a complete, or\npartial LLA structure refresh with operator commands, such as \"F\nLLA,REFRESH\" which does a complete rebuild of the LLA structure.  This,\nsimply put, describes the \"change of architecture\" which should lead to\na change in our thinking.  It is now permissible and efficient to put\neven a very large number of load libraries into the link list, and now\nwe can separate more MVS vendor products and system components into\n\"pure load libraries\" that come solely from each vendor.\n\n      What's the advantage of doing this?  We can probably best answer\nthat question by pointing out some disadvantages to the \"combined load\nlibrary\" system.  The first obvious disadvantage to a combined load\nlibrary is that you don't know which product a particular load module\ncomes from.  You might answer that by saying that all load modules for a\ngiven product have a standard naming convention, with perhaps a standard\nprefix in the module name.  But that isn't entirely true.  Sometimes\nthere's a system requirement that can't be avoided.  For example, CA-1\n(tape management) has to supply certain system exits, whose names,\nOMODVOL1 and EMODVOL1, are required by IBM.  So if you see OMODVOL1 in a\ncombined load library, you have no idea where it really came from.  You\ncan try browsing the load module, but even then, there might not be a\ntelltale eyecatcher.  However if you kept your load libraries \"pure\",\nwithout mixing them up, there would be no such problems.\n\n      A more subtle disadvantage to combining load libraries, is that\nyou don't know what RELEASE of a certain product that a particular\nmodule belongs to.  Of course, if the vendor always supplies eyecatchers\nwithin ALL its modules (not always the case), you can use the free PDS\ncommand package (CBT Tape File 182) to issue a:\n      FIND : /eyecatcher/ THEN SUBLIST\nsubcommand and pick all those modules out.  But that's a spotty method\nthat obviously doesn't work in all cases, though it can help you in a\nparticular case where the vendor is always consistently supplying the\nproper eyecatchers.  But obviously, if a vendor drops a certain module\nname from a later release of its product, the old module will always\nremain around in the combined library, and it will never be replaced by\nanother copy from a new release, and thus disappear.  So the cleanest\napproach nowadays, is to keep all vendor link list libraries \"pure\",\neven if there are a lot of them.\n\n      In your particular shop there may be other factors which affect a\ndecision of this type, so the bottom line is that you always have to\nthink straight, keep all the factors in mind, and be aware that there\nare no universal rules that apply to everybody.\n\n\nCOMBINING DIFFERENT PRODUCTS ON ONE DISK PACK\n\n      So now we're coming back to the other question of how to combine\ndifferent MVS products and components on ONE or a few disk packs, so as\nto use a minimum of disk volumes for system purposes.  This is not\nnecessarily a contradiction to our original aim of separating different\nMVS components on different disk packs.  The idea here, is that if we\nare limited in the number of disk volumes available to be used for\nsystem purposes, we should carefully plan which components or products\nto put together on each particular pack, but we should also be aware of\ntheir separateness.  So we should keep each component's libraries and\ndatasets strictly separated as much as possible, even though they may\nphysically reside on the same disk volume.\n\n      Several factors may enter, when we are making these decisions.  I\nthink the primary factor is that when looking at a dataset list of any\nparticular system volume, the list of its contents should make obvious\nsense.  An outsider, trying to figure out how you've organized your\nsystem volumes, should have little trouble figuring out why you've put a\nparticular set of components or products on any particular system pack.\n\n      One obvious method of disk volume organization is to put, say,\nall CICS-related components on one pack, all IMS-related components on\na second pack, and all DB2-related components on a third pack (or set\nof packs).  This is a clear and sensible scheme that makes the products\neasy to find.  Of course in your particular shop, that scheme might not\nwork out, but in many places, it will.  The important idea here is to\nkeep the dataset organization as simple and clear as possible, despite\nan individual installation's peculiarities.\n\n      Several other factors come to mind when organizing disk datasets.\nWe'll mention what they are, and then say a few words about each one.\nI'll call these factors:  functionality, disk space requirements,\nreplaceability, and unavoidable MVS system requirements.\n\n      Functionality includes two considerations.  The first is that\nrelated types of software components should be near each other.  The\nsecond is that heavily used datasets should not interfere with each\nother or bottleneck the system.  For example, a dataset which gets\nfrequent RESERVEs placed against it, should not be on the same volume\nwith other datasets that are heavily used.\n\n      Disk space requirements are obvious.  If there is a lot of space\non a pack--enough to contain several separate components, and they do\nnot interfere with each others' operation, then they can be placed\ntogether on the same pack.\n\n      Replaceability has to do with ease of substituting a new release\nof the product, or ease of backing the product up.  If the components\nof a product are scattered across several different disk volumes, then\nsynchronized backups and replacements of software intrinsically present\nmore difficulty.\n\n      Finally, unavoidable MVS system requirements are the kind of thing\nwhere you have to put an entry in PARMLIB, or you have to put a library\ninto the LPA list or some place on the main MVS res pack, so that the\ncombination of purely MVS requirements forces you to place different\nparts of a component or product on completely different packs.  With\nrecent improvemnts to MVS, such as the ability to have many libraries in\nthe LPA list instead of forcing you to put all modules into SYS1.LPALIB,\nthe situation has been improved.  But it still is not perfect, in this\nregard, by any means.  So for a while at least, MVS requirements may\nsometimes place restrictions on sensible disk placement.\n\n      I hope that this mini-series has provided us with food for thought\nabout improving the efficiency of our MVS installations in various ways.\nAs Gerald Weinberg once pointed out his preface to Bill Mosteller's\nclassic 1979 book \"The Systems Programmer's Problem Solver\", a systems\nprogrammer is very much like a soccer goalie.  Often, the action is\ntaking place on the other side of the field.  But the goalie has to\nanticipate, worry and plan nevertheleass, about what to do when the\naction comes to his side.  That is the realm of what we've been\ndiscussing these last three months.  You've got to accumulate the\nknow-how today, to solve or avoid tomorrow's problems.  I wish you all\nthe best of everything, and hope to see you here again next time.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0405MY": {"ttr": 26377, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x17\\x01\\x04\\x10\\x0f\\x01\\x04\\x10\\x0f\\x07\\x11\\x00\\xed\\x00\\xed\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-04-09T00:00:00", "modifydate": "2004-04-09T07:11:17", "lines": 237, "newlines": 237, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           MAY 2004\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.  The Online CBT Tape web site can be reached\nat www.cbttape.org .\n\n\nWHAT'S FOREMOST IN YOUR MIND\n\n      Today, I want to talk about a mental phenomenon that everyone\nknows about, and which almost nobody writes about, especially as it\nrelates to MVS systems programming.  This phenomenon greatly affects\nour MVS work, and also the way we live our lives.  All people work and\noperate within its parameters.  Everybody is consciously, or (much more\nfrequently) unconsciously aware of its effects.  But, since I'm not a\nprofessional psychologist, I've never seen this mental phenomenon\nformally discussed or written about, even though its effects are so\npervasive, and it is so important to all of us.  What is this\nphenomenon?  How does it work?  As an MVS systems programmer, I feel\nthe effects of this phenomenon every single day.  That's why I felt\ncompelled to write something about it.  It's very relevant to us.\n\n      I'll keep you in suspense just a moment longer, while we introduce\nthe subject at hand.  Everybody knows from experience that we're usually\nthinking about something.  There's almost no time when we're thinking\nabout \"absolutely nothing\", even when we're sleeping.  Especially at\nwork, there's always some problem or task or situation which is\ncurrently keeping us busy, or which gives us something to be concerned\nabout.  Even if we're thinking about something at work that isn't work\nrelated--we're still thinking about something.\n\n      Now we all know, whether we're psychologists or not, that whatever\nwe've been thinking about RECENTLY, is foremost in our minds.  After\nthat, the thoughts are not forgotten completely, but they recede, in our\nminds, back into what I call \"various stages of archiving,\" like HSM\nstage one and HSM stage two.  If you need a piece of information that\nyou haven't thought about since some time before, you do a mental\nprocess that's somewhat like recalling data from archive.  Either you\nget it back from a \"first level of archive\" which is easier to recall,\nor if you haven't thought about it for a long time, it has to be\nrecalled from (to picture it) \"deep in the recesses of your mind.\"  This\nprocess of \"recalling from deeper down\" might be (depending on the\nperson, the time, and the information to be recalled) somewhat more\ndifficult.\n\n      At this point we can introduce today's subject.  It is simply to\npoint out HOW MUCH our production and creativity at work, depend on what\nwe've been thinking about RECENTLY.  With this background, we can also\nthink how our RECENT thoughts juxtapose with the recalling of certain of\nour OLDER thoughts.  We can all gain a lot by realizing what's going on\nhere in our own minds.  If we understand that there is a mental process\nof archiving and recalling our thoughts, and by understanding that it is\nvery important to bring thoughts to our \"mental foreground\" to make them\n\"recent thoughts,\" then we can consciously increase our productivity,\nand create a greater satisfaction in our accomplishments within\nourselves.\n\n\nAN EXAMPLE\n\n      Here's an example to show what I mean.\n\n      I recently had occasion to fire up an old release of MVS, because\nwe wanted to create a testing situation and compare how software ran in\nthe past, on old MVS releases, to how it runs today.  While watching the\nIPL of the old release, I noticed that JES2 came up without parameters,\nso I put a \"START JES2,PARM='WARM,NOREQ'\" statement into the COMMND00\nmember in PARMLIB.  After doing that, JES2 came up twice, in the first\ninstance, still without the parameters.  I needed to find out what was\nstarting JES2 in the first instance.\n\n      Upon searching PARMLIB for other \"S JES2\" statements, I found\nnone, and was, for the moment, perplexed.  Then I realized that JES2 is\na subsystem, and I looked into the IEFSSN00 member of PARMLIB, still\nfinding nothing.  Finally, I checked out the IEFSSN00 member of my\ncurrent MVS system to compare, and I found the statement:\n       SUBSYS SUBNAME(JES2) PRIMARY(YES) START(NO)\nAnd it was the \"START(NO)\" that made me realize what was starting JES2\non the old system.  I corrected the statement in IEFSSN00:\n       JES2,,,PRIMARY\nto read:\n       JES2,,,PRIMARY,NOSTART\nand with the next IPL, all was well.\n\n      Now most of you have been sitting and laughing at me the entire\ntime you've been reading this.  That's because you've all had occasion\nto think about the contents of the IEFSSN00 member of PARMLIB recently,\nwhile I haven't tried to change one of them, in the last ten years or\nso.  I had forgotten that the JES2,,,PRIMARY statement in IEFSSNxx will\nstart JES2, unless you tell it not to.  I have known this fact for well\nover twenty years.  But I hadn't thought about it RECENTLY.\n\n      The fact was buried in the archive of my mind.  Upon receiving\n\"a request for recall\" in the form of the question, \"what the heck is\nstarting JES2 here?\" I started investigating, which triggered \"the\nrecall process\" inside of my mind.  Even after seeing the new format\nof the statement defining the subsystem JES2 to MVS, I was able to\nrecall the correct old format, and after this \"recall from my archive\"\nI was able to fix the problem on the old system.\n\n      This illustrates our process very aptly.  Now we'll be able to\nlook at the phenomenon in much more detail, as it relates to our\neveryday work.\n\n\nMIXING THE RECENT THOUGHTS WITH THE OLD KNOWLEDGE\n\n      If we sit down and think carefully about what we do, we'll see\nthat most of it consists of applying our \"old knowledge\" to addressing\ncurrent tasks and problems.  So if we start looking at it, we'll see\nthat our daily thought processes largely consist of pulling ideas and\nfacts from both recent and distant mental archives, to apply them to\nsolving our current problem.  Once a fact has been \"recalled from\narchive\" it is then turned into \"current knowledge\" that is in the front\nof our mind.  It's almost like using DASD, when you are operating in an\nenvironment that has HSM or some other dynamic file-archiving and\nrecall mechanism.  It's easy for us to make such a mental picture.\n\n      The process can go the other way, too.  If you write programs\nfrequently, you'll see what I mean.  And everybody else can sympathize\nas well, so you'll all understand how it goes.\n\n      Have you ever written an involved program, had your \"head in it\"\nfor weeks, and finally gotten it to work?  Once the program has passed\nmuster and it's working properly, you then tend to \"forget about it and\ngo on to the next thing.\"  A couple of months later, you might barely\nremember that you ever wrote that program.  If you happen to look at the\nsource code a couple of YEARS later, you might ask yourself:  \"DID I\nEVER WRITE THIS?\"  Sometimes I actually feel that way myself, when I\nlook at my old \"MVS Tools\" columns.  Of course, residuals remain in the\nfront of your mind, when you're reminded about your old work.  You\nusually recall that you did it, but the details have been \"archived\"\nand you won't remember them, until after the \"recall process\" has been\ncompleted in your mind.  You need something to \"refresh your memory.\"\n\n      So next comes the question:  \"How much of my knowledge should be\n'recent', and how much should I allow to become 'archived'?  Should I\ntry to do a lot of 'recalls' so that more of my knowledge becomes\nrecent?  When does this pay, and when does it not pay?\"\n\n      Of course, if you're going for job interviews, you have to do a\nlot of \"recalls from archive.\"  If you're settled at a job, then there's\nsome leeway to choose what to do.  I have a few thoughts on that.\n\n\nREVIEW, REVIEW--AND HELP THE OTHER GUY\n\n      How do you force a thought or a fact to be \"recent\"?  The simplest\nway is by thinking about it.  To keep that thought from being archived,\nyou think about it again.  And again, and again.  It's just like\nmanaging HSM.  If you keep on accessing the data (read \"thought\"), it\nwon't be archived.\n\n      I'll show you a real-life example.  I am the proprietor of the CBT\nTape collection of free MVS software tools, and as of this writing,\nthere are over 670 non-null files on the \"tape\" (which really is a\ntape).  I know most of the programs by their file number, since I'm\ninvolved with putting the tape together.  I'm pretty good at remembering\nnumbers.  Especially, file numbers from my own contributions to the\ncollection are not easily forgotten.  So imagine my surprise this\nmorning when somebody asked me about my SMP/E tools file (it is really\nFile 118), and I couldn't recall the file number or any of the program\nnames.  I did manage to remember that the programs were meant to\npre-process a PTF file (on tape or on disk) without using SMP/E, and\nsort the PTF numbers by their FMIDs and report line counts, etc.  But I\neven forgot all the program names.  And I wrote that stuff myself!\n\n      So I looked up \"SMP/E\" in my CBT Documentation pds (a pds-izing\nof CBT Tape File 001 - see File 006 as to how to make that pds from\nFile 001), using a PDS 8.5 text scan.  The PDS85 command is:\n      FIND : ?SMP/E? THEN(MEMLIST)\nThe members which turned up included @FILE118, so that was enough to\njog my memory and get the correct file number.  Then I read the program\nnames from the member, and I'm not going to forget them for a while.\nThe two program names are PUTXREF and SMPUPD.\n\n      If I really didn't want to forget this stuff, and if I felt that\nit's especially important, I'd make sure to print it out and read it\nover every day for a week or two.  That certainly should help to keep it\ncurrent in my mind.  Or I'd make a mnemonic device, like \"XU118\" to\nstand for putXref and smpUpd which belongs to CBT Tape File 118.  Then I\ncould review the mnemonic \"XU118\" a bunch of times, so I don't forget it\neasily.  (I'd still have to remember what XU118 actually stands for.)\nIn either case, you manage your memory just like you deal with HSM.  If\nyou want to keep an item current, you do a lot of recalls.  REVIEW,\nREVIEW!\n\n      One way I keep \"fresh\" in my MVS knowledge is to ask other\nsystems programmers what is bothering them--what current problems do\nthey have on their mind?  If you're not that gregarious and you don't\ntalk to people that much, try reading through a daily digest of the\nIBM-Main newsgroup, to see discussions of many other people's problems.\n(To find out about IBM-Main, see my April 1998 column--member CL9804AP\non File 120 of the CBT Tape--which has been updated since then.)  When\nI have to grapple with a fresh problem, either a task at work, or to\nhelp someone else, it triggers a lot of \"recalls\" in my mind.  So when\nthat \"data\" is accessed, it returns again to the front of my mind.\n\n      It's really just like HSM.  You have to find excuses to do a lot\nof recalls.\n\n\nSUMMARY\n\n      Sometimes you have to say to your mind:  \"What have you done for\nme lately?\"  The mind is, in a sense, very similar to HSM.  If you don't\naccess the data, it gets \"archived\".  Archived data is more difficult to\naccess than is \"current data\".  It has to be \"recalled\" first.\n\n      Facts in your mind are very similar.  If you don't think about\nthem, they go to the \"back\" of your mind instead of staying in the\n\"front\" where you can get right at them.  To get them \"back from the\nback\", you have to do a type of \"mental recall\" which can be triggered\nby thinking about something related to that fact.  So if you want to be\nsharp and fresh on any subject, including MVS topics, you have to do a\nlot of mental \"recalls\" to keep the data \"current\", \"in front of\nyour mind\" instead of \"in the back.\"\n\n      You can either be proactive, and consciously trigger the \"recalls\"\nyourself, or you can be more passive, and let the circumstances trigger\nthe recalls.  It all depends on how important you think the information\nis, and on how non-lazy you are.  In any case, it's good to know about\nthis stuff.  Heck, we have to use our minds to do this job!  It's nice\nto know a little more about how our own minds operate.\n\n      So I hope this month's piece has jogged your mind a wee bit.\nBest of everything to all of you!  And I hope to see you here again\nnext month.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0406JN": {"ttr": 26625, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x000\\x01\\x04\\x12\\x8f\\x01\\x04\\x13\\x1f\\x12X\\x01\\x02\\x01\\x02\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-05-07T00:00:00", "modifydate": "2004-05-10T12:58:30", "lines": 258, "newlines": 258, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           JUNE 2004\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.  The Online CBT Tape web site can be reached\nat www.cbttape.org .\n\n\nCBT TAPE NEW CONTRIBUTIONS\n\n      Every so often I like to report about new contributions to the\nfree MVS software collection called the CBT Tape.  It is now close to 30\nyears since Arnold Casinghino (then working at the Connecticut Bank and\nTrust Company in Hartford) started this collection.  Since the\nacquisition and dissolution of the original CBT bank, the letters \"CBT\",\nas we use them, mean nothing in particular, except to refer to this huge\nMVS software repository.  But the collection remains a freely available\nsource of useful stuff for all MVS systems programmers who are in need\nof goodies.  And who isn't?\n\n      The reason that it is not boring to report on new contributions to\nthis collection once in a while (we haven't done it here in over two\nyears) is that new material has been arriving at the average rate of 15\nto 20 file revisions per month, and I feel that after two years, it's\nworth informing people about what's going on.  Something we've got might\njust be something that you need.  Although the CBT Tape web site has its\nown URL, you can also get to it through NaSPA's web site.  And try doing\na www.google.com search on CBT Tape.\n\n      What is \"fair game\" for a CBT Tape contribution?  The answer is:\n\"anything that is useful for an MVS systems programmer\" whether it be a\ncomplete software program tool package or merely an idea.  We even have\na small, and very clever, collection of CLISTs by Eli Duttman (File 195)\nwhich includes a one-line CLIST containing the one word LOGOFF.  The\nCLIST is called X.  When you're in a hurry to get out of TSO, it's far\neasier to type X than to have to type LOGOFF and type it wrong three\ntimes.  As we said, anything that helps you is fair game.\n\n      On the other hand, the CBT Tape collection contains \"battle-wagon\nsized\" ready-made software packages like the PDS command package (File\n182) for manipulating all kinds of datasets, Fullscreen ZAP (File 134)\nfor seeing, finding, and changing any disk data, SHOWMVS (File 492) and\nMXI (Files 409 and 410) which are the ultimate MVS Auditor's tools, and\nREVIEW, an extremely powerful file browsing tool, which is now acquiring\nISPF-like TSO-based file editor capability.  All of these packages\ngreatly extend and expand the capabilities which IBM claims to give you.\nAnd they're for free!  You just have to discover them, download them,\ninstall them, and use them.  This is the ultimate MVS Toy Store!\n\n\nWHAT'S NEW?\n\n      Here's an idea that was inspired by a new CBT Tape contribution.\nIt may be applicable to a considerable number of shops, and I feel the\nidea is so important that it's worth mentioning first.\n\n      Suppose a company is considering getting rid of MVS because of the\nexpense.  But in reality, they really need the functionality and\ncapability of MVS, and they're only bothered by the cost.  The solution?\nDownsize MVS by getting a FLEX-ES system (or several of them) from\nFundamental Software.  Everybody will be happy.  Your company will be\nhappy because it hasn't lost much of its essential computing capability\nand power.  You (as the sysprog) will be happy because you haven't lost\nyour job, or your ability to work on an MVS system.  Fundamental\nSoftware (or one of its competitors) will be happy, because they now\nhave new business.  And the customers, users, and programmers for that\ninstallation will be happy, because systems will work well, and they\nwill not have to be converted.  IBM will be happy, because they won't\nhave lost an MVS customer.  This entire idea came from a CBT Tape\ncontribution.  I hope it helps a lot of people!\n\n      Now I'll continue, and just throw a lot of stuff at you.  We'll\nstart with the automation stuff, because there's been a lot of it, and\nwe'll go on from there.  I've personally tried some of this stuff, but\nobviously if there are three or four automation packages, I can't have\ntried all of them, so if you need some more console automation, at least\nyou have a choice, and you can explore these packages for yourselves.\n\n      For myself, I've preferred the old NETINIT package, as revised for\nOS/390 and z/OS by Joel Ewing, and which can be found on File 672 of the\nCBT Tape collection.  NETINIT is an old program, originally written in\nthe early 1980s, which issues timed and (optionally) monitored console\ncommands after VTAM has been initialized.  Its specifications probably\nwere part of the requirements asked of IBM, which resulted in the\nintroduction of IBM's VTAMAPPL program, and indeed, NETINIT seems to be\nfunctionally equivalent to VTAMAPPL.  The idea of programs of this type,\nis to delay the starting of tasks like TSO or TCAS, that are dependent\non VTAM being up.  So NETINIT or VTAMAPPL or another program of this\ntype, will wait for the IST020I message that VTAM has been initialized\ncompletely, and then they will start other tasks that may or may not\nbe dependent on VTAM.\n\n      NETINIT also has a separate \"system shutdown\" capability, so I've\nset it up as the NETSTOP proc to shut everything down until we just have\nRACF, TSO, VTAM and JES2 left.  But the NETSTOP capability can take the\nsystem down much further than that, and then stop VTAM itself.  I\npersonally prefer NETINIT to VTAMAPPL because I have more complete\ncontrol over it, and because it works on older MVS systems.  So at least\nyou have an alternative to VTAMAPPL if you need a substitute.\n\n      A related VTAM-dependent package is NETSOL on File 356, which has\nbeen updated by Dave Juraschek to work on z/OS.  Other console\nautomation packages, not VTAM-dependent, are:  AUTOMAN from Simon\nSpanchak (File 627), Sergey Makogonov's system for automated shutdown\nand system control on File 588, and Hunter Zhou's AUTOIPL package on\nFile 623.  As I've mentioned in a previous column (April 2003), the TSSO\nautomated operations package (File 404) has been updated, mostly by Ed\nJaffe, to now work for z/OS systems.  TSSO executes as an MVS subsystem,\nand it is a fully functional console automations package.  TSSO also\ndoes other unique things, like creating a genuine line-mode TSO\nenvironment for the MVS console, so if you want to rename a dataset from\nthe system console using the TSO RENAME command, or compress a pds\nwithout TSO using the line-mode PDS 8.5 IEBCOPY interface (the PDS\nCOMPRESS subcommand), you can do so when TSSO is installed.\n\n\nMORE NEW THINGS\n\n      Lionel Dyck's large contributions deserve special mention.  This\ncollection is so sizable that it takes up three CBT Tape files, Files\n312, 313 and 314.  The collection consists of many separate utility\npackages, most of which are written in REXX.  Because Lionel has\ncontributed so much stuff, I (as proprietor of the CBT Tape) made\nthe decision to separate it all into three files, by alphabetic order of\nthe member names, for want of an easier way to find things there.\nFile 312 contains members whose names begin with A-R.  File 313 contains\nmembers beginning with S-TS.  File 314 contains members beginning with\nTX-Z.\n\n      Lionel's first two packages were XMITIP, which allows MVS users\nto send emails directly from TSO, and FTPBATCH, which uses an ISPF\ninterface to set up batch FTP jobs that accomplish the transfer of\nfiles from MVS systems.  But Lionel has about 15 or 20 more packages of\nvarious sizes, to help make your work easier.  According to the scheme\nabove, XMITIP is in File 314.  FTPBATCH is in File 312.\n\n      It is worthy to mention something about the enormity of XMITIP.\nXMITIP itself, as it is shipped currently, contains in excess of 46000\ncard-images of material.  In addition, there are some other pieces that\nXMITIP uses.  Since XMITIP has to format emails, and emails can have\nmaterials in HTML, RTF (Rich Text Format), or Adobe PDF format, XMITIP\nalso includes separate packages to convert plain text into these\nformats.  These packages are called TXT2HTML, TXT2RTF, and TXT2PDF,\nrespectively.  All of the XMITIP materials are on File 314 of the CBT\nTape collection, because their member names coincidentally begin with\nthe letter TX or higher, which places them at the end of the alphabet.\nSo it comes out conveniently, that the XMITIP-related materials are\nfound on File 314.  XMITIP also has its own news group, called\nxmitip@yahoogroups.com .\n\n      Some of the smaller tools in Lionel's collection are also\nextremely useful.  I'll mention a few of them.  PLPISPF (Product Launch\nPoint) is a scheme to allow ISPF users to go into any ISPF application\nthey want, from any point in their ISPF session.  LSTPROC, which I use\nfrequently, is a REXX exec that looks up all libraries that are\navailable to JES2 as PROCs.  The result of invoking LSTPROC is an\nISRDDN display of all the PROCxx DD names in the active JES2 PROC.\nSince looking up the sequence of active PROCs on a JES2-based MVS system\nis normally quite tedious (you have to find the active JES2 PROC,\nusually in SYS1.PROCLIB, and then you have to search the libraries in\nthe PROCxx DD statements there, by hand), LSTPROC becomes an extremely\nconvenient lookup tool.  And you get the active version of each PROC\nname instantly.\n\n      Other miscellaneous tools in Lionel's collection are:  CAVXTRT, a\ntool to extract and print parts of CA-VIEW reports.  CMDS (Doug Adams'\nISPF Command Table handler).  COMPVTOC, a REXX to compare dataset names\non a VTOC to a catalog.  CSVEDIT, an ISPF Edit macro to convert a\ndataset or member into \"comma separated values\" so it can be imported\ninto a spreadsheet.  CUTPASTE, a set of ISPF CUT-PASTE edit macros.\nDDLIST, an ISPF command to display all datasets concatenated into a\ngiven ddname, and to optionally display all datasets containing a given\nmember name.  DOALL, a REXX exec to run a given ISPF edit macro against\nall members of a given pds.  PRMCK, an ISPF edit macro to verify the\nvalidity of certain PARMLIB member types, before you try them for real\nin a system IPL.  And there are many more such tools.\n\n      Now we'll leave Lionel's stuff and I'll say a few words about some\nother new tools.  Rob Scott's comprehensive MXI tool, which tells you\nmuch information about the internals of your running MVS system, has\nbeen enhanced some more.  Rob Scott is now employed by Rocket Software,\nwhich owns the rights to MXI, but they are committed to supplying the\npublic with a free version of MXI indefinitely.  Rob has been submitting\nall of the free enhancement levels to the CBT Tape.\n\n      Another bunch of wonderful MVS tools has been recently contributed\nby Hunter Guanghui Zhou.  Notable among Hunter's work is his automated\nIPL and System Shutdown (File 623 - see also Sergey Makogonov's File\n588 for a similar package that works differently),  SENDMAIL (File 638)\nwhich can send emails and attachments from OS/390 and z/OS systems,\nSETHOUR (File 639) which can do everything at once, to let your system\nknow about Daylight Savings time changes, including an edit of your\nactive CLOCKxx PARMLIB member for TIMEZONE,  OFFLOAD (File 668), which\ncan copy JES2 spool outputs to plain sequential datasets, and his TCP/IP\nNPF exits (File 621), which allow pc network printers to print MVS\noutputs, even though there is only pure TCP/IP, without any SNA\ngateways, or postscript support features on the printer.\n\n      There have been many more recent changes to the CBT Tape\ncollection than just these.  If you'd like me to write another column\nspecifically dedicated to describing them, please email me.  But now\nI'll tell you what you can do, to discover them for yourself.\n\n\nWHERE YOU CAN LOOK THIS UP YOURSELF\n\n      The general documentation file for the CBT Tape materials is File\n001, which can be downloaded from the CBT web site.  If you do a FIND\nwhen browsing this documentation, for strings like 'V-465 SECTION' or\n'V-464 SECTION' and so forth (descendingly), you'll find all the changes\nto the CBT collection which occurred at those stated version levels.  As\nof this writing, the current CBT Tape version is Version 465.  So if\nyou're reading this article at a later time, there will be more \"change\nsections\" ahead of the 'V-465 SECTION' on File 001, which will show the\nspecific file updates for each CBT Tape version that came later.\n\n      Additionally, there's something else you can do.  You can break\nFile 001 into a partitioned dataset, using my CBTUPD assembler program\non File 006, to get the changes at each version level separately, as\nseparate pds members.  Using this general method, you can easily check\nor print out the updates on several of the previous tape versions.  For\nmyself, I find it very handy to have CBT Tape File 001 broken up into\nthis pds.  Once you've set up the procedure, you can quickly do it for\neach new CBT Tape version.\n\n      If you're on the CBT Tape web site, there's something quick that\nyou can do, to see the new files which are from one step back.  When you\nget into the CBT Tape web site, and you look at the CBT Tape files in\ngeneral, you have the option to list all NEW files, which will only tell\nyou the files that have changed in the current version, but this will\nnot list the changes in previous versions.  So the best way to find\nrecent tape changes over several versions, is to download File 001 and\nsearch the version change sections for yourself.\n\n\nCONCLUSION\n\n      We are very grateful that the CBT Tape collection of MVS tools is\na growing and changing body of knowledge.  It certainly pays, every so\noften, to keep track of the changes that have been going on.  I've\nfrequently received an email about some MVS question, and several days\nbefore, a contributor had sent me some new package which solved that\nvery person's problem.  This has happened so much, maybe a couple of\ndozen times already, that I feel I should mention that it pays to write\nme, or to take a fresh look at the CBT Tape web site to see what's\navailable now.\n\n      I wish you all the very best of everything, and hope to see you\nhere again next month.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0407JL": {"ttr": 26630, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00#\\x01\\x04\\x15\\x8f\\x01\\x04\\x15\\x8f\\x12W\\x00\\xeb\\x00\\xeb\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-06-06T00:00:00", "modifydate": "2004-06-06T12:57:23", "lines": 235, "newlines": 235, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           JULY 2004\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.  The Online CBT Tape web site can be reached\nat www.cbttape.org .\n\n\nMEASURING AND ACCESSING TAPE DATA\n\n      One of the hidden resources of a data center is its tape data.\nI'm referring to tape data as being \"hidden\", because people don't think\nof tape data as being readily accessible.  In order to look at tape\ndata, people think that you have to copy it over to something else, such\nas disk, or print some of it out.  It is not easy to \"read a tape\ndirectly\" without copying the contents.  The \"conventional wisdom\" about\ntapes is, that \"we know the data is there somewhere, just in case,\" but\nwe have absolutely no idea how to find it, or search out WHAT is there,\nfrom the tapes themselves.\n\n      Today, I'm going to talk about how to reveal more of what is\nhidden on tapes.  This is an underdeveloped area of MVS knowledge, and\nI'll tell you one of the reasons why I think that is so.  According to\nmy speculation, the IBM MVS development people were always nervous about\nletting people find out about what was on a tape.  The reason is\nsecurity.  In RACF, as well as with the other popular security products,\nit is easier to \"secure\" a data file than to \"secure\" a tape volume.  A\ntape volume can contain all kinds of mixed data, and one tape can\ncontain many diverse files.  If you can make a \"xerox copy\" of an entire\ntape and take it off site, then you might gain improper access to some\ndata that doesn't belong to you.  There isn't enough granularity to\ndistinguish what you should see, from what you shouldn't.  On the other\nhand, if all of your data access is limited to \"file access,\" then it is\neasier for the installation to control \"who\" has access to \"what\" data.\n\n      So it follows from this line of thought, that IBM has never given\nthe MVS world a simple tool to copy entire tapes on the volume level, as\nopposed to the file level.  The one exception to this, is if you are\nmigrating all your tapes to an automated tape library.  Then such tools\nhave been made available, because since the output tapes would reside in\nan enclosed tape library and would never leave the installation anyway,\nexcept possibly for disaster recovery purposes, there isn't much danger\nof an employee carrying out an unauthorized copy of a \"company tape\" for\nhimself.\n\n      Nevertheless, tape data is, consciously or unconsciously, still\nregarded as \"hidden\" by most people.  Although I am aware of the\nsecurity considerations mentioned above, I don't think this is entirely\na good thing.  Much time is often wasted in a shop, looking for data\nthat the company has on a tape somewhere, and the people don't know how\nto find it.  People feel that one can't \"search and browse\" for the tape\ndata they need.  Most often, they give up trying, and I think that's\noften unnecessary and a pity.  Something ought to be done about this\nsituation.\n\n\nTHE ART OF MAPPING A TAPE\n\n      I would define the process of \"mapping a tape\" as that of\ndiscovering the contents of a tape which you previously knew nothing\nabout.  There are tools for this.  Conceptually, it's a simple idea.\nTapes are sequential.  If they are \"Standard Labeled\" or SL, then the\ndata files are sandwiched on either side by \"tape label\" files, which\ncontain much useful information about the file contents, such as the\ndataset name, file characteristics, blocking, creating jobname and\nstepname, creation date, and so forth.  So if you can merely print out\nand neatly format most of the fields in the tape labels for each file on\nthe tape, you have already made a lot of headway in discovering \"what\"\nis on the tape.\n\n      That is fine for Standard Labeled tapes, which have descriptive\nlabels, but what about Non-Labeled (NL) tapes, which don't have label\nfiles sandwiching all the data?  In that case, a \"tape mapping\"\nprogram would have to read the tape data files themselves, and would\nhave to draw conclusions from what it \"saw\" on them.  There do exist\nuseful tools for doing this also, as we shall see.\n\n      Why do I call the process of mapping a tape, an \"art\"?  Because\nthere exist many free tools, as well as IBM's DITTO product, which do\nvarious aspects of this job.  But no one single tool will show you\neverything you want to know about a particular tape.  For example, if\nyou want to know about the data that is on each tape file, but you don't\nwant to see ALL of it, because that would be too much output, then you\nhave a choice.  You could dump a few records for each tape file, using\nIBM's DITTO, but the problem is that DITTO will only dump an ENTIRE tape\nblock, and you might not want to see all 32000 bytes of it, if it is\nthat large.  Another choice of tool would be the TAPESCAN program from\nCBT Tape File 102, which automatically hex dumps the first 100 bytes of\nthe first n blocks of each tape file, where n=4 by default, and n is\noverrideable.  In a particular case, that might be the wiser choice of\ntool.  TAPESCAN also formats and displays the contents of the tape\nlabels, if they exist.  For a similar purpose, you can use the free\nCOPYMODS program from File 229 of the CBT Tape, using a SYSIN parm of\nREAD, LABELS, HEXPRT, and PRINTRCDS=nnn, to print the first 132 bytes of\nthe first nnn blocks of each file on the tape, as well as the label\ncontents.  So that is why I call mapping a tape, an \"art.\"  It takes\nknowledge and experience with the tools, to make the correct choice for\nwhat you want to do.\n\n      So if mapping a tape is an \"art\", you have to become the \"artist\".\nIt pays to familiarize yourself with as many tape mapping tools as\npossible, as well as to become somewhat knowledgeable about the various\nfields of information in the tape labels of SL tapes.  This knowledge\nwill help you pick the proper tool to find out the particular\ninformation about a tape that you happen to need.\n\n      The information about data in the tape labels, may be found in the\nIBM manual, \"DFSMS: Using Magnetic Tapes\" (SC26-7412).  If you are\nlicensed to use IBM's DITTO product, you should learn about its tape\nfunctions.  But the free tape mapping tools, in my opinion, sometimes do\nthe job a lot better than DITTO does.\n\n      Many of the free tape mapping tools can be found in the huge \"CBT\nTape\" collection of free MVS tools.  You can do a www.google.com search\non CBT Tape to find out how to get these tape mapping tools.  Notable\ntape mapping tools from the CBT Tape collection are TAPEMAP from File\n299, TAPESCAN from File 102, COPYMODS (a tape copying program which can\nbe run in READ only mode) on File 229,  TCOPY from File 193, SS0104 from\nFile 266, and Leonard Woren's version of TAPEMAP, which you can get from\nLeonard's web site at www.ldworen.net.  Each of these programs is\ndifferent from the others, and each reports its outputs differently, but\nthe idea behind all of them, is pretty much the same.\n\n\nWHAT DOES A TAPE MAPPING PROGRAM DO?\n\n      A tape mapping program reads the data blocks and tape marks (the\nfile separator marks) on a tape, and interprets their contents.  The way\nin which a tape mapping program reports what it \"sees\" depends on the\ninformation that the programmer wanted it to report.  This information\ngenerally breaks down into two categories:  tape label reporting, and\nphysical scanning of the tape blocks.\n\n      The TAPEMAP program from File 299, and Leonard Woren's (different)\nversion of it, generally do the both of these jobs best.  So I would\nrecommend them most highly, if you need one program that finds out what\nis on a tape.  TAPEMAP has two output DD names, SYSPRINT and SYSPRNT2.\nThe SYSPRINT DD name contains tape label information gleaned from the\ntape labels (if any), and also the block information obtained by reading\nand scanning the data blocks on the tape.  But in addition, TAPEMAP can\nfigure out, in many cases, which program dumped the contents of each\ntape file.  For example, if IEBCOPY dumped a pds, TAPEMAP will tell you\nso.  The CBT Tape File 299 version of TAPEMAP will tell you if FDR or\nFDRDSF created that tape file.  There are many other formats supported\nby the CBT File 299 version of TAPEMAP, such as SMPPTFIN and IEBUPDTE.\nIf TAPEMAP has encountered a tape file in one of its recognized formats,\nthe chances are that the SYSPRNT2 DD name will report the details.\n\n      For example, if a tape file was created by an IEBCOPY dump of a\npds, then the SYSPRNT2 DD name will display the names of the members of\nthat pds.  If the tape file was created as an FDR dump, then the\nSYSPRNT2 DD name will display the dataset names on the volume that was\ndumped.  If the input tape file is in SMPPTFIN format, then the CBT File\n299 version of TAPEMAP will display the PTF, APAR, or USERMOD numbers in\nthe file.  This is extremely useful information that you can't easily\nfind out with other tape mapping programs.  That is why I think that the\nTAPEMAP program is often more useful than other tape mapping programs,\nand it is probably the first program you should try when you want to\nfind out what is on an unknown tape.\n\n      I think the second program you should try, is the TAPESCAN program\nfrom File 102 of the CBT collection.  TAPESCAN will hex dump the first\n100 bytes of the first few blocks on each tape file, and it will also\nformat most of the tape label information for you.  So if TAPEMAP will\nnot tell you enough detail about what is on a tape, often TAPESCAN will\ntell you more.\n\n      The third program I would try, is my version of the COPYMODS\nprogram, from File 229 of the CBT Tape.  My version of COPYMODS can be\nrun in READ only mode, to scan the contents of a tape, as well as in its\nnormal mode, to create \"xerox\" copies of an entire tape from end to\nend.  My version of COPYMODS can be made to show byte counts for all the\ntape files, and to separate the byte counts in the label files from the\nbyte counts in the data files (the CUMSEP option).  I think that anyone\nwho wants to do serious tape work, should learn the details and many\noptions which are found in my version of the COPYMODS program.  But the\nfirst two programs, TAPEMAP and TAPESCAN, are easier to use by default,\nand they should be your first choice in getting started with tape\nmapping programs.\n\n      A fourth choice in mapping a tape might be the old SS0104 program\nfrom Florida Power, which is on CBT Tape File 266, and which I recently\nfixed up.  SS0104 will figure out footages for each tape file, as if the\ntape were a 6250 bpi tape reel.  These footages give us a standard way\nof roughly determining how much data is on a tape.  I have recently\nimported the SS0104 footage calculation code into COPYMODS also (option\nFOOTAGE in COPYMODS Level 076), so you can now also find out this\ninformation for a tape, using COPYMODS.  COPYMODS contains many advanced\nfeatures to do all kinds of exotic tape manipulation, so if you're\nserious about improving your tape skills, you should spend some serious\ntime learning to use COPYMODS.\n\n       A fifth choice, TCOPY, in its LIST mode, will report maximum and\nminimum physical block sizes in each tape file.  Most of the other tape\nmapping programs won't report that information.  TCOPY is on File 193 of\nthe CBT Tape collection.\n\n\nLIMITATIONS IN THE CURRENT TECHNOLOGY\n\n       Tape files are still not as accessible to us as disk files.  In\norder to change what is on a tape, you either have to make a copy of the\ntape, or write it to disk and change the disk file.  In order to SEE\nwhat is on a tape physically, the REVIEW program from File 134 can be\nrigged up for that purpose, and if your tape happens to reside on an\nautomated tape library or a virtual tape library, the response when you\nREVIEW a tape file can be very fast.  So it pays for you to look into\nthe free REVIEW program, and to learn how to exploit REVIEW to look\ndirectly at the contents of a tape.  IBM's DITTO program can also be\nused to browse the contents of tape files, but I think that REVIEW is\nprobably better suited for the purpose.  It depends on your individual\npreference.\n\nCONCLUDSION\n\n       I feel that an MVS systems programmer must have the skill to\nlook at a completely unknown tape, and be able to discover what is on\nit.  Before I used to install any vendor's product on my system, I\nwould always TAPEMAP their installation tape, and I would never take\ntheir word at face value, without also investigating on my own.  This\nskill should also be used to help you find archived information in your\ncompany's tape library, when that job needs to be done.  In any\ninstallation, a person who has the skills to explore completely unknown\ntapes, is a valuable corporate asset.\n\n       I wish you all the best of everything, and I hope to see you\nhere again, next month.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0408AU": {"ttr": 26635, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00G\\x01\\x04\\x18\\x8f\\x01\\x04\\x18\\x8f\\x11\\x19\\x01\\x10\\x01\\x10\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-07-06T00:00:00", "modifydate": "2004-07-06T11:19:47", "lines": 272, "newlines": 272, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          AUGUST 2004\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.  The Online CBT Tape web site can be reached\nat www.cbttape.org .\n\n\nANATOMY OF AN MVS BATTLEWAGON\n\n      During World War II, one of the most feared naval vessels was the\nbig Battleship.  The Battleship was the closest thing to being a\nfloating army--it was as big as a medium sized city, and its\nversatility, in the kinds of weapons it could bring to bear in almost\nany situation, was almost unparalleled.  Proper use of the Battleship\nin the war, would lead in large part, to mastery and control of the\nseas.  One of these huge Battleships, for whatever reason, was usually\nreferred to in the Military very affectionately, as a \"Battlewagon.\"\n\n      In MVS, we have a class of tools which are like the \"naval\nbattlewagons.\"  They are the great tool packages, which contain a large\nnumber of options, parms, or subcommands.  One of these tools will be\nable to perform a large variety of different operations and functions.\nSuch \"MVS Battlewagons\" come in two categories:  There are commercial\ntools like Omegamon from Candle Corp, and Resolve from BMC Software, and\nDP Technician from Data Processing Techniques, among many others.  And\nthen there are the free \"multi-talented\" tools that are available to\neveryone, such as REVIEW from Greg Price (CBT Tape File 134), the PDS\nprogram package (CBT Tape File 182) written largely by Bruce Leland and\nSteve Smith, and which is currently being maintained by John Kalinich,\nand the free MXI product (CBT Files 409 and 410) from Rob Scott at\nRocket Software, among many others.  Many of these fantastic free\nproducts can be obtained from the CBT Tape collection on the web.  Do a\ngoogle search on \"CBT Tape\".\n\n      Today, we'll talk about the kind of mentality that goes into\ndeveloping a \"one tool does it all\" kind of tool package.  And just as\nimportantly, we'll make some recommendations for the users of such\na package, as to how (and why) to become an expert in using the many\nfunctions that it contains.\n\n\nWHY ONE TOOL AND NOT MANY?\n\n      We might ask the obvious question, as to why a developer would\nwant to create one single tool that has many options and choices, as\nopposed to a collection of many specialized \"single function\" tools that\nare separate programs from each other.  (I personally have created one\nlarge package of each type, so I have some insight into this.)  I think\nthere are several reasonable answers.  The principal motivation to begin\ncreating what will eventually become an \"MVS Battlewagon\" might be\ntermed \"accessibility to an MVS component.\"  For a program to gain this\naccessibility, the programming task is often quite non-trivial.\n\n      For example, the free PDS program package begins its operation by\nOPENing a partitioned or a sequential dataset, and setting up an\nenvironment.  Once the PDS program has gained access to that dataset and\nhas set up its working environment, you have a very large choice of\nmanipulations which you can do, like adding more pds directory blocks,\nchanging the attributes of one or more load modules, editing a pds\nmember, and so forth.  But the idea here, is that the same coding has\nprovided your basic access to the dataset, and once we have the access\nand the special environment, now we can \"do something.\"  It's a pity and\na waste to repeat the (sometimes very complicated) coding which gave you\nthis initial access.\n\n      A second reason for developing a multi-function package is\nactually an consequence of \"accessibility.\"  To see what I mean, you can\nput it like this:  \"The first thing you do is to get into the building.\nOnce there, you can start exploring its rooms.\"  Each particular\nbuilding has different rooms and a different layout than other buildings\nhave.  In two different buildings, there are many completely different\nareas to explore.  And each area of exploration is intrinsically tied up\nto that building's particular architecture and layout.\n\n      So similarly, each multi-function package has usually gained\naccess to a component of the MVS operating system or its data.  Once\nthere, the creator(s) of the package feel(s) motivated to \"make the\nmost\" of this exposure to that environment.  One asks questions like:\n\"I have access to the innards of a pds.  What would be useful for me to\nbe able to do?\"  Or, \"I am reading or copying a tape.  I have access to\nevery byte that is on it.  How is this useful to me and what functions\ncan I make easy, which previously were hard?\"  Or, \"I know how to access\na large variety of MVS control blocks.  How can I make that information\nreadily available?  Which control block fields can I usefully display,\nand which, if any, can I safely alter?\"\n\n      An essential additional ingredient in creating a multi-function\ntool package is to have written a fairly simple mechanism to add new\noptions to the package.  If such a mechanism is already in place, then\nthe tool package will tend to keep growing, because the program\nstructure makes it easy to add new stuff.\n`\n      For example, in my COPYMODS tape copying program, which is rapidly\nbecoming an MVS Battlewagon in the area of tape copying, tape reading,\nand tape measuring, I have invented a table-driven parse engine, that\nconverts PARM or SYSIN keywords into option bit settings.  Thus, the\nCOPYMODS program can easily use these bit settings to control its\nvarious features.  As of this writing, I have already used up 45 option\nbits out of a possible 80.  (See CBT Tape File 540 for this parser as a\nseparate entity, and see the COPYMODS program on CBT File 229 for this\nparser in its practical use.)  The free PDS program (CBT Tape File 182)\non the other hand, is a TSO command, so it has a big PARSE CSECT, which\nprovides PDS with a fairly easy mechanism to add new keywords using\nIBM's IKJPARS facility.  In fact, all of the big MVS tool packages\nalready have some easy and standard way to add a new feature in, without\ntoo much additional effort on the part of the programmer.\n\n      Now comes the question of why such a big tool package will tend to\ngrow even further.  What motivates the growth?  What kind of force will\ncause the programmer(s) to want to include some new features?\n\n      We can begin answering this in several ways.  First, user demand\nhas always been a traditional driver in the further development of MVS\nfunctionality.  IBM itself is mostly driven by customer demand, when\ndeveloping new features of MVS.  And the tool developers, who pick up\nwhere IBM left off, do pretty much the same thing, too.  There is a\nsmall twist on this when it comes to free MVS software.  Somebody who is\nwriting a commercial product ultimately wants to make money.  But\nsomeone who is doing the development for free, will sometimes include a\nfeature in the product simply for completeness, or \"because it is\nthere,\" or \"because he can.\"  So a \"Free MVS Battlewagon\" might\nsometimes become better than a commercial product, actually because\nmoney doesn't enter into it.  However money is a great motivator too,\nand a commercial developer always wants to create a good and reliable\nproduct, that is well supported, and is fit to sell.\n\n\nILLUSTRATIONS AND EXAMPLES\n\n      Now I'll show you a concrete case of how a package can start\nexpanding and growing in many directions.  Let's take a quick look at\nthe REVIEW TSO command processor program, from File 134 of the CBT Tape\ncollection.\n\n      The original REVIEW TSO command, found on the CBT Tape, was\nwritten by Bill Godfrey around 1980 as a handy, but limited-use, full\nscreen file browser.  REVIEW had an enormous advantage, in that it does\nnot need ISPF to function.  REVIEW can run under raw TSO in READY mode.\n\n      Let's get a glimpse at REVIEW from its beginning to the present.\nIn the beginning, REVIEW could only browse a sequential file.  A member\nof a pds had to be expressly specified.  You couldn't display a pds\ndirectory under REVIEW, and pick out a member to look at.  REVIEW could\nalways look at load modules as well as FB and VB files.  But originally\nas written by Bill Godfrey, its width range was only until 1080 bytes.\nIf the load module you were browsing was wider, the old REVIEW would\nstop looking when it got to 1080 bytes.  In the mid-80s, I was tempted\nto expand the capabilities of REVIEW myself, but I never did so.  Then,\nin 1990, Greg Price from Australia submitted his highly souped-up\nversion of REVIEW to the CBT Tape, and Greg has been improving on the\ncode ever since.  The original REVIEW program from Bill Godfrey was\naround 4000 lines of code.  Greg Price's current version (38.0) contains\nwell upwards of 40000 lines of code, and it now even contains a file\neditor that is not unlike ISPF's editor.  A full 32760 byte width is, of\ncourse, present in the current REVIEW version.  PDS member lists can be\ndisplayed.  And of course, VSAM and HFS files can be browsed with the\nnew REVIEW too.  REVIEW's fantastic facility to look at (and format)\nSMF files, is world-famous.  And you can REVIEW files on tape.\n\n      I don't have the space here to go through all the iterations of\nGreg's improvements to REVIEW since 1981, but you can see them in the\nREVIEW source code on CBT Tape File 134.  REVIEW has all the elements\nthat are present in an MVS Battlewagon, though.  It is easy to add new\noptions, and if you're working with a dataset browser, there are many\nnew capabilities that you can dream up, using your own imagination and\nother people's suggestions.  REVIEW is definitely a fertile plant that\ngrows in MVS Battlewagon territory.\n\n      The PDS command package from CBT File 182 is an MVS Battlewagon,\npar excellence!  In 1987 and 1988, I must have spent over 400 hours on\nthe phone talking to (authors) Bruce Leland and Steve Smith, discussing\nhow to use all the 50-or-so subcommand options that were (then) found in\ntheir version of the PDS commnand utility package from File 182 of the\nCBT Tape.  The result was a series of tutorial magazine articles in 1988\nthat was published in \"Technical Support\" magazine.  These can be found\nin CBT File 182 as members $PDSARTn, n=0,1,2,3.  I had been privy to\nseeing a considerable part of PDS's development, and its growth had\nfollowed a typical Battlewagon pattern.  Bruce Leland kept incorporating\ncode from other free pds-managing utilities into the PDS package as new\noptions, and Bruce also wrote many other original new utility functions.\nSteve Smith did the ISPF part.  Steve invented the multi-purpose member\nlist, long before IBM (in ISPF) or SPIFFY (from ISOGON) made them.  The\nPDS product grew and grew.  Over the years, I can safely say that I\nmyself contributed nearly 200 suggestions for PDS product improvement,\nwhich were actually incorporated into both the free product, and its\nvendor-supported successor (from Serena).\n\n      I'll conclude with my own experience, by contrasting my tape\ncopying package called COPYMODS (from CBT File 229) with my\nSYS1.BRODCAST manager set of utilities on CBT File 247.  COPYMODS has\nbecome a full-fledged Battlewagon, with at least 45 options, as it is\ncurrently coded.  On the other hand, my SYS1.BRODCAST manager package\nconsists entirely of separate programs, with only Vinh Vu's magnificent\nISPF interface, to unify them.  Why the difference?\n\n\nONE BATTLEWAGON VERSUS A COLLECTION OF PROGRAMS\n\n      I think the main reason why my SYS1.BRODCAST manager utilities\ndidn't become a battlewagon, was the lack of unity with the\nSYS1.BRODCAST file access and the command parsing.  I had found it\neasier to put separate functionality into separate programs because:\nFirst, some of the mechanisms of file access were different in the\ndifferent program functions.  Second, to me the programs were easier to\ntest, when they were separate entities, and third, it was hard to make a\nuniform parsing mechanism that would encompass all of the functionality\nrequired, and it would still work in a simple way.  In short, the\nSYS1.BRODCAST manager stuff just didn't lend itself easily to a unified\nprocessing framework.\n\n      However, I did foresee that some of the separate programs should\nbe unified by an ISPF platform (a \"shell\", so to speak) that would make\nthem work together.  After my own attempt to create such a platform, I\nsaw that my friend Vinh Vu, who is a whiz at that stuff, would be able\nto create a far better ISPF environment than I could.  Vinh's package\n(which is the BCMISPF member oF CBT File 247) shows a table of all TSO\nusers with undelivered messages, and gives you the option of displaying\nthem, printing them, or deleting all or some of them.  So the\nmulti-utility functionality is not provided in one program, but rather\nin the ISPF dialog that calls some of the separate programs.  Others of\nthe programs (BCMSCAN, BCMCLEAN, BCMXPORT, BCMDUMP, BCMREST, and\nBCMXPAND) are designed to be run in batch.  And still others (BCMUSADD,\nBCMUSDEL) are special purpose TSO commands, which are front ends for the\nTSO macro service called IKJIFRIF, that adds or deletes single userids\nfrom the SYS1.BRODCAST dataset.  So in the case of this package, it\nseemed to me that a better idea than having one program to \"do it all\",\nwould be to have a shell that calls some of the separate programs.  Vinh\nVu has created that, and I am very satisfied with the result, because it\nis easy to use.\n\n      On the other hand, the COPYMODS program lends itself far better to\nthe \"battlewagon concept\".  Tape copying is one process.  You read the\ntape blocks into a data buffer, and you write them out to output tapes\nfrom that buffer.  While that one process is being done, all of the tape\nblocks and tape marks are passing before your eyes, so you can exercise\na wide variety of options to determine how you want to change them in\nthe copied tapes, or simply if you want a \"read only\" run.  As you read\nthe input tape, you can format or process any, or all, of the tape label\nfields as you see fit.  I have already dreamt up 45 separate options to\nrun, to vary the controls, and I have more of them on my wish list.\n\n      So when there's one process of file access (i.e. \"accessiblity\" as\nwe mentioned before) and there are a lot of different things you may\nwant to do once you've achieved that access, then that situation lends\nitself very well to the battlewagon concept.  But if the various\nfunctions required, call for too much difference in the way they are\ncarried out, it is probably better to unify the functionaity in some\nother way.\n\n\nCONCLUSION\n\n      I hope that after reading this article, you resolve to learn more\nabout some of the multi-function utility packages you already use, and\nthat you'll start to try and use at least one new package that is freely\navailalble.  I can guarantee that all the effort you put in this\ndirection, will be promptly paid back in satisfaction and saved time.\nIt is granted that you'll have to be \"burdened\" to learn (possibly many)\nnew keyword controls, but that effort will be paid back to you by a\nquality high-powered \"battlewagon\" product.\n\n      All the best of everything to all of you, and I hope to see you\nhere again next month.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0409SE": {"ttr": 26885, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x04\"?\\x01\\x04\"?\\tE\\x01\\x11\\x01\\x11\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-08-10T00:00:00", "modifydate": "2004-08-10T09:45:00", "lines": 273, "newlines": 273, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         SEPTMBER 2004\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.  The Online CBT Tape web site can be reached\nat www.cbttape.org .\n\n\nADMINISTERING SYS1.BRODCAST\n\n      Today I'd like to talk about a frequently neglected part of the\nMVS operating system, which need be neglected no more.  This is the part\nof the system which IBM designed (many long years ago) to convey\nmessages between programmers using TSO, and which is now mostly used to\ntell the programmer how well a job has executed.  I'm referring to the\nbroadcast facility of MVS.  The broadcast facility uses a dataset called\nSYS1.BRODCAST.  (The first A has been left out to get its name down to 8\ncharacters.)  SYS1.BRODCAST technically \"belongs\" to TSO, but it is a\nnecessary part of MVS itself.\n\n      You can't have an MVS operating system which doesn't contain the\nSYS1.BRODCAST dataset.  As necessary as SYS1.BRODCAST seems to be, IBM\ncertainly hasn't provided any normal and convenient set of tools for the\nsystem administrator to use in taking care of it.  I can supply a few\nexcuses for IBM's neglect in that regard, but I've also \"put my money\nwhere my mouth is\" and I've written many of these tools that will fill\nthe void which IBM has left.  If you set up and use these tools, which\ndon't cost a penny, then just about all of the administration problems\nregarding SYS1.BRODCAST will be gotten rid of.\n\n      Before telling you about my tools, we have to know something about\nhow SYS1.BRODCAST works, and how IBM's commands, SEND and LISTBC, as\nwell as the ACCOUNT and SYNC administrator commands, interact with it.\nSYS1.BRODCAST is a Direct Access dataset (DSORG=DA) whose records\n(KEYLEN=1,LRECL=129) are accessed by means of a relative record number\nof 6 hex digits, which starts with (hex) 000000.  SYS1.BRODCAST\ncurrently has six (really seven) different types of records.  Each type\nhas its own purpose and its own layout.  The macros describing all the\nSYS1.BRODCAST record types have now (finally) been placed in SYS1.MACLIB\ninstead of in the Optional Materials, and they have names IKJZT301 thru\nIKJZT306.\n\n      Two TSO commands access SYS1.BRODCAST on a regular basis.  They\nare:  SEND, which writes messages to SYS1.BRODCAST, and LISTBC, which\nreads messages from SYS1.BRODCAST, and which (in the case of user\nmessages) deletes them after they have been read.  The SEND and LISTBC\ncommands have to be APF authorized, because they are usually invoked on\nbehalf of TSO users who don't have write access to the SYS1.BRODCAST\ndataset.  LISTBC is automatically invoked by TSO every time you LOGON.\nThat's why you see your notification messages at LOGON time.\n\n      For your information, enqueues on the SYS1.BRODCAST dataset have a\nQNAME of SYSIKJBC, and an RNAME of the hexadecimal 6-digit relative\nrecord number that is being accessed.  An ENQ is usually also placed on\nthe header record of SYS1.BRODCAST, whose relative record address is\n000000, so the RNAME for header record access is X'000000'.  This extra\nENQ is done to \"lock up\" the header record in any case.  That's because\nmost programs which access SYS1.BRODCAST, have to start by looking up\ninformation that is stored in the header record.\n\n      There are two basic types of broadcast messages which are stored\nand forwarded by means of the SYS1.BRODCAST dataset.  These are:  global\nnotification messages, and user messages.  Global notification messages\ngo out to all TSO users whenever they LOGON (and the LISTBC program is\nautomatically invoked).  These are the messages which the system\nadministrators put out, such as:  \"System A will be down all next\nTuesday.  Please only use System B on Tuesday.\"  These are the messages\nwhich all users have to see.  And then there are the user messages which\ngo only to one userid.  If one TSO user issues a SEND command to send a\nmessage to another TSO user, then (if TSO userlogs are not in effect, or\nif the particular user doesn't have a userlog allocated, and if the user\nisn't currently logged on) that message is stored as a user message in\nSYS1.BRODCAST.  When a job, which had NOTIFY=userid coded in the JOB\ncard, finishes, then a SEND command is also issued by the system, to\nnotify the TSO user mentioned, that the job has finished.  These\n\"NOTIFY\" messages are the most frequently found user messages on MVS\nsystems nowadays.\n\n      Since SYS1.BRODCAST is a Direct Access dataset, it has a fixed\nnumber of \"slots\" for records, and therefore it can fill up.  When\nSYS1.BRODCAST fills up, TSO users who are not logged on, cannot receive\nmessages unless TSO userlogs are in effect and they have a TSO userlog.\nMany MVS systems operate with SYS1.BRODCAST completely filled up.\nThat's because IBM doesn't give you a good way to administer its\ncontents.  This doesn't have to happen.  WE HAVE THE TOOLS!\n\n      When SYS1.BRODCAST fills up and the user whose messages have\nfilled it up, does not LOGON (for example, if he has left the company),\nthen IBM has provided only one solution to delete THAT USER's messages:\nWipe out EVERYBODY's messages, no matter how important they may be.  IBM\nallows the administrator to do this, with the ACCOUNT and SYNC commands.\nThese commands check which users are defined both to SYS1.UADS and the\nsecurity system, and the SYNC command then completely initializes\nSYS1.BRODCAST so it is completely blank.  Talk about blowing up the\nbarn to kill a skunk that's inside it!\n\n      On File 247 of the CBT Tape collection, which is free to everyone,\nthere is a very capable package of SYS1.BRODCAST administration tools.\nThese tools are collectively called the \"Broadcast Manager\" package, and\nas I've said, they are free.  Using the package's BCMISPF interface,\nwhich takes 5 minutes to set up for each MVS instance in your shop, you\ncan:  List, Print and Delete all outstanding messages for any user.  And\nalso, you can even List, Print or Delete only SOME of the messages and\nleave the rest, for any user, even if it is not you.  NO OTHER PACKAGE\ncurrently gives you this power in SYS1.BRODCAST, and there is plenty\nmore besides that, which you can do.  Here are some further examples.\n\n      You can create a copy of SYS1.BRODCAST which contains your old\nmessages after an ACCOUNT SYNC of the real SYS1.BRODCAST has wiped them\nout.  And you can List, Print, and Delete (all or some) messages from\nthe copy as well.  In addition, the BCMSEND command allows you to write\nnew messages to either SYS1.BRODCAST itself, or to the copy.  If this\nhas aroused your curiosity, please read on, and I'll show you some more\nof the wonders contained in the \"Broadcast Manager\" package from CBT\nTape File 247.\n\n\nBASIC SETUP OF THE BCM PACKAGE\n\n      To find out about the CBT Tape collection of software, do a\nwww.google.com search for \"CBT Tape\".  Then follow your nose.  The\nBroadcast Manager package is on File 247 of the CBT collection, and\nonce you've created its partitioned dataset on your MVS system, you're\nready to start.  For quick setup, there is a LOADMODS member, which is\nreally an XMIT-unloaded load library containing all the relevant load\nmodules.  Just do a TSO RECEIVE INDS(this.pds(member)) and create the\nload library.  Then copy all the members to a load library which your\nTSO session can get to.  You won't need APF authorization, except to run\nthe BCMDEL and BCMDEL1 programs, because they temporarily change the\nuserid and then invoke LISTBC.  But since you'll probably be running\nBCMDEL2 to delete messages, and BCMDEL2 accesses the SYS1.BRODCAST\ndataset directly, no authorization is required.  If you want to assemble\nyour own modules, see sample JCL members $$BCMASM and/or $ASMSING.  And\nalso, your TSO id should have at least UPDATE or ALTER access to the\nSYS1.BRODCAST dataset.  This eliminates the amateurs, and doesn't let\nthem play.\n\n      Once you have access to the load modules, you'll want to set up\nthe BCMISPF interface (written by Vinh Vu), which takes about two\nminutes.  First either create the ISPF materials pds by running job\n$LOADSPF, or by doing a TSO RECEIVE INDS(file247.pds(BCMISPF)).  Copy\nthe BCMUTIL member of that pds to a CLIST or REXX library (SYSPROC or\nSYSEXEC concatenation) and the rest of the members to an ISPF panel\nlibrary (ISPPLIB).  Then from TSO, just execute TSO BCMUTIL, and you\nshould be ready to go.  A panel showing all users with outstanding\nSYS1.BRODCAST messages will appear.  You just type an S (to display) D\n(to delete) or P (to print) next to any user whose messages you want to\ndeal with.  The SKIP(mm) and MSGS(nn) keywords will always allow you to\nskip the first mm messages and then display, print, or delete the next\nnn messages.\n\n\nADVANCED FACILITIES OF THE BCM PACKAGE\n\n      The BCM (Broadcast Manager) package is a very complete set of\nutilities for dealing with the \"user message\" part of SYS1.BRODCAST, and\nfor dealing with the SYS1.BRODCAST dataset as a whole.  For example, the\nBCMDUMP program allows you to create an FB-130 sequential dataset from\nSYS1.BRODCAST, including everything in it, and you can send that dataset\nanywhere--you can even zip it or unzip it.  Then, with programs BCMREST\n(restore the backup to the old size) or BCMEXPND (which allows you to\nmake it bigger and add more user records), you can create a new copy of\nSYS1.BRODCAST from this FB-130 (non-DA) backup, which can be used later,\nas a new version of SYS1.BRODCAST on the system.  The BCMSEND TSO\ncommand can send new user messages to the copy, or to the original\nSYS1.BRODCAST dataset.  And the BCMLIST and BCMDEL2 programs can list or\ndelete (respectively) user messages from either the original\nSYS1.BRODCAST, or from a copy.  The BCMUTIL REXX exec also has the\ncapacity to access both the working SYS1.BRODCAST dataset or a copy.\n\n      You can control which SYS1.BRODCAST format dataset is addressed\nby any of the BCM**** programs, by allocating the BRODCAST DD name to\neither SYS1.BRODCAST or to a copy of it.  The BCMSEND TSO command will\nsend messages to either SYS1.BRODCAST or to a copy, in this way.  Also,\nsince BCMSEND (unlike IBM's SEND) command, does not use IBM's IKJPARS\nTSO command parser, but it takes all characters that are one space after\nthe TSO userid, you can send characters to SYS1.BRODCAST messages that\nare not \"legal\" by TSO standards.  So you can make messages out of hex\ncharacters and be very creative, if you want to be.\n\n      The BCMUSADD and BCMUSDEL TSO commands use IBM's IKJIFRIF\ninterface to the \"userid\" records of SYS1.BRODCAST, to either add, or\ndelete, a new userid from SYS1.BRODCAST (or from a copy).  This has\nnothing to do with RACF or UADS.  You can add a phony id like XXXXXX.\nWhen you add the new userid to SYS1.BRODCAST in this way, you can then\nSEND messages to that \"userid\" or use the NOTIFY=XXXXXX keyword in a job\ncard, and the messages will go into the chain of messages that are\nconnected to userid XXXXXX in SYS1.BRODCAST, even if that userid does\nnot exist anywhere else on the system.  This is a \"SYS1.BRODCAST\" thing,\nonly.  Of course, you'll need the BCM package to display or delete\nuserid XXXXXX's messages too, but the BCMUTIL interface will do it.  Of\ncourse, you'll want to do this carefully, so that SYS1.BRODCAST won't\nget filled up with your new id's messages.\n\n      A practical use for this type of thing would be if you want to\ntrack a job for a couple of days.  Just do a BCMUSADD for XXXXXX, and\nsend NOTIFY=XXXXXX messages to the runs of that job.  Use the BCMUTIL\ninterface to track the resulting messages for as long as you need them.\nThen, after you don't need the id anymore, just BCMUSDEL XXXXXX and all\nof the messages for that userid on SYS1.BRODCAST will be cleared out, in\naddition to the userid itself being cleared out.  Of course, when you\nrun IBM's ACCOUNT and SYNC against SYS1.BRODCAST, all the new id's\nyou've created in this way will be cleaned out, because SYNC checks all\nuserids against both SYS1.UADS and the RACF (or other security system)\ndatabase, and SYS1.BRODCAST userid records for only valid userids will\nbe created.\n\n      Most of the BCM package's functionality deals with the \"user\nmessages\" part of SYS1.BRODCAST.  But there is some \"global\nnotification\" message support there, too.  The BCEDIT REXX, and the\nother BCED*** REXX members in File 247 were supplied by Paul Lemons, and\nthey allow you to ISPF EDIT your \"global notification\" messages from\nSYS1.BRODCAST and replace them with new ones.  To do this, you need TSO\nCONSOLE authority, so you'll have to get at least READ access to the\nTSOAUTH CONSOLE resource from RACF for your TSO userid.  But as an\nadministrator, you should be able to get permission for this access.\n\n      In the area of the \"global notification\" messages in\nSYS1.BRODCAST, I've made one attempt to write a program that displays\nthese notification messages, and that is the TSO command, BCMNLIST.  In\nthe future, I hope to possibly create my own \"notification message\"\ndelete and send commands, but I haven't done so as yet.  Creating such\ncommands would allow me to write and delete notification messages to a\ncopy of SYS1.BRODCAST, as well as to SYS1.BRODCAST itself.\n\n      There is another little thing that I've done in the SYS1.BRODCAST\narea.  That is my program called BCMCLEAN.  If you've ever browsed your\nSYS1.BRODCAST dataset, it might seem full of messages, even though a\nprogram like BCMSCAN, or the BCMUTIL package says that it is practically\nempty.  That is because when LISTBC deletes a user broadcast message,\nit doesn't wipe out all the message text.  When LISTBC deletes a user\nmessage, it only changes the first two bytes of it.  The first byte of\nthe message, the \"key\" byte, has to be X'FF' for a \"deleted message\".\nBut there's also another condition.  For a user message in SYS1.BRODCAST\nto be considered \"deleted\", the first data byte (the one after the key)\nhas to equal the \"R\" (record number on the track) of the CCHHR or TTR\nrecord location on DASD.  Therefore, LISTBC just sets the first byte of\nthe message record to X'FF' and the second byte to the R of the CCHHR.\nThe rest of the message is still there, and if you're browsing, it looks\nas if there's a real message in that slot.\n\n      So the function of BCMCLEAN is to go through all the user messages\nin SYS1.BRODCAST and find the ones that are actually deleted messages.\nThen BCMCLEAN replaces the text part of the old message with hex zeroes.\nThis makes it easier to spot deleted messages in SYS1.BRODCAST if you\nare BROWSE-ing it with ISPF (not a good practice, because you lose the\nlast byte) or you're REVIEW-ing it with the REVIEW TSO command from\nCBT Tape File 134.  REVIEW shows the key byte and data bytes clearly,\nand it differentiates between them.\n\n\nCONCLUSION\n\n      This month, I've tried to open your eyes to a (usually) very\nneglected part of MVS administration, taking care of the SYS1.BRODCAST\ndataset.  This subject actually has many fine points, as I've tried to\neither show directly, or hint at indirectly.  The \"broadcast manager\"\nadministration package from CBT Tape File 247, which is free, will\ngreatly help you clean out garbage messages in SYS1.BRODCAST, and will\nactually make it possible to manage and administer SYS1.BRODCAST\neffectively.\n\n      Best of luck to all of you, and I'm hoping to see you here again\nnext month.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0410OC": {"ttr": 26890, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00@\\x01\\x04%\\x1f\\x01\\x04&?\\x14H\\x01\\x07\\x01\\x05\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-09-07T00:00:00", "modifydate": "2004-09-19T14:48:40", "lines": 263, "newlines": 261, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          OCTOBER 2004\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.  The Online CBT Tape web site can be reached\nat www.cbttape.org .\n\n\nWORK AND PLAY\n\n      Many of us have heard the expression:  \"All work and no play\nmakes Johnny a dull boy.\"  Believe it or not, this concept has a lot to\ndo with MVS systems programming too.  One might wonder how?  After all,\nsystems programming IS work.  But during my years of working in this\nfield, I've discovered that there is a method of creating a happy\nmedium between \"work at work\" and \"play at work\".  The way IBM has\nconstructed the MVS operating system, makes this possible.  And the\nresult is that if you exploit this situation correctly, you'll increase\nyour productivity immensely, and not only that--it'll make the work\nvery much more fun to do!\n\n      IBM really created this scenario themselves.  In the design of\nOS/360 and its descendants, IBM themselves never did the full job of\nsupplying tools.  Of course the operating system itself was completely\nfunctional, but many gaps were left, probably because IBM didn't want to\nallocate programmer time for them, and much of the utility development\nwas left to the customers, and later, to the vendors.  In fact, at one\ntime, the job of systems programming actually required a lot of\nprogramming in Assembler Language.  Different sites would make\nmodifications to the operating system according to their individual\nneeds.  JES2 is a prime example, where modifications were the rule\nrather than the exception.  For example, the user-created free spool\nbrowsing tool called QUEUE, actually predated IBM's equivalent offering,\nSDSF, by a few years.\n\n      Many of these modifications ended up residing in large free\ncollections of MVS tools, because in order to sell software written for\nMVS, you usually need a whole marketing setup.  Most of the program\nauthors, who are sysprogs working for companies that aren't interested\nin selling software, can't afford to buy their own machine and do their\nown development and marketing to sell their creations.  Furthermore, the\ncompanies which employ these \"sysprog-authors\", usually don't mind if\ntheir system-level software is given out for public use.  Again, the\ncompanies which own the machines, usually aren't in the business of\nselling MVS system software.  So IBM itself is largely responsible for\nmaking this environment what it has become, because IBM tacitly\nencourages MVS software writing by making most of the various system\ninterfaces publicly available.  One of the largest collections of free\nMVS software tools is the enormous \"CBT MVS Utilities Tape\" collection,\nwhich is now also on the web.  On www.google.com, search with the words\n\"CBT Tape\".\n\n      So where does the \"playing\" come in?  \"Playing\" (in our sense)\nmeans trying to create or use new tools, especially some of the free\nuser-written tools from the CBT MVS Utilities Tape, or from the free\nsection of www.xephon.com.  I'll give one example (among many hundreds)\nto illustrate this point.  Suppose that you are the SMP/E person who\nlooks at the IBM monthly maintenance tapes as they come into your shop.\nIf you just RECEIVE the maintenance as it comes in, you're doing the\n\"work\" involved in the job.  But if you go to File 118 of the free CBT\ncollection of MVS tools, and you try out the two SMP/E pre-processing\nprograms PUTXREF and SMPUPD which are there, you'll then get a\ncompletely different insight and analysis of the IBM maintenance.  And\nyou'll take much more control of the maintenance process in your shop.\nIt may not seem to make much of a difference to do this, but if there's\na \"situation\" where you need to carefully select PTFs, the impact can be\nmajor.\n\n      What does the PUTXREF program do?  In summary, it shows which\nFUNCTION each PTF, APAR, or USERMOD belongs to.  And what does the\nSMPUPD program do?  It breaks a (possibly very large) sequential PTF\ndataset (in \"SMPPTFIN format\") into a pds, with the individual PTFs,\nAPARs, or USERMODs as the members.  Once you know what these basic\nfunctions of PUTXREF and SMPUPD are, I can show you more details about\nwhat they can do, and how they can profoundly affect the way you run the\nmaintenance of your shop.  Ultimately and hopefully, you'll get to see\nsome of the enormous additional power over the maintenance processes,\nwhich this puts into your hands.  And that power comes directly from our\nkind of \"playing\".\n\n\nPUTXREF and SMPUPD\n\n      Let's see how to \"play\" with the PUTXREF program first.  The idea\nof PUTXREF is to find out which FMIDs your PTFs in a PTF tape belong to.\nI once received a maintenance tape from IBM (long ago) which didn't\ncontain stuff for all the FMIDs it was advertised to contain, so I\nwanted a way to check up on them, and found half of the job already\ndone.  This was Jerry Lawson's PUTXREF program.  I added more\nfunctionality to it.  The outputs to this processing are now in 3\ndifferent formats.  The PRINTER DD points to an FBA-133 report, that\nlists an FMID and then all the PTFs, APARs, or USERMODs that belong to\nit.  The SMPCOUT DD points to an FB-80 sequential dataset that contains\na list of each SYSMOD belonging to each FMID, with the different FMID's\nPTFs being separated by ./ ADD NAME=fmidnam   IEBUPDTE-type control\ncards.  This allows you to do a de facto APPLY SELECT for one FMID at a\ntime, and feed an SMP/E APPLY CHECK job with everything belonging to\nonly one or a few specific FMIDs.  I used to use this processing with\nSMP4 after SMP/E came out, to achieve a FORFMID effect that was not yet\nbuilt into SMP4.  (The Hercules people running MVS 3.8 can still take\nadvantage of this.)\n\n      Finally, the PDSATOUT DD name gives the output in the form of PDS\n8.5 ATTRIBUTE commands to add or change ISPF stats of a pds member that\ndidn't have any stats.  You use this output by pointing the free PDS 8.5\ncommand at your SMPPTS dataset, and you add ISPF stats in batch, to the\nPTF pds members, with the owning FMID as the \"userid\", using these\npre-generated ATTRIBUTE subcommand cards.  Pretty cool!  Then you can\nlook at your SMPPTS dataset with ISPF and see at a glance, which PTFs\nyou have, that belong to a certain FMID.  Since pds members with ISPF\nstats take up more directory space than those without stats, you\nprobably will have to add more directory space to the SMPPTS dataset on\nthe fly, using the PDS 8.5 subcommand:  FIXPDS EXPANDDIR(nnn), to add\nnnn more directory blocks.  This is very nice \"playing.\"  If you think\nabout it, you'll see that you're no longer at the mercy of SMP/E RECEIVE\nprocessing, to choose what maintenance will go onto your system.\n\n      I invented the SMPUPD program because I wanted to BROWSE a\nparticular PTF from a tape.  If I would IEBGENER an SMPPTFIN file from a\ntape, into a big sequential dataset on disk, I found out that BROWSE,\nwhich uses BSAM reads, took forever to find the PTF number I was looking\nfor.  So I wrote the SMPUPD program to put ./ ADD NAME=ptfnumb cards\ninto the copied stream, right ahead of each new PTF.  And then, I run\nIEBUPDTE against the copied stream, and load up a pds with the\nindividual PTFs as separate members.  This made it easy to look at each\nPTF individually.\n\n      SMPUPD can be run with PARM=READ, and its report lists each PTF\nnumber on the SMPPTFIN file (say \"tape\" for simplicity), together with\nhow many lines of code each PTF (read SYSMOD) contains.  So you can also\nuse SMPUPD to find out if a particular PTF number resides on a certain\ntape.\n\n      So what's my point in telling you all this?  The idea is that if\nyou find some extra tools to \"play\" with, your \"work\" will be much more\naccurate, satisfying, and fun.  (Of course, it's assumed that you like\ndoing sysprogging.)  Someone who only does things the \"vanilla IBM way\"\nis not only missing out on a good time, but he or she is also losing a\ngood measure of control over the system maintenance process.\n\n\nLEARNING HOW TO PLAY\n\n      The obvious question now is:  \"How do I start learning to play?\"\nAnd if I already know how to play a little bit, how do I learn how to\nplay better?  My answer is:  \"It depends what you're working on.\"\n\n      I'd suggest that while you're working on whatever is currently\nkeeping you busy, you should take a few minutes out, and look at the CBT\nTape directory to see if you can find some tool(s) that relate to your\ncurrent task.  Then download them from the web site, install them (if\nthey look like they'd help you) and try them out.  You might search the\nXephon web site (www.xephon.com) and look for tools there also.  Don't\nstop your regular work and just do this.  Rather, allocate a small\nportion of your workday for \"experimenting\".  If you do this on a fairly\nregular basis, you'll soon find that you can get all of your work done\nsooner, and you'll even have more time left over for more experimenting.\nYou have to remember that your main job is what they're paying you for.\nThe \"playing\" is only for the purpose of making shorter work of what you\nhave to do.  Done correctly, it becomes a \"win-win\" situation, and your\nemployer will gain, as well as you.\n\n\nWRITING YOUR OWN STUFF\n\n      Sometimes if you're trying to solve a problem more quickly, you\nmight feel that the best way is to write your own tool to do it more\nefficiently.  If you're good at REXX or Assembler language, this may be\na productive direction to take.  In former years, I used to do it in\nCOBOL too.  But I found that since COBOL needs a run-time library, and\nthe \"newer COBOLs\" had different syntax rules than the \"old COBOL\", the\nCOBOL tools of mine became difficult to maintain.  So in the end, I\nconverted them all to Assembler and was much happier with them.\n\n      Many of us have written our own stuff, over the years.  It pays to\nsave it, for several reasons.  First, you won't have to invent the wheel\na second time, when you encounter the same problem over again.  Second,\nsomebody else might have the same problem in a different shop, and if\nyou share your tool on a public tool collection (like the CBT Tape),\neach person can benefit from other people's work.  If you have some\ntools to share, you can email them to me, because I'm the proprietor of\nthe CBT Tape collection, and I can put them there so they can be used by\nmany people, hopefully for a long time to come.\n\n      I almost never consider a tool \"too trivial\" to archive.  If it\nsaves work, then it doesn't matter if it's intrinsically simple.  IBM\ndoesn't give you everything you need, in the way of tools for MVS.  We\nall need extra help.  And if one very simple mechanism will save you a\nlot of time, I feel it's worth shouting about.  So I accept all kinds of\ntools, both simple and complicated, for the CBT Tape collection.  If\nthey work, then they are \"good\" for me and you.\n\n      That said, let me give you a few pointers.  Before you start\nwriting, first do a thorough search of both the CBT Tape and Xephon\nstuff, to see if someone solved the same problem before, and wrote a `\ntool that you could use.  If you're searching for a tool and you don't\nknow if one exists, you can post a message on one of the news groups\nsuch as IBM-Main, or RACF-L or any of the others.  These lists are\nmonitored by many experts and if a tool is there, they'll most likely\npoint you to it.  Also, once a discussion has started on one of the news\ngroups about a tool, it may come out that someone has written just what\nyou need, but until now they haven't sent it in to the CBT Tape or to\nsomewhere else that is searchable.  So as a result of your question, the\ntool will get sent to me so we can archive it on the CBT Tape and make\nit available.  When all these paths get exhausted, then you can start\nwriting, unless it is in REXX and it is a simple process to carry out.\n\n\nSAVING YOUR STUFF\n\n      I'm a big believer in saving machine-readable copies of all the\nsoftware I've written, provided that it doesn't conflict with the\npolicies of an employer (say, a software company).  If the stuff is\npotentially publicly distributable, or even it I feel I'd like to use\nit someplace else, at a later time, I try to archive it so I won't\nhave to reinvent the wheel twelve more times.\n\n      You should know that it is now possible to save your tapes on\ncd-roms or dvd-rom disks.  You can use any MVS system to read your\nphysical tape into my VTT2DISK program from File 533 of the CBT Tape\ncollection, and convert it into an FB-80 folded AWS-format tape stream\nthat can be FTP'ed to a pc and archived on a cd-rom or dvd-rom.  Then at\na later time, you can move the AWS-format file onto another MVS system\nand have FTP or IND$FILE fold it over into an FB-80 format file.  This\nfile can then be used as input to my VTT2TAPE program from CBT File 533,\nand a real tape can be cut from that AWS-format file.\n\n      At the CBT Tape web site most of the materials are stored as\nzipped XMIT-format pds'es.  By unzipping each file, uploading to an MVS\nsystem in BINARY, and running the TSO/E RECEIVE command:\nRECEIVE INDS(your.FB80.XMI)   against it, you can re-create the pds\nexactly as it existed before, even with the ISPF statistics for source\nand even for a load module pds.  This judicious use of the TSO/E XMIT\ncommand to preserve pds'es, now has become a standard technique to save\nyour stuff.  The required syntax of the XMIT (or TRANSMIT) TSO command\nis: XMIT node.userid DSN(your.dataset) OUTDSN(your.FB80.XMI)  The output\ndataset is FB-80 sequential, and you can zip it, unzip it, upload it,\ndownload it, or send it anywhere very easily.  This format makes\narchiving your own work for later use, extremely easy.\n\n\nCONCLUSION\n\n      IBM has never pretended to have written a \"complete set of tools\"\nthat will manage every part of an MVS system.  But IBM has provided many\nof the primitives and interfaces for us (and vendors) to write our own\nsets of tools.  There are collections of user-written tools such as the\nCBT Tape collection and Xephon's collection which are freely available\nto everyone, and it pays to spend a certain amount of time \"playing\naround\" with these tools to make the rest of our work easier.  In most\ncases, the time spent \"playing\" is more than made up by time saved\nbecause you're using this \"new equipment.\"\n\n      I wish all of you the best of everything, and I'm looking forward\nto seeing you here again next month.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0411NV": {"ttr": 27140, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01\\x04(O\\x01\\x04(O\\x10S\\x01\\x11\\x01\\x11\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-10-10T00:00:00", "modifydate": "2004-10-10T10:53:32", "lines": 273, "newlines": 273, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         NOVEMBER 2004\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.  The Online CBT Tape web site can be reached\nat www.cbttape.org .\n\n\nPDS and PDSE\n\n      Today I want to talk about the partitioned dataset (called a \"pds\"\nfor short) in MVS, which is one of the principal ways of storing data in\nan MVS system besides VSAM.  Both source code and executable load\nmodules, as well as most \"flat data\", can be stored in pds'es.  In the\ncourse of many years of MVS's existence, people found things \"wrong\"\nwith the pds structure, and in 1988 or so, someone wrote a white paper\nfor SHARE, outlining all of these \"defects\" that the pds supposedly (and\nactually) had.  IBM then addressed the \"problems\" outlined in the SHARE\npds white paper and came up with a new structure, known as the PDSE,\nwhich supposedly solved all those problems.  The PDSE actually has a lot\nof its own problems, which IBM has been spending the last 17 or so MVS\nreleases, working out.\n\n      Let's begin our discussion by looking at some of the nitty\ngritty details of the partitioned dataset's structure.\n\n      MVS has just about always had this \"library\" dataset known as the\n\"partitioned dataset\" or pds.  The pds structure consists of a\n\"directory\" at the beginning, which is a keyed fixed unblocked structure\nhaving a key length of 8, and a data length of 256 bytes in addition.\nThe pds directory points to units of sequential data, starting after the\nend of the directory and known as \"members\".  Members follow each other\nand have end-of-file markers in between.  DCB attributes of the data\nportion of a pds are exactly like the DCB attributes of sequential\ndatasets.  This is the \"data\" portion of the partitioned dataset.  And\nthe overall DCB attributes of the pds are those of the data portion,\nnot those of the directory portion.  As we said, the data is organized\ninto \"members\", and the beginning TTR of each member is pointed to by a\ndirectory entry.  Thus we have a library-type structure with a lot of\ndata members grouped into one dataset structure.  Locations within the\npds are referred to by relative TTR (track-record) locations starting\nfrom the beginning of the dataset.\n\n      Now that we've got the basic idea of what's happening in a pds,\n(you may have to re-read the previous paragraph several times), we can\ntalk about what's good and what's bad.  I'm assuming that all of you\nhave worked in this field and have some practical experience with\npds'es, so you'll understand what I'm saying.\n\n      The first fact we need to mention is that when a pds is updated\nwith a modified \"member\", the space taken up by the previous version of\nthat member is not reused, but the modified member is written after the\nend of the last member in the pds, and the directory entry referring to\nits member name, is re-pointed from the previous member location TTR to\nthe modified member location TTR.  So that leaves the space occupied by\nthe previous version of the member as \"dead space\" in the pds, which is\nnot pointed to by any directory member at all.  This dead space stays\naround, until a process called \"compression\" is done, usually using the\nIBM utility IEBCOPY.  So one of the \"defects\" of a pds is that it is\nusually bigger than it has to be, due to the need for periodic\ncompression.\n\n      The SHARE white paper referred to the need for compression in a\npds as a \"defect\".  However, with the proper utilities, it can be an\nadvantage.  For example, when you \"delete\" a member of a pds, all you\nare really doing is wiping out the directory entry that points to that\nmember name.  The member's data actually remains there, though, as we\nmentioned.  So it's logical that if you write a utility which will\nconstruct a new directory entry, and point it to the old data, you can\n\"restore\" the original pds member after it has been deleted.  Of course,\nyou wouldn't be able to do this after the pds has been compressed and\nthe old member data was wiped out by the compression process.\n\n      Now since IBM itself hasn't supplied MVS users with a utility that\nrestores a deleted pds member, all this sounds theoretical.  But MVS\nsysprogs have written such utilities, which are freely available, and\nusing these utilities, pds members can be easily restored.  IBM, not\nwishing to \"officially\" recognize the existence of any of these free\nutilities, considered the need for pds compression a \"fault\", but to a\nuser who has the free PDS 8.5 package installed (CBT Tape File 182), and\nwho can use its RESTORE subcommand to restore deleted members, it isn't\na fault, but it's actually an advantage and a safety net if you make a\nmistake with a member and you need the old version again.  So it all\ndepends on your point of view, whether the need for pds compression is\nor is not a fault.\n\n      Another pds \"defect\" that's worthy of mention, is what happens\nwhen the directory is too small, and is full, and you want to add more\nmembers to the pds.  According to IBM, who hasn't supplied a utility\nwhich expands a pds directory, you have to make a new pds with a larger\ndirectory, copy the data members from the old pds to the new pds, and\ndelete the old pds, all of which requires ALTER RACF authority and which\nis a great inconvenience.  But if you are using the formerly mentioned\nfree PDS 8.5 utility from the CBT Tape, all you have to do is to use its\nFIXPDS EXPANDDIR(nnn) subcommand, where nnn is the number of directory\nblocks you want to add.  Then, PDS 8.5 will move some members from the\nbeginning of the data part of the pds to the end, and will reformat the\nacquired space into the required number of new empty directory blocks.\nThe pds does not have to be re-created by this process, and all you need\nfrom RACF, is UPDATE authority.  It's much easier, and under those\ncircumstances, I wouldn't call the need to add directory blocks a real\n\"defect\" (although IBM would).\n\n\nIBM's IMPLEMENTATION OF THE PDSE\n\n      IBM went to a lot of trouble to create a new structure, called a\nPDSE, that supposedly solved all the pds \"problems\" (to be taken with a\ngrain of salt, as we mentioned).  Yes, the new PDSE doesn't have to be\ncompressed; deleted space is automatically reused.  Yes, the directory\nin the PDSE expands as more directory blocks are needed.  Yes, the fixed\nunblocked keyed directory structure has been changed, and access time is\nnot so slow.  (Although I have noticed that IEBCOPY member copying is\nmuch slower.)  All of this has been done, but at a very big price.\n\n      The price is that PDSE's have to be managed by external services.\nIf the PDSE is not on a SMS-managed disk pack, or if two extra address\nspaces don't happen to be up, PDSE services are dead in the water.  The\nPDSE datasets are simply not usable.  That's a VERY LARGE defect.  On\nthe other hand, normal pds'es don't require anything extra, other than\nbasic MVS capabilities, to be accessible.  Only the data itself needs to\nbe accessed.  No \"extra services\" are involved.  So the \"old-style\"\npds'es are \"always there\", while the PDSE's may not be.\n\n      That's what IBM has been spending 17 MVS releases (so far) trying\nto fix up.  My personal solution is to use old pds'es everywhere, unless\nI simply can't avoid a PDSE that someone else has created.  And then I\ntry to convert the data back to a pds if I can.  I think that's a safer\npolicy.  And I can also get access to the data in that pds, even when I\nneed to run an older release of MVS for some reason.  Sometimes I'm at\na site where I have to do that.  IBM's current level of PDSE support\nis really good, only from z/OS Release 1.2 and later.\n\n      So I think (even at this late point in time) that if I put my data\nin a pds instead of a PDSE, it's simply safer.  The exceptions are only\nif a PDSE is unavoidable.  That's my own personal (but flexible) opinion\nfor now.  But to be truthful and balanced, I have to add another\nstatement.  And that is, when IBM does something, you have to pay close\nattention.  Remember when they set their mind to make PC's in the early\n1980's?  IBM's plan eventually took over and dominated the entire world\nof personal computing, and since they used Microsoft to develop their\noperating system for their PC's, they singlehandedly made Microsoft into\nthe enormous giant it is today.  So you can never take IBM's plans\nlightly, and they have put PDSEs into their plans.  So we are forced to\nconsider PDSEs to be \"the wave of the future\", and we must spend time\nlearning as much as possible about them.\n\n\nHOW TO LEARN ABOUT PDSEs\n\n      Now that we know that PDSEs are here to stay, and we have to\nlearn about them, I am pleased to mention that the IBM Redbook people\nhave created a wonderful piece of \"one-stop shopping\" for learning very\nmuch about PDSEs.  This is the IBM Redbook, number SG24-6106, called\n\"Partitioned Data Set Extended (PDSE) Usage Guide\".  You can download\nthis book in PDF format from www.ibm.com/redbooks.  When you point to\nz/OS books and do a search on this book number, this manual should come\nup for viewing and download.\n\n      I've included Figure 1 to show you just a bit about the immense\ncoverage of PDSEs in this Redbook.  Space considerations have prevented\nme from printing the chapter details here also.  I encourage you very\nmuch to download, print, and read this book from IBM.  I don't think\nI can do a better job telling you about PDSEs than this book does.\n\n\nEXTRA TOOLS YOU CAN USE\n\n      But here's where I can give you a lot of information that IBM\ncan't (and of course won't) tell you.  That is, I can show you how to\ntap into the large pool of user-written tools which will make the old\npds'es easier to use, and which will eliminate 80 to 90 percent of the\ndownside of the old pds'es, as mentioned in the SHARE white paper.\n\n      These tools can be found in the free CBT MVS Utilities Tape\ncollection that is accessible online.  Just do a www.google.com search\non CBT Tape.  There are thousands of free MVS software tools in the\nCBT Tape collection.\n\n      The first place to look, to obtain first-class partitioned dataset\nutility service, is CBT Tape File 182, which houses the multi-purpose\n\"PDS 8.5 command utility package\".  The PDS command package is currently\nbeing maintained by John Kalinich, but it was largely developed by Bruce\nLeland and Steve Smith in former years.  The PDS command package is\ncapable of doing over 1000 separate utility functions with partitioned\ndatasets, but among many other things, the PDS command package can\nexpand the number of directory blocks in a pds \"on the fly\" as I've\nmentioned before.  Also, the PDS command was the first package to offer\nmulti-purpose (partial and) complete pds member lists under ISPF, when\nit runs in \"ISPF mode\" as opposed to \"raw TSO mode\".  The PDS command\nalso does character scans and replacements for subgroups of pds members,\nwith \"write in place\".  In other words, when PDS scans members for\nstrings and replaces them with other strings, it does not create deleted\nmembers, but it rewrites the affected data blocks \"in place\".  The PDS\ncommand does so many other useful functions to the old-style pds'es and\na few for PDSEs, that if you know how to use it well, you won't miss\nhaving PDSEs at all, in all likelihood.  The PDS package can RESTORE\ndeleted members too.\n\n      I think that the PDS command package from File 182 of the CBT Tape\nis the first place to look for extra leverage in dealing with old-style\npds'es.  But also check out File 036 from Bob Weinstein, which can\nrestore deleted pds members by looking at them backwards, from the\nhighest TTR that points to a deleted member, and back.  Each deleted\nmember, when found, is ISPF browsed for your examination.  Then you\ndecide whether to restore it or not.  CBT File 316 contains a large\nnumber of batch utility tools, but the PDSGAS program is a batch utility\nwhich will also restore deleted pds members.  However, the PDS command\npackage (which can also be run under TSO-in-batch), I think, does a\nbetter job, because PDS can also restore deleted load modules and allow\nthe restoration of their old attributes, if you know what they had been.\n\n      Anyway, I'd highly recommend installing the PDS 8.5 command\npackage, and I'd also recommend looking at the CBT Tape doc file, File\n001, to see what other tools you can discover.  The CDSCB authorized TSO\ncommand from CBT File 300, can (zap the VTOC to) change dataset\nattributes in general, in a very foolproof way.  For example, if the\nsecondary allocation amount is too small, and a dataset is in danger of\nrunning up to 16 extents, you use CDSCB to change the secondary\nallocation amount, so enough anticipated space is made available in the\nextents remaining.  The PDS command also is good for stopping a dataset\nfrom overflowing 16 extents.  Using the FIXPDS ADDTRK(nnn) or FIXPDS\nADDCYL(nnn) subcommands, you can preallocate additional single extents\nto the dataset, of any specified size, one at a time.  I think that by\nnow, you're getting the idea that there are a lot of good pds utilites\nout there for the taking, in the CBT collection.\n\n      So, to conclude our discussion for this month, the idea is that\nfrom IBM's point of view, PDSEs are the way to go.  That's because IBM\ncan't officially recognize the extra user-written pds utilities which\nanswer the SHARE white paper's objections to the old pds structure.  But\nI say that if you have the proper extra tools, even vendor tools like\nFileAid or the equivalent, then the old pds'es can last you a much\nlonger time.  And I personally prefer the old pds'es to the PDSEs.\n\n      Have a nice month.  I hope to see all of you here again next time.\n\n\n *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   Chapter Headings of the PDSE Usage Guide Redbook\n            SG24-6106.  This is one-stop shopping for PDSE\n            knowledge.\n\n            The following outline of chapter headings illustrates\n            the immense value of this IBM Redbook in learning\n            about how and when to use PDSEs.  The coverage of PDSE\n            \"knowhow\" in this book is very thorough and detailed.\n\n\n            Chapter 1.  Introduction\n            Chapter 2.  Using PDSEs\n            Chapter 3.  Program management and PDSEs\n            Chapter 4.  PDSE sharing and serialization\n            Chapter 5.  Performance considerations\n            Chapter 6.  Migration\n            Chapter 7.  Managing PDSEs\n            Chapter 8.  PDSE diagnosis\n            Appendix A. Software requirements\n              A.1       Base PDSE support\n              A.2       Extended sharing support\n              A.3       Program object support\n              A.4       Non-SMS PDSE support\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0412DE": {"ttr": 27145, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x17\\x01\\x041/\\x01\\x041/\\x11S\\x00\\xe2\\x00\\xe2\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-11-07T00:00:00", "modifydate": "2004-11-07T11:53:17", "lines": 226, "newlines": 226, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         DECEMBER 2004\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.  The Online CBT Tape web site can be reached\nat www.cbttape.org .\n\n\nIDEAS\n\n      We systems programmers have to be creative people.  It is a\nrequirement of the job.  When you're setting up an MVS system or you're\nfixing a problem with the system, you have to be logical, methodical,\nneat, and clever.  If somebody isn't one of these, it'll lead to a\nproblem in all likelihood, because an MVS system has parts which all\nhave to be set up correctly, not interfere with each other, and work\ntogether with each other.  Arrangements of datasets on disk packs also\nmust be carefully considered, and dataset placement has to be planned so\nthere won't be production problems later, with contention and such.\n\n      So during a typical day on the job, you're usually called upon to\nresolve a sequence of (possibly unrelated) problems, each of which\nrequires careful thought.  And sometimes you're stuck.  Where do you\npull ideas from, which will get you unstuck?\n\n      Usually it's from experience.  After years on the job, you've\nprobably seen 90 percent of the problems before.  In the simple cases,\nthe error messages lead to a certain MVS component, and there's more or\nless a \"yellow brick road\" to follow, which leads to an answer.  But not\nalways.  Timing problems, in particular, are very difficult to address.\nAnd sometimes an error message from one component is merely triggered by\na problem in a completely different component, and it takes a lot of\ndigging to get to the bottom of it.\n\n      Nevertheless, I have never forgotten what I was told on the very\nfirst day of my first systems programming job.  And that is, that if\nthere is a problem, look up the error messages.  See what the book (the\nIBM manual) says.  Then go from there.  In most of the cases, the error\nmessages will point out what direction to go in, to eventually solve the\nproblem.\n\n      It also helps to have some knowledgeable friends in the business,\nbut not necessarily somebody working at the same shop.  There's an\nadvantage to calling someone at a different shop who is your friend.\nMainly, you don't \"look bad\" to your friend when you can't solve\nsomething.  The truth is, that EVERYBODY can't solve something\nsometimes.  No matter how \"good\" you are in this business, sometimes the\nsolution to a given problem will elude you.  So it's actually no \"shame\"\nto be stuck once in a while.  However, within a shop, there can\nsometimes be rivalries between the staff, and pecking orders.  If you\ncall someone outside, there's no temptation to do that silly sort of\nstuff, because you're both not trying to impress the same boss.  And\nyou'll get your problems solved without any unnecessary emotional junk\nmixed into it.  Therefore it's good to have at least one knowledgeable\nfriend who works outside.\n\n\nBUT WHAT IF YOU'RE REALLY STUCK?\n\n      I'm just grappling with a situation, as I write, where I'll\nprobably have to draw a solution from my own experience outside the\nsystems programming field.  Once in a while, you can get an idea from\nwhat someone said on a news program, or in an old movie that you've\nrecently watched on DVD, or from some experience that you acquired in a\nprevious job, before you ever thought of working in the computer field.\nOne thing which life has taught me:  \"You should never throw out\nanything that you have ever learned or seen.  It might come back to help\nyou someday, often in some unexpected way.  BTW, you should always trust\nthat your many experiences won't fill your mind up.  You have enough\nmental capacity to keep and hold everythihg that you've learned.\"\n\n      For instance, my own particular previous background was \"Pure\nMathematics\".  Pure mathematics is all about \"proving theorems\" and it\ndoesn't bear too directly on the kind of work I have to do now.  Most of\nthe people who do \"pure mathematics\" are very abstract thinkers and are\ngenerally not the types who do things practical, like fixing a table in\ntheir house when it is broken.  If you're trying to grapple in your head\nwith truths about \"n-dimensional manifolds\" and trying to picture how\nthey work (a very old mathematical topic which roughly deals with curved\nn-dimensional (n usually bigger than 3) spaces) or if you're into one of\nthe newer mathematical fields which are all very abstract, then\npracticality of thinking usually gets in the way.  I personally am not\nbuilt like that mentally.  I like to fix my table.  That's why I left\nthe mathematics field.  (Besides, it doesn't pay much, for all the\nmental work you have to do.)\n\n      But, some of that mathematics training is helping me solve my\nprogramming problem that I have now.  The particular idea I'm pulling\nfrom the mathematics discipline is, that when you're analyzing a\nprocess, you have to get to the bottom of how it really works, without\nimposing any extra ideas on it.  Proving mathematical theorems is like\nthat.  You have to be (what mathematicians call) \"elegant\".  It means,\ngetting to the bottom of what's really going on, with absolutely no\nfrills and nothing extra to obscure the facts.\n\n      So in my particular case, I wrote a program a few years ago which\nworks, but which doesn't take all the possible cases into account.  (If\nyou really want to know, it is my VTT2TAPE program from CBT Tape File\n533, which cuts a \"real tape\" from an AWS-format virtual tape image on\nan MVS system.)  When I wrote the program originally, I got it to work\nfor SOME AWS-format virtual tape files, but not for all of them.  Now I\nam being forced to re-write the program to cover the rest of the\nlegitimate AWS-format cases which I didn't anticipate before.  In the\ncase of my program, it is not a simple fix.  I see now, that when I\nwrote the program originally, I didn't really get to the bottom of what\nwas going on.  I imposed my own artificial ideas on the cases I knew\nabout, and I programmed for them.  Now I see that I have to rip much of\nthe program apart, and just program for the bare essentials.  I was\nwrong before.  I didn't really look at the situation the way I should\nhave looked at it.  And my previous mathematics background showed me the\nway to do it right.\n\n\nPACKAGING PROGRAMS FOR THE CBT TAPE\n\n      I know this is an MVS column and you don't want your time taken\nup by general concepts of \"idea grabbing\", unless they relate to what\nwe do every day.  So I'm going to talk about some of the things I do\nevery day.  I'll give you a small glimpse into where I pull my ideas\nfrom.  And then you yourselves can pull some of these ideas from here,\nto gain a bit of benefit for yourselves.  Most of what this is about,\nrelates to moving moderate amounts of data from one system to another,\nor from one shop to another.\n\n      As proprietor of the \"CBT Tape\" collection of free MVS software,\nit is my business to gather up people's useful tools, software,\ntechniques, and other things--anything that will help an MVS systems\nprogrammer to do the work better.  BTW, do a www.google.com search on\n\"CBT Tape\" if you want to know how to get these free materials.\n\n      Nowadays, we are not dealing with \"pure MVS\" anymore.  Most of us\nnow work on Windows-based terminal emulators, not on directly-attached\n\"green screens\".  Recent directions in computing, such as the fact that\nmany people are running MVS on Linux-based FLEX-ES systems, force us to\ndiversify and relate to tools that are partially rooted in non-MVS\nsystems as well as in MVS itself.  For example, many people now write\ntheir documentation for MVS tools in Microsoft WORD or in PDF format,\nand that stuff is not directly usable on MVS.  You need a PC, and you'd\nprobably have to deal with some Windows-based system, to be able read\nthe doc for these MVS tools.\n\n      Now by definition, the CBT Tape collection is MVS-based.  But as\nthe proprietor, I have to account for all the new diversity in MVS\nsystem tools.  For example, I just got some contributions which do\nFLEX-ES tape management, RACF reporting, and CICS work, using Perl\nscripts on Linux.  (This is from John McKown.)  There is an MVS portion\nof each tool, and a Linux portion which has to be packaged in a TAR\nfile.  To fit the CBT Tape requirements, I have to get all of that stuff\ninto FB-80 EBCDIC format.  This was a problem to solve, and I needed to\ngather ideas.  John himself provided many of them.\n\n      To understand it better, let's back-track and relate some history.\nWhen Arnold Casinghino started the CBT Tape collection almost 30 years\nago, he put separate programs into separate tape files.  Then he started\nto gather multiple files into pds'es, and package them on the tape using\nIEBCOPY.  After that, a program was written (called CBT973) which took\na pds that was in IEBUPDTE format and squeezed the blanks out.  For\nsource code, that program saved almost half the length on a tape over\nIEBCOPY packaging.  Load modules and other non-FB-80 materials still had\nto be dealt with using IEBCOPY if they were pds-based, or with IEBGENER\nif they were in some weird sequential format.  And the load modules\ncould never be packaged together with source modules for the same program\npackage.\n\n      All of this changed, when TSO XMIT format started to be used.  TSO\nXMIT format was designed to send non-VSAM files over JES transmission\nlines.  JES2 and JES3 both are very FB-80 friendly.  So in order to\nfacilitate the transmission, the idea was first to transform the data\nfrom whatever format it was in, to sequential FB-80, transmit it, and\nthen to maintain integrity and transform it back the way it was, once it\nreached its destination.  For our purposes, we weren't interested in the\ntransmission of the data over the NJE lines.  We were interested in\ntransforming it to and from FB-80 sequential format reliably.  We took\nadvantage of the OUTDSN( ) keyword of the TSO XMIT command, which does\nthis transformation.  The XMIT command (and its opposite number, the\nRECEIVE command) are IBM-created programs that are found on all MVS\nsystems which have TSO/E.  So if you can reliably create FB-80 format\nfiles out of almost anything, then you can package a load library as a\nmember of the same pds which contains the source code.  And there are\nzillions of other possibilities that this XMIT facility opens up, when\nwe consider using it for our packaging purposes.\n\n      So how does John McKown package his Perl scripts for distribution\non an MVS system?  He FTPs a TAR file containing them, from the Linux\nsystem to a sequential file on an MVS system, and then puts it into\nFB-80 format on MVS using the XMIT command and its OUTDSN( ) keyword.\nThis becomes a member of a pds on a CBT Tape file.  To use the material\non Linux, you have to RECEIVE it on the MVS system and then FTP the TAR\nfile back to Linux, where it can be expanded and used.  Since quite a\nfew people have such a configuration nowadays, we can still use \"pure\nMVS\" to distribute software that is meant to be used only partially on\nMVS.\n\n      While we're talking about that, I might as well mention that we\nhave MSWORD and PDF files on the (MVS-based) CBT Tape too.  Sometimes\nwhen it's too hard for me to convert somebody's WORD doc to EBCDIC FB-80\ntext, I just FTP the WORD (or PDF) doc in BINARY to an FB-80 file on\nMVS, and make it a member of a CBT Tape file pds.  It takes up a lot of\nroom, relatively speaking, but the process works!  To use these files,\nyou have to FTP them back to a pc, of course.\n\n\nSUMMARY\n\n      I certainly hope that you've gotten some benefit from reading this\nmonth's column.  The point is that in order to solve our problems, we\nshouldn't limit our thinking, but we should set our minds to be able to\npull ideas from ALL of our experiences, not just our current\nwork-related ones.  We should try to use these ideas, and bring them to\nbear on the daily problems we are solving.  If a simple solution\nsuffices for the current task, then all well and good.  But if we have\nto rack our brains on a tough problem, maybe we should start thinking of\nthat movie we saw last week.  It might give us a good idea.\n\n      I wish you all a happy and prosperous year, as we are finishing\nthe 16th year of this column and going into the 17th.  You can find\nall of these columns on File 120 of the CBT Tape collection, so if you\nwant, you can look up any of the back ones.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0501JA": {"ttr": 27395, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x06\\x01\\x044\\x0f\\x01\\x044\\x1f\\x14I\\x01\\x1b\\x01\\x1b\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-12-05T00:00:00", "modifydate": "2004-12-06T14:49:06", "lines": 283, "newlines": 283, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          JANUARY 2005\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.\n\n\nMY POINT OF VIEW\n\n      This month, I want to talk about some of my personal ways of doing\nthings.  Everybody has his/her own \"style\", for want of a better way to\ndescribe one's personal preferences in how to do the work.  Along with a\npersonal style, everybody develops a personal set of tools to use, over\nthe years.  A lot of times, we write these tools ourselves, but more\noften, we borrow them from others, and adapt them to our own needs and\nlikes.  The huge CBT Tape collection of free tools and \"stuff\" for MVS\nsystems programmers, in its almost 30 years of existence, has become an\nimportant source for all of us to borrow tools from.  Do a\nwww.google.com search for \"CBT Tape\" to find out more information about\nthe CBT Tape collection.\n\n       Today, I'd like to describe some of my own tools and ways of\ndoing my own work.  The first reason for choosing this topic is that\nmost people pick up pointers to improve their working style, one pointer\nat a time.  Watching me talk about my own methods, is very much like\npicking up one pointer at a time.  Also, some of my own personal\ngimmicks are from the newer creations that have been contributed to the\nCBT Tape.  If someone hasn't looked at a CBT tape or the cbttape.org web\nsite for a while, these ideas might be new and useful to them.  A\nsecond reason for choosing this topic, is to answer people's questions\nas to why some of the CBT Tape files are built the way they are.  As\nproprietor of the collection, I have to make quite a few decisions about\nthe content and structure of the files.  And if people ask questions\nlike why am I reluctant to delete old pds members from a file, I'd like\nto talk about that.  Normally, I have to explain these things many times\nover to everyone who asks the same questions.\n\n\nHOW I SET MYSELF UP\n\n      I have to admit that like most people, I am not \"the complete\ninnovator\".  I have invented a few of my own setup tools, but I have\nborrowed and adapted most of the session setup tools that I use.  These\nhave varied over the years.  But I always angle the type of tools I want\nto use, in certain directions, even if the exact tool for a given\npurpose isn't the same one I used ten years ago.  That's why I think\nthat many of you might be able to pick up a pointer or two from watching\nme work.\n\n      First, I have to state that in my position as the \"system doctor\",\nwherever I have worked, I insist on having access to as many APF\nauthorized TSO commands as I feel I need.  Sometimes a particular shop\nwould try and restrict my access in certain directions.  If it is to\npreserve their company data, I have always respected that.  After all, I\nwas hired to protect their installation and guard it, not to harm it in\nany way or to cause them unnecessary data loss or down time.  But I feel\nthat I am responsible enough to be trusted to fix any part of the system\nwhen a repair is needed.  And I need access to my special tools for\nthat.\n\n      So to set up APF authorized access to special tools for myself, I\ntry and get my own TSO LOGON PROC, or in a slightly worse case, to use\nthe installation's \"sysprog\" LOGON PROC.  The main thing I want from the\nLOGON PROC, is to have a STEPLIB with only an APF authorized load\nlibrary in it.  This allows me to accomplish what I call \"personal APF\nauthorization\" of TSO commands and programs to be run under TSO.\nDetails on what this gains for you, can be found on Files 185 and 186 of\nthe CBT Tape collection.  For space reasons, I don't want to elaborate\nany more about it here, except to say that if IKJTABLS is running from\nan authorized STEPLIB (either in the LOGON PROC or TSO-in-Batch), then\nit completely overrides the active global IKJTSOxx member in PARMLIB.\n\n      Once I have access to my authorized library of TSO commands, I am\npretty much \"in business\".  But there is quite a bit more that I need,\nespecially under ISPF, that will help me to get quick access to my\narsenal of tools.  For that reason, I want to customize my own ISPF\ncommand table, and do it quickly and effortlessly.  I've had various\nways of doing it over the years, but currently I use Willy Jensen's REXX\nexecs, ISPCMDL, ISPCMDU, and ISPMSG from File 349 of the CBT Tape, to\nadd new entries to the ISPF command table \"on the fly\".  The way it\nworks is that you code a member called ISPCOMND in your ISPF.ISPPROF\npds, and put all the new ISPF commands you want to add, there.  Then you\ninvoke the REXX exec (which goes into your SYSPROC or SYSEXEC library\nconcatenation) ISPCMDU to update the incore command table and add your\nspecial commands.  Or you invoke the exec ISPCMDL to list your current\nactive command table in storage.  A sample ISPCOMND member to add to\nyour ISPF profile dataset is included in File 349 of the CBT Tape.  I'd\nstrongly recommend that you look at it and see the enormous advantages\nthat these extra commands give you, like being able to invoke any ISPF\npanel \"on top of\" any other work under ISPF that you're currently doing.\n\n      A disadvantage to using this \"on the fly\" command update method is\nthat the updates disappear whenever there is a severe ISPF error, and\nthen TSO ISPCMDU must be invoked again, to reinstate your personal ISPF\ncommand environment.  My personal answer to this, is to make \"TSO\nISPCMDU\" easy to invoke.  I do it by making a single addition to the\nstatic ISPCMDS ISPTABL member (which should be first in your ISPTLIB\nconcatenation), to invoke only %ISPCMDU.  The entry is as follows:\n\n      CMDUPD   4   SELECT CMD(ISPCMDU)\n\nSo by simply entering CMDU on the ISPF command line and pressing ENTER,\nI can always reinstate my ISPF command environment.  In my LOGON CLIST,\nI include the command ISRPCP CMDU at the bottom, so the \"invalid\ncommand\" CMDU will appear at the top of my initial ISPF screen, and I\nonly have to press ENTER to invoke it.  This method of creating your own\nISPF command environment is especially helpful in a large shop, where\nyou don't want to \"rock the public boat\" by personalizing too much stuff\nthat is in common libraries.\n\n      Speaking of the ISPTABL and ISPTLIB libraries, most of you know\nthis, but I'll just repeat the facts to refresh your memory.  ISPTABL is\nthe library concatenation which is written to, when you make ISPF 3.9\n(command table) updates.  ISPTLIB is the \"reference library\nconcatenation\" which is read by ISPF when it searches for xxxCMDS\nmembers.  So therefore, it pays to make your ISPTABL library which is\nfirst in the ISPTABL concatenation, also the first library in your\nISPTLIB concatenation.  That way, as soon as you make command table\nupdates, they will be immediately effective.  In my own place, I use my\nISPF profile dataset pds as the first library in both my ISPTABL and\nISPTLIB concatenations, so my personal updates remain personal.\n\n\nLOGON CLISTS VERSUS HARD-CODED LOGON PROC JCL\n\n      I strongly prefer to allocate my TSO LOGON PROC datasets via a\nLOGON CLIST, rather than to hard-code the DD names of all the libraries\nin the LOGON PROC JCL.  In fact, my ideal LOGON PROC looks very much\nlike the \"emergency LOGON PROC\" that is shipped with new IBM MVS\nsystems, but with four exceptions.  The first is that I hard-code my APF\nauthorized STEPLIB in the STEPLIB ddname.  The second is that I prefer\nto use the TSO Session Manager instead of the normal TSO READY prompt,\nso I code PGM=ADFMDF03 in the EXEC card instead of PGM=IKJEFT01.  The\nthird is that I code a SYSPROC ddname that points to the clist library\ncontaining my LOGON CLIST which does the allocations.  And the fourth is\nthat I code a PARM='%myclist' in the EXEC card, to invoke my own LOGON\nCLIST that is in the SYSPROC library.\n\n      The enormous advantage of a \"sparse LOGON PROC\" which uses mostly\nCLIST allocations, is that when one of the datasets to be allocated is\nmissing, you only get an allocation error for one ddname, but you still\nhave your TSO session in operation.  If the missing dataset DD card had\nbeen hard-coded in the JCL, you would have gotten a JCL error when\nlogging on to TSO, and so you would have no TSO session at all.\n\n      To easily create a LOGON CLIST instead of the existing allocation\nmethod, just get into your current TSO session under ISPF and invoke\nISRDDN.  Then (for most later versions of ISPF) invoke the CLIST\nsubcommand of ISRDDN.  This will create a CLIST that will be a good\nstarting point for making a personal LOGON CLIST to allocate the proper\nlibraries for your session.\n\n      So how do you fix a bad allocation when you don't have ISPF to\nedit the LOGON CLIST?  I use an editor which works under \"raw TSO\" and\nwhich does not need ISPF at all.  Three such editors are:  RPF from\nRob Prins, and RPF/E, which is the XA version of RPF.  RPF resides on\nthe CBT Tape collection in File 415.  RPF/E resides in File 417.  These\ntwo TSO-based editors are ISPF-like for FB-80 datasets, and they have\nextra utility functions which you are only used to seeing when you have\nISPF up.  These two editors (should) have identical functionality, but\nwith RPF/E, since it uses the storage area above the 16M line, you can\nedit much larger datasets.  So if you have a modern MVS system, RPF/E is\nthe preferred editor to install.  The other TSO-based editor is new in\nthe REVIEW command, from CBT Tape Files 134 (source) and 135 (load).\nThe newest REVIEW command from Greg Price doesn't only browse datasets\nwithout ISPF, it can now edit them too.  Just REVIEW a single member or\ndataset and type UPDATE on the command line, to invoke the REVEDIT\neditor and edit that dataset.  If you're in the REVIEW pds member list,\ntype U (for UPDATE) next to any member, to edit it.  REVEDIT, now an\nintegral part of the REVIEW command, is also very ISPF-like in feel,\nalthough it doesn't (yet) have all the subcommands that the ISPF editor\nhas.  (Give Greg a little time.....)\n\n      If you have one or more of these tools already installed on all of\nyour systems, you can much more easily fix TSO problems and general\nsystem problems.  I trust that one word to the wise, will be sufficient.\n\n\nA SMALL RACF TIP\n\n      If I want to share my RACF database across several MVS releases, I\nupdate a common RACF database and its backup, with the highest MVS level\nRACF templates.  And I point to these common databases using an ICHRDSNT\nmodule that I try and put into a linklist library at the highest\npossible concatenation level on each system.  RACF at lower system\nlevels is always built to understand a RACF database at a higher RACF\nlevel.  Therefore I don't have to re-establish all of my permissions at\neach system level.  I only use one set of common RACF databases at the\nhighest MVS level, and do all the permissions only once.\n\n\nWHY I DO THINGS MY WAY, ON THE CBT TAPE\n\n      I've been editing the CBT Tape collection for over 14 years now,\nand Arnold Casinghino before me, edited the collection for 15 years\nbefore that.  During the last 5 years of Arnie's time managing the\ncollection, I worked in fairly close collaboration with him.  So between\nwhat I've learned from watching Arnie, and from my own experiences, I've\ndeveloped a point of view which kind of encourages me to do things \"a\ncertain way\".  Of course if anybody thinks I should do things\ndifferently, I'm always willing to listen, and I've picked up a lot of\nsuggestions from quite a few people over the years.\n\n      One thing I do is to try and preserve old pds members.  When\nsomeone sends me a new pds to update his/her file, I compare the new pds\nwith the old one, and only update the changed or new members that the\ncontributor sent me.  I try to keep all the old members, unless the\ncontributor expressly tells me to delete them.  The reason for this is\nas follows:\n\n      In managing the CBT Tape collection, I feel I have to \"cater to\nall the world's needs\".  Some shops are running old versions of MVS,\nalthough after Y2K, almost all shops are past OS/390 1.2 or 1.3.  But\nthese were 16 or 17 releases ago, and a lot of water has already gone\nunder the bridge, even since Y2K.  So the older pds members in a\npackage, which might be irrelevant for newer MVS releases, sometimes are\nneeded to run the package or program on an older MVS version.  Once in a\nwhile, a contributor, who himself is running some very new MVS version,\nloses sight of that fact, and deletes \"irrelevant\" members that are\nuseless to him at his own shop, but not necessarily to others.  To stay\non the safe side of that, I keep old pds members, unless I'm explicitly\ntold not to.\n\n      The other big question concerns producing load modules.  Most of\nthe CBT Tape contributions are in source form.  So at each installation,\na person installing the package has to assemble or compile the modules\nand produce his own executable load modules.  But for some of the\npackages, either for the purpose of quick installation, or because some\nshops don't have the required level of MACLIB, MODGEN or the assembler\nitself, I have to create these load modules myself.  What are my general\ncriteria when I do this?  Please bear in mind that I have to cater to at\nleast 17 levels of the operating system, if not more.\n\n      If I'm assembling something, I try and use the latest MACLIB and\nMODGEN I have, unless they absolutely don't work for some reason, and\nthen I have to revert to using an older set of macro libraries.  I try\nto use the latest version of the assembler, though not necessarily the\nlatest version of the Binder or linkage editor.  Sometimes I'll even use\nHEWLKED instead of IEWL.  HEWLKED is the pre-Binder old linkage editor,\nwhich is still shipped with z/OS.  Usually the version of Binder or\nlinkage editor doesn't matter, but the version of the assembler\nsometimes does matter.  A \"new\" program like SHOWMVS (on CBT File 492)\nabsolutely requires the newest assembler and macro libraries.  But the\nload module will run on older systems, usually.  (ShowZOS runs only in\n64-bit mode, ShowMVS 7.09 runs on OS/390 and above, while ShowMVS 6.30\nis required for older systems.)  Therefore I feel it is a requirement\nfor me to produce load modules that cater to the widest audience\npossible, and to make the tool available to as many people as I can.\n\n      With the PL/I Optimizing compiler, the situation is opposite.\nNowadays, there aren't too many PL/I contributions remaining on the CBT\nTape, but the ones which are still there, like VSAMANAL (CBT File 294)\nand ASMTOZAP (File 044 for source, File 035 for load) are very\nimportant.  In producing PL/I load modules, I use the OLDEST PL/I\ncompiler I can get hold of.  The reason for that, is also to cater to\nthe widest audience.  Some shops pay for PL/I run time libraries, but\nnot for the compiler.  New run time libraries will run old load modules,\nbut not the other way around.  So I produce old-style PL/I load modules\nwith the oldest PL/I Optimizing Compiler version I can get hold of.\n\n\nCONCLUSION\n\n      I hope this month's piece has been helpful to the widest audience\npossible (in keeping with my general outlook).  All of the opinions\nexpressed here are my own, but not necessarily ONLY my own.  In my own\nwork, I try to make what I do and the environment I create, as\nuniversally applicable as I can.  And I try as hard as possible while\ndoing my own work with as many tools as I can muster, not to impact the\nother users, and all the application programmers, in the shop.  I\nisolate my own environment and try to keep it as private as possible.\n\n      All the best of everything to everybody....  I hope to see you\nhere again next month.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0502FE": {"ttr": 27401, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x16\\x01\\x05\\x00_\\x01\\x05\\x00\\x7f\\t3\\x01&\\x01&\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2005-01-05T00:00:00", "modifydate": "2005-01-07T09:33:16", "lines": 294, "newlines": 294, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         FEBRUARY 2005\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.\n\n\nEMULATION AND MVS\n\n      I consider myself very fortunate to be able to witness our\nexciting era of change.  Technological progress gives rise to new\ntechniques, and new techniques give rise to further technological\nprogress.  As we go on and do our jobs every day, events continue to\noccur that change both our larger world, and also the way we do our\nnormal everyday work.  Some people may not like to always be moving in\nan ever changing set of surroundings, and I admit that it is more\ncomfortable to be settled into a daily routine that doesn't vary too\nmuch.  But there is a vibrant excitement to our time, which was not\nnearly as evident in former times.  And I feel that it would be a great\npity, not to both enjoy it and take advantage of it.\n\n      For example, consider something as basic as hard drives for the\nPC.  Today it is not uncommon to use 300 gigabyte attachable hard drives\non your own personal computer at home.  Now let's compare that size to\nan IBM \"big-iron\" mainframe disk pack, like a 3390 model 3.  The\ncapacity of a 3390 mod 3 is 2.7 gigabytes--that's all!  Can you figure\nhow many 3390-3 disk packs you'll be able to fit on ONE 300 gigabyte\ndisk drive that you can hold in your hand?  It's well over a hundred of\nthem!  And that's without even compressing them!\n\n      So, the old mainframer will still pipe back and say that the\nnumbers may not be lying, but practically speaking, you can't make use\nof PC disk space as mainframe DASD.  Not so at all!  FLEX-ES MVS systems\nuse PC disk space as emulated MVS DASD.  P/390s use PC disk space as\nemulated DASD.  And even Hercules systems (legally run) use PC disk\nspace as emulated DASD.  To top it off, Hercules systems can use\ncompressed DASD that averages one fifth the size, depending on how much\nreal data is there.  So what comes out of this (relatively small)\ntechnological development of having the availability of high-capacity PC\nhard drives?  It comes out that the entire DASD situation on\nmainframe-based MVS systems has been completely revolutionized!\nPractically speaking, you can now carry an entire \"DASD farm\" around in\nyour hand.  That's not a small consequence, coming as it does, from just\n\"one single technological development\".\n\n      Today I'd like to encapsulate the consequences to MVS, of four\nareas of change, all caused by some form of \"emulation\".  These are:\nFirst, \"terminal emulation\" versus the old hard-attached \"green\nscreens\".  Second, \"hardware instruction emulation\" versus \"real\nmachines\".  Third, \"virtual DASD\" versus \"real DASD\".  And fourth,\n\"virtual tape\" versus \"real tape\".  I'll show you how each of these\nmarvelous technological developments has revolutionized our entire MVS\nworld view.  And practically speaking, each of us will be able to\nimmediately use more than a few new techniques taken from each one of\nthese four areas of emulation.  The direct benefits to all of us from\nthese developments are REAL!  They are not just news items.\n\n\nTERMINAL EMULATION VERSUS \"GREEN SCREENS\"\n\n      In former times (i.e. for my first ten years in this business),\nI used to be extremely comfortable with the directly attached 3270 TSO\n\"green screen\" that was supplied with MVS.  Every time I logged on and\nlooked at that old familiar terminal, I felt that \"I am at home.  This\nis where I live.\"  Then the PCs came along, and I had to be in Windows\ninitially, before I could get onto TSO.  It was disconcerting at first.\nI had to get used to using an emulator.  Which emulator?  Attachmate?\nQWS3270?  IBM Personal Communications for Windows?  Each one was\ndifferent, and each was awkward in at least one way.  In short, they\nwere all a big pain in the neck.\n\n      I finally settled on one emulator that I liked, and I always use\nthat one.  It was written by a friend of mine who is a fellow MVS\nsystems programmer, and I get the feeling that he wrote it for US--for\nOUR TYPE OF PEOPLE.  There is a lot of good information on the bottom of\nthe screen, and everything is very customizable.  This emulator is\ncalled Vista.  It was written by Tom Brennan, and you can get it for\nyourself, over the web, from www.tombrennansoftware.com.  Tom charges 30\ndollars for a personal license, but he gives a free 30-day trial first,\nand you can install it on any computer that you personally use for\nyourself (if I understand his terms properly).  Tom gives you a good\ndeal.  So whatever, whenever, and wherever I dial into something (as\nlong as it is an MVS system), it always looks and feels the same, even\nif the system itself is physically sitting halfway around the world.\n\n      Whatever terminal emulator you are using, you always have some\nadvantages over the green screen.  These are:  Color control, which is\nmuch more easily done.  Keyboard control.  On Vista, you have individual\ncontrol over which character any key stands for.  CUT and PASTE.  You\ncan copy stuff between two completely different computer sessions, as\nlong as they are both running as emulated sessions on the same PC.  You\nnever could do that with a green screen.  You always had to have some\nphysical transmission between two computer systems which was a direct\nconnection, before you could copy data from one session to the other.\nIND$FILE.  You can always upload and download files from the PC to the\nmainframe, when you have an emulated terminal.  Font adjustments.  These\nare easy to do on an emulated screen, and almost impossible on a green\nscreen.  Scripts and playback.  Even though you can do this on the more\nsophisticated physical terminals too, it's much easier to set them up on\nan emulated terminal.\n\n      So you see that once you have gotten used to working on an\nemulated TSO screen, it's a lot more flexible to do your own special\nstuff there, than it was on the (much more unforgiving) hardware\nterminals.  I did know one systems programmer who insisted on having a\ndirectly connected terminal on his desk.  But he was the only one who\nwanted that, in a very large shop.  Everyone is entitled to his or her\npreference.  That is part of the greatness of humanity--all people are\ncreated different!  I actually took advantage of it.  That person was\nable to fix something on the system one time, when nobody else's\nterminal worked.  But the rest of the time, he wasn't able to enjoy all\nthe other advantages that we had.\n\n\nHARDWARE INSTRUCTION EMULATION VERSUS \"REAL MACHINES\"\n\n      It was after a NaSPA chapter meeting in 1990 when my friend George\nShedlock gave me a long speech about how this fellow Marty Ziskind who\nworked for IBM was touting a mini-MVS machine called a P/390 that IBM\nwas making.  At that time it was hard to imagine an MVS machine that was\nsmaller than two very large refrigerators.  Most were much larger.  This\nmachine was going to be a PC with a special card in it, that emulated\nthe MVS instruction set.  All of the MVS hardware devices were emulated\nunder OS/2 on the same PC.  Such a thought was mind-boggling and amazing.\nIt was a little too much for me to fully absorb at the time.\n\n      The successor to the P/390 turned out to be a completely emulated\nmachine that runs on a \"plain PC\" under Linux.  It is the FLEX-ES\nmachine from Fundamental Software, that does most of the MVS functions\non an ordinary IBM PC.  No special cards are needed.  Everything is done\nwith software emulation of hardware.  So any new instructions which IBM\nwants to add, can be emulated by a new version of the FLEX software,\ninstead of IBM having to make a new hardware card.  The system only\nneeds a proprietary hardware dongle that plugs into a USB slot on the\nPC, to protect the rights of the company that wrote the emulation\nsoftware (Fundamental Software).  And MVS runs on it.  Imagine a 30 mip\nMVS machine in 64-bit mode that runs on hardware weighing only 5 pounds!\nYou can carry it anywhere in a small suitcase, and it runs on battery\npower.  It's perfect for a software developer, and now (under IBM's PWD\nprogram) it's actually semi-affordable (it costs \"only\" about 15\nthousand dollars).\n\n      A used P/390 is considerably cheaper, but you still have to get\napproved by PWD to qualify for the MVS software loan.  And P/390s will\nonly run in 31-bit mode (z/OS 1.5 is the highest release which supports\n31-bit mode).  On top of that, you need a P390/E card to execute the\ninstructions to go that high with z/OS.  The older P/390 card stops\nworking after OS/390 2.10.\n\n      It has long been a fact that PC software could be developed by\nalmost anyone, because PC's were cheap.  But MVS software had to be\ndeveloped by someone working for a sizable company, because the machines\nit ran on, were very expensive.  Now it's not quite so bad.  IBM, with\nit's Partnerworld for Development (PWD) program, lends you the MVS\nsoftware for nothing, if you register at PWD with them, and they approve\nof your filed software development plan.  You have to own some hardware\nthat can run MVS, like a P/390 or a FLEX-ES box.  They're trying to help\nmake it possible for (at least some) independent people, or for someone\nwho doesn't have an MVS job right now (many people nowadays,\nunfortunately), to keep on working and exercising their hard-won MVS\nprogramming skills.  So the technology has helped some of us, at least,\nduring this current recession.\n\n      The power of emulated MVS software is only made possible, because\nof the immense CPU speed (usually over 1.5 gigahertz) of the modern-day\nPC machines.  Also, a physically tiny PC can now be equipped with well\nover 1 gigabyte of real memory.  So there's plenty of storage on a new\nPC, for MVS to run in.  The faster the CPU speed of the PC, the faster\nthe emulated MVS machine can be.  Fundamental Software has made some\nextra enhancements (such as their instruction cacheing, and their\nproprietary DASD format) to boost the speed up even more.  Peripheral\ndevices--DASD and even tape drives--are also emulated by the FLEX-ES\nsoftware.  And this brings us to our final two topics.\n\n\nEMULATED DASD\n\n      The P/390 introduced emulated ckd and fba DASD to the world.\nWhen you run the P/390 configurator program, which uses its own set of\nemulation software that runs under OS/2, you can create 3380 or 3390\nformat mini-disks having as many cylinders as you want to specify, up\nto an architectural limit of 2 gigabytes.  This takes us to the 3390\nmod 2 range.  To define a mod 3, which is bigger, the configurator\nmanufactures two files.  The first contains as many cylinders as can\nfit into 2 gigs, and the second contains the rest of them.  I haven't\nplayed with P/390 disks that are bigger, but the architecture allows\nthem to be defined.  The PC file name is just suffixed with _1, _2,\netc.  When you specify the file name to the configuration file for the\nP/390, you just specify the _1 piece, and the system finds the rest of\nthem.\n\n      IBM distributes the system DASD for its ADCDs (Application\nDevelopment CD-roms) in zipped P/390 format.  All you have to do is to\nunzip the DASD files which are on their cd's, and define them to the\nconfiguration file of the P/390.  When all of the disks are unzipped and\ndefined to the P/390, you IPL the system and MVS comes up!  Then you\ncustomize.  This was unimaginable in former times (roughly until 1990).\n\n      So on a P/390, you're only limited by how much hard drive space\nyou have, as to how much DASD you can support on your MVS system.\nUnfortunately, the old microchannel PCs that ran the P/390 systems,\ndidn't have very good IDE controllers, and my old model 750 P/390 will\ntake a 200 gig Hitachi (i.e. IBM) disk drive, jumpered to 15 heads, and\nonly use 7.5 gigs of that.  What a waste!  Fortunately, the newer PCs\nrunning FLEX-ES or even Hercules, will use all of their space capacity.\nAnd as we said before, you can carry a very huge DASD farm around on\nvery few hard drives.  And it can be ipl-able too!\n\n      Actually, the revolution has really gone full circle, and there\naren't many storage subsystems for MVS that use real 3390 hardware\nanymore.  They are all PC disks under the covers, in RAID configurations\nor whatever, to boost their reliability.  So the practical results of\nthis disk revolution have already been implemented on most of our MVS\nsystems.  Only the external names haven't been changed.\n\n\nEMULATED TAPE\n\n      When you talk about emulated tape, there are several different\nthings which can be called that.  One is the proprietary format of a\n\"virtual tape library\" where supposed tape files are really kept as\ndisk files under the covers.  That's not what we'll talk about here.\n\n      Our immediate concern centers around P/390 and FLEX-ES type\n\"virtual tapes\", which contain the tape data as disk files.  With these\n\"virtual tape formats\", the tape data blocks are sandwiched between\n\"headers\" that tell the emulated tape software how to jump from one tape\nblock to the next, and where a \"tape mark\" is, to mark the end of a\n\"tape file\".  For example, if you want to create a \"tape\" on a P/390\nsystem, you satisfy the tape mount request with an OS/2 command called\nAWSMOUNT, that points to a file on PC disk, which is the supposed\n\"tape\".  The FLEX-ES systems can deal with these virtual \"AWS-format\ntapes\" too, but they have their own format, called FAKETAPE.  The\nFAKETAPE format really is like the AWS-format, but FAKETAPE has their\nown headers, and their architecture is currently a bit less flexible\nthan the AWS-tape architecture for the P/390 virtual tapes.\n\n      Now I'll show you how you can use these \"virtual tape\" formats to\nbe able to keep your own tape collections on cd-rom or dvd-rom.  And\nwhen you need the tapes again, you can convert them on any MVS system,\nto real tapes.  I've written a set of programs that run on any MVS\nsystem, to make these conversions from tape to disk files.  You can find\nthese programs on File 533 of the Updates page of the CBT Tape\ncollection of free MVS programs.  Just do a www.google.com search on\n\"CBT Tape\".  The programs are called VTT2DISK (tape to AWS-format disk),\nVTT2T2FK (tape to FAKETAPE), which go from real tape to these disk\nformats.  And the programs to go the other way are:  VTT2TAPE (AWS-\nformat to real tape) and VTT2FK2T (FAKETAPE format to real tape).  JCL\nto run these programs is provided in the File 533 pds.\n\n      The one caveat is the format of the disk files on the MVS system.\nIn order to treat an AWS-format disk file as a \"virtual tape\", it has\nto be a PC file.  And PC files are just a long string of data on disk.\nOn MVS systems, you can't have that.  All MVS data has to be blocked.\nSo when I created my AWS-format \"tapes\" or FAKETAPE-format tapes on MVS,\nI had to choose a blocking scheme.  I chose Fixed Blocked, LRECL=80\nformat files on MVS, because they are easy to handle and send from one\nsystem to another.  Therefore, if you want to use the \"virtual tape\"\nfiles that I create on MVS as \"tapes\" on a P/390 or FLEX-ES MVS system,\nthey have to be downloaded in BINARY using FTP or IND$FILE to the PC\nsystem.  If you want to take a FAKETAPE file or an AWS-format tape from\na PC system and make a real tape from it using my programs, you have to\nupload them in BINARY to a pre-allocated MVS file in FB-80 format so\nthey get folded over.  Then my programs can read them and create real\ntapes from them.\n\n\nCONCLUSION\n\n      Emulation of several kinds has revolutionized ALL MVS systems\nnowadays, and our working lives are affected in many ways.  New DASD\nisn't old DASD anymore.  It's all PC-type hard drives, in one form or\nanother.  An immmediate consequence is that IBM isn't changing the\n3390 disk structure anytime soon, except to add more cylinder capacity\nto a logical volume.  Tapes can now be archived as disk files.  Full\nsized MVS machines can now be run on 5 pound notebook computers, and you\ncan carry one around if you want to do that.  A terabyte of MVS DASD can\nnow be carried around in a small satchel.  Life on the MVS scene is\ndefinitely different, and it has all been caused by emulation, in one\nform or another.\n\n      So I hope you're all starting to think and explore the\npossibilities for yourselves.  That big personal cartridge library can\nnow be reduced down to a few cd-rom or dvd-rom disks.  And you can go on\nfrom there.  I wish the best of everything for all of you, and I hope to\nsee you here again, next month.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0503MA": {"ttr": 27649, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00E\\x01\\x05\\x04\\x1f\\x01\\x05\\x04\\x1f\\x08X\\x00\\xf5\\x00\\xf5\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-02-10T00:00:00", "modifydate": "2005-02-10T08:58:45", "lines": 245, "newlines": 245, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          MARCH 2005\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.\n\n\nCREATIVITY\n\n      There's one fact that you can't get away from.  Like it or not,\neverybody needs everybody else.  Every person has to say to himself or\nherself:  \"There isn't one person I've ever heard of, who hasn't\naffected me in some way.\"  This has to be true, because whenever we hear\nabout someone else--what they did, or what happened to them--it affects\nus somehow.  We have feelings about it.  We have emotions about it.  We\nthink about it.  And that affects our lives, like it or not.  Even\npeople we've never heard of, deeply affect us.  For one example, let's\nconsider all the people who are responsible for bringing us our cell\nphones and the cell phone service.  Many of them may be in China or in\nother far-flung parts of the world.  But every single one of them\naffects us very much, no matter what our own opinions are.  After all,\nthey brought us the cell phone that we use.  And the cell phone works!\n\n      This idea relates to our area, MVS, very much, although as we\nmentioned, it is very general in scope.  We cannot forget that even in\nthis day and age, MVS is one of the most important pieces of the\ncomputing world, no matter what anybody says.  The facts are, that big\ncompanies rely on the MVS operating system and the hardware it runs on,\nto do very big tasks that handle a large bulk of the corporate business\ndone, all over the world.  We can't get away from that.  Take away the\nMVS component of computing, God forbid, and a large part of the business\nworld would collapse.  Despite anyone's opinion, MVS today is a very\nessential component of our lives, and every single person who\ncontributes in some way to MVS, affects practically the entire world.\nWhen you take some time to think about all the ramifications, you'll see\nthat it's really true.\n\n      So now, let's begin to zero in closer.  IBM employs people to\nproduce the MVS operating system.  The vendors employ people to produce\nutilities and programs that make MVS better.  Systems programmers and\nother people write their own utilities, tools, REXXes and CLISTs, to\nhelp them do their work.  Let's think.  What would the picture look\nlike, if just one of these people didn't do his or her part of the job?\nThe answer is, that there would be some missing pieces in that corner of\nthe world, which never came into existence.  In a business situation, if\nthe person who didn't do the job was working for IBM or a vendor, then\nthe product wouldn't be as good.  Maybe the product wouldn't work at\nall.  And the company which was responsible, would have to take some\nmeasures to compensate for the loss.  Either they would have to get\nsomeone else to try and make up the work, or they would risk a real\nbusiness failure in some way.\n\n      So I guess by now, if you've been thinking about it, you're\nbeginning to realize that EVERY person's work is important to YOU.\n\n\nWHAT CAN I DO?\n\n      What can YOU do?  Well, you do your work every day.  The first\nthing you can consider doing is to do your own job well.  Other people\nneed you, in the position where you are.  So if you do your own job\nwell, then you're automatically making an important contribution to\nthe entire world, not just to your own company or your own business.\nDid you ever think about it that way?\n\n\nWHAT ELSE CAN I DO?\n\n      The other thing you can do, is to create and innovate.  That's\nreally the topic of today's piece, and it's really a very important\npart of the MVS systems programmer's job.\n\n      If you think that being creative is hard, I'll show you that it's\nnot.  I think that all systems programmers have to have a bent for\ncreativity, because it's in the nature of the work, and if you're not\nnaturally creative, you won't like to do this job.  But to be specific,\nI'll give you an example of HOW to be creative, and what it means to be\ncreative.\n\n      A former co-worker of mine, Eli Duttman, besides doing more\ncomplicated things, created a simple CLIST called X.  The contents of\nthe CLIST was one line, which said LOGOFF.  If you think that's a\nno-brainer to do, I'll ask you a question.  How many of you have\nalready installed something like that on your systems?\n\n      What's the point of this supremely simple CLIST?  If you have to\nleave your desk quickly and need to log off your TSO session, you might\nnervously type the word LOGOFF incorrectly three or four times, before\nyou finally get it right.  X is less prone to mistakes.  So the idea is\nthat if you have some kind of emergency (like you're being called to a\nmeeting) and you don't want anything to happen to your TSO session, you\nwant a way to quickly and safely scram (i.e. get out).\n\n      Now 99.5 percent of you will tell me that this CLIST is very nice,\nbut there's a problem with it.  Usually, in these modern times, when you\nare in a TSO session, you're usually deep within ISPF, sometimes five or\nsix sessions deep.  Everybody knows that you can't type LOGOFF from\nwithin ISPF.  So you have to get out of all your ISPF sessions first,\nand then you have to type LOGOFF.  Only then, will typing X instead of\nLOGOFF, help you.  So you'd ask a question:  \"Maybe there's a REXX\nsomewhere (say it's called XXX) so that when you type XXX from inside\nISPF, this REXX will feel what sessions you have open, safely close them\nthe way you want to, and then LOGOFF from TSO.  Where can you find a\nREXX like that?\"\n\n      My answer is that I don't know of any REXX like that.  But I think\nit is possible to create one.  From all of you readers out there, I know\nthere are some of you with enough knowledge of the innards of ISPF\nsessions, that you can create a program to nicely close an ISPF session\nthat is open.  Now that I've said that, I know what many of you will\nthink.  AHA!  He's got something on the CBT Tape that does this!  But\nthe truth is that I don't know of one.  So, dear readers, where does\nthat leave you now?\n\n      At this point, I've got you thinking exactly what I want you to\nthink.  Picture this.  Think of your favorite tool.  And now suppose,\njust suppose, that it doesn't exist yet.  Somebody has to sit and write\nit.  Somebody has to create it and bring it into existence.  Before the\ntool exists, it's something that you might like to have, but you've half\ngiven up about actually having something that does what this tool should\ndo.  In contrast, after the tool has actually been written and brought\ninto the world (and it has been made accessible to you and installed on\nyour system), you can actually use it and do what you want with it.\nJust think hard about the difference between these two scenarios.\n\n      Now, you've got my point.  What is the difference between wanting\nsomething and actually having it?  Additionally, what is the difference\nbetween wanting something that actually doesn't exist (yet), and\nbringing it into existence yourself?  It's the exertion of effort.  The\neffort needs to go in two directions:  gathering knowledge, and then\napplying the knowledge once it has been gathered, to accomplish the\nresult and create the tool.  Once this has been done, you have brought\nthe tool into the world.  It is as if you have actually given birth to\nit.  Before you did what you did, the tool didn't exist--it was\nvaporware.  Now, you have actually created a working, useful being.\n\n      So, you'll add, \"it's too hard for me to create every tool I want,\nall by myself.  I don't have time for it.\"  This is a point well taken.\nBut to answer, I'd say that you should at least create a few of the\ntools yourself, and then you can also look in the CBT Tape collection of\nfree tools, or in other places, and try to see if someone else has done\nthe work of creating the OTHER tools that you ALSO want to have.\n\n      Now I've really shown you what I mean to say.  Before a tool is\ncreated, it doesn't exist in the world.  Someone has to write it, and\n(so to speak) give birth to it.  Only THEN, does it exist.  If a tool\nhasn't been written yet, it doesn't exist.  Once it has been written and\ndoes exist, if you want to make it useful for you, you have to install\nit, and exert some kind of effort to make it available to fill your\nneeds.  THAT's what I mean by creativity, as it applies to us.\n\n\nSHARING YOUR CREATIONS\n\n      In the PC world, there are two schools of thought.  Should I try\nand make money from the tools I write, or should I share them with\nothers for free?  In the MVS world, the software marketing situation\noften forces our hand.  In the MVS world, unless you have some marketing\nconnections or you're willing to exert great effort, possibly with no\nreturn or minimal return, it is very hard to market the software you've\nwritten.  So in the MVS world, a lot of people give away their software\nfor free, simply because there isn't any other real choice.\n\n      Of course, someone can keep his software to himself.  I know a\nperson like that.  This person wrote a programming language which he\nuses in his own work.  He's had this tool, and kept it to himself, for\nmaybe twenty years.  (Of course, it's his right to do so.)  But to my\nknowledge, he hasn't made a penny on it in all this time.  And by not\nletting anyone ELSE use it, he's deprived people, both of getting their\nwork done faster, and of helping him debug and enhance the tool, to make\nit better, even for himself.  He has also kept his name from getting\naround.  I think that if this person will share his tool and lets other\npeople see it, that language might have the potential to become some\nsort of a mini-Linux for MVS.  That's my opinion.  It's a big world, and\nother people have their reasons for doing things.  But I think that by\nhis not sharing his creation with others, this person has deprived a lot\nof people, and himself also, from gaining a lot of benefit in many\nvaried ways.\n\n      How can you share your creations, and also reap the benefit of\ngetting other people's suggestions for improvement?  One way is to have\nyour creation put into the CBT Tape collection of MVS tools.  This way,\nyour tool can eventually benefit many other people, and conversely,\nmany other people can contribute their suggestions for enhancing and\nimproving the tool as well.  It's a win-win situation, unless you have\nsome REAL potential for making money from your work.  Then I'd say that\nyou should make money.  But it's very hard to do that in the MVS world,\nunless you really can see your way through.  The CBT Tape collection can\nbe reached from its web site, or by emailing me at sbgolob@cbttape.org.\nOr else, just go to www.google.com and enter the words \"CBT Tape\".\n\n\nSOMETHING CONCRETE\n\n      To conclude this month's article, I'd like to mention a few of the\nvery new contributions to the CBT Tape, which you might be interested in\ndeploying.  These can be found on the Updates page at the CBT Tape web\nsite.  They will soon find their way into the main CBT section of the\nsite.\n\n      The first thing to look at is File 708, from Glenn Siegel, which\nis a very general MPF exit that may be able to replace all, many, or\nmost, of your current MPF exits.  Glenn calls it \"not your mother's MPF\nexit.\"  I call it (at the risk of some political incorrectness) \"the\nmother of all MPF exits.\"  It's worth a good look.  Next, is File 706\nfrom Andrew Armstrong, which is currently on the Updates page, but since\nit is a very large file, I am still looking for a permanent home for it.\nThis file will convert your MVS-generated reports into Shared Vector\nGraphics (SVG) format, so that the pictures will be scalable and will\nnot lose resolution when enlarged.  In SVG format, your graphical\npictures of performance info and such, will be able to be moved to other\nplatforms, all across your corporate network.  A cool thing indeed!  I\njust have to find a good home for the file, because the JAVA executables\nwhich are included with it, are very large, and don't zip down well.\n\n      File 705 is from Dave Cartwright, and shows you how to do some\nperformance tuning on a FLEX-ES machine.  It looks like FLEX-ES machines\nare here to stay, since they are the current supported low-end platform\nfor MVS.  So if you've got one, it's nice to have tools for it.  Dave\nCartwright has also contributed File 662, which helps you convert your\nCA-1 managed tape library to a FLEX-ES Faketape (TM) tape collection.\nIf you want to import real tapes into a FLEX-ES environment, look at my\nFile 533 collection of tools to create Faketape-format and AWS-format\ntapes on any MVS system, or to cut real tapes from them on any MVS\nsystem with a tape drive.   For more info about many more new tools,\nplease look at the Updates page of the CBT Tape web site.\n\n      I hope, as usual, that you were able to gain something from\nreading this month's column.  Creativity, meaning writing software\ntools--simple or complicated--in your language of choice--really is a\nprocess of making something out of nothing.  Before you wrote the\nsoftware and did the work, the tool didn't exist.  You were literally\nits creator.  Think about it!\n\n      I wish all the best of everything to all of you, and hope to see\nyou here again next month.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0504AP": {"ttr": 27654, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x14\\x01\\x05\\x07\\x0f\\x01\\x05\\x07\\x0f\\x10\\x11\\x01@\\x01@\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-03-11T00:00:00", "modifydate": "2005-03-11T10:11:14", "lines": 320, "newlines": 320, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          APRIL 2005\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.\n\n\nMVS SYSTEM LEVELS\n\n      Anyone who has been around the MVS world for a long time, knows\nthat IBM is always trying to improve MVS.  Much of the time, the changes\nare driven by customer needs, and often they are also driven by changes\nin the computing industry in general, such as connectivity issues.  For\nthe past ten years or so, IBM has committed itself to put out an\nintegrated new release of MVS every half-year or every year.  And\ntherefore, it behooves the MVS systems programmer, who is taking care of\nthese different releases, to know something about MVS \"release\ndependencies\" and how they are indicated internally within the operating\nsystem.\n\n      Any program which refers to or uses an MVS facility, should have\nthe capability of first determining if the MVS level it's running on,\nsupports that facility.  This is especially true for the newer MVS\nfacilities that haven't been around that long.  For instance, if a tool\n(which someone has written) uses, or refers to Hiperspaces, then that\ntool should be able to look at the particular MVS level it's running on,\nto see if that level supports Hiperspaces.  If the MVS level is too low,\nthen the tool should issue an appropriate error message and end.  This\ncertainly makes sense.\n\n\nGETTING STARTED - THE CVT\n\n      Where are the MVS system levels displayed internally?  For this\nquestion, as for most MVS internal control block chasing, the starting\npoint should be the CVT or \"Communication Vector Table\", which is mapped\nby the CVT macro in SYS1.MACLIB.  (For the record, the CVT macro was\nshipped in SYS1.MODGEN in very early releases of MVS.  My guess would be\nthat for assemblies that did control block chasing, it would be very\ninconvenient to always require that MODGEN be included in the assembly,\nso CVT was moved to MACLIB.)  After the ESA 3.1.0 level, there has been\nincluded a relatively new 16-byte field called CVTOSLVL that indicates\nthe presence of certain hardware facilities and indicates the exact\nsystem level.  The existence of the CVTOSLVL field of bits is indicated\nby an X'08' in the CVTOSEXT field.  When that bit is on, you can query\nthe CVTOSLVL bits to determine the current system level exactly.  To get\nto the address of the beginning of the CVT (ahead of its prefix), you\nload a register with the absolute decimal value of 16, or with X'10'.\nThe CVT prefix (which is just BEFORE the beginning of the CVT in\nstorage) includes the FMID of the current system level also, but it does\nnot contain bits that can be queried.  It just states FMID names.\n\n      Another indicator of the presence of hardware facilities is the\nSCCB (Service Call Control Block), which deals with the MVS Service\nProcessor Interface, and which is mapped by the IHASCCB macro.  The CVT\npoints to a permanent copy of the SCCB, whose address is located in CVT\nfield CVTSCPIN.  The copy of the SCCB which is pointed to by CVTSPCIN,\nis never deleted for the life of the IPL.  You should look at the macro\nIHASCCB that is in SYS1.MACLIB for more information.\n\n      At this point, I'd like to suggest, in general, that one try to\nfollow IBM's official guidelines when it comes to extracting a piece of\nsystem information.  So I'll say that to programmatically (in Assembler\nlanguage) determine the presence or absence of any particular MVS\nfacility, you should look at the particular documentation for that\nfacility in the IBM manuals, because although most facilities can be\ntracked down by experimenting, it is best to use an IBM-recommended and\n(if possible) an IBM-supported way of determining its existence.  For\nmost of the facilities that are intended to be used by the (educated)\npublic, IBM tries to provide adequate documentation (for that facility)\nsomewhere.\n\n\nLOOKING AROUND YOUR OWN SYSTEM\n\n      There are (at least) three good tools for nosing around within\nyour own MVS system, to see what exists there, and to find out the MVS\nsystem levels that you're running with.  In my opinion, these tools can\ncompletely replace most of the specialized auditors' tools that the MVS\nauditors used to write.  (See CBT Tape Files 220 and 221 for an XA\nversion of some specialized Auditor's Tools from Lee Conyers, a well\nknown MVS auditor.)  In my opinion, these 3 integrated tools completely\nreplace the collection of specialized individual tools which Lee Conyers\nwrote, years ago.  (You can look at these files in the CBT collection\nand check the facts out for yourself.)  Do a www.google.com search for\n\"CBT Tape\" and you'll find all this good stuff on the CBT collection.\n\n      The three tools referred to, are SHOWMVS (CBT File 492) from\nGilbert Saint-flour, now supported by Roland Schiradin, MXI (CBT Files\n409 and 410) from Rob Scott, and TASID from Doug Nadel (downloadable\nfrom his web site www.sillysot.com/mvs).  SHOWMVS is available in source\ncode as well as in load module form, and therefore you can learn how to\nget a lot of MVS internals information from looking into the SHOWMVS\nsource code.  Many of the SHOWMVS nosing-around methods are undocumented\nby IBM, and had to be figured out by the program's authors.  While this\nis not a recommended method, the authors of SHOWMVS really had no\nchoice.  But SHOWMVS is an invaluable tool for us, both in its output\nand in its source code.  So by making even a moderately thorough study\nof the SHOWMVS source, you can (once you get used to the methodology)\nlearn a great deal about many aspects of MVS internals.\n\n      In addition to using these Assembler-based tools to nose about\nyour MVS system, it's also good to look at Mark Zelden's IPLINFO REXX\nexec on CBT Tape File 434.  IPLINFO, as a REXX exec, is an excellent\nexample of showing the very considerable power of REXX in chasing MVS\ncontrol blocks.  Mark's collection of other useful tools on File 434 are\nalso well worth looking at, and using.  Most of them, being REXXes, are\nquite simple to use.\n\n\nTHE THREE AUDITORS' TOOLS\n\n      SHOWMVS, MXI and TASID are so good, that anyone who knows how to\nuse all three of them well, can keep an extremely sensitive finger on\nthe pulse of an MVS system.  Figure 1 shows the first 40-or-so SHOWMVS\noutput lines out of about 5000 (yes, FIVE THOUSAND).  You'll see SOME of\nthe MVS component release levels shown there, although there are even\nmore of them in the rest of the display.  SHOWMVS shows its information\nunder ISPF BROWSE, but it can deliver its output in several other ways,\nincluding a TCP/IP connection.  Much MVS information that is specific to\nthe installation, and a ton of information about the invoking TSO userid\nare displayed by SHOWMVS.  And again, since the source code of SHOWMVS\nis distributed too, you can (after some study) figure out how SHOWMVS\ngets its information which is in the display.\n\n      MXI is an ISPF application from Rob Scott, who was supporting it\nfor years by himself, until he finally got a job with a good company\n(Rocket Software) which is allowing him to support the free version of\nMXI while at the same time developing a vendor-supported enhanced \"pay\nversion\" that is for sale.  I only got to see the free version, which is\npart of the CBT Tape collection, but it has so many display options (at\nlast count, about 118 general ones in the free version, besides the\nsub-options and memory displays) that if you study it well, it will\nkeep you busy for some time.  Many innards of MVS are displayed by MXI,\nincluding UCBs, ESOTERIC device names, SMS information, RACF innards,\nand many other things.  I can't even begin to scratch the surface of\nwhat MXI does, here.  But I can tell you, that you can find out a lot\nof information about your system and software levels using MXI.\n\n      Doug Nadel (the developer of TASID) works for IBM, and he was one\nof the ISPF developers for a long time.  One of the things Doug did,\namong many others, was to develop ISRDDN.  Since IBM equipment was used\nin developing TASID, it has an IBM copyright, and I can't put it on the\nCBT Tape, although Doug has permission to distribute TASID for free.\nSo you can get TASID from Doug's website, www.sillysot.com/mvs.\n\n      TASID will tell you many things, and will allow you to browse\nstorage with quite a bit of help, such as a FIND facility.  There are a\nlot of point and shoot features in the TASID storage viewer.  ENQ\ndisplays are a particularly strong suit of TASID, and the RACF\ninformation is very useful.  Of course, there is a lot more to TASID\nthan I have space to mention here, and therefore I encourage you to try\nit and play with it.\n\n\nAN ILLUSTRATION OF SYSTEM LEVEL DEPENDENCE\n\n      A particular instance of system level dependence can be found in\nthe changes which IBM made to UCB lookups, around ESA version 4.  The\nUCB lookup scheme had been changed once before that also, at the XA 2.2\nlevel.  So any code which is intended to run on multiple MVS releases\nand which looks up devices, device characteristics, and device activity,\nespecially if it does not run authorized, has to have release level\ndependent coding when it comes to the UCB lookups.\n\n      SHOWMVS itself has such a requirement.  One of the chief displays\nof SHOWMVS is of device activity.  You want to know which disks are\nallocated to which jobs, and which tapes are on the tape drives.  Take\na look at Figure 2 to see a partial illustration of this SHOWMVS\ndisplay, for DASD.\n\n      Gilbert Saint-flour maintained the SHOWMVS code for many years,\nsince SHOWMVS is his program.  (Roland Schiradin maintains SHOWMVS\nnowadays.)  When IBM changed the UCB lookup scheme in ESA version 4,\nthey required that mass UCB lookups which found the actual UCBs (and not\na copy of the UCB) had to be done by authorized programs only.  Only APF\nauthorized programs could execute the IBM-mandated mass-lookup options\nin the UCBSCAN macro.  So Gilbert, who was supporting these lookups in\nthe SHOWMVS displays, and who needed the actual UCB for real-time\ninformation (and not a copy of the UCB), was stuck.  SHOWMVS supports\na complete refresh of the DASD and TAPE devices display, every time you\npress Enter under ISPF, and Gilbert did not want to eliminate this\ndisplay whenever SHOWMVS would be run non-APF authorized.\n\n      So Gilbert did some research into how the UCB lookups are done\ninternally, in the IBM code, and he came up with a scheme to do the\nmass UCB lookups in a non-authorized fashion.  You can find his code\nby looking at the SHOWMVS source code and doing a FIND on the string\n\"ULUT\" (which means \"UCB Lookup Table\").  There you will see the\nrelease-dependent code, in all its glory.  When SHOWMVS runs non-APF\nauthorized, it will still create the DASD and TAPE device displays.\n\n\nALERTNESS IN RELEASE DEPENDENCY MATTERS\n\n      IBM is very customer-driven when making changes to MVS.  So for\ninstance, when banking, insurance, and other large institutions which\nhave to stay open all the time, asked IBM for IPL reductions, IBM had to\nrespond by changing and restructuring parts of MVS.  Many of the changes\nhad to involve a redesign of the original MVS structures which were\ncreated at IPL time, and which could not be changed without another IPL.\nThese all had to be (one at a time) converted into dynamically alterable\nstructures that accomplished the same result as the former static\nstructures, but which could be changed with an operator command.\n\n      For example, one of the first areas to be addressed was device\ndefinitions.  MVS used to be statically generated with all the devices\nstatically defined, with an \"IOGEN\" required when changes were needed.\nThat was one of the first things that had to go.  There is HCD that does\nthe same job now.  A new IODF can be made and plugged in much more\neasily than by doing the complete system change which an IOGEN used to\nrequire.  Then there was the static APF list and other static things\nwhich had to be made dynamic.  JES2 needed many such changes also.  And\nthe new requirements for restructuring of MVS internals are constantly\ncoming in.\n\n      So (in conclusion), what should we do about it?  A general piece\nof advice is to keep abreast of the IBM announcements and get the MVS\nconversion guides, whenever your installation is planning a release\nchange, and even if it isn't.  Staying abreast of the changes to MVS is\nthe main part of the effort.  What to do about them, will depend on your\ninstallation's particular needs.\n\n      I certainly wish you much success in all these, and your other,\nendeavors.  And I hope to see you again here next month.\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   About the first 40 lines of SHOWMVS output.\n\n            There are over 5000 lines more.  Much system\n            information is displayed.  Quite a bit of it\n            is renewed every time you press Enter.\n\n\nSHOWMVS is running authorized\n\n>Operating System:\n\n  z/OS 01.06.00   FMID: HBB7709    CVTOSLVL: FF FF FF BF E9 00 00 00\n\n  DFSMS/MVS 1.6.0         Dynamic Linklist is supported\n                          Dynamic LPA is available\n                          DFSMS Loader Fork Exit is present\n                          DFSMS RVA SnapShot is available\n                          DFSMS RVA SnapShot API is available\n\n  JES2 Level: z/OS 1.5    NJE Node: N1          DSNID: 01\n\n>Last IPL:\n\n  Date: Sunday 2005-03-06 (2 days ago)    Time: 11.08    Julian: 2005.065\n  From: Z6RES1/0A80    NUC Id: 1    Type: Warm Start    CVTUSER: 00000000\n  Last Cold Start (CLPA) Date: 2005-02-27   Time: 06.21.19\n  Last Quick Start (CVIO) Date: 2005-02-27   Time: 06.21.19\n  SYSPLEX name: ADCDPL    SYSPLEX ID: 1A  Sysname: ADCD      Lparname:\n  Timezone: W 05.00.00 Leap Seconds: 0000000000000000\n\n>System Software:\n\nTSO/E Level:   3.6.0\nISPF Level:    5.6     PDF 5.6\nDF/DSS Level:  1.6.0\nRACF Level:    7.70.9\nICKDSF Level:  1.17.0\nVTAM Level:    6.1.6       VE616           00C45008\nLE Version:    1.6.0\n\nTCP/IP:        2004.0 M 5655-H    MVPTASK\n\n  Tseb     SI Proc     Ver   Tsdb     Tsdx     Asid TraceOpts Status\n  1040B040 01 TCPIP    06.16 103F4000 103F40C8 0048 00000000  Active\n\n * * * *  about 5000 lines more  * * * *\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFigure 2.   SHOWMVS display of DASD devices, showing which\n            address space has allocated each device.\n\n            Every time you press Enter during the SHOWMVS ISPF\n            display, this information gets updated.\n\n\n>Device Class: DASD\n\n  Unit Names:      3390      3380      DASD      SYSDA     VIO       SYSALLDA\n\n  UCBs:    368 (defined)     45 (on-line)\n\n   DEVN  UCBTYP    Unitname S Volser  Status\n\n   0124. 3030200E  3380     S OS39H3  Resident Private IDAW\n   0130. 3030200E  3380     S RESCUE  Resident Private IDAW\n   0300  3010200F  3390-1     WORK01  Resident Storage IDAW\n   0301  3010200F  3390-1     WORK02  Resident Storage IDAW\n   0302  3010200F  3390-1     WORK03  Resident Storage IDAW\n   0303  3010200F  3390-1     WORK04  Resident Storage IDAW\n   0304  3010200F  3390-1     JES301  Resident Private IDAW\n   0305  3010200F  3390-1     MOD113  Resident Private IDAW\n   0306  3010200F  3390-1     MOD114  Resident Private IDAW\n   0307  3010200F  3390-1     MOD115  Resident Private IDAW\n   0308  3010200F  3390-2     MOD201  Resident Private IDAW\n   0A80. 3030200F  3390-3   S Z6RES1  System Resident Private Allocated J=LLA\n   0A81. 3030200F  3390-3   S Z6RES2  Resident Private Allocated J=IBMUSER  IDAW\n   0A82. 3030200F  3390-3   S Z6SYS1  Resident Private Allocated J=DUMPSRV  IDAW\n   0A83. 3030200F  3390-3   S Z6DB81  Resident Private Allocated J=OMVS     IDAW\n   0A84. 3030200F  3390-2   S Z6CIC1  Resident Private Allocated J=OMVS     IDAW\n   0A85. 3030200F  3390-3   S Z6DIS1  Resident Private IDAW\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0505MY": {"ttr": 27905, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x05\\x10\\x8f\\x01\\x05\\x10\\x8f\\x08\\x01\\x01\\x06\\x01\\x06\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-04-18T00:00:00", "modifydate": "2005-04-18T08:01:59", "lines": 262, "newlines": 262, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                            MAY 2005\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.\n\n\nACCUMULATING KNOWLEDGE IN ASSEMBLER\n\n      Only the old-timers in MVS systems programming remember when this\njob actually involved an extensive amount of programming in Assembler\nlanguage.  That era ended around 1980 or so.  After that time, our job\nrequirement became mainly the setting up of the MVS operating system\nwhen necessary, and the installation of fixes.  We may also debug\nday-to-day problems, or more often, we merely report them to the various\nvendors' support lines.  And we generally keep our firm and alert\nfingers on the general health of the system.  This leaves very little\nrequirement for us to do any writing of code in Assembler.  So many of\nus do not get any Assembler practice as part of the job.  There actually\nexist a lot of \"systems programmers\" who never do any programming.\n\n      And after the \"Assembler Coding Era\" for MVS systems programmers\nended, the tendency, both from IBM and from the vendors, was (perhaps\nunintentionally) to tacitly discourage the use and knowledge of the\nAssembler language among MVS support people.  Intentionally or not, the\ntendency was there.  OCO (Object Code Only - no source) distribution of\nthe operating system and vendor code, was becoming the rule, even more\nso among the vendors than with IBM, and as a result, MVS systems\nprogrammers were getting less and less of a chance to learn about what\nreally makes their system tick.\n\n      Another blow that took away systems programmers' Assembler\nprogramming practice, was the general replacement of user modifications\nto the system, by system exits.  This was practical.  Installations who\nmodified the operating system would later have to re-fit their\nmodifications to later operating system versions.  This discouraged the\ninstallation of new system releases, and it presented a problem to all\nthe vendors.  As a remedy, IBM and the vendors added exit points to\ntheir code in places where the users frequently wanted to make their\ninstallation-dependent changes.  So instead of having the users modify\nthe main code, they would merely code a (hopefully release-independent)\nuser exit and hook it in to the vendor's product at a strategic,\nvendor-determined point.  But that practice, as necessary as it was,\nalso tended to reduce the amount of Assembler coding required in this\njob.\n\n      Now the question remains:  Why should we all have to know\nAssembler language?  The answer is that even though much of the system\nis coded in PL/X by IBM, it all boils down to Assembler code\neventually.  We can safely say that for all practical purposes, most of\nthe MVS system is written in Assembler language.  So if you understand\nAssembler language and you know about the system interfaces to the\nvarious components of MVS, you have an excellent chance of learning a\nlot about how the MVS system components work.  If on the contrary, you\ndon't know Assembler language, you have very little chance of acquiring\nany in-depth knowledge about MVS at all.  And in this business, that is\nan enormous handicap.\n\n\nFIGHTING THE GENERAL TENDENCY\n\n      Starting in the mid-80s, many of us have tried to \"buck the\ntendency\" of excluding Assembler programming practice from the the MVS\nsystem programmer's job.  A person whose everyday work is in this field,\nand who is straining himself with the everyday tasks, might wonder when\nyou can get an opportunity to write Assembler code as part of the job.\nThe answer, I think, is in the writing of utilities.\n\n      IBM has left us a lot of leeway in the \"optional utilities\ndepartment\" of MVS, especially in writing utilities that work under TSO.\nTSO has most of the power of MVS itself, and while IBM itself has given\nus some completed tools and TSO commands in SYS1.CMDLIB, they have not\ncome anywhere near supplying us with the capability of \"doing things\"\nunder TSO which TSO is really capable of.  But IBM has been nice to us\nin another way.  IBM has supplied us with a wealth of system macros\nthat provide access to a great many of the MVS internal facilities, and\nthey have given us documentation about how to use them.  With these\nmacros, you can write utility programs to extend your powers under MVS\nin astonishing ways.  But you have to know Assembler language to take\nadvantage of this opportunity.  And to learn the language you have to\npractice coding it.\n\n      In the old days, the companies would send us to Assembler school.\nI think those days are pretty much over.  Nowadays, I think the best\nway to learn Assembler is to look at other people's code.  And it helps\nif you can crystallize your knowledge, a bit at a time, by making\nyourself a project to write one utility in Assembler and getting it to\nwork.  Then you can add to that, and write another utility, and then\nsome more.  That's the way to get going.\n\n      There are a few Assembler language books, most of them pretty old,\nbut for our purposes, one of them stands out.  That one is:  Advanced\nAssembler Language and MVS Interfaces: For IBM Systems and Application\nProgrammers, by Carmine A. Cannatello and published by John Wiley, ISBN\nnumber 0-471-36176-3.  Last I checked on Amazon, it was very hard to get.\nI myself learned the basics of Assembler from Kevin McQuillen's book,\npublished by Mike Murach, which is still in print.  All the coding\nexamples from Carmine Cannatello's book are available for free, on the\nCBT Tape, in File 069.  Do a www.google.com search on \"CBT Tape\" to get\nto this enormous free collection of MVS goodies.\n\n      I'll give you one example about what I was able to write, just\nto show you the kind of power you can create by writing in Assembler.\n(This is not to disparage REXX and other languages--it's just that\nAssembler can go much deeper into the system.)  The example is my set of\nprograms to administer the SYS1.BRODCAST dataset, and TSO Broadcast data\nin general, which is on File 247 of the CBT Tape collection.  Most of my\nprograms can write directly to the SYS1.BRODCAST dataset without being\nAPF authorized.  (You just need RACF Update authority to SYS1.BRODCAST.)\nSYS1.BRODCAST is a DSORG=DA keyed dataset which needs special methods to\naccess it.  I can duplicate IBM's way of doing that, in Assembler\nlanguage, and I can also duplicate IBM's enqueues to make sure that\nIBM's SEND and LISTBC commands will not update SYS1.BRODCAST at the same\ntime I am doing any updating.  I challenge you to do something similar\nin REXX or in another language.  It's highly unlikely.  If you want to\nsee my code, just download File 247 from the CBT Tape, and you can learn\nall the stuff necessary to do this yourself, if you need that kind of\ninformation, or if you're just curious.\n\n      I don't expect any of you to try and do what I've done.  But my\nstuff is available for you to get information from.  So is a lot of\nother people's code, in the over 700 files that are on the CBT Tape\ncollection itself, and in the almost 300 files on the CBT Overflow Tape.\nAt www.xephon.com there are a lot of coding examples too, in the free\ncode that is more than two years old, which they give out.  The beauty\nof Assembler coding your own utilities is that you can do your own work,\nin areas of MVS that will help you yourself, and your own shop.  You\nshould create, and have fun doing it!\n\n      Now let's get to the real point of this article.  Practically\nspeaking, it takes time and effort to accumulate Assembler programming\nknowledge, to the point where you will accomplish what you want to do.\nI'm going to show you a few hints about how I've progressed over time,\nand I hope that I can help you achieve fantastic satisfaction and very\ntangible results.\n\n\nACCUMULATING ASSEMBLER KNOWLEDGE\n\n      I don't have space to talk about too many specifics here.  It's\nATTITUDE that I'm trying to give over.  The right attitude is the\ntried and true way of accumulating Assembler knowledge.\n\n      The first thing you have to know in Assembler language, is how the\ninstructions work.  While you're learning that, ONE INSTRUCTION AT A\nTIME, you have to also learn to use the special commands which tell the\nAssembler compiler (known as \"the Assembler\") what to do.  You have to\nlearn the general concepts of how a program keeps track of where it is,\nby means of \"base registers\".  And you have to learn how these base\nregisters are loaded with the proper data, so they work the way you want\nthem to.  The Assembler's USING instructions are the means of keeping\ntrack of where the program thinks its locations are.\n\n      Anyone can refer you to IBM's \"Principles of Operation\" manual,\nand tell you to start there.  But the \"PrinOp\" is a very forbidding\nplace to start for a beginner, and it's my job, for the rest of this\narticle, to try and make your progress easier, more enjoyable, and\ndoable.\n\n      One nice thing about MVS is that the old stuff that was written\nyears ago, will continue to work on new systems, unless some internals\nhave changed significantly.  And the old ways of entering a program,\nsaving the registers, and returning back to the caller or the system,\nstill work just fine.  In fact, I much prefer to use the old ways of\nentering and leaving a program, to the new BAKR and PR method, because\nmy programs will work on older MVS systems as well as on the new ones.\n\n      The main idea in (eventually) getting expertise in Assembler\nprogramming is to learn ONE THING AT A TIME.  This idea is so important\nthat it should be your watchword.  \"One thing at a time.\"  For example,\nonce you learn about the LOAD and STORE instructions, and get that idea\ninto your head once and for all, you'll never again confuse the LOAD\ninstruction with the LOAD ADDRESS instruction.  Confusing those two\ninstructions is the source of a large percentage of Assembler\nprogramming errors with beginners, and even with some more advanced\npeople.  It goes like this.  The LOAD instruction will take four bytes\nof storage, starting at a beginning location, and dump those four bytes,\nunchanged, into a register.  The STORE instruction does exactly the\nopposite.  STORE takes the entire (4-byte) contents of a register and\ndumps it, unchanged, into a 4-byte chunk of storage starting at a given\nlocation.  LOAD and STORE just move data between a register and storage.\nBut LOAD ADDRESS does arithmetic.  LOAD ADDRESS adds numbers together.\nLOAD and STORE don't.  They just move data.  So when you get that\nstraight, you won't ever confuse LOAD and LOAD ADDRESS again.\n\n      The process of \"Learning Assembler\" consists of learning new\nthings like this, many times over.  And there's so much to learn, that\npeople tend to get discouraged and don't bother learning more.  Looking\nat what you don't know, is not the way to go.  Using what you DO KNOW,\nand adding to it, one thing at a time, IS THE WAY TO GO.  That principle\nis so important, that if you just learn it, without any other specifics,\nfrom this article, then I've already done my job.\n\n      Condition codes are an important thing to learn about.  Some of\nthe assembler instructions change the condition code, and some of them\ndon't.  An instruction that sets the condition code (which is one nibble\nof bits 8, 4, 2, and 1) can be followed by another instruction which\nreads the current condition code (like a BRANCH instruction) and acts\naccording to what it sees.  It's another thing that you have to learn,\nbut if you do it \"one particular thing at a time\" and you're patient,\nI guarantee that you will eventually succeed.\n\n      When people went to Assembler school (in former times) they would\nsometimes do \"cutesy things\" like writing an instruction that sets the\ncondition code, and then writing a whole page of other instructions\ncarefully, which don't change the condition code, and then afterwards\ncode an instruction which reads the condition code that was set, 65\ninstructions back, and acts on it.  I don't recommend such programming\npractices at all.  I like to make my programs straightforward and\nreadable, and I try to comment each line.  Assembler is a hard enough\nlanguage to learn in the first place.  (Remember--one thing at a time.)\nMaking it harder by confused coding, is downright cruel to the next guy.\nIt's sort of like trying to follow ALTER instructions in a big COBOL\nprogram.\n\n      Once you've gotten some expertise in Assembler coding, after\nhaving followed these principles, you'll be able to test yourself by\ntrying to find 10 different ways of zeroing a register, and to know\nwhich of these set the condition code and which of them do not.  This\nis the kind of question we used to get at job interviews 25 years ago.\nThat's all very nice, and a way to measure your progress, but the main\nidea is to write simple, solid code THAT WORKS.   Even if you don't\nknow very much Assembler, if you can do that, you can pat yourself on\nthe back and start enjoying what you can do.  THEN ADD TO YOUR\nKNOWLEDGE, and do some more.  The key is to do it gradually.  And don't\nworry that there's so much more to learn.  Just concentrate on what you\nknow already, and try to add a little bit more to that.  USE what you\nknow already, and then add, and then USE THAT!\n\n\nSUMMARY\n\n      Assembler knowledge is a very powerful thing to have, if you work\nwith MVS.  It's a lost art nowadays, but you can't learn about how the\nMVS system works, without it.  Therefore, despite the fact that our\nworking environment usually does not afford us the time or occasion to\nlearn Assembler, we should all embark on it.  We should all BEGIN, and\nthen CONTINUE.\n\n      The key idea in learning Assembler language is to do one thing at\na time, and concentrate on what you already know, rather than on what\nyou don't know.  USE WHAT YOU KNOW, THEN ADD A LITTLE MORE TO IT, THEN\nUSE THAT.  In this way, you will succeed.  It is the tried and true\nformula.\n\n      I hope that old hands in this field, as well as new people, will\ngain from reviewing these ideas.  They are very important in our job,\neven if Assembler programming is not encouraged, and nobody mentions it\nat work.  If you push yourself in this direction, you will profit, and\nso will your work place.\n\n      All the best of everything to all of you!  I am looking forward to\nseeing you here again, next month.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0506JN": {"ttr": 27910, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Q\\x01\\x05\\x13?\\x01\\x05\\x13?\\x10R\\x00\\xfe\\x00\\xfe\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-05-13T00:00:00", "modifydate": "2005-05-13T10:52:51", "lines": 254, "newlines": 254, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           JUNE 2005\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.\n\n\nFIGURING STUFF OUT\n\n      After spending many years in this field, I feel that experience is\nthe best teacher.  We accumulate experience, a bit at a time, and\nhopefully store it up for future use.  I like to archive my past work\nand keep it with me.  I keep big personal JCL libraries from all my\nprevious sites, so I know how to make a job work properly and I don't\nhave to redo all the parameters and control statements each time.  Most\nof this experience is hard-won, so I don't want to lose it, or leave it\nat a previous site.\n\n      Early in my career, I developed a concept, or work ethic, which\nhas helped me throughout.  I call it my 50-50 100-100 rule.  It goes\nlike this.  When I do my job, I split it 50-50 with my employer.  The\nemployer gets my work, and I get the experience.  That's why I call it\n50-50.  But it's really 100-100.  The employer gets 100 percent of my\nwork, and I get 100 percent of the experience.  Knowing that I am always\ngoing to come away with valuable experience from all the work I do, I\ntry to do my job well, even if I'm not particularly thrilled with the\nattitudes and approaches of my current employer, but even more so if I\nam happy there.  In any case, using the 50-50 100-100 principle and\nkeeping it in mind, I always tend to do a good job wherever I am.\n\n      Today's topic is about applying your experience, especially when\nit comes to finding out information about how components of the MVS\nsystem work.  I'll show you an example from my own experience, and of\ncourse, you'll be able to make connections to your own experience and\nhopefully, profit from the effort.\n\n      Some of the best systems programmers and MVS software developers\nwe have today, came from difficult beginnings which we can't re-create\nnow.  And that's what made them good.  For example, in Australia, there\nused to be a lot of Fujitsu FACOM installations, which are slightly\ndifferent from IBM's MVS systems.  Let me explain.  These sites arose\nbecause IBM, in the 1970s, used to give out the OS/360 and MVS operating\nsystems for free, since IBM (at that time) made the bulk of their money\nfrom selling hardware.  Back then, MVS was practically public domain\nsoftware.  Fujitsu, a Japanese company, decided to expand on IBM's last\nfree software level, after a lawsuit from other hardware manufacturers\nforced IBM to charge money for the MVS software (and IBM started\ncharging a lot).  The Fujitsu FACOM system cost very much less money\nthan MVS did, and IBM in turn sued them.  As one of the results of the\nFujitsu settlement, Fujitsu was not allowed to sell their \"derivative\"\nMVS-like operating system in the United States.\n\n      So the Fujitsu system caught on in Australia, and it proliferated\nuntil the XA and ESA times, when the Fujitsu developers in Japan found\nthemselves unable to keep up with IBM.  Until then, Australian sysprogs\nat Fujitsu sites often found themselves in the position of having to\nadapt IBM software tools to the Fujitsu system, which had slightly, but\nsignificantly different control blocks and structures than \"real MVS\"\ndid.  Since the MVS tools didn't work unless you \"got down to the nuts\nand bolts\" and completely reworked them for Fujitsu's FACOM, these\nAustralian sysprogs got very unique experience, which was impossible to\ncreate almost anywhere in the United States (except at a few special\nFujitsu software development sites that were allowed to exist in the\nU.S.)\n\n      In this atmosphere, Greg Price and a whole bunch of other skilled\nAustralian software developers cut their teeth.  The Russian experience\nis another, even more extreme case.  During the Cold War, ending around\n1990, IBM did not sell their systems to Russia.  So the Russians, who\nneeded the IBM systems to keep the Moscow subway system running, and to\nmaintain their other institutions, had to get the IBM hardware and\nsoftware clandestinely, through other countries.  Russian sysprogs, who\nlater came to the U.S. (I'm friends with a bunch of them), could not\ncall the IBM support centers when they had a problem; they weren't even\nsupposed to have the computers at all!  So the Russian sysprogs had to\ndebug all the systems, and make their own PTFs and fixes without outside\nhelp.  Most of them wrote their own debuggers and disassemblers.  And\ntoday, they are so sharp in many aspects of this work, that their\nexperience is unequalled.  Since the political climate has now changed\nand many of the Russian programmers are in other places as well as\nRussia, it has turned out that we all are receiving benefit from these\nRussians' wonderful work, born of their unique experience under duress.\n\n\nSOME OF MY OWN EXPERIENCE\n\n      For illustrative purposes, I'd like to share one of my own recent\nexperiences, which in some sense is a small window into the \"process\"\nthat I want to describe.  I was tempted to call this column \"Reverse\nEngineering\" but that is not truly accurate.  The idea is to figure out\nhow the IBM programs must work, without having to know their code\nitself.  To be able to do this, is an important systems programming\nskill.  When you see the example, you'll get what I mean.\n\n      A uniqueness in my own experience, is that I was once paid to\ndevelop utilities to manage the user messages in SYS1.BRODCAST.  You\ncan see many of the results of my work by looking at File 247 of the\nhuge free CBT Tape collection of MVS software.  (Just do a google\nsearch on the words \"CBT Tape\".)\n\n      As most of us know, and all of us can find out by doing a TSO\nLISTD command against the SYS1.BRODCAST dataset, this dataset has\nDSORG=DA or \"Direct Access\" dataset organization, and it is \"keyed\",\nhaving a one-byte key at the beginning, with 129 bytes of data following\nthe key in each record.  And it is \"fixed unblocked\".  Such datasets,\nwhich formerly were in wider use, are composed of \"slots\" of records,\nwith one record in each slot, each record having a uniquely addressable\nposition, marked by its \"relative record address\".  In the case of\nSYS1.BRODCAST, the relative record address of each record is a\nthree-byte hexadecimal number, starting with X'000000' for the first\nrecord, or \"header record\".  (In the particular case of SYS1.BRODCAST,\nthe header record has information to find all the other records.)  Since\nthese datasets are very uncommon today, but the SYS1.BRODCAST dataset\nitself is necessary for the correct functioning of MVS, experience in\nreading and writing to SYS1.BRODCAST directly, is very hard to come by.\n\n      If you'll look at my \"Broadcast Manager\" software package on File\n247 of the CBT Tape collection, you'll see that I have very complete\ncoverage of the \"user messages\" portion of the SYS1.BRODCAST dataset,\nand I have several utilities which manage and can duplicate the dataset\nas a whole.  But recently I wanted to complete the package with programs\nthat handled the \"global notices\" portion of SYS1.BRODCAST, which works\ncompletely differently than the \"user messages\" portion.  So I came up\nwith two programs that read and write directly to this part of\nSYS1.BRODCAST.  They are:  BCMNLIST (to list active Notice message\nlines, like the SEND LIST subcommand of OPER does), and BCMNOTFY which\ncan write a new message line to a message number, delete a message\nnumber line, or write a message of (30) blanks to a message number line.\nI obviously thought that by doing this, it would be enough.  In my mind,\nI had it covered: BCMNLIST to list the \"Notify\" messages by number, and\nBCMNOTFY to write them, change them, delete them, and even to write\nblank lines.  I can also write my Notify messages to a COPY of\nSYS1.BRODCAST as well as to the \"real\" one.  All I have to do is to\nallocate the ddname of BRODCAST to either SYS1.BRODCAST or to the copy.\n\n      But when I got finished writing BCMNOTFY, I was shocked to\ndiscover that LISTBC did not show my changes, even though I had\nindelibly written them to SYS1.BRODCAST.  It was obvious to me that\nLISTBC was looking at an incore copy of the Notices, not at\nSYS1.BRODCAST itself.\n\n      It should have occurred to me that this made sense.  Suppose at a\nlarge site, that 150 people were trying to LOGON to TSO at one time.\nSince LISTBC is automatically invoked by every TSO LOGON, unless the\nsite turns off the invocation of LISTBC (which is very rare), then if\nLISTBC had to read SYS1.BRODCAST directly for each LOGON, there would be\na big performance bottleneck in these LOGONs which are occurring\ntogether.  So to avoid unnecessary waits at LOGON time, IBM had created\nan incore copy of the \"Notices\" part of SYS1.BRODCAST, which LISTBC\nwould read.  Since (officially) the Notices part of SYS1.BRODCAST could\nonly (using IBM's tools) be changed by the SEND subcommand of the OPER\nTSO command, it made sense to change the incore copy only when the OPER\nSEND command combination was invoked.  So what was I to do?  I had to\nmake it possible for LISTBC to detect my changes, and force a re-read of\nthe SYS1.BRODCAST dataset to create a new incore copy of the Notices.\n\n      I had figured all of this out without asking one question of IBM,\nnor of any of my friends.  But then I needed to ask something:  \"Where\nwas the incore copy of the Notices kept?\"  So I put out the question on\nthe IBM-Main newsgroup, and Jim Mulder, one of the IBM developers who\nmonitors IBM-Main (voluntarily, I might add), told me to look at the\nIKJTSVT macro, which maps the \"TSO Vector Table\", and to look at\nanything with the string TSVTNCT in it.  There were two occurrences of\nTSVTNCT in the assembler part of IKJTSVT.  One was TSVTNCT itself, that\nis an address pointer to the actual incore Notices table, and the other\nis TSVTNCTU, a flag byte which indicates that the incore Notices table\nneeds to be updated.  Now I'd gotten somewhere.  The TSVT is pointed to\nfrom the CVT (Communication Vector Table) at X'9C' off the beginning of\nthe CVT, and the data is pointed to at +8 off the TSVT.  The \"need to\nupdate\" flag is X'80' at +5 off the TSVT.\n\n      I used the free LOOK TSO command from File 264 of the CBT Tape\ncollection to browse the core.  The J10 subcommand of LOOK (look at\nstorage pointed to by virtual location X'10') got me to the CVT, which\nLOOK formats.  Then the LTVT command (link to the TVT field of the CVT\nformatted control block) got me to the TSO Vector Table, which LOOK also\nformats.  Then LNCT got me to browse the incore Notices table itself.\nPressing PF9 to back up one screen and look at the formatted TSVT again,\nI entered the ONULL LOOK subcommand, to unformat the storage so I could\nbrowse it directly.  I found out everything I wanted.  Now I just had to\nwrite a program to throw the \"table needs to be updated bit\", and see\nwhich IBM program would read that bit and update the table.  The program\nto throw the bit is now called BCMNUPD, and it is a TSO command which\nhas to be run APF authorized.  But the other programs, BCMNLIST and\nBCMNOTFY, don't have to run authorized.\n\n      When I flipped the TSVTNCTU bit on, I found, on recent systems,\nthat LISTBC itself will inquire about that bit, and it itself will\nupdate the incore Notices table.  But on older TSO systems (it turned\nout on z/OS 1.2 and older), you needed to run an OPER SEND to force an\ninquiry of this bit and update the incore Notices table.  So I solved\nmy problem.\n\n      Please notice that this entire process did not require any real\n\"reverse engineering\" or disassembly of IBM code.  It only required some\nknowledge of IBM control blocks, which is public knowledge on\nSYS1.MACLIB.  I didn't need to do any reverse engineering in my actual\ncoding efforts, at all.  IBM gives you the information publicly, if you\nhave the experience to know how to look for it.\n\n\nUSING OTHER PEOPLE'S EXPERIENCE\n\n      It is obvious that very very few people have done what I have, in\nthe previous example.  But MVS is a very huge system, and there's lots\nto learn about, and lots of other stuff to be done.  Each person does\nthe job in those areas which he or she has to support.  And for the\nother stuff that needs doing, we all have to rely on tapping into other\npeople's experiences.  We all use the RESULTS of my experiences.  But\nalmost nobody else has to duplicate my work.  That's the beauty of it.\nMVS is a large system, but a lot of coverage is obtained, when each\ndifferent person takes his own piece of it to study.  With a lot of\npeople working, there is then a lot of coverage.  And you can see the\nresult of the other people's work by looking at the CBT Tape collection\n(most of which comes with source code), and at www.xephon.com's older\nstuff, which is free, as well as in other scattered places on the net.\nAnother good place for finding facts about MVS internals is the source\ncode for the SHOWMVS program, on CBT Tape File 492, where a lot of this\ncontrol block information has already been figured out.\n\n      Some of the tools that I used in my particular endeavors are very\ninteresting and useful, such as the LOOK program from File 264 of the\nCBT Tape, which I used for browsing virtual storage.  LOOK can\npotentially format any storage which has a macro definition to describe\nit.  The version of LOOK which I used, has a nice selection of macros\nfor formatting, and you can add many more, if you want to.  If a control\nblock is formatted by field names, you can use an L command (or Link) to\nfollow the control block chains by field name, as long as all the\ncontrol blocks involved are formatted.  If not, you just point to the\nnext field by displacement, such as J+8, which would mean to show the\nstorage that is pointed to by the current location +8.  Other programs\non the CBT Tape can show storage, such as MXI (Files 409 and 410) from\nRob Scott and XMDSMAIN on File 690 from Martin Kline.  The TASID program\nfrom Doug Nadel at www.sillysot.com/mvs is another free program that can\nbe used to browse storage too, among its \"many other talents\".\n\n      At this point (right before I have to close) I want to say that\nmany facts about MVS internals can be learned by \"figuring them out\" and\nby experimenting.  Each person can't do all of it alone.  And each\nseparate investigation takes time.  But each person can profit by\nlooking at the other people's work as it relates to theirs, learning\npiece by piece, one fact at a time.  That's how you accumulate knowledge\nand eventually you can do more and more, to everyone's gain.  I wish you\nall the best of everything, and I'm hoping to see you here again next\nmonth.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0507JL": {"ttr": 27915, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x11\\x01\\x05\\x17_\\x01\\x05\\x17_\\x11\\x12\\x00\\xfc\\x00\\xfc\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-06-24T00:00:00", "modifydate": "2005-06-24T11:12:11", "lines": 252, "newlines": 252, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           JULY 2005\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.\n\n\nMVS IS ITS HISTORY\n\n     Back in the 80s, I always used to complain that IBM never tried to\nteach MVS to new systems programmers properly.  IBM has since addressed\nthe \"newbie education problem\" better, having come out with a fine\nmultivolume series of Redbooks called \"The ABCs of z/OS System\nProgramming\".  However, the practical problem of training new systems\nprogrammers to maintain MVS (which by any other name, is still MVS) is\nnow becoming much more critical every day.  The older systems\nprogrammers who have all the experience, are retiring, and the working\nMVS systems are nevertheless very much a crucial component of data\nprocessing in the world today.  Who is going to continue to maintain\nMVS, as we go into the future?  We have figure out how to bring up the\nnew people, so that they properly appreciate the job they will have to\ndo.\n\n     What were my complaints about IBM's policies?  First and foremost,\nwas the gripe that IBM never would mention in their manuals, where a\ncomponent of MVS came from, and what its history was.  This IBM\ninsistence on only mentioning the newest version of their products, and\nhow their products currently work, may have been justified from the\noperational point of view.  Because after all, the manual should teach\nyou how to run the current version of the product.  But in the special\ncase of the MVS operating system, the omission of MVS history left a\nwoeful inadequacy from the teaching point of view.  If a new systems\nprogrammer would look at an IBM manual to learn something about an MVS\ncomponent, he or she would often be confused by a maze of unintuitive\nkeywords and terms, which could only be properly understood if you knew\nwhere they came from in the past.  Many of us old-timers think that the\nthrust in teaching MVS has to be different, simply because of the way\nMVS has developed.  MVS is historical.  MVS has always been built on the\npast.  Anybody who has taken care of MVS for more than a few years, can\ntell you that without batting an eyelash.\n\n     Why this specialness about MVS?  The reason is because OS/360 was\ndesigned and implemented to reach into the future, but in an\nevolutionary way.  Most of the improvements to OS/360. OS/VS2, MVS,\nMVS/XA, MVS/ESA, OS/390, and z/OS have been customer driven\nimprovements.  But the shops which were running the new releases also\nhad to keep running the old programs.  The system was always designed\nwith a compatibility and a connectivity to the past.  So MVS has always\ngrown from the branches, with most of the roots still left intact.\nThat's why you can't properly learn about the current state of MVS\nwithout knowing what MVS was like before.  And that's why, in the\nparticular case of supporting MVS, that the old-timers have an almost\ninsurmountable advantage over the newbies.\n\n     But the old-timers are gradually leaving, and we have to face the\ninevitable problem of how to bring up the new people.\n\n\nAN EXAMPLE\n\n     It took me four years to learn SMP4 and SMP/E, IBM's automated\nsystem to apply programming changes (i.e. PTFs, APARs, and USERMODs) to\nMVS.  After the four years, I saw in retrospect that with the proper\nintroduction, I could have learned most of it in three weeks.  And that\nwas a woeful shame.  Nobody took the time or effort to explain SMP to me\nso it would be understandable.  I had to wade through it myself and take\nthe hard knocks, until finally it dawned on me, what was really going\non.\n\n     I determined to remedy the situation by writing a series of three\narticles for \"Technical Support\" magazine back in 1988, explaining in a\nfew pages, why SMP(/E) does what it does, and why it is built the way it\nis built.  (You can see these articles today, in File 014 from the free\nCBT Tape collection that is on the web.  Just do a www.google.com search\nfor the words \"CBT Tape\".)  What I did in those articles, and what IBM\nwould not (then) have done for almost any amount of persuasion, was to\nexplain that the whole concept of SMP could not be understood, if you\ndidn't already understand what the SYSGEN process was.  And today, we\ndon't even do any SYSGENs at all.  The SYSGEN functionality has\npartially been superseded by HCD, the rest of it is built into the\npre-packaged target zones from IBM, and we don't ever get to see it at\nall anymore.  So today, how are we supposed to properly understand what\nSMP/E is, and how or why it does what it does?\n\n     Of course, we can learn SMP/E by rote, and \"just do\" what the\nmanual says.  But there's no real understanding there, unless you have a\ngood idea of what's behind the (very elusive) concept of \"JCLIN\".\n\n     The word JCLIN doesn't seem to imply much.  If you knew nothing\nabout it, the word would suggest the idea of \"putting JCL in\".  An\nintelligent person would ask:  \"What is this for?  Why should you want\nto 'put JCL in'?\"  To explain to the user that the JCLIN process is the\nvery heart and soul of SMP/E processing, was the farthest thing from the\nIBM manual writers' consciousness.  That's why it took me four years to\nlearn SMP/E instead of three weeks.  I had to discover this idea for\nmyself.\n\n      If I had only known that JCLIN was a DD name for input to SMP's\npredecessor program, AMAPTFLE, that, in itself, would have helped a lot.\nAnd it would have helped me to have put in some PTF fixes to MVS the old\nway, using AMAPTFLE.  Had I understood how to do the system fixes the\nold way, the new way would have made more sense to me.  To use the old\nAMAPTFLE program required, that you had to access (at least) part of the\nJCL that was generated by Stage 2 of the SYSGEN.  That JCL told AMAPTFLE\nhow the particular piece of MVS being fixed, was originally put\ntogether.  So therefore, had I had some practice using AMAPTFLE, I would\nhave immediately understood the connection between applying the system\nfix, and the original SYSGEN JCL, inputted by the JCLIN DD name.\n\n      But the main remedy would have been if the IBM manual writers had\nthought of simply stating the actual purpose of what JCLIN is for.  The\nIBM manuals on SMP/E should have said:  \"The reason for the JCLIN input\nis to tell SMP/E what the structure of the MVS load modules and other\ncomponents looks like.  JCLIN tells SMP/E how to build each part of MVS\nfunctionality from its component elements.  JCLIN tells SMP/E the\n\"architect's plans\" about how to put the MVS system together.\"  If the\nIBM manuals would have said that, my learning of SMP/E would have taken\nmere months, not years.  But if someone, or some manual, had gone a bit\nfurther and taken the time to explain the following historical fact, I\nwould have gotten the correct idea, right away.  The idea is, that just\nthe way a SYSGEN puts the whole MVS system together and determines its\nentire structure, so does the JCLIN tell SMP/E how to insert a partial\nreplacement, or even a complete replacement, into an already existing\nMVS system.\n\n      So from this example, you can see how it helps to include a\nhistorical perspective, into explaining how a piece of MVS works.\n\n\nCURRENT MVS SYSTEMS LOOK LIKE THE PREVIOUS ONES\n\n      Imagine this scenario.  (Everybody who is experienced, knows that\nthis is true.)  Suppose you would be able to patiently go through an IPL\nof 20 or so successive releases of MVS, one after the other.  Each\nrelease is one higher than the one before.  If you were able to do that,\nyou'd notice that the console messages for each system level do not\ndiffer too much from either its predecessor or its successor.  For sure,\nyou would certainly notice the differences at each level.  (And that's\nwhat you're SUPPOSED to notice.)  But by and large, the external\nappearance of MVS does not change much.  Even if you were to go back 15\nreleases from the one you're running now, the general appearance would\nstill be quite familiar to you.  So I might ask, why can't a new MVS\nsysprog just learn the system from its current level, and then he or she\nwill be \"up to snuff\"?\n\n      The answer is in the changes.  As I hinted before, most of the\ndevelopment of MVS occurs incrementally, as add-ons or as replacements\nto pieces of the system.  Almost the entire education of an MVS systems\nprogrammer comes from the accumulation of knowledge about MVS\ncomponents.  And if you saw how each component was first introduced, and\nif you followed it through its successive developmental stages until it\nwas finally stabilized, then you have a good chance to acquire a decent\nunderstanding of that component.  You'll understand the \"why\" of the\ncomponent, as well as the \"what\".  This is what the experienced MVS\nsystems programmers have, and the newbies (no matter how bright) do not.\nThis is what the employers of the sysprogs, the MVS installations, are\nmissing, when a seasoned MVS sysprog retires.  Replacements for that\nknowledge are not easily found, and the installation will eventually\nsuffer considerably because of that gap in understanding.\n\n\nCAN SOMETHING BE DONE ABOUT IT?\n\n      Awareness of the history of MVS and its components is a very large\npart of the MVS sysprog's education.  In my opinion, it seems that if\nyou haven't lived through the history yourself, the historical knowledge\nof MVS is hard to come by.  But some of the gaps can be filled in, and\nat least a piecemeal attempt can be made by a new sysprog, to be able to\nfigure out \"what must have happened before.\"\n\n      Talking to the old-timers about MVS is very instructive.  If a\nveteran MVS sysprog is nice enough to \"talk shop\" with the new people\ncoming up, they can gain a world of knowledge.  Having such a person to\ntalk to, is one of the greatest resources an MVS sysprog can have.  If\nyou can't find an old-timer who's willing to talk in your own shop, you\nmight join the IBM-Main news group and follow the discussions there.  A\nlot of old-timers get into the discussions on IBM-Main.  (See my April\n1998 column entitled \"Other People's Problems\" on File 120 of the CBT\nTape collection, and get a detailed introduction to IBM-Main.  I've\nupdated the specific URL information about IBM-Main there.  In the\nreprint of the actual article, that specific information is old.)  Since\nIBM-Main is available to everyone, you don't have to remain in isolation\nfrom the MVS old-timers of the world.\n\n      Another thing you can do, is to run an ancient version of MVS,\nlegally, for yourself, on your own PC at home.  Get a copy of the\nTurnkey MVS system made by Volker Bandke, which runs on any modern PC\nunder Windows, and you can be transported back to the mid-1970s era of\nMVS.  You'll see for yourself, how things USED TO BE DONE.  You'll run\nSMP4, which came before SMP/E.  You'll have to work through the\nlimitations of MVS that were there, before they got fixed by later\nimprovements to the MVS system.  This is entirely legal, because the\nversion of MVS which comes on the Turnkey system (it can be installed\nand running in less than an hour), was free software, licensed by IBM\nbut given out for free, vintage 1975.  So go to the CBT Tape website\n(look on www.google.com and search for \"CBT Tape\") and follow the\nHercules links on the home page.  Order or download a Turnkey MVS\nsystem for yourself.  Once you've played with the old MVS 3.8 system,\nand with some of the more modern toys that were re-fitted to it later,\nyou'll acquire an enormous amount of historical perspective in MVS, and\nyou'll become a far more valuable MVS sysprog on the modern z/OS\nsystems.\n\n\nGETTING ON MY SOAPBOX\n\n      Right now, I feel that it is appropriate to make a necessary point\nabout judging the \"qualifications\" of an MVS systems programmer,\nspecifically when it comes to evaluating a person for a job opening.\nOver the years, many of us have encountered \"job requirements\" for MVS\nsysprogs, stating that they have to be very familiar with the most\nrecent versions of MVS (OS/390, z/OS, etc.) almost before the new\nreleases come out.  If a shop wants to install a new release of (say)\nz/OS, they tell it to their personnel people, and the personnel people\nerroneously only look for someone with VERY RECENT MVS EXPERIENCE.  This\nis A VERY BIG ERROR.  MVS is old.  MVS knowledge, largely, is MVS\nhistory.  MVS experience comes mostly from MVS history, and NOT from\nknowing only the newest release.  Very fine and highly capable MVS\nsystems programmers are often rejected from a job opening, only because\ntheir previous shop did not run a \"very current release\" of MVS.\n\n      Evaluating the \"talent\" only from experience with a recent MVS\nrelease is a big mistake, because an experienced MVS person always knows\nabout most of the system, and the \"new stuff\" can be picked up very\nquickly if you already have the \"old knowledge\".  New people don't have\nthe \"old MVS knowledge\".  The experienced people DO have it.  The way\nMVS is built, the \"old knowledge\" provides the skill to overcome myriads\nof problems.  Lack of the old knowledge leaves a person empty of the\nmeans to overcome adversity.  So shops looking for an MVS sysprog, would\nbe better off considering an \"old MVS hand\" and trust that he or she can\npick up the new stuff as needed.  Systems programming managers should be\nquick to catch this mistake when they talk to their personnel\ndepartments, so they will hire the most skilled person for the job, and\nnot let him or her go.\n\n      I trust that this month's piece will be helpful to you in a\npractical way.  Some of these topics have gone too long, without being\nspecifically mentioned and spoken out.  Things that \"everybody knows,\nbut nobody says\", when they relate to MVS knowledge, are better \"said\"\nthan \"unsaid\".  That's why I'm saying them.\n\n      I wish all of you the best of everything.  Please come back here\nagain, next month.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0508AU": {"ttr": 28165, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00T\\x01\\x05\\x18\\x8f\\x01\\x05\\x18\\x9f\\x12C\\x00\\xe6\\x00\\xe6\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2005-07-07T00:00:00", "modifydate": "2005-07-08T12:43:54", "lines": 230, "newlines": 230, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          AUGUST 2005\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.\n\n\nHOW TO DO STUFF RIGHT\n\n      I was tempted to call this column \"Saving Your JCL\", and a lot of\nwhat we want to talk about today, will have to do with that.  However, I\nreally want to be a bit more general, and talk about saving instructions\nabout how to do each job, so you don't have to refresh your memory every\ntime you try and do something over again.  And you'll always get a\nconsistent result, too.  But having a policy and a method for saving\nyour JCL is actually a very big part of this (more general) topic, of\nsaving your stuff, when you've already done the job right.\n\n      Over a period of years, I have watched many other systems\nprogrammers work, and I know that everybody has different habits,\nespecially when it comes to the topic of saving JCL that was previously\nused.  However, there are common threads in everyone's habits, and I\nthink that this subject of saving JCL is well worth taking some time\nboth to think about, and to talk about.  I'll tell you about some of the\nthings I've seen, and what I do myself.  But I'd also appreciate it if\npeople email me and show me their suggestions as well.\n\n      JCL is used to execute (sometimes complicated) programs that run\nin batch.  And due to the fact that these programs must often be called\nupon to carefully perform very detailed tasks, they therefore are\nendowed by their creators with a fairly involved set of controls in the\nform of keywords.  Often those keywords have to be precisely specified,\nor the result you desire will not be obtained.  For example, consider\nthe job of the program ADRDSSU (DFDSS) to move a bunch of datasets from\none disk pack to another.  If you leave out just one keyword, this job\nwill not work properly.  For example, the datasets might be properly\ncopied and recataloged, but the old datasets on the old pack would be\nuncataloged but not deleted.  If that is not the result you want, it\nwould be nice to keep a sample of the correct JCL handy.  If it worked\nonce, it will probably work again.  When you re-run the old JCL for a\nnew group of datasets and different disk packs, but with the same\nkeywords, you'll still be almost sure that the job will run similarly to\nthe way it did once before.\n\n      Before we get into details, I feel it's worth mentioning one other\nfact which is obvious, but we don't think of it.  Look at software\nutilities as if you were the writer, and not the user.  Try to remember\nthat since software programs are often written to do complicated jobs\nwith multiple choices, the software writers and designers have to invent\na usable set of controlling keywords for each utility they write.  It\nisn't always easy for them to make the controlling keywords easy to\nlearn and use.  This was the topic of my November 2003 column called\n\"Making Life Complicated\".\n\n      So for us now, the point is that often the software writers were\nnot so successful in making their utility controls easy to learn.  And\ntherefore it might be hard to remember every controlling keyword which\nis necessary.  If you leave out one keyword in some execution JCL or in\nthe control of a TSO command, the whole darn thing won't work.  It's\nalmost like having a bug in a program, and often it's almost as pesky as\nfinding a bug, to figure out what went wrong.  So our recommendation is,\nthat if you got it right at least once, save all the information about\nwhat you did.  You'll be very glad later.\n\n\nSAVING YOUR JCL\n\n      There are two aspects to saving your JCL.  The first one is saving\nit, and deciding how many copies of similar JCL that you want to keep.\nThe second one is finding the appropriate JCL for a job you want to do,\namong a set of JCL samples that you've already saved.  If you've got a\ngood \"finding method\" then it'll be easier to save more copies.  If you\ndon't, then you'll probably want to save as little as possible, but then\nyou'll be more likely to be burned by not getting the keywords right,\nbecause you've saved too few examples to cover the ground.\n\n      I guess that a big issue is WHERE to save your old JCL.  I put\nmine in a plain pds, rather than in something like a PANVALET library.\nPds'es are easier to back up (using IEBCOPY or the TSO XMIT command) and\nit is easier to find stuff there, using either ISPF Search-For or the\nfree PDS command (from File 182 of the CBT MVS Utilities collection --\ndo a google search for the words \"CBT Tape\").  With PANVALET you have do\nsome kind of ++SCAN, if you're searching for data by its content, rather\nthan by member name.  I make my JCL pds big, because I've got a good\n\"finding method\".  For example, the JCL pds from one place where I\nworked for 6 1/2 years, has 2286 members, and I still have it.  The JCL\npds from another place where I worked for nearly 5 years, has 1522\nmembers.  My current JCL pds has 751 members, as of this moment.  If you\nneed more than one pds, you should certainly arrange that, but keep the\nnames trackable, so you'll know where to look when you need to find the\nappropriate JCL sample.\n\n      My boss at the first place (the 6 1/2 year one) used to complain\nthat he could never find anything in my JCL pds.  That's because he\nsteadfastly refused to learn how to use the PDS command package.  Back\nthen, ISPF did not offer the luxury of having partial member lists (I\nthink that concept was invented by Steve Smith in the PDS command\npackage, and everybody else adopted it later.)  My former boss was\noverwhelmed by having so many names to look at, in the member list.  And\nafter that, even if there were many similar but descriptive member\nnames, like IEBCOP01, IEBCOP02 and so forth, he didn't know which of\nthese he should look at.  I did.  I was comfortable.  He wasn't.  What\nwas the difference?\n\n      First of all, I could search my pds'es by member content, not just\nby member name.  For example, if there was a sample IEBCOPY execution\nthat had a member name of FLUBBUB, I could easily find it using a PDS\nsubcommand in ISPF mode.  The command is:  FIND : /PGM=IEBCOPY/\nTHEN(MEMLIST) where the colon (:) means \"look in all members\".  The\nresulting partial member list would yield all members containing the\nstring \"PDM=IEBCOPY\", even if the member name was FLUBBUB.  And it's\nmuch easier to search members in a partial member list than in a very\nlong list.  See?  For me it was easy!\n\n      Of course, when you design this, you have to figure if the JCL\narchiving method will only be used by you, or it will also be used by\nothers.  Other people will not be as familiar with the tools you are\nfamiliar with.  So you have to take that into account.\n\n      The other thing is portability.  Using the OUTDSN keyword of the\nTSO XMIT command makes it easy to carry a pds with you, in sequential\nFB-80 format that can be downloaded to a PC and uploaded from a PC.  It\nisn't that easy to back up a VSAM dataset with REPRO or some other\nutility, although it's quite possible too.  So, if your archive was in\nVSAM format, like with the very unique ARCHIVER facility from Rick\nFochtman in CBT Tape File 147, it might not be so easy to obtain a\nbackup copy of it.  This is something to take into account, ahead of\ntime.  Using a PDSE, rather than a pds, is also a factor.  You never\nknow where you'll have to restore the data, and with many older MVS\nsystems, you might have a hard time getting a PDSE restored onto them.\nSo it helps to DESIGN your JCL archive(s) and not just create them\nhaphazardly.  But if you've already created them haphazardly, you should\ntake some time to redesign them and reorganize them.  You'll be VERY\nthankful you did this, later on.\n\n\nCOLLECTING GOOD ADVICE\n\n      JCL isn't the only thing you can save.  You can save instructions\nand advice about \"how to do stuff right\".  One of my former colleagues\nclaimed that he had a bad memory, so he would always write MANY details\nabout how EVERYTHING got done, in pds members.  Whenever I had to follow\nhis act, I always appreciated this.  After all, he DID the stuff before,\nand I didn't.  If his memory was bad, mine (nonexistent) was even worse!\nSo I was very grateful that he was so organized, and he wrote so much\nstuff down.\n\n      As a result of my contact with this fellow, I was motivated to\ncreate a \"how to\" file on the CBT Tape, which would not contain programs,\nbut which would contain a growing collection of miscellaneous advice,\nexecution JCL, and all kinds of \"how to\" knowledge.  Sometimes, you can't\npay enough money to get advice like this.  If, for example, a certain\nproduct won't install correctly unless you know a trick, you can save\nyourself many hours of work, if someone tells you the trick beforehand.\nI wanted to collect as much of this kind of stuff as possible.  So File\n570 of the CBT Tape is one place to try, if you need advice about how to\ndo something.\n\n      If you were fortunate enough to install a ServerPac from IBM, it\nwould be a very helpful thing if you made a pds of all the generated\njobs and advice, from the \"installation jobs\" section of the dialog.\nThere might be 160 or so members there, but if you take the time to make\npds members of them all to save for later, you will be very grateful.\nThese members are full of practical \"how to\" knowledge, because you use\nthese jobs to construct an actual MVS system from scratch.  There's a\nlot of good JCL here.  For example, in a \"complete system replacement\"\nexecution of a ServerPac, the ALLOCDS job shows you working JCL about\nhow to allocate ALL of the necessary system datasets for MVS.  And you\nare pretty sure that this JCL should work properly.\n\n      As a tip in constructing a pds member from a \"browse-only\" doc\nmember from a ServerPac installation jobs list, go to the ISPF command\nline and type TSO ISRDDN.  Then EDIT the CPPTEMP1 or CPPTEMP2 ddname,\nand you will be able to use the CREATE subcommand of ISPF EDIT to make a\nreal pds member out of that material.\n\n      Another good source for such JCL is in File 434 of the CBT Tape\nfrom Mark Zelden.  These are in his ONEPAK** and TWOPAK** members, which\nhelp you construct a standalone one-pack or two-pack IPL'able MVS\nrecovery system, from your current production system.  A lot of good JCL\nis to be found in these members, and you can use the pieces, when you\nneed to build an MVS dataset later.\n\n      I would suggest (if you aren't already doing this) that you should\nmake your own pds or sequential member, just for containing advice.\nPretend that you have a bad memory, even if you have a good one.  Look\nat a member of File 570 like SYSDOCB (from Bruce Bordonaro) if you would\nlike to see one example of what you can do.  If you have one of these\ndatasets already, I'd appreciate it if you would email it to me, so I\ncan add it to File 570 and use it to help everyone else.  Don't hold\nback, even if you think your stuff is too system-specific.  Someone else\nmight have the same actual system need, and they will benefit from your\nparticular and specific experience.  That's what this collection is for.\nIt is to help in specific situations, to show you how to solve specific\nproblems or do a specific job.\n\n\nSUMMARY\n\n      In our particular field of MVS sysprogging, we might go several\nyears before we have to do a specific task twice.  But when we need to\nget it right, we can't afford to make a mistake and have a system\ncomponent fail afterward, just because we got a utility control keyword\nwrong in the JCL.  So it behooves us to make it our business to save all\nJCL that has been proven to work.\n\n      Sometimes we have done an install of a product, and we needed to\nlearn some tricks to get it done.  We might have to re-install or fix\nthe same product, a couple of years later.  In that case, it is surely\nhelpful to have written down (in a dataset that you still have with you)\nwhat needed to be done then.  So you should do it always, and not ever\nhave to trip on the same thing twice.\n\n      File 570 of the CBT Tape collection contains a lot of this advice\nalready, but it is only from a few sources.  We want this collection to\ngrow.  So please look it over, and see if you have something to add.\nEmail it to me, and I'll see to it that your stuff gets added to the\ncollection, so someone else can find it, and get this same kind of help.\n\n      I hope that this month's piece will prove useful in making your\nwork easier.  Please join me again here, next month.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0509SE": {"ttr": 28170, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x05%\\x0f\\x01\\x05%\\x0f\\tR\\x01\\\\\\x01\\\\\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-09-07T00:00:00", "modifydate": "2005-09-07T09:52:04", "lines": 348, "newlines": 348, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         SEPTEMBER 2005\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.\n\n\nPOWER VERSUS SAFETY\n\n      I became a systems programmer (many many years ago) after having\nbeen an applications programmer, and the first thing I noticed when I\nmade the switch, was that basically (within some limitations) I didn't\nhave to ask anybody for \"authority\" anymore.  The \"systems doctor\" was\nexpected to fix the system whenever any repair or change was needed, and\nfor the most part, once I got my bearings and my tools together, I found\nthat I could \"cut through the ice\" whenever I needed to.  The\napplication programmer mentality of \"do I have permission to access\nthis?\" basically flew out the window when I became a sysprog, and\neventually it became a distant memory to me.  I was only reminded of it\nafterwards, when I would speak to an application programmer about\nsomething.\n\n      This is not to say that I could do anything I wanted to, using my\nemployer's system.  I was there to protect and preserve, and to keep the\nsystem running properly and efficiently.  I was not there to change it\nagainst their will, or to break it, God forbid.  In other words, my\nmandate was to use the power wisely.  And therefore I needed to have the\npower in the first place, perhaps to a greater extent than most of the\nother people who worked there.\n\n      So this brings us to today's topic.  I want to talk about the\ngeneral idea of how much power should be put into our tools, but also\nHOW the power should be put in, to minimize risk.\n\n      If we encounter a situation and we know what we're doing, we\ncertainly want to be able to do what it takes, to get the job done\neasily, efficiently, and accurately.  But on the other hand, we don't\nwant to expose ourselves to damaging the system by entering some\ntypographical error, and killing something major.  Our tools should not\never let us do that, easily.  The bottom line is that our tools should\nhave reasonable and decent safeguards in a normal situation, but they\nshould still leave us free to do something unusual or even quite\nbizarre, if the situation genuinely calls for it.  That is my general\nopinion on this subject, if I'm ever asked to put it into one sentence.\n\n      Of course it makes a difference if you have the flexibility of\nwriting the tools yourself, or if you are using commercially written\ntools, which have already been written for you.  You can't change a\ncommercial vendor's code--you can only submit a \"change request\" to the\nvendor, and it might not be listened to.  Nevertheless, in either case,\nI feel it is important for every sysprog to spend at least SOME time,\nthinking about this general idea of \"power versus safety\" in tools,\nbecause it will sharpen you up, and you'll certainly learn how to use\nall of your tools much better in either case, whether they be\nuser-written, or commercial.  We'll now show you a specific case of a\nspecific tool, that will illustrate this entire concept.\n\n\nCDSCB VERSUS A DIRECT ZAP TO THE VTOC\n\n      I'll start the discussion with an illustration of a specific tool\nthat has a lot of power, but which is still pretty foolproof, so we see\nthat we don't always have to sacrifice power to achieve safety.  The\ntool is a free TSO command called CDSCB (Change the DSCB).  CDSCB can be\nfound on File 300 of the free CBT Tape collection of MVS tools.  (Do a\nwww.google.com search on \"CBT Tape\".)  I think that CDSCB is a powerful\ntool which still has a high degree of safety, and therefore it comes\nclose to satisfying my idea of making a tool reasonably foolproof, but\nstill giving it a lot of capability when you really need to have it.\nCDSCB was written by Bill Godfrey, and updated by other people since,\nnotably Greg Price.  A version of CDSCB which uses RACF for\nauthorization checking to see if you're entitled to use it, is found on\nCBT Tape File 301 (adaptation by Mike Cleary).\n\n      CDSCB performs the trick job of \"zapping the VTOC entry\" of a\ndataset on disk, to change the dataset's properties.  For instance, one\nthing you can do by zapping the VTOC, is to change the size of the\nsecondary extents allocation of a dataset, telling the \"volume\nmanagement\" component of MVS how much space should be allocated in each\nnew extent, whenever the dataset needs more extents.  There are actually\ntwo fields in the Format-1 DSCB which do this--one of them is a raw\nnumber, and the other one says whether that number refers to TRACKS,\nCYLINDERS, or BLOCKS.  This information resides in the Format-1 VTOC\nentry for the dataset, and if you zap the VTOC entry to a different\nvalue, the change will be permanent.  So obviously, you can't afford to\nmake a mistake.\n\n      A tool (like CDSCB) which formats the fields of a Format-1 VTOC\nentry, and which works at the \"field level\", will do a better job than a\ntool (like AMASPZAP) which forces you to find the correct field in the\nVTOC entry yourself.  If you use CDSCB, you'll always zap the correct\nfield (although not necessarily with the correct value).  If you use\nAMASPZAP, you might change the wrong field altogether, and cause real\nhavoc and damage to the dataset.\n\n      So why is all of this useful, and why would you feel that it is\nnecessary to do this?  A typical situation is when IBM's shipped dataset\nsecondary space allocations have to be changed.  For example, when IBM\nships a new system, the secondary extent values for their DLIB datasets\nmight be very small, often set to only a track or two for tens or\nhundreds of DLIB datasets.  This makes it difficult for SMP/E ACCEPT\njobs which add a lot of maintenance, to run cleanly later.  They bomb\nwhen each dataset runs to 16 extents, many of them only a track or two\napiece.\n\n      To change the secondary allocation of a group of datasets, you can\nset up a TSO-in-Batch job which runs CDSCB APF-authorized (see CBT Tape\nFiles 185 and 186 for help with how to do that), and which runs CDSCB\nagainst each dataset which has to be changed.  See Figure 1 for an\nillustration of some JCL that runs CDSCB as a TSO command in batch, to\ndo this job.  You can run CDSCB against hundreds of datasets on your\nDLIB volumes, and fix all their secondary extents, exactly the way you\nwant, so the MASS ACCEPT jobs don't blow up later because of \"lack of\nsecondary extent space\".  For some syntax rules on how to run the CDSCB\nTSO command, see Figure 2.\n\n      Just to complete the picture of what we're up against when we\nhave to zap a Format-1 VTOC entry for a dataset, I've included Figure\n3, which shows a \"raw\" Format-1 DSCB entry (presented to us by the fine\nFullscreen ZAP program from CBT Tape File 300) with none of the fields\nformatted.  And I've also included Figure 4, which shows the same data\nas formatted fields, which of course, are easier to find and change\naccurately.\n\n      By showing you what CDSCB does in its specific area, I'm trying to\njog your mind to think of other tools in other areas, which may be more\nfoolproof than the ones you are currently using.  If you find yourself\nrepeatedly doing some tricky and delicate manipulations to system data,\nmaybe you can search for a program or write a program that does the same\njob, but with less risk, and which is less prone to error.  Or you can\nemail me, or email IBM-Main or another news group, and ask the people\nthere, if anyone knows of a less risky tool which can help you.\n\n\nHOW MUCH FLEXIBILITY SHOULD YOU LEAVE IN THE TOOLS YOU WRITE?\n\n      As I said before, even if you don't write your own tools, you\ncan still think and philosphize about this subject.  The activity of\nthinking in this direction, will sharpen you up a lot.\n\n      I recently had to write a syntax checker for IBM tape volser\nnames.  You would code a volser name of up to 6 characters in some JCL,\nand my program would try and make sure that the volser name was\nacceptable to MVS, before inserting it into a VOL1 label for a new tape.\n\n      The IBM tape label manual (\"Using Magnetic Tapes\" - SC26-7412)\nsays that all alphanumeric characters, and national characters, special\ncharacters, and the hyphen are acceptable in volume serial names.  So my\nidea of running a proposed volser name through a translate table which\nconverted invalid characters to blanks, might work out well, but if I\nrestricted the table too much, it might convert a printable character\ninto a blank in the middle of the volser name, and that would NOT be\nacceptable.  So I decided to just include all EBCDIC printable\ncharacters as unchanged, uppercase all lowercase characters, and leave\nit at that.  I couldn't be too exact in following \"the IBM rules\" or I\nmight run into a different problem.  But in doing this, I would allow\nyou to code (possibly) invalid characters into a volser.  My dilemma\nwas:  \"How exact should you be?\"\n\n      Of course, I could have taken a different approach, and I could\nhave rejected any questionable character by substituting a question mark\nthere.  Then I'd stop the job and and ask you to fix it up and run it\nagain.  But this wasn't possible to do in my specific case.  The\nrequirement was that I had to place a volser into the new tape the first\ntime, without allowing any reruns.  So I did my best, even though I\nallowed a remote possibility of entering something invalid into the\nvolser.  I had to weigh \"foolproof\" against \"power\" a different way.  I\nfigured that the possibility of introducing a weird character into a\nvolser was remote.  Most people do not make that type of typographical\nerror often.  So in that case, I had to compromise on \"safety\" just a\nbit, and opt for \"power\".\n\n\nSUMMARY\n\n      Every programmer who writes system level tools, has to make\ndecisions about \"power versus safety\".  It is very useful for us to\nthink about this subject too, whether we write our own tools ourselves,\nor we just use tools written by others.  We are the \"system doctors\" and\nwe make very important adjustments which affect the very health of the\nsystems we protect.  If we find ourselves doing some very delicate\nsystem-level job, and we sense that a slight mistake might put the\nentire system at risk, we might look for a better and more foolproof\ntool or method which can accomplish the same job in a less risky way.\n\n      If you write your own tools, you might decide to compromise the\n\"safety side\" and allow your tool to do something bizarre and \"push the\nenvelope\" a bit.  Commercial tool vendors sometimes do this too, but in\nsuch cases, they make a decision to protect the tool against an\nunskilled user, by requiring a password for certain more risky\nfunctions, or by employing some other \"safety net\".\n\n      The bottom line is that every tool we work with, has decisions\nbuilt into it, which relate to the question of \"power versus safety\".\nIn our own lives, we might look for tools which give us more power, most\nof the time.  But sometimes, for example when we have to zap fields in a\ndataset VTOC entry, we really want to do that job in as foolproof a way\nas possible.  So we have to be very aware of the big question of \"power\nversus safety\" at all times.\n\n      I wish all of you well, and hope to see you here again, next\nmonth.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   Example of Running TSO Command CDSCB Under\n                       TSO-in-Batch\n\n            CDSCB is an APF-authorized TSO command, which\n            can do its magic in bulk, as follows:\n\n            In the illustration, secondary space for\n            SYS1.ACMDLIB is set to 5 cylinders, and\n            secondary space for SYS1.ACSSLIB is set to\n            45 tracks.\n\n\n//TSOBATCH EXEC PGM=IKJEFT01\n//STEPLIB  DD DSN=my.authrzed.library\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN DD *\n CDSCB 'SYS1.ACMDLIB'  VOL(C4DLB1) SPACE(5)  ALLOC(CYL)\n CDSCB 'SYS1.ACSSLIB'  VOL(C4DLB1) SPACE(45) ALLOC(TR)\n/*\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.   Syntax of the CDSCB TSO Command, which illustrates\n            what it can do.\n\n\n)F FUNCTION -\n  THE CDSCB (CHANGE DSCB) COMMAND MODIFIES A DATA SET'S\n  FORMAT-1 DSCB IN A VTOC.\n\n  SINCE THE FORMAT-1 DSCB CONTAINS INFORMATION CRUCIAL TO\n  A DATA SETS' SECURITY AND INTEGRITY, (AND IN FACT TO THE\n  WHOLE SYSTEM'S SECURITY AND INTEGRITY), THIS COMMAND\n  MUST BE RESTRICTED TO SYSTEMS SUPPORT PERSONNEL.\n\n)X SYNTAX  -\n       CDSCB  'DSNAME'   EXPDT(DATE)  SHR  VOL(VOLUME) UNIT(UNIT)\n                         CREATE(DATE) REFDT(DATE)\n                         DSORG(XX) RECFM(XX) LRECL(XX) BLKSIZE(XX)\n                         ALLOC(TR/CYL/BL)  SPACE(SECONDARY-AMOUNT)\n                         PWR/PWW/NOP/RACF/NORACF\n                         ZAP(OFFSET VERDATA REPDATA)\n  REQUIRED - 'DSNAME'\n  DEFAULTS - NOTHING WILL HAPPEN IF NO CHANGES ARE SPECIFIED.\n  ALIAS    - NONE\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 3.  A raw (unformatted) image of a Format-1 DSCB (VTOC\n           entry for a dataset).  The tool which produced this\n           image is the Fullscreen ZAP TSO command from CBT\n           Tape, File 300.\n\n\n                                 Z  A  P\n\nENTER VALID COMMAND ABOVE OR ? FOR HELP         VERSION=3.2Z 24JUN05\nF/SBGOLOB.B.ASM/\n\n00000  >E2C2 C7D6  D3D6 C24B   C24B C1E2  D440 4040   |SBGOLOB.B.ASM   |\n00010   4040 4040  4040 4040   4040 4040  4040 4040   |                |\n00020   4040 4040  4040 4040   4040 4040  F1C3 C1D9   |            1CAR|\n00030   E3C7 F100  0169 0010   0000 0001  0000 C9C2   |TG1...........IB|\n00040   D4D6 E2E5  E2F2 4040   4040 4069  00D4 0000   |MOSVS2     ..M..|\n00050   0000 0200  9020 6D10   0050 0000  0082 8000   |......_..&...b..|\n00060   01C2 0A8C  02C1 E800   0001 0002  7800 0303   |.B...AY.........|\n00070   4000 0200  0000 0000   0000 0000  0000 0000   | ...............|\n00080   0000 0000  0000 0000   0000 0000              |............    |\n\n\n\n\n                         *****  SCAN MATCH  *****\nOFF: 0000 (     0) ADDR: 00000 (       0) DSN: VTOC FOR CARTG1\nLEN: 008C (   140) BASE: 00000 (       0) CCHHR: 000000020C TTR:  00010C\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 4.   A formatted image of the same dataset shown in Figure 3.\n            This image was produced by the vendor product, StarTool\n            FDM from Serena.  The option was FIXPDS, followed by\n            the option of \"Update the Format-1 DSCB\".\n\n\n---------------------- FIXPDS: Format 1 DSCB Modification ---------------------\nOPTION  ===>\n\nCurrent - DSN=SBGOLOB.B.ASM,VOL=SER=CARTG1  MEM=  -----------------------------\n DSCB1 at 000000020C\n                                                                   More:\n Caution: many of the fields of the Format 1 DSCB can not be changed without\n          compromising data set integrity.  For more information using field\n          level help, place the cursor on any of these items and press HELP\n\nOFF,LEN   LABEL      HEX VALUE       DESCRIPTION\n(0,44) DS1DSNAM ===> SBGOLOB.B.ASM\n(2C,1) DS1FMTID ===> F1              Format identifier\n(2D,6) DS1DSSN  ===> C3C1D9E3C7F1    Data set serial name\n(33,2) DS1VOLSQ ===> 0001            Volume sequence number\n(35,3) DS1CREDT ===> 690010          Creation date\n(38,3) DS1EXPDT ===> 000000          Expiration date\n(3B,1) DS1NOEPV ===> 01              Number of extents on volume\n(3C,1) DS1NOBDB ===> 00              Number of bytes used in last directory\n(3D,1)          ===> 00              Reserved\n(3E,6) DS1SYSCD ===> C9C2D4D6E2E5    System code\n(44,7)          ===> E2F24040404040  System code (last 7 characters)\n(4B,3) DS1REFD  ===> 6900D3          Date last referenced\n(4E,1) DS1SMSFG ===> 00              System managed storage indicators\n(4F,1) DS1SCXTF ===> 00              Secondary space extension flag\n(50,2) DS1SCXTV ===> 0000            Secondary space extension value\n(52,2) DS1DSORG ===> 0200            Data set organization\n(54,1) DS1RECFM ===> 90              Record format\n(55,1) DS1OPTCD ===> 20              Option code\n(56,2) DS1BLKL  ===> 6D10            Block length\n(58,2) DS1LRECL ===> 0050            Logical record length\n(5A,1) DS1KEYL  ===> 00              Key length\n(5B,2) DS1RKP   ===> 0000            Relative key position\n(5D,1) DS1DSIND ===> 82              Data set indicator flags\n(5E,4) DS1SCALO ===> 800001C2        Secondary allocation type and amount\n(62,3) DS1LSTAR ===> 0A8C02          TTR of last used track and block of data\n(65,2) DS1TRBAL ===> C1E8            Bytes remaining on last track used\n(67,2)          ===> 0000            Reserved\n(69,10)DS1EXT1  ===> 01000278000303400002  Extent 1 in XX00CCCCHHHHCCCCHHHH\n(73,10)DS1EXT2  ===> 00000000000000000000  Extent 2 in XX01CCCCHHHHCCCCHHHH\n(7D,10)DS1EXT3  ===> 00000000000000000000  Extent 3 in XX02CCCCHHHHCCCCHHHH\n(87,6) DS1PTRDS ===> 0000000000      CCHHR of any associated Format 2 or 3 DSCB\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0510OC": {"ttr": 28421, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00W\\x01\\x05%o\\x01\\x05&o\\x10G\\x00\\xf7\\x00\\xf8\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2005-09-13T00:00:00", "modifydate": "2005-09-23T10:47:57", "lines": 247, "newlines": 248, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          OCTOBER 2005\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.\n\n\nTHE 30TH ANNIVERSARY OF THE CBT TAPE\n\n      We would never have thought that MVS has been here so long, had we\nnot noticed that so many of our colleagues are retiring.  After all,\nisn't computing a \"new\" thing, only for \"young\" people?  Of course, when\nit comes to PERSONAL computing, that kind of computing is relatively\nnew, having come out for the first time in the late 70s and early 80s.\nBut computing on the big machines that are owned by huge companies, is a\ngood 20 years older, and it is very easy to forget how long mainframe\ncomputing has really been around.  Today, we'll talk about one of the\nMVS Systems Programmer mainstays which has already been here for 30\nyears.  (Would you believe it?)  This is Arnold Casinghino's CBT\n(Connecticut Bank and Trust Company) MVS Utilities Tape.\n\n      Arnie used to work for the (now defunct, original) Connecticut\nBank and Trust Company in Hartford, Connecticut.  (There is now a new\nstartup bank by the same name, not to be confused with the old one.)\nAnd that's what \"CBT\" used to stand for.  (Now it stands for nothing\nspecial.  I once thought of calling it \"Casinghino's Big Tape\".)  Arnie\ntold me that the CBT Tape got started around 1975 in their Hartford\narea user group, which consisted of 13 companies.  The companies used\nto share their usermods for each new release of the MVS system that\ncame out, so eventually, Arnie and they decided that it would be easier\nto put all the stuff on one tape and circulate it around.  Once the\ntape was made, Arnie posted its contents on a bulletin board at the\nnext SHARE conference, and the rest is history.  The tape grew and\ngrew.  It is still growing.\n\n      After I took over the proprietorship of the tape in 1990, Arnie\nrevealed to me that the Connecticut Bank and Trust Company did not let\nhim advertise for contributions.  If somebody contributed, that was\nfine.  But Arnie wasn't allowed to go out and solicit new items.  The\nfact that when I took over the tape, there were already 472 files there,\ntestifies to the unbelievable way in which the CBT Tape grew to service\nthe MVS community.  It really caught on.  And today, 148+ versions later\n(the current version number is 469), the CBT Tape is over two and a half\ntimes as big, with the CBT Overflow Tape being almost the same size.  We\nare all very happy that the MVS world is continuing to contribute to and\nbenefit from this facility.\n\n       At the end of 1998, Sam Knutson proposed to create a web site as\na new home for the CBT Tape materials, which had been distributed on\nreal tape by NaSPA ever since the Connecticut Bank and Trust Company\nfolded and I became the editor.  The new medium proved to be the wave of\nthe future, as contributions began pouring in over the Internet from all\nparts of the world.  Since previously, contributors had to mail a tape\nor cartridge in to either Arnie or me, international contributions had\nbeen limited.  But once the Internet communication of \"CBT Tape\nbusiness\" began in earnest, it was just as easy for someone in Italy or\nIndonesia to send in a contribution as for someone in the U.S.  So the\ninternational representation of contributors on the tape today, is very\nextensive.\n\n       Sam Knutson and I currently divide the CBT Tape maintenance work\nbetween us.  Sam Knutson is the webmaster and keeper of the CBT Tape web\nsite, so all questions concerning the web site should go to Sam K.  I'm\nin charge of managing the contributions and editing the actual tape\nfiles and materials.  So questions concerning the tape contents and file\nmaterials should go to me.  At the CBT Tape site home page, you can find\nbuttons to click, to send an email to either of us.  It's either\nsknutson@cbttape.org for Sam K, or sbgolob@cbttape.org for me.\n\n\n\"TAPE\" ORGANIZATION\n\n       Believe it or not, with all the other media around, the CBT Tape\ncollection is still representable as a physical tape, or actually two\ntapes.  The regular CBT Tape has over 720 file slots, almost all full.\nThe \"CBT Overflow Tape\" has close to 300 full file slots.  The \"Regular\nCBT Tape\" has just exceeded the capacity of a 3480 IDRC cartridge, and\nif you'd want to fit it onto a single tape now, you'd have to use a\n3490E.  The Overflow Tape still fits onto a 3480 IDRC cartridge, but\nbarely.  There is a program on CBT Tape File 229 called COPYNLNL, that\ncan split a CBT tape into two separate tapes by copying some of the NL\nfiles onto one output tape, and the rest of them onto another tape.\n\n       Alternatively, you can obtain an AWS-format tape image of the\nentire CBT Tape at the CBT Tape web site, or you can obtain it from Sam\nKnutson on cd-rom, and use the VTT2TAPE program from CBT File 533, to\nmake a real tape out of it, if your site has a tape drive.  Actually,\nmost people download single CBT Tape files from the CBT Tape web site,\nand that's how they get the goodies.  If you do a www.google.com search\nfor \"CBT Tape\", you'll find the CBT Tape web site very easily.  All\nmaterials there are free, and you don't have to be a member of any\norganization to obtain them.  It's a wonderful service for MVS\npractitioners everywhere, and entirely volunteer.  It is sort of (but\nnot exactly) like \"Open Source\", but it is much older.\n\n       CBT Tape and CBT Overflow Tape file updates, that are developed\nin between the cuts of a full new version of the tape(s), are posted to\nthe \"Updates\" Page of the CBT Tape web site.  I feel it is very\nimportant to know about the Updates Page, because that's where the\ncurrent action is, and that's what I deal with, almost every day.\n\n       Let me explain.  When you go to the CBT Tape web site, there are\nquite a few categories (on the left side of the home page) that you can\nclick on.  One of them is called CBT, and it contains individual files\nfrom the latest \"official\" version of the entire (Regular CBT) Tape.\nAnother one is called Overflow, and there you can get the latest\n\"official\" version of the CBT Overflow Tape files.  But we cut new CBT\nTape versions only once every several months nowadays, and the Overflow\nTape versions are cut even less often.  So all the new and updated stuff\ngoes onto the Updates page, and my recommendation is to look at the\nUpdates page often.\n\n       Since I'm in charge of the Updates page contents, I can tell you\nthat usually the stuff there is quite reliable.  I try not to post any\nstuff there which is not already going to go onto the regular tape.  Sam\nKnutson's explanation at the top of the Updates page is pretty\nrealistic.  Most of the files there are ready to use, or I won't post\nthem.  However, the authors and I sometimes have a back and forth\nconversation for a while, and I keep posting new (and more \"fixed\")\nversions of their work on the Updates page, until they are satisfied.\nGenerally, I try to wait until all pending contributions are somewhat\nstable, before cutting a new version of an entire tape.  But the cutoff\npoint can be arbitrary (like a few weeks before SHARE), and so it often\nhappens that a better version of a package, with more bugs fixed, can be\nfound on the Updates page, than on the CBT page.\n\n       On the current CBT Tape files that I post nowadays, there is\nusually a member called $$$#DATE, which can be regarded as a \"version\nnumber tag\".  Every time I post a new version of the software on Updates,\n(and these get carried to the \"official\" CBT Tape cuts too), I create a\nnew version of this member, which contains a time and date stamp, and\nthe total number of (usually 80-byte) records in the file.  So if there\nis a question as to which version of a program you are running, and you\nstill have the \"install file\", you can go to this member and find out\nexactly when you got your code.\n\n       For your information, in case you want to know about the tools I\nuse in creating the CBT Tape files, you can find them on CBT Tape File\n006.  The GENDAT CLIST used to create the $$$#DATE member is there, as\nare the DOCFILE and DOCFILX members which fix the @FILEnnn members of\neach CBT Tape file.  The CBTUPD program, which breaks CBT Tape File 001\n(the doc file) into a pds, is there too.  I maintain File 001 as a pds\n(with currently over 1200 members), and you can create that same pds for\nyourself, using the CBTUPD program.  It could make it a lot easier for\nyou to look up the documentation about a particular CBT Tape file.  File\n006 is very interesting, and you might learn something useful by taking\na look at it.\n\n\nRECENT CBT TAPE ACTIVITY\n\n       The phrase \"too numerous to mention\" is quite accurate in\ndescribing recent CBT Tape activity.  The most recently cut CBT Tape\n(Version 469) had 50 file updates, which is an all-time record for\nthe number of updates in a single CBT Tape version.  Some of the new\ncontributions are entirely different from any previous contributions,\nsuch as the JumpList programmer's workbench from Joseph Caughman, which\nis on File 717.  File 719 contains a completely novel DASD dump/restore\nprogram from Greg Smith.  Files 721 and 722 contain the ChangeWiz and\nFileWiz packages from Shirley Huhtanen, which are very sophisticated\n\"library member change\" and \"file compare\" packages.  Bill Sweeney, an\n\"old MVS hand\", has contributed a big collection of his utilities on\nFile 720.  Garry Green has contributed File 718, which provides TSO\nLOGON exits that allow you to LOGON to any subsystem.\n\n       On the Updates page, for a sampling, Harvey Wachtel has updated\nthe SETPW2 command from the RACF SHARE tape, to allow an administrator\nto permanently change any RACF user's password when necessary.  This is\non File 007 (not James Bond-esque at all - quite routine).  Greg Price\nhas come up with a new Version 39.3 of REVIEW (CBT File 134) (the famous\nMVS file browser) again, and this version sports the capability of\nISPF-like editing that has been much improved.  The editing is triggered\nfrom a REVIEW screen by entering UPDATE on the command line, or from a\nmember directory by entering \"U\" next to a member name.  You don't need\nISPF to be up, to use either the browsing or editing capabilities of\nREVIEW, but if ISPF is up, REVIEW will take extra advantage of it.  I\nhave contributed some updates to File 533, which contains programs to\nconvert AWS-format and FLEX-ES (R) FAKETAPE-format virtual tapes to real\ntapes, and vice-versa.\n\n\nEFFECTS OF THE CBT TAPE ON MVS\n\n       It can safely be said, that the CBT Tape has been a major force\nin triggering enhancement suggestions, improvement suggestions, and \"MVS\nRequirements\" to IBM.  If somebody developed a tool, or a mod, which\ncould be incorporated into the MVS Operating System, but which was not\nyet there, though people were already using it, it was just a matter of\ntime before there was a clamor for IBM to pick up the enhancement.  And\nmany of the SHARE and GUIDE requirements were the direct result of the\nfact that there already existed a tool or a mod on the CBT Tape to do\nthe job.\n\n       I can't begin to list the enormous number of features of MVS, now\ntaken for granted, that started from CBT Tape contributions.  I'll just\ngive one example.  This is the \"partial pds member list\" in ISPF.  ISPF\nused to only list ALL the members of a pds in an EDIT or BROWSE screen,\nand it was impossible to isolate and display only SOME of the members.\nSteve Smith, in the PDS Command package on File 182 of the CBT Tape, not\nonly invented partial member lists, but he also invented the massive\nmulti-function ISPF member list, where you could BROWSE or EDIT or do\ntwenty-odd other functions from the same member list, without having to\nget out of it.  Other ISPF-based packages, such as ISOGON's SPIFFY,\npicked up on this idea, and eventually it became a part of ISPF itself.\nThis is only one of hundreds, or even thousands, of examples where\ncomponents of MVS have gotten improved from the CBT Tape based\ncontributions and tools.\n\n\nAFTERWORDS\n\n       The CBT Tape, started by Arnold Casinghino, has already been\naround, and helping MVS'ers, for just about 30 years now.  It's amazing\nhow time flies when you're having fun!  Having grown from the Hartford\nArea MVS Users Group, through SHARE, to a worldwide supported\ninstitution, the CBT Tape collection of software, utilities, mods, and\nassorted goodies supplies MVS shops throughout the world with much extra\nequipment and advice, to make our job easier through sharing.\n\n       It cannot be forgotten that for nearly 10 years, NaSPA was the\nprincipal means for distributing the CBT Tape materials, and I want to\nexpress our heartfelt thanks to Scott Sherer and the entire NaSPA crew,\nfor their enormous role in continuing the chain of MVS support through\nthe CBT Tape.  Between the time just before I took over the tape, in\n1989, and continuing until the time when we started the web site, at the\nbeginning of 1999, everybody got the CBT Tape materials principally\nthrough NaSPA.  Marty Kuntz at Deluxe Check Printers was contracted to\nduplicate the tapes, and most of the original tape distributions for a\nlong time, were done in this way.  Thanks, Scott!  This is well deserved\nand long overdue.\n\n       So I am very grateful to also have been a part of MVS history,\nthrough helping to disseminate of the work of thousands of us MVS\npractitioners throughout the world.  For 30 years now, the products of\nthe CBT Tape collection have brightened our environment and aided us\nwith many of the details in doing our everyday work.  I wish all of you\nthe very best of everything, and I hope to see you here again next\nmonth.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0511NV": {"ttr": 28426, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00V\\x01\\x05(_\\x01\\x05(_\\x15\\x16\\x00\\xfa\\x00\\xfa\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-10-12T00:00:00", "modifydate": "2005-10-12T15:16:56", "lines": 250, "newlines": 250, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         NOVEMBER 2005\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.\n\n\nMAKING YOUR WORK SHORTER WITH TOOLS\n\n      I recently had a task to perform, which I was able to \"knock off\"\nin about ten minutes, and which might have taken someone else\nconsiderably longer to do.  The job was greatly shortened by the fact\nthat I had written a tool several years ago, that broke this job into\ntwo steps--one automatic, and the other easy.  Without this tool, I'd\nbet the job would have taken no less than an hour or longer.  So today,\nI'd like to talk about several \"sysprog jobs\" which can be made much\nshorter, provided that we deploy a tool or two.  All these tools are\nobtainable for free, and you can install them one at a time, to add to\nyour arsenal.  An excellent source for free tools is the enormous \"CBT\nTape\" collection that can be found on the web.  Just search in\nwww.google.com for \"CBT Tape\", and you should get there.  You don't\nhave to be a \"member of anything\" or to have any special password, to\nbe able to access and download tools from the CBT Tape collection.\n\n      Now, we'll talk about a few types of tasks, where I've found I can\nsave a lot of time using specialized tools that not everybody knows\nabout.\n\n\nEXTRACTING SOFTWARE FROM SMPPTFIN FORMAT FILES\n\n      I recently needed a newer version of some Assembly macros that\nare normally distributed in several system macro libraries.  I didn't\nwant to affect my system's SMP/E libraries by RECEIVE-ing the\nmaintenance.  In fact, the macro versions I wanted, weren't for the\nsystem level that the production system was at.  I just needed to have\nthese macros alone, so I could cleanly assemble a program using them.\nSince I was entitled to pull PTFs electronically, and I knew which\nnumbers to get, I went and got them, but the only trouble was that for\none macro, almost two million lines of data got shipped to me from IBM,\nin the form of an SMP/E SMPPTFIN-format sequential file.  How was I to\naccurately (and quickly) pull this macro of perhaps 500 lines, from all\nof that data?  I did know the PTF number that my macro was in, but it\ncame shipped along with over 180 prereqs and coreqs.  How could I make\nthis job doable, and do it accurately?\n\n      Fortunately there is a tool, on CBT Tape File 118, which can make\na partitioned dataset out of an SMPPTFIN-format sequential file, with\nthe sysmods (read PTFs) as separate members.  The program, called\nSMPUPD, is admittedly a little kludgey, but if you have the work space\non disk, it sure works great!  SMPUPD simply makes a copy of the\nSMPPTFIN format file, but it adds IEBUPDTE ./ ADD cards before each PTF,\nwith the PTF number as the member name.  And after you have the copied\nfile (which can be a temporary file), you just have to run that file\ninto IBM's IEBUPDTE program and load up a pds with each PTF as a member\nname.  It's very simple and mechanical, once a workable piece of JCL has\nbeen set up.  The SMPUPD program (Assembler version) also has the added\nadvantage that it prints very detailed statistics about the PTFs in the\ninput, and how many lines each one has.  If you want the statistics\nalone, you can do a dry run by executing SMPUPD with PARM=READ for\nread-only operation.\n\n      So I took my two-million-line input, and made a pds out of it.\nThen, I just looked for the PTF number I wanted, as member name, and\nedited it.  In no time, I had the macro that I wanted.  If you want raw\nobject code out of a PTF, you can get it this way, too.  What you do\nwith it afterwards, depends on your needs and your skills.  I've used\nthis technique in the past to linkedit the object deck and get\ndisplacement values out of it, to refit the zaps for a vendor product\nsuch as CA-1 tape management, ahead of time.\n\n      It's quite obvious that circumventing SMP/E processing of SMPPTFIN\nfiles might be very useful at times, especially when software that is\ndistributed by IBM as a PTF or other sysmod might be needed as an\nisolated program, rather than being part of your production system.  You\nmight need to experiment with a different version of a system program,\nthat could have unknown bugs, without compromising the integrity of your\nmain MVS machine.  So in this way, by extracting the needed data from\nthe PTF and putting it together yourself, you can accomplish your goal\nwithout much risk to the system, and without messing up the\ninstallation's SMP/E configuration.  You can take this technique as far\nas your imagination will carry you, as long as you minimize the risks.\n\n\nUSING THE PDS PACKAGE \"FIND-REPLACE\" FACILITY\n\n      The amazing free \"PDS Program package\" from CBT Tape File 182\noffers a \"string find and string replace\" capability that spans many pds\nmembers.  This facility is so useful, and in my opinion, so under-used\nby the public, that I feel it is very much worth mentioning when it\ncomes to learning about tools that can save you lots of time.  We owe\nthe PDS program largely to the labors of Bruce Leland and Steve Smith\n(in the past) and to John Kalinich (in the present) with many helpers\nalong the way.  If you want to find out A LOT about the PDS command\npackage, refer to my series of articles about most of its subcommands,\noriginally printed in \"Technical Support\" in 1988, and now available as\nmembers $PDSARTx, x=0,1,2,3 in CBT Tape File 182.  I had spent perhaps\n300 hours on the telephone, talking to Bruce Leland and Steve Smith, in\ngathering the information to write those articles.\n\n      For people who have never used the PDS program package, it\nconsists of a \"TSO line mode\" part and an \"ISPF mode\" part.  To use the\nPDS program in TSO line mode, all you need is the load module.  To use\nPDS in \"ISPF mode\" (called ISPMODE by the PDS program internally), you\nhave to have the set of ISPF panels and messages available to your TSO\nsession.  The PDS program is set up at assembly time with a lot of\noptions, one of which is to start ISPMODE automatically (although this\ncan be turned off).  If the PDS program load module was assembled that\nway, you can still execute it in line mode by entering:\n\nPDS dataset.name XISPMode\n\nwhere the XISPMODE keyword will tell PDS not to look for the ISPF stuff\nwhich is the panels and the messages.  All the ISPF panels and messages\nare found in File 182, with instructions (in the $$$INST member) about\nhow to put them in.  The PDS program, properly installed, also can use\nsome extra utilities which can be found in CBT File 296, as well as the\nVTOC command from CBT File 112.  And it can call the REVIEW program from\nFile 134 (source) or File 135 (load).  For a quicker install, we have\njust included a separate member in File 182 (called UTILXMIT) which is a\nload library with all the load modules for the extra utilities that PDS\ncan use, in TSO XMIT format.\n\n      We will not discuss the many capabilities of the PDS command\npackage here.  (The PDS command has over 50 separate subcommands.)  But\nwe will concentrate on PDS's \"FIND\" and \"REPLACE\" (in place) facilities\nfor now.  I do have to add that PDSE support has been added to the PDS\npackage recently, by John Kalinich and Greg Price, and that the new\nrelease number for free PDS, with the PDSE support, is PDS 8.6.  The\ncommercial version of PDS, called STARTOOL FDM, with VSAM support and\nmany other extras, is marketed by Serena Software, Inc.\n\n      The PDS command (in either line mode or ISPMODE) must always point\nat a dataset.  This is a dataset which PDS is going to either examine or\nmanipulate.  If the dataset is a partitioned dataset, PDS has the\ndistinguishing characteristic that it always keeps track of a subgroup\nof the pds members, and that all its actions will go against all the\nmembers included in that subgroup.  Internally, the PDS command calls\nthis group of members the \"current member subgroup\".  The member\nsubgroup can be defined either by means of a RULE using the MEMBERS\nsubcommand (i.e. all members containing the string pattern ABC, defined\nby the rule /ABC), or it may be defined as a list of individual members,\ncalled a SUBLIST.  For a particular pds, the \"rule\" definition can be\nconverted to a sublist, by using the \"SUBLIST\" PDS subcommand.  Since\nthe current member group is referred to in the PDS package by using an\nasterisk \"*\" instead of the member name, the command \"SUBLIST *\" can be\nused to \"convert the current member group definition into a list of\nmember names\" automatically.\n\n      After this necessary introduction to the PDS package, we'll show\nyou some of the time-saving operations that you can do, using its FIND\nand REPLACE subcommands.  Once you know how to use these well, only your\nimagination will limit the amazing things you'll be able to do, and in\nno time flat.  I have to mention here that all \"string replacement\"\nactions done by PDS's REPLACE subcommand, are done \"in place\", so that\nno dataset compression will be necessary afterwards.  FIND and REPLACE\nalso work with load modules, believe it or not.  But with load modules,\nyou have to replace all found strings with an equal length replacement\nstring.  If you also want to find strings in the IDR records of load\nmodules, you have to use the PDS FIND and REPLACE subcommands with the\nDUMP option.  It goes without saying, that all of these operations have\nto be done with great care and responsibility, because of their\nimplications.\n\n\nPDS \"FIND-REPLACE\" WIZARDRY\n\n      Let's start, and say that if you have a JCL pds, and you want to\ndo a global change to a group of its members because a dataset name has\nchanged at your installation, that the PDS package, in either line mode\nor ISPMODE, can do the job for you.  For example, to discover which\nmembers contain the name of the dataset which has to be changed, just\nenter the PDS subcommand (the colon \":\" in PDS stands for \"all members\")\n\nFIND : /old.dataset.name/ THEN(SUBLIST)\n\nand this command will cause PDS to look in ALL the pds members for the\nstring \"old.dataset.name\" and the result will be a sublist of members,\nall of which contain the given string.  Using a slash in the command is\nnot absolutely necessary.  The slash is used here to delimit the\ndefinition of the \"find string\".  Actually, the FIND command just looks\nat the first character where a string is to be defined, and it considers\nthat character as the delimiter.  So if your string itself contains a\nslash, you might use another delimiter, such as a question mark \"?\" in\nspecifying the string to be searched for.\n\n      To change this string, in ALL the members containing it, to some\nother string, you use the REPLACE subcommand of the PDS command.  And\nwhen you use the REPLACE command, you have to now specify TWO strings,\nthe old string which needs to be found, and the new string you'll want\nto replace it with.  In our case, if you've already found all\noccurrences of \"old.dataset.name\" and created a sublist using the above\nFIND subcommand, the proper REPLACE subcommand will read:\n\nREPLACE * /old.dataset.name/new.dataset.name/\n\nAs written, REPLACE will show you all the string occurrences, in all the\nmembers, that will be replaced.  It will only be a dry run.  To make the\nchanges permanent, you add the WRITE parameter to the REPLACE\nsubcommand:\n\nREPLACE * /old.dataset.name/new.dataset.name/ WRITE\n\nand the changes will be permanent, using \"replace in place\" logic.\n\n      Since we're coming to the end of our space for this month, I'll\nmention one more trick before closing.  Suppose that I have a system\nproblem and the system produces an error message, say IEF999I.  I can\nsearch SYS1.LINKLIB and SYS1.LPALIB to see which modules contain that\nmessage, using the PDS FIND command.  Let's say that I've pointed PDS\nto SYS1.LINKLIB as follows:\n\nPDS 'SYS1.LINKLIB'\n\nThen, once this has been done, I use a FIND command to get occurrences\nof the message id:\n\nFIND : ?IEF999?\n\nwhere for illustrative purposes, I've now used a question mark as the\ndelimiter instead of a slash.  PDS will deliver a picture of all module\npieces containing the string IEF999 (I've left the \"I\" off the search\npurposely).  Or, I can also say:\n\nFIND : ?IEF999? THEN(SUBLIST)\n\nand I can examine each of the found members individually afterwards,\nonce I know their names.\n\n      The nice thing about this, is that once I know the module names\nwhich can produce this message, I can search IBM's knowledge base to\ndetermine if there are any PTFs against them.  This method has often\nhelped me to discover the solution to some tough looking problems.\n\n      So I hope that I've given you a taste of some pretty nifty things\nyou can do, if you have learned to use a few of the many free tools that\nare available on the CBT Tape collection (for example).  Besides giving\nyou something to think about, I hope that eventually, these techniques\n(and extensions of them) will be able to save you big gobs of time.\n\n      I wish all of you the best of everything, and I hope to see you\nhere again, next month.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0512DE": {"ttr": 28676, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x051?\\x01\\x051?\\x081\\x00\\xde\\x00\\xde\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-11-09T00:00:00", "modifydate": "2005-11-09T08:31:20", "lines": 222, "newlines": 222, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         DECEMBER 2005\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.\n\n\nALL BEGINNINGS ARE DIFFICULT\n\n      After writing this column for 17 full years, I felt it ironic to\nbe talking about beginnings.  But the real truth is that beginnings are\nwhat accomplishment is all about.  It has to start from somewhere.  And\nonce you get started, then you're on your way.\n\n      MVS Systems Programming is the same way.  When you begin your\ncareer, you have to get your feet wet.  Then you learn more and more,\none thing at a time, until you finally get comfortable working.  You add\nexperience, in the process of being assigned to do more tasks, and it\nkeeps building, until you eventually get to feel that you can handle\nmost anything that'll come along.  Then comes a snag, a completely new\nthing to do, that you haven't ever seen before.  (Remember when UNIX\nfirst came into MVS?)  And you feel you're back to square one.  But\nsince you have confidence that you've been able to do all the work up to\nhere, and since everybody else is in the same boat, it's not as bad now,\nas when you FIRST were beginning.\n\n      Now if you think about it a bit, there are really a lot of\nbeginnings in this whole process.  Every time you learn something new,\nit's actually a new beginning.  Even if you're reviewing something you\nalready know, it's another beginning too, just to put the thought in\nfront of your mind AGAIN.  So it comes out that if you know how to\n\"handle beginnings\" well, then you've mastered a lot of what life\nconsists of.  And it's a plain fact, which everybody knows, that all\nbeginnings are difficult.\n\n\nWHY DOES IT PAY TO KNOW THIS?\n\n      What advantage is it to you, to know the fact that \"all beginnings\nare difficult\"?  Why does just knowing that fact, help you out?  The\nanswer is that since most of our activities include so many\n\"beginnings\", as we mentioned before, if you know that you'll have to\nget over a hump, and that it's inevitable and you can't avoid it, then\nyou'll just reconcile yourself to doing it, and you'll do it.  The other\nway, not knowing that all beginnings are difficult, you'll just grouse\nthat \"things are too hard\" and you'll never get started.  Knowing the\nfact that ALL beginnings REQUIRE that you get over an initial\ndifficulty, will help you accomplish all manner of (great and small)\nthings in life.  And the small accomplishments will eventually build and\naccumulate, to become big ones.\n\n\nAN EXAMPLE\n\n      I'd like to share one of the \"new things\" that I've done in my\nown career, which initially had been difficult to \"get into\", but once I\nwas there for a while, everything went more smoothly.  And actually, if\nyou think about it, probably most of the things which you have done, are\nmuch like this, too.  Looking at this example will surely jog your own\nmemory to recall similar experiences which you have had, where it was\ntough to get started, and even tough to continue, because there was one\n\"beginning\" after another, and they all seemed to be endless.\n\n      This experience which comes to mind, was my first encounter with a\nVTS, or Virtual Tape System.  And you'll soon see why it stuck in my\nmemory so much.\n\n      Our new VTS was an IBM box which simulated tapes using its own\nspecial DASD, and when that DASD would come close to getting full, some\nof it would be backed up (transparently to the user except for recall\nresponse time) to a bank of real 3590 volumes.  MVS would think that the\nVTS is a library of tapes and a bank of 3490E tape drives.\n\n      But we also had the CA-1 Tape Management system, and the \"virtual\nvolumes\" in the VTS had to be made known to CA-1 as well.  My task was\nto produce an audit report to compare what CA-1 thought about the status\nof a tape, to what the VTS thought about that same tape.  We didn't want\none system thinking the tape was a scratch tape, while the other one was\nthinking that the tape was currently being used.  At the beginning, my\nbewilderment was complicated by the fact that I had no idea how an\ninquiry to \"tape status\" worked, in the VTS.\n\n      So I had to get familiar with how MVS looked at the status of an\nindividual tape in the VTS.  What was the inquiry method?  It turned out\nthat MVS kept the tape status info in a strange and new and \"weird\"\ntype of VSAM catalog entry, which took some getting used to.  The\n\"catalog of tape volumes\" was called a VOLCAT, and in order to inquire\nabout the status of a tape, you had to do a special type of LISTCAT TSO\ncommand against that catalog, using a VOLENTRIES( ) keyword.  This\nprovided what I'd call a quick inquiry about the status of the tapes in\nthe VTS, but it was not entirely up-to-date.  I don't remember exactly\nwhat the vulnerabilities were, but there was a definite possibility that\nthe actual VTS volume information could be updated, and the LISTCAT\ninquiry wouldn't show the latest volume status.\n\n      So I found out that the best status information could be had, by\nquerying the VTS box directly, using an IBM macro interface in an\nAssembler program.  I duly wrote a program that used this macro call, to\nthe IBM macro CBRLXCS, and produced an output file in a format of my own\nchoosing.  After a number of experiments with this program, I found that\nthe direct VTS query, volume by volume, was prohibitively slow when you\nwanted to run it against all the volumes in the VTS.  So I wrote another\nprogram to convert the original LISTCAT output into my new format, and I\nhad two alternative methods for getting VTS status for a large number of\ntapes in the VTS.  All of this could be considered one conglomerate of\n\"beginnings\", one after the other.  I'd definitely say it was difficult\nto go through those experiences with each and every \"beginning\".\n\n      But the important fact is that eventually I broke through, and I\nwas successfully able to produce the audit report.  I had some similar\ndifficulties on the CA-1 side too.  When it was all done, it was just\nanother report that we ran every day.  But I'll always remember all\nthose beginnings, one after the other.\n\n      If you want to see the results of this work, they are in the\n(free) CBT Tape collection of MVS goodies, in Files 519 and 516.  To get\nto the CBT Tape web site, just do a www.google.com inquiry for the words\n\"CBT Tape\", and you should find the site very easily.  You don't have to\nbe a member of anything, or know a password, to download any of the good\nstuff that's there.  If you've never looked at the CBT Tape web site\nbefore, that's also a \"beginning\".\n\n      What I'm trying to show here, is that if you look at your tasks\nas a series of \"beginnings to be broken through\", you can eventually\naccomplish big things.\n\n\nEQUIPMENT OTHER THAN MVS\n\n      Many of our beginnings occur when we are forced to use systems,\nother than MVS, in our work.  We have to get used to something new.  A\ngood example of this, in former times, was when I was going from one\nversion of Windows to another (for terminal emulation, etc.) and it was\nhard to get used to where the old functionality was, in the new product.\n\n      For example, I like to use the \"Show Desktop\" icon in my tray, at\nthe bottom of the Windows screen, and one of the new Windows releases\ntook that icon out of the tray.  It was very hard to find it again, as I\nrecall, and I was struggling with my terminal for a couple of days,\nuntil I found where that icon was being kept by default, and I was able\nto move it to it's proper place at the left side of the tray.\n\n      I'll give you another, and more serious example.  Having worked in\na small development shop, and having to use a P390 and a FLEX-ES system,\nI can surely tell you that the OS/2 based P390 machine and the Linux\nbased FLEX-ES machine have given me fits, at the beginning.  I couldn't\neven do the most elementary stuff with my MVS machines, until I figured\nout how the basic configuration procedures were entered into the\nunderlying \"other\" operating systems.  With the FLEX-ES machine in\nparticular, since I didn't know any Linux or UNIX at all before, it was\nvery slow at the beginning, until I was able to pick up all the basic\ncommands about how to list the contents of directories, copy files, and\nso forth.  All I can give as advice here, is to say that you should get\nas comfortable with the necessary basic commands that you need in the\nnew system, and from then on, it's a matter of personal taste, how much\nyou want to get involved.  But the beginning is difficult, and this kind\nof thing impacts many of us.  I'd simply say that you should just\nplaster a smile on your face, and gut your way through it.  If you're in\na bigger shop and other people have to get used to the same new stuff,\nit's definitely easier, because you can work it out together with them,\nand somebody there may actually know something.\n\n      In everybody's experience these examples are innumerable, and we\nhave all seen that \"beginnings\" of any type, involve snags.\n\n\nCHANGING JOBS OR SITES\n\n      Consultants see more of this phenomenon than regular employees do.\nThe question is:  \"How do you go about getting used to another MVS\nsystem at a new site?\"  It may become hard to find the tools that you\nare used to using.  Things aren't in the \"right place\".  Especially if\nyou have worked in the same shop for a long time, you get used to where\neverything is, and you're ESPECIALLY used to the fact that any equipment\nor tools, once installed, usually stay put.\n\n      When you move to another site, things DON'T stay put, and in my\nmind, that situation qualifies as a \"new beginning\".  So therefore it\nhas to be tough, to at least some degree.\n\n      For myself, I try to minimize the difficulty by packaging all my\nown optional tools (as far as possible) into single libraries that can\nbe easily moved.  I have my own load library, my authorized load\nlibrary, my panel library, JCL library, message library, and so forth.\nI try to make sure that these will go where I go.  But of course,\nsometimes that is impossible because of company restrictions, and then I\nhave to learn to use what THEY have, and not what I have.  At that\npoint, it's a beginning, and it's difficult again.\n\n\nTHE REWARDS\n\n      All of these trials and tribulations are part of our life, but\nthere's also an up-side to them.  Experience is the best teacher, and\nevery \"beginning\" that you have to slog through, gives you invaluable\nexperiences that will certainly help you get through whatever lies\nahead.  Most people will eventually get a tremendous satisfaction from\nthe accomplishments that they've achieved, if they'd stop and think\nabout where they've been, and what they've been through.  I've learned\nin my own travels, that above all, the most valuable reaction that I\ncan have to all this, is to be THANKFUL for having been given all of\nthese experiences and opportunities.\n\n      So to summarize, I'd say that it's a lesson in life to recognize\nwhen some experience is a \"beginning\".  And once you know it's a\nbeginning, you automatically realize that there's going to be some kind\nof difficulty attached to it.  And once you realize that, and you hunker\ndown and get over those obstacles, you'll be on your way to real\naccomplishment.  This is one of the most important lessons that I've\never learned!\n\n      I wish all the best of everything to all of you.  And I hope to\nsee you here again next month.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0601JA": {"ttr": 28681, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x007\\x01\\x054o\\x01\\x054o\\x08\\x03\\x00\\xe5\\x00\\xe5\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-12-12T00:00:00", "modifydate": "2005-12-12T08:03:37", "lines": 229, "newlines": 229, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          JANUARY 2006\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.\n\n\nWORKING WITH WHAT YOU HAVE, AND ENJOYING IT\n\n      Here's something I've been thinking about.  The \"older people\"\nnowadays, in the years 200x, talk often about the 60's and 70's, and how\nit was then.  Back in those days, in the 50's, 60's and 70's, the \"older\npeople then\" used to talk about the 20's all the time (and the Great\nDepression in the 30's, and the First and Second Wars).  So we might\neasily picture that the \"older people\" in the 20's used to talk about\nthe 1880's and 1890's.  And in the 1880's and 1890's there weren't even\nany automobiles or trucks.  Everybody used horses.  Really!  There were\ntrains then, but no cars!  And somehow, everybody still managed to live\ntheir lives \"normally\".\n\n      So we have to be aware about how much everything has changed, and\nhow quickly it is still changing.  Even the younger people among us can\nsee this.  Ten or fifteen years ago, there were hardly any cell phones.\nI visited Chicago once, at that time, and I was impressed about how you\ncouldn't find a phone booth there, as compared to New York.  Now, unless\nyour cell phone doesn't work (or you forgot it, perish the thought),\nit's a moot point.  And the Internet is even newer!  Computers\nthemselves are getting faster every year, with mind-boggling jumps in\nstorage capacity and speed that we're easily getting used to, as they\noccur.  And to tell you the truth, the Mainframe world (established as\nit is), is no different.\n\n      We are \"techies\".  We are supposed to be in the middle of all\nthis change.  We aren't just reacting to it.  We're CAUSING it too!  And\nthat's what I want to talk about today.  Our lives are a mixture of\nboth REACTING to all the changes, and PARTICIPATING in them also.  If\nyou think about it, it's a very exciting time to live in.  And by\nconsidering these thoughts and bringing them more forward in our minds,\nwe can become more effective participants, as well as enjoying our work\nbetter.\n\n      Let's consider one more aspect of our jobs.  It's the fact that we\ncan APPRECIATE our job AT THE TIME WE ARE DOING IT.  This is a\nprivilege.  Not all jobs are like that.  There are many jobs which let\nus ENJOY our surroundings, and there are some jobs which don't.  I'll\nshow you.\n\n      I once read a \"tale of woe\" written by an expert \"long snapper\"\nspecialist in the National Football League.  His job, being performed in\na big stadium with 80000 people watching, required 100 percent\nconcentration with ABSOLUTELY no room for any other thoughts.  Every\nmove of his hands was thought out, to the millimeter!  As a consequence,\nat the time he was doing his job, this man was not privileged to be able\nto think about where he was.  At the very end of his (otherwise very\ndistinguished) career, he was hired to be the long snapper for a\ncontending team, for the final 3 games.  In the last game, he got\noverwhelmed by the magnificence of the great crowd, enjoyed himself for\na second, muffed the snap, and cost his entire team, which had worked\nhard all year, a trip to the playoffs.  It was all because he took some\ntime to enjoy his job, in a job that didn't allow it.  So we have to be\nvery grateful for our own positions, which do allow it.\n\n      One of the ways that we can enjoy our own jobs, is to be able to\nPARTICIPATE in the \"change process\" aspect of it.  Another way, is to\nhave fun using the new tools and gimmicks that other people have\ndeveloped.  Even though we might get caught up in the \"drudgery\" of\ndoing our daily tasks, we should wake ourselves up once in a while,\n(using some kind of internal STIMER macro to remind us) and see how much\nof this job we can really enjoy.\n\n\nENJOYING THE NEWS GROUPS\n\n      IBM-Main is one of the nicest ways of keeping up with this field.\nI'll admit that the IBM-Main newsgroup is highly dependent on the types\nof questions which the people will write in, and therefore, the subject\nmatter will jump around a lot.  But since the IBM-Main group is\nmonitored by a lot of experts, from within IBM itself and outside IBM,\nthe replies there are often very authoritative, and you can learn a lot\nby reading the IBM-Main digests.\n\n      If you want to join IBM-Main, it is a listserv-based news group,\nand you can subscribe at the listserv address of listserv@bama.ua.edu.\nOnce you've already subscribed, the posting address in\nibm-main@bama.ua.edu.  I once wrote an entire article in this column\nabout IBM-Main, which you can find on File 120 of the CBT Tape, as\nmember CL9804AP (April 1998).  You can also find that column in the\nNaSPA archives, but I've since updated the subscription information in\nthe copy on CBT File 120, because it has changed since then.\n\n      If I have time, I like to read through the IBM-Main digests and\nsee the kinds of MVS questions which people are concerned with.  It's\nlike reading a newspaper that has to do with MVS.  You can pick and\nchoose the threads you like, or you can simply sit down and read through\nthe whole thing.  If IBM-Main is too long for you, or it's not in your\nexact special area, you can find many other news groups (based on\nlistserv or elsewhere, such as on yahoogroups.com).  To avoid cluttering\nmy email inbox, I get digests for all the groups I subscribe to.  One\nhint about finding newsgroups:  If a group is listserv-based, you can\nfind all of them from any one of them.  And yahoogroups has a searchable\nindex, so you can find anything over there, that you might be interested\nin.\n\n      By the way, I've just started a news group of my own.  It is\ncalled cbt-tape@yahoogroups.com.  Its purpose is to discuss the contents\nof the CBT Tape collection, to report recent Updates to the collection,\nand to report bugs and code changes to anything in the collection.  The\nentire CBT Tape collection is free to anyone, and you don't have to be\na \"member of anything\" or know a password, to use it.  Just do a search\non www.google.com for \"CBT Tape\" and you should get there easily.\n\n\nA PROGRESSION\n\n      Over the years, I have found that my work as an MVS systems\nprogrammer follows a pattern.  I get used to working with certain tools\nand equipment.  Then I add to them, as I discover more.  Then the\ntechnology improves, or I add to the technology by writing more tools\nmyself.  Then my techniques change and adapt, often to the extent that I\nwonder how I ever was able to do my job before.  It's almost like\nwondering how people were able to live when there were just horses, and\nno cars.\n\n      For example, since I use the PDS 8.6 command package from CBT Tape\nFile 182 (or its vendor equivalent Startool FDM from Serena) so often, I\nwonder what life would be like without it.  If (just to choose one\nsituation for illustrative purposes) I might want to find all the\nmembers of a partitioned dataset that were updated in the last two\nweeks, I could do either of the following:  Without the PDS package, I'd\nget an EDIT member list and do a \"sort changed\" command, or click on the\ndate field header.  With the PDS package, I'd get a partial member list\nusing the subcommand:  MEMLIST : LAST(14) , or use the abbreviation:\nML : BIWeek .  Because the PDS command offers many more options with its\nmember list than just doing an EDIT or BROWSE, I prefer the PDS way of\ndoing things.  But native ISPF has improved over the years too, and\nwithout the PDS command package, it's not quite the same as going back\nto a horse and wagon again.  The techniques using native ISPF are pretty\ngood, too.\n\n      With non-IBM parts of our work, the situation has changed\ndramatically too.  I don't know what I'd do without Windows cut and\npaste on the terminal emulator screen.  If I'm logged onto two\ncompletely different machines from the same pc, I can transfer screens\nfull of data using cut and paste.  Examples like this are innumerable.\nOur life is far different than it was, even 10 years ago.\n\n\nMORE SPECIFICS\n\n      Lately, I've been using some neat gimmicks like the tools from Bob\nGlover (of Jacksonville).  One tool, which requires a little bit of\nsetup (i.e. adding ADRDSSU to the IKJTSOxx AUTHPGM list) is an ADRDSSU\nbased dataset copy and move tool, that runs in the foreground.  The tool\nis from CBT File 630 and it is called MC.  You enter TSO MC and get a\npanel, asking which dataset(s) to move (in DFDSS control card format).\nThen the panel sets up a DFDSS copy or move job which runs under your\nTSO session, instead of in batch.  If your computer is fast enough (and\nmost of them are, nowadays) the jobs run pretty quickly, and you can\njockey your datasets around from pack to pack without much fuss.  It\nmakes my own DASD management, in a small shop, very clean and quick.\nYou might try and have a look at Bob's other files (numbers 608, 624,\n626, 631 and 682) where he has contributed some other useful gimmicks.\n\n      In the same vein, you should look at Mark Zelden's big toolbox on\nCBT Tape File 434.  Especially nice is his IPLINFO REXX exec, that only\nrequires copying to SYSPROC or SYSEXEC to use.  The wealth of system\ninformation that can be had, straight from a REXX, is mind boggling.\nBut Mark's stuff goes much farther than that, and once you're used to\nusing some of it, you'll never know how you ever did without it.\n\n      I don't know what I'd ever do without MXI (the huge monitor) from\nRob Scott (CBT Files 409 and 410), or SHOWMVS and SHOWzOS (from Gilbert\nSaint-flour and Roland Schiradin (File 492)).  These two monitors\ndisplay much MVS system information in an easy-to-use way.  The extent\nof the information shown by both of these packages is very great, almost\nunimaginable.  And they are free.\n\n      I don't know how I'd ever be able to run through a control block\nsearch without the LOOK TSO program from CBT File 264.  LOOK can format\nmany MVS control blocks, and chaining through them to see the incore\ndata, is a breeze.  I've written many an MVS utility with the info I've\ngotten through a core browse using LOOK.  You can get LOOK to format any\ncontrol block at all, using the actual IBM macro itself, so you can\nupdate the control block formatting with later versions of the macro,\nany time you want.\n\n      The TSO Fullscreen ZAP program (originally from UCLA) on File 134\nof the CBT Tape (a load module is on File 135) is so handy for looking\nat any DASD file, that I feel that if someone would have to do without\nit, it would be like using a horse-cart instead of a truck.  It is true\nthat AMASPZAP can do many of the things that Fullscreen ZAP can, but\nwithout any of the usability features.  You can even search through a\nDASD pack to find deleted data, anywhere on it, using Fullscreen ZAP, in\nauthorized mode, with its FULLVOL keyword.\n\n\nSUMMARY\n\n      Progress is constantly being made, to improve our work\nenvironment.  MVS tools are being written, and IBM is making many\n\"usability improvements\" to the MVS operating system as well.  If you\nwould compare our work environment today, to the green screens of 20\nyears ago, and the speed of today's machines and their networkability,\nto what wasn't there before, you might wonder how you ever were able to\ndo your work at all, in the old days.\n\n      But we did our work then (a team of horses can pull pretty big\nloads), and we do our work now too, only in a better manner.  Much of\nthe improvement, of course, depends on us--on our willingness to learn\nabout the new gimmicks as they arrive.  But besides our constant\nstriving to improve our methods, we must ever be grateful to live in\nsuch a time, when the technology improvements keep pouring in.  This\ngives us the food to nourish our thoughts.\n\n      I hope that this month's column will serve to stimulate your\nthought processes.  I hope that by mentioning a few of the tools now\navailable to make our lives easier, you will go out yourselves and\neventually find a few hundred of them.  Then you'll be able to tackle\nbigger jobs (than a horse can do), in far less time.  All the best of\neverything to all of you!  I hope to see you here again, next month.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0602FE": {"ttr": 28929, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x005\\x01\\x055o\\x01\\x055o\\x13\\x05\\x016\\x016\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-12-22T00:00:00", "modifydate": "2005-12-22T13:05:35", "lines": 310, "newlines": 310, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         FEBRUARY 2006\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.\n\n\nTSO/E CONTROL BLOCKS - PART 1\n\n      TSO is a very old part of MVS, but it has to keep up with the\ntimes.  Installations are trying to be up 24 hours a day, 7 days a week,\nand they are trying to avoid IPLs.  Adjustments have to be made to the\nsystem while it is up and running and in the middle of doing productive\nwork.  (It would be nice to perform these adjustments using operator\ncommands from the console.)  Hard-coded quantities which need an IPL to\nchange, are a no-no, and for the past twenty-or-so years, IBM has been\ntrying to engineer them out of the system.  But unfortunately, MVS, as\noriginally designed, had a lot of these quantities built into it.\n\n      So each one of these things had to be painstakingly redone and\nre-architected.  For example, the control block which defined all the\nnode names known to JES2, used to be located in one block of storage\nthat was defined at IPL time.  Such a structure would assume that you\ndidn't mind doing an IPL.  But that's intolerable now.  So the control\nblock was made dynamic.  A block of storage was obtained and pointed to,\nand then all the node names were copied in, but the storage was\nextendable, so that each obtained piece of storage pointed to the next\npiece, and the node names themselves were chained to each other.  This\nnew kind of structure could be done over without an IPL, while the\nsystem was still running, and a new node could be added or deleted at\nany time, using an operator command.\n\n      Same thing with TSO.  In the original design of MVS, the APF\nauthorized TSO command table was actually a CSECT that was linkedited\ninto the terminal monitor program itself.  When I first started in the\nbusiness, you had to have your own copy of the IKJEFT02 program in an\nauthorized STEPLIB, if you wanted your session to use a different APF\nlist of programs (CSECT IKJEFTE2) than everybody else had.  This was\nrelease-dependent too.  The next time IBM came out with a new version of\nTSO, you had to re-do your CSECT IKJEFTE2 (and IKJEFTE8, etc.) and\nlinkedit those tables into the later release level of the IKJEFT02\nterminal monitor program.  Otherwise, you'd get incompatibilities in the\nway your TSO session was run.  You were running the old release, and the\nrest of the system was running the new release.  If you wanted to be\n\"special\", it was quite a high price to pay.\n\n      So when IBM came out with TSO/E (in the early to mid 80s) they got\nsmarter and realized that tables of program names should not be\nassociated with things that were release dependent.  All of these CSECTs\nwhich contained the tables of names that are now associated with the\nIKJTSOxx PARMLIB member entries:  AUTHCMD - CSECT IKJEFTE2, AUTHPGM -\nIKJEFTE8, NOTBKGND - IKJEFTNS, and AUTHTSF - IKJEFTAP, were now isolated\ninto a new load module called IKJTABLS.  This module only contained the\nfour entry points and their corresponding tables of program names only.\nSuch a table would never again be dependent on which release of TSO you\nwere running.\n\n      But even that wasn't enough for a 24x7 environment that could not\ntolerate IPLs.  Changes to these tables that would truly be dynamic,\nwer- required.  IBM's first stab at this was with the PARMLIB UPDATE(xx)\nTSO command.  I guess they figured that since such system-wide changes\nwere in the systems programmers' domain, they should give the systems\nprogrammers the ability to control the situation, and they designed a\nspecially authorized TSO command (the PARMLIB command) that would allow\nsystems programmers to perform PARMLIB member switches.\n\n      With TSO/E Version 3 (z/OS 1.3 and later), even that wasn't\nenough.  Sometimes the systems programmers will set up a change plan\nand then they'll go home, making an arrangement with the operators to\nenter some command that makes the adjustment at some ungodly hour in\nthe middle of the night.  You would never expect an operator to enter a\nTSO PARMLIB command.  Their TSO ids do not (and should not) have that\nmuch authority.  The operator's domain is the console, and therefore\nthey should have a console command to do the adjustment.  So with TSO/E\nVersion 3, IBM introduced the SET IKJTSO=xx command that does\nessentially the same thing as the PARMLIB UPDATE(xx) command.\n\n      This is the area that we are going to address today.  When the\nsystem (during IPL time) or the programmer (using a PARMLIB command) or\nthe operator (using the SET IKJTSO=xx command) sets up the TSO\nenvironment a certain way, what happens internally?  Where is this\ninformation kept?  How can we learn more about our own systems, and make\nproper adjustments if necessary, by peeking and poking (safely) in this\narea?  To tell the truth, IBM has it pretty well covered with the great\npower that the PARMLIB TSO command has nowadays.  But I think that it is\nstill profitable for us to look around at what's there, and learn.\n\n\nLOOKING AT TSO CONTROL INFORMATION THE WAY THE SYSTEM DOES\n\n      The heart and soul of modern TSO/E internal structure is the TSO/E\nVector Table, mapped by the IKJTSVT macro in SYS1.MACLIB.  It is a\nfitting testimony to the fact that IBM is \"dynamic-izing\" TSO, that at\none time in not-so-distant MVS history, the TSO Vector Table didn't even\nexist.  Everything in TSO really WAS very static.\n\n      Since the TSO/E Vector Table mapping is public knowledge, I invite\nyou to go to your systems and look at it.  You should read all of the\n\"Change Activity\".  Depending on your TSO Version level, you'll see that\nthe support for various TSO/E facilities has kept growing, and the\nbeginnings of the search for most control information relating to TSO/E\noperation starts here with the TSO/E Vector Table.\n\n      My own interest in this area was initiated by the fact that I am\nwriting and expanding a comprehensive BROADCAST dataset management tool.\nI started out by dealing with the SYS1.BRODCAST dataset itself, and I\nlearned how to access the different parts of it, how to read, write and\ndelete the messages myself, both in the user part and in the Notices\npart, and how to backup and copy the BROADCAST dataset in it's entirety,\neven across different device types.  That was all well and good before,\nbut in today's TSO environment, it's becoming downright exciting,\nbecause one of the latest TSO/E developments, begun in TSO/E Version 3,\nhas been BROADCAST dataset switching.  If I can make a copy of the\nSYS1.BRODCAST dataset, or even construct a completely new one using my\nown tools, and then the system can switch to it using a PARMLIB\nUPDATE(xx) TSO command or a SET IKJTSO=xx operator command, then I've\ngiven the system administrators very considerable control over the TSO\nmessaging environment.\n\n      So because of this, I had to expand my interest in the\nSYS1.BRODCAST dataset itself, to include all the goings-on involved in\nswitching from one copy of it to another.  This stuff starts taking\nplace in the IKJTSVT control block (the TSO/E Vector Table) and\ncontinues in the TPVT (which officially is not a public interface, but\nas we'll see, you have to look at it), and it goes further, to the\nIKJEESCB control block (mapped in SYS1.MODGEN), which contains a good\ndeal of the BRODCAST dataset information, and with TSO/E Version 3, it\ncontains much of the BROADCAST dataset switching information.  Today\nwe'll get a glimpse of how exciting the knowledge of this information\ncan be.\n\n\nBROWSING STORAGE AND FOLLOWING CONTROL BLOCK CHAINS\n\n      I almost never write a system-level program that \"chases control\nblock chains\" without using the free \"LOOK\" TSO command, which browses\nactive storage.  The LOOK command can be found (source code) in the free\nCBT Tape collection on File 264.  An easily installed load module for\nLOOK can be copied from the load module library on CBT Tape File 035.\nSo if you get this load module library from the CBT Tape web site (do a\nwww.google.com search for \"CBT Tape\" and you'll find it easily), then\njust copy the LOOK module from the File 035 library to a load library\nthat your TSO session can access.\n\n      If you run LOOK unauthorized, you can browse storage in your own\nTSO session's address space.  But that includes all COMMON STORAGE that\nis not fetch protected.  Therefore you can use LOOK to examine Subpool\n241, both below and above the 16M line, which is valid for the entire\nsystem, and which concerns us directly.  So that's where we're going to\nbegin.\n\n      How does LOOK work?  LOOK has a full screen display.  The command\nJ denotes 31-bit indirect addressing.  So if you want to point to the\nCVT, whose address is at virtual storage location X'10', you say (in the\nLOOK screen) the command J10.  This points you to the CVT.  If you'll\nactually do that, you'll notice that the CVT is formatted by its fields.\nThe field names correspond exactly to the names in the CVT macro from\nSYS1.MACLIB, because at assembly time, the formatting had been built\nfrom an actual copy of the CVT macro in SYS1.MACLIB.\n\n      To get to the TSO/E control block areas we need, using LOOK, you\ndo the following:  Entering J+9C from the CVT, you get to the TSO Vector\nTable.  Entering J+4C from the TSVT, you get to the TPVT.  And entering\nJ+20 from the TPVT, you get to the IKJEESCB control block that gives you\nvery important information about the current status of the BROADCAST\ndataset.  In an Assembler program, the corresponding instruction\nsequence would be:  Load a register with 16 (which is X'10') to get to\nthe CVT.  Load a register with X'9C' off the CVT to get to the TSVT.\nAnd load a register with X'4C' off that register to get to the TPVT.\nThen load a register with X'20' off the beginning of the TPVT, to get to\nthe IKJEESCB.\n\n      To show you the kind of information about the BROADCAST dataset\nwhich the TPVT and IKJEESCB control blocks contain, I have written a TSO\ncommand which displays the current status of this information on your\nMVS system.  This command is called EESCB, and it runs unauthorized\nbecause it just displays information, and doesn't try to change Subpool\n241 storage.  To show you some output from the the EESCB command, please\nlook at Figure 1.  You can find the EESCB command on File 731 of the CBT\nTape collection.  At this writing, File 731 is only on the Updates page\nof the CBT Tape web site; it isn't on the regular CBT Tape yet.\n\n\nTHE TPVT CONTROL BLOCK\n\n      The TPVT control block, which is at the heart of all the PARMLIB\nswitching mechanisms, is officially not described to the public by IBM.\nBut one glance at it using LOOK, will show you how important the TPVT is\nto TSO/E operation.  The address at TPVT+X'14' points to the CTLT\ncontrol block, which points to the incore addresses of the AUTHCMD,\nAUTHPGM, NOTBKGND, and AUTHTSF tables.  TPVT+X'20' points to the\nIKJEESCB control block (with IS documented by IBM in SYS1.MODGEN).\nTPVT+X'24' points to the ALPL control block, which tells you if your\ndefault allocations in the system are OLD or SHR.  (This is all PARMLIB\nIKJTSOxx information, folks!)  TPVT+X'28' points to the TPT, which gives\nTCT and SCT information.  TPVT+X'2C' points to the INMXPARM control\nblock, that has all your TRANSMIT TSO command defaults for the system.\nTPVT+X'30' points to IKJCNPRM, which contains your CONSOLE TSO command\nPARMLIB quantities.  TPVT+X'3C' points to IKJEFHCB, which contains the\nPARMLIB information about the HELP datasets and their language support.\nAdditional information in the TPVT concerns the most recent status of\nPARMLIB IKJTSOxx switching, who did it, and when.\n\n      Quite a bit of this information has to be figured out by\nguesswork.  But much of the guesswork has already been done for you.\nThe SHOWMVS TSO command (source on CBT File 492, load on File 614),\nwhich displays \"everything but the kitchen sink\" about your MVS system\nand your own TSO session, contains a macro library which has macros\nthat attempt to map system areas by guesswork.  All macros there which\nbegin with the letters IKJ, will be helpful.  I made a correction to\nthe macro there (called IKJXPRM) that describes the INMXPARM control\nblock.  The corrected macro can be found on File 731 on the Updates\npage of the CBT web site, in the MODGEN member.\n\n      I guess that does it for now, but we'll hopefully continue on\nthis same topic next time.  I think that this knowledge gives a person\na real appreciation for the work that the IBM MVS developers have done,\nand continue to do, with such accuracy and reliability.  Support for\nthe newer MVS features does not come cheaply.  It requires large effort\nfrom the MVS developers, and since the system works so nicely, we don't\neasily get to appreciate the detailed and extremely careful work which\nthese fine people have done.  Thanks, IBM Software Development!\n\n      Please come back to these pages next month.  Meanwhile, I wish\nall of you a most happy, healthy, and productive year.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   Sample Output from the EESCB\n            TSO Command\n\n\n       The EESCB command, from File 731 of the\n       CBT Tape collection of free MVS materials,\n       shows the status of the BROADCAST dataset\n       (default is SYS1.BRODCAST) on the MVS\n       system.  The EESCB command attempts to be\n       as self-explanatory as possible.\n\n\nCurrent PARMLIB BRODCAST information - IKJEESCB\n------- ------- -------- -----------   --------\n  The EESCB TSO command displays information\n  concerning the TSO SEND and LISTBC command\n  options.  Information is obtained from the\n  IKJEESCB and TPVT TSO control blocks, which\n  are chained off the TSO Vector Table IKJTSVT.\n  BROADCAST dataset switching is only available\n  from IKJEESCB version 03 or later.\n  ---------------------------------------------\n  Parmlib member IKJTSOxx can be invoked:\n    A - At IPL Time\n    B - Under TSO using PARMLIB UPDATE(xx)\n    C - Using Operator command SET IKJTSO=xx\n  ---------------------------------------------\n  Source of EESCB messages:\n  ---------------------------------------------\n    IKJEESCB - General SEND and LISTBC defaults\n               from the IKJEESCB control block.\n    PARMLIB  - TPVT control block\n    BRODCAST - BRODCAST section of IKJEESCB\n               which is only present from\n               IKJEESCB version 03 or later.\n  ---------------------------------------------\nIKJEESCB Address : 113D6770\nIKJEESCB Version : 03\nIKJEESCB Flags   : E8800000\nIKJEESCB Opersend: On\nIKJEESCB Usersend: On\nIKJEESCB Save    : On\nIKJEESCB Chkbrod : Off\nIKJEESCB Usebrod : On\nIKJEESCB Msgprot : Off\nIKJEESCB Sysplxshr Off\nIKJEESCB Spxshrxcf Off\nIKJEESCB Oprsewait On\nIKJEESCB Spxshrini Off\nIKJEESCB Lognmspec Off\nPARMLIB  Dataset : ADCD.Z16.PARMLIB\nPARMLIB  Volser  : Z6RES1\nPARMLIB  Member  : IKJTSO00\nPARMLIB  Activator **IPL**\nPARMLIB  Swt Date: 2005-10-03\nPARMLIB  Swt Time: 06:54:43\nPARMLIB  System  : ADCD\nPARMLIB  CPUID   : 0192\nPARMLIB  CPU Model 1247\nThis system does not write to TSO Userlogs.\nBRODCAST Dataset : SYS1.BRODCAST\nBRODCAST Volser  : Z6SYS1\nBRODCAST Unit Name SYSALLDA\nBRODCAST Flags   : 30\nBRODCAST Timeout : 005   Seconds\nBRODCAST Operator: Prompt\nThe BRODCAST dataset name is the default.\nBRODCAST Dataset volser not specified in IKJTSO00\nBRODCAST Dataset name was set by System IPL\nBRODCAST Dataset switch required?   No\nBRODCAST Dataset Name is an ALIAS?  No\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0603MA": {"ttr": 28935, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x18\\x01\\x06\\x04\\x1f\\x01\\x06\\x04o\\x08I\\x01K\\x018\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2006-02-10T00:00:00", "modifydate": "2006-02-15T08:49:18", "lines": 331, "newlines": 312, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          MARCH 2006\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.\n\n\nTSO/E CONTROL BLOCKS - PART 2\n\n      Last month, we talked about some of the nice extensions to TSO/E\nwhich were developed by IBM to help avoid IPLs and give the systems\nprogramming staff better power and control over the system.  Today,\nwe'll continue that discussion and mention more of the details.\n\n      The main focus of our attention centers around the PARMLIB member\nIKJTSOxx.  Using either a TSO PARMLIB UPDATE(xx) command, or an Operator\nSET IKJTSO=xx command, the active member IKJTSOxx in PARMLIB can be\neither reloaded (from an edited version of the same member) or switched\nto the quantities and names specified in a new member.  The internals of\nwhat is involved when this happens, are so interesting, that I feel\ncompelled to show you some of the nice things that IBM's TSO developers\nhave accomplished.  Much of the motivation for putting these features\ninto TSO/E, has been \"avoiding unnecessary IPLs.\"\n\n      Of course, the main idea in avoiding unnecessary IPLs is to\nconvert fixed structures that were created in storage at IPL time, to\nstructures that can be re-created (in a different storage location and\npointed to) much later, long after the IPL, when the system is running\nnormally.  These new structures that were created later, should perform\nwith exactly the same effectiveness as the original structures that were\ncreated at IPL time.  Thus, a new IPL is avoided.\n\n      So what kind of functionality are we dealing with here?  Just take\na quick look at a fully populated PARMLIB IKJTSOxx member, and let's\nsee.  We can go to SYS1.SAMPLIB on our system and look at the IKJTSO00\nmember which is there, for a typical example.  The categories listed\nare:  AUTHCMD, AUTHPGM, NOTBKGND, AUTHTSF, SEND, ALLOCATE, TRANSREC\n(Transmit and Receive), CONSOLE, PLATCMD, HELP, PLATPGM, and TEST.  As\nfar as I know, the entries under each of these categories can all be\nchanged dynamically, by either a PARMLIB UPDATE(xx) command or an\nOperator SET IKJTSO=xx command.  (We're talking TSO/E Version 3 here,\nfrom z/OS 1.3 and onward.  Before that, this wasn't entirely true.)  So\nthis means that each of these entries must reserve a certain place in\nmachine storage, where control information exists that is pointed to and\nreferenced by whichever TSO/E component applies.  Today I'm prepared to\nshow you much of it.\n\n\nTSO/E CONTROL BLOCKS\n\n      Last month, we talked quite a bit about the general TSO/E control\nblock structure which applies to this area, so today I'm going to\nsummarize what is going on.\n\n      The main TSO/E control block is the TSO/E Vector Table, the TSVT,\nwhich is pointed to by address X'9C' off the beginning of the CVT.  The\nTSVT is a public interface, which is described by the IKJTSVT macro in\nSYS1.MACLIB.  The next important control block is the TPVT, which is a\nprivate control block whose details have not been publicized by IBM.\nThe TPVT is pointed to at location X'4C' off the beginning of the TSVT.\n(This location is public knowledge, and part of the IKJTSVT macro in\nSYS1.MACLIB.) A description of the TPVT has been created, by guesswork,\nand can be found as macro IKJTPVT in the SHOWMVS source code in the\nSHOWMACS member of CBT Tape File 492.  I have made a few corrections to\nthis member, and my updated IKJTPVT member is found on the CBT Tape File\n731, in the MODGEN member, that may currently be found on the Updates\npage of the CBT Tape website.  You can easily locate the CBT Tape\nwebsite by running a www.google.com search for \"CBT Tape\".  The TPVT\ncontrol block points to most of the rest of the necessary information.\n\n      Please look at our sample picture of an active TPVT control block\nthat is from a z/OS 1.6 MVS system.  This picture was created using the\nLOOK TSO command that is very helpful for browsing system storage\nlocations in a running MVS system.  Source code for LOOK comes from File\n264 of the CBT Tape collection.  A load module for LOOK can be found on\nCBT Tape File 035.\n\n\nAUTHCMD, AUTHPGM, NOTBKGND, and AUTHTSF\n\n      The dynamic storage which points to all of these authorization\ntables for TSO/E is pointed to from the CTLT control block at X'14' off\nthe beginning of the TPVT.  The CTLT +X'8' points to IKJEFTE2, followed\nby a fullword with the length of the control block, a halfword with the\nnumber of entries starting from the entry point, and another halfword\ncontaining the length of one table entry (which in this case is 8, the\nmaximum length of a program name).  This is followed by the CTLT +X'14',\npointing to IKJEFTE8, followed by similar \"length\" information, then\nCTLT +X'20', pointing to IKJEFTNS, and CTLT +X'2C', pointing to\nIKJEFTAP.  This is the \"real global system information\", unless it is\noverridden by an IKJTABLS member running in an authorized STEPLIB in\nyour TSO session (or in the authorized STEPLIB of a TSO-in-batch job).\n\n      If any of these four keywords, AUTHCMD, AUTHPGM, NOTBKGND, or\nAUTHTSF, is not coded in the active IKJTSOxx member, then the addresses\nin the CTLT will default to point to the entry points (respectively)\nIKJEFTE2, IKJEFTE8, IKJEFTNS, and IKJEFTAP that are in the copy of the\nIKJTABLS member in LPALIB, and the length information which follows them\nin the CTLT control block is set to zero.  In that way, the TSO programs\nthat need this information will \"know\" what to do.\n\n\nALLOCATE, HELP, CONSOLE, AND TEST\n\n      The ALLOCATE entry in the IKJTSOxx member of PARMLIB has only two\npossible settings:  DEFAULT(OLD) or DEFAULT(SHR).  The idea is that if\nyou allocate a new dataset with no further specifications (say, if you\nuse the TSO ALLOCATE command to do it), then this setting sets a\nsystem-wide default that the allocation be either DISP=OLD or DISP=SHR.\nThe indicator is a single bit setting at X'C' off the ALPL control block\nthat is at X'24' from the beginning of the TPVT.  If the bit setting is\nX'80', then the default allocation attempts are DISP=OLD.  If the bit\nsetting is X'40' then the default allocation attempts are DISP=SHR.  The\ndefault (if no ALLOCATE entry is present in the IKJTSOxx member) is\nDISP=OLD.\n\n      The CONSOLE entry in the IKJTSOxx member sets the default capacity\nvalues for simulated MVS consoles which are opened by the TSO CONSOLE\ncommand.  Default values are INITUNUM and INITSNUM of 1000, and MAXUNUM\nand MAXSNUM of 10000.  You can change these by setting different\nquantities up, in your IKJTSOxx member of PARMLIB.  The incore values\nfor these quantities are present in the IKJCNPRM control block that is\nat X'30' off the beginning of the TPVT.  A guesswork mapping of IKJCNPRM\ncan be found in the SHOWMVS.MACLIB that is from the SHOWMACS member of\nCBT File 492.\n\n      The HELP entry in the IKJTSOxx member supports National Language\ndifferences when it comes to TSO HELP.  United States English (called\nENU) is the default for the HELP dataset, and SYS1.HELP is the default\nfor its name.  But many national languages, together with their\nassociated HELP datasets, can be supported under TSO, and their names\nand datasets can be specified here.  Control Block information for the\nHELP entry in IKJTSOxx is located at X'3C' off the TPVT, which points\nto the IKJEFHCB (TSO Help Control Block).\n\n      The TEST entry in the IKJTSOxx member contains two sets of name\nentries.  These are the TSOCMD( ) entries and the SUBCMD(( )) entries.\nBoth are pointed to by the TPT control block whose address is at X'28'\noff the beginning of the TPVT.  TPT +X'C' points to the TCT which is the\nlist of TSO commands that can be executed under the TEST command.  TPT\n+X'14' points to the SCT which is the list user program names paired\nwith their entry points, that can be run as subcommands under TEST.\nThis capability extends the powers of the TEST command to include\nuser-written interfaces.  Defaults are blank table entries.\n\n\nPLATCMD and PLATPGM\n\n      The PLATCMD and PLATPGM entries in IKJTSOxx can specify lists of\nTSO command names and program names (respectively) which can run under\nthe TSO/E command/program invocation platform.  These programs do not\nrequire task termination processing to clean up for them.  If these\nparameters are not coded in the IKJTSOxx member, then the default is not\nto create any incore name lists, and the TPVT entries which are supposed\nto point to the FCVE (for PLATCMD) and PPVE (for PLATPGM) control blocks\nwill contain binary zeros.  If the PLATCMD and/or PLATPGM entries are\nfound in the IKJTSOxx member, then these control blocks are created.\nThe FCVE control block (PLATCMD) is pointed to by the address at X'34'\noff the TPVT, and the PPVE control block (PLATPGM) is pointed to by the\naddress at X'40' off the TPVT.  If these locations in the TPVT contain\nfullwords of binary zeros, it means that the PLATCMD and PLATPGM\nkeywords had not been coded in the active IKJTSOxx member of PARMLIB.\n\n\nTRANSREC and SEND\n\n      We've saved the best for last.  These are the specifications for\nthe TRANSREC (Transmit and Receive defaults) and SEND (SEND, LISTBC\nand BROADCAST dataset) keywords in the IKJTSOxx member of PARMLIB.\n\n      If you've ever tried to TRANSMIT (XMIT) a large dataset, you've\nprobably run into the warning messages about the TRANSMIT limits on the\nsystem.  These are the INMX034I warning messages that tell you that\nnnnnnn messages have already been transmitted, and your installation\nlimit is xxxxxxxxx records.  If you don't code a TRANSREC statement in\nthe IKJTSOxx member of PARMLIB, you'll find that the limits of the stuff\nyou can TRANSMIT are very small:  10000 lines for the first warning,\n5000 lines for the warning interval, and 30000 lines for the maximum.\nThese numbers show up in the INMXPARM control block too.\n\n      The INMXPARM control block, which contains the TRANSREC settings\nin storage, is pointed to by X'2C' off the TPVT.  I have written a TSO\ncommand (non-authorized) to display all the INMXPARM values.  This\ncommand is called INMXD and you can find it in CBT Tape File 731 on the\nUpdates page (currently) at the CBT website.  My INMXD command takes\nold TSO/E releases into account too, back (at least) to TSO/E 2.5.  See\nFigure 2 for some typical output from the INMXD command.\n\n      The INMXPARM control block doesn't have a publicized mapping macro\nfrom IBM.  But in the MODGEN member on File 731, macro IKJXPRM, there is\nat least, for the current versions of TSO/E (2.6 and later) a pretty\ngood guess at its contents.  The format of the INMXPARM control block\nhad changed, between TSO/E Versions 2.5 and 2.6.\n\n      As we mentioned last month, the SEND keyword in the IKJTSOxx\nPARMLIB member contains the BROADCAST dataset information, and the\nBROADCAST dataset name.  This keyword also contains information about\nwhether the TSO Userlogs for user messages are enabled, and the Userlog\nnaming conventions and default sizes.  Control information about the\ncurrent BROADCAST dataset, Userlogs (if any) and BROADCAST dataset\nswitching is contained in the IKJEESCB control block that is pointed to\nat X'20' off the beginning of the TPVT.  The IKJEESCB control block\nformat is a public interface, with the IKJEESCB macro being located in\nSYS1.MODGEN.\n\n      I have written a (non-authorized) TSO command called EESCB which\nwe illustrated in this column last month.  The EESCB command displays\nthe current status of (pretty much) all of the SEND parameter\ninformation in IKJTSOxx, and it displays more information then does the\nD IKJTSO,SEND Operator command.  My EESCB command will display available\ninformation about the BROADCAST dataset on older TSO/E releases as well,\nbut before TSO/E Version 3.x, there was no BROADCAST dataset switching.\nAt the TSO/E Version 3 level, EESCB will display just about all of the\nBROADCAST dataset switching information, except for the switching time\ninformation at the end of IKJEESCB.  I figured that since BROADCAST\ndataset switching is usually done via a full PARMLIB member switch,\ndisplaying the time and date from the TPVT (which is formatted more\nnicely) would suffice.\n\n      If you don't code a SEND parameter in IKJTSOxx, then SYS1.BRODCAST\n(as cataloged) is the default BROADCAST dataset name, and things are\njust about the same as they were before BROADCAST dataset switching was\npossible.\n\n\nSUMMARY\n\n      IBM's developers have done a very good coding job in allowing\nTSO/E-controlled values to be reset at any time after an IPL, using the\nPARMLIB UPDATE(xx) TSO command, or the SET IKJTSO=xx Operator command to\ntrigger the switching.  All of the values which can be specified in the\nIKJTSOxx PARMLIB member will eventually show up in dynamically created\nTSO/E control blocks that the system uses.  I find it quite amazing that\nthese values (if they existed at all) in the old MVS releases, used to\nrequire an IPL to change, and now, they don't.  MVS still has the look\nand feel of the way it used to be, but by clever coding, the IBM\nsoftware developers have been able to make all the values dynamically\nadjustable without an IPL.\n\n      For us, I feel that this discussion brings us back to earth, in a\nsense.  As systems programmers, we spend a lot of time setting up the\nsystem, and precious little time thinking about how it is coded.  So\nhere we see a component of the system, which has existed for nearly four\ndecades already.  It has been re-coded in many very clever ways, and it\nstill remains externally looking much the same as it used to look.  My  `\nown creative juices get inspired when I see that, and it encourages me\nto think of clever innovations with the system that I can try to create\nmyself.  I wish you all a good month, and I hope to see you here again\nnext time.\n\n    *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFigure 1.   A Glimpse at the TPVT Control Block\n\n      The TPVT Control Block, here illustrated using the\n      LOOK TSO command from File 264 of the CBT Tape (load\n      module on File 035), from z/OS 1.6, showing its\n      active pointers.\n\n\nLOOK COMMAND - DISPLAY VIRTUAL MEMORY      DISPLAY ASID= 004C\nENTER CMD -\nLAST CMD  - J+4C\n\n11495670   >E3D7E5E3  00DC0200  C9D2D1E3  E2D6F0F0 *>TPVT....IKJTSO00*\n11495680    00000001  114B5010  0000003C  00000000  *......&.........*\n11495690    101CC1D8  114BC028  11231018  101CC0D8  *..AQ...........Q*\n114956A0    11239010  101B4068  00000000  11232000  *...... .........*\n114956B0    11255020  00000000  00000000  00000000  *..&.............*\n114956C0    C1C4C3C4  4BE9F1F6  4BD7C1D9  D4D3C9C2  *ADCD.Z16.PARMLIB*\n114956D0    40404040  40404040  40404040  40404040  *                *\n114956E0    40404040  40404040  40404040  E9F6D9C5  *            Z6RE*\n114956F0    E2F10000  C1C4C3C4  40404040  5C5CE2C5  *S1..ADCD    **SE*\n11495700    E35C5C40  F1F17AF0  F67AF5F6  F2F0F0F6  *T** 11:06:562006*\n11495710    60F0F260  F0F80080  00009999  12471106  *-02-08..........*\n11495720    56762006  02088000  00000000  00000000  *................*\n11495730    00000000  00000000  00000000  00000000  *................*\n11495740    00000000  00000000  00000000  00000000  *................*\n11495750    00000000  00000000  80000000  00000000  *................*\n11495760    00000000  00000000  00000000  00000000  *................*\n\n\n1= HELP      2=           3= END        4=           5= REPEAT  6=\n7= BACKWARD  8= FORWARD   9= HIST BWD  10= HIST FWD 11=        12=\n\n    *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFigure 2.   TSO Command INMXD Example\n\n        The INMXD command from CBT Tape File\n        731 shows the currently set values in\n        the INMXPARM (Transmit and Receive)\n        control block.  This command does not\n        have to be APF Authorized, because it\n        does display only.  Old releases of\n        TSO/E (before 2.6) are also supported\n        by this command.\n\n\n    INMXPARM - Display of Field Values\n    --------   ------- -- ----- ------\n    INMXPARM ADDR   1119E390\n    LENGTH          0100\n    NJE COUNT       0001\n    NJE START       1119E480\n    INMX VERSION    02\n    INIT WARN            50000\n    WARN INTRVL          15000\n    OUTLIMIT           5000000\n    VIO UNIT LNG    08\n    VIO UNIT        SYSALLDA\n    CIPHER FLAG     40\n    SYSOUT CLASS    *\n    LOG NAME        MISC\n    LOGSEL 1        .\n    LOGSEL          LOG.\n    LOGSEL SIZE     0005\n    SYSCTL NAME\n    SYSCTL SIZE     0000\n    USRCTL NAME     .NAMES.TEXT\n    USRCTL SIZE     000B\n    SPOOL CLASS     B\n    NODE/SMF 0001   NODENAME  SMF\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0604AP": {"ttr": 29187, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00$\\x01\\x06\\x08\\x0f\\x01\\x06\\x08\\x0f\\x08I\\x00\\xf7\\x00\\xf7\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-03-21T00:00:00", "modifydate": "2006-03-21T08:49:24", "lines": 247, "newlines": 247, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          APRIL 2006\n\n(Written jointly with Courtney Taylor.)\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.\n\n\nINTERNATIONALIZATION\n\n      Today we'd like to address an aspect of MVS development and\nhistory that we seldom thought about in previous years.  This world is\nbecoming \"one world\", more and more.  The Internet is bringing people of\nall countries together, like never before.  The Internet transcends and\npenetrates national boundaries.  People in five or ten different\ncountries can all conference with each other at the same time, as well\nas people in far flung corners of the same country, like the United\nStates or Canada.  Miles and kilometers don't mean anything, when it\ncomes to Internet messaging and traffic.  Messages can bounce halfway\n(or all the way) around the world and back again, sometimes in less time\nthan it takes to blink an eye, only limited by the speed of light.\n\n      The implications for MVS are about as great as they are for\nanything else.  Recently, we've received software products from MVS\nvendors, without tapes.  I just downloaded the entire product from an\nFTP site, and uploaded it and installed it on the MVS mainframe in a\nfew minutes.  Tapes?  What tapes?  No tapes were ever involved.  And\nit didn't even seem to make a difference what country the product was\ncoming from.  We've gotten products from Australia the same way as from\nthe U.S.\n\n      As the proprietor of the \"CBT Tape\" collection of free MVS\nsoftware, this internationalization through the Internet has affected me\n(and you) even more.  In years past, when I had to make an update to\nsome products in the collection, I had to carry a satchel full of tapes\ninto the computer room, mount them on tape drives, figure out what was\non them (one tape at a time), copy the stuff off onto DASD, and package\neach creation coherently to make sure all the stuff was installable by a\nreasonably trained MVS sysprog.  Most of the time, the tapes came from\nthe U.S.  Canada has some sort of strict regulation about exporting\ncomputer tapes to the U.S., but we got a few from there too.  And from\nother countries, the difficulty of sending a tape was often so\nprohibitive (if not to say expensive also), that we got very few\ncontributions from the far-flung countries of the world.  Today, it\ndoesn't matter where the contributor is from.  The messages fly \"fast\nand furious\", and sometimes a dozen messages will get sent back and\nforth more than halfway around the world (each time) in the space of an\nhour, to fix a contributed product.  My, has the world changed!  All we\nhave to worry about is time zones.\n\n      Eighty years ago, some utopians, liberals (I don't know how to\nname them accurately) wanted to start a movement to make \"one world\".\nI remember hearing about this from my grandfather.  Of course, in the\nproposed \"one world\", there would be a small obstacle known as a\nlanguage barrier.  The peoples of the world happen to speak hundreds of\ndifferent languages (in their everyday conversation and\ncommunications).  How would you propose to solve that small problem\n(eighty years ago)?  One inventive soul then, proposed to create a\n\"universal language\" which he called \"Esperanto\", and he thought he\ncould get all the people to forget the languages they were born with,\nthrow them all into the garbage pail, and only speak Esperanto.  I\nthink you can figure out what happened to that plan!  But in the 1920s,\neverybody was talking about it, and a few were even speaking Esperanto\n(to their friends only).  I'll tell you, more people were speaking \"Pig\nLatin\".\n\n      But today, to our big surprise, this \"one world\" actually exists!\nIt has sneaked up on us.  And the Internet has made it happen.  What\nabout the language barriers?  People haven't forgotten all their\nlanguages.  But they've all learned English in addition, and English\nseems to be the de facto \"Esperanto\" that the fellow 80 years ago was\nlooking for.  Sometimes even the most Utopian dreams can actually come\ntrue.  Go know!  They just have to wait for the right time.\n\n\nIBM IS ALL OVER THE WORLD\n\n      Everybody knows that IBM, and the MVS operating system, is all\nover the world, in many countries.  There is a lot of \"National Language\nSupport\" (known as NLS) in IBM's products, MVS included.  Just go to\nIBM's web site, www.ibm.com, and you'll see the long list of countries.\nYou might think that \"it's all well and good, but how does that relate\nto me?\"  Well, with the Internet being what it is, and with newsgroups\non the Internet reaching out to MVS sysprogs all over the world, as soon\nas we get onto one or more of the newsgroups and have a discussion, we\nfind ourselves talking to people from Europe, Asia, Australia, Africa,\nof course North and South America, and just about any place except\nAntarctica.  (I don't think IBM has established a North Pole office on\nthe ice yet.  But the technology is better now.  And I don't think\nthey'd need a raised floor for a datacenter there.)\n\n      Being in charge of the CBT Tape contributions, I feel the effects\nof internationalizaton a lot more.  Just a few days ago, a fellow in the\nmiddle of Siberia wrote me with a modification of a fantastic program\ncalled IEBLIST (a quick dataset lister for DASD packs, but much more\nversatile than your usual VTOC lister programs).  IEBLIST was written by\na Brazilian fellow, (then) working for IBM Portugal, whose name is\nRicardo J.  Paranhos.  Since Ricardo (who speaks and writes Portuguese)\nwas an IBM'er and an excellent Assembler coder, his program was\nsupremely useful to everyone (see CBT Tape File 510, member name\nIEBLIST).  But the allowed dataset selection criteria needed some more\ntweaking.  The Russian fellow, Alexander I. Vasilenko, (who works for\nthe Krasnoyarsk Railway System) put some extra code into IEBLIST to\nallow selection of datasets by either \"creation date\" and/or block size.\nThen Alexander sent his code to me.\n\n      Well for me, this was a scenario entitled \"IEBLIST revisited.\"\nThe first time I had seen IEBLIST five years ago, the place where I\nthen worked, needed the program very much.  So I didn't want to leave\nthe Portuguese comments just as they were.  Somebody who didn't know\nPortuguese might have to read them later.  So I wrote to Ricardo\noffering to try and translate them into English.  I bought a Portuguese\ndictionary, found that Portuguese is a lot different from Spanish, and\ngot about a third of the way through the program, before time\nconstraints (and my boss) forced me to stop.  Ricardo checked my\ntranslations and found them OK.  Then he went a bit further and\ntranslated a few more of the comments himself.  But about half the\nprogram's comments still remained in Portuguese.  When Alexander sent me\nhis modified version, I decided to translate the rest of the comments\ninto English.  As of this writing, we can't locate Ricardo, but both\nAlexander and I appreciate his work very much, and we both want to\npublicly thank him.\n\n      This is what the MVS world has now become, in microcosm.  While I\nhad Alexander's attention, I asked him to send me the code pages for\nEBCDIC Russian Language support.  The issue was relevant to IEBLIST\nitself, because I wanted to know if I should uppercase the dataset names\nthat were being reported.  But I worried that the technique for\nuppercasing characters in Russian might be different from that in\nEnglish.  (In English you don't need a translate table.  Since uppercase\nletters in EBCDIC in English are represented the same as lowercase,\nexcept for the X'40' bit, you can uppercase any letter in English by\n\"or-ing it\" against a blank, which is X'40' in EBCDIC.)\n\n      I had had another issue with MVS in the Russian language.  When\nValentin Chernyak first released the source code to his marvelous REASM\ninteractive disassembler program which runs under ISPF, I had seen some\nRussian language pds member names, and I was confused by them.\nValentin's REASM source code is on CBT Tape File 243, (the rest of his\nproduct is on Files 238 thru 242) and the Russian pds member names have\nsince been cleaned up.  But I wanted to know, from Alexander, whether\nIBM permits Russian-language pds names, dataset names, or volume names\nin the MVS operating system, when NLS support for Russian is enabled.\n\n      Alexander answered all my questions and he sent me a copy of the\nEBCDIC Russian language code pages.  I found out that the \"or-ing\" trick\nwith blanks doesn't work in Russian.  Since the EBCDIC representation of\nRussian lowercase letters does not fit nicely with the EBCDIC\nrepresentation of the corresponding uppercase letters, you have to use a\ncustomized translate table to \"uppercase\" the characters in Russian.\nObviously, for other languages that have uppercase and lowercase\nletters, you'd need a different customized translate table for that\npurpose.  So you can't use one technique to cover uppercasing for\nmultiple languages.  I also found out that pds member names can\ncertainly be in Russian letters.  (Remember SMP4, where many of the pds\nmember names were hex values?)  But dataset names have to be in English\ncharacters, and the jury is out on volser names.  Alexander tells me\nthat where he works, they haven't tried to use Russian volser names.\n\n      So from this experience, I have already seen an eyeful.  I have no\nexperience at all with the \"double byte character set\" languages like\nChinese, Japanese, or Korean.  But even with a \"single byte character\nset\" that has different characters, like Russian, I've encountered\nplenty of MVS issues.  And I've come to the conclusion that\ninternationalization is certainly a relevant consideration in today's\nMVS world.\n\n\nOTHER USEFUL PROGRAMS FROM THE WORLD OVER\n\n      Now that we've gotten your curiosity going about CBT Tape\ncontributions from all over the world, it is only fair to you that we\nmention a few of them to you.  To get hold of the CBT Tape files over\nthe Internet, just do a www.google.com search for \"CBT Tape\", and our\nCBT Tape web site should come out at, or near, the top.  Everything\nthere is free to download, and you don't need a password.\n\n      CBT Tape Files 535, 536, and 670 come from my friend Deru Sudibyo\nin Indonesia.  Deru used to work for IBM Indonesia and is (like Ricardo)\na very good coder.  File 535 contains a TSO command to do dynamic\ndataset allocation and deallocation, and it is quite a bit more general\nthan most commands of this type.  File 536 contains XDI, a combined\nCA-Xcom and CA-DIspatch solution for Report Distribution Management.\nFile 670 contains a mathematical functions package for REXX, similar to\nthe math function package for PL/I.  You can see that Deru has done some\nvery useful work.\n\n      I have to say something about the very large Australian\ncontingent.  My first introduction to them was through Greg Price, who\nis a very skilled Assembler programmer, and who has produced enormous\nenhancements to the REVIEW program (CBT Files 134 and 135), including an\nISPF-like editor that works under both RAW TSO and ISPF.  Greg has also\nadded a lot of PDSE support to the PDS program package (CBT File 182),\ntogether with John Kalinich.  (Here you see some more international\ncooperation.  John Kalinich is in Saint Louis, Missouri.  Greg is in\nMelbourne.  No problem.)\n\n      Andrew Armstrong's varied and highly innovative contributions\n(Files 628, 629, 640, 647, 706, and 725) have already been mentioned a\nbit here, and his work deserves much more \"press\" than we have space for\nthis month.  Paul Gillis (File 382) has a nice collection of programs,\nMurray Nicholas (CBT File 345) has provided a generalized MPF exit which\nis the basis for Glenn Siegel's enormously enhanced \"generalized MPF\nexit package\" that is on File 708.  Now that Glenn's package is out, I'd\nrecommend installing it over Murray's package, but Murray's package is\nthe one that started things off.  I'd also like to refer you to Gerard\nNicol's REXX function package (CBT Files 323 and 324).\n\n      Solomon Santos (CBT File 555) is a Filipino from Manila who lives\nin Sydney, Australia, and who has been a longtime contributor to the MVS\ncommunity in various ways.  David Marsden (Files 374, 375, 376) has sent\nin some very innovative things, especially on File 376.  I also want to\nthank Shane Ginnane for his good work, as well.\n\n      Contributors from Spain have been there too.  Salvador Carrasco\n(File 386) had been employed as a computer operator, and taught himself\nMVS systems programming without any help or job tasks in the field.  As\na result of his enormous efforts to learn the field on his own (which is\nalmost unheard of), Salvador's contributions and utilities are unique\nand highly original.  I think he eventually got a systems programming\njob.  (At least I hope so.)  Other contributors from Spain are:\nBaldomero Castilla (File 480 and 481), Jose Maria Martinez and Angel\nLuis Dominguez (File 513), and Chema Alvarez (File 687).\n\n      It's time to close, but I can't forget to mention Paul Moinil's\noriginal contributions and modifications to other CBT files (Files 453\nthru 459) which, although they are getting a bit old, are still relevant\ntoday.  Paul has retired from computing altogether; he is from Belgium\nand he lives in Italy.  Paul's friend Antonio Colombo (formerly of\nAmdahl Italy) has sent Paul's work to me over the years, and I still\ncorrespond with them through Antonio.  Antonio used to actually mail\n\"real tapes\" to me, in years gone by.\n\n      So I hope you've gotten a small glimpse of \"MVS International\", so\nto speak.  MVS sysprogs and programmers everywhere are a very clever and\ninnovative bunch.  So when you have access to the work of more of them,\nyou'll always benefit from it.  I wish all of you the best of everything,\nand I'm looking forward to seeing you here again next month.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0605MY": {"ttr": 29192, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x12\\x01\\x06\\x10\\x0f\\x01\\x06\\x10\\x0f\\x03$\\x01\\x05\\x01\\x05\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-04-10T00:00:00", "modifydate": "2006-04-10T03:24:12", "lines": 261, "newlines": 261, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           MAY 2006\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.\n\n\nWHY CONTROL BLOCKS?\n\n      Everybody who has the slightest acquaintance with MVS internals,\nwill quickly notice that many of the storage areas in a running MVS\nsystem are called \"control blocks\".  Control blocks are defined (by IBM)\nas blocks of data in computer storage, which are somehow related to each\nother by function.  It really goes much further than that, as we will\nshow.  Often, a definition of a term does not really tell you all the\nconsequences and the details which are implied by that term.  In many\ncases, the definition does not tell you the WHY.  Someone who is really\nfamiliar with the usage of control blocks in MVS, will tell you that\nthis basic definition of control blocks actually leaves most of the\ninformation out.\n\n      I'll show you another IBM definition, just to make my point.  The\nother definition is in the area of SMP/E, something that most MVS\nsysprogs have to deal with sooner or later.  SMP/E is IBM's program\npackage to install updates and fixes to the MVS system.  The usual basic\nSMP/E definitions:  RECEIVE, APPLY, and ACCEPT, are easy enough to\nunderstand intuitively, even for a novice.  RECEIVE means \"getting a fix\n(technically known as a SYSMOD) into the system.\"  APPLY means to\nactually install the fix into executable libraries.  And ACCEPT means\n(very roughly) making the fix permanent.  Those concepts are pretty easy\nto grasp.  But what about the concept of JCLIN?\n\n      JCLIN is defined (in the IBM books) roughly, as \"a job stream of\nassembly, linkedit, and IEBCOPY job steps. ... This job stream is used\nas input to a JCLIN command to update or create entries in a target\nzone.\"  That definition doesn't really tell you what JCLIN does.  It\njust tells you roughly, that it is JCL which you feed into an APPLY job.\nThe definition doesn't tell you the WHY of JCLIN.  The WHY of JCLIN\nreally is, that SMP/E needs to know the structure of all the executables\nin the system, and how they hang together.  That's what the linkedit\njobs in JCLIN do.  And SMP/E also needs to know the library locations\nwhere all the pieces of the system, as shipped by IBM, are supposed to\nreside.  That's what the IEBCOPY jobs (and the SYSLMOD DD of the\nlinkedit jobs) do.  This is really the purpose of the \"JCL\" which has\nbeen fed \"in\" to the APPLY job.  When you've dealt with SMP/E a lot, you\nknow this.  Otherwise, you probably don't.  The basic definition of\nJCLIN doesn't give you much of a clue in any case, and it doesn't\nexplain itself.\n\n      The situation is similar with control blocks.  The WHAT of control\nblocks, that they are related pieces of data which the system needs, is\nsomething that it doesn't take long for a new MVS sysprog to learn.  But\nthe WHY is a slightly longer story.  To give a hint toward an answer, we\nmight ask the rhetorical question:  \"What came first?  The controlling\ndata structures or the programs?\"  And the answer is:  Probably they\nwere designed together.  Then another question:  \"What if you change the\ncontrolling data, and not the programs?\"  Answer:  Then you've got all\nthe flexibility that you need.  And that, folks, shows you the value of\ncontrol blocks.  The data in the MVS control blocks allows you to wield\nall the flexibility and control that was designed into the system.  The\ncontrol blocks \"give the orders\".  The system programs just carry out\nthe orders.\n\n\nAN EXAMPLE\n\n      A few months ago, we wrote about \"TSO/E control blocks\" in this\ncolumn.  To show an example, one of the TSO/E control blocks is the\nINMXPARM control block.  The INMXPARM control block regulates how much\noutput a single TSO TRANSMIT (XMIT) command, executed in a single MVS\ninstance, is allowed to produce.  If 5 million lines is in the control\nblock, then the XMIT command output gets cut off after writing 5000000\nlines.  If 30000 lines is in the control block, then an XMIT command can\nonly produce 30000 lines of output.  If 0 (zero) is stuffed into the\ncontrol block, then XMIT will not be able to produce any output.  The\nXMIT program has not changed.  But its behavior has changed, because of\na controlling value that has been stored in the appropriate place, in\nthe appropriate control block, located externally to the XMIT program.\n\n      In actual fact, a lot more controlling information is present in\nthe INMXPARM control block, and this affects a lot of the behavior of\nthe TSO XMIT command.  The dataset name that logs the XMIT command\noutputs is determined there.  The warning threshold and warning\nintervals are specified there.  And a lot of other controlling\ninformation is there.  Although the INMXPARM control block is not\ndescribed by a publicly specified macro, you can see a good guess at its\ncontents by looking at the IKJXPRM member in the MODGEN member of File\n731 of the CBT MVS Utilities Tape.  But the bottom line idea is, that\nall of the possible varied behaviors of the TSO TRANSMIT program are\ncontrolled by the values and quantities in the INMXPARM control block.\nThe control block controls the behavior of the program.\n\n      Now, we're getting a clearer idea about what control blocks do.\nBut we'll even do better than that!\n\n\nPASSING CONTROL DATA BETWEEN MULTIPLE PROGRAMS\n\n      Sometimes (read USUALLY), the state of an ongoing process in MVS,\nis completely described by the contents of one or more control blocks.\nThese control blocks, and the data quantities within them, completely\ndescribe and keep track of what is going on in the process.  Such a\nprogram design is often implemented within the MVS components.  And that\nis how many MVS components actually work.\n\n      If a program wants to \"know\" about the current status of the\nprocess, it need merely query the contents of the relevant control\nblocks.  The program does not need to have access to any data areas that\nare located within some other program.  In this design, all of the\ncontrolling data is located externally to any of the processing\nprograms.  And now, we have really begun to understand why MVS has so\nmany control blocks.  The purpose of the control blocks is to keep the\ncontrolling data EXTERNAL to any of the processing (system) programs.\n\n      So when a system program wants to affect how some system process\nis being executed, it need merely change the relevant quantities in the\nappropriate control blocks.  In other words, when this program design is\nimplemented (as it is in most of MVS internals), the control of the\nprocesses is completely carried out by data that is external to the\nrunning programs.  Most of MVS has been designed to work this way.\n\n      Now, we are really zeroing into the REAL REASON why MVS has\ncontrol blocks.  The real purpose of control blocks is to keep all of\nthe controlling data external to all of the processing programs.  Then,\nif a programming change is necessary to one of the processing programs,\nthat change will not directly force a corresponding change to any other\nprograms, except in how they affect the external data that is within the\ncontrol blocks.  If a new field is required by the programming change,\nit is added to (or changed within) the control block, and any other\nprograms which need to read or change that new field, must be adjusted\naccordingly.\n\n      This will give you much insight into understanding IBM fixes.  If\nyou spend time reading APARs and PTFs as they come from IBM, you will\nnotice that they usually change the contents of a control block, and\nthen they will also supply new copies of all the relevant programs so\nthese programs will properly access that new (or changed) control block\nfield in the new way.\n\n\nMACROS\n\n      Control blocks, and the data fields contained in them, are almost\nalways described by macros.  Macros are Assembler (or PL/X) statements\nwhich are centrally packaged in macro libraries, and which describe the\ndetailed structure of all the fields in a given control block to a\nprocessing program.  The MVS data areas books, which contain\ndescriptions of all the publicly available control blocks for a given\nrelease of MVS, are actually constructed by automated processes (from\nwithin IBM) from actual macros in SYS1.MACLIB, SYS1.MODGEN, or in the\nspecialized macro libraries that are sometimes distributed with less\ncommon MVS components.\n\n      Knowledge of many MVS control blocks is publicly available.  And\nyou can learn about the structure of these control blocks, either by\nlooking in the MVS Data Areas books, or in the actual macro libraries\n(usually SYS1.MACLIB or SYS1.MODGEN).  Some of the MVS control block\ndescriptions are not publicly available.  IBM calls these control blocks\n\"OCO\" (Object Code Only distribution), but it really means that IBM does\nnot want to publicly disclose the details of their contents.  The macros\nwhich describe OCO control blocks are kept internally within IBM, and\nare not distributed in the system macro libraries.  So IBM can assemble\nprograms which refer to those control blocks, but (officially) you\ncan't.\n\n      Since most of MVS is coded using this design, with the controlling\ndata being external to the processing programs, and with this data being\nlocated in \"control blocks\", you can understand much of what is going on\nwithin any MVS component by studying the contents of the relevant\ncontrol blocks.  Often, you don't even need to know any of the details\nabout how the processing programs work.  That is one of the beautiful\nthings about MVS.  Since the controlling data is external to the\nprograms, you can follow the progress of much of MVS processing, just by\nhaving an understanding of the contents of the relevant control blocks.\nDetailed knowledge of the actual programming is usually unnecessary, if\nyou are a sysprog trying to solve a system problem.\n\n\nI'VE DONE IT TOO\n\n      I've implemented this \"control block\" design in several of the\nutilities that I've written myself.  I'll briefly describe what I've\ndone, and how I've done it.  For all the details, you can download File\n533 from the free CBT Tape collection.  (Do a www.google.com search on\n\"CBT Tape\" to find our website, which should come out near the top of\nthe search.)\n\n      The two relevant programs are called VTT2TAPE and VTT2DISK.  Both\nprograms are designed to run on any MVS system, and they convert the\ncontents of any physical tape, to (what I call) FB-80 AWS disk format.\nVTT2DISK reads in a tape, and converts its entire contents to AWS format\n(the data being folded over into FB-80 record format in MVS).  And the\nother program, VTT2TAPE, reads this FB-80 folded AWS disk file, and can\nre-create the original tape from it.  You can export the contents of the\nFB-80 AWS file from MVS to another system, like a P390 or a FLEX-ES\nsystem, using FTP, and that file (on OS/2 disk for the P390, or on Linux\ndisk for FLEX-ES) can then be directly read as a tape by either of those\nsystems.\n\n      Since all disk data in MVS has to be blocked somehow, and there\nisn't the concept of a continuous \"tape\" file containing (say) a gig or\ntwo of data on MVS DASD, I had to pick an arbitrary way of folding all\nof the continuous tape data, and the AWS \"header\" data that was\nsandwiched in between that, into a blocked MVS disk file.  I picked\n80-byte fixed blocked \"card image\" format.  Fixed blocked 80-byte card\nimage data is probably the easiest data to deal with, and transport,\nwithin MVS systems.  I don't like VB, because it introduces extra data\ninto the \"tape\" file.\n\n      So let us illustrate what I wanted to do in the VTT2DISK program.\nI would use EXCP to read a block of data from the actual tape on the\ntape drive.  This data is read into a buffer that is located in my\nprogram's storage.  Then I have to measure how much data is actually in\nthe block, construct an appropriate AWS header to precede the block in\nthe AWS file, fold that header into the FB-80 output file, and then fold\nthe data in afterwards.  Although I could have done this job \"quick and\ndirty\" using the MVCL instruction, I wanted to keep careful track of the\nprocess, and to be able to debug any part of it.  Therefore I wrote a\nsubprogram (called FOLDEM) to do the actual data folding.\n\n      The main VTT2DISK program communicates with the FOLDEM subprogram\nusing only a control block that I designed.  The current state of how\nthe data folding has progressed, is completely described by the fields\nin this FLDAREA control block.  The calling program does not have to\nrefer to any data in the subroutine.  It only has to have a current copy\nof the FLDAREA control block.  Same with the subroutine.  It only needs\nto have a current copy of FLDAREA.  Both routines update the control\nblock, which keeps complete and perfect track (hopefully) of all the\ndata folding proceedings.  Again, for the actual code, you have to look\nat CBT Tape File 533.  But you get the idea.\n\n\nSUMMARY\n\n      Today, I've talked about the REAL purpose of MVS control blocks,\nwhich is to implement a programming design in which all of the\ncontrolling quantities of an MVS process reside OUTSIDE all of the\nprocessing programs.  All relevant controlling data is in one place in\nsystem storage, and any programs needing the data, have to access that\nstorage and refer to its (carefully designed and formatted) contents.\nSince most of the \"amateur\" Assembler language programming that we do,\nis not done in this style, I have to spell out how MVS program design is\ndifferent.  Only then, can we understand the real purpose of MVS control\nblocks--the WHY of MVS control blocks.\n\n      Once we understand that, we can look at the structure of most IBM\nPTFs or APARs, and understand what they do.  Often a control block is\nchanged, and all the processing programs that refer to this control\nblock, are supplied in new versions, which refer to the changed control\nblock in its new, changed way.\n\n      I wish all of you a good month, and all good things in general.\nAnd I'm certainly looking forward to seeing you here again, next month.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0606JN": {"ttr": 29441, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\t\\x01\\x06\\x12\\x9f\\x01\\x06\\x12\\x9f\\x10\\x12\\x00\\xe3\\x00\\xe3\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-05-09T00:00:00", "modifydate": "2006-05-09T10:12:09", "lines": 227, "newlines": 227, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           JUNE 2006\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.\n\n\nTHE WORLD SHOULD BE FULL OF COLLECTORS\n\n      I am a \"fairly\" firm believer in my not having to do the same job\ntwice, or at least too many times.  Of course, there are some advantages\nto repeating the performance of a job.  It drives the procedures deeply\ninto your head.  You become familiar, in fact, quite intimately\nfamiliar, with the processes.  They become part of your \"skill set\".\nAnd for us, in our position, that is goodness, because as the system\ndoctors, we have to have a good handle on all of the everyday methods we\nuse, and we have to show that we are always confident in getting the\njobs done.\n\n      But to have to repeat too many times, no!  We have to use\nshortcuts too, otherwise, we'd never get our jobs done in a reasonable\namount of time.  In fact, one of the ways I feel I can tell a relative\nnewcomer from an \"experienced hand\" in this business, is to see how many\ntools \"for shortcuts\" that he or she is familiar with using.  Over the\nyears, I was always happy with myself about how quickly I could get most\nof the systems programming jobs finished.  Clever tools that people have\nwritten, make this possible.  Saving your old JCL also makes this\npossible.\n\n      Problem is, that if you go from one shop to another, can you bring\nyour techniques with you?  If the techniques are dependent on the use of\ncommercial products, like \"Omegamon\" (from IBM) or \"Resolve\" (from BMC\nSoftware), then what if the new shop doesn't have them?  Are you stuck?\nSometimes yes, sometimes no.  Of course, you don't have to start again\ncompletely from square one, because you know the KIND of task you want\nto accomplish.  You're familiar with the particular operation, such as\nmaking a certain load library authorized.  But at the new place, you'll\nhave to find a substitute tool (if you can) that does the same thing.\nDepending on the particular operation you're trying to do, this can be\nhard, or even impossible, in the new environment.\n\n      So the solution I've made for myself, is to collect a lot of free\ntools that I can bring from one place to another, and I can install\nthem anywhere.  These are unencumbered by licensing, and they have been\ntried and tested to get the job done, as well.  For pure portability, I\nhave come to like the REXX-based tools (such as those written by Mark\nZelden - CBT Tape File 434) a lot, because they are easy to install\n(just copy them into a CLIST library) and there's less objection from\nmanagement about running them.  A REXX exec, even if it digs deeply\ninto system control blocks, conjures up the image (in a manager's mind)\nthat is similar to what a CLIST does.  It can't be objectionable,\nbecause it's not a \"product\".  Nevertheless, the bread and butter of my\ntechniques is still based on collecting Assembler programs, and\nAssembler-based tools.  However, the bottom line with me is always\nthat:  \"Anything which works, is good, and anything which helps me now,\nis even better.\"\n\n\nSOMEBODY HAS HAD TO SAVE THE STUFF\n\n      How do you go about acquiring these tools that you will use\nthroughout your working life?  Of course, you can do some of this for\nyourself, in a very simple way.  You can save all the CLISTs, REXX\nexecs, edit macros, and JCL that you have ever written.  I always try to\ndo this for myself.  It helps me avoid having to spend time at a new\nsite, or even at the same site, repeating the work I've already\nsuccessfully done before.  Getting JCL correct, for some tools such as\nADRDSSU, is always a pain in the neck, if you have to start over from\nthe beginning.  It pays to save all the old job streams that have\nalready worked before.\n\n      Using the OUTDSN keyword of the TSO XMIT command helps me to\nconvert pds'es into easy-to-transport FB-80 sequential files.  I find\nthese are also very helpful (at my current site) for backup purposes, in\ncase any of my files (God forbid) ever gets \"wiped\".  Entire tapes can\nbe saved on cd-roms or other PC-based files, using the VTT2DISK program\nthat I've written (see CBT Tape File 533).  VTT2DISK converts an entire\ntape into an AWS-format tape image on DASD in FB-80 format, which can\nthen be downloaded in BINARY to a PC, and you can copy that PC file to a\ncd-rom disk.  To reconstruct the real tape from the cd, or the PC file,\njust upload it in BINARY from the PC to an FB-80 target file on the\nmainframe, and run my VTT2TAPE program (also from CBT Tape File 533)\nagainst that FB-80 file, to cut a real tape.  So tapes can be put on\ncd-rom disks, and vice-versa.  You don't really need to have a tape\ndrive in order to save and access your tape data.\n\n      That's all well and good for your own stuff.  How do you go about\ngetting access to other people's tools?\n\n      Well, as you probably can figure out, the whole world is full of\npeople who save things and collect things.  Just look on Ebay for some\nthing you'd like to have.  I once broke a \"Jackie Gleason Honeymooners\"\nmug that my wife had been saving.  A short time afterward, I was able to\nget on Ebay, and buy nine of them.  It made my wife a lot happier.\nPeople save a lot of miscellaneous stuff, including MVS tools and parts\nof old MVS operating systems.  You just need to know how to \"network\"\nin order to have access to those resources.\n\n      One place you can go, to get a huge head start, is the CBT Tape\nweb site.  Just do a Google search (www.google.com) for \"CBT Tape\" and\nthe CBT Tape web site should come up at, or near, the top.  You can\ndownload anything that's available from there, and you don't have to be\na \"member of anything\" or even enter a password.  Just go there and get\nall the tools you want or need.\n\n      The user group lists, such as IBM-Main, or the other Listserv\nbased groups, and the yahoogroups based groups, etc., can provide a lot\nof connectivity with other people who will be able to help you.  See my\nApril 1998 column in \"Technical Support\" (member CL9804AP in CBT File\n120, or on the Naspa archives) which talks about how to join the\nIBM-Main group, and other Listserv based groups.  Go to\nwww.yahoogroups.com to find and join the Yahoo groups of your choice.\nI usually get \"digest\" files from all of the groups, which are all the\nposts that were accumulated during one day, or (in the case of the\nyahoogroups groups) collections of 25 messages or less, within each\nday's postings.  This way, I can archive the digests without having to\nread all the messages right now, and I can search them later if I need\nsome information, or to search for a person's current email address.\n\n      I write to people who have posted to these groups, to ask them for\nhelp with problems, or to discuss any MVS issues that I have.  You can\neither write to the entire group, or if it is a more personal or\nsensitive issue, you can write to one of the people personally.\n\n\nOPTIONAL MATERIALS\n\n      A licensed user of any flavor of MVS (z/OS, OS/390, MVS/ESA,\nMVS/XA and so on backward) can order tapes of what is termed \"Optional\nMaterials.\"  Optional Materials may be translated as \"source code\" and\n\"IBM Private macros.\"  These are available (for non-OCO modules and)\nfor many of the IBM program products, as well as for the base operating\nsystem.\n\n      It used to be, at the MVS/XA level and before, that IBM would give\naway the source code of most of its MVS modules, to any licensed user\nwho requested them.  PTF levels of the modules were (then) available on\nmicrofiche.  After ESA and the OCO restrictions on many of the newer\nmodules, source code and logic manuals were no longer made available for\nthem.  At the time of the introduction of MVS/ESA, around 1989, IBM\nitself recommended that anyone who had logic manuals (and source code\ntapes for that matter) had better save them.  Some people have saved\nthese materials even until now.\n\n      Since these materials are the \"licensed materials\" and property of\nIBM, they can't be distributed on public software collections such as\nthe CBT Tape collection.  But if you are currently working at a licensed\nMVS site, I'd strongly recommend that you order all the optional\nmaterials that your site is entitled to.  There is no extra cost\ninvolved, as far as I have ever heard.  You just have to speak to your\nIBM representative and request that the Optional Materials be made part\nof your order configuration.  It's a win-win situation, even if you\ndon't think \"right now\" that you're a good Assembler programmer.  The\ntruth is that you're looking to the future, and you don't want to close\noff any possible future opportunities.  Trust me on this.  I know, from\nexperience (both good and bitter)!\n\n      You may worry about how to take care of the Optional Materials\ntapes, when they come.  Of course, you can leave them in the closet, as\nmost people used to do.  But I have a better idea, so that the materials\nwill be more quickly accessible when you need them.\n\n      Optional Materials tapes are almost always written in IEBUPDTE\nSYSIN format.  This means that each member of a dumped pds is\n\"sequentialized\" into one physical sequential (FB-80) file, and a\nseparator card of the format ./ ADD NAME=memname (starting in column 1)\nis put before each member.  The TAPEMAP program (CBT Tape File 299) can\nread a file on a tape, which is in this format, and report all of the\nmember names of pds members in that tape file.  So it comes out as a\nresult, that you can TAPEMAP the Optional Materials tapes, and the\nTAPEMAP program will report all of the member names (read source modules\nand macro names) contained therein.  This TAPEMAP report is a good thing\nto have, and if you make an FB-133 partitioned dataset out of all the\nTAPEMAP reports of all of your Optional Materials tapes, you can easily\nsearch for member names, and find out which tapes contain a given source\nmodule or \"private\" macro, and on which file number.  Then you should\nkeep some IEBUPDTE JCL handy, in order to dump any file from any given\ntape, into an appropriately named pds on DASD.  In that way, you'll be\nable to quickly locate and access any source module that you may need,\nor want to look at.\n\n      I personally would go one step further.  I would convert all the\ntapes into cd-rom disks, duplicate and archive them.  That'll keep these\nmaterials safer.  And it is much more compact to have a couple of cd-rom\ndisks, than a big stack of tapes.  They are also easier to duplicate and\narchive.  If you already have a big pile of tapes, why create a second\npile just for safety?  Usually there is no room in the tape closet.  And\nif you make the cd-roms, you still have the tapes themselves, for\nbackup.\n\n      I use the VTT2DISK program (as described above) to convert the\nentire tapes to disk files, and I FTP them or otherwise download them,\nin BINARY, to a PC.  Then I can either copy them to a cd-rom as is, or\nzip them first, to save space.  An awful lot of tapes can be fit onto\none cd-rom disk in this way.  Another alternative is to create the pds\nfiles, one by one on MVS, using a big batch job to automate the process,\nrun the TSO XMIT command under TSO-in-Batch, to sequentialize the\npds'es, and then download (in BINARY) the individual XMIT-format files\nto the PC and write them to cd-rom.  All of these methods work fine.  If\nyou want to view an XMIT-format MVS file directly on the PC, you can use\nthe marvelous \"XMIT Manager\" program which is downloadable from the CBT\nTape web site, and you can see, or print, all the pds members,\ntranslated to ASCII.\n\n\nSUMMARY\n\n      I am of the opinion that MVS systems programmers should be\npackrats.  In other words, we should intelligently (and neatly) save as\nmany MVS materials, good JCL, and other stuff, as we can.  It pays to\nput in some extra time, to make these materials quickly accessible, and\nto allow any given item to be easy to find.  I firmly believe and know\n(from many years of experience) that reusing and re-customizing old\njobstreams can save tons of time and work.\n\n      Next month, I hope to continue on this topic, concentrating more\non searching techniques, to make it more effortless to find all the old\nstuff that you've already saved.  Have a good month, and I hope to see\nyou here again next time.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0607JL": {"ttr": 29446, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00H\\x01\\x06\\x15\\x8f\\x01\\x06\\x15\\x8f#5\\x01p\\x01p\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-06-07T00:00:00", "modifydate": "2006-06-07T23:35:48", "lines": 368, "newlines": 368, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           JULY 2006\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.\n\n\nTHE WORLD SHOULD BE FULL OF COLLECTORS - 2\n\n      As a longtime MVS systems programmer, a large part of my arsenal\nof tools consists of my tape collections, my JCL collections, and\nwhatever source code examples, especially in Assembler language, that\nI've been able to keep nearby.  Nevertheless, no matter how avid a\ncollector that anyone is, everyone knows that a big pile of tapes in the\ncloset has much POTENTIAL value, but its actual value varies.  If you\ndon't know what is IN the collection, you might have all the gold in the\nworld there, but you won't be able to use it.  My experience tells me\nthat it still pays to save all those tapes, because you (or someone\nelse) might be able to make good use of them LATER, and I absolutely\nadvocate NOT throwing them out.  But there's an even better idea.  If\nyou can use these tapes NOW, that's much better than only potentially\nbeing able to use them later.\n\n      It takes only a little work to make all your tapes and JCL\nsearchable.  You can even make all of your PTF tapes searchable.  The\nidea is something like organizing a filing cabinet.  Not everybody does\nit, but once you do, it's relatively easy to find most of the things\nthat are in there.\n\n      The tools that it takes are things that not so many MVS sysprogs\nuse on a very regular basis, even if they do know about them.  I have\nfound that a certain combination of these tools can be used to create\nindexing pds'es, which can then be searched very easily, using the FIND\n\"pds multiple member\" string searching capability of the free PDS\nprogram package.  And once everything has been set up, you can quickly\nfind almost any software materials or PTFs that are on any of the tapes\nin your tape closet.  If you need something quickly, you will pick the\nexact tape and files that are needed, and load them (and only them) onto\ndisk.  If you can't already do this, the way you are set up now, doesn't\nthe prospect sound exciting to you?  Actually, with only a moderate\namount of attention, it's quite easy to accomplish.\n\n\nPRODUCING PDS MEMBERS CONTAINING THE TAPE REPORTS\n\n      You can't find out anything about what's on a tape unless you read\nthe tape on a tape drive.  I am one of those people who don't trust the\npaper label that is stuck on the tape, to tell me completely what that\ntape contains.  I have better tools, and if I can use them by reading\nthe tape on a tape drive to discover its real contents, then I don't\ncompletely trust what's on the paper tape label to help me find the data\nthat I need.\n\n      In order to read a tape in a manner that is appropriate for my\nsearching purposes, that is, to find out member names that are on\nIEBCOPY or IEBUPDTE backed-up pds files, or to find out the dataset\nnames of the tape files, or to find the DASD dataset names backed up by\nan FDR tape, or to find out PTF particulars (such as which FMID the PTFs\nbelong to) on a tape containing PTFs, we must use an appropriate tape\nsearching program.  Such searching programs exist, and (for the most\npart), they are free.  To obtain these programs, do a www.google.com\nsearch for \"CBT Tape\" to get to the free CBT Tape website, and from\nthere (you don't need to be a \"member of anything\" or know any password)\nyou can download all of these MVS tools, and install them on your MVS\nsystem.  These are free and public programs, and in my extensive\nexperience with them, they are \"very tried\" and \"very true\".\n\n      What are the appropriate programs to use?  For starters, I always\nuse the TAPEMAP program from CBT File 299.  TAPEMAP will show you, not\nonly the sequence number and name of all files on the tape, and their\nphysical file characteristics, but for many types of tape backup files,\nsuch as IEBCOPY or IEBUPDTE, TAPEMAP will show you (in its second\nreport) all the backed-up member names, or for PTF files, TAPEMAP will\nshow you the PTF numbers too.  For FDR backup tapes, TAPEMAP will list\nall the DASD file names that were backed up to that tape by FDR or\nFDRDSF.\n\n      For PTF files in particular, I use the two programs from CBT File\n118 called PUTXREF and SMPUPD to read the tape.  PUTXREF produces a\nreport showing which FMIDs each PTF, APAR, FUNCTION, or USERMOD belongs\nto.  And the outputs of the PUTXREF program come in several very useful\nformats that are appropriate for further processing.  (These support\nFORFMID-like preprocessing of PTFs without directly using SMP/E.)  The\nSMPUPD program, whose primary purpose is to break up an SMPPTFIN-format\nfile into a pds containing individual PTFs, can also be used (with\nPARM=READ) to produce an informative report about the individual PTFs\nthat the SMPPTFIN-format file contains.  See Figure 2 for an\nillustration of both of these programs.\n\n      If you know that the tape contains a DFDSS backup file, then the\nappropriate tape-reading program will have to be ADRDSSU (the DFDSSdss\nprogram) itself.  The COPYMODS program from CBT File 229, using its\nPARM=READ capability, has (besides its many other strengths) the almost\nunique capability of automatically reporting on, and bypassing all\nleading tape marks on a tape (even 200 or more of them), and telling you\nwhat else is there, after all the tape marks.  In any case, whatever\ntape-reading tool you do use, the idea is that the tape report has to\ncontain tell-tale search strings which will help you find your data.\nThese might consist either of dataset names, and/or pds member names or\nPTF names which will occur in the backed-up data.\n\n      I then use the SDSF \"PRINT OUTDSN\" command, or whatever command\nfor copying the report data is appropriate to your spool browsing\nprogram, to copy the tape report into a member of an appropriately\nconstructed pds.  For images of printed reports, I prefer pds'es that\nare Fixed Blocked with an LRECL of 133; these usually have enough room\nto contain all of the printed data.\n\n\nSEARCHING PDS'ES FOR MEMBERS CONTAINING A STRING\n\n      Once these tape reports have been produced, and they have been\nloaded into members of either FB-80 or FB-133 pds'es, then, I must\nlocate the search strings I want to find, in the pds members which\ncontain them.  That information will tell me on which tape, and on which\nfile of that tape, I can find the data I want.  For this search, across\nmultiple pds members in a pds, I use the PDS program package from CBT\nFile 182 (load modules are on CBT File 035 or 135, and you can copy the\nISPF panels and messages from File 182 for a quick install, if you don't\nwant to assemble the PDS program yourself).\n\n      The PDS program contains a pds multiple-member-oriented string\nfinding subcommand, called FIND, which you can run against any pds\nmember subgroup, and produce the output either as an ISPF member list\nunder PDS, called a MEMLIST, or as a member subgroup (called a SUBLIST)\nwhich is defined by the PDS program itself.  (Or you can display the\nactual records within each member, containing the strings themselves.)\nSearching the smaller list of members that contain the desired string,\nis (of course) easier than to search the entire pds, which might have a\nvery large number of members, most of which are not relevant to what you\nwant to look for.\n\n      Of course, to search a JCL pds for execution JCL that I want to\nfind, I can also use this same FIND subcommand of the free PDS program\npackage.  Suppose (for example) that I am having some problems running a\nDFDSS move of some datasets from one DASD volume to another, and I want\nto find some JCL in my (large) JCL pds which has already been proven to\ndo this properly.  I'll point the PDS program to the JCL pds, do an FIND\non some string like \"PGM=ADRDSSU\" using the FIND subcommand of the PDS\nprogram, and come up with a subset of pds members which contain the\nstring PGM=ADRDSSU and which most likely are DFDSS JCL examples.  The\ncomplete PDS subcommand string would be:\n\n   FIND : /PGM=ADRDSSU/ THEN(MEMLIST) or THEN(SUBLIST)\n\nThe colon (:) in the command, means to search ALL of the pds members.\nTo search a previously created subset of members, you would use an\nasterisk (*) instead of the colon.  And this would yield a subset of\n(the original group of) pds members which contains the desired search\nstring.  It's much easier to look at this small subset of members, than\nto search the entire pds for what I want.\n\n      This technique is the key to all of our efforts, whether the\nsearch is against a JCL pds, or it is against the tape indexing pds that\nwe have constructed.\n\n\nWHAT A TAPE COLLECTION PDS LOOKS LIKE\n\n      Suppose I have 60 tapes that I want to index in this way.  I would\nrun 60 TAPEMAP jobs against these 60 tapes, or one job against all of\nthem, if I can somehow keep the individual output reports separated from\neach other.  Then each of the TAPEMAP reports could be written to one\nmember of the TAPEMAP.OUTPUTS pds which is FB-133, preferably with the\nvolser of the tape being a part of the member name in the pds.  Since the\nTAPEMAP program produces two reports, the SYSPRINT report containing the\nphysical characteristics of the tape files, and the SYSPRNT2 report which\nholds the member names of pds members, or PTF numbers, or FDR backup data,\nI might want to make separate members of the pds with data from each of\nthese reports separately, as members TAPVOLA and TAPVOLB, respectively.\nEither way I do it, the PDS program product's FIND capability will easily\nbe able to locate any of the information I want to look for.  See Figure\n1 for a JCL example of such a TAPEMAP job.\n\n      I have to mention, that if you are in possession of one or more\nphysical CBT tapes, the TAPEMAP program can expand each of the files,\nwhich are in \"CBT973-compressed format\", and display all the member\nnames, and all the IEBUPDTE-embedded member names in all the files.  So\nif you TAPEMAP a genuine CBT tape, you'll be able to find all the member\nnames for almost all the files, in the SYSPRNT2 TAPEMAP report.\n\n      Now, searching the TAPEMAP.OUTPUTS pds using the PDS program's\nFIND subcommand, as we mentioned before, is a snap.  You can locate any\nmember name or program name or dataset name that was backed up on the\ntape.\n\n\nSPECIAL PROCESSING FOR PTF TAPES\n\n      In my opinion, the PTF tapes that your shop has, deserve special\ntreatment.  The reason for this is, that even though you may do\nregularly scheduled SMP/E processing for all your PUT tapes or CBPDO\ntapes or whatever, you may need, at some future point, to find or\nexamine a PTF that has not ever been RECEIVEd, or has not ever gotten\nonto your system.  Often the PTF tapes you get will also include later\nversions of a PTF, designed for a level of z/OS that you haven't put on\nyet.  You might have a need to examine this PTF without putting it on\nthe system at all.  And you'll first need to find out if you already\nhave it in the shop.  Granted, with the speed of electronic PTF ordering\nthat we have nowadays, this is not as important an endeavor as in\n\"former times\", when we had to wait for a PTF to arrive on a tape in the\nmail.  But still, it's nice to know that you already have a PTF on a\ntape which is in house, and you can look at it quickly, without any\nadditional fuss or special ordering from IBM.\n\n      What kind of processing do we have to do, to get this done?  We\ncan use the PUTXREF program from CBT File 118.  Since our space is\nsomewhat limited here, I have shown most of the functionality of PUTXREF\nin Figure 2.  The three outputs of PUTXREF are the PRINTER, SMPCOUT, and\nPDSATOUT DD names.  PRINTER is a SYSOUT file that should be copied into\nan FB-133 pds and searched later.  SMPCOUT and PDSATOUT can already be\nautomatically loaded into pds'es by the job itself, and of course, these\npds'es can also be searched later for the FMID number or the PTF number.\n\n\nSUMMARY\n\n      Rather than let your MVS tape library remain as a big pile of\ntapes in your tape closet, why not \"index\" the tapes and make their\ncontents searchable?  The free PDS program package from CBT File 182\nallows you to search multiple members of a pds for a string and report\non only those members which contain the search string.  So it makes\nsense to read all your tapes on a tape drive with an appropriate tape\nmapping program, and copy the reports to a pds, which can then be\nsearched afterwards for a program name, a PTF number, or an FMID.  This\nwill make the software you're looking for, findable in a jiffy, and\nyou'll know which tape it's on, and exactly which file also.\n\n      I trust that this information will be helpful to many of you.\nI'm looking forward to seeing you here again next month, and I wish all\nof you the best of everything.\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFigure 1.   JCL to run the TAPEMAP utility against\n            multiple tape volumes in one job.\n\n\n//SBGOLOBM JOB (ACCT#),'TAPEMAP UTILITY',\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X\n//*------------------------------------*//\n//*       TAPEMAP UTILITY PROGRAM      *//\n//*          CBT TAPE FILE 299         *//\n//*------------------------------------*//\n//TAPEMAP PROC VL=XXXXXX\n//TAPEMAP EXEC PGM=TAPEMAP\n//STEPLIB  DD DISP=SHR,DSN=your.loadlib\n//SYSUT1   DD DISP=OLD,\n// UNIT=CART,\n// VOL=(,RETAIN,SER=&VL),\n// LABEL=(,BLP,EXPDT=98000)\n//SYSPRINT DD SYSOUT=*\n//SYSPRNT2 DD SYSOUT=*\n//  PEND\n//*\n//S01 EXEC TAPEMAP,VL=EXS001\n//S02 EXEC TAPEMAP,VL=EXS002\n//S03 EXEC TAPEMAP,VL=EXS003\n//S04 EXEC TAPEMAP,VL=EXS004\n//S05 EXEC TAPEMAP,VL=EXS005\n//S06 ....\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFigure 2:   JCL and Sample Outputs from the PUTXREF\n            and SMPUPD programs - CBT File 118\n\n            PRINTER output of PUTXREF shows which SYSMODs\n            belong to which FMIDs.  These can later\n            be searched by PTF number using the PDS\n            command FIND subcommand.\n\n            PUTXREF SMPCOUT output can be fed into an SMP/E\n            APPLY SELECT job to achieve a FORFMID effect.\n\n            PUTXREF PDSATOUT output can be fed into the\n            PDS command package, to add ISPF stats\n            to your SMPPTS members showing their FMID.\n\n            SMPUPD SYSPRINT output shows the number of\n            records in each PTF, and how many internal\n            ./ cards each PTF has.\n\n\n//youruidF JOB (A006,SYTM,99,99),S-GOLOB,\n//        CLASS=B,MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//********************************************//\n//*    PUTXREF PROGRAM FROM CBT FILE 118     *//\n//********************************************//\n//*\n//S01XREF  EXEC PGM=PUTXREF,REGION=4096K\n//STEPLIB  DD  DISP=SHR,DSN=your.loadlib\n//INPUT    DD  DISP=SHR,DSN=youruid.OA06712.SERVICE  <-SMPPTFIN file\n//SORTIN   DD  DSN=&&SORT,DISP=(NEW,PASS),UNIT=SYSALLDA,\n//             DCB=(RECFM=FB,LRECL=15,BLKSIZE=4095),\n//             SPACE=(CYL,(150,40))\n//SORTOUT  DD  DSN=&&SORT,DISP=(SHR,PASS),VOL=REF=*.SORTIN\n//TITLES   DD  DISP=SHR,DSN=CBT.CBT471.FILE118.PDS(TITLES)\n//PRINTER  DD  SYSOUT=*\n//PDSATOUT DD DISP=SHR,DSN=youruid.PTFPDS(OA06712A)\n//SMPCOUT  DD DISP=SHR,DSN=youruid.PTFPDS2(OA06712)\n//SYSUDUMP DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=*\n//SYSOUT   DD  SYSOUT=*\n//SYSIN    DD  *\n SORT FIELDS=(9,7,CH,A,1,7,CH,A)\n/*\n\n   - - - - - - - - - - - - - - - - - - - - - - - - -\n\n Sample PRINTER output from PUTXREF  (FB-133 - squeezed to fit in here)\n\n                 SYSMOD BY FMID CROSS REFERENCE                 PAGE   1\nFMID    SYSMOD  SYSMOD  SYSMOD  SYSMOD  SYSMOD  SYSMOD  SYSMOD  SYSMOD\n******* ******* ******* ******* ******* ******* ******* ******* *******\nHBB7707   (title - if found - goes here)\n        UA03994 UA06335 UA06381 UA11443 UA12189 UA12204 UA12312 UA12688\n        UA15173 UA15759 UA16071 UA16226 UA16709 UA16718 UA17276 UA12786\n\n   - - - - - - - - - - - - - - - - - - - - - - - - -\n\n Sample SMPCOUT output from PUTXREF\n\n./  ADD  NAME=HBB7707\n      UA03994  /*  FMID - HBB7707 - FROM PUT TAPE - DONE 04/02/06    */\n      UA06335  /*  FMID - HBB7707 - FROM PUT TAPE - DONE 04/02/06    */\n      UA06381  /*  FMID - HBB7707 - FROM PUT TAPE - DONE 04/02/06    */\n      UA11443  /*  FMID - HBB7707 - FROM PUT TAPE - DONE 04/02/06    */\n      UA12189  /*  FMID - HBB7707 - FROM PUT TAPE - DONE 04/02/06    */\n      UA12204  /*  FMID - HBB7707 - FROM PUT TAPE - DONE 04/02/06    */\n      UA12312  /*  FMID - HBB7707 - FROM PUT TAPE - DONE 04/02/06    */\n      UA12688  /*  FMID - HBB7707 - FROM PUT TAPE - DONE 04/02/06    */\n\n   - - - - - - - - - - - - - - - - - - - - - - - - -\n\n Sample PDSATOUT output from PUTXREF\n\n   ATTRIB UA03994 ADDSTATS  ID(HBB7707)\n   ATTRIB UA06335 ADDSTATS  ID(HBB7707)\n   ATTRIB UA06381 ADDSTATS  ID(HBB7707)\n   ATTRIB UA11443 ADDSTATS  ID(HBB7707)\n   ATTRIB UA12189 ADDSTATS  ID(HBB7707)\n   ATTRIB UA12204 ADDSTATS  ID(HBB7707)\n   ATTRIB UA12312 ADDSTATS  ID(HBB7707)\n   ATTRIB UA12688 ADDSTATS  ID(HBB7707)\n\n   - - - - - - - - - - - - - - - - - - - - - - - - -\n\n Sample SMPUPD SYSPRINT output (squeezed from FB-133 size)\n\n   SMPUPD - ADD PDSLOAD (IEBUPDTE) CARDS TO AN SMPPTFIN FILE - READ ONLY ...\n\nPTF  UA10754 HAS    1,397 RECORDS WITH   0  INTERNAL ./ RECORDS CHANGED TO ><\nPTF  UA13586 HAS    1,445 RECORDS WITH   0  INTERNAL ./ RECORDS CHANGED TO ><\nPTF  UA11460 HAS    2,825 RECORDS WITH   0  INTERNAL ./ RECORDS CHANGED TO ><\nPTF  UA18918 HAS    4,610 RECORDS WITH   0  INTERNAL ./ RECORDS CHANGED TO ><\nPTF  UA18786 HAS  123,489 RECORDS WITH   0  INTERNAL ./ RECORDS CHANGED TO ><\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0608AU": {"ttr": 29697, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00$\\x01\\x06!/\\x01\\x06!/\\x14&\\x01\\x10\\x01\\x10\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-07-31T00:00:00", "modifydate": "2006-07-31T14:26:24", "lines": 272, "newlines": 272, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          AUGUST 2006\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.\n\n\nCBT TAPE PACKAGING\n\n      Every once in a while in this column, I like to present a summary\nof the recent CBT Tape contributions and updates, in the hope that I've\nmentioned something which will be of immediate use to you.  I'm very\ngrateful that people are constantly solving their own problems at work\nby writing tools for themselves, but I am far more grateful that they\nare sharing their tools with the whole world, by sending them into the\nCBT Tape collection to make all our lives easier.  Since I'm the\nproprietor of the collection, I'm in a good position to tell you about\nwhat has recently changed.  But today, I'd rather emphasize more about\nthe processes that go into creating and maintaining the collection, in\nthe hope that you'll make better use of its many software packages and\ntools.  The CBT Tape collection was founded by Arnold Casinghino in\n1975.  I have been its proprietor since 1990.\n\n      If you don't already know about it, the CBT MVS Utilities tapes\ncontain a free collection of MVS utilities, tools, suggestions, and\ngenerally helpful things for people working with MVS and supporting MVS.\nThe collection has a website, which you can find by doing a\nwww.google.com search for \"CBT Tape\", with the site appearing at or near\nthe top of the search.  You do not need a password to access the\nutilities, nor do you need to be a \"member of anything\" or of any\norganization.  The stuff is free for all, although it is only really\nuseful for MVS practitioners.  There are many \"really heavy-duty, tried\nand tested\" utilities and utility packages in this very large\ncollection.  Two \"tapes\" are supported:  the \"original\" CBT Tape, which\ngets updated every few months, and the \"CBT Overflow Tape\" which\ncontains other utilities, that either didn't fit on the \"regular\" tape,\nor older versions of the same utilities that are on the regular CBT\nTape.  The CBT Overflow Tape is updated whenever there is a necessary\nchange, but quite a bit less often than the \"regular\" CBT Tape.\n\n      On the website, which is supported by Sam Knutson, there is an\n\"Updates page\" that is supported by me.  All of the new contributions\nthat have arrived since the entire tape version was last cut, are posted\nto the Updates page of the CBT Tape website.  These may be changed, as\nthe authors fix things, but I generally like to make sure that a package\nwhich is posted to the Updates page, already works.  Therefore, you can\nusually consider a package or program from the Updates page safe to use,\nbut there might be some more bug fixes or improvements before the author\nis satisfied.  Of course, since the CBT Tape collection is a volunteer\nenterprise, no liabilities are assumed by anybody (see the posted\nDisclaimer on the website).  But practically speaking, that does not\ndiminish the usefulness of these tools for us in the MVS world.  We do\ntry our best to make sure that these tools are good, and work properly.\n\n      The CBT Tape collection is organized by \"files\".  These correspond\nto actual files on an actual tape.  The individual files can be uploaded\nto an MVS system, and each file usually converts, on MVS, to a pds, or\npartitioned dataset, although some of the older (tape) files convert to\na sequential file.  File 001 of each tape (i.e. the regular CBT Tape,\nand the CBT Overflow Tape) consists of an FB-80 sequential documentation\nfile.  And File 003 of each tape consists of JCL to unload all the files\nfrom the actual physical tape.  File 002 of each tape is source for an\nAssembler program that compresses or decompresses blanks from the tape\nfiles.  This program, for historical reasons, is named CBT973.\n\n      Data representation of the tape files differs, depending whether\nthe file is on a physical tape or a tape image, or whether it was\ndownloaded directly from the website.  But the result, no matter where\nyou originally got the CBT Tape file from, is the same.  It is usually a\npds on your MVS system, with the package or programs ready to install,\nand with documentation included.\n\n      Let me tell you about the data representation differences between\nthe website files and the actual tape files.  The \"website\" files are in\nzipped TSO XMIT format.  So when you download a website CBT file to your\nPC, you first unzip it, and then upload it in BINARY to your MVS system\nas a fixed blocked (FB), LRECL=80 sequential file.  After that, you then\nexecute a TSO RECEIVE INDS(yourfile.XMI) command against it, to\n(usually) produce a partitioned dataset on MVS.  On the other hand, the\nfiles from the tapes are mostly in CBT973 compressed format, except for\nthe first three files which are uncompressed, and the JCL from File 003\nin each tape, will supply proper instructions to create each file in its\nproper format (usually a pds) on your MVS system.  Again, no matter what\nthe origin of the file, whether it be from the website or from a real\ntape or tape image, the result should be the same, once the file was\nmoved to the MVS system.  And it usually is a pds.\n\n      What about \"CBT version numbers\"?  Each entire CBT Tape contains a\nversion number and a date.  These appear at the beginning of the tape\ndocumentation on File 001.  This tells you the general level of all the\nutilities from all the files on that tape.  For example, if you have\nFile 182 from CBT Tape Version 470, then you know which level of the PDS\nprogram package (which resides on File 182) you have.  More\nspecifically, to fine-tune the versioning, I have included a\n\"versioning\" member for most of the CBT Tape files, which I\nautomatically produce, that is pds member $$$#DATE.  See Figure 1 for\none example of this member.  This member is produced by a CLIST that I\nwrote, called GENDAT, which is on CBT File 006.  File 006 contains tools\nthat I myself use to generally maintain the tape, and you can use them\ntoo, if you want to.  (That's why I make them publicly available.)  As\nof this writing, the version number of the latest entire CBT Tape is\nVersion 471.  And I am currently accumulating the updates for Version\n472.  These are on the Updates page of the CBT Tape website.  The latest\n\"entire tape version\" of all the CBT Tape files is on the \"CBT\" page of\nthe CBT website.\n\n\nCBT FILE DOCUMENTATION\n\n      The CBT Tapes were originally \"purely MVS\" entities, and they were\nproduced to be exclusively installable and usable on MVS systems.\nHowever, the world has now changed, and people write their documentation\nin Microsoft WORD and in Adobe PDF formats.  Text representations of the\ndoc in EBCDIC are getting much rarer nowadays, and so I have to handle\nthat situation when I prepare a CBT Tape file for distribution.\n\n      As far as I know, the MVS system doesn't have a tool that runs\nunder it, which will read either WORD or PDF documentation formats\ndirectly.  So what I do is to upload a byte-for-byte FB-80\nrepresentation of the WORD or PDF data to MVS, and insert it in to the\nCBT Tape file as a separate member.  In order for the user of the file\nto read this documentation, that pds member has to be downloaded in\nBINARY to a PC, and either WORD or an ADOBE reader (depending on the\nformat) has to be opened against the PC version of that file.  The file\n(of course) cannot be read directly on the MVS system, and I do not like\nthis idea, but this is the reality of our current world and I have had\nto adapt to it.\n\n      I used to spend many hours converting the WORD format doc files\ninto FB-80 text representations, to conform with the way the file doc\nused to be distributed in former years.  This was because there still\nwere some MVS sites that ran without PC support, and I felt that those\nplaces wouldn't be able to fully benefit from the packages if they could\nnot read the documentation that came along.  But nowadays, I generally\nleave any WORD or PDF doc as is, because the readership generally has\naccess to PC software, and someone who is running in a \"purely MVS\"\nenvironment with only directly attached \"green screens\" is a very rare\nbird, indeed.\n\n\nCBT FILE PACKAGING\n\n      When somebody submits their materials for inclusion into the CBT\nTape collection, I generally have to do a considerable amount of work.\nMy work consists of making sure that the package is \"installable\" and\nthat it works.  I don't have time to actually test all of the packages\nwhich are submitted, especially if they are for an MVS add-on like CA-1,\nwhich I don't run at my own installation.  My general policy then is:  I\nmust make sure that the package can be easily installed by a reasonably\ntrained MVS systems programmer.  Once the package is out there, I assume\nthat it will be tested by anyone who needs it, and that they will report\nbugs or design defects (if any) back to me so they can be corrected, and\nthe package will then be further improved and fixed.\n\n      There is a general situation which I have to address when I'm\npackaging the submitted materials.  The CBT MVS tapes are designed to\nrun, and be used, on MVS systems.  Many people nowadays, with hybrid\ncomputing environments as they are, do not actually write their\nsoftware, even if it is to be used on MVS, on MVS systems.  And so the\ndata representation of the submitted materials might be ASCII, with\ncarriage return and line feed characters appended, and the lines of the\nsource code might be longer than 80 characters.  Other differences may\nbe present in the submitted materials, which could make them quite\nincompatible with the traditional MVS data formats.  So what do I do?\nThe answer is that I still try to MVS-ize the submitted materials as\nmuch as possible, without compromising the integrity of the installation\nprocess.  My attitude is that I will try to put the materials, or fold\nthem, into FB-80 format somehow.  If that can be done, then I'm\nreasonably happy.  And the folding and/or data conversion processes must\nbe easily and accurately reversible, too.\n\n      Several repackaging tools are available for this purpose, which\nare either present on MVS systems already, or which are installable for\nfree on MVS.  The first is the TSO TRANSMIT (XMIT for short) command,\nand the second is IEBUPDTE, and its user-written counterparts, OFFLOAD\nand PDSLOAD.  The TSO XMIT command will take VB or FB data of almost any\nformat, and convert it into FB-80 immediately, using its optional\nOUTDSN( ) keyword parameter.  The effect of this XMIT repackaging is\nreversed by the TSO RECEIVE command, with its INDS( ) keyword parameter.\nA drawback to the use of the XMIT command for packaging CBT files, is\nthat it requires the presence of TSO/E on the MVS system.  Pre-TSO/E MVS\nsystems do not contain the XMIT (or RECEIVE) TSO commands, so a pds\nmember which is in XMIT format, cannot be easily interpreted on those\nsystems without an auxiliary tool.  This situation might occur nowadays\nif someone is running MVS 3.8 under the Hercules emulator on a PC.  For\nthose people who need a tool for the PC to interpret XMIT-format files\nthat have been downloaded to the PC, there is a tool called XMIT-manager\nthat (I believe) is (still) available at the CBT website.\n\n      One of the principal purposes of using the XMIT TSO command to\nreformat data, is to convert pds'es into FB-80 sequential files, so they\ncan be loaded into an FB-80 format pds for inclusion in a CBT Tape file.\nIf the data is already in FB-80 format, but it is a pds, the pds can be\n\"sequentialized\" using the MVS IEBUPDTE program.  The idea of IEBUPDTE\n(as we use it) is to load each member of the pds into a sequential file,\nbut with a separator line consisting of an ./ ADD NAME=memname card that\nis in between each member.  IEBUPDTE can be used to both create the\nsequential file from the pds, and to reload the pds from the data in the\nsequential file.  The OFFLOAD and PDSLOAD program combination from CBT\nTape File 093, can do this also.  But OFFLOAD and PDSLOAD has two more\nadvantages over IEBUPDTE.  First, OFFLOAD (to create the sequential file\nfrom the pds) and PDSLOAD (to reload the pds from the sequential file)\nwill preserve ISPF statistics of the members, if they are present.\nSecond, OFFLOAD and PDSLOAD are not restricted to LRECL=80 data, as\nIEBUPDTE is.  Please see CBT Tape File 093 for another set of tools,\ncalled UPDTE and UNUPDTE, which do something similar to OFFLOAD and\nPDSLOAD.\n\n      A good reason for representing an unloaded pds in IEBUPDTE format\non a CBT Tape file, as opposed to XMIT format, is that the data is\nbasically unchanged, but the data from the separate pds members has just\nbeen strung together, one member after another.  An advantage is that\nthis data can still be read directly (especially on pre-TSO/E systems)\nand it does not need an intermediate program (TSO RECEIVE) to make it\nreadable and usable.\n\n      So, using a combination of IEBUPDTE format and XMIT format pds\nmembers, I have been able to re-package non-MVS data on MVS systems in a\nreproducible and reversible manner.  Therefore, I can package a product\non MVS, which was not designed to fully run on MVS.  Even a zipped file\ncan be directly uploaded to MVS as FB-80 and folded over.  So using\n\"modern methods\", there is still really a lot of flexibility in creating\n\"mixed\" packages for distribution on an MVS system.\n\n\nSUMMARY\n\n      My hope this month has been to give you some more insight into how\nMVS software packaging can be used to contain some non-MVS software\ndata.  Also, I hope that you'll gain some appreciation into the process\nof making people's software products that were submitted to the CBT\nTape, distributable and installable in a standard manner.  For those of\nyou who aren't so familiar with these processes, I'd bet that after\nreading this article, it'll be much easier to install programs and\npackages from the CBT Tape collection.  Best of everything to all of\nyou, and I hope to see you here again next month.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   A CBT File Versioning Member, $$$#DATE.\n\n            This is a sample versioning member for a CBT\n            Tape file (File 743), which shows when the\n            file was last updated, and how many records\n            it contains.  Thus, you can trace exactly\n            which version of the file that you have.  The\n            CLIST called GENDAT from File 006 produced\n            this member.\n\n\nREGULAR CBT TAPE - VERSION 472    FILE:  743\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT472.FILE743\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 17 MEMBERS COUNTED; CUMULATIVE SIZE IS 4,511 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   07/05/06    09:02:55    GMT-4:00\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0609SE": {"ttr": 29702, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x12\\x01\\x06\"o\\x01\\x06\"o\\x08V\\x01\\x08\\x01\\x08\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-08-14T00:00:00", "modifydate": "2006-08-14T08:56:12", "lines": 264, "newlines": 264, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                        SEPTEMBER 2006\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.\n\n\nFIND AND REPLACE IN PLACE\n\n      A large part of our job concerns the manipulation of files.  Some\nof the work involves the moving of files from one place to another.  But\nanother piece of what we do, is to make sure that the contents of system\nfiles, libraries, and even directories (pds directories, VTOCs, and so\nforth) are (either) what they should be, or what you want them to be.\nToday, we shall talk about the process of looking for character strings\nin one or multiple files, and if need be, changing them to some other\nstring.  This process is often not as simple as just editing the file,\nand as we shall see, there's sometimes quite a bit more to it.\n\n      Usually, if we want to change a character string in a file,\nediting the file is enough.  When you edit a pds member and save the\nedit, you create a new copy of the member (in the free space at the end\nof the pds member data) and you re-point the pds directory entry for\nthat member, to the TTR at the beginning of the new copy.  This leaves\nthe data of the old copy intact, but not pointed to, until the next\n\"compress operation\" on the pds.  And a by-product of this editing\noperation is that extra disk space is used up in the pds.\n\n      On the other hand, if a purely physical sequential file is being\nedited (i.e. NOT a pds member), and the changes are saved, then it may\ndepend on how the specific editor works, but the usual result is that\nthe new copy of the file is written over all of the disk space where the\nold file existed before.  Again, as with the case of merely editing pds\nmembers, this may not present any real problem to us, because we don't\ncare exactly where each data block of the file resides on the disk.  But\nsometimes we do care, and it just may be, in a case of a specific\nfind-replace, that we want to only replace the minimum of the file data\n(usually an individual data block) that it is possible to replace.  So\nwe need to have tools to do this.\n\n      For example, if we need to zap a VTOC entry on a disk pack, it is\nvery critical that the new data reside in the same place where the old\ndata was.  The CCHHR of the beginning of the VTOC is pointed to by the\nvolume label of the disk pack, and the VTOC cannot be moved\nnoninvasively, under ordinary circumstances, except through the use of\nspecialized tools.  So any tool which is used to merely change a VTOC\nentry, must only replace the minimum amount of data, and it should be\ncapable of doing a \"replace in place\" of any data block in the file.\n\n\nTOOLS THAT CAN DO \"REPLACE IN PLACE\"\n\n      For the purposes of this column when it comes to tools, I prefer\nto discuss either tools that are shipped for no extra cost with the MVS\noperating system, or if the tools are indeed \"add-on\" to MVS, they\nshould be obtainable for free.  Although sometimes vendor tools (which\ncan cost a lot of money) will do the same job as well, they are not in\neverybody's MVS shop, and if I write about them, most of the people will\nsay that \"this procedure or technique is not for me.\"  So I certainly\nwant to avoid such a scene.  That's why I mention free tools all the\ntime.  Free tools can be obtained and profitably used by anyone who\nreads this column and who has access to an MVS machine.\n\n      The principal tools I'll discuss today are free \"add-on\" tools\nwhich are obtainable from the CBT Tape website.  You don't need a\npassword to get any of these tools from the CBT website.  Just do a\nwww.google.com search for \"CBT Tape\" and the website should come out\nnear the top of the search.  The two main tools I want to talk about,\nare \"Fullscreen ZAP\" (source on CBT File 134, load module on File 135)\nand the PDS 8.6 program package (source, panels and message members on\nCBT File 182, load module (if you don't assemble it yourself) on File\n035).  As we discussed last month, sometimes you can get the latest\nversion of CBT Tape programs by going to the Updates page of the CBT\nwebsite, as opposed to the CBT page.  As of this writing, the latest\nversion of the PDS 8.6 package is on File 182 of the Updates page.\n\n\nFULLSCREEN ZAP\n\n      Fullscreen ZAP is TSO command which is a replacement for IBM's\nAMASPZAP program, but it has the enormous advantage of showing you the\ndata on screen, both before and after a string replacement has been\nmade.  You get to see 256 bytes of the data at a time, and in addition,\nFullscreen ZAP shows you much of the detail about where the data is, and\nwhat kind to physical blocking it has, right at the bottom of the\nscreen.  Fullscreen ZAP only does a \"replacement in place\" of the\ncurrent block of data, so it is quite uninvasive to the file being\nmanipulated.\n\n      For ordinary data replacement to a file, Fullscreen ZAP doesn't\neven have to be APF authorized.  But if you want to use Fullscreen ZAP's\nenormously powerful FULLVOL option, which zaps the DEB of the data file\nto change its extents to those of the entire pack, then the ZAP command\nhas to be APF authorized, as a TSO command, and its name has to be\nentered in the effective IKJEFTE2 table for that MVS system.  (Edit the\nAUTHCMD NAMES entries of the IKJTSOxx member of PARMLIB to include the\nname ZAP, do a PARMLIB UPDATE(xx) TSO command, or a SET IKJTSO=xx\noperator command.  More advanced techniques for APF authorizing a TSO\ncommand have been mentioned from time to time in this column.)  Of\ncourse the ZAP load module has to be link-edited with SETCODE AC(1).  If\nyou forgot to do that, the PDS 8.6 program (to be mentioned later) is\ncapable of setting the AUTH bit on in ZAP's load module directory entry,\nby pointing the PDS command to the load library, and using the ATTRIB\nZAP AUTH subcommand on the ZAP load module.\n\n      Fullscreen ZAP does not need ISPF.  It works under raw TSO.  And\nFullscreen ZAP has it's own online help.  Once you enter the ZAP command\nagainst a dataset (with the optional VOL() operand if the dataset is not\ncataloged), then entering the word HELP, or a question mark (?) in the\nupper left hand corner command area will give you 13 help screens that\nscroll forward each time you press ENTER.  To get back to where you were\nworking before, just enter U in the command area of the help screen.  To\nZAP a VTOC for a particular volume, use the VOL() parameter, and make\nthe dataset name 'FORMAT4.DSCB'.\n\n      Finding data with Fullscreen ZAP can be done either in HEX or in\nEBCDIC.  To use ZAP's FIND command (F) for hex data, just enter the hex\ndata after the subcommand F with no spaces in between.  To find EBCDIC\ndata, just enclose the data in between slashes or question marks.\nAgain, don't put a space between the F and the data.  Try it.  You'll\nlike it.  If you're not using ZAP in FULLVOL mode, the F subcommand will\nstop it's action when you've reached the end of all the dataset's\nextents, if you haven't found the string.  If you are using the FULLVOL\noption, it is obvious that ZAP will find all occurrences of the string\non the DASD, in CCHHR order from the start of the search, and it will\neven find the string in deleted data areas.  So you see that you can\nsearch deleted data on DASD using Fullscreen ZAP by using the FULLVOL\noption.\n\n      Replacing EBCDIC data with ZAP unfortunately requires a knowledge\nof EBCDIC character representation, because ZAP will only accept\nreplacement data (using its S subcommand) if you enter (up to 8 bytes\nof) hex data immediately after the S in the command area.  You can also\nOR and AND existing data using other ZAP subcommands, but the data entry\nis always in hex.  So ZAP requires (at least) some skill with hex\nnumbers to be used effectively, when data is to be replaced in a block.\n\n      From my own experience, you get the most joy and effectiveness\nfrom the ZAP command by playing with it, and trying the different\nsubcommands that are mentioned in the built-in HELP.  Then, once you've\nseen the possibilities, you'll almost never go back to AMASPZAP, unless\nyou need to set up a batch job.  In fact, when setting up such a batch\njob with AMASPZAP, you can explore the relevant disk area using\nFullscreen ZAP first, to actually see the data and verify that it is\nwhat it is supposed to be.  For zapping disk data, Fullscreen ZAP is\nalways my first choice.  IBM's AMASPZAP is a very distant second choice,\nand I only use AMASPZAP when I absolutely have to.\n\n\nFIND AND REPLACE WITH THE PDS COMMAND\n\n      The free PDS TSO command (which can either be run under Raw TSO\nusing the XISPMODE option, or under ISPF), is a multipurpose tool that\ncontains something like 1000 separate functions which are grouped under\nperhaps 60 subcommands.  But the reason why we are mentioning it here,\nthis month, is because its default FIND-REPLACE mechanism uses the\n\"replace in place\" technique.  And you can use the PDS command to do\nmultiple (read \"up to hundreds\" or \"thousands\") of find-replace\noperations at one time.  Clearly, when you know how to use the PDS\ncommand in this way, it is an enormous time saver.  Of course, you have\nto be careful and accurate too, and not replace a string that shouldn't\nbe replaced.  I assume that an MVS sysprog with reasonable skills is\nappropriately safety minded concerning his or her employer's data.\n\n      Unlike the Fullscreen ZAP command, the PDS command (even though it\nis also a TSO command) can also be made to run under TSO-in-batch.  So\nyou can set up batch jobs to use the PDS command and accomplish what you\nwant to do.  And under ordinary circumstance, the PDS command is designed\nNOT to run APF-authorized.  So that is another advantage which PDS has.\n\n      When using the PDS command to FIND character strings and\nsubsequently REPLACE them, you can do a dry run of the REPLACE command,\nwhich will not make any actual changes.  Then, when you've carefully\nlooked at the results of the dry run, and adjusted it appropriately so\nit is exactly right and it does exactly what you want, you can then\nexecute the same REPLACE command with the WRITE option, and make the\nchanges in-place and final.\n\n      The syntax of the FIND subcommand and REPLACE subcommand in PDS\nare quite simple.  For FIND, you have a space after the command, and you\nenclose the desired (EBCDIC) string between a delimiter character such as\na slash or a question mark.  So to find all occurrences of the string\nABCDEFG in all the members of an entire pds, you would point the PDS\ncommand to the partitioned dataset by saying:\n\nPDS my.dataset\n\nand then you'd run the subcommand:\n\nFIND : /ABCDEFG/    (where the colon (:) stands for \"all members')\n\nwhich would produce a report in the PDS log, showing all occurrences\nof the EBCDIC string ABCDEFG in the entire pds.  To do a replacement of\nABCDEFG with HIJKLMN, you'd use the PDS REPLACE subcommand as follows:\n\nREPLACE : /ABCDEFG/HIJKLMN/\n\nIf the \"find\" or \"replacement\" string of data contains lower case\ncharacters, use the ASIS option of FIND or REPLACE to avoid\nupper-casing.  To FIND or REPLACE hex data, enclose the hex data\nbetween the character x, as a delimiter.  In other words,\n\nFIND : xFFx\n\nwhich will find all occurrences of X'FF' in all members of the pds.\n\n      All the REPLACE operations of the PDS command use the\n\"replace-in-place\" technique, and no additional free space is used up.\nIf the replacement string is longer then the \"find\" string, overflow\nconditions are shown in the PDS log report which contains the results of\nthe command.  So it is always best to do a \"dry run\" and not use the\nWRITE option until you are absolutely ready to make all the changes\nfinal.\n\n      I don't have too much space left here, but I must mention that the\nPDS command allows selection of \"member subgroups\" which are referred to\nby entering an asterisk (*) in the place where you put in the member\nname in any PDS subcommand.  The FIND subcommand of PDS has THEN and\nELSE operands, which can be used as follows:\n\nFIND : /ABCDEFG/ THEN(SUBLIST)\n\nThis will allow you to pick a subset of all partitioned dataset members\nwhich contain the string ABCDEFG and ONLY those members.  So you can\nselect a subgroup of only those members containing the given string, and\nconveniently refer to that subgroup using the character \"*\".  Thus, after\nthe above FIND command, you can later enter:\n\nREPLACE * /ABCDEFG/HIJKLMN/\n\nand know, positively, that you have affected only the members which\nactually contain the string, and not any other members of the\npartitioned dataset.\n\n      As you can see, if you explore the HELP member of the PDS command,\nthat the possibilities are almost endless, and once you have the\nexperience, you can do a lot of FIND and REPLACE work in very little\nelapsed time.  If you look in the PDS HELP at the DATA subcommand of the\nLIST subcommand, you will see even more power, that you've never even\ndreamed of.  I say again:  Try it.  You'll like it.  But, BE VERY\nCAREFUL.....\n\n\nSUMMARY\n\n      Today, we've explored some possibilites concerning finding\ncharacter strings in data, and replacing them in place.  These\ntechniques use free and powerful MVS tools which run under TSO.  So\neverybody with an MVS system can run them.  However, to properly use\nthese tools requires quite a bit of practice and experience.  But if\nyou've put in the time, you'll reap the rewards, and you'll thank me\nmany times over.\n\n      I wish you a lot of luck and success in all your endeavors, and\nI'm looking forward to seeing you here again next month.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0610OC": {"ttr": 29707, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00F\\x01\\x06$\\x7f\\x01\\x06%O!B\\x00\\xe5\\x00\\xe5\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2006-09-04T00:00:00", "modifydate": "2006-09-11T21:42:46", "lines": 229, "newlines": 229, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         OCTOBER 2006\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.\n\n\nMVS KNOWLEDGE\n\n      Sometimes I ask myself:  \"Just what have I learned in my 25-odd\nyears in this field?\"  And when I really think about it, the answer is\ncomplicated.  That's what I want to talk about today.  With so many of\nus so-called \"old timers\" approaching retirement age, and with the IBM\nmainframe still extremely vital in today's industry, we have to ask the\nquestion about how we're going to groom new people to take care of the\nsystems.  So it makes sense for each of us to ask questions about \"what\nwe really know.\"\n\n      Every person has a different head.  So it makes a lot of sense\nthat each of us has followed a different path in acquiring the MVS\nknowledge and practical know-how.  I for one, went to a \"computer\nprogramming school\" and I also acquired some programming knowledge on my\nown.  Later, I \"grew into\" a systems programming job, on the job, after\nhaving been a COBOL and ASSEMBLER programmer for a couple of years.\nMany other MVS sysprogs started as computer operators, and grew into\nsystems programming after displaying a curiosity to understand what was\ninside the system they were operating.  What were the guts of the system\nlike?  And maybe they also had ambition to make more money too, at a\nmore skilled job level which was less boring than just operating the\nmachine.  Sysprogging is certainly a giant step up from computer\noperating, and it's a good opportunity for a bright person.  Other\npeople followed different paths--some were engineers before.  So each\nperson's mental makeup and background forms the patterns he or she will\nuse, to angle for the knowledge necessary to build and maintain an MVS\nsystem.\n\n      With all these differences, where is the common ground?  Actually,\nI might want to answer this by saying that the knowledge itself is the\nequalizer.  There's a certain core of knowledge and skill that everybody\nhas to have.  You have to know quite a bit about TSO and ISPF.  You have\nto know at least something, about how SMP/E works.  You have to know\nabout datasets on MVS, and all the different data types, and about data\nmanagement.  You have to know about how programs work, and about how\nprograms use system services.  Nowadays, you also have to know about\nUNIX, and how to mount file systems and how to set up UNIX under MVS.\nAnd you have to know about the general processes of \"moving datasets\naround\" in order to be able to install software.\n\n      Then also, you have to know about load parms, and PARMLIB, and\nabout how the system starts up.  And you have to be able to set all of\nthat up, with a knowledge of which PARMLIB members need to be adjusted\nto give the system the proper tools to do what the installation needs\nit to do.\n\n      After all this, you need a general knowledge of each system\ncomponent, how it works, and how it interacts with the other system\ncomponents.  But that's not enough.  You also need to know how to set\nall the components up, individually.  So you need to know all the\ndatasets they need, how to configure them, allocate them, and resize\nthem.  A basic knowledge of how system dataset placement affects system\nperformance is also a must.  You don't want to put a dataset that\nconstantly gets RESERVEs on it, together with frequently used system\ndatasets, together on the same disk pack.  I mean c'mon, that's a \"no\nno\".  And you've got to be aware of such issues.\n\n      Experience is the best teacher, and acquiring experience takes\ntime.  Also, you often have to have an \"issue\" before the opportunity to\nacquire the experience presents itself.  Suppose your installation is\nhaving a certain performance problem and you've been assigned to curing\nthe problem.  You have to find out why the problem occurs, which MVS\ncomponents are affected, and in the process of doing that, you'll learn\na bunch of \"do's and don'ts\".  Those \"do's and don'ts\" then become an\nessential part of what you have to know.  Each person builds up a\ncollection of these cumulative experiences, and getting that knowledge\ntakes you to the next level.  You depend on your everyday tasks to\nenable you to deal with whatever may come up later.\n\n      IBM itself has recognized that it needs to address the \"training\nissue\" for MVS sysprogs.  When I broke into the field, the IBM manuals\nwere a hodge-podge.  There were maybe a hundred MVS books, and in order\nto find out something practical, you often had to look in four or five\nseparate books and put the bits of knowledge together yourself, to be\nable to address even a relatively simple problem.  Now, the books have\nbeen reorganized to put \"practical information about a topic\" together\nin one place, and IBM has also come out with its excellent multi-volume\nRedbooks, \"ABCs of System Programming.\"  The advent of the Redbooks in\ngeneral, has allowed us to concentrate on learning one topic at a time\nin a practical way, and they have made our lives much easier.\n\n      Then there's the big question of tools.  When I started, I had to\nlearn about all the basic IBM utilities and tools for MVS.  After that,\nI found out that many IBM-supplied tools left much to desired, with\ntheir lack of user-friendliness and lack of scope.  So I had to find\nout about, or write, many system-level tools myself.  This involved much\nresearch and Assembler language programming, and it got me involved with\nthe magnificent free collection of MVS tools known as the CBT Tape, from\nArnold Casinghino at the (now defunct) Connecticut Bank and Trust\nCompany.  You almost can't be a systems programmer without knowing about\nthe CBT Tape collection, where you can get everything for free.  The CBT\nTape collection is now online.  Just do a www.google.com search for \"CBT\nTape\", and the website for the collection should come out near the top.\n\n      But this is just the beginning, and when I ask myself what I have\nbeen doing for 25-odd years, I have to answer that I have constantly\nbeen adding to my knowledge of the system, and to my knowledge of the\nnecessary tools to handle problems and get information about each\ncomponent of MVS.  It's really very involved.  I guess I've learned a\nlot.\n\n\nINDIVIDUAL APPROACHES\n\n      As I said before, each person has his or her own head.  So the\nspecial individual mental qualities which each person has, will\ncontribute to his or her approach in learning this field.  The bottom\nline in MVS systems programming, is to know as much as possible about\nhow the operating system works.  Each component is deployed at system\nstart-up, and each gets its own control block information initialized,\nand each component is designed to interact in necessary ways, with some\nor all of the other components.  You've got to find out about this, and\nyou also have to find out how to fix it, if it's broken.\n\n      My own teacher, Bill Mosteller, who wrote a book called \"Systems\nProgrammer's Problem Solver\" has an introduction in the book from Gerald\nWeinberg, who likens sysprogging to being a soccer goalie.  Most of the\ntime, the action on a soccer field is not near the goalie, but he must\nalways keep a vigilant eye on all the proceedings, and when the action\ngets near him, he must do everything he can to anticipate any problems\nand avoid them at all costs.  Most people who watch a soccer game don't\nspend too much time looking at the goalie, unless he (or she) makes a\ngood save, or gets the ball into a good starting position for his team.\nNevertheless, no one would argue against the fact that the goalie's\nposition is perhaps the most important position on the team, and without\nthe goalie doing his or her job, the team wouldn't have much of a\nresult.  Same with the systems programmer, who installs the system and\nwho must always be vigilant to prevent and fix problems.  The systems\nprogrammer is also the last line of defense.\n\n      So as an individual, what do I myself do to learn about the\nsystem?  For myself, I am a big believer in exposure.  I find that my\nhead picks up what it sees.  So I'll take a glance through the member\nlists in SYS1.LINKLIB, SYS1.CMDLIB, SYS1.MACLIB, SYS1.MODGEN, and the\nlike, getting exposed to what the member names look like.  I won't spend\ntons of time doing this, but at least I'm getting familiar with what\nnames the programs and macros have.  Most people don't find it practical\nto do that, but I do.  When a system problem will occur that affects\nsome component, I'll already have a bit of familiarity with some of the\nindividual pieces which make up that component.  I find that this will\nhelp me solve problems more quickly.  It works for me.\n\n      Somebody else I know, only reads manuals.  Give him a manual, and\nhe's a happy camper.  When I worked with him, I tried to talk to him\nabout my own techniques for learning about the system, and it was like\ntalking to a wall.  His head just didn't work that way.  But he was a\nvery effective and successful systems programmer nevertheless.  He\nfollowed the directions in the manuals, and he was able to learn\neverything he needed to know, to do his job.  He just didn't come up\nwith the really creative and innovative and \"off the wall\" things that I\ntended to come up with.  The shop needed both of us.  And similarly,\nyour shop needs you.\n\n      If you have experience in this field, you already know something\nabout how you approach things and how you try and learn new things, when\nyou have to.  Most people who are experienced, have a pretty good handle\non their techniques.  But I would say that maybe you should try and\nlearn a few things once in a while, that you DON'T HAVE TO.  You should\nstretch your mind a bit--go into the unknown.  Look up something that's\nin some random area which you don't know about yet.  Especially if you\nhave a bit of free time.\n\n      This is the kind of innovative activity which separates the\n\"creative ones\" from the ordinary people who do their job well.  I think\nthat you should spend some of your \"free\" working time \"doing your own\ncreative thing,\" as long as it doesn't interfere with your regular work.\nDone right, using your own individual head will add immensely to your\neffectiveness in the shop, and it will be a source of much benefit and\nsatisfaction, but you've got to be careful to do it intelligently and\nnot counter-productively.  Don't work on something optional, when you\nhave to be busy with some assigned task.  Remember that you also learn\ntons, and get most of your good experience, while you're doing your\nassigned tasks.  The optional stuff is only something you do, when \"the\naction isn't on your side of the soccer field.\"  And it's only a\nsuggestion, not an obligation.  If you stick to your obligations, you'll\nalways be safer.\n\n\nTHE BOTTOM LINE\n\n      I think that the bottom line in all this, is to always try and add\nto your knowledge, and don't ever mind repeating some of your tasks\nwhich are routine.  Repeating a task drives the techniques into your\nhead.  It is a rare piece of wisdom to know, that repetition of a task\n(in our field) is goodness, most of the time.  Repetition makes a task\nsecond nature, and much of our effectiveness in deploying our knowledge,\nis that most of our actions have become second nature to us.\n\n      Nevertheless, in some sense, a good sysprog should also let the\ncomputer make him or her lazy.  If you use good tools and shorten the\nwork, then the work gets done faster.  It makes sense.  So there's a\nbalance between accustoming your head and your fingers to be able to\nwork quickly, but you also shouldn't take the slow road if there's a\nfast road available.  Again, the bottom line comes down to using your\nhead and always acting intelligently.  It's just like driving a car.\nWhen you're driving, you always have to be alert, make good decisions,\nand act responsibly.  Same with sysprogging.  That's how you'll be\neffective at this job.\n\n      In a short space, I've had to try and summarize what goes into the\nmaking of an effective MVS system programmer.  It does take a lot of\nexperience in doing tasks and learning about the system.  You have to\ntake as much advantage as possible of your own talents.  An \"I can do\nwhatever it takes\" attitude is one of the most important things I've\ncome across, too.  But mostly, it's a willingness to keep learning about\nthe system and about tools.  It's a desire and a curiosity to learn\nabout how the system works.  And you have to mix in common sense, to\nprotect your employer's environment.  When I think about it, I suppose\nI've come a pretty long way in 25 years.\n\n      So I wish all of you heaps of good luck and success in all ways.\nAnd I hope very much, that you'll come and visit here again, next month.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0611NV": {"ttr": 29957, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x000\\x01\\x06'/\\x01\\x06'\\x7f\\x10\\x12\\x00\\xf1\\x00\\xf1\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2006-09-29T00:00:00", "modifydate": "2006-10-04T10:12:30", "lines": 241, "newlines": 241, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         NOVEMBER 2006\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.\n\n\nSYSTEM RECOVERY TOOLS - PART 1\n\n      I am forever amazed by the delicacy of an MVS system.  By that I\nmean that very significant parts of the system can be very significantly\ndisturbed if one byte, or even one bit, in a crucial place, is wrong.\nToday, we are going to talk about what we can do to accumulate defenses\nand cures, in the event of something happening.  I hope to approach this\ntopic in a somewhat systematic manner, and I think that fairly complete\ncoverage will have to span several installments of this column.\n\n      Everyone in this business knows, that an MVS system can only be\nrecovered (usually) by having another MVS system available (or at least\nhaving a VM system that can get to the MVS system's disk packs).  So\nprudence dictates that you have every one of your disk packs accessible\nby at least two (or preferably more) IPL-able res packs.  Otherwise, if\nsomething (damaging) happens to one of the res packs, you'll have\nanother MVS system available to fix it with.  That said, I'll give a\nstarting example to get us \"into\" this fascinating subject of how to\nrecover.  Here we go.\n\n      Something that sounds (to an outsider) as insignificant as a\nvolser name being wrong, can of course have enormous consequences for an\nMVS system.  Datasets are cataloged to a volser name.  So if, for\nexample, a volser name gets accidentally changed, then all the datasets\nwhich are cataloged to that volume, can not be reached afterwards by\nmeans of the catalog.  That means that if many important system datasets\nare cataloged to a volume whose volser had been changed, an IPL of that\nsystem will be impaired or will be crippled, and recovery of the system,\ndepending on what was on the volume, can be tedious and difficult.  I'll\nmention one example that happened to me.\n\n      I was restoring a system volume (not the res volume) from an FDR\nbackup, and I forgot to change COPYVOLID=YES to COPYVOLID=NO in the JCL,\nin spite of the fact that the volser name in the backup was indeed\ndifferent than the name of the volume I was restoring.  My mistake.\nWhen the restore was complete, and I saw the highlighted FDR message on\nthe console that the VOLID of the volume had been changed, I knew I was\nin big trouble.  This happened to be an isolated MVS system, and it\nwould be difficult to restart it from the outside, without a drastic\nmeasure, such as a standalone restore of the res packs.\n\n      On that occasion, fortunately, the system was still up, and I\nsurely didn't want to disturb it more, by bringing it down and damaging\nit further.  But I was not logged onto TSO on that system.  When I tried\nto logon, of course the allocations of the datasets were greatly\nimpaired, since many datasets, essential for the LOGON, were cataloged\nto the pack whose volser had been changed.  But I was very fortunate\nthat my TSO LOGON PROC did not contain many datasets in it.  Most of\nthem were allocated by the logon CLIST, which is a much safer practice.\nAt least I had a TSO session to fix things with.  But I was still in a\nlot of trouble.  What was I to do?  Only two bytes had been changed,\nthose being in the volser name that was in the volume ID record of the\ndisk pack.  But that caused A LOT of consternation, and if I wasn't\ncareful now, the troubles would multiply.\n\n      One main rule in MVS recovery situations is to ask three\nquestions:   First, \"What do I still have available which did not get\ndamaged?\"  Second, \"What needs to be fixed in order to recover?\"  And\nthird,  \"What tools and materials do I have available to fix what needs\nto be fixed?\"\n\n      Getting back to our situation, I (fortunately) had a TSO session\navailable in READY mode.  That was still there, but ISPF was not\nreachable.  The answer to the second question was, that the volser of\nthe important DATA01 volume, which contained the RACF database, my\nimportant toolkit load library, which had to be APF authorized, and many\nother system-related datasets, essential to my session and to MVS in\ngeneral, had to be readjusted to its original value.  The answer to the\nthird question, was that I could easily clip the pack (i.e. change its\nvolser) with my TSO Fullscreen ZAP tool that could run in READY mode,\nbut the ZAP program had to be APF authorized, and the authorizing\nmechanisms resided on the volume whose id got changed.\n\n      You might have done something different in my situation, such as\nto run a previously prepared ICKDSF \"pack clipping\" proc as a started\ntask.  In my particular case, I didn't have one of those all ready.  But\nI did have my toolkit load library as a (now uncataloged and\nunauthorized) load library on the pack whose volser got changed.  IBM\nthen saved my tail with one of its new TSO goodies called TSOLIB.  I\ncouldn't get to my toolkit load library from the allocations in my\nbarebones TSO LOGON PROC that I needed to logon.  So I looked up the\nHELP for the TSOLIB command, and I allocated a ddname of XXX to my\ntoolkit library, using the VOL( ) keyword of the ALLOC command, pointing\nto the changed volser name.  Then I issued TSOLIB ACTIVATE DDNAME(XXX)\nand I was able to get to my tools in non-APF mode, at least.\n\n      I then used the new dataset editing capabilities of the REVIEW TSO\ncommand from Greg Price (CBT Tape File 134).  REVIEW can run in TSO\nREADY mode and using its new UPDATE keyword, it can edit datasets in an\nISPF-like setting, under raw TSO in READY mode.  Without REVIEW, I would\nhave had access to Rob Prins' RPF editor (CBT Tape Files 415 or 417),\nwhich is also in my toolkit library, but I think the REVIEW UPDATE file\neditor is easier to use, being more like the ISPF editor.  Otherwise, I\nmight have been forced to use the old TSO line editor called EDIT.  EDIT\nis supplied by IBM with all MVS systems, even the very ancient ones.\nUsing the TSO EDIT command is tedious, but if you know what to do, EDIT\nwill do the trick just as well as any other tool will.  Take your\nchoice, and get the job done.\n\n      So now I got to the PROGxx member in PARMLIB with REVIEW UPDATE,\nand I altered all occurrences of volume name DATA01 to the value it had\nbeen changed to.  Then I went to the console and issued SET PROG=xx, and\nso I got my toolkit library to be authorized.  Then I went to the\nIKJTSOxx member of PARMLIB and used the REVIEW UPDATE subcommand again,\nadding ZAP to the AUTHCMD NAMES list there.  A SET IKJTSO=xx command\nactivated that change, and I was almost in business.  I made a small\nupdate to my LOGON CLIST so I could get a better TSO session, and then I\ndid another LOGON to my session, so the new AUTHCMD stuff would be\nvalid, and after that, I issued the ZAP command with its FULLVOL operand\nto clip the volser name back (in the third record of track 0) to what it\nwas.  Then I set all the changed PARMLIB volser values back to what they\nhad been before, and now I was in business.  The system had been\nrecovered and brought back to a healthy state, so it could be re-IPLed\nnormally.\n\n\nAN OVERVIEW OF MVS SYSTEM STARTUP\n\n      As all of you know, all recovery situations are different, and\nthey depend on two factors:  what had been damaged, and what is still\nthere.  Since a lot of different stuff can be damaged, and every\ncircumstance is different from the other circumstances, I feel that an\noverview of how MVS starts up, is the easiest way to teach an MVS\nsysprog how to recover a damaged system.  If you know how the system\nstarts up, then you'll have a better handle on assessing the level of\nsystem damage.  You'll better be able to answer the three \"recovery\nquestions\" that I mentioned before.\n\n      An MVS IPL needs to have the bootstrap program pre-loaded on the\nfirst track of the MVS res pack.  This is done when you set up the\nsystem, using ICKDSF, and the bootstrap program for the current level of\nMVS is shipped in SYS1.SAMPLIB as members IPLRECS and IEAIPL00.  When\nthe bootstrap program runs, it looks for SYS1.NUCLEUS and the LOADxx\nmember of either SYS1.IPLPARM or SYS1.PARMLIB, whose suffix you\nmentioned in the IPL configuration.  From there, the system knows where\nthe MVS system catalog is, where the PARMLIB datasets are, and it can\nstart finding datasets and initializing the system control blocks.  So\nat that point, the system values which are pointed to by the CVT macro\nare getting filled in.  If there's any damage at this point, the system\nusually goes into a wait state, and you have to look up the wait state\ncodes to figure out what went wrong.\n\n      Once the system control blocks have been filled in from PARMLIB\nvalues, the essential system address spaces are then started, using\nstarted tasks, before JES (2 or 3) comes up.  After JES comes up, then\nmany more tasks can be started, using the COMMNDxx and IEACMDxx members\nof PARMLIB to get them going.  At that point, if the system itself isn't\ndamaged, then any further problems are usually in the individual address\nspaces, and they don't have to do with the system in general.  But\nsometimes this isn't true, because a PARMLIB value can be set wrong.\nAnd if that wrong value isn't one that disturbs the flow of the IPL, you\ncan still have a \"damaged\" system because one of its controlling values\nisn't right.\n\n      So now that we've quickly seen how the system starts up, we can\nbetter assess the nature of a given problem.  In my experience, many\nproblems occur at the address space level.  But a problem in starting\nJES, or TSO, or ISPF, or with a usercatalog, or with some other system\ncomponent, can occur on a deep level, and they all have to be recovered\nfrom.  How can we start preparing for all of these unfortunate\ncircumstances, before they occur?\n\n\nACCESS TO TOOLS, AND ESPECIALLY TSO\n\n      Rule number one in my book, is to always have access to another\nMVS system which can access (at least some of) your disk packs.\nPractically speaking, an MVS system can only be fixed by an MVS system,\nand therefore, when one MVS system is broken, it's very helpful to have\neasy access to another one.  You can accomplish this in your shop by\nsetting up a one- or two-pack \"rescue system\" (see CBT File 434 for\nexamples of JCL to do this).  Or your shop may already be configured\nwith alternate res packs for a \"test system\" or a res-pack flip-flop\narrangement.  In any case, you need another MVS system that is\navailable and accessible.\n\n      After MVS itself, you need access to TSO.  ISPF runs under TSO,\nand since ISPF requires a lot of dataset allocations, it is not always\navailable in a \"damage situation\".  But even before even addressing the\nproblem of ISPF, you need to be sure that you can have TSO at all.\n\n      I take the safeguard of adjusting my TSO LOGON PROCs by putting as\nfew of the TSO dataset allocations as possible into the JCL, and as many\nas possible, into an \"allocation CLIST or REXX\" which gets executed\nafterwards.  What this accomplishes for a recovery situation, is that\nyou can still have TSO available, even though one of the \"essential\"\ndatasets for your session is unavailable.  It's easy to see why.  TSO\nstarts using a LOGON PROC in one of your system proclibs, defined by the\nJES startup.  A LOGON proc is just like any other JCL stream.  If one of\nthe allocated DDNAMEs is missing, then you get a JCL error, and the PROC\ncan't start.  So you don't have TSO.  By eliminating all but the\nessential parts of the JCL in the LOGON PROC, you assure that damage to\nthe other datasets, which are not entirely essential for the TSO session\nto start, will not cause you to lose access to TSO altogether.\n\n      At this point, before we close for this issue, I want to give you\na hint on how to convert your DDNAME-filled TSO LOGON PROC into one that\nhas been stripped down to the bare bones, with the unessential dataset\nallocations being made later.  On modern MVS systems, the tool to use is\nISRDDN.\n\n      LOGON to your usual TSO session that has all the hard-coded JCL in\nthe LOGON PROC.  Get into ISPF, and then type TSO ISRDDN on the command\nline.  This will get you into a fullscreen display of all of your TSO\nsession's dataset allocations.  Then (for recent levels of ISPF) type\nthe word CLIST on the command line, and press ENTER.  You'll get a fully\nprepared LOGON CLIST with all of your current dataset allocations, that\nwill come up under ISPF EDIT.  Do a CREATE to copy this CLIST into a\nlibrary in your SYSPROC concatenation, and edit it afterwards, if that\nis necessary.  Create a new LOGON PROC, based on the emergency LOGON\nPROC that is usually shipped with MVS, and have it execute the CLIST\nin the PARM field of the EXEC PGM=IKJEFT01 or PGM=ADFMDF03 card.  Set\nthe SYSPROC DDNAME in the LOGON PROC to point ONLY to the one library\nwhich contains the logon CLIST.  Run your new LOGON PROC in parallel to\nthe old one, and keep adjusting the new one, until both of them allocate\nexactly the same datasets for the TSO session.\n\n      We'll continue on this topic next time, mentioning more\nparticulars for different recovery situations, and I'll show you how to\nset up free tools in advance, to help you with myriad recovery\nscenarios.  The CBT Tape collection of MVS software tools, which is\nentirely free, can be found by doing a www.google.com search for the\nwords \"CBT Tape\", and its website should come up at, or near, the top of\nthe list.  Meanwhile, I wish all of you a good month, and the best of\neverything.  Please come back and visit this column again, in our next\nissue.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0612DE": {"ttr": 29962, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00B\\x01\\x061/\\x01\\x061/\\x16\\x13\\x01'\\x01'\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-11-08T00:00:00", "modifydate": "2006-11-08T16:13:42", "lines": 295, "newlines": 295, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         DECEMBER 2006\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.\n\n\nSYSTEM RECOVERY TOOLS - PART 2\n\n      This month we'll continue our study of how to recover from the\nvarious damages that can occur during the startup of an MVS system.\nEverybody knows that a damaged MVS system can normally be recovered only\nby having another MVS system (or maybe a VM system) which can access the\nsystem's disk packs.  However, if the damaged system is partially up,\nsometimes it may be recovered using specialized tools that don't need a\nfully operational system to work.  Today, we'll look at such tools,\nwhich for example, might allow you to edit files from raw TSO (i.e.\n\"READY\") mode, if ISPF isn't available, or which might allow you to fix\na PARMLIB member if only a system console is available and TSO isn't\nthere at all.  You can easily see the advantage you can have, to use\ntools like these, if they have been previously installed and are now\navailable.\n\n      Last month, we took you through a quick tour of how an MVS system\nstartup works.  We need to know that, because if the startup gets\ninterrupted at some stage, we have to know what's already there to use,\nand what's not yet there, and still unavailable.  Then, to recover, we\ncan pick an appropriate tool which can operate with the facilities that\nare already there, but which does not need the part of the system that\nis not there.  So to quickly summarize, how does an MVS system start up?\n\n      Basically, the idea is this.  At IPL time, the system is IPLed\nfrom bootstrap records which have been previously loaded from a disk\npack or perhaps from a tape, or even from a cd-rom.  The bootstrap\nrecords look for a LOADxx member in SYS1.IPLPARM or SYS1.PARMLIB that\nwill tell the fledgling system where the PARMLIBs are, and where the\nMaster Catalog is.  Once that information is available, the system can\nthen proceed to look at the IEASYSxx member(s) of PARMLIB and the other\nPARMLIB members which will tell it how to start up.  The names and\nlocations of datasets essential to the next phase of the startup are\nfound there.  Finally, the startup is able to proceed and fill in all\nthe data that is normally pointed to by the CVT area in storage, and\nonce that has been done, the system can then operate relatively\nnormally.  That is a \"quick summary\" of how an MVS IPL works.\n\n      When the IPL is interrupted or damaged at some stage, often the\nonly recovery necessary, is simply to point the system to a corrected\nPARMLIB member, which will then be pointed to correct or corrected\ncopies of the essential system datasets.  But if any of those datasets\nare themselves damaged, then they either have to be physically fixed, or\nelse (at least) the appropriate PARMLIB member has to be adjusted to\nre-point to a corrected or fixed copy of the damaged dataset.  Making\nsuch an adjustment usually means possessing a tool that can either edit\nthe PARMLIB member, or which can perform an IEBCOPY of a correct PARMLIB\nmember from another pds somewhere, to the PARMLIB pds that's needed for\nthe IPL.  So for recovery purposes, we usually need a file editing tool\nwhich can work when most of the MVS system is not available.\n\n\nEDITING TOOLS, AND THE MINIMUMS THAT THEY NEED\n\n      I always try and have a bunch of file editing tools available,\nwhich need a minimum of system resources.  I think that the best file\neditors for recovery purposes are the ones that do not need MVS at all.\nThere is a vendor product called \"Stand Alone Edit\" from New Era\nSoftware which will IPL on a standalone basis and do file editing, but\nthat product is expensive.  A free alternative, which works very well\nindeed, is ZZSA from Jan Jaeger.  You can obtain and learn about ZZSA\nfrom the free CBT Tape collection, on Files 437 and 538.  And you can\nget to the CBT Tape collection by doing a www.google.com search for the\nstring \"CBT Tape\".  The CBT Tape website will come out at or near the\ntop of the search, and you don't need to be a \"member of anything\" or\nto have any password, to obtain the good materials available there.\n\n      You can IPL ZZSA either from DASD (pre-loaded via ICKDSF), tape,\ncard images loaded from a card reader, or from a cd-rom.  When you IPL\nZZSA, you need a system console available, and already there.  In your\nIPL system configuration, please be sure to also include all the DASD\nvolumes that you will want to fix or access.\n\n      Once the IPL proceeds and stops, you then just press an interrupt\non the console screen (such as the ESC key) and ZZSA will fire up on the\nscreen.  Please look at Figure 1 to see the ZZSA main menu.  I think\nthat the first thing you should do, upon starting ZZSA, is to execute\nthe \"0\" option to list the attached devices.  That operation will tell\nZZSA where all your DASD volumes are, and it will speed up all the\nsubsequent operations, such as editing a file.  The rest of the\noperations can be found by \"following your nose\" and playing with the\ntool.  If you really need to recover a slightly damaged MVS system but\ncan't IPL it at all, then ZZSA could be your ticket to recovery.\n\n      The ZZSA file editor is (of course) more limited than other file\neditors that were designed to run under operating systems.  So you can\nuse the ZZSA facilities to try and get your system IPLable.  And then\nonce the system comes up, at least partially, you can use some other\nfile manipulation tools, which we'll describe now.\n\n\nIF TSO DOESN'T COME UP\n\n      To guard against a situation where (perhaps) you don't have VTAM\nor even JES2, and TSO can't come up, you should install the TSSO product,\nfrom CBT Tape File 404.  I have tested and run TSSO from File 404 on\nsystems as recent as z/OS 1.7.\n\n      TSSO (which is quite versatile, also including an Automated\nOperations part), at rock bottom, establishes a TSO-like line-mode\nenvironment in which input and output for TSO functions occurs through\nsystem console inputs and outputs.  TSSO runs as a subsystem, and you\nassign a subsystem character to TSSO so it can accept its own subsystem\ncommands.  If you have JES up, you can start TSSO under SUB=JES2 or\nSUB=JES3.  But if JES won't come up, you can start TSSO under SUB=MSTR\nand even then, it can still do most of its magic.\n\n      For example, suppose the TSSO subsystem character is a question\nmark (?).  Then when TSSO is up, even under the master subsystem, you\ncan issue TSO line-mode commands from the system console, and get the\nPUTLINE outputs on the system console too.  So if you enter the command,\n?LISTD 'SYS1.LINKLIB', you'll get a LISTD output displayed for\nSYS1.LINKLIB on your console, and the full output will also show up in\nSYSLOG (assuming you have SYSLOG).\n\n      You can give TSSO as much power as you want to, just as you can\ngive your TSO userid and TSO session as much power as is needed.\nInstead of a TSO LOGON PROC, you make your TSSO startup PROC very\nsimilar, following the guidelines described in CBT File 404.  You can\nauthorize TSO commands under TSSO in the same ways as under TSO, using\nan Authorized Library STEPLIB DD, and a special IKJTABLS load module.\n(See CBT File 185 for details about that).  Or you can APF authorize TSO\ncommands under TSSO in the ordinary ways.  You can also include the\npowerful free PDS product (CBT File 182 - load modules in Files 035 or\n135) in the TSSO STEPLIB library, so you can run IEBCOPY using the PDS\nCOPY subcommand, from a system console, even if JES isn't up.\n\n      The reason TSSO works this way, is that it uses the established\nTSO load module libraries, such as SYS1.CMDLIB and SYS1.LINKLIB and\nSYS1.LPALIB, even though the TSO address space isn't there.  TSSO\nestablishes its OWN TSO-like environment, in its OWN address space.  And\nremember that you can START TSSO under SUB=MSTR.  TSSO uses the existing\nTSO modules that are in the system, but the TSO-like environment that\nTSSO creates, is ITS OWN, not TSO's.  So TSSO is not dependent on TSO\nrunning.  But TSSO can execute the TSO commands from the TSO libraries,\nand you have full line-mode TSO power with TSSO.  This allows you to run\nall the line-mode PDS 8.6 commands from a system console, if you've\nincluded the PDS 8.6 load module in the STEPLIB libraries of the TSSO\nstartup PROC.  And you can run powerful TSO commands such as CDSCB (CBT\nFile 300) if you had the foresight to include them in the TSSO STEPLIB\nlibrary, and made that library APF authorized.\n\n      So I'll leave it up to your imagination and ingenuity, how far you\nchoose to go with this.  If you install TSSO on your systems, and make\nit as powerful as you need to, then you'll have a fine low-level\nrecovery tool available when not much of your MVS system will come up.\nYou can even use the TSO EDIT line-mode command under TSSO, if you know\nhow to use EDIT and are somewhat skilled with it.  I've even used the\nTSO HELP command under TSSO to display HELP information on the console.\nYou just type something like ?PDS86 'SYS1.HELP' (field mark) LIST LISTD,\nand you can restrict the outputs later, the way you need them, to get\nthe help you need.\n\n\nTSO COMES UP, BUT YOU CAN'T GET TO ISPF\n\n      Two free tools come to mind, which will run under raw TSO, but\nwhich will allow you to edit files and do many recovery operations in a\nversatile way, approximating much of the power of ISPF.  One of these\ntools is RPF (CBT Tape Files 415 (non-XA) or 417 (XA and higher) from\nRob Prins.  And the other tool is REVIEW from Greg Price (CBT Files 134\n(source) and 135 (load modules)).  If you have both of these tools\nalready installed on your MVS systems, then you won't have to resort to\nmore primitive means, if (God forbid) an appropriate recovery situation\nwould present itself.\n\n      Figure 2, which is the main menu for RPF/E (the XA version), gives\nyou a pretty good idea about what the tool can do, using only raw TSO.\nI don't have the space to go into details here, but I must say that if\nyou have a modern MVS system which is at least in XA mode, then please\ninstall RPF/E (from File 417) rather than RPF (from File 415) because\nyou will be able to edit much larger files.  RPF/E puts the data above\nthe 16 meg line.  Nevertheless, author Rob Prins has taken great pains\nto keep both tools at an equal level of functionality and maintenance.\n\n      REVIEW from Greg Price (the original author of REVIEW was Bill\nGodfrey) initially was a file browsing tool only.  But Greg Price has\nadded a file editing capability to REVIEW in recent releases, so that\nMVS 3.8 running under the Hercules emulator (ISPF isn't available there)\nwould have a file editing facility.  (In fact, that's why we have RPF\ntoo.  Rob Prins wanted to give his RPF file editor to the Hercules\npeople so they could have a file editor that ran under raw TSO.)\nREVIEW's new file editing capability is invoked using its subcommand\nUPDATE, invoked from its command line when you're looking at a dataset.\nAnd if you're running REVEIW with a PDS directory, you type U next to\nthe member that you want to edit.\n\n      REVIEW's editor (separate load module REVEDIT, or CSECT REVEDIT)\nis remarkably ISPF-like, but Greg hasn't yet gotten around to adding ALL\nof the ISPF bells and whistles.  Nevertheless, REVIEW is a VERY good\neditor.  RPF is a very good editor too, but I think that REVIEW, being\nnewer, and also containing a lot more file browsing power, can edit much\nmore troublesome and larger files than RPF can.  So between RPF and\nREVIEW (if they are installed on your systems) you have a lot of\nrecovery power when ISPF can't come up for some reason.\n\n\nSUMMARY\n\n      Today we've looked into free MVS system recovery tools at three\nlevels.  The first is when you can't bring MVS up at all.  Then you need\na standalone recovery tool such as ZZSA from Jan Jaeger (CBT Tape Files\n437 and 538).  This should get the system to where you can IPL and get\nsome stuff to come up, at least to the point where LOADxx and PARMLIB\nhave been read, and the MVS fields which are pointed to by the CVT have\nmostly or completely been filled out.  Then a tool which runs SUB=MSTR,\nsuch as TSSO, can help us out to go further.  Finally, if TSO is up, but\nyou can't get to ISPF, the (much) more sophisticated file editors that\nare connected to RPF or REVIEW, can be used to fix the system to where\nit can finally come up completely.\n\n      I wish all of you the best of everything, and hope that you can\njoin me here again, next time.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   Primary Menu for Jan Jaeger's ZZSA Stand-Alone Utility\n\n            Information about ZZSA (which is a free tool) may be\n            found on CBT Tape Files 437 and 538.  You can load a\n            DASD pack with IPL Text for ZZSA, and IPL it, pointing\n            to your existing MVS DASD configuration.  And then you\n            can fix all your packs, without an IPL of MVS!\n\n\nZZSAPRIM                    Stand Alone Utilities\n\nOption ===>\n\n\n    0 ListDev  - List all devices\n\n    1 Browse   - Browse dataset or member           Console     0700/3278\n\n    2 Edit     - Edit dataset or member             IPL Device  0A97/3390\n\n    3 ListVTOC - List Volume Table Of Contents      IPL CPU     0000\n\n    4 ListPDS  - List PDS directory                 CPU Version FD\n\n    5 DispVol  - Display DASD volume label          CPU Serial  000192\n\n    6 Dump     - Dump DASD record by CCHHR          CPU Model   1247\n\n    7 Zap      - Alter DASD record by CCHHR         Date (TOD)  07/11/2006\n\n    X Exit     - Terminate program                  Time (TOD)  13:34:33\n\n                                       Jan Jaeger - Version 12/07/98-12.15\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.   Main menu for Rob Prins' XA version of RPF, called RPF/E\n\n            RPF (non-XA) is found on CBT File 415.  This version,\n            called RPF/E (for XA, ESA, and higher) is found on\n            CBT File 417.\n\n\n---------------------------- RPF/E MAIN MENU --------------------Invalid option\nOption  ===>\n                                                            USERID  - SBGOLOB\n  0  Defaults    - Alter / Display session defaults         Time    - 10:49:11\n  1  View        - Display source data or output listings   System  - SYS1\n  2  Edit        - Update / Create a member or dataset      TSO-proc- ISPFPROC\n  3  Utility     - Enter UTILITY                            Release - V1R2M2\n  4  Assembler   - Foreground ASSEMBLER and LINK\n  5  User        - Execute RPF/E user routine\n  6  TSO         - Execute TSO commands                      November  2006\n  7  Tutorial    - Display HELP information               Su Mo Tu We Th Fr Sa\n  8  Test        - Enter TEST mode (Authorized)                     1  2  3  4\n  9  Operator    - Enter OPERATOR mode                     5  6  7  8  9 10 11\n  X  Exit        - Terminate RPF/E                        12 13 14 15 16 17 18\n                                                          19 20 21 22 23 24 25\nHit PF03/15 to terminate RPF/E                            26 27 28 29 30\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0701JA": {"ttr": 30212, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x064O\\x01\\x064O\\x010\\x00\\xe9\\x00\\xe9\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-12-10T00:00:00", "modifydate": "2006-12-10T01:30:03", "lines": 233, "newlines": 233, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         JANUARY 2007\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.\n\n\nA LITTLE BIT AT A TIME\n\n      I am very thankful to mention, that this month's installment\nbegins this column's nineteenth year.  In that vein, I think it is\nappropriate to give proper credit to the old-timers in this field, and\nat the same time, to give encouragement to the newer people.  Knowledge\nof MVS isn't easy to come by.  The MVS system (whatever name you call it\nnow--z/OS and so forth--it is still MVS) contains many intricate\ncomponents, and IBM keeps adding more of them.  Nevertheless, MVS is\nvery special, because IBM does not often rewrite its oldest components,\nand those older parts of MVS (even if changed or improved somewhat)\noften work the same way that they did many years ago.  So much of the\nold MVS knowledge still very much applies today.\n\n      For that reason, we have to acknowledge the wisdom of the MVS\nold-timers, whose expertise was accumulated over many years, through\nmany \"wars\" and experiences, and by their having dealt with many errors,\neither their own, or those that were imposed upon them by others.  This\nexperience, which cannot be replaced, was acquired over time, a little\nbit at a time.\n\n      And every MVS practitioner acquires his or her OWN unique set of\nknowledge.  The knowledge is a mixture of deep system information and\n\"trivial\" facts.  Sometimes knowing one ISPF setting will save hours of\nunnecessary work.  Other times, you have to have found out about the\nintricacies of some system control block, in order to solve a problem.\nOur expertise cannot be classified as \"hard\" or \"easy\".  It can probably\nbest be expressed as \"a miscellaneous collection of stuff.\"  Everybody\nwho has spent a significant amount of time servicing the MVS system,\nknows this.\n\n      So now, to encourage the new people.  Us old-timers were all new\npeople once.  I remember my first systems programming boss \"classifying\"\nme as \"light\".  I'm not sure how many people would say that about me\ntoday.  BUT WE CAN ALWAYS LEARN, and that is the process.  The real\ntruth is that each person is \"himself\" or \"herself\".  And every time we\nlearn something new, we become a BETTER \"himself\" or \"herself\".  That is\none of the most important things we can know, not only in systems\nprogramming, but in LIFE itself.  The more we concentrate on improving\nOURSELVES, and the less we concentrate on whether we're \"better\" or\n\"worse\" than the other person, the more accurately we will live our\nlives.  Each of us is DIFFERENT than the next person.  We can pick up\ngood pointers and knowledge from them, but we are US, and we are NOT\nTHEM.  We NEVER will be THEM.  We ALWAYS will be US.\n\n      I have been fortunate to have had mentors.  I have learned tons\nof stuff, a little bit at a time, from many (more experienced, and less\nexperienced) people.  A \"less experienced\" person is often more\nexperienced than I am, but in a different area.  So really, for people\nwho have already had SOME experience, you can't classify anyone.  For\nme, it's just so much joy to spend some time talking systems programming\nwith somebody.  I used to spend time on the phone with Greg Price and\nBruce Leland and Steve Smith, John Kalinich and Rick Fochtman, and many\nmany others.  I've learned a lot of things from all of them.  Sometimes\nwhat I learned seemed very trivial at the time, but it was \"the little\nfact\" that solved the problem which was then facing me.  So in\nretrospect, I have to say that just about everything I know, was\nacquired a little bit at a time, from books, from other people, and from\nlooking at the operating system itself, using tools.\n\n      To finish this section, I have to mention that I get (or see)\nquite a few emails from people in other countries, notably India, who\nare starting to learn about MVS, and they are in various beginning\nstages.  It is very instructive for me, to watch the progress of some of\nthese people.  I remember one guy, who started by asking very elementary\nquestions, and within a few months, he was already doing stuff that I\nhad no experience with.  I was very impressed by him.  Other people\nasked questions which showed that they may have had less \"geniousy\nminds\", but they were progressing nicely nevertheless.  In my opinion,\nthey are all doing valuable jobs.  The world needs all of them.  And to\neach of you I say:  If you like this job, keep learning things about\nMVS, a little bit at a time.  The knowledge will pay you back!\n\n\nMY EXPERIENCE, AND MY EXPOSURE\n\n      I feel fortunate, that as proprietor of the free \"CBT Tape\"\ncollection of MVS goodies, I get to see the many contributions from\npeople all over the world, which come in to me.  All of you can see the\nsame stuff that I do.  It is all available at the CBT Tape website,\nwhich can be easily found by doing a www.google.com search on \"CBT\nTape\".  Our website comes out at, or near, the top of the search items.\nThe stuff at the CBT Tape website is all free, and you don't have to\nhave any password or be a \"member of anything\" to have access to all the\nmaterials found there.\n\n      But there's a difference between my view and yours.  I don't have\ncontrol as to when I get to see the stuff.  And I don't have a choice as\nto what I want to see.  If somebody sends something to me, I have to\nlook at it then and there, no matter what kind of MVS tool it happens to\nbe.  I don't have a choice.  It's my job to look at it, evaluate it,\npackage it, and put it up.  Please look at the \"Updates page\" of the CBT\nTape website, so you can see all of the new contributions which have\ncome in recently.\n\n      I also have to deal with \"tool questions\" that people email to me.\nThey ask whether we have a tool to solve a problem.  Or else, it might\nbe about one of our tools they are already using, which they either\ncan't install, or can't get to work right.  I have to deal with that, if\nand when the question comes in, and in a timely fashion.  So my learning\npatterns are often directed by these considerations.  Nevertheless I\nthink you can profit by my sharing some of the things I've recently\nseen.  And you can see that I too, in my situation, learn stuff a little\nbit at a time.\n\n\nDEALING WITH LEFT OUT DD NAMES\n\n      As an example of something I've had to deal with recently, I'm\ndeliberately choosing a topic that you don't usually come across as a\nsystems programmer, but as an Assembler programmer.  This information\ntook me years to accumulate, a little bit at a time.  Why did I pick\nthis particular topic?  Because every sysprog will encounter problems\nthat are related to it, sooner or later, even if he or she doesn't do\nmuch Assembler coding.  DD names are often left out of JCL; programs\n(and the system itself) react differently, depending on how they are\ncoded, when a DD name is left out.  So it is indeed useful for all of\nus to have some deeper knowledge in this area.\n\n      When you write a program that OPENs and CLOSEs files, there's\nalways the question of how you can protect that program from bombing\nwhen one of its DD names has not been coded in the JCL.  Sure, you can\njust let the system react, but if the program code tries to OPEN (or\nCLOSE) one of its DCBs when the file is not there (because the DD name\nwas left out of the JCL that executes the program) you'll get a nasty\nS0C1 abend, with very little indication where it came from.  And as the\nprogram's writer, you don't want your program to be exposed to such a\nvulnerability.  It's very disconcerting for a user of the program to see\na big rotten abend, during what should be normal program execution, or\nmaybe just a simple JCL error.  So what can you do to protect the\nprogram from something that looks like a catastrophe?  We'll deal with\nthis systematically.\n\n      First, you can test all the DD names in your DCBs that define the\nfiles, by doing a TIOT scan to see if the DD name was coded in the JCL\nat all.  The TIOT is created from the JCL.  Each DD name in the JCL\nproduces one TIOT entry.  And if a particular DD name doesn't show up\nduring the TIOT scan, you know it wasn't coded in the JCL.  Therefore,\nwhen the DD name is missing, you'll know it at this stage of the program\nexecution, and you can take appropriate action before any further damage\nis done.  If the file has not been allocated, you'll surely not try to\nOPEN or CLOSE it.\n\n      A second measure you can take, right after an attempted OPEN, is\nto test the X'10' bit at decimal 48 bytes off the beginning of the DCB\nyou've tried to OPEN.  This bit is on, only after a successful OPEN, so\nyou can see if the OPEN actually worked, and intercept any problems that\nmay have occurred at that point, before the consequences escalate.  If\nyou want to see how to code a TIOT scan, many programs in the CBT Tape\ncollection do it.  One example is my version of the COPYMODS program\nfrom CBT Tape File 229 (at label TIOTSCAN).  The IEFTIOT1 macro which\ndescribes the TIOT, is found in SYS1.MACLIB.\n\n      Then there's a third action you can take.  This one is more\ncomplicated, and requires some setup, but it's often worth it.  It's the\nexecution of a RDJFCB macro against the DCB.  The RDJFCB macro brings a\ncopy of the file's JFCB (one for each DD name is created at Allocation\ntime by the Interpreter) into your program, and you can examine all the\nJFCB fields, either before, or after the OPEN.  After the OPEN, any\nspecific file characteristics hard-coded in the DCB itself are merged\nback into the JFCB, so after the OPEN, what's in the JFCB may not\ncompletely reflect everything that was coded in the JCL or in the\ncatalog.  The program's hard-coded DCB fields may also override your JCL\nat that point.\n\n      Executing a RDJFCB against a particular DCB requires adding an\nEXLST parameter to the DCB, pointing to an area defined by an X'07' or\nX'87' header list, and a pointer to a 176-byte area in your program\nwhich will contain the copy of the JFCB.  So it's a bit of work to set\nup, but once you've done it, it's easy, and it's there in your program\nfor you to use.\n\n      And it often pays.  Knowing all the details of the characteristics\nof the particular file you're trying to access, gives you a lot of\ncontrol before the OPEN, as to whether or not you want to OPEN the file,\nor whether you want to change the way you OPEN it.  And (either before\nor after the OPEN), you can also have your program display many of the\nfile's DCB characteristics at execution time, such as its actual name,\nthe volume it's on, LRECL, BLKSIZE, DSORG, and so forth.  Remember that\nthe JFCB was created by the Interpreter (or by Dynamic Allocation), and\nit contains information about the actual files on your system which the\nprogram is trying to access.  In skilled hands, RDJFCB is a very\nfantastic tool.  Most of the information about using the RDJFCB macro is\nfound in the z/OS DFSMSdfp Advanced Services manual.  Most of the\nJFCB-related fields are described in the IEFJFCBN macro in SYS1.MACLIB.\nThe JFCB extension is described by the IEFJFCBX macro.\n\n      One more word about the JFCB before I close.  Once you've done a\nRDJFCB macro BEFORE the OPEN, and you've brought a copy of the JFCB into\nyour program, your program can modify some of the fields of the JFCB and\nuse the copy of the JFCB that's in YOUR PROGRAM to OPEN the file, rather\nthan the copy of the JFCB which the system had created.  To do this, you\ndon't execute an ordinary OPEN for the file, but rather an OPEN, TYPE=J.\nOPEN, TYPE=J has some restrictions, one example being that if you've\nmodified the JFCB for a tape file to force BLP processing, your program\nhas to be APF authorized to do the OPEN, TYPE=J.  This is a system\nrestriction, and in those special cases, you have to know about these\nthings, to get them to work properly.  (That's what experience is for.\nAnd the IBM manual talks about the subject.)\n\n\nCONCLUSION\n\n      If there's one thing I've learned in my years as an MVS sysprog,\nit is that \"a lot of knowledge only comes a little bit at a time.\"  It\nis accumulated as you deal with specific situations, and as you overcome\nthe problem that is facing you NOW.  Over time, the facts accumulate in\nyour head, and you get a bigger picture of what's happening.  In turn,\nthe bigger picture helps you understand more specific details, as you\naccumulate more knowledge and experience.  You shouldn't try to learn\ntoo much, too fast.  Usually, that doesn't work.  But doing it this way,\nlearning a little bit at a time, is a universal formula for success.  I\ncan testify to that.  And so can almost everybody else.\n\n      I wish all the best of everything to all of you, and as this\ncolumn enters its nineteenth year, I'm hoping to see you back here\nagain, next month and beyond.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0702FE": {"ttr": 30217, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x07\\x01\\x07\\x01\\x0f\\x01\\x07\\x01\\x0f\\x080\\x01\\x01\\x01\\x01\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-01-10T00:00:00", "modifydate": "2007-01-10T08:30:07", "lines": 257, "newlines": 257, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         FEBRUARY 2007\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.\n\n      ***      By Sam Golob and Courtney Taylor     ***\n\n\nTECHNOLOGY BREEDS TECHNOLOGY\n\n      Today's topic needs a bit of introductory explanation.  The idea\nof \"technology breeds technology\" is something like the idea of\n\"knowledge breeds knowledge\", but the two concepts are not exactly\nalike, and there is a big basic difference between them.  Nevertheless\nif you know about the idea of \"knowledge breeds knowledge\", then you can\ngrasp what is meant by \"technology breeds technology\".  And \"technology\nbreeds technology\" is a very important idea to understand well.  That's\nwhy I felt it was necessary to write an article about it.  The idea of\n\"technology breeds technology\" is very close to the life of an MVS\nsystems programmer.\n\n      What is meant by \"knowledge breeds knowledge?\"  It simply means\nthat when you learn a fact or a principle, and you know it, you can then\nbuild on knowing that fact or principle to learn yet another fact or yet\nanother principle.  And the new knowledge which came from previous\nknowledge builds up piece by piece, so that you eventually accumulate a\nbig body of knowledge after you started out with just a little bit.  For\nexample, when you start to learn a new language, you learn a few words\nfirst.  When you know how to say a few things, you can then build on it,\nby asking how to say a few more things, and eventually, you can speak\nthe language quite well.  So you see that a bit of knowledge can be\nexploited to acquire more knowledge, and eventually, when you follow the\npath out, you acquire a lot of knowledge and become quite an expert on\nthe subject.\n\n      Technology is like that, but instead of consisting of isolated or\nsmall pieces of knowledge alone, each \"piece of technology\" or \"level\nof technology\" is a complete tool, or a complete piece of machinery,\nwhich works by itself as a separate entity.  To show this better, if\nyou'd say that if a piece of knowledge can be symbolized by knowing how\nto use a particular Assembler language instruction, then a piece of\ntechnology would be like having a complete, working Assembler language\nprogram or tool, that has already been completely debugged, and it is\nknown to work well.  Once you have the complete program in place and\nyou can use it, you have acquired some technology (even if you wrote\nthe program yourself).  And then you can use this \"technology\" that you\nacquired by writing or by using that program, to write and use more\nprograms.  And so, having some technology, breeds acquiring more\ntechnology.  It's like accumulating knowledge, but to be more exact,\nit's more like accumulating tools.  A \"piece of technology\" is already\na complete working tool or set of tools, and it is not just \"an\nisolated piece of knowledge.\"\n\n\nA NEW ENVIRONMENT\n\n      We tend to feel the \"lack of technology\" and \"the need for more\ntechnology\" when we are entering a new environment, where things are not\nas familiar to us as they were before.  Most of us have changed jobs\nduring our careers.  Even though the new shop is an MVS shop, and the\nold shop was an MVS shop, they usually were by no means identical.  And\nwe had to take quite a bit of time to accommodate ourselves to the new\nplace.  Furthermore, in many instances, the new place did not own or\nlicense proprietary software (or hardware) tools which the old place\nhad.  So we had to learn to do without some of the \"technology\" that we\npreviously were familiar with.  Of course, the new place would often\nhave licensed other proprietary software tools, so now, we would have\nthe opportunity to take advantage of learning and using new \"technology\"\nalso.  See what I mean?  I'm trying to show you how to look at an MVS\n(or any other) environment in \"technology\" terms.\n\n      A case in point, which shows this principle very dramatically, is\nthe \"hobbyist MVS environment\" which involves being able to run ancient\nMVS 3.8, under the Hercules emulator, on your PC at home.  IBM used to\nbe primarily a hardware company, in the business of selling their large\ncomputers, and they conveniently provided the software which ran on\ntheir machines for no extra charge.  (The computers, then, were\nexpensive enough so that IBM could do very well on the hardware money\nalone.)  Then around 1978, following a lawsuit, IBM was forced to charge\nmoney for the system software they had developed.  But the software\ndeveloped before that, would remain free.  This is why it is possible to\nlegally run a free version of MVS, using an S/390 instruction emulator\nwhich was developed to run on a PC.  The \"ancient MVS\" of the mid-1970s\nis still, indeed, free software.\n\n      But of course, the \"technology\" of 1975-era MVS is not the same\nas ours.  Many pieces of MVS that we are now familiar with, are\nconspicuously missing.  For example, ISPF came later, so ISPF is not\nthere.  Most of us would have a very hard time using MVS under TSO on a\nsystem that doesn't have ISPF.  But if you run \"hobbyist MVS\", then you\nare forced to do just that.  Therefore, there was an effort to develop\n\"replacement technology\" to try and get around the fact that all the\n\"ISPF technology\" was missing.  Rob Prins (of the Netherlands) brought\nhis \"RPF\" package back, which was an ISPF-like file editor and\nutilities package he had developed in the early 1980s.  (See CBT Tape\nFiles 415 or 417 to get the RPF package(s).)  And Greg Price added an\nISPF-like file editor extension to his REVIEW (TSO-based) browsing\nprogram (CBT File 134).  So with these \"new technologies\", it would then\nbe possible to approximate some of the advantages of having the ISPF\ntechnology available, which we all now pretty much take for granted on\nan MVS system.\n\n\nTHE MVS DEVELOPER ENVIRONMENT\n\n      While I'm here, I feel it is very important to discuss the \"MVS\nDeveloper\" environment that many of us work in.  This environment is\nwhere many of the \"new technologies\" that we use, are born.  Of course,\nevery computer system requires a development environment.  People always\nhave to develop new software packages (i.e. \"technologies\") for computer\nsystems, so that your everyday work on the system is made easier.  For\nexample, I remember the FSE (Full Screen Edit) package for MVT, which\nwas better than (line mode) TSO EDIT by a long shot.  But ISPF (for MVS)\nwas a lot better than FSE.  FSE was a \"technology\" that had to be\ndeveloped by a private software company.  So you see why this area is so\nrelevant to today's topic.  And private software companies outside of\nIBM, had many difficulties.\n\n      In former times, MVS software required very expensive machines to\nrun on.  You couldn't write MVS software unless you had a 5-million\ndollar or 10-million dollar machine to run it on.  So the software\ndevelopers (and software development companies) for the MVS environment\neither had to be very rich (which most of them weren't), or they had to\ncontract for computer time from very large companies, which had the use\nof these machines.  I personally think that this situation set the\nprecedent, to explain why most commercial MVS software today is so very\nexpensive to license.  At that time, the software was very expensive to\ndevelop.  Then, in the early 1990s, IBM addressed the \"low-end machine\nproblem\" for developers, by coming up with the PC-based P/390 machines,\nthat depended on a special hardware card which ran the S/390 instruction\nset (under OS/2) on a PC.\n\n      All of a sudden, the P/390s went out of style.  This was for an\nobvious reason.  By the year 2000, IBM had started the process of adding\nhundreds of new hardware instructions to its instruction set, and if you\nwould try and make these new instructions execute on a hardware card,\nyou'd have to come out with a new hardware card every year.  Therefore\nIBM gave up on its P/390s and Multiprise successor machines,\ninadvertently leaving the developers in the lurch.  (I remember it well.\nI asked them about the low-end machines, and they wouldn't give me an\nanswer.)\n\n      But meanwhile, Fundamental Software (FLEX-ES) had come out with\ntheir new \"hardware emulation technology\" to run S/390 hardware\ninstructions in emulation mode on an ordinary unmodified PC.  Hardware\ninstruction emulation was nothing new.  In the old days before System\n360, IBM would always have some emulation technology which would run the\nprevious system's hardware instructions on the new machine.  But this\ntime, IBM was taken by surprise.  In their big effort to add new\nhardware capabilities to the new \"z\" machines, they left the low-end\nsoftware developers hanging.  So IBM turned to the most \"established\"\ncompany that had already developed a relatively inexpensive system which\ncould help the developers.  And IBM contracted to the FLEX people, to\nproduce the emulation software solution that would satisfy all the\nlow-end developer needs.  But I wouldn't be surprised if IBM might yet\nannounce their own low-end solution.  Who knows?  Technology does not\nstand still, and anything can happen.\n\n\nBACK TO SOFTWARE TOOLS\n\n      I'd like to share one of my recent experiences which reflects the\nconcept of \"technology breeding technology\".  As (I hope) you might have\nheard, I'm busy trying to extend my free BRODCAST Dataset management\npackage (CBT Tape File 247) into a commercial product.  (In contrast\nwith the current trends, I intend to make it VERY inexpensive.)  By the\nway, if you want to access the free tools in the CBT Tape collection,\nplease do a www.google.com search on \"CBT Tape\", and the correct website\nshould come out at, or near, the top.\n\n      In the process of developing an \"industrial strength\" version of\nmy BRODCAST package, I wrote a program (called BDMINIT) which is driven\nby SYSIN keywords, that allows you to create a BRODCAST Dataset of any\nsize.  The BDMINIT program calculates all the necessary quantities\nyou'll need, and it tailors itself to any geometry of CKD DASD.  Also,\nit does not rely on any BRODCAST Dataset management facility or BRODCAST\nutility that comes from IBM.  In other words, if you want 200 Notices,\nyou don't have to zap some IBM module.  You merely have to code\nNOTIFY=200 in a SYSIN card.  With just your own SYSIN input, all the\ncalculations and initializations for the entire new BRODCAST Dataset are\nautomatically done for you.  And the program makes sure you've allocated\nenough space on DASD.\n\n      So now I have technology that allows me to quickly create a\nBRODCAST Dataset of any size.  I made one that is 3000 cylinders, with\nspace for 10000 users and over 2 million messages.  And I made another\none that is one track, with space for 9 users and 21 messages.  They\nboth work.  I switched my system to use both of them, using the new\nPARMLIB UPDATE(xx) facility that allows you to switch the active\nBRODCAST Dataset on your MVS system.  Making both of these datasets\njust took a matter of minutes (mainly for formatting the large one).\n\n      Using this new technology which I now have in my pocket, I can\ntest my other BRODCAST programs, such as my souped up BRODCAST Dataset\nSCAN program (called BDMSCAN), on a tailor made BRODCAST Dataset which\nI can whip up on short notice.  The technology that allowed me to\ninstantly create any size BRODCAST Dataset, then helped me to fix my\nother programs, and develop even more technology for handling the\nBRODCAST Dataset or any copies thereof.  The technology that I myself\ncreated, is breeding more and more technology that I hope many of us\nwill be able to eventually use.\n\n      Here's another thought.  Any software tool that you use in your\nwork, whether it be commercial software from IBM or another vendor, or\nfree software that comes from the CBT Tape Utilites collection or any\nother place, can rightfully be considered \"a piece of technology.\"  And\nyou, yourself, use these pieces of technology to either write your own\nprograms, or to do something to maintain your system.  I'd challenge\nanybody working in this field to prove that he or she has NOT INNOVATED\nsome new technique or has NOT WRITTEN any new program, even if it was a\nCLIST or a REXX.  That is next to impossible.  You can't do this work\nwithout doing any innovating or creating!  And much of the innovating\nand creating, when you think about it, involves making new \"technology\",\neven if it is just putting together a cleverly crafted JCL stream.  And\nto do all this, we use our existing \"technology\".  So just in doing our\neveryday work, we see, indeed, that \"technology breeds technology.\"\n\n\nSUMMARY\n\n      Today, my purpose is merely to rephrase some facts that we already\nknow.  But it comes with the intent of making us focus on the progress\nwe are making, and on the \"technological\" advances we are living through\nand participating in.  When we look at our work in this way, we see that\nit is an exciting and satisfying job that we do.  Besides that, whether\nwe realize it or not, we are constantly contributing to making our own\nwork easier, and everyone else's work, too.\n\n      The mechanism we employ, is to \"use technology to create new\ntechnology.\"  That is really what we are doing, most of the time.  In\nthis definition, the word \"technology\" means any finished tool or\ncreation, which we can use to do some work.  All of our work is done\nwith tools.  And each of the tools is \"a piece of technology\".  When we\ndo our work, the tools we are using are either employed to create\nsomething else, say another tool, or to create a technique to use the\ntools.  So whether we know it or not, we are constantly using\n\"technology\" to create \"technology\".\n\n      Because we often don't realize we are doing this, I feel I have to\nbring it out into the open.  Big technological advances, such as the\ncreation of a new database system or a new way to store your data, pique\nyour attention.  But we should all be aware of the small technological\nadvances, which we are all contributing to, every day.  Old technology\nbreeds new technology constantly, as long as someone is working at it.\n\n      I wish all of you the best of everything, and I am happy to \"see\"\nall of you here today.  Please come and visit us again, next month.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0703MA": {"ttr": 30465, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00(\\x01\\x07\\x04\\x0f\\x01\\x07\\x04\\x0f\\x01\\x13\\x00\\xe9\\x00\\xe9\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-02-09T00:00:00", "modifydate": "2007-02-09T01:13:28", "lines": 233, "newlines": 233, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           MARCH 2007\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.\n\n\nSANITY CHECKS AND PROGRAMMING ENHANCEMENTS\n\n      Back when I was looking for my first programming job, you\npractically couldn't get anywhere if you didn't know how to write a\nFLOWCHART.  I don't know how much flowcharts are used nowadays, so I\ndon't know how familiar the readership is with them.  But they can be\nbasically characterized as \"program logic diagrams\" in a certain format,\nwhich describe each logical step that a program takes, together with a\nmapping of the logical flow and relationship between the steps.  Hence\nthe name \"flowchart\".  It charts the program logic flow.  If you have\nthe privilege of looking at the old IBM MVS logic manuals, you will see\nmany flowcharts there.\n\n      In one of my programming interviews a long time ago, the head man\nasked me to flowchart a candy vending machine.  You put in some coins,\nand out comes a candy bar.  The job was to write a logic diagram, in\nflowchart format, to accurately describe what happens in the machine,\nfrom the time you put in the coins, to the time you get the candy.  The\nboss told me (afterwards) that his head programmer, when asked to do\nthis, produced a diagram with over 100 boxes, describing each step and\ndecision in excruciating detail, and anticipating many possible\nproblems.  Of course the boss was very proud of him, and he hired him.\n\n      Detail in anticipating a logic problem in a program, is often\n(nowadays) called a \"sanity check\".  I don't remember hearing the term\n\"sanity check\" when I first started.  It may be a relatively new word.\nBut it does describe the concept of putting some extra code into a\nprogram, so as to circumvent a possible future problem.  It's like\nputting an extra box or two into a flowchart.\n\n      I think that many sanity checks are necessary, and even more\noften, they cause more problems than they solve.  My (pure) mathematics\nbackground reminds me to emphasize what mathematicians call \"elegance\".\nThis means \"simplicity\" in the sense of doing only what's essential.  In\nother words, an \"elegant\" solution to a problem involves doing ONLY what\nis necessary, cutting through ALL the crap, getting EXACTLY to the\npoint, and eliminating ANYTHING extra.  Another term which is\napproximately equivalent to an \"elegant solution\" is a \"tight solution\",\nbut elegance also implies aesthetic \"prettiness\" in addition to the\n\"tightness\" of the code.\n\n\nEXTRA BOXES IN MVS UTILITIES\n\n      That brings us closer to today's topic.  In the MVS world, we\nuse \"tried and true\" utilities to do much of our work.  IBM, over the\nyears, has endeavored to make sure that their utilities will not\nproduce problems when you go from earlier MVS operating systems to\nlater ones.  But once in a while, you'll get snagged by something,\nalbeit rarely.  I've been snagged in the past, by IEBGENER.  At one\npoint, IEBGENER was made to do something (by default) that disturbed\nmy operation, namely, it reblocked tape files to large blocksizes\nwithout telling you it did so.  Undoing that effect in IEBGENER's\nbehavior is not so simple.  To do it system-wide, you have to set a\nkeyword in the DEVSUPxx member of PARMLIB, and IPL.  (With z/OS 1.8\nyou won't have to IPL.)  Or, in an individual run, you have to code\nsome extra parms in your IEBGENER JCL.  My simple circumvention to all\nthis, was to get an old version of IEBGENER which didn't do any\nautomatic reblocking, rename it to IEBGEOLD, and run it on a later\nversion of MVS.  That solution has (so far) worked out well for me.\n\n      But now, it seems, I might have been similarly snagged by IEBCOPY.\nI'm still (at the time of this writing) in the midst of wrestling with\nthe IEBCOPY controversy, so I can't tell you any conclusive answer about\nthat.  But I already see that I can't use the simple solution of running\na backleveled IEBCOPY load module.  IEBCOPY is so \"bound\" to other\nparameters in the system, and to system level indicators, that you can't\nrun one level of IEBCOPY anymore on a different level of MVS.  If your\nshop can afford it, it sometimes pays to buy a non-IBM utility like\nPDSFAST to substitute for IEBCOPY, just to get away from the crazy\nsystem dependencies that IEBCOPY has grown to have.\n\n\nMAKING UTILITIES (TOO) DEPENDENT ON THE SYSTEM\n\n      The basic thrust of what we're talking about today, is the\nquestion of \"how cute and fine-grained\" can you get while enhancing a\nprogram, without introducing one or more harmful errors?  Sometimes it's\nbest to keep it simple and avoid the errors.  Other times, you just have\nto introduce the extra complexity.  But there's more to this problem.\nIn certain instances, the difficulty may simply be whether the utility\nis \"IBM\" or \"not IBM\".\n\n      I think that IBM, being \"the owners of the operating system\", are\nguilty of introducing many unnecessary system dependencies into their\nutilities.  For example, IBM's DFDSS (program ADRDSSU) DASD backup and\nrestore utility, may look to see how a dataset is cataloged before\ndeciding whether or not to back it up.  FDR, a similar utility NOT\nwritten by IBM, just backs up the tracks and doesn't ask too many\nquestions.  Therefore, you can use FDR to back up and restore VM packs,\nwhich you certainly cannot do using DFDSS.  And on MVS packs too, FDR\nwill usually do a more hassle-free job of backing all the datasets up\nand getting the job done.  The non-IBM vendors, being less privy to the\nsystem's innards, can oftentimes think more clearly about the essence of\nwhat their utility is supposed to do, and they'll come up with much more\nelegant code than IBM will.\n\n      Another example of this concerns the limitation of the amount of\noutput produced by the XMIT or TRANSMIT TSO utility, which of course,\nwas written by IBM.  We discussed in a previous column (May 2006 - \"Why\nControl Blocks?\") that the XMIT command is completely dependent on\nquantities in IBM-controlled common storage, to determine its operating\ncharacteristics.  If you or I would write an equivalent to the TRANSMIT\nutility, we would most probably control its output with either a PARM\nor a SYSIN keyword that is external to the system.  But IBM, being IBM,\nsimply won't do it that way.\n\n      Still another example concerns the formatting of the TSO Broadcast\nDataset, which used to be known simply as SYS1.BRODCAST.  When you\nformat a new Broadcast Dataset, using IBM's ACCOUNT and SYNC TSO\ncommands, the number of global Notices records in the new dataset is\ndetermined by a binary quantity that has been hard-coded into an IBM\nload module.  To change this quantity (globally--it's the only way), you\nhave to zap the load module and (maybe) IPL.  At the very least, MAYBE\nyou can get away with refreshing LLA.  I wrote a utility to do this same\njob, for my forthcoming commercial Broadcast Dataset management package,\nand it is driven by a SYSIN keyword.  You have the flexibility to change\nthe number of global Notices with a SYSIN keyword, so you can do it\ndifferently each time you invoke the utility.\n\n      My question is then: \"How could IBM have designed this arrangement\nso inflexibly?\"  I think the answer is:  Because they controlled the\nsystem, and they weren't forced to think about how they could do the job\nmore flexibly to help the users.  They didn't force themselves do the\njob ELEGANTLY.  They just got it done THEIR way.  And if it wasn't a\ndesign that would allow the users to control the situation better, they\njust didn't bother.  It's similar to the situation with the old Linkage\nEditor, where for 30 years IBM never corrected the artificial limitation\nthat the Object Deck blocksize can't be bigger than 3200.  It's a simple\ncorrection, and we have zaps to do it (see CBT Tape File 257), but IBM\nthemselves didn't address the problem until they formally rewrote the\nLinkage Editor to create the BINDER.  Most of us lived with that\nlimitation for over 30 years!\n\n\nSANITY CHECKS CAN BE USEFUL TOO\n\n      One of my own programs is a good example of a large collection\nof sanity checks, introduced into old and simple code.  This is the\npractical and useful COPYMODS program (CBT Tape File 229) that was\noriginally called COPYTAPE and written by Paul Tokheim.  (He is a\ngreat grandson of the man who invented the old gasoline pumps.)  BTW,\nyou can get anything in the vast CBT Tape collection for free from the\nCBT Tape website, whose URL can be found by doing a www.google.com\nsearch on keywords \"CBT Tape\" and looking near the top of the list of\nresults.\n\n      The COPYMODS program works on a very simple principle, designed by\nTokheim.  Read a block from the tape (using EXCP) into a big buffer that\nis included in the program.  Then write out the contents of this buffer\nto one or more output tapes (Paul coded up to 10 output tapes--I\nextended that to 16.  Art Tansky, in his modification (see CBT File 229)\nextended it to 100), if you have that many drives.  If you read a tape\nmark on the input tape, then write a tape mark on all the OPEN output\ntapes.  After two consecutive tape marks, stop the action and CLOSE\nall the tapes.\n\n      This seems simple enough, but I had a big problem using COPYMODS\non Standard Labeled tapes.  Namely (think about it), if you have an SL\ntape file with no data in it (say, it was created as an IEBCOPY backup\nof a pds with no members), then after the HDR1 label there is one tape\nmark, and before the EOF1 label there is another tape mark, and there\nis no other data in between those two tape marks.  So COPYMODS action,\nseeing those two consecutive tape marks, will stop right there in the\nmiddle of the file, and will not go farther to reach the end of the\ninput tape.\n\n      To solve this, I had to \"teach\" the COPYMODS program about\nStandard Labels, and that it should not stop if it \"knew\" it was in the\nmiddle of an SL file, yet it saw two tape marks without seeing any real\ndata yet.  I eventually extended this to ASCII tapes with ASCII labels.\nWhile I was at it, I realized that I had access to all the tape data as\nit was passing by, so I could introduce more and more (optional) sanity\nchecks to read, print, measure, and limit copying of the data, if I so\nwished.  To control the many options, I wrote a \"PARM and SYSIN parser\"\nthat can read keywords to set up to 80 option bits, either singly or in\ncombination.  And what eventually happened is, that the entire program,\nalbeit being very useful, became one huge collection of sanity checks.\nCOPYMODS is now at Level 081, up from Level 002.  And this was done\nalmost purely by adding more and more sanity checks to it.\n\n\nSUMMARY\n\n      I think that the programming of utilities, whether you do it, or\nwhether a vendor does it, should adhere to the KISS (Keep It Simple,\nStupid) principle as much as possible.  Nevertheless, the program's\nrequirements and the necessity of the situation may require the addition\nof extra code here and there, so the program should work right.\n\n      IBM, in their programming of (their) utilities, often takes the\nliberty of realizing that they \"own\" the MVS operating system.  So IBM\nwill often make their utility very dependent on quantities that are\npresent in control blocks, which THEY have put into common storage.\nThis kind of programming, in my opinion, makes many of their utilities\nless useful, less flexible, and far more \"operating system dependent\"\nthan is really necessary for proper functioning.  I think that IBM would\nbe better served in the long run, if they didn't go \"hog wild\" in\nimplementing such dependencies.  They should code them only if they are\nreally essential for the proper action of the utility.  If the customers\nare really annoyed by this IBM practice, and they can afford it, I'd\neven go so far as to suggest that they selectively buy non-IBM utility\nproducts instead of IBM products.\n\n      Sanity checks, which are extra blocks of code that are introduced\ninto a program to take care of a contingency, are sometimes needed, but\nin my opionion, they should be avoided when they are not really\nnecessary.  Clean elegant code is usually the most error-free code.\nNevertheless, sanity checks, if they make the program work correctly,\ncan be a very useful solution, and if they are coded carefully enough,\nthey can even constitute useful program enhancements.\n\n      I think that even though this month's topic concerns the writing\nof code, and not all of us write code, all of us can nevertheless\nbenefit from the effort involved in cleaning and neatening up our\nthinking.  I wish all of you a happy, healthy, and prosperous month, and\nI'm looking forward to seeing you here again next time.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0704AP": {"ttr": 30470, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x06\\x01\\x07\\x07/\\x01\\x07\\x07/\\x119\\x01\\t\\x01\\t\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-03-13T00:00:00", "modifydate": "2007-03-13T11:39:06", "lines": 265, "newlines": 265, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           APRIL 2007\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.\n\n\nMVS EXPERIENCE\n\n      I figure that now is the time to talk about what is considered\n\"MVS Experience.\"  Any experience that you get, at least in the computer\nfield, usually takes the form of acquiring some familiarity with the\nenvironment, and learning HOW to do what you WANT to do.  At the very\nbeginning, it also involves learning WHAT you want to do in the first\nplace--an absorption of the aims of what we're all about, and about what\ncomputing does.\n\n      When we first break into MVS in particular, we absorb very much\ninformation about the capabilities of the MVS system and what it is used\nfor.  We learn all the ins and outs of JCL, TSO, and Operator Commands,\nwhich are the tools that everybody uses for interacting with the MVS\nsystem.  We also spend a lot of time gathering knowledge about the\nindividual components of MVS and what each of them does.  Then, we have\nto form a bigger picture in our mind about how the various components of\nMVS hang together, function in tandem, and how processes pass\ninformation and data from one part of MVS to another.  This \"bigger\npicture\" is a very important thing to acquire.  As one of my former\ncolleagues put it:  \"You aren't a real MVS systems programmer until you\nacquire the big picture about how the MVS components hang together.\"\nEveryone out there who has extensive experience, will probably agree\nwith me.\n\n      At the same time, we constantly try to set up our INDIVIDUAL\ninstances of MVS, so they can be all that they can be.  Each particular\nMVS installation has to be properly tailored for its own workload.  And\nsince MVS, and the machines which run it, cost such a large sum of\nmoney, the company pays us the big bucks (hopefully) to make MVS deliver\nall of its potential value.  As all of us know, this is not a simple\njob.  That's why we get paid for the hard-earned experience which we\nhave acquired, to help make this happen.\n\n\nTHE BASIC DESIGN OF MVS\n\n      One of the primary motivating factors in acquiring MVS experience\ncomes from the nature of MVS itself, and what IBM has tried to design\ninto it.  From the very earliest days of OS/360, this operating system\nwas designed for adding on.  Even now, after dozens upon dozens of\niterations of the operating system, thru MVT and VS1, with MVS (as VS2)\nand MVS/SE, MVS/SP1 (non-XA), MVS/SP2 (XA), MVS/SP3 thru 5 (ESA), the 10\nreleases of OS/390, and the various releases of z/OS, the basic\nstructure of the MVS operating system follows almost the same pattern as\nit did at the very beginning.  Someone who acquired extensive MVT and\nMVS experience 20 or more years ago, can still use that same experience\ntoday.  The only difference is to learn the add-ons, with a few (but\nvery few) exceptions.  (There's no SYSJOBQE anymore.)\n\n      For this reason, I have to make a statement whose truth every\nexperienced MVS systems programmer knows.  That is, if you are an\nexperienced MVS hand, with a lot of system knowledge, and you have gone\nthrough a layoff from MVS for a while, it is very easy to pick up where\nyou left off and regain your MVS expertise, to bring it up to date in a\nvery short time.  You merely have to learn the new things, and\nre-familiarize yourself with the old ones.  Almost all of the old stuff\nis still there, and very little of it goes away.\n\n      I personally have seen many examples of very good MVS sysprogs who\nwere laid off for a while, even for a period of years, and with the\nchance of a new job, they were completely caught up to speed in the\nspace of a couple of months, or even weeks.  Sometimes, an experienced\nMVS sysprog was stuck in a shop that had a back leveled version of MVS.\nWhen that same person was put in a shop which had the new stuff, he or\nshe was up to snuff in almost no time.  The basic MVS knowledge is very\nhard to acquire.  But the add-ons are usually not as difficult, and\ntheir knowledge normally comes fairly quickly, if you already know the\nbasics well.\n\n      So this gets me to describing an old gripe, which I don't think is\nquite as prevalent nowadays in the MVS world as it used to be.  It used\nto be that when a company was looking for an MVS sysprog to fill a job\nslot, they would describe the slot to their personnel department, that\nthey wanted to put in MVS release x.y (the newest one which was only out\nfor a month or two).  The personnel department interpreted that to mean\ntherefore that they needed ONLY a person with experience in installing\nJUST that release.  This request is simply not logical.  First of all,\nif the release was out for just a month, how many people would be\navailable for work at this moment in time, who have already installed\nit?  And secondly, who says that even if there does exist such a person\nwho IS available, that he or she is more valuable to the company than an\nold MVS hand with a ton of experience on slightly older MVS releases?\n\n      Here we see a piece of ignorance (usually on the part of\npersonnel, but even on the part of a manager or two), which could lead\nto a big disaster in hiring.  An experienced sysprog who knows what he\nor she is doing, is far more valuable a resource to a company, than is a\nnew person who was lucky enough to be exposed to a recent MVS release,\nrecently.  Who knows more?  The experienced one, of course.  So\ntherefore, a company could severely short change itself by blatantly\nhiring the wrong person.  This practice is only the result of extreme\nignorance, concerning what MVS knowledge is all about.  But since it has\nactually affected so many people, so often, within my memory, I feel I\nhave to mention it, because it irritates me to the point of anger.\n\n      In summary, MVS experience is built up first by learning the\nbasics, which have existed from time immemorial (that is, 1964 or\nlater), and then learning about the new features or structures which\nwere added on afterwards.  Those old hands, who had gone through all the\nchanges when they first occurred, are in the best position of\nunderstanding the total structure of MVS today.  Newer people will have\nto content themselves with trying to relive the old experiences by\ntalking with the older people, or by fishing out the old conversion\nnotebook manuals to witness (for themselves) the step by step changes\nand add-ons to MVS at each stage.  The total MVS system is a result of\nvery many add-ons.  Make no mistake about it!  You learn MVS best, once\nyou know how the basics work, and then by learning how each of the new\nfeatures was added on later.\n\n\nTSO/E\n\n      I'll try and illustrate what I've just said, by using the examples\npresented by TSO/E and ISPF.  We'll start with TSO/E.\n\n      \"Plain TSO\" is much older than TSO/E (which means \"TSO Extended\").\nPlain TSO was free with the MVS Operating System.  You had to pay extra\nfor TSO/E.  TSO/E came out in the early to mid 1980s, around the MVS/SP\n1.3 time.  (Nowadays, we take the presence of TSO/E completely for\ngranted.)  I first saw TSO/E, in our jump between MVS/SP 1.3.3 and\n1.3.5, but you have to remember that then, all the separate pieces of\nMVS were delivered as separate and interchangeable components, and\nbilled separately.  The OS/390 era of integrated testing and software\ndelivery had not yet started.  So TSO/E, which presented a large bunch\nof enhancements to \"old TSO\", could have been delivered with MVS/SP\n1.3.3 or possibly earlier.  It only depended whether you wanted to pay\nfor it, or not.\n\n      TSO/E came with an enhanced ALLOCATE command, that allowed the\nREUSE keyword.  In other words, if a DD name was already allocated and\nyou wanted to ALLOCATE it again to another dataset, you first would have\nto FREE it, and then re-ALLOCATE it.  This presented the problem in a\nCLIST, because to ALLOCATE the dataset to a DD name in a CLIST, you\nwould first have to use some \"robotic\" method of determining if the DD\nname was already allocated to some other dataset.  The REUSE keyword of\nALLOCATE eliminated that problem.  If you wanted to force a reallocation\nof the DD name no matter what was there before, you would just code the\nREUSE keyword of the (new) ALLOCATE command.  Today we take the REUSE\ncommand of ALLOCATE for granted.  In the old days, people had to write\ntheir own TSO commands to use in CLISTs, that determined whether a DD\nname was already being used, or not.\n\n      Another thing introduced by TSO/E was the altogether new TRANSMIT\nand RECEIVE TSO commands.  These were designed to send datasets between\nuserids that were attached to different MVS nodes.  The TRANSMIT (or\nXMIT) command would (under the covers) repackage the dataset as an FB-80\nbundle and then ship it across JES lines, to another connected MVS\nsystem that was defined as a node to the SNA network.  And on the other\nend, the RECEIVE command (operating under the control of a userid),\nwould unpackage the bundle and re-create a copy of the original dataset\nin the new place, at the new node.\n\n      Nowadays, we take advantage of the repackaging aspect of XMIT and\nRECEIVE in a way unforeseen by (perhaps some of) the designers.  By\nusing the OUTDSN( ) keyword of the XMIT command, instead of preparing an\nFB-80 bundle under the covers, XMIT will actually bring it out into the\nopen, as a sequential dataset.  And using the INDS( ) keyword of the\nRECEIVE command against that sequential dataset, we can re-create the\noriginal dataset on a new system, just using the dataset created by\nOUTDSN.  So as a consequence, we can use the TSO/E XMIT and RECEIVE\ncommands to transport a dataset between ANY two MVS systems, even if\nthere isn't a line which connects them, in between.  For the purpose of\nthis article, we must mention that all of this wonderful functionality\nonly came into being with TSO/E, and it was not there in \"old TSO.\"\n\n      So from the point of view of the MVS sysprog, what experience did\nwe gain from TSO/E, as opposed to \"old TSO?\"  At the time TSO/E came\nout, MVS sysprogs would read the conversion manual and try to learn the\nnew features.  They would possibly rewrite some of their CLISTs to make\nuse of the new REUSE feature of ALLOCATE.  And if they were of a\nvisionary nature, they might try to figure out how the new TRANSMIT and\nRECEIVE TSO commands would make their lives easier.  I remember how I\nused XMIT and RECEIVE to transport a copy of the TMS TMC dataset from\none datacenter to another, on a regular basis, so we could perform\nstatistical analysis using SAS, which was only licensed at one of the\ndatacenters.  Other installations might have (inventively) used TRANSMIT\nand RECEIVE for similar, but equally novel, purposes.  This illustrates\nhow an add-on feature of MVS becomes an integral part of \"MVS\nexperience.\"\n\n\nISPF\n\n      Today, we almost universally take for granted the presence of that\nfantastic file editor and utility super-package on MVS which is known as\nISPF, or ISPF/PDF.  Once upon a time, ISPF didn't even exist on MVS.  I\nremember when you had to use the line editor called EDIT, to edit a\nfile.  At that time, our installation invested some well-spent money on\nan OEM supplied vendor product called FSE (or Full Screen EDIT), which\nwas much more powerful and easy to use, than the IBM EDIT line editor\nprogram.  Most of our programmers became very proficient using FSE, and\nit was a powerful productivity tool at that time.  But FSE was\nabsolutely nothing, when compared to IBM's new ISPF.\n\n      ISPF evolved gradually, requiring its users to learn some of its\nfeatures initially, and to add on to the experiences later.  ISPF always\ncame with a full-screen tutorial.  If you took the time to read it, you\nwould learn a lot, and your productivity would profit a lot.  One of my\nfriends told me, that much of his value (to the company) came from the\nfact that he took the time to read ALL of the ISPF tutorials and to\nstudy them well.  ISPF is expanding, even today, and MVS sysprogs will\nsurely profit greatly, by reading its enhancement notices.  But I have\nto say that even if your \"ISPF experience\" is old, you still know a lot.\nThat's because ISPF, as with the other MVS components and products, was\nalways built using the same \"add-on\" concept.  The old features usually\ndo not go away.  They are only supplemented by new features.\n\n      Today's space is short, and I don't have the time to dwell on the\ngreat many particulars about how ISPF experience gets \"built up over\ntime.\"  If you see Jim Moore's columns, especially if you've followed\nthem over the years, the immense value of learning new ISPF tricks will\nbe greatly noticed.  But today I want to say that \"ISPF experience\" is\n\"MVS experience\", and so is TCP/IP experience and Unix Systems Services\nexperience.  The \"core MVS experience\" has existed for a long time.  But\nthe \"add-on\" MVS experience becomes part of the whole, and once you've\nacquired much of the core experience, most of the rest of it is the\nadd-on experience.\n\n\nSUMMARY\n\n      As is often the case, the things I've mentioned today about \"MVS\nexperience\" are things that most people already know.  But a significant\nnumber of people, the newer ones, and the ones not deeply involved in\nMVS, don't know them.  A \"gifted manager\" with different experience, who\nis forced by the upper management to head an MVS group, is often put\ninto this position, and runs afoul of his or her lack of knowledge about\nhow MVS experience works.\n\n      Therefore I feel that it is VERY IMPORTANT to point out that the\nexperience acquired in the process of maintaining MVS, is extremely\ndependent on how IBM designed MVS and its predecessors in the first\nplace.  The original (circa 1964) design of OS/360 was based on keeping\nthe core structure intact, and then adding onto it later.  That's the\nway our \"experience with MVS\" is acquired too.  If you don't know that,\nthen you don't have any \"professional direction\" in this field.  \"The\nold guys know the most.\"  That's just how it is.\n\n      Other computing systems that get completely rewritten, or which\nwere not originally designed in this way, may have other \"learning\nparameters\" and patterns.  But MVS has its own design structure, which\nwas imposed on us, for our fun and profit, by IBM.  If you don't respect\nthat and know that, then your company will suffer, and so will the\nemployees.  That's why I think it pays for me to say this.\n\n      In any case, I always wish all of you well, I hope all of you have\nmany good months and years ahead, and I'm looking forward to seeing you\nhere again, next month.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0705MY": {"ttr": 30475, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\t\\x01\\x07\\x10/\\x01\\x07\\x10/\\x10\\x18\\x01&\\x01&\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2007-04-12T00:00:00", "modifydate": "2007-04-12T10:18:09", "lines": 294, "newlines": 294, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                            MAY 2007\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.\n\n\nIF IT AIN'T BROKE, DON'T FIX IT\n\n      Everybody knows that it's often difficult to write an Assembler\nprogram of any complexity, and most of us know that it sometimes can be\neven harder to debug it.  The same holds true if you're programming in\nother languages.  Writing error-free code takes a lot of effort, and\nusually, you don't want to make that same effort twice.  So once you've\nbeen able to successfully complete a piece of error-free code, that's a\nreal accomplishment, and you'll (of course) want to save and preserve\nthe result.\n\n      This holds true for commercial vendors too.  Let me tell you an\nexample.  I once had the privilege of developing a piece of code that\n(in the wrong hands) had the potential of creating a serious security\nvulnerability in tape processing.  My own code could detect the\nsituation which I myself created, but I wasn't sure that there existed\nany commercial code which could also figure out that something was\nsuspicious (with the tape).  So in fairness to the public, I contacted a\nvendor of such software, and apprised them of my code and what it could\ndo.\n\n      Their answer was a bit of a shock to me.  They told me that the\ncode in their product was 25 years old, tried and tested by the whole\nworld, and they were afraid to mess with it, to have to deal with such a\nfar-out situation.  Also, it was designed to deal with ordinary\nsituations that occur every day, not with such a strange one.  So they\ndidn't want to do anything about the special handling of my special\ncase.\n\n      When I thought about it, I couldn't say that I blamed them.  Sure,\nmy code could do something that fooled their code.  But their code was\ncapable of doing its designed job to perfection, which was the reason\nwhy most people bought it.  And to risk that, just to cover a very\nminute possibility of potential abuse which probably no one would\nattempt anyway, was not worth the risk of breaking their tested,\ndebugged, and tried-and-true code.\n\n      IBM does the same thing.  Anybody who ever worked there (or in any\nother software company) can tell you that programmer time is a very\nprecious commodity.  You absolutely do not want to make the same effort\ntwice.  So if you've got good code, you don't change it unless you have\noutside requirements to either fix it or enhance it.\n\n      I'll tell you one more example, which has to do with IBM.  Back in\nthe MVS SP 1.3 and XA days, we used to support a system mod which would\nput I/O counts into the IEF285I messages (KEPT, DELETED, PASSED,\nCATALOGED etc.) that describe datasets used by batch job executions, TSO\nsessions, or started tasks.  This mod was very useful, because you could\nsee very graphically, if a dataset was really being used by a job, or\nnot, and HOW MUCH it was being used.  The IBM modules affected most by\nour mod, were IEFAB4B0 and IEFAB4A2 (allocation modules).  Until SMS\ndevelopment came along, and IBM started messing with allocation modules\nin a big way, these two modules were relatively stable, and for 10\nyears, IEFAB4B0 in particular, wasn't changed at all.\n\n      One time, I had to make a Level 2 call to IBM, concerning some\nother allocation modules which had problems.  The Level 2 person seemed\nvery knowledgeable with that component, so I asked her if she had ever\nheard of module IEFAB4B0.  She said she hadn't, and I told her why.  The\nmodule hadn't been changed in 10 years, and there were no problems with\nit.  So she never saw it.  It was one of those \"huge gobs\" of IBM code\nthat \"takes its licking and keeps on ticking\".  In other words, it's\ngood code that keeps working, so no one has any mind to try and change\nit unless they have to.  Therefore, even (some of) the support people\ndidn't notice that it exists.\n\n\nSTABILITY AND UPWARD COMPATIBILITY\n\n      So how does all this apply to us, the MVS systems programmers?\nWhat difference does it make?  I'd say that in general it is a very good\nthing for us, that IBM and vendor code does not change too much.  It\nmakes for stability and predictability in our working environment.  And\neven when we change operating system releases, we only concentrate on\nthe differences.  We don't have to recreate the entire environment over\nagain, because the underlying code has not changed all that much.\n\n      This is a situation which we all take for granted, and we don't\noften take the time to think about why all the changes and developments\nin the system are so gradual.  The fact is, that it is quite difficult,\nand it is usually unnecessary, to rewrite good code.\n\n      Nowadays, there is also another factor, and that is the\nincreasingly blurred distinction between hardware and software.\nSoftware functions are now being used, to emulate hardware functions.\nAnd we are increasingly making more and more use of software to do\nthings such as machine instruction emulation.  The \"software-hardware\"\nis no longer so hidden under the covers, as in IBM microcode, which is\nreally software, but it looks like hardware and we never see it.  In\neither case, once the (humanly programmed) software works correctly,\nwhether it be \"real software\" or microcode, why should we change it?\n\n      For example, you can now run MVS on a PC, because of software\nemulation.  IBM machine instructions (if we ignore the current IBM\ninstruction patent fights) can technologically be emulated on a machine\nthat is completely different from the hardware which the instructions\nwere designed for, and therefore, in a strict sense, it is software\nwhich is running the instructions, and not hardware.  These days,\nsoftware has increasingly become a replacement for hardware.  So again,\nsince this software was initially quite difficult to write (accurately)\nand required a considerable human effort to develop, once it is there,\nwe have very little temptation to rewrite it, or mess with how it works.\n\n      Further, you can see that when we write software, we also \"build\ntechnology\".  (See my February 2007 column about \"Technology Breeds\nTechnology\" for a more detailed treatment of that subject.)  This means\nthat debugged software, which performs \"necessary\" functionality that we\ncome to take for granted, becomes part of our environment.  And that\nenvironment is then used recursively, to either further extend our\nenvironment or to do our necessary work that \"keeps industry going\".  So\nonce we are using a wrench to turn bolts every day, we are not going to\ntry to break that wrench each day, and build it anew.  It would be far\ntoo disturbing for anyone to think about.\n\n      One of my dear friends who comes from a third world country,\ndescribes why the development of his country is severely and\nunnecessarily impeded.  This shows us why OUR situation is so much\nbetter, and it makes my whole point.  In his country (it is hard for us\nto fathom this), when a new president comes in, they completely drop all\nthe humanitarian development projects that were started by the previous\ngovernment.  If they feel like it, they start some entirely new and\ndifferent programs of their own.  So in effect, the good works of one\ngovernment do not last, past the duration of that government in office.\nAnd little permanent progress is made.  This situation sounds crazy and\nludicrous, but it is REAL.  IT ACTUALLY HAPPENS THERE!  When people tear\ndown what is already good, to try and build it over, or they stop a work\nthat is already in progress and nearing completion, they often are\ndestroying far more than they are building.  We have to be very grateful\nthat both system and application software is not normally dealt with, in\nsuch a way.\n\n\nGROWTH\n\n      Now we're coming to the second side of the coin.  Of course, it's\nfine and well that old code, which works, should be preserved.  But then\nthere's the second question:  \"How do we make progress?\"  And after that\nwe have to ask:  \"How do we reconcile the two concepts with each other?\"\n\n      I can supply several examples from my \"CBT Tape\" experience.\nThese will show you the basic idea I want to get across, and you can\nfigure everything else out from there.  As most of you know, the \"CBT\nTape\" collection of free MVS software, can be found at our web site by\ndoing a www.google.com search on \"CBT Tape\" and looking at or near the\ntop of the resulting list.  In the CBT Tape free collection are some\nvery amazing software programs which started relatively small, and which\ngrew both in functionality and size, quite amazingly over the years.\nThe original code in these programs was not (for the most part)\ndestroyed.  It was added to and enhanced, with dramatic results.\n\n      One of the programs I want to talk about is called REVIEW.  REVIEW\nis a TSO-based file browsing command that was written originally by Bill\nGodfrey around 1979 or so.  Bill has told me that he intended (at the\noutset) for most of his creations to be added to, eventually, by others.\nThis has happened, and his wish has been abundantly granted.  Bill's\nTSSO program (CBT Tape File 306) has been added to by Marc Schare, Dave\nCartwright, Ed Jaffe, and others, and it has grown from being a\nconsole-mode TSO substitute, to being an Automated Operations tool, and\nmuch more (CBT File 404).  Bill's REVIEW program has grown from being a\nbasic 4000-line sequential file browser program to being a 50000-line\njack-of-all-trades file looker, with an ISPF-like editor added on, an\nSMF record and LOGREC record interpreter, and many more exotic features.\nGreg Price has been responsible for most of the improvements to REVIEW,\nand he has produced most of the 46000 or so extra lines of code which\nhave been added after Bill Godfrey's initial work.  REVIEW is the only\nprogram I have, which will accurately browse the (keyed) SYS1.BRODCAST\ndataset.  ISPF Browse counts the first character (the key) with the\ndata, and drops the last character so you can't see it.  REVIEW does it\nright.  (Yes, DITTO does it too, but not as conveniently.)\n\n      Greg Price did not abandon Bill Godfrey's REVIEW code.  Instead,\nhe built on it and enhanced it, in ways not dreamed of.  Actually, Greg\nsent his (already hugely enhanced) REVIEW program into the CBT Tape\ncollection (to Arnie Casinghino) in 1989, 10 years after it was\noriginally written.  I myself, had been tempted to start enhancing\nREVIEW before then, but once I saw what Greg had done, I realized that I\ncould never equal his accomplishment.  And Greg has still been working\non REVIEW ever since then.  REVIEW can look at VSAM files and HFS files\nand all kinds of other \"MVS things\".  Source code is on CBT Tape File\n134, and load modules are on File 135.  Bill Godfrey had also originally\nwritten a full screen TSO HELP program, called HEL, to look at SYSHELP\nfiles in full screen, based on the REVIEW code, and Greg Price merged\nthe HEL code into the REVIEW code so they both could be enhanced\ntogether as one program.  HEL is now an ALIAS of REVIEW, and it is an\nenormous aid in reading a long TSO HELP file.  HEL (instead of TSO HELP)\nallows you to scroll up and down the file, which regular TSO HELP (being\na line-mode command) does not.\n\n      My point is that Greg Price did not destroy Bill Godfrey's tried\nand tested code in REVIEW.  Instead, he enhanced it and built on top of\nit, so that the \"basic engine\" of Bill Godfrey's could be made to do\nmore.  When IBM enhances a product, they tend to do the same thing.  I\noften look at old IBM source code for TSO modules, and I compare it to\nthe current code (OCO of course) for the same modules.  I usually find\nthat the original principles and coding have not been changed.  They\nhave only been adjusted a bit for modern times, and tweaked.\n\n      One more enormously improved utility package that must be\nmentioned here, is the \"PDS Utility Package\" which I have used, even\nback in the MVT days.  \"PDS\" was originally writted at Firemen's Fund to\nlook at a partitioned dataset and perform a limited number of functions.\nSee Figure 1 to see the original list of its options.\n\n      The modern \"PDS package\", versioned PDS 8.6, is still free, being\nmaintained by John Kalinich, and you can find it (together with the\noriginal version) on CBT File 182.  There is also a commercial product\ncalled \"Startool FDM\", now owned and marketed by Serena, which is an\noutgrowth of the original \"PDS\" product as well.  Both of these products\nhave thousands of separate functions built into them.\n\n      How did this happen?  It came from an idea by Bruce Leland, who\ntried to add functionality to the original PDS code.  Bruce told me that\nhe spent a year studying the PDS source, until he understood it well\nenough that he felt he could make meaningful changes.  But once Bruce\nmade changes (without destroying the original engines, of course), they\nstarted to come by the dozens.  Bruce was soon joined by Steve Smith,\nwho made an ISPF interface for the product (which still works both in\nISPF mode and in TSO line mode).  When Bruce was offered the opportunity\n(by Serena) to extend \"PDS\" into a commercial product, Steve Smith\njoined him, and together, they enhanced the package for over 10 years.\nWhen Y2K threatened its big ugly head meanwhile, John Kalinich picked up\nthe free version (which hadn't been changed since 1989), and John has\nbeen adding more features to the public version ever since.  You see\nfrom this that enormous enhancements can be put into a product without\ndestroying its original mechanisms.  If it ain't broke, you (usually)\nshouldn't try to fix it!\n\n\nSUMMARY\n\n      Debugged code which works, is hard to duplicate.  The effort that\nwould be spent in rewriting perfectly good code from scratch, is usually\nwasted effort.  Therefore, most good code gets saved and reused.  This\nis generally a happy thing for us, because the MVS operating system,\nbeing largely based on old code which always has worked, doesn't change\ntoo fast, and we can use most of our old experience, in our job of\nmaintaining it.\n\n      When enhancements ARE made to old code, they usually do not\ndestroy the basic \"engines\" which were put there by the efforts of the\noriginal coders.  If these engines do their work well, it pays to\npreserve them.  If they do not, then we are forced to rewrite them, but\nONLY then.  We can always try to alter these \"facts of life\" and rewrite\nexisting functionality anew, but I think that we need a good reason to\ndo so.  Learning new techniques, in my opinion, counts as a \"good\nreason\".  So does \"machine inefficiency\", if it applies to a particular\ncase.  In general, though, it pays to build new technology on top of\nexisting good technology.  If it ain't broke, then don't fix it.\n\n      I hope you have profited from this month's piece.  At least I hope\nthat it has made you think a bit.  Please come and visit this column\nagain next month.  I'll be looking forward to seeing you.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.  Options available with the original\n           PDS program to manipulate pds members.\n           This is from before Bruce Leland and\n           Steve Smith (and John Kalinich) got a\n           hold of the program.  After the PDS\n           command is pointed at a dataset, you\n           have the following choices:\n\n    THE FOLLOWING OPTIONS ARE AVAILABLE:\n    DISPLAY -   DISPLAY DIRECTORY\n    RENAME  -   RENAME A MEMBER\n    SCRATCH -   SCRATCH A MEMBER\n    ALIAS   -   ASSIGN AN ALIAS TO A MEMBER\n    ATTR    -   LIST LOAD MODULE ATTRIBUTES\n    MAP     -   MAP STRUCTURE OF LOAD MODULE\n    HISTORY -   LIST HISTORY OF LOAD MODULE\n    LIST    -   LIST CONTENTS OF A MEMBER\n    USAGE   -   LIST DIRECTORY STATISTICS\n    CHANGE  -   SELECT A NEW DATA SET\n    OPTIONS -   DISPLAY THIS MENU\n    HELP    -   DISPLAY HELP TEXT\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0706JN": {"ttr": 30726, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00D\\x01\\x07\\x14\\x0f\\x01\\x07\\x14/\\x18C\\x01\\x18\\x01\\x18\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2007-05-20T00:00:00", "modifydate": "2007-05-22T18:43:44", "lines": 280, "newlines": 280, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           JUNE 2007\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.\n\n\nTHE STRUCTURE OF THE BROADCAST DATASET - PART 1\n\n      TSO has been around, on OS/360 (circa late-1960s) and on later MVT\nand MVS systems, for many years.  Being the \"terminal access\" mechanism\nfor the Operating System, and being \"User and Userid oriented\", TSO (in\nMVS) has always had a messaging system, so that one user could send\nmessages to another user.  An essential part of this messaging system is\na dataset which holds the messages, if they can't be sent to the\nrecipient user right away.  This happens if (for example) that user is\nnot currently logged on.  This dataset, which used to be called\nSYS1.BRODCAST exclusively, is an essential part of all MVS systems, and\ntherefore, it pays for us to know something about it.\n\n      TSO itself provides two commands for sending and receiving\nmessages.  The TSO SEND command is used to send a message from one user\nto another user, or to a system console.  As far as receiving messages\ngoes, if the user is currently logged on, as soon as a terminal\ninterrupt occurs, any outstanding messages will appear on the TSO\nterminal.  But if the issuer of the SEND command used the SAVE option,\nthen the sent message is saved in the SYS1.BRODCAST dataset and is not\nforwarded to the recipient user now.  Any messages that were stored in\nthe SYS1.BRODCAST dataset (more properly nowadays to be called the\n\"Broadcast Dataset\") are displayed, and deleted, by the TSO LISTBC\ncommand, which can be issued at any time by the user, or it is\nautomatically issued on behalf of every user at LOGON time.  That's why,\nwhen you LOGON to TSO, you always see your messages.  It is the LISTBC\ncommand which displays (and deletes) them for you.\n\n      How does LISTBC (which is a general system command) \"know\" which\nuser has issued it, so it can display (and delete) the appropriate\nmessages which are being saved for that user?  The answer is that LISTBC\ninterrogates a field in a control block, the PSCBUSER field in the PSCB\ncontrol block, and whichever userid name appears there, that's the one\nwhich LISTBC will use, to go out to the Broadcast Dataset (or the TSO\nUserlog if it exists) and retrieve its messages.  Usually the Userid\nname in the PSCBUSER control block belongs to the real TSO Userid, but\nif you \"play games\" and put another id in there, LISTBC won't know the\ndifference.  Of course, you need to create an APF authorized program to\ndo that, and I don't recommend potentially violating the system\nintegrity.  But I can testify that this is what happens, that I've\nactually written such a program, and that it is publicly available if\nyou really want to see it.\n\n      So much said, by way of introduction.  Now we can get to the nitty\ngritty of the internal structure of the Broadcast Dataset, where the\nmessages are stored.\n\n\nPARTS OF THE BROADCAST DATASET\n\n      The Broadcast Dataset is a Direct Access (DSORG=DA) dataset, and\nany of its \"parts\" can be anywhere in the dataset, except for the first\nrecord, or the \"Header Record\", which must be at the beginning.  The\nHeader Record tells you where all the other parts of the Broadcast\nDataset are.\n\n      More specifically, the Broadcast Dataset is \"keyed\", with a 1-byte\nkey at the beginning of each record.  And it is fixed, unblocked.  That\nis, RECFM=F, KEYLEN=1.  The record length, besides the key, is 129\nbytes.  Therefore, for each record in the Broadcast Dataset, there are\n130 bytes.  One byte is for the key, and 129 bytes are for the data.\nTherefore, LRECL=129.\n\n      Keyed datasets are difficult to Browse, using ISPF.  Since there\nare 130 bytes of information in each record, but the LRECL is only 129,\nISPF Browse only looks at the first 129 bytes of data in each record,\nand drops the last character, which unfortunately contains very useful\ninformation.  To correctly look at a Broadcast Dataset, and to see all\nof its data, use MVS Ditto, or (more conveniently) the free REVIEW TSO\ncommand, which can be found in the free CBT Tape collection of MVS\nUtilities, on File 134 (source) and File 135 (load modules).  REVIEW\nwill nicely display, in EBCDIC or in Hex, each record of the Broadcast\nDataset accurately, and REVIEW is the tool I always use.  (The CBT Tape\ncollection is on the Internet.  It is free, and you don't need a\npassword to look at, or download, anything.  To get its URL, just do a\nwww.google.com search on \"CBT Tape\" and the correct URL should come out\nat, or near the top of the search.)\n\n      Each \"type of record\" in the Broadcast Dataset is defined by the\nvalue in the \"key\" field.  There are seven different types of record in\nthe Broadcast Dataset, and therefore there are seven different key\nvalues.  See Figure 1 for a table of the key values in the Broadcast\nDataset, and the type of record that each key is used to define.  The\nappropriate system macro which describes each type of Broadcast Dataset\nrecord, is listed there too.  These macros are now in SYS1.MACLIB, but\nthey used to be available only on the \"Optional Materials\" tapes for\nMVS.  Being now in SYS1.MACLIB, they are much easier to find and use.\n\n      Basically, three types of things are stored in the Broadcast\nDataset, and these are covered by most of the record types.  They are,\nfirst:  Global Notices, which LISTBC displays to all TSO users when they\nissue a LISTBC command or when they LOGON.  Global Notices are handled\nby two record types:  X'00' which are Global Notices Directory Records,\nand X'02', which are the Global Notice messages themselves.\n\n      Userids, which are defined for each user name who is allowed to\nstore User Messages in the Broadcast Dataset, are stored in the type\nX'01' Userid Records.  Each X'01' Userid Record can store up to nine\nUserids.  These are the second type of thing stored in the Broadcast\nDataset.  The third thing is the User Messages which are the individual\nmessages intended for each user.  Each User's Messages are chained off\nits Userid Record, and if there is more than one message for a user, all\nthose messages are chained to each other.  Record types which handle\nUser Messages are: X'03' for a User Message Record, and X'FF' for a Free\nRecord which is eligible to be occupied by a new User Message.\n\n      These three types of stored things cover five record types.  The\nother two record types are type X'04' which is the Broadcast Dataset\nHeader Record, and the type X'05' which is called the Free Search\nRecord.  The Free Search Record, which was added later for efficiency,\nusually points to the Relative Block Location (the three-byte RBA) of\nthe first Free Message Record in the Broadcast Dataset.  That covers all\nthe record types in the Broadcast Dataset.  If you know about them, then\nyou know most of what you have to know.\n\n\nENQUEUES ON THE BROADCAST DATASET\n\n      It's obvious that if one user is busily in the process of issuing\na SEND command to save a message in the Broadcast Dataset, you don't\nwant another user to be doing something similar at the same time.  Or\nyou don't want to SEND a message to a user at the exact same time that\nthe user is issuing a LISTBC command to display and delete his (or her)\nmessages.  To prevent interference between what more than one user (plus\nthe system itself) are doing at the same time, the wise TSO developers\nhave installed ENQUEUE protection.\n\n      ENQUEUE protection works with 4 values.  If an address space is\nthe \"holder\" of the enqueue, and has registered the 4 values with the\nsystem, then any other address space attempting to obtain the same\n4-values in its own enqueue, will be stopped, until the first address\nspace lets the enqueue go, by issuing a DEQUEUE on this enqueue.\nThere's a little more to it.\n\n      There are \"exclusive\" enqueues and \"shared\" enqueues.  Exclusive\nenqueues work as described above; they stop another address space which\nis attempting to acquire the same enqueue, whether it be exclusive or\nshared.  But there can be many holders of the same SHARED enqueue.  What\na SHARED enqueue does, is to stop a new address space from obtaining the\nsame 4-valued enqueue as an EXCLUSIVE enqueue.  In other words, if a\nSHARED enqueue is in effect, and is held by one or more address spaces,\nthen no other address space can obtain an EXCLUSIVE enqueue on the same\nresource until all the SHARED enqueues have been let go.\n\n      What are the 4 values which constitute an enqueue?  The first two\nare called the Q-name and the R-name, and they are two quite arbitrary\nvalues.  IBM convention for enqueue assignment of Q-names is usually,\nthat one component or resource-type will use the same Q-name always, or\nit will use just a minimally few different ones.  For example, dataset\nprotection uses a Q-name of SYSDSN, and an R-name of the actual dataset\nname.\n\n      The third value is whether the enqueue is EXCLUSIVE or SHARED.\nAnd finally, the fourth value is the SCOPE, which tells you how widely\nthis enqueue is to be distributed.  The possible values of the SCOPE are\n\"STEP\", \"SYSTEM\", or \"SYSTEMS\".  If two enqueues have identical Q-name,\nR-name, and exclusivity, but they have a different SCOPE, they are\nregarded as different enqueues, and the presence of one, will not stop\nthe address space which holds the other.  So now you've seen the four\nparts of an enqueue.  In an Assembler program, enqueues are issued by\nthe ENQ macro (found in SYS1.MACLIB) and they are destroyed by the DEQ\nmacro (also found there).\n\n      IBM convention for Broadcast Dataset enqueues is to use a Q-name\nof SYSIKJBC, and the R-name is the hex value of the 3-byte Relative\nRecord Address (the RBA) of the particular Broadcast Dataset record\nwhich is being enqueued upon.  For example, an enqueue on the Broadcast\nHeader Record, which always has an RBA of X'000000', will have a Q-name\nof SYSIKJBC, an R-name of X'000000' and a scope of \"SYSTEM\".  The reason\nwhy IBM uses a scope of SYSTEM, is that there is usually a separate\nBroadcast Dataset defined for each LPAR or MVS instance.  So logically,\nand actually, the scope of the Broadcast Dataset should not go beyond\nthe particular MVS instance which it is running on.\n\n      So how is the enqueue on a Broadcast Dataset used?  When LISTBC\nis trying to display and delete all messages belonging to a particular\nuser, it enqueues on the Broadcast Header record, and on the particular\nUserid record (that is, the R-name on the ENQ is the RBA of the Userid\nRecord) containing that Userid.  It makes sense that as a particular\nUser Message record is being deleted, there should be a quick ENQ and\nDEQ on that record, so it should not be modified by somebody else.  And\nalso, the Free Search Record is quickly enqueued and dequeued upon, as\nit is being modified after the User message deletions have been\nperformed.\n\n      Anybody who writes his (or her) own Broadcast Dataset management\npackage (I have written two of them), must take these enqueues into\naccount, whenever a program in his package is modifying an active\nBroadcast Dataset.  Since anybody at any time, might be issuing a SEND\nor a LISTBC command against the active Broadcast Dataset too, your\npackage has to temporarily stop them, by issuing the same enqueues as\nthey do, whenever it modifies the active Broadcast Dataset.\n\n\nWHICH IS THE ACTIVE BROADCAST DATASET?\n\n      Ever since TSO/E Release 3 came out (with z/OS 1.3), it is\npossible for a Broadcast Dataset to have a name other than SYS1.BRODCAST\nwhich is cataloged in the Master Catalog.  Now, you can have a\nfunctioning active Broadcast Dataset, with any name, and which does not\nhave to be cataloged.  The name, and volume, of the active Broadcast\nDataset is determined by the active IKJTSOxx member in PARMLIB.  (See\nthe z/OS MVS Initialization and Tuning Reference manual for coding\ndetails in the IKJTSOxx member of PARMLIB.)\n\n      At IPL time, the system looks in the IEASYSnn member of PARMLIB\nfirst, to determine which initial IKJTSOxx member to use.  And this will\nactivate the INITIAL copy of the Broadcast Dataset.  (If a different\nname isn't coded, the default is still SYS1.BRODCAST as cataloged in the\nMaster Catalog.)  But after the IPL, the Broadcast Dataset can be\nswitched at any time, by using either the PARMLIB UPDATE(xx) TSO\ncommand, or the console SET IKJTSO=xx operator command.  The effect of\neither of the latter two commands is to change which IKJTSOxx member in\nPARMLIB is currently the active one.\n\n      How do you (yourself, as the sysprog) determine which is the\nactive copy of the Broadcast Dataset that the system is currently using?\nThe active Broadcast Dataset may be found by running a set of control\nblock pointers, starting from the CVT, the TSVT (TSO Vector Table), the\nTPVT (TSO Private Vector Table) and the EESCB.  I have written a TSO\ncommand which does this, and which displays all the relevant results\nusing the TSO PUTLINE interface, on the TSO tube.  This public domain\ncommand is called \"EESCB\", and it may be obtained from the CBT Tape\ncollection on File 731.  So instead of running the control block chain\nyourself, you can install this EESCB command, and get all the\nappropriate information for yourself very easily.\n\n\nENOUGH FOR NOW\n\n      I'm running out of space this month, so I'll continue, hopefully,\nnext time.  We've explained a lot of the overall facts about the\nBroadcast Dataset this month, and next time, I hope to get into more of\nthe specifics about how User Messages are written and deleted, how\nUserids are written and deleted, and about how Global Notices are\nwritten and deleted.\n\n      So I'm hoping to see you again soon, and I wish all of you the\nbest of everything!\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFigure 1.   Types of Broadcast Dataset Records, as defined\n            by their key.\n\n\n    Key Value         Type of Record Defined              Macro\n    --- -----         ---- -- ------ -------              -----\n\n     X'04'            Broadcast Header Record             IKJZT301\n     X'00'            Global Notify Directory Record      IKJZT302\n     X'02'            Global Notice Record                IKJZT303\n     X'05'            Free Search Record                  IKJZT306\n     X'01'            Userid Record                       IKJZT304\n     X'03'            User Message Record (occupied)      IKJZT305\n     X'FF'            Free Message Record                 No Macro\n\n   The X'FF' record has to have its relative position (on the\n   track), in other words, the \"R\" of its CCHHR or TTR, as its\n   first data byte, otherwise the Broadcast Dataset is considered\n   \"corrupted\" by the system, and it will not function.  This is\n   why IBM says that you can't copy a Broadcast Dataset from one\n   device type to another.  The X'FF' records will come out on\n   the wrong places in the track, if you do a dataset copy of the\n   Broadcast Dataset using IBM tools.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0707JL": {"ttr": 30731, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00R\\x01\\x07\\x16\\x8f\\x01\\x07\\x16\\x8f\\x08P\\x01\\x1d\\x01\\x1d\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-06-17T00:00:00", "modifydate": "2007-06-17T08:50:52", "lines": 285, "newlines": 285, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           JULY 2007\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.\n\n\nTHE STRUCTURE OF THE BROADCAST DATASET - PART 2\n\n      Last month, we talked about the basic structure, and some of the\ngeneral details, of the TSO Broadcast Dataset, which used to exclusively\nbe called SYS1.BRODCAST.  The Broadcast Dataset is part of the\n\"messaging facility\" which belongs to TSO under MVS, and it has been\naround (as SYS1.BRODCAST) since the MVT times, long before MVS was given\nits name.\n\n      As we mentioned last month, messages are sent under TSO using the\nTSO SEND command.  And if the messages were not received immediately by\nthe intended receiving Userid, they are displayed for that Userid by the\nLISTBC TSO command when it is issued, being deleted from the Broadcast\nDataset afterward.  Later versions of TSO/E allow for individual TSO\nUserlogs to be created, to store these messages, provided that Userlogs\nare specified in the active IKJTSOxx member of Parmlib, and that the\nindividual user actually creates his or her Userlog the first time.\n\n      A TSO user can issue the LISTBC command at any time, or it is\nautomatically issued on behalf of every user at LOGON time.  LISTBC,\nbesides displaying the Global Notification messages that are in the\nBroadcast Dataset for everyone to see, also displays each user's stored\nUserid Messages.  But the stored Userid messages, particular for that\nuser only, are then deleted by LISTBC.\n\n      Global Notification messages, which are displayed by LISTBC for\nevery TSO user, remain on the Broadcast Dataset until they are changed\nby a SEND subcommand of the OPER TSO command.  Actually, when LISTBC\ndisplays the Global Notification messages, LISTBC does not access the\nBroadcast Dataset itself, but it reads an incore copy of the Notices\nmessages.  This is so that if a few hundred TSO users LOGON, say at\n9:00 in the morning, all at once, there won't be an enqueue bottleneck\non the Broadcast Dataset.\n\n      What event will trigger a change to the incore copy of the Global\nNotices?  It is the setting of a bit, the TSVTCNVU bit in the TSO Vector\nTable which is chained off the CVT, and mapped by the IKJTSVT macro that\nis in SYS1.MACLIB.  Issuing an OPER SEND command, will both set this\nbit, and will read this bit, to trigger a rereading of the Broadcast\nDataset, to update the Incore Global Notices Table.  After TSO/E Release\n3, which came out with z/OS 1.3, the LISTBC command itself, will read\nthe TSVTCNVU bit, and it will update the Incore Table and turn the bit\noff.  Therefore, after TSO/E Release 3, if you set this bit on, the\nfirst person who logs on, and in the process, invokes the LISTBC\ncommand, will cause the update of the Incore Global Notices Table to\ntake place.\n\n\nTHE PIECES OF THE BROADCAST DATASET\n\n      Now it's time to get to the nitty gritty details of the Broadcast\nDataset, that I promised to talk about last time.\n\n      Physically, the Broadcast Dataset is a keyed UNBLOCKED dataset\n(RECFM=F, KEYLEN=1) with 129 data bytes, so the LRECL=129.  The type of\nrecord in the Broadcast Dataset is described by the value in the\none-byte key.  See Figure 1, which describes all the possible record\ntypes in the Broadcast Dataset, and which also shows the macros in\nSYS1.MACLIB which document the format of each type of record.  I use the\nfree REVIEW TSO command to look at a Broadcast Dataset, because REVIEW\nwill show all the key and data bytes correctly.  ISPF Browse will drop\nthe last data byte off, which causes you to \"not see\" very valuable data\nat the end of the record.  You can get the REVIEW program from File 134\n(source) and File 135 (load modules) on the CBT Tape website.  To get\nthe website's URL, do a www.google.com search for \"CBT Tape\".\n\n      There are three \"logical pieces\" of the Broadcast Dataset, which\ncan conceptually be pictured as being completely separate from each\nother.  These are:  the Global Notification Messages, the Userids, and\nthe User Messages.  Each of these pieces must be considered separately,\nalthough the User Messages have to be attached to Userids.  So therefore\nthe Userids need to come first, before any User Messages can be created\nand stored.\n\n      A new Broadcast Dataset is formatted (after its space is\nallocated) by IBM's SYNC subcommand of the ACCOUNT TSO command.  The\nSYNC subcommand creates an empty Broadcast Dataset, but it fills the\nUserid section with TSO Userids from both the SYS1.UADS dataset, and the\nRACF Database.  Of course, the SYNC subcommand, created by IBM, will not\nattempt to read the databases of the other MVS security products, such\nas ACF2 and Top Secret, which are proprietary CA products.  So\ninstallations which have ACF2 or Top Secret have to do their own Userid\nsynchronization procedures which read the respective security databases\nand extract TSO-connected Userid names.  Once the Userid names are\nextracted, however, they are loaded into the Broadcast Dataset by the\nrespective security products in a completely standard way.\n\n      We will now talk about the three separate logical components of\nthe Broadcast Dataset, starting with the Userids, and then discussing\nthe User Messages (which are related to the Userids) and finally the\nGlobal Notices Message system.\n\n\nTHE USERID DESCRIPTORS\n\n      You can't get anywhere in the Broadcast Dataset without reading\nthe Header Record first, indicated by X'04' in its key byte.  The Header\nRecord (always Relative Record Address X'000000') points to the\nthree-byte Relative Record address of the first Userid Record, and it is\nfrom there, that we start our search to see whether a particular Userid\nis defined in the Broadcast Dataset.  To be exact, the pointer to the\nfirst Userid Record is described by field R1USPTR of macro IKJZT301 in\nSYS1.MACLIB.\n\n      Once you've gotten to the first Userid record and you READ it,\nyou'll notice that the last three bytes of it point to the next Userid\nrecord, and so forth, until we come to the last Userid record, which\npoints to X'000000' which means to nowhere.  Once we come to the last\nUserid record, it is considered that we have read all of them.  A Userid\nrecord in the Broadcast Dataset is indicated by an X'01' in the one-byte\nkey field.\n\n      Each Userid record has room for nine Userid descriptors, each of\nwhich defines one Userid to the Broadcast Dataset.  The reason for 9, is\nbecause each Userid descriptor takes up 13 bytes--7 bytes for the Userid\nitself, and 6 bytes for two 3-byte RBA (relative record) locations.\nNine 13-byte descriptors will fit into the 125 usable bytes of a Userid\nrecord.  The 6 extra bytes which contain the two 3-byte RBA's, are the\nRelative Record locations of the first User Message and the last User\nMessage attached to this Userid.  In between, all the User messages are\nchained to each other, by an RBA number in the last 3 bytes of each\nmessage, which points to the location of the next message.  In other\nwords, the first message for a Userid is pointed to by the first RBA in\nthe Userid record.  After that, this Userid's messages are all chained\nto each other.  And the last User Message contains an X'000000' in\nits last three bytes, showing that it is the last message attached to\nthis Userid.  Redundantly, the RBA location of this last User message is\nrepeated in the second RBA of the Userid descriptor.\n\n      Any of you who is Mathematically inclined (and most of you who are\nnot) can see that to determine the location of the last message attached\nto a Userid, you need only follow the chain through all the messages,\nstarting from the RBA of the first User message attached to this id.\nWhy do we need the RBA of the last message, to be also stored in the\nsecond RBA location in the Userid descriptor?  The answer is for\nefficiency.  It is for the SEND command.  The RBA of the last message is\nprovided directly, so that when you SEND a new message to a Userid, you\nwon't have to chain through all the existing messages first, to see\nwhere the last message is.  There might be thousands of other messages\nalready there for a particular Userid, and this situation happens often.\nSo you want to find the last message's location easily.\n\n      Back in the old MVT days, a Userid record actually contained only\n10 bytes instead of 13, and this was because only the starting RBA for\nthe first User Message was provided.  But in MVS, the RBA of the last\nmessage was inserted into the Userid descriptor for efficiency.  Since\nthere are 125 usable bytes in an actual Userid Record, nine 13-byte\nUserid descriptors can fit in.  Back in the old MVT days, when the\nUserid descriptors were only 10 bytes long, 12 Userids could fit into a\nUserid record.  So the MVS Broadcast Dataset format for Userid\ndescriptors has always been the same, but if you go back to an MVT\nsystem, which you can run nowadays under Hercules on a PC, there were 12\nUserid descriptors in a Userid Record instead of 9.\n\n\nUSERID MESSAGES THEMSELVES, AND EMPTY RECORDS\n\n      A User Message record in the Broadcast Dataset is described by a\nX'03' in the key field.  The first data byte, after the key byte,\ncontains the binary length of the actual message, and the message itself\nfollows afterwards, starting from byte two of the data in the record.\nThis is very simple to understand.  A User Message can therefore be up\nto 125 bytes long.  3-bytes at the end are necessary to chain to the\nnext message, and the actual message starts from byte 2 of the data.  So\n125 bytes are left.\n\n      An empty record, described by an X'FF' in the key field, is a bit\nmore complicated.  Empty records are usually used to contain a User\nMessage later, but an empty record can also (potentially) be converted\ninto an extra Userid Record, if you want to define more Userids to the\nBroadcast Dataset, and there's no room for them in the existing Userid\nRecords that are already there.  So then, an X'FF' record gets converted\ninto an X'01' (Userid) record instead of an X'03' (User Message) record.\n\n      There's something very particular about the X'FF' records.  If you\ndon't understand this, you can cause a great deal of trouble.  Here's\nthe deal.  In order for an X'FF' record to be valid, it has to contain\nthe binary value of its record location on the track, the \"R\" of the\nCCHHR or TTR value describing the location of the record, in the first\ndata byte location of the record itself.  In other words, you can't move\nan X'FF' record to a different location of the track.  That is why IBM\nsays that you can't use conventional means, to copy a Broadcast Dataset\nfrom one device type (like a 3390) to another device type (like a 3380).\nIt will come out, that the X'FF' records will have their first data\nbytes NOT pointing to their correct location on the track, since on a\n3380 (for example), 53 Broadcast Dataset records will fit on a track,\nbut on a 3390, only 50 records will fit on a track.  So the \"R\" numbers\non a 3380 will go from X'01' to X'35', but on a 3390, the \"R\" numbers\nwill go only from X'01' to X'32'.  And if the first data byte of an\nX'FF' record is wrong, the Broadcast Dataset is considered corrupted.\nIt will definitely not work correctly.\n\n      So any means of copying a Broadcast Dataset will have to take into\naccount the absolute value of the track locations for all the X'FF'\nrecords.  Sorry about that.  I'll talk more about it next month.\n\n\nTHE GLOBAL NOTIFICATION MESSAGING SYSTEM\n\n      From the purely Broadcast Dataset point of view (excluding\nconsideration of the Incore Notices Table), Global Notices are\ncontrolled by two types of records:  the X'00' Global Notices Directory\nrecords which each contain 25 5-byte entries, and the X'02' Global\nMessage records themselves, which contain the messages.\n\n      The X'00' Directory records are described by the IKJZT302 macro in\nSYS1.MACLIB.  Each 5-byte directory entry points to a sequentially\nnumbered Notices Message record.  The first two bytes in binary, tell\nyou what the message number is, and the next 3 bytes provide the actual\nmessage's RBA location.  A Notices Message (as described by its\ndirectory entry) is considered ACTIVE, if its high-order bit, X'80' of\nthe first byte of the five, is OFF.  Otherwise, if the X'80' bit of the\ndirectory entry is ON, the Notices message is considered INACTIVE, and\nwhatever information is in it, will not be displayed.  All the X'00'\nrecords are chained to each other, similarly to the way the Userid\nRecords are chained to each other.\n\n      The X'02' Notice records, which contain the actual Notice\nmessages, are very simple.  The first byte of the data portion, contains\nthe length of the message.  And the rest of the record contains the\nmessage itself.  No indication is present in the Notices Message itself,\nas to whether that message is ACTIVE or not.  It all depends on the\nX'80' byte in the 5-byte directory entry for that Notice Number, which\npoints to that Notice.  If the X'80' bit is OFF, then the corresponding\nNotice message is ACTIVE, otherwise that Notice message is INACTIVE, and\nit will not be displayed, no matter what data the X'02' record actually\ncontains.  This concludes our discussion of the Global Notices record\nsystem, for now.\n\n      One more record, the X'05' or Free Search Record, needs to be\ndescribed.  This record contains one RBA, which usually is the location\nof the first free record or X'FF' record, currently in the Broadcast\nDataset.  The Free Search Record is for efficiency, to make it easier to\nfind the next free (X'FF') record in the Broadcast Dataset, if it is\nneeded for the writing of a new User Message or for the creating of a\nnew Userid Directory Record.  The X'FF' record is updated whenever\nmessages are sent to, or deleted from, the Broadcast Dataset.\n\n      So for now, we have shown you how the Broadcast Dataset record\ntypes work.  Next month, we'll (hopefully) show you some tools, to make\nyour life easier, in administering the Broadcast Dataset yourself.   I\nwish all of you the best of everything, and I hope to see you here again,\nnext month.\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFigure 1.   Types of Broadcast Dataset Records, as defined\n            by their key.\n\n\n    Key Value         Type of Record Defined              Macro\n    --- -----         ---- -- ------ -------              -----\n\n     X'04'            Broadcast Header Record             IKJZT301\n     X'00'            Global Notify Directory Record      IKJZT302\n     X'02'            Global Notice Record                IKJZT303\n     X'05'            Free Search Record                  IKJZT306\n     X'01'            Userid Record                       IKJZT304\n     X'03'            User Message Record (occupied)      IKJZT305\n     X'FF'            Free Message Record                 No Macro\n\n   The X'FF' record has to have its relative position (on the\n   track), in other words, the \"R\" of its CCHHR or TTR, as its\n   first data byte, otherwise the Broadcast Dataset is considered\n   \"corrupted\" by the system, and it will not function.  This is\n   why IBM says that you can't copy a Broadcast Dataset from one\n   device type to another.  The X'FF' records will come out on\n   the wrong places in the track, if you do a dataset copy of the\n   Broadcast Dataset using IBM tools.\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0708AU": {"ttr": 30982, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00&\\x01\\x07!?\\x01\\x07!?\\x11\\x15\\x01\\x8b\\x01\\x8b\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2007-08-01T00:00:00", "modifydate": "2007-08-01T11:15:26", "lines": 395, "newlines": 395, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          AUGUST 2007\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.\n\n\nTHE STRUCTURE OF THE BROADCAST DATASET - PART 3\n\n      Last month, we talked about many of the details concerning the\ninternal structure of the TSO Broadcast Dataset, which used to be known\nexclusively as SYS1.BRODCAST.  In former times (at the z/OS 1.2 Release\nlevel and before, you had to have a dataset (of the proper format)\ncalled SYS1.BRODCAST, cataloged in the master catalog, in order to even\nIPL MVS, and certainly, SYS1.BRODCAST had to be present, to enable the\nTSO/E messaging facility.  After TSO/E Release 3 came out, with z/OS\n1.3, it became possible to name the TSO/E Broadcast Dataset with any\nname, and it even could be uncataloged, with its volume serial\nspecified.  So now it is possible to talk about multiple copies of the\nTSO/E Broadcast Dataset, and we have a need to determine which copy is\nthe active copy, and which copies are not.  The active copy of the TSO/E\nBroadcast Dataset is determined by a PARMLIB member named IKJTSOxx.\n\n      Since the active copy of the TSO/E Broadcast Dataset is determined\nby a PARMLIB member, we must mention that from z/OS 1.3 and afterwards,\nit is possible to switch the active Broadcast Dataset, by means of names\nsupplied in another PARMLIB member.  Let's show how.\n\n      At IPL time, if the IEASYSxx member points to an IKJTSOxx member\nof PARMLIB, then the IKJTSOxx member with the proper suffix is honored.\nIf a name other than SYS1.BRODCAST is mentioned by the BROADCAST\n(DATASET(data-set-name) VOLUME(volume-name)) subparameters of the SEND\nparameter in the IKJTSOxx member, then that name and volser are honored.\nBut after IPL also, there are two means of switching the active IKJTSOxx\nPARMLIB member, to include a possible change in Broadcast Dataset name\nor location.  These are:  The PARMLIB UPDATE(xx) TSO command, and the\nSET IKJTSO=xx console operator command.  Both of these commands have the\nsame net effect, that of changing the TSO/E internal control blocks\naccording to ALL of the specifications and instructions mentioned in\nthat PARMLIB member, including a possibly new name, and possibly a new\ndisk location, for the TSO/E Broadcast Dataset.\n\n      This month, we're going to talk about tools which you can use, to\nadminister the Broadcast Dataset.  And we'll start by mentioning a free\ntool that I wrote, which shows you all of the current Broadcast Dataset\ninformation.\n\n\nTHE EESCB TOOL\n\n      If you want to know what is going on with all the TSO/E control\nblocks that have to do with the Broadcast Dataset, I have written a TSO\ncommand which shows this information.  The command is called EESCB, and\nyou can find it (source and all) in the CBT Tape collection at\nwww.cbttape.org, on File 731 (on the Updates page, most likely).  I have\nwritten the EESCB command to be backward compatible, all the way back to\nthe TSO/E 2.4 level (ESA 5.2.2), even though the relevant control blocks\nhave changed very considerably since then.  Of course, the EESCB command\nworks all the way up to the present system levels, z/OS 1.8 and TSO/E\n3.8.0, at the time of this writing.  Please look at Figure 1 for an\nillustration of the output of the EESCB command.\n\n      When I wrote the EESCB command, I tried to show just about every\npossible field in the appropriate TSO/E control blocks that has to do\nwith the Broadcast Dataset.  There are a very few fields that I left\nout, but all of the stuff which was coded in the active PARMLIB IKJTSOxx\nmember, appears in the output of the EESCB command, in control block\nform.  In other words, using the EESCB command, you can see how the\ncontents of the PARMLIB IKJTSOxx member is reflected in the actual\ncontrol blocks that are in storage.  These results are very interesting,\nand if you don't happen to have access to the PARMLIB datasets at the\ncurrent moment, or to a console where you can execute the D IKJTSO\ncommand, the EESCB command, (which DOES NOT have to be authorized) will\nshow you all the relevant information.\n\n      Since the EESCB TSO command uses the TSO PUTLINE interface to show\nits output, all of the output can be SYSOUTTRAP-ped and displayed in\nISPF EDIT, ISPF BROWSE, ISPF VIEW, or TSO REVIEW (CBT Tape File 134)\nfullscreen format.  CBT Tape File 434 contains REXX execs from Mark\nZelden called TSOE, TSOB, TSOV, and TSOR, which do the SYSOUTTRAP-ping.\nWhen these are executed with the EESCB command by saying TSO TSOE EESCB,\nTSO TSOB EESCB, and so forth, they will display all of the EESCB output\nin fullscreen, scrollable form.\n\n\nMANAGING USERIDS AND USER MESSAGES\n\n      The usual problem that we normally have with the Broadcast Dataset\nis that is has filled up, or it is threatening to fill up.  It usually\nfills up with user messages that are attached to userids.\n\n      When this condition happens, and several userids are accumulating\na large quantity of user messages without deleting them (by means of the\nuser logging on to TSO and thereby issuing the LISTBC command), IBM is\nnot particularly helpful.  IBM's \"remedy\" for a filled-up Broadcast\nDataset is to issue the SYNC subcommand of the ACCOUNT TSO command,\nwhich will effectively wipe out EVERYBODY's user messages, instead of\njust looking at the ones belonging to the worst \"offending\" userids.  In\nother words, IBM is telling us that when a skunk goes into the barn, you\nhave to burn down the entire barn and rebuild it over again, just to get\nrid of the skunk.  Putting it another way, IBM does not provide services\nwhich an administrator can use, to intelligently manage which Userids\nare accumulating an inordinately large number of messages without having\ndeleted them.\n\n      At this point, I have to point out one other fact.  All of IBM's\ntools which are intended to access the Broadcast Dataset, are geared to\nonly accessing the copy of the Broadcast Dataset which is currently in\nuse by the system.  In other words, this is the copy of the Broadcast\nDataset which is being pointed to by the IKJEESCB control block.  Or in\nolder systems, this is the cataloged copy of the dataset named\nSYS1.BRODCAST.  What if you have another copy of the Broadcast Dataset\nwhich is not currently in use?  Are there any tools to display ITS\nmessages, or to delete THEM?\n\n      I wrote two packages of tools to address both of these issues.\nOne of them is free, and it can be found on File 247 of the CBT Tape\ncollection of free MVS tools.  (Go to www.cbttape.org.)  The other one\nis a commercial package with more extensive capabilities, which I intend\nto release soon.  Most of the programs in my free package, and ALL of\nthe programs in my commercial package, can access any copy of the\nBroadcast Dataset, whether in use by the system, or not.  They do this\nby our allocating the BRODCAST DD name to the Broadcast Dataset copy\nthat we want to point to.\n\n      As far as micro-managing user messages that are attached to\nuserids, my packages contain three programs which perform the actual\nadministration:  BCMUSERS, BCMLIST, and BCMDEL2 in my free package, and\nBDMUSERS, BDMLIST, and BDMDEL in my commercial package.  These are\ninterfaced to a nice ISPF-based dialog from my friend Vinh Vu, called\nBCMUTIL in the free package and BDMUTIL in the commercial package.\n(Using the program names from the free package) I'll explain their\nfunctionality.  BCMUSERS will show all userids in the target Broadcast\nDataset which have messages attached to them, and it will say how many\nmessages are attached to each userid.  BCMLIST will list all messages\nattached to one userid, or to all of them.  (If you list the special\nuserid name ALL$#@ you will get all messages for all userids in that\nBroadcast Dataset.  And finally, BCMDEL2 will delete all (or some) of\nthe messages attached to one userid.  BCMUTIL provides an interface to\nall three of these programs, to show all the userids with messages, and\nthen to provide an opportunity to display, print, or delete (all or some\nof) them.  Please see Figure 2, to show what the BCMUTIL utility looks\nlike.\n\n      Unlike other tools which list or delete user messages from the\nBroadcast Dataset, BCMLIST and BCMDEL2 (as well as their commercial\ncounterparts BDMLIST and BDMDEL) can list or delete SOME of the user\nmessages belonging to a userid, without listing or deleting all of them.\nThis is accomplished with two keywords:  SKIP(mm) and MSGS(nn), where mm\nand nn are numeric integers.  SKIP(mm) means to skip the first mm\nmessages before performing the list or delete operation.  And MSGS(nn)\nmeans to list or delete the next nn messages after the skip, if SKIP is\ncoded, or nn messages from the first message, if SKIP is not coded.  If\nyou think about this arrangement, you'll see that it gives you COMPLETE\nCONTROL, which messages to list, or to delete, or to keep.\n\n      In addition to these three utilities, the BCMSEND command will\nsend a user message to any copy of the Broadcast Dataset.  But the free\nversion BCMSEND is quite slow, being adequate for a few messages, but\nit cannot efficiently be used to load messages in bulk.  In the commercial\npackage, I rewrote the BDMSEND command to be about 80 times more efficient\nthan the free BCMSEND version.  Syntax of the command is:  BCMSEND userid\ntext-of-message.\n\n\nUTILITIES FOR USERIDS AND GLOBAL NOTICES\n\n      The utility programs mentioned above are only intended to manage\nthe \"user message\" part of the Broadcast Dataset, but the Userid part\nand the Global Notification messages part are equally as important to\nadminister.\n\n      Userids are added or deleted, one at a time, by my BCMUSADD and\nBCMUSDEL free utilities.  But these two programs use an IBM interface to\nthe Userid portion of the Broadcast Dataset, and that interface does not\neasily allow access to an arbitrary copy of Broadcast which is not in\ncurrent use by the system.  In the commercial package, I completely\nrewrote BDMUSADD and BDMUSDEL from scratch, to eliminate the IBM\ninterface.  BDMUSADD and BDMUSDEL are easily able to add Userids to any\ncopy of the Broadcast Dataset, or to delete a Userid.  In addition, the\nreports from BDMUSADD and BDMUSDEL are far more informative about what\nwas actually done, than those in their free counterparts.\n\n      Global Notification messages, the ones that go to all users of the\nsystem at LOGON time (or whenever LISTBC is invoked), are managed with\nthree programs in the free package, and with their counterparts, and\nalso some other programs in addition, in the commercial package.  The\nthree programs are BCMNLIST, BCMNOTFY, and BCMNUPD.  Also in the free\npackage is the BDMNCLEN TSO command, whose functionality is absorbed in\nthe BDMCLEAN TSO command in the commercial package.\n\n      BCMNLIST will list all active messages in the Broadcast Dataset.\nThis is accomplished by reading the Broadcast Dataset (that is currently\nbeing pointed to by the BRODCAST DD name) directly.  Its format is similar\nto that of the SEND LIST subcommand of OPER which IBM provides.  But (as\nI explained in a previous article in this series), LISTBC will not read\nthe Broadcast Dataset directly, but an incore copy of it.\n\n      BCMNOTFY can change any active message in the Broadcast Dataset\ncopy that is being pointed to.  BCMNOTFY is wholly driven by \"message\nnumber\" and it will either place a Global message in that number slot,\nplace a blank message there, or delete the message that was there\nbefore.  Its syntax is:  BCMNOTFY nn followed by either:  message text,\n-BLAnks, or -DELete.\n\n      BCMNUPD is an authorized TSO command which sets a bit, to tell the\nsystem that the Global Notices section of the currently active Broadcast\nDataset has to be reread, and that the incore copy of the Global Notices\nhas to be replaced.  When this bit is set on, one invocation of LISTBC\nanywhere in the system will trigger the \"incore notice table\" update.\nBut that happens only with TSO/E Release 3 (z/OS 1.3) or later.  Before\nTSO/E Release 3, you needed an OPER SEND command which updated the\nBroadcast Dataset, to also update the incore Notices table when the bit\nis set on.\n\n\nOTHER UTILITIES\n\n      You may want to make a copy of the Broadcast Dataset on the same\ndevice type or on a different DASD device type.  The free package has a\nBCMDUMP and BCMREST \"dump-restore\" combination.  BCMDUMP makes an FB-130\nformat dataset out of the direct access format Broadcast Dataset, and\nBCMREST will reload a newly allocated Broadcast Dataset with all the\ndata from the dumped dataset.  An extra program called BCMEXPND not only\nwill reload a new Broadcast Dataset from the FB-130 BCMDUMP dataset, but\nit will additionally fill any larger \"first extent\" allocation for the\ntarget dataset, with extra blank userid message datasets (format X'FF').\nBoth BCMREST and BCMEXPND can reload the Broadcast Dataset to a\ndifferent DASD device type, because they fill in the correct first data\nbyte value (the R of the CCHHR or TTR of the record) no matter what type\nof DASD the target device type is.\n\n      The commercial package contains more than a few amazing additional\nutilities.  Its BDMINIT program will initialize a new Broadcast Dataset\nof any size, based on SYSIN keyword parameter data.  For example, if you\nwant the new Broadcast Dataset to have capacity for 400 Global\nNotification messages, you need merely code NOTIFY=400 in SYSIN, rather\nthan having to zap an IBM module that is in the link list.  The BDMINIT\nprogram is preceded by a BDMCALC program, which helps you calculate all\nthe sizes, track and cylinder capacities for the target DASD device\ntype, before actually creating the new dataset by running the BDMINIT\nprogram using the same parameters.  I created working Broadcast Datasets\nusing BDMINIT, as large as over 1000 cylinders, and as small as only one\ntrack.\n\n      Once the BDMINIT program has been created according to your specs,\nyou have to load it with Notices, Userids, and Messages.  These are done\nusing newly written Bulk Dumper and Bulk Loader programs for all of\nthese three categories.  So you can allocate and format any size new\nBroadcast Dataset with BDMINIT, and load it using a batch JCL stream, in\na very short period of time.  On my development system, loading a 13000\nrecord Broadcast Dataset from a fully loaded old Broadcast Dataset, took\nconsiderably less than one minute, clock time.\n\n      Last but not least, I have to mention the BDMSCAN program.  This\ncommercial program came from the BCMSCAN program in my free package,\nwhich in turn, was an improvement over the old user-written BRODSCAN\nprogram.  Both programs give you a summary of how many records of each\ntype, are in the Broadcast Dataset, and which userids have (how many)\nmessages deferred.  But BDMSCAN (the commercial version) also will\nformat (using an optional DD name) all of that Broadcast Dataset's\nrecords, interpreting all the field values for all the record types.  If\nyou look at File 247 of the CBT Tape, you'll see a load module of an\nearly version of BDMSCAN that I allow everybody to use, with JCL to run\nit, and then you'll taste why my commercial package is so much better\nthan my free package.  You can find out about my commercial package\n(called Broadcast Master) by looking at www.brodmstr.com or by emailing\nme directly.  I expect the price for my commercial Broadcast Master\npackage to be REMARKABLY affordable.\n\n\nSUMMARY\n\n      In the first two installments of this series, I explained many\ndetails about the internal structure of a Broadcast Dataset.  Today, I\ndescribed two sets of tools that I've written, to administer (any copy\nof) a Broadcast Dataset, in detail.  The free set of programs is\navailable on File 247 of the free CBT Tape collection (see the Updates\npage of www.cbttape.org).  The commercial package is about to be\nreleased in beta, and inquiries about it, can be made on\nwww.brodmstr.com, or by emailing me directly.\n\n      Best of luck to all of you.  And I'm looking forward to seeing you\nhere again next month.\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.  A sample of output from the free TSO command EESCB\n           at the z/OS 1.8 level (TSO/E Release 3.8.0).\n\n\nCurrent PARMLIB BRODCAST information - IKJEESCB\n------- ------- -------- -----------   --------\n  The EESCB TSO command displays information\n  concerning the TSO SEND and LISTBC command\n  options.  Information is obtained from the\n  IKJEESCB and TPVT TSO control blocks, which\n  are chained off the TSO Vector Table IKJTSVT.\n  BROADCAST dataset switching is only available\n  from IKJEESCB version 03 or later.\n  ---------------------------------------------\n  Parmlib member IKJTSOxx can be invoked:\n    A - At IPL Time\n    B - Under TSO using PARMLIB UPDATE(xx)\n    C - Using Operator command SET IKJTSO=xx\n  ---------------------------------------------\n  Source of EESCB messages:\n  ---------------------------------------------\n    IKJEESCB - General SEND and LISTBC defaults\n               from the IKJEESCB control block.\n    PARMLIB  - TPVT control block\n    BRODCAST - BRODCAST section of IKJEESCB\n               which is only present from\n               IKJEESCB version 03 or later.\n  ---------------------------------------------\nIKJEESCB Address : 119C30D8\nIKJEESCB Version : 03\nIKJEESCB Flags   : E8800000\nIKJEESCB Opersend: On\nIKJEESCB Usersend: On\nIKJEESCB Save    : On\nIKJEESCB Chkbrod : Off\nIKJEESCB Usebrod : On\nIKJEESCB Msgprot : Off\nIKJEESCB Sysplxshr Off\nIKJEESCB Spxshrxcf Off\nIKJEESCB Oprsewait On\nIKJEESCB Spxshrini Off\nIKJEESCB Lognmspec Off\nPARMLIB  Dataset : ADCD.Z18.PARMLIB\nPARMLIB  Volser  : Z8RES1\nPARMLIB  Member  : IKJTSO06\nPARMLIB  Activator SBGOLOB\nPARMLIB  Swt Date: 2007-07-17\nPARMLIB  Swt Time: 08:03:41\nPARMLIB  System  : ADCD\nPARMLIB  CPUID   : 0192\nPARMLIB  CPU Model 1247\nThis system does not write to TSO Userlogs.\nBRODCAST Dataset : SYS1.BRODCAST\nBRODCAST Volser  : Z8SYS1\nBRODCAST Unit Name SYSALLDA\nBRODCAST Flags   : 24\nBRODCAST Timeout : 005   Seconds\nBRODCAST Operator: Prompt\nThe BRODCAST dataset name is the default.\nBRODCAST Dataset volser not specified in IKJTSO06\nBRODCAST Dataset name was set by PARMLIB TSO command\nBRODCAST Dataset switch required?   No\nBRODCAST Dataset Name is an ALIAS?  No\n\n\n  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.   Illustration of Vinh Vu's BCMUTIL ISPF interface for\n            administrating User Messages connected to Userids\n            in the Broadcast Dataset.\n\n\n  Sort    Exit\n------------------------------------------------------------------------------\n 2007/07/31 ---------------  SYS1.BRODCAST Utility  -------- Row 1 to 17 of 48\nCmd input ===>                                                Scroll ===> PAGE\n (SORTID, SORTTOT)\n\n    CPU Type:  1247  CPs:  1  SU/Sec: 1483.5  Real:   512M  Exp:     0M\n    Active SMF id: SYS1               Number of Active TSUs:        1\n    Broadcast DSN: IBMUSER.NEW.BRODCAST\n    Volume: WORK04     Unit:  3390     Creation Date: 2007/105\n    Dsorg:  DA    Recfm:    F   Keyl:    1  Lrecl:   129   Blksize:   129\n\nAction    SKIP    MSGS   ID        Number Of  TSO ID\n(S/D/P)   (nn)    (nn)             Messages   Status\n------------------------------------------------------------------------------\n   _                     USER001        1875\n   _                     USER002         256\n   _                     USER003           4\n   _                     USER004           5\n   _                     USER005           1\n   _                     USER017          17\n   _                     USER021          28\n   _                     USER045          38\n   _                     USER057           6\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0709SE": {"ttr": 31233, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00$\\x01\\x07$/\\x01\\x07$/\\x11$\\x00\\xea\\x00\\xea\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-08-30T00:00:00", "modifydate": "2007-08-30T11:24:24", "lines": 234, "newlines": 234, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         SEPTEMBER 2007\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.\n\n\nSYSTEM SOFTWARE \"QUALITY\"\n\n      There are many possible \"standards\" by which we can judge the\nso-called \"quality\" of MVS system software.  In order to sell some tool\nor product commercially, certain standards of reliability and usability\nhave to be met, or else the users will not feel happy with the feel and\nresults of the product, and they will not want to buy it.  If their\ninstallation has already bought it, and the sysprogs don't like to use\nit, the sysprogs' opinion will surely be felt--a future recommendation\nwill not be forthcoming.  On the other hand, if the product is a dream\nto use, and it is almost impossible to make errors with it, then its\nacceptance level among the users will most certainly be high.\n\n      On the system level, and as a practitioner, I get two feelings\nabout the quality level of tools.  On the one hand, there is the \"quick\nand dirty\" tool that throws the bit I want to throw, and I don't care\nwhat it looks like or feels like to use, as long as it gets the job\ndone.  On the other hand, there is a complete and polished multi-set of\ntools, with its own contextual help, complete 24/7 support, and a nice\nmanual that is easy to use.  In between, there is everything else.  This\nis the area that we want to look at today.  Not only do we want to\nconsider the \"absolute usefulness\" of a piece of software--whether it\nwill get the job done for us.  But also we want to consider its\nreliability, helpfulness when we don't know how to do something, and its\nease of use.\n\n\nTHE WRITER'S (PROGRAMMER'S) POINT OF VIEW\n\n      In the \"older days\" (20 or 30 years ago) when there weren't so\nmany free or commercial packages which catered to a systems programmer's\nneeds, people had to grope for a way to throw a crucial bit, and they\ndidn't care too much how it was done, as long as it got done somehow.\nOne example comes to mind from my experience.  I worked for an fairly\nlarge sized MVS shop, JES2 was giving us problems in the middle of a\nbusy day, and I couldn't cancel JES2 and restart it.  JES2 (of course)\nis marked non-cancelable, and I didn't (then) have a tool to make it\ncancelable.  (You only have to throw one bit to do that.)  The result\nwas that this large company had to IPL in the middle of the day.  A\ncouple of months later, I acquired a free tool which can make a job\ncancelable (i.e. it \"knows\" which bit to throw) and we never had such a\nproblem again.\n\n      Now suppose I'm a sysprog, and (for argument's sake), I have done\nthe research and found out which bit to throw, on or off.  If I have a\nminimal knowledge of how to write a TSO command, I can quickly write\na specialized command which would access the bit, and take a parameter\nto turn the bit either on or off.  Of course this would get the job\ndone to my satisfaction, and I'd keep this tool in my \"bag of tricks\",\nready to use if I ever got into that situation again.  But could I ever\nsell this tool as a commercial product?  Most likely not, because it is\ntoo \"raw\" and it might cause a system error if somone used it\nincorrectly--not as it was designed to be used.\n\n      Suppose now, that I wanted to share my tool with other people.\nIn order to do that, I'd have to \"clean it up\" so that nobody might be\nable to make an error with it or misuse it somehow.  I'd have to\nexamine the parameter setup, so that if you entered the wrong parameter,\nyou would get a meaningful error message instead of getting an\nunpredictable result or an abend.  I might also have to research the\nparticular control block setup, to make sure it isn't release dependent,\nand an older or newer MVS release would be able to run my command\nequally well.  As you can surmise, there are many ways to improve the\nway a program runs, and there are also many ways to make it more\nfoolproof.\n\n\nWHAT'S IN BETWEEN?\n\n      What steps can you take to improve a program?  Actually, there are\nmore things than you can imagine.  A few obvious steps would be to look\nat \"boundary conditions\".  What would happen if the size of a parameter\nexceeds the maximum that should be allowed, or it's smaller than the\nminimum, or if it is not numeric, and it is supposed to be numeric?\nWhat happens if the parameter is exactly on the border between a \"good\"\nvalue and a \"bad\" value?  What happens if the user enters an extra\nparameter that the programmer didn't anticipate?  And what happens if no\nparameter is entered, when there is supposed to be one?  All of these\ncases have to be considered, if you want to \"clean up\" a program.\n\n      These considerations are not really enough.  Sometimes a program\nappears to run perfectly, but if you would examine the code line by\nline, you'd see errors that don't affect the code now.  But in the\nfuture, some unanticipated problems might rear their ugly heads.  For\nexample, suppose the program has three base registers, and the last one\nwas not initialized correctly.  If the program currently does not exceed\ntwo base registers, but in the future, a modification would overflow the\nsecond base and go into the range of the third, you'd get a big problem\nall of a sudden.  How do we anticipate and cure this kind of error?  In\nmy opinion, the easiest way is probably with a line-by-line source code\ncheck.\n\n      Line-by-line source code checks will expose and cure many\ndifferent classes of program error.  If you are looking at a piece of\ncode, and are trying to imagine what the machine is doing while it is\nexecuting that code, you'll often see things that don't make sense.\nQuestion is, why didn't you see that before?  Answers can be:  Maybe a\nnormal execution of the program won't pass through this code--only a\nboundary condition will cause those instructions to be hit.  Second,\nmaybe an incorrect value in a register or in some other field, might not\nbe seen by the user during the usual execution conditions (but it could\nbe doing some system damage that you don't see).  Third, the program\nmight not be properly \"cleaning up after itself\".  I once had a program\nthat didn't FREEMAIN the storage it GETMAINed.  A system dump revealed\nmany multiples of the control information which this program was\nsupposed to create.  These are some of the non-obvious types of errors\nwhich you may encounter.  A line-by-line source code check will reveal\nthis type of problem more easily than other diagnostic methods.\n\n      Then, there is the class of error which a \"debugger\" type of\nprogram will reveal.  A debugger program allows you to partially execute\na program, and stop in the middle, at crucial points where you suspect\nthere might be an error.  These points are called \"breakpoints\", and you\nset them up yourself.  When you stop the program execution at a\nbreakpoint, the debugger program will allow you display many aspects of\nthe program's environment, such as the register contents and the storage\ncurrently being accessed.  Using a debugger program will definitely help\nyou clean up how a program executes.  But it will not necessarily reveal\nfundamental coding errors that aren't hit by an actual program execution\nin a run.  For that, you still have to do a line-by-line source code\ncheck, to examine or \"eyeball\" the code yourself.\n\n      After that, there's plain old \"usability\".  What if a program will\nexecute perfecly and do what you want, without making a system error?\nBut it \"is a bear to use\"?  An example I can think of, is IBM's AMASPZAP\nprogram which can change disk storage.  IBM made the AMASPZAP program\nvery general, and it has enormous capability.  But what if you want to\nfind a piece of disk storage containing a string, and that's the only\nstorage you want to change?  Then AMASPZAP is not the tool you want.\nFullscreen ZAP, a TSO command which can be found on File 134 of the\n(huge and free) CBT Tape collection (www.cbttape.org), is the tool you\nwant to use for that job, not AMASPZAP.\n\n      So suppose, for argument's sake, that I wanted to add a \"string\nfind\" functionality to IBM's AMASPZAP program.  First of all, I couldn't\neasily do that, because IBM controls the code, and the next release of\nAMASPZAP wouldn't contain my changes.  Therefore, if I were bullheaded\nenough, I'd have to put in a change request to IBM, and they may, or may\nnot, listen to me.  If the code I want to improve is public code, such\nas code on the CBT Tape, then I can fix it.  And Sam Golob, who controls\nwhat gets into the CBT Tape collection, might be sympathetic enough and\nload my improved version of the program into the collection, in place of\n(or in addition to) the old version that was there before.  But in\neither case, here was a program that was working properly, but it was\nnot usable easily enough, or it was plain \"hard to use\".  That, in\nitself, cries out that a fix is either needed or should be desirable.\n\n\nQUALITY OF PUBLIC PROGRAMS VERSUS COMMERCIAL ONES\n\n      A vendor of commercial programs usually offers a written warranty\nthat the program(s) will (at least) be supported if some error or defect\nis present.  The vendor has to be aware of \"customer satisfaction\" and\nusability issues.  They certainly want to sell more licenses of their\nproduct.  And in general, it is in the best interest of a vendor of\nsoftware, to give out good code.  So they are forced to live up to\nstandards, which are partly of their own making, and which are partly\nimposed upon them by their customers.\n\n      Public code, on the other hand, is expressly released with no\nwarranties, no guarantee of support, and the user is assumed to take his\n(or her) own risks in using it.  Nevertheless, in my very long\nexperience with the code on the CBT Tape collection, and code from other\nplaces, I've observed that people who write public code tend to have a\ncertain pride in their workmanship, and in many cases, they're more\ndevoted to user satisfaction than even the vendors are.\n\n      You can see this by comparing code written under \"open source\"\nconditions to code written by software vendors.  Of course, results may\nvary, depending on who the people are, and what their circumstances are.\nI've found that vendors, who are often more short of programmer time and\nprogramming resources than their customers realize, will not make the\nprogramming effort necessary to put in a user-suggested enhancement,\nsimply because they don't feel that they have the resources to allocate,\nand they deem that the change will not be economically feasible.\nHowever an \"open source\" programmer, who is doing it \"for the love of\nthe game\", will gladly attempt the improvement, and will even add\nseveral more improvements of his own.  Quality of the software is not\neven an issue much of the time, because the \"open source\" programmer,\ndoing it for pride, will take the user feedback and gladly fix any code\nthat is shown to be in error.\n\n      I have, over the years, of course seen exceptions to this on both\nsides of the fence.  Some software vendors are extremely responsive, at\nleast to \"program fix\" requests.  But in general, the vendors are trying\nto make as much money as possible, once a software product has been\ndeveloped and is \"mature\".  They don't want to mess with code that has\nworked for a long time (and which they warranty in writing).  So I'd say\nin general, that vendors tend to be less inclined and flexible with\nregard to putting in \"usability fixes\" then are the \"open source\"\nwriters.\n\n\nSUMMARY\n\n      \"Quality issues\" in system software should be thought about.\nToday, I've only scratched the surface in dealing with them.  But I want\nto open your minds and generally get you to think about factors which\naffect software \"quality\".\n\n      You can't beat the price of free software.  But it must be pointed\nout that a writer of free software is not being FORCED to make his\nprograms the best that they can be.  Nevertheless, in many cases,\nsomeone who writes free software, and (you and) they know who they are,\ntakes enormous pride in their work, and they do it for the love of it.\nThey are also not restricted by any economic factors, other than the use\nof their time.  So the \"free software writers\" tend to be more open to\nimprovement suggestions because of this.  And sometimes, strange as it\nmay seem, free software is simply better.\n\n      But, free or vendor-supported, quality is the bottom line, unless\nof course you need a tool quickly, and you must write your own.  In that\ncase, the main idea is simply to get the job done any way you can.  And\nfor that purpose, the tool which was used, doesn't necessarily have to\nbe polished up, or adhere to a group of standards.\n\n      I hope that you've found this month's issue to be thought\nprovoking, and I wish all of you well.  Best of luck.  See you here next\nmonth!\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0710OC": {"ttr": 31238, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00P\\x01\\x07(\\x0f\\x01\\x07(_\\x165\\x01\\xcf\\x01\\xcf\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2007-10-07T00:00:00", "modifydate": "2007-10-12T16:35:50", "lines": 463, "newlines": 463, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                          OCTOBER 2007\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.\n\n\nEXPLORING \"LIVE\" STORAGE WITH THE \"LOOK\" TSO COMMAND\n\n      It is extremely useful, helpful, and often quite necessary, to be\nable to examine \"live\" system storage in the MVS (z/OS or any other\nflavor) machine that is currently running.  There are many available\ntools to do that, and most of them are vendor products which not\neveryone has.  But today, I want to concentrate on using one free tool\nto examine system storage.  And this is a tool that anyone, in any MVS\nshop, can easily acquire.  It is called LOOK, and it can be found on\nFile 264 of the CBT MVS Utilities collection (www.cbttape.org).\n\n      Programmers who write utilities for the MVS system must often also\nexamine live system storage, because that comprises the data which their\nprograms are usually trying to look at.  I assure you that you cannot\neffectively write utilites that read control block contents, unless you\ncan see the data which resides in the control blocks.  It is extremely\ninaccurate to program blindly, without looking at the data that you are\ntrying to either display or manipulate.\n\n      Then, in our modern MVS systems, there's also the question of\ngoing cross memory.  In other words, virtual storage, at the same\nnumerical address, but in different address spaces, contains different\ncontents.  So you'd often like to know what is going on, when one\naddress space communicates with another.  A memory display program which\ncommunicates between two or more address spaces in live storage on the\nmachine, is a useful thing to have in your tool box.  LOOK can do that,\nalbeit with some limitations, if it is running APF-authorized.\n\n\nTHE FREE \"LOOK\" PROGRAM\n\n      LOOK is a TSO command, and as I said before, it is free for the\ndownloading.  Source code is on File 264 of the magnificent CBT Tape\ncollection of free MVS utilities, and a load module is on File 035.\n(See www.cbttape.org).  LOOK is an old program from the pre-XA days, and\nit was extended to work in 31-bit mode.  But even though LOOK is a bit\noutmoded in its coding style, it has features that make it so convenient\nto use, that if your (storage browsing) task is not beyond LOOK's\ncapabilities, I think it is the preferred tool for the job.  And that's\nwhy I'm writing my column about it this month.\n\n      LOOK is a full screen TSO command.  For browsing storage in your\nown address space, LOOK doesn't even have to run APF authorized.  But if\nLOOK is APF authorized, it can go cross-memory too.  LOOK was written in\nthe old days, before convenient ESA cross-memory mechanisms were\ninvented.  So LOOK goes cross-memory by scheduling an SRB, which is one\nof it's weaknesses.  By the time the SRB results get back to you, the\nstorage in the other address space that you're examining, may be out of\ndate.  But in most cases, as long as you don't need absolutely accurate\ncross-memory storage information, LOOK has so many nice features that\nyou'll always want to use LOOK, unless you absolutely can't, and you\nhave to use another tool.\n\n      What is so great about LOOK?  The first thing, is that LOOK can\nFORMAT a control block's storage according to its descriptive macro.\nMany other storage browsing programs can't do that.  In addition, if\nyou do format the control block according to its macro, then you can\nnavigate the storage, using the name of the control block's field, and\nthus, you don't even have to know the numerical displacement of the field\nwithin the control block.  You just have to know its NAME.  I'll show you\nhow all of this works.\n\n      Before I go on, I'd like to tell you about one more advantage\n(over other spool browsing programs) that LOOK has.  That is, LOOK can\nrun in non-APF-authorized mode.  True, when LOOK is run non-authorized,\nit can only browse the storage in your own TSO address space.  But I have\nto point out something.  YOUR OWN TSO address space also includes COMMON\nSTORAGE!  This means you can look at EVERYBODY's CSA, PLPA, FLPA, MLPA,\nand SQA, from your own TSO address space, and you can do so while YOU'RE\nNOT AUTHORIZED...  Not too many other spool browsing programs can lay\nclaim to that.  This means, that when you don't have full power, you can\nstill find out an awful lot about your system's storage contents.\n\n\nSTEPPING THROUGH CONTROL BLOCKS WITH \"LOOK\"\n\n      Please take a look at Figure 1, which is the HELP screen for the\nLOOK TSO command.  You invoke LOOK from TSO by simply entering LOOK at\nthe READY prompt, or TSO LOOK from the ISPF command line.  Then,\npressing PF1 takes you to this HELP screen.\n\n      We all know that when an Assembler program runs a chain of control\nblock fields, mostly LOAD (L) and LOAD ADDRESS (LA) instructions are\nused.  For example, suppose (to pick a control block) we want to access\nthe IKJEESCB control block, which tells us all about where the Broadcast\nDataset (usually SYS1.BRODCAST) is, which the system is using now.\nAfter z/OS 1.3, you can switch Broadcast Datasets, and they don't have\nto be named SYS1.BRODCAST and cataloged in the master catalog any more.\nBut they can be named any valid dataset name, and they don't even have\nto be cataloged.  So to find the Broadcast Dataset after z/OS 1.3, the\nsystem runs a chain of control blocks to access the IKJEESCB control\nblock.  IKJEESCB has all the information about which current Broadcast\nDataset the SEND and LISTBC TSO commands are now accessing.\n\n      Let's get going.  When we type LOOK as a TSO command, we get the\nscreen in Figure 2, which is Virtual address 00000000, or the PSA\ncontrol block.  But you'll notice that the fields are formatted.  Why is\nthat, and how does it work?  Formatting uses the \"O\" subcommand in LOOK.\nType \"ONULL\" and you'll turn off formatting.  Type \"OPSA\" and you'll\nformat the current storage, beginning at the current location, as though\nit were the beginning of the PSA control block.  When you know which\nsystem control blocks that LOOK can format, you can enter these \"Oxxx\"\ncommands yourself.  To turn formatting off, anytime, just type ONULL.\n\n      Some control blocks get formatted by LOOK automatically, if they\nstart with an eyecatcher string, which can be programmed into the CBMACS\nmacro that does the formatting.  LOOK can automatically format a control\nblock if the current storage (being looked at) contains some indicator\nwhich we know about.  And you can code the formatting for any macro you\nwant, using any macro, into the CBMACS source member yourself.\n\n      Now how do we navigate control blocks?  LOOK starts at storage\nlocation 00000000.  But to get to the CVT, we have to look at the\nvirtual storage in address 00000010 (hex).  To see that, we have to go\nto virtual location X'10', look at the address in the fullword there,\nand load it.  In other words, we point to the address that is located at\naddress X'10'.  In Assembler, this is done with a LOAD instruction, but\nthe command in LOOK which is similar to the LOAD instruction is called\n\"J\".  Therefore, if we want to display the storage pointed to at address\nX'10', we say (in LOOK) the command \"J10\".  This will get us to the CVT,\nand all the storage there, is formatted according to the layout in the\nCVT macro in SYS1.MACLIB.\n\n      In LOOK, if a control block is formatted already, and we want to\npoint to the address that is in one of the fields, we use the \"L\"\ninstruction which really means \"link\" to the address in the named field.\nFor example, if we are pointing to the CVT (see Figure 3), and we want\nto point to the address at the named field TVT, we say the command\n\"LTVT\".  Lo and behold, we are pointing to the TSVT control block (TSO\nVector Table).  Had we known a relative address (from the CVT start\npoint) where the TSVT is pointed to, we could have entered it using a\n\"J\" command.  In actuality, we thus could have said, \"J+9C\" and gotten\nto the same place.  But when formatting of a control block is in place,\nand the \"L\" command is available, it saves you a lot of work to use the\n\"L\" notation, because you don't have to know all the absolute address\ndisplacements.  A field name is sufficient to get to see the required\nstorage.\n\n      In LOOK, a Load Address (LA) instruction is simply entered by\nusing a plus sign \"+\" and entering the hex quantity you want to jump to.\nFor example, if you are pointing to the CVT start and you want to point\nto an address X'8' bytes higher, you simply say +8.  To go to a lower\naddress location, you use a minus sign \"-\" instead of the plus sign.  So\nthe LOAD and LOAD ADDRESS operations can easily be duplicated in the\nLOOK command, when you're trying to follow control block chains in\nvirtual storage.  If you've made a mistake, or just want to go back to\nthe previous LOOK screen, just press PF9.  That takes you back to the\nscreen before, if there was one.\n\n      If you see an location that contains an address you think you\nmight be interested in, simply use a J command and point it at that\naddress.  For instance, when pointed at the TSVT (which is formatted by\nmy copy of LOOK - see Figure 4) and you see the TPVT, you can point to\nit with LTPVT, but then, that is an OCO control block, and I might want\nto explore its contents some more.  See Figure 5.  There is an\ninteresting address at +20 from the beginning of that control block.  I\nwant to see what is there, so I enter the command, J+20.  Lo and behold,\nthere appears the IKJEESCB control block.  If I am interested in\nSYS1.BRODCAST related stuff, I have found what I want to see.  If not, I\npress PF9 to go back one screen, and I try another address.\n\n      In this way, I was able to explore the contents of most of the\nTSO/E-related control blocks in the system.  See my February and March\n2006 columns about TSO/E control blocks.  All of the information found\nthere, was obtained using the LOOK command, and exploring.  Amazing,\nisn't it?\n\n\nWHAT YOU CAN DO, ONCE YOU'VE SEEN THE STORAGE\n\n      Once you've seen the storage, you can simply remember what's\nthere, for your own knowledge, or you can write programs to display or\nuse the storage values in some way.  To illustrate how I could use the\nknowledge that was available in the IKJEESCB control block, and also to\nshow some related information that could be found in the TPVT, I wrote a\ndisplay program which I called \"EESCB\".  EESCB source code can be found\non the CBT Tape File 731, along with some other related useful programs\nthat came out of my TSO/E control block discoveries.  Please look at\nFigure 7, to see some sample output from EESCB.\n\n      I never do any programming in system control blocks, without using\nthe LOOK program to see what was there in the first place.  LOOK is my\neyes and ears into system storage.  Of course, we can go further and use\nother tools too, but for me, LOOK is always the place to start.\n\n      I hope you have gained something from this article, whether you\nare an experienced programmer, a novice, or somewhere in between.  I\nwish all the best of everything for all of you, and I hope to see you\nhere again next month.\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFigure 1.   HELP screen to summarize the LOOK subcommands.\n\n\nLOOK COMMAND - DISPLAY VIRTUAL MEMORY      DISPLAY ASID= 002A\nENTER CMD -\nLAST CMD  -\n\nLOOK is a real time core display and formatting program. It also has the\ncapability of displaying memory in any address space (if authorized).\n\nThe valid commands are:\nIexp  24 bit indirect                 | Jexp  31 bit indirect\n>     Forward                         | <     Backward\n=sym  Define current address as \"sym\" | ,sym  Redisplay core at \"sym\"\nM0/M1 Flip between top and center     | Lname Indirect thru control block field\nOcb   Format as \"cb\" control block    | R     Refresh displayed storage\n      \"cb\" may be NULL to show as hex |\n\nwhere 'exp' is of the form:\n    <+/->hhhh<+/-hhhh<+/-hhhh...>>\nand 'hhhh' is a 1 to 8 digit hex number.\n\n\n\n\n1= HELP      2=           3= END        4=           5= REPEAT  6=\n7= BACKWARD  8= FORWARD   9= HIST BWD  10= HIST FWD 11=        12=\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFigure 2.  LOOK pointing at location 00000000, which is\n           formatted as the PSA control block.\n\n\nLOOK COMMAND - DISPLAY VIRTUAL MEMORY      DISPLAY ASID= 001A\nENTER CMD -\nLAST CMD  - OPSA\n                          00000000  PSA\n RNPSW   000A0000  ROPSW   0000000000000000  CVT     00FDDF00\n EOPSW   7FFFF0007FFFF000  SOPSW   7FFFF0007FFFF000  POPSW   7FFFF0007FFFF000\n MOPSW   0000000000000000  IOPSW   7FFFF0007FFFF000  CVT2    00FDDF00\n ENPSW   000A0000  SNPSW   000A0000  PNPSW   000A0000  MNPSW   000A0000\n INPSW   000A0000  EPARM   00000000  SPAD    0000  EICOD   1005  SVILC   02\n SVCN    006B  PIILC   02  EECOD   00  PICOD   11  TEAB3   01  MCNUM   00\n PERCD   00  ATMID   00  PER     00000000  MTRCD   000000  TEARN   00\n PERRN   00  ARCH    01  MPL     01367908  SID     0001003D  IOFP    00F53590\n FACL0   F1  FACL1   60  FACL2   FE  FACL3   CB  ESAR    00000000\n CTSA    0000000000000000  CCSA    0000000000000000  MCIC    0000000000000000\n FSA     00000000  FLA     00000000000000000000000000000000  ARSAV   00000000\n FPSAV   00000000000000000000000000000000070420008000000000000000011FC52C\n GRSAV   00000000  CRSAV   04040000  PSA     PSA       CPUPA   0000\n CPULA   0040  PCCAV   00F59008  PCCAR   1E6DA008  LCCAV   00F96000\n LCCAR   1E717000  TNEW    008C9468  TOLD    008C9468  ANEW    00FDC400\n AOLD    00FC9280  SUP1    00  SUP2    00  SUP3    00  SUP4    00  PTYPE   00\n\n\n1= HELP      2=           3= END        4=           5= REPEAT  6=\n7= BACKWARD  8= FORWARD   9= HIST BWD  10= HIST FWD 11=        12=\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFigure 3.   LOOK pointing at the CVT control block that was\n            pointed to by virtual storage location X'10'.\n            The CVT control block has been automatically\n            formatted by the CBMACS section of the LOOK program.\n\n\nLOOK COMMAND - DISPLAY VIRTUAL MEMORY      DISPLAY ASID= 001A\nENTER CMD -\nLAST CMD  - J10\n                          00FDDF00  CVT\n TCBP    00000218  0EF00   00FED61C  LINK    00FDDE7C  AUSCB   00FDE4E8\n BUF     00000000  XAPG    00FF5FF8  0VL00   00FF1896  PCNVT   00FE775E\n PRLTV   00FE7564  LLCB    019476D8  LLTRM   812FF600  XTLER   00FEBAD8\n SYSAD   00F53500  BTERM   00FE9FB8  DATE    0107276F  MSLT    00FDE510\n ZDTAB   00F49000  XITP    00FF7DC8  0EF01   00FED63C  VSS     0000\n VPSM    0000  EXIT    0A03  BRET    07FE  SVDCB   00FDDE84  TPC     00FD9488\n FLGC0   00  FLGC1   00  ICPID   0000  CVT      CVT      CUCB    00FDEA78\n QTE00   00FED65A  QTD00   00FED662  STB     00F552F0  DCB     9B\n DCBA    FE0D78  SV76M   0062001D  IXAVL   00FE41C0  NUCB    00000000\n FBOSV   813C0920  0DS     00FED554  ECVT    0195C9F8  DAIRX   8328B000\n MSER    00FDE510  0PT01   00FED4C4  TVT     00CB0140  040ID   000000A4\n MZ00    7F  1EF00   00000000  QOCR    00000000  QMWR    00FDE5F0\n SNCTR   0000  OPTA    A3  OPTB    20  QCDSR   00FE9328  QLPAQ   00FDDEB8\n ENFCT   00FDE628  SMCA    80FCE0F0  ABEND   00FDD310  USER    00000000\n MDLDS   00000000  QABST   0A0D  LNKSC   0A06  TSCE    00000000\n PATCH   00FDD238  RMS     0132C368  SPDME   0230FF44  0SCR1   00FE6BB8\n\n\n1= HELP      2=           3= END        4=           5= REPEAT  6=\n7= BACKWARD  8= FORWARD   9= HIST BWD  10= HIST FWD 11=        12=\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFigure 4.  LOOK pointing to the TSO Vector Table, as a\n           result of using an \"L\" command in the previous\n           display of the formatted CVT control block.\n\n\nLOOK COMMAND - DISPLAY VIRTUAL MEMORY      DISPLAY ASID= 001A\nENTER CMD -\nLAST CMD  - LTVT\n                          00CB0140  TSVT\n TSVT    TSVT      LEV     .   FLG1        NCT     1178D250  VACC    00CE0A4E\n ASF     00CCD1E0  LTBL    00D95B30  FLA1    83E1A000  CTIO    80D9A000\n CTAB    83E16030  T440    83EA26AE  T441    83EBC910  PUTL    83EB3028\n PTGT    83EB3F18  GETL    83EB751E  STCK    83EAE220  TSL     80CD0990\n SCAN    83EC2000  PARS    83E81000  EF02    83E73000  TPVT    119C3198\n RCVY    84A839B0  TRAN    83EC4000  BCMT    ........\n CAF     83E473D8  LVER    3   LREL    08    LMOD    0   CTDB    83274B88\n RIF     8326A370  RAF     83E3D000  RTRP    83EBF000  TBLS    00CE0A30\n ADTB    83681EB8  TBLR    83EDFD20  ESTK    84075E98  TVAR    840C65E8\n INIT    84091910  OLAR    80D7E000  TO00    840C1000  T44X    83EA1CC8\n FTS2    83E42000  EXE     8408E4E8  INOU    840908D8  LOA     84090CB0\n TER     840BC7B0  SUBC    8408EE28  MSGI    840A91D0  EXCO    8408F1F8\n TERM    840A6B90  ETVP    00C9BAD0  TSFI    83E40000  TSFT    82B0B868\n PCN1    00001A00  SNTA    1197A490  SVTA    1197AE48  SYML    00000B70\n XCFU    00000000  MSTR    00FDC400  BECB    808C9070  APPC    82887A40\n URPS    83EC6000  PCN2    00001A01  MSR0    83E75000  MDT@    831A0718\n\n\n1= HELP      2=           3= END        4=           5= REPEAT  6=\n7= BACKWARD  8= FORWARD   9= HIST BWD  10= HIST FWD 11=        12=\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFigure 5.   LOOK pointing at unformatted storage, which is\n            the OCO control block IKJTPVT.  In order to see\n            what is here, we have to explore, using J+x\n            commands.  For example, J+20, which looks\n            interesting.\n\n\nLOOK COMMAND - DISPLAY VIRTUAL MEMORY      DISPLAY ASID= 001A\nENTER CMD -\nLAST CMD  - LTPVT\n\n119C3198   >E3D7E5E3  00DC0200  C9D2D1E3  E2D6F0F0 *>TPVT....IKJTSO00*\n119C31A8    00000000  11A6C018  0000003C  00000000  *.....w..........*\n119C31B8    119BF3A0  11A6D008  119CB058  119BF2A0  *..3..w........2.*\n119C31C8    11A2F018  00000000  00000000  119E4018  *.s0........... .*\n119C31D8    00000000  00000000  00000000  00000000  *................*\n119C31E8    C1C4C3C4  4BE9F1F8  E24BD7C1  D9D4D3C9  *ADCD.Z18S.PARMLI*\n119C31F8    C2404040  40404040  40404040  40404040  *B               *\n119C3208    40404040  40404040  40404040  E2F8D9C5  *            S8RE*\n119C3218    E2F10000  C1C4C3C4  40404040  5C5CC9D7  *S1..ADCD    **IP*\n119C3228    D35C5C40  F0F97AF5  F97AF2F8  F2F0F0F7  *L** 09:59:282007*\n119C3238    60F1F060  F0F30080  00000192  12470959  *-10-03.....k....*\n119C3248    28102007  10038000  00000000  00000000  *................*\n119C3258    00000000  00000000  00000000  00000000  *................*\n119C3268    00000000  00000000  00000000  00000000  *................*\n119C3278    C5D5C6D3  40000000  00000000  81238D82  *ENFL .......a..b*\n119C3288    00000001  00000000  117F2380  00000000  *.........\"......*\n\n\n1= HELP      2=           3= END        4=           5= REPEAT  6=\n7= BACKWARD  8= FORWARD   9= HIST BWD  10= HIST FWD 11=        12=\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFigure 6.   A LOOK at the unformatted IKJEESCB control\n            block.  The macro describing this storage is in\n            SYS1.MODGEN.\n\n\nLOOK COMMAND - DISPLAY VIRTUAL MEMORY      DISPLAY ASID= 001A\nENTER CMD -\nLAST CMD  - J+20\n\n119BF3A0   >C9D2D1C5  C5E2C3C2  030000C0  E8800000 *>IKJEESCB....Y...*\n119BF3B0    5C404040  40404040  40404040  40404040  **               *\n119BF3C0    40404040  40404040  40404040  40404040  *                *\n119BF3D0    40404040  40404040  40404040  40404040  *                *\n119BF3E0    40404040  0107276F  13592792  00010002  *    ...?...k....*\n119BF3F0    00140000  00000000  00000000  00000000  *................*\n119BF400    30000000  0005000D  E2E8E2F1  4BC2D9D6  *........SYS1.BRO*\n119BF410    C4C3C1E2  E3404040  40404040  40404040  *DCAST           *\n119BF420    40404040  40404040  40404040  40404040  *                *\n119BF430    40404040  E2F8E2E8  E2F10000  E2E8E2C1  *    S8SYS1..SYSA*\n119BF440    D3D3C4C1  00000000  00000000  0107276F  *LLDA...........?*\n119BF450    13592821  00000000  00000000  00000000  *................*\n119BF460    C9D2D1C5  C6E3C5F2  40D7C1D9  D4D3C9C2  *IKJEFTE2 PARMLIB*\n119BF470    C1C44040  40404040  C1C4C4E2  C4404040  *AD      ADDSD   *\n119BF480    C1C74040  40404040  C1C4C4C7  D9D6E4D7  *AG      ADDGROUP*\n119BF490    C1E44040  40404040  C1C4C4E4  E2C5D940  *AU      ADDUSER *\n\n\n1= HELP      2=           3= END        4=           5= REPEAT  6=\n7= BACKWARD  8= FORWARD   9= HIST BWD  10= HIST FWD 11=        12=\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\nFigure 7.  Output of the EESCB command, which\n           is a program that displays the contents\n           of the IKJEESCB control block in detail.\n\n\nCurrent PARMLIB BRODCAST information - IKJEESCB\n------- ------- -------- -----------   --------\n  The EESCB TSO command displays information\n  concerning the TSO SEND and LISTBC command\n  options.  Information is obtained from the\n  IKJEESCB and TPVT TSO control blocks, which\n  are chained off the TSO Vector Table IKJTSVT.\n  BROADCAST dataset switching is only available\n  from IKJEESCB version 03 or later.\n  ---------------------------------------------\n  Parmlib member IKJTSOxx can be invoked:\n    A - At IPL Time\n    B - Under TSO using PARMLIB UPDATE(xx)\n    C - Using Operator command SET IKJTSO=xx\n  ---------------------------------------------\n  Source of EESCB messages:\n  ---------------------------------------------\n    IKJEESCB - General SEND and LISTBC defaults\n               from the IKJEESCB control block.\n    PARMLIB  - TPVT control block\n    BRODCAST - BRODCAST section of IKJEESCB\n               which is only present from\n               IKJEESCB version 03 or later.\n  ---------------------------------------------\nIKJEESCB Address : 119BF3A0\nIKJEESCB Version : 03\nIKJEESCB Flags   : E8800000\nIKJEESCB Opersend: On\nIKJEESCB Usersend: On\nIKJEESCB Save    : On\nIKJEESCB Chkbrod : Off\nIKJEESCB Usebrod : On\nIKJEESCB Msgprot : Off\nIKJEESCB Sysplxshr Off\nIKJEESCB Spxshrxcf Off\nIKJEESCB Oprsewait On\nIKJEESCB Spxshrini Off\nIKJEESCB Lognmspec Off\nPARMLIB  Dataset : ADCD.Z18S.PARMLIB\nPARMLIB  Volser  : S8RES1\nPARMLIB  Member  : IKJTSO00\nPARMLIB  Activator **IPL**\nPARMLIB  Swt Date: 2007-10-03\nPARMLIB  Swt Time: 09:59:28\nPARMLIB  System  : ADCD\nPARMLIB  CPUID   : 0192\nPARMLIB  CPU Model 1247\nThis system does not write to TSO Userlogs.\nBRODCAST Dataset : SYS1.BRODCAST\nBRODCAST Volser  : S8SYS1\nBRODCAST Unit Name SYSALLDA\nBRODCAST Flags   : 30\nBRODCAST Timeout : 005   Seconds\nBRODCAST Operator: Prompt\nThe BRODCAST dataset name is the default.\nBRODCAST Dataset volser not specified in IKJTSO00\nBRODCAST Dataset name was set by System IPL\nBRODCAST Dataset switch required?   No\nBRODCAST Dataset Name is an ALIAS?  No\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0711NV": {"ttr": 31492, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x001\\x01\\x071\\x0f\\x01\\x071\\x0f\\x12I\\x01\\xb6\\x01\\xb6\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-11-06T00:00:00", "modifydate": "2007-11-06T12:49:31", "lines": 438, "newlines": 438, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         NOVEMBER 2007\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.\n\n\nDISPLAYING MVS SYSTEM VALUES - Part 1\n\n      There's a general question when dealing with any operating system,\nand especially when dealing with MVS in any of its forms (z/OS, OS/390,\nand further back).  That is:  We know there is much information about\nthe general well-being and the operating particulars of the system\nstored in the many control blocks and control areas of the system.  But\nthat information remains hidden from us, unless there's some way for us\nto display it clearly.  How can we get to the information?  And how can\nwe use it to see what the system is doing?  The answer, in the case of\nMVS, is that even if we see many of the system values, it still takes\nskill and knowledge to interpret them.  But we must be able to see them\nfirst, and that requires a program (or many programs) to use for\ndisplaying them.\n\n      When we logon to TSO and see the standard screen and the ISPF\nentry panel, those give us a warm and fuzzy feeling because they are\nvery familiar to us.  The entry TSO screens do not vary much, when going\nfrom one MVS instance or MVS installation to the other.  But the entry\nscreens give us very little visible indication about what is going on in\nOUR PARTICULAR SYSTEM, and about how THIS SYSTEM is behaving.  When we\nfirst log on, we have absolutely no indication about whether our system\nis \"sick\" or \"healthy\".  And we don't see a thing, about what kind of\nDASD drives are attached to the system, or about what processes and\ntasks are actually running there.  We need more tools, obviously.\n\n      Various program packages have been written to display the values\nin many system control blocks.  These are the big monitoring tools, such\nas Omegamon (TM) and Resolve (TM) and such general utility packages.\nThose tools are supposed to help an administrator to regulate and watch\nthe general health and operation of the system.  And there are many more\nspecific utilities and lesser-known monitors, such as Greg Price's IMON\nmonitor, as well, which can do this kind of job.  That's from a \"general\nadministration\" point of view.  This kind of work can be done by a\nskilled computer operator.  But we, as the \"system doctors\", have to do\n(and know) much more.  In our position, we are required to gain as much\nknowledge about the innards of the various MVS component parts as\npossible.  And we should know the possible correct operating parameters\nof most of the system components, so that they operate efficiently, and\nrun the way we want them to run.\n\n      So how do we display these parameters and quantities, in such a\nway that we can use our skills to follow how our own MVS systems are\ndoing?  Fortunately, there is a free tool available for this, with\nsource code accessible too.  This tool is called SHOWMVS (originally\nfrom Gilbert Saint-flour), which in its more modern form, is called\nSHOWzOS.  SHOWzOS is now maintained by Roland Schiradin.  You can obtain\nboth of these programs from CBT Tape File 492 (at www.cbttape.org) by\nlooking at the Updates page.  SHOWzOS performs the valuable function of\nmaking the MVS control information (which is hidden in the system\ninnards) DISPLAYABLE.  How SHOWMVS and SHOWzOS do this, is the subject\nof today's article.\n\n\nWHY SHOWzOS IN PARTICULAR?\n\n      SHOWMVS and SHOWzOS are available in source code, which we can\nstudy ourselves.  Looking at this source code can prove very useful in\nour learning process.  Other similar tools, such as MXI from Rob Scott\n(CBT Files 409 and 410), and TASID from Doug Nadel of IBM\n(www.sillysot.com/mvs/tasid.htm) do not have source code with them, so\nwhile they are very useful to us, it is much harder for us to learn\nabout the actual paths to the MVS innards from them.  Even though they\ndisplay the contents of many of those innards, MXI and TASID won't show\nyou directly, where (in the system) their information came from.\n\n      From studying SHOWMVS and SHOWzOS, we can learn how to do control\nblock displays ourselves, in our own programs.  SHOWMVS and SHOWzOS are\nwritten in Assembler language.  We can look at the SHOWzOS Assembler\ncode and figure out the direct paths to each control block which SHOWzOS\ncan display.  It's not too easy, just from looking at the code, but the\nknowledge is worth the effort.\n\n      Once we know how to get to a piece of system data, Assembler code,\nor even REXX, can be used to display it.  The display tool in SHOWzOS is\npackaged as a macro (invented by Gilbert Saint-flour or by members of\nhis group) called STRING.  In SHOWzOS, the 64-bit version of STRING is\ncalled STRING64.  Using the STRING or STRING64 macro, a whole line of\ndata, built up from various fields and character strings mixed together,\ncan be displayed by one macro instruction.  That makes it easy for\nSHOWMVS or SHOWzOS to produce its complicated display lines.  If you\nwrite your own display code for some control blocks, you don't have to\nuse the STRING macro, but you can form your display lines in some more\ntraditional manner.  I'll try to write more about this subject next\ntime.  Meanwhile, look at Figure 2 to see some sample SHOWzOS output.\n\n      As for using REXX instead of Assembler, if REXX is easier for you,\nthere exist wonderful examples of the use of REXX to display system\ncontrol quantities.  Mark Zelden's examples (in CBT Tape File 434 - be\nsure to use the Updates page of www.cbttape.org) are among the best I've\nseen.  Especially look at Mark's marvelous IPLINFO REXX exec.  You can\nlearn a lot from looking at the IPLINFO REXX source, and from Mark\nZelden's stuff on CBT File 434, in general.  Again, check the Updates\npage on www.cbttape.org first.\n\n\nHOW TO FIND AND DISPLAY MVS CONTROL INFORMATION\n\n      Every component of MVS has to store its control information\nsomewhere.  After the initial control information has been stored away,\nat IPL time or during the later initialization of a component, the\nsystem has to be able to find it or change it, when it needs it.  So\nthere have to be well designed and well documented paths that get you to\neach particular piece of information.  Once you know these paths, you\ncan get to the information.  And once you get to the information, you\nhave to figure out how to display it and make it visible.  Otherwise\nyou'd have to interpret all the raw hexadecimal bits and bytes, which is\nmuch more difficult than just seeing the correct quantities displayed\nplainly in front of you, together with their appropriate titles.\n\n      The layouts of most MVS control blocks are described by MACROS, at\nleast in Assembler, and also in IBM's proprietary system development\nlanguage, PL/X.  IBM uses PL/X (which is very much like PL/I) to write\nmany of the MVS system components.  IBM releases the contents of many of\nits macros to the public, in its big macro libraries SYS1.MACLIB and\nSYS1.MODGEN, although some of the IBM macros are distributed in small\nmacro libraries that are specialized to the individual components.  A\nkey example of this is HLASM, the High Level Assembler, whose macros are\navailable in macro libraries HLA.SASMMAC1 and HLA.SASMMAC2, and not in\nSYS1.MACLIB or SYS1.MODGEN.\n\n      When IBM does NOT want to publish the contents of a control block\nat all, it does NOT release the descriptive macro (which shows the\nlayout of the control block) to the public.  For sure, such a macro does\nexist within the confines of IBM.  Those macros which IBM uses for its\nown development purposes are marked \"for Internal Use Only\", and are not\nreleased to the public.\n\n      So, in that case, if any \"interested users\" would want to know\nwhat is going on, they have to research that control block, try to\nfigure out how it is used, and manufacture a descriptive macro for\nthemselves.  I have found the LOOK program (CBT Tape File 264) which we\ndescribed last month, to be very useful in doing this research.  The\nidea is to try and document the contents of the unknown control block,\nso we can write a program which can then display its current values.\nSince it is the job of the SHOWzOS program to display as many critical\nsystem values as possible, the developers of SHOWzOS have done much of\nthe necessary research to create their own descriptive macros that show\nthe layout of many undocumented IBM control blocks.  You can be the\nbeneficiary of their exhaustive and painstaking research.\n\n      Therefore, take a look at CBT File 492 (use the www.cbttape.org\nUpdates page) member SHOWMACS.  SHOWMACS is a collection of\nuser-developed macros which attempt to describe many MVS control areas\nthat IBM doesn't especially want you to know about.  The member SHOWMACS\nis really an unloaded pds in IEBUPDTE unload format.  The SHOWMACS\nlibrary on CBT File 492 (again, use the Updates page if possible) can\nform the basis of much of your initial research into unknown MVS control\nblocks.\n\n      If you are interested enough in seeing an in-core version of some\nof the areas which these macros describe, you can actually assemble them\ninto the CBMACS component of the LOOK TSO command which we wrote about\nlast month (CBT File 264), and you can use the macros from the SHOWMACS\nlibrary to format the (proprietary) control areas of your choice, while\nyou are viewing system storage on the screen!\n\n\nSOME SUGGESTIONS\n\n      Please look at Figure 1, which summarizes the kinds of MVS control\ninformation that SHOWzOS can display.  As you can see, it is a huge\nlist.  If you are interested in making your own displays of similar\npieces of system information, you can get your start by examining the\nparticular pieces of SHOWzOS code which access the areas you are\ninterested in looking at.  Also take a look at Figure 2, which shows\nsome of the top level information which SHOWzOS displays in a modern\nsystem.  Thus, you can get a small idea about the way SHOWzOS displays\nits information.  My advice is:  Try it.  You'll like it.\n\n      If you want load modules, or (for some reason) you can't cleanly\nassemble the SHOWzOS source code, the CBT Tape collection has a load\nmodule library file on File 614 (again try and use the Updates page).\nVarious levels of SHOWMVS and SHOWzOS load libraries, in TSO XMIT\nformat, are members of the File 614 pds.  The reason why these load\nmodule libraries are in a separate location from the source code, is\nbecause some of the source code is z/OS release dependent, and the load\nmodule for SHOWzOS should PREFERABLY be exactly matched to the level of\nsystem macros your installation has, for all installed components.\nThat's why we can't create ONE load module to exactly fit all the\ncomponents in your system's particular mix.  But File 614 is there for\nyou to use, so you can fire up SHOWzOS quickly on your system.  If there\nare any runtime errors, you can always reassemble SHOWzOS again later.\n\n      This topic will be continued next month.  I hope that you have\ngotten a bit wiser by reading this article.  At least, if it makes your\nmind work and \"gets the wheels turning\" a bit, I feel that I've done my\njob.  I wish all of you the best of everything, and I'm looking forward\nto seeing all of you here again, next time.\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 1.   A summary of SHOWzOS functions, taken from the\n            actual source code.  Many of the SHOWzOS displays\n            can be created, even if the SHOWzOS command is not\n            being run APF-authorized.  Which particular displays\n            need APF authorization to run, are indicated\n            below.\n\n\n               SSSS  H   H  OOOOO  W   W ZZZZZ   OOOOO  SSSS\n             S      H   H  O   O  W   W    ZZ   O   O  S\n             SSS   HHHHH  O   O  W W W    Z    O   O   SSS\n               S  H   H  O   O  WW WW   ZZ    O   O      S\n          SSSS   H   H  OOOOO  W   W   ZZZZZ OOOOO  SSSS\n\n      This program displays information obtained from various\n      control blocks of the MVS system on which it is run.\n      The information can be displayed under ISPF using EDIF or\n      BRIF, written to the TSO terminal using PUTLINE or to\n      a data set using QSAM.\n\n      SHOWzOS displays two different types of data:\n\n        1. Data related to the MVS operating system:\n\n           MVS LEVEL, DFP LEVEL, OSLVL FLAGS, JES2 LEVEL\n           IPL DATE, TIME, VOLSER, NUC-ID, CLPA, CVTUSER\n           Date and time of last CLPA                       (auth)\n           Time Zone, Primary sub-system name and type\n           Software Level: TSO/E, ISPF, DSS, HSM, RACF, VTAM, SORT\n                           DSF, DB2, CICS, MQ Series, TCP/IP, LE,\n                           IMS (v9 and higher)\n             Run-time Environments (CBL,PLI,FORTRAN,C,LE,REXX,SAS/C\n             RTLS)\n             SORT\n             LE runtime options (CEEDOPT, CEECOPT, CELQDOPT)\n           UNIX System Services\n             Settings\n             HFS Statistics\n             Files\n             PID\n             IPC\n           ISV software base CSRCTABL\n           ICSF configuration (Crypto)\n           SMF Information: SID, JWT, data sets, exits\n           SMS Configuration:  SCDS, system names, last update\n                               dataclas, mgmtclas and so on\n           HSM information\n           SDM information\n           GRS Configuration\n           Hardware configuration\n             Central Processing Complex Node Description (CPC ND)\n             On-line CPUs and storage\n             Performance (SU/sec, estimated MIPS)\n             Service Processor data\n             CSRSI support\n             Other CPU related attributes\n             I/O configuration Definition (IODF)\n             LPAR configuration\n           VM host information                              (auth)\n           VIRTUAL STORAGE MAP (CSA, SQA, LPA, etc)\n           Subpool attributes\n           Global Cellpools\n           Subpool Usage\n           Common Storage Usage\n           Dataspaces                                       (auth)\n           64-bit memory object and MEMLIMIT\n           CSM Communication Storage Manager\n           XCF Configuration                                (auth)\n             Path data                                      (auth)\n             Couple Datasets                                (auth)\n           Coupling facility                                (auth)\n           External timer                                   (auth)\n           Resource Manager\n           WLM data (MODE, etc)\n           SMF data for each ASID (enclaves, zAAP, zIIP)    (auth)\n           System Logger (IXGLOGR)                          (auth)\n           Resource Recovery Manager (RRS)\n           Automatic Restart Manager (ARM)\n           TCP/IP statistics, connections, listener         (auth)\n           OPEN catalogs\n           PAGE data sets in use\n           Dump data sets status and dump options\n             Dump data sets date, time and title            (auth)\n             Automatically-allocated dump data sets         (auth)\n           DAE Parameters                                   (auth)\n           SLIP data                                        (auth)\n           GTF status and options\n           DIAG settings\n           Initialization Parameters (IPA)\n           IPL-Statistic\n           Health Checker                                   (auth)\n           Master JCL (IEEMSJCL)\n           Sub-system vector table with functions processed\n           Primary Sub-system JCL                           (auth)\n           TCAS parameters                                  (auth)\n           TSO PARMLIB data (IKJTSOxx)\n           TSO Exits and Tables\n           RACF options, data sets and tables\n           UNICODE data\n           Address space usage:\n             Batch Jobs\n             TSO users\n             Started tasks\n             USS users\n             CICS regions\n               STEPLIB/DFHRPL (&VERBOSE_CICS switch)        (auth)\n             TCP/IP users\n           JES2 Initiators and corresponding jobs\n           JES2 Dynamic proclib                             (auth)\n           JES Monitor and Job class information            (auth)\n           Link-list data sets, with creation date\n           LPA-list data sets, with creation date\n           List of authorized libraries\n           Dynamic Exit Facility                            (auth)\n           Static system symbols\n           LLA parameters and managed libraries             (auth)\n           ACTIVE LPA QUEUE\n           SVC Table with name of the corresponding module\n           T1, T2, T3 and T6 ESR tables\n           Linkage Index (LX) Table                         (auth)\n           Auth Index (LX) Table                            (auth)\n           Cross Memory Connection (XMS)                    (auth)\n           Memory Delete Queue (MDQ)                        (auth)\n           PC usage (ETE)                                   (auth)\n           ENF Listener (ENF)                               (auth)\n           Timer Queue Elements (only DIE) (TQE)            (auth)\n           Program Properties Table (PPT)                   (auth)\n           I/O Appendage Table\n           Resource Manager List (IEAVTRML)\n           Products Information\n           Device Classes and corresponding unit names\n           On-line devices, with unit-name, VOLSER, owning job,\n                 use attribute, storage group\n           Channel Measurement (ECMB)                       (auth)\n           Config Data Record (CDR)                         (auth)\n           PAV info (PAV)                                   (auth)\n           Channel Path information\n           Channel Path Measurement Facility\n           System consoles, with status & Routcde list\n               EMCS-Consoles                                (auth)\n               CMDS                                         (auth)\n               Consol Query                                 (auth)\n           Master Trace Table (MTT)  see &MTTDATA           (auth)\n           Message Processing Facility (MPF)\n           Command Prefix Table (CPFT)\n           Name/Token information\n           Device Allocation Defaults (ALLOCxx)\n           Addresses of selected global control blocks\n\n        2. Data related to the current address space\n\n           JCL information for current JOB/STEP\n           RACF profile (from ACEE)\n           TSO profile (from PSCB & UPT)\n           ISPF Tso Command table (ISPTCM)\n           REXX environments, host cmd tables and func pkg\n               directories\n           Allocated Data sets (from TIOT, SWA, TCT)\n           TCB tree and PRB chain\n           Attention Routines\n           Enhanced view of the JPAQ and Load-lists\n           Local Cellpools\n           Recovery exits and timers\n           Local Name/Token\n           Addresses of selected local control blocks\n\n\n   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\n\nFigure 2.   Top few lines of a modern SHOWzOS Display.\n            On a small system, the display can be well over\n            7000 lines long!\n\n\n BROWSE    GSF Utilities - SHOWzOS R715               Line 00000000 Col 001 080\n Command ===>                                                  Scroll ===> CSR\n********************************* Top of Data **********************************\n\nSHOWMVS is running authorized\n\n>Operating System:\n\n  z/OS 01.08.00   FMID: HBB7730    CVTOSLVL: FF FF FF BF EB 60 00 00\n\n  DFSMS     1.8.0                  Feature : FF 6E 73 7F A0 30\n                          DFSMS Loader Fork Exit is present\n                          DFSMS RVA SnapShot is available\n                          DFSMS RVA SnapShot API is available\n\n  JES2 Level: z/OS 1.8    NJE Node: N1          DSNID: 01\n\n  SHOWzOS REL=R715 20070503 20.30 MVS=708 SMS=03010800 HLASM=1.5.0\n  OSREL=01010800 STRING=R515 Switches=E2C03FC000000000 Auth=Yes,ESR=IGX00011\n\n>Last IPL:\n\n  Date: Monday 2007-10-24 (Today)    Time: 01.29    Julian: 2007.297\n  From: S8RES1/0A80    NUC Id: 1    Type: Warm Start    CVTUSER: 00000000\n  Last Cold Start (CLPA) Date: 2007-10-22   Time: 13.27.14\n  Last Quick Start (CVIO) Date: 2007-10-22   Time: 13.27.14\n  SYSPLEX name: ADCDPL    SYSPLEX ID: 1A  Sysname: ADCD      Lparname:\n  Timezone: W 04.00.00 Leap Seconds: 0000000000000000\n\n>System Software:\n\n  TSO/E Level:   3.8.0\n\n  ISPF Level:    5.8     PDF 5.8\n\n  RACF Level:    7.73.0\n\n  ICKDSF Level:  1.17.0\n\n  VTAM Level:    6.1.8       VE618           00C7D008\n\n  LE Version:    1.8.0\n\n  MQ Series:     5655L8200   SSCTSNAM=CSQ1   Inactive\n  MQ Series:     5655L8200   SSCTSNAM=CSQ2   Inactive\n  MQ Series:     5655L8200   SSCTSNAM=CSQ3   Inactive\n\n\n  TCP/IP:        05.363 5655-HAL    MVPTASK\n\n    Tseb     SI Proc     Ver   Tsdb     Tsdx     Asid TraceOpts Status\n    107D5040 01 TCPIP    06.18 107BA000 107BA0C8 0017 00000000  Active\n\n     * * *    and much more....\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0712DE": {"ttr": 31745, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00R\\x01\\x074\\x0f\\x01\\x075\\x1f\\x11W\\x01\\x11\\x01\\x11\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2007-12-06T00:00:00", "modifydate": "2007-12-17T11:57:52", "lines": 273, "newlines": 273, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         DECEMBER 2007\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.\n\n\nDISPLAYING MVS SYSTEM VALUES - Part 2\n\n      Last month, we talked about the idea of looking at significant\nsystem values in an MVS system (z/OS or previous), which determine\ndifferent aspects of how the system will run.  Not only is it important\nto know about many of the system values connected with the various MVS\ncomponents, but it is also of great help, if you can figure out how the\nsystem itself gets to access these values.  Either way, the more you can\nfind out about the contents of MVS control blocks and control values,\nthe better you'll be able to get the most out of your MVS system.\n\n      It is true that in being an MVS systems programmer, the emphasis\nis more on \"looking at the system\" than on \"changing the system\".  And\nif you have tools (such as the free \"SHOWzOS\" or \"SHOWMVS\" tools we\nmentioned last month) to look at the current values in an MVS system,\nyou've done 70 percent of the work.  Nevertheless, once you've seen\n\"what is going on\", and you have a tool to CHANGE some value, the\npossession of an arsenal of such tools gives you a flexibility that can\nhelp your shop get more work out of the system.  But this flexibility\nmust come with knowledge.  Making a system value \"more wrong\", without\nknowledge, can be just as easy (and far more damaging) as making that\nsystem value \"more correct\".\n\n      IBM has made it much easier to change certain system values\nwithout an IPL in recent years.  Many adjustments can be made to many\nsystem values, by simply changing a PARMLIB member and by issuing an\noperator command to make that changed (or new) member \"active\".  We see\nthis with the IKJTSOxx PARMLIB members and the PROGxx and SMFPRMxx\nPARMLIB members as well as with quite a few others.  These can be\nactivated using an Operator SET command.  After the PARMLIB member has\nbeen made active with the SET command, its new values can usually be\ndisplayed using an Operator DISPLAY command.  So IBM has, in many ways,\nmade MVS system operation easier, and has made it possible to avoid\nIPLs, simply by giving us the ability to change certain system values\n\"on the fly\", while the system is running, and not requiring an IPL to\nchange those values.\n\n      In the old days, when more IPLs WERE required to change system\nvalues, wily systems programmers worked hard to write programs that DID\nchange these values \"on the fly\".  This would make \"the impossible\"\nPOSSIBLE, and would allow the sysprog to fix a situation which would\notherwise require a complete IPL that might bring the system to a halt\nin the middle of a workday.  This column was originally designed for the\npurpose of letting people know about such commands and programs that\ncould manipulate critical system values and change them easily and\nquickly while the system was up.  Many of these tools can be found in\nthe free \"CBT Tape\" utilities collection, at www.cbttape.org.  My\nrecommendation is to use the Updates page there first, before going to\nthe \"CBT\" page.\n\n      In practice, if you would experiment, sometimes changing a system\nvalue would work, and sometimes it wouldn't work.  Usually the problem\nwould be that the system did not recognize the new or changed values,\nand it would still use the old value.  Other times (more happily), you\nCOULD get somewhere by altering a system value in machine storage, or on\ndisk.  As with any complicated system, each case was different.  Systems\nprogrammers had to KNOW what to do, in each situation where a (wrong)\nsystem value could pose a problem, and you had to do something to set it\nright.  If there existed a tool to change that value, and the sysprog\nhad it in his or her pocket, this would make him or her a \"magic worker\"\nto fix the system and save it from having to be brought down.  Fixing\nthese types of problems helped the sysprog to earn his or her salary, by\nkeeping the machine up and running during productive hours.  For me, it\nwas always one of the thrills of the job, to know that I had saved a\nproduction day, on a multi-million dollar machine, from down time or a\ndisaster.\n\n\nDISPLAYING, VERSUS CHANGING, OF VALUES\n\n      When looking into computer storage, there is a very great\ndifference between DISPLAYING a system value and CHANGING that value.\nUsually, especially if the value is system-wide in scope, the system\nvalues are contained within some sort of protected storage.  Otherwise,\nany non-authorized user could come along and change a value critical to\nsystem operation, or corrupt it.  If any of you remembers back to the\nMVT days, many system areas were not adequately protected from user\nalteration then.  \"Security by ignorance\" was the rule then, more than\nthe exception.  But nowadays, MVS systems have much more need to be\nprotected from harm, against much more knowledgeable intruders, or from\napplication or system programmer blunders.  The stakes are higher today,\nand IBM takes protection of the system's \"family jewels\" much more\nseriously.\n\n      So it makes sense that just READING the value that's there, for\ndisplay purposes, shouldn't require a great degree of authorization,\nbecause one should usually be given the ability to determine the state\nof a machine, or of one of its component parts.  But ALTERING system\nvalues, of course, must always be done with care, knowledge, and (above\nall) authority to do so.\n\n      The systems programmer, when it comes to \"authority\", is always\nwalking on a fine line.  He or she is the \"system doctor\" who must fix\nwhat ails the machine.  Denying \"authority\" to the system doctor will\nsometimes prevent him or her from doing the job.  On the other hand,\neven though the system doctor can (and should) fix the \"system\"\nprograms, this person does not generally have the know-how to interfere\nwith the \"applications\" that are running on the machine, unless the\napplications people are also watching.  So there is some theoretical\nlimit to the system person's scope as well, and also to the \"authority\"\nthat might properly and fairly be granted to him, her, or them.\n\n      A given company's \"technical management\" people, being human\nbeings, might vary greatly in the degree to which they understand the\nneeds of the systems people, or \"trust\" them in doing their jobs.  I\nhave heard of a shop where it took the signatures of ten levels of\nmanagement just to authorize a PARMLIB change.  This is not a joke that\nsomeone made up.  A real shop (a very large one) actually operated that\nway!  If that were the case, or even if there were lesser restrictions\nimposed on things like PARMLIB changes, the sysprogs might actually need\nsome extra tools to change control block values, which IBM made \"easy to\nchange\" through the making of a new PARMLIB member.  Management, in that\ncase, simply closed the door that IBM opened.  In a pinch like that, or\nin a similar situation, when production is heavy and you \"can't change\nthings\", sometimes you have to \"change things\", and you need the tools\nto do so.\n\n      So the systems programmer (at least) needs APF authorization when\nit's necessary.  At least the management has to be understanding enough\nto grant THAT.  And once APF authorization of TSO commands and batch\nprograms has been granted to the sysprogs, it is then up to the sysprogs\nto make the most of it, each in one's own situation.  Therefore, I think\nit is an \"unofficial obligation\" on every systems programmer to write,\nor otherwise accumulate, a set of tools which takes advantage of APF\nauthorization, and which can accurately and consistently alter various\nsystem control blocks or control areas, as needed.\n\n\nMORE ABOUT DISPLAYING AND ALTERING\n\n      If you have gotten used to using a program like SHOWzOS, which we\nmentioned last month (source can be found on www.cbttape.org UPDATES,\nFile 492), then you see that it is very possible to display many many\nsystem values, even if you are not running the SHOWzOS TSO command APF\nauthorized.  However, changing any of the values with an incore zapper\n(I use Greg Price's IMON with the VB option - www.prycroft6.com.au) or\nwith a user-written program, is tricky at best, and you'd better know\nwhat you are doing when you try it.\n\n      For example, I attempted to change the active Broadcast Dataset in\nan MVS system by zapping a new name into the appropriate place in the\nIKJEESCB control block (in live storage), and a new volser for the new\ndataset's location.  At first, this didn't work, because before the\ndataset name, there is a one-byte field containing the length of the\nname.  And that was wrong.  The second problem was, that the system does\nnot know if the new \"Broadcast Dataset\" determined by the new name, and\nthe new location, really exists.  And if it does, is it properly\nformatted as a Broadcast Dataset, with the proper LRECL, KEYLEN, RECFM,\nBLKSIZE, and internal structure (header record first, and so forth)?\nWhen you do a PARMLIB UPDATE(xx) TSO command or a SET IKJTSO=xx Operator\ncommand to do a Broadcast Dataset Switch, the system programs verify all\nthat information before actually making the switch.  But if you zap the\nnew values directly into core, there is no such validation or\nverification taking place.  So when you change any system values by\nzapping core, you must either use a specialized program for the purpose\n(which verifies and validates all the housekeeping necessary), or you\nmust know everything that has to take place in order for the switch to\nbe successful.\n\n      I was (in practice) actually able to switch the Broadcast Dataset\nin this way.  But I just happen to know a lot of stuff about the control\nblocks involved, and about the internal structure of how the Broadcast\nDataset should be.  In another part of the system, I would be as much\n\"in the dark\" as anyone else, with regard to the structures and\nquantities that needed to be changed, in order to make any new system\nvalues work, be valid, and be completely consistent with what they\nshould be.\n\n      So my general rule is as follows.  Do not play with system values\nby changing them unless:\n\n1.  You know ALL the quantities that need to be changed in order to make\n    the new values work properly in the MVS system and with the\n    appropriate MVS support programs (in your current release of MVS).\n\nOR\n\n2.  You possess a program which has been debugged to do all these\n    changes, in a consistent manner with the way (your current release\n    of) MVS works.\n\nThis is a hard and fast rule.  Do not violate it, or you are asking for\na lot of trouble!\n\n      However, if you do want to FIND the control blocks pointing to the\nsystem values you want to study, then I would suggest that you study the\nSHOWzOS source code which does the finding, and trace the path taken by\nSHOWzOS, using the LOOK program or some similar core browser.  Then, once\nyou are sure about how to get to the place you want to see, you might want\nto write your own display program that displays the control block's system\nvalues.  If your program's display values are consistent with what SHOWzOS\nshows, then you can (probably) safely feel that \"you got there\".  After\nthat, you might do the research to properly change some of the values, and\nyou could write your own (probably APF-authorized) program to do just\nthat.\n\n\nTHE ART OF DISPLAYING\n\n      Displaying a number at a terminal, or in printed output, usually\ninvolves converting an internal quantity into EBCDIC display characters.\nIn Assembler language, if the original quantity was a number, expressed\nas fullword BINARY, this usually involves converting the number to\npacked decimal using the CVD (convert to decimal) instruction, and then\nusing the ED (edit) instruction to display the packed number on a\ndisplay line in EBCDIC characters.  If you don't care about leading\nzeros in the displayed numbers, you might want to use the UNPK (unpack)\ninstruction instead of the ED (edit) instruction to convert the packed\nnumber to EBCDIC display characters.\n\n      SHOWzOS has a specialized tool to do its number and character\ndisplays.  This is a macro (invented by Gilbert Saint-flour and his\nco-workers) called STRING or STRING64 (for the 64-bit version), which is\nquite complicated, and which does all the number conversions to EBCDIC\ndisplay characters automatically.  You can gain a lot by studying the\nSTRING and STRING64 macro source in CBT Tape File 492.\n\n      However, if you write a TSO command to display lines of numbers or\ncharacters at a terminal, you have to use either of two methods.  First\nis the simple method that uses the TPUT macro.  To use the TPUT macro in\na program, all you have to do is to put your data into a display line,\nand then issue TPUT on that display line for a certain number of\ncharacters.  For example, TPUT  LINE,30   which will output the first 30\nlines contained in field LINE, to the terminal.  This is very simple to\ncode.\n\n      There is a big drawback to using the TPUT macro method, however.\nThat is, if you run the TSO command under TSO-in-batch, you cannot see\nthe output displayed by TPUT.  Also, you can't SYSOUTTRAP any TPUT\noutput.  So in order to see terminal output under TSO-in-batch, you have\nto use another method of displaying it.  That method uses the PUTLINE\nmacro, which is much harder to set up and code, than is the TPUT macro.\nFortunately, there is a gizmo on the CBT Tape, in File 136, to convert\nTPUT code to PUTLINE code.  Here is what I do, to use this conversion\nmethod.\n\n      The conversion code (from TPUT to PUTLINE) consists of two parts.\nOne part is a macro, called APUT, which takes TPUT-like input and calls\nthe second piece, a subroutine called EPUTL.  EPUTL should be linkedited\ntogether with your TSO command.  EPUTL automagically sets up the entire\n(complicated) PUTLINE environment.  So just add the EPUTL source to the\nbottom of your TSO command's source, copy the APUT macro source inline\nto your TSO command source, and change every place where you coded a\nTPUT, to an APUT.  Usually, that's all it takes to convert the TPUT\nterminal display to a PUTLINE terminal display, and then you can see the\noutput after doing a SYSOUTTRAP or in a printed output display under\nTSO-in-batch.\n\n      I hope that this month's piece has made you a little bit wiser,\nby getting your own brain working in a new direction.  Displaying the\ncontents of MVS control blocks is always very instructive, but CHANGING\nsomething can be very tricky, because you have to know about all the\ninterrelated values that have been affected by any change in that area.\nPerform all system value changes with caution, or use a pre-programmed\ntool to do so, that has already been debugged and proven to be accurate.\n\n      I wish all of you the best of everything, and I'm looking forward\nto seeing you here again next month.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0801JA": {"ttr": 31750, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x17\\x01\\x08\\x00\\x8f\\x01\\x08\\x00\\x8f\\x19 \\x00\\xbb\\x00\\xbb\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-01-08T00:00:00", "modifydate": "2008-01-08T19:20:17", "lines": 187, "newlines": 187, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         JANUARY 2008\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also participates in\nlibrary tours and book signings with his wife, author Courtney Taylor.\nSam can be contacted at sbgolob@cbttape.org and/or\nsbgolob@attglobal.net.\n\n\nPROTECTING OUR CODE FROM SYSTEM ERRORS\n\n      This month, I'd like to talk about something that professional\ncoders generally do, rather than something that systems programmers\nnormally do.  But this topic is of much concern for us as systems\nprogrammers as well, and you'll soon see why.\n\n      Today I want to convey an appreciation for the fact that whenever\nwe enter a wrong parameter in a system utility, we don't get a crazy,\nhard to diagnose system abend, but rather a nice, polite little message.\nThis doesn't happen automatically when you write system code, but it has\nto be planned for.  Today we'll look at just a few of the wrong things\nthat can happen when we write system code, and at some of the\ncorrections we (as programmers) can make to intercept the problems and\nhave the program play nice.\n\n      We generally take \"protection from system abends\" for granted, and\nwe figure that the coders have already done all the work for us.  But\nprogrammers of system utilities often have to guard against bad looking\nand unnecessary crashes that seem to come from out of nowhere, when\nthey're testing out a new utility program.  And the coders, sooner or\nlater, learn to anticipate many of these.  Not all of us (being sysprogs\nwho don't code that often) generally have the chance to code a complete\nsystem tool for ourselves.  But when we do use a tool that has flaws, we\nALL NOTICE THE ERRORS immediately and are quite disturbed when they\noccur.  These errors don't have to happen, and we should appreciate when\nthe programmer has cleaned up his or her code to prevent them.  I'll\nshow you what I mean with a simple example.\n\n      Suppose that you are using a certain tool to flip a system bit on\nor off.  For instance, I'll invent an imaginary tool that makes a job\ncancelable or non-cancelable.  Let's say the tool is a TSO command which\nis called \"CANCL\".  You would use the tool as follows.  From a TSO tube,\nif you wanted to make job MYJOBA cancelable, you would enter the\ncommand: \"CANCL MYJOBA CNCL\".  And similarly, if you wanted to make\nMYJOBA non-cancelable, you would enter the command \"CANCL MYJOBA NOCN\".\nFair enough.  Now suppose additionally, that no provision was made by\nthe coder of the CANCL tool to enter any other subcommand besides CNCL\nor NOCN.  If a user would enter a misspelled subcommand like NOCL\ninstead of NOCN, he might get a SOC1 or a SOC4 abend (instead of an\ninformative message) with no meaningful further help forthcoming.  This\nresult certainly is very disturbing, and would render the CANCL tool\nnearly useless, unless you had some prior training and warning about not\nto enter the wrong subcommands.\n\n      Today we'll illustrate a few of the ways in which a coder can\nprotect the user from errors like this, just to give you an idea about\nwhat kinds of things have to be done.  When we are the user, we don't\ntend to appreciate the efforts which the coder had made to protect us\nfrom our own errors, or from the system's errors.  But when we are the\ncoder, it is critical to think of every possible thing that can go\nwrong, and to not any errors creep in which would bring about serious or\nconfusing consequences.\n\n\nONE EXAMPLE\n\n      Here is one example where the coder can \"silently\" protect the\nuser.  Suppose he has written a TSO command that has to be run APF\nauthorized, and it wasn't run that way.  The \"unprotected\" result will\nusually be a System 047 abend, which signifies that an \"authorized\nfunction\" was requested by this program, and since the actual program\nwas not run \"APF authorized\", this function cannot be fulfilled.  That\nwould happen when you just allow the Operating System to detect the\nerror, and the above S047 abend would probably be the result.\n\n      But now, if the programmer had anticipated the situation, he or\nshe could have coded a TESTAUTH macro with FCTN=1 before trying to\nperform the authorized operation in the code.  If the return code from\nTESTAUTH was not zero, this means that the code was not (at that point)\nrunning APF authorized, and a proper reaction by the programmer would be\nto issue an error message which says that \"This Program must be run\nAPF-authorized\".  After issuing that message, the program would exit.\nIf the return code from TESTAUTH WAS zero, then the program could go on\nto do its job.  Such a \"programmed protection\" will tell the user what\nwas wrong, and it also could give some hint as to how to correct the\nsituation.\n\n      So you can now see, that it is usually up to the programmer of any\nsystem tool, to protect the user from \"system errors\" as well as \"user\nerrors\" in using his/her tool.  And it is especially important for the\nprogrammer NOT to leave the user at the mercy of the Operating System\n(which will probably generate a barely decipherable abend, at best).  In\na worse case, an uncorrected user error might actually cause the program\nto flip the wrong bit, or it might incorrectly alter some other storage\nin a bad way.  Our emphasis this month however, is to show a few ways\nhow our trusty system tools shelter us from the operating system's very\nraw error mechanisms by intercepting \"error calls\" to the Operating\nSystem BEFORE they occur, and then clearly telling us what the error\nwas, AS it occurs.  WE (as programmers) can write the error messages\nfor our users more coherently than the operating system can!\n\n\nIF FILES ARE MISSING\n\n      Here is a situation which is not usually anticipated by the casual\nuser of a system tool, if that tool happens to require the allocation of\none or more files.  What if you leave out a DD name in the JCL, or\nsimilarly for a TSO command, what if you don't allocate (dynamically or\nstatically) a file that the program needs?\n\n      Here are a few of the possible consequences, if the programmer did\nnot make provisions to protect the program.  One example:  if you try to\nCLOSE a file that has not been OPENed, you get a nasty S0C1 abend.\nAnother example:  if you leave out a SYSPRINT DD name where the output\nof the program is supposed to go, and the program tries to WRITE to\nSYSPRINT.  Blooey!  Here comes another S0C1 (probably).  That's enough\nto mention, for now.\n\n      There are two tiers of protection for missing DD names, or in the\ncase of a TSO command, for missing file allocations.  The first tier is\nto do a TIOT scan to see if the DD name is even there.  If there's no DD\nname, then there isn't even a possibility to OPEN the file at all, much\nless to try and CLOSE it.  The second tier is to check, after an\nattempted file OPEN, to see if the OPEN really worked.  If you ran an\nOPEN macro to attempt to OPEN a file, and the OPEN failed, you need to\nknow that the file isn't OPEN.  Then, you wouldn't try afterwards to\nCLOSE the file.  Also, you might try and issue a message that the file\ncould not be OPENed.  After that, you'd exit the program gracefully.\nThis post-OPEN check is done by examining the OPEN flags, at (decimal)\nlocation 48 or X'30' past the beginning of the DCB being OPENed, to see\nif if the X'10' bit is turned on.  If that bit is not on, then the OPEN\ndidn't work, and you have to take the necessary measures to protect the\nrest of the program, and the user.\n\n\nIF FILES ARE IN THE WRONG FORMAT\n\n      Once you know that a file is there, and you have OPENed it, you\nmight then try to READ a record from it or WRITE a record to it.  But\nwhat if you need information about the physical file itself that was\njust OPENed, such as its DSORG (data set organization, PS, PO, etc.) or\nits Record Format (FB, VB, etc.), its record length, or its block size,\nor even extra information about the allocation, like if any secondary\nextents were asked for?  You find that out, in your program, by issuing\na RDJFCB (or Read The JFCB) macro.  The RDJFCB macro can be issued\nbefore or after an OPEN macro, and it brings the current contents of the\nfile's JFCB (Job File Control Block) into the program for your\nexamination.\n\n      Examining the JFCB by reading it with a RDJFCB macro, can expose\nmore subtle errors in your program, without having to force the user do\nthe diagnosis.  For example, if your program tries to write a long\nrecord to a file, and the record length of the file (as shown by an\ninquiry into the JFCB after a RDJFCB) is not big enough to accommodate\nthe long record, then you can make provision for that possibility\nwithout the user having to worry about it.  And this applies to many\nsimilar situations--just use your imagination.  In short, it is better\nfor the program to intercept an error than for the system to find it, or\nfor the error to cause an \"explosion\" that bursts unexpectedly on the\nuser.\n\n\nSUMMARY\n\n      Today, I've tried to give a small indication as to how the\nprogrammers of system tools have to work hard, to protect the users of\ntheir tools from being unnecessarily exposed to system errors or from\nbeing \"splattered to bits\" by simple user errors.  Of course,\napplication programmers also know very much about some of these\nprinciples.  But system tools, since they deal with system quantities\nand system storage, and they might also have to be run APF-authorized,\nhave special needs, to be able to run correctly.  I'm sorry that I don't\nhave space today, to go into more details.  But I trust that once you\nsee a few of the possibilities, you'll get the idea that there's more to\nwriting a system tool than to just get to the right place and perform\nthe right action.  The users (of the tool) have to be protected from\nunnecessary system abends, too.\n\n      I wish all of you the very best of everything, and a very happy\nand prosperous year.  I'm looking forward to seeing all of you here\nagain, next month.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0802FE": {"ttr": 31754, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x13\\x01\\x08\\x07?\\x01\\x08\\x07?\\x17\\x03\\x00\\xd0\\x00\\xd0\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-03-13T00:00:00", "modifydate": "2008-03-13T17:03:13", "lines": 208, "newlines": 208, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                         FEBRUARY 2008\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also\nparticipates in library tours and book signings with his\nwife, author Courtney Taylor. Sam can be contacted at\nsbgolob@cbttape.org and/or sbgolob@attglobal.net.\n\nCBT Tape Recent Developments - Part 1\n\n      Every once in a while, we devote an installment or two of this\ncolumn to displaying some of the newer contributions to the CBT Tape MVS\nUtilities collection, which have been either submitted recently, or have\nbeen considerably enhanced lately.  The CBT Tape collection can be found\nat www.cbttape.org, and you don't need to be a member of anything, or to\nknow a password, to get any of the thousands of software tools, large or\nsmall, which are posted there.  I've just looked at the title index for\nthis column, and I see that for several years now, I haven't written an\narticle of this type here.  So here goes an attempt at a half-decent\nsummary of as much of the new stuff as I can fit into this space.\n\n      The last column of this type was written in June of 2004, and\nafter looking, I've discovered that over 380 changes have been made to\nthe collection since then.  So even though I surely can't do justice to\na complete description of all those updates, I guess I can try to hit\nthe highlights by describing a few of them.\n\n      As of this writing, the newest changed files in the website at\nwww.cbttape.org are still in the UPDATES page, and not in the CBT page.\nTherefore, if you want to see the newest CBT files, please go to the\nUPDATES page at the www.cbttape.org website.  In general, I'd always\nrecommend going to the UPDATES page for any file you might be interested\nin, and only afterwards, if that file number isn't in UPDATES, only THEN\ngo to the CBT page and look there.\n\n      Even though the CBT Tape collection exists (primarily) as a\nwebsite, the collection still resides on real tapes.  The last actual\ntape that was cut, was Version 475, cut on Dec.  20, 2007.  All file\nupdates since Version 471, created on Feb. 28, 2006, are found (as of\nthis writing) on the UPDATES PAGE ONLY, at www.cbttape.org.\n\n\nTHE PDS TSO COMMAND, ETC.\n\n      One of the highlights of the CBT Tape collection has always been\nthe (practically indispensable for those who use it) PDS TSO command\ntool, whose source is found on File 182 of the CBT Tape.  The PDS\ncommand manipulates datasets, particularly partitioned datasets or\npds'es, hence its name.  The PDS command tool can do several thousand\ndifferent functions, literally, and is a great time saver for those who\nknow how to use it.  Since its original authors, mainly Bruce Leland and\nSteve Smith, made a commercial product out of PDS back in 1989 (it is\nnow called Startool FDM (TM), and distributed by Serena Software), John\nKalinich has continued to enhance the free version of PDS, still on the\nCBT Tape collection on File 182, for everyone to keep enjoying for free.\n\n      Every few months, John sends me a refresh of the PDS command\nsource, which he has kept working on, even as we write.  The main\nenhancement of PDS since 2004 has been (almost complete) support for\nPDSE's (extended PDS'es), which was added by John, with much help from\nGreg Price, whose REVIEW file browsing program (to be discussed next)\nfrom CBT File 134, has long supported PDSE's.  Versions of the PDS\ncommand which support PDSE's are called PDS 8.6, as opposed to PDS 8.5,\nwhich does not support PDSE's.  The current level of the PDS command\npackage, as of the time of this writing, is PDS 8.6.08.\n\n      John has supplied (in the $$$MODS member of CBT File 182) a list\nof new subcommands that have been added to the free PDS command package.\nThese are:\n\n   1. MXIBAT: DISPLAY (in the PDS log) MVS EXTENDED INFORMATION\n      CULLED FROM THE MXI PACKAGE (CBT Tape Files 409 and 410) if\n      MXI is installed on your system.\n   2. SRCHFOR: SEARCH MEMBERS WITH ISPF SEARCH-FOR PROGRAM\n   3. DISASM: DISASSEMBLE LOAD MODULE\n   4. DLINK: RECONSTRUCT OBJECT CODE FOR A LOAD MODULE\n   5. XMIT: XMIT MEMBERS WITH TSO TRANSMIT\n   6. OFFLOAD: OFFLOAD MEMBERS TO A SEQUENTIAL FILE\n   7. SMPGEN: CREATE SMP/E CONTROLS FOR MEMBERS\n   8. LMA: LIST DEBUG TOOL LOAD MODULE ANALYSIS INFO (if IBM's\n      LMA is installed)\n   9. CPKMAP: VOLUME TRACK MAP WITH COMPAKTOR (if FDR products\n      (commercial) are installed)\n\nMany additional changes to PDS 8.6.xx have also been documented in the\n$$$MODS member of File 182.\n\n      Since many additional (free) TSO commands and programs are\nnecessary to be present in your TSO environment for some of the\nsubcommands of PDS to work properly, these have now been packaged in\nFile 182 as an XMIT'ed load library, in member UTILXMIT.  Therefore, you\ndon't have to separately install all of these programs from their\nvarious source files on the CBT Tape.  Instead, you just have to TSO\nRECEIVE the UTILXMIT member of File 182, and you have a load library of\nall the necessary commands, to copy into your load library that makes\nall those commands accessible to your TSO session.\n\nENHANCEMENTS TO REVIEW (CBT FILE 134)\n\n      Bill Godfrey wrote the first version of the REVIEW TSO command in\n1980, as a general purpose file browser.  Starting in 1983 and\nunbeknownst to us until 1989 (because he lives in Australia and there\nwas no Internet then), Greg Price started enhancing the REVIEW command\nand adding features.  Greg has never stopped doing that.  Today REVIEW\nhas grown from 4,000-odd lines of code to (now) well over 50,000 lines\nof code.\n\n      Using the REVIEW command, you can now look at (browse) just about\nany kind of MVS file that exists, including VSAM and HFS files.  And now\nthere's a file EDITOR too, that looks like, and very much is used like,\nthe ISPF editor.  But REVIEW (and its editor) can be used in RAW TSO,\nwithout ISPF being present.  As a browser, if ISPF is present, REVIEW\nuses the available ISPF windows.  If ISPF is not present, REVIEW uses\nthe full screen under TSO.\n\n      One of the nicer uses for the REVIEW command is to look at SMF\nrecords in an SMF file, either the primary or secondary file on disk, in\nreal time, or at one of the backup SMF files, either on disk or on tape.\nREVIEW has a very unique ability to find all the SMF records you are\nlooking for, in an SMF file, and to format them for you, to show you\nwhat they mean.  If you're REVIEWing an SMF file (containing SMF\nrecords) and you want to format the records as you're seeing them, just\ntype the word SMF on the command line, and you'll see a lot of\ninformation about what the records really mean.  To find a given record\ntype, just enter the FS nn primary command, where nn is a record type.\nYou'll find the first record of that type, like FS 21, which finds the\nnext Type 21 SMF record.  FS 21 ALL will find ALL of the Type 21 records\nin the file, starting from the position (in the file) where you\ncurrently are.\n\n      As of this writing, the REVIEW command is at level 41.0.  If you\nreally want to know the principal changes that have occurred in REVIEW\nsince mid-2004 levels 38.x and 39.0, please refer to the REVNOTES member\nof File 134 at the bottom of the member.  I don't have space to include\nall of the level 41.0 changes, but the REVEDIT (the REVIEW editor)\nchanges should be of interest to all of you.  They are as follows:\n\n   R41.0 enhancements to REVEDIT include:\n   - add TF and TS line commands.\n   - add SORT primary command.\n   - add CREATE and REPLACE primary commands.\n   - colon command prefix applies command to current line. eg.\n     :TS\n   - support ASM highlighting of source code in a jobstream.\n\n      So you see that the REVIEW EDITOR (invoked by an UPDATE subcommand\nin REVIEW) is now becoming more and more ISPF- like.  Remember that you\ncan do file editing with REVIEW even under RAW TSO, with no ISPF present\nat all.  So REVIEW is a fine recovery tool to have, when ISPF won't come\nup.  Load modules for the REVIEW command, and all the subprograms and\naliases it uses (including HEL and FSH - fullscreen scrollable TSO\nHELP), can be found in the load library on CBT File 135.  So\ninstallation of REVIEW can be supremely easy.  Just copy the correct\nload modules from File 135 and make them accessible to your TSO session.\nSee File 134, member REVINST, for further help in installing REVIEW.\n\nLIONEL DYCK'S STUFF, AND MORE\n\n      Lionel Dyck has quietly accumulated a large collection of very\nuseful tools, in CBT Tape Files 312, 313, and 314.  Lionel is an old MVS\nhand, and he has made many contributions to the field of MVS sysprogging\nfor a long time.  Since Lionel's contributions to the CBT Tape are so\nmany, I had to break them into three files, with the member names in\nalphabetical order.  Lionel's personal website is www.lbdsoftware.com,\nbut his stuff is also on Files 312 thru 314 on the CBT Tape, and Lionel\ntries to keep the CBT Tape collection current, with his latest updates.\n\n      Probably the best-known of Lionel's many applications is XMITIP, a\nsystem of sending emails from an SMTP session on your MVS machine.  This\nis no ordinary simple email application.  There are extremely many bells\nand whistles found in XMITIP, where you can change or format practically\nanything you want to put into an email.  There is even an XMITIP news\ngroup on www.yahoogroups.com which is a forum for XMITIP enhancement\nsuggestions and questions.  XMITIP is found on CBT File 314, because it\nbegins with an X, at the end of the alphabet.\n\n      Another of Lionel's famous applications, is FTPB, an ISPF dialog\nwhich makes it easy to send FTP transmissions in either the foreground\nor as JCL, to make a batch job.  FTPB is found on File 312.  Another\nFile 312 gem, which I use all the time, is LSTPROC, a small REXX\napplication which reads your JES2 PROCLIB list, allocates the PROC files\nin SHR mode, and invokes ISRDDN to display the PROCLIB concatenations.\nThis is very simple to use, and it beats all the alternatives.\n\n      A third small application that is very useful, is Lionel's PARMLIB\nchecker, called PRMCK.  This is a REXX that checks the syntax of PARMLIB\nmembers, and is therefore very useful.  I don't have more space to\nelaborate here, but I suggest that you download Files 312, 313, and 314\nfrom the UPDATES page of www.cbttape.org, and see Lionel's gems for\nyourself.\n\nTO BE CONTINUED\n\n      Today, I could only hit some of the bigger packages and their high\npoints.  To do any justice to the CBT Tape files and how they have\nchanged in the recent past, you'll have to go to www.cbttape.org and\nlook at the UPDATES page to see for yourselves.  Nevertheless, I hope to\ncontinue on this topic next month, and talk about some of the newer\npackages on the CBT Tape collection which are very innovative and novel.\n\n      I wish all of you the best of everything, and I hope to see you\nhere again, next month.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CM0803MA": {"ttr": 32003, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00F\\x01\\x08\\x07\\x7f\\x01\\x08\\x07\\x7f\\x12\\x01\\x00\\xd2\\x00\\xd2\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-03-17T00:00:00", "modifydate": "2008-03-17T12:01:46", "lines": 210, "newlines": 210, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           MARCH 2008\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also\nparticipates in library tours and book signings with his\nwife, author Courtney Taylor. Sam can be contacted at\nsbgolob@cbttape.org and/or sbgolob@attglobal.net.\n\nCBT Tape Recent Developments - Part 2\n\n      Every once in a while, we devote an installment or two of this\ncolumn to displaying some of the newer contributions to the CBT Tape MVS\nUtilities collection, which have been either submitted recently, or have\nbeen considerably enhanced lately.  The CBT Tape collection can be found\nat www.cbttape.org, and you don't need to be a member of anything, or to\nknow a password, to get any of the thousands of software tools, large or\nsmall, which are posted there.\n\n      Last month, we talked about three of the biggest contributions (or\ngroup of contributions in Lionel Dyck's case.) of software in the CBT\ncollection that are useful for MVS shops.  These were the PDS package\nfrom File 182, the REVIEW package from File 134, and Lionel Dyck's big\ncollection of packages on Files 312, 313, and 314, which includes (but\ndefinitely is not limited to) his XMITIP package that is a comprehensive\nand very rich facility to send emails from an MVS system.\n\n      Today, we'll continue by describing some of the other new and\nimproved software programs and packages in the CBT Tape collection.\nAgain, the list is long, and we're not going to come near to getting to\nthe end of it.  But I'm here to whet your appetite, and if you explore\nthe CBT Tape collection for yourself, I'd bet that you see quite a few\nsoftware items that you'd put on your own wish list.  Since these\nprograms and packages are already available and they're free, your\nwishes will turn to reality very quickly, just for the downloading and\ninstalling of them.\n\n      Of course I have to add the caveat that since these programs are\nfree, no warranties come with them, but by and large they usually (at\nleast in many cases) have been thoroughly tested (by users like you and\nme, and by the authors), though the degree of testing will have varied\nfrom package to package.  Most of the time, you have access to source\ncode (or to the program authors), so fixes can be made or obtained\nrather quickly in many cases, practically speaking.\n\n\nPACKAGES, PACKAGES, PACKAGES\n\n      We can start by talking about CBT File 708, which is an automation\npackage by Glenn Siegel called MPFXTALL.  MPFXTALL works as a\ngeneralized MPF exit, and it can be rigged up to automate your startup\nand shutdown procedures, for example.  But MPFXTALL can do anything that\nany MPF exit can do.  As an MPF exit, MPFXTALL can get control very\nearly in the IPL process, so therefore you have very complete startup\nand shutdown coverage.  Glenn himself includes MPFTXALL into the systems\nhe sets up, so this package has been tested quite thoroughly.\n\n      Mark Zelden's large collection of tools is on CBT Tape File 434,\nwhich he updates quite frequently.  Many of Mark's tools are written in\nREXX, so they are quite easy to install.  One of the key members of this\ncollection is Mark's IPLINFO program, a REXX exec that displays (under\nISPF BROWSE or even under TSO READY mode) many statistics about your\nlatest IPL, the Link List, LPA list, APF library list, subsystem info,\naddress space statistics, startup parms, a virtual storage map, and\nmore.  This stuff was all obtained using REXX!\n\n      Mark has a half-zillion other tools in his collection.  One useful\nsubset of them is ZBROWSE, ZEDIT, and ZVIEW.  When you're editing a file\nwhich contains a dataset name, just put the cursor on the same line,\nenter ZEDIT, ZVIEW, or ZBROWSE on the command line, and you'll EDIT,\nVIEW, or BROWSE, that dataset!  For TSO commands which use the PUTLINE\ndisplay interface, you can capture their output and BROWSE, VIEW, or\nEDIT it, using Mark's TSOB, TSOV, and TSOE commands.  Just say TSOB,\nTSOV, or TSOE before issuing the TSO command whose output you want to\ncapture.  Mark also has a way to make a one-pack or a two-pack MVS\nsystem out of your current (full size) MVS system, so you can\nconveniently make a \"rescue system\" for yourself.  Just look at his\nONEPAKxx and TWOPAKxx members on File 434.  Mark's stuff is definitely\nworth exploring, installing, and (in some cases) customizing for\nyourself.\n\n      Gilbert Saint-flour is the original author of the fantastic\nSHOWMVS program, which now is on File 492 and is maintained by Roland\nSchiradin.  The latest (64-bit) versions of SHOWMVS are now called\nSHOWzOS.  SHOWzOS displays a huge number of internal MVS quantities from\nboth the entire running MVS system, and from the invoker's TSO session.\nInformation from a huge number of internal MVS control blocks, both\ndocumented and undocumented (by IBM) are displayed.  This is a program\n(a TSO command) that you ABSOLUTELY HAVE TO try for yourself.\n\n      Gilbert's OTHER stuff is on CBT Tape File 183.  There, Gilbert has\nwritten, or supplied us with, so many original tools that it boggles the\nmind.  I'll mention just a few of them, and what they do.  One handy\ntool is a TSO LOGON reconnect exit, IKJEFLN2, which allows your TSO\nsession to switch from one tube to another, through the execution of the\nVTAM command:  VARY NET,TERM,TYPE=COND,NOTIFY=NO,SLU=tubelu  where\ntubelu is the LU (logical unit) of the new terminal.  Gilbert sells an\nimproved version of this IKJEFLN2 exit with a graphical interface, but\nhis free version is quite fine.\n\n      Now we'll mention a few of Gilbert's more novel programs, the like\nof which are hard to find elsewhere.  I have to tell you that I'm not\ngoing to come close to mentioning all of them.  You have to look at CBT\nFile 183 for yourself.\n\n      A REXX exec called VSAVE operates as an edit macro, but in a VIEW\nsession, to SAVE the member being VIEWed, just as a SAVE command will\nsave a member being edited.  Ever have trouble deleting an uncataloged\ndataset because another dataset with the same name was OPEN?  Well,\nGilbert's BYPASSNQ batch program will solve that.  Another program is\ncalled DONTFAIL.  If a batch job has multiple inputs, and one of them\nisn't cataloged or isn't there, DONTFAIL will allow the job to \"not\nfail\" by DUMMYing out the DD name that isn't there.  Gilbert's BR TSO\nprogram allows you (if ISPF is present) to browse most VSAM and BDAM (as\nwell as normal non-VSAM) data sets.  BR may be invoked as a TSO command,\nas a program, or as an EDIT macro.  LINKLLA is a batch program to\nsimulate a \"REFRESH LLA\" command in a batch job.  Three scenarios are\npossible.  You can refresh a whole library, or a single member, or you\ncan linkedit a load module into an LLA managed library and refresh it in\na single step.\n\n      A subset of Gilbert's utilities which he has reworked to operate\nat the (very old) MVS 3.8 level under Hercules, can be found on CBT File\n749.  And I haven't even begun to scratch the surface in listing many of\nGilbert's innovative programs.  We must go on.\n\n\nNEW CONTRIBUTIONS\n\n      We have been blessed with contributors.  Now, I'll mention a few\nof the latest contributions to the CBT Tape collection, among many\nothers of them.\n\n      Steve Bacher has donated much of his life work, in several\nprogramming languages:  Assembler, C, and PL/I, to the CBT Tape\ncollection, in File 772.  Arthur Fichtl has contributed an interactive\ndisassembler that can disassemble a chunk of storage in a dump.\nArthur's contribution is in CBT File 773.  Craig Schneiderwent has coded\na proof of concept application which allows CICS COBOL to respond to\nHTTP requests.  Craig's program is in CBT File 775.  Robert Prins, of\nRPF fame (an ISPF-like editor found in Files 415 (non-XA) and 417 (XA))\nhas contributed a very novel set of REXX execs that are run as ISPF edit\nmacros.  These macros turn code, from various programming languages,\ninto HTML source.  Optionally, these REXXes will invoke a browser to\ndisplay the resulting HTML code.  Rob's HTML stuff is found in CBT File\n769.\n\n      Let's mention just a few more of the newest things.  Daniel Gaeta\nhas contributed (CBT File 767) a frontend for TRSMAIN to TERSE and\nUNTERSE files in TRSMAIN compress format.  Daniel Gaeta has also\ncontributed (CBT File 778) a set of programs to access the SMP/E API,\nGIMAPI, through REXX variables, to produce reports from SMP/E zones.\nSteve McColley, who is the current maintainer of what used to be called\nthe \"JES2 Mellon Mods\", has contributed extensions to the original mods\nand has included additional exits, at the z/OS 1.7 and 1.8 levels, in\nCBT File 766.  As far as I know, the original \"Mellon Mods\" JES2\nfunctions are still there too.\n\n      Ken Fitzgerald has contributed an entire package called LOGGRASM\n(CBT File 757).  According to his description: LOGGRASM is a utility to\nperform basic source setup of an Assembler program, and to log basic\ninformation about an Assembler program during execution. This utility\nprovides a method to show program execution in Assembler language\nprograms.  LOGGRASM is a tool to assist students and new programmers in\nlearning Assembler on a mainframe.  Ken has already taken LOGGRASM\nthrough five revisions, since having first submitted it to the CBT\ncollection.\n\n      Rick Bourgeois (CBT File 768) has converted my File 533 programs\n(named VTT2****) to run under VM and CMS.  These programs will take a\n\"real tape\" and convert it into either an AWS-format disk file, or a\nFLEX-ES FAKETAPE format disk file, and vice-versa.  From one of those\ndisk files, you can actually cut a real tape.  These programs make it\npossible to archive your large collections of tapes into a few DVDs or\nCD-rom disks.  They also makes it possible for expired or expiring\nFLEX-ES users to convert their FAKETAPE format tapes, so they will run\nunder other MVS systems.\n\n      Let's mention just a few more new things, before ending.\nKarl-Heinz Doppelfeld (CBT File 771) has contributed an ICSF (Integrated\nCryptographic Service Facility) monitor written in REXX, which displays\nvarious ICSF statistics.  Edgar Hofmann (CBT File 776) has contributed a\nrevised version of RECV390 to expand an XMIT-format MVS file on a PC.\nPhilippe Cochy has contributed CBT File 777 which contains a REXX exec\nto read a dcollect report and check disk space occupancy.  This REXX\ncontains an original algorithm to filter dataset names.  Roland\nSchiradin has upgraded his COBANAL program (CBT File 321) so it will\ninterpret load modules from the latest versions of COBOL.  Tom Conley\n(CBT File 495) has upgraded his \"Dynamic ISPF\" package (which helps you\nallocate files for individual ISPF applications, as needed) to a new\nrelease level.  Bill Godfrey (CBT file 741) has contributed his MAKEB64\nprogram that encodes/decodes a text file to/from BASE64 format.  Bill\nBass (CBT File 779) has contributed a very clever COBOL program which\nlooks at a job in SDSF and performs symbolic substitutions based on the\nsymbolic substitutions made by the Converter and the Interpreter.\n\n\nTHINGS ARE EXCITING\n\n      So I'm very happy to report that the CBT Tape collection is a\ndynamic and ever-changing environment.  Go to www.cbttape.org, look\nat the Updates page, and see for yourself.\n\n      All the best of everything to all of you.  I'm looking forward\nto seeing all of you here again, next month.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0804AP": {"ttr": 32007, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x006\\x01\\x08\\t\\x9f\\x01\\x08\\t\\x9f\\x12#\\x00\\xf3\\x00\\xf3\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-04-08T00:00:00", "modifydate": "2008-04-08T12:23:36", "lines": 243, "newlines": 243, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                           APRIL 2008\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also\nparticipates in library tours and book signings with his\nwife, author Courtney Taylor. Sam can be contacted at\nsbgolob@cbttape.org and/or sbgolob@attglobal.net.\n\n\nTAPE MAPPING, TAPE MEASURING, TAPE COPYING\n\n      Physical tapes have not gone away yet.  Nor are they likely to go\naway in the foreseeable future.  Even though we don't deal with tapes\nnowadays as often as we used to, I think it is still valuable for us to\nknow something about the structure, measuring, and mapping of a \"tape\",\nwhether it be a real tape, or a \"virtual tape\" in a Virtual Tape\nLibrary, or whether the physical media is on an old-style reel, or on a\ncartridge.  Tapes are still a part of our lives, and we ought to have\nthe tools to look at what's inside them and to analyze them.\n\n      Back when I first started, I'd look at a tape, and the only way\nI'd know anything about what was on it, was by looking at the physical\npaper label (if it had one).  A bunch of tapes in a pile, have a funny\nway of \"looking identical to each other\" unless there are paper labels\non them.  Later, I learned about tools which can read what kind of\ncontents a tape has, even if it doesn't have a paper label.  These are\nthe \"tape mapping\" tools.  Then there are the \"tape copying\" tools,\nwhich copy the contents or data blocks from one tape to another,\nfaithfully reading each block from the input tape, and copying it to\none or more output tapes afterward.\n\n      What do \"tape mapping\" programs and \"tape copying\" programs have\nin common?  Let's look.  Since both of these kinds of programs will\noperate by reading an \"input tape\", they will also be capable\n(potentially) of measuring the tape and looking at the tape's data as\nthey are reading each block.  So if you program them properly, this\nclass of programs is exposed to information that can tell you about how\nmuch tape data there is, what the data is, and how big each of the data\nblocks is, in each tape file.  These programs share the common mechanism\nof reading all the blocks on a tape.  After they do that, it just\ndepends on how the program is made to evaluate the data that it has been\nexposed to.\n\n      Therefore, as they are reading data from each tape block, these\nprograms can be made to examine and analyze that data, measure the size\nof the blocks, and count the blocks at the same time.  It all depends on\nthe programming which is used to ANALYZE or DISPLAY the tape blocks as\nthey pass through the program.  The kind of programming necessary to\naccomplish these various tasks, and tell us what we want to know about a\ntape, is what we are going to talk about next.\n\n\nREADING TAPE DATA BLOCKS\n\n      Most tape mapping and tape copying programs use either the EXCP\n(EXecute Channel Program) or BSAM (Basic Sequential Access Method)\naccess methods to read the tape blocks.  You can use QSAM (Queued\nSequential Access Method) to read tape blocks, but QSAM is not practical\nto use for tape mapping and copying programs in most cases, because when\nyou encounter an unknown tape, you don't know in advance, what its\nrecord structure will be like.  The BSAM and EXCP access methods are\nmuch more flexible regarding that.  QSAM requires some previous\nknowledge of the record structure which will be read.\n\n      Remember that tapes are one-dimensional and sequential in\nstructure.  Using EXCP is the most \"native\" or \"assembler-like\" way of\ndoing I/O programming.  BSAM is a bit more like a higher-level language.\nWith BSAM you use READ and WRITE macros, and you don't directly access\nthe tape device's operation codes.  With EXCP you do.  Therefore, if you\nare using EXCP to read a tape, you have to know the specific device\noperation codes that can manipulate the tape device.\n\n      EXCP operation codes for tape drives can be found in the tape\nhardware manuals, such as the 3480 or 3490 hardware manuals, but I'll\nsummarize a few of them that we use often.  X'02' is to READ a block of\ndata from the tape.  X'01' is to WRITE a block of data to the tape.\nX'03' is a \"no operation\" or a NOOP which does nothing (but you need it\nas a placeholder and for status reporting when you write channel\nprograms).  X'3F' is to forward space the tape (FSF) for one or more\nfiles.  X'2F' is to backward space the tape (BSF) for one or more files.\nX'07' is the REWIND code, to rewind the tape to the beginning.  X'27' is\nto backspace one or more blocks (BSB).  X'37' is to forward space one or\nmore blocks (FSB).  X'1F' is to write a tape mark (which separates\nbetween tape files).  These are most of what we need in a tape mapping\nor tape copying program.\n\n      These operation codes are incorporated into \"Channel Command\nWords\" or CCWs, which are the individual instructions to the tape\ndevice.  Strings of CCWs are incorporated into \"Channel Programs\" that\nare executed by the EXCP instruction, but more on that, later.  Included\nin the CCWs are a 3-byte data area address (4 bytes for Format 1 CCWs)\nto read the data into, or to write the data from).  At the end of the\nCCW is a halfword count field, which for READ or WRITE operations means\nthe number of bytes to read or write.  Included also, is a bit called\nthe SILI bit, which (if it's on) tells the CCW that the READ or WRITE\ncount is only a maximum, but if the CCW runs out of bytes while it is\nexecuting a READ or a WRITE, it should stop, and report the number of\nbytes of the total actually NOT YET WRITTEN or NOT YET READ by the\noperation.  Technically, that number is called the \"residual count\" of\nbytes NOT READ or NOT WRITTEN.  So if you subtract that number (the\nresidual count) from the maximum count number in the CCW, you will get\nthe number of bytes that were actually read or written.  That is very\nimportant for us to know, because it enables us to measure the amount of\ndata bytes in each data block on a tape.\n\n      As the tape program executes Channel Programs to read the tape\nblocks (the address of the strings of CCWs are included in an IOB (an\nI/O Block) and you actually EXCP the I/O Block) and you are reading\nblocks of data into an input area in your program, you then can actually\nSEE THE DATA that was in the tape block just read.  At this point, you\nknow how many bytes of data that were in the block, and you have copied\nall of this data into your program's \"input area\" in main storage.  This\naction makes it possible to analyze and measure (or copy) the data that\nis on the tape, one block at a time.\n\n\nIT ALL DEPENDS ON THE PROGRAMMING\n\n      Now that we know we have access to all the data blocks on the\ntape, one at a time, the next thing we have to do is to write code in\nthe tape mapping or tape copying program, so that it will REPORT\nsomething about the information it has seen.  At this point, we need to\nsee some ideas about the kinds of information we might like to report.\nWe'll throw out some suggestions.\n\n      First, the program might want to differentiate between whether it\nis looking at a tape label, or whether it is looking at data.  Second,\nif the program \"knows\" it is looking at a label, it might want to report\nall the information that is contained in the label.  Third, while the\nprogram is reading tape blocks and counting how many bytes are in each\none, it might report many statistics concerning those figures (minimum\nblock size, maximum block size of records in the file, and so forth).\nYou can use your imagination as to what might be useful information to\nreport from a block scan.  Also, with a labeled tape, where the RECFM\n(record format) and LRECL (record length) and BLKSIZE (block size) and\nother file characteristics are reported in the labels, the program might\ntry to compare those numbers (side by side) to the actual numbers it\nfound when it scanned the actual tape data blocks by reading them.\n\n      If you've ever used DITTO to read a tape, you know that you can\nsee a HEX print of the actual bytes in the tape records.  Your program\nmight want to do this, but you probably would not want to make the\nreport too long.  So one idea, would be to hex print the first 100\nbytes, or the first 132 bytes of the first few blocks in each tape file,\njust to give the reader an idea about what kind of data is there.  Of\ncourse ASCII tape labels are rather rare in MVS systems, but they do\nexist.  And you might want to treat ASCII labels as though they are\nlabels, and not as raw data.  So (it's difficult but doable, and) if\nit's worth your while, you might look into the \"Using Magnetic Tapes\"\nmanual and see how ASCII tape labels are different from the usual EBCDIC\ntape labels.  Our idea is that the sky is the limit, and it only depends\non how much work you want to put in, to report whatever information\nabout a tape that you feel is useful.\n\n      If this kind of programming job sounds too daunting for you, or\nyou just don't have the time right now, you can rest assured that if you\nget some of the existing tape mapping and tape copying programs, many of\nwhich are free, a lot of this \"reporting stuff\" has already been done\nfor you.  That's what we are going to talk about next.\n\n\nEXAMPLES OF TAPE MAPPING AND TAPE COPYING PROGRAMS\n\n      Many tape mapping and tape copying programs can be found in the\nCBT Tape collection, all of which is free to anyone to download and use\n(go to www.cbttape.org).  I would recommend looking in the Updates\nsection first, to get the latest version of each \"CBT tape file\", before\nlooking in the \"CBT\" section for that file number.\n\n      I would say that the best general tape mapping program in the CBT\ntape collection is probably the TAPEMAP program from CBT File 299.  I\nwould probably recommend, for making exact copies of an existing tape,\nthe COPYMODS program from CBT File 229.  TAPEMAP is best used with no\nparms or extra options.  Just run the TAPEMAP JCL \"vanilla\".  On the\nother hand, the COPYMODS program, which can make from one to 16 copies\nof a tape in a single run, or it can just read a tape and report\nstatistics about it, has many options and possibilities which may be\nentered via EXEC PARM field or SYSIN card.  If you use the COPYMODS\nprogram, it might pay for you to investigate the possible parms, to see\nall the stuff that COPYMODS can do.\n\n      If you want to copy all or selected SL files from a Standard\nLabeled tape, you may try the COPYFILE program, also on CBT File 229.\nCOPYFILE allows you to select any files from the input SL tape by file\nnumber, and put the copied files, one at a time, in any order on the\noutput SL tape.  COPYFILE, with all its file number selectivity, has two\nother programs associated with it, also on CBT File 229.  One of them is\ncalled COPYSLNL, which produces an NL output tape from the SL input tape\nby stripping the labels off (COPYMODS can also do this if you say\nPARM=STRIP).  The second dervied program from COPYMODS is called\nCOPYNLNL, which is intended to deal with NL tapes and to copy selected\nfile numbers from them, onto an output tape.  I trust that if you play\nwith these programs, you will find them to be very useful tools in your\npersonal toolbox.\n\n      Getting back to the TAPEMAP program, I have to say that the\ninteresting thing about it, is that it can show you about tape files\nwhich have been created in certain formats.  For example, if a tape file\nwas created by IEBCOPY, TAPEMAP, in its SYSPRNT2 DD name, will tell you\nall the member names that were dumped by IEBCOPY from the original pds.\nTAPEMAP can tell you about IEBUPDTE dumped files, FDR tape file headers,\nSMPPTFIN format files (it reports the PTF numbers) and others.\n\n      The first report from TAPEMAP, the SYSPRINT DD, includes much\nuseful information from the tape labels, if any, and it compares this\nlabel information to the results of its scan of the actual tape blocks.\nThe SYSPRINT report from the File 299 TAPEMAP program also tells you\nwhich input format that each tape file is in, if the program knows how\nto detect it.  Obvious things, such as Dataset Name from the labels,\nblock counts and maximum block sizes found from the scan, and\napproximate relative footages for each tape file, are also reported in\nTAPEMAP's SYSPRINT DD name.\n\n      There are many other tape mapping and tape copying programs on the\nCBT Tape collection.  I don't have time now to tell you more of the\ndetails about them.  The main idea is that they all do approximately the\nsame thing and have similar function.  The differences are mainly in the\nREPORTING, and the kind and extent of the reporting.\n\n\nSUMMARY\n\n      Tape mapping and tape copying programs all do approximately the\nsame thing.  That is, they read the input tape, block by block, and copy\neach block into some storage that is accessible to the program.  How\neach program uses the information so obtained, is where each of these\nprograms differs from the other programs of this type.  Reading of the\ntape blocks usually has to be done using the EXCP or BSAM access\nmethods, in order to ensure the maximum flexibility and ability to read\nunknown tape data.  As far as reporting goes, it is up to the programmer\nto determine which information he or she needs or thinks is useful to\nreport.  Free examples and source code for a good number of tape mapping\nand tape copying programs can be obtained from the CBT Tape collection\nat www.cbttape.org.\n\n      I wish all of you everything good, and I hope to see you here\nagain next month.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CM0805MY": {"ttr": 32012, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00(\\x01\\x08\\x12_\\x01\\x08\\x12_\\x16\\x03\\x00\\xd7\\x00\\xd7\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-05-04T00:00:00", "modifydate": "2008-05-04T16:03:28", "lines": 215, "newlines": 215, "modlines": 0, "user": "SBGOLOB"}, "text": "                MVS TOOLS AND TRICKS OF THE TRADE\n                            MAY 2008\n\nBy Sam Golob and Courtney Taylor\n-- --- ----- --- -------- ------\n\n                                      Sam Golob\n                                      MVS Systems Programmer\n                                      P.O. Box 906\n                                      Tallman, New York 10982\n\nSam Golob is a Senior Systems Programmer.  He also\nparticipates in library tours and book signings with his\nwife, author Courtney Taylor. Sam can be contacted at\nsbgolob@cbttape.org and/or sbgolob@attglobal.net.\n\n\nPRESERVING YOUR TAPES FOR POSTERITY\n\n      Over the nearly 30 years that I've been in this field, most people\nwho've worked with us and talked with us have taken \"progress\" for\ngranted.  Everything has been improved.  The hardware is always getting\nbetter and faster.  The disk drives are getting better, bigger, and\nfaster.  The old clunker green-screen terminals have been taken over by\nmulti-color emulators running on the PC.  And, of course, software\ndevelopments abound, both in the operating system software, and in the\napplication software.  Recently, the software that is avalable for the\nPC's themselves, has taken several quantum leaps forward, so it seems.\nAnd the new capabilities of the hand-held computers and mobile phones\nblow the mind away.  Modern times sure are exciting!\n\n      How does all this reflect on the world of tapes?  Let's think\nabout it.  Tapes were always the \"overflow medium\" and the \"archive\nmedium\" for MVS systems.  In the early days, tapes had bigger capacities\nfor holding data than did disk packs.  So when you wanted to back up or\npreserve the data on disk packs, you'd back them up to tape.  Now, with\n\"redundant copying\" of data on disks, with bigger and faster disks, with\n\"virtual tapes\" that are really disk files, and with far faster data\ntransmission speeds to duplicate current data at remote locations, it's\ndeveloping that people are really moving away from the concept of using\ntapes for archiving data.  MVS (read z/OS) installations are having a\ntendency to keep fewer and fewer tape drives.  In the current\natmosphere, we've even heard of some installations who are considering\ngetting rid of all, or most of their tape drives altogether.\n\n      This doesn't mean that tapes are getting useless.  First of all, a\ntape backup will preserve a \"snapshot\" (so to speak) of the contents of\na disk AT ONE PARTICULAR TIME.  Having a record like that can be very\nimportant.  It's nice to know that there is a stable recording or a\nstable \"level\" of the \"ever changing\" disk pack archived somewhere, that\nyou can refer to.\n\n      But now we'll delve into another aspect of tapes and their\n\"technology\", which is far more consequential and relevant to us.  I'd\nsay that this following observation is the main point of our article.\n\n\nTHE IMPACT OF THE P/390 AND HERCULES ON \"TAPES\"\n\n      There's this point to make.  Ten years ago, who would've thought\nthat my PC at home would be able to emulate hardware, and even run an\nold copy of the MVS operating system?  Well today, it's a reality.  Not\nonly does the commercial FLEX-ES (TM of Fundamental Software) system\n(most of the \"development ones\" are currently expiring as we write)\nemulate IBM hardware on a PC, but even the open-source Hercules system\ncan do it too.  Legally, you can download and operate an old 1975-level\nMVS on Hercules at home, for free.  And since there are a good many\nretirees and other interested parties constantly improving that old MVS\n(it supports 3380s and 3390s now, and there are ISPF-like file editors\nfor it), it's rapidly becoming a practical \"new environment\" for\nseasoned MVS practitioners to work in.  All of their saved tapes from 20\nand 25 years ago, are suddenly becoming \"relevant\" again.\n\n      But our additional observation is, that this Hercules system, and\nthe improved old MVS system which legally runs with it, can read\nvirtual, AWS-format tapes as though they were real tapes.\n\n      What does that mean to us?\n\n      Well, when IBM developed their P/390 systems (in the 1990s) as a\nhardware platform to run MVS on a PC, they had to make a \"virtual tape\"\nformat which simulated a tape, on a disk file.  Not everyone had real\ntape drives that they could attach to a PC.  (One drive would cost about\n12K dollars at that time.)  Since IBM's prefix to designate the P/390\nsoftware (IBM always has a prefix) was \"AWS\", their format of disk file\nwhich imitates a tape, is called AWS-format by most people.  I think\nthat the FLEX folks came up with that term first, because they wanted to\ndifferentiate IBM's P/390 tape format from their own Faketape (TM)\nvirtual tape format.\n\n      Anyway, once there's AN ACCESSIBLE disk format to represent an\nentire tape, people can start using it independently.  This contrasts\nwith the disk formats for Virtual Tape libraries, which are proprietary.\nAWS tape format is not proprietary.  Anyone can make \"tapes\" in this\nformat, which is public knowledge.\n\n      You don't need to have a P/390 machine either.  If you have tapes\nin AWS format, there are several ways in which you can read them.\nFirst, Hercules recognizes virtual tapes in AWS-format as being \"tapes\".\nSo if you have a running Hercules system, you can mount the AWS-format\ntapes on that system using a \"devinit\" command, and you can run a\nTAPEMAP job or other such job against the AWS-format tape file, as\nthough it were a real tape.\n\n      Another way of directly looking at an AWS-format tape on the PC,\nis by using David Trout's (www.softdevlabs.com) AWSBROWSE program on a\nWindows machine.  I've packaged this program on CBT Tape File 782\n(www.cbttape.org - please look on the Updates page) as a .zip file which\nunzips to an .exe file that should be installed on Windows.  Because the\nCBT Tape files are intended to be used on an MVS system, the\ninstallation of this one, which is intended to be used on a Windows\nmachine, is a bit awkward.  Here's how it goes.\n\n      File 782 should be uploaded to MVS in BINARY.  Do a TSO RECEIVE\nwith the INDS( ) parameter on MVS into a pds.  Then you download the\nAWSBR152 member of the pds, in BINARY, back down to the PC.  After\nunzipping that on the PC, you get an .exe file, which you can install on\nWindows.  The AWSBROWSE program, once installed on the PC, will allow\nyou to view all the blocks, and label information, on the AWS-format\ntape file.  Go to www.cbttape.org on the Updates page, and get AWSBROWSE\nfor yourself.  David Trout's website, www.softdevlabs.com, also has the\nlatest and greatest AWSBROWSE program (much easier to install).\n\n      What can you do to handle AWS-format \"tapes\" on a \"pure MVS\"\nsystem?  Plenty.  On CBT Tape File 533, there is a set of utilities to\nmake a \"real tape\" from an AWS-format tape, and vice-versa.  The one\npoint is that on MVS disk, the AWS-format tape must be folded over into\nan FB (fixed block) disk dataset with record length (LRECL) equal to 80\n(but with any block size that is a multiple of 80).  That can be\naccomplished by FTP-ing the AWS file from the PC up to the mainframe, in\nBINARY, into an FB-80 dataset.  The folding over will be accomplished\nautomatically by FTP.  Then the VTT2TAPE program from File 533 will read\nthe folded-over AWS format file, and cut a real tape from it.  The\nVTT2DISK program will do the opposite, and will create a folded-over\nFB-80 AWS-format tape file from a real tape, which can then be FTP-ed\ndown to a PC file.\n\n      So it results that if you use the VTT2TAPE utility to convert an\nAWS-format \"tape\" into a real tape, and the VTT2DISK utility to do the\nopposite, the two media would become interchangeable.  And furthermore,\nif you had a Hercules system running on your PC, at home or at work,\neven if it is running the old free MVS from 1975 (but improved), you can\nstill map the AWS-format tapes directly, and look at their contents,\nbefore trying to convert them to real tapes for z/OS use.  To obtain a\ncopy of VTT2TAPE and VTT2DISK and related programs, go to\nwww.cbttape.org, look first at the Updates page and then at the CBT\npage, and download File 533 from there.\n\n      Now, the consequence would be, that instead of having to save\ntapes, you could save PC AWS-format disk files on cd-rom or DVD.  These\ntake up far less physical space than even a cartridge does, and anybody\nwith an inexpensive DVD or CD duplicator machine can make backup copies\nof them.  (We just bought a 5-tier DVD duplicator for $449.  Works\nfine.)  Therefore, even if you are worried that a cd-rom or DVD might\nnot last, when you have 2 or more duplicates of them, you're somewhat\nsafer.  And if you have a standalone DVD duplicating machine, you're\neven better off!\n\n      Just to show you an example of how good this technology is, we\nhave just made one DVD that contains probably 100 tapes on it, including\n40 back-level CBT Tapes, all zipped.  These are the wonders of modern\ntechnology.  In our opinion, that should change people's thinking.  At\nleast, you personally should save your own \"favorite tapes\" from your\ncollection, in this way, even if these methods still might be deemed\nimpractical at a corporate level.\n\n\nKEEPING FUTURE DEVELOPMENTS IN MIND\n\n      We have seen that if you have entire tapes in AWS-format, stored\naway on CD, on DVD, or on PC disk, you can either read them with a\nHercules system, browse them on the PC using David Trout's AWSBROWSE\nprogram, or convert them to real tapes on any MVS system, using the\nVTT2TAPE program from CBT Tape File 533.  Even today, these alternatives\nallow you to store your tapes away as PC disk files, and to use them\nprofitably when you'll need them.  But there is one missing piece.  That\nis, you currently (at this time) can't treat an AWS-format \"tape file\"\nwith a native MVS (z/OS) system, as though it were a real tape.  My take\non this situation is as follows.  Future developments will open up new\npossibilities.\n\n      For example, if someone develops a subsystem that will allow MVS\nto read AWS-format tape data as though it were a real tape, then using\njust minor changes in JCL, you'll be able to directly run all MVS-based\ntape programs against an AWS-format tape file, just as though it were a\nreal tape.  So then, you'll be able to directly TAPEMAP an AWS-format\ntape file that's on MVS DASD, or you'll be able to copy it with the\nCOPYMODS program (CBT Tape File 229) or any other tape copying program,\nto either a real tape, or to another AWS-format tape image.  This hasn't\nbeen written yet, but as soon as it HAS been done, and it's in place and\ndebugged, a whole world of \"tape manipulation\" possibilites will then be\nopened up.  So you can see why it pays (even now) to save your tapes as\nPC files, in AWS format.  When this stuff gets developed (and it will),\nyou'll then have a whole world of things to do with your AWS-format\ntapes!  We're simply saying that \"vaporware\" doesn't always stay\nvaporware.  It gets developed, through the efforts of concerned people,\nand then all of us can get the benefit.\n\n\nCONCLUSION\n\n      We're saying, yet again, that when technological developments\ncome, they require a rethinking of our methods.  New technology opens up\nnew possibility.  Having a 4.7 gig DVD, and the possibility of\nrepresenting entire tapes, from end to end, in the publicly available\nAWS disk format, allows us to store the complete contents of many tapes\non one small disk.  Having inexpensive DVD disk duplicators available,\nmakes the preservation of all of this data much easier.  And with more\ntools to \"read\" this data constantly being written, it pays to save our\ntapes in this format, so we will be able to use their contents far into\nthe future.\n\n      We wish all of you a good and happy month, and we're looking\nforward to seeing you here again, next time.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT120/FILE120.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT120", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}