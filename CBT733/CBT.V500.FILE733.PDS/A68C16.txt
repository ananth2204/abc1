./       ADD          NAME=BCRMACS
         MACRO
&L       BHR   &R
&L       BCR   2,&R
         MEND
         MACRO
&L       BLR   &R
&L       BCR   4,&R
         MEND
         MACRO
&L       BER   &R
&L       BCR   8,&R
         MEND
         MACRO
&L       BNHR  &R
&L       BCR   13,&R
         MEND
         MACRO
&L       BNLR  &R
&L       BCR   11,&R
         MEND
         MACRO
&L       BNER  &R
&L       BCR   7,&R
         MEND
         MACRO
&L       BOR   &R
&L       BCR   1,&R
         MEND
         MACRO
&L       BPR   &R
&L       BCR   2,&R
         MEND
         MACRO
&L       BMR   &R
&L       BCR   4,&R
         MEND
         MACRO
&L       BNPR  &R
&L       BCR   13,&R
         MEND
         MACRO
&L       BNMR  &R
&L       BCR   11,&R
         MEND
         MACRO
&L       BNZR  &R
&L       BCR   7,&R
         MEND
         MACRO
&L       BZR   &R
&L       BCR   8,&R
         MEND
         MACRO
&L       BNOR  &R
&L       BCR   14,&R
         MEND
./       ADD          NAME=FORT
************************************************************
*                                                          *
*        FORTRAN  INTERFACE  FOR ALGOL68C                  *
*                                                          *
************************************************************
*
         MACRO
         $FORTRAN &NAME,&N
         $ENTRYF &N
         LA    R0,ARG1            arg address
         ST    R0,0(NEWP)          set up argument list
         MVI   0(NEWP),X'80'       mark end of list (redundant?)
         LR    WSA,R1              save link
         LR    R1,NEWP             argument list pointer
         L     ENTRY,=V(&NAME)
         DROP  ENTRY
         BALR  LINK,ENTRY          FORTRAN call
         LDR   FRESULT,0           result to ALGOL68C register
         BR    WSA
         MEND
*
*
*
*
$FORT  CSECT
         $FORTRAN DSIN,40
         $FORTRAN DCOS,41
         $FORTRAN DTAN,42
         $FORTRAN DARSIN,43
         $FORTRAN DARCOS,44
         $FORTRAN DATAN,45
         $FORTRAN DLOG,46
         $FORTRAN DEXP,47
         $FORTRAN DSQRT,48
*
         LTORG
*
         $REGDEF
         $FRAME
         $GLOBAL
*
         END
./       ADD          NAME=MACS
         MACRO
         $VERSION
         GBLC  &VERSION
         MNOTE *,'** assembling ZLIB version &VERSION **'
         MEND
*
         MACRO
         $REGDEF
*
*
*
***************************************************
*                                                 *
*                                                 *
*        Register Usage Conventions               *
*                                                 *
*                                                 *
*   After   ENTRY      ENTRYF      IENTRY         *
*                                                 *
*  In use   R2 PP      ENTRY regs  ENTRY regs     *
*           R13 BASE   R1  PLINK                  *
*           R12 DWOST  R14 NEWP    R5  ILINK      *
*           R13        R15 ENTRY                  *
*                                                 *
* Available WSR        WSR                        *
* for use   WSB...WSF  WSB...WSF   R0,R1,R4,R14,  *
*           R0,R1,R4   R0          R15            *
*           R14,R15,R5                            *
*                                                 *
*                                                 *
***************************************************
*
*
*        REGISTERS
*
STATIC   EQU   0                   STATIC CHAIN     ) STACK
PLINK    EQU   1                   EXTERNAL LINK    )  FRAME
PP       EQU   2                   CURRENT FRAME POINTER )
BASE     EQU   3                   BASE
NXTBASE  EQU   4                     REGISTERS
LASTBASE EQU   5
ILINK    EQU   LASTBASE
*
WSA      EQU   LASTBASE+1          6 WORKING REGISTERS
WSB      EQU   WSA+1               7
WSC      EQU   WSB+1               8
WSD      EQU   WSC+1               9
WSE      EQU   WSD+1               10
WSF      EQU   WSE+1               11
RESULT   EQU   WSA                 RESULT OF INTEGER PROCEDURES
*
DWOST    EQU   12                  DYNAMIC STACK BASE POINTER
GLOBAL   EQU   13                  GLOBAL FRAME (AND OS SAVE AREA)
NEWP     EQU   14                  NEW FRAME ON PROCEDURE ENTRY
ENTRY    EQU   15                  ENTRY POINT
*
WS0      EQU   0
R0       EQU   0
R1       EQU   1
R14      EQU   14
R15      EQU   15
LINK     EQU   R14                 INTERNAL AND OS LINK
RETCODE  EQU   R15                 OS RETURN CODE
*
WS0F     EQU   0                   floating point workspace
WS2F     EQU   6
FRESULT  EQU   2                 floating point result register
*
*
*
         MEND
*
*
*
*
         MACRO
         $FRAME
FRAME    DSECT                     STACK FRAME
*
FSTATIC  DS    A                   STATIC CHAIN
FPLINK   DS    A                   LINK
         DS    A                   DYNAMIC CHAIN
         DS    (LASTBASE-BASE+1)A   BASE REGISTER DUMP
ARG1     DS    A
ARG2     DS    A
ARG3     DS    A
         MEND
*
*
*
*
         MACRO
         $FILE
*        FILE DESCRIPTOR BLOCK
*
FDATA    DS    0F                  THIS IS BOTH THE INITIALISATION
*                                      AND THE 'DSECT'
FDCB     DCB   DSORG=PS,MACRF=(GL,PL),EODAD=EODAD,EXLST=EXLST,DDNAME=X
DCBPUTX  DS    F                   PUT diversion
FCHAIN   DC    A(0)                CHAIN OF OPEN FILES
FBSTART  DC    A(0)                START OF CURRENT BUFFER
FBEND    DC    A(0)                END OF CURRENT BUFFER
FBPTR    DC    A(1)                CURRENT CHARACTER
FBLFE    DC    A(0)                logical file end = max(FBLFE,FBPTR)
FFLAGS   DC    AL1(FPARM)          MISC FLAGS
FINOUT   EQU   X'02'               if output
FEOF     EQU   X'04'               EOF
FPARM    EQU   X'08'               special PARM input file
FIRSTIME EQU   X'10'               marks GET attempted
FCCC     DC    C'+'                CC for next record
FOFFSET  DC    H'0'                start of data part of record
FLINE    DC    F'0'                line position
FSERIAL  DS    F'0'
         DS    0D
FDDNAM   DC    CL8' '              ddname
*
*ÂBUFCB  DS    0F                  buffer pool control block
*ÂBUFAD  DC    A(0)
*ÂBUFNO  DC    H'0'
*ÂBUFL   DC    H'0'
*
FLEN     EQU   *-FDATA
         MEND
*
*
*
*
         MACRO
         $GLOBAL &INIT
*        GLOBAL AREA AND OS SAVE AREA
*
GDSECT   DSECT
         DS    F                   OS SAVE AREA
OLDSAVE  DS    F                   PREVIOUS SAVE AREA
NEWSAVE  DS    F                   NEXT SAVE AREA
R14DUMP  DS    F
GDWS     DS    0D                  16  INT/REAL/DEVTYPE working space
R15DUMP  DS    F
         DS    12F
R12DUMP  DS    F
*
EDUMP    DC    A(0)                (72)  link dump for error routine
ARETCODE DC    A(0)                (76)  return code address
PARM     DS    F                   (80) parm address
*
         AIF   ('&INIT' EQ '').NOINIT
INITAREA DS    0XL(GINITL)         area to be initialised
.NOINIT  ANOP
*
ABASE    DS    A                   (84) mainbase address for reg base
         DS    A                   (88) mainbase+4095 for nextbase
         DC    0F'0',AL3(0)        92 filler
STRINGTM DC    C'"'                   stringterm
BITSRADX DC    F'0'                96 bitsradix
         DC    0F'0',AL3(0)        100 filler
POW10CH  DC    C'e'                    powertenchar
GD0      DC    0D'0',X'4E00000000000000' 104
GDM0     DC    X'CE00000000000000' 112
PI       DS    D                   120 pi
MAXREAL  DS    D                   128 maxreal
SMALLREA DS    D                   136 smallreal
FILECHN  DC    A(0)                (144) chain of open files
ERROUT   DC    A(0)                (148)  ERROR MESSAGE FILE
TIME     DC    X'7FFFFFFF'         (152) INITIAL TIMER VALUE
FREE     DS    F                   (156) free space chain
GFFREE   DC    A(0)                (160) free file chain
*
CHEK     EQU   *
*
GDWBASE  DS    F                   (164) initial dynamic stack
HEAPLIM  DS    F                   (168) heap lower bound
         DS    F                   (172) spare
RANDOMGN DS    2D                  (176-191) random generator state
GFRAME   DS    0X
GFREE    EQU   *-GDSECT            192 START OF USER AREA
GLIMIT   EQU   200                 what environment assumes
GCHECK1  EQU   GLIMIT-GFREE
*
         DC    0Y(GCHECK1)       spare below what ENV assumes
*
         MEND
*
*
*
*
         MACRO
         $DCBD
         DCBD  DEVD=,DSORG=PS
*
*        RECFM bit allocation
*
RECFMF   EQU   X'80'               format F/FB
RECFMV   EQU   X'40'               format V/VB
RECFMU   EQU   X'C0'               format U
RECFMB   EQU   X'10'               blocked
RECFMA   EQU   X'04'               ASCII carriage controls
RECFMM   EQU   X'02'               machine carriage controls
RECFMCC  EQU   RECFMA+RECFMM       any carriage controls
         MEND
*
*
*
*
         MACRO
&L       $ENTRY &N,&ARG,&BASE
         GBLB  &TWOBASE
&TWOBASE SETB  0
&L       DS    0H
         ENTRY $$$$00&N
$$$$00&N DS    0H
         USING *,ENTRY             TEMP ADDRESSIBILITY
         USING FRAME,PP            stack frame adressing
         STM   STATIC,LASTBASE,0(NEWP)
         LR    PP,NEWP
         AIF   ('&SYSECT' EQ 'ZLIB').ZLIB
         LR    BASE,ENTRY
         USING $$$$00&N,BASE
         AGO   .ALL
.ZLIB    AIF   ('&BASE' NE '').TWOBASE
         L     BASE,ABASE          SET BASE FOR LIBRARY
&TWOBASE SETB  0
         $USING
         AGO   .ALL
.TWOBASE ANOP
         LM    BASE,NXTBASE,ABASE
&TWOBASE SETB  1
         $USING
.ALL     ANOP
         DROP  ENTRY
         AIF   ('&ARG' EQ '').END
         L     &ARG,ARG1
.END     MEND
*
*
*
*
         MACRO
&L       $EXIT
&L       LM    STATIC,LASTBASE,FSTATIC
         BR    PLINK
         $DROP
         MEND
*
*
*
*
         MACRO
         $USING
         GBLB  &TWOBASE
         USING FRAME,PP
         USING MAINBASE,BASE
         AIF   (NOT &TWOBASE).END
         USING MAINBASE+4095,NXTBASE
.END     MEND
*
*
*
*
         MACRO
         $DROP
         GBLB  &TWOBASE
         DROP  PP,BASE
         AIF   (NOT &TWOBASE).END
         DROP  NXTBASE
.END     MEND
*
*
*
*
         MACRO
&L       $ENTRYF &N,&ARG
&L       DS    0H
         ENTRY $$$$00&N
         USING *,ENTRY
         USING FRAME,NEWP
$$$$00&N DS    0H
         AIF   ('&ARG' EQ '').END
         L     &ARG,ARG1
.END     MEND
*
*
*
*
         MACRO
&L       $EXITF
&L       BR    PLINK
         DROP  ENTRY,NEWP
         MEND
*
*
*
*
         MACRO
&T       $ICALL &RT
&T       BAL   ILINK,&RT
         MEND
*
*
*
*
         MACRO
&T       $IENTRY
&T       DS    0H
         USING MAINBASE,BASE
         USING FRAME,PP
         MEND
*
*
*
*
         MACRO
&T       $IEXIT
&T       DS    0H
         BR    ILINK
         DROP  PP,BASE
         MEND
*
*
*
*
         MACRO
&L       $ERROR &STRING
         LCLA  &C
&L       BALR  LINK,0
         USING *,LINK
         BAL   LINK,ESTOP
         DROP  LINK
&C       SETA  K'&STRING-2
         DC    H'&C'
         DC    C&STRING
         DS    0F
         MEND
*
*
*
*
         MACRO
&L       $IDF &STRING
         LCLA &D
&D       SETA  K'&STRING-2
&L       DC    H'&D'
         DC    C&STRING
         DS    0F
         MEND
*
*
*
*
         MACRO
&NAME    LOADFILE &ARG,&R=FILE,&SOFT=NO
&NAME    L     &R,&ARG
         USING FDATA,&R
         CL    &R,FSERIAL          check self pointing
         AIF   ('&SOFT' EQ 'YES').SOFT
         BNZ   BADFILE
.SOFT    MEND
./       ADD          NAME=RAND
$RANDOM  CSECT
*
*
*
*        A uniform real (0,1) random number package for ALGOL68C.  The
*    following declarations are necessary in the machine code level
*    of the library prelude:
*        MODE SYSRANDOM # = STRUCT(INT,INT) #;
*        MODE RANDOMDATA = STRUCT(SYSRANDOM hidden, REAL normal);
*        RANDOMDATA randomgenerator;
*        PROC getrandom = (INT arg) RANDOMDATA: # see later #;
*        PROC saverandom = RANDOMDATA: # see later #;
*        PROC changerandom = (RANDOMDATA arg) VOID: # see later #;
*        PROC random = REAL: # see later #;
*
*        The following declarations must be made at the ALGOL68 level
*    of the library prelude:
*        changerandom(getrandom(0));
*        PROC normalrandom = (REAL mean,standev) REAL:
*            # see the code of normalrandom #;
*
*        The result of all this is that one mode (SYSRANDOM) is
*    available to the user but not intended to be used by him/her.
*    It is, however, fairly difficult to use by accident as it has
*    no denotations.
*        If at all possible, all unset RANDOMDATA quantities should
*    default to getrandom(0); note that this gives a different
*    result each time it is called.
*
*
         $REGDEF
         USING GDSECT,GLOBAL
*
*
*    getrandom:
*        This takes one integer argument, from which a RANDOMDATA
*        result is generated; the same sequence can be repeated if
*        the same integer is used.  If the value of the integer is
*        zero, the time of day is used instead of the integer value
*        and a totally non-repeatable sequence is generated.  Note
*        that it does not change randomgenerator  and hence the
*        sequence currently being generated; this must be done by
*        calling changerandom.
*
         $ENTRY 73
         L     WSF,ARG1            pick up address of result space
         L     WSA,ARG2            pick up the argument
         LPR   WSB,WSA
         BZ    RANDOM01            use real time clock if arg=0
         LTR   WSA,WSA
         BNM   RANDOM11            set the generator to:
         ALR   WSB,WSB             (2**32+(arg>0|1|2))*ABS(arg)
         LPR   WSA,WSA             for possible compatibility
         B     RANDOM11
*
RANDOM01 DS    0H                  random value if arg=0
         L     WSC,16              ->CVT
CVTOPTB  EQU   183                 options byte in CVT
CVTTOD   EQU   X'20'               TOD clock present
*                                  N.B. CONTROL BLOCKS manual is wrong
*                                  in saying this bit is x'40'
         TM    CVTOPTB(WSC),CVTTOD
         BZ    RANDOM10            if TOD clock is not present
         STCK  0(WSF)
         B     RANDOM12
*
RANDOM10 DS    0H
         TIME  TU                  do the best we can
         LR    WSA,R0
         LR    WSB,R0
RANDOM11 DS    0H
         STM   WSA,WSB,0(WSF)
*
RANDOM12 DS    0H                  all join
         OI    7(WSF),X'01'        force the ls bit to 1
         MVC   8(8,WSF),RANDOM03   set real field of result
         $EXIT
*
*
*
*
*    saverandom:
*        PROC saverandom = RANDOMDATA: randomgenerator;
*
         $ENTRYF 74
         L     WSF,ARG1            pick address of result space
         LD    WS0F,RANDOMGN       this is faster than MVC
         LD    WS2F,RANDOMGN+8
         STD   WS0F,0(WSF)
         STD   WS2F,8(WSF)
         $EXITF
*
*
*
*
*    changerandom:
*        PROC changerandom = (RANDOMDATA arg) VOID:
*            (randomgenerator := arg);
*
         $ENTRYF 75
         LD    WS0F,ARG1           this is faster than MVC
         LD    WS2F,ARG1+8
         STD   WS0F,RANDOMGN
         STD   WS2F,RANDOMGN+8
         $EXITF
*
*
*
*
*    random:
*        This takes no arguments and returns a real result,
*        uniformly distributed between 0 and 1 exclusive.  Its
*        statistical properties should be quite good, despite only
*        32 bits being significant in the result.  It updates
*        (hidden OF randomgenerator) by the following algorithm:
*                h(n+1)=h(n)*(13**17)    mod(2**64)
*        This requires randomhidden to have at least 64 bits.  The
*        following code requires (RANDOM04/2**31) to be odd (sic).
*
         $ENTRYF 76
         L     WSB,RANDOMGN+4
         LTR   WSC,WSB             test the sign bit of second word
         M     WSA,RANDOM04+4      multiply two ls words
         BNM   RANDOM21
         AL    WSA,RANDOM04+4      correct for the sign bit
RANDOM21 DS    0H
         ST    WSB,RANDOMGN+4      store ls word back again
         LR    WSB,WSC
         LR    WSC,WSA             save ms word temporarily
         M     WSA,RANDOM04        multiply ls by ms word
         ALR   WSC,WSB             update ms word
         L     WSB,RANDOMGN
         M     WSA,RANDOM04+4      multiply ms by ls word
         ALR   WSB,WSC
         ST    WSB,RANDOMGN        store ms word back again
         L     WSA,RANDOM06
         ST    WSA,ARG1            convert the ms word to a
         ST    WSB,ARG1+4          floating point fraction
         LD    FRESULT,ARG1
         AD    FRESULT,RANDOM05    normalise and force non-zero
         $EXITF
RANDOM03 DC    D'-100.0'           i.e. no normal number present
RANDOM04 DC    X'780C7372621BD74D' 13**17
RANDOM05 DC    X'4500000000000008' 2**(-33)
RANDOM06 DC    X'46000000'         exponent for floating
*
*
*
         $FRAME
         $GLOBAL
*
         END
./       ADD          NAME=ZLIB
**************************************************************
*                                                            *
*        ALGOL68 RUNTIME SYSTEM                              *
*                                                            *
**************************************************************
*                                                            *
*                  ENTRY  POINTS                             *
*                                                            *
**************************************************************
*
*    all use standard ALGOL68 calling sequence
*
*     R0 = static chain  (irrelevant for library routines)
*     R1 = return address
*     R2 = old stack frame
*     R3-5 old base registers
*     R6 = result for INT, BOOL, CHAR, REF X procedures
*     R12= dyamic stack frame base
*     R13= global frame (also used for OS save area)
*     R14= new frame start
*     R15= entry point
*
*     FP2= result for REAL procedures
*
*
*   1    GENERATE
*   2    FAULT
*   3
*   4    GLOBAL GENERATE
*   5    (MRETURN)
*   6    (MSTART)
*   7    PRETURN
*   8    PSTART
*   9    syswriteint
*  10
*  11    syswritechar
*  12    syswritebits
*  13    syswritereal
*  14    sysoutstring
*  15    sysprintstring
*  16    sysendline
*  17
*  18    syscharpos
*  19    syslinepos
*  20    setreturncode
*  21    sysreadchar
*  22    sysreadint
*  23
*  24    packstring
*  25    cvtstring
*  26    sysreadstring
*  27    (sysreadbits)
*  28    sysreadcc
*  29    syswritecc
*  30    sysreflectline
*  31    clock
*  32    sysopen
*  33    sysclose
*  34    stack available
*  35    heap available
*  36    store available
*  37    store used
*  38    sysundefined
*  39    sysfileopen
*
*
*  40-49 used for elementary functions (separate file)
*
*  51    syslineended
*  52    sysfileended
*  53    sysmovepos
*  54    sysmaxpos
*  55    syssetpos
*  56    syscharsleft
*
*  59    CF compare(char,char)int
*  60    CF compare(string,string)int
*  61    CF compare(char,string)int
*  62    CF compare(string,char)int
*  63    ELEM(int,string)char
*  64    ELEM(int,bits)bool
*  65    LWB(string)int
*  66    UPB(string)int
*  67    ELEM(int,bytes)char
*  68    +(string,string)string
*  69    +(string,char)string
*
*  70    +(char,string)string
*  71    +(char,char)string
*  72    *(string,int)string
*  73-76 "random" routines  (separate file)
*  77    sysdecomposereal(REAL,REF INT,REF REAL)
*
*
*************************************************************
*                                                           *
*               ASSUMPTIONS AND RESTRICTIONS                *
*                                                           *
*************************************************************
*
*
*   e  indicates efficiency consideration only
*
*   a) e  Single buffering is forced for unit record devices.
*         (i.e. assumes the output is being spooled by HASP etc.)
*   b) e  The default LRECL/BLKSIZE values (table DCBEXIT5) are
*         optimised for a 3330, and will use disc space inefficiently
*         on other devices.
*
*
*
*
*       Things not yet implemented etc.
*       -------------------------------
*
*   .  Spanned records (VS or VBS) on input or output.
*
*   .  Real input.
*
*   .  Setting of STAE/SPIE and diagnostics in general.
*
*   .  Machine carriage control characters.
*
*   .  Print real does not always round correctly.
*
*
*
*
*
*
*
*
*
*
**************************************************************
*                                                            *
*                                                            *
*                                                            *
**************************************************************
*
*
*
*
*
*
*
*
********************************************************
*                                                      *
*               ENVIRONMENT  OPTIONS                   *
*                                                      *
********************************************************
*
         GBLC  &CPU,&OS,&VERSION
         GBLA  &RELEASE
ZLIB     CSECT
*
&VERSION SETC  '127'
*
&CPU     SETC  '360'           = 370 if extra instructions present
*  no 370 instructions are currently used; decimal feature and
*  floating point feature must be present
*
*  all operands should be aligned; however the library has only been
*  tested on a CPU with boundary alignment.
*
*
&OS      SETC  'MVT'           operating system
*  this library has only been tested with MVT, but ought to work under
*  MFT etc.
*
&RELEASE SETA  21                  OS (etc) release
* this is used to alter the coding for RDJFCB.
*
*
**************************************************************
*                                                            *
*                                                            *
*                                                            *
**************************************************************
*
*
*
ZLIB     CSECT
*
         $VERSION
         DC    C'ALGOL68C LIBRARY VERSION &VERSION'
         DS    0F
         $REGDEF
         $FILE ,                   this is purposely not addressable
*
*
*
*
*
*
*        STANDARD  ADDRESSABILITY
*
         USING GDSECT,GLOBAL       Global frame and OS save area
*
*************************************************************
*                                                           *
*                    INITIALISATION                         *
*                                                           *
*************************************************************
*
*
         ENTRY $A68INIT
$A68INIT DS    0H
         STM   14,5,R14DUMP
         XC    R15DUMP,R15DUMP      COMPLETION CODE
         LA    LASTBASE,R15DUMP    COMPLETION CODE ADDRESS
         LR    BASE,15
         USING $A68INIT,BASE
         L     NXTBASE,0(R1)         SAVE PARM ADDRESS
         LR    PP,13               RECORD OLD SAVE AREA
*
*        SET UP STACK AREA AND INITIALISE GLOBAL FRAME
*
LENGTH   EQU   GLOBAL+1
*
         LA    R1,44(13)           USE OLD SAVE AREA AS GETMAIN ARGS
         USING GETM-44,PP
         MVC   GETMLA-4(12),GETMSIZE SIZE LIMITS
         GETMAIN VU,LA=GETMLA,A=GETMA,MF=(E,(1))
         LM    GLOBAL,LENGTH,GETMA LENGTH AND ADDRESS
         STM   6,12,44(PP)         SAVE REST OF REGISTERS
         DROP  PP
         MVC   INITAREA,GINIT      initialised variables
         ST    PP,GDSECT+4         chain save areas
         ST    GLOBAL,8(PP)
         LR    PP,GLOBAL           CURRENT FRAME IS GLOBAL
         ST    NXTBASE,PARM          STORE PARM AND RETURN CODE POINTER
         ST    LASTBASE,ARETCODE
*
*        reserve minimum(half of store, 26k) for OS
*
         L     R0,OSRESERV
         CR    R0,LENGTH
         BL    INIT1
         LR    R0,LENGTH
INIT1    SRA   R0,1
         AR    LENGTH,GLOBAL
         SR    LENGTH,R0           TOP ADDRESS TO BE KEPT
         LA    DWOST,GDWBASE
         ST    LENGTH,0(DWOST)     initialise dynamic stack
         ST    LENGTH,HEAPLIM
         FREEMAIN R,LV=(0),A=(LENGTH)  FREE UNWANTED SPACE
*
*
*        INITIALISE TIMER
*
         TTIMER ,                  CHECK IF TIMER ALREADY SET
         LTR   R0,R0
         BP    TIM0                ALREADY SET
         STIMER TASK,TUINTVL=TIME  OR SET IT
         L     R0,TIME
TIM0     ST    R0,TIME             RECORD INITIAL TIMER VALUE
*
*        STAE ....
*        SPIE ....
*        SET PROGRAM MASK
*
         XC    EDUMP,EDUMP
*
*        set up STANDOUT initially
*
         LA    WSA,ERROUT          SYSPRINT first
         LA    ENTRY,$$$$0032
         LA    NEWP,GFRAME         START OF FREE STACK
         USING FRAME,NEWP
         LA    WSB,GETMSIZE !!         null IDF
         LA    WSC,2               channel
         STM   WSA,WSC,ARG1
         DROP  NEWP
         BALR  PLINK,ENTRY
*
         L     ENTRY,AENTER        ENTER FIRST ENVIRON
         BR    ENTRY
*
OSRESERV DC    A(2*26624)
GETMSIZE DC    F'0,8',X'00FFFF00'  VARIABLE GETMAIN LIMITS
AENTER   DC    V($$$$0008)         MAIN ENTRY POINT
*
*
*        INITIAL VALUES FOR GLOBAL VARIABLES
*
GINIT    DS    0F
         DC    A(MAINBASE,MAINBASE+4095)       base regs for library
         DC    AL3(0),C'"'                     stringterm
         DC    F'0'                            bitsradix
         DC    0F'0',AL3(0),C'e'               powertenchar
         DC    X'4E00000000000000'             GD0
         DC    X'CE00000000000000'             GDM0
         DC    DL8'3.14159265358979'           PI (NB NOT ALIGNED)
         DC    X'7FFFFFFFFFFFFFFF'             MAXREAL
         DC    X'3410000000000000'             SMALLREAL
         DC    A(0,0),X'7FFFFFFF',A(0,0)       filechn->GFFREE
GINITL   EQU   *-GINIT
*
*
MAINBASE DS    0H                  normal base address
         USING MAINBASE,BASE
*
EDCON    DC    X'402020202020202020202120'  EDIT INTEGER
*
*
****************************************************
*                                                  *
*                                                  *
*                                                  *
****************************************************
*
*        WORKING SPACE LAYOUT
*
         $FRAME
*
*        OUTPUT CONVERSION WORKING SPACE
*
         ORG   ARG3
CVDWS    DS    D
EDWS     DS    XL12
*
*        REAL CONVERSION WORKSPACE
*
         ORG   ARG3
FARG1    DS    0D                  floating argument
RSCVD    DS    D                   for decimal convert
RSSIGN   DS    C                   sign
RSDIG0   DS    C                   mantissa digits
RSPOINT  DS    C
RSDIG1   DS    CL8
RSPOW10  DS    C                   'E'
RSEXP    DS    CL3                 exponent
RSSPACE  DS    C                   terminal space
RSLEN    EQU   *-RSSIGN
*
RSEDWS   DS    CL(L'EDCON)         for editing
*
*        OPEN WORKING SPACE
*
         ORG   ARG3
OPENARG  DS    F                   ARGUMENT LIST FOR OPEN/CLOSE/RDJFCB
EXLA     DS    2F                  MODIFIED DCB EXIT LIST FOR RDJFCD
GETMWS   DS    0F                  register dump when getting buffers
*
JFCB     DS    0XL176
JFCBDSNM DS    CL44                data set name
JFCBELNM DS    CL8                 member name
         DS    24X
JFCBFLAG DS    X
         ORG   JFCB+86
JFCBIND1 DS    X                   indicator byte 1
         ORG   JFCB+L'JFCB
*
*
**************************************************************
*                                                            *
*                                                            *
*                                                            *
**************************************************************
*
*
ZLIB     CSECT
*
*************************************************************
*                                                           *
*                                                           *
*               OUTPUT  SUBROUTINES                         *
*                                                           *
*************************************************************
*
*        PUTSTR
*
*        NB  STRING LENGTH MUST BE > 0
*
FST      EQU   R15                 BUFFER START
FND      EQU   R0                  BUFFER END
FPTR     EQU   R1                  BUFFER POINTER
STRA     EQU   WSE
STRL     EQU   WSB                 STRING LENGTH
FILE     EQU   WSC                 file for output operations
FCC      EQU   WSA                 carriage control char
*
PUTSTR   $IENTRY
         LOADFILE ARG1
PUTSTRE  $IENTRY
         LM    FST,FPTR,FBSTART
         SR    FND,FPTR            amount remaining
         SR    FND,STRL            after string done
         BM    PUTSTR4             if not enough room for string
         LR    FND,STRL
         BCTR  FND,0
PUTSTR2  DS    0H
         SH    FND,=H'256'
         BNL   PUTSTR3             if more than 256 to move
         LR    FST,FND             ****** R0 problem
         EX    FST,PUTMVC          move it
         LA    FPTR,257(FPTR,FST)  update buff ptr
         ST    FPTR,FBPTR
         LA    STRA,257(STRA,FST)  update input pointer
         LA    RESULT,1            TRUE
         $IEXIT ,                  with cc¬=0
*
         USING MAINBASE,BASE
         USING FRAME,PP
PUTSTR3  DS    0H                  deal with >256
         MVC   0(256,FPTR),0(STRA)
         LA    FPTR,256(FPTR)
         LA    STRA,256(STRA)
         B     PUTSTR2
*
PUTSTR4  DS    0H                  not enough room on record
         SR    RESULT,RESULT       FALSE (and cc=0)
         $IEXIT
*
PUTMVC   MVC   0(0,FPTR),0(STRA)   EXECUTED
*
*
*        ENDREC - tidy up record for output
*
*        NB  this subroutine is called from PUT/TRUNC divert
*       it must not assume that the global frame is addressable
*
         DROP GLOBAL
*
ENDREC   $IENTRY
         LA    FCC,C' '              default cc
ENDRECCC $IENTRY
         LM    FST,FPTR,FBSTART
         C     FPTR,FBLFE          ADVANCE POINTER TO END FO LINE
         BNL   ENDREC7
         L     FPTR,FBLFE
ENDREC7  STC   FCC,FCCC            save carriage control
         TM    DCBRECFM-IHADCB+FDCB,RECFMV
         BZ    ENDREC1             JUMP IF F/FB
         SR    FPTR,FST            COMPUTE RDW
         BNZ   ENDRECV1
         LA    FPTR,1              ensure line contains one char
ENDRECV1 AH    FPTR,FOFFSET        compute total record length
         SH    FST,FOFFSET         to record start (before ccc and RDW)
         TM    DCBRECFM-IHADCB+FDCB,RECFMU
         BO    ENDRECU             JUMP IF FORMAT U
         STC   FPTR,1(FST)         STORE RDW
         SRA   FPTR,8
         STC   FPTR,0(FST)
         $IEXIT
*
PUTMVC1  MVC   1(1,FPTR),0(FPTR)
*
         USING MAINBASE,BASE
         USING FRAME,PP
ENDREC1  SR    FND,FPTR            F/FB  FILL OUT RECORD WITH SPACES
         BZR   ILINK               if record full
         MVI   0(FPTR),C' '
         SH    FND,=H'2'
         BMR   ILINK               if record now full
         LR    FST,FND             ****** R0 PROBLEM
ENDRECF1 SH    FST,=H'256'
         BNM   ENDRECF2            if >256
         EX    FST,PUTMVC1
         $IEXIT
*
         USING MAINBASE,BASE
         USING FRAME,PP
ENDRECF2 MVC   1(256,FPTR),0(FPTR)
         LA    FPTR,256(FPTR)
         B     ENDRECF1
*
ENDRECU  AR    FPTR,FST            FORMAT U - set end of record in DCB
         ST    FPTR,DCBRECAD-IHADCB+FDCB
         ST    FPTR,DCBEOBAD-IHADCB+FDCB
         $IEXIT
*
*
*        set up next record
*
NXTREC   $IENTRY
         TM    FFLAGS,FINOUT
         BZ    WRITERR             if input file
         LR    R1,FILE             pseudo PUT
         USING IHADCB,R1
         L     ENTRY,DCBPUT
         DROP  R1
*Â       L     ENTRY,DCBPUTX
         BALR  LINK,ENTRY
         LA    R1,0(R1)            clean top byte (TCAM leaves junk)
         LA    FND,1
         A     FND,FLINE           incr lpos
         ST    FND,FLINE
         LR    FND,R1
         TM    DCBRECFM-IHADCB+FDCB,RECFMF
         BNZ   NXTREC4             JUMP IF F/FB or U
         XC    0(4,FPTR),0(FPTR)   prepare RDW
         LA    FPTR,4(FPTR)        ALLOW SPACE FOR RDW IF V/VB
NXTREC4  TM    DCBRECFM-IHADCB+FDCB,RECFMCC
         BZ    NXTREC5             SKIP IF NO CCC
         MVC   0(1,FPTR),FCCC      insert CC  (ASCII only)
         LA    FPTR,1(FPTR)
NXTREC5  DS    0H
         LR    FST,FPTR
         MVI   0(FPTR),C' '        IN CASE NULL LINE
         AH    FND,DCBLRECL-IHADCB+FDCB
         STM   FST,FPTR,FBSTART
         ST    FPTR,FBLFE
         $IEXIT
*
*
*
         DROP  FILE
         USING GDSECT,GLOBAL
*
*
***********************************************************
*                                                         *
*                     GENERATE                            *
*                                                         *
***********************************************************
*
GENSIZE  EQU   STATIC             size of request
LIMIT    EQU   WSC                frame pointer (=FILE)
GENAD    EQU   RESULT             result address
*
         ENTRY $$$$0001,$$$$0004
         USING *,ENTRY
$$$$0004 LA    LIMIT,HEAPLIM       GLOBAL GENERATOR
         BAL   ENTRY,GEN0
         USING *,ENTRY
$$$$0001 LR    LIMIT,DWOST
GEN0     L     GENAD,0(DWOST)      CURRENT DYNAMIC STACK POINTER
         C     GENAD,HEAPLIM       STAY BELOW HEAP
         BNH   GEN1
         L     GENAD,HEAPLIM
GEN1     DS    0H
         SR    GENAD,GENSIZE       step off amount required
         LA    GENSIZE,200(NEWP)   CHECK SAFETY MARGIN
         CR    GENAD,GENSIZE
         BL    GENERR
         N     GENAD,=F'-8'        ENSURE ALIGNED
         ST    GENAD,0(LIMIT)
         BR    PLINK
         DROP  ENTRY
*
         AGO   .A1
*
*        GET SPACE FROM FREE CHAIN
*
*        size GENSIZE, link PLINK; GENAD:=result
*
GFWS     EQU   LIMIT
LAST     EQU   WSB
*
GETCHN   LA    LAST,FREE           free chain
         LA    ENTRY,$$$$0004
GF0      L     GENAD,0(LAST)       next block on chain
         LTR   GENAD,GENAD
         BZR   ENTRY             to HEAP generate if chain empty
         L     GFWS,4(GENAD)
         SR    GFWS,GENSIZE
         BZ    GF1                 block of exact size
         LR    LAST,GENAD
         BM    GF0                 block too small
         CH    GFWS,=H'8'
         BM    GF0                 or not enough room for chain
         ST    GFWS,4(GENAD)       reset size
         AR    GENAD,GFWS
         BR    PLINK
*
GF1      MVC   0(4,LAST),0(GENAD)  exact block - close up chain
         BR    PLINK
*
*
*        RETURN SPACE TO FREE CHAIN
*
.A1      ANOP
*
*
**************************************************************
*                                                            *
*                                                            *
*                                                            *
**************************************************************
*
*
*
* PROC(SYSFILE,INT)BOOL syswriteint
*
         $ENTRY 09
         L     WS0,ARG2            ARGUMENT
         CVD   WS0,CVDWS           TO DECIMAL
         MVC   EDWS,EDCON
         LA    R1,EDWS+L'EDWS-1    SET ADDRESS IN CASE 0
         EDMK  EDWS,CVDWS+2        ZERO SUPPRESS
         LR    STRA,R1             ADDRESS OF FIRST SIG DIGIT
         BNM   INTPR0
         BCTR  STRA,0              INSERT SIGN
         MVI   0(STRA),C'-'
INTPR0   LA    STRL,EDWS+L'EDWS    COMPUTE SIGNIFICANT LENGTH
         SR    STRL,STRA
STRXIT   DS    0H
         $ICALL PUTSTR
XXIT     $EXIT
*
*
* PROC(SYSFILE,REF CHAR)BOOL syswritechar
*
         $ENTRYF 11
         LOADFILE ARG1
         LM    WSA,WSB,FBEND       end of buffer, current posn
         CLR   WSB,WSA
         BNM   WREOR               at/over end
         L     WSA,ARG2
         STC   WSA,0(WSB)          put char in buffer
         LA    RESULT,1            TRUE
         AR    WSB,RESULT
         ST    WSB,FBPTR
         BR    PLINK
*
WREOR    XR    RESULT,RESULT       FALSE
         $EXITF
*
*
* PROC(SYSFILE,BITS)BOOL sysprintbits
*
BITSWS   EQU   ARG2+L'ARG2
BITSWSL  EQU   32
*
         $ENTRY 12
         L     WSC,BITSRADX        bitsradix
         BCTR  WSC,0
         CL    WSC,=F'15'
         BH    PRBITSER            if radix>16 or <=0
         STC   WSC,BITSWS
         MVC   BITSWS+1(BITSWSL-1),BITSWS form mask
         IC    WSC,BITSHIFT(WSC)   bits per char
         LTR   WSC,WSC
         BZ    PRBITSER            if radix not 2**n
         LA    STRA,BITSWS+BITSWSL
         LR    STRL,STRA
         L     WSA,ARG2            bits value
PRBITSL  DS    0H
         BCTR  STRA,0              next char pos
         EX    WSA,PRBITSNI        char to store (using NI)
         SRL   WSA,0(WSC)
         LTR   WSA,WSA
         BNZ   PRBITSL             loop whilst chars are significant
         SR    STRL,STRA           actual length
         EX    STRL,TOHEX          one too many - who cares?
         B     STRXIT             try to print
*
PRBITSNI NI    0(STRA),0          executed
TOHEX    TR    0(0,STRA),HEXCHARS
         DROP  BASE,PP
*
*
***********************************************************************
*                                                                     *
* syswritestring(SYSFILE, REF INT, STRING)BOOL:                       *
* PROC(SYSFILE, REF INT, REFâäINT)BOOL outstring
*                                                                     *
***********************************************************************
*
         $ENTRY 15
         ENTRY $$$$0014
$$$$0014 EQU   $$$$0015
         LA    RESULT,1           TRUE
         L     STRA,ARG3           -> string
         LH    STRL,0(STRA)        length
         LTR   STRL,STRL
         BNP   PRTSTR4             if =0 or >32k
PRTSTR1  DS    0H
         L     WSD,ARG2            -> INT (WSD not destroyed by putstr
         L     R1,0(WSD)           number of chars already done
         SR    STRL,R1
         BC    13,PRTSTRX          if int>=strl
         LA    STRA,2(STRA,R1)     -> next char to do
         $ICALL PUTSTR
         BNZ   PRTSTR2             if done all of string
         AR    STRL,FND            amount that can be done
         BZ    PRTSTRX             if none
         $ICALL PUTSTR             do as much as poss
         SR    RESULT,RESULT       FALSE
PRTSTR2  DS    0H
         A     STRL,0(WSD)         amount done
         ST    STRL,0(WSD)
PRTSTRX  $EXIT
         USING MAINBASE,BASE
PRTSTR4  DS    0H                  length =0 or >32k
         N     STRL,=A(HALFMASK)
         BZ    PRTSTRX             length = 0
         B     PRTSTR1
         DROP  BASE,FILE
*
*
*
*        PRINTREAL
*
EXP      EQU   WSA                 exponent
INCR     EQU   WSE                 useful constant
*
         $ENTRY 13
         MVC   RSSIGN(RSLEN),RSZERO set up 0 in case
         SDR   WS0F,WS0F
         AD    WS0F,FARG1          force normalisation
         BZ    RPRZZ               special format for zero
         BP    RPR0
         MVI   RSSIGN,C'-'         set negative
         LPDR  WS0F,WS0F
RPR0     LA    INCR,9              exponent increment
         XR    EXP,EXP             initial exponent
         CE    WS0F,MAXREAL        near 'maxreal' ? (!!!)
         BNL   RPR2                so skip rounding
         HDR   WS2F,WS0F           approximate rounding
         DD    WS2F,=D'1E9'
         ADR   WS0F,WS2F
         CD    WS0F,=D'1'
         BNL   RPR3
RPR1     SR    EXP,INCR            deal with numbers <1
         MD    WS0F,=D'1E9'
         CD    WS0F,=D'1'
         BL    RPR1
         B     RPR4
*
RPR2     AR    EXP,INCR            deal with numbers >1E9
         DD    WS0F,=D'1E9'
RPR3     CD    WS0F,=D'1E9'
         BNL   RPR2
RPR4     DS    0H
*
*
*        we now have a mantissa in â1,1E9), and exponent in EXP
*
         LDR   WS2F,WS0F
         AW    WS2F,GD0
         STD   WS2F,GDWS
         AD    WS2F,GD0            restandardise
         L     R1,GDWS+4           convert first block of 9 digits
         CVD   R1,RSCVD
         MVC   RSEDWS,EDCON        and edit them
         LA    R1,RSEDWS+L'RSEDWS-1
         LR    WSB,R1
         EDMK  RSEDWS,RSCVD+2
         SR    WSB,R1              no of sig digits after .
         LA    STRA,RSDIG1(WSB)    store address for second block
         MVC   RSDIG0,0(R1)
         MVC   RSDIG1,1(R1)        (move more digits than needed)
*
         SDR   WS0F,WS2F
         MD    WS0F,=D'1E9'
         AW    WS0F,GD0
         STD   WS0F,GDWS
         L     R1,GDWS+4            convert second block of digits
         CVD   R1,RSCVD
         UNPK  0(9,STRA),RSCVD+3(5) NB least sig digit never used
*
         MVC   RSPOW10(RSSPACE+1-RSPOW10),CSPACE  blank exponent
         AR    EXP,WSB             adjust exponent
         BZ    RPRZZ               finished if no exponent
         IC    R1,POW10CH
         STC   R1,RSPOW10
         CVD   EXP,RSCVD
         MVC   RSEDWS,EDCON
         LA    R1,RSEDWS+L'EDCON-1
         EDMK  RSEDWS,RSCVD+2
         BNM   RPRE1               skip if positive
         BCTR  R1,0                or insert sign
         MVI   0(R1),C'-'
RPRE1    MVC   RSEXP,RSEDWS+L'RSEDWS-L'RSEXP move exponent into output
RPRZZ    LA    STRA,RSSIGN
         LA    STRL,RSLEN          output string length
         B     STRXIT
RSZERO   DC    CL(RSLEN)' 0.'      (here to avoid forward reference)
CSPACE   EQU   RSZERO+3            pointer to a space
*
*
*
*
*
*
***********************************************************
*                                                         *
*        OPEN                                             *
*                                                         *
***********************************************************
*
*
         $ENTRY 32,,TWOBASE
         LM    WSA,WSC,ARG1        GET ARGUMENTS
         LTR   WSC,WSC
         BNP   OPENE1              COMPLAIN IF UNSUITABLE CHANNEL
         LH    WSD,0(WSB)
         CH    WSD,=H'18'
         BH    OPENE1
         LA    WSB,1(WSB)
         BCTR  WSD,0               in MVC format
         CH    WSC,OPEN2L
         IC    WSC,OPEN2-1(WSC)
         BNH   OPEN1(WSC)          BRANCH IF CHANNEL IN RANGE
*
*        WSA = REF FILE for result
*        WSB = idf base - 1
*        WSD = idf length -1
*
OPEN2    DC    AL1(OPENC1-OPEN1,OPENC2-OPEN1,OPENC3-OPEN1,OPENC4-OPEN1)
OPEN2X   EQU   *-OPEN2
OPEN2L   DC    Y(OPEN2X)
*
*        1     standinchannel
*
OPEN1    DS    0H
OPENC1   LTR   WSC,WSD
         BNM   OPENC1A
         LH    WSD,OPENS1
         LA    WSB,OPENS1+1
         BAL   WSE,OPEN3           assume SYSIN if null IDF
         DC    X'0080'
OPENS1   $IDF 'SYSIN'
*
*        2     standoutchannel
*
OPENC2   DS    0H
         LTR   WSC,WSD
         BNM   OPENC2B
         L     FILE,ERROUT         assume SYSPRINT if null IDF
         LTR   FILE,FILE
         BNZ   OPENC2A
         LH    WSD,OPENS2
         LA    WSB,OPENS2+1
         BAL   WSE,OPEN3
         DC    X'028F'
OPENS2   $IDF 'SYSPRINT'
*
OPENC2B  BAL   WSE,OPEN3A
         DC    X'C28F'
SPACES   DC    CL8' '
*
OPENC1A  BAL   WSE,OPEN3A
         DC    X'C080',CL8' '
*
*        3     PARM
*
OPENC3   XR    WSE,WSE             mark no open wanted
         B     OPENP3
*
*        4    prelude
*
OPENC4   DS    0H
         LH    WSD,OPENS4
         LA    WSB,OPENS4+1
         BAL   WSE,OPEN3
         DC    X'0080'
OPENS4   $IDF 'INIT'
*
*
*        return here to finish parmstring open
*
         USING FDATA,FILE
OPENP0   O     WSE,PARM            parm address if any
         BZ    OPENFAIL
         LA    R15,2(WSE)
         LH    R0,0(WSE)
         AR    R0,R15
         MVI   FLINE+3,1           as didnt call $getline
OPENP2   CR    R15,R0              skip to /
         BNL   OPENFAIL            not found
         CLI   0(R15),C'/'
         LA    R15,1(R15)
         BNE   OPENP2
         CR    R15,R0
         BE    OPENFAIL            if no chars after /
         LR    R1,R15              pointer=start
         STM   R15,R1,FBSTART
         MVC   FDDNAM(8),PARMSTR
         B     OPENP1
         DROP  FILE
*
PARMSTR  DC    CL8'PARM'
*
*        CHECK IDF FORMAT
*        format is  DDNAME  or  DDNAME(MEMBER)
*
*        the checking isnt very thorough, as other junk will
*        be picked up by OS as bad DD or member names.
*
OPEN3A   AR    WSC,WSB             end of string-1
         CLI   1(WSC),C')'         check for member name
         BNE   OPEN3M1             DDNAME only
*
*        separate DDNAME from member name
*
         BCTR  WSC,0               (at least 1 char in member)
OPEN3M   CR    WSC,WSB
         BNH   OPENE1              format error - no '(' found
         CLI   0(WSC),C'('
         BCTR  WSC,0               step past char
         BNZ   OPEN3M
*
         LR    WSD,WSC             WSC now points to end of DDNAME - 1
         SR    WSD,WSB
OPEN3    BCTR  WSD,0
OPEN3M1  CH    WSD,=H'8'           check DDNAME not too long
         BNL   OPENE1
*
*
*        GET SPACE FOR FILE DESCRIPTOR BLOCK
*
*        WSB = idf base -1
*        WSD = ddname length -1
*        WSE = dcbdata or zero if PARM
*
OPENP3   L     FILE,GFFREE         HEAD OF CHAIN
         LTR   FILE,FILE
         BNZ   OPENP31             if got spare file block
         LA    GENSIZE,FLEN
         LA    ENTRY,$$$$0004
         BALR  PLINK,ENTRY         else HEAP generate
         LR    FILE,RESULT
         L     WSA,ARG1            RECOVER WSA DESTROYED BY HEAP EEN
         B     OPENP32
*
OPENP31  DS    0H
         USING FDATA,FILE
         MVC   GFFREE(1),FSERIAL   insert identity byte
         L     FILE,GFFREE
         MVC   GFFREE,0(FILE)      CLOSE UP CHAIN
OPENP32  DS    0H
         L     R1,=A(FDATA)        -> file proforma
         MVC   FDATA(FLEN),0(R1)   initialise file
         USING IHADCB-FDCB+FDATA,FILE
         ST    FILE,FSERIAL-FDATA(FILE) set identity
         LTR   WSE,WSE
         BZ    OPENP0              jump if PARM
         USING DCBDATA,WSE
         MVC   DCBDDNAM,SPACES     INSERT SPACES
         LA    WS0,FDCB-FDATA(FILE) SET UP ARGUMENT LIST FOR OPEN
         ST    WS0,OPENARG
         MVC   OPENARG(1),DATAFLG2 set in/out switch
         MVN   FFLAGS-FDATA(,FILE),DATAFLG1 mark OUT
*
*Â       LA    WS0,BUFCB-FDATA(FILE) set buffer pool control block
*Â       ST    WS0,DCBBUFCB          and BUFNO=0
         EX    WSD,XMVC1           insert DDNAME, forcing upper case
         EX    WSD,XMVC2
         DEVTYPE DCBDDNAM,ARG1
         LTR   RETCODE,RETCODE
         BNZ   OPENFAIL            dd not present
         DROP  WSE
*
*        check for member name, and insert in JFCB
*
         LA    WSE,3(WSB,WSD)      start of member name or end idf + 1
         IC    WSD,0(WSB)
         AR    WSD,WSB             end of whole IDF - 1
         SR    WSD,WSE             length of member name
         BNP   OPEN4               normal open if no member
         BCTR  WSD,0
*
         LA    WS0,EXLA            SET UP TEMPORARY EXIT LIST
         ST    WS0,DCBEXLST
         LA    WS0,JFCB
         ST    WS0,EXLA
         MVI   EXLA,X'07'
         L     WS0,EXLST           ADD STANDARD DCB EXIT
         ST    WS0,EXLA+4
         XC    JFCB(L'JFCB),JFCB
         RDJFCB MF=(E,OPENARG)     READ JFCB
         AIF   (&RELEASE LT 21).NORET
         LTR   RETCODE,RETCODE     (ONLY SET IF RELEASE>=21)
         BNZ   OPENFAIL
.NORET   ANOP
         NC    JFCB(L'JFCB),JFCB
         BZ    OPENFAIL            REJECT IF JFCB NOT READ
         OI    JFCBIND1,X'01'      MEMBERNAME PRESENT
         MVC   JFCBELNM,SPACES     INSERT MEMBER, UPPER CASING
         EX    WSD,XMVC
         OI    JFCBFLAG,X'80'      FORCE WRITE BACK
         OPEN  MF=(E,OPENARG),TYPE=J
         MVC   DCBEXLST+1(3),EXLA+4 RESTORE NORMAL EXIT
         B     OPEN5               JOIN NORMAL ROUTE
XMVC     OC    JFCBELNM(1),0(WSE)
*
*        NORMAL OPEN
*
XMVC1    OC    DCBDDNAM(1),1(WSB)
XMVC2    OC    FDDNAM-FDATA(1,FILE),1(WSB)
*
*
OPEN4    DS    0H
         OPEN  MF=(E,OPENARG)
OPEN5    TM    DCBOFLGS,X'10'      TEST IF OPEN SUCCEEDED
         BZ    OPENFAIL
         DROP  FILE
         USING FDATA,FILE
         TM    FFLAGS,FINOUT
         BZ    OPENREAD           if input
*Â       MVC   DCBPUTX,DCBPUT-IHADCB+FDCB save real put for self
*Â       B     *+L'*+6            temp bypass
*Â       MVC   DCBPUT+1-IHADCB+FDCB(3),=AL3(PUTDVT) divert dcb puts
         $ICALL NXTREC
         B     OPENP1             everything joins there
*
OPENREAD $ICALL GETLINE           setup input line (if any)
*
OPENP1   MVC   FCHAIN,FILECHN      ADD TO OPEN CHAIN
         ST    FILE,FILECHN
OPENC2A  DS    0H
         ST    FILE,0(WSA)         set file
         XR    RESULT,RESULT    0 => success
OPENXIT  $EXIT
         DROP  FILE
*
         $USING ,                  regain previous addressability
OPENFAIL DS    0H
         XC    0(4,WSA),0(WSA)     no suitable sysfile
         LA    RESULT,1            nonzero -> failure
         B     OPENFAIM            join common code in close
         $DROP
*
*
*
*****************************************************************
*                                                               *
*        DCB EXIT ROUTINE                                       *
*                                                               *
*   R1=DCB, R14=link, R15=entry point N.B. as this can be entered *
*   from concatenation, as well as OPEN, no other registers are   *
*   reliable.                                                     *
*   uses WSA, WSB, WSC (FILE), WSD
*                                                               *
*****************************************************************
*
         DROP  GLOBAL
         USING *,ENTRY
         USING IHADCB,R1
DCBEXIT  DS    0H
         L     BASE,ABASE1
         DROP  ENTRY
         USING MAINBASE,BASE
         OI    DCBOFLGS,X'08'      allow for unlike concatenation
*
*        delete existing buffer pool
*
         LR    FILE,R1
         USING IHADCB,FILE
         TM    DCBBUFCB+2,X'01'
         BNZ   DCBXNBF             none
         TM    DCBCIND2,X'08'
         BZ    DCBXNBF             if pool not got by OPEN
         NI    DCBCIND2,X'FF'-X'08'
         $ICALL FREEPOOL
         DROP  R1
DCBXNBF  DS    0H
         SR    WSA,WSA             flag for BUFNO=1
         LA    WSB,DCBEXIT5        default details for unit record
         CLI   DCBDEVT,X'4F'       (set only for TSO)
         BE    DCBEXIT1            if TSO terminal
         L     WSD,16              ->CVT
         L     WSD,0(WSD)          ->TCB WORDS
         L     WSD,4(WSD)          ->TCB
TCBTSFLG EQU   148
         TM    TCBTSFLG(WSD),X'80'
         BZ    DCBEXIT0            unless time sharing task
         LA    WSA,1               default BUFNO=1 for all devices
DCBEXIT0 DS    0H
TCBTIO   EQU   12
         L     WSD,TCBTIO(WSD)     ->TIOT
         AH    WSD,DCBTIOT         ->TIOT DD ENTRY
         L     WSD,16(WSD)         ->UCB (if any)
         LA    WSD,0(WSD)
         LTR   WSD,WSD
         BZ    DCBXDUM             if DD DUMMY
UCBTYP   EQU   16
         CLI   2+UCBTYP(WSD),X'08'
         BE    DCBXUR              if UR
         BCTR  WSA,0               default bufno unset unless TSO
*
*        FILL IN DEFAULTS FOR BLKSIZE,RECFM IF NOT SET
*
DCBEXIT8 DS    0H
         LA    WSB,DCBEXITO-6
         BALR  WSD,0
         LA    WSB,6(WSB)
         CLC   DCBRECFM,0(WSB)
         BZ    DCBEXIT4            RECFM MATCHES
         CLC   DCBRECFM,1(WSB)
         BZ    DCBEXIT4
         TM    6(WSB),X'FF'
         BNZR  WSD                 LOOP FOR MORE
         B     DCBXDFLT            insert default
*
DCBEXIT5 DC    X'4444',H'254,258'  defaults for TSO/dummy out
DCBEXITD DC    X'8080',H'8,8'      DD DUMMY input
*
DCBEXITO DC    X'4442',H'137,141'  VA,VM
DCBEXITI DC    X'8080',H'80,80'    F unit record input default
         DC    X'5050',H'136,2498' VB
         DC    X'4040',H'136,140'  V
         DC    X'9492',H'133,3059' FBA,FBM
         DC    X'9C9E',H'133,3059' FBSA,FBSM
         DC    X'8482',H'133,133'  FA,FM
         DC    X'9098',H'80,2480'  FB,FBS
         DC    X'C0C4',H'0,4096'   U,UA
         DC    X'5452',H'137,2498' VBA,VBM  (default - must be last)
         DC    X'00'
*
*
*
DCBXUR   DS    0H
         LA    WSD,DCBEXITO-DCBEXIT5 switch for UR output
DCBXDUM  DS    0H
         AR    WSB,WSD             select dummy or unit record
         TM    FFLAGS-FDCB+IHADCB,FINOUT
         BNZ   DCBEXIT1            if output
         LA    WSB,6(WSB)          select input
DCBEXIT1 DS    0H
         TM    DCBRECFM,RECFMU
         BNZ   DCBEXIT8            look up provided recfm
DCBXDFLT DS    0H
         MVC   DCBRECFM,0(WSB)     set default RECFM
*
DCBEXIT4 DS    0H
         CLI   DCBBUFNO,0
         BNE   DCBEXIT9            if BUFNO set externally
         LTR   WSA,WSA
         BM    DCBEXIT9            if not to force BUFNO=1
         MVI   DCBBUFNO,1
DCBEXIT9 DS    0H
         LH    WSA,DCBBLKSI
         LH    WSD,DCBLRECL
         OR    WSA,WSD
         BNZ   DCBEXIT2            if either BLKSIZE or LRECL set
         MVC   DCBLRECL,2(WSB)     set LRECL
         MVC   DCBBLKSI,4(WSB)     and BLKSIZE
DCBEXIT2 DS    0H
         NI    FFLAGS-FDATA+IHADCB,255-FIRSTIME mark GET aborted
         XR    WSB,WSB             offset from record start
         TM    DCBRECFM,RECFMCC
         BZ    DCBEXIT6            if no carriage controls
         LA    WSB,1(WSB)
DCBEXIT6 DS    0H
         TM    DCBRECFM,RECFMF
         BNZ   DCBEXIT7            if F or U
         TM    DCBRECFM,RECFMV
         BZ    DCBEXIT7            unless V
         LA    WSB,4(WSB)          for RDW
DCBEXIT7 DS    0H
         STH   WSB,FOFFSET-FDATA+IHADCB
         BR    R14
         DROP  BASE
         USING GDSECT,GLOBAL
         AGO   .PUTDVT            AS IBM WONT FIX ABEND BUG
*
*
*        PUT/TRUNC diversion
*
         USING *,ENTRY
PUTDVT   MVI   R12DUMP,0          mark PUT
         B     PUTDVT1
*
         ORG   PUTDVT+8
         MVI   R12DUMP,8           mark TRUNC
PUTDVT1  STM   LINK,WSD,R14DUMP
         L     BASE,ABASE
         DROP  ENTRY
         USING MAINBASE,BASE
         LR    FILE,R1
         USING FDATA,FILE
         $ICALL ENDREC            terminate current record
         LM    LINK,WSD,R14DUMP
         XR    ENTRY,ENTRY
         IC    ENTRY,R12DUMP
         A     ENTRY,DCBPUTX-FDCB(R1) now enter real PUT/TRUNC
         BR    ENTRY
         DROP  BASE,FILE
.PUTDVT  ANOP
*
*
*
*************************************************************
*                                                           *
*                      CLOSE                                *
*                                                           *
*************************************************************
*
         $ENTRY 33
         LOADFILE ARG1
         TM    DCBOFLGS-IHADCB+FDCB,X'10'
         BZ    CLOSEP              bypass close if not open
         TM    FFLAGS,FINOUT
         BZ    CLOSER              bypass if reading
         $ICALL ENDREC
         CL    FILE,ERROUT
         BE    CLOSEX
CLOSER   DS    0H
         LA    WS0,FDCB            MAKE UP ARGUMENT LIST
         ST    WS0,OPENARG
         MVI   OPENARG,X'80'
         CLOSE MF=(E,OPENARG)
         LA    R1,FDCB
         $ICALL FREEPOOL
CLOSEP   LA    WSA,FILECHN-FCHAIN+FDATA  SCAN FILE CHAIN
CLOSE2   CL    FILE,FCHAIN-FDATA(WSA)
         BE    CLOSE3              JUMP IF FILE FOUND
         L     WSA,FCHAIN-FDATA(WSA)
         LTR   WSA,WSA
         BNZ   CLOSE2
         B     CLOSERR
*
CLOSE3   DS    0H
         MVC   FCHAIN-FDATA(4,WSA),FCHAIN remove from open chain
OPENFAIM DS    0H                  OPEN FAILURE JOINS
         IC    R1,FSERIAL          change file identity
         BCTR  R1,0
         SLL   R1,24               ensure FSERIAL cannot appear open
         ST    R1,FSERIAL
         MVC   0(4,FILE),GFFREE    ADD TO FREE CHAIN
         ST    FILE,GFFREE
         DROP  FILE
CLOSEX   $EXIT
*
*
FREEPOOL $IENTRY
         FREEPOOL (1)
         $IEXIT
*
*
*
*
*
**************************************************************
*                                                            *
*                                                            *
*                                                            *
**************************************************************
*
*
* PROC(SYSFILE,REF CHAR)BOOL sysreadchar
*
*
         $ENTRYF 21
RDCH0    DS    0H
         LOADFILE ARG1
         LM    WSA,WSB,FBEND       end of record / current character
         CLR   WSB,WSA
         BNM   RDEOR               END OF RECORD
         XR    WSA,WSA
         IC    WSA,0(WSB)          PICK UP CHARACTER
         LA    WSB,1(WSB)          STEP POINTER
         ST    WSB,FBPTR
         L     WSB,ARG2
         ST    WSA,0(WSB)          set char
         LA    RESULT,1            result TRUE
         BR    PLINK
*
RDEOR    XR    RESULT,RESULT       FALSE
         $EXITF
*
*
* PROC(SYSFILE,REF INT)BOOL sysreadint
*
         $ENTRYF 22
         LOADFILE ARG1
         LM    WSA,WSB,FBEND
RDI2     CR    WSB,WSA             check for end of record
         BNL   RDI0
         CLI   0(WSB),C' '         ignore initial spaces
         BZ    RDI3
         LA    WSD,*+5             point to '+'
         CLI   0(WSB),C'+'
         BZ    RDI4
         CLI   0(WSB),C'-'
         BNZ   RDI6
         LA    WSD,=X'0D'
         B     RDI4
RDI6     BCTR  WSB,0
RDI4     LA    WSE,1(WSB)          note first digit position
RDI7     LA    WSB,1(WSB)
         CR    WSB,WSA
         BNL   RDI5                end number with end of line
         CLI   0(WSB),C'0'
         BL    RDI5                or with non digit
         CLI   0(WSB),C'9'
         BNH   RDI7
RDI5     ST    WSB,FBPTR           reset input pointer
         SR    WSB,WSE             length of number
         BZ    RDIERR              no digits
RDI8     BCT   WSB,RDI10
RDI9     CH    WSB,=H'16'
         BNL   RDIER               if too many digits (>16 (sic))
         EX    WSB,XPACK           (assumes <17 digits!)
         MVN   CVDWS+7(1),0(WSD)   insert sign
         CVB   WSA,CVDWS           to binary
         B     RDIEND
*
RDI0     DS    0H
RDIERR   XR    RESULT,RESULT       FALSE
         B     RDIXIT
*
XPACK    PACK  CVDWS(8),0(1,WSE)   (executed)
*
RDI3     LA    WSB,1(WSB)          skip initial spaces
         B     RDI2
*
RDI10    CLI   0(WSE),C'0'         skip leading zeros
         BNE   RDI9                if not a zero
         LA    WSE,1(WSE)          try next
         B     RDI8
*
RDIEND   DS    0H
         L     WSB,ARG2
         ST    WSA,0(WSB)
         LA    RESULT,1            TRUE
RDIXIT   $EXITF
         DROP  FILE
*
*
*
*
* PROC(SYSFILE,REF STRING)BOOL sysreadstring
*     (n.b. always assigns a string and updates charpos;
*           yields TRUE if stringterm is encountered, else FALSE.)
*
         $ENTRY 26
         LOADFILE ARG1,R=WSF
         SR    WSA,WSA             FALSE
         ST    WSA,ARG3+L'ARG3
         LA    WSA,NULLSTR         prepare for exit if no chars left
         LM    FND,FPTR,FBEND
         SR    FND,FPTR
         BNP   RDSTR3              if no chars left
         LR    WSD,FPTR
         L     WSA,STRINGTM-3      term char
         MVI   ARG3+L'ARG3+3,1     TRUE
RDSTR2   DS    0H
         EX    WSA,RDSTRCLI        look for term
         BE    RDSTR1              if found
         LA    WSD,1(WSD)          to next char
         BCT   FND,RDSTR2
         MVI   ARG3+L'ARG3+3,0     FALSE
RDSTR1   DS    0H
         ST    WSD,FBPTR           leave char ptr at term (if any)
         DROP  WSF
         SR    WSD,FPTR            number of chars
         LR    WSE,FPTR            start of chars
         LR    WSF,WSD
         $ICALL GETSTR             get string space from heap
         LR    WSC,WSF
         $ICALL MOVE1              move chars into string
RDSTR3   DS    0H
         L     WSF,ARG2
         ST    WSA,0(WSF)          set string 'result'
         L     RESULT,ARG3+L'ARG3  result
         $EXIT
*
RDSTRCLI CLI   0(WSD),*-*
*
*
*
* PROC(SYSFILE)BOOL sysendline
*
         $ENTRY 16
         LOADFILE ARG1
         TM    FFLAGS,FINOUT
         BZ    NLI
         LA    FCC,C' '            default ANSI ccc
         B     SYSWCC1
NLI      $ICALL GETLINE
         BZ    EXITTRUE            if getline ok
         XR    RESULT,RESULT       else FALSE
NLXIT    $EXIT
         DROP  FILE
*
*
* PROC(SYSFILE,REF INT)BOOL sysreadcc
*
         $ENTRY 28
         LOADFILE ARG1
         TM    FFLAGS,FINOUT
         BNZ   NQERR               if output file
         $ICALL GETLINE
         LA    WSA,0               (WSA=RESULT<-FALSE) c-code unaltered
         BNZ   RCCX                if EOF
         L     WSB,ARG2
         IC    WSA,FCCC
         ST    WSA,0(WSB)          set the int
EXITTRUE LA    RESULT,1            TRUE
RCCX     $EXIT
         DROP  FILE
*
*
*
* PROC(SYSFILE,INT)BOOL syswritecc
*
         $ENTRY 29
         LOADFILE ARG1
         TM    FFLAGS,FINOUT
         BZ    NPERR
         L     FCC,ARG2
SYSWCC1  DS    0H
         $ICALL ENDRECCC
         $ICALL NXTREC
         LA    RESULT,1            TRUE
         $EXIT
         DROP  FILE
*
*
*
*
*        getline
*
GETLINE  $IENTRY
         USING FDATA,FILE
         TM    FFLAGS,FINOUT
         BNZ   READERR             if output file
         TM    FFLAGS,FPARM+FEOF deal with special states
         BNZ   NXT5
NXT2     OI    FFLAGS,FIRSTIME     SET SWITCH FOR UNLIKE CONCATENATION
         GET   (FILE)
         LA    R1,0(R1)            clean top byte (left dirty by TCAM)
         TM    FFLAGS,FIRSTIME
         BZ    NXT2                RETRY IF FAILED
         MVI   FCCC,C' '           default ANSI ccc
         TM    DCBRECFM-IHADCB+FDCB,RECFMCC
         BZ    GETLNOCC            if no carriage controls
         MVC   FCCC,0(R1)          copy the provided cc
GETLNOCC DS    0H
         LR    R0,R1
         AH    R0,DCBLRECL-IHADCB+FDCB  RECORD LENGTH
         AH    R1,FOFFSET          start of data
         ST    R1,FBSTART          SET UP RECORD DETAILS
         STM   R0,R1,FBEND
         LA    R0,1
         A     R0,FLINE
         ST    R0,FLINE
         SR    R0,R0               set condition code to mark not EOF
         B     GETXIT
*
NXT5     TM    FFLAGS,FEOF
         BO    GETXIT              EXIT IF EOF
*
*        EOF ENCOUNTERED
*
EODAD    XC    FBSTART(12),FBSTART MARK NO BUFFER
         OI    FFLAGS,FEOF         set up EOF and cc nonzero
GETXIT   $IEXIT
         DROP  FILE
*
* PROC(SYSFILE,INT)BOOL syssetpos
*
         $ENTRYF 55
         LOADFILE ARG1
         L     WSB,ARG2
         BCTR  WSB,0
         LM    WSD,WSF,FBSTART
         AR    WSB,WSD            new position
         LA    ENTRY,SYSMOVEP
         USING SYSMOVEP,ENTRY
         B     SYSSETP1           join sysmovepos
         DROP  ENTRY,NEWP,FILE
*
*
* PROC(SYSFILE,INT)BOOL sysmovepos
*
SYSMOVEP $ENTRYF 53
         LOADFILE ARG1
         L     WSB,ARG2
         LM    WSD,WSF,FBSTART
         AR    WSB,WSF            new position
SYSSETP1 XR    RESULT,RESULT      FALSE
         CLR   WSB,WSD
         BMR   PLINK              if < start
         CLR   WSB,WSE
         BPR   PLINK              off end of record
         LA    RESULT,1           TRUE
         ST    WSB,FBPTR
         TM    FFLAGS,FINOUT
         BZR   PLINK             no LFE check if input
*
         L     WSE,FBLFE
         CLR   WSF,WSE
         BNP   SYSMOVE1           if old<=lfe
         ST    WSF,FBLFE          lfe':=old
         LR    WSE,WSF
SYSMOVE1 DS    0H                 now lfe'=max(lfe,old)
         CLR   WSB,WSE
         BNPR  PLINK              if new<=lfe'
*
         MVI   0(WSE),C' '         pad with spaces
         BCTR  WSB,0
         SLR   WSB,WSE
         BMR   PLINK             only one space needed
SETCREST DS    0H
         SH    WSB,=H'256'
         BNM   SETC256
         EX    WSB,EXMVC           put rest of spaces
         BR    PLINK
*
SETC256  MVC   1(256,WSE),0(WSE)
         LA    WSE,256(WSE)
         B     SETCREST
         DROP  ENTRY,NEWP
*
EXMVC    MVC   1(*-*,WSE),0(WSE)   executed
*
*
*
* PROC(SYSFILE)BOOL syslineended
*
         $ENTRYF 51
         LOADFILE ARG1
         XR    RESULT,RESULT
         CLC   FBEND,FBPTR
         BPR   PLINK
         LA    RESULT,1
         $EXITF
         DROP  FILE
*
*
* PROC(SYSFILE)BOOL sysfileended
*
         $ENTRYF 52
         LOADFILE ARG1
         XR    RESULT,RESULT
         TM    FFLAGS,FEOF
         BZR   PLINK
         LA    RESULT,1
         $EXITF
         DROP  FILE
*
*
*
* PROC(SYSFILE,SYSFILE)BOOL sysreflectline
*
         $ENTRY 30
         LOADFILE ARG2             to
         DROP  FILE
         LOADFILE ARG1,R=WSA       from
         L     STRA,FBSTART        STRING ADDRESS AND LENGTH
         L     STRL,FBEND
         DROP  WSA
         SR    STRL,STRA
         BNP   RFDONE              exit if line empty or EOF (fudge!)
         $ICALL PUTSTRE
         BNZ   RFDONE              if done all
         AR    STRL,FND            amount that can be done
         BZ    RFDONE              if none (can't happen?)
         $ICALL PUTSTRE
RFDONE   $ICALL ENDREC
         $ICALL NXTREC
         LA    RESULT,1            TRUE
         $EXIT
*
*
* PROC(SYSFILE)INT syslinepos
*
         $ENTRYF 19
         LOADFILE ARG1
         L     RESULT,FLINE
         $EXITF
*
* PROC(SYSFILE)INT syscharpos
*
         $ENTRYF 18
         LOADFILE ARG1
         LA    RESULT,1
         A     RESULT,FBPTR
         S     RESULT,FBSTART
         $EXITF
*
*
* PROC(SYSFILE)INT sysmaxpos
*
         $ENTRYF 54
         LOADFILE ARG1
         L     RESULT,FBEND
         SL    RESULT,FBSTART
         $EXITF
         DROP  FILE
*
*
* PROC(SYSFILE)INT syscharsleft
*
         $ENTRYF 56
         LOADFILE ARG1
         LM    WSA,WSB,FBEND      end of buffer, current posn
         SLR   WSA,WSB
         $EXITF
         DROP  FILE
*
*
**************************************************************
*                                                            *
* ELEM(INT,STRING)CHAR:                                      *
*                                                            *
**************************************************************
*
         $ENTRYF 63,WSB
         L     WSC,ARG2           to string
         SH    WSB,=H'1'
         BC    5,ELEMERR1         if o'flow (cc3) or -ve (cc1)
         XR    RESULT,RESULT
         CH    WSB,0(WSC)
         BNL   ELEM2              probably outside string
ELEM1    DS    0H
         IC    RESULT,2(WSB,WSC)
         BR    PLINK
*
ELEM2    DS    0H
         LH    WSD,0(WSC)         string length
         N     WSD,=A(HALFMASK)
         CR    WSB,WSD
         BL    ELEM1              string length is 32k->64k-1
         B     ELEMERR1           over end of string
         DROP  ENTRY,NEWP
*
*
**************************************************************
*                                                            *
* ELEM(INT,BITS)BOOL:                                        *
*                                                            *
**************************************************************
*
         $ENTRYF 64
         LM    WSC,WSD,ARG1
         LA    WSB,32
         SR    WSB,WSC
         BC    5,ELEMERR2         if o'flow (cc3) or -ve (cc1)
         CH    WSB,=H'31'
         BH    ELEMERR2           subscript was 0 or -ve
         LA    RESULT,1
         SRL   WSD,0(WSB)
         NR    RESULT,WSD
         $EXITF
*
*
***********************************************************************
*                                                                     *
* ELEM(INT,BYTES)CHAR:                                                *
*                                                                     *
***********************************************************************
*
         $ENTRYF 67,RESULT
         LTR   RESULT,RESULT
         BNP   ELEMERR3            if index<=0
         CH    RESULT,=H'8'
         BH    ELEMERR3            if index>8
         IC    RESULT,ARG2+4-1(RESULT) n.b.  bytes aligned at 8
         $EXITF
*
***********************************************************************
*                                                                     *
* + (STRING,STRING)STRING:                                            *
*                                                                     *
***********************************************************************
*
         $ENTRY 68
         LM    WSE,WSF,ARG1        and ARG2
COM1     DS    0H                  other combinations join here
         LH    GENSIZE,0(WSE)      length of string1
         LH    WSD,0(WSF)                and string2
         N     GENSIZE,=A(HALFMASK)                  upto 64k
         N     WSD,=A(HALFMASK)
         AR    WSD,GENSIZE         total length
         $ICALL GETSTR             get string space from HEAP and init
         $ICALL MOVE               move in string1
         LR    WSE,WSF             move in string2
         $ICALL MOVE
         $EXIT
*
GETSTR   $IENTRY
         C     WSD,=A(HALFMASK)
         BH    STRERR              if >=64k
         LA    GENSIZE,2(WSD)      allow for length halfword
         LA    ENTRY,$$$$0004
         BALR  PLINK,ENTRY         HEAP generate (clobbers WSC)
         STH   WSD,0(RESULT)       set length of result string
         LR    WSD,RESULT
         $IEXIT
*
MOVE     $IENTRY
         LH    WSC,0(WSE)          length
         N     WSC,=A(HALFMASK)
         BZ    MOVEX               if nothing to move
MOVE1    DS    0H
         SH    WSC,=H'256'
         BH    MOVE2
         BCTR  WSC,0
         EX    WSC,XMOVE
         LA    WSD,257(WSD,WSC)
MOVEX    BR    ILINK
*
XMOVE    MVC   2(*-*,WSD),2(WSE)  EXecuted
*
MOVE2    DS    0H
         MVC   2(256,WSD),2(WSE)
         LA    WSE,256(WSE)
         LA    WSD,256(WSD)
         B     MOVE1
         DROP  BASE,PP
*
***********************************************************************
*                                                                     *
* + (STRING,CHAR)STRING:                                              *
*                                                                     *
***********************************************************************
*
         $ENTRY 69
         L     WSE,ARG1
         LA    WSF,ARG2+L'ARG2    make string from ARG2
         LA    WSD,1
         STH   WSD,0(WSF)         length
         MVC   2(1,WSF),ARG2+3
         B     COM1
*
***********************************************************************
*                                                                     *
* + (CHAR,STRING)STRING:                                              *
*                                                                     *
***********************************************************************
*
         $ENTRY 70
         L     WSF,ARG2
COM2     DS    0H                 make string from arg1
         LA    WSE,ARG2+L'ARG2
         LA    WSD,1
         STH   WSD,0(WSE)         length
         MVC   2(1,WSE),ARG1+3
         B     COM1
*
***********************************************************************
*                                                                     *
* + (CHAR,CHAR)STRING:                                                *
*                                                                     *
***********************************************************************
*
         $ENTRY 71
         LA    WSF,ARG2+L'ARG2+4   make string from arg2
         LA    WSD,1
         STH   WSD,0(WSF)          length
         MVC   2(1,WSF),ARG2+3
         B     COM2
*
***********************************************************************
*                                                                     *
*  * (STRING,INT)STRING:                                              *
*                                                                     *
***********************************************************************
*
         $ENTRY 72
         LM    WSE,WSF,ARG1        string,int
         LH    WSD,0(WSE)
         N     WSD,=A(HALFMASK)    length
         LA    RESULT,NULLSTR      prepare for fast exit
         BZ    STIMESX             if null input string
         MR    WSC,WSF             result string length
         LTR   WSC,WSC
         BM    STIMESX             exit with null string if int<0
         BNZ   STRERR              result string exceeds 64k
         $ICALL GETSTR             get string from heap and initialise
         LA    WSF,1(WSF)          fiddle for bct
         $ICALL STIMES             sets link
         L     WSE,ARG1            regain string
STIMES   DS    0H
         BCT   WSF,MOVE            construct result
STIMESX  DS    0H
         $EXIT
*
*
*
*
*
*
*
**************************************************************
*                                                            *
*                                                            *
*                                                            *
**************************************************************
*
*
*
*
*
RDIER    $ERROR 'readint: too many digits'
PRBITSER $ERROR 'printbits: bitsradix not 2, 4, 8, or 16'
WRITERR  $ERROR 'writing on input-only channel'
NPERR    EQU   WRITERR
READERR  $ERROR 'reading on output-only channel'
NQERR    EQU   READERR
ELEMERR1 $ERROR 'integer out of range for ELEM string'
ELEMERR2 $ERROR 'integer out of range for ELEM bits'
ELEMERR3 $ERROR 'integer out of range for ELEM bytes'
CLOSERR  $ERROR 'closing unopened file'
GENERR   $ERROR 'no storage for generator'
BADFILE  $ERROR 'using unopened file'
OPENE1   $ERROR 'bad data for open'
STRERR   $ERROR 'string exceeds 64k characters'
         ENTRY $$$$0002
$$$$0002 $ERROR 'obeying faulty program'
*
*
**************************************************************
*                                                            *
*                                                            *
*                                                            *
**************************************************************
*
*
NULLSTR  DC    H'0'                null string
COLLAPSE DC    H'29',CL29'++++ALGOL68C run time error: '
         ENTRY $$$$0007
$$$$0007 DC    0F'0'
ABASE1   DC    A(MAINBASE,MAINBASE+4095,0,STOP0) ENVIRON EXIT
EXLST    DC    0F'0',X'85',AL3(DCBEXIT)  STANDARD EXIT LIST
*
F5       DC    F'5'
F192     DC    F'192'
DECSIGN  DC    0F'0',X'C0'         decimal sign for octal output
*
* for PRINTBITS
*
HEXCHARS DC    C'0123456789abcdef'
BITSHIFT DC    AL1(0,1,0,2,0,0,0,3,0,0,0,0,0,0,0,4)
HALFMASK EQU   X'00FFFF'
*
*
         LTORG
*
*
**************************************************************
*                                                            *
*                                                            *
*                                                            *
**************************************************************
*
*
*
* PROC(STRING)VOID sysundefined
*
         $ENTRYF 38
         L     LINK,ARG1
         DROP  NEWP
         L     ENTRY,AESTOP
         DROP  ENTRY
         BR    ENTRY
*
AESTOP   DC    A(ESTOP)
*
*
*********************************************************************
*                                                                   *
* PROC(SYSFILE)BOOL sysfileopen                                     *
*                                                                   *
*********************************************************************
*
         $ENTRYF 39
         SR    RESULT,RESULT       FALSE
         L     WSB,ARG1
         L     WSC,16              ->CVT
         L     WSC,CVTMZ00(WSC)    last byte in store
         LTR   WSB,WSB
         BNPR  PLINK               if no sysfile
         CR    WSB,WSC
         BNLR  PLINK               if no sysfile
         USING FDATA,WSB
         CL    WSB,FSERIAL
         BNER  PLINK               not open sysfile
         DROP  WSB
         LA    RESULT,1             TRUE
         $EXITF
*
*
*
* PROC INT clock
*
         $ENTRY 31
         TTIMER ,                  READ TIME
         L     WSB,TIME
         SR    WSB,R0              SUBTRACT FROM INITIAL VALUE
         M     WSA,F5              CONVERT TO MILLISECONDS
         D     WSA,F192
         LR    WSA,WSB
         $EXIT
*
*        CVTSTRING
*
         $ENTRYF 25,RESULT         argument to result
         $EXITF
*
**************************************************************
*                                                            *
* LWB(STRING)INT:                                            *
*                                                            *
**************************************************************
*
         $ENTRYF 65
         LA    RESULT,1
         $EXITF
*
*
**************************************************************
*                                                            *
* UPB(STRING)INT:                                            *
*                                                            *
**************************************************************
*
         $ENTRYF 66,WSA
         LH    RESULT,0(WSA)
         N     RESULT,HALFWORD
         $EXITF
*
*
**************************************************************
*                                                            *
* CF string comparison: RESULT := SIGN(string1 - string2)    *
*        string length 0 -> 64k-1                            *
*                                                            *
**************************************************************
*
         $ENTRYF 59
         L     RESULT,ARG2         char2
         S     RESULT,ARG1         char1
         BZR   PLINK
         LA    RESULT,1
         BNPR  PLINK
         LCR   RESULT,RESULT
         $EXITF
*
*
         $ENTRYF 61                OP (CHAR,STRING)INT:
         LA    WSB,ARG1+1          ) simulate string1
         LA    WSE,1               )
         L     WSC,ARG2
         B     CF0
         DROP  ENTRY,NEWP
*
         $ENTRYF 62                OP (STRING,CHAR)INT:
         L     WSB,ARG1
         LA    WSC,ARG2+1          )  simulate string2
         LA    WSD,1               )
         LH    WSE,0(WSB)
         B     CF00
         DROP  ENTRY,NEWP
*
*
         $ENTRYF 60                OP (STRING,STRING)INT:
         LM    WSB,WSC,ARG1        and ARG2
         LH    WSE,0(WSB)          string1 length
CF0      DS    0H
         LH    WSD,0(WSC)          string2 length
CF00     DS    0H
         BALR  ENTRY,0             addressability for char paths
         USING *,ENTRY
         XR    RESULT,RESULT
         LR    WSF,WSD
         CR    WSD,WSE
         BL    CF1                 if length2 < length1
         LR    WSF,WSE             string 1 is shorter - use it
CF1      DS    0H
         LTR   WSF,WSF
         BNH   CF6                 if lengths zero or >=32k
         BCTR  WSF,0               machine length
CF2      DS    0H
         SH    WSF,H256
         BNL   CF5                 if length > 256
         EX    WSF,CFCLC           compare logical characters
         BNE   CF3                 if chars differ
         CR    WSE,WSD             otherwise compare lengths
         BER   PLINK
CF3      DS    0H
         LA    RESULT,1            if arg1>arg2
         BHR   PLINK
         LCR   RESULT,RESULT       otherwise arg1<arg2
         BR    PLINK
*
CF5      DS    0H                  lengths longer than 256
         CLC   2(256,WSB),2(WSC)
         BNE   CF3
         LA    WSB,256(WSB)
         LA    WSC,256(WSC)
         B     CF2                 loop for next segment
*
CF6      DS    0H                  both lengths 0 or one or both >= 32k
         BER   PLINK               if both zero
         N     WSD,HALFWORD        to 64k-1
         N     WSE,HALFWORD
         BR    ENTRY
         DROP  ENTRY,NEWP
*
CFCLC    CLC   2(0,WSB),2(WSC)     EXecuted
H256     DC    H'256'
HALFWORD DC    A(HALFMASK)
*
*
* PROC(REFâäINT)INT packstring
*
         $ENTRYF 24,WSB            define entry 24, arg to WSB
         L     WSC,0(WSB)          COUNT
         LR    WSA,WSB             TO BE LENGTH
         LR    WSE,WSA
         LTR   WSC,WSC
         BZ    PACK7               NULL STRING
*
PACK1    LA    WSB,4(WSB)          MAIN LOOP
         LA    WSA,1(WSA)
         MVC   1(1,WSA),3(WSB)
         BCT   WSC,PACK1
*
PACK7    SR    WSA,WSE
         STH   WSA,0(WSE)
         LA    WSA,5(WSA)          ROUND AND
         SRA   WSA,2                  POSITION AS INTEGER
         $EXITF
*
*
* PROC INT stackavailable
*          heapavailable
*          storeavailable
*
         $ENTRYF 34                stack
         $ENTRYF 35                heap
         $ENTRYF 36                store
         L     RESULT,0(DWOST)     dwost low water mark
         L     WSB,HEAPLIM         heap low water mark
         CLR   WSB,RESULT
         BNL   LDWOST
         LR    RESULT,WSB
LDWOST   DS    0H
         SLR   RESULT,NEWP
         $EXITF
*
*
* PROC INT storeused
*
* MVT only - allows for multiple regions belonging to this TCB
*
         $ENTRYF 37
         L     RESULT,0(DWOST)     dwost low water mark
         L     WSB,HEAPLIM         heap low water mark
         CLR   WSB,RESULT
         BNL   LDWOST1
         LR    RESULT,WSB
LDWOST1  DS    0H
         SLR   RESULT,NEWP
         LCR   RESULT,RESULT       -storeavailable
*
         L     WSB,16              ->CVT
         L     WSC,0(WSB)          ->TCBWORDS
         L     WSC,4(WSC)          ->TCB
         L     WSD,TCBDPQE(WSC)    ->DPQE (-8)
*Â         L     WSB,CVTMZ00(WSB)    amount of store of the m/c
         B     PQEL1
*
* note that the pqe chain can change dynamically because of the
* action of other tasks
* in any case, the store used will fluctuate if other tasks are
* active in this jobstep.
*
PQELOOP  LA    WSE,3
         NR    WSE,WSD
         BNZR  ENTRY               reenter if not at full word
         A     RESULT,PQEREGSZ(WSD) +size of this region
*Â         L     WSE,PQEFPQE(WSC)
*Â         LA    WSE,0(WSE)
*Â         CLR   WSE,WSD
*Â         BNER  ENTRY               if pqe chain is altered
*Â         L     WSE,PQEBPQE(WSD)
*Â         LA    WSE,0(WSE)
*Â         CLR   WSE,WSC
*Â         BNER  ENTRY               ditto
PQEL1    LA    WSC,0(WSD)
         L     WSD,PQEFPQE(WSC)    ->next (or first) pqe
         LA    WSD,0(WSD)          clear top byte
*Â         CR    WSD,WSB
*Â         BHR   ENTRY               points out of store
         LTR   WSD,WSD
         BNZ   PQELOOP             if not end of pqe chain
         $EXITF
TCBDPQE  EQU   152
CVTMZ00  EQU   164
PQEFPQE  EQU   8
PQEBPQE  EQU   12
PQEREGSZ EQU   20
*
*
*
*
*
*
* PROC(INT)VOID setreturncode
*
         $ENTRYF 20,WSA
         L     WSB,ARETCODE
         ST    WSA,0(WSB)
         $EXITF
*
*
*******************************************************************
*                                                                 *
* sysdecomposereal(REAL, REF INT, REF REAL)VOID:                  *
*                                                                 *
*******************************************************************
*
*
         $ENTRYF 77
         LM    WSA,WSD,FARG1
         L     WSE,EXPPART
         NR    WSE,WSA             extract exponent
         XR    WSA,WSE
         SRL   WSE,24
         O     WSA,EXP64
         ST    WSE,0(WSC)          set REF INT exponent part
         STM   WSA,WSB,0(WSD)      set REF REAL mantissa part
         $EXITF
*
EXPPART  DC    0F'0',X'7F000000'   exponent bits
EXP64    DC    0F'0',X'20000000'   exponent zero
*
*
*
*
*        enter here with run time errors
*
*
*
ESTOP    DS   0H
         BALR  ENTRY,0
         USING *,ENTRY
         LM    BASE,NXTBASE,ABASE
         DROP  ENTRY
         USING MAINBASE+4095,NXTBASE
         USING MAINBASE,BASE
         OC    EDUMP,EDUMP
         BNZ   STOPA               prevent looping
         ST    LINK,EDUMP
         L     FILE,ERROUT
         USING FDATA,FILE
         CLC   FBPTR,FBSTART
         BNE   ESTOP1
         CLC   FBLFE,FBSTART
         BE    ESTOP2               if line not used yet
ESTOP1   DS    0H
         $ICALL ENDREC
         $ICALL NXTREC
ESTOP2   DS    0H
         $ICALL ENDREC
         $ICALL NXTREC
         LH    STRL,COLLAPSE
         LA    STRA,2+COLLAPSE
         $ICALL PUTSTRE
         L     LINK,EDUMP
         LH    STRL,0(LINK)
         LA    STRA,2(LINK)
         $ICALL PUTSTRE
*
STOPA    LA    R15,12
         L     R14,ARETCODE
         ST    R15,0(R14)       set returncode
         B     STOP0
*
*        CLOSE ALL FILES
STOP0    DS    0H
         XC   ERROUT,ERROUT          allow it to be closed
         BALR  PLINK,0             LINK FOR REPEAT
         OC    FILECHN,FILECHN
         BZ    STOP1               NO FILES LEFT
         LA    NEWP,GFRAME         SET UP CALL OF CLOSE
         USING FRAME,NEWP
         MVC   ARG1,FILECHN
         LA    ENTRY,$$$$0033
         BR    ENTRY
         DROP  NEWP
*
STOP1    DS    0H
         DROP  BASE,NXTBASE
         L     R0,GDWBASE          COMPUTE STACK SIZE
         SR    R0,GLOBAL
         LR    R1,GLOBAL
         L     13,OLDSAVE
         FREEMAIN R,LV=(0),A=(1)  FREE STACK
         LM    LINK,12,R14DUMP
         BR    LINK
*
*
*
*
**************************************************************
*                                                            *
*                                                            *
*                                                            *
**************************************************************
*
         $GLOBAL GINITL            include initarea field
CHEK1    EQU   CHEK-INITAREA-GINITL
CHEK2    EQU   INITAREA-CHEK+GINITL
         DC    0Y(CHEK1),0Y(CHEK2) CHECK initialisation sizes
*
*
**************************************************************
*                                                            *
*                                                            *
*                                                            *
**************************************************************
*
*        DATA FOR OPEN
*
DCBDATA  DSECT
DATAFLG1 DS    X                   OPTION FLAGS
*        FINOUT, FPARM from FFLAGS
DATAFLG2 DS    X                   FLAGS FOR OPEN (+80)
*
         $DCBD
*
*
**************************************************************
*                                                            *
*                                                            *
*                                                            *
**************************************************************
*
*        GETMAIN WORK AREA
*
GETM     DSECT
         GETMAIN VU,MF=L
GETMLA   DS    2F                  VARIABLE LENGTH PAIR
GETMA    DS    2F                  RETURNED ADDRESS AND SIZE
GETML    EQU   *-GETM
*
*
*
*
         END   $A68INIT
./       ENDUP
