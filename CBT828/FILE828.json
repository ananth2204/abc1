{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012905000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 58786, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "CBT.V500.FILE828.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 58786, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 58786, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE828.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x02\\x0e'", "DS1TRBAL": "b'=~'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x05\\xaa\\x00\\x07\\x05\\xaa\\x00\\t\\x00\\x03'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04O\\x00D\\x01\\x10\\x12\\x0f\\x01\\x10\\x12\\x0f\\x147\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf9@@@'", "ispf": {"version": "04.79", "flags": 0, "createdate": "2010-04-30T00:00:00", "modifydate": "2010-04-30T14:37:44", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-479"}, "text": "REGULAR CBT TAPE - VERSION 479    FILE:  828\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT479.FILE828\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 3 MEMBERS COUNTED; CUMULATIVE SIZE IS 394 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   04/30/10    14:37:44    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE828": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04O\\x009\\x01\\x10\\x12\\x0f\\x01\\x10\\x12\\x0f\\x147\\x00\\x0e\\x00\\x0e\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf9@@@'", "ispf": {"version": "04.79", "flags": 0, "createdate": "2010-04-30T00:00:00", "modifydate": "2010-04-30T14:37:39", "lines": 14, "newlines": 14, "modlines": 0, "user": "CBT-479"}, "text": "//***FILE 828 contains an updated version of the DELAY program      *   FILE 828\n//*           that was originally submitted to the MVS 3.8          *   FILE 828\n//*           Turnkey #3 system and which is found on File 547      *   FILE 828\n//*           (buried in the ASM member there).                     *   FILE 828\n//*                                                                 *   FILE 828\n//*           This version of the DELAY program can be run in       *   FILE 828\n//*           several ways: in batch, TSO, or REXX, and it can      *   FILE 828\n//*           be called as a REXX function.  This version of        *   FILE 828\n//*           DELAY can wait in hundredths of a second also.        *   FILE 828\n//*                                                                 *   FILE 828\n//*           See comments in the program for further detail.       *   FILE 828\n//*                                                                 *   FILE 828\n//*           email:  somitcw@yahoo.com                             *   FILE 828\n//*                                                                 *   FILE 828\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DELAY": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x10\\x12\\x0f\\x01\\x10\\x12\\x0f\\t1\\x01p\\x01p\\x00\\x00\\xe2\\xd6\\xd4\\xc9\\xe3\\xc3\\xe6@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-04-30T00:00:00", "modifydate": "2010-04-30T09:31:00", "lines": 368, "newlines": 368, "modlines": 0, "user": "SOMITCW"}, "text": "//SOMITCWD JOB (????????,????,1439,9999),DELAY-SOMITCW,\n//             CLASS=?,MSGCLASS=?,\n//             NOTIFY=SOMITCW,COND=(0,NE)\n//*\n//HLASMCL EXEC PROC=HLASMCL,PARM.C=(RENT,OBJECT,NODECK,TERM),\n//  PARM.L=(TERM,LIST,RENT,REUS,REFR)\n//SYSTERM  DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=*\nPASS     TITLE 'DELAY - - - Set an STIMER with user specified value'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*     This program accepts the PARM in batch, TSO, or Rexx format,\n*  and delays the process for the requested number of seconds and\n*  hundredths of a second.  If tenths or hundredths of a second\n*  are needed, then PARM must contain a decimal point.\n*\n*     If called as a Rexx function, the actual wait time accepted\n*  will be the returned data.\n*\n*     Original DELAY program was a batch or called program only\n*  and only waited for seconds, not hundredths.\n*\n*     Updated 2010-04-26  To not abend when called without a PARM or\n*  when a Rexx EXEC passes a PARM of '.'.\n*\n*     Updated 2010-04-24  To allow running as a TSO CP, REXX\n*  external function, or batch program.  The update also allows\n*  tenths and hundredths of a second to be specified.\n*\n*     Tur(n)key #3 location of old version: SYS1.SETUP.ASM(DELAY)\n*\n*  //DELAY#1 EXEC PGM=DELAY,PARM=5      Wait five seconds\n*  //DELAY#2 EXEC PGM=DELAY,PARM=1.2    Wait one and one-fifth seconds\n*  //DELAY#3 EXEC PGM=DELAY,PARM='.01'  Minimum wait time\n*  //DELAY#4 EXEC PGM=DELAY,PARM=0      Will give minimum of .01\n*\n*  /* Rexx */\n* SAY DELAY(\"1.23\")      /* Will wait 1.23 seconds and then SAY 1.23 */\n* SAY DELAY(\"01.23456\")  /* Will wait 1.23 seconds and then SAY 1.23 */\n* CALL DELAY(\".2\")       /* Will wait for one-fifth of a second */\n* xxxx = DELAY(\"3\")      /* Will wait three seconds and SET xxxx = 3 */\n*\n*  READY\n* delay 1\n*  READY\n*\n*  Blame: somitcw@yahoo.com\n*\n* R13 = Register save area and work area\n* R12 = Base register\n* R11 = Input PARM list address\n* R10 = Address of input PARM seconds\n* R9  = Input PARM seconds length ( Should end up being 0 to 8 )\n* R8  = Address of input PARM hundreds of seconds\n* R7  = Input PARM hundreds of seconds length ( Should end up 0,1,or 2)\n* R6  = Address of Rexx return data if called as a Rexx function\n* R5  = Length of Rexx return data if called as a Rexx function\n* R4  = Rexx Evaluation Block if called as a Rexx function\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE\nDELAY    CSECT ,\nDELAY    AMODE ANY                Addressing mode of ANY\nDELAY    RMODE ANY                Residency mode of ANY\n         SAVE  (14,12),,'DELAY.&SYSDATE..&SYSTIME'    Save Reg.s\n         LR    R12,R15            Load the program's base register\n         USING DELAY,R12          Give the assembler the base reg.\n         LA    R11,0(,R1)         Save the address of the PARM list\n         LA    R0,WORKSIZE        Load work area size for GETMAIN\n         GETMAIN R,LV=(0)         Get storage for work space\n         XC    0(WORKSIZE,R1),0(R1)  Clear DSECT to binary zeroes\n         ST    R1,8(,R13)         Connect old and new save areas\n         ST    R13,4(,R1)         Connect old and new save areas\n         LR    R13,R1             Connect old and new save areas\n         USING WORKAREA,R13       Tell assembler of save area base reg.\n         MVC   PARMDISP,ZEROES    Initialize PARM convert area\n         LTR   R11,R11            See if the PARM register is zero\n         BZ    PACK               No PARM, go default to .01 seconds\n         ICM   R1,B'1111',0(R11)  See if first word of PARM list zero\n         BZ    REXXIN             Is REXX function PARM, go process\n         LA    R1,0(,R1)          Clear high-order bit or byte\n         LTR   R1,R1              See if the PARM address is zero\n         BZ    PACK               No PARM, go default to .01 seconds\n         TM    0(R11),X'80'       See if a batch program PARM\n         BO    BATCHIN            Is MVS batch program PARM, go process\n         CLI   2(R1),X'00'        See if TSO CP\n         BZ    TSOCPIN            Is TSO CP PARM format, go process\n         B     ERRPARM            PARM format not recognized, go abend\n*\n* REXX function arguments format\nREXXIN   DS    0H\n         L     R10,16(,R11)       Load address of argument addr&length\n         ICM   R9,B'1111',4(R10)  Load length of REXX argument\n         BNP   PACK               Not positive=no argument, go default\n         L     R10,0(,R10)        Load address of REXX argument\n         B     EATZEROS           Go to cleanup and format the argument\n*\n* TSO CP input PARM format\nTSOCPIN  DS    0H\n         SLR   R2,R2              Clear work register for ICM\n         ICM   R2,B'0011',2(R1)   Load the PARM displacement\n         BZ    PACK               No displacement, go default to .01\n         LA    R2,4(,R2)          Add length of first word of CPPL\n         LR    R10,R1             Load address of TSO CP command block\n         AR    R10,R2             Add displacement to calc PARM address\n         LA    R10,0(,R10)        Load address of REXX argument\n         SLR   R9,R9              Prepare to get PARM length\n         ICM   R9,B'0011',0(R1)   Get CPPL length\n         SLR   R9,R2              Get PARM data length\n         B     EATZEROS           Go to cleanup and format the argument\n*\n* Batch input PARM format\nBATCHIN  DS    0H\n         LA    R10,2(,R1)         Load address of the PARM data\n         SLR   R9,R9              Prepare to get PARM length\n         ICM   R9,B'0011',0(R1)   Get PARM length\n         BZ    PACK               No PARM length, go take default .01\n*        B     EATZEROS           Go to cleanup and format the argument\n*\n* Drop leading zeroes\nEATZEROS DS    0H\n         LTR   R9,R9              See if PARM length is zero\n         BZ    PACK               PARM was all zeroes, go assume 0.01\n         CLI   0(R10),C'0'        See if first byte is zero\n         BNE   FINDDOT            Leading zeroes dropped, go find dec.\n         LA    R10,1(,R10)        Move past a leading zero\n         BCTR  R9,0               Drop PARM length by one\n         B     EATZEROS           Go back to check for more leading 0's\n*\n* Find decimal point\nFINDDOT  DS    0H\n         LTR   R9,R9              See if PARM length is zero bytes\n         BZ    PACK               PARM 0, go use default of .01 seconds\n         LA    R10,0(,R10)        Clean PARM data location address\n         LR    R1,R9              Get length of PARM\n         BCTR  R1,0               Get length of PARM for EX instruction\n         EX    R1,TRT             Find if a decimal point in PARM\n         BZ    MOVWHOLE           Is whole number, skip decimal process\n         BH    ENDDOT             PARM has ending decimal point\n         LA    R8,1(,R1)          Load location of decimal fraction\n         LA    R1,0(,R1)          Clean period location address\n         SLR   R1,R10             Find length of whole number\n         LR    R7,R9              Find length of decimal part of number\n         SLR   R7,R1              Find length of decimal part of number\n         BCTR  R7,0               Find length of decimal part of number\n         LR    R9,R1              Save length of whole number\n         MVC   PARMDISP+8(1),0(R8)  Move first byte of decimal to pack\n         BCTR  R7,0               Drop length of fraction bytes by one\n         LTR   R7,R7              See if a second byte\n         BZ    MOVWHOLE           No other byte to move, go move whole\n         MVC   PARMDISP+9(1),1(R8)  Move second byte of dec. to pack\n         B     MOVWHOLE           No more bytes to move, go do whole no\n*\nTRT      TRT   0(*-*,R10),DOTTABLE  Find if decimal point in PARM\n*\nENDDOT   DS    0H\n         BCTR  R9,0               Drop ending period from PARM\n         LTR   R9,R9              See if any PARM left\n         BZ    PACK               PARM only a decimal point, go default\n*\nMOVWHOLE DS    0H\n* R10 is location of whole number part of the PARM\n* R9  is length of whole number part of the PARM\n         LTR   R9,R9              See if any whole number to move\n         BZ    PACK               No whole number, go pack fraction\n         CH    R9,H8              See if PARM whole no. over 8 bytes\n         BH    PARMLONG           If over 8 bytes, go abend\n         LA    R1,PARMDISP+8      Find where to move PARM to\n         SLR   R1,R9              Find where to move PARM whole number\n         LR    R2,R9              Load length of PARM whole number\n         BCTR  R2,0               Adjust PARM whole no. length for EX\n         EX    R2,MVCPARM         Copy PARM whole number for convert\n         B     PACK               Go pack and CVB the PARM and wait\n*\nMVCPARM  MVC   0(*-*,R1),0(R10)   Dummy copy for above EXecute\n*\nPACK     DS    0H\n         MVC   PARMCOMP,ZEROES    See if PARM is numeric\n         MVZ   PARMCOMP,PARMDISP  See if PARM is numeric\n         CLC   PARMCOMP,ZEROES    See if PARM is numeric\n         BNE   PARMINV            PARM not numeric, go abend\n         CLC   PARMDISP,TWOGIG    See if PARM greater than 21474836.47\n         BH    PARMLONG           PARM too great, go abend\n         PACK  PARMPACK,PARMDISP  Change display data to packed format\n         OI    PARMPACK+7,X'0F'   Insure a valid and positive sign\n         CVB   R1,PARMPACK        Change packed data to binary data\n         LTR   R1,R1              See of time of zero requested\n         BNZ   STORTIME           Not zero time, go store time\n         LA    R1,1               Set default of .01 seconds\n         MVI   PARMDISP+9,C'1'    Set default of .01 seconds\nSTORTIME DS    0H\n         ST    R1,TIME            Set time for STIMER to delay\n         ICM   R1,B'1111',0(R11)  See if first word of PARM list zero\n         BNZ   STIMER             Not REXX function PARM, go wait\n         L     R4,20(,R11)        Load REXX evaluation block address\n         L     R4,0(,R4)          Load REXX evaluation block address\n         CLI   7(R4),8            Insure REXX Eval.block 9 double words\n         BL    STIMER ? Abend ?   Eval. block too short, skip update\n         MVC   REXXRETD(8),PARMDISP  Copy whole number of seconds\n         MVI   REXXRETD+8,C'.'   Put decimal point for REXX return\n         MVC   REXXRETD+9(2),PARMDISP+8  Put decimal number for ret.\n         LA    R6,REXXRETD        Load address of max. data to return\n         LA    R5,11              Load maximum length to return\nEATLEAD0 DS    0H\n         CLI   0(R6),C'0'         See if a leading zero\n         BNE   NOWDOT             No more leading zeroes, go handle dot\n         LA    R6,1(,R6)          Bump to next REXX return data address\n         BCTR  R5,0               Drop length of REXX return data by 1\n         B     EATLEAD0           Go back to eat more leading zeroes\n*\nNOWDOT   DS    0H\n         CLI   REXXRETD+10,C'0'   See if trailing zero in hundredth pos\n         BNE   STORREXX           Not trailing, go store REXX ret. data\n         BCTR  R5,0               Drop length of REXX return data by 1\n         CLI   REXXRETD+9,C'0'    See if trailing zero in tenths pos.\n         BNE   STORREXX           Not trailing, go store REXX ret. data\n         BCTR  R5,0       zero    Drop length of REXX return data by 1\n         BCTR  R5,0       period  Drop length of REXX return data by 1\n*\nSTORREXX DS    0H\n         ST    R5,8(,R4)          Store return data length\n         BCTR  R5,0               Adjust length for following EX instr.\n         EX    R5,MVCREXX         Move REXX return data to REXX eval.\n*\nSTIMER   DS    0H\n         STIMER WAIT,BINTVL=TIME  Wait for requested number of seconds\n         LA    R0,WORKSIZE        Load work area size for FREEMAIN\n         LR    R1,R13             Save work area location for FREEMAIN\n         L     R13,4(,R1)         Restore the caller's save area addr.\n         FREEMAIN R,LV=(0),A=(1)  Free work area's storage\n         RETURN (14,12),RC=0      Return to caller w/retcode of zero\n*\nMVCREXX  MVC   16(*-*,R4),0(R6)   Move REXX output data\n*\n         EJECT ,\nERRPARM  DS    0H\n         WTO   'DELAY - PARM not Batch, TSO-CP, or REXX, abending',    C\n               ROUTCDE=(1,11)\n         ABEND 1111               Abend, no dump\n*\nPARMLONG DS    0H\n         WTO   'DELAY - Abending, PARM too long, max is 21474836.47',  C\n               ROUTCDE=(1,11)\n         ABEND 1112               Abend, no dump\n*\nPARMINV  DS    0H\n         WTO   'DELAY - Abending because PARM is not numeric',         C\n               ROUTCDE=(1,11)\n         ABEND 1113               Abend, no dump\n*\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*     Constants and literals\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\nH8       DC    H'8'               Constant for comparing PARM length\n*\nTWOGIG   DC    CL10'2147483647'   To init PARM display area\n*\nZEROES   DC    CL10'0000000000'   Value to init&check PARM display area\n*\n         LTORG ,                  In case someone uses literals\nDOTTABLE DC    0D'0',XL256'00'    TRT table to find decimal points\n         ORG   DOTTABLE+C'.'      Overlay the period position\n         DC    CL1'.'             Overlay the period position\n         ORG   ,                  Overlay the period position\n         EJECT ,\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*      DSECTs and register equates follow\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\nWORKAREA DSECT ,\n*\nSAVEAREA DS    18F                Register save area\n*\nPARMPACK DS    D                  PARM converted to packed area\nPARMDISP DS    CL10               PARM display-format area\nPARMCOMP DS    CL10               Area to check PARM for being numeric\nREXXRETD DS    CL11               Rexx return data work area\nTIME     DS    F                  Delay in hundredths/seconds in binary\n*\nWORKSIZE EQU   *-SAVEAREA\n*\n         IKJCPPL ,                TSO Command Processor Parameter List\n*\n* Rexx External Functions Parm List labels from TSO/E MACRO IRXEFPL\n* Old MACLIBs do not have Program Product TSO/E MACROs\n* so for compatibility, labels are not used.\n* LICENSED MATERIALS - PROPERTY OF IBM\n* THIS MACRO IS \"RESTRICTED MATERIALS OF IBM\"\n* 5685-025 (C) COPYRIGHT IBM CORP. 1988, 1991\n* SEE COPYRIGHT INSTRUCTIONS\n* Defaults to DSECT=YES for DSECT\n* If DSECT=YES\n* EFPL     DSECT ,\n* EFPLCOM  DS A     * Reserved\n* EFPLBARG DS A     * Reserved\n* EFPLEARG DS A     * Reserved\n* EFPLFB   DS A     * Reserved\n* EFPLARG  DS A     * Pointer to Arguments Table\n* EFPLEVAL DS A     * Pointer to address of EvalBlock\n*\n* Rexx Argument Table labels from TSO/E MACRO IRXARGTB\n* Old MACLIBs do not have Program Product TSO/E MACROs and\n* labels are too long for old assemblers like IFOX00,\n* so for compatibility, labels are not used.\n* LICENSED MATERIALS - PROPERTY OF IBM\n* THIS MACRO IS \"RESTRICTED MATERIALS OF IBM\"\n* 5685-025 (C) COPYRIGHT IBM CORP. 1988, 1991\n* SEE COPYRIGHT INSTRUCTIONS\n* Defaults to DECLARE=NO for DSECT\n* If DECLARE=NO\n* ARGTABLE_ENTRY DSECT ,                 REXX Argument Table Entry\n*          DS  0D                        Align on doubleword boundary\n* ARGTABLE_ARGSTRING_PTR    DS  A        Address of the argument string\n* ARGTABLE_ARGSTRING_LENGTH DS  F        Length of the argument string\n* ARGTABLE_NEXT             DS  0D       Next ARGTABLE entry\n*          DS  0D                        Align on doubleword boundary\n* ARGSTRING DSECT ,                      REXX Argument String\n* ARGTABLE_END DC  XL8'FFFFFFFFFFFFFFFF' End of ARGTABLE marker\n*\n* Rexx Evaluation Block labels from TSO/E MACRO IRXEVALB\n* Old MACLIBs do not have Program Product TSO/E MACROs and\n* labels are too long for old assemblers like IFOX00,\n* so for compatibility, labels are not used.\n* LICENSED MATERIALS - PROPERTY OF IBM\n* THIS MACRO IS \"RESTRICTED MATERIALS OF IBM\"\n* 5685-025 (C) COPYRIGHT IBM CORP. 1988, 1991\n* SEE COPYRIGHT INSTRUCTIONS\n* Defaults to DECLARE=NO for DSECT\n* If DECLARE=NO\n* EVALBLOCK DSECT ,              REXX Evaluation Block\n* EVALBLOCK_EVPAD1 DS  F         Reserved - set to binary zero\n* EVALBLOCK_EVSIZE DS  F         Size of EVALBLOCK in double words\n* EVALBLOCK_EVLEN  DS  F         Length of data\n* EVALBLOCK_EVPAD2 DS  F         Reserved - set to binary zero\n* EVALBLOCK_EVDATA DS  C         Result\n* Notes: EVALBLOCK_EVLEN is X'80000000' on input to indicate if\n* a new length is stored to indicate data returned.\n* EVALBLOCK_EVDATA is the first byte of the data but cannot\n* exceed EVALBLOCK_EVLEN\n*\nR0       EQU   0                  Register equate for register 0\nR1       EQU   1                  Register equate for register 1\nR2       EQU   2                  Register equate for register 2\nR3       EQU   3                  Register equate for register 3\nR4       EQU   4                  Register equate for register 4\nR5       EQU   5                  Register equate for register 5\nR6       EQU   6                  Register equate for register 6\nR7       EQU   7                  Register equate for register 7\nR8       EQU   8                  Register equate for register 8\nR9       EQU   9                  Register equate for register 9\nR10      EQU   10                 Register equate for register 10\nR11      EQU   11                 Register equate for register 11\nR12      EQU   12                 Register equate for register 12\nR13      EQU   13                 Register equate for register 13\nR14      EQU   14                 Register equate for register 14\nR15      EQU   15                 Register equate for register 15\n         END   ,                  The end of the program\n//*\n//L.SYSLMOD  DD  DISP=SHR,DSN=????.LOAD????\n NAME DELAY\n//*\n//CHECKCC EXEC PGM=IEFBR14\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT828/FILE828.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT828", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}