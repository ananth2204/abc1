{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013528000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 470288, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 10, "INMDSNAM": "CBT.V500.FILE941.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 470288, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 470288, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE941.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\t\\x07'", "DS1TRBAL": "b'\\x9d\\xea'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\t\\xa7\\x00\\x0b\\t\\xa8\\x00\\x05\\x00\\n'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04`\\x00\"\\x01\\x18\\x17\\x8f\\x01\\x18\\x17\\x8f\\x11D\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf6@@@'", "ispf": {"version": "04.96", "flags": 0, "createdate": "2018-06-27T00:00:00", "modifydate": "2018-06-27T11:44:22", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-496"}, "text": "REGULAR CBT TAPE - VERSION 496    FILE:  941\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT496.FILE941\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 28 MEMBERS COUNTED; CUMULATIVE SIZE IS 4,292 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   06/27/18    11:44:21    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE00": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x16\\x10/\\x01\\x16\\x10/!P\\x00\\x14\\x00\\x14\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-04-11T00:00:00", "modifydate": "2016-04-11T21:50:59", "lines": 20, "newlines": 20, "modlines": 0, "user": "SBGOLOB"}, "text": "NOTES FOR THE USE OF THIS FILE.\n----- --- --- --- -- ---- ----\n\n\n1.   The member of this pds called HTML is an XMIT-format pds of\n     help files for the utilities in this file, in HTML format.\n     Because of the size of the lines comprising the screen images,\n     this HTML file, when RECEIVED, is RECFM=VB,LRECL=255, and a\n     pds.\n\n     The members in that pds are in EBCDIC format, so to read their\n     HTML content, you would have to download them to a PC while\n     translating the text to ASCII, and then the help contents\n     can be browsed on the PC with a browser.\n\n     TO MAKE LIFE EASIER FOR YOU, WE HAVE TRANSLATED THESE HTML\n     HELP FILES INTO EBCDIC TEXT, CONTAINING THE SAME CONTENTS.\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$NOTE01": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x007\\x01\\x16\\x10/\\x01\\x16\\x10/!W\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-04-11T00:00:00", "modifydate": "2016-04-11T21:57:37", "lines": 28, "newlines": 28, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  Contribution I\nFrom:     GBliznets@iba.by\nDate:     3/25/2016 9:28 AM\nTo:       sbgolob@cbttape.org\n\nHello dear Mr. Golob.\n\nI'd like to offer MVS-related tools written by me for a years.\nLet me start from the few simple tools:\n\n1. Simple AMBLIST interactive interface\n\n2. Generate data set definition for an existing data set\n   (Supersede CBT tape file 920).   Called DDL.\n\n3. Load ISPF Table from CSV (comma-separated values) flat file\n   and vice versa. Allow ISPF tables' maintenance under SCLM.\n   Called CSV2ISP and ISP2CSV.\n\n\nAs you see, I've contributed both MF format (XMIT) as well as PC\nformat (zip). Just let me know if this packaging is inconvenient\n\nPlease consider my files.  Thank you.\n\nRegards,\nGregory.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$NOTE02": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00&\\x01\\x18\\x10\\x0f\\x01\\x18\\x10\\x0f\\x19C\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-04-10T00:00:00", "modifydate": "2018-04-10T19:43:26", "lines": 14, "newlines": 14, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  File 941 replacement\nFrom:     GBliznets@iba.by\nDate:     4/10/2018 7:57 AM\nTo:       sbgolob@cbttape.org\n\nHi Sam,\n\nPlease consider file attached, this is a\u00a0CBT Tape file 941\nreplacement. I've added few tools (RESIZE, LA, TRAP), I hope they\ncould be useful.\n\nThank you,\nGregory\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$NOTE03": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x18\\x17\\x8f\\x01\\x18\\x17\\x8f\\x11B\\x00\\x11\\x00\\x11\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-06-27T00:00:00", "modifydate": "2018-06-27T11:42:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  File 941 replacement\nFrom:     GBliznets@iba.by\nDate:     6/26/2018 6:14 AM\nTo:       \"Sam Golob\" <sbgolob@cbttape.org>\n\nHi Sam,\n\nPlease consider file attached, this is CBT Tape file 941 replacement:\n- RESIZE covers VSAM data sets now (as well as PS and PO\u00ddE\u00a8);\n- AMBLIST supports large output;\n- FEEDBACK is added;\n\n(See attached file: CBT941.zip)\n\nThank you,\nGregory\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE941": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04`\\x00\\x14\\x01\\x18\\x17\\x8f\\x01\\x18\\x17\\x8f\\x11D\\x00\\x1f\\x00\\x1f\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf6@@@'", "ispf": {"version": "04.96", "flags": 0, "createdate": "2018-06-27T00:00:00", "modifydate": "2018-06-27T11:44:14", "lines": 31, "newlines": 31, "modlines": 0, "user": "CBT-496"}, "text": "//***FILE 941 is from Gregory Bliznets and contains several of      *   FILE 941\n//*           his REXX-based utilities.                             *   FILE 941\n//*                                                                 *   FILE 941\n//*           email:  GBliznets@iba.by                              *   FILE 941\n//*                                                                 *   FILE 941\n//*       The utilites are:                                         *   FILE 941\n//*                                                                 *   FILE 941\n//*       AMBLIST   -  A tool to run an AMBLIST in various formats  *   FILE 941\n//*                    and display the results to ISPF.             *   FILE 941\n//*                                                                 *   FILE 941\n//*       ISP2CSV   -  Dumping your ISPF command tables to a        *   FILE 941\n//*                    comma-separated format for post-processing.  *   FILE 941\n//*                                                                 *   FILE 941\n//*       CSV2ISP   -  The reverse of ISP2CSV.                      *   FILE 941\n//*                                                                 *   FILE 941\n//*       DDL       -  A tool to look at a VSAM catalog and         *   FILE 941\n//*                    create card-images to re-define the          *   FILE 941\n//*                    entries cataloged in it, also calculate      *   FILE 941\n//*                    required space.                              *   FILE 941\n//*                                                                 *   FILE 941\n//*       RESIZE    -  A tool to easily resize (reallocate) any     *   FILE 941\n//*                    data set with or without saving data.        *   FILE 941\n//*                                                                 *   FILE 941\n//*       LA        -  List allocated data set as set of ALLOCATE   *   FILE 941\n//*                    command or JCL DD statements.                *   FILE 941\n//*                                                                 *   FILE 941\n//*       TRAP      -  Trap TSO command output and allow Browse     *   FILE 941\n//*                    or Edit it.                                  *   FILE 941\n//*                                                                 *   FILE 941\n//*       FEEDBACK  -  Complete job notification.                   *   FILE 941\n//*                                                                 *   FILE 941\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "AMBLIST": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x01\\x01\\x18\\x17\\x8f\\x01\\x18\\x17\\x8f\\x117\\x00\\xf3\\x00\\xf3\\x00\\x00\\xc2\\xd3\\xc9\\xe9\\xd5\\xc5\\xe3\\xe2@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-06-27T00:00:00", "modifydate": "2018-06-27T11:37:01", "lines": 243, "newlines": 243, "modlines": 0, "user": "BLIZNETS"}, "text": "/* REXX/370 */\n/*\n\nDescription:\n       AMBLIST interactive interface\n\nFunction:\n       Invoke AMBLIST interactively to perform an available function\n       (LISTIDR, LISTLOAD, LISTOBJ, LISTLPA) and browse output.\n\nSyntax:\n       AMBLIST\n\nParameters:\n       none\n\nNote:\n       This code contains inline ISPF elements (panel)\n\n(C) 2006-2018 Gregori Bliznets gbliznets@iba.by\n\n*/\ntrace off\nrc = loadispf()\nif rc <> 0\nthen exit 1\nzmsg = ''\ndo forever\n  address ISPEXEC 'DISPLAY PANEL(AMBLIST)'\n  if rc > 4\n  then leave\n  address TSO\n  if O <> 5\n  then do\n    volume = ''\n    if ambvol <> ''\n    then volume = 'VOLUME('ambvol')'\n    call outtrap 'NIL.'\n    'FREE FI(SYSLIB)'\n    call outtrap 'OFF'\n    call outtrap 'TSO.'\n    \"ALLOC FI(SYSLIB) SHR DA('\"ambdsn\"') \"volume\n    call outtrap 'OFF'\n    end\n  if rc <> 0\n  then do\n    zmsg = tso.1\n    iterate\n    end\n  zmsg = ''\n  call outtrap 'NIL.'\n  'FREE FI(SYSIN SYSPRINT)'\n  call outtrap 'OFF'\n  'ALLOC FI(SYSIN) UNIT(VIO) SP(1,1) TRACK RECFM(F) LRECL(80) BLKSIZE(80)'\n  if ambunit = 'TRK'\n  then ambunit = 'TRACK'\n  if ambunit = 'CYL'\n  then ambunit = 'CYLINDER'\n  'ALLOC FI(SYSPRINT) UNIT(VIO) SP('ambpri','ambsec') 'ambunit,\n        'RECFM(F) LRECL(121) BLKSIZE(5687)'\n  stmt.0 = 1\n  select\n  when O = 1\n  then stmt.1 = ' LISTIDR MEMBER='ambmem\n  when O = 2\n  then stmt.1 = ' LISTLOAD OUTPUT=XREF,MEMBER='ambmem\n  when O = 3\n  then stmt.1 = ' LISTLOAD MEMBER='ambmem\n  when O = 4\n  then stmt.1 = ' LISTOBJ MEMBER='ambmem\n  when O = 5\n  then stmt.1 = ' LISTLPA'\n  end\n  'EXECIO 1 DISKW SYSIN (STEM STMT. FINIS'\n  call outtrap off\n  \"CALL 'SYS1.LINKLIB(AMBLIST)'\"\n  address ISPEXEC\n  'LMINIT DATAID(AMBROWSE) DDNAME(SYSPRINT)'\n  'BROWSE DATAID('AMBROWSE')'\n  'LMFREE DATAID('AMBROWSE')'\nend\naddress TSO\ncall outtrap 'NIL.'\n'FREE FI(SYSLIB SYSIN SYSPRINT)'\n'ALLOC FI(SYSPRINT) DA(*)'\nrc = quitispf()\ncall outtrap 'OFF'\nexit\n\n/* Load ISPF elements that are inline in the REXX source code */\nLoadISPF:\n  dataid = ''\n  address TSO\n  call outtrap 'NIL.'\n  'FREE FI($$ISPF$$)'\n  'ALLOC FI($$ISPF$$) UNIT(VIO) SPACE(5,5) DIR(1)' ,\n    'LRECL(80) RECFM(F B) BLKSIZE(0)'\n  call outtrap 'OFF'\n  address ISPEXEC\n  'CONTROL ERRORS RETURN'\n  'LMINIT DATAID(DATAID) DDNAME($$ISPF$$)'\n  'LMOPEN DATAID('dataid') OPTION(OUTPUT)'\n  keys = 'START PANEL MSG SKEL END'\n  drop data.\n  data.0 = 0\n  found = 0\n  do i = sourceline() to 1 by -1\n    s = sourceline(i)\n    parse upper var s 1 ?? +2 keyword name .\n    select\n    when ?? = './'\n    then do\n      n = wordpos(keyword, keys)\n      select\n      when n = 0\n      then signal quit /* unknown marker */\n      when n = 1\n      then leave i /* top marker */\n      when n = words(keys)\n      then found = 1 /* bottom marker */\n      otherwise /* marker found */\n        if name = ''\n        then signal quit /* Name is missed */\n        if data.0 = 0\n        then iterate i /* empty element */\n        do n = data.0 to 1 by -1\n          s = data.n\n          'LMPUT DATAID('dataid') MODE(INVAR) DATALOC(S) DATALEN(80)'\n        end n\n        'LMMADD DATAID('dataid') MEMBER('name')'\n        drop data.\n        data.0 = 0\n      end\n      end\n    when found = 0\n    then iterate i\n    otherwise /* data element */\n      n = data.0+1\n      data.n = s\n      data.0 = n\n    end\n  end i\n  'LMCLOSE DATAID('dataid')'\n  'LMFREE DATAID('dataid')'\n  'LIBDEF ISPPLIB LIBRARY ID($$ISPF$$) STACK'\n  'LIBDEF ISPMLIB LIBRARY ID($$ISPF$$) STACK'\n  'LIBDEF ISPSLIB LIBRARY ID($$ISPF$$) STACK'\n  return 0\n\nQuitISPF:\n  address ISPEXEC\n  'CONTROL ERRORS RETURN'\n  if dataid <> ''\n  then do\n    'LMCLOSE DATAID('dataid')'\n    'LMFREE DATAID('dataid')'\n     end\n  'LIBDEF ISPPLIB'\n  'LIBDEF ISPMLIB'\n  'LIBDEF ISPSLIB'\n  address TSO 'FREE FI($$ISPF$$)'\n  return 0\n\n/* Inline ISPF elements follow:\n./START\n./PANEL AMBLIST\n)ATTR\n + TYPE(TEXT) INTENS(LOW)\n % TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n _ TYPE(INPUT) INTENS(HIGH) COLOR(WHITE) JUST(LEFT)\n \u00ac  TYPE(OUTPUT) INTENS(HIGH) CAPS(OFF) COLOR(YELLOW) JUST(LEFT)\n)BODY EXPAND (//)\n%-/-/ Interactive AMBLIST -/-/\n%Command ===>_ZCMD                                                     +\n\u00acZMSG                                                                          +\n+\n+Option. . . . . . . _O+ 1 LISTIDR (List load module identification records)\n+                        2 LISTLOAD XREF (Load module cross-reference)\n+                        3 LISTLOAD (Load module map)\n+                        4 LISTOBJ (Object module map)\n+                        5 LISTLPA (Link Pack Area listing)\n+\n+Input\n+Library . . . . . . _AMBDSN                                      +\n+Member. . . . . . . _AMBMEM  +\n+Volume serial . . . _AMBVOL+\n+\n+Output\n+Space units . . . . _AMBUNIT+ (TRACK, TRK, CYLINDER, CYL)\n+Primary quantity. . _AMBPRI+  (In above units)\n+Secondary quantity. _AMBSEC+  (In above units)\n+\n)INIT\n .HELP = 'AMBLISTH'\n &ZPRIM = NO\n .CURSOR = O\n &O = &AMBOPT\n &AMBPRI = 5\n &AMBSEC = 5\n &AMBUNIT = TRACK\n IF (&O = &Z )\n    &O = 1\n)PROC\n  VER (&O,NONBLANK)\n  VER (&O,LIST,1,2,3,4,5)\n  IF  (&O NE 5)\n    VER (&AMBDSN,NONBLANK)\n    VER (&AMBDSN,DSNAME)\n    VER (&AMBMEM,NONBLANK)\n    VER (&AMBMEM,NAME)\n  &AMBOPT = &O\n  VER (&AMBUNIT,LIST,CYLINDER,CYL,TRACK,TRK)\n  VER (&AMBPRI,NUM)\n  VER (&AMBSEC,NUM)\n  VPUT (AMBDSN AMBMEM AMBOPT AMBVOL AMBPRI AMBSEC AMBUNIT) PROFILE\n)END\n./PANEL AMBLISTH\n)ATTR\n + TYPE(TEXT) INTENS(LOW)\n % TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n _ TYPE(INPUT) INTENS(HIGH) COLOR(WHITE) JUST(LEFT)\n \u00ac  TYPE(OUTPUT) INTENS(HIGH) CAPS(OFF) COLOR(YELLOW) JUST(LEFT)\n)BODY EXPAND (//)\n%-/-/ Interactive AMBLIST -/-/\n%Command ===>_ZCMD                                                     +\n\u00acZMSG                                                                          +\n+\n+Specify AMBLIST option:\n+  1 - LISTIDR - list load module identification records\n+  2 - LISTLOAD XREF - load module cross-reference\n+  3 - LISTLOAD - load module map\n+  4 - LISTOBJ - object module map\n+  5 - LISTLPA - Link Pack Area listing\n+\n+For all options except 5 (LISTLPA) full qualified library name without\n+quotes and member name must be specified. Volume serial required if\n+library is not cataloged (antique systems). Specify space allocation\n+for output report if required (need to be increased for large module,\n+like IEANUC01 etc.). See \"MVS Diagnosis: Tools and Service Aids\" manual\n+for AMBLIST detail description.\n)END\n./END\n*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AMBLIST#": {"ttr": 533, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00C\\x01\\x18\\x10/\\x01\\x18\\x10/\\x16R\\x00P\\x00P\\x00\\x00\\xc8\\xc5\\xd3\\xd7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-04-12T00:00:00", "modifydate": "2018-04-12T16:52:43", "lines": 80, "newlines": 80, "modlines": 0, "user": "HELP"}, "text": "\nFunction:\n\n\nInvoke AMBLIST interactively to perform an available function\n(LISTIDR, LISTLOAD, LISTOBJ, LISTLPA) and browse output.\n\n\n\nSyntax:\n\n     AMBLIST\n\n\n\nUsage:\n\n     Select Option(1-4), specify library name, member and volume\n     serial when library if not cataloged. Then press enter. AMBLIST\n     output appears.\n\n\n ----------------------------- Interactive AMBLIST -----------------------------\n Command ===>\n\n\n Option. . . . . .  1  1 LISTIDR (List load module identification records)\n                       2 LISTLOAD XREF (Load module cross-reference)\n                       3 LISTLOAD (Load module map)\n                       4 LISTOBJ (Object module map)\n                       5 LISTLPA (Link Pack Area listing)\n\n Input\n Library . . . . . .  SYS1.LINKLIB\n Member. . . . . . .  IEFBR14\n Volume serial . . .\n\n Output\n Space units . . . .  TRACK    (TRACK, TRK, CYLINDER, CYL)\n Primary quantity. .  5        (In above units)\n Secondary quantity.  5        (In above units)\n\n Specify AMBLIST option. For all options except 5 (LISTLPA) full qualified\n library name without quotes and member name must be specified. Volume serial\n required if library is not cataloged. Specify space allocation if required.\n\n\n  F1=HELP      F2=SPLIT     F3=END       F4=RETURN    F5=RFIND     F6=RCHANGE\n  F7=UP        F8=DOWN      F9=SWAP     F10=LEFT     F11=RIGHT    F12=RETRIEVE\n\n\n\n\n   Menu  Utilities  Compilers  Help\n -------------------------------------------------------------------------------\n BROWSE    SYS16049.T161057.RA000.IBMUSER.R0100323    Line 00000000 Col 001 080\n********************************* Top of Data **********************************\n LISTIDR MEMBER=IEFBR14\n                                  *****  M O D U L E   S U M M A R Y  *****\n    MEMBER NAME:  IEFBR14\n    LIBRARY:      SYSLIB\n        NO ALIASES **\n--------------------------------------------------------------------------------\n                       ****          ATTRIBUTES OF MODULE           ****\n                **   BIT  STATUS         BIT  STATUS         BIT  STATUS\n                      0  RENT             1  REUS             2  NOT-OVLY\n                      4  NOT-OL           5  BLOCK            6  EXEC\n                      8  NOT-DC           9  ZERO-ORG         10 EP-ZERO\n                      12 EDIT             13 NO-SYMS          14 F-LEVEL\n--------------------------------------------------------------------------------\n                                    MODULE SSI:        NONE\n                                    APFCODE:           00000000\n                                    RMODE:             24\n\n Command ===>                                                  Scroll ===> PAGE\n  F1=Help    F2=Split   F3=Exit    F5=Rfind   F7=Up      F8=Down    F9=Swap\n F10=Left   F11=Right  F12=Cancel\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CSV2ISP": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x01\\x01\\x18\\x17\\x8f\\x01\\x18\\x17\\x8f\\x117\\x00\\xee\\x00\\xee\\x00\\x00\\xc2\\xd3\\xc9\\xe9\\xd5\\xc5\\xe3\\xe2@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-06-27T00:00:00", "modifydate": "2018-06-27T11:37:01", "lines": 238, "newlines": 238, "modlines": 0, "user": "BLIZNETS"}, "text": "/* REXX */\n/*\n\nFunction:\n       Load ISPF table from CSV file\n\nSyntax:\n       CSV2ISP csv table \u00a2fs \u00a2fd!!\n\nHistory:\n       Created 02/2005\n       Updated 09/2005 - command syntax changed to fit SCLM\n       Updated 09/2012 - reviewed and rewritten\n\n(C) 2005-2012 Gregory Bliznets gbliznets@iba.by\n\n*/\ntrace off\nparse upper arg csv tbl fs fd\naddress ISPEXEC\n'CONTROL ERRORS RETURN'\nlower = 'qwertyuiopasdfghjklzxcvbnm'\nparse upper var lower upper\ndigits = '0123456789'\nspecial = '$_@'\nself = 'CSV2ISP'\nzispfrc = 0\ntbopen = 0\ntbcreate = 0\nlmid = ''\nlmopen = 0\nisptdd = 'ISPTABL'\n\nif tbl = ''\nthen call error 16, 'Table was not specified'\nif pos('=', tbl) > 0\nthen do /* reference to the ddname */\n  tblref = 'DDNAME'\n  parse var tbl keyword '=' isptlib '(' table ')'\n  if abbrev('DDNAME', ToUpper(keyword), 2) = 0\n  then call error 16, 'Invalid table specification: 'tbl\n  if isptlib = ''\n  then call error 16, 'Invalid table specification: 'tbl\n  if table = ''\n  then call error 16, 'Invalid table specification: 'tbl\n  rc = ISPF(0, \"LIBDEF \"isptdd\" LIBRARY ID(\"isptlib\")\")\n  end\nelse do /* data set name specified */\n  tblref = 'DSNAME'\n  parse var tbl isptlib '(' table ')'\n  if isptlib = ''\n  then call error 16, 'Invalid table specification: 'tbl\n  if table = ''\n  then call error 16, 'Invalid table specification: 'tbl\n  if Exists(isptlib) = 0\n  then call error 16, isptlib' does not exists'\n  rc = ISPF(0, \"LIBDEF \"isptdd\" DATASET ID('\"isptlib\"')\")\n  end\n\nif csv = ''\nthen call error 16, 'CSV input not specified'\nif pos('=', csv) > 0\nthen do /* reference to the ddname */\n  csvref = 'DDNAME'\n  parse var csv keyword '=' csvdd '(' csvmember ')'\n  if abbrev('DDNAME', ToUpper(keyword), 2) = 0\n  then call error 16, 'Invalid CSV specification'\n  if csvdd = ''\n  then call error 16, 'Invalid CSV specification'\n  end\nelse do /* data set name specified */\n  csvref = 'DSNAME'\n  parse var csv csvdsname '(' csvmember ')'\n  if exists(csv) = 0\n  then call error 16, csv' does not exists'\n  csvdd = self\n  end\n\nif fs = ''\nthen fs = ','\nif length(fs) = 2 & datatype(fs,'X') = 1\nthen fs = x2c(fs)\nif length(fs) <>  1\nthen call error 16, 'Invalid field separator 'fs\nif fd = ''\nthen fd = '\"'\nif length(fd) = 2 & datatype(fd,'X') = 1\nthen fd = x2c(fd)\nif length(fd) <>  1\nthen call error 16, 'Invalid field delimiter 'fd\nif fs = fd\nthen call error 16, 'Field delimiter and field separator cannot be the same'\n\n/* Open CSV */\nif csvref = 'DDNAME'\nthen lmopt = \"DDNAME(\"csvdd\")\"\nelse lmopt = \"DATASET('\"csvdsname\"')\"\nlmopt = lmopt' ENQ(SHR)'\nrc = ISPF(0, \"LMINIT DATAID(LMID) \"lmopt)\nlmid = 'DATAID('lmid')'\nlmopt = 'OPTION(INPUT)'\nrc = ISPF(0, 'LMOPEN 'lmid' 'lmopt)\nlmopen = 1\n\nif csvmember <> ''\nthen rc = ISPF(0, 'LMMFIND 'lmid' MEMBER('csvmember') STATS(NO)')\n/* Read and parse CSV header */\nparse value '' with keys names\nlmopt = 'MODE(INVAR) MAXLEN(32768)'\nrc = ISPF(8, 'LMGET 'lmid' DATALOC(LINE) DATALEN(L) 'lmopt)\nif rc = 8\nthen call error rc, csv' is empty'\ndo while line <>  ''\n  parse var line name (fs) line\n  name = strip(name)\n  if IsName(name) = 0\n  then call error rc, 'Invalid column name: 'name\n  if left(name, 2) = '__'\n  then call error rc, 'Unsupported column name: 'name\n  if IsUpper(name) = 1\n  then keys = keys' 'name\n  else names = names' 'name\nend\n/* Create table */\nparms = ''\nif keys <>  ''\nthen parms = parms' KEYS('strip(keys)')'\nif names <>  ''\nthen parms = parms' NAMES('strip(ToUpper(names))')'\nrc = ISPF(4, 'TBCREATE 'table' 'parms' REPLACE')\ntbcreate = 1\n\n/* Read and process CSV data records */\ndo n = 2 /* until EOF reached */\n  rc = ISPF(8, 'LMGET 'lmid' DATALOC(LINE) DATALEN(L) 'lmopt)\n  if rc = 8 /* EOF reached */\n  then leave\n  rc = TBPut(table, keys' 'names, strip(line), fd, fs, n)\nend n\nrc = ISPF(0, 'TBSAVE 'table)\nsay tbl' loaded from 'csv\n\nQuit:\n  if tbcreate = 1\n  then 'TBEND 'table\n  if lmopen = 1\n  then 'LMCLOSE 'lmid\n  if lmid <> ''\n  then 'LMFREE 'lmid\n  if isptdd <> ''\n  then 'LIBDEF 'isptdd\n  \"VPUT (ZISPFRC)\"\n  exit zispfrc\n\nError: parse arg zispfrc, text\n  say text\n  signal Quit\n\nTBPut: procedure\n  /*\n  Note: variable names prefixed here with __ to avoid accidental change when\n  table column has the same name as variable (let suppose column name FD)\n  */\n  parse arg __table, __vars, __values, __fd, __fs, __n\n  __fdfs = __fd''__fs\n  do while __vars <>  ''\n    parse var __vars __var __vars\n    if __values = '' & __vars <> ''\n    then call error 20, 'Too few data at line '__n\n    if left(__values, 1) = __fd /* delimited field */\n    then do\n      if __vars = '' /* last field */\n      then parse var __values (__fd) __value (__fd) __values\n      else parse var __values (__fd) __value (__fdfs) __values\n      if pos(__fd''__fd, __value) > 0\n      then __value = ChangeStr(__fd''__fd, __fd, __value)\n      end\n    else parse var __values __value (__fs) __values\n    parse upper var __var __var .\n    call value __var, __value\n  end\n  if __values <> ''\n  then call error 20, 'Too many data at line '__n\n  rc = ISPF(4, 'TBADD '__table)\n  return rc\n\n/* Check string for uppercase letters / digits / special */\nIsUpper:\n  return verify(arg(1), upper''digits''special) = 0\n\n/* Check string for valid ISPF table field name */\nIsName:\n  return (verify(arg(1), lower''upper''digits''special) = 0) & ,\n         (verify(left(arg(1),1), lower''upper''special) = 0)\n\n/* Lowercase string */\nToLower:\n  return translate(arg(1), lower, upper)\n\n/* Uppercase string */\nToUpper:\n  return translate(arg(1), upper, lower)\n\n/* Case-independent changestr function */\nChangeStr: procedure\n  parse arg needle, haystack, newneedle\n  parse upper arg upper_needle, upper_haystack\n  result = ''\n  p1 = 1;\n  do forever\n    p2 = pos(upper_needle, upper_haystack, p1)\n    if p2 = 0\n    then leave\n    result = result''substr(haystack,p1,p2-p1)''newneedle\n    p1 = p2 + length(needle)\n  end\n  return result''substr(haystack, p1)\n\n/* Check if library(member) exists */\nExists: procedure\n  parse arg dsn\n  msgmode = 'MSG'('OFF')\n  rc = 'SYSDSN'(\"'\"dsn\"'\") = 'OK'\n  msgmode = 'MSG'(msgmode)\n  return rc\n\nISPF:\n  address ISPEXEC arg(2)\n  if rc > arg(1)\n  then do\n    say self' terminated due to ' word(arg(2),1) 'error' rc':'\n    address ISPEXEC 'VGET (ZERRMSG ZERRLM)'\n    msg = ZERRMSG' 'ZERRLM\n    say arg(2)\n    say msg\n    signal quit\n    end\n  return rc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CSV2ISP#": {"ttr": 774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x10\\x01\\x16\\x10/\\x01\\x16\\x10/\\x16H\\x00\\xb0\\x00\\xb0\\x00\\x00\\xc8\\xc5\\xd3\\xd7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-04-11T00:00:00", "modifydate": "2016-04-11T16:48:10", "lines": 176, "newlines": 176, "modlines": 0, "user": "HELP"}, "text": "\nCSV2ISP - load ISPF table from CSV file\n\nFunction:\n    Load ISPF Table from CSV comma-separated flat file (CSV file)\n    produced by ISP2CSV procedure as well as any spreadsheet\n    processor or any other tool.\n\n    This procedures can be used to perform the following tasks:\n\n        Perform data exchange between z/OS ISPF and any workstation\n        spreadsheet processor (MS Excel, Lotus 123 and so on). CSV\n        file processed by both procedures has the same structure as\n        used by the workstations spreadsheet processors. Data can be\n        processed using the powerfull features of the spreadsheet\n        processor - creating diagrams, complex calculations and so\n        on, and if necessary - transferred back to the z/OS and\n        loading to the same or another ISPF table.\n\n        Maintain ISPF table source. With CSV2ISP procedure ISPF\n        table data can be maintaned as a text file. This procedure\n        can be defined as SCLM CSV language translator to\n        maintenance table data under SCLM (see below for details)\n        and maintained automatically as integral part of other\n        source code.\n\n\nSyntax:\n\n     CSV2ISP CSV_specification table_specification >fs >fd!!\n\ntable_specification\n\n    Refers to ISPF table. The one of the following should be\n    specified:\n\n        library(member)\n        DDname=ddname(member)\n\n    Only partitioned data set (PDS, PDSE) allowed. If reference to\n    DD name specified, this DD should be provided. The data set must\n    exist, an ISPF table may exist. If table exists, it would be\n    replaced with new data. If reference to DD name specified in\n    form DDname=ddname, appropriate DD name cannot define a member\n    of the partitioned data set, reference in form\n    DDname=ddname(member) should be used instead.\n\nCSV_specification\n    Refers to CSV file. The one of the following should be specified:\n\n        dataset\n        library(member)\n        DDname=ddname\n        DDname=ddname(member)\n\n    Either member of the partitioned data set (PDS, PDSE) or\n    sequential data set (PS) can be specified. If reference to DD\n    name specified, this DD must be preallocated. Data set must be\n    preallocated anyway. Member, if specified, will be replaced if\n    it already exists or added otherwise. If reference to DD name\n    specified in form DDname=ddname, appropriate DD name cannot\n    define a member of the partitioned data set, reference in form\n    DDname=ddname(member) should be used instead.\n\nfs\n\n    field separator. Either one character or two hexadecimal digits.\n    Optional, comma by default.\n\nfd\n    field delimiter. Either one character or two hexadecimal digits.\n    Optional, double quote by default.\n\n\nUsage notes:\n\n        All parameters are positional\n\n        The first line of the CSV input file considered as a header.\n        Header should contains field names, separated by field\n        separator (comma by default). Field name should not started\n        with two underscope character (__). Key fields should be in\n        uppercase, other fields should be in lowercase or mixed case\n        letters. All fields are separated by field separator, all\n        non-numeric field may be enclosed in field delimiters\n        (double quote), but this is not necessary. If field\n        separator should be treated as a part of the field value,\n        this field must be enclosed in the field delimiters (eg.\n        \"1,2\",3,\"4,5\"). If field delimited should be treated as a\n        part of the value, it should be doubled (eg. \"don\"\"t\").\n        Thus, most of the the CSV files produced by MS Excel as well\n        as Lotus-123 should be eligible for loading without any\n        changes.\n\n        Procedure does not kept incomplete table if load fails due\n        to any reason.\n\n        Parameters in form library(member) may be useful for\n        interactive ISPF session, for a batch job form reference to\n        DD name may be more convenient.\n\n  ISPF environment required to run this procedure in batch job\n  (use ISPF or ISPSTART). See job example below:\n\n\n  //ISPF     EXEC PGM=IKJEFT01,REGION=0K\n  //SYSTSPRT DD  SYSOUT=*\n  //SYSPROC  DD  DISP=SHR,DSN=CENTER.CLIST\n  //SYSEXEC  DD  DISP=SHR,DSN=ISP.SISPEXEC\n  //ISPPLIB  DD  DISP=SHR,DSN=ISP.SISPPENU\n  ...  other ISPF libraries\n  //SYSTSIN  DD  *\n   ISPF CMD(%CSV2ISP DD=TBL(TEST) DD=CSV)\n  //CSV      DD  DISP=SHR,DISP=&SYSUID.CSV.DATA\n  //TBL      DD  DISP=SHR,DSN=&SYSUID.ISPF.TABLES\n\n  JCL procedure CSV2ISP provided to simplify use of CSV2ISP in batch.\n\n\n  //CSV2ISP  PROC LIB=,     -- Table Library, mandatory\n  //          CSV=,     -- CSV Data Set, mandatory\n  //          TABLE=    -- Table Name, mandatory\n  //          FS='',    -- Field Separator, optional, ',' by default\n  //          FD='',    -- Field Delimiter, optional, '\"' by default\n  //          SELF=CENTER.CLIST, -- Library where ISPTCSV resides\n  //          ISPFHLQ=ISP -- ISPF data set prefix, usually ISP or SYS1\n\n  Thus, with procedure above job to load table from CSV look as follows:\n\n\n  //SYSPRG1A JOB  MSGCLASS=H\n  //PROC     JCLLIB ORDER=(CENTER.PROCLIB)\n  //         EXEC CSV2ISP,\n  //            TABLE=TEST,\n  //            LIB=&SYSUID.ISPF.TABLES,\n  //            CSV=&SYSUID.CSV.DATA\n  //\n\n\nSCLM usage notes:\n\n    This procedure may be used as SCLM language traslator to allow\n    ISPF table maintenance. Source file would be CSV, target - ISPF\n    table. Example of the CSV language definition follows:\n\n\n      FLMLANGL LANG=CSV,VERSION=V1.0\n      FLMTRNSL CALLNAM='CSV2ISP',                                    +\n             FUNCTN=BUILD,                                           +\n             COMPILE=SELECT,                                         +\n             GOODRC=0,                                               +\n             PORDER=1,                                               +\n             CALLMETH=ISPLNK,                                        +\n             OPTIONS='CMD(%CSV2ISP DDNAME=SOURCE(@@FLMMBR) DDNAME=TAR+\n             GET(@@FLMMBR))'\n    *  INPUT CSV DATA\n       FLMALLOC IOTYPE=A,DDNAME=SOURCE\n       FLMCPYLB @@FLMPRJ.@@FLMGRP.@@FLMTYP\n    *  OUTPUT TABLE LIBRARY\n       FLMALLOC IOTYPE=P,KEYREF=OUT1,RECFM=FB,LRECL=80,              +\n             RECNUM=5000,PRINT=Y,DFLTTYP=ISPTLIB,DDNAME=TARGET\n\n    Example of the ARCHDEF member referred to this language definition\n\n\n    SINC   EXAMPLE  CSV\n    OUT1   EXAMPLE  ISPTLIB\n\n    With this CSV language definition ISPTLIB members (eg. ISPF\n    tables) becomes non-editable, they are automatically created\n    from an appropriate CSV file by the SCLM build.\n\nHistory:\n    Written by Gregori Bliznets at 2005, last changed 09.2012\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CSV2ISPJ": {"ttr": 778, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00@\\x01\\x16\\x08\\x1f\\x01\\x16\\x08\\x1f\\x175\\x00\\x12\\x00\\x12\\x00\\x00\\xd1\\xd6\\xc2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-03-21T00:00:00", "modifydate": "2016-03-21T17:35:40", "lines": 18, "newlines": 18, "modlines": 0, "user": "JOB"}, "text": "//IBMUSERA JOB  MSGCLASS=H\n//PROC     JCLLIB ORDER=(CPAC.PROCLIB)\n//COPY     EXEC PGM=IEBGENER\n//SYSPRINT DD  DUMMY\n//SYSIN    DD  DUMMY\n//SYSUT1   DD  *\nKEY,data,comment\n1,\"A\",\"test\"\n2,\"B\",\n3,\"C\",\"just a test\"\n4,,\"another test\"\n//SYSUT2   DD  DISP=(NEW,PASS),DSN=&&CSV,\n//             UNIT=VIO,SPACE=(TRK,(1,1)),\n//             DCB=(LRECL=80,BLKSIZE=0,RECFM=FB)\n//         EXEC CSV2ISP,TABLE=TEST\n//ISPTCSV.CSV DD DISP=(OLD,DELETE),DSN=&&CSV\n//ISPTCSV.TBL DD DISP=SHR,DSN=CPAC.ISPTLIB\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CSV2ISPP": {"ttr": 780, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00@\\x01\\x16\\x08\\x1f\\x01\\x16\\x08\\x1f\\x175\\x00\\x1e\\x00\\x1e\\x00\\x00\\xd7\\xd9\\xd6\\xc3@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-03-21T00:00:00", "modifydate": "2016-03-21T17:35:40", "lines": 30, "newlines": 30, "modlines": 0, "user": "PROC"}, "text": "//CSV2ISP PROC LIB=,     -- Table Library, mandatory\n//             TABLE=,   -- Table name, mandatory\n//             CSV=,     -- CSV Data Set, mandatory\n//             FS='',    -- Field Separator, optional, ',' by default\n//             FD='',    -- Field Delimiter, optional, '\"' by default\n//             SELF=CPAC.CMDPROC, -- Library where ISPTCVS resides\n//             ISPFHLQ=ISP -- ISPF data set prefix, usually ISP or SYS1\n//ISPPROF  EXEC PGM=IEBCOPY\n//SYSPRINT DD  DUMMY\n//SYSIN    DD  DUMMY\n//SYSUT1   DD  DISP=SHR,DSN=&SYSUID..ISPF.ISPPROF\n//SYSUT2   DD  DISP=(NEW,PASS),DSN=&&PROF,\n//             UNIT=VIO,SPACE=(TRK,(1,1,5)),\n//             DCB=(LRECL=80,BLKSIZE=0,RECFM=FB)\n//ISPTCSV  EXEC PGM=IKJEFT01,REGION=0K,\n// PARM='ISPF CMD(%CSV2ISP DD=CSV DD=TBL(&TABLE) &FS &FD)'\n//SYSTSPRT DD  SYSOUT=*\n//SYSPROC  DD  DISP=SHR,DSN=&SELF\n//SYSEXEC  DD  DISP=SHR,DSN=&ISPFHLQ..SISPEXEC\n//ISPPLIB  DD  DISP=SHR,DSN=&ISPFHLQ..SISPPENU\n//ISPSLIB  DD  DISP=SHR,DSN=&ISPFHLQ..SISPSENU\n//ISPMLIB  DD  DISP=SHR,DSN=&ISPFHLQ..SISPMENU\n//ISPTLIB  DD  DISP=SHR,DSN=&ISPFHLQ..SISPTENU\n//ISPPROF  DD  DISP=(OLD,DELETE),DSN=&&PROF\n//ISPLOG   DD  SYSOUT=*,\n//             DCB=(LRECL=120,BLKSIZE=2400,DSORG=PS,RECFM=FB)\n//ISPLIST  DD  SYSOUT=*,DCB=(LRECL=121,BLKSIZE=1210,RECFM=FBA)\n//CSV      DD  DISP=SHR,DSN=&CSV\n//TBL      DD  DISP=SHR,DSN=&LIB\n//SYSTSIN  DD  DUMMY\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DDL": {"ttr": 782, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00@\\x01\\x16\\x08\\x1f\\x01\\x16\\x11\\x9f\\x10\\x01\\x02\\x91\\x01\\x8f\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2016-03-21T00:00:00", "modifydate": "2016-04-28T10:01:40", "lines": 657, "newlines": 399, "modlines": 0, "user": "REXX"}, "text": "/* REXX/370 */\n/*\n\nFunction:\n       Builds a job to allocate data set(s) and VSAM objects definitions\n       for an exising data sets and objects.\n       This allocation job is useful to reallocate data set on the\n       target system when those transferred via ftp.\n\nSyntax:\n       DDL hlq \u00a2DCB(YES\u00a6NO)! \u00a2SMS(YES\u00a6NO\u00a6ONLY)! \u00a2AMS(ALL\u00a6VSAM)!\n\n(C) 2006-2015 Gregori Bliznets gbliznets@iba.by\n\n*/\ntrace off\naddress ISPEXEC\n'VGET (ZUSER ZENVIR ZAPPLID ZGUI ZTEMPF ZTEMPN BJC1 BJC2 BJC3 BJC4)'\nparse var zenvir 17 runmode 25\nif zgui <> ''\nthen runmode = zgui\nkeys = 'DCB SMS AMS'\ndo i = 1 to words(keys)\n  call value word(keys,i), ''\nend i\nparse upper arg hlq parms\ndo while parms <> ''\n  parse var parms parm parms\n  parse var parm key '(' val ')'\n  found = 0\n  do i = 1 to words(keys) while found = 0\n    if abbrev(key, word(keys,i))\n    then found = i\n  end i\n  if found = 0\n  then do\n    say '002T Invalid parameter: 'parm\n    rc = 16\n    signal quit\n    end\n  call value word(keys,found), val\nend\n\nif left(hlq,1) = \"'\" & right(hlq,1) = \"'\"\nthen hlq = substr(hlq,2,length(hlq)-2)\nif hlq = ''\nthen do\n  say '002T HLQ is missed'\n  rc = 16\n  signal quit\n  end\nif dcb = ''\nthen dcb = 'YES'\nif wordpos(dcb, 'YES NO') = 0\nthen do\n  say '002T Invalid parameter: DCB('dcb')'\n  rc = 16\n  signal quit\n  end\nif sms = ''\nthen sms = 'YES'\nif wordpos(sms, 'YES NO ONLY') = 0\nthen do\n  say '002T Invalid parameter: SMS('sms')'\n  rc = 16\n  signal quit\n  end\nif ams = ''\nthen ams = 'ALL'\nif wordpos(ams, 'ALL VSAM') = 0\nthen do\n  say '002T Invalid parameter: AMS('ams')'\n  rc = 16\n  signal quit\n  end\n\n/* Device constants: z/OS supports 3380, 3390, 9345 only */\ndevtypes.1  = '3390 0F 15 56664'\ndevtypes.2  = '3380 0E 15 47476'\ndevtypes.3  = '3330 0D 19 13030' /* 3330-11, 3333-11 */\ndevtypes.4  = '3375 0C 12 35616'\ndevtypes.5  = '3350 0B 30 19069'\ndevtypes.6  = '3340 0A 12  8368'\ndevtypes.7  = '3330 09 19 13030' /* 3390-1, 3390-2, 3333 */\ndevtypes.8  = '2314 08 20  7294'\ndevtypes.9  = '2305 07  8 14136' /* 2305-2 */\ndevtypes.10 = '2305 06  8 14136' /* 2305-1 */\ndevtypes.11 = '2301 05  8 14136'\ndevtypes.12 = '9345 04 15 46456'\ndevtypes.13 = '2311 01 10  3625'\ndevtypes.0 = 13\n\n/* Check if output DD present */\nif runmode = 'BATCH'\nthen do\n  ddname = 'DDL'\n  found = 0\n  numeric digits 20\n  CVT = '10'\n  TCB = c2d(storage(c2x(storage(c2x(storage(CVT,4)),4)),4))\n  TIOT = c2d(storage(d2x(TCB+12),4))\n  TIOTPTR = TIOT+24\n  TIOELNGH = c2d(storage(d2x(TIOTPTR),1))\n  do until TIOELNGH = 0\n    TIOEDDNM = strip(storage(d2x(TIOTPTR+4),8))\n    if substr(TIOEDDNM,1,1) <> '00'x & TIOEDDNM <> '' & TIOEDDNM = ddname\n    then found = 1\n    TIOTPTR = TIOTPTR + TIOELNGH\n    TIOELNGH = c2d(storage(d2x(TIOTPTR),1))\n  end\n  if found = 0\n  then ddname = ztempn\n  end\nelse ddname = ztempn\n'LMDINIT LISTID(listid) LEVEL('hlq')'\nif rc <> 0\nthen do\n  say '003T LMDINIT failed, return code 'rc\n  rc = 16\n  signal quit\n  end\ndsn = ''\ntotal = 0\njcl.0 = 2\ndo i = 1 to jcl.0\n  jcl.i.0 = 0\nend i\ndo i = 1 to 4\n  if value('BJC'i) <> ''\n  then rc = jcl(value('BJC'i))\nend i\nrc = jcl('//         EXEC PGM=IDCAMS,DYNAMNBR=1000')\nrc = jcl('//SYSPRINT DD SYSOUT=*')\ndo n = 1\n  tracks = 0\n  zdsdevt = '3390'\n  'LMDLIST LISTID('listid') DATASET(DSN) STATS(YES)'\n  if rc <> 0\n  then leave n\n  \"DSINFO DATASET('\"dsn\"')\"\n  call outtrap 'AMS.'\n  address TSO \"LISTCAT ENTRIES('\"dsn\"') ALL\"\n  call outtrap 'OFF'\n  parse var ams.1 w1 w2 .\n  if rc <> 0\n  then do\n    say '004W Unknown object 'dsn\n    iterate n\n    end\n\n  if zdsorg = 'VS' & hlq = dsn & (w1 = 'INDEX' | w1 = 'DATA')\n  then do /* VSAM component specified, handle associated cluster */\n    rc = jcl('  /* WARNING: 'w1' COMPONENT SPECIFIED, HANDLE CLUSTER */')\n    do i = 1 to ams.0\n      parse var ams.i w1 w2 w3 w4 w5 w6 w7 w8 .\n      if w1 = 'ASSOCIATIONS'\n      then leave i\n    end i\n    i = i+1\n    if i > ams.0\n    then do\n      say '004W Unknown object 'dsn\n      iterate n\n      end\n    parse var ams.i w1 w2 w3 w4 w5 w6 w7 w8 .\n    if left(w1,9) = 'CLUSTER--'\n    then dsn = substr(w1,10)\n    else do\n      say '004W Unknown object 'dsn\n      iterate n\n      end\n    drop ams.\n    call outtrap 'AMS.'\n    address TSO \"LISTCAT ENTRIES('\"dsn\"') ALL\"\n    call outtrap 'OFF'\n    parse var ams.1 w1 w2 .\n    if rc <> 0\n    then do\n      say '004W Unknown object 'dsn\n      iterate n\n      end\n    end\n\n  select\n  when w1' 'w2 = 'GDG BASE'\n  then do\n    parse var ams.7 w1 w2 w3 .\n    limit = word(translate(w1,' ','-'),2)\n    rc = jcl('  DEFINE -')\n    rc = jcl('   GENERATIONDATAGROUP -')\n    rc = jcl('    NAME('dsn') -')\n    rc = jcl('    LIMIT('limit') -')\n    rc = jcl('    'w2' -')\n    rc = jcl('    'w3' -')\n    rc = jcl('    ) ')\n    end\n  when w1 = 'ALIAS'\n  then do\n    parse var ams.6 w1 w2 w3 .\n    relate = word(translate(w1,' ','-'),2)\n    rc = jcl('  DEFINE -')\n    rc = jcl('   ALIAS -')\n    rc = jcl('    NAME('dsn') -')\n    rc = jcl('    RELATE('relate') -')\n    rc = jcl('    ) ')\n    end\n  when zdsorg = 'VS'\n  then do /* VSAM */\n    select\n    when w1 = 'CLUSTER'\n    then object = w1\n    when w1 = 'INDEX'\n    then iterate n\n    when w1 = 'DATA'\n    then iterate n\n    when w1 = 'AIX'\n    then object = w1\n    when w1 = 'PATH'\n    then object = w1\n    when w1 = 'PAGESPACE'\n    then object = w1\n    otherwise nop\n    end\n    dname = ''\n    iname = ''\n    dtracks = 0\n    itracks = 0\n    dunit = ''\n    iunit = ''\n    quote = \"'\"\n    storclas = ''\n    mgmtclas = ''\n    dataclas = ''\n    do i = 1 to ams.0\n      parse var ams.i w1 w2 w3 w4 w5 w6 w7 w8 .\n      select\n      when w1 = 'DATA' & w2 = '-------'\n      then dname = w3\n      when w1 = 'INDEX' & w2 = '------'\n      then iname = w3\n      when left(w1,8) = 'KEYLEN--' & iname = ''\n      then do\n        keylen = word(translate(w1,' ','-'),2)\n        avglrecl = word(translate(w2,' ','-'),2)\n        end\n      when left(w1,5) = 'RKP--' & iname = ''\n      then do\n        rkp = word(translate(w1,' ','-'),2)\n        maxlrecl = word(translate(w2,' ','-'),2)\n        end\n      when left(w1,8) = 'SHROPTNS' & iname = ''\n      then do\n        parse var w1 . '(' shropt ')' .\n        amorg = w5 /* INDEXED NONINDEXED NUMBERED LINEAR */\n        k = i+1\n        parse var ams.k w10 w11 .\n        if object = 'CLUSTER'\n        then amattr = w4 w6 w8 w10 /* \u00a2NO!ERASE \u00a2NO!WRITECHK \u00a2NO!REUSE */\n        if object = 'AIX'\n        then amattr = w4 w6 w8 w11 /* \u00a2NO!ERASE \u00a2NO!WRITECHK \u00a2NON!UNIQKEY */\n        if object = 'PAGESPACE'\n        then amattr = ''\n        end\n      when w1 = 'STORAGECLASS '\n      then do\n        storclas = strip(translate(w2,' ','-'))\n        mgmtclas = word(translate(w3,' ','-'),2)\n        end\n      when w1 = 'DATACLASS '\n      then do\n        dataclas = strip(translate(w2,' ','-'))\n        end\n      when left(w1,12) = 'SPACE-TYPE--'\n      then do\n        if iname <> ''\n        then isptype = word(translate(w1,' ','-'),3)\n        else dsptype = word(translate(w1,' ','-'),3)\n        end\n      when left(w1,11) = 'SPACE-PRI--'\n      then do\n        if iname <> ''\n        then isppri = word(translate(w1,' ','-'),3)\n        else dsppri = word(translate(w1,' ','-'),3)\n        end\n      when left(w1,11) = 'SPACE-SEC--'\n      then do\n        if iname <> ''\n        then ispsec = word(translate(w1,' ','-'),3)\n        else dspsec = word(translate(w1,' ','-'),3)\n        end\n      when left(w1,13) = 'LOW-CCHH-----'\n      then do\n        parse var ams.i . (quote) +1 lowcc +4 lowhh (quote) .\n        k = i+1\n        parse var ams.k . (quote) +1 highcc +4 highhh (quote) .\n        tracks = (x2d(highcc)-x2d(lowcc))*trkpercyl+(x2d(highhh)-x2d(lowhh))+1\n        if iname <> ''\n        then itracks = itracks+tracks\n        else dtracks = dtracks+tracks\n        end\n      when left(w1,18) = 'VOLSER------------'\n      then do\n        if iname <> ''\n        then ivolser = word(translate(w1,' ','-'),2)\n        else dvolser = word(translate(w1,' ','-'),2)\n        end\n      when left(w1,13) = 'DEVTYPE------'\n      then do\n        parse var ams.i . (quote) +1 ucbtyp (quote) .\n        parse var ucbtyp ucbtbyt1 +1 ucbtbyt2 +1 ucbtbyt3 +1 ucbtbyt4 +1\n        found = 0\n        do k = 1 to devtypes.0\n          parse var devtypes.k name type trkpercyl bytepertrk\n          if '20'type == ucbtbyt3''ucbtbyt4\n          then do\n            found = 1\n            leave k\n            end\n        end k\n        if found = 0 /* assume 3390 when not found */\n        then parse var devtypes.1 name type trkpercyl bytepertrk\n        if iname <> ''\n        then iunit = name\n        else dunit = name\n        end\n      when left(w1,13) = 'REC-INSERTED-'\n      then freeci = word(translate(w2,' ','-'),3)\n      when left(w1,13) = 'REC-UPDATED--'\n      then freeca = word(translate(w2,' ','-'),3)\n      when left(w1,13) = 'RELEASE------'\n      then expire = substr(w2,17,4) || substr(w2,22,3)\n      when object = 'AIX' & left(w1,9) = 'CLUSTER--'\n      then relate = word(translate(w1,' ','-'),2)\n      when object = 'AIX' & left(w1,7) = 'UPGRADE'\n      then upgrade = w1\n      when object = 'AIX' & left(w1,7) = 'NOUPGRADE'\n      then upgrade = w1\n      when object = 'AIX' & left(w1,7) = 'AXRKP--'\n      then axrkp = word(translate(w1,' ','-'),2)\n      when object = 'PATH' & left(w1,9) = 'AIX------'\n      then pathentry = word(translate(w1,' ','-'),2)\n      when object = 'PATH' & left(w1,9) = 'CLUSTER--'\n      then pathentry = word(translate(w1,' ','-'),2)\n      when object = 'PATH' & left(w1,7) = 'UPDATE'\n      then update = w1\n      when object = 'PATH' & left(w1,7) = 'NOUPDATE'\n      then update = w1\n      otherwise nop\n      end\n    end i\n    tracks = itracks+dtracks\n    select\n    when object = 'PATH'\n    then do\n      rc = jcl('  DEFINE -')\n      rc = jcl('   PATH( -')\n      rc = jcl('    NAME('dsn') -')\n      rc = jcl('    PATHENTRY('pathentry') -')\n      rc = jcl('    'update' -')\n      rc = jcl('    ) ')\n      end\n    when object = 'AIX'\n    then do\n      rc = jcl('  DEFINE -')\n      rc = jcl('   AIX( -')\n      rc = jcl('    NAME('dsn') -')\n      rc = jcl('    RELATE('relate') -')\n      rc = jcl('    'upgrade' -')\n      do while amattr <> ''\n        parse var amattr w1 amattr\n        p = wordpos(w1, 'NOWRITECHK WRITECHK NONUNIQKEY UNIQKEY')\n        if p > 0\n        then w1 = word('NOWRITECHECK WRITECHECK NONUNIQUEKEY UNIQUEKEY', p)\n        rc = jcl('    'w1' -')\n      end\n      rc = jcl('    KEYS('keylen' 'axrkp') -')\n      rc = jcl('    RECORDSIZE('avglrecl' 'maxlrecl') -')\n      if freeci+freeca <> 0\n      then rc = jcl('    FREESPACE('freeci' 'freeca') -')\n      rc = jcl('    SHAREOPTIONS('shropt') -')\n      rc = jcl('    ) -')\n      rc = jcl('   DATA ( -')\n      rc = jcl('    NAME('dname') -')\n      rc = jcl('    'dsptype'('dsppri' 'dspsec') -')\n      rc = jcl('    ) -')\n      rc = jcl('   INDEX ( -')\n      rc = jcl('    NAME('iname') -')\n      rc = jcl('    'isptype'('isppri' 'ispsec') -')\n      rc = jcl('    ) ')\n      end\n    when object = 'CLUSTER'\n    then do\n      rc = jcl('  DEFINE -')\n      rc = jcl('   CLUSTER( -')\n      rc = jcl('    NAME('dsn') -')\n      rc = jcl('    'amorg' -')\n      do while amattr <> ''\n        parse var amattr w1 amattr\n        p = wordpos(w1, 'NOWRITECHK WRITECHK NONUNIQKEY UNIQKEY')\n        if p > 0\n        then w1 = word('NOWRITECHECK WRITECHECK NONUNIQUEKEY UNIQUEKEY', p)\n        rc = jcl('    'w1' -')\n      end\n      if expire <> '0000000'\n      then rc = jcl('    TO('expire') -')\n      if amorg = 'INDEXED'\n      then rc = jcl('    KEYS('keylen' 'rkp') -')\n      if amorg <> 'LINEAR'\n      then rc = jcl('    RECORDSIZE('avglrecl' 'maxlrecl') -')\n      if freeci+freeca <> 0\n      then rc = jcl('    FREESPACE('freeci' 'freeca') -')\n      if sms <> 'NO'\n      then do\n        if storclas <> '(NULL)' & storclass <> ''\n        then rc = jcl('    STORAGECLASS('storclas') -')\n        if mgmtclas <> '(NULL)' & mgmtclass <> ''\n        then rc = jcl('    MANAGEMENTCLASS('mgmtclas') -')\n        if dataclas <> '(NULL)' & dataclass <> ''\n        then rc = jcl('    DATACLASS('dataclas') -')\n        end\n      rc = jcl('    SHAREOPTIONS('shropt') -')\n      rc = jcl('    ) -')\n      rc = jcl('   DATA ( -')\n      rc = jcl('    NAME('dname') -')\n      rc = jcl('    'dsptype'S('dsppri' 'dspsec') -')\n      if sms <> 'ONLY'\n      then rc = jcl('    VOLUMES('strip(dvolser)') -')\n      if amorg = 'INDEXED'\n      then do\n        rc = jcl('    ) -')\n        rc = jcl('   INDEX ( -')\n        rc = jcl('    NAME('iname') -')\n        rc = jcl('    'isptype'S('isppri' 'ispsec') -')\n        if sms <> 'ONLY'\n        then rc = jcl('    VOLUMES('strip(ivolser)') -')\n        end\n      rc = jcl('    ) ')\n      end\n    when object = 'PAGESPACE'\n    then do\n      rc = jcl('  DEFINE -')\n      rc = jcl('   PAGESPACE( -')\n      rc = jcl('    NAME('dsn') -')\n      rc = jcl('    'dsptype'S('dsppri' 'dspsec') -')\n      if expire <> '0000000'\n      then rc = jcl('    TO('expire') -')\n      if sms <> 'NO'\n      then do\n        if storclas <> '(NULL)' & storclas <> ''\n        then rc = jcl('    STORAGECLASS('storclas') -')\n        if mgmtclas <> '(NULL)' & mgmtclas <> ''\n        then rc = jcl('    MANAGEMENTCLASS('mgmtclas') -')\n        if dataclas <> '(NULL)' & dataclas <> ''\n        then rc = jcl('    DATACLASS('dataclas') -')\n        end\n      else rc = jcl('    VOLUME('strip(dvolser)') -')\n      rc = jcl('    ) ')\n      end\n    end\n    end\n  otherwise /* NONVSAM */\n    space = space(translate(zdstota,' ',','),0)\n    found = 0\n    do k = 1 to devtypes.0\n      parse var devtypes.k name type trkpercyl bytepertrk\n      if zdsdevt = name\n      then do\n        found = 1\n        leave k\n        end\n    end k\n    if found = 0 /* assume 3390 is not found */\n    then parse var devtypes.1 name type trkpercyl bytepertrk\n    if ams = 'ALL'\n    then do\n      rc = jcl('  ALLOCATE -')\n      rc = jcl(\"   DSNAME('\"dsn\"') -\")\n      end\n    else do\n      rc = jcl('//DD'right(n,6,'0')' DD DSN='dsn',')\n      rc = jcl('//            DISP=(NEW,CATLG),')\n      end\n    expdt = ''\n    if zdsxdate <> '***None***'\n    then do\n      parse var zdsxdate yyyy '/' mm '/' dd\n      expdt = yyyy''right(date('D',yyyy''mm''dd,'S'),3,'0')\n      end\n    /* Calculate request in tracks */\n    select\n    when zdsspc = 'CYLINDER'\n    then tracks = space*trkpercyl\n    when zdsspc = 'TRACK'\n    then tracks = space\n    when zdsspc = 'BLOCK'\n    then tracks = format(zdsblk*space/bytepertrk,,0)\n    when zdsspc = 'BYTE'\n    then tracks = format(space/bytepertrk,,0)\n    end\n    if ams = 'ALL'\n    then do\n      select\n      when zdsspc = 'CYLINDER'\n      then rc = jcl('   CYLINDERS -')\n      when zdsspc = 'TRACK'\n      then rc = jcl('   TRACKS -')\n      when zdsspc = 'BLOCK'\n      then rc = jcl('   BLOCK('strip(zdsblk)') -')\n      when zdsspc = 'BYTE'\n      then rc = jcl('   TRACKS -')\n      end\n      dsppri = strip(zds1ex)\n      dspsec = strip(zds2ex)\n      if zdsspc = 'BYTE'\n      then do\n        dsppri = format(dsppri/bytepertrk,,0)\n        dspsec = format(dspsec/bytepertrk,,0)\n        end\n      rc = jcl('   SPACE('dsppri' 'dspsec') -')\n      if zdsorg = 'PO'\n      then rc = jcl('   DIR('strip(zdsdira)') -')\n      if zdsdsnt = 'HFS' | zdsdsnt = 'LIBRARY'\n      then rc = jcl('   DSNTYPE('strip(zdsdsnt)') -')\n      if expdt <> ''\n      then rc = jcl('   EXPDT('expdt') -')\n      end\n    else do\n      select\n      when zdsspc = 'CYLINDER'\n      then space = 'CYL'\n      when zdsspc = 'TRACK'\n      then space = 'TRK'\n      when zdsspc = 'BLOCK'\n      then space = strip(zdsblk)\n      when zdsspc = 'BYTE'\n      then space = 'TRK'\n      end\n      dsppri = strip(zds1ex)\n      dspsec = strip(zds2ex)\n      if zdsspc = 'BYTE'\n      then do\n        dsppri = format(dsppri/bytepertrk,,0)\n        dspsec = format(dspsec/bytepertrk,,0)\n        end\n      space = space',('dsppri','dspsec')'\n      if zdsorg = 'PO'\n      then space = space','strip(zdsdira)')'\n      else space = space')'\n      rc = jcl('//            SPACE=('space'),')\n      if zdsdsnt = 'HFS' | zdsdsnt = 'LIBRARY'\n      then rc = jcl('//            DSNTYPE='strip(zdsdsnt)',')\n      if expdt <> ''\n      then rc = jcl('//            DCB=EXPDT='expdt',')\n      end\n    if dcb = 'YES'\n    then do\n      recfm = ''\n      do i = 1 to length(zdlrecfm)\n        recfm=recfm' 'substr(zdlrecfm,i,1)\n      end i\n      if ams = 'ALL'\n      then do\n        rc = jcl('   DSORG('strip(zdsorg)') -')\n        rc = jcl('   RECFM('strip(recfm)') -')\n        rc = jcl('   LRECL('strip(zdslrec)') -')\n        rc = jcl('   BLKSIZE('strip(zdsblk)') -')\n        end\n      else do\n        rc = jcl('//            DSORG='strip(zdsorg)',')\n        rc = jcl('//            RECFM='strip(zdlrecfm)',')\n        rc = jcl('//            LRECL='strip(zdslrec)',')\n        rc = jcl('//            BLKSIZE='strip(zdsblk)',')\n        end\n      end\n    if sms <> 'NO'\n    then do\n      smsattr = ''\n      if ams = 'ALL'\n      then do\n        if zdsmc <> '**None**'\n        then smsattr = smsattr' MANAGEMENTCLASS('strip(zdsmc)')'\n        if zdssc <> '**None**'\n        then smsattr = smsattr' STORAGECLASS('strip(zdssc)')'\n        if zdsdc <> '**None**'\n        then smsattr = smsattr' DATACLASS('strip(zdsdc)')'\n        do k = 1 to words(smsattr)\n          c = ''\n          if k < words(smsattr)\n          then c = '-'\n          rc = jcl('   'word(smsattr,k)' 'c)\n        end k\n        end\n      else do\n        if zdsmc <> '**None**'\n        then smsattr = smsattr' MGMTCLAS='strip(zdsmc)\n        if zdssc <> '**None**'\n        then smsattr = smsattr' STORCLAS='strip(zdssc)\n        if zdsdc <> '**None**'\n        then smsattr = smsattr' DATACLAS='strip(zdsdc)\n        do k = 1 to words(smsattr)\n          c = ''\n          if k < words(smsattr)\n          then c = ','\n          rc = jcl('//            'word(smsattr,k)''c)\n        end k\n        end\n      end\n    if sms <> 'ONLY'\n    then do\n      if ams = 'ALL'\n      then rc = jcl('   UNIT('strip(zdsdevt)') -')\n      else rc = jcl('//            UNIT='strip(zdsdevt)',')\n      if zds#vols = 1\n      then volser = strip(zdsvol)\n      else volser = strip(zdsvtab)\n      if ams = 'ALL'\n      then rc = jcl('   VOLUME('volser') ')\n      else rc = jcl('//            VOL=SER='volser' ')\n      end\n  end\n  if zdsapf = 'YES'\n  then do\n    if ams = 'ALL'\n    then rc = jcl('  /* APF-authorized data set */')\n    else rc = jcl('//* APF-authorized data set ***')\n    end\n  /* Allocation summary */\n  if ams = 'ALL'\n  then rc = jcl('  /* 'tracks' 'strip(zdsdevt)' TRACK(S) ALLOCATED */')\n  else rc = jcl('//* 'tracks' 'strip(zdsdevt)' TRACK(S) ALLOCATED ***')\n  if datatype(tracks,'W')\n  then total = total + tracks\nend n\nrc = jcl('//SYSIN    DD *')\nrc = jcl('  /* TOTAL 'total' 'strip(zdsdevt)' TRACK(S) ALLOCATED */')\nrc = jcl('//')\ndo i = 1 to jcl.0\n  address TSO 'EXECIO 'jcl.i.0' DISKW 'ddname' (STEM JCL.'i'.'\nend i\naddress TSO 'EXECIO 0 DISKW 'ddname' (FINIS'\n'LMDFREE LISTID('listid')'\nif runmode <> 'BATCH'\nthen \"EDIT DATASET('\"ztempf\"')\"\nrc = 0\n\nquit:\n  zispfrc = rc\n  address ISPEXEC 'VPUT ZISPFRC'\n  exit rc\n\njcl: procedure expose jcl.\n  parse arg c\n  i = 2 - ((left(c,2)='//') & (c<>'//'))\n  j = jcl.i.0+1\n  jcl.i.j = c\n  jcl.i.0 = j\n  return 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DDL#": {"ttr": 1281, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00Q\\x01\\x16\\x08\\x1f\\x01\\x16\\x10/\\x15\\x10\\x01\\x9b\\x00j\\x00\\x00\\xc8\\xc5\\xd3\\xd7@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2016-03-21T00:00:00", "modifydate": "2016-04-11T15:10:51", "lines": 411, "newlines": 106, "modlines": 0, "user": "HELP"}, "text": "Function:\n\n\nThis REXX exec generates definition - IDCAMS DEFINE, ALLOCATE as well as\nJCL DD  statements - for an existing data set, GDG base and VSAM\nobject.  The generated definition may be used to easily re-create\nobjects on the same or another z/OS system, that's may be especially\nuseful to reallocate data set on the target system when those are\ntransferred via ftp.\n\nI hope, this procedure will supersede CBT tape File 920 by John McKown: it\nis able to generate declaration of all kind of VSAM data sets as well as\nany RFS object - non-VSAM dataset, AIX, path, GDG base, alias.\n\n\nSyntax:\n\n\n    DDL   hlq  \u00ddDCB(YES\u00a6NO)\u00a8  \u00ddSMS(YES\u00a6NO\u00a6ONLY)\u00a8  \u00ddAMS(ALL\u00a6VSAM)\u00a8\n\n\n    hlq     specifies the high-level qualifier(s) being processed.\n            May be also a fully-qualified data set.\n\n    DCB     YES   causes generation of all DCB attribites (RECFM,\n                  LRECL, BLKSIZE);\n            NO    suppresses generation of all DCB attribites.\n\n    SMS     YES   causes generation of all SMS-related allocation\n                  parameters (DATACLAS, MGMTCLAS etc) as well as\n                  old-fashioned allocation parameters (VOLUME, UNIT)\n            ONLY  causes generation of all SMS-related allocation\n                  parameters (DATACLAS, MGMTCLAS etc) only\n            NO    causes generation of old-fashion allocation\n                  parameters (VOLUME, UNIT) only.\n\n    AMS     ALL   generates AMS statements for object definition,\n                  includung ALLOCATE;\n            VSAM  generates AMS statements for VSAM and GDG and DD\n                  statements for non-VSAM allocations.\n\n\nUsage:\n\n\n    This procedure can be invoked via JCL or interactively (ISPF 6\n    or as a ISPF 3.4 prefix command).  An example of JCL is supplied,\n    but needs to be changed according to data set naming conventions\n    on your z/OS system.  When DDL is invoked interactively, it writes\n    generated definitions to the temporary data set and then enters\n    ISPF EDIT, so those may be easily saved.  In batch mode DDL\n    writes generated output to DDL DD.\n\n\n\nExample of use DDL as 3.4 prefix command\n\n\n   Menu  Options  View  Utilities  Compilers  Help\n ------------------------------------------------------------------------------\n DSLIST - Data Sets Matching CPAC                                   Row 1 of 19\n\n Command - Enter \"/\" to select action                  Message           Volume\n -------------------------------------------------------------------------------\n          CPAC.CMDPROC                                                   Z13CAT\n          CPAC.DBRMLIB                                                   Z13CAT\n ddl      CPAC.DOCLIB                                                    Z13CAT\n          CPAC.FTPXLATE                                                  Z13CAT\n          CPAC.HFS                                                       Z13CAT\n          CPAC.ISPCLIB                                                   Z13CAT\n          CPAC.ISPMLIB                                                   Z13CAT\n          CPAC.ISPPLIB                                                   Z13CAT\n          CPAC.ISPSLIB                                                   Z13CAT\n          CPAC.ISPTLIB                                                   Z13CAT\n          CPAC.LINKLIB                                                   Z13CAT\n          CPAC.LOADLIB                                                   Z13CAT\n          CPAC.LPALIB                                                    Z13CAT\n          CPAC.PARMLIB                                                   Z13CAT\n          CPAC.PIPELIB                                                   Z13CAT\n Command ===>                                                  Scroll ===> PAGE\n  F1=Help    F2=Split   F3=Exit    F5=Rfind   F7=Up      F8=Down    F9=Swap\n F10=Left   F11=Right  F12=Cancel\n\n\n\nResult may be as follows:\n\n   File  Edit  Edit_Settings  Menu  Utilities  Compilers  Test  Help\n -------------------------------------------------------------------------------\n EDIT       IBMUSER.SPFTEMP1.CNTL                           Columns 00001 00072\n ****** ***************************** Top of Data ******************************\n ==MSG> -Warning- The UNDO command is not available until you change\n ==MSG>           your edit profile using the command RECOVERY ON.\n 000001 //IBMUSERB JOB MSGCLASS=H,NOTIFY=&SYSUID\n 000002 //         EXEC PGM=IDCAMS,DYNAMNBR=1000\n 000003 //SYSPRINT DD SYSOUT=*\n 000004 //SYSIN    DD *\n 000005 //\n 000006   ALLOCATE -\n 000007    DSNAME('CPAC.DOCLIB') -\n 000008    TRACKS -\n 000009    SPACE(80 42) -\n 000010    DIR(0) -\n 000011    DSNTYPE(LIBRARY) -\n 000012    DSORG(PO) -\n 000013    RECFM(F B) -\n 000014    LRECL(80) -\n 000015    BLKSIZE(32720) -\n Command ===>                                                  Scroll ===> CSR\n  F1=Help      F2=Split     F3=Exit      F5=Rfind     F6=Rchange   F7=Up\n  F8=Down      F9=Swap     F10=Left     F11=Right    F12=Cancel\n\n\n Please note - job card generated as defined on ISRJPA panel (ISPF =5):\n\n   Menu  Utilities  Help\n ------------------------------------------------------------------------------\n                             Batch Selection Panel\n\n 1  Assembler              7  *Binder/Link editor    15 *ADA/370\n 2  COBOL                  10 *VS COBOL II debug     16 *AD/Cycle C/370\n 3  VS FORTRAN             12  Member Parts List     18  ISPDTLC\n 5  PLI                    13 *C/370                 19 *OS/390 C/C++\n 6  VS PASCAL              14 *REXX/370\n\n     Enter \"/\" to select option          * No packed data support\n     /  Source data online\n        Source data packed\n\n Job Statement Information: Verify before proceeding\n\n ===> //IBMUSERB JOB MSGCLASS=H,NOTIFY=&SYSUID\n ===>\n ===>\n ===>\n\n Option ===>\n  F1=Help      F2=Split     F3=Exit      F7=Backward  F8=Forward   F9=Swap\n F10=Actions  F12=Cancel\n\n\n\n\nExample of batch DDL usage\n\n\n//IBMUSERA JOB MSGCLASS=H,NOTIFY=&SYSUID,REGION=0M\n//TSO     EXEC PGM=IKJEFT01,\n// PARM='ISPSTART CMD(%DDL CPAC.*)'\n//SYSPROC  DD DSN=CPAC.CMDPROC,DISP=SHR\n//ISPPLIB  DD DSN=ISP.SISPPENU,DISP=SHR\n//ISPSLIB  DD DSN=ISP.SISPSENU,DISP=SHR\n//ISPMLIB  DD DSN=ISP.SISPMENU,DISP=SHR\n//ISPTLIB  DD DSN=ISP.SISPTENU,DISP=SHR\n//ISPILIB  DD DSN=ISP.SISPSAMP,DISP=SHR\n//ISPPROF  DD DSN=&&PROF,DISP=(NEW,PASS),\n//            UNIT=VIO,SPACE=(TRK,(1,1,20)),\n//            DCB=(LRECL=80,BLKSIZE=0,RECFM=FB)\n//ISPLOG   DD DUMMY\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD DUMMY\n//DDL      DD SYSOUT=*\n//\n\n\nResult (on DDL DD) may look as follows:\n\n//IBMUSERB JOB MSGCLASS=H,NOTIFY=&SYSUID\n//         EXEC PGM=IDCAMS,DYNAMNBR=1000\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *\n  ALLOCATE -\n   DSNAME('CPAC.CMDPROC') -\n   TRACKS -\n   SPACE(10 10) -\n   DIR(50) -\n   DSORG(PO) -\n   RECFM(F B) -\n   LRECL(80) -\n   BLKSIZE(27920) -\n   UNIT(3390) -\n   VOLUME(Z13CAT)\n  /* 80 3390 TRACK(S) ALLOCATED */\n  ALLOCATE -\n   DSNAME('CPAC.DBRMLIB') -\n   BLOCK(6160) -\n   SPACE(1149 426) -\n   DIR(0) -\n   DSNTYPE(LIBRARY) -\n   DSORG(PO) -\n   RECFM(F B) -\n   LRECL(80) -\n   BLKSIZE(6160) -\n   UNIT(3390) -\n   VOLUME(Z13CAT)\n  /* 125 3390 TRACK(S) ALLOCATED */\n  ALLOCATE -\n   DSNAME('CPAC.DOCLIB') -\n   TRACKS -\n   SPACE(80 42) -\n   DIR(0) -\n   DSNTYPE(LIBRARY) -\n   DSORG(PO) -\n   RECFM(F B) -\n   LRECL(80) -\n   BLKSIZE(32720) -\n   UNIT(3390) -\n   VOLUME(Z13CAT)\n  /* 80 3390 TRACK(S) ALLOCATED */\n  ALLOCATE -\n   DSNAME('CPAC.FTPXLATE') -\n   BLOCK(256) -\n   SPACE(183 100) -\n   DIR(20) -\n   DSORG(PO) -\n   RECFM(F) -\n   LRECL(256) -\n   BLKSIZE(256) -\n   UNIT(3390) -\n   VOLUME(Z13CAT)\n  /* 1 3390 TRACK(S) ALLOCATED */\n  ALLOCATE -\n   DSNAME('CPAC.HFS') -\n   CYLINDERS -\n   SPACE(500 100) -\n   DIR(0) -\n   DSNTYPE(HFS) -\n   DSORG(PO) -\n   RECFM(U) -\n   LRECL(0) -\n   BLKSIZE(0) -\n   UNIT(3390) -\n   VOLUME(Z13CAT)\n  /* 42000 3390 TRACK(S) ALLOCATED */\n  ALLOCATE -\n   DSNAME('CPAC.ISPCLIB') -\n   BLOCK(6160) -\n   SPACE(1141 426) -\n   DIR(0) -\n   DSNTYPE(LIBRARY) -\n   DSORG(PO) -\n   RECFM(F B) -\n   LRECL(80) -\n   BLKSIZE(6160) -\n   UNIT(3390) -\n   VOLUME(Z13CAT)\n  /* 124 3390 TRACK(S) ALLOCATED */\n  ALLOCATE -\n   DSNAME('CPAC.ISPMLIB') -\n   BLOCK(6160) -\n   SPACE(24 6) -\n   DIR(12) -\n   DSORG(PO) -\n   RECFM(F B) -\n   LRECL(80) -\n   BLKSIZE(6160) -\n   UNIT(3390) -\n   VOLUME(Z13CAT)\n  /* 3 3390 TRACK(S) ALLOCATED */\n  ALLOCATE -\n   DSNAME('CPAC.ISPPLIB') -\n   BLOCK(6160) -\n   SPACE(144 34) -\n   DIR(21) -\n   DSORG(PO) -\n   RECFM(F B) -\n   LRECL(80) -\n   BLKSIZE(6160) -\n   UNIT(3390) -\n   VOLUME(Z13CAT)\n  /* 16 3390 TRACK(S) ALLOCATED */\n  ALLOCATE -\n   DSNAME('CPAC.ISPSLIB') -\n   BLOCK(6160) -\n   SPACE(24 6) -\n   DIR(8) -\n   DSORG(PO) -\n   RECFM(F B) -\n   LRECL(80) -\n   BLKSIZE(6160) -\n   UNIT(3390) -\n   VOLUME(Z13CAT)\n  /* 3 3390 TRACK(S) ALLOCATED */\n  ALLOCATE -\n   DSNAME('CPAC.ISPTLIB') -\n   BLOCK(6160) -\n   SPACE(32 8) -\n   DIR(8) -\n   DSORG(PO) -\n   RECFM(F B) -\n   LRECL(80) -\n   BLKSIZE(6160) -\n   UNIT(3390) -\n   VOLUME(Z13CAT)\n  /* 3 3390 TRACK(S) ALLOCATED */\n  ALLOCATE -\n   DSNAME('CPAC.LINKLIB') -\n   BLOCK(23200) -\n   SPACE(336 620) -\n   DIR(0) -\n   DSNTYPE(LIBRARY) -\n   DSORG(PO) -\n   RECFM(U) -\n   LRECL(0) -\n   BLKSIZE(23200) -\n   UNIT(3390) -\n   VOLUME(Z13CAT)\n  /* APF-authorized data set */\n  /* 676 3390 TRACK(S) ALLOCATED */\n  ALLOCATE -\n   DSNAME('CPAC.LOADLIB') -\n   BLOCK(6144) -\n   SPACE(320 95) -\n   DIR(9) -\n   DSORG(PO) -\n   RECFM(U) -\n   LRECL(0) -\n   BLKSIZE(6144) -\n   UNIT(3390) -\n   VOLUME(Z13CAT)\n  /* 170 3390 TRACK(S) ALLOCATED */\n  ALLOCATE -\n   DSNAME('CPAC.LPALIB') -\n   BLOCK(23200) -\n   SPACE(12 4) -\n   DIR(9) -\n   DSORG(PO) -\n   RECFM(U) -\n   LRECL(0) -\n   BLKSIZE(23200) -\n   UNIT(3390) -\n   VOLUME(Z13CAT)\n  /* 5 3390 TRACK(S) ALLOCATED */\n  ALLOCATE -\n   DSNAME('CPAC.PARMLIB') -\n   TRACKS -\n   SPACE(102 10) -\n   DIR(151) -\n   DSORG(PO) -\n   RECFM(F B) -\n   LRECL(80) -\n   BLKSIZE(27920) -\n   UNIT(3390) -\n   VOLUME(Z13CAT)\n  /* 102 3390 TRACK(S) ALLOCATED */\n  ALLOCATE -\n   DSNAME('CPAC.PIPELIB') -\n   BLOCK(32760) -\n   SPACE(41 15) -\n   DIR(22) -\n   DSORG(PO) -\n   RECFM(U) -\n   LRECL(0) -\n   BLKSIZE(32760) -\n   UNIT(3390) -\n   VOLUME(Z13CAT)\n  /* 24 3390 TRACK(S) ALLOCATED */\n  ALLOCATE -\n   DSNAME('CPAC.PROCLIB') -\n   TRACKS -\n   SPACE(19 2) -\n   DIR(30) -\n   DSORG(PO) -\n   RECFM(F B) -\n   LRECL(80) -\n   BLKSIZE(27920) -\n   UNIT(3390) -\n   VOLUME(Z13CAT)\n  /* 27 3390 TRACK(S) ALLOCATED */\n  ALLOCATE -\n   DSNAME('CPAC.SAMPLIB') -\n   TRACKS -\n   SPACE(5 1) -\n   DIR(10) -\n   DSORG(PO) -\n   RECFM(F B) -\n   LRECL(80) -\n   BLKSIZE(27920) -\n   UNIT(3390) -\n   VOLUME(Z13CAT)\n  /* 20 3390 TRACK(S) ALLOCATED */\n  ALLOCATE -\n   DSNAME('CPAC.VTAMLIB') -\n   TRACKS -\n   SPACE(3 0) -\n   DIR(10) -\n   DSORG(PO) -\n   RECFM(U) -\n   LRECL(0) -\n   BLKSIZE(32760) -\n   UNIT(3390) -\n   VOLUME(Z13CAT)\n  /* APF-authorized data set */\n  /* 3 3390 TRACK(S) ALLOCATED */\n  ALLOCATE -\n   DSNAME('CPAC.VTAMLST') -\n   TRACKS -\n   SPACE(116 12) -\n   DIR(41) -\n   DSORG(PO) -\n   RECFM(F B) -\n   LRECL(80) -\n   BLKSIZE(27920) -\n   UNIT(3390) -\n   VOLUME(Z13CAT)\n  /* 116 3390 TRACK(S) ALLOCATED */\n  /* TOTAL 43578 3390 TRACK(S) ALLOCATED */\n\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FEEDBACK": {"ttr": 1288, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x01\\x01\\x18\\x17\\x8f\\x01\\x18\\x17\\x8f\\x117\\x00x\\x00x\\x00\\x00\\xc2\\xd3\\xc9\\xe9\\xd5\\xc5\\xe3\\xe2@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-06-27T00:00:00", "modifydate": "2018-06-27T11:37:01", "lines": 120, "newlines": 120, "modlines": 0, "user": "BLIZNETS"}, "text": "/* REXX */\n/*\n\nFunction: Complete error notification.\n\nUsage:    This procedure designated for use in batch JCL jobs,\n          usually as a last step (but not necessarilly). Traps\n          the highest completion code of the previous (already\n          completed) job steps as well as jobname, jobid, userid\n          and date, then reads SYSUT1 stream and substitute any\n          occurences of %MAXCC%, %JOBNAME%, %JOBID%, %USERID%,\n          %DD%, %MM%, %YYYY%, %YY%, %JJJ% with an appropriate\n          values and writes to SYSUT2.\n          SYSUT1 data assumed to be a complete SMTP stream:\n          HELO SMTP_host\n          MAIL FROM: sender\n          RCPT TO: recipients\n          etc. etc.\n          QUIT\n\nSyntax:   FEEDBACK \u00a2ctlchar!\n          ctlchar - replacement for substitution control charater.\n                    default is '%'.\n\nExample:  //   IF condition THEN\n          //   EXEC PGM=IRXJCL,PARM='FEEDBACK'\n          //SYSEXEC  DD procedure_library\n          //SYSTSPRT DD SYSOUT=*\n          //SYSUT1   DD notification_template\n          //SYSUT2   DD (B,SMTP)\n          //   ENDIF\n\n(C) 2005-2016 Gregory Bliznets gbliznets@iba.by\n\n*/\ntrace off\nmaxcc = 0\nparse upper arg ctlchar .\nif ctlchar = ''\nthen ctlchar = '%'\nCVT = '10' /* CVT absolute address */\nTCB = c2x(storage(c2x(storage(c2x(storage(CVT,4)),4)),4)) /* current TCB */\nTIOT = c2x(storage(la(TCB,'000C'),4)) /* ptr to TIOT */\njobname = storage(TIOT,8) /* jobname */\nJSCB = c2x(storage(la(TCB,'00B4'),4)) /* ptr to JSCB */\nJCT = c2x(storage(la(JSCB,'0104'),4)) /* ptr to JCT */\nSSIB = c2x(storage(la(JSCB,'013C'),4)) /* ptr to SSIB */\njobid = storage(la(SSIB,'000C'),8) /* jobid */\ntimestamp = storage(la(JCT,'00A2'),6) /* Date and Time */\n/* 'yydddFhhhhhh'x where hhhhhh number of centisec since 0h, not used yet */\nSCT = c2x(storage(la(JCT,'0030'),3)) /* ptr to first SCT */\ndo i = 1 to 255 while SCT <> '00000000' /* limit to 255 to avoid loop */\n  pgm = storage(la(SCT,'007C'),8) /* pgmname */\n  SCTX = c2x(storage(la(SCT,'0054'),3)) /* ptr to SCTX */\n  parm = strip(storage(la(SCTX,'0014'),100),,'00'x) /* parm */\n  SCTSCLPC = storage(la(SCT,'003C'),8) /* procname */\n  SCTSNAME = storage(la(SCT,'0044'),8) /* stepname */\n  SCTSTEND = storage(la(SCT,'00BC'),1) /* switches */\n  if stepname = ''\n  then step = SCTSCLPC\n  else step = SCTSNAME\n  select\n  when bitand(SCTSTEND, '10'x) == '10'x\n  then nop /* this step was flushed */\n  when bitand(SCTSTEND, 'C0'x) == 'C0'x\n  then maxcc = max(maxcc, c2d(storage(la(SCT,'0018'),2))) /* completion code */\n  when bitand(SCTSTEND, '80'x) == '80'x\n  then nop /* active step, I'm running here */\n  otherwise nop /* step not started yet */\n  end\n  SCT = c2x(storage(la(SCT,'0024'),3)) /* ptr to next SCT */\nend i\nyyyymmdd = date('S')\nparse var yyyymmdd 1 yyyy +4 -2 yy +2 mm +2 dd +2\nif ((yyyy//4=0 & yyyy//100<>0) | yyyy//400=0)\nthen dayspermonth = '31 29 31 30 31 30 31 31 30 31 30 31'\nelse dayspermonth = '31 28 31 30 31 30 31 31 30 31 30 31'\njjj = 0\ndo i = 1 to mm-1\n  jjj = jjj + word(dayspermonth,i)\nend i\njjj = right(jjj+dd,3,'0')\n\nsubs.1 = 'MAXCC 'maxcc\nsubs.2 = 'USERID 'userid()\nsubs.3 = 'JOBNAME 'jobname\nsubs.4 = 'JOBID 'jobid\nsubs.5 = 'DD 'dd\nsubs.6 = 'MM 'mm\nsubs.7 = 'YY 'yy\nsubs.8 = 'YYYY 'yyyy\nsubs.9 = 'JJJ 'jjj\nsubs.0 = 9\n'EXECIO * DISKR SYSUT1 (FINIS STEM SMTP.'\ndo i = 1 to smtp.0\n  do j = 1 to subs.0 while pos(ctlchar, smtp.i) > 0\n    parse var subs.j var val\n    smtp.i = changestr(ctlchar''var''ctlchar, smtp.i, val)\n  end j\nend i\n'EXECIO 'smtp.0' DISKW SYSUT2 (FINIS STEM SMTP.'\nexit maxcc\n\nla: /* Load address (pointer calculation) */\n  return d2x(x2d(arg(1))+x2d(arg(2)))\n\nChangeStr: /* Case-independent changestr function */\n  parse arg _needle, _haystack, _newneedle\n  parse upper arg _upper_needle, _upper_haystack, _upper_newneedle\n  result=''\n  _p1=1\n  do forever\n    _p2=pos(_upper_needle,_upper_haystack,_p1)\n    if _p2=0\n    then leave\n    result=result''substr(_haystack,_p1,_p2-_p1)''_newneedle\n    _p1=_p2+length(_needle)\n  end\n  return result''substr(_haystack,_p1)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FEEDBCK#": {"ttr": 1291, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x01\\x01\\x18\\x17\\x8f\\x01\\x18\\x17\\x8f\\x117\\x00>\\x00>\\x00\\x00\\xc2\\xd3\\xc9\\xe9\\xd5\\xc5\\xe3\\xe2@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-06-27T00:00:00", "modifydate": "2018-06-27T11:37:01", "lines": 62, "newlines": 62, "modlines": 0, "user": "BLIZNETS"}, "text": "\nFunction: Complete error notification.\n\nUsage:    This procedure designated for use in batch JCL jobs,\n          usually as a last step (but not necessarilly). Traps\n          the highest completion code of the previous (already\n          completed) job steps as well as jobname, jobid and\n          userid, then reads SYSUT1 stream and substitute any\n          occurences of %MAXCC%, %JOBNAME%, %JOBID%, %USERID%,\n          %DD%, %MM%, %YYYY%, %YY%, %JJJ% with an appropriate\n          values and writes to SYSUT2.\n          %MAXCC% will substituted with maximum job step completion code\n          %JOBNAME% will substituted with actual job name\n          %JOBID% will substituted with actual job id\n          %USERID% will substituted with actual userid assigned to the job\n          %DD% will substituted with actual day (two digits)\n          %MM% will substituted with actual month (two digits)\n          %YYYY% will substituted with actual year (four digits)\n          %YY% will substituted with actual century year (two digits)\n          %JJJ% will substituted with actual day of year (julian date, three dig\n\n          SYSUT1 data usually assumed to be a complete SMTP stream:\n          HELO SMTP_host\n          MAIL FROM: sender\n          RCPT TO: recipients\n          etc. etc.\n          QUIT\n\nSyntax:   FEEDBACK \u00a2ctlchar!\n          ctlchar - replacement for substitution control charater.\n                    default is '%'.\n\nExample:  //   IF condition THEN\n          //   EXEC PGM=IRXJCL,PARM='FEEDBACK'\n          //SYSEXEC  DD procedure_library\n          //SYSTSPRT DD SYSOUT=*\n          //SYSUT1   DD *\n          HELO there\n          MAIL FROM:<somebody@somewhere>\n          RCPT TO:<gbliznet@iba.by>\n          DATA\n          MIME-Version: 1.0\n          Content-Type: text/html; Charset=US-ASCII; Content-Transfer-Encoding:\n          From:<somebody@somewhere>\n          To:<gbliznets@iba.by>\n          Subject: Feedback: %USERID% %JOBNAME%(%JOBID%) completed, rc %MAXCC%\n\n          <html><body><tt><pre>\n          Feedback: %USERID% %JOBNAME%(%JOBID%) completed, rc %MAXCC%\n          </pre></tt></body</html>\n\n          .\n          //SYSUT2   DD (B,SMTP)\n          //   ENDIF\n\nNote:     Starting z/OS 2.1 JES2 able to substitute the following\n          JCL symbols to the input stream: &SYSUID, &SYSJOBNM, &SYSJOBID.\n          However, max job step completion code cannot be substituted,\n          at least with z/OS 2.3\n\nHistory:\n    Written by Gregori Bliznets at 2005, last changed 02.2008\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "HTML": {"ttr": 1293, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00V\\x01\\x18\\x10\\x0f\\x01\\x18\\x10\\x0f\\x19&\\x00\\x01\\x00\\x01\\x00\\x00\\xc2\\xd3\\xc9\\xe9\\xd5\\xc5\\xe3\\xe2@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-04-10T00:00:00", "modifydate": "2018-04-10T19:26:56", "lines": 1, "newlines": 1, "modlines": 0, "user": "BLIZNETS"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "ISP2CSV": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x01\\x01\\x18\\x17\\x8f\\x01\\x18\\x17\\x8f\\x117\\x00\\xfc\\x00\\xfc\\x00\\x00\\xc2\\xd3\\xc9\\xe9\\xd5\\xc5\\xe3\\xe2@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-06-27T00:00:00", "modifydate": "2018-06-27T11:37:01", "lines": 252, "newlines": 252, "modlines": 0, "user": "BLIZNETS"}, "text": "/* REXX */\n/*\n\nFunction:\n       Unload ISPF table to CSV file\n\nSyntax:\n       ISP2CSV table csv \u00a2fs \u00a2fd!!\n\nHistory:\n       Created 02/2005\n       Updated 09/2005 - command syntax changed to fit SCLM\n       Updated 09/2012 - reviewed and rewritten\n       Updated 09/2016 - wrong check for input CSV parameter\n\n(C) 2005-2016 Gregory Bliznets gbliznets@iba.by\n\n*/\ntrace off\nparse upper arg tbl csv fs fd\naddress ISPEXEC\n'CONTROL ERRORS RETURN'\nlower = 'qwertyuiopasdfghjklzxcvbnm'\nparse upper var lower upper\ndigits = '0123456789'\nspecial = '$_@'\nself = 'ISP2CSV'\nzispfrc = 0\ntbopen = 0\nlmid = ''\nlmopen = 0\nisptdd = 'ISPTLIB'\n\nif tbl = ''\nthen call error 16, 'Table was not specified'\nif pos('=', tbl) > 0\nthen do /* reference to the ddname */\n  tblref = 'DDNAME'\n  parse var tbl keyword '=' isptlib '(' table ')'\n  if abbrev('DDNAME', ToUpper(keyword), 2) = 0\n  then call error 16, 'Invalid table specification: 'tbl\n  if isptlib = ''\n  then call error 16, 'Invalid table specification: 'tbl\n  if table = ''\n  then call error 16, 'Invalid table specification: 'tbl\n  rc = ISPF(0, \"LIBDEF \"isptdd\" LIBRARY ID(\"isptlib\")\")\n  end\nelse do /* data set name specified */\n  tblref = 'DSNAME'\n  parse var tbl isptlib '(' table ')'\n  if isptlib = ''\n  then call error 16, 'Invalid table specification: 'tbl\n  if table = ''\n  then call error 16, 'Invalid table specification: 'tbl\n  if Exists(isptlib) <> 0\n  then call error 16, isptlib' does not exists'\n  if dsorg <> 'PO'\n  then call error 16, 'Invalid table specification: 'tbl\n  rc = ISPF(0, \"LIBDEF \"isptdd\" DATASET ID('\"isptlib\"')\")\n  end\n\nif csv = ''\nthen call error 16, 'CSV output not specified'\nif pos('=', csv) > 0\nthen do /* reference to the ddname */\n  csvref = 'DDNAME'\n  parse var csv keyword '=' csvdd '(' csvmember ')'\n  if abbrev('DDNAME', ToUpper(keyword), 2) = 0\n  then call error 16, 'Invalid CSV specification'\n  if csvdd = ''\n  then call error 16, 'Invalid CSV specification'\n  end\nelse do /* data set name specified */\n  csvref = 'DSNAME'\n  parse var csv csvdsname '(' csvmember ')'\n  dsorg = ''\n  if exists(csvdsname) <> 0\n  then call error 16, csvdsname' does not exists'\n  select\n  when dsorg = 'PS' & csvmember <> ''\n  then call error 16, 'Invalid CSV specification'\n  when dsorg = 'PO' & csvmember = ''\n  then do\n    csvmember = table\n    csvdsname = csv\n    csv = csvdsname'('csvmember')'\n    end\n  when dsorg = 'PO' & csvmember <> ''\n  then nop\n    otherwise call error 16, 'Invalid CSV specification'\n  end\n  csvdd = self\n  end\n\nif fs = ''\nthen fs = ','\nif length(fs) = 2 & datatype(fs,'X') = 1\nthen fs = x2c(fs)\nif length(fs) <>  1\nthen call error 16, 'Invalid field separator 'fs\nif fd = ''\nthen fd = '\"'\nif length(fd) = 2 & datatype(fd,'X') = 1\nthen fd = x2c(fd)\nif length(fd) <>  1\nthen call error 16, 'Invalid field delimiter 'fd\nif fs = fd\nthen call error 16, 'Field delimiter and field separator cannot be the same'\n\n/* Open CSV */\nif csvref = 'DDNAME'\nthen lmopt = \"DDNAME(\"csvdd\")\"\nelse lmopt = \"DATASET('\"csvdsname\"')\"\nif csvmember = ''\nthen lmopt = lmopt' ENQ(EXCLU)'\nelse lmopt = lmopt' ENQ(SHRW)'\nrc = ISPF(0, \"LMINIT DATAID(LMID) \"lmopt)\nlmid = 'DATAID('lmid')'\nlmopt = 'OPTION(OUTPUT)'\nrc = ISPF(0, 'LMOPEN 'lmid' 'lmopt)\nlmopen = 1\n\nrc = ISPF(0, 'TBOPEN 'table' NOWRITE')\ntbopen = 1\nrc = ISPF(0, 'TBQUERY 'table' KEYS(KEYS) NAMES(NAMES)')\nparse var keys . '(' keys ')' .\nparse var names . '(' names ')' .\nvars = ToUpper(keys) ToLower(names)\nline = ''\ndo while vars <> ''\n  parse var vars var vars\n  if left(var, 2) = '__'\n  then call error rc, 'Unsupported column name: 'var\n  line = line''fs''var\nend\nline = substr(line, 2)\nl = length(line)\nrc = ISPF(0, 'LMPUT 'lmid' DATALOC(LINE) DATALEN('l') MODE(INVAR)')\nrc = ISPF(0, 'TBTOP 'table)\ndo n = 2\n  line = TBGet(table, keys' 'names, fd, fs)\n  if line = ''\n  then leave\n  l = length(line)\n  rc = ISPF(0, 'LMPUT 'lmid' DATALOC(LINE) DATALEN('l') MODE(INVAR)')\nend\nif csvmember <> ''\nthen rc = ISPF(8, 'LMMREP 'lmid' MEMBER('csvmember') STATS(NO) NOENQ')\nsay tbl' unloaded to 'csv\n\nQuit:\n  'TBEND 'table\n  if lmopen = 1\n  then 'LMCLOSE 'lmid\n  if lmid <> ''\n  then 'LMFREE 'lmid\n  if isptdd <> ''\n  then 'LIBDEF 'isptdd\n  \"VPUT (ZISPFRC)\"\n  exit zispfrc\n\nError: parse arg zispfrc, text\n  say text\n  signal Quit\n\nTBGet: procedure\n  /*\n  Note: variable names prefixed here with __ to avoid accidental change when\n  table column has the same name as variable (let suppose column name FD)\n  */\n  parse arg __table, __vars, __fd, __fs\n  rc = ISPF(12, \"TBSKIP \"__table)\n  if rc <> 0\n  then return ''\n  __values = ''\n  do while __vars <> ''\n    parse var __vars __var __vars\n    __value = strip(value(__var))\n    if (datatype(__value, 'W') = 0) | (verify(__value, '0123456789.-+') <> 0)\n    then do\n      if pos(__fd, __value) > 0\n      then __value = ChangeStr(__fd, __fd''__fd, __value)\n      __value = __fd''__value''__fd\n      end\n    __values = __values''__fs''__value\n  end\n  return substr(__values, 2) /* skip leading fs */\n\n/* Check string for uppercase letters / digits / special */\nIsUpper:\n  return verify(arg(1), upper''digits''special) = 0\n\n/* Check string for valid ISPF table field name */\nIsName:\n  return (verify(arg(1), lower''upper''digits''special) = 0) & ,\n         (verify(left(arg(1),1), lower''upper''special) = 0)\n\n/* Lowercase string */\nToLower:\n  return translate(arg(1), lower, upper)\n\n/* Uppercase string */\nToUpper:\n  return translate(arg(1), upper, lower)\n\n/* Case-independent changestr function */\nChangeStr: procedure\n  parse arg needle, haystack, newneedle\n  parse upper arg upper_needle, upper_haystack\n  result = ''\n  p1 = 1;\n  do forever\n    p2 = pos(upper_needle, upper_haystack, p1)\n    if p2 = 0\n    then leave\n    result = result''substr(haystack,p1,p2-p1)''newneedle\n    p1 = p2 + length(needle)\n  end\n  return result''substr(haystack, p1)\n\n/* Check if library(member) exists */\nExists: procedure expose dsorg\n  parse arg dsn\n  rc = LISTDSI(\"'\"dsn\"'\")\n  dsorg = sysdsorg\n  return rc\n\nISPF:\n  address ISPEXEC arg(2)\n  if rc > arg(1)\n  then do\n    say self' terminated due to 'word(arg(2),1)' error 'rc':'\n    if word(arg(2),1) = 'TBOPEN'\n    then do\n      select\n      when rc = 8\n      then msg = 'Table does not exist'\n      when rc = 12\n      then msg = 'Table was in use'\n      otherwise\n        msg = 'Severe error'\n      end\n      end\n    else do\n      address ISPEXEC 'VGET (ZERRMSG ZERRLM)'\n      msg = ZERRMSG' 'ZERRLM\n      end\n    say arg(2)\n    say msg\n    signal quit\n    end\n  return rc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISP2CSV#": {"ttr": 1542, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00G\\x01\\x16\\x10/\\x01\\x16\\x10/\\x16&\\x00\\x83\\x00\\x00\\x00\\x00\\xc8\\xc5\\xd3\\xd7@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2016-04-11T00:00:00", "modifydate": "2016-04-11T16:26:47", "lines": 131, "newlines": 0, "modlines": 0, "user": "HELP"}, "text": "\nISP2CSV - unload ISPF table to CSV file\n\nFunction:\n    Unload ISPF Table to comma-separated flat file (CSV file)/ CSV\n    file can be easily edited on z/OS with powerfull ISPF editor as\n    well as transferred to the workstation and processed with MS\n    Excel, Lotus 123 and many other programs.\n\n    This procedures can be used to perform the following tasks:\n\n        Perform data exchange between z/OS ISPF and any workstation\n        spreadsheet processor (MS Excel, Lotus 123 and so on). CSV\n        file processed by both procedures has the same structure as\n        used by the workstations spreadsheet processors. Data can be\n        processed using the powerfull features of the spreadsheet\n        processor - creating diagrams, complex calculations and so\n        on, and if necessary - transferred back to the z/OS and\n        loading to the same or another ISPF table.\n\n        Maintain ISPF table source together with CSV2ISP procedure.\n        ISPF table data can be maintaned as a text file. ISP2CSV\n        procedure can be defined as SCLM CSV language translator to\n        maintenance table data under SCLM and maintained\n        automatically as integral part of other source code.\n\n\nSyntax:\n     ISP2CSV   table_specification   CSV_specification  >fs  >fd!!\n\ntable_specification\n    Refers to ISPF table. The one of the following should be specified:\n\n      * library(member)\n      * DDname=ddname(member)\n\n    Only partitioned data set (PDS, PDSE) allowed. If reference to\n    DD name specified, this DD must be preallocated. Both data set\n    and member (i.e. the ISPF table) must exist. If reference to DD\n    name specified in form DDname=ddname, appropriate DD name cannot\n    define a member of the partitioned data set, reference in form\n    DDname=ddname(member) should be used instead.\n\nCSV_specification\n    Refers to CSV file. The one of the following should be specified:\n\n      * dataset\n      & library(member)\n      & DDname=ddname\n      * DDname=ddname(member)\n\n    Either member of the partitioned data set (PDS, PDSE) or\n    sequential data set (PS) can be specified. If reference to DD\n    name specified, this DD must be preallocated. Data set must be\n    preallocated anyway. Member, if specified, will be replaced if\n    it already exists or added otherwise. If reference to DD name\n    specified in form DDname=ddname, appropriate DD name cannot\n    define a member of the partitioned data set, reference in form\n    DDname=ddname(member) should be used instead.\n\nfs\n    field separator. Either one character or two hexadecimal digits.\n    Optional, comma by default.\n\nfd\n    field delimiter. Either one character or two hexadecimal digits.\n    Optional, double quote by default.\n\n\nUsage notes:\n\n    1.  All parameters are positional\n    2.  The first line of unloaded CSV file would contains field\n        names, separated by field separator (comma). Key fields names\n        are uppercase, other fields are in lowercase. Table data\n        follows the header. All fields are separated by field\n        separator, all non-numeric field enclosed in field delimiters\n        (double quote);\n    3.  Output data set or library must be preallocated;\n    4.  Unloaded table should not contains field names started\n        with two underscope character (__). There are no any other\n        restrictions on the unloaded table. The table can be defined\n        with or without keyed fields, with or without non-keyed\n        fields. However, the output data set or library should have\n        sufficient record length to fit all table fields and added\n        field separators and field delimiters.\n    5.  Parameters in form library(member) may be useful for\n        interactive ISPF session, for a batch job form reference to\n        DD name may be more convenient.\n    6.  ISPF environment required to run this procedure in batch\n        job (use ISPF or ISPSTART). See job example below:\n\n\n   //ISPF     EXEC PGM=IKJEFT01,REGION=0K\n   //SYSTSPRT DD  SYSOUT=*\n   //SYSPROC  DD  DISP=SHR,DSN=CENTER.CLIST\n   //SYSEXEC  DD  DISP=SHR,DSN=ISP.SISPEXEC\n   //ISPPLIB  DD  DISP=SHR,DSN=ISP.SISPPENU\n   ...  other ISPF libraries\n   //SYSTSIN  DD  *\n    ISPF CMD(%ISP2CSV DD=TBL(TEST) DD=CSV)\n   //CSV      DD  DISP=SHR,DISP=&SYSUID.CSV.DATA\n   //TBL      DD  DISP=SHR,DSN=&SYSUID.ISPF.TABLES\n\n   JCL procedure ISP2CSV provided to simplify use of ISP2CSV in batch.\n\n\n   //ISP2CSV  PROC LIB=,     -- Table Library, mandatory\n   //          CSV=,     -- CSV Data Set, mandatory\n   //          TABLE=    -- Table Name, mandatory\n   //          FS='',    -- Field Separator, optional, ',' by default\n   //          FD='',    -- Field Delimiter, optional, '\"' by default\n   //          SELF=CENTER.CLIST, -- Library where ISPTCSV resides\n   //          ISPFHLQ=ISP -- ISPF data set prefix, usually ISP or SYS1\n\n   Thus, with procedure above job to load table from CSV look as\n   follows:\n\n\n   //SYSPRG1A JOB  MSGCLASS=H\n   //PROC     JCLLIB ORDER=(CENTER.PROCLIB)\n   //         EXEC ISP2CSV,\n   //            TABLE=TEST,\n   //            LIB=&SYSUID.ISPF.TABLES,\n   //            CSV=&SYSUID.CSV.DATA\n   //\n\nHistory:\n    Written by Gregori Bliznets at 2005, last changed 09.2012\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISP2CSVJ": {"ttr": 1545, "alias": false, "halfwords": 40, "notes": 0, "parms": "b'\\x01\\x00 @\\x01\\x16\\x08\\x1f\\x01\\x16\\x08\\x1f\\x175\\x00\\r\\x00\\r\\x00\\x00\\xd1\\xd6\\xc2@@@@@\\x00\\x00\\x00\\r\\x00\\x00\\x00\\r\\x00\\x00\\x00\\x00'", "ispf": {"version": "01.00", "flags": 32, "createdate": "2016-03-21T00:00:00", "modifydate": "2016-03-21T17:35:40", "lines": 13, "newlines": 13, "modlines": 0, "user": "JOB"}, "text": "//IBMUSERB JOB  MSGCLASS=H\n//PROC     JCLLIB ORDER=(CPAC.PROCLIB)\n//         EXEC ISP2CSV,TABLE=TEST,FS=';'\n//ISPTCSV.TBL DD DISP=SHR,DSN=CPAC.ISPTLIB\n//ISPTCSV.CSV DD DISP=(NEW,PASS),DSN=&&CSV,\n//             UNIT=VIO,SPACE=(TRK,(1,1)),\n//             DCB=(DSORG=PS,LRECL=255,BLKSIZE=0,RECFM=VB)\n//PRINT    EXEC PGM=IEBGENER\n//SYSPRINT DD  DUMMY\n//SYSIN    DD  DUMMY\n//SYSUT1   DD  DISP=(OLD,DELETE),DSN=&&CSV\n//SYSUT2   DD  SYSOUT=*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ISP2CSVP": {"ttr": 1547, "alias": false, "halfwords": 40, "notes": 0, "parms": "b'\\x01\\x00 @\\x01\\x16\\x08\\x1f\\x01\\x16\\x08\\x1f\\x175\\x00\\x1e\\x00\\x1e\\x00\\x00\\xd7\\xd9\\xd6\\xc3@@@@\\x00\\x00\\x00\\x1e\\x00\\x00\\x00\\x1e\\x00\\x00\\x00\\x00'", "ispf": {"version": "01.00", "flags": 32, "createdate": "2016-03-21T00:00:00", "modifydate": "2016-03-21T17:35:40", "lines": 30, "newlines": 30, "modlines": 0, "user": "PROC"}, "text": "//ISP2CSV  PROC LIB=,    -- Table Library, mandatory\n//             TABLE=,   -- Table name, mandatory\n//             CSV=,     -- CSV Data Set, mandatory\n//             FS='',    -- Field Separator, optional, ',' by default\n//             FD='',    -- Field Delimiter, optional, '\"' by default\n//             SELF=CPAC.CMDPROC, -- Library where ISPTCVS resides\n//             ISPFHLQ=ISP -- ISPF data set prefix, usually ISP or SYS1\n//ISPPROF  EXEC PGM=IEBCOPY\n//SYSPRINT DD  DUMMY\n//SYSIN    DD  DUMMY\n//SYSUT1   DD  DISP=SHR,DSN=&SYSUID..ISPF.ISPPROF\n//SYSUT2   DD  DISP=(NEW,PASS),DSN=&&PROF,\n//             UNIT=VIO,SPACE=(TRK,(1,1,5)),\n//             DCB=(LRECL=80,BLKSIZE=0,RECFM=FB)\n//ISPTCSV  EXEC PGM=IKJEFT01,REGION=0K,\n// PARM='ISPF CMD(%ISP2CSV DD=TBL(&TABLE) DD=CSV &FS &FD)'\n//SYSTSPRT DD  SYSOUT=*\n//SYSPROC  DD  DISP=SHR,DSN=&SELF\n//SYSEXEC  DD  DISP=SHR,DSN=&ISPFHLQ..SISPEXEC\n//ISPPLIB  DD  DISP=SHR,DSN=&ISPFHLQ..SISPPENU\n//ISPSLIB  DD  DISP=SHR,DSN=&ISPFHLQ..SISPSENU\n//ISPMLIB  DD  DISP=SHR,DSN=&ISPFHLQ..SISPMENU\n//ISPTLIB  DD  DISP=SHR,DSN=&ISPFHLQ..SISPTENU\n//ISPPROF  DD  DISP=(OLD,DELETE),DSN=&&PROF\n//ISPLOG   DD  SYSOUT=*,\n//             DCB=(LRECL=120,BLKSIZE=2400,DSORG=PS,RECFM=FB)\n//ISPLIST  DD  SYSOUT=*,DCB=(LRECL=121,BLKSIZE=1210,RECFM=FBA)\n//CSV      DD  DISP=SHR,DSN=&CSV\n//TBL      DD  DISP=SHR,DSN=&LIB\n//SYSTSIN  DD  DUMMY\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LA": {"ttr": 1549, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00V\\x01\\x18\\x10\\x0f\\x01\\x18\\x10\\x0f\\x19&\\x00]\\x00]\\x00\\x00\\xd9\\xc5\\xe7\\xe7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-04-10T00:00:00", "modifydate": "2018-04-10T19:26:56", "lines": 93, "newlines": 93, "modlines": 0, "user": "REXX"}, "text": "/* MVS/TSO REXX/370 */\n/*\nFunction:\n       LISTALC alternative - list allocated data sets as a set of ALLOC commands\n       or JCL DD statements. Under ISPF this procedure may be used together with\n       TRAP or Mark Zelden's TSOB, TSOV, TSOE to browse output.\n\nSyntax:\n       LA \u00a2TSO \u00a6 JCL!\n\n(C) 2006-2018 Gregori Bliznets gbliznets@iba.by\n\n*/\nparse upper arg option .\nselect\nwhen option = ''\nthen jcl = 0\nwhen abbrev(option, 'TSO')\nthen jcl = 0\nwhen abbrev(option, 'JCL')\nthen jcl = 1\notherwise\n  say 'Invalid option: 'option\n  exit 16\nend\ncall outtrap 'stem.'\n'LISTALC STATUS'\ncall outtrap 'off'\ni = 2\ndd.0 = 0\ndo while i < stem.0\n  parse var stem.i dsname ddname disp\n  i = i + 1\n  select\n  when dsname = 'NULLFILE' then nop\n  when dsname = 'TERMFILE' then nop\n  otherwise\n    parse var stem.i 3 ddname +8 disp\n    i = i + 1\n  end\n  if ddname = ''\n  then do\n    n = dd.0\n    dd.n = dd.n' 'dsname\n    end\n  else do\n    n = dd.0 + 1\n    dd.n = ddname' 'dsname\n    dd.0 = n\n    end\nend\ndo i = 1 to dd.0\n  parse var dd.i ddname dsnames\n  dsnames = strip(dsnames)\n  w = words(dsnames)\n  select\n  when dsnames = 'NULLFILE'\n  then do\n    if jcl = 0\n    then say 'ALLOC 'left('FI('ddname')', 12)' DUMMY'\n    else say '//'left(ddname, 8)' DD DUMMY'\n    end\n  when dsnames = 'TERMFILE'\n  then do\n    if jcl = 0\n    then say 'ALLOC 'left('FI('ddname')', 12)' DSN(*)'\n    else say '//'left(ddname, 8)' DD SYSOUT=*'\n    end\n  when w = 1\n  then do\n    if jcl = 0\n    then say 'ALLOC 'left('FI('ddname')', 12)' DSN('''dsnames''')'\n    else say '//'left(ddname, 8)' DD DISP=SHR,DSN='dsnames\n    end\n  otherwise\n    do j = 1 to w\n      dsname = word(dsnames, j)\n      select\n      when j = 1 & jcl = 0\n      then say 'ALLOC 'left('FI('ddname')', 12)' DSN('''dsname''' + '\n      when j = 1\n      then say '//'left(ddname, 8)' DD DISP=SHR,DSN='dsname\n      when j = w & jcl = 0\n      then say copies(' ', 23)''''dsname''')'\n      when jcl = 1\n      then say '//         DD DISP=SHR,DSN='dsname\n      otherwise\n        say copies(' ', 23)''''dsname''' + '\n      end\n    end j\n  end\nend i\nexit 0\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LA#": {"ttr": 1552, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00V\\x01\\x18\\x10\\x0f\\x01\\x18\\x10\\x0f\\x19&\\x00\\x10\\x00\\x10\\x00\\x00\\xc8\\xc5\\xd3\\xd7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-04-10T00:00:00", "modifydate": "2018-04-10T19:26:56", "lines": 16, "newlines": 16, "modlines": 0, "user": "HELP"}, "text": "Function:\n \tThis simple procedure is a LISTALC alternative - list allocated data\n        sets as a set of ALLOCATE commands or JCL DD statements.\n\n\nSyntax:\n        LA \u00a2TSO \u00a6 JCL!\n\nUsage:\n  \tTSO (the default) caused LA to generate TSO ALLOCATE commands to\n        reproduce current data set allocation. JCL caused LA to generate\n        a set of JCL DD statements.\n\n        LA may be used as a command on TSO READY prompt, on ISPF =6 or on\n        COMMAND prompt. Under ISPF LA may be used together with TRAP or\n        Mark Zelden's TSOB, TSOV, TSOE to browse or edit output.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RESIZE": {"ttr": 1793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x01\\x01\\x18\\x17\\x8f\\x01\\x18\\x17\\x8f\\x117\\x04\\xc9\\x04\\xc9\\x00\\x00\\xc2\\xd3\\xc9\\xe9\\xd5\\xc5\\xe3\\xe2@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-06-27T00:00:00", "modifydate": "2018-06-27T11:37:01", "lines": 1225, "newlines": 1225, "modlines": 0, "user": "BLIZNETS"}, "text": "/* REXX */\n/*\n\nDescription:\n       Resize (reallocate) an existing PS, PO, POE, VSAM\n       cluster or VSAM alternate index.\n\nFunction:\n       Reallocate space for existing data set. Also can\n       convert PDS to PDSE and vice versa, update record\n       format, record length, block size, expiration date.\n       For VSAM cluster as well as VSAM alternate index\n       max lrecl, average lrecl, %free CI, %free CA and\n       expiration date may be changed.\n\nSyntax:\n       RESIZE dsname\n\nReturns:\n       0 - resize done\n       4 - resize done, warning issued\n       other - resize failed\n\nNote:\n       This code contains inline ISPF elements (panels, skels)\n\n(C) 2006-2018 Gregori Bliznets gbliznets@iba.by\n\n*/\ntrace off\nparse arg parms\naddress ISPEXEC\ndataid = ''\nrc = LoadISPF()\nparse upper var parms fromdsn .\nzerralrm = 'YES'\nzerrhm = '*'\nzerrsm = ''\nzerrlm = ''\n'VPUT (ZERRSM,ZERRLM,ZERRALRM,ZERRHM) SHARED'\nif fromdsn = \"\"\nthen do\n  zerrsm = 'Dataset name is missed'\n  zerrlm = 'Dataset name is missed'\n  'SETMSG MSG(ISRZ002)'\n  exit 8\n  end\nif left(fromdsn,1) = \"'\" & right(fromdsn,1) = \"'\"\nthen parse var fromdsn \"'\" fromdsn \"'\"\nrc = LISTDSI(\"'\"fromdsn\"' DIRECTORY SMSINFO\")\ntodsn = ''\ndsn = fromdsn\ndo while dsn <> ''\n  parse var dsn q '.' dsn\n  if length(todsn) + length(q) + 16 > 44\n  then leave\n  todsn = todsn''q'.'\nend\ncc = 0\nyyyy = left(date('S'), 4)\nddd = right(date('D'), 3, '0')\nssssss = right(time('S'), 6, '0')\ntodsn = todsn'D'yyyy''ddd'.T'ssssss\nalloc = sysalloc\nused = sysused\nunits = sysunits\ndsorg = sysdsorg\nrecfm = sysrecfm\nlrecl = syslrecl\nexpdt = sysexdate\nblksize = sysblksize\nprimary = sysprimary\nseconds = sysseconds\nextents = sysextents\nadirblk = sysadirblk\nudirblk = sysudirblk\ncredt = syscreate\ndssms = sysdssms\naextents = sysextents\nuextents = sysusedextents\nmgmtclas = sysmgmtclass\ndataclas = sysdataclass\nstorclas = sysstorclass\nvolume = sysvolume\ndevice = sysunit\nrecorg = ''\nselect\nwhen sysreason = 0\nthen object = 'NVSAM'\nwhen sysreason = 30\nthen do\n  zerrsm = 'Non-SMS data set'\n  zerrlm = 'Data set 'fromdsn' not SMS-managed,',\n           'LISTDSI reason code 'sysreason\n  'SETMSG MSG(ISRZ002)'\n  exit 8\n  end\nwhen sysreason = 12\nthen do\n  call outtrap 'AMS.'\n  address TSO \"LISTCAT ENTRIES('\"fromdsn\"') ALL\"\n  call outtrap 'OFF'\n  parse var ams.1 w1 w2 .\n  if rc <> 0\n  then do\n    zerrsm = 'Unsupported'\n    zerrlm = 'Resize of the data set 'fromdsn' not supported,',\n             'LISTCAT return code 'rc\n    'SETMSG MSG(ISRZ002)'\n    exit 8\n    end\n  if w1 = 'PATH'\n  then do\n    zerrsm = 'Wrong target'\n    zerrlm = 'Path 'fromdsn' cannot be resized: it has no space behind'\n    'SETMSG MSG(ISRZ002)'\n    exit 8\n    end\n\n  /* Device constants: z/OS supports 3380, 3390, 9345 only */\n  devtypes.1  = '3390 0F 15 56664'\n  devtypes.2  = '3380 0E 15 47476'\n  devtypes.3  = '3330 0D 19 13030' /* 3330-11, 3333-11 */\n  devtypes.4  = '3375 0C 12 35616'\n  devtypes.5  = '3350 0B 30 19069'\n  devtypes.6  = '3340 0A 12  8368'\n  devtypes.7  = '3330 09 19 13030' /* 3390-1, 3390-2, 3333 */\n  devtypes.8  = '2314 08 20  7294'\n  devtypes.9  = '2305 07  8 14136' /* 2305-2 */\n  devtypes.10 = '2305 06  8 14136' /* 2305-1 */\n  devtypes.11 = '2301 05  8 14136'\n  devtypes.12 = '9345 04 15 46456'\n  devtypes.13 = '2311 01 10  3625'\n  devtypes.0 = 13\n\n  object = w1\n  dname = ''\n  iname = ''\n  dtracks = 0\n  itracks = 0\n  dunits = ''\n  iunits = ''\n  quote = \"'\"\n  storclas = ''\n  mgmtclas = ''\n  dataclas = ''\n  iprimary = ''\n  dprimary = ''\n  iseconds = ''\n  dseconds = ''\n  ivolume = ''\n  dvolume = ''\n  ifreeci = ''\n  dfreeci = ''\n  ifreeca = ''\n  dfreeca = ''\n  do i = 1 to ams.0\n    parse var ams.i w1 w2 w3 w4 w5 w6 w7 w8 .\n    select\n    when w1 = 'DATA' & w2 = '-------'\n    then dname = w3\n    when w1 = 'INDEX' & w2 = '------'\n    then iname = w3\n    when left(w1,8) = 'KEYLEN--' & iname = ''\n    then do\n      keylen = word(translate(w1,' ','-'),2)\n      avglrecl = word(translate(w2,' ','-'),2)\n      end\n    when left(w1,5) = 'RKP--' & iname = ''\n    then do\n      rkp = word(translate(w1,' ','-'),2)\n      maxlrecl = word(translate(w2,' ','-'),2)\n      end\n    when left(w1,8) = 'SHROPTNS' & iname = ''\n    then do\n      parse var w1 . '(' shropt ')' .\n      amorg = w5\n      k = wordpos(amorg, 'INDEXED NONINDEXED NUMBERED LINEAR')\n      recorg = word('KS ES RR LS', k)\n      k = i+1\n      parse var ams.k w10 w11 .\n      if object = 'CLUSTER'\n      then amattr = attr(w4) attr(w6) attr(w8) attr(w10)\n      /* \u00a2NO!ERASE \u00a2NO!WRITECHK \u00a2NO!REUSE */\n      if object = 'AIX'\n      then amattr = attr(w4) attr(w6) attr(w8) attr(w11)\n      /* \u00a2NO!ERASE \u00a2NO!WRITECHK \u00a2NON!UNIQKEY */\n      if object = 'PAGESPACE'\n      then amattr = ''\n      end\n    when left(w2,8) = 'CREATION'\n    then do\n      yyyyddd = translate(right(w2,8),'/','.')\n      select\n      when iname = '' & dname = ''\n      then credt = yyyyddd\n      when dname <> '' & iname = ''\n      then dcredt = yyyyddd\n      when iname <> '' & dname <> ''\n      then icredt = yyyyddd\n      end\n      end\n    when left(w2,10) = 'EXPIRATION'\n    then do\n      yyyyddd = translate(right(w2,8),'/','.')\n      if yyyyddd = '0000/000'\n      then yyyyddd = ''\n      select\n      when iname = '' & dname = ''\n      then expdt = yyyyddd\n      when dname <> '' & iname = ''\n      then dexpdt = yyyyddd\n      when dname <> '' & iname <> ''\n      then iexpdt = yyyyddd\n      end\n      end\n    when w1 = 'STORAGECLASS '\n    then do\n      storclas = strip(translate(w2,' ','-'))\n      mgmtclas = word(translate(w3,' ','-'),2)\n      if storclas = '(NULL)'\n      then storclas = ''\n      if mgmtclas = '(NULL)'\n      then mgmtclas = ''\n      end\n    when w1 = 'DATACLASS '\n    then do\n      dataclas = strip(translate(w2,' ','-'))\n      if dataclas = '(NULL)'\n      then dataclas = ''\n      end\n    when left(w1,12) = 'SPACE-TYPE--'\n    then do\n      if iname <> ''\n      then iunits = word(translate(w1,' ','-'),3)\n      else dunits = word(translate(w1,' ','-'),3)\n      end\n    when left(w1,11) = 'SPACE-PRI--'\n    then do\n      if iname <> ''\n      then iprimary = word(translate(w1,' ','-'),3)\n      else dprimary = word(translate(w1,' ','-'),3)\n      end\n    when left(w1,11) = 'SPACE-SEC--'\n    then do\n      if iname <> ''\n      then iseconds = word(translate(w1,' ','-'),3)\n      else dseconds = word(translate(w1,' ','-'),3)\n      end\n    when left(w1,13) = 'LOW-CCHH-----'\n    then do\n      parse var ams.i . (quote) +1 lowcc +4 lowhh (quote) .\n      k = i+1\n      parse var ams.k . (quote) +1 highcc +4 highhh (quote) .\n      tracks = (x2d(highcc)-x2d(lowcc))*trkpercyl+(x2d(highhh)-x2d(lowhh))+1\n      if iname <> ''\n      then itracks = itracks+tracks\n      else dtracks = dtracks+tracks\n      end\n    when left(w1,18) = 'VOLSER------------'\n    then do\n      if iname <> ''\n      then ivolume = word(translate(w1,' ','-'),2)\n      else dvolume = word(translate(w1,' ','-'),2)\n      end\n    when left(w1,13) = 'DEVTYPE------'\n    then do\n      parse var ams.i . (quote) +1 ucbtyp (quote) .\n      parse var ucbtyp ucbtbyt1 +1 ucbtbyt2 +1 ucbtbyt3 +1 ucbtbyt4 +1\n      found = 0\n      do k = 1 to devtypes.0\n        parse var devtypes.k name type trkpercyl bytepertrk\n        if '20'type == ucbtbyt3''ucbtbyt4\n        then do\n          found = 1\n          leave k\n          end\n      end k\n      if found = 0 /* assume 3390 when not found */\n      then parse var devtypes.1 name type trkpercyl bytepertrk\n      if iname <> ''\n      then idevice = name\n      else ddevice = name\n      end\n    when left(w1,13) = 'REC-INSERTED-'\n    then do\n      freeci = word(translate(w2,' ','-'),3)\n      if iname <> ''\n      then ifreeci = freeci\n      else dfreeci = freeci\n      end\n    when left(w1,13) = 'REC-UPDATED--'\n    then do\n      freeca = word(translate(w2,' ','-'),3)\n      if iname <> ''\n      then ifreeca = freeca\n      else dfreeca = freeca\n      end\n    when object = 'AIX' & left(w1,9) = 'CLUSTER--'\n    then relate = word(translate(w1,' ','-'),2)\n    when object = 'AIX' & left(w1,7) = 'UPGRADE'\n    then upgrade = w1\n    when object = 'AIX' & left(w1,7) = 'NOUPGRADE'\n    then upgrade = w1\n    when object = 'AIX' & left(w1,7) = 'AXRKP--'\n    then axrkp = word(translate(w1,' ','-'),2)\n    otherwise nop\n    end\n  end i\n  end\notherwise\n  zerrsm = 'Unsupported'\n  zerrlm = 'Resize of the data set 'fromdsn' not supported,',\n           'LISTDSI reason code 'sysreason\n  'SETMSG MSG(ISRZ002)'\n  exit 8\nend\nif credt <> ''\nthen credt = yyyymmdd(credt)\nselect\nwhen wordpos(sysdssms, 'PDSE LIBRARY PROGRAM_LIBRARY DATA_LIBRARY') > 0\nthen sysdsntype = 'LIBRARY'\nwhen dsorg = 'PO'\nthen sysdsntype = 'PDS'\nwhen dsorg = 'PS' & sysseqdsntype <> ''\nthen sysdsntype = sysseqdsntype\notherwise\n  sysdsntype = ''\nend\naunits = 'tracks'\nuunits = 'tracks'\nselect\nwhen sysdsntype = 'LIBRARY'\nthen do /* PDSE */\n  adirblk = ''\n  udirblk = ''\n  aunits = 'pages'\n  uunits = 'pages'\n  atracks = sysallocpages\n  utracks = sysusedpages\n  end\nwhen sysunits = 'CYLINDER'\nthen do\n  atracks = systrkscyl * sysalloc\n  utracks = systrkscyl * sysused\n  end\nwhen sysunits = 'TRACK'\nthen do\n  atracks = sysalloc\n  utracks = sysused\n  end\nwhen sysunits = 'BLOCK'\nthen do\n  atracks = sysalloc * sysblksize / sysblkstrk\n  utracks = sysused * sysblksize / sysblkstrk\n  end\notherwise\n  atracks = ''\n  utracks = ''\nend\nif (expdt <> '') & (expdt <> 0)\nthen expdt = yyyymmdd(expdt)\nelse expdt = ''\nsysexpdt = expdt\ndirblk = adirblk\ndsntype = sysdsntype\n/* the following code would automatically resize PO to POE\nif sysdsorg = 'PO' & sysdsntype = 'PDS'\nthen dsntype = 'LIBRARY'\n*/\nzwinttl = 'Resize Facility'\ndo forever\n  'ADDPOP ROW(6) COLUMN(6)'\n  /* create list of changeable screen variables */\n  select\n  when dsorg = 'VS' & recorg = 'KS'\n  then vars = 'avglrecl maxlrecl dataclas mgmtclas storclas dunits dprimary' ,\n              'dseconds dvolume ddevice iunits iprimary iseconds ivolume' ,\n              'idevice dfreeci dfreeca ifreeci ifreeca'\n  when dsorg = 'VS'\n  then vars = 'avglrecl maxlrecl dataclas mgmtclas storclas dunits dprimary' ,\n              'dseconds dvolume ddevice dfreeci dfreeca'\n  otherwise\n    vars = 'units recfm lrecl blksize primary seconds dataclas mgmtclas' ,\n           'storclas expdt dsntype volume device dirblk'\n  end\n  /* store values of the changeable screen variables */\n  drop var.\n  do i = 1 to words(vars)\n    var.i = value(translate(word(vars, i)))\n  end i\n  panel = 'PANEL'dsorg\n  if recorg = 'KS'\n  then panel = 'PANEL'recorg\n  'DISPLAY PANEL('panel')'\n  cc = rc\n  'REMPOP ALL'\n  if cc > 0\n  then leave\n  drop new.\n  found = 0\n  do i = 1 to words(vars)\n    if value(word(vars, i)) <> var.i\n    then found = 1\n  end i\n  if found = 0\n  then do\n    zerrsm = 'Nothing to do'\n    zerrlm = 'Nothing was changed, data set remains unchanged'\n    'SETMSG MSG(ISRZ002)'\n    iterate\n    end\n  if dsorg <> 'VS'\n  then minlrecl = min(syslrecl,lrecl)\n  if (expdt <> getvar('expdt')) & (expdt <> '')\n  then expdt = yyyyddd(expdt)\n  if keep = 'N'\n  then do\n    'ADDPOP ROW(6) COLUMN(6)'\n    'DISPLAY PANEL(CONFIRM)'\n    cc = rc\n    'REMPOP ALL'\n    if cc <> 0\n    then iterate\n    end\n  if submit = 'Y' | submit = 'E'\n  then do\n    'VPUT (MINLRECL)'\n    'VGET (ZTEMPF ZTEMPN BJC1 BJC2 BJC3 BJC4)'\n    'FTOPEN TEMP'\n    'FTINCL SKEL'dsorg\n    'FTCLOSE'\n    if submit = 'S'\n    then do\n      rc = TSO(\"SUBMIT '\"ztempf\"'\")\n      zerrsm = 'Submitted'\n      zerrlm = 'Job to resize data set 'fromdsn' successfully submited'\n      'SETMSG MSG(ISRZ002)'\n      end\n    else \"EDIT DATASET('\"ztempf\"')\"\n    iterate\n    end\n\n  select\n  when object = 'NVSAM'\n  then do\n    /* construct TSO ALLOCATE statement */\n    stmt = \"ALLOCATE FI(UT2) DA('\"todsn\"') NEW CATALOG REUSE\"\n    stmt = stmt' UNIT('device') 'units' SPACE('primary' 'seconds')'\n    if volume <> getvar('volume')\n    then stmt = stmt' VOLUME('volume')'\n    if mgmtclas <> getvar('mgmtclas')\n    then stmt = stmt' MGMTCLAS('mgmtclas')'\n    if dataclas <> getvar('dataclas')\n    then stmt = stmt' DATACLAS('dataclas')'\n    if storclas <> getvar('storclas')\n    then stmt = stmt' STORCLAS('storclas')'\n    select\n    when dsntype = 'PDS'\n    then stmt = stmt' DSORG(PO) DIR('dirblk')'\n    when dsntype = 'LIBRARY'\n    then stmt = stmt' DSORG(PO) DSNTYPE(LIBRARY)'\n    when dsorg = 'PS' & dsntype <> getvar('dsntype')\n    then stmt = stmt' DSORG(PS) DSNTYPE('dsntype')'\n    otherwise\n      stmt = stmt' DSORG('dsorg')'\n    end\n    stmt = stmt' LRECL('lrecl') BLKSIZE('blksize') RECFM('\n    do i = 1 to length(recfm)\n      stmt = stmt''substr(recfm,i,1)' '\n    end i\n    stmt = stmt')'\n    if units = 'BLOCK'\n    then stmt = stmt' BLOCK('blksize')'\n    else stmt = stmt' 'units\n    if expdt <> ''\n    then stmt = stmt' EXPDT('expdt')'\n    end\n  when object = 'CLUSTER'\n  then do\n    /* construct AMS DEFINE CLUSTER statement */\n    stmt = \" DEFINE CLUSTER( NAME('\"todsn\"') \"amorg\n    stmt = stmt' 'amattr\n    if expdt <> ''\n    then stmt = stmt' TO('expdt')'\n    if amorg = 'INDEXED'\n    then stmt = stmt' KEYS('keylen' 'rkp')'\n    if amorg <> 'LINEAR'\n    then stmt = stmt' RECORDSIZE('avglrecl' 'maxlrecl')'\n    if sms <> 'NO'\n    then do\n      if storclas <> ''\n      then stmt = stmt' STORAGECLASS('storclas')'\n      if mgmtclas <> ''\n      then stmt = stmt' MANAGEMENTCLASS('mgmtclas')'\n      if dataclas <> ''\n      then stmt = stmt' DATACLASS('dataclas')'\n      end\n    stmt = stmt' SHAREOPTIONS('shropt')'\n    stmt = stmt' )'\n    stmt = stmt\" DATA (NAME('\"todsn\".D') \"dunits\"S(\"dprimary\" \"dseconds\")\"\n    if dfreeci+dfreeca <> 0\n    then stmt = stmt'  FREESPACE('dfreeci' 'dfreeca')'\n    if sms <> 'ONLY'\n    then stmt = stmt' VOLUMES('strip(dvolume)')'\n    stmt = stmt' )'\n    if amorg = 'INDEXED'\n    then do\n      stmt = stmt\" INDEX (NAME('\"todsn\".I') \"iunits\"S(\"iprimary\" \"iseconds\")\"\n      if ifreeci+ifreeca <> 0\n      then stmt = stmt'  FREESPACE('ifreeci' 'ifreeca')'\n      if sms <> 'ONLY'\n      then stmt = stmt' VOLUMES('strip(ivolume)')'\n      stmt = stmt' )'\n      end\n    end\n  when object = 'AIX'\n  then do\n    /* construct DEFINE AIX statement */\n    stmt = \" DEFINE AIX( NAME('\"todsn\"')\"\n    stmt = stmt' RELATE('relate') 'upgrade\n    stmt = stmt' 'amattr\n    stmt = stmt' KEYS('keylen' 'axrkp')'\n    stmt = stmt' RECORDSIZE('avglrecl' 'maxlrecl')'\n    if freeci+freeca <> 0\n    then stmt = stmt' FREESPACE('freeci' 'freeca')'\n    stmt = stmt' SHAREOPTIONS('shropt') )'\n    stmt = stmt\" DATA (NAME('\"dname\"') \"dunits\"S(\"dprimary\" \"dseconds\")\"\n    if sms <> 'ONLY'\n    then stmt = stmt' VOLUMES('strip(ivolume)')'\n    stmt = stmt' )'\n    stmt = stmt\" INDEX (NAME('\"iname\"') \"iunits\"S(\"iprimary\" \"iseconds\")\"\n    if sms <> 'ONLY'\n    then stmt = stmt' VOLUMES('strip(ivolume)')'\n    stmt = stmt' )'\n    end\n  otherwise nop\n  end\n  /* create new object */\n  rc = TSO(stmt)\n  if rc <> 0\n  then do\n    zerrsm = word(stmt, 1)' failed 'rc\n    zerrlm = tso.1\n    'SETMSG MSG(ISRZ002)'\n    iterate\n    end\n\n  if keep = 'Y'\n  then do /* Data must be kept, copy data with proper utility */\n    Z = copies('00'x,8)\n    DDLIST = Z''Z''Z''Z'UTI     UTO     'Z'UT1     UT2     '\n    PARM = ''\n    if object = 'CLUSTER'\n    then rc = TSO(\"ALLOCATE FI(UT2) DA('\"todsn\"') SHR\")\n    rc = TSO(\"ALLOC FI(UT1) DA('\"fromdsn\"') SHR\")\n    rc = TSO(\"ALLOC FI(UTO) REU RECFM(F) LRECL(121) SPACE(1,1) TRACK\")\n    rc = TSO(\"ALLOC FI(UTI) NEW TRACKS SPACE(1) UNIT(SYSDA) LRECL(80)\",\n             \"BLKSIZE(0) RECFM(F B) REU\")\n    select\n    when dsorg = 'PO'\n    then do\n      uti.1 = ' COPY INDD=UT1,OUTDD=UT2'\n      uti.0 = 1\n      utp = 'IEBCOPY'\n      cc = rc\n      end\n    when dsorg = 'PS'\n    then do\n      u = 0\n      u = u+1; uti.u = ' GENERATE MAXFLDS=1 '\n      if lrecl <> minlrecl\n      then do\n        u = u+1; uti.u = ' RECORD FIELD=('minlrecl') '\n        end\n      uti.0 = u\n      utp = 'IEBGENER'\n      end\n    when object = 'AIX'\n    then do /* Just rebuild it rather than copy */\n      uti.1 = \" BLDINDEX INDATASET('\"relate\"') - \"\n      uti.2 = \" OUTDATASET('\"fromdsn\"') \"\n      uti.0 = 2\n      utp = 'IDCAMS'\n      end\n    when dsorg = 'VS'\n    then do\n      uti.1 = ' REPRO INFILE(UT1) OUTFILE(UT2) '\n      uti.0 = 1\n      utp = 'IDCAMS'\n      end\n    otherwise nop\n    end\n    rc = TSO('EXECIO 'uti.0' DISKW UTI (STEM UTI. FINIS')\n    address LINKMVS utp' PARM DDLIST'\n    cc = rc\n    if cc <> 0\n    then do\n      rc = TSO(\"EXECIO * DISKR UTO (STEM UTO. FINIS\")\n      zerrsm = utp\" rc \"cc\n      zerrlm = ''\n      do i = 1 to uto.0\n        if left(word(uto.i,1),3) = 'IEB' | left(word(uto.i,1),3) = 'IDC'\n        then zerrlm = zerrlm\" \"uto.i\n      end i\n      'SETMSG MSG(ISRZ002)'\n      rc = TSO('FREE FI(UTI UTO UT1 UT2)')\n      rc = TSO(\"DELETE '\"todsn\"' PURGE\")\n      iterate\n      end\n    rc = TSO('FREE FI(UTI UTO UT1 UT2)')\n    end\n\n  if object = 'AIX'\n  then do /* We've resized original object */\n    zerrsm = 'Resized'\n    zerrlm = 'Alternate index 'fromdsn' successfully rebuilt'\n    'SETMSG MSG(ISRZ002)'\n    iterate\n    end\n\n  /* Delete original data set */\n  rc = TSO(\"DELETE '\"fromdsn\"' PURGE\")\n  if rc <> 0\n  then do\n    zerrsm = 'Delete failed 'rc\n    zerrlm = tso.1\n    'SETMSG MSG(ISRZ002)'\n    iterate\n    end\n  /* Rename target data set to original name */\n  if dsorg = 'VS'\n  then do\n    rc = TSO(\" ALTER '\"todsn\"' NEWNAME('\"fromdsn\"')\")\n    if rc = 0\n    then rc = TSO(\" ALTER '\"todsn\".D' NEWNAME('\"dname\"')\")\n    if rc = 0 & amorg = 'INDEXED'\n    then rc = TSO(\" ALTER '\"todsn\".I' NEWNAME('\"iname\"')\")\n    end\n  else rc = TSO(\"RENAME '\"todsn\"' '\"fromdsn\"'\")\n  if rc <> 0\n  then do\n    zerrsm = 'Rename failed 'cc\n    zerrlm = tso.1\n    'SETMSG MSG(ISRZ002)'\n    iterate\n    end\n  zerrsm = 'Resized'\n  zerrlm = 'Data set 'fromdsn' successfully resized'\n  'SETMSG MSG(ISRZ002)'\nend\n\nquit:\n  rc = QuitISPF()\n  exit\n\ngetvar:\n  parse arg var\n  p = wordpos(var, vars)\n  return var.p\n\nyyyymmdd: procedure /* convert date from yyyy/ddd to yyyy/mm/dd */\n  parse arg yyyy '/' ddd\n  dm = dpm(yyyy)\n  d = 0\n  do i = 1 by 1 until d > ddd\n    d = d + word(dm,i)\n  end i\n  return yyyy'/'right(i,2,0)'/'right(ddd-d+word(dm,i),2,0)\n\nyyyyddd: procedure /* convert date from yyyy/mm/dd to yyyy/ddd */\n  parse arg yyyy '/' mm '/' dd\n  dm = dpm(yyyy)\n  d = 0\n  do i = 1 to mm-1\n    d = d + word(dm,i)\n  end i\n  return yyyy'/'right(d+dd,3,'0')\n\ndpm: /* returns days-per-month for given year yyyy */\n  parse arg yyyy\n  if ((yyyy//4=0 & yyyy//100<>0) | yyyy//400=0)\n  then return '31 29 31 30 31 30 31 31 30 31 30 31'\n  else return '31 28 31 30 31 30 31 31 30 31 30 31'\n\nattr:\n  w = arg(1)\n  p = wordpos(w, 'NOWRITECHK WRITECHK NONUNIQKEY UNIQKEY')\n  if p > 0\n  then w = word('NOWRITECHECK WRITECHECK NONUNIQUEKEY UNIQUEKEY', p)\n  return w\n\ntso: /* run TSO command */\n  parse arg cmd\n  call outtrap 'tso.'\n  address TSO cmd\n  call outtrap 'OFF'\n  return rc\n\nLoadISPF: /* load ISPF elements that are inline in the REXX source code */\n  'CONTROL ERRORS RETURN'\n  rc = TSO('FREE FI($$ISPF$$)')\n  rc = TSO('ALLOC FI($$ISPF$$) UNIT(VIO) SPACE(5,5) DIR(5)',\n               'LRECL(80) RECFM(F B) BLKSIZE(32000)')\n  'LMINIT DATAID(DATAID) DDNAME($$ISPF$$)'\n  'LMOPEN DATAID('dataid') OPTION(OUTPUT)'\n  keys = 'START PANEL MSG SKEL END'\n  drop data.\n  data.0 = 0\n  found = 0\n  do i = sourceline() to 1 by -1\n    s = sourceline(i)\n    parse upper var s 1 ?? +2 keyword name .\n    select\n    when ?? = './'\n    then do\n      n = wordpos(keyword, keys)\n      select\n      when n = 0\n      then signal quit /* unknown marker */\n      when n = 1\n      then leave i /* top marker */\n      when n = words(keys)\n      then found = 1 /* bottom marker */\n      otherwise /* marker found */\n        if name = ''\n        then signal quit /* Name is missed */\n        if data.0 = 0\n        then iterate i /* empty element */\n        do n = data.0 to 1 by -1\n          s = data.n\n          'LMPUT DATAID('dataid') MODE(INVAR) DATALOC(S) DATALEN(80)'\n        end n\n        'LMMADD DATAID('dataid') MEMBER('name')'\n        drop data.\n        data.0 = 0\n      end\n      end\n    when found = 0\n    then iterate i\n    otherwise /* data element */\n      n = data.0+1\n      data.n = s\n      data.0 = n\n    end\n  end i\n  'LMCLOSE DATAID('dataid')'\n  'LMFREE DATAID('dataid')'\n  dataid = ''\n  'LIBDEF ISPPLIB LIBRARY ID($$ISPF$$) STACK'\n  'LIBDEF ISPMLIB LIBRARY ID($$ISPF$$) STACK'\n  'LIBDEF ISPSLIB LIBRARY ID($$ISPF$$) STACK'\n  return 0\n\nQuitISPF:\n  'CONTROL ERRORS RETURN'\n  if dataid <> ''\n  then do\n    'LMCLOSE DATAID('dataid')'\n    'LMFREE DATAID('dataid')'\n     end\n  'LIBDEF ISPPLIB'\n  'LIBDEF ISPMLIB'\n  'LIBDEF ISPSLIB'\n  rc = TSO('FREE FI($$ISPF$$)')\n  return 0\n\n/* inline ISPF elements follows\n./START\n./PANEL PANELPS\n)ATTR DEFAULT(%+_)\n% TYPE(TEXT) INTENS(HIGH) SKIP(ON)\n+ TYPE(TEXT) INTENS(LOW) SKIP(ON)\n$ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) COLOR(YELLOW)\n# TYPE(OUTPUT) INTENS(LOW) CAPS(OFF) JUST(LEFT)\n@ TYPE(OUTPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)\n_ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) PAD('_')\n\u00a6 AREA(SCRL  ) EXTEND(OFF )\n)BODY WINDOW(64,16) EXPAND(<<) ASIS\n%COMMAND ===> $ZCMD                                         +\n@FROMDSN                                       +\n\u00a6PARMS                                                         \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n)AREA PARMS\n+Keep data  . . . . .$Z+       Submit job . . . . .$Z+\n+\n+Organization . . . .#DSORG +  Creation date  . . .#CREDT      +\n+Record format  . . .$RECFM +  Space units  . . . .$Z          +\n+Record length  . . .$LRECL+   Primary quantity . .$Z     +\n+Block size . . . . .$Z    +   Secondary quantity .$Z     +\n+Data set name type .$Z       +\n+Management class . .$Z       +Volume serial  . . .$Z     +\n+Storage class  . . .$Z       +Device type  . . . .$Z     +\n+Data class . . . . .$Z       +Expiration date  . .$EXPDT      +\n+\n+Current Allocation            Current Utilization\n+Allocated#Z    + . .#Z    +   Used#Z     + . . . .#Z   +\n+Allocated extents  .#Z    +   Used extents . . . .#Z   +\n)INIT\n .ZVARS  = '(KEEP SUBMIT UNITS PRIMARY BLKSIZE SECONDS DSNTYPE +\n             MGMTCLAS VOLUME STORCLAS DEVICE DATACLAS AUNITS ATRACKS +\n             UUNITS UTRACKS AEXTENTS UEXTENTS)'\n .CURSOR = ZCMD\n &KEEP = 'Y'\n &SUBMIT = 'N'\n)REINIT\n)PROC\n VER (&KEEP,NB,LIST,Y,N)\n VER (&SUBMIT,NB,LIST,Y,N,E)\n VER (&FROMDSN,NB,DSNAME)\n VER (&DSNTYPE,NB,LIST,BASIC,LARGE,EXTENDED)\n VER (&PRIMARY,NB,NUM)\n VER (&SECONDS,NB,NUM)\n VER (&LRECL,NB,NUM)\n VER (&UNITS,NB,LIST,TRACK,TRACKS,CYLINDER,BLOCK,BLOCKS)\n VER (&BLKSIZE,NB,NUM)\n VER (&RECFM,NB)\n VER (&EXPDT,STDDATE)\n)END\n./PANEL PANELPO\n)ATTR DEFAULT(%+_)\n% TYPE(TEXT) INTENS(HIGH) SKIP(ON)\n+ TYPE(TEXT) INTENS(LOW) SKIP(ON)\n$ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) COLOR(YELLOW)\n# TYPE(OUTPUT) INTENS(LOW) CAPS(OFF) JUST(LEFT)\n@ TYPE(OUTPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)\n_ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) PAD('_')\n\u00a6 AREA(SCRL  ) EXTEND(OFF )\n)BODY WINDOW(64,16) EXPAND(<<) ASIS\n%COMMAND ===> $ZCMD                                         +\n@FROMDSN                                       +\n\u00a6PARMS                                                         \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n)AREA PARMS\n+Keep data  . . . . .$Z+       Submit job . . . . .$Z+\n+\n+Organization . . . .#DSORG +  Creation date  . . .#CREDT      +\n+Record format  . . .$RECFM +  Space units  . . . .$Z          +\n+Record length  . . .$LRECL+   Primary quantity . .$Z     +\n+Block size . . . . .$Z    +   Secondary quantity .$Z     +\n+Data set name type .$Z       +Directory blocks . .$Z     +\n+Management class . .$Z       +Volume serial  . . .$Z     +\n+Storage class  . . .$Z       +Device type  . . . .$Z     +\n+Data class . . . . .$Z       +Expiration date  . .$EXPDT      +\n+\n+Current Allocation            Current Utilization\n+Allocated#Z    + . .#Z    +   Used#Z     + . . . .#Z   +\n+Allocated extents  .#Z    +   Used extents . . . .#Z   +\n+Maximum dir. blocks #Z    +   Used dir. blocks . .#Z   +\n)INIT\n .ZVARS  = '(KEEP SUBMIT UNITS PRIMARY BLKSIZE SECONDS DSNTYPE DIRBLK +\n             MGMTCLAS VOLUME STORCLAS DEVICE DATACLAS AUNITS ATRACKS +\n             UUNITS UTRACKS AEXTENTS UEXTENTS ADIRBLK UDIRBLK)'\n .CURSOR = ZCMD\n &KEEP = 'Y'\n &SUBMIT = 'N'\n)REINIT\n)PROC\n VER (&KEEP,NB,LIST,Y,N)\n VER (&SUBMIT,NB,LIST,Y,N,E)\n VER (&FROMDSN,NB,DSNAME)\n VER (&DSNTYPE,NB,LIST,PDS,LIBRARY)\n VER (&PRIMARY,NB,NUM)\n VER (&SECONDS,NB,NUM)\n VER (&LRECL,NB,NUM)\n VER (&UNITS,NB,LIST,TRACK,TRACKS,CYLINDER,BLOCK,BLOCKS)\n VER (&BLKSIZE,NB,NUM)\n VER (&RECFM,NB)\n VER (&EXPDT,STDDATE)\n IF (&DSNTYPE = 'PDS')\n    VER (&DIRBLK,NB,NUM)\n)END\n./PANEL PANELVS\n)ATTR DEFAULT(~+_)\n+ TYPE(TEXT) INTENS(LOW) SKIP(ON)\n$ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) COLOR(YELLOW)\n# TYPE(OUTPUT) INTENS(LOW) CAPS(OFF) JUST(LEFT)\n@ TYPE(OUTPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)\n_ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) PAD('_')\n\u00a6 AREA(SCRL  ) EXTEND(OFF )\n)BODY WINDOW(64,16) EXPAND(<<) ASIS\n%COMMAND ===> $ZCMD                                         +\n@FROMDSN                                       +\n\u00a6PARMS                                                         \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n)AREA PARMS\n+Keep data  . . . . .$Z+       Submit job . . . . .$Z+\n+\n+Organization . . . .#RECORG+  Creation date  . . .#CREDT      +\n+Average length . . .$Z    +   Expiration date  . .$EXPDT      +\n+Maximal length . . .$Z    +   Data class . . . . .$Z       +\n+Management class . .$Z       +Storage class  . . .$Z       +\n+\n@DNAME\n+Space units  . . . .$Z       +Device type  . . . .$Z     +\n+Primary quantity . .$Z     +  Secondary quantity .$Z     +\n+Freespace %CI  . . .$Z     +  Freespace %CA  . . .$Z     +\n+Volume serial  . . .$Z     +\n+\n)INIT\n .ZVARS  = '(KEEP SUBMIT AVGLRECL MAXLRECL DATACLAS MGMTCLAS STORCLAS +\n             DUNITS DDEVICE DPIMARY DSECONDS DFREECI DFREECA DVOLUME)'\n .CURSOR = ZCMD\n &KEEP = 'Y'\n &SUBMIT = 'N'\n)REINIT\n)PROC\n VER (&KEEP,NB,LIST,Y,N)\n VER (&SUBMIT,NB,LIST,Y,N,E)\n VER (&FROMDSN,NB,DSNAME)\n VER (&DPRIMARY,NB,NUM)\n VER (&DSECONDS,NB,NUM)\n VER (&AVGLRECL,NB,NUM)\n VER (&MAXLRECL,NB,NUM)\n VER (&DUNITS,NB,LIST,TRACK,TRACKS,CYLINDER,BLOCK,BLOCKS)\n VER (&EXPDT,STDDATE)\n)END\n./PANEL PANELKS\n)ATTR DEFAULT(~+_)\n+ TYPE(TEXT) INTENS(LOW) SKIP(ON)\n$ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) COLOR(YELLOW)\n# TYPE(OUTPUT) INTENS(LOW) CAPS(OFF) JUST(LEFT)\n@ TYPE(OUTPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)\n_ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT) PAD('_')\n\u00a6 AREA(SCRL  ) EXTEND(OFF )\n)BODY WINDOW(64,16) EXPAND(<<) ASIS\n%COMMAND ===> $ZCMD                                         +\n@FROMDSN                                       +\n\u00a6PARMS                                                         \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n\u00a6                                                              \u00a6\n)AREA PARMS\n+Keep data  . . . . .$Z+       Submit job . . . . .$Z+\n+\n+Organization . . . .#RECORG + Creation date  . . .#CREDT      +\n+Average length . . .$Z    +   Expiration date  . .$EXPDT      +\n+Maximal length . . .$Z    +   Data class . . . . .$Z       +\n+Management class . .$Z       +Storage class  . . .$Z       +\n+\n@DNAME\n+Space units  . . . .$Z       +Device type  . . . .$Z     +\n+Primary quantity . .$Z     +  Secondary quantity .$Z     +\n+Freespace %CI  . . .$Z     +  Freespace %CA  . . .$Z     +\n+Volume serial  . . .$Z     +\n+\n@INAME\n+Space units  . . . .$Z       +Device type  . . . .$Z     +\n+Primary quantity . .$Z     +  Secondary quantity .$Z     +\n+Freespace %CI  . . .$Z     +  Freespace %CA  . . .$Z     +\n+Volume serial  . . .$Z     +\n)INIT\n .ZVARS  = '(KEEP SUBMIT AVGLRECL MAXLRECL DATACLAS MGMTCLAS STORCLAS +\n             DUNITS DDEVICE DPRIMARY DSECONDS DFREECI DFREECA DVOLUME +\n             IUNITS IDEVICE IPRIMARY ISECONDS IFREECI IFREECA IVOLUME)'\n .CURSOR = ZCMD\n &KEEP = 'Y'\n &SUBMIT = 'N'\n)REINIT\n)PROC\n VER (&KEEP,NB,LIST,Y,N)\n VER (&SUBMIT,NB,LIST,Y,N,E)\n VER (&FROMDSN,NB,DSNAME)\n VER (&DPRIMARY,NB,NUM)\n VER (&DSECONDS,NB,NUM)\n VER (&IPRIMARY,NB,NUM)\n VER (&ISECONDS,NB,NUM)\n VER (&AVGLRECL,NB,NUM)\n VER (&MAXLRECL,NB,NUM)\n VER (&IUNITS,NB,LIST,TRACK,TRACKS,CYLINDER,CYLINDERS,BLOCK,BLOCKS)\n VER (&DUNITS,NB,LIST,TRACK,TRACKS,CYLINDER,CYLINDERS,BLOCK,BLOCKS)\n VER (&EXPDT,STDDATE)\n)END\n./PANEL CONFIRM\n)ATTR\n+  TYPE(TEXT) INTENS(LOW ) SKIP(ON ) COLOR(BLUE  )\n%  TYPE(TEXT) INTENS(HIGH) SKIP(ON ) COLOR(WHITE )\n~  TYPE(TEXT) INTENS(HIGH) CAPS(OFF) COLOR(YELLOW) HILITE(REVERSE)\n)BODY WINDOW(64,11)\n+\n+  ~Warning +\n+\n+   Keep data option is set to N. It mean, than any existing\n+   data would be lost and this is last choice to save data.\n+\n+   Press%ENTER+key to confirm and continue\n+   Press%CANCEL+or%EXIT+to cancel request\n+\n)INIT\n)PROC\n)END\n./SKEL SKELJOB\n)SEL &BJC1 \u00ac= &Z\n&BJC1\n)ENDSEL\n)SEL &BJC2 \u00ac= &Z\n&BJC2\n)ENDSEL\n)SEL &BJC3 \u00ac= &Z\n&BJC3\n)ENDSEL\n)SEL &BJC4 \u00ac= &Z\n&BJC4\n)ENDSEL\n)SET SLASH = /\n)SET JCLCM = &SLASH.&SLASH.*\n)SEL &KEEP = N\n&JCLCM\n&JCLCM  Warning\n&JCLCM\n&JCLCM  This job reallocate existing data set &FROMDSN.\n&JCLCM  All existing data would be lost\n&JCLCM\n)ENDSEL\n./SKEL SKELPS\n)CM JOB SKELETON USED BY RESIZE PS DATA SET\n)IM SKELJOB\n//ALLOCATE EXEC PGM=IEFBR14\n//SYSUT2   DD  DISP=(NEW,CATLG),DSN=&TODSN,\n)SEL &DSNTYPE = LARGE OR &DSNTYPE = EXTENDED\n//             DSNTYPE=&DSNTYPE,\n)ENDSEL\n)SEL &UNITS = CYLINDER\n//             SPACE=(CYL,(&PRIMARY,&SECONDS)),\n)ENDSEL\n)SEL &UNITS = TRACK\n//             SPACE=(TRK,(&PRIMARY,&SECONDS)),\n)ENDSEL\n)SEL &UNITS = BLOCK\n//             SPACE=(&BLKSIZE,(&PRIMARY,&SECONDS)),\n)ENDSEL\n)SEL &EXPDT \u00ac= &Z\n//             EXPDT=&EXPDT,\n)ENDSEL\n//             DCB=(RECFM=&RECFM,LRECL=&LRECL,BLKSIZE=&BLKSIZE)\n)SEL &KEEP = Y\n//COPY     EXEC PGM=IEBGENER\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  DISP=SHR,DSN=&FROMDSN\n//SYSUT2   DD  DISP=SHR,DSN=&TODSN\n//SYSIN    DD  *\n GENERATE MAXFLDS=1\n)SEL &MAXLRECL \u00ac= &LRECL\n RECORD FIELD=(&MAXLRECL)\n)ENDSEL\n//         IF  (COPY.RC = 0) THEN\n)ENDSEL\n//DELETE   EXEC PGM=IDCAMS\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  *\n DELETE &FROMDSN PURGE\n ALTER &TODSN -\n       NEWNAME(&FROMDSN)\n)SEL &KEEP = Y\n//         ENDIF\n)ENDSEL\n//\n./SKEL SKELPO\n)CM JOB SKELETON USED BY RESIZE PO DATA SET\n)IM SKELJOB\n//ALLOCATE EXEC PGM=IEFBR14\n//SYSUT2   DD  DISP=(NEW,CATLG),DSN=&TODSN,\n)SEL &DSNTYPE = LIBRARY\n//             DSNTYPE=&DSNTYPE,\n)ENDSEL\n)SEL &UNITS = CYLINDER\n//             SPACE=(CYL,(&PRIMARY,&SECONDS,&DIRBLK)),\n)ENDSEL\n)SEL &UNITS = TRACK\n//             SPACE=(TRK,(&PRIMARY,&SECONDS,&DIRBLK)),\n)ENDSEL\n)SEL &UNITS = BLOCK\n//             SPACE=(&BLKSIZE,(&PRIMARY,&SECONDS,&DIRBLK)),\n)ENDSEL\n)SEL &EXPDT \u00ac= &Z\n//             EXPDT=&EXPDT,\n)ENDSEL\n//             DCB=(RECFM=&RECFM,LRECL=&LRECL,BLKSIZE=&BLKSIZE)\n)SEL &KEEP = Y\n//COPY     EXEC PGM=IEBCOPY\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  DISP=SHR,DSN=&FROMDSN\n//SYSUT2   DD  DISP=SHR,DSN=&TODSN\n//SYSIN    DD  *\n COPY INDD=SYSUT1,OUTDD=SYSUT2\n//         IF  (COPY.RC = 0) THEN\n)ENDSEL\n//DELETE   EXEC PGM=IDCAMS\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  *\n DELETE &FROMDSN PURGE\n ALTER &TODSN -\n       NEWNAME(&FROMDSN)\n)SEL &KEEP = Y\n//         ENDIF\n)ENDSEL\n//\n./SKEL SKELVS\n)CM JOB SKELETON USED BY RESIZE VS DATA SET\n)IM SKELJOB\n//DEFINE   EXEC PGM=IDCAMS\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  *\n  DEFINE CLUSTER( -\n    NAME(&TODSN) -\n    &AMORG -\n    &AMATTR -\n)SEL &EXPDT \u00ac= &Z\n    TO(&EXPDT) -\n)ENDSEL\n)SEL &AMORG = INDEXED\n    KEYS(&KEYLEN &RKP) -\n)ENDSEL\n)SEL &AMORG = LINEAR\n    RECORDSIZE(&AVGLRECL &MAXLRECL) -\n)ENDSEL\n)SEL &SMS NE NO\n)SEL &STORCLAS \u00ac= &Z\n    STORAGECLASS(&STORCLAS) -\n)ENDSEL\n)SEL &MGMTCLAS \u00ac= &Z\n    MANAGEMENTCLASS(&MGMTCLAS) -\n)ENDSEL\n)SEL &DATACLAS \u00ac= &Z\n    DATACLASS(&DATACLAS) -\n)ENDSEL\n)ENDSEL\n    SHAREOPTIONS(&SHROPT) -\n    ) -\n  DATA ( -\n    NAME(&TODSN..D) -\n    &DUNITS.S(&DPRIMARY &DSECONDS) -\n)SEL &SMS \u00ac= ONLY\n    VOLUMES(&DVOLUME) -\n)ENDSEL\n)SEL &DFREECA \u00ac= 0 | &DFREECI \u00ac= 0\n    FREESPACE(&DFREECI &DFREECA) -\n)ENDSEL\n    ) -\n)SEL &AMORG = INDEXED\n  INDEX ( -\n    NAME(&TODSN..I) -\n    &DUNITS.S(&IPRIMARY &ISECONDS) -\n)SEL &SMS \u00ac= ONLY\n    VOLUMES(&IVOLUME) -\n)ENDSEL\n)SEL &IFREECA \u00ac= 0 | &IFREECI \u00ac= 0\n    FREESPACE(&IFREECI &IFREECA) -\n)ENDSEL\n    ) -\n)ENDSEL\n  )\n)SEL &KEEP = Y\n//COPY     EXEC PGM=IDCAMS\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  DISP=SHR,DSN=&FROMDSN\n//SYSUT2   DD  DISP=SHR,DSN=&TODSN\n//SYSIN    DD  *\n  REPRO INFILE=SYSUT1,OUTFILE=SYSUT2\n//         IF  (COPY.RC = 0) THEN\n)ENDSEL\n//DELETE   EXEC PGM=IDCAMS\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  *\n DELETE &FROMDSN PURGE\n ALTER &TODSN -\n       NEWNAME(&FROMDSN)\n ALTER &TODSN..D -\n       NEWNAME(&FROMDSN..D)\n)SEL &AMORG = INDEXED\n ALTER &TODSN..I -\n       NEWNAME(&FROMDSN..I)\n)ENDSEL\n)SEL &KEEP = Y\n//         ENDIF\n)ENDSEL\n//\n./END\n*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RESIZE#": {"ttr": 2305, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00V\\x01\\x18\\x10\\x0f\\x01\\x18\\x10\\x0f\\x19&\\x00S\\x00S\\x00\\x00\\xc8\\xc5\\xd3\\xd7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-04-10T00:00:00", "modifydate": "2018-04-10T19:26:56", "lines": 83, "newlines": 83, "modlines": 0, "user": "HELP"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "TRAP": {"ttr": 2308, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x01\\x01\\x18\\x17\\x8f\\x01\\x18\\x17\\x8f\\x117\\x00A\\x00A\\x00\\x00\\xc2\\xd3\\xc9\\xe9\\xd5\\xc5\\xe3\\xe2@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-06-27T00:00:00", "modifydate": "2018-06-27T11:37:01", "lines": 65, "newlines": 65, "modlines": 0, "user": "BLIZNETS"}, "text": "/* REXX/370 */\n/*\n\nFunction:\n       Run TSO command, trap command output and view/browse/edit it.\n       This procedure primarily designed for use on ISPF C/S(ISPF\n       Client/Server) session, where normal TSO command output issued\n       via TPUT service didn't displayed. Also may be usefull during\n       \"normal\" ISPF session to run TSO command or CLIST that produces\n       large output, like LISTALC, LISTCAT etc. Especially useful with\n       TSO HELP.\n       Alternative of Mark Zelden's TSOB, TSOV, TSOE.\n\nSyntax:\n       TRAP command \u00a2Browse \u00a6 View \u00a6 Edit!\n\n(C) 2006-2018 Gregori Bliznets gbliznets@iba.by\n\n*/\ntrace off\nparse source system . myid . . . . ispf .\nif ispf <> 'ISPF'\nthen do\n  say myid' should run under ISPF'\n  exit 20\n  end\nparse arg command\nviewer = ''\ncommand = strip(command)\np = lastpos(' ', command)\nif p > 0\nthen do\n  lastword = translate(substr(command, p+1))\n  select\n  when abbrev('BROWSE', lastword, 1)\n  then viewer = 'BROWSE'\n  when abbrev('VIEW', lastword, 1)\n  then viewer = 'VIEW'\n  when abbrev('EDIT', lastword, 1)\n  then viewer = 'EDIT'\n  otherwise nop\n  end\n  end\nif viewer <> ''\nthen command = substr(command, 1, p-1)\nelse viewer = 'BROWSE'\naddress ISPEXEC 'CONTROL ERRORS RETURN'\ncall outtrap 'responce.'\naddress TSO command\ncc = rc\ncall outtrap 'OFF'\nif cc <> 0\nthen do\n  zerrsm = \"Return code \"cc\n  zerrlm = \"Return code from command is \"cc\n  zerralrm = \"YES\"\n  zerrhm = \"*\"\n  address ISPEXEC \"SETMSG MSG(ISRZ002)\"\n  end\nif responce.0 > 0\nthen do\n  address ISPEXEC 'VGET (ZTEMPN ZTEMPF)'\n  address TSO 'EXECIO * DISKW 'ztempn' (FINIS STEM RESPONCE.'\n  address ISPEXEC viewer\" DATASET('\"ztempf\"')\"\nexit cc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TRAP#": {"ttr": 2310, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00V\\x01\\x18\\x10\\x0f\\x01\\x18\\x10\\x0f\\x19&\\x00\\x12\\x00\\x12\\x00\\x00\\xc8\\xc5\\xd3\\xd7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-04-10T00:00:00", "modifydate": "2018-04-10T19:26:56", "lines": 18, "newlines": 18, "modlines": 0, "user": "HELP"}, "text": "Function:\n \tThis simple procedure run TSO command, trap command output and\n        view/browse/edit it. Procedure primarily designed for use on ISPF\n        C/S (ISPF Client/Server) session, where normal TSO command output\n        issued via TPUT service didn't displayed. Also may be useful on a\n        \"normal\" ISPF session to run TSO command or CLIST that produces\n        large output, like LISTALC, LISTCAT etc.\n\n\nSyntax:\n        TRAP TSO command \u00a2BROWSE \u00a6 EDIT \u00a6 VIEW!\n\nUsage:\n  \tSpecify desired TSO command or line-mode TSO procedure.\n\n        TRAP may be used on ISPF =6 or on ISPF COMMAND prompt.\n\n        Alternative of Mark Zelden's TSOB, TSOV, TSOE.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT941/FILE941.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT941", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}