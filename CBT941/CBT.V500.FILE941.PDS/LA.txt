/* MVS/TSO REXX/370 */
/*
Function:
       LISTALC alternative - list allocated data sets as a set of ALLOC commands
       or JCL DD statements. Under ISPF this procedure may be used together with
       TRAP or Mark Zelden's TSOB, TSOV, TSOE to browse output.

Syntax:
       LA ¢TSO ¦ JCL!

(C) 2006-2018 Gregori Bliznets gbliznets@iba.by

*/
parse upper arg option .
select
when option = ''
then jcl = 0
when abbrev(option, 'TSO')
then jcl = 0
when abbrev(option, 'JCL')
then jcl = 1
otherwise
  say 'Invalid option: 'option
  exit 16
end
call outtrap 'stem.'
'LISTALC STATUS'
call outtrap 'off'
i = 2
dd.0 = 0
do while i < stem.0
  parse var stem.i dsname ddname disp
  i = i + 1
  select
  when dsname = 'NULLFILE' then nop
  when dsname = 'TERMFILE' then nop
  otherwise
    parse var stem.i 3 ddname +8 disp
    i = i + 1
  end
  if ddname = ''
  then do
    n = dd.0
    dd.n = dd.n' 'dsname
    end
  else do
    n = dd.0 + 1
    dd.n = ddname' 'dsname
    dd.0 = n
    end
end
do i = 1 to dd.0
  parse var dd.i ddname dsnames
  dsnames = strip(dsnames)
  w = words(dsnames)
  select
  when dsnames = 'NULLFILE'
  then do
    if jcl = 0
    then say 'ALLOC 'left('FI('ddname')', 12)' DUMMY'
    else say '//'left(ddname, 8)' DD DUMMY'
    end
  when dsnames = 'TERMFILE'
  then do
    if jcl = 0
    then say 'ALLOC 'left('FI('ddname')', 12)' DSN(*)'
    else say '//'left(ddname, 8)' DD SYSOUT=*'
    end
  when w = 1
  then do
    if jcl = 0
    then say 'ALLOC 'left('FI('ddname')', 12)' DSN('''dsnames''')'
    else say '//'left(ddname, 8)' DD DISP=SHR,DSN='dsnames
    end
  otherwise
    do j = 1 to w
      dsname = word(dsnames, j)
      select
      when j = 1 & jcl = 0
      then say 'ALLOC 'left('FI('ddname')', 12)' DSN('''dsname''' + '
      when j = 1
      then say '//'left(ddname, 8)' DD DISP=SHR,DSN='dsname
      when j = w & jcl = 0
      then say copies(' ', 23)''''dsname''')'
      when jcl = 1
      then say '//         DD DISP=SHR,DSN='dsname
      otherwise
        say copies(' ', 23)''''dsname''' + '
      end
    end j
  end
end i
exit 0
